#!/usr/bin/perl -w

#
#    Source modules that we can feasibly strip
# out immediately.
#
my @system_modules = (
	'python', 'zlib', 'bitstream_vera_fonts', 'freetype', 'jpeg'
);

#
# More advanced topics for further work
#
my @incomplete_modules = (
	'curl', 'dictionaries', 'dllcompat',
	'expat', 'icu', 'libxml2', 'libxmlsec', 'moz',
	'nas', 'neon', 'msfontextract', 'openssl', 'pspell',
	'regexp', 'rhino', 'sablot', 'sane', 'stlport', 'twain',
	'unixODBC', 'x11extension', 'zlib'
);

# Perl grep is appallingly useless
sub working_grep($@)
{
  my $match = shift;
  while (my $elem = shift) {
    $elem =~ m/$match/ && return 1;
  }
  return 0;
}

sub read_modules($)
{
  my $dirh;
  my $path = shift;
  my @elems;
  my @sanity = ( 'solenv', 'sc', 'sw', 'jpeg', 'moz', 'curl' );

  opendir ($dirh, $path) || die "Can't open $path: $!";  
  @elems = readdir ($dirh);
  closedir ($dirh);

  for my $check (@sanity) {
    working_grep ($check, @elems) || die "Missing module $check\n";
  }

  return @elems;
}

my $dest;
my $src;

for my $arg (@ARGV) {
  if ($arg eq '-h' || $arg eq '--help') {
    print "src-package: <path-to-src> [destination]\n";
    print "  the src will be packed into several archives\n";
    print"   prefixed by the last path element \n";
    exit 0;
  }
  if (!defined $src) {
    $src = $arg;
  }
  if (!defined $dest) {
    $dest = $arg;
  }
}


my @modules;

@modules = read_modules ($src);

