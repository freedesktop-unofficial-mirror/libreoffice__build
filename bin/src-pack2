#!/usr/bin/perl -w

use strict;

# Towards a more modular build ...

my $tar_opts='cj';
my %module_map = (
    'ure' => [ 'bridges', 'cli_ure', 'codemaker', 'cppu', 'cppuhelper',
	       'cpputools', 'idlc', 'io', 'javaunohelper', 'jurt', 'jut',
	       'jvmaccess', 'jvmfwk', 'offapi', 'offuh', 'pyuno', 'rdbmaker',
	       'registry', 'remotebridges', 'ridljar', 'sal', 'salhelper',
	       'stoc', 'store', 'udkapi', 'unoil', 'ure', 'xml2cmp' ],
    'sdk' => [ 'autodoc', 'cosv', 'odk', 'sdk_oo', 'udm', 'unodevtools' ],
    'base' => [ 'dbaccess', 'reportdesign' ],
    'calc' => [ 'sc', 'scaddins', 'sccomp', 'chart2' ],
    'l10n' => [ 'extras', 'helpcontent2', 'readlicense_oo' ],
    'writer' => [ 'sw', 'starmath' ],
    'impress' => [ 'sd', 'animations', 'slideshow', 'sdext' ],
    'artwork' => [ 'default_images', 'external_images', 'ooo_custom_images' ],
    'filters' => [ 'binfilter', 'filter', 'hwpfilter', 'unoxml',
		   'writerfilter', 'writerperfect', 'xmerge', 'oox' ],
    'testing' => [ 'qadevOOo', 'smoketestoo_native', 'testshl2', 'testtools' ],
    'bootstrap' => [ 'config_office', 'dmake', 'instsetoo_native', 'scp2',
		     'solenv', 'soltools', 'stlport' ],
    'libs_gui' => [ 'basebmp', 'basegfx', 'canvas', 'comphelper', 'cppcanvas',
		    'dtrans', 'goodies', 'i18npool', 'i18nutil', 'o3tl',
		    'padmin', 'psprint', 'psprint_config', 'regexp', 'rsc', 
		    'sax', 'sot', 'svtools', 'toolkit', 'tools', 'transex3',
		    'ucbhelper', 'unotools', 'vcl', 'vos' ],
    'libs_core' => [ 'avmedia', 'basic', 'configmgr', 'connectivity',
		     'desktop', 'embeddedobj', 'eventattacher', 'fileaccess',
		     'fpicker', 'framework', 'idl', 'linguistic',
		     'officecfg', 'oovbaapi', 'sandbox', 'scripting',
		     'sfx2', 'shell', 'sj2', 'svx', 'sysui',
		     'ucb', 'uui', 'xmlhelp', 'xmloff', 'xmlscript' ],
    'libs_extern' => [ 'afms', 'agg', 'beanshell', 'epm', 'external',
		       'fondu', 'freetype', 'hsqldb', 'jfreereport',
		       'libegg', 'libtextcat', 'libxmlsec', 'msfontextract',
		       'np_sdk', 'rhino', 'sane', 'twain', 'lpsolve', 'icc',
		       'openssl', 'unixODBC', 'vigra', 'x11_extensions',
		       'xpdf', 'hyphen', 'libwpd', 'lucene', 'redland' ],
    'components' => [ 'accessibility', 'automation', 'basctl', 'bean',
		      'crashrep', 'embedserv', 'extensions', 'forms',
		      'javainstaller2', 'lingucomponent', 'MathMLDTD',
		      'package', 'setup_native', 'UnoControls', 'wizards',
		      'xmlsecurity' ],
    'postprocess' => [ 'postprocess', 'packimages' ],
    'libs_extern_sys' => [ 'berkeleydb', 'bitstream_vera_fonts', 'expat', 'icu', 
			   'jpeg', 'libxml2', 'libxslt', 'moz', 'neon',
			   'python', 'zlib', 'xalan', 'boost', 'curl',
			   'dictionaries', 'cairo', 'hunspell' ]
);
my $force = 0;

my $src;
my $dest;

sub print_help_and_exit()
{
    print "src-package: <src-directory-name> [<destination-directory>] [--force]\n";
    print "   the src will be un-packed into several archives\n";
    print "   prefixed by the last path element\n";
    print "   --force: ignore missing modules\n";
    exit 0;
}

sub slurp_dir_to_hash($)
{
    my $src = shift;
    my %entries;

    opendir my $dirh, "$src" || die "Can't open $src: $!";
    while (my $entry = readdir ($dirh)) {
	next if ($entry =~ /^\./);
	$entries{$entry} = 1;
    }
    closedir ($dirh);
    return \%entries;
}

sub verify_module_map($$)
{
    my $src = shift;
    my $module_map = shift;
    my $failed = 0;

    my $modules = slurp_dir_to_hash ($src);

    print "Verifying module map ...";
    
    for my $section (keys %{$module_map}) {
#	print "check for $section\n";
	for my $module (@{$module_map->{$section}}) {
#	    print "\tcheck for $module\n";
	    if (!defined $modules->{$module}) {
		print "\n\nError: section '$section' contains non-existent module '$module'\n\n";
		$failed = 1 if (!$force);
	    }
	    delete $modules->{$module};
	}
    }
    my @left_over = keys %{$modules};
    if (@left_over) {
	print "\n\nError: modules not included in any section: '@left_over'\n\n";
	$failed = 1;
    }
    
    die "Failed." if ($failed);
    print " done\n";
}

for my $arg (@ARGV) {
    if ($arg eq "--help" || $arg eq '-h') {
	print_help_and_exit();
    } elsif ($arg eq '--force') {
	$force = 1;
    } elsif (!defined $src) {
	$src = $arg;
    } elsif (!defined $dest) {
	$dest = $arg;
    } else {
	die "Too many arguments '$arg'";
    }
}

if (!defined $src) {
    print_help_and_exit();
}
$dest = '.' if (!defined $dest);

-f "$src/vcl/source/gdi/outdev.cxx" || die "$src doesn't look like an OO.o source tree";

verify_module_map ($src, \%module_map);

print STDERR "packing source in $src to directory $dest\n";

for my $a (keys %module_map) {
    print STDERR "\tpack $a ...";
    my $dest_tar = "$dest/$src-$a.tar.bz2";
    my $cmd = "tar $tar_opts --dereference -f $dest_tar ";
    my $newsrc = "$src-$a";
    symlink ($src, $newsrc ) if (! -l $newsrc);

    for my $b (@{$module_map{$a}}) {
	$cmd .= "$newsrc/$b " if (-d "$newsrc/$b");
    }
    if (-f $dest_tar) {
	print "\twarning: $dest_tar exists, skipping\n";
    } else {
	system ($cmd) && die "Failed to execute '$cmd': $!";
    }

    $cmd = "md5sum $dest_tar > $dest_tar.md5";
    system ($cmd) && die "Failed to generate md5: '$cmd': $!";
    print STDERR " done\n";
}
