#!/usr/bin/perl
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
	if $running_under_some_shell;
#!/usr/bin/perl

use strict;

my $verbose = 0;

# indexes for the various types of result file entries
my @indexes = (0,1,2,3,4,5,6,7,8);
# indexed by types 0,1,2,3
my @totalCounts;
# array of hashes of hashes of arrays;
# 1st index is message type 0,1,2,3;
# 2nd index is resource file name
# 3rd index is problem type
# the value is the message
my @logMessages;
# array of hashes:
# 1st index is message type 0,1,2,3;
# 2nd index is problem type
my @logProblems;

foreach my $i (@indexes) {
    $totalCounts[$i] = 0;
    $logMessages[$i] = {};
    $logProblems[$i] = {};
}

# User readable strigs for the various results file entries
my @typeMessages = (
	"Runned",
	"Test Cases",
	"Error",
	"Call Stack",
	"Message",
	"Warning",
	"Assertion",
	"QA Error",
	"Assert Stack"
	);

# FIXME, could this be automatized?
my %knownIDs = (
	'20000'	 => 'could not be executed',
	'20008'  => 'server timeout while waiting for answer',
	'20009'  => 'application has been restarted',
	'20014'  => 'XXX errors occured',
	'20016'  => 'XXX warnings occured',
	'20023'  => 'XXX warnings occured during initialization',
	'20018'  => 'Slot/Control unknown',
	'22014'	 => 'unknown method',
	'22018'  => 'could not be found',
	'22019'  => 'is not visible',
	'22020'  => 'could not be accessed',
	'22021'  => 'entry member XX is too large at Select. Max allowd is YY',
	'22022'  => 'entry member XX is too small at Select. Min allowd is YY',
	'22030'  => 'tab page not found at SetPage',
	'22035'  => 'entry at select not found',
	'22041'  => 'TearOff failed in ToolBot at TeadOff',
	'22048'  => 'There is no Cancel button at Cancel',
	'22049'  => 'There is no Yes button at Yes',
	'22050'  => 'There is no No button at No',
	);

sub AnalyzeResFile($) {
    my $resFile = shift;
    
    open (RES_FILE, $resFile) || die "can't open $resFile for reading: $!\n";

    my $resFileName = $resFile;
    $resFileName =~ s/.*\///;


    printf "Analyzing $resFile ...\n" if ($verbose);

    my $knownFileFormat = 0;

    while (my $line = <RES_FILE>) {
        chomp $line;              
    
	if ($line =~ /^File Format Version: 3/) {
	    $knownFileFormat=1;
	    next;
	}
	
	if ($line =~ /^([0-9]);([^;]*);([^;]*);([^;]*);([^;]*);(.*)/) {
	    my $type = "$1";
	    my $message = "$6";
	
	    # total counts
	    $totalCounts[$type] += 1;
	    
	    # quess problem type
	    my $problem = "unknown";
#	    print "$message\n";
	    if ($message =~ /\%ResId=([0-9]*)/) {
		$problem = "$1";
	    }

	    $logProblems[$type]{$problem} = 1;

	    $logMessages[$type]{$resFileName} = {} unless (defined $logMessages[$type]{$resFileName});
	    $logMessages[$type]{$resFileName}{$problem} = [] unless (defined $logMessages[$type]{$resFileName}{$problem});
	    push @{ $logMessages[$type]{$resFileName}{$problem} }, "$message";

	    next;
	}

	die "Error: $resFile:$.: broken file format\n";
    }

    ($knownFileFormat) || die "Error: $resFile: Unknown file format\n";
}

# various statistics

sub StatGlobal() {
    print "=====================================================\n";
    print "All tests summary\n";
    print "=====================================================\n";

    foreach my $i (@indexes) {
	printf STDOUT "%-15s: $totalCounts[$i]\n", $typeMessages[$i];
    }
    print "\n\n\n";

}

sub StatOfTypeByFiles($) {
    my $type = shift;
    
    print "Numbers of $typeMessages[$type] in files:\n";
    print "------------------------------------------\n";

    foreach my $resFileName (keys %{$logMessages[$type]}) {
	my $count = 0;
	foreach my $problem (keys %{$logMessages[$type]{$resFileName}}) {
	    $count += scalar @{$logMessages[$type]{$resFileName}{$problem}};
	}
        printf "$resFileName ($count)\n";
    }
    
    print "\n\n";
}

sub MessagesOfTypeByFiles($) {
    my $type = shift;
    
    print "Messages with $typeMessages[$type] in files:\n";
    print "---------------------------------------------------\n";

    foreach my $resFileName (keys %{$logMessages[$type]}) {
	foreach my $problem (keys %{$logMessages[$type]{$resFileName}}) {
	    foreach my $msg (@{ $logMessages[$type]{$resFileName}{$problem} }) {
    		printf "$resFileName: $msg\n";
	    }
	}
    }
    
    print "\n\n";
}

sub StatOfTypeByProblems($) {
    my $type = shift;
    
    print "Numbers of particular $typeMessages[$type]:\n";
    print "--------------------------------------------------------\n";

    # we would want to sort results before printing
    my @result;
    foreach my $problem (keys %{$logProblems[$type]}) {
	my $count = 0;
        foreach my $resFileName (keys %{$logMessages[$type]}) {
	    if (defined $logMessages[$type]{$resFileName}{$problem}) {
		$count += scalar @{$logMessages[$type]{$resFileName}{$problem}};
	    }
	}

	push @result, [$problem,$count];
    }

#    foreach my $resRef ( sort { $a->[1] <=> $b->[1] } @result ) {
    foreach my $resRef ( sort { $a->[0] <=> $b->[0] } @result ) {
	if (defined $knownIDs{$resRef->[0]}) {
    	    printf "%03d: problem id $resRef->[0]: $knownIDs{$resRef->[0]}\n", $resRef->[1];
	} else {
	    printf "%03d: problem id $resRef->[0]:\n", $resRef->[1];
	}
    }	
    
    print "\n\n";
}

sub StatOfTypeAndProblemByFiles($$) {
    my $type = shift;
    my $problem = shift;
    
    print "Numbers of the $typeMessages[$type], id $problem, in files:\n";
    print "----------------------------------------------------------------\n";

    my $count = 0;
    foreach my $resFileName (keys %{$logMessages[$type]}) {
	if (defined $logMessages[$type]{$resFileName}{$problem}) {
	    my $count = scalar @{$logMessages[$type]{$resFileName}{$problem}};
    	    printf "%03d: $resFileName\n", $count;
	}
    }
    
    print "\n\n";
}

sub StatOfTypebyProblemsAndFiles($) {
    my $type = shift;
    
    print "Numbers of particular $typeMessages[$type] types in files:\n";
    print "===============================================================\n";

    foreach my $problem (keys %{$logProblems[$type]}) {
	StatOfTypeAndProblemByFiles($type, $problem);
    }
    print "\n\n";
}


sub MessagesOfTypeAndProblemByFiles($$) {
    my $type = shift;
    my $problem = shift;
    
    print "Messages with the problem id $problem of $typeMessages[$type]:\n";
    print "----------------------------------------------------------------\n";

    foreach my $resFileName (keys %{$logMessages[$type]}) {
	if (defined $logMessages[$type]{$resFileName}{$problem}) {
	    foreach my $msg (@{ $logMessages[$type]{$resFileName}{$problem} }) {
    		printf "$resFileName: $msg\n";
	    }
	}
    }
    
    print "\n\n";
}

sub MessagesOfTypeByProblemsAndFiles($) {
    my $type = shift;
    
    print "Messages sorted by particular types of $typeMessages[$type]:\n";
    print "===============================================================\n";

    foreach my $problem (keys %{$logProblems[$type]}) {
	MessagesOfTypeAndProblemByFiles($type, $problem);
    }
    print "\n\n";
}


###########################################################
###########################################################
#######                   MAIN                     ########
###########################################################
###########################################################


foreach my $f (@ARGV) { 
    AnalyzeResFile($f);
}
print "\n\n"  if ($verbose);


# type 2 = error
# type 5 = warning

StatGlobal();
#StatOfTypeByFiles(2);
#MessagesOfTypeByFiles(2);
StatOfTypeByProblems(2);
StatOfTypeByProblems(5);
#StatOfTypebyProblemsAndFiles(2);
#StatOfTypebyProblemsAndFiles(2);
#StatOfTypebyProblemsAndFiles(5);
#MessagesOfTypeByProblemsAndFiles(2);
#MessagesOfTypeByProblemsAndFiles(5);
