Quick diagramming ui

From: Thorsten Behrens <thb@openoffice.org>


---

 sd/inc/app.hrc                                     |    3 
 sd/inc/glob.hrc                                    |    1 
 sd/inc/helpids.h                                   |    1 
 sd/prj/build.lst                                   |    1 
 sd/sdi/_drvwsh.sdi                                 |   12 
 sd/sdi/sdraw.sdi                                   |   50 +
 sd/source/ui/animations/makefile.mk                |    2 
 sd/source/ui/app/menuids2_tmpl.src                 |    8 
 sd/source/ui/app/menuids_tmpl.src                  |   24 
 sd/source/ui/app/popup2_tmpl.src                   |   12 
 sd/source/ui/app/res_bmp.src                       |   20 
 sd/source/ui/app/strings.src                       |    4 
 sd/source/ui/framework/tools/FrameworkHelper.cxx   |    2 
 sd/source/ui/ig/BulletTextIterator.cxx             |  202 +++
 sd/source/ui/ig/CircleLayoutAlgorithm.cxx          |   87 +
 sd/source/ui/ig/FieldLayoutAlgorithm.cxx           |  364 +++++
 sd/source/ui/ig/GroupedListLayout.cxx              |  337 +++++
 sd/source/ui/ig/HorizontalListLayoutAlgorithm.cxx  |   51 +
 sd/source/ui/ig/IntelligentGroup.cxx               |  171 +++
 sd/source/ui/ig/IntelligentGroupBulletList.cxx     |  135 ++
 sd/source/ui/ig/IntelligentGroupController.cxx     |  149 ++
 sd/source/ui/ig/IntelligentGroupFrame.cxx          | 1364 ++++++++++++++++++++
 sd/source/ui/ig/IntelligentGroupLayoutBase.cxx     |  202 +++
 sd/source/ui/ig/IntelligentGroupLayoutManager.cxx  |  180 +++
 sd/source/ui/ig/IntelligentGroupLayouter.cxx       |  259 ++++
 sd/source/ui/ig/IntelligentGroupModel.cxx          |  589 +++++++++
 sd/source/ui/ig/IntelligentGroupPane.cxx           |  521 ++++++++
 sd/source/ui/ig/IntelligentGroupPane.hrc           |   53 +
 sd/source/ui/ig/IntelligentGroupPane.hxx           |  104 ++
 sd/source/ui/ig/IntelligentGroupPane.src           |  136 ++
 sd/source/ui/ig/IntelligentGroupShapeAccessor.cxx  |  110 ++
 sd/source/ui/ig/IntelligentGroupText.cxx           |  138 ++
 sd/source/ui/ig/IntelligentGroupTextIterator.cxx   |  112 ++
 sd/source/ui/ig/LayoutBase.cxx                     |  190 +++
 sd/source/ui/ig/ListLayoutAlgorithm.cxx            |  170 ++
 sd/source/ui/ig/PictureAccentListLayout.cxx        |  286 ++++
 sd/source/ui/ig/RowFieldLayoutAlgorithm.cxx        |   51 +
 sd/source/ui/ig/SelectionManager.cxx               |  299 ++++
 sd/source/ui/ig/TreeLayout.cxx                     |  182 +++
 sd/source/ui/ig/TreeLayoutAlgorithm.cxx            |  153 ++
 sd/source/ui/ig/makefile.mk                        |   81 +
 sd/source/ui/inc/BulletTextIterator.hxx            |   66 +
 sd/source/ui/inc/CircleLayoutAlgorithm.hxx         |   57 +
 sd/source/ui/inc/FieldLayoutAlgorithm.hxx          |   80 +
 sd/source/ui/inc/GroupedListLayout.hxx             |   67 +
 sd/source/ui/inc/HorizontalListLayoutAlgorithm.hxx |   50 +
 sd/source/ui/inc/IntelligentGroup.hxx              |   74 +
 sd/source/ui/inc/IntelligentGroupAlgorithmBase.hxx |   55 +
 sd/source/ui/inc/IntelligentGroupBulletList.hxx    |   68 +
 sd/source/ui/inc/IntelligentGroupController.hxx    |   62 +
 sd/source/ui/inc/IntelligentGroupDescriptors.hxx   |  190 +++
 sd/source/ui/inc/IntelligentGroupFrame.hxx         |  132 ++
 sd/source/ui/inc/IntelligentGroupLayoutBase.hxx    |   75 +
 sd/source/ui/inc/IntelligentGroupLayoutManager.hxx |   73 +
 sd/source/ui/inc/IntelligentGroupLayouter.hxx      |   78 +
 sd/source/ui/inc/IntelligentGroupModel.hxx         |  103 ++
 sd/source/ui/inc/IntelligentGroupShapeAccessor.hxx |   62 +
 sd/source/ui/inc/IntelligentGroupText.hxx          |   59 +
 sd/source/ui/inc/IntelligentGroupTextAccess.hxx    |   50 +
 sd/source/ui/inc/IntelligentGroupTextIterator.hxx  |   75 +
 sd/source/ui/inc/ListLayoutAlgorithm.hxx           |   63 +
 sd/source/ui/inc/PictureAccentListLayout.hxx       |   64 +
 sd/source/ui/inc/RowFieldLayoutAlgorithm.hxx       |   50 +
 sd/source/ui/inc/SelectionManager.hxx              |   99 +
 sd/source/ui/inc/TaskPaneViewShell.hxx             |    1 
 sd/source/ui/inc/TreeLayout.hxx                    |   62 +
 sd/source/ui/inc/TreeLayoutAlgorithm.hxx           |   77 +
 sd/source/ui/inc/ViewShellBase.hxx                 |    5 
 sd/source/ui/inc/framework/FrameworkHelper.hxx     |    1 
 sd/source/ui/inc/res_bmp.hrc                       |    6 
 sd/source/ui/toolpanel/TaskPaneViewShell.cxx       |   17 
 .../toolpanel/controls/IntelligentGroupPanel.cxx   |  118 ++
 .../toolpanel/controls/IntelligentGroupPanel.hxx   |   78 +
 sd/source/ui/toolpanel/controls/makefile.mk        |    3 
 sd/source/ui/view/ViewShellBase.cxx                |   21 
 sd/source/ui/view/drviews2.cxx                     |   14 
 sd/source/ui/view/drviewse.cxx                     |   62 +
 sd/uiconfig/simpress/menubar/menubar.xml           |    1 
 sd/util/makefile.mk                                |    7 
 79 files changed, 9037 insertions(+), 4 deletions(-)
 create mode 100644 sd/source/ui/ig/BulletTextIterator.cxx
 create mode 100644 sd/source/ui/ig/CircleLayoutAlgorithm.cxx
 create mode 100644 sd/source/ui/ig/FieldLayoutAlgorithm.cxx
 create mode 100644 sd/source/ui/ig/GroupedListLayout.cxx
 create mode 100644 sd/source/ui/ig/HorizontalListLayoutAlgorithm.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroup.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupBulletList.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupController.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupFrame.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupLayoutBase.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupLayoutManager.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupLayouter.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupModel.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupPane.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupPane.hrc
 create mode 100644 sd/source/ui/ig/IntelligentGroupPane.hxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupPane.src
 create mode 100644 sd/source/ui/ig/IntelligentGroupShapeAccessor.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupText.cxx
 create mode 100644 sd/source/ui/ig/IntelligentGroupTextIterator.cxx
 create mode 100644 sd/source/ui/ig/LayoutBase.cxx
 create mode 100644 sd/source/ui/ig/ListLayoutAlgorithm.cxx
 create mode 100644 sd/source/ui/ig/PictureAccentListLayout.cxx
 create mode 100644 sd/source/ui/ig/RowFieldLayoutAlgorithm.cxx
 create mode 100644 sd/source/ui/ig/SelectionManager.cxx
 create mode 100644 sd/source/ui/ig/TreeLayout.cxx
 create mode 100644 sd/source/ui/ig/TreeLayoutAlgorithm.cxx
 create mode 100644 sd/source/ui/ig/makefile.mk
 create mode 100644 sd/source/ui/inc/BulletTextIterator.hxx
 create mode 100644 sd/source/ui/inc/CircleLayoutAlgorithm.hxx
 create mode 100644 sd/source/ui/inc/FieldLayoutAlgorithm.hxx
 create mode 100644 sd/source/ui/inc/GroupedListLayout.hxx
 create mode 100644 sd/source/ui/inc/HorizontalListLayoutAlgorithm.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroup.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupAlgorithmBase.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupBulletList.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupController.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupDescriptors.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupFrame.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupLayoutBase.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupLayoutManager.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupLayouter.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupModel.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupShapeAccessor.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupText.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupTextAccess.hxx
 create mode 100644 sd/source/ui/inc/IntelligentGroupTextIterator.hxx
 create mode 100644 sd/source/ui/inc/ListLayoutAlgorithm.hxx
 create mode 100644 sd/source/ui/inc/PictureAccentListLayout.hxx
 create mode 100644 sd/source/ui/inc/RowFieldLayoutAlgorithm.hxx
 create mode 100644 sd/source/ui/inc/SelectionManager.hxx
 create mode 100644 sd/source/ui/inc/TreeLayout.hxx
 create mode 100644 sd/source/ui/inc/TreeLayoutAlgorithm.hxx
 create mode 100644 sd/source/ui/toolpanel/controls/IntelligentGroupPanel.cxx
 create mode 100644 sd/source/ui/toolpanel/controls/IntelligentGroupPanel.hxx


diff --git sd/inc/app.hrc sd/inc/app.hrc
index 4c87bfd..f5196a6 100644
--- sd/inc/app.hrc
+++ sd/inc/app.hrc
@@ -468,5 +468,8 @@
 
 #define SID_ADD_MOTION_PATH					(SID_SD_START+443)
 #define SID_TABLE_TOOLBOX					(SID_SD_START+444)
+#define SID_INSERT_INTELLIGENT_GROUP        (SID_SD_START+445)
+#define SID_INTELLIGENT_GROUP				(SID_SD_START+446)
+#define SID_ADD_SHAPE						(SID_SD_START+447)
 
 #endif
diff --git sd/inc/glob.hrc sd/inc/glob.hrc
index 3fb822e..cc18b8b 100644
--- sd/inc/glob.hrc
+++ sd/inc/glob.hrc
@@ -151,5 +151,6 @@
 #define DLG_TABLEDESIGNPANE						RID_GLOB_START+224
 #define STR_TABLEOBJECTBARSHELL					RID_GLOB_START+225
 #define RID_TABPAGE_PARA_NUMBERING				RID_GLOB_START+226
+#define DLG_INTELLIGENTGROUPPANE				RID_GLOB_START+227
 
 
diff --git sd/inc/helpids.h sd/inc/helpids.h
index 9d5260e..391508e 100644
--- sd/inc/helpids.h
+++ sd/inc/helpids.h
@@ -280,3 +280,4 @@
 #define HID_SD_CELL_STYLE_LAST_COLUMN						(HID_SD_START + 199)
 
 #define HID_SD_TABLE_DESIGN									(HID_SD_START + 200)
+#define HID_SD_INTELLIGENT_GROUP							(HID_SD_START + 201)
diff --git sd/prj/build.lst sd/prj/build.lst
index 949153b..8c52ab7 100644
--- sd/prj/build.lst
+++ sd/prj/build.lst
@@ -8,6 +8,7 @@ sd	sd\res\imagelst							get		-	all	sd_resil NULL
 sd	sd\sdi									nmake	-	all	sd_sdi NULL
 sd	sd\source\helper						nmake	-	all sd_helper sd_inc NULL
 sd	sd\source\ui\func						nmake	-	all	sd_func sd_sdi sd_inc NULL
+sd	sd\source\ui\ig          				nmake	-	all sd_ig sd_sdi sd_inc NULL
 sd	sd\source\ui\view						nmake	-	all	sd_view sd_sdi sd_inc NULL
 sd	sd\source\ui\app						nmake	-	all	sd_app sd_sdi sd_inc NULL
 sd	sd\source\ui\dlg						nmake	-	all	sd_dlg sd_sdi sd_inc NULL
diff --git sd/sdi/_drvwsh.sdi sd/sdi/_drvwsh.sdi
index aacab01..3bc0e81 100644
--- sd/sdi/_drvwsh.sdi
+++ sd/sdi/_drvwsh.sdi
@@ -2240,6 +2240,18 @@ interface DrawView
         StateMethod = GetMenuState ;
 	]
 
+	SID_INSERT_INTELLIGENT_GROUP
+	[
+		ExecMethod = FuPermanent ;
+		StateMethod = GetMenuState ;
+	]
+	
+	SID_ADD_SHAPE
+	[
+		ExecMethod = FuTemporary ;
+        StateMethod = GetMenuState ;
+	]
+	
     SID_INSERT_DATE_TIME // ole : no, status : ?
     [
         ExecMethod = ExecCtrl ;
diff --git sd/sdi/sdraw.sdi sd/sdi/sdraw.sdi
index bfb834a..cb30c1a 100644
--- sd/sdi/sdraw.sdi
+++ sd/sdi/sdraw.sdi
@@ -6692,6 +6692,56 @@ SfxVoidItem InsertPageNumber SID_INSERT_PAGE_NUMBER
 ]
 
 //--------------------------------------------------------------------------
+SfxVoidItem InsertIntelligentGroup SID_INSERT_INTELLIGENT_GROUP
+()
+[
+	/* flags: */  
+	AutoUpdate = FALSE, 
+	Cachable = Cachable, 
+	FastCall = FALSE, 
+	HasCoreId = FALSE, 
+	HasDialog = TRUE, 
+	ReadOnlyDoc = FALSE, 
+	Toggle = FALSE, 
+	Container = FALSE, 
+	RecordAbsolute = FALSE, 
+	RecordPerSet;
+	Synchron;
+
+	/* config: */ 
+	AccelConfig = TRUE, 
+	MenuConfig = TRUE, 
+	StatusBarConfig = FALSE, 
+	ToolBoxConfig = TRUE, 
+	GroupId = GID_MODIFY;
+]
+
+//--------------------------------------------------------------------------
+SfxVoidItem AddShape SID_ADD_SHAPE
+()
+[
+	/* flags: */  
+	AutoUpdate = FALSE, 
+	Cachable = Cachable, 
+	FastCall = FALSE, 
+	HasCoreId = FALSE, 
+	HasDialog = FALSE, 
+	ReadOnlyDoc = FALSE, 
+	Toggle = FALSE, 
+	Container = FALSE, 
+	RecordAbsolute = FALSE, 
+	RecordPerSet;
+	Synchron;
+
+	/* config: */ 
+	AccelConfig = TRUE, 
+	MenuConfig = TRUE, 
+	StatusBarConfig = FALSE, 
+	ToolBoxConfig = TRUE, 
+	GroupId = GID_MODIFY;
+]
+
+//--------------------------------------------------------------------------
 SfxVoidItem InsertDateAndTime SID_INSERT_DATE_TIME
 ()
 [
diff --git sd/source/ui/animations/makefile.mk sd/source/ui/animations/makefile.mk
index e3754a6..9684cf2 100644
--- sd/source/ui/animations/makefile.mk
+++ sd/source/ui/animations/makefile.mk
@@ -63,7 +63,7 @@ SLOFILES =  \
 		$(SLO)$/DialogListBox.obj \
 		$(SLO)$/SlideTransitionPane.obj \
         $(SLO)$/STLPropertySet.obj \
-        $(SLO)$/motionpathtag.obj
+        $(SLO)$/motionpathtag.obj 
 
 # --- Tagets -------------------------------------------------------
 
diff --git sd/source/ui/app/menuids2_tmpl.src sd/source/ui/app/menuids2_tmpl.src
index 614a671..a54270f 100644
--- sd/source/ui/app/menuids2_tmpl.src
+++ sd/source/ui/app/menuids2_tmpl.src
@@ -686,6 +686,14 @@
         Text [ en-US ] = "~Check..." ; \
 	};
 
+#define MN_INSERT_INTELLIGENT_GROUP \
+	MenuItem\
+	{\
+		Identifier = SID_INSERT_INTELLIGENT_GROUP ; \
+		HelpID = SID_INSERT_INTELLIGENT_GROUP ; \
+		Text = "Intelligent Group..."; \
+	};
+
 #define MN_AUTOSPELL_CHECK \
     MenuItem\
     {\
diff --git sd/source/ui/app/menuids_tmpl.src sd/source/ui/app/menuids_tmpl.src
index 6221028..1f30867 100644
--- sd/source/ui/app/menuids_tmpl.src
+++ sd/source/ui/app/menuids_tmpl.src
@@ -1211,6 +1211,30 @@
         };\
 	};
 
+#define MN_ADD_SHAPE \
+    MenuItem\
+    {\
+        Identifier = SID_ADD_SHAPE ; \
+        HelpID = SID_ADD_SHAPE ; \
+        Text [ en-US ] = "Add shape" ; \
+	};
+	
+#define MNSUB_INTELLIGENTGROUP \
+	MenuItem\
+	{\
+		Identifier = SID_INTELLIGENT_GROUP ; \
+		 Command = ".uno:IntelligentGroupMenu" ; \
+		HelpID = SID_INTELLIGENT_GROUP ; \
+		Text [ en-US ] = "Intelligent Group" ;\
+		SubMenu = Menu\
+        {\
+            ItemList = \
+            {\
+                MN_ADD_SHAPE\
+            };\
+        };\
+	};
+
 #define MNSUB_MIRROR \
     MenuItem\
     {\
diff --git sd/source/ui/app/popup2_tmpl.src sd/source/ui/app/popup2_tmpl.src
index 77e712b..15a9d56 100644
--- sd/source/ui/app/popup2_tmpl.src
+++ sd/source/ui/app/popup2_tmpl.src
@@ -64,6 +64,7 @@
 		MN_OBJECT_ALIGN
 		MN_DISTRIBUTE
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 
 		//-#i68101#----------------------
 		SEPARATOR
@@ -148,6 +149,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_DISMANTLE
@@ -192,6 +194,7 @@
 		MNSUB_MIRROR
 		// #i37263#
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_DISMANTLE
@@ -233,6 +236,7 @@
 		MN_OBJECT_ALIGN
 		MN_DISTRIBUTE
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_ENTER_GROUP
 		MN_3D_WIN
@@ -312,6 +316,7 @@
 		MN_OBJECT_ALIGN
 		MN_DISTRIBUTE
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_3D_WIN
@@ -355,6 +360,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 
 		//-#i68101#----------------------
 		SEPARATOR
@@ -395,6 +401,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_DISMANTLE
@@ -439,6 +446,7 @@
 		MN_OBJECT_ALIGN
 		MN_DISTRIBUTE
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_DISMANTLE
@@ -483,6 +491,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_DISMANTLE
@@ -527,6 +536,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_LEAVE_GROUP
 		MN_DISMANTLE
@@ -607,6 +617,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		SEPARATOR
 		MN_GROUP
 		MN_UNGROUP
@@ -649,6 +660,7 @@
 		MN_DISTRIBUTE
 		MNSUB_MIRROR
 		MNSUB_CONVERT
+		MNSUB_INTELLIGENTGROUP
 		MN_BREAK
 
 		//-#i68101#----------------------
diff --git sd/source/ui/app/res_bmp.src sd/source/ui/app/res_bmp.src
index 639a1b9..20eabdd 100644
--- sd/source/ui/app/res_bmp.src
+++ sd/source/ui/app/res_bmp.src
@@ -297,6 +297,26 @@ Bitmap BMP_FOIL_NONE
 {
 	File = "foilnone.bmp" ;
 };
+Bitmap BMP_IGLAYOUTS_GROUPEDLIST
+{
+	File = "foiln01_h.bmp";	
+};
+Bitmap BMP_IGLAYOUTS_PICTUREACCENTLIST
+{
+	File = "foiln01_h.bmp";	
+};
+Bitmap BMP_IGLAYOUTS_TREE
+{
+	File = "foiln01_h.bmp";
+};
+Bitmap BMP_IGLAYOUTS_SIMPLEFIELD
+{
+	File = "foiln01_h.bmp";
+};
+Bitmap BMP_IGLAYOUTS_BASECIRCLE
+{
+	File = "foiln01_h.bmp";
+};
 Bitmap BMP_PAGE
 {
 	File = "page.bmp" ;
diff --git sd/source/ui/app/strings.src sd/source/ui/app/strings.src
index 6d82912..febd8c4 100644
--- sd/source/ui/app/strings.src
+++ sd/source/ui/app/strings.src
@@ -1241,6 +1241,10 @@ String DLG_TABLEDESIGNPANE
 {
 	Text [ en-US ] = "Table Designs";
 };
+String DLG_INTELLIGENTGROUPPANE
+{
+	Text [ en-US ] = "Intelligent Group";
+};
 String STR_NAVIGATOR_SHOW_NAMED_SHAPES
 {
 	Text [ en-US ] = "Named shapes";
diff --git sd/source/ui/framework/tools/FrameworkHelper.cxx sd/source/ui/framework/tools/FrameworkHelper.cxx
index 579bd13..f2f0c61 100644
--- sd/source/ui/framework/tools/FrameworkHelper.cxx
+++ sd/source/ui/framework/tools/FrameworkHelper.cxx
@@ -226,6 +226,8 @@ const ::rtl::OUString FrameworkHelper::msMasterPagesTaskPanelURL(
     msTaskPanelURLPrefix + OUString::createFromAscii("MasterPages"));
 const ::rtl::OUString FrameworkHelper::msLayoutTaskPanelURL(
     msTaskPanelURLPrefix + OUString::createFromAscii("Layouts"));
+const ::rtl::OUString FrameworkHelper::msIntelligentGroupTaskPanelURL(
+	msTaskPanelURLPrefix + OUString::createFromAscii("IntelligentGroup"));
 const ::rtl::OUString FrameworkHelper::msTableDesignPanelURL(
     msTaskPanelURLPrefix + OUString::createFromAscii("TableDesign"));
 const ::rtl::OUString FrameworkHelper::msCustomAnimationTaskPanelURL(
diff --git sd/source/ui/ig/BulletTextIterator.cxx sd/source/ui/ig/BulletTextIterator.cxx
new file mode 100644
index 0000000..835b9d9
--- /dev/null
+++ sd/source/ui/ig/BulletTextIterator.cxx
@@ -0,0 +1,202 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: BulletTextIterator.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "BulletTextIterator.hxx"
+
+namespace sd{
+
+	BulletTextIterator::BulletTextIterator(IntelligentGroupTextAccess* pTextAccess)
+		:mpTextAccess(pTextAccess)
+	{
+		Rewind();
+	}
+
+
+	BulletTextIterator::BulletTextIterator(BulletTextIterator* pIterator)
+		: IntelligentGroupTextIterator(pIterator),
+		mpTextAccess(pIterator->mpTextAccess)
+	{
+	}
+
+
+	BulletTextIterator::~BulletTextIterator()
+	{
+
+	}
+
+
+	bool BulletTextIterator::Rewind()
+	{
+		if (mpTextAccess->GetItemCount() == 0)
+			return false;
+		else
+		{
+			IntelligentGroupTextIterator::Rewind();
+			mnCurrentLevel = mpTextAccess->GetDepth(mnCurrentIndex);
+			return true;
+		}
+	}
+
+
+	sal_Int32 BulletTextIterator::GetChildCount()
+	{
+		/** Count entries for following the current one that
+		*	have one more * than the current one and until
+		*	there is one with the same or a smaller number.
+		*/
+
+		sal_Int32 nChildCount = 0;
+		const sal_Int32 nCount = mpTextAccess->GetItemCount();
+
+		for (sal_Int32 nIndex = mnCurrentIndex+1; nIndex < nCount; ++nIndex)
+		{
+			const sal_Int32 nDepth = mpTextAccess->GetDepth(nIndex);
+			if (nDepth <= mnCurrentLevel)
+				break;
+			else if (nDepth == mnCurrentLevel+1)
+				++nChildCount;
+		}
+		return nChildCount;
+	}
+
+
+	sal_Int32 BulletTextIterator::GetItemCount()
+	{
+		const sal_Int32 nSavedIndex = mnCurrentIndex;
+		const sal_Int32 nSavedLevel = mnCurrentLevel;
+		sal_Int32 nCount = 0;
+
+		if ( GotoParent() )
+		{
+			if ( GotoFirstChild() )
+			{
+				++nCount;
+				while ( GotoNext() )
+					++nCount;
+			}
+		}
+		else
+		{
+			// Count elements on the top level;
+			//ReWind();
+			if ( Rewind() ) // jianli modify for delete all the shapes
+				++nCount;
+			while ( GotoNext() )
+				++nCount;
+		}
+		mnCurrentIndex = nSavedIndex;
+		mnCurrentLevel = nSavedLevel;
+		return nCount;
+	}
+
+	rtl::OUString BulletTextIterator::GetText()
+	{
+		const rtl::OUString sText (mpTextAccess->GetText(mnCurrentIndex, mnCurrentLevel));
+
+		if ( sText.endsWithAsciiL("\n", 1) )
+			return sText.copy( 0, sText.getLength()-1 );
+		else
+			return sText;
+	}
+
+
+	bool BulletTextIterator::GotoFirstChild()
+	{
+		if ( HasChildren() )
+		{
+			++mnCurrentIndex;
+			Down();
+			return true;
+		}
+		else
+			return false;
+	}
+
+
+	bool BulletTextIterator::GotoNext()
+	{
+		sal_Int32 nIndex = mnCurrentIndex;
+
+		while ( ++nIndex < mpTextAccess->GetItemCount() )
+		{
+			const sal_Int32 nDepth = mpTextAccess->GetDepth(nIndex);
+			if (nDepth < 0)
+				return false;
+			else if (nDepth == mnCurrentLevel)
+			{
+				mnCurrentIndex = nIndex;
+				++mnCurrentIndexOnLevel;
+				return true;
+			}
+			else if (nDepth < mnCurrentLevel)
+				break;
+		}
+		return false;
+	}
+
+
+	bool BulletTextIterator::GotoParent()
+	{
+		if (mnCurrentLevel == 0)
+			return false;
+
+		const sal_Int32 nParentLevel = mnCurrentLevel - 1;
+		for (sal_Int32 nIndex = mnCurrentIndex-1; nIndex >= 0; --nIndex)
+		{
+			if (mpTextAccess->GetDepth(nIndex) == nParentLevel)
+			{
+				mnCurrentIndex = nIndex;
+				Up();
+				return true;
+			}
+		}
+		return false;
+	}
+
+
+	bool BulletTextIterator::HasChildren()
+	{
+		return mnCurrentIndex < mpTextAccess->GetItemCount() - 1
+			&& mpTextAccess->GetDepth(mnCurrentIndex+1) == mnCurrentLevel + 1;
+	}
+
+
+	boost::shared_ptr<IntelligentGroupTextIterator> BulletTextIterator::GetCopy()
+	{
+		return ::boost::shared_ptr<IntelligentGroupTextIterator> ( new BulletTextIterator(this) );
+	}
+
+
+}
+
+
+
diff --git sd/source/ui/ig/CircleLayoutAlgorithm.cxx sd/source/ui/ig/CircleLayoutAlgorithm.cxx
new file mode 100644
index 0000000..e2fae52
--- /dev/null
+++ sd/source/ui/ig/CircleLayoutAlgorithm.cxx
@@ -0,0 +1,87 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: CircleLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#include "CircleLayoutAlgorithm.hxx"
+#include "IntelligentGroupLayoutBase.hxx"
+#include <math.h>
+
+#define PI 3.14159265358979323846
+
+namespace sd {
+
+
+CircleLayoutAlgorithm::CircleLayoutAlgorithm()
+{
+}
+
+
+CircleLayoutAlgorithm::~CircleLayoutAlgorithm()
+{
+}
+
+
+void CircleLayoutAlgorithm::PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, 
+//									 std::vector<std::vector<IntelligentGroupShapeDescriptor>>& aShapeDescriptors, 
+								     boost::shared_ptr<IntelligentGroupModel> pModel,
+									 css::awt::Rectangle aGroupBoundingBox)
+{
+//	sal_Int32 nShapeGroupCount = aShapeDescriptors.size();
+	sal_Int32 nShapeGroupCount = pModel->GetShapeGroupCount();
+	if (nShapeGroupCount == 0)
+		return;
+	sal_Int32 nTotalRadius = std::min(aGroupBoundingBox.Width/2, aGroupBoundingBox.Height/2);
+	sal_Int32 nRadius = (sal_Int32)(sin(PI/nShapeGroupCount) * (nTotalRadius/2) * 0.8 + 0.5);
+	sal_Int32 nCenterX = aGroupBoundingBox.X+aGroupBoundingBox.Width/2;
+	sal_Int32 nCenterY = aGroupBoundingBox.Y+aGroupBoundingBox.Height/2;
+	double nAngle = PI * 2 / nShapeGroupCount;
+
+	for (sal_Int32 nIndex=0; nIndex<nShapeGroupCount; ++nIndex)
+	{
+		css::awt::Rectangle aBoundingBox(
+			(long)(nCenterX + cos(nIndex*nAngle) * (nTotalRadius-nRadius))-nRadius,
+			(long)(nCenterY + sin(nIndex*nAngle) * (nTotalRadius-nRadius))-nRadius,
+			2*nRadius,
+			2*nRadius); 
+
+		pLayout->PlaceShapes(
+//			aShapeDescriptors[nIndex],
+			nIndex,
+			aBoundingBox,
+			aGroupBoundingBox,
+			css::awt::Size(2*nRadius,2*nRadius),
+			1);
+
+	}
+}
+
+
+
+} 
\ No newline at end of file
diff --git sd/source/ui/ig/FieldLayoutAlgorithm.cxx sd/source/ui/ig/FieldLayoutAlgorithm.cxx
new file mode 100644
index 0000000..f5ae32b
--- /dev/null
+++ sd/source/ui/ig/FieldLayoutAlgorithm.cxx
@@ -0,0 +1,364 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: FieldLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#include "FieldLayoutAlgorithm.hxx"
+#include "IntelligentGroupLayoutBase.hxx"
+#include <math.h>
+
+namespace css = ::com::sun::star;
+
+
+namespace sd {
+
+
+	class FieldLayoutAlgorithm::Line
+	{
+	public:
+		Line ();
+
+		void Add ( const css::awt::Size aSize );
+
+	public:
+		css::awt::Size maTotalSize;
+		std::vector<css::awt::Size> maSizes;
+	};
+
+	FieldLayoutAlgorithm::Line::Line()
+	{
+		maTotalSize =css::awt::Size(0,0);
+	}
+
+	void FieldLayoutAlgorithm::Line::Add( const css::awt::Size aSize )
+	{
+		maSizes.push_back(aSize);
+		maTotalSize.Width += aSize.Width;
+		if (aSize.Height > maTotalSize.Height)
+			maTotalSize.Height = aSize.Height;
+	}
+
+
+FieldLayoutAlgorithm::FieldLayoutAlgorithm(const ig::Orientation eOrientation)
+{
+	meOrientation = eOrientation;
+}
+
+
+FieldLayoutAlgorithm::~FieldLayoutAlgorithm()
+{
+}
+
+
+void FieldLayoutAlgorithm::PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, 
+//									 std::vector<std::vector<IntelligentGroupShapeDescriptor>>& aShapeDescriptors, 
+									 boost::shared_ptr<IntelligentGroupModel> pModel,
+									 css::awt::Rectangle aGroupBoundingBox)
+{
+	// There is one group of shapes for every top level text entry.
+//	sal_Int32 nCount = aShapeDescriptors.size();
+	sal_Int32 nCount = pModel->GetShapeGroupCount();
+	if (nCount == 0)
+	{
+		// There are no text entries => Nothing to do.
+		return;
+	}
+
+	sal_Int32 nGap = (sal_Int32)(pLayout->GetGap(aGroupBoundingBox) + 0.5);
+
+	// Default aspect ratio of shapes is 5:3.
+	double nDefaultAspectRatio = 5.0 / 3.0;
+	css::awt::Size aDefaultSize(300, (long)(300/nDefaultAspectRatio));
+
+	// Setup an array of the sizes of the individual shape groups.
+	std::vector<css::awt::Size> aSizes;
+	sal_Int32 nIndex = 0;
+	for (; nIndex<nCount; ++nIndex)
+	{
+		aSizes.push_back(
+			pLayout->GetBoundingSize(
+			nIndex,
+			aDefaultSize,
+//			aShapeDescriptors[nIndex]));
+			pModel->GetShapeDescriptorVector(nIndex)));
+	}
+
+	// Start with one line that contains all shapes.
+	std::vector<FieldLayoutAlgorithm::Line> aLines;
+	FieldLayoutAlgorithm::Line aFirstLine;
+	for (std::vector<css::awt::Size>::iterator aIter = aSizes.begin(); aIter != aSizes.end(); aIter++)
+		aFirstLine.Add(*aIter);
+	aLines.push_back(aFirstLine);
+
+	// Calculate aspect ratio of the intelligent group shape.
+	double nBoundingBoxAspectRatio = aGroupBoundingBox.Width / (double)aGroupBoundingBox.Height;
+
+	// Now start an iterative process of shortening lines to optimize the 
+	// aspect ratio of the combined lines.
+	while (true)
+	{
+		double nLinesAspectRatio = CalculateAspectRatio(aLines, nGap, aGroupBoundingBox);
+
+		// Reduce the width of the longest line and re-flow shapes so
+		// that all lines obey the new width.
+		double nNewWidth = CalculateNewWidth(aLines);
+		std::vector<FieldLayoutAlgorithm::Line> aNewLines = ReflowLines(aLines, nNewWidth, nGap);
+
+		double nNewLinesAspectRatio = CalculateAspectRatio(aNewLines, nGap, aGroupBoundingBox);
+
+		if (abs(nBoundingBoxAspectRatio-nNewLinesAspectRatio) <= abs(nBoundingBoxAspectRatio-nLinesAspectRatio)
+			&& nNewLinesAspectRatio != nLinesAspectRatio)
+		{
+			aLines = aNewLines;
+		}
+		else
+			break;
+	}
+
+	// The line structure has been determined.  First calculate the scale factor.
+	css::awt::Size aTotalSize = CalculateTotalSize(aLines);
+	double nScale = CalculateScale(aLines, nGap, aGroupBoundingBox);
+
+	// Now layout the individual shape groups.
+	nIndex = 0;
+	double nTotalHeight = aTotalSize.Height * nScale + CalculateTotalGapSize(aLines, nGap).Height; 
+	sal_Int32 nY = (sal_Int32)(aGroupBoundingBox.Y + (aGroupBoundingBox.Height - nTotalHeight) / 2);
+	for (std::vector<FieldLayoutAlgorithm::Line>::iterator aIter=aLines.begin(); aIter!=aLines.end(); aIter++)
+	{
+		double nTotalLineWidth = (*aIter).maTotalSize.Width*nScale 
+			+ (((*aIter).maSizes.size() > 1) ? ((*aIter).maSizes.size()-1)*nGap : 0);
+		sal_Int32 nX = (sal_Int32)(aGroupBoundingBox.X + (aGroupBoundingBox.Width - nTotalLineWidth) / 2);
+		for (std::vector<css::awt::Size>::iterator aInnerIter = (*aIter).maSizes.begin();
+			aInnerIter!=(*aIter).maSizes.end(); 
+			aInnerIter++)
+		{
+			sal_Int32 nWidth = (sal_Int32)((*aInnerIter).Width * nScale + 0.5);
+			sal_Int32 nHeight = (sal_Int32)((*aInnerIter).Height * nScale + 0.5);
+			sal_Int32 nTop = nY + (sal_Int32)(((*aIter).maTotalSize.Height*nScale - nHeight)/2);
+			if(nIndex<nCount)
+				pLayout->PlaceShapes(
+//					aShapeDescriptors[nIndex],
+					nIndex,
+					css::awt::Rectangle(
+					nX,
+					nTop,
+					nWidth,
+					nHeight),
+					aGroupBoundingBox,
+					aDefaultSize,
+					nScale);
+			nX += (sal_Int32)((*aInnerIter).Width * nScale + nGap);
+			++nIndex;
+		}
+		nY += (sal_Int32)((*aIter).maTotalSize.Height * nScale + nGap);
+	}
+}
+
+
+std::vector<FieldLayoutAlgorithm::Line> FieldLayoutAlgorithm::ReflowLines(const std::vector<FieldLayoutAlgorithm::Line> aLines, double nMaximalWidth, sal_Int32 nGap)
+{
+	std::vector<FieldLayoutAlgorithm::Line> aNewLines;
+	bool bIsReflowActive = false;
+	boost::shared_ptr<Line> pReflowLine(new Line());
+	for (std::vector<FieldLayoutAlgorithm::Line>::const_iterator aIter = aLines.begin(); aIter != aLines.end(); aIter++)
+	{
+		if ((*aIter).maTotalSize.Width > nMaximalWidth)
+		{
+			bIsReflowActive = true;
+		}
+		if (bIsReflowActive)
+		{
+			for (std::vector<css::awt::Size>::const_iterator aInnerIter = (*aIter).maSizes.begin();
+				aInnerIter!=(*aIter).maSizes.end();
+				aInnerIter++)
+			{
+				if (pReflowLine->maSizes.empty() 
+					|| pReflowLine->maTotalSize.Width+(*aInnerIter).Width+nGap <= nMaximalWidth)
+				{
+					pReflowLine->Add(*aInnerIter);
+				}
+				else
+				{
+					aNewLines.push_back(*(pReflowLine.get()));
+					pReflowLine.reset(new Line());
+					pReflowLine->Add(*aInnerIter);
+				}
+			}
+		}
+		else
+			aNewLines.push_back(*aIter);
+	}
+	if ( ! pReflowLine->maSizes.empty())
+		aNewLines.push_back(*(pReflowLine.get()));
+	return aNewLines;
+}
+
+
+double FieldLayoutAlgorithm::CalculateNewWidth (std::vector<FieldLayoutAlgorithm::Line> aLines)
+{
+	double nLargestWidth = 0;
+	for (std::vector<FieldLayoutAlgorithm::Line>::iterator aIter = aLines.begin(); aIter != aLines.end(); aIter++)
+	{
+		if ((*aIter).maTotalSize.Width > nLargestWidth)
+		{
+			nLargestWidth = (*aIter).maTotalSize.Width;
+		}
+	}
+	return nLargestWidth - 1;
+}
+
+
+double FieldLayoutAlgorithm::CalculateAspectRatio (
+							 const std::vector<FieldLayoutAlgorithm::Line> aLines,
+							 const sal_Int32 nGap,
+							 const css::awt::Rectangle aBoundingBox)
+{
+	css::awt::Size aTotalSize = CalculateTotalSize(aLines);
+	css::awt::Size aTotalGapSize = CalculateTotalGapSize(aLines, nGap);
+	css::awt::Size aAvailableSize (
+		aBoundingBox.Width - aTotalGapSize.Width,
+		aBoundingBox.Height - aTotalGapSize.Height);
+	double nScale;
+	if (aTotalSize.Width / (double)aTotalSize.Height
+			> aAvailableSize.Width/(double)aAvailableSize.Height)
+	{
+		nScale = aAvailableSize.Width / (double)aTotalSize.Width;
+	}
+	else
+	{
+		nScale = aAvailableSize.Height/ (double)aTotalSize.Height;
+	}
+	const css::awt::Size aFinalTotalSize (
+		(long)(aTotalSize.Width * nScale + aTotalGapSize.Width),
+		(long)(aTotalSize.Height * nScale + aTotalGapSize.Height));
+	return aFinalTotalSize.Width / (double)aFinalTotalSize.Height;
+}
+
+
+double FieldLayoutAlgorithm::CalculateScale (
+					   const std::vector<FieldLayoutAlgorithm::Line> aLines,
+					   const sal_Int32 nGap,
+					   const css::awt::Rectangle aBoundingBox)
+{
+	css::awt::Size aTotalSize = CalculateTotalSize(aLines);
+	css::awt::Size aTotalGapSize = CalculateTotalGapSize(aLines, nGap);
+	css::awt::Size aAvailableSize (
+		aBoundingBox.Width - aTotalGapSize.Width,
+		aBoundingBox.Height - aTotalGapSize.Height);
+	double nScale;
+	if (aTotalSize.Width / (double)aTotalSize.Height
+			> aAvailableSize.Width/(double)aAvailableSize.Height)
+	{
+		nScale = aAvailableSize.Width / (double)aTotalSize.Width;
+	}
+	else
+	{
+		nScale = aAvailableSize.Height/ (double)aTotalSize.Height;
+	}
+	return nScale;
+}
+
+
+
+css::awt::Size FieldLayoutAlgorithm::CalculateTotalSize (const std::vector<Line> aLines)
+{
+	css::awt::Size aTotalSize(0,0);
+	for (std::vector<FieldLayoutAlgorithm::Line>::const_iterator aIter = aLines.begin(); aIter!=aLines.end(); aIter++)
+	{
+		if ((*aIter).maTotalSize.Width > aTotalSize.Width)
+			aTotalSize.Width = (*aIter).maTotalSize.Width;
+		aTotalSize.Height += (*aIter).maTotalSize.Height;
+	}
+	return aTotalSize;
+}
+
+
+css::awt::Size FieldLayoutAlgorithm::CalculateTotalGapSize (const std::vector<Line> aLines, const sal_Int32 nGap)
+{
+	sal_Int32 nMaxItemCount = 0;
+	for (std::vector<FieldLayoutAlgorithm::Line>::const_iterator aIter=aLines.begin(); aIter!=aLines.end(); aIter++)
+		if ((sal_Int32)(*aIter).maSizes.size() > nMaxItemCount)
+			nMaxItemCount = (*aIter).maSizes.size();
+
+	return css::awt::Size(
+		(aLines.size() > 1) ? (aLines.size()-1)*nGap : 0,
+		(nMaxItemCount > 1) ? (nMaxItemCount-1)*nGap : 0);
+}
+
+
+
+sal_Int32 FieldLayoutAlgorithm::Project(const sal_Int32 nFirst, const sal_Int32 nSecond, const bool bProjectToPrimaryAxis)
+{
+	switch( meOrientation)
+	{
+	case ig::Horizontal:
+		if (bProjectToPrimaryAxis)
+			return nFirst;
+		else
+			return nSecond;
+	case ig::Vertical:
+		if (bProjectToPrimaryAxis)
+			return nSecond;
+		else
+			return nFirst;
+	default:
+	    return 0; // It's better to throw a exception.
+	}
+}
+
+
+css::awt::Size FieldLayoutAlgorithm::CreateSize(const sal_Int32 nSizeOnPrimaryAxis, const sal_Int32 nSizeOnSecondaryAxis)
+{
+	switch(meOrientation)
+	{
+	case ig::Horizontal:
+		return css::awt::Size(nSizeOnPrimaryAxis, nSizeOnSecondaryAxis);
+	case ig::Vertical:
+		return css::awt::Size(nSizeOnSecondaryAxis, nSizeOnPrimaryAxis);
+	default:
+		return css::awt::Size(0 ,0); // It's better to throw a exception.
+	}
+}
+
+
+css::awt::Point FieldLayoutAlgorithm::CreatePosition(const sal_Int32 nPositionOnPrimaryAxis, const sal_Int32 nPositionOnSecondaryAxis)
+{
+	switch(meOrientation)
+	{
+	case ig::Horizontal:
+		return css::awt::Point(nPositionOnPrimaryAxis, nPositionOnSecondaryAxis);
+	case ig::Vertical:
+	    return css::awt::Point(nPositionOnSecondaryAxis, nPositionOnPrimaryAxis);
+	default:
+		return css::awt::Point(0, 0); // It's better to throw a exception.
+	}
+}
+
+
+} 
\ No newline at end of file
diff --git sd/source/ui/ig/GroupedListLayout.cxx sd/source/ui/ig/GroupedListLayout.cxx
new file mode 100644
index 0000000..c1411b6
--- /dev/null
+++ sd/source/ui/ig/GroupedListLayout.cxx
@@ -0,0 +1,337 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: groupedlistlayout.cxx,v $
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "GroupedListLayout.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/style/ParagraphAdjust.hpp>
+#include <com/sun/star/drawing/ColorMode.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/drawing/TextFitToSizeType.hpp>
+#include <svtools/colorcfg.hxx>
+
+using namespace ::com::sun::star;
+
+namespace sd{
+
+GroupedListLayout::GroupedListLayout(
+	boost::shared_ptr<IntelligentGroupModel> pModel,
+	boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+	:IntelligentGroupLayoutBase(pModel,pDescriptor)
+{
+}
+
+double GroupedListLayout::GetGap( awt::Rectangle aGroupBoundingBox )
+{
+	return aGroupBoundingBox.Width / 50;
+}
+
+awt::Size GroupedListLayout::GetBoundingSize (
+	sal_Int32 /*nIndex*/, 
+	awt::Size aDefaultSize, 
+	std::vector<IntelligentGroupShapeDescriptor> aDescriptors)
+{
+
+	if (aDescriptors.size() == 0)
+		return aDefaultSize;
+
+	sal_Int32 nMaxWidth = 0;
+	sal_Int32 nMaxHeight = 0;
+	for (sal_uInt32 nChildIndex=0; nChildIndex<aDescriptors.size(); ++nChildIndex)
+	{
+		sal_Int32 nWidth = 0;
+		sal_Int32 nHeight = 0;
+		if (aDescriptors[nChildIndex].Exists)
+		{
+			nWidth = aDescriptors[nChildIndex].ShapeSize.Width;
+			nHeight = aDescriptors[nChildIndex].ShapeSize.Height;
+		}
+		else
+		{
+			nWidth = aDefaultSize.Width;
+			nHeight  = aDefaultSize.Height;
+			if (nChildIndex > 0)
+			{
+				nWidth *= 8 / 10;
+				nHeight *= 6/10 / (aDescriptors.size()-1);
+			}
+		}
+		if (nWidth > nMaxWidth)
+			nMaxWidth = nWidth;
+		if (nHeight > nMaxHeight)
+			nMaxHeight = nHeight;
+	}
+	awt::Size aSize(nMaxWidth, nMaxHeight);
+	return aSize;
+}
+
+std::vector<IntelligentGroupShapeDescriptor> GroupedListLayout::PrepareShapes (boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator, sal_Int32 nIndex, bool bCreatedByUser)
+{
+	std::vector<IntelligentGroupShapeDescriptor> aDescriptors;
+	IntelligentGroupStyle aStyle;
+
+	if(!bCreatedByUser)
+	{
+		sal_Int32 nChildCount = pTextIterator->GetChildCount();
+
+		aStyle.aBackground = IntelligentGroupStyle::Background;
+		aStyle.aBorder = IntelligentGroupStyle::None_Border;
+		aStyle.aText = IntelligentGroupStyle::Primary;
+
+		//aDescriptors[0] = GetShapeDescriptor(
+		aDescriptors.push_back(GetShapeDescriptor(
+			GetShapeName(ig::TopLevelText, nIndex),
+			ig::Primary,
+			aStyle));
+
+		sal_Int32 nChildIndex = 0;
+		if (pTextIterator->GotoFirstChild())
+		{
+			do
+			{
+				aStyle.aBackground = IntelligentGroupStyle::Foreground;
+				aStyle.aBorder = IntelligentGroupStyle::Regular;
+				aStyle.aText = IntelligentGroupStyle::Secondary;
+				//aDescriptors[nChildIndex+1] = GetShapeDescriptor(
+				aDescriptors.push_back(GetShapeDescriptor(
+					GetShapeName(ig::SecondLevelText, nIndex, nChildIndex),
+					ig::Accent,
+					aStyle));
+				++nChildIndex;
+			}
+			while (pTextIterator->GotoNext());
+
+			pTextIterator->GotoParent();
+		}
+
+		mpModel->AddShapeGroup(aDescriptors, mpModel->GetShapeGroupCount());
+	}
+	else
+	{
+		aStyle.aBackground = IntelligentGroupStyle::Background;
+		aStyle.aBorder = IntelligentGroupStyle::None_Border;
+		aStyle.aText = IntelligentGroupStyle::Primary;
+
+		aDescriptors.push_back(GetShapeDescriptor(
+			rtl::OUString::createFromAscii("Primary"),
+			ig::Primary,
+			aStyle));
+
+		aStyle.aBackground = IntelligentGroupStyle::Foreground;
+		aStyle.aBorder = IntelligentGroupStyle::Regular;
+		aStyle.aText = IntelligentGroupStyle::Secondary;
+
+		aDescriptors.push_back(GetShapeDescriptor(
+			rtl::OUString::createFromAscii("Secondary"),
+			ig::Accent,
+			aStyle));
+
+	}
+
+	return aDescriptors;
+}
+
+//void GroupedListLayout::PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aShapeDescriptors, 
+void GroupedListLayout::PlaceShapes(sal_Int32 nShapeGroupIndex, 
+	awt::Rectangle aBoundingBox, 
+	awt::Rectangle aGroupBoundingBox, 
+	awt::Size /*aDefaultSize*/, 
+	double nScale)
+{	 // Provide default sizes and locations.
+	//	IntelligentGroupShapeDescriptor& aTopLevelTextDescriptor = aShapeDescriptors[0];
+	IntelligentGroupShapeDescriptor aTopLevelTextDescriptor;
+	aTopLevelTextDescriptor.DefaultLocation = awt::Point( aBoundingBox.X, aBoundingBox.Y );
+	aTopLevelTextDescriptor.DefaultSize = awt::Size(aBoundingBox.Width, aBoundingBox.Height);
+	if (aTopLevelTextDescriptor.SizeTransformation.Width != 0 && aTopLevelTextDescriptor.SizeTransformation.Height != 0)
+		if (aTopLevelTextDescriptor.ShapeSize.Height < aGroupBoundingBox.Height)
+			aTopLevelTextDescriptor.DefaultSize.Height = (long)(aTopLevelTextDescriptor.ShapeSize.Height * nScale);
+
+	//	sal_Int32 nChildCount = aShapeDescriptors.size() - 1;
+
+	sal_Int32 nShapeDescriptorIndex = mpModel->GetShapeDescriptorIndex(nShapeGroupIndex,0);
+	mpModel->SetSizeLocation(nShapeDescriptorIndex,aTopLevelTextDescriptor);
+
+	sal_Int32 nChildCount = mpModel->GetGroupShapeCount(nShapeGroupIndex)-1;
+	if (nChildCount > 0)
+	{
+		sal_Int32 nGap = aBoundingBox.Height / 30;
+		sal_Int32 nChildAreaHeight = (sal_Int32)(0.6 * aBoundingBox.Height);
+		sal_Int32 nChildHeight = (nChildAreaHeight+nGap) / nChildCount - nGap;
+		sal_Int32 nY = (sal_Int32)(0.3 * aBoundingBox.Height);
+		for (sal_Int32 nChildIndex=1; nChildIndex<=nChildCount; ++nChildIndex)
+		{
+			//			IntelligentGroupShapeDescriptor& aSecondLevelTextDescriptor = aShapeDescriptors[nChildIndex];
+			IntelligentGroupShapeDescriptor aSecondLevelTextDescriptor;
+			aSecondLevelTextDescriptor.DefaultLocation = awt::Point(
+				aBoundingBox.X + (sal_Int32)(0.1*aBoundingBox.Width),
+				aBoundingBox.Y + nY);
+			aSecondLevelTextDescriptor.DefaultSize = awt::Size(
+				(sal_Int32)(0.8 * aBoundingBox.Width),
+				nChildHeight);
+			nY += nChildHeight + nGap;
+			mpModel->SetSizeLocation(nShapeDescriptorIndex+nChildIndex,aSecondLevelTextDescriptor);
+		}
+	}
+
+	//	SetSizeLocation(aTopLevelTextDescriptor);
+
+
+
+	//	for (sal_Int32 nChildIndex=1; nChildIndex<=nChildCount; ++nChildIndex)
+	//		SetSizeLocation(aShapeDescriptors[nChildIndex]);
+
+
+	// Move shapes into the bounding box of the enclosing group.
+	//	MoveShapeIntoGroupBoundingBox(aTopLevelTextDescriptor, aGroupBoundingBox);
+	for (sal_Int32 nChildIndex=0; nChildIndex<=nChildCount; ++nChildIndex)
+		//		MoveShapeIntoGroupBoundingBox(aShapeDescriptors[nChildIndex],aGroupBoundingBox);
+		mpModel->MoveShapeIntoGroupBoundingBox(nShapeDescriptorIndex+nChildIndex,aGroupBoundingBox);
+}
+
+uno::Reference<drawing::XShape> GroupedListLayout::CreateShape(rtl::OUString aIdentifier)
+{
+	uno::Reference<drawing::XShape> xShape = NULL;
+
+	ig::ShapeClass eClass = GetClassForName(aIdentifier);
+
+	switch (eClass)
+	{
+	case ig::TopLevelText:
+		{
+			xShape = uno::Reference<drawing::XShape>(
+				mpModel->GetShapeFactory()->createInstance(
+				rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.drawing.TextShape"))),
+				uno::UNO_QUERY);
+			uno::Reference<beans::XPropertySet> xProperties(xShape, uno::UNO_QUERY);
+			if (xProperties.is())
+			{
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("CornerRadius"), uno::makeAny(sal_Int32(500)));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("LineStyle"), uno::makeAny(drawing::LineStyle_SOLID));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillColor"), uno::makeAny(sal_Int32(0xFFFF00)));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("ParaAdjust"), uno::makeAny(style::ParagraphAdjust_CENTER));
+			}
+		}
+		break;
+
+	case ig::SecondLevelText:
+		{
+			xShape = uno::Reference<drawing::XShape>(
+				mpModel->GetShapeFactory()->createInstance(
+				//					OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.presentation.OutlinerShape"))),
+				rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.drawing.TextShape"))),
+				uno::UNO_QUERY);
+			uno::Reference<beans::XPropertySet> xProperties(xShape, uno::UNO_QUERY);
+			if (xProperties.is())
+			{
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("CornerRadius"), uno::makeAny(sal_Int32(400)));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("LineStyle"), uno::makeAny(drawing::LineStyle_SOLID));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("ParaAdjust"), uno::makeAny(style::ParagraphAdjust_CENTER));
+				//					xProperties->setPropertyValue(rtl::OUString::createFromAscii("TextFitToSize"), uno::makeAny(drawing::TextFitToSizeType_PROPORTIONAL));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillColor"), uno::makeAny(sal_Int32(0x0099ccff)));
+				xProperties->setPropertyValue(rtl::OUString::createFromAscii("TextAutoGrowHeight"), uno::makeAny(sal_Bool(sal_True)));
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (xShape.is())
+	{
+		xShape->setSize(awt::Size(0,0));
+	}
+
+	return xShape;
+}
+
+
+
+rtl::OUString GroupedListLayout::GetShapePrefix(ig::ShapeClass eClass)
+{
+	switch (eClass)
+	{
+	case ig::TopLevelText : return rtl::OUString::createFromAscii("Primary");
+	case ig::SecondLevelText : return rtl::OUString::createFromAscii("Secondary");
+	default:
+		return rtl::OUString();
+	}
+}
+
+rtl::OUString GroupedListLayout::GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex)
+{
+	return GetShapePrefix(eClass) + rtl::OUString::valueOf(nIndex);
+}
+
+
+rtl::OUString GroupedListLayout::GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex, sal_Int32 nChildIndex)
+{
+	return GetShapePrefix(eClass) + rtl::OUString::valueOf(nIndex)+rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("."))+rtl::OUString::valueOf(nChildIndex);
+}
+
+ig::ShapeClass GroupedListLayout::GetClassForName(rtl::OUString sIdentifier)
+{
+
+	ig::ShapeClass eClass;
+	sal_Int32 aLength;
+
+	eClass = ig::TopLevelText;
+	aLength = GetShapePrefix(eClass).getLength();
+	if(sIdentifier.copy(0, aLength) == GetShapePrefix(eClass))
+		return eClass;
+	else 
+		return ig::SecondLevelText;
+
+}
+
+
+
+void GroupedListLayout::AddShape(css::uno::Reference<css::drawing::XShape> rxSelectedShape)
+{
+	IntelligentGroupStyle aStyle;
+	aStyle.aBackground = IntelligentGroupStyle::Foreground;
+	aStyle.aBorder = IntelligentGroupStyle::Regular;
+	aStyle.aText = IntelligentGroupStyle::Secondary;
+
+	sal_Int32 nIndex  = mpModel->GetShapeIndex(rxSelectedShape);
+
+	mpModel->AddShapeDescriptor(nIndex+1,
+		GetShapeDescriptor(rtl::OUString::createFromAscii("Secondary"),
+		ig::Accent,
+		aStyle));
+}
+
+
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/HorizontalListLayoutAlgorithm.cxx sd/source/ui/ig/HorizontalListLayoutAlgorithm.cxx
new file mode 100644
index 0000000..7e410bf
--- /dev/null
+++ sd/source/ui/ig/HorizontalListLayoutAlgorithm.cxx
@@ -0,0 +1,51 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: HorizontalListLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+
+#include "HorizontalListLayoutAlgorithm.hxx"
+
+
+namespace sd { 
+
+
+
+HorizontalListLayoutAlgorithm::HorizontalListLayoutAlgorithm()
+:ListLayoutAlgorithm( ig::Horizontal )
+{
+}
+
+
+HorizontalListLayoutAlgorithm::~HorizontalListLayoutAlgorithm()
+{
+}
+
+
+} // end of namespace ::sd::intelligentgroup
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroup.cxx sd/source/ui/ig/IntelligentGroup.cxx
new file mode 100644
index 0000000..8e3d708
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroup.cxx
@@ -0,0 +1,171 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgroup.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroup.hxx"
+#include "IntelligentGroupLayoutManager.hxx"
+#include <com/sun/star/drawing/XShapeGroup.hpp>
+
+using namespace ::com::sun::star;
+
+
+
+namespace sd{
+	
+IntelligentGroup::IntelligentGroupVector  IntelligentGroup::maActiveGroup;
+
+IntelligentGroup::IntelligentGroup( 
+	uno::Reference<frame::XModel> rxModel,
+	uno::Reference<drawing::XShape> rxShape)
+{
+	awt::Point aPoint = rxShape->getPosition();
+	awt::Size aSize = rxShape->getSize();
+	mpModel.reset(new IntelligentGroupModel(rxModel,awt::Rectangle(aPoint.X, aPoint.Y, aSize.Width, aSize.Height)));
+//	msLayoutName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("NULL"));
+}
+
+bool IntelligentGroup::IsIntelligentGroup(uno::Reference<drawing::XShape> xShape)
+{
+	std::vector<boost::shared_ptr<IntelligentGroup> >::iterator aIter = maActiveGroup.begin();
+	for( ; aIter != maActiveGroup.end(); aIter++ )
+	{
+		boost::shared_ptr<IntelligentGroupModel> pModel = (*aIter)->GetModel();
+		if( pModel->IsInModel( xShape ) ) 
+			return true;
+	}
+	
+	return false;
+}
+
+
+boost::shared_ptr<IntelligentGroup> IntelligentGroup::Instance(	
+	uno::Reference< frame::XModel > rxModel,
+	uno::Reference< drawing::XShape > rxShape)
+{	
+	if( !rxModel.is() )
+		return boost::shared_ptr<IntelligentGroup>();
+
+	std::vector<boost::shared_ptr<IntelligentGroup> >::iterator aIter = maActiveGroup.begin();
+	for ( ; aIter != maActiveGroup.end(); aIter++ )
+	{
+		if( (*aIter)->GetModel()->IsInModel( rxShape ))
+			return (*aIter);
+	}
+	boost::shared_ptr<IntelligentGroup> pGroup( new IntelligentGroup(rxModel,rxShape) );
+	maActiveGroup.push_back(pGroup);
+	return pGroup;
+}
+
+void IntelligentGroup::Dispose()
+{
+	maActiveGroup.clear();
+}
+
+boost::shared_ptr<IntelligentGroupModel> IntelligentGroup::GetModel()
+{
+	return mpModel;
+}
+
+void IntelligentGroup::SetLayout(rtl::OUString sLayoutName)
+{
+	if(!sLayoutName.equals(msLayoutName))
+	{
+		msLayoutName = sLayoutName;
+		GetLayouter();
+		UpdateLayout();
+	}
+}
+
+void IntelligentGroup::SetText(boost::shared_ptr<IntelligentGroupText> pText)
+{
+	mpText = pText;
+	UpdateLayout();
+}
+
+void IntelligentGroup::UpdateLayout()
+{
+	mpText.reset(new IntelligentGroupText(true)); 
+	if(mpText!=NULL)
+	{
+		GetLayouter();
+
+		if(mpLayouter.get()!=NULL)
+		{
+			mpLayouter->DoLayout(mpText);
+		}
+	}
+	
+}
+
+boost::shared_ptr<IntelligentGroupLayouter> IntelligentGroup::GetLayouter()
+{
+	if (mpLayouter.get() == NULL)
+	{
+		if (msLayoutName != NULL)
+		{
+			mpLayout = IntelligentGroupLayoutManager::Instance()->GetLayout(msLayoutName, mpModel);
+			mpLayouter = IntelligentGroupLayoutManager::Instance()->GetLayouter(mpModel, mpLayout);
+		}
+	}
+	return mpLayouter;
+}
+
+boost::shared_ptr<IntelligentGroupLayoutBase> IntelligentGroup::GetLayout()
+{
+	if(mpLayout.get() != NULL)
+		return mpLayout;
+	else 
+		return boost::shared_ptr<IntelligentGroupLayoutBase>();
+}
+
+
+
+void IntelligentGroup::AddShape(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxSelectedShape)
+{
+	if(mpLayouter.get() != NULL)
+	{
+		if(mpModel.get() != NULL)
+		{
+			sal_Int32 nCount = mpModel->GetShapeCount();
+			for(sal_Int32 nIndex = 0; nIndex<nCount; nIndex++)
+			{
+				if(rxSelectedShape == mpModel->GetShape(nIndex))
+				{
+					mpLayouter->AddShape(mpModel->GetShapeDescriptor(nIndex));
+					UpdateLayout();
+					break;
+				}
+			}
+		}
+	}
+}
+
+}// end of namespace sd
diff --git sd/source/ui/ig/IntelligentGroupBulletList.cxx sd/source/ui/ig/IntelligentGroupBulletList.cxx
new file mode 100644
index 0000000..f727697
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupBulletList.cxx
@@ -0,0 +1,135 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupBulletList.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupBulletList.hxx"
+#include "BulletTextIterator.hxx"
+
+namespace sd{
+
+	IntelligentGroupBulletList::IntelligentGroupBulletList()
+		:msIndentationString (::rtl::OUString::createFromAscii("* "))
+	{
+	}
+
+
+	IntelligentGroupBulletList::~IntelligentGroupBulletList()
+	{
+	}
+
+
+	void IntelligentGroupBulletList::SetText(const std::vector< ::rtl::OUString >& rTextVector)
+	{
+		maTextVector.clear();
+
+		std::vector<rtl::OUString>::const_iterator aIter(rTextVector.begin());
+		for (; aIter != rTextVector.end(); aIter++)
+		{
+			sal_uInt32 nLength = 0;
+			const sal_Int32 nDepth = aIter->lastIndexOf('*') + 1;
+
+			if (nDepth)
+				nLength = aIter->getLength() - 1;
+			else
+				nLength = aIter->getLength();
+
+			rtl::OUString aSubString (aIter->copy( nDepth, nLength ));
+			AddText(nDepth, aSubString);
+		}
+	}
+
+
+	boost::shared_ptr<IntelligentGroupTextIterator> IntelligentGroupBulletList::CreateIterator()
+	{
+		return boost::shared_ptr<IntelligentGroupTextIterator> (new BulletTextIterator(this));
+	}
+
+
+
+	void IntelligentGroupBulletList::AddText(const sal_Int32 nDepth, const ::rtl::OUString& rShapeText)
+	{
+		::rtl::OUString sText(::rtl::OUString::createFromAscii(""));
+		for (sal_Int32 i = 0; i < nDepth; i++)
+			sText += msIndentationString;
+		sText += rShapeText;
+		maTextVector.push_back(sText);
+	}
+
+
+	sal_Int32 IntelligentGroupBulletList::GetIndentation(const ::rtl::OUString& rText)
+	{
+		sal_Int32 nDepth = 0;
+		const sal_Int32 nLength = msIndentationString.getLength();
+
+		const ::rtl::OUString sCandidate (rText.copy(0, nLength));
+		if ( sCandidate.equals(msIndentationString) )
+			++nDepth;
+
+		return nDepth;
+	}
+
+
+	sal_Int32 IntelligentGroupBulletList::GetDepth(sal_Int32 nIndex)
+	{
+		return GetIndentation( maTextVector.at(nIndex) );
+	}
+
+
+	sal_Int32 IntelligentGroupBulletList::GetItemCount()
+	{
+		return maTextVector.size();
+	}
+
+
+	::rtl::OUString IntelligentGroupBulletList::GetText(sal_Int32 nItemIndex, sal_Int32 nDepth)
+	{
+		const sal_Int32 nLength = msIndentationString.getLength()
+			;
+		const ::rtl::OUString sText (maTextVector.at(nItemIndex));
+		const ::rtl::OUString sCandidate (sText.copy(0, nLength));
+
+		if ( sCandidate.equals(msIndentationString) )
+			return sText.copy( nLength, sText.getLength()-nLength );
+		else
+			return sText;
+	}
+
+
+	void IntelligentGroupBulletList::Clear()
+	{
+		maTextVector.clear();
+	}
+
+
+} //end of namespace sd
+
+
+
diff --git sd/source/ui/ig/IntelligentGroupController.cxx sd/source/ui/ig/IntelligentGroupController.cxx
new file mode 100644
index 0000000..24c2bab
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupController.cxx
@@ -0,0 +1,149 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgroupcontroller.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupController.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+using namespace ::com::sun::star;
+
+
+
+namespace sd{
+
+IntelligentGroupController::IntelligentGroupController( 
+	uno::Reference<frame::XModel> rxModel,
+	uno::Reference<frame::XController> rxController,
+	ViewShellBase& rBase)
+	:mxModel(rxModel)
+	,mxController(rxController)
+{
+	if(rBase.GetIGSelectionManager().get() != NULL)
+	{
+		mpSelectionManager = rBase.GetIGSelectionManager();
+	}
+	else
+	{
+		mpSelectionManager.reset(new SelectionManager(rxController, rxModel));
+		rBase.SetIGSelectionManager(mpSelectionManager);
+	}
+}
+
+IntelligentGroupController::~IntelligentGroupController()
+{
+
+}
+
+
+void IntelligentGroupController::SetLayout(rtl::OUString sLayoutName, bool /*bCreate*/)
+{
+	// When there is no selected intelligent group then create one and select it.
+	if (mpSelectionManager->GetSelectedIntelligentGroup().get() == NULL)
+	{
+		boost::shared_ptr<IntelligentGroup> pIntelligentGroup = CreateIntelligentGroup();
+		pIntelligentGroup->SetLayout(sLayoutName);
+		mpSelectionManager->Select(pIntelligentGroup);
+	}
+	else
+	{
+		boost::shared_ptr<IntelligentGroup> pIntelligentGroup = mpSelectionManager->GetSelectedIntelligentGroup();
+		if (pIntelligentGroup->GetLayout().get() != NULL)
+		{
+			if(!pIntelligentGroup->GetLayout()->GetLayoutDescriptor()->Name.equals(sLayoutName))
+			{
+				boost::shared_ptr<IntelligentGroup> pIntelligentGroup = CreateIntelligentGroup();
+				pIntelligentGroup->SetLayout(sLayoutName);
+				mpSelectionManager->Select(pIntelligentGroup);
+			}
+		}
+	}
+}
+
+void IntelligentGroupController::DoLayout()
+{
+	boost::shared_ptr<IntelligentGroup> pGroup = mpSelectionManager->GetSelectedIntelligentGroup();
+	if(pGroup.get()!=NULL)
+	{
+		pGroup->UpdateLayout();
+	}
+}
+
+boost::shared_ptr<IntelligentGroup> IntelligentGroupController::GetSelectedIntelligentGroup()
+{
+	return mpSelectionManager->GetSelectedIntelligentGroup();
+}
+
+/*
+boost::shared_ptr<SelectionManager> IntelligentGroupController::GetSelectionManager()
+{
+	return mpSelectionManager;
+}
+*/
+
+boost::shared_ptr<IntelligentGroup> IntelligentGroupController::CreateIntelligentGroup()
+{
+	// Create a new shape group.  Everything else is done by the
+	// IG model and layout assignment.
+	uno::Reference<lang::XMultiServiceFactory> xFactory(mxModel,uno::UNO_QUERY);
+	if (!xFactory.is())
+	{
+		return boost::shared_ptr<IntelligentGroup>();
+	}
+
+		uno::Reference<beans::XPropertySet> xProperties(mxController,uno::UNO_QUERY);
+		uno::Reference<drawing::XDrawPage> xPage(xProperties->getPropertyValue(
+			rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage"))),
+				uno::UNO_QUERY);
+		
+		uno::Reference< drawing::XShape > xShape ( 
+			xFactory->createInstance( 
+				rtl::OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" ) ), 
+			uno::UNO_QUERY );
+
+		// Set size and location of the new group.
+		uno::Reference<beans::XPropertySet> xPageProperties(xPage,uno::UNO_QUERY);
+		if (xPageProperties.is())
+		{
+			uno::Any aAny = xPageProperties->getPropertyValue(rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("Width")));
+			sal_Int32 nPageWidth; aAny >>= nPageWidth;
+			aAny = xPageProperties->getPropertyValue(rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("Height")));
+			sal_Int32 nPageHeight; aAny >>= nPageHeight;
+			awt::Point aPosition( (long)nPageWidth*1/6, (long)nPageHeight*1/6 );
+			xShape->setPosition( aPosition );
+			awt::Size aSize( (long)nPageWidth*2/3, (long)nPageHeight*2/3 );
+			xShape->setSize( aSize );
+		}
+
+		// Finally create and return the intelligent group wrapper.
+		return IntelligentGroup::Instance(mxModel,xShape);	
+}
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupFrame.cxx sd/source/ui/ig/IntelligentGroupFrame.cxx
new file mode 100644
index 0000000..15d911e
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupFrame.cxx
@@ -0,0 +1,1364 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgroupframe.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+
+#include <com/sun/star/util/XChangesNotifier.hpp>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
+
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/dispatch.hxx>
+
+#include <svx/sdr/overlay/overlaymanager.hxx>
+#include <svx/sdr/overlay/overlaysdrobject.hxx>
+#include <svx/sdr/overlay/overlaypolypolygon.hxx>
+#include <svx/svdpagv.hxx>
+#include <svx/sdrpagewindow.hxx>
+#include <svx/sdrpaintwindow.hxx>
+#include <svx/svdopath.hxx>
+#include <svx/xlndsit.hxx>
+#include <svx/xlnclit.hxx>
+#include <svx/xlnstit.hxx>
+#include <svx/xlnedit.hxx>
+#include <svx/xlnstwit.hxx>
+#include <svx/xlnedwit.hxx>
+#include <svx/xlnstcit.hxx>
+#include <svx/xlnedcit.hxx>
+#include <svx/xlntrit.hxx>
+#include <svx/svxids.hrc>
+#include <svx/polypolygoneditor.hxx>
+#include <svx/svddrgmt.hxx>
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/animations/XAnimationNodeSupplier.hpp>
+#include <svx/xlnwtit.hxx>
+
+
+#include "IntelligentGroupFrame.hxx"
+#include "View.hxx"
+#include "sdpage.hxx"
+#include "ViewShell.hxx"
+#include "app.hrc"
+#include "Window.hxx"
+
+using ::rtl::OUString;
+using ::sdr::PolyPolygonEditor;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::drawing;
+
+
+
+
+namespace sd{
+
+const sal_uInt32 SMART_TAG_HDL_NUM = SAL_MAX_UINT32;
+static const int DRGPIX     = 2;    
+
+// --------------------------------------------------------------------
+
+class FrameDragMove : public SdrDragMove
+{
+private:
+	basegfx::B2DPolyPolygon			maPathPolyPolygon;
+
+protected:
+	virtual void createSdrDragEntries();
+
+public:
+	FrameDragMove(SdrDragView& rNewView, 
+		const rtl::Reference <IntelligentGroupFrame >& xFrame,
+		const basegfx::B2DPolyPolygon& rPathPolyPolygon)
+	:	SdrDragMove(rNewView), 
+		maPathPolyPolygon(rPathPolyPolygon),
+		mxFrame( xFrame ) 
+	{}
+
+	FrameDragMove(SdrDragView& rNewView, 
+		const rtl::Reference <IntelligentGroupFrame >& xFrame)
+	:	SdrDragMove(rNewView), 
+		maPathPolyPolygon(),
+		mxFrame( xFrame ) 
+	{}
+
+	virtual bool BeginSdrDrag();
+	virtual bool EndSdrDrag(bool bCopy);
+
+	rtl::Reference <IntelligentGroupFrame > mxFrame;
+};
+
+void FrameDragMove::createSdrDragEntries()
+{
+	// call parent
+	SdrDragMove::createSdrDragEntries();
+
+	if(maPathPolyPolygon.count())
+	{
+		addSdrDragEntry(new SdrDragEntryPolyPolygon(maPathPolyPolygon));
+	}
+}
+
+bool FrameDragMove::BeginSdrDrag()
+{
+	if( mxFrame.is() )
+	{
+		SdrPathObj* pPathObj = mxFrame->getPathObj();
+		if( pPathObj )
+		{
+			DragStat().SetActionRect(pPathObj->GetCurrentBoundRect());
+		}
+	}
+	Show();
+	return TRUE;
+}
+
+bool FrameDragMove::EndSdrDrag(bool /*bCopy*/)
+{
+	Hide();
+	if( mxFrame.is() )
+		mxFrame->MovePath( DragStat().GetDX(), DragStat().GetDY() );
+	return TRUE;
+}
+
+// --------------------------------------------------------------------
+
+class FrameDragResize : public SdrDragResize
+{
+private:
+	basegfx::B2DPolyPolygon			maPathPolyPolygon;
+
+protected:
+	virtual void createSdrDragEntries();
+
+public:
+	FrameDragResize(SdrDragView& rNewView, 
+		const rtl::Reference <IntelligentGroupFrame >& xFrame,
+		const basegfx::B2DPolyPolygon& rPathPolyPolygon)
+		:	SdrDragResize(rNewView), 
+		maPathPolyPolygon(rPathPolyPolygon),
+		mxFrame( xFrame )
+	{}
+
+	FrameDragResize(SdrDragView& rNewView, 
+		const rtl::Reference <IntelligentGroupFrame >& xFrame)
+	:	SdrDragResize(rNewView), 
+		maPathPolyPolygon(),
+		mxFrame( xFrame ) 
+	{}
+
+	virtual bool EndSdrDrag(bool bCopy);
+	rtl::Reference <IntelligentGroupFrame > mxFrame;
+};
+
+// --------------------------------------------------------------------
+
+void FrameDragResize::createSdrDragEntries()
+{
+	// call parent
+	SdrDragResize::createSdrDragEntries();
+
+	if(maPathPolyPolygon.count())
+	{
+		addSdrDragEntry(new SdrDragEntryPolyPolygon(maPathPolyPolygon));
+	}
+}
+
+bool FrameDragResize::EndSdrDrag(bool /*bCopy*/)
+{
+	Hide();
+	if( mxFrame.is() )
+	{
+		SdrPathObj* pPathObj = mxFrame->getPathObj();
+		if( pPathObj )
+		{
+			basegfx::B2DHomMatrix aTrans;
+			const Point aRef( DragStat().Ref1() );
+			aTrans.translate(-aRef.X(), -aRef.Y());
+			aTrans.scale(double(aXFact), double(aYFact));
+			aTrans.translate(aRef.X(), aRef.Y());
+			basegfx::B2DPolyPolygon aDragPoly(pPathObj->GetPathPoly());
+			aDragPoly.transform(aTrans);
+			pPathObj->SetPathPoly( aDragPoly );
+			//IG
+			basegfx::B2DRange aRange = aDragPoly.getB2DRange();
+			mxFrame->GetModel()->SetLocation(
+				::com::sun::star::awt::Point(long(aRange.getMinX()+aRange.getWidth()/22),long(aRange.getMinY()+aRange.getHeight()/22)));
+			mxFrame->GetModel()->SetSize(
+				::com::sun::star::awt::Size(long(aRange.getWidth()*11/12),long(aRange.getHeight()*11/12)));
+			if(mxFrame->GetLayouter().get() != NULL)
+			{
+				mxFrame->GetLayouter()->GetLayoutAlgorithm()->PlaceShape(
+					mxFrame->GetLayouter()->GetLayout(),
+//					mxFrame->GetLayouter()->GetShapeDescriptors(),
+					mxFrame->GetModel(),
+					::com::sun::star::awt::Rectangle(mxFrame->GetModel()->GetLocation().X,
+					mxFrame->GetModel()->GetLocation().Y,
+					mxFrame->GetModel()->GetSize().Width,
+					mxFrame->GetModel()->GetSize().Height));
+			}
+		}
+	}
+	return TRUE;
+}
+
+// --------------------------------------------------------------------
+
+class FrameDragObjOwn : public SdrDragObjOwn
+{
+private:
+	basegfx::B2DPolyPolygon			maPathPolyPolygon;
+
+protected:
+	virtual void createSdrDragEntries();
+
+public:
+	FrameDragObjOwn(SdrDragView& rNewView,
+		const basegfx::B2DPolyPolygon& rPathPolyPolygon)
+		:	SdrDragObjOwn(rNewView),
+		maPathPolyPolygon(rPathPolyPolygon)
+	{}
+
+	FrameDragObjOwn(SdrDragView& rNewView)
+		:	SdrDragObjOwn(rNewView),
+		maPathPolyPolygon()
+	{}
+
+	virtual bool EndSdrDrag(bool bCopy);
+};
+
+// --------------------------------------------------------------------
+
+void FrameDragObjOwn::createSdrDragEntries()
+{
+	// call parent
+	SdrDragObjOwn::createSdrDragEntries();
+
+	if(maPathPolyPolygon.count())
+	{
+		addSdrDragEntry(new SdrDragEntryPolyPolygon(maPathPolyPolygon));
+	}
+}
+
+bool FrameDragObjOwn::EndSdrDrag(bool /*bCopy*/)
+{
+	Hide();
+	SdrObject* pObj=GetDragObj();
+	if (pObj!=NULL)
+		return pObj->applySpecialDrag(DragStat());
+	else
+		return FALSE;
+}
+
+// --------------------------------------------------------------------
+
+class SdFrameHdl : public SmartHdl
+{
+public:
+	SdFrameHdl( const SmartTagReference& xTag, SdrPathObj* mpPathObj );
+	virtual ~SdFrameHdl();
+	virtual void CreateB2dIAObject();
+	virtual BOOL IsFocusHdl() const;
+	virtual Pointer GetPointer() const;
+	virtual bool isMarkable() const;
+
+private:
+	SdrPathObj* mpPathObj;
+	rtl::Reference< IntelligentGroupFrame > mxFrame;
+	::sdr::overlay::OverlayObject* pNewOverlayObject;
+};
+
+// --------------------------------------------------------------------
+
+SdFrameHdl::SdFrameHdl( const SmartTagReference& xTag, SdrPathObj* pPathObj )
+: SmartHdl( xTag, pPathObj->GetCurrentBoundRect().TopLeft() )
+, mpPathObj( pPathObj )
+, mxFrame( dynamic_cast< IntelligentGroupFrame* >( xTag.get() ) )
+, pNewOverlayObject( NULL )
+{
+}
+
+// --------------------------------------------------------------------
+
+SdFrameHdl::~SdFrameHdl()
+{
+
+}
+
+// --------------------------------------------------------------------
+
+void SdFrameHdl::CreateB2dIAObject()
+{
+	// first throw away old one
+	GetRidOfIAObject();
+
+	if(pHdlList)
+	{
+		SdrMarkView* pView = pHdlList->GetView();
+
+		if(pView && !pView->areMarkHandlesHidden())
+		{
+			SdrPageView* pPageView = pView->GetSdrPageView();
+
+			if(pPageView)
+			{
+				for(sal_uInt32 b(0L); b < pPageView->PageWindowCount(); b++)
+				{
+					// const SdrPageViewWinRec& rPageViewWinRec = rPageViewWinList[b];
+					const SdrPageWindow& rPageWindow = *pPageView->GetPageWindow(b);
+
+					if(rPageWindow.GetPaintWindow().OutputToWindow())
+					{
+						if(rPageWindow.GetOverlayManager())
+						{
+							const SdrPathObj& rPath = *mpPathObj;
+
+							::sdr::overlay::OverlayObject* pNewOverlayObject = new
+								::sdr::overlay::OverlaySdrObject(basegfx::B2DPoint(), rPath);
+							//::sdr::overlay::OverlayPolyPolygonStriped( maPolyPolygon );
+							DBG_ASSERT(pNewOverlayObject, "Got NO new IAO!");
+
+							// OVERLAYMANAGER
+							if(pNewOverlayObject)
+							{
+								rPageWindow.GetOverlayManager()->add(*pNewOverlayObject);
+								maOverlayGroup.append(*pNewOverlayObject);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+// --------------------------------------------------------------------
+
+BOOL SdFrameHdl::IsFocusHdl() const
+{
+	return FALSE;
+}
+
+// --------------------------------------------------------------------
+
+bool SdFrameHdl::isMarkable() const
+{
+	return false;
+}
+
+// --------------------------------------------------------------------
+
+Pointer SdFrameHdl::GetPointer() const
+{
+	PointerStyle eStyle = POINTER_NOTALLOWED;
+	if( mxFrame.is() )
+	{
+		if( mxFrame->isSelected() )
+		{
+			if( !mxFrame->getView().IsFrameDragSingles() && mxFrame->getView().IsInsObjPointMode() )
+				eStyle = POINTER_CROSS;
+			else
+				eStyle = POINTER_MOVE;
+		}
+		else
+		{
+			eStyle = POINTER_ARROW;
+
+		}
+	}
+	return Pointer( eStyle );
+}
+
+
+// ====================================================================
+
+IntelligentGroupFrame::IntelligentGroupFrame( boost::shared_ptr<IntelligentGroupModel> pModel, ::sd::View& rView )
+: SmartTag( rView )
+, mpModel( pModel )
+{
+	mpPathObj = new SdrPathObj(OBJ_RECT);
+
+	::com::sun::star::awt::Rectangle rBoundingBox(mpModel->GetLocation().X,mpModel->GetLocation().Y,mpModel->GetSize().Width,mpModel->GetSize().Height);
+	basegfx::B2DPolygon aRectanglePolygon;
+	aRectanglePolygon.append(::basegfx::B2DPoint( rBoundingBox.X-rBoundingBox.Width/20,rBoundingBox.Y-rBoundingBox.Height/20));
+	aRectanglePolygon.append(::basegfx::B2DPoint( rBoundingBox.Width*21/20+rBoundingBox.X,rBoundingBox.Y-rBoundingBox.Height/20));
+	
+	aRectanglePolygon.append(::basegfx::B2DPoint( rBoundingBox.Width*21/20+rBoundingBox.X,rBoundingBox.Height*21/20+rBoundingBox.Y));
+	aRectanglePolygon.append(::basegfx::B2DPoint( rBoundingBox.X-rBoundingBox.Width/20,rBoundingBox.Height*21/20+rBoundingBox.Y));
+	
+	basegfx::B2DPolyPolygon aGeometry(aRectanglePolygon);
+	aGeometry.setClosed(true);
+	mpPathObj->SetPathPoly(aGeometry);
+	maOriginPos = ::com::sun::star::awt::Point(long(aGeometry.getB2DRange().getMinX()),long(aGeometry.getB2DRange().getMinY()));
+
+	SdrPage* pPage = mrView.GetSdrPageView()->GetPage();
+	if( pPage )
+	{
+		mpPathObj->SetPage( pPage );
+		mpPathObj->SetObjList( pPage );
+	}
+
+	XDash aDash( XDASH_RECT, 1, 80, 1, 80, 80);
+	String aEmpty( RTL_CONSTASCII_USTRINGPARAM("?") );
+//	mpPathObj->SetMergedItem( XLineDashItem( aEmpty, aDash ) );
+	mpPathObj->SetMergedItem( XLineStyleItem( XLINE_DASH ) );
+	
+	mpPathObj->SetMergedItem( XLineColorItem(aEmpty, ::Color(COL_GRAY)) );
+	mpPathObj->SetMergedItem( XFillStyleItem( XFILL_SOLID ) );
+	mpPathObj->SetMergedItem( XLineWidthItem(100));
+
+	//Do not need arrow here
+/*	::basegfx::B2DPolygon aStartArrow;
+	aStartArrow.append(::basegfx::B2DPoint(20.0, 0.0));
+	aStartArrow.append(::basegfx::B2DPoint(0.0,  0.0));
+	aStartArrow.append(::basegfx::B2DPoint(10.0, 30.0));
+	aStartArrow.setClosed(true);
+	mpPathObj->SetMergedItem(XLineStartItem(aEmpty,::basegfx::B2DPolyPolygon(aStartArrow)));
+	mpPathObj->SetMergedItem(XLineStartWidthItem(400));
+	mpPathObj->SetMergedItem(XLineStartCenterItem(TRUE));
+*/
+//	updatePathAttributes();
+
+	mpPathObj->SetMergedItem(XLineTransparenceItem(50));
+
+	mpMark = new SdrMark( mpPathObj, mrView.GetSdrPageView() );
+
+	select();
+
+//	mpPathObj->AddListener( *this );
+
+/*	Reference< XChangesNotifier > xNotifier( mrModel.GetUnoModel(), UNO_QUERY);
+	if( xNotifier.is() )
+	{
+		Reference< XChangesListener > xListener( this );
+		xNotifier->addChangesListener( this );
+	}
+*/
+}
+
+// --------------------------------------------------------------------
+
+IntelligentGroupFrame::~IntelligentGroupFrame()
+{
+	DBG_ASSERT( mpPathObj == 0, "sd::MotionPathTag::~MotionPathTag(), dispose me first!" );
+	if( !isDisposed() )
+		Dispose();
+}
+
+// --------------------------------------------------------------------
+
+
+void IntelligentGroupFrame::SetLayouter(boost::shared_ptr<IntelligentGroupLayouter> pLayouter)
+{
+	mpLayouter = pLayouter;
+}
+
+boost::shared_ptr<IntelligentGroupLayouter> IntelligentGroupFrame::GetLayouter()
+{
+	return mpLayouter;
+}
+
+boost::shared_ptr<IntelligentGroupModel> IntelligentGroupFrame::GetModel()
+{
+	return mpModel;
+}
+
+/*
+void IntelligentGroupFrame::updatePathAttributes()
+{
+	String aEmpty( RTL_CONSTASCII_USTRINGPARAM("?") );
+
+	::basegfx::B2DPolygon aCandidate;
+	if( mxPolyPoly.count() )
+	{
+		aCandidate = mxPolyPoly.getB2DPolygon(0);
+		::basegfx::tools::checkClosed( aCandidate );
+	}
+
+	if( !aCandidate.isClosed() )
+	{
+		//Do not need arrow here
+		::basegfx::B2DPolygon aEndArrow;
+		aEndArrow.append(::basegfx::B2DPoint(10.0, 0.0));
+		aEndArrow.append(::basegfx::B2DPoint(0.0, 30.0));
+		aEndArrow.append(::basegfx::B2DPoint(20.0, 30.0));
+		aEndArrow.setClosed(true);
+		mpPathObj->SetMergedItem(XLineEndItem(aEmpty,::basegfx::B2DPolyPolygon(aEndArrow)));
+		mpPathObj->SetMergedItem(XLineEndWidthItem(400));
+		mpPathObj->SetMergedItem(XLineEndCenterItem(TRUE));
+	}
+	else
+	{
+		mpPathObj->SetMergedItem(XLineEndItem());
+	}
+}
+*/
+
+
+// --------------------------------------------------------------------
+
+void IntelligentGroupFrame::MovePath( int nDX, int nDY )
+{
+	if( mpPathObj )
+	{
+		mpPathObj->Move( Size( nDX, nDY ) );
+		mpModel->SetLocation(::com::sun::star::awt::Point(mpModel->GetLocation().X+nDX,mpModel->GetLocation().Y+nDY));
+		if(mpLayouter.get() != NULL)
+		{
+			mpLayouter->GetLayoutAlgorithm()->PlaceShape(
+				mpLayouter->GetLayout(),
+//				mpLayouter->GetShapeDescriptors(),
+				mpModel,
+				::com::sun::star::awt::Rectangle(mpModel->GetLocation().X,
+					mpModel->GetLocation().Y,
+					mpModel->GetSize().Width,
+					mpModel->GetSize().Height));
+		}
+
+		mrView.updateHandles();
+	}
+}
+
+// --------------------------------------------------------------------
+
+/** returns true if the MotionPathTag handled the event. */
+bool IntelligentGroupFrame::MouseButtonDown( const MouseEvent& rMEvt, SmartHdl& rHdl )
+{
+	if( !mpPathObj )
+		return false;
+
+	if( !isSelected() )
+	{
+		SmartTagReference xTag( this );
+		mrView.getSmartTags().select( xTag );
+		return true;
+	}
+	else
+	{
+		if( rMEvt.IsLeft() && (rMEvt.GetClicks() == 2) )
+		{
+			mrView.GetViewShell()->GetViewFrame()->GetDispatcher()->Execute(SID_BEZIER_EDIT, SFX_CALLMODE_ASYNCHRON);
+			return true;
+		}
+		else if( rMEvt.IsLeft() )
+		{			
+			OutputDevice* pOut = mrView.GetViewShell()->GetActiveWindow();
+			Point aMDPos( pOut->PixelToLogic( rMEvt.GetPosPixel() ) );
+
+			if( !mrView.IsFrameDragSingles() && mrView.IsInsObjPointMode() && (rHdl.GetObjHdlNum() == SMART_TAG_HDL_NUM) )
+			{
+				// insert a point in edit mode
+				const bool bNewObj = rMEvt.IsMod1();
+
+				mrView.BrkAction();
+
+				Point aPt(aMDPos); // - pMarkedPV->GetOffset());
+
+				if(bNewObj) 
+					aPt = mrView.GetSnapPos(aPt,mrView.GetSdrPageView());
+
+				sal_Bool bClosed0(mpPathObj->IsClosedObj());
+
+				sal_uInt32 nInsPointNum = mpPathObj->NbcInsPointOld(aPt, bNewObj, sal_True);
+
+				if(bClosed0 != mpPathObj->IsClosedObj())
+				{ 
+					// Obj was closed implicit
+					// object changed
+					mpPathObj->SetChanged();
+					mpPathObj->BroadcastObjectChange();
+				}
+
+				if(0xffffffff != nInsPointNum) 
+				{
+					mrView.UnmarkAllPoints();
+					mrView.updateHandles();
+
+					bool bRet = mrView.BegDragObj(aMDPos, pOut, mrView.GetHdl(nInsPointNum+1), 0, new FrameDragObjOwn( mrView ) );
+
+					if (bRet) 
+					{
+						const_cast< SdrDragStat* >( &mrView.GetDragStat() )->SetMinMoved();
+						mrView.MovDragObj(aMDPos);
+					}
+				}
+				return true;
+			}
+			else
+			{
+				SmartHdl* pHdl = &rHdl;
+				if (!mrView.IsPointMarked(*pHdl) || rMEvt.IsShift())
+				{
+					if (!rMEvt.IsShift())
+					{
+						mrView.UnmarkAllPoints();
+						pHdl = dynamic_cast< SmartHdl* >( mrView.PickHandle(aMDPos) );
+					}
+					else
+					{
+						if (mrView.IsPointMarked(*pHdl) )
+						{
+							mrView.UnmarkPoint(*pHdl);
+							pHdl = NULL;
+						}
+						else
+						{
+							pHdl = dynamic_cast< SmartHdl* >( mrView.PickHandle(aMDPos) );
+						}
+					}
+
+					if (pHdl)
+						mrView.MarkPoint(*pHdl);
+				}
+
+
+				if( pHdl && !rMEvt.IsRight() )
+				{
+					mrView.BrkAction();
+					const USHORT nDrgLog = (USHORT)pOut->PixelToLogic(Size(DRGPIX,0)).Width();
+
+					rtl::Reference< IntelligentGroupFrame > xTag( this );
+					SdrDragMethod* pDragMethod;
+					
+					const basegfx::B2DPolyPolygon aDragPoly(mpPathObj->GetPathPoly());
+
+					if( (pHdl->GetKind() == HDL_MOVE) || (pHdl->GetKind() == HDL_SMARTTAG) )
+					{
+						pDragMethod = new FrameDragMove( mrView, xTag );
+						pHdl->SetPos( aMDPos );
+					}
+					else if( pHdl->GetKind() == HDL_POLY )
+					{
+						pDragMethod = new FrameDragObjOwn( mrView );
+					}
+					else
+					{
+						pDragMethod = new FrameDragResize( mrView, xTag );
+					}
+
+					mrView.BegDragObj(aMDPos, NULL, pHdl, nDrgLog, pDragMethod );
+
+/*					basegfx::B2DPolyPolygon aDragPoly(mpPathObj->GetPathPoly());
+					mrView.GetSdrPageView()->setDragPoly0(aDragPoly);
+					mrView.GetSdrPageView()->setDragPoly(aDragPoly);
+*/				}
+				return true;
+			}
+		} 
+	}
+
+	return false;
+}
+
+// --------------------------------------------------------------------
+
+/** returns true if the SmartTag consumes this event. */
+bool IntelligentGroupFrame::KeyInput( const KeyEvent& rKEvt )
+{
+	if( !mpPathObj )
+		return false;
+
+	USHORT nCode = rKEvt.GetKeyCode().GetCode();
+	switch( nCode )
+	{
+	case KEY_DELETE:
+		return OnDelete();
+
+	case KEY_DOWN:
+	case KEY_UP:
+	case KEY_LEFT:
+	case KEY_RIGHT:
+		return OnMove( rKEvt );
+
+	case KEY_ESCAPE:
+		{
+			SmartTagReference xThis( this );
+			mrView.getSmartTags().deselect();
+			return true;
+		}
+
+	case KEY_TAB:
+		return OnTabHandles( rKEvt );
+
+	case KEY_SPACE:
+		return OnMarkHandle( rKEvt );
+
+	default:
+		break;
+	}
+	return false;
+}
+
+bool IntelligentGroupFrame::OnDelete()
+{
+//	mrPane.remove( mpEffect );
+	return true;
+}
+
+bool IntelligentGroupFrame::OnTabHandles( const KeyEvent& rKEvt )
+{
+	if(rKEvt.GetKeyCode().IsMod1() || rKEvt.GetKeyCode().IsMod2())
+	{
+		const SdrHdlList& rHdlList = mrView.GetHdlList();
+		sal_Bool bForward(!rKEvt.GetKeyCode().IsShift());
+
+		((SdrHdlList&)rHdlList).TravelFocusHdl(bForward);
+
+		// guarantee visibility of focused handle
+		SdrHdl* pHdl = rHdlList.GetFocusHdl();
+
+		if(pHdl)
+		{
+			Window* pWindow = mrView.GetViewShell()->GetActiveWindow();
+			if( pWindow )
+			{
+				Point aHdlPosition(pHdl->GetPos());
+				Rectangle aVisRect(aHdlPosition - Point(100, 100), Size(200, 200));
+				mrView.MakeVisible(aVisRect, *pWindow);
+			}
+		}
+
+		return true;
+	}
+
+	return false;
+}
+
+bool IntelligentGroupFrame::OnMarkHandle( const KeyEvent& rKEvt )
+{
+	const SdrHdlList& rHdlList = mrView.GetHdlList();
+	SdrHdl* pHdl = rHdlList.GetFocusHdl();
+
+	if(pHdl && pHdl->GetKind() == HDL_POLY )
+	{
+		// rescue ID of point with focus
+		sal_uInt32 nPol(pHdl->GetPolyNum());
+		sal_uInt32 nPnt(pHdl->GetPointNum());
+
+		if(mrView.IsPointMarked(*pHdl))
+		{
+			if(rKEvt.GetKeyCode().IsShift())
+			{
+				mrView.UnmarkPoint(*pHdl);
+			}
+		}
+		else
+		{
+			if(!rKEvt.GetKeyCode().IsShift())
+			{
+				mrView.UnmarkAllPoints();
+			}
+			mrView.MarkPoint(*pHdl);
+		}
+
+		if(0L == rHdlList.GetFocusHdl())
+		{
+			// restore point with focus
+			SdrHdl* pNewOne = 0L;
+
+			for(sal_uInt32 a(0); !pNewOne && a < rHdlList.GetHdlCount(); a++)
+			{
+				SdrHdl* pAct = rHdlList.GetHdl(a);
+
+				if(pAct && pAct->GetKind() == HDL_POLY && pAct->GetPolyNum() == nPol && pAct->GetPointNum() == nPnt)
+					pNewOne = pAct;
+			}
+
+			if(pNewOne)
+				((SdrHdlList&)rHdlList).SetFocusHdl(pNewOne);
+		}
+	}
+
+	return true;
+}
+
+bool IntelligentGroupFrame::OnMove( const KeyEvent& rKEvt )
+{
+	long nX = 0;
+	long nY = 0;
+
+	switch( rKEvt.GetKeyCode().GetCode() )
+	{
+	case KEY_UP:	nY = -1; break;
+	case KEY_DOWN:	nY =  1; break;
+	case KEY_LEFT:	nX = -1; break;
+	case KEY_RIGHT:	nX =  1; break;
+	default: break;
+	}
+
+	if(rKEvt.GetKeyCode().IsMod2())
+	{
+		OutputDevice* pOut = mrView.GetViewShell()->GetActiveWindow();
+		Size aLogicSizeOnePixel = (pOut) ? pOut->PixelToLogic(Size(1,1)) : Size(100, 100);
+		nX *= aLogicSizeOnePixel.Width();
+		nY *= aLogicSizeOnePixel.Height();
+	}
+	else
+	{
+		// old, fixed move distance
+		nX *= 100;
+		nY *= 100;
+	}
+
+	if( nX || nY )
+	{
+		// in point edit mode move the handle with the focus
+		const SdrHdlList& rHdlList = mrView.GetHdlList();
+		SdrHdl* pHdl = rHdlList.GetFocusHdl();
+
+		if(pHdl)
+		{
+			// now move the Handle (nX, nY)
+			Point aStartPoint(pHdl->GetPos());
+			Point aEndPoint(pHdl->GetPos() + Point(nX, nY));
+
+			// start dragging
+			rtl::Reference< IntelligentGroupFrame > xTag( this );
+			SdrDragMethod* pDragMethod = 0;
+			if( (pHdl->GetKind() == HDL_MOVE) || (pHdl->GetKind() == HDL_SMARTTAG) )
+			{
+				pDragMethod = new FrameDragMove( mrView, xTag );
+			}
+			else if( pHdl->GetKind() == HDL_POLY )
+			{
+				pDragMethod = new FrameDragObjOwn( mrView );
+			}
+			else if( pHdl->GetKind() != HDL_BWGT )
+			{
+				pDragMethod = new FrameDragResize( mrView, xTag );
+			}
+			mrView.BegDragObj(aStartPoint, 0, pHdl, 0, pDragMethod);
+
+			if(mrView.IsDragObj())
+			{
+				FASTBOOL bWasNoSnap = mrView.GetDragStat().IsNoSnap();
+				BOOL bWasSnapEnabled = mrView.IsSnapEnabled();
+
+				// switch snapping off
+				if(!bWasNoSnap)
+					((SdrDragStat&)mrView.GetDragStat()).SetNoSnap(TRUE);
+				if(bWasSnapEnabled)
+					mrView.SetSnapEnabled(FALSE);
+
+				mrView.MovAction(aEndPoint);
+				mrView.EndDragObj();
+
+				// restore snap
+				if(!bWasNoSnap)
+					((SdrDragStat&)mrView.GetDragStat()).SetNoSnap(bWasNoSnap);
+				if(bWasSnapEnabled)
+					mrView.SetSnapEnabled(bWasSnapEnabled);
+			}
+		}
+		else
+		{
+			// move the path
+			MovePath( nX, nY );
+		}
+	}
+
+	return true;
+}
+
+// --------------------------------------------------------------------
+
+ULONG IntelligentGroupFrame::GetMarkablePointCount() const
+{
+	if( mpPathObj && isSelected() )
+	{
+		return mpPathObj->GetPointCount();
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+// --------------------------------------------------------------------
+
+ULONG IntelligentGroupFrame::GetMarkedPointCount() const
+{
+	if( mpMark )
+	{
+		const SdrUShortCont* pPts=mpMark->GetMarkedPoints();
+		return pPts ? pPts->GetCount() : 0;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+// --------------------------------------------------------------------
+
+BOOL IntelligentGroupFrame::MarkPoint(SdrHdl& rHdl, BOOL bUnmark )
+{
+	BOOL bRet=FALSE;
+	if( mpPathObj && mrView.IsPointMarkable( rHdl ) && (rHdl.GetKind() != HDL_SMARTTAG) )
+	{
+		SmartHdl* pSmartHdl = dynamic_cast< SmartHdl* >( &rHdl );
+		if( pSmartHdl && pSmartHdl->getTag().get() == this )
+		{
+			SdrUShortCont* pPts=mpMark->ForceMarkedPoints();
+			pPts->ForceSort();
+			if (mrView.MarkPointHelper(&rHdl,mpMark,bUnmark))
+			{
+				pPts->ForceSort();
+				mrView.MarkListHasChanged();
+				bRet=TRUE;
+			}
+		}
+	}
+	return bRet;
+}
+
+// --------------------------------------------------------------------
+
+BOOL IntelligentGroupFrame::MarkPoints(const Rectangle* pRect, BOOL bUnmark )
+{
+	BOOL bChgd=FALSE;
+
+	if( mpPathObj && isSelected() )
+	{
+		sal_Int32 nHdlNum = mrView.GetHdlList().GetHdlCount() - 1;
+		while( nHdlNum > 0 )
+		{
+			SmartHdl* pHdl = dynamic_cast< SmartHdl* >( mrView.GetHdl( sal::static_int_cast< ULONG >( nHdlNum-- ) ) );
+
+			if( pHdl && (pHdl->getTag().get() == this) && mrView.IsPointMarkable(*pHdl) && pHdl->IsSelected()==bUnmark)
+			{
+				Point aPos(pHdl->GetPos());
+				if( pRect==NULL || pRect->IsInside(aPos))
+				{
+					if( mrView.MarkPointHelper(pHdl,mpMark,bUnmark) )
+						bChgd=TRUE;
+				}
+			}
+		}
+
+		if(bChgd)
+			mrView.MarkListHasChanged();
+	}
+
+	return bChgd;
+}
+
+// --------------------------------------------------------------------
+
+bool IntelligentGroupFrame::getContext( SdrViewContext& rContext )
+{
+	if( mpPathObj && isSelected() && !mrView.IsFrameDragSingles() )
+	{
+		rContext = SDRCONTEXT_POINTEDIT;
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+}
+
+// --------------------------------------------------------------------
+
+void IntelligentGroupFrame::CheckPossibilities()
+{
+	if( mpPathObj )
+	{
+		if( isSelected() )
+		{
+			if( mrView.IsFrameDragSingles() )
+			{
+				mrView.SetMoveAllowed( true );
+				mrView.SetMoveProtected( false );
+				mrView.SetResizeFreeAllowed( true );
+				mrView.SetResizePropAllowed( true );
+				mrView.SetResizeProtected( false );
+
+			}
+			else
+			{
+				bool b1stSmooth(true);
+				bool b1stSegm(true);
+				bool bCurve(false);
+				bool bSmoothFuz(false);
+				bool bSegmFuz(false);
+				basegfx::B2VectorContinuity eSmooth = basegfx::CONTINUITY_NONE;
+
+				mrView.CheckPolyPossibilitiesHelper( mpMark, b1stSmooth, b1stSegm, bCurve, bSmoothFuz, bSegmFuz, eSmooth );
+			}
+		}
+	}
+}
+
+// --------------------------------------------------------------------
+
+void IntelligentGroupFrame::addCustomHandles( SdrHdlList& rHandlerList )
+{
+	if( mpPathObj )
+	{
+		SmartTagReference xThis( this );
+		SdFrameHdl* pHdl = new SdFrameHdl( xThis, mpPathObj );
+
+		pHdl->SetObjHdlNum( SMART_TAG_HDL_NUM );
+		pHdl->SetPageView( mrView.GetSdrPageView() );
+
+		pHdl->SetObj(mpPathObj);
+		rHandlerList.AddHdl( pHdl );
+
+		if( isSelected() )
+		{
+			if( mrView.GetSdrPageView() )
+				mrView.GetSdrPageView()->SetHasMarkedObj(TRUE);
+
+			if( !mrView.IsFrameDragSingles() )
+			{
+				SdrHdlList aTemp( rHandlerList.GetView() );
+				mpPathObj->AddToHdlList( aTemp );
+				const SdrUShortCont* pMrkPnts=mpMark->GetMarkedPoints();
+
+				sal_uInt32 nHandle;
+				for( nHandle = 0; nHandle < aTemp.GetHdlCount(); ++nHandle )
+				{
+					SdrHdl* pTempHdl = aTemp.GetHdl( nHandle );
+
+					SmartHdl* pSmartHdl = new SmartHdl( xThis, mpPathObj, pTempHdl->GetPos(), pTempHdl->GetKind() );
+					pSmartHdl->SetObjHdlNum( nHandle );
+					pSmartHdl->SetPolyNum( pTempHdl->GetPolyNum() );
+					pSmartHdl->SetPointNum( pTempHdl->GetPointNum() );
+					pSmartHdl->SetPlusHdl(  pTempHdl->IsPlusHdl() );
+					pSmartHdl->SetSourceHdlNum( pTempHdl->GetSourceHdlNum() );
+					pSmartHdl->SetPageView( mrView.GetSdrPageView() );
+
+					rHandlerList.AddHdl( pSmartHdl );
+
+					const bool bSelected= pMrkPnts && pMrkPnts->Exist(sal::static_int_cast< USHORT >(nHandle));
+					pSmartHdl->SetSelected(bSelected);
+
+					if( mrView.IsPlusHandlesAlwaysVisible() || bSelected ) 
+					{
+						sal_uInt32 nPlusAnz=mpPathObj->GetPlusHdlCount(*pSmartHdl);
+						for (sal_uInt32 nPlusNum=0; nPlusNum<nPlusAnz; nPlusNum++) 
+						{
+							SdrHdl* pPlusHdl = mpPathObj->GetPlusHdl(*pSmartHdl,nPlusNum);
+							if (pPlusHdl!=NULL) 
+							{
+								pPlusHdl->SetObj(mpPathObj);
+								pPlusHdl->SetPageView(mrView.GetSdrPageView());
+								pPlusHdl->SetPlusHdl(TRUE);
+								rHandlerList.AddHdl(pPlusHdl);
+							}
+						}
+					}
+				}
+			}
+			else
+			{
+				Rectangle aRect(mpPathObj->GetCurrentBoundRect());
+
+				if(!aRect.IsEmpty()) 
+				{
+					ULONG nCount = rHandlerList.GetHdlCount();
+
+					BOOL bWdt0=aRect.Left()==aRect.Right();
+					BOOL bHgt0=aRect.Top()==aRect.Bottom();
+					if (bWdt0 && bHgt0) 
+					{
+						rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.TopLeft(),HDL_UPLFT));
+					} 
+					else if (bWdt0 || bHgt0)
+					{
+						rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.TopLeft()    ,HDL_UPLFT));
+						rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.BottomRight(),HDL_LWRGT));
+					} 
+					else 
+					{
+						if (!bWdt0 && !bHgt0) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.TopLeft()     ,HDL_UPLFT));
+						if (          !bHgt0) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.TopCenter()   ,HDL_UPPER));
+						if (!bWdt0 && !bHgt0) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.TopRight()    ,HDL_UPRGT));
+						if (!bWdt0          ) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.LeftCenter()  ,HDL_LEFT ));
+						if (!bWdt0          ) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.RightCenter() ,HDL_RIGHT));
+						if (!bWdt0 && !bHgt0) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.BottomLeft()  ,HDL_LWLFT));
+						if (          !bHgt0) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.BottomCenter(),HDL_LOWER));
+						if (!bWdt0 && !bHgt0) rHandlerList.AddHdl(new SmartHdl( xThis, mpPathObj, aRect.BottomRight() ,HDL_LWRGT));
+					}
+
+					while( nCount < rHandlerList.GetHdlCount() )
+					{
+						rHandlerList.GetHdl(nCount++)->SetPageView( mrView.GetSdrPageView() );
+					}
+				}
+			}
+		}
+	}
+}
+
+// --------------------------------------------------------------------
+
+void IntelligentGroupFrame::disposing()
+{
+	if( mpPathObj )
+	{
+		SdrPathObj* pPathObj = mpPathObj;
+		mpPathObj = 0;
+		mrView.updateHandles(); 
+
+		delete pPathObj;
+	}
+
+	if( mpMark )
+	{
+		delete mpMark;
+		mpMark = 0;
+	}
+
+	SmartTag::disposing();
+}
+
+// --------------------------------------------------------------------
+
+void IntelligentGroupFrame::deselect()
+{
+	SmartTag::deselect();
+
+	if( mpMark )
+	{
+		SdrUShortCont* pPts = mpMark->GetMarkedPoints();
+
+		if( pPts ) 
+			pPts->Clear();
+	}
+}
+
+// --------------------------------------------------------------------
+// IPolyPolygonEditorController
+// --------------------------------------------------------------------
+
+void IntelligentGroupFrame::DeleteMarkedPoints()
+{
+	if( mpPathObj && IsDeleteMarkedPointsPossible() )
+	{
+		mrView.BrkAction();
+
+		// Description
+		//		BegUndo(ImpGetResStr(STR_EditDelete),GetDescriptionOfMarkedPoints(),SDRREPFUNC_OBJ_DELETE);
+
+		SdrUShortCont* pPts = mpMark->GetMarkedPoints();
+
+		if( pPts ) 
+		{
+			PolyPolygonEditor aEditor( mpPathObj->GetPathPoly(), mpPathObj->IsClosed() );
+			if( aEditor.DeletePoints( pPts->getContainer() ) )
+			{
+				if( aEditor.GetPolyPolygon().count() )
+				{
+					//					AddUndo(GetModel()->GetSdrUndoFactory().CreateUndoGeoObject(*pPath ));
+					mpPathObj->SetPathPoly( aEditor.GetPolyPolygon() );
+				}
+				else
+				{
+					//					AddUndo( GetModel()->GetSdrUndoFactory().CreateUndoDeleteObject(*pPath ) );
+					//					pM->GetPageView()->GetObjList()->RemoveObject(pObj->GetOrdNum());
+				}
+
+				mrView.UnmarkAllPoints();
+				mrView.MarkListHasChanged();
+				mrView.updateHandles();
+			}
+		}
+
+		//		EndUndo();
+	}
+}
+
+BOOL IntelligentGroupFrame::IsDeleteMarkedPointsPossible() const
+{
+	return mpPathObj && isSelected() && (GetMarkedPointCount() != 0);
+}
+
+void IntelligentGroupFrame::RipUpAtMarkedPoints()
+{
+	// not supported for motion path
+}
+
+bool IntelligentGroupFrame::IsRipUpAtMarkedPointsPossible() const
+{
+	// not supported for motion path
+	return false;
+}
+
+BOOL IntelligentGroupFrame::IsSetMarkedSegmentsKindPossible() const
+{
+	if( mpPathObj )
+		return mrView.IsSetMarkedSegmentsKindPossible();
+	else
+		return FALSE;
+}
+
+SdrPathSegmentKind IntelligentGroupFrame::GetMarkedSegmentsKind() const
+{
+	if( mpPathObj )
+		return mrView.GetMarkedSegmentsKind();
+	else
+		return SDRPATHSEGMENT_LINE;
+}
+
+void IntelligentGroupFrame::SetMarkedSegmentsKind(SdrPathSegmentKind eKind)
+{
+	if(mpPathObj && isSelected() && (GetMarkedPointCount() != 0)) 
+	{
+		SdrUShortCont* pPts = mpMark->GetMarkedPoints();
+		if(pPts) 
+		{
+			PolyPolygonEditor aEditor( mpPathObj->GetPathPoly(), mpPathObj->IsClosed() );
+			if(aEditor.SetSegmentsKind( eKind, pPts->getContainer()) )
+			{
+				//				AddUndo(GetModel()->GetSdrUndoFactory().CreateUndoGeoObject(*pPath));
+				mpPathObj->SetPathPoly(aEditor.GetPolyPolygon());
+				mrView.MarkListHasChanged();
+				mrView.updateHandles();
+			}
+		}
+	}
+}
+
+BOOL IntelligentGroupFrame::IsSetMarkedPointsSmoothPossible() const
+{
+	if( mpPathObj )
+		return mrView.IsSetMarkedPointsSmoothPossible();
+	else
+		return FALSE;
+}
+
+SdrPathSmoothKind IntelligentGroupFrame::GetMarkedPointsSmooth() const
+{
+	if( mpPathObj )
+		return mrView.GetMarkedPointsSmooth();
+	else
+		return SDRPATHSMOOTH_ANGULAR;
+}
+
+void IntelligentGroupFrame::SetMarkedPointsSmooth(SdrPathSmoothKind eKind)
+{
+	basegfx::B2VectorContinuity eFlags;
+
+	if(SDRPATHSMOOTH_ANGULAR == eKind) 
+	{
+		eFlags = basegfx::CONTINUITY_NONE;
+	}
+	else if(SDRPATHSMOOTH_ASYMMETRIC == eKind) 
+	{
+		eFlags = basegfx::CONTINUITY_C1;
+	}
+	else if(SDRPATHSMOOTH_SYMMETRIC == eKind) 
+	{
+		eFlags = basegfx::CONTINUITY_C2;
+	}
+	else 
+	{
+		return;
+	}
+
+	if(mpPathObj && mpMark && isSelected() && (GetMarkedPointCount() != 0)) 
+	{
+		SdrUShortCont* pPts = mpMark->GetMarkedPoints();
+		if(pPts) 
+		{
+			PolyPolygonEditor aEditor( mpPathObj->GetPathPoly(), mpPathObj->IsClosed() );
+			if(aEditor.SetPointsSmooth( eFlags, pPts->getContainer() ) )
+			{
+				//				AddUndo(GetModel()->GetSdrUndoFactory().CreateUndoGeoObject(*pPath));
+				mpPathObj->SetPathPoly(aEditor.GetPolyPolygon());
+				mrView.MarkListHasChanged();
+				mrView.updateHandles();
+			}
+		}
+	}
+}
+
+void IntelligentGroupFrame::CloseMarkedObjects(BOOL /*bToggle*/, BOOL /*bOpen*/ )
+{
+	// not supported for motion path
+}
+
+bool IntelligentGroupFrame::IsOpenCloseMarkedObjectsPossible() const
+{
+	// not supported for motion path
+	return false;
+}
+
+SdrObjClosedKind IntelligentGroupFrame::GetMarkedObjectsClosedState() const
+{
+	// not supported for motion path
+	return SDROBJCLOSED_OPEN;
+}
+
+// XChangesListener
+void SAL_CALL IntelligentGroupFrame::changesOccurred( const ChangesEvent& /*Event*/ ) throw (RuntimeException)
+{
+	if( mpPathObj/* && !mbInUpdatePath && (mpEffect->getPath() != msLastPath)*/ )
+	{
+//		updatePathAttributes();
+		mrView.updateHandles();
+	}
+}
+
+void SAL_CALL IntelligentGroupFrame::disposing( const EventObject& /*Source*/ ) throw (RuntimeException)
+{
+	if( mpPathObj )
+		Dispose();
+}
+
+Any SAL_CALL IntelligentGroupFrame::queryInterface( const ::com::sun::star::uno::Type& aType ) throw (RuntimeException)
+{
+	if( aType == XChangesListener::static_type() )
+		return Any( Reference< XChangesListener >( this ) );
+	if( aType == XEventListener::static_type() )
+		return Any( Reference< XEventListener >( this ) );
+	if( aType == XInterface::static_type() )
+		return Any( Reference< XInterface >( this ) );
+
+	return Any();
+}
+
+void SAL_CALL IntelligentGroupFrame::acquire() throw ()
+{
+	SimpleReferenceComponent::acquire();
+}
+
+void SAL_CALL IntelligentGroupFrame::release(  ) throw ()
+{
+	SimpleReferenceComponent::release();
+}
+
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupLayoutBase.cxx sd/source/ui/ig/IntelligentGroupLayoutBase.cxx
new file mode 100644
index 0000000..386136d
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupLayoutBase.cxx
@@ -0,0 +1,202 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgrouplayoutbase.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupLayoutBase.hxx"
+
+using namespace ::com::sun::star;
+
+namespace sd{
+
+IntelligentGroupLayoutBase::IntelligentGroupLayoutBase(
+	boost::shared_ptr<IntelligentGroupModel> pModel,
+	boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+	:mpModel(pModel)
+	,mpLayoutDescriptor(pDescriptor)
+{
+}
+
+
+IntelligentGroupLayoutBase::~IntelligentGroupLayoutBase()
+{
+
+}
+
+
+boost::shared_ptr<IntelligentGroupLayoutDescriptor>IntelligentGroupLayoutBase::GetLayoutDescriptor()
+{
+	return mpLayoutDescriptor;
+}
+
+
+IntelligentGroupShapeDescriptor IntelligentGroupLayoutBase::GetShapeDescriptor(
+	const rtl::OUString sShapeIdentifier,
+	const ig::ShapeRole eRole,
+	const IntelligentGroupStyle aStyle)
+{
+	IntelligentGroupShapeDescriptor aShapeDescriptor;
+	aShapeDescriptor.Shape = mpModel->GetShape(sShapeIdentifier);
+	aShapeDescriptor.Identifier = sShapeIdentifier;
+	aShapeDescriptor.Role = eRole;
+	aShapeDescriptor.Style = aStyle;
+	aShapeDescriptor.Exists = aShapeDescriptor.Shape!=NULL;
+	if (aShapeDescriptor.Exists)
+	{
+		aShapeDescriptor.ShapeLocation = aShapeDescriptor.Shape->getPosition();
+		aShapeDescriptor.ShapeSize = aShapeDescriptor.Shape->getSize();
+	}
+	else
+	{
+		aShapeDescriptor.Shape = CreateShape(aShapeDescriptor.Identifier);
+//		mpModel->AddShape(aShapeDescriptor.Identifier, aShapeDescriptor.Role, aShapeDescriptor.Shape);
+	}
+
+	return aShapeDescriptor;
+}
+
+void IntelligentGroupLayoutBase::MoveShapeIntoGroupBoundingBox (
+	IntelligentGroupShapeDescriptor& aDescriptor,
+	awt::Rectangle aGroupBoundingBox)
+{
+	if ( ! aDescriptor.Exists)
+	{
+		// Shape has just been created and is at its default position.
+		return;
+	}
+
+	bool bLocationModified = false;
+	awt::Point aLocation(
+		aDescriptor.ShapeLocation.X,
+		aDescriptor.ShapeLocation.Y);
+	if (aLocation.Y < aGroupBoundingBox.Y)
+	{
+		aLocation.Y = aGroupBoundingBox.Y;
+		bLocationModified = true;
+	}
+	if (aLocation.Y+aDescriptor.ShapeSize.Height > aGroupBoundingBox.Y+aGroupBoundingBox.Height)
+	{
+		aLocation.Y = aGroupBoundingBox.Y+aGroupBoundingBox.Height-aDescriptor.ShapeSize.Height;
+		bLocationModified = true;
+	}
+	if (aLocation.X < aGroupBoundingBox.X)
+	{
+		aLocation.X = aGroupBoundingBox.X;
+		bLocationModified = true;
+	}
+	if (aLocation.X+aDescriptor.ShapeSize.Width > aGroupBoundingBox.X+aGroupBoundingBox.Width)
+	{
+		aLocation.X = aGroupBoundingBox.X+aGroupBoundingBox.Width-aDescriptor.ShapeSize.Width;
+		bLocationModified = true;
+	}
+
+	if (bLocationModified)
+	{
+		// Place the shape at the corrected location.  
+		aDescriptor.Shape->setPosition(aLocation);
+
+		if (aDescriptor.LocationTransformation.X != 0 && aDescriptor.LocationTransformation.Y != 0)
+		{
+			// Now that the location of the shape has been corrected,
+			// we have to figure out how the correction affects the
+			// location transformation (manual translation made by user).
+
+			// Calculate the corrections that have to be made to the current
+			// location in order to move the shape inside the bounding box of
+			// the group.
+			const int nDX = aLocation.X - aDescriptor.ShapeLocation.X;
+			const int nDY = aLocation.Y - aDescriptor.ShapeLocation.Y;
+
+			// If we change the location transformation at all then we reduce it.
+			// This is the case only when the current transformation and
+			// the correction have different signs.
+			if (aDescriptor.LocationTransformation.X * nDX < 0)
+			{
+				const sal_Int32 nNewFirst = aDescriptor.LocationTransformation.X + nDX;
+				// We must not overshoot.  When the correction is larger (in absolute value)
+				// then the location transformation then set the later to 0. 
+				if (nNewFirst * aDescriptor.LocationTransformation.X <= 0)
+					aDescriptor.LocationTransformation.X = 0;
+				else
+					aDescriptor.LocationTransformation.X = nNewFirst;
+			}
+
+			// Now do the same with the other coordinate.
+			if (aDescriptor.LocationTransformation.Y * nDY < 0)
+			{
+				const sal_Int32 nNewSecond = aDescriptor.LocationTransformation.Y + nDY;
+				// We must not overshoot.  When the correction is larger (in absolute value)
+				// then the location transformation then set the later to 0. 
+				if (nNewSecond * aDescriptor.LocationTransformation.Y <= 0)
+					aDescriptor.LocationTransformation.Y = 0;
+				else
+					aDescriptor.LocationTransformation.Y = nNewSecond;
+			}
+		}
+
+		// Remember the new location.
+		aDescriptor.ShapeLocation = aLocation;
+	}
+}
+
+void IntelligentGroupLayoutBase::SetSizeLocation (IntelligentGroupShapeDescriptor& aDescriptor)
+{
+	if ( ! aDescriptor.Exists)
+	{
+		aDescriptor.Shape->setPosition(aDescriptor.DefaultLocation);
+		aDescriptor.Shape->setSize(aDescriptor.DefaultSize);
+	}
+	else
+	{
+		awt::Point aLocation = aDescriptor.DefaultLocation;
+		if (aDescriptor.LocationTransformation.X != 0 && aDescriptor.LocationTransformation.Y != 0)
+		{
+			aLocation.X += aDescriptor.LocationTransformation.X;
+			aLocation.Y += aDescriptor.LocationTransformation.Y;
+		}
+		aDescriptor.Shape->setPosition(aLocation);
+		aDescriptor.Shape->setSize(aDescriptor.DefaultSize);
+		aDescriptor.ShapeLocation = aLocation;
+		aDescriptor.ShapeSize = aDescriptor.DefaultSize;
+	}
+}
+
+bool IntelligentGroupLayoutBase::IsGeometryModified(const IntelligentGroupShapeDescriptor& aDescriptor)
+{	return aDescriptor.Exists 
+		&& ((aDescriptor.SizeTransformation.Width!=0 && aDescriptor.SizeTransformation.Height!=0)|| 
+		(aDescriptor.LocationTransformation.X!=0 && aDescriptor.LocationTransformation.Y!=0));
+}
+
+void IntelligentGroupLayoutBase::AddShape(css::uno::Reference<css::drawing::XShape> /*rxShape*/)
+{
+
+}
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupLayoutManager.cxx sd/source/ui/ig/IntelligentGroupLayoutManager.cxx
new file mode 100644
index 0000000..1984a2a
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupLayoutManager.cxx
@@ -0,0 +1,180 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgrouplayoutmanager.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupLayoutManager.hxx"
+#include "GroupedListLayout.hxx"
+#include "HorizontalListLayoutAlgorithm.hxx"
+//#include "VerticalListLayoutAlgorithm.hxx"
+#include "PictureAccentListLayout.hxx"
+#include "TreeLayout.hxx"
+#include "TreeLayoutAlgorithm.hxx"
+#include "RowFieldLayoutAlgorithm.hxx"
+#include "CircleLayoutAlgorithm.hxx"
+
+namespace sd{
+
+boost::shared_ptr<IntelligentGroupLayoutManager> IntelligentGroupLayoutManager::mpInstance;
+
+const ::rtl::OUString IntelligentGroupLayoutManager::msGroupedListLayout(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedListLayout")));
+const ::rtl::OUString IntelligentGroupLayoutManager::msPictureAccentListLayout(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PictureAccentListLayout")));
+const ::rtl::OUString IntelligentGroupLayoutManager::msTreeLayout(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("TreeLayout")));
+
+const ::rtl::OUString IntelligentGroupLayoutManager::msCircleLayoutAlgorithm(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("CircleLayoutAlgorithm")));
+const ::rtl::OUString IntelligentGroupLayoutManager::msHorizontalListLayoutAlgorithm(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("HorizontalListLayoutAlgorithm")));
+const ::rtl::OUString IntelligentGroupLayoutManager::msRowFieldLayoutAlgorithm(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("RowFieldLayoutAlgorithm")));
+const ::rtl::OUString IntelligentGroupLayoutManager::msTreeLayoutAlgorithm(
+	rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("TreeLayoutAlgorithm")));
+
+IntelligentGroupLayoutManager::IntelligentGroupLayoutManager()
+{
+	// This initialization would best be done via the configuration.
+	AddLayout(GroupedListDescriptor::Get());
+	AddLayout(CircleLayoutDescriptor::Get());
+	AddLayout(TreeDescriptor::Get());
+	AddLayout(PictureAccentListDescriptor::Get());
+	AddLayout(SimpleFieldDescriptor::Get());
+}
+
+boost::shared_ptr<IntelligentGroupLayoutManager> IntelligentGroupLayoutManager::Instance()
+{
+	if(mpInstance.get() == NULL)
+		mpInstance.reset(new IntelligentGroupLayoutManager());
+	return mpInstance;
+}
+
+boost::shared_ptr<IntelligentGroupLayoutDescriptor> IntelligentGroupLayoutManager::GetLayoutDescriptor(const rtl::OUString& sLayoutName)
+{
+	LayoutDescriptors::iterator aIter = maLayoutDescriptors.find(sLayoutName);
+	OSL_ASSERT (aIter != maLayoutDescriptors.end());
+	return aIter->second;
+}
+
+boost::shared_ptr<IntelligentGroupLayoutBase> IntelligentGroupLayoutManager::GetLayout(const rtl::OUString& sLayoutName,boost::shared_ptr<IntelligentGroupModel> pModel)
+{
+	return CreateLayout(pModel,sLayoutName);
+}
+
+boost::shared_ptr<IntelligentGroupLayouter> IntelligentGroupLayoutManager::GetLayouter(
+	boost::shared_ptr<IntelligentGroupModel> pModel, 
+	boost::shared_ptr<IntelligentGroupLayoutBase> pLayout)
+{
+	boost::shared_ptr<IntelligentGroupAlgorithmBase> pAlgorithm = CreateLayoutAlgorithm(pLayout->GetLayoutDescriptor());
+	if(pAlgorithm.get() != NULL)
+		return boost::shared_ptr<IntelligentGroupLayouter> (
+			new IntelligentGroupLayouter(
+				pModel,
+				pLayout,
+				pAlgorithm));
+	else 
+		return boost::shared_ptr<IntelligentGroupLayouter>();
+}
+
+void IntelligentGroupLayoutManager::AddLayout(boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+{
+	rtl::OUString sCategory = pDescriptor->Category;
+	rtl::OUString sLayout = pDescriptor->Name;
+	Categories::iterator aIter = maCategories.find(sCategory);
+	std::vector<rtl::OUString> aLayoutsOfCategory;
+	if(aIter != maCategories.end())
+		aLayoutsOfCategory = aIter->second;
+	if (aLayoutsOfCategory.empty())
+	{
+		maCategories.insert(Categories::value_type(sCategory, aLayoutsOfCategory));
+	}
+	aLayoutsOfCategory.push_back(sLayout);
+	maLayoutDescriptors.insert(LayoutDescriptors::value_type(sLayout, pDescriptor));
+//	std::pair<LayoutDescriptors::iterator,bool> pr;
+//	pr = maLayoutDescriptors.insert(LayoutDescriptors::value_type(sLayout, aDescriptor));
+//	bool aValue = pr.second;
+}
+
+boost::shared_ptr<IntelligentGroupLayoutBase> IntelligentGroupLayoutManager::CreateLayout(boost::shared_ptr<IntelligentGroupModel> pModel, const rtl::OUString& sLayoutName)
+{
+	boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor = GetLayoutDescriptor(sLayoutName);
+	if(pLayoutDescriptor.get() != NULL)
+		return CreateLayout(pModel, pLayoutDescriptor);
+	else 
+		return boost::shared_ptr<IntelligentGroupLayoutBase>();
+}
+
+boost::shared_ptr<IntelligentGroupLayoutBase> IntelligentGroupLayoutManager::CreateLayout(boost::shared_ptr<IntelligentGroupModel> pModel, boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+{
+	rtl::OUString aLayoutName = pDescriptor->LayoutServiceName;
+	boost::shared_ptr<IntelligentGroupLayoutBase> pLayout;
+	if(aLayoutName == IntelligentGroupLayoutManager::msGroupedListLayout)
+	{
+		pLayout.reset((IntelligentGroupLayoutBase*)new GroupedListLayout(pModel,pDescriptor));
+	}
+	else if(aLayoutName == IntelligentGroupLayoutManager::msPictureAccentListLayout)
+	{
+		pLayout.reset((IntelligentGroupLayoutBase*)new PictureAccentListLayout(pModel,pDescriptor));
+	}
+	else if(aLayoutName == IntelligentGroupLayoutManager::msTreeLayout)
+	{
+		pLayout.reset((IntelligentGroupLayoutBase*)new TreeLayout(pModel,pDescriptor));
+	}
+		
+	return pLayout;
+}
+
+boost::shared_ptr<IntelligentGroupAlgorithmBase> IntelligentGroupLayoutManager::CreateLayoutAlgorithm(boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+{
+	rtl::OUString aClassName = pDescriptor->LayoutAlgorithmServiceName;
+	boost::shared_ptr<IntelligentGroupAlgorithmBase> pAlgorithm;
+	if(aClassName == IntelligentGroupLayoutManager::msHorizontalListLayoutAlgorithm)
+	{
+		pAlgorithm.reset((IntelligentGroupAlgorithmBase*)new HorizontalListLayoutAlgorithm());
+	}
+	else if(aClassName == IntelligentGroupLayoutManager::msTreeLayoutAlgorithm)
+	{
+		pAlgorithm.reset((IntelligentGroupAlgorithmBase*)new TreeLayoutAlgorithm());
+	}
+	else if(aClassName == IntelligentGroupLayoutManager::msRowFieldLayoutAlgorithm)
+	{
+		pAlgorithm.reset((IntelligentGroupAlgorithmBase*)new RowFieldLayoutAlgorithm());
+	}
+	else if(aClassName == IntelligentGroupLayoutManager::msCircleLayoutAlgorithm)
+	{
+		pAlgorithm.reset((IntelligentGroupAlgorithmBase*)new CircleLayoutAlgorithm());
+	}
+	
+	return pAlgorithm;
+}
+
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupLayouter.cxx sd/source/ui/ig/IntelligentGroupLayouter.cxx
new file mode 100644
index 0000000..3b965d9
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupLayouter.cxx
@@ -0,0 +1,259 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgrouplayouter.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupLayouter.hxx"
+
+using namespace ::com::sun::star;
+
+
+namespace sd{
+
+IntelligentGroupLayouter::IntelligentGroupLayouter(
+	boost::shared_ptr<IntelligentGroupModel> pModel,
+	boost::shared_ptr<IntelligentGroupLayoutBase> pLayout,
+	boost::shared_ptr<IntelligentGroupAlgorithmBase> pAlgorithm)
+	: mpModel(pModel)
+	, mpLayout(pLayout)
+	, mpAlgorithm(pAlgorithm)
+{
+
+}
+
+IntelligentGroupLayouter::~IntelligentGroupLayouter()
+{
+
+}
+
+
+void IntelligentGroupLayouter::DoLayout(boost::shared_ptr<IntelligentGroupText> pText)
+{
+	if(mpModel->GetShapeDescriptors().empty())
+	{
+//		maShapeDescriptors = PrepareShapes(pText->CreateIterator());
+		PrepareShapes(pText->CreateIterator());
+	}
+
+	// Get bounding box of the group shape.
+	awt::Rectangle aGroupBoundingBox(
+		mpModel->GetLocation().X,
+		mpModel->GetLocation().Y,
+		mpModel->GetSize().Width,
+		mpModel->GetSize().Height);
+//	mpAlgorithm->PlaceShape(mpLayout, maShapeDescriptors, aGroupBoundingBox);
+	mpAlgorithm->PlaceShape(mpLayout, mpModel, aGroupBoundingBox);
+//	UpdateText(pText);
+}
+
+
+//std::vector<std::vector<IntelligentGroupShapeDescriptor> > IntelligentGroupLayouter::PrepareShapes(
+void IntelligentGroupLayouter::PrepareShapes(
+	boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator)
+{	 
+	mpTextIterator = pTextIterator;
+	sal_Int32 nGroupCount = pTextIterator->GetItemCount();
+//	std::vector<std::vector<IntelligentGroupShapeDescriptor> > aShapeDescriptors;
+
+	for (int nIndex=0; nIndex<nGroupCount; ++nIndex)
+	{
+//		std::vector<IntelligentGroupShapeDescriptor> aShapeDescriptor = mpLayout->PrepareShapes(
+		mpLayout->PrepareShapes(
+			pTextIterator,
+			nIndex);
+//		aShapeDescriptors.push_back(aShapeDescriptor);
+		pTextIterator->GotoNext();
+	}
+
+	// Find all shapes in the model that have not been requested
+	// in the recent prepareShapes() calls.
+
+	// Create a flat list with the identifiers of the requested shapes.
+	std::vector<rtl::OUString> aRequestedShapes;
+//	std::vector<std::vector<IntelligentGroupShapeDescriptor> >::const_iterator aIter = aShapeDescriptors.begin();
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> >::const_iterator aIter = mpModel->GetShapeDescriptors().begin();
+//	for (; aIter != aShapeDescriptors.end(); ++aIter)
+	for (; aIter != mpModel->GetShapeDescriptors().end(); ++aIter)
+		for(std::vector<IntelligentGroupShapeDescriptor>::const_iterator aIterator = (*aIter).begin();
+			aIterator != (*aIter).end(); ++aIterator)
+			aRequestedShapes.push_back((*aIterator).Identifier);
+
+//	return aShapeDescriptors;
+}
+
+
+void IntelligentGroupLayouter::AddShape(const IntelligentGroupShapeDescriptor& rShapeDescriptor)
+{
+	if(ig::Primary == rShapeDescriptor.Role)
+	{
+		sal_Int32 nGroupIndex = mpModel->GetShapeGroupIndex(rShapeDescriptor.Shape);
+		std::vector<IntelligentGroupShapeDescriptor> aDescriptorVector = mpLayout->PrepareShapes(
+			mpTextIterator,
+			nGroupIndex+1,
+			true);
+	
+		mpModel->AddShapeGroup(aDescriptorVector, nGroupIndex+1);
+	}
+	else if(ig::Accent == rShapeDescriptor.Role)
+	{
+		mpLayout->AddShape(rShapeDescriptor.Shape);
+	}
+}
+
+
+/*
+void IntelligentGroupLayouter::UpdateText(::boost::shared_ptr<IntelligentGroupText> pText)
+{
+	boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator = pText->CreateIterator();
+	boost::shared_ptr<IntelligentGroupShapeAccessor> pShapeAccessor = mpLayout->GetShapeAccessor(maShapeDescriptors);
+	boost::shared_ptr<IntelligentGroupShapeIterator> pShapeIterator(new IntelligentGroupShapeDescriptor(pShapeAccessor.get()));
+
+	if (pTextIterator->Rewind() && pShapeIterator->Rewind() )
+	{
+		while (true)
+		{
+			if ( pShapeIterator->IsOutliner() )
+			{
+				if (pShapeIterator->GetItemCount() > 1)
+				{
+					// When there is more than one shape on this level then
+					// each will display on text item on the current level of the text iterator
+					// and all its children.
+					do 
+					{
+						UpdateOutlineText(
+							pShapeIterator->GetShape(),
+							boost::shared_ptr<IntelligentGroupFlatSubTextIterator> (
+							new IntelligentGroupFlatSubTextIterator(pTextIterator.get(), true)),
+							-pTextIterator->GetLevel() );
+					} 
+					while( pTextIterator->GotoNext() && aShapeIterator.GotoNext() );
+				}
+				else
+				{
+					// When there is only one shape then this will display all text
+					// on the current level and the levels below of the text iterator.
+
+					UpdateOutlineText(
+						pShapeIterator->GetShape(),
+						boost::shared_ptr<IntelligentGroupFlatSubTextIterator> (
+						new IntelligentGroupFlatSubTextIterator(pTextIterator.get(), false)),
+						-pTextIterator->GetLevel() );
+				}
+			}
+			else
+			{
+				// The current shape does not have outline text. Therefore it just
+				// displays the current text.
+				UpdateText( pShapeIterator->GetShape(), pTextIterator->GetText() );
+			}
+
+			// Depth first traversal.
+			if ( !pShapeIterator->IsOutliner() && pShapeIterator->GotoFirstChild()
+				&& pTextIterator->GotoFirstChild() )
+				continue;
+
+			// Goto next sibling when there are no children.
+			if (pTextIterator->GotoNext() && pShapeIterator->GotoNext() )
+				continue;
+
+			// Go to next element on one of the upper levels.
+			bool bLoop = false;
+			while ( pTextIterator->GotoParent() && pShapeIterator->GotoParent() )
+			{
+				if ( pTextIterator->GotoNext() && pShapeIterator->GotoNext() )
+				{
+					bLoop = true;
+					break;
+				}
+			}
+			if (!bLoop)
+				break;
+		}
+	}
+}
+
+
+
+void IntelligentGroupLayouter::UpdateOutlineText(const uno::Reference<drawing::XShape> xShape,
+												 boost::shared_ptr<IntelligentGroupFlatTextIterator> pTextIterator,
+												 const sal_Int32 nIndentationOffset)
+{
+	uno::Reference<text::XTextRange> xShapeText (xShape, uno::UNO_QUERY_THROW);
+	if (!xShapeText.is())
+		return;
+
+	// Clear old content.
+	xShapeText->setString( ::rtl::OUString::createFromAscii("") );
+
+	bool bFirst = true;
+	do
+	{
+		// Insert a new line before any but the first line.
+		if (bFirst)
+			bFirst = false;
+		else
+			xShapeText->setString( ::rtl::OUString::createFromAscii("\n") );
+
+		// Append next line and set the right indentation level.
+		xShapeText = xShapeText->getEnd();
+		uno::Reference<beans::XPropertySet> xProperties (xShapeText, uno::UNO_QUERY_THROW);
+		try
+		{
+			sal_Int32 nCharHeight = 20;
+			sal_Int32 nNumberingLevel = pTextIterator->GetLevel()+nIndentationOffset;
+			xProperties->setPropertyValue( ::rtl::OUString::createFromAscii("CharHeight"), uno::makeAny(nCharHeight) );
+			xProperties->setPropertyValue( ::rtl::OUString::createFromAscii("NumberingLevel"), uno::makeAny(nNumberingLevel) );
+		}
+		catch (uno::Exception&)
+		{
+			DBG_ERROR("IntelligentGroupLayouter::UpdateOutlineText(), exception caught!");
+		}
+		::rtl::OUString sText = pTextIterator->GetText();
+		xShapeText->setString(sText);
+		xShapeText = xShapeText->getEnd();
+	}
+	while (pTextIterator->GotoNext());
+}
+
+
+
+
+void IntelligentGroupLayouter::UpdateText(
+	const uno::Reference<drawing::XShape> xShape,
+	const ::rtl::OUString sText)
+{
+	uno::Reference<text::XTextRange> xShapeText (xShape, uno::UNO_QUERY_THROW);
+	if (xShapeText.is())
+		xShapeText->setString(sText);
+}
+*/
+
+}// end of namespace sd
diff --git sd/source/ui/ig/IntelligentGroupModel.cxx sd/source/ui/ig/IntelligentGroupModel.cxx
new file mode 100644
index 0000000..499bcc9
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupModel.cxx
@@ -0,0 +1,589 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgroupmodel.cxx,v $
+ * $Revision: 1.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+
+#include "IntelligentGroupModel.hxx"
+#include <com/sun/star/drawing/XShapeGroup.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+
+using namespace ::com::sun::star;
+
+namespace sd{
+
+IntelligentGroupModel::IntelligentGroupModel(
+	uno::Reference<frame::XModel> xModel,
+	awt::Rectangle aBoundingBox)
+	:mxModel(xModel)
+{
+	maSize = awt::Size(aBoundingBox.Width, aBoundingBox.Height);
+	maLocation = awt::Point(aBoundingBox.X, aBoundingBox.Y);
+
+	SetupShapeList();
+}
+
+IntelligentGroupModel::~IntelligentGroupModel()
+{
+	maContentShapeMap.clear();
+	maDisposedShapes.clear();
+	maContentShapeGroups.clear();
+	maDisposedShapeMap.clear();
+}
+
+uno::Reference<drawing::XShapes> IntelligentGroupModel::GetGroupShape(void)
+{
+	return mxGroup;
+}
+/*
+void IntelligentGroupModel::AddShape(
+			rtl::OUString rIdentifier,
+			ig::ShapeRole rRole,
+			uno::Reference<drawing::XShape> xShape)
+{
+	IntelligentGroupShapeDescriptor aDescriptor;
+	aDescriptor.Identifier = rIdentifier;
+	aDescriptor.Role = rRole;
+	aDescriptor.Shape = xShape;
+
+	maContentShapeMap.insert(DescriptorInfo::value_type(rIdentifier, aDescriptor));
+	maContentShapeVector.push_back(aDescriptor);
+
+	uno::Reference< beans::XPropertySet > xProperties(mxModel->getCurrentController(),uno::UNO_QUERY);
+	uno::Reference< drawing::XDrawPage > xPage (xProperties->getPropertyValue(
+		rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage"))),
+		uno::UNO_QUERY);
+	xPage->add(xShape);
+	// Add shape to underlying group shape.
+//	mxGroup->add(xShape);
+}
+*/
+
+void IntelligentGroupModel::AddShapeGroup(const std::vector<IntelligentGroupShapeDescriptor>& aShapeDescriptorVector, sal_Int32 nIndex)
+{
+	maContentShapeGroups.insert(maContentShapeGroups.begin()+nIndex,aShapeDescriptorVector);
+	uno::Reference< beans::XPropertySet > xProperties(mxModel->getCurrentController(),uno::UNO_QUERY);
+	uno::Reference< drawing::XDrawPage > xPage (xProperties->getPropertyValue(
+		rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage"))),
+		uno::UNO_QUERY);
+	for(std::vector<IntelligentGroupShapeDescriptor>::const_iterator aIter = aShapeDescriptorVector.begin(); aIter!=aShapeDescriptorVector.end(); aIter++)
+	{
+		xPage->add(aIter->Shape);
+	}
+}
+
+sal_Int32 IntelligentGroupModel::GetShapeGroupIndex(uno::Reference< drawing::XShape > rxShape)
+{
+	sal_Int32 nIndex = 0;
+	bool bFound = false;
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> >::iterator aOuterIter = maContentShapeGroups.begin();
+	for(; aOuterIter!=maContentShapeGroups.end(); aOuterIter++)
+	{
+		std::vector<IntelligentGroupShapeDescriptor>::iterator aInnerIter = aOuterIter->begin();
+		for(; aInnerIter!=aOuterIter->end(); aInnerIter++)
+			if(aInnerIter->Shape == rxShape)
+			{
+				bFound = true;
+				break;
+			}
+
+		if(bFound)
+			break;
+
+		nIndex++;
+	}
+
+	return nIndex;
+}
+
+
+
+
+std::vector<IntelligentGroupShapeDescriptor> IntelligentGroupModel::GetShapeDescriptorVector(sal_Int32 nIndex)
+{
+	return maContentShapeGroups[nIndex];
+}
+
+
+sal_Int32 IntelligentGroupModel::GetShapeDescriptorIndex(sal_Int32 nShapeGroupIndex, sal_Int32 nInnerIndex)
+{
+	sal_Int32 nCount = 0;
+	for(sal_Int32 nGroupIndex = 0; nGroupIndex < nShapeGroupIndex; nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+	}
+
+	return nCount+nInnerIndex;
+}
+
+
+void IntelligentGroupModel::SetSizeLocation(sal_Int32 nShapeDescriptorIndex, IntelligentGroupShapeDescriptor aShapeDescriptor)
+{
+	sal_Int32 nCount = 0;
+	for(sal_uInt32 nGroupIndex = 0; nGroupIndex < maContentShapeGroups.size(); nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+		if(nCount>nShapeDescriptorIndex)
+		{
+			sal_Int32 nRelativeIndex = nShapeDescriptorIndex-nCount+maContentShapeGroups[nGroupIndex].size();
+
+			if ( ! maContentShapeGroups[nGroupIndex][nRelativeIndex].Exists)
+			{
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].Shape->setPosition(aShapeDescriptor.DefaultLocation);
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].Shape->setSize(aShapeDescriptor.DefaultSize);
+			}
+			else
+			{
+				awt::Point aLocation = maContentShapeGroups[nGroupIndex][nRelativeIndex].DefaultLocation;
+				if (maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X != 0 
+					&& maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y != 0)
+				{
+					aLocation.X += maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X;
+					aLocation.Y += maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y;
+				}
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].Shape->setPosition(aLocation);
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].Shape->setSize(maContentShapeGroups[nGroupIndex][nRelativeIndex].DefaultSize);
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeLocation = aLocation;
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeSize = aShapeDescriptor.DefaultSize;
+			}
+			break;
+		}
+	}
+}
+
+
+
+
+sal_Int32 IntelligentGroupModel::GetGroupShapeCount(sal_Int32 nShapeGroupIndex)
+{
+	return maContentShapeGroups[nShapeGroupIndex].size();
+
+}
+
+
+
+
+void IntelligentGroupModel::MoveShapeIntoGroupBoundingBox(sal_Int32 nShapeIndex,::com::sun::star::awt::Rectangle aGroupBoundingBox)
+{
+	sal_Int32 nCount = 0;
+	for(sal_uInt32 nGroupIndex = 0; nGroupIndex<maContentShapeGroups.size(); nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+		if(nCount>nShapeIndex)
+		{
+			sal_Int32 nRelativeIndex = nShapeIndex-nCount+maContentShapeGroups[nGroupIndex].size();
+
+			if ( ! maContentShapeGroups[nGroupIndex][nRelativeIndex].Exists)
+			{
+				// Shape has just been created and is at its default position.
+				return;
+			}
+
+			bool bLocationModified = false;
+			awt::Point aLocation(
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeLocation.X,
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeLocation.Y);
+			if (aLocation.Y < aGroupBoundingBox.Y)
+			{
+				aLocation.Y = aGroupBoundingBox.Y;
+				bLocationModified = true;
+			}
+			if (aLocation.Y+maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeSize.Height > aGroupBoundingBox.Y+aGroupBoundingBox.Height)
+			{
+				aLocation.Y = aGroupBoundingBox.Y+aGroupBoundingBox.Height-maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeSize.Height;
+				bLocationModified = true;
+			}
+			if (aLocation.X < aGroupBoundingBox.X)
+			{
+				aLocation.X = aGroupBoundingBox.X;
+				bLocationModified = true;
+			}
+			if (aLocation.X+maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeSize.Width > aGroupBoundingBox.X+aGroupBoundingBox.Width)
+			{
+				aLocation.X = aGroupBoundingBox.X+aGroupBoundingBox.Width-maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeSize.Width;
+				bLocationModified = true;
+			}
+
+			if (bLocationModified)
+			{
+				// Place the shape at the corrected location.  
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].Shape->setPosition(aLocation);
+
+				if (maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X != 0 && maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y != 0)
+				{
+					// Now that the location of the shape has been corrected,
+					// we have to figure out how the correction affects the
+					// location transformation (manual translation made by user).
+
+					// Calculate the corrections that have to be made to the current
+					// location in order to move the shape inside the bounding box of
+					// the group.
+					const int nDX = aLocation.X - maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeLocation.X;
+					const int nDY = aLocation.Y - maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeLocation.Y;
+
+					// If we change the location transformation at all then we reduce it.
+					// This is the case only when the current transformation and
+					// the correction have different signs.
+					if (maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X * nDX < 0)
+					{
+						const sal_Int32 nNewFirst = maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X + nDX;
+						// We must not overshoot.  When the correction is larger (in absolute value)
+						// then the location transformation then set the later to 0. 
+						if (nNewFirst * maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X <= 0)
+							maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X = 0;
+						else
+							maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.X = nNewFirst;
+					}
+
+					// Now do the same with the other coordinate.
+					if (maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y * nDY < 0)
+					{
+						const sal_Int32 nNewSecond = maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y + nDY;
+						// We must not overshoot.  When the correction is larger (in absolute value)
+						// then the location transformation then set the later to 0. 
+						if (nNewSecond * maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y <= 0)
+							maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y = 0;
+						else
+							maContentShapeGroups[nGroupIndex][nRelativeIndex].LocationTransformation.Y = nNewSecond;
+					}
+				}
+
+				// Remember the new location.
+				maContentShapeGroups[nGroupIndex][nRelativeIndex].ShapeLocation = aLocation;
+			}
+
+			break;
+		}
+	}
+}
+
+
+
+void IntelligentGroupModel::AddShapeDescriptor(sal_Int32 nIndex, IntelligentGroupShapeDescriptor aShapeDescriptor)
+{
+	sal_Int32 nCount = 0;
+	for(sal_uInt32 nGroupIndex = 0; nGroupIndex<maContentShapeGroups.size(); nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+		if(nCount>nIndex-1)
+		{
+			sal_Int32 nRelativeIndex = nIndex-nCount+maContentShapeGroups[nGroupIndex].size();
+			std::vector<IntelligentGroupShapeDescriptor>::iterator aIter = maContentShapeGroups[nGroupIndex].begin();
+			maContentShapeGroups[nGroupIndex].insert(aIter+nRelativeIndex, aShapeDescriptor);
+			uno::Reference< beans::XPropertySet > xProperties(mxModel->getCurrentController(),uno::UNO_QUERY);
+			uno::Reference< drawing::XDrawPage > xPage (xProperties->getPropertyValue(
+				rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage"))),
+				uno::UNO_QUERY);
+			xPage->add(aShapeDescriptor.Shape);
+			break;
+		}
+	}
+}
+
+
+
+
+sal_Int32 IntelligentGroupModel::GetShapeGroupCount()
+{
+	return maContentShapeGroups.size();
+}
+
+
+
+sal_Int32 IntelligentGroupModel::GetShapeIndex(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxShape)
+{
+	sal_Int32 nGroupIndex = GetShapeGroupIndex(rxShape);
+	sal_Int32 nCount = 0;
+	for(sal_Int32 nIndex = 0; nIndex<nGroupIndex; nIndex++)
+	{
+		nCount += GetGroupShapeCount(nIndex);
+	}
+	for(std::vector<IntelligentGroupShapeDescriptor>::iterator aIter=maContentShapeGroups[nGroupIndex].begin();
+		aIter!=maContentShapeGroups[nGroupIndex].end();
+		aIter++)
+	{
+		if(aIter->Shape == rxShape)
+			break;
+		nCount++;
+	}
+	return nCount;
+}
+
+
+
+std::vector<std::vector<IntelligentGroupShapeDescriptor> >& IntelligentGroupModel::GetShapeDescriptors()
+{
+	return maContentShapeGroups;
+}
+
+/*
+void IntelligentGroupModel::RemoveShape(rtl::OUString rIdentifier)
+{
+	maContentShapeMap.erase(rIdentifier);
+
+	IntelligentGroupShapeDescriptor aDescriptor = maContentShapeMap[rIdentifier];
+	std::vector<IntelligentGroupShapeDescriptor>::iterator aIter = maContentShapeVector.begin();
+	while(aIter != maContentShapeVector.end())
+	{
+		if((*aIter).Identifier == rIdentifier)
+		{
+			maContentShapeVector.erase(aIter);
+
+			uno::Reference<beans::XPropertySet> xProperties(mxModel->getCurrentController(),uno::UNO_QUERY);
+			uno::Reference< drawing::XDrawPage > xPage (xProperties->getPropertyValue(
+				rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage"))),
+				uno::UNO_QUERY);
+			xPage->remove( (*aIter).Shape );
+			break;
+		}
+		aIter++;
+	}
+
+//	mxGroup->remove(aDescriptor.Shape);
+}
+*/
+
+
+void IntelligentGroupModel::RemoveShape(uno::Reference<drawing::XShape> rxShape)
+{
+	bool bRemoved = false;
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> >::iterator aOuterIter = maContentShapeGroups.begin();
+	for(; aOuterIter!=maContentShapeGroups.end(); aOuterIter++)
+	{
+		for(std::vector<IntelligentGroupShapeDescriptor>::iterator aInnerIter = aOuterIter->begin(); aInnerIter != aOuterIter->end(); aInnerIter++)
+			if(rxShape == aInnerIter->Shape)
+			{
+				maDisposedShapes.push_back(*aInnerIter);
+				maDisposedShapeMap.insert(IndexInfo::value_type(aInnerIter->Identifier,GetShapeIndex(rxShape)));
+				aOuterIter->erase(aInnerIter);
+
+				if(aOuterIter->empty())
+					maContentShapeGroups.erase(aOuterIter);
+
+/*				uno::Reference<beans::XPropertySet> xProperties(mxModel->getCurrentController(),uno::UNO_QUERY);
+				uno::Reference< drawing::XDrawPage > xPage (xProperties->getPropertyValue(
+					rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage"))),
+					uno::UNO_QUERY);
+				xPage->remove( (*aInnerIter).Shape );
+*/				bRemoved = true;
+				break;
+			}
+		if(bRemoved)
+			break;
+	}
+}
+
+
+uno::Reference<drawing::XShape> IntelligentGroupModel::GetShape( rtl::OUString rIdentifier)
+{
+	IntelligentGroupShapeDescriptor aDescriptor = maContentShapeMap[rIdentifier];
+	if (aDescriptor.Shape.is())
+		return aDescriptor.Shape;
+	else
+		return NULL;
+}
+
+uno::Reference<drawing::XShape> IntelligentGroupModel::GetShape(sal_Int32 nIndex)
+{
+	sal_Int32 nCount = 0;
+	for(sal_uInt32 nGroupIndex = 0; nGroupIndex < maContentShapeGroups.size(); nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+		if(nCount>nIndex)
+		{
+			sal_Int32 nRelativeIndex = nIndex-nCount+maContentShapeGroups[nGroupIndex].size();
+			return maContentShapeGroups[nGroupIndex][nRelativeIndex].Shape;
+		}
+	}
+}
+
+rtl::OUString IntelligentGroupModel::GetShapeIdentifier (sal_Int32 nIndex)
+{
+	sal_Int32 nCount = 0;
+	for(sal_uInt32 nGroupIndex = 0; nGroupIndex < maContentShapeGroups.size(); nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+		if(nCount>nIndex)
+		{
+			sal_Int32 nRelativeIndex = nIndex-nCount+maContentShapeGroups[nGroupIndex].size();
+			return maContentShapeGroups[nGroupIndex][nRelativeIndex].Identifier;
+		}
+	}
+	return rtl::OUString();
+}
+
+sal_Int32 IntelligentGroupModel::GetShapeCount(void)
+{
+//	return maContentShapeVector.size();
+	sal_Int32 nCount = 0;
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> >::iterator aOuterIter = maContentShapeGroups.begin();
+	for(; aOuterIter!=maContentShapeGroups.end(); aOuterIter++)
+	{
+		nCount += aOuterIter->size();
+	}
+	return nCount;
+}
+
+
+void IntelligentGroupModel::SetupShapeList(void)
+{
+	maContentShapeMap.clear();
+//	maContentShapeVector.clear();
+	maContentShapeGroups.clear();
+}
+
+void IntelligentGroupModel::SetSize(awt::Size rSize)
+{
+	maSize = rSize;
+}
+
+
+awt::Size IntelligentGroupModel::GetSize(void)
+{
+	return maSize;
+}
+
+void IntelligentGroupModel::SetLocation(awt::Point rPoint)
+{
+	maLocation = rPoint;
+}
+
+awt::Point  IntelligentGroupModel::GetLocation(void)
+{
+	return maLocation;
+}
+
+uno::Reference<lang::XMultiServiceFactory> IntelligentGroupModel::GetShapeFactory(void)
+{
+	return uno::Reference<lang::XMultiServiceFactory>( mxModel, uno::UNO_QUERY);
+}
+
+void IntelligentGroupModel::UpdateSizeAndLocation(void)
+{
+	const uno::Reference<drawing::XShapeGroup> xGroup(mxGroup,uno::UNO_QUERY);
+	maSize = awt::Size(xGroup->getSize().Width, xGroup->getSize().Height);
+	maLocation = awt::Point(xGroup->getPosition().X, xGroup->getPosition().Y);
+}
+/*
+void IntelligentGroupModel::RemoveUnusedShapes (rtl::OUString rUsedShapes[])
+{
+	std::vector<rtl::OUString> aShapesToBeDeleted;
+	std::vector<IntelligentGroupShapeDescriptor>::iterator iter=maContentShapeVector.begin();
+	for (;iter!=maContentShapeVector.end();++iter)
+	{
+		bool bFound = false;
+		for (int i=0;rUsedShapes[i]!=NULL;i++)
+			if ((*iter).Identifier.equals(rUsedShapes[i]))
+			{
+				bFound = true;
+				break;
+			}
+		if ( ! bFound)
+			aShapesToBeDeleted.push_back((*iter).Identifier);
+	}
+
+	std::vector<rtl::OUString>::iterator aIter=aShapesToBeDeleted.begin();
+	for (;aIter!=aShapesToBeDeleted.end();++aIter)
+	{
+		RemoveShape(*aIter);
+	}
+}
+*/
+uno::Reference<frame::XModel> IntelligentGroupModel::GetUnoModel()
+{
+	return mxModel;
+}
+
+bool IntelligentGroupModel::IsInModel( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape )
+{
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> >::iterator aIter = maContentShapeGroups.begin();
+	for ( ; aIter != maContentShapeGroups.end(); aIter++ )
+	{
+		for(std::vector<IntelligentGroupShapeDescriptor>::iterator aInnerIter = aIter->begin(); aInnerIter!=aIter->end(); aInnerIter++)
+			if ( (*aInnerIter).Shape == xShape )
+				return true;
+	}
+
+	return false;
+}
+
+
+IntelligentGroupShapeDescriptor IntelligentGroupModel::GetShapeDescriptor(sal_Int32 nIndex)
+{
+	sal_Int32 nCount = 0;
+	for(sal_uInt32 nGroupIndex = 0; nGroupIndex < maContentShapeGroups.size(); nGroupIndex++)
+	{
+		nCount += maContentShapeGroups[nGroupIndex].size();
+		if(nCount>nIndex)
+		{
+			sal_Int32 nRelativeIndex = nIndex-nCount+maContentShapeGroups[nGroupIndex].size();
+			return maContentShapeGroups[nGroupIndex][nRelativeIndex];
+		}
+	}
+
+	return IntelligentGroupShapeDescriptor();
+}
+
+
+
+bool IntelligentGroupModel::RequestUndo()
+{
+	uno::Reference<beans::XPropertySet> xProperties(mxModel->getCurrentController(),uno::UNO_QUERY);
+	sal_Int32 nShapeCount = 0;
+	if (xProperties.is())
+	{
+		uno::Reference<container::XIndexAccess> xPage (
+			xProperties->getPropertyValue(rtl::OUString::createFromAscii("CurrentPage")), uno::UNO_QUERY);
+		nShapeCount = xPage->getCount();
+		if(GetShapeCount()<nShapeCount)
+		{
+			for(sal_Int32 nIndex = 0; nIndex<nShapeCount; nIndex++)
+			{
+
+				uno::Reference<drawing::XShape> xShape (
+					xPage->getByIndex(nIndex), uno::UNO_QUERY);
+
+				if(xShape == maDisposedShapes.back().Shape)
+				{
+					IndexInfo::iterator aIter = maDisposedShapeMap.find(maDisposedShapes.back().Identifier);
+					AddShapeDescriptor(aIter->second, maDisposedShapes.back());
+					maDisposedShapes.pop_back();
+					maDisposedShapeMap.erase(aIter);
+					return true;
+				}
+			}
+		}
+	}
+	return false;
+}
+
+
+} //end of namespace sd
diff --git sd/source/ui/ig/IntelligentGroupPane.cxx sd/source/ui/ig/IntelligentGroupPane.cxx
new file mode 100644
index 0000000..5bf23c2
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupPane.cxx
@@ -0,0 +1,521 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: IntelligentGroupPane.cxx,v $
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+
+#include "IntelligentGroupPane.hxx"
+#include "IntelligentGroupPane.hrc"
+#include "glob.hrc"
+#include "sdresid.hxx"
+#include "ViewShellBase.hxx"
+#include "DrawDocShell.hxx"
+#include "drawdoc.hxx"
+#include "DialogListBox.hxx"
+#include <sfx2/request.hxx>
+#include <sfx2/viewfrm.hxx>
+#include "res_bmp.hrc"
+#include <vcl/bitmap.hxx>
+#include <sfx2/app.hxx>
+#include "app.hrc"
+#include <sfx2/dispatch.hxx>
+#include <sfx2/bindings.hxx>
+
+
+
+namespace sd
+{	
+
+// ___________________
+//
+// IntelligentGroupPane
+// ___________________
+
+IntelligentGroupPane::IntelligentGroupPane(
+	::Window * pParent,
+	ViewShellBase & rBase,
+	const Size& rMinSize,
+	SdDrawDocument* pDoc ) :
+Control( pParent, SdResId( DLG_INTELLIGENTGROUPPANE ) ),
+
+	mrBase( rBase ),
+	mpDrawDoc( pDoc ),
+	maMinSize( rMinSize )
+{
+	mpFLIntelligentGroupLayouts = new FixedLine( this, SdResId( FL_INTELLIGENT_GROUP_LAYOUTS ) );
+	mpFLIntelligentGroupStyle = new FixedLine( this, SdResId( FL_INTELLIGENT_GROUP_STYLE ) );
+	mpFLIntelligentGroupThemeColor = new FixedLine( this, SdResId( FL_INTELLIGENT_GROUP_THEME_COLOR ) );
+
+	mpVSIntelligentGroupLayouts = new ValueSet( this, SdResId( CT_INTELLIGENT_GROUP_LAYOUTS ) );
+	mpVSIntelligentGroupLayouts->SetStyle( mpVSIntelligentGroupLayouts->GetStyle() & ~(WB_ITEMBORDER|WB_BORDER) | WB_NO_DIRECTSELECT |
+								WB_FLATVALUESET | WB_NOBORDER );
+	mpVSIntelligentGroupLayouts->SetColor();
+	mpVSIntelligentGroupLayouts->SetExtraSpacing(8);
+
+	mpVSIntelligentGroupStyle = new ValueSet( this, SdResId( CT_INTELLIGENT_GROUP_STYLE ) );
+	mpVSIntelligentGroupStyle->SetStyle( mpVSIntelligentGroupStyle->GetStyle() & ~(WB_ITEMBORDER|WB_BORDER) | WB_NO_DIRECTSELECT |
+								WB_FLATVALUESET | WB_NOBORDER );
+	mpVSIntelligentGroupStyle->SetColor();
+	mpVSIntelligentGroupStyle->SetExtraSpacing(8);
+
+	mpVSIntelligentGroupThemeColor = new ValueSet( this, SdResId( CT_INTELLIGENT_GROUP_THEME_COLOR ) );
+	mpVSIntelligentGroupThemeColor->SetStyle( mpVSIntelligentGroupThemeColor->GetStyle() & ~(WB_ITEMBORDER|WB_BORDER) | WB_NO_DIRECTSELECT |
+								WB_FLATVALUESET | WB_NOBORDER );
+	mpVSIntelligentGroupThemeColor->SetColor();
+	mpVSIntelligentGroupThemeColor->SetExtraSpacing(8);
+
+
+	mpFLSeperator = new FixedLine( this, SdResId( FL_SEPERATOR ) );
+	mpRBTLayouts = new RadioButton( this, SdResId( RBT_LAYOUTS ) );
+	mpRBTStyle = new RadioButton( this, SdResId( RBT_STYLE ) );
+	mpRBTThemeColor = new RadioButton( this, SdResId( RBT_THEME_COLOR ) );
+	mpLBLayouts = new ListBox( this ,SdResId( LB_LAYOUTS ) );
+
+	mpRBTLayouts->Check();
+	mpLBLayouts->SelectEntryPos(0);
+
+	// update the state of radio buttons and list box.
+	UpdateControlState();
+
+	// fill intelligent group layouts preview control in the valueset.
+	UpdateIntelligentGroupLayouts();
+
+	// resize controls according to current size
+	UpdateLayout();
+
+	// set handlers
+	mpVSIntelligentGroupLayouts->SetSelectHdl( LINK(this, IntelligentGroupPane, LayoutClickHandler) );
+	mpVSIntelligentGroupStyle->SetSelectHdl( LINK(this, IntelligentGroupPane, StyleClickHandler) );
+	mpVSIntelligentGroupThemeColor->SetSelectHdl( LINK(this, IntelligentGroupPane, ThemeColorClickHandler) );
+	mpLBLayouts->SetSelectHdl( LINK(this, IntelligentGroupPane, LayoutsSelectHdl) );
+	mpRBTLayouts->SetToggleHdl( LINK( this, IntelligentGroupPane, RadioButtonToggled ));
+	mpRBTStyle->SetToggleHdl( LINK( this, IntelligentGroupPane, RadioButtonToggled ));
+	mpRBTThemeColor->SetToggleHdl( LINK( this, IntelligentGroupPane, RadioButtonToggled ));
+
+	// use no resource ids from here on
+	FreeResource();
+}
+
+
+IntelligentGroupPane::~IntelligentGroupPane()
+{
+	delete mpFLIntelligentGroupLayouts;
+	delete mpFLIntelligentGroupStyle;
+	delete mpFLIntelligentGroupThemeColor;
+	delete mpVSIntelligentGroupLayouts;
+	delete mpVSIntelligentGroupStyle;
+	delete mpVSIntelligentGroupThemeColor;
+	delete mpFLSeperator;
+	delete mpRBTLayouts;
+	delete mpRBTStyle;
+	delete mpRBTThemeColor;
+	delete mpLBLayouts;
+}
+
+
+void IntelligentGroupPane::Resize()
+{
+	Size aPaneSize( GetSizePixel() );
+	Size aValueSetSize( mpVSIntelligentGroupLayouts->GetSizePixel() );
+	if (IsVisible() && aPaneSize.Width() > 0)
+	{
+		// Calculate the number of rows and columns.
+		if (mpVSIntelligentGroupLayouts->GetItemCount() > 0 && mpRBTLayouts->IsChecked())
+		{
+			Image aImage = mpVSIntelligentGroupLayouts->GetItemImage(mpVSIntelligentGroupLayouts->GetItemId(0));
+			Size aItemSize = mpVSIntelligentGroupLayouts->CalcItemSizePixel ( aImage.GetSizePixel());
+			aItemSize.Width() += 10;
+			aItemSize.Height() += 10;
+			int nColumnCount = ( aPaneSize.Width() - mpVSIntelligentGroupLayouts->GetScrollWidth() ) / aItemSize.Width();
+			if (nColumnCount < 1)
+				nColumnCount = 1;
+			else if (nColumnCount > 4)
+				nColumnCount = 4;
+
+			int nRowCount = (mpVSIntelligentGroupLayouts->GetItemCount() + nColumnCount - 1) / nColumnCount;
+
+			if (nRowCount < 4)
+				mpVSIntelligentGroupLayouts->SetLineCount( 4 );
+			else
+			{
+				int nVisibleRowCount = (aValueSetSize.Height() + 2) / aItemSize.Height();
+				mpVSIntelligentGroupLayouts->SetLineCount( (nRowCount < nVisibleRowCount) ? (USHORT) nRowCount : (USHORT)nVisibleRowCount );
+
+				if ( nRowCount > nVisibleRowCount )
+				{
+					mpVSIntelligentGroupLayouts->SetStyle( mpVSIntelligentGroupLayouts->GetStyle() | WB_VSCROLL );
+				}
+			}
+
+			mpVSIntelligentGroupLayouts->SetColCount( (USHORT)nColumnCount );
+		}
+
+		// Calculate the number of rows and columns.
+		if (mpVSIntelligentGroupStyle->GetItemCount() > 0 && mpRBTStyle->IsChecked())
+		{
+			Image aImage = mpVSIntelligentGroupStyle->GetItemImage(mpVSIntelligentGroupStyle->GetItemId(0));
+			Size aItemSize = mpVSIntelligentGroupStyle->CalcItemSizePixel ( aImage.GetSizePixel());
+			aItemSize.Width() += 10;
+			aItemSize.Height() += 10;
+			int nColumnCount = ( aPaneSize.Width() - mpVSIntelligentGroupStyle->GetScrollWidth() ) / aItemSize.Width();
+			if (nColumnCount < 1)
+				nColumnCount = 1;
+			else if (nColumnCount > 4)
+				nColumnCount = 4;
+
+			int nRowCount = (mpVSIntelligentGroupStyle->GetItemCount() + nColumnCount - 1) / nColumnCount;
+
+			if (nRowCount < 4)
+				mpVSIntelligentGroupStyle->SetLineCount( 4 );
+			else
+			{
+				int nVisibleRowCount = (aValueSetSize.Height() + 2) / aItemSize.Height();
+				mpVSIntelligentGroupStyle->SetLineCount( (nRowCount < nVisibleRowCount) ? (USHORT) nRowCount : (USHORT)nVisibleRowCount );
+
+				if ( nRowCount > nVisibleRowCount )
+				{
+					mpVSIntelligentGroupStyle->SetStyle( mpVSIntelligentGroupLayouts->GetStyle() | WB_VSCROLL );
+				}
+			}
+
+			mpVSIntelligentGroupStyle->SetColCount( (USHORT)nColumnCount );
+		}
+
+		// Calculate the number of rows and columns.
+		if (mpVSIntelligentGroupThemeColor->GetItemCount() > 0 && mpRBTThemeColor->IsChecked())
+		{
+			Image aImage = mpVSIntelligentGroupThemeColor->GetItemImage(mpVSIntelligentGroupThemeColor->GetItemId(0));
+			Size aItemSize = mpVSIntelligentGroupThemeColor->CalcItemSizePixel ( aImage.GetSizePixel());
+			aItemSize.Width() += 10;
+			aItemSize.Height() += 10;
+			int nColumnCount = ( aPaneSize.Width() - mpVSIntelligentGroupThemeColor->GetScrollWidth() ) / aItemSize.Width();
+			if (nColumnCount < 1)
+				nColumnCount = 1;
+			else if (nColumnCount > 4)
+				nColumnCount = 4;
+
+			int nRowCount = (mpVSIntelligentGroupThemeColor->GetItemCount() + nColumnCount - 1) / nColumnCount;
+
+			if (nRowCount < 4)
+				mpVSIntelligentGroupThemeColor->SetLineCount( 4 );
+			else
+			{
+				int nVisibleRowCount = (aValueSetSize.Height() + 2) / aItemSize.Height();
+				mpVSIntelligentGroupThemeColor->SetLineCount( (nRowCount < nVisibleRowCount) ? (USHORT) nRowCount : (USHORT)nVisibleRowCount );
+
+				if ( nRowCount > nVisibleRowCount )
+				{
+					mpVSIntelligentGroupThemeColor->SetStyle( mpVSIntelligentGroupThemeColor->GetStyle() | WB_VSCROLL );
+				}
+			}
+
+			mpVSIntelligentGroupThemeColor->SetColCount( (USHORT)nColumnCount );
+		}
+	}
+
+	UpdateLayout();
+}
+
+
+static SfxBindings* getBindings( ViewShellBase& rBase )
+{
+	if( rBase.GetMainViewShell().get() && rBase.GetMainViewShell()->GetViewFrame() )
+		return &rBase.GetMainViewShell()->GetViewFrame()->GetBindings();
+	else
+		return 0;
+}
+
+
+void IntelligentGroupPane::UpdateIntelligentGroupLayouts ( void )
+{
+	mpVSIntelligentGroupLayouts->Clear();
+	USHORT nIndex = mpLBLayouts->GetSelectEntryPos();
+
+	Bitmap aGroupListBmp( SdResId(BMP_IGLAYOUTS_GROUPEDLIST));
+	Bitmap aPictureAccentListBmp( SdResId(BMP_IGLAYOUTS_PICTUREACCENTLIST));
+	Bitmap aTreeBmp( SdResId(BMP_IGLAYOUTS_TREE) );
+	Bitmap aSimpleFieldBmp( SdResId(BMP_IGLAYOUTS_SIMPLEFIELD) );
+	Bitmap aBaseCircleBmp( SdResId(BMP_IGLAYOUTS_BASECIRCLE) );
+
+	switch( nIndex )
+	{
+		case 0:	// Insert All the layouts
+		{
+			mpVSIntelligentGroupLayouts->InsertItem( 1, aGroupListBmp );
+			mpVSIntelligentGroupLayouts->InsertItem( 2, aPictureAccentListBmp );
+			mpVSIntelligentGroupLayouts->InsertItem( 3, aTreeBmp );
+			mpVSIntelligentGroupLayouts->InsertItem( 4, aSimpleFieldBmp);
+			mpVSIntelligentGroupLayouts->InsertItem( 5, aBaseCircleBmp );
+		}
+		break;
+
+		case 1:	// Insert List layouts
+		{
+			mpVSIntelligentGroupLayouts->InsertItem( 1, aGroupListBmp );
+			mpVSIntelligentGroupLayouts->InsertItem( 2, aPictureAccentListBmp );
+		}
+		break;
+
+		case 2: // Insert Process layouts
+		{
+			mpVSIntelligentGroupLayouts->InsertItem( 4, aSimpleFieldBmp);
+		}
+		break;
+
+		case 3:	// Insert Cycle layouts
+		{
+			mpVSIntelligentGroupLayouts->InsertItem( 5, aBaseCircleBmp );
+		}
+		break;
+
+		case 4:	// Insert Hierarchy layouts
+		{
+			mpVSIntelligentGroupLayouts->InsertItem( 3, aTreeBmp );
+		}
+		break;
+
+		case 5:	// Insert Relationship layouts
+		//TODO
+		break;
+
+		case 6:	// Insert Matrix layouts
+		//TODO
+		break;
+		default:
+			break;
+	}
+}
+
+
+void IntelligentGroupPane::UpdateLayout()
+{
+	Size aPaneSize( GetSizePixel() );
+	if( aPaneSize.Width() < maMinSize.Width() )
+		aPaneSize.Width() = maMinSize.Width();
+
+	if( aPaneSize.Height() < maMinSize.Height() )
+		aPaneSize.Height() = maMinSize.Height();
+
+	// We should layout elements from bottom to top.Because the size of topmost
+	// control rest with the remaining space.
+	Point aOffset( LogicToPixel( Point(1,1), MAP_APPFONT ) );
+	long nOffsetX = aOffset.getX();
+	long nOffsetY = aOffset.getY();
+	long nOffsetRbtX = LogicToPixel( Point( 6, 1 ), MAP_APPFONT ).getX();
+
+	Point aUpperLeft( nOffsetX, aPaneSize.getHeight() - nOffsetY );
+	long nMaxWidth = aPaneSize.getWidth() -  2*nOffsetX;
+
+	// "Theme Color" RadioButton
+	Size aCtrlSize = mpRBTThemeColor->GetSizePixel();
+	aCtrlSize.setWidth( mpRBTThemeColor->CalcMinimumSize().getWidth() + nOffsetRbtX );
+	aUpperLeft.setY( aUpperLeft.getY() - aCtrlSize.getHeight() );
+	mpRBTThemeColor->SetPosSizePixel( aUpperLeft, aCtrlSize );
+
+	// "Style" RadioButton
+	aCtrlSize = mpRBTStyle->GetSizePixel();
+	aCtrlSize.setWidth( mpRBTThemeColor->CalcMinimumSize().getWidth() + nOffsetRbtX );
+	aUpperLeft.setY( aUpperLeft.getY() - aCtrlSize.getHeight() - 3*nOffsetY );
+	mpRBTStyle->SetPosSizePixel( aUpperLeft, aCtrlSize );
+
+	// "Layouts" RadioButton
+	aCtrlSize = mpRBTLayouts->GetSizePixel();
+	aCtrlSize.setWidth( mpRBTLayouts->CalcMinimumSize().getWidth() + nOffsetRbtX );
+	aUpperLeft.setY( aUpperLeft.getY() - aCtrlSize.getHeight() - 3*nOffsetY );
+	mpRBTLayouts->SetPosSizePixel( aUpperLeft, aCtrlSize );
+
+	// "Layouts select" ListBox
+	aCtrlSize = mpLBLayouts->GetSizePixel();
+	aCtrlSize.setWidth( nMaxWidth - mpRBTLayouts->CalcMinimumSize().getWidth() - 2*nOffsetX );
+	aUpperLeft.setX( mpRBTLayouts->CalcMinimumSize().getWidth() + 4*nOffsetX );
+	mpLBLayouts->SetPosSizePixel( aUpperLeft, aCtrlSize );
+	aUpperLeft.setX( nOffsetX );
+
+	// Fixedline above "Layouts RadioButton"
+	aCtrlSize = mpFLSeperator->GetSizePixel();
+	aCtrlSize.setWidth( nMaxWidth );
+	aUpperLeft.setY( aUpperLeft.getY() - aCtrlSize.getHeight() - 3*nOffsetY );
+	mpFLSeperator->SetPosSizePixel( aUpperLeft, aCtrlSize );
+
+	// "Intelligent Group Layouts" FixedLine
+	Point aUpperLeftCorner( 2*nOffsetX, 2*nOffsetY );
+	aCtrlSize = mpFLIntelligentGroupLayouts->GetSizePixel();
+	aCtrlSize.setWidth( nMaxWidth );
+	mpFLIntelligentGroupLayouts->SetPosSizePixel( aUpperLeftCorner, aCtrlSize );
+
+	// "Intelligent Group Style" FixedLine
+	aCtrlSize = mpFLIntelligentGroupStyle->GetSizePixel();
+	aCtrlSize.setWidth( nMaxWidth );
+	mpFLIntelligentGroupStyle->SetPosSizePixel( aUpperLeftCorner, aCtrlSize );
+
+	// "Intelligent Group Theme Color" FixedLine
+	aCtrlSize = mpFLIntelligentGroupThemeColor->GetSizePixel();
+	aCtrlSize.setWidth( nMaxWidth );
+	mpFLIntelligentGroupThemeColor->SetPosSizePixel( aUpperLeftCorner, aCtrlSize );
+	aUpperLeftCorner.setY( aUpperLeftCorner.getY() + aCtrlSize.Height() + 3*nOffsetY );
+	aUpperLeft.setY( aUpperLeft.getY() - nOffsetY );
+
+	// "Intelligent Group Valueset" control
+	aCtrlSize.setWidth( nMaxWidth );
+	aCtrlSize.setHeight( aUpperLeft.getY() - aUpperLeftCorner.getY() );
+	mpVSIntelligentGroupLayouts->SetPosSizePixel( aUpperLeftCorner, aCtrlSize );
+	mpVSIntelligentGroupStyle->SetPosSizePixel( aUpperLeftCorner, aCtrlSize );
+	mpVSIntelligentGroupThemeColor->SetPosSizePixel( aUpperLeftCorner, aCtrlSize );
+}
+
+
+::Window * createIntelligentGroupPanel( ::Window* pParent, ViewShellBase& rBase )
+{
+	DialogListBox* pWindow = 0;
+
+	DrawDocShell* pDocSh = rBase.GetDocShell();
+	if( pDocSh )
+	{
+		pWindow = new DialogListBox( pParent, WB_CLIPCHILDREN|WB_TABSTOP|WB_AUTOHSCROLL );
+
+		Size aMinSize( pWindow->LogicToPixel( Size( 80, 230 ), MAP_APPFONT ) );
+		::Window* pPaneWindow = new IntelligentGroupPane( pWindow, rBase, aMinSize, pDocSh->GetDoc() );
+		pWindow->SetChildWindow( pPaneWindow, aMinSize );
+		pWindow->SetText( pPaneWindow->GetText() );
+	}
+
+	return pWindow;
+}
+
+
+IMPL_LINK( IntelligentGroupPane, LayoutClickHandler, ValueSet*, EMPTYARG )
+{
+	ApplyIntelligentGroupLayout();
+	return 0;
+}
+
+
+IMPL_LINK( IntelligentGroupPane, StyleClickHandler, ValueSet*, EMPTYARG )
+{
+	AssignStyleToSelectLayout();
+	return 0;
+}
+
+
+IMPL_LINK( IntelligentGroupPane, ThemeColorClickHandler, ValueSet*, EMPTYARG )
+{
+	AssignThemeColorToSelectLayout();
+	return 0;
+}
+
+
+IMPL_LINK( IntelligentGroupPane, RadioButtonToggled,  void *, EMPTYARG )
+{
+	UpdateControlState();
+	return 0;
+}
+
+
+IMPL_LINK(IntelligentGroupPane, LayoutsSelectHdl, ListBox *, EMPTYARG )
+{
+	UpdateIntelligentGroupLayouts();
+	return 0;
+}
+
+void IntelligentGroupPane::UpdateControlState()
+{
+	mpFLIntelligentGroupLayouts->Hide();
+	mpVSIntelligentGroupLayouts->Hide();
+	mpFLIntelligentGroupStyle->Hide();
+	mpVSIntelligentGroupStyle->Hide();
+	mpFLIntelligentGroupThemeColor->Hide();
+	mpVSIntelligentGroupThemeColor->Hide();
+	mpLBLayouts->Disable();
+
+	if ( mpRBTLayouts->IsChecked() )
+	{
+		mpFLIntelligentGroupLayouts->Show();
+		mpVSIntelligentGroupLayouts->Show();
+		mpLBLayouts->Enable();
+	}
+
+	if ( mpRBTStyle->IsChecked() )
+	{
+		mpFLIntelligentGroupStyle->Show();
+		mpVSIntelligentGroupStyle->Show();
+	}
+
+	if ( mpRBTThemeColor->IsChecked() )
+	{
+		mpFLIntelligentGroupThemeColor->Show();
+		mpVSIntelligentGroupThemeColor->Show();
+	}
+}
+
+
+static SfxDispatcher* getDispatcher( ViewShellBase& rBase )
+{
+	if( rBase.GetMainViewShell().get() && rBase.GetMainViewShell()->GetViewFrame() )
+		return rBase.GetMainViewShell()->GetViewFrame()->GetDispatcher();
+	else
+		return 0;
+}
+
+
+void IntelligentGroupPane::ApplyIntelligentGroupLayout()
+{
+	USHORT aLayoutIndex = mpVSIntelligentGroupLayouts->GetSelectItemId();
+	rtl::OUString sStyleName;
+	switch(aLayoutIndex)
+	{
+		case 1: sStyleName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedList")); break;
+		case 2: sStyleName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PictureAccentList")); break;
+		case 3: sStyleName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Tree")); break;
+		case 4: sStyleName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("SimpleField"));break;
+		case 5: sStyleName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("BaseCircle"));break;
+	}
+	SfxRequest aReq (mrBase.GetViewFrame(), SID_INSERT_INTELLIGENT_GROUP);
+	aReq.AppendItem( SfxStringItem( SID_INSERT_INTELLIGENT_GROUP, sStyleName ) );
+	ViewShell* pMainViewShell = mrBase.GetMainViewShell().get();
+
+	if ( pMainViewShell )
+	{
+		pMainViewShell->ExecuteSlot (aReq);
+	}
+}
+
+
+void IntelligentGroupPane::AssignStyleToSelectLayout()
+{
+	//TODO:
+}
+
+
+void IntelligentGroupPane::AssignThemeColorToSelectLayout()
+{
+	//TODO:
+}
+
+} //  namespace sd
diff --git sd/source/ui/ig/IntelligentGroupPane.hrc sd/source/ui/ig/IntelligentGroupPane.hrc
new file mode 100644
index 0000000..53ce7a5
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupPane.hrc
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: IntelligentGroupPane.hrc,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/09 03:37:38 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SD_INTELLIGENTGROUPPANE_HRC
+#define _SD_INTELLIGENTGROUPPANE_HRC
+
+// spec: 1
+
+#define FL_INTELLIGENT_GROUP_LAYOUTS		1
+#define FL_INTELLIGENT_GROUP_STYLE			2
+#define FL_INTELLIGENT_GROUP_THEME_COLOR	3
+#define CT_INTELLIGENT_GROUP_LAYOUTS		4
+#define CT_INTELLIGENT_GROUP_STYLE			5
+#define CT_INTELLIGENT_GROUP_THEME_COLOR	6
+#define FL_SEPERATOR					    7
+#define RBT_LAYOUTS							8
+#define LB_LAYOUTS							9
+#define RBT_STYLE							10
+#define RBT_THEME_COLOR						11
+
+#endif // _SD_INTELLIGENTGROUPPANE_HRC
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupPane.hxx sd/source/ui/ig/IntelligentGroupPane.hxx
new file mode 100644
index 0000000..377c02c
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupPane.hxx
@@ -0,0 +1,104 @@
+/*************************************************************************
+*
+*  OpenOffice.org - a multi-platform office productivity suite
+*
+*  $RCSfile: IntelligentGroupPane.hxx,v $
+*
+*  $Revision: 1.7 $
+*
+*  last change: $Author: kz $ $Date: 2006/04/26 20:45:07 $
+*
+*  The Contents of this file are made available subject to
+*  the terms of GNU Lesser General Public License Version 2.1.
+*
+*
+*    GNU Lesser General Public License Version 2.1
+*    =============================================
+*    Copyright 2005 by Sun Microsystems, Inc.
+*    901 San Antonio Road, Palo Alto, CA 94303, USA
+*
+*    This library is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU Lesser General Public
+*    License version 2.1, as published by the Free Software Foundation.
+*
+*    This library is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*    Lesser General Public License for more details.
+*
+*    You should have received a copy of the GNU Lesser General Public
+*    License along with this library; if not, write to the Free Software
+*    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+*    MA  02111-1307  USA
+*
+************************************************************************/
+#ifndef SD_INTELLIGENTGOUPPANE_HXX
+#define SD_INTELLIGENTGOUPPANE_HXX
+
+
+#include <vcl/fixed.hxx>
+#include <vcl/button.hxx>
+#include <vcl/lstbox.hxx>
+//#include <tools/string.hxx>
+#include <svtools/valueset.hxx>
+
+
+class SdDrawDocument;
+
+
+namespace sd
+{
+
+
+class ViewShellBase;
+
+class IntelligentGroupPane : public Control
+{
+public:
+	explicit IntelligentGroupPane(
+		::Window * pParent,
+		ViewShellBase & rBase,
+		const Size& rMinSize,
+		SdDrawDocument* pDoc );
+	virtual ~IntelligentGroupPane();
+
+	virtual void Resize();
+private:
+
+	DECL_LINK( LayoutClickHandler, ValueSet* );
+	DECL_LINK( StyleClickHandler, ValueSet* );
+	DECL_LINK( ThemeColorClickHandler, ValueSet* );
+	DECL_LINK( LayoutsSelectHdl, ListBox * );
+	DECL_LINK( RadioButtonToggled, void * );
+
+	void UpdateLayout();
+	void UpdateControlState();
+	void UpdateIntelligentGroupLayouts( );
+
+	void ApplyIntelligentGroupLayout();
+	void AssignStyleToSelectLayout();
+	void AssignThemeColorToSelectLayout();
+
+private:
+	ViewShellBase &   mrBase;
+	SdDrawDocument *  mpDrawDoc;
+	Size              maMinSize;
+
+	FixedLine*   mpFLIntelligentGroupLayouts;
+	FixedLine*   mpFLIntelligentGroupStyle;
+	FixedLine*   mpFLIntelligentGroupThemeColor;
+	ValueSet*    mpVSIntelligentGroupLayouts;
+	ValueSet*    mpVSIntelligentGroupStyle;
+	ValueSet*    mpVSIntelligentGroupThemeColor;
+	FixedLine*	 mpFLSeperator;
+	PushButton*	 mpPBEditColorSchemes;
+	RadioButton* mpRBTLayouts;
+	ListBox*	 mpLBLayouts;
+	RadioButton* mpRBTStyle;
+	RadioButton* mpRBTThemeColor;
+};
+
+} //  namespace sd
+
+// SD_COLORSCHEMESPANE_HXX
+#endif;
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupPane.src sd/source/ui/ig/IntelligentGroupPane.src
new file mode 100644
index 0000000..627e6e0
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupPane.src
@@ -0,0 +1,136 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: IntelligentGroupPane.src,v $
+ *
+ *  $Revision: 1.9 $
+ *
+ *  last change: $Author: ihi $ $Date: 2007/04/19 12:16:08 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "IntelligentGroupPane.hrc"
+#include "glob.hrc"
+#include <svtools/controldims.hrc>
+
+Control DLG_INTELLIGENTGROUPPANE
+{
+	OutputSize = TRUE;
+	DialogControl = TRUE;
+	Size = MAP_APPFONT( 1, 1 );
+
+	Text [ en-US ] = "Intelligent Group";
+	
+	FixedLine FL_INTELLIGENT_GROUP_LAYOUTS
+	{
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_FIXEDLINE_HEIGHT );
+		Text [ en-US ] = "Layouts";
+	};
+	
+	FixedLine FL_INTELLIGENT_GROUP_STYLE
+	{
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_FIXEDLINE_HEIGHT );
+		Text [ en-US ] = "Style";
+	};
+	
+	FixedLine FL_INTELLIGENT_GROUP_THEME_COLOR
+	{
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_FIXEDLINE_HEIGHT );
+		Text [ en-US ] = "Theme Color";
+	};
+	
+	Control CT_INTELLIGENT_GROUP_LAYOUTS
+	{
+		Size = MAP_APPFONT( 1, 1 );
+		Border = TRUE ;
+		TabStop = TRUE ;	
+	};
+	
+	Control CT_INTELLIGENT_GROUP_STYLE
+	{
+		Size = MAP_APPFONT( 1, 1 );
+		Border = TRUE ;
+		TabStop = TRUE ;	
+	};
+	
+	Control CT_INTELLIGENT_GROUP_THEME_COLOR
+	{
+		Size = MAP_APPFONT( 1, 1 );
+		Border = TRUE ;
+		TabStop = TRUE ;	
+	};
+	
+	FixedLine FL_SEPERATOR
+	{
+		OutputSize = TRUE;
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_FIXEDLINE_HEIGHT );
+	};
+	
+	RadioButton RBT_LAYOUTS
+	{
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_RADIOBUTTON_HEIGHT );
+		Text [ en-US ] = "Layouts";
+	};
+	
+	ListBox LB_LAYOUTS
+	{
+        Size = MAP_APPFONT ( 1 , RSC_CD_DROPDOWN_HEIGHT );
+		Border = TRUE ;
+		DropDown = TRUE ;
+
+		StringList [ en-US ] =
+		{
+			< "ALL" ; > ;
+			< "List" ; > ;
+			< "Process" ; > ;
+			< "Cycle" ; > ;
+			< "Hierarchy" ; > ;
+			< "Relationship" ; > ;
+			< "Matrix" ; > ;
+			< "Pyramid" ; > ;
+		};
+	};
+	
+	RadioButton RBT_STYLE
+	{
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_RADIOBUTTON_HEIGHT );
+		Text [ en-US ] = "Style";
+	};
+	
+	RadioButton RBT_THEME_COLOR
+	{
+		OutputSize = TRUE;
+		Size = MAP_APPFONT( 1, RSC_CD_RADIOBUTTON_HEIGHT );
+		Text [ en-US ] = "Theme Color";
+	};
+};
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupShapeAccessor.cxx sd/source/ui/ig/IntelligentGroupShapeAccessor.cxx
new file mode 100644
index 0000000..93be96c
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupShapeAccessor.cxx
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupShapeAccessor.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupShapeAccessor.hxx"
+
+
+using namespace ::com::sun::star;
+
+
+namespace sd{
+
+	IntelligentGroupShapeAccessor::IntelligentGroupShapeAccessor(
+		boost::shared_ptr<IntelligentGroupModel> pModel,
+		std::vector< std::vector<IntelligentGroupShapeDescriptor> > aShapeDescriptorVector)
+		: mpModel(pModel),
+		maShapeDescriptors(aShapeDescriptorVector)
+	{
+	}
+
+
+	IntelligentGroupShapeAccessor::~IntelligentGroupShapeAccessor()
+	{
+	}
+
+
+	uno::Reference<drawing::XShape> IntelligentGroupShapeAccessor::GetShape(std::vector<sal_Int32> aPathVector)
+	{
+		switch (aPathVector.size())
+		{
+		case 1:
+			{
+				rtl::OUString sText = (maShapeDescriptors.at(aPathVector.at(0))).at(0).Identifier;
+				return mpModel->GetShape(sText);
+			}
+		case 2:
+			{
+				rtl::OUString sText = (maShapeDescriptors.at(aPathVector.at(0))).at(aPathVector.at(1)+1).Identifier;
+				return mpModel->GetShape(sText);
+			}
+		default: 
+			return NULL; 
+		}	
+	}
+
+
+	bool IntelligentGroupShapeAccessor::IsOutliner(std::vector<sal_Int32> aPathVector)
+	{
+		sal_Int32 nCount = aPathVector.size();
+		return aPathVector.size() >= 2;
+	}
+
+
+	sal_Int32 IntelligentGroupShapeAccessor::GetShapeCount(std::vector<sal_Int32> aPathVector)
+	{
+		switch (aPathVector.size())
+		{
+		case 1:
+			return maShapeDescriptors.size();
+		case 2:
+			return maShapeDescriptors.at(aPathVector.at(0)).size() - 1;
+		default:
+			return 0;
+		}
+	}
+
+
+	sal_Int32 IntelligentGroupShapeAccessor::GetChildCount(std::vector<sal_Int32> aPathVector)
+	{
+		switch (aPathVector.size())
+		{
+		case 1:
+			return maShapeDescriptors.at(aPathVector.at(0)).size() - 1;
+		case 2:
+			return 0;
+		default: 
+			return 0;
+		}
+	}
+
+
+}//end of namespace sd
diff --git sd/source/ui/ig/IntelligentGroupText.cxx sd/source/ui/ig/IntelligentGroupText.cxx
new file mode 100644
index 0000000..aade2ff
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupText.cxx
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: intelligentgrouptext.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupText.hxx"
+
+
+
+namespace sd{
+
+IntelligentGroupText::IntelligentGroupText(bool bIsUpdateFromShapeAllowed)
+{
+	mbIsUpdateFromShapeAllowed = bIsUpdateFromShapeAllowed;
+
+	Layout();
+	Initialize3();
+}
+
+
+void IntelligentGroupText::Layout ()
+{
+    mpText.reset(new IntelligentGroupBulletList());
+}
+
+
+void IntelligentGroupText::Initialize1 ()
+{
+	std::vector<rtl::OUString> aText;
+	aText.push_back(rtl::OUString::createFromAscii("One"));
+	aText.push_back(rtl::OUString::createFromAscii("Two"));
+	aText.push_back(rtl::OUString::createFromAscii("Three"));
+	aText.push_back(rtl::OUString::createFromAscii("Four"));
+	aText.push_back(rtl::OUString::createFromAscii("Five"));
+	mpText->SetText(aText);
+}
+
+
+void IntelligentGroupText::Initialize2 ()
+{
+	std::vector<rtl::OUString> aText;
+	aText.push_back(rtl::OUString::createFromAscii("January"));
+	aText.push_back(rtl::OUString::createFromAscii("February"));
+	aText.push_back(rtl::OUString::createFromAscii("March"));
+	aText.push_back(rtl::OUString::createFromAscii("April"));
+	aText.push_back(rtl::OUString::createFromAscii("May"));
+	aText.push_back(rtl::OUString::createFromAscii("June"));
+	aText.push_back(rtl::OUString::createFromAscii("July"));
+	aText.push_back(rtl::OUString::createFromAscii("August"));
+	aText.push_back(rtl::OUString::createFromAscii("September"));
+	aText.push_back(rtl::OUString::createFromAscii("October"));
+	aText.push_back(rtl::OUString::createFromAscii("November"));
+	aText.push_back(rtl::OUString::createFromAscii("December"));
+	mpText->SetText(aText);
+}
+
+
+
+void IntelligentGroupText::Initialize3 ()
+{
+	std::vector<rtl::OUString> aText;
+	aText.push_back(rtl::OUString::createFromAscii("Earth"));
+	aText.push_back(rtl::OUString::createFromAscii("*Moon"));
+	aText.push_back(rtl::OUString::createFromAscii("Mars"));
+	aText.push_back(rtl::OUString::createFromAscii("*Phobos"));
+	aText.push_back(rtl::OUString::createFromAscii("*Deimos"));
+	aText.push_back(rtl::OUString::createFromAscii("Jupiter"));
+	aText.push_back(rtl::OUString::createFromAscii("*Io"));
+	aText.push_back(rtl::OUString::createFromAscii("*Europa"));
+	aText.push_back(rtl::OUString::createFromAscii("*Ganymede"));
+	aText.push_back(rtl::OUString::createFromAscii("*Callisto"));
+	aText.push_back(rtl::OUString::createFromAscii("Neptune"));
+	aText.push_back(rtl::OUString::createFromAscii("*Proteus"));
+	aText.push_back(rtl::OUString::createFromAscii("*Triton"));
+	aText.push_back(rtl::OUString::createFromAscii("*Nereid"));
+	mpText->SetText(aText);
+}
+
+/*
+void IntelligentGroupText::UpdateList (boost::shared_ptr<IntelligentGroup> pGroup)
+{
+	if ( ! mbIsUpdateFromShapeAllowed)
+		return;
+	// When there is no group selected then leave without
+	// clearing the current content. 
+	if (pGroup.get() == NULL)
+		return;
+
+	mpText->Clear();
+	boost::shared_ptr<IntelligentGroupModel> pModel = pGroup->GetModel();
+	if (pModel.get() == NULL)
+		return;
+
+	boost::shared_ptr<IntelligentGroupTextIterator> pIterator = pGroup->GetLayouter()->CreateTextIterator();
+	boost::shared_ptr<IntelligentGroupFlatTextIterator> pFlatIterator(new IntelligentGroupFlatTextIterator(pIterator));
+
+	while (pFlatIterator->GotoNext())
+	{
+		mpText->AddText(pFlatIterator->GetLevel(), pFlatIterator->GetText());
+	}
+}
+*/
+
+boost::shared_ptr<IntelligentGroupTextIterator> IntelligentGroupText::CreateIterator()
+{
+	return mpText->CreateIterator();
+}
+
+
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/IntelligentGroupTextIterator.cxx sd/source/ui/ig/IntelligentGroupTextIterator.cxx
new file mode 100644
index 0000000..49998ca
--- /dev/null
+++ sd/source/ui/ig/IntelligentGroupTextIterator.cxx
@@ -0,0 +1,112 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupTextIterator.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "IntelligentGroupTextIterator.hxx"
+
+namespace sd{
+
+IntelligentGroupTextIterator::IntelligentGroupTextIterator()
+{
+	mnCurrentIndex = 0;
+	mnCurrentLevel = 0;
+	mnCurrentIndexOnLevel = 0;
+}
+
+
+IntelligentGroupTextIterator::~IntelligentGroupTextIterator()
+{
+	maIndexPath.clear();
+}
+
+
+IntelligentGroupTextIterator::IntelligentGroupTextIterator(IntelligentGroupTextIterator* pIterator)
+{
+	mnCurrentIndex = pIterator->mnCurrentIndex;
+	mnCurrentLevel = pIterator->mnCurrentLevel;
+	mnCurrentIndexOnLevel = pIterator->mnCurrentIndexOnLevel;
+
+	sal_Int32 nCount = pIterator->maIndexPath.size();
+	for (sal_Int32 nIndex=0; nIndex<nCount; ++nIndex)
+		maIndexPath.push_back(pIterator->maIndexPath[nIndex]);
+}
+
+
+
+sal_Int32 IntelligentGroupTextIterator::GetLevel()
+{
+	return mnCurrentLevel;
+}
+
+
+bool IntelligentGroupTextIterator::HasParent()
+{
+	return mnCurrentLevel>0;
+}
+
+
+void IntelligentGroupTextIterator::Down ()
+{
+	++mnCurrentLevel;
+	maIndexPath.push_back(mnCurrentIndexOnLevel);
+	mnCurrentIndexOnLevel = 0;
+}
+
+
+void IntelligentGroupTextIterator::Up ()
+{
+	--mnCurrentLevel;
+	mnCurrentIndexOnLevel = maIndexPath.back();
+	maIndexPath.pop_back();
+}
+
+
+sal_Int32 IntelligentGroupTextIterator::GetParentIndex (const sal_Int32 nLevel)
+{
+	return maIndexPath[nLevel];
+}
+
+
+
+bool IntelligentGroupTextIterator::Rewind ()
+{
+	mnCurrentIndex = 0;
+	mnCurrentLevel = 0;
+	mnCurrentIndexOnLevel = 0;
+	maIndexPath.clear();
+	return true;
+}
+
+
+}
+
+
+
diff --git sd/source/ui/ig/LayoutBase.cxx sd/source/ui/ig/LayoutBase.cxx
new file mode 100644
index 0000000..f750389
--- /dev/null
+++ sd/source/ui/ig/LayoutBase.cxx
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: layoutbase.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+
+#include "LayoutBase.hxx"
+
+using namespace ::com::sun::star;
+
+namespace sd{
+
+LayoutBase::LayoutBase(
+	IntelligentGroupModel* pModel,
+	LayoutDescriptor* pDescriptor)
+	:mpModel(pModel)
+	,mpLayoutDescriptor(pDescriptor)
+{
+}
+
+LayoutDescriptor* LayoutBase::GetLayoutDescriptor(void)
+{
+	return mpLayoutDescriptor;
+}
+
+ShapeDescriptor LayoutBase::GetShapeDescriptor(
+	const rtl::OUString sShapeIdentifier,
+	const ig::ShapeRole eRole,
+	const IntelligentGroupStyle aStyle)
+{
+	ShapeDescriptor aShapeDescriptor;
+	aShapeDescriptor.Shape = mpModel->GetShape(sShapeIdentifier);
+	aShapeDescriptor.Identifier = sShapeIdentifier;
+	aShapeDescriptor.Role = eRole;
+	aShapeDescriptor.Style = aStyle;
+	aShapeDescriptor.Exists = aShapeDescriptor.Shape!=NULL;
+	if (aShapeDescriptor.Exists)
+	{
+		aShapeDescriptor.ShapeLocation = aShapeDescriptor.Shape->getPosition();
+		aShapeDescriptor.ShapeSize = aShapeDescriptor.Shape->getSize();
+	}
+	else
+	{
+		aShapeDescriptor.Shape = CreateShape(aShapeDescriptor.Identifier);
+		mpModel->AddShape(aShapeDescriptor.Identifier, aShapeDescriptor.Role, aShapeDescriptor.Shape);
+	}
+
+	return aShapeDescriptor;
+}
+
+void LayoutBase::MoveShapeIntoGroupBoundingBox (
+	ShapeDescriptor& aDescriptor,
+	awt::Rectangle aGroupBoundingBox)
+{
+	if ( ! aDescriptor.Exists)
+	{
+		// Shape has just been created and is at its default position.
+		return;
+	}
+
+	bool bLocationModified = false;
+	awt::Point aLocation(
+		aDescriptor.ShapeLocation.X,
+		aDescriptor.ShapeLocation.Y);
+	if (aLocation.Y < aGroupBoundingBox.Y)
+	{
+		aLocation.Y = aGroupBoundingBox.Y;
+		bLocationModified = true;
+	}
+	if (aLocation.Y+aDescriptor.ShapeSize.Height > aGroupBoundingBox.Y+aGroupBoundingBox.Height)
+	{
+		aLocation.Y = aGroupBoundingBox.Y+aGroupBoundingBox.Height-aDescriptor.ShapeSize.Height;
+		bLocationModified = true;
+	}
+	if (aLocation.X < aGroupBoundingBox.X)
+	{
+		aLocation.X = aGroupBoundingBox.X;
+		bLocationModified = true;
+	}
+	if (aLocation.X+aDescriptor.ShapeSize.Width > aGroupBoundingBox.X+aGroupBoundingBox.Width)
+	{
+		aLocation.X = aGroupBoundingBox.X+aGroupBoundingBox.Width-aDescriptor.ShapeSize.Width;
+		bLocationModified = true;
+	}
+
+	if (bLocationModified)
+	{
+		// Place the shape at the corrected location.  
+		aDescriptor.Shape->setPosition(aLocation);
+
+		if (aDescriptor.LocationTransformation.X != 0 && aDescriptor.LocationTransformation.Y != 0)
+		{
+			// Now that the location of the shape has been corrected,
+			// we have to figure out how the correction affects the
+			// location transformation (manual translation made by user).
+
+			// Calculate the corrections that have to be made to the current
+			// location in order to move the shape inside the bounding box of
+			// the group.
+			const int nDX = aLocation.X - aDescriptor.ShapeLocation.X;
+			const int nDY = aLocation.Y - aDescriptor.ShapeLocation.Y;
+
+			// If we change the location transformation at all then we reduce it.
+			// This is the case only when the current transformation and
+			// the correction have different signs.
+			if (aDescriptor.LocationTransformation.X * nDX < 0)
+			{
+				const sal_Int32 nNewFirst = aDescriptor.LocationTransformation.X + nDX;
+				// We must not overshoot.  When the correction is larger (in absolute value)
+				// then the location transformation then set the later to 0. 
+				if (nNewFirst * aDescriptor.LocationTransformation.X <= 0)
+					aDescriptor.LocationTransformation.X = 0;
+				else
+					aDescriptor.LocationTransformation.X = nNewFirst;
+			}
+
+			// Now do the same with the other coordinate.
+			if (aDescriptor.LocationTransformation.Y * nDY < 0)
+			{
+				const sal_Int32 nNewSecond = aDescriptor.LocationTransformation.Y + nDY;
+				// We must not overshoot.  When the correction is larger (in absolute value)
+				// then the location transformation then set the later to 0. 
+				if (nNewSecond * aDescriptor.LocationTransformation.Y <= 0)
+					aDescriptor.LocationTransformation.Y = 0;
+				else
+					aDescriptor.LocationTransformation.Y = nNewSecond;
+			}
+		}
+
+		// Remember the new location.
+		aDescriptor.ShapeLocation = aLocation;
+	}
+}
+
+void LayoutBase::SetSizeLocation (ShapeDescriptor& aDescriptor)
+{
+	if ( ! aDescriptor.Exists)
+	{
+		aDescriptor.Shape->setPosition(aDescriptor.DefaultLocation);
+		aDescriptor.Shape->setSize(aDescriptor.DefaultSize);
+	}
+	else
+	{
+		awt::Point aLocation = aDescriptor.DefaultLocation;
+		if (aDescriptor.LocationTransformation.X != 0 && aDescriptor.LocationTransformation.Y != 0)
+		{
+			aLocation.X += aDescriptor.LocationTransformation.X;
+			aLocation.Y += aDescriptor.LocationTransformation.Y;
+		}
+		aDescriptor.Shape->setPosition(aLocation);
+		aDescriptor.Shape->setSize(aDescriptor.DefaultSize);
+		aDescriptor.ShapeLocation = aLocation;
+		aDescriptor.ShapeSize = aDescriptor.DefaultSize;
+	}
+}
+
+bool LayoutBase::IsGeometryModified(const ShapeDescriptor& aDescriptor)
+{	return aDescriptor.Exists 
+		&& ((aDescriptor.SizeTransformation.Width!=0 && aDescriptor.SizeTransformation.Height!=0)|| 
+		(aDescriptor.LocationTransformation.X!=0 && aDescriptor.LocationTransformation.Y!=0));
+}
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/ListLayoutAlgorithm.cxx sd/source/ui/ig/ListLayoutAlgorithm.cxx
new file mode 100644
index 0000000..b353fe3
--- /dev/null
+++ sd/source/ui/ig/ListLayoutAlgorithm.cxx
@@ -0,0 +1,170 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: ListLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#include "ListLayoutAlgorithm.hxx"
+#include "IntelligentGroupLayoutBase.hxx"
+
+
+namespace sd {
+
+
+ListLayoutAlgorithm::ListLayoutAlgorithm(const ig::Orientation eOrientation)
+{
+	meOrientation = eOrientation;
+}
+
+
+ListLayoutAlgorithm::~ListLayoutAlgorithm()
+{
+}
+
+
+void ListLayoutAlgorithm::PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, 
+//									 std::vector<std::vector<IntelligentGroupShapeDescriptor>>& rShapeDescriptorVector, 
+									 boost::shared_ptr<IntelligentGroupModel> pModel,
+									 css::awt::Rectangle aGroupBoundingBox)
+{
+	// There is one group of shapes for every top of level text entry.
+//	const sal_Int32 nCount = rShapeDescriptorVector.size();
+	const sal_Int32 nCount = pModel->GetShapeGroupCount();
+	if (nCount == 0)
+	{
+		// There are no text entries  => Nothing to do. 
+		return;
+	}
+	
+	const double nGap = pLayout->GetGap(aGroupBoundingBox);
+
+	// Determine the available size.
+	const sal_Int32 nAvailableSize = Project(aGroupBoundingBox.Width, aGroupBoundingBox.Height, true) - sal_Int32((nCount-1)*nGap);
+
+	// The default size depends on the available size and the number of
+	// shape groups but not an the actual sizes of the shape groups.
+	const sal_Int32 nDefaultSize = (sal_Int32)(nAvailableSize / nCount);
+
+	// Setup an array of the weights of the individual shape groups.
+	std::vector<sal_Int32> aWeightsVector;
+	sal_Int32 nTotalWeight = 0;
+	for (sal_Int32 nIndex = 0; nIndex < nCount; nIndex++)
+	{
+		css::awt::Size aBoundingSize = pLayout->GetBoundingSize( nIndex,
+																 css::awt::Size(nDefaultSize, aGroupBoundingBox.Height),	
+//																 rShapeDescriptorVector[nIndex] );
+																 pModel->GetShapeDescriptorVector(nIndex));
+		sal_Int32 nWeight = aBoundingSize.Width;
+
+		if (nWeight == 0)
+			nWeight = nDefaultSize;
+		else if (nWeight < 0)
+			nWeight =- nWeight;
+
+		nTotalWeight =+ nWeight;
+		aWeightsVector.push_back(nWeight);
+	}
+
+	// Scale all shapes up or down so that they fit the available size.
+	double nScale = nAvailableSize / nTotalWeight;
+
+	// Scale and place the shape groups.
+	sal_Int32 nPosition = 0;
+	for (sal_Int32 nIndex = 0; nIndex < nCount; nIndex++)
+	{
+		const css::awt::Point aRelativePosition = CreatePosition(nPosition, 0);
+		const sal_Int32 nWidth = sal_Int32(aWeightsVector.at(nIndex) * nScale + 0.5);
+
+		pLayout->PlaceShapes(
+//			rShapeDescriptorVector[nIndex],
+			nIndex,
+			css::awt::Rectangle(
+				aGroupBoundingBox.X + aRelativePosition.X,
+				aGroupBoundingBox.Y + aRelativePosition.Y,
+				//nWidth,
+				nWidth/nCount,
+				aGroupBoundingBox.Height),
+			aGroupBoundingBox,
+			css::awt::Size((sal_Int32)nDefaultSize, aGroupBoundingBox.Height),
+			nScale );
+
+		//nPosition += nWidth + nGap;
+		nPosition += sal_Int32(nWidth/nCount + nGap);
+	}
+}
+
+
+sal_Int32 ListLayoutAlgorithm::Project(const sal_Int32 nFirst, const sal_Int32 nSecond, const bool bProjectToPrimaryAxis)
+{
+	switch( meOrientation)
+	{
+	case ig::Horizontal:
+		if (bProjectToPrimaryAxis)
+			return nFirst;
+		else
+			return nSecond;
+	case ig::Vertical:
+		if (bProjectToPrimaryAxis)
+			return nSecond;
+		else
+			return nFirst;
+	default:
+	    return 0; // It's better to throw a exception.
+	}
+}
+
+
+css::awt::Size ListLayoutAlgorithm::CreateSize(const sal_Int32 nSizeOnPrimaryAxis, const sal_Int32 nSizeOnSecondaryAxis)
+{
+	switch(meOrientation)
+	{
+	case ig::Horizontal:
+		return css::awt::Size(nSizeOnPrimaryAxis, nSizeOnSecondaryAxis);
+	case ig::Vertical:
+		return css::awt::Size(nSizeOnSecondaryAxis, nSizeOnPrimaryAxis);
+	default:
+		return css::awt::Size(0 ,0); // It's better to throw a exception.
+	}
+}
+
+
+css::awt::Point ListLayoutAlgorithm::CreatePosition(const sal_Int32 nPositionOnPrimaryAxis, const sal_Int32 nPositionOnSecondaryAxis)
+{
+	switch(meOrientation)
+	{
+	case ig::Horizontal:
+		return css::awt::Point(nPositionOnPrimaryAxis, nPositionOnSecondaryAxis);
+	case ig::Vertical:
+	    return css::awt::Point(nPositionOnSecondaryAxis, nPositionOnPrimaryAxis);
+	default:
+		return css::awt::Point(0, 0); // It's better to throw a exception.
+	}
+}
+
+
+} 
\ No newline at end of file
diff --git sd/source/ui/ig/PictureAccentListLayout.cxx sd/source/ui/ig/PictureAccentListLayout.cxx
new file mode 100644
index 0000000..2ae1c0f
--- /dev/null
+++ sd/source/ui/ig/PictureAccentListLayout.cxx
@@ -0,0 +1,286 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: PictureAccentListLayout.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "PictureAccentListLayout.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/style/ParagraphAdjust.hpp>
+#include <com/sun/star/drawing/ColorMode.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/drawing/TextFitToSizeType.hpp>
+#include <com/sun/star/text/WritingMode.hpp>
+#include <svtools/colorcfg.hxx>
+
+using namespace ::com::sun::star;
+
+namespace sd{
+
+PictureAccentListLayout::PictureAccentListLayout(
+	boost::shared_ptr<IntelligentGroupModel> pModel,
+	boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+	:IntelligentGroupLayoutBase(pModel,pDescriptor)
+{
+}
+
+double PictureAccentListLayout::GetGap( awt::Rectangle aGroupBoundingBox )
+{
+	return aGroupBoundingBox.Width / 50;
+}
+
+awt::Size PictureAccentListLayout::GetBoundingSize (
+	sal_Int32 nIndex, 
+	awt::Size aDefaultSize, 
+	std::vector<IntelligentGroupShapeDescriptor> aDescriptors)
+{
+	uno::Reference<drawing::XShape> xTopLevelTextShape = mpModel->GetShape(GetShapeName(ig::TopLevelText, nIndex));
+	uno::Reference<drawing::XShape> xSecondLevelTextShape = mpModel->GetShape(GetShapeName(ig::SecondLevelText, nIndex));
+	uno::Reference<drawing::XShape> xAccentShape = mpModel->GetShape(GetShapeName(ig::Image, nIndex));
+	if (xTopLevelTextShape.is() && xSecondLevelTextShape.is() && xAccentShape.is())
+	{
+		sal_Int32 nTopLevelTextShapeWidth = xTopLevelTextShape->getSize().Width;
+		sal_Int32 nSecondLevelTextShapeWidth = xSecondLevelTextShape->getSize().Width;
+		sal_Int32 nAccentWidth = xAccentShape->getSize().Width;
+		// The accent image is centered on the left side of the second level text shape.
+		// Take it only into account when it is wider then the top level text shape on its left or
+		// the second level text shape on its right.
+		sal_Int32 nWidth = (sal_Int32)(std::max(nAccentWidth/2,nTopLevelTextShapeWidth)
+			+ std::max(nAccentWidth/2, nSecondLevelTextShapeWidth) + 0.5);
+
+		if ( ! (IsGeometryModified(aDescriptors[0])
+			|| IsGeometryModified(aDescriptors[1])
+			|| IsGeometryModified(aDescriptors[2])))
+		{
+			// The shapes do not yet exist or their geometry has not been modified manually.
+			return aDefaultSize;
+		}
+
+		return awt::Size(nWidth, aDefaultSize.Height);
+	}
+	else
+	{
+		// The shape does not yet exist.  When it is later created then it
+		// will have the default width.
+		return aDefaultSize;
+	}
+}
+
+std::vector<IntelligentGroupShapeDescriptor> PictureAccentListLayout::PrepareShapes (boost::shared_ptr<IntelligentGroupTextIterator> /*pTextIterator*/, sal_Int32 nIndex, bool bCreatedByUser)
+{
+	std::vector<IntelligentGroupShapeDescriptor> aDescriptors;
+
+	IntelligentGroupStyle aStyle;
+
+	aStyle.aBackground = IntelligentGroupStyle::None_Background;
+	aStyle.aBorder = IntelligentGroupStyle::None_Border;
+	aStyle.aText = IntelligentGroupStyle::Primary;
+	aDescriptors.push_back(GetShapeDescriptor(
+		GetShapeName(ig::TopLevelText, nIndex),
+		ig::Primary,
+		aStyle));
+
+	aStyle.aBackground = IntelligentGroupStyle::Foreground;
+	aStyle.aBorder = IntelligentGroupStyle::Regular;
+	aStyle.aText = IntelligentGroupStyle::Secondary;
+	aDescriptors.push_back(GetShapeDescriptor(
+		GetShapeName(ig::SecondLevelText, nIndex),
+		ig::Primary,
+		aStyle));
+
+	aStyle.aBackground = IntelligentGroupStyle::Accent;
+	aStyle.aBorder = IntelligentGroupStyle::None_Border;
+	aStyle.aText = IntelligentGroupStyle::None_Text;
+	aDescriptors.push_back(GetShapeDescriptor(
+		GetShapeName(ig::Image, nIndex),
+		ig::Accent,
+		aStyle));
+
+	if(!bCreatedByUser)
+		mpModel->AddShapeGroup(aDescriptors, mpModel->GetShapeGroupCount());
+
+	return aDescriptors;
+}
+
+//void PictureAccentListLayout::PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aShapeDescriptors,
+void PictureAccentListLayout::PlaceShapes(sal_Int32 nShapeGroupIndex,
+									awt::Rectangle aBoundingBox, 
+									awt::Rectangle aGroupBoundingBox, 
+									awt::Size aDefaultSize, 
+									double /*nScale*/)
+{	 // Provide default sizes and locations.
+	sal_Int32 nAccentSize = (sal_Int32)(aDefaultSize.Width*2/7+0.5);
+	sal_Int32 nTopLevelTextWidth = (sal_Int32)aBoundingBox.Width*1/4; 
+//	IntelligentGroupShapeDescriptor aSecondLevelTextDescriptor = aShapeDescriptors[1];
+	IntelligentGroupShapeDescriptor aSecondLevelTextDescriptor;
+	aSecondLevelTextDescriptor.DefaultLocation =awt::Point(
+		long(aBoundingBox.X + std::max(nAccentSize/2, nTopLevelTextWidth)),
+		long(aBoundingBox.Y + nAccentSize*2/3));
+	aSecondLevelTextDescriptor.DefaultSize = awt::Size(
+		long(aBoundingBox.Width*3/4),
+		long(aBoundingBox.Height - nAccentSize*2/3));
+
+//	IntelligentGroupShapeDescriptor aTopLevelTextDescriptor = aShapeDescriptors[0];
+	IntelligentGroupShapeDescriptor aTopLevelTextDescriptor;
+	aTopLevelTextDescriptor.DefaultLocation = awt::Point(
+		aBoundingBox.X,
+		aBoundingBox.Y + nAccentSize);
+	aTopLevelTextDescriptor.DefaultSize = awt::Size(
+		nTopLevelTextWidth,
+		aBoundingBox.Height - nAccentSize);
+
+//	IntelligentGroupShapeDescriptor aAccentDescriptor = aShapeDescriptors[2];
+	IntelligentGroupShapeDescriptor aAccentDescriptor;
+	aAccentDescriptor.DefaultLocation = awt::Point(
+		long(aBoundingBox.X + std::max(nAccentSize/2, nTopLevelTextWidth) - nAccentSize/2),
+		aBoundingBox.Y);
+	aAccentDescriptor.DefaultSize = awt::Size (
+		nAccentSize,
+		nAccentSize);
+
+	// Move shapes into the bounding box of the enclosing group.
+//	MoveShapeIntoGroupBoundingBox(aTopLevelTextDescriptor, aGroupBoundingBox);
+//	MoveShapeIntoGroupBoundingBox(aSecondLevelTextDescriptor,aGroupBoundingBox);
+//	MoveShapeIntoGroupBoundingBox(aAccentDescriptor, aGroupBoundingBox);
+
+	sal_Int32 nShapeDescriptorIndex = mpModel->GetShapeDescriptorIndex(nShapeGroupIndex,0);
+	mpModel->SetSizeLocation(nShapeDescriptorIndex,aTopLevelTextDescriptor);
+	mpModel->SetSizeLocation(nShapeDescriptorIndex+1,aSecondLevelTextDescriptor);
+	mpModel->SetSizeLocation(nShapeDescriptorIndex+2,aAccentDescriptor);
+	for(sal_Int32 nIndex = nShapeDescriptorIndex; nIndex<=nShapeDescriptorIndex+2; nIndex++)
+		mpModel->MoveShapeIntoGroupBoundingBox(nIndex, aGroupBoundingBox);
+
+}
+
+uno::Reference<drawing::XShape> PictureAccentListLayout::CreateShape(rtl::OUString aIdentifier)
+{
+	uno::Reference<drawing::XShape> xShape = NULL;
+
+	ig::ShapeClass eClass = GetClassForName(aIdentifier);
+	uno::Reference<beans::XPropertySet> xProperties;
+
+	switch (eClass)
+	{
+		case ig::TopLevelText:
+			{
+				xShape = uno::Reference<drawing::XShape>(
+					mpModel->GetShapeFactory()->createInstance(
+					rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.drawing.TextShape"))),
+					uno::UNO_QUERY);
+				xProperties = uno::Reference<beans::XPropertySet>(xShape, uno::UNO_QUERY);
+				if (xProperties.is())
+				{
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("TextWritingMode"), uno::makeAny(text::WritingMode_TB_RL));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("CornerRadius"), uno::makeAny((sal_Int32)100));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillColor"), uno::makeAny(sal_Int32(0xA90052)));
+				}
+			}
+			break;
+
+		case ig::SecondLevelText:
+			{
+				xShape = uno::Reference<drawing::XShape>(
+					mpModel->GetShapeFactory()->createInstance(
+					rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.presentation.OutlinerShape"))),
+					uno::UNO_QUERY);
+				xProperties = uno::Reference<beans::XPropertySet>(xShape, uno::UNO_QUERY);
+				if (xProperties.is())
+				{
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("CornerRadius"), uno::makeAny((sal_Int32)200));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillColor"), uno::makeAny(sal_Int32(0x2E8B57)));
+				}
+			}
+			break;
+		case ig::Image:
+			{
+				xShape = uno::Reference<drawing::XShape>(
+					mpModel->GetShapeFactory()->createInstance(
+					rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.presentation.GraphicObjectShape"))),
+					uno::UNO_QUERY);
+				xProperties = uno::Reference<beans::XPropertySet>(xShape, uno::UNO_QUERY);
+				if (xProperties.is())
+				{
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("CornerRadius"), uno::makeAny((sal_Int32)50));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID));
+					xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillColor"), uno::makeAny(sal_Int32(0xA90052)));
+				}
+			}
+			break;
+		default:
+			break;
+	}
+
+	if (xShape.is())
+	{
+		xShape->setSize(awt::Size(0,0));
+	}
+
+	return xShape;
+}
+
+
+rtl::OUString PictureAccentListLayout::GetShapePrefix(ig::ShapeClass eClass)
+{
+	rtl::OUString aShapePrefix;
+	switch (eClass)
+	{
+		case ig::TopLevelText : aShapePrefix = rtl::OUString::createFromAscii("Primary"); break;
+		case ig::SecondLevelText : aShapePrefix = rtl::OUString::createFromAscii("Secondary"); break;
+		case ig::Image: aShapePrefix = rtl::OUString::createFromAscii("Image"); break;
+	}
+	return aShapePrefix;
+}
+
+rtl::OUString PictureAccentListLayout::GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex)
+{
+	return GetShapePrefix(eClass) + rtl::OUString::valueOf(nIndex);
+}
+
+
+ig::ShapeClass PictureAccentListLayout::GetClassForName(rtl::OUString sIdentifier)
+{
+	ig::ShapeClass eShapeClass, eClass1 = ig::TopLevelText, eClass2 = ig::SecondLevelText, eClass3 = ig::Image;
+	if(sIdentifier.match(GetShapePrefix(eClass1)))
+		eShapeClass = eClass1;
+	else if(sIdentifier.match(GetShapePrefix(eClass2)))
+		eShapeClass = eClass2;
+	else if(sIdentifier.match(GetShapePrefix(eClass3)))
+		eShapeClass = eClass3;
+
+	return eShapeClass;
+
+}
+
+
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/RowFieldLayoutAlgorithm.cxx sd/source/ui/ig/RowFieldLayoutAlgorithm.cxx
new file mode 100644
index 0000000..97c7382
--- /dev/null
+++ sd/source/ui/ig/RowFieldLayoutAlgorithm.cxx
@@ -0,0 +1,51 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: RowFieldLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+
+#include "RowFieldLayoutAlgorithm.hxx"
+
+
+namespace sd { 
+
+
+
+RowFieldLayoutAlgorithm::RowFieldLayoutAlgorithm()
+:FieldLayoutAlgorithm( ig::Horizontal )
+{
+}
+
+
+RowFieldLayoutAlgorithm::~RowFieldLayoutAlgorithm()
+{
+}
+
+
+} 
\ No newline at end of file
diff --git sd/source/ui/ig/SelectionManager.cxx sd/source/ui/ig/SelectionManager.cxx
new file mode 100644
index 0000000..e7f43b7
--- /dev/null
+++ sd/source/ui/ig/SelectionManager.cxx
@@ -0,0 +1,299 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: selectionmanager.cxx,v $
+ * $Revision: 1.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "SelectionManager.hxx"
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include "View.hxx"
+#include "framework/FrameworkHelper.hxx"
+
+using namespace ::com::sun::star;
+using ::sd::framework::FrameworkHelper;
+
+namespace sd{
+
+SelectionManager::SelectionManager(uno::Reference<frame::XController> xController,
+	uno::Reference<frame::XModel> xModel)
+{
+	mxController = xController;
+	mxModel = xModel;
+	mpIntelligentGroupFrame = 0;
+
+	if (xController.is())
+	{
+		mxSelectionSupplier = uno::Reference<view::XSelectionSupplier>(
+			xController, uno::UNO_QUERY );
+		if (mxSelectionSupplier.is())
+			mxSelectionSupplier->addSelectionChangeListener(this);
+
+		uno::Reference< beans::XPropertySet > xPropertySet ( 
+			xController, uno::UNO_QUERY );
+		if ( xPropertySet.is() )
+			xPropertySet->addPropertyChangeListener( ::rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage")), this );
+	}
+}
+
+SelectionManager::~SelectionManager() 
+{
+	if(mpIntelligentGroupFrame != NULL)
+	{
+		mpIntelligentGroupFrame->Dispose();
+		mpIntelligentGroupFrame = 0;
+	}
+
+	IntelligentGroup::Dispose();
+}
+
+boost::shared_ptr<IntelligentGroup> SelectionManager::GetSelectedIntelligentGroup()
+{
+	if (mpSelectedIntelligentGroup.get() == NULL && mxSelectedShape.is())
+		mpSelectedIntelligentGroup = IntelligentGroup::Instance(mxModel, mxSelectedShape);
+	
+	return mpSelectedIntelligentGroup;
+}
+
+bool SelectionManager::IsSelectedIntelligentGroupEntered()
+{
+	return mbIsEntered;
+}
+
+void SelectionManager::DisposeFrame()
+{
+	if( mpIntelligentGroupFrame != NULL )
+	{
+		mpIntelligentGroupFrame->Dispose();
+		mpIntelligentGroupFrame = 0;
+	}
+}
+
+
+void  SAL_CALL
+SelectionManager::selectionChanged (const ::com::sun::star::lang::EventObject& /*rEvent*/)
+throw (::com::sun::star::uno::RuntimeException)
+{
+	uno::Reference<drawing::XShape> xShape = GetSelectedShape();
+	SetSelectedShape(xShape);
+
+	boost::shared_ptr<ViewShell> pCenterViewShell = 
+		FrameworkHelper::Instance(mxController)->
+		GetViewShell(framework::FrameworkHelper::msCenterPaneURL);
+	if (pCenterViewShell.get() != NULL)
+	{
+		if(mpIntelligentGroupFrame == NULL && xShape.is() && mbIsEntered)
+		{
+			if(pCenterViewShell->GetShellType() == ViewShell::ST_IMPRESS)
+			{
+				sd::View* pView  = pCenterViewShell->GetView();
+				mpIntelligentGroupFrame = new IntelligentGroupFrame(mpSelectedIntelligentGroup->GetModel(),*pView);
+				mpIntelligentGroupFrame->SetLayouter(mpSelectedIntelligentGroup->GetLayouter());
+			}
+		}
+		else if(mpIntelligentGroupFrame != NULL && !xShape.is() && !mbIsEntered)
+		{
+			mpIntelligentGroupFrame->Dispose();
+			mpIntelligentGroupFrame = 0;
+		}
+	}
+	else 
+	{
+		if(mpIntelligentGroupFrame != NULL)
+		{
+			mpIntelligentGroupFrame->Dispose();
+			mpIntelligentGroupFrame = 0;
+		}
+	}
+}
+
+
+void SAL_CALL
+SelectionManager::propertyChange(const ::com::sun::star::beans::PropertyChangeEvent& rEventObject)
+throw (::com::sun::star::uno::RuntimeException)
+{
+	OSL_TRACE ("AccessibleDrawDocumentView::propertyChange");
+	if (rEventObject.PropertyName == ::rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage")))
+	{
+		if( mpIntelligentGroupFrame != NULL )
+		{
+			mpIntelligentGroupFrame->Dispose();
+//			mpView->updateHandles();
+			mpIntelligentGroupFrame = 0;
+		}
+
+		mpSelectedIntelligentGroup.reset();
+	}
+}
+
+void SAL_CALL 
+SelectionManager::disposing (const ::com::sun::star::lang::EventObject& rEventObject)
+throw (::com::sun::star::uno::RuntimeException)
+{
+	if (rEventObject.Source == mxSelectionSupplier)
+	{
+		if(mxSelectionSupplier.is())
+			mxSelectionSupplier->removeSelectionChangeListener(this);
+
+		uno::Reference< beans::XPropertySet > xPropertySet ( 
+			mxController, uno::UNO_QUERY );
+		if ( xPropertySet.is() )
+			xPropertySet->removePropertyChangeListener( ::rtl::OUString (RTL_CONSTASCII_USTRINGPARAM("CurrentPage")), this );
+
+		mxSelectionSupplier = NULL;
+	}
+}
+
+void SelectionManager::SetSelectedShape(uno::Reference<drawing::XShape> xShape)
+{
+//	AddOrRemovePropertyListener(mpSelectedIntelligentGroup.get(), false);
+
+	mxSelectedShape = xShape;
+	mbIsEntered = false;
+	if (mxSelectedShape.is())
+	{
+		if (IntelligentGroup::IsIntelligentGroup(mxSelectedShape))
+		{
+			mpSelectedIntelligentGroup = IntelligentGroup::Instance(mxModel, mxSelectedShape);
+			mbIsEntered = true;
+		}
+		else
+		{
+			mpSelectedIntelligentGroup = FindShapeInGroup(xShape);
+			mbIsEntered = mpSelectedIntelligentGroup.get()!=NULL;
+		}
+	}
+/*	else
+	{
+		mpSelectedIntelligentGroup = 0;
+	}
+*/
+//	AddOrRemovePropertyListener(mpSelectedIntelligentGroup.get(), true);
+
+//	std::vector<uno::Reference<view::XSelectionChangeListener> >::iterator aIter = maListeners.begin();
+//	for (; aIter!=maListeners.end(); ++aIter)
+//		(*aIter)->NotifySelectionChange(mpSelectedIntelligentGroup);
+
+}
+
+
+void SelectionManager::Select(boost::shared_ptr<IntelligentGroup> pIntelligentGroup)
+{
+	if (mxSelectionSupplier.is())
+		mxSelectionSupplier->select(uno::makeAny(pIntelligentGroup->GetModel()->GetGroupShape()));
+}
+
+uno::Reference<drawing::XShape> SelectionManager::GetSelectedShape()
+{
+	uno::Reference<drawing::XShape> xShape;
+	sal_Int32 nCount = 0;
+
+	if (mxSelectionSupplier.is())
+	{
+		uno::Any aSelection = mxSelectionSupplier->getSelection();
+//		if (aSelection.hasValue())
+//		{
+//			xShape = uno::Reference<drawing::XShape>(aSelection, uno::UNO_QUERY);
+			aSelection >>= xShape;
+			
+			if (xShape.is())
+				nCount = 1;
+			else
+			{
+//				uno::Reference<container::XIndexAccess> xShapes(aSelection, uno::UNO_QUERY);
+				uno::Reference<container::XIndexAccess> xShapes;
+				aSelection >>= xShapes;
+				if (xShapes.is())
+				{
+					nCount = xShapes->getCount();
+					if (nCount == 1)
+					{
+						xShape = uno::Reference<drawing::XShape>(xShapes->getByIndex(0), uno::UNO_QUERY);
+						if (xShape.is())
+							nCount = 0;
+					}
+				}
+			}
+//		}
+	}
+	return xShape;
+}
+
+boost::shared_ptr<IntelligentGroup> SelectionManager::FindShapeInGroup(uno::Reference<drawing::XShape> xShape)
+{
+/*	uno::Reference<beans::XPropertySet> xProperties (mxController, uno::UNO_QUERY);
+	if (xProperties.is())
+	{
+		uno::Reference<container::XIndexAccess> xPage (
+			xProperties->getPropertyValue(rtl::OUString::createFromAscii("CurrentPage")), uno::UNO_QUERY);
+		sal_Int32 nShapeCount = xPage->getCount();
+		for (sal_Int32 nIndex=0; nIndex<nShapeCount; ++nIndex)
+		{
+			uno::Reference<drawing::XShape> xChild (
+				xPage->getByIndex(nIndex), uno::UNO_QUERY);
+			if (IntelligentGroup::IsIntelligentGroup(xChild))
+			{
+				uno::Reference<container::XIndexAccess> xGroup (
+					xChild, uno::UNO_QUERY);
+				sal_Int32 nGroupCount = xGroup->getCount();
+				for (sal_Int32 nGroupIndex=0; nGroupIndex<nGroupCount; ++nGroupIndex)
+				{
+					uno::Reference<drawing::XShape> xGroupChild (
+						xGroup->getByIndex(nGroupIndex), uno::UNO_QUERY);
+					if (xGroupChild == xShape)
+						return IntelligentGroup::Instance(mxModel, xChild);
+				}
+			}
+		}
+	}
+*/
+	if(IntelligentGroup::IsIntelligentGroup(xShape))
+		return IntelligentGroup::Instance(mxModel, xShape);
+	else 
+		return boost::shared_ptr<IntelligentGroup>();
+}
+
+void SelectionManager::AddSelectionChangeListener(uno::Reference<view::XSelectionChangeListener> xListener)
+{
+	maListeners.push_back(xListener);
+}
+
+void SelectionManager::RemoveSelectionChangeListener(uno::Reference<view::XSelectionChangeListener> xListener)
+{
+	std::vector<uno::Reference<view::XSelectionChangeListener> >::iterator aIter = maListeners.begin();
+	while(aIter!=maListeners.end())
+	{
+		if(*aIter == xListener)
+			maListeners.erase(aIter);
+	}
+}
+
+} //end of namespace sd
diff --git sd/source/ui/ig/TreeLayout.cxx sd/source/ui/ig/TreeLayout.cxx
new file mode 100644
index 0000000..7025d10
--- /dev/null
+++ sd/source/ui/ig/TreeLayout.cxx
@@ -0,0 +1,182 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: TreeLayout.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#include "TreeLayout.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/style/ParagraphAdjust.hpp>
+#include <com/sun/star/drawing/ColorMode.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/drawing/TextFitToSizeType.hpp>
+#include <com/sun/star/text/WritingMode.hpp>
+#include <svtools/colorcfg.hxx>
+
+using namespace ::com::sun::star;
+
+namespace sd{
+
+TreeLayout::TreeLayout(
+	boost::shared_ptr<IntelligentGroupModel> pModel,
+	boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor)
+	:IntelligentGroupLayoutBase(pModel,pDescriptor)
+{
+}
+
+double TreeLayout::GetGap( awt::Rectangle /*aGroupBoundingBox*/ )
+{
+	return 0;
+}
+
+awt::Size TreeLayout::GetBoundingSize (
+	sal_Int32 /*nIndex*/, 
+	awt::Size aDefaultSize, 
+	std::vector<IntelligentGroupShapeDescriptor> /*aDescriptors*/)
+{
+	return aDefaultSize;
+}
+
+std::vector<IntelligentGroupShapeDescriptor> TreeLayout::PrepareShapes (boost::shared_ptr<IntelligentGroupTextIterator> /*pTextIterator*/, sal_Int32 nIndex, bool bCreatedByUser)
+{
+	std::vector<IntelligentGroupShapeDescriptor> aDescriptors;
+
+	IntelligentGroupStyle aStyle;
+
+	aStyle.aBackground = IntelligentGroupStyle::Foreground;
+	aStyle.aBorder = IntelligentGroupStyle::Regular;
+	aStyle.aText = IntelligentGroupStyle::Primary;
+	aDescriptors.push_back(GetShapeDescriptor(
+		rtl::OUString::createFromAscii("Primary")+rtl::OUString::valueOf(nIndex),
+		ig::Primary,
+		aStyle));
+
+	// Every shape except the root at index 0 has a connector to its parent. 
+	if (nIndex > 0)
+	{
+		aStyle.aBackground = IntelligentGroupStyle::None_Background;
+		aStyle.aBorder = IntelligentGroupStyle::None_Border;
+		aStyle.aText = IntelligentGroupStyle::None_Text;
+		aDescriptors.push_back(GetShapeDescriptor(
+			rtl::OUString::createFromAscii("Connector")+rtl::OUString::valueOf(nIndex),
+			ig::Connector,
+			aStyle));
+	}
+
+	if(!bCreatedByUser)
+		mpModel->AddShapeGroup(aDescriptors, mpModel->GetShapeGroupCount());
+
+	return aDescriptors;
+}
+
+//void TreeLayout::PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aShapeDescriptors, 
+void TreeLayout::PlaceShapes(sal_Int32 nShapeGroupIndex, 
+									awt::Rectangle aBoundingBox, 
+									awt::Rectangle /*aGroupBoundingBox*/, 
+									awt::Size /*aDefaultSize*/, 
+									double /*nScale*/)
+{	 
+//	aShapeDescriptors[0].DefaultLocation = awt::Point(
+	IntelligentGroupShapeDescriptor aShapeDescriptor;
+	aShapeDescriptor.DefaultLocation = awt::Point(
+		aBoundingBox.X,
+		aBoundingBox.Y);
+//	aShapeDescriptors[0].DefaultSize = awt::Size(
+	aShapeDescriptor.DefaultSize = awt::Size(
+		aBoundingBox.Width,
+		aBoundingBox.Height);
+//	SetSizeLocation(aShapeDescriptors[0]);
+	sal_Int32 nShapeDescriptorIndex = mpModel->GetShapeDescriptorIndex(nShapeGroupIndex,0);
+	mpModel->SetSizeLocation(nShapeDescriptorIndex, aShapeDescriptor);
+}
+
+uno::Reference<drawing::XShape> TreeLayout::CreateShape(rtl::OUString aIdentifier)
+{
+	uno::Reference<drawing::XShape> xShape = NULL;
+
+	uno::Reference<beans::XPropertySet> xProperties;
+
+	if (aIdentifier.match(rtl::OUString::createFromAscii("Connector")))
+	{
+		xShape = uno::Reference<drawing::XShape>(
+			mpModel->GetShapeFactory()->createInstance(
+			rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.drawing.ConnectorShape"))),
+			uno::UNO_QUERY);
+
+		xProperties = uno::Reference<beans::XPropertySet>(xShape, uno::UNO_QUERY);
+		if(xProperties.is())
+		{
+			// glue point positions: 0=top 1=left 2=bottom 3=right
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("StartGluePointIndex"), uno::makeAny((sal_Int32)2)); 
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("EndGluePointIndex"), uno::makeAny((sal_Int32)0));
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("LineWidth"), uno::makeAny((sal_Int32)100));
+		}
+	}
+	else if (aIdentifier.match(rtl::OUString::createFromAscii("Primary")))
+	{
+		xShape = uno::Reference<drawing::XShape>(
+			mpModel->GetShapeFactory()->createInstance(
+			rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.drawing.TextShape"))),
+			uno::UNO_QUERY);
+
+		xProperties = uno::Reference<beans::XPropertySet>(xShape, uno::UNO_QUERY);
+
+		if (xProperties.is())
+		{
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID));
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("FillColor"), uno::makeAny(sal_Int32(0x9ACD00)));
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("LineWidth"), uno::makeAny((sal_Int32)200));
+			xProperties->setPropertyValue(rtl::OUString::createFromAscii("CornerRadius"), uno::makeAny((sal_Int32)200));
+		}
+	}
+
+	return xShape;
+}
+
+
+rtl::OUString TreeLayout::GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex)
+{
+	return GetShapePrefix(eClass) + rtl::OUString::valueOf(nIndex);
+}
+
+rtl::OUString TreeLayout::GetShapePrefix(ig::ShapeClass eClass)
+{
+	rtl::OUString aShapePrefix;
+	switch (eClass)
+	{
+	case ig::TopLevelText : aShapePrefix = rtl::OUString::createFromAscii("Primary"); break;
+	case ig::SecondLevelText : aShapePrefix = rtl::OUString::createFromAscii("Secondary"); break;
+	case ig::Image: aShapePrefix = rtl::OUString::createFromAscii("Image"); break;
+	}
+	return aShapePrefix;
+}
+
+}// end of namespace sd
\ No newline at end of file
diff --git sd/source/ui/ig/TreeLayoutAlgorithm.cxx sd/source/ui/ig/TreeLayoutAlgorithm.cxx
new file mode 100644
index 0000000..fe9698c
--- /dev/null
+++ sd/source/ui/ig/TreeLayoutAlgorithm.cxx
@@ -0,0 +1,153 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: TreeLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#include "TreeLayoutAlgorithm.hxx"
+#include "IntelligentGroupLayoutBase.hxx"
+#include <math.h>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+namespace sd {
+
+
+TreeLayoutAlgorithm::TreeLayoutAlgorithm()
+{
+
+}
+
+
+TreeLayoutAlgorithm::~TreeLayoutAlgorithm()
+{
+}
+
+
+void TreeLayoutAlgorithm::PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, 
+//									 std::vector<std::vector<IntelligentGroupShapeDescriptor>>& rShapeDescriptorVector, 
+									 boost::shared_ptr<IntelligentGroupModel> pModel,
+									 css::awt::Rectangle aGroupBoundingBox)
+{
+	const sal_Int32 nGroupCount = pModel->GetShapeGroupCount();
+
+	mnLevelCount = (sal_Int32)ceil(log((float)(nGroupCount+1)) / log((float)2.0));
+	const sal_Int32 nMaxHorizontalElementCount = (sal_Int32)pow(2.0, mnLevelCount-1);
+
+	maGroupBoundingBox = aGroupBoundingBox;
+
+	// calculate shape sizes and positions
+	mnShapeWidth = (sal_Int32)(0.8 * maGroupBoundingBox.Width  / nMaxHorizontalElementCount);
+	mnShapeHeight = (sal_Int32)(0.8 * maGroupBoundingBox.Height / mnLevelCount);
+	mnHorizontalSpace = (maGroupBoundingBox.Width- mnShapeWidth*nMaxHorizontalElementCount) / (nMaxHorizontalElementCount-1);
+	mnVerticalSpace = (maGroupBoundingBox.Height - mnShapeHeight*mnLevelCount) / (mnLevelCount-1);
+
+	PlaceSubTree(pLayout, pModel, 0, nGroupCount, NULL, maGroupBoundingBox.X);
+}
+
+
+
+Rectangle TreeLayoutAlgorithm::PlaceSubTree(boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, 
+//								  std::vector<std::vector<IntelligentGroupShapeDescriptor>>& aShapeDescriptors, 
+								  boost::shared_ptr<IntelligentGroupModel> pModel,
+								  sal_Int32 nIndex, 
+								  sal_Int32 nCount, 
+								  css::uno::Reference<css::drawing::XShape> xParent, 
+								  sal_Int32 nLeft)
+{
+	if (nIndex >= nCount)
+		return Rectangle();
+
+	const sal_Int32 nLevel = (sal_Int32)floor(log((float)(nIndex+1)) / log((float)2.0));
+	const sal_Int32 nTotalHeight = mnLevelCount * mnShapeHeight + (mnLevelCount-1)*mnVerticalSpace;
+
+	const sal_Int32 nY = maGroupBoundingBox.Y + (maGroupBoundingBox.Height - nTotalHeight) / 2 + nLevel * (mnShapeHeight+mnVerticalSpace);
+
+	// Create shape for node, size and place it, and add it to the group shape.
+//	IntelligentGroupShapeDescriptor& aDescriptor = aShapeDescriptors[nIndex][0];
+	IntelligentGroupShapeDescriptor aDescriptor = pModel->GetShapeDescriptor(pModel->GetShapeDescriptorIndex(nIndex,0));
+
+	// Create nodes for the two children.
+	Rectangle aBBox = Rectangle(nLeft,nY,mnShapeWidth+nLeft, mnShapeHeight+nY);
+
+	// Place left sub-tree.
+	Rectangle aLeftBBox = PlaceSubTree(
+//		pLayout, aShapeDescriptors, nIndex*2+1, nCount, aDescriptor.Shape, nLeft);
+		pLayout, pModel, nIndex*2+1, nCount, aDescriptor.Shape, nLeft);
+	sal_Int32 nRightLeft;
+	if (!aLeftBBox.IsEmpty())
+	{
+		aBBox.Union(aLeftBBox);
+		nRightLeft = (sal_Int32)aLeftBBox.Right() + mnHorizontalSpace;
+	}
+	else
+		nRightLeft = nLeft;
+
+	// Place right sub-tree.
+	Rectangle aRightBBox = PlaceSubTree(
+//		pLayout, aShapeDescriptors, nIndex*2+2, nCount, aDescriptor.Shape, nRightLeft);
+		pLayout, pModel, nIndex*2+2, nCount, aDescriptor.Shape, nRightLeft);
+	if (!aRightBBox.IsEmpty())
+		aBBox.Union(aRightBBox);
+
+	sal_Int32 nX = (sal_Int32)(aBBox.Right() + aBBox.Left() - mnShapeWidth)/2;
+
+//	pLayout->PlaceShapes(aShapeDescriptors[nIndex],
+	pLayout->PlaceShapes(nIndex,
+		css::awt::Rectangle(
+		nX,
+		nY,
+		mnShapeWidth,
+		mnShapeHeight),
+		maGroupBoundingBox,
+		css::awt::Size(mnShapeWidth, mnShapeHeight),
+		1);
+
+	// Add Connector to children
+	if (nIndex*2+1 < nCount)
+	{
+//		IntelligentGroupShapeDescriptor aConnectorDescriptor = aShapeDescriptors[nIndex*2+1][1];
+		IntelligentGroupShapeDescriptor aConnectorDescriptor = pModel->GetShapeDescriptor(pModel->GetShapeDescriptorIndex(nIndex*2+1,1));
+		css::uno::Reference<css::beans::XPropertySet> xConnectorProps (aConnectorDescriptor.Shape, css::uno::UNO_QUERY);
+		xConnectorProps->setPropertyValue(rtl::OUString::createFromAscii("StartShape"), css::uno::makeAny(aDescriptor.Shape));
+		xConnectorProps->setPropertyValue(rtl::OUString::createFromAscii("EndShape"), css::uno::makeAny(pModel->GetShapeDescriptor(pModel->GetShapeDescriptorIndex(nIndex*2+1,0)).Shape));
+	}
+	if (nIndex*2+2 < nCount)
+	{
+//		IntelligentGroupShapeDescriptor aConnectorDescriptor = aShapeDescriptors[nIndex*2+2][1];
+		IntelligentGroupShapeDescriptor aConnectorDescriptor = pModel->GetShapeDescriptor(pModel->GetShapeDescriptorIndex(nIndex*2+2,1));
+		css::uno::Reference<css::beans::XPropertySet> xConnectorProps (aConnectorDescriptor.Shape, css::uno::UNO_QUERY);
+		xConnectorProps->setPropertyValue(rtl::OUString::createFromAscii("StartShape"), css::uno::makeAny(aDescriptor.Shape));
+		xConnectorProps->setPropertyValue(rtl::OUString::createFromAscii("EndShape"), css::uno::makeAny(pModel->GetShapeDescriptor(pModel->GetShapeDescriptorIndex(nIndex*2+2,0)).Shape));
+	}
+
+	return aBBox;
+}
+
+
+
+}
\ No newline at end of file
diff --git sd/source/ui/ig/makefile.mk sd/source/ui/ig/makefile.mk
new file mode 100644
index 0000000..7eb2c91
--- /dev/null
+++ sd/source/ui/ig/makefile.mk
@@ -0,0 +1,81 @@
+ #*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.0 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PROJECTPCH=sd
+PROJECTPCHSOURCE=$(PRJ)$/util$/sd
+PRJNAME=sd
+TARGET=ig
+ENABLE_EXCEPTIONS=TRUE
+AUTOSEG=true
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+
+# --- Files --------------------------------------------------------
+
+SRS1NAME=$(TARGET)
+SRC1FILES =\
+	IntelligentGroupPane.src
+		
+SLOFILES = \
+		$(SLO)$/IntelligentGroupTextIterator.obj	\
+		$(SLO)$/BulletTextIterator.obj \
+		$(SLO)$/IntelligentGroupBulletList.obj \
+		$(SLO)$/IntelligentGroupShapeAccessor.obj \
+		$(SLO)$/IntelligentGroupModel.obj \
+		$(SLO)$/IntelligentGroupLayoutBase.obj \
+		$(SLO)$/GroupedListLayout.obj \
+		$(SLO)$/ListLayoutAlgorithm.obj \
+		$(SLO)$/HorizontalListLayoutAlgorithm.obj \
+		$(SLO)$/IntelligentGroupController.obj \
+		$(SLO)$/IntelligentGroupText.obj \
+		$(SLO)$/IntelligentGroupLayouter.obj \
+		$(SLO)$/IntelligentGroupLayoutManager.obj \
+		$(SLO)$/IntelligentGroup.obj \
+		$(SLO)$/IntelligentGroupFrame.obj  \
+		$(SLO)$/SelectionManager.obj \
+		$(SLO)$/IntelligentGroupPane.obj \
+		$(SLO)$/PictureAccentListLayout.obj	\
+		$(SLO)$/TreeLayout.obj \
+		$(SLO)$/TreeLayoutAlgorithm.obj \
+		$(SLO)$/FieldLayoutAlgorithm.obj \
+		$(SLO)$/RowFieldLayoutAlgorithm.obj \
+		$(SLO)$/CircleLayoutAlgorithm.obj 
+
+
+# --- Tagets -------------------------------------------------------
+
+.INCLUDE :  target.mk
diff --git sd/source/ui/inc/BulletTextIterator.hxx sd/source/ui/inc/BulletTextIterator.hxx
new file mode 100644
index 0000000..461f5c9
--- /dev/null
+++ sd/source/ui/inc/BulletTextIterator.hxx
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: BulletTextIterator.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_BULLET_TEXT_ITERATOR_HXX
+#define SD_BULLET_TEXT_ITERATOR_HXX
+
+#include "IntelligentGroupTextIterator.hxx"
+#include "IntelligentGroupTextAccess.hxx"
+
+namespace sd
+{
+
+class BulletTextIterator : public IntelligentGroupTextIterator
+{
+public:
+	BulletTextIterator(IntelligentGroupTextAccess* pTextAccess);
+	virtual ~BulletTextIterator();
+	virtual bool Rewind();
+	virtual sal_Int32 GetChildCount();
+	virtual sal_Int32 GetItemCount();
+	virtual rtl::OUString GetText();
+	virtual bool GotoFirstChild();
+	virtual bool GotoNext();
+	virtual bool GotoParent();
+	virtual bool HasChildren();
+	virtual ::boost::shared_ptr<IntelligentGroupTextIterator> GetCopy();
+
+
+private:
+	BulletTextIterator(BulletTextIterator* pIterator);
+
+	IntelligentGroupTextAccess* mpTextAccess;
+};
+
+}//end of namespace sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/CircleLayoutAlgorithm.hxx sd/source/ui/inc/CircleLayoutAlgorithm.hxx
new file mode 100644
index 0000000..68cddc9
--- /dev/null
+++ sd/source/ui/inc/CircleLayoutAlgorithm.hxx
@@ -0,0 +1,57 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: CircleLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_CIRCLE_LAYOUT_ALGORITHM_HXX
+#define SD_CIRCLE_LAYOUT_ALGORITHM_HXX
+
+
+#include "IntelligentGroupAlgorithmBase.hxx"
+
+
+namespace css = ::com::sun::star;
+
+
+namespace sd { 
+
+
+class CircleLayoutAlgorithm : public IntelligentGroupAlgorithmBase
+{
+public:
+	CircleLayoutAlgorithm();
+	virtual ~CircleLayoutAlgorithm();
+//	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, std::vector<std::vector<IntelligentGroupShapeDescriptor>>& rShapeDescriptorVector, const css::awt::Rectangle aGroupBoundingBox );
+	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, boost::shared_ptr<IntelligentGroupModel> pModel, const css::awt::Rectangle aGroupBoundingBox );
+};
+
+
+ } 
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/FieldLayoutAlgorithm.hxx sd/source/ui/inc/FieldLayoutAlgorithm.hxx
new file mode 100644
index 0000000..22e89bd
--- /dev/null
+++ sd/source/ui/inc/FieldLayoutAlgorithm.hxx
@@ -0,0 +1,80 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: FieldLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_FIELD_LAYOUT_ALGORITHM_HXX
+#define SD_FIELD_LAYOUT_ALGORITHM_HXX
+
+
+#include "IntelligentGroupAlgorithmBase.hxx"
+
+
+namespace css = ::com::sun::star;
+
+
+namespace sd { 
+
+
+class FieldLayoutAlgorithm : public IntelligentGroupAlgorithmBase
+{
+public:
+	FieldLayoutAlgorithm( const ig::Orientation eOrientation );
+	virtual ~FieldLayoutAlgorithm();
+//	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, std::vector<std::vector<IntelligentGroupShapeDescriptor>>& rShapeDescriptorVector, const css::awt::Rectangle aGroupBoundingBox );
+	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, boost::shared_ptr<IntelligentGroupModel> pModel, const css::awt::Rectangle aGroupBoundingBox );
+
+
+protected:
+	css::awt::Point CreatePosition( const sal_Int32 nPositionOnPrimaryAxis, const sal_Int32 nPositionOnSecondaryAxis );
+	sal_Int32 Project( const sal_Int32 nFirst, const sal_Int32 nSecond, const bool bProjectToPrimaryAxis );
+	css::awt::Size CreateSize( const sal_Int32 nSizeOnPrimaryAxis, const sal_Int32 nSizeOnSecondaryAxis );
+
+private:
+	class Line;
+	ig::Orientation meOrientation;
+
+	std::vector<FieldLayoutAlgorithm::Line> ReflowLines(const std::vector<Line> aLines, double nMaximalWidth, sal_Int32 nGap);
+	double CalculateNewWidth (std::vector<FieldLayoutAlgorithm::Line> aLines);
+	double CalculateAspectRatio (
+		const std::vector<FieldLayoutAlgorithm::Line> aLines,
+		const sal_Int32 nGap,
+		const css::awt::Rectangle aBoundingBox);
+	double CalculateScale (
+		const std::vector<FieldLayoutAlgorithm::Line> aLines,
+		const sal_Int32 nGap,
+		const css::awt::Rectangle aBoundingBox);
+	css::awt::Size CalculateTotalSize (const std::vector<FieldLayoutAlgorithm::Line> aLines);
+	css::awt::Size CalculateTotalGapSize (const std::vector<FieldLayoutAlgorithm::Line> aLines, const sal_Int32 nGap);
+};
+
+
+ }
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/GroupedListLayout.hxx sd/source/ui/inc/GroupedListLayout.hxx
new file mode 100644
index 0000000..ede0b34
--- /dev/null
+++ sd/source/ui/inc/GroupedListLayout.hxx
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: GroupedListLayout.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_GROUPED_LIST_LAYOUT_HXX
+#define SD_GROUPED_LIST_LAYOUT_HXX
+
+#include "IntelligentGroupLayoutBase.hxx"
+
+namespace css = ::com::sun::star;
+
+namespace sd{
+
+	class GroupedListLayout: public IntelligentGroupLayoutBase
+	{
+	public:
+		GroupedListLayout(boost::shared_ptr<IntelligentGroupModel> pModel,
+			boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+		double GetGap(css::awt::Rectangle aGroupBoundingBox);
+		css::awt::Size GetBoundingSize(sal_Int32 nIndex, css::awt::Size aDefaultSize, std::vector<IntelligentGroupShapeDescriptor> aDescriptos);
+		std::vector<IntelligentGroupShapeDescriptor> PrepareShapes(boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator, sal_Int32 nIndex, bool bCreatedByUser = false);
+//		void PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aDescriptors, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale);
+		void PlaceShapes(sal_Int32 nShapeGroupIndex, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale);
+		css::uno::Reference<css::drawing::XShape> CreateShape(rtl::OUString aIdentifier);
+		void AddShape(css::uno::Reference<css::drawing::XShape> rxSelectedShape);
+
+
+	private:
+		virtual rtl::OUString GetShapePrefix(ig::ShapeClass eClass);
+		virtual rtl::OUString GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex);
+		virtual rtl::OUString GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex, sal_Int32 nChildIndex);
+		virtual ig::ShapeClass GetClassForName(rtl::OUString sIdentifier);
+	};
+
+
+
+} //end of nameclass sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/HorizontalListLayoutAlgorithm.hxx sd/source/ui/inc/HorizontalListLayoutAlgorithm.hxx
new file mode 100644
index 0000000..8c0c912
--- /dev/null
+++ sd/source/ui/inc/HorizontalListLayoutAlgorithm.hxx
@@ -0,0 +1,50 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: HorizontalListLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_HORIZONTALLISTLAYOUTALGORITHM_HXX
+#define SD_HORIZONTALLISTLAYOUTALGORITHM_HXX
+
+
+#include "ListLayoutAlgorithm.hxx"
+
+
+namespace sd { 
+
+class HorizontalListLayoutAlgorithm : public ListLayoutAlgorithm
+{
+public:
+	HorizontalListLayoutAlgorithm();
+	~HorizontalListLayoutAlgorithm();
+};
+
+} // end of namespace ::sd::intelligentgroup
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroup.hxx sd/source/ui/inc/IntelligentGroup.hxx
new file mode 100644
index 0000000..d8ef20b
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroup.hxx
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroup.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_HXX
+#define SD_INTELLIGENT_GROUP_HXX
+
+#include <com/sun/star/frame/XController.hpp>
+#include "IntelligentGroupLayouter.hxx"
+#include <boost/shared_ptr.hpp>
+
+
+namespace sd{
+
+	class IntelligentGroup
+	{
+	public:
+		static bool IsIntelligentGroup( ::com::sun::star::uno::Reference< com::sun::star::drawing::XShape > xShape );
+		static boost::shared_ptr<IntelligentGroup> Instance(
+			::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > rxModel,
+			::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxShape);
+		static void Dispose();
+		boost::shared_ptr<IntelligentGroupModel> GetModel();
+		void SetLayout(::rtl::OUString sLayoutName);
+		void SetText(boost::shared_ptr<IntelligentGroupText> pText);
+		void UpdateLayout();
+		boost::shared_ptr<IntelligentGroupLayouter> GetLayouter();
+		boost::shared_ptr<IntelligentGroupLayoutBase> GetLayout();
+		void AddShape(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxSelectedShape);
+		
+	private:
+		IntelligentGroup(::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > xModel, 
+			::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxShape);
+		
+	private:
+		boost::shared_ptr<IntelligentGroupModel> mpModel;
+		boost::shared_ptr<IntelligentGroupLayoutBase> mpLayout;
+		boost::shared_ptr<IntelligentGroupLayouter> mpLayouter; 
+		boost::shared_ptr<IntelligentGroupText> mpText;
+		rtl::OUString msLayoutName;
+		
+		typedef std::vector<boost::shared_ptr<IntelligentGroup> > IntelligentGroupVector;
+		static IntelligentGroupVector maActiveGroup;
+	};
+
+}//end of namespace sd
+
+#endif
diff --git sd/source/ui/inc/IntelligentGroupAlgorithmBase.hxx sd/source/ui/inc/IntelligentGroupAlgorithmBase.hxx
new file mode 100644
index 0000000..64f7aac
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupAlgorithmBase.hxx
@@ -0,0 +1,55 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: IntelligentGroupAlgorithmBase.hxx,v $
+*
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_ALGORITHM_BASE_HXX
+#define SD_INTELLIGENT_GROUP_ALGORITHM_BASE_HXX
+
+#include "IntelligentGroupDescriptors.hxx"
+#include "IntelligentGroupLayoutBase.hxx"
+
+namespace css = ::com::sun::star;
+
+
+namespace sd { 
+
+
+class IntelligentGroupAlgorithmBase
+{
+public:
+	IntelligentGroupAlgorithmBase(){};
+	virtual ~IntelligentGroupAlgorithmBase(){};
+	virtual void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, boost::shared_ptr<IntelligentGroupModel> pModel, const css::awt::Rectangle aGroupBoundingBox ) = 0;
+};
+
+
+ } // end of namespace 
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupBulletList.hxx sd/source/ui/inc/IntelligentGroupBulletList.hxx
new file mode 100644
index 0000000..64d433a
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupBulletList.hxx
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupBulletList.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_INTELLIGENT_GROUP_BULLET_LIST_HXX
+#define SD_INTELLIGENT_GROUP_BULLET_LIST_HXX
+
+#include "IntelligentGroupTextAccess.hxx"
+#include "IntelligentGroupTextIterator.hxx"
+
+namespace sd
+{
+
+class IntelligentGroupController;
+
+class IntelligentGroupBulletList : public IntelligentGroupTextAccess
+{
+public:
+
+	IntelligentGroupBulletList();
+	virtual ~IntelligentGroupBulletList();
+	boost::shared_ptr< IntelligentGroupTextIterator > CreateIterator();
+	void SetText(const std::vector< rtl::OUString >& aText);
+	void AddText(const sal_Int32 nDepth, const ::rtl::OUString& rShapeText);
+
+	sal_Int32 GetDepth(const sal_Int32 nIndex);
+	sal_Int32 GetItemCount();
+	::rtl::OUString GetText(sal_Int32 nItemIndex, sal_Int32 nDepth);
+	void Clear();
+
+private:
+	sal_Int32 GetIndentation(const ::rtl::OUString& rText);
+
+	rtl::OUString msIndentationString;
+	std::vector<rtl::OUString> maTextVector;
+};
+
+}//end of namespace sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupController.hxx sd/source/ui/inc/IntelligentGroupController.hxx
new file mode 100644
index 0000000..7298a2e
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupController.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupText.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_CONTROLLER_HXX
+#define SD_INTELLIGENT_GROUP_CONTROLLER_HXX
+
+#include "ViewShellBase.hxx"
+
+namespace sd{
+
+	class IntelligentGroupController//: public cppu::WeakImplHelper1<::com::sun::star::view::XSelectionChangeListener>, public ::com::sun::star::beans::XPropertyChangeListener 
+	{
+	public:
+		IntelligentGroupController(
+			com::sun::star::uno::Reference< com::sun::star::frame::XModel > rxModel,
+			com::sun::star::uno::Reference< com::sun::star::frame::XController > rxController,
+			ViewShellBase& rBase);
+		virtual ~IntelligentGroupController();
+		void SetLayout(rtl::OUString sLayoutName, bool bCreate);
+		void DoLayout();
+		boost::shared_ptr<IntelligentGroup> GetSelectedIntelligentGroup();
+//		boost::shared_ptr< SelectionManager > GetSelectionManager();
+
+	private:
+		boost::shared_ptr<IntelligentGroup> CreateIntelligentGroup();
+
+	private:
+		com::sun::star::uno::Reference< com::sun::star::frame::XModel > mxModel;
+		com::sun::star::uno::Reference< com::sun::star::frame::XController > mxController;
+		boost::shared_ptr<SelectionManager> mpSelectionManager;
+	};
+
+}//end of namespace sd
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupDescriptors.hxx sd/source/ui/inc/IntelligentGroupDescriptors.hxx
new file mode 100644
index 0000000..443a94b
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupDescriptors.hxx
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupDescriptors.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+
+#ifndef SD_INTELLIGENT_GROUP_DESCRIPTORS_HXX
+#define SD_INTELLIGENT_GROUP_DESCRIPTORS_HXX
+
+#include <vcl/image.hxx>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <boost/shared_ptr.hpp>
+
+
+namespace sd{ namespace ig{
+
+		enum ShapeRole{ Primary, Accent, Connector, Other, User };
+		enum ShapeClass { TopLevelText, SecondLevelText, Image };
+		enum Orientation { Horizontal, Vertical };
+}
+struct IntelligentGroupLayoutDescriptor
+{
+	rtl::OUString Category;
+	rtl::OUString Name;
+	rtl::OUString DisplayName;
+	rtl::OUString Description;
+	Image Icon;
+	Image Colorable;
+	Image Preview;
+	rtl::OUString LayoutServiceName;
+	rtl::OUString LayoutAlgorithmServiceName;
+	USHORT MinimalShapeCount;
+	USHORT MaximalShapeCount;
+};
+
+struct IntelligentGroupStyle
+{
+	enum StyleBackground { None_Background, Background, Foreground, Accent };
+	enum Border { None_Border, Regular };
+	enum Text { None_Text, Primary, Secondary };
+
+	StyleBackground aBackground;
+	Border aBorder;
+	Text aText;
+	rtl::OUString GetDisplayName(void);
+};
+
+struct IntelligentGroupShapeDescriptor
+{
+	rtl::OUString Identifier;
+	ig::ShapeRole Role;
+	IntelligentGroupStyle Style;
+	bool Exists;
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > Shape;
+	::com::sun::star::awt::Point DefaultLocation;
+	::com::sun::star::awt::Size DefaultSize;
+	::com::sun::star::awt::Point ShapeLocation;
+	::com::sun::star::awt::Size ShapeSize; 
+	::com::sun::star::awt::Size SizeTransformation;
+	::com::sun::star::awt::Point LocationTransformation;
+};
+
+struct GroupedListDescriptor
+{
+	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> Get()
+	{
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+		pLayoutDescriptor->Category = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Horizontal List"));
+		pLayoutDescriptor->Description = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Horizontal grouped list"));
+		pLayoutDescriptor->DisplayName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Grouped List"));
+		pLayoutDescriptor->LayoutServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedListLayout"));
+		pLayoutDescriptor->LayoutAlgorithmServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("HorizontalListLayoutAlgorithm"));
+		pLayoutDescriptor->MaximalShapeCount = 0;
+		pLayoutDescriptor->MinimalShapeCount = 1;
+		pLayoutDescriptor->Name = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedList"));
+		return pLayoutDescriptor;
+	}
+//	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor;
+};
+//boost::shared_ptr<IntelligentGroupLayoutDescriptor> GroupedListDescriptor::pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+
+struct CircleLayoutDescriptor 
+{
+	static  boost::shared_ptr<IntelligentGroupLayoutDescriptor> Get()
+	{
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+		pLayoutDescriptor->Category = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Primary Circle"));
+		pLayoutDescriptor->Description = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Basic circular layout"));
+		pLayoutDescriptor->DisplayName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Base Circle"));
+		pLayoutDescriptor->LayoutServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedListLayout"));
+		pLayoutDescriptor->LayoutAlgorithmServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("CircleLayoutAlgorithm"));
+		pLayoutDescriptor->MaximalShapeCount = 0;
+		pLayoutDescriptor->MinimalShapeCount = 1;
+		pLayoutDescriptor->Name = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("BaseCircle"));
+		return pLayoutDescriptor;
+	}
+//	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor;
+};
+//boost::shared_ptr<IntelligentGroupLayoutDescriptor> CircleLayoutDescriptor::pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+
+struct SimpleFieldDescriptor
+{
+	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> Get()
+	{
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+		pLayoutDescriptor->Category = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Field"));
+		pLayoutDescriptor->Description = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Row first field"));
+		pLayoutDescriptor->DisplayName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Simple Field"));
+		pLayoutDescriptor->LayoutServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedListLayout"));
+		pLayoutDescriptor->LayoutAlgorithmServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("RowFieldLayoutAlgorithm"));
+		pLayoutDescriptor->MaximalShapeCount = 0;
+		pLayoutDescriptor->MinimalShapeCount = 1;
+		pLayoutDescriptor->Name = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("SimpleField"));
+		return pLayoutDescriptor;
+	}
+//	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor;
+};
+//boost::shared_ptr<IntelligentGroupLayoutDescriptor> SimpleFieldDescriptor::pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+
+
+struct TreeDescriptor
+{
+	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> Get()
+	{
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+		pLayoutDescriptor->Category = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Tree"));
+		pLayoutDescriptor->Description = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Binary tree layout"));
+		pLayoutDescriptor->DisplayName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Tree"));
+		pLayoutDescriptor->LayoutServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("TreeLayout"));
+		pLayoutDescriptor->LayoutAlgorithmServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("TreeLayoutAlgorithm"));
+		pLayoutDescriptor->MaximalShapeCount = 0;
+		pLayoutDescriptor->MinimalShapeCount = 1;
+		pLayoutDescriptor->Name = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Tree"));
+		return pLayoutDescriptor;
+	}
+//	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor;
+};
+//boost::shared_ptr<IntelligentGroupLayoutDescriptor> TreeDescriptor::pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+
+
+struct PictureAccentListDescriptor
+{
+	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> Get()
+	{
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+		pLayoutDescriptor->Category = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Horizontal List"));
+		pLayoutDescriptor->Description = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Horizontal list with image accents"));
+		pLayoutDescriptor->DisplayName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Picture Accent List"));
+		pLayoutDescriptor->LayoutServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PictureAccentListLayout"));
+		pLayoutDescriptor->LayoutAlgorithmServiceName = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("HorizontalListLayoutAlgorithm"));
+		pLayoutDescriptor->MaximalShapeCount = 0;
+		pLayoutDescriptor->MinimalShapeCount = 1;
+		pLayoutDescriptor->Name = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PictureAccentList"));
+		return pLayoutDescriptor;
+	}
+//	static boost::shared_ptr<IntelligentGroupLayoutDescriptor> pLayoutDescriptor;
+};
+//boost::shared_ptr<IntelligentGroupLayoutDescriptor> PictureAccentListDescriptor::pLayoutDescriptor(new IntelligentGroupLayoutDescriptor);
+
+
+}//end of namespace sd
+
+#endif
diff --git sd/source/ui/inc/IntelligentGroupFrame.hxx sd/source/ui/inc/IntelligentGroupFrame.hxx
new file mode 100644
index 0000000..20484e5
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupFrame.hxx
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupFrame.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "precompiled_sd.hxx"
+
+#ifndef SD_INTELLIGENT_GROUP_FRAME_HXX
+#define SD_INTELLIGENT_GROUP_FRAME_HXX
+
+#include <com/sun/star/util/XChangesListener.hpp>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include "smarttag.hxx"
+#include "IntelligentGroupModel.hxx"
+#include "IntelligentGroupLayouter.hxx"
+
+class SdrPathObj;
+
+namespace sd {
+
+	class View;
+	class SmartTag;
+	/*************************************************************************
+	|*
+	|* Basisklasse fuer alle Funktionen
+	|*
+	\************************************************************************/
+
+	class IntelligentGroupFrame : public SmartTag, public IPolyPolygonEditorController, public SfxListener, public ::com::sun::star::util::XChangesListener
+	{
+	public:
+		IntelligentGroupFrame( boost::shared_ptr<IntelligentGroupModel> pModel, ::sd::View& rView );
+		
+		virtual ~IntelligentGroupFrame();
+
+		SdrPathObj* getPathObj() const { return mpPathObj; }
+		boost::shared_ptr<IntelligentGroupLayouter> GetLayouter();
+		boost::shared_ptr<IntelligentGroupModel> GetModel();
+
+		/** returns true if the SmartTag handled the event. */
+		virtual bool MouseButtonDown( const MouseEvent&, SmartHdl& );
+
+		/** returns true if the SmartTag consumes this event. */
+		virtual bool KeyInput( const KeyEvent& rKEvt );
+
+		void SetLayouter(boost::shared_ptr<IntelligentGroupLayouter> pLayouter);
+		// callbacks from sdr view
+		virtual ULONG GetMarkablePointCount() const;
+		virtual ULONG GetMarkedPointCount() const;
+		virtual BOOL MarkPoint(SdrHdl& rHdl, BOOL bUnmark=FALSE);
+		virtual void CheckPossibilities();
+		virtual BOOL MarkPoints(const Rectangle* pRect, BOOL bUnmark);
+
+		// IPolyPolygonEditorController
+		virtual void DeleteMarkedPoints();
+		virtual BOOL IsDeleteMarkedPointsPossible() const;
+
+		virtual	void RipUpAtMarkedPoints();
+		virtual bool IsRipUpAtMarkedPointsPossible() const;
+
+		virtual BOOL IsSetMarkedSegmentsKindPossible() const;
+		virtual SdrPathSegmentKind GetMarkedSegmentsKind() const;
+		virtual void SetMarkedSegmentsKind(SdrPathSegmentKind eKind);
+
+		virtual BOOL IsSetMarkedPointsSmoothPossible() const;
+		virtual SdrPathSmoothKind GetMarkedPointsSmooth() const;
+		virtual void SetMarkedPointsSmooth(SdrPathSmoothKind eKind);
+
+		virtual void CloseMarkedObjects(BOOL bToggle, BOOL bOpen );
+		virtual bool IsOpenCloseMarkedObjectsPossible() const;
+		virtual SdrObjClosedKind GetMarkedObjectsClosedState() const;
+
+		void MovePath( int nDX, int nDY );
+		bool OnDelete();
+		bool OnTabHandles( const KeyEvent& rKEvt );
+		bool OnMarkHandle( const KeyEvent& rKEvt );
+		bool OnMove( const KeyEvent& rKEvt );
+
+		// XChangesListener
+		virtual void SAL_CALL changesOccurred( const ::com::sun::star::util::ChangesEvent& Event ) throw (::com::sun::star::uno::RuntimeException);
+		virtual void SAL_CALL disposing( const ::com::sun::star::lang::EventObject& Source ) throw (::com::sun::star::uno::RuntimeException);
+		virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type& aType ) throw (::com::sun::star::uno::RuntimeException);
+		virtual void SAL_CALL acquire(  ) throw ();
+		virtual void SAL_CALL release(  ) throw ();
+
+	protected:
+		virtual void addCustomHandles( SdrHdlList& rHandlerList );
+		virtual bool getContext( SdrViewContext& rContext );
+		virtual void disposing();
+		virtual void deselect();
+
+//		void updatePathAttributes();
+
+	private:
+
+		boost::shared_ptr<IntelligentGroupModel> mpModel;
+		boost::shared_ptr<IntelligentGroupLayouter> mpLayouter;
+		SdrPathObj* mpPathObj;
+		::com::sun::star::awt::Point maOriginPos;
+		SdrMark* mpMark;
+	};
+
+}//end of namespace sd
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupLayoutBase.hxx sd/source/ui/inc/IntelligentGroupLayoutBase.hxx
new file mode 100644
index 0000000..6be9862
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupLayoutBase.hxx
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupLayoutBase.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_INTELLIGENT_GROUP_LAYOUT_BASE_HXX
+#define SD_INTELLIGENT_GROUP_LAYOUT_BASE_HXX
+
+#include "IntelligentGroupModel.hxx"
+#include "IntelligentGroupTextIterator.hxx"
+
+namespace css = ::com::sun::star;
+
+namespace sd{
+
+	class IntelligentGroupLayoutBase
+	{
+	public:
+		IntelligentGroupLayoutBase(boost::shared_ptr<IntelligentGroupModel> pModel,
+			boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+		virtual ~IntelligentGroupLayoutBase();
+		virtual boost::shared_ptr<IntelligentGroupLayoutDescriptor> GetLayoutDescriptor(void);
+		virtual IntelligentGroupShapeDescriptor GetShapeDescriptor(
+			const rtl::OUString sShapeIdentifier,
+			const ig::ShapeRole eRole,
+			const IntelligentGroupStyle aStyle);
+		virtual css::uno::Reference<css::drawing::XShape> CreateShape(rtl::OUString aIdentifier) = 0;
+		virtual rtl::OUString GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex) = 0;
+		virtual double GetGap(css::awt::Rectangle aGroupBoundingBox) = 0;
+		virtual css::awt::Size GetBoundingSize(sal_Int32 nIndex, css::awt::Size aDefaultSize, std::vector<IntelligentGroupShapeDescriptor> aDescriptos) = 0;
+		virtual std::vector<IntelligentGroupShapeDescriptor> PrepareShapes(boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator, sal_Int32 nIndex, bool bCreatedByUser = false) = 0;
+//		virtual void PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aDescriptors, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale) = 0;
+		virtual void PlaceShapes(sal_Int32 nShapeGroupIndex, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale) = 0;
+		virtual void AddShape(css::uno::Reference<css::drawing::XShape> rxSelectedShape);
+
+	protected:
+		virtual void MoveShapeIntoGroupBoundingBox(IntelligentGroupShapeDescriptor& aDescriptor,
+			css::awt::Rectangle aRectangle);
+		virtual void SetSizeLocation(IntelligentGroupShapeDescriptor& aDescriptor);
+		virtual bool IsGeometryModified(const IntelligentGroupShapeDescriptor& aDescriptor);
+
+	protected:
+		boost::shared_ptr<IntelligentGroupModel> mpModel;
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> mpLayoutDescriptor;
+	};
+}
+
+#endif //SD_LAYOUT_BASE_HXX
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupLayoutManager.hxx sd/source/ui/inc/IntelligentGroupLayoutManager.hxx
new file mode 100644
index 0000000..b8ac86c
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupLayoutManager.hxx
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupLayoutManager.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_LAYOUT_MANAGER_HXX
+#define SD_INTELLIGENT_GROUP_LAYOUT_MANAGER_HXX
+
+#include "IntelligentGroupAlgorithmBase.hxx"
+#include "IntelligentGroupLayouter.hxx"
+#include <hash_map>
+
+
+namespace sd{
+
+	class IntelligentGroupLayoutManager
+	{
+	public:
+		static const ::rtl::OUString msGroupedListLayout;
+		static const ::rtl::OUString msPictureAccentListLayout;
+		static const ::rtl::OUString msTreeLayout;
+
+		static const ::rtl::OUString msCircleLayoutAlgorithm;
+		static const ::rtl::OUString msHorizontalListLayoutAlgorithm;
+		static const ::rtl::OUString msRowFieldLayoutAlgorithm;
+		static const ::rtl::OUString msTreeLayoutAlgorithm;
+		static boost::shared_ptr<IntelligentGroupLayoutManager> Instance();
+		boost::shared_ptr<IntelligentGroupLayoutDescriptor> GetLayoutDescriptor(const rtl::OUString& sLayoutName);
+		boost::shared_ptr<IntelligentGroupLayoutBase> GetLayout(const rtl::OUString& sLayoutName, boost::shared_ptr<IntelligentGroupModel> pModel);
+		boost::shared_ptr<IntelligentGroupLayouter> GetLayouter(boost::shared_ptr<IntelligentGroupModel> pModel, boost::shared_ptr<IntelligentGroupLayoutBase> pLayout);
+		void AddLayout(boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+
+	private:
+		IntelligentGroupLayoutManager();
+		boost::shared_ptr<IntelligentGroupLayoutBase> CreateLayout(boost::shared_ptr<IntelligentGroupModel> pModel, const rtl::OUString& sLayoutName);
+		boost::shared_ptr<IntelligentGroupLayoutBase> CreateLayout(boost::shared_ptr<IntelligentGroupModel> pModel, boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+		boost::shared_ptr<IntelligentGroupAlgorithmBase> CreateLayoutAlgorithm(boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+
+	private:
+		typedef std::hash_map<rtl::OUString,std::vector<rtl::OUString>,rtl::OUStringHash,std::equal_to<rtl::OUString> > Categories;
+		Categories maCategories;
+		typedef std::hash_map<rtl::OUString,boost::shared_ptr<IntelligentGroupLayoutDescriptor>,rtl::OUStringHash,std::equal_to<rtl::OUString> > LayoutDescriptors;
+		LayoutDescriptors maLayoutDescriptors;
+		static boost::shared_ptr<IntelligentGroupLayoutManager> mpInstance;
+	};
+}//end of namespace sd
+
+#endif
diff --git sd/source/ui/inc/IntelligentGroupLayouter.hxx sd/source/ui/inc/IntelligentGroupLayouter.hxx
new file mode 100644
index 0000000..cdedf60
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupLayouter.hxx
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupLayouter.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_LAYOUTER_HXX
+#define SD_INTELLIGENT_GROUP_LAYOUTER_HXX
+
+#include "IntelligentGroupAlgorithmBase.hxx"
+#include "IntelligentGroupText.hxx"
+
+
+namespace sd{
+
+	class IntelligentGroupLayouter
+	{
+	public:
+		IntelligentGroupLayouter(
+			boost::shared_ptr<IntelligentGroupModel> pModel, 
+			boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, 
+			boost::shared_ptr<IntelligentGroupAlgorithmBase> pAlgorithm);
+		~IntelligentGroupLayouter();
+		inline boost::shared_ptr<IntelligentGroupLayoutBase> GetLayout(void) { return mpLayout; }
+		inline boost::shared_ptr<IntelligentGroupModel> GetModel(void){ return mpModel; }
+		inline std::vector<std::vector<IntelligentGroupShapeDescriptor> >& GetShapeDescriptors(){ return mpModel->GetShapeDescriptors(); }
+		inline boost::shared_ptr<IntelligentGroupAlgorithmBase> GetLayoutAlgorithm(){ return mpAlgorithm; }
+		void DoLayout(boost::shared_ptr<IntelligentGroupText> pText);
+//		std::vector<std::vector<IntelligentGroupShapeDescriptor> > PrepareShapes(boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator);
+		void PrepareShapes(boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator);
+		void AddShape(const IntelligentGroupShapeDescriptor& rShapeDescriptor);
+//		void UpdateText(boost::shared_ptr<IntelligentGroupText> pText);
+
+
+//	protected:
+//		std::vector<std::vector<IntelligentGroupShapeDescriptor> > maShapeDescriptors;
+
+	private:
+/*		void UpdateOutlineText(const css::uno::Reference<css::drawing::XShape> xShape,
+			boost::shared_ptr<IntelligentGroupFlatTextIterator> pTextIterator,
+			const sal_Int32 nIndentationOffset);
+		void IntelligentGroupLayouter::UpdateText(
+			const uno::Reference<drawing::XShape> xShape,
+			const ::rtl::OUString sText);
+*/
+		boost::shared_ptr<IntelligentGroupModel> mpModel;
+		boost::shared_ptr<IntelligentGroupLayoutBase> mpLayout;
+		boost::shared_ptr<IntelligentGroupAlgorithmBase> mpAlgorithm;
+		boost::shared_ptr<IntelligentGroupTextIterator> mpTextIterator;
+	};
+
+}//end of namespace sd
+
+#endif
diff --git sd/source/ui/inc/IntelligentGroupModel.hxx sd/source/ui/inc/IntelligentGroupModel.hxx
new file mode 100644
index 0000000..a8833c5
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupModel.hxx
@@ -0,0 +1,103 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupModel.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_MODEL_HXX
+#define SD_INTELLIGENT_GROUP_MODEL_HXX
+
+#include <hash_map>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/drawing/XShapes.hpp>
+
+#include"IntelligentGroupDescriptors.hxx"
+
+namespace sd{
+
+class IntelligentGroupModel
+{
+public:
+	IntelligentGroupModel(
+		::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > xModel,
+		::com::sun::star::awt::Rectangle aBoudingBox);
+//	IntelligentGroupModel();
+	~IntelligentGroupModel();
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes > GetGroupShape(void);
+//	void AddShape(rtl::OUString rIdentifier,
+//		ig::ShapeRole rRole,
+//		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape);
+//	void RemoveShape(rtl::OUString rIdentifier);
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > GetShape(rtl::OUString rIdentifier);
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > GetShape(sal_Int32 nIndex);
+	rtl::OUString GetShapeIdentifier(sal_Int32 nIndex);
+	sal_Int32 GetShapeCount(void);
+	void SetupShapeList(void);
+	void SetSize(::com::sun::star::awt::Size rSize);
+	::com::sun::star::awt::Size GetSize(void);
+	void SetLocation(::com::sun::star::awt::Point rLocation);
+	::com::sun::star::awt::Point GetLocation(void);
+	::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > GetShapeFactory();
+	void UpdateSizeAndLocation();
+//	void RemoveUnusedShapes(rtl::OUString rUsedShapes[]);
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > GetUnoModel();
+	bool IsInModel(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape);
+	IntelligentGroupShapeDescriptor GetShapeDescriptor(sal_Int32 nIndex);
+	void RemoveShape(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxShape);
+	void AddShapeGroup(const std::vector<IntelligentGroupShapeDescriptor>& aShapeDescriptorVector, sal_Int32 nIndex);
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> >& GetShapeDescriptors();
+	sal_Int32 GetShapeGroupIndex(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxShape);
+	sal_Int32 GetShapeDescriptorIndex(sal_Int32 nShapeGroupIndex, sal_Int32 nInnerIndex);
+	void SetSizeLocation(sal_Int32 nShapeDescriptorIndex, IntelligentGroupShapeDescriptor aShapeDescriptor);
+	sal_Int32 GetGroupShapeCount(sal_Int32 nShapeGroupIndex);
+	void MoveShapeIntoGroupBoundingBox(sal_Int32 nShapeIndex,::com::sun::star::awt::Rectangle aGroupBoundingBox);
+	void AddShapeDescriptor(sal_Int32 nIndex, IntelligentGroupShapeDescriptor aShapeDescriptor);
+	sal_Int32 GetShapeIndex(::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > rxShape);
+	sal_Int32 GetShapeGroupCount();
+	std::vector<IntelligentGroupShapeDescriptor> GetShapeDescriptorVector(sal_Int32 nGroupIndex);
+	bool RequestUndo();
+
+protected:
+	typedef std::hash_map<rtl::OUString,IntelligentGroupShapeDescriptor,rtl::OUStringHash,std::equal_to<rtl::OUString> > DescriptorInfo;
+	DescriptorInfo maContentShapeMap;
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> > maContentShapeGroups;
+	std::vector< IntelligentGroupShapeDescriptor > maDisposedShapes;
+	typedef std::hash_map<rtl::OUString,sal_Int32,rtl::OUStringHash,std::equal_to<rtl::OUString> > IndexInfo;
+	IndexInfo maDisposedShapeMap;
+	::com::sun::star::awt::Size maSize;
+	::com::sun::star::awt::Point maLocation;
+
+private:
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes > mxGroup;
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > mxModel;
+};
+
+}//end of namespace sd
+
+#endif //SD_INTELLIGENT_GROUP_MODEL_HXX
diff --git sd/source/ui/inc/IntelligentGroupShapeAccessor.hxx sd/source/ui/inc/IntelligentGroupShapeAccessor.hxx
new file mode 100644
index 0000000..0f2f2db
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupShapeAccessor.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupShapeAccessor.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+
+#ifndef SD_INTELLIGENT_GROUP_SHAPE_ACCESSOR_HXX
+#define SD_INTELLIGENT_GROUP_SHAPE_ACCESSOR_HXX
+
+#include "IntelligentGroupModel.hxx"
+
+namespace css = ::com::sun::star;
+
+namespace sd{
+
+class IntelligentGroupShapeAccessor
+{
+public:
+	IntelligentGroupShapeAccessor(
+		boost::shared_ptr<IntelligentGroupModel> pModel,
+		std::vector<std::vector<IntelligentGroupShapeDescriptor> > rShapeDescriptors);
+	virtual ~IntelligentGroupShapeAccessor();
+	virtual css::uno::Reference<css::drawing::XShape> GetShape(std::vector<sal_Int32> aPath) ;
+	virtual bool IsOutliner(std::vector<sal_Int32> /*aPath*/);
+	virtual sal_Int32 GetShapeCount(std::vector<sal_Int32> /*aPath*/) ; 
+	virtual sal_Int32 GetChildCount(std::vector<sal_Int32> /*aPath*/) ;
+
+protected:
+	boost::shared_ptr<IntelligentGroupModel> mpModel;
+	std::vector<std::vector<IntelligentGroupShapeDescriptor> > maShapeDescriptors;
+};
+
+}//end of namespace sd
+
+#endif 
diff --git sd/source/ui/inc/IntelligentGroupText.hxx sd/source/ui/inc/IntelligentGroupText.hxx
new file mode 100644
index 0000000..c46cb0f
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupText.hxx
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupText.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_INTELLIGENT_GROUP_TEXT_HXX
+#define SD_INTELLIGENT_GROUP_TEXT_HXX
+
+#include "IntelligentGroupTextIterator.hxx"
+#include "IntelligentGroupBulletList.hxx"
+
+
+namespace sd{
+
+	class IntelligentGroupText
+	{
+	public:
+		IntelligentGroupText(bool bIsUpdateFromShapeAllowed);
+//		void UpdateList (boost::shared_ptr< IntelligentGroup > pGroup);
+		boost::shared_ptr< IntelligentGroupTextIterator > CreateIterator();
+
+	private:
+		void Layout ();
+		void Initialize1 ();
+		void Initialize2 ();
+		void Initialize3 ();
+
+		bool mbIsUpdateFromShapeAllowed;
+		boost::shared_ptr< IntelligentGroupBulletList > mpText;
+	};
+
+}//end of namespace sd
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupTextAccess.hxx sd/source/ui/inc/IntelligentGroupTextAccess.hxx
new file mode 100644
index 0000000..efdd7e1
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupTextAccess.hxx
@@ -0,0 +1,50 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupTextAccess.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_INTELLIGENT_GROUP_TEXT_ACCESS_HXX
+#define SD_INTELLIGENT_GROUP_TEXT_ACCESS_HXX
+
+#include <rtl/ustring.hxx>
+
+namespace sd{
+
+	class IntelligentGroupTextAccess
+	{
+	public:
+		virtual sal_Int32 GetItemCount() = 0;
+		virtual sal_Int32 GetDepth(const sal_Int32 nItemIndex) = 0;
+		virtual rtl::OUString GetText(sal_Int32 nCurrentIndex, sal_Int32 nCurrentLevel) = 0;
+	};
+
+}//end of namespace sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/IntelligentGroupTextIterator.hxx sd/source/ui/inc/IntelligentGroupTextIterator.hxx
new file mode 100644
index 0000000..feab3af
--- /dev/null
+++ sd/source/ui/inc/IntelligentGroupTextIterator.hxx
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: IntelligentGroupTextIterator.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_INTELLIGENT_GROUP_TEXT_ITERATOR_HXX
+#define SD_INTELLIGENT_GROUP_TEXT_ITERATOR_HXX
+
+#include <sal/types.h>
+#include <vector>
+#include <boost/shared_ptr.hpp>
+
+namespace sd
+{
+
+class IntelligentGroupTextIterator
+{
+public:
+
+	virtual ~IntelligentGroupTextIterator();
+	virtual bool Rewind ();
+	virtual bool HasParent();
+	virtual sal_Int32 GetLevel();
+	virtual sal_Int32 GetChildCount() = 0;
+	virtual sal_Int32 GetItemCount() = 0;
+	virtual bool GotoFirstChild() = 0;
+	virtual bool GotoNext() = 0;
+	virtual bool GotoParent() = 0;
+
+
+protected:
+	sal_Int32 mnCurrentIndex;
+	sal_Int32 mnCurrentLevel;
+	sal_Int32 mnCurrentIndexOnLevel;
+
+	IntelligentGroupTextIterator();
+	IntelligentGroupTextIterator(IntelligentGroupTextIterator* pIterator);
+	void Up();
+	void Down();
+	sal_Int32 GetParentIndex (sal_Int32 nLevel);
+
+private:
+	std::vector<sal_Int32> maIndexPath;
+};
+
+}//end of namespace sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/ListLayoutAlgorithm.hxx sd/source/ui/inc/ListLayoutAlgorithm.hxx
new file mode 100644
index 0000000..cad4f29
--- /dev/null
+++ sd/source/ui/inc/ListLayoutAlgorithm.hxx
@@ -0,0 +1,63 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: ListLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_LIST_LAYOUT_ALGORITHM_HXX
+#define SD_LIST_LAYOUT_ALGORITHM_HXX
+
+
+#include "IntelligentGroupAlgorithmBase.hxx"
+
+
+namespace css = ::com::sun::star;
+
+
+namespace sd { 
+
+
+class ListLayoutAlgorithm : public IntelligentGroupAlgorithmBase
+{
+public:
+	ListLayoutAlgorithm( const ig::Orientation eOrientation );
+	virtual ~ListLayoutAlgorithm();
+	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, boost::shared_ptr<IntelligentGroupModel> pModel, const css::awt::Rectangle aGroupBoundingBox );
+	css::awt::Point CreatePosition( const sal_Int32 nPositionOnPrimaryAxis, const sal_Int32 nPositionOnSecondaryAxis );
+
+protected:
+	sal_Int32 Project( const sal_Int32 nFirst, const sal_Int32 nSecond, const bool bProjectToPrimaryAxis );
+	css::awt::Size CreateSize( const sal_Int32 nSizeOnPrimaryAxis, const sal_Int32 nSizeOnSecondaryAxis );
+
+private:
+	ig::Orientation meOrientation;
+};
+
+
+ }
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/PictureAccentListLayout.hxx sd/source/ui/inc/PictureAccentListLayout.hxx
new file mode 100644
index 0000000..2d467af
--- /dev/null
+++ sd/source/ui/inc/PictureAccentListLayout.hxx
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: PictureAccentListLayout.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_PICTURE_ACCENT_LIST_LAYOUT_HXX
+#define SD_PICTURE_ACCENT_LIST_LAYOUT_HXX
+
+#include "IntelligentGroupLayoutBase.hxx"
+
+namespace css = ::com::sun::star;
+
+namespace sd{
+
+	class PictureAccentListLayout: public IntelligentGroupLayoutBase
+	{
+	public:
+		PictureAccentListLayout(boost::shared_ptr<IntelligentGroupModel> pModel,
+			boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+		double GetGap(css::awt::Rectangle aGroupBoundingBox);
+		css::awt::Size GetBoundingSize(sal_Int32 nIndex, css::awt::Size aDefaultSize, std::vector<IntelligentGroupShapeDescriptor> aDescriptos);
+		std::vector<IntelligentGroupShapeDescriptor> PrepareShapes(boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator, sal_Int32 nIndex, bool bCreatedByUser = false);
+//		void PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aDescriptors, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale);
+		void PlaceShapes(sal_Int32 nShapeGroupIndex, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale);
+		css::uno::Reference<css::drawing::XShape> CreateShape(rtl::OUString aIdentifier);
+		rtl::OUString GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex);
+	
+
+	private:
+		rtl::OUString GetShapePrefix(ig::ShapeClass eClass);
+		ig::ShapeClass GetClassForName(rtl::OUString sIdentifier);
+	};
+
+
+} //end of nameclass sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/RowFieldLayoutAlgorithm.hxx sd/source/ui/inc/RowFieldLayoutAlgorithm.hxx
new file mode 100644
index 0000000..21c241d
--- /dev/null
+++ sd/source/ui/inc/RowFieldLayoutAlgorithm.hxx
@@ -0,0 +1,50 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: RowFieldLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_ROW_FIELD_LAYOUT_ALGORITHM_HXX
+#define SD_ROW_FIELD_LAYOUT_ALGORITHM_HXX
+
+
+#include "FieldLayoutAlgorithm.hxx"
+
+
+namespace sd { 
+
+class RowFieldLayoutAlgorithm : public FieldLayoutAlgorithm
+{
+public:
+	RowFieldLayoutAlgorithm();
+	~RowFieldLayoutAlgorithm();
+};
+
+} 
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/SelectionManager.hxx sd/source/ui/inc/SelectionManager.hxx
new file mode 100644
index 0000000..14034be
--- /dev/null
+++ sd/source/ui/inc/SelectionManager.hxx
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: SelectionManager.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SD_SELECTION_MANAGER_HXX
+#define SD_SELECTION_MANAGER_HXX
+
+#include <hash_map>
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/view/XSelectionChangeListener.hpp>
+#include <com/sun/star/beans/XPropertyChangeListener.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include "IntelligentGroup.hxx"
+#include "IntelligentGroupFrame.hxx"
+
+namespace css = ::com::sun::star;
+
+
+namespace sd{
+
+class View;
+
+typedef ::cppu::WeakImplHelper2< ::com::sun::star::view::XSelectionChangeListener, ::com::sun::star::beans::XPropertyChangeListener > SelectionChangeListener;
+
+class SelectionManager: public SelectionChangeListener
+{
+public:
+
+	SelectionManager(css::uno::Reference< css::frame::XController > xController,
+		css::uno::Reference< css::frame::XModel > xModel) ;
+	virtual ~SelectionManager() ;
+	boost::shared_ptr<IntelligentGroup> GetSelectedIntelligentGroup();
+	bool IsSelectedIntelligentGroupEntered();
+	void Select(boost::shared_ptr<IntelligentGroup> pIntelligentGroup);
+	void AddSelectionChangeListener(css::uno::Reference< css::view::XSelectionChangeListener > xListener);
+	void RemoveSelectionChangeListener(css::uno::Reference< css::view::XSelectionChangeListener > xListener);
+	void SetSelectedShape(css::uno::Reference< css::drawing::XShape > xShape);
+	css::uno::Reference< css::drawing::XShape > GetSelectedShape();
+	void DisposeFrame();
+
+	// lang::XEventListener
+	void SAL_CALL 
+		disposing (const ::com::sun::star::lang::EventObject& rEventObject)
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// view::XSelectionChangeListener
+	void SAL_CALL
+		selectionChanged (const ::com::sun::star::lang::EventObject& rEvent)
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// beans::XPropertyChangeListener
+	void SAL_CALL
+		propertyChange (const ::com::sun::star::beans::PropertyChangeEvent& rEventObject)
+		throw (::com::sun::star::uno::RuntimeException);
+private:
+	boost::shared_ptr<IntelligentGroup> FindShapeInGroup(css::uno::Reference< css::drawing::XShape > xShape);
+
+private:
+
+//	css::uno::Reference< css::view::XSelectionSupplier > mxSelectionSupplier;
+	css::uno::Reference< css::drawing::XShape > mxSelectedShape;
+	css::uno::Reference< css::frame::XModel > mxModel;
+	css::uno::Reference< css::frame::XController > mxController;
+	std::vector< css::uno::Reference< css::view::XSelectionChangeListener > > maListeners;
+	css::uno::Reference< css::view::XSelectionSupplier > mxSelectionSupplier;
+	boost::shared_ptr<IntelligentGroup> mpSelectedIntelligentGroup;
+	bool mbIsEntered;
+	IntelligentGroupFrame* mpIntelligentGroupFrame;
+};
+
+}//end of namespace sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/TaskPaneViewShell.hxx sd/source/ui/inc/TaskPaneViewShell.hxx
index 6659064..e36f1e5 100644
--- sd/source/ui/inc/TaskPaneViewShell.hxx
+++ sd/source/ui/inc/TaskPaneViewShell.hxx
@@ -76,6 +76,7 @@ public:
         PID_UNKNOWN = PID__START,
         PID_MASTER_PAGES,
         PID_LAYOUT,
+		PID_INTELLIGENT_GROUP,
 		PID_TABLE_DESIGN,
         PID_ANIMATION_SCHEMES,
         PID_CUSTOM_ANIMATION,
diff --git sd/source/ui/inc/TreeLayout.hxx sd/source/ui/inc/TreeLayout.hxx
new file mode 100644
index 0000000..24d396f
--- /dev/null
+++ sd/source/ui/inc/TreeLayout.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: TreeLayout.hxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+
+#ifndef SD_TREE_LAYOUT_HXX
+#define SD_TREE_LAYOUT_HXX
+
+#include "IntelligentGroupLayoutBase.hxx"
+
+namespace css = ::com::sun::star;
+
+namespace sd{
+
+	class TreeLayout: public IntelligentGroupLayoutBase
+	{
+	public:
+		TreeLayout(boost::shared_ptr<IntelligentGroupModel> pModel,
+			boost::shared_ptr<IntelligentGroupLayoutDescriptor> pDescriptor);
+		double GetGap(css::awt::Rectangle aGroupBoundingBox);
+		css::awt::Size GetBoundingSize(sal_Int32 nIndex, css::awt::Size aDefaultSize, std::vector<IntelligentGroupShapeDescriptor> aDescriptos);
+		std::vector<IntelligentGroupShapeDescriptor> PrepareShapes(boost::shared_ptr<IntelligentGroupTextIterator> pTextIterator, sal_Int32 nIndex, bool bCreatedByUser = false);
+//		void PlaceShapes(std::vector<IntelligentGroupShapeDescriptor> aDescriptors, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale);
+		void PlaceShapes(sal_Int32 nShapeGroupIndex, css::awt::Rectangle aBoundingBox, css::awt::Rectangle aGroupBoundingBox, css::awt::Size aDefaultSize, double nScale);
+		css::uno::Reference<css::drawing::XShape> CreateShape(rtl::OUString aIdentifier);
+		rtl::OUString GetShapeName(ig::ShapeClass eClass, sal_Int32 nIndex);
+
+	private:
+		rtl::OUString GetShapePrefix(ig::ShapeClass eClass);
+	};
+
+
+} //end of nameclass sd
+
+#endif 
\ No newline at end of file
diff --git sd/source/ui/inc/TreeLayoutAlgorithm.hxx sd/source/ui/inc/TreeLayoutAlgorithm.hxx
new file mode 100644
index 0000000..e083503
--- /dev/null
+++ sd/source/ui/inc/TreeLayoutAlgorithm.hxx
@@ -0,0 +1,77 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: TreeLayoutAlgorithm.hxx,v $
+*
+* $Revision: 1.3 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+#ifndef SD_TREE_LAYOUT_ALGORITHM_HXX
+#define SD_TREE_LAYOUT_ALGORITHM_HXX
+
+
+#include "IntelligentGroupAlgorithmBase.hxx"
+
+
+namespace css = ::com::sun::star;
+
+
+namespace sd { 
+
+
+class TreeLayoutAlgorithm : public IntelligentGroupAlgorithmBase
+{
+public:
+	TreeLayoutAlgorithm();
+	virtual ~TreeLayoutAlgorithm();
+//	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, std::vector<std::vector<IntelligentGroupShapeDescriptor>>& rShapeDescriptorVector, const css::awt::Rectangle aGroupBoundingBox );
+	void PlaceShape( boost::shared_ptr<IntelligentGroupLayoutBase> pLayout, boost::shared_ptr<IntelligentGroupModel> pModel, const css::awt::Rectangle aGroupBoundingBox );
+
+
+protected:
+	Rectangle PlaceSubTree(
+		boost::shared_ptr<IntelligentGroupLayoutBase> pLayout,
+//		std::vector<std::vector<IntelligentGroupShapeDescriptor>>& aShapeDescriptors, 
+		boost::shared_ptr<IntelligentGroupModel> pModel,
+		sal_Int32 nIndex,
+		sal_Int32 nCount,
+		css::uno::Reference<css::drawing::XShape> xParent,
+		sal_Int32 nLeft);
+
+
+private:
+	css::awt::Rectangle maGroupBoundingBox;
+	sal_Int32 mnLevelCount;
+	sal_Int32 mnShapeWidth;
+	sal_Int32 mnShapeHeight;
+	sal_Int32 mnHorizontalSpace;
+	sal_Int32 mnVerticalSpace;
+};
+
+
+ }
+
+#endif
\ No newline at end of file
diff --git sd/source/ui/inc/ViewShellBase.hxx sd/source/ui/inc/ViewShellBase.hxx
index fdd8b95..1017018 100644
--- sd/source/ui/inc/ViewShellBase.hxx
+++ sd/source/ui/inc/ViewShellBase.hxx
@@ -39,6 +39,7 @@
 #include <memory>
 #include <boost/shared_ptr.hpp>
 #include <boost/scoped_ptr.hpp>
+#include "SelectionManager.hxx"
 
 #include <set>
 
@@ -202,6 +203,9 @@ public:
     */
     void SetBusyState (bool bBusy);
 
+	void SetIGSelectionManager(::boost::shared_ptr<SelectionManager> pSelectionManager);
+	::boost::shared_ptr<SelectionManager> GetIGSelectionManager(void);
+
     /** Call this method when the controls of this view shell or the
         embedded sub shell need to be rearranged.  This is necessary
         e.g. when the border has been modified (UpdateBorder() calls this
@@ -271,6 +275,7 @@ private:
     ::boost::scoped_ptr<Implementation> mpImpl;
 	DrawDocShell* mpDocShell;
 	SdDrawDocument* mpDocument;
+	::boost::shared_ptr<SelectionManager> mpIGSelectionManager;
 
     /** Determine from the properties of the document shell the initial type
         of the view shell in the center pane.  We use this method to avoid
diff --git sd/source/ui/inc/framework/FrameworkHelper.hxx sd/source/ui/inc/framework/FrameworkHelper.hxx
index 3e06aac..cee3bbd 100644
--- sd/source/ui/inc/framework/FrameworkHelper.hxx
+++ sd/source/ui/inc/framework/FrameworkHelper.hxx
@@ -100,6 +100,7 @@ public:
     static const ::rtl::OUString msTaskPanelURLPrefix;
     static const ::rtl::OUString msMasterPagesTaskPanelURL;
     static const ::rtl::OUString msLayoutTaskPanelURL;
+	static const ::rtl::OUString msIntelligentGroupTaskPanelURL;
     static const ::rtl::OUString msTableDesignPanelURL;
     static const ::rtl::OUString msCustomAnimationTaskPanelURL;
     static const ::rtl::OUString msSlideTransitionTaskPanelURL;
diff --git sd/source/ui/inc/res_bmp.hrc sd/source/ui/inc/res_bmp.hrc
index 8565e1b..659c2e2 100644
--- sd/source/ui/inc/res_bmp.hrc
+++ sd/source/ui/inc/res_bmp.hrc
@@ -304,6 +304,12 @@
 #define RID_DRAW_OUTLINETEXTOBJ_POPUP		RID_APP_START+94
 #define RID_GRAPHIC_OUTLINETEXTOBJ_POPUP	RID_APP_START+95
 
+#define BMP_IGLAYOUTS_GROUPEDLIST			RID_APP_START+93
+#define BMP_IGLAYOUTS_PICTUREACCENTLIST		RID_APP_START+94
+#define BMP_IGLAYOUTS_TREE					RID_APP_START+95
+#define BMP_IGLAYOUTS_SIMPLEFIELD			RID_APP_START+96
+#define BMP_IGLAYOUTS_BASECIRCLE			RID_APP_START+97
+
 /*
  * Pointer (Mauszeiger)
  */
diff --git sd/source/ui/toolpanel/TaskPaneViewShell.cxx sd/source/ui/toolpanel/TaskPaneViewShell.cxx
index 6322365..aac1e11 100644
--- sd/source/ui/toolpanel/TaskPaneViewShell.cxx
+++ sd/source/ui/toolpanel/TaskPaneViewShell.cxx
@@ -46,6 +46,7 @@
 #include "taskpane/TaskPaneControlFactory.hxx"
 #include "controls/MasterPagesPanel.hxx"
 #include "controls/MasterPagesSelector.hxx"
+#include "controls/IntelligentGroupPanel.hxx"
 #include "controls/TableDesignPanel.hxx"
 #include "controls/CustomAnimationPanel.hxx"
 #include "controls/SlideTransitionPanel.hxx"
@@ -248,6 +249,22 @@ void TaskPaneViewShell::Implementation::Setup (
     nIdOfControlToExpand = nId;
 
 	{
+		DummyControl aControl (pToolPanel, SdResId(DLG_INTELLIGENTGROUPPANE));
+
+		//IntelligentGroupPanel
+		nId = pToolPanel->AddControl (
+			controls::IntelligentGroupPanel::CreateControlFactory(rBase),
+			aControl.GetText(),
+			HID_SD_INTELLIGENT_GROUP,
+			ResourceActivationClickHandler(
+			pFrameworkHelper, 
+			pFrameworkHelper->CreateResourceId(
+			FrameworkHelper::msIntelligentGroupTaskPanelURL, xTaskPaneId),
+			pToolPanel->GetControlContainer()));
+		AddPanel (nId, PID_INTELLIGENT_GROUP);
+	}
+
+	{
         DummyControl aControl (pToolPanel, SdResId(DLG_TABLEDESIGNPANE));
 
         // TableDesignPanel
diff --git sd/source/ui/toolpanel/controls/IntelligentGroupPanel.cxx sd/source/ui/toolpanel/controls/IntelligentGroupPanel.cxx
new file mode 100644
index 0000000..ec0bdd0
--- /dev/null
+++ sd/source/ui/toolpanel/controls/IntelligentGroupPanel.cxx
@@ -0,0 +1,118 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: IntelligentGroupPanel.cxx,v $
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include "IntelligentGroupPanel.hxx"
+
+#include "taskpane/TaskPaneControlFactory.hxx"
+
+#include "strings.hrc"
+#include "sdresid.hxx"
+
+#ifndef _COM_SUN_STAR_FRAME_XMODEL_HPP_
+#include <com/sun/star/frame/XModel.hpp>
+#endif
+
+namespace sd
+{
+
+	class ViewShellBase;
+	extern ::Window * createIntelligentGroupPanel( ::Window* pParent, ViewShellBase& rBase );
+
+	namespace toolpanel { namespace controls {
+
+
+
+		IntelligentGroupPanel::IntelligentGroupPanel(TreeNode* pParent, ViewShellBase& rBase)
+			: SubToolPanel (pParent),
+			maPreferredSize( 100, 200 )
+		{
+			mpWrappedControl = createIntelligentGroupPanel( pParent->GetWindow(), rBase );
+			mpWrappedControl->Show();
+		}
+
+		IntelligentGroupPanel::~IntelligentGroupPanel()
+		{
+			delete mpWrappedControl;
+		}
+
+		std::auto_ptr<ControlFactory> IntelligentGroupPanel::CreateControlFactory (ViewShellBase& rBase)
+		{
+			return std::auto_ptr<ControlFactory>(
+				new ControlFactoryWithArgs1<IntelligentGroupPanel,ViewShellBase>(rBase));
+		}
+
+		Size IntelligentGroupPanel::GetPreferredSize()
+		{
+			return maPreferredSize;
+		}
+
+		sal_Int32 IntelligentGroupPanel::GetPreferredWidth(sal_Int32 )
+		{
+			return maPreferredSize.Width();
+		}
+
+		sal_Int32 IntelligentGroupPanel::GetPreferredHeight(sal_Int32 )
+		{
+			return maPreferredSize.Height();
+		}
+
+		::Window* IntelligentGroupPanel::GetWindow()
+		{
+			return mpWrappedControl;
+		}
+
+		bool IntelligentGroupPanel::IsResizable()
+		{
+			return true;
+		}
+
+		bool IntelligentGroupPanel::IsExpandable() const
+		{
+			return true;
+		}
+
+
+
+
+		::com::sun::star::uno::Reference<
+			::com::sun::star::accessibility::XAccessible> IntelligentGroupPanel::CreateAccessibleObject (
+			const ::com::sun::star::uno::Reference<
+			::com::sun::star::accessibility::XAccessible>& )
+		{
+			if (GetWindow() != NULL)
+				return GetWindow()->GetAccessible();
+			else
+				return NULL;
+		}
+
+
+	} } } // end of namespace ::sd::toolpanel::controls
\ No newline at end of file
diff --git sd/source/ui/toolpanel/controls/IntelligentGroupPanel.hxx sd/source/ui/toolpanel/controls/IntelligentGroupPanel.hxx
new file mode 100644
index 0000000..efad609
--- /dev/null
+++ sd/source/ui/toolpanel/controls/IntelligentGroupPanel.hxx
@@ -0,0 +1,78 @@
+/*************************************************************************
+*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright 2008 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+* $RCSfile: IntelligentGroupPanel.hxx,v $
+* $Revision: 1.0 $
+*
+* This file is part of OpenOffice.org.
+*
+* OpenOffice.org is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Lesser General Public License version 3
+* only, as published by the Free Software Foundation.
+*
+* OpenOffice.org is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Lesser General Public License version 3 for more details
+* (a copy is included in the LICENSE file that accompanied this code).
+*
+* You should have received a copy of the GNU Lesser General Public License
+* version 3 along with OpenOffice.org.  If not, see
+* <http://www.openoffice.org/license.html>
+* for a copy of the LGPLv3 License.
+*
+************************************************************************/
+#ifndef SD_TOOLPANEL_CONTROLS_INTELLIGENT_GROUOP_PANEL_HXX
+#define SD_TOOLPANEL_CONTROLS_INTELLIGENT_GROUOP_PANEL_HXX
+
+#include "taskpane/SubToolPanel.hxx"
+
+namespace sd {
+	class ViewShellBase;
+}
+
+namespace sd { namespace toolpanel {
+	class ControlFactory;
+	class TreeNode;
+} }
+
+namespace sd { namespace toolpanel { namespace controls {
+
+	class IntelligentGroupPanel
+		: public SubToolPanel
+	{
+	public:
+		IntelligentGroupPanel (
+			TreeNode* pParent,
+			ViewShellBase& rBase);
+		virtual ~IntelligentGroupPanel (void);
+
+		static std::auto_ptr<ControlFactory> CreateControlFactory (ViewShellBase& rBase);
+
+		virtual Size GetPreferredSize (void);
+		virtual sal_Int32 GetPreferredWidth (sal_Int32 nHeigh);
+		virtual sal_Int32 GetPreferredHeight (sal_Int32 nWidth);
+		virtual ::Window* GetWindow (void);
+		virtual bool IsResizable (void);
+		virtual bool IsExpandable (void) const;
+
+		virtual ::com::sun::star::uno::Reference<
+			::com::sun::star::accessibility::XAccessible > CreateAccessibleObject (
+			const ::com::sun::star::uno::Reference<
+			::com::sun::star::accessibility::XAccessible>& rxParent);
+
+		using Window::GetWindow;
+
+	private:
+		Size maPreferredSize;
+		::Window* mpWrappedControl;
+	};
+
+} } } // end of namespace ::sd::toolpanel::controls
+
+#endif
diff --git sd/source/ui/toolpanel/controls/makefile.mk sd/source/ui/toolpanel/controls/makefile.mk
index 693a30f..3f281a4 100644
--- sd/source/ui/toolpanel/controls/makefile.mk
+++ sd/source/ui/toolpanel/controls/makefile.mk
@@ -64,7 +64,8 @@ SLOFILES =      							\
 	$(SLO)$/CustomAnimationPanel.obj		\
 	$(SLO)$/SlideTransitionPanel.obj		\
 	$(SLO)$/TableDesignPanel.obj			\
-	$(SLO)$/AnimationSchemesPanel.obj
+	$(SLO)$/AnimationSchemesPanel.obj		\
+	$(SLO)$/IntelligentGroupPanel.obj
 
 
 # --- Tagets -------------------------------------------------------
diff --git sd/source/ui/view/ViewShellBase.cxx sd/source/ui/view/ViewShellBase.cxx
index 78d5092..23856db 100644
--- sd/source/ui/view/ViewShellBase.cxx
+++ sd/source/ui/view/ViewShellBase.cxx
@@ -416,6 +416,27 @@ void ViewShellBase::LateInit (const ::rtl::OUString& rsDefaultView)
 
 
 
+void ViewShellBase::SetIGSelectionManager( ::boost::shared_ptr<SelectionManager> pIGSelectionManger )
+{
+	if(mpIGSelectionManager != pIGSelectionManger)
+	{
+		mpIGSelectionManager.reset();
+		mpIGSelectionManager = pIGSelectionManger;
+	}
+}
+
+
+
+
+::boost::shared_ptr<SelectionManager> ViewShellBase::GetIGSelectionManager( void )
+{
+	return mpIGSelectionManager;
+}
+
+
+
+
+
 ::boost::shared_ptr<ViewShellManager> ViewShellBase::GetViewShellManager (void) const
 {
     return mpImpl->mpViewShellManager;
diff --git sd/source/ui/view/drviews2.cxx sd/source/ui/view/drviews2.cxx
index 8326f7a..4a4b836 100644
--- sd/source/ui/view/drviews2.cxx
+++ sd/source/ui/view/drviews2.cxx
@@ -93,6 +93,8 @@
 #include "slideshow.hxx"
 #include "fuvect.hxx"
 #include "stlpool.hxx"
+#include "ViewShellBase.hxx"
+#include "SelectionManager.hxx"
 
 // #90356#
 #include "optsitem.hxx"
@@ -834,6 +836,18 @@ void DrawViewShell::FuTemporary(SfxRequest& rReq)
 		rReq.Done ();
 		break;
 
+		case SID_ADD_SHAPE:
+		{
+			Reference<drawing::XShape> xShape ( GetViewShellBase().GetIGSelectionManager()->GetSelectedShape() );
+			if(!IntelligentGroup::IsIntelligentGroup(xShape))
+				break;
+			GetViewShellBase().GetIGSelectionManager()->GetSelectedIntelligentGroup()->AddShape(xShape);
+		}
+
+		Cancel();
+		rReq.Done();
+		break;
+
 		case SID_SET_DEFAULT:
 		{
 			SfxItemSet* pSet = NULL;
diff --git sd/source/ui/view/drviewse.cxx sd/source/ui/view/drviewse.cxx
index 1c77e6a..b94ba5b 100644
--- sd/source/ui/view/drviewse.cxx
+++ sd/source/ui/view/drviewse.cxx
@@ -71,7 +71,9 @@
 #include <svtools/urihelper.hxx>
 #include <sfx2/topfrm.hxx>
 #include <sfx2/docfile.hxx>
+#include <svx/unoshape.hxx>
 
+#include "IntelligentGroupController.hxx"
 #include "DrawViewShell.hxx"
 #include "slideshow.hxx"
 #include "ViewShellImplementation.hxx"
@@ -273,6 +275,33 @@ void DrawViewShell::FuPermanent(SfxRequest& rReq)
 		}
 		break;
 
+		case SID_INSERT_INTELLIGENT_GROUP:
+		{
+			SdPage* pPage = GetActualPage();
+
+			IntelligentGroupController* pIGController =  new IntelligentGroupController(
+				uno::Reference<frame::XModel>(pPage->GetModel()->getUnoModel(),uno::UNO_QUERY),
+				GetViewShellBase().GetController(),
+				GetViewShellBase());
+
+			SFX_REQUEST_ARG (rReq, pName, SfxStringItem, SID_INSERT_INTELLIGENT_GROUP, FALSE);
+			rtl::OUString sLayoutName;
+			if(pName)
+			{
+				sLayoutName = pName->GetValue();
+				pIGController->SetLayout(sLayoutName,true);
+			}
+			else
+				pIGController->SetLayout(OUString(RTL_CONSTASCII_USTRINGPARAM("GroupedList")),true);
+
+			delete pIGController;
+
+			SetCurrentFunction( FuSelection::Create(this, GetActiveWindow(), mpDrawView, GetDoc(), rReq) );
+			rReq.Done();
+			Invalidate( SID_OBJECT_SELECT );
+		}
+		break;
+
 		// #98721#
 		case SID_FM_CREATE_FIELDCONTROL:
 		{
@@ -854,6 +883,32 @@ void DrawViewShell::FuSupport(SfxRequest& rReq)
                 ::sd::Window* pWindow = GetActiveWindow();
                 InfoBox(pWindow, String(SdResId(STR_ACTION_NOTPOSSIBLE) ) ).Execute();
 			}
+			else if (GetViewShellBase().GetIGSelectionManager().get() &&
+				IntelligentGroup::IsIntelligentGroup(GetViewShellBase().GetIGSelectionManager()->GetSelectedShape()))
+			{
+				boost::shared_ptr<IntelligentGroup> pCurrentGroup = GetViewShellBase().GetIGSelectionManager()->GetSelectedIntelligentGroup();
+
+				pCurrentGroup->GetModel()->RemoveShape(GetViewShellBase().GetIGSelectionManager()->GetSelectedShape());
+
+				KeyCode aKCode(KEY_DELETE);
+				KeyEvent aKEvt( 0, aKCode);
+
+				bool bConsumed = mpDrawView && mpDrawView->getSmartTags().KeyInput( aKEvt );
+
+				if( !bConsumed && HasCurrentFunction() )
+					bConsumed = GetCurrentFunction()->KeyInput(aKEvt);
+
+				if( !bConsumed && mpDrawView )
+					mpDrawView->DeleteMarked();
+
+
+				if(pCurrentGroup->GetModel()->GetShapeCount() == 0)
+				{
+					GetViewShellBase().GetIGSelectionManager()->DisposeFrame();
+				}
+				else
+					pCurrentGroup->UpdateLayout();
+			}
 			else
 			{
 				KeyCode aKCode(KEY_DELETE);
@@ -1425,6 +1480,13 @@ void DrawViewShell::FuSupport(SfxRequest& rReq)
 		{
 			// #96090# moved implementation to BaseClass
 			ImpSidUndo(TRUE, rReq);
+
+			boost::shared_ptr<IntelligentGroup> pIntelligentGroup = GetViewShellBase().GetIGSelectionManager()->GetSelectedIntelligentGroup();
+			if(pIntelligentGroup.get())
+			{
+				if(pIntelligentGroup->GetModel()->RequestUndo())
+					pIntelligentGroup->UpdateLayout();
+			}
 		}
 		break;
 		case SID_REDO :
diff --git sd/uiconfig/simpress/menubar/menubar.xml sd/uiconfig/simpress/menubar/menubar.xml
index 8e6fd46..7394432 100644
--- sd/uiconfig/simpress/menubar/menubar.xml
+++ sd/uiconfig/simpress/menubar/menubar.xml
@@ -173,6 +173,7 @@
                 </menu:menupopup>
             </menu:menu>
 			<menu:menuitem menu:id=".uno:InsertTable"/>
+			<menu:menuitem menu:id=".uno:InsertIntelligentGroup"/>
 			<menu:menuitem menu:id=".uno:InsertAVMedia"/>
             <menu:menu menu:id=".uno:ObjectMenu">
 				<menu:menupopup>
diff --git sd/util/makefile.mk sd/util/makefile.mk
index c2409f4..cee9b83 100644
--- sd/util/makefile.mk
+++ sd/util/makefile.mk
@@ -60,6 +60,7 @@ RESLIB1SRSFILES=\
 	$(SRS)$/animui.srs			\
 	$(SRS)$/slideshow.srs		\
 	$(SRS)$/uitable.srs			\
+	$(SRS)$/ig.srs				\
 	$(SOLARCOMMONRESDIR)$/sfx.srs
 
 # --- StarDraw DLL
@@ -140,7 +141,8 @@ LIB5FILES=      \
 			$(SLB)$/accessibility.lib	\
 			$(SLB)$/toolpanel.lib		\
 			$(SLB)$/uitools.lib			\
-			$(SLB)$/tpcontrols.lib
+			$(SLB)$/tpcontrols.lib		\
+			$(SLB)$/ig.lib
 
 LIB6TARGET=$(SLB)$/sdraw3_3.lib
 LIB6FILES=      								\
@@ -156,7 +158,8 @@ LIB6FILES=      								\
 			$(SLB)$/framework_factories.lib		\
 			$(SLB)$/framework_module.lib		\
 			$(SLB)$/framework_tools.lib			\
-			$(SLB)$/presenter.lib
+			$(SLB)$/presenter.lib				
+
 
 # sdd
 SHL2TARGET= sdd$(DLLPOSTFIX)
