diff -u -r1.41 -r1.41.6.1
--- vcl/unx/inc/salframe.h	9 Sep 2004 16:24:15 -0000	1.41
+++ vcl/unx/inc/salframe.h	20 Sep 2004 12:58:19 -0000	1.41.6.1
@@ -98,23 +98,6 @@
 
 namespace vcl_sal { class WMAdaptor; class NetWMAdaptor; class GnomeWMAdaptor; }
 
-class SalFrameDelData 
-{
-    private:
- 
-        sal_Bool            mbDeleted; 
-        SalFrameDelData*    mpNext;                    
-
-    public:
-                            SalFrameDelData () : mbDeleted(sal_False), mpNext(NULL)
-                                         {}
-        void                Delete ()    { mbDeleted = sal_True; }
-        sal_Bool            IsDeleted () { return mbDeleted; }
-        void                SetNext (SalFrameDelData* pData) 
-                                         { mpNext = pData; }
-        SalFrameDelData*    GetNext ()   { return mpNext; }
-}; 
-
 // -=-= X11SalFrame =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 #define SHOWSTATE_UNKNOWN		-1
 #define SHOWSTATE_MINIMIZED 	0
@@ -191,8 +174,6 @@
     SalI18N_InputContext *mpInputContext;
     bool			mbDeleteInputContext;
     Bool			mbInputFocus;
-    SalFrameDelData *mpDeleteData;
-    void            NotifyDeleteData ();
     
     void			GetPosSize( Rectangle &rPosSize );
     void			SetSize   ( const Size      &rSize );
@@ -251,8 +232,6 @@
     void			        getPosSize( Rectangle& rRect ) { GetPosSize( rRect ); }
     void					setPosSize( const Rectangle& rRect ) { SetPosSize( rRect ); }
     bool					isMapped() const { return bMapped_; }
-    void            RegisterDeleteData (SalFrameDelData *pData);
-    void            UnregisterDeleteData (SalFrameDelData *pData);
     
     virtual SalGraphics*		GetGraphics();
     virtual void				ReleaseGraphics( SalGraphics* pGraphics );


--- vcl/unx/inc/plugins/gtk/gtkframe.hxx	9 Sep 2004 16:24:46 -0000	1.5
+++ vcl/unx/inc/plugins/gtk/gtkframe.hxx	20 Sep 2004 10:26:51 -0000	1.4.66.3
@@ -143,7 +145,7 @@
     static void			signalIMPreeditEnd( GtkIMContext*, gpointer );
     static void			signalIMPreeditStart( GtkIMContext*, gpointer );
     static gboolean		signalIMRetrieveSurrounding( GtkIMContext*, gpointer );
-    
+    static void			signalDestroy( GtkObject*, gpointer );
 
 	GtkSalDisplay*	getDisplay();
 	GdkDisplay*		getGdkDisplay();


--- vcl/unx/inc/plugins/gtk/gtkobject.hxx	20 Feb 2004 08:57:43 -0000	1.2
+++ vcl/unx/inc/plugins/gtk/gtkobject.hxx	9 Sep 2004 13:58:28 -0000	1.2.154.1
@@ -84,6 +84,7 @@
     // signals
     static gboolean		signalButton( GtkWidget*, GdkEventButton*, gpointer );
     static gboolean		signalFocus( GtkWidget*, GdkEventFocus*, gpointer );
+    static void			signalDestroy( GtkObject*, gpointer );
 public:
     GtkSalObject( GtkSalFrame* pParent );
     virtual ~GtkSalObject();

Index: inc/salframe.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salframe.hxx,v
retrieving revision 1.21
retrieving revision 1.21.6.1
diff -u -r1.21 -r1.21.6.1
--- vcl/inc/salframe.hxx	9 Sep 2004 16:16:17 -0000	1.21
+++ vcl/inc/salframe.hxx	20 Sep 2004 12:58:18 -0000	1.21.6.1
@@ -92,6 +92,10 @@
 #include <region.hxx>
 #endif
 
+#ifndef _VCL_IMPDEL_HXX
+#include <impdel.hxx>
+#endif
+
 #ifndef _RTL_USTRING_HXX_
 #include <rtl/ustring.hxx>
 #endif
@@ -182,7 +186,7 @@
 
 struct SystemParentData;
 
-class SalFrame
+class SalFrame : public vcl::DeletionNotifier
 {
     void*					m_pInst;
     SALFRAMEPROC			m_pProc;



Index: unx/source/window/salframe.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/window/salframe.cxx,v
retrieving revision 1.183
retrieving revision 1.181.38.3
diff -u -r1.183 -r1.181.38.3
--- vcl/unx/source/window/salframe.cxx	9 Sep 2004 16:25:58 -0000	1.183
+++ vcl/unx/source/window/salframe.cxx	20 Sep 2004 12:58:19 -0000	1.181.38.3
@@ -670,8 +709,6 @@
     maAlwaysOnTopRaiseTimer.SetTimeoutHdl( LINK( this, X11SalFrame, HandleAlwaysOnTopRaise ) );
     maAlwaysOnTopRaiseTimer.SetTimeout( 100 );
 
-    mpDeleteData                = NULL;
-
     meWindowType				= WMAdaptor::windowType_Normal;
     mnDecorationFlags			= WMAdaptor::decoration_All;
     mbMaximizedVert				= false;
@@ -719,6 +756,8 @@
 
 X11SalFrame::~X11SalFrame()
 {
+	notifyDelete();
+	
     if( mhStackingWindow )
         aPresentationReparentList.remove( mhStackingWindow );
 
@@ -752,8 +791,6 @@
         doReparentPresentationDialogues( GetDisplay() );
     }
 
-    NotifyDeleteData ();
-
 	if( pGraphics_ )
 	{
 		pGraphics_->DeInit();
@@ -2556,39 +2593,6 @@
 	return nRet;
 }
 
-//
-// The eventhandler member functions may indirectly call their own destructor.
-// So make sure to be notified of that case to not to touch any member in the
-// rest of the eventhandler.
-//
-void
-X11SalFrame::RegisterDeleteData (SalFrameDelData *pData)
-{
-    pData->SetNext (mpDeleteData);
-    mpDeleteData = pData;
-}
-void
-X11SalFrame::NotifyDeleteData ()
-{
-    for (SalFrameDelData* pData = mpDeleteData; pData != NULL; pData = pData->GetNext())
-        pData->Delete();
-}
-void
-X11SalFrame::UnregisterDeleteData (SalFrameDelData *pData)
-{
-    if (mpDeleteData == pData)
-    {
-        mpDeleteData = pData->GetNext ();
-    }
-    else
-    {
-        SalFrameDelData* pList = mpDeleteData;
-        while (pList->GetNext() != pData)
-            pList = pList->GetNext ();
-        pList->SetNext (pData->GetNext());
-    }
-}
-
 // F10 means either KEY_F10 or KEY_MENU, which has to be decided
 // in the independent part.
 struct KeyAlternate
@@ -2811,8 +2815,7 @@
 		nSize = 1;
 	}
 
-    SalFrameDelData aDeleteWatch;
-    RegisterDeleteData (&aDeleteWatch);
+    DeletionListener aDeleteWatch( this );
 
 	if (   mpInputContext != NULL
 		&& mpInputContext->UseContext()
@@ -2868,12 +2871,10 @@
   	//
   	// update the spot location for PreeditPosition IME style
   	//
-    if (! aDeleteWatch.IsDeleted())
+    if (! aDeleteWatch.isDeleted())
     {
         if (mpInputContext != NULL && mpInputContext->UseContext())
             mpInputContext->UpdateSpotLocation();
-
-        UnregisterDeleteData (&aDeleteWatch);
     }
 
 	free (pBuffer);


Index: unx/gtk/window/gtkobject.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/gtk/window/gtkobject.cxx,v
retrieving revision 1.3
retrieving revision 1.3.100.1
diff -u -r1.3 -r1.3.100.1
--- vcl/unx/gtk/window/gtkobject.cxx	10 May 2004 15:53:24 -0000	1.3
+++ vcl/unx/gtk/window/gtkobject.cxx	9 Sep 2004 13:58:29 -0000	1.3.100.1
@@ -101,6 +101,7 @@
         g_signal_connect( G_OBJECT(m_pSocket), "button-release-event", G_CALLBACK(signalButton), this );
         g_signal_connect( G_OBJECT(m_pSocket), "focus-in-event", G_CALLBACK(signalFocus), this );
         g_signal_connect( G_OBJECT(m_pSocket), "focus-out-event", G_CALLBACK(signalFocus), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "destroy", G_CALLBACK(signalDestroy), this );
     }
 }
 
@@ -120,7 +121,8 @@
 
 void GtkSalObject::ResetClipRegion()
 {
-    gdk_window_shape_combine_region( m_pSocket->window, NULL, 0, 0 );
+    if( m_pSocket )
+        gdk_window_shape_combine_region( m_pSocket->window, NULL, 0, 0 );
 }
 
 USHORT GtkSalObject::GetClipRegionType()
@@ -148,7 +150,8 @@
 
 void GtkSalObject::EndSetClipRegion()
 {
-    gdk_window_shape_combine_region( m_pSocket->window, m_pRegion, 0, 0 );
+    if( m_pSocket )
+        gdk_window_shape_combine_region( m_pSocket->window, m_pRegion, 0, 0 );
 }
 
 void GtkSalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
@@ -217,4 +220,13 @@
     pThis->CallCallback( pEvent->in ? SALOBJ_EVENT_GETFOCUS : SALOBJ_EVENT_LOSEFOCUS, NULL );
 
     return FALSE;
+}
+
+void GtkSalObject::signalDestroy( GtkObject* pObj, gpointer object )
+{
+    GtkSalObject* pThis = (GtkSalObject*)object;
+    if( GTK_WIDGET(pObj) == pThis->m_pSocket )
+    {
+        pThis->m_pSocket = NULL;
+    }
 }


--- vcl/unx/gtk/window/gtkframe.cxx	2004-09-17 17:00:40.000000000 +0100
+++ vcl/unx/gtk/window/gtkframe.cxx	2004-09-24 18:33:53.807931536 +0100
@@ -230,6 +230,7 @@
     g_signal_connect( G_OBJECT(m_pWindow), "leave-notify-event", G_CALLBACK(signalCrossing), this );
     g_signal_connect( G_OBJECT(m_pWindow), "enter-notify-event", G_CALLBACK(signalCrossing), this );
     g_signal_connect( G_OBJECT(m_pWindow), "visibility-notify-event", G_CALLBACK(signalVisibility), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "destroy", G_CALLBACK(signalDestroy), this );
 
     // init members
 	m_pCurrentCursor    = NULL;
@@ -433,7 +434,7 @@
 
 void GtkSalFrame::SetIcon( USHORT nIcon )
 {
-    if( m_nStyle & SAL_FRAME_STYLE_CHILD )
+    if( m_nStyle & SAL_FRAME_STYLE_CHILD || ! m_pWindow )
         return;
 
 	GList *pPixbufs = NULL;
@@ -547,7 +548,7 @@
     SetPosSize( 0, 0, aDefSize.Width(), aDefSize.Height(),
                 SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
 
-    if( m_nStyle & SAL_FRAME_STYLE_DEFAULT )
+    if( m_nStyle & SAL_FRAME_STYLE_DEFAULT && m_pWindow )
         gtk_window_maximize( m_pWindow );
 }
 
@@ -675,7 +676,7 @@
 
 void GtkSalFrame::GetClientSize( long& rWidth, long& rHeight )
 {
-    if( GTK_WIDGET_MAPPED( GTK_WIDGET(m_pWindow) ) )
+    if( m_pWindow && GTK_WIDGET_MAPPED( GTK_WIDGET(m_pWindow) ) )
     {
         rWidth = maGeometry.nWidth;
         rHeight = maGeometry.nHeight;
@@ -866,26 +867,32 @@
 
 void GtkSalFrame::SetPointer( PointerStyle ePointerStyle )
 {
-	GdkCursor *pCursor = getDisplay()->getCursor( ePointerStyle );
-	gdk_window_set_cursor( GTK_WIDGET(m_pWindow)->window, pCursor );
-	m_pCurrentCursor = pCursor;
+    if( m_pWindow )
+    {
+        GdkCursor *pCursor = getDisplay()->getCursor( ePointerStyle );
+        gdk_window_set_cursor( GTK_WIDGET(m_pWindow)->window, pCursor );
+        m_pCurrentCursor = pCursor;
+    }
 }
 
 void GtkSalFrame::grabPointer( BOOL bGrab, BOOL bOwnerEvents )
 {
-	int nMask = ( GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK );
-	GdkGrabStatus nStatus;
-
-	if( bGrab )
-		nStatus = gdk_pointer_grab
+    if( m_pWindow )
+    {
+        int nMask = ( GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK );
+        GdkGrabStatus nStatus;
+        
+        if( bGrab )
+            nStatus = gdk_pointer_grab
 				( GTK_WIDGET(m_pWindow)->window, bOwnerEvents,
 				  (GdkEventMask) nMask, NULL, m_pCurrentCursor,
 				  GDK_CURRENT_TIME );
-	else
-	{
-		// Two GdkDisplays may be open
-		gdk_display_pointer_ungrab( getGdkDisplay(), GDK_CURRENT_TIME);
-	}
+        else
+        {
+            // Two GdkDisplays may be open
+            gdk_display_pointer_ungrab( getGdkDisplay(), GDK_CURRENT_TIME);
+        }
+    }
 }
 
 void GtkSalFrame::CaptureMouse( BOOL bCapture )
@@ -1357,8 +1348,12 @@
     }
 
     GTK_YIELD_GRAB();
+
+	vcl::DeletionListener aDel( pThis );
+
     pThis->CallCallback( nEventType, &aEvent );
 
+	if (! aDel.isDeleted() )
     if( bClosePopups )
     {
         ImplSVData* pSVData = ImplGetSVData();
@@ -1415,12 +1410,16 @@
     aEvent.mnButton	= 0;
 
     GTK_YIELD_GRAB();
+	vcl::DeletionListener aDel( pThis );
+
     pThis->CallCallback( SALEVENT_MOUSEMOVE, &aEvent );
 
+	if( !aDel.isDeleted() ) {
     // ask for the next hint
     gint x, y;
     GdkModifierType mask;
     gdk_window_get_pointer( GTK_WIDGET(pThis->m_pWindow)->window, &x, &y, &mask );
+	}
 
     return TRUE;
 }
@@ -1472,6 +1471,8 @@
         pThis->m_bWasPreedit = false;
 	}
 
+	::vcl::DeletionListener aDel( pThis );
+
     if( pThis->m_pIMContext )
     {
         if( pEvent->in )
@@ -1483,7 +1484,8 @@
         {
             gtk_im_context_focus_out( pThis->m_pIMContext );
             pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, NULL );
-            gtk_im_context_reset( pThis->m_pIMContext );
+			if (! aDel.isDeleted() )
+	            gtk_im_context_reset( pThis->m_pIMContext );
         }
     }
 
@@ -1494,6 +1496,7 @@
     //
     // in the meantime do not propagate focus get/lose on a plugged window
     // if floats are open
+	if (! aDel.isDeleted() )
     if( ! ((pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) && m_nFloats > 0 ) )
         pThis->CallCallback( pEvent->in ? SALEVENT_GETFOCUS : SALEVENT_LOSEFOCUS, NULL );
 
@@ -1611,7 +1614,9 @@
 
     GTK_YIELD_GRAB();
 
-    // handle modifiers
+	vcl::DeletionListener aDel( pThis );
+
+	// handle modifiers
     if( pEvent->keyval == GDK_Shift_L || pEvent->keyval == GDK_Shift_R ||
         pEvent->keyval == GDK_Control_L || pEvent->keyval == GDK_Control_R ||
         pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ||
@@ -1681,30 +1686,36 @@
 
 		pThis->CallCallback( SALEVENT_KEYMODCHANGE, &aModEvt );
 
-        // emulate KEY_MENU
-		if( ( pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ) &&
-			( nModCode & ~(KEY_CONTROLMOD|KEY_MOD2)) == 0 )
+		if( ! aDel.isDeleted() )
 		{
-            if( pEvent->type == GDK_KEY_PRESS )
-                pThis->m_bSingleAltPress = true;
-
-			else if( pThis->m_bSingleAltPress )
+			// emulate KEY_MENU
+			if( ( pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ) &&
+				( nModCode & ~(KEY_CONTROLMOD|KEY_MOD2)) == 0 )
 			{
-		        SalKeyEvent aKeyEvt;
-
-                aKeyEvt.mnCode	   = KEY_MENU | nModCode;
-                aKeyEvt.mnRepeat   = 0;
-                aKeyEvt.mnTime	   = pEvent->time;
-                aKeyEvt.mnCharCode = 0;
-
-                // simulate KEY_MENU
-                pThis->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
-                pThis->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
-				pThis->m_bSingleAltPress = false;
+				if( pEvent->type == GDK_KEY_PRESS )
+					pThis->m_bSingleAltPress = true;
+	
+				else if( pThis->m_bSingleAltPress )
+				{
+					SalKeyEvent aKeyEvt;
+	
+					aKeyEvt.mnCode	   = KEY_MENU | nModCode;
+					aKeyEvt.mnRepeat   = 0;
+					aKeyEvt.mnTime	   = pEvent->time;
+					aKeyEvt.mnCharCode = 0;
+	
+					// simulate KEY_MENU
+					pThis->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+					if( ! aDel.isDeleted() )
+					{
+						pThis->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
+						pThis->m_bSingleAltPress = false;
+					}
+				}
 			}
+			else
+				pThis->m_bSingleAltPress = false;
 		}
-		else
-			pThis->m_bSingleAltPress = false;
     }
     else
     {
@@ -1717,8 +1728,11 @@
 
         pThis->CallCallback( (pEvent->type == GDK_KEY_PRESS) ? SALEVENT_KEYINPUT : SALEVENT_KEYUP, &aEvent );
 
-		pThis->m_bSendModChangeOnRelease = false;
-		pThis->m_bSingleAltPress = false;
+		if( ! aDel.isDeleted() )
+		{
+			pThis->m_bSendModChangeOnRelease = false;
+			pThis->m_bSingleAltPress = false;
+		}
     }
 
     return TRUE;
@@ -1787,6 +1801,8 @@
     aTextEvent.mbOnlyCursor 	= False;
 
     GTK_YIELD_GRAB();
+	
+	vcl::DeletionListener aDel( pThis );
 
     /* necessary HACK: all keyboard input comes in here as soon as a IMContext is set
      *  which is logical and consequent. But since even simple input like
@@ -1811,12 +1827,14 @@
 
        pThis->m_bWasPreedit = false;
        pThis->CallCallback( SALEVENT_KEYINPUT, &aEvent );
+	   if (!aDel.isDeleted())
        pThis->CallCallback( SALEVENT_KEYUP, &aEvent );
        return;
     }
 
     pThis->m_bWasPreedit = false;
     pThis->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
+	if (!aDel.isDeleted())
     pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 }
 
@@ -1882,2 +1900,12 @@
     return FALSE;
 }
+ 
+void GtkSalFrame::signalDestroy( GtkObject* pObj, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    if( GTK_WINDOW( pObj ) == pThis->m_pWindow )
+    {
+        pThis->m_pWindow = NULL;
+    }
+}
+

--- /dev/null	2004-07-26 12:51:14.000000000 +0100
+++ vcl/inc/impdel.hxx	2004-09-20 13:58:18.000000000 +0100
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+ #ifndef _VCL_IMPDEL_HXX
+ #define _VCL_IMPDEL_HXX
+ 
+ #include <list>
+ 
+ namespace vcl
+ {
+ 
+ class DeletionListener;
+ 
+ class DeletionNotifier
+ {
+	 std::list< DeletionListener* > m_aListeners;
+	 protected:
+	 DeletionNotifier() {}
+
+	 ~DeletionNotifier()
+	 { notifyDelete(); }
+	 
+	 inline void notifyDelete();
+
+	 public:	 
+	 void addDel( DeletionListener* pListener )
+	 { m_aListeners.push_back( pListener ); }
+	 
+	 void removeDel( DeletionListener* pListener )
+	 { m_aListeners.remove( pListener ); }
+ };
+ 
+ class DeletionListener
+ {
+	 DeletionNotifier*	m_pNotifier;
+	 public:
+	 DeletionListener( DeletionNotifier* pNotifier )
+	 : 	m_pNotifier( pNotifier )
+		{
+			if( m_pNotifier )
+				m_pNotifier->addDel( this );
+		}
+	~DeletionListener()
+	{
+		if( m_pNotifier )
+			m_pNotifier->removeDel( this );
+	}
+	void deleted() { m_pNotifier = NULL; }
+	bool isDeleted() { return m_pNotifier == NULL; }
+ };
+
+ inline void DeletionNotifier::notifyDelete()
+ {
+	 for( std::list< DeletionListener* >::const_iterator it =
+	 		m_aListeners.begin(); it != m_aListeners.end(); ++it )
+		(*it)->deleted();
+			
+	 m_aListeners.clear();
+ }
+ 
+ } // namespace vcl
+ 
+ #endif // _VCL_IMPDEL_HXX
