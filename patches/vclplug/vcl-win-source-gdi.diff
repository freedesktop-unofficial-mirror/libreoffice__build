Index: vcl/win/source/gdi/MAKEFILE.MK
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/MAKEFILE.MK,v
retrieving revision 1.4
retrieving revision 1.7
diff -u -p -u -r1.4 -r1.7
--- vcl/win/source/gdi/MAKEFILE.MK	11 Apr 2003 17:35:54 -0000	1.4
+++ vcl/win/source/gdi/MAKEFILE.MK	10 May 2004 16:02:14 -0000	1.7
@@ -34,27 +83,13 @@ SLOFILES=   $(SLO)$/salgdi.obj   \
             $(SLO)$/salvd.obj    \
             $(SLO)$/salprn.obj   \
             $(SLO)$/salbmp.obj	 \
-            $(SLO)$/salogl.obj
-
-.IF "$(ENABLE_CTL)" != ""
-SLOFILES+=$(SLO)$/winlayout.obj
-.ENDIF
-
-.IF "$(GUI)" == "WNT"
-SLOFILES+=$(SLO)$/wntgdi.obj
-.ENDIF
+            $(SLO)$/salogl.obj	\
+            $(SLO)$/winlayout.obj	\
+            $(SLO)$/wntgdi.obj      \
+	        $(SLO)$/salnativewidgets-luna.obj
+            
 
 EXCEPTIONSFILES=	$(SLO)$/salprn.obj
-
-.IF "$(UPDATER)"=="YES"
-OBJFILES=   $(OBJ)$/salgdi.obj   \
-            $(OBJ)$/salgdi2.obj  \
-            $(OBJ)$/salgdi3.obj  \
-            $(OBJ)$/salvd.obj    \
-            $(OBJ)$/salprn.obj   \
-            $(OBJ)$/salbmp.obj	 \
-			$(OBJ)$/salogl.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/win/source/gdi/salbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salbmp.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/gdi/salbmp.cxx	28 Jun 2001 13:13:55 -0000	1.2
+++ vcl/win/source/gdi/salbmp.cxx	6 Jan 2004 14:54:30 -0000	1.4
@@ -63,29 +63,23 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALBMP_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 #include <string.h>
 
-#ifdef WIN
-#define BI_BITFIELDS	3
-#endif
-
 // -----------
 // - Inlines -
 // -----------
@@ -98,11 +92,11 @@ inline void ImplSetPixel4( const HPBYTE 
 				 ( rByte &= 0x0f, rByte |= ( cIndex << 4 ) );
 }
 
-// -------------
-// - SalBitmap -
-// -------------
+// ----------------
+// - WinSalBitmap -
+// ----------------
 
-SalBitmap::SalBitmap() :
+WinSalBitmap::WinSalBitmap() :
 		mhDIB		( 0 ),
 		mhDDB		( 0 ),
 		mnBitCount	( 0 )
@@ -111,16 +105,16 @@ SalBitmap::SalBitmap() :
 
 // ------------------------------------------------------------------
 
-SalBitmap::~SalBitmap()
+WinSalBitmap::~WinSalBitmap()
 {
 	Destroy();
 }
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( HANDLE hBitmap, BOOL bDIB, BOOL bCopyHandle )
+bool WinSalBitmap::Create( HANDLE hBitmap, bool bDIB, bool bCopyHandle )
 {
-	BOOL bRet = TRUE;
+	bool bRet = TRUE;
 
 	if( bDIB )
 		mhDIB = (HGLOBAL) ( bCopyHandle ? ImplCopyDIBOrDDB( hBitmap, TRUE ) : hBitmap );
@@ -169,9 +163,9 @@ BOOL SalBitmap::Create( HANDLE hBitmap, 
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+bool WinSalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
 
 	mhDIB = ImplCreateDIB( rSize, nBitCount, rPal );
 
@@ -187,9 +181,10 @@ BOOL SalBitmap::Create( const Size& rSiz
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBitmap )
+bool WinSalBitmap::Create( const SalBitmap& rSSalBitmap )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
 
 	if ( rSalBitmap.mhDIB || rSalBitmap.mhDDB )
 	{
@@ -215,15 +210,18 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
+bool WinSalBitmap::Create( const SalBitmap& rSSalBmp, SalGraphics* pSGraphics )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
+
+    const WinSalBitmap& rSalBmp = static_cast<const WinSalBitmap&>(rSSalBmp);
+    WinSalGraphics* pGraphics = static_cast<WinSalGraphics*>(pSGraphics);
 
 	if( rSalBmp.mhDIB )
 	{
 		PBITMAPINFO 		pBI = (PBITMAPINFO) GlobalLock( rSalBmp.mhDIB );
 		PBITMAPINFOHEADER	pBIH = (PBITMAPINFOHEADER) pBI;
-		HDC 				hDC  = pGraphics->maGraphicsData.mhDC;
+		HDC 				hDC  = pGraphics->mhDC;
 		HBITMAP 			hNewDDB;
 		BITMAP				aDDBInfo;
 		PBYTE				pBits = (PBYTE) pBI + *(DWORD*) pBI +
@@ -265,9 +263,11 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
+bool WinSalBitmap::Create( const SalBitmap& rSSalBmp, USHORT nNewBitCount )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
+
+    const WinSalBitmap& rSalBmp = static_cast<const WinSalBitmap&>(rSSalBmp);
 
 	if( rSalBmp.mhDDB )
 	{
@@ -315,7 +315,7 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // ------------------------------------------------------------------
 
-void SalBitmap::Destroy()
+void WinSalBitmap::Destroy()
 {
 	if( mhDIB )
 		GlobalFree( mhDIB );
@@ -328,7 +328,7 @@ void SalBitmap::Destroy()
 
 // ------------------------------------------------------------------
 
-USHORT SalBitmap::ImplGetDIBColorCount( HGLOBAL hDIB )
+USHORT WinSalBitmap::ImplGetDIBColorCount( HGLOBAL hDIB )
 {
 	USHORT nColors = 0;
 
@@ -358,7 +358,7 @@ USHORT SalBitmap::ImplGetDIBColorCount( 
 
 // ------------------------------------------------------------------
 
-HGLOBAL SalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBits, const BitmapPalette& rPal )
+HGLOBAL WinSalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBits, const BitmapPalette& rPal )
 {
 	DBG_ASSERT( nBits == 1 || nBits == 4 || nBits == 8 || nBits == 24, "Unsupported BitCount!" );
 
@@ -393,7 +393,7 @@ HGLOBAL SalBitmap::ImplCreateDIB( const 
 				const USHORT nMinCount = Min( nColors, rPal.GetEntryCount() );
 
 				if( nMinCount )
-					HMEMCPY( pBI->bmiColors, rPal.ImplGetColorBuffer(), nMinCount * sizeof( RGBQUAD ) );
+					memcpy( pBI->bmiColors, rPal.ImplGetColorBuffer(), nMinCount * sizeof( RGBQUAD ) );
 			}
 
 			GlobalUnlock( hDIB );
@@ -405,7 +405,7 @@ HGLOBAL SalBitmap::ImplCreateDIB( const 
 
 // ------------------------------------------------------------------
 
-HANDLE SalBitmap::ImplCopyDIBOrDDB( HANDLE hHdl, BOOL bDIB )
+HANDLE WinSalBitmap::ImplCopyDIBOrDDB( HANDLE hHdl, bool bDIB )
 {
 	HANDLE	hCopy = 0;
 
@@ -415,7 +415,7 @@ HANDLE SalBitmap::ImplCopyDIBOrDDB( HAND
 
 		if ( hCopy = GlobalAlloc( GHND, nSize  ) )
 		{
-			HMEMCPY( (LPSTR) GlobalLock( hCopy ), (LPSTR) GlobalLock( hHdl ), nSize );
+			memcpy( (LPSTR) GlobalLock( hCopy ), (LPSTR) GlobalLock( hHdl ), nSize );
 
 			GlobalUnlock( hCopy );
 			GlobalUnlock( hHdl );
@@ -451,7 +451,7 @@ HANDLE SalBitmap::ImplCopyDIBOrDDB( HAND
 
 // ------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::AcquireBuffer( BOOL bReadOnly )
+BitmapBuffer* WinSalBitmap::AcquireBuffer( bool bReadOnly )
 {
 	BitmapBuffer* pBuffer = NULL;
 
@@ -474,7 +474,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 				BYTE*				pOldBits = (PBYTE) pBI + nOffset;
 				BYTE*				pNewBits = (PBYTE) pNewBI + nOffset;
 
-				HMEMCPY( pNewBI, pBI, nOffset );
+				memcpy( pNewBI, pBI, nOffset );
 				pNewBIH->biCompression = 0;
 				ImplDecodeRLEBuffer( pOldBits, pNewBits, aSizePix, pBIH->biCompression == BI_RLE4 );
 
@@ -510,7 +510,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 					const USHORT nPalCount = ImplGetDIBColorCount( mhDIB );
 
 					pBuffer->maPalette.SetEntryCount( nPalCount );
-					HMEMCPY( pBuffer->maPalette.ImplGetColorBuffer(), pBI->bmiColors, nPalCount * sizeof( RGBQUAD ) );
+					memcpy( pBuffer->maPalette.ImplGetColorBuffer(), pBI->bmiColors, nPalCount * sizeof( RGBQUAD ) );
 					pBuffer->mpBits = (PBYTE) pBI + *(DWORD*) pBI + nPalCount * sizeof( RGBQUAD );
 				}
 				else if( ( pBIH->biBitCount == 16 ) || ( pBIH->biBitCount == 32 ) )
@@ -550,7 +550,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 
 // ------------------------------------------------------------------
 
-void SalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, BOOL bReadOnly )
+void WinSalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly )
 {
 	if( pBuffer )
 	{
@@ -561,7 +561,7 @@ void SalBitmap::ReleaseBuffer( BitmapBuf
 				PBITMAPINFO 	pBI = (PBITMAPINFO) GlobalLock( mhDIB );
 				const USHORT	nCount = pBuffer->maPalette.GetEntryCount();
 
-				HMEMCPY( pBI->bmiColors, pBuffer->maPalette.ImplGetColorBuffer(), nCount * sizeof( RGBQUAD ) );
+				memcpy( pBI->bmiColors, pBuffer->maPalette.ImplGetColorBuffer(), nCount * sizeof( RGBQUAD ) );
 				GlobalUnlock( mhDIB );
 			}
 
@@ -574,8 +574,8 @@ void SalBitmap::ReleaseBuffer( BitmapBuf
 
 // ------------------------------------------------------------------
 
-void SalBitmap::ImplDecodeRLEBuffer( const BYTE* pSrcBuf, BYTE* pDstBuf,
-									 const Size& rSizePixel, BOOL bRLE4 )
+void WinSalBitmap::ImplDecodeRLEBuffer( const BYTE* pSrcBuf, BYTE* pDstBuf,
+									 const Size& rSizePixel, bool bRLE4 )
 {
 	HPBYTE			pRLE = (HPBYTE) pSrcBuf;
 	HPBYTE			pDIB = (HPBYTE) pDstBuf;
@@ -587,7 +587,7 @@ void SalBitmap::ImplDecodeRLEBuffer( con
 	ULONG			nX = 0;
 	ULONG			i;
 	BYTE			cTmp;
-	BOOL			bEndDecoding = FALSE;
+	bool			bEndDecoding = FALSE;
 
 	if( pRLE && pDIB )
 	{
@@ -618,7 +618,7 @@ void SalBitmap::ImplDecodeRLEBuffer( con
 					}
 					else
 					{
-						HMEMCPY( &pDIB[ nX ], pRLE, nRunByte );
+						memcpy( &pDIB[ nX ], pRLE, nRunByte );
 						pRLE += nRunByte;
 						nX += nRunByte;
 
Index: vcl/win/source/gdi/salgdi.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salgdi.cxx,v
retrieving revision 1.13.112.1
retrieving revision 1.20
diff -u -p -u -r1.13.112.1 -r1.20
--- vcl/win/source/gdi/salgdi.cxx	19 Nov 2003 15:42:24 -0000	1.13.112.1
+++ vcl/win/source/gdi/salgdi.cxx	18 Jun 2004 15:06:40 -0000	1.20
@@ -65,27 +65,30 @@
 #ifndef _SVWIN_H
 #include <tools/svwin.h>
 #endif
-#define _SV_SALGDI_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
+#endif
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include "poly.hxx"
+#ifndef _RTL_STRINGBUF_HXX
+#include <rtl/strbuf.hxx>
 #endif
 
+using namespace rtl;
+
 // =======================================================================
 
 // comment out to prevent use of beziers on GDI functions
@@ -561,7 +564,7 @@ static SalColor ImplGetROPSalColor( SalR
 
 // =======================================================================
 
-void ImplSalInitGraphics( SalGraphicsData* pData )
+void ImplSalInitGraphics( WinSalGraphics* pData )
 {
 	// Beim Printer berechnen wir die minimale Linienstaerke
 	if ( pData->mbPrinter )
@@ -580,7 +583,7 @@ void ImplSalInitGraphics( SalGraphicsDat
 
 // -----------------------------------------------------------------------
 
-void ImplSalDeInitGraphics( SalGraphicsData* pData )
+void ImplSalDeInitGraphics( WinSalGraphics* pData )
 {
 	// Default Objekte selektieren
 	if ( pData->mhDefPen )
@@ -665,12 +668,12 @@ void ImplClearHDCCache( SalData* pData )
 void ImplPreparePolyDraw( bool						bCloseFigures,
                           ULONG 					nPoly,
                           const ULONG* 				pPoints,
-                          const SalPoint* const* 	pPtAry, 
+                          const SalPoint* const* 	pPtAry,
                           const BYTE* const* 		pFlgAry,
                           POINT* 					pWinPointAry,
                           BYTE* 					pWinFlagAry		)
 {
-    ULONG nCurrPoly;    
+    ULONG nCurrPoly;
     for( nCurrPoly=0; nCurrPoly<nPoly; ++nCurrPoly )
     {
         const POINT* pCurrPoint = reinterpret_cast<const POINT*>( *pPtAry++ );
@@ -691,9 +694,9 @@ void ImplPreparePolyDraw( bool						bClo
                 // #102067# Check existence of flag array
                 if( bHaveFlagArray &&
                     ( nCurrPoint + 2 ) < nCurrPoints )
-                { 
+                {
                     BYTE P4( pCurrFlag[ 2 ] );
-                    
+
                     if( ( POLY_CONTROL == pCurrFlag[ 0 ] ) &&
                         ( POLY_CONTROL == pCurrFlag[ 1 ] ) &&
                         ( POLY_NORMAL == P4 || POLY_SMOOTH == P4 || POLY_SYMMTR == P4 ) )
@@ -701,11 +704,11 @@ void ImplPreparePolyDraw( bool						bClo
                         // control point one
                         *pWinPointAry++ = *pCurrPoint++;
                         *pWinFlagAry++  = PT_BEZIERTO;
-                        
+
                         // control point two
                         *pWinPointAry++ = *pCurrPoint++;
                         *pWinFlagAry++  = PT_BEZIERTO;
-                        
+
                         // end point
                         *pWinPointAry++ = *pCurrPoint++;
                         *pWinFlagAry++  = PT_BEZIERTO;
@@ -727,7 +730,7 @@ void ImplPreparePolyDraw( bool						bClo
             if( bCloseFigures )
                 pWinFlagAry[-1] |= PT_CLOSEFIGURE;
         }
-    }    
+    }
 }
 
 // =======================================================================
@@ -762,105 +765,105 @@ void ImplRenderPath( HDC hdc, ULONG nPoi
 
 // =======================================================================
 
-SalGraphics::SalGraphics()
+WinSalGraphics::WinSalGraphics()
 {
     for( int i = 0; i < MAX_FALLBACK; ++i )
-        maGraphicsData.mhFonts[ i ] = 0;
-	maGraphicsData.mhDC 				= 0;
-	maGraphicsData.mhPen				= 0;
-	maGraphicsData.mhBrush				= 0;
-	maGraphicsData.mhRegion 			= 0;
-	maGraphicsData.mhDefPen 			= 0;
-	maGraphicsData.mhDefBrush			= 0;
-	maGraphicsData.mhDefFont			= 0;
-	maGraphicsData.mhDefPal 			= 0;
-	maGraphicsData.mpStdClipRgnData 	= NULL;
-	maGraphicsData.mpLogFont			= NULL;
-	maGraphicsData.mpFontCharSets		= NULL;
-	maGraphicsData.mnFontCharSetCount	= 0;
-	maGraphicsData.mpFontKernPairs		= NULL;
-	maGraphicsData.mnFontKernPairCount	= 0;
-	maGraphicsData.mbFontKernInit		= FALSE;
-	maGraphicsData.mbXORMode			= FALSE;
-	maGraphicsData.mnPenWidth			= GSL_PEN_WIDTH;
+        mhFonts[ i ] = 0;
+	mhDC 				= 0;
+	mhPen				= 0;
+	mhBrush				= 0;
+	mhRegion 			= 0;
+	mhDefPen 			= 0;
+	mhDefBrush			= 0;
+	mhDefFont			= 0;
+	mhDefPal 			= 0;
+	mpStdClipRgnData 	= NULL;
+	mpLogFont			= NULL;
+	mpFontCharSets		= NULL;
+	mnFontCharSetCount	= 0;
+	mpFontKernPairs		= NULL;
+	mnFontKernPairCount	= 0;
+	mbFontKernInit		= FALSE;
+	mbXORMode			= FALSE;
+	mnPenWidth			= GSL_PEN_WIDTH;
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics::~SalGraphics()
+WinSalGraphics::~WinSalGraphics()
 {
 	// free obsolete GDI objekts
     for( int i = 0; i < MAX_FALLBACK; ++i )
-        if( maGraphicsData.mhFonts[ i ] )
-            DeleteFont( maGraphicsData.mhFonts[ i ] );
+        if( mhFonts[ i ] )
+            DeleteFont( mhFonts[ i ] );
 
-	if ( maGraphicsData.mhPen )
+	if ( mhPen )
 	{
-		if ( !maGraphicsData.mbStockPen )
-			DeletePen( maGraphicsData.mhPen );
+		if ( !mbStockPen )
+			DeletePen( mhPen );
 	}
-	if ( maGraphicsData.mhBrush )
+	if ( mhBrush )
 	{
-		if ( !maGraphicsData.mbStockBrush )
-			DeleteBrush( maGraphicsData.mhBrush );
+		if ( !mbStockBrush )
+			DeleteBrush( mhBrush );
 	}
 
-	if ( maGraphicsData.mhRegion )
+	if ( mhRegion )
 	{
-		DeleteRegion( maGraphicsData.mhRegion );
-		maGraphicsData.mhRegion = 0;
+		DeleteRegion( mhRegion );
+		mhRegion = 0;
 	}
 
 	// Cache-Daten zerstoeren
-	if ( maGraphicsData.mpStdClipRgnData )
-		delete [] maGraphicsData.mpStdClipRgnData;
+	if ( mpStdClipRgnData )
+		delete [] mpStdClipRgnData;
 
-	if ( maGraphicsData.mpLogFont )
-		delete maGraphicsData.mpLogFont;
+	if ( mpLogFont )
+		delete mpLogFont;
 
-	if ( maGraphicsData.mpFontCharSets )
-		delete maGraphicsData.mpFontCharSets;
+	if ( mpFontCharSets )
+		delete mpFontCharSets;
 
-	if ( maGraphicsData.mpFontKernPairs )
-		delete maGraphicsData.mpFontKernPairs;
+	if ( mpFontKernPairs )
+		delete mpFontKernPairs;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetResolution( long& rDPIX, long& rDPIY )
+void WinSalGraphics::GetResolution( long& rDPIX, long& rDPIY )
 {
-	rDPIX = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSX );
-	rDPIY = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSY );
+	rDPIX = GetDeviceCaps( mhDC, LOGPIXELSX );
+	rDPIY = GetDeviceCaps( mhDC, LOGPIXELSY );
 
     // #111139# this fixes the symptom of div by zero on startup
-    // however, printing will fail most likely as communication with 
+    // however, printing will fail most likely as communication with
     // the printer seems not to work in this case
     if( !rDPIX || !rDPIY )
-        rDPIX = rDPIY = 600;   
+        rDPIX = rDPIY = 600;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetScreenFontResolution( long& rDPIX, long& rDPIY )
+void WinSalGraphics::GetScreenFontResolution( long& rDPIX, long& rDPIY )
 {
-	rDPIX = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSX );
-	rDPIY = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSY );
+	rDPIX = GetDeviceCaps( mhDC, LOGPIXELSX );
+	rDPIY = GetDeviceCaps( mhDC, LOGPIXELSY );
 }
 
 // -----------------------------------------------------------------------
 
-USHORT SalGraphics::GetBitCount()
+USHORT WinSalGraphics::GetBitCount()
 {
-	return (USHORT)GetDeviceCaps( maGraphicsData.mhDC, BITSPIXEL );
+	return (USHORT)GetDeviceCaps( mhDC, BITSPIXEL );
 }
 
 // -----------------------------------------------------------------------
 
-long SalGraphics::GetGraphicsWidth()
+long WinSalGraphics::GetGraphicsWidth()
 {
-    if( maGraphicsData.mhWnd && IsWindow( maGraphicsData.mhWnd ) )
+    if( mhWnd && IsWindow( mhWnd ) )
     {
-        SalFrame* pFrame = GetWindowPtr( maGraphicsData.mhWnd );
+        WinSalFrame* pFrame = GetWindowPtr( mhWnd );
         if( pFrame )
         {
             if( pFrame->maGeometry.nWidth )
@@ -869,7 +872,7 @@ long SalGraphics::GetGraphicsWidth()
             {
                 // TODO: perhaps not needed, maGeometry should always be up-to-date
                 RECT aRect;
-                GetClientRect( maGraphicsData.mhWnd, &aRect );
+                GetClientRect( mhWnd, &aRect );
                 return aRect.right;
             }
         }
@@ -880,64 +883,64 @@ long SalGraphics::GetGraphicsWidth()
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::ResetClipRegion()
+void WinSalGraphics::ResetClipRegion()
 {
-	if ( maGraphicsData.mhRegion )
+	if ( mhRegion )
 	{
-		DeleteRegion( maGraphicsData.mhRegion );
-		maGraphicsData.mhRegion = 0;
+		DeleteRegion( mhRegion );
+		mhRegion = 0;
 	}
 
-	SelectClipRgn( maGraphicsData.mhDC, 0 );
+	SelectClipRgn( mhDC, 0 );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::BeginSetClipRegion( ULONG nRectCount )
+void WinSalGraphics::BeginSetClipRegion( ULONG nRectCount )
 {
-	if ( maGraphicsData.mhRegion )
+	if ( mhRegion )
 	{
-		DeleteRegion( maGraphicsData.mhRegion );
-		maGraphicsData.mhRegion = 0;
+		DeleteRegion( mhRegion );
+		mhRegion = 0;
 	}
 
 	ULONG nRectBufSize = sizeof(RECT)*nRectCount;
 	if ( nRectCount < SAL_CLIPRECT_COUNT )
 	{
-		if ( !maGraphicsData.mpStdClipRgnData )
-			maGraphicsData.mpStdClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+(SAL_CLIPRECT_COUNT*sizeof(RECT))];
-		maGraphicsData.mpClipRgnData = maGraphicsData.mpStdClipRgnData;
+		if ( !mpStdClipRgnData )
+			mpStdClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+(SAL_CLIPRECT_COUNT*sizeof(RECT))];
+		mpClipRgnData = mpStdClipRgnData;
 	}
 	else
-		maGraphicsData.mpClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+nRectBufSize];
-	maGraphicsData.mpClipRgnData->rdh.dwSize	= sizeof( RGNDATAHEADER );
-	maGraphicsData.mpClipRgnData->rdh.iType 	= RDH_RECTANGLES;
-	maGraphicsData.mpClipRgnData->rdh.nCount	= nRectCount;
-	maGraphicsData.mpClipRgnData->rdh.nRgnSize	= nRectBufSize;
-	SetRectEmpty( &(maGraphicsData.mpClipRgnData->rdh.rcBound) );
-	maGraphicsData.mpNextClipRect			= (RECT*)(&(maGraphicsData.mpClipRgnData->Buffer));
-	maGraphicsData.mbFirstClipRect			= TRUE;
+		mpClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+nRectBufSize];
+	mpClipRgnData->rdh.dwSize	= sizeof( RGNDATAHEADER );
+	mpClipRgnData->rdh.iType 	= RDH_RECTANGLES;
+	mpClipRgnData->rdh.nCount	= nRectCount;
+	mpClipRgnData->rdh.nRgnSize	= nRectBufSize;
+	SetRectEmpty( &(mpClipRgnData->rdh.rcBound) );
+	mpNextClipRect			= (RECT*)(&(mpClipRgnData->Buffer));
+	mbFirstClipRect			= TRUE;
 }
 
 
 // -----------------------------------------------------------------------
 
-BOOL SalGraphics::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice* )
+BOOL WinSalGraphics::unionClipRegion( long nX, long nY, long nWidth, long nHeight )
 {
 	if ( nWidth && nHeight )
 	{
-		RECT*		pRect = maGraphicsData.mpNextClipRect;
-		RECT*		pBoundRect = &(maGraphicsData.mpClipRgnData->rdh.rcBound);
+		RECT*		pRect = mpNextClipRect;
+		RECT*		pBoundRect = &(mpClipRgnData->rdh.rcBound);
 		long		nRight = nX + nWidth;
 		long		nBottom = nY + nHeight;
 
-		if ( maGraphicsData.mbFirstClipRect )
+		if ( mbFirstClipRect )
 		{
 			pBoundRect->left	= nX;
 			pBoundRect->top 	= nY;
 			pBoundRect->right	= nRight;
 			pBoundRect->bottom	= nBottom;
-			maGraphicsData.mbFirstClipRect = FALSE;
+			mbFirstClipRect = FALSE;
 		}
 		else
 		{
@@ -958,12 +961,12 @@ BOOL SalGraphics::UnionClipRegion( long 
 		pRect->top		= (int)nY;
 		pRect->right	= (int)nRight;
 		pRect->bottom	= (int)nBottom;
-		maGraphicsData.mpNextClipRect++;
+		mpNextClipRect++;
 	}
 	else
 	{
-		maGraphicsData.mpClipRgnData->rdh.nCount--;
-		maGraphicsData.mpClipRgnData->rdh.nRgnSize -= sizeof( RECT );
+		mpClipRgnData->rdh.nCount--;
+		mpClipRgnData->rdh.nRgnSize -= sizeof( RECT );
 	}
 
 	return TRUE;
@@ -971,73 +974,73 @@ BOOL SalGraphics::UnionClipRegion( long 
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::EndSetClipRegion()
+void WinSalGraphics::EndSetClipRegion()
 {
 	// create clip region from ClipRgnData
-	if ( maGraphicsData.mpClipRgnData->rdh.nCount == 1 )
+	if ( mpClipRgnData->rdh.nCount == 1 )
 	{
-		RECT* pRect = &(maGraphicsData.mpClipRgnData->rdh.rcBound);
-		maGraphicsData.mhRegion = CreateRectRgn( pRect->left, pRect->top,
+		RECT* pRect = &(mpClipRgnData->rdh.rcBound);
+		mhRegion = CreateRectRgn( pRect->left, pRect->top,
 												 pRect->right, pRect->bottom );
 	}
 	else
 	{
-		ULONG nSize = maGraphicsData.mpClipRgnData->rdh.nRgnSize+sizeof(RGNDATAHEADER);
-		maGraphicsData.mhRegion = ExtCreateRegion( NULL, nSize, maGraphicsData.mpClipRgnData );
+		ULONG nSize = mpClipRgnData->rdh.nRgnSize+sizeof(RGNDATAHEADER);
+		mhRegion = ExtCreateRegion( NULL, nSize, mpClipRgnData );
 
 		// if ExtCreateRegion(...) is not supported
-		if( !maGraphicsData.mhRegion )
+		if( !mhRegion )
 		{
-			RGNDATAHEADER* pHeader = (RGNDATAHEADER*) maGraphicsData.mpClipRgnData;
+			RGNDATAHEADER* pHeader = (RGNDATAHEADER*) mpClipRgnData;
 
 			if( pHeader->nCount )
 			{
-				RECT* pRect = (RECT*) maGraphicsData.mpClipRgnData->Buffer;
-				maGraphicsData.mhRegion = CreateRectRgn( pRect->left, pRect->top, pRect->right, pRect->bottom );
+				RECT* pRect = (RECT*) mpClipRgnData->Buffer;
+				mhRegion = CreateRectRgn( pRect->left, pRect->top, pRect->right, pRect->bottom );
 				pRect++;
 
 				for( ULONG n = 1; n < pHeader->nCount; n++, pRect++ )
 				{
 					HRGN hRgn = CreateRectRgn( pRect->left, pRect->top, pRect->right, pRect->bottom );
-					CombineRgn( maGraphicsData.mhRegion, maGraphicsData.mhRegion, hRgn, RGN_OR );
+					CombineRgn( mhRegion, mhRegion, hRgn, RGN_OR );
 					DeleteRegion( hRgn );
 				}
 			}
 		}
 
-		if ( maGraphicsData.mpClipRgnData != maGraphicsData.mpStdClipRgnData )
-			delete [] maGraphicsData.mpClipRgnData;
+		if ( mpClipRgnData != mpStdClipRgnData )
+			delete [] mpClipRgnData;
 	}
 
-	SelectClipRgn( maGraphicsData.mhDC, maGraphicsData.mhRegion );
+	SelectClipRgn( mhDC, mhRegion );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetLineColor()
+void WinSalGraphics::SetLineColor()
 {
 	// create and select new pen
 	HPEN hNewPen = GetStockPen( NULL_PEN );
-	HPEN hOldPen = SelectPen( maGraphicsData.mhDC, hNewPen );
+	HPEN hOldPen = SelectPen( mhDC, hNewPen );
 
 	// destory or save old pen
-	if ( maGraphicsData.mhPen )
+	if ( mhPen )
 	{
-		if ( !maGraphicsData.mbStockPen )
-			DeletePen( maGraphicsData.mhPen );
+		if ( !mbStockPen )
+			DeletePen( mhPen );
 	}
 	else
-		maGraphicsData.mhDefPen = hOldPen;
+		mhDefPen = hOldPen;
 
 	// set new data
-	maGraphicsData.mhPen		= hNewPen;
-	maGraphicsData.mbPen		= FALSE;
-	maGraphicsData.mbStockPen	= TRUE;
+	mhPen		= hNewPen;
+	mbPen		= FALSE;
+	mbStockPen	= TRUE;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetLineColor( SalColor nSalColor )
+void WinSalGraphics::SetLineColor( SalColor nSalColor )
 {
 	COLORREF	nPenColor = PALETTERGB( SALCOLOR_RED( nSalColor ),
 										SALCOLOR_GREEN( nSalColor ),
@@ -1047,7 +1050,7 @@ void SalGraphics::SetLineColor( SalColor
 
 	// search for stock pen (only screen, because printer have problems,
 	// when we use stock objects)
-	if ( !maGraphicsData.mbPrinter )
+	if ( !mbPrinter )
 	{
 		SalData* pSalData = GetSalData();
 		for ( USHORT i = 0; i < pSalData->mnStockPenCount; i++ )
@@ -1064,61 +1067,61 @@ void SalGraphics::SetLineColor( SalColor
 	// create new pen
 	if ( !hNewPen )
 	{
-		if ( !maGraphicsData.mbPrinter )
+		if ( !mbPrinter )
 		{
 			if ( GetSalData()->mhDitherPal && ImplIsSysColorEntry( nSalColor ) )
 				nPenColor = PALRGB_TO_RGB( nPenColor );
 		}
 
-		hNewPen = CreatePen( PS_SOLID, maGraphicsData.mnPenWidth, nPenColor );
+		hNewPen = CreatePen( PS_SOLID, mnPenWidth, nPenColor );
 		bStockPen = FALSE;
 	}
 
 	// select new pen
-	HPEN hOldPen = SelectPen( maGraphicsData.mhDC, hNewPen );
+	HPEN hOldPen = SelectPen( mhDC, hNewPen );
 
 	// destory or save old pen
-	if ( maGraphicsData.mhPen )
+	if ( mhPen )
 	{
-		if ( !maGraphicsData.mbStockPen )
-			DeletePen( maGraphicsData.mhPen );
+		if ( !mbStockPen )
+			DeletePen( mhPen );
 	}
 	else
-		maGraphicsData.mhDefPen = hOldPen;
+		mhDefPen = hOldPen;
 
 	// set new data
-	maGraphicsData.mnPenColor	= nPenColor;
-	maGraphicsData.mhPen		= hNewPen;
-	maGraphicsData.mbPen		= TRUE;
-	maGraphicsData.mbStockPen	= bStockPen;
+	mnPenColor	= nPenColor;
+	mhPen		= hNewPen;
+	mbPen		= TRUE;
+	mbStockPen	= bStockPen;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetFillColor()
+void WinSalGraphics::SetFillColor()
 {
 	// create and select new brush
 	HBRUSH hNewBrush = GetStockBrush( NULL_BRUSH );
-	HBRUSH hOldBrush = SelectBrush( maGraphicsData.mhDC, hNewBrush );
+	HBRUSH hOldBrush = SelectBrush( mhDC, hNewBrush );
 
 	// destory or save old brush
-	if ( maGraphicsData.mhBrush )
+	if ( mhBrush )
 	{
-		if ( !maGraphicsData.mbStockBrush )
-			DeleteBrush( maGraphicsData.mhBrush );
+		if ( !mbStockBrush )
+			DeleteBrush( mhBrush );
 	}
 	else
-		maGraphicsData.mhDefBrush = hOldBrush;
+		mhDefBrush = hOldBrush;
 
 	// set new data
-	maGraphicsData.mhBrush		= hNewBrush;
-	maGraphicsData.mbBrush		= FALSE;
-	maGraphicsData.mbStockBrush = TRUE;
+	mhBrush		= hNewBrush;
+	mbBrush		= FALSE;
+	mbStockBrush = TRUE;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetFillColor( SalColor nSalColor )
+void WinSalGraphics::SetFillColor( SalColor nSalColor )
 {
 	SalData*	pSalData	= GetSalData();
 	BYTE		nRed		= SALCOLOR_RED( nSalColor );
@@ -1130,7 +1133,7 @@ void SalGraphics::SetFillColor( SalColor
 
 	// search for stock brush (only screen, because printer have problems,
 	// when we use stock objects)
-	if ( !maGraphicsData.mbPrinter )
+	if ( !mbPrinter )
 	{
 		for ( USHORT i = 0; i < pSalData->mnStockBrushCount; i++ )
 		{
@@ -1146,7 +1149,7 @@ void SalGraphics::SetFillColor( SalColor
 	// create new brush
 	if ( !hNewBrush )
 	{
-		if ( maGraphicsData.mbPrinter || !pSalData->mhDitherDIB )
+		if ( mbPrinter || !pSalData->mhDitherDIB )
 			hNewBrush = CreateSolidBrush( nBrushColor );
 		else
 		{
@@ -1202,92 +1205,92 @@ void SalGraphics::SetFillColor( SalColor
 	}
 
 	// select new brush
-	HBRUSH hOldBrush = SelectBrush( maGraphicsData.mhDC, hNewBrush );
+	HBRUSH hOldBrush = SelectBrush( mhDC, hNewBrush );
 
 	// destory or save old brush
-	if ( maGraphicsData.mhBrush )
+	if ( mhBrush )
 	{
-		if ( !maGraphicsData.mbStockBrush )
-			DeleteBrush( maGraphicsData.mhBrush );
+		if ( !mbStockBrush )
+			DeleteBrush( mhBrush );
 	}
 	else
-		maGraphicsData.mhDefBrush = hOldBrush;
+		mhDefBrush = hOldBrush;
 
 	// set new data
-	maGraphicsData.mnBrushColor = nBrushColor;
-	maGraphicsData.mhBrush		= hNewBrush;
-	maGraphicsData.mbBrush		= FALSE;
-	maGraphicsData.mbStockBrush = bStockBrush;
+	mnBrushColor = nBrushColor;
+	mhBrush		= hNewBrush;
+	mbBrush		= FALSE;
+	mbStockBrush = bStockBrush;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetXORMode( BOOL bSet )
+void WinSalGraphics::SetXORMode( BOOL bSet )
 {
-	maGraphicsData.mbXORMode = bSet;
-	::SetROP2( maGraphicsData.mhDC, bSet ? R2_XORPEN : R2_COPYPEN );
+	mbXORMode = bSet;
+	::SetROP2( mhDC, bSet ? R2_XORPEN : R2_COPYPEN );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetROPLineColor( SalROPColor nROPColor )
+void WinSalGraphics::SetROPLineColor( SalROPColor nROPColor )
 {
 	SetLineColor( ImplGetROPSalColor( nROPColor ) );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetROPFillColor( SalROPColor nROPColor )
+void WinSalGraphics::SetROPFillColor( SalROPColor nROPColor )
 {
 	SetFillColor( ImplGetROPSalColor( nROPColor ) );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPixel( long nX, long nY, const OutputDevice* )
+void WinSalGraphics::drawPixel( long nX, long nY )
 {
-	if ( maGraphicsData.mbXORMode )
+	if ( mbXORMode )
 	{
-		HBRUSH	hBrush = CreateSolidBrush( maGraphicsData.mnPenColor );
-		HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
-		PatBlt( maGraphicsData.mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		HBRUSH	hBrush = CreateSolidBrush( mnPenColor );
+		HBRUSH	hOldBrush = SelectBrush( mhDC, hBrush );
+		PatBlt( mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
+		SelectBrush( mhDC, hOldBrush );
 		DeleteBrush( hBrush );
 	}
 	else
-		SetPixel( maGraphicsData.mhDC, (int)nX, (int)nY, maGraphicsData.mnPenColor );
+		SetPixel( mhDC, (int)nX, (int)nY, mnPenColor );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice*  )
+void WinSalGraphics::drawPixel( long nX, long nY, SalColor nSalColor )
 {
 	COLORREF nCol = PALETTERGB( SALCOLOR_RED( nSalColor ),
 								SALCOLOR_GREEN( nSalColor ),
 								SALCOLOR_BLUE( nSalColor ) );
 
-	if ( !maGraphicsData.mbPrinter &&
+	if ( !mbPrinter &&
 		 GetSalData()->mhDitherPal &&
 		 ImplIsSysColorEntry( nSalColor ) )
 		nCol = PALRGB_TO_RGB( nCol );
 
-	if ( maGraphicsData.mbXORMode )
+	if ( mbXORMode )
 	{
 		HBRUSH	hBrush = CreateSolidBrush( nCol );
-		HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
-		PatBlt( maGraphicsData.mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		HBRUSH	hOldBrush = SelectBrush( mhDC, hBrush );
+		PatBlt( mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
+		SelectBrush( mhDC, hOldBrush );
 		DeleteBrush( hBrush );
 	}
 	else
-		::SetPixel( maGraphicsData.mhDC, (int)nX, (int)nY, nCol );
+		::SetPixel( mhDC, (int)nX, (int)nY, nCol );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice* )
+void WinSalGraphics::drawLine( long nX1, long nY1, long nX2, long nY2 )
 {
-	MoveToEx( maGraphicsData.mhDC, (int)nX1, (int)nY1, NULL );
+	MoveToEx( mhDC, (int)nX1, (int)nY1, NULL );
 
 	// we must paint the endpoint
 	int bPaintEnd = TRUE;
@@ -1308,33 +1311,33 @@ void SalGraphics::DrawLine( long nX1, lo
 			nX2--;
 	}
 
-	LineTo( maGraphicsData.mhDC, (int)nX2, (int)nY2 );
+	LineTo( mhDC, (int)nX2, (int)nY2 );
 
-	if ( bPaintEnd && !maGraphicsData.mbPrinter )
+	if ( bPaintEnd && !mbPrinter )
 	{
-		if ( maGraphicsData.mbXORMode )
+		if ( mbXORMode )
 		{
-			HBRUSH	hBrush = CreateSolidBrush( maGraphicsData.mnPenColor );
-			HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
-			PatBlt( maGraphicsData.mhDC, (int)nX2, (int)nY2, (int)1, (int)1, PATINVERT );
-			SelectBrush( maGraphicsData.mhDC, hOldBrush );
+			HBRUSH	hBrush = CreateSolidBrush( mnPenColor );
+			HBRUSH	hOldBrush = SelectBrush( mhDC, hBrush );
+			PatBlt( mhDC, (int)nX2, (int)nY2, (int)1, (int)1, PATINVERT );
+			SelectBrush( mhDC, hOldBrush );
 			DeleteBrush( hBrush );
 		}
 		else
-			SetPixel( maGraphicsData.mhDC, (int)nX2, (int)nY2, maGraphicsData.mnPenColor );
+			SetPixel( mhDC, (int)nX2, (int)nY2, mnPenColor );
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice* )
+void WinSalGraphics::drawRect( long nX, long nY, long nWidth, long nHeight )
 {
-	if ( !maGraphicsData.mbPen )
+	if ( !mbPen )
 	{
-		if ( !maGraphicsData.mbPrinter )
+		if ( !mbPrinter )
 		{
-			PatBlt( maGraphicsData.mhDC, (int)nX, (int)nY, (int)nWidth, (int)nHeight,
-					maGraphicsData.mbXORMode ? PATINVERT : PATCOPY );
+			PatBlt( mhDC, (int)nX, (int)nY, (int)nWidth, (int)nHeight,
+					mbXORMode ? PATINVERT : PATCOPY );
 		}
 		else
 		{
@@ -1343,47 +1346,47 @@ void SalGraphics::DrawRect( long nX, lon
 			aWinRect.top	= nY;
 			aWinRect.right	= nX+nWidth;
 			aWinRect.bottom = nY+nHeight;
-			::FillRect( maGraphicsData.mhDC, &aWinRect, maGraphicsData.mhBrush );
+			::FillRect( mhDC, &aWinRect, mhBrush );
 		}
 	}
 	else
-		WIN_Rectangle( maGraphicsData.mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
+		WIN_Rectangle( mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice* )
+void WinSalGraphics::drawPolyLine( ULONG nPoints, const SalPoint* pPtAry )
 {
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyLine(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyLine(): POINT != SalPoint" );
 
 	POINT* pWinPtAry = (POINT*)pPtAry;
 	// Wegen Windows 95 und der Beschraenkung auf eine maximale Anzahl
 	// von Punkten
-	if ( !Polyline( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-		Polyline( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+	if ( !Polyline( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+		Polyline( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice* )
+void WinSalGraphics::drawPolygon( ULONG nPoints, const SalPoint* pPtAry )
 {
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolygon(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolygon(): POINT != SalPoint" );
 
 	POINT* pWinPtAry = (POINT*)pPtAry;
 	// Wegen Windows 95 und der Beschraenkung auf eine maximale Anzahl
 	// von Punkten
-	if ( !WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-		WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+	if ( !WIN_Polygon( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+		WIN_Polygon( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints,
-								   PCONSTSALPOINT* pPtAry, const OutputDevice* )
+void WinSalGraphics::drawPolyPolygon( ULONG nPoly, const ULONG* pPoints,
+								   PCONSTSALPOINT* pPtAry )
 {
 	UINT	aWinPointAry[SAL_POLYPOLYCOUNT_STACKBUF];
 	UINT*	pWinPointAry;
@@ -1411,7 +1414,7 @@ void SalGraphics::DrawPolyPolygon( ULONG
 		pWinPointAryAry = new POINT[nPolyPolyPoints];
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyPolygon(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyPolygon(): POINT != SalPoint" );
 	const SalPoint* pPolyAry;
 	UINT			n = 0;
 	for ( i = 0; i < (UINT)nPoly; i++ )
@@ -1423,7 +1426,7 @@ void SalGraphics::DrawPolyPolygon( ULONG
 		n += nPoints;
 	}
 
-	if ( !WIN_PolyPolygon( maGraphicsData.mhDC, pWinPointAryAry, (int*)pWinPointAry, (UINT)nPoly ) &&
+	if ( !WIN_PolyPolygon( mhDC, pWinPointAryAry, (int*)pWinPointAry, (UINT)nPoly ) &&
 		 (nPolyPolyPoints > MAX_64KSALPOINTS) )
 	{
 		nPolyPolyPoints  = 0;
@@ -1438,9 +1441,9 @@ void SalGraphics::DrawPolyPolygon( ULONG
 		if ( pWinPointAry[(UINT)nPoly] > MAX_64KSALPOINTS )
 			pWinPointAry[(UINT)nPoly] = MAX_64KSALPOINTS;
 		if ( nPoly == 1 )
-			WIN_Polygon( maGraphicsData.mhDC, pWinPointAryAry, *pWinPointAry );
+			WIN_Polygon( mhDC, pWinPointAryAry, *pWinPointAry );
 		else
-			WIN_PolyPolygon( maGraphicsData.mhDC, pWinPointAryAry, (int*)pWinPointAry, nPoly );
+			WIN_PolyPolygon( mhDC, pWinPointAryAry, (int*)pWinPointAry, nPoly );
 	}
 
 	if ( pWinPointAry != aWinPointAry )
@@ -1455,14 +1458,14 @@ void SalGraphics::DrawPolyPolygon( ULONG
 
 // -----------------------------------------------------------------------
 
-sal_Bool SalGraphics::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool WinSalGraphics::drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
 #ifdef USE_GDI_BEZIERS
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyLineBezier(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyLineBezier(): POINT != SalPoint" );
 
-    ImplRenderPath( maGraphicsData.mhDC, nPoints, pPtAry, pFlgAry );
+    ImplRenderPath( mhDC, nPoints, pPtAry, pFlgAry );
 
     return sal_True;
 #else
@@ -1472,12 +1475,12 @@ sal_Bool SalGraphics::DrawPolyLineBezier
 
 // -----------------------------------------------------------------------
 
-sal_Bool SalGraphics::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool WinSalGraphics::drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
 #ifdef USE_GDI_BEZIERS
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolygonBezier(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolygonBezier(): POINT != SalPoint" );
 
     POINT	aStackAry1[SAL_POLY_STACKBUF];
     BYTE	aStackAry2[SAL_POLY_STACKBUF];
@@ -1498,13 +1501,13 @@ sal_Bool SalGraphics::DrawPolygonBezier(
 
     sal_Bool bRet( sal_False );
 
-    if( BeginPath( maGraphicsData.mhDC ) )
+    if( BeginPath( mhDC ) )
     {
-        PolyDraw(maGraphicsData.mhDC, pWinPointAry, pWinFlagAry, nPoints);
+        PolyDraw(mhDC, pWinPointAry, pWinFlagAry, nPoints);
 
-        if( EndPath( maGraphicsData.mhDC ) )
+        if( EndPath( mhDC ) )
         {
-            if( StrokeAndFillPath( maGraphicsData.mhDC ) )
+            if( StrokeAndFillPath( mhDC ) )
                 bRet = sal_True;
         }
     }
@@ -1514,7 +1517,7 @@ sal_Bool SalGraphics::DrawPolygonBezier(
         delete [] pWinPointAry;
         delete [] pWinFlagAry;
     }
-    
+
     return bRet;
 #else
     return sal_False;
@@ -1523,13 +1526,13 @@ sal_Bool SalGraphics::DrawPolygonBezier(
 
 // -----------------------------------------------------------------------
 
-sal_Bool SalGraphics::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
-                                             const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice* )
+sal_Bool WinSalGraphics::drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+                                             const SalPoint* const* pPtAry, const BYTE* const* pFlgAry )
 {
 #ifdef USE_GDI_BEZIERS
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyPolygonBezier(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyPolygonBezier(): POINT != SalPoint" );
 
     ULONG nCurrPoly, nTotalPoints;
     const ULONG* pCurrPoints = pPoints;
@@ -1555,13 +1558,13 @@ sal_Bool SalGraphics::DrawPolyPolygonBez
 
     sal_Bool bRet( sal_False );
 
-    if( BeginPath( maGraphicsData.mhDC ) )
+    if( BeginPath( mhDC ) )
     {
-        PolyDraw(maGraphicsData.mhDC, pWinPointAry, pWinFlagAry, nTotalPoints);
+        PolyDraw(mhDC, pWinPointAry, pWinFlagAry, nTotalPoints);
 
-        if( EndPath( maGraphicsData.mhDC ) )
+        if( EndPath( mhDC ) )
         {
-            if( StrokeAndFillPath( maGraphicsData.mhDC ) )
+            if( StrokeAndFillPath( mhDC ) )
                 bRet = sal_True;
         }
     }
@@ -1571,7 +1574,7 @@ sal_Bool SalGraphics::DrawPolyPolygonBez
         delete [] pWinPointAry;
         delete [] pWinFlagAry;
     }
-    
+
     return bRet;
 #else
     return sal_False;
@@ -1588,7 +1591,8 @@ static BYTE* ImplSearchEntry( BYTE* pSou
 {
 	while ( nComp-- >= nSize )
 	{
-		for ( ULONG i = 0; i < nSize; i++ )
+		ULONG i;
+		for ( i = 0; i < nSize; i++ )
 		{
 			if ( ( pSource[i]&~0x20 ) != ( pDest[i]&~0x20 ) )
 				break;
@@ -1613,7 +1617,8 @@ static BOOL ImplGetBoundingBox( double* 
 		if ( nSizeLeft > 100 )
 			nSizeLeft = 100;	// only 100 bytes following the bounding box will be checked
 
-		for ( int i = 0; ( i < 4 ) && nSizeLeft; i++ )
+		int i;
+		for ( i = 0; ( i < 4 ) && nSizeLeft; i++ )
 		{
 			int 	nDivision = 1;
 			BOOL	bDivision = FALSE;
@@ -1661,37 +1666,28 @@ static BOOL ImplGetBoundingBox( double* 
 	return bRetValue;
 }
 
-inline void ImplWriteDouble( BYTE** pBuf, double nNumb )
-{
-	*pBuf += sprintf( (char*)*pBuf, "%f", nNumb );
-	*(*pBuf)++ = ' ';
-}
-
-inline void ImplWriteString( BYTE** pBuf, const char* sString )
-{
-	strcpy( (char*)*pBuf, sString );
-	*pBuf += strlen( sString );
-}
-
-BOOL SalGraphics::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice* )
+BOOL WinSalGraphics::drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize )
 {
 	BOOL bRetValue = FALSE;
 
-	if ( maGraphicsData.mbPrinter )
+	if ( mbPrinter )
 	{
 		int nEscape = POSTSCRIPT_PASSTHROUGH;
 
-		if ( Escape( maGraphicsData.mhDC, QUERYESCSUPPORT, sizeof( int ), ( LPSTR )&nEscape, 0 ) )
+		if ( Escape( mhDC, QUERYESCSUPPORT, sizeof( int ), ( LPSTR )&nEscape, 0 ) )
 		{
-			BYTE* pBuf = new BYTE[ POSTSCRIPT_BUFSIZE ];
-
 			double	nBoundingBox[4];
 
-			if ( pBuf && ImplGetBoundingBox( nBoundingBox, (BYTE*)pPtr, nSize ) )
+			if ( ImplGetBoundingBox( nBoundingBox, (BYTE*)pPtr, nSize ) )
 			{
+                OStringBuffer aBuf( POSTSCRIPT_BUFSIZE );
+
+                // reserve place for a USHORT
+                aBuf.append( "aa" );
+
                 // #107797# Write out EPS encapsulation header
                 // ----------------------------------------------------------------------------------
-               
+
                 // directly taken from the PLRM 3.0, p. 726. Note:
                 // this will definitely cause problems when
                 // recursively creating and embedding PostScript files
@@ -1700,43 +1696,92 @@ BOOL SalGraphics::DrawEPS( long nX, long
                 // op_count_salWin). Currently, I have no idea on how to
                 // work around that, except from scanning and
                 // interpreting the EPS for unused identifiers.
-				BYTE*	pTemp = pBuf + 2;		// +2 because we want to insert the size later
-				ImplWriteString( &pTemp, "\n\n/b4_Inc_state_salWin save def\n" );
-				ImplWriteString( &pTemp, "/dict_count_salWin countdictstack def\n" );
-				ImplWriteString( &pTemp, "/op_count_salWin count 1 sub def\n" );
-				ImplWriteString( &pTemp, "userdict begin\n" );
-				ImplWriteString( &pTemp, "/showpage {} def\n" );
-				ImplWriteString( &pTemp, "0 setgray 0 setlinecap\n" );
-				ImplWriteString( &pTemp, "1 setlinewidth 0 setlinejoin\n" );
-				ImplWriteString( &pTemp, "10 setmiterlimit [] 0 setdash newpath\n" );
-				ImplWriteString( &pTemp, "/languagelevel where\n" );
-				ImplWriteString( &pTemp, "{\n" );
-				ImplWriteString( &pTemp, "  pop languagelevel\n" );
-				ImplWriteString( &pTemp, "  1 ne\n" );
-				ImplWriteString( &pTemp, "  {\n" );
-				ImplWriteString( &pTemp, "    false setstrokeadjust false setoverprint\n" ); 
-				ImplWriteString( &pTemp, "  } if\n" );
-				ImplWriteString( &pTemp, "} if\n\n" );
-				*((USHORT*)pBuf) = (USHORT)( pTemp - pBuf - 2 );
-				Escape ( maGraphicsData.mhDC, nEscape, pTemp - pBuf, (LPTSTR)((BYTE*)pBuf), 0 );
-                
+
+                // append the real text
+                aBuf.append( "\n\n/b4_Inc_state_salWin save def\n"
+                             "/dict_count_salWin countdictstack def\n"
+                             "/op_count_salWin count 1 sub def\n"
+                             "userdict begin\n"
+                             "/showpage {} def\n"
+                             "0 setgray 0 setlinecap\n"
+                             "1 setlinewidth 0 setlinejoin\n"
+                             "10 setmiterlimit [] 0 setdash newpath\n"
+                             "/languagelevel where\n"
+                             "{\n"
+                             "  pop languagelevel\n"
+                             "  1 ne\n"
+                             "  {\n"
+                             "    false setstrokeadjust false setoverprint\n"
+                             "  } if\n"
+                             "} if\n\n" );
+
+
+                // #i10737# Apply clipping manually
+                // ----------------------------------------------------------------------------------
+
+                // Windows seems to ignore any clipping at the HDC,
+                // when followed by a POSTSCRIPT_PASSTHROUGH
+
+                // Check whether we've got a clipping, consisting of
+                // exactly one rect (other cases should be, but aren't
+                // handled currently)
+
+                // TODO: Handle more than one rectangle here (take
+                // care, the buffer can handle only POSTSCRIPT_BUFSIZE
+                // characters!)
+                if ( mhRegion != 0 &&
+                     mpStdClipRgnData != NULL &&
+                     mpClipRgnData == mpStdClipRgnData &&
+                     mpClipRgnData->rdh.nCount == 1 )
+                {
+                    RECT* pRect = &(mpClipRgnData->rdh.rcBound);
+
+                    aBuf.append( "\nnewpath\n" );
+                    aBuf.append( pRect->left );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->top );
+                    aBuf.append( " moveto\n" );
+                    aBuf.append( pRect->right );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->top );
+                    aBuf.append( " lineto\n" );
+                    aBuf.append( pRect->right );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->bottom );
+                    aBuf.append( " lineto\n" );
+                    aBuf.append( pRect->left );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->bottom );
+                    aBuf.append( " lineto\n"
+                                 "closepath\n"
+                                 "clip\n"
+                                 "newpath\n" );
+                }
+
+                // #107797# Write out buffer
+                // ----------------------------------------------------------------------------------
+				*((USHORT*)aBuf.getStr()) = (USHORT)( aBuf.getLength() - 2 );
+				Escape ( mhDC, nEscape, aBuf.getLength(), (LPTSTR)aBuf.getStr(), 0 );
+
 
                 // #107797# Write out EPS transformation code
                 // ----------------------------------------------------------------------------------
 				double	dM11 = nWidth / ( nBoundingBox[2] - nBoundingBox[0] );
 				double	dM22 = nHeight / (nBoundingBox[1] - nBoundingBox[3] );
-				pTemp = pBuf + 2;		// +2 because we want to insert the size later
-				ImplWriteString( &pTemp, "\n\n[ " );
-				ImplWriteDouble( &pTemp, dM11 );
-				ImplWriteDouble( &pTemp, 0 );
-				ImplWriteDouble( &pTemp, 0 );
-				ImplWriteDouble( &pTemp, dM22 );
-				ImplWriteDouble( &pTemp, nX - ( dM11 * nBoundingBox[0] ) );
-				ImplWriteDouble( &pTemp, nY - ( dM22 * nBoundingBox[3] ) );
-				ImplWriteString( &pTemp, "] concat\n" );
-				ImplWriteString( &pTemp, "%%BeginDocument:\n" );
-				*((USHORT*)pBuf) = (USHORT)( pTemp - pBuf - 2 );
-				Escape ( maGraphicsData.mhDC, nEscape, pTemp - pBuf, (LPTSTR)((BYTE*)pBuf), 0 );
+                // reserve a USHORT again
+                aBuf.setLength( 2 );
+                aBuf.append( "\n\n[" );
+                aBuf.append( dM11 );
+                aBuf.append( " 0 0 " );
+                aBuf.append( dM22 );
+                aBuf.append( ' ' );
+                aBuf.append( nX - ( dM11 * nBoundingBox[0] ) );
+                aBuf.append( ' ' );
+                aBuf.append( nY - ( dM22 * nBoundingBox[3] ) );
+                aBuf.append( "] concat\n"
+                             "%%BeginDocument:\n" );
+				*((USHORT*)aBuf.getStr()) = (USHORT)( aBuf.getLength() - 2 );
+				Escape ( mhDC, nEscape, aBuf.getLength(), (LPTSTR)aBuf.getStr(), 0 );
 
 
                 // #107797# Write out actual EPS content
@@ -1748,9 +1793,11 @@ BOOL SalGraphics::DrawEPS( long nX, long
 					nDoNow = nToDo;
 					if ( nToDo > POSTSCRIPT_BUFSIZE - 2 )
 						nDoNow = POSTSCRIPT_BUFSIZE - 2;
-					*((USHORT*)pBuf) = (USHORT)nDoNow;
-					memcpy( pBuf + 2, (BYTE*)pPtr + nSize - nToDo, nDoNow );
-					ULONG nResult = Escape ( maGraphicsData.mhDC, nEscape, nDoNow + 2, (LPTSTR)((BYTE*)pBuf), 0 );
+                    // the following is based on the string buffer allocation
+                    // of size POSTSCRIPT_BUFSIZE at construction time of aBuf
+					*((USHORT*)aBuf.getStr()) = (USHORT)nDoNow;
+					memcpy( (void*)(aBuf.getStr() + 2), (BYTE*)pPtr + nSize - nToDo, nDoNow );
+					ULONG nResult = Escape ( mhDC, nEscape, nDoNow + 2, (LPTSTR)aBuf.getStr(), 0 );
 					if (!nResult )
 						break;
 					nToDo -= nResult;
@@ -1759,16 +1806,16 @@ BOOL SalGraphics::DrawEPS( long nX, long
 
                 // #107797# Write out EPS encapsulation footer
                 // ----------------------------------------------------------------------------------
-				pTemp = pBuf + 2;
-				ImplWriteString( &pTemp, "%%EndDocument\n" );
-				ImplWriteString( &pTemp, "count op_count_salWin sub {pop} repeat\n" );
-				ImplWriteString( &pTemp, "countdictstack dict_count_salWin sub {end} repeat\n" );
-				ImplWriteString( &pTemp, "b4_Inc_state_salWin restore\n\n" );
-				*((USHORT*)pBuf) = (USHORT)( pTemp - pBuf - 2 );
-				Escape ( maGraphicsData.mhDC, nEscape, pTemp - pBuf, (LPTSTR)((BYTE*)pBuf), 0 );
+                // reserve a USHORT again
+                aBuf.setLength( 2 );
+                aBuf.append( "%%EndDocument\n"
+                             "count op_count_salWin sub {pop} repeat\n"
+                             "countdictstack dict_count_salWin sub {end} repeat\n"
+                             "b4_Inc_state_salWin restore\n\n" );
+				*((USHORT*)aBuf.getStr()) = (USHORT)( aBuf.getLength() - 2 );
+				Escape ( mhDC, nEscape, aBuf.getLength(), (LPTSTR)aBuf.getStr(), 0 );
 				bRetValue = TRUE;
 			}
-			delete [] pBuf;
 		}
 	}
 
Index: vcl/win/source/gdi/salgdi2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/win/source/gdi/salgdi2.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 salgdi2.cxx
--- vcl/win/source/gdi/salgdi2.cxx	18 Nov 2002 13:50:32 -0000	1.3
+++ vcl/win/source/gdi/salgdi2.cxx	20 Jul 2004 11:04:57 -0000
@@ -70,13 +70,11 @@
 #include <tools/debug.hxx>
 #endif
 
-#define _SV_SALGDI2_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
@@ -84,27 +82,23 @@
 #ifndef _SV_SALIDS_HRC
 #include <salids.hrc>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
 // =======================================================================
 
-BOOL bFastTransparent = FALSE;
-
-// =======================================================================
-
-void SalGraphics::CopyBits( const SalTwoRect* pPosAry, SalGraphics* pSrcGraphics, const OutputDevice* /*pOutDev*/, const OutputDevice* /*pSrcOutDev*/)
+void WinSalGraphics::copyBits( const SalTwoRect* pPosAry, SalGraphics* pSrcGraphics )
 {
 	HDC 	hSrcDC;
 	DWORD	nRop;
 
 	if ( pSrcGraphics )
-		hSrcDC = pSrcGraphics->maGraphicsData.mhDC;
+		hSrcDC = static_cast<WinSalGraphics*>(pSrcGraphics)->mhDC;
 	else
-		hSrcDC = maGraphicsData.mhDC;
+		hSrcDC = mhDC;
 
-	if ( maGraphicsData.mbXORMode )
+	if ( mbXORMode )
 		nRop = SRCINVERT;
 	else
 		nRop = SRCCOPY;
@@ -112,7 +106,7 @@ void SalGraphics::CopyBits( const SalTwo
 	if ( (pPosAry->mnSrcWidth  == pPosAry->mnDestWidth) &&
 		 (pPosAry->mnSrcHeight == pPosAry->mnDestHeight) )
 	{
-		BitBlt( maGraphicsData.mhDC,
+		BitBlt( mhDC,
 				(int)pPosAry->mnDestX, (int)pPosAry->mnDestY,
 				(int)pPosAry->mnDestWidth, (int)pPosAry->mnDestHeight,
 				hSrcDC,
@@ -121,15 +115,15 @@ void SalGraphics::CopyBits( const SalTwo
 	}
 	else
 	{
-		int nOldStretchMode = SetStretchBltMode( maGraphicsData.mhDC, STRETCH_DELETESCANS );
-		StretchBlt( maGraphicsData.mhDC,
+		int nOldStretchMode = SetStretchBltMode( mhDC, STRETCH_DELETESCANS );
+		StretchBlt( mhDC,
 					(int)pPosAry->mnDestX, (int)pPosAry->mnDestY,
 					(int)pPosAry->mnDestWidth, (int)pPosAry->mnDestHeight,
 					hSrcDC,
 					(int)pPosAry->mnSrcX, (int)pPosAry->mnSrcY,
 					(int)pPosAry->mnSrcWidth, (int)pPosAry->mnSrcHeight,
 					nRop );
-		SetStretchBltMode( maGraphicsData.mhDC, nOldStretchMode );
+		SetStretchBltMode( mhDC, nOldStretchMode );
 	}
 }
 
@@ -178,20 +172,20 @@ void ImplCalcOutSideRgn( const RECT& rSr
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::CopyArea( long nDestX, long nDestY,
+void WinSalGraphics::copyArea( long nDestX, long nDestY,
 							long nSrcX, long nSrcY,
 							long nSrcWidth, long nSrcHeight,
-							USHORT nFlags, const OutputDevice* )
+							USHORT nFlags )
 {
-	BitBlt( maGraphicsData.mhDC,
+	BitBlt( mhDC,
 			(int)nDestX, (int)nDestY,
 			(int)nSrcWidth, (int)nSrcHeight,
-			maGraphicsData.mhDC,
+			mhDC,
 			(int)nSrcX, (int)nSrcY,
 			SRCCOPY );
 
 	// Muessen die ueberlappenden Bereiche auch invalidiert werden?
-	if ( (nFlags & SAL_COPYAREA_WINDOWINVALIDATE) && maGraphicsData.mbWindow )
+	if ( (nFlags & SAL_COPYAREA_WINDOWINVALIDATE) && mbWindow )
 	{
 		// Overlap-Bereich berechnen und invalidieren
 		RECT	aSrcRect;
@@ -207,7 +201,7 @@ void SalGraphics::CopyArea( long nDestX,
 		aSrcRect.top	= (int)nSrcY;
 		aSrcRect.right	= aSrcRect.left+(int)nSrcWidth;
 		aSrcRect.bottom = aSrcRect.top+(int)nSrcHeight;
-		GetClientRect( maGraphicsData.mhWnd, &aClipRect );
+		GetClientRect( mhWnd, &aClipRect );
 		if ( IntersectRect( &aSrcRect, &aSrcRect, &aClipRect ) )
 		{
 			// Rechteck in Screen-Koordinaaten umrechnen
@@ -216,7 +210,7 @@ void SalGraphics::CopyArea( long nDestX,
 			int nScreenDY = GetSystemMetrics( SM_CYSCREEN );
 			aPt.x = 0;
 			aPt.y = 0;
-			ClientToScreen( maGraphicsData.mhWnd, &aPt );
+			ClientToScreen( mhWnd, &aPt );
 			aSrcRect.left	+= aPt.x;
 			aSrcRect.top	+= aPt.y;
 			aSrcRect.right	+= aPt.x;
@@ -227,7 +221,7 @@ void SalGraphics::CopyArea( long nDestX,
 
 			// Bereiche die von anderen Fenstern ueberlagert werden berechnen
 			HRGN hTempRgn2 = 0;
-			HWND hWndTopWindow = maGraphicsData.mhWnd;
+			HWND hWndTopWindow = mhWnd;
 			// Find the TopLevel Window, because only Windows which are in
 			// in the foreground of our TopLevel window must be considered
 			if ( GetWindowStyle( hWndTopWindow ) & WS_CHILD )
@@ -300,11 +294,11 @@ void SalGraphics::CopyArea( long nDestX,
 					int nOffY = (int)(nDestY-nSrcY);
 					OffsetRgn( hInvalidateRgn, nOffX-aPt.x, nOffY-aPt.y );
 					// Combine Invalidate Region with existing ClipRegion
-					if ( GetClipRgn( maGraphicsData.mhDC, hTempRgn ) == 1 )
+					if ( GetClipRgn( mhDC, hTempRgn ) == 1 )
 						nRgnType = CombineRgn( hInvalidateRgn, hTempRgn, hInvalidateRgn, RGN_AND );
 					if ( (nRgnType != ERROR) && (nRgnType != NULLREGION) )
 					{
-						InvalidateRgn( maGraphicsData.mhWnd, hInvalidateRgn, TRUE );
+						InvalidateRgn( mhWnd, hInvalidateRgn, TRUE );
 						// Hier loesen wir nur ein Update aus, wenn es der
 						// MainThread ist, damit es beim Bearbeiten der
 						// Paint-Message keinen Deadlock gibt, da der
@@ -312,7 +306,7 @@ void SalGraphics::CopyArea( long nDestX,
 						SalData*	pSalData = GetSalData();
 						DWORD		nCurThreadId = GetCurrentThreadId();
 						if ( pSalData->mnAppThreadId == nCurThreadId )
-							UpdateWindow( maGraphicsData.mhWnd );
+							UpdateWindow( mhWnd );
 					}
 				}
 				DeleteRegion( hTempRgn );
@@ -325,19 +319,19 @@ void SalGraphics::CopyArea( long nDestX,
 // -----------------------------------------------------------------------
 
 void ImplDrawBitmap( HDC hDC,
-					 const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap,
+					 const SalTwoRect* pPosAry, const WinSalBitmap& rSalBitmap,
 					 BOOL bPrinter, int nDrawMode )
 {
 	if( hDC )
 	{
 		HGLOBAL 	hDrawDIB;
 		HBITMAP 	hDrawDDB = rSalBitmap.ImplGethDDB();
-		SalBitmap*	pTmpSalBmp;
+		WinSalBitmap*	pTmpSalBmp;
 		BOOL		bPrintDDB = ( bPrinter && hDrawDDB );
 
 		if( bPrintDDB )
 		{
-			pTmpSalBmp = new SalBitmap;
+			pTmpSalBmp = new WinSalBitmap;
 			pTmpSalBmp->Create( rSalBitmap, rSalBitmap.GetBitCount() );
 			hDrawDIB = pTmpSalBmp->ImplGethDIB();
 		}
@@ -416,24 +410,26 @@ void ImplDrawBitmap( HDC hDC,
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
-							  const SalBitmap& rSalBitmap, const OutputDevice* )
+void WinSalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+							  const SalBitmap& rSalBitmap )
 {
-	ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, rSalBitmap,
-					maGraphicsData.mbPrinter,
-					maGraphicsData.mbXORMode ? SRCINVERT : SRCCOPY );
+	ImplDrawBitmap( mhDC, pPosAry, static_cast<const WinSalBitmap&>(rSalBitmap),
+					mbPrinter,
+					mbXORMode ? SRCINVERT : SRCCOPY );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
-							  const SalBitmap& rSalBitmap,
-							  SalColor nTransparentColor, const OutputDevice* pOutDev )
+void WinSalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+							  const SalBitmap& rSSalBitmap,
+							  SalColor nTransparentColor )
 {
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No transparency print possible!" );
+	DBG_ASSERT( !mbPrinter, "No transparency print possible!" );
+
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
 
-	SalBitmap*	pMask = new SalBitmap;
-	HDC 		hDC = maGraphicsData.mhDC;
+	WinSalBitmap*	pMask = new WinSalBitmap;
+	HDC 		hDC = mhDC;
 	const Point aPoint;
 	const Size	aSize( rSalBitmap.GetSize() );
 	HBITMAP 	hMaskBitmap = CreateBitmap( (int) aSize.Width(), (int) aSize.Height(), 1, 1, NULL );
@@ -454,7 +450,7 @@ void SalGraphics::DrawBitmap( const SalT
 	}
 	else
 	{
-		SalBitmap*	pTmpSalBmp = new SalBitmap;
+		WinSalBitmap*	pTmpSalBmp = new WinSalBitmap;
 
 		if( pTmpSalBmp->Create( rSalBitmap, this ) )
 		{
@@ -474,128 +470,104 @@ void SalGraphics::DrawBitmap( const SalT
 
 	// hMaskBitmap is destroyed by new SalBitmap 'pMask' ( bDIB==FALSE, bCopy == FALSE )
 	if( pMask->Create( hMaskBitmap, FALSE, FALSE ) )
-		DrawBitmap( pPosAry, rSalBitmap, *pMask, pOutDev );
+		drawBitmap( pPosAry, rSalBitmap, *pMask );
 
 	delete pMask;
 }
-
+ 
 // -----------------------------------------------------------------------
-
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
-							  const SalBitmap& rSalBitmap,
-							  const SalBitmap& rTransparentBitmap, const OutputDevice* )
-{
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No transparency print possible!" );
-
-	if( bFastTransparent )
-	{
-		// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
-		// die Farben der Maske richtig auf die Palette abzubilden,
-		// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
-		if( ( GetBitCount() <= 8 ) && rTransparentBitmap.ImplGethDIB() && rTransparentBitmap.GetBitCount() == 1 )
-		{
-			SalBitmap aTmp;
-			if( aTmp.Create( rTransparentBitmap, this ) )
-				ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, aTmp, FALSE, SRCAND );
-		}
-		else
-			ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, rTransparentBitmap, FALSE, SRCAND );
-
-		// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
-		// die Farben der Maske richtig auf die Palette abzubilden,
-		// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
-		if( ( GetBitCount() <= 8 ) && rSalBitmap.ImplGethDIB() && rSalBitmap.GetBitCount() == 1 )
-		{
-			SalBitmap aTmp;
-			if( aTmp.Create( rSalBitmap, this ) )
-				ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, aTmp, FALSE, SRCPAINT );
-		}
-		else
-			ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, rSalBitmap, FALSE, SRCPAINT );
-	}
-	else
+ 
+void WinSalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+							  const SalBitmap& rSSalBitmap,
+							  const SalBitmap& rSTransparentBitmap )
+{
+	DBG_ASSERT( !mbPrinter, "No transparency print possible!" );
+ 
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
+    const WinSalBitmap& rTransparentBitmap = static_cast<const WinSalBitmap&>(rSTransparentBitmap);
+ 
+	SalTwoRect	aPosAry = *pPosAry;
+	int 		nDstX = (int)aPosAry.mnDestX;
+	int 		nDstY = (int)aPosAry.mnDestY;
+	int 		nDstWidth = (int)aPosAry.mnDestWidth;
+	int 		nDstHeight = (int)aPosAry.mnDestHeight;
+	HDC 		hDC = mhDC;
+	HBITMAP 	hMemBitmap = 0;
+	HBITMAP 	hMaskBitmap = 0;
+ 
+	if( ( nDstWidth > CACHED_HDC_DEFEXT ) || ( nDstHeight > CACHED_HDC_DEFEXT ) )
+	{
+		hMemBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
+		hMaskBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
+	}
+ 
+	HDC hMemDC = ImplGetCachedDC( CACHED_HDC_1, hMemBitmap );
+	HDC hMaskDC = ImplGetCachedDC( CACHED_HDC_2, hMaskBitmap );
+ 
+	aPosAry.mnDestX = aPosAry.mnDestY = 0;
+	BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hDC, nDstX, nDstY, SRCCOPY );
+ 
+	// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
+	// die Farben der Maske richtig auf die Palette abzubilden,
+	// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
+	if( ( GetBitCount() <= 8 ) && rTransparentBitmap.ImplGethDIB() && rTransparentBitmap.GetBitCount() == 1 )
 	{
-		SalTwoRect	aPosAry = *pPosAry;
-		int 		nDstX = (int)aPosAry.mnDestX;
-		int 		nDstY = (int)aPosAry.mnDestY;
-		int 		nDstWidth = (int)aPosAry.mnDestWidth;
-		int 		nDstHeight = (int)aPosAry.mnDestHeight;
-		HDC 		hDC = maGraphicsData.mhDC;
-		HBITMAP 	hMemBitmap = 0;
-		HBITMAP 	hMaskBitmap = 0;
-
-		if( ( nDstWidth > CACHED_HDC_DEFEXT ) || ( nDstHeight > CACHED_HDC_DEFEXT ) )
-		{
-			hMemBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
-			hMaskBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
-		}
-
-		HDC hMemDC = ImplGetCachedDC( CACHED_HDC_1, hMemBitmap );
-		HDC hMaskDC = ImplGetCachedDC( CACHED_HDC_2, hMaskBitmap );
-
-		aPosAry.mnDestX = aPosAry.mnDestY = 0;
-		BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hDC, nDstX, nDstY, SRCCOPY );
-
-		// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
-		// die Farben der Maske richtig auf die Palette abzubilden,
-		// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
-		if( ( GetBitCount() <= 8 ) && rTransparentBitmap.ImplGethDIB() && rTransparentBitmap.GetBitCount() == 1 )
-		{
-			SalBitmap aTmp;
-
-			if( aTmp.Create( rTransparentBitmap, this ) )
-				ImplDrawBitmap( hMaskDC, &aPosAry, aTmp, FALSE, SRCCOPY );
-		}
-		else
-			ImplDrawBitmap( hMaskDC, &aPosAry, rTransparentBitmap, FALSE, SRCCOPY );
-
-        // now MemDC contains background, MaskDC the transparency mask
-
-        // #105055# Respect XOR mode
-        if( maGraphicsData.mbXORMode )
-        {
-            ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
-            // now MaskDC contains the bitmap area with black background
-            BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCINVERT );
-            // now MemDC contains background XORed bitmap area ontop
-        }
-        else
-        {
-            BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCAND );       
-            // now MemDC contains background with masked-out bitmap area
-            ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
-            // now MaskDC contains the bitmap area with black background
-            BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCPAINT );
-            // now MemDC contains background and bitmap merged together
-        }
-        // copy to output DC
-        BitBlt( hDC, nDstX, nDstY, nDstWidth, nDstHeight, hMemDC, 0, 0, SRCCOPY );
-
-		ImplReleaseCachedDC( CACHED_HDC_1 );
-		ImplReleaseCachedDC( CACHED_HDC_2 );
-
-		// hMemBitmap != 0 ==> hMaskBitmap != 0
-		if( hMemBitmap )
-		{
-			DeleteObject( hMemBitmap );
-			DeleteObject( hMaskBitmap );
-		}
+		WinSalBitmap aTmp;
+ 
+		if( aTmp.Create( rTransparentBitmap, this ) )
+			ImplDrawBitmap( hMaskDC, &aPosAry, aTmp, FALSE, SRCCOPY );
+	}
+	else
+		ImplDrawBitmap( hMaskDC, &aPosAry, rTransparentBitmap, FALSE, SRCCOPY );
+ 
+    // now MemDC contains background, MaskDC the transparency mask
+ 
+    // #105055# Respect XOR mode
+    if( mbXORMode )
+    {
+        ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
+        // now MaskDC contains the bitmap area with black background
+        BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCINVERT );
+        // now MemDC contains background XORed bitmap area ontop
+    }
+    else
+    {
+        BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCAND );       
+        // now MemDC contains background with masked-out bitmap area
+        ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
+        // now MaskDC contains the bitmap area with black background
+        BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCPAINT );
+        // now MemDC contains background and bitmap merged together
+    }
+    // copy to output DC
+    BitBlt( hDC, nDstX, nDstY, nDstWidth, nDstHeight, hMemDC, 0, 0, SRCCOPY );
+ 
+	ImplReleaseCachedDC( CACHED_HDC_1 );
+	ImplReleaseCachedDC( CACHED_HDC_2 );
+ 
+	// hMemBitmap != 0 ==> hMaskBitmap != 0
+	if( hMemBitmap )
+	{
+		DeleteObject( hMemBitmap );
+		DeleteObject( hMaskBitmap );
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawMask( const SalTwoRect* pPosAry,
-							const SalBitmap& rSalBitmap,
-							SalColor nMaskColor, const OutputDevice* )
+void WinSalGraphics::drawMask( const SalTwoRect* pPosAry,
+							const SalBitmap& rSSalBitmap,
+							SalColor nMaskColor )
 {
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No transparency print possible!" );
+	DBG_ASSERT( !mbPrinter, "No transparency print possible!" );
+
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
 
 	SalTwoRect	aPosAry = *pPosAry;
 	const BYTE	cRed = SALCOLOR_RED( nMaskColor );
 	const BYTE	cGreen = SALCOLOR_GREEN( nMaskColor );
 	const BYTE	cBlue = SALCOLOR_BLUE( nMaskColor );
-	HDC 		hDC = maGraphicsData.mhDC;
+	HDC 		hDC = mhDC;
 	HBRUSH		hMaskBrush = CreateSolidBrush( RGB( cRed, cGreen, cBlue ) );
 	HBRUSH		hOldBrush = SelectBrush( hDC, hMaskBrush );
 
@@ -604,7 +576,7 @@ void SalGraphics::DrawMask( const SalTwo
 	// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
 	if( ( GetBitCount() <= 8 ) && rSalBitmap.ImplGethDIB() && rSalBitmap.GetBitCount() == 1 )
 	{
-		SalBitmap aTmp;
+		WinSalBitmap aTmp;
 
 		if( aTmp.Create( rSalBitmap, this ) )
 			ImplDrawBitmap( hDC, &aPosAry, aTmp, FALSE, 0x00B8074AUL );
@@ -618,16 +590,16 @@ void SalGraphics::DrawMask( const SalTwo
 
 // -----------------------------------------------------------------------
 
-SalBitmap* SalGraphics::GetBitmap( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+SalBitmap* WinSalGraphics::getBitmap( long nX, long nY, long nDX, long nDY )
 {
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No ::GetBitmap() from printer possible!" );
+	DBG_ASSERT( !mbPrinter, "No ::GetBitmap() from printer possible!" );
 
-	SalBitmap* pSalBitmap = NULL;
+	WinSalBitmap* pSalBitmap = NULL;
 
 	nDX = labs( nDX );
 	nDY = labs( nDY );
 
-	HDC 	hDC = maGraphicsData.mhDC;
+	HDC 	hDC = mhDC;
 	HBITMAP hBmpBitmap = CreateCompatibleBitmap( hDC, nDX, nDY );
 	HDC 	hBmpDC = ImplGetCachedDC( CACHED_HDC_1, hBmpBitmap );
 	BOOL	bRet;
@@ -637,7 +609,7 @@ SalBitmap* SalGraphics::GetBitmap( long 
 
 	if( bRet )
 	{
-		pSalBitmap = new SalBitmap;
+		pSalBitmap = new WinSalBitmap;
 
 		if( !pSalBitmap->Create( hBmpBitmap, FALSE, FALSE ) )
 		{
@@ -651,15 +623,11 @@ SalBitmap* SalGraphics::GetBitmap( long 
 
 // -----------------------------------------------------------------------
 
-SalColor SalGraphics::GetPixel( long nX, long nY, const OutputDevice* )
+SalColor WinSalGraphics::getPixel( long nX, long nY )
 {
-	COLORREF aWinCol = ::GetPixel( maGraphicsData.mhDC, (int) nX, (int) nY );
+	COLORREF aWinCol = ::GetPixel( mhDC, (int) nX, (int) nY );
 
-#ifdef WIN
-	if ( -1 == aWinCol )
-#else
 	if ( CLR_INVALID == aWinCol )
-#endif
 		return MAKE_SALCOLOR( 0, 0, 0 );
 	else
 		return MAKE_SALCOLOR( GetRValue( aWinCol ),
@@ -669,20 +637,20 @@ SalColor SalGraphics::GetPixel( long nX,
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice * )
+void WinSalGraphics::invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags )
 {
 	if ( nFlags & SAL_INVERT_TRACKFRAME )
 	{
 		HPEN	hDotPen = CreatePen( PS_DOT, 0, 0 );
-		HPEN	hOldPen = SelectPen( maGraphicsData.mhDC, hDotPen );
-		HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, GetStockBrush( NULL_BRUSH ) );
-		int 	nOldROP = SetROP2( maGraphicsData.mhDC, R2_NOT );
-
-		WIN_Rectangle( maGraphicsData.mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
-
-		SetROP2( maGraphicsData.mhDC, nOldROP );
-		SelectPen( maGraphicsData.mhDC, hOldPen );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		HPEN	hOldPen = SelectPen( mhDC, hDotPen );
+		HBRUSH	hOldBrush = SelectBrush( mhDC, GetStockBrush( NULL_BRUSH ) );
+		int 	nOldROP = SetROP2( mhDC, R2_NOT );
+
+		WIN_Rectangle( mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
+
+		SetROP2( mhDC, nOldROP );
+		SelectPen( mhDC, hOldPen );
+		SelectBrush( mhDC, hOldBrush );
 		DeletePen( hDotPen );
 	}
 	else if ( nFlags & SAL_INVERT_50 )
@@ -695,11 +663,11 @@ void SalGraphics::Invert( long nX, long 
 			pSalData->mh50Brush = CreatePatternBrush( pSalData->mh50Bmp );
 		}
 
-		COLORREF nOldTextColor = ::SetTextColor( maGraphicsData.mhDC, 0 );
-		HBRUSH hOldBrush = SelectBrush( maGraphicsData.mhDC, pSalData->mh50Brush );
-		PatBlt( maGraphicsData.mhDC, nX, nY, nWidth, nHeight, PATINVERT );
-		::SetTextColor( maGraphicsData.mhDC, nOldTextColor );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		COLORREF nOldTextColor = ::SetTextColor( mhDC, 0 );
+		HBRUSH hOldBrush = SelectBrush( mhDC, pSalData->mh50Brush );
+		PatBlt( mhDC, nX, nY, nWidth, nHeight, PATINVERT );
+		::SetTextColor( mhDC, nOldTextColor );
+		SelectBrush( mhDC, hOldBrush );
 	}
 	else
 	{
@@ -708,20 +676,20 @@ void SalGraphics::Invert( long nX, long 
 		 aRect.top		 = (int)nY;
 		 aRect.right	 = (int)nX+nWidth;
 		 aRect.bottom	 = (int)nY+nHeight;
-		 ::InvertRect( maGraphicsData.mhDC, &aRect );
+		 ::InvertRect( mhDC, &aRect );
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nSalFlags, const OutputDevice* )
+void WinSalGraphics::invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nSalFlags )
 {
 	HPEN		hPen;
 	HPEN		hOldPen;
 	HBRUSH		hBrush;
 	HBRUSH		hOldBrush;
 	COLORREF	nOldTextColor;
-	int 		nOldROP = SetROP2( maGraphicsData.mhDC, R2_NOT );
+	int 		nOldROP = SetROP2( mhDC, R2_NOT );
 
 	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
 		hPen = CreatePen( PS_DOT, 0, 0 );
@@ -744,56 +712,38 @@ void SalGraphics::Invert( ULONG nPoints,
 			hBrush = GetStockBrush( BLACK_BRUSH );
 
 		hPen = GetStockPen( NULL_PEN );
-		nOldTextColor = ::SetTextColor( maGraphicsData.mhDC, 0 );
-		hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
+		nOldTextColor = ::SetTextColor( mhDC, 0 );
+		hOldBrush = SelectBrush( mhDC, hBrush );
 	}
-	hOldPen = SelectPen( maGraphicsData.mhDC, hPen );
+	hOldPen = SelectPen( mhDC, hPen );
 
 	POINT* pWinPtAry;
-#ifdef WIN
-	if ( nPoints > MAX_64KSALPOINTS )
-		nPoints = MAX_64KSALPOINTS;
-
-	pWinPtAry = new POINT[(USHORT)nPoints];
-	const SalPoint huge* pHugePtAry = (const SalPoint huge*)pPtAry;
-	for( USHORT i=0; i < (USHORT)nPoints ; i++ )
-	{
-		pWinPtAry[i].x = (int)pHugePtAry[i].mnX;
-		pWinPtAry[i].y = (int)pHugePtAry[i].mnY;
-	}
-	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
-		Polyline( maGraphicsData.mhDC, pWinPtAry, (int)nPoints );
-	else
-		WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, (int)nPoints );
-	delete pWinPtAry;
-#else
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyLine(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyLine(): POINT != SalPoint" );
 
 	pWinPtAry = (POINT*)pPtAry;
 	// Wegen Windows 95 und der Beschraenkung auf eine maximale Anzahl
 	// von Punkten
 	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
 	{
-		if ( !Polyline( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-			Polyline( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+		if ( !Polyline( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+			Polyline( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 	}
 	else
 	{
-		if ( !WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-			WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+		if ( !WIN_Polygon( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+			WIN_Polygon( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 	}
-#endif
 
-	SetROP2( maGraphicsData.mhDC, nOldROP );
-	SelectPen( maGraphicsData.mhDC, hOldPen );
+	SetROP2( mhDC, nOldROP );
+	SelectPen( mhDC, hOldPen );
 
 	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
 		DeletePen( hPen );
 	else
 	{
-		::SetTextColor( maGraphicsData.mhDC, nOldTextColor );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		::SetTextColor( mhDC, nOldTextColor );
+		SelectBrush( mhDC, hOldBrush );
 	}
 }


Index: vcl/win/source/gdi/salgdi3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salgdi3.cxx,v
retrieving revision 1.48.46.3
retrieving revision 1.55
diff -u -p -u -r1.48.46.3 -r1.55
--- vcl/win/source/gdi/salgdi3.cxx	26 Jan 2004 17:28:36 -0000	1.48.46.3
+++ vcl/win/source/gdi/salgdi3.cxx	30 Mar 2004 13:44:57 -0000	1.55
@@ -66,8 +66,6 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALGDI3_CXX
-
 #ifndef _RTL_TENCINFO_H
 #include <rtl/tencinfo.h>
 #endif
@@ -90,8 +88,8 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _SV_OUTFONT_HXX
 #include <outfont.hxx>
@@ -99,24 +97,18 @@
 #ifndef _SV_FONT_HXX
 #include <font.hxx>
 #endif
-
-#ifdef ENABLE_CTL
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif // _SV_SALLAYOUT_HXX
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
-#endif // _SV_POLY_HXX
-#endif // ENABLE_CTL
-
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 #ifdef GCP_KERN_HACK
 #include <algorithm>
 #endif // GCP_KERN_HACK
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
-
 #ifndef __SUBFONT_H
 #include <psprint/list.h>
 #include <psprint/sft.h>
@@ -126,12 +118,6 @@
 // - Defines -
 // -----------
 
-//#ifdef FORCE_VERTICAL_NAME
-
-#ifdef WIN
-#define GDI_ERROR   (0xFFFFFFFFUL)
-#endif
-
 #define GLYPH_INC               (512UL)
 #define MAX_POLYCOUNT           (2048UL)
 
@@ -158,7 +144,7 @@ inline int IntFromFixed(FIXED f)
 static BOOL bImplSalCourierScalable = FALSE;
 static BOOL bImplSalCourierNew = FALSE;
 
-static BOOL FontHasCJKUnicodeRange( const SalGraphics* pGraphics, BOOL &bHasKoreanRange );
+static BOOL FontHasCJKUnicodeRange( const WinSalGraphics* pGraphics, BOOL &bHasKoreanRange );
 
 // =======================================================================
 
@@ -269,7 +255,7 @@ static BYTE ImplFamilyToWin( FontFamily 
 
 // -----------------------------------------------------------------------
 
-static FontWeight ImplWeightToSal( WinWeight nWeight )
+static FontWeight ImplWeightToSal( int nWeight )
 {
     if ( nWeight <= FW_THIN )
         return WEIGHT_THIN;
@@ -293,7 +279,7 @@ static FontWeight ImplWeightToSal( WinWe
 
 // -----------------------------------------------------------------------
 
-static WinWeight ImplWeightToWin( FontWeight eWeight )
+static int ImplWeightToWin( FontWeight eWeight )
 {
     switch ( eWeight )
     {
@@ -518,20 +504,20 @@ void ImplSalLogFontToFontW( HDC hDC, con
 
 // =======================================================================
 
-void SalGraphics::SetTextColor( SalColor nSalColor )
+void WinSalGraphics::SetTextColor( SalColor nSalColor )
 {
     COLORREF aCol = PALETTERGB( SALCOLOR_RED( nSalColor ),
                                 SALCOLOR_GREEN( nSalColor ),
                                 SALCOLOR_BLUE( nSalColor ) );
 
-    if( !maGraphicsData.mbPrinter &&
+    if( !mbPrinter &&
         GetSalData()->mhDitherPal &&
         ImplIsSysColorEntry( nSalColor ) )
     {
         aCol = PALRGB_TO_RGB( aCol );
     }
 
-    ::SetTextColor( maGraphicsData.mhDC, aCol );
+    ::SetTextColor( mhDC, aCol );
 }
 
 // -----------------------------------------------------------------------
@@ -552,11 +538,6 @@ static void ImplSalGetVerticalFontNameW(
     if (rName.Len() == 0 || rName.GetChar(0) == '@')
         return;
 
-#ifdef FORCE_VERTICAL_NAME
-    rName.Insert( (sal_Unicode)'@', 0 );
-    return;
-#endif // FORCE_VERTICAL_NAME
-
     // Vertical fonts starts with a @
     UniString aTemp = rName;
     aTemp.Insert( (sal_Unicode)'@', 0 );
@@ -727,7 +708,7 @@ static HFONT ImplSelectFontW( HDC hDC, L
     if ( !GetTextMetricsW( hDC, &aWinMetric ) )
     {
         // font doesn't work => try a replacement
-        lstrcpyW( rLogFont.lfFaceName, L"Courier New" );
+        lstrcpynW( rLogFont.lfFaceName, L"Courier New", 11 );
         rLogFont.lfPitchAndFamily = FIXED_PITCH;
         HFONT hNewFont2 = CreateFontIndirectW( &rLogFont );
         SelectFont( hDC, hNewFont2 );
@@ -750,7 +731,7 @@ static HFONT ImplSelectFontA( HDC hDC, L
     // when the font doesn't work try a replacement
     if ( !GetTextMetricsA( hDC, &aWinMetric ) )
     {
-        strcpy( rLogFont.lfFaceName, "Courier New" );
+        strncpy( rLogFont.lfFaceName, "Courier New", 11 );
         rLogFont.lfPitchAndFamily = FIXED_PITCH;
         HFONT hNewFont2 = CreateFontIndirectA( &rLogFont );
         SelectFont( hDC, hNewFont2 );
@@ -764,14 +745,7 @@ static HFONT ImplSelectFontA( HDC hDC, L
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::RemovingFont( ImplFontData* )
-{
-    // dummy implementation on W32
-}
-
-// -----------------------------------------------------------------------
-
-USHORT SalGraphics::SetFont( ImplFontSelectData* pFont, int nFallbackLevel )
+USHORT WinSalGraphics::SetFont( ImplFontSelectData* pFont, int nFallbackLevel )
 {
     HFONT hNewFont = 0;
     HFONT hOldFont;
@@ -779,24 +753,24 @@ USHORT SalGraphics::SetFont( ImplFontSel
     if ( aSalShlData.mbWNT )
     {
         LOGFONTW aLogFont;
-        ImplGetLogFontFromFontSelect( maGraphicsData.mhDC, pFont, aLogFont, true );
+        ImplGetLogFontFromFontSelect( mhDC, pFont, aLogFont, true );
 
         // Auf dem Bildschirm nehmen wir Courier New, wenn Courier nicht
         // skalierbar ist und wenn der Font skaliert oder rotiert werden
         // muss
-        if ( maGraphicsData.mbScreen &&
+        if ( mbScreen &&
              (pFont->mnWidth || pFont->mnOrientation ||
               !pFont->mpFontData || (pFont->mpFontData->mnHeight != pFont->mnHeight)) &&
              !bImplSalCourierScalable && bImplSalCourierNew &&
              (ImplSalWICompareAscii( aLogFont.lfFaceName, "Courier" ) == 0) )
-            lstrcpyW( aLogFont.lfFaceName, L"Courier New" );
+            lstrcpynW( aLogFont.lfFaceName, L"Courier New", 11 );
 
-        hOldFont = ImplSelectFontW( maGraphicsData.mhDC, aLogFont, &hNewFont );
+        hOldFont = ImplSelectFontW( mhDC, aLogFont, &hNewFont );
     }
     else
     {
-        if ( !maGraphicsData.mpLogFont )
-            maGraphicsData.mpLogFont = new LOGFONTA;
+        if ( !mpLogFont )
+            mpLogFont = new LOGFONTA;
 
         ByteString aName;
         if ( pFont->mpFontData )
@@ -806,91 +780,91 @@ USHORT SalGraphics::SetFont( ImplFontSel
 
         // Test for vertical
         if ( pFont->mbVertical )
-            ImplSalGetVerticalFontNameA( maGraphicsData.mhDC, aName );
+            ImplSalGetVerticalFontNameA( mhDC, aName );
 
         UINT nNameLen = aName.Len();
-        if ( nNameLen > sizeof( maGraphicsData.mpLogFont->lfFaceName )-1 )
-            nNameLen = sizeof( maGraphicsData.mpLogFont->lfFaceName )-1;
-        memcpy( maGraphicsData.mpLogFont->lfFaceName, aName.GetBuffer(), nNameLen );
-        maGraphicsData.mpLogFont->lfFaceName[nNameLen] = 0;
+        if ( nNameLen > sizeof( mpLogFont->lfFaceName )-1 )
+            nNameLen = sizeof( mpLogFont->lfFaceName )-1;
+        memcpy( mpLogFont->lfFaceName, aName.GetBuffer(), nNameLen );
+        mpLogFont->lfFaceName[nNameLen] = 0;
 
         if ( pFont->mpFontData )
-            maGraphicsData.mpLogFont->lfCharSet = (WIN_BYTE)(pFont->mpFontData->mpSysData);
+            mpLogFont->lfCharSet = (WIN_BYTE)(pFont->mpFontData->mpSysData);
         else
-            maGraphicsData.mpLogFont->lfCharSet = ImplCharSetToWin( pFont->meCharSet );
+            mpLogFont->lfCharSet = ImplCharSetToWin( pFont->meCharSet );
 
-        maGraphicsData.mpLogFont->lfPitchAndFamily  = ImplPitchToWin( pFont->mePitch );
-        maGraphicsData.mpLogFont->lfPitchAndFamily |= ImplFamilyToWin( pFont->meFamily );
-        maGraphicsData.mpLogFont->lfWeight          = ImplWeightToWin( pFont->meWeight );
-        maGraphicsData.mpLogFont->lfHeight          = (int)-pFont->mnHeight;
-        maGraphicsData.mpLogFont->lfWidth           = (int)pFont->mnWidth;
-        maGraphicsData.mpLogFont->lfUnderline       = 0;
-        maGraphicsData.mpLogFont->lfStrikeOut       = 0;
-        maGraphicsData.mpLogFont->lfItalic          = (pFont->meItalic) != ITALIC_NONE;
-        maGraphicsData.mpLogFont->lfEscapement      = pFont->mnOrientation;
-        maGraphicsData.mpLogFont->lfOrientation     = 0;
-        maGraphicsData.mpLogFont->lfClipPrecision   = CLIP_DEFAULT_PRECIS;
-        maGraphicsData.mpLogFont->lfQuality         = DEFAULT_QUALITY;
-        maGraphicsData.mpLogFont->lfOutPrecision    = OUT_TT_PRECIS;
+        mpLogFont->lfPitchAndFamily  = ImplPitchToWin( pFont->mePitch );
+        mpLogFont->lfPitchAndFamily |= ImplFamilyToWin( pFont->meFamily );
+        mpLogFont->lfWeight          = ImplWeightToWin( pFont->meWeight );
+        mpLogFont->lfHeight          = (int)-pFont->mnHeight;
+        mpLogFont->lfWidth           = (int)pFont->mnWidth;
+        mpLogFont->lfUnderline       = 0;
+        mpLogFont->lfStrikeOut       = 0;
+        mpLogFont->lfItalic          = (pFont->meItalic) != ITALIC_NONE;
+        mpLogFont->lfEscapement      = pFont->mnOrientation;
+        mpLogFont->lfOrientation     = 0;
+        mpLogFont->lfClipPrecision   = CLIP_DEFAULT_PRECIS;
+        mpLogFont->lfQuality         = DEFAULT_QUALITY;
+        mpLogFont->lfOutPrecision    = OUT_TT_PRECIS;
         if ( pFont->mnOrientation )
-            maGraphicsData.mpLogFont->lfClipPrecision |= CLIP_LH_ANGLES;
+            mpLogFont->lfClipPrecision |= CLIP_LH_ANGLES;
 
         // disable antialiasing if requested
         if ( pFont->mbNonAntialiased )
-            maGraphicsData.mpLogFont->lfQuality = NONANTIALIASED_QUALITY;
+            mpLogFont->lfQuality = NONANTIALIASED_QUALITY;
 
         // on the display we prefer Courier New when Courier is a
         // bitmap only font and we need to stretch or rotate it
-        if ( maGraphicsData.mbScreen &&
+        if ( mbScreen &&
              (pFont->mnWidth || pFont->mnOrientation ||
               !pFont->mpFontData || (pFont->mpFontData->mnHeight != pFont->mnHeight)) &&
              !bImplSalCourierScalable && bImplSalCourierNew &&
-             (stricmp( maGraphicsData.mpLogFont->lfFaceName, "Courier" ) == 0) )
-            strcpy( maGraphicsData.mpLogFont->lfFaceName, "Courier New" );
+             (stricmp( mpLogFont->lfFaceName, "Courier" ) == 0) )
+            strncpy( mpLogFont->lfFaceName, "Courier New", 11 );
 
-        hOldFont = ImplSelectFontA( maGraphicsData.mhDC, *maGraphicsData.mpLogFont, &hNewFont );
+        hOldFont = ImplSelectFontA( mhDC, *mpLogFont, &hNewFont );
     }
 
-    if( !maGraphicsData.mhDefFont )
+    if( !mhDefFont )
     {
         // keep default font
-        maGraphicsData.mhDefFont = hOldFont;
+        mhDefFont = hOldFont;
     }
     else
     {
         // dereference unused fonts
         for( int i = nFallbackLevel; i < MAX_FALLBACK; ++i )
         {
-            if( maGraphicsData.mhFonts[i] )
+            if( mhFonts[i] )
             {
-                DeleteFont( maGraphicsData.mhFonts[i] );
-                maGraphicsData.mhFonts[i] = 0;
+                DeleteFont( mhFonts[i] );
+                mhFonts[i] = 0;
             }
         }
     }
 
     // store new font in correct layer
-    maGraphicsData.mhFonts[ nFallbackLevel ] = hNewFont;
+    mhFonts[ nFallbackLevel ] = hNewFont;
 
     if( !nFallbackLevel )
     {
-        maGraphicsData.mnFontCharSetCount = 0;
-        maGraphicsData.mbFontKernInit = TRUE;
-        if ( maGraphicsData.mpFontKernPairs )
+        mnFontCharSetCount = 0;
+        mbFontKernInit = TRUE;
+        if ( mpFontKernPairs )
         {
-            delete[] maGraphicsData.mpFontKernPairs;
-            maGraphicsData.mpFontKernPairs = NULL;
+            delete[] mpFontKernPairs;
+            mpFontKernPairs = NULL;
         }
-        maGraphicsData.mnFontKernPairCount = 0;
+        mnFontKernPairCount = 0;
     }
 
-    if (maGraphicsData.mxTextLayoutCache.get() != 0)
-        maGraphicsData.mxTextLayoutCache->flush( nFallbackLevel );
+    if (mxTextLayoutCache.get() != 0)
+        mxTextLayoutCache->flush( nFallbackLevel );
 
     // some printers have higher internal resolution, so their
     // text output would be different from what we calculated
     // => suggest DrawTextArray to workaround this problem
-    if ( maGraphicsData.mbPrinter )
+    if ( mbPrinter )
         return SAL_SETFONT_USEDRAWTEXTARRAY;
     else
         return 0;
@@ -898,16 +872,16 @@ USHORT SalGraphics::SetFont( ImplFontSel
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetFontMetric( ImplFontMetricData* pMetric )
+void WinSalGraphics::GetFontMetric( ImplFontMetricData* pMetric )
 {
     if ( aSalShlData.mbWNT )
     {
         wchar_t aFaceName[LF_FACESIZE+60];
-        if ( GetTextFaceW( maGraphicsData.mhDC, sizeof( aFaceName ) / sizeof( wchar_t ), aFaceName ) )
+        if ( GetTextFaceW( mhDC, sizeof( aFaceName ) / sizeof( wchar_t ), aFaceName ) )
             pMetric->maName = aFaceName;
 
         TEXTMETRICW aWinMetric;
-        if ( GetTextMetricsW( maGraphicsData.mhDC, &aWinMetric ) )
+        if ( GetTextMetricsW( mhDC, &aWinMetric ) )
         {
             pMetric->mnWidth            = aWinMetric.tmAveCharWidth;
             pMetric->meFamily           = ImplFamilyToSal( aWinMetric.tmPitchAndFamily );;
@@ -946,11 +938,11 @@ void SalGraphics::GetFontMetric( ImplFon
     else
     {
         char aFaceName[LF_FACESIZE+60];
-        if ( GetTextFaceA( maGraphicsData.mhDC, sizeof( aFaceName ), aFaceName ) )
+        if ( GetTextFaceA( mhDC, sizeof( aFaceName ), aFaceName ) )
             pMetric->maName = ImplSalGetUniString( aFaceName );
 
         TEXTMETRICA aWinMetric;
-        if ( GetTextMetricsA( maGraphicsData.mhDC, &aWinMetric ) )
+        if ( GetTextMetricsA( mhDC, &aWinMetric ) )
         {
             pMetric->mnWidth            = aWinMetric.tmAveCharWidth;
             pMetric->meFamily           = ImplFamilyToSal( aWinMetric.tmPitchAndFamily );;
@@ -994,7 +989,7 @@ int CALLBACK SalEnumCharSetsProcExA( con
                                      const NEWTEXTMETRICEXA* pMetric,
                                      DWORD nFontType, LPARAM lParam )
 {
-    SalGraphicsData* pData = (SalGraphicsData*)lParam;
+    WinSalGraphics* pData = (WinSalGraphics*)lParam;
     // Charset already in the list?
     for ( BYTE i = 0; i < pData->mnFontCharSetCount; i++ )
     {
@@ -1008,7 +1003,7 @@ int CALLBACK SalEnumCharSetsProcExA( con
 
 // -----------------------------------------------------------------------
 
-static void ImplGetAllFontCharSets( SalGraphicsData* pData )
+static void ImplGetAllFontCharSets( WinSalGraphics* pData )
 {
     if ( !pData->mpFontCharSets )
         pData->mpFontCharSets = new BYTE[256];
@@ -1023,7 +1018,7 @@ static void ImplGetAllFontCharSets( SalG
 
 // -----------------------------------------------------------------------
 
-static void ImplAddKerningPairs( SalGraphicsData* pData )
+static void ImplAddKerningPairs( WinSalGraphics* pData )
 {
     ULONG nPairs = ::GetKerningPairsA( pData->mhDC, 0, NULL );
     if ( !nPairs )
@@ -1121,75 +1116,75 @@ static void ImplAddKerningPairs( SalGrap
 
 // -----------------------------------------------------------------------
 
-ULONG SalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs )
+ULONG WinSalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs )
 {
     DBG_ASSERT( sizeof( KERNINGPAIR ) == sizeof( ImplKernPairData ),
-                "SalGraphics::GetKernPairs(): KERNINGPAIR != ImplKernPairData" );
+                "WinSalGraphics::GetKernPairs(): KERNINGPAIR != ImplKernPairData" );
 
-    if ( maGraphicsData.mbFontKernInit )
+    if ( mbFontKernInit )
     {
-        if( maGraphicsData.mpFontKernPairs )
+        if( mpFontKernPairs )
         {
-            delete[] maGraphicsData.mpFontKernPairs;
-            maGraphicsData.mpFontKernPairs = NULL;
+            delete[] mpFontKernPairs;
+            mpFontKernPairs = NULL;
         }
-        maGraphicsData.mnFontKernPairCount = 0;
+        mnFontKernPairCount = 0;
 
         if ( aSalShlData.mbWNT )
         {
             KERNINGPAIR* pPairs = NULL;
-            int nCount = ::GetKerningPairsW( maGraphicsData.mhDC, 0, NULL );
+            int nCount = ::GetKerningPairsW( mhDC, 0, NULL );
             if( nCount )
             {
 #ifdef GCP_KERN_HACK
                 pPairs = new KERNINGPAIR[ nCount+1 ];
-                maGraphicsData.mpFontKernPairs = pPairs;
-                maGraphicsData.mnFontKernPairCount = nCount;
-                ::GetKerningPairsW( maGraphicsData.mhDC, nCount, pPairs );
+                mpFontKernPairs = pPairs;
+                mnFontKernPairCount = nCount;
+                ::GetKerningPairsW( mhDC, nCount, pPairs );
 #else // GCP_KERN_HACK
                 pPairs = pKernPairs;
                 nCount = (nCount < nPairs) : nCount : nPairs;
-                ::GetKerningPairsW( maGraphicsData.mhDC, nCount, pPairs );
+                ::GetKerningPairsW( mhDC, nCount, pPairs );
                 return nCount;
 #endif // GCP_KERN_HACK
             }
         }
         else
         {
-            if ( !maGraphicsData.mnFontCharSetCount )
-                ImplGetAllFontCharSets( &maGraphicsData );
+            if ( !mnFontCharSetCount )
+                ImplGetAllFontCharSets( this );
 
-            if ( maGraphicsData.mnFontCharSetCount <= 1 )
-                ImplAddKerningPairs( &maGraphicsData );
+            if ( mnFontCharSetCount <= 1 )
+                ImplAddKerningPairs( this );
             else
             {
                 // Query All Kerning Pairs from all possible CharSets
-                for ( BYTE i = 0; i < maGraphicsData.mnFontCharSetCount; i++ )
+                for ( BYTE i = 0; i < mnFontCharSetCount; i++ )
                 {
-                    maGraphicsData.mpLogFont->lfCharSet = maGraphicsData.mpFontCharSets[i];
-                    HFONT hNewFont = CreateFontIndirectA( maGraphicsData.mpLogFont );
-                    HFONT hOldFont = SelectFont( maGraphicsData.mhDC, hNewFont );
-                    ImplAddKerningPairs( &maGraphicsData );
-                    SelectFont( maGraphicsData.mhDC, hOldFont );
+                    mpLogFont->lfCharSet = mpFontCharSets[i];
+                    HFONT hNewFont = CreateFontIndirectA( mpLogFont );
+                    HFONT hOldFont = SelectFont( mhDC, hNewFont );
+                    ImplAddKerningPairs( this );
+                    SelectFont( mhDC, hOldFont );
                     DeleteFont( hNewFont );
                 }
             }
         }
 
-        maGraphicsData.mbFontKernInit = FALSE;
+        mbFontKernInit = FALSE;
 
-        std::sort( maGraphicsData.mpFontKernPairs,
-            maGraphicsData.mpFontKernPairs + maGraphicsData.mnFontKernPairCount,
+        std::sort( mpFontKernPairs,
+            mpFontKernPairs + mnFontKernPairCount,
             ImplCmpKernData );
     }
 
     if( !pKernPairs )
-        return maGraphicsData.mnFontKernPairCount;
-    else if( maGraphicsData.mpFontKernPairs )
+        return mnFontKernPairCount;
+    else if( mpFontKernPairs )
     {
-        if ( nPairs < maGraphicsData.mnFontKernPairCount )
-            nPairs = maGraphicsData.mnFontKernPairCount;
-        memcpy( pKernPairs, maGraphicsData.mpFontKernPairs,
+        if ( nPairs < mnFontKernPairCount )
+            nPairs = mnFontKernPairCount;
+        memcpy( pKernPairs, mpFontKernPairs,
                 nPairs*sizeof( ImplKernPairData ) );
         return nPairs;
     }
@@ -1204,7 +1199,7 @@ static unsigned GetUShort( const unsigne
 static signed GetSShort( const unsigned char* p ){ return((short)((p[0]<<8)+p[1]));}
 static inline DWORD CalcTag( const char p[4]) { return (p[0]+(p[1]<<8)+(p[2]<<16)+(p[3]<<24)); }
 
-static BOOL FontHasCJKUnicodeRange( const SalGraphics* pGraphics, BOOL &bHasKoreanRange )
+static BOOL FontHasCJKUnicodeRange( const WinSalGraphics* pGraphics, BOOL &bHasKoreanRange )
 {
     BOOL bCJKCapable = FALSE;
     bHasKoreanRange = FALSE;
@@ -1212,12 +1207,12 @@ static BOOL FontHasCJKUnicodeRange( cons
     if ( pGraphics )
     {
         const DWORD Cos2Tag = CalcTag( "OS/2" );
-        DWORD nRCos2 = GetFontData( pGraphics->maGraphicsData.mhDC, Cos2Tag, 0, NULL, 0 );
+        DWORD nRCos2 = GetFontData( pGraphics->mhDC, Cos2Tag, 0, NULL, 0 );
         if ( nRCos2 != GDI_ERROR )
         {
             int nLength = nRCos2;
             unsigned char* pOS2map = (unsigned char*)alloca( nLength );
-            nRCos2 = GetFontData( pGraphics->maGraphicsData.mhDC, Cos2Tag, 0, pOS2map, nLength );
+            nRCos2 = GetFontData( pGraphics->mhDC, Cos2Tag, 0, pOS2map, nLength );
             sal_uInt32 version = GetUShort( pOS2map );
             if ( version >= 0x0001 && nLength >= 58 )
             {
@@ -1243,20 +1238,20 @@ static BOOL FontHasCJKUnicodeRange( cons
     return bCJKCapable;
 }
 
-ULONG SalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
+ULONG WinSalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
 {
     int nRangeCount = 0;
 
 	// get SFNT font's CMAP table
 	const DWORD CmapTag = CalcTag( "cmap" );
-	DWORD nRC = GetFontData( maGraphicsData.mhDC, CmapTag, 0, NULL, 0 );
+	DWORD nRC = GetFontData( mhDC, CmapTag, 0, NULL, 0 );
 	if( nRC == GDI_ERROR )
         return 0;
 
 	int nLength = nRC;
     std::vector<unsigned char> aCmap( nLength );
     unsigned char* pCmap = &aCmap[0];
-	nRC = GetFontData( maGraphicsData.mhDC, CmapTag, 0, pCmap, nLength );
+	nRC = GetFontData( mhDC, CmapTag, 0, pCmap, nLength );
 	if( nRC == GDI_ERROR )
         return 0;
     // check for the CMAP table corruption
@@ -1276,28 +1271,28 @@ ULONG SalGraphics::GetFontCodeRanges( sa
 	    int nTmpOffset = GetUInt( p+4 );
 	    int nTmpFormat = GetUShort( pCmap + nTmpOffset );
 
-        int nValue;
-		if( nPlatform==3 && nEncoding==1 )      // Win Unicode
-            nValue = 3;
-        else if( nPlatform==1 && nEncoding==3 ) // Mac Unicode>2.0
-            nValue = 2;
-        else if( nPlatform==1 && nEncoding==0 ) // Mac Unicode<2.0
-            nValue = 1;
-        else
-            continue;                           // ignore non-unicode tables
+		int nValue;
+		if( nPlatform==3 && nEncoding==1 )		// Win Unicode
+			nValue = 3;
+		else if( nPlatform==1 && nEncoding==3 )	// Mac Unicode>2.0
+			nValue = 2;
+		else if( nPlatform==1 && nEncoding==0 )	// Mac Unicode<2.0
+			nValue = 1;
+		else
+			continue;							// ignore non-unicode tables
+
+		if( nTmpFormat == 12 )					// 32bit unicode mappings
+			nValue += 3;
+		else if( nTmpFormat != 4 )				// 16bit unicode mappings
+			continue;							// ignore other formats
 
-	    if( nTmpFormat == 12 )                  // 32bit unicode mappings
-            nValue += 3;
-        else if( nTmpFormat != 4 )              // 16bit unicode mappings
-            continue;                           // ignore other formats
-
-        if( nBestVal < nValue )
-        {
-            nBestVal = nValue;
-            nOffset = nTmpOffset;
-            nFormat = nTmpFormat;
-        }
-    }
+		if( nBestVal < nValue )
+		{
+			nBestVal = nValue;
+			nOffset = nTmpOffset;
+			nFormat = nTmpFormat;
+		}
+	}
 
     sal_uInt32* pCP = pCodePairs;
 
@@ -1362,7 +1357,7 @@ int CALLBACK SalEnumFontsProcExA( const 
                 pInfo->mbCourier = FALSE;
             XubString aName( ImplSalGetUniString( pLogFont->elfLogFont.lfFaceName ) );
             pInfo->mpName = &aName;
-            strcpy( pInfo->mpLogFontA->lfFaceName, pLogFont->elfLogFont.lfFaceName );
+            strncpy( pInfo->mpLogFontA->lfFaceName, pLogFont->elfLogFont.lfFaceName, LF_FACESIZE );
             pInfo->mpLogFontA->lfCharSet = pLogFont->elfLogFont.lfCharSet;
             EnumFontFamiliesExA( pInfo->mhDC, pInfo->mpLogFontA, (FONTENUMPROCA)SalEnumFontsProcExA,
                                  (LPARAM)(void*)pInfo, 0 );
@@ -1539,7 +1534,7 @@ bool ImplAddTempFont( SalData& rSalData,
     ::rtl::OUString aUSytemPath;
     OSL_VERIFY( !osl::FileBase::getSystemPathFromFileURL( rFontFileURL, aUSytemPath ) );
 
-#ifdef FR_PRIVATE
+#ifdef FR_PRIVATE   // wingdi.h, but only if _WIN32_WINNT >= 0x0500, which is currently not true.
     OSVERSIONINFO aVersion;
     aVersion.dwOSVersionInfoSize = sizeof(aVersion);
     if( ::GetVersionEx( &aVersion ) && (aVersion.dwMajorVersion >= 5) )
@@ -1547,7 +1542,7 @@ bool ImplAddTempFont( SalData& rSalData,
         nRet = AddFontResourceExW( aUSytemPath.getStr(), FR_PRIVATE, NULL );
     }
     else
-#endif // FR_PRIVATE
+#endif        
     {
         static int nCounter = 0;
         char aFileName[] = "soAA.fot";
@@ -1556,7 +1551,9 @@ bool ImplAddTempFont( SalData& rSalData,
         char aResourceName[512];
         int nMaxLen = sizeof(aResourceName)/sizeof(*aResourceName) - 16;
         int nLen = ::GetTempPathA( nMaxLen, aResourceName );
-        ::strcpy( aResourceName + nLen, aFileName );
+        ::strncpy( aResourceName + nLen, aFileName, sizeof( aResourceName )- nLen );
+        // security: end buffer in any case
+        aResourceName[ 511 ] = 0;
         ::DeleteFileA( aResourceName );
 
         rtl_TextEncoding theEncoding = osl_getThreadTextEncoding();
@@ -1577,9 +1574,7 @@ bool ImplAddTempFont( SalData& rSalData,
         }
     }
 
-    if( nRet > 0 )
-        return true;
-    return false;
+	return ( nRet > 0 ) ? true : false;
 }
 
 // -----------------------------------------------------------------------
@@ -1637,11 +1632,7 @@ String ImplGetFontNameFromFile( SalData&
     char aResourceName[512];
     int nMaxLen = sizeof(aResourceName)/sizeof(*aResourceName) - 16;
     int nLen = ::GetTempPathA( nMaxLen, aResourceName );
-#if (_MSC_VER < 1300)
-    ::strncpy( aResourceName + nLen, aFileName, std::max( 0, nMaxLen - nLen ));
-#else
-    ::strncpy( aResourceName + nLen, aFileName, max( 0, nMaxLen - nLen ));
-#endif
+    ::strncpy( aResourceName + nLen, aFileName, Max( 0, nMaxLen - nLen ));
     ::DeleteFileA( aResourceName );
 
     // Create font resource file (typically with a .fot file name extension).    
@@ -1722,7 +1713,7 @@ String ImplGetFontNameFromFile( SalData&
 
 // -----------------------------------------------------------------------
 
-ImplFontData* SalGraphics::AddTempDevFont( const String& rFontFileURL, const String& rFontName )
+ImplFontData* WinSalGraphics::AddTempDevFont( const String& rFontFileURL, const String& rFontName )
 {
     String aFontName( rFontName );
     
@@ -1733,7 +1724,7 @@ ImplFontData* SalGraphics::AddTempDevFon
     if ( !aFontName.Len() )
         return NULL;
 
-    if( ::ImplIsFontAvailable( maGraphicsData.mhDC, aFontName ) )
+    if( ::ImplIsFontAvailable( mhDC, aFontName ) )
         return NULL;
 
     // remember temp font for cleanup later
@@ -1768,18 +1759,19 @@ ImplFontData* SalGraphics::AddTempDevFon
     pFontData->mbSubsettable= FALSE;
     pFontData->mbEmbeddable = FALSE;
 
-#if 0   // TODO: improve ImplFontData using "FONTRES:" from *.fot file
+	/*
+	// TODO: improve ImplFontData using "FONTRES:" from *.fot file
     pFontData->maSearchName = // using "FONTRES:" from file
     if( rFontName != pFontData->maName )
         pFontData->maMapName = aFontName;
-#endif
+	*/
 
     return pFontData;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetDevFontList( ImplDevFontList* pList )
+void WinSalGraphics::GetDevFontList( ImplDevFontList* pList )
 {
     // make sure all fonts are registered at least temporarily
     static bool bOnce = true;
@@ -1815,13 +1807,13 @@ void SalGraphics::GetDevFontList( ImplDe
     }
 
     ImplEnumInfo aInfo;
-    aInfo.mhDC          = maGraphicsData.mhDC;
+    aInfo.mhDC          = mhDC;
     aInfo.mpList        = pList;
     aInfo.mpName        = NULL;
     aInfo.mpLogFontA    = NULL;
     aInfo.mpLogFontW    = NULL;
     aInfo.mbCourier     = FALSE;
-    if ( !maGraphicsData.mbPrinter )
+    if ( !mbPrinter )
     {
         aInfo.mbImplSalCourierScalable  = FALSE;
         aInfo.mbImplSalCourierNew       = FALSE;
@@ -1846,7 +1838,7 @@ void SalGraphics::GetDevFontList( ImplDe
         memset( &aLogFont, 0, sizeof( aLogFont ) );
         aLogFont.lfCharSet = DEFAULT_CHARSET;
         aInfo.mpLogFontW = &aLogFont;
-        EnumFontFamiliesExW( maGraphicsData.mhDC, &aLogFont,
+        EnumFontFamiliesExW( mhDC, &aLogFont,
             (FONTENUMPROCW)SalEnumFontsProcExW, (LPARAM)(void*)&aInfo, 0 );
     }
     else
@@ -1855,13 +1847,13 @@ void SalGraphics::GetDevFontList( ImplDe
         memset( &aLogFont, 0, sizeof( aLogFont ) );
         aLogFont.lfCharSet = DEFAULT_CHARSET;
         aInfo.mpLogFontA = &aLogFont;
-        EnumFontFamiliesExA( maGraphicsData.mhDC, &aLogFont,
+        EnumFontFamiliesExA( mhDC, &aLogFont,
             (FONTENUMPROCA)SalEnumFontsProcExA, (LPARAM)(void*)&aInfo, 0 );
     }
 
     // Feststellen, was es fuer Courier-Schriften auf dem Bildschirm gibt,
     // um in SetFont() evt. Courier auf Courier New zu mappen
-    if ( !maGraphicsData.mbPrinter )
+    if ( !mbPrinter )
     {
         bImplSalCourierScalable = aInfo.mbImplSalCourierScalable;
         bImplSalCourierNew      = aInfo.mbImplSalCourierNew;
@@ -1870,14 +1862,14 @@ void SalGraphics::GetDevFontList( ImplDe
 
 // ----------------------------------------------------------------------------
 
-void SalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
+void WinSalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
 {}
 
 // -----------------------------------------------------------------------
 
-BOOL SalGraphics::GetGlyphBoundRect( long nIndex, Rectangle& rRect, const OutputDevice* )
+BOOL WinSalGraphics::GetGlyphBoundRect( long nIndex, Rectangle& rRect )
 {
-    HDC hDC = maGraphicsData.mhDC;
+    HDC hDC = mhDC;
 
     // use unity matrix
     MAT2 aMat;
@@ -1906,12 +1898,12 @@ BOOL SalGraphics::GetGlyphBoundRect( lon
 
 // -----------------------------------------------------------------------
 
-BOOL SalGraphics::GetGlyphOutline( long nIndex, PolyPolygon& rPolyPoly, const OutputDevice* )
+BOOL WinSalGraphics::GetGlyphOutline( long nIndex, PolyPolygon& rPolyPoly )
 {
     rPolyPoly.Clear();
 
     BOOL bRet = FALSE;
-    HDC  hDC = maGraphicsData.mhDC;
+    HDC  hDC = mhDC;
 
     // use unity matrix
     MAT2 aMat;
@@ -2101,16 +2093,16 @@ private:
 class ScopedFont
 {
 public:
-    explicit ScopedFont(SalGraphicsData & rData);
+    explicit ScopedFont(WinSalGraphics & rData);
 
     ~ScopedFont();
 
 private:
-    SalGraphicsData & m_rData;
+    WinSalGraphics & m_rData;
     HFONT m_hOrigFont;
 };
 
-ScopedFont::ScopedFont(SalGraphicsData & rData): m_rData(rData)
+ScopedFont::ScopedFont(WinSalGraphics & rData): m_rData(rData)
 {
     m_hOrigFont = m_rData.mhFonts[0];
     m_rData.mhFonts[0] = 0; // avoid deletion of current font
@@ -2156,7 +2148,7 @@ int ScopedTrueTypeFont::open(void * pBuf
     return OpenTTFont(pBuffer, nLen, nFaceNum, &m_pFont);
 }
 
-BOOL SalGraphics::CreateFontSubset( const rtl::OUString& rToFile,
+BOOL WinSalGraphics::CreateFontSubset( const rtl::OUString& rToFile,
     ImplFontData* pFont, long* pGlyphIDs, sal_uInt8* pEncoding,
     sal_Int32* pWidths, int nGlyphs, FontSubsetInfo& rInfo )
 {
@@ -2182,13 +2174,13 @@ BOOL SalGraphics::CreateFontSubset( cons
     aIFSD.mbNonAntialiased  = false;
 
     // TODO: much better solution: move SetFont and restoration of old font to caller
-    ScopedFont aOldFont(maGraphicsData);
+    ScopedFont aOldFont(*this);
     SetFont( &aIFSD, 0 );
 
 #if OSL_DEBUG_LEVEL > 1
     // get font metrics
     TEXTMETRICA aWinMetric;
-    if( !::GetTextMetricsA( maGraphicsData.mhDC, &aWinMetric ) )
+    if( !::GetTextMetricsA( mhDC, &aWinMetric ) )
         return FALSE;
 
     DBG_ASSERT( !(aWinMetric.tmPitchAndFamily & TMPF_DEVICE), "cannot subset device font" );
@@ -2196,11 +2188,11 @@ BOOL SalGraphics::CreateFontSubset( cons
 #endif
 
     // get raw font file data
-    DWORD nFontSize = ::GetFontData( maGraphicsData.mhDC, 0, 0, NULL, 0 );
+    DWORD nFontSize = ::GetFontData( mhDC, 0, 0, NULL, 0 );
     if( nFontSize == GDI_ERROR )
         return FALSE;
     ScopedCharArray xRawFontData(new char[ nFontSize ]);
-    DWORD nFontSize2 = ::GetFontData( maGraphicsData.mhDC, 0, 0, (void*)xRawFontData.get(), nFontSize );
+    DWORD nFontSize2 = ::GetFontData( mhDC, 0, 0, (void*)xRawFontData.get(), nFontSize );
     if( nFontSize != nFontSize2 )
         return FALSE;
 
@@ -2291,7 +2283,7 @@ BOOL SalGraphics::CreateFontSubset( cons
 
 //--------------------------------------------------------------------------
 
-const void* SalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+const void* WinSalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
 {
     // TODO: how to get access to Type 1 font files on this platform?
     return NULL;
@@ -2299,16 +2291,22 @@ const void* SalGraphics::GetEmbedFontDat
 
 //--------------------------------------------------------------------------
 
-void SalGraphics::FreeEmbedFontData( const void* pData, long nLen )
+void WinSalGraphics::FreeEmbedFontData( const void* pData, long nLen )
 {
     // TODO: once GetEmbedFontData() above does something check implementation below
     free( (void*)pData );
 }
 
-const std::map< sal_Unicode, sal_Int32 >* SalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+const std::map< sal_Unicode, sal_Int32 >* WinSalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
 {
     // TODO: once GetEmbedFontData() above does something this needs implementation
     if( pNonEncoded )
         *pNonEncoded = NULL;
     return NULL;
+}
+
+//--------------------------------------------------------------------------
+
+void WinSalGraphics::DrawServerFontLayout( const ServerFontLayout& )
+{
 }
Index: vcl/win/source/gdi/salnativewidgets-luna.cxx
===================================================================
RCS file: vcl/win/source/gdi/salnativewidgets-luna.cxx
diff -N vcl/win/source/gdi/salnativewidgets-luna.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/source/gdi/salnativewidgets-luna.cxx	10 May 2004 16:02:25 -0000	1.2
@@ -0,0 +1,977 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_CXX
+
+#ifndef _SV_SVSYS_H
+#include <svsys.h>
+#endif
+
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
+#endif
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#include "uxtheme.h"
+#include "tmschema.h"
+
+#include <map>
+#include <string>
+
+using namespace rtl;
+using namespace std;
+
+typedef map< wstring, HTHEME > ThemeMap;
+static ThemeMap aThemeMap;
+
+
+/****************************************************
+ wrap visual styles API to avoid linking against it
+ it is not available on all Windows platforms
+*****************************************************/
+
+class VisualStylesAPI
+{
+private:
+    typedef HTHEME  (WINAPI * OpenThemeData_Proc_T) ( HWND hwnd, LPCWSTR pszClassList );
+    typedef HRESULT (WINAPI * CloseThemeData_Proc_T) ( HTHEME hTheme );
+    typedef HRESULT (WINAPI * GetThemeBackgroundContentRect_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    typedef HRESULT (WINAPI * DrawThemeBackground_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    typedef HRESULT (WINAPI * DrawThemeText_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    typedef HRESULT (WINAPI * GetThemePartSize_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+
+    OpenThemeData_Proc_T                    lpfnOpenThemeData;
+    CloseThemeData_Proc_T                   lpfnCloseThemeData;
+    GetThemeBackgroundContentRect_Proc_T    lpfnGetThemeBackgroundContentRect;
+    DrawThemeBackground_Proc_T              lpfnDrawThemeBackground;
+    DrawThemeText_Proc_T                    lpfnDrawThemeText;
+    GetThemePartSize_Proc_T                 lpfnGetThemePartSize;
+
+    HMODULE mhModule;
+
+public:
+    VisualStylesAPI();
+    ~VisualStylesAPI();
+    BOOL IsAvailable()  { return (mhModule != NULL); }
+
+    HTHEME OpenThemeData( HWND hwnd, LPCWSTR pszClassList );
+    HRESULT CloseThemeData( HTHEME hTheme );
+    HRESULT GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    HRESULT DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    HRESULT DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    HRESULT GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+};
+
+static VisualStylesAPI vsAPI;
+
+VisualStylesAPI::VisualStylesAPI()
+{
+    mhModule = LoadLibraryA("uxtheme.dll");
+
+    lpfnOpenThemeData = (OpenThemeData_Proc_T) GetProcAddress( mhModule, "OpenThemeData" );
+    lpfnCloseThemeData = (CloseThemeData_Proc_T) GetProcAddress( mhModule, "CloseThemeData" );
+    lpfnGetThemeBackgroundContentRect = (GetThemeBackgroundContentRect_Proc_T) GetProcAddress( mhModule, "GetThemeBackgroundContentRect" );
+    lpfnDrawThemeBackground = (DrawThemeBackground_Proc_T) GetProcAddress( mhModule, "DrawThemeBackground" );
+    lpfnDrawThemeText = (DrawThemeText_Proc_T) GetProcAddress( mhModule, "DrawThemeText" );
+    lpfnGetThemePartSize = (GetThemePartSize_Proc_T) GetProcAddress( mhModule, "GetThemePartSize" );
+}
+VisualStylesAPI::~VisualStylesAPI()
+{
+    if( mhModule )
+        FreeLibrary( mhModule );
+}
+HTHEME VisualStylesAPI::OpenThemeData( HWND hwnd, LPCWSTR pszClassList )
+{
+    if(lpfnOpenThemeData)
+        return (*lpfnOpenThemeData) (hwnd, pszClassList);
+    else
+        return NULL;
+}
+
+HRESULT VisualStylesAPI::CloseThemeData( HTHEME hTheme )
+{
+    if(lpfnCloseThemeData)
+        return (*lpfnCloseThemeData) (hTheme);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect )
+{
+    if(lpfnGetThemeBackgroundContentRect)
+        return (*lpfnGetThemeBackgroundContentRect) ( hTheme, hdc, iPartId, iStateId, pBoundingRect, pContentRect );
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect )
+{
+    if(lpfnDrawThemeBackground)
+        return (*lpfnDrawThemeBackground) (hTheme, hdc, iPartId, iStateId, pRect, pClipRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect )
+{
+    if(lpfnDrawThemeText)
+        return (*lpfnDrawThemeText) (hTheme, hdc, iPartId, iStateId, pszText, iCharCount, dwTextFlags, dwTextFlags2, pRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz )
+{
+    if(lpfnGetThemePartSize)
+        return (*lpfnGetThemePartSize) (hTheme, hdc, iPartId, iStateId, prc, eSize, psz);
+    else
+        return S_FALSE;
+}
+
+
+/*********************************************************
+ * Initialize XP theming and local stuff                         
+ *********************************************************/
+void SalData::initNWF( void )
+{
+}
+
+
+// *********************************************************
+// * Release theming handles
+// ********************************************************
+void SalData::deInitNWF( void )
+{
+    ThemeMap::iterator iter = aThemeMap.begin();
+    while( iter != aThemeMap.end() )
+    {
+        vsAPI.CloseThemeData(iter->second);
+        iter++;
+    }
+    aThemeMap.clear();
+}
+
+static HTHEME getThemeHandle( HWND hWnd, LPCWSTR name )
+{
+    if( GetSalData()->mbThemeChanged )
+    {
+        // throw away invalid theme handles
+        GetSalData()->deInitNWF();
+        GetSalData()->mbThemeChanged = FALSE;
+    }
+
+    ThemeMap::iterator iter;
+    if( (iter = aThemeMap.find( name )) != aThemeMap.end() )
+        return iter->second;
+    // theme not found -> add it to map
+    HTHEME hTheme = vsAPI.OpenThemeData( hWnd, name );
+    if( hTheme != NULL )
+        aThemeMap[name] = hTheme;
+    return hTheme;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL WinSalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    HTHEME hTheme = NULL;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            if( nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT )
+                return FALSE;   // no background painting needed
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else if( nPart == PART_ALL_BUTTONS || 
+                nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN || 
+                nPart == PART_BUTTON_LEFT|| nPart == PART_BUTTON_RIGHT )
+                hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_ALL_BUTTONS )
+                hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+                //return TRUE;
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+            break;
+    }
+
+    return (hTheme != NULL);
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL WinSalGraphics::hitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside )
+{
+    return FALSE;
+}
+
+BOOL ImplDrawTheme( HTHEME hTheme, HDC hDC, int iPart, int iState, RECT rc, const OUString& aStr)
+{
+    HRESULT hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+
+    if( aStr.getLength() )
+    {
+        RECT rcContent;
+        hr = vsAPI.GetThemeBackgroundContentRect( hTheme, hDC, iPart, iState, &rc, &rcContent);
+        hr = vsAPI.DrawThemeText( hTheme, hDC, iPart, iState,
+            aStr.getStr(), -1,
+            DT_CENTER | DT_VCENTER | DT_SINGLELINE,
+            0, &rcContent);
+    }
+    return (hr == S_OK);
+}
+
+
+// Helper functions
+// ----
+
+void ImplConvertSpinbuttonValues( int nControlPart, const ControlState& rState, const Rectangle& rRect, 
+                                 int* pLunaPart, int *pLunaState, RECT *pRect )
+{
+    if( nControlPart == PART_BUTTON_DOWN )
+    {
+        *pLunaPart = SPNP_DOWN;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNS_HOT;
+        else
+            *pLunaState = DNS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_UP )
+    {
+        *pLunaPart = SPNP_UP;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPS_HOT;
+        else
+            *pLunaState = UPS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_RIGHT )
+    {
+        *pLunaPart = SPNP_UPHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNHZS_HOT;
+        else
+            *pLunaState = DNHZS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_LEFT )
+    {
+        *pLunaPart = SPNP_DOWNHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPHZS_HOT;
+        else
+            *pLunaState = UPHZS_NORMAL;
+    }
+
+    pRect->left   = rRect.Left();
+    pRect->right  = rRect.Right()+1;
+    pRect->top    = rRect.Top();
+    pRect->bottom = rRect.Bottom()+1;
+}
+
+// ----
+
+BOOL ImplDrawNativeControl(	HDC hDC, HTHEME hTheme, RECT rc,
+                            ControlType nType,
+							ControlPart nPart,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+    // a listbox dropdown is actually a combobox dropdown
+    if( nType == CTRL_LISTBOX )
+        if( nPart == PART_BUTTON_DOWN )
+            nType = CTRL_COMBOBOX;
+
+    // draw entire combobox as a large edit box
+    if( nType == CTRL_COMBOBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    // draw entire spinbox as a large edit box
+    if( nType == CTRL_SPINBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    int iPart(0), iState(0);
+    if( nType == CTRL_SCROLLBAR )
+    {
+        HRESULT hr;
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_UPPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_UPDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_UPHOT;
+            else
+                iState = ABS_UPNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_DOWNPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_DOWNDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_DOWNHOT;
+            else
+                iState = ABS_DOWNNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_LEFTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_LEFTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_LEFTHOT;
+            else
+                iState = ABS_LEFTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_RIGHTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_RIGHTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_RIGHTHOT;
+            else
+                iState = ABS_RIGHTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_THUMB_HORZ || nPart == PART_THUMB_VERT )
+        {
+            iPart = (nPart == PART_THUMB_HORZ) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+
+            SIZE sz;
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_MIN, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_TRUE, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_DRAW, &sz);
+
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            // paint gripper on thumb if enough space
+            if( ( (nPart == PART_THUMB_VERT) && (rc.bottom-rc.top > 12) ) ||
+                ( (nPart == PART_THUMB_HORZ) && (rc.right-rc.left > 12) ) )
+            {
+                iPart = (nPart == PART_THUMB_HORZ) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+                iState = 0;
+                vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            }
+            return (hr == S_OK);
+        }
+        if( nPart == PART_TRACK_HORZ_LEFT || nPart == PART_TRACK_HORZ_RIGHT || nPart == PART_TRACK_VERT_UPPER || nPart == PART_TRACK_VERT_LOWER )
+        {
+            switch( nPart )
+            {
+                case PART_TRACK_HORZ_LEFT:  iPart = SBP_UPPERTRACKHORZ; break;
+                case PART_TRACK_HORZ_RIGHT: iPart = SBP_LOWERTRACKHORZ; break;
+                case PART_TRACK_VERT_UPPER: iPart = SBP_UPPERTRACKVERT; break;
+                case PART_TRACK_VERT_LOWER: iPart = SBP_LOWERTRACKVERT; break;
+            }
+
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+    }
+    if( nType == CTRL_SPINBUTTONS && nPart == PART_ALL_BUTTONS )
+    {
+        SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            BOOL bOk = FALSE;
+
+            RECT rect;
+            ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+            bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+            if( bOk )
+            {
+                ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+            }
+
+            return bOk;
+        }
+    }
+    if( nType == CTRL_SPINBOX )
+    {
+        // decrease spinbutton rects a little
+        //rc.right--;
+        //rc.bottom--;
+        if( nPart == PART_ALL_BUTTONS )
+        {
+            SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+            if( pValue )
+            {
+                BOOL bOk = FALSE;
+
+                RECT rect;
+                ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+                if( bOk )
+                {
+                    ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                    bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+                }
+
+                return bOk;
+            }
+        }
+
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SPNP_DOWN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNS_HOT;
+            else
+                iState = DNS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SPNP_UP;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPS_HOT;
+            else
+                iState = UPS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SPNP_DOWNHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNHZS_HOT;
+            else
+                iState = DNHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SPNP_UPHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPHZS_HOT;
+            else
+                iState = UPHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT || nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN )
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    if( nType == CTRL_COMBOBOX )
+    {
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = CP_DROPDOWNBUTTON;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = CBXS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = CBXS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = CBXS_HOT;
+            else
+                iState = CBXS_NORMAL;
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+    if( nType == CTRL_PUSHBUTTON )
+    {
+        iPart = BP_PUSHBUTTON;
+        if( nState & CTRL_STATE_PRESSED )
+            iState = PBS_PRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = PBS_DISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = PBS_HOT;
+        else if( nState & CTRL_STATE_DEFAULT )
+            iState = PBS_DEFAULTED;
+        //else if( nState & CTRL_STATE_FOCUSED )
+        //    iState = PBS_DEFAULTED;    // may need to draw focus rect 
+        else
+            iState = PBS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_RADIOBUTTON )
+    {
+        iPart = BP_RADIOBUTTON;
+        BOOL bChecked = ( aValue.getTristateVal() == BUTTONVALUE_ON );
+
+        if( nState & CTRL_STATE_PRESSED )
+            iState = bChecked ? RBS_CHECKEDPRESSED : RBS_UNCHECKEDPRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = bChecked ? RBS_CHECKEDDISABLED : RBS_UNCHECKEDDISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = bChecked ? RBS_CHECKEDHOT : RBS_UNCHECKEDHOT;
+        else
+            iState = bChecked ? RBS_CHECKEDNORMAL : RBS_UNCHECKEDNORMAL;
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_CHECKBOX )
+    {
+        iPart = BP_CHECKBOX;
+        ButtonValue v = aValue.getTristateVal();
+
+        if( nState & CTRL_STATE_PRESSED )
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDPRESSED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDPRESSED : CBS_MIXEDPRESSED );
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDDISABLED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDDISABLED : CBS_MIXEDDISABLED );
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDHOT : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDHOT : CBS_MIXEDHOT );
+        else
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDNORMAL : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDNORMAL : CBS_MIXEDNORMAL );
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        //SIZE sz;
+        //THEMESIZE eSize = TS_DRAW; // TS_MIN, TS_TRUE, TS_DRAW
+        //vsAPI.GetThemePartSize( hTheme, hDC, iPart, iState, &rc, eSize, &sz);
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_EDITBOX )
+    {
+        iPart = EP_EDITTEXT;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = ETS_DISABLED;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = ETS_FOCUSED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = ETS_HOT;
+        else
+            iState = ETS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_LISTBOX )
+    {
+        if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+        {
+            iPart = LVP_EMPTYTEXT; // ??? no idea which part to choose here
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+
+    if( nType == CTRL_TAB_PANE )
+    {
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_FIXEDBORDER )
+    {
+        /*
+        iPart = BP_GROUPBOX;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = GBS_DISABLED;
+        else
+            iState = GBS_NORMAL;
+            */
+        // The fixed border is only used around the tools->options tabpage where
+        // TABP_PANE fits best
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_BODY )
+    {
+        iPart = TABP_BODY;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_ITEM )
+    {
+        iPart = TABP_TABITEMLEFTEDGE;
+        rc.bottom--;
+
+        TabitemValue *pValue = (TabitemValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            if( pValue->isBothAligned() )
+            {
+                iPart = TABP_TABITEMLEFTEDGE;
+                rc.right--;
+            }
+            else if( pValue->isLeftAligned() )
+                iPart = TABP_TABITEMLEFTEDGE;
+            else if( pValue->isRightAligned() )
+                iPart = TABP_TABITEMRIGHTEDGE;
+            else iPart = TABP_TABITEM;
+        }
+ 
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = TILES_DISABLED;
+        else if( nState & CTRL_STATE_SELECTED )
+        {
+            iState = TILES_SELECTED;
+            // increase the selected tab
+            rc.left-=2;
+            if( pValue && !pValue->isBothAligned() )
+            {
+                if( pValue->isLeftAligned() || pValue->isNotAligned() )
+                    rc.right+=2;
+                if( pValue->isRightAligned() )
+                    rc.right+=1;
+            }
+            rc.top-=2;
+            rc.bottom+=2;
+        }
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = TILES_HOT;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = TILES_FOCUSED;    // may need to draw focus rect 
+        else
+            iState = TILES_NORMAL;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    return false;
+}
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the WinSalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL WinSalGraphics::drawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+    BOOL bOk = false;
+    HTHEME hTheme;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            hTheme = getThemeHandle( mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            hTheme = getThemeHandle( mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else
+                hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            hTheme = getThemeHandle( mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            hTheme = getThemeHandle( mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+    }
+
+    if( !hTheme )
+        return false;
+
+	Rectangle buttonRect = rControlRegion.GetBoundRect();
+    RECT rc;
+    rc.left   = buttonRect.Left();
+    rc.right  = buttonRect.Right()+1;
+    rc.top    = buttonRect.Top();
+    rc.bottom = buttonRect.Bottom()+1;
+
+    HDC hDC = GetDC( mhWnd );
+
+    // set default text alignment
+    int ta = SetTextAlign( hDC, TA_LEFT|TA_TOP|TA_NOUPDATECP );
+
+    OUString aCaptionStr( aCaption.replace('~', '&') ); // translate mnemonics
+    bOk = ImplDrawNativeControl(hDC, hTheme, rc,
+                            nType, nPart, nState, aValue,
+							rControlHandle, aCaptionStr );
+
+    // restore alignment
+    SetTextAlign( hDC, ta );
+   
+    ReleaseDC( mhWnd, hDC );
+
+    //GdiFlush();
+
+	return bOk;
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the WinSalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL WinSalGraphics::drawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption )
+{
+	return( false );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the true bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the WinSalGraphics implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL WinSalGraphics::getNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion )
+{
+    BOOL bRet = FALSE;
+    /*
+    if( nType == CTRL_PUSHBUTTON && nPart == PART_ENTIRE_CONTROL )
+    {
+        if( nState & CTRL_STATE_DEFAULT )
+        {
+            // make default button bigger
+            rNativeContentRegion = rControlRegion;
+            Rectangle aBoundRect = rControlRegion.GetBoundRect();
+            aBoundRect.Top() -= 5;
+            aBoundRect.Bottom() += 5;
+            aBoundRect.Left() -= 8;
+            aBoundRect.Right() += 8;
+            rNativeBoundingRegion = Region( aBoundRect );
+            bRet = TRUE;
+        }
+    }
+*/
+	return( bRet );
+}
+
+
Index: vcl/win/source/gdi/salogl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salogl.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/gdi/salogl.cxx	2 Feb 2001 15:18:28 -0000	1.2
+++ vcl/win/source/gdi/salogl.cxx	6 Jan 2004 14:56:06 -0000	1.4
@@ -63,18 +63,14 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALOGL_CXX
-
-#ifndef _SV_SALOGL_HXX
-#include <salogl.hxx>
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
-#ifdef WIN
-#define __OPENGL_CALL _far _pascal
-#elif defined WNT
+#ifdef WNT
 #define __OPENGL_CALL __stdcall
 #else
 #define __OPENGL_CALL
@@ -110,9 +106,9 @@ if( !pImplOpenWGLFnc##FncName ) bRet = F
 
 // Members
 static HINSTANCE	hImplOGLLib;
-HGLRC				SalOpenGL::mhOGLContext = 0;
-HDC 				SalOpenGL::mhOGLLastDC = 0;
-ULONG				SalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
+HGLRC				WinSalOpenGL::mhOGLContext = 0;
+HDC 				WinSalOpenGL::mhOGLLastDC = 0;
+ULONG				WinSalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
 
 INIT_OGLFNC_WGL( CreateContext );
 INIT_OGLFNC_WGL( DeleteContext );
@@ -132,26 +128,26 @@ LRESULT CALLBACK OpenGLWndProc( HWND hWn
 // - SalOpenGL -
 // -------------
 
-SalOpenGL::SalOpenGL( SalGraphics* pGraphics )
+WinSalOpenGL::WinSalOpenGL( SalGraphics* pGraphics )
 {
 	// Set mhOGLLastDC only the first time a
 	// SalOpenGL object is created; we need
 	// this DC in SalOpenGL::Create();
 	if ( OGL_STATE_UNLOADED == mnOGLState )
-		mhOGLLastDC = pGraphics->maGraphicsData.mhDC;
+		mhOGLLastDC = static_cast<WinSalGraphics*>(pGraphics)->mhDC;
 }
 
 // ------------------------------------------------------------------------
 
-SalOpenGL::~SalOpenGL()
+WinSalOpenGL::~WinSalOpenGL()
 {
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::Create()
+bool WinSalOpenGL::IsValid()
 {
-	BOOL bRet = FALSE;
+	bool bRet = false;
 
 	if ( OGL_STATE_UNLOADED == mnOGLState )
 	{
@@ -218,21 +214,21 @@ BOOL SalOpenGL::Create()
 			mnOGLState = OGL_STATE_INVALID;
 	}
 	else if( OGL_STATE_VALID == mnOGLState )
-		bRet = TRUE;
+		bRet = true;
 
 	return bRet;
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::Release()
+void WinSalOpenGL::Release()
 {
 	ImplFreeLib();
 }
 
 // ------------------------------------------------------------------------
 
-void* SalOpenGL::GetOGLFnc( const char* pFncName )
+void* WinSalOpenGL::GetOGLFnc( const char* pFncName )
 {
 	if ( hImplOGLLib )
 		return (void*)GetProcAddress( hImplOGLLib, pFncName );
@@ -244,9 +240,11 @@ void* SalOpenGL::GetOGLFnc( const char* 
 
 typedef BOOL (WINAPI *MyFuncType)(HDC, HGLRC);
 
-void SalOpenGL::OGLEntry( SalGraphics* pGraphics )
+void WinSalOpenGL::OGLEntry( SalGraphics* pSGraphics )
 {
-	if ( pGraphics->maGraphicsData.mhDC != mhOGLLastDC )
+    WinSalGraphics* pGraphics = static_cast<WinSalGraphics*>(pSGraphics);
+
+	if ( pGraphics->mhDC != mhOGLLastDC )
 	{
 		PIXELFORMATDESCRIPTOR pfd =
 		{
@@ -254,7 +252,7 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 			1,
 			PFD_DRAW_TO_WINDOW | PFD_SUPPORT_GDI | PFD_SUPPORT_OPENGL,
 			PFD_TYPE_RGBA,
-			GetDeviceCaps( pGraphics->maGraphicsData.mhDC, BITSPIXEL ),
+			GetDeviceCaps( pGraphics->mhDC, BITSPIXEL ),
 			0, 0, 0, 0, 0, 0,
 			0,
 			0,
@@ -268,14 +266,14 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 			0, 0, 0
 		};
 
-		const int nIndex = ChoosePixelFormat( pGraphics->maGraphicsData.mhDC, &pfd );
-		if ( nIndex && SetPixelFormat( pGraphics->maGraphicsData.mhDC, nIndex, &pfd ) )
+		const int nIndex = ChoosePixelFormat( pGraphics->mhDC, &pfd );
+		if ( nIndex && SetPixelFormat( pGraphics->mhDC, nIndex, &pfd ) )
 		{
 			WNDCLASS	aWc;
 			HWND		hDummyWnd;
 
 			pImplOpenWGLFncDeleteContext( mhOGLContext );
-			mhOGLLastDC = pGraphics->maGraphicsData.mhDC;
+			mhOGLLastDC = pGraphics->mhDC;
 			mhOGLContext = pImplOpenWGLFncCreateContext( mhOGLLastDC );
 
 			SaveDC( mhOGLLastDC );
@@ -298,20 +296,32 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::OGLExit( SalGraphics* pGraphics )
+void WinSalOpenGL::OGLExit( SalGraphics* pGraphics )
+{
+}
+
+// ------------------------------------------------------------------------
+
+void WinSalOpenGL::StartScene( SalGraphics* pGraphics )
+{
+}
+
+// ------------------------------------------------------------------------
+
+void WinSalOpenGL::StopScene()
 {
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::ImplInitLib()
+BOOL WinSalOpenGL::ImplInitLib()
 {
 	return ((hImplOGLLib = LoadLibrary( OGL_LIBNAME )) != NULL);
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::ImplFreeLib()
+void WinSalOpenGL::ImplFreeLib()
 {
 	if ( hImplOGLLib )
 	{
@@ -323,7 +333,7 @@ void SalOpenGL::ImplFreeLib()
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::ImplInit()
+BOOL WinSalOpenGL::ImplInit()
 {
 	BOOL bRet = TRUE;
 
Index: vcl/win/source/gdi/salprn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salprn.cxx,v
retrieving revision 1.12.12.2
retrieving revision 1.17
diff -u -p -u -r1.12.12.2 -r1.17
--- vcl/win/source/gdi/salprn.cxx	7 Apr 2004 11:02:40 -0000	1.12.12.2
+++ vcl/win/source/gdi/salprn.cxx	18 May 2004 10:59:21 -0000	1.17
@@ -64,28 +64,26 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALPRN_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 #ifndef _SV_SALPTYPE_HXX
 #include <salptype.hxx>
 #endif
-#ifndef _SV_SALPRN_HXX
-#include <salprn.hxx>
+#ifndef _SV_SALPRN_H
+#include <salprn.h>
 #endif
 
 #ifndef _NEW_HXX
@@ -195,7 +193,7 @@ static ULONG ImplWinQueueStatusToSal( DW
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
+void WinSalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
 {
 // !!! UNICODE - NT Optimierung !!!
 	DWORD			i;
@@ -385,7 +383,7 @@ void SalInstance::GetPrinterQueueInfo( I
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
+void WinSalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
 {
 // !!! UNICODE - NT Optimierung !!!
 	DWORD				nBytes = 0;
@@ -422,7 +420,7 @@ void SalInstance::GetPrinterQueueState( 
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
+void WinSalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
 {
 	delete (String*)(pInfo->mpSysData);
 	delete pInfo;
@@ -431,7 +429,7 @@ void SalInstance::DeletePrinterQueueInfo
 // -----------------------------------------------------------------------
 
 // !!! UNICODE - NT Optimierung !!!
-XubString SalInstance::GetDefaultPrinter()
+XubString WinSalInstance::GetDefaultPrinter()
 {
 	// Default-Printer-String aus win.ini holen
 	char szBuffer[256];
@@ -451,7 +449,7 @@ XubString SalInstance::GetDefaultPrinter
 
 // =======================================================================
 
-static DWORD ImplDeviceCaps( SalInfoPrinter* pPrinter, WORD nCaps,
+static DWORD ImplDeviceCaps( WinSalInfoPrinter* pPrinter, WORD nCaps,
 							 LPTSTR pOutput, const ImplJobSetup* pSetupData )
 {
 	DEVMODE* pDevMode;
@@ -461,15 +459,14 @@ static DWORD ImplDeviceCaps( SalInfoPrin
 		pDevMode = SAL_DEVMODE( pSetupData );
 
 // !!! UNICODE - NT Optimierung !!!
-
-    return DeviceCapabilitiesA( ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(), 
-                              ImplSalGetWinAnsiString( pPrinter->maPrinterData.maPortName, TRUE ).GetBuffer(),
-                              nCaps, (LPSTR)pOutput, pDevMode );
+	return DeviceCapabilitiesA( ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(), 
+                                ImplSalGetWinAnsiString( pPrinter->maPortName, TRUE ).GetBuffer(),
+                                nCaps, (LPSTR)pOutput, pDevMode );
 }
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplTestSalJobSetup( SalInfoPrinter* pPrinter,
+static BOOL ImplTestSalJobSetup( WinSalInfoPrinter* pPrinter,
 								 ImplJobSetup* pSetupData, BOOL bDelete )
 {
 	if ( pSetupData && pSetupData->mpDriverData )
@@ -490,11 +487,11 @@ static BOOL ImplTestSalJobSetup( SalInfo
             // can avoid potential driver crashes as their jobsetups are often not compatible
             // #110800#, #111151#, #112381#, #i16580#, #i14173# and perhaps #112375#
             HANDLE hPrn;
-	        if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
+	        if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
 		        return FALSE;
 
 	        long nSysJobSize = DocumentPropertiesA( 0, hPrn,
-                                                    (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+                                                    (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
                                                     NULL, NULL, 0 );
             if( nSysJobSize < 0 )
             {
@@ -503,7 +500,7 @@ static BOOL ImplTestSalJobSetup( SalInfo
             }
             DEVMODE *pBuffer = (DEVMODE*) _alloca( nSysJobSize );
 	        DWORD nRet = DocumentPropertiesA( 0, hPrn,
-                                            (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+                                            (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
                                             pBuffer, NULL, DM_OUT_BUFFER );
             if( nRet < 0 )
             {
@@ -521,7 +518,7 @@ static BOOL ImplTestSalJobSetup( SalInfo
         }
 
 		if ( (pSetupData->mnSystem == JOBSETUP_SYSTEM_WINDOWS) &&
-             (pPrinter->maPrinterData.maDriverName == pSetupData->maDriver) &&
+             (pPrinter->maDriverName == pSetupData->maDriver) &&
 			 (pSetupData->mnDriverDataLen > sizeof( SalDriverData )) &&
              (dmSpecVersion == pDevMode->dmSpecVersion) &&
              (dmDriverVersion == pDevMode->dmDriverVersion) &&
@@ -540,12 +537,12 @@ static BOOL ImplTestSalJobSetup( SalInfo
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplUpdateSalJobSetup( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData,
-								   BOOL bIn, SalFrame* pVisibleDlgParent )
+static BOOL ImplUpdateSalJobSetup( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData,
+								   BOOL bIn, WinSalFrame* pVisibleDlgParent )
 {
 	HANDLE hPrn;
 // !!! UNICODE - NT Optimierung !!!
-	if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
+	if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
 		return FALSE;
 
 	LONG			nRet;
@@ -559,7 +556,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
 
 // !!! UNICODE - NT Optimierung !!!
 	nSysJobSize = DocumentPropertiesA( hWnd, hPrn,
-									   (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+									   (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
 									   NULL, NULL, 0 );
 	if ( nSysJobSize < 0 )
 	{
@@ -586,7 +583,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
 	// Testen, ob Dialog angezeigt werden soll
 	if ( pVisibleDlgParent )
 	{
-		hWnd = pVisibleDlgParent->maFrameData.mhWnd;
+		hWnd = pVisibleDlgParent->mhWnd;
 		nMode |= DM_IN_PROMPT;
 	}
 
@@ -597,7 +594,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
         nMutexCount = ImplSalReleaseYieldMutex();
 
 	nRet = DocumentPropertiesA( hWnd, hPrn,
-								(LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+								(LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
 								pOutDevBuffer, pInDevBuffer, nMode );
     if ( pVisibleDlgParent )
         ImplSalAcquireYieldMutex( nMutexCount );
@@ -637,7 +634,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
 
 // -----------------------------------------------------------------------
 
-static void ImplDevModeToJobSetup( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
+static void ImplDevModeToJobSetup( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
 {
 	if ( !pSetupData || !pSetupData->mpDriverData )
 		return;
@@ -730,7 +727,7 @@ static BOOL ImplPaperSizeEqual( short nP
 
 // -----------------------------------------------------------------------
 
-static void ImplJobSetupToDevMode( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
+static void ImplJobSetupToDevMode( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
 {
 	if ( !pSetupData || !pSetupData->mpDriverData )
 		return;
@@ -858,8 +855,8 @@ static void ImplJobSetupToDevMode( SalIn
 				{
 					pDevMode->dmFields	   |= DM_PAPERLENGTH | DM_PAPERWIDTH;
 					pDevMode->dmPaperSize	= DMPAPER_USER;
-					pDevMode->dmPaperWidth	= (short)pSetupData->mnPaperWidth/10;
-					pDevMode->dmPaperLength = (short)pSetupData->mnPaperHeight/10;
+					pDevMode->dmPaperWidth	= (short)(pSetupData->mnPaperWidth/10);
+					pDevMode->dmPaperLength = (short)(pSetupData->mnPaperHeight/10);
 				}
 
 				if ( pPapers )
@@ -875,7 +872,7 @@ static void ImplJobSetupToDevMode( SalIn
 
 // -----------------------------------------------------------------------
 
-static HDC ImplCreateSalPrnIC( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
+static HDC ImplCreateSalPrnIC( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
 {
 	LPDEVMODE pDevMode;
 	if ( pSetupData && pSetupData->mpDriverData )
@@ -884,14 +881,14 @@ static HDC ImplCreateSalPrnIC( SalInfoPr
 		pDevMode = NULL;
 // !!! UNICODE - NT Optimierung !!!
 	// #95347 some buggy drivers (eg, OKI) write to those buffers in CreateIC, although declared const - so provide some space
-	ByteString aDriver ( ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDriverName, TRUE ) );
-	ByteString aDevice ( ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ) );
+	ByteString aDriver ( ImplSalGetWinAnsiString( pPrinter->maDriverName, TRUE ) );
+	ByteString aDevice ( ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ) );
 	int n = aDriver.Len() > aDevice.Len() ? aDriver.Len() : aDevice.Len();
 	n += 2048;
 	char *lpszDriverName = new char[n];
 	char *lpszDeviceName = new char[n];
-	strcpy( lpszDriverName, aDriver.GetBuffer() );
-	strcpy( lpszDeviceName, aDevice.GetBuffer() );
+	strncpy( lpszDriverName, aDriver.GetBuffer(), n );
+	strncpy( lpszDeviceName, aDevice.GetBuffer(), n );
 	HDC hDC = CreateICA( lpszDriverName,
 						 lpszDeviceName,
 						 0,
@@ -903,50 +900,51 @@ static HDC ImplCreateSalPrnIC( SalInfoPr
 
 // -----------------------------------------------------------------------
 
-static SalGraphics* ImplCreateSalPrnGraphics( HDC hDC )
+static WinSalGraphics* ImplCreateSalPrnGraphics( HDC hDC )
 {
-	SalGraphics* pGraphics = new SalGraphics;
-	pGraphics->maGraphicsData.mhDC		= hDC;
-	pGraphics->maGraphicsData.mhWnd 	= 0;
-	pGraphics->maGraphicsData.mbPrinter = TRUE;
-	pGraphics->maGraphicsData.mbVirDev	= FALSE;
-	pGraphics->maGraphicsData.mbWindow	= FALSE;
-	pGraphics->maGraphicsData.mbScreen	= FALSE;
-	ImplSalInitGraphics( &(pGraphics->maGraphicsData) );
+	WinSalGraphics* pGraphics = new WinSalGraphics;
+    pGraphics->SetLayout( 0 );
+	pGraphics->mhDC		= hDC;
+	pGraphics->mhWnd 	= 0;
+	pGraphics->mbPrinter = TRUE;
+	pGraphics->mbVirDev	= FALSE;
+	pGraphics->mbWindow	= FALSE;
+	pGraphics->mbScreen	= FALSE;
+	ImplSalInitGraphics( pGraphics );
 	return pGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplUpdateSalPrnIC( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
+static BOOL ImplUpdateSalPrnIC( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
 {
 	HDC hNewDC = ImplCreateSalPrnIC( pPrinter, pSetupData );
 	if ( !hNewDC )
 		return FALSE;
 
-	if ( pPrinter->maPrinterData.mpGraphics )
+	if ( pPrinter->mpGraphics )
 	{
-		ImplSalDeInitGraphics( &(pPrinter->maPrinterData.mpGraphics->maGraphicsData) );
-		DeleteDC( pPrinter->maPrinterData.mpGraphics->maGraphicsData.mhDC );
-		delete pPrinter->maPrinterData.mpGraphics;
+		ImplSalDeInitGraphics( pPrinter->mpGraphics );
+		DeleteDC( pPrinter->mpGraphics->mhDC );
+		delete pPrinter->mpGraphics;
 	}
 
-	SalGraphics* pGraphics = ImplCreateSalPrnGraphics( hNewDC );
-	pPrinter->maPrinterData.mhDC		= hNewDC;
-	pPrinter->maPrinterData.mpGraphics	= pGraphics;
+	WinSalGraphics* pGraphics = ImplCreateSalPrnGraphics( hNewDC );
+	pPrinter->mhDC		= hNewDC;
+	pPrinter->mpGraphics	= pGraphics;
 
 	return TRUE;
 }
 
 // =======================================================================
 
-SalInfoPrinter* SalInstance::CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
-												ImplJobSetup* pSetupData )
+SalInfoPrinter* WinSalInstance::CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
+                                                   ImplJobSetup* pSetupData )
 {
-	SalInfoPrinter* pPrinter = new SalInfoPrinter;
-	pPrinter->maPrinterData.maDriverName	= pQueueInfo->maDriver;
-	pPrinter->maPrinterData.maDeviceName	= pQueueInfo->maPrinterName;
-	pPrinter->maPrinterData.maPortName		= *(String*)(pQueueInfo->mpSysData);
+	WinSalInfoPrinter* pPrinter = new WinSalInfoPrinter;
+	pPrinter->maDriverName	= pQueueInfo->maDriver;
+	pPrinter->maDeviceName	= pQueueInfo->maPrinterName;
+	pPrinter->maPortName		= *(String*)(pQueueInfo->mpSysData);
 
 	// Testen, ob Setupdaten zum Drucker gehoeren (erst aufrufen, nachdem
 	// die Member gesetzt sind, da diese in dieser Routine abgefragt werden)
@@ -959,9 +957,9 @@ SalInfoPrinter* SalInstance::CreateInfoP
 		return NULL;
 	}
 
-	SalGraphics* pGraphics = ImplCreateSalPrnGraphics( hDC );
-	pPrinter->maPrinterData.mhDC		= hDC;
-	pPrinter->maPrinterData.mpGraphics	= pGraphics;
+	WinSalGraphics* pGraphics = ImplCreateSalPrnGraphics( hDC );
+	pPrinter->mhDC		= hDC;
+	pPrinter->mpGraphics	= pGraphics;
 	if ( !pSetupData->mpDriverData )
 		ImplUpdateSalJobSetup( pPrinter, pSetupData, FALSE, NULL );
 	ImplDevModeToJobSetup( pPrinter, pSetupData, SAL_JOBSET_ALL );
@@ -972,36 +970,36 @@ SalInfoPrinter* SalInstance::CreateInfoP
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
+void WinSalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
 {
 	delete pPrinter;
 }
 
 // =======================================================================
 
-SalInfoPrinter::SalInfoPrinter()
+WinSalInfoPrinter::WinSalInfoPrinter()
 {
-	maPrinterData.mhDC			= 0;
-	maPrinterData.mpGraphics	= NULL;
-	maPrinterData.mbGraphics	= FALSE;
+	mhDC			= 0;
+	mpGraphics	= NULL;
+	mbGraphics	= FALSE;
     m_bPapersInit               = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-SalInfoPrinter::~SalInfoPrinter()
+WinSalInfoPrinter::~WinSalInfoPrinter()
 {
-	if ( maPrinterData.mpGraphics )
+	if ( mpGraphics )
 	{
-		ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-		DeleteDC( maPrinterData.mpGraphics->maGraphicsData.mhDC );
-		delete maPrinterData.mpGraphics;
+		ImplSalDeInitGraphics( mpGraphics );
+		DeleteDC( mpGraphics->mhDC );
+		delete mpGraphics;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
+void WinSalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
 {
     m_aPaperFormats.clear();
 
@@ -1035,7 +1033,7 @@ void SalInfoPrinter::InitPaperFormats( c
 
 // -----------------------------------------------------------------------
 
-int SalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
+int WinSalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
 {
     int nRet = ImplDeviceCaps( this, DC_ORIENTATION, NULL, pSetupData );
 
@@ -1047,29 +1045,29 @@ int SalInfoPrinter::GetLandscapeAngle( c
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalInfoPrinter::GetGraphics()
+SalGraphics* WinSalInfoPrinter::GetGraphics()
 {
-	if ( maPrinterData.mbGraphics )
+	if ( mbGraphics )
 		return NULL;
 
-	if ( maPrinterData.mpGraphics )
-		maPrinterData.mbGraphics = TRUE;
+	if ( mpGraphics )
+		mbGraphics = TRUE;
 
-	return maPrinterData.mpGraphics;
+	return mpGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::ReleaseGraphics( SalGraphics* )
+void WinSalInfoPrinter::ReleaseGraphics( SalGraphics* )
 {
-	maPrinterData.mbGraphics = FALSE;
+	mbGraphics = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pSetupData )
+BOOL WinSalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pSetupData )
 {
-	if ( ImplUpdateSalJobSetup( this, pSetupData, TRUE, pFrame ) )
+	if ( ImplUpdateSalJobSetup( this, pSetupData, TRUE, static_cast<WinSalFrame*>(pFrame) ) )
 	{
 		ImplDevModeToJobSetup( this, pSetupData, SAL_JOBSET_ALL );
 		return ImplUpdateSalPrnIC( this, pSetupData );
@@ -1080,7 +1078,7 @@ BOOL SalInfoPrinter::Setup( SalFrame* pF
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::SetPrinterData( ImplJobSetup* pSetupData )
+BOOL WinSalInfoPrinter::SetPrinterData( ImplJobSetup* pSetupData )
 {
 	if ( !ImplTestSalJobSetup( this, pSetupData, FALSE ) )
 		return FALSE;
@@ -1089,7 +1087,7 @@ BOOL SalInfoPrinter::SetPrinterData( Imp
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::SetData( ULONG nFlags, ImplJobSetup* pSetupData )
+BOOL WinSalInfoPrinter::SetData( ULONG nFlags, ImplJobSetup* pSetupData )
 {
 	ImplJobSetupToDevMode( this, pSetupData, nFlags );
 	if ( ImplUpdateSalJobSetup( this, pSetupData, TRUE, NULL ) )
@@ -1103,7 +1101,7 @@ BOOL SalInfoPrinter::SetData( ULONG nFla
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pSetupData )
+ULONG WinSalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pSetupData )
 {
 	DWORD nRet = ImplDeviceCaps( this, DC_BINS, NULL, pSetupData );
 	if ( nRet && (nRet != ((ULONG)-1)) )
@@ -1114,7 +1112,7 @@ ULONG SalInfoPrinter::GetPaperBinCount( 
 
 // -----------------------------------------------------------------------
 
-XubString SalInfoPrinter::GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin )
+XubString WinSalInfoPrinter::GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin )
 {
 // !!! UNICODE - NT Optimierung !!!
 	XubString aPaperBinName;
@@ -1134,7 +1132,7 @@ XubString SalInfoPrinter::GetPaperBinNam
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType )
+ULONG WinSalInfoPrinter::GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType )
 {
 	DWORD nRet;
 
@@ -1185,12 +1183,12 @@ ULONG SalInfoPrinter::GetCapabilities( c
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::GetPageInfo( const ImplJobSetup*,
+void WinSalInfoPrinter::GetPageInfo( const ImplJobSetup*,
 								  long& rOutWidth, long& rOutHeight,
 								  long& rPageOffX, long& rPageOffY,
 								  long& rPageWidth, long& rPageHeight )
 {
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 
 	rOutWidth	= GetDeviceCaps( hDC, HORZRES );
 	rOutHeight	= GetDeviceCaps( hDC, VERTRES );
@@ -1203,16 +1201,16 @@ void SalInfoPrinter::GetPageInfo( const 
 
 // =======================================================================
 
-SalPrinter* SalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
+SalPrinter* WinSalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
 {
-	SalPrinter* pPrinter = new SalPrinter;
-	pPrinter->maPrinterData.mpInfoPrinter = pInfoPrinter;
+	WinSalPrinter* pPrinter = new WinSalPrinter;
+	pPrinter->mpInfoPrinter = static_cast<WinSalInfoPrinter*>(pInfoPrinter);
 	return pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyPrinter( SalPrinter* pPrinter )
+void WinSalInstance::DestroyPrinter( SalPrinter* pPrinter )
 {
 	delete pPrinter;
 }
@@ -1222,7 +1220,7 @@ void SalInstance::DestroyPrinter( SalPri
 WIN_BOOL CALLBACK SalPrintAbortProc( HDC hPrnDC, int /* nError */ )
 {
 	SalData*	pSalData = GetSalData();
-	SalPrinter* pPrinter;
+	WinSalPrinter* pPrinter;
 	BOOL		bWhile = TRUE;
 	int 		i = 0;
 
@@ -1244,13 +1242,13 @@ WIN_BOOL CALLBACK SalPrintAbortProc( HDC
 		pPrinter = pSalData->mpFirstPrinter;
 		while ( pPrinter )
 		{
-			if( pPrinter->maPrinterData.mhDC == hPrnDC )
+			if( pPrinter->mhDC == hPrnDC )
 				break;
 
-			pPrinter = pPrinter->maPrinterData.mpNextPrinter;
+			pPrinter = pPrinter->mpNextPrinter;
 		}
 
-		if ( !pPrinter || pPrinter->maPrinterData.mbAbort )
+		if ( !pPrinter || pPrinter->mbAbort )
 			return FALSE;
 	}
 	while ( bWhile );
@@ -1288,35 +1286,35 @@ static LPDEVMODE ImplSalSetCopies( LPDEV
 
 // -----------------------------------------------------------------------
 
-SalPrinter::SalPrinter()
+WinSalPrinter::WinSalPrinter()
 {
 	SalData* pSalData = GetSalData();
 
-	maPrinterData.mhDC			= 0;
-	maPrinterData.mpGraphics	= NULL;
-	maPrinterData.mbAbort		= FALSE;
-	maPrinterData.mnCopies		= 0;
-	maPrinterData.mbCollate 	= FALSE;
+	mhDC			= 0;
+	mpGraphics	= NULL;
+	mbAbort		= FALSE;
+	mnCopies		= 0;
+	mbCollate 	= FALSE;
 
 	// insert frame in framelist
-	maPrinterData.mpNextPrinter = pSalData->mpFirstPrinter;
+	mpNextPrinter = pSalData->mpFirstPrinter;
 	pSalData->mpFirstPrinter = this;
 }
 
 // -----------------------------------------------------------------------
 
-SalPrinter::~SalPrinter()
+WinSalPrinter::~WinSalPrinter()
 {
 	SalData* pSalData = GetSalData();
 
 	// DC freigeben, wenn er noch durch ein AbortJob existiert
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( hDC )
 	{
-		if ( maPrinterData.mpGraphics )
+		if ( mpGraphics )
 		{
-			ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-			delete maPrinterData.mpGraphics;
+			ImplSalDeInitGraphics( mpGraphics );
+			delete mpGraphics;
 		}
 
 		DeleteDC( hDC );
@@ -1324,30 +1322,30 @@ SalPrinter::~SalPrinter()
 
 	// remove printer from printerlist
 	if ( this == pSalData->mpFirstPrinter )
-		pSalData->mpFirstPrinter = maPrinterData.mpNextPrinter;
+		pSalData->mpFirstPrinter = mpNextPrinter;
 	else
 	{
-		SalPrinter* pTempPrinter = pSalData->mpFirstPrinter;
+		WinSalPrinter* pTempPrinter = pSalData->mpFirstPrinter;
 
-		while( pTempPrinter->maPrinterData.mpNextPrinter != this )
-			pTempPrinter = pTempPrinter->maPrinterData.mpNextPrinter;
+		while( pTempPrinter->mpNextPrinter != this )
+			pTempPrinter = pTempPrinter->mpNextPrinter;
 
-		pTempPrinter->maPrinterData.mpNextPrinter = maPrinterData.mpNextPrinter;
+		pTempPrinter->mpNextPrinter = mpNextPrinter;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::StartJob( const XubString* pFileName,
+BOOL WinSalPrinter::StartJob( const XubString* pFileName,
 						   const XubString& rJobName,
 						   const XubString&,
 						   ULONG nCopies, BOOL bCollate,
 						   ImplJobSetup* pSetupData )
 {
-	maPrinterData.mnError		= 0;
-	maPrinterData.mbAbort		= FALSE;
-	maPrinterData.mnCopies		= nCopies;
-	maPrinterData.mbCollate 	= bCollate;
+	mnError		= 0;
+	mbAbort		= FALSE;
+	mnCopies		= nCopies;
+	mbCollate 	= bCollate;
 
 	LPDEVMODE	pOrgDevMode = NULL;
 	LPDEVMODE	pDevMode;
@@ -1362,15 +1360,15 @@ BOOL SalPrinter::StartJob( const XubStri
 
 // !!! UNICODE - NT Optimierung !!!
 	// #95347 some buggy drivers (eg, OKI) write to those buffers in CreateDC, although declared const - so provide some space
-	ByteString aDriver ( ImplSalGetWinAnsiString( maPrinterData.mpInfoPrinter->maPrinterData.maDriverName, TRUE ) );
-	ByteString aDevice ( ImplSalGetWinAnsiString( maPrinterData.mpInfoPrinter->maPrinterData.maDeviceName, TRUE ) );
-	ByteString aPort   ( ImplSalGetWinAnsiString( maPrinterData.mpInfoPrinter->maPrinterData.maPortName, TRUE ) );
+	ByteString aDriver ( ImplSalGetWinAnsiString( mpInfoPrinter->maDriverName, TRUE ) );
+	ByteString aDevice ( ImplSalGetWinAnsiString( mpInfoPrinter->maDeviceName, TRUE ) );
+	ByteString aPort   ( ImplSalGetWinAnsiString( mpInfoPrinter->maPortName, TRUE ) );
 	int n = aDriver.Len() > aDevice.Len() ? aDriver.Len() : aDevice.Len();
 	n += 2048;
 	char *lpszDriverName = new char[n];
 	char *lpszDeviceName = new char[n];
-	strcpy( lpszDriverName, aDriver.GetBuffer() );
-	strcpy( lpszDeviceName, aDevice.GetBuffer() );
+	strncpy( lpszDriverName, aDriver.GetBuffer(), n );
+	strncpy( lpszDeviceName, aDevice.GetBuffer(), n );
 	HDC hDC = CreateDCA( lpszDriverName,
 						 lpszDeviceName,
                          NULL,
@@ -1384,18 +1382,18 @@ BOOL SalPrinter::StartJob( const XubStri
 
 	if ( !hDC )
 	{
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 
 	if ( SetAbortProc( hDC, SalPrintAbortProc ) <= 0 )
 	{
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 
-	maPrinterData.mnError	= 0;
-	maPrinterData.mbAbort	= FALSE;
+	mnError	= 0;
+	mbAbort	= FALSE;
 
 // !!! UNICODE - NT Optimierung !!!
 	// Both strings must be exist, if StartJob() is called
@@ -1440,10 +1438,10 @@ BOOL SalPrinter::StartJob( const XubStri
 			bWhile = FALSE;
 	}
 	while ( bWhile );
-	ImplPostMessage( GetSalData()->mpFirstInstance->maInstData.mhComWnd, SAL_MSG_DUMMY, 0, 0 );
+	ImplPostMessage( GetSalData()->mpFirstInstance->mhComWnd, SAL_MSG_DUMMY, 0, 0 );
 
     // make sure mhDC is set before the printer driver may call our abortproc
-	maPrinterData.mhDC = hDC;
+	mhDC = hDC;
 
     // bring up a file choser if printing to file port but no file name given
     OString aOutFileName;
@@ -1475,7 +1473,7 @@ BOOL SalPrinter::StartJob( const XubStri
                 }
                 else
                 {
-                    maPrinterData.mnError = SAL_PRINTER_ERROR_ABORT;
+                    mnError = SAL_PRINTER_ERROR_ABORT;
                     return FALSE;
                 }
             }
@@ -1488,9 +1486,9 @@ BOOL SalPrinter::StartJob( const XubStri
 	{
         long nError = GetLastError();
         if ( (nRet == SP_USERABORT) || (nRet == SP_APPABORT) || (nError == ERROR_PRINT_CANCELLED) || (nError == ERROR_CANCELLED) )
-			maPrinterData.mnError = SAL_PRINTER_ERROR_ABORT;
+			mnError = SAL_PRINTER_ERROR_ABORT;
 		else
-			maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+			mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 
@@ -1499,17 +1497,17 @@ BOOL SalPrinter::StartJob( const XubStri
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndJob()
+BOOL WinSalPrinter::EndJob()
 {
 	DWORD err = 0;
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( hDC )
 	{
-		if ( maPrinterData.mpGraphics )
+		if ( mpGraphics )
 		{
-			ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-			delete maPrinterData.mpGraphics;
-			maPrinterData.mpGraphics = NULL;
+			ImplSalDeInitGraphics( mpGraphics );
+			delete mpGraphics;
+			mpGraphics = NULL;
 		}
 
 		if( ::EndDoc( hDC ) <= 0 )
@@ -1522,16 +1520,16 @@ BOOL SalPrinter::EndJob()
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::AbortJob()
+BOOL WinSalPrinter::AbortJob()
 {
-	maPrinterData.mbAbort = TRUE;
+	mbAbort = TRUE;
 
 	// Abort asyncron ausloesen
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( hDC )
 	{
 		SalData* pSalData = GetSalData();
-		ImplPostMessage( pSalData->mpFirstInstance->maInstData.mhComWnd,
+		ImplPostMessage( pSalData->mpFirstInstance->mhComWnd,
 						 SAL_MSG_PRINTABORTJOB, (WPARAM)hDC, 0 );
 	}
 
@@ -1543,28 +1541,28 @@ BOOL SalPrinter::AbortJob()
 void ImplSalPrinterAbortJobAsync( HDC hPrnDC )
 {
 	SalData*	pSalData = GetSalData();
-	SalPrinter* pPrinter = pSalData->mpFirstPrinter;
+	WinSalPrinter* pPrinter = pSalData->mpFirstPrinter;
 
 	// Feststellen, ob Printer noch existiert
 	while ( pPrinter )
 	{
-		if ( pPrinter->maPrinterData.mhDC == hPrnDC )
+		if ( pPrinter->mhDC == hPrnDC )
 			break;
 
-		pPrinter = pPrinter->maPrinterData.mpNextPrinter;
+		pPrinter = pPrinter->mpNextPrinter;
 	}
 
 	// Wenn Printer noch existiert, dann den Job abbrechen
 	if ( pPrinter )
 	{
-		HDC hDC = pPrinter->maPrinterData.mhDC;
+		HDC hDC = pPrinter->mhDC;
 		if ( hDC )
 		{
-			if ( pPrinter->maPrinterData.mpGraphics )
+			if ( pPrinter->mpGraphics )
 			{
-				ImplSalDeInitGraphics( &(pPrinter->maPrinterData.mpGraphics->maGraphicsData) );
-				delete pPrinter->maPrinterData.mpGraphics;
-				pPrinter->maPrinterData.mpGraphics = NULL;
+				ImplSalDeInitGraphics( pPrinter->mpGraphics );
+				delete pPrinter->mpGraphics;
+				pPrinter->mpGraphics = NULL;
 			}
 
 			::AbortDoc( hDC );
@@ -1575,15 +1573,15 @@ void ImplSalPrinterAbortJobAsync( HDC hP
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalPrinter::StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData )
+SalGraphics* WinSalPrinter::StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData )
 {
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( pSetupData && pSetupData->mpDriverData && bNewJobData )
 	{
 		LPDEVMODE	pOrgDevMode;
 		LPDEVMODE	pDevMode;
 		pOrgDevMode = SAL_DEVMODE( pSetupData );
-		pDevMode = ImplSalSetCopies( pOrgDevMode, maPrinterData.mnCopies, maPrinterData.mbCollate );
+		pDevMode = ImplSalSetCopies( pOrgDevMode, mnCopies, mbCollate );
 		ResetDC( hDC, pDevMode );
 		if ( pDevMode != pOrgDevMode )
 			rtl_freeMemory( pDevMode );
@@ -1592,7 +1590,7 @@ SalGraphics* SalPrinter::StartPage( Impl
 	if ( nRet <= 0 )
 	{
 		DWORD err = GetLastError();
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return NULL;
 	}
 
@@ -1603,28 +1601,28 @@ SalGraphics* SalPrinter::StartPage( Impl
 	SelectPen( hDC, hTempPen );
 	SelectBrush( hDC, hTempBrush );
 
-	SalGraphics* pGraphics = new SalGraphics;
-	pGraphics->maGraphicsData.mhDC		= hDC;
-	pGraphics->maGraphicsData.mhWnd 	= 0;
-	pGraphics->maGraphicsData.mbPrinter = TRUE;
-	pGraphics->maGraphicsData.mbVirDev	= FALSE;
-	pGraphics->maGraphicsData.mbWindow	= FALSE;
-	pGraphics->maGraphicsData.mbScreen	= FALSE;
-	ImplSalInitGraphics( &(pGraphics->maGraphicsData) );
-	maPrinterData.mpGraphics = pGraphics;
+	WinSalGraphics* pGraphics = new WinSalGraphics;
+	pGraphics->mhDC		= hDC;
+	pGraphics->mhWnd 	= 0;
+	pGraphics->mbPrinter = TRUE;
+	pGraphics->mbVirDev	= FALSE;
+	pGraphics->mbWindow	= FALSE;
+	pGraphics->mbScreen	= FALSE;
+	ImplSalInitGraphics( pGraphics );
+	mpGraphics = pGraphics;
 	return pGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndPage()
+BOOL WinSalPrinter::EndPage()
 {
-	HDC hDC = maPrinterData.mhDC;
-	if ( hDC && maPrinterData.mpGraphics )
+	HDC hDC = mhDC;
+	if ( hDC && mpGraphics )
 	{
-		ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-		delete maPrinterData.mpGraphics;
-		maPrinterData.mpGraphics = NULL;
+		ImplSalDeInitGraphics( mpGraphics );
+		delete mpGraphics;
+		mpGraphics = NULL;
 	}
 	int nRet = ::EndPage( hDC );
 	if ( nRet > 0 )
@@ -1632,14 +1630,14 @@ BOOL SalPrinter::EndPage()
 	else
 	{
 		DWORD err = GetLastError();
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalPrinter::GetErrorCode()
+ULONG WinSalPrinter::GetErrorCode()
 {
-	return maPrinterData.mnError;
+	return mnError;
 }
Index: vcl/win/source/gdi/salvd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salvd.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/gdi/salvd.cxx	27 Mar 2003 17:59:23 -0000	1.2
+++ vcl/win/source/gdi/salvd.cxx	6 Jan 2004 14:56:52 -0000	1.4
@@ -63,22 +63,20 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALVD_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 
 // =======================================================================
@@ -98,42 +96,44 @@ static HBITMAP ImplCreateVirDevBitmap( H
 
 // =======================================================================
 
-SalVirtualDevice* SalInstance::CreateVirtualDevice( SalGraphics* pGraphics,
-													long nDX, long nDY,
-													USHORT nBitCount )
+SalVirtualDevice* WinSalInstance::CreateVirtualDevice( SalGraphics* pSGraphics,
+                                                       long nDX, long nDY,
+                                                       USHORT nBitCount )
 {
-	HDC 	hDC 	= CreateCompatibleDC( pGraphics->maGraphicsData.mhDC );
-	HBITMAP hBmp	= ImplCreateVirDevBitmap( pGraphics->maGraphicsData.mhDC,
+    WinSalGraphics* pGraphics = static_cast<WinSalGraphics*>(pSGraphics);
+
+	HDC 	hDC 	= CreateCompatibleDC( pGraphics->mhDC );
+	HBITMAP hBmp	= ImplCreateVirDevBitmap( pGraphics->mhDC,
 											  nDX, nDY, nBitCount );
 
 	if ( hDC && hBmp )
 	{
-		SalVirtualDevice*	pVDev = new SalVirtualDevice;
-		SalData*			pSalData = GetSalData();
-		SalGraphics*		pVirGraphics = new SalGraphicsLayout;
+		WinSalVirtualDevice*	pVDev = new WinSalVirtualDevice;
+		SalData*                pSalData = GetSalData();
+		WinSalGraphics*         pVirGraphics = new WinSalGraphics;
         pVirGraphics->SetLayout( 0 );   // by default no! mirroring for VirtualDevices, can be enabled with EnableRTL()
-		pVirGraphics->maGraphicsData.mhDC	   = hDC;
-		pVirGraphics->maGraphicsData.mhWnd	   = 0;
-		pVirGraphics->maGraphicsData.mbPrinter = FALSE;
-		pVirGraphics->maGraphicsData.mbVirDev  = TRUE;
-		pVirGraphics->maGraphicsData.mbWindow  = FALSE;
-		pVirGraphics->maGraphicsData.mbScreen  = pGraphics->maGraphicsData.mbScreen;
-		if ( pSalData->mhDitherPal && pVirGraphics->maGraphicsData.mbScreen )
+		pVirGraphics->mhDC	   = hDC;
+		pVirGraphics->mhWnd	   = 0;
+		pVirGraphics->mbPrinter = FALSE;
+		pVirGraphics->mbVirDev  = TRUE;
+		pVirGraphics->mbWindow  = FALSE;
+		pVirGraphics->mbScreen  = pGraphics->mbScreen;
+		if ( pSalData->mhDitherPal && pVirGraphics->mbScreen )
 		{
-			pVirGraphics->maGraphicsData.mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
+			pVirGraphics->mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
 			RealizePalette( hDC );
 		}
-		ImplSalInitGraphics( &(pVirGraphics->maGraphicsData) );
+		ImplSalInitGraphics( pVirGraphics );
 
-		pVDev->maVirDevData.mhDC		= hDC;
-		pVDev->maVirDevData.mhBmp		= hBmp;
-		pVDev->maVirDevData.mhDefBmp	= SelectBitmap( hDC, hBmp );
-		pVDev->maVirDevData.mpGraphics	= pVirGraphics;
-		pVDev->maVirDevData.mnBitCount	= nBitCount;
-		pVDev->maVirDevData.mbGraphics	= FALSE;
+		pVDev->mhDC		= hDC;
+		pVDev->mhBmp		= hBmp;
+		pVDev->mhDefBmp	= SelectBitmap( hDC, hBmp );
+		pVDev->mpGraphics	= pVirGraphics;
+		pVDev->mnBitCount	= nBitCount;
+		pVDev->mbGraphics	= FALSE;
 
 		// insert VirDev in VirDevList
-		pVDev->maVirDevData.mpNext = pSalData->mpFirstVD;
+		pVDev->mpNext = pSalData->mpFirstVD;
 		pSalData->mpFirstVD = pVDev;
 
 		return pVDev;
@@ -150,76 +150,76 @@ SalVirtualDevice* SalInstance::CreateVir
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
+void WinSalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
 {
 	delete pDevice;
 }
 
 // =======================================================================
 
-SalVirtualDevice::SalVirtualDevice()
+WinSalVirtualDevice::WinSalVirtualDevice()
 {
 }
 
 // -----------------------------------------------------------------------
 
-SalVirtualDevice::~SalVirtualDevice()
+WinSalVirtualDevice::~WinSalVirtualDevice()
 {
 	SalData* pSalData = GetSalData();
 
 	// destroy saved DC
-	if ( maVirDevData.mpGraphics->maGraphicsData.mhDefPal )
-		SelectPalette( maVirDevData.mpGraphics->maGraphicsData.mhDC, maVirDevData.mpGraphics->maGraphicsData.mhDefPal, TRUE );
-	ImplSalDeInitGraphics( &(maVirDevData.mpGraphics->maGraphicsData) );
-	SelectBitmap( maVirDevData.mpGraphics->maGraphicsData.mhDC, maVirDevData.mhDefBmp );
-	DeleteDC( maVirDevData.mpGraphics->maGraphicsData.mhDC );
-	DeleteBitmap( maVirDevData.mhBmp );
-	delete maVirDevData.mpGraphics;
+	if ( mpGraphics->mhDefPal )
+		SelectPalette( mpGraphics->mhDC, mpGraphics->mhDefPal, TRUE );
+	ImplSalDeInitGraphics( mpGraphics );
+	SelectBitmap( mpGraphics->mhDC, mhDefBmp );
+	DeleteDC( mpGraphics->mhDC );
+	DeleteBitmap( mhBmp );
+	delete mpGraphics;
 
 	// remove VirDev from VirDevList
 	if ( this == pSalData->mpFirstVD )
-		pSalData->mpFirstVD = maVirDevData.mpNext;
+		pSalData->mpFirstVD = mpNext;
 	else
 	{
-		SalVirtualDevice* pTempVD = pSalData->mpFirstVD;
-		while ( pTempVD->maVirDevData.mpNext != this )
-			pTempVD = pTempVD->maVirDevData.mpNext;
+		WinSalVirtualDevice* pTempVD = pSalData->mpFirstVD;
+		while ( pTempVD->mpNext != this )
+			pTempVD = pTempVD->mpNext;
 
-		pTempVD->maVirDevData.mpNext = maVirDevData.mpNext;
+		pTempVD->mpNext = mpNext;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalVirtualDevice::GetGraphics()
+SalGraphics* WinSalVirtualDevice::GetGraphics()
 {
-	if ( maVirDevData.mbGraphics )
+	if ( mbGraphics )
 		return NULL;
 
-	if ( maVirDevData.mpGraphics )
-		maVirDevData.mbGraphics = TRUE;
+	if ( mpGraphics )
+		mbGraphics = TRUE;
 
-	return maVirDevData.mpGraphics;
+	return mpGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-void SalVirtualDevice::ReleaseGraphics( SalGraphics* )
+void WinSalVirtualDevice::ReleaseGraphics( SalGraphics* )
 {
-	maVirDevData.mbGraphics = FALSE;
+	mbGraphics = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalVirtualDevice::SetSize( long nDX, long nDY )
+BOOL WinSalVirtualDevice::SetSize( long nDX, long nDY )
 {
-	HBITMAP hNewBmp = ImplCreateVirDevBitmap( maVirDevData.mhDC, nDX, nDY,
-											  maVirDevData.mnBitCount );
+	HBITMAP hNewBmp = ImplCreateVirDevBitmap( mhDC, nDX, nDY,
+											  mnBitCount );
 	if ( hNewBmp )
 	{
-		SelectBitmap( maVirDevData.mhDC, hNewBmp );
-		DeleteBitmap( maVirDevData.mhBmp );
-		maVirDevData.mhBmp = hNewBmp;
+		SelectBitmap( mhDC, hNewBmp );
+		DeleteBitmap( mhBmp );
+		mhBmp = hNewBmp;
 		return TRUE;
 	}
 	else
Index: vcl/win/source/gdi/winlayout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/winlayout.cxx,v
retrieving revision 1.71.12.3
retrieving revision 1.80
diff -u -p -u -r1.71.12.3 -r1.80
--- vcl/win/source/gdi/winlayout.cxx	15 Jan 2004 12:55:41 -0000	1.71.12.3
+++ vcl/win/source/gdi/winlayout.cxx	18 Jun 2004 15:06:52 -0000	1.80
@@ -63,8 +63,8 @@
 #include <tools/svwin.h>
 #endif
 
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif // _SV_SALGDI_HXX
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
@@ -152,6 +152,7 @@ private:
     int*            mpCharWidths;   // map rel char pos to char width
     int*            mpChars2Glyphs; // map rel char pos to abs glyph pos
     int*            mpGlyphs2Chars; // map abs glyph pos to abs char pos
+    bool*           mpGlyphRTLFlags;// BiDi status for glyphs: true=>RTL
     mutable long    mnWidth;
     bool            mbDisableGlyphs;
 
@@ -211,6 +212,7 @@ SimpleWinLayout::SimpleWinLayout( HDC hD
     mpCharWidths( NULL ),
     mpChars2Glyphs( NULL ),
     mpGlyphs2Chars( NULL ),
+    mpGlyphRTLFlags( NULL ),
     mnWidth( 0 ),
     mnNotdefWidth( -1 ),
     mnCharSet( nCharSet ),
@@ -224,6 +226,7 @@ SimpleWinLayout::SimpleWinLayout( HDC hD
 
 SimpleWinLayout::~SimpleWinLayout()
 {
+    delete[] mpGlyphRTLFlags;
     delete[] mpGlyphs2Chars;
     delete[] mpChars2Glyphs;
     if( mpCharWidths != mpGlyphAdvances )
@@ -240,6 +243,7 @@ bool SimpleWinLayout::LayoutText( ImplLa
     // prepare layout
     // TODO: fix case when reusing object
     mbDisableGlyphs |= ((rArgs.mnFlags & SAL_LAYOUT_DISABLE_GLYPH_PROCESSING) != 0);
+    mnCharCount = rArgs.mnEndCharPos - rArgs.mnMinCharPos;
 
     // TODO: use a cached value for bDisableGlyphs from upper layers font info
     if( !mbDisableGlyphs )
@@ -258,11 +262,12 @@ bool SimpleWinLayout::LayoutText( ImplLa
             ||  !(aTextMetricA.tmPitchAndFamily & TMPF_TRUETYPE)
             ||   (aTextMetricA.tmPitchAndFamily & TMPF_DEVICE) )
                 mbDisableGlyphs = true;
-#if 0 // #110548# more important than #107885# => TODO: better solution
+/*
+			// #110548# more important than #107885# => TODO: better solution
             DWORD nFLI = GetFontLanguageInfo( mhDC );
             if( !(nFLI & GCP_GLYPHSHAPE) )
                 mbDisableGlyphs = true;
-#endif
+*/
         }
     }
 
@@ -277,19 +282,26 @@ bool SimpleWinLayout::LayoutText( ImplLa
 
     // layout text
     int i, j;
-    
+
     mnGlyphCount = 0;
     bool bVertical = (rArgs.mnFlags & SAL_LAYOUT_VERTICAL) != 0;
     if( !bVertical )
     {
         // count chars to process as LTR
         rArgs.ResetPos();
-        for( bool bRTL; rArgs.GetNextRun( &i, &j, &bRTL ) && !bRTL; )
+		bool bRTL;
+        for( bRTL; rArgs.GetNextRun( &i, &j, &bRTL ) && !bRTL; )
             mnGlyphCount += j - i;
+        // if there are RTL runs we need room to remember the RTL status
+        if( bRTL )
+        {
+            mpGlyphRTLFlags = new bool[ mnCharCount ];
+            for( i = 0; i < mnCharCount; ++i )
+                mpGlyphRTLFlags[i] = false;
+        }
     }
 
     const sal_Unicode* pBidiStr;
-    mnCharCount = rArgs.mnEndCharPos - rArgs.mnMinCharPos;
     if( mnGlyphCount == mnCharCount )
         pBidiStr = rArgs.mpStr + rArgs.mnMinCharPos;
     else
@@ -314,6 +326,7 @@ bool SimpleWinLayout::LayoutText( ImplLa
                     sal_Unicode cChar = rArgs.mpStr[ --j ];
                     pStr[ mnGlyphCount ] = ::GetMirroredChar( cChar );
                     mpChars2Glyphs[ j - rArgs.mnMinCharPos ] = mnGlyphCount;
+                    mpGlyphRTLFlags[ mnGlyphCount ] = true;
                     mpGlyphs2Chars[ mnGlyphCount++ ] = j;
                 } while( i < j );
             }
@@ -480,7 +493,7 @@ bool SimpleWinLayout::LayoutText( ImplLa
         }
 
         // request fallback
-        bool bRTL = false;  // TODO: get from run
+        bool bRTL = mpGlyphRTLFlags ? mpGlyphRTLFlags[i] : false;
         int nCharPos = mpGlyphs2Chars ? mpGlyphs2Chars[i]: i + rArgs.mnMinCharPos;
         rArgs.NeedFallback( nCharPos, bRTL );
 
@@ -608,8 +621,6 @@ bool SimpleWinLayout::HasGSUBstitutions(
     if( !pTTFont )
         return false;
 
-    mrGSUBList.erase( -1 ); // remove "no GSUB in font" mark
-
     // add vertically substituted characters to list
     static sal_Unicode aGSUBCandidates[] = {
         0x0020, 0x0080, // ASCII
@@ -619,12 +630,21 @@ bool SimpleWinLayout::HasGSUBstitutions(
         0xFF00, 0xFFF0, // halfwidth|fullwidth forms
     0 };
 
+    bool bHasGSUB = false;
     for( sal_Unicode* pPair = aGSUBCandidates; *pPair; pPair += 2 )
         for( sal_Unicode c = pPair[0]; c < pPair[1]; ++c )
             if( MapChar( pTTFont, c, 0 ) != MapChar( pTTFont, c, 1 ) )
+            {
+                if( !bHasGSUB )
+                {
+                    mrGSUBList.erase( -1 ); // remove "no GSUB in font" mark
+                    bHasGSUB = true;
+                }
                 mrGSUBList.insert( c ); // insert GSUBbed unicodes
+            }
 
     CloseTTFont( pTTFont );
+    return bHasGSUB;
 }
 
 // -----------------------------------------------------------------------
@@ -712,7 +732,7 @@ void SimpleWinLayout::DrawText( SalGraph
     if( mnGlyphCount <= 0 )
         return;
 
-    HDC aHDC = rGraphics.maGraphicsData.mhDC;
+    HDC aHDC = static_cast<WinSalGraphics&>(rGraphics).mhDC;
 
     UINT mnDrawOptions = ETO_GLYPH_INDEX;
     if( mbDisableGlyphs )
@@ -721,11 +741,7 @@ void SimpleWinLayout::DrawText( SalGraph
     Point aPos = GetDrawPosition( Point( mnBaseAdv, 0 ) );
 
      // #108267#, limit the number of glyphs to avoid paint errors
-#if (_MSC_VER < 1300)
-    UINT limitedGlyphCount = std::min( 8192, mnGlyphCount );
-#else
-     UINT limitedGlyphCount = min( 8192, mnGlyphCount );
-#endif
+    UINT limitedGlyphCount = Min( 8192, mnGlyphCount );
    // #108267#, break up into glyph portions of a limited size required by Win32 API
     const unsigned int maxGlyphCount = 8192;
     UINT numGlyphPortions = mnGlyphCount / maxGlyphCount;
@@ -741,13 +757,13 @@ void SimpleWinLayout::DrawText( SalGraph
             POINT oldPos;
             UINT oldTa = ::GetTextAlign( aHDC );
             ::SetTextAlign( aHDC, (oldTa & ~TA_NOUPDATECP) | TA_UPDATECP );
-            ::MoveToEx( aHDC, aPos.X(), aPos.Y(), &oldPos ); 
+            ::MoveToEx( aHDC, aPos.X(), aPos.Y(), &oldPos );
             for( i=n=0; n<numGlyphPortions; n++, i+=maxGlyphCount )
                 ::ExtTextOutW( aHDC, 0, 0, mnDrawOptions, NULL,
                     mpOutGlyphs+i, maxGlyphCount, mpGlyphAdvances+i );
             ::ExtTextOutW( aHDC, 0, 0, mnDrawOptions, NULL,
                 mpOutGlyphs+i, remainingGlyphs, mpGlyphAdvances+i );
-            ::MoveToEx( aHDC, oldPos.x, oldPos.y, (LPPOINT) NULL); 
+            ::MoveToEx( aHDC, oldPos.x, oldPos.y, (LPPOINT) NULL);
             ::SetTextAlign( aHDC, oldTa );
         }
         else
@@ -844,13 +860,12 @@ void SimpleWinLayout::GetCaretPositions(
             pCaretXArray[ i ] = -1;
 
         // assign glyph positions to character positions
-        int nLeftIdx = 0;
         for( i = 0; i < mnGlyphCount; ++i )
         {
             int nCurrIdx = mpGlyphs2Chars[ i ] - mnMinCharPos;
             long nXRight = nXPos + mpCharWidths[ nCurrIdx ];
             nCurrIdx *= 2;
-            if( nLeftIdx <= nCurrIdx )
+            if( !(mpGlyphRTLFlags && mpGlyphRTLFlags[i]) )
             {
                 // normal positions for LTR case
                 pCaretXArray[ nCurrIdx ]   = nXPos;
@@ -862,7 +877,6 @@ void SimpleWinLayout::GetCaretPositions(
                 pCaretXArray[ nCurrIdx ]   = nXRight;
                 pCaretXArray[ nCurrIdx+1 ] = nXPos;
             }
-            nLeftIdx = nCurrIdx;
             nXPos += mpGlyphAdvances[ i ];
         }
     }
@@ -881,20 +895,27 @@ void SimpleWinLayout::Justify( long nNew
     if( nNewWidth == nOldWidth )
         return;
 
-    int i = mnGlyphCount - 1;
     // the rightmost glyph cannot be stretched
-    nOldWidth -= mpGlyphAdvances[i];
-    nNewWidth -= mpGlyphAdvances[i];
-
-    // stretch remaining glyphs to new width
-    while( --i >= 0 )
+    const int nRight = mnGlyphCount - 1;
+    nOldWidth -= mpGlyphAdvances[ nRight ];
+    nNewWidth -= mpGlyphAdvances[ nRight ];
+
+    // count stretchable glyphs
+    int nStretchable = 0, i;
+    for( i = 0; i < nRight; ++i )
+        if( mpGlyphAdvances[i] >= 0 )
+            ++nStretchable;
+
+    // stretch these glyphs
+    int nDiffWidth = nNewWidth - nOldWidth;
+    for( i = 0; (i < nRight) && (nStretchable > 0); ++i )
     {
-        if( nNewWidth < 0 )
-            nNewWidth = 0;
-        double fStretch = (nOldWidth<0) ? 0.0 : (double)nNewWidth / nOldWidth;
-        nOldWidth -= mpGlyphAdvances[i];
-        mpGlyphAdvances[i] = (long)(mpGlyphAdvances[i] * fStretch + 0.5);
-        nNewWidth -= mpGlyphAdvances[i];
+        if( mpGlyphAdvances[i] <= 0 )
+            continue;
+        int nDeltaWidth = nDiffWidth / nStretchable;
+        mpGlyphAdvances[i] += nDeltaWidth;
+        --nStretchable;
+        nDiffWidth -= nDeltaWidth;
     }
 }
 
@@ -946,20 +967,19 @@ void SimpleWinLayout::ApplyDXArray( cons
 
     int i = 0;
     long nOldWidth = mnBaseAdv;
-    for(; i < mnGlyphCount; ++i )
+    for(; i < mnCharCount; ++i )
     {
         int j = !mpChars2Glyphs ? i : mpChars2Glyphs[i];
         if( j >= 0 )
         {
             nOldWidth += mpGlyphAdvances[ j ];
             int nDiff = nOldWidth - pDXArray[ i ];
-#if 0       // disabled because of #104768#
+
+	       // disabled because of #104768#
             // works great for static text, but problems when typing
-            if( nDiff>+1 || nDiff<-1 )
-#else
+            // if( nDiff>+1 || nDiff<-1 )
             // only bother with changing anything when something moved
             if( nDiff != 0 )
-#endif
                 break;
         }
     }
@@ -974,7 +994,7 @@ void SimpleWinLayout::ApplyDXArray( cons
     }
 
     mnWidth = mnBaseAdv;
-    for( i = 0; i < mnGlyphCount; ++i )
+    for( i = 0; i < mnCharCount; ++i )
     {
         int j = !mpChars2Glyphs ? i : mpChars2Glyphs[i];
         if( j >= 0 )
@@ -1056,7 +1076,7 @@ void SimpleWinLayout::Simplify( bool bIs
     // keep original widths around
     if( !mpGlyphOrigAdvs )
     {
-        mpGlyphOrigAdvs = new int[ mnGlyphCount ]; 
+        mpGlyphOrigAdvs = new int[ mnGlyphCount ];
         for( int k = 0; k < mnGlyphCount; ++k )
             mpGlyphOrigAdvs[ k ] = mpGlyphAdvances[ k ];
     }
@@ -1863,7 +1883,8 @@ void UniscribeLayout::MoveGlyph( int nSt
     long nDelta = nNewXPos - pVI->mnXOffset;
     if( nStart > nMinGlyphPos )
     {
-        for( int i = nMinGlyphPos; i < nStart; ++i )
+		int i;
+        for( i = nMinGlyphPos; i < nStart; ++i )
             nDelta -= mpGlyphAdvances[ i ];
         mpGlyphAdvances[ i-1 ] += nDelta;
     }
@@ -2166,7 +2187,8 @@ void UniscribeLayout::ApplyDXArray( cons
     bool bModified = false;
     int nOldWidth = 0;
     DBG_ASSERT( mnUnitsPerPixel==1, "UniscribeLayout.mnUnitsPerPixel != 1" );
-    for( int i = mnMinCharPos, j = 0; i < mnEndCharPos; ++i, ++j )
+	int i,j;
+    for( i = mnMinCharPos, j = 0; i < mnEndCharPos; ++i, ++j )
     {
         int nNewCharWidth = (pDXArray[j] - nOldWidth);
         // TODO: nNewCharWidth *= mnUnitsPerPixel;
@@ -2292,8 +2314,8 @@ void UniscribeLayout::Justify( long nNew
                 mpVisualAttrs + rVisualItem.mnMinGlyphPos,
                 mpGlyphAdvances + rVisualItem.mnMinGlyphPos,
                 rVisualItem.mnEndGlyphPos - rVisualItem.mnMinGlyphPos,
-                nItemWidth, 
-                nMinKashida, 
+                nItemWidth,
+                nMinKashida,
                 mpJustifications + rVisualItem.mnMinGlyphPos );
 
             rVisualItem.mnXOffset = nXOffset;
@@ -2318,7 +2340,7 @@ public:
     virtual ~WinTextLayoutCache() { flush( 0 ); }
     virtual void flush( int nMinLevel );
 
-// public access only visible to SalGraphics::GetTextLayout()
+// public access only visible to WinSalGraphics::GetTextLayout()
 #ifdef GNG_VERT_HACK
     GSUBList maGSUBLists[ MAX_FALLBACK ];
 #endif // GNG_VERT_HACK
@@ -2356,15 +2378,15 @@ void WinTextLayoutCache::flush( int nMin
 
 // =======================================================================
 
-SalLayout* SalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
+SalLayout* WinSalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
 {
     WinLayout* pWinLayout = NULL;
 
-    WinTextLayoutCache* pCache = (WinTextLayoutCache*)maGraphicsData.mxTextLayoutCache.get();
+    WinTextLayoutCache* pCache = (WinTextLayoutCache*)mxTextLayoutCache.get();
     if( !pCache )
     {
         pCache = new WinTextLayoutCache;
-        maGraphicsData.mxTextLayoutCache.reset( pCache );
+        mxTextLayoutCache.reset( pCache );
     }
 
 #ifdef USE_UNISCRIBE
@@ -2373,7 +2395,7 @@ SalLayout* SalGraphics::GetTextLayout( I
     {
         // script complexity is determined in upper layers
         SCRIPT_CACHE& rScriptCache = pCache->maScriptCache[ nFallbackLevel ];
-        pWinLayout = new UniscribeLayout( maGraphicsData.mhDC, rScriptCache );
+        pWinLayout = new UniscribeLayout( mhDC, rScriptCache );
         // NOTE: it must be guaranteed that the SalGraphics lives longer than
         // the created UniscribeLayout, otherwise the data passed into the
         // constructor might become invalid too early
@@ -2382,7 +2404,7 @@ SalLayout* SalGraphics::GetTextLayout( I
 #endif // USE_UNISCRIBE
     {
 #ifdef GCP_KERN_HACK
-        if( (rArgs.mnFlags & SAL_LAYOUT_KERNING_PAIRS) && maGraphicsData.mbFontKernInit )
+        if( (rArgs.mnFlags & SAL_LAYOUT_KERNING_PAIRS) && mbFontKernInit )
             GetKernPairs( 0, NULL );
 #endif // GCP_KERN_HACK
 
@@ -2391,11 +2413,11 @@ SalLayout* SalGraphics::GetTextLayout( I
 #endif // GNG_VERT_HACK
 
         BYTE eCharSet = ANSI_CHARSET;
-        if( maGraphicsData.mpLogFont )
-            eCharSet = maGraphicsData.mpLogFont->lfCharSet;
-        pWinLayout = new SimpleWinLayout( maGraphicsData.mhDC, eCharSet
+        if( mpLogFont )
+            eCharSet = mpLogFont->lfCharSet;
+        pWinLayout = new SimpleWinLayout( mhDC, eCharSet
 #ifdef GCP_KERN_HACK
-            , maGraphicsData.mpFontKernPairs, maGraphicsData.mnFontKernPairCount
+            , mpFontKernPairs, mnFontKernPairCount
 #endif // GCP_KERN_HACK
 #ifdef GNG_VERT_HACK
             , rGSUBList
