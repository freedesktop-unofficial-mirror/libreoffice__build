Index: vcl/win/source/app/saldata.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/saldata.cxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/win/source/app/saldata.cxx	1 Apr 2003 14:07:44 -0000	1.4
+++ vcl/win/source/app/saldata.cxx	6 Jan 2004 14:51:01 -0000	1.5
@@ -63,8 +63,6 @@
 #include <tools/svwin.h>
 #endif
 #include "rtl/tencinfo.h"
-
-#define _SV_SALDATA_CXX
 
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
Index: vcl/win/source/app/salinfo.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salinfo.cxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/win/source/app/salinfo.cxx	12 Oct 2001 16:27:12 -0000	1.3
+++ vcl/win/source/app/salinfo.cxx	6 Jan 2004 14:51:26 -0000	1.5
@@ -59,825 +59,101 @@
  *
  ************************************************************************/
 
-#if 1
-
-/* !!! UNICODE !!! */
-/* !!! This code should be change from ByteString to
-   !!! UniString, currently we doesn't support this !!! */
-
-#include <tools/string.hxx>
-#include <salsys.hxx>
-
-String GetSalSummarySystemInfos( ULONG nFlags )
-{
-    return XubString();
-}
-
-#else
-
 #define VCL_NEED_BASETSD
-
 #include <tools/presys.h>
 #include <windows.h>
-#include <imagehlp.h>
 #include <tools/postsys.h>
 
-#include <stdio.h>
 #include <tools/string.hxx>
 #include <salsys.hxx>
-
-#include <algorithm>
-
-// Wegen Stacktrace-Generierung
-#pragma optimize ("", off)
-
-// #include <tlhelp32.h>
-// ToolHelp32
-#define MAX_MODULE_NAME32 255
-#define TH32CS_SNAPMODULE   0x00000008
-
-typedef struct tagMODULEENTRY32
-{
-    DWORD   dwSize;
-    DWORD   th32ModuleID;       // This module
-    DWORD   th32ProcessID;      // owning process
-    DWORD   GlblcntUsage;       // Global usage count on the module
-    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
-    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
-    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
-    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
-    char    szModule[MAX_MODULE_NAME32 + 1];
-    char    szExePath[MAX_PATH];
-} MODULEENTRY32;
-typedef MODULEENTRY32 *  PMODULEENTRY32;
-typedef MODULEENTRY32 *  LPMODULEENTRY32;
-
-// PSAPI functions - Windows NT only
-typedef struct _MODULEINFO {
-    LPVOID lpBaseOfDll;
-    DWORD SizeOfImage;
-    LPVOID EntryPoint;
-} MODULEINFO, *LPMODULEINFO;
-
-
-
-// PSAPI
-typedef BOOL (WINAPI *ENUMPROCESSMODULESPROC)( HANDLE hProcess, HMODULE* lphModule, DWORD cb, LPDWORD lpcbNeeded );
-typedef BOOL (WINAPI *GETMODULEINFORMATIONPROC)( HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb );
-typedef DWORD (WINAPI *GETMODULEBASENAMEAPROC)( HANDLE hProcess, HMODULE hModule, LPSTR lpBaseName, DWORD nSize );
-typedef DWORD (WINAPI *GETMODULEFILENAMEEXAPROC)( HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize );
-typedef HANDLE (WINAPI *CREATESNAPSHOTPROC)(DWORD dwFlags, DWORD th32ProcessID);
-typedef BOOL (WINAPI *MODULE32FIRSTPROC)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
-typedef BOOL (WINAPI *MODULE32NEXTPROC)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
-
-
-// ImageHlp
-typedef int (__stdcall *STACKWALKPROC) ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, PVOID, PREAD_PROCESS_MEMORY_ROUTINE,PFUNCTION_TABLE_ACCESS_ROUTINE, PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );
-typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, DWORD );
-typedef DWORD (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, DWORD );
-typedef DWORD (__stdcall *SYMSETOPTIONSPROC ) (DWORD dwSymOptions);
-typedef int (__stdcall *SYMINITIALIZEPROC ) ( HANDLE, LPSTR, int );
-typedef int (__stdcall *SYMCLEANUPPROC)( HANDLE );
-typedef DWORD (__stdcall WINAPI *UNDECORATESYMBOLNAMEPROC)( PCSTR, PSTR, DWORD, DWORD );
-typedef DWORD (__stdcall *SYMLOADMODULEPROC) ( HANDLE, HANDLE, LPSTR, LPSTR, DWORD, DWORD );
-typedef int (__stdcall *SYMGETSYMFROMADDR)( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
-
-
-struct ModuleInfo
-{
-    struct ModuleInfo*          pNext;
-
-    char                        szModBaseName[MAX_PATH];
-    char                        szModFileName[MAX_PATH];
-    unsigned long               nBaseAddress;
-    unsigned long               nSize;
-//  unsigned long               nEntryPoint;
-//  HANDLE                      nHandle;
-//  PIMAGE_DEBUG_INFORMATION    pDebugInfos;
-};
-
-struct ModuleInfo* FindModuleContainingAddress( struct ModuleInfo* pStart, void* pAddr );
-
-
-
-struct SystemInfos
-{
-    DWORD   nCurrentProcessId;
-    HANDLE  hCurrentProcess;
-    DWORD   nCurrentThreadId;
-    HANDLE  hCurrentThread;
-
-    ModuleInfo* pModInfos;
-
-    String  aStack;
-    String  aModules;
-    String  aSystemVersion;
-    String  aCPUType;
-    String  aMemoryInfo;
-    String  aLocalVolumes;
-    String  aSystemDirs;
-    String  aMouseInfo;
-
-    SystemInfos()
-    {
-        nCurrentProcessId = 0;
-        hCurrentProcess = 0;
-        hCurrentThread = 0;
-        pModInfos = NULL;
-    }
+#include <salframe.h>
+#include <salinst.h>
+#include <tools/debug.hxx>
+#include <svdata.hxx>
+#include <window.hxx>
+
+class WinSalSystem : public SalSystem
+{
+public:
+    WinSalSystem() {}
+    virtual ~WinSalSystem();
+
+    virtual bool GetSalSystemDisplayInfo( DisplayInfo& rInfo );
+    virtual int ShowNativeMessageBox( const String& rTitle,
+                                      const String& rMessage,
+                                      int nButtonCombination,
+                                      int nDefaultButton);
 };
 
-void DebugThread( SystemInfos* pSysInfos );
-
-
-typedef struct _Thread
-{
-    DWORD dwThreadId;
-    HANDLE hThread;
-} Thread;
-
-
-struct ModuleInfo*  WNT_CreateModuleInfos();
-
-String ImplCreateToken( const String& rToken )
-{
-    String aToken( '<' );
-    aToken += rToken;
-    aToken += ' ';
-    while ( aToken.Len() < 25 )
-        aToken += '-';
-    aToken += '>';
-    return aToken;
-}
-
-
-
-String WNT_CreateModulePath( struct ModuleInfo* pModInfos )
+SalSystem* WinSalInstance::CreateSalSystem()
 {
-    String aPath;
-    struct ModuleInfo* pM = pModInfos;
-    while ( pM )
-    {
-        String aTmpPath = pM->szModFileName;
-        USHORT n = aTmpPath.SearchBackward( '\\' );
-        if ( n != STRING_NOTFOUND )
-            aTmpPath.Erase( n );
-        aTmpPath += ';';
-        aTmpPath.ToLower();
-        if ( aPath.Search( aTmpPath ) == STRING_NOTFOUND  )
-            aPath += aTmpPath;
-
-        pM = pM->pNext;
-    }
-    return aPath;
-}
-
-
-struct ModuleInfo*  WNT_CreateModuleInfos()
-{
-    struct ModuleInfo* pModInfos = NULL;
-
-    OSVERSIONINFO aOSVersion;
-    aOSVersion.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
-    if ( GetVersionEx( &aOSVersion ) )
-    {
-        if ( aOSVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
-        {
-            HINSTANCE hPSAPILib = LoadLibrary( "PSAPI.DLL" );
-            if( hPSAPILib )
-            {
-                ENUMPROCESSMODULESPROC _fpEnumProcessModules = (ENUMPROCESSMODULESPROC) GetProcAddress( hPSAPILib, "EnumProcessModules" );
-                GETMODULEINFORMATIONPROC _fpGetModuleInformation = (GETMODULEINFORMATIONPROC) GetProcAddress( hPSAPILib, "GetModuleInformation" );
-                GETMODULEBASENAMEAPROC _fpGetModuleBaseNameA = (GETMODULEBASENAMEAPROC) GetProcAddress( hPSAPILib, "GetModuleBaseNameA" );
-                GETMODULEFILENAMEEXAPROC _fpGetModuleFileNameExA = (GETMODULEFILENAMEEXAPROC) GetProcAddress( hPSAPILib, "GetModuleFileNameExA" );
-
-                HANDLE hProcess = GetCurrentProcess();
-                HMODULE hMods[1024];
-                DWORD cbNeeded;
-                if( _fpEnumProcessModules( hProcess, hMods, sizeof(hMods), &cbNeeded ) )
-                {
-                    int nMods = cbNeeded / sizeof( HMODULE );
-                    int nArrSz = nMods * sizeof( struct ModuleInfo );
-                    pModInfos = (struct ModuleInfo*) malloc( nArrSz );
-                    memset( pModInfos, 0, nArrSz );
-
-                    for ( int i = 0; i < nMods; i++ )
-                    {
-                        pModInfos[i].pNext = 0;
-                        if ( i )
-                            pModInfos[i-1].pNext = &pModInfos[i];
-
-                        _fpGetModuleBaseNameA( hProcess, hMods[i], pModInfos[i].szModBaseName, sizeof( pModInfos[i].szModBaseName ) );
-                        _fpGetModuleFileNameExA( hProcess, hMods[i], pModInfos[i].szModFileName, sizeof( pModInfos[i].szModFileName ) );
-
-                        MODULEINFO aInf;
-                        if ( _fpGetModuleInformation( hProcess, hMods[i], &aInf, sizeof( aInf ) ) )
-                        {
-                            pModInfos[i].nBaseAddress = (unsigned long) aInf.lpBaseOfDll;
-                            pModInfos[i].nSize = aInf.SizeOfImage;
-        //                  pModInfos[i].nEntryPoint = (unsigned long) aInf.EntryPoint;
-                        }
-                    }
-                }
-                FreeLibrary( hPSAPILib );
-            }
-        }
-        else if ( aOSVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
-        {
-            HINSTANCE hToolHelpLib = LoadLibrary( "KERNEL32.DLL" );
-            if( hToolHelpLib )
-            {
-                CREATESNAPSHOTPROC _fpCreateSnapshot = (CREATESNAPSHOTPROC) GetProcAddress( hToolHelpLib, "CreateToolhelp32Snapshot" );
-                MODULE32FIRSTPROC _fpModule32First = (MODULE32FIRSTPROC) GetProcAddress( hToolHelpLib, "Module32First" );
-                MODULE32NEXTPROC _fpModule32Next = (MODULE32NEXTPROC) GetProcAddress( hToolHelpLib, "Module32Next" );
-
-                HANDLE hSnap = _fpCreateSnapshot( TH32CS_SNAPMODULE, 0 );
-                if ( hSnap )
-                {
-                    MODULEENTRY32 aMod32Entry;
-                    ZeroMemory( &aMod32Entry, sizeof( MODULEENTRY32 ) );
-                    aMod32Entry.dwSize = sizeof( MODULEENTRY32 );
-                    int nMods = 0;
-                    BOOL bMod = _fpModule32First( hSnap, &aMod32Entry );
-                    while ( bMod )
-                    {
-                        nMods++;
-                        bMod = _fpModule32Next( hSnap, &aMod32Entry );
-                    }
-
-                    int nArrSz = nMods * sizeof( struct ModuleInfo );
-                    pModInfos = (struct ModuleInfo*) malloc( nArrSz );
-                    memset( pModInfos, 0, nArrSz );
-
-                    int nMod = 0;
-                    bMod = _fpModule32First( hSnap, &aMod32Entry );
-                    while ( bMod )
-                    {
-                        pModInfos[nMod].pNext = 0;
-                        if ( nMod )
-                            pModInfos[nMod-1].pNext = &pModInfos[nMod];
-
-                        strcpy( pModInfos[nMod].szModBaseName, aMod32Entry.szModule );
-                        strcpy( pModInfos[nMod].szModFileName, aMod32Entry.szExePath );
-                        pModInfos[nMod].nBaseAddress = (unsigned long) aMod32Entry.modBaseAddr;
-                        pModInfos[nMod].nSize = aMod32Entry.modBaseSize;
-//                      pModInfos[nMod].nEntryPoint = 0xFFFFFFFF;
-
-                        bMod = _fpModule32Next( hSnap, &aMod32Entry );
-                        nMod++;
-                    }
-
-                    CloseHandle( hSnap );
-                }
-
-                FreeLibrary( hToolHelpLib );
-            }
-        }
-    }
-    return pModInfos;
+    return new WinSalSystem();
 }
 
-BOOL WNT_GetLogicalAddress( PVOID addr, PTSTR szModule, DWORD len, DWORD& section, DWORD& offset )
+WinSalSystem::~WinSalSystem()
 {
-    MEMORY_BASIC_INFORMATION mbi;
-
-    if( VirtualQuery( addr, &mbi, sizeof(mbi) ) && mbi.AllocationBase )
-    {
-        DWORD hMod = (DWORD)mbi.AllocationBase;
-
-        if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
-            return FALSE;
-
-        // Point to the DOS header in memory
-        PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)hMod;
-
-        // From the DOS header, find the NT (PE) header
-        PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
-
-        PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION( pNtHdr );
-
-        DWORD rva = (DWORD)addr - hMod; // RVA is offset from module load address
-
-        // Iterate through the section table, looking for the one that encompasses
-        // the linear address.
-        for (   unsigned i = 0;
-                i < pNtHdr->FileHeader.NumberOfSections;
-                i++, pSection++ )
-        {
-            DWORD sectionStart = pSection->VirtualAddress;
-            DWORD sectionEnd = sectionStart
-                        + std::max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);
-
-            // Is the address in this section???
-            if ( (rva >= sectionStart) && (rva <= sectionEnd) )
-            {
-                // Yes, address is in the section.  Calculate section and offset,
-                // and store in the "section" & "offset" params, which were
-                // passed by reference.
-                section = i+1;
-                offset = rva - sectionStart;
-                return TRUE;
-            }
-        }
-    }
-    return FALSE;
 }
 
+// -----------------------------------------------------------------------
 
-struct ModuleInfo* FindModuleContainingAddress( struct ModuleInfo* pStart, void* pAddr )
+bool WinSalSystem::GetSalSystemDisplayInfo( DisplayInfo& rInfo )
 {
-    struct ModuleInfo* pRet = NULL;
-    struct ModuleInfo* pM = pStart;
-    unsigned long nAddr = (unsigned long) pAddr;
+    RECT aRect;
+    ImplSalGetWorkArea( NULL, &aRect, NULL );
 
-    while ( pM && !pRet )
+    HDC hDC;
+    if( hDC = GetDC( NULL ) )
     {
-        if ( ( nAddr >= pM->nBaseAddress ) &&
-             ( nAddr < ( pM->nBaseAddress + pM->nSize ) ) )
-        {
-            pRet = pM;
-        }
-        else
-        {
-            pM = pM->pNext;
-        }
-    }
-    return pRet;
-}
-
-String _OLD_GetStackInfo()
-{
-    // Try an other way...
-    String aTmpStack;
-    ModuleInfo* pMods = WNT_CreateModuleInfos();
-
-    ULONG* pBP;
-    __asm mov pBP, ebp;
-    char buffer[1024];
-
-    for ( int i = 0; i < 15; i++ )
-    {
-        ULONG nIP = pBP[1];
-        sprintf( buffer, "[%.2u] IP=%.8lx", i, nIP );
-        aTmpStack += buffer;
-
-        ModuleInfo* pI = FindModuleContainingAddress( pMods, (void*)nIP );
-        if ( pI )
-        {
-            sprintf( buffer, " (Rel=%.8lx) [%s, Base=%.8lx, Path=%s]", nIP-pI->nBaseAddress-0x1000, pI->szModBaseName, pI->nBaseAddress, pI->szModFileName );
-            aTmpStack += buffer;
-        }
-
-        if ( !pI || (pBP[0] & 3) || (ULONG)pBP > pBP[0] )
-        {
-            aTmpStack += "\nError!\n";
-            break;
-        }
-
-        aTmpStack += '\n';
-        pBP = (ULONG*) pBP[0];
+        rInfo.nWidth    = aRect.right - aRect.left;
+        rInfo.nHeight   = aRect.bottom - aRect.top;
+        rInfo.nDepth    = GetDeviceCaps( hDC, BITSPIXEL );
+        ReleaseDC( NULL, hDC );
+        return true;
     }
-
-    // Modul-Infos zerstoeren...
-    return aTmpStack;
+    else
+        return false;
 }
 
-String GetSalSummarySystemInfos( ULONG nFlags )
+// -----------------------------------------------------------------------
+/* We have to map the button identifier to the identifier used by the Win32
+   Platform SDK to specify the default button for the MessageBox API.
+   The first dimension is the button combination, the second dimension
+   is the button identifier.
+*/
+static int DEFAULT_BTN_MAPPING_TABLE[][8] =
 {
-    SystemInfos aSysInfos;
-    HANDLE nCurrentThreadPseudo = GetCurrentThread();
-    HANDLE nCurrentProcessPseudo = GetCurrentProcess();
-    aSysInfos.nCurrentThreadId = GetCurrentThreadId();
-    DuplicateHandle( nCurrentProcessPseudo, nCurrentThreadPseudo, nCurrentProcessPseudo,
-                        &aSysInfos.hCurrentThread, PROCESS_ALL_ACCESS, TRUE, 0 );
-    aSysInfos.nCurrentProcessId = GetCurrentProcessId();
-    DuplicateHandle( nCurrentProcessPseudo, nCurrentProcessPseudo, nCurrentProcessPseudo,
-                        &aSysInfos.hCurrentProcess, PROCESS_ALL_ACCESS, TRUE, 0 );
-
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_STACK )
-    {
-        DWORD nDebugThreadId;
-        HANDLE hDebugThread = CreateThread(
-                                NULL, 16000,
-                                (LPTHREAD_START_ROUTINE)DebugThread, &aSysInfos,
-                                0, &nDebugThreadId );
-
-        WaitForSingleObject( hDebugThread, INFINITE );
-        CloseHandle( hDebugThread );
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_MODULES )
-    {
-        aSysInfos.aModules = "<Modules>\n";
-        char buffer[1024];
-        if ( !aSysInfos.pModInfos )
-            aSysInfos.pModInfos = WNT_CreateModuleInfos();
-        struct ModuleInfo* pM = aSysInfos.pModInfos;
-        while ( pM )
-        {
-            aSysInfos.aModules += "  <Module name=\"";
-            aSysInfos.aModules += pM->szModBaseName;
-            aSysInfos.aModules += "\" path=\"";
-            aSysInfos.aModules += pM->szModFileName;
-            aSysInfos.aModules += "\" >\n";
-            aSysInfos.aModules += "    <ModuleInfo name=\"BASE\" value=\"";
-            sprintf( buffer, "%.8lx", pM->nBaseAddress );
-            aSysInfos.aModules += buffer;
-            aSysInfos.aModules += "\" />\n";
-            aSysInfos.aModules += "    <ModuleInfo name=\"Size\" value=\"";
-            aSysInfos.aModules += pM->nSize;
-            aSysInfos.aModules += "\" />\n  </Module>\n";
-            pM = pM->pNext;
-        }
-        aSysInfos.aModules += "</Modules>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_SYSTEMVERSION )
-    {
-        aSysInfos.aSystemVersion = "<System name=\"";
-        OSVERSIONINFO aVersionInfos;
-        memset(&aVersionInfos, 0, sizeof( OSVERSIONINFO ) );
-        aVersionInfos.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
-        GetVersionEx( &aVersionInfos );
-        if ( aVersionInfos.dwPlatformId == VER_PLATFORM_WIN32s )
-            aSysInfos.aSystemVersion += "Microsoft Win32s";
-        else if ( aVersionInfos.dwPlatformId == VER_PLATFORM_WIN32_NT )
-            aSysInfos.aSystemVersion += "Microsoft Windows NT";
-        else if ( aVersionInfos.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
-        {
-            if ( !aVersionInfos.dwMinorVersion )
-                aSysInfos.aSystemVersion += "Microsoft Windows 95";
-            else
-                aSysInfos.aSystemVersion += "Microsoft Windows 98";
-        }
-        else
-            aSysInfos.aSystemVersion += "Unknown Windows";
-        aSysInfos.aSystemVersion += "\" version=\"";
-        aSysInfos.aSystemVersion += aVersionInfos.dwMajorVersion;
-        aSysInfos.aSystemVersion += '.';
-        aSysInfos.aSystemVersion += aVersionInfos.dwMinorVersion;
-        aSysInfos.aSystemVersion += "\" build=\"";
-        aSysInfos.aSystemVersion += aVersionInfos.dwBuildNumber&0xFFFF;
-        aSysInfos.aSystemVersion += "\" />";
-
-        // aSysInfos.aSystemVersion += aVersionInfos.szCSDVersion;
-        /*
-            Under both Windows NT and Windows 95, you can get the
-            language information in the FileVersionInfo of User.exe by
-            calling GetFileVersionInfo, and then
-            VerQueryValue (on \\VarFileInfo\\Translation") on the
-            VersionInfo block of the operating system's User.exe.
-            NOTE: This method is the most reliable. It works well under
-            both Windows NT and Windows 95. This method also works for
-            Windows 3.1
-        */
-//      DWORD nDefInputLanguage;
-//      if ( SystemParametersInfo( SPI_GETDEFAULTINPUTLANG, 0, &nDefInputLanguage, 0 ) )
-//      {
-//          aSysInfos.aSystemVersion += " default input language = ";
-//          aSysInfos.aSystemVersion += nDefInputLanguage;
-//      }
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_CPUTYPE )
-    {
-        SYSTEM_INFO aSystemInfo;
-        memset( &aSystemInfo, 0, sizeof( SYSTEM_INFO ) );
-        GetSystemInfo( &aSystemInfo );
-        aSysInfos.aCPUType = "<CPU count=\"";
-        aSysInfos.aCPUType += aSystemInfo.dwNumberOfProcessors;
-        aSysInfos.aCPUType += "\" type=\"";
-        if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "X86";
-        else if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "MIPS";
-        else if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "ALPHA";
-        else if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "PPC";
-        else
-            aSysInfos.aCPUType += "unknown";
-        aSysInfos.aCPUType += "\"></CPU>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_MEMORYINFO )
-    {
-        MEMORYSTATUS aMemStatus;
-        memset( &aMemStatus, 0, sizeof( MEMORYSTATUS ) );
-        GlobalMemoryStatus( &aMemStatus );
-        aSysInfos.aMemoryInfo = "<Memory>\n";
-        aSysInfos.aMemoryInfo += "  <MemoryType name=\"Physical\" total=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwTotalPhys+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" free=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwAvailPhys+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" />\n";
-        aSysInfos.aMemoryInfo += "  <MemoryType name=\"Swap\" total=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwTotalPageFile+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" free=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwAvailPageFile+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" />\n";
-        aSysInfos.aMemoryInfo += "  <MemoryType name=\"Virtual\" total=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwTotalVirtual+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" free=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwAvailVirtual+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" />\n";
-        aSysInfos.aMemoryInfo += "</Memory>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_LOCALVOLUMES )
-    {
-        aSysInfos.aLocalVolumes = "<LocalVolumes>\n";
-        char aDriveStrings[4096];
-        GetLogicalDriveStrings( 4096, aDriveStrings );
-        LPTSTR pDriveStr = aDriveStrings;
-        while ( *pDriveStr )
-        {
-            UINT nType = GetDriveType( pDriveStr );
-            if ( nType != DRIVE_REMOTE )
-            {
-                aSysInfos.aLocalVolumes += "  <LocalVolume type=\"";
-
-                switch ( nType )
-                {
-                    case DRIVE_REMOVABLE:   aSysInfos.aLocalVolumes += "Removable"; break;
-                    case DRIVE_FIXED:       aSysInfos.aLocalVolumes += "Fixed"; break;
-                    case DRIVE_REMOTE:      aSysInfos.aLocalVolumes += "Remote";    break;
-                    case DRIVE_CDROM:       aSysInfos.aLocalVolumes += "CD-ROM";    break;
-                    case DRIVE_RAMDISK:     aSysInfos.aLocalVolumes += "RAM disk";  break;
-                    default:                aSysInfos.aLocalVolumes += "Unkown";
-                }
-                aSysInfos.aLocalVolumes += "\" path=\"";
-                aSysInfos.aLocalVolumes += pDriveStr;
-                aSysInfos.aLocalVolumes += "\"";
-                if( nType == DRIVE_FIXED )
-                {
-                    DWORD nSectorsPerCluster;
-                    DWORD nBytesPerSector;
-                    DWORD nNumberFreeClusters;
-                    DWORD nNumberTotalClusters;
-                    if( GetDiskFreeSpace( pDriveStr, &nSectorsPerCluster, &nBytesPerSector, &nNumberFreeClusters, &nNumberTotalClusters ) )
-                    {
-                        DWORD nUnitsPerCluster = nSectorsPerCluster*nBytesPerSector;
-                        DWORD nUnitDivi = 1;
-                        String aUnit = "bytes";
-                        if( ( nUnitsPerCluster % 1024 ) == 0 )
-                        {
-                            aUnit = "KB";
-                            nUnitsPerCluster /= 1024;
-                        }
-                        else if( ( nUnitsPerCluster % 512 ) == 0 )
-                        {
-                            aUnit = "KB";
-                            nUnitDivi = 1024;
-                        }
-                        DWORD nFree = nNumberFreeClusters*nUnitsPerCluster/nUnitDivi;
-                        aSysInfos.aLocalVolumes += " free=\"";
-                        aSysInfos.aLocalVolumes += nFree;
-                        aSysInfos.aLocalVolumes += ' ';
-                        aSysInfos.aLocalVolumes += aUnit;
-                        aSysInfos.aLocalVolumes += "\"";
-                    }
-                }
-                aSysInfos.aLocalVolumes += " />\n";
-            }
-            while ( *pDriveStr )
-                pDriveStr++;
-            pDriveStr++;
-        }
-        aSysInfos.aLocalVolumes += "</LocalVolumes>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_SYSTEMDIRS )
-    {
-        aSysInfos.aSystemDirs = "<SystemDirs>\n";
-        char buffer[ MAX_PATH ];
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"Windows\" path=\"";
-        if( GetWindowsDirectory( buffer, MAX_PATH ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"System\" path=\"";
-        if( GetSystemDirectory( buffer, MAX_PATH ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"Current\" path=\"";
-        if( GetCurrentDirectory( MAX_PATH, buffer ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"Temp\" path=\"";
-        if( GetTempPath( MAX_PATH, buffer ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-        aSysInfos.aSystemDirs += "</SystemDirs>";
-
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_MOUSEINFO )
-    {
-        aSysInfos.aMouseInfo = "<Mouse ";
-        int nRet = GetSystemMetrics( SM_CMOUSEBUTTONS );
-        if ( nRet )
-        {
-            aSysInfos.aMouseInfo += "buttons=\"";
-            aSysInfos.aMouseInfo += nRet;
-            aSysInfos.aMouseInfo += "\" description=\"";
-            if( GetSystemMetrics( 75 /*SM_MOUSEWHEELPRESENT - missing in SDK from MSVC4.2 */ ) )
-                aSysInfos.aMouseInfo += "wheel mouse";
-            else
-                aSysInfos.aMouseInfo += "standard mouse";
-            aSysInfos.aMouseInfo += "\"";
-        }
-        else
-        {
-            aSysInfos.aMouseInfo += "description=\"Not installed.\"";
-        }
-        aSysInfos.aMouseInfo += " />";
-    }
-
-    CloseHandle( aSysInfos.hCurrentThread );
-    CloseHandle( aSysInfos.hCurrentProcess );
-
-    String aInfos;
-
-    aInfos += aSysInfos.aSystemVersion;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aCPUType;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aMouseInfo;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aMemoryInfo;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aStack;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aModules;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aLocalVolumes;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aSystemDirs;
-    aInfos += "\n\n";
-
-    return aInfos;
-}
-
-
-
+    //  Undefined        OK             CANCEL         ABORT          RETRY          IGNORE         YES             NO
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //OK
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //OK_CANCEL
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //ABORT_RETRY_IGNO
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON3, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2 }, //YES_NO_CANCEL
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2 }, //YES_NO
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }  //RETRY_CANCEL
+};
 
-void DebugThread( SystemInfos* pSysInfos )
+int WinSalSystem::ShowNativeMessageBox(const String& rTitle, const String& rMessage, int nButtonCombination, int nDefaultButton)
 {
-    HINSTANCE hImageHelpLib = LoadLibrary( "IMAGEHLP.DLL" );
-    if( hImageHelpLib )
-    {
-        if ( SuspendThread( pSysInfos->hCurrentThread ) != 0xFFFFFFFF )
-        {
-            STACKFRAME aStackFrame;
-            memset( &aStackFrame, 0, sizeof( aStackFrame ) );
-
-            CONTEXT aContext;
-            memset( &aContext, 0, sizeof( aContext ) );
-            aContext.ContextFlags = CONTEXT_FULL;
-            if ( GetThreadContext( pSysInfos->hCurrentThread, &aContext ) )
-            {
-                STACKWALKPROC _fpStackWalk = (STACKWALKPROC) GetProcAddress( hImageHelpLib, "StackWalk" );
-                SYMFUNCTIONTABLEACCESSPROC _fpSymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC) GetProcAddress( hImageHelpLib, "SymFunctionTableAccess" );
-                SYMGETMODULEBASEPROC _fpSymGetModuleBase = (SYMGETMODULEBASEPROC) GetProcAddress( hImageHelpLib, "SymGetModuleBase" );
-                SYMSETOPTIONSPROC _fpSymSetOptionsProc = (SYMSETOPTIONSPROC) GetProcAddress( hImageHelpLib, "SymGetOptions" );
-                SYMINITIALIZEPROC _fpSymInitializeProc = (SYMINITIALIZEPROC) GetProcAddress( hImageHelpLib, "SymInitialize" );
-                SYMCLEANUPPROC _fpSymCleanup = (SYMCLEANUPPROC) GetProcAddress( hImageHelpLib, "SymCleanup" );
-                UNDECORATESYMBOLNAMEPROC _fpUndecorateSymbolName = (UNDECORATESYMBOLNAMEPROC) GetProcAddress( hImageHelpLib, "UnDecorateSymbolName" );
-                SYMLOADMODULEPROC _fpSymLoadModule = ( SYMLOADMODULEPROC) GetProcAddress( hImageHelpLib, "SymLoadModule" );
-                SYMGETSYMFROMADDR _fpSymGetSymFromAddr = ( SYMGETSYMFROMADDR ) GetProcAddress( hImageHelpLib, "SymGetSymFromAddr" );
-
-                if ( !pSysInfos->pModInfos )
-                    pSysInfos->pModInfos = WNT_CreateModuleInfos();
-
-                _fpSymSetOptionsProc( SYMOPT_DEFERRED_LOADS );
-
-                char buffer[1024];
-
-                // Initialize the imagehlp symbol handler
-                BOOL bAutoLoad = FALSE;
-//              String aPath = WNT_CreateModulePath( pSysInfos->pModInfos );
-//              USHORT nLen = aPath.Len();
-//              memcpy( buffer, aPath.GetStr(), nLen );
-//              buffer[nLen] = 0;
-//              BOOL bSymbols = _fpSymInitializeProc( pSysInfos->hCurrentProcess, NULL, bAutoLoad );
-                // Path funktioniert nicht, also lade ich unten alle von Hand!
-                BOOL bSymbols = _fpSymInitializeProc( pSysInfos->hCurrentProcess, NULL, bAutoLoad );
-
-                // Load symbol modules for the current process
-                if ( bSymbols && !bAutoLoad )
-                {
-                    // LoadModuleSymbols( pSysInfos->nCurrentProcessId, pSysInfos->hCurrentProcess );
-                    struct ModuleInfo* pM = pSysInfos->pModInfos;
-                    char buffer1[1024];
-                    char buffer2[1024];
-
-                    while ( pM )
-                    {
-                        strcpy( buffer1, pM->szModFileName );
-                        strcpy( buffer2, pM->szModBaseName );
-
-                        BOOL bDone = _fpSymLoadModule( pSysInfos->hCurrentProcess, 0, buffer1, buffer2, pM->nBaseAddress, pM->nSize );
-
-                        pM = pM->pNext;
-                    }
-                }
-
-                // Initialize the STACKFRAME structure for the first call.  This is only
-                // necessary for Intel CPUs, and isn't mentioned in the documentation.
-                aStackFrame.AddrPC.Offset       = aContext.Eip;
-                aStackFrame.AddrPC.Mode         = AddrModeFlat;
-                aStackFrame.AddrStack.Offset    = aContext.Esp;
-                aStackFrame.AddrStack.Mode      = AddrModeFlat;
-                aStackFrame.AddrFrame.Offset    = aContext.Ebp;
-                aStackFrame.AddrFrame.Mode      = AddrModeFlat;
-
-
-                pSysInfos->aStack = "<Stack type=\"WIN32\" >\n";
-
-                for ( int nS = 0; nS < 20; nS++ )
-                {
-                    SetLastError( 0 );
-                    BOOL bStack = _fpStackWalk( IMAGE_FILE_MACHINE_I386,
-                                                pSysInfos->hCurrentProcess,
-                                                pSysInfos->hCurrentThread,
-                                                &aStackFrame,
-                                                &aContext,
-                                                NULL, // ReadProcessMemory,
-                                                _fpSymFunctionTableAccess,
-                                                _fpSymGetModuleBase,
-                                                NULL );
-
-                    if ( !bStack || !aStackFrame.AddrReturn.Offset || !aStackFrame.AddrFrame.Offset )
-                        break;
-
-                    pSysInfos->aStack += "  <StackInfo pos=\"";
-                    pSysInfos->aStack += (USHORT)nS;
-                    pSysInfos->aStack += "\" ip=\"";
-                    ULONG nIP = aStackFrame.AddrReturn.Offset;
-                    sprintf( buffer, "%.8lx", nIP );
-                    pSysInfos->aStack += buffer;
-                    pSysInfos->aStack += "\"";
-
-                    TCHAR aModuleFileName[MAX_PATH];
-                    DWORD section, offset;
-                    if ( WNT_GetLogicalAddress( (void*)nIP, aModuleFileName, MAX_PATH, section, offset ) )
-                    {
-                        pSysInfos->aStack += " rel=\"";
-                        sprintf( buffer, "%.8lx", offset );
-                        pSysInfos->aStack += buffer;
-                        pSysInfos->aStack += "\" file=\"";
-                        char* pModName = strrchr( aModuleFileName, '\\' );
-                        pSysInfos->aStack += pModName ? (pModName+1) : aModuleFileName;
-                        pSysInfos->aStack += "\"";
-                    }
-                    else
-                    {
-                        pSysInfos->aStack += " rel=\"ERROR\"";
-                        break;
-                    }
-
-                    if ( bSymbols )
-                    {
-
-                        BYTE symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
-                        PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
-                        memset( symbolBuffer, 0, sizeof(symbolBuffer) );
-                        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
-                        pSymbol->MaxNameLength = sizeof(symbolBuffer) - sizeof(IMAGEHLP_SYMBOL) + 1;
-
-                        DWORD symDisplacement = 0;  // Displacement of the input address,
-                                                    // relative to the start of the symbol
-
-                        if ( _fpSymGetSymFromAddr( pSysInfos->hCurrentProcess, aStackFrame.AddrReturn.Offset,
-                                                &symDisplacement, pSymbol ) )
-                        {
-                            pSysInfos->aStack += " ordinal=\"";
-                            _fpUndecorateSymbolName( pSymbol->Name, buffer, 1024, UNDNAME_NAME_ONLY );
-                            pSysInfos->aStack += buffer;
-                            pSysInfos->aStack += "\"";
-                            // aStackLine += '<';
-                            // _fpUndecorateSymbolName( pSymbol->Name, buffer, 1024, UNDNAME_COMPLETE );
-                            // aStackLine += buffer;
-                            // aStackLine += '>';
-                        }
-                        else    // No symbol found.  Print out the logical address instead.
-                        {
-                            pSysInfos->aStack += " ordinal=\"???\"";
-                        }
-                    }
-
-                    pSysInfos->aStack += " />\n";
-                }
-                pSysInfos->aStack += "</Stack>";
-                _fpSymCleanup( pSysInfos->hCurrentProcess );
-            }
-            ResumeThread( pSysInfos->hCurrentThread );
-        }
-        FreeLibrary( hImageHelpLib );
-    }
+    DBG_ASSERT( nButtonCombination >= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK &&
+                nButtonCombination <= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL &&
+                nDefaultButton >= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK &&
+                nDefaultButton <= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO, "Invalid arguments!" );
+
+    int nFlags = MB_TASKMODAL | MB_SETFOREGROUND | MB_ICONWARNING | nButtonCombination;
+
+    if (nButtonCombination >= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK &&
+        nButtonCombination <= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL &&
+        nDefaultButton >= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK &&
+        nDefaultButton <= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO)
+        nFlags |= DEFAULT_BTN_MAPPING_TABLE[nButtonCombination][nDefaultButton];
+
+    //#107209 hide the splash screen if active
+    ImplSVData* pSVData = ImplGetSVData();
+    if (pSVData->mpIntroWindow)
+        pSVData->mpIntroWindow->Hide();
+
+    return MessageBoxW(
+        0,
+        rMessage.GetBuffer(),
+        rTitle.GetBuffer(),
+        nFlags);
 }
-
-#endif
Index: vcl/win/source/app/salinst.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salinst.cxx,v
retrieving revision 1.14.82.2
retrieving revision 1.21
diff -u -p -u -r1.14.82.2 -r1.21
--- vcl/win/source/app/salinst.cxx	3 Mar 2004 10:10:48 -0000	1.14.82.2
+++ vcl/win/source/app/salinst.cxx	18 May 2004 13:47:58 -0000	1.21
@@ -65,8 +65,6 @@
 #include <process.h>
 #endif
 
-#define _SV_SALINST_CXX
-
 #ifndef _VOS_MUTEX_HXX
 #include <vos/mutex.hxx>
 #endif
@@ -84,23 +82,23 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
-#ifndef _SV_SALOBJ_HXX
-#include <salobj.hxx>
+#ifndef _SV_SALOBJ_H
+#include <salobj.h>
 #endif
 #ifndef _SV_SALSYS_HXX
 #include <salsys.hxx>
 #endif
-#ifndef _SV_SALTIMER_HXX
-#include <saltimer.hxx>
+#ifndef _SV_SALTIMER_H
+#include <saltimer.h>
 #endif
-#ifndef _SV_SALSOUND_HXX
-#include <salsound.hxx>
+#ifndef _SV_SALSOUND_H
+#include <salsound.h>
 #endif
 #ifndef _SV_SALATYPE_HXX
 #include <salatype.hxx>
@@ -108,13 +106,22 @@
 #ifndef _SV_SYSDATA_HXX
 #include <sysdata.hxx>
 #endif
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
+#endif
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
+#endif
+#ifndef _SV_SALIMESTATUS_HXX
+#include <salimestatus.hxx>
+#endif
 
 #ifndef _SV_TIMER_HXX
 #include <timer.hxx>
 #endif
 
-#ifndef CS_DROPSHADOW
-#define CS_DROPSHADOW       0x00020000
+#ifndef _SV_WINCOMP_HXX
+#include <wincomp.hxx>	// CS_DROPSHADOW
 #endif
 
 // =======================================================================
@@ -148,12 +155,12 @@ LRESULT CALLBACK SalComWndProcW( HWND hW
 class SalYieldMutex : public vos::OMutex
 {
 public: // for ImplSalYield()
-    SalInstanceData*            mpInstData;
+    WinSalInstance*             mpInstData;
     ULONG                       mnCount;
     DWORD                       mnThreadId;
 
 public:
-                                SalYieldMutex( SalInstanceData* pInstData );
+                                SalYieldMutex( WinSalInstance* pInstData );
 
     virtual void SAL_CALL       acquire();
     virtual void SAL_CALL       release();
@@ -164,7 +171,7 @@ public:
 
 // -----------------------------------------------------------------------
 
-SalYieldMutex::SalYieldMutex( SalInstanceData* pInstData )
+SalYieldMutex::SalYieldMutex( WinSalInstance* pInstData )
 {
     mpInstData  = pInstData;
     mnCount     = 0;
@@ -250,7 +257,7 @@ ULONG SalYieldMutex::GetAcquireCount( UL
 
 void ImplSalYieldMutexAcquireWithWait()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( !pInst )
         return;
 
@@ -267,41 +274,41 @@ void ImplSalYieldMutexAcquireWithWait()
         BOOL bAcquire = FALSE;
         do
         {
-            if ( pInst->maInstData.mpSalYieldMutex->tryToAcquire() )
+            if ( pInst->mpSalYieldMutex->tryToAcquire() )
                 bAcquire = TRUE;
             else
             {
-                pInst->maInstData.mpSalWaitMutex->acquire();
-                if ( pInst->maInstData.mpSalYieldMutex->tryToAcquire() )
+                pInst->mpSalWaitMutex->acquire();
+                if ( pInst->mpSalYieldMutex->tryToAcquire() )
                 {
                     bAcquire = TRUE;
-                    pInst->maInstData.mpSalWaitMutex->release();
+                    pInst->mpSalWaitMutex->release();
                 }
                 else
                 {
-                    pInst->maInstData.mnYieldWaitCount++;
-                    pInst->maInstData.mpSalWaitMutex->release();
+                    pInst->mnYieldWaitCount++;
+                    pInst->mpSalWaitMutex->release();
                     MSG aTmpMsg;
-                    ImplGetMessage( &aTmpMsg, pInst->maInstData.mhComWnd, SAL_MSG_RELEASEWAITYIELD, SAL_MSG_RELEASEWAITYIELD );
-                    pInst->maInstData.mnYieldWaitCount--;
-                    if ( pInst->maInstData.mnYieldWaitCount )
-                        ImplPostMessage( pInst->maInstData.mhComWnd, SAL_MSG_RELEASEWAITYIELD, 0, 0 );
+                    ImplGetMessage( &aTmpMsg, pInst->mhComWnd, SAL_MSG_RELEASEWAITYIELD, SAL_MSG_RELEASEWAITYIELD );
+                    pInst->mnYieldWaitCount--;
+                    if ( pInst->mnYieldWaitCount )
+                        ImplPostMessage( pInst->mhComWnd, SAL_MSG_RELEASEWAITYIELD, 0, 0 );
                 }
             }
         }
         while ( !bAcquire );
     }
     else
-        pInst->maInstData.mpSalYieldMutex->acquire();
+        pInst->mpSalYieldMutex->acquire();
 }
 
 // -----------------------------------------------------------------------
 
 BOOL ImplSalYieldMutexTryToAcquire()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( pInst )
-        return pInst->maInstData.mpSalYieldMutex->tryToAcquire();
+        return pInst->mpSalYieldMutex->tryToAcquire();
     else
         return FALSE;
 }
@@ -310,20 +317,20 @@ BOOL ImplSalYieldMutexTryToAcquire()
 
 void ImplSalYieldMutexAcquire()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( pInst )
-        pInst->maInstData.mpSalYieldMutex->acquire();
+        pInst->mpSalYieldMutex->acquire();
 }
 
 // -----------------------------------------------------------------------
 
 void ImplSalYieldMutexRelease()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( pInst )
     {
         GdiFlush();
-        pInst->maInstData.mpSalYieldMutex->release();
+        pInst->mpSalYieldMutex->release();
     }
 }
 
@@ -331,11 +338,11 @@ void ImplSalYieldMutexRelease()
 
 ULONG ImplSalReleaseYieldMutex()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( !pInst )
         return 0;
 
-    SalYieldMutex*  pYieldMutex = pInst->maInstData.mpSalYieldMutex;
+    SalYieldMutex*  pYieldMutex = pInst->mpSalYieldMutex;
     ULONG           nCount = pYieldMutex->GetAcquireCount( GetCurrentThreadId() );
     ULONG           n = nCount;
     while ( n )
@@ -351,11 +358,11 @@ ULONG ImplSalReleaseYieldMutex()
 
 void ImplSalAcquireYieldMutex( ULONG nCount )
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( !pInst )
         return;
 
-    SalYieldMutex*  pYieldMutex = pInst->maInstData.mpSalYieldMutex;
+    SalYieldMutex*  pYieldMutex = pInst->mpSalYieldMutex;
     while ( nCount )
     {
         pYieldMutex->acquire();
@@ -375,7 +382,7 @@ void ImplDbgTestSolarMutex()
     {
         if ( pSalData->mpFirstInstance )
         {
-            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->maInstData.mpSalYieldMutex;
+            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->mpSalYieldMutex;
             if ( pYieldMutex->mnThreadId != nCurThreadId )
             {
                 DBG_ERROR( "SolarMutex not locked, and not thread save code in VCL is called from outside of the main thread" );
@@ -386,7 +393,7 @@ void ImplDbgTestSolarMutex()
     {
         if ( pSalData->mpFirstInstance )
         {
-            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->maInstData.mpSalYieldMutex;
+            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->mpSalYieldMutex;
             if ( pYieldMutex->mnThreadId != nCurThreadId )
             {
                 DBG_ERROR( "SolarMutex not locked in the main thread" );
@@ -413,27 +420,102 @@ static void InitSalShlData()
 }
 
 // =======================================================================
+// -------
+// SalData
+// -------
+
+SalData::SalData()
+{
+    mhInst = 0;                 // default instance handle
+    mhPrevInst = 0;             // previous instance handle
+    mnCmdShow = 0;              // default frame show style
+    mhDitherPal = 0;            // dither palette
+    mhDitherDIB = 0;            // dither memory handle
+    mpDitherDIB = 0;            // dither memory
+    mpDitherDIBData = 0;        // beginning of DIB data
+    mpDitherDiff = 0;           // Dither mapping table
+    mpDitherLow = 0;            // Dither mapping table
+    mpDitherHigh = 0;           // Dither mapping table
+    mnTimerMS = 0;              // Current Time (in MS) of the Timer
+    mnTimerOrgMS = 0;           // Current Original Time (in MS)
+    mnTimerId = 0;              // windows timer id
+    mbInTimerProc = FALSE;      // timer event is currently being dispatched
+    mhSalObjMsgHook = 0;        // hook to get interesting msg for SalObject
+    mhWantLeaveMsg = 0;         // window handle, that want a MOUSELEAVE message
+    mpMouseLeaveTimer = 0;      // Timer for MouseLeave Test
+    mpFirstInstance = 0;        // pointer of first instance
+    mpFirstFrame = 0;           // pointer of first frame
+    mpFirstObject = 0;          // pointer of first object window
+    mpFirstVD = 0;              // first VirDev
+    mpFirstPrinter = 0;         // first printing printer
+    mpHDCCache = 0;             // Cache for three DC's
+    mh50Bmp = 0;                // 50% Bitmap
+    mh50Brush = 0;              // 50% Brush
+    int i;
+    for(i=0; i<MAX_STOCKPEN; i++)
+    {
+        maStockPenColorAry[i] = 0;
+        mhStockPenAry[i] = 0;
+    }
+    for(i=0; i<MAX_STOCKBRUSH; i++)
+    {
+        maStockBrushColorAry[i] = 0;
+        mhStockBrushAry[i] = 0;
+    }
+    mnStockPenCount = 0;        // count of static pens
+    mnStockBrushCount = 0;      // count of static brushes
+    mnSalObjWantKeyEvt = 0;     // KeyEvent, welcher vom SalObj-Hook verarbeitet werden soll
+    mnCacheDCInUse = 0;         // count of CacheDC in use
+    mbObjClassInit = FALSE;     // is SALOBJECTCLASS initialised
+    mbInPalChange = FALSE;      // is in WM_QUERYNEWPALETTE
+    mnAppThreadId = 0;          // Id from Applikation-Thread
+    mbScrSvrEnabled = FALSE;    // ScreenSaver enabled
+    mnSageStatus = 0;           // status of Sage-DLL (DISABLE_AGENT == nicht vorhanden)
+    mhSageInst = 0;             // instance handle for the Sage-DLL
+    mpSageEnableProc = 0;       // funktion to deactivate the system agent
+    mpFirstIcon = 0;            // icon cache, points to first icon, NULL if none
+    mpTempFontItem = 0;
+    mbThemeChanged = FALSE;     // true if visual theme was changed: throw away theme handles
+
+    SetSalData( this );
+    initNWF();
+}
+
+SalData::~SalData()
+{
+    deInitNWF();
+    SetSalData( NULL );
+}
 
 void InitSalData()
 {
     SalData* pSalData = new SalData;
-    memset( pSalData, 0, sizeof( SalData ) );
-    SetSalData( pSalData );
     CoInitialize(0);
 }
 
-// -----------------------------------------------------------------------
 
 void DeInitSalData()
 {
     CoUninitialize();
     SalData* pSalData = GetSalData();
     delete pSalData;
-    SetSalData( NULL );
 }
 
+// -----------------------------------------------------------------------
+
 void InitSalMain()
 {
+    // remember data, copied from WinMain
+    SalData* pData = GetAppSalData();
+    if ( pData )    // Im AppServer NULL
+    {
+        STARTUPINFO aSI;
+        aSI.cb = sizeof( aSI );
+        GetStartupInfo( &aSI );
+        pData->mhInst                   = GetModuleHandle( NULL );
+        pData->mhPrevInst               = NULL;
+        pData->mnCmdShow                = aSI.wShowWindow;
+    }
 }
 
 void DeInitSalMain()
@@ -442,27 +524,16 @@ void DeInitSalMain()
 
 // -----------------------------------------------------------------------
 
-void SetFilterCallback( void* pCallback, void* pInst )
-{
-    SalData* pSalData = GetSalData();
-
-    pSalData->mpFirstInstance->maInstData.mpFilterCallback = pCallback;
-    pSalData->mpFirstInstance->maInstData.mpFilterInst = pInst;
-}
-
-// -----------------------------------------------------------------------
-
 SalInstance* CreateSalInstance()
 {
     SalData* pSalData = GetSalData();
 
     // determine the windows version
-    aSalShlData.mbW40 = 0;
     aSalShlData.mbWNT = 0;
     aSalShlData.mbWXP = 0;
     WORD nVer = (WORD)GetVersion();
     aSalShlData.mnVersion = (((WORD)LOBYTE(nVer)) * 100) + HIBYTE(nVer);
-    if ( aSalShlData.mnVersion >= W95_VERSION )
+    if ( aSalShlData.mnVersion >= 400 )
         aSalShlData.mbW40 = 1;
     OSVERSIONINFO aVerInfo;
     aVerInfo.dwOSVersionInfoSize = sizeof( aVerInfo );
@@ -570,15 +641,15 @@ SalInstance* CreateSalInstance()
     if ( !hComWnd )
         return NULL;
 
-    SalInstance* pInst = new SalInstance;
+    WinSalInstance* pInst = new WinSalInstance;
 
     // init shl data
     InitSalShlData();
 
     // init instance (only one instance in this version !!!)
     pSalData->mpFirstInstance   = pInst;
-    pInst->maInstData.mhInst    = pSalData->mhInst;
-    pInst->maInstData.mhComWnd  = hComWnd;
+    pInst->mhInst    = pSalData->mhInst;
+    pInst->mhComWnd  = hComWnd;
 
     // init static GDI Data
     ImplInitSalGDI();
@@ -605,44 +676,43 @@ void DestroySalInstance( SalInstance* pI
 
 // -----------------------------------------------------------------------
 
-SalInstance::SalInstance()
+WinSalInstance::WinSalInstance()
 {
-    maInstData.mhComWnd                 = 0;
-    maInstData.mpFilterCallback         = NULL;
-    maInstData.mpFilterInst             = NULL;
-    maInstData.mpSalYieldMutex          = new SalYieldMutex( &maInstData );
-    maInstData.mpSalWaitMutex           = new vos::OMutex;
-    maInstData.mnYieldWaitCount         = 0;
-    maInstData.mpSalYieldMutex->acquire();
+    mhComWnd                 = 0;
+    mpSalYieldMutex          = new SalYieldMutex( this );
+    mpSalWaitMutex           = new vos::OMutex;
+    mnYieldWaitCount         = 0;
+    mpSalYieldMutex->acquire();
 }
 
 // -----------------------------------------------------------------------
 
-SalInstance::~SalInstance()
+WinSalInstance::~WinSalInstance()
 {
-    maInstData.mpSalYieldMutex->release();
-    delete maInstData.mpSalYieldMutex;
-    delete maInstData.mpSalWaitMutex;
-    DestroyWindow( maInstData.mhComWnd );
+    WinSalOpenGL::Release();
+    mpSalYieldMutex->release();
+    delete mpSalYieldMutex;
+    delete mpSalWaitMutex;
+    DestroyWindow( mhComWnd );
 }
 
 // -----------------------------------------------------------------------
 
-vos::IMutex* SalInstance::GetYieldMutex()
+vos::IMutex* WinSalInstance::GetYieldMutex()
 {
-    return maInstData.mpSalYieldMutex;
+    return mpSalYieldMutex;
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalInstance::ReleaseYieldMutex()
+ULONG WinSalInstance::ReleaseYieldMutex()
 {
     return ImplSalReleaseYieldMutex();
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::AcquireYieldMutex( ULONG nCount )
+void WinSalInstance::AcquireYieldMutex( ULONG nCount )
 {
     ImplSalAcquireYieldMutex( nCount );
 }
@@ -668,7 +738,7 @@ void ImplSalYield( BOOL bWait )
 {
     MSG aMsg;
 
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( bWait )
     {
         if ( ImplGetMessage( &aMsg, 0, 0, 0 ) )
@@ -689,9 +759,9 @@ void ImplSalYield( BOOL bWait )
 
 // -----------------------------------------------------------------------
 
-void SalInstance::Yield( BOOL bWait )
+void WinSalInstance::Yield( BOOL bWait )
 {
-    SalYieldMutex*  pYieldMutex = maInstData.mpSalYieldMutex;
+    SalYieldMutex*  pYieldMutex = mpSalYieldMutex;
     SalData*        pSalData = GetSalData();
     DWORD           nCurThreadId = GetCurrentThreadId();
     ULONG           nCount = pYieldMutex->GetAcquireCount( nCurThreadId );
@@ -716,7 +786,7 @@ void SalInstance::Yield( BOOL bWait )
         if( ImplGetSVData()->maAppData.mnModalMode )
             Sleep(1);
         else
-            ImplSendMessage( maInstData.mhComWnd, SAL_MSG_THREADYIELD, (WPARAM)bWait, (LPARAM)0 );
+            ImplSendMessage( mhComWnd, SAL_MSG_THREADYIELD, (WPARAM)bWait, (LPARAM)0 );
 
         n = nCount;
         while ( n )
@@ -760,8 +830,8 @@ LRESULT CALLBACK SalComWndProc( HWND hWn
         // us again, because in the other case we wait forever.
         case SAL_MSG_RELEASEWAITYIELD:
             {
-            SalInstance* pInst = GetSalData()->mpFirstInstance;
-            if ( pInst && pInst->maInstData.mnYieldWaitCount )
+            WinSalInstance* pInst = GetSalData()->mpFirstInstance;
+            if ( pInst && pInst->mnYieldWaitCount )
                 ImplPostMessage( hWnd, SAL_MSG_RELEASEWAITYIELD, wParam, lParam );
             }
             rDef = FALSE;
@@ -787,7 +857,7 @@ LRESULT CALLBACK SalComWndProc( HWND hWn
             rDef = FALSE;
             break;
         case SAL_MSG_CREATEOBJECT:
-            nRet = (LRESULT)ImplSalCreateObject( GetSalData()->mpFirstInstance, (SalFrame*)lParam );
+            nRet = (LRESULT)ImplSalCreateObject( GetSalData()->mpFirstInstance, (WinSalFrame*)lParam );
             rDef = FALSE;
             break;
         case SAL_MSG_DESTROYOBJECT:
@@ -795,11 +865,11 @@ LRESULT CALLBACK SalComWndProc( HWND hWn
             rDef = FALSE;
             break;
         case SAL_MSG_CREATESOUND:
-            nRet = ((SalSound*)lParam)->ImplCreate();
+            nRet = ((WinSalSound*)lParam)->ImplCreate();
             rDef = FALSE;
             break;
         case SAL_MSG_DESTROYSOUND:
-            ((SalSound*)lParam)->ImplDestroy();
+            ((WinSalSound*)lParam)->ImplDestroy();
             rDef = FALSE;
             break;
         case SAL_MSG_GETDC:
@@ -865,7 +935,7 @@ BOOL ImplVerifyTimerMessage( const MSG& 
         return TRUE;    // arbitrary messages
 }
 
-BOOL SalInstance::AnyInput( USHORT nType )
+bool WinSalInstance::AnyInput( USHORT nType )
 {
     MSG aMsg;
 
@@ -875,7 +945,7 @@ BOOL SalInstance::AnyInput( USHORT nType
         // Thus we have to check for user input messages first to be able to detect them between the timer messages.
         // Otherwise we might not detect user input and the system will become unresponsive.
         if( AnyInput( INPUT_MOUSE ) || AnyInput( INPUT_KEYBOARD ) || AnyInput( INPUT_PAINT ) )
-            return TRUE;
+            return true;
         if ( ImplPeekMessage( &aMsg, 0, 0, 0, PM_NOREMOVE | PM_NOYIELD ) )
             return ImplVerifyTimerMessage( aMsg );
     }
@@ -886,7 +956,7 @@ BOOL SalInstance::AnyInput( USHORT nType
             // Test for mouse input
             if ( ImplPeekMessage( &aMsg, 0, WM_MOUSEFIRST, WM_MOUSELAST,
                                   PM_NOREMOVE | PM_NOYIELD ) )
-                return TRUE;
+                return true;
         }
 
         if ( nType & INPUT_KEYBOARD )
@@ -898,9 +968,9 @@ BOOL SalInstance::AnyInput( USHORT nType
                 if ( (aMsg.wParam == VK_SHIFT)   ||
                      (aMsg.wParam == VK_CONTROL) ||
                      (aMsg.wParam == VK_MENU) )
-                    return FALSE;
+                    return false;
                 else
-                    return TRUE;
+                    return true;
             }
         }
 
@@ -909,7 +979,7 @@ BOOL SalInstance::AnyInput( USHORT nType
             // Test for paint input
             if ( ImplPeekMessage( &aMsg, 0, WM_PAINT, WM_PAINT,
                                   PM_NOREMOVE | PM_NOYIELD ) )
-                return TRUE;
+                return true;
         }
 
         if ( nType & INPUT_TIMER )
@@ -943,9 +1013,9 @@ void SalTimer::Start( ULONG nMS )
     if ( pSalData->mpFirstInstance )
     {
         if ( pSalData->mnAppThreadId != GetCurrentThreadId() )
-            ImplPostMessage( pSalData->mpFirstInstance->maInstData.mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+            ImplPostMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
         else
-            ImplSendMessage( pSalData->mpFirstInstance->maInstData.mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+            ImplSendMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
     }
     else
         ImplSalStartTimer( nMS, FALSE );
@@ -953,71 +1023,110 @@ void SalTimer::Start( ULONG nMS )
 
 // -----------------------------------------------------------------------
 
-SalFrame* SalInstance::CreateChildFrame( SystemParentData* pSystemParentData, ULONG nSalFrameStyle )
+SalFrame* WinSalInstance::CreateChildFrame( SystemParentData* pSystemParentData, ULONG nSalFrameStyle )
 {
     // Um auf Main-Thread umzuschalten
-    return (SalFrame*)ImplSendMessage( maInstData.mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)pSystemParentData->hWnd );
+    return (SalFrame*)ImplSendMessage( mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)pSystemParentData->hWnd );
 }
 
 // -----------------------------------------------------------------------
 
-SalFrame* SalInstance::CreateFrame( SalFrame* pParent, ULONG nSalFrameStyle )
+SalFrame* WinSalInstance::CreateFrame( SalFrame* pParent, ULONG nSalFrameStyle )
 {
     // Um auf Main-Thread umzuschalten
     HWND hWndParent;
     if ( pParent )
-        hWndParent = pParent->maFrameData.mhWnd;
+        hWndParent = static_cast<WinSalFrame*>(pParent)->mhWnd;
     else
         hWndParent = 0;
-    return (SalFrame*)ImplSendMessage( maInstData.mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)hWndParent );
+    return (SalFrame*)ImplSendMessage( mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)hWndParent );
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyFrame( SalFrame* pFrame )
+void WinSalInstance::DestroyFrame( SalFrame* pFrame )
 {
-    ImplSendMessage( maInstData.mhComWnd, SAL_MSG_DESTROYFRAME, 0, (LPARAM)pFrame );
+    ImplSendMessage( mhComWnd, SAL_MSG_DESTROYFRAME, 0, (LPARAM)pFrame );
 }
 
 // -----------------------------------------------------------------------
 
-SalObject* SalInstance::CreateObject( SalFrame* pParent )
+SalObject* WinSalInstance::CreateObject( SalFrame* pParent )
 {
     // Um auf Main-Thread umzuschalten
-    return (SalObject*)ImplSendMessage( maInstData.mhComWnd, SAL_MSG_CREATEOBJECT, 0, (LPARAM)pParent );
+    return (SalObject*)ImplSendMessage( mhComWnd, SAL_MSG_CREATEOBJECT, 0, (LPARAM)static_cast<WinSalFrame*>(pParent) );
+}
+
+// -----------------------------------------------------------------------
+
+void WinSalInstance::DestroyObject( SalObject* pObject )
+{
+    ImplSendMessage( mhComWnd, SAL_MSG_DESTROYOBJECT, 0, (LPARAM)pObject );
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyObject( SalObject* pObject )
+void* WinSalInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
 {
-    ImplSendMessage( maInstData.mhComWnd, SAL_MSG_DESTROYOBJECT, 0, (LPARAM)pObject );
+    rReturnedBytes  = 1;
+    rReturnedType   = AsciiCString;
+    return "";
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::SetEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int) )
+SalTimer* WinSalInstance::CreateSalTimer()
 {
+    return new WinSalTimer();
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::SetErrorEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int) )
+SalSound* WinSalInstance::CreateSalSound()
 {
+    return new WinSalSound();
 }
 
 // -----------------------------------------------------------------------
 
-void* SalInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
+SalOpenGL* WinSalInstance::CreateSalOpenGL( SalGraphics* pGraphics )
 {
-    rReturnedBytes  = 1;
-    rReturnedType   = AsciiCString;
-    return "";
+    return new WinSalOpenGL( pGraphics );
+}
+
+// -----------------------------------------------------------------------
+
+SalBitmap* WinSalInstance::CreateSalBitmap()
+{
+    return new WinSalBitmap();
+}
+
+class WinImeStatus : public SalI18NImeStatus
+{
+  public:
+    WinImeStatus() {}
+    virtual ~WinImeStatus() {}
+    
+    // asks whether there is a status window available
+    // to toggle into menubar
+    virtual bool canToggle() { return false; }
+    virtual void toggle() {}
+};
+
+SalI18NImeStatus* WinSalInstance::CreateI18NImeStatus()
+{
+    return new WinImeStatus();
 }
 
 // -----------------------------------------------------------------------
 
-SalSession* SalInstance::CreateSalSession()
+const ::rtl::OUString& SalGetDesktopEnvironment()
+{
+    static ::rtl::OUString aDesktopEnvironment( RTL_CONSTASCII_USTRINGPARAM( "Windows" ) );
+    return aDesktopEnvironment;
+}
+
+SalSession* WinSalInstance::CreateSalSession()
 {
     return NULL;
 }
Index: vcl/win/source/app/salmain.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salmain.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/win/source/app/salmain.cxx	22 Feb 2001 15:40:01 -0000	1.2
+++ vcl/win/source/app/salmain.cxx	6 Jan 2004 14:52:21 -0000	1.3
@@ -62,8 +62,6 @@
 #ifndef _SVWIN_H
 #include <tools/svwin.h>
 #endif
-
-#define _SV_SALMAIN_CXX
 
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
Index: vcl/win/source/app/salshl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salshl.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/win/source/app/salshl.cxx	9 Nov 2001 14:33:27 -0000	1.3
+++ vcl/win/source/app/salshl.cxx	6 Jan 2004 14:52:42 -0000	1.4
@@ -63,8 +63,6 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALSHL_CXX
-
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
@@ -79,34 +77,6 @@ SalShlData aSalShlData;
 
 // =======================================================================
 
-#ifdef WIN
-
-extern "C"
-{
-
-int CALLBACK LibMain( HINSTANCE hInst, WORD, WORD nHeap, LPSTR )
-{
-	if ( nHeap )
-		UnlockData( 0 );
-
-	aSalShlData.mhInst = hInst;
-
-	return 1;
-}
-
-// -----------------------------------------------------------------------
-
-int CALLBACK WEP( int )
-{
-	return 1;
-}
-
-}
-
-#endif
-
-// =======================================================================
-
 #ifdef WNT
 
 extern "C"
Index: vcl/win/source/app/salsound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salsound.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/app/salsound.cxx	15 Nov 2000 11:48:58 -0000	1.2
+++ vcl/win/source/app/salsound.cxx	6 Jan 2004 14:53:09 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALSOUND_CXX
-
 #define INCLUDE_MMSYSTEM
 
 // ------------
@@ -74,11 +72,11 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALSOUND_HXX
-#include <salsound.hxx>
+#ifndef _SV_SALSOUND_H
+#include <salsound.h>
 #endif
 
 // ---------
@@ -96,21 +94,17 @@
 // - Fnc cast -
 // ------------
 
-#ifdef WIN
-#define __MCI_CALL _far _pascal
-#else
 #define __MCI_CALL __stdcall
-#endif
 
-#define MCIFNC ((DWORD( __MCI_CALL * )( UINT, UINT, DWORD, DWORD )) SalSound::mpMCIFnc)
+#define MCIFNC ((DWORD( __MCI_CALL * )( UINT, UINT, DWORD, DWORD )) WinSalSound::mpMCIFnc)
 
 // -----------------
 // - Statics init. -
 // -----------------
 
-HINSTANCE	SalSound::mhMCILib = 0;
-ULONG		SalSound::mnSoundState = SOUND_STATE_UNLOADED;
-void*		SalSound::mpMCIFnc = NULL;
+HINSTANCE	WinSalSound::mhMCILib = 0;
+ULONG		WinSalSound::mnSoundState = SOUND_STATE_UNLOADED;
+void*		WinSalSound::mpMCIFnc = NULL;
 
 // -------------------
 // - Window-Callback -
@@ -140,7 +134,7 @@ void ImplSalHandleMCINotify( HWND hWnd, 
 	}
 
 	if ( bNotify )
-		((SalSound*)GetWindowLong( hWnd, 0 ) )->ImplNotify( eNotification, 0 );
+		((WinSalSound*)GetWindowLong( hWnd, 0 ) )->ImplNotify( eNotification, 0 );
 }
 
 LRESULT CALLBACK SalSoundWndProcA( HWND hWnd, UINT nMsg, WPARAM nPar1, LPARAM nPar2 )
@@ -161,8 +155,7 @@ LRESULT CALLBACK SalSoundWndProcW( HWND 
 // - SalSound -
 // ------------
 
-SalSound::SalSound() :
-	mpProc			( NULL ),
+WinSalSound::WinSalSound() :
 	mhSoundWnd		( 0 ),
 	mnDeviceId		( 0 ),
 	mbLoop			( FALSE ),
@@ -172,7 +165,7 @@ SalSound::SalSound() :
 
 // ------------------------------------------------------------------------
 
-SalSound::~SalSound()
+WinSalSound::~WinSalSound()
 {
 	Stop();
 
@@ -187,10 +180,10 @@ SalSound::~SalSound()
 	// Call Destroy in the main thread, because Create is also called in
 	// the main thread and if we don't call this also in the main thread
 	// windows doesn't destroy the window
-	SalInstance* pInst = GetSalData()->mpFirstInstance;
+	WinSalInstance* pInst = GetSalData()->mpFirstInstance;
 	if ( pInst )
 	{
-		ImplSendMessage( pInst->maInstData.mhComWnd, SAL_MSG_DESTROYSOUND,
+		ImplSendMessage( pInst->mhComWnd, SAL_MSG_DESTROYSOUND,
 						 0, (LPARAM)this );
 	}
 	else
@@ -199,7 +192,7 @@ SalSound::~SalSound()
 
 // ------------------------------------------------------------------------
 
-void SalSound::ImplSetError( DWORD nMciErr )
+void WinSalSound::ImplSetError( DWORD nMciErr )
 {
 	struct aMapper { DWORD nMci; ULONG nSv; };
 
@@ -240,29 +233,28 @@ void SalSound::ImplSetError( DWORD nMciE
 
 // ------------------------------------------------------------------------
 
-void SalSound::ImplNotify( SoundNotification eNotification, ULONG nError )
+void WinSalSound::ImplNotify( SoundNotification eNotification, ULONG nError )
 {
 	if ( mbLoop && (SOUND_NOTIFY_SUCCESS == eNotification) && !nError )
 		Play( mnStartTime, mnPlayLen, TRUE );
 
-	if ( mpProc && mpInst )
-		mpProc( mpInst, eNotification, nError );
+    CallNotifyProc( eNotification, nError );
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalSound::ImplCreate()
+bool WinSalSound::ImplCreate()
 {
 	SalData*	pData = GetSalData();
-	BOOL		bRet = FALSE;
+	bool		bRet = FALSE;
 
-	if ( SOUND_STATE_UNLOADED == SalSound::mnSoundState )
+	if ( SOUND_STATE_UNLOADED == WinSalSound::mnSoundState )
 	{
 		// load library and init fncpointer
 		if ( aSalShlData.mbWNT )
 		{
-			if ( (SalSound::mhMCILib = LoadLibraryW( SOUND_LIBNAMEW )) != 0 &&
-				 (SalSound::mpMCIFnc = (void*)GetProcAddress( SalSound::mhMCILib, SOUND_PROCNAMEW )) != 0 )
+			if ( (WinSalSound::mhMCILib = LoadLibraryW( SOUND_LIBNAMEW )) != 0 &&
+				 (WinSalSound::mpMCIFnc = (void*)GetProcAddress( WinSalSound::mhMCILib, SOUND_PROCNAMEW )) != 0 )
 			{
 				WNDCLASSEXW aWndClass;
 
@@ -274,15 +266,15 @@ BOOL SalSound::ImplCreate()
 				aWndClass.lpszClassName = SOUND_WINDOWCLASSW;
 				if ( RegisterClassExW( &aWndClass ) )
 				{
-					SalSound::mnSoundState = SOUND_STATE_VALID;
+					WinSalSound::mnSoundState = SOUND_STATE_VALID;
 					bRet = TRUE;
 				}
 			}
 		}
 		else
 		{
-			if ( (SalSound::mhMCILib = LoadLibraryA( SOUND_LIBNAMEA )) != 0 &&
-				 (SalSound::mpMCIFnc = (void*)GetProcAddress( SalSound::mhMCILib, SOUND_PROCNAMEA )) != 0 )
+			if ( (WinSalSound::mhMCILib = LoadLibraryA( SOUND_LIBNAMEA )) != 0 &&
+				 (WinSalSound::mpMCIFnc = (void*)GetProcAddress( WinSalSound::mhMCILib, SOUND_PROCNAMEA )) != 0 )
 			{
 				WNDCLASSEXA aWndClass;
 
@@ -294,7 +286,7 @@ BOOL SalSound::ImplCreate()
 				aWndClass.lpszClassName = SOUND_WINDOWCLASSA;
 				if ( RegisterClassExA( &aWndClass ) )
 				{
-					SalSound::mnSoundState = SOUND_STATE_VALID;
+					WinSalSound::mnSoundState = SOUND_STATE_VALID;
 					bRet = TRUE;
 				}
 			}
@@ -302,14 +294,14 @@ BOOL SalSound::ImplCreate()
 
 		if ( !bRet )
 		{
-			if ( SalSound::mhMCILib )
-				FreeLibrary( SalSound::mhMCILib );
+			if ( WinSalSound::mhMCILib )
+				FreeLibrary( WinSalSound::mhMCILib );
 
-			SalSound::mnSoundState = SOUND_STATE_INVALID;
+			WinSalSound::mnSoundState = SOUND_STATE_INVALID;
 			ImplNotify( SOUND_NOTIFY_ERROR, SOUNDERR_CANNOT_LOAD_DRIVER );
 		}
 	}
-	else if ( SOUND_STATE_VALID == SalSound::mnSoundState )
+	else if ( SOUND_STATE_VALID == WinSalSound::mnSoundState )
 		bRet = TRUE;
 
 	if ( bRet )
@@ -335,14 +327,14 @@ BOOL SalSound::ImplCreate()
 
 // ------------------------------------------------------------------------
 
-BOOL SalSound::Create()
+bool WinSalSound::IsValid()
 {
 	// Call Create in the main thread, because in the other case the
 	// Sound stop, if the calling thread dies.
-	SalInstance* pInst = GetSalData()->mpFirstInstance;
+	WinSalInstance* pInst = GetSalData()->mpFirstInstance;
 	if ( pInst )
 	{
-		return (BOOL)ImplSendMessage( pInst->maInstData.mhComWnd, SAL_MSG_CREATESOUND,
+		return (BOOL)ImplSendMessage( pInst->mhComWnd, SAL_MSG_CREATESOUND,
 									  0, (LPARAM)this );
 	}
 	else
@@ -351,7 +343,7 @@ BOOL SalSound::Create()
 
 // ------------------------------------------------------------------------
 
-void SalSound::ImplDestroy()
+void WinSalSound::ImplDestroy()
 {
 	if ( mhSoundWnd )
 		DestroyWindow( mhSoundWnd );
@@ -360,18 +352,18 @@ void SalSound::ImplDestroy()
 
 // ------------------------------------------------------------------------
 
-void SalSound::Release()
+void WinSalSound::Release()
 {
 	// free library
-	if ( SalSound::mhMCILib )
-		FreeLibrary( SalSound::mhMCILib );
+	if ( WinSalSound::mhMCILib )
+		FreeLibrary( WinSalSound::mhMCILib );
 
-	SalSound::mnSoundState = SOUND_STATE_UNLOADED;
+	WinSalSound::mnSoundState = SOUND_STATE_UNLOADED;
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalSound::Init( SalFrame* pFrame, const XubString& rSoundName, ULONG& rSoundLen )
+bool WinSalSound::Init( const XubString& rSoundName, ULONG& rSoundLen )
 {
 	DWORD nMciErr = 0;
 	rSoundLen = 0;
@@ -438,22 +430,12 @@ BOOL SalSound::Init( SalFrame* pFrame, c
 	if ( nMciErr )
 		ImplSetError( nMciErr );
 
-	return (nMciErr ? FALSE : TRUE);
-}
-
-// ------------------------------------------------------------------------
-
-BOOL SalSound::Init( SalFrame* pFrame, const BYTE* pSound, ULONG nDataLen, ULONG& rSoundLen )
-{
-	rSoundLen = 0UL;
-	ImplSetError( MCIERR_FILE_NOT_FOUND );
-
-	return FALSE;
+	return (nMciErr ? false : true);
 }
 
 // ------------------------------------------------------------------------
 
-void SalSound::Play( ULONG nStartTime, ULONG nPlayLen, BOOL bLoop )
+void WinSalSound::Play( ULONG nStartTime, ULONG nPlayLen, bool bLoop )
 {
 	if ( mnDeviceId )
 	{
@@ -470,7 +452,7 @@ void SalSound::Play( ULONG nStartTime, U
 		mnStartTime = nStartTime;
 		mnPlayLen = nPlayLen;
 		mbLoop = bLoop;
-		mbPaused = FALSE;
+		mbPaused = false;
 
 		if( !nMciErr )
 		{
@@ -506,26 +488,54 @@ void SalSound::Play( ULONG nStartTime, U
 
 // ------------------------------------------------------------------------
 
-void SalSound::Stop()
+void WinSalSound::Stop()
 {
 	if ( mnDeviceId )
 	{
 		MCI_GENERIC_PARMS aGenericParams;
 		aGenericParams.dwCallback = (DWORD)mhSoundWnd;
-		mbLoop = mbPaused = FALSE;
+		mbLoop = mbPaused = false;
 		MCIFNC( mnDeviceId, MCI_STOP, MCI_WAIT, (DWORD) &aGenericParams );
 	}
 }
 
 // ------------------------------------------------------------------------
 
-void SalSound::Pause()
+void WinSalSound::Pause()
 {
 	if ( mnDeviceId )
 	{
 		MCI_GENERIC_PARMS aGenericParams;
 		aGenericParams.dwCallback = (DWORD)mhSoundWnd;
-		mbPaused = TRUE;
+		mbPaused = true;
 		MCIFNC( mnDeviceId, MCI_PAUSE, MCI_WAIT, (DWORD) &aGenericParams );
 	}
+}
+
+// ------------------------------------------------------------------------
+
+void WinSalSound::Continue()
+{
+    Play( 0, 0, mbLoop );
+}
+
+// ------------------------------------------------------------------------
+
+bool WinSalSound::IsLoopMode() const
+{
+    return mbLoop;
+}
+
+// ------------------------------------------------------------------------
+
+bool WinSalSound::IsPlaying() const
+{
+    return !mbPaused;
+}
+
+// ------------------------------------------------------------------------
+
+bool WinSalSound::IsPaused() const
+{
+    return mbPaused;
 }
Index: vcl/win/source/app/saltimer.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/saltimer.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/app/saltimer.cxx	28 May 2003 12:35:28 -0000	1.2
+++ vcl/win/source/app/saltimer.cxx	6 Jan 2004 14:53:36 -0000	1.4
@@ -63,13 +63,14 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALTIMER_CXX
-
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALTIMER_HXX
-#include <saltimer.hxx>
+#ifndef _SV_SALTIMER_H
+#include <saltimer.h>
+#endif
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 // =======================================================================
@@ -102,7 +103,26 @@ void ImplSalStartTimer( ULONG nMS, BOOL 
 
 // -----------------------------------------------------------------------
 
-void SalTimer::Stop()
+WinSalTimer::~WinSalTimer()
+{
+}
+
+void WinSalTimer::Start( ULONG nMS )
+{
+    // switch to main thread
+    SalData* pSalData = GetSalData();
+    if ( pSalData->mpFirstInstance )
+    {
+        if ( pSalData->mnAppThreadId != GetCurrentThreadId() )
+            ImplPostMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+        else
+            ImplSendMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+    }
+    else
+        ImplSalStartTimer( nMS, FALSE );
+}
+
+void WinSalTimer::Stop()
 {
 	SalData* pSalData = GetSalData();
 
@@ -116,29 +136,22 @@ void SalTimer::Stop()
 
 // -----------------------------------------------------------------------
 
-void SalTimer::SetCallback( SALTIMERPROC pProc )
-{
-	SalData* pSalData = GetSalData();
-	pSalData->mpTimerProc = pProc;
-}
-
-// -----------------------------------------------------------------------
-
 void CALLBACK SalTimerProc( HWND, UINT, UINT, DWORD )
 {
 	SalData* pSalData = GetSalData();
+    ImplSVData* pSVData = ImplGetSVData();
 
 	// Test for MouseLeave
 	SalTestMouseLeave();
 
-	if ( pSalData->mpTimerProc )
+	if ( pSVData->mpSalTimer )
 	{
 		// Try to aquire the mutex. If we don't get the mutex then we
 		// try this a short time later again.
 		if ( ImplSalYieldMutexTryToAcquire() )
 		{
             pSalData->mbInTimerProc = TRUE;
-			pSalData->mpTimerProc();
+			pSVData->mpSalTimer->CallCallback();
             pSalData->mbInTimerProc = FALSE;
 			ImplSalYieldMutexRelease();
 
