Index: vcl/unx/gtk/app/gtkdata.cxx
===================================================================
RCS file: vcl/unx/gtk/app/gtkdata.cxx
diff -N vcl/unx/gtk/app/gtkdata.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/gtkdata.cxx	2 Jun 2004 14:54:21 -0000	1.7
@@ -0,0 +1,790 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALDATA_CXX
+
+// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <errno.h>
+#include <poll.h>
+#ifdef FREEBSD
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#endif
+
+#ifndef _VCL_GTKDATA_HXX
+#include <plugins/gtk/gtkdata.hxx>
+#endif
+#ifndef _VCL_GTKINST_HXX
+#include <plugins/gtk/gtkinst.hxx>
+#endif
+#ifndef _VCL_GTKFRAME_HXX
+#include <plugins/gtk/gtkframe.hxx>
+#endif
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+#ifndef _OSL_PROCESS_H_
+#include <osl/process.h>
+#endif
+
+#include <tools/debug.hxx>
+
+#ifndef _SAL_I18N_INPUTMETHOD_HXX
+#include "i18n_im.hxx"
+#endif
+#ifndef _SAL_I18N_XKBDEXTENSION_HXX
+#include "i18n_xkb.hxx"
+#endif
+
+#include "../../unx/source/inc/salcursors.h"
+
+using namespace rtl;
+
+/***************************************************************************
+ * class GtkDisplay                                                        *
+ ***************************************************************************/
+
+GtkSalDisplay::GtkSalDisplay( GdkDisplay* pDisplay, Visual* pVis, Colormap aCol ) 
+            : m_pGdkDisplay( pDisplay ),
+              SalDisplay( gdk_x11_display_get_xdisplay( pDisplay ), aCol )
+{
+	for(int i = 0; i < POINTER_COUNT; i++)
+		m_aCursors[ i ] = NULL;
+	Init ( aCol, pVis );
+}
+
+GtkSalDisplay::~GtkSalDisplay()
+{
+    doDestruct();
+
+	for(int i = 0; i < POINTER_COUNT; i++)
+		if( m_aCursors[ i ] )
+			gdk_cursor_unref( m_aCursors[ i ] );
+
+    pDisp_ = NULL;
+}
+
+void GtkSalDisplay::deregisterFrame( SalFrame* pFrame )
+{
+	if( m_pCapture == pFrame )
+	{
+		static_cast<GtkSalFrame*>(m_pCapture)->grabPointer( FALSE );
+		m_pCapture = NULL;
+	}
+    SalDisplay::deregisterFrame( pFrame );
+}
+
+GdkFilterReturn GtkSalDisplay::filterGdkEvent( GdkXEvent* sys_event,
+                                               GdkEvent* event,
+                                               gpointer data )
+{
+    GTK_YIELD_GRAB();
+    
+    GdkFilterReturn aFilterReturn = GDK_FILTER_CONTINUE;
+    
+	XEvent *pEvent = (XEvent *)sys_event;
+	GtkSalDisplay *pDisplay = (GtkSalDisplay *)data;
+
+    if (pDisplay->GetDisplay() == pEvent->xany.display )
+    {
+        // let's see if one of our frames wants to swallow these events
+        // get the frame
+        for( std::list< SalFrame* >::const_iterator it = pDisplay->m_aFrames.begin();
+                 it != pDisplay->m_aFrames.end(); ++it )
+        {
+            GtkSalFrame* pFrame = static_cast<GtkSalFrame*>(*it);
+            if( pFrame->GetSystemData()->aWindow == pEvent->xany.window ||
+                ( pFrame->getForeignParent() && GDK_WINDOW_XWINDOW(pFrame->getForeignParent()) == pEvent->xany.window ) ||
+                ( pFrame->getForeignTopLevel() && GDK_WINDOW_XWINDOW(pFrame->getForeignTopLevel()) == pEvent->xany.window )
+                )
+            {
+                if( ! pFrame->Dispatch( pEvent ) )
+                    aFilterReturn = GDK_FILTER_REMOVE;
+                break;
+            }
+        }
+    }
+
+    return aFilterReturn;
+}
+
+long GtkSalDisplay::Dispatch( XEvent* pEvent )
+{
+    if( GetDisplay() == pEvent->xany.display )
+    {
+        // let's see if one of our frames wants to swallow these events
+        // get the child frame
+        for( std::list< SalFrame* >::const_iterator it = m_aFrames.begin();
+             it != m_aFrames.end(); ++it )
+        {
+            if( (*it)->GetSystemData()->aWindow == pEvent->xany.window )
+                return static_cast<GtkSalFrame*>(*it)->Dispatch( pEvent );
+        }
+    }
+
+    return GDK_FILTER_CONTINUE;
+}
+
+GdkCursor* GtkSalDisplay::getFromXPM( const char *pBitmap,
+									  const char *pMask,
+									  int nWidth, int nHeight,
+									  int nXHot, int nYHot )
+{
+	GdkScreen *pScreen = gdk_display_get_default_screen( m_pGdkDisplay );
+	GdkDrawable *pDrawable = GDK_DRAWABLE( gdk_screen_get_root_window (pScreen) );
+	GdkBitmap *pBitmapPix = gdk_bitmap_create_from_data
+			( pDrawable, pBitmap, nWidth, nHeight );
+	GdkBitmap *pMaskPix = gdk_bitmap_create_from_data
+			( pDrawable, pMask, nWidth, nHeight );
+	GdkColormap *pColormap = gdk_drawable_get_colormap( pDrawable );
+
+	GdkColor aWhite = { 0, 0xffff, 0xffff, 0xffff };
+	GdkColor aBlack = { 0, 0, 0, 0 };
+
+	gdk_colormap_alloc_color( pColormap, &aBlack, FALSE, TRUE);
+	gdk_colormap_alloc_color( pColormap, &aWhite, FALSE, TRUE);
+
+	return gdk_cursor_new_from_pixmap
+			( pBitmapPix, pMaskPix,
+			  &aBlack, &aWhite, nXHot, nYHot);
+}
+
+#define MAKE_CURSOR( vcl_name, name ) \
+	case vcl_name: \
+		pCursor = getFromXPM( name##curs##_bits, name##mask##_bits, \
+							  name##curs_width, name##curs_height, \
+							  name##curs_x_hot, name##curs_y_hot ); \
+		break
+#define MAP_BUILTIN( vcl_name, gdk_name ) \
+		case vcl_name: \
+			pCursor = gdk_cursor_new_for_display( m_pGdkDisplay, gdk_name ); \
+			break
+
+GdkCursor *GtkSalDisplay::getCursor( PointerStyle ePointerStyle )
+{
+    if( ePointerStyle > POINTER_COUNT )
+        return NULL;
+
+	if ( !m_aCursors[ ePointerStyle ] )
+	{
+		GdkCursor *pCursor;
+
+	    switch( ePointerStyle )
+	    {
+			MAP_BUILTIN( POINTER_ARROW, GDK_LEFT_PTR );
+			MAP_BUILTIN( POINTER_TEXT, GDK_XTERM );
+			MAP_BUILTIN( POINTER_HELP, GDK_QUESTION_ARROW );
+			MAP_BUILTIN( POINTER_CROSS, GDK_CROSSHAIR );
+
+			MAP_BUILTIN( POINTER_NSIZE, GDK_SB_V_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_SSIZE, GDK_SB_V_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_WSIZE, GDK_SB_H_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_ESIZE, GDK_SB_H_DOUBLE_ARROW );
+
+			MAP_BUILTIN( POINTER_WINDOW_NSIZE, GDK_TOP_SIDE );
+			MAP_BUILTIN( POINTER_WINDOW_SSIZE, GDK_BOTTOM_SIDE );
+			MAP_BUILTIN( POINTER_WINDOW_WSIZE, GDK_LEFT_SIDE );
+			MAP_BUILTIN( POINTER_WINDOW_ESIZE, GDK_RIGHT_SIDE );
+
+			MAP_BUILTIN( POINTER_WINDOW_NWSIZE, GDK_TOP_LEFT_CORNER );
+			MAP_BUILTIN( POINTER_WINDOW_NESIZE, GDK_TOP_RIGHT_CORNER );
+			MAP_BUILTIN( POINTER_WINDOW_SWSIZE, GDK_BOTTOM_LEFT_CORNER );
+			MAP_BUILTIN( POINTER_WINDOW_SESIZE, GDK_BOTTOM_RIGHT_CORNER );
+
+			MAP_BUILTIN( POINTER_HSIZEBAR, GDK_SB_H_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_VSIZEBAR, GDK_SB_V_DOUBLE_ARROW );
+
+			MAP_BUILTIN( POINTER_REFHAND, GDK_HAND1 );
+			MAP_BUILTIN( POINTER_HAND, GDK_HAND2 );
+			MAP_BUILTIN( POINTER_PEN, GDK_PENCIL );
+
+			MAKE_CURSOR( POINTER_NULL, null );
+			MAKE_CURSOR( POINTER_WAIT, wait_ );
+			MAKE_CURSOR( POINTER_NWSIZE, nwsesize_ );
+			MAKE_CURSOR( POINTER_NESIZE, neswsize_ );
+			MAKE_CURSOR( POINTER_SWSIZE, neswsize_ );
+			MAKE_CURSOR( POINTER_SESIZE, nwsesize_ );
+			MAKE_CURSOR( POINTER_HSPLIT, hsplit_ );
+			MAKE_CURSOR( POINTER_VSPLIT, vsplit_ );
+			MAKE_CURSOR( POINTER_MAGNIFY, magnify_ );
+			MAKE_CURSOR( POINTER_FILL, fill_ );
+			MAKE_CURSOR( POINTER_MOVE, move_ );
+			MAKE_CURSOR( POINTER_MOVEDATA, movedata_ );
+			MAKE_CURSOR( POINTER_COPYDATA, copydata_ );
+			MAKE_CURSOR( POINTER_MOVEFILE, movefile_ );
+			MAKE_CURSOR( POINTER_COPYFILE, copyfile_ );
+			MAKE_CURSOR( POINTER_MOVEFILES, movefiles_ );
+			MAKE_CURSOR( POINTER_COPYFILES, copyfiles_ );
+			MAKE_CURSOR( POINTER_NOTALLOWED, nodrop_ );
+			MAKE_CURSOR( POINTER_ROTATE, rotate_ );
+			MAKE_CURSOR( POINTER_HSHEAR, hshear_ );
+			MAKE_CURSOR( POINTER_VSHEAR, vshear_ );
+			MAKE_CURSOR( POINTER_DRAW_LINE, drawline_ );
+			MAKE_CURSOR( POINTER_DRAW_RECT, drawrect_ );
+			MAKE_CURSOR( POINTER_DRAW_POLYGON, drawpolygon_ );
+			MAKE_CURSOR( POINTER_DRAW_BEZIER, drawbezier_ );
+			MAKE_CURSOR( POINTER_DRAW_ARC, drawarc_ );
+			MAKE_CURSOR( POINTER_DRAW_PIE, drawpie_ );
+			MAKE_CURSOR( POINTER_DRAW_CIRCLECUT, drawcirclecut_ );
+			MAKE_CURSOR( POINTER_DRAW_ELLIPSE, drawellipse_ );
+			MAKE_CURSOR( POINTER_DRAW_CONNECT, drawconnect_ );
+			MAKE_CURSOR( POINTER_DRAW_TEXT, drawtext_ );
+			MAKE_CURSOR( POINTER_MIRROR, mirror_ );
+			MAKE_CURSOR( POINTER_CROOK, crook_ );
+			MAKE_CURSOR( POINTER_CROP, crop_ );
+			MAKE_CURSOR( POINTER_MOVEPOINT, movepoint_ );
+			MAKE_CURSOR( POINTER_MOVEBEZIERWEIGHT, movebezierweight_ );
+			MAKE_CURSOR( POINTER_DRAW_FREEHAND, drawfreehand_ );
+			MAKE_CURSOR( POINTER_DRAW_CAPTION, drawcaption_ );
+			MAKE_CURSOR( POINTER_LINKDATA, linkdata_ );
+			MAKE_CURSOR( POINTER_MOVEDATALINK, movedlnk_ );
+			MAKE_CURSOR( POINTER_COPYDATALINK, copydlnk_ );
+			MAKE_CURSOR( POINTER_LINKFILE, linkfile_ );
+			MAKE_CURSOR( POINTER_MOVEFILELINK, moveflnk_ );
+			MAKE_CURSOR( POINTER_COPYFILELINK, copyflnk_ );
+			MAKE_CURSOR( POINTER_CHART, chart_ );
+			MAKE_CURSOR( POINTER_DETECTIVE, detective_ );
+			MAKE_CURSOR( POINTER_PIVOT_COL, pivotcol_ );
+			MAKE_CURSOR( POINTER_PIVOT_ROW, pivotrow_ );
+			MAKE_CURSOR( POINTER_PIVOT_FIELD, pivotfld_ );
+			MAKE_CURSOR( POINTER_PIVOT_DELETE, pivotdel_ );
+			MAKE_CURSOR( POINTER_CHAIN, chain_ );
+			MAKE_CURSOR( POINTER_CHAIN_NOTALLOWED, chainnot_ );
+			MAKE_CURSOR( POINTER_TIMEEVENT_MOVE, timemove_ );
+			MAKE_CURSOR( POINTER_TIMEEVENT_SIZE, timesize_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_N, asn_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_S, ass_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_W, asw_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_E, ase_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NW, asnw_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NE, asne_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_SW, assw_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_SE, asse_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NS, asns_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_WE, aswe_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NSWE, asnswe_ );
+			MAKE_CURSOR( POINTER_AIRBRUSH, airbrush_ );
+			MAKE_CURSOR( POINTER_TEXT_VERTICAL, vertcurs_ );
+		default:
+			fprintf( stderr, "pointer %d not implemented", ePointerStyle );
+			break;
+		}
+		if( !pCursor )
+			pCursor = gdk_cursor_new_for_display( m_pGdkDisplay, GDK_LEFT_PTR );
+
+		m_aCursors[ ePointerStyle ] = pCursor;
+	}
+
+	return m_aCursors[ ePointerStyle ];
+}
+
+int GtkSalDisplay::CaptureMouse( SalFrame* pSFrame )
+{
+    GtkSalFrame* pFrame = static_cast<GtkSalFrame*>(pSFrame);
+
+	if( !pFrame )
+	{
+		if( m_pCapture )
+			static_cast<GtkSalFrame*>(m_pCapture)->grabPointer( FALSE );
+		m_pCapture = NULL;
+		return 0;
+	}
+
+	if( m_pCapture )
+	{
+		if( pFrame == m_pCapture )
+			return 1;
+		static_cast<GtkSalFrame*>(m_pCapture)->grabPointer( FALSE );
+	}
+		
+	m_pCapture = pFrame;
+	static_cast<GtkSalFrame*>(pFrame)->grabPointer( TRUE );
+    return 1;
+}
+
+/***************************************************************************
+ * class GtkXLib                                                           *
+ ***************************************************************************/
+
+class GtkXLib : public SalXLib
+{
+    GtkSalDisplay       *m_pGtkSalDisplay;
+    std::list<GSource *> m_aSources;
+    GSource             *m_pTimeout;
+	GSource				*m_pUserEvent;
+	ULONG				 m_nTimeoutMs;
+
+	static gboolean      timeoutFn(gpointer data);
+	static gboolean      userEventFn(gpointer data);
+public:
+
+    GtkXLib();
+    virtual ~GtkXLib();
+  
+    virtual void    Init();
+    virtual void    Yield( BOOL );
+    virtual void    Insert( int fd, void* data,
+                            YieldFunc	pending,
+                            YieldFunc	queued,
+                            YieldFunc	handle );
+    virtual void    Remove( int fd );
+
+	virtual void    StartTimer( ULONG nMS );
+	virtual void    StopTimer();
+    virtual void    Wakeup();
+    virtual void    PostUserEvent();
+};
+
+GtkXLib::GtkXLib()
+{
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "GtkXLib::GtkXLib()\n" );
+#endif
+    m_pGtkSalDisplay = NULL;
+	m_pTimeout = NULL;
+	m_nTimeoutMs = 0;
+    m_pUserEvent = NULL;
+}
+
+GtkXLib::~GtkXLib()
+{
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "GtkXLib::~GtkXLib()\n" );
+#endif
+	StopTimer();
+}
+
+void GtkXLib::Init()
+{
+    int i;
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "GtkXLib::Init()\n" );
+#endif
+	XrmInitialize();
+
+    gtk_set_locale();
+
+	/*
+	 * open connection to X11 Display
+	 * try in this order:
+	 *  o  -display command line parameter,
+	 *  o  $DISPLAY environment variable
+	 *  o  default display
+	 */
+	
+    GdkDisplay *pGdkDisp = NULL;
+    
+	// is there a -display command line parameter?
+    rtl_TextEncoding aEnc = osl_getThreadTextEncoding();
+	int nParams = osl_getCommandArgCount();
+	rtl::OString aDisplay;
+	rtl::OUString aParam, aBin;
+    char** pCmdLineAry = new char*[ nParams+1 ];
+    osl_getExecutableFile( &aParam.pData );
+    osl_getSystemPathFromFileURL( aParam.pData, &aBin.pData );
+    pCmdLineAry[0] = g_strdup( OUStringToOString( aBin, aEnc ).getStr() );
+	for (i=0; i<nParams; i++) 
+	{
+		osl_getCommandArg(i, &aParam.pData );
+        OString aBParam( OUStringToOString( aParam, aEnc ) );
+
+		if( aParam.equalsAscii( "-display" ) || aParam.equalsAscii( "--display" ) )
+		{
+			pCmdLineAry[i+1] = g_strdup( "--display" );
+			osl_getCommandArg(i+1, &aParam.pData );
+			aDisplay = rtl::OUStringToOString( aParam, aEnc );
+		}
+		else
+	        pCmdLineAry[i+1] = g_strdup( aBParam.getStr() );
+	}
+    // add executable
+    nParams++;
+
+    // init gtk/gdk
+    gtk_init_check( &nParams, &pCmdLineAry );
+    
+	for (i = 0; i < nParams; i++ )
+		g_free( pCmdLineAry[i] );
+	delete [] pCmdLineAry;
+
+#if OSL_DEBUG_LEVEL > 1
+	if (g_getenv ("SAL_DEBUG_UPDATES"))
+		gdk_window_set_debug_updates (TRUE);
+#endif
+
+    pGdkDisp = gdk_display_get_default();
+	if ( !pGdkDisp )
+	{
+	    rtl::OUString aProgramFileURL;
+        osl_getExecutableFile( &aProgramFileURL.pData );
+	    rtl::OUString aProgramSystemPath;
+        osl_getSystemPathFromFileURL (aProgramFileURL.pData, &aProgramSystemPath.pData);
+        rtl::OString  aProgramName = rtl::OUStringToOString(
+                                            aProgramSystemPath,
+                                            osl_getThreadTextEncoding() );
+		fprintf( stderr, "%s X11 error: Can't open display: %s\n",
+				aProgramName.getStr(), aDisplay.getStr()); 
+		fprintf( stderr, "   Set DISPLAY environment variable, use -display option\n"); 
+		fprintf( stderr, "   or check permissions of your X-Server\n"); 
+		fprintf( stderr, "   (See \"man X\" resp. \"man xhost\" for details)\n");
+		fflush( stderr );
+		exit(0);
+	}
+
+	/*
+	 * if a -display switch was used, we need
+	 * to set the environment accoringly since 
+	 * the clipboard build another connection 
+	 * to the xserver using $DISPLAY
+	 */
+	char *pPutEnvIsBroken = g_strdup_printf( "DISPLAY=%s",
+											 gdk_display_get_name( pGdkDisp ) );
+	putenv( pPutEnvIsBroken );
+
+	Display *pDisp = gdk_x11_display_get_xdisplay( pGdkDisp );
+	XVisualInfo aVI;
+	Colormap	aColMap;
+	int 		nScreen = DefaultScreen( pDisp );
+
+	if( SalDisplay::BestVisual( pDisp, nScreen, aVI ) ) // DefaultVisual
+		aColMap = DefaultColormap( pDisp, nScreen );
+	else
+		aColMap = XCreateColormap( pDisp,
+								   RootWindow( pDisp, nScreen ),
+								   aVI.visual,
+								   AllocNone );
+
+	XSetIOErrorHandler	  ( (XIOErrorHandler)SalData::XIOErrorHdl );
+	XSetErrorHandler	  ( (XErrorHandler)SalData::XErrorHdl );
+
+	m_pGtkSalDisplay = new GtkSalDisplay( pGdkDisp, aVI.visual, aColMap );
+
+    gdk_window_add_filter( NULL, GtkSalDisplay::filterGdkEvent, m_pGtkSalDisplay );
+
+	sal_Bool bOldErrorSetting = GetIgnoreXErrors();
+	SetIgnoreXErrors( True );
+	SalI18N_KeyboardExtension *pKbdExtension = new SalI18N_KeyboardExtension( pDisp );
+	XSync( pDisp, False );
+
+	pKbdExtension->UseExtension( ! WasXError() );
+	SetIgnoreXErrors( bOldErrorSetting );
+
+	m_pGtkSalDisplay->SetKbdExtension( pKbdExtension );
+    
+}
+
+gboolean GtkXLib::timeoutFn(gpointer data)
+{
+	SalData *pSalData = GetSalData();
+	GtkXLib *pThis = (GtkXLib *) data;
+
+	pSalData->pInstance_->GetYieldMutex()->acquire();
+
+	if( pThis->m_pTimeout )
+	{
+		g_source_unref (pThis->m_pTimeout);
+		pThis->m_pTimeout = NULL;
+	}
+
+	// Auto-restart immediately
+	pThis->StartTimer( pThis->m_nTimeoutMs );
+	
+	GetSalData()->Timeout();
+
+	pSalData->pInstance_->GetYieldMutex()->release();
+	
+	return FALSE;
+}
+
+void GtkXLib::StartTimer( ULONG nMS )
+{
+	StopTimer();
+	m_nTimeoutMs = nMS; // for restarting
+
+//	fprintf (stderr, "Add timeout of '%d'ms\n", m_nTimeoutMs);
+
+	m_pTimeout = g_timeout_source_new (m_nTimeoutMs);
+	g_source_set_can_recurse (m_pTimeout, TRUE);
+	g_source_set_callback (m_pTimeout, timeoutFn,
+						   (gpointer) this, NULL);
+	g_source_attach (m_pTimeout, g_main_context_default ());
+}
+
+void GtkXLib::StopTimer()
+{
+	if (m_pTimeout)
+	{
+		g_source_destroy (m_pTimeout);
+		g_source_unref (m_pTimeout);
+		m_pTimeout = NULL;
+	}
+}
+
+gboolean GtkXLib::userEventFn(gpointer data)
+{
+	gboolean bContinue;
+	GtkXLib *pThis = (GtkXLib *) data;
+	SalData *pSalData = GetSalData();
+
+	pSalData->pInstance_->GetYieldMutex()->acquire();
+	pThis->m_pGtkSalDisplay->EventGuardAcquire();
+
+	if( !pThis->m_pGtkSalDisplay->HasMoreEvents() )
+	{
+		if( pThis->m_pUserEvent )
+		{
+			g_source_unref (pThis->m_pUserEvent);
+			pThis->m_pUserEvent = NULL;
+		}
+		bContinue = FALSE;
+	}
+	else
+		bContinue = TRUE;
+
+	pThis->m_pGtkSalDisplay->EventGuardRelease();
+
+	pThis->m_pGtkSalDisplay->DispatchInternalEvent();
+
+	pSalData->pInstance_->GetYieldMutex()->release();
+
+	return bContinue;
+}
+
+// hEventGuard_ held during this invocation
+void GtkXLib::PostUserEvent()
+{
+	if( !m_pUserEvent ) // not pending anyway
+	{
+		m_pUserEvent = g_idle_source_new();
+		g_source_set_priority( m_pUserEvent, G_PRIORITY_HIGH );
+		g_source_set_can_recurse (m_pUserEvent, TRUE);
+		g_source_set_callback (m_pUserEvent, userEventFn,
+							   (gpointer) this, NULL);
+		g_source_attach (m_pUserEvent, g_main_context_default ());
+	}
+    Wakeup();
+}
+
+void GtkXLib::Wakeup()
+{
+	g_main_context_wakeup( g_main_context_default () );
+}
+
+void GtkXLib::Yield( BOOL bWait )
+{
+	// release YieldMutex (and re-acquire at method end)
+	YieldMutexReleaser aReleaser;
+
+	g_main_context_iteration( NULL, bWait );
+}
+
+extern "C" {
+
+typedef struct {
+	GSource       source;
+
+	GPollFD       pollfd;
+	GIOCondition  condition;
+	
+	YieldFunc     pending;
+	YieldFunc     handle;
+	gpointer      user_data;
+} SalWatch;
+
+static gboolean 
+sal_source_prepare (GSource *source,
+					gint    *timeout)
+{
+	SalWatch *watch = (SalWatch *)source;
+
+	*timeout = -1;
+
+	if (watch->pending &&
+	    watch->pending (watch->pollfd.fd, watch->user_data)) {
+		watch->pollfd.revents |= watch->condition;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static gboolean 
+sal_source_check (GSource *source)
+{
+	SalWatch *watch = (SalWatch *)source;
+
+	return watch->pollfd.revents & watch->condition;
+}
+
+static gboolean
+sal_source_dispatch (GSource    *source,
+					 GSourceFunc callback,
+					 gpointer    user_data)
+{
+	SalData *pSalData = GetSalData();
+	SalWatch *watch = (SalWatch *) source;
+
+	pSalData->pInstance_->GetYieldMutex()->acquire();
+
+	watch->handle (watch->pollfd.fd, watch->user_data);
+
+	pSalData->pInstance_->GetYieldMutex()->release();
+
+	return TRUE;
+}
+
+static void
+sal_source_finalize (GSource *source)
+{
+}
+
+static GSourceFuncs sal_source_watch_funcs = {
+	sal_source_prepare,
+	sal_source_check,
+	sal_source_dispatch,
+	sal_source_finalize
+};
+
+static GSource *
+sal_source_create_watch (int           fd,
+                         GIOCondition  condition,
+                         YieldFunc     pending,
+                         YieldFunc     handle,
+                         gpointer      user_data)
+{
+	GSource      *source;
+	SalWatch     *watch;
+	GMainContext *context = g_main_context_default ();
+
+	source = g_source_new (&sal_source_watch_funcs,
+			       sizeof (SalWatch));
+	watch = (SalWatch *) source;
+
+	watch->pollfd.fd     = fd;
+	watch->pollfd.events = condition;
+	watch->condition = condition;
+	watch->pending   = pending;
+	watch->handle    = handle;
+	watch->user_data = user_data;
+
+	g_source_set_can_recurse (source, TRUE);
+	g_source_add_poll (source, &watch->pollfd);
+	g_source_attach (source, context);
+
+	return source;
+}
+
+} // extern "C"
+
+void GtkXLib::Insert( int       nFD,
+		      void     *data,
+		      YieldFunc pending,
+		      YieldFunc queued,
+		      YieldFunc handle )
+{
+	GSource *source = sal_source_create_watch
+		( nFD, (GIOCondition) ((G_IO_IN|G_IO_PRI) |
+				       (G_IO_ERR|G_IO_HUP|G_IO_NVAL)),
+		  pending, handle, data );
+	m_aSources.push_back( source );
+}
+
+void GtkXLib::Remove( int nFD )
+{
+    ::std::list< GSource * >::iterator it;
+	
+	for (it = m_aSources.begin(); it != m_aSources.end(); ++it)
+	{
+		SalWatch *watch = (SalWatch *) *it;
+
+		if (watch->pollfd.fd == nFD)
+		{
+            m_aSources.erase( it );
+
+			g_source_destroy ((GSource *)watch);
+			g_source_unref   ((GSource *)watch);
+			return;
+		}
+	}
+}
+
+/**********************************************************************
+ * class GtkData                                                      *
+ **********************************************************************/
+
+GtkData::~GtkData()
+{
+}
+
+void GtkData::Init()
+{
+    pXLib_ = new GtkXLib();
+    pXLib_->Init();
+}
Index: vcl/unx/gtk/app/gtkinst.cxx
===================================================================
RCS file: vcl/unx/gtk/app/gtkinst.cxx
diff -N vcl/unx/gtk/app/gtkinst.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/gtkinst.cxx	2 Jun 2004 14:53:44 -0000	1.5
@@ -0,0 +1,323 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <osl/module.h>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <salframe.h>
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkobject.hxx>
+
+#if OSL_DEBUG_LEVEL > 1
+#include <cstdio>
+#endif
+
+GtkHookedYieldMutex::GtkHookedYieldMutex()
+{
+}
+
+/*
+ * These methods always occur in pairs
+ * A ThreadsEnter is followed by a ThreadsLeave
+ * We need to queue up the recursive lock count
+ * for each pair, so we can accurately restore
+ * it later.
+ */
+void GtkHookedYieldMutex::ThreadsEnter()
+{
+	acquire();
+	if( !aYieldStack.empty() )
+	{ /* Previously called ThreadsLeave() */
+		ULONG nCount = aYieldStack.front();
+		aYieldStack.pop_front();
+		while( nCount-- > 1 )
+			acquire();
+	}
+}
+
+void GtkHookedYieldMutex::ThreadsLeave()
+{
+	aYieldStack.push_front( mnCount );
+
+#if OSL_DEBUG_LEVEL > 1
+	if( mnThreadId &&
+		mnThreadId != NAMESPACE_VOS(OThread)::getCurrentIdentifier())
+		fprintf( stderr, "\n\n--- A different thread owns the mutex ...---\n\n\n");
+#endif
+
+	while( mnCount > 1 )
+		release();
+	release();
+}
+
+void GtkHookedYieldMutex::acquire()
+{
+	SalYieldMutex::acquire();
+}
+
+void GtkHookedYieldMutex::release()
+{
+	SalYieldMutex::release();
+}
+
+extern "C" 
+{
+	#define GET_YIELD_MUTEX() static_cast<GtkHookedYieldMutex*>(GetSalData()->pInstance_->GetYieldMutex())
+	static void GdkThreadsEnter( void )
+	{
+		GtkHookedYieldMutex *pYieldMutex = GET_YIELD_MUTEX();
+		pYieldMutex->ThreadsEnter();
+	}
+	static void GdkThreadsLeave( void )
+	{
+		GtkHookedYieldMutex *pYieldMutex = GET_YIELD_MUTEX();
+		pYieldMutex->ThreadsLeave();
+	}
+	static bool hookLocks( oslModule pModule )
+	{
+		typedef void (*GdkLockFn) (GCallback enter_fn, GCallback leave_fn);
+		rtl::OUString aSymbolName( RTL_CONSTASCII_USTRINGPARAM( "gdk_threads_set_lock_functions") );
+
+		GdkLockFn gdk_threads_set_lock_functions =
+				(GdkLockFn) osl_getSymbol( pModule, aSymbolName.pData );
+		if ( !gdk_threads_set_lock_functions )
+		{
+#if OSL_DEBUG_LEVEL > 1
+		    fprintf( stderr, "Failed to hook gdk threads locks\n" );
+#endif
+			return false;
+		}
+
+		gdk_threads_set_lock_functions (GdkThreadsEnter, GdkThreadsLeave);
+#if OSL_DEBUG_LEVEL > 1
+		fprintf( stderr, "Hooked gdk threads locks\n" );
+#endif
+		return true;
+	}
+
+    SalInstance* create_SalInstance( oslModule pModule )
+    {
+        const gchar* pVersion = gtk_check_version( 2, 2, 0 );
+        if( pVersion )
+        {
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "gtk version conflict: %s\n", pVersion );
+#endif
+            return NULL;
+        }
+
+		GtkYieldMutex *pYieldMutex;
+
+        // init gdk thread protection
+		if ( !g_thread_supported() )
+			g_thread_init( NULL );
+
+		if ( hookLocks( pModule ) )
+			pYieldMutex = new GtkHookedYieldMutex();
+		else
+			pYieldMutex = new GtkYieldMutex();
+				
+		gdk_threads_init();
+
+        GtkInstance* pInstance = new GtkInstance( pYieldMutex );
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "creating GtkSalInstance 0x%p\n", pInstance );
+#endif
+
+        // initialize SalData
+        SalData *pSalData = new GtkData();
+        SetSalData( pSalData );
+        pSalData->pInstance_ = pInstance;
+        pSalData->Init();
+        pSalData->initNWF();
+
+        return pInstance;
+    }
+}
+
+GtkInstance::~GtkInstance()
+{
+}
+
+SalFrame* GtkInstance::CreateFrame( SalFrame* pParent, ULONG nStyle )
+{
+    return new GtkSalFrame( pParent, nStyle );
+}
+
+SalObject* GtkInstance::CreateObject( SalFrame* pParent )
+{
+    return new GtkSalObject( static_cast<GtkSalFrame*>(pParent) );
+}
+
+GtkYieldMutex::GtkYieldMutex()
+{
+}
+
+void GtkYieldMutex::acquire()
+{
+    vos::OThread::TThreadIdentifier aCurrentThread = vos::OThread::getCurrentIdentifier();
+    // protect member manipulation
+    OMutex::acquire();
+    if( mnCount > 0 && mnThreadId == aCurrentThread )
+    {
+        mnCount++;
+        OMutex::release();
+        return;
+    }
+    OMutex::release();
+    
+    // obtain gdk mutex
+    gdk_threads_enter();
+
+    // obtained gdk mutex, now lock count is one by definition
+    OMutex::acquire();
+    mnCount = 1;
+    mnThreadId = aCurrentThread;
+    OMutex::release();
+}
+
+void GtkYieldMutex::release()
+{
+    vos::OThread::TThreadIdentifier aCurrentThread = vos::OThread::getCurrentIdentifier();
+    // protect member manipulation
+    OMutex::acquire();
+    // strange things happen, do nothing if we don't own the mutex
+    if( mnThreadId == aCurrentThread )
+    {
+        mnCount--;
+        if( mnCount == 0 )
+        {
+            gdk_threads_leave();
+            mnThreadId = 0;
+        }
+    }
+    OMutex::release();
+}
+
+sal_Bool GtkYieldMutex::tryToAcquire()
+{
+    vos::OThread::TThreadIdentifier aCurrentThread = vos::OThread::getCurrentIdentifier();
+    // protect member manipulation
+    OMutex::acquire();
+    if( mnCount > 0 )
+    {
+        if( mnThreadId == aCurrentThread )
+        {
+            mnCount++;
+            OMutex::release();
+            return sal_True;
+        }
+        else
+        {
+            OMutex::release();
+            return sal_False;
+        }
+    }
+    OMutex::release();
+
+    // HACK: gdk_threads_mutex is private, we shouldn't use it.
+    // how to we do a try_lock without having a gdk_threads_try_enter ?
+    if( ! g_mutex_trylock( gdk_threads_mutex ) )
+        return sal_False;
+    
+    // obtained gdk mutex, now lock count is one by definition
+    OMutex::acquire();
+    mnCount = 1;
+    mnThreadId = aCurrentThread;
+    OMutex::release();
+    
+    return sal_True;
+}
+
+int GtkYieldMutex::Grab()
+{
+    // this MUST only be called by gdk/gtk callbacks:
+    // they are entered with gdk mutex locked; the mutex
+    // was unlocked by GtkYieldMutex befor yielding which
+    // is now locked again by gtk implicitly
+
+    // obtained gdk mutex, now lock count is one by definition
+    OMutex::acquire();
+    int nRet = mnCount;
+    if( mnCount == 0 ) // recursive else
+        mnThreadId = vos::OThread::getCurrentIdentifier();
+#if OSL_DEBUG_LEVEL > 1
+    else if( mnThreadId != vos::OThread::getCurrentIdentifier() )
+    {
+        fprintf( stderr, "Yield mutex grabbed in different thread !\n" );
+        abort();
+    }
+#endif
+    mnCount = 1;
+    OMutex::release();
+    return nRet;
+}
+
+void GtkYieldMutex::Ungrab( int nGrabs )
+{
+    // this MUST only be called when leaving the callback
+    // that locked the mutex with Grab()
+    OMutex::acquire();
+    mnCount = nGrabs;
+    if( mnCount == 0 )
+        mnThreadId = 0;
+    OMutex::release();
+}
Index: vcl/unx/gtk/app/gtksys.cxx
===================================================================
RCS file: vcl/unx/gtk/app/gtksys.cxx
diff -N vcl/unx/gtk/app/gtksys.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/gtksys.cxx	20 Feb 2004 08:53:44 -0000	1.2
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <svunx.h>
+#include <svdata.hxx>
+#include <window.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <cstdio>
+#include <gdk/gdk.h>
+#include <gtk/gtk.h>
+#include <X11/Xlib.h>
+
+SalSystem *GtkInstance::CreateSalSystem()
+{
+		return new GtkSalSystem();
+}
+
+GtkSalSystem::~GtkSalSystem()
+{
+}
+
+int GtkSalSystem::ShowNativeDialog( const String& rTitle,
+									const String& rMessage,
+									const std::list< String >& rButtons,
+									int nDefButton )
+{
+
+	ImplSVData* pSVData = ImplGetSVData();
+	if( pSVData->mpIntroWindow )
+			pSVData->mpIntroWindow->Hide();
+
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, "GtkSalSystem::ShowNativeDialog\n");
+#endif
+
+	ByteString aTitle( rTitle, RTL_TEXTENCODING_UTF8 );
+	ByteString aMessage( rMessage, RTL_TEXTENCODING_UTF8 );
+
+    /* Create the dialogue */
+    GtkWidget* mainwin = gtk_message_dialog_new
+			( NULL, (GtkDialogFlags)0, GTK_MESSAGE_WARNING,
+			  GTK_BUTTONS_NONE, aMessage.GetBuffer(), NULL );
+    gtk_window_set_title( GTK_WINDOW( mainwin ), aTitle.GetBuffer() );
+
+    gint i, nButtons = 0, nResponse;
+
+	int nButton = 0;
+	for( std::list< String >::const_iterator it = rButtons.begin(); it != rButtons.end(); ++it )
+	{
+        ByteString aLabel( *it, RTL_TEXTENCODING_UTF8 );
+
+		if( nButton == nDefButton )
+		{
+            gtk_dialog_add_button( GTK_DIALOG( mainwin ), aLabel.GetBuffer(), nButtons );
+            gtk_dialog_set_default_response( GTK_DIALOG( mainwin ), nButtons );
+		}
+		else
+			gtk_dialog_add_button( GTK_DIALOG( mainwin ), aLabel.GetBuffer(), nButtons );
+		nButtons++;
+	}
+
+    nResponse = gtk_dialog_run( GTK_DIALOG(mainwin) );
+    if( nResponse == GTK_RESPONSE_NONE || nResponse == GTK_RESPONSE_DELETE_EVENT )
+        nResponse = -1;
+
+    gtk_widget_destroy( GTK_WIDGET(mainwin) );
+
+	return nResponse;
+}
Index: vcl/unx/gtk/app/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/app/makefile.mk
diff -N vcl/unx/gtk/app/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/makefile.mk	10 May 2004 15:52:35 -0000	1.4
@@ -0,0 +1,110 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtkapp
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# workaround for makedepend hang
+MKDEPENDSOLVER=
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
+SLOFILES=\
+			$(SLO)$/gtkdata.obj	\
+			$(SLO)$/gtkinst.obj	\
+			$(SLO)$/gtksys.obj
+
+.IF "$(WITH_LIBSN)"=="YES"
+CDEFS+=-DHAVE_LIBSN
+CFLAGS+=$(LIBSN_CFLAGS)
+.ENDIF
+
+.ELSE # "$(ENABLE_GTK)" != ""
+
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/gtk/gdi/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/gdi/makefile.mk
diff -N vcl/unx/gtk/gdi/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/gdi/makefile.mk	10 May 2004 15:52:47 -0000	1.2
@@ -0,0 +1,102 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtkgdi
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
+SLOFILES=\
+			$(SLO)$/salnativewidgets-gtk.obj
+
+.ELSE # "$(ENABLE_GTK)" != ""
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx
===================================================================
RCS file: vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx
diff -N vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx	10 May 2004 15:52:59 -0000	1.2
@@ -0,0 +1,2349 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <plugins/gtk/gtkgdi.hxx>
+
+#include <cstdio>
+#include <cmath>
+#include <vector>
+#include <algorithm>
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+
+#ifndef _OSL_CONDITN_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+// initialize statics
+BOOL GtkSalGraphics::bThemeChanged = TRUE;
+
+GtkSalGraphics::~GtkSalGraphics()
+{
+}
+
+
+using namespace rtl;
+
+/*************************************
+ * Cached native widget objects
+ *************************************/
+static GtkWidget *	gCacheWindow = NULL;
+static GtkWidget *	gDumbContainer = NULL;
+
+static GtkWidget *	gBtnWidget 			= NULL;
+static GtkWidget *	gRadioWidget			= NULL;
+static GtkWidget *	gRadioWidgetSibling		= NULL;
+static GtkWidget *	gCheckWidget			= NULL;
+static GtkWidget *	gScrollHorizWidget		= NULL;
+static GtkWidget *	gScrollVertWidget		= NULL;
+static GtkWidget *	gArrowWidget			= NULL;
+static GtkWidget *	gDropdownWidget		= NULL;
+static GtkWidget *	gEditBoxWidget			= NULL;
+static GtkWidget *	gSpinButtonWidget		= NULL;
+static GtkWidget *	gNotebookWidget		= NULL;
+static GtkWidget *	gOptionMenuWidget		= NULL;
+static GtkWidget *	gComboWidget			= NULL;
+static GtkWidget *	gScrolledWindowWidget	= NULL;
+
+osl::Mutex	* pWidgetMutex;
+
+class NWPixmapCacheList;
+static NWPixmapCacheList* gNWPixmapCacheList = NULL;
+
+static const GtkBorder aDefDefBorder		= { 1, 1, 1, 1 };
+static const GtkBorder aDefDefOutsideBorder	= { 0, 0, 0, 0 };
+
+// Some GTK defaults
+#define MIN_ARROW_SIZE					11
+#define BTN_CHILD_SPACING				1
+#define MIN_SPIN_ARROW_WIDTH				6
+
+
+static void NWEnsureGTKRadio			( void );
+static void NWEnsureGTKButton			( void );
+static void NWEnsureGTKCheck			( void );
+static void NWEnsureGTKScrollbars		( void );
+static void NWEnsureGTKArrow			( void );
+static void NWEnsureGTKEditBox		( void );
+static void NWEnsureGTKSpinButton		( void );
+static void NWEnsureGTKNotebook		( void );
+static void NWEnsureGTKOptionMenu		( void );
+static void NWEnsureGTKCombo			( void );
+static void NWEnsureGTKScrolledWindow	( void );
+
+static void NWConvertVCLStateToGTKState( ControlState nVCLState, GtkStateType* nGTKState, GtkShadowType* nGTKShadow );
+static void NWAddWidgetToCacheWindow( GtkWidget* widget );
+
+
+/*
+ * Individual helper functions
+ *
+ */
+
+//---
+static Rectangle NWGetButtonArea( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+								const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static Rectangle NWGetEditBoxPixmapRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static void NWPaintOneEditBox( GdkWindow * gdkDrawable, GdkRectangle *gdkRect, 
+                               ControlType nType, ControlPart nPart, Rectangle aEditBoxRect,
+                               ControlState nState, const ImplControlValue& aValue,
+                               SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static Rectangle NWGetSpinButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static void NWPaintOneSpinButton( GdkPixmap * pixmap, ControlType nType, ControlPart nPart, Rectangle aAreaRect,
+							ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+							OUString aCaption );
+//---
+static Rectangle NWGetComboBoxButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static Rectangle NWGetListBoxButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static Rectangle NWGetListBoxIndicatorRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+//---
+
+/*********************************************************
+ * PixmapCache
+ *********************************************************/
+
+// as some native widget drawing operations are pretty slow
+// with certain themes (eg tabpages)
+// this cache can be used to cache the corresponding pixmap
+// see NWPaintGTKTabItem
+
+class NWPixmapCacheData
+{
+public:
+    ControlType m_nType;
+    ControlState m_nState;
+    Rectangle   m_pixmapRect;
+    GdkPixmap*  m_pixmap;
+    
+    NWPixmapCacheData()
+        { m_pixmap = NULL; };
+    ~NWPixmapCacheData()
+        { SetPixmap( NULL ); };
+    void SetPixmap( GdkPixmap* pPixmap );
+};
+
+class NWPixmapCache
+{
+    int m_size;
+    int m_idx;
+    NWPixmapCacheData* pData;
+public:
+    NWPixmapCache();
+    ~NWPixmapCache();
+    
+    void SetSize( int n)
+        { delete [] pData; m_idx = 0; m_size = n; pData = new NWPixmapCacheData[m_size]; }
+    int GetSize() { return m_size; }
+    
+    BOOL Find( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap** pPixmap );
+    void Fill( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap* pPixmap );
+    
+    void ThemeChanged();    
+};
+
+class NWPixmapCacheList
+{
+public:
+    ::std::vector< NWPixmapCache* > mCaches;
+
+    void AddCache( NWPixmapCache *pCache );
+    void RemoveCache( NWPixmapCache *pCache );
+    void ThemeChanged();
+};
+
+// --- implementation ---
+
+void NWPixmapCacheData::SetPixmap( GdkPixmap* pPixmap )
+{
+    if( m_pixmap )
+        g_object_unref( m_pixmap );
+    
+    m_pixmap = pPixmap;
+    
+    if( m_pixmap )
+        g_object_ref( m_pixmap );
+}
+
+
+NWPixmapCache::NWPixmapCache()
+{
+    m_idx = 0;
+    m_size = 0;
+    pData = NULL;
+    gNWPixmapCacheList->AddCache(this);
+} 
+NWPixmapCache::~NWPixmapCache()
+{
+    gNWPixmapCacheList->RemoveCache(this);
+    delete[] pData;
+}
+void NWPixmapCache::ThemeChanged()
+{
+    // throw away cached pixmaps
+    int i;
+    for(i=0; i<m_size; i++)
+        pData[i].SetPixmap( NULL );
+}
+
+BOOL  NWPixmapCache::Find( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap** pPixmap )
+{
+    aState &= ~CTRL_CACHING_ALLOWED; // mask clipping flag
+    int i;
+    for(i=0; i<m_size; i++)
+    {
+        if( pData[i].m_nType == aType &&
+            pData[i].m_nState == aState &&    
+            pData[i].m_pixmapRect.getWidth() == r_pixmapRect.getWidth() &&    
+            pData[i].m_pixmapRect.getHeight() == r_pixmapRect.getHeight() &&    
+            pData[i].m_pixmap != NULL )
+        {
+            *pPixmap = pData[i].m_pixmap;
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+void NWPixmapCache::Fill( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap* pPixmap )
+{
+    if( !(aState & CTRL_CACHING_ALLOWED) )
+        return; 
+
+    aState &= ~CTRL_CACHING_ALLOWED; // mask clipping flag
+    m_idx = (m_idx+1) % m_size; // just wrap
+    pData[m_idx].m_nType = aType;
+    pData[m_idx].m_nState = aState;
+    pData[m_idx].m_pixmapRect = r_pixmapRect;
+    pData[m_idx].SetPixmap( pPixmap );
+}
+
+
+void NWPixmapCacheList::AddCache( NWPixmapCache* pCache )
+{
+    mCaches.push_back( pCache );
+}
+void NWPixmapCacheList::RemoveCache( NWPixmapCache* pCache )
+{
+    ::std::vector< NWPixmapCache* >::iterator p;
+    p = ::std::find( mCaches.begin(), mCaches.end(), pCache );
+    if( p != mCaches.end() )
+        mCaches.erase( p );
+}
+void NWPixmapCacheList::ThemeChanged( )
+{
+    ::std::vector< NWPixmapCache* >::iterator p = mCaches.begin();
+    while( p != mCaches.end() )
+    {
+        (*p)->ThemeChanged();
+        p++;
+    }
+}
+
+
+/*********************************************************
+ * Make border manipulation easier
+ *********************************************************/
+inline void NW_gtk_border_set_from_border( GtkBorder& aDst, const GtkBorder * pSrc )
+{
+	aDst.left		= pSrc->left;
+	aDst.top		= pSrc->top;
+	aDst.right	= pSrc->right;
+	aDst.bottom	= pSrc->bottom;
+}
+
+
+/*********************************************************
+ * Initialize GTK and local stuff                         
+ *********************************************************/
+void GtkData::initNWF( void )
+{
+	pWidgetMutex = new osl::Mutex;
+    gNWPixmapCacheList = new NWPixmapCacheList;
+}
+
+
+/*********************************************************
+ * Release GTK and local stuff                         
+ *********************************************************/
+void GtkData::deInitNWF( void )
+{
+	delete pWidgetMutex;
+    delete gNWPixmapCacheList;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL GtkSalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+	if (
+		((nType==CTRL_PUSHBUTTON)  && (nPart==PART_ENTIRE_CONTROL)) 	||
+ 		((nType==CTRL_RADIOBUTTON) && (nPart==PART_ENTIRE_CONTROL))		||
+		((nType==CTRL_CHECKBOX)    && (nPart==PART_ENTIRE_CONTROL))		||
+		((nType==CTRL_SCROLLBAR) &&
+				(  (nPart==PART_DRAW_BACKGROUND_HORZ)
+				|| (nPart==PART_DRAW_BACKGROUND_VERT)
+				|| (nPart==PART_ENTIRE_CONTROL) )				)	||
+		((nType==CTRL_EDITBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) ) 			)	||
+		((nType==CTRL_SPINBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_ALL_BUTTONS)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) )			)	||
+		((nType==CTRL_SPINBUTTONS) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_ALL_BUTTONS)	)				)	||
+		((nType==CTRL_COMBOBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==HAS_BACKGROUND_TEXTURE)	)			)	||
+		(((nType==CTRL_TAB_ITEM) || (nType==CTRL_TAB_PANE) ||
+		  (nType==CTRL_TAB_BODY) || (nType==CTRL_FIXEDBORDER)) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_TABS_DRAW_RTL) )				)	||
+		((nType==CTRL_LISTBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_WINDOW)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) )			)
+	   )
+		return( TRUE );
+
+	return( FALSE );
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  bIsInside is set to TRUE if aPos is contained within the
+ *  given part of the control, whose bounding region is
+ *  given by rControlRegion (in VCL frame coordinates).
+ *
+ *  returns whether bIsInside was really set.
+ */
+BOOL GtkSalGraphics::hitTestNativeControl( ControlType		nType,
+								ControlPart		nPart,
+								const Region&		rControlRegion,
+								const Point&		aPos,
+								SalControlHandle&	rControlHandle,
+								BOOL&			rIsInside )
+{
+	if( IsNativeControlSupported(nType, nPart) )
+	{
+		rIsInside = rControlRegion.IsInside( aPos );
+		return( TRUE );
+	}
+	else
+	{
+		return( FALSE );
+	}
+}
+
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL GtkSalGraphics::drawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+	BOOL			returnVal = FALSE;
+	int			    nDepth = GetSalData()->GetDisplay()->GetVisual()->GetDepth();
+
+	// get a GC with current clipping region set
+	GC			gc = SelectFont();
+    
+    // theme changed ?
+    if( GtkSalGraphics::bThemeChanged )
+    {
+        // invalidate caches
+        gNWPixmapCacheList->ThemeChanged();
+        GtkSalGraphics::bThemeChanged = FALSE;    
+    }
+    
+	if ( pWidgetMutex->acquire() )
+	{
+		if ( (nType==CTRL_PUSHBUTTON) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKButton( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_RADIOBUTTON) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKRadio( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_CHECKBOX) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKCheck( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_SCROLLBAR) && ((nPart==PART_DRAW_BACKGROUND_HORZ) || (nPart==PART_DRAW_BACKGROUND_VERT)) )
+		{
+			returnVal = NWPaintGTKScrollbar( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( ((nType==CTRL_EDITBOX) && ((nPart==PART_ENTIRE_CONTROL) || (nPart==HAS_BACKGROUND_TEXTURE)) )
+				|| ((nType==CTRL_SPINBOX) && (nPart==HAS_BACKGROUND_TEXTURE))
+				|| ((nType==CTRL_COMBOBOX) && (nPart==HAS_BACKGROUND_TEXTURE))
+				|| ((nType==CTRL_LISTBOX) && (nPart==HAS_BACKGROUND_TEXTURE)) )
+		{
+			returnVal = NWPaintGTKEditBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( ((nType==CTRL_SPINBOX) || (nType==CTRL_SPINBUTTONS))
+				&& ((nPart==PART_ENTIRE_CONTROL) || (nPart==PART_ALL_BUTTONS)) )
+		{
+			returnVal = NWPaintGTKSpinBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType == CTRL_COMBOBOX) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKComboBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_TAB_ITEM) || (nType==CTRL_TAB_PANE) || (nType==CTRL_TAB_BODY) || (nType==CTRL_FIXEDBORDER) )
+		{
+			if ( nType == CTRL_TAB_BODY )
+				returnVal = TRUE;
+			else
+				returnVal = NWPaintGTKTabItem( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption);
+		}
+		else if ( (nType==CTRL_LISTBOX) && ((nPart==PART_ENTIRE_CONTROL) || (nPart==PART_WINDOW)) )
+		{
+			returnVal = NWPaintGTKListBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+
+		pWidgetMutex->release();
+	}
+
+	return( returnVal );
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL GtkSalGraphics::drawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption )
+{
+	return( FALSE );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the TRUE bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL GtkSalGraphics::getNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion )
+{
+	BOOL returnVal = FALSE;
+
+	if ( pWidgetMutex->acquire() )
+	{
+		if ( (nType==CTRL_PUSHBUTTON) && (nPart==PART_ENTIRE_CONTROL)
+				&& (rControlRegion.GetBoundRect().GetWidth() > 16)
+				&& (rControlRegion.GetBoundRect().GetHeight() > 16) )
+		{
+			rNativeBoundingRegion = NWGetButtonArea( nType, nPart, rControlRegion.GetBoundRect(),
+									 nState, aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rControlRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_SPINBOX) && ((nPart==PART_BUTTON_UP) || (nPart==PART_BUTTON_DOWN)) )
+		{
+			rNativeBoundingRegion = NWGetSpinButtonRect( nType, nPart, rControlRegion.GetBoundRect(),
+										nState, aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_COMBOBOX) && (nPart==PART_BUTTON_DOWN) )
+		{
+			rNativeBoundingRegion = NWGetComboBoxButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+										aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_SPINBOX) && ((nPart==PART_BUTTON_UP) || (nPart==PART_BUTTON_DOWN)) )
+		{
+			SpinbuttonValue *	pSpinVal = (SpinbuttonValue *)(aValue.getOptionalVal());
+
+			rNativeBoundingRegion = NWGetSpinButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+									aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_LISTBOX) && ((nPart==PART_BUTTON_DOWN) || (nPart==PART_SUB_EDIT)) )
+		{
+			rNativeBoundingRegion = NWGetListBoxButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+										aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+
+		pWidgetMutex->release();
+	}
+
+	return( returnVal );
+}
+
+
+/************************************************************************
+ * Individual control drawing functions
+ ************************************************************************/
+BOOL GtkSalGraphics::NWPaintGTKButton( ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		buttonRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	BOOL			bDrawFocus = TRUE;
+	gint			x, y, w, h;
+	GtkBorder		aDefBorder;
+	GtkBorder		aDefOutsideBorder;
+	GtkBorder*		pBorder;
+	GtkBorder*		pOutBorder;
+    GdkRectangle	clipRect;
+    
+	NWEnsureGTKButton();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	x = y = 0;
+	w = pixmapRect.getWidth();
+	h = pixmapRect.getHeight();
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gBtnWidget,	"focus-line-width",	&focusWidth,
+								"focus-padding", 	&focusPad,
+					 			"interior_focus",	&interiorFocus,
+								"default_border",	&pBorder,
+								"default_outside_border", &pOutBorder, NULL );
+
+	// Make sure the border values exist, otherwise use some defaults
+	if ( pBorder )
+	{
+		NW_gtk_border_set_from_border( aDefBorder, pBorder );
+		gtk_border_free( pBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefBorder, &aDefDefBorder );
+
+	if ( pOutBorder )
+	{
+		NW_gtk_border_set_from_border( aDefOutsideBorder, pOutBorder );
+		gtk_border_free( pOutBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefOutsideBorder, &aDefDefOutsideBorder );
+
+	// If the button is too small, don't ever draw focus or grab more space
+	if ( (w < 16) || (h < 16) )
+		bDrawFocus = FALSE;
+
+	// Some themes use these GTK flags to alter the appearance of the button
+	GTK_WIDGET_UNSET_FLAGS( gBtnWidget, GTK_HAS_DEFAULT );
+	GTK_WIDGET_UNSET_FLAGS( gBtnWidget, GTK_HAS_FOCUS );
+	GTK_WIDGET_UNSET_FLAGS( gBtnWidget, GTK_SENSITIVE );
+	if ( nState & CTRL_STATE_DEFAULT )
+		GTK_WIDGET_SET_FLAGS( gBtnWidget, GTK_HAS_DEFAULT );
+	if ( nState & CTRL_STATE_FOCUSED )
+		GTK_WIDGET_SET_FLAGS( gBtnWidget, GTK_HAS_FOCUS );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( gBtnWidget, GTK_SENSITIVE );
+
+	gtk_widget_set_state( gBtnWidget, stateType );
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+    
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	// Buttons must paint opaque since some themes have alpha-channel enabled buttons
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "base", x, y, w, h );
+
+	if ( (nState & CTRL_STATE_DEFAULT) && (GTK_BUTTON(gBtnWidget)->relief == GTK_RELIEF_NORMAL) )
+	{
+		gtk_paint_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_IN, 
+                       gdkRect, gBtnWidget, "buttondefault", x, y, w, h );
+	}
+
+	if ( (nState & CTRL_STATE_DEFAULT) && bDrawFocus )
+	{
+		x += aDefBorder.left;
+		y += aDefBorder.top;
+		w -= aDefBorder.left + aDefBorder.right;
+		h -= aDefBorder.top + aDefBorder.bottom;
+	}
+
+	if ( !interiorFocus && bDrawFocus )
+	{
+		x += focusWidth + focusPad;
+		y += focusWidth + focusPad;
+		w -= 2 * (focusWidth + focusPad);
+		h -= 2 * (focusWidth + focusPad);
+	}
+
+	if ( (GTK_BUTTON(gBtnWidget)->relief != GTK_RELIEF_NONE)
+		|| ((GTK_WIDGET_STATE(gBtnWidget) != GTK_STATE_NORMAL)
+		    && (GTK_WIDGET_STATE(gBtnWidget) != GTK_STATE_INSENSITIVE)) )
+	{
+		gtk_paint_box( gBtnWidget->style, gdkDrawable, stateType, shadowType,
+                       gdkRect, gBtnWidget, "button", x, y, w, h );
+	}
+
+	// Draw focus rect
+#if 0 // VCL draws focus rects
+	if ( (nState & CTRL_STATE_FOCUSED) && (nState & CTRL_STATE_ENABLED) && bDrawFocus )
+	{
+		if (interiorFocus)
+		{
+			x += gBtnWidget->style->xthickness + focusPad;
+			y += gBtnWidget->style->ythickness + focusPad;
+			w -= 2 * (gBtnWidget->style->xthickness + focusPad);
+			h -=  2 * (gBtnWidget->style->xthickness + focusPad);
+		}
+		else
+		{
+			x -= focusWidth + focusPad;
+			y -= focusWidth + focusPad;
+			w += 2 * (focusWidth + focusPad);
+			h += 2 * (focusWidth + focusPad);
+		}
+		if ( !interiorFocus )
+			gtk_paint_focus( gBtnWidget->style, gdkDrawable, stateType, gdkRect,
+                             gBtnWidget, "button", x, y, w, h );
+	}
+#endif
+
+//	gdk_draw_rectangle( pixmap, gBtnWidget->style->black_gc, false, 0, 0, pixmapRect.getWidth()-1, pixmapRect.getHeight()-1 );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+    
+	return( TRUE );
+}
+
+static Rectangle NWGetButtonArea( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption )
+{
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	GtkBorder		aDefBorder;
+	GtkBorder		aDefOutsideBorder;
+	GtkBorder *	pBorder;
+	GtkBorder *	pOutBorder;
+	BOOL			bDrawFocus = TRUE;
+	Rectangle		aRect;
+	gint			x, y, w, h;
+
+	NWEnsureGTKButton();
+	gtk_widget_style_get( gBtnWidget,	"focus-line-width",	&focusWidth,
+								"focus-padding", 	&focusPad,
+					 			"interior_focus",	&interiorFocus,
+								"default_border",	&pBorder,
+								"default_outside_border", &pOutBorder, NULL );
+
+	// Make sure the border values exist, otherwise use some defaults
+	if ( pBorder )
+	{
+		NW_gtk_border_set_from_border( aDefBorder, pBorder );
+		gtk_border_free( pBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefBorder, &aDefDefBorder );
+
+	if ( pOutBorder )
+	{
+		NW_gtk_border_set_from_border( aDefOutsideBorder, pOutBorder );
+		gtk_border_free( pOutBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefOutsideBorder, &aDefDefOutsideBorder );
+
+	x = aAreaRect.getX();
+	y = aAreaRect.getY();
+	w = aAreaRect.getWidth();
+	h = aAreaRect.getHeight();
+
+	// If the button is too small, don't ever draw focus or grab more space
+	if ( (w < 16) || (h < 16) )
+		bDrawFocus = FALSE;
+
+	if ( (nState & CTRL_STATE_DEFAULT) && bDrawFocus )
+	{
+		x -= aDefBorder.left;
+		y -= aDefBorder.top;
+		w += aDefBorder.left + aDefBorder.right;
+		h += aDefBorder.top + aDefBorder.bottom;
+	}
+
+	aRect.setX( x );
+	aRect.setY( y );
+	aRect.setWidth( w );
+	aRect.setHeight( h );
+
+	return( aRect );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKRadio( ControlType nType, ControlPart nPart,
+                                      const Region& rControlRegion, ControlState nState, 
+                                      const ImplControlValue& aValue, SalControlHandle& rControlHandle, 
+                                      OUString aCaption )
+{
+#define	RADIO_BUTTON_MINIMUMSIZE   14 // found by experiment, TODO: should be checked at runtime if possible 
+
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	BOOL			isChecked = (aValue.getTristateVal()==BUTTONVALUE_ON);
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+    gint            x, y;
+    GdkRectangle	clipRect;
+   
+	NWEnsureGTKButton();
+	NWEnsureGTKRadio();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+    x = y = 0;
+    
+    // assure minimum button size required by gtk+ to avoid clipping
+    if( pixmapRect.getWidth() < RADIO_BUTTON_MINIMUMSIZE )
+        pixmapRect.setWidth( RADIO_BUTTON_MINIMUMSIZE );
+    if( pixmapRect.getHeight() < RADIO_BUTTON_MINIMUMSIZE )
+        pixmapRect.setHeight( RADIO_BUTTON_MINIMUMSIZE );
+
+	// Set the shadow based on if checked or not so we get a freakin checkmark.
+	shadowType = isChecked ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+	NWSetWidgetState( gRadioWidget, nState, stateType );
+	NWSetWidgetState( gRadioWidgetSibling, nState, stateType );
+
+	// GTK enforces radio groups, so that if we don't have 2 buttons in the group,
+	// the single button will always be active.  So we have to have 2 buttons.
+	if (!isChecked)
+		gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gRadioWidgetSibling), TRUE );
+	gtk_widget_set_state( GTK_WIDGET(gRadioWidget), stateType );
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gRadioWidget), isChecked );
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+    
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+    gtk_paint_option( gRadioWidget->style, gdkDrawable, stateType, shadowType, 
+                      gdkRect, gRadioWidget, "radiobutton",
+                      x, y, pixmapRect.getWidth(), pixmapRect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+    
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKCheck( ControlType nType, ControlPart nPart,
+                                      const Region& rControlRegion, ControlState nState, 
+                                      const ImplControlValue& aValue,
+                                      SalControlHandle& rControlHandle, OUString aCaption )
+{
+#define	CHECKBOX_MINIMUMSIZE   14 // found by experiment, TODO: should be checked at runtime if possible 
+    
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		btnBoundRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	BOOL			isChecked = (aValue.getTristateVal()==BUTTONVALUE_ON) ? TRUE : FALSE;
+	gint			ctrlSize;
+    GdkRectangle	clipRect;
+    gint			x,y;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKCheck();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+    
+    // assure minimum button size required by gtk+ to avoid clipping
+    if( pixmapRect.getWidth() < CHECKBOX_MINIMUMSIZE )
+        pixmapRect.setWidth( CHECKBOX_MINIMUMSIZE );
+    if( pixmapRect.getHeight() < CHECKBOX_MINIMUMSIZE )
+        pixmapRect.setHeight( CHECKBOX_MINIMUMSIZE );
+    
+	btnBoundRect = pixmapRect;
+
+	// Set the shadow based on if checked or not so we get a freakin checkmark.
+	shadowType = isChecked ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+
+	gtk_widget_set_state( gCheckWidget, stateType );
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gCheckWidget), isChecked );
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = btnBoundRect.getX() - pixmapRect.getX();
+        y = btnBoundRect.getY() - pixmapRect.getY();
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = btnBoundRect.Left();
+        y = btnBoundRect.Top();
+    }
+
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	gtk_paint_check( gCheckWidget->style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, gCheckWidget, "checkbutton",
+                     x, y, btnBoundRect.getWidth(), btnBoundRect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKScrollbar( ControlType nType, ControlPart nPart,
+                                          const Region& rControlRegion, ControlState nState, 
+                                          const ImplControlValue& aValue, SalControlHandle& rControlHandle, 
+                                          OUString aCaption )
+{
+	ScrollbarValue* pScrollbarVal = (ScrollbarValue *)(aValue.getOptionalVal());
+	GdkPixmap	*	pixmap = NULL;
+	Rectangle		pixmapRect;
+	Rectangle		scrollbarRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	GtkScrollbar *	scrollbarWidget;
+	GtkStyle *	style;
+	GtkAdjustment* scrollbarValues = NULL;
+	GtkOrientation	scrollbarOrientation;
+	Rectangle		thumbRect = pScrollbarVal->maThumbRect;
+	Rectangle		button1BoundRect = pScrollbarVal->maButton1Rect;
+	Rectangle		button2BoundRect = pScrollbarVal->maButton2Rect;
+	GtkArrowType	button1Type;
+	GtkArrowType	button2Type;
+	gint			nButton1Extra = 0;
+	gint			nButton2Extra = 0;
+	gchar *		scrollbarTagH = (gchar *) "hscrollbar";
+	gchar *		scrollbarTagV = (gchar *) "vscrollbar";
+	gchar *		scrollbarTag = NULL;
+	Rectangle		arrow1Rect;
+	Rectangle		arrow2Rect;
+	gint			slider_width;
+	gint			stepper_size;
+	gint			stepper_spacing;
+	gint			trough_border;
+	gint			vShim = 0;
+	gint			hShim = 0;
+	gint			x,y;
+	GdkRectangle	clipRect;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKScrollbars();
+	NWEnsureGTKArrow();
+
+    // as multiple paints are required for the scrollbar
+	// painting them directly to the window flickers
+    BOOL bUseWindow = FALSE; //(GetNumCliprects() == 1);
+    
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+	pixmapRect.setWidth( pixmapRect.getWidth() + 1 );
+	pixmapRect.setHeight( pixmapRect.getHeight() + 1 );
+	scrollbarRect = pixmapRect;
+	if ( (scrollbarRect.getWidth() <= 1) || (scrollbarRect.getHeight() <= 1) )
+		return( TRUE );
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gScrollHorizWidget, "slider_width", &slider_width,
+									  "stepper_size", &stepper_size,
+									  "trough_border", &trough_border,
+									  "stepper_spacing", &stepper_spacing, NULL );
+
+	if ( nPart == PART_DRAW_BACKGROUND_HORZ )
+	{
+		unsigned int	sliderHeight = slider_width + (trough_border * 2);
+		vShim = (pixmapRect.getHeight() - sliderHeight) / 2;
+
+		if ( sliderHeight < scrollbarRect.getHeight() );
+		{
+			scrollbarRect.Move( 0, vShim );
+			scrollbarRect.setHeight( sliderHeight );
+		}
+
+		scrollbarWidget = GTK_SCROLLBAR( gScrollHorizWidget );
+		scrollbarOrientation = GTK_ORIENTATION_HORIZONTAL;
+		scrollbarTag = scrollbarTagH;
+		button1Type = GTK_ARROW_LEFT;
+		button2Type = GTK_ARROW_RIGHT;
+
+		button1BoundRect.setX( (button1BoundRect.getWidth()-stepper_size) / 2 );
+		button1BoundRect.setY( ((button1BoundRect.getHeight()-vShim)-slider_width) / 2 );
+		button1BoundRect.setHeight( slider_width );
+		button1BoundRect.setWidth( stepper_size );
+		nButton1Extra = (pScrollbarVal->maButton1Rect.getX() + pScrollbarVal->maButton1Rect.getWidth()) - 
+				(button1BoundRect.getX() + button1BoundRect.getWidth());
+
+		button2BoundRect.setX( scrollbarRect.getWidth() - button2BoundRect.getWidth() + ((button2BoundRect.getWidth()-stepper_size) / 2) );
+		button2BoundRect.setY( ((button2BoundRect.getHeight()-vShim)-slider_width) / 2 );
+		button2BoundRect.setHeight( slider_width );
+		button2BoundRect.setWidth( stepper_size );
+		nButton2Extra =  button2BoundRect.getX() - pScrollbarVal->maButton2Rect.getX();
+
+		thumbRect.setHeight( slider_width );
+		// Center vertically in the track
+		thumbRect.Move( 0, (scrollbarRect.getHeight() - slider_width) / 2 );
+
+		// Themes may have a different idea of what the scrollbar stepper button
+		// size should be, so we have to adjust the Thumbs rectangle to account
+		// for the difference between OOo's idea and the theme's
+		thumbRect.Move( -nButton1Extra, 0 );
+		thumbRect.setWidth( thumbRect.getWidth() + nButton1Extra + nButton2Extra );
+	}
+	else
+	{
+		unsigned int	sliderWidth = slider_width + (trough_border * 2);
+		hShim = (pixmapRect.getWidth() - sliderWidth) / 2;
+
+		if ( sliderWidth < scrollbarRect.getWidth() );
+		{
+			scrollbarRect.Move( hShim, 0 );
+			scrollbarRect.setWidth( sliderWidth );
+		}
+
+		scrollbarWidget = GTK_SCROLLBAR( gScrollVertWidget );
+		scrollbarOrientation = GTK_ORIENTATION_VERTICAL;
+		scrollbarTag = scrollbarTagV;
+		button1Type = GTK_ARROW_UP;
+		button2Type = GTK_ARROW_DOWN;
+
+		button1BoundRect.setX( ((button1BoundRect.getWidth()-hShim)-slider_width) / 2 );
+		button1BoundRect.setY( (button1BoundRect.getHeight()-stepper_size) / 2 );
+		button1BoundRect.setHeight( stepper_size );
+		button1BoundRect.setWidth( slider_width );
+		nButton1Extra = (pScrollbarVal->maButton1Rect.getY() + pScrollbarVal->maButton1Rect.getHeight()) - 
+				(button1BoundRect.getY() + button1BoundRect.getHeight());
+
+		button2BoundRect.setX( ((button2BoundRect.getWidth()-hShim)-slider_width) / 2 );
+		button2BoundRect.setY( scrollbarRect.getHeight() - button2BoundRect.getHeight() + ((button2BoundRect.getHeight()-stepper_size) / 2) );
+		button2BoundRect.setHeight( stepper_size );
+		button2BoundRect.setWidth( slider_width );
+		nButton2Extra =  button2BoundRect.getY() - pScrollbarVal->maButton2Rect.getY();
+
+		thumbRect.setWidth( slider_width );
+		// Center horizontally in the track
+		thumbRect.Move( (scrollbarRect.getWidth() - slider_width) / 2, 0 );
+
+		// Themes may have a different idea of what the scrollbar stepper button
+		// size should be, so we have to adjust the Thumbs rectangle to account
+		// for the difference between OOo's idea and the theme's
+		thumbRect.Move( 0, -nButton1Extra );
+		thumbRect.setHeight( thumbRect.getHeight() + nButton1Extra + nButton2Extra );
+	}
+
+	scrollbarValues = gtk_range_get_adjustment( GTK_RANGE(scrollbarWidget) );
+	if ( scrollbarValues == NULL )
+		scrollbarValues = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+	if ( nPart == PART_DRAW_BACKGROUND_HORZ )
+	{
+		scrollbarValues->lower = pScrollbarVal->mnMin;
+		scrollbarValues->upper = pScrollbarVal->mnMax;
+		scrollbarValues->value = pScrollbarVal->mnCur;
+		scrollbarValues->page_size = scrollbarRect.getWidth() / 2;
+	}
+	else
+	{
+		scrollbarValues->lower = pScrollbarVal->mnMin;
+		scrollbarValues->upper = pScrollbarVal->mnMax;
+		scrollbarValues->value = pScrollbarVal->mnCur;
+		scrollbarValues->page_size = scrollbarRect.getHeight() / 2;
+	}
+	gtk_adjustment_changed( scrollbarValues );
+
+	// Size the arrow appropriately
+	arrow1Rect.setWidth ( button1BoundRect.getWidth()  / 2 );
+	arrow1Rect.setHeight( button1BoundRect.getHeight() / 2 );
+	arrow2Rect.setWidth ( button2BoundRect.getWidth()  / 2 );
+	arrow2Rect.setHeight( button2BoundRect.getHeight() / 2 );
+
+	arrow1Rect.setX( button1BoundRect.getX() + (button1BoundRect.getWidth()  - arrow1Rect.getWidth() ) / 2 );
+	arrow1Rect.setY( button1BoundRect.getY() + (button1BoundRect.getHeight() - arrow1Rect.getHeight()) / 2 );
+	arrow2Rect.setX( button2BoundRect.getX() + (button2BoundRect.getWidth()  - arrow2Rect.getWidth() ) / 2 );
+	arrow2Rect.setY( button2BoundRect.getY() + (button2BoundRect.getHeight() - arrow2Rect.getHeight()) / 2 );
+
+	if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+	style = GTK_WIDGET( scrollbarWidget )->style;
+
+	// ----------------- TROUGH
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, 
+                        GTK_STATE_NORMAL, GTK_SHADOW_NONE, gdkRect,
+                        gBtnWidget, "base", x, y, 
+                        pixmapRect.getWidth(), pixmapRect.getHeight() );
+	gtk_paint_box( style, gdkDrawable, GTK_STATE_ACTIVE, GTK_SHADOW_IN, 
+                   gdkRect, GTK_WIDGET(scrollbarWidget), "trough",
+                   x+(scrollbarRect.getX() - pixmapRect.getX()), 
+                   y+(scrollbarRect.getY()-pixmapRect.getY()),
+                   scrollbarRect.getWidth(), scrollbarRect.getHeight() );
+
+	if ( nState & CTRL_STATE_FOCUSED )
+	{
+		gtk_paint_focus( style, gdkDrawable, GTK_STATE_ACTIVE, 
+                         gdkRect, GTK_WIDGET(scrollbarWidget), "trough",
+                         x+(scrollbarRect.getX() - pixmapRect.getX()), 
+                         y+(scrollbarRect.getY()-pixmapRect.getY()),
+                         scrollbarRect.getWidth(), scrollbarRect.getHeight() );
+	}
+
+	// ----------------- THUMB
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnThumbState, &stateType, &shadowType );
+	if ( pScrollbarVal->mnThumbState & CTRL_STATE_PRESSED )  stateType = GTK_STATE_PRELIGHT;
+	gtk_paint_slider( style, gdkDrawable, stateType, GTK_SHADOW_OUT, 
+                      gdkRect, GTK_WIDGET(scrollbarWidget), "slider",
+                      x+hShim+thumbRect.getX(), y+vShim+thumbRect.getY(), 
+                      thumbRect.getWidth(), thumbRect.getHeight(), scrollbarOrientation );
+
+	// ----------------- BUTTON 1
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnButton1State, &stateType, &shadowType );
+	if ( stateType == GTK_STATE_INSENSITIVE )	stateType = GTK_STATE_NORMAL;
+	gtk_paint_box( style, gdkDrawable, stateType, shadowType, 
+                   gdkRect, GTK_WIDGET(scrollbarWidget), "stepper",
+                   x+hShim+button1BoundRect.getX(), y+vShim+button1BoundRect.getY(), 
+                   button1BoundRect.getWidth(), button1BoundRect.getHeight() );
+	// ----------------- ARROW 1
+	gtk_paint_arrow( style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, GTK_WIDGET(scrollbarWidget), scrollbarTag, button1Type, TRUE,
+                     x+hShim+arrow1Rect.getX(), y+vShim+arrow1Rect.getY(), 
+                     arrow1Rect.getWidth(), arrow1Rect.getHeight() );
+
+	// ----------------- BUTTON 2
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnButton2State, &stateType, &shadowType );
+	if ( stateType == GTK_STATE_INSENSITIVE )	stateType = GTK_STATE_NORMAL;
+	gtk_paint_box( style, gdkDrawable, stateType, shadowType, gdkRect, 
+                   GTK_WIDGET(scrollbarWidget), "stepper",
+                   x+hShim+button2BoundRect.getX(), y+vShim+button2BoundRect.getY(), 
+                   button2BoundRect.getWidth(), button2BoundRect.getHeight() );
+	// ----------------- ARROW 2
+	gtk_paint_arrow( style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, GTK_WIDGET(scrollbarWidget), scrollbarTag, button2Type, TRUE,
+                     x+hShim+arrow2Rect.getX(), y+vShim+arrow2Rect.getY(), 
+                     arrow2Rect.getWidth(), arrow2Rect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKEditBox( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue, SalControlHandle& rControlHandle, 
+                                        OUString aCaption )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = NWGetEditBoxPixmapRect( nType, nPart, rControlRegion.GetBoundRect(),
+					nState, aValue, rControlHandle, aCaption );
+
+	pixmap = NWGetPixmapFromScreen( pixmapRect );
+	if ( !pixmap )
+		return( FALSE );
+
+	// NWPaintOneEditBox() requires pixmap local
+	Rectangle		aEditBoxRect = rControlRegion.GetBoundRect();
+	aEditBoxRect.setX( rControlRegion.GetBoundRect().getX() - pixmapRect.getX() );
+	aEditBoxRect.setY( rControlRegion.GetBoundRect().getY() - pixmapRect.getY() );
+
+	NWPaintOneEditBox( pixmap, NULL, nType, nPart, aEditBoxRect, nState, aValue, rControlHandle, aCaption );
+
+	if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+
+/* Take interior/exterior focus into account and return
+ * the bounding rectangle of the edit box including
+ * any focus requirements.
+ */
+static Rectangle NWGetEditBoxPixmapRect(ControlType			nType,
+								ControlPart			nPart,
+								Rectangle				aAreaRect,
+								ControlState			nState,
+								const ImplControlValue&	aValue,
+								SalControlHandle&		rControlHandle,
+								OUString				aCaption )
+{
+	Rectangle		pixmapRect = aAreaRect;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+
+	NWEnsureGTKEditBox();
+
+	// Grab some entry style attributes
+	gtk_widget_style_get( gEditBoxWidget,	"focus-line-width",	&focusWidth,
+					 				"interior-focus",	&interiorFocus, NULL );
+
+	if ( !interiorFocus )
+	{
+		pixmapRect.Move( -(focusWidth), -(focusWidth) );
+		pixmapRect.setWidth( pixmapRect.getWidth() + (2*(focusWidth)) );
+		pixmapRect.setHeight( pixmapRect.getHeight() + (2*(focusWidth)) );
+	}
+
+	return( pixmapRect );
+}
+
+
+/* Paint a GTK Entry widget into the specified GdkPixmap.
+ * All coordinates should be local to the Pixmap, NOT
+ * screen/window coordinates.
+ */
+static void NWPaintOneEditBox(	GdkWindow * gdkDrawable,
+                                GdkRectangle *	gdkRect,
+							ControlType			nType,
+							ControlPart			nPart,
+							Rectangle				aEditBoxRect,
+							ControlState			nState,
+							const ImplControlValue&	aValue,
+							SalControlHandle&		rControlHandle,
+							OUString				aCaption )
+{
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	GtkWidget *	widget;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKEditBox();
+	NWEnsureGTKSpinButton();
+	NWEnsureGTKCombo();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	switch ( nType )
+	{
+		case CTRL_COMBOBOX:
+		case CTRL_SPINBOX:
+			widget = gSpinButtonWidget;
+			break;
+
+//		case CTRL_COMBOBOX:
+//			widget = gComboWidget;
+//			break;
+
+		default:
+			widget = gEditBoxWidget;
+			break;
+	}
+
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_HAS_DEFAULT );
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_HAS_FOCUS );
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_SENSITIVE );
+	if ( nState & CTRL_STATE_DEFAULT )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_HAS_DEFAULT );
+	if ( nState & CTRL_STATE_FOCUSED )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_HAS_FOCUS );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_SENSITIVE );
+
+	gtk_widget_set_state( widget, stateType );
+
+	// Blueprint needs to paint entry_bg with a Button widget, not an Entry widget to get
+	// a nice white (or whatever default color) background
+	if ( stateType == GTK_STATE_PRELIGHT )
+		stateType = GTK_STATE_NORMAL;
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, stateType, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "entry_bg",
+                        aEditBoxRect.getX(), aEditBoxRect.getY(), 
+                        aEditBoxRect.getWidth(), aEditBoxRect.getHeight() );
+
+	gtk_paint_shadow( widget->style, gdkDrawable, GTK_STATE_NORMAL, shadowType, 
+                      gdkRect, widget, "entry",
+                      aEditBoxRect.getX(), aEditBoxRect.getY(), 
+                      aEditBoxRect.getWidth(), aEditBoxRect.getHeight() );
+
+	// Grab some entry style attributes
+	gtk_widget_style_get( gEditBoxWidget,	"focus-line-width",	&focusWidth,
+					 				"interior-focus",	&interiorFocus, NULL );
+	// Draw focus rect
+#if 0   // vcl draws focus rects
+	if ( nState & CTRL_STATE_FOCUSED )
+	{
+		if ( !interiorFocus )
+		{
+			Rectangle aFocusRect = aEditBoxRect;
+
+			aFocusRect.Move( -(focusWidth), -(focusWidth) );
+			aFocusRect.setWidth( aFocusRect.getWidth() + (2*(focusWidth)) );
+			aFocusRect.setHeight( aFocusRect.getHeight() + (2*(focusWidth)) );
+
+			gtk_paint_focus( widget->style, gdkDrawable, stateType, gdkRect, widget, "entry", 
+				aFocusRect.getX(), aFocusRect.getY(), aFocusRect.getWidth(), aFocusRect.getHeight() );
+		}
+	}
+#endif
+}
+
+
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKSpinBox( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue,
+                                        SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap	*		pixmap;
+	Rectangle			pixmapRect;
+	GtkStateType		stateType;
+	GtkShadowType		shadowType;
+	SpinbuttonValue *	pSpinVal = (SpinbuttonValue *)(aValue.getOptionalVal());
+	Rectangle			upBtnRect;
+	ControlPart		upBtnPart = PART_BUTTON_UP;
+	ControlState		upBtnState = CTRL_STATE_ENABLED;
+	Rectangle			downBtnRect;
+	ControlPart		downBtnPart = PART_BUTTON_DOWN;
+	ControlState		downBtnState = CTRL_STATE_ENABLED;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKSpinButton();
+	NWEnsureGTKArrow();
+
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	if ( pSpinVal )
+	{
+		upBtnPart = pSpinVal->mnUpperPart;
+		upBtnState = pSpinVal->mnUpperState;
+
+		downBtnPart = pSpinVal->mnLowerPart;
+		downBtnState = pSpinVal->mnLowerState;
+	}
+
+	// CTRL_SPINBUTTONS pass their area in pSpinVal, not in rControlRegion
+	if ( nType == CTRL_SPINBUTTONS )
+	{
+		if ( !pSpinVal )
+		{
+			fprintf( stderr, "Tried to draw CTRL_SPINBUTTONS, but the SpinButtons data structure didn't exist!\n" );
+			return( false );
+		}
+		pixmapRect = pSpinVal->maUpperRect;
+		pixmapRect.Union( pSpinVal->maLowerRect );
+	}
+	else
+		pixmapRect = rControlRegion.GetBoundRect();
+
+
+	pixmap = NWGetPixmapFromScreen( pixmapRect );
+	if ( !pixmap )
+		return( FALSE );
+
+	upBtnRect = NWGetSpinButtonRect( nType, upBtnPart, pixmapRect, upBtnState, aValue, rControlHandle, aCaption );
+	downBtnRect = NWGetSpinButtonRect( nType, downBtnPart, pixmapRect, downBtnState, aValue, rControlHandle, aCaption );
+
+	if ( (nType==CTRL_SPINBOX) && (nPart!=PART_ALL_BUTTONS) )
+	{
+		// Draw an edit field for SpinBoxes and ComboBoxes
+		Rectangle aEditBoxRect( pixmapRect );
+		aEditBoxRect.setWidth( upBtnRect.getX() - pixmapRect.getX() );
+		aEditBoxRect.setX( 0 );
+		aEditBoxRect.setY( 0 );
+
+		NWPaintOneEditBox( pixmap, NULL, nType, nPart, aEditBoxRect, nState, aValue, rControlHandle, aCaption );
+	}
+
+	gtk_widget_style_get( gSpinButtonWidget, "shadow_type", &shadowType, NULL );
+
+	if ( shadowType != GTK_SHADOW_NONE )
+	{
+		Rectangle		shadowRect( upBtnRect );
+
+		shadowRect.Union( downBtnRect );
+		gtk_paint_box( gSpinButtonWidget->style, pixmap, GTK_STATE_NORMAL, shadowType, NULL,
+			gSpinButtonWidget, "spinbutton",
+			(shadowRect.getX() - pixmapRect.getX()), (shadowRect.getY() - pixmapRect.getY()),
+			shadowRect.getWidth(), shadowRect.getHeight() );
+	}
+
+	NWPaintOneSpinButton( pixmap, nType, upBtnPart, pixmapRect, upBtnState, aValue, rControlHandle, aCaption );
+	NWPaintOneSpinButton( pixmap, nType, downBtnPart, pixmapRect, downBtnState, aValue, rControlHandle, aCaption );
+
+	if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//---
+
+static Rectangle NWGetSpinButtonRect(	ControlType			nType,
+								ControlPart			nPart,
+								Rectangle 			aAreaRect,
+								ControlState			nState,
+								const ImplControlValue&	aValue,
+								SalControlHandle&		rControlHandle,
+								OUString				aCaption )
+{
+	gint			buttonSize;
+	Rectangle		buttonRect;
+
+	NWEnsureGTKSpinButton();
+
+	buttonSize = MAX( PANGO_PIXELS( pango_font_description_get_size(GTK_WIDGET(gSpinButtonWidget)->style->font_desc) ),
+				   MIN_SPIN_ARROW_WIDTH );
+	buttonSize -= buttonSize % 2 - 1; /* force odd */
+	buttonRect.setWidth( buttonSize + 2 * gSpinButtonWidget->style->xthickness );
+	buttonRect.setX( aAreaRect.getX() + (aAreaRect.getWidth() - buttonRect.getWidth()) );
+	buttonRect.setHeight( (aAreaRect.getHeight() / 2) );
+	if ( nPart == PART_BUTTON_UP )
+        buttonRect.setY( aAreaRect.getY() );
+	else
+    {
+        buttonRect.Top() = aAreaRect.getY() + (aAreaRect.getHeight() / 2);
+        buttonRect.Bottom() = aAreaRect.Bottom(); // cover area completely
+    }
+
+	return( buttonRect );
+}
+
+//---
+
+static void NWPaintOneSpinButton(	GdkPixmap	*			pixmap,
+							ControlType			nType,
+							ControlPart			nPart,
+							Rectangle				aAreaRect,
+							ControlState			nState,
+							const ImplControlValue&	aValue,
+							SalControlHandle&		rControlHandle,
+							OUString				aCaption )
+{
+	Rectangle			buttonRect;
+	GtkStateType		stateType;
+	GtkShadowType		shadowType;
+	Rectangle			arrowRect;
+	gint				arrowSize;
+
+	NWEnsureGTKSpinButton();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+//	gtk_widget_set_state( gSpinButtonWidget, stateType );
+
+	buttonRect = NWGetSpinButtonRect( nType, nPart, aAreaRect, nState, aValue, rControlHandle, aCaption );
+
+	GTK_WIDGET_UNSET_FLAGS( gSpinButtonWidget, GTK_SENSITIVE );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( gSpinButtonWidget, GTK_SENSITIVE );
+
+	gtk_paint_box( gSpinButtonWidget->style, pixmap, stateType, shadowType, NULL, gSpinButtonWidget,
+			(nPart == PART_BUTTON_UP) ? "spinbutton_up" : "spinbutton_down",
+			(buttonRect.getX() - aAreaRect.getX()), (buttonRect.getY() - aAreaRect.getY()),
+			buttonRect.getWidth(), buttonRect.getHeight() );
+
+	arrowSize = (buttonRect.getWidth() - (2 * gSpinButtonWidget->style->xthickness)) - 4;
+	arrowSize -= arrowSize % 2 - 1; /* force odd */
+	arrowRect.setWidth( arrowSize );
+	arrowRect.setHeight( arrowRect.getWidth() );
+	arrowRect.setX( buttonRect.getX() + (buttonRect.getWidth() - arrowRect.getWidth()) / 2 );
+	if ( nPart == PART_BUTTON_UP )
+		arrowRect.setY( buttonRect.getY() + (buttonRect.getHeight() - arrowRect.getHeight()) / 2 + 1);
+	else
+		arrowRect.setY( buttonRect.getY() + (buttonRect.getHeight() - arrowRect.getHeight()) / 2 - 1);
+
+	gtk_paint_arrow( gSpinButtonWidget->style, pixmap, GTK_STATE_NORMAL, GTK_SHADOW_OUT, NULL, gSpinButtonWidget,
+			"spinbutton", (nPart == PART_BUTTON_UP) ? GTK_ARROW_UP : GTK_ARROW_DOWN, TRUE,
+			(arrowRect.getX() - aAreaRect.getX()), (arrowRect.getY() - aAreaRect.getY()),
+			arrowRect.getWidth(), arrowRect.getHeight() );
+}
+
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKComboBox( ControlType nType, ControlPart nPart,
+                                         const Region& rControlRegion, ControlState nState, 
+                                         const ImplControlValue& aValue,
+                                         SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap	*	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		buttonRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	Rectangle		arrowRect;
+	gint			arrowSize;
+    gint			x,y;
+    GdkRectangle	clipRect;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKArrow();
+	NWEnsureGTKCombo();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+    buttonRect = NWGetComboBoxButtonRect( nType, nPart, pixmapRect, nState, aValue, rControlHandle, aCaption );
+
+	Rectangle		aEditBoxRect( pixmapRect );
+	aEditBoxRect.setWidth( pixmapRect.getWidth() - buttonRect.getWidth() );
+	aEditBoxRect.setX( x );
+	aEditBoxRect.setY( y );
+
+	NWPaintOneEditBox( gdkDrawable, gdkRect, nType, nPart, aEditBoxRect, 
+                       nState, aValue, rControlHandle, aCaption );
+
+//	gtk_widget_set_state( gComboWidget, stateType );
+
+	// Buttons must paint opaque since some themes have alpha-channel enabled buttons
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "base", 
+                        x+(buttonRect.getX() - pixmapRect.getX()), 
+                        y+(buttonRect.getY() - pixmapRect.getY()),
+                        buttonRect.getWidth(), buttonRect.getHeight() );
+	gtk_paint_box( GTK_COMBO(gComboWidget)->button->style, gdkDrawable, stateType, shadowType,
+                   gdkRect, GTK_COMBO(gComboWidget)->button, "button",
+                   x+(buttonRect.getX() - pixmapRect.getX()), 
+                   y+(buttonRect.getY() - pixmapRect.getY()),
+                   buttonRect.getWidth(), buttonRect.getHeight() );
+
+#define ARROW_EXTENT		0.7
+	arrowRect.setWidth( (gint)(MIN_ARROW_SIZE * ARROW_EXTENT) );
+	arrowRect.setHeight( (gint)(MIN_ARROW_SIZE * ARROW_EXTENT) );
+	arrowRect.setX( buttonRect.getX() + (gint)((buttonRect.getWidth() - arrowRect.getWidth()) / 2)  );
+	arrowRect.setY( buttonRect.getY() + (gint)((buttonRect.getHeight() - arrowRect.getHeight()) / 2)  );
+
+	gtk_paint_arrow( gArrowWidget->style, gdkDrawable, stateType, shadowType,
+			gdkRect, gArrowWidget, "arrow", GTK_ARROW_DOWN, TRUE,
+			x+(arrowRect.getX() - pixmapRect.getX()), y+(arrowRect.getY() - pixmapRect.getY()),
+			arrowRect.getWidth(), arrowRect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+
+	return( TRUE );
+}
+
+//----
+
+static Rectangle NWGetComboBoxButtonRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle	aButtonRect;
+	gint		nArrowWidth;
+	gint		nFocusWidth;
+	gint		nFocusPad;
+
+	NWEnsureGTKArrow();
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gDropdownWidget,	"focus-line-width",	&nFocusWidth,
+									"focus-padding", 	&nFocusPad, NULL );
+
+	nArrowWidth = MIN_ARROW_SIZE + (GTK_MISC(gArrowWidget)->xpad * 2);
+	aButtonRect.setY( aAreaRect.getY() );
+	aButtonRect.setHeight( aAreaRect.getHeight() );
+	aButtonRect.setWidth( nArrowWidth + ((BTN_CHILD_SPACING + gDropdownWidget->style->xthickness) * 2)
+						+ (2 * (nFocusWidth+nFocusPad)) );
+	aButtonRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - aButtonRect.getWidth() );
+
+	return( aButtonRect );
+}
+
+//-------------------------------------
+
+
+    
+BOOL GtkSalGraphics::NWPaintGTKTabItem( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue,
+                                        SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		tabRect;
+	TabitemValue *	pTabitemValue = (TabitemValue *)(aValue.getOptionalVal());
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+    static NWPixmapCache aCacheItems;
+    static NWPixmapCache aCachePage;
+
+    if( !aCacheItems.GetSize() )
+        aCacheItems.SetSize( 20 );
+    if( !aCachePage.GetSize() )
+        aCachePage.SetSize( 1 );
+    
+	if ( !pTabitemValue && (nType==CTRL_TAB_ITEM) )
+	{
+		fprintf( stderr, "NWPaintGTKTabItem() received a NULL TabitemValue.  Cannot draw native tab\n" );
+		return( false );
+	}
+
+	NWEnsureGTKButton();
+	NWEnsureGTKNotebook();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	if ( nType == CTRL_TAB_ITEM )
+	{
+		if ( !pTabitemValue->isFirst() )
+		{
+			// GTK+ tabs overlap on the right edge (the top tab obscures the
+			// left edge of the tab right "below" it, so adjust the rectangle
+			// to draw tabs slightly large so the overlap happens
+			pixmapRect.Move( -2, 0 );
+			pixmapRect.setWidth( pixmapRect.getWidth() + 2 );
+		}
+		if ( nState & CTRL_STATE_SELECTED )
+		{
+			// In GTK+, the selected tab is 2px taller than all other tabs
+			pixmapRect.setY( pixmapRect.getY() - 2 );
+			pixmapRect.setHeight( pixmapRect.getHeight() + 3 );
+			tabRect = pixmapRect;
+			// Only draw over 1 pixel of the tab pane that this tab is drawn on top of.
+			tabRect.setHeight( tabRect.getHeight() - 1 );
+		}
+		else
+			tabRect = pixmapRect;
+
+		// Allow the tab to draw a right border if needed
+		tabRect.setWidth( tabRect.getWidth() - 1 );
+	}
+
+    if( nType == CTRL_TAB_ITEM )
+    {
+        if( aCacheItems.Find( nType, nState, pixmapRect, &pixmap ) )
+            return NWRenderPixmapToScreen( pixmap, pixmapRect );
+    }
+    else
+    {
+        if( aCachePage.Find( nType, nState, pixmapRect, &pixmap ) )
+            return NWRenderPixmapToScreen( pixmap, pixmapRect );
+    }
+
+        
+//	gtk_widget_set_state( gNotebookWidget, stateType );
+
+	pixmap = NWGetPixmapFromScreen( pixmapRect );
+	if ( !pixmap )
+		return( FALSE );
+
+	switch( nType )
+	{
+		case CTRL_TAB_BODY:
+			break;
+
+		case CTRL_FIXEDBORDER:
+		case CTRL_TAB_PANE:
+			gtk_paint_box_gap( gNotebookWidget->style, pixmap, GTK_STATE_NORMAL, GTK_SHADOW_OUT, NULL, gNotebookWidget,
+				(char *)"notebook", 0, 0, pixmapRect.getWidth(), pixmapRect.getHeight(), GTK_POS_TOP, 0, 0 );
+			break;
+
+		case CTRL_TAB_ITEM:
+			stateType = ( nState & CTRL_STATE_SELECTED ) ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE;
+
+			gtk_paint_extension( gNotebookWidget->style, pixmap, stateType, GTK_SHADOW_OUT, NULL, gNotebookWidget,
+				(char *)"tab", (tabRect.getX() - pixmapRect.getX()), (tabRect.getY() - pixmapRect.getY()),
+				tabRect.getWidth(), tabRect.getHeight(), GTK_POS_BOTTOM );
+
+			if ( nState & CTRL_STATE_SELECTED )
+			{
+				gtk_paint_flat_box( gNotebookWidget->style, pixmap, stateType, GTK_SHADOW_NONE, NULL, gNotebookWidget,
+					(char *)"base", 0, (pixmapRect.getHeight() - 2), pixmapRect.getWidth(), 1 );
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	// Crux seems to think it can make the pane without a left edge
+	if ( nType == CTRL_FIXEDBORDER )
+		pixmapRect.Move( 1, 0 );
+
+    // cache data
+    if( GetGtkFrame()->getVisibilityState() == GDK_VISIBILITY_UNOBSCURED ) 
+    {
+        if( nType == CTRL_TAB_ITEM )
+            aCacheItems.Fill( nType, nState, pixmapRect, pixmap );
+        else
+            aCachePage.Fill( nType, nState, pixmapRect, pixmap );
+    }
+        
+	if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+    
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKListBox( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue,
+                                        SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap	*	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		widgetRect;
+	Rectangle		aIndicatorRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gint			bInteriorFocus;
+	gint			nFocusLineWidth;
+	gint			nFocusPadding;
+    gint			x,y;
+    GdkRectangle    clipRect;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKOptionMenu();
+	NWEnsureGTKScrolledWindow();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	if ( nPart == PART_WINDOW )
+	{
+		// Make the widget a _bit_ bigger
+		pixmapRect.setX( pixmapRect.getX() - 1 );
+		pixmapRect.setY( pixmapRect.getY() - 1 );
+		pixmapRect.setWidth( pixmapRect.getWidth() + 2 );
+		pixmapRect.setHeight( pixmapRect.getHeight() + 2 );
+	}
+
+	widgetRect = pixmapRect;
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	if ( nPart != PART_WINDOW )
+	{
+		gtk_widget_style_get( gOptionMenuWidget,
+			"interior_focus",	&bInteriorFocus,
+			"focus_line_width",	&nFocusLineWidth,
+			"focus_padding",	&nFocusPadding,
+			NULL);
+
+		// Listboxes must paint opaque since some themes have alpha-channel enabled bodies
+		gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                            gdkRect, gBtnWidget, "base", x, y, 
+                            pixmapRect.getWidth(), pixmapRect.getHeight() );
+
+		gtk_paint_box( gOptionMenuWidget->style, gdkDrawable, stateType, shadowType, gdkRect,
+                       gOptionMenuWidget, "optionmenu",
+                       x+(widgetRect.getX() - pixmapRect.getX()), 
+                       y+(widgetRect.getY() - pixmapRect.getY()),
+                       widgetRect.getWidth(), widgetRect.getHeight() );
+
+		aIndicatorRect = NWGetListBoxIndicatorRect( nType, nPart, widgetRect, nState, 
+                                                    aValue, rControlHandle, aCaption );
+		gtk_paint_tab( gOptionMenuWidget->style, gdkDrawable, stateType, shadowType, gdkRect,
+                       gOptionMenuWidget, "op  tionmenutab",
+                       x+(aIndicatorRect.getX() - pixmapRect.getX()), 
+                       y+(aIndicatorRect.getY() - pixmapRect.getY()),
+                       aIndicatorRect.getWidth(), aIndicatorRect.getHeight() );
+	}
+	else
+	{
+		gtk_paint_shadow( gScrolledWindowWidget->style, gdkDrawable, GTK_STATE_NORMAL, shadowType,
+			gdkRect, gScrolledWindowWidget, "scrolled_window",
+			x+(widgetRect.getX() - pixmapRect.getX()), y+(widgetRect.getY() - pixmapRect.getY()),
+			widgetRect.getWidth(), widgetRect.getHeight() );
+	}
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+	g_object_unref( pixmap );
+    }
+
+	return( TRUE );
+}
+
+//----
+
+static Rectangle NWGetListBoxButtonRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle 		aPartRect;
+	GtkRequisition *	pIndicatorSize;
+	GtkBorder *		pIndicatorSpacing;
+	gint				width = 13;	// GTK+ default
+	gint				left  = 7;	// GTK+ default
+	gint				right = 5;	// GTK+ default
+	gint				nButtonAreaWidth = 0;
+
+	NWEnsureGTKOptionMenu();
+
+	gtk_widget_style_get( gOptionMenuWidget,
+			"indicator_size",	&pIndicatorSize,
+			"indicator_spacing",&pIndicatorSpacing, NULL);
+	
+	if ( pIndicatorSize && ((pIndicatorSize->width < 20) || (pIndicatorSize->width >= 0)) )
+		width = pIndicatorSize->width;
+
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->right < 20) || (pIndicatorSpacing->right >= 0)) )
+		right = pIndicatorSpacing->right;
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->left < 20) || (pIndicatorSpacing->left >= 0)) )
+		left = pIndicatorSpacing->left;
+
+	aPartRect.setHeight( aAreaRect.getHeight() );
+	aPartRect.setY( aAreaRect.getY() );
+
+	nButtonAreaWidth = width + right + (gOptionMenuWidget->style->xthickness * 2);
+	switch( nPart )
+	{
+		case PART_BUTTON_DOWN:
+			aPartRect.setWidth( nButtonAreaWidth );
+			aPartRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - aPartRect.getWidth() );
+			break;
+
+		case PART_SUB_EDIT:
+			aPartRect.setWidth( aAreaRect.getWidth() - nButtonAreaWidth );
+			aPartRect.setX( aAreaRect.getX() );
+			break;
+
+		default:
+			aPartRect.setWidth( aAreaRect.getWidth() );	
+			aPartRect.setX( aAreaRect.getX() );
+			break;
+	}
+
+	if ( pIndicatorSize )
+		g_free( pIndicatorSize );
+	if ( pIndicatorSpacing )
+		g_free( pIndicatorSpacing );
+
+	return( aPartRect );
+}
+
+//----
+
+static Rectangle NWGetListBoxIndicatorRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle 		aIndicatorRect;
+	GtkRequisition *	pIndicatorSize;
+	GtkBorder *		pIndicatorSpacing;
+	gint				width = 7;	// GTK+ default
+	gint				height = 13;	// GTK+ default
+	gint				right = 5;	// GTK+ default
+
+	NWEnsureGTKOptionMenu();
+
+	gtk_widget_style_get( gOptionMenuWidget,
+			"indicator_size",	&pIndicatorSize,
+			"indicator_spacing",&pIndicatorSpacing, NULL);
+	
+	if ( pIndicatorSize && ((pIndicatorSize->width < 20) && (pIndicatorSize->width >= 0)) )
+		width = pIndicatorSize->width;
+	if ( pIndicatorSize && ((pIndicatorSize->height < 20) && (pIndicatorSize->height >= 0)) )
+		height = pIndicatorSize->height;
+
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->right < 20) && (pIndicatorSpacing->right >= 0)) )
+		right = pIndicatorSpacing->right;
+
+	aIndicatorRect.setWidth( width );
+	aIndicatorRect.setHeight( height );
+	aIndicatorRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - width - right - gOptionMenuWidget->style->xthickness );
+	aIndicatorRect.setY( aAreaRect.getY() + ((aAreaRect.getHeight() - height) / 2) );
+
+	// If height is odd, move the indicator down 1 pixel
+	if ( aIndicatorRect.getHeight() % 2 )
+		aIndicatorRect.setY( aIndicatorRect.getY() + 1 );
+
+	if ( pIndicatorSize )
+		g_free( pIndicatorSize );
+	if ( pIndicatorSpacing )
+		g_free( pIndicatorSpacing );
+
+	return( aIndicatorRect );
+}
+
+
+/************************************************************************
+ * Create a GdkPixmap filled with the contents of an area of an Xlib window
+ ************************************************************************/
+
+GdkPixmap* GtkSalGraphics::NWGetPixmapFromScreen( Rectangle srcRect )
+{
+    // Create a new pixmap to hold the composite of the window background and the control
+    GdkPixmap * pPixmap		= gdk_pixmap_new( NULL, srcRect.getWidth(), srcRect.getHeight(), 
+                                              GetSalData()->GetDisplay()->GetVisual()->GetDepth() );
+    GdkGC *	 pPixmapGC	= gdk_gc_new( pPixmap );
+
+    if( !pPixmap || !pPixmapGC )
+    {
+        if ( pPixmap )
+            g_object_unref( pPixmap );
+        if ( pPixmapGC )
+            g_object_unref( pPixmapGC );
+        fprintf( stderr, "salnativewidgets-gtk.cxx: could not get valid pixmap from screen\n" );
+        return( NULL );
+    }
+
+    // Copy the background of the screen into a composite pixmap
+    XCopyArea( GetXDisplay(), GetDrawable(), gdk_x11_drawable_get_xid(pPixmap), gdk_x11_gc_get_xgc(pPixmapGC),
+               srcRect.getX(), srcRect.getY(), srcRect.getWidth(), srcRect.getHeight(), 0, 0 );
+
+    g_object_unref( pPixmapGC );
+    return( pPixmap );
+}
+
+
+
+
+/************************************************************************
+ * Copy an alpha pixmap to screen using a gc with clipping
+ ************************************************************************/
+
+BOOL GtkSalGraphics::NWRenderPixmapToScreen( GdkPixmap* pPixmap, Rectangle dstRect )
+{
+    // The GC can't be null, otherwise we'd have no clip region
+    if( SelectFont() == NULL )
+    {
+        fprintf(stderr, "salnativewidgets.cxx: no valid GC\n" );
+        return( FALSE );
+    }
+
+    if ( !pPixmap )
+        return( FALSE );
+
+    // Copy the background of the screen into a composite pixmap
+    XCopyArea( GetXDisplay(), GDK_DRAWABLE_XID(pPixmap), GetDrawable(), SelectFont(),
+               0, 0, dstRect.getWidth(), dstRect.getHeight(), dstRect.getX(), dstRect.getY() );
+
+    X11SalGraphics::YieldGraphicsExpose( GetXDisplay(), NULL, GetDrawable() );
+    
+    return( TRUE );
+}
+
+
+/************************************************************************
+ * State conversion
+ ************************************************************************/
+static void NWConvertVCLStateToGTKState( ControlState nVCLState,
+			GtkStateType* nGTKState, GtkShadowType* nGTKShadow )
+{
+	*nGTKShadow = GTK_SHADOW_OUT;
+	*nGTKState = GTK_STATE_INSENSITIVE;
+
+	if ( nVCLState & CTRL_STATE_ENABLED )
+	{
+		// Pressed button?
+		if ( nVCLState & CTRL_STATE_PRESSED )
+		{
+			*nGTKState = GTK_STATE_ACTIVE;
+			*nGTKShadow = GTK_SHADOW_IN;
+		}
+		else if ( nVCLState & CTRL_STATE_ROLLOVER )
+		{
+			*nGTKState = GTK_STATE_PRELIGHT;
+			*nGTKShadow = GTK_SHADOW_OUT;
+		}
+		else
+		{
+			*nGTKState = GTK_STATE_NORMAL;
+			*nGTKShadow = GTK_SHADOW_OUT;
+		}
+	}
+}
+
+
+/************************************************************************
+ * Widget ensure functions - make sure cached objects are valid
+ ************************************************************************/
+
+//-------------------------------------
+#if 0
+static void
+style_set_cb (GtkWidget *widget)
+{
+  g_print ("Here: %s\n", g_type_name_from_instance ((gpointer)widget));
+}
+#endif
+
+static void NWAddWidgetToCacheWindow( GtkWidget* widget )
+{
+	if ( !gCacheWindow || !gDumbContainer )
+	{
+		if ( !gCacheWindow )
+			gCacheWindow = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+		if ( !gDumbContainer )
+			gDumbContainer = gtk_fixed_new();
+		gtk_container_add( GTK_CONTAINER(gCacheWindow), gDumbContainer );
+		gtk_widget_realize( gDumbContainer );
+		gtk_widget_realize( gCacheWindow );
+#if 0
+		gtk_widget_show( gCacheWindow );
+		gtk_widget_show( gDumbContainer );
+#endif		
+	}
+
+	gtk_container_add( GTK_CONTAINER(gDumbContainer), widget );
+	gtk_widget_realize( widget );
+#if 0
+	gtk_widget_show( widget );
+	g_signal_connect ( widget, "style-set", G_CALLBACK (style_set_cb), NULL);
+#endif
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKButton( void )
+{
+	if ( !gBtnWidget )
+	{
+		gBtnWidget = gtk_button_new_with_label( "" );
+		NWAddWidgetToCacheWindow( gBtnWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKRadio( void )
+{
+	if ( !gRadioWidget || !gRadioWidgetSibling )
+	{
+		gRadioWidget = gtk_radio_button_new( NULL );
+		gRadioWidgetSibling = gtk_radio_button_new_from_widget( GTK_RADIO_BUTTON(gRadioWidget) );
+		NWAddWidgetToCacheWindow( gRadioWidget );
+		NWAddWidgetToCacheWindow( gRadioWidgetSibling );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKCheck( void )
+{
+	if ( !gCheckWidget )
+	{
+		gCheckWidget = gtk_check_button_new();
+		NWAddWidgetToCacheWindow( gCheckWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKScrollbars( void )
+{
+	if ( !gScrollHorizWidget )
+	{
+		gScrollHorizWidget = gtk_hscrollbar_new( NULL );
+		NWAddWidgetToCacheWindow( gScrollHorizWidget );
+	}
+
+	if ( !gScrollVertWidget )
+	{
+		gScrollVertWidget = gtk_vscrollbar_new( NULL );
+		NWAddWidgetToCacheWindow( gScrollVertWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKArrow( void )
+{
+	if ( !gArrowWidget || !gDropdownWidget )
+	{
+		gDropdownWidget = gtk_toggle_button_new();
+		NWAddWidgetToCacheWindow( gDropdownWidget );
+		gArrowWidget = gtk_arrow_new( GTK_ARROW_DOWN, GTK_SHADOW_OUT );
+		gtk_container_add( GTK_CONTAINER(gDropdownWidget), gArrowWidget );
+		gtk_widget_set_rc_style( gArrowWidget );
+		gtk_widget_realize( gArrowWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKEditBox( void )
+{
+	if ( !gEditBoxWidget )
+	{
+		gEditBoxWidget = gtk_entry_new();
+		NWAddWidgetToCacheWindow( gEditBoxWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKSpinButton( void )
+{
+	if ( !gSpinButtonWidget )
+	{
+		GtkAdjustment *adj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+		gSpinButtonWidget = gtk_spin_button_new( adj, 1, 2 );
+		NWAddWidgetToCacheWindow( gSpinButtonWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKNotebook( void )
+{
+	if ( !gNotebookWidget )
+	{
+		gNotebookWidget = gtk_notebook_new();
+		NWAddWidgetToCacheWindow( gNotebookWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKOptionMenu( void )
+{
+	if ( !gOptionMenuWidget )
+	{
+		gOptionMenuWidget = gtk_option_menu_new();
+		NWAddWidgetToCacheWindow( gOptionMenuWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKCombo( void )
+{
+	if ( !gComboWidget )
+	{
+		gComboWidget = gtk_combo_new();
+		NWAddWidgetToCacheWindow( gComboWidget );
+		// Must realize the ComboBox's button widget, since GTK
+		// does not do this for us in GtkCombo::gtk_widget_realize()
+		gtk_widget_realize( GTK_COMBO(gComboWidget)->button );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKScrolledWindow( void )
+{
+	if ( !gScrolledWindowWidget )
+	{
+		GtkAdjustment *hadj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+		GtkAdjustment *vadj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+
+		gScrolledWindowWidget = gtk_scrolled_window_new( hadj, vadj );
+		NWAddWidgetToCacheWindow( gScrolledWindowWidget );
+	}
+}
Index: vcl/unx/gtk/window/gtkframe.cxx
===================================================================
RCS file: vcl/unx/gtk/window/gtkframe.cxx
diff -N vcl/unx/gtk/window/gtkframe.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/window/gtkframe.cxx	17 Jun 2004 12:48:23 -0000	1.6
@@ -0,0 +1,1810 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <plugins/gtk/gtkgdi.hxx>
+#include <keycodes.hxx>
+#include <wmadaptor.hxx>
+#include <salbmp.h>
+#include <floatwin.hxx>
+
+#include <prex.h>
+#include <X11/Xatom.h>
+#include <postx.h>
+
+#include <dlfcn.h>
+#include <soicon.hxx>
+
+#if OSL_DEBUG_LEVEL > 1
+#include <cstdio>
+#endif
+
+int GtkSalFrame::m_nFloats = 0;
+
+static USHORT GetModCode( guint state )
+{
+    USHORT nCode = 0;
+    if( (state & GDK_SHIFT_MASK) )
+        nCode |= KEY_SHIFT;
+    if( (state & GDK_CONTROL_MASK) )
+        nCode |= KEY_MOD1;
+    if( (state & GDK_MOD1_MASK) )
+	{
+        nCode |= KEY_MOD2;
+		if( (state & GDK_MOD1_MASK) )
+			nCode |= KEY_CONTROLMOD;
+	}
+    if( (state & GDK_BUTTON1_MASK) )
+        nCode |= MOUSE_LEFT;
+    if( (state & GDK_BUTTON2_MASK) )
+        nCode |= MOUSE_MIDDLE;
+    if( (state & GDK_BUTTON3_MASK) )
+        nCode |= MOUSE_RIGHT;
+    return nCode;
+}
+
+static USHORT GetKeyCode( guint keyval )
+{
+    USHORT nCode = 0;
+    if( keyval >= GDK_0 && keyval <= GDK_9 )
+        nCode = KEY_0 + (keyval-GDK_0);
+    else if( keyval >= GDK_A && keyval <= GDK_Z )
+        nCode = KEY_A + (keyval-GDK_A );
+    else if( keyval >= GDK_a && keyval <= GDK_z )
+        nCode = KEY_A + (keyval-GDK_a );
+    else if( keyval >= GDK_F1 && keyval <= GDK_F26 )
+        nCode = KEY_F1 + (keyval-GDK_F1);
+    
+    {
+        switch( keyval )
+        {
+            case GDK_KP_Down:
+            case GDK_Down:			nCode = KEY_DOWN;		break;
+            case GDK_KP_Up:
+            case GDK_Up:			nCode = KEY_UP;			break;
+            case GDK_KP_Left:
+            case GDK_Left:			nCode = KEY_LEFT;		break;
+            case GDK_KP_Right:
+            case GDK_Right:			nCode =	KEY_RIGHT;		break;
+            case GDK_KP_Home:
+            case GDK_Home:			nCode = KEY_HOME;		break;
+            case GDK_KP_End:
+            case GDK_End:			nCode = KEY_END;		break;
+            case GDK_KP_Page_Up:
+            case GDK_Page_Up:		nCode = KEY_PAGEUP;		break;
+            case GDK_KP_Page_Down:
+            case GDK_Page_Down:		nCode = KEY_PAGEDOWN;	break;
+            case GDK_KP_Enter:
+            case GDK_Return:		nCode = KEY_RETURN;		break;
+            case GDK_Escape:		nCode = KEY_ESCAPE;		break;
+            case GDK_ISO_Left_Tab:
+            case GDK_KP_Tab:
+            case GDK_Tab:			nCode = KEY_TAB;		break;
+            case GDK_BackSpace:		nCode = KEY_BACKSPACE;	break;
+            case GDK_KP_Space:
+            case GDK_space:			nCode = KEY_SPACE;		break;
+            case GDK_Insert:		nCode = KEY_INSERT;		break;
+            case GDK_Delete:		nCode = KEY_DELETE;		break;
+            case GDK_KP_Add:		nCode = KEY_ADD;		break;
+            case GDK_KP_Subtract:	nCode = KEY_SUBTRACT;	break;
+            case GDK_KP_Multiply:	nCode = KEY_MULTIPLY;	break;
+            case GDK_KP_Divide:		nCode = KEY_DIVIDE;		break;
+            case GDK_period:
+            case GDK_decimalpoint:	nCode = KEY_POINT;		break;
+            case GDK_comma:			nCode = KEY_COMMA;		break;
+            case GDK_less:			nCode = KEY_LESS;		break;
+            case GDK_greater:		nCode = KEY_GREATER;	break;
+            case GDK_equal:			nCode = KEY_EQUAL;		break;
+            case GDK_Find:			nCode = KEY_FIND;		break;
+            case GDK_Menu:			nCode = KEY_MENU;		break;
+            case GDK_Help:			nCode = KEY_HELP;		break;
+            case GDK_Undo:			nCode = KEY_UNDO;		break;
+        }
+    }
+    return nCode;
+}
+
+static USHORT GetCharCodeFromUnicode( sal_Unicode cCode )
+{
+    USHORT nRet = 0;
+    
+    if( cCode >= '0' && cCode <= '9' )
+        nRet = KEY_0 + (cCode - '0');
+    else if( cCode >= 'a' && cCode <= 'z' )
+        nRet = KEY_A + (cCode -'a' );
+    else if( cCode >= 'A' && cCode <= 'Z' )
+        nRet = KEY_A + (cCode -'A' );
+    else if( cCode == ' ' )
+        nRet = KEY_SPACE;
+    else if( cCode == '+' )
+        nRet = KEY_ADD;
+    else if( cCode == '-' )
+        nRet = KEY_SUBTRACT;
+    else if( cCode == '*' )
+        nRet = KEY_MULTIPLY;
+    else if( cCode == '/' )
+        nRet = KEY_DIVIDE;
+    else if( cCode == '.' )
+        nRet = KEY_POINT;
+    else if( cCode == ',' )
+        nRet = KEY_COMMA;
+    else if( cCode == '<' )
+        nRet = KEY_LESS;
+    else if( cCode == '>' )
+        nRet = KEY_GREATER;
+    else if( cCode == '=' )
+        nRet = KEY_EQUAL;
+    
+    return nRet;
+}
+
+GtkSalFrame::GraphicsHolder::~GraphicsHolder()
+{
+    delete pGraphics;
+}
+
+GtkSalFrame::GtkSalFrame( SalFrame* pParent, ULONG nStyle )
+{
+	getDisplay()->registerFrame( this );
+    Init( pParent, nStyle );
+}
+
+GtkSalFrame::GtkSalFrame( SystemParentData* pSysData )
+{
+	getDisplay()->registerFrame( this );
+    getDisplay()->setHaveSystemChildFrame();
+    Init( pSysData );
+}
+
+GtkSalFrame::~GtkSalFrame()
+{
+	getDisplay()->deregisterFrame( this );
+    if( m_pIMContext )
+    {
+        gtk_im_context_reset( m_pIMContext );
+        gtk_im_context_set_client_window( m_pIMContext, NULL );
+        g_object_unref( m_pIMContext );
+    }
+    if( m_pFixedContainer )
+        gtk_widget_destroy( GTK_WIDGET(m_pFixedContainer) );
+    if( m_pWindow )
+        gtk_widget_destroy( GTK_WIDGET(m_pWindow) );
+    if( m_pForeignParent )
+        gdk_window_destroy( m_pForeignParent );
+    if( m_pForeignTopLevel )
+        gdk_window_destroy( m_pForeignTopLevel );
+}
+
+void GtkSalFrame::InitCommon()
+{
+    // connect signals
+    g_signal_connect( G_OBJECT(m_pWindow), "style-set", G_CALLBACK(signalStyleSet), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "button-press-event", G_CALLBACK(signalButton), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "button-release-event", G_CALLBACK(signalButton), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "expose-event", G_CALLBACK(signalExpose), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "focus-in-event", G_CALLBACK(signalFocus), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "focus-out-event", G_CALLBACK(signalFocus), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "map-event", G_CALLBACK(signalMap), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "unmap-event", G_CALLBACK(signalUnmap), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "configure-event", G_CALLBACK(signalConfigure), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "motion-notify-event", G_CALLBACK(signalMotion), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "key-press-event", G_CALLBACK(signalKey), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "key-release-event", G_CALLBACK(signalKey), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "delete-event", G_CALLBACK(signalDelete), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "window-state-event", G_CALLBACK(signalState), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "scroll-event", G_CALLBACK(signalScroll), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "leave-notify-event", G_CALLBACK(signalCrossing), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "enter-notify-event", G_CALLBACK(signalCrossing), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "visibility-notify-event", G_CALLBACK(signalVisibility), this );
+
+    // init members
+	m_pCurrentCursor    = NULL;
+	m_nKeyModifiers     = 0;
+	m_bSingleAltPress   = false;
+    m_bResizeable		= true;
+    m_bDefaultPos		= true;
+    m_bDefaultSize		= ( (m_nStyle & SAL_FRAME_STYLE_SIZEABLE) && ! m_pParent );
+    m_nState			= GDK_WINDOW_STATE_WITHDRAWN;
+    m_nVisibility		= GDK_VISIBILITY_FULLY_OBSCURED;
+	m_bSendModChangeOnRelease = false;
+    m_pIMContext		= NULL;
+    m_bWasPreedit		= false;
+    // delete graphics if InitCommon is called not from destructor
+    for( int i = 0; i < nMaxGraphics; i++ )
+    {
+        m_aGraphics[i].bInUse = false;
+        delete m_aGraphics[i].pGraphics;
+        m_aGraphics[i].pGraphics = NULL;
+    }
+    
+    gtk_widget_set_app_paintable( GTK_WIDGET(m_pWindow), TRUE );
+    gtk_widget_set_double_buffered( GTK_WIDGET(m_pWindow), FALSE );
+    gtk_widget_set_redraw_on_allocate( GTK_WIDGET(m_pWindow), FALSE );
+
+    // realize the window, we need an XWindow id
+    gtk_widget_realize( GTK_WIDGET(m_pWindow) );
+
+    // add the fixed container child,
+    // fixed is needed since we have to position plugin windows
+    m_pFixedContainer = GTK_FIXED(gtk_fixed_new());
+    gtk_container_add( GTK_CONTAINER(m_pWindow), GTK_WIDGET(m_pFixedContainer) );
+    gtk_widget_show( GTK_WIDGET(m_pFixedContainer) );
+
+    //system data
+    SalDisplay* pDisp = GetSalData()->GetDisplay();
+    m_aSystemData.pDisplay		= pDisp->GetDisplay();
+    m_aSystemData.aWindow		= GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window);
+    m_aSystemData.pSalFrame		= this;
+    m_aSystemData.pWidget		= GTK_WIDGET(m_pWindow);
+    m_aSystemData.pVisual		= pDisp->GetVisual()->GetVisual();
+    m_aSystemData.nDepth		= pDisp->GetVisual()->GetDepth();
+    m_aSystemData.aColormap		= pDisp->GetColormap().GetXColormap();
+    m_aSystemData.pAppContext	= NULL;
+    m_aSystemData.aShellWindow	= m_aSystemData.aWindow;
+    m_aSystemData.pShellWidget	= m_aSystemData.pWidget;
+
+    gtk_widget_add_events( GTK_WIDGET(m_pWindow),
+                           GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                           GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
+                           GDK_VISIBILITY_NOTIFY_MASK
+                           );
+
+    // fake an initial geometry, gets updated via configure event or SetPosSize
+    Size aDefSize = calcDefaultSize();
+    maGeometry.nX					= -1;
+    maGeometry.nY					= -1;
+    maGeometry.nWidth				= aDefSize.Width();
+    maGeometry.nHeight				= aDefSize.Height();
+    if( m_pParent )
+    {
+        // approximation
+        maGeometry.nTopDecoration		= m_pParent->maGeometry.nTopDecoration;
+        maGeometry.nBottomDecoration	= m_pParent->maGeometry.nBottomDecoration;
+        maGeometry.nLeftDecoration		= m_pParent->maGeometry.nLeftDecoration;
+        maGeometry.nRightDecoration		= m_pParent->maGeometry.nRightDecoration;
+    }
+    else
+    {
+        maGeometry.nTopDecoration		= 0;
+        maGeometry.nBottomDecoration	= 0;
+        maGeometry.nLeftDecoration		= 0;
+        maGeometry.nRightDecoration		= 0;
+    }
+}
+
+void GtkSalFrame::Init( SalFrame* pParent, ULONG nStyle )
+{
+    if( nStyle & SAL_FRAME_STYLE_DEFAULT ) // ensure default style
+    {
+        nStyle |= SAL_FRAME_STYLE_MOVEABLE | SAL_FRAME_STYLE_SIZEABLE | SAL_FRAME_STYLE_CLOSEABLE;
+        nStyle &= ~SAL_FRAME_STYLE_FLOAT;
+    }
+    
+    m_pWindow = GTK_WINDOW( gtk_widget_new( GTK_TYPE_WINDOW, "type", (nStyle & SAL_FRAME_STYLE_FLOAT) ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL, "visible", FALSE, NULL ) );
+    m_pParent = static_cast<GtkSalFrame*>(pParent);
+    m_pForeignParent = NULL;
+    m_pForeignTopLevel = NULL;
+    m_nStyle = nStyle;
+
+	if( m_pParent && m_pParent->m_pWindow && ! (m_pParent->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+		gtk_window_set_screen( m_pWindow, gtk_window_get_screen( m_pParent->m_pWindow ) );
+
+    InitCommon();
+
+    if( ! (nStyle & (SAL_FRAME_STYLE_FLOAT|SAL_FRAME_STYLE_CHILD)) )
+    {
+        m_bResizeable = (nStyle & SAL_FRAME_STYLE_SIZEABLE) != 0;
+        gtk_window_set_resizable( m_pWindow, m_bResizeable ? TRUE : FALSE );
+        gtk_window_set_gravity( m_pWindow, GDK_GRAVITY_STATIC );
+        if( (nStyle & SAL_FRAME_STYLE_INTRO) )
+            gtk_window_set_type_hint( m_pWindow, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN );
+        else if( (nStyle & SAL_FRAME_STYLE_TOOLWINDOW ) )
+            gtk_window_set_type_hint( m_pWindow, GDK_WINDOW_TYPE_HINT_UTILITY );
+        if( ! (nStyle & (SAL_FRAME_STYLE_MOVEABLE | SAL_FRAME_STYLE_SIZEABLE | SAL_FRAME_STYLE_CLOSEABLE ) ) )
+            gtk_window_set_decorated( m_pWindow, FALSE );
+        if( m_pParent && ! (m_pParent->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+            gtk_window_set_transient_for( m_pWindow, m_pParent->m_pWindow );
+    }
+}
+
+GdkNativeWindow GtkSalFrame::findTopLevelSystemWindow( GdkNativeWindow aWindow )
+{
+    int x_ret, y_ret;
+    unsigned int bw, d;
+    XLIB_Window aRoot, aParent;
+    XLIB_Window* pChildren;
+    unsigned int nChildren;
+    bool bBreak = false;
+    do
+    {
+        XQueryTree( getDisplay()->GetDisplay(), aWindow,
+                    &aRoot, &aParent, &pChildren, &nChildren );
+        XFree( pChildren );
+        if( aParent != aRoot )
+            aWindow = aParent;
+        int nCount = 0;
+        Atom* pProps = XListProperties( getDisplay()->GetDisplay(),
+                                        aWindow,
+                                        &nCount );
+        for( int i = 0; i < nCount && ! bBreak; ++i )
+            bBreak = (pProps[i] == XA_WM_HINTS);
+        if( pProps )
+            XFree( pProps );
+    } while( aParent != aRoot && ! bBreak );
+    
+    return aWindow;
+}
+
+void GtkSalFrame::Init( SystemParentData* pSysData )
+{
+    m_pParent = NULL;
+    m_pForeignParent = gdk_window_foreign_new_for_display( getGdkDisplay(), (GdkNativeWindow)pSysData->aWindow );
+    gdk_window_set_events( m_pForeignParent, GDK_STRUCTURE_MASK );
+    m_pForeignTopLevel = gdk_window_foreign_new_for_display( getGdkDisplay(), findTopLevelSystemWindow( (GdkNativeWindow)pSysData->aWindow ) );
+    gdk_window_set_events( m_pForeignTopLevel, GDK_STRUCTURE_MASK );
+    m_pWindow = GTK_WINDOW(gtk_window_new( GTK_WINDOW_POPUP ));
+    m_nStyle = SAL_FRAME_STYLE_CHILD;
+	InitCommon();
+    XReparentWindow( getDisplay()->GetDisplay(),
+                     GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window),
+                     (XLIB_Window)pSysData->aWindow,
+                     0, 0 );
+}
+
+SalGraphics* GtkSalFrame::GetGraphics()
+{
+    if( m_pWindow )
+    {
+        for( int i = 0; i < nMaxGraphics; i++ )
+        {
+            if( ! m_aGraphics[i].bInUse )
+            {
+                m_aGraphics[i].bInUse = true;
+                if( ! m_aGraphics[i].pGraphics )
+                {
+                    m_aGraphics[i].pGraphics = new GtkSalGraphics(GTK_WIDGET( m_pWindow ));
+                    m_aGraphics[i].pGraphics->Init( this, GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window) );
+                }
+                return m_aGraphics[i].pGraphics;
+            }
+        }
+    }
+    
+    return NULL;
+}
+
+void GtkSalFrame::ReleaseGraphics( SalGraphics* pGraphics )
+{
+    for( int i = 0; i < nMaxGraphics; i++ )
+    {
+        if( m_aGraphics[i].pGraphics == pGraphics )
+        {
+            m_aGraphics[i].bInUse = false;
+            break;
+        }
+    }
+}
+
+BOOL GtkSalFrame::PostEvent( void* pData )
+{
+	getDisplay()->SendInternalEvent( this, pData );
+	return TRUE;
+}
+
+void GtkSalFrame::SetTitle( const String& rTitle )
+{
+    if( m_pWindow && !(m_nStyle & SAL_FRAME_STYLE_CHILD))
+        gtk_window_set_title( m_pWindow, rtl::OUStringToOString( rTitle, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+void GtkSalFrame::SetIcon( USHORT nIcon )
+{
+    if( m_nStyle & SAL_FRAME_STYLE_CHILD )
+        return;
+
+	GList *pPixbufs = NULL;
+
+    // pl: evil ? don't be scared so easily :-)
+	{ // Begin this unutterably evil; we need to pass a nice handle down
+	    VCL_CUSTOM_ICON_FN *pCustomIcon = 0;
+		char *pSymbol = g_strdup_printf ("%s%d", VCL_CUSTOM_ICON_BASE, nIcon );
+		void *pAppHdl = dlopen( NULL, RTLD_LAZY );
+		if ( ( pCustomIcon = ( VCL_CUSTOM_ICON_FN* ) dlsym( pAppHdl, pSymbol ) ) )
+		{
+			char **pIcons[4] = { NULL, NULL, NULL, NULL };
+			pCustomIcon( pIcons[0], pIcons[1], pIcons[2], pIcons[3] );
+			for( int i = 0; i < 4; i++)
+			{
+                if( pIcons[i] )
+                {
+                    GdkPixbuf *pPixbuf = gdk_pixbuf_new_from_xpm_data( (const char **) pIcons[i] );
+                    pPixbufs = g_list_prepend( pPixbufs, pPixbuf );
+                }
+			}
+		}
+		g_free( pSymbol );
+		dlclose( pAppHdl );
+	} // End evilness
+
+	gtk_window_set_icon_list( m_pWindow, pPixbufs );
+
+	g_list_foreach( pPixbufs, (GFunc) g_object_unref, NULL );
+	g_list_free( pPixbufs );
+}
+
+void GtkSalFrame::SetMenu( SalMenu* pSalMenu )
+{
+}
+
+void GtkSalFrame::DrawMenuBar()
+{
+}
+
+void GtkSalFrame::Center()
+{
+    long nX, nY;
+
+    if( m_pParent )
+    {
+        nX = ((long)m_pParent->maGeometry.nWidth - (long)maGeometry.nWidth)/2;
+        nY = ((long)m_pParent->maGeometry.nHeight - (long)maGeometry.nHeight)/2;
+        
+    }
+    else
+    {
+        long	nScreenWidth, nScreenHeight;
+        long	nScreenX = 0, nScreenY = 0;
+
+        nScreenWidth		= GetSalData()->GetDisplay()->GetScreenSize().Width();
+        nScreenHeight		= GetSalData()->GetDisplay()->GetScreenSize().Height();
+        if( GetSalData()->GetDisplay()->IsXinerama() )
+        {
+            // get xinerama screen we are on
+            // if there is a parent, use its center for screen determination
+            // else use the pointer
+            GdkScreen* pScreen;
+            gint x, y;
+            GdkModifierType aMask;
+            gdk_display_get_pointer( getGdkDisplay(), &pScreen, &x, &y, &aMask );
+
+            const std::vector< Rectangle >& rScreens = GetSalData()->GetDisplay()->GetXineramaScreens();
+            for( int i = 0; i < rScreens.size(); i++ )
+                if( rScreens[i].IsInside( Point( x, y ) ) )
+                {
+                    nScreenX			= rScreens[i].Left();
+                    nScreenY			= rScreens[i].Top();
+                    nScreenWidth		= rScreens[i].GetWidth();
+                    nScreenHeight		= rScreens[i].GetHeight();
+                    break;
+                }
+        }
+        nX = nScreenX + (nScreenWidth - (long)maGeometry.nWidth)/2;
+        nY = nScreenY + (nScreenHeight - (long)maGeometry.nHeight)/2;
+    }
+    SetPosSize( nX, nY, 0, 0, SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y );		
+}
+
+Size GtkSalFrame::calcDefaultSize()
+{
+    const Size& rScreenSize( getDisplay()->GetScreenSize() );
+    long w = rScreenSize.Width();
+    long h = rScreenSize.Height();
+
+    // fill in holy default values brought to us by product management
+    if( rScreenSize.Width() >= 800 )
+        w = 785;
+    if( rScreenSize.Width() >= 1024 )
+        w = 920;
+    
+    if( rScreenSize.Height() >= 600 )
+        h = 550;
+    if( rScreenSize.Height() >= 768 )
+        h = 630;
+    if( rScreenSize.Height() >= 1024 )
+        h = 875;
+
+    return Size( w, h );
+}
+
+void GtkSalFrame::SetDefaultSize()
+{
+    Size aDefSize = calcDefaultSize();
+    
+    SetPosSize( 0, 0, aDefSize.Width(), aDefSize.Height(),
+                SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
+
+    if( m_nStyle & SAL_FRAME_STYLE_DEFAULT )
+        gtk_window_maximize( m_pWindow );
+}
+
+void GtkSalFrame::Show( BOOL bVisible, BOOL bNoActivate )
+{
+    if( m_pWindow )
+    {
+        if( bVisible )
+        {
+            if( m_bDefaultPos )
+                Center();
+            if( m_bDefaultSize )
+                SetDefaultSize();
+
+            gtk_widget_show( GTK_WIDGET(m_pWindow) );
+            if( isFloatGrabWindow() )
+            {
+                m_nFloats++;
+                if( ! getDisplay()->GetCaptureFrame() && m_nFloats == 1 )
+                    grabPointer( TRUE, TRUE );
+            }
+        }
+        else
+        {
+            if( isFloatGrabWindow() )
+            {
+                m_nFloats--;
+                if( ! getDisplay()->GetCaptureFrame() && m_nFloats == 0)
+                    grabPointer( FALSE );
+            }
+            gtk_widget_hide( GTK_WIDGET(m_pWindow) );
+            if( m_pIMContext )
+            {
+                gtk_im_context_focus_out( m_pIMContext );
+                gtk_im_context_reset( m_pIMContext );
+            }
+        }
+    }
+}
+
+void GtkSalFrame::Enable( BOOL bEnable )
+{
+	// Not implemented by X11SalFrame either
+}
+
+void GtkSalFrame::SetMinClientSize( long nWidth, long nHeight )
+{
+    if( m_pWindow )
+        gtk_widget_set_size_request( GTK_WIDGET(m_pWindow), nWidth, nHeight );
+}
+
+void GtkSalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags )
+{
+    if( !m_pWindow || (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+		return;
+
+	if( (nFlags & ( SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT )) &&
+		(nWidth > 0 && nHeight > 0 ) // sometimes stupid things happen
+            )
+	{
+#if OSL_DEBUG_LEVEL > 1
+		if( nWidth < 2 || nWidth > 2000 || nHeight < 2 || nHeight > 2000 )
+		{
+			fprintf( stderr, "Discarding bad size: %d, %d\n", nWidth, nHeight );
+			return;
+		}
+#endif
+        m_bDefaultSize = false;
+		gtk_window_resize( m_pWindow, nWidth, nHeight );
+		if( ! m_bResizeable )
+		{
+			GdkGeometry aGeo;
+			aGeo.min_width = aGeo.max_width = nWidth;
+			aGeo.min_height = aGeo.max_height = nHeight;
+			gtk_window_set_geometry_hints( m_pWindow,
+                                           NULL,
+                                           &aGeo,
+                                           (GdkWindowHints)( GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE ) );
+		}
+
+		maGeometry.nWidth	= nWidth;
+		maGeometry.nHeight	= nHeight;
+	}
+    else if( m_bDefaultSize )
+        SetDefaultSize();
+
+    m_bDefaultSize = false;
+
+	if( nFlags & ( SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y ) )
+	{
+#if OSL_DEBUG_LEVEL > 1
+		if( std::abs( nX ) > 2000 || std::abs( nY ) > 2000 )
+		{
+			fprintf( stderr, "Discarding bad pos: %d, %d\n", nX, nY );
+            return;
+		}
+#endif
+		if( m_pParent )
+		{
+			nX += m_pParent->maGeometry.nX;
+			nY += m_pParent->maGeometry.nY;
+		}
+
+        // adjust position to avoid off screen windows
+        Size aScreenSize = GetSalData()->GetDisplay()->GetScreenSize();
+        if( nX < (long)maGeometry.nLeftDecoration )
+            nX = maGeometry.nLeftDecoration;
+        if( nY < (long)maGeometry.nTopDecoration )
+            nY = maGeometry.nTopDecoration;
+        if( (nX + (long)maGeometry.nWidth + (long)maGeometry.nRightDecoration) > (long)aScreenSize.Width() )
+            nX = aScreenSize.Width() - maGeometry.nWidth - maGeometry.nRightDecoration;
+        if( (nY + (long)maGeometry.nHeight + (long)maGeometry.nBottomDecoration) > (long)aScreenSize.Height() )
+            nY = aScreenSize.Height() - maGeometry.nHeight - maGeometry.nBottomDecoration;
+
+		m_bDefaultPos = false;
+		gtk_window_move( m_pWindow, nX, nY );
+		maGeometry.nX = nX;
+		maGeometry.nY = nY;
+	}
+	else if( m_bDefaultPos )
+		Center();
+
+	m_bDefaultPos = false;
+}
+
+void GtkSalFrame::GetClientSize( long& rWidth, long& rHeight )
+{
+    if( GTK_WIDGET_MAPPED( GTK_WIDGET(m_pWindow) ) )
+    {
+        rWidth = maGeometry.nWidth;
+        rHeight = maGeometry.nHeight;
+    }
+    else
+        rWidth = rHeight = 0;
+}
+
+void GtkSalFrame::GetWorkArea( Rectangle& rRect )
+{
+    rRect = GetSalData()->GetDisplay()->getWMAdaptor()->getWorkArea( 0 );
+}
+
+SalFrame* GtkSalFrame::GetParent() const
+{
+    return m_pParent;
+}
+
+void GtkSalFrame::SetWindowState( const SalFrameState* pState )
+{
+    if( ! m_pWindow || ! pState || (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+        return;
+
+    if( pState->mnMask & (SAL_FRAMESTATE_MASK_X | SAL_FRAMESTATE_MASK_Y | SAL_FRAMESTATE_MASK_WIDTH | SAL_FRAMESTATE_MASK_HEIGHT ) )
+    {
+        USHORT nPosSizeFlags = 0;
+        long nX			= pState->mnX - (m_pParent ? m_pParent->maGeometry.nX : 0);
+        long nY			= pState->mnY - (m_pParent ? m_pParent->maGeometry.nY : 0);
+        long nWidth		= pState->mnWidth;
+        long nHeight	= pState->mnHeight;
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_X )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_X;
+        else
+            nX = maGeometry.nX - (m_pParent ? m_pParent->maGeometry.nX : 0);
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_Y )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_Y;
+        else
+            nY = maGeometry.nY - (m_pParent ? m_pParent->maGeometry.nY : 0);
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_WIDTH )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_WIDTH;
+        else
+            nWidth = maGeometry.nWidth;
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_HEIGHT )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_HEIGHT;
+        else
+            nHeight = maGeometry.nHeight;
+        SetPosSize( nX, nY, pState->mnWidth, pState->mnHeight, nPosSizeFlags );
+    }
+    if( pState->mnMask & SAL_FRAMESTATE_MASK_STATE )
+    {
+        if( pState->mnState & SAL_FRAMESTATE_MAXIMIZED )
+            gtk_window_maximize( m_pWindow );
+        if( pState->mnState & SAL_FRAMESTATE_MINIMIZED )
+            gtk_window_iconify( m_pWindow );
+    }
+}
+
+BOOL GtkSalFrame::GetWindowState( SalFrameState* pState )
+{
+    pState->mnState = SAL_FRAMESTATE_NORMAL;
+    if( (m_nState & GDK_WINDOW_STATE_ICONIFIED) )
+        pState->mnState |= SAL_FRAMESTATE_MINIMIZED;
+    if( m_nState & GDK_WINDOW_STATE_MAXIMIZED )
+        pState->mnState |= SAL_FRAMESTATE_MAXIMIZED;
+    // rollup ? gtk 2.2 does not seem to support the shaded state
+
+    pState->mnX			= maGeometry.nX;
+    pState->mnY			= maGeometry.nY;
+    pState->mnWidth		= maGeometry.nWidth;
+    pState->mnHeight	= maGeometry.nHeight;
+    pState->mnMask		=
+        SAL_FRAMESTATE_MASK_X			|
+        SAL_FRAMESTATE_MASK_Y			|
+        SAL_FRAMESTATE_MASK_WIDTH		|
+        SAL_FRAMESTATE_MASK_HEIGHT		|
+        SAL_FRAMESTATE_MASK_STATE;
+
+#if OSL_DEBUG_LEVEL > 1
+    if( std::abs( maGeometry.nX ) > 2000 || std::abs( maGeometry.nY ) > 2000 )
+    {
+        fprintf( stderr, "bad pos in GetWindowState: %d, %d\n", maGeometry.nX, maGeometry.nY );
+        abort();
+    }
+    if( maGeometry.nWidth < 2 || maGeometry.nWidth > 2000 || maGeometry.nHeight < 2 || maGeometry.nHeight > 2000 )
+    {
+        fprintf( stderr, "bad size in GetWindowState: %d, %d\n", maGeometry.nWidth, maGeometry.nHeight );
+        abort();
+    }
+#endif
+
+    return TRUE;
+}
+
+void GtkSalFrame::ShowFullScreen( BOOL bFullScreen )
+{
+    if( m_pWindow && ! (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+    {
+        if( bFullScreen )
+        {
+            if( ! m_bResizeable )
+                gtk_window_set_resizable( m_pWindow, TRUE );
+            gtk_window_fullscreen( m_pWindow );
+        }
+        else
+        {
+            gtk_window_unfullscreen( m_pWindow );
+            if( ! m_bResizeable )
+                gtk_window_set_resizable( m_pWindow, FALSE );
+        }
+    }
+}
+
+/* definitions from xautolock.c (pl15) */
+#define XAUTOLOCK_DISABLE 1
+#define XAUTOLOCK_ENABLE  2
+
+void GtkSalFrame::setAutoLock( bool bLock )
+{
+	GdkScreen  *pScreen = gtk_window_get_screen( m_pWindow );
+	GdkDisplay *pDisplay = gdk_screen_get_display( pScreen );
+	GdkWindow  *pRootWin = gdk_screen_get_root_window( pScreen );
+
+	Atom nAtom = XInternAtom( GDK_DISPLAY_XDISPLAY( pDisplay ),
+							  "XAUTOLOCK_MESSAGE", False );
+
+	int nMessage = bLock ? XAUTOLOCK_ENABLE : XAUTOLOCK_DISABLE;
+
+	XChangeProperty( GDK_DISPLAY_XDISPLAY( pDisplay ),
+					 GDK_WINDOW_XID( pRootWin ),
+					 nAtom, XA_INTEGER,
+					 8, PropModeReplace,
+					 (unsigned char*)&nMessage,
+					 sizeof( nMessage ) );
+}
+
+void GtkSalFrame::StartPresentation( BOOL bStart )
+{
+	Display *pDisplay = GDK_DISPLAY_XDISPLAY( getGdkDisplay() );
+
+	setAutoLock( !bStart );
+
+	int nTimeout, nInterval, bPreferBlanking, bAllowExposures;
+
+	XGetScreenSaver( pDisplay, &nTimeout, &nInterval,
+					 &bPreferBlanking, &bAllowExposures );
+	if( bStart )
+	{
+		if ( nTimeout )
+		{
+			m_nSavedScreenSaverTimeout = nTimeout;
+			XResetScreenSaver( pDisplay );
+			XSetScreenSaver( pDisplay, 0, nInterval,
+							 bPreferBlanking, bAllowExposures );
+		}
+	}
+	else
+	{
+		if( m_nSavedScreenSaverTimeout )
+			XSetScreenSaver( pDisplay, m_nSavedScreenSaverTimeout,
+							 nInterval, bPreferBlanking,
+							 bAllowExposures );
+		m_nSavedScreenSaverTimeout = 0;
+	}	
+}
+
+void GtkSalFrame::SetAlwaysOnTop( BOOL bOnTop )
+{
+}
+
+void GtkSalFrame::ToTop( USHORT nFlags )
+{
+    if( m_pWindow )
+    {
+        if( GTK_WIDGET_MAPPED( GTK_WIDGET(m_pWindow ) ) )
+        {
+            if( ! SAL_FRAME_TOTOP_GRABFOCUS_ONLY )
+                gtk_window_present( m_pWindow );
+            else
+                gdk_window_focus( GTK_WIDGET(m_pWindow)->window, GDK_CURRENT_TIME );
+        }
+        else
+        {
+            if( nFlags & SAL_FRAME_TOTOP_RESTOREWHENMIN )
+                gtk_window_present( m_pWindow );
+        }
+    }
+}
+
+void GtkSalFrame::SetPointer( PointerStyle ePointerStyle )
+{
+	GdkCursor *pCursor = getDisplay()->getCursor( ePointerStyle );
+	gdk_window_set_cursor( GTK_WIDGET(m_pWindow)->window, pCursor );
+	m_pCurrentCursor = pCursor;
+}
+
+void GtkSalFrame::grabPointer( BOOL bGrab, BOOL bOwnerEvents )
+{
+	int nMask = ( GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK );
+	GdkGrabStatus nStatus;
+
+	if( bGrab )
+		nStatus = gdk_pointer_grab
+				( GTK_WIDGET(m_pWindow)->window, bOwnerEvents,
+				  (GdkEventMask) nMask, NULL, m_pCurrentCursor,
+				  GDK_CURRENT_TIME );
+	else
+	{
+		// Two GdkDisplays may be open
+		gdk_display_pointer_ungrab( getGdkDisplay(), GDK_CURRENT_TIME);
+	}
+}
+
+void GtkSalFrame::CaptureMouse( BOOL bCapture )
+{
+	getDisplay()->CaptureMouse( bCapture ? this : NULL );
+}
+
+void GtkSalFrame::SetPointerPos( long nX, long nY )
+{
+	GdkScreen *pScreen = gtk_window_get_screen( m_pWindow );
+	GdkDisplay *pDisplay = gdk_screen_get_display( pScreen );
+
+    /* #87921# when the application tries to center the mouse in the dialog the
+     * window isn't mapped already. So use coordinates relative to the root window.
+     */
+    unsigned int nWindowLeft = maGeometry.nX + nX;
+    unsigned int nWindowTop  = maGeometry.nY + nY;
+
+    XWarpPointer( GDK_DISPLAY_XDISPLAY (pDisplay), None,
+				  GDK_WINDOW_XID (gdk_screen_get_root_window( pScreen ) ),
+                  0, 0, 0, 0, nWindowLeft, nWindowTop);
+}
+
+void GtkSalFrame::Flush()
+{
+#ifdef HAVE_A_RECENT_GTK
+	gdk_display_flush( getGdkDisplay() );
+#else
+    XFlush (GDK_DISPLAY_XDISPLAY (getGdkDisplay()));
+#endif
+}
+
+void GtkSalFrame::Sync()
+{
+	gdk_display_sync( getGdkDisplay() );
+}
+
+String GtkSalFrame::GetSymbolKeyName( const String&, USHORT nKeyCode )
+{
+  return getDisplay()->GetKeyName( nKeyCode );
+}
+
+String GtkSalFrame::GetKeyName( USHORT nKeyCode )
+{
+	return getDisplay()->GetKeyName( nKeyCode );
+}
+
+GdkDisplay *GtkSalFrame::getGdkDisplay()
+{
+    return static_cast<GtkSalDisplay*>(GetSalData()->GetDisplay())->GetGdkDisplay();
+}
+
+GtkSalDisplay *GtkSalFrame::getDisplay()
+{
+	return static_cast<GtkSalDisplay*>(GetSalData()->GetDisplay());
+}
+
+ULONG GtkSalFrame::GetCurrentModButtons()
+{
+    GdkScreen* pScreen;
+    gint x, y;
+    GdkModifierType aMask;
+    gdk_display_get_pointer( getGdkDisplay(), &pScreen, &x, &y, &aMask );
+    return GetModCode( aMask );
+}
+
+void GtkSalFrame::SetInputContext( SalInputContext* pContext )
+{
+    if( ! pContext )
+        return;
+    
+    if( ! (pContext->mnOptions & SAL_INPUTCONTEXT_TEXT) )
+    {
+        if( m_pIMContext )
+            gtk_im_context_focus_out( m_pIMContext );
+        return;
+    }
+
+    // create a new im context
+    if( ! m_pIMContext )
+    {
+        m_pIMContext = gtk_im_multicontext_new ();
+        g_signal_connect( m_pIMContext, "commit",
+                          G_CALLBACK (signalIMCommit), this );
+        g_signal_connect( m_pIMContext, "preedit_changed",
+                          G_CALLBACK (signalIMPreeditChanged), this );
+        g_signal_connect( m_pIMContext, "retrieve_surrounding",
+                          G_CALLBACK (signalIMRetrieveSurrounding), this );
+        g_signal_connect( m_pIMContext, "delete_surrounding",
+                          G_CALLBACK (signalIMDeleteSurrounding), this );
+
+        gtk_im_context_set_client_window( m_pIMContext, GTK_WIDGET(m_pWindow)->window );
+    }
+}
+void GtkSalFrame::EndExtTextInput( USHORT nFlags )
+{
+    if( m_pIMContext )
+        gtk_im_context_reset( m_pIMContext );
+    m_bWasPreedit = false;
+}
+
+LanguageType GtkSalFrame::GetInputLanguage()
+{
+    return LANGUAGE_DONTKNOW;
+}
+
+SalBitmap* GtkSalFrame::SnapShot()
+{
+	if( !m_pWindow )
+		return NULL;
+
+	X11SalBitmap *pBmp = new X11SalBitmap;
+	GdkWindow *pWin = GTK_WIDGET(m_pWindow)->window;
+	if( pBmp->SnapShot( GDK_DISPLAY_XDISPLAY( getGdkDisplay() ),
+						GDK_WINDOW_XID( pWin ) ) )
+		return pBmp;
+	else
+		delete pBmp;
+
+	return NULL;
+}
+
+static inline Color getColor( const GdkColor& rCol )
+{
+    return Color( rCol.red >> 8, rCol.green >> 8, rCol.blue >> 8 );
+}
+
+#if OSL_DEBUG_LEVEL > 1
+
+void printColor( const char* name, const GdkColor& rCol )
+{
+    fprintf( stderr, "   %s = 0x%2x 0x%2x 0x%2x\n",
+             name,
+             rCol.red >> 8, rCol.green >> 8, rCol.blue >> 8 );
+}
+
+void printStyleColors( GtkStyle* pStyle )
+{
+    static const char* pStates[] = { "NORMAL", "ACTIVE", "PRELIGHT", "SELECTED", "INSENSITIVE" };
+
+    for( int i = 0; i < 5; i++ )
+    {
+        fprintf( stderr, "state %s colors:\n", pStates[i] );
+        printColor( "bg     ", pStyle->bg[i] ); 
+        printColor( "fg     ", pStyle->fg[i] ); 
+        printColor( "light  ", pStyle->light[i] ); 
+        printColor( "dark   ", pStyle->dark[i] ); 
+        printColor( "mid    ", pStyle->mid[i] ); 
+        printColor( "text   ", pStyle->text[i] ); 
+        printColor( "base   ", pStyle->base[i] ); 
+        printColor( "text_aa", pStyle->text_aa[i] ); 
+    }
+}
+#endif
+
+void GtkSalFrame::UpdateSettings( AllSettings& rSettings )
+{
+    if( ! m_pWindow )
+        return;
+
+    StyleSettings aStyleSet = rSettings.GetStyleSettings();
+
+    gtk_widget_ensure_style( GTK_WIDGET(m_pWindow) );
+    GtkStyle* pStyle = gtk_widget_get_style( GTK_WIDGET(m_pWindow) );
+
+#if OSL_DEBUG_LEVEL > 2
+    printStyleColors( pStyle );
+#endif
+    
+    // text colors
+    Color aTextColor = getColor( pStyle->text[GTK_STATE_NORMAL] );
+    aStyleSet.SetDialogTextColor( aTextColor );
+    aStyleSet.SetMenuTextColor( aTextColor );
+    aStyleSet.SetButtonTextColor( aTextColor );
+    aStyleSet.SetRadioCheckTextColor( aTextColor );
+    aStyleSet.SetGroupTextColor( aTextColor );
+    aStyleSet.SetLabelTextColor( aTextColor );
+    aStyleSet.SetInfoTextColor( aTextColor );
+    aStyleSet.SetWindowTextColor( aTextColor );
+    aStyleSet.SetFieldTextColor( aTextColor );
+    
+    // background colors
+    Color aBackColor = getColor( pStyle->bg[GTK_STATE_NORMAL] );
+    Color aBackFieldColor = getColor( pStyle->base[ GTK_STATE_NORMAL ] );
+    aStyleSet.Set3DColors( aBackColor );
+    aStyleSet.SetFaceColor( aBackColor );
+    aStyleSet.SetDialogColor( aBackColor );
+    aStyleSet.SetMenuColor( aBackColor );
+    aStyleSet.SetMenuBarColor( aBackColor );
+    aStyleSet.SetFieldColor( aBackFieldColor );
+    aStyleSet.SetWindowColor( aBackFieldColor );
+    // ancient wisdom tells us a mystic algorithm how to set checked color
+    if( aBackColor == COL_LIGHTGRAY )
+        aStyleSet.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
+    else
+    {
+        Color aColor2 = aStyleSet.GetLightColor();
+        Color aCheck( (BYTE)(((USHORT)aBackColor.GetRed()+(USHORT)aColor2.GetRed())/2),
+                      (BYTE)(((USHORT)aBackColor.GetGreen()+(USHORT)aColor2.GetGreen())/2),
+                      (BYTE)(((USHORT)aBackColor.GetBlue()+(USHORT)aColor2.GetBlue())/2)
+                      );
+        aStyleSet.SetCheckedColor( aCheck );
+    }
+
+    // highlighting colors
+    Color aHighlightColor = getColor( pStyle->base[GTK_STATE_SELECTED] );
+    Color aHighlightTextColor = getColor( pStyle->text[GTK_STATE_SELECTED] );
+    aStyleSet.SetHighlightColor( aHighlightColor );
+    aStyleSet.SetHighlightTextColor( aHighlightTextColor );
+
+    // menu highlighting
+    aHighlightColor = getColor( pStyle->bg[ GTK_STATE_SELECTED ] );
+    aStyleSet.SetMenuHighlightColor( aHighlightColor );
+    aHighlightTextColor = getColor( pStyle->fg[ GTK_STATE_PRELIGHT ] );
+    aStyleSet.SetMenuHighlightTextColor( aHighlightTextColor );
+
+    // UI font
+    ByteString	aFamily	= pango_font_description_get_family( pStyle->font_desc );
+    int nPixelHeight	= pango_font_description_get_size( pStyle->font_desc )/PANGO_SCALE;
+    PangoStyle	eStyle	= pango_font_description_get_style( pStyle->font_desc );
+    PangoWeight	eWeight	= pango_font_description_get_weight( pStyle->font_desc );
+    
+    sal_Int32 nDPIX, nDPIY;
+    sal_Int32 nDispDPIY = getDisplay()->GetResolution().B();
+    getDisplay()->GetScreenFontResolution( nDPIX, nDPIY );
+    int nHeight = nPixelHeight * nDispDPIY / nDPIY;
+    // allow for rounding in back conversion (at SetFont)
+    while( (nHeight * nDPIY / nDispDPIY) > nPixelHeight )
+        nHeight--;
+    while( (nHeight * nDPIY / nDispDPIY) < nPixelHeight )
+        nHeight++;
+    
+    Font aFont( String( aFamily, RTL_TEXTENCODING_UTF8 ), Size( 0, nHeight ) );
+    if( eWeight >= PANGO_WEIGHT_BOLD )
+        aFont.SetWeight( WEIGHT_BOLD );
+    else if( PANGO_WEIGHT_LIGHT )
+        aFont.SetWeight( WEIGHT_LIGHT );
+    if( eStyle == PANGO_STYLE_OBLIQUE )
+        aFont.SetItalic( ITALIC_OBLIQUE );
+    else if( eStyle == PANGO_STYLE_ITALIC )
+        aFont.SetItalic( ITALIC_NORMAL );
+    
+    aStyleSet.SetAppFont( aFont );
+    aStyleSet.SetHelpFont( aFont );
+    aStyleSet.SetTitleFont( aFont );
+    aStyleSet.SetFloatTitleFont( aFont );
+    aStyleSet.SetMenuFont( aFont );
+    aStyleSet.SetToolFont( aFont );
+    aStyleSet.SetLabelFont( aFont );
+    aStyleSet.SetInfoFont( aFont );
+    aStyleSet.SetRadioCheckFont( aFont );
+    aStyleSet.SetPushButtonFont( aFont );
+    aStyleSet.SetFieldFont( aFont );
+    aStyleSet.SetIconFont( aFont );
+    aStyleSet.SetGroupFont( aFont );    
+
+//  FIXME: need some way of fetching toolbar icon size.
+//	aStyleSet.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_SMALL );
+
+    rSettings.SetStyleSettings( aStyleSet );
+}
+
+void GtkSalFrame::Beep( SoundType eType )
+{
+    gdk_display_beep( getGdkDisplay() );
+}
+
+const SystemEnvData* GtkSalFrame::GetSystemData() const
+{
+    return &m_aSystemData;
+}
+
+void GtkSalFrame::SetParent( SalFrame* pNewParent )
+{
+    m_pParent = static_cast<GtkSalFrame*>(pNewParent);
+    if( ! (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+        gtk_window_set_transient_for( m_pWindow,
+                                      (m_pParent && !(m_pParent->m_nStyle & SAL_FRAME_STYLE_CHILD)) ? m_pParent->m_pWindow : NULL
+                                     );
+}
+
+bool GtkSalFrame::SetPluginParent( SystemParentData* pSysParent )
+{
+    gtk_widget_destroy( GTK_WIDGET(m_pWindow) );
+    if( m_pForeignParent )
+        gdk_window_destroy( m_pForeignParent );
+    if( m_pForeignTopLevel )
+        gdk_window_destroy( m_pForeignTopLevel );
+    Init( pSysParent );
+    return true;
+}
+
+bool GtkSalFrame::Dispatch( const XEvent* pEvent )
+{
+    bool bContinueDispatch = true;
+
+    if( m_pForeignParent &&
+        pEvent->type == ConfigureNotify &&
+        pEvent->xconfigure.window == GDK_WINDOW_XWINDOW(m_pForeignParent)
+        )
+    {
+        bContinueDispatch = false;
+        gtk_window_resize( m_pWindow, pEvent->xconfigure.width, pEvent->xconfigure.height );
+    }
+    else if( m_pForeignTopLevel &&
+             pEvent->type == ConfigureNotify &&
+             pEvent->xconfigure.window == GDK_WINDOW_XWINDOW(m_pForeignTopLevel)
+             )
+    {
+        bContinueDispatch = false;
+        // update position
+        int x = 0, y = 0;
+        XLIB_Window aChild;
+  		XTranslateCoordinates( getDisplay()->GetDisplay(),
+                               GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window),
+ 							   getDisplay()->GetRootWindow(),
+ 							   0, 0,
+ 							   &x, &y,
+ 							   &aChild );
+        if( x != maGeometry.nX || y != maGeometry.nY )
+        {
+            maGeometry.nX = x;
+            maGeometry.nY = y;
+            getDisplay()->SendInternalEvent( this, NULL, SALEVENT_MOVE );
+        }
+    }
+    
+    return bContinueDispatch;
+}
+
+gboolean GtkSalFrame::signalButton( GtkWidget* pWidget, GdkEventButton* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    SalMouseEvent aEvent;
+    USHORT nEventType = 0;
+    switch( pEvent->type )
+    {
+        case GDK_BUTTON_PRESS:
+            nEventType = SALEVENT_MOUSEBUTTONDOWN;
+            break;
+        case GDK_BUTTON_RELEASE:
+            nEventType = SALEVENT_MOUSEBUTTONUP;
+            break;
+        default:
+            return FALSE;
+    }
+    switch( pEvent->button )
+    {
+        case 1: aEvent.mnButton = MOUSE_LEFT;	break;
+        case 2: aEvent.mnButton = MOUSE_MIDDLE;	break;
+        case 3: aEvent.mnButton = MOUSE_RIGHT;	break;
+        default: return FALSE;				break;
+    }       
+    aEvent.mnTime	= pEvent->time;
+    aEvent.mnX		= (long)pEvent->x;
+    aEvent.mnY		= (long)pEvent->y;
+    aEvent.mnCode	= GetModCode( pEvent->state );
+
+    bool bClosePopups = false;
+    if( pEvent->type == GDK_BUTTON_PRESS && m_nFloats > 0 )
+    {
+        // close popups if user clicks outside our application
+        gint x, y;
+        bClosePopups = (gdk_display_get_window_at_pointer( pThis->getGdkDisplay(), &x, &y ) == NULL);
+        gdk_display_pointer_ungrab( pThis->getGdkDisplay(), GDK_CURRENT_TIME );
+    }
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( nEventType, &aEvent );
+
+    if( bClosePopups )
+    {
+        ImplSVData* pSVData = ImplGetSVData();
+        if ( pSVData->maWinData.mpFirstFloat )
+        {
+            static const char* pEnv = getenv( "SAL_FLOATWIN_NOAPPFOCUSCLOSE" );
+            if ( !(pSVData->maWinData.mpFirstFloat->GetPopupModeFlags() & FLOATWIN_POPUPMODE_NOAPPFOCUSCLOSE) && !(pEnv && *pEnv) )
+                pSVData->maWinData.mpFirstFloat->EndPopupMode( FLOATWIN_POPUPMODEEND_CANCEL | FLOATWIN_POPUPMODEEND_CLOSEALL );
+        }
+    }
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalScroll( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    GdkEventScroll* pSEvent = (GdkEventScroll*)pEvent;
+
+    static ULONG		nLines = 0;
+    if( ! nLines )
+    {
+        char* pEnv = getenv( "SAL_WHEELLINES" );
+        nLines = pEnv ? atoi( pEnv ) : 3;
+        if( nLines > 10 )
+            nLines = SAL_WHEELMOUSE_EVENT_PAGESCROLL;
+    }
+
+    bool bNeg = (pSEvent->direction == GDK_SCROLL_DOWN || pSEvent->direction == GDK_SCROLL_RIGHT );
+    SalWheelMouseEvent aEvent;
+    aEvent.mnTime			= pSEvent->time;
+    aEvent.mnX				= (ULONG)pSEvent->x;
+    aEvent.mnY				= (ULONG)pSEvent->y;
+    aEvent.mnDelta			= bNeg ? -120 : 120;
+    aEvent.mnNotchDelta		= bNeg ? -1 : 1;
+    aEvent.mnScrollLines	= nLines;
+    aEvent.mnCode			= GetModCode( pSEvent->state );
+    aEvent.mbHorz			= (pSEvent->direction == GDK_SCROLL_LEFT || pSEvent->direction == GDK_SCROLL_RIGHT);
+    
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_WHEELMOUSE, &aEvent );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalMotion( GtkWidget* pWidget, GdkEventMotion* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    SalMouseEvent aEvent;
+    aEvent.mnTime	= pEvent->time;
+    aEvent.mnX		= (long)pEvent->x;
+    aEvent.mnY		= (long)pEvent->y;
+    aEvent.mnCode	= GetModCode( pEvent->state );
+    aEvent.mnButton	= 0;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_MOUSEMOVE, &aEvent );
+
+    // ask for the next hint
+    gint x, y;
+    GdkModifierType mask;
+    gdk_window_get_pointer( GTK_WIDGET(pThis->m_pWindow)->window, &x, &y, &mask );
+
+    return TRUE;
+}
+
+gboolean GtkSalFrame::signalCrossing( GtkWidget* pWidget, GdkEventCrossing* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    SalMouseEvent aEvent;
+    aEvent.mnTime	= pEvent->time;
+    aEvent.mnX		= (long)pEvent->x;
+    aEvent.mnY		= (long)pEvent->y;
+    aEvent.mnCode	= GetModCode( pEvent->state );
+    aEvent.mnButton	= 0;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( (pEvent->type == GDK_ENTER_NOTIFY) ? SALEVENT_MOUSEMOVE : SALEVENT_MOUSELEAVE, &aEvent );
+
+    return TRUE;
+}
+
+
+gboolean GtkSalFrame::signalExpose( GtkWidget* pWidget, GdkEventExpose* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    struct SalPaintEvent aEvent;
+    aEvent.mnBoundX			= pEvent->area.x;
+    aEvent.mnBoundY			= pEvent->area.y;
+    aEvent.mnBoundWidth		= pEvent->area.width;
+    aEvent.mnBoundHeight	= pEvent->area.height;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_PAINT, &aEvent );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalFocus( GtkWidget* pWidget, GdkEventFocus* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+
+	if( !pEvent->in )
+	{
+		pThis->m_nKeyModifiers = 0;
+		pThis->m_bSingleAltPress = false;
+		pThis->m_bSendModChangeOnRelease = false;
+        pThis->m_bWasPreedit = false;
+	}
+
+    if( pThis->m_pIMContext )
+    {
+        if( pEvent->in )
+        {
+            gtk_im_context_focus_in( pThis->m_pIMContext );
+            gtk_im_context_reset( pThis->m_pIMContext );
+        }
+        else
+        {
+            gtk_im_context_focus_out( pThis->m_pIMContext );
+            pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, NULL );
+            gtk_im_context_reset( pThis->m_pIMContext );
+        }
+    }
+
+    // FIXME: find out who the hell steals the focus from our frame
+    // if we are plugged and a float opens; why does the same not
+    // happen unplugged ? Is the plugging application (SimpleViewer in SDK)
+    // somehow responsible ? The focus does not seem to get set inside our process
+    //
+    // in the meantime do not propagate focus get/lose on a plugged window
+    // if floats are open
+    if( ! ((pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) && m_nFloats > 0 ) )
+        pThis->CallCallback( pEvent->in ? SALEVENT_GETFOCUS : SALEVENT_LOSEFOCUS, NULL );
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalMap( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_RESIZE, NULL );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalUnmap( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_RESIZE, NULL );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalConfigure( GtkWidget* pWidget, GdkEventConfigure* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    bool bMoved = false, bSized = false;
+    int x = pEvent->x, y = pEvent->y;
+
+    if( (pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+    {
+        // in child case the coordinates are not root coordinates,
+        // need to transform
+        XLIB_Window aChild;
+  		XTranslateCoordinates( pThis->getDisplay()->GetDisplay(),
+                               GDK_WINDOW_XWINDOW(GTK_WIDGET(pThis->m_pWindow)->window),
+ 							   pThis->getDisplay()->GetRootWindow(),
+ 							   0, 0,
+ 							   &x, &y,
+ 							   &aChild );
+    }
+
+
+    if( x != pThis->maGeometry.nX || y != pThis->maGeometry.nY )
+        bMoved = true;
+    if( pEvent->width != pThis->maGeometry.nWidth || pEvent->height != pThis->maGeometry.nHeight )
+        bSized = true;
+
+    pThis->maGeometry.nX		= x;
+    pThis->maGeometry.nY		= y;
+    pThis->maGeometry.nWidth	= pEvent->width;
+    pThis->maGeometry.nHeight	= pEvent->height;
+
+    // update decoration hints
+    if( ! (pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+    {
+        GdkRectangle aRect;
+        gdk_window_get_frame_extents( GTK_WIDGET(pThis->m_pWindow)->window, &aRect );
+        pThis->maGeometry.nTopDecoration	= y - aRect.y;
+        pThis->maGeometry.nBottomDecoration	= aRect.y + aRect.height - y - pEvent->height;
+        pThis->maGeometry.nLeftDecoration	= x - aRect.x;
+        pThis->maGeometry.nRightDecoration	= aRect.x + aRect.width - x - pEvent->width;
+    }
+    else
+    {
+        pThis->maGeometry.nTopDecoration =
+            pThis->maGeometry.nBottomDecoration =
+            pThis->maGeometry.nLeftDecoration =
+            pThis->maGeometry.nRightDecoration = 0;
+    }
+
+	GTK_YIELD_GRAB();
+    if( bMoved && bSized )
+        pThis->CallCallback( SALEVENT_MOVERESIZE, NULL );
+    else if( bMoved )
+        pThis->CallCallback( SALEVENT_MOVE, NULL );
+    else if( bSized )
+        pThis->CallCallback( SALEVENT_RESIZE, NULL );
+
+	return FALSE;
+}
+
+gboolean GtkSalFrame::signalKey( GtkWidget* pWidget, GdkEventKey* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    static GdkEventKey aLastPressEvent = { GDK_KEY_PRESS, NULL, 0, 0, 0, 0, 0, NULL, 0, 0 };
+
+    if( pThis->m_pIMContext )
+    {
+        if( gtk_im_context_filter_keypress( pThis->m_pIMContext, pEvent ) )
+        {
+            aLastPressEvent = *pEvent;
+            return TRUE;
+        }    
+        else
+            if( pEvent->type == GDK_KEY_PRESS )
+                aLastPressEvent.window = NULL;
+    }
+
+    // swallow key release events if according keypress was filtered
+    if( pEvent->type == GDK_KEY_RELEASE							&&
+        pEvent->window		== aLastPressEvent.window			&&
+        pEvent->send_event	== aLastPressEvent.send_event		&&
+        pEvent->state		== aLastPressEvent.state			&&
+        pEvent->keyval		== aLastPressEvent.keyval )
+    {
+        aLastPressEvent.window = NULL;
+        return TRUE;
+    }
+
+    GTK_YIELD_GRAB();
+
+    // handle modifiers
+    if( pEvent->keyval == GDK_Shift_L || pEvent->keyval == GDK_Shift_R ||
+        pEvent->keyval == GDK_Control_L || pEvent->keyval == GDK_Control_R ||
+        pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ||
+        pEvent->keyval == GDK_Meta_L || pEvent->keyval == GDK_Meta_R )
+    {
+		SalKeyModEvent aModEvt;
+
+		USHORT nModCode = GetModCode( pEvent->state );
+
+        aModEvt.mnModKeyCode = 0; // emit no MODKEYCHANGE events
+        if( pEvent->type == GDK_KEY_PRESS && !pThis->m_nKeyModifiers )
+			pThis->m_bSendModChangeOnRelease = true;
+
+        else if( pEvent->type == GDK_KEY_RELEASE &&
+				 pThis->m_bSendModChangeOnRelease )
+        {
+			aModEvt.mnModKeyCode = pThis->m_nKeyModifiers;
+			pThis->m_nKeyModifiers = 0;
+        }
+
+        USHORT nExtModMask = 0;
+        USHORT nModMask = 0;
+		// pressing just the ctrl key leads to a keysym of XK_Control but
+		// the event state does not contain ControlMask. In the release
+		// event its the other way round: it does contain the Control mask.
+		// The modifier mode therefore has to be adapted manually.
+        switch( pEvent->keyval )
+        {
+            case GDK_Control_L:
+                nExtModMask = MODKEY_LMOD1;
+                nModMask = KEY_MOD1;
+                break;
+            case GDK_Control_R:
+                nExtModMask = MODKEY_RMOD1;
+                nModMask = KEY_MOD1;
+                break;
+            case GDK_Alt_L:
+                nExtModMask = MODKEY_LMOD2;
+                nModMask = KEY_MOD2 | (pEvent->type == GDK_KEY_RELEASE ? KEY_CONTROLMOD : 0);
+                break;
+            case GDK_Alt_R:
+                nExtModMask = MODKEY_RMOD2;
+                nModMask = KEY_MOD2 | (pEvent->type == GDK_KEY_RELEASE ? KEY_CONTROLMOD : 0);
+                break;
+            case GDK_Shift_L:
+                nExtModMask = MODKEY_LSHIFT;
+                nModMask = KEY_SHIFT;
+                break;
+            case GDK_Shift_R:
+                nExtModMask = MODKEY_RSHIFT;
+                nModMask = KEY_SHIFT;
+                break;
+        }
+        if( pEvent->type == GDK_KEY_RELEASE )
+        {
+            nModCode &= ~nModMask;
+            pThis->m_nKeyModifiers &= ~nExtModMask;
+        }
+        else
+        {
+            nModCode |= nModMask;
+            pThis->m_nKeyModifiers |= nExtModMask;
+        }
+
+		aModEvt.mnCode = nModCode;
+		aModEvt.mnTime = pEvent->time;
+
+		pThis->CallCallback( SALEVENT_KEYMODCHANGE, &aModEvt );
+
+        // emulate KEY_MENU
+		if( ( pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ) &&
+			( nModCode & ~(KEY_CONTROLMOD|KEY_MOD2)) == 0 )
+		{
+            if( pEvent->type == GDK_KEY_PRESS )
+                pThis->m_bSingleAltPress = true;
+
+			else if( pThis->m_bSingleAltPress )
+			{
+		        SalKeyEvent aKeyEvt;
+
+                aKeyEvt.mnCode	   = KEY_MENU | nModCode;
+                aKeyEvt.mnRepeat   = 0;
+                aKeyEvt.mnTime	   = pEvent->time;
+                aKeyEvt.mnCharCode = 0;
+
+                // simulate KEY_MENU
+                pThis->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+                pThis->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
+				pThis->m_bSingleAltPress = false;
+			}
+		}
+		else
+			pThis->m_bSingleAltPress = false;
+    }
+    else
+    {
+        SalKeyEvent aEvent;
+        
+        aEvent.mnTime			= pEvent->time;
+        aEvent.mnCode			= GetKeyCode( pEvent->keyval ) | GetModCode( pEvent->state );
+        aEvent.mnCharCode		= (USHORT)gdk_keyval_to_unicode( pEvent->keyval );
+        aEvent.mnRepeat			= 0;
+
+        pThis->CallCallback( (pEvent->type == GDK_KEY_PRESS) ? SALEVENT_KEYINPUT : SALEVENT_KEYUP, &aEvent );
+
+		pThis->m_bSendModChangeOnRelease = false;
+		pThis->m_bSingleAltPress = false;
+    }
+
+    return TRUE;
+}
+
+gboolean GtkSalFrame::signalDelete( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_CLOSE, NULL );
+
+    return TRUE;
+}
+
+void GtkSalFrame::signalStyleSet( GtkWidget* pWidget, GtkStyle* pPrevious, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    // every frame gets an initial style set on creation
+    // do not post these as the whole application tends to
+    // redraw itself to adjust to the new style
+    // where there IS no new style resulting in tremendous unnecessary flickering
+    if( pPrevious != NULL )
+        // signalStyleSet does NOT usually have the gdk lock
+        // so post user event to safely dispatch the SALEVENT_SETTINGSCHANGED
+        // note: settings changed for multiple frames is avoided in winproc.cxx ImplHandleSettings
+        pThis->getDisplay()->SendInternalEvent( pThis, NULL, SALEVENT_SETTINGSCHANGED );
+        
+    if( ! pThis->m_pParent ) 
+    {
+        // signalize theme changed for NWF caches
+        // FIXME: should be called only once for a style change
+        GtkSalGraphics::bThemeChanged = TRUE;
+    }
+}
+
+gboolean GtkSalFrame::signalState( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    pThis->m_nState = pEvent->window_state.new_window_state;
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalVisibility( GtkWidget* pWidget, GdkEventVisibility* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    pThis->m_nVisibility = pEvent->state;
+
+    return FALSE;
+}
+
+void GtkSalFrame::signalIMCommit( GtkIMContext* pContext, gchar* pText, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    SalExtTextInputEvent aTextEvent;
+
+    aTextEvent.mnTime 			= 0;
+    aTextEvent.mpTextAttr 		= 0;
+    aTextEvent.maText 			= String( pText, RTL_TEXTENCODING_UTF8 );
+    aTextEvent.mnCursorPos 		= aTextEvent.maText.Len();
+    aTextEvent.mnCursorFlags 	= 0;
+    aTextEvent.mnDeltaStart 	= 0;
+    aTextEvent.mbOnlyCursor 	= False;
+
+    GTK_YIELD_GRAB();
+
+    /* necessary HACK: all keyboard input comes in here as soon as a IMContext is set
+     *  which is logical and consequent. But since even simple input like
+     *  <space> comes through the commit signal instead of signalKey
+     *  and all kinds of windows only implement KeyInput (e.g. PushButtons,
+     *  RadioButtons and a lot of other Controls), will send a single
+     *  KeyInput/KeyUp sequence instead of an ExtText event if there
+     *  never was a preedit and the text is only one character.
+     *
+     *  In this case there the last ExtText event must have been
+     *  SALEVENT_ENDEXTTEXTINPUT, either because of a regular commit
+     *  or because there never was a preedit.
+     */
+    if( ! pThis->m_bWasPreedit && aTextEvent.maText.Len() == 1 )
+    {
+        USHORT nCharCode = GetCharCodeFromUnicode( aTextEvent.maText.GetChar( 0 ) );
+        if( nCharCode != 0 )
+        {
+            SalKeyEvent aEvent;
+            
+            aEvent.mnTime			= 0;
+            aEvent.mnCode			= nCharCode;
+            aEvent.mnCharCode		= aTextEvent.maText.GetChar(0);
+            aEvent.mnRepeat			= 0;
+
+            pThis->m_bWasPreedit = false;
+            pThis->CallCallback( SALEVENT_KEYINPUT, &aEvent );
+            pThis->CallCallback( SALEVENT_KEYUP, &aEvent );
+            return;
+        }
+    }
+
+    pThis->m_bWasPreedit = false;
+    pThis->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
+    pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+}
+
+void GtkSalFrame::signalIMPreeditChanged( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    char*			pText			= NULL;
+    PangoAttrList*	pAttribs		= NULL;
+    gint			nCursorPos		= 0;
+    
+    gtk_im_context_get_preedit_string( pThis->m_pIMContext,
+                                       &pText,
+                                       &pAttribs,
+                                       &nCursorPos );
+    SalExtTextInputEvent aTextEvent;
+
+    aTextEvent.mnTime 			= 0;
+    aTextEvent.maText 			= String( pText, RTL_TEXTENCODING_UTF8 );
+    aTextEvent.mnCursorPos 		= nCursorPos;
+    aTextEvent.mnCursorFlags 	= 0;
+    aTextEvent.mnDeltaStart 	= 0;
+    aTextEvent.mbOnlyCursor 	= False;
+
+    USHORT* pSalAttribs = new USHORT[ aTextEvent.maText.Len() ];
+	// FIXME: more sophisticated attributes
+    for( int i = 0; i < aTextEvent.maText.Len(); ++i )
+        pSalAttribs[i] = SAL_EXTTEXTINPUT_ATTR_UNDERLINE;
+
+    aTextEvent.mpTextAttr 		= pSalAttribs;
+
+    g_free( pText );
+    pango_attr_list_unref( pAttribs );
+    
+    GTK_YIELD_GRAB();
+    pThis->m_bWasPreedit = true;
+    pThis->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
+
+    delete [] pSalAttribs;
+}
+
+void GtkSalFrame::signalIMPreeditStart( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+}
+
+void GtkSalFrame::signalIMPreeditEnd( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+}
+
+gboolean GtkSalFrame::signalIMRetrieveSurrounding( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalIMDeleteSurrounding( GtkIMContext* pContext, gint arg1, gint arg2, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    return FALSE;
+}
Index: vcl/unx/gtk/window/gtkobject.cxx
===================================================================
RCS file: vcl/unx/gtk/window/gtkobject.cxx
diff -N vcl/unx/gtk/window/gtkobject.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/window/gtkobject.cxx	10 May 2004 15:53:24 -0000	1.3
@@ -0,0 +1,220 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkobject.hxx>
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+
+GtkSalObject::GtkSalObject( GtkSalFrame* pParent ) 
+        : m_pSocket( NULL ),
+          m_pRegion( NULL )
+{
+    if( pParent )
+    {
+        // our plug window
+        m_pSocket = gtk_drawing_area_new();
+        // insert into container
+        gtk_fixed_put( pParent->getFixedContainer(),
+                       m_pSocket,
+                       0, 0 );
+        // realize so we can get a window id
+        gtk_widget_realize( m_pSocket );
+
+
+        // make it transparent; some plugins may not insert
+        // their own window here but use the socket window itself
+        gtk_widget_set_app_paintable( m_pSocket, TRUE );
+
+        //system data
+        SalDisplay* pDisp = GetSalData()->GetDisplay();
+        m_aSystemData.pDisplay		= pDisp->GetDisplay();
+        m_aSystemData.aWindow		= GDK_WINDOW_XWINDOW(m_pSocket->window);
+        m_aSystemData.pSalFrame		= NULL;
+        m_aSystemData.pWidget		= m_pSocket;
+        m_aSystemData.pVisual		= pDisp->GetVisual()->GetVisual();
+        m_aSystemData.nDepth		= pDisp->GetVisual()->GetDepth();
+        m_aSystemData.aColormap		= pDisp->GetColormap().GetXColormap();
+        m_aSystemData.pAppContext	= NULL;
+        m_aSystemData.aShellWindow	= GDK_WINDOW_XWINDOW(GTK_WIDGET(pParent->getWindow())->window);
+        m_aSystemData.pShellWidget	= GTK_WIDGET(pParent->getWindow());
+
+        g_signal_connect( G_OBJECT(m_pSocket), "button-press-event", G_CALLBACK(signalButton), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "button-release-event", G_CALLBACK(signalButton), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "focus-in-event", G_CALLBACK(signalFocus), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "focus-out-event", G_CALLBACK(signalFocus), this );
+    }
+}
+
+GtkSalObject::~GtkSalObject()
+{
+    if( m_pRegion )
+        gdk_region_destroy( m_pRegion );
+    if( m_pSocket )
+    {
+        // remove socket from parent frame's fixed container
+        gtk_container_remove( GTK_CONTAINER(gtk_widget_get_parent(m_pSocket)),
+                              m_pSocket );
+        // get rid of the socket
+        gtk_widget_destroy( m_pSocket );
+    }
+}
+
+void GtkSalObject::ResetClipRegion()
+{
+    gdk_window_shape_combine_region( m_pSocket->window, NULL, 0, 0 );
+}
+
+USHORT GtkSalObject::GetClipRegionType()
+{
+    return SAL_OBJECT_CLIP_INCLUDERECTS;
+}
+
+void GtkSalObject::BeginSetClipRegion( ULONG nRects )
+{
+    if( m_pRegion )
+        gdk_region_destroy( m_pRegion );
+    m_pRegion = gdk_region_new();
+}
+
+void GtkSalObject::UnionClipRegion( long nX, long nY, long nWidth, long nHeight )
+{
+    GdkRectangle aRect;
+    aRect.x			= nX;
+    aRect.y			= nY;
+    aRect.width		= nWidth;
+    aRect.height	= nHeight;
+    
+    gdk_region_union_with_rect( m_pRegion, &aRect );
+}
+
+void GtkSalObject::EndSetClipRegion()
+{
+    gdk_window_shape_combine_region( m_pSocket->window, m_pRegion, 0, 0 );
+}
+
+void GtkSalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
+{
+    if( m_pSocket )
+    {
+        GtkFixed* pContainer = GTK_FIXED(gtk_widget_get_parent(m_pSocket));
+        gtk_fixed_move( pContainer, m_pSocket, nX, nY );
+        gtk_widget_set_size_request( m_pSocket, nWidth, nHeight );
+        gtk_container_resize_children( GTK_CONTAINER(pContainer) );
+    }
+}
+
+void GtkSalObject::Show( BOOL bVisible )
+{
+    if( m_pSocket )
+    {
+        if( bVisible )
+            gtk_widget_show( m_pSocket );
+        else
+            gtk_widget_hide( m_pSocket );
+    }
+}
+
+void GtkSalObject::Enable( BOOL nEnable )
+{
+}
+
+void GtkSalObject::GrabFocus()
+{
+}
+
+void GtkSalObject::SetBackground()
+{
+}
+
+void GtkSalObject::SetBackground( SalColor nSalColor )
+{
+}
+
+const SystemEnvData* GtkSalObject::GetSystemData() const
+{
+    return &m_aSystemData;
+}
+
+   
+gboolean GtkSalObject::signalButton( GtkWidget* pWidget, GdkEventButton* pEvent, gpointer object )
+{
+    GtkSalObject* pThis = (GtkSalObject*)object;
+
+    if( pEvent->type == GDK_BUTTON_PRESS )
+    {
+        GTK_YIELD_GRAB();
+        pThis->CallCallback( SALOBJ_EVENT_TOTOP, NULL );
+    }
+
+    return FALSE;
+}
+
+gboolean GtkSalObject::signalFocus( GtkWidget* pWidget, GdkEventFocus* pEvent, gpointer object )
+{
+    GtkSalObject* pThis = (GtkSalObject*)object;
+
+    GTK_YIELD_GRAB();
+
+    pThis->CallCallback( pEvent->in ? SALOBJ_EVENT_GETFOCUS : SALOBJ_EVENT_LOSEFOCUS, NULL );
+
+    return FALSE;
+}
Index: vcl/unx/gtk/window/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/window/makefile.mk
diff -N vcl/unx/gtk/window/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/window/makefile.mk	10 May 2004 15:53:37 -0000	1.4
@@ -0,0 +1,103 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtkwin
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# workaround for makedepend hang
+MKDEPENDSOLVER=
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
+SLOFILES=\
+			$(SLO)$/gtkframe.obj				\
+			$(SLO)$/gtkobject.obj
+.ELSE # "$(ENABLE_GTK)" != ""
+
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
