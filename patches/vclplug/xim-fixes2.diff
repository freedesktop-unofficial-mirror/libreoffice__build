--- vcl/unx/gtk/window/gtkframe.cxx
+++ vcl/unx/gtk/window/gtkframe.cxx
@@ -246,6 +246,9 @@
 	m_bSendModChangeOnRelease = false;
     m_pIMContext		= NULL;
     m_bWasPreedit		= false;
+    m_aPrevKeyPresses.clear();
+    m_nPrevKeyPresses = 0;
+
     // delete graphics if InitCommon is called not from destructor
     for( int i = 0; i < nMaxGraphics; i++ )
     {
@@ -985,8 +988,13 @@
                           G_CALLBACK (signalIMPreeditChanged), this );
         g_signal_connect( m_pIMContext, "retrieve_surrounding",
                           G_CALLBACK (signalIMRetrieveSurrounding), this );
+
         g_signal_connect( m_pIMContext, "delete_surrounding",
                           G_CALLBACK (signalIMDeleteSurrounding), this );
+        g_signal_connect( m_pIMContext, "preedit_start",
+                          G_CALLBACK (signalIMPreeditStart), this );
+        g_signal_connect( m_pIMContext, "preedit_end",
+                          G_CALLBACK (signalIMPreeditEnd), this );
 
         gtk_im_context_set_client_window( m_pIMContext, GTK_WIDGET(m_pWindow)->window );
 		gtk_im_context_focus_in( m_pIMContext );
@@ -994,6 +1002,9 @@
 }
 void GtkSalFrame::EndExtTextInput( USHORT nFlags )
 {
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, "EndExtTextInput: ContextReset\n" );
+#endif
     if( m_pIMContext )
         gtk_im_context_reset( m_pIMContext );
     m_bWasPreedit = false;
@@ -1011,6 +1022,9 @@
 		aArea.y = aPosEvent.mnY;
 		aArea.width = aPosEvent.mnWidth;
 		aArea.height = aPosEvent.mnHeight;
+#if OSL_DEBUG_LEVEL > 1
+		fprintf( stderr, "UpdateIMSpotLocation: SetCursorLocation\n" );
+#endif
 		gtk_im_context_set_cursor_location( m_pIMContext, &aArea );
 	}
 }
@@ -1634,35 +1648,59 @@
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
 
-    static GdkEventKey aLastPressEvent = { GDK_KEY_PRESS, NULL, 0, 0, 0, 0, 0, NULL, 0, 0 };
+	vcl::DeletionListener aDel( pThis );
 
     if( pThis->m_pIMContext )
     {
         if( gtk_im_context_filter_keypress( pThis->m_pIMContext, pEvent ) )
         {
-            aLastPressEvent = *pEvent;
+            if( pEvent->type == GDK_KEY_PRESS )
+			{
+				// Add this key press event to the list of previous key presses
+				// to which we compare key release events.  If a later key release
+				// event has a matching key press event in this list, we swallow
+				// the key release because some GTK Input Methods don't swallow it
+				// for us.
+				pThis->m_aPrevKeyPresses.push_back( PreviousKeyPress(pEvent) );
+				pThis->m_nPrevKeyPresses++;
+            
+				// Also pop off the earliest key press event if there are more than 10
+				// already.
+				while (pThis->m_nPrevKeyPresses > 10)
+				{
+					pThis->m_aPrevKeyPresses.pop_front();
+					pThis->m_nPrevKeyPresses--;
+				}
+			}
             return TRUE;
         }    
-        else
-            if( pEvent->type == GDK_KEY_PRESS )
-                aLastPressEvent.window = NULL;
     }
 
-    // swallow key release events if according keypress was filtered
-    if( pEvent->type == GDK_KEY_RELEASE							&&
-        pEvent->window		== aLastPressEvent.window			&&
-        pEvent->send_event	== aLastPressEvent.send_event		&&
-        pEvent->state		== aLastPressEvent.state			&&
-        pEvent->keyval		== aLastPressEvent.keyval )
-    {
-        aLastPressEvent.window = NULL;
+    if( aDel.isDeleted() )
         return TRUE;
+
+    // Determine if we got an earlier key press event corresponding to this key release
+    if (pEvent->type == GDK_KEY_RELEASE)
+    {
+        std::list<PreviousKeyPress>::iterator    iter     = pThis->m_aPrevKeyPresses.begin();
+        std::list<PreviousKeyPress>::iterator    iter_end = pThis->m_aPrevKeyPresses.end();
+        
+        while (iter != iter_end)
+        {
+            // If we found a corresponding previous key press event, swallow the release
+            // and remove the earlier key press from our list
+            if (*iter == pEvent)
+            {
+                pThis->m_aPrevKeyPresses.erase(iter);
+                pThis->m_nPrevKeyPresses--;
+                return TRUE;
+            }
+            ++iter;
+        }
     }
 
     GTK_YIELD_GRAB();
 
-	vcl::DeletionListener aDel( pThis );
-
 	// handle modifiers
     if( pEvent->keyval == GDK_Shift_L || pEvent->keyval == GDK_Shift_R ||
         pEvent->keyval == GDK_Control_L || pEvent->keyval == GDK_Control_R ||
@@ -1840,6 +1878,10 @@
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
 
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, ":signalImCommit '%s'\n", pText );
+#endif
+
     SalExtTextInputEvent aTextEvent;
 
     aTextEvent.mnTime 			= 0;
@@ -1893,13 +1935,19 @@
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
 
     char*			pText			= NULL;
-    PangoAttrList*	pAttribs		= NULL;
+    PangoAttrList*	pAttrs		    = NULL;
     gint			nCursorPos		= 0;
-    
+
     gtk_im_context_get_preedit_string( pThis->m_pIMContext,
                                        &pText,
-                                       &pAttribs,
+                                       &pAttrs,
                                        &nCursorPos );
+
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, ":signalImPreeditChanged '%s'\n", pText );
+#endif
+	bool bEmptyText = !pText || !strlen( pText );
+
     SalExtTextInputEvent aTextEvent;
 
     aTextEvent.mnTime 			= 0;
@@ -1910,43 +1958,105 @@
     aTextEvent.mbOnlyCursor 	= False;
 
     USHORT* pSalAttribs = new USHORT[ aTextEvent.maText.Len() ];
-	// FIXME: more sophisticated attributes
-    for( int i = 0; i < aTextEvent.maText.Len(); ++i )
-        pSalAttribs[i] = SAL_EXTTEXTINPUT_ATTR_UNDERLINE;
+	for( int i = 0; i < aTextEvent.maText.Len(); ++i )
+        pSalAttribs[i] = 0;
+
+    PangoAttrIterator   *iter       = pango_attr_list_get_iterator (pAttrs);
+    do
+    {
+        GSList *attr_list = NULL;
+        GSList *tmp_list = NULL;
+        gint start, end;
+        guint sal_attr = SAL_EXTTEXTINPUT_ATTR_UNDERLINE;
+
+        pango_attr_iterator_range (iter, &start, &end);
+        if (end == G_MAXINT)
+            end = pText ? strlen (pText) : 0;
+        if (end == start)
+            continue;
+
+        start = g_utf8_pointer_to_offset (pText, pText + start);
+        end = g_utf8_pointer_to_offset (pText, pText + end);
+
+        tmp_list = attr_list = pango_attr_iterator_get_attrs (iter);
+        while (tmp_list)
+        {
+            PangoAttribute *pango_attr = (PangoAttribute *)(tmp_list->data);
+
+            switch (pango_attr->klass->type)
+            {
+                case PANGO_ATTR_BACKGROUND:
+				sal_attr |= (SAL_EXTTEXTINPUT_ATTR_HIGHLIGHT | SAL_EXTTEXTINPUT_CURSOR_INVISIBLE);
+                    break;
+                case PANGO_ATTR_UNDERLINE:
+				sal_attr |= SAL_EXTTEXTINPUT_ATTR_UNDERLINE;
+                    break;
+                case PANGO_ATTR_STRIKETHROUGH:
+                    sal_attr |= SAL_EXTTEXTINPUT_ATTR_REDTEXT;
+                    break;
+                default:
+                    break;
+            }
+            pango_attribute_destroy (pango_attr);
+            tmp_list = tmp_list->next;
+        }
+        g_slist_free (attr_list);
+
+        // Set the sal attributes on our text
+        for (int i = start; i < end; i++)
+            pSalAttribs[i] |= sal_attr;
+    } while (pango_attr_iterator_next (iter));
 
     aTextEvent.mpTextAttr 		= pSalAttribs;
 
     g_free( pText );
-    pango_attr_list_unref( pAttribs );
-    
+    pango_attr_list_unref( pAttrs );
+
+	vcl::DeletionListener aDel( pThis );
     GTK_YIELD_GRAB();
+
     pThis->m_bWasPreedit = true;
     pThis->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
 
+	if( bEmptyText && !aDel.isDeleted() )
+			signalIMPreeditEnd( pContext, frame );
+
     delete [] pSalAttribs;
 }
 
 void GtkSalFrame::signalIMPreeditStart( GtkIMContext* pContext, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, "*** :signalImPreeditStart ***\n" );
+#endif
 }
 
 void GtkSalFrame::signalIMPreeditEnd( GtkIMContext* pContext, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, "*** :signalImPreeditEnd ***\n" );
+#endif
+	pThis->m_bWasPreedit = false;
+	pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 }
 
 gboolean GtkSalFrame::signalIMRetrieveSurrounding( GtkIMContext* pContext, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
-
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, ":signalIMRetrieveSurrounding\n" );
+#endif
     return FALSE;
 }
 
 gboolean GtkSalFrame::signalIMDeleteSurrounding( GtkIMContext* pContext, gint arg1, gint arg2, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
-
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, ":signalIMDeleteSurrounding\n" );
+#endif
     return FALSE;
 }
  




--- vcl/unx/inc/plugins/gtk/gtkframe.hxx
+++ vcl/unx/inc/plugins/gtk/gtkframe.hxx
@@ -94,6 +94,60 @@
         ~GraphicsHolder();
     };
 
+
+    //--------------------------------------------------------
+    // Not all GTK Input Methods swallow key release
+    // events.  Since they swallow the key press events and we
+    // are left with the key release events, we need to
+    // manually swallow those.  To do this, we keep a list of
+    // the previous 10 key press events in each GtkSalFrame
+    // and when we get a key release that matches one of the
+    // key press events in our list, we swallow it.
+    struct PreviousKeyPress
+    {
+        GdkWindow *window;
+        gint8   send_event;
+        guint32 time;
+        guint   state;
+        guint   keyval;
+        
+        PreviousKeyPress (GdkEventKey *event)
+        :   window (NULL),
+            send_event (0),
+            time (0),
+            state (0),
+            keyval (0)
+        {
+            if (event)
+            {
+                window = event->window;
+                send_event = event->send_event;
+                time = event->time;
+                state = event->state;
+                keyval = event->keyval;
+            }
+        }
+        
+        PreviousKeyPress( const PreviousKeyPress& rPrev )
+        :   window( rPrev.window ),
+            send_event( rPrev.send_event ),
+            time( rPrev.time ),
+            state( rPrev.state ),
+            keyval( rPrev.keyval )
+        {}
+        
+        bool PreviousKeyPress::operator== (GdkEventKey *event) const
+        {
+            return (event != NULL)
+                && (event->window == window)
+                && (event->send_event == send_event)
+                && (event->state == state)
+                && (event->keyval == keyval)
+                && (event->time - time < 3)
+                ;
+        }
+    };
+
     GtkWindow*				m_pWindow;
     GdkWindow*				m_pForeignParent;
     GdkWindow*				m_pForeignTopLevel;
@@ -115,6 +169,9 @@
     bool					m_bSendModChangeOnRelease;
     bool					m_bWasPreedit;
 
+    std::list< PreviousKeyPress >   m_aPrevKeyPresses;
+    int                             m_nPrevKeyPresses; // avoid using size()
+
     void Init( SalFrame* pParent, ULONG nStyle );
     void Init( SystemParentData* pSysData );
     void InitCommon();    
