Index: vcl/win/inc/salbmp.h
===================================================================
RCS file: vcl/win/inc/salbmp.h
diff -N vcl/win/inc/salbmp.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/inc/salbmp.h	18 Nov 2003 14:48:14 -0000	1.2
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALBMP_H
+#define _SV_SALBMP_H
+
+#ifndef _SV_WINCOMP_HXX
+#include <wincomp.hxx>
+#endif
+
+#ifndef _GEN_HXX
+#include <tools/gen.hxx>
+#endif
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+
+#ifndef _SV_SALBMP_HXX
+#include <salbmp.hxx>
+#endif
+
+// --------------
+// - SalBitmap	-
+// --------------
+
+struct	BitmapBuffer;
+class	BitmapColor;
+class	BitmapPalette;
+class	SalGraphics;
+
+class WinSalBitmap : public SalBitmap
+{
+private:
+
+	Size				maSize;
+	HGLOBAL 			mhDIB;
+	HBITMAP 			mhDDB;
+	USHORT				mnBitCount;
+
+public:
+
+	HGLOBAL 			ImplGethDIB() const { return mhDIB; }
+	HBITMAP 			ImplGethDDB() const { return mhDDB; }
+
+	static HGLOBAL		ImplCreateDIB( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal );
+	static HANDLE		ImplCopyDIBOrDDB( HANDLE hHdl, bool bDIB );
+	static USHORT		ImplGetDIBColorCount( HGLOBAL hDIB );
+	static void 		ImplDecodeRLEBuffer( const BYTE* pSrcBuf, BYTE* pDstBuf,
+											 const Size& rSizePixel, bool bRLE4 );
+
+public:
+
+						WinSalBitmap();
+	virtual				~WinSalBitmap();
+
+public:
+
+	bool                        Create( HANDLE hBitmap, bool bDIB, bool bCopyHandle );
+	virtual bool                Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal );
+	virtual bool                Create( const SalBitmap& rSalBmpImpl );
+	virtual bool                Create( const SalBitmap& rSalBmpImpl, SalGraphics* pGraphics );
+	virtual bool                Create( const SalBitmap& rSalBmpImpl, USHORT nNewBitCount );
+
+	virtual void                Destroy();
+
+	virtual Size                GetSize() const { return maSize; }
+	virtual USHORT              GetBitCount() const { return mnBitCount; }
+
+	virtual BitmapBuffer*		AcquireBuffer( bool bReadOnly );
+	virtual void                ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly );
+};
+
+#endif // _SV_SALBMP_HXX
Index: vcl/win/inc/saldata.hxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/saldata.hxx,v
retrieving revision 1.11
retrieving revision 1.14
diff -u -p -u -r1.11 -r1.14
--- vcl/win/inc/saldata.hxx	28 May 2003 12:34:54 -0000	1.11
+++ vcl/win/inc/saldata.hxx	10 May 2004 16:01:23 -0000	1.14
@@ -75,25 +75,12 @@
 #include <wincomp.hxx>
 #endif
 
-// as long as we're using the old skd header files, define some of the new XP constants here
-
-#ifndef SPI_GETFLATMENU
-#define SPI_GETFLATMENU     0x1022
-#endif
-#ifndef COLOR_MENUBAR
-#define COLOR_MENUBAR       30
-#endif
-#ifndef COLOR_MENUHILIGHT
-#define COLOR_MENUHILIGHT   29   
-#endif
-
-
 class AutoTimer;
-class SalInstance;
-class SalObject;
-class SalFrame;
-class SalVirtualDevice;
-class SalPrinter;
+class WinSalInstance;
+class WinSalObject;
+class WinSalFrame;
+class WinSalVirtualDevice;
+class WinSalPrinter;
 class Font;
 struct HDCCache;
 struct TempFontItem;
@@ -122,13 +109,20 @@ struct SalIcon
 // - SalData -
 // -----------
 
-struct SalData
+class SalData
 {
+public:
+    SalData();
+    ~SalData();
+
+    // native widget framework
+    void    initNWF();
+    void    deInitNWF();
+
+public:
     HINSTANCE               mhInst;                 // default instance handle
     HINSTANCE               mhPrevInst;             // previous instance handle
     int                     mnCmdShow;              // default frame show style
-    // Erst hier koennen Daten kompatible eingefuegt werden, da die
-    // oberen Daten in salmain.cxx modifiziert werden
     HPALETTE                mhDitherPal;            // dither palette
     HGLOBAL                 mhDitherDIB;            // dither memory handle
     BYTE*                   mpDitherDIB;            // dither memory
@@ -139,16 +133,15 @@ struct SalData
     ULONG                   mnTimerMS;              // Current Time (in MS) of the Timer
     ULONG                   mnTimerOrgMS;           // Current Original Time (in MS)
     UINT                    mnTimerId;              // windows timer id
-    SALTIMERPROC            mpTimerProc;            // timer callback proc
     BOOL                    mbInTimerProc;          // timer event is currently being dispatched
     HHOOK                   mhSalObjMsgHook;        // hook to get interesting msg for SalObject
     HWND                    mhWantLeaveMsg;         // window handle, that want a MOUSELEAVE message
     AutoTimer*              mpMouseLeaveTimer;      // Timer for MouseLeave Test
-    SalInstance*            mpFirstInstance;        // pointer of first instance
-    SalFrame*               mpFirstFrame;           // pointer of first frame
-    SalObject*              mpFirstObject;          // pointer of first object window
-    SalVirtualDevice*       mpFirstVD;              // first VirDev
-    SalPrinter*             mpFirstPrinter;         // first printing printer
+    WinSalInstance*         mpFirstInstance;        // pointer of first instance
+    WinSalFrame*            mpFirstFrame;           // pointer of first frame
+    WinSalObject*           mpFirstObject;          // pointer of first object window
+    WinSalVirtualDevice*    mpFirstVD;              // first VirDev
+    WinSalPrinter*          mpFirstPrinter;         // first printing printer
     HDCCache*               mpHDCCache;             // Cache for three DC's
     HBITMAP                 mh50Bmp;                // 50% Bitmap
     HBRUSH                  mh50Brush;              // 50% Brush
@@ -169,6 +162,8 @@ struct SalData
     SysAgt_Enable_PROC      mpSageEnableProc;       // funktion to deactivate the system agent
     SalIcon*                mpFirstIcon;            // icon cache, points to first icon, NULL if none
     TempFontItem*           mpTempFontItem;
+    BOOL                    mbThemeChanged;         // true if visual theme was changed: throw away theme handles
+
 };
 
 inline void SetSalData( SalData* pData ) { ImplGetSVData()->mpSalData = (void*)pData; }
@@ -266,7 +261,7 @@ long ImplHandleSalObjSysCharMsg( HWND hW
 BOOL ImplHandleGlobalMsg( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT& rlResult );
 
 // \WIN\SOURCE\WINDOW\SALOBJ.CXX
-SalObject* ImplFindSalObject( HWND hWndChild );
+WinSalObject* ImplFindSalObject( HWND hWndChild );
 BOOL ImplSalPreDispatchMsg( MSG* pMsg );
 void ImplSalPostDispatchMsg( MSG* pMsg, LRESULT nDispatchResult );
 
@@ -383,24 +378,24 @@ WIN_BOOL    ImplGetMessage( LPMSG lpMsg,
 WIN_BOOL    ImplPeekMessage( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg );
 LONG        ImplDispatchMessage( CONST MSG *lpMsg );
 
-inline void SetWindowPtr( HWND hWnd, SalFrame* pThis )
+inline void SetWindowPtr( HWND hWnd, WinSalFrame* pThis )
 {
     ImplSetWindowLong( hWnd, SAL_FRAME_THIS, (LONG)pThis );
 }
 
-inline SalFrame* GetWindowPtr( HWND hWnd )
+inline WinSalFrame* GetWindowPtr( HWND hWnd )
 {
-    return (SalFrame*)ImplGetWindowLong( hWnd, SAL_FRAME_THIS );
+    return (WinSalFrame*)ImplGetWindowLong( hWnd, SAL_FRAME_THIS );
 }
 
-inline void SetSalObjWindowPtr( HWND hWnd, SalObject* pThis )
+inline void SetSalObjWindowPtr( HWND hWnd, WinSalObject* pThis )
 {
     ImplSetWindowLong( hWnd, SAL_OBJECT_THIS, (LONG)pThis );
 }
 
-inline SalObject* GetSalObjWindowPtr( HWND hWnd )
+inline WinSalObject* GetSalObjWindowPtr( HWND hWnd )
 {
-    return (SalObject*)ImplGetWindowLong( hWnd, SAL_OBJECT_THIS );
+    return (WinSalObject*)ImplGetWindowLong( hWnd, SAL_OBJECT_THIS );
 }
 
 #endif  // _SV_SALDATA_HXX
Index: vcl/win/inc/salframe.h
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/salframe.h,v
retrieving revision 1.7
retrieving revision 1.9
diff -u -p -u -r1.7 -r1.9
--- vcl/win/inc/salframe.h	19 Mar 2002 17:09:35 -0000	1.7
+++ vcl/win/inc/salframe.h	18 Nov 2003 16:03:05 -0000	1.9
@@ -70,21 +70,27 @@
 #include <sysdata.hxx>
 #endif
 
+#ifndef _SV_SALFRAME_HXX
+#include <salframe.hxx>
+#endif
+
+class WinSalGraphics;
+
 // ----------------
-// - SalFrameData -
+// - WinSalFrame -
 // ----------------
 
-class SalFrameData
+class WinSalFrame : public SalFrame
 {
 public:
     HWND                    mhWnd;                  // Window handle
     HCURSOR                 mhCursor;               // cursor handle
     HIMC                    mhDefIMEContext;        // default IME-Context
-    SalGraphics*            mpGraphics;             // current frame graphics
-    SalGraphics*            mpGraphics2;            // current frame graphics for other threads
-    SalFrame*               mpNextFrame;            // pointer to next frame
-    void*                   mpInst;                 // instance handle for callback
-    SALFRAMEPROC            mpProc;                 // callback proc
+    WinSalGraphics*         mpGraphics;             // current frame graphics
+    WinSalGraphics*         mpGraphics2;            // current frame graphics for other threads
+    WinSalFrame*            mpNextFrame;            // pointer to next frame
+    HMENU                   mSelectedhMenu;         // the menu where highlighting is currently going on
+    HMENU                   mLastActivatedhMenu;    // the menu that was most recently opened
     SystemEnvData           maSysData;              // system data
     SalFrameState           maState;                // frame state
     int                     mnShowState;            // show state
@@ -118,7 +124,51 @@ public:
     BOOL                    mbSpezIME;              // TRUE: Spez IME
     BOOL                    mbAtCursorIME;          // TRUE: Wir behandeln nur einige IME-Messages
     BOOL                    mbCandidateMode;        // TRUE: Wir befinden uns im Candidate-Modus
-    BOOL                    mbInReparent;           // TRUE: ignore focus lost and gain due to reparenting
+    static BOOL             mbInReparent;           // TRUE: ignore focus lost and gain due to reparenting
+
+public:
+    WinSalFrame();
+    virtual ~WinSalFrame();
+
+    virtual SalGraphics*		GetGraphics();
+    virtual void				ReleaseGraphics( SalGraphics* pGraphics );
+    virtual BOOL				PostEvent( void* pData );
+    virtual void				SetTitle( const XubString& rTitle );
+    virtual void				SetIcon( USHORT nIcon );
+    virtual void                                SetMenu( SalMenu* pSalMenu );
+    virtual void                                DrawMenuBar();
+    virtual void				Show( BOOL bVisible, BOOL bNoActivate = FALSE );
+    virtual void				Enable( BOOL bEnable );
+    virtual void              SetMinClientSize( long nWidth, long nHeight );
+    virtual void				SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags );
+    virtual void				GetClientSize( long& rWidth, long& rHeight );
+    virtual void				GetWorkArea( Rectangle& rRect );
+    virtual SalFrame*			GetParent() const;
+    virtual void				SetWindowState( const SalFrameState* pState );
+    virtual BOOL				GetWindowState( SalFrameState* pState );
+    virtual void				ShowFullScreen( BOOL bFullScreen );
+    virtual void				StartPresentation( BOOL bStart );
+    virtual void				SetAlwaysOnTop( BOOL bOnTop );
+    virtual void				ToTop( USHORT nFlags );
+    virtual void				SetPointer( PointerStyle ePointerStyle );
+    virtual void				CaptureMouse( BOOL bMouse );
+    virtual void				SetPointerPos( long nX, long nY );
+    virtual void				Flush();
+    virtual void				Sync();
+    virtual void				SetInputContext( SalInputContext* pContext );
+    virtual void				EndExtTextInput( USHORT nFlags );
+    virtual String				GetKeyName( USHORT nKeyCode );
+    virtual String				GetSymbolKeyName( const XubString& rFontName, USHORT nKeyCode );
+    virtual LanguageType		GetInputLanguage();
+    virtual SalBitmap*			SnapShot();
+    virtual void				UpdateSettings( AllSettings& rSettings );
+    virtual void				Beep( SoundType eSoundType );
+    virtual const SystemEnvData*	GetSystemData() const;
+    virtual ULONG				GetCurrentModButtons();
+    virtual void				SetParent( SalFrame* pNewParent );
+    virtual bool				SetPluginParent( SystemParentData* pNewParent );
 };
+
+void ImplSalGetWorkArea( HWND hWnd, RECT *pRect, const RECT *pParentRect );
 
 #endif // _SV_SALFRAME_H
Index: vcl/win/inc/salgdi.h
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/salgdi.h,v
retrieving revision 1.8
retrieving revision 1.12
diff -u -p -u -r1.8 -r1.12
--- vcl/win/inc/salgdi.h	28 May 2003 12:35:06 -0000	1.8
+++ vcl/win/inc/salgdi.h	10 May 2004 16:01:37 -0000	1.12
@@ -68,6 +68,9 @@
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
 
 #include "boost/scoped_ptr.hpp"
 
@@ -100,7 +103,7 @@ public:
 // - SalGraphicsData -
 // -------------------
 
-class SalGraphicsData
+class WinSalGraphics : public SalGraphics
 {
 public:
 	HDC 					mhDC;				// HDC
@@ -141,11 +144,177 @@ public:
     // SalGraphics::GetTextLayout, to cache data derived from mhDC's font;
     // flushed whenever a new font is selected into mhDC:
     boost::scoped_ptr< ImplTextLayoutCache > mxTextLayoutCache;
+public:
+    WinSalGraphics();
+    virtual ~WinSalGraphics();
+
+protected:
+    virtual BOOL		unionClipRegion( long nX, long nY, long nWidth, long nHeight );
+    // draw --> LineColor and FillColor and RasterOp and ClipRegion
+    virtual void		drawPixel( long nX, long nY );
+    virtual void		drawPixel( long nX, long nY, SalColor nSalColor );
+    virtual void		drawLine( long nX1, long nY1, long nX2, long nY2 );
+    virtual void		drawRect( long nX, long nY, long nWidth, long nHeight );
+    virtual void		drawPolyLine( ULONG nPoints, const SalPoint* pPtAry );
+    virtual void		drawPolygon( ULONG nPoints, const SalPoint* pPtAry );
+    virtual void		drawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry );
+    virtual sal_Bool	drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry );
+    virtual sal_Bool	drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry );
+    virtual sal_Bool	drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints, const SalPoint* const* pPtAry, const BYTE* const* pFlgAry );
+
+    // CopyArea --> No RasterOp, but ClipRegion
+    virtual void		copyArea( long nDestX, long nDestY, long nSrcX, long nSrcY, long nSrcWidth,
+                                  long nSrcHeight, USHORT nFlags );
+    
+    // CopyBits and DrawBitmap --> RasterOp and ClipRegion
+    // CopyBits() --> pSrcGraphics == NULL, then CopyBits on same Graphics
+    virtual void		copyBits( const SalTwoRect* pPosAry, SalGraphics* pSrcGraphics );
+    virtual void		drawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap );
+    virtual void		drawBitmap( const SalTwoRect* pPosAry,
+                                    const SalBitmap& rSalBitmap,
+                                    SalColor nTransparentColor );
+    virtual void		drawBitmap( const SalTwoRect* pPosAry,
+                                    const SalBitmap& rSalBitmap,
+                                    const SalBitmap& rTransparentBitmap );
+    virtual void		drawMask( const SalTwoRect* pPosAry,
+                                  const SalBitmap& rSalBitmap,
+                                  SalColor nMaskColor );
+    
+    virtual SalBitmap*	getBitmap( long nX, long nY, long nWidth, long nHeight );
+    virtual SalColor	getPixel( long nX, long nY );
+
+    // invert --> ClipRegion (only Windows or VirDevs)
+    virtual void		invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags);
+    virtual void		invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags );
+
+    virtual BOOL		drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize );
+
+    // native widget rendering methods that require mirroring
+    virtual BOOL        hitTestNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                              const Point& aPos, SalControlHandle& rControlHandle, BOOL& rIsInside );
+    virtual BOOL        drawNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                           ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+                                           rtl::OUString aCaption );
+    virtual BOOL        drawNativeControlText( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                               ControlState nState, const ImplControlValue& aValue,
+                                               SalControlHandle& rControlHandle, rtl::OUString aCaption );
+    virtual BOOL        getNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
+                                                const ImplControlValue& aValue, SalControlHandle& rControlHandle, rtl::OUString aCaption,
+                                                Region &rNativeBoundingRegion, Region &rNativeContentRegion );
+
+public:
+    // public SalGraphics methods, the interface to teh independent vcl part
+
+    // get device resolution
+    virtual void			GetResolution( long& rDPIX, long& rDPIY );
+    // get resolution for fonts (an implementations specific adjustment,
+    // ideally would be the same as the Resolution)
+    virtual void			GetScreenFontResolution( long& rDPIX, long& rDPIY );
+    // get the depth of the device
+    virtual USHORT			GetBitCount();
+    // get the width of the device
+    virtual long			GetGraphicsWidth();
+
+    // set the clip region to empty
+    virtual void			ResetClipRegion();
+    // begin setting the clip region, add rectangles to the
+    // region with the UnionClipRegion call
+    virtual void			BeginSetClipRegion( ULONG nCount );
+    // all rectangles were added and the clip region should be set now
+    virtual void			EndSetClipRegion();
+
+    // set the line color to transparent (= don't draw lines)
+    virtual void			SetLineColor();
+    // set the line color to a specific color
+    virtual void			SetLineColor( SalColor nSalColor );
+    // set the fill color to transparent (= don't fill)
+    virtual void			SetFillColor();
+    // set the fill color to a specific color, shapes will be
+    // filled accordingly
+    virtual void          	SetFillColor( SalColor nSalColor );
+    // enable/disable XOR drawing
+    virtual void			SetXORMode( BOOL bSet );
+    // set line color for raster operations
+    virtual void			SetROPLineColor( SalROPColor nROPColor );
+    // set fill color for raster operations
+    virtual void			SetROPFillColor( SalROPColor nROPColor );
+    // set the text color to a specific color
+    virtual void			SetTextColor( SalColor nSalColor );
+    // set the font
+    virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel );
+    // get the current font's etrics
+    virtual void			GetFontMetric( ImplFontMetricData* );
+    // get kernign pairs of the current font
+    // return only PairCount if (pKernPairs == NULL)
+    virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
+    // get the repertoire of the current font; the code pairs returned
+    // contain unicode ranges. if pCodePairs is NULL return only the
+    // number of pairs which would be filled
+    virtual ULONG			GetFontCodeRanges( sal_uInt32* pCodePairs ) const;
+    // graphics must fill supplied font list
+    virtual void			GetDevFontList( ImplDevFontList* );
+    // graphics should call ImplAddDevFontSubstitute on supplied
+    // OutputDevice for all its device specific preferred font substitutions
+    virtual void			GetDevFontSubstList( OutputDevice* );
+    virtual ImplFontData*	AddTempDevFont( const String& rFileURL, const String& rFontName );
+    // CreateFontSubset: a method to get a subset of glyhps of a font
+    // inside a new valid font file
+    // returns TRUE if creation of subset was successfull
+    // parameters: rToFile: contains a osl file URL to write the subset to
+    //             pFont: describes from which font to create a subset
+    //             pGlyphIDs: the glyph ids to be extracted
+    //             pEncoding: the character code corresponding to each glyph
+    //             pWidths: the advance widths of the correspoding glyphs (in PS font units)
+    //             nGlyphs: the number of glyphs
+    //             rInfo: additional outgoing information
+    // implementation note: encoding 0 with glyph id 0 should be added implicitly
+    // as "undefined character"
+    virtual BOOL			CreateFontSubset( const rtl::OUString& rToFile,
+                                              ImplFontData* pFont,
+                                              long* pGlyphIDs,
+                                              sal_uInt8* pEncoding,
+                                              sal_Int32* pWidths,
+                                              int nGlyphs,
+                                              FontSubsetInfo& rInfo // out parameter
+                                              );
+
+    // GetFontEncodingVector: a method to get the encoding map Unicode
+	// to font encoded character; this is only used for type1 fonts and
+    // may return NULL in case of unknown encoding vector
+    // if ppNonEncoded is set and non encoded characters (that is type1
+    // glyphs with only a name) exist it is set to the corresponding
+    // map for non encoded glyphs; the encoding vector contains -1
+    // as encoding for these cases
+    virtual const std::map< sal_Unicode, sal_Int32 >* GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** ppNonEncoded );
+
+    // GetEmbedFontData: gets the font data for a font marked
+    // embeddable by GetDevFontList or NULL in case of error
+    // parameters: pFont: describes the font in question
+    //             pWidths: the widths of all glyphs from char code 0 to 255
+    //                      pWidths MUST support at least 256 members;
+    //             rInfo: additional outgoing information
+    //             pDataLen: out parameter, contains the byte length of the returned buffer
+    virtual const void*	GetEmbedFontData( ImplFontData* pFont,
+                                          const sal_Unicode* pUnicodes,
+                                          sal_Int32* pWidths,
+                                          FontSubsetInfo& rInfo,
+                                          long* pDataLen );
+    // frees the font data again
+    virtual void			FreeEmbedFontData( const void* pData, long nDataLen );
+
+    virtual BOOL                    GetGlyphBoundRect( long nIndex, Rectangle& );
+    virtual BOOL                    GetGlyphOutline( long nIndex, PolyPolygon& );
+
+    virtual SalLayout*              GetTextLayout( ImplLayoutArgs&, int nFallbackLevel );
+    virtual void					 DrawServerFontLayout( const ServerFontLayout& );
+
+    // Query the platform layer for control support
+    virtual BOOL IsNativeControlSupported( ControlType nType, ControlPart nPart );
 };
 
 // Init/Deinit Graphics
-void	ImplSalInitGraphics( SalGraphicsData* mpData );
-void	ImplSalDeInitGraphics( SalGraphicsData* mpData );
+void	ImplSalInitGraphics( WinSalGraphics* mpData );
+void	ImplSalDeInitGraphics( WinSalGraphics* mpData );
 void	ImplUpdateSysColorEntries();
 int 	ImplIsSysColorEntry( SalColor nSalColor );
 void	ImplGetLogFontFromFontSelect( HDC hDC,
@@ -157,11 +326,7 @@ void	ImplGetLogFontFromFontSelect( HDC h
 // - Defines -
 // -----------
 
-#ifdef WIN
-#define MAX_64KSALPOINTS	((((USHORT)0xFFFF)-4)/sizeof(POINT))
-#else
 #define MAX_64KSALPOINTS	((((USHORT)0xFFFF)-8)/sizeof(POINTS))
-#endif
 
 // -----------
 // - Inlines -
Index: vcl/win/inc/salinst.h
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/salinst.h,v
retrieving revision 1.4
retrieving revision 1.7
diff -u -p -u -r1.4 -r1.7
--- vcl/win/inc/salinst.h	11 Apr 2003 17:35:32 -0000	1.4
+++ vcl/win/inc/salinst.h	18 May 2004 10:59:00 -0000	1.7
@@ -66,34 +66,74 @@
 #include <sv.h>
 #endif
 
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
+
 namespace vos { class OMutex; }
-class SalYieldMutex;
-class SalInstance;
-class SalFrame;
-class SalObject;
 
 // -------------------
 // - SalInstanceData -
 // -------------------
 
-class SalInstanceData
+class SalYieldMutex;
+
+class WinSalInstance : public SalInstance
 {
 public:
 	HINSTANCE			mhInst; 				// Instance Handle
 	HWND				mhComWnd;				// window, for communication (between threads and the main thread)
-	void*				mpFilterInst;
-	void*				mpFilterCallback;
 	SalYieldMutex*		mpSalYieldMutex;		// Sal-Yield-Mutex
 	vos::OMutex*		mpSalWaitMutex; 		// Sal-Wait-Mutex
 	USHORT				mnYieldWaitCount;		// Wait-Count
+public:
+    WinSalInstance();
+    virtual ~WinSalInstance();
+
+    virtual SalFrame*      	CreateChildFrame( SystemParentData* pParent, ULONG nStyle );
+    virtual SalFrame*      	CreateFrame( SalFrame* pParent, ULONG nStyle );
+    virtual void			DestroyFrame( SalFrame* pFrame );
+    virtual SalObject*		CreateObject( SalFrame* pParent );
+    virtual void			DestroyObject( SalObject* pObject );
+    virtual SalVirtualDevice*	CreateVirtualDevice( SalGraphics* pGraphics,
+                                                     long nDX, long nDY,
+                                                     USHORT nBitCount );
+    virtual void			DestroyVirtualDevice( SalVirtualDevice* pDevice );
+
+    virtual SalInfoPrinter*	CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
+                                               ImplJobSetup* pSetupData );
+    virtual void			DestroyInfoPrinter( SalInfoPrinter* pPrinter );
+    virtual SalPrinter*		CreatePrinter( SalInfoPrinter* pInfoPrinter );
+    virtual void			DestroyPrinter( SalPrinter* pPrinter );
+    virtual void			GetPrinterQueueInfo( ImplPrnQueueList* pList );
+    virtual void			GetPrinterQueueState( SalPrinterQueueInfo* pInfo );
+    virtual void			DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo );
+    virtual String             GetDefaultPrinter();
+    virtual SalSound*			CreateSalSound();
+    virtual SalTimer*			CreateSalTimer();
+    virtual SalOpenGL*			CreateSalOpenGL( SalGraphics* pGraphics );
+    virtual SalI18NImeStatus*	CreateI18NImeStatus();
+    virtual SalSystem*			CreateSalSystem();
+    virtual SalBitmap*			CreateSalBitmap();
+    virtual vos::IMutex*		GetYieldMutex();
+    virtual ULONG				ReleaseYieldMutex();
+    virtual void				AcquireYieldMutex( ULONG nCount );
+    virtual void				Yield( BOOL bWait );
+    virtual bool				AnyInput( USHORT nType );
+    virtual SalMenu*				CreateMenu( BOOL bMenuBar );
+    virtual void				DestroyMenu( SalMenu* );
+    virtual SalMenuItem*			CreateMenuItem( const SalItemParams* pItemData );
+    virtual void				DestroyMenuItem( SalMenuItem* );
+    virtual SalSession*                         CreateSalSession();
+    virtual void*				GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes );
 };
 
 // --------------
 // - Prototypen -
 // --------------
 
-SalFrame* ImplSalCreateFrame( SalInstance* pInst, HWND hWndParent, ULONG nSalFrameStyle );
-SalObject* ImplSalCreateObject( SalInstance* pInst, SalFrame* pParent );
+SalFrame* ImplSalCreateFrame( WinSalInstance* pInst, HWND hWndParent, ULONG nSalFrameStyle );
+SalObject* ImplSalCreateObject( WinSalInstance* pInst, WinSalFrame* pParent );
 HWND ImplSalReCreateHWND( HWND hWndParent, HWND oldhWnd, BOOL bAsChild );
 void ImplSalStartTimer( ULONG nMS, BOOL bMutex = FALSE );
 void ImplSalPrinterAbortJobAsync( HDC hPrnDC );
Index: vcl/win/inc/salmenu.h
===================================================================
RCS file: vcl/win/inc/salmenu.h
diff -N vcl/win/inc/salmenu.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/inc/salmenu.h	20 Nov 2003 13:03:11 -0000	1.3
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALMENU_H
+#define _SV_SALMENU_H
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _SV_BITMAP_HXX
+#include <bitmap.hxx>
+#endif
+#ifndef _SV_SALMENU_HXX
+#include <salmenu.hxx>
+#endif
+
+
+class WinSalMenu : public SalMenu
+{
+public:
+    WinSalMenu();
+    virtual ~WinSalMenu();
+    virtual BOOL VisibleMenuBar();  // must return TRUE to actually DISPLAY native menu bars
+                            // otherwise only menu messages are processed (eg, OLE on Windows)
+
+    virtual void InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos );
+    virtual void RemoveItem( unsigned nPos );
+    virtual void SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos );
+    virtual void SetFrame( const SalFrame* pFrame );
+    virtual void CheckItem( unsigned nPos, BOOL bCheck );
+    virtual void EnableItem( unsigned nPos, BOOL bEnable );
+    virtual void SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const XubString& rText );
+    virtual void SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage );
+    virtual void SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const XubString& rKeyName );
+    virtual void GetSystemMenuData( SystemMenuData* pData );
+
+    HMENU mhMenu;           // the menu handle
+    BOOL  mbMenuBar;        // true for menu bars
+    HWND  mhWnd;            // the window handle where the menubar is attached, may be NULL
+    WinSalMenu *mpParentMenu;  // the parent menu
+};
+
+class WinSalMenuItem : public SalMenuItem
+{
+public:
+    WinSalMenuItem();
+    virtual ~WinSalMenuItem();
+
+
+    MENUITEMINFOW mInfo;
+    void*     mpMenu;       // pointer to corresponding VCL menu
+    XubString mText;        // the item text
+    XubString mAccelText;   // the accelerator string
+    Bitmap    maBitmap;     // item image
+    int       mnId;         // item id
+    WinSalMenu*  mpSalMenu;    // the menu where this item is inserted
+};
+
+#endif // _SV_SALMENU_H
+
Index: vcl/win/inc/salnativewidgets.h
===================================================================
RCS file: vcl/win/inc/salnativewidgets.h
diff -N vcl/win/inc/salnativewidgets.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/inc/salnativewidgets.h	10 May 2004 16:01:47 -0000	1.2
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_NATIVEWIDGETS_H
+#define _SV_NATIVEWIDGETS_H
+
+
+#ifdef __cplusplus
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+
+/* SalControlHandleData:
+ * 
+ *   Holds platform specific theming data.
+ */
+
+class SalControlHandleData
+{
+	public:
+		SalControlHandleData( void );
+		~SalControlHandleData( void );
+
+	public:
+        // nothing needed on Win32
+};
+
+
+#endif	/* __cplusplus */
+
+#endif
Index: vcl/win/inc/salobj.h
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/salobj.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/win/inc/salobj.h	18 Sep 2000 17:05:49 -0000	1.1.1.1
+++ vcl/win/inc/salobj.h	18 Nov 2003 14:49:11 -0000	1.2
@@ -68,12 +68,15 @@
 #ifndef _SV_SYSDATA_HXX
 #include <sysdata.hxx>
 #endif
+#ifndef _SV_SALOBJ_HXX
+#include <salobj.hxx>
+#endif
 
 // -----------------
 // - SalObjectData -
 // -----------------
 
-class SalObjectData
+class WinSalObject : public SalObject
 {
 public:
 	HWND					mhWnd;					// Window handle
@@ -84,9 +87,24 @@ public:
 	RGNDATA*				mpStdClipRgnData;		// Cache Standard-ClipRegion-Data
 	RECT*					mpNextClipRect; 		// Naechstes ClipRegion-Rect
 	BOOL					mbFirstClipRect;		// Flag for first cliprect to insert
-	SalObject*				mpNextObject;			// pointer to next object
-	void*					mpInst; 				// instance handle for callback
-	SALOBJECTPROC			mpProc; 				// callback proc
+	WinSalObject*				mpNextObject;			// pointer to next object
+
+
+    WinSalObject();
+    virtual ~WinSalObject();
+
+	virtual void					ResetClipRegion();
+	virtual USHORT					GetClipRegionType();
+	virtual void					BeginSetClipRegion( ULONG nRects );
+	virtual void					UnionClipRegion( long nX, long nY, long nWidth, long nHeight );
+	virtual void					EndSetClipRegion();
+	virtual void					SetPosSize( long nX, long nY, long nWidth, long nHeight );
+	virtual void					Show( BOOL bVisible );
+	virtual void					Enable( BOOL nEnable );
+	virtual void					GrabFocus();
+	virtual void					SetBackground();
+	virtual void					SetBackground( SalColor nSalColor );
+	virtual const SystemEnvData*	GetSystemData() const;
 };
 
 #endif // _SV_SALOBJ_H
Index: vcl/win/inc/salogl.h
===================================================================
RCS file: vcl/win/inc/salogl.h
diff -N vcl/win/inc/salogl.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/inc/salogl.h	18 Nov 2003 14:49:19 -0000	1.2
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALOGL_H
+#define _SV_SALOGL_H
+
+#define _OPENGL_EXT
+
+#ifndef _SV_WINCOMP_HXX
+#include <wincomp.hxx>
+#endif
+#ifndef _GEN_HXX
+#include <tools/gen.hxx>
+#endif
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _SV_SALOGL_HXX
+#include <salogl.hxx>
+#endif
+
+// -----------------
+// - State defines -
+// -----------------
+
+#define OGL_STATE_UNLOADED		(0x00000000)
+#define OGL_STATE_INVALID		(0x00000001)
+#define OGL_STATE_VALID 		(0x00000002)
+
+// -------------
+// - SalOpenGL -
+// -------------
+
+class SalGraphics;
+class String;
+
+class WinSalOpenGL : public SalOpenGL
+{
+private:
+	static HGLRC		mhOGLContext;
+	static HDC			mhOGLLastDC;
+	static ULONG		mnOGLState;
+
+private:
+	static BOOL 		ImplInitLib();
+	static BOOL 		ImplInit();
+	static void 		ImplFreeLib();
+
+public:
+    WinSalOpenGL( SalGraphics* );
+    virtual ~WinSalOpenGL();
+						
+	virtual bool		IsValid();
+	virtual void*		GetOGLFnc( const char * );
+	virtual void		OGLEntry( SalGraphics* pGraphics );
+	virtual void		OGLExit( SalGraphics* pGraphics );
+    virtual void		StartScene( SalGraphics* pGraphics );
+	virtual void		StopScene();
+
+    static void         Release();
+};
+
+#endif // _SV_SALOGL_H
Index: vcl/win/inc/salprn.h
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/salprn.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/win/inc/salprn.h	18 Sep 2000 17:05:49 -0000	1.1.1.1
+++ vcl/win/inc/salprn.h	18 Nov 2003 14:49:31 -0000	1.2
@@ -66,8 +66,9 @@
 #include <sv.h>
 #endif
 
-class SalGraphics;
-class SalInfoPrinter;
+#ifndef _SV_SALPRN_HXX
+#include <salprn.hxx>
+#endif
 
 // -----------------
 // - SalDriverData -
@@ -105,14 +106,16 @@ struct SalSysQueueData
 	BOOL					mbAnsi; 				// TRUE - use A functions
 };
 
-// ----------------------
-// - SalInfoPrinterData -
-// ----------------------
+// ---------------------
+// - WinSalInfoPrinter -
+// ---------------------
+
+class WinSalGraphics;
 
-class SalInfoPrinterData
+class WinSalInfoPrinter : public SalInfoPrinter
 {
 public:
-	SalGraphics*			mpGraphics; 			// current Printer graphics
+	WinSalGraphics*			mpGraphics; 			// current Printer graphics
 	XubString				maDriverName;			// printer driver name
 	XubString				maDeviceName;			// printer device name
 	XubString				maPortName; 			// printer port name
@@ -122,23 +125,57 @@ public:
 	HDC 					mhDC;					// printer hdc
 	BOOL					mbGraphics; 			// is Graphics used
 	BOOL					mbAnsi;
+
+public:
+    WinSalInfoPrinter();
+    virtual ~WinSalInfoPrinter();
+
+	virtual SalGraphics*			GetGraphics();
+	virtual void					ReleaseGraphics( SalGraphics* pGraphics );
+	virtual BOOL					Setup( SalFrame* pFrame, ImplJobSetup* pSetupData );
+	virtual BOOL					SetPrinterData( ImplJobSetup* pSetupData );
+	virtual BOOL					SetData( ULONG nFlags, ImplJobSetup* pSetupData );
+	virtual void					GetPageInfo( const ImplJobSetup* pSetupData,
+                                                 long& rOutWidth, long& rOutHeight,
+                                                 long& rPageOffX, long& rPageOffY,
+                                                 long& rPageWidth, long& rPageHeight );
+	virtual ULONG					GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType );
+	virtual ULONG					GetPaperBinCount( const ImplJobSetup* pSetupData );
+	virtual String					GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin );
+    virtual void					InitPaperFormats( const ImplJobSetup* pSetupData );
+    virtual int					GetLandscapeAngle( const ImplJobSetup* pSetupData );
 };
 
-// ------------------
-// - SalPrinterData -
-// ------------------
+// -----------------
+// - WinSalPrinter -
+// -----------------
 
-class SalPrinterData
+class WinSalPrinter : public SalPrinter
 {
 public:
-	SalGraphics*			mpGraphics; 			// current Printer graphics
-	SalInfoPrinter* 		mpInfoPrinter;			// pointer to the compatible InfoPrinter
-	SalPrinter* 			mpNextPrinter;			// next printing printer
+	WinSalGraphics*			mpGraphics; 			// current Printer graphics
+	WinSalInfoPrinter* 		mpInfoPrinter;			// pointer to the compatible InfoPrinter
+	WinSalPrinter* 			mpNextPrinter;			// next printing printer
 	HDC 					mhDC;					// printer hdc
 	ULONG					mnError;				// Error Code
 	ULONG					mnCopies;				// Kopien
 	BOOL					mbCollate;				// Sortierte Kopien
 	BOOL					mbAbort;				// Job Aborted
+
+public:
+    WinSalPrinter();
+    virtual ~WinSalPrinter();
+
+	virtual BOOL					StartJob( const XubString* pFileName,
+                                              const XubString& rJobName,
+                                              const XubString& rAppName,
+                                              ULONG nCopies, BOOL bCollate,
+                                              ImplJobSetup* pSetupData );
+	virtual BOOL					EndJob();
+	virtual BOOL					AbortJob();
+	virtual SalGraphics*			StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData );
+	virtual BOOL					EndPage();
+	virtual ULONG					GetErrorCode();
 };
 
 #endif // _SV_SALPRN_H
Index: vcl/win/inc/salsound.h
===================================================================
RCS file: vcl/win/inc/salsound.h
diff -N vcl/win/inc/salsound.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/inc/salsound.h	18 Nov 2003 14:49:40 -0000	1.2
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALSOUND_H
+#define _SV_SALSOUND_H
+
+#ifndef _SV_WINCOMP_HXX
+#include <wincomp.hxx>
+#endif
+
+#ifndef _GEN_HXX
+#include <tools/gen.hxx>
+#endif
+#ifndef _STRING_HXX
+#include <tools/string.hxx>
+#endif
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+
+#ifndef _SV_SALFRAME_HXX
+#include <salframe.hxx>
+#endif
+#ifndef _SV_SALSTYPE_HXX
+#include <salstype.hxx>
+#endif
+#ifndef _SV_SALSOUND_HXX
+#include <salsound.hxx>
+#endif
+
+// ------------
+// - SalSound -
+// ------------
+
+class WinSalSound : public SalSound
+{
+private:
+	static HINSTANCE	mhMCILib;
+	static ULONG		mnSoundState;
+	static void*		mpMCIFnc;
+	ULONG				mnStartTime;
+	ULONG				mnPlayLen;
+	HWND				mhSoundWnd;
+	UINT				mnDeviceId;
+	bool				mbLoop;
+	bool				mbPaused;
+
+public:
+	void				ImplSetError( DWORD nMciErr );
+	void				ImplNotify( SoundNotification eNotification, ULONG nError );
+
+public:
+    WinSalSound();
+    virtual ~WinSalSound();
+    
+    virtual bool		IsValid();
+    virtual bool		Init( const String&	rSoundName,
+                              ULONG&		rSoundLen );
+   	virtual void		Play( ULONG nStartTime, ULONG nPlayTime, bool bLoop );
+	virtual void		Stop();
+	virtual void		Pause();
+	virtual void		Continue();
+    virtual bool		IsLoopMode() const;
+	virtual bool		IsPlaying() const;
+    virtual bool		IsPaused() const;
+
+
+	bool				ImplCreate();
+	void				ImplDestroy();
+	static void 		Release();
+};
+
+#endif // _SV_SALSOUND_H
Index: vcl/win/inc/saltimer.h
===================================================================
RCS file: vcl/win/inc/saltimer.h
diff -N vcl/win/inc/saltimer.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/inc/saltimer.h	18 Nov 2003 14:49:47 -0000	1.2
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALTIMER_H
+#define _SV_SALTIMER_H
+
+#ifndef _SV_SALTIMER_HXX
+#include <saltimer.hxx>
+#endif
+
+class WinSalTimer : public SalTimer
+{
+public:
+    WinSalTimer() {}
+    virtual ~WinSalTimer();
+
+    // overload all pure virtual methods
+	void 			Start( ULONG nMS );
+	void 			Stop();
+};
+
+#endif
Index: vcl/win/inc/salvd.h
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/salvd.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/win/inc/salvd.h	18 Sep 2000 17:05:49 -0000	1.1.1.1
+++ vcl/win/inc/salvd.h	18 Nov 2003 14:50:00 -0000	1.2
@@ -66,23 +66,33 @@
 #include <sv.h>
 #endif
 
-class SalGraphics;
-class SalVirtualDevice;
+#ifndef _SV_SALVD_HXX
+#include <salvd.hxx>
+#endif
+
+class WinSalGraphics;
 
 // -----------------
 // - SalVirDevData -
 // -----------------
 
-class SalVirDevData
+class WinSalVirtualDevice : public SalVirtualDevice
 {
 public:
 	HDC 					mhDC;					// HDC or 0 for Cache Device
 	HBITMAP 				mhBmp;					// Memory Bitmap
 	HBITMAP 				mhDefBmp;				// Default Bitmap
-	SalGraphics*			mpGraphics; 			// current VirDev graphics
-	SalVirtualDevice*		mpNext; 				// next VirDev
+	WinSalGraphics*			mpGraphics; 			// current VirDev graphics
+	WinSalVirtualDevice*	mpNext; 				// next VirDev
 	USHORT					mnBitCount; 			// BitCount (0 or 1)
 	BOOL					mbGraphics; 			// is Graphics used
+
+    WinSalVirtualDevice();
+    virtual ~WinSalVirtualDevice();
+
+    virtual SalGraphics*			GetGraphics();
+    virtual void					ReleaseGraphics( SalGraphics* pGraphics );
+    virtual BOOL                    SetSize( long nNewDX, long nNewDY );
 };
 
 #endif // _SV_SALVD_H
Index: vcl/win/inc/wincomp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/inc/wincomp.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/win/inc/wincomp.hxx	18 Sep 2000 17:05:49 -0000	1.1.1.1
+++ vcl/win/inc/wincomp.hxx	6 Jan 2004 14:50:04 -0000	1.2
@@ -186,241 +186,69 @@ inline HFONT GetWindowFont( HWND hWnd )
 	return (HFONT)(UINT)SendMessage( hWnd, WM_GETFONT, 0, 0 );
 }
 
-// ---------------------
-// - Windows/Window NT -
-// ---------------------
-
-// Anpassung fuer Unterschiede zwischen 3.x und NT
-
 inline void SetClassCursor( HWND hWnd, HCURSOR hCursor )
 {
-#ifndef WNT
-	SetClassWord( hWnd, GCW_HCURSOR, (WORD)hCursor );
-#else
 	SetClassLong( hWnd, GCL_HCURSOR, (DWORD)hCursor );
-#endif
 }
 
 inline HCURSOR GetClassCursor( HWND hWnd )
 {
-#ifndef WNT
-	return (HCURSOR)GetClassWord( hWnd, GCW_HCURSOR );
-#else
 	return (HCURSOR)GetClassLong( hWnd, GCL_HCURSOR );
-#endif
 }
 
 inline void SetClassIcon( HWND hWnd, HICON hIcon )
 {
-#ifndef WNT
-	SetClassWord( hWnd, GCW_HICON, (WORD)hIcon );
-#else
 	SetClassLong( hWnd, GCL_HICON, (DWORD)hIcon );
-#endif
 }
 
 inline HICON GetClassIcon( HWND hWnd )
 {
-#ifndef WNT
-	return (HICON)GetClassWord( hWnd, GCW_HICON );
-#else
 	return (HICON)GetClassLong( hWnd, GCL_HICON );
-#endif
 }
 
 inline HBRUSH SetClassBrush( HWND hWnd, HBRUSH hBrush )
 {
-#ifndef WNT
-	return (HBRUSH)SetClassWord( hWnd, GCW_HBRBACKGROUND, (WORD)hBrush );
-#else
 	return (HBRUSH)SetClassLong( hWnd, GCL_HBRBACKGROUND, (DWORD)hBrush );
-#endif
 }
 
 inline HBRUSH GetClassBrush( HWND hWnd )
 {
-#ifndef WNT
-	return (HBRUSH)GetClassWord( hWnd, GCW_HBRBACKGROUND );
-#else
 	return (HBRUSH)GetClassLong( hWnd, GCL_HBRBACKGROUND );
-#endif
 }
 
 inline HINSTANCE GetWindowInstance( HWND hWnd )
 {
-#ifndef WNT
-	return (HINSTANCE)GetWindowWord( hWnd, GWW_HINSTANCE );
-#else
 	return (HINSTANCE)GetWindowLong( hWnd, GWL_HINSTANCE );
-#endif
-}
-
-#ifndef WNT
-inline UINT CharLowerBuff( LPSTR lpStr, UINT nLen )
-{
-	return AnsiLowerBuff( lpStr, nLen );
-}
-#endif
-
-#ifndef WNT
-inline UINT CharUpperBuff( LPSTR lpStr, UINT nLen )
-{
-	return AnsiUpperBuff( lpStr, nLen );
-}
-#endif
-
-#ifndef WNT
-inline void OemToChar( LPCSTR lpStr1, LPSTR lpStr2 )
-{
-	OemToAnsi( lpStr1, lpStr2 );
 }
-#endif
-
-
-// -----------------------------------
-// - Unterschiede zwischen 16/32-Bit -
-// -----------------------------------
-
-#ifdef WIN
-#define SVWINAPI	WINAPI
-#else
-#define SVWINAPI	APIENTRY
-#endif
-
-#ifdef WIN
-#define NEARDATA	_near
-#else
-#define NEARDATA
-#endif
-
-// Zum kopieren von mehr als 64 KB
-#ifdef WIN
-inline void lmemcpy( void* pDst, const void* pSrc, ULONG nSize )
-{
-	hmemcpy( pDst, pSrc, nSize );
-}
-#else
-inline void lmemcpy( void* pDst, const void* pSrc, ULONG nSize )
-{
-	memcpy( pDst, pSrc, nSize );
-}
-#endif
-
-#ifdef WNT
-typedef LONG	WinWeight;
-#else
-typedef int 	WinWeight;
-#endif
-
-
-// ----------------------------------------------------
-// - Steuerungen fuer Versionen und Laufzeit-Abfragen -
-// ----------------------------------------------------
-
-#if defined( WNT )
-#define W95_VERSION 		400
-#else
-#define W95_VERSION 		395
-#endif
-
-// Wenn eine 32-Bit SV Version die nur unter W95 laeuft gebildet werden soll,
-// muss nur dieses Define W40ONLY definiert werden
-#if ( WINVER >= 0x0400 )
-#define W40ONLY
-#endif
-
-// Wenn wir sowieso erst ab W95 laufen, brauchen wir auch keine
-// Laufzeit-Abfragen
-#ifdef W40ONLY
-#define W40IF
-#define W40NIF
-#define W40ELSE
-
-#else
-
-// Nur ein 32-Bit-SDK definiert WINVER >= 0x0400 und somit brauchen wir
-// diese W40-Abfragen auch nur hier. Die Abfragen, die sowohl fuer 3.1
-// als auch fuer NT gelten sind als normale if-Abfragen kodiert
-#ifdef WIN
-#define W40NIF
-#else
-#define W40IF				if ( aSalShlData.mbW40 )
-#define W40NIF				if ( !aSalShlData.mbW40 )
-#define W40ELSE 			else
-#endif
-
-#endif
-
-/****************************
-
-Beispiel fuer Klammerung:
-
-#if ( WINVER >= 0x0400 )
-	W40IF
-	{
-	... W40-Code
-	}
-	W40ELSE
-#endif
-#ifndef W40ONLY
-	{
-	... Normaler 3.1 und NT 3.5(1)-Code
-	}
-#endif
-
-*****************************/
-
 
 // ------------------------
 // - ZMouse Erweiterungen -
 // ------------------------
 
-#if defined( WNT )
-
-#ifdef UNICODE
-#define MSH_MOUSEWHEEL L"MSWHEEL_ROLLMSG"
-#else
 #define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
-#endif
 
-// Default value for rolling one notch
-#ifndef WHEEL_DELTA
-#define WHEEL_DELTA 	 120
-#endif
-
-#ifndef WM_MOUSEWHEEL
-#define WM_MOUSEWHEEL					0x020A
-#endif
-
-#ifndef  WHEEL_PAGESCROLL
-// signifies to scroll a page, also defined in winuser.h in the NT4.0 SDK
-#define WHEEL_PAGESCROLL  (UINT_MAX)
-#endif
-
-#ifdef UNICODE
-#define MOUSEZ_CLASSNAME  L"MouseZ"           // wheel window class
-#define MOUSEZ_TITLE	  L"Magellan MSWHEEL" // wheel window title
-#else
 #define MOUSEZ_CLASSNAME  "MouseZ"            // wheel window class
 #define MOUSEZ_TITLE	  "Magellan MSWHEEL"  // wheel window title
-#endif
 
 #define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
 #define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)
 
-#ifdef UNICODE
-#define MSH_SCROLL_LINES L"MSH_SCROLL_LINES_MSG"
-#else
 #define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"
-#endif
 
+#ifndef WHEEL_DELTA
+#define WHEEL_DELTA 				120
+#endif
+#ifndef WM_MOUSEWHEEL
+#define WM_MOUSEWHEEL				0x020A
+#endif
 #ifndef SPI_GETWHEELSCROLLLINES
-#define SPI_GETWHEELSCROLLLINES   104
+#define SPI_GETWHEELSCROLLLINES		104
 #endif
 #ifndef SPI_SETWHEELSCROLLLINES
-#define SPI_SETWHEELSCROLLLINES   105
+#define SPI_SETWHEELSCROLLLINES		105
 #endif
-
+#ifndef WHEEL_PAGESCROLL
+#define WHEEL_PAGESCROLL			(UINT_MAX)
 #endif
 
 
@@ -428,26 +256,46 @@ Beispiel fuer Klammerung:
 // - SystemAgent Erweiterungen -
 // -----------------------------
 
-#if ( WINVER >= 0x0400 )
 #define ENABLE_AGENT			1
 #define DISABLE_AGENT			2
 #define GET_AGENT_STATUS		3
-
-typedef int (SVWINAPI* SysAgt_Enable_PROC)( int );
-#endif
+typedef int (APIENTRY* SysAgt_Enable_PROC)( int );
 
 // ---------------------
 // - 5.0-Erweiterungen -
 // ---------------------
 
-#ifndef COLOR_HOTLIGHT
-#define COLOR_HOTLIGHT					26
-#endif
 #ifndef COLOR_GRADIENTACTIVECAPTION
 #define COLOR_GRADIENTACTIVECAPTION 	27
 #endif
 #ifndef COLOR_GRADIENTINACTIVECAPTION
 #define COLOR_GRADIENTINACTIVECAPTION	28
+#endif
+
+#ifndef SPI_GETFLATMENU
+#define SPI_GETFLATMENU     0x1022
+#endif
+#ifndef COLOR_MENUBAR
+#define COLOR_MENUBAR       30
+#endif
+#ifndef COLOR_MENUHILIGHT
+#define COLOR_MENUHILIGHT   29   
+#endif
+
+#ifndef CS_DROPSHADOW
+#define CS_DROPSHADOW       0x00020000
+#endif
+
+// -------------------------------------------------------
+// MT 12/03: From winuser.h, only needed in salframe.cxx
+// Better change salframe.cxx to include winuser.h
+// -------------------------------------------------------
+
+#define WS_EX_LAYERED           0x00080000
+
+#ifndef WM_UNICHAR
+#define WM_UNICHAR              0x0109
+#define UNICODE_NOCHAR          0xFFFF
 #endif
 
 #endif // _SV_WINCOMP_HXX
Index: vcl/win/source/app/saldata.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/saldata.cxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/win/source/app/saldata.cxx	1 Apr 2003 14:07:44 -0000	1.4
+++ vcl/win/source/app/saldata.cxx	6 Jan 2004 14:51:01 -0000	1.5
@@ -63,8 +63,6 @@
 #include <tools/svwin.h>
 #endif
 #include "rtl/tencinfo.h"
-
-#define _SV_SALDATA_CXX
 
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
Index: vcl/win/source/app/salinfo.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salinfo.cxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/win/source/app/salinfo.cxx	12 Oct 2001 16:27:12 -0000	1.3
+++ vcl/win/source/app/salinfo.cxx	6 Jan 2004 14:51:26 -0000	1.5
@@ -59,825 +59,101 @@
  *
  ************************************************************************/
 
-#if 1
-
-/* !!! UNICODE !!! */
-/* !!! This code should be change from ByteString to
-   !!! UniString, currently we doesn't support this !!! */
-
-#include <tools/string.hxx>
-#include <salsys.hxx>
-
-String GetSalSummarySystemInfos( ULONG nFlags )
-{
-    return XubString();
-}
-
-#else
-
 #define VCL_NEED_BASETSD
-
 #include <tools/presys.h>
 #include <windows.h>
-#include <imagehlp.h>
 #include <tools/postsys.h>
 
-#include <stdio.h>
 #include <tools/string.hxx>
 #include <salsys.hxx>
-
-#include <algorithm>
-
-// Wegen Stacktrace-Generierung
-#pragma optimize ("", off)
-
-// #include <tlhelp32.h>
-// ToolHelp32
-#define MAX_MODULE_NAME32 255
-#define TH32CS_SNAPMODULE   0x00000008
-
-typedef struct tagMODULEENTRY32
-{
-    DWORD   dwSize;
-    DWORD   th32ModuleID;       // This module
-    DWORD   th32ProcessID;      // owning process
-    DWORD   GlblcntUsage;       // Global usage count on the module
-    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
-    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
-    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
-    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
-    char    szModule[MAX_MODULE_NAME32 + 1];
-    char    szExePath[MAX_PATH];
-} MODULEENTRY32;
-typedef MODULEENTRY32 *  PMODULEENTRY32;
-typedef MODULEENTRY32 *  LPMODULEENTRY32;
-
-// PSAPI functions - Windows NT only
-typedef struct _MODULEINFO {
-    LPVOID lpBaseOfDll;
-    DWORD SizeOfImage;
-    LPVOID EntryPoint;
-} MODULEINFO, *LPMODULEINFO;
-
-
-
-// PSAPI
-typedef BOOL (WINAPI *ENUMPROCESSMODULESPROC)( HANDLE hProcess, HMODULE* lphModule, DWORD cb, LPDWORD lpcbNeeded );
-typedef BOOL (WINAPI *GETMODULEINFORMATIONPROC)( HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb );
-typedef DWORD (WINAPI *GETMODULEBASENAMEAPROC)( HANDLE hProcess, HMODULE hModule, LPSTR lpBaseName, DWORD nSize );
-typedef DWORD (WINAPI *GETMODULEFILENAMEEXAPROC)( HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize );
-typedef HANDLE (WINAPI *CREATESNAPSHOTPROC)(DWORD dwFlags, DWORD th32ProcessID);
-typedef BOOL (WINAPI *MODULE32FIRSTPROC)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
-typedef BOOL (WINAPI *MODULE32NEXTPROC)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
-
-
-// ImageHlp
-typedef int (__stdcall *STACKWALKPROC) ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, PVOID, PREAD_PROCESS_MEMORY_ROUTINE,PFUNCTION_TABLE_ACCESS_ROUTINE, PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );
-typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, DWORD );
-typedef DWORD (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, DWORD );
-typedef DWORD (__stdcall *SYMSETOPTIONSPROC ) (DWORD dwSymOptions);
-typedef int (__stdcall *SYMINITIALIZEPROC ) ( HANDLE, LPSTR, int );
-typedef int (__stdcall *SYMCLEANUPPROC)( HANDLE );
-typedef DWORD (__stdcall WINAPI *UNDECORATESYMBOLNAMEPROC)( PCSTR, PSTR, DWORD, DWORD );
-typedef DWORD (__stdcall *SYMLOADMODULEPROC) ( HANDLE, HANDLE, LPSTR, LPSTR, DWORD, DWORD );
-typedef int (__stdcall *SYMGETSYMFROMADDR)( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
-
-
-struct ModuleInfo
-{
-    struct ModuleInfo*          pNext;
-
-    char                        szModBaseName[MAX_PATH];
-    char                        szModFileName[MAX_PATH];
-    unsigned long               nBaseAddress;
-    unsigned long               nSize;
-//  unsigned long               nEntryPoint;
-//  HANDLE                      nHandle;
-//  PIMAGE_DEBUG_INFORMATION    pDebugInfos;
-};
-
-struct ModuleInfo* FindModuleContainingAddress( struct ModuleInfo* pStart, void* pAddr );
-
-
-
-struct SystemInfos
-{
-    DWORD   nCurrentProcessId;
-    HANDLE  hCurrentProcess;
-    DWORD   nCurrentThreadId;
-    HANDLE  hCurrentThread;
-
-    ModuleInfo* pModInfos;
-
-    String  aStack;
-    String  aModules;
-    String  aSystemVersion;
-    String  aCPUType;
-    String  aMemoryInfo;
-    String  aLocalVolumes;
-    String  aSystemDirs;
-    String  aMouseInfo;
-
-    SystemInfos()
-    {
-        nCurrentProcessId = 0;
-        hCurrentProcess = 0;
-        hCurrentThread = 0;
-        pModInfos = NULL;
-    }
+#include <salframe.h>
+#include <salinst.h>
+#include <tools/debug.hxx>
+#include <svdata.hxx>
+#include <window.hxx>
+
+class WinSalSystem : public SalSystem
+{
+public:
+    WinSalSystem() {}
+    virtual ~WinSalSystem();
+
+    virtual bool GetSalSystemDisplayInfo( DisplayInfo& rInfo );
+    virtual int ShowNativeMessageBox( const String& rTitle,
+                                      const String& rMessage,
+                                      int nButtonCombination,
+                                      int nDefaultButton);
 };
 
-void DebugThread( SystemInfos* pSysInfos );
-
-
-typedef struct _Thread
-{
-    DWORD dwThreadId;
-    HANDLE hThread;
-} Thread;
-
-
-struct ModuleInfo*  WNT_CreateModuleInfos();
-
-String ImplCreateToken( const String& rToken )
-{
-    String aToken( '<' );
-    aToken += rToken;
-    aToken += ' ';
-    while ( aToken.Len() < 25 )
-        aToken += '-';
-    aToken += '>';
-    return aToken;
-}
-
-
-
-String WNT_CreateModulePath( struct ModuleInfo* pModInfos )
+SalSystem* WinSalInstance::CreateSalSystem()
 {
-    String aPath;
-    struct ModuleInfo* pM = pModInfos;
-    while ( pM )
-    {
-        String aTmpPath = pM->szModFileName;
-        USHORT n = aTmpPath.SearchBackward( '\\' );
-        if ( n != STRING_NOTFOUND )
-            aTmpPath.Erase( n );
-        aTmpPath += ';';
-        aTmpPath.ToLower();
-        if ( aPath.Search( aTmpPath ) == STRING_NOTFOUND  )
-            aPath += aTmpPath;
-
-        pM = pM->pNext;
-    }
-    return aPath;
-}
-
-
-struct ModuleInfo*  WNT_CreateModuleInfos()
-{
-    struct ModuleInfo* pModInfos = NULL;
-
-    OSVERSIONINFO aOSVersion;
-    aOSVersion.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
-    if ( GetVersionEx( &aOSVersion ) )
-    {
-        if ( aOSVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
-        {
-            HINSTANCE hPSAPILib = LoadLibrary( "PSAPI.DLL" );
-            if( hPSAPILib )
-            {
-                ENUMPROCESSMODULESPROC _fpEnumProcessModules = (ENUMPROCESSMODULESPROC) GetProcAddress( hPSAPILib, "EnumProcessModules" );
-                GETMODULEINFORMATIONPROC _fpGetModuleInformation = (GETMODULEINFORMATIONPROC) GetProcAddress( hPSAPILib, "GetModuleInformation" );
-                GETMODULEBASENAMEAPROC _fpGetModuleBaseNameA = (GETMODULEBASENAMEAPROC) GetProcAddress( hPSAPILib, "GetModuleBaseNameA" );
-                GETMODULEFILENAMEEXAPROC _fpGetModuleFileNameExA = (GETMODULEFILENAMEEXAPROC) GetProcAddress( hPSAPILib, "GetModuleFileNameExA" );
-
-                HANDLE hProcess = GetCurrentProcess();
-                HMODULE hMods[1024];
-                DWORD cbNeeded;
-                if( _fpEnumProcessModules( hProcess, hMods, sizeof(hMods), &cbNeeded ) )
-                {
-                    int nMods = cbNeeded / sizeof( HMODULE );
-                    int nArrSz = nMods * sizeof( struct ModuleInfo );
-                    pModInfos = (struct ModuleInfo*) malloc( nArrSz );
-                    memset( pModInfos, 0, nArrSz );
-
-                    for ( int i = 0; i < nMods; i++ )
-                    {
-                        pModInfos[i].pNext = 0;
-                        if ( i )
-                            pModInfos[i-1].pNext = &pModInfos[i];
-
-                        _fpGetModuleBaseNameA( hProcess, hMods[i], pModInfos[i].szModBaseName, sizeof( pModInfos[i].szModBaseName ) );
-                        _fpGetModuleFileNameExA( hProcess, hMods[i], pModInfos[i].szModFileName, sizeof( pModInfos[i].szModFileName ) );
-
-                        MODULEINFO aInf;
-                        if ( _fpGetModuleInformation( hProcess, hMods[i], &aInf, sizeof( aInf ) ) )
-                        {
-                            pModInfos[i].nBaseAddress = (unsigned long) aInf.lpBaseOfDll;
-                            pModInfos[i].nSize = aInf.SizeOfImage;
-        //                  pModInfos[i].nEntryPoint = (unsigned long) aInf.EntryPoint;
-                        }
-                    }
-                }
-                FreeLibrary( hPSAPILib );
-            }
-        }
-        else if ( aOSVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
-        {
-            HINSTANCE hToolHelpLib = LoadLibrary( "KERNEL32.DLL" );
-            if( hToolHelpLib )
-            {
-                CREATESNAPSHOTPROC _fpCreateSnapshot = (CREATESNAPSHOTPROC) GetProcAddress( hToolHelpLib, "CreateToolhelp32Snapshot" );
-                MODULE32FIRSTPROC _fpModule32First = (MODULE32FIRSTPROC) GetProcAddress( hToolHelpLib, "Module32First" );
-                MODULE32NEXTPROC _fpModule32Next = (MODULE32NEXTPROC) GetProcAddress( hToolHelpLib, "Module32Next" );
-
-                HANDLE hSnap = _fpCreateSnapshot( TH32CS_SNAPMODULE, 0 );
-                if ( hSnap )
-                {
-                    MODULEENTRY32 aMod32Entry;
-                    ZeroMemory( &aMod32Entry, sizeof( MODULEENTRY32 ) );
-                    aMod32Entry.dwSize = sizeof( MODULEENTRY32 );
-                    int nMods = 0;
-                    BOOL bMod = _fpModule32First( hSnap, &aMod32Entry );
-                    while ( bMod )
-                    {
-                        nMods++;
-                        bMod = _fpModule32Next( hSnap, &aMod32Entry );
-                    }
-
-                    int nArrSz = nMods * sizeof( struct ModuleInfo );
-                    pModInfos = (struct ModuleInfo*) malloc( nArrSz );
-                    memset( pModInfos, 0, nArrSz );
-
-                    int nMod = 0;
-                    bMod = _fpModule32First( hSnap, &aMod32Entry );
-                    while ( bMod )
-                    {
-                        pModInfos[nMod].pNext = 0;
-                        if ( nMod )
-                            pModInfos[nMod-1].pNext = &pModInfos[nMod];
-
-                        strcpy( pModInfos[nMod].szModBaseName, aMod32Entry.szModule );
-                        strcpy( pModInfos[nMod].szModFileName, aMod32Entry.szExePath );
-                        pModInfos[nMod].nBaseAddress = (unsigned long) aMod32Entry.modBaseAddr;
-                        pModInfos[nMod].nSize = aMod32Entry.modBaseSize;
-//                      pModInfos[nMod].nEntryPoint = 0xFFFFFFFF;
-
-                        bMod = _fpModule32Next( hSnap, &aMod32Entry );
-                        nMod++;
-                    }
-
-                    CloseHandle( hSnap );
-                }
-
-                FreeLibrary( hToolHelpLib );
-            }
-        }
-    }
-    return pModInfos;
+    return new WinSalSystem();
 }
 
-BOOL WNT_GetLogicalAddress( PVOID addr, PTSTR szModule, DWORD len, DWORD& section, DWORD& offset )
+WinSalSystem::~WinSalSystem()
 {
-    MEMORY_BASIC_INFORMATION mbi;
-
-    if( VirtualQuery( addr, &mbi, sizeof(mbi) ) && mbi.AllocationBase )
-    {
-        DWORD hMod = (DWORD)mbi.AllocationBase;
-
-        if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
-            return FALSE;
-
-        // Point to the DOS header in memory
-        PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)hMod;
-
-        // From the DOS header, find the NT (PE) header
-        PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
-
-        PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION( pNtHdr );
-
-        DWORD rva = (DWORD)addr - hMod; // RVA is offset from module load address
-
-        // Iterate through the section table, looking for the one that encompasses
-        // the linear address.
-        for (   unsigned i = 0;
-                i < pNtHdr->FileHeader.NumberOfSections;
-                i++, pSection++ )
-        {
-            DWORD sectionStart = pSection->VirtualAddress;
-            DWORD sectionEnd = sectionStart
-                        + std::max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);
-
-            // Is the address in this section???
-            if ( (rva >= sectionStart) && (rva <= sectionEnd) )
-            {
-                // Yes, address is in the section.  Calculate section and offset,
-                // and store in the "section" & "offset" params, which were
-                // passed by reference.
-                section = i+1;
-                offset = rva - sectionStart;
-                return TRUE;
-            }
-        }
-    }
-    return FALSE;
 }
 
+// -----------------------------------------------------------------------
 
-struct ModuleInfo* FindModuleContainingAddress( struct ModuleInfo* pStart, void* pAddr )
+bool WinSalSystem::GetSalSystemDisplayInfo( DisplayInfo& rInfo )
 {
-    struct ModuleInfo* pRet = NULL;
-    struct ModuleInfo* pM = pStart;
-    unsigned long nAddr = (unsigned long) pAddr;
+    RECT aRect;
+    ImplSalGetWorkArea( NULL, &aRect, NULL );
 
-    while ( pM && !pRet )
+    HDC hDC;
+    if( hDC = GetDC( NULL ) )
     {
-        if ( ( nAddr >= pM->nBaseAddress ) &&
-             ( nAddr < ( pM->nBaseAddress + pM->nSize ) ) )
-        {
-            pRet = pM;
-        }
-        else
-        {
-            pM = pM->pNext;
-        }
-    }
-    return pRet;
-}
-
-String _OLD_GetStackInfo()
-{
-    // Try an other way...
-    String aTmpStack;
-    ModuleInfo* pMods = WNT_CreateModuleInfos();
-
-    ULONG* pBP;
-    __asm mov pBP, ebp;
-    char buffer[1024];
-
-    for ( int i = 0; i < 15; i++ )
-    {
-        ULONG nIP = pBP[1];
-        sprintf( buffer, "[%.2u] IP=%.8lx", i, nIP );
-        aTmpStack += buffer;
-
-        ModuleInfo* pI = FindModuleContainingAddress( pMods, (void*)nIP );
-        if ( pI )
-        {
-            sprintf( buffer, " (Rel=%.8lx) [%s, Base=%.8lx, Path=%s]", nIP-pI->nBaseAddress-0x1000, pI->szModBaseName, pI->nBaseAddress, pI->szModFileName );
-            aTmpStack += buffer;
-        }
-
-        if ( !pI || (pBP[0] & 3) || (ULONG)pBP > pBP[0] )
-        {
-            aTmpStack += "\nError!\n";
-            break;
-        }
-
-        aTmpStack += '\n';
-        pBP = (ULONG*) pBP[0];
+        rInfo.nWidth    = aRect.right - aRect.left;
+        rInfo.nHeight   = aRect.bottom - aRect.top;
+        rInfo.nDepth    = GetDeviceCaps( hDC, BITSPIXEL );
+        ReleaseDC( NULL, hDC );
+        return true;
     }
-
-    // Modul-Infos zerstoeren...
-    return aTmpStack;
+    else
+        return false;
 }
 
-String GetSalSummarySystemInfos( ULONG nFlags )
+// -----------------------------------------------------------------------
+/* We have to map the button identifier to the identifier used by the Win32
+   Platform SDK to specify the default button for the MessageBox API.
+   The first dimension is the button combination, the second dimension
+   is the button identifier.
+*/
+static int DEFAULT_BTN_MAPPING_TABLE[][8] =
 {
-    SystemInfos aSysInfos;
-    HANDLE nCurrentThreadPseudo = GetCurrentThread();
-    HANDLE nCurrentProcessPseudo = GetCurrentProcess();
-    aSysInfos.nCurrentThreadId = GetCurrentThreadId();
-    DuplicateHandle( nCurrentProcessPseudo, nCurrentThreadPseudo, nCurrentProcessPseudo,
-                        &aSysInfos.hCurrentThread, PROCESS_ALL_ACCESS, TRUE, 0 );
-    aSysInfos.nCurrentProcessId = GetCurrentProcessId();
-    DuplicateHandle( nCurrentProcessPseudo, nCurrentProcessPseudo, nCurrentProcessPseudo,
-                        &aSysInfos.hCurrentProcess, PROCESS_ALL_ACCESS, TRUE, 0 );
-
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_STACK )
-    {
-        DWORD nDebugThreadId;
-        HANDLE hDebugThread = CreateThread(
-                                NULL, 16000,
-                                (LPTHREAD_START_ROUTINE)DebugThread, &aSysInfos,
-                                0, &nDebugThreadId );
-
-        WaitForSingleObject( hDebugThread, INFINITE );
-        CloseHandle( hDebugThread );
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_MODULES )
-    {
-        aSysInfos.aModules = "<Modules>\n";
-        char buffer[1024];
-        if ( !aSysInfos.pModInfos )
-            aSysInfos.pModInfos = WNT_CreateModuleInfos();
-        struct ModuleInfo* pM = aSysInfos.pModInfos;
-        while ( pM )
-        {
-            aSysInfos.aModules += "  <Module name=\"";
-            aSysInfos.aModules += pM->szModBaseName;
-            aSysInfos.aModules += "\" path=\"";
-            aSysInfos.aModules += pM->szModFileName;
-            aSysInfos.aModules += "\" >\n";
-            aSysInfos.aModules += "    <ModuleInfo name=\"BASE\" value=\"";
-            sprintf( buffer, "%.8lx", pM->nBaseAddress );
-            aSysInfos.aModules += buffer;
-            aSysInfos.aModules += "\" />\n";
-            aSysInfos.aModules += "    <ModuleInfo name=\"Size\" value=\"";
-            aSysInfos.aModules += pM->nSize;
-            aSysInfos.aModules += "\" />\n  </Module>\n";
-            pM = pM->pNext;
-        }
-        aSysInfos.aModules += "</Modules>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_SYSTEMVERSION )
-    {
-        aSysInfos.aSystemVersion = "<System name=\"";
-        OSVERSIONINFO aVersionInfos;
-        memset(&aVersionInfos, 0, sizeof( OSVERSIONINFO ) );
-        aVersionInfos.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
-        GetVersionEx( &aVersionInfos );
-        if ( aVersionInfos.dwPlatformId == VER_PLATFORM_WIN32s )
-            aSysInfos.aSystemVersion += "Microsoft Win32s";
-        else if ( aVersionInfos.dwPlatformId == VER_PLATFORM_WIN32_NT )
-            aSysInfos.aSystemVersion += "Microsoft Windows NT";
-        else if ( aVersionInfos.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
-        {
-            if ( !aVersionInfos.dwMinorVersion )
-                aSysInfos.aSystemVersion += "Microsoft Windows 95";
-            else
-                aSysInfos.aSystemVersion += "Microsoft Windows 98";
-        }
-        else
-            aSysInfos.aSystemVersion += "Unknown Windows";
-        aSysInfos.aSystemVersion += "\" version=\"";
-        aSysInfos.aSystemVersion += aVersionInfos.dwMajorVersion;
-        aSysInfos.aSystemVersion += '.';
-        aSysInfos.aSystemVersion += aVersionInfos.dwMinorVersion;
-        aSysInfos.aSystemVersion += "\" build=\"";
-        aSysInfos.aSystemVersion += aVersionInfos.dwBuildNumber&0xFFFF;
-        aSysInfos.aSystemVersion += "\" />";
-
-        // aSysInfos.aSystemVersion += aVersionInfos.szCSDVersion;
-        /*
-            Under both Windows NT and Windows 95, you can get the
-            language information in the FileVersionInfo of User.exe by
-            calling GetFileVersionInfo, and then
-            VerQueryValue (on \\VarFileInfo\\Translation") on the
-            VersionInfo block of the operating system's User.exe.
-            NOTE: This method is the most reliable. It works well under
-            both Windows NT and Windows 95. This method also works for
-            Windows 3.1
-        */
-//      DWORD nDefInputLanguage;
-//      if ( SystemParametersInfo( SPI_GETDEFAULTINPUTLANG, 0, &nDefInputLanguage, 0 ) )
-//      {
-//          aSysInfos.aSystemVersion += " default input language = ";
-//          aSysInfos.aSystemVersion += nDefInputLanguage;
-//      }
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_CPUTYPE )
-    {
-        SYSTEM_INFO aSystemInfo;
-        memset( &aSystemInfo, 0, sizeof( SYSTEM_INFO ) );
-        GetSystemInfo( &aSystemInfo );
-        aSysInfos.aCPUType = "<CPU count=\"";
-        aSysInfos.aCPUType += aSystemInfo.dwNumberOfProcessors;
-        aSysInfos.aCPUType += "\" type=\"";
-        if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "X86";
-        else if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "MIPS";
-        else if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "ALPHA";
-        else if ( aSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
-            aSysInfos.aCPUType += "PPC";
-        else
-            aSysInfos.aCPUType += "unknown";
-        aSysInfos.aCPUType += "\"></CPU>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_MEMORYINFO )
-    {
-        MEMORYSTATUS aMemStatus;
-        memset( &aMemStatus, 0, sizeof( MEMORYSTATUS ) );
-        GlobalMemoryStatus( &aMemStatus );
-        aSysInfos.aMemoryInfo = "<Memory>\n";
-        aSysInfos.aMemoryInfo += "  <MemoryType name=\"Physical\" total=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwTotalPhys+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" free=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwAvailPhys+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" />\n";
-        aSysInfos.aMemoryInfo += "  <MemoryType name=\"Swap\" total=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwTotalPageFile+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" free=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwAvailPageFile+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" />\n";
-        aSysInfos.aMemoryInfo += "  <MemoryType name=\"Virtual\" total=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwTotalVirtual+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" free=\"";
-        aSysInfos.aMemoryInfo += (aMemStatus.dwAvailVirtual+512)/1024/1024+1;
-        aSysInfos.aMemoryInfo += " MB\" />\n";
-        aSysInfos.aMemoryInfo += "</Memory>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_LOCALVOLUMES )
-    {
-        aSysInfos.aLocalVolumes = "<LocalVolumes>\n";
-        char aDriveStrings[4096];
-        GetLogicalDriveStrings( 4096, aDriveStrings );
-        LPTSTR pDriveStr = aDriveStrings;
-        while ( *pDriveStr )
-        {
-            UINT nType = GetDriveType( pDriveStr );
-            if ( nType != DRIVE_REMOTE )
-            {
-                aSysInfos.aLocalVolumes += "  <LocalVolume type=\"";
-
-                switch ( nType )
-                {
-                    case DRIVE_REMOVABLE:   aSysInfos.aLocalVolumes += "Removable"; break;
-                    case DRIVE_FIXED:       aSysInfos.aLocalVolumes += "Fixed"; break;
-                    case DRIVE_REMOTE:      aSysInfos.aLocalVolumes += "Remote";    break;
-                    case DRIVE_CDROM:       aSysInfos.aLocalVolumes += "CD-ROM";    break;
-                    case DRIVE_RAMDISK:     aSysInfos.aLocalVolumes += "RAM disk";  break;
-                    default:                aSysInfos.aLocalVolumes += "Unkown";
-                }
-                aSysInfos.aLocalVolumes += "\" path=\"";
-                aSysInfos.aLocalVolumes += pDriveStr;
-                aSysInfos.aLocalVolumes += "\"";
-                if( nType == DRIVE_FIXED )
-                {
-                    DWORD nSectorsPerCluster;
-                    DWORD nBytesPerSector;
-                    DWORD nNumberFreeClusters;
-                    DWORD nNumberTotalClusters;
-                    if( GetDiskFreeSpace( pDriveStr, &nSectorsPerCluster, &nBytesPerSector, &nNumberFreeClusters, &nNumberTotalClusters ) )
-                    {
-                        DWORD nUnitsPerCluster = nSectorsPerCluster*nBytesPerSector;
-                        DWORD nUnitDivi = 1;
-                        String aUnit = "bytes";
-                        if( ( nUnitsPerCluster % 1024 ) == 0 )
-                        {
-                            aUnit = "KB";
-                            nUnitsPerCluster /= 1024;
-                        }
-                        else if( ( nUnitsPerCluster % 512 ) == 0 )
-                        {
-                            aUnit = "KB";
-                            nUnitDivi = 1024;
-                        }
-                        DWORD nFree = nNumberFreeClusters*nUnitsPerCluster/nUnitDivi;
-                        aSysInfos.aLocalVolumes += " free=\"";
-                        aSysInfos.aLocalVolumes += nFree;
-                        aSysInfos.aLocalVolumes += ' ';
-                        aSysInfos.aLocalVolumes += aUnit;
-                        aSysInfos.aLocalVolumes += "\"";
-                    }
-                }
-                aSysInfos.aLocalVolumes += " />\n";
-            }
-            while ( *pDriveStr )
-                pDriveStr++;
-            pDriveStr++;
-        }
-        aSysInfos.aLocalVolumes += "</LocalVolumes>";
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_SYSTEMDIRS )
-    {
-        aSysInfos.aSystemDirs = "<SystemDirs>\n";
-        char buffer[ MAX_PATH ];
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"Windows\" path=\"";
-        if( GetWindowsDirectory( buffer, MAX_PATH ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"System\" path=\"";
-        if( GetSystemDirectory( buffer, MAX_PATH ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"Current\" path=\"";
-        if( GetCurrentDirectory( MAX_PATH, buffer ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-
-        aSysInfos.aSystemDirs += "  <SystemDir envname=\"Temp\" path=\"";
-        if( GetTempPath( MAX_PATH, buffer ) )
-            aSysInfos.aSystemDirs += buffer;
-        aSysInfos.aSystemDirs += "\" />\n";
-        aSysInfos.aSystemDirs += "</SystemDirs>";
-
-    }
-    if ( nFlags & SALSYSTEM_GETSYSTEMINFO_MOUSEINFO )
-    {
-        aSysInfos.aMouseInfo = "<Mouse ";
-        int nRet = GetSystemMetrics( SM_CMOUSEBUTTONS );
-        if ( nRet )
-        {
-            aSysInfos.aMouseInfo += "buttons=\"";
-            aSysInfos.aMouseInfo += nRet;
-            aSysInfos.aMouseInfo += "\" description=\"";
-            if( GetSystemMetrics( 75 /*SM_MOUSEWHEELPRESENT - missing in SDK from MSVC4.2 */ ) )
-                aSysInfos.aMouseInfo += "wheel mouse";
-            else
-                aSysInfos.aMouseInfo += "standard mouse";
-            aSysInfos.aMouseInfo += "\"";
-        }
-        else
-        {
-            aSysInfos.aMouseInfo += "description=\"Not installed.\"";
-        }
-        aSysInfos.aMouseInfo += " />";
-    }
-
-    CloseHandle( aSysInfos.hCurrentThread );
-    CloseHandle( aSysInfos.hCurrentProcess );
-
-    String aInfos;
-
-    aInfos += aSysInfos.aSystemVersion;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aCPUType;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aMouseInfo;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aMemoryInfo;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aStack;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aModules;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aLocalVolumes;
-    aInfos += "\n\n";
-
-    aInfos += aSysInfos.aSystemDirs;
-    aInfos += "\n\n";
-
-    return aInfos;
-}
-
-
-
+    //  Undefined        OK             CANCEL         ABORT          RETRY          IGNORE         YES             NO
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //OK
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //OK_CANCEL
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //ABORT_RETRY_IGNO
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON3, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2 }, //YES_NO_CANCEL
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2 }, //YES_NO
+    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }  //RETRY_CANCEL
+};
 
-void DebugThread( SystemInfos* pSysInfos )
+int WinSalSystem::ShowNativeMessageBox(const String& rTitle, const String& rMessage, int nButtonCombination, int nDefaultButton)
 {
-    HINSTANCE hImageHelpLib = LoadLibrary( "IMAGEHLP.DLL" );
-    if( hImageHelpLib )
-    {
-        if ( SuspendThread( pSysInfos->hCurrentThread ) != 0xFFFFFFFF )
-        {
-            STACKFRAME aStackFrame;
-            memset( &aStackFrame, 0, sizeof( aStackFrame ) );
-
-            CONTEXT aContext;
-            memset( &aContext, 0, sizeof( aContext ) );
-            aContext.ContextFlags = CONTEXT_FULL;
-            if ( GetThreadContext( pSysInfos->hCurrentThread, &aContext ) )
-            {
-                STACKWALKPROC _fpStackWalk = (STACKWALKPROC) GetProcAddress( hImageHelpLib, "StackWalk" );
-                SYMFUNCTIONTABLEACCESSPROC _fpSymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC) GetProcAddress( hImageHelpLib, "SymFunctionTableAccess" );
-                SYMGETMODULEBASEPROC _fpSymGetModuleBase = (SYMGETMODULEBASEPROC) GetProcAddress( hImageHelpLib, "SymGetModuleBase" );
-                SYMSETOPTIONSPROC _fpSymSetOptionsProc = (SYMSETOPTIONSPROC) GetProcAddress( hImageHelpLib, "SymGetOptions" );
-                SYMINITIALIZEPROC _fpSymInitializeProc = (SYMINITIALIZEPROC) GetProcAddress( hImageHelpLib, "SymInitialize" );
-                SYMCLEANUPPROC _fpSymCleanup = (SYMCLEANUPPROC) GetProcAddress( hImageHelpLib, "SymCleanup" );
-                UNDECORATESYMBOLNAMEPROC _fpUndecorateSymbolName = (UNDECORATESYMBOLNAMEPROC) GetProcAddress( hImageHelpLib, "UnDecorateSymbolName" );
-                SYMLOADMODULEPROC _fpSymLoadModule = ( SYMLOADMODULEPROC) GetProcAddress( hImageHelpLib, "SymLoadModule" );
-                SYMGETSYMFROMADDR _fpSymGetSymFromAddr = ( SYMGETSYMFROMADDR ) GetProcAddress( hImageHelpLib, "SymGetSymFromAddr" );
-
-                if ( !pSysInfos->pModInfos )
-                    pSysInfos->pModInfos = WNT_CreateModuleInfos();
-
-                _fpSymSetOptionsProc( SYMOPT_DEFERRED_LOADS );
-
-                char buffer[1024];
-
-                // Initialize the imagehlp symbol handler
-                BOOL bAutoLoad = FALSE;
-//              String aPath = WNT_CreateModulePath( pSysInfos->pModInfos );
-//              USHORT nLen = aPath.Len();
-//              memcpy( buffer, aPath.GetStr(), nLen );
-//              buffer[nLen] = 0;
-//              BOOL bSymbols = _fpSymInitializeProc( pSysInfos->hCurrentProcess, NULL, bAutoLoad );
-                // Path funktioniert nicht, also lade ich unten alle von Hand!
-                BOOL bSymbols = _fpSymInitializeProc( pSysInfos->hCurrentProcess, NULL, bAutoLoad );
-
-                // Load symbol modules for the current process
-                if ( bSymbols && !bAutoLoad )
-                {
-                    // LoadModuleSymbols( pSysInfos->nCurrentProcessId, pSysInfos->hCurrentProcess );
-                    struct ModuleInfo* pM = pSysInfos->pModInfos;
-                    char buffer1[1024];
-                    char buffer2[1024];
-
-                    while ( pM )
-                    {
-                        strcpy( buffer1, pM->szModFileName );
-                        strcpy( buffer2, pM->szModBaseName );
-
-                        BOOL bDone = _fpSymLoadModule( pSysInfos->hCurrentProcess, 0, buffer1, buffer2, pM->nBaseAddress, pM->nSize );
-
-                        pM = pM->pNext;
-                    }
-                }
-
-                // Initialize the STACKFRAME structure for the first call.  This is only
-                // necessary for Intel CPUs, and isn't mentioned in the documentation.
-                aStackFrame.AddrPC.Offset       = aContext.Eip;
-                aStackFrame.AddrPC.Mode         = AddrModeFlat;
-                aStackFrame.AddrStack.Offset    = aContext.Esp;
-                aStackFrame.AddrStack.Mode      = AddrModeFlat;
-                aStackFrame.AddrFrame.Offset    = aContext.Ebp;
-                aStackFrame.AddrFrame.Mode      = AddrModeFlat;
-
-
-                pSysInfos->aStack = "<Stack type=\"WIN32\" >\n";
-
-                for ( int nS = 0; nS < 20; nS++ )
-                {
-                    SetLastError( 0 );
-                    BOOL bStack = _fpStackWalk( IMAGE_FILE_MACHINE_I386,
-                                                pSysInfos->hCurrentProcess,
-                                                pSysInfos->hCurrentThread,
-                                                &aStackFrame,
-                                                &aContext,
-                                                NULL, // ReadProcessMemory,
-                                                _fpSymFunctionTableAccess,
-                                                _fpSymGetModuleBase,
-                                                NULL );
-
-                    if ( !bStack || !aStackFrame.AddrReturn.Offset || !aStackFrame.AddrFrame.Offset )
-                        break;
-
-                    pSysInfos->aStack += "  <StackInfo pos=\"";
-                    pSysInfos->aStack += (USHORT)nS;
-                    pSysInfos->aStack += "\" ip=\"";
-                    ULONG nIP = aStackFrame.AddrReturn.Offset;
-                    sprintf( buffer, "%.8lx", nIP );
-                    pSysInfos->aStack += buffer;
-                    pSysInfos->aStack += "\"";
-
-                    TCHAR aModuleFileName[MAX_PATH];
-                    DWORD section, offset;
-                    if ( WNT_GetLogicalAddress( (void*)nIP, aModuleFileName, MAX_PATH, section, offset ) )
-                    {
-                        pSysInfos->aStack += " rel=\"";
-                        sprintf( buffer, "%.8lx", offset );
-                        pSysInfos->aStack += buffer;
-                        pSysInfos->aStack += "\" file=\"";
-                        char* pModName = strrchr( aModuleFileName, '\\' );
-                        pSysInfos->aStack += pModName ? (pModName+1) : aModuleFileName;
-                        pSysInfos->aStack += "\"";
-                    }
-                    else
-                    {
-                        pSysInfos->aStack += " rel=\"ERROR\"";
-                        break;
-                    }
-
-                    if ( bSymbols )
-                    {
-
-                        BYTE symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
-                        PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
-                        memset( symbolBuffer, 0, sizeof(symbolBuffer) );
-                        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
-                        pSymbol->MaxNameLength = sizeof(symbolBuffer) - sizeof(IMAGEHLP_SYMBOL) + 1;
-
-                        DWORD symDisplacement = 0;  // Displacement of the input address,
-                                                    // relative to the start of the symbol
-
-                        if ( _fpSymGetSymFromAddr( pSysInfos->hCurrentProcess, aStackFrame.AddrReturn.Offset,
-                                                &symDisplacement, pSymbol ) )
-                        {
-                            pSysInfos->aStack += " ordinal=\"";
-                            _fpUndecorateSymbolName( pSymbol->Name, buffer, 1024, UNDNAME_NAME_ONLY );
-                            pSysInfos->aStack += buffer;
-                            pSysInfos->aStack += "\"";
-                            // aStackLine += '<';
-                            // _fpUndecorateSymbolName( pSymbol->Name, buffer, 1024, UNDNAME_COMPLETE );
-                            // aStackLine += buffer;
-                            // aStackLine += '>';
-                        }
-                        else    // No symbol found.  Print out the logical address instead.
-                        {
-                            pSysInfos->aStack += " ordinal=\"???\"";
-                        }
-                    }
-
-                    pSysInfos->aStack += " />\n";
-                }
-                pSysInfos->aStack += "</Stack>";
-                _fpSymCleanup( pSysInfos->hCurrentProcess );
-            }
-            ResumeThread( pSysInfos->hCurrentThread );
-        }
-        FreeLibrary( hImageHelpLib );
-    }
+    DBG_ASSERT( nButtonCombination >= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK &&
+                nButtonCombination <= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL &&
+                nDefaultButton >= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK &&
+                nDefaultButton <= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO, "Invalid arguments!" );
+
+    int nFlags = MB_TASKMODAL | MB_SETFOREGROUND | MB_ICONWARNING | nButtonCombination;
+
+    if (nButtonCombination >= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK &&
+        nButtonCombination <= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL &&
+        nDefaultButton >= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK &&
+        nDefaultButton <= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO)
+        nFlags |= DEFAULT_BTN_MAPPING_TABLE[nButtonCombination][nDefaultButton];
+
+    //#107209 hide the splash screen if active
+    ImplSVData* pSVData = ImplGetSVData();
+    if (pSVData->mpIntroWindow)
+        pSVData->mpIntroWindow->Hide();
+
+    return MessageBoxW(
+        0,
+        rMessage.GetBuffer(),
+        rTitle.GetBuffer(),
+        nFlags);
 }
-
-#endif
Index: vcl/win/source/app/salinst.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salinst.cxx,v
retrieving revision 1.14.82.2
retrieving revision 1.21
diff -u -p -u -r1.14.82.2 -r1.21
--- vcl/win/source/app/salinst.cxx	3 Mar 2004 10:10:48 -0000	1.14.82.2
+++ vcl/win/source/app/salinst.cxx	18 May 2004 13:47:58 -0000	1.21
@@ -65,8 +65,6 @@
 #include <process.h>
 #endif
 
-#define _SV_SALINST_CXX
-
 #ifndef _VOS_MUTEX_HXX
 #include <vos/mutex.hxx>
 #endif
@@ -84,23 +82,23 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
-#ifndef _SV_SALOBJ_HXX
-#include <salobj.hxx>
+#ifndef _SV_SALOBJ_H
+#include <salobj.h>
 #endif
 #ifndef _SV_SALSYS_HXX
 #include <salsys.hxx>
 #endif
-#ifndef _SV_SALTIMER_HXX
-#include <saltimer.hxx>
+#ifndef _SV_SALTIMER_H
+#include <saltimer.h>
 #endif
-#ifndef _SV_SALSOUND_HXX
-#include <salsound.hxx>
+#ifndef _SV_SALSOUND_H
+#include <salsound.h>
 #endif
 #ifndef _SV_SALATYPE_HXX
 #include <salatype.hxx>
@@ -108,13 +106,22 @@
 #ifndef _SV_SYSDATA_HXX
 #include <sysdata.hxx>
 #endif
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
+#endif
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
+#endif
+#ifndef _SV_SALIMESTATUS_HXX
+#include <salimestatus.hxx>
+#endif
 
 #ifndef _SV_TIMER_HXX
 #include <timer.hxx>
 #endif
 
-#ifndef CS_DROPSHADOW
-#define CS_DROPSHADOW       0x00020000
+#ifndef _SV_WINCOMP_HXX
+#include <wincomp.hxx>	// CS_DROPSHADOW
 #endif
 
 // =======================================================================
@@ -148,12 +155,12 @@ LRESULT CALLBACK SalComWndProcW( HWND hW
 class SalYieldMutex : public vos::OMutex
 {
 public: // for ImplSalYield()
-    SalInstanceData*            mpInstData;
+    WinSalInstance*             mpInstData;
     ULONG                       mnCount;
     DWORD                       mnThreadId;
 
 public:
-                                SalYieldMutex( SalInstanceData* pInstData );
+                                SalYieldMutex( WinSalInstance* pInstData );
 
     virtual void SAL_CALL       acquire();
     virtual void SAL_CALL       release();
@@ -164,7 +171,7 @@ public:
 
 // -----------------------------------------------------------------------
 
-SalYieldMutex::SalYieldMutex( SalInstanceData* pInstData )
+SalYieldMutex::SalYieldMutex( WinSalInstance* pInstData )
 {
     mpInstData  = pInstData;
     mnCount     = 0;
@@ -250,7 +257,7 @@ ULONG SalYieldMutex::GetAcquireCount( UL
 
 void ImplSalYieldMutexAcquireWithWait()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( !pInst )
         return;
 
@@ -267,41 +274,41 @@ void ImplSalYieldMutexAcquireWithWait()
         BOOL bAcquire = FALSE;
         do
         {
-            if ( pInst->maInstData.mpSalYieldMutex->tryToAcquire() )
+            if ( pInst->mpSalYieldMutex->tryToAcquire() )
                 bAcquire = TRUE;
             else
             {
-                pInst->maInstData.mpSalWaitMutex->acquire();
-                if ( pInst->maInstData.mpSalYieldMutex->tryToAcquire() )
+                pInst->mpSalWaitMutex->acquire();
+                if ( pInst->mpSalYieldMutex->tryToAcquire() )
                 {
                     bAcquire = TRUE;
-                    pInst->maInstData.mpSalWaitMutex->release();
+                    pInst->mpSalWaitMutex->release();
                 }
                 else
                 {
-                    pInst->maInstData.mnYieldWaitCount++;
-                    pInst->maInstData.mpSalWaitMutex->release();
+                    pInst->mnYieldWaitCount++;
+                    pInst->mpSalWaitMutex->release();
                     MSG aTmpMsg;
-                    ImplGetMessage( &aTmpMsg, pInst->maInstData.mhComWnd, SAL_MSG_RELEASEWAITYIELD, SAL_MSG_RELEASEWAITYIELD );
-                    pInst->maInstData.mnYieldWaitCount--;
-                    if ( pInst->maInstData.mnYieldWaitCount )
-                        ImplPostMessage( pInst->maInstData.mhComWnd, SAL_MSG_RELEASEWAITYIELD, 0, 0 );
+                    ImplGetMessage( &aTmpMsg, pInst->mhComWnd, SAL_MSG_RELEASEWAITYIELD, SAL_MSG_RELEASEWAITYIELD );
+                    pInst->mnYieldWaitCount--;
+                    if ( pInst->mnYieldWaitCount )
+                        ImplPostMessage( pInst->mhComWnd, SAL_MSG_RELEASEWAITYIELD, 0, 0 );
                 }
             }
         }
         while ( !bAcquire );
     }
     else
-        pInst->maInstData.mpSalYieldMutex->acquire();
+        pInst->mpSalYieldMutex->acquire();
 }
 
 // -----------------------------------------------------------------------
 
 BOOL ImplSalYieldMutexTryToAcquire()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( pInst )
-        return pInst->maInstData.mpSalYieldMutex->tryToAcquire();
+        return pInst->mpSalYieldMutex->tryToAcquire();
     else
         return FALSE;
 }
@@ -310,20 +317,20 @@ BOOL ImplSalYieldMutexTryToAcquire()
 
 void ImplSalYieldMutexAcquire()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( pInst )
-        pInst->maInstData.mpSalYieldMutex->acquire();
+        pInst->mpSalYieldMutex->acquire();
 }
 
 // -----------------------------------------------------------------------
 
 void ImplSalYieldMutexRelease()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( pInst )
     {
         GdiFlush();
-        pInst->maInstData.mpSalYieldMutex->release();
+        pInst->mpSalYieldMutex->release();
     }
 }
 
@@ -331,11 +338,11 @@ void ImplSalYieldMutexRelease()
 
 ULONG ImplSalReleaseYieldMutex()
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( !pInst )
         return 0;
 
-    SalYieldMutex*  pYieldMutex = pInst->maInstData.mpSalYieldMutex;
+    SalYieldMutex*  pYieldMutex = pInst->mpSalYieldMutex;
     ULONG           nCount = pYieldMutex->GetAcquireCount( GetCurrentThreadId() );
     ULONG           n = nCount;
     while ( n )
@@ -351,11 +358,11 @@ ULONG ImplSalReleaseYieldMutex()
 
 void ImplSalAcquireYieldMutex( ULONG nCount )
 {
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( !pInst )
         return;
 
-    SalYieldMutex*  pYieldMutex = pInst->maInstData.mpSalYieldMutex;
+    SalYieldMutex*  pYieldMutex = pInst->mpSalYieldMutex;
     while ( nCount )
     {
         pYieldMutex->acquire();
@@ -375,7 +382,7 @@ void ImplDbgTestSolarMutex()
     {
         if ( pSalData->mpFirstInstance )
         {
-            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->maInstData.mpSalYieldMutex;
+            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->mpSalYieldMutex;
             if ( pYieldMutex->mnThreadId != nCurThreadId )
             {
                 DBG_ERROR( "SolarMutex not locked, and not thread save code in VCL is called from outside of the main thread" );
@@ -386,7 +393,7 @@ void ImplDbgTestSolarMutex()
     {
         if ( pSalData->mpFirstInstance )
         {
-            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->maInstData.mpSalYieldMutex;
+            SalYieldMutex* pYieldMutex = pSalData->mpFirstInstance->mpSalYieldMutex;
             if ( pYieldMutex->mnThreadId != nCurThreadId )
             {
                 DBG_ERROR( "SolarMutex not locked in the main thread" );
@@ -413,27 +420,102 @@ static void InitSalShlData()
 }
 
 // =======================================================================
+// -------
+// SalData
+// -------
+
+SalData::SalData()
+{
+    mhInst = 0;                 // default instance handle
+    mhPrevInst = 0;             // previous instance handle
+    mnCmdShow = 0;              // default frame show style
+    mhDitherPal = 0;            // dither palette
+    mhDitherDIB = 0;            // dither memory handle
+    mpDitherDIB = 0;            // dither memory
+    mpDitherDIBData = 0;        // beginning of DIB data
+    mpDitherDiff = 0;           // Dither mapping table
+    mpDitherLow = 0;            // Dither mapping table
+    mpDitherHigh = 0;           // Dither mapping table
+    mnTimerMS = 0;              // Current Time (in MS) of the Timer
+    mnTimerOrgMS = 0;           // Current Original Time (in MS)
+    mnTimerId = 0;              // windows timer id
+    mbInTimerProc = FALSE;      // timer event is currently being dispatched
+    mhSalObjMsgHook = 0;        // hook to get interesting msg for SalObject
+    mhWantLeaveMsg = 0;         // window handle, that want a MOUSELEAVE message
+    mpMouseLeaveTimer = 0;      // Timer for MouseLeave Test
+    mpFirstInstance = 0;        // pointer of first instance
+    mpFirstFrame = 0;           // pointer of first frame
+    mpFirstObject = 0;          // pointer of first object window
+    mpFirstVD = 0;              // first VirDev
+    mpFirstPrinter = 0;         // first printing printer
+    mpHDCCache = 0;             // Cache for three DC's
+    mh50Bmp = 0;                // 50% Bitmap
+    mh50Brush = 0;              // 50% Brush
+    int i;
+    for(i=0; i<MAX_STOCKPEN; i++)
+    {
+        maStockPenColorAry[i] = 0;
+        mhStockPenAry[i] = 0;
+    }
+    for(i=0; i<MAX_STOCKBRUSH; i++)
+    {
+        maStockBrushColorAry[i] = 0;
+        mhStockBrushAry[i] = 0;
+    }
+    mnStockPenCount = 0;        // count of static pens
+    mnStockBrushCount = 0;      // count of static brushes
+    mnSalObjWantKeyEvt = 0;     // KeyEvent, welcher vom SalObj-Hook verarbeitet werden soll
+    mnCacheDCInUse = 0;         // count of CacheDC in use
+    mbObjClassInit = FALSE;     // is SALOBJECTCLASS initialised
+    mbInPalChange = FALSE;      // is in WM_QUERYNEWPALETTE
+    mnAppThreadId = 0;          // Id from Applikation-Thread
+    mbScrSvrEnabled = FALSE;    // ScreenSaver enabled
+    mnSageStatus = 0;           // status of Sage-DLL (DISABLE_AGENT == nicht vorhanden)
+    mhSageInst = 0;             // instance handle for the Sage-DLL
+    mpSageEnableProc = 0;       // funktion to deactivate the system agent
+    mpFirstIcon = 0;            // icon cache, points to first icon, NULL if none
+    mpTempFontItem = 0;
+    mbThemeChanged = FALSE;     // true if visual theme was changed: throw away theme handles
+
+    SetSalData( this );
+    initNWF();
+}
+
+SalData::~SalData()
+{
+    deInitNWF();
+    SetSalData( NULL );
+}
 
 void InitSalData()
 {
     SalData* pSalData = new SalData;
-    memset( pSalData, 0, sizeof( SalData ) );
-    SetSalData( pSalData );
     CoInitialize(0);
 }
 
-// -----------------------------------------------------------------------
 
 void DeInitSalData()
 {
     CoUninitialize();
     SalData* pSalData = GetSalData();
     delete pSalData;
-    SetSalData( NULL );
 }
 
+// -----------------------------------------------------------------------
+
 void InitSalMain()
 {
+    // remember data, copied from WinMain
+    SalData* pData = GetAppSalData();
+    if ( pData )    // Im AppServer NULL
+    {
+        STARTUPINFO aSI;
+        aSI.cb = sizeof( aSI );
+        GetStartupInfo( &aSI );
+        pData->mhInst                   = GetModuleHandle( NULL );
+        pData->mhPrevInst               = NULL;
+        pData->mnCmdShow                = aSI.wShowWindow;
+    }
 }
 
 void DeInitSalMain()
@@ -442,27 +524,16 @@ void DeInitSalMain()
 
 // -----------------------------------------------------------------------
 
-void SetFilterCallback( void* pCallback, void* pInst )
-{
-    SalData* pSalData = GetSalData();
-
-    pSalData->mpFirstInstance->maInstData.mpFilterCallback = pCallback;
-    pSalData->mpFirstInstance->maInstData.mpFilterInst = pInst;
-}
-
-// -----------------------------------------------------------------------
-
 SalInstance* CreateSalInstance()
 {
     SalData* pSalData = GetSalData();
 
     // determine the windows version
-    aSalShlData.mbW40 = 0;
     aSalShlData.mbWNT = 0;
     aSalShlData.mbWXP = 0;
     WORD nVer = (WORD)GetVersion();
     aSalShlData.mnVersion = (((WORD)LOBYTE(nVer)) * 100) + HIBYTE(nVer);
-    if ( aSalShlData.mnVersion >= W95_VERSION )
+    if ( aSalShlData.mnVersion >= 400 )
         aSalShlData.mbW40 = 1;
     OSVERSIONINFO aVerInfo;
     aVerInfo.dwOSVersionInfoSize = sizeof( aVerInfo );
@@ -570,15 +641,15 @@ SalInstance* CreateSalInstance()
     if ( !hComWnd )
         return NULL;
 
-    SalInstance* pInst = new SalInstance;
+    WinSalInstance* pInst = new WinSalInstance;
 
     // init shl data
     InitSalShlData();
 
     // init instance (only one instance in this version !!!)
     pSalData->mpFirstInstance   = pInst;
-    pInst->maInstData.mhInst    = pSalData->mhInst;
-    pInst->maInstData.mhComWnd  = hComWnd;
+    pInst->mhInst    = pSalData->mhInst;
+    pInst->mhComWnd  = hComWnd;
 
     // init static GDI Data
     ImplInitSalGDI();
@@ -605,44 +676,43 @@ void DestroySalInstance( SalInstance* pI
 
 // -----------------------------------------------------------------------
 
-SalInstance::SalInstance()
+WinSalInstance::WinSalInstance()
 {
-    maInstData.mhComWnd                 = 0;
-    maInstData.mpFilterCallback         = NULL;
-    maInstData.mpFilterInst             = NULL;
-    maInstData.mpSalYieldMutex          = new SalYieldMutex( &maInstData );
-    maInstData.mpSalWaitMutex           = new vos::OMutex;
-    maInstData.mnYieldWaitCount         = 0;
-    maInstData.mpSalYieldMutex->acquire();
+    mhComWnd                 = 0;
+    mpSalYieldMutex          = new SalYieldMutex( this );
+    mpSalWaitMutex           = new vos::OMutex;
+    mnYieldWaitCount         = 0;
+    mpSalYieldMutex->acquire();
 }
 
 // -----------------------------------------------------------------------
 
-SalInstance::~SalInstance()
+WinSalInstance::~WinSalInstance()
 {
-    maInstData.mpSalYieldMutex->release();
-    delete maInstData.mpSalYieldMutex;
-    delete maInstData.mpSalWaitMutex;
-    DestroyWindow( maInstData.mhComWnd );
+    WinSalOpenGL::Release();
+    mpSalYieldMutex->release();
+    delete mpSalYieldMutex;
+    delete mpSalWaitMutex;
+    DestroyWindow( mhComWnd );
 }
 
 // -----------------------------------------------------------------------
 
-vos::IMutex* SalInstance::GetYieldMutex()
+vos::IMutex* WinSalInstance::GetYieldMutex()
 {
-    return maInstData.mpSalYieldMutex;
+    return mpSalYieldMutex;
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalInstance::ReleaseYieldMutex()
+ULONG WinSalInstance::ReleaseYieldMutex()
 {
     return ImplSalReleaseYieldMutex();
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::AcquireYieldMutex( ULONG nCount )
+void WinSalInstance::AcquireYieldMutex( ULONG nCount )
 {
     ImplSalAcquireYieldMutex( nCount );
 }
@@ -668,7 +738,7 @@ void ImplSalYield( BOOL bWait )
 {
     MSG aMsg;
 
-    SalInstance* pInst = GetSalData()->mpFirstInstance;
+    WinSalInstance* pInst = GetSalData()->mpFirstInstance;
     if ( bWait )
     {
         if ( ImplGetMessage( &aMsg, 0, 0, 0 ) )
@@ -689,9 +759,9 @@ void ImplSalYield( BOOL bWait )
 
 // -----------------------------------------------------------------------
 
-void SalInstance::Yield( BOOL bWait )
+void WinSalInstance::Yield( BOOL bWait )
 {
-    SalYieldMutex*  pYieldMutex = maInstData.mpSalYieldMutex;
+    SalYieldMutex*  pYieldMutex = mpSalYieldMutex;
     SalData*        pSalData = GetSalData();
     DWORD           nCurThreadId = GetCurrentThreadId();
     ULONG           nCount = pYieldMutex->GetAcquireCount( nCurThreadId );
@@ -716,7 +786,7 @@ void SalInstance::Yield( BOOL bWait )
         if( ImplGetSVData()->maAppData.mnModalMode )
             Sleep(1);
         else
-            ImplSendMessage( maInstData.mhComWnd, SAL_MSG_THREADYIELD, (WPARAM)bWait, (LPARAM)0 );
+            ImplSendMessage( mhComWnd, SAL_MSG_THREADYIELD, (WPARAM)bWait, (LPARAM)0 );
 
         n = nCount;
         while ( n )
@@ -760,8 +830,8 @@ LRESULT CALLBACK SalComWndProc( HWND hWn
         // us again, because in the other case we wait forever.
         case SAL_MSG_RELEASEWAITYIELD:
             {
-            SalInstance* pInst = GetSalData()->mpFirstInstance;
-            if ( pInst && pInst->maInstData.mnYieldWaitCount )
+            WinSalInstance* pInst = GetSalData()->mpFirstInstance;
+            if ( pInst && pInst->mnYieldWaitCount )
                 ImplPostMessage( hWnd, SAL_MSG_RELEASEWAITYIELD, wParam, lParam );
             }
             rDef = FALSE;
@@ -787,7 +857,7 @@ LRESULT CALLBACK SalComWndProc( HWND hWn
             rDef = FALSE;
             break;
         case SAL_MSG_CREATEOBJECT:
-            nRet = (LRESULT)ImplSalCreateObject( GetSalData()->mpFirstInstance, (SalFrame*)lParam );
+            nRet = (LRESULT)ImplSalCreateObject( GetSalData()->mpFirstInstance, (WinSalFrame*)lParam );
             rDef = FALSE;
             break;
         case SAL_MSG_DESTROYOBJECT:
@@ -795,11 +865,11 @@ LRESULT CALLBACK SalComWndProc( HWND hWn
             rDef = FALSE;
             break;
         case SAL_MSG_CREATESOUND:
-            nRet = ((SalSound*)lParam)->ImplCreate();
+            nRet = ((WinSalSound*)lParam)->ImplCreate();
             rDef = FALSE;
             break;
         case SAL_MSG_DESTROYSOUND:
-            ((SalSound*)lParam)->ImplDestroy();
+            ((WinSalSound*)lParam)->ImplDestroy();
             rDef = FALSE;
             break;
         case SAL_MSG_GETDC:
@@ -865,7 +935,7 @@ BOOL ImplVerifyTimerMessage( const MSG& 
         return TRUE;    // arbitrary messages
 }
 
-BOOL SalInstance::AnyInput( USHORT nType )
+bool WinSalInstance::AnyInput( USHORT nType )
 {
     MSG aMsg;
 
@@ -875,7 +945,7 @@ BOOL SalInstance::AnyInput( USHORT nType
         // Thus we have to check for user input messages first to be able to detect them between the timer messages.
         // Otherwise we might not detect user input and the system will become unresponsive.
         if( AnyInput( INPUT_MOUSE ) || AnyInput( INPUT_KEYBOARD ) || AnyInput( INPUT_PAINT ) )
-            return TRUE;
+            return true;
         if ( ImplPeekMessage( &aMsg, 0, 0, 0, PM_NOREMOVE | PM_NOYIELD ) )
             return ImplVerifyTimerMessage( aMsg );
     }
@@ -886,7 +956,7 @@ BOOL SalInstance::AnyInput( USHORT nType
             // Test for mouse input
             if ( ImplPeekMessage( &aMsg, 0, WM_MOUSEFIRST, WM_MOUSELAST,
                                   PM_NOREMOVE | PM_NOYIELD ) )
-                return TRUE;
+                return true;
         }
 
         if ( nType & INPUT_KEYBOARD )
@@ -898,9 +968,9 @@ BOOL SalInstance::AnyInput( USHORT nType
                 if ( (aMsg.wParam == VK_SHIFT)   ||
                      (aMsg.wParam == VK_CONTROL) ||
                      (aMsg.wParam == VK_MENU) )
-                    return FALSE;
+                    return false;
                 else
-                    return TRUE;
+                    return true;
             }
         }
 
@@ -909,7 +979,7 @@ BOOL SalInstance::AnyInput( USHORT nType
             // Test for paint input
             if ( ImplPeekMessage( &aMsg, 0, WM_PAINT, WM_PAINT,
                                   PM_NOREMOVE | PM_NOYIELD ) )
-                return TRUE;
+                return true;
         }
 
         if ( nType & INPUT_TIMER )
@@ -943,9 +1013,9 @@ void SalTimer::Start( ULONG nMS )
     if ( pSalData->mpFirstInstance )
     {
         if ( pSalData->mnAppThreadId != GetCurrentThreadId() )
-            ImplPostMessage( pSalData->mpFirstInstance->maInstData.mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+            ImplPostMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
         else
-            ImplSendMessage( pSalData->mpFirstInstance->maInstData.mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+            ImplSendMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
     }
     else
         ImplSalStartTimer( nMS, FALSE );
@@ -953,71 +1023,110 @@ void SalTimer::Start( ULONG nMS )
 
 // -----------------------------------------------------------------------
 
-SalFrame* SalInstance::CreateChildFrame( SystemParentData* pSystemParentData, ULONG nSalFrameStyle )
+SalFrame* WinSalInstance::CreateChildFrame( SystemParentData* pSystemParentData, ULONG nSalFrameStyle )
 {
     // Um auf Main-Thread umzuschalten
-    return (SalFrame*)ImplSendMessage( maInstData.mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)pSystemParentData->hWnd );
+    return (SalFrame*)ImplSendMessage( mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)pSystemParentData->hWnd );
 }
 
 // -----------------------------------------------------------------------
 
-SalFrame* SalInstance::CreateFrame( SalFrame* pParent, ULONG nSalFrameStyle )
+SalFrame* WinSalInstance::CreateFrame( SalFrame* pParent, ULONG nSalFrameStyle )
 {
     // Um auf Main-Thread umzuschalten
     HWND hWndParent;
     if ( pParent )
-        hWndParent = pParent->maFrameData.mhWnd;
+        hWndParent = static_cast<WinSalFrame*>(pParent)->mhWnd;
     else
         hWndParent = 0;
-    return (SalFrame*)ImplSendMessage( maInstData.mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)hWndParent );
+    return (SalFrame*)ImplSendMessage( mhComWnd, SAL_MSG_CREATEFRAME, nSalFrameStyle, (LPARAM)hWndParent );
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyFrame( SalFrame* pFrame )
+void WinSalInstance::DestroyFrame( SalFrame* pFrame )
 {
-    ImplSendMessage( maInstData.mhComWnd, SAL_MSG_DESTROYFRAME, 0, (LPARAM)pFrame );
+    ImplSendMessage( mhComWnd, SAL_MSG_DESTROYFRAME, 0, (LPARAM)pFrame );
 }
 
 // -----------------------------------------------------------------------
 
-SalObject* SalInstance::CreateObject( SalFrame* pParent )
+SalObject* WinSalInstance::CreateObject( SalFrame* pParent )
 {
     // Um auf Main-Thread umzuschalten
-    return (SalObject*)ImplSendMessage( maInstData.mhComWnd, SAL_MSG_CREATEOBJECT, 0, (LPARAM)pParent );
+    return (SalObject*)ImplSendMessage( mhComWnd, SAL_MSG_CREATEOBJECT, 0, (LPARAM)static_cast<WinSalFrame*>(pParent) );
+}
+
+// -----------------------------------------------------------------------
+
+void WinSalInstance::DestroyObject( SalObject* pObject )
+{
+    ImplSendMessage( mhComWnd, SAL_MSG_DESTROYOBJECT, 0, (LPARAM)pObject );
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyObject( SalObject* pObject )
+void* WinSalInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
 {
-    ImplSendMessage( maInstData.mhComWnd, SAL_MSG_DESTROYOBJECT, 0, (LPARAM)pObject );
+    rReturnedBytes  = 1;
+    rReturnedType   = AsciiCString;
+    return "";
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::SetEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int) )
+SalTimer* WinSalInstance::CreateSalTimer()
 {
+    return new WinSalTimer();
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::SetErrorEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int) )
+SalSound* WinSalInstance::CreateSalSound()
 {
+    return new WinSalSound();
 }
 
 // -----------------------------------------------------------------------
 
-void* SalInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
+SalOpenGL* WinSalInstance::CreateSalOpenGL( SalGraphics* pGraphics )
 {
-    rReturnedBytes  = 1;
-    rReturnedType   = AsciiCString;
-    return "";
+    return new WinSalOpenGL( pGraphics );
+}
+
+// -----------------------------------------------------------------------
+
+SalBitmap* WinSalInstance::CreateSalBitmap()
+{
+    return new WinSalBitmap();
+}
+
+class WinImeStatus : public SalI18NImeStatus
+{
+  public:
+    WinImeStatus() {}
+    virtual ~WinImeStatus() {}
+    
+    // asks whether there is a status window available
+    // to toggle into menubar
+    virtual bool canToggle() { return false; }
+    virtual void toggle() {}
+};
+
+SalI18NImeStatus* WinSalInstance::CreateI18NImeStatus()
+{
+    return new WinImeStatus();
 }
 
 // -----------------------------------------------------------------------
 
-SalSession* SalInstance::CreateSalSession()
+const ::rtl::OUString& SalGetDesktopEnvironment()
+{
+    static ::rtl::OUString aDesktopEnvironment( RTL_CONSTASCII_USTRINGPARAM( "Windows" ) );
+    return aDesktopEnvironment;
+}
+
+SalSession* WinSalInstance::CreateSalSession()
 {
     return NULL;
 }
Index: vcl/win/source/app/salmain.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salmain.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/win/source/app/salmain.cxx	22 Feb 2001 15:40:01 -0000	1.2
+++ vcl/win/source/app/salmain.cxx	6 Jan 2004 14:52:21 -0000	1.3
@@ -62,8 +62,6 @@
 #ifndef _SVWIN_H
 #include <tools/svwin.h>
 #endif
-
-#define _SV_SALMAIN_CXX
 
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
Index: vcl/win/source/app/salshl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salshl.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/win/source/app/salshl.cxx	9 Nov 2001 14:33:27 -0000	1.3
+++ vcl/win/source/app/salshl.cxx	6 Jan 2004 14:52:42 -0000	1.4
@@ -63,8 +63,6 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALSHL_CXX
-
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
@@ -79,34 +77,6 @@ SalShlData aSalShlData;
 
 // =======================================================================
 
-#ifdef WIN
-
-extern "C"
-{
-
-int CALLBACK LibMain( HINSTANCE hInst, WORD, WORD nHeap, LPSTR )
-{
-	if ( nHeap )
-		UnlockData( 0 );
-
-	aSalShlData.mhInst = hInst;
-
-	return 1;
-}
-
-// -----------------------------------------------------------------------
-
-int CALLBACK WEP( int )
-{
-	return 1;
-}
-
-}
-
-#endif
-
-// =======================================================================
-
 #ifdef WNT
 
 extern "C"
Index: vcl/win/source/app/salsound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/salsound.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/app/salsound.cxx	15 Nov 2000 11:48:58 -0000	1.2
+++ vcl/win/source/app/salsound.cxx	6 Jan 2004 14:53:09 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALSOUND_CXX
-
 #define INCLUDE_MMSYSTEM
 
 // ------------
@@ -74,11 +72,11 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALSOUND_HXX
-#include <salsound.hxx>
+#ifndef _SV_SALSOUND_H
+#include <salsound.h>
 #endif
 
 // ---------
@@ -96,21 +94,17 @@
 // - Fnc cast -
 // ------------
 
-#ifdef WIN
-#define __MCI_CALL _far _pascal
-#else
 #define __MCI_CALL __stdcall
-#endif
 
-#define MCIFNC ((DWORD( __MCI_CALL * )( UINT, UINT, DWORD, DWORD )) SalSound::mpMCIFnc)
+#define MCIFNC ((DWORD( __MCI_CALL * )( UINT, UINT, DWORD, DWORD )) WinSalSound::mpMCIFnc)
 
 // -----------------
 // - Statics init. -
 // -----------------
 
-HINSTANCE	SalSound::mhMCILib = 0;
-ULONG		SalSound::mnSoundState = SOUND_STATE_UNLOADED;
-void*		SalSound::mpMCIFnc = NULL;
+HINSTANCE	WinSalSound::mhMCILib = 0;
+ULONG		WinSalSound::mnSoundState = SOUND_STATE_UNLOADED;
+void*		WinSalSound::mpMCIFnc = NULL;
 
 // -------------------
 // - Window-Callback -
@@ -140,7 +134,7 @@ void ImplSalHandleMCINotify( HWND hWnd, 
 	}
 
 	if ( bNotify )
-		((SalSound*)GetWindowLong( hWnd, 0 ) )->ImplNotify( eNotification, 0 );
+		((WinSalSound*)GetWindowLong( hWnd, 0 ) )->ImplNotify( eNotification, 0 );
 }
 
 LRESULT CALLBACK SalSoundWndProcA( HWND hWnd, UINT nMsg, WPARAM nPar1, LPARAM nPar2 )
@@ -161,8 +155,7 @@ LRESULT CALLBACK SalSoundWndProcW( HWND 
 // - SalSound -
 // ------------
 
-SalSound::SalSound() :
-	mpProc			( NULL ),
+WinSalSound::WinSalSound() :
 	mhSoundWnd		( 0 ),
 	mnDeviceId		( 0 ),
 	mbLoop			( FALSE ),
@@ -172,7 +165,7 @@ SalSound::SalSound() :
 
 // ------------------------------------------------------------------------
 
-SalSound::~SalSound()
+WinSalSound::~WinSalSound()
 {
 	Stop();
 
@@ -187,10 +180,10 @@ SalSound::~SalSound()
 	// Call Destroy in the main thread, because Create is also called in
 	// the main thread and if we don't call this also in the main thread
 	// windows doesn't destroy the window
-	SalInstance* pInst = GetSalData()->mpFirstInstance;
+	WinSalInstance* pInst = GetSalData()->mpFirstInstance;
 	if ( pInst )
 	{
-		ImplSendMessage( pInst->maInstData.mhComWnd, SAL_MSG_DESTROYSOUND,
+		ImplSendMessage( pInst->mhComWnd, SAL_MSG_DESTROYSOUND,
 						 0, (LPARAM)this );
 	}
 	else
@@ -199,7 +192,7 @@ SalSound::~SalSound()
 
 // ------------------------------------------------------------------------
 
-void SalSound::ImplSetError( DWORD nMciErr )
+void WinSalSound::ImplSetError( DWORD nMciErr )
 {
 	struct aMapper { DWORD nMci; ULONG nSv; };
 
@@ -240,29 +233,28 @@ void SalSound::ImplSetError( DWORD nMciE
 
 // ------------------------------------------------------------------------
 
-void SalSound::ImplNotify( SoundNotification eNotification, ULONG nError )
+void WinSalSound::ImplNotify( SoundNotification eNotification, ULONG nError )
 {
 	if ( mbLoop && (SOUND_NOTIFY_SUCCESS == eNotification) && !nError )
 		Play( mnStartTime, mnPlayLen, TRUE );
 
-	if ( mpProc && mpInst )
-		mpProc( mpInst, eNotification, nError );
+    CallNotifyProc( eNotification, nError );
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalSound::ImplCreate()
+bool WinSalSound::ImplCreate()
 {
 	SalData*	pData = GetSalData();
-	BOOL		bRet = FALSE;
+	bool		bRet = FALSE;
 
-	if ( SOUND_STATE_UNLOADED == SalSound::mnSoundState )
+	if ( SOUND_STATE_UNLOADED == WinSalSound::mnSoundState )
 	{
 		// load library and init fncpointer
 		if ( aSalShlData.mbWNT )
 		{
-			if ( (SalSound::mhMCILib = LoadLibraryW( SOUND_LIBNAMEW )) != 0 &&
-				 (SalSound::mpMCIFnc = (void*)GetProcAddress( SalSound::mhMCILib, SOUND_PROCNAMEW )) != 0 )
+			if ( (WinSalSound::mhMCILib = LoadLibraryW( SOUND_LIBNAMEW )) != 0 &&
+				 (WinSalSound::mpMCIFnc = (void*)GetProcAddress( WinSalSound::mhMCILib, SOUND_PROCNAMEW )) != 0 )
 			{
 				WNDCLASSEXW aWndClass;
 
@@ -274,15 +266,15 @@ BOOL SalSound::ImplCreate()
 				aWndClass.lpszClassName = SOUND_WINDOWCLASSW;
 				if ( RegisterClassExW( &aWndClass ) )
 				{
-					SalSound::mnSoundState = SOUND_STATE_VALID;
+					WinSalSound::mnSoundState = SOUND_STATE_VALID;
 					bRet = TRUE;
 				}
 			}
 		}
 		else
 		{
-			if ( (SalSound::mhMCILib = LoadLibraryA( SOUND_LIBNAMEA )) != 0 &&
-				 (SalSound::mpMCIFnc = (void*)GetProcAddress( SalSound::mhMCILib, SOUND_PROCNAMEA )) != 0 )
+			if ( (WinSalSound::mhMCILib = LoadLibraryA( SOUND_LIBNAMEA )) != 0 &&
+				 (WinSalSound::mpMCIFnc = (void*)GetProcAddress( WinSalSound::mhMCILib, SOUND_PROCNAMEA )) != 0 )
 			{
 				WNDCLASSEXA aWndClass;
 
@@ -294,7 +286,7 @@ BOOL SalSound::ImplCreate()
 				aWndClass.lpszClassName = SOUND_WINDOWCLASSA;
 				if ( RegisterClassExA( &aWndClass ) )
 				{
-					SalSound::mnSoundState = SOUND_STATE_VALID;
+					WinSalSound::mnSoundState = SOUND_STATE_VALID;
 					bRet = TRUE;
 				}
 			}
@@ -302,14 +294,14 @@ BOOL SalSound::ImplCreate()
 
 		if ( !bRet )
 		{
-			if ( SalSound::mhMCILib )
-				FreeLibrary( SalSound::mhMCILib );
+			if ( WinSalSound::mhMCILib )
+				FreeLibrary( WinSalSound::mhMCILib );
 
-			SalSound::mnSoundState = SOUND_STATE_INVALID;
+			WinSalSound::mnSoundState = SOUND_STATE_INVALID;
 			ImplNotify( SOUND_NOTIFY_ERROR, SOUNDERR_CANNOT_LOAD_DRIVER );
 		}
 	}
-	else if ( SOUND_STATE_VALID == SalSound::mnSoundState )
+	else if ( SOUND_STATE_VALID == WinSalSound::mnSoundState )
 		bRet = TRUE;
 
 	if ( bRet )
@@ -335,14 +327,14 @@ BOOL SalSound::ImplCreate()
 
 // ------------------------------------------------------------------------
 
-BOOL SalSound::Create()
+bool WinSalSound::IsValid()
 {
 	// Call Create in the main thread, because in the other case the
 	// Sound stop, if the calling thread dies.
-	SalInstance* pInst = GetSalData()->mpFirstInstance;
+	WinSalInstance* pInst = GetSalData()->mpFirstInstance;
 	if ( pInst )
 	{
-		return (BOOL)ImplSendMessage( pInst->maInstData.mhComWnd, SAL_MSG_CREATESOUND,
+		return (BOOL)ImplSendMessage( pInst->mhComWnd, SAL_MSG_CREATESOUND,
 									  0, (LPARAM)this );
 	}
 	else
@@ -351,7 +343,7 @@ BOOL SalSound::Create()
 
 // ------------------------------------------------------------------------
 
-void SalSound::ImplDestroy()
+void WinSalSound::ImplDestroy()
 {
 	if ( mhSoundWnd )
 		DestroyWindow( mhSoundWnd );
@@ -360,18 +352,18 @@ void SalSound::ImplDestroy()
 
 // ------------------------------------------------------------------------
 
-void SalSound::Release()
+void WinSalSound::Release()
 {
 	// free library
-	if ( SalSound::mhMCILib )
-		FreeLibrary( SalSound::mhMCILib );
+	if ( WinSalSound::mhMCILib )
+		FreeLibrary( WinSalSound::mhMCILib );
 
-	SalSound::mnSoundState = SOUND_STATE_UNLOADED;
+	WinSalSound::mnSoundState = SOUND_STATE_UNLOADED;
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalSound::Init( SalFrame* pFrame, const XubString& rSoundName, ULONG& rSoundLen )
+bool WinSalSound::Init( const XubString& rSoundName, ULONG& rSoundLen )
 {
 	DWORD nMciErr = 0;
 	rSoundLen = 0;
@@ -438,22 +430,12 @@ BOOL SalSound::Init( SalFrame* pFrame, c
 	if ( nMciErr )
 		ImplSetError( nMciErr );
 
-	return (nMciErr ? FALSE : TRUE);
-}
-
-// ------------------------------------------------------------------------
-
-BOOL SalSound::Init( SalFrame* pFrame, const BYTE* pSound, ULONG nDataLen, ULONG& rSoundLen )
-{
-	rSoundLen = 0UL;
-	ImplSetError( MCIERR_FILE_NOT_FOUND );
-
-	return FALSE;
+	return (nMciErr ? false : true);
 }
 
 // ------------------------------------------------------------------------
 
-void SalSound::Play( ULONG nStartTime, ULONG nPlayLen, BOOL bLoop )
+void WinSalSound::Play( ULONG nStartTime, ULONG nPlayLen, bool bLoop )
 {
 	if ( mnDeviceId )
 	{
@@ -470,7 +452,7 @@ void SalSound::Play( ULONG nStartTime, U
 		mnStartTime = nStartTime;
 		mnPlayLen = nPlayLen;
 		mbLoop = bLoop;
-		mbPaused = FALSE;
+		mbPaused = false;
 
 		if( !nMciErr )
 		{
@@ -506,26 +488,54 @@ void SalSound::Play( ULONG nStartTime, U
 
 // ------------------------------------------------------------------------
 
-void SalSound::Stop()
+void WinSalSound::Stop()
 {
 	if ( mnDeviceId )
 	{
 		MCI_GENERIC_PARMS aGenericParams;
 		aGenericParams.dwCallback = (DWORD)mhSoundWnd;
-		mbLoop = mbPaused = FALSE;
+		mbLoop = mbPaused = false;
 		MCIFNC( mnDeviceId, MCI_STOP, MCI_WAIT, (DWORD) &aGenericParams );
 	}
 }
 
 // ------------------------------------------------------------------------
 
-void SalSound::Pause()
+void WinSalSound::Pause()
 {
 	if ( mnDeviceId )
 	{
 		MCI_GENERIC_PARMS aGenericParams;
 		aGenericParams.dwCallback = (DWORD)mhSoundWnd;
-		mbPaused = TRUE;
+		mbPaused = true;
 		MCIFNC( mnDeviceId, MCI_PAUSE, MCI_WAIT, (DWORD) &aGenericParams );
 	}
+}
+
+// ------------------------------------------------------------------------
+
+void WinSalSound::Continue()
+{
+    Play( 0, 0, mbLoop );
+}
+
+// ------------------------------------------------------------------------
+
+bool WinSalSound::IsLoopMode() const
+{
+    return mbLoop;
+}
+
+// ------------------------------------------------------------------------
+
+bool WinSalSound::IsPlaying() const
+{
+    return !mbPaused;
+}
+
+// ------------------------------------------------------------------------
+
+bool WinSalSound::IsPaused() const
+{
+    return mbPaused;
 }
Index: vcl/win/source/app/saltimer.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/app/saltimer.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/app/saltimer.cxx	28 May 2003 12:35:28 -0000	1.2
+++ vcl/win/source/app/saltimer.cxx	6 Jan 2004 14:53:36 -0000	1.4
@@ -63,13 +63,14 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALTIMER_CXX
-
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALTIMER_HXX
-#include <saltimer.hxx>
+#ifndef _SV_SALTIMER_H
+#include <saltimer.h>
+#endif
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 // =======================================================================
@@ -102,7 +103,26 @@ void ImplSalStartTimer( ULONG nMS, BOOL 
 
 // -----------------------------------------------------------------------
 
-void SalTimer::Stop()
+WinSalTimer::~WinSalTimer()
+{
+}
+
+void WinSalTimer::Start( ULONG nMS )
+{
+    // switch to main thread
+    SalData* pSalData = GetSalData();
+    if ( pSalData->mpFirstInstance )
+    {
+        if ( pSalData->mnAppThreadId != GetCurrentThreadId() )
+            ImplPostMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+        else
+            ImplSendMessage( pSalData->mpFirstInstance->mhComWnd, SAL_MSG_STARTTIMER, 0, (LPARAM)nMS );
+    }
+    else
+        ImplSalStartTimer( nMS, FALSE );
+}
+
+void WinSalTimer::Stop()
 {
 	SalData* pSalData = GetSalData();
 
@@ -116,29 +136,22 @@ void SalTimer::Stop()
 
 // -----------------------------------------------------------------------
 
-void SalTimer::SetCallback( SALTIMERPROC pProc )
-{
-	SalData* pSalData = GetSalData();
-	pSalData->mpTimerProc = pProc;
-}
-
-// -----------------------------------------------------------------------
-
 void CALLBACK SalTimerProc( HWND, UINT, UINT, DWORD )
 {
 	SalData* pSalData = GetSalData();
+    ImplSVData* pSVData = ImplGetSVData();
 
 	// Test for MouseLeave
 	SalTestMouseLeave();
 
-	if ( pSalData->mpTimerProc )
+	if ( pSVData->mpSalTimer )
 	{
 		// Try to aquire the mutex. If we don't get the mutex then we
 		// try this a short time later again.
 		if ( ImplSalYieldMutexTryToAcquire() )
 		{
             pSalData->mbInTimerProc = TRUE;
-			pSalData->mpTimerProc();
+			pSVData->mpSalTimer->CallCallback();
             pSalData->mbInTimerProc = FALSE;
 			ImplSalYieldMutexRelease();
 
Index: vcl/win/source/gdi/MAKEFILE.MK
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/MAKEFILE.MK,v
retrieving revision 1.4
retrieving revision 1.7
diff -u -p -u -r1.4 -r1.7
--- vcl/win/source/gdi/MAKEFILE.MK	11 Apr 2003 17:35:54 -0000	1.4
+++ vcl/win/source/gdi/MAKEFILE.MK	10 May 2004 16:02:14 -0000	1.7
@@ -34,27 +83,13 @@ SLOFILES=   $(SLO)$/salgdi.obj   \
             $(SLO)$/salvd.obj    \
             $(SLO)$/salprn.obj   \
             $(SLO)$/salbmp.obj	 \
-            $(SLO)$/salogl.obj
-
-.IF "$(ENABLE_CTL)" != ""
-SLOFILES+=$(SLO)$/winlayout.obj
-.ENDIF
-
-.IF "$(GUI)" == "WNT"
-SLOFILES+=$(SLO)$/wntgdi.obj
-.ENDIF
+            $(SLO)$/salogl.obj	\
+            $(SLO)$/winlayout.obj	\
+            $(SLO)$/wntgdi.obj      \
+	        $(SLO)$/salnativewidgets-luna.obj
+            
 
 EXCEPTIONSFILES=	$(SLO)$/salprn.obj
-
-.IF "$(UPDATER)"=="YES"
-OBJFILES=   $(OBJ)$/salgdi.obj   \
-            $(OBJ)$/salgdi2.obj  \
-            $(OBJ)$/salgdi3.obj  \
-            $(OBJ)$/salvd.obj    \
-            $(OBJ)$/salprn.obj   \
-            $(OBJ)$/salbmp.obj	 \
-			$(OBJ)$/salogl.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/win/source/gdi/salbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salbmp.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/gdi/salbmp.cxx	28 Jun 2001 13:13:55 -0000	1.2
+++ vcl/win/source/gdi/salbmp.cxx	6 Jan 2004 14:54:30 -0000	1.4
@@ -63,29 +63,23 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALBMP_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 #include <string.h>
 
-#ifdef WIN
-#define BI_BITFIELDS	3
-#endif
-
 // -----------
 // - Inlines -
 // -----------
@@ -98,11 +92,11 @@ inline void ImplSetPixel4( const HPBYTE 
 				 ( rByte &= 0x0f, rByte |= ( cIndex << 4 ) );
 }
 
-// -------------
-// - SalBitmap -
-// -------------
+// ----------------
+// - WinSalBitmap -
+// ----------------
 
-SalBitmap::SalBitmap() :
+WinSalBitmap::WinSalBitmap() :
 		mhDIB		( 0 ),
 		mhDDB		( 0 ),
 		mnBitCount	( 0 )
@@ -111,16 +105,16 @@ SalBitmap::SalBitmap() :
 
 // ------------------------------------------------------------------
 
-SalBitmap::~SalBitmap()
+WinSalBitmap::~WinSalBitmap()
 {
 	Destroy();
 }
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( HANDLE hBitmap, BOOL bDIB, BOOL bCopyHandle )
+bool WinSalBitmap::Create( HANDLE hBitmap, bool bDIB, bool bCopyHandle )
 {
-	BOOL bRet = TRUE;
+	bool bRet = TRUE;
 
 	if( bDIB )
 		mhDIB = (HGLOBAL) ( bCopyHandle ? ImplCopyDIBOrDDB( hBitmap, TRUE ) : hBitmap );
@@ -169,9 +163,9 @@ BOOL SalBitmap::Create( HANDLE hBitmap, 
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+bool WinSalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
 
 	mhDIB = ImplCreateDIB( rSize, nBitCount, rPal );
 
@@ -187,9 +181,10 @@ BOOL SalBitmap::Create( const Size& rSiz
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBitmap )
+bool WinSalBitmap::Create( const SalBitmap& rSSalBitmap )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
 
 	if ( rSalBitmap.mhDIB || rSalBitmap.mhDDB )
 	{
@@ -215,15 +210,18 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
+bool WinSalBitmap::Create( const SalBitmap& rSSalBmp, SalGraphics* pSGraphics )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
+
+    const WinSalBitmap& rSalBmp = static_cast<const WinSalBitmap&>(rSSalBmp);
+    WinSalGraphics* pGraphics = static_cast<WinSalGraphics*>(pSGraphics);
 
 	if( rSalBmp.mhDIB )
 	{
 		PBITMAPINFO 		pBI = (PBITMAPINFO) GlobalLock( rSalBmp.mhDIB );
 		PBITMAPINFOHEADER	pBIH = (PBITMAPINFOHEADER) pBI;
-		HDC 				hDC  = pGraphics->maGraphicsData.mhDC;
+		HDC 				hDC  = pGraphics->mhDC;
 		HBITMAP 			hNewDDB;
 		BITMAP				aDDBInfo;
 		PBYTE				pBits = (PBYTE) pBI + *(DWORD*) pBI +
@@ -265,9 +263,11 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // ------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
+bool WinSalBitmap::Create( const SalBitmap& rSSalBmp, USHORT nNewBitCount )
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
+
+    const WinSalBitmap& rSalBmp = static_cast<const WinSalBitmap&>(rSSalBmp);
 
 	if( rSalBmp.mhDDB )
 	{
@@ -315,7 +315,7 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // ------------------------------------------------------------------
 
-void SalBitmap::Destroy()
+void WinSalBitmap::Destroy()
 {
 	if( mhDIB )
 		GlobalFree( mhDIB );
@@ -328,7 +328,7 @@ void SalBitmap::Destroy()
 
 // ------------------------------------------------------------------
 
-USHORT SalBitmap::ImplGetDIBColorCount( HGLOBAL hDIB )
+USHORT WinSalBitmap::ImplGetDIBColorCount( HGLOBAL hDIB )
 {
 	USHORT nColors = 0;
 
@@ -358,7 +358,7 @@ USHORT SalBitmap::ImplGetDIBColorCount( 
 
 // ------------------------------------------------------------------
 
-HGLOBAL SalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBits, const BitmapPalette& rPal )
+HGLOBAL WinSalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBits, const BitmapPalette& rPal )
 {
 	DBG_ASSERT( nBits == 1 || nBits == 4 || nBits == 8 || nBits == 24, "Unsupported BitCount!" );
 
@@ -393,7 +393,7 @@ HGLOBAL SalBitmap::ImplCreateDIB( const 
 				const USHORT nMinCount = Min( nColors, rPal.GetEntryCount() );
 
 				if( nMinCount )
-					HMEMCPY( pBI->bmiColors, rPal.ImplGetColorBuffer(), nMinCount * sizeof( RGBQUAD ) );
+					memcpy( pBI->bmiColors, rPal.ImplGetColorBuffer(), nMinCount * sizeof( RGBQUAD ) );
 			}
 
 			GlobalUnlock( hDIB );
@@ -405,7 +405,7 @@ HGLOBAL SalBitmap::ImplCreateDIB( const 
 
 // ------------------------------------------------------------------
 
-HANDLE SalBitmap::ImplCopyDIBOrDDB( HANDLE hHdl, BOOL bDIB )
+HANDLE WinSalBitmap::ImplCopyDIBOrDDB( HANDLE hHdl, bool bDIB )
 {
 	HANDLE	hCopy = 0;
 
@@ -415,7 +415,7 @@ HANDLE SalBitmap::ImplCopyDIBOrDDB( HAND
 
 		if ( hCopy = GlobalAlloc( GHND, nSize  ) )
 		{
-			HMEMCPY( (LPSTR) GlobalLock( hCopy ), (LPSTR) GlobalLock( hHdl ), nSize );
+			memcpy( (LPSTR) GlobalLock( hCopy ), (LPSTR) GlobalLock( hHdl ), nSize );
 
 			GlobalUnlock( hCopy );
 			GlobalUnlock( hHdl );
@@ -451,7 +451,7 @@ HANDLE SalBitmap::ImplCopyDIBOrDDB( HAND
 
 // ------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::AcquireBuffer( BOOL bReadOnly )
+BitmapBuffer* WinSalBitmap::AcquireBuffer( bool bReadOnly )
 {
 	BitmapBuffer* pBuffer = NULL;
 
@@ -474,7 +474,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 				BYTE*				pOldBits = (PBYTE) pBI + nOffset;
 				BYTE*				pNewBits = (PBYTE) pNewBI + nOffset;
 
-				HMEMCPY( pNewBI, pBI, nOffset );
+				memcpy( pNewBI, pBI, nOffset );
 				pNewBIH->biCompression = 0;
 				ImplDecodeRLEBuffer( pOldBits, pNewBits, aSizePix, pBIH->biCompression == BI_RLE4 );
 
@@ -510,7 +510,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 					const USHORT nPalCount = ImplGetDIBColorCount( mhDIB );
 
 					pBuffer->maPalette.SetEntryCount( nPalCount );
-					HMEMCPY( pBuffer->maPalette.ImplGetColorBuffer(), pBI->bmiColors, nPalCount * sizeof( RGBQUAD ) );
+					memcpy( pBuffer->maPalette.ImplGetColorBuffer(), pBI->bmiColors, nPalCount * sizeof( RGBQUAD ) );
 					pBuffer->mpBits = (PBYTE) pBI + *(DWORD*) pBI + nPalCount * sizeof( RGBQUAD );
 				}
 				else if( ( pBIH->biBitCount == 16 ) || ( pBIH->biBitCount == 32 ) )
@@ -550,7 +550,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 
 // ------------------------------------------------------------------
 
-void SalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, BOOL bReadOnly )
+void WinSalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly )
 {
 	if( pBuffer )
 	{
@@ -561,7 +561,7 @@ void SalBitmap::ReleaseBuffer( BitmapBuf
 				PBITMAPINFO 	pBI = (PBITMAPINFO) GlobalLock( mhDIB );
 				const USHORT	nCount = pBuffer->maPalette.GetEntryCount();
 
-				HMEMCPY( pBI->bmiColors, pBuffer->maPalette.ImplGetColorBuffer(), nCount * sizeof( RGBQUAD ) );
+				memcpy( pBI->bmiColors, pBuffer->maPalette.ImplGetColorBuffer(), nCount * sizeof( RGBQUAD ) );
 				GlobalUnlock( mhDIB );
 			}
 
@@ -574,8 +574,8 @@ void SalBitmap::ReleaseBuffer( BitmapBuf
 
 // ------------------------------------------------------------------
 
-void SalBitmap::ImplDecodeRLEBuffer( const BYTE* pSrcBuf, BYTE* pDstBuf,
-									 const Size& rSizePixel, BOOL bRLE4 )
+void WinSalBitmap::ImplDecodeRLEBuffer( const BYTE* pSrcBuf, BYTE* pDstBuf,
+									 const Size& rSizePixel, bool bRLE4 )
 {
 	HPBYTE			pRLE = (HPBYTE) pSrcBuf;
 	HPBYTE			pDIB = (HPBYTE) pDstBuf;
@@ -587,7 +587,7 @@ void SalBitmap::ImplDecodeRLEBuffer( con
 	ULONG			nX = 0;
 	ULONG			i;
 	BYTE			cTmp;
-	BOOL			bEndDecoding = FALSE;
+	bool			bEndDecoding = FALSE;
 
 	if( pRLE && pDIB )
 	{
@@ -618,7 +618,7 @@ void SalBitmap::ImplDecodeRLEBuffer( con
 					}
 					else
 					{
-						HMEMCPY( &pDIB[ nX ], pRLE, nRunByte );
+						memcpy( &pDIB[ nX ], pRLE, nRunByte );
 						pRLE += nRunByte;
 						nX += nRunByte;
 
Index: vcl/win/source/gdi/salgdi.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salgdi.cxx,v
retrieving revision 1.13.112.1
retrieving revision 1.20
diff -u -p -u -r1.13.112.1 -r1.20
--- vcl/win/source/gdi/salgdi.cxx	19 Nov 2003 15:42:24 -0000	1.13.112.1
+++ vcl/win/source/gdi/salgdi.cxx	18 Jun 2004 15:06:40 -0000	1.20
@@ -65,27 +65,30 @@
 #ifndef _SVWIN_H
 #include <tools/svwin.h>
 #endif
-#define _SV_SALGDI_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
+#endif
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include "poly.hxx"
+#ifndef _RTL_STRINGBUF_HXX
+#include <rtl/strbuf.hxx>
 #endif
 
+using namespace rtl;
+
 // =======================================================================
 
 // comment out to prevent use of beziers on GDI functions
@@ -561,7 +564,7 @@ static SalColor ImplGetROPSalColor( SalR
 
 // =======================================================================
 
-void ImplSalInitGraphics( SalGraphicsData* pData )
+void ImplSalInitGraphics( WinSalGraphics* pData )
 {
 	// Beim Printer berechnen wir die minimale Linienstaerke
 	if ( pData->mbPrinter )
@@ -580,7 +583,7 @@ void ImplSalInitGraphics( SalGraphicsDat
 
 // -----------------------------------------------------------------------
 
-void ImplSalDeInitGraphics( SalGraphicsData* pData )
+void ImplSalDeInitGraphics( WinSalGraphics* pData )
 {
 	// Default Objekte selektieren
 	if ( pData->mhDefPen )
@@ -665,12 +668,12 @@ void ImplClearHDCCache( SalData* pData )
 void ImplPreparePolyDraw( bool						bCloseFigures,
                           ULONG 					nPoly,
                           const ULONG* 				pPoints,
-                          const SalPoint* const* 	pPtAry, 
+                          const SalPoint* const* 	pPtAry,
                           const BYTE* const* 		pFlgAry,
                           POINT* 					pWinPointAry,
                           BYTE* 					pWinFlagAry		)
 {
-    ULONG nCurrPoly;    
+    ULONG nCurrPoly;
     for( nCurrPoly=0; nCurrPoly<nPoly; ++nCurrPoly )
     {
         const POINT* pCurrPoint = reinterpret_cast<const POINT*>( *pPtAry++ );
@@ -691,9 +694,9 @@ void ImplPreparePolyDraw( bool						bClo
                 // #102067# Check existence of flag array
                 if( bHaveFlagArray &&
                     ( nCurrPoint + 2 ) < nCurrPoints )
-                { 
+                {
                     BYTE P4( pCurrFlag[ 2 ] );
-                    
+
                     if( ( POLY_CONTROL == pCurrFlag[ 0 ] ) &&
                         ( POLY_CONTROL == pCurrFlag[ 1 ] ) &&
                         ( POLY_NORMAL == P4 || POLY_SMOOTH == P4 || POLY_SYMMTR == P4 ) )
@@ -701,11 +704,11 @@ void ImplPreparePolyDraw( bool						bClo
                         // control point one
                         *pWinPointAry++ = *pCurrPoint++;
                         *pWinFlagAry++  = PT_BEZIERTO;
-                        
+
                         // control point two
                         *pWinPointAry++ = *pCurrPoint++;
                         *pWinFlagAry++  = PT_BEZIERTO;
-                        
+
                         // end point
                         *pWinPointAry++ = *pCurrPoint++;
                         *pWinFlagAry++  = PT_BEZIERTO;
@@ -727,7 +730,7 @@ void ImplPreparePolyDraw( bool						bClo
             if( bCloseFigures )
                 pWinFlagAry[-1] |= PT_CLOSEFIGURE;
         }
-    }    
+    }
 }
 
 // =======================================================================
@@ -762,105 +765,105 @@ void ImplRenderPath( HDC hdc, ULONG nPoi
 
 // =======================================================================
 
-SalGraphics::SalGraphics()
+WinSalGraphics::WinSalGraphics()
 {
     for( int i = 0; i < MAX_FALLBACK; ++i )
-        maGraphicsData.mhFonts[ i ] = 0;
-	maGraphicsData.mhDC 				= 0;
-	maGraphicsData.mhPen				= 0;
-	maGraphicsData.mhBrush				= 0;
-	maGraphicsData.mhRegion 			= 0;
-	maGraphicsData.mhDefPen 			= 0;
-	maGraphicsData.mhDefBrush			= 0;
-	maGraphicsData.mhDefFont			= 0;
-	maGraphicsData.mhDefPal 			= 0;
-	maGraphicsData.mpStdClipRgnData 	= NULL;
-	maGraphicsData.mpLogFont			= NULL;
-	maGraphicsData.mpFontCharSets		= NULL;
-	maGraphicsData.mnFontCharSetCount	= 0;
-	maGraphicsData.mpFontKernPairs		= NULL;
-	maGraphicsData.mnFontKernPairCount	= 0;
-	maGraphicsData.mbFontKernInit		= FALSE;
-	maGraphicsData.mbXORMode			= FALSE;
-	maGraphicsData.mnPenWidth			= GSL_PEN_WIDTH;
+        mhFonts[ i ] = 0;
+	mhDC 				= 0;
+	mhPen				= 0;
+	mhBrush				= 0;
+	mhRegion 			= 0;
+	mhDefPen 			= 0;
+	mhDefBrush			= 0;
+	mhDefFont			= 0;
+	mhDefPal 			= 0;
+	mpStdClipRgnData 	= NULL;
+	mpLogFont			= NULL;
+	mpFontCharSets		= NULL;
+	mnFontCharSetCount	= 0;
+	mpFontKernPairs		= NULL;
+	mnFontKernPairCount	= 0;
+	mbFontKernInit		= FALSE;
+	mbXORMode			= FALSE;
+	mnPenWidth			= GSL_PEN_WIDTH;
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics::~SalGraphics()
+WinSalGraphics::~WinSalGraphics()
 {
 	// free obsolete GDI objekts
     for( int i = 0; i < MAX_FALLBACK; ++i )
-        if( maGraphicsData.mhFonts[ i ] )
-            DeleteFont( maGraphicsData.mhFonts[ i ] );
+        if( mhFonts[ i ] )
+            DeleteFont( mhFonts[ i ] );
 
-	if ( maGraphicsData.mhPen )
+	if ( mhPen )
 	{
-		if ( !maGraphicsData.mbStockPen )
-			DeletePen( maGraphicsData.mhPen );
+		if ( !mbStockPen )
+			DeletePen( mhPen );
 	}
-	if ( maGraphicsData.mhBrush )
+	if ( mhBrush )
 	{
-		if ( !maGraphicsData.mbStockBrush )
-			DeleteBrush( maGraphicsData.mhBrush );
+		if ( !mbStockBrush )
+			DeleteBrush( mhBrush );
 	}
 
-	if ( maGraphicsData.mhRegion )
+	if ( mhRegion )
 	{
-		DeleteRegion( maGraphicsData.mhRegion );
-		maGraphicsData.mhRegion = 0;
+		DeleteRegion( mhRegion );
+		mhRegion = 0;
 	}
 
 	// Cache-Daten zerstoeren
-	if ( maGraphicsData.mpStdClipRgnData )
-		delete [] maGraphicsData.mpStdClipRgnData;
+	if ( mpStdClipRgnData )
+		delete [] mpStdClipRgnData;
 
-	if ( maGraphicsData.mpLogFont )
-		delete maGraphicsData.mpLogFont;
+	if ( mpLogFont )
+		delete mpLogFont;
 
-	if ( maGraphicsData.mpFontCharSets )
-		delete maGraphicsData.mpFontCharSets;
+	if ( mpFontCharSets )
+		delete mpFontCharSets;
 
-	if ( maGraphicsData.mpFontKernPairs )
-		delete maGraphicsData.mpFontKernPairs;
+	if ( mpFontKernPairs )
+		delete mpFontKernPairs;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetResolution( long& rDPIX, long& rDPIY )
+void WinSalGraphics::GetResolution( long& rDPIX, long& rDPIY )
 {
-	rDPIX = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSX );
-	rDPIY = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSY );
+	rDPIX = GetDeviceCaps( mhDC, LOGPIXELSX );
+	rDPIY = GetDeviceCaps( mhDC, LOGPIXELSY );
 
     // #111139# this fixes the symptom of div by zero on startup
-    // however, printing will fail most likely as communication with 
+    // however, printing will fail most likely as communication with
     // the printer seems not to work in this case
     if( !rDPIX || !rDPIY )
-        rDPIX = rDPIY = 600;   
+        rDPIX = rDPIY = 600;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetScreenFontResolution( long& rDPIX, long& rDPIY )
+void WinSalGraphics::GetScreenFontResolution( long& rDPIX, long& rDPIY )
 {
-	rDPIX = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSX );
-	rDPIY = GetDeviceCaps( maGraphicsData.mhDC, LOGPIXELSY );
+	rDPIX = GetDeviceCaps( mhDC, LOGPIXELSX );
+	rDPIY = GetDeviceCaps( mhDC, LOGPIXELSY );
 }
 
 // -----------------------------------------------------------------------
 
-USHORT SalGraphics::GetBitCount()
+USHORT WinSalGraphics::GetBitCount()
 {
-	return (USHORT)GetDeviceCaps( maGraphicsData.mhDC, BITSPIXEL );
+	return (USHORT)GetDeviceCaps( mhDC, BITSPIXEL );
 }
 
 // -----------------------------------------------------------------------
 
-long SalGraphics::GetGraphicsWidth()
+long WinSalGraphics::GetGraphicsWidth()
 {
-    if( maGraphicsData.mhWnd && IsWindow( maGraphicsData.mhWnd ) )
+    if( mhWnd && IsWindow( mhWnd ) )
     {
-        SalFrame* pFrame = GetWindowPtr( maGraphicsData.mhWnd );
+        WinSalFrame* pFrame = GetWindowPtr( mhWnd );
         if( pFrame )
         {
             if( pFrame->maGeometry.nWidth )
@@ -869,7 +872,7 @@ long SalGraphics::GetGraphicsWidth()
             {
                 // TODO: perhaps not needed, maGeometry should always be up-to-date
                 RECT aRect;
-                GetClientRect( maGraphicsData.mhWnd, &aRect );
+                GetClientRect( mhWnd, &aRect );
                 return aRect.right;
             }
         }
@@ -880,64 +883,64 @@ long SalGraphics::GetGraphicsWidth()
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::ResetClipRegion()
+void WinSalGraphics::ResetClipRegion()
 {
-	if ( maGraphicsData.mhRegion )
+	if ( mhRegion )
 	{
-		DeleteRegion( maGraphicsData.mhRegion );
-		maGraphicsData.mhRegion = 0;
+		DeleteRegion( mhRegion );
+		mhRegion = 0;
 	}
 
-	SelectClipRgn( maGraphicsData.mhDC, 0 );
+	SelectClipRgn( mhDC, 0 );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::BeginSetClipRegion( ULONG nRectCount )
+void WinSalGraphics::BeginSetClipRegion( ULONG nRectCount )
 {
-	if ( maGraphicsData.mhRegion )
+	if ( mhRegion )
 	{
-		DeleteRegion( maGraphicsData.mhRegion );
-		maGraphicsData.mhRegion = 0;
+		DeleteRegion( mhRegion );
+		mhRegion = 0;
 	}
 
 	ULONG nRectBufSize = sizeof(RECT)*nRectCount;
 	if ( nRectCount < SAL_CLIPRECT_COUNT )
 	{
-		if ( !maGraphicsData.mpStdClipRgnData )
-			maGraphicsData.mpStdClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+(SAL_CLIPRECT_COUNT*sizeof(RECT))];
-		maGraphicsData.mpClipRgnData = maGraphicsData.mpStdClipRgnData;
+		if ( !mpStdClipRgnData )
+			mpStdClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+(SAL_CLIPRECT_COUNT*sizeof(RECT))];
+		mpClipRgnData = mpStdClipRgnData;
 	}
 	else
-		maGraphicsData.mpClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+nRectBufSize];
-	maGraphicsData.mpClipRgnData->rdh.dwSize	= sizeof( RGNDATAHEADER );
-	maGraphicsData.mpClipRgnData->rdh.iType 	= RDH_RECTANGLES;
-	maGraphicsData.mpClipRgnData->rdh.nCount	= nRectCount;
-	maGraphicsData.mpClipRgnData->rdh.nRgnSize	= nRectBufSize;
-	SetRectEmpty( &(maGraphicsData.mpClipRgnData->rdh.rcBound) );
-	maGraphicsData.mpNextClipRect			= (RECT*)(&(maGraphicsData.mpClipRgnData->Buffer));
-	maGraphicsData.mbFirstClipRect			= TRUE;
+		mpClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+nRectBufSize];
+	mpClipRgnData->rdh.dwSize	= sizeof( RGNDATAHEADER );
+	mpClipRgnData->rdh.iType 	= RDH_RECTANGLES;
+	mpClipRgnData->rdh.nCount	= nRectCount;
+	mpClipRgnData->rdh.nRgnSize	= nRectBufSize;
+	SetRectEmpty( &(mpClipRgnData->rdh.rcBound) );
+	mpNextClipRect			= (RECT*)(&(mpClipRgnData->Buffer));
+	mbFirstClipRect			= TRUE;
 }
 
 
 // -----------------------------------------------------------------------
 
-BOOL SalGraphics::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice* )
+BOOL WinSalGraphics::unionClipRegion( long nX, long nY, long nWidth, long nHeight )
 {
 	if ( nWidth && nHeight )
 	{
-		RECT*		pRect = maGraphicsData.mpNextClipRect;
-		RECT*		pBoundRect = &(maGraphicsData.mpClipRgnData->rdh.rcBound);
+		RECT*		pRect = mpNextClipRect;
+		RECT*		pBoundRect = &(mpClipRgnData->rdh.rcBound);
 		long		nRight = nX + nWidth;
 		long		nBottom = nY + nHeight;
 
-		if ( maGraphicsData.mbFirstClipRect )
+		if ( mbFirstClipRect )
 		{
 			pBoundRect->left	= nX;
 			pBoundRect->top 	= nY;
 			pBoundRect->right	= nRight;
 			pBoundRect->bottom	= nBottom;
-			maGraphicsData.mbFirstClipRect = FALSE;
+			mbFirstClipRect = FALSE;
 		}
 		else
 		{
@@ -958,12 +961,12 @@ BOOL SalGraphics::UnionClipRegion( long 
 		pRect->top		= (int)nY;
 		pRect->right	= (int)nRight;
 		pRect->bottom	= (int)nBottom;
-		maGraphicsData.mpNextClipRect++;
+		mpNextClipRect++;
 	}
 	else
 	{
-		maGraphicsData.mpClipRgnData->rdh.nCount--;
-		maGraphicsData.mpClipRgnData->rdh.nRgnSize -= sizeof( RECT );
+		mpClipRgnData->rdh.nCount--;
+		mpClipRgnData->rdh.nRgnSize -= sizeof( RECT );
 	}
 
 	return TRUE;
@@ -971,73 +974,73 @@ BOOL SalGraphics::UnionClipRegion( long 
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::EndSetClipRegion()
+void WinSalGraphics::EndSetClipRegion()
 {
 	// create clip region from ClipRgnData
-	if ( maGraphicsData.mpClipRgnData->rdh.nCount == 1 )
+	if ( mpClipRgnData->rdh.nCount == 1 )
 	{
-		RECT* pRect = &(maGraphicsData.mpClipRgnData->rdh.rcBound);
-		maGraphicsData.mhRegion = CreateRectRgn( pRect->left, pRect->top,
+		RECT* pRect = &(mpClipRgnData->rdh.rcBound);
+		mhRegion = CreateRectRgn( pRect->left, pRect->top,
 												 pRect->right, pRect->bottom );
 	}
 	else
 	{
-		ULONG nSize = maGraphicsData.mpClipRgnData->rdh.nRgnSize+sizeof(RGNDATAHEADER);
-		maGraphicsData.mhRegion = ExtCreateRegion( NULL, nSize, maGraphicsData.mpClipRgnData );
+		ULONG nSize = mpClipRgnData->rdh.nRgnSize+sizeof(RGNDATAHEADER);
+		mhRegion = ExtCreateRegion( NULL, nSize, mpClipRgnData );
 
 		// if ExtCreateRegion(...) is not supported
-		if( !maGraphicsData.mhRegion )
+		if( !mhRegion )
 		{
-			RGNDATAHEADER* pHeader = (RGNDATAHEADER*) maGraphicsData.mpClipRgnData;
+			RGNDATAHEADER* pHeader = (RGNDATAHEADER*) mpClipRgnData;
 
 			if( pHeader->nCount )
 			{
-				RECT* pRect = (RECT*) maGraphicsData.mpClipRgnData->Buffer;
-				maGraphicsData.mhRegion = CreateRectRgn( pRect->left, pRect->top, pRect->right, pRect->bottom );
+				RECT* pRect = (RECT*) mpClipRgnData->Buffer;
+				mhRegion = CreateRectRgn( pRect->left, pRect->top, pRect->right, pRect->bottom );
 				pRect++;
 
 				for( ULONG n = 1; n < pHeader->nCount; n++, pRect++ )
 				{
 					HRGN hRgn = CreateRectRgn( pRect->left, pRect->top, pRect->right, pRect->bottom );
-					CombineRgn( maGraphicsData.mhRegion, maGraphicsData.mhRegion, hRgn, RGN_OR );
+					CombineRgn( mhRegion, mhRegion, hRgn, RGN_OR );
 					DeleteRegion( hRgn );
 				}
 			}
 		}
 
-		if ( maGraphicsData.mpClipRgnData != maGraphicsData.mpStdClipRgnData )
-			delete [] maGraphicsData.mpClipRgnData;
+		if ( mpClipRgnData != mpStdClipRgnData )
+			delete [] mpClipRgnData;
 	}
 
-	SelectClipRgn( maGraphicsData.mhDC, maGraphicsData.mhRegion );
+	SelectClipRgn( mhDC, mhRegion );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetLineColor()
+void WinSalGraphics::SetLineColor()
 {
 	// create and select new pen
 	HPEN hNewPen = GetStockPen( NULL_PEN );
-	HPEN hOldPen = SelectPen( maGraphicsData.mhDC, hNewPen );
+	HPEN hOldPen = SelectPen( mhDC, hNewPen );
 
 	// destory or save old pen
-	if ( maGraphicsData.mhPen )
+	if ( mhPen )
 	{
-		if ( !maGraphicsData.mbStockPen )
-			DeletePen( maGraphicsData.mhPen );
+		if ( !mbStockPen )
+			DeletePen( mhPen );
 	}
 	else
-		maGraphicsData.mhDefPen = hOldPen;
+		mhDefPen = hOldPen;
 
 	// set new data
-	maGraphicsData.mhPen		= hNewPen;
-	maGraphicsData.mbPen		= FALSE;
-	maGraphicsData.mbStockPen	= TRUE;
+	mhPen		= hNewPen;
+	mbPen		= FALSE;
+	mbStockPen	= TRUE;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetLineColor( SalColor nSalColor )
+void WinSalGraphics::SetLineColor( SalColor nSalColor )
 {
 	COLORREF	nPenColor = PALETTERGB( SALCOLOR_RED( nSalColor ),
 										SALCOLOR_GREEN( nSalColor ),
@@ -1047,7 +1050,7 @@ void SalGraphics::SetLineColor( SalColor
 
 	// search for stock pen (only screen, because printer have problems,
 	// when we use stock objects)
-	if ( !maGraphicsData.mbPrinter )
+	if ( !mbPrinter )
 	{
 		SalData* pSalData = GetSalData();
 		for ( USHORT i = 0; i < pSalData->mnStockPenCount; i++ )
@@ -1064,61 +1067,61 @@ void SalGraphics::SetLineColor( SalColor
 	// create new pen
 	if ( !hNewPen )
 	{
-		if ( !maGraphicsData.mbPrinter )
+		if ( !mbPrinter )
 		{
 			if ( GetSalData()->mhDitherPal && ImplIsSysColorEntry( nSalColor ) )
 				nPenColor = PALRGB_TO_RGB( nPenColor );
 		}
 
-		hNewPen = CreatePen( PS_SOLID, maGraphicsData.mnPenWidth, nPenColor );
+		hNewPen = CreatePen( PS_SOLID, mnPenWidth, nPenColor );
 		bStockPen = FALSE;
 	}
 
 	// select new pen
-	HPEN hOldPen = SelectPen( maGraphicsData.mhDC, hNewPen );
+	HPEN hOldPen = SelectPen( mhDC, hNewPen );
 
 	// destory or save old pen
-	if ( maGraphicsData.mhPen )
+	if ( mhPen )
 	{
-		if ( !maGraphicsData.mbStockPen )
-			DeletePen( maGraphicsData.mhPen );
+		if ( !mbStockPen )
+			DeletePen( mhPen );
 	}
 	else
-		maGraphicsData.mhDefPen = hOldPen;
+		mhDefPen = hOldPen;
 
 	// set new data
-	maGraphicsData.mnPenColor	= nPenColor;
-	maGraphicsData.mhPen		= hNewPen;
-	maGraphicsData.mbPen		= TRUE;
-	maGraphicsData.mbStockPen	= bStockPen;
+	mnPenColor	= nPenColor;
+	mhPen		= hNewPen;
+	mbPen		= TRUE;
+	mbStockPen	= bStockPen;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetFillColor()
+void WinSalGraphics::SetFillColor()
 {
 	// create and select new brush
 	HBRUSH hNewBrush = GetStockBrush( NULL_BRUSH );
-	HBRUSH hOldBrush = SelectBrush( maGraphicsData.mhDC, hNewBrush );
+	HBRUSH hOldBrush = SelectBrush( mhDC, hNewBrush );
 
 	// destory or save old brush
-	if ( maGraphicsData.mhBrush )
+	if ( mhBrush )
 	{
-		if ( !maGraphicsData.mbStockBrush )
-			DeleteBrush( maGraphicsData.mhBrush );
+		if ( !mbStockBrush )
+			DeleteBrush( mhBrush );
 	}
 	else
-		maGraphicsData.mhDefBrush = hOldBrush;
+		mhDefBrush = hOldBrush;
 
 	// set new data
-	maGraphicsData.mhBrush		= hNewBrush;
-	maGraphicsData.mbBrush		= FALSE;
-	maGraphicsData.mbStockBrush = TRUE;
+	mhBrush		= hNewBrush;
+	mbBrush		= FALSE;
+	mbStockBrush = TRUE;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetFillColor( SalColor nSalColor )
+void WinSalGraphics::SetFillColor( SalColor nSalColor )
 {
 	SalData*	pSalData	= GetSalData();
 	BYTE		nRed		= SALCOLOR_RED( nSalColor );
@@ -1130,7 +1133,7 @@ void SalGraphics::SetFillColor( SalColor
 
 	// search for stock brush (only screen, because printer have problems,
 	// when we use stock objects)
-	if ( !maGraphicsData.mbPrinter )
+	if ( !mbPrinter )
 	{
 		for ( USHORT i = 0; i < pSalData->mnStockBrushCount; i++ )
 		{
@@ -1146,7 +1149,7 @@ void SalGraphics::SetFillColor( SalColor
 	// create new brush
 	if ( !hNewBrush )
 	{
-		if ( maGraphicsData.mbPrinter || !pSalData->mhDitherDIB )
+		if ( mbPrinter || !pSalData->mhDitherDIB )
 			hNewBrush = CreateSolidBrush( nBrushColor );
 		else
 		{
@@ -1202,92 +1205,92 @@ void SalGraphics::SetFillColor( SalColor
 	}
 
 	// select new brush
-	HBRUSH hOldBrush = SelectBrush( maGraphicsData.mhDC, hNewBrush );
+	HBRUSH hOldBrush = SelectBrush( mhDC, hNewBrush );
 
 	// destory or save old brush
-	if ( maGraphicsData.mhBrush )
+	if ( mhBrush )
 	{
-		if ( !maGraphicsData.mbStockBrush )
-			DeleteBrush( maGraphicsData.mhBrush );
+		if ( !mbStockBrush )
+			DeleteBrush( mhBrush );
 	}
 	else
-		maGraphicsData.mhDefBrush = hOldBrush;
+		mhDefBrush = hOldBrush;
 
 	// set new data
-	maGraphicsData.mnBrushColor = nBrushColor;
-	maGraphicsData.mhBrush		= hNewBrush;
-	maGraphicsData.mbBrush		= FALSE;
-	maGraphicsData.mbStockBrush = bStockBrush;
+	mnBrushColor = nBrushColor;
+	mhBrush		= hNewBrush;
+	mbBrush		= FALSE;
+	mbStockBrush = bStockBrush;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetXORMode( BOOL bSet )
+void WinSalGraphics::SetXORMode( BOOL bSet )
 {
-	maGraphicsData.mbXORMode = bSet;
-	::SetROP2( maGraphicsData.mhDC, bSet ? R2_XORPEN : R2_COPYPEN );
+	mbXORMode = bSet;
+	::SetROP2( mhDC, bSet ? R2_XORPEN : R2_COPYPEN );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetROPLineColor( SalROPColor nROPColor )
+void WinSalGraphics::SetROPLineColor( SalROPColor nROPColor )
 {
 	SetLineColor( ImplGetROPSalColor( nROPColor ) );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::SetROPFillColor( SalROPColor nROPColor )
+void WinSalGraphics::SetROPFillColor( SalROPColor nROPColor )
 {
 	SetFillColor( ImplGetROPSalColor( nROPColor ) );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPixel( long nX, long nY, const OutputDevice* )
+void WinSalGraphics::drawPixel( long nX, long nY )
 {
-	if ( maGraphicsData.mbXORMode )
+	if ( mbXORMode )
 	{
-		HBRUSH	hBrush = CreateSolidBrush( maGraphicsData.mnPenColor );
-		HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
-		PatBlt( maGraphicsData.mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		HBRUSH	hBrush = CreateSolidBrush( mnPenColor );
+		HBRUSH	hOldBrush = SelectBrush( mhDC, hBrush );
+		PatBlt( mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
+		SelectBrush( mhDC, hOldBrush );
 		DeleteBrush( hBrush );
 	}
 	else
-		SetPixel( maGraphicsData.mhDC, (int)nX, (int)nY, maGraphicsData.mnPenColor );
+		SetPixel( mhDC, (int)nX, (int)nY, mnPenColor );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice*  )
+void WinSalGraphics::drawPixel( long nX, long nY, SalColor nSalColor )
 {
 	COLORREF nCol = PALETTERGB( SALCOLOR_RED( nSalColor ),
 								SALCOLOR_GREEN( nSalColor ),
 								SALCOLOR_BLUE( nSalColor ) );
 
-	if ( !maGraphicsData.mbPrinter &&
+	if ( !mbPrinter &&
 		 GetSalData()->mhDitherPal &&
 		 ImplIsSysColorEntry( nSalColor ) )
 		nCol = PALRGB_TO_RGB( nCol );
 
-	if ( maGraphicsData.mbXORMode )
+	if ( mbXORMode )
 	{
 		HBRUSH	hBrush = CreateSolidBrush( nCol );
-		HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
-		PatBlt( maGraphicsData.mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		HBRUSH	hOldBrush = SelectBrush( mhDC, hBrush );
+		PatBlt( mhDC, (int)nX, (int)nY, (int)1, (int)1, PATINVERT );
+		SelectBrush( mhDC, hOldBrush );
 		DeleteBrush( hBrush );
 	}
 	else
-		::SetPixel( maGraphicsData.mhDC, (int)nX, (int)nY, nCol );
+		::SetPixel( mhDC, (int)nX, (int)nY, nCol );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice* )
+void WinSalGraphics::drawLine( long nX1, long nY1, long nX2, long nY2 )
 {
-	MoveToEx( maGraphicsData.mhDC, (int)nX1, (int)nY1, NULL );
+	MoveToEx( mhDC, (int)nX1, (int)nY1, NULL );
 
 	// we must paint the endpoint
 	int bPaintEnd = TRUE;
@@ -1308,33 +1311,33 @@ void SalGraphics::DrawLine( long nX1, lo
 			nX2--;
 	}
 
-	LineTo( maGraphicsData.mhDC, (int)nX2, (int)nY2 );
+	LineTo( mhDC, (int)nX2, (int)nY2 );
 
-	if ( bPaintEnd && !maGraphicsData.mbPrinter )
+	if ( bPaintEnd && !mbPrinter )
 	{
-		if ( maGraphicsData.mbXORMode )
+		if ( mbXORMode )
 		{
-			HBRUSH	hBrush = CreateSolidBrush( maGraphicsData.mnPenColor );
-			HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
-			PatBlt( maGraphicsData.mhDC, (int)nX2, (int)nY2, (int)1, (int)1, PATINVERT );
-			SelectBrush( maGraphicsData.mhDC, hOldBrush );
+			HBRUSH	hBrush = CreateSolidBrush( mnPenColor );
+			HBRUSH	hOldBrush = SelectBrush( mhDC, hBrush );
+			PatBlt( mhDC, (int)nX2, (int)nY2, (int)1, (int)1, PATINVERT );
+			SelectBrush( mhDC, hOldBrush );
 			DeleteBrush( hBrush );
 		}
 		else
-			SetPixel( maGraphicsData.mhDC, (int)nX2, (int)nY2, maGraphicsData.mnPenColor );
+			SetPixel( mhDC, (int)nX2, (int)nY2, mnPenColor );
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice* )
+void WinSalGraphics::drawRect( long nX, long nY, long nWidth, long nHeight )
 {
-	if ( !maGraphicsData.mbPen )
+	if ( !mbPen )
 	{
-		if ( !maGraphicsData.mbPrinter )
+		if ( !mbPrinter )
 		{
-			PatBlt( maGraphicsData.mhDC, (int)nX, (int)nY, (int)nWidth, (int)nHeight,
-					maGraphicsData.mbXORMode ? PATINVERT : PATCOPY );
+			PatBlt( mhDC, (int)nX, (int)nY, (int)nWidth, (int)nHeight,
+					mbXORMode ? PATINVERT : PATCOPY );
 		}
 		else
 		{
@@ -1343,47 +1346,47 @@ void SalGraphics::DrawRect( long nX, lon
 			aWinRect.top	= nY;
 			aWinRect.right	= nX+nWidth;
 			aWinRect.bottom = nY+nHeight;
-			::FillRect( maGraphicsData.mhDC, &aWinRect, maGraphicsData.mhBrush );
+			::FillRect( mhDC, &aWinRect, mhBrush );
 		}
 	}
 	else
-		WIN_Rectangle( maGraphicsData.mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
+		WIN_Rectangle( mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice* )
+void WinSalGraphics::drawPolyLine( ULONG nPoints, const SalPoint* pPtAry )
 {
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyLine(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyLine(): POINT != SalPoint" );
 
 	POINT* pWinPtAry = (POINT*)pPtAry;
 	// Wegen Windows 95 und der Beschraenkung auf eine maximale Anzahl
 	// von Punkten
-	if ( !Polyline( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-		Polyline( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+	if ( !Polyline( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+		Polyline( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice* )
+void WinSalGraphics::drawPolygon( ULONG nPoints, const SalPoint* pPtAry )
 {
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolygon(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolygon(): POINT != SalPoint" );
 
 	POINT* pWinPtAry = (POINT*)pPtAry;
 	// Wegen Windows 95 und der Beschraenkung auf eine maximale Anzahl
 	// von Punkten
-	if ( !WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-		WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+	if ( !WIN_Polygon( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+		WIN_Polygon( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints,
-								   PCONSTSALPOINT* pPtAry, const OutputDevice* )
+void WinSalGraphics::drawPolyPolygon( ULONG nPoly, const ULONG* pPoints,
+								   PCONSTSALPOINT* pPtAry )
 {
 	UINT	aWinPointAry[SAL_POLYPOLYCOUNT_STACKBUF];
 	UINT*	pWinPointAry;
@@ -1411,7 +1414,7 @@ void SalGraphics::DrawPolyPolygon( ULONG
 		pWinPointAryAry = new POINT[nPolyPolyPoints];
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyPolygon(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyPolygon(): POINT != SalPoint" );
 	const SalPoint* pPolyAry;
 	UINT			n = 0;
 	for ( i = 0; i < (UINT)nPoly; i++ )
@@ -1423,7 +1426,7 @@ void SalGraphics::DrawPolyPolygon( ULONG
 		n += nPoints;
 	}
 
-	if ( !WIN_PolyPolygon( maGraphicsData.mhDC, pWinPointAryAry, (int*)pWinPointAry, (UINT)nPoly ) &&
+	if ( !WIN_PolyPolygon( mhDC, pWinPointAryAry, (int*)pWinPointAry, (UINT)nPoly ) &&
 		 (nPolyPolyPoints > MAX_64KSALPOINTS) )
 	{
 		nPolyPolyPoints  = 0;
@@ -1438,9 +1441,9 @@ void SalGraphics::DrawPolyPolygon( ULONG
 		if ( pWinPointAry[(UINT)nPoly] > MAX_64KSALPOINTS )
 			pWinPointAry[(UINT)nPoly] = MAX_64KSALPOINTS;
 		if ( nPoly == 1 )
-			WIN_Polygon( maGraphicsData.mhDC, pWinPointAryAry, *pWinPointAry );
+			WIN_Polygon( mhDC, pWinPointAryAry, *pWinPointAry );
 		else
-			WIN_PolyPolygon( maGraphicsData.mhDC, pWinPointAryAry, (int*)pWinPointAry, nPoly );
+			WIN_PolyPolygon( mhDC, pWinPointAryAry, (int*)pWinPointAry, nPoly );
 	}
 
 	if ( pWinPointAry != aWinPointAry )
@@ -1455,14 +1458,14 @@ void SalGraphics::DrawPolyPolygon( ULONG
 
 // -----------------------------------------------------------------------
 
-sal_Bool SalGraphics::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool WinSalGraphics::drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
 #ifdef USE_GDI_BEZIERS
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyLineBezier(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyLineBezier(): POINT != SalPoint" );
 
-    ImplRenderPath( maGraphicsData.mhDC, nPoints, pPtAry, pFlgAry );
+    ImplRenderPath( mhDC, nPoints, pPtAry, pFlgAry );
 
     return sal_True;
 #else
@@ -1472,12 +1475,12 @@ sal_Bool SalGraphics::DrawPolyLineBezier
 
 // -----------------------------------------------------------------------
 
-sal_Bool SalGraphics::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool WinSalGraphics::drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
 #ifdef USE_GDI_BEZIERS
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolygonBezier(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolygonBezier(): POINT != SalPoint" );
 
     POINT	aStackAry1[SAL_POLY_STACKBUF];
     BYTE	aStackAry2[SAL_POLY_STACKBUF];
@@ -1498,13 +1501,13 @@ sal_Bool SalGraphics::DrawPolygonBezier(
 
     sal_Bool bRet( sal_False );
 
-    if( BeginPath( maGraphicsData.mhDC ) )
+    if( BeginPath( mhDC ) )
     {
-        PolyDraw(maGraphicsData.mhDC, pWinPointAry, pWinFlagAry, nPoints);
+        PolyDraw(mhDC, pWinPointAry, pWinFlagAry, nPoints);
 
-        if( EndPath( maGraphicsData.mhDC ) )
+        if( EndPath( mhDC ) )
         {
-            if( StrokeAndFillPath( maGraphicsData.mhDC ) )
+            if( StrokeAndFillPath( mhDC ) )
                 bRet = sal_True;
         }
     }
@@ -1514,7 +1517,7 @@ sal_Bool SalGraphics::DrawPolygonBezier(
         delete [] pWinPointAry;
         delete [] pWinFlagAry;
     }
-    
+
     return bRet;
 #else
     return sal_False;
@@ -1523,13 +1526,13 @@ sal_Bool SalGraphics::DrawPolygonBezier(
 
 // -----------------------------------------------------------------------
 
-sal_Bool SalGraphics::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
-                                             const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice* )
+sal_Bool WinSalGraphics::drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+                                             const SalPoint* const* pPtAry, const BYTE* const* pFlgAry )
 {
 #ifdef USE_GDI_BEZIERS
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyPolygonBezier(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyPolygonBezier(): POINT != SalPoint" );
 
     ULONG nCurrPoly, nTotalPoints;
     const ULONG* pCurrPoints = pPoints;
@@ -1555,13 +1558,13 @@ sal_Bool SalGraphics::DrawPolyPolygonBez
 
     sal_Bool bRet( sal_False );
 
-    if( BeginPath( maGraphicsData.mhDC ) )
+    if( BeginPath( mhDC ) )
     {
-        PolyDraw(maGraphicsData.mhDC, pWinPointAry, pWinFlagAry, nTotalPoints);
+        PolyDraw(mhDC, pWinPointAry, pWinFlagAry, nTotalPoints);
 
-        if( EndPath( maGraphicsData.mhDC ) )
+        if( EndPath( mhDC ) )
         {
-            if( StrokeAndFillPath( maGraphicsData.mhDC ) )
+            if( StrokeAndFillPath( mhDC ) )
                 bRet = sal_True;
         }
     }
@@ -1571,7 +1574,7 @@ sal_Bool SalGraphics::DrawPolyPolygonBez
         delete [] pWinPointAry;
         delete [] pWinFlagAry;
     }
-    
+
     return bRet;
 #else
     return sal_False;
@@ -1588,7 +1591,8 @@ static BYTE* ImplSearchEntry( BYTE* pSou
 {
 	while ( nComp-- >= nSize )
 	{
-		for ( ULONG i = 0; i < nSize; i++ )
+		ULONG i;
+		for ( i = 0; i < nSize; i++ )
 		{
 			if ( ( pSource[i]&~0x20 ) != ( pDest[i]&~0x20 ) )
 				break;
@@ -1613,7 +1617,8 @@ static BOOL ImplGetBoundingBox( double* 
 		if ( nSizeLeft > 100 )
 			nSizeLeft = 100;	// only 100 bytes following the bounding box will be checked
 
-		for ( int i = 0; ( i < 4 ) && nSizeLeft; i++ )
+		int i;
+		for ( i = 0; ( i < 4 ) && nSizeLeft; i++ )
 		{
 			int 	nDivision = 1;
 			BOOL	bDivision = FALSE;
@@ -1661,37 +1666,28 @@ static BOOL ImplGetBoundingBox( double* 
 	return bRetValue;
 }
 
-inline void ImplWriteDouble( BYTE** pBuf, double nNumb )
-{
-	*pBuf += sprintf( (char*)*pBuf, "%f", nNumb );
-	*(*pBuf)++ = ' ';
-}
-
-inline void ImplWriteString( BYTE** pBuf, const char* sString )
-{
-	strcpy( (char*)*pBuf, sString );
-	*pBuf += strlen( sString );
-}
-
-BOOL SalGraphics::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice* )
+BOOL WinSalGraphics::drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize )
 {
 	BOOL bRetValue = FALSE;
 
-	if ( maGraphicsData.mbPrinter )
+	if ( mbPrinter )
 	{
 		int nEscape = POSTSCRIPT_PASSTHROUGH;
 
-		if ( Escape( maGraphicsData.mhDC, QUERYESCSUPPORT, sizeof( int ), ( LPSTR )&nEscape, 0 ) )
+		if ( Escape( mhDC, QUERYESCSUPPORT, sizeof( int ), ( LPSTR )&nEscape, 0 ) )
 		{
-			BYTE* pBuf = new BYTE[ POSTSCRIPT_BUFSIZE ];
-
 			double	nBoundingBox[4];
 
-			if ( pBuf && ImplGetBoundingBox( nBoundingBox, (BYTE*)pPtr, nSize ) )
+			if ( ImplGetBoundingBox( nBoundingBox, (BYTE*)pPtr, nSize ) )
 			{
+                OStringBuffer aBuf( POSTSCRIPT_BUFSIZE );
+
+                // reserve place for a USHORT
+                aBuf.append( "aa" );
+
                 // #107797# Write out EPS encapsulation header
                 // ----------------------------------------------------------------------------------
-               
+
                 // directly taken from the PLRM 3.0, p. 726. Note:
                 // this will definitely cause problems when
                 // recursively creating and embedding PostScript files
@@ -1700,43 +1696,92 @@ BOOL SalGraphics::DrawEPS( long nX, long
                 // op_count_salWin). Currently, I have no idea on how to
                 // work around that, except from scanning and
                 // interpreting the EPS for unused identifiers.
-				BYTE*	pTemp = pBuf + 2;		// +2 because we want to insert the size later
-				ImplWriteString( &pTemp, "\n\n/b4_Inc_state_salWin save def\n" );
-				ImplWriteString( &pTemp, "/dict_count_salWin countdictstack def\n" );
-				ImplWriteString( &pTemp, "/op_count_salWin count 1 sub def\n" );
-				ImplWriteString( &pTemp, "userdict begin\n" );
-				ImplWriteString( &pTemp, "/showpage {} def\n" );
-				ImplWriteString( &pTemp, "0 setgray 0 setlinecap\n" );
-				ImplWriteString( &pTemp, "1 setlinewidth 0 setlinejoin\n" );
-				ImplWriteString( &pTemp, "10 setmiterlimit [] 0 setdash newpath\n" );
-				ImplWriteString( &pTemp, "/languagelevel where\n" );
-				ImplWriteString( &pTemp, "{\n" );
-				ImplWriteString( &pTemp, "  pop languagelevel\n" );
-				ImplWriteString( &pTemp, "  1 ne\n" );
-				ImplWriteString( &pTemp, "  {\n" );
-				ImplWriteString( &pTemp, "    false setstrokeadjust false setoverprint\n" ); 
-				ImplWriteString( &pTemp, "  } if\n" );
-				ImplWriteString( &pTemp, "} if\n\n" );
-				*((USHORT*)pBuf) = (USHORT)( pTemp - pBuf - 2 );
-				Escape ( maGraphicsData.mhDC, nEscape, pTemp - pBuf, (LPTSTR)((BYTE*)pBuf), 0 );
-                
+
+                // append the real text
+                aBuf.append( "\n\n/b4_Inc_state_salWin save def\n"
+                             "/dict_count_salWin countdictstack def\n"
+                             "/op_count_salWin count 1 sub def\n"
+                             "userdict begin\n"
+                             "/showpage {} def\n"
+                             "0 setgray 0 setlinecap\n"
+                             "1 setlinewidth 0 setlinejoin\n"
+                             "10 setmiterlimit [] 0 setdash newpath\n"
+                             "/languagelevel where\n"
+                             "{\n"
+                             "  pop languagelevel\n"
+                             "  1 ne\n"
+                             "  {\n"
+                             "    false setstrokeadjust false setoverprint\n"
+                             "  } if\n"
+                             "} if\n\n" );
+
+
+                // #i10737# Apply clipping manually
+                // ----------------------------------------------------------------------------------
+
+                // Windows seems to ignore any clipping at the HDC,
+                // when followed by a POSTSCRIPT_PASSTHROUGH
+
+                // Check whether we've got a clipping, consisting of
+                // exactly one rect (other cases should be, but aren't
+                // handled currently)
+
+                // TODO: Handle more than one rectangle here (take
+                // care, the buffer can handle only POSTSCRIPT_BUFSIZE
+                // characters!)
+                if ( mhRegion != 0 &&
+                     mpStdClipRgnData != NULL &&
+                     mpClipRgnData == mpStdClipRgnData &&
+                     mpClipRgnData->rdh.nCount == 1 )
+                {
+                    RECT* pRect = &(mpClipRgnData->rdh.rcBound);
+
+                    aBuf.append( "\nnewpath\n" );
+                    aBuf.append( pRect->left );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->top );
+                    aBuf.append( " moveto\n" );
+                    aBuf.append( pRect->right );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->top );
+                    aBuf.append( " lineto\n" );
+                    aBuf.append( pRect->right );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->bottom );
+                    aBuf.append( " lineto\n" );
+                    aBuf.append( pRect->left );
+                    aBuf.append( " " );
+                    aBuf.append( pRect->bottom );
+                    aBuf.append( " lineto\n"
+                                 "closepath\n"
+                                 "clip\n"
+                                 "newpath\n" );
+                }
+
+                // #107797# Write out buffer
+                // ----------------------------------------------------------------------------------
+				*((USHORT*)aBuf.getStr()) = (USHORT)( aBuf.getLength() - 2 );
+				Escape ( mhDC, nEscape, aBuf.getLength(), (LPTSTR)aBuf.getStr(), 0 );
+
 
                 // #107797# Write out EPS transformation code
                 // ----------------------------------------------------------------------------------
 				double	dM11 = nWidth / ( nBoundingBox[2] - nBoundingBox[0] );
 				double	dM22 = nHeight / (nBoundingBox[1] - nBoundingBox[3] );
-				pTemp = pBuf + 2;		// +2 because we want to insert the size later
-				ImplWriteString( &pTemp, "\n\n[ " );
-				ImplWriteDouble( &pTemp, dM11 );
-				ImplWriteDouble( &pTemp, 0 );
-				ImplWriteDouble( &pTemp, 0 );
-				ImplWriteDouble( &pTemp, dM22 );
-				ImplWriteDouble( &pTemp, nX - ( dM11 * nBoundingBox[0] ) );
-				ImplWriteDouble( &pTemp, nY - ( dM22 * nBoundingBox[3] ) );
-				ImplWriteString( &pTemp, "] concat\n" );
-				ImplWriteString( &pTemp, "%%BeginDocument:\n" );
-				*((USHORT*)pBuf) = (USHORT)( pTemp - pBuf - 2 );
-				Escape ( maGraphicsData.mhDC, nEscape, pTemp - pBuf, (LPTSTR)((BYTE*)pBuf), 0 );
+                // reserve a USHORT again
+                aBuf.setLength( 2 );
+                aBuf.append( "\n\n[" );
+                aBuf.append( dM11 );
+                aBuf.append( " 0 0 " );
+                aBuf.append( dM22 );
+                aBuf.append( ' ' );
+                aBuf.append( nX - ( dM11 * nBoundingBox[0] ) );
+                aBuf.append( ' ' );
+                aBuf.append( nY - ( dM22 * nBoundingBox[3] ) );
+                aBuf.append( "] concat\n"
+                             "%%BeginDocument:\n" );
+				*((USHORT*)aBuf.getStr()) = (USHORT)( aBuf.getLength() - 2 );
+				Escape ( mhDC, nEscape, aBuf.getLength(), (LPTSTR)aBuf.getStr(), 0 );
 
 
                 // #107797# Write out actual EPS content
@@ -1748,9 +1793,11 @@ BOOL SalGraphics::DrawEPS( long nX, long
 					nDoNow = nToDo;
 					if ( nToDo > POSTSCRIPT_BUFSIZE - 2 )
 						nDoNow = POSTSCRIPT_BUFSIZE - 2;
-					*((USHORT*)pBuf) = (USHORT)nDoNow;
-					memcpy( pBuf + 2, (BYTE*)pPtr + nSize - nToDo, nDoNow );
-					ULONG nResult = Escape ( maGraphicsData.mhDC, nEscape, nDoNow + 2, (LPTSTR)((BYTE*)pBuf), 0 );
+                    // the following is based on the string buffer allocation
+                    // of size POSTSCRIPT_BUFSIZE at construction time of aBuf
+					*((USHORT*)aBuf.getStr()) = (USHORT)nDoNow;
+					memcpy( (void*)(aBuf.getStr() + 2), (BYTE*)pPtr + nSize - nToDo, nDoNow );
+					ULONG nResult = Escape ( mhDC, nEscape, nDoNow + 2, (LPTSTR)aBuf.getStr(), 0 );
 					if (!nResult )
 						break;
 					nToDo -= nResult;
@@ -1759,16 +1806,16 @@ BOOL SalGraphics::DrawEPS( long nX, long
 
                 // #107797# Write out EPS encapsulation footer
                 // ----------------------------------------------------------------------------------
-				pTemp = pBuf + 2;
-				ImplWriteString( &pTemp, "%%EndDocument\n" );
-				ImplWriteString( &pTemp, "count op_count_salWin sub {pop} repeat\n" );
-				ImplWriteString( &pTemp, "countdictstack dict_count_salWin sub {end} repeat\n" );
-				ImplWriteString( &pTemp, "b4_Inc_state_salWin restore\n\n" );
-				*((USHORT*)pBuf) = (USHORT)( pTemp - pBuf - 2 );
-				Escape ( maGraphicsData.mhDC, nEscape, pTemp - pBuf, (LPTSTR)((BYTE*)pBuf), 0 );
+                // reserve a USHORT again
+                aBuf.setLength( 2 );
+                aBuf.append( "%%EndDocument\n"
+                             "count op_count_salWin sub {pop} repeat\n"
+                             "countdictstack dict_count_salWin sub {end} repeat\n"
+                             "b4_Inc_state_salWin restore\n\n" );
+				*((USHORT*)aBuf.getStr()) = (USHORT)( aBuf.getLength() - 2 );
+				Escape ( mhDC, nEscape, aBuf.getLength(), (LPTSTR)aBuf.getStr(), 0 );
 				bRetValue = TRUE;
 			}
-			delete [] pBuf;
 		}
 	}
 
Index: vcl/win/source/gdi/salgdi2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/win/source/gdi/salgdi2.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 salgdi2.cxx
--- vcl/win/source/gdi/salgdi2.cxx	18 Nov 2002 13:50:32 -0000	1.3
+++ vcl/win/source/gdi/salgdi2.cxx	20 Jul 2004 11:04:57 -0000
@@ -70,13 +70,11 @@
 #include <tools/debug.hxx>
 #endif
 
-#define _SV_SALGDI2_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
@@ -84,27 +82,23 @@
 #ifndef _SV_SALIDS_HRC
 #include <salids.hrc>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
 // =======================================================================
 
-BOOL bFastTransparent = FALSE;
-
-// =======================================================================
-
-void SalGraphics::CopyBits( const SalTwoRect* pPosAry, SalGraphics* pSrcGraphics, const OutputDevice* /*pOutDev*/, const OutputDevice* /*pSrcOutDev*/)
+void WinSalGraphics::copyBits( const SalTwoRect* pPosAry, SalGraphics* pSrcGraphics )
 {
 	HDC 	hSrcDC;
 	DWORD	nRop;
 
 	if ( pSrcGraphics )
-		hSrcDC = pSrcGraphics->maGraphicsData.mhDC;
+		hSrcDC = static_cast<WinSalGraphics*>(pSrcGraphics)->mhDC;
 	else
-		hSrcDC = maGraphicsData.mhDC;
+		hSrcDC = mhDC;
 
-	if ( maGraphicsData.mbXORMode )
+	if ( mbXORMode )
 		nRop = SRCINVERT;
 	else
 		nRop = SRCCOPY;
@@ -112,7 +106,7 @@ void SalGraphics::CopyBits( const SalTwo
 	if ( (pPosAry->mnSrcWidth  == pPosAry->mnDestWidth) &&
 		 (pPosAry->mnSrcHeight == pPosAry->mnDestHeight) )
 	{
-		BitBlt( maGraphicsData.mhDC,
+		BitBlt( mhDC,
 				(int)pPosAry->mnDestX, (int)pPosAry->mnDestY,
 				(int)pPosAry->mnDestWidth, (int)pPosAry->mnDestHeight,
 				hSrcDC,
@@ -121,15 +115,15 @@ void SalGraphics::CopyBits( const SalTwo
 	}
 	else
 	{
-		int nOldStretchMode = SetStretchBltMode( maGraphicsData.mhDC, STRETCH_DELETESCANS );
-		StretchBlt( maGraphicsData.mhDC,
+		int nOldStretchMode = SetStretchBltMode( mhDC, STRETCH_DELETESCANS );
+		StretchBlt( mhDC,
 					(int)pPosAry->mnDestX, (int)pPosAry->mnDestY,
 					(int)pPosAry->mnDestWidth, (int)pPosAry->mnDestHeight,
 					hSrcDC,
 					(int)pPosAry->mnSrcX, (int)pPosAry->mnSrcY,
 					(int)pPosAry->mnSrcWidth, (int)pPosAry->mnSrcHeight,
 					nRop );
-		SetStretchBltMode( maGraphicsData.mhDC, nOldStretchMode );
+		SetStretchBltMode( mhDC, nOldStretchMode );
 	}
 }
 
@@ -178,20 +172,20 @@ void ImplCalcOutSideRgn( const RECT& rSr
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::CopyArea( long nDestX, long nDestY,
+void WinSalGraphics::copyArea( long nDestX, long nDestY,
 							long nSrcX, long nSrcY,
 							long nSrcWidth, long nSrcHeight,
-							USHORT nFlags, const OutputDevice* )
+							USHORT nFlags )
 {
-	BitBlt( maGraphicsData.mhDC,
+	BitBlt( mhDC,
 			(int)nDestX, (int)nDestY,
 			(int)nSrcWidth, (int)nSrcHeight,
-			maGraphicsData.mhDC,
+			mhDC,
 			(int)nSrcX, (int)nSrcY,
 			SRCCOPY );
 
 	// Muessen die ueberlappenden Bereiche auch invalidiert werden?
-	if ( (nFlags & SAL_COPYAREA_WINDOWINVALIDATE) && maGraphicsData.mbWindow )
+	if ( (nFlags & SAL_COPYAREA_WINDOWINVALIDATE) && mbWindow )
 	{
 		// Overlap-Bereich berechnen und invalidieren
 		RECT	aSrcRect;
@@ -207,7 +201,7 @@ void SalGraphics::CopyArea( long nDestX,
 		aSrcRect.top	= (int)nSrcY;
 		aSrcRect.right	= aSrcRect.left+(int)nSrcWidth;
 		aSrcRect.bottom = aSrcRect.top+(int)nSrcHeight;
-		GetClientRect( maGraphicsData.mhWnd, &aClipRect );
+		GetClientRect( mhWnd, &aClipRect );
 		if ( IntersectRect( &aSrcRect, &aSrcRect, &aClipRect ) )
 		{
 			// Rechteck in Screen-Koordinaaten umrechnen
@@ -216,7 +210,7 @@ void SalGraphics::CopyArea( long nDestX,
 			int nScreenDY = GetSystemMetrics( SM_CYSCREEN );
 			aPt.x = 0;
 			aPt.y = 0;
-			ClientToScreen( maGraphicsData.mhWnd, &aPt );
+			ClientToScreen( mhWnd, &aPt );
 			aSrcRect.left	+= aPt.x;
 			aSrcRect.top	+= aPt.y;
 			aSrcRect.right	+= aPt.x;
@@ -227,7 +221,7 @@ void SalGraphics::CopyArea( long nDestX,
 
 			// Bereiche die von anderen Fenstern ueberlagert werden berechnen
 			HRGN hTempRgn2 = 0;
-			HWND hWndTopWindow = maGraphicsData.mhWnd;
+			HWND hWndTopWindow = mhWnd;
 			// Find the TopLevel Window, because only Windows which are in
 			// in the foreground of our TopLevel window must be considered
 			if ( GetWindowStyle( hWndTopWindow ) & WS_CHILD )
@@ -300,11 +294,11 @@ void SalGraphics::CopyArea( long nDestX,
 					int nOffY = (int)(nDestY-nSrcY);
 					OffsetRgn( hInvalidateRgn, nOffX-aPt.x, nOffY-aPt.y );
 					// Combine Invalidate Region with existing ClipRegion
-					if ( GetClipRgn( maGraphicsData.mhDC, hTempRgn ) == 1 )
+					if ( GetClipRgn( mhDC, hTempRgn ) == 1 )
 						nRgnType = CombineRgn( hInvalidateRgn, hTempRgn, hInvalidateRgn, RGN_AND );
 					if ( (nRgnType != ERROR) && (nRgnType != NULLREGION) )
 					{
-						InvalidateRgn( maGraphicsData.mhWnd, hInvalidateRgn, TRUE );
+						InvalidateRgn( mhWnd, hInvalidateRgn, TRUE );
 						// Hier loesen wir nur ein Update aus, wenn es der
 						// MainThread ist, damit es beim Bearbeiten der
 						// Paint-Message keinen Deadlock gibt, da der
@@ -312,7 +306,7 @@ void SalGraphics::CopyArea( long nDestX,
 						SalData*	pSalData = GetSalData();
 						DWORD		nCurThreadId = GetCurrentThreadId();
 						if ( pSalData->mnAppThreadId == nCurThreadId )
-							UpdateWindow( maGraphicsData.mhWnd );
+							UpdateWindow( mhWnd );
 					}
 				}
 				DeleteRegion( hTempRgn );
@@ -325,19 +319,19 @@ void SalGraphics::CopyArea( long nDestX,
 // -----------------------------------------------------------------------
 
 void ImplDrawBitmap( HDC hDC,
-					 const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap,
+					 const SalTwoRect* pPosAry, const WinSalBitmap& rSalBitmap,
 					 BOOL bPrinter, int nDrawMode )
 {
 	if( hDC )
 	{
 		HGLOBAL 	hDrawDIB;
 		HBITMAP 	hDrawDDB = rSalBitmap.ImplGethDDB();
-		SalBitmap*	pTmpSalBmp;
+		WinSalBitmap*	pTmpSalBmp;
 		BOOL		bPrintDDB = ( bPrinter && hDrawDDB );
 
 		if( bPrintDDB )
 		{
-			pTmpSalBmp = new SalBitmap;
+			pTmpSalBmp = new WinSalBitmap;
 			pTmpSalBmp->Create( rSalBitmap, rSalBitmap.GetBitCount() );
 			hDrawDIB = pTmpSalBmp->ImplGethDIB();
 		}
@@ -416,24 +410,26 @@ void ImplDrawBitmap( HDC hDC,
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
-							  const SalBitmap& rSalBitmap, const OutputDevice* )
+void WinSalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+							  const SalBitmap& rSalBitmap )
 {
-	ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, rSalBitmap,
-					maGraphicsData.mbPrinter,
-					maGraphicsData.mbXORMode ? SRCINVERT : SRCCOPY );
+	ImplDrawBitmap( mhDC, pPosAry, static_cast<const WinSalBitmap&>(rSalBitmap),
+					mbPrinter,
+					mbXORMode ? SRCINVERT : SRCCOPY );
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
-							  const SalBitmap& rSalBitmap,
-							  SalColor nTransparentColor, const OutputDevice* pOutDev )
+void WinSalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+							  const SalBitmap& rSSalBitmap,
+							  SalColor nTransparentColor )
 {
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No transparency print possible!" );
+	DBG_ASSERT( !mbPrinter, "No transparency print possible!" );
+
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
 
-	SalBitmap*	pMask = new SalBitmap;
-	HDC 		hDC = maGraphicsData.mhDC;
+	WinSalBitmap*	pMask = new WinSalBitmap;
+	HDC 		hDC = mhDC;
 	const Point aPoint;
 	const Size	aSize( rSalBitmap.GetSize() );
 	HBITMAP 	hMaskBitmap = CreateBitmap( (int) aSize.Width(), (int) aSize.Height(), 1, 1, NULL );
@@ -454,7 +450,7 @@ void SalGraphics::DrawBitmap( const SalT
 	}
 	else
 	{
-		SalBitmap*	pTmpSalBmp = new SalBitmap;
+		WinSalBitmap*	pTmpSalBmp = new WinSalBitmap;
 
 		if( pTmpSalBmp->Create( rSalBitmap, this ) )
 		{
@@ -474,128 +470,104 @@ void SalGraphics::DrawBitmap( const SalT
 
 	// hMaskBitmap is destroyed by new SalBitmap 'pMask' ( bDIB==FALSE, bCopy == FALSE )
 	if( pMask->Create( hMaskBitmap, FALSE, FALSE ) )
-		DrawBitmap( pPosAry, rSalBitmap, *pMask, pOutDev );
+		drawBitmap( pPosAry, rSalBitmap, *pMask );
 
 	delete pMask;
 }
-
+ 
 // -----------------------------------------------------------------------
-
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
-							  const SalBitmap& rSalBitmap,
-							  const SalBitmap& rTransparentBitmap, const OutputDevice* )
-{
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No transparency print possible!" );
-
-	if( bFastTransparent )
-	{
-		// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
-		// die Farben der Maske richtig auf die Palette abzubilden,
-		// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
-		if( ( GetBitCount() <= 8 ) && rTransparentBitmap.ImplGethDIB() && rTransparentBitmap.GetBitCount() == 1 )
-		{
-			SalBitmap aTmp;
-			if( aTmp.Create( rTransparentBitmap, this ) )
-				ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, aTmp, FALSE, SRCAND );
-		}
-		else
-			ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, rTransparentBitmap, FALSE, SRCAND );
-
-		// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
-		// die Farben der Maske richtig auf die Palette abzubilden,
-		// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
-		if( ( GetBitCount() <= 8 ) && rSalBitmap.ImplGethDIB() && rSalBitmap.GetBitCount() == 1 )
-		{
-			SalBitmap aTmp;
-			if( aTmp.Create( rSalBitmap, this ) )
-				ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, aTmp, FALSE, SRCPAINT );
-		}
-		else
-			ImplDrawBitmap( maGraphicsData.mhDC, pPosAry, rSalBitmap, FALSE, SRCPAINT );
-	}
-	else
+ 
+void WinSalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+							  const SalBitmap& rSSalBitmap,
+							  const SalBitmap& rSTransparentBitmap )
+{
+	DBG_ASSERT( !mbPrinter, "No transparency print possible!" );
+ 
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
+    const WinSalBitmap& rTransparentBitmap = static_cast<const WinSalBitmap&>(rSTransparentBitmap);
+ 
+	SalTwoRect	aPosAry = *pPosAry;
+	int 		nDstX = (int)aPosAry.mnDestX;
+	int 		nDstY = (int)aPosAry.mnDestY;
+	int 		nDstWidth = (int)aPosAry.mnDestWidth;
+	int 		nDstHeight = (int)aPosAry.mnDestHeight;
+	HDC 		hDC = mhDC;
+	HBITMAP 	hMemBitmap = 0;
+	HBITMAP 	hMaskBitmap = 0;
+ 
+	if( ( nDstWidth > CACHED_HDC_DEFEXT ) || ( nDstHeight > CACHED_HDC_DEFEXT ) )
+	{
+		hMemBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
+		hMaskBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
+	}
+ 
+	HDC hMemDC = ImplGetCachedDC( CACHED_HDC_1, hMemBitmap );
+	HDC hMaskDC = ImplGetCachedDC( CACHED_HDC_2, hMaskBitmap );
+ 
+	aPosAry.mnDestX = aPosAry.mnDestY = 0;
+	BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hDC, nDstX, nDstY, SRCCOPY );
+ 
+	// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
+	// die Farben der Maske richtig auf die Palette abzubilden,
+	// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
+	if( ( GetBitCount() <= 8 ) && rTransparentBitmap.ImplGethDIB() && rTransparentBitmap.GetBitCount() == 1 )
 	{
-		SalTwoRect	aPosAry = *pPosAry;
-		int 		nDstX = (int)aPosAry.mnDestX;
-		int 		nDstY = (int)aPosAry.mnDestY;
-		int 		nDstWidth = (int)aPosAry.mnDestWidth;
-		int 		nDstHeight = (int)aPosAry.mnDestHeight;
-		HDC 		hDC = maGraphicsData.mhDC;
-		HBITMAP 	hMemBitmap = 0;
-		HBITMAP 	hMaskBitmap = 0;
-
-		if( ( nDstWidth > CACHED_HDC_DEFEXT ) || ( nDstHeight > CACHED_HDC_DEFEXT ) )
-		{
-			hMemBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
-			hMaskBitmap = CreateCompatibleBitmap( hDC, nDstWidth, nDstHeight );
-		}
-
-		HDC hMemDC = ImplGetCachedDC( CACHED_HDC_1, hMemBitmap );
-		HDC hMaskDC = ImplGetCachedDC( CACHED_HDC_2, hMaskBitmap );
-
-		aPosAry.mnDestX = aPosAry.mnDestY = 0;
-		BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hDC, nDstX, nDstY, SRCCOPY );
-
-		// bei Paletten-Displays hat WIN/WNT offenbar ein kleines Problem,
-		// die Farben der Maske richtig auf die Palette abzubilden,
-		// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
-		if( ( GetBitCount() <= 8 ) && rTransparentBitmap.ImplGethDIB() && rTransparentBitmap.GetBitCount() == 1 )
-		{
-			SalBitmap aTmp;
-
-			if( aTmp.Create( rTransparentBitmap, this ) )
-				ImplDrawBitmap( hMaskDC, &aPosAry, aTmp, FALSE, SRCCOPY );
-		}
-		else
-			ImplDrawBitmap( hMaskDC, &aPosAry, rTransparentBitmap, FALSE, SRCCOPY );
-
-        // now MemDC contains background, MaskDC the transparency mask
-
-        // #105055# Respect XOR mode
-        if( maGraphicsData.mbXORMode )
-        {
-            ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
-            // now MaskDC contains the bitmap area with black background
-            BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCINVERT );
-            // now MemDC contains background XORed bitmap area ontop
-        }
-        else
-        {
-            BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCAND );       
-            // now MemDC contains background with masked-out bitmap area
-            ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
-            // now MaskDC contains the bitmap area with black background
-            BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCPAINT );
-            // now MemDC contains background and bitmap merged together
-        }
-        // copy to output DC
-        BitBlt( hDC, nDstX, nDstY, nDstWidth, nDstHeight, hMemDC, 0, 0, SRCCOPY );
-
-		ImplReleaseCachedDC( CACHED_HDC_1 );
-		ImplReleaseCachedDC( CACHED_HDC_2 );
-
-		// hMemBitmap != 0 ==> hMaskBitmap != 0
-		if( hMemBitmap )
-		{
-			DeleteObject( hMemBitmap );
-			DeleteObject( hMaskBitmap );
-		}
+		WinSalBitmap aTmp;
+ 
+		if( aTmp.Create( rTransparentBitmap, this ) )
+			ImplDrawBitmap( hMaskDC, &aPosAry, aTmp, FALSE, SRCCOPY );
+	}
+	else
+		ImplDrawBitmap( hMaskDC, &aPosAry, rTransparentBitmap, FALSE, SRCCOPY );
+ 
+    // now MemDC contains background, MaskDC the transparency mask
+ 
+    // #105055# Respect XOR mode
+    if( mbXORMode )
+    {
+        ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
+        // now MaskDC contains the bitmap area with black background
+        BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCINVERT );
+        // now MemDC contains background XORed bitmap area ontop
+    }
+    else
+    {
+        BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCAND );       
+        // now MemDC contains background with masked-out bitmap area
+        ImplDrawBitmap( hMaskDC, &aPosAry, rSalBitmap, FALSE, SRCERASE );
+        // now MaskDC contains the bitmap area with black background
+        BitBlt( hMemDC, 0, 0, nDstWidth, nDstHeight, hMaskDC, 0, 0, SRCPAINT );
+        // now MemDC contains background and bitmap merged together
+    }
+    // copy to output DC
+    BitBlt( hDC, nDstX, nDstY, nDstWidth, nDstHeight, hMemDC, 0, 0, SRCCOPY );
+ 
+	ImplReleaseCachedDC( CACHED_HDC_1 );
+	ImplReleaseCachedDC( CACHED_HDC_2 );
+ 
+	// hMemBitmap != 0 ==> hMaskBitmap != 0
+	if( hMemBitmap )
+	{
+		DeleteObject( hMemBitmap );
+		DeleteObject( hMaskBitmap );
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::DrawMask( const SalTwoRect* pPosAry,
-							const SalBitmap& rSalBitmap,
-							SalColor nMaskColor, const OutputDevice* )
+void WinSalGraphics::drawMask( const SalTwoRect* pPosAry,
+							const SalBitmap& rSSalBitmap,
+							SalColor nMaskColor )
 {
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No transparency print possible!" );
+	DBG_ASSERT( !mbPrinter, "No transparency print possible!" );
+
+    const WinSalBitmap& rSalBitmap = static_cast<const WinSalBitmap&>(rSSalBitmap);
 
 	SalTwoRect	aPosAry = *pPosAry;
 	const BYTE	cRed = SALCOLOR_RED( nMaskColor );
 	const BYTE	cGreen = SALCOLOR_GREEN( nMaskColor );
 	const BYTE	cBlue = SALCOLOR_BLUE( nMaskColor );
-	HDC 		hDC = maGraphicsData.mhDC;
+	HDC 		hDC = mhDC;
 	HBRUSH		hMaskBrush = CreateSolidBrush( RGB( cRed, cGreen, cBlue ) );
 	HBRUSH		hOldBrush = SelectBrush( hDC, hMaskBrush );
 
@@ -604,7 +576,7 @@ void SalGraphics::DrawMask( const SalTwo
 	// wenn wir die DIB direkt ausgeben => DDB-Ausgabe
 	if( ( GetBitCount() <= 8 ) && rSalBitmap.ImplGethDIB() && rSalBitmap.GetBitCount() == 1 )
 	{
-		SalBitmap aTmp;
+		WinSalBitmap aTmp;
 
 		if( aTmp.Create( rSalBitmap, this ) )
 			ImplDrawBitmap( hDC, &aPosAry, aTmp, FALSE, 0x00B8074AUL );
@@ -618,16 +590,16 @@ void SalGraphics::DrawMask( const SalTwo
 
 // -----------------------------------------------------------------------
 
-SalBitmap* SalGraphics::GetBitmap( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+SalBitmap* WinSalGraphics::getBitmap( long nX, long nY, long nDX, long nDY )
 {
-	DBG_ASSERT( !maGraphicsData.mbPrinter, "No ::GetBitmap() from printer possible!" );
+	DBG_ASSERT( !mbPrinter, "No ::GetBitmap() from printer possible!" );
 
-	SalBitmap* pSalBitmap = NULL;
+	WinSalBitmap* pSalBitmap = NULL;
 
 	nDX = labs( nDX );
 	nDY = labs( nDY );
 
-	HDC 	hDC = maGraphicsData.mhDC;
+	HDC 	hDC = mhDC;
 	HBITMAP hBmpBitmap = CreateCompatibleBitmap( hDC, nDX, nDY );
 	HDC 	hBmpDC = ImplGetCachedDC( CACHED_HDC_1, hBmpBitmap );
 	BOOL	bRet;
@@ -637,7 +609,7 @@ SalBitmap* SalGraphics::GetBitmap( long 
 
 	if( bRet )
 	{
-		pSalBitmap = new SalBitmap;
+		pSalBitmap = new WinSalBitmap;
 
 		if( !pSalBitmap->Create( hBmpBitmap, FALSE, FALSE ) )
 		{
@@ -651,15 +623,11 @@ SalBitmap* SalGraphics::GetBitmap( long 
 
 // -----------------------------------------------------------------------
 
-SalColor SalGraphics::GetPixel( long nX, long nY, const OutputDevice* )
+SalColor WinSalGraphics::getPixel( long nX, long nY )
 {
-	COLORREF aWinCol = ::GetPixel( maGraphicsData.mhDC, (int) nX, (int) nY );
+	COLORREF aWinCol = ::GetPixel( mhDC, (int) nX, (int) nY );
 
-#ifdef WIN
-	if ( -1 == aWinCol )
-#else
 	if ( CLR_INVALID == aWinCol )
-#endif
 		return MAKE_SALCOLOR( 0, 0, 0 );
 	else
 		return MAKE_SALCOLOR( GetRValue( aWinCol ),
@@ -669,20 +637,20 @@ SalColor SalGraphics::GetPixel( long nX,
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice * )
+void WinSalGraphics::invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags )
 {
 	if ( nFlags & SAL_INVERT_TRACKFRAME )
 	{
 		HPEN	hDotPen = CreatePen( PS_DOT, 0, 0 );
-		HPEN	hOldPen = SelectPen( maGraphicsData.mhDC, hDotPen );
-		HBRUSH	hOldBrush = SelectBrush( maGraphicsData.mhDC, GetStockBrush( NULL_BRUSH ) );
-		int 	nOldROP = SetROP2( maGraphicsData.mhDC, R2_NOT );
-
-		WIN_Rectangle( maGraphicsData.mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
-
-		SetROP2( maGraphicsData.mhDC, nOldROP );
-		SelectPen( maGraphicsData.mhDC, hOldPen );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		HPEN	hOldPen = SelectPen( mhDC, hDotPen );
+		HBRUSH	hOldBrush = SelectBrush( mhDC, GetStockBrush( NULL_BRUSH ) );
+		int 	nOldROP = SetROP2( mhDC, R2_NOT );
+
+		WIN_Rectangle( mhDC, (int)nX, (int)nY, (int)(nX+nWidth), (int)(nY+nHeight) );
+
+		SetROP2( mhDC, nOldROP );
+		SelectPen( mhDC, hOldPen );
+		SelectBrush( mhDC, hOldBrush );
 		DeletePen( hDotPen );
 	}
 	else if ( nFlags & SAL_INVERT_50 )
@@ -695,11 +663,11 @@ void SalGraphics::Invert( long nX, long 
 			pSalData->mh50Brush = CreatePatternBrush( pSalData->mh50Bmp );
 		}
 
-		COLORREF nOldTextColor = ::SetTextColor( maGraphicsData.mhDC, 0 );
-		HBRUSH hOldBrush = SelectBrush( maGraphicsData.mhDC, pSalData->mh50Brush );
-		PatBlt( maGraphicsData.mhDC, nX, nY, nWidth, nHeight, PATINVERT );
-		::SetTextColor( maGraphicsData.mhDC, nOldTextColor );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		COLORREF nOldTextColor = ::SetTextColor( mhDC, 0 );
+		HBRUSH hOldBrush = SelectBrush( mhDC, pSalData->mh50Brush );
+		PatBlt( mhDC, nX, nY, nWidth, nHeight, PATINVERT );
+		::SetTextColor( mhDC, nOldTextColor );
+		SelectBrush( mhDC, hOldBrush );
 	}
 	else
 	{
@@ -708,20 +676,20 @@ void SalGraphics::Invert( long nX, long 
 		 aRect.top		 = (int)nY;
 		 aRect.right	 = (int)nX+nWidth;
 		 aRect.bottom	 = (int)nY+nHeight;
-		 ::InvertRect( maGraphicsData.mhDC, &aRect );
+		 ::InvertRect( mhDC, &aRect );
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nSalFlags, const OutputDevice* )
+void WinSalGraphics::invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nSalFlags )
 {
 	HPEN		hPen;
 	HPEN		hOldPen;
 	HBRUSH		hBrush;
 	HBRUSH		hOldBrush;
 	COLORREF	nOldTextColor;
-	int 		nOldROP = SetROP2( maGraphicsData.mhDC, R2_NOT );
+	int 		nOldROP = SetROP2( mhDC, R2_NOT );
 
 	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
 		hPen = CreatePen( PS_DOT, 0, 0 );
@@ -744,56 +712,38 @@ void SalGraphics::Invert( ULONG nPoints,
 			hBrush = GetStockBrush( BLACK_BRUSH );
 
 		hPen = GetStockPen( NULL_PEN );
-		nOldTextColor = ::SetTextColor( maGraphicsData.mhDC, 0 );
-		hOldBrush = SelectBrush( maGraphicsData.mhDC, hBrush );
+		nOldTextColor = ::SetTextColor( mhDC, 0 );
+		hOldBrush = SelectBrush( mhDC, hBrush );
 	}
-	hOldPen = SelectPen( maGraphicsData.mhDC, hPen );
+	hOldPen = SelectPen( mhDC, hPen );
 
 	POINT* pWinPtAry;
-#ifdef WIN
-	if ( nPoints > MAX_64KSALPOINTS )
-		nPoints = MAX_64KSALPOINTS;
-
-	pWinPtAry = new POINT[(USHORT)nPoints];
-	const SalPoint huge* pHugePtAry = (const SalPoint huge*)pPtAry;
-	for( USHORT i=0; i < (USHORT)nPoints ; i++ )
-	{
-		pWinPtAry[i].x = (int)pHugePtAry[i].mnX;
-		pWinPtAry[i].y = (int)pHugePtAry[i].mnY;
-	}
-	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
-		Polyline( maGraphicsData.mhDC, pWinPtAry, (int)nPoints );
-	else
-		WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, (int)nPoints );
-	delete pWinPtAry;
-#else
 	// Unter NT koennen wir das Array direkt weiterreichen
 	DBG_ASSERT( sizeof( POINT ) == sizeof( SalPoint ),
-				"SalGraphics::DrawPolyLine(): POINT != SalPoint" );
+				"WinSalGraphics::DrawPolyLine(): POINT != SalPoint" );
 
 	pWinPtAry = (POINT*)pPtAry;
 	// Wegen Windows 95 und der Beschraenkung auf eine maximale Anzahl
 	// von Punkten
 	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
 	{
-		if ( !Polyline( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-			Polyline( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+		if ( !Polyline( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+			Polyline( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 	}
 	else
 	{
-		if ( !WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
-			WIN_Polygon( maGraphicsData.mhDC, pWinPtAry, MAX_64KSALPOINTS );
+		if ( !WIN_Polygon( mhDC, pWinPtAry, (int)nPoints ) && (nPoints > MAX_64KSALPOINTS) )
+			WIN_Polygon( mhDC, pWinPtAry, MAX_64KSALPOINTS );
 	}
-#endif
 
-	SetROP2( maGraphicsData.mhDC, nOldROP );
-	SelectPen( maGraphicsData.mhDC, hOldPen );
+	SetROP2( mhDC, nOldROP );
+	SelectPen( mhDC, hOldPen );
 
 	if ( nSalFlags & SAL_INVERT_TRACKFRAME )
 		DeletePen( hPen );
 	else
 	{
-		::SetTextColor( maGraphicsData.mhDC, nOldTextColor );
-		SelectBrush( maGraphicsData.mhDC, hOldBrush );
+		::SetTextColor( mhDC, nOldTextColor );
+		SelectBrush( mhDC, hOldBrush );
 	}
 }


Index: vcl/win/source/gdi/salgdi3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salgdi3.cxx,v
retrieving revision 1.48.46.3
retrieving revision 1.55
diff -u -p -u -r1.48.46.3 -r1.55
--- vcl/win/source/gdi/salgdi3.cxx	26 Jan 2004 17:28:36 -0000	1.48.46.3
+++ vcl/win/source/gdi/salgdi3.cxx	30 Mar 2004 13:44:57 -0000	1.55
@@ -66,8 +66,6 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALGDI3_CXX
-
 #ifndef _RTL_TENCINFO_H
 #include <rtl/tencinfo.h>
 #endif
@@ -90,8 +88,8 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _SV_OUTFONT_HXX
 #include <outfont.hxx>
@@ -99,24 +97,18 @@
 #ifndef _SV_FONT_HXX
 #include <font.hxx>
 #endif
-
-#ifdef ENABLE_CTL
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif // _SV_SALLAYOUT_HXX
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
-#endif // _SV_POLY_HXX
-#endif // ENABLE_CTL
-
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 #ifdef GCP_KERN_HACK
 #include <algorithm>
 #endif // GCP_KERN_HACK
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
-
 #ifndef __SUBFONT_H
 #include <psprint/list.h>
 #include <psprint/sft.h>
@@ -126,12 +118,6 @@
 // - Defines -
 // -----------
 
-//#ifdef FORCE_VERTICAL_NAME
-
-#ifdef WIN
-#define GDI_ERROR   (0xFFFFFFFFUL)
-#endif
-
 #define GLYPH_INC               (512UL)
 #define MAX_POLYCOUNT           (2048UL)
 
@@ -158,7 +144,7 @@ inline int IntFromFixed(FIXED f)
 static BOOL bImplSalCourierScalable = FALSE;
 static BOOL bImplSalCourierNew = FALSE;
 
-static BOOL FontHasCJKUnicodeRange( const SalGraphics* pGraphics, BOOL &bHasKoreanRange );
+static BOOL FontHasCJKUnicodeRange( const WinSalGraphics* pGraphics, BOOL &bHasKoreanRange );
 
 // =======================================================================
 
@@ -269,7 +255,7 @@ static BYTE ImplFamilyToWin( FontFamily 
 
 // -----------------------------------------------------------------------
 
-static FontWeight ImplWeightToSal( WinWeight nWeight )
+static FontWeight ImplWeightToSal( int nWeight )
 {
     if ( nWeight <= FW_THIN )
         return WEIGHT_THIN;
@@ -293,7 +279,7 @@ static FontWeight ImplWeightToSal( WinWe
 
 // -----------------------------------------------------------------------
 
-static WinWeight ImplWeightToWin( FontWeight eWeight )
+static int ImplWeightToWin( FontWeight eWeight )
 {
     switch ( eWeight )
     {
@@ -518,20 +504,20 @@ void ImplSalLogFontToFontW( HDC hDC, con
 
 // =======================================================================
 
-void SalGraphics::SetTextColor( SalColor nSalColor )
+void WinSalGraphics::SetTextColor( SalColor nSalColor )
 {
     COLORREF aCol = PALETTERGB( SALCOLOR_RED( nSalColor ),
                                 SALCOLOR_GREEN( nSalColor ),
                                 SALCOLOR_BLUE( nSalColor ) );
 
-    if( !maGraphicsData.mbPrinter &&
+    if( !mbPrinter &&
         GetSalData()->mhDitherPal &&
         ImplIsSysColorEntry( nSalColor ) )
     {
         aCol = PALRGB_TO_RGB( aCol );
     }
 
-    ::SetTextColor( maGraphicsData.mhDC, aCol );
+    ::SetTextColor( mhDC, aCol );
 }
 
 // -----------------------------------------------------------------------
@@ -552,11 +538,6 @@ static void ImplSalGetVerticalFontNameW(
     if (rName.Len() == 0 || rName.GetChar(0) == '@')
         return;
 
-#ifdef FORCE_VERTICAL_NAME
-    rName.Insert( (sal_Unicode)'@', 0 );
-    return;
-#endif // FORCE_VERTICAL_NAME
-
     // Vertical fonts starts with a @
     UniString aTemp = rName;
     aTemp.Insert( (sal_Unicode)'@', 0 );
@@ -727,7 +708,7 @@ static HFONT ImplSelectFontW( HDC hDC, L
     if ( !GetTextMetricsW( hDC, &aWinMetric ) )
     {
         // font doesn't work => try a replacement
-        lstrcpyW( rLogFont.lfFaceName, L"Courier New" );
+        lstrcpynW( rLogFont.lfFaceName, L"Courier New", 11 );
         rLogFont.lfPitchAndFamily = FIXED_PITCH;
         HFONT hNewFont2 = CreateFontIndirectW( &rLogFont );
         SelectFont( hDC, hNewFont2 );
@@ -750,7 +731,7 @@ static HFONT ImplSelectFontA( HDC hDC, L
     // when the font doesn't work try a replacement
     if ( !GetTextMetricsA( hDC, &aWinMetric ) )
     {
-        strcpy( rLogFont.lfFaceName, "Courier New" );
+        strncpy( rLogFont.lfFaceName, "Courier New", 11 );
         rLogFont.lfPitchAndFamily = FIXED_PITCH;
         HFONT hNewFont2 = CreateFontIndirectA( &rLogFont );
         SelectFont( hDC, hNewFont2 );
@@ -764,14 +745,7 @@ static HFONT ImplSelectFontA( HDC hDC, L
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::RemovingFont( ImplFontData* )
-{
-    // dummy implementation on W32
-}
-
-// -----------------------------------------------------------------------
-
-USHORT SalGraphics::SetFont( ImplFontSelectData* pFont, int nFallbackLevel )
+USHORT WinSalGraphics::SetFont( ImplFontSelectData* pFont, int nFallbackLevel )
 {
     HFONT hNewFont = 0;
     HFONT hOldFont;
@@ -779,24 +753,24 @@ USHORT SalGraphics::SetFont( ImplFontSel
     if ( aSalShlData.mbWNT )
     {
         LOGFONTW aLogFont;
-        ImplGetLogFontFromFontSelect( maGraphicsData.mhDC, pFont, aLogFont, true );
+        ImplGetLogFontFromFontSelect( mhDC, pFont, aLogFont, true );
 
         // Auf dem Bildschirm nehmen wir Courier New, wenn Courier nicht
         // skalierbar ist und wenn der Font skaliert oder rotiert werden
         // muss
-        if ( maGraphicsData.mbScreen &&
+        if ( mbScreen &&
              (pFont->mnWidth || pFont->mnOrientation ||
               !pFont->mpFontData || (pFont->mpFontData->mnHeight != pFont->mnHeight)) &&
              !bImplSalCourierScalable && bImplSalCourierNew &&
              (ImplSalWICompareAscii( aLogFont.lfFaceName, "Courier" ) == 0) )
-            lstrcpyW( aLogFont.lfFaceName, L"Courier New" );
+            lstrcpynW( aLogFont.lfFaceName, L"Courier New", 11 );
 
-        hOldFont = ImplSelectFontW( maGraphicsData.mhDC, aLogFont, &hNewFont );
+        hOldFont = ImplSelectFontW( mhDC, aLogFont, &hNewFont );
     }
     else
     {
-        if ( !maGraphicsData.mpLogFont )
-            maGraphicsData.mpLogFont = new LOGFONTA;
+        if ( !mpLogFont )
+            mpLogFont = new LOGFONTA;
 
         ByteString aName;
         if ( pFont->mpFontData )
@@ -806,91 +780,91 @@ USHORT SalGraphics::SetFont( ImplFontSel
 
         // Test for vertical
         if ( pFont->mbVertical )
-            ImplSalGetVerticalFontNameA( maGraphicsData.mhDC, aName );
+            ImplSalGetVerticalFontNameA( mhDC, aName );
 
         UINT nNameLen = aName.Len();
-        if ( nNameLen > sizeof( maGraphicsData.mpLogFont->lfFaceName )-1 )
-            nNameLen = sizeof( maGraphicsData.mpLogFont->lfFaceName )-1;
-        memcpy( maGraphicsData.mpLogFont->lfFaceName, aName.GetBuffer(), nNameLen );
-        maGraphicsData.mpLogFont->lfFaceName[nNameLen] = 0;
+        if ( nNameLen > sizeof( mpLogFont->lfFaceName )-1 )
+            nNameLen = sizeof( mpLogFont->lfFaceName )-1;
+        memcpy( mpLogFont->lfFaceName, aName.GetBuffer(), nNameLen );
+        mpLogFont->lfFaceName[nNameLen] = 0;
 
         if ( pFont->mpFontData )
-            maGraphicsData.mpLogFont->lfCharSet = (WIN_BYTE)(pFont->mpFontData->mpSysData);
+            mpLogFont->lfCharSet = (WIN_BYTE)(pFont->mpFontData->mpSysData);
         else
-            maGraphicsData.mpLogFont->lfCharSet = ImplCharSetToWin( pFont->meCharSet );
+            mpLogFont->lfCharSet = ImplCharSetToWin( pFont->meCharSet );
 
-        maGraphicsData.mpLogFont->lfPitchAndFamily  = ImplPitchToWin( pFont->mePitch );
-        maGraphicsData.mpLogFont->lfPitchAndFamily |= ImplFamilyToWin( pFont->meFamily );
-        maGraphicsData.mpLogFont->lfWeight          = ImplWeightToWin( pFont->meWeight );
-        maGraphicsData.mpLogFont->lfHeight          = (int)-pFont->mnHeight;
-        maGraphicsData.mpLogFont->lfWidth           = (int)pFont->mnWidth;
-        maGraphicsData.mpLogFont->lfUnderline       = 0;
-        maGraphicsData.mpLogFont->lfStrikeOut       = 0;
-        maGraphicsData.mpLogFont->lfItalic          = (pFont->meItalic) != ITALIC_NONE;
-        maGraphicsData.mpLogFont->lfEscapement      = pFont->mnOrientation;
-        maGraphicsData.mpLogFont->lfOrientation     = 0;
-        maGraphicsData.mpLogFont->lfClipPrecision   = CLIP_DEFAULT_PRECIS;
-        maGraphicsData.mpLogFont->lfQuality         = DEFAULT_QUALITY;
-        maGraphicsData.mpLogFont->lfOutPrecision    = OUT_TT_PRECIS;
+        mpLogFont->lfPitchAndFamily  = ImplPitchToWin( pFont->mePitch );
+        mpLogFont->lfPitchAndFamily |= ImplFamilyToWin( pFont->meFamily );
+        mpLogFont->lfWeight          = ImplWeightToWin( pFont->meWeight );
+        mpLogFont->lfHeight          = (int)-pFont->mnHeight;
+        mpLogFont->lfWidth           = (int)pFont->mnWidth;
+        mpLogFont->lfUnderline       = 0;
+        mpLogFont->lfStrikeOut       = 0;
+        mpLogFont->lfItalic          = (pFont->meItalic) != ITALIC_NONE;
+        mpLogFont->lfEscapement      = pFont->mnOrientation;
+        mpLogFont->lfOrientation     = 0;
+        mpLogFont->lfClipPrecision   = CLIP_DEFAULT_PRECIS;
+        mpLogFont->lfQuality         = DEFAULT_QUALITY;
+        mpLogFont->lfOutPrecision    = OUT_TT_PRECIS;
         if ( pFont->mnOrientation )
-            maGraphicsData.mpLogFont->lfClipPrecision |= CLIP_LH_ANGLES;
+            mpLogFont->lfClipPrecision |= CLIP_LH_ANGLES;
 
         // disable antialiasing if requested
         if ( pFont->mbNonAntialiased )
-            maGraphicsData.mpLogFont->lfQuality = NONANTIALIASED_QUALITY;
+            mpLogFont->lfQuality = NONANTIALIASED_QUALITY;
 
         // on the display we prefer Courier New when Courier is a
         // bitmap only font and we need to stretch or rotate it
-        if ( maGraphicsData.mbScreen &&
+        if ( mbScreen &&
              (pFont->mnWidth || pFont->mnOrientation ||
               !pFont->mpFontData || (pFont->mpFontData->mnHeight != pFont->mnHeight)) &&
              !bImplSalCourierScalable && bImplSalCourierNew &&
-             (stricmp( maGraphicsData.mpLogFont->lfFaceName, "Courier" ) == 0) )
-            strcpy( maGraphicsData.mpLogFont->lfFaceName, "Courier New" );
+             (stricmp( mpLogFont->lfFaceName, "Courier" ) == 0) )
+            strncpy( mpLogFont->lfFaceName, "Courier New", 11 );
 
-        hOldFont = ImplSelectFontA( maGraphicsData.mhDC, *maGraphicsData.mpLogFont, &hNewFont );
+        hOldFont = ImplSelectFontA( mhDC, *mpLogFont, &hNewFont );
     }
 
-    if( !maGraphicsData.mhDefFont )
+    if( !mhDefFont )
     {
         // keep default font
-        maGraphicsData.mhDefFont = hOldFont;
+        mhDefFont = hOldFont;
     }
     else
     {
         // dereference unused fonts
         for( int i = nFallbackLevel; i < MAX_FALLBACK; ++i )
         {
-            if( maGraphicsData.mhFonts[i] )
+            if( mhFonts[i] )
             {
-                DeleteFont( maGraphicsData.mhFonts[i] );
-                maGraphicsData.mhFonts[i] = 0;
+                DeleteFont( mhFonts[i] );
+                mhFonts[i] = 0;
             }
         }
     }
 
     // store new font in correct layer
-    maGraphicsData.mhFonts[ nFallbackLevel ] = hNewFont;
+    mhFonts[ nFallbackLevel ] = hNewFont;
 
     if( !nFallbackLevel )
     {
-        maGraphicsData.mnFontCharSetCount = 0;
-        maGraphicsData.mbFontKernInit = TRUE;
-        if ( maGraphicsData.mpFontKernPairs )
+        mnFontCharSetCount = 0;
+        mbFontKernInit = TRUE;
+        if ( mpFontKernPairs )
         {
-            delete[] maGraphicsData.mpFontKernPairs;
-            maGraphicsData.mpFontKernPairs = NULL;
+            delete[] mpFontKernPairs;
+            mpFontKernPairs = NULL;
         }
-        maGraphicsData.mnFontKernPairCount = 0;
+        mnFontKernPairCount = 0;
     }
 
-    if (maGraphicsData.mxTextLayoutCache.get() != 0)
-        maGraphicsData.mxTextLayoutCache->flush( nFallbackLevel );
+    if (mxTextLayoutCache.get() != 0)
+        mxTextLayoutCache->flush( nFallbackLevel );
 
     // some printers have higher internal resolution, so their
     // text output would be different from what we calculated
     // => suggest DrawTextArray to workaround this problem
-    if ( maGraphicsData.mbPrinter )
+    if ( mbPrinter )
         return SAL_SETFONT_USEDRAWTEXTARRAY;
     else
         return 0;
@@ -898,16 +872,16 @@ USHORT SalGraphics::SetFont( ImplFontSel
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetFontMetric( ImplFontMetricData* pMetric )
+void WinSalGraphics::GetFontMetric( ImplFontMetricData* pMetric )
 {
     if ( aSalShlData.mbWNT )
     {
         wchar_t aFaceName[LF_FACESIZE+60];
-        if ( GetTextFaceW( maGraphicsData.mhDC, sizeof( aFaceName ) / sizeof( wchar_t ), aFaceName ) )
+        if ( GetTextFaceW( mhDC, sizeof( aFaceName ) / sizeof( wchar_t ), aFaceName ) )
             pMetric->maName = aFaceName;
 
         TEXTMETRICW aWinMetric;
-        if ( GetTextMetricsW( maGraphicsData.mhDC, &aWinMetric ) )
+        if ( GetTextMetricsW( mhDC, &aWinMetric ) )
         {
             pMetric->mnWidth            = aWinMetric.tmAveCharWidth;
             pMetric->meFamily           = ImplFamilyToSal( aWinMetric.tmPitchAndFamily );;
@@ -926,18 +900,36 @@ void SalGraphics::GetFontMetric( ImplFon
                 pMetric->mnOrientation = 0;
             }
             pMetric->mbDevice           = (aWinMetric.tmPitchAndFamily & TMPF_DEVICE) != 0;
-            pMetric->mnLeading          = aWinMetric.tmInternalLeading;
+            pMetric->mnIntLeading       = aWinMetric.tmInternalLeading;
+            pMetric->mnExtLeading       = aWinMetric.tmExternalLeading;
             pMetric->mnAscent           = aWinMetric.tmAscent;
+            pMetric->mnDescent          = aWinMetric.tmDescent;
+            // #107888# workround for Asian...
+            // TODO: assess workaround below for CWS >= extleading
             BOOL bHasKoreanRange;
-            if ( FontHasCJKUnicodeRange( this, bHasKoreanRange ))    // #107888# worakround for Asian...
+            if ( FontHasCJKUnicodeRange( this, bHasKoreanRange ))
             {
-                pMetric->mnLeading  += aWinMetric.tmExternalLeading;
-                pMetric->mnAscent   += aWinMetric.tmExternalLeading;
-                // #109280# korean only: increase descent for wavelines and improved line space
-                if( bHasKoreanRange )
-                    pMetric->mnDescent   += aWinMetric.tmExternalLeading;
+                pMetric->mnIntLeading  += aWinMetric.tmExternalLeading;
+
+                // #109280# The line height for Asian fonts is too small.
+                // Therefore we add half of the external leading to the
+                // ascent, the other half is added to the descent.
+                const long nHalfTmpExtLeading = aWinMetric.tmExternalLeading / 2;
+                const long nOtherHalfTmpExtLeading = aWinMetric.tmExternalLeading -
+                                                     nHalfTmpExtLeading;
+
+                // #110641# external leading for Asian fonts.
+                // The factor 0.3 has been verified during experiments.
+                const long nCJKExtLeading = 0.30 * (pMetric->mnAscent + pMetric->mnDescent);
+
+                if ( nCJKExtLeading > aWinMetric.tmExternalLeading )
+                    pMetric->mnExtLeading = nCJKExtLeading - aWinMetric.tmExternalLeading;
+                else
+                    pMetric->mnExtLeading = 0;
+
+                pMetric->mnAscent   += nHalfTmpExtLeading;
+                pMetric->mnDescent  += nOtherHalfTmpExtLeading;
             }
-            pMetric->mnDescent          = aWinMetric.tmDescent;
             pMetric->mnSlant            = 0;
             pMetric->mnFirstChar        = aWinMetric.tmFirstChar;
             pMetric->mnLastChar         = aWinMetric.tmLastChar;
@@ -946,11 +938,11 @@ void SalGraphics::GetFontMetric( ImplFon
     else
     {
         char aFaceName[LF_FACESIZE+60];
-        if ( GetTextFaceA( maGraphicsData.mhDC, sizeof( aFaceName ), aFaceName ) )
+        if ( GetTextFaceA( mhDC, sizeof( aFaceName ), aFaceName ) )
             pMetric->maName = ImplSalGetUniString( aFaceName );
 
         TEXTMETRICA aWinMetric;
-        if ( GetTextMetricsA( maGraphicsData.mhDC, &aWinMetric ) )
+        if ( GetTextMetricsA( mhDC, &aWinMetric ) )
         {
             pMetric->mnWidth            = aWinMetric.tmAveCharWidth;
             pMetric->meFamily           = ImplFamilyToSal( aWinMetric.tmPitchAndFamily );;
@@ -971,15 +963,18 @@ void SalGraphics::GetFontMetric( ImplFon
             pMetric->mbDevice           = (aWinMetric.tmPitchAndFamily & TMPF_DEVICE) != 0;
             pMetric->mnAscent           = aWinMetric.tmAscent;
             pMetric->mnDescent          = aWinMetric.tmDescent;
-            pMetric->mnLeading          = aWinMetric.tmInternalLeading;
+            pMetric->mnIntLeading       = aWinMetric.tmInternalLeading;
+            pMetric->mnExtLeading       = aWinMetric.tmExternalLeading;
+            // #107888# workround for Asian...
+            // TODO: assess workaround below for CWS >= extleading
             BOOL bHasKoreanRange;
             if ( FontHasCJKUnicodeRange( this, bHasKoreanRange ))    // #107888# worakround for Asian...
             {
-                pMetric->mnLeading  += aWinMetric.tmExternalLeading;
-                pMetric->mnAscent   += aWinMetric.tmExternalLeading;
+                pMetric->mnIntLeading  += aWinMetric.tmExternalLeading;
+                pMetric->mnAscent      += aWinMetric.tmExternalLeading;
                 // #109280# korean only: increase descent for wavelines and improved line space
                 if( bHasKoreanRange )
-                    pMetric->mnDescent   += aWinMetric.tmExternalLeading;
+                    pMetric->mnDescent += aWinMetric.tmExternalLeading;
             }
             pMetric->mnSlant            = 0;
             pMetric->mnFirstChar        = aWinMetric.tmFirstChar;
@@ -994,7 +989,7 @@ int CALLBACK SalEnumCharSetsProcExA( con
                                      const NEWTEXTMETRICEXA* pMetric,
                                      DWORD nFontType, LPARAM lParam )
 {
-    SalGraphicsData* pData = (SalGraphicsData*)lParam;
+    WinSalGraphics* pData = (WinSalGraphics*)lParam;
     // Charset already in the list?
     for ( BYTE i = 0; i < pData->mnFontCharSetCount; i++ )
     {
@@ -1008,7 +1003,7 @@ int CALLBACK SalEnumCharSetsProcExA( con
 
 // -----------------------------------------------------------------------
 
-static void ImplGetAllFontCharSets( SalGraphicsData* pData )
+static void ImplGetAllFontCharSets( WinSalGraphics* pData )
 {
     if ( !pData->mpFontCharSets )
         pData->mpFontCharSets = new BYTE[256];
@@ -1023,7 +1018,7 @@ static void ImplGetAllFontCharSets( SalG
 
 // -----------------------------------------------------------------------
 
-static void ImplAddKerningPairs( SalGraphicsData* pData )
+static void ImplAddKerningPairs( WinSalGraphics* pData )
 {
     ULONG nPairs = ::GetKerningPairsA( pData->mhDC, 0, NULL );
     if ( !nPairs )
@@ -1121,75 +1116,75 @@ static void ImplAddKerningPairs( SalGrap
 
 // -----------------------------------------------------------------------
 
-ULONG SalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs )
+ULONG WinSalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs )
 {
     DBG_ASSERT( sizeof( KERNINGPAIR ) == sizeof( ImplKernPairData ),
-                "SalGraphics::GetKernPairs(): KERNINGPAIR != ImplKernPairData" );
+                "WinSalGraphics::GetKernPairs(): KERNINGPAIR != ImplKernPairData" );
 
-    if ( maGraphicsData.mbFontKernInit )
+    if ( mbFontKernInit )
     {
-        if( maGraphicsData.mpFontKernPairs )
+        if( mpFontKernPairs )
         {
-            delete[] maGraphicsData.mpFontKernPairs;
-            maGraphicsData.mpFontKernPairs = NULL;
+            delete[] mpFontKernPairs;
+            mpFontKernPairs = NULL;
         }
-        maGraphicsData.mnFontKernPairCount = 0;
+        mnFontKernPairCount = 0;
 
         if ( aSalShlData.mbWNT )
         {
             KERNINGPAIR* pPairs = NULL;
-            int nCount = ::GetKerningPairsW( maGraphicsData.mhDC, 0, NULL );
+            int nCount = ::GetKerningPairsW( mhDC, 0, NULL );
             if( nCount )
             {
 #ifdef GCP_KERN_HACK
                 pPairs = new KERNINGPAIR[ nCount+1 ];
-                maGraphicsData.mpFontKernPairs = pPairs;
-                maGraphicsData.mnFontKernPairCount = nCount;
-                ::GetKerningPairsW( maGraphicsData.mhDC, nCount, pPairs );
+                mpFontKernPairs = pPairs;
+                mnFontKernPairCount = nCount;
+                ::GetKerningPairsW( mhDC, nCount, pPairs );
 #else // GCP_KERN_HACK
                 pPairs = pKernPairs;
                 nCount = (nCount < nPairs) : nCount : nPairs;
-                ::GetKerningPairsW( maGraphicsData.mhDC, nCount, pPairs );
+                ::GetKerningPairsW( mhDC, nCount, pPairs );
                 return nCount;
 #endif // GCP_KERN_HACK
             }
         }
         else
         {
-            if ( !maGraphicsData.mnFontCharSetCount )
-                ImplGetAllFontCharSets( &maGraphicsData );
+            if ( !mnFontCharSetCount )
+                ImplGetAllFontCharSets( this );
 
-            if ( maGraphicsData.mnFontCharSetCount <= 1 )
-                ImplAddKerningPairs( &maGraphicsData );
+            if ( mnFontCharSetCount <= 1 )
+                ImplAddKerningPairs( this );
             else
             {
                 // Query All Kerning Pairs from all possible CharSets
-                for ( BYTE i = 0; i < maGraphicsData.mnFontCharSetCount; i++ )
+                for ( BYTE i = 0; i < mnFontCharSetCount; i++ )
                 {
-                    maGraphicsData.mpLogFont->lfCharSet = maGraphicsData.mpFontCharSets[i];
-                    HFONT hNewFont = CreateFontIndirectA( maGraphicsData.mpLogFont );
-                    HFONT hOldFont = SelectFont( maGraphicsData.mhDC, hNewFont );
-                    ImplAddKerningPairs( &maGraphicsData );
-                    SelectFont( maGraphicsData.mhDC, hOldFont );
+                    mpLogFont->lfCharSet = mpFontCharSets[i];
+                    HFONT hNewFont = CreateFontIndirectA( mpLogFont );
+                    HFONT hOldFont = SelectFont( mhDC, hNewFont );
+                    ImplAddKerningPairs( this );
+                    SelectFont( mhDC, hOldFont );
                     DeleteFont( hNewFont );
                 }
             }
         }
 
-        maGraphicsData.mbFontKernInit = FALSE;
+        mbFontKernInit = FALSE;
 
-        std::sort( maGraphicsData.mpFontKernPairs,
-            maGraphicsData.mpFontKernPairs + maGraphicsData.mnFontKernPairCount,
+        std::sort( mpFontKernPairs,
+            mpFontKernPairs + mnFontKernPairCount,
             ImplCmpKernData );
     }
 
     if( !pKernPairs )
-        return maGraphicsData.mnFontKernPairCount;
-    else if( maGraphicsData.mpFontKernPairs )
+        return mnFontKernPairCount;
+    else if( mpFontKernPairs )
     {
-        if ( nPairs < maGraphicsData.mnFontKernPairCount )
-            nPairs = maGraphicsData.mnFontKernPairCount;
-        memcpy( pKernPairs, maGraphicsData.mpFontKernPairs,
+        if ( nPairs < mnFontKernPairCount )
+            nPairs = mnFontKernPairCount;
+        memcpy( pKernPairs, mpFontKernPairs,
                 nPairs*sizeof( ImplKernPairData ) );
         return nPairs;
     }
@@ -1204,7 +1199,7 @@ static unsigned GetUShort( const unsigne
 static signed GetSShort( const unsigned char* p ){ return((short)((p[0]<<8)+p[1]));}
 static inline DWORD CalcTag( const char p[4]) { return (p[0]+(p[1]<<8)+(p[2]<<16)+(p[3]<<24)); }
 
-static BOOL FontHasCJKUnicodeRange( const SalGraphics* pGraphics, BOOL &bHasKoreanRange )
+static BOOL FontHasCJKUnicodeRange( const WinSalGraphics* pGraphics, BOOL &bHasKoreanRange )
 {
     BOOL bCJKCapable = FALSE;
     bHasKoreanRange = FALSE;
@@ -1212,12 +1207,12 @@ static BOOL FontHasCJKUnicodeRange( cons
     if ( pGraphics )
     {
         const DWORD Cos2Tag = CalcTag( "OS/2" );
-        DWORD nRCos2 = GetFontData( pGraphics->maGraphicsData.mhDC, Cos2Tag, 0, NULL, 0 );
+        DWORD nRCos2 = GetFontData( pGraphics->mhDC, Cos2Tag, 0, NULL, 0 );
         if ( nRCos2 != GDI_ERROR )
         {
             int nLength = nRCos2;
             unsigned char* pOS2map = (unsigned char*)alloca( nLength );
-            nRCos2 = GetFontData( pGraphics->maGraphicsData.mhDC, Cos2Tag, 0, pOS2map, nLength );
+            nRCos2 = GetFontData( pGraphics->mhDC, Cos2Tag, 0, pOS2map, nLength );
             sal_uInt32 version = GetUShort( pOS2map );
             if ( version >= 0x0001 && nLength >= 58 )
             {
@@ -1243,20 +1238,20 @@ static BOOL FontHasCJKUnicodeRange( cons
     return bCJKCapable;
 }
 
-ULONG SalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
+ULONG WinSalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
 {
     int nRangeCount = 0;
 
 	// get SFNT font's CMAP table
 	const DWORD CmapTag = CalcTag( "cmap" );
-	DWORD nRC = GetFontData( maGraphicsData.mhDC, CmapTag, 0, NULL, 0 );
+	DWORD nRC = GetFontData( mhDC, CmapTag, 0, NULL, 0 );
 	if( nRC == GDI_ERROR )
         return 0;
 
 	int nLength = nRC;
     std::vector<unsigned char> aCmap( nLength );
     unsigned char* pCmap = &aCmap[0];
-	nRC = GetFontData( maGraphicsData.mhDC, CmapTag, 0, pCmap, nLength );
+	nRC = GetFontData( mhDC, CmapTag, 0, pCmap, nLength );
 	if( nRC == GDI_ERROR )
         return 0;
     // check for the CMAP table corruption
@@ -1276,28 +1271,28 @@ ULONG SalGraphics::GetFontCodeRanges( sa
 	    int nTmpOffset = GetUInt( p+4 );
 	    int nTmpFormat = GetUShort( pCmap + nTmpOffset );
 
-        int nValue;
-		if( nPlatform==3 && nEncoding==1 )      // Win Unicode
-            nValue = 3;
-        else if( nPlatform==1 && nEncoding==3 ) // Mac Unicode>2.0
-            nValue = 2;
-        else if( nPlatform==1 && nEncoding==0 ) // Mac Unicode<2.0
-            nValue = 1;
-        else
-            continue;                           // ignore non-unicode tables
+		int nValue;
+		if( nPlatform==3 && nEncoding==1 )		// Win Unicode
+			nValue = 3;
+		else if( nPlatform==1 && nEncoding==3 )	// Mac Unicode>2.0
+			nValue = 2;
+		else if( nPlatform==1 && nEncoding==0 )	// Mac Unicode<2.0
+			nValue = 1;
+		else
+			continue;							// ignore non-unicode tables
+
+		if( nTmpFormat == 12 )					// 32bit unicode mappings
+			nValue += 3;
+		else if( nTmpFormat != 4 )				// 16bit unicode mappings
+			continue;							// ignore other formats
 
-	    if( nTmpFormat == 12 )                  // 32bit unicode mappings
-            nValue += 3;
-        else if( nTmpFormat != 4 )              // 16bit unicode mappings
-            continue;                           // ignore other formats
-
-        if( nBestVal < nValue )
-        {
-            nBestVal = nValue;
-            nOffset = nTmpOffset;
-            nFormat = nTmpFormat;
-        }
-    }
+		if( nBestVal < nValue )
+		{
+			nBestVal = nValue;
+			nOffset = nTmpOffset;
+			nFormat = nTmpFormat;
+		}
+	}
 
     sal_uInt32* pCP = pCodePairs;
 
@@ -1362,7 +1357,7 @@ int CALLBACK SalEnumFontsProcExA( const 
                 pInfo->mbCourier = FALSE;
             XubString aName( ImplSalGetUniString( pLogFont->elfLogFont.lfFaceName ) );
             pInfo->mpName = &aName;
-            strcpy( pInfo->mpLogFontA->lfFaceName, pLogFont->elfLogFont.lfFaceName );
+            strncpy( pInfo->mpLogFontA->lfFaceName, pLogFont->elfLogFont.lfFaceName, LF_FACESIZE );
             pInfo->mpLogFontA->lfCharSet = pLogFont->elfLogFont.lfCharSet;
             EnumFontFamiliesExA( pInfo->mhDC, pInfo->mpLogFontA, (FONTENUMPROCA)SalEnumFontsProcExA,
                                  (LPARAM)(void*)pInfo, 0 );
@@ -1539,7 +1534,7 @@ bool ImplAddTempFont( SalData& rSalData,
     ::rtl::OUString aUSytemPath;
     OSL_VERIFY( !osl::FileBase::getSystemPathFromFileURL( rFontFileURL, aUSytemPath ) );
 
-#ifdef FR_PRIVATE
+#ifdef FR_PRIVATE   // wingdi.h, but only if _WIN32_WINNT >= 0x0500, which is currently not true.
     OSVERSIONINFO aVersion;
     aVersion.dwOSVersionInfoSize = sizeof(aVersion);
     if( ::GetVersionEx( &aVersion ) && (aVersion.dwMajorVersion >= 5) )
@@ -1547,7 +1542,7 @@ bool ImplAddTempFont( SalData& rSalData,
         nRet = AddFontResourceExW( aUSytemPath.getStr(), FR_PRIVATE, NULL );
     }
     else
-#endif // FR_PRIVATE
+#endif        
     {
         static int nCounter = 0;
         char aFileName[] = "soAA.fot";
@@ -1556,7 +1551,9 @@ bool ImplAddTempFont( SalData& rSalData,
         char aResourceName[512];
         int nMaxLen = sizeof(aResourceName)/sizeof(*aResourceName) - 16;
         int nLen = ::GetTempPathA( nMaxLen, aResourceName );
-        ::strcpy( aResourceName + nLen, aFileName );
+        ::strncpy( aResourceName + nLen, aFileName, sizeof( aResourceName )- nLen );
+        // security: end buffer in any case
+        aResourceName[ 511 ] = 0;
         ::DeleteFileA( aResourceName );
 
         rtl_TextEncoding theEncoding = osl_getThreadTextEncoding();
@@ -1577,9 +1574,7 @@ bool ImplAddTempFont( SalData& rSalData,
         }
     }
 
-    if( nRet > 0 )
-        return true;
-    return false;
+	return ( nRet > 0 ) ? true : false;
 }
 
 // -----------------------------------------------------------------------
@@ -1637,11 +1632,7 @@ String ImplGetFontNameFromFile( SalData&
     char aResourceName[512];
     int nMaxLen = sizeof(aResourceName)/sizeof(*aResourceName) - 16;
     int nLen = ::GetTempPathA( nMaxLen, aResourceName );
-#if (_MSC_VER < 1300)
-    ::strncpy( aResourceName + nLen, aFileName, std::max( 0, nMaxLen - nLen ));
-#else
-    ::strncpy( aResourceName + nLen, aFileName, max( 0, nMaxLen - nLen ));
-#endif
+    ::strncpy( aResourceName + nLen, aFileName, Max( 0, nMaxLen - nLen ));
     ::DeleteFileA( aResourceName );
 
     // Create font resource file (typically with a .fot file name extension).    
@@ -1722,7 +1713,7 @@ String ImplGetFontNameFromFile( SalData&
 
 // -----------------------------------------------------------------------
 
-ImplFontData* SalGraphics::AddTempDevFont( const String& rFontFileURL, const String& rFontName )
+ImplFontData* WinSalGraphics::AddTempDevFont( const String& rFontFileURL, const String& rFontName )
 {
     String aFontName( rFontName );
     
@@ -1733,7 +1724,7 @@ ImplFontData* SalGraphics::AddTempDevFon
     if ( !aFontName.Len() )
         return NULL;
 
-    if( ::ImplIsFontAvailable( maGraphicsData.mhDC, aFontName ) )
+    if( ::ImplIsFontAvailable( mhDC, aFontName ) )
         return NULL;
 
     // remember temp font for cleanup later
@@ -1768,18 +1759,19 @@ ImplFontData* SalGraphics::AddTempDevFon
     pFontData->mbSubsettable= FALSE;
     pFontData->mbEmbeddable = FALSE;
 
-#if 0   // TODO: improve ImplFontData using "FONTRES:" from *.fot file
+	/*
+	// TODO: improve ImplFontData using "FONTRES:" from *.fot file
     pFontData->maSearchName = // using "FONTRES:" from file
     if( rFontName != pFontData->maName )
         pFontData->maMapName = aFontName;
-#endif
+	*/
 
     return pFontData;
 }
 
 // -----------------------------------------------------------------------
 
-void SalGraphics::GetDevFontList( ImplDevFontList* pList )
+void WinSalGraphics::GetDevFontList( ImplDevFontList* pList )
 {
     // make sure all fonts are registered at least temporarily
     static bool bOnce = true;
@@ -1815,13 +1807,13 @@ void SalGraphics::GetDevFontList( ImplDe
     }
 
     ImplEnumInfo aInfo;
-    aInfo.mhDC          = maGraphicsData.mhDC;
+    aInfo.mhDC          = mhDC;
     aInfo.mpList        = pList;
     aInfo.mpName        = NULL;
     aInfo.mpLogFontA    = NULL;
     aInfo.mpLogFontW    = NULL;
     aInfo.mbCourier     = FALSE;
-    if ( !maGraphicsData.mbPrinter )
+    if ( !mbPrinter )
     {
         aInfo.mbImplSalCourierScalable  = FALSE;
         aInfo.mbImplSalCourierNew       = FALSE;
@@ -1846,7 +1838,7 @@ void SalGraphics::GetDevFontList( ImplDe
         memset( &aLogFont, 0, sizeof( aLogFont ) );
         aLogFont.lfCharSet = DEFAULT_CHARSET;
         aInfo.mpLogFontW = &aLogFont;
-        EnumFontFamiliesExW( maGraphicsData.mhDC, &aLogFont,
+        EnumFontFamiliesExW( mhDC, &aLogFont,
             (FONTENUMPROCW)SalEnumFontsProcExW, (LPARAM)(void*)&aInfo, 0 );
     }
     else
@@ -1855,13 +1847,13 @@ void SalGraphics::GetDevFontList( ImplDe
         memset( &aLogFont, 0, sizeof( aLogFont ) );
         aLogFont.lfCharSet = DEFAULT_CHARSET;
         aInfo.mpLogFontA = &aLogFont;
-        EnumFontFamiliesExA( maGraphicsData.mhDC, &aLogFont,
+        EnumFontFamiliesExA( mhDC, &aLogFont,
             (FONTENUMPROCA)SalEnumFontsProcExA, (LPARAM)(void*)&aInfo, 0 );
     }
 
     // Feststellen, was es fuer Courier-Schriften auf dem Bildschirm gibt,
     // um in SetFont() evt. Courier auf Courier New zu mappen
-    if ( !maGraphicsData.mbPrinter )
+    if ( !mbPrinter )
     {
         bImplSalCourierScalable = aInfo.mbImplSalCourierScalable;
         bImplSalCourierNew      = aInfo.mbImplSalCourierNew;
@@ -1870,14 +1862,14 @@ void SalGraphics::GetDevFontList( ImplDe
 
 // ----------------------------------------------------------------------------
 
-void SalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
+void WinSalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
 {}
 
 // -----------------------------------------------------------------------
 
-BOOL SalGraphics::GetGlyphBoundRect( long nIndex, Rectangle& rRect, const OutputDevice* )
+BOOL WinSalGraphics::GetGlyphBoundRect( long nIndex, Rectangle& rRect )
 {
-    HDC hDC = maGraphicsData.mhDC;
+    HDC hDC = mhDC;
 
     // use unity matrix
     MAT2 aMat;
@@ -1906,12 +1898,12 @@ BOOL SalGraphics::GetGlyphBoundRect( lon
 
 // -----------------------------------------------------------------------
 
-BOOL SalGraphics::GetGlyphOutline( long nIndex, PolyPolygon& rPolyPoly, const OutputDevice* )
+BOOL WinSalGraphics::GetGlyphOutline( long nIndex, PolyPolygon& rPolyPoly )
 {
     rPolyPoly.Clear();
 
     BOOL bRet = FALSE;
-    HDC  hDC = maGraphicsData.mhDC;
+    HDC  hDC = mhDC;
 
     // use unity matrix
     MAT2 aMat;
@@ -2101,16 +2093,16 @@ private:
 class ScopedFont
 {
 public:
-    explicit ScopedFont(SalGraphicsData & rData);
+    explicit ScopedFont(WinSalGraphics & rData);
 
     ~ScopedFont();
 
 private:
-    SalGraphicsData & m_rData;
+    WinSalGraphics & m_rData;
     HFONT m_hOrigFont;
 };
 
-ScopedFont::ScopedFont(SalGraphicsData & rData): m_rData(rData)
+ScopedFont::ScopedFont(WinSalGraphics & rData): m_rData(rData)
 {
     m_hOrigFont = m_rData.mhFonts[0];
     m_rData.mhFonts[0] = 0; // avoid deletion of current font
@@ -2156,7 +2148,7 @@ int ScopedTrueTypeFont::open(void * pBuf
     return OpenTTFont(pBuffer, nLen, nFaceNum, &m_pFont);
 }
 
-BOOL SalGraphics::CreateFontSubset( const rtl::OUString& rToFile,
+BOOL WinSalGraphics::CreateFontSubset( const rtl::OUString& rToFile,
     ImplFontData* pFont, long* pGlyphIDs, sal_uInt8* pEncoding,
     sal_Int32* pWidths, int nGlyphs, FontSubsetInfo& rInfo )
 {
@@ -2182,13 +2174,13 @@ BOOL SalGraphics::CreateFontSubset( cons
     aIFSD.mbNonAntialiased  = false;
 
     // TODO: much better solution: move SetFont and restoration of old font to caller
-    ScopedFont aOldFont(maGraphicsData);
+    ScopedFont aOldFont(*this);
     SetFont( &aIFSD, 0 );
 
 #if OSL_DEBUG_LEVEL > 1
     // get font metrics
     TEXTMETRICA aWinMetric;
-    if( !::GetTextMetricsA( maGraphicsData.mhDC, &aWinMetric ) )
+    if( !::GetTextMetricsA( mhDC, &aWinMetric ) )
         return FALSE;
 
     DBG_ASSERT( !(aWinMetric.tmPitchAndFamily & TMPF_DEVICE), "cannot subset device font" );
@@ -2196,11 +2188,11 @@ BOOL SalGraphics::CreateFontSubset( cons
 #endif
 
     // get raw font file data
-    DWORD nFontSize = ::GetFontData( maGraphicsData.mhDC, 0, 0, NULL, 0 );
+    DWORD nFontSize = ::GetFontData( mhDC, 0, 0, NULL, 0 );
     if( nFontSize == GDI_ERROR )
         return FALSE;
     ScopedCharArray xRawFontData(new char[ nFontSize ]);
-    DWORD nFontSize2 = ::GetFontData( maGraphicsData.mhDC, 0, 0, (void*)xRawFontData.get(), nFontSize );
+    DWORD nFontSize2 = ::GetFontData( mhDC, 0, 0, (void*)xRawFontData.get(), nFontSize );
     if( nFontSize != nFontSize2 )
         return FALSE;
 
@@ -2291,7 +2283,7 @@ BOOL SalGraphics::CreateFontSubset( cons
 
 //--------------------------------------------------------------------------
 
-const void* SalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+const void* WinSalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
 {
     // TODO: how to get access to Type 1 font files on this platform?
     return NULL;
@@ -2299,16 +2291,22 @@ const void* SalGraphics::GetEmbedFontDat
 
 //--------------------------------------------------------------------------
 
-void SalGraphics::FreeEmbedFontData( const void* pData, long nLen )
+void WinSalGraphics::FreeEmbedFontData( const void* pData, long nLen )
 {
     // TODO: once GetEmbedFontData() above does something check implementation below
     free( (void*)pData );
 }
 
-const std::map< sal_Unicode, sal_Int32 >* SalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+const std::map< sal_Unicode, sal_Int32 >* WinSalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
 {
     // TODO: once GetEmbedFontData() above does something this needs implementation
     if( pNonEncoded )
         *pNonEncoded = NULL;
     return NULL;
+}
+
+//--------------------------------------------------------------------------
+
+void WinSalGraphics::DrawServerFontLayout( const ServerFontLayout& )
+{
 }
Index: vcl/win/source/gdi/salnativewidgets-luna.cxx
===================================================================
RCS file: vcl/win/source/gdi/salnativewidgets-luna.cxx
diff -N vcl/win/source/gdi/salnativewidgets-luna.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/source/gdi/salnativewidgets-luna.cxx	10 May 2004 16:02:25 -0000	1.2
@@ -0,0 +1,977 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_CXX
+
+#ifndef _SV_SVSYS_H
+#include <svsys.h>
+#endif
+
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
+#endif
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#include "uxtheme.h"
+#include "tmschema.h"
+
+#include <map>
+#include <string>
+
+using namespace rtl;
+using namespace std;
+
+typedef map< wstring, HTHEME > ThemeMap;
+static ThemeMap aThemeMap;
+
+
+/****************************************************
+ wrap visual styles API to avoid linking against it
+ it is not available on all Windows platforms
+*****************************************************/
+
+class VisualStylesAPI
+{
+private:
+    typedef HTHEME  (WINAPI * OpenThemeData_Proc_T) ( HWND hwnd, LPCWSTR pszClassList );
+    typedef HRESULT (WINAPI * CloseThemeData_Proc_T) ( HTHEME hTheme );
+    typedef HRESULT (WINAPI * GetThemeBackgroundContentRect_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    typedef HRESULT (WINAPI * DrawThemeBackground_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    typedef HRESULT (WINAPI * DrawThemeText_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    typedef HRESULT (WINAPI * GetThemePartSize_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+
+    OpenThemeData_Proc_T                    lpfnOpenThemeData;
+    CloseThemeData_Proc_T                   lpfnCloseThemeData;
+    GetThemeBackgroundContentRect_Proc_T    lpfnGetThemeBackgroundContentRect;
+    DrawThemeBackground_Proc_T              lpfnDrawThemeBackground;
+    DrawThemeText_Proc_T                    lpfnDrawThemeText;
+    GetThemePartSize_Proc_T                 lpfnGetThemePartSize;
+
+    HMODULE mhModule;
+
+public:
+    VisualStylesAPI();
+    ~VisualStylesAPI();
+    BOOL IsAvailable()  { return (mhModule != NULL); }
+
+    HTHEME OpenThemeData( HWND hwnd, LPCWSTR pszClassList );
+    HRESULT CloseThemeData( HTHEME hTheme );
+    HRESULT GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    HRESULT DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    HRESULT DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    HRESULT GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+};
+
+static VisualStylesAPI vsAPI;
+
+VisualStylesAPI::VisualStylesAPI()
+{
+    mhModule = LoadLibraryA("uxtheme.dll");
+
+    lpfnOpenThemeData = (OpenThemeData_Proc_T) GetProcAddress( mhModule, "OpenThemeData" );
+    lpfnCloseThemeData = (CloseThemeData_Proc_T) GetProcAddress( mhModule, "CloseThemeData" );
+    lpfnGetThemeBackgroundContentRect = (GetThemeBackgroundContentRect_Proc_T) GetProcAddress( mhModule, "GetThemeBackgroundContentRect" );
+    lpfnDrawThemeBackground = (DrawThemeBackground_Proc_T) GetProcAddress( mhModule, "DrawThemeBackground" );
+    lpfnDrawThemeText = (DrawThemeText_Proc_T) GetProcAddress( mhModule, "DrawThemeText" );
+    lpfnGetThemePartSize = (GetThemePartSize_Proc_T) GetProcAddress( mhModule, "GetThemePartSize" );
+}
+VisualStylesAPI::~VisualStylesAPI()
+{
+    if( mhModule )
+        FreeLibrary( mhModule );
+}
+HTHEME VisualStylesAPI::OpenThemeData( HWND hwnd, LPCWSTR pszClassList )
+{
+    if(lpfnOpenThemeData)
+        return (*lpfnOpenThemeData) (hwnd, pszClassList);
+    else
+        return NULL;
+}
+
+HRESULT VisualStylesAPI::CloseThemeData( HTHEME hTheme )
+{
+    if(lpfnCloseThemeData)
+        return (*lpfnCloseThemeData) (hTheme);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect )
+{
+    if(lpfnGetThemeBackgroundContentRect)
+        return (*lpfnGetThemeBackgroundContentRect) ( hTheme, hdc, iPartId, iStateId, pBoundingRect, pContentRect );
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect )
+{
+    if(lpfnDrawThemeBackground)
+        return (*lpfnDrawThemeBackground) (hTheme, hdc, iPartId, iStateId, pRect, pClipRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect )
+{
+    if(lpfnDrawThemeText)
+        return (*lpfnDrawThemeText) (hTheme, hdc, iPartId, iStateId, pszText, iCharCount, dwTextFlags, dwTextFlags2, pRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz )
+{
+    if(lpfnGetThemePartSize)
+        return (*lpfnGetThemePartSize) (hTheme, hdc, iPartId, iStateId, prc, eSize, psz);
+    else
+        return S_FALSE;
+}
+
+
+/*********************************************************
+ * Initialize XP theming and local stuff                         
+ *********************************************************/
+void SalData::initNWF( void )
+{
+}
+
+
+// *********************************************************
+// * Release theming handles
+// ********************************************************
+void SalData::deInitNWF( void )
+{
+    ThemeMap::iterator iter = aThemeMap.begin();
+    while( iter != aThemeMap.end() )
+    {
+        vsAPI.CloseThemeData(iter->second);
+        iter++;
+    }
+    aThemeMap.clear();
+}
+
+static HTHEME getThemeHandle( HWND hWnd, LPCWSTR name )
+{
+    if( GetSalData()->mbThemeChanged )
+    {
+        // throw away invalid theme handles
+        GetSalData()->deInitNWF();
+        GetSalData()->mbThemeChanged = FALSE;
+    }
+
+    ThemeMap::iterator iter;
+    if( (iter = aThemeMap.find( name )) != aThemeMap.end() )
+        return iter->second;
+    // theme not found -> add it to map
+    HTHEME hTheme = vsAPI.OpenThemeData( hWnd, name );
+    if( hTheme != NULL )
+        aThemeMap[name] = hTheme;
+    return hTheme;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL WinSalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    HTHEME hTheme = NULL;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            if( nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT )
+                return FALSE;   // no background painting needed
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else if( nPart == PART_ALL_BUTTONS || 
+                nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN || 
+                nPart == PART_BUTTON_LEFT|| nPart == PART_BUTTON_RIGHT )
+                hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_ALL_BUTTONS )
+                hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+                //return TRUE;
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+            break;
+    }
+
+    return (hTheme != NULL);
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL WinSalGraphics::hitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside )
+{
+    return FALSE;
+}
+
+BOOL ImplDrawTheme( HTHEME hTheme, HDC hDC, int iPart, int iState, RECT rc, const OUString& aStr)
+{
+    HRESULT hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+
+    if( aStr.getLength() )
+    {
+        RECT rcContent;
+        hr = vsAPI.GetThemeBackgroundContentRect( hTheme, hDC, iPart, iState, &rc, &rcContent);
+        hr = vsAPI.DrawThemeText( hTheme, hDC, iPart, iState,
+            aStr.getStr(), -1,
+            DT_CENTER | DT_VCENTER | DT_SINGLELINE,
+            0, &rcContent);
+    }
+    return (hr == S_OK);
+}
+
+
+// Helper functions
+// ----
+
+void ImplConvertSpinbuttonValues( int nControlPart, const ControlState& rState, const Rectangle& rRect, 
+                                 int* pLunaPart, int *pLunaState, RECT *pRect )
+{
+    if( nControlPart == PART_BUTTON_DOWN )
+    {
+        *pLunaPart = SPNP_DOWN;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNS_HOT;
+        else
+            *pLunaState = DNS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_UP )
+    {
+        *pLunaPart = SPNP_UP;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPS_HOT;
+        else
+            *pLunaState = UPS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_RIGHT )
+    {
+        *pLunaPart = SPNP_UPHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNHZS_HOT;
+        else
+            *pLunaState = DNHZS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_LEFT )
+    {
+        *pLunaPart = SPNP_DOWNHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPHZS_HOT;
+        else
+            *pLunaState = UPHZS_NORMAL;
+    }
+
+    pRect->left   = rRect.Left();
+    pRect->right  = rRect.Right()+1;
+    pRect->top    = rRect.Top();
+    pRect->bottom = rRect.Bottom()+1;
+}
+
+// ----
+
+BOOL ImplDrawNativeControl(	HDC hDC, HTHEME hTheme, RECT rc,
+                            ControlType nType,
+							ControlPart nPart,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+    // a listbox dropdown is actually a combobox dropdown
+    if( nType == CTRL_LISTBOX )
+        if( nPart == PART_BUTTON_DOWN )
+            nType = CTRL_COMBOBOX;
+
+    // draw entire combobox as a large edit box
+    if( nType == CTRL_COMBOBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    // draw entire spinbox as a large edit box
+    if( nType == CTRL_SPINBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    int iPart(0), iState(0);
+    if( nType == CTRL_SCROLLBAR )
+    {
+        HRESULT hr;
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_UPPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_UPDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_UPHOT;
+            else
+                iState = ABS_UPNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_DOWNPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_DOWNDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_DOWNHOT;
+            else
+                iState = ABS_DOWNNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_LEFTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_LEFTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_LEFTHOT;
+            else
+                iState = ABS_LEFTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_RIGHTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_RIGHTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_RIGHTHOT;
+            else
+                iState = ABS_RIGHTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_THUMB_HORZ || nPart == PART_THUMB_VERT )
+        {
+            iPart = (nPart == PART_THUMB_HORZ) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+
+            SIZE sz;
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_MIN, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_TRUE, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_DRAW, &sz);
+
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            // paint gripper on thumb if enough space
+            if( ( (nPart == PART_THUMB_VERT) && (rc.bottom-rc.top > 12) ) ||
+                ( (nPart == PART_THUMB_HORZ) && (rc.right-rc.left > 12) ) )
+            {
+                iPart = (nPart == PART_THUMB_HORZ) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+                iState = 0;
+                vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            }
+            return (hr == S_OK);
+        }
+        if( nPart == PART_TRACK_HORZ_LEFT || nPart == PART_TRACK_HORZ_RIGHT || nPart == PART_TRACK_VERT_UPPER || nPart == PART_TRACK_VERT_LOWER )
+        {
+            switch( nPart )
+            {
+                case PART_TRACK_HORZ_LEFT:  iPart = SBP_UPPERTRACKHORZ; break;
+                case PART_TRACK_HORZ_RIGHT: iPart = SBP_LOWERTRACKHORZ; break;
+                case PART_TRACK_VERT_UPPER: iPart = SBP_UPPERTRACKVERT; break;
+                case PART_TRACK_VERT_LOWER: iPart = SBP_LOWERTRACKVERT; break;
+            }
+
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+    }
+    if( nType == CTRL_SPINBUTTONS && nPart == PART_ALL_BUTTONS )
+    {
+        SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            BOOL bOk = FALSE;
+
+            RECT rect;
+            ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+            bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+            if( bOk )
+            {
+                ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+            }
+
+            return bOk;
+        }
+    }
+    if( nType == CTRL_SPINBOX )
+    {
+        // decrease spinbutton rects a little
+        //rc.right--;
+        //rc.bottom--;
+        if( nPart == PART_ALL_BUTTONS )
+        {
+            SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+            if( pValue )
+            {
+                BOOL bOk = FALSE;
+
+                RECT rect;
+                ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+                if( bOk )
+                {
+                    ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                    bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+                }
+
+                return bOk;
+            }
+        }
+
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SPNP_DOWN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNS_HOT;
+            else
+                iState = DNS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SPNP_UP;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPS_HOT;
+            else
+                iState = UPS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SPNP_DOWNHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNHZS_HOT;
+            else
+                iState = DNHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SPNP_UPHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPHZS_HOT;
+            else
+                iState = UPHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT || nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN )
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    if( nType == CTRL_COMBOBOX )
+    {
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = CP_DROPDOWNBUTTON;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = CBXS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = CBXS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = CBXS_HOT;
+            else
+                iState = CBXS_NORMAL;
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+    if( nType == CTRL_PUSHBUTTON )
+    {
+        iPart = BP_PUSHBUTTON;
+        if( nState & CTRL_STATE_PRESSED )
+            iState = PBS_PRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = PBS_DISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = PBS_HOT;
+        else if( nState & CTRL_STATE_DEFAULT )
+            iState = PBS_DEFAULTED;
+        //else if( nState & CTRL_STATE_FOCUSED )
+        //    iState = PBS_DEFAULTED;    // may need to draw focus rect 
+        else
+            iState = PBS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_RADIOBUTTON )
+    {
+        iPart = BP_RADIOBUTTON;
+        BOOL bChecked = ( aValue.getTristateVal() == BUTTONVALUE_ON );
+
+        if( nState & CTRL_STATE_PRESSED )
+            iState = bChecked ? RBS_CHECKEDPRESSED : RBS_UNCHECKEDPRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = bChecked ? RBS_CHECKEDDISABLED : RBS_UNCHECKEDDISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = bChecked ? RBS_CHECKEDHOT : RBS_UNCHECKEDHOT;
+        else
+            iState = bChecked ? RBS_CHECKEDNORMAL : RBS_UNCHECKEDNORMAL;
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_CHECKBOX )
+    {
+        iPart = BP_CHECKBOX;
+        ButtonValue v = aValue.getTristateVal();
+
+        if( nState & CTRL_STATE_PRESSED )
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDPRESSED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDPRESSED : CBS_MIXEDPRESSED );
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDDISABLED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDDISABLED : CBS_MIXEDDISABLED );
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDHOT : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDHOT : CBS_MIXEDHOT );
+        else
+            iState = (v == BUTTONVALUE_ON)  ? CBS_CHECKEDNORMAL : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDNORMAL : CBS_MIXEDNORMAL );
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        //SIZE sz;
+        //THEMESIZE eSize = TS_DRAW; // TS_MIN, TS_TRUE, TS_DRAW
+        //vsAPI.GetThemePartSize( hTheme, hDC, iPart, iState, &rc, eSize, &sz);
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_EDITBOX )
+    {
+        iPart = EP_EDITTEXT;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = ETS_DISABLED;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = ETS_FOCUSED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = ETS_HOT;
+        else
+            iState = ETS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_LISTBOX )
+    {
+        if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+        {
+            iPart = LVP_EMPTYTEXT; // ??? no idea which part to choose here
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+
+    if( nType == CTRL_TAB_PANE )
+    {
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_FIXEDBORDER )
+    {
+        /*
+        iPart = BP_GROUPBOX;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = GBS_DISABLED;
+        else
+            iState = GBS_NORMAL;
+            */
+        // The fixed border is only used around the tools->options tabpage where
+        // TABP_PANE fits best
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_BODY )
+    {
+        iPart = TABP_BODY;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_ITEM )
+    {
+        iPart = TABP_TABITEMLEFTEDGE;
+        rc.bottom--;
+
+        TabitemValue *pValue = (TabitemValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            if( pValue->isBothAligned() )
+            {
+                iPart = TABP_TABITEMLEFTEDGE;
+                rc.right--;
+            }
+            else if( pValue->isLeftAligned() )
+                iPart = TABP_TABITEMLEFTEDGE;
+            else if( pValue->isRightAligned() )
+                iPart = TABP_TABITEMRIGHTEDGE;
+            else iPart = TABP_TABITEM;
+        }
+ 
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = TILES_DISABLED;
+        else if( nState & CTRL_STATE_SELECTED )
+        {
+            iState = TILES_SELECTED;
+            // increase the selected tab
+            rc.left-=2;
+            if( pValue && !pValue->isBothAligned() )
+            {
+                if( pValue->isLeftAligned() || pValue->isNotAligned() )
+                    rc.right+=2;
+                if( pValue->isRightAligned() )
+                    rc.right+=1;
+            }
+            rc.top-=2;
+            rc.bottom+=2;
+        }
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = TILES_HOT;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = TILES_FOCUSED;    // may need to draw focus rect 
+        else
+            iState = TILES_NORMAL;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    return false;
+}
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the WinSalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL WinSalGraphics::drawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+    BOOL bOk = false;
+    HTHEME hTheme;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            hTheme = getThemeHandle( mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            hTheme = getThemeHandle( mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( mhWnd, L"Edit");
+            else
+                hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            hTheme = getThemeHandle( mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            hTheme = getThemeHandle( mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            hTheme = getThemeHandle( mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+    }
+
+    if( !hTheme )
+        return false;
+
+	Rectangle buttonRect = rControlRegion.GetBoundRect();
+    RECT rc;
+    rc.left   = buttonRect.Left();
+    rc.right  = buttonRect.Right()+1;
+    rc.top    = buttonRect.Top();
+    rc.bottom = buttonRect.Bottom()+1;
+
+    HDC hDC = GetDC( mhWnd );
+
+    // set default text alignment
+    int ta = SetTextAlign( hDC, TA_LEFT|TA_TOP|TA_NOUPDATECP );
+
+    OUString aCaptionStr( aCaption.replace('~', '&') ); // translate mnemonics
+    bOk = ImplDrawNativeControl(hDC, hTheme, rc,
+                            nType, nPart, nState, aValue,
+							rControlHandle, aCaptionStr );
+
+    // restore alignment
+    SetTextAlign( hDC, ta );
+   
+    ReleaseDC( mhWnd, hDC );
+
+    //GdiFlush();
+
+	return bOk;
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the WinSalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL WinSalGraphics::drawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption )
+{
+	return( false );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the true bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the WinSalGraphics implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL WinSalGraphics::getNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion )
+{
+    BOOL bRet = FALSE;
+    /*
+    if( nType == CTRL_PUSHBUTTON && nPart == PART_ENTIRE_CONTROL )
+    {
+        if( nState & CTRL_STATE_DEFAULT )
+        {
+            // make default button bigger
+            rNativeContentRegion = rControlRegion;
+            Rectangle aBoundRect = rControlRegion.GetBoundRect();
+            aBoundRect.Top() -= 5;
+            aBoundRect.Bottom() += 5;
+            aBoundRect.Left() -= 8;
+            aBoundRect.Right() += 8;
+            rNativeBoundingRegion = Region( aBoundRect );
+            bRet = TRUE;
+        }
+    }
+*/
+	return( bRet );
+}
+
+
Index: vcl/win/source/gdi/salogl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salogl.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/gdi/salogl.cxx	2 Feb 2001 15:18:28 -0000	1.2
+++ vcl/win/source/gdi/salogl.cxx	6 Jan 2004 14:56:06 -0000	1.4
@@ -63,18 +63,14 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALOGL_CXX
-
-#ifndef _SV_SALOGL_HXX
-#include <salogl.hxx>
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
-#ifdef WIN
-#define __OPENGL_CALL _far _pascal
-#elif defined WNT
+#ifdef WNT
 #define __OPENGL_CALL __stdcall
 #else
 #define __OPENGL_CALL
@@ -110,9 +106,9 @@ if( !pImplOpenWGLFnc##FncName ) bRet = F
 
 // Members
 static HINSTANCE	hImplOGLLib;
-HGLRC				SalOpenGL::mhOGLContext = 0;
-HDC 				SalOpenGL::mhOGLLastDC = 0;
-ULONG				SalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
+HGLRC				WinSalOpenGL::mhOGLContext = 0;
+HDC 				WinSalOpenGL::mhOGLLastDC = 0;
+ULONG				WinSalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
 
 INIT_OGLFNC_WGL( CreateContext );
 INIT_OGLFNC_WGL( DeleteContext );
@@ -132,26 +128,26 @@ LRESULT CALLBACK OpenGLWndProc( HWND hWn
 // - SalOpenGL -
 // -------------
 
-SalOpenGL::SalOpenGL( SalGraphics* pGraphics )
+WinSalOpenGL::WinSalOpenGL( SalGraphics* pGraphics )
 {
 	// Set mhOGLLastDC only the first time a
 	// SalOpenGL object is created; we need
 	// this DC in SalOpenGL::Create();
 	if ( OGL_STATE_UNLOADED == mnOGLState )
-		mhOGLLastDC = pGraphics->maGraphicsData.mhDC;
+		mhOGLLastDC = static_cast<WinSalGraphics*>(pGraphics)->mhDC;
 }
 
 // ------------------------------------------------------------------------
 
-SalOpenGL::~SalOpenGL()
+WinSalOpenGL::~WinSalOpenGL()
 {
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::Create()
+bool WinSalOpenGL::IsValid()
 {
-	BOOL bRet = FALSE;
+	bool bRet = false;
 
 	if ( OGL_STATE_UNLOADED == mnOGLState )
 	{
@@ -218,21 +214,21 @@ BOOL SalOpenGL::Create()
 			mnOGLState = OGL_STATE_INVALID;
 	}
 	else if( OGL_STATE_VALID == mnOGLState )
-		bRet = TRUE;
+		bRet = true;
 
 	return bRet;
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::Release()
+void WinSalOpenGL::Release()
 {
 	ImplFreeLib();
 }
 
 // ------------------------------------------------------------------------
 
-void* SalOpenGL::GetOGLFnc( const char* pFncName )
+void* WinSalOpenGL::GetOGLFnc( const char* pFncName )
 {
 	if ( hImplOGLLib )
 		return (void*)GetProcAddress( hImplOGLLib, pFncName );
@@ -244,9 +240,11 @@ void* SalOpenGL::GetOGLFnc( const char* 
 
 typedef BOOL (WINAPI *MyFuncType)(HDC, HGLRC);
 
-void SalOpenGL::OGLEntry( SalGraphics* pGraphics )
+void WinSalOpenGL::OGLEntry( SalGraphics* pSGraphics )
 {
-	if ( pGraphics->maGraphicsData.mhDC != mhOGLLastDC )
+    WinSalGraphics* pGraphics = static_cast<WinSalGraphics*>(pSGraphics);
+
+	if ( pGraphics->mhDC != mhOGLLastDC )
 	{
 		PIXELFORMATDESCRIPTOR pfd =
 		{
@@ -254,7 +252,7 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 			1,
 			PFD_DRAW_TO_WINDOW | PFD_SUPPORT_GDI | PFD_SUPPORT_OPENGL,
 			PFD_TYPE_RGBA,
-			GetDeviceCaps( pGraphics->maGraphicsData.mhDC, BITSPIXEL ),
+			GetDeviceCaps( pGraphics->mhDC, BITSPIXEL ),
 			0, 0, 0, 0, 0, 0,
 			0,
 			0,
@@ -268,14 +266,14 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 			0, 0, 0
 		};
 
-		const int nIndex = ChoosePixelFormat( pGraphics->maGraphicsData.mhDC, &pfd );
-		if ( nIndex && SetPixelFormat( pGraphics->maGraphicsData.mhDC, nIndex, &pfd ) )
+		const int nIndex = ChoosePixelFormat( pGraphics->mhDC, &pfd );
+		if ( nIndex && SetPixelFormat( pGraphics->mhDC, nIndex, &pfd ) )
 		{
 			WNDCLASS	aWc;
 			HWND		hDummyWnd;
 
 			pImplOpenWGLFncDeleteContext( mhOGLContext );
-			mhOGLLastDC = pGraphics->maGraphicsData.mhDC;
+			mhOGLLastDC = pGraphics->mhDC;
 			mhOGLContext = pImplOpenWGLFncCreateContext( mhOGLLastDC );
 
 			SaveDC( mhOGLLastDC );
@@ -298,20 +296,32 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::OGLExit( SalGraphics* pGraphics )
+void WinSalOpenGL::OGLExit( SalGraphics* pGraphics )
+{
+}
+
+// ------------------------------------------------------------------------
+
+void WinSalOpenGL::StartScene( SalGraphics* pGraphics )
+{
+}
+
+// ------------------------------------------------------------------------
+
+void WinSalOpenGL::StopScene()
 {
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::ImplInitLib()
+BOOL WinSalOpenGL::ImplInitLib()
 {
 	return ((hImplOGLLib = LoadLibrary( OGL_LIBNAME )) != NULL);
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::ImplFreeLib()
+void WinSalOpenGL::ImplFreeLib()
 {
 	if ( hImplOGLLib )
 	{
@@ -323,7 +333,7 @@ void SalOpenGL::ImplFreeLib()
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::ImplInit()
+BOOL WinSalOpenGL::ImplInit()
 {
 	BOOL bRet = TRUE;
 
Index: vcl/win/source/gdi/salprn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salprn.cxx,v
retrieving revision 1.12.12.2
retrieving revision 1.17
diff -u -p -u -r1.12.12.2 -r1.17
--- vcl/win/source/gdi/salprn.cxx	7 Apr 2004 11:02:40 -0000	1.12.12.2
+++ vcl/win/source/gdi/salprn.cxx	18 May 2004 10:59:21 -0000	1.17
@@ -64,28 +64,26 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALPRN_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 #ifndef _SV_SALPTYPE_HXX
 #include <salptype.hxx>
 #endif
-#ifndef _SV_SALPRN_HXX
-#include <salprn.hxx>
+#ifndef _SV_SALPRN_H
+#include <salprn.h>
 #endif
 
 #ifndef _NEW_HXX
@@ -195,7 +193,7 @@ static ULONG ImplWinQueueStatusToSal( DW
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
+void WinSalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
 {
 // !!! UNICODE - NT Optimierung !!!
 	DWORD			i;
@@ -385,7 +383,7 @@ void SalInstance::GetPrinterQueueInfo( I
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
+void WinSalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
 {
 // !!! UNICODE - NT Optimierung !!!
 	DWORD				nBytes = 0;
@@ -422,7 +420,7 @@ void SalInstance::GetPrinterQueueState( 
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
+void WinSalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
 {
 	delete (String*)(pInfo->mpSysData);
 	delete pInfo;
@@ -431,7 +429,7 @@ void SalInstance::DeletePrinterQueueInfo
 // -----------------------------------------------------------------------
 
 // !!! UNICODE - NT Optimierung !!!
-XubString SalInstance::GetDefaultPrinter()
+XubString WinSalInstance::GetDefaultPrinter()
 {
 	// Default-Printer-String aus win.ini holen
 	char szBuffer[256];
@@ -451,7 +449,7 @@ XubString SalInstance::GetDefaultPrinter
 
 // =======================================================================
 
-static DWORD ImplDeviceCaps( SalInfoPrinter* pPrinter, WORD nCaps,
+static DWORD ImplDeviceCaps( WinSalInfoPrinter* pPrinter, WORD nCaps,
 							 LPTSTR pOutput, const ImplJobSetup* pSetupData )
 {
 	DEVMODE* pDevMode;
@@ -461,15 +459,14 @@ static DWORD ImplDeviceCaps( SalInfoPrin
 		pDevMode = SAL_DEVMODE( pSetupData );
 
 // !!! UNICODE - NT Optimierung !!!
-
-    return DeviceCapabilitiesA( ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(), 
-                              ImplSalGetWinAnsiString( pPrinter->maPrinterData.maPortName, TRUE ).GetBuffer(),
-                              nCaps, (LPSTR)pOutput, pDevMode );
+	return DeviceCapabilitiesA( ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(), 
+                                ImplSalGetWinAnsiString( pPrinter->maPortName, TRUE ).GetBuffer(),
+                                nCaps, (LPSTR)pOutput, pDevMode );
 }
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplTestSalJobSetup( SalInfoPrinter* pPrinter,
+static BOOL ImplTestSalJobSetup( WinSalInfoPrinter* pPrinter,
 								 ImplJobSetup* pSetupData, BOOL bDelete )
 {
 	if ( pSetupData && pSetupData->mpDriverData )
@@ -490,11 +487,11 @@ static BOOL ImplTestSalJobSetup( SalInfo
             // can avoid potential driver crashes as their jobsetups are often not compatible
             // #110800#, #111151#, #112381#, #i16580#, #i14173# and perhaps #112375#
             HANDLE hPrn;
-	        if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
+	        if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
 		        return FALSE;
 
 	        long nSysJobSize = DocumentPropertiesA( 0, hPrn,
-                                                    (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+                                                    (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
                                                     NULL, NULL, 0 );
             if( nSysJobSize < 0 )
             {
@@ -503,7 +500,7 @@ static BOOL ImplTestSalJobSetup( SalInfo
             }
             DEVMODE *pBuffer = (DEVMODE*) _alloca( nSysJobSize );
 	        DWORD nRet = DocumentPropertiesA( 0, hPrn,
-                                            (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+                                            (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
                                             pBuffer, NULL, DM_OUT_BUFFER );
             if( nRet < 0 )
             {
@@ -521,7 +518,7 @@ static BOOL ImplTestSalJobSetup( SalInfo
         }
 
 		if ( (pSetupData->mnSystem == JOBSETUP_SYSTEM_WINDOWS) &&
-             (pPrinter->maPrinterData.maDriverName == pSetupData->maDriver) &&
+             (pPrinter->maDriverName == pSetupData->maDriver) &&
 			 (pSetupData->mnDriverDataLen > sizeof( SalDriverData )) &&
              (dmSpecVersion == pDevMode->dmSpecVersion) &&
              (dmDriverVersion == pDevMode->dmDriverVersion) &&
@@ -540,12 +537,12 @@ static BOOL ImplTestSalJobSetup( SalInfo
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplUpdateSalJobSetup( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData,
-								   BOOL bIn, SalFrame* pVisibleDlgParent )
+static BOOL ImplUpdateSalJobSetup( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData,
+								   BOOL bIn, WinSalFrame* pVisibleDlgParent )
 {
 	HANDLE hPrn;
 // !!! UNICODE - NT Optimierung !!!
-	if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
+	if ( !OpenPrinterA( (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(), &hPrn, NULL ) )
 		return FALSE;
 
 	LONG			nRet;
@@ -559,7 +556,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
 
 // !!! UNICODE - NT Optimierung !!!
 	nSysJobSize = DocumentPropertiesA( hWnd, hPrn,
-									   (LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+									   (LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
 									   NULL, NULL, 0 );
 	if ( nSysJobSize < 0 )
 	{
@@ -586,7 +583,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
 	// Testen, ob Dialog angezeigt werden soll
 	if ( pVisibleDlgParent )
 	{
-		hWnd = pVisibleDlgParent->maFrameData.mhWnd;
+		hWnd = pVisibleDlgParent->mhWnd;
 		nMode |= DM_IN_PROMPT;
 	}
 
@@ -597,7 +594,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
         nMutexCount = ImplSalReleaseYieldMutex();
 
 	nRet = DocumentPropertiesA( hWnd, hPrn,
-								(LPSTR)ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ).GetBuffer(),
+								(LPSTR)ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ).GetBuffer(),
 								pOutDevBuffer, pInDevBuffer, nMode );
     if ( pVisibleDlgParent )
         ImplSalAcquireYieldMutex( nMutexCount );
@@ -637,7 +634,7 @@ static BOOL ImplUpdateSalJobSetup( SalIn
 
 // -----------------------------------------------------------------------
 
-static void ImplDevModeToJobSetup( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
+static void ImplDevModeToJobSetup( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
 {
 	if ( !pSetupData || !pSetupData->mpDriverData )
 		return;
@@ -730,7 +727,7 @@ static BOOL ImplPaperSizeEqual( short nP
 
 // -----------------------------------------------------------------------
 
-static void ImplJobSetupToDevMode( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
+static void ImplJobSetupToDevMode( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData, ULONG nFlags )
 {
 	if ( !pSetupData || !pSetupData->mpDriverData )
 		return;
@@ -858,8 +855,8 @@ static void ImplJobSetupToDevMode( SalIn
 				{
 					pDevMode->dmFields	   |= DM_PAPERLENGTH | DM_PAPERWIDTH;
 					pDevMode->dmPaperSize	= DMPAPER_USER;
-					pDevMode->dmPaperWidth	= (short)pSetupData->mnPaperWidth/10;
-					pDevMode->dmPaperLength = (short)pSetupData->mnPaperHeight/10;
+					pDevMode->dmPaperWidth	= (short)(pSetupData->mnPaperWidth/10);
+					pDevMode->dmPaperLength = (short)(pSetupData->mnPaperHeight/10);
 				}
 
 				if ( pPapers )
@@ -875,7 +872,7 @@ static void ImplJobSetupToDevMode( SalIn
 
 // -----------------------------------------------------------------------
 
-static HDC ImplCreateSalPrnIC( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
+static HDC ImplCreateSalPrnIC( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
 {
 	LPDEVMODE pDevMode;
 	if ( pSetupData && pSetupData->mpDriverData )
@@ -884,14 +881,14 @@ static HDC ImplCreateSalPrnIC( SalInfoPr
 		pDevMode = NULL;
 // !!! UNICODE - NT Optimierung !!!
 	// #95347 some buggy drivers (eg, OKI) write to those buffers in CreateIC, although declared const - so provide some space
-	ByteString aDriver ( ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDriverName, TRUE ) );
-	ByteString aDevice ( ImplSalGetWinAnsiString( pPrinter->maPrinterData.maDeviceName, TRUE ) );
+	ByteString aDriver ( ImplSalGetWinAnsiString( pPrinter->maDriverName, TRUE ) );
+	ByteString aDevice ( ImplSalGetWinAnsiString( pPrinter->maDeviceName, TRUE ) );
 	int n = aDriver.Len() > aDevice.Len() ? aDriver.Len() : aDevice.Len();
 	n += 2048;
 	char *lpszDriverName = new char[n];
 	char *lpszDeviceName = new char[n];
-	strcpy( lpszDriverName, aDriver.GetBuffer() );
-	strcpy( lpszDeviceName, aDevice.GetBuffer() );
+	strncpy( lpszDriverName, aDriver.GetBuffer(), n );
+	strncpy( lpszDeviceName, aDevice.GetBuffer(), n );
 	HDC hDC = CreateICA( lpszDriverName,
 						 lpszDeviceName,
 						 0,
@@ -903,50 +900,51 @@ static HDC ImplCreateSalPrnIC( SalInfoPr
 
 // -----------------------------------------------------------------------
 
-static SalGraphics* ImplCreateSalPrnGraphics( HDC hDC )
+static WinSalGraphics* ImplCreateSalPrnGraphics( HDC hDC )
 {
-	SalGraphics* pGraphics = new SalGraphics;
-	pGraphics->maGraphicsData.mhDC		= hDC;
-	pGraphics->maGraphicsData.mhWnd 	= 0;
-	pGraphics->maGraphicsData.mbPrinter = TRUE;
-	pGraphics->maGraphicsData.mbVirDev	= FALSE;
-	pGraphics->maGraphicsData.mbWindow	= FALSE;
-	pGraphics->maGraphicsData.mbScreen	= FALSE;
-	ImplSalInitGraphics( &(pGraphics->maGraphicsData) );
+	WinSalGraphics* pGraphics = new WinSalGraphics;
+    pGraphics->SetLayout( 0 );
+	pGraphics->mhDC		= hDC;
+	pGraphics->mhWnd 	= 0;
+	pGraphics->mbPrinter = TRUE;
+	pGraphics->mbVirDev	= FALSE;
+	pGraphics->mbWindow	= FALSE;
+	pGraphics->mbScreen	= FALSE;
+	ImplSalInitGraphics( pGraphics );
 	return pGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplUpdateSalPrnIC( SalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
+static BOOL ImplUpdateSalPrnIC( WinSalInfoPrinter* pPrinter, ImplJobSetup* pSetupData )
 {
 	HDC hNewDC = ImplCreateSalPrnIC( pPrinter, pSetupData );
 	if ( !hNewDC )
 		return FALSE;
 
-	if ( pPrinter->maPrinterData.mpGraphics )
+	if ( pPrinter->mpGraphics )
 	{
-		ImplSalDeInitGraphics( &(pPrinter->maPrinterData.mpGraphics->maGraphicsData) );
-		DeleteDC( pPrinter->maPrinterData.mpGraphics->maGraphicsData.mhDC );
-		delete pPrinter->maPrinterData.mpGraphics;
+		ImplSalDeInitGraphics( pPrinter->mpGraphics );
+		DeleteDC( pPrinter->mpGraphics->mhDC );
+		delete pPrinter->mpGraphics;
 	}
 
-	SalGraphics* pGraphics = ImplCreateSalPrnGraphics( hNewDC );
-	pPrinter->maPrinterData.mhDC		= hNewDC;
-	pPrinter->maPrinterData.mpGraphics	= pGraphics;
+	WinSalGraphics* pGraphics = ImplCreateSalPrnGraphics( hNewDC );
+	pPrinter->mhDC		= hNewDC;
+	pPrinter->mpGraphics	= pGraphics;
 
 	return TRUE;
 }
 
 // =======================================================================
 
-SalInfoPrinter* SalInstance::CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
-												ImplJobSetup* pSetupData )
+SalInfoPrinter* WinSalInstance::CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
+                                                   ImplJobSetup* pSetupData )
 {
-	SalInfoPrinter* pPrinter = new SalInfoPrinter;
-	pPrinter->maPrinterData.maDriverName	= pQueueInfo->maDriver;
-	pPrinter->maPrinterData.maDeviceName	= pQueueInfo->maPrinterName;
-	pPrinter->maPrinterData.maPortName		= *(String*)(pQueueInfo->mpSysData);
+	WinSalInfoPrinter* pPrinter = new WinSalInfoPrinter;
+	pPrinter->maDriverName	= pQueueInfo->maDriver;
+	pPrinter->maDeviceName	= pQueueInfo->maPrinterName;
+	pPrinter->maPortName		= *(String*)(pQueueInfo->mpSysData);
 
 	// Testen, ob Setupdaten zum Drucker gehoeren (erst aufrufen, nachdem
 	// die Member gesetzt sind, da diese in dieser Routine abgefragt werden)
@@ -959,9 +957,9 @@ SalInfoPrinter* SalInstance::CreateInfoP
 		return NULL;
 	}
 
-	SalGraphics* pGraphics = ImplCreateSalPrnGraphics( hDC );
-	pPrinter->maPrinterData.mhDC		= hDC;
-	pPrinter->maPrinterData.mpGraphics	= pGraphics;
+	WinSalGraphics* pGraphics = ImplCreateSalPrnGraphics( hDC );
+	pPrinter->mhDC		= hDC;
+	pPrinter->mpGraphics	= pGraphics;
 	if ( !pSetupData->mpDriverData )
 		ImplUpdateSalJobSetup( pPrinter, pSetupData, FALSE, NULL );
 	ImplDevModeToJobSetup( pPrinter, pSetupData, SAL_JOBSET_ALL );
@@ -972,36 +970,36 @@ SalInfoPrinter* SalInstance::CreateInfoP
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
+void WinSalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
 {
 	delete pPrinter;
 }
 
 // =======================================================================
 
-SalInfoPrinter::SalInfoPrinter()
+WinSalInfoPrinter::WinSalInfoPrinter()
 {
-	maPrinterData.mhDC			= 0;
-	maPrinterData.mpGraphics	= NULL;
-	maPrinterData.mbGraphics	= FALSE;
+	mhDC			= 0;
+	mpGraphics	= NULL;
+	mbGraphics	= FALSE;
     m_bPapersInit               = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-SalInfoPrinter::~SalInfoPrinter()
+WinSalInfoPrinter::~WinSalInfoPrinter()
 {
-	if ( maPrinterData.mpGraphics )
+	if ( mpGraphics )
 	{
-		ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-		DeleteDC( maPrinterData.mpGraphics->maGraphicsData.mhDC );
-		delete maPrinterData.mpGraphics;
+		ImplSalDeInitGraphics( mpGraphics );
+		DeleteDC( mpGraphics->mhDC );
+		delete mpGraphics;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
+void WinSalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
 {
     m_aPaperFormats.clear();
 
@@ -1035,7 +1033,7 @@ void SalInfoPrinter::InitPaperFormats( c
 
 // -----------------------------------------------------------------------
 
-int SalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
+int WinSalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
 {
     int nRet = ImplDeviceCaps( this, DC_ORIENTATION, NULL, pSetupData );
 
@@ -1047,29 +1045,29 @@ int SalInfoPrinter::GetLandscapeAngle( c
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalInfoPrinter::GetGraphics()
+SalGraphics* WinSalInfoPrinter::GetGraphics()
 {
-	if ( maPrinterData.mbGraphics )
+	if ( mbGraphics )
 		return NULL;
 
-	if ( maPrinterData.mpGraphics )
-		maPrinterData.mbGraphics = TRUE;
+	if ( mpGraphics )
+		mbGraphics = TRUE;
 
-	return maPrinterData.mpGraphics;
+	return mpGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::ReleaseGraphics( SalGraphics* )
+void WinSalInfoPrinter::ReleaseGraphics( SalGraphics* )
 {
-	maPrinterData.mbGraphics = FALSE;
+	mbGraphics = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pSetupData )
+BOOL WinSalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pSetupData )
 {
-	if ( ImplUpdateSalJobSetup( this, pSetupData, TRUE, pFrame ) )
+	if ( ImplUpdateSalJobSetup( this, pSetupData, TRUE, static_cast<WinSalFrame*>(pFrame) ) )
 	{
 		ImplDevModeToJobSetup( this, pSetupData, SAL_JOBSET_ALL );
 		return ImplUpdateSalPrnIC( this, pSetupData );
@@ -1080,7 +1078,7 @@ BOOL SalInfoPrinter::Setup( SalFrame* pF
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::SetPrinterData( ImplJobSetup* pSetupData )
+BOOL WinSalInfoPrinter::SetPrinterData( ImplJobSetup* pSetupData )
 {
 	if ( !ImplTestSalJobSetup( this, pSetupData, FALSE ) )
 		return FALSE;
@@ -1089,7 +1087,7 @@ BOOL SalInfoPrinter::SetPrinterData( Imp
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::SetData( ULONG nFlags, ImplJobSetup* pSetupData )
+BOOL WinSalInfoPrinter::SetData( ULONG nFlags, ImplJobSetup* pSetupData )
 {
 	ImplJobSetupToDevMode( this, pSetupData, nFlags );
 	if ( ImplUpdateSalJobSetup( this, pSetupData, TRUE, NULL ) )
@@ -1103,7 +1101,7 @@ BOOL SalInfoPrinter::SetData( ULONG nFla
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pSetupData )
+ULONG WinSalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pSetupData )
 {
 	DWORD nRet = ImplDeviceCaps( this, DC_BINS, NULL, pSetupData );
 	if ( nRet && (nRet != ((ULONG)-1)) )
@@ -1114,7 +1112,7 @@ ULONG SalInfoPrinter::GetPaperBinCount( 
 
 // -----------------------------------------------------------------------
 
-XubString SalInfoPrinter::GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin )
+XubString WinSalInfoPrinter::GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin )
 {
 // !!! UNICODE - NT Optimierung !!!
 	XubString aPaperBinName;
@@ -1134,7 +1132,7 @@ XubString SalInfoPrinter::GetPaperBinNam
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType )
+ULONG WinSalInfoPrinter::GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType )
 {
 	DWORD nRet;
 
@@ -1185,12 +1183,12 @@ ULONG SalInfoPrinter::GetCapabilities( c
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::GetPageInfo( const ImplJobSetup*,
+void WinSalInfoPrinter::GetPageInfo( const ImplJobSetup*,
 								  long& rOutWidth, long& rOutHeight,
 								  long& rPageOffX, long& rPageOffY,
 								  long& rPageWidth, long& rPageHeight )
 {
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 
 	rOutWidth	= GetDeviceCaps( hDC, HORZRES );
 	rOutHeight	= GetDeviceCaps( hDC, VERTRES );
@@ -1203,16 +1201,16 @@ void SalInfoPrinter::GetPageInfo( const 
 
 // =======================================================================
 
-SalPrinter* SalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
+SalPrinter* WinSalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
 {
-	SalPrinter* pPrinter = new SalPrinter;
-	pPrinter->maPrinterData.mpInfoPrinter = pInfoPrinter;
+	WinSalPrinter* pPrinter = new WinSalPrinter;
+	pPrinter->mpInfoPrinter = static_cast<WinSalInfoPrinter*>(pInfoPrinter);
 	return pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyPrinter( SalPrinter* pPrinter )
+void WinSalInstance::DestroyPrinter( SalPrinter* pPrinter )
 {
 	delete pPrinter;
 }
@@ -1222,7 +1220,7 @@ void SalInstance::DestroyPrinter( SalPri
 WIN_BOOL CALLBACK SalPrintAbortProc( HDC hPrnDC, int /* nError */ )
 {
 	SalData*	pSalData = GetSalData();
-	SalPrinter* pPrinter;
+	WinSalPrinter* pPrinter;
 	BOOL		bWhile = TRUE;
 	int 		i = 0;
 
@@ -1244,13 +1242,13 @@ WIN_BOOL CALLBACK SalPrintAbortProc( HDC
 		pPrinter = pSalData->mpFirstPrinter;
 		while ( pPrinter )
 		{
-			if( pPrinter->maPrinterData.mhDC == hPrnDC )
+			if( pPrinter->mhDC == hPrnDC )
 				break;
 
-			pPrinter = pPrinter->maPrinterData.mpNextPrinter;
+			pPrinter = pPrinter->mpNextPrinter;
 		}
 
-		if ( !pPrinter || pPrinter->maPrinterData.mbAbort )
+		if ( !pPrinter || pPrinter->mbAbort )
 			return FALSE;
 	}
 	while ( bWhile );
@@ -1288,35 +1286,35 @@ static LPDEVMODE ImplSalSetCopies( LPDEV
 
 // -----------------------------------------------------------------------
 
-SalPrinter::SalPrinter()
+WinSalPrinter::WinSalPrinter()
 {
 	SalData* pSalData = GetSalData();
 
-	maPrinterData.mhDC			= 0;
-	maPrinterData.mpGraphics	= NULL;
-	maPrinterData.mbAbort		= FALSE;
-	maPrinterData.mnCopies		= 0;
-	maPrinterData.mbCollate 	= FALSE;
+	mhDC			= 0;
+	mpGraphics	= NULL;
+	mbAbort		= FALSE;
+	mnCopies		= 0;
+	mbCollate 	= FALSE;
 
 	// insert frame in framelist
-	maPrinterData.mpNextPrinter = pSalData->mpFirstPrinter;
+	mpNextPrinter = pSalData->mpFirstPrinter;
 	pSalData->mpFirstPrinter = this;
 }
 
 // -----------------------------------------------------------------------
 
-SalPrinter::~SalPrinter()
+WinSalPrinter::~WinSalPrinter()
 {
 	SalData* pSalData = GetSalData();
 
 	// DC freigeben, wenn er noch durch ein AbortJob existiert
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( hDC )
 	{
-		if ( maPrinterData.mpGraphics )
+		if ( mpGraphics )
 		{
-			ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-			delete maPrinterData.mpGraphics;
+			ImplSalDeInitGraphics( mpGraphics );
+			delete mpGraphics;
 		}
 
 		DeleteDC( hDC );
@@ -1324,30 +1322,30 @@ SalPrinter::~SalPrinter()
 
 	// remove printer from printerlist
 	if ( this == pSalData->mpFirstPrinter )
-		pSalData->mpFirstPrinter = maPrinterData.mpNextPrinter;
+		pSalData->mpFirstPrinter = mpNextPrinter;
 	else
 	{
-		SalPrinter* pTempPrinter = pSalData->mpFirstPrinter;
+		WinSalPrinter* pTempPrinter = pSalData->mpFirstPrinter;
 
-		while( pTempPrinter->maPrinterData.mpNextPrinter != this )
-			pTempPrinter = pTempPrinter->maPrinterData.mpNextPrinter;
+		while( pTempPrinter->mpNextPrinter != this )
+			pTempPrinter = pTempPrinter->mpNextPrinter;
 
-		pTempPrinter->maPrinterData.mpNextPrinter = maPrinterData.mpNextPrinter;
+		pTempPrinter->mpNextPrinter = mpNextPrinter;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::StartJob( const XubString* pFileName,
+BOOL WinSalPrinter::StartJob( const XubString* pFileName,
 						   const XubString& rJobName,
 						   const XubString&,
 						   ULONG nCopies, BOOL bCollate,
 						   ImplJobSetup* pSetupData )
 {
-	maPrinterData.mnError		= 0;
-	maPrinterData.mbAbort		= FALSE;
-	maPrinterData.mnCopies		= nCopies;
-	maPrinterData.mbCollate 	= bCollate;
+	mnError		= 0;
+	mbAbort		= FALSE;
+	mnCopies		= nCopies;
+	mbCollate 	= bCollate;
 
 	LPDEVMODE	pOrgDevMode = NULL;
 	LPDEVMODE	pDevMode;
@@ -1362,15 +1360,15 @@ BOOL SalPrinter::StartJob( const XubStri
 
 // !!! UNICODE - NT Optimierung !!!
 	// #95347 some buggy drivers (eg, OKI) write to those buffers in CreateDC, although declared const - so provide some space
-	ByteString aDriver ( ImplSalGetWinAnsiString( maPrinterData.mpInfoPrinter->maPrinterData.maDriverName, TRUE ) );
-	ByteString aDevice ( ImplSalGetWinAnsiString( maPrinterData.mpInfoPrinter->maPrinterData.maDeviceName, TRUE ) );
-	ByteString aPort   ( ImplSalGetWinAnsiString( maPrinterData.mpInfoPrinter->maPrinterData.maPortName, TRUE ) );
+	ByteString aDriver ( ImplSalGetWinAnsiString( mpInfoPrinter->maDriverName, TRUE ) );
+	ByteString aDevice ( ImplSalGetWinAnsiString( mpInfoPrinter->maDeviceName, TRUE ) );
+	ByteString aPort   ( ImplSalGetWinAnsiString( mpInfoPrinter->maPortName, TRUE ) );
 	int n = aDriver.Len() > aDevice.Len() ? aDriver.Len() : aDevice.Len();
 	n += 2048;
 	char *lpszDriverName = new char[n];
 	char *lpszDeviceName = new char[n];
-	strcpy( lpszDriverName, aDriver.GetBuffer() );
-	strcpy( lpszDeviceName, aDevice.GetBuffer() );
+	strncpy( lpszDriverName, aDriver.GetBuffer(), n );
+	strncpy( lpszDeviceName, aDevice.GetBuffer(), n );
 	HDC hDC = CreateDCA( lpszDriverName,
 						 lpszDeviceName,
                          NULL,
@@ -1384,18 +1382,18 @@ BOOL SalPrinter::StartJob( const XubStri
 
 	if ( !hDC )
 	{
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 
 	if ( SetAbortProc( hDC, SalPrintAbortProc ) <= 0 )
 	{
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 
-	maPrinterData.mnError	= 0;
-	maPrinterData.mbAbort	= FALSE;
+	mnError	= 0;
+	mbAbort	= FALSE;
 
 // !!! UNICODE - NT Optimierung !!!
 	// Both strings must be exist, if StartJob() is called
@@ -1440,10 +1438,10 @@ BOOL SalPrinter::StartJob( const XubStri
 			bWhile = FALSE;
 	}
 	while ( bWhile );
-	ImplPostMessage( GetSalData()->mpFirstInstance->maInstData.mhComWnd, SAL_MSG_DUMMY, 0, 0 );
+	ImplPostMessage( GetSalData()->mpFirstInstance->mhComWnd, SAL_MSG_DUMMY, 0, 0 );
 
     // make sure mhDC is set before the printer driver may call our abortproc
-	maPrinterData.mhDC = hDC;
+	mhDC = hDC;
 
     // bring up a file choser if printing to file port but no file name given
     OString aOutFileName;
@@ -1475,7 +1473,7 @@ BOOL SalPrinter::StartJob( const XubStri
                 }
                 else
                 {
-                    maPrinterData.mnError = SAL_PRINTER_ERROR_ABORT;
+                    mnError = SAL_PRINTER_ERROR_ABORT;
                     return FALSE;
                 }
             }
@@ -1488,9 +1486,9 @@ BOOL SalPrinter::StartJob( const XubStri
 	{
         long nError = GetLastError();
         if ( (nRet == SP_USERABORT) || (nRet == SP_APPABORT) || (nError == ERROR_PRINT_CANCELLED) || (nError == ERROR_CANCELLED) )
-			maPrinterData.mnError = SAL_PRINTER_ERROR_ABORT;
+			mnError = SAL_PRINTER_ERROR_ABORT;
 		else
-			maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+			mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 
@@ -1499,17 +1497,17 @@ BOOL SalPrinter::StartJob( const XubStri
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndJob()
+BOOL WinSalPrinter::EndJob()
 {
 	DWORD err = 0;
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( hDC )
 	{
-		if ( maPrinterData.mpGraphics )
+		if ( mpGraphics )
 		{
-			ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-			delete maPrinterData.mpGraphics;
-			maPrinterData.mpGraphics = NULL;
+			ImplSalDeInitGraphics( mpGraphics );
+			delete mpGraphics;
+			mpGraphics = NULL;
 		}
 
 		if( ::EndDoc( hDC ) <= 0 )
@@ -1522,16 +1520,16 @@ BOOL SalPrinter::EndJob()
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::AbortJob()
+BOOL WinSalPrinter::AbortJob()
 {
-	maPrinterData.mbAbort = TRUE;
+	mbAbort = TRUE;
 
 	// Abort asyncron ausloesen
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( hDC )
 	{
 		SalData* pSalData = GetSalData();
-		ImplPostMessage( pSalData->mpFirstInstance->maInstData.mhComWnd,
+		ImplPostMessage( pSalData->mpFirstInstance->mhComWnd,
 						 SAL_MSG_PRINTABORTJOB, (WPARAM)hDC, 0 );
 	}
 
@@ -1543,28 +1541,28 @@ BOOL SalPrinter::AbortJob()
 void ImplSalPrinterAbortJobAsync( HDC hPrnDC )
 {
 	SalData*	pSalData = GetSalData();
-	SalPrinter* pPrinter = pSalData->mpFirstPrinter;
+	WinSalPrinter* pPrinter = pSalData->mpFirstPrinter;
 
 	// Feststellen, ob Printer noch existiert
 	while ( pPrinter )
 	{
-		if ( pPrinter->maPrinterData.mhDC == hPrnDC )
+		if ( pPrinter->mhDC == hPrnDC )
 			break;
 
-		pPrinter = pPrinter->maPrinterData.mpNextPrinter;
+		pPrinter = pPrinter->mpNextPrinter;
 	}
 
 	// Wenn Printer noch existiert, dann den Job abbrechen
 	if ( pPrinter )
 	{
-		HDC hDC = pPrinter->maPrinterData.mhDC;
+		HDC hDC = pPrinter->mhDC;
 		if ( hDC )
 		{
-			if ( pPrinter->maPrinterData.mpGraphics )
+			if ( pPrinter->mpGraphics )
 			{
-				ImplSalDeInitGraphics( &(pPrinter->maPrinterData.mpGraphics->maGraphicsData) );
-				delete pPrinter->maPrinterData.mpGraphics;
-				pPrinter->maPrinterData.mpGraphics = NULL;
+				ImplSalDeInitGraphics( pPrinter->mpGraphics );
+				delete pPrinter->mpGraphics;
+				pPrinter->mpGraphics = NULL;
 			}
 
 			::AbortDoc( hDC );
@@ -1575,15 +1573,15 @@ void ImplSalPrinterAbortJobAsync( HDC hP
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalPrinter::StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData )
+SalGraphics* WinSalPrinter::StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData )
 {
-	HDC hDC = maPrinterData.mhDC;
+	HDC hDC = mhDC;
 	if ( pSetupData && pSetupData->mpDriverData && bNewJobData )
 	{
 		LPDEVMODE	pOrgDevMode;
 		LPDEVMODE	pDevMode;
 		pOrgDevMode = SAL_DEVMODE( pSetupData );
-		pDevMode = ImplSalSetCopies( pOrgDevMode, maPrinterData.mnCopies, maPrinterData.mbCollate );
+		pDevMode = ImplSalSetCopies( pOrgDevMode, mnCopies, mbCollate );
 		ResetDC( hDC, pDevMode );
 		if ( pDevMode != pOrgDevMode )
 			rtl_freeMemory( pDevMode );
@@ -1592,7 +1590,7 @@ SalGraphics* SalPrinter::StartPage( Impl
 	if ( nRet <= 0 )
 	{
 		DWORD err = GetLastError();
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return NULL;
 	}
 
@@ -1603,28 +1601,28 @@ SalGraphics* SalPrinter::StartPage( Impl
 	SelectPen( hDC, hTempPen );
 	SelectBrush( hDC, hTempBrush );
 
-	SalGraphics* pGraphics = new SalGraphics;
-	pGraphics->maGraphicsData.mhDC		= hDC;
-	pGraphics->maGraphicsData.mhWnd 	= 0;
-	pGraphics->maGraphicsData.mbPrinter = TRUE;
-	pGraphics->maGraphicsData.mbVirDev	= FALSE;
-	pGraphics->maGraphicsData.mbWindow	= FALSE;
-	pGraphics->maGraphicsData.mbScreen	= FALSE;
-	ImplSalInitGraphics( &(pGraphics->maGraphicsData) );
-	maPrinterData.mpGraphics = pGraphics;
+	WinSalGraphics* pGraphics = new WinSalGraphics;
+	pGraphics->mhDC		= hDC;
+	pGraphics->mhWnd 	= 0;
+	pGraphics->mbPrinter = TRUE;
+	pGraphics->mbVirDev	= FALSE;
+	pGraphics->mbWindow	= FALSE;
+	pGraphics->mbScreen	= FALSE;
+	ImplSalInitGraphics( pGraphics );
+	mpGraphics = pGraphics;
 	return pGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndPage()
+BOOL WinSalPrinter::EndPage()
 {
-	HDC hDC = maPrinterData.mhDC;
-	if ( hDC && maPrinterData.mpGraphics )
+	HDC hDC = mhDC;
+	if ( hDC && mpGraphics )
 	{
-		ImplSalDeInitGraphics( &(maPrinterData.mpGraphics->maGraphicsData) );
-		delete maPrinterData.mpGraphics;
-		maPrinterData.mpGraphics = NULL;
+		ImplSalDeInitGraphics( mpGraphics );
+		delete mpGraphics;
+		mpGraphics = NULL;
 	}
 	int nRet = ::EndPage( hDC );
 	if ( nRet > 0 )
@@ -1632,14 +1630,14 @@ BOOL SalPrinter::EndPage()
 	else
 	{
 		DWORD err = GetLastError();
-		maPrinterData.mnError = SAL_PRINTER_ERROR_GENERALERROR;
+		mnError = SAL_PRINTER_ERROR_GENERALERROR;
 		return FALSE;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalPrinter::GetErrorCode()
+ULONG WinSalPrinter::GetErrorCode()
 {
-	return maPrinterData.mnError;
+	return mnError;
 }
Index: vcl/win/source/gdi/salvd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/salvd.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/gdi/salvd.cxx	27 Mar 2003 17:59:23 -0000	1.2
+++ vcl/win/source/gdi/salvd.cxx	6 Jan 2004 14:56:52 -0000	1.4
@@ -63,22 +63,20 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALVD_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 
 // =======================================================================
@@ -98,42 +96,44 @@ static HBITMAP ImplCreateVirDevBitmap( H
 
 // =======================================================================
 
-SalVirtualDevice* SalInstance::CreateVirtualDevice( SalGraphics* pGraphics,
-													long nDX, long nDY,
-													USHORT nBitCount )
+SalVirtualDevice* WinSalInstance::CreateVirtualDevice( SalGraphics* pSGraphics,
+                                                       long nDX, long nDY,
+                                                       USHORT nBitCount )
 {
-	HDC 	hDC 	= CreateCompatibleDC( pGraphics->maGraphicsData.mhDC );
-	HBITMAP hBmp	= ImplCreateVirDevBitmap( pGraphics->maGraphicsData.mhDC,
+    WinSalGraphics* pGraphics = static_cast<WinSalGraphics*>(pSGraphics);
+
+	HDC 	hDC 	= CreateCompatibleDC( pGraphics->mhDC );
+	HBITMAP hBmp	= ImplCreateVirDevBitmap( pGraphics->mhDC,
 											  nDX, nDY, nBitCount );
 
 	if ( hDC && hBmp )
 	{
-		SalVirtualDevice*	pVDev = new SalVirtualDevice;
-		SalData*			pSalData = GetSalData();
-		SalGraphics*		pVirGraphics = new SalGraphicsLayout;
+		WinSalVirtualDevice*	pVDev = new WinSalVirtualDevice;
+		SalData*                pSalData = GetSalData();
+		WinSalGraphics*         pVirGraphics = new WinSalGraphics;
         pVirGraphics->SetLayout( 0 );   // by default no! mirroring for VirtualDevices, can be enabled with EnableRTL()
-		pVirGraphics->maGraphicsData.mhDC	   = hDC;
-		pVirGraphics->maGraphicsData.mhWnd	   = 0;
-		pVirGraphics->maGraphicsData.mbPrinter = FALSE;
-		pVirGraphics->maGraphicsData.mbVirDev  = TRUE;
-		pVirGraphics->maGraphicsData.mbWindow  = FALSE;
-		pVirGraphics->maGraphicsData.mbScreen  = pGraphics->maGraphicsData.mbScreen;
-		if ( pSalData->mhDitherPal && pVirGraphics->maGraphicsData.mbScreen )
+		pVirGraphics->mhDC	   = hDC;
+		pVirGraphics->mhWnd	   = 0;
+		pVirGraphics->mbPrinter = FALSE;
+		pVirGraphics->mbVirDev  = TRUE;
+		pVirGraphics->mbWindow  = FALSE;
+		pVirGraphics->mbScreen  = pGraphics->mbScreen;
+		if ( pSalData->mhDitherPal && pVirGraphics->mbScreen )
 		{
-			pVirGraphics->maGraphicsData.mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
+			pVirGraphics->mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
 			RealizePalette( hDC );
 		}
-		ImplSalInitGraphics( &(pVirGraphics->maGraphicsData) );
+		ImplSalInitGraphics( pVirGraphics );
 
-		pVDev->maVirDevData.mhDC		= hDC;
-		pVDev->maVirDevData.mhBmp		= hBmp;
-		pVDev->maVirDevData.mhDefBmp	= SelectBitmap( hDC, hBmp );
-		pVDev->maVirDevData.mpGraphics	= pVirGraphics;
-		pVDev->maVirDevData.mnBitCount	= nBitCount;
-		pVDev->maVirDevData.mbGraphics	= FALSE;
+		pVDev->mhDC		= hDC;
+		pVDev->mhBmp		= hBmp;
+		pVDev->mhDefBmp	= SelectBitmap( hDC, hBmp );
+		pVDev->mpGraphics	= pVirGraphics;
+		pVDev->mnBitCount	= nBitCount;
+		pVDev->mbGraphics	= FALSE;
 
 		// insert VirDev in VirDevList
-		pVDev->maVirDevData.mpNext = pSalData->mpFirstVD;
+		pVDev->mpNext = pSalData->mpFirstVD;
 		pSalData->mpFirstVD = pVDev;
 
 		return pVDev;
@@ -150,76 +150,76 @@ SalVirtualDevice* SalInstance::CreateVir
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
+void WinSalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
 {
 	delete pDevice;
 }
 
 // =======================================================================
 
-SalVirtualDevice::SalVirtualDevice()
+WinSalVirtualDevice::WinSalVirtualDevice()
 {
 }
 
 // -----------------------------------------------------------------------
 
-SalVirtualDevice::~SalVirtualDevice()
+WinSalVirtualDevice::~WinSalVirtualDevice()
 {
 	SalData* pSalData = GetSalData();
 
 	// destroy saved DC
-	if ( maVirDevData.mpGraphics->maGraphicsData.mhDefPal )
-		SelectPalette( maVirDevData.mpGraphics->maGraphicsData.mhDC, maVirDevData.mpGraphics->maGraphicsData.mhDefPal, TRUE );
-	ImplSalDeInitGraphics( &(maVirDevData.mpGraphics->maGraphicsData) );
-	SelectBitmap( maVirDevData.mpGraphics->maGraphicsData.mhDC, maVirDevData.mhDefBmp );
-	DeleteDC( maVirDevData.mpGraphics->maGraphicsData.mhDC );
-	DeleteBitmap( maVirDevData.mhBmp );
-	delete maVirDevData.mpGraphics;
+	if ( mpGraphics->mhDefPal )
+		SelectPalette( mpGraphics->mhDC, mpGraphics->mhDefPal, TRUE );
+	ImplSalDeInitGraphics( mpGraphics );
+	SelectBitmap( mpGraphics->mhDC, mhDefBmp );
+	DeleteDC( mpGraphics->mhDC );
+	DeleteBitmap( mhBmp );
+	delete mpGraphics;
 
 	// remove VirDev from VirDevList
 	if ( this == pSalData->mpFirstVD )
-		pSalData->mpFirstVD = maVirDevData.mpNext;
+		pSalData->mpFirstVD = mpNext;
 	else
 	{
-		SalVirtualDevice* pTempVD = pSalData->mpFirstVD;
-		while ( pTempVD->maVirDevData.mpNext != this )
-			pTempVD = pTempVD->maVirDevData.mpNext;
+		WinSalVirtualDevice* pTempVD = pSalData->mpFirstVD;
+		while ( pTempVD->mpNext != this )
+			pTempVD = pTempVD->mpNext;
 
-		pTempVD->maVirDevData.mpNext = maVirDevData.mpNext;
+		pTempVD->mpNext = mpNext;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalVirtualDevice::GetGraphics()
+SalGraphics* WinSalVirtualDevice::GetGraphics()
 {
-	if ( maVirDevData.mbGraphics )
+	if ( mbGraphics )
 		return NULL;
 
-	if ( maVirDevData.mpGraphics )
-		maVirDevData.mbGraphics = TRUE;
+	if ( mpGraphics )
+		mbGraphics = TRUE;
 
-	return maVirDevData.mpGraphics;
+	return mpGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-void SalVirtualDevice::ReleaseGraphics( SalGraphics* )
+void WinSalVirtualDevice::ReleaseGraphics( SalGraphics* )
 {
-	maVirDevData.mbGraphics = FALSE;
+	mbGraphics = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalVirtualDevice::SetSize( long nDX, long nDY )
+BOOL WinSalVirtualDevice::SetSize( long nDX, long nDY )
 {
-	HBITMAP hNewBmp = ImplCreateVirDevBitmap( maVirDevData.mhDC, nDX, nDY,
-											  maVirDevData.mnBitCount );
+	HBITMAP hNewBmp = ImplCreateVirDevBitmap( mhDC, nDX, nDY,
+											  mnBitCount );
 	if ( hNewBmp )
 	{
-		SelectBitmap( maVirDevData.mhDC, hNewBmp );
-		DeleteBitmap( maVirDevData.mhBmp );
-		maVirDevData.mhBmp = hNewBmp;
+		SelectBitmap( mhDC, hNewBmp );
+		DeleteBitmap( mhBmp );
+		mhBmp = hNewBmp;
 		return TRUE;
 	}
 	else
Index: vcl/win/source/gdi/winlayout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/gdi/winlayout.cxx,v
retrieving revision 1.71.12.3
retrieving revision 1.80
diff -u -p -u -r1.71.12.3 -r1.80
--- vcl/win/source/gdi/winlayout.cxx	15 Jan 2004 12:55:41 -0000	1.71.12.3
+++ vcl/win/source/gdi/winlayout.cxx	18 Jun 2004 15:06:52 -0000	1.80
@@ -63,8 +63,8 @@
 #include <tools/svwin.h>
 #endif
 
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif // _SV_SALGDI_HXX
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
@@ -152,6 +152,7 @@ private:
     int*            mpCharWidths;   // map rel char pos to char width
     int*            mpChars2Glyphs; // map rel char pos to abs glyph pos
     int*            mpGlyphs2Chars; // map abs glyph pos to abs char pos
+    bool*           mpGlyphRTLFlags;// BiDi status for glyphs: true=>RTL
     mutable long    mnWidth;
     bool            mbDisableGlyphs;
 
@@ -211,6 +212,7 @@ SimpleWinLayout::SimpleWinLayout( HDC hD
     mpCharWidths( NULL ),
     mpChars2Glyphs( NULL ),
     mpGlyphs2Chars( NULL ),
+    mpGlyphRTLFlags( NULL ),
     mnWidth( 0 ),
     mnNotdefWidth( -1 ),
     mnCharSet( nCharSet ),
@@ -224,6 +226,7 @@ SimpleWinLayout::SimpleWinLayout( HDC hD
 
 SimpleWinLayout::~SimpleWinLayout()
 {
+    delete[] mpGlyphRTLFlags;
     delete[] mpGlyphs2Chars;
     delete[] mpChars2Glyphs;
     if( mpCharWidths != mpGlyphAdvances )
@@ -240,6 +243,7 @@ bool SimpleWinLayout::LayoutText( ImplLa
     // prepare layout
     // TODO: fix case when reusing object
     mbDisableGlyphs |= ((rArgs.mnFlags & SAL_LAYOUT_DISABLE_GLYPH_PROCESSING) != 0);
+    mnCharCount = rArgs.mnEndCharPos - rArgs.mnMinCharPos;
 
     // TODO: use a cached value for bDisableGlyphs from upper layers font info
     if( !mbDisableGlyphs )
@@ -258,11 +262,12 @@ bool SimpleWinLayout::LayoutText( ImplLa
             ||  !(aTextMetricA.tmPitchAndFamily & TMPF_TRUETYPE)
             ||   (aTextMetricA.tmPitchAndFamily & TMPF_DEVICE) )
                 mbDisableGlyphs = true;
-#if 0 // #110548# more important than #107885# => TODO: better solution
+/*
+			// #110548# more important than #107885# => TODO: better solution
             DWORD nFLI = GetFontLanguageInfo( mhDC );
             if( !(nFLI & GCP_GLYPHSHAPE) )
                 mbDisableGlyphs = true;
-#endif
+*/
         }
     }
 
@@ -277,19 +282,26 @@ bool SimpleWinLayout::LayoutText( ImplLa
 
     // layout text
     int i, j;
-    
+
     mnGlyphCount = 0;
     bool bVertical = (rArgs.mnFlags & SAL_LAYOUT_VERTICAL) != 0;
     if( !bVertical )
     {
         // count chars to process as LTR
         rArgs.ResetPos();
-        for( bool bRTL; rArgs.GetNextRun( &i, &j, &bRTL ) && !bRTL; )
+		bool bRTL;
+        for( bRTL; rArgs.GetNextRun( &i, &j, &bRTL ) && !bRTL; )
             mnGlyphCount += j - i;
+        // if there are RTL runs we need room to remember the RTL status
+        if( bRTL )
+        {
+            mpGlyphRTLFlags = new bool[ mnCharCount ];
+            for( i = 0; i < mnCharCount; ++i )
+                mpGlyphRTLFlags[i] = false;
+        }
     }
 
     const sal_Unicode* pBidiStr;
-    mnCharCount = rArgs.mnEndCharPos - rArgs.mnMinCharPos;
     if( mnGlyphCount == mnCharCount )
         pBidiStr = rArgs.mpStr + rArgs.mnMinCharPos;
     else
@@ -314,6 +326,7 @@ bool SimpleWinLayout::LayoutText( ImplLa
                     sal_Unicode cChar = rArgs.mpStr[ --j ];
                     pStr[ mnGlyphCount ] = ::GetMirroredChar( cChar );
                     mpChars2Glyphs[ j - rArgs.mnMinCharPos ] = mnGlyphCount;
+                    mpGlyphRTLFlags[ mnGlyphCount ] = true;
                     mpGlyphs2Chars[ mnGlyphCount++ ] = j;
                 } while( i < j );
             }
@@ -480,7 +493,7 @@ bool SimpleWinLayout::LayoutText( ImplLa
         }
 
         // request fallback
-        bool bRTL = false;  // TODO: get from run
+        bool bRTL = mpGlyphRTLFlags ? mpGlyphRTLFlags[i] : false;
         int nCharPos = mpGlyphs2Chars ? mpGlyphs2Chars[i]: i + rArgs.mnMinCharPos;
         rArgs.NeedFallback( nCharPos, bRTL );
 
@@ -608,8 +621,6 @@ bool SimpleWinLayout::HasGSUBstitutions(
     if( !pTTFont )
         return false;
 
-    mrGSUBList.erase( -1 ); // remove "no GSUB in font" mark
-
     // add vertically substituted characters to list
     static sal_Unicode aGSUBCandidates[] = {
         0x0020, 0x0080, // ASCII
@@ -619,12 +630,21 @@ bool SimpleWinLayout::HasGSUBstitutions(
         0xFF00, 0xFFF0, // halfwidth|fullwidth forms
     0 };
 
+    bool bHasGSUB = false;
     for( sal_Unicode* pPair = aGSUBCandidates; *pPair; pPair += 2 )
         for( sal_Unicode c = pPair[0]; c < pPair[1]; ++c )
             if( MapChar( pTTFont, c, 0 ) != MapChar( pTTFont, c, 1 ) )
+            {
+                if( !bHasGSUB )
+                {
+                    mrGSUBList.erase( -1 ); // remove "no GSUB in font" mark
+                    bHasGSUB = true;
+                }
                 mrGSUBList.insert( c ); // insert GSUBbed unicodes
+            }
 
     CloseTTFont( pTTFont );
+    return bHasGSUB;
 }
 
 // -----------------------------------------------------------------------
@@ -712,7 +732,7 @@ void SimpleWinLayout::DrawText( SalGraph
     if( mnGlyphCount <= 0 )
         return;
 
-    HDC aHDC = rGraphics.maGraphicsData.mhDC;
+    HDC aHDC = static_cast<WinSalGraphics&>(rGraphics).mhDC;
 
     UINT mnDrawOptions = ETO_GLYPH_INDEX;
     if( mbDisableGlyphs )
@@ -721,11 +741,7 @@ void SimpleWinLayout::DrawText( SalGraph
     Point aPos = GetDrawPosition( Point( mnBaseAdv, 0 ) );
 
      // #108267#, limit the number of glyphs to avoid paint errors
-#if (_MSC_VER < 1300)
-    UINT limitedGlyphCount = std::min( 8192, mnGlyphCount );
-#else
-     UINT limitedGlyphCount = min( 8192, mnGlyphCount );
-#endif
+    UINT limitedGlyphCount = Min( 8192, mnGlyphCount );
    // #108267#, break up into glyph portions of a limited size required by Win32 API
     const unsigned int maxGlyphCount = 8192;
     UINT numGlyphPortions = mnGlyphCount / maxGlyphCount;
@@ -741,13 +757,13 @@ void SimpleWinLayout::DrawText( SalGraph
             POINT oldPos;
             UINT oldTa = ::GetTextAlign( aHDC );
             ::SetTextAlign( aHDC, (oldTa & ~TA_NOUPDATECP) | TA_UPDATECP );
-            ::MoveToEx( aHDC, aPos.X(), aPos.Y(), &oldPos ); 
+            ::MoveToEx( aHDC, aPos.X(), aPos.Y(), &oldPos );
             for( i=n=0; n<numGlyphPortions; n++, i+=maxGlyphCount )
                 ::ExtTextOutW( aHDC, 0, 0, mnDrawOptions, NULL,
                     mpOutGlyphs+i, maxGlyphCount, mpGlyphAdvances+i );
             ::ExtTextOutW( aHDC, 0, 0, mnDrawOptions, NULL,
                 mpOutGlyphs+i, remainingGlyphs, mpGlyphAdvances+i );
-            ::MoveToEx( aHDC, oldPos.x, oldPos.y, (LPPOINT) NULL); 
+            ::MoveToEx( aHDC, oldPos.x, oldPos.y, (LPPOINT) NULL);
             ::SetTextAlign( aHDC, oldTa );
         }
         else
@@ -844,13 +860,12 @@ void SimpleWinLayout::GetCaretPositions(
             pCaretXArray[ i ] = -1;
 
         // assign glyph positions to character positions
-        int nLeftIdx = 0;
         for( i = 0; i < mnGlyphCount; ++i )
         {
             int nCurrIdx = mpGlyphs2Chars[ i ] - mnMinCharPos;
             long nXRight = nXPos + mpCharWidths[ nCurrIdx ];
             nCurrIdx *= 2;
-            if( nLeftIdx <= nCurrIdx )
+            if( !(mpGlyphRTLFlags && mpGlyphRTLFlags[i]) )
             {
                 // normal positions for LTR case
                 pCaretXArray[ nCurrIdx ]   = nXPos;
@@ -862,7 +877,6 @@ void SimpleWinLayout::GetCaretPositions(
                 pCaretXArray[ nCurrIdx ]   = nXRight;
                 pCaretXArray[ nCurrIdx+1 ] = nXPos;
             }
-            nLeftIdx = nCurrIdx;
             nXPos += mpGlyphAdvances[ i ];
         }
     }
@@ -881,20 +895,27 @@ void SimpleWinLayout::Justify( long nNew
     if( nNewWidth == nOldWidth )
         return;
 
-    int i = mnGlyphCount - 1;
     // the rightmost glyph cannot be stretched
-    nOldWidth -= mpGlyphAdvances[i];
-    nNewWidth -= mpGlyphAdvances[i];
-
-    // stretch remaining glyphs to new width
-    while( --i >= 0 )
+    const int nRight = mnGlyphCount - 1;
+    nOldWidth -= mpGlyphAdvances[ nRight ];
+    nNewWidth -= mpGlyphAdvances[ nRight ];
+
+    // count stretchable glyphs
+    int nStretchable = 0, i;
+    for( i = 0; i < nRight; ++i )
+        if( mpGlyphAdvances[i] >= 0 )
+            ++nStretchable;
+
+    // stretch these glyphs
+    int nDiffWidth = nNewWidth - nOldWidth;
+    for( i = 0; (i < nRight) && (nStretchable > 0); ++i )
     {
-        if( nNewWidth < 0 )
-            nNewWidth = 0;
-        double fStretch = (nOldWidth<0) ? 0.0 : (double)nNewWidth / nOldWidth;
-        nOldWidth -= mpGlyphAdvances[i];
-        mpGlyphAdvances[i] = (long)(mpGlyphAdvances[i] * fStretch + 0.5);
-        nNewWidth -= mpGlyphAdvances[i];
+        if( mpGlyphAdvances[i] <= 0 )
+            continue;
+        int nDeltaWidth = nDiffWidth / nStretchable;
+        mpGlyphAdvances[i] += nDeltaWidth;
+        --nStretchable;
+        nDiffWidth -= nDeltaWidth;
     }
 }
 
@@ -946,20 +967,19 @@ void SimpleWinLayout::ApplyDXArray( cons
 
     int i = 0;
     long nOldWidth = mnBaseAdv;
-    for(; i < mnGlyphCount; ++i )
+    for(; i < mnCharCount; ++i )
     {
         int j = !mpChars2Glyphs ? i : mpChars2Glyphs[i];
         if( j >= 0 )
         {
             nOldWidth += mpGlyphAdvances[ j ];
             int nDiff = nOldWidth - pDXArray[ i ];
-#if 0       // disabled because of #104768#
+
+	       // disabled because of #104768#
             // works great for static text, but problems when typing
-            if( nDiff>+1 || nDiff<-1 )
-#else
+            // if( nDiff>+1 || nDiff<-1 )
             // only bother with changing anything when something moved
             if( nDiff != 0 )
-#endif
                 break;
         }
     }
@@ -974,7 +994,7 @@ void SimpleWinLayout::ApplyDXArray( cons
     }
 
     mnWidth = mnBaseAdv;
-    for( i = 0; i < mnGlyphCount; ++i )
+    for( i = 0; i < mnCharCount; ++i )
     {
         int j = !mpChars2Glyphs ? i : mpChars2Glyphs[i];
         if( j >= 0 )
@@ -1056,7 +1076,7 @@ void SimpleWinLayout::Simplify( bool bIs
     // keep original widths around
     if( !mpGlyphOrigAdvs )
     {
-        mpGlyphOrigAdvs = new int[ mnGlyphCount ]; 
+        mpGlyphOrigAdvs = new int[ mnGlyphCount ];
         for( int k = 0; k < mnGlyphCount; ++k )
             mpGlyphOrigAdvs[ k ] = mpGlyphAdvances[ k ];
     }
@@ -1863,7 +1883,8 @@ void UniscribeLayout::MoveGlyph( int nSt
     long nDelta = nNewXPos - pVI->mnXOffset;
     if( nStart > nMinGlyphPos )
     {
-        for( int i = nMinGlyphPos; i < nStart; ++i )
+		int i;
+        for( i = nMinGlyphPos; i < nStart; ++i )
             nDelta -= mpGlyphAdvances[ i ];
         mpGlyphAdvances[ i-1 ] += nDelta;
     }
@@ -2166,7 +2187,8 @@ void UniscribeLayout::ApplyDXArray( cons
     bool bModified = false;
     int nOldWidth = 0;
     DBG_ASSERT( mnUnitsPerPixel==1, "UniscribeLayout.mnUnitsPerPixel != 1" );
-    for( int i = mnMinCharPos, j = 0; i < mnEndCharPos; ++i, ++j )
+	int i,j;
+    for( i = mnMinCharPos, j = 0; i < mnEndCharPos; ++i, ++j )
     {
         int nNewCharWidth = (pDXArray[j] - nOldWidth);
         // TODO: nNewCharWidth *= mnUnitsPerPixel;
@@ -2292,8 +2314,8 @@ void UniscribeLayout::Justify( long nNew
                 mpVisualAttrs + rVisualItem.mnMinGlyphPos,
                 mpGlyphAdvances + rVisualItem.mnMinGlyphPos,
                 rVisualItem.mnEndGlyphPos - rVisualItem.mnMinGlyphPos,
-                nItemWidth, 
-                nMinKashida, 
+                nItemWidth,
+                nMinKashida,
                 mpJustifications + rVisualItem.mnMinGlyphPos );
 
             rVisualItem.mnXOffset = nXOffset;
@@ -2318,7 +2340,7 @@ public:
     virtual ~WinTextLayoutCache() { flush( 0 ); }
     virtual void flush( int nMinLevel );
 
-// public access only visible to SalGraphics::GetTextLayout()
+// public access only visible to WinSalGraphics::GetTextLayout()
 #ifdef GNG_VERT_HACK
     GSUBList maGSUBLists[ MAX_FALLBACK ];
 #endif // GNG_VERT_HACK
@@ -2356,15 +2378,15 @@ void WinTextLayoutCache::flush( int nMin
 
 // =======================================================================
 
-SalLayout* SalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
+SalLayout* WinSalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
 {
     WinLayout* pWinLayout = NULL;
 
-    WinTextLayoutCache* pCache = (WinTextLayoutCache*)maGraphicsData.mxTextLayoutCache.get();
+    WinTextLayoutCache* pCache = (WinTextLayoutCache*)mxTextLayoutCache.get();
     if( !pCache )
     {
         pCache = new WinTextLayoutCache;
-        maGraphicsData.mxTextLayoutCache.reset( pCache );
+        mxTextLayoutCache.reset( pCache );
     }
 
 #ifdef USE_UNISCRIBE
@@ -2373,7 +2395,7 @@ SalLayout* SalGraphics::GetTextLayout( I
     {
         // script complexity is determined in upper layers
         SCRIPT_CACHE& rScriptCache = pCache->maScriptCache[ nFallbackLevel ];
-        pWinLayout = new UniscribeLayout( maGraphicsData.mhDC, rScriptCache );
+        pWinLayout = new UniscribeLayout( mhDC, rScriptCache );
         // NOTE: it must be guaranteed that the SalGraphics lives longer than
         // the created UniscribeLayout, otherwise the data passed into the
         // constructor might become invalid too early
@@ -2382,7 +2404,7 @@ SalLayout* SalGraphics::GetTextLayout( I
 #endif // USE_UNISCRIBE
     {
 #ifdef GCP_KERN_HACK
-        if( (rArgs.mnFlags & SAL_LAYOUT_KERNING_PAIRS) && maGraphicsData.mbFontKernInit )
+        if( (rArgs.mnFlags & SAL_LAYOUT_KERNING_PAIRS) && mbFontKernInit )
             GetKernPairs( 0, NULL );
 #endif // GCP_KERN_HACK
 
@@ -2391,11 +2413,11 @@ SalLayout* SalGraphics::GetTextLayout( I
 #endif // GNG_VERT_HACK
 
         BYTE eCharSet = ANSI_CHARSET;
-        if( maGraphicsData.mpLogFont )
-            eCharSet = maGraphicsData.mpLogFont->lfCharSet;
-        pWinLayout = new SimpleWinLayout( maGraphicsData.mhDC, eCharSet
+        if( mpLogFont )
+            eCharSet = mpLogFont->lfCharSet;
+        pWinLayout = new SimpleWinLayout( mhDC, eCharSet
 #ifdef GCP_KERN_HACK
-            , maGraphicsData.mpFontKernPairs, maGraphicsData.mnFontKernPairCount
+            , mpFontKernPairs, mnFontKernPairCount
 #endif // GCP_KERN_HACK
 #ifdef GNG_VERT_HACK
             , rGSUBList
Index: vcl/win/source/src/50.bmp
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/src/50.bmp,v
retrieving revision 1.1.1.1
retrieving revision 1.1
diff -u -p -u -r1.1.1.1 -r1.1
Index: vcl/win/source/src/50.png
===================================================================
RCS file: vcl/win/source/src/50.png
diff -N vcl/win/source/src/50.png
--- vcl/win/source/src/MAKEFILE.MK	20 Nov 2002 12:36:27 -0000	1.4
+++ vcl/win/source/src/MAKEFILE.MK	20 Oct 2003 17:50:28 -0000	1.5
Index: vcl/win/source/window/MAKEFILE.MK
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/window/MAKEFILE.MK,v
retrieving revision 1.2
retrieving revision 1.7
diff -u -p -u -r1.2 -r1.7
--- vcl/win/source/window/MAKEFILE.MK	20 Nov 2002 12:36:25 -0000	1.2
+++ vcl/win/source/window/MAKEFILE.MK	10 May 2004 16:02:37 -0000	1.7
@@ -29,12 +78,9 @@ CFLAGS += -DWINVER=0x0400
 # --- Files --------------------------------------------------------
 
 SLOFILES=	$(SLO)$/salframe.obj	\
+			$(SLO)$/salmenu.obj     \
 			$(SLO)$/salobj.obj
-
-.IF "$(UPDATER)"=="YES"
-OBJFILES=	$(OBJ)$/salframe.obj	\
-			$(OBJ)$/salobj.obj
-.ENDIF
+			
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/win/source/window/salframe.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/window/salframe.cxx,v
retrieving revision 1.94.112.4
retrieving revision 1.106
diff -u -p -u -r1.94.112.4 -r1.106
--- vcl/win/source/window/salframe.cxx	15 Jan 2004 14:21:12 -0000	1.94.112.4
+++ vcl/win/source/window/salframe.cxx	17 Jun 2004 16:12:04 -0000	1.106
@@ -70,8 +70,6 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALFRAME_CXX
-
 #ifndef _RTL_STRING_H_
 #include <rtl/string.h>
 #endif
@@ -96,25 +94,30 @@
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 #ifndef _SV_SALSYS_HXX
 #include <salsys.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
+#endif
+#ifndef _SV_SALMENU_H
+#include <salmenu.h>
+#endif
+#ifndef _SV_IMPBMP_HXX
+#include <impbmp.hxx>
 #endif
-
 #ifndef _SV_TIMER_HXX
 #include <timer.hxx>
 #endif
@@ -148,17 +151,13 @@ extern "C" {
     typedef BOOL ( WINAPI * SetLayeredWindowAttributes_Proc_T ) (HWND,COLORREF,BYTE,DWORD);
     static SetLayeredWindowAttributes_Proc_T lpfnSetLayeredWindowAttributes;
 };
-#define LWA_COLORKEY            0x00000001
-#define LWA_ALPHA               0x00000002
-#define ULW_COLORKEY            0x00000001
-#define ULW_ALPHA               0x00000002
-#define ULW_OPAQUE              0x00000004
-#define WS_EX_LAYERED           0x00080000
 
 // =======================================================================
 
 const unsigned int WM_USER_SYSTEM_WINDOW_ACTIVATED = RegisterWindowMessageA("SYSTEM_WINDOW_ACTIVATED");
 
+BOOL WinSalFrame::mbInReparent = FALSE;
+
 // =======================================================================
 
 // Wegen Fehler in Windows-Headerfiles
@@ -169,70 +168,62 @@ const unsigned int WM_USER_SYSTEM_WINDOW
 #define IMN_CLOSECANDIDATE              0x0004
 #endif
 
+#ifndef WM_THEMECHANGED
+#define WM_THEMECHANGED                 0x031A
+#endif
+
 // Macros for support of WM_UNICHAR & Keyman 6.0
 #define Uni_UTF32ToSurrogate1(ch)   (((unsigned long) (ch) - 0x10000) / 0x400 + 0xD800)
 #define Uni_UTF32ToSurrogate2(ch)   (((unsigned long) (ch) - 0x10000) % 0x400 + 0xDC00)
 #define Uni_SupplementaryPlanesStart    0x10000
-#ifndef WM_UNICHAR
-#define WM_UNICHAR          0x0109
-#define UNICODE_NOCHAR      0xFFFF
-#endif
-
-#if OSL_DEBUG_LEVEL > 1
-void MyOutputDebugString(const char *buffer)
-{
-    OutputDebugString( buffer );
-}
-#endif
 
 // =======================================================================
-BOOL SalFrame::mbInReparent = FALSE;
 
 static void UpdateFrameGeometry( HWND hWnd, SalFrame* pFrame );
 
-static void ImplSaveFrameState( SalFrame* pFrame )
+static void ImplSaveFrameState( WinSalFrame* pFrame )
 {
     // Position, Groesse und Status fuer GetWindowState() merken
-    if ( !pFrame->maFrameData.mbFullScreen )
+    if ( !pFrame->mbFullScreen )
     {
-        BOOL bVisible = (GetWindowStyle( pFrame->maFrameData.mhWnd ) & WS_VISIBLE) != 0;
-        if ( IsIconic( pFrame->maFrameData.mhWnd ) )
+        BOOL bVisible = (GetWindowStyle( pFrame->mhWnd ) & WS_VISIBLE) != 0;
+        if ( IsIconic( pFrame->mhWnd ) )
         {
-            pFrame->maFrameData.maState.mnState |= SAL_FRAMESTATE_MINIMIZED;
+            pFrame->maState.mnState |= SAL_FRAMESTATE_MINIMIZED;
             if ( bVisible )
-                pFrame->maFrameData.mnShowState = SW_SHOWMAXIMIZED;
+                pFrame->mnShowState = SW_SHOWMAXIMIZED;
         }
-        else if ( IsZoomed( pFrame->maFrameData.mhWnd ) )
+        else if ( IsZoomed( pFrame->mhWnd ) )
         {
-            pFrame->maFrameData.maState.mnState &= ~SAL_FRAMESTATE_MINIMIZED;
-            pFrame->maFrameData.maState.mnState |= SAL_FRAMESTATE_MAXIMIZED;
+            pFrame->maState.mnState &= ~SAL_FRAMESTATE_MINIMIZED;
+            pFrame->maState.mnState |= SAL_FRAMESTATE_MAXIMIZED;
             if ( bVisible )
-                pFrame->maFrameData.mnShowState = SW_SHOWMAXIMIZED;
-            pFrame->maFrameData.mbRestoreMaximize = TRUE;
+                pFrame->mnShowState = SW_SHOWMAXIMIZED;
+            pFrame->mbRestoreMaximize = TRUE;
         }
         else
         {
             RECT aRect;
-            GetWindowRect( pFrame->maFrameData.mhWnd, &aRect );
+            GetWindowRect( pFrame->mhWnd, &aRect );
 
             // to be consistent with Unix, the frame state is without(!) decoration
             RECT aRect2 = aRect;
-		    AdjustWindowRectEx( &aRect2, GetWindowStyle( pFrame->maFrameData.mhWnd ),
-							FALSE,     GetWindowExStyle( pFrame->maFrameData.mhWnd ) );
+		    AdjustWindowRectEx( &aRect2, GetWindowStyle( pFrame->mhWnd ),
+							FALSE,     GetWindowExStyle( pFrame->mhWnd ) );
             long nTopDeco = abs( aRect.top - aRect2.top );
             long nLeftDeco = abs( aRect.left - aRect2.left );
             long nBottomDeco = abs( aRect.bottom - aRect2.bottom );
             long nRightDeco = abs( aRect.right - aRect2.right );
 
-            pFrame->maFrameData.maState.mnState &= ~(SAL_FRAMESTATE_MINIMIZED | SAL_FRAMESTATE_MAXIMIZED);
+            pFrame->maState.mnState &= ~(SAL_FRAMESTATE_MINIMIZED | SAL_FRAMESTATE_MAXIMIZED);
             // subtract decoration
-            pFrame->maFrameData.maState.mnX      = aRect.left+nLeftDeco;
-            pFrame->maFrameData.maState.mnY      = aRect.top+nTopDeco;
-            pFrame->maFrameData.maState.mnWidth  = aRect.right-aRect.left-nLeftDeco-nRightDeco;
-            pFrame->maFrameData.maState.mnHeight = aRect.bottom-aRect.top-nTopDeco-nBottomDeco;
+            pFrame->maState.mnX      = aRect.left+nLeftDeco;
+            pFrame->maState.mnY      = aRect.top+nTopDeco;
+            pFrame->maState.mnWidth  = aRect.right-aRect.left-nLeftDeco-nRightDeco;
+            pFrame->maState.mnHeight = aRect.bottom-aRect.top-nTopDeco-nBottomDeco;
             if ( bVisible )
-                pFrame->maFrameData.mnShowState = SW_SHOWNORMAL;
-            pFrame->maFrameData.mbRestoreMaximize = FALSE;
+                pFrame->mnShowState = SW_SHOWNORMAL;
+            pFrame->mbRestoreMaximize = FALSE;
         }
     }
 }
@@ -240,17 +231,17 @@ static void ImplSaveFrameState( SalFrame
 // -----------------------------------------------------------------------
 
 // if pParentRect is set, the workarea of the monitor that contains pParentRect is returned
-static void ImplSalGetWorkArea( HWND hWnd, RECT *pRect, const RECT *pParentRect )
+void ImplSalGetWorkArea( HWND hWnd, RECT *pRect, const RECT *pParentRect )
 {
 	static int winVerChecked = 0;
 	static int winVerOk = 0;
 
     // check if we or our parent is fullscreen, then the taskbar should be ignored
     bool bIgnoreTaskbar = false;
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
 	if( pFrame )
     {
-	    Window *pWin = ((Window*)pFrame->maFrameData.mpInst);
+	    Window *pWin = ((Window*)pFrame->GetInstance());
         while( pWin )
         {
             WorkWindow *pWorkWin = (pWin->GetType() == WINDOW_WORKWINDOW) ? (WorkWindow *) pWin : NULL;
@@ -364,10 +355,10 @@ static void ImplSalGetWorkArea( HWND hWn
 
 // =======================================================================
 
-SalFrame* ImplSalCreateFrame( SalInstance* pInst,
+SalFrame* ImplSalCreateFrame( WinSalInstance* pInst,
                               HWND hWndParent, ULONG nSalFrameStyle )
 {
-    SalFrame*   pFrame = new SalFrame;
+    WinSalFrame*   pFrame = new WinSalFrame;
     HWND        hWnd;
     DWORD       nSysStyle = 0;
     DWORD       nExSysStyle = 0;
@@ -400,7 +391,7 @@ SalFrame* ImplSalCreateFrame( SalInstanc
         {
             nSysStyle |= WS_POPUP;
             bSubFrame = TRUE;
-            pFrame->maFrameData.mbNoIcon = TRUE;
+            pFrame->mbNoIcon = TRUE;
         }
         else
         {
@@ -418,7 +409,7 @@ SalFrame* ImplSalCreateFrame( SalInstanc
 
         if ( nSalFrameStyle & SAL_FRAME_STYLE_MOVEABLE )
         {
-            pFrame->maFrameData.mbCaption = TRUE;
+            pFrame->mbCaption = TRUE;
             nSysStyle |= WS_SYSMENU | WS_CAPTION;
             if ( !hWndParent )
                 nSysStyle |= WS_SYSMENU | WS_MINIMIZEBOX;
@@ -427,13 +418,13 @@ SalFrame* ImplSalCreateFrame( SalInstanc
 
             if ( nSalFrameStyle & SAL_FRAME_STYLE_SIZEABLE )
             {
-                pFrame->maFrameData.mbSizeBorder = TRUE;
+                pFrame->mbSizeBorder = TRUE;
                 nSysStyle |= WS_THICKFRAME;
                 if ( !hWndParent )
                     nSysStyle |= WS_MAXIMIZEBOX;
             }
             else
-                pFrame->maFrameData.mbFixBorder = TRUE;
+                pFrame->mbFixBorder = TRUE;
 
             if ( nSalFrameStyle & SAL_FRAME_STYLE_DEFAULT )
                 nExSysStyle |= WS_EX_APPWINDOW;
@@ -447,7 +438,7 @@ SalFrame* ImplSalCreateFrame( SalInstanc
             // #103578# looked too bad - above changes reverted
             /* && !(nSalFrameStyle & SAL_FRAME_STYLE_SIZEABLE) */ )
         {
-            pFrame->maFrameData.mbNoIcon = TRUE;
+            pFrame->mbNoIcon = TRUE;
             nExSysStyle |= WS_EX_TOOLWINDOW;
             if ( pEnvTransparentFloats && bLayeredAPI == 1 /*&& !(nSalFrameStyle & SAL_FRAME_STYLE_MOVEABLE) */)
                 nExSysStyle |= WS_EX_LAYERED;
@@ -456,7 +447,7 @@ SalFrame* ImplSalCreateFrame( SalInstanc
     if ( nSalFrameStyle & SAL_FRAME_STYLE_FLOAT )
     {
         nExSysStyle |= WS_EX_TOOLWINDOW;
-        pFrame->maFrameData.mbFloatWin = TRUE;
+        pFrame->mbFloatWin = TRUE;
 
         if ( pEnvTransparentFloats && bLayeredAPI == 1 /*&& !(nSalFrameStyle & SAL_FRAME_STYLE_MOVEABLE) */)
             nExSysStyle |= WS_EX_LAYERED;
@@ -466,31 +457,31 @@ SalFrame* ImplSalCreateFrame( SalInstanc
         nExSysStyle |= WS_EX_TOPMOST;
 
     // init frame data
-    pFrame->maFrameData.mnStyle = nSalFrameStyle;
+    pFrame->mnStyle = nSalFrameStyle;
 
     // determine show style
-    pFrame->maFrameData.mnShowState = SW_SHOWNORMAL;
+    pFrame->mnShowState = SW_SHOWNORMAL;
     if ( (nSysStyle & (WS_POPUP | WS_MAXIMIZEBOX | WS_THICKFRAME)) == (WS_MAXIMIZEBOX | WS_THICKFRAME) )
     {
         if ( GetSystemMetrics( SM_CXSCREEN ) <= 1024 )
-            pFrame->maFrameData.mnShowState = SW_SHOWMAXIMIZED;
+            pFrame->mnShowState = SW_SHOWMAXIMIZED;
         else
         {
             if ( nSalFrameStyle & SAL_FRAME_STYLE_DEFAULT )
             {
                 SalData* pSalData = GetSalData();
-                pFrame->maFrameData.mnShowState = pSalData->mnCmdShow;
-                if ( (pFrame->maFrameData.mnShowState != SW_SHOWMINIMIZED) &&
-                     (pFrame->maFrameData.mnShowState != SW_MINIMIZE) &&
-                     (pFrame->maFrameData.mnShowState != SW_SHOWMINNOACTIVE) )
+                pFrame->mnShowState = pSalData->mnCmdShow;
+                if ( (pFrame->mnShowState != SW_SHOWMINIMIZED) &&
+                     (pFrame->mnShowState != SW_MINIMIZE) &&
+                     (pFrame->mnShowState != SW_SHOWMINNOACTIVE) )
                 {
-                    if ( (pFrame->maFrameData.mnShowState == SW_SHOWMAXIMIZED) ||
-                         (pFrame->maFrameData.mnShowState == SW_MAXIMIZE) )
-                        pFrame->maFrameData.mbOverwriteState = FALSE;
-                    pFrame->maFrameData.mnShowState = SW_SHOWMAXIMIZED;
+                    if ( (pFrame->mnShowState == SW_SHOWMAXIMIZED) ||
+                         (pFrame->mnShowState == SW_MAXIMIZE) )
+                        pFrame->mbOverwriteState = FALSE;
+                    pFrame->mnShowState = SW_SHOWMAXIMIZED;
                 }
                 else
-                    pFrame->maFrameData.mbOverwriteState = FALSE;
+                    pFrame->mbOverwriteState = FALSE;
             }
             else
             {
@@ -498,9 +489,9 @@ SalFrame* ImplSalCreateFrame( SalInstanc
                 // is also maximized
                 HWND hWnd = GetForegroundWindow();
                 if ( hWnd && IsMaximized( hWnd ) &&
-                     (GetWindowInstance( hWnd ) == pInst->maInstData.mhInst) &&
+                     (GetWindowInstance( hWnd ) == pInst->mhInst) &&
                      ((GetWindowStyle( hWnd ) & (WS_POPUP | WS_MAXIMIZEBOX | WS_THICKFRAME)) == (WS_MAXIMIZEBOX | WS_THICKFRAME)) )
-                    pFrame->maFrameData.mnShowState = SW_SHOWMAXIMIZED;
+                    pFrame->mnShowState = SW_SHOWMAXIMIZED;
             }
         }
     }
@@ -525,11 +516,11 @@ SalFrame* ImplSalCreateFrame( SalInstanc
         }
         hWnd = CreateWindowExW( nExSysStyle, pClassName, L"", nSysStyle,
                                 CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
-                                hWndParent, 0, pInst->maInstData.mhInst, (void*)pFrame );
+                                hWndParent, 0, pInst->mhInst, (void*)pFrame );
 #if OSL_DEBUG_LEVEL > 1
         // set transparency value
         if( bLayeredAPI == 1 && GetWindowExStyle( hWnd ) & WS_EX_LAYERED )
-            lpfnSetLayeredWindowAttributes( hWnd, 0, 230, LWA_ALPHA );
+            lpfnSetLayeredWindowAttributes( hWnd, 0, 230, 0x00000002 /*LWA_ALPHA*/ );
 #endif
     }
     else
@@ -541,7 +532,7 @@ SalFrame* ImplSalCreateFrame( SalInstanc
             pClassName = SAL_FRAME_CLASSNAMEA;
         hWnd = CreateWindowExA( nExSysStyle, pClassName, "", nSysStyle,
                                 CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
-                                hWndParent, 0, pInst->maInstData.mhInst, (void*)pFrame );
+                                hWndParent, 0, pInst->mhInst, (void*)pFrame );
     }
     if ( !hWnd )
     {
@@ -576,24 +567,24 @@ SalFrame* ImplSalCreateFrame( SalInstanc
     }
 
     // reset input context
-    pFrame->maFrameData.mhDefIMEContext = ImmAssociateContext( hWnd, 0 );
+    pFrame->mhDefIMEContext = ImmAssociateContext( hWnd, 0 );
 
     // determine output size and state
     RECT aRect;
     GetClientRect( hWnd, &aRect );
-    pFrame->maFrameData.mnWidth  = aRect.right;
-    pFrame->maFrameData.mnHeight = aRect.bottom;
+    pFrame->mnWidth  = aRect.right;
+    pFrame->mnHeight = aRect.bottom;
     ImplSaveFrameState( pFrame );
-    pFrame->maFrameData.mbDefPos = TRUE;
+    pFrame->mbDefPos = TRUE;
 
 	UpdateFrameGeometry( hWnd, pFrame );
 
-    if( pFrame->maFrameData.mnShowState == SW_SHOWMAXIMIZED )
+    if( pFrame->mnShowState == SW_SHOWMAXIMIZED )
 	{
 		// #96084 set a useful internal window size because
 		// the window will not be maximized (and the size updated) before show()
 		RECT aRect;
-		ImplSalGetWorkArea( pFrame->maFrameData.mhWnd, &aRect, NULL );
+		ImplSalGetWorkArea( pFrame->mhWnd, &aRect, NULL );
 		AdjustWindowRectEx( &aRect, GetWindowStyle( hWnd ),
 							FALSE,     GetWindowExStyle( hWnd ) );
 		pFrame->maGeometry.nX = aRect.left;
@@ -753,9 +744,9 @@ static USHORT aImplTranslateKeyTab[KEY_T
     KEY_9,                // VK_NUMPAD9                      105
     KEY_MULTIPLY,         // VK_MULTIPLY                     106
     KEY_ADD,              // VK_ADD                          107
-    KEY_COMMA,            // VK_SEPARATOR                    108
+    KEY_DECIMAL,          // VK_SEPARATOR                    108
     KEY_SUBTRACT,         // VK_SUBTRACT                     109
-    KEY_POINT,            // VK_DECIMAL                      110
+    KEY_DECIMAL,          // VK_DECIMAL                      110
     KEY_DIVIDE,           // VK_DIVIDE                       111
     KEY_F1,               // VK_F1                           112
     KEY_F2,               // VK_F2                           113
@@ -795,13 +786,6 @@ static USHORT aImplTranslateKeyTab[KEY_T
 
 // =======================================================================
 
-long ImplSalCallbackDummy( void*, SalFrame*, USHORT, const void* )
-{
-    return 0;
-}
-
-// -----------------------------------------------------------------------
-
 static UINT ImplSalGetWheelScrollLines()
 {
     UINT nScrLines = 0;
@@ -824,7 +808,7 @@ static UINT ImplSalGetWheelScrollLines()
 
 // -----------------------------------------------------------------------
 
-static void ImplSalCalcBorder( const SalFrame* pFrame,
+static void ImplSalCalcBorder( const WinSalFrame* pFrame,
                                int& rLeft, int& rTop, int& rRight, int& rBottom )
 {
     // set window to screen size
@@ -832,17 +816,17 @@ static void ImplSalCalcBorder( const Sal
     int nFrameY;
     int nCaptionY;
 
-    if ( pFrame->maFrameData.mbSizeBorder )
+    if ( pFrame->mbSizeBorder )
     {
         nFrameX = GetSystemMetrics( SM_CXSIZEFRAME );
         nFrameY = GetSystemMetrics( SM_CYSIZEFRAME );
     }
-    else if ( pFrame->maFrameData.mbFixBorder )
+    else if ( pFrame->mbFixBorder )
     {
         nFrameX = GetSystemMetrics( SM_CXFIXEDFRAME );
         nFrameY = GetSystemMetrics( SM_CYFIXEDFRAME );
     }
-    else if ( pFrame->maFrameData.mbBorder )
+    else if ( pFrame->mbBorder )
     {
         nFrameX = GetSystemMetrics( SM_CXBORDER );
         nFrameY = GetSystemMetrics( SM_CYBORDER );
@@ -852,7 +836,7 @@ static void ImplSalCalcBorder( const Sal
         nFrameX = 0;
         nFrameY = 0;
     }
-    if ( pFrame->maFrameData.mbCaption )
+    if ( pFrame->mbCaption )
         nCaptionY = GetSystemMetrics( SM_CYCAPTION );
     else
         nCaptionY = 0;
@@ -865,7 +849,7 @@ static void ImplSalCalcBorder( const Sal
 
 // -----------------------------------------------------------------------
 
-static void ImplSalCalcFullScreenSize( const SalFrame* pFrame,
+static void ImplSalCalcFullScreenSize( const WinSalFrame* pFrame,
                                        int& rX, int& rY, int& rDX, int& rDY )
 {
     // set window to screen size
@@ -875,17 +859,17 @@ static void ImplSalCalcFullScreenSize( c
     int nScreenDX;
     int nScreenDY;
 
-    if ( pFrame->maFrameData.mbSizeBorder )
+    if ( pFrame->mbSizeBorder )
     {
         nFrameX = GetSystemMetrics( SM_CXSIZEFRAME );
         nFrameY = GetSystemMetrics( SM_CYSIZEFRAME );
     }
-    else if ( pFrame->maFrameData.mbFixBorder )
+    else if ( pFrame->mbFixBorder )
     {
         nFrameX = GetSystemMetrics( SM_CXFIXEDFRAME );
         nFrameY = GetSystemMetrics( SM_CYFIXEDFRAME );
     }
-    else if ( pFrame->maFrameData.mbBorder )
+    else if ( pFrame->mbBorder )
     {
         nFrameX = GetSystemMetrics( SM_CXBORDER );
         nFrameY = GetSystemMetrics( SM_CYBORDER );
@@ -895,7 +879,7 @@ static void ImplSalCalcFullScreenSize( c
         nFrameX = 0;
         nFrameY = 0;
     }
-    if ( pFrame->maFrameData.mbCaption )
+    if ( pFrame->mbCaption )
         nCaptionY = GetSystemMetrics( SM_CYCAPTION );
     else
         nCaptionY = 0;
@@ -911,9 +895,9 @@ static void ImplSalCalcFullScreenSize( c
 
 // -----------------------------------------------------------------------
 
-static void ImplSalFrameFullScreenPos( SalFrame* pFrame, BOOL bAlways = FALSE )
+static void ImplSalFrameFullScreenPos( WinSalFrame* pFrame, BOOL bAlways = FALSE )
 {
-    if ( bAlways || !IsIconic( pFrame->maFrameData.mhWnd ) )
+    if ( bAlways || !IsIconic( pFrame->mhWnd ) )
     {
         // set window to screen size
         int nX;
@@ -921,7 +905,7 @@ static void ImplSalFrameFullScreenPos( S
         int nWidth;
         int nHeight;
         ImplSalCalcFullScreenSize( pFrame, nX, nY, nWidth, nHeight );
-        SetWindowPos( pFrame->maFrameData.mhWnd, 0,
+        SetWindowPos( pFrame->mhWnd, 0,
                       nX, nY, nWidth, nHeight,
                       SWP_NOZORDER | SWP_NOACTIVATE );
     }
@@ -929,48 +913,48 @@ static void ImplSalFrameFullScreenPos( S
 
 // -----------------------------------------------------------------------
 
-SalFrame::SalFrame()
+WinSalFrame::WinSalFrame()
 {
     SalData* pSalData = GetSalData();
 
-    maFrameData.mhWnd               = 0;
-    maFrameData.mhCursor            = LoadCursor( 0, IDC_ARROW );
-    maFrameData.mhDefIMEContext     = 0;
-    maFrameData.mpGraphics          = NULL;
-    maFrameData.mpGraphics2         = NULL;
-    maFrameData.mpInst              = NULL;
-    maFrameData.mpProc              = ImplSalCallbackDummy;
-    maFrameData.mnShowState         = SW_SHOWNORMAL;
-    maFrameData.mnWidth             = 0;
-    maFrameData.mnHeight            = 0;
-    maFrameData.mnMinWidth          = 0;
-    maFrameData.mnMinHeight         = 0;
-    maFrameData.mnInputLang         = 0;
-    maFrameData.mnInputCodePage     = 0;
-    maFrameData.mbGraphics          = FALSE;
-    maFrameData.mbCaption           = FALSE;
-    maFrameData.mbBorder            = FALSE;
-    maFrameData.mbFixBorder         = FALSE;
-    maFrameData.mbSizeBorder        = FALSE;
-    maFrameData.mbFullScreen        = FALSE;
-    maFrameData.mbPresentation      = FALSE;
-    maFrameData.mbInShow            = FALSE;
-    maFrameData.mbRestoreMaximize   = FALSE;
-    maFrameData.mbInMoveMsg         = FALSE;
-    maFrameData.mbInSizeMsg         = FALSE;
-    maFrameData.mbFullScreenToolWin = FALSE;
-    maFrameData.mbDefPos            = TRUE;
-    maFrameData.mbOverwriteState    = TRUE;
-    maFrameData.mbIME               = FALSE;
-    maFrameData.mbHandleIME         = FALSE;
-    maFrameData.mbSpezIME           = FALSE;
-    maFrameData.mbAtCursorIME       = FALSE;
-    maFrameData.mbCandidateMode     = FALSE;
-    maFrameData.mbFloatWin          = FALSE;
-    maFrameData.mbNoIcon            = FALSE;
+    mhWnd               = 0;
+    mhCursor            = LoadCursor( 0, IDC_ARROW );
+    mhDefIMEContext     = 0;
+    mpGraphics          = NULL;
+    mpGraphics2         = NULL;
+    mnShowState         = SW_SHOWNORMAL;
+    mnWidth             = 0;
+    mnHeight            = 0;
+    mnMinWidth          = 0;
+    mnMinHeight         = 0;
+    mnInputLang         = 0;
+    mnInputCodePage     = 0;
+    mbGraphics          = FALSE;
+    mbCaption           = FALSE;
+    mbBorder            = FALSE;
+    mbFixBorder         = FALSE;
+    mbSizeBorder        = FALSE;
+    mbFullScreen        = FALSE;
+    mbPresentation      = FALSE;
+    mbInShow            = FALSE;
+    mbRestoreMaximize   = FALSE;
+    mbInMoveMsg         = FALSE;
+    mbInSizeMsg         = FALSE;
+    mbFullScreenToolWin = FALSE;
+    mbDefPos            = TRUE;
+    mbOverwriteState    = TRUE;
+    mbIME               = FALSE;
+    mbHandleIME         = FALSE;
+    mbSpezIME           = FALSE;
+    mbAtCursorIME       = FALSE;
+    mbCandidateMode     = FALSE;
+    mbFloatWin          = FALSE;
+    mbNoIcon            = FALSE;
+    mSelectedhMenu      = 0;
+    mLastActivatedhMenu = 0;
 
-    memset( &maFrameData.maState, 0, sizeof( SalFrameState ) );
-    maFrameData.maSysData.nSize     = sizeof( SystemEnvData );
+    memset( &maState, 0, sizeof( SalFrameState ) );
+    maSysData.nSize     = sizeof( SystemEnvData );
 
     memset( &maGeometry, 0, sizeof( maGeometry ) );
 
@@ -984,35 +968,35 @@ SalFrame::SalFrame()
     }
 
     // insert frame in framelist
-    maFrameData.mpNextFrame = pSalData->mpFirstFrame;
+    mpNextFrame = pSalData->mpFirstFrame;
     pSalData->mpFirstFrame = this;
 }
 
 // -----------------------------------------------------------------------
 
-SalFrame::~SalFrame()
+WinSalFrame::~WinSalFrame()
 {
     SalData* pSalData = GetSalData();
 
     // Release Cache DC
-    if ( maFrameData.mpGraphics2 &&
-         maFrameData.mpGraphics2->maGraphicsData.mhDC )
-        ReleaseGraphics( maFrameData.mpGraphics2 );
+    if ( mpGraphics2 &&
+         mpGraphics2->mhDC )
+        ReleaseGraphics( mpGraphics2 );
 
     // destroy saved DC
-    if ( maFrameData.mpGraphics )
+    if ( mpGraphics )
     {
-        if ( maFrameData.mpGraphics->maGraphicsData.mhDefPal )
-            SelectPalette( maFrameData.mpGraphics->maGraphicsData.mhDC, maFrameData.mpGraphics->maGraphicsData.mhDefPal, TRUE );
-        ImplSalDeInitGraphics( &(maFrameData.mpGraphics->maGraphicsData) );
-        ReleaseDC( maFrameData.mhWnd, maFrameData.mpGraphics->maGraphicsData.mhDC );
-        delete maFrameData.mpGraphics;
+        if ( mpGraphics->mhDefPal )
+            SelectPalette( mpGraphics->mhDC, mpGraphics->mhDefPal, TRUE );
+        ImplSalDeInitGraphics( mpGraphics );
+        ReleaseDC( mhWnd, mpGraphics->mhDC );
+        delete mpGraphics;
     }
 
-    if ( maFrameData.mhWnd )
+    if ( mhWnd )
     {
         // reset mouse leave data
-        if ( pSalData->mhWantLeaveMsg == maFrameData.mhWnd )
+        if ( pSalData->mhWantLeaveMsg == mhWnd )
         {
             pSalData->mhWantLeaveMsg = 0;
             if ( pSalData->mpMouseLeaveTimer )
@@ -1023,28 +1007,28 @@ SalFrame::~SalFrame()
         }
 
         // destroy system frame
-        if ( !DestroyWindow( maFrameData.mhWnd ) )
-            SetWindowPtr( maFrameData.mhWnd, 0 );
+        if ( !DestroyWindow( mhWnd ) )
+            SetWindowPtr( mhWnd, 0 );
 	}
 
     // remove frame from framelist
     if ( this == pSalData->mpFirstFrame )
-        pSalData->mpFirstFrame = maFrameData.mpNextFrame;
+        pSalData->mpFirstFrame = mpNextFrame;
     else
     {
-        SalFrame* pTempFrame = pSalData->mpFirstFrame;
-        while ( pTempFrame->maFrameData.mpNextFrame != this )
-            pTempFrame = pTempFrame->maFrameData.mpNextFrame;
+        WinSalFrame* pTempFrame = pSalData->mpFirstFrame;
+        while ( pTempFrame->mpNextFrame != this )
+            pTempFrame = pTempFrame->mpNextFrame;
 
-        pTempFrame->maFrameData.mpNextFrame = maFrameData.mpNextFrame;
+        pTempFrame->mpNextFrame = mpNextFrame;
     }
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalFrame::GetGraphics()
+SalGraphics* WinSalFrame::GetGraphics()
 {
-    if ( maFrameData.mbGraphics )
+    if ( mbGraphics )
         return NULL;
 
     // Other threads get an own DC, because Windows modify in the
@@ -1058,116 +1042,116 @@ SalGraphics* SalFrame::GetGraphics()
         if ( pSalData->mnCacheDCInUse >= 3 )
             return NULL;
 
-        if ( !maFrameData.mpGraphics2 )
+        if ( !mpGraphics2 )
         {
-            maFrameData.mpGraphics2 = new SalGraphicsLayout;
-            maFrameData.mpGraphics2->maGraphicsData.mhDC        = 0;
-            maFrameData.mpGraphics2->maGraphicsData.mhWnd       = maFrameData.mhWnd;
-            maFrameData.mpGraphics2->maGraphicsData.mbPrinter   = FALSE;
-            maFrameData.mpGraphics2->maGraphicsData.mbVirDev    = FALSE;
-            maFrameData.mpGraphics2->maGraphicsData.mbWindow    = TRUE;
-            maFrameData.mpGraphics2->maGraphicsData.mbScreen    = TRUE;
+            mpGraphics2 = new WinSalGraphics;
+            mpGraphics2->mhDC        = 0;
+            mpGraphics2->mhWnd       = mhWnd;
+            mpGraphics2->mbPrinter   = FALSE;
+            mpGraphics2->mbVirDev    = FALSE;
+            mpGraphics2->mbWindow    = TRUE;
+            mpGraphics2->mbScreen    = TRUE;
         }
 
-        HDC hDC = (HDC)ImplSendMessage( pSalData->mpFirstInstance->maInstData.mhComWnd,
+        HDC hDC = (HDC)ImplSendMessage( pSalData->mpFirstInstance->mhComWnd,
                                         SAL_MSG_GETDC,
-                                        (WPARAM)maFrameData.mhWnd, 0 );
+                                        (WPARAM)mhWnd, 0 );
         if ( hDC )
         {
-            maFrameData.mpGraphics2->maGraphicsData.mhDC = hDC;
+            mpGraphics2->mhDC = hDC;
             if ( pSalData->mhDitherPal )
             {
-                maFrameData.mpGraphics2->maGraphicsData.mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
+                mpGraphics2->mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
                 RealizePalette( hDC );
             }
-            ImplSalInitGraphics( &(maFrameData.mpGraphics2->maGraphicsData) );
-            maFrameData.mbGraphics = TRUE;
+            ImplSalInitGraphics( mpGraphics2 );
+            mbGraphics = TRUE;
             pSalData->mnCacheDCInUse++;
-            return maFrameData.mpGraphics2;
+            return mpGraphics2;
         }
         else
             return NULL;
     }
     else
     {
-        if ( !maFrameData.mpGraphics )
+        if ( !mpGraphics )
         {
-            HDC hDC = GetDC( maFrameData.mhWnd );
+            HDC hDC = GetDC( mhWnd );
             if ( hDC )
             {
-                maFrameData.mpGraphics = new SalGraphicsLayout;
-                maFrameData.mpGraphics->maGraphicsData.mhDC      = hDC;
-                maFrameData.mpGraphics->maGraphicsData.mhWnd     = maFrameData.mhWnd;
-                maFrameData.mpGraphics->maGraphicsData.mbPrinter = FALSE;
-                maFrameData.mpGraphics->maGraphicsData.mbVirDev  = FALSE;
-                maFrameData.mpGraphics->maGraphicsData.mbWindow  = TRUE;
-                maFrameData.mpGraphics->maGraphicsData.mbScreen  = TRUE;
+                mpGraphics = new WinSalGraphics;
+                mpGraphics->mhDC      = hDC;
+                mpGraphics->mhWnd     = mhWnd;
+                mpGraphics->mbPrinter = FALSE;
+                mpGraphics->mbVirDev  = FALSE;
+                mpGraphics->mbWindow  = TRUE;
+                mpGraphics->mbScreen  = TRUE;
                 if ( pSalData->mhDitherPal )
                 {
-                    maFrameData.mpGraphics->maGraphicsData.mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
+                    mpGraphics->mhDefPal = SelectPalette( hDC, pSalData->mhDitherPal, TRUE );
                     RealizePalette( hDC );
                 }
-                ImplSalInitGraphics( &(maFrameData.mpGraphics->maGraphicsData) );
-                maFrameData.mbGraphics = TRUE;
+                ImplSalInitGraphics( mpGraphics );
+                mbGraphics = TRUE;
             }
         }
         else
-            maFrameData.mbGraphics = TRUE;
+            mbGraphics = TRUE;
 
-        return maFrameData.mpGraphics;
+        return mpGraphics;
     }
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::ReleaseGraphics( SalGraphics* pGraphics )
+void WinSalFrame::ReleaseGraphics( SalGraphics* pGraphics )
 {
-    if ( maFrameData.mpGraphics2 == pGraphics )
+    if ( mpGraphics2 == pGraphics )
     {
-        if ( maFrameData.mpGraphics2->maGraphicsData.mhDC )
+        if ( mpGraphics2->mhDC )
         {
             SalData* pSalData = GetSalData();
-            if ( maFrameData.mpGraphics2->maGraphicsData.mhDefPal )
-                SelectPalette( maFrameData.mpGraphics2->maGraphicsData.mhDC, maFrameData.mpGraphics2->maGraphicsData.mhDefPal, TRUE );
-            ImplSalDeInitGraphics( &(maFrameData.mpGraphics2->maGraphicsData) );
-            ImplSendMessage( pSalData->mpFirstInstance->maInstData.mhComWnd,
+            if ( mpGraphics2->mhDefPal )
+                SelectPalette( mpGraphics2->mhDC, mpGraphics2->mhDefPal, TRUE );
+            ImplSalDeInitGraphics( mpGraphics2 );
+            ImplSendMessage( pSalData->mpFirstInstance->mhComWnd,
                              SAL_MSG_RELEASEDC,
-                             (WPARAM)maFrameData.mhWnd,
-                             (LPARAM)maFrameData.mpGraphics2->maGraphicsData.mhDC );
-            maFrameData.mpGraphics2->maGraphicsData.mhDC = 0;
+                             (WPARAM)mhWnd,
+                             (LPARAM)mpGraphics2->mhDC );
+            mpGraphics2->mhDC = 0;
             pSalData->mnCacheDCInUse--;
         }
     }
 
-    maFrameData.mbGraphics = FALSE;
+    mbGraphics = FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalFrame::PostEvent( void* pData )
+BOOL WinSalFrame::PostEvent( void* pData )
 {
-    return (BOOL)ImplPostMessage( maFrameData.mhWnd, SAL_MSG_USEREVENT, 0, (LPARAM)pData );
+    return (BOOL)ImplPostMessage( mhWnd, SAL_MSG_USEREVENT, 0, (LPARAM)pData );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetTitle( const XubString& rTitle )
+void WinSalFrame::SetTitle( const XubString& rTitle )
 {
-    DBG_ASSERT( sizeof( WCHAR ) == sizeof( xub_Unicode ), "SalFrame::SetTitle(): WCHAR != sal_Unicode" );
+    DBG_ASSERT( sizeof( WCHAR ) == sizeof( xub_Unicode ), "WinSalFrame::SetTitle(): WCHAR != sal_Unicode" );
 
-    if ( !SetWindowTextW( maFrameData.mhWnd, rTitle.GetBuffer() ) )
+    if ( !SetWindowTextW( mhWnd, rTitle.GetBuffer() ) )
     {
         ByteString aAnsiTitle = ImplSalGetWinAnsiString( rTitle );
-        SetWindowTextA( maFrameData.mhWnd, aAnsiTitle.GetBuffer() );
+        SetWindowTextA( mhWnd, aAnsiTitle.GetBuffer() );
     }
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetIcon( USHORT nIcon )
+void WinSalFrame::SetIcon( USHORT nIcon )
 {
     // If we have a window without an Icon (for example a dialog), ignore this call
-    if ( maFrameData.mbNoIcon )
+    if ( mbNoIcon )
         return;
 
     // 0 means default (class) icon
@@ -1177,51 +1161,61 @@ void SalFrame::SetIcon( USHORT nIcon )
 
     ImplLoadSalIcon( nIcon, hIcon, hSmIcon );
 
-    DBG_ASSERT( hIcon ,   "SalFrame::SetIcon(): Could not load large icon !" );
-    DBG_ASSERT( hSmIcon , "SalFrame::SetIcon(): Could not load small icon !" );
+    DBG_ASSERT( hIcon ,   "WinSalFrame::SetIcon(): Could not load large icon !" );
+    DBG_ASSERT( hSmIcon , "WinSalFrame::SetIcon(): Could not load small icon !" );
+
+    ImplSendMessage( mhWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon );
+    ImplSendMessage( mhWnd, WM_SETICON, ICON_SMALL, (LPARAM)hSmIcon );
+}
+
+// -----------------------------------------------------------------------
+
+void WinSalFrame::SetMenu( SalMenu* pSalMenu )
+{
+    WinSalMenu* pWMenu = static_cast<WinSalMenu*>(pSalMenu);
+    if( pSalMenu && pWMenu->mbMenuBar )
+        ::SetMenu( mhWnd, pWMenu->mhMenu );
+}
 
-    ImplSendMessage( maFrameData.mhWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon );
-    ImplSendMessage( maFrameData.mhWnd, WM_SETICON, ICON_SMALL, (LPARAM)hSmIcon );
+void WinSalFrame::DrawMenuBar()
+{
+    ::DrawMenuBar( mhWnd );
 }
 
 // -----------------------------------------------------------------------
 HWND ImplGetParentHwnd( HWND hWnd )
 {
-#ifndef REMOTE_APPSERVER
-    SalFrame* pFrame = GetWindowPtr( hWnd );
-	if( !pFrame || !pFrame->maFrameData.mpInst)
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
+	if( !pFrame || !pFrame->GetInstance())
 		return ::GetParent( hWnd );
-	Window *pRealParent = ((Window*)pFrame->maFrameData.mpInst)->mpRealParent;
+	Window *pRealParent = ((Window*)pFrame->GetInstance())->mpRealParent;
 	if( pRealParent )
-		return pRealParent->mpFrame->maFrameData.mhWnd;
+		return static_cast<WinSalFrame*>(pRealParent->mpFrame)->mhWnd;
 	else
 		return ::GetParent( hWnd );
-#else
-	return ::GetParent( hWnd );	// just to get it compiled for remote case, this function is never executed...
-#endif
 
 }
 
 // -----------------------------------------------------------------------
 
-SalFrame* SalFrame::GetParent() const
+SalFrame* WinSalFrame::GetParent() const
 {
-    return GetWindowPtr( ImplGetParentHwnd( maFrameData.mhWnd ) );
+    return GetWindowPtr( ImplGetParentHwnd( mhWnd ) );
 }
 
 // -----------------------------------------------------------------------
 
 static void ImplSalShow( HWND hWnd, BOOL bVisible, BOOL bNoActivate )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( !pFrame )
         return;
 
     if ( bVisible )
     {
-        pFrame->maFrameData.mbDefPos = FALSE;
-        pFrame->maFrameData.mbOverwriteState = TRUE;
-        pFrame->maFrameData.mbInShow = TRUE;
+        pFrame->mbDefPos = FALSE;
+        pFrame->mbOverwriteState = TRUE;
+        pFrame->mbInShow = TRUE;
 
         // #i4715, save position
         RECT aRectPreMatrox, aRectPostMatrox;
@@ -1230,9 +1224,9 @@ static void ImplSalShow( HWND hWnd, BOOL
         if( bNoActivate )
             ShowWindow( hWnd, SW_SHOWNOACTIVATE );
         else
-            ShowWindow( hWnd, pFrame->maFrameData.mnShowState );
+            ShowWindow( hWnd, pFrame->mnShowState );
 
-        if ( aSalShlData.mbWXP && pFrame->maFrameData.mbFloatWin && !(pFrame->maFrameData.mnStyle & SAL_FRAME_STYLE_NOSHADOW))
+        if ( aSalShlData.mbWXP && pFrame->mbFloatWin && !(pFrame->mnStyle & SAL_FRAME_STYLE_NOSHADOW))
         {
             // erase the window immediately to improve XP shadow effect
             // otherwise the shadow may appears long time before the rest of the window
@@ -1248,17 +1242,17 @@ static void ImplSalShow( HWND hWnd, BOOL
         // reposition popups without caption (menues, dropdowns, tooltips)
         GetWindowRect( hWnd, &aRectPostMatrox );
         if( (GetWindowStyle( hWnd ) & WS_POPUP) &&
-            !pFrame->maFrameData.mbCaption &&
+            !pFrame->mbCaption &&
             (aRectPreMatrox.left != aRectPostMatrox.left || aRectPreMatrox.top != aRectPostMatrox.top) )
             SetWindowPos( hWnd, 0, aRectPreMatrox.left, aRectPreMatrox.top, 0, 0, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE  );
 
-		Window *pClientWin = ((Window*)pFrame->maFrameData.mpInst)->ImplGetClientWindow();
-        if ( pFrame->maFrameData.mbFloatWin || ( pClientWin && (pClientWin->GetStyle() & WB_SYSTEMFLOATWIN) ) )
-            pFrame->maFrameData.mnShowState = SW_SHOWNOACTIVATE;
+		Window *pClientWin = ((Window*)pFrame->GetInstance())->ImplGetClientWindow();
+        if ( pFrame->mbFloatWin || ( pClientWin && (pClientWin->GetStyle() & WB_SYSTEMFLOATWIN) ) )
+            pFrame->mnShowState = SW_SHOWNOACTIVATE;
         else
-            pFrame->maFrameData.mnShowState = SW_SHOW;
+            pFrame->mnShowState = SW_SHOW;
         // Damit Taskleiste unter W98 auch gleich ausgeblendet wird
-        if ( pFrame->maFrameData.mbPresentation )
+        if ( pFrame->mbPresentation )
         {
             HWND hWndParent = ::GetParent( hWnd );
             if ( hWndParent )
@@ -1266,7 +1260,7 @@ static void ImplSalShow( HWND hWnd, BOOL
             SetForegroundWindow( hWnd );
         }
 
-        pFrame->maFrameData.mbInShow = FALSE;
+        pFrame->mbInShow = FALSE;
 
 
         // Direct Paint only, if we get the SolarMutx
@@ -1279,8 +1273,8 @@ static void ImplSalShow( HWND hWnd, BOOL
     else
     {
         // See also Bug #91813# and #68467#
-        if ( pFrame->maFrameData.mbFullScreen &&
-             pFrame->maFrameData.mbPresentation &&
+        if ( pFrame->mbFullScreen &&
+             pFrame->mbPresentation &&
              (aSalShlData.mnVersion < 500) &&
              !::GetParent( hWnd ) )
         {
@@ -1299,7 +1293,7 @@ static void ImplSalShow( HWND hWnd, BOOL
                 int nOldAni = aInfo.iMinAnimate;
                 aInfo.iMinAnimate = 0;
                 SystemParametersInfo( SPI_SETANIMATION, 0, &aInfo, 0 );
-                ShowWindow( pFrame->maFrameData.mhWnd, SW_SHOWMINNOACTIVE );
+                ShowWindow( pFrame->mhWnd, SW_SHOWMINNOACTIVE );
                 aInfo.iMinAnimate = nOldAni;
                 SystemParametersInfo( SPI_SETANIMATION, 0, &aInfo, 0 );
             }
@@ -1314,57 +1308,57 @@ static void ImplSalShow( HWND hWnd, BOOL
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Show( BOOL bVisible, BOOL bNoActivate )
+void WinSalFrame::Show( BOOL bVisible, BOOL bNoActivate )
 {
     // Post this Message to the window, because this only works
     // in the thread of the window, which has create this window.
     // We post this message to avoid deadlocks
     if ( GetSalData()->mnAppThreadId != GetCurrentThreadId() )
-        ImplPostMessage( maFrameData.mhWnd, SAL_MSG_SHOW, bVisible, bNoActivate );
+        ImplPostMessage( mhWnd, SAL_MSG_SHOW, bVisible, bNoActivate );
     else
-        ImplSalShow( maFrameData.mhWnd, bVisible, bNoActivate );
+        ImplSalShow( mhWnd, bVisible, bNoActivate );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Enable( BOOL bEnable )
+void WinSalFrame::Enable( BOOL bEnable )
 {
-    EnableWindow( maFrameData.mhWnd, bEnable );
+    EnableWindow( mhWnd, bEnable );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetMinClientSize( long nWidth, long nHeight )
+void WinSalFrame::SetMinClientSize( long nWidth, long nHeight )
 {
-    maFrameData.mnMinWidth  = nWidth;
-    maFrameData.mnMinHeight = nHeight;
+    mnMinWidth  = nWidth;
+    mnMinHeight = nHeight;
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight,
+void WinSalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight,
                                                    USHORT nFlags )
 {
-    BOOL bVisible = (GetWindowStyle( maFrameData.mhWnd ) & WS_VISIBLE) != 0;
+    BOOL bVisible = (GetWindowStyle( mhWnd ) & WS_VISIBLE) != 0;
     if ( !bVisible )
     {
-		Window *pClientWin = ((Window*)maFrameData.mpInst)->ImplGetClientWindow();
-        if ( maFrameData.mbFloatWin || ( pClientWin && (pClientWin->GetStyle() & WB_SYSTEMFLOATWIN) ) )
-                maFrameData.mnShowState = SW_SHOWNOACTIVATE;
+		Window *pClientWin = ((Window*)GetInstance())->ImplGetClientWindow();
+        if ( mbFloatWin || ( pClientWin && (pClientWin->GetStyle() & WB_SYSTEMFLOATWIN) ) )
+                mnShowState = SW_SHOWNOACTIVATE;
         else
-                maFrameData.mnShowState = SW_SHOWNORMAL;
+                mnShowState = SW_SHOWNORMAL;
     }
     else
     {
-        if ( IsIconic( maFrameData.mhWnd ) || IsZoomed( maFrameData.mhWnd ) )
-                ShowWindow( maFrameData.mhWnd, SW_RESTORE );
+        if ( IsIconic( mhWnd ) || IsZoomed( mhWnd ) )
+                ShowWindow( mhWnd, SW_RESTORE );
     }
 
     USHORT nEvent = 0;
     UINT    nPosSize = 0;
     RECT    aClientRect, aWindowRect;
-    GetClientRect( maFrameData.mhWnd, &aClientRect );   // x,y always 0,0, but width and height without border
-    GetWindowRect( maFrameData.mhWnd, &aWindowRect );   // x,y in screen coordinates, width and height with border
+    GetClientRect( mhWnd, &aClientRect );   // x,y always 0,0, but width and height without border
+    GetWindowRect( mhWnd, &aWindowRect );   // x,y in screen coordinates, width and height with border
 
     if ( !(nFlags & (SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y)) )
         nPosSize |= SWP_NOMOVE;
@@ -1393,25 +1387,29 @@ void SalFrame::SetPosSize( long nX, long
     aWinRect.right  = (int)nWidth-1;
     aWinRect.top    = 0;
     aWinRect.bottom = (int)nHeight-1;
-    AdjustWindowRectEx( &aWinRect, GetWindowStyle( maFrameData.mhWnd ),
-                        FALSE,     GetWindowExStyle( maFrameData.mhWnd ) );
+    AdjustWindowRectEx( &aWinRect, GetWindowStyle( mhWnd ),
+                        FALSE,     GetWindowExStyle( mhWnd ) );
     nWidth  = aWinRect.right - aWinRect.left + 1;
     nHeight = aWinRect.bottom - aWinRect.top + 1;
 
-    if ( !(nPosSize & SWP_NOMOVE) && ::GetParent( maFrameData.mhWnd ) )
+    if ( !(nPosSize & SWP_NOMOVE) && ::GetParent( mhWnd ) )
     {
             // --- RTL --- (mirror window pos)
             RECT aParentRect;
-            GetClientRect( ImplGetParentHwnd( maFrameData.mhWnd ), &aParentRect );
+            GetClientRect( ImplGetParentHwnd( mhWnd ), &aParentRect );
             if( Application::GetSettings().GetLayoutRTL() )
                 nX = (aParentRect.right - aParentRect.left) - nWidth-1 - nX;
 
-            POINT aPt;
-            aPt.x = nX;
-            aPt.y = nY;
-            ClientToScreen( ImplGetParentHwnd( maFrameData.mhWnd ), &aPt );
-            nX = aPt.x;
-            nY = aPt.y;
+            //#110386#, do not transform coordinates for system child windows
+            if( !(GetWindowStyle( mhWnd ) & WS_CHILD) )
+            {
+                POINT aPt;
+                aPt.x = nX;
+                aPt.y = nY;
+                ClientToScreen( ImplGetParentHwnd( mhWnd ), &aPt );
+                nX = aPt.x;
+                nY = aPt.y;
+            }
     }
 
     // #i3338# to be conformant to UNIX we must position the client window, ie without the decoration
@@ -1425,17 +1423,17 @@ void SalFrame::SetPosSize( long nX, long
 
 
     RECT aRect;
-    ImplSalGetWorkArea( maFrameData.mhWnd, &aRect, NULL );
+    ImplSalGetWorkArea( mhWnd, &aRect, NULL );
     nScreenX        = aRect.left;
     nScreenY        = aRect.top;
     nScreenWidth    = aRect.right-aRect.left;
     nScreenHeight   = aRect.bottom-aRect.top;
 
-    if ( maFrameData.mbDefPos && (nPosSize & SWP_NOMOVE)) // we got no positioning request, so choose default position
+    if ( mbDefPos && (nPosSize & SWP_NOMOVE)) // we got no positioning request, so choose default position
     {
         // center window
 
-        HWND hWndParent = ::GetParent( maFrameData.mhWnd );
+        HWND hWndParent = ::GetParent( mhWnd );
         // Search for TopLevel Frame
         while ( hWndParent && (GetWindowStyle( hWndParent ) & WS_CHILD) )
             hWndParent = ::GetParent( hWndParent );
@@ -1475,7 +1473,7 @@ void SalFrame::SetPosSize( long nX, long
 
             // dualmonitor support:
             // Get screensize of the monitor whith the mouse pointer
-            ImplSalGetWorkArea( maFrameData.mhWnd, &aRect, &aRect );
+            ImplSalGetWorkArea( mhWnd, &aRect, &aRect );
 
             nX = ((aRect.right-aRect.left)-nWidth)/2 + aRect.left;
             nY = ((aRect.bottom-aRect.top)-nHeight)/2 + aRect.top;
@@ -1483,9 +1481,9 @@ void SalFrame::SetPosSize( long nX, long
 
 
         //if ( bVisible )
-        //    maFrameData.mbDefPos = FALSE;
+        //    mbDefPos = FALSE;
 
-        maFrameData.mbDefPos = FALSE;   // center only once
+        mbDefPos = FALSE;   // center only once
         nPosSize &= ~SWP_NOMOVE;        // activate positioning
         nEvent = SALEVENT_MOVERESIZE;
     }
@@ -1503,81 +1501,81 @@ void SalFrame::SetPosSize( long nX, long
 
     UINT nPosFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER | nPosSize;
     // bring floating windows always to top
-    if( !(maFrameData.mnStyle & SAL_FRAME_STYLE_FLOAT) )
+    if( !(mnStyle & SAL_FRAME_STYLE_FLOAT) )
         nPosFlags |= SWP_NOZORDER; // do not change z-order
 
-    SetWindowPos( maFrameData.mhWnd, HWND_TOP, nX, nY, (int)nWidth, (int)nHeight, nPosFlags  );
+    SetWindowPos( mhWnd, HWND_TOP, nX, nY, (int)nWidth, (int)nHeight, nPosFlags  );
 
-	UpdateFrameGeometry( maFrameData.mhWnd, this );
+	UpdateFrameGeometry( mhWnd, this );
 
     // Notification -- really ???
     if( nEvent )
-        maFrameData.mpProc( maFrameData.mpInst, this, nEvent, NULL );
+        CallCallback( nEvent, NULL );
 }
 
 // -----------------------------------------------------------------------
 
-static void ImplSetParentFrame( SalFrame* pThis, HWND hNewParentWnd, BOOL bAsChild )
+static void ImplSetParentFrame( WinSalFrame* pThis, HWND hNewParentWnd, BOOL bAsChild )
 {
     pThis->mbInReparent = TRUE;
 
     // save hwnd, will be overwritten in WM_CREATE during createwindow
-    HWND hWndOld = pThis->maFrameData.mhWnd;
-    BOOL bNeedGraphics = pThis->maFrameData.mbGraphics;
+    HWND hWndOld = pThis->mhWnd;
+    BOOL bNeedGraphics = pThis->mbGraphics;
     HFONT   hFont   = NULL;
     HPEN    hPen    = NULL;
     HBRUSH  hBrush  = NULL;
 
     // Release Cache DC
-    if ( pThis->maFrameData.mpGraphics2 &&
-         pThis->maFrameData.mpGraphics2->maGraphicsData.mhDC )
+    if ( pThis->mpGraphics2 &&
+         pThis->mpGraphics2->mhDC )
     {
         // save current gdi objects before hdc is gone
-        hFont   = (HFONT)   GetCurrentObject( pThis->maFrameData.mpGraphics2->maGraphicsData.mhDC, OBJ_FONT);
-        hPen    = (HPEN)    GetCurrentObject( pThis->maFrameData.mpGraphics2->maGraphicsData.mhDC, OBJ_PEN);
-        hBrush  = (HBRUSH)  GetCurrentObject( pThis->maFrameData.mpGraphics2->maGraphicsData.mhDC, OBJ_BRUSH);
-        pThis->ReleaseGraphics( pThis->maFrameData.mpGraphics2 );
+        hFont   = (HFONT)   GetCurrentObject( pThis->mpGraphics2->mhDC, OBJ_FONT);
+        hPen    = (HPEN)    GetCurrentObject( pThis->mpGraphics2->mhDC, OBJ_PEN);
+        hBrush  = (HBRUSH)  GetCurrentObject( pThis->mpGraphics2->mhDC, OBJ_BRUSH);
+        pThis->ReleaseGraphics( pThis->mpGraphics2 );
     }
 
     // destroy saved DC
-    if ( pThis->maFrameData.mpGraphics )
+    if ( pThis->mpGraphics )
     {
-        if ( pThis->maFrameData.mpGraphics->maGraphicsData.mhDefPal )
-            SelectPalette( pThis->maFrameData.mpGraphics->maGraphicsData.mhDC, pThis->maFrameData.mpGraphics->maGraphicsData.mhDefPal, TRUE );
-        ImplSalDeInitGraphics( &(pThis->maFrameData.mpGraphics->maGraphicsData) );
-        ReleaseDC( pThis->maFrameData.mhWnd, pThis->maFrameData.mpGraphics->maGraphicsData.mhDC );
+        if ( pThis->mpGraphics->mhDefPal )
+            SelectPalette( pThis->mpGraphics->mhDC, pThis->mpGraphics->mhDefPal, TRUE );
+        ImplSalDeInitGraphics( pThis->mpGraphics );
+        ReleaseDC( pThis->mhWnd, pThis->mpGraphics->mhDC );
     }
 
     // create a new hwnd with the same styles
     HWND hWndParent = hNewParentWnd;
     // forward to main thread
-    HWND hWnd = (HWND) ImplSendMessage( GetSalData()->mpFirstInstance->maInstData.mhComWnd,
+    HWND hWnd = (HWND) ImplSendMessage( GetSalData()->mpFirstInstance->mhComWnd,
                                         bAsChild ? SAL_MSG_RECREATECHILDHWND : SAL_MSG_RECREATEHWND,
-                                        (WPARAM) hWndParent, (LPARAM)pThis->maFrameData.mhWnd );
+                                        (WPARAM) hWndParent, (LPARAM)pThis->mhWnd );
 
     // succeeded ?
     hWndParent = ::GetParent( hWnd );
-    DBG_ASSERT( hWndParent == hNewParentWnd, "SalFrame::SetParent not successful");
+    DBG_ASSERT( hWndParent == hNewParentWnd, "WinSalFrame::SetParent not successful");
 
     // recreate DCs
     if( bNeedGraphics )
     {
-        if( pThis->maFrameData.mpGraphics2 )
+        if( pThis->mpGraphics2 )
         {
             // re-create cached DC
-            HDC hDC = (HDC)ImplSendMessage( GetSalData()->mpFirstInstance->maInstData.mhComWnd,
+            HDC hDC = (HDC)ImplSendMessage( GetSalData()->mpFirstInstance->mhComWnd,
                                             SAL_MSG_GETDC,
                                             (WPARAM) hWnd, 0 );
-            pThis->maFrameData.mpGraphics2->maGraphicsData.mhWnd = hWnd;
+            pThis->mpGraphics2->mhWnd = hWnd;
             if ( hDC )
             {
-                pThis->maFrameData.mpGraphics2->maGraphicsData.mhDC = hDC;
+                pThis->mpGraphics2->mhDC = hDC;
                 if ( GetSalData()->mhDitherPal )
                 {
-                    pThis->maFrameData.mpGraphics2->maGraphicsData.mhDefPal = SelectPalette( hDC, GetSalData()->mhDitherPal, TRUE );
+                    pThis->mpGraphics2->mhDefPal = SelectPalette( hDC, GetSalData()->mhDitherPal, TRUE );
                     RealizePalette( hDC );
                 }
-                ImplSalInitGraphics( &(pThis->maFrameData.mpGraphics2->maGraphicsData) );
+                ImplSalInitGraphics( pThis->mpGraphics2 );
 
                 // re-select saved gdi objects
                 if( hFont )
@@ -1587,23 +1585,23 @@ static void ImplSetParentFrame( SalFrame
                 if( hBrush )
                     SelectObject( hDC, hBrush );
 
-                pThis->maFrameData.mbGraphics = TRUE;
+                pThis->mbGraphics = TRUE;
                 GetSalData()->mnCacheDCInUse++;
             }
         }
 
-        if( pThis->maFrameData.mpGraphics )
+        if( pThis->mpGraphics )
         {
             // re-create DC
-            pThis->maFrameData.mpGraphics->maGraphicsData.mhWnd = hWnd;
-            pThis->maFrameData.mpGraphics->maGraphicsData.mhDC = GetDC( hWnd );
+            pThis->mpGraphics->mhWnd = hWnd;
+            pThis->mpGraphics->mhDC = GetDC( hWnd );
             if ( GetSalData()->mhDitherPal )
             {
-                pThis->maFrameData.mpGraphics->maGraphicsData.mhDefPal = SelectPalette( pThis->maFrameData.mpGraphics->maGraphicsData.mhDC, GetSalData()->mhDitherPal, TRUE );
-                RealizePalette( pThis->maFrameData.mpGraphics->maGraphicsData.mhDC );
+                pThis->mpGraphics->mhDefPal = SelectPalette( pThis->mpGraphics->mhDC, GetSalData()->mhDitherPal, TRUE );
+                RealizePalette( pThis->mpGraphics->mhDC );
             }
-            ImplSalInitGraphics( &(pThis->maFrameData.mpGraphics->maGraphicsData) );
-            pThis->maFrameData.mbGraphics = TRUE;
+            ImplSalInitGraphics( pThis->mpGraphics );
+            pThis->mbGraphics = TRUE;
         }
     }
 
@@ -1615,12 +1613,12 @@ static void ImplSetParentFrame( SalFrame
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetParent( SalFrame* pNewParent )
+void WinSalFrame::SetParent( SalFrame* pNewParent )
 {
-    ImplSetParentFrame( this, pNewParent->maFrameData.mhWnd, FALSE );
+    ImplSetParentFrame( this, static_cast<WinSalFrame*>(pNewParent)->mhWnd, FALSE );
 }
 
-bool SalFrame::SetPluginParent( SystemParentData* pNewParent )
+bool WinSalFrame::SetPluginParent( SystemParentData* pNewParent )
 {
     if ( pNewParent->hWnd == 0 )
     {
@@ -1633,10 +1631,10 @@ bool SalFrame::SetPluginParent( SystemPa
 
 // -----------------------------------------------------------------------
 
-void SalFrame::GetWorkArea( Rectangle &rRect )
+void WinSalFrame::GetWorkArea( Rectangle &rRect )
 {
     RECT aRect;
-	ImplSalGetWorkArea( maFrameData.mhWnd, &aRect, NULL );
+	ImplSalGetWorkArea( mhWnd, &aRect, NULL );
     rRect.nLeft     = aRect.left;
     rRect.nRight    = aRect.right-1;
     rRect.nTop      = aRect.top;
@@ -1645,7 +1643,7 @@ void SalFrame::GetWorkArea( Rectangle &r
 
 // -----------------------------------------------------------------------
 
-void SalFrame::GetClientSize( long& rWidth, long& rHeight )
+void WinSalFrame::GetClientSize( long& rWidth, long& rHeight )
 {
     rWidth  = maGeometry.nWidth;
     rHeight = maGeometry.nHeight;
@@ -1653,7 +1651,7 @@ void SalFrame::GetClientSize( long& rWid
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetWindowState( const SalFrameState* pState )
+void WinSalFrame::SetWindowState( const SalFrameState* pState )
 {
     // Wir testen, ob das Fenster ueberhaupt auf den Bildschirm passt, damit
     // nicht wenn die Bildschirm-Aufloesung geaendert wurde, das Fenster aus
@@ -1668,7 +1666,7 @@ void SalFrame::SetWindowState( const Sal
     int     nScreenHeight;
 
     RECT aRect;
-	ImplSalGetWorkArea( maFrameData.mhWnd, &aRect, NULL );
+	ImplSalGetWorkArea( mhWnd, &aRect, NULL );
     // #102500# allow some overlap, the window could have been made a little larger than the physical screen
     nScreenX        = aRect.left-10;
     nScreenY        = aRect.top-10;
@@ -1677,13 +1675,13 @@ void SalFrame::SetWindowState( const Sal
 
     UINT    nPosSize    = 0;
     RECT    aWinRect;
-    GetWindowRect( maFrameData.mhWnd, &aWinRect );
+    GetWindowRect( mhWnd, &aWinRect );
 
     // to be consistent with Unix, the frame state is without(!) decoration
     // ->add the decoration
     RECT aRect2 = aWinRect;
-	AdjustWindowRectEx( &aRect2, GetWindowStyle( maFrameData.mhWnd ),
-					FALSE,     GetWindowExStyle( maFrameData.mhWnd ) );
+	AdjustWindowRectEx( &aRect2, GetWindowStyle( mhWnd ),
+					FALSE,     GetWindowExStyle( mhWnd ) );
     long nTopDeco = abs( aWinRect.top - aRect2.top );
     long nLeftDeco = abs( aWinRect.left - aRect2.left );
     long nBottomDeco = abs( aWinRect.bottom - aRect2.bottom );
@@ -1730,28 +1728,28 @@ void SalFrame::SetWindowState( const Sal
     // Restore-Position setzen
     WINDOWPLACEMENT aPlacement;
     aPlacement.length = sizeof( aPlacement );
-    GetWindowPlacement( maFrameData.mhWnd, &aPlacement );
+    GetWindowPlacement( mhWnd, &aPlacement );
 
     // Status setzen
-    BOOL bVisible = (GetWindowStyle( maFrameData.mhWnd ) & WS_VISIBLE) != 0;
+    BOOL bVisible = (GetWindowStyle( mhWnd ) & WS_VISIBLE) != 0;
 	BOOL bUpdateHiddenFramePos = FALSE;
     if ( !bVisible )
     {
         aPlacement.showCmd = SW_HIDE;
 
-        if ( maFrameData.mbOverwriteState )
+        if ( mbOverwriteState )
         {
             if ( pState->mnMask & SAL_FRAMESTATE_MASK_STATE )
             {
                 if ( pState->mnState & SAL_FRAMESTATE_MINIMIZED )
-                    maFrameData.mnShowState = SW_SHOWMINIMIZED;
+                    mnShowState = SW_SHOWMINIMIZED;
                 else if ( pState->mnState & SAL_FRAMESTATE_MAXIMIZED )
 				{
-                    maFrameData.mnShowState = SW_SHOWMAXIMIZED;
+                    mnShowState = SW_SHOWMAXIMIZED;
 					bUpdateHiddenFramePos = TRUE;
 				}
                 else if ( pState->mnState & SAL_FRAMESTATE_NORMAL )
-                    maFrameData.mnShowState = SW_SHOWNORMAL;
+                    mnShowState = SW_SHOWNORMAL;
             }
         }
     }
@@ -1775,7 +1773,7 @@ void SalFrame::SetWindowState( const Sal
     // Wenn Fenster nicht minimiert/maximiert ist oder nicht optisch
     // umgesetzt werden muss, dann SetWindowPos() benutzen, da
     // SetWindowPlacement() die TaskBar mit einrechnet
-    if ( !IsIconic( maFrameData.mhWnd ) && !IsZoomed( maFrameData.mhWnd ) &&
+    if ( !IsIconic( mhWnd ) && !IsZoomed( mhWnd ) &&
          (!bVisible || (aPlacement.showCmd == SW_RESTORE)) )
     {
 		if( bUpdateHiddenFramePos )
@@ -1794,16 +1792,16 @@ void SalFrame::SetWindowState( const Sal
             // Get screensize of the monitor whith the mouse pointer
 
 			RECT aRect;
-			ImplSalGetWorkArea( maFrameData.mhWnd, &aRect, &aRectMouse );
-			AdjustWindowRectEx( &aRect, GetWindowStyle( maFrameData.mhWnd ),
-								FALSE,     GetWindowExStyle( maFrameData.mhWnd ) );
+			ImplSalGetWorkArea( mhWnd, &aRect, &aRectMouse );
+			AdjustWindowRectEx( &aRect, GetWindowStyle( mhWnd ),
+								FALSE,     GetWindowExStyle( mhWnd ) );
 			maGeometry.nX = aRect.left;
 			maGeometry.nY = aRect.top;;
 			maGeometry.nWidth = aRect.right - aRect.left + 1;
 			maGeometry.nHeight = aRect.bottom - aRect.top + 1;
 		}
 		else
-			SetWindowPos( maFrameData.mhWnd, 0,
+			SetWindowPos( mhWnd, 0,
                       nX, nY, nWidth, nHeight,
                       SWP_NOZORDER | SWP_NOACTIVATE | nPosSize );
     }
@@ -1816,20 +1814,20 @@ void SalFrame::SetWindowState( const Sal
             aPlacement.rcNormalPosition.right   = nX+nWidth-nScreenX;
             aPlacement.rcNormalPosition.bottom  = nY+nHeight-nScreenY;
         }
-        SetWindowPlacement( maFrameData.mhWnd, &aPlacement );
+        SetWindowPlacement( mhWnd, &aPlacement );
     }
 
     if( !(nPosSize & SWP_NOMOVE) )
-        maFrameData.mbDefPos = FALSE; // window was positioned
+        mbDefPos = FALSE; // window was positioned
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalFrame::GetWindowState( SalFrameState* pState )
+BOOL WinSalFrame::GetWindowState( SalFrameState* pState )
 {
-    if ( maFrameData.maState.mnWidth && maFrameData.maState.mnHeight )
+    if ( maState.mnWidth && maState.mnHeight )
     {
-        *pState = maFrameData.maState;
+        *pState = maState;
         // #94144# allow Minimize again, should be masked out when read from configuration
         // 91625 - Don't save minimize
         //if ( !(pState->mnState & SAL_FRAMESTATE_MAXIMIZED) )
@@ -1843,32 +1841,29 @@ BOOL SalFrame::GetWindowState( SalFrameS
 
 // -----------------------------------------------------------------------
 
-void SalFrame::ShowFullScreen( BOOL bFullScreen )
+void WinSalFrame::ShowFullScreen( BOOL bFullScreen )
 {
-    if ( maFrameData.mbFullScreen == bFullScreen )
+    if ( mbFullScreen == bFullScreen )
         return;
 
-    maFrameData.mbFullScreen = bFullScreen;
+    mbFullScreen = bFullScreen;
     if ( bFullScreen )
     {
-#if ( WINVER >= 0x0400 )
         // Damit Taskleiste von Windows ausgeblendet wird
-        DWORD nExStyle = GetWindowExStyle( maFrameData.mhWnd );
+        DWORD nExStyle = GetWindowExStyle( mhWnd );
         if ( nExStyle & WS_EX_TOOLWINDOW )
         {
-            maFrameData.mbFullScreenToolWin = TRUE;
+            mbFullScreenToolWin = TRUE;
             nExStyle &= ~WS_EX_TOOLWINDOW;
-            SetWindowExStyle( maFrameData.mhWnd, nExStyle );
+            SetWindowExStyle( mhWnd, nExStyle );
         }
-#endif
-
         // save old position
-        GetWindowRect( maFrameData.mhWnd, &maFrameData.maFullScreenRect );
+        GetWindowRect( mhWnd, &maFullScreenRect );
 
         // save show state
-        maFrameData.mnFullScreenShowState = maFrameData.mnShowState;
-        if ( !(GetWindowStyle( maFrameData.mhWnd ) & WS_VISIBLE) )
-            maFrameData.mnShowState = SW_SHOW;
+        mnFullScreenShowState = mnShowState;
+        if ( !(GetWindowStyle( mhWnd ) & WS_VISIBLE) )
+            mnShowState = SW_SHOW;
 
         // set window to screen size
         ImplSalFrameFullScreenPos( this, TRUE );
@@ -1877,33 +1872,31 @@ void SalFrame::ShowFullScreen( BOOL bFul
     {
         // wenn ShowState wieder hergestellt werden muss, hiden wir zuerst
         // das Fenster, damit es nicht so sehr flackert
-        BOOL bVisible = (GetWindowStyle( maFrameData.mhWnd ) & WS_VISIBLE) != 0;
-        if ( bVisible && (maFrameData.mnShowState != maFrameData.mnFullScreenShowState) )
-            ShowWindow( maFrameData.mhWnd, SW_HIDE );
-
-#if ( WINVER >= 0x0400 )
-        if ( maFrameData.mbFullScreenToolWin )
-            SetWindowExStyle( maFrameData.mhWnd, GetWindowExStyle( maFrameData.mhWnd ) | WS_EX_TOOLWINDOW );
-        maFrameData.mbFullScreenToolWin = FALSE;
-#endif
-
-        SetWindowPos( maFrameData.mhWnd, 0,
-                      maFrameData.maFullScreenRect.left,
-                      maFrameData.maFullScreenRect.top,
-                      maFrameData.maFullScreenRect.right-maFrameData.maFullScreenRect.left,
-                      maFrameData.maFullScreenRect.bottom-maFrameData.maFullScreenRect.top,
+        BOOL bVisible = (GetWindowStyle( mhWnd ) & WS_VISIBLE) != 0;
+        if ( bVisible && (mnShowState != mnFullScreenShowState) )
+            ShowWindow( mhWnd, SW_HIDE );
+
+        if ( mbFullScreenToolWin )
+            SetWindowExStyle( mhWnd, GetWindowExStyle( mhWnd ) | WS_EX_TOOLWINDOW );
+        mbFullScreenToolWin = FALSE;
+
+        SetWindowPos( mhWnd, 0,
+                      maFullScreenRect.left,
+                      maFullScreenRect.top,
+                      maFullScreenRect.right-maFullScreenRect.left,
+                      maFullScreenRect.bottom-maFullScreenRect.top,
                       SWP_NOZORDER | SWP_NOACTIVATE );
 
         // restore show state
-        if ( maFrameData.mnShowState != maFrameData.mnFullScreenShowState )
+        if ( mnShowState != mnFullScreenShowState )
         {
-            maFrameData.mnShowState = maFrameData.mnFullScreenShowState;
+            mnShowState = mnFullScreenShowState;
             if ( bVisible )
             {
-                maFrameData.mbInShow = TRUE;
-                ShowWindow( maFrameData.mhWnd, maFrameData.mnShowState );
-                maFrameData.mbInShow = FALSE;
-                UpdateWindow( maFrameData.mhWnd );
+                mbInShow = TRUE;
+                ShowWindow( mhWnd, mnShowState );
+                mbInShow = FALSE;
+                UpdateWindow( mhWnd );
             }
         }
     }
@@ -1911,17 +1904,16 @@ void SalFrame::ShowFullScreen( BOOL bFul
 
 // -----------------------------------------------------------------------
 
-void SalFrame::StartPresentation( BOOL bStart )
+void WinSalFrame::StartPresentation( BOOL bStart )
 {
-    if ( maFrameData.mbPresentation == bStart )
+    if ( mbPresentation == bStart )
         return;
 
-    maFrameData.mbPresentation = bStart;
+    mbPresentation = bStart;
 
     SalData* pSalData = GetSalData();
     if ( bStart )
     {
-#if ( WINVER >= 0x0400 )
         if ( !pSalData->mpSageEnableProc )
         {
             if ( pSalData->mnSageStatus != DISABLE_AGENT )
@@ -1945,7 +1937,6 @@ void SalFrame::StartPresentation( BOOL b
             if ( pSalData->mnSageStatus == ENABLE_AGENT )
                 pSalData->mpSageEnableProc( DISABLE_AGENT );
         }
-#endif
 
         // Bildschirmschoner ausschalten, wenn Praesentation laueft
         SystemParametersInfo( SPI_GETSCREENSAVEACTIVE, 0,
@@ -1959,24 +1950,22 @@ void SalFrame::StartPresentation( BOOL b
         if ( pSalData->mbScrSvrEnabled )
             SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, pSalData->mbScrSvrEnabled, 0, 0 );
 
-#if ( WINVER >= 0x0400 )
         // Systemagenten wieder aktivieren
         if ( pSalData->mnSageStatus == ENABLE_AGENT )
             pSalData->mpSageEnableProc( pSalData->mnSageStatus );
-#endif
     }
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetAlwaysOnTop( BOOL bOnTop )
+void WinSalFrame::SetAlwaysOnTop( BOOL bOnTop )
 {
     HWND hWnd;
     if ( bOnTop )
         hWnd = HWND_TOPMOST;
     else
         hWnd = HWND_NOTOPMOST;
-    SetWindowPos( maFrameData.mhWnd, hWnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE );
+    SetWindowPos( mhWnd, hWnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE );
 }
 
 // -----------------------------------------------------------------------
@@ -1993,10 +1982,10 @@ static void ImplSalToTop( HWND hWnd, USH
         {
             if ( IsIconic( hIconicWnd ) )
             {
-                SalFrame* pFrame = GetWindowPtr( hIconicWnd );
+                WinSalFrame* pFrame = GetWindowPtr( hIconicWnd );
                 if ( pFrame )
                 {
-                    if ( GetWindowPtr( hWnd )->maFrameData.mbRestoreMaximize )
+                    if ( GetWindowPtr( hWnd )->mbRestoreMaximize )
                         ShowWindow( hIconicWnd, SW_MAXIMIZE );
                     else
                         ShowWindow( hIconicWnd, SW_RESTORE );
@@ -2023,21 +2012,21 @@ static void ImplSalToTop( HWND hWnd, USH
 
 // -----------------------------------------------------------------------
 
-void SalFrame::ToTop( USHORT nFlags )
+void WinSalFrame::ToTop( USHORT nFlags )
 {
 	nFlags &= ~SAL_FRAME_TOTOP_GRABFOCUS;	// this flag is not needed on win32
     // Post this Message to the window, because this only works
     // in the thread of the window, which has create this window.
     // We post this message to avoid deadlocks
     if ( GetSalData()->mnAppThreadId != GetCurrentThreadId() )
-        ImplPostMessage( maFrameData.mhWnd, SAL_MSG_TOTOP, nFlags, 0 );
+        ImplPostMessage( mhWnd, SAL_MSG_TOTOP, nFlags, 0 );
     else
-        ImplSalToTop( maFrameData.mhWnd, nFlags );
+        ImplSalToTop( mhWnd, nFlags );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetPointer( PointerStyle ePointerStyle )
+void WinSalFrame::SetPointer( PointerStyle ePointerStyle )
 {
     struct ImplPtrData
     {
@@ -2052,11 +2041,7 @@ void SalFrame::SetPointer( PointerStyle 
     { 0, 0, SAL_RESID_POINTER_NULL },               // POINTER_NULL
     { 0, IDC_WAIT, 0 },                             // POINTER_WAIT
     { 0, IDC_IBEAM, 0 },                            // POINTER_TEXT
-#if ( WINVER >= 0x0400 )
     { 0, IDC_HELP, 0 },                             // POINTER_HELP
-#else
-    { 0, 0, SAL_RESID_POINTER_HELP },               // POINTER_HELP
-#endif
     { 0, 0, SAL_RESID_POINTER_CROSS },              // POINTER_CROSS
     { 0, 0, SAL_RESID_POINTER_MOVE },               // POINTER_MOVE
     { 0, IDC_SIZENS, 0 },                           // POINTER_NSIZE
@@ -2156,16 +2141,16 @@ void SalFrame::SetPointer( PointerStyle 
     }
 
     // Unterscheidet sich der Mauspointer, dann den neuen setzen
-    if ( maFrameData.mhCursor != aImplPtrTab[ePointerStyle].mhCursor )
+    if ( mhCursor != aImplPtrTab[ePointerStyle].mhCursor )
     {
-        maFrameData.mhCursor = aImplPtrTab[ePointerStyle].mhCursor;
-        SetCursor( maFrameData.mhCursor );
+        mhCursor = aImplPtrTab[ePointerStyle].mhCursor;
+        SetCursor( mhCursor );
     }
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::CaptureMouse( BOOL bCapture )
+void WinSalFrame::CaptureMouse( BOOL bCapture )
 {
     // Send this Message to the window, because CaptureMouse() only work
     // in the thread of the window, which has create this window
@@ -2174,30 +2159,30 @@ void SalFrame::CaptureMouse( BOOL bCaptu
         nMsg = SAL_MSG_CAPTUREMOUSE;
     else
         nMsg = SAL_MSG_RELEASEMOUSE;
-    ImplSendMessage( maFrameData.mhWnd, nMsg, 0, 0 );
+    ImplSendMessage( mhWnd, nMsg, 0, 0 );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetPointerPos( long nX, long nY )
+void WinSalFrame::SetPointerPos( long nX, long nY )
 {
     POINT aPt;
     aPt.x = (int)nX;
     aPt.y = (int)nY;
-    ClientToScreen( maFrameData.mhWnd, &aPt );
+    ClientToScreen( mhWnd, &aPt );
     SetCursorPos( aPt.x, aPt.y );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Flush()
+void WinSalFrame::Flush()
 {
     GdiFlush();
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Sync()
+void WinSalFrame::Sync()
 {
     GdiFlush();
 }
@@ -2206,37 +2191,37 @@ void SalFrame::Sync()
 
 static void ImplSalFrameSetInputContext( HWND hWnd, const SalInputContext* pContext )
 {
-    SalFrame*   pFrame = GetWindowPtr( hWnd );
+    WinSalFrame*   pFrame = GetWindowPtr( hWnd );
     BOOL        bIME = (pContext->mnOptions & SAL_INPUTCONTEXT_TEXT) != 0;
     if ( bIME )
     {
-        if ( !pFrame->maFrameData.mbIME )
+        if ( !pFrame->mbIME )
         {
-            pFrame->maFrameData.mbIME = TRUE;
+            pFrame->mbIME = TRUE;
 
-            if ( pFrame->maFrameData.mhDefIMEContext )
+            if ( pFrame->mhDefIMEContext )
             {
-                ImmAssociateContext( pFrame->maFrameData.mhWnd, pFrame->maFrameData.mhDefIMEContext );
+                ImmAssociateContext( pFrame->mhWnd, pFrame->mhDefIMEContext );
                 UINT nImeProps = ImmGetProperty( GetKeyboardLayout( 0 ), IGP_PROPERTY );
-                pFrame->maFrameData.mbSpezIME = (nImeProps & IME_PROP_SPECIAL_UI) != 0;
-                pFrame->maFrameData.mbAtCursorIME = (nImeProps & IME_PROP_AT_CARET) != 0;
-                pFrame->maFrameData.mbHandleIME = !pFrame->maFrameData.mbSpezIME;
+                pFrame->mbSpezIME = (nImeProps & IME_PROP_SPECIAL_UI) != 0;
+                pFrame->mbAtCursorIME = (nImeProps & IME_PROP_AT_CARET) != 0;
+                pFrame->mbHandleIME = !pFrame->mbSpezIME;
             }
         }
 
         // When the application can't handle IME messages, then the
         // System should handle the IME handling
         if ( !(pContext->mnOptions & SAL_INPUTCONTEXT_EXTTEXTINPUT) )
-            pFrame->maFrameData.mbHandleIME = FALSE;
+            pFrame->mbHandleIME = FALSE;
 
         // Set the Font for IME Handling
         if ( pContext->mpFont )
         {
-            HIMC hIMC = ImmGetContext( pFrame->maFrameData.mhWnd );
+            HIMC hIMC = ImmGetContext( pFrame->mhWnd );
             if ( hIMC )
             {
                 LOGFONTW aLogFont;
-                HDC hDC = GetDC( pFrame->maFrameData.mhWnd );
+                HDC hDC = GetDC( pFrame->mhWnd );
                 // In case of vertical writing, always append a '@' to the
                 // Windows font name, not only if such a Windows font really is
                 // available (bTestVerticalAvail == false in the below call):
@@ -2247,29 +2232,29 @@ static void ImplSalFrameSetInputContext(
                 // '@' in front of this font name.
                 ImplGetLogFontFromFontSelect( hDC, pContext->mpFont, aLogFont,
                                               false );
-                ReleaseDC( pFrame->maFrameData.mhWnd, hDC );
+                ReleaseDC( pFrame->mhWnd, hDC );
                 ImmSetCompositionFontW( hIMC, &aLogFont );
-                ImmReleaseContext( pFrame->maFrameData.mhWnd, hIMC );
+                ImmReleaseContext( pFrame->mhWnd, hIMC );
             }
         }
     }
     else
     {
-        if ( pFrame->maFrameData.mbIME )
+        if ( pFrame->mbIME )
         {
-            pFrame->maFrameData.mbIME = FALSE;
-            pFrame->maFrameData.mbHandleIME = FALSE;
-            ImmAssociateContext( pFrame->maFrameData.mhWnd, 0 );
+            pFrame->mbIME = FALSE;
+            pFrame->mbHandleIME = FALSE;
+            ImmAssociateContext( pFrame->mhWnd, 0 );
         }
     }
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetInputContext( SalInputContext* pContext )
+void WinSalFrame::SetInputContext( SalInputContext* pContext )
 {
     // Must be called in the main thread!
-    ImplSendMessage( maFrameData.mhWnd, SAL_MSG_SETINPUTCONTEXT, 0, (LPARAM)(void*)pContext );
+    ImplSendMessage( mhWnd, SAL_MSG_SETINPUTCONTEXT, 0, (LPARAM)(void*)pContext );
 }
 
 // -----------------------------------------------------------------------
@@ -2292,10 +2277,10 @@ static void ImplSalFrameEndExtTextInput(
 
 // -----------------------------------------------------------------------
 
-void SalFrame::EndExtTextInput( USHORT nFlags )
+void WinSalFrame::EndExtTextInput( USHORT nFlags )
 {
     // Must be called in the main thread!
-    ImplSendMessage( maFrameData.mhWnd, SAL_MSG_ENDEXTTEXTINPUT, (WPARAM)nFlags, 0 );
+    ImplSendMessage( mhWnd, SAL_MSG_ENDEXTTEXTINPUT, (WPARAM)nFlags, 0 );
 }
 
 // -----------------------------------------------------------------------
@@ -2304,7 +2289,7 @@ static void ImplGetKeyNameText( LONG lPa
                                 UINT& rCount, UINT nMaxSize,
                                 const sal_Char* pReplace )
 {
-    DBG_ASSERT( sizeof( WCHAR ) == sizeof( xub_Unicode ), "SalFrame::ImplGetKeyNameTextW(): WCHAR != sal_Unicode" );
+    DBG_ASSERT( sizeof( WCHAR ) == sizeof( xub_Unicode ), "WinSalFrame::ImplGetKeyNameTextW(): WCHAR != sal_Unicode" );
 
     WCHAR aKeyBuf[350];
     int nKeyLen = 0;
@@ -2384,7 +2369,7 @@ static void ImplGetKeyNameText( LONG lPa
 
 // -----------------------------------------------------------------------
 
-XubString SalFrame::GetKeyName( USHORT nKeyCode )
+XubString WinSalFrame::GetKeyName( USHORT nKeyCode )
 {
     XubString   aKeyCode;
     sal_Unicode aKeyBuf[350];
@@ -2593,7 +2578,7 @@ XubString SalFrame::GetKeyName( USHORT n
 
 // -----------------------------------------------------------------------
 
-XubString SalFrame::GetSymbolKeyName( const XubString&, USHORT nKeyCode )
+XubString WinSalFrame::GetSymbolKeyName( const XubString&, USHORT nKeyCode )
 {
     return GetKeyName( nKeyCode );
 }
@@ -2674,7 +2659,7 @@ static long ImplA2I( const BYTE* pStr )
 
 // -----------------------------------------------------------------------
 
-void SalFrame::UpdateSettings( AllSettings& rSettings )
+void WinSalFrame::UpdateSettings( AllSettings& rSettings )
 {
     MouseSettings aMouseSettings = rSettings.GetMouseSettings();
     aMouseSettings.SetDoubleClickTime( GetDoubleClickTime() );
@@ -2706,13 +2691,10 @@ void SalFrame::UpdateSettings( AllSettin
 
     StyleSettings aStyleSettings = rSettings.GetStyleSettings();
     BOOL bCompBorder = (aStyleSettings.GetOptions() & (STYLE_OPTION_MACSTYLE | STYLE_OPTION_UNIXSTYLE)) == 0;
-#if (_MSC_VER < 1300)
-    aStyleSettings.SetScrollBarSize( std::min( GetSystemMetrics( SM_CXVSCROLL ), 20 ) ); // #99956# do not allow huge scrollbars, most of the UI is not scaled anymore
-    aStyleSettings.SetSpinSize( std::min( GetSystemMetrics( SM_CXVSCROLL ), 20 ) );
-#else
-    aStyleSettings.SetScrollBarSize( min( GetSystemMetrics( SM_CXVSCROLL ), 20 ) ); // #99956# do not allow huge scrollbars, most of the UI is not scaled anymore
-    aStyleSettings.SetSpinSize( min( GetSystemMetrics( SM_CXVSCROLL ), 20 ) );
-#endif
+    // TODO: once those options vanish: just set bCompBorder to TRUE
+    // to have the system colors read
+    aStyleSettings.SetScrollBarSize( Min( GetSystemMetrics( SM_CXVSCROLL ), 20 ) ); // #99956# do not allow huge scrollbars, most of the UI is not scaled anymore
+    aStyleSettings.SetSpinSize( Min( GetSystemMetrics( SM_CXVSCROLL ), 20 ) );
     aStyleSettings.SetCursorBlinkTime( GetCaretBlinkTime() );
     if ( bCompBorder )
     {
@@ -2754,6 +2736,7 @@ void SalFrame::UpdateSettings( AllSettin
         aStyleSettings.SetMenuColor( ImplWinColorToSal( GetSysColor( COLOR_MENU ) ) );
         aStyleSettings.SetMenuBarColor( aStyleSettings.GetMenuColor() );
         aStyleSettings.SetMenuBorderColor( aStyleSettings.GetLightBorderColor() ); // overriden below for flat menus
+        aStyleSettings.SetUseFlatBorders( FALSE );
         aStyleSettings.SetUseFlatMenues( FALSE );
         aStyleSettings.SetMenuTextColor( ImplWinColorToSal( GetSysColor( COLOR_MENUTEXT ) ) );
         aStyleSettings.SetActiveColor( ImplWinColorToSal( GetSysColor( COLOR_ACTIVECAPTION ) ) );
@@ -2771,6 +2754,10 @@ void SalFrame::UpdateSettings( AllSettin
                 aStyleSettings.SetMenuBarColor( ImplWinColorToSal( GetSysColor( COLOR_MENUBAR ) ) );
                 aStyleSettings.SetMenuHighlightColor( ImplWinColorToSal( GetSysColor( COLOR_MENUHILIGHT ) ) );
                 aStyleSettings.SetMenuBorderColor( ImplWinColorToSal( GetSysColor( COLOR_3DSHADOW ) ) );
+
+                // flat borders for our controls etc. as well in this mode (ie, no 3d borders)
+                // this is not active in the classic style appearance
+                aStyleSettings.SetUseFlatBorders( TRUE );
             }
         }
     }
@@ -2925,16 +2912,16 @@ void SalFrame::UpdateSettings( AllSettin
 
 // -----------------------------------------------------------------------
 
-SalBitmap* SalFrame::SnapShot()
+SalBitmap* WinSalFrame::SnapShot()
 {
-    SalBitmap* pSalBitmap = NULL;
+    WinSalBitmap* pSalBitmap = NULL;
 
     RECT aRect;
-    GetWindowRect( maFrameData.mhWnd, &aRect );
+    GetWindowRect( mhWnd, &aRect );
 
     int     nDX = aRect.right-aRect.left;
     int     nDY = aRect.bottom-aRect.top;
-    HDC     hDC = GetWindowDC( maFrameData.mhWnd );
+    HDC     hDC = GetWindowDC( mhWnd );
     HBITMAP hBmpBitmap = CreateCompatibleBitmap( hDC, nDX, nDY );
     HDC     hBmpDC = ImplGetCachedDC( CACHED_HDC_1, hBmpBitmap );
     BOOL    bRet;
@@ -2944,7 +2931,7 @@ SalBitmap* SalFrame::SnapShot()
 
     if ( bRet )
     {
-        pSalBitmap = new SalBitmap;
+        pSalBitmap = new WinSalBitmap;
 
         if ( !pSalBitmap->Create( hBmpBitmap, FALSE, FALSE ) )
         {
@@ -2958,14 +2945,14 @@ SalBitmap* SalFrame::SnapShot()
 
 // -----------------------------------------------------------------------
 
-const SystemEnvData* SalFrame::GetSystemData() const
+const SystemEnvData* WinSalFrame::GetSystemData() const
 {
-    return &maFrameData.maSysData;
+    return &maSysData;
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Beep( SoundType eSoundType )
+void WinSalFrame::Beep( SoundType eSoundType )
 {
     static UINT aImplSoundTab[5] =
     {
@@ -2976,27 +2963,12 @@ void SalFrame::Beep( SoundType eSoundTyp
         MB_ICONQUESTION                 // SOUND_QUERY
     };
 
-#if SOUND_COUNT != 5
-#error New Sound must be defined!
-#endif
-
     MessageBeep( aImplSoundTab[eSoundType] );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetCallback( void* pInst, SALFRAMEPROC pProc )
-{
-    maFrameData.mpInst = pInst;
-    if ( pProc )
-        maFrameData.mpProc = pProc;
-    else
-        maFrameData.mpProc = ImplSalCallbackDummy;
-}
-
-// -----------------------------------------------------------------------
-
-ULONG SalFrame::GetCurrentModButtons()
+ULONG WinSalFrame::GetCurrentModButtons()
 {
     ULONG nMod = 0;
 
@@ -3020,7 +2992,7 @@ ULONG SalFrame::GetCurrentModButtons()
 static long ImplHandleMouseMsg( HWND hWnd, UINT nMsg,
                                 WPARAM wParam, LPARAM lParam )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( !pFrame )
         return 0;
 
@@ -3029,7 +3001,7 @@ static long ImplHandleMouseMsg( HWND hWn
         // #103168# post again if async focus has not arrived yet
         // hopefully we will not receive the corresponding button up before this
         // button down arrives again
-        Window *pWin = (Window*) pFrame->maFrameData.mpInst;
+        Window *pWin = (Window*) pFrame->GetInstance();
         if( pWin && pWin->mpFrameData->mnFocusId )
         {
             ImplPostMessage( hWnd, nMsg, wParam, lParam );
@@ -3173,10 +3145,9 @@ static long ImplHandleMouseMsg( HWND hWn
         if( Application::GetSettings().GetLayoutRTL() )
             aMouseEvt.mnX = pFrame->maGeometry.nWidth-1-aMouseEvt.mnX;
 
-        nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                           nEvent, &aMouseEvt );
+        nRet = pFrame->CallCallback( nEvent, &aMouseEvt );
         if ( nMsg == WM_MOUSEMOVE )
-            SetCursor( pFrame->maFrameData.mhCursor );
+            SetCursor( pFrame->mhCursor );
     }
     else
         nRet = 0;
@@ -3188,11 +3159,11 @@ static long ImplHandleMouseMsg( HWND hWn
 
 static long ImplHandleMouseActivateMsg( HWND hWnd )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( !pFrame )
         return 0;
 
-    if ( pFrame->maFrameData.mbFloatWin )
+    if ( pFrame->mbFloatWin )
         return TRUE;
 
     SalMouseActivateEvent   aMouseActivateEvt;
@@ -3201,8 +3172,7 @@ static long ImplHandleMouseActivateMsg( 
     ScreenToClient( hWnd, &aPt );
     aMouseActivateEvt.mnX = aPt.x;
     aMouseActivateEvt.mnY = aPt.y;
-    return pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                       SALEVENT_MOUSEACTIVATE, &aMouseActivateEvt );
+    return pFrame->CallCallback( SALEVENT_MOUSEACTIVATE, &aMouseActivateEvt );
 }
 
 // -----------------------------------------------------------------------
@@ -3212,7 +3182,7 @@ static long ImplHandleWheelMsg( HWND hWn
     ImplSalYieldMutexAcquireWithWait();
 
     long        nRet = 0;
-    SalFrame*   pFrame = GetWindowPtr( hWnd );
+    WinSalFrame*   pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
         WORD    nWinModCode = LOWORD( wParam );
@@ -3245,8 +3215,7 @@ static long ImplHandleWheelMsg( HWND hWn
         if( Application::GetSettings().GetLayoutRTL() )
             aWheelEvt.mnX = pFrame->maGeometry.nWidth-1-aWheelEvt.mnX;
 
-        nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                           SALEVENT_WHEELMOUSE, &aWheelEvt );
+        nRet = pFrame->CallCallback( SALEVENT_WHEELMOUSE, &aWheelEvt );
     }
 
     ImplSalYieldMutexRelease();
@@ -3306,36 +3275,27 @@ static UINT ImplStrToNum( const sal_Char
 
 // -----------------------------------------------------------------------
 
-LanguageType SalFrame::GetInputLanguage()
-{
-    if( !maFrameData.mnInputLang )
-        return LANGUAGE_DONTKNOW;
-    else
-        return (LanguageType) maFrameData.mnInputLang;
-}
-
-// -----------------------------------------------------------------------
-
-static sal_Unicode ImplGetCharCode( SalFrame* pFrame, WPARAM nCharCode )
+static void ImplUpdateInputLang( WinSalFrame* pFrame )
 {
     BOOL bLanguageChange = FALSE;
     UINT nLang = LOWORD( GetKeyboardLayout( 0 ) );
-    if ( nLang && nLang != pFrame->maFrameData.mnInputLang )
+    if ( nLang && nLang != pFrame->mnInputLang )
     {
         // keep input lang up-to-date
-        pFrame->maFrameData.mnInputLang = nLang;
+        pFrame->mnInputLang = nLang;
         bLanguageChange = TRUE;
     }
 
     // If we are on Windows NT we use Unicode FrameProcs and so we
     // get Unicode charcodes directly from Windows
+    // no need to set up a code page
     if ( aSalShlData.mbWNT )
-        return (sal_Unicode)nCharCode;
+        return;
 
     if ( !nLang )
     {
-        pFrame->maFrameData.mnInputLang     = 0;
-        pFrame->maFrameData.mnInputCodePage = GetACP();
+        pFrame->mnInputLang     = 0;
+        pFrame->mnInputCodePage = GetACP();
     }
     else if ( bLanguageChange )
     {
@@ -3343,13 +3303,24 @@ static sal_Unicode ImplGetCharCode( SalF
         if ( GetLocaleInfoA( MAKELCID( nLang, SORT_DEFAULT ), LOCALE_IDEFAULTANSICODEPAGE,
                              aBuf, sizeof(aBuf) ) > 0 )
         {
-            pFrame->maFrameData.mnInputCodePage = ImplStrToNum( aBuf );
-            if ( !pFrame->maFrameData.mnInputCodePage )
-                pFrame->maFrameData.mnInputCodePage = GetACP();
+            pFrame->mnInputCodePage = ImplStrToNum( aBuf );
+            if ( !pFrame->mnInputCodePage )
+                pFrame->mnInputCodePage = GetACP();
         }
         else
-            pFrame->maFrameData.mnInputCodePage = GetACP();
+            pFrame->mnInputCodePage = GetACP();
     }
+}
+
+
+static sal_Unicode ImplGetCharCode( WinSalFrame* pFrame, WPARAM nCharCode )
+{
+    ImplUpdateInputLang( pFrame );
+
+    // If we are on Windows NT we use Unicode FrameProcs and so we
+    // get Unicode charcodes directly from Windows
+    if ( aSalShlData.mbWNT )
+        return (sal_Unicode)nCharCode;
 
     sal_Char    aCharBuf[2];
     int         nCharLen;
@@ -3365,7 +3336,7 @@ static sal_Unicode ImplGetCharCode( SalF
         aCharBuf[0] = (sal_Char)nCharCode;
         nCharLen = 1;
     }
-    if ( ::MultiByteToWideChar( pFrame->maFrameData.mnInputCodePage,
+    if ( ::MultiByteToWideChar( pFrame->mnInputCodePage,
                                 MB_PRECOMPOSED,
                                 aCharBuf, nCharLen, &c, 1 ) )
         return (sal_Unicode)c;
@@ -3375,6 +3346,19 @@ static sal_Unicode ImplGetCharCode( SalF
 
 // -----------------------------------------------------------------------
 
+LanguageType WinSalFrame::GetInputLanguage()
+{
+    if( !mnInputLang )
+        ImplUpdateInputLang( this );
+
+    if( !mnInputLang )
+        return LANGUAGE_DONTKNOW;
+    else
+        return (LanguageType) mnInputLang;
+}
+
+// -----------------------------------------------------------------------
+
 static long ImplHandleKeyMsg( HWND hWnd, UINT nMsg,
                               WPARAM wParam, LPARAM lParam, LRESULT& rResult )
 {
@@ -3397,15 +3381,15 @@ static long ImplHandleKeyMsg( HWND hWnd,
         return 0;
     }
 
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( !pFrame )
         return 0;
 
     // Wir restaurieren den Background-Modus bei jeder Texteingabe,
     // da einige Tools wie RichWin uns diesen hin- und wieder umsetzen
-    if ( pFrame->maFrameData.mpGraphics &&
-         pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC )
-        SetBkMode( pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC, TRANSPARENT );
+    if ( pFrame->mpGraphics &&
+         pFrame->mpGraphics->mhDC )
+        SetBkMode( pFrame->mpGraphics->mhDC, TRANSPARENT );
 
     // determine modifiers
     if ( GetKeyState( VK_SHIFT ) & 0x8000 )
@@ -3430,7 +3414,13 @@ static long ImplHandleKeyMsg( HWND hWnd,
             // #101635# if zero is returned here for WM_SYSCHAR (ALT+<key>) Windows will beep
             // becaus this 'hotkey' was not processed -> better return 1
             // except for Alt-SPACE which should always open the sysmenu (#104616#)
-            return ( wParam == 0x20 ) ? 0 : 1;
+
+            // also return zero if a system menubar is available that might process this hotkey
+            // this also applies to the OLE inplace embedding where we are a child window
+            if( (GetWindowStyle( hWnd ) & WS_CHILD) || GetMenu( hWnd ) || (wParam == 0x20) )
+                return 0;
+            else
+                return 1;
         }
 
         // Backspace ignorieren wir als eigenstaendige Taste,
@@ -3466,10 +3456,8 @@ static long ImplHandleKeyMsg( HWND hWnd,
         aKeyEvt.mnRepeat    = nRepeat;
         nLastChar = 0;
         nLastVKChar = 0;
-        long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                SALEVENT_KEYINPUT, &aKeyEvt );
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    SALEVENT_KEYUP, &aKeyEvt );
+        long nRet = pFrame->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+        pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
         return nRet;
     }
  	// #i11583#, MCD, 2003-01-13, Support for WM_UNICHAR & Keyman 6.0; addition begins
@@ -3493,10 +3481,8 @@ static long ImplHandleKeyMsg( HWND hWnd,
 			sal_Unicode ch = (sal_Unicode) Uni_UTF32ToSurrogate1(wParam);
 	 		nLastChar = 0;
  			nLastVKChar = 0;
-	 		long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                    SALEVENT_KEYINPUT, &aKeyEvt );
- 			pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_KEYUP, &aKeyEvt );
+	 		long nRet = pFrame->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+ 			pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
 			wParam = (sal_Unicode) Uni_UTF32ToSurrogate2( wParam );
  		}
 
@@ -3504,10 +3490,8 @@ static long ImplHandleKeyMsg( HWND hWnd,
 
  		nLastChar = 0;
  		nLastVKChar = 0;
- 		long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                SALEVENT_KEYINPUT, &aKeyEvt );
- 		pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-					                SALEVENT_KEYUP, &aKeyEvt );
+ 		long nRet = pFrame->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+ 		pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
 
  		return nRet;
  	}
@@ -3551,8 +3535,7 @@ static long ImplHandleKeyMsg( HWND hWnd,
             if( !tmpCode )
                 bWaitForModKeyRelease = false;
 
-            return pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                               SALEVENT_KEYMODCHANGE, &aModEvt );
+            return pFrame->CallCallback( SALEVENT_KEYMODCHANGE, &aModEvt );
         }
         else
         {
@@ -3626,14 +3609,11 @@ static long ImplHandleKeyMsg( HWND hWnd,
                 aKeyEvt.mnCode     |= nModCode;
                 aKeyEvt.mnRepeat    = nRepeat;
                 bIgnoreCharMsg = bCharPeek;
-                long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                        nEvent, &aKeyEvt );
-
+                long nRet = pFrame->CallCallback( nEvent, &aKeyEvt );
                 // independent part only reacts on keyup but Windows does not send
                 // keyup for VK_HANJA
                 if( aKeyEvt.mnCode == KEY_HANGUL_HANJA )
-                    nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                        SALEVENT_KEYUP, &aKeyEvt );
+                    nRet = pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
 
                 bIgnoreCharMsg = FALSE;
 
@@ -3665,7 +3645,7 @@ long ImplHandleSalObjKeyMsg( HWND hWnd, 
 {
     if ( (nMsg == WM_KEYDOWN) || (nMsg == WM_KEYUP) )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( !pFrame )
             return 0;
 
@@ -3704,8 +3684,7 @@ long ImplHandleSalObjKeyMsg( HWND hWnd, 
                 aKeyEvt.mnTime      = GetMessageTime();
                 aKeyEvt.mnCode     |= nModCode;
                 aKeyEvt.mnRepeat    = nRepeat;
-                long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                        nEvent, &aKeyEvt );
+                long nRet = pFrame->CallCallback( nEvent, &aKeyEvt );
                 return nRet;
             }
             else
@@ -3720,7 +3699,7 @@ long ImplHandleSalObjKeyMsg( HWND hWnd, 
 
 long ImplHandleSalObjSysCharMsg( HWND hWnd, WPARAM wParam, LPARAM lParam )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( !pFrame )
         return 0;
 
@@ -3751,10 +3730,8 @@ long ImplHandleSalObjSysCharMsg( HWND hW
     aKeyEvt.mnCode     |= nModCode;
     aKeyEvt.mnCharCode  = ImplGetCharCode( pFrame, cKeyCode );
     aKeyEvt.mnRepeat    = nRepeat;
-    long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_KEYINPUT, &aKeyEvt );
-    pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                SALEVENT_KEYUP, &aKeyEvt );
+    long nRet = pFrame->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+    pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
     return nRet;
 }
 
@@ -3770,13 +3747,13 @@ static void ImplHandlePaintMsg( HWND hWn
     // because other threads doesn't use the mutex from the main
     // thread --> see GetGraphics()
 
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
         // Clip-Region muss zurueckgesetzt werden, da wir sonst kein
         // ordentliches Bounding-Rectangle bekommen
-        if ( pFrame->maFrameData.mpGraphics && pFrame->maFrameData.mpGraphics->maGraphicsData.mhRegion )
-            SelectClipRgn( pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC, 0 );
+        if ( pFrame->mpGraphics && pFrame->mpGraphics->mhRegion )
+            SelectClipRgn( pFrame->mpGraphics->mhDC, 0 );
 
         // Laut Window-Doku soll man erst abfragen, ob ueberhaupt eine
         // Paint-Region anliegt
@@ -3792,10 +3769,10 @@ static void ImplHandlePaintMsg( HWND hWn
 
             // Paint
             // ClipRegion wieder herstellen
-            if ( pFrame->maFrameData.mpGraphics && pFrame->maFrameData.mpGraphics->maGraphicsData.mhRegion )
+            if ( pFrame->mpGraphics && pFrame->mpGraphics->mhRegion )
             {
-                SelectClipRgn( pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC,
-                               pFrame->maFrameData.mpGraphics->maGraphicsData.mhRegion );
+                SelectClipRgn( pFrame->mpGraphics->mhDC,
+                               pFrame->mpGraphics->mhRegion );
             }
 
             if ( bMutex )
@@ -3810,8 +3787,7 @@ static void ImplHandlePaintMsg( HWND hWn
                 if( Application::GetSettings().GetLayoutRTL() )
                     aPEvt.mnBoundX = pFrame->maGeometry.nWidth-aPEvt.mnBoundWidth-aPEvt.mnBoundX;
 
-                pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_PAINT, &aPEvt );
+                pFrame->CallCallback( SALEVENT_PAINT, &aPEvt );
             }
             else
             {
@@ -3823,10 +3799,10 @@ static void ImplHandlePaintMsg( HWND hWn
         else
         {
             // ClipRegion wieder herstellen
-            if ( pFrame->maFrameData.mpGraphics && pFrame->maFrameData.mpGraphics->maGraphicsData.mhRegion )
+            if ( pFrame->mpGraphics && pFrame->mpGraphics->mhRegion )
             {
-                SelectClipRgn( pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC,
-                               pFrame->maFrameData.mpGraphics->maGraphicsData.mhRegion );
+                SelectClipRgn( pFrame->mpGraphics->mhDC,
+                               pFrame->mpGraphics->mhRegion );
             }
         }
     }
@@ -3842,7 +3818,7 @@ static void ImplHandlePaintMsg2( HWND hW
     // Paint
     if ( ImplSalYieldMutexTryToAcquire() )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
         {
             SalPaintEvent aPEvt;
@@ -3855,8 +3831,7 @@ static void ImplHandlePaintMsg2( HWND hW
             if( Application::GetSettings().GetLayoutRTL() )
                 aPEvt.mnBoundX = pFrame->maGeometry.nWidth-aPEvt.mnBoundWidth-aPEvt.mnBoundX;
 
-            pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_PAINT, &aPEvt );
+            pFrame->CallCallback( SALEVENT_PAINT, &aPEvt );
         }
         ImplSalYieldMutexRelease();
         delete pRect;
@@ -3894,6 +3869,14 @@ static void UpdateFrameGeometry( HWND hW
 
     RECT aInnerRect;
     GetClientRect( hWnd, &aInnerRect );
+    if( aInnerRect.right )
+    {
+        // improve right decoration
+        aPt.x=aInnerRect.right;
+        aPt.y=aInnerRect.top;
+        ClientToScreen(hWnd, &aPt);
+        pFrame->maGeometry.nRightDecoration = aRect.right - aPt.x;
+    }
     if( aInnerRect.bottom ) // may be zero if window was not shown yet
         pFrame->maGeometry.nBottomDecoration += aRect.bottom - aPt.y - aInnerRect.bottom;
     else
@@ -3913,13 +3896,12 @@ static void UpdateFrameGeometry( HWND hW
 
 static void ImplCallMoveHdl( HWND hWnd )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    SALEVENT_MOVE, 0 );
+        pFrame->CallCallback( SALEVENT_MOVE, 0 );
         // Um doppelte Paints von VCL und SAL zu vermeiden
-        //if ( IsWindowVisible( hWnd ) && !pFrame->maFrameData.mbInShow )
+        //if ( IsWindowVisible( hWnd ) && !pFrame->mbInShow )
         //    UpdateWindow( hWnd );
     }
 }
@@ -3928,11 +3910,10 @@ static void ImplCallMoveHdl( HWND hWnd )
 
 static void ImplCallClosePopupsHdl( HWND hWnd )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    SALEVENT_CLOSEPOPUPS, 0 );
+        pFrame->CallCallback( SALEVENT_CLOSEPOPUPS, 0 );
     }
 }
 
@@ -3942,22 +3923,22 @@ static void ImplHandleMoveMsg( HWND hWnd
 {
     if ( ImplSalYieldMutexTryToAcquire() )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
         {
             UpdateFrameGeometry( hWnd, pFrame );
 
             if ( GetWindowStyle( hWnd ) & WS_VISIBLE )
-                pFrame->maFrameData.mbDefPos = FALSE;
+                pFrame->mbDefPos = FALSE;
 
             // Gegen moegliche Rekursionen sichern
-            if ( !pFrame->maFrameData.mbInMoveMsg )
+            if ( !pFrame->mbInMoveMsg )
             {
                 // Fenster im FullScreenModus wieder einpassen
-                pFrame->maFrameData.mbInMoveMsg = TRUE;
-                if ( pFrame->maFrameData.mbFullScreen )
+                pFrame->mbInMoveMsg = TRUE;
+                if ( pFrame->mbFullScreen )
                     ImplSalFrameFullScreenPos( pFrame );
-                pFrame->maFrameData.mbInMoveMsg = FALSE;
+                pFrame->mbInMoveMsg = FALSE;
             }
 
             // Status merken
@@ -3983,13 +3964,12 @@ static void ImplCallSizeHdl( HWND hWnd )
     // Solar-Semaphore beruecksichtigt werden
     if ( ImplSalYieldMutexTryToAcquire() )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
         {
-            pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_RESIZE, 0 );
+            pFrame->CallCallback( SALEVENT_RESIZE, 0 );
             // Um doppelte Paints von VCL und SAL zu vermeiden
-            if ( IsWindowVisible( hWnd ) && !pFrame->maFrameData.mbInShow )
+            if ( IsWindowVisible( hWnd ) && !pFrame->mbInShow )
                 UpdateWindow( hWnd );
         }
 
@@ -4005,13 +3985,13 @@ static void ImplHandleSizeMsg( HWND hWnd
 {
     if ( (wParam != SIZE_MAXSHOW) && (wParam != SIZE_MAXHIDE) )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
         {
             UpdateFrameGeometry( hWnd, pFrame );
 
-            pFrame->maFrameData.mnWidth  = (int)LOWORD(lParam);
-            pFrame->maFrameData.mnHeight = (int)HIWORD(lParam);
+            pFrame->mnWidth  = (int)LOWORD(lParam);
+            pFrame->mnHeight = (int)HIWORD(lParam);
             // Status merken
             ImplSaveFrameState( pFrame );
             // Call Hdl
@@ -4026,32 +4006,30 @@ static void ImplHandleFocusMsg( HWND hWn
 {
     if ( ImplSalYieldMutexTryToAcquire() )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
-        if ( pFrame && !SalFrame::mbInReparent )
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
+        if ( pFrame && !WinSalFrame::mbInReparent )
         {
             // Query the actual status
             if ( ::GetFocus() == hWnd )
             {
-                if ( IsWindowVisible( hWnd ) && !pFrame->maFrameData.mbInShow )
+                if ( IsWindowVisible( hWnd ) && !pFrame->mbInShow )
                     UpdateWindow( hWnd );
 
                 // Feststellen, ob wir IME unterstuetzen
-                if ( pFrame->maFrameData.mbIME && pFrame->maFrameData.mhDefIMEContext )
+                if ( pFrame->mbIME && pFrame->mhDefIMEContext )
                 {
                     UINT nImeProps = ImmGetProperty( GetKeyboardLayout( 0 ), IGP_PROPERTY );
 
-                    pFrame->maFrameData.mbSpezIME = (nImeProps & IME_PROP_SPECIAL_UI) != 0;
-                    pFrame->maFrameData.mbAtCursorIME = (nImeProps & IME_PROP_AT_CARET) != 0;
-                    pFrame->maFrameData.mbHandleIME = !pFrame->maFrameData.mbSpezIME;
+                    pFrame->mbSpezIME = (nImeProps & IME_PROP_SPECIAL_UI) != 0;
+                    pFrame->mbAtCursorIME = (nImeProps & IME_PROP_AT_CARET) != 0;
+                    pFrame->mbHandleIME = !pFrame->mbSpezIME;
                 }
 
-                pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_GETFOCUS, 0 );
+                pFrame->CallCallback( SALEVENT_GETFOCUS, 0 );
             }
             else
             {
-                pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_LOSEFOCUS, 0 );
+                pFrame->CallCallback( SALEVENT_LOSEFOCUS, 0 );
             }
         }
 
@@ -4067,11 +4045,10 @@ static void ImplHandleCloseMsg( HWND hWn
 {
     if ( ImplSalYieldMutexTryToAcquire() )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
         {
-            pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_CLOSE, 0 );
+            pFrame->CallCallback( SALEVENT_CLOSE, 0 );
         }
 
         ImplSalYieldMutexRelease();
@@ -4086,11 +4063,10 @@ static long ImplHandleShutDownMsg( HWND 
 {
     ImplSalYieldMutexAcquireWithWait();
     long        nRet = 0;
-    SalFrame*   pFrame = GetWindowPtr( hWnd );
+    WinSalFrame*   pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
-        nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                           SALEVENT_SHUTDOWN, 0 );
+        nRet = pFrame->CallCallback( SALEVENT_SHUTDOWN, 0 );
     }
     ImplSalYieldMutexRelease();
     return nRet;
@@ -4105,10 +4081,8 @@ static void ImplHandleSettingsChangeMsg(
 
     if ( nMsg == WM_DEVMODECHANGE )
         nSalEvent = SALEVENT_PRINTERCHANGED;
-#ifdef WM_DISPLAYCHANGE
     else if ( nMsg == WM_DISPLAYCHANGE )
         nSalEvent = SALEVENT_DISPLAYCHANGED;
-#endif
     else if ( nMsg == WM_FONTCHANGE )
         nSalEvent = SALEVENT_FONTCHANGED;
     else if ( nMsg == WM_TIMECHANGE )
@@ -4130,30 +4104,27 @@ static void ImplHandleSettingsChangeMsg(
         }
     }
 
-#ifdef WM_SETTINGCHANGE
     if ( nMsg == WM_SETTINGCHANGE )
     {
         if ( wParam == SPI_SETWHEELSCROLLLINES )
             aSalShlData.mnWheelScrollLines = ImplSalGetWheelScrollLines();
     }
-#endif
 
     if ( WM_SYSCOLORCHANGE == nMsg && GetSalData()->mhDitherPal )
         ImplUpdateSysColorEntries();
 
     ImplSalYieldMutexAcquireWithWait();
 
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
         if ( (nMsg == WM_DISPLAYCHANGE) || (nMsg == WM_WININICHANGE) )
         {
-            if ( pFrame->maFrameData.mbFullScreen )
+            if ( pFrame->mbFullScreen )
                 ImplSalFrameFullScreenPos( pFrame );
         }
 
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    nSalEvent, 0 );
+        pFrame->CallCallback( nSalEvent, 0 );
     }
 
     ImplSalYieldMutexRelease();
@@ -4164,11 +4135,10 @@ static void ImplHandleSettingsChangeMsg(
 static void ImplHandleUserEvent( HWND hWnd, LPARAM lParam )
 {
     ImplSalYieldMutexAcquireWithWait();
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    SALEVENT_USEREVENT, (void*)lParam );
+        pFrame->CallCallback( SALEVENT_USEREVENT, (void*)lParam );
     }
     ImplSalYieldMutexRelease();
 }
@@ -4187,19 +4157,18 @@ static void ImplHandleForcePalette( HWND
             return;
         }
 
-        SalFrame* pFrame = GetWindowPtr( hWnd );
-        if ( pFrame && pFrame->maFrameData.mpGraphics )
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
+        if ( pFrame && pFrame->mpGraphics )
         {
-            SalGraphics* pGraphics = pFrame->maFrameData.mpGraphics;
-            if ( pGraphics && pGraphics->maGraphicsData.mhDefPal )
+            WinSalGraphics* pGraphics = pFrame->mpGraphics;
+            if ( pGraphics && pGraphics->mhDefPal )
             {
-                SelectPalette( pGraphics->maGraphicsData.mhDC, hPal, FALSE );
-                if ( RealizePalette( pGraphics->maGraphicsData.mhDC ) )
+                SelectPalette( pGraphics->mhDC, hPal, FALSE );
+                if ( RealizePalette( pGraphics->mhDC ) )
                 {
                     InvalidateRect( hWnd, NULL, FALSE );
                     UpdateWindow( hWnd );
-                    pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                SALEVENT_DISPLAYCHANGED, 0 );
+                    pFrame->CallCallback( SALEVENT_DISPLAYCHANGED, 0 );
                 }
             }
         }
@@ -4241,9 +4210,9 @@ static LRESULT ImplHandlePalette( BOOL b
             ImplPostMessage( hWnd, SAL_MSG_POSTPALCHANGED, wParam, lParam );
     }
 
-    SalVirtualDevice*   pTempVD;
-    SalFrame*           pTempFrame;
-    SalGraphics*        pGraphics;
+    WinSalVirtualDevice*pTempVD;
+    WinSalFrame*        pTempFrame;
+    WinSalGraphics*     pGraphics;
     HDC                 hDC;
     HPALETTE            hOldPal;
     UINT                nCols;
@@ -4256,35 +4225,35 @@ static LRESULT ImplHandlePalette( BOOL b
     pTempVD = pSalData->mpFirstVD;
     while ( pTempVD )
     {
-        pGraphics = pTempVD->maVirDevData.mpGraphics;
-        if ( pGraphics->maGraphicsData.mhDefPal )
+        pGraphics = pTempVD->mpGraphics;
+        if ( pGraphics->mhDefPal )
         {
-            SelectPalette( pGraphics->maGraphicsData.mhDC,
-                           pGraphics->maGraphicsData.mhDefPal,
+            SelectPalette( pGraphics->mhDC,
+                           pGraphics->mhDefPal,
                            TRUE );
         }
-        pTempVD = pTempVD->maVirDevData.mpNext;
+        pTempVD = pTempVD->mpNext;
     }
     pTempFrame = pSalData->mpFirstFrame;
     while ( pTempFrame )
     {
-        pGraphics = pTempFrame->maFrameData.mpGraphics;
-        if ( pGraphics && pGraphics->maGraphicsData.mhDefPal )
+        pGraphics = pTempFrame->mpGraphics;
+        if ( pGraphics && pGraphics->mhDefPal )
         {
-            SelectPalette( pGraphics->maGraphicsData.mhDC,
-                           pGraphics->maGraphicsData.mhDefPal,
+            SelectPalette( pGraphics->mhDC,
+                           pGraphics->mhDefPal,
                            TRUE );
         }
-        pTempFrame = pTempFrame->maFrameData.mpNextFrame;
+        pTempFrame = pTempFrame->mpNextFrame;
     }
 
     // Palette neu realizen
-    SalFrame* pFrame = NULL;
+    WinSalFrame* pFrame = NULL;
     if ( bFrame )
         pFrame = GetWindowPtr( hWnd );
-    if ( pFrame && pFrame->maFrameData.mpGraphics )
+    if ( pFrame && pFrame->mpGraphics )
     {
-        hDC = pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC;
+        hDC = pFrame->mpGraphics->mhDC;
         bStdDC = TRUE;
     }
     else
@@ -4306,28 +4275,28 @@ static LRESULT ImplHandlePalette( BOOL b
     pTempVD = pSalData->mpFirstVD;
     while ( pTempVD )
     {
-        pGraphics = pTempVD->maVirDevData.mpGraphics;
-        if ( pGraphics->maGraphicsData.mhDefPal )
+        pGraphics = pTempVD->mpGraphics;
+        if ( pGraphics->mhDefPal )
         {
-            SelectPalette( pGraphics->maGraphicsData.mhDC, hPal, TRUE );
-            RealizePalette( pGraphics->maGraphicsData.mhDC );
+            SelectPalette( pGraphics->mhDC, hPal, TRUE );
+            RealizePalette( pGraphics->mhDC );
         }
-        pTempVD = pTempVD->maVirDevData.mpNext;
+        pTempVD = pTempVD->mpNext;
     }
     pTempFrame = pSalData->mpFirstFrame;
     while ( pTempFrame )
     {
         if ( pTempFrame != pFrame )
         {
-            pGraphics = pTempFrame->maFrameData.mpGraphics;
-            if ( pGraphics && pGraphics->maGraphicsData.mhDefPal )
+            pGraphics = pTempFrame->mpGraphics;
+            if ( pGraphics && pGraphics->mhDefPal )
             {
-                SelectPalette( pGraphics->maGraphicsData.mhDC, hPal, TRUE );
-                if ( RealizePalette( pGraphics->maGraphicsData.mhDC ) )
+                SelectPalette( pGraphics->mhDC, hPal, TRUE );
+                if ( RealizePalette( pGraphics->mhDC ) )
                     bUpdate = TRUE;
             }
         }
-        pTempFrame = pTempFrame->maFrameData.mpNextFrame;
+        pTempFrame = pTempFrame->mpNextFrame;
     }
 
     // Wenn sich Farben geaendert haben, dann die Fenster updaten
@@ -4336,15 +4305,14 @@ static LRESULT ImplHandlePalette( BOOL b
         pTempFrame = pSalData->mpFirstFrame;
         while ( pTempFrame )
         {
-            pGraphics = pTempFrame->maFrameData.mpGraphics;
-            if ( pGraphics && pGraphics->maGraphicsData.mhDefPal )
+            pGraphics = pTempFrame->mpGraphics;
+            if ( pGraphics && pGraphics->mhDefPal )
             {
-                InvalidateRect( pTempFrame->maFrameData.mhWnd, NULL, FALSE );
-                UpdateWindow( pTempFrame->maFrameData.mhWnd );
-                pTempFrame->maFrameData.mpProc( pTempFrame->maFrameData.mpInst, pTempFrame,
-                                                SALEVENT_DISPLAYCHANGED, 0 );
+                InvalidateRect( pTempFrame->mhWnd, NULL, FALSE );
+                UpdateWindow( pTempFrame->mhWnd );
+                pTempFrame->CallCallback( SALEVENT_DISPLAYCHANGED, 0 );
             }
-            pTempFrame = pTempFrame->maFrameData.mpNextFrame;
+            pTempFrame = pTempFrame->mpNextFrame;
         }
     }
 
@@ -4367,12 +4335,12 @@ static int ImplHandleMinMax( HWND hWnd, 
 
     if ( ImplSalYieldMutexTryToAcquire() )
     {
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
         {
             MINMAXINFO* pMinMax = (MINMAXINFO*)lParam;
 
-            if ( pFrame->maFrameData.mbFullScreen )
+            if ( pFrame->mbFullScreen )
             {
                 int         nX;
                 int         nY;
@@ -4400,10 +4368,10 @@ static int ImplHandleMinMax( HWND hWnd, 
                 bRet = TRUE;
             }
 
-            if ( pFrame->maFrameData.mnMinWidth || pFrame->maFrameData.mnMinHeight )
+            if ( pFrame->mnMinWidth || pFrame->mnMinHeight )
             {
-                int nMinWidth   = pFrame->maFrameData.mnMinWidth;
-                int nMinHeight  = pFrame->maFrameData.mnMinHeight;
+                int nMinWidth   = pFrame->mnMinWidth;
+                int nMinHeight  = pFrame->mnMinHeight;
                 int nLeft;
                 int nTop;
                 int nRight;
@@ -4426,18 +4394,444 @@ static int ImplHandleMinMax( HWND hWnd, 
 
 // -----------------------------------------------------------------------
 
+// retrieves the SalMenuItem pointer from a hMenu
+// the pointer is stored in every item, so if no position
+// is specified we just use the first item (ie, pos=0)
+// if bByPosition is FALSE then nPos denotes a menu id instead of a position
+static WinSalMenuItem* ImplGetSalMenuItem( HMENU hMenu, UINT nPos, BOOL bByPosition=TRUE )
+{
+    DWORD err=0;
+
+    MENUITEMINFOW mi;
+    memset(&mi, 0, sizeof(mi));
+    mi.cbSize = sizeof( mi );
+    mi.fMask = MIIM_DATA;
+    if( !GetMenuItemInfoW( hMenu, nPos, bByPosition, &mi) )
+        err = GetLastError();
+
+    return (WinSalMenuItem *) mi.dwItemData;
+}
+
+// returns the index of the currently selected item if any or -1
+static int ImplGetSelectedIndex( HMENU hMenu )
+{
+    DWORD err=0;
+
+    MENUITEMINFOW mi;
+    memset(&mi, 0, sizeof(mi));
+    mi.cbSize = sizeof( mi );
+    mi.fMask = MIIM_STATE;
+    int n = GetMenuItemCount( hMenu );
+    if( n != -1 )
+    {
+        for(int i=0; i<n; i++ )
+        {
+            if( !GetMenuItemInfoW( hMenu, i, TRUE, &mi) )
+                err = GetLastError();
+            else
+            {
+                if( mi.fState & MFS_HILITE )
+                    return i;
+            }
+        }
+    }
+    return -1;
+}
+
+static int ImplMenuChar( HWND hWnd, WPARAM wParam, LPARAM lParam )
+{
+    int nRet = MNC_IGNORE;
+    HMENU hMenu = (HMENU) lParam;
+    String aMnemonic;
+    aMnemonic.AssignAscii("&");
+    aMnemonic.Append( (sal_Unicode) LOWORD(wParam) );
+    aMnemonic.ToLowerAscii();   // we only have ascii mnemonics
+
+    // search the mnemonic in the current menu
+    int nItemCount = GetMenuItemCount( hMenu );
+    int nFound = 0;
+    int idxFound = -1;
+    int idxSelected = ImplGetSelectedIndex( hMenu );
+    int idx = idxSelected != -1 ? idxSelected+1 : 0;    // if duplicate mnemonics cycle through menu
+    for( int i=0; i< nItemCount; i++, idx++ )
+    {
+        WinSalMenuItem* pSalMenuItem = ImplGetSalMenuItem( hMenu, idx % nItemCount );
+        if( !pSalMenuItem )
+            continue;
+        String aStr = pSalMenuItem->mText;
+        aStr.ToLowerAscii();
+        if( aStr.Search( aMnemonic ) != STRING_NOTFOUND)
+        {
+            if( idxFound == -1 )
+                idxFound = idx % nItemCount;
+            if( nFound++ )
+                break;  // duplicate found
+        }
+    }
+    if( nFound == 1 )
+        nRet = MAKELRESULT( idxFound, MNC_EXECUTE );
+    else
+        // duplicate mnemonics, just select the next occurence
+        nRet = MAKELRESULT( idxFound, MNC_SELECT );
+
+    return nRet;
+}
+
+static int ImplMeasureItem( HWND hWnd, WPARAM wParam, LPARAM lParam )
+{
+    int nRet = 0;
+    if( !wParam )
+    {
+        // request was sent by a menu
+        nRet = 1;
+        MEASUREITEMSTRUCT *pMI = (LPMEASUREITEMSTRUCT) lParam;
+        if( pMI->CtlType != ODT_MENU )
+            return 0;
+
+        WinSalMenuItem *pSalMenuItem = (WinSalMenuItem *) pMI->itemData;
+        if( !pSalMenuItem )
+            return 0;
+
+        HDC hdc = GetDC( hWnd );
+        SIZE strSize;
+
+        NONCLIENTMETRICS ncm;
+        memset( &ncm, 0, sizeof(ncm) );
+        ncm.cbSize = sizeof( ncm );
+        SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, (PVOID) &ncm, 0 );
+
+        // Assume every menu item can be default and printed bold
+        //ncm.lfMenuFont.lfWeight = FW_BOLD;
+
+        HFONT hfntOld = (HFONT) SelectObject(hdc, (HFONT) CreateFontIndirect( &ncm.lfMenuFont ));
+
+        // menu text and accelerator
+        String aStr(pSalMenuItem->mText.GetBuffer() );
+        if( pSalMenuItem->mAccelText.Len() )
+        {
+            aStr.AppendAscii(" ");
+            aStr.Append( pSalMenuItem->mAccelText );
+        }
+        GetTextExtentPoint32W( hdc, (LPWSTR) aStr.GetBuffer(),
+                                aStr.Len(), &strSize );
+
+        // image
+        Size bmpSize( 16, 16 );
+        //if( !!pSalMenuItem->maBitmap )
+        //    bmpSize = pSalMenuItem->maBitmap.GetSizePixel();
+
+        // checkmark
+        Size checkSize( GetSystemMetrics( SM_CXMENUCHECK ), GetSystemMetrics( SM_CYMENUCHECK ) );
+
+        pMI->itemWidth = checkSize.Width() + 3 + bmpSize.Width() + 3 + strSize.cx;
+        pMI->itemHeight = max( max( checkSize.Height(), bmpSize.Height() ), strSize.cy );
+        pMI->itemHeight += 4;
+
+        DeleteObject( SelectObject(hdc, hfntOld) );
+        ReleaseDC( hWnd, hdc );
+    }
+
+    return nRet;
+}
+
+static int ImplDrawItem(HWND hWnd, WPARAM wParam, LPARAM lParam )
+{
+    int nRet = 0;
+    DWORD err = 0;
+    if( !wParam )
+    {
+        // request was sent by a menu
+        nRet = 1;
+        DRAWITEMSTRUCT *pDI = (LPDRAWITEMSTRUCT) lParam;
+        if( pDI->CtlType != ODT_MENU )
+            return 0;
+
+        WinSalMenuItem *pSalMenuItem = (WinSalMenuItem *) pDI->itemData;
+        if( !pSalMenuItem )
+            return 0;
+
+        COLORREF clrPrevText, clrPrevBkgnd;
+        HFONT hfntOld;
+        HBRUSH hbrOld;
+        BOOL	fChecked = pDI->itemState & ODS_CHECKED;
+        BOOL	fSelected = pDI->itemState & ODS_SELECTED;
+        BOOL	fDisabled = pDI->itemState & (ODS_DISABLED | ODS_GRAYED);
+
+        // Set the appropriate foreground and background colors.
+        RECT aRect = pDI->rcItem;
+
+        clrPrevBkgnd = SetBkColor( pDI->hDC, GetSysColor( COLOR_MENU ) );
+
+        if ( fDisabled )
+            clrPrevText = SetTextColor( pDI->hDC, GetSysColor( COLOR_GRAYTEXT ) );
+        else
+            clrPrevText = SetTextColor( pDI->hDC, GetSysColor( fSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT ) );
+
+        DWORD colBackground = GetSysColor( fSelected ? COLOR_HIGHLIGHT : COLOR_MENU );
+        if ( fSelected )
+	        clrPrevBkgnd = SetBkColor( pDI->hDC, colBackground );
+        else
+	        clrPrevBkgnd = SetBkColor( pDI->hDC, colBackground );
+
+        hbrOld = (HBRUSH)SelectObject( pDI->hDC, CreateSolidBrush( GetBkColor( pDI->hDC ) ) );
+
+        // Fill background
+        if(!PatBlt( pDI->hDC, aRect.left, aRect.top, aRect.right-aRect.left, aRect.bottom-aRect.top, PATCOPY ))
+            err = GetLastError();
+
+        int lineHeight = aRect.bottom-aRect.top;
+
+        int x = aRect.left;
+        int y = aRect.top;
+
+        int checkWidth  = GetSystemMetrics( SM_CXMENUCHECK );
+        int checkHeight = GetSystemMetrics( SM_CYMENUCHECK );
+        if( fChecked )
+        {
+            RECT r;
+            r.left = 0;
+            r.top = 0;
+            r.right = checkWidth;
+            r.bottom = checkWidth;
+            HDC memDC = CreateCompatibleDC( pDI->hDC );
+            HBITMAP memBmp = CreateCompatibleBitmap( pDI->hDC, checkWidth, checkHeight );
+            HBITMAP hOldBmp = (HBITMAP) SelectObject( memDC, memBmp );
+            DrawFrameControl( memDC, &r, DFC_MENU, DFCS_MENUCHECK );
+            BitBlt( pDI->hDC, x, y+(lineHeight-checkHeight)/2, checkWidth, checkHeight, memDC, 0, 0, SRCAND );
+            DeleteObject( SelectObject( memDC, hOldBmp ) );
+            DeleteDC( memDC );
+        }
+        x += checkWidth+3;
+
+        //Size bmpSize = aBitmap.GetSizePixel();
+        Size bmpSize(16, 16);
+        if( !!pSalMenuItem->maBitmap )
+        {
+            Bitmap aBitmap( pSalMenuItem->maBitmap );
+
+            // set transparent pixels to background color
+            if( fDisabled )
+                colBackground = RGB(255,255,255);
+            aBitmap.Replace( Color( COL_LIGHTMAGENTA ), 
+                Color( GetRValue(colBackground),GetGValue(colBackground),GetBValue(colBackground) ), 0);
+
+            WinSalBitmap* pSalBmp = static_cast<WinSalBitmap*>(aBitmap.ImplGetImpBitmap()->ImplGetSalBitmap());
+			HGLOBAL hDrawDIB = pSalBmp->ImplGethDIB();
+
+            if( hDrawDIB )
+            {
+                PBITMAPINFO 		pBI = (PBITMAPINFO) GlobalLock( hDrawDIB );
+			    PBITMAPINFOHEADER	pBIH = (PBITMAPINFOHEADER) pBI;
+			    PBYTE				pBits = (PBYTE) pBI + *(DWORD*) pBI +
+										    pSalBmp->ImplGetDIBColorCount( hDrawDIB ) * sizeof( RGBQUAD );
+
+                HBITMAP hBmp = CreateDIBitmap( pDI->hDC, pBIH, CBM_INIT, pBits, pBI, DIB_RGB_COLORS );
+			    GlobalUnlock( hDrawDIB );
+
+                HBRUSH hbrIcon = CreateSolidBrush( GetSysColor( COLOR_GRAYTEXT ) );
+                DrawStateW( pDI->hDC, (HBRUSH)hbrIcon, (DRAWSTATEPROC)NULL, (LPARAM)hBmp, (WPARAM)0, 
+                    x, y+(lineHeight-bmpSize.Height())/2, bmpSize.Width(), bmpSize.Height(), 
+                     DST_BITMAP | (fDisabled ? (fSelected ? DSS_MONO : DSS_DISABLED) : DSS_NORMAL) );
+
+                DeleteObject( hbrIcon );
+                DeleteObject( hBmp );
+            }
+
+        }
+        x += bmpSize.Width() + 3;
+        aRect.left = x;
+
+        NONCLIENTMETRICS ncm;
+        memset( &ncm, 0, sizeof(ncm) );
+        ncm.cbSize = sizeof( ncm );
+        SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, (PVOID) &ncm, 0 );
+
+        // Print default menu entry with bold font
+        //if ( pDI->itemState & ODS_DEFAULT )
+	    //    ncm.lfMenuFont.lfWeight = FW_BOLD;
+
+        hfntOld = (HFONT) SelectObject(pDI->hDC, (HFONT) CreateFontIndirect( &ncm.lfMenuFont ));
+
+        SIZE strSize;
+        String aStr( pSalMenuItem->mText.GetBuffer() );
+        GetTextExtentPoint32W( pDI->hDC, (LPWSTR) aStr.GetBuffer(),
+                                aStr.Len(), &strSize );
+
+        if(!DrawStateW( pDI->hDC, (HBRUSH)NULL, (DRAWSTATEPROC)NULL,
+            (LPARAM)(LPWSTR) aStr.GetBuffer(), 
+            (WPARAM)0, aRect.left, aRect.top + (lineHeight - strSize.cy)/2, 0, 0,
+            DST_PREFIXTEXT | (fDisabled && !fSelected ? DSS_DISABLED : DSS_NORMAL) ) )
+            err = GetLastError();
+
+        if( pSalMenuItem->mAccelText.Len() )
+        {
+            SIZE strSizeA;
+            aStr = pSalMenuItem->mAccelText;
+            GetTextExtentPoint32W( pDI->hDC, (LPWSTR) aStr.GetBuffer(),
+                                    aStr.Len(), &strSizeA );
+            TEXTMETRIC tm;
+            GetTextMetrics( pDI->hDC, &tm );
+
+            // position the accelerator string to the right but leave space for the 
+            // (potential) submenu arrow (tm.tmMaxCharWidth)
+            if(!DrawStateW( pDI->hDC, (HBRUSH)NULL, (DRAWSTATEPROC)NULL,
+                (LPARAM)(LPWSTR) aStr.GetBuffer(), 
+                (WPARAM)0, aRect.right-strSizeA.cx-tm.tmMaxCharWidth, aRect.top + (lineHeight - strSizeA.cy)/2, 0, 0,
+                DST_TEXT | (fDisabled && !fSelected ? DSS_DISABLED : DSS_NORMAL) ) )
+                err = GetLastError();
+        }
+
+        // Restore the original font and colors.
+        DeleteObject( SelectObject( pDI->hDC, hbrOld ) );
+        DeleteObject( SelectObject( pDI->hDC, hfntOld) );
+        SetTextColor(pDI->hDC, clrPrevText);
+        SetBkColor(pDI->hDC, clrPrevBkgnd);
+    }
+    return nRet;
+}
+
+static int ImplHandleMenuActivate( HWND hWnd, WPARAM wParam, LPARAM lParam )
+{
+    // Menu activation
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
+    if ( !pFrame )
+        return 0;
+
+    HMENU hMenu = (HMENU) wParam;
+    WORD nPos = LOWORD (lParam);
+    BOOL bWindowMenu = (BOOL) HIWORD(lParam);
+
+    // Send activate and deactivate together, so we have not keep track of opened menues
+    // this will be enough to have the menues updated correctly
+    SalMenuEvent aMenuEvt;
+    WinSalMenuItem *pSalMenuItem = ImplGetSalMenuItem( hMenu, 0 );
+    if( pSalMenuItem )
+        aMenuEvt.mpMenu = pSalMenuItem->mpMenu;
+    else
+        aMenuEvt.mpMenu = NULL;
+
+    long nRet = pFrame->CallCallback( SALEVENT_MENUACTIVATE, &aMenuEvt );
+    if( nRet )
+        nRet = pFrame->CallCallback( SALEVENT_MENUDEACTIVATE, &aMenuEvt );
+    if( nRet )
+        pFrame->mLastActivatedhMenu = hMenu;
+
+    return (nRet!=0);
+}
+
+static int ImplHandleMenuSelect( HWND hWnd, WPARAM wParam, LPARAM lParam )
+{
+    // Menu selection
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
+    if ( !pFrame )
+        return 0;
+
+    WORD nId = LOWORD(wParam);      // menu item or submenu index
+    WORD nFlags = HIWORD(wParam);
+    HMENU hMenu = (HMENU) lParam;
+    BOOL bByPosition = FALSE;
+    if( nFlags & MF_POPUP )
+        bByPosition = TRUE;
+
+    long nRet = 0;
+    if ( hMenu && !pFrame->mLastActivatedhMenu )
+    {
+        // we never activated a menu (ie, no WM_INITMENUPOPUP has occured yet) 
+        // which means this must be the menubar -> send activation/deactivation
+        SalMenuEvent aMenuEvt;
+        WinSalMenuItem *pSalMenuItem = ImplGetSalMenuItem( hMenu, nId, bByPosition );
+        if( pSalMenuItem )
+            aMenuEvt.mpMenu = pSalMenuItem->mpMenu;
+        else
+            aMenuEvt.mpMenu = NULL;
+
+        nRet = pFrame->CallCallback( SALEVENT_MENUACTIVATE, &aMenuEvt );
+        if( nRet )
+            nRet = pFrame->CallCallback( SALEVENT_MENUDEACTIVATE, &aMenuEvt );
+        if( nRet )
+            pFrame->mLastActivatedhMenu = hMenu;
+    }
+
+    if( !hMenu && nFlags == 0xFFFF )
+    {
+        // all menus are closed, reset activation logic
+        pFrame->mLastActivatedhMenu = NULL;
+    }
+
+    if( hMenu )
+    {
+        // hMenu must be saved, as it is not passed in WM_COMMAND which always occurs after a selection
+        // if a menu is closed due to a command selection then hMenu is NULL, but WM_COMMAND comes later
+        // so we must not overwrite it in this case
+        pFrame->mSelectedhMenu = hMenu; 
+
+        // send highlight event
+        if( nFlags & MF_POPUP )
+        {
+            // submenu selected
+            // wParam now carries an index instead of an id -> retrieve id
+            MENUITEMINFOW mi;
+            memset(&mi, 0, sizeof(mi));
+            mi.cbSize = sizeof( mi );
+            mi.fMask = MIIM_ID;
+            if( GetMenuItemInfoW( hMenu, LOWORD(wParam), TRUE, &mi) )
+                nId = mi.wID;
+        }
+
+        SalMenuEvent aMenuEvt;
+        aMenuEvt.mnId   = nId;
+        WinSalMenuItem *pSalMenuItem = ImplGetSalMenuItem( hMenu, nId, FALSE );
+        if( pSalMenuItem )
+            aMenuEvt.mpMenu = pSalMenuItem->mpMenu;
+        else
+            aMenuEvt.mpMenu = NULL;
+
+        nRet = pFrame->CallCallback( SALEVENT_MENUHIGHLIGHT, &aMenuEvt );
+    }
+
+    return (nRet != 0);
+}
+
+static int ImplHandleCommand( HWND hWnd, WPARAM wParam, LPARAM lParam )
+{
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
+    if ( !pFrame )
+        return 0;
+
+    DWORD err=0;
+    long nRet = 0;
+    if( !HIWORD(wParam) )
+    {
+        // Menu command
+        WORD nId = LOWORD(wParam);
+        if( nId )   // zero for separators
+        {
+            SalMenuEvent aMenuEvt;
+            aMenuEvt.mnId   = nId;
+            WinSalMenuItem *pSalMenuItem = ImplGetSalMenuItem( pFrame->mSelectedhMenu, nId, FALSE );
+            if( pSalMenuItem )
+                aMenuEvt.mpMenu = pSalMenuItem->mpMenu;
+            else
+                aMenuEvt.mpMenu = NULL;
+
+            nRet = pFrame->CallCallback( SALEVENT_MENUCOMMAND, &aMenuEvt );
+        }
+    }
+    return (nRet != 0);
+}
+
 static int ImplHandleSysCommand( HWND hWnd, WPARAM wParam, LPARAM lParam )
 {
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( !pFrame )
         return 0;
 
     WPARAM nCommand = wParam & 0xFFF0;
 
-    if ( pFrame->maFrameData.mbFullScreen )
+    if ( pFrame->mbFullScreen )
     {
-        WIN_BOOL    bMaximize = IsZoomed( pFrame->maFrameData.mhWnd );
-        WIN_BOOL    bMinimize = IsIconic( pFrame->maFrameData.mhWnd );
+        WIN_BOOL    bMaximize = IsZoomed( pFrame->mhWnd );
+        WIN_BOOL    bMinimize = IsIconic( pFrame->mhWnd );
         if ( (nCommand == SC_SIZE) ||
              (!bMinimize && (nCommand == SC_MOVE)) ||
              (!bMaximize && (nCommand == SC_MAXIMIZE)) ||
@@ -4450,6 +4844,11 @@ static int ImplHandleSysCommand( HWND hW
 
     if ( nCommand == SC_KEYMENU )
     {
+        // do not process SC_KEYMENU if we have a native menu
+        // Windows should handle this
+        if( GetMenu( hWnd ) )
+            return FALSE;   
+
         // Hier verarbeiten wir nur KeyMenu-Events fuer Alt um
         // den MenuBar zu aktivieren, oder wenn ein SysChild-Fenster
         // den Focus hat, da diese Alt+Tasten-Kombinationen nur
@@ -4477,10 +4876,8 @@ static int ImplHandleSysCommand( HWND hW
             aKeyEvt.mnCode      = KEY_MENU;
             aKeyEvt.mnCharCode  = 0;
             aKeyEvt.mnRepeat    = 0;
-            long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                    SALEVENT_KEYINPUT, &aKeyEvt );
-            pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_KEYUP, &aKeyEvt );
+            long nRet = pFrame->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+            pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
             return (nRet != 0);
         }
         else
@@ -4516,10 +4913,8 @@ static int ImplHandleSysCommand( HWND hW
                     aKeyEvt.mnCode     |= nModCode;
                     aKeyEvt.mnCharCode  = cKeyCode;
                     aKeyEvt.mnRepeat    = 0;
-                    long nRet = pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                            SALEVENT_KEYINPUT, &aKeyEvt );
-                    pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                SALEVENT_KEYUP, &aKeyEvt );
+                    long nRet = pFrame->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+                    pFrame->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
                     return (nRet != 0);
                 }
             }
@@ -4536,24 +4931,27 @@ static void ImplHandleInputLangChange( H
     ImplSalYieldMutexAcquireWithWait();
 
     // Feststellen, ob wir IME unterstuetzen
-    SalFrame* pFrame = GetWindowPtr( hWnd );
-    if ( pFrame && pFrame->maFrameData.mbIME && pFrame->maFrameData.mhDefIMEContext )
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
+    if ( pFrame && pFrame->mbIME && pFrame->mhDefIMEContext )
     {
-        HWND    hWnd = pFrame->maFrameData.mhWnd;
+        HWND    hWnd = pFrame->mhWnd;
         HKL     hKL = (HKL)lParam;
         UINT    nImeProps = ImmGetProperty( hKL, IGP_PROPERTY );
 
-        pFrame->maFrameData.mbSpezIME = (nImeProps & IME_PROP_SPECIAL_UI) != 0;
-        pFrame->maFrameData.mbAtCursorIME = (nImeProps & IME_PROP_AT_CARET) != 0;
-        pFrame->maFrameData.mbHandleIME = !pFrame->maFrameData.mbSpezIME;
+        pFrame->mbSpezIME = (nImeProps & IME_PROP_SPECIAL_UI) != 0;
+        pFrame->mbAtCursorIME = (nImeProps & IME_PROP_AT_CARET) != 0;
+        pFrame->mbHandleIME = !pFrame->mbSpezIME;
     }
 
+    // trigger input language and codepage update
+    ImplUpdateInputLang( pFrame );
+
     ImplSalYieldMutexRelease();
 }
 
 // -----------------------------------------------------------------------
 
-static void ImplUpdateIMECursorPos( SalFrame* pFrame, HIMC hIMC )
+static void ImplUpdateIMECursorPos( WinSalFrame* pFrame, HIMC hIMC )
 {
     COMPOSITIONFORM aForm;
     memset( &aForm, 0, sizeof( aForm ) );
@@ -4561,8 +4959,7 @@ static void ImplUpdateIMECursorPos( SalF
     // Cursor-Position ermitteln und aus der die Default-Position fuer
     // das Composition-Fenster berechnen
     SalExtTextInputPosEvent aPosEvt;
-    pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvt );
+    pFrame->CallCallback( SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvt );
     if ( (aPosEvt.mnX == -1) && (aPosEvt.mnY == -1) )
         aForm.dwStyle |= CFS_DEFAULT;
     else
@@ -4575,9 +4972,9 @@ static void ImplUpdateIMECursorPos( SalF
 
     // Because not all IME's use this values, we create
     // a Windows caret to force the Position from the IME
-    if ( GetFocus() == pFrame->maFrameData.mhWnd )
+    if ( GetFocus() == pFrame->mhWnd )
     {
-        CreateCaret( pFrame->maFrameData.mhWnd, 0,
+        CreateCaret( pFrame->mhWnd, 0,
                      aPosEvt.mnWidth, aPosEvt.mnHeight );
         SetCaretPos( aPosEvt.mnX, aPosEvt.mnY );
     }
@@ -4591,7 +4988,7 @@ static BOOL ImplHandleIMEStartCompositio
 
     ImplSalYieldMutexAcquireWithWait();
 
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame )
     {
         HIMC hIMC = ImmGetContext( hWnd );
@@ -4601,9 +4998,9 @@ static BOOL ImplHandleIMEStartCompositio
             ImmReleaseContext( hWnd, hIMC );
         }
 
-        if ( pFrame->maFrameData.mbHandleIME )
+        if ( pFrame->mbHandleIME )
         {
-            if ( pFrame->maFrameData.mbAtCursorIME )
+            if ( pFrame->mbAtCursorIME )
                 bDef = FALSE;
         }
     }
@@ -4615,7 +5012,7 @@ static BOOL ImplHandleIMEStartCompositio
 
 // -----------------------------------------------------------------------
 
-static BOOL ImplHandleIMECompositionInput( SalFrame* pFrame,
+static BOOL ImplHandleIMECompositionInput( WinSalFrame* pFrame,
                                            HIMC hIMC, LPARAM lParam )
 {
     BOOL bDef = TRUE;
@@ -4644,15 +5041,13 @@ static BOOL ImplHandleIMECompositionInpu
         }
 
         aEvt.mnCursorPos = aEvt.maText.Len();
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
-        pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                    SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+        pFrame->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
+        pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
         ImplUpdateIMECursorPos( pFrame, hIMC );
     }
 
     // If the IME doesn't support OnSpot input, then there is nothing to do
-    if ( !pFrame->maFrameData.mbAtCursorIME )
+    if ( !pFrame->mbAtCursorIME )
         return !bDef;
 
     // If we get new Composition data, then we handle this new input
@@ -4712,12 +5107,10 @@ static BOOL ImplHandleIMECompositionInpu
         if ( (nTextLen > 0) || !(lParam & GCS_RESULTSTR) )
         {
             // End the mode, if the last character is deleted
-            if ( !nTextLen && !pFrame->maFrameData.mbCandidateMode )
+            if ( !nTextLen && !pFrame->mbCandidateMode )
             {
-                pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
-                pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+                pFrame->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
+                pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
             }
             else
             {
@@ -4732,13 +5125,12 @@ static BOOL ImplHandleIMECompositionInpu
                 else
                     aEvt.mnCursorPos = LOWORD( ImmGetCompositionStringW( hIMC, GCS_CURSORPOS, 0, 0 ) );
 
-                if ( pFrame->maFrameData.mbCandidateMode )
+                if ( pFrame->mbCandidateMode )
                     aEvt.mnCursorFlags |= SAL_EXTTEXTINPUT_CURSOR_INVISIBLE;
                 if ( lParam & CS_NOMOVECARET )
                     aEvt.mnCursorFlags |= SAL_EXTTEXTINPUT_CURSOR_OVERWRITE;
 
-                pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                            SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
+                pFrame->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
             }
             ImplUpdateIMECursorPos( pFrame, hIMC );
         }
@@ -4757,17 +5149,17 @@ static BOOL ImplHandleIMEComposition( HW
     BOOL bDef = TRUE;
     ImplSalYieldMutexAcquireWithWait();
 
-    SalFrame* pFrame = GetWindowPtr( hWnd );
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
     if ( pFrame && (!lParam || (lParam & GCS_RESULTSTR)) )
     {
         // Wir restaurieren den Background-Modus bei jeder Texteingabe,
         // da einige Tools wie RichWin uns diesen hin- und wieder umsetzen
-        if ( pFrame->maFrameData.mpGraphics &&
-             pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC )
-            SetBkMode( pFrame->maFrameData.mpGraphics->maGraphicsData.mhDC, TRANSPARENT );
+        if ( pFrame->mpGraphics &&
+             pFrame->mpGraphics->mhDC )
+            SetBkMode( pFrame->mpGraphics->mhDC, TRANSPARENT );
     }
 
-    if ( pFrame && pFrame->maFrameData.mbHandleIME )
+    if ( pFrame && pFrame->mbHandleIME )
     {
         if ( !lParam )
         {
@@ -4778,10 +5170,8 @@ static BOOL ImplHandleIMEComposition( HW
             aEvt.mnDeltaStart       = 0;
             aEvt.mbOnlyCursor       = FALSE;
             aEvt.mnCursorFlags      = 0;
-            pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
-            pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                        SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+            pFrame->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aEvt );
+            pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
         }
         else if ( lParam & (GCS_RESULTSTR | GCS_COMPSTR | GCS_COMPATTR | GCS_CURSORPOS) )
         {
@@ -4808,10 +5198,10 @@ static BOOL ImplHandleIMEEndComposition(
 
     ImplSalYieldMutexAcquireWithWait();
 
-    SalFrame* pFrame = GetWindowPtr( hWnd );
-    if ( pFrame && pFrame->maFrameData.mbHandleIME )
+    WinSalFrame* pFrame = GetWindowPtr( hWnd );
+    if ( pFrame && pFrame->mbHandleIME )
     {
-        if ( pFrame->maFrameData.mbAtCursorIME )
+        if ( pFrame->mbAtCursorIME )
             bDef = FALSE;
     }
 
@@ -4828,15 +5218,15 @@ static void ImplHandleIMENotify( HWND hW
     {
         ImplSalYieldMutexAcquireWithWait();
 
-        SalFrame* pFrame = GetWindowPtr( hWnd );
-        if ( pFrame && pFrame->maFrameData.mbHandleIME &&
-             pFrame->maFrameData.mbAtCursorIME )
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
+        if ( pFrame && pFrame->mbHandleIME &&
+             pFrame->mbAtCursorIME )
         {
             // Wir wollen den Cursor hiden
-            pFrame->maFrameData.mbCandidateMode = TRUE;
+            pFrame->mbCandidateMode = TRUE;
             ImplHandleIMEComposition( hWnd, GCS_CURSORPOS );
 
-            HWND hWnd = pFrame->maFrameData.mhWnd;
+            HWND hWnd = pFrame->mhWnd;
             HIMC hIMC = ImmGetContext( hWnd );
             if ( hIMC )
             {
@@ -4844,8 +5234,7 @@ static void ImplHandleIMENotify( HWND hW
                 if ( nBufLen >= 1 )
                 {
                     SalExtTextInputPosEvent aPosEvt;
-                    pFrame->maFrameData.mpProc( pFrame->maFrameData.mpInst, pFrame,
-                                                SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvt );
+                    pFrame->CallCallback( SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvt );
 
                     // Vertical !!!
                     CANDIDATEFORM aForm;
@@ -4869,9 +5258,9 @@ static void ImplHandleIMENotify( HWND hW
     else if ( wParam == (WPARAM)IMN_CLOSECANDIDATE )
     {
         ImplSalYieldMutexAcquireWithWait();
-        SalFrame* pFrame = GetWindowPtr( hWnd );
+        WinSalFrame* pFrame = GetWindowPtr( hWnd );
         if ( pFrame )
-            pFrame->maFrameData.mbCandidateMode = FALSE;
+            pFrame->mbCandidateMode = FALSE;
         ImplSalYieldMutexRelease();
     }
 }
@@ -4937,15 +5326,15 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
         // Can also be used for the W-Version, because the struct
         // to access lpCreateParams is the same structure
         CREATESTRUCTA* pStruct = (CREATESTRUCTA*)lParam;
-        SalFrame* pFrame = (SalFrame*)pStruct->lpCreateParams;
+        WinSalFrame* pFrame = (WinSalFrame*)pStruct->lpCreateParams;
 		if ( pFrame != 0 )
 		{
 			SetWindowPtr( hWnd, pFrame );
 			// HWND schon hier setzen, da schon auf den Instanzdaten
 			// gearbeitet werden kann, wenn Messages waehrend
 			// CreateWindow() gesendet werden
-			pFrame->maFrameData.mhWnd = hWnd;
-			pFrame->maFrameData.maSysData.hWnd = hWnd;
+			pFrame->mhWnd = hWnd;
+			pFrame->maSysData.hWnd = hWnd;
 		}
         return 0;
     }
@@ -5026,6 +5415,24 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
             }
             break;
 
+        case WM_COMMAND:
+            ImplSalYieldMutexAcquireWithWait();
+            rDef = !ImplHandleCommand( hWnd, wParam, lParam );
+            ImplSalYieldMutexRelease();
+            break;
+
+        case WM_INITMENUPOPUP:
+            ImplSalYieldMutexAcquireWithWait();
+            rDef = !ImplHandleMenuActivate( hWnd, wParam, lParam );
+            ImplSalYieldMutexRelease();
+            break;
+
+        case WM_MENUSELECT:
+            ImplSalYieldMutexAcquireWithWait();
+            rDef = !ImplHandleMenuSelect( hWnd, wParam, lParam );
+            ImplSalYieldMutexRelease();
+            break;
+
         case WM_SYSCOMMAND:
             ImplSalYieldMutexAcquireWithWait();
             nRet = ImplHandleSysCommand( hWnd, wParam, lParam );
@@ -5034,6 +5441,24 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
                 rDef = FALSE;
             break;
 
+        case WM_MENUCHAR:
+            nRet = ImplMenuChar( hWnd, wParam, lParam );
+            if( nRet )
+                rDef = FALSE;
+            break;
+
+        case WM_MEASUREITEM:
+            nRet = ImplMeasureItem(hWnd, wParam, lParam);
+            if( nRet )
+                rDef = FALSE;
+            break;
+
+        case WM_DRAWITEM:
+            nRet = ImplDrawItem(hWnd, wParam, lParam);
+            if( nRet )
+                rDef = FALSE;
+            break;
+
         case WM_MOVE:
         case SAL_MSG_POSTMOVE:
             ImplHandleMoveMsg( hWnd );
@@ -5090,10 +5515,10 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
         case WM_ENABLE:
             // #95133# a system dialog is opened/closed, using our app window as parent
             {
-                SalFrame* pFrame = GetWindowPtr( hWnd );
+                WinSalFrame* pFrame = GetWindowPtr( hWnd );
                 Window *pWin = NULL;
 	            if( pFrame )
-	                pWin = ((Window*)pFrame->maFrameData.mpInst);
+	                pWin = ((Window*)pFrame->GetInstance());
 
                 if( !wParam )
                 {
@@ -5174,14 +5599,8 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
 			rDef = FALSE;
 			break;
 
-#ifdef WM_DISPLAYCHANGE
         case WM_DISPLAYCHANGE:
-#endif
-#ifdef WM_SETTINGCHANGE
         case WM_SETTINGCHANGE:
-#else
-        case WM_WININICHANGE:
-#endif
         case WM_DEVMODECHANGE:
         case WM_FONTCHANGE:
         case WM_SYSCOLORCHANGE:
@@ -5189,6 +5608,10 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
             ImplHandleSettingsChangeMsg( hWnd, nMsg, wParam, lParam );
             break;
 
+        case WM_THEMECHANGED:
+            GetSalData()->mbThemeChanged = TRUE;
+            break;
+
         case SAL_MSG_USEREVENT:
             ImplHandleUserEvent( hWnd, lParam );
             rDef = FALSE;
@@ -5334,70 +5757,6 @@ BOOL ImplHandleGlobalMsg( HWND hWnd, UIN
     }
     else
         return FALSE;
-}
-
-// -----------------------------------------------------------------------
-
-bool GetSalSystemDisplayInfo( System::DisplayInfo& rInfo )
-{
-    RECT aRect;
-    ImplSalGetWorkArea( NULL, &aRect, NULL );
-
-    HDC hDC;
-    if( hDC = GetDC( NULL ) )
-    {
-        rInfo.nWidth    = aRect.right - aRect.left;
-        rInfo.nHeight   = aRect.bottom - aRect.top;
-        rInfo.nDepth    = GetDeviceCaps( hDC, BITSPIXEL );
-        ReleaseDC( NULL, hDC );
-        return true;
-    }
-    else
-        return false;
-}
-
-// -----------------------------------------------------------------------
-/* We have to map the button identifier to the identifier used by the Win32
-   Platform SDK to specify the default button for the MessageBox API.
-   The first dimension is the button combination, the second dimension
-   is the button identifier.
-*/
-static int DEFAULT_BTN_MAPPING_TABLE[][8] =
-{
-    //  Undefined        OK             CANCEL         ABORT          RETRY          IGNORE         YES             NO
-    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //OK
-    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //OK_CANCEL
-    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3, MB_DEFBUTTON1, MB_DEFBUTTON1 }, //ABORT_RETRY_IGNO
-    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON3, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2 }, //YES_NO_CANCEL
-    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2 }, //YES_NO
-    { MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1, MB_DEFBUTTON1 }  //RETRY_CANCEL
-};
-
-int ImplShowNativeMessageBox(const String& rTitle, const String& rMessage, int nButtonCombination, int nDefaultButton)
-{
-    DBG_ASSERT( nButtonCombination >= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK &&
-                nButtonCombination <= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL &&
-                nDefaultButton >= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK &&
-                nDefaultButton <= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO, "Invalid arguments!" );
-
-    int nFlags = MB_TASKMODAL | MB_SETFOREGROUND | MB_ICONWARNING | nButtonCombination;
-
-    if (nButtonCombination >= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK &&
-        nButtonCombination <= SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL &&
-        nDefaultButton >= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK &&
-        nDefaultButton <= SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO)
-        nFlags |= DEFAULT_BTN_MAPPING_TABLE[nButtonCombination][nDefaultButton];
-
-    //#107209 hide the splash screen if active
-    ImplSVData* pSVData = ImplGetSVData();
-    if (pSVData->mpIntroWindow)
-        pSVData->mpIntroWindow->Hide();
-
-    return MessageBoxW(
-        0,
-        rMessage.GetBuffer(),
-        rTitle.GetBuffer(),
-        nFlags);
 }
 
 // -----------------------------------------------------------------------
Index: vcl/win/source/window/salmenu.cxx
===================================================================
RCS file: vcl/win/source/window/salmenu.cxx
diff -N vcl/win/source/window/salmenu.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/win/source/window/salmenu.cxx	21 May 2004 16:29:40 -0000	1.7
@@ -0,0 +1,458 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SVWIN_H
+#include <tools/svwin.h>
+#endif
+
+#ifndef _SV_WINCOMP_HXX
+#include <wincomp.hxx>
+#endif
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+#ifndef _SV_SALINST_H
+#include <salinst.h>
+#endif
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _SV_SALMENU_H
+#include <salmenu.h>
+#endif
+#ifndef _SV_MENU_HXX
+#include <menu.hxx>
+#endif
+#ifndef _SV_SYSDATA_HXX
+#include <sysdata.hxx>
+#endif
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
+#endif
+#ifndef _SV_IMPBMP_HXX
+#include <impbmp.hxx>
+#endif
+
+// uncomment the following line to have ownerdrawn menues, ie, with bitmaps
+// however, this is incompatible with OLE inplace editing
+// so it is not activated by default
+//#define OWNERDRAW
+
+static DWORD myerr=0;
+
+// =======================================================================
+
+// WinSalInst factory methods
+
+SalMenu* WinSalInstance::CreateMenu( BOOL bMenuBar )
+{
+    WinSalMenu *pSalMenu = new WinSalMenu();
+
+    pSalMenu->mbMenuBar = bMenuBar;
+    pSalMenu->mhWnd     = NULL;
+    if( bMenuBar )
+        pSalMenu->mhMenu = ::CreateMenu();
+    else
+        pSalMenu->mhMenu = ::CreatePopupMenu();
+
+    return pSalMenu;
+}
+
+void WinSalInstance::DestroyMenu( SalMenu* pSalMenu )
+{
+    delete pSalMenu;
+}
+
+
+SalMenuItem* WinSalInstance::CreateMenuItem( const SalItemParams* pItemData )
+{
+    if( !pItemData )
+        return NULL;
+
+    WinSalMenuItem *pSalMenuItem = new WinSalMenuItem();
+    memset( &pSalMenuItem->mInfo, 0, sizeof( MENUITEMINFOW ) );
+    pSalMenuItem->mInfo.cbSize = sizeof( MENUITEMINFOW );
+
+    if( pItemData->eType == MENUITEM_SEPARATOR )
+    {
+        // separator
+        pSalMenuItem->mInfo.fMask = MIIM_TYPE;
+        pSalMenuItem->mInfo.fType = MFT_SEPARATOR;
+    }
+    else
+    {
+        // item
+        pSalMenuItem->mText   = pItemData->aText;
+        pSalMenuItem->mpMenu  = pItemData->pMenu;
+        pSalMenuItem->maBitmap= !!pItemData->aImage ? pItemData->aImage.GetBitmapEx().GetBitmap() : Bitmap();
+        pSalMenuItem->mnId    = pItemData->nId;
+
+        // 'translate' mnemonics
+        pSalMenuItem->mText.SearchAndReplace( '~', '&' );
+        
+        pSalMenuItem->mInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID | MIIM_DATA;
+        pSalMenuItem->mInfo.fType = MFT_STRING; 
+#ifdef OWNERDRAW
+        if( pItemData->pMenu && !pItemData->pMenu->IsMenuBar() )
+            pSalMenuItem->mInfo.fType |= MFT_OWNERDRAW;
+        pSalMenuItem->mInfo.fState = MFS_ENABLED;
+#endif
+        pSalMenuItem->mInfo.dwTypeData = (LPWSTR) pSalMenuItem->mText.GetBuffer();
+        pSalMenuItem->mInfo.cch = pSalMenuItem->mText.Len();
+        
+        pSalMenuItem->mInfo.wID = pItemData->nId;
+        pSalMenuItem->mInfo.dwItemData = (ULONG_PTR) pSalMenuItem; // user data
+    }
+
+    return pSalMenuItem;
+}
+
+void WinSalInstance::DestroyMenuItem( SalMenuItem* pSalMenuItem )
+{
+    delete pSalMenuItem;
+}
+
+
+// =======================================================================
+
+static SalMenu* ImplFindMenuBar( SalMenu *pMenu )
+{
+    WinSalMenu *pMenuBar = static_cast<WinSalMenu*>(pMenu);
+    while( pMenuBar->mpParentMenu )
+        pMenuBar = pMenuBar->mpParentMenu;
+    if( pMenuBar->mbMenuBar )
+        return pMenuBar;
+    else
+        return NULL;
+}
+
+static void ImplDrawMenuBar( SalMenu *pMenu )
+{
+    if( pMenu->VisibleMenuBar() )
+    {
+        // redrawing the menubar all the time actually seems to be unnecessary (it just flickers)
+        /*
+        WinSalMenu *pMenuBar = ImplFindMenuBar( pMenu );
+        if( pMenuBar && pMenuBar->mhWnd )
+            ::DrawMenuBar( pMenuBar->mhWnd );
+            */
+    }
+}
+
+// =======================================================================
+
+
+/*
+ * WinSalMenu
+ */
+
+WinSalMenu::WinSalMenu()
+{
+    mhMenu       = NULL;
+    mbMenuBar    = FALSE;
+    mhWnd        = NULL;
+    mpParentMenu = NULL;
+}
+
+WinSalMenu::~WinSalMenu()
+{
+    // only required if not associated to a window...
+    ::DestroyMenu( mhMenu );
+}
+
+BOOL WinSalMenu::VisibleMenuBar()
+{
+    // The Win32 implementation never shows a native
+    // menubar. Thus, native menues are only visible
+    // when the menu is merged with an OLE container.
+    // The reason are missing tooltips, ownerdraw
+    // issues and accessibility which are better supported
+    // by VCL menues.
+    // Nevertheless, the native menues are always created
+    // and the application will properly react to all native
+    // menu messages.
+
+    return FALSE;
+}
+
+void WinSalMenu::SetFrame( const SalFrame *pFrame )
+{
+    if( pFrame )
+        mhWnd = static_cast<const WinSalFrame*>(pFrame)->mhWnd;
+    else
+        mhWnd = NULL;
+}
+
+void WinSalMenu::InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos )
+{
+    if( pSalMenuItem )
+    {
+	WinSalMenuItem* pWItem = static_cast<WinSalMenuItem*>(pSalMenuItem);
+        if( nPos == MENU_APPEND )
+        {
+            nPos = ::GetMenuItemCount( mhMenu );
+            if( nPos == -1 )
+                return;
+        }
+
+        if(!::InsertMenuItemW( mhMenu, nPos, TRUE, &pWItem->mInfo ))
+            myerr = GetLastError();
+        else
+        {
+            pWItem->mpSalMenu = this;
+            ImplDrawMenuBar( this );
+        }
+    }
+}
+
+void WinSalMenu::RemoveItem( unsigned nPos )
+{
+    int num = ::GetMenuItemCount( mhMenu );
+    if( num != -1 && nPos < (unsigned)num )
+    {
+        WinSalMenuItem *pSalMenuItem = NULL;
+
+        MENUITEMINFOW mi;
+        memset( &mi, 0, sizeof(mi) );
+        mi.cbSize = sizeof( mi );
+        mi.fMask = MIIM_DATA;
+        if( !GetMenuItemInfoW( mhMenu, nPos, TRUE, &mi) )
+            myerr = GetLastError();
+        else
+            pSalMenuItem = (WinSalMenuItem *) mi.dwItemData;
+
+        if( !::RemoveMenu( mhMenu, nPos, MF_BYPOSITION ) )
+            myerr = GetLastError();
+        else
+        {
+            if( pSalMenuItem )
+                pSalMenuItem->mpSalMenu = NULL;
+            ImplDrawMenuBar( this );
+        }
+    }
+}
+
+void ImplRemoveItemById( WinSalMenu *pSalMenu, unsigned nItemId )
+{
+    if( !pSalMenu )
+        return;
+
+    WinSalMenuItem *pSalMenuItem = NULL;
+
+    MENUITEMINFOW mi;
+    memset( &mi, 0, sizeof(mi) );
+    mi.cbSize = sizeof( mi );
+    mi.fMask = MIIM_DATA;
+    if( !GetMenuItemInfoW( pSalMenu->mhMenu, nItemId, FALSE, &mi) )
+        myerr = GetLastError();
+    else
+        pSalMenuItem = (WinSalMenuItem *) mi.dwItemData;
+
+    if( !::RemoveMenu( pSalMenu->mhMenu, nItemId, MF_BYCOMMAND ) )
+        myerr = GetLastError();
+    else
+    {
+        if( pSalMenuItem )
+            pSalMenuItem->mpSalMenu = NULL;
+        ImplDrawMenuBar( pSalMenu );
+    }
+}
+
+void WinSalMenu::SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos )
+{
+    if( pSalMenuItem )
+    {
+	WinSalMenuItem* pWMenuItem = static_cast<WinSalMenuItem*>(pSalMenuItem);
+	WinSalMenu* pWSubMenu = static_cast<WinSalMenu*>(pSubMenu);
+        if( pWMenuItem->mInfo.hSubMenu )
+            ::DestroyMenu( pWMenuItem->mInfo.hSubMenu );
+
+        pWMenuItem->mInfo.fMask |= MIIM_SUBMENU;
+        if( !pSubMenu )
+            pWMenuItem->mInfo.hSubMenu = NULL;
+        else
+        {
+            pWMenuItem->mInfo.hSubMenu = pWSubMenu->mhMenu;
+            pWSubMenu->mpParentMenu = this;
+        }
+
+        int num = ::GetMenuItemCount( mhMenu );
+        if(!::SetMenuItemInfoW( mhMenu, nPos, TRUE, &pWMenuItem->mInfo ) )
+            myerr = GetLastError();
+        else
+            ImplDrawMenuBar( this );
+    }
+}
+
+void WinSalMenu::CheckItem( unsigned nPos, BOOL bCheck )
+{
+    if( -1 != ::CheckMenuItem( mhMenu, nPos, MF_BYPOSITION|(bCheck ? MF_CHECKED : MF_UNCHECKED) ) )
+        ImplDrawMenuBar( this );
+}
+
+void WinSalMenu::EnableItem( unsigned nPos, BOOL bEnable )
+{
+    if( -1 != ::EnableMenuItem( mhMenu, nPos, MF_BYPOSITION|(bEnable ? MF_ENABLED : (MF_DISABLED|MF_GRAYED) ) ) )
+        ImplDrawMenuBar( this );
+}
+
+void WinSalMenu::SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage )
+{
+    if( pSalMenuItem )
+    {
+	WinSalMenuItem* pWItem = static_cast<WinSalMenuItem*>(pSalMenuItem);
+        if( !!rImage )
+            pWItem->maBitmap = rImage.GetBitmapEx().GetBitmap();
+        else
+            pWItem->maBitmap = Bitmap();
+    }
+}
+
+void WinSalMenu::SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const XubString& rText )
+{
+    if( pSalMenuItem )
+    {
+	WinSalMenuItem* pWItem = static_cast<WinSalMenuItem*>(pSalMenuItem);
+        pWItem->mText = rText;
+        // 'translate' mnemonics
+        pWItem->mText.SearchAndReplace( '~', '&' );
+        pWItem->mInfo.fMask = MIIM_TYPE | MIIM_DATA;
+        pWItem->mInfo.fType = MFT_STRING;
+#ifdef OWNERDRAW
+        if( pWItem->mpMenu && !((Menu*) pWItem->mpMenu)->IsMenuBar() )
+            pWItem->mInfo.fType |= MFT_OWNERDRAW;
+#endif
+
+        // combine text and accelerator text
+        XubString aStr( pWItem->mText );
+        if( pWItem->mAccelText.Len() )
+        {
+            aStr.AppendAscii("\t");
+            aStr.Append( pWItem->mAccelText );
+        }
+        pWItem->mInfo.dwTypeData = (LPWSTR) aStr.GetBuffer();
+        pWItem->mInfo.cch = aStr.Len();
+
+        if(!::SetMenuItemInfoW( mhMenu, nPos, TRUE, &pWItem->mInfo ))
+            myerr = GetLastError();
+        else
+            ImplDrawMenuBar( this );
+    }
+}
+
+void WinSalMenu::SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const XubString& rKeyName )
+{
+    if( pSalMenuItem )
+    {
+	WinSalMenuItem* pWItem = static_cast<WinSalMenuItem*>(pSalMenuItem);
+        pWItem->mAccelText = rKeyName;
+        pWItem->mInfo.fMask = MIIM_TYPE | MIIM_DATA;
+        pWItem->mInfo.fType = MFT_STRING;
+#ifdef OWNERDRAW
+        if( pWItem->mpMenu && !((Menu*)pWItem->mpMenu)->IsMenuBar() )
+            pWItem->mInfo.fType |= MFT_OWNERDRAW;
+#endif
+        // combine text and accelerator text
+        XubString aStr( pWItem->mText );
+        if( pWItem->mAccelText.Len() )
+        {
+            aStr.AppendAscii("\t");
+            aStr.Append( pWItem->mAccelText );
+        }
+        pWItem->mInfo.dwTypeData = (LPWSTR) aStr.GetBuffer();
+        pWItem->mInfo.cch = aStr.Len();
+
+        if(!::SetMenuItemInfoW( mhMenu, nPos, TRUE, &pWItem->mInfo ))
+            myerr = GetLastError();
+        else
+            ImplDrawMenuBar( this );
+    }
+}
+
+void WinSalMenu::GetSystemMenuData( SystemMenuData* pData )
+{
+    if( pData )
+        pData->hMenu = mhMenu;
+}
+
+// =======================================================================
+
+/*
+ * SalMenuItem
+ */
+
+
+WinSalMenuItem::WinSalMenuItem()
+{
+    memset( &mInfo, 0, sizeof( MENUITEMINFOW ) );
+    mpMenu = NULL;
+    mnId  = 0xFFFF;
+    mpSalMenu = NULL;
+}
+
+WinSalMenuItem::~WinSalMenuItem()
+{
+    if( mpSalMenu )
+        ImplRemoveItemById( mpSalMenu, mnId );
+}
+
+// -------------------------------------------------------------------
+
Index: vcl/win/source/window/salobj.cxx
===================================================================
RCS file: /cvs/gsl/vcl/vcl/win/source/window/salobj.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/win/source/window/salobj.cxx	7 Dec 2001 11:33:35 -0000	1.2
+++ vcl/win/source/window/salobj.cxx	6 Jan 2004 14:58:37 -0000	1.4
@@ -65,22 +65,20 @@
 #include <tools/svwin.h>
 #endif
 
-#define _SV_SALOBJ_CXX
-
 #ifndef _SV_WINCOMP_HXX
 #include <wincomp.hxx>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
-#ifndef _SV_SALOBJ_HXX
-#include <salobj.hxx>
+#ifndef _SV_SALOBJ_H
+#include <salobj.h>
 #endif
 
 #ifndef _DEBUG_HXX
@@ -110,16 +108,16 @@ static BOOL ImplIsSysWindowOrChild( HWND
 
 // -----------------------------------------------------------------------
 
-SalObject* ImplFindSalObject( HWND hWndChild )
+WinSalObject* ImplFindSalObject( HWND hWndChild )
 {
-	SalData*	pSalData = GetSalData();
-	SalObject*	pObject = pSalData->mpFirstObject;
+	SalData*        pSalData = GetSalData();
+	WinSalObject*	pObject = pSalData->mpFirstObject;
 	while ( pObject )
 	{
-		if ( ImplIsSysWindowOrChild( pObject->maObjectData.mhWndChild, hWndChild ) )
+		if ( ImplIsSysWindowOrChild( pObject->mhWndChild, hWndChild ) )
 			return pObject;
 
-		pObject = pObject->maObjectData.mpNextObject;
+		pObject = pObject->mpNextObject;
 	}
 
 	return NULL;
@@ -127,21 +125,21 @@ SalObject* ImplFindSalObject( HWND hWndC
 
 // -----------------------------------------------------------------------
 
-SalFrame* ImplFindSalObjectFrame( HWND hWnd )
+WinSalFrame* ImplFindSalObjectFrame( HWND hWnd )
 {
-	SalFrame* pFrame = NULL;
-	SalObject* pObject = ImplFindSalObject( hWnd );
+	WinSalFrame* pFrame = NULL;
+	WinSalObject* pObject = ImplFindSalObject( hWnd );
 	if ( pObject )
 	{
 		// Dazugehoerenden Frame suchen
-		HWND hWnd = ::GetParent( pObject->maObjectData.mhWnd );
+		HWND hWnd = ::GetParent( pObject->mhWnd );
 		pFrame = GetSalData()->mpFirstFrame;
 		while ( pFrame )
 		{
-			if ( pFrame->maFrameData.mhWnd == hWnd )
+			if ( pFrame->mhWnd == hWnd )
 				break;
 
-			pFrame = pFrame->maFrameData.mpNextFrame;
+			pFrame = pFrame->mpNextFrame;
 		}
 	}
 
@@ -164,21 +162,20 @@ LRESULT CALLBACK SalSysMsgProc( int nCod
 
 		// Testen, ob wir Daten fuer ein SalObject-Fenster behandeln
 		// muessen
-		SalObject* pObject;
+		WinSalObject* pObject;
 		if ( pData->message == WM_SETFOCUS )
 		{
 			pObject = ImplFindSalObject( pData->hwnd );
 			if ( pObject )
 			{
-				pObject->maObjectData.mhLastFocusWnd = pData->hwnd;
+				pObject->mhLastFocusWnd = pData->hwnd;
 				if ( ImplSalYieldMutexTryToAcquire() )
 				{
-					pObject->maObjectData.mpProc( pObject->maObjectData.mpInst, pObject,
-												  SALOBJ_EVENT_GETFOCUS, 0 );
+					pObject->CallCallback( SALOBJ_EVENT_GETFOCUS, 0 );
 					ImplSalYieldMutexRelease();
 				}
 				else
-					ImplPostMessage( pObject->maObjectData.mhWnd, SALOBJ_MSG_POSTFOCUS, 0, 0 );
+					ImplPostMessage( pObject->mhWnd, SALOBJ_MSG_POSTFOCUS, 0, 0 );
 			}
 		}
 		else if ( pData->message == WM_KILLFOCUS )
@@ -192,15 +189,14 @@ LRESULT CALLBACK SalSysMsgProc( int nCod
 				{
 					if ( ImplSalYieldMutexTryToAcquire() )
 					{
-						pObject->maObjectData.mpProc( pObject->maObjectData.mpInst, pObject,
-													  SALOBJ_EVENT_LOSEFOCUS, 0 );
+						pObject->CallCallback( SALOBJ_EVENT_LOSEFOCUS, 0 );
 						ImplSalYieldMutexRelease();
 					}
 					else
-						ImplPostMessage( pObject->maObjectData.mhWnd, SALOBJ_MSG_POSTFOCUS, 0, 0 );
+						ImplPostMessage( pObject->mhWnd, SALOBJ_MSG_POSTFOCUS, 0, 0 );
 				}
 				else
-					pObject->maObjectData.mhLastFocusWnd = (HWND)pData->wParam;
+					pObject->mhLastFocusWnd = (HWND)pData->wParam;
 			}
 		}
 	}
@@ -213,8 +209,8 @@ LRESULT CALLBACK SalSysMsgProc( int nCod
 BOOL ImplSalPreDispatchMsg( MSG* pMsg )
 {
 	// Used for Unicode and none Unicode
-	SalData*	pSalData = GetSalData();
-	SalObject*	pObject;
+	SalData*	    pSalData = GetSalData();
+	WinSalObject*	pObject;
 
 	if ( (pMsg->message == WM_LBUTTONDOWN) ||
 		 (pMsg->message == WM_RBUTTONDOWN) ||
@@ -223,7 +219,7 @@ BOOL ImplSalPreDispatchMsg( MSG* pMsg )
 		ImplSalYieldMutexAcquireWithWait();
 		pObject = ImplFindSalObject( pMsg->hwnd );
 		if ( pObject )
-			ImplPostMessage( pObject->maObjectData.mhWnd, SALOBJ_MSG_TOTOP, 0, 0 );
+			ImplPostMessage( pObject->mhWnd, SALOBJ_MSG_TOTOP, 0, 0 );
 		ImplSalYieldMutexRelease();
 	}
 
@@ -276,10 +272,10 @@ BOOL ImplSalPreDispatchMsg( MSG* pMsg )
 			{
 				if ( pMsg->hwnd == ::GetFocus() )
 				{
-					SalFrame* pFrame = ImplFindSalObjectFrame( pMsg->hwnd );
+					WinSalFrame* pFrame = ImplFindSalObjectFrame( pMsg->hwnd );
 					if ( pFrame )
 					{
-						if ( ImplHandleSalObjSysCharMsg( pFrame->maFrameData.mhWnd, pMsg->wParam, pMsg->lParam ) )
+						if ( ImplHandleSalObjSysCharMsg( pFrame->mhWnd, pMsg->wParam, pMsg->lParam ) )
 							bRet = TRUE;
 					}
 				}
@@ -300,8 +296,8 @@ BOOL ImplSalPreDispatchMsg( MSG* pMsg )
 void ImplSalPostDispatchMsg( MSG* pMsg, LRESULT /* nDispatchResult */ )
 {
 	// Used for Unicode and none Unicode
-	SalData*	pSalData = GetSalData();
-	SalFrame*	pFrame;
+	SalData*	    pSalData = GetSalData();
+	WinSalFrame*	pFrame;
 
 	if ( (pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_KEYUP) )
 	{
@@ -313,7 +309,7 @@ void ImplSalPostDispatchMsg( MSG* pMsg, 
 				ImplSalYieldMutexAcquireWithWait();
 				pFrame = ImplFindSalObjectFrame( pMsg->hwnd );
 				if ( pFrame )
-					ImplHandleSalObjKeyMsg( pFrame->maFrameData.mhWnd, pMsg->message, pMsg->wParam, pMsg->lParam );
+					ImplHandleSalObjKeyMsg( pFrame->mhWnd, pMsg->message, pMsg->wParam, pMsg->lParam );
 				ImplSalYieldMutexRelease();
 			}
 		}
@@ -326,8 +322,8 @@ void ImplSalPostDispatchMsg( MSG* pMsg, 
 
 LRESULT CALLBACK SalSysObjWndProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam, int& rDef )
 {
-	SalObject*	pSysObj;
-	LRESULT 	nRet = 0;
+	WinSalObject*	pSysObj;
+	LRESULT      	nRet = 0;
 
 	switch( nMsg )
 	{
@@ -354,7 +350,7 @@ LRESULT CALLBACK SalSysObjWndProc( HWND 
 				ImplSalYieldMutexAcquireWithWait();
 				pSysObj = GetSalObjWindowPtr( hWnd );
 				if ( pSysObj )
-					pSysObj->maObjectData.mpProc( pSysObj->maObjectData.mpInst, pSysObj, SALOBJ_EVENT_TOTOP, 0 );
+					pSysObj->CallCallback( SALOBJ_EVENT_TOTOP, 0 );
 				ImplSalYieldMutexRelease();
 			}
 			}
@@ -368,8 +364,7 @@ LRESULT CALLBACK SalSysObjWndProc( HWND 
 			if ( ImplSalYieldMutexTryToAcquire() )
 			{
 				pSysObj = GetSalObjWindowPtr( hWnd );
-				pSysObj->maObjectData.mpProc( pSysObj->maObjectData.mpInst, pSysObj,
-											  SALOBJ_EVENT_TOTOP, 0 );
+				pSysObj->CallCallback( SALOBJ_EVENT_TOTOP, 0 );
 				ImplSalYieldMutexRelease();
 				rDef = FALSE;
 			}
@@ -387,8 +382,7 @@ LRESULT CALLBACK SalSysObjWndProc( HWND 
 					nEvent = SALOBJ_EVENT_GETFOCUS;
 				else
 					nEvent = SALOBJ_EVENT_LOSEFOCUS;
-				pSysObj->maObjectData.mpProc( pSysObj->maObjectData.mpInst, pSysObj,
-											  nEvent, 0 );
+				pSysObj->CallCallback( nEvent, 0 );
 				ImplSalYieldMutexRelease();
 			}
 			else
@@ -415,12 +409,12 @@ LRESULT CALLBACK SalSysObjWndProc( HWND 
 			// Can also be used for the W-Version, because the struct
 			// to access lpCreateParams is the same structure
 			CREATESTRUCTA* pStruct = (CREATESTRUCTA*)lParam;
-			pSysObj = (SalObject*)pStruct->lpCreateParams;
+			pSysObj = (WinSalObject*)pStruct->lpCreateParams;
 			SetSalObjWindowPtr( hWnd, pSysObj );
 			// HWND schon hier setzen, da schon auf den Instanzdaten
 			// gearbeitet werden kann, wenn Messages waehrend
 			// CreateWindow() gesendet werden
-			pSysObj->maObjectData.mhWnd = hWnd;
+			pSysObj->mhWnd = hWnd;
 			rDef = FALSE;
 			}
 			break;
@@ -495,7 +489,7 @@ LRESULT CALLBACK SalSysObjChildWndProcW(
 
 // =======================================================================
 
-SalObject* ImplSalCreateObject( SalInstance* pInst, SalFrame* pParent )
+SalObject* ImplSalCreateObject( WinSalInstance* pInst, WinSalFrame* pParent )
 {
 	SalData* pSalData = GetSalData();
 
@@ -577,7 +571,7 @@ SalObject* ImplSalCreateObject( SalInsta
 
 	if ( pSalData->mbObjClassInit )
 	{
-		SalObject* pObject = new SalObject;
+		WinSalObject* pObject = new WinSalObject;
 		HWND		hWnd;
 		HWND		hWndChild = 0;
         // #95301# shockwave plugin has bug; expects ASCII functions to be used
@@ -585,30 +579,30 @@ SalObject* ImplSalCreateObject( SalInsta
 		{
 			hWnd = CreateWindowExW( 0, SAL_OBJECT_CLASSNAMEW, L"",
 									WS_CHILD, 0, 0, 0, 0,
-									pParent->maFrameData.mhWnd, 0,
-									pInst->maInstData.mhInst, (void*)pObject );
+									pParent->mhWnd, 0,
+									pInst->mhInst, (void*)pObject );
 			if ( hWnd )
 			{
 				hWndChild = CreateWindowExW( 0, SAL_OBJECT_CHILDCLASSNAMEW, L"",
 											 WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE,
 											 0, 0, 0, 0,
 											 hWnd, 0,
-											 pInst->maInstData.mhInst, NULL );
+											 pInst->mhInst, NULL );
 			}
 		}
 		else
 		{
 			hWnd = CreateWindowExA( 0, SAL_OBJECT_CLASSNAMEA, "",
 									WS_CHILD, 0, 0, 0, 0,
-									pParent->maFrameData.mhWnd, 0,
-									pInst->maInstData.mhInst, (void*)pObject );
+									pParent->mhWnd, 0,
+									pInst->mhInst, (void*)pObject );
 			if ( hWnd )
 			{
 				hWndChild = CreateWindowExA( 0, SAL_OBJECT_CHILDCLASSNAMEA, "",
 											 WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE,
 											 0, 0, 0, 0,
 											 hWnd, 0,
-											 pInst->maInstData.mhInst, NULL );
+											 pInst->mhInst, NULL );
 			}
 		}
 		if ( !hWndChild )
@@ -619,9 +613,9 @@ SalObject* ImplSalCreateObject( SalInsta
 
 		if ( hWnd )
 		{
-			pObject->maObjectData.mhWnd 			= hWnd;
-			pObject->maObjectData.mhWndChild		= hWndChild;
-			pObject->maObjectData.maSysData.hWnd	= hWndChild;
+			pObject->mhWnd 			= hWnd;
+			pObject->mhWndChild		= hWndChild;
+			pObject->maSysData.hWnd	= hWndChild;
 			return pObject;
 		}
 	}
@@ -631,40 +625,31 @@ SalObject* ImplSalCreateObject( SalInsta
 
 // =======================================================================
 
-long ImplSalObjCallbackDummy( void*, SalObject*, USHORT, const void* )
-{
-	return 0;
-}
-
-// =======================================================================
-
-SalObject::SalObject()
+WinSalObject::WinSalObject()
 {
 	SalData* pSalData = GetSalData();
 
-	maObjectData.mhWnd				= 0;
-	maObjectData.mhWndChild 		= 0;
-	maObjectData.mhLastFocusWnd 	= 0;
-	maObjectData.maSysData.nSize	= sizeof( SystemEnvData );
-	maObjectData.mpInst 			= NULL;
-	maObjectData.mpProc 			= ImplSalObjCallbackDummy;
-	maObjectData.mpStdClipRgnData	= NULL;
+	mhWnd			= 0;
+	mhWndChild 		= 0;
+	mhLastFocusWnd 	= 0;
+	maSysData.nSize	= sizeof( SystemEnvData );
+	mpStdClipRgnData	= NULL;
 
 	// Insert object in objectlist
-	maObjectData.mpNextObject = pSalData->mpFirstObject;
+	mpNextObject = pSalData->mpFirstObject;
 	pSalData->mpFirstObject = this;
 }
 
 // -----------------------------------------------------------------------
 
-SalObject::~SalObject()
+WinSalObject::~WinSalObject()
 {
 	SalData* pSalData = GetSalData();
 
 	// remove frame from framelist
 	if ( this == pSalData->mpFirstObject )
 	{
-		pSalData->mpFirstObject = maObjectData.mpNextObject;
+		pSalData->mpFirstObject = mpNextObject;
 
 		// Wenn letztes SalObject, dann Hook wieder entfernen
 		if ( !pSalData->mpFirstObject )
@@ -672,23 +657,23 @@ SalObject::~SalObject()
 	}
 	else
 	{
-		SalObject* pTempObject = pSalData->mpFirstObject;
-		while ( pTempObject->maObjectData.mpNextObject != this )
-			pTempObject = pTempObject->maObjectData.mpNextObject;
+		WinSalObject* pTempObject = pSalData->mpFirstObject;
+		while ( pTempObject->mpNextObject != this )
+			pTempObject = pTempObject->mpNextObject;
 
-		pTempObject->maObjectData.mpNextObject = maObjectData.mpNextObject;
+		pTempObject->mpNextObject = mpNextObject;
 	}
 
 	// Cache-Daten zerstoeren
-	if ( maObjectData.mpStdClipRgnData )
-		delete maObjectData.mpStdClipRgnData;
+	if ( mpStdClipRgnData )
+		delete mpStdClipRgnData;
 
-	HWND hWndParent = ::GetParent( maObjectData.mhWnd );
+	HWND hWndParent = ::GetParent( mhWnd );
 
-	if ( maObjectData.mhWndChild )
-		DestroyWindow( maObjectData.mhWndChild );
-	if ( maObjectData.mhWnd )
-		DestroyWindow( maObjectData.mhWnd );
+	if ( mhWndChild )
+		DestroyWindow( mhWndChild );
+	if ( mhWnd )
+		DestroyWindow( mhWnd );
 
 	// Palette wieder zuruecksetzen, wenn kein externes Child-Fenster
 	// mehr vorhanden ist, da diese unsere Palette ueberschrieben haben
@@ -701,56 +686,56 @@ SalObject::~SalObject()
 
 // -----------------------------------------------------------------------
 
-void SalObject::ResetClipRegion()
+void WinSalObject::ResetClipRegion()
 {
-	SetWindowRgn( maObjectData.mhWnd, 0, TRUE );
+	SetWindowRgn( mhWnd, 0, TRUE );
 }
 
 // -----------------------------------------------------------------------
 
-USHORT SalObject::GetClipRegionType()
+USHORT WinSalObject::GetClipRegionType()
 {
 	return SAL_OBJECT_CLIP_INCLUDERECTS;
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::BeginSetClipRegion( ULONG nRectCount )
+void WinSalObject::BeginSetClipRegion( ULONG nRectCount )
 {
 	ULONG nRectBufSize = sizeof(RECT)*nRectCount;
 	if ( nRectCount < SAL_CLIPRECT_COUNT )
 	{
-		if ( !maObjectData.mpStdClipRgnData )
-			maObjectData.mpStdClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+(SAL_CLIPRECT_COUNT*sizeof(RECT))];
-		maObjectData.mpClipRgnData = maObjectData.mpStdClipRgnData;
+		if ( !mpStdClipRgnData )
+			mpStdClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+(SAL_CLIPRECT_COUNT*sizeof(RECT))];
+		mpClipRgnData = mpStdClipRgnData;
 	}
 	else
-		maObjectData.mpClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+nRectBufSize];
-	maObjectData.mpClipRgnData->rdh.dwSize	  = sizeof( RGNDATAHEADER );
-	maObjectData.mpClipRgnData->rdh.iType	  = RDH_RECTANGLES;
-	maObjectData.mpClipRgnData->rdh.nCount	  = nRectCount;
-	maObjectData.mpClipRgnData->rdh.nRgnSize  = nRectBufSize;
-	SetRectEmpty( &(maObjectData.mpClipRgnData->rdh.rcBound) );
-	maObjectData.mpNextClipRect 		  = (RECT*)(&(maObjectData.mpClipRgnData->Buffer));
-	maObjectData.mbFirstClipRect		  = TRUE;
+		mpClipRgnData = (RGNDATA*)new BYTE[sizeof(RGNDATA)-1+nRectBufSize];
+	mpClipRgnData->rdh.dwSize	  = sizeof( RGNDATAHEADER );
+	mpClipRgnData->rdh.iType	  = RDH_RECTANGLES;
+	mpClipRgnData->rdh.nCount	  = nRectCount;
+	mpClipRgnData->rdh.nRgnSize  = nRectBufSize;
+	SetRectEmpty( &(mpClipRgnData->rdh.rcBound) );
+	mpNextClipRect 		  = (RECT*)(&(mpClipRgnData->Buffer));
+	mbFirstClipRect		  = TRUE;
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::UnionClipRegion( long nX, long nY, long nWidth, long nHeight )
+void WinSalObject::UnionClipRegion( long nX, long nY, long nWidth, long nHeight )
 {
-	RECT*		pRect = maObjectData.mpNextClipRect;
-	RECT*		pBoundRect = &(maObjectData.mpClipRgnData->rdh.rcBound);
+	RECT*		pRect = mpNextClipRect;
+	RECT*		pBoundRect = &(mpClipRgnData->rdh.rcBound);
 	long		nRight = nX + nWidth;
 	long		nBottom = nY + nHeight;
 
-	if ( maObjectData.mbFirstClipRect )
+	if ( mbFirstClipRect )
 	{
 		pBoundRect->left	= nX;
 		pBoundRect->top 	= nY;
 		pBoundRect->right	= nRight;
 		pBoundRect->bottom	= nBottom;
-		maObjectData.mbFirstClipRect = FALSE;
+		mbFirstClipRect = FALSE;
 	}
 	else
 	{
@@ -771,105 +756,94 @@ void SalObject::UnionClipRegion( long nX
 	pRect->top		= (int)nY;
 	pRect->right	= (int)nRight;
 	pRect->bottom	= (int)nBottom;
-	maObjectData.mpNextClipRect++;
+	mpNextClipRect++;
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::EndSetClipRegion()
+void WinSalObject::EndSetClipRegion()
 {
 	HRGN hRegion;
 
 	// Aus den Region-Daten muessen wir jetzt eine ClipRegion erzeugen
-	if ( maObjectData.mpClipRgnData->rdh.nCount == 1 )
+	if ( mpClipRgnData->rdh.nCount == 1 )
 	{
-		RECT* pRect = &(maObjectData.mpClipRgnData->rdh.rcBound);
+		RECT* pRect = &(mpClipRgnData->rdh.rcBound);
 		hRegion = CreateRectRgn( pRect->left, pRect->top,
 								 pRect->right, pRect->bottom );
 	}
 	else
 	{
-		ULONG nSize = maObjectData.mpClipRgnData->rdh.nRgnSize+sizeof(RGNDATAHEADER);
-		hRegion = ExtCreateRegion( NULL, nSize, maObjectData.mpClipRgnData );
-		if ( maObjectData.mpClipRgnData != maObjectData.mpStdClipRgnData )
-			delete maObjectData.mpClipRgnData;
+		ULONG nSize = mpClipRgnData->rdh.nRgnSize+sizeof(RGNDATAHEADER);
+		hRegion = ExtCreateRegion( NULL, nSize, mpClipRgnData );
+		if ( mpClipRgnData != mpStdClipRgnData )
+			delete mpClipRgnData;
 	}
 
 	DBG_ASSERT( hRegion, "SalObject::EndSetClipRegion() - Can't create ClipRegion" );
-	SetWindowRgn( maObjectData.mhWnd, hRegion, TRUE );
+	SetWindowRgn( mhWnd, hRegion, TRUE );
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
+void WinSalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
 {
 	ULONG nStyle = 0;
-	BOOL bVisible = (GetWindowStyle( maObjectData.mhWnd ) & WS_VISIBLE) != 0;
+	BOOL bVisible = (GetWindowStyle( mhWnd ) & WS_VISIBLE) != 0;
 	if ( bVisible )
 	{
-		ShowWindow( maObjectData.mhWnd, SW_HIDE );
+		ShowWindow( mhWnd, SW_HIDE );
 		nStyle |= SWP_SHOWWINDOW;
 	}
-	SetWindowPos( maObjectData.mhWnd, 0,
+	SetWindowPos( mhWnd, 0,
 				  (int)nX, (int)nY, (int)nWidth, (int)nHeight,
 				  SWP_NOZORDER | SWP_NOACTIVATE | nStyle );
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::Show( BOOL bVisible )
+void WinSalObject::Show( BOOL bVisible )
 {
 	if ( bVisible )
-		ShowWindow( maObjectData.mhWnd, SW_SHOWNORMAL );
+		ShowWindow( mhWnd, SW_SHOWNORMAL );
 	else
-		ShowWindow( maObjectData.mhWnd, SW_HIDE );
+		ShowWindow( mhWnd, SW_HIDE );
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::Enable( BOOL bEnable )
+void WinSalObject::Enable( BOOL bEnable )
 {
-	EnableWindow( maObjectData.mhWnd, bEnable );
+	EnableWindow( mhWnd, bEnable );
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::GrabFocus()
+void WinSalObject::GrabFocus()
 {
-	if ( maObjectData.mhLastFocusWnd &&
-		 IsWindow( maObjectData.mhLastFocusWnd ) &&
-		 ImplIsSysWindowOrChild( maObjectData.mhWndChild, maObjectData.mhLastFocusWnd ) )
-		::SetFocus( maObjectData.mhLastFocusWnd );
+	if ( mhLastFocusWnd &&
+		 IsWindow( mhLastFocusWnd ) &&
+		 ImplIsSysWindowOrChild( mhWndChild, mhLastFocusWnd ) )
+		::SetFocus( mhLastFocusWnd );
 	else
-		::SetFocus( maObjectData.mhWndChild );
+		::SetFocus( mhWndChild );
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::SetBackground()
+void WinSalObject::SetBackground()
 {
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::SetBackground( SalColor nSalColor )
+void WinSalObject::SetBackground( SalColor nSalColor )
 {
 }
 
 // -----------------------------------------------------------------------
 
-const SystemEnvData* SalObject::GetSystemData() const
+const SystemEnvData* WinSalObject::GetSystemData() const
 {
-	return &maObjectData.maSysData;
-}
-
-// -----------------------------------------------------------------------
-
-void SalObject::SetCallback( void* pInst, SALOBJECTPROC pProc )
-{
-	maObjectData.mpInst = pInst;
-	if ( pProc )
-		maObjectData.mpProc = pProc;
-	else
-		maObjectData.mpProc = ImplSalObjCallbackDummy;
+	return &maSysData;
 }
