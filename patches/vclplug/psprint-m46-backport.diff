Index: psprint/inc/cupsmgr.hxx
===================================================================
RCS file: psprint/inc/cupsmgr.hxx
diff -N psprint/inc/cupsmgr.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ psprint/inc/cupsmgr.hxx	17 Mar 2004 10:47:45 -0000	1.2
@@ -0,0 +1,128 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _PSPRINT_CUPSMGR_HXX_
+#define _PSPRINT_CUPSMGR_HXX_
+
+#include <psprint/printerinfomanager.hxx>
+#include <osl/module.h>
+
+namespace psp
+{
+
+class CUPSWrapper;
+class PPDParser;
+
+struct FPtrHash
+{
+    size_t operator()(const FILE* pPtr) const
+    { return (size_t)pPtr; }
+};
+
+class CUPSManager : public PrinterInfoManager
+{
+    CUPSWrapper*												m_pCUPSWrapper;
+    std::hash_map< FILE*, rtl::OString, FPtrHash >				m_aSpoolFiles;
+    int															m_nDests;
+    void*														m_pDests;
+    bool														m_bFirstDest;
+    std::hash_map< rtl::OUString, int, rtl::OUStringHash >		m_aCUPSDestMap;
+
+    rtl::OString												m_aUser;
+    // this is a security risk, but the CUPS API demands
+    // to deliver a pointer to a static buffer containing
+    // the password, so this cannot be helped
+    rtl::OString												m_aPassword;
+
+    CUPSManager( CUPSWrapper*, int nDests = 0, void* pDests = NULL );
+    virtual ~CUPSManager();
+
+    virtual void initialize();
+public:
+
+    static CUPSManager* tryLoadCUPS();
+
+    const PPDParser* createCUPSParser( const rtl::OUString& rPrinter );
+	// wraps cupsGetPPD, so unlink after use !
+
+    const char* authenticateUser( const char* );
+
+    virtual FILE* startSpool( const rtl::OUString& rPrinterName );
+    virtual int endSpool( const rtl::OUString& rPrinterName, const rtl::OUString& rJobTitle, FILE* pFile );
+    virtual void setupJobContextData( JobData& rData );
+
+    // changes the info about a named printer
+    virtual void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
+
+    // check if the printer configuration has changed
+    virtual bool checkPrintersChanged();
+
+    // members for administration (->padmin)
+    // disable for CUPS
+    virtual bool addPrinter( const rtl::OUString& rPrinterName, const ::rtl::OUString& rDriverName );
+    virtual bool removePrinter( const rtl::OUString& rPrinterName, bool bCheckOnly = false );
+    virtual bool writePrinterConfig();
+    virtual bool setDefaultPrinter( const rtl::OUString& rPrinterName );
+};
+
+} // namespace psp
+
+#endif
--- psprint/inc/psprint/fontcache.hxx	15 Jan 2004 12:56:53 -0000	1.2.38.1
+++ psprint/inc/psprint/fontcache.hxx	2 Feb 2004 18:52:33 -0000	1.3
Index: psprint/inc/psprint/fontmanager.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/fontmanager.hxx,v
retrieving revision 1.15.20.1
retrieving revision 1.18
diff -u -p -u -r1.15.20.1 -r1.18
--- psprint/inc/psprint/fontmanager.hxx	7 Apr 2004 11:04:23 -0000	1.15.20.1
+++ psprint/inc/psprint/fontmanager.hxx	17 Jun 2004 13:50:47 -0000	1.18
@@ -337,7 +337,7 @@ class PrintFontManager
     {
         static const int MaskFoundry	= 1;
         static const int MaskFamily		= 2;
-        static const int MaskAddStyle   = 4;
+        static const int MaskAddStyle	= 4;
         static const int MaskItalic		= 8;
         static const int MaskWeight		= 16;
         static const int MaskWidth		= 32;
@@ -421,6 +421,12 @@ class PrintFontManager
 
     void getServerDirectories(); // get font server directories on e.g. redhat
 
+    // try to initialize from libfontconfig
+    // returns true if at least one font was added by libfontconfig,
+    // else returns false (e.g. no libfontconfig found
+    // called from initialize()
+    bool initFontconfig();
+
     static bool parseXLFD( const rtl::OString& rXLFD, XLFDEntry& rEntry );
     void parseXLFD_appendAliases( const std::list< rtl::OString >& rXLFDs, std::list< XLFDEntry >& rEntries ) const;
     void initFontsAlias();
@@ -607,7 +613,7 @@ public:
     // pXMin, pYMin, pXMax, pYMax: outgoing font bounding box
     bool createFontSubset( fontID nFont,
                            const rtl::OUString& rOutFile,
-                           long* pGlyphIDs,
+                           sal_Int32* pGlyphIDs,
                            sal_uInt8* pNewEncoding,
                            sal_Int32* pWidths,
                            int nGlyphs,
Index: psprint/inc/psprint/helper.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/helper.hxx,v
retrieving revision 1.4.38.1
retrieving revision 1.6
diff -u -p -u -r1.4.38.1 -r1.6
--- psprint/inc/psprint/helper.hxx	15 Jan 2004 12:57:18 -0000	1.4.38.1
+++ psprint/inc/psprint/helper.hxx	15 Mar 2004 12:09:35 -0000	1.6
@@ -77,15 +77,21 @@ namespace osl { class File; }
 namespace psp {
 typedef int fontID;
 
-const ::rtl::OUString& getPrinterPath();
+const rtl::OUString& getPrinterPath();
 void getPrinterPathList( std::list< rtl::OUString >& rPathList, const char* pSubDir );
-const ::rtl::OUString& getFontPath();
+const rtl::OUString& getFontPath();
 
-bool convertPfbToPfa( ::osl::File& rInFile, ::osl::File& rOutFile );
+bool convertPfbToPfa( osl::File& rInFile, osl::File& rOutFile );
+
+// normalized path (equivalent to realpath)
+void normPath( rtl::OString& rPath );
+
+// splits rOrgPath into dirname and basename
+// rOrgPath will be subject to normPath
+void splitPath( rtl::OString& rOrgPath, rtl::OString& rDir, rtl::OString& rBase );
 
 enum whichOfficePath { NetPath, UserPath };
 const rtl::OUString& getOfficePath( enum whichOfficePath ePath );
-
 } // namespace
 
 #endif // _PSPRINT_HELPER_HXX_
Index: psprint/inc/psprint/jobdata.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/jobdata.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- psprint/inc/psprint/jobdata.hxx	8 May 2001 11:45:33 -0000	1.1.1.1
+++ psprint/inc/psprint/jobdata.hxx	17 Mar 2004 10:47:57 -0000	1.2
@@ -105,6 +105,10 @@ struct JobData
             m_eOrientation( orientation::Portrait ),
             m_pParser( NULL ) {}
 
+    JobData& operator=(const psp::JobData& rRight);
+
+    JobData( const JobData& rData ) { *this = rData; }
+
     // creates a new buffer using new
     // it is up to the user to delete it again
     bool getStreamBuffer( void*& pData, int& bytes );
@@ -112,5 +116,6 @@ struct JobData
 };
 
 } // namespace
+
 
 #endif // PSPRINT_JOBDATA_HXX
Index: psprint/inc/psprint/ppdparser.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/ppdparser.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- psprint/inc/psprint/ppdparser.hxx	11 Apr 2003 17:17:50 -0000	1.4
+++ psprint/inc/psprint/ppdparser.hxx	17 Mar 2004 10:48:09 -0000	1.5
@@ -149,11 +149,13 @@ public:
  */
 
 class PPDContext;
+class CUPSManager;
 
 class PPDParser
 {
     friend class PPDContext;
-    
+    friend class CUPSManager;
+
     typedef ::std::hash_map< ::rtl::OUString, PPDKey*, ::rtl::OUStringHash > hash_type;
     typedef ::std::vector< PPDKey* > value_type;
 
Index: psprint/inc/psprint/printergfx.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/printergfx.hxx,v
retrieving revision 1.11
retrieving revision 1.13
diff -u -p -u -r1.11 -r1.13
--- psprint/inc/psprint/printergfx.hxx	30 Jun 2003 14:26:09 -0000	1.11
+++ psprint/inc/psprint/printergfx.hxx	6 Jan 2004 19:06:03 -0000	1.13
@@ -113,10 +113,10 @@ public:
             meColorspace (eRGB)
     {}
     PrinterColor (sal_uInt32 nRGB) :
-            meColorspace (eRGB),
-            mnBlue  ((nRGB & 0x000000ff)      ),
+            mnRed   ((nRGB & 0x00ff0000) >> 16),
             mnGreen ((nRGB & 0x0000ff00) >>  8),
-            mnRed   ((nRGB & 0x00ff0000) >> 16)
+            mnBlue  ((nRGB & 0x000000ff)      ),
+            meColorspace (eRGB)
     {}
     ~PrinterColor ()
     {}
@@ -210,6 +210,8 @@ struct GraphicsStatus
 {
     rtl::OString        maFont;
     rtl_TextEncoding	maEncoding;
+    bool				mbArtItalic;
+    bool				mbArtBold;
     sal_Int32           mnTextHeight;
     sal_Int32           mnTextWidth;
     PrinterColor        maColor;
@@ -428,7 +430,9 @@ public:
                              sal_Int32 nPointHeight,
                              sal_Int32 nPointWidth,
                              sal_Int32 nAngle,
-                             bool bVertical
+                             bool bVertical,
+                             bool bArtItalic,
+                             bool bArtBold
                              );
     sal_uInt16      SetFallbackFont ( sal_Int32 nFontID );
     sal_Int32       GetFontAngle () const
@@ -441,6 +445,10 @@ public:
     { return maVirtualStatus.mnTextHeight; }
     sal_Int32       GetFontWidth () const
     { return maVirtualStatus.mnTextWidth; }
+    bool			GetArtificialItalic() const
+    { return maVirtualStatus.mbArtItalic; }
+    bool			GetArtificialBold() const
+    { return maVirtualStatus.mbArtBold; }
     void            DrawText (const Point& rPoint, 
                               const sal_Unicode* pStr, sal_Int16 nLen, 
                               const sal_Int32* pDeltaArray = NULL);
Index: psprint/inc/psprint/printerinfomanager.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/printerinfomanager.hxx,v
retrieving revision 1.4.26.1.18.1
retrieving revision 1.6
diff -u -p -u -r1.4.26.1.18.1 -r1.6
--- psprint/inc/psprint/printerinfomanager.hxx	9 May 2004 15:21:14 -0000	1.4.26.1.18.1
+++ psprint/inc/psprint/printerinfomanager.hxx	17 Mar 2004 10:48:31 -0000	1.6
@@ -80,6 +80,7 @@
 #ifndef _PSPRINT_HELPER_HXX_
 #include <psprint/helper.hxx>
 #endif
+#include <cstdio>
 
 #ifdef MACOSX
 /* MacOS X print system discovery constants:
@@ -88,17 +89,20 @@
  * They are used as indications _as well as_ indexes into the
  * aParms structure used below for print commands.
  */
-#define		kApplePrintingFailure                   0		/* For whatever reason, we can't print at all */
+#define		kApplePrintingFailure		0		/* For whatever reason, we can't print at all */
 #define		kApplePrintingLPR			1		/* Darwin 5.x style LPR printing */
 #define		kApplePrintingCUPS			2		/* MacOS X 10.2/Darwin 6 style CUPS (also CUPS installed by users on 10.1) */
-#define         kApplePrintingNewCUPS                   3               /* MacOSX 10.3/Darwin 7 style CUPS with integrated ghostscript like filters */
+#define		kApplePrintingPrintCenter	3		/* MacOS X 10.1 /usr/sbin/Print printing */
 
 /* Constants for PostScript vs PDF printing */
-#define		kApplePrintingUsePDF		        1	/* Run PS through ps to pdfconversion first requires GhostScript in /usr/local */
-#define		kApplePrintingUsePS			2	/* print PS directly to printer (requires PS printer or New CUPS) */
+#define		kApplePrintingUsePDF		1		/* Default; Run PS through ps2pdf first (requires GhostScript) */
+#define		kApplePrintingUsePS			2		/* Optional, print PS directly to printer (less compatible, requires PS printer) */
 
 /* Define various printing commands */
-#define		kApplePS2PDFLocation	        "/usr/local/bin/ps2pdf"	/* PS -> PDF conversion command (Ghostscript) */
+#define		kApplePCPrintCommand	"/usr/sbin/Print"		/* Mac OS X 10.1 Print Center Printing command */
+#define		kApplePS2PDFLocation	"/usr/local/bin/ps2pdf"	/* PS -> PDF conversion command */
+#define		kApplePCQueueName		"Apple Print Center Default Printer"	/* Name that appears in Print... dialog as the default */
+																/* printer for 10.1 Print Center printing */
 
 /* Prototype for print method discovery function.  Returns
  * a constant defined in printerinfomanager.hxx
@@ -115,16 +119,16 @@ class SystemQueueInfo;
 struct PrinterInfo : JobData
 {
     // basename of PPD
-    ::rtl::OUString             m_aDriverName;
+    rtl::OUString             m_aDriverName;
     // can be the queue
-    ::rtl::OUString             m_aLocation;
+    rtl::OUString             m_aLocation;
     // a user defined comment
-    ::rtl::OUString             m_aComment;
+    rtl::OUString             m_aComment;
     // a command line to pipe a PS-file to
-    ::rtl::OUString             m_aCommand;
+    rtl::OUString             m_aCommand;
     // a list of special features separated by ',' not used by psprint
     // but assigned from the outside (currently only for "fax")
-    ::rtl::OUString             m_aFeatures;
+    rtl::OUString             m_aFeatures;
     // a mapping of fonts to other fonts.
     // this provides a method for the user
     // to replace arbitrary fonts by printer builtin fonts
@@ -135,20 +139,24 @@ struct PrinterInfo : JobData
     // this vector is currently implicitly given by the adobe
     // standard encoding
     bool                        m_bPerformFontSubstitution;
-    ::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >
+    std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >
     m_aFontSubstitutes;
-    ::std::hash_map< fontID, fontID >
+    std::hash_map< fontID, fontID >
     m_aFontSubstitutions;
 };
 
 class PrinterInfoManager
 {
+public:
+    enum Type { Default = 0, CUPS = 1 };
+
+protected:
     // needed for checkPrintersChanged: files (not necessarily existant)
     // and their last known modification time
     struct WatchFile
     {
         // the file in question
-        ::rtl::OUString         m_aFilePath;
+        rtl::OUString         m_aFilePath;
         // the last know modification time or 0, if file did not exist
         TimeValue               m_aModified;
     };
@@ -158,33 +166,35 @@ class PrinterInfoManager
     {
         // configuration file containing this printer
         // empty means a freshly added printer that has to be saved yet
-        ::rtl::OUString         m_aFile;
+        rtl::OUString         m_aFile;
         // details other config files that have this printer
         // in case of removal all have to be removed
-        ::std::list< ::rtl::OUString > m_aAlternateFiles;
+        std::list< rtl::OUString > m_aAlternateFiles;
         // group in m_aFile containing the printer
         // this must be unique over all configuration files
         // it usually should be the printer name
-        ::rtl::OString          m_aGroup;
+        rtl::OString          m_aGroup;
         // whether changes need to be saved
         bool                    m_bModified;
         // the corresponding info and job data
         PrinterInfo             m_aInfo;
     };
 
-    ::std::hash_map< ::rtl::OUString, Printer, ::rtl::OUStringHash > m_aPrinters;
+    std::hash_map< rtl::OUString, Printer, rtl::OUStringHash > m_aPrinters;
     PrinterInfo                         m_aGlobalDefaults;
-    ::std::list< WatchFile >            m_aWatchFiles;
-    ::rtl::OUString                     m_aDefaultPrinter;
-    ::rtl::OUString                     m_aSystemPrintCommand;
-    ::std::list< ::rtl::OUString >      m_aSystemPrintQueues;
+    std::list< WatchFile >            m_aWatchFiles;
+    rtl::OUString                     m_aDefaultPrinter;
+    rtl::OUString                     m_aSystemPrintCommand;
+    std::list< rtl::OUString >      m_aSystemPrintQueues;
 
     SystemQueueInfo*					m_pQueueInfo;
 
-    PrinterInfoManager();
-    ~PrinterInfoManager();
+    Type								m_eType;
+
+    PrinterInfoManager( Type eType = Default );
+    virtual ~PrinterInfoManager();
 
-    void initialize();
+    virtual void initialize();
 
     // fill in font substitutions
     // the resulting hash_map maps from source to target font ids
@@ -194,52 +204,65 @@ public:
     // there can only be one
     static PrinterInfoManager& get();
 
+    // get PrinterInfoManager type
+    Type getType() const { return m_eType; }
+
     // lists the names of all known printers
-    void listPrinters( ::std::list< ::rtl::OUString >& rList ) const;
+    void listPrinters( std::list< rtl::OUString >& rList ) const;
 
     // gets the number of known printers
     int countPrinters() const { return m_aPrinters.size(); }
 
     // gets info about a named printer
-    const PrinterInfo& getPrinterInfo( const ::rtl::OUString& rPrinter ) const;
+    const PrinterInfo& getPrinterInfo( const rtl::OUString& rPrinter ) const;
         
     // gets the name of the default printer
-    const ::rtl::OUString& getDefaultPrinter() const { return m_aDefaultPrinter; }
+    const rtl::OUString& getDefaultPrinter() const { return m_aDefaultPrinter; }
+
+    virtual void setupJobContextData( JobData& rData );
 
     // changes the info about a named printer
-    void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
+    virtual void changePrinterInfo( const rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
 
     // check if the printer configuration has changed
-    bool checkPrintersChanged();
+    virtual bool checkPrintersChanged();
 
     // members for administration (->padmin)
 
     // add a named printer
     // addPrinter fails if a printer with the same name already exists
     // or the driver does not exist
-    bool addPrinter( const ::rtl::OUString& rPrinterName, const ::rtl::OUString& rDriverName );
+    virtual bool addPrinter( const rtl::OUString& rPrinterName, const rtl::OUString& rDriverName );
 
     // remove a named printer
     // this fails if the config file belonging to this printer
     // is not writeable
     // if bCheckOnly is true, the printer is not really removed;
     // this is for checking if the removal would fail
-    bool removePrinter( const ::rtl::OUString& rPrinterName, bool bCheckOnly = false );
+    virtual bool removePrinter( const rtl::OUString& rPrinterName, bool bCheckOnly = false );
 
     // save the changes to all printers. this fails if there
     // is no writable config file at all
-    bool writePrinterConfig();
+    virtual bool writePrinterConfig();
 
     // set a new default printer
     // fails if the specified printer does not exist
-    bool setDefaultPrinter( const ::rtl::OUString& rPrinterName );
+    virtual bool setDefaultPrinter( const rtl::OUString& rPrinterName );
 
     // primarily used internally but also by padmin
     // returns the printer queue names
-    const ::std::list< ::rtl::OUString >& getSystemPrintQueues();
+    virtual const std::list< rtl::OUString >& getSystemPrintQueues();
         
     // similar but returnse whole commandlines
-    void getSystemPrintCommands( ::std::list< ::rtl::OUString >& rCommands );
+    virtual void getSystemPrintCommands( std::list< rtl::OUString >& rCommands );
+
+    // abstract print command
+    // returns a stdio FILE* that a postscript file may be written to
+    // this may either be a regular file or the result of popen()
+    virtual FILE* startSpool( const rtl::OUString& rPrinterName );
+    // close the FILE* returned by startSpool and does the actual spooling
+    // returns a numerical job id
+    virtual int endSpool( const rtl::OUString& rPrinterName, const rtl::OUString& rJobTitle, FILE* pFile );
 };
     
 } // namespace
Index: psprint/inc/psprint/printerjob.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/printerjob.hxx,v
retrieving revision 1.4.44.1
retrieving revision 1.7
diff -u -p -u -r1.4.44.1 -r1.7
--- psprint/inc/psprint/printerjob.hxx	28 Jan 2004 11:22:11 -0000	1.4.44.1
+++ psprint/inc/psprint/printerjob.hxx	30 Mar 2004 13:47:13 -0000	1.7
@@ -87,8 +87,8 @@ private:            // private data
 
     rtl::OUString           maSpoolDirName;
     rtl::OUString           maFileName; // empty: spool to command, else spool to named file
-    int                     mnFileMode;
-    rtl::OUString           maJobName;
+    rtl::OUString			maJobTitle;
+    int						mnFileMode;
 
     osl::File*              mpJobHeader;
     osl::File*              mpJobTrailer;
@@ -126,7 +126,8 @@ private:            // private methods
     bool			writeFeatureList( osl::File* pFile, const JobData&, bool bDocumentSetup );
     bool            writeSetup( osl::File* pFile, const JobData& );
     bool            writePageSetup( osl::File* pFile, const JobData& );
-    bool            writeProlog (osl::File* pFile);
+    void			writeJobPatch( osl::File* File, const JobData& );
+    bool            writeProlog (osl::File* pFile, const JobData& );
 
 public:             // for usage in PrinterGfx
             
Index: psprint/prj/build.lst
===================================================================
RCS file: /cvs/gsl/psprint/prj/build.lst,v
retrieving revision 1.4
retrieving revision 1.6
diff -u -p -u -r1.4 -r1.6
--- psprint/prj/build.lst	26 Mar 2003 14:24:03 -0000	1.4
+++ psprint/prj/build.lst	1 Jun 2004 13:59:39 -0000	1.6
@@ -1,4 +1,4 @@
-pp	psprint	:	tools unotools cpputools jvmaccess NULL
+pp	psprint	:	tools unotools cpputools jvmaccess print_header jvmfwk NULL
 pp	psprint									usr1	-	all	pp_mkout NULL
 pp	psprint\source\fontsubset				nmake	-	all	pp_fontsset NULL
 pp	psprint\source\printer					nmake	-	u	pp_printer NULL
Index: psprint/source/fontmanager/fontcache.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/fontcache.cxx,v
retrieving revision 1.8.26.1
retrieving revision 1.10
diff -u -p -u -r1.8.26.1 -r1.10
--- psprint/source/fontmanager/fontcache.cxx	15 Jan 2004 12:57:38 -0000	1.8.26.1
+++ psprint/source/fontmanager/fontcache.cxx	17 Mar 2004 10:48:54 -0000	1.10
@@ -259,6 +259,7 @@ void FontCache::flush()
                         aLine.Append( ';' );
                         aLine.Append( ByteString::CreateFromInt32( static_cast<const PrintFontManager::TrueTypeFontFile*>(*it)->m_nTypeFlags ) );
                         break;
+                    default: break;
                 }
                 aStream.WriteLine( aLine );
             }
@@ -375,6 +376,7 @@ void FontCache::read()
                     case fonttype::Builtin:
                         pFont = new PrintFontManager::BuiltinFont();
                         break;
+                    default: break;
                 }
                 nIndex = 0;
                 
@@ -444,6 +446,7 @@ void FontCache::read()
                         static_cast<PrintFontManager::BuiltinFont*>(pFont)->m_nDirectory = nDir;
                         static_cast<PrintFontManager::BuiltinFont*>(pFont)->m_aMetricFile = aFile;
                         break;
+                    default: break;
                 }
 
                 /*
@@ -523,6 +526,7 @@ void FontCache::copyPrintFont( const Pri
             static_cast<PrintFontManager::BuiltinFont*>(pTo)->m_nDirectory = static_cast<const PrintFontManager::BuiltinFont*>(pFrom)->m_nDirectory;
             static_cast<PrintFontManager::BuiltinFont*>(pTo)->m_aMetricFile = static_cast<const PrintFontManager::BuiltinFont*>(pFrom)->m_aMetricFile;
             break;
+        default: break;
     }
     pTo->m_nFamilyName		= pFrom->m_nFamilyName;
     pTo->m_aAliases			= pFrom->m_aAliases;
@@ -561,6 +565,7 @@ PrintFontManager::PrintFont* FontCache::
         case fonttype::Builtin:
             pFont = new PrintFontManager::BuiltinFont();
             break;
+        default: break;
     }
     if( pFont )
     {
Index: psprint/source/fontmanager/fontconfig.cxx
===================================================================
RCS file: psprint/source/fontmanager/fontconfig.cxx
diff -N psprint/source/fontmanager/fontconfig.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ psprint/source/fontmanager/fontconfig.cxx	1 Jun 2004 09:35:26 -0000	1.4
@@ -0,0 +1,412 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifdef ENABLE_FONTCONFIG
+#include <fontconfig/fontconfig.h>
+#else
+typedef void FcConfig;
+typedef void FcObjectSet;
+typedef void FcPattern;
+typedef void FcFontSet;
+typedef int FcResult;
+typedef int FcBool;
+typedef char FcChar8;
+
+#endif
+
+#include <cstdio>
+#include <cstdarg>
+
+#ifndef _PSPRINT_FONTMANAGER_HXX_
+#include <psprint/fontmanager.hxx>
+#endif
+#ifndef _PSPRINT_FONTCACHE_HXX_
+#include <psprint/fontcache.hxx>
+#endif
+#ifndef _UTL_ATOM_HXX_
+#include <unotools/atom.hxx>
+#endif
+#ifndef _OSL_MODULE_H
+#include <osl/module.h>
+#endif
+#ifndef _OSL_THREAD_H
+#include <osl/thread.h>
+#endif
+
+using namespace psp;
+using namespace osl;
+using namespace rtl;
+
+class FontCfgWrapper
+{
+    void*			m_pLib;
+
+    FcConfig*		(*m_pFcInitLoadConfigAndFonts)();
+    FcObjectSet*	(*m_pFcObjectSetVaBuild)(const char*,va_list);
+    void			(*m_pFcObjectSetDestroy)(FcObjectSet* pSet);
+    FcPattern*		(*m_pFcPatternCreate)();
+    void			(*m_pFcPatternDestroy)(FcPattern*);
+    FcFontSet*		(*m_pFcFontList)(FcConfig*,FcPattern*,FcObjectSet*);
+    void			(*m_pFcFontSetDestroy)(FcFontSet*);
+    FcResult		(*m_pFcPatternGetString)(const FcPattern*,const char*,int,FcChar8**);
+    FcResult		(*m_pFcPatternGetInteger)(const FcPattern*,const char*,int,int*);
+    FcResult		(*m_pFcPatternGetDouble)(const FcPattern*,const char*,int,double*);
+    FcResult		(*m_pFcPatternGetBool)(const FcPattern*,const char*,int,FcBool*);
+    
+    void* loadSymbol( const char* );
+public:
+    FontCfgWrapper();
+    ~FontCfgWrapper();
+
+    bool isValid() const 
+    { return m_pLib != NULL;}
+
+    FcConfig* FcInitLoadConfigAndFonts()
+    { return m_pFcInitLoadConfigAndFonts(); }
+
+    FcObjectSet* FcObjectSetBuild( const char* first, ... )
+    {
+        va_list ap;
+        va_start( ap, first );
+        FcObjectSet* pSet = m_pFcObjectSetVaBuild( first, ap );
+        va_end( ap );
+        return pSet;
+    }
+
+    void FcObjectSetDestroy( FcObjectSet* pSet )
+    { m_pFcObjectSetDestroy( pSet ); }
+    
+    FcPattern* FcPatternCreate()
+    { return m_pFcPatternCreate(); }
+
+    void FcPatternDestroy( FcPattern* pPattern )
+    { m_pFcPatternDestroy( pPattern ); }
+    
+    FcFontSet* FcFontList( FcConfig* pConfig, FcPattern* pPattern, FcObjectSet* pSet )
+    { return m_pFcFontList( pConfig, pPattern, pSet ); }
+    
+    void FcFontSetDestroy( FcFontSet* pSet )
+    { m_pFcFontSetDestroy( pSet );}
+
+    FcResult FcPatternGetString( const FcPattern* pPattern, const char* object, int n, FcChar8** s )
+    { return m_pFcPatternGetString( pPattern, object, n, s ); }
+
+    FcResult FcPatternGetInteger( const FcPattern* pPattern, const char* object, int n, int* s )
+    { return m_pFcPatternGetInteger( pPattern, object, n, s ); }
+
+    FcResult FcPatternGetDouble( const FcPattern* pPattern, const char* object, int n, double* s )
+    { return m_pFcPatternGetDouble( pPattern, object, n, s ); }
+
+    FcResult FcPatternGetBool( const FcPattern* pPattern, const char* object, int n, FcBool* s )
+    { return m_pFcPatternGetBool( pPattern, object, n, s ); }
+};
+
+void* FontCfgWrapper::loadSymbol( const char* pSymbol )
+{
+    OUString aSym( OUString::createFromAscii( pSymbol ) );
+    void* pSym = osl_getSymbol( m_pLib, aSym.pData );
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "%s %s\n", pSymbol, pSym ? "found" : "not found" );
+#endif
+    return pSym;
+}
+
+FontCfgWrapper::FontCfgWrapper()
+        : m_pLib( NULL )
+{
+#ifdef ENABLE_FONTCONFIG
+    OUString aLib( RTL_CONSTASCII_USTRINGPARAM( "libfontconfig.so.1" ) );
+    m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( !m_pLib )
+    {
+        aLib = OUString( RTL_CONSTASCII_USTRINGPARAM( "libfontconfig.so" ) );
+        m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    }
+#endif
+
+    if( ! m_pLib )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "no libfontconfig\n" );
+#endif
+        return;
+    }
+
+    m_pFcInitLoadConfigAndFonts = (FcConfig*(*)())
+        loadSymbol( "FcInitLoadConfigAndFonts" );
+    m_pFcObjectSetVaBuild = (FcObjectSet*(*)(const char*,va_list))
+        loadSymbol( "FcObjectSetVaBuild" );
+    m_pFcObjectSetDestroy = (void(*)(FcObjectSet*))
+        loadSymbol( "FcObjectSetDestroy" );
+    m_pFcPatternCreate = (FcPattern*(*)())
+        loadSymbol( "FcPatternCreate" );
+    m_pFcPatternDestroy = (void(*)(FcPattern*))
+        loadSymbol( "FcPatternDestroy" );
+    m_pFcFontList = (FcFontSet*(*)(FcConfig*,FcPattern*,FcObjectSet*))
+        loadSymbol( "FcFontList" );
+    m_pFcFontSetDestroy = (void(*)(FcFontSet*))
+        loadSymbol( "FcFontSetDestroy" );
+    m_pFcPatternGetString = (FcResult(*)(const FcPattern*,const char*,int,FcChar8**))
+        loadSymbol( "FcPatternGetString" );
+    m_pFcPatternGetInteger = (FcResult(*)(const FcPattern*,const char*,int,int*))
+        loadSymbol( "FcPatternGetInteger" );
+    m_pFcPatternGetDouble = (FcResult(*)(const FcPattern*,const char*,int,double*))
+        loadSymbol( "FcPatternGetDouble" );
+    m_pFcPatternGetBool = (FcResult(*)(const FcPattern*,const char*,int,FcBool*))
+        loadSymbol( "FcPatternGetBool" );
+
+    if( ! (
+            m_pFcInitLoadConfigAndFonts		&&
+            m_pFcObjectSetVaBuild			&&
+            m_pFcObjectSetDestroy			&&
+            m_pFcPatternCreate				&&
+            m_pFcPatternDestroy				&&
+            m_pFcFontList					&&
+            m_pFcFontSetDestroy				&&
+            m_pFcPatternGetString			&&
+            m_pFcPatternGetInteger			&&
+            m_pFcPatternGetDouble			&&
+            m_pFcPatternGetBool
+            ) )
+     {
+         osl_unloadModule( m_pLib );
+         m_pLib = NULL;
+#if OSL_DEBUG_LEVEL > 1
+         fprintf( stderr, "not all needed symbols were found in libfontconfig\n" );
+#endif
+     }
+}
+
+FontCfgWrapper::~FontCfgWrapper()
+{
+    if( m_pLib )
+        osl_unloadModule( m_pLib );
+}
+
+/*
+ * PrintFontManager::initFontconfig
+ */
+bool PrintFontManager::initFontconfig()
+{
+    int nFonts = 0;
+
+#ifdef ENABLE_FONTCONFIG    
+    FontCfgWrapper aWrapper;
+    if( ! aWrapper.isValid() )
+        return false;
+
+    FcConfig* pConfig = aWrapper.FcInitLoadConfigAndFonts();
+    if( ! pConfig )
+        return false;
+
+    FcObjectSet* pOSet = aWrapper.FcObjectSetBuild( FC_FAMILY,
+                                                    FC_STYLE,
+                                                    FC_SLANT,
+                                                    FC_WEIGHT,
+                                                    FC_SPACING,
+                                                    FC_FILE,
+                                                    FC_OUTLINE,
+                                                    NULL );
+    FcPattern* pPattern = aWrapper.FcPatternCreate();
+    FcFontSet* pFSet = aWrapper.FcFontList( pConfig, pPattern, pOSet );
+
+    if( pFSet )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "found %d entries in fontconfig fontset\n", pFSet->nfont );
+#endif
+        for( int i = 0; i < pFSet->nfont; i++ )
+        {
+            FcChar8* file = NULL;
+            FcChar8* family = NULL;
+            FcChar8* style = NULL;
+            int slant = 0;
+            int weight = 0;
+            int spacing = 0;
+            FcBool outline = false;
+            
+            FcResult eFileRes	= aWrapper.FcPatternGetString( pFSet->fonts[i], FC_FILE, 0, &file );
+            FcResult eFamilyRes	= aWrapper.FcPatternGetString( pFSet->fonts[i], FC_FAMILY, 0, &family );
+            FcResult eStyleRes	= aWrapper.FcPatternGetString( pFSet->fonts[i], FC_STYLE, 0, &style );
+            FcResult eSlantRes	= aWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_SLANT, 0, &slant );
+            FcResult eWeightRes	= aWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_WEIGHT, 0, &weight );
+            FcResult eSpacRes	= aWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_SPACING, 0, &spacing );
+            FcResult eOutRes	= aWrapper.FcPatternGetBool( pFSet->fonts[i], FC_OUTLINE, 0, &outline );
+            
+            
+            if( eFileRes != FcResultMatch || eFamilyRes != FcResultMatch || eOutRes != FcResultMatch )
+                continue;
+
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "found font \"%s\" in file %s\n"
+                     "   weight = %d, slant = %d, style = \"%s\"\n"
+                     "   spacing = %d, outline = %d\n"
+                     , family, file
+                     , eWeightRes == FcResultMatch ? weight : -1
+                     , eSpacRes == FcResultMatch ? slant : -1
+                     , eStyleRes == FcResultMatch ? (const char*) style : "<nil>"
+                     , eSpacRes == FcResultMatch ? spacing : -1
+                     , eOutRes == FcResultMatch ? outline : -1
+                     );
+#endif
+
+            // only outline fonts are usable to psprint anyway
+            if( eOutRes == FcResultMatch && ! outline )
+                continue;
+
+            // see if this font is already cached
+            // update attributes
+            std::list< PrintFont* > aFonts;
+            OString aDir, aBase, aOrgPath( (sal_Char*)file );
+            splitPath( aOrgPath, aDir, aBase );
+            int nDirID = getDirectoryAtom( aDir, true );
+            if( ! m_pFontCache->getFontCacheFile( nDirID, aDir, aBase, aFonts ) )
+            {
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr, "file %s not cached\n", aBase.getStr() );
+#endif
+                // not known, analyze font file to get attributes
+                // not described by fontconfig (e.g. alias names, PSName)
+                std::list< OString > aDummy;
+                analyzeFontFile( nDirID, aBase, true, aDummy, aFonts );
+            }
+#if OSL_DEBUG_LEVEL > 1
+            if( aFonts.size() > 1 )
+                fprintf( stderr, "Warning: file contains more than one font, updating all to fontconfig data\n" );
+            else if( aFonts.empty() )
+                fprintf( stderr, "Warning: file is unusable to psprint\n" );
+#endif
+            int nFamilyName = m_pAtoms->getAtom( ATOM_FAMILYNAME, OStringToOUString( OString( (sal_Char*)family ), osl_getThreadTextEncoding() ), sal_True );
+            
+            for( std::list< PrintFont* >::iterator it = aFonts.begin();
+                 it != aFonts.end(); ++it )
+            {
+                // set family name
+                if( (*it)->m_nFamilyName != nFamilyName )
+                {
+                    (*it)->m_aAliases.remove( (*it)->m_nFamilyName );
+                    (*it)->m_aAliases.push_back( (*it)->m_nFamilyName );
+                    (*it)->m_aAliases.remove( nFamilyName );
+                    (*it)->m_nFamilyName = nFamilyName;
+                }
+                if( eWeightRes == FcResultMatch )
+                {
+                    // set weight
+                    if( weight == FC_WEIGHT_LIGHT )
+                        (*it)->m_eWeight = weight::Light;
+                    else if( weight == FC_WEIGHT_MEDIUM )
+                        (*it)->m_eWeight = weight::Medium;
+                    else if( weight == FC_WEIGHT_DEMIBOLD )
+                        (*it)->m_eWeight = weight::SemiBold;
+                    else if( weight == FC_WEIGHT_BOLD )
+                        (*it)->m_eWeight = weight::Bold;
+                    else if( weight == FC_WEIGHT_BLACK )
+                        (*it)->m_eWeight = weight::Black;
+                }
+                if( eSpacRes == FcResultMatch )
+                {
+                    // set pitch
+                    if( spacing == FC_PROPORTIONAL )
+                        (*it)->m_ePitch = pitch::Variable;
+                    else if( spacing == FC_MONO || spacing == FC_CHARCELL )
+                        (*it)->m_ePitch = pitch::Fixed;
+                }
+                if( eSlantRes == FcResultMatch )
+                {
+                    // set italic
+                    if( slant == FC_SLANT_ROMAN )
+                        (*it)->m_eItalic = italic::Upright;
+                    else if( slant == FC_SLANT_ITALIC )
+                        (*it)->m_eItalic = italic::Italic;
+                    else if( slant == FC_SLANT_OBLIQUE )
+                        (*it)->m_eItalic = italic::Oblique;
+                }
+                
+                // update font cache
+                m_pFontCache->updateFontCacheEntry( *it, false );
+                // sort into known fonts
+                fontID aFont = m_nNextFontID++;
+                m_aFonts[ aFont ] = *it;
+                m_aFontFileToFontID[ aBase ].insert( aFont );
+                nFonts++;
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr, "inserted font %s as fontID %d\n", family, aFont );
+#endif
+            }
+        }
+    }
+    
+    
+    // cleanup
+    if( pPattern )
+        aWrapper.FcPatternDestroy( pPattern );
+    if( pFSet )
+        aWrapper.FcFontSetDestroy( pFSet );
+    if( pOSet )
+        aWrapper.FcObjectSetDestroy( pOSet );
+    
+    // how does one get rid of the config ?
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "inserted %d fonts from fontconfig\n", nFonts );
+#endif
+#endif // ENABLE_FONTCONFIG
+    return nFonts != 0;
+}
Index: psprint/source/fontmanager/fontmanager.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/fontmanager.cxx,v
retrieving revision 1.39.20.5
retrieving revision 1.50
diff -u -p -u -r1.39.20.5 -r1.50
--- psprint/source/fontmanager/fontmanager.cxx	15 Apr 2004 14:28:22 -0000	1.39.20.5
+++ psprint/source/fontmanager/fontmanager.cxx	17 Jun 2004 13:51:09 -0000	1.50
@@ -534,12 +534,12 @@ bool PrintFontManager::TrueTypeFontFile:
 
 
                 KernPair aPair;
-                for( i = 0; i < pImplTTFont->nkern; i++ )
+                for( i = 0; i < (int)pImplTTFont->nkern; i++ )
                 {
                     const sal_uInt8* pTable = pImplTTFont->kerntables[i];
 
-                    sal_uInt16 nVersion     = getUInt16BE( pTable );
-                    sal_uInt16 nLength      = getUInt16BE( pTable );
+                    /*sal_uInt16 nVersion     =*/ getUInt16BE( pTable );
+                    /*sal_uInt16 nLength      =*/ getUInt16BE( pTable );
                     sal_uInt16 nCoverage    = getUInt16BE( pTable );
 
                     aPair.kern_x    = 0;
@@ -701,10 +701,10 @@ bool PrintFontManager::TrueTypeFontFile:
                         case 2:
                         {
                             const sal_uInt8* pSubTable = pTable;
-                            sal_uInt16 nRowWidth    = getUInt16BE( pTable );
+                            /*sal_uInt16 nRowWidth    =*/ getUInt16BE( pTable );
                             sal_uInt16 nOfLeft      = getUInt16BE( pTable );
                             sal_uInt16 nOfRight     = getUInt16BE( pTable );
-                            sal_uInt16 nOfArray     = getUInt16BE( pTable );
+                            /*sal_uInt16 nOfArray     =*/ getUInt16BE( pTable );
                             const sal_uInt8* pTmp = pSubTable + nOfLeft;
                             sal_uInt16 nFirstLeft   = getUInt16BE( pTmp );
                             sal_uInt16 nLastLeft    = getUInt16BE( pTmp ) + nFirstLeft - 1;
@@ -712,7 +712,6 @@ bool PrintFontManager::TrueTypeFontFile:
                             sal_uInt16 nFirstRight  = getUInt16BE( pTmp );
                             sal_uInt16 nLastRight   = getUInt16BE( pTmp ) + nFirstRight -1;
 
-                            int nPairs = (int)(nLastLeft-nFirstLeft+1)*(int)(nLastRight-nFirstRight+1);
                             for( aPair.first = nFirstLeft; aPair.first < nLastLeft; aPair.first++ )
                             {
                                 for( aPair.second = 0; aPair.second < nLastRight; aPair.second++ )
@@ -766,7 +765,7 @@ bool PrintFontManager::PrintFont::readAf
     if( ! fp )
         return false;
     FontInfo* pInfo = NULL;
-    int nResult = parseFile( fp, &pInfo, P_ALL );
+    parseFile( fp, &pInfo, P_ALL );
     fclose( fp );
     if( ! pInfo || ! pInfo->numOfChars )
     {
@@ -854,7 +853,7 @@ bool PrintFontManager::PrintFont::readAf
                 RTL_TEXTENCODING_JIS_X_0208
             };
 
-        for( int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
+        for( unsigned int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
         {
             sal_Int32 nIndex = 0, nOffset = 1;
             do
@@ -1125,12 +1124,12 @@ PrintFontManager& PrintFontManager::get(
  */
 
 PrintFontManager::PrintFontManager() :
-        m_pAtoms( new MultiAtomProvider() ),
         m_nNextFontID( 1 ),
+        m_pAtoms( new MultiAtomProvider() ),
         m_nNextDirAtom( 1 ),
         m_pFontCache( NULL )
 {
-    for( int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
+    for( unsigned int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
     {
         m_aUnicodeToAdobename.insert( ::std::hash_multimap< sal_Unicode, ::rtl::OString >::value_type( aAdobeCodes[i].aUnicode, aAdobeCodes[i].pAdobename ) );
         m_aAdobenameToUnicode.insert( ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::value_type( aAdobeCodes[i].pAdobename, aAdobeCodes[i].aUnicode ) );
@@ -1221,7 +1220,6 @@ int PrintFontManager::addFontFile( const
 bool PrintFontManager::analyzeFontFile( int nDirID, const OString& rFontFile, bool bReadFile, const ::std::list<OString>& rXLFDs, ::std::list< PrintFontManager::PrintFont* >& rNewFonts ) const
 {
     rNewFonts.clear();
-    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
 
     OString aDir( getDirectory( nDirID ) );
 
@@ -1301,7 +1299,8 @@ bool PrintFontManager::analyzeFontFile( 
         else
             delete pFont;
     }
-    else if( aExt.EqualsIgnoreCaseAscii( "ttf" ) )
+    else if( aExt.EqualsIgnoreCaseAscii( "ttf" )
+         ||  aExt.EqualsIgnoreCaseAscii( "otf" ) ) // #112957# allow GLYF-OTF
     {
         TrueTypeFontFile* pFont     = new TrueTypeFontFile();
         pFont->m_nDirectory         = nDirID;
@@ -1585,6 +1584,19 @@ void PrintFontManager::getFontAttributes
     // handle iso8859-1 as ms1252 to fill the "gap" starting at 0x80
     if( pFont->m_aEncoding == RTL_TEXTENCODING_ISO_8859_1 )
         pFont->m_aEncoding = RTL_TEXTENCODING_MS_1252;
+    if( rXLFDs.begin() != rXLFDs.end() )
+    {
+        switch( pFont->m_eType )
+        {
+            case fonttype::Type1:
+                static_cast<Type1FontFile*>(pFont)->m_aXLFD = rXLFDs.front();
+                break;
+            case fonttype::TrueType:
+                static_cast<TrueTypeFontFile*>(pFont)->m_aXLFD = rXLFDs.front();
+                break;
+            default: break;
+        }
+    }
 }
 
 // -------------------------------------------------------------------------
@@ -1621,6 +1633,7 @@ ByteString PrintFontManager::getXLFD( Pr
         case weight::Bold:              aXLFD += "bold";break;
         case weight::UltraBold:     aXLFD += "ultrabold";break;
         case weight::Black:         aXLFD += "black";break;
+        default: break;
     }
     aXLFD += '-';
     switch( pFont->m_eItalic )
@@ -1628,6 +1641,7 @@ ByteString PrintFontManager::getXLFD( Pr
         case italic::Upright:           aXLFD += 'r';break;
         case italic::Oblique:           aXLFD += 'o';break;
         case italic::Italic:            aXLFD += 'i';break;
+        default: break;
     }
     aXLFD += '-';
     switch( pFont->m_eWidth )
@@ -1641,6 +1655,7 @@ ByteString PrintFontManager::getXLFD( Pr
         case width::Expanded:           aXLFD += "expanded";break;
         case width::ExtraExpanded:      aXLFD += "extraexpanded";break;
         case width::UltraExpanded:      aXLFD += "ultraexpanded";break;
+        default: break;
     }
     aXLFD += "-utf8-0-0-0-0-";
     aXLFD += pFont->m_ePitch == pitch::Fixed ? "m" : "p";
@@ -1922,22 +1937,6 @@ bool PrintFontManager::analyzeTrueTypeFi
 
 // -------------------------------------------------------------------------
 
-static void normPath( ByteString& rPath )
-{
-    char buf[PATH_MAX];
-
-    // double slashes and slash at end are probably
-    // removed by realpath anyway, but since this runs
-    // on many different platforms let's play it safe
-    while( rPath.SearchAndReplace( "//", "/" ) != STRING_NOTFOUND )
-        ;
-    if( rPath.Len() > 0 && rPath.GetChar( rPath.Len()-1 ) == '/' )
-        rPath.Erase( rPath.Len()-1 );
-
-    if( realpath( rPath.GetBuffer(), buf ) )
-        rPath = buf;
-}
-
 void PrintFontManager::getServerDirectories()
 {
 #ifdef LINUX
@@ -1949,7 +1948,7 @@ void PrintFontManager::getServerDirector
     };
     ::std::list< ByteString > aLines;
 
-    for( int i = 0; i < sizeof(pCommands)/sizeof(pCommands[0]); i++ )
+    for( unsigned int i = 0; i < sizeof(pCommands)/sizeof(pCommands[0]); i++ )
     {
         FILE* pPipe = popen( pCommands[i], "r" );
         aLines.clear();
@@ -2065,6 +2064,9 @@ void PrintFontManager::initialize( void*
     aStart = times( &tms );
 #endif
 
+    // first try fontconfig
+    bool bFontconfigSuccess = initFontconfig();
+
     // part one - look for downloadable fonts
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
     const ::rtl::OUString &rSalPrivatePath = psp::getFontPath();
@@ -2073,91 +2075,97 @@ void PrintFontManager::initialize( void*
     // the TrueType fonts installed with the office
     if( rSalPrivatePath.getLength() )
     {
-        ByteString aPath = ::rtl::OUStringToOString( rSalPrivatePath, aEncoding );
-        int nTokens = aPath.GetTokenCount( ';' );
-        for( int i = 0; i < nTokens; i++ )
+        OString aPath = rtl::OUStringToOString( rSalPrivatePath, aEncoding );
+        sal_Int32 nIndex = 0;
+        do
         {
-            ByteString aToken( aPath.GetToken( i, ';' ) );
+            OString aToken = aPath.getToken( 0, ';', nIndex );
             normPath( aToken );
             m_aFontDirectories.push_back( aToken );
             m_aPrivateFontDirectories.push_back( getDirectoryAtom( aToken, true ) );
-        }
+        } while( nIndex >= 0 );
     }
 
-    Display *pDisplay = (Display*)pInitDisplay;
-
-    if( ! pDisplay )
+    // don't search through many directories fontconfig already told us about
+    if( ! bFontconfigSuccess )
+    {							
+        Display *pDisplay = (Display*)pInitDisplay;
+        
+        if( ! pDisplay )
         pDisplay = XOpenDisplay( NULL );
-
-    if( pDisplay )
-    {
-        // get font paths to look for fonts
-        int nPaths = 0, i;
-        char** pPaths = XGetFontPath( pDisplay, &nPaths );
         
-        int nPos = 0;
-        bool bServerDirs = false;
-        for( i = 0; i < nPaths; i++ )
-        {
-            ByteString aPath( pPaths[i] );
-            if( ! bServerDirs
-                && ( nPos = aPath.Search( ':' ) ) != STRING_NOTFOUND
-                && ( !aPath.Equals( ":unscaled", nPos, 9 ) ) )
-            {
-                bServerDirs = true;
-                getServerDirectories();
-            }
-            else
+        if( pDisplay )
+        {
+            // get font paths to look for fonts
+            int nPaths = 0, i;
+            char** pPaths = XGetFontPath( pDisplay, &nPaths );
+            
+            bool bServerDirs = false;
+            for( i = 0; i < nPaths; i++ )
             {
-                normPath( aPath );
-                m_aFontDirectories.push_back( aPath );
+                OString aPath( pPaths[i] );
+                sal_Int32 nPos = 0;
+                if( ! bServerDirs
+                    && ( nPos = aPath.indexOf( ':' ) ) > 0
+                    && ( !aPath.copy(nPos).equals( ":unscaled" ) ) )
+                {
+                    bServerDirs = true;
+                    getServerDirectories();
+                }
+                else
+                {
+                    normPath( aPath );
+                    m_aFontDirectories.push_back( aPath );
+                }
             }
+            
+            if( nPaths )
+                XFreeFontPath( pPaths );
+            
+            if( ! pInitDisplay )
+                XCloseDisplay( pDisplay );
         }
 
-        if( nPaths )
-            XFreeFontPath( pPaths );
-
-        if( ! pInitDisplay )
-            XCloseDisplay( pDisplay );
-    }
-
-    // insert some standard directories
-    m_aFontDirectories.push_back( "/usr/openwin/lib/X11/fonts/TrueType" );
-    m_aFontDirectories.push_back( "/usr/openwin/lib/X11/fonts/Type1" );
-    m_aFontDirectories.push_back( "/usr/openwin/lib/X11/fonts/Type1/sun" );
-    m_aFontDirectories.push_back( "/usr/X11R6/lib/X11/fonts/truetype" );
-    m_aFontDirectories.push_back( "/usr/X11R6/lib/X11/fonts/Type1" );
+        // insert some standard directories
+        m_aFontDirectories.push_back( "/usr/openwin/lib/X11/fonts/TrueType" );
+        m_aFontDirectories.push_back( "/usr/openwin/lib/X11/fonts/Type1" );
+        m_aFontDirectories.push_back( "/usr/openwin/lib/X11/fonts/Type1/sun" );
+        m_aFontDirectories.push_back( "/usr/X11R6/lib/X11/fonts/truetype" );
+        m_aFontDirectories.push_back( "/usr/X11R6/lib/X11/fonts/Type1" );
     
 #ifdef SOLARIS
-    /* cde specials, from /usr/dt/bin/Xsession: here are the good fonts,
-       the OWfontpath file may contain as well multiple lines as a comma
-       separated list of fonts in each line. to make it even more weird
-       environment variables are allowed as well */
-
-    const char* lang = getenv("LANG");
-    if ( lang != NULL )
-    {
-        String aOpenWinDir( String::CreateFromAscii( "/usr/openwin/lib/locale/" ) );
-        aOpenWinDir.AppendAscii( lang );
-        aOpenWinDir.AppendAscii( "/OWfontpath" );
-
-        SvFileStream aStream( aOpenWinDir, STREAM_READ );
-
-        // TODO: replace environment variables
-        while( aStream.IsOpen() && ! aStream.IsEof() )
+        /* cde specials, from /usr/dt/bin/Xsession: here are the good fonts,
+           the OWfontpath file may contain as well multiple lines as a comma
+           separated list of fonts in each line. to make it even more weird
+           environment variables are allowed as well */
+        
+        const char* lang = getenv("LANG");
+        if ( lang != NULL )
         {
-            ByteString aLine;
-            aStream.ReadLine( aLine );
-            normPath( aLine );
-            // try to avoid bad fonts in some cases
-            static bool bAvoid = (strncasecmp( lang, "ar", 2 ) == 0) || (strncasecmp( lang, "he", 2 ) == 0) || (strncasecmp( lang, "hi", 2 ) == 0);
-            if( bAvoid && aLine.Search( "iso_8859" ) != STRING_NOTFOUND )
-                continue;
-            m_aFontDirectories.push_back( aLine );
+            String aOpenWinDir( String::CreateFromAscii( "/usr/openwin/lib/locale/" ) );
+            aOpenWinDir.AppendAscii( lang );
+            aOpenWinDir.AppendAscii( "/OWfontpath" );
+            
+            SvFileStream aStream( aOpenWinDir, STREAM_READ );
+            
+            // TODO: replace environment variables
+            while( aStream.IsOpen() && ! aStream.IsEof() )
+            {
+                ByteString aLine;
+                aStream.ReadLine( aLine );
+                // need an OString for normpath
+                OString aNLine( aLine );
+                normPath( aNLine );
+                aLine = aNLine;
+                // try to avoid bad fonts in some cases
+                static bool bAvoid = (strncasecmp( lang, "ar", 2 ) == 0) || (strncasecmp( lang, "iw", 2 ) == 0) || (strncasecmp( lang, "hi", 2 ) == 0);
+                if( bAvoid && aLine.Search( "iso_8859" ) != STRING_NOTFOUND )
+                    continue;
+                m_aFontDirectories.push_back( aLine );
+            }
         }
-    }
-
 #endif /* SOLARIS */
+    } // ! bFontconfigSuccess
 
     // fill XLFD aliases from fonts.alias files
     initFontsAlias();
@@ -2753,6 +2761,7 @@ OString PrintFontManager::getAfmFile( Pr
                 aMetricPath += pBuiltinFont->m_aMetricFile;
             }
             break;
+            default: break;
         }
     }
     return aMetricPath;
@@ -3069,7 +3078,7 @@ int PrintFontManager::importFonts( const
     // find a directory with write access
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
     SvFileStream aFontsDir;
-    int nDirID;
+    int nDirID = 0;
     INetURLObject aDir;
     for( ::std::list< int >::const_iterator dir_it = m_aPrivateFontDirectories.begin();
          ! ( aFontsDir.IsOpen() && aFontsDir.IsWritable() ) && dir_it != m_aPrivateFontDirectories.end(); ++dir_it )
@@ -3211,6 +3220,7 @@ int PrintFontManager::importFonts( const
                             if( static_cast<TrueTypeFontFile*>(current->second)->m_aFontFile == aFileName )
                                 bRemove = true;
                             break;
+                        default: break;
                     }
                     if( bRemove )
                     {
@@ -3338,6 +3348,7 @@ bool PrintFontManager::checkChangeFontPr
             case fonttype::TrueType:
                 aFontsDirPath = getDirectory( static_cast< TrueTypeFontFile* >(pFont)->m_nDirectory );
                 break;
+            default: break;
         }
         if( aFontsDirPath.getLength() )
         {
@@ -3378,6 +3389,7 @@ bool PrintFontManager::changeFontPropert
             aFontFile = static_cast< TrueTypeFontFile* >(pFont)->m_aFontFile;
             nTTCnumber = static_cast< TrueTypeFontFile* >(pFont)->m_nCollectionEntry;
             break;
+        default: break;
     }
     OUString aUniPath, aFDPath;
 	FileBase::getFileURLFromSystemPath( OStringToOUString( aFontsDirPath, aEncoding ), aUniPath );
@@ -3605,6 +3617,7 @@ bool PrintFontManager::isPrivateFontFile
         {
             case fonttype::Type1: nDirID = static_cast< Type1FontFile* >(pFont)->m_nDirectory;break;
             case fonttype::TrueType: nDirID = static_cast< TrueTypeFontFile* >(pFont)->m_nDirectory;break;
+            default: break;
         }
     }
     if( nDirID != -1 )
@@ -3665,7 +3678,7 @@ bool PrintFontManager::getAlternativeFam
 bool PrintFontManager::createFontSubset(
                                         fontID nFont,
                                         const OUString& rOutFile,
-                                        long* pGlyphIDs,
+                                        sal_Int32* pGlyphIDs,
                                         sal_uInt8* pNewEncoding,
                                         sal_Int32* pWidths,
                                         int nGlyphs,
@@ -3692,7 +3705,8 @@ bool PrintFontManager::createFontSubset(
     memset( pGID, 0, sizeof( pGID ) );
     memset( pOldIndex, 0, sizeof( pOldIndex ) );
     int nChar = 1;
-    for( int i = 0; i < nGlyphs; i++ )
+    int i;
+    for( i = 0; i < nGlyphs; i++ )
     {
         if( pNewEncoding[i] == 0 )
         {
@@ -3782,8 +3796,8 @@ std::list< OString > PrintFontManager::g
     if( aRet.begin() == aRet.end() && aChar != 0 )
     {
         sal_Char aBuf[8];
-        snprintf( (char*)aBuf, sizeof( aBuf ), "uni%.4hX\0", aChar );
-        aRet.push_back( aBuf );
+        sal_Int32 nChars = snprintf( (char*)aBuf, sizeof( aBuf ), "uni%.4hX", aChar );
+        aRet.push_back( OString( aBuf, nChars ) );
     }
 
     return aRet;
Index: psprint/source/fontmanager/makefile.mk
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/makefile.mk,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- psprint/source/fontmanager/makefile.mk	20 Aug 2002 15:00:13 -0000	1.4
+++ psprint/source/fontmanager/makefile.mk	15 Mar 2004 12:03:52 -0000	1.5
@@ -66,17 +66,22 @@ ENABLE_EXCEPTIONS=TRUE
 PRJNAME=psprint
 TARGET=fontman
 
-ENVCFLAGS+= -I..$/fontsubset
-
 # --- Settings -----------------------------------------------------
 
 .INCLUDE :  settings.mk
 
+CFLAGS+= -I..$/fontsubset
+
+.IF "$(ENABLE_FONTCONFIG)" != ""
+CDEFS += -DENABLE_FONTCONFIG
+.ENDIF
+
 # --- Files --------------------------------------------------------
 
 SLOFILES=\
 	$(SLO)$/fontmanager.obj		\
 	$(SLO)$/fontcache.obj		\
+	$(SLO)$/fontconfig.obj		\
 	$(SLO)$/parseAFM.obj
 
 .IF "$(OS)$(CPU)"=="SOLARISI"
Index: psprint/source/fontmanager/parseAFM.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/parseAFM.cxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- psprint/source/fontmanager/parseAFM.cxx	20 Jul 2002 15:21:19 -0000	1.3
+++ psprint/source/fontmanager/parseAFM.cxx	30 Mar 2004 13:47:25 -0000	1.5
@@ -655,8 +655,7 @@ static int parseCharWidths( FILE* fp, re
  */ 
 
 static int
-reallocFontMetrics( void **pp_fontmetrics, int *p_oldcount, unsigned int n_newcount,
-                    unsigned int n_size )
+reallocFontMetrics( void **pp_fontmetrics, int *p_oldcount, int n_newcount, unsigned int n_size )
 {
     char *p_tmpmetrics = NULL;
 
@@ -788,8 +787,7 @@ static int parseCharMetrics( FILE* fp, r
                 break;
             case CHARNAME: 
                 keyword = token(fp);
-                temp->name = (char *) malloc(strlen(keyword) + 1);
-                strcpy(temp->name, keyword);
+                temp->name = (char *)strdup(keyword);
                 break;            
             case CHARBBOX: 
                 temp->charBBox.llx = atoi(token(fp));
@@ -810,11 +808,9 @@ static int parseCharMetrics( FILE* fp, r
                 
                 *tail = (Ligature *) calloc(1, sizeof(Ligature));
                 keyword = token(fp);
-                (*tail)->succ = (char *) malloc(strlen(keyword) + 1);
-                strcpy((*tail)->succ, keyword);
+                (*tail)->succ = (char *)strdup(keyword);
                 keyword = token(fp);
-                (*tail)->lig = (char *) malloc(strlen(keyword) + 1);
-                strcpy((*tail)->lig, keyword);
+                (*tail)->lig = (char *)strdup(keyword);
                 break; }
             case ENDCHARMETRICS:
                 cont = false;;
Index: psprint/source/fontsubset/gsub.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/gsub.cxx,v
retrieving revision 1.4.76.1
retrieving revision 1.6
diff -u -p -u -r1.4.76.1 -r1.6
--- psprint/source/fontsubset/gsub.cxx	15 Jan 2004 12:58:22 -0000	1.4.76.1
+++ psprint/source/fontsubset/gsub.cxx	17 Mar 2004 10:49:37 -0000	1.6
@@ -149,7 +149,7 @@ int ReadGSUB( struct _TrueTypeFont* pTTF
         if( (nDefaultLangsysOfs != 0) && (nDefaultLangsysOfs != nLangsysOffset) )
         {       
             const FT_Byte* pLangSys = pGsubBase + nOfsScriptList + nOfsScriptTable + nDefaultLangsysOfs;
-            const USHORT nLookupOrder   = NEXT_UShort( pLangSys );
+            /*const USHORT nLookupOrder   =*/ NEXT_UShort( pLangSys );
             const USHORT nReqFeatureIdx = NEXT_UShort( pLangSys );
             const USHORT nCntFeature    = NEXT_UShort( pLangSys );
             aFeatureIndexList.push_back( nReqFeatureIdx );
@@ -163,7 +163,7 @@ int ReadGSUB( struct _TrueTypeFont* pTTF
         if( nLangsysOffset != 0 )
         {       
             const FT_Byte* pLangSys = pGsubBase + nOfsScriptList + nOfsScriptTable + nLangsysOffset;
-            const USHORT nLookupOrder   = NEXT_UShort( pLangSys );
+            /*const USHORT nLookupOrder   =*/ NEXT_UShort( pLangSys );
             const USHORT nReqFeatureIdx = NEXT_UShort( pLangSys );
             const USHORT nCntFeature    = NEXT_UShort( pLangSys );
             aFeatureIndexList.push_back( nReqFeatureIdx );
@@ -222,7 +222,7 @@ int ReadGSUB( struct _TrueTypeFont* pTTF
         const USHORT nOfsLookupTable = *it;
         const FT_Byte* pLookupTable = pGsubBase + nOfsLookupList + nOfsLookupTable;
         const USHORT eLookupType        = NEXT_UShort( pLookupTable );
-        const USHORT eLookupFlag        = NEXT_UShort( pLookupTable );
+        /*const USHORT eLookupFlag        =*/ NEXT_UShort( pLookupTable );
         const USHORT nCntLookupSubtable = NEXT_UShort( pLookupTable );
 
         // TODO: switch( eLookupType )
Index: psprint/source/fontsubset/list.c
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/list.c,v
retrieving revision 1.2
retrieving revision 1.5
diff -u -p -u -r1.2 -r1.5
--- psprint/source/fontsubset/list.c	15 Apr 2003 16:14:04 -0000	1.2
+++ psprint/source/fontsubset/list.c	30 Mar 2004 13:47:35 -0000	1.5
@@ -72,8 +72,11 @@
 #include <stdlib.h>
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
+
 #include <assert.h>
 
 #ifdef MALLOC_TRACE
@@ -606,7 +609,7 @@ int main()
 
     for(i=0; i<10; i++) {
         ptr = malloc(20);
-        sprintf(ptr, "element # %d", i);
+        snprintf(ptr, 20, "element # %d", i);
         listAppend(l1, ptr);
     }
 
Index: psprint/source/fontsubset/sft.c
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/sft.c,v
retrieving revision 1.23.8.5
retrieving revision 1.30
diff -u -p -u -r1.23.8.5 -r1.30
--- psprint/source/fontsubset/sft.c	7 Apr 2004 11:04:59 -0000	1.23.8.5
+++ psprint/source/fontsubset/sft.c	18 May 2004 10:45:42 -0000	1.30
@@ -67,7 +67,9 @@
  */
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
 #include <assert.h>
 
@@ -937,19 +939,18 @@ static int BSplineToPSPath(ControlPoint 
     int i = 0, pCount = 0;
     PSPathElement *p;
 
-    int x0, y0, x1, y1, x2, y2, curx, cury;
+    int x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2, y2, curx, cury;
     int lastOff = 0;                                        /*- last point was off-contour */
     int scflag = 1;                                         /*- start contour flag */
     int ecflag = 0;                                         /*- end contour flag */
     int cp = 0;                                             /*- current point */
+    int StartContour = 0, EndContour = 1;
 
     listSetElementDtor(pList, free);
     *path = 0;
 
     /* if (srcCount > 0) for(;;) */
     while (srcCount > 0) {                                  /*- srcCount does not get changed inside the loop. */
-        int StartContour, EndContour;
-
         if (scflag) {
             int l = cp;
             StartContour = cp;
@@ -2218,10 +2219,10 @@ int  CreateTTFromTTGlyphs(TrueTypeFont  
 static GlyphOffsets *GlyphOffsetsNew(sal_uInt8 *sfntP)
 {
     GlyphOffsets *res = smalloc(sizeof(GlyphOffsets));
-    sal_uInt8 *loca;
+    sal_uInt8 *loca = NULL;
     sal_uInt16 i, numTables = GetUInt16(sfntP, 4, 1);
-    sal_uInt32 locaLen;
-    sal_Int16 indexToLocFormat;
+    sal_uInt32 locaLen = 0;
+    sal_Int16 indexToLocFormat = 0;
 
     for (i = 0; i < numTables; i++) {
         sal_uInt32 tag = GetUInt32(sfntP + 12, 16 * i, 1);
@@ -2380,7 +2381,7 @@ int  CreateT42FromTTGlyphs(TrueTypeFont 
         return res;
     }
 
-    fprintf(outf, "%%!PS-TrueTypeFont-%d.%d-%d.%d\n", ver>>16, ver & 0xFFFF, rev>>16, rev & 0xFFFF);
+    fprintf(outf, "%%!PS-TrueTypeFont-%d.%d-%d.%d\n", (int)(ver>>16), (int)(ver & 0xFFFF), (int)(rev>>16), (int)(rev & 0xFFFF));
     fprintf(outf, "%%%%Creator: %s %s %s\n", modname, modver, modextra);
     fprintf(outf, "%%- Font subset generated from a source font file: '%s'\n", ttf->fname);
     fprintf(outf, "%%- Original font name: %s\n", ttf->psname);
@@ -2398,7 +2399,7 @@ int  CreateT42FromTTGlyphs(TrueTypeFont 
     for (i = 1; i<nGlyphs; i++) {
         fprintf(outf, "Encoding %d /glyph%d put\n", encoding[i], gID[i]);
     }
-    fprintf(outf, "/XUID [103 0 1 16#%08X %d 16#%08X 16#%08X] def\n", rtl_crc32(0, ttf->ptr, ttf->fsize), nGlyphs, rtl_crc32(0, glyphArray, nGlyphs * 2), rtl_crc32(0, encoding, nGlyphs));
+    fprintf(outf, "/XUID [103 0 1 16#%08X %d 16#%08X 16#%08X] def\n", (unsigned int)rtl_crc32(0, ttf->ptr, ttf->fsize), (unsigned int)nGlyphs, (unsigned int)rtl_crc32(0, glyphArray, nGlyphs * 2), (unsigned int)rtl_crc32(0, encoding, nGlyphs));
 
     DumpSfnts(outf, sfntP);
 
@@ -2740,6 +2741,7 @@ int GetTTNameRecords(TrueTypeFont *ttf, 
                 rec[i].slen = 0;
                 continue;
             }
+
             rec_string = table + nStrBase + nStrOffset;
             // sanity check
             if( rec_string > (sal_uInt8*)ttf->ptr && rec_string < ((sal_uInt8*)ttf->ptr + ttf->fsize - rec[i].slen ) )
Index: psprint/source/fontsubset/ttcr.c
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/ttcr.c,v
retrieving revision 1.4
retrieving revision 1.6
diff -u -p -u -r1.4 -r1.6
--- psprint/source/fontsubset/ttcr.c	15 Apr 2003 16:14:27 -0000	1.4
+++ psprint/source/fontsubset/ttcr.c	17 Mar 2004 10:50:16 -0000	1.6
@@ -73,7 +73,9 @@
 #include <string.h>
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
 #include <assert.h>
 
@@ -299,7 +301,7 @@ void TrueTypeCreatorNewEmpty(sal_uInt32 
     TrueTypeCreator *ptr = smalloc(sizeof(TrueTypeCreator));
 
     ptr->tables = listNewEmpty();
-    listSetElementDtor(ptr->tables, TrueTypeTableDispose);
+    listSetElementDtor(ptr->tables, (void(*)(void*))TrueTypeTableDispose);
 
     ptr->tag = tag;
 
@@ -348,7 +350,7 @@ int StreamToMemory(TrueTypeCreator *_thi
     sal_uInt8 *ttf;
     int i=0, n;
     TableEntry *te;
-    sal_uInt8 *head;     /* saved pointer to the head table data for checkSumAdjustment calculation */
+    sal_uInt8 *head = NULL;     /* saved pointer to the head table data for checkSumAdjustment calculation */
     
     if ((n = listCount(_this->tables)) == 0) return SF_TTFORMAT;
 
@@ -628,7 +630,7 @@ static void TrueTypeTableDispose_post(Tr
             if (p->format == 0x00030000) {
                 /* do nothing */
             } else {
-                fprintf(stderr, "Unsupported format of a 'post' table: %08X.\n", p->format);
+                fprintf(stderr, "Unsupported format of a 'post' table: %08X.\n", (int)p->format);
             }
             free(p);
         }
@@ -955,7 +957,7 @@ static int GetRawData_post(TrueTypeTable
         PutUInt16((sal_uInt16)p->isFixedPitch, post, 12, 1);
         ret = TTCR_OK;
     } else {
-        fprintf(stderr, "Unrecognized format of a post table: %08X.\n", p->format);
+        fprintf(stderr, "Unrecognized format of a post table: %08X.\n", (int)p->format);
         ret = TTCR_POSTFORMAT;
     }
 
Index: psprint/source/helper/helper.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/helper/helper.cxx,v
retrieving revision 1.14.38.4
retrieving revision 1.20
diff -u -p -u -r1.14.38.4 -r1.20
--- psprint/source/helper/helper.cxx	19 Feb 2004 10:58:14 -0000	1.14.38.4
+++ psprint/source/helper/helper.cxx	1 Jun 2004 08:58:42 -0000	1.20
@@ -73,7 +73,7 @@
 #include <rtl/bootstrap.hxx>
 #include <sal/config.h>
 #ifdef SOLAR_JAVA
-#include "jvmaccess/javainfo.hxx"
+#include <jvmfwk/framework.h>
 #endif // SOLAR_JAVA
 
 #ifdef MACOSX
@@ -247,87 +247,36 @@ const OUString& psp::getFontPath()
 
         // append jre/jdk fonts if possible
         OString aJREpath;
-        if( aUserPath.getLength() )
-        {
-            OUString aJavaRc( aUserPath );
-            aJavaRc += OUString( RTL_CONSTASCII_USTRINGPARAM( "/user/config/" SAL_CONFIGFILE( "java" ) ) );
-            Config aConfig( aJavaRc );
-            aConfig.SetGroup( "Java" );
-            aJREpath = aConfig.ReadKey( "Home" );
-            if( ! aJREpath.getLength() )
-            {
-                aJavaRc = aNetPath;
-                aJavaRc += OUString( RTL_CONSTASCII_USTRINGPARAM( "/share/config/" SAL_CONFIGFILE("java") ) );
-                Config aShareConfig( aJavaRc );
-                aShareConfig.SetGroup( "Java" );
-                aJREpath = aShareConfig.ReadKey( "Home" );
-            }
-                
-            if( aJREpath.compareTo( "file:", 5 ) == 0 )
-            {
-                OUString aURL( OStringToOUString( aJREpath, osl_getThreadTextEncoding() ) );
-                OUString aSys;
-                if( osl_getSystemPathFromFileURL( aURL.pData, &aSys.pData ) == osl_File_E_None )
-                    aJREpath = OUStringToOString( aSys, osl_getThreadTextEncoding() );
-            }
+
+#ifdef SOLAR_JAVA        
+        JavaInfo * pInfo = NULL;
+        javaFrameworkError jerr = jfw_getSelectedJRE( & pInfo);
+        if (jerr == JFW_E_NONE && pInfo != NULL)
+        {
+            OUString aSys;
+            if( osl_getSystemPathFromFileURL( pInfo->sLocation, &aSys.pData ) == osl_File_E_None )
+                aJREpath = OUStringToOString( aSys, osl_getThreadTextEncoding() );
+        }
+        jfw_freeJavaInfo(pInfo);
+#endif
             
-            if( aJREpath.getLength() > 0 )
+        if( aJREpath.getLength() > 0 )
+        {
+            OString aTestPath( aJREpath );
+            aTestPath += "/jre/lib/fonts";
+            if( access( aTestPath.getStr(), R_OK ) )
             {
-                OString aTestPath( aJREpath );
-                aTestPath += "/jre/lib/fonts";
+                aTestPath = aJREpath;
+                aTestPath += "/lib/fonts";
                 if( access( aTestPath.getStr(), R_OK ) )
-                {
-                    aTestPath = aJREpath;
-                    aTestPath += "/lib/fonts";
-                    if( access( aTestPath.getStr(), R_OK ) )
-                        aJREpath = OString();
-                    else
-                        aJREpath = aTestPath;
-                }
+                    aJREpath = OString();
                 else
                     aJREpath = aTestPath;
             }
+            else
+                aJREpath = aTestPath;
         }
 
-#ifdef SOLAR_JAVA
-        // if no javarc (e.g. in setup) exists or it failed try the UDK method
-        if( ! aJREpath.getLength() )
-        {
-            OString aJavaLib;
-            try
-            {
-                OUString aLib;
-                if (osl::FileBase::getSystemPathFromFileURL(
-                            jvmaccess::JavaInfo::createBestInfo(true).
-                                getRuntimeLibLocation(),
-                            aLib)
-                        == osl::FileBase::E_None)
-                    aLib.convertToString(
-                        &aJavaLib, osl_getThreadTextEncoding(),
-                        RTL_UNICODETOTEXT_FLAGS_UNDEFINED_ERROR
-                            | RTL_UNICODETOTEXT_FLAGS_INVALID_ERROR);
-            }
-            catch (jvmaccess::JavaInfo::InitException &)
-            {}
-
-            if (aJavaLib.getLength() != 0)
-            {
-                sal_Int32 nIndex;
-                while( ( nIndex = aJavaLib.lastIndexOf( '/' ) ) != -1 )
-                {
-                    aJavaLib = aJavaLib.copy( 0, nIndex );
-                    OString aTmpPath = aJavaLib;
-                    aTmpPath += "/lib/fonts";
-                    if( access( aTmpPath.getStr(), R_OK ) == 0 )
-                    {
-                        aJREpath = aTmpPath;
-                        break;
-                    }
-                }
-            }
-        }
-#endif // SOLAR_JAVA
-
         if( aJREpath.getLength() )
         {
             aPath += OUString( RTL_CONSTASCII_USTRINGPARAM( ";" ) );
@@ -359,8 +308,8 @@ bool psp::convertPfbToPfa( ::osl::File& 
     {
         // read leading bytes
         bEof = ! rInFile.read( buffer, 6, nRead ) && nRead == 6 ? false : true;
-        int nType = buffer[ 1 ];
-        int nBytesToRead = buffer[2] | buffer[3] << 8 | buffer[4] << 16 | buffer[5] << 24;
+        unsigned int nType = buffer[ 1 ];
+        unsigned int nBytesToRead = buffer[2] | buffer[3] << 8 | buffer[4] << 16 | buffer[5] << 24;
         if( buffer[0] != 0x80 ) // test for pfb m_agic number
         {
             // this migt be a pfa font already
@@ -395,8 +344,8 @@ bool psp::convertPfbToPfa( ::osl::File& 
                     // ascii data, convert dos lineends( \r\n ) and
                     // m_ac lineends( \r ) to \n
                     unsigned char * pWriteBuffer = new unsigned char[ nBytesToRead ];
-                    int nBytesToWrite = 0;
-                    for( int i = 0; i < nBytesToRead; i++ )
+                    unsigned int nBytesToWrite = 0;
+                    for( unsigned int i = 0; i < nBytesToRead; i++ )
                     {
                         if( pBuffer[i] != '\r' )
                             pWriteBuffer[ nBytesToWrite++ ] = pBuffer[i];
@@ -416,8 +365,8 @@ bool psp::convertPfbToPfa( ::osl::File& 
                 else
                 {
                     // binary data
-                    int nBuffer = 0;
-                    for( int i = 0; i < nBytesToRead && bSuccess; i++ )
+                    unsigned int nBuffer = 0;
+                    for( unsigned int i = 0; i < nBytesToRead && bSuccess; i++ )
                     {
                         buffer[ nBuffer++ ] = hexDigits[ pBuffer[ i ] >> 4 ];
                         buffer[ nBuffer++ ] = hexDigits[ pBuffer[ i ] & 15 ];
@@ -450,3 +399,36 @@ bool psp::convertPfbToPfa( ::osl::File& 
 
     return bSuccess;
 }
+
+void psp::normPath( OString& rPath )
+{
+    char buf[PATH_MAX];
+    ByteString aPath( rPath );
+    
+    // double slashes and slash at end are probably
+    // removed by realpath anyway, but since this runs
+    // on many different platforms let's play it safe
+    while( aPath.SearchAndReplace( "//", "/" ) != STRING_NOTFOUND )
+        ;
+    if( aPath.Len() > 0 && aPath.GetChar( aPath.Len()-1 ) == '/' )
+        aPath.Erase( aPath.Len()-1 );
+
+    if( realpath( aPath.GetBuffer(), buf ) )
+        rPath = buf;
+    else
+        rPath = aPath;
+}
+
+void psp::splitPath( OString& rPath, OString& rDir, OString& rBase )
+{
+    normPath( rPath );
+    sal_Int32 nIndex = rPath.lastIndexOf( '/' );
+    if( nIndex > 0 )
+        rDir = rPath.copy( 0, nIndex );
+    else if( nIndex == 0 ) // root dir
+        rDir = rPath.copy( 0, 1 );
+    if( rPath.getLength() > nIndex+1 )
+        rBase = rPath.copy( nIndex+1 );
+}
+
+
Index: psprint/source/helper/ppdparser.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/helper/ppdparser.cxx,v
retrieving revision 1.8.38.2
retrieving revision 1.14
diff -u -p -u -r1.8.38.2 -r1.14
--- psprint/source/helper/ppdparser.cxx	19 Feb 2004 10:58:29 -0000	1.8.38.2
+++ psprint/source/helper/ppdparser.cxx	18 May 2004 10:45:57 -0000	1.14
@@ -67,16 +67,19 @@
 // define a hash for PPDKey
 namespace psp { class PPDKey; }
 
-struct std::hash< const psp::PPDKey* >
+namespace  _STL {
+struct hash< const psp::PPDKey* >
 {
     size_t operator()( const psp::PPDKey * pKey) const
     { return (size_t)pKey; }
 };
+}
 
 #include <psprint/ppdparser.hxx>
 #include <tools/debug.hxx>
 #include <psprint/strhelper.hxx>
 #include <psprint/helper.hxx>
+#include <cupsmgr.hxx>
 #include <tools/urlobj.hxx>
 #include <tools/stream.hxx>
 #include <osl/mutex.hxx>
@@ -104,13 +107,11 @@ static String aEmptyString;
 void PPDParser::scanPPDDir( const String& rDir )
 {
     static const sal_Char* pSuffixes[] = { "PS", "PPD" };
-    static const int nSuffixLens[] = { 2, 3 };
     const int nSuffixes = sizeof(pSuffixes)/sizeof(pSuffixes[0]);
 
     osl::Directory aDir( rDir );
     aDir.open();
     osl::DirectoryItem aItem;
-    bool bWas = false;
 
     INetURLObject aPPDDir(rDir);
     while( aDir.getNextItem( aItem ) == osl::FileBase::E_None )
@@ -181,24 +182,21 @@ String PPDParser::getPPDFile( const Stri
     if( ! aStream.IsOpen() )
     {
         initPPDFiles();
-#ifdef MACOSX
+        // some PPD files contain dots beside the extension, so try name first,
+        // base after that
         std::hash_map< OUString, OUString, OUStringHash >::const_iterator it =
             pAllPPDFiles->find( aPPD.getName() );
-#else
-        std::hash_map< OUString, OUString, OUStringHash >::const_iterator it =
-            pAllPPDFiles->find( aPPD.getBase() );
-#endif // MACOSX
+        if( it == pAllPPDFiles->end() )
+            it = pAllPPDFiles->find( aPPD.getBase() );
         if( it == pAllPPDFiles->end() )
         {
             // a new file ? rehash
             delete pAllPPDFiles; pAllPPDFiles = NULL;
             initPPDFiles();
             // aPPD is already the file name minus the extension
-#ifdef MACOSX
             it = pAllPPDFiles->find( aPPD.getName() );
-#else
-            it = pAllPPDFiles->find( aPPD.getBase() );
-#endif // MACOSX
+            if( it == pAllPPDFiles->end() )
+                it = pAllPPDFiles->find( aPPD.getBase() );
             // note this is optimized for office start where
             // no new files occur and initPPDFiles is called only once
         }
@@ -275,7 +273,8 @@ const PPDParser* PPDParser::getParser( S
     static ::osl::Mutex aMutex;
     ::osl::Guard< ::osl::Mutex > aGuard( aMutex );
 
-    aFile = getPPDFile( aFile );
+    if( aFile.CompareToAscii( "CUPS:", 5 ) != COMPARE_EQUAL )
+        aFile = getPPDFile( aFile );
     if( ! aFile.Len() )
     {
         fprintf( stderr, "Could not get printer PPD file!\n" );
@@ -286,8 +285,21 @@ const PPDParser* PPDParser::getParser( S
         if( (*it)->m_aFile == aFile )
             return *it;
 
-    PPDParser *pNewParser = new PPDParser( aFile );
-    aAllParsers.push_back( pNewParser );
+    PPDParser* pNewParser = NULL;
+    if( aFile.CompareToAscii( "CUPS:", 5 ) != COMPARE_EQUAL )
+        pNewParser = new PPDParser( aFile );
+    else
+    {
+        PrinterInfoManager& rMgr = PrinterInfoManager::get();
+        if( rMgr.getType() == PrinterInfoManager::CUPS )
+        {
+            pNewParser = const_cast<PPDParser*>(static_cast<CUPSManager&>(rMgr).createCUPSParser( aFile ));
+            if( pNewParser )
+                pNewParser->m_aFile = aFile;
+        }
+    }
+    if( pNewParser )
+        aAllParsers.push_back( pNewParser );
     return pNewParser;
 }
 
@@ -304,6 +316,7 @@ void PPDParser::freeAll()
 
 PPDParser::PPDParser( const String& rFile ) :
         m_aFile( rFile ),
+        m_bType42Capable( false ),
         m_pDefaultImageableArea( NULL ),
         m_pImageableAreas( NULL ),
         m_pDefaultPaperDimension( NULL ),
@@ -314,8 +327,7 @@ PPDParser::PPDParser( const String& rFil
         m_pResolutions( NULL ),
         m_pDefaultDuplexType( NULL ),
         m_pDuplexTypes( NULL ),
-        m_pFontList( NULL ),
-        m_bType42Capable( false )
+        m_pFontList( NULL )
 {
     // read in the file
     ::std::list< String > aLines;
@@ -350,8 +362,8 @@ PPDParser::PPDParser( const String& rFil
 
     // now get the Values
     parse( aLines );
-#ifdef __DEBUG
-    fprintf( stderr, "acquired %d Keys from PPD %s:\n", m_aKeys.Count(), BSTRING( m_aFile ).GetBuffer() );
+#if OSL_DEBUG_LEVEL > 2
+    fprintf( stderr, "acquired %d Keys from PPD %s:\n", m_aKeys.size(), BSTRING( m_aFile ).GetBuffer() );
     for( PPDParser::hash_type::const_iterator it = m_aKeys.begin(); it != m_aKeys.end(); ++it )
     {
         const PPDKey* pKey = it->second;
@@ -375,7 +387,7 @@ PPDParser::PPDParser( const String& rFil
         for( int j = 0; j < pKey->countValues(); j++ )
         {
             fprintf( stderr, "\t\t" );
-            PPDValue* pValue = pKey->getValue( j );
+            const PPDValue* pValue = pKey->getValue( j );
             if( pValue == pKey->m_pDefaultValue )
                 fprintf( stderr, "(Default:) " );
             char* pVType = "<unknown>";
@@ -396,15 +408,14 @@ PPDParser::PPDParser( const String& rFil
                      BSTRING( pValue->m_aValueTranslation ).GetBuffer() );
         }
     }
-    fprintf( stderr, "constraints: (%d found)\n", m_aConstraints.Count() );
-    for( int j = 0; j < m_aConstraints.Count(); j++ )
+    fprintf( stderr, "constraints: (%d found)\n", m_aConstraints.size() );
+    for( std::list< PPDConstraint >::const_iterator cit = m_aConstraints.begin(); cit != m_aConstraints.end(); ++cit )
     {
-        PPDConstraint* pCon = m_aConstraints.GetObject( j );
         fprintf( stderr, "*\"%s\" \"%s\" *\"%s\" \"%s\"\n",
-                 BSTRING( pCon->m_pKey1->getKey() ).GetBuffer(),
-                 pCon->m_pOption1 ? BSTRING( pCon->m_pOption1->m_aOption ).GetBuffer() : "<nil>",
-                 BSTRING( pCon->m_pKey2->getKey() ).GetBuffer(),
-                 pCon->m_pOption2 ? BSTRING( pCon->m_pOption2->m_aOption ).GetBuffer() : "<nil>"
+                 BSTRING( cit->m_pKey1->getKey() ).GetBuffer(),
+                 cit->m_pOption1 ? BSTRING( cit->m_pOption1->m_aOption ).GetBuffer() : "<nil>",
+                 BSTRING( cit->m_pKey2->getKey() ).GetBuffer(),
+                 cit->m_pOption2 ? BSTRING( cit->m_pOption2->m_aOption ).GetBuffer() : "<nil>"
                  );
     }
 #endif
@@ -444,16 +455,16 @@ PPDParser::PPDParser( const String& rFil
     DBG_ASSERT( m_pFontList, "Warning: no Font in PPD\n" );
 
     // fill in direct values
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ModelName" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ModelName" ) ) )) )
         m_aPrinterName = pKey->getValue( 0 )->m_aValue;
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "NickName" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "NickName" ) ) )) )
         m_aNickName = pKey->getValue( 0 )->m_aValue;
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ColorDevice" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ColorDevice" ) ) )) )
         m_bColorDevice = pKey->getValue( 0 )->m_aValue.CompareIgnoreCaseToAscii( "true", 4 ) == COMPARE_EQUAL ? true : false;
 
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "LanguageLevel" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "LanguageLevel" ) ) )) )
         m_nLanguageLevel = pKey->getValue( 0 )->m_aValue.ToInt32();
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "TTRasterizer" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "TTRasterizer" ) ) )) )
         m_bType42Capable = pKey->getValue( 0 )->m_aValue.EqualsIgnoreCaseAscii( "Type42" ) ? true : false;
 
 #ifdef MACOSX
@@ -490,7 +501,7 @@ void PPDParser::insertKey( const String&
 
 const PPDKey* PPDParser::getKey( int n ) const
 {
-    return (n < m_aOrderedKeys.size() && n >= 0) ? m_aOrderedKeys[n] : NULL;
+    return ((unsigned int)n < m_aOrderedKeys.size() && n >= 0) ? m_aOrderedKeys[n] : NULL;
 }
 
 const PPDKey* PPDParser::getKey( const String& rKey ) const
@@ -1194,10 +1205,10 @@ const String& PPDParser::getFont( int nF
 
 PPDKey::PPDKey( const String& rKey ) :
         m_aKey( rKey ),
-        m_bUIOption( false ),
-        m_eUIType( PickOne ),
         m_pDefaultValue( NULL ),
         m_bQueryValue( false ),
+        m_bUIOption( false ),
+        m_eUIType( PickOne ),
         m_nOrderDependency( 100 ),
         m_eSetupType( AnySetup )
 {
@@ -1213,14 +1224,13 @@ PPDKey::~PPDKey()
 
 const PPDValue* PPDKey::getValue( int n ) const
 {
-    return (n < m_aOrderedValues.size() && n >= 0) ? m_aOrderedValues[n] : NULL;
+    return ((unsigned int)n < m_aOrderedValues.size() && n >= 0) ? m_aOrderedValues[n] : NULL;
 }
 
 // -------------------------------------------------------------------
 
 const PPDValue* PPDKey::getValue( const String& rOption ) const
 {
-    const PPDValue* pValue = NULL;
     PPDKey::hash_type::const_iterator it = m_aValues.find( rOption );
     return it != m_aValues.end() ? &it->second : NULL;
 }
@@ -1299,8 +1309,11 @@ const PPDKey* PPDContext::getModifiedKey
 
 void PPDContext::setParser( const PPDParser* pParser )
 {
-    m_aCurrentValues.clear();
-    m_pParser = pParser;
+    if( pParser != m_pParser )
+    {
+        m_aCurrentValues.clear();
+        m_pParser = pParser;
+    }
 }
 
 // -------------------------------------------------------------------
@@ -1539,7 +1552,6 @@ void PPDContext::getUnconstrainedValues(
 void* PPDContext::getStreamableBuffer( ULONG& rBytes ) const
 {
     rBytes = 0;
-    int i;
     if( ! m_aCurrentValues.size() )
         return NULL;
     ::std::hash_map< const PPDKey*, const PPDValue* >::const_iterator it;
Index: psprint/source/helper/strhelper.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/helper/strhelper.cxx,v
retrieving revision 1.3.80.1
retrieving revision 1.6
diff -u -p -u -r1.3.80.1 -r1.6
--- psprint/source/helper/strhelper.cxx	9 Jan 2004 18:21:24 -0000	1.3.80.1
+++ psprint/source/helper/strhelper.cxx	30 Mar 2004 13:48:06 -0000	1.6
@@ -63,9 +63,9 @@
 #include <ieeefp.h> // finite
 #include <alloca.h>
 #endif
-#include <stdlib.h>
-#include <math.h> // for isnan
-#include <string.h> // strcpy
+#include <cstdlib>
+#include <cmath> // for isnan
+#include <cstring>
 
 namespace psp {
 
@@ -643,19 +643,19 @@ int getValueOfDouble( char* pBuffer, dou
 
     if( ! finite( f ) )
     {
-        strcpy( pBuffer, "Inf" );
+        strncpy( pBuffer, "Inf", 3 );
         return 3;
     }
 
     if( isnan( f ) )
     {
-        strcpy( pBuffer, "NaN" );
+        strncpy( pBuffer, "NaN", 3 );
         return 3;
     }
 
     if( f == 0.0 )
     {
-        strcpy( pBuffer, "0" );
+        strncpy( pBuffer, "0", 3 );
         return 1;
     }
 
@@ -664,12 +664,12 @@ int getValueOfDouble( char* pBuffer, dou
         *pBuffer++ = '-';
         f = -f;
     }
-    int exponent = log10( f );
+    int exponent = (int)log10( f );
     if( exponent < 4 && exponent > -4 )
         exponent = 0;
     f /= pow( 10, (double) exponent );
 
-    int nInt = f;
+    int nInt = (int)f;
     f -= nInt;
     // f should really not be 1.0 after this, but some
     // hardware implementations seem to round at this point
@@ -696,7 +696,7 @@ int getValueOfDouble( char* pBuffer, dou
         do
         {
             f *= 10;
-            nInt = f;
+            nInt = (int)f;
             f -= nInt;
             // f should really not be 1.0 after this, but some
             // hardware implementations seem to round at this point
Index: psprint/source/printer/cupsmgr.cxx
===================================================================
RCS file: psprint/source/printer/cupsmgr.cxx
diff -N psprint/source/printer/cupsmgr.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ psprint/source/printer/cupsmgr.cxx	18 May 2004 10:46:09 -0000	1.3
@@ -0,0 +1,737 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifdef ENABLE_CUPS
+#include <cups/cups.h>
+#include <cups/ppd.h>
+#else
+typedef void ppd_file_t;
+typedef void cups_dest_t;
+typedef void cups_option_t;
+#endif
+
+#include <osl/thread.h>
+#include <osl/diagnose.h>
+#include <cupsmgr.hxx>
+
+namespace psp
+{
+class CUPSWrapper
+{
+    oslModule		m_pLib;
+
+    int				(*m_pcupsPrintFile)(const char*, const char*, const char*, int, cups_option_t*);
+    int				(*m_pcupsGetDests)(cups_dest_t**);
+    void			(*m_pcupsSetDests)(int,cups_dest_t*);
+    void			(*m_pcupsFreeDests)(int,cups_dest_t*);
+    const char*	(*m_pcupsGetPPD)(const char*);
+    int				(*m_pcupsMarkOptions)(ppd_file_t*,int,cups_option_t*);
+    int				(*m_pcupsAddOption)(const char*,const char*,int,cups_option_t**);
+    void			(*m_pcupsFreeOptions)(int,cups_option_t*);
+    ppd_file_t*		(*m_pppdOpenFile)(const char* pFile);
+    void			(*m_pppdClose)(ppd_file_t*);
+    const char*	(*m_pcupsServer)();
+    void			(*m_pcupsSetPasswordCB)(const char*(cb)(const char*));
+    const char*	(*m_pcupsUser)();
+    void			(*m_pcupsSetUser)(const char*);
+
+    void* loadSymbol( const char* );
+public:
+    CUPSWrapper();
+    ~CUPSWrapper();
+
+    bool isValid();
+
+    int cupsGetDests(cups_dest_t** pDests)
+    { return m_pcupsGetDests(pDests); }
+
+    void cupsSetDests( int nDests, cups_dest_t* pDests )
+    { m_pcupsSetDests( nDests, pDests ); }
+
+    void cupsFreeDests(int nDests, cups_dest_t* pDests)
+    { m_pcupsFreeDests(nDests, pDests); }
+
+    int cupsPrintFile( const char* pPrinter,
+                       const char* pFileName,
+                       const char* pTitle,
+                       int nOptions,
+                   cups_option_t* pOptions )
+    { return m_pcupsPrintFile( pPrinter, pFileName, pTitle, nOptions, pOptions ); }
+
+    const char* cupsGetPPD( const char* pPrinter )
+    { return m_pcupsGetPPD( pPrinter ); }
+
+    int cupsMarkOptions(ppd_file_t* pPPD, int nOptions, cups_option_t* pOptions )
+    { return m_pcupsMarkOptions(pPPD, nOptions, pOptions); }
+
+    int cupsAddOption( const char* pName, const char* pValue, int nOptions, cups_option_t** pOptions )
+    { return m_pcupsAddOption( pName, pValue, nOptions, pOptions ); }
+
+    void cupsFreeOptions( int nOptions, cups_option_t* pOptions )
+    { m_pcupsFreeOptions( nOptions, pOptions ); }
+
+    ppd_file_t* ppdOpenFile( const char* pFileName )
+    { return m_pppdOpenFile( pFileName ); }
+
+    void ppdClose( ppd_file_t* pPPD )
+    { m_pppdClose( pPPD ); }
+
+    const char	*cupsServer(void)
+    { return m_pcupsServer(); }
+
+    const char	*cupsUser(void)
+    { return m_pcupsUser(); }
+    
+    void cupsSetPasswordCB(const char *(*cb)(const char *))
+    { m_pcupsSetPasswordCB( cb ); }
+
+    void cupsSetUser(const char *user)
+    { m_pcupsSetUser( user ); }
+    
+};
+}
+
+using namespace psp;
+using namespace osl;
+using namespace rtl;
+
+/*
+ *  CUPSWrapper class
+ */
+
+void* CUPSWrapper::loadSymbol( const char* pSymbol )
+{
+    OUString aSym( OUString::createFromAscii( pSymbol ) );
+    void* pSym = osl_getSymbol( m_pLib, aSym.pData );
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "%s %s\n", pSymbol, pSym ? "found" : "not found" );
+#endif
+    return pSym;
+}
+
+CUPSWrapper::CUPSWrapper() 
+        : m_pLib( NULL )
+{
+#ifdef ENABLE_CUPS
+    OUString aLib( RTL_CONSTASCII_USTRINGPARAM( "libcups.so.2" ) );
+    m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( ! m_pLib )
+    {
+        aLib = OUString( RTL_CONSTASCII_USTRINGPARAM( "libcups.so" ) );
+        m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    }
+#endif
+
+    if( ! m_pLib )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "no cups library found\n" );
+#endif
+        return;
+    }
+
+    m_pcupsPrintFile	 	= (int(*)(const char*,const char*,const char*,int,cups_option_t*))
+        loadSymbol( "cupsPrintFile" );
+    m_pcupsGetDests			= (int(*)(cups_dest_t**))
+        loadSymbol( "cupsGetDests" );
+    m_pcupsSetDests			= (void(*)(int,cups_dest_t*))
+        loadSymbol( "cupsSetDests" );
+    m_pcupsFreeDests		= (void(*)(int,cups_dest_t*))
+        loadSymbol( "cupsFreeDests" );
+    m_pcupsGetPPD			= (const char*(*)(const char*))
+        loadSymbol( "cupsGetPPD" );
+    m_pcupsMarkOptions		= (int(*)(ppd_file_t*,int,cups_option_t*))
+        loadSymbol( "cupsMarkOptions" );
+    m_pcupsAddOption		= (int(*)(const char*,const char*,int,cups_option_t**))
+        loadSymbol( "cupsAddOption" );
+    m_pcupsFreeOptions		= (void(*)(int,cups_option_t*))
+        loadSymbol( "cupsFreeOptions" );
+    m_pppdOpenFile			= (ppd_file_t*(*)(const char*))
+        loadSymbol( "ppdOpenFile" );
+    m_pppdClose				= (void(*)(ppd_file_t*))
+        loadSymbol( "ppdClose" );
+    m_pcupsServer			= (const char*(*)())
+        loadSymbol( "cupsServer" );
+    m_pcupsUser				= (const char*(*)())
+        loadSymbol( "cupsUser" );
+    m_pcupsSetPasswordCB	= (void(*)(const char*(*)(const char*)))
+        loadSymbol( "cupsSetPasswordCB" );
+    m_pcupsSetUser			= (void(*)(const char*))
+        loadSymbol( "cupsSetUser" );
+
+    if( ! (
+           m_pcupsPrintFile					&&
+           m_pcupsGetDests					&&
+           m_pcupsSetDests					&&
+           m_pcupsFreeDests					&&
+           m_pcupsGetPPD					&&
+           m_pcupsMarkOptions				&&
+           m_pcupsAddOption					&&
+           m_pcupsServer					&&
+           m_pcupsUser						&&
+           m_pcupsSetPasswordCB				&&
+           m_pcupsSetUser					&&
+           m_pcupsFreeOptions				&&
+           m_pppdOpenFile					&&
+           m_pppdClose
+           ) )
+    {
+        osl_unloadModule( m_pLib );
+        m_pLib = NULL;
+    }
+}
+
+CUPSWrapper::~CUPSWrapper()
+{
+    if( m_pLib )
+        osl_unloadModule( m_pLib );
+}
+
+bool CUPSWrapper::isValid()
+{
+    return m_pLib != NULL;
+}
+
+static const char* setPasswordCallback( const char* pIn )
+{
+    const char* pRet = NULL;
+    
+    PrinterInfoManager& rMgr = PrinterInfoManager::get();
+    if( rMgr.getType() == PrinterInfoManager::CUPS ) // sanity check
+        pRet = static_cast<CUPSManager&>(rMgr).authenticateUser( pIn );
+    return pRet;
+}
+
+/*
+ *  CUPSManager class
+ */
+
+CUPSManager* CUPSManager::tryLoadCUPS()
+{
+    CUPSManager* pManager = NULL;
+#ifdef ENABLE_CUPS
+    static const char* pEnv = getenv( "SAL_DISABLE_CUPS" );
+    
+    if( ! pEnv || ! *pEnv )
+    {
+        // try to load CUPS
+        CUPSWrapper* pWrapper = new CUPSWrapper();
+        if( pWrapper->isValid() )
+        {
+            // check if there are any dests; if not
+            // CUPS is unconfigured (at least) and
+            // should not be used
+            cups_dest_t* pDests = NULL;
+            int nDests = pWrapper->cupsGetDests( &pDests );
+            if( nDests && pDests )
+                pManager = new CUPSManager( pWrapper, nDests, pDests );
+#if OSL_DEBUG_LEVEL > 1
+            else
+                fprintf( stderr, "CUPS loaded but no dests -> CUPS disabled\n" );
+#endif
+        }
+        // something failed, don't use CUPS
+        if( ! pManager )
+            delete pWrapper;
+    }
+#endif
+    return pManager;
+}
+
+CUPSManager::CUPSManager( CUPSWrapper* pWrapper, int nDests, void* pDests ) :
+        PrinterInfoManager( CUPS ),
+        m_pCUPSWrapper( pWrapper ),
+        m_nDests( nDests ),
+        m_pDests( pDests )
+{
+        m_bFirstDest = (nDests && pDests);
+}
+
+CUPSManager::~CUPSManager()
+{
+    if( m_nDests && m_pDests )
+        m_pCUPSWrapper->cupsFreeDests( m_nDests, (cups_dest_t*)m_pDests );
+    delete m_pCUPSWrapper;
+}
+
+void CUPSManager::initialize()
+{
+#ifdef ENABLE_CUPS
+    // there may have been a previous run
+    if( m_nDests && m_pDests && !m_bFirstDest )
+        m_pCUPSWrapper->cupsFreeDests( m_nDests, (cups_dest_t*)m_pDests );
+    m_aPrinters.clear();
+    m_aCUPSDestMap.clear();
+
+    // get normal printers
+    PrinterInfoManager::initialize();
+
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    int nPrinter = 0;
+
+    // get CUPS dests if this is not the first run after the constructor
+    // in which case m_pDests was already intialized
+    if( m_bFirstDest && m_nDests && m_pDests )
+        nPrinter = m_nDests;
+    else
+        m_nDests = nPrinter = m_pCUPSWrapper->cupsGetDests( (cups_dest_t**)&m_pDests );
+    
+    m_bFirstDest = false;
+
+    // add CUPS printers, should there be a printer
+    // with the same name as a CUPS printer, overwrite it
+    while( nPrinter-- )
+    {
+        cups_dest_t* pDest = ((cups_dest_t*)m_pDests)+nPrinter;
+        OUString aPrinterName = OStringToOUString( pDest->name, aEncoding );
+
+        // initialize printer with possible configuration from psprint.conf
+        Printer aPrinter = m_aPrinters[ aPrinterName ];
+        aPrinter.m_aInfo.m_aPrinterName = aPrinterName;
+        if( pDest->instance && *pDest->instance )
+            aPrinter.m_aInfo.m_aLocation = OStringToOUString( pDest->instance, aEncoding );
+        if( pDest->is_default )
+            m_aDefaultPrinter = aPrinterName;
+
+
+        OUString aPPD( RTL_CONSTASCII_USTRINGPARAM( "CUPS:" ) );
+        aPPD = aPPD + aPrinterName;
+        // note: the parser that goes with the PrinterInfo
+        // is created implicitly by the JobData::operator=()
+        // when it detects the NULL ptr m_pParser.
+        // if we wanted to fill in the parser here this
+        // would mean we'd have to download PPDs for each and
+        // every printer - which would be really bad runtime
+        // behaviour
+        aPrinter.m_aInfo.m_pParser = NULL;
+        aPrinter.m_aInfo.m_aContext.setParser( NULL );
+        aPrinter.m_aInfo.m_aDriverName = aPPD;
+        aPrinter.m_bModified = false;
+
+        m_aPrinters[ aPrinter.m_aInfo.m_aPrinterName ] = aPrinter;
+        m_aCUPSDestMap[ aPrinter.m_aInfo.m_aPrinterName ] = nPrinter;
+    }
+
+    // remove everything that is not a CUPS printer and not
+    // a special purpose printer (PDF, Fax)
+    std::list< OUString > aRemovePrinters;
+    for( std::hash_map< OUString, Printer, OUStringHash >::iterator it = m_aPrinters.begin();
+         it != m_aPrinters.end(); ++it )
+    {
+        if( m_aCUPSDestMap.find( it->first ) != m_aCUPSDestMap.end() )
+            continue;
+
+        if( it->second.m_aInfo.m_aFeatures.getLength() > 0 )
+            continue;
+        aRemovePrinters.push_back( it->first );
+    }
+    while( aRemovePrinters.begin() != aRemovePrinters.end() )
+    {
+        m_aPrinters.erase( aRemovePrinters.front() );
+        aRemovePrinters.pop_front();
+    }
+
+    m_pCUPSWrapper->cupsSetPasswordCB( setPasswordCallback );
+#endif // ENABLE_CUPS
+}
+
+#ifdef ENABLE_CUPS
+static void updatePrinterContextInfo( ppd_group_t* pPPDGroup, PrinterInfo& rInfo )
+{
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    for( int i = 0; i < pPPDGroup->num_options; i++ )
+    {
+        ppd_option_t* pOption = pPPDGroup->options + i;
+        for( int n = 0; n < pOption->num_choices; n++ )
+        {
+            ppd_choice_t* pChoice = pOption->choices + n;
+            if( pChoice->marked )
+            {
+                const PPDKey* pKey = rInfo.m_pParser->getKey( OStringToOUString( pOption->keyword, aEncoding ) );
+                if( pKey )
+                {
+                    const PPDValue* pValue = pKey->getValue( OStringToOUString( pChoice->choice, aEncoding ) );
+                    if( pValue )
+                    {
+                        if( pValue != pKey->getDefaultValue() )
+                        {
+                            rInfo.m_aContext.setValue( pKey, pValue, true );
+#if OSL_DEBUG_LEVEL > 1
+                            fprintf( stderr, "key %s is set to %s\n", pOption->keyword, pChoice->choice );
+#endif
+                            
+                        }                       
+#if OSL_DEBUG_LEVEL > 1
+                        else
+                            fprintf( stderr, "key %s is defaulted to %s\n", pOption->keyword, pChoice->choice );
+#endif
+                    }
+#if OSL_DEBUG_LEVEL > 1
+                    else
+                        fprintf( stderr, "caution: value %s not found in key %s\n", pChoice->choice, pOption->keyword );
+#endif
+                }
+#if OSL_DEBUG_LEVEL > 1
+                else
+                    fprintf( stderr, "caution: key %s not found in parser\n", pOption->keyword );
+#endif
+            }
+        }
+    }
+
+    // recurse through subgroups
+    for( int g = 0; g < pPPDGroup->num_subgroups; g++ )
+    {
+        updatePrinterContextInfo( pPPDGroup->subgroups + g, rInfo );
+    }
+}
+#endif // ENABLE_CUPS
+
+const PPDParser* CUPSManager::createCUPSParser( const OUString& rPrinter )
+{
+    const PPDParser* pNewParser = NULL;
+    OUString aPrinter;
+
+    if( rPrinter.compareToAscii( "CUPS:", 5 ) == 0 )
+        aPrinter = rPrinter.copy( 5 );
+    else
+        aPrinter = rPrinter;
+
+#ifdef ENABLE_CUPS
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    OString aPrinterName( OUStringToOString( aPrinter, aEncoding ) );
+
+    const char* pPPDFile = m_pCUPSWrapper->cupsGetPPD( aPrinterName.getStr() );
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "PPD for %s is %s\n", aPrinterName.getStr(), pPPDFile );
+#endif
+    if( pPPDFile )
+    {
+        OUString aFileName( OStringToOUString( pPPDFile, aEncoding ) );
+        // create the new parser
+        pNewParser = new PPDParser( aFileName );
+
+        std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+            m_aCUPSDestMap.find( aPrinter );
+
+        if( dest_it != m_aCUPSDestMap.end() )
+        {
+            cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + dest_it->second;
+            // update the printer info with context information
+            ppd_file_t* pPPD = m_pCUPSWrapper->ppdOpenFile( pPPDFile );
+            /*int nConflicts =*/ m_pCUPSWrapper->cupsMarkOptions( pPPD, pDest->num_options, pDest->options );
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "processing the following options for printer %s (instance %s):\n",
+                     pDest->name, pDest->instance );
+            for( int k = 0; k < pDest->num_options; k++ )
+                fprintf( stderr, "   \"%s\" = \"%s\"\n",
+                         pDest->options[k].name,
+                         pDest->options[k].value );
+#endif
+            PrinterInfo& rInfo = m_aPrinters[ aPrinter ].m_aInfo;
+        
+            rInfo.m_pParser = pNewParser;
+            rInfo.m_aContext.setParser( pNewParser );
+            for( int i = 0; i < pPPD->num_groups; i++ )
+                updatePrinterContextInfo( pPPD->groups + i, rInfo );
+
+            // clean up the mess
+            m_pCUPSWrapper->ppdClose( pPPD );
+        }
+#if OSL_DEBUG_LEVEL > 1
+        else
+            fprintf( stderr, "no dest found for printer %s\n", aPrinterName.getStr() );
+#endif
+        // remove temporary PPD file
+        unlink( pPPDFile );
+    }
+    else
+#endif // ENABLE_CUPS
+    {
+        // get the default PPD
+        pNewParser = PPDParser::getParser( String( RTL_CONSTASCII_USTRINGPARAM( "SGENPRT" ) ) );
+        
+        PrinterInfo& rInfo = m_aPrinters[ aPrinter ].m_aInfo;
+        
+        rInfo.m_pParser = pNewParser;
+        rInfo.m_aContext.setParser( pNewParser );
+    }
+
+    return pNewParser;
+}
+
+void CUPSManager::setupJobContextData( JobData& rData )
+{
+#ifdef ENABLE_CUPS
+    std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+        m_aCUPSDestMap.find( rData.m_aPrinterName );
+
+    if( dest_it == m_aCUPSDestMap.end() )
+        return PrinterInfoManager::setupJobContextData( rData );
+
+    std::hash_map< OUString, Printer, OUStringHash >::iterator p_it =
+        m_aPrinters.find( rData.m_aPrinterName );
+    if( p_it == m_aPrinters.end() ) // huh ?
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "CUPS printer list in disorder, no dest for printer %s !\n", OUStringToOString( rData.m_aPrinterName, osl_getThreadTextEncoding() ).getStr() );
+#endif
+        return;
+    }
+
+    if( p_it->second.m_aInfo.m_pParser == NULL )
+    {
+        // in turn calls createCUPSParser
+        // which updates the printer info
+        p_it->second.m_aInfo.m_pParser = PPDParser::getParser( p_it->second.m_aInfo.m_aDriverName );
+    }
+
+    rData.m_pParser		= p_it->second.m_aInfo.m_pParser;
+    rData.m_aContext	= p_it->second.m_aInfo.m_aContext;
+#endif
+}
+
+FILE* CUPSManager::startSpool( const OUString& rPrintername )
+{
+#ifdef ENABLE_CUPS
+    OUString aTmpURL, aTmpFile;
+    osl_createTempFile( NULL, NULL, &aTmpURL.pData );
+    osl_getSystemPathFromFileURL( aTmpURL.pData, &aTmpFile.pData );
+    OString aSysFile = OUStringToOString( aTmpFile, osl_getThreadTextEncoding() );
+    FILE* fp = fopen( aSysFile.getStr(), "w" );
+    if( fp )
+        m_aSpoolFiles[fp] = aSysFile;
+    
+    return fp;
+#else
+    return NULL;
+#endif
+}
+
+int CUPSManager::endSpool( const OUString& rPrintername, const OUString& rJobTitle, FILE* pFile )
+{
+    int nJobID = 0;
+
+#ifdef ENABLE_CUPS
+    std::hash_map< FILE*, OString, FPtrHash >::const_iterator it = m_aSpoolFiles.find( pFile );
+    if( it != m_aSpoolFiles.end() )
+    {
+        fclose( pFile );
+        rtl_TextEncoding aEnc = osl_getThreadTextEncoding();
+
+        nJobID = m_pCUPSWrapper->cupsPrintFile( OUStringToOString( rPrintername, aEnc ).getStr(),
+                                            it->second.getStr(),
+                                            OUStringToOString( rJobTitle, aEnc ).getStr(),
+                                            0, NULL );
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "cupsPrintFile( %s, %s, %s, 0, 0 ) returns %d\n",
+                 OUStringToOString( rPrintername, aEnc ).getStr(),
+                 it->second.getStr(),
+                 OUStringToOString( rJobTitle, aEnc ).getStr(),
+                 nJobID );
+        OString aCmd( "cp " );
+        aCmd = aCmd + it->second;
+        aCmd = aCmd + OString( " $HOME/cupsprint.ps" );
+        system( aCmd.getStr() );
+#endif
+
+        unlink( it->second.getStr() );
+        m_aSpoolFiles.erase( pFile );
+    }
+#endif // ENABLE_CUPS
+
+    return nJobID;
+}
+
+
+void CUPSManager::changePrinterInfo( const OUString& rPrinter, const PrinterInfo& rNewInfo )
+{
+    PrinterInfoManager::changePrinterInfo( rPrinter, rNewInfo );
+}
+
+bool CUPSManager::checkPrintersChanged()
+{
+    return PrinterInfoManager::checkPrintersChanged();
+}
+
+bool CUPSManager::addPrinter( const OUString& rName, const OUString& rDriver )
+{
+    // don't touch the CUPS printers
+    if( m_aCUPSDestMap.find( rName ) != m_aCUPSDestMap.end() ||
+        rDriver.compareToAscii( "CUPS:", 5 ) == 0
+        )
+        return false;
+    return PrinterInfoManager::addPrinter( rName, rDriver );
+}
+
+bool CUPSManager::removePrinter( const OUString& rName, bool bCheck )
+{
+    // don't touch the CUPS printers
+    if( m_aCUPSDestMap.find( rName ) != m_aCUPSDestMap.end() )
+        return false;
+    return PrinterInfoManager::removePrinter( rName, bCheck );
+}
+
+bool CUPSManager::setDefaultPrinter( const OUString& rName )
+{
+#ifdef ENABLE_CUPS
+    std::hash_map< OUString, int, OUStringHash >::iterator nit =
+        m_aCUPSDestMap.find( rName );
+    if( nit == m_aCUPSDestMap.end() )
+        return false;
+
+    cups_dest_t* pDests = (cups_dest_t*)m_pDests;
+    for( int i = 0; i < m_nDests; i++ )
+        pDests[i].is_default = 0;
+    pDests[ nit->second ].is_default = 1;
+    m_pCUPSWrapper->cupsSetDests( m_nDests, (cups_dest_t*)m_pDests );
+    m_aDefaultPrinter = rName;
+
+    return true;
+#else
+    return false;
+#endif
+}
+
+bool CUPSManager::writePrinterConfig()
+{
+#ifdef ENABLE_CUPS
+    bool bDestModified = false;
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+
+    for( std::hash_map< OUString, Printer, OUStringHash >::iterator prt =
+             m_aPrinters.begin(); prt != m_aPrinters.end(); ++prt )
+    {
+        std::hash_map< OUString, int, OUStringHash >::iterator nit =
+            m_aCUPSDestMap.find( prt->first );
+        if( nit == m_aCUPSDestMap.end() )
+            continue;
+        
+        if( ! prt->second.m_bModified )
+            continue;
+
+        bDestModified = true;
+        cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + nit->second;
+        PrinterInfo& rInfo = prt->second.m_aInfo;
+
+        // create new option list
+        int nNewOptions = 0;
+        cups_option_t* pNewOptions = NULL; 
+        int nValues = rInfo.m_aContext.countValuesModified();
+        for( int i = 0; i < nValues; i++ )
+        {
+            const PPDKey* pKey = rInfo.m_aContext.getModifiedKey( i );
+            const PPDValue* pValue = rInfo.m_aContext.getValue( pKey );
+            if( pKey && pValue ) // sanity check
+            {
+                OString aName = OUStringToOString( pKey->getKey(), aEncoding );
+                OString aValue = OUStringToOString( pValue->m_aOption, aEncoding );
+                nNewOptions = m_pCUPSWrapper->cupsAddOption( aName.getStr(), aValue.getStr(), nNewOptions, &pNewOptions );
+            }
+        }
+        // set PPD options on CUPS dest
+        m_pCUPSWrapper->cupsFreeOptions( pDest->num_options, pDest->options );
+        pDest->num_options = nNewOptions;
+        pDest->options = pNewOptions;
+    }
+    if( bDestModified )
+        m_pCUPSWrapper->cupsSetDests( m_nDests, (cups_dest_t*)m_pDests );
+#endif // ENABLE_CUPS
+
+    return PrinterInfoManager::writePrinterConfig();
+}
+
+#include <rtsname.hxx>
+
+const char* CUPSManager::authenticateUser( const char* pIn )
+{
+    const char* pRet = NULL;
+
+#ifdef ENABLE_CUPS
+    OUString aLib = OUString::createFromAscii( _XSALSET_LIBNAME );
+    oslModule pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( pLib )
+    {
+        OUString aSym( RTL_CONSTASCII_USTRINGPARAM( "Sal_authenticateQuery" ) );
+        bool (*getpw)( const OString& rServer, OString& rUser, OString& rPw) =
+            (bool(*)(const OString&,OString&,OString&))osl_getSymbol( pLib, aSym.pData );
+        if( getpw )
+        {
+            OString aUser = m_pCUPSWrapper->cupsUser();
+            OString aServer = m_pCUPSWrapper->cupsServer();
+            OString aPassword;
+            if( getpw( aServer, aUser, aPassword ) )
+            {       
+                m_aPassword = aPassword;
+                m_aUser = aUser;
+                m_pCUPSWrapper->cupsSetUser( m_aUser.getStr() );
+                pRet = m_aPassword.getStr();
+            }   	
+        }
+        osl_unloadModule( pLib );
+    }
+#if OSL_DEBUG_LEVEL > 1
+    else fprintf( stderr, "loading of module %s failed\n", OUStringToOString( aLib, osl_getThreadTextEncoding() ).getStr() );
+#endif
+#endif // ENABLE_CUPS
+
+    return pRet;
+}
Index: psprint/source/printer/jobdata.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printer/jobdata.cxx,v
retrieving revision 1.2.78.1
retrieving revision 1.5
diff -u -p -u -r1.2.78.1 -r1.5
--- psprint/source/printer/jobdata.cxx	9 Jan 2004 18:21:26 -0000	1.2.78.1
+++ psprint/source/printer/jobdata.cxx	17 Mar 2004 10:51:16 -0000	1.5
@@ -72,6 +72,30 @@
 using namespace psp;
 using namespace rtl;
 
+JobData& JobData::operator=(const JobData& rRight)
+{
+    m_nCopies				= rRight.m_nCopies;
+    m_nScale				= rRight.m_nScale;
+    m_nLeftMarginAdjust		= rRight.m_nLeftMarginAdjust;
+    m_nRightMarginAdjust	= rRight.m_nRightMarginAdjust;
+    m_nTopMarginAdjust		= rRight.m_nTopMarginAdjust;
+    m_nBottomMarginAdjust	= rRight.m_nBottomMarginAdjust;
+    m_nColorDepth			= rRight.m_nColorDepth;
+    m_eOrientation			= rRight.m_eOrientation;
+    m_aPrinterName			= rRight.m_aPrinterName;
+    m_pParser				= rRight.m_pParser;
+    m_aContext				= rRight.m_aContext;
+    m_nPSLevel				= rRight.m_nPSLevel;
+    m_nColorDevice			= rRight.m_nColorDevice;
+
+    if( ! m_pParser && m_aPrinterName.getLength() )
+    {
+        PrinterInfoManager& rMgr = PrinterInfoManager::get();
+        rMgr.setupJobContextData( *this );
+    }
+    return *this;
+}
+
 bool JobData::getStreamBuffer( void*& pData, int& bytes )
 {
     // consistency checks
@@ -133,7 +157,7 @@ bool JobData::getStreamBuffer( void*& pD
         aStream.Write( pContextBuffer, nBytes );
 
     // success
-    pData = rtl_allocateMemory( bytes = aStream.GetSize() );
+    pData = rtl_allocateMemory( bytes = aStream.Tell() );
     memcpy( pData, aStream.GetData(), bytes );
     return true;
 }
Index: psprint/source/printer/makefile.mk
===================================================================
RCS file: /cvs/gsl/psprint/source/printer/makefile.mk,v
retrieving revision 1.2.78.1
retrieving revision 1.4
diff -u -p -u -r1.2.78.1 -r1.4
--- psprint/source/printer/makefile.mk	28 Jan 2004 11:24:45 -0000	1.2.78.1
+++ psprint/source/printer/makefile.mk	17 Mar 2004 10:51:30 -0000	1.4
@@ -70,6 +70,10 @@ TARGET=printer
 
 .INCLUDE :  settings.mk
 
+.IF "$(ENABLE_CUPS)" != ""
+CDEFS += -DENABLE_CUPS
+.ENDIF
+
 # --- Files --------------------------------------------------------
 
 .IF "$(GUIBASE)"=="aqua"
@@ -81,10 +85,20 @@ dummy:
 
 SLOFILES=\
 	$(SLO)$/printerinfomanager.obj	\
-	$(SLO)$/jobdata.obj
+	$(SLO)$/jobdata.obj				\
+	$(SLO)$/cupsmgr.obj
 
 .ENDIF # GUIBASE = aqua
 
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :  target.mk
+
+XSALSETLIBNAME=$(DLLPRE)spa$(UPD)$(DLLPOSTFIX)$(DLLPOST)
+
+$(INCCOM)$/rtsname.hxx:
+	rm -f $(INCCOM)$/rtsname.hxx ; \
+	echo "#define _XSALSET_LIBNAME "\"$(XSALSETLIBNAME)\" > $(INCCOM)$/rtsname.hxx
+
+$(SLO)$/cupsmgr.obj : $(INCCOM)$/rtsname.hxx
+
Index: psprint/source/printer/printerinfomanager.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printer/printerinfomanager.cxx,v
retrieving revision 1.19.26.2.14.2
retrieving revision 1.23
diff -u -p -u -r1.19.26.2.14.2 -r1.23
--- psprint/source/printer/printerinfomanager.cxx	10 May 2004 13:01:07 -0000	1.19.26.2.14.2
+++ psprint/source/printer/printerinfomanager.cxx	17 Mar 2004 10:51:45 -0000	1.23
@@ -67,7 +67,7 @@
 #include <tools/stream.hxx>
 #include <tools/debug.hxx>
 #include <tools/config.hxx>
-#include <psprint/printerinfomanager.hxx>
+#include <cupsmgr.hxx>
 #include <psprint/fontmanager.hxx>
 
 #include <osl/thread.hxx>
@@ -123,17 +123,29 @@ class SystemQueueInfo : public Thread
 
 PrinterInfoManager& PrinterInfoManager::get()
 {
-    static PrinterInfoManager aManager;
+    static PrinterInfoManager* pManager = NULL;
 
-    return aManager;
+    if( ! pManager )
+    {
+        pManager = CUPSManager::tryLoadCUPS();
+        if( ! pManager )
+            pManager = new PrinterInfoManager();
+
+        if( pManager )
+            pManager->initialize();
+    }
+
+    return *pManager;
 }
 
 // -----------------------------------------------------------------
 
-PrinterInfoManager::PrinterInfoManager()
+PrinterInfoManager::PrinterInfoManager( Type eType ) :
+        m_pQueueInfo( NULL ),
+        m_eType( eType )
 {
-    m_pQueueInfo = new SystemQueueInfo();
-    initialize();
+    if( eType == Default )
+        m_pQueueInfo = new SystemQueueInfo();
 }
 
 // -----------------------------------------------------------------
@@ -172,7 +184,7 @@ bool PrinterInfoManager::checkPrintersCh
             }
         }
     }
-    if( ! bChanged )
+    if( ! bChanged && m_pQueueInfo )
         bChanged = m_pQueueInfo->hasChanged();
     if( bChanged )
     {
@@ -183,7 +195,7 @@ bool PrinterInfoManager::checkPrintersCh
         sal_Int32    applePrintSystem;
 
         applePrintSystem = macxp_GetSystemPrintMethod();
-        if ( (applePrintSystem == kApplePrintingCUPS) || (applePrintSystem == kApplePrintingNewCUPS) )
+        if ( applePrintSystem == kApplePrintingCUPS )
         {
             m_aSystemPrintQueues.clear();
             delete m_pQueueInfo;
@@ -254,8 +266,12 @@ void PrinterInfoManager::initialize()
             m_aGlobalDefaults.m_eOrientation = aValue.EqualsIgnoreCaseAscii( "Landscape" ) ? orientation::Landscape : orientation::Portrait;
 
             aValue = aConfig.ReadKey( "Scale" );
-		  if ( aValue.Len() )
+            if( aValue.Len() )
+            {
                 m_aGlobalDefaults.m_nScale = aValue.ToInt32();
+                if( (m_aGlobalDefaults.m_nScale < 1) || (m_aGlobalDefaults.m_nScale > 1000) )
+                    m_aGlobalDefaults.m_nScale = 100;
+            }
 
             aValue = aConfig.ReadKey( "MarginAdjust" );
             m_aGlobalDefaults.m_nLeftMarginAdjust   = aValue.GetToken( 0, ',' ).ToInt32();
@@ -313,7 +329,7 @@ void PrinterInfoManager::initialize()
     // notified of queue/printer updates, but these don't necessarily
     // happen when psprint.conf changes.  The user can change settings in
     // the Print Center which should also make OOo update its queue list.
-    if ( (applePrintSystem == kApplePrintingCUPS) || (applePrintSystem == kApplePrintingNewCUPS) )
+    if ( applePrintSystem == kApplePrintingCUPS )
     {
         // /etc/cups/printers.conf gets modified every time the Print Center printer
         // list is modified, so we want to watch this file too.
@@ -415,62 +431,71 @@ void PrinterInfoManager::initialize()
                 aPrinterName = String( aValue.Copy( nNamePos+1 ), RTL_TEXTENCODING_UTF8 );
                 aPrinter.m_aInfo.m_aPrinterName     = aPrinterName;
                 aPrinter.m_aInfo.m_aDriverName      = String( aValue.Copy( 0, nNamePos ), RTL_TEXTENCODING_UTF8 );
-                aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
-                aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
-                // note: setParser also purges the context
 
-                // ignore this printer if its driver is not found
-                if( ! aPrinter.m_aInfo.m_pParser )
-                    continue;
-
-                // merge the ppd context keys if the printer has the same keys and values
-                // this is a bit tricky, since it involves mixing two PPDs
-                // without constraints which might end up badly
-                // this feature should be use with caution
-                // it is mainly to select default paper sizes for new printers
-                for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
+                // set parser, merge settings
+                // don't do this for CUPS printers as this is done
+                // by the CUPS system itself
+                if( aPrinter.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) != 0 )
                 {
-                    const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
-                    const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
-                    const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
-                    if( pDefKey && pPrinterKey )
-                        // at least the options exist in both PPDs
+                    aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
+                    aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
+                    // note: setParser also purges the context
+
+                    // ignore this printer if its driver is not found
+                    if( ! aPrinter.m_aInfo.m_pParser )
+                        continue;
+
+                    // merge the ppd context keys if the printer has the same keys and values
+                    // this is a bit tricky, since it involves mixing two PPDs
+                    // without constraints which might end up badly
+                    // this feature should be use with caution
+                    // it is mainly to select default paper sizes for new printers
+                    for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
                     {
-                        if( pDefValue )
+                        const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
+                        const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
+                        const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
+                        if( pDefKey && pPrinterKey )
+                            // at least the options exist in both PPDs
                         {
-                            const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
-                            if( pPrinterValue )
-                                // the printer has a corresponding option for the key
-                                aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
-                        }
+                            if( pDefValue )
+                            {
+                                const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
+                                if( pPrinterValue )
+                                    // the printer has a corresponding option for the key
+                                    aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
+                            }
                         else
                             aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, NULL );
+                        }
                     }
-                }
 
-                aValue = aConfig.ReadKey( "Command" );
-                // no printer without a command
-                if( ! aValue.Len() )
-                {
-                    /*  TODO:
-                     *  porters: please append your platform to the Solaris
-                     *  case if your platform has SystemV printing per default.
-                     */
+                    aValue = aConfig.ReadKey( "Command" );
+                    // no printer without a command
+                    if( ! aValue.Len() )
+                    {
+                        /*  TODO:
+                         *  porters: please append your platform to the Solaris
+                         *  case if your platform has SystemV printing per default.
+                         */
 #if defined SOLARIS || defined(IRIX)
-                    aValue = "lp";
-#elif defined(MACOSX)
-                    if ( (applePrintSystem == kApplePrintingCUPS ) || (applePrintSystem == kApplePrintingNewCUPS) )
                         aValue = "lp";
-                    else
-                    {
-                        // Fallback case is kApplePrintingLPR
-                        aValue = "lpr";
-                    }
+#elif defined(MACOSX)
+                        if ( applePrintSystem == kApplePrintingCUPS )
+                            aValue = "lp";
+                        else if ( applePrintSystem == kApplePrintingPrintCenter )
+                            aValue = kApplePCPrintCommand;
+                        else
+                        {
+                            // Fallback case is kApplePrintingLPR
+                            aValue = "lpr";
+                        }
 #else
-                    aValue = "lpr";
+                        aValue = "lpr";
 #endif
+                    }
+                    aPrinter.m_aInfo.m_aCommand = String( aValue, RTL_TEXTENCODING_UTF8 );
                 }
-                aPrinter.m_aInfo.m_aCommand = String( aValue, RTL_TEXTENCODING_UTF8 );
 
                 aValue = aConfig.ReadKey( "Features" );
                 aPrinter.m_aInfo.m_aFeatures = String( aValue, RTL_TEXTENCODING_UTF8 );
@@ -496,7 +521,11 @@ void PrinterInfoManager::initialize()
 
                 aValue = aConfig.ReadKey( "Scale" );
                 if( aValue.Len() )
+                {
                     aPrinter.m_aInfo.m_nScale = aValue.ToInt32();
+                    if( (aPrinter.m_aInfo.m_nScale < 1) || (aPrinter.m_aInfo.m_nScale > 1000) )
+                        aPrinter.m_aInfo.m_nScale = 100;
+                }                
 
                 aValue = aConfig.ReadKey( "MarginAdjust" );
                 if( aValue.Len() )
@@ -531,7 +560,7 @@ void PrinterInfoManager::initialize()
                 for( int nKey = 0; nKey < aConfig.GetKeyCount(); nKey++ )
                 {
                     ByteString aKey( aConfig.GetKeyName( nKey ) );
-                    if( aKey.CompareTo( "PPD_", 4 ) == COMPARE_EQUAL )
+                    if( aKey.CompareTo( "PPD_", 4 ) == COMPARE_EQUAL && aPrinter.m_aInfo.m_pParser )
                     {
                         aValue = aConfig.ReadKey( aKey );
                         const PPDKey* pKey = aPrinter.m_aInfo.m_pParser->getKey( String( aKey.Copy( 4 ), RTL_TEXTENCODING_ISO_8859_1 ) );
@@ -568,6 +597,9 @@ void PrinterInfoManager::initialize()
         }
     }
 
+    if( m_eType != Default )
+        return;
+
     // set default printer
     if( m_aPrinters.size() )
     {
@@ -628,7 +660,7 @@ void PrinterInfoManager::initialize()
         // is associated with from /etc/cups/ppd (it's autocreated by the OS X printing system) and
         // use those values instead of the ones generated in the merged defaults.  We want to make
         // this system printer just like we assigned it a PPD in padmin.
-        if ( (applePrintSystem == kApplePrintingCUPS) || (applePrintSystem == kApplePrintingNewCUPS) )
+        if ( applePrintSystem == kApplePrintingCUPS )
         {
             aPrinter.m_aInfo.m_aFontSubstitutes.clear();
             aPrinter.m_aInfo.m_aFontSubstitutions.clear();
@@ -896,16 +928,19 @@ bool PrinterInfoManager::writePrinterCon
             aValue += ByteString::CreateFromInt32( it->second.m_aInfo.m_nBottomMarginAdjust );
             pConfig->WriteKey( "MarginAdjust", aValue );
 
-            // write PPDContext
-            for( int i = 0; i < it->second.m_aInfo.m_aContext.countValuesModified(); i++ )
+            if( it->second.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) != 0 )
             {
-                const PPDKey* pKey = it->second.m_aInfo.m_aContext.getModifiedKey( i );
-                ByteString aKey( "PPD_" );
-                aKey += ByteString( pKey->getKey(), RTL_TEXTENCODING_ISO_8859_1 );
-
-                const PPDValue* pValue = it->second.m_aInfo.m_aContext.getValue( pKey );
-                aValue = pValue ? ByteString( pValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ) : ByteString( "*nil" );
-                pConfig->WriteKey( aKey, aValue );
+                // write PPDContext (not for CUPS)
+                for( int i = 0; i < it->second.m_aInfo.m_aContext.countValuesModified(); i++ )
+                {
+                    const PPDKey* pKey = it->second.m_aInfo.m_aContext.getModifiedKey( i );
+                    ByteString aKey( "PPD_" );
+                    aKey += ByteString( pKey->getKey(), RTL_TEXTENCODING_ISO_8859_1 );
+                    
+                    const PPDValue* pValue = it->second.m_aInfo.m_aContext.getValue( pKey );
+                    aValue = pValue ? ByteString( pValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ) : ByteString( "*nil" );
+                    pConfig->WriteKey( aKey, aValue );
+                }
             }
 
             // write font substitution table
@@ -968,6 +1003,14 @@ bool PrinterInfoManager::addPrinter( con
 
         m_aPrinters[ rPrinterName ] = aPrinter;
         bSuccess = true;
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "new printer %s, level = %d, scale = %d, colordevice = %d, depth = %d\n",
+                 OUStringToOString( rPrinterName, osl_getThreadTextEncoding() ).getStr(),
+                 m_aPrinters[rPrinterName].m_aInfo.m_nPSLevel,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nScale,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nColorDevice,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nColorDepth );
+#endif
     }
     return bSuccess;
 }
@@ -1145,7 +1188,7 @@ void PrinterInfoManager::fillFontSubstit
 
 void PrinterInfoManager::getSystemPrintCommands( std::list< OUString >& rCommands )
 {
-    if( m_pQueueInfo->hasChanged() )
+    if( m_pQueueInfo && m_pQueueInfo->hasChanged() )
     {
         m_aSystemPrintCommand = m_pQueueInfo->getCommand();
         m_pQueueInfo->getSystemQueues( m_aSystemPrintQueues );
@@ -1164,7 +1207,7 @@ void PrinterInfoManager::getSystemPrintC
 
 const std::list< OUString >& PrinterInfoManager::getSystemPrintQueues()
 {
-    if( m_pQueueInfo->hasChanged() )
+    if( m_pQueueInfo && m_pQueueInfo->hasChanged() )
     {
         m_aSystemPrintCommand = m_pQueueInfo->getCommand();
         m_pQueueInfo->getSystemQueues( m_aSystemPrintQueues );
@@ -1173,6 +1216,32 @@ const std::list< OUString >& PrinterInfo
     return m_aSystemPrintQueues;
 }
 
+FILE* PrinterInfoManager::startSpool( const OUString& rPrintername )
+{
+    const PrinterInfo&   rPrinterInfo	= getPrinterInfo (rPrintername);
+    const rtl::OUString& rCommand		= rPrinterInfo.m_aCommand;
+    const rtl::OString aShellCommand	= OUStringToOString (rCommand, RTL_TEXTENCODING_ISO_8859_1);
+													  
+    return popen (aShellCommand.getStr(), "w");
+}
+
+int PrinterInfoManager::endSpool( const OUString& rPrintername, const OUString& rJobTitle, FILE* pFile )
+{
+    pclose( pFile );
+    return 0; // job id ?
+}
+
+void PrinterInfoManager::setupJobContextData( JobData& rData )
+{
+    std::hash_map< OUString, Printer, OUStringHash >::iterator it =
+        m_aPrinters.find( rData.m_aPrinterName );
+    if( it != m_aPrinters.end() )
+    {
+        rData.m_pParser		= it->second.m_aInfo.m_pParser;
+        rData.m_aContext	= it->second.m_aInfo.m_aContext;
+    }
+}
+
 // -----------------------------------------------------------------
 
 SystemQueueInfo::SystemQueueInfo() :
@@ -1227,11 +1296,11 @@ static const struct SystemCommandParamet
      * printerinfomanager.hxx and are indexed by those constants.  ORDER IS IMPORTANT!!!
 	*/
     /* Apple LPR printing (kApplePrintingLPR) */
-    { "/usr/sbin/lpc status", "lpr -P (PRINTER)", "", ":", 0 },
+    { "/usr/bin/lpc status", "lpr -P (PRINTER)", "", ":", 0 },
     /* Apple CUPS printing (kApplePrintingCUPS) */
     { "LANG=C;LC_ALL=C;export LANG LC_ALL;/usr/bin/lpstat -s", "lp -d (PRINTER)", "device for ", ": ", 1 },
-    /* Apple New CUPS printing (kApplePrintingCUPS) */
-    { "LANG=C;LC_ALL=C;export LANG LC_ALL;/usr/bin/lpstat -s", "lp -d (PRINTER)", "device for ", ": ", 1 },
+    /* Apple Print Center printing (kApplePrintingPrintCenter) */
+    { kApplePCQueueName, kApplePCPrintCommand, "", ":", 0 }
 #else
     { "LANG=C;LC_ALL=C;export LANG LC_ALL;lpstat -s", "lp -d \"(PRINTER)\"", "system for ", ": ", 1 },
     { "/usr/sbin/lpc status", "lpr -P \"(PRINTER)\"", "", ":", 0 },
@@ -1241,19 +1310,9 @@ static const struct SystemCommandParamet
 
 void SystemQueueInfo::run()
 {
-
-#ifdef MACOSX
-    // FIXME: revisit this to see why MacOSX needs to grab the mutex earlier
-    // Workaround to allow MacOSX print queue detection to work
-    // Must grab the mutex as early as possible to make
-    // sure that run() actually runs before hasChanged() or
-    // getSystemQueues() get called by the PrinterInfoManager
-    MutexGuard aGuard( m_aMutex );
-#endif
-
     char pBuffer[1024];
     ByteString aPrtQueueCmd, aForeToken, aAftToken, aString;
-    int nForeTokenCount, i;
+    int nForeTokenCount = 0, i;
     FILE *pPipe;
     bool bSuccess = false;
     std::list< ByteString > aLines;
@@ -1279,6 +1338,22 @@ void SystemQueueInfo::run()
 #if OSL_DEBUG_LEVEL > 1
         fprintf( stderr, "trying print queue command \"%s\" ... ", aParms[i].pQueueCommand );
 #endif
+#ifdef MACOSX
+        /* For Mac OS X 10.1 Print Center printing, we only use the default queue.  We do not
+         * need to discover it.  So when it comes up in the list of possible queues,
+         * recognize it and declare success.
+         */
+        if ( applePrintSysType == kApplePrintingPrintCenter )
+        {
+            if ( strstr(aPrtQueueCmd.GetBuffer(), kApplePCQueueName) != NULL )
+                bSuccess = TRUE;
+#ifdef DEBUG
+            else
+                fprintf( stderr, "Ignoring print queue command \"%s\" because using 10.1 Print Center printing.\n", aParms[i].pQueueCommand );
+#endif
+        }
+        else
+#endif
         {
             if( pPipe = popen( aPrtQueueCmd.GetBuffer(), "r" ) )
             {
@@ -1293,7 +1368,27 @@ void SystemQueueInfo::run()
 #endif
     }
 
-   {
+#ifdef MACOSX
+    /* Since we only print to the default printer for MacOS X 10.1,
+     * queue discovery serves no purpose.
+     */
+    if ( applePrintSysType == kApplePrintingPrintCenter )
+    {
+        std::list< OUString > aSysPrintQueues;
+
+        aSysPrintQueues.push_back( OUString::createFromAscii(kApplePCQueueName) );
+      #ifdef DEBUG
+        fprintf( stderr, "printerinfomanager.cxx: using Print Center default print queue.\n" );
+      #endif
+
+        MutexGuard aGuard( m_aMutex );
+        m_bChanged	= true;
+        m_aQueues	= aSysPrintQueues;
+        m_aCommand	= aPrintCommand;
+    }
+    else
+#endif	/* MACOSX */
+    {
         /* Normal Unix print queue discovery, also used for Darwin 5 LPR printing
          * and MacOS X 10.2/Darwin 6 CUPS printing.
          */
@@ -1330,11 +1425,7 @@ void SystemQueueInfo::run()
                 }
             }
         
-#ifndef MACOSX
-            // FIXME: revisit this to see why MacOSX needs to grab the mutex earlier
-            // A specific MacOSX workaround grabbed this Mutex earlier so do not regrab
             MutexGuard aGuard( m_aMutex );
-#endif
             m_bChanged	= true;
             m_aQueues	= aSysPrintQueues;
             m_aCommand	= aPrintCommand;
@@ -1346,10 +1437,13 @@ void SystemQueueInfo::run()
 
 /* On Apple systems printing gets more complicated...
  * 1)  Darwin 5:     use straight lpr system, user has to configure lpr correctly
- * 2)  MacOS X 10.2: use CUPS duo of lpstat/lp
- * 3)  Darwin 6:     Like MacOS X 10.2, use CUPS
- * 4)  MacOS X 10.3:use New CUPS and duo lpstat/lp 
- * 5)  Darwin 7: Like MacOS X 10.3
+ * 2)  MacOS X 10.1: use /usr/sbin/Print which prints to default Print Center printer
+ * 3)  MacOS X 10.2: use CUPS duo of lpstat/lp
+ * 4)  Darwin 6:     Like MacOS X 10.2, use CUPS
+ *
+ * --- FIXME ---   We don't support printer choosing on MacOS X 10.1 at this time,
+ *                 only printing to default Print Center printer.  The user can
+ *                 change the default Print Center printer at any point however.
  */
 
 /*
@@ -1357,8 +1451,11 @@ void SystemQueueInfo::run()
  *
  * Find out which printing system/OS we are using.
  *
- * Darwin 5 is the fallback case.  For 10.2/Darwin 6, we attempt to find lpstat.
- * For 10.3/Darwin 7, we attempt to fid pstopdf
+ * Darwin 5 is the fallback case.  To check for 10.1 printing we try to see if
+ * /usr/sbin/Print exists.  For 10.2/Darwin 6, we attempt to find lpstat.  Users
+ * might also have installed CUPS on Darwin 5 or MacOS X 10.1, but we default to
+ * Print Center (/usr/sbin/Print) printing on 10.1.
+ *
  */
 sal_Int32 macxp_GetSystemPrintMethod( void )
 {
@@ -1369,13 +1466,13 @@ sal_Int32 macxp_GetSystemPrintMethod( vo
      /* Attempt to find out which OS we are on... */
      applePrintSysType = kApplePrintingLPR;
 	
-     /* Check for MacOS X 10.3 and later CUPS first. */
-     err = stat( "/usr/bin/pstopdf", &status );
+     /* Check for MacOS X 10.1 first. */
+     err = stat( "/usr/sbin/Print", &status );
      if ( err == 0 )
      {
-          applePrintSysType = kApplePrintingNewCUPS;
+          applePrintSysType = kApplePrintingPrintCenter;
           #ifdef DEBUG
-               fprintf( stderr, "printerinfomanager.cxx:  found MacOS X 10.3 or later type printing system.\n" );
+               fprintf( stderr, "printerinfomanager.cxx:  found MacOS X 10.1-type printing system.\n" );
           #endif
      }
      else
Index: psprint/source/printergfx/bitmap_gfx.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/bitmap_gfx.cxx,v
retrieving revision 1.6
retrieving revision 1.8
diff -u -p -u -r1.6 -r1.8
--- psprint/source/printergfx/bitmap_gfx.cxx	26 Mar 2003 14:24:07 -0000	1.6
+++ psprint/source/printergfx/bitmap_gfx.cxx	17 Mar 2004 10:51:59 -0000	1.8
@@ -71,8 +71,8 @@
 
 namespace psp {
 
-const sal_Int32 nLineLength = 80;
-const sal_Int32 nBufferSize = 16384;
+const sal_uInt32 nLineLength = 80;
+const sal_uInt32 nBufferSize = 16384;
 
 /*
  * 
@@ -197,9 +197,9 @@ public:
 
 Ascii85Encoder::Ascii85Encoder (osl::File* pFile) :
         mpFile (pFile),
-        mnOffset (0),
+        mnByte (0),
         mnColumn (0),
-        mnByte (0)
+        mnOffset (0)
 {}
 
 inline void
@@ -591,13 +591,14 @@ PrinterGfx::writePS2ImageHeader (const R
     sal_Int32 nChar = 0;
     sal_Char  pImage [512];
 
-    sal_Int32 nDictType;
+    sal_Int32 nDictType = 0;
     switch (nType)
     {
         case psp::TrueColorImage:  nDictType = 0; break;
         case psp::PaletteImage:    nDictType = 1; break;
         case psp::GrayScaleImage:  nDictType = 2; break;
         case psp::MonochromeImage: nDictType = 3; break;
+        default: break;
     }
     sal_Int32 nCompressType = mbCompressBmp ? 1 : 0;
 
@@ -630,14 +631,15 @@ PrinterGfx::writePS2Colorspace(const Pri
 
         case psp::MonochromeImage: 
         case psp::PaletteImage:
+        {
 
             sal_Int32 nChar = 0;
             sal_Char  pImage [4096];
 
-            sal_Int32 nSize = rBitmap.GetPaletteEntryCount() - 1;
+            const sal_uInt32 nSize = rBitmap.GetPaletteEntryCount();
 
             nChar += psp::appendStr ("[/Indexed /DeviceRGB ", pImage + nChar);
-            nChar += psp::getValueOf (rBitmap.GetPaletteEntryCount() - 1, pImage + nChar);
+            nChar += psp::getValueOf (nSize - 1, pImage + nChar);
             if (mbCompressBmp)
                 nChar += psp::appendStr ("\npsp_lzwstring\n", pImage + nChar);
             else
@@ -646,7 +648,7 @@ PrinterGfx::writePS2Colorspace(const Pri
 
             ByteEncoder* pEncoder = mbCompressBmp ? new LZWEncoder(mpPageBody) 
                                                   : new Ascii85Encoder(mpPageBody);
-            for (sal_Int32 i = 0; i < rBitmap.GetPaletteEntryCount(); i++)
+            for (sal_uInt32 i = 0; i < nSize; i++)
             {
                 PrinterColor aColor = rBitmap.GetPaletteColor(i);
 
@@ -657,8 +659,9 @@ PrinterGfx::writePS2Colorspace(const Pri
             delete pEncoder;
           
             WritePS (mpPageBody, "pop ] setcolorspace\n");
-  
-            break;
+        }
+        break;
+        default: break;
     }
 }
 
Index: psprint/source/printergfx/common_gfx.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/common_gfx.cxx,v
retrieving revision 1.11.44.2
retrieving revision 1.15
diff -u -p -u -r1.11.44.2 -r1.15
--- psprint/source/printergfx/common_gfx.cxx	2 Apr 2004 12:15:06 -0000	1.11.44.2
+++ psprint/source/printergfx/common_gfx.cxx	18 May 2004 10:46:21 -0000	1.15
@@ -94,7 +94,9 @@ static const sal_Int32 nMaxTextColumn = 
 GraphicsStatus::GraphicsStatus() :
         mnTextHeight( 0 ),
         mnTextWidth( 0 ),
-        mfLineWidth( -1 )
+        mfLineWidth( -1 ),
+        mbArtItalic( false ),
+        mbArtBold( false )
 {
 }
 
@@ -131,8 +133,8 @@ PrinterGfx::Init (const JobData& rData)
     mpPageHeader    = NULL;
     mpPageBody      = NULL;
     mnDepth         = rData.m_nColorDepth;
-    mnPSLevel       = rData.m_nPSLevel ? rData.m_nPSLevel : rData.m_pParser->getLanguageLevel();
-    mbColor         = rData.m_nColorDevice ? ( rData.m_nColorDevice == -1 ? sal_False : sal_True ) : ( rData.m_pParser->isColorDevice() ? sal_True : sal_False );
+    mnPSLevel       = rData.m_nPSLevel ? rData.m_nPSLevel : (rData.m_pParser ? rData.m_pParser->getLanguageLevel() : 2 );
+    mbColor         = rData.m_nColorDevice ? ( rData.m_nColorDevice == -1 ? sal_False : sal_True ) : (( rData.m_pParser ?  (rData.m_pParser->isColorDevice() ? sal_True : sal_False ) : sal_True ) );
     int nRes = rData.m_aContext.getRenderResolution();
     mnDpi           = nRes;
     mfScaleX        = (double)72.0 / (double)mnDpi;
@@ -174,12 +176,13 @@ PrinterGfx::PrinterGfx() : 
         mpPageBody (NULL),
         mnFontID (0),
         mnFallbackID (0),
-        maLineColor (0, 0xff, 0),
-        maFillColor (0xff,0,0),
-        maTextColor (0,0,0),
+        mnTextAngle (0),
         mbTextVertical (false),
         mrFontMgr (PrintFontManager::get()),
         mbCompressBmp (sal_True),
+        maFillColor (0xff,0,0),
+        maTextColor (0,0,0),
+        maLineColor (0, 0xff, 0),
         mpFontSubstitutes( NULL )
 {
     maVirtualStatus.mfLineWidth = 1.0;
@@ -489,7 +492,7 @@ PrinterGfx::DrawPolygon (sal_uInt32 nPoi
         
     PSBinStartPath();
     PSBinMoveTo( pPath[0], aPoint, nColumn );
-    for( int n = 1; n < nPoints; n++ )
+    for( unsigned int n = 1; n < nPoints; n++ )
         PSBinLineTo( pPath[n], aPoint, nColumn );
     if( pPath[0] != pPath[nPoints-1] )
         PSBinLineTo( pPath[0], aPoint, nColumn );
@@ -531,14 +534,14 @@ PrinterGfx::DrawPolyPolygon (sal_uInt32 
 
 
     // setup closed path
-    for( int i = 0; i < nPoly; i++ )
+    for( unsigned int i = 0; i < nPoly; i++ )
     {
         Point aPoint( 0, 0 );
         sal_Int32 nColumn( 0 );
         
         PSBinStartPath();
         PSBinMoveTo( pPaths[i][0], aPoint, nColumn );
-        for( int n = 1; n < pSizes[i]; n++ )
+        for( unsigned int n = 1; n < pSizes[i]; n++ )
             PSBinLineTo( pPaths[i][n], aPoint, nColumn );
         if( pPaths[i][0] != pPaths[i][pSizes[i]-1] )
                 PSBinLineTo( pPaths[i][0], aPoint, nColumn );
@@ -593,25 +596,25 @@ PrinterGfx::DrawPolyLineBezier (sal_uInt
         }
         else
         {
-            snprintf(pString, nBezString, "%i %i moveto\n", pPath[0].X(), pPath[0].Y());
+            snprintf(pString, nBezString, "%li %li moveto\n", pPath[0].X(), pPath[0].Y());
             WritePS(mpPageBody, pString);
         }
         
         // Handle the drawing of mixed lines mixed with curves 
         // - a normal point followed by a normal point is a line
         // - a normal point followed by 2 control points and a normal point is a curve
-        for (int i=1; i<nPoints;)
+        for (unsigned int i=1; i<nPoints;)
         {
             if (pFlgAry[i+1] != POLY_CONTROL) //If the next point is a POLY_NORMAL, we're drawing a line
             {
                 if (i+1 >= nPoints) return; //Make sure we don't pass the end of the array
-                snprintf(pString, nBezString, "%i %i lineto\n", pPath[i].X(), pPath[i].Y());
+                snprintf(pString, nBezString, "%li %li lineto\n", pPath[i].X(), pPath[i].Y());
                 i++;
             }
             else //Otherwise we're drawing a spline
             {
                 if (i+3 >= nPoints) return; //Make sure we don't pass the end of the array
-                snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                         pPath[i+1].X(), pPath[i+1].Y(),
                         pPath[i+2].X(), pPath[i+2].Y(),
                         pPath[i+3].X(), pPath[i+3].Y());
@@ -656,13 +659,13 @@ PrinterGfx::DrawPolygonBezier (sal_uInt3
     if (!(nPoints > 1) || (pPath == NULL) || !(maFillColor.Is() || maLineColor.Is()))
         return;
     
-    snprintf(pString, nBezString, "%i %i moveto\n", pPath[0].X(), pPath[0].Y());
+    snprintf(pString, nBezString, "%li %li moveto\n", pPath[0].X(), pPath[0].Y());
     WritePS(mpPageBody, pString); //Move to the starting point for the PolyPoygon
-    for (int i=1; i < nPoints;) 
+    for (unsigned int i=1; i < nPoints;) 
     {
         if (pFlgAry[i] != POLY_CONTROL)
         {
-            snprintf(pString, nBezString, "%i %i lineto\n", pPath[i].X(), pPath[i].Y());
+            snprintf(pString, nBezString, "%li %li lineto\n", pPath[i].X(), pPath[i].Y());
             WritePS(mpPageBody, pString);
             i++;
         }
@@ -673,7 +676,7 @@ PrinterGfx::DrawPolygonBezier (sal_uInt3
             if ((pFlgAry[i] == POLY_CONTROL) && (pFlgAry[i+1] == POLY_CONTROL) &&
                     (pFlgAry[i+2] != POLY_CONTROL))
             {
-                snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                         pPath[i].X(), pPath[i].Y(), 
                         pPath[i+1].X(), pPath[i+1].Y(), 
                         pPath[i+2].X(), pPath[i+2].Y());
@@ -712,22 +715,22 @@ PrinterGfx::DrawPolyPolygonBezier (sal_u
         return;
     
     
-    for (int i=0; i<nPoly;i++)
+    for (unsigned int i=0; i<nPoly;i++)
     {
         sal_uInt32 nPoints = pPoints[i];
         // #112689# sanity check
         if( nPoints == 0 || pPtAry[i] == NULL )
             continue;
         
-        snprintf(pString, nBezString, "%i %i moveto\n", pPtAry[i][0].X(), pPtAry[i][0].Y()); //Move to the starting point
+        snprintf(pString, nBezString, "%li %li moveto\n", pPtAry[i][0].X(), pPtAry[i][0].Y()); //Move to the starting point
         WritePS(mpPageBody, pString);
-        for (int j=1; j < nPoints;)
+        for (unsigned int j=1; j < nPoints;)
         {
             // if no flag array exists for this polygon, then it must be a regular
             // polygon without beziers
             if ( ! pFlgAry[i] || pFlgAry[i][j] != POLY_CONTROL)
             {
-                snprintf(pString, nBezString, "%i %i lineto\n", pPtAry[i][j].X(), pPtAry[i][j].Y());
+                snprintf(pString, nBezString, "%li %li lineto\n", pPtAry[i][j].X(), pPtAry[i][j].Y());
                 WritePS(mpPageBody, pString);
                 j++;
             }
@@ -737,7 +740,7 @@ PrinterGfx::DrawPolyPolygonBezier (sal_u
                     break; //Error: wrong sequence of contol/normal points somehow
                 if ((pFlgAry[i][j] == POLY_CONTROL) && (pFlgAry[i][j+1] == POLY_CONTROL) && (pFlgAry[i][j+2] != POLY_CONTROL))
                 {
-                    snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                    snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                             pPtAry[i][j].X(), pPtAry[i][j].Y(), 
                             pPtAry[i][j+1].X(), pPtAry[i][j+1].Y(), 
                             pPtAry[i][j+2].X(), pPtAry[i][j+2].Y());
@@ -849,15 +852,20 @@ void
 PrinterGfx::PSSetFont ()
 {
     GraphicsStatus& rCurrent( currentState() );
-    if( maVirtualStatus.maFont           != rCurrent.maFont         ||
-        maVirtualStatus.mnTextHeight     != rCurrent.mnTextHeight   ||
-        maVirtualStatus.maEncoding       != rCurrent.maEncoding     ||
-        maVirtualStatus.mnTextWidth      != rCurrent.mnTextWidth )
+    if( maVirtualStatus.maFont			!= rCurrent.maFont			||
+        maVirtualStatus.mnTextHeight	!= rCurrent.mnTextHeight	||
+        maVirtualStatus.maEncoding      != rCurrent.maEncoding		||
+        maVirtualStatus.mnTextWidth     != rCurrent.mnTextWidth		||
+        maVirtualStatus.mbArtBold		!= rCurrent.mbArtBold		||
+        maVirtualStatus.mbArtItalic		!= rCurrent.mbArtItalic
+        )
     {
         rCurrent.maFont              = maVirtualStatus.maFont;
         rCurrent.maEncoding          = maVirtualStatus.maEncoding;
         rCurrent.mnTextWidth         = maVirtualStatus.mnTextWidth;
         rCurrent.mnTextHeight        = maVirtualStatus.mnTextHeight;
+        rCurrent.mbArtItalic		 = maVirtualStatus.mbArtItalic;
+        rCurrent.mbArtBold			 = maVirtualStatus.mbArtBold;
 
         sal_Int32 nTextHeight = rCurrent.mnTextHeight;
         sal_Int32 nTextWidth  = rCurrent.mnTextWidth ? rCurrent.mnTextWidth 
@@ -894,10 +902,24 @@ PrinterGfx::PSSetFont ()
                                                     pSetFont + nChar);
         }
 
-        nChar += psp::getValueOf (nTextWidth,   pSetFont + nChar);
-        nChar += psp::appendStr  (" ",          pSetFont + nChar);
-        nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
-        nChar += psp::appendStr  (" matrix scale makefont setfont\n", pSetFont + nChar);
+        if( ! rCurrent.mbArtItalic )
+        {
+            nChar += psp::getValueOf (nTextWidth,   pSetFont + nChar);
+            nChar += psp::appendStr  (" ",          pSetFont + nChar);
+            nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
+            nChar += psp::appendStr  (" matrix scale makefont setfont\n", pSetFont + nChar);
+        }
+        else // skew 15 degrees to right
+        {
+            nChar += psp::appendStr  ( " [",		pSetFont + nChar);
+            nChar += psp::getValueOf (nTextWidth,	pSetFont + nChar);
+            nChar += psp::appendStr  (" 0 ",        pSetFont + nChar);
+            nChar += psp::getValueOfDouble (pSetFont + nChar, 0.27*(double)nTextWidth, 3 );
+            nChar += psp::appendStr  ( " ",			pSetFont + nChar);
+            nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
+            
+            nChar += psp::appendStr  (" 0 0] makefont setfont\n", pSetFont + nChar);
+        }
 
         WritePS (mpPageBody, pSetFont);
     }
@@ -1023,7 +1045,7 @@ PrinterGfx::PSBinCurrentPath (sal_uInt32
 
     PSBinStartPath ();
     PSBinMoveTo (*pPath, aPoint, nColumn);
-    for (int i = 1; i < nPoints; i++)
+    for (unsigned int i = 1; i < nPoints; i++)
         PSBinLineTo (pPath[i], aPoint, nColumn);
     PSBinEndPath ();
 }
@@ -1168,17 +1190,40 @@ PrinterGfx::PSShowText (const sal_uChar*
         PSRotate (mnTextAngle);
     }
 
+    sal_Char pBuffer[256];
+    if( maVirtualStatus.mbArtBold )
+    {
+        sal_Int32 nLW = maVirtualStatus.mnTextWidth;
+        if( nLW == 0 )
+            nLW = maVirtualStatus.mnTextHeight;
+        else
+            nLW = nLW < maVirtualStatus.mnTextHeight ? nLW : maVirtualStatus.mnTextHeight;
+        psp::getValueOfDouble( pBuffer, (double)nLW / 30.0 );
+    }
     // dispatch to the drawing method
     if (pDeltaArray == NULL)
     {
         PSHexString (pStr, nBytes);
-        WritePS (mpPageBody, "show\n");
+            
+        if( maVirtualStatus.mbArtBold )
+        {
+            WritePS( mpPageBody, pBuffer );
+            WritePS( mpPageBody, " bshow\n" );
+        }
+        else
+            WritePS (mpPageBody, "show\n");
     }
     else
     {
         PSHexString (pStr, nBytes);
         PSDeltaArray (pDeltaArray, nGlyphs - 1);
-        WritePS (mpPageBody, "xshow\n");
+        if( maVirtualStatus.mbArtBold )
+        {
+            WritePS( mpPageBody, pBuffer );
+            WritePS( mpPageBody, " bxshow\n" );
+        }
+        else
+            WritePS (mpPageBody, "xshow\n");
     }
 
     // restore the user coordinate system   
@@ -1210,6 +1255,8 @@ PrinterGfx::DrawEPS( const Rectangle& rB
 {
     if( nSize == 0 )
         return sal_True;
+    if( ! mpPageBody )
+        return sal_False;
 
     sal_Bool bSuccess = sal_False;
 
@@ -1263,10 +1310,8 @@ PrinterGfx::DrawEPS( const Rectangle& rB
     {
         double fScaleX = (double)rBoundingBox.GetWidth()/(fRight-fLeft);
         double fScaleY = -(double)rBoundingBox.GetHeight()/(fTop-fBottom);
-        Point aTranslatePoint( rBoundingBox.Left()-fLeft*fScaleX,
-                               rBoundingBox.Bottom()+1-fBottom*fScaleY );
-        char buffer[128];
-
+        Point aTranslatePoint( (int)(rBoundingBox.Left()-fLeft*fScaleX),
+                               (int)(rBoundingBox.Bottom()+1-fBottom*fScaleY) );
         // prepare EPS
         WritePS( mpPageBody,
                  "/b4_Inc_state save def\n"

Index: psprint/source/printergfx/printerjob.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/printerjob.cxx,v
retrieving revision 1.21.44.4.4.1
retrieving revision 1.28
diff -u -p -u -r1.21.44.4.4.1 -r1.28
--- psprint/source/printergfx/printerjob.cxx	9 May 2004 15:21:15 -0000	1.21.44.4.4.1
+++ psprint/source/printergfx/printerjob.cxx	18 May 2004 10:46:35 -0000	1.28
@@ -107,7 +107,8 @@
 
 #include "glyphset.hxx"
 
-using namespace psp ;
+using namespace psp;
+using namespace rtl;
 
 #ifdef MACOSX
 // Prototype our MacOS X printing help function
@@ -143,8 +144,8 @@ AppendPS (FILE* pDst, osl::File* pSrc, s
 
     pSrc->setPos (osl_Pos_Absolut, 0);
 
-    sal_uInt64 nIn;
-    sal_uInt64 nOut;
+    sal_uInt64 nIn = 0;
+    sal_uInt64 nOut = 0;
     do
     {
         pSrc->read  (pBuffer, nBlockSize, nIn);
@@ -267,8 +268,8 @@ PrinterJob::GetCurrentPageBody ()
  */ 
 
 PrinterJob::PrinterJob () :
-        mpJobTrailer (NULL),
-        mpJobHeader (NULL)
+        mpJobHeader (NULL),
+        mpJobTrailer (NULL)
 {
 }
 
@@ -446,11 +447,13 @@ PrinterJob::StartJob (
     maFileName = rFileName;
     mnFileMode = nMode;
     maSpoolDirName = createSpoolDir ();
-    maJobName = rJobName;
+    maJobTitle = rJobName;
 
     rtl::OUString aExt = rtl::OUString::createFromAscii (".ps");
     mpJobHeader  = CreateSpoolFile (rtl::OUString::createFromAscii("psp_head"), aExt);
     mpJobTrailer = CreateSpoolFile (rtl::OUString::createFromAscii("psp_tail"), aExt);
+    if( ! (mpJobHeader && mpJobTrailer) ) // existing files are removed in destructor
+        return sal_False;
 
     // write document header according to Document Structuring Conventions (DSC)
     WritePS (mpJobHeader,
@@ -481,6 +484,7 @@ PrinterJob::StartJob (
 
     // Document Title
     aFilterWS = WhitespaceToSpace( rJobName, FALSE );
+    maJobTitle = aFilterWS;
     WritePS (mpJobHeader, "%%Title: "); 
     WritePS (mpJobHeader, aFilterWS);
     WritePS (mpJobHeader, "\n");
@@ -500,7 +504,7 @@ PrinterJob::StartJob (
     WritePS (mpJobHeader, "%%EndComments\n");
 
     // write Prolog
-    writeProlog (mpJobHeader);
+    writeProlog (mpJobHeader, rSetupData);
 
     // mark last job setup as not set
     m_aLastJobData.m_pParser = NULL;
@@ -519,8 +523,11 @@ PrinterJob::EndJob ()
 
     // write document setup (done here because it
     // includes the accumulated fonts
-    writeSetup( mpJobHeader, m_aDocumentJobData );
+    if( mpJobHeader )
+        writeSetup( mpJobHeader, m_aDocumentJobData );
     m_pGraphics->OnEndJob();
+    if( ! (mpJobHeader && mpJobTrailer) )
+        return sal_False;
 
     // write document trailer according to Document Structuring Conventions (DSC)
     rtl::OStringBuffer aTrailer(512);
@@ -575,6 +582,12 @@ PrinterJob::EndJob ()
     }
     else
     {
+#ifndef MACOSX
+        PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get ();
+        pDestFILE = rPrinterInfoManager.startSpool( m_aLastJobData.m_aPrinterName );
+        if (pDestFILE == NULL)
+            return sal_False;
+#else
         const PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get ();
         const rtl::OUString& rPrinter     = m_aLastJobData.m_aPrinterName;
         const PrinterInfo&   rPrinterInfo = rPrinterInfoManager.getPrinterInfo (rPrinter);
@@ -587,26 +600,19 @@ PrinterJob::EndJob ()
          *           All other OS X/Darwin cases use spool to file.
 	    * Other UNIX:  always open a pipe.
          */
-        if (
-           #ifdef MACOSX
-               applePrintSysType == kApplePrintingLPR
-           #else
-               sal_True
-           #endif
-           )
+        if ( applePrintSysType == kApplePrintingLPR )
         {
             pDestFILE = popen (aShellCommand.getStr(), "w");
             if (pDestFILE == NULL)
                 return sal_False;
         }
-     #ifdef MACOSX
         else
         {
             /* Spool to file instead so we can convert it.  Cases used here:
-             * 1) kApplePrintingCUPS && kApplePrintingUsePDF
-             * 2) kApplePrintingCUPS && kApplePrintingUsePS
-             * 3) kApplePrintingNewCUPS && kApplePrintingUseNewPDF
-             * 2) kApplePrintingNewCUPS && kApplePrintingUsePS
+             * 1) kApplePrintingPrintCenter && kApplePrintingUsePDF
+             * 2) kApplePrintingPrintCenter && kApplePrintingUsePS
+             * 3) kApplePrintingCUPS && kApplePrintingUsePDF
+             * 4) kApplePrintingCUPS && kApplePrintingUsePS
              */
 
             /* Get a temporary file name for the spool file.
@@ -624,7 +630,7 @@ PrinterJob::EndJob ()
                 return sal_False;
             }
         }
-     #endif
+#endif
     }
 
     /* spool the document parts to the destination */
@@ -633,25 +639,36 @@ PrinterJob::EndJob ()
 
     AppendPS (pDestFILE, mpJobHeader, pBuffer);
     mpJobHeader->close();
-    
+
+    sal_Bool bSuccess = sal_True;
     std::list< osl::File* >::iterator pPageBody;
     std::list< osl::File* >::iterator pPageHead;
     for (pPageBody  = maPageList.begin(), pPageHead  = maHeaderList.begin();
          pPageBody != maPageList.end() && pPageHead != maHeaderList.end(); 
          pPageBody++, pPageHead++)
     {
-        osl::File::RC nError = (*pPageHead)->open(OpenFlag_Read);
-        if (nError == osl::File::E_None)
+        if( *pPageHead )
         {
-            AppendPS (pDestFILE, *pPageHead, pBuffer);
-            (*pPageHead)->close();
+            osl::File::RC nError = (*pPageHead)->open(OpenFlag_Read);
+            if (nError == osl::File::E_None)
+            {
+                AppendPS (pDestFILE, *pPageHead, pBuffer);
+                (*pPageHead)->close();
+            }
         }
-        nError = (*pPageBody)->open(OpenFlag_Read);
-        if (nError == osl::File::E_None)
+        else
+            bSuccess = sal_False;
+        if( *pPageBody )
         {
-            AppendPS (pDestFILE, *pPageBody, pBuffer);
-            (*pPageBody)->close();
+            osl::File::RC nError = (*pPageBody)->open(OpenFlag_Read);
+            if (nError == osl::File::E_None)
+            {
+                AppendPS (pDestFILE, *pPageBody, pBuffer);
+                (*pPageBody)->close();
+            }
         }
+        else
+            bSuccess = sal_False;
     }
     
     AppendPS (pDestFILE, mpJobTrailer, pBuffer);
@@ -662,8 +679,13 @@ PrinterJob::EndJob ()
     if (bSpoolToFile)
         fclose (pDestFILE);
     else
+#ifndef MACOSX
+    {
+        PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get();
+        rPrinterInfoManager.endSpool( m_aLastJobData.m_aPrinterName, maJobTitle, pDestFILE );
+    }
+#else
     {
-        #ifdef MACOSX
             sal_uInt32	nXdpi;
             sal_uInt32	nYdpi;
 
@@ -691,14 +713,9 @@ PrinterJob::EndJob ()
                                            aShellCommand,
                                            aDriverName,
                                            m_aLastJobData,
-                                           &maJobName,
+                                           &maJobTitle,
                                            mnResolution );
-        #else
-            pclose (pDestFILE);
-        #endif
     }
-
-#ifdef MACOSX
     /* If we created a spool file for our Mac OS X/Darwin job,
      * delete it.  Also free the variable, since it is malloc()ed in macxp_tempnam()
      * and otherwise we'd leak memory.
@@ -710,7 +727,7 @@ PrinterJob::EndJob ()
     }
 #endif
 
-    return sal_True;
+    return bSuccess;
 }
 
 #ifdef MACOSX
@@ -754,46 +771,73 @@ void macxp_ProcessAndPrintDocument( sal_
          * "cupsFilter" key, or if the "cupsFilter" key _doesn't_ contain "application/pdf",
          * then we print directly with PostScript.
          */
-
-        /* For Jaguar default to using PDF unless no PDF filter in ppd */
-        if (applePrintSysType==kApplePrintingCUPS) {
-            printFormat = kApplePrintingUsePDF;
-            if ( (sal_False == psprintDriverName.equals("SGENPRT")) && (sal_False == psprintDriverName.equals("MacShared")) )
+        printFormat = kApplePrintingUsePDF;
+        if ( (sal_False == psprintDriverName.equals("SGENPRT")) && (sal_False == psprintDriverName.equals("MacShared")) )
+        {
+            /* The should exist a valid PPD for this printer */
+            if ( pJobData.m_pParser )
             {
-                /* The should exist a valid PPD for this printer */
-                if ( pJobData.m_pParser )
-                {
-                    const PPDKey    *pCupsFilterKey;
-                    const PPDValue  *pCupsFilterValue;
+                const PPDKey    *pCupsFilterKey;
+                const PPDValue  *pCupsFilterValue;
 
-                    pCupsFilterKey = pJobData.m_pParser->getKey( String(RTL_CONSTASCII_USTRINGPARAM("cupsFilter")) );
-                    pCupsFilterValue = pCupsFilterKey != NULL ? pJobData.m_aContext.getValue( pCupsFilterKey ) : NULL;
-                    if ( pCupsFilterValue )
-                    {
-                        ByteString    aCupsFilterString( pCupsFilterValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 );
-                        if ( aCupsFilterString.Search("application/pdf") == 0 )
-                        {
-                            /* cupsFilter didn't have application/pdf */
-                            printFormat = kApplePrintingUsePS;
-                        }
-                    }
-                    else
+                pCupsFilterKey = pJobData.m_pParser->getKey( String(RTL_CONSTASCII_USTRINGPARAM("cupsFilter")) );
+                pCupsFilterValue = pCupsFilterKey != NULL ? pJobData.m_aContext.getValue( pCupsFilterKey ) : NULL;
+                if ( pCupsFilterValue )
+                {
+                    ByteString    aCupsFilterString( pCupsFilterValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 );
+                    if ( aCupsFilterString.Search("application/pdf") == 0 )
                     {
-                        /* No "cupsFilter" key */
+                        /* cupsFilter didn't have application/pdf */
                         printFormat = kApplePrintingUsePS;
                     }
                 }
+                else
+                {
+                    /* No "cupsFilter" key */
+                    printFormat = kApplePrintingUsePS;
+                }
             }
-	}
-
-        /* For Panther and later simply use PS and let the new CUPS handle any conversions via filters */
-        if (applePrintSysType==kApplePrintingNewCUPS) {         
-            printFormat = kApplePrintingUsePS;
         }
 
+        if ( (applePrintSysType==kApplePrintingPrintCenter) && (printFormat==kApplePrintingUsePS) )
+        {		  
+            /* Now pass the PS file to /usr/sbin/Print for printing. */
+            snprintf( sysCommandBuffer, kSysCommandBufferLen-1, "%s -M ps \"%s\"", kApplePCPrintCommand, spoolFileName );
+            #ifdef DEBUG
+                fprintf( stderr, "printerjob.cxx: printing doc with command '%s'\n", sysCommandBuffer );
+            #endif
 
-        if ( ((applePrintSysType==kApplePrintingCUPS) || (applePrintSysType==kApplePrintingNewCUPS)) 
-             && ((printFormat==kApplePrintingUsePDF) || (printFormat==kApplePrintingUsePS)) )
+            printCmdErr = system( sysCommandBuffer );
+        }
+        else if ( (applePrintSysType==kApplePrintingPrintCenter) && (printFormat==kApplePrintingUsePDF) )
+        {
+            char	pdfFileName[ kPDFFileNameBufferLen ];
+            char	pdfFileNameMacFormat[ kPDFFileNameBufferLen ];
+            char	*c;
+            
+            /* Convert file to PDF using GhostScript */
+            printCmdErr =  macxp_ConvertPSFileToPDF( spoolFileName, pdfFileName, kPDFFileNameBufferLen, jobDPI );
+            if ( printCmdErr == 0 )
+		  {
+                /* AppleScript expects MacOS-style paths, so convert Unix path to Mac OS Style.
+                 * If the Unix path is absolute, get rid of the starting slash
+                 */
+                strncpy( pdfFileNameMacFormat, pdfFileName, kPDFFileNameBufferLen-1 );
+                if ( *pdfFileNameMacFormat == '/' )
+                    strncpy( pdfFileNameMacFormat, pdfFileName+1, kPDFFileNameBufferLen-2 );
+                while ( (c=strchr(pdfFileNameMacFormat,'/')) != NULL )
+                    *c = ':';
+            
+                /* Construct and execute the actual printing command using AppleScript */
+                snprintf( sysCommandBuffer, kSysCommandBufferLen-1, "/usr/bin/osascript -e 'tell application \"Finder\"' -e 'print {file \"%s\"}' -e 'end tell'", pdfFileNameMacFormat );
+                #ifdef DEBUG
+                    fprintf( stderr, "printerjob.cxx: printing PDF with command '%s'\n", sysCommandBuffer );
+                #endif
+                printCmdErr = system( sysCommandBuffer );
+            }
+		  unlink( pdfFileName );
+        }
+        else if ( (applePrintSysType==kApplePrintingCUPS) && ((printFormat==kApplePrintingUsePDF) || (printFormat==kApplePrintingUsePS)) )
         {
             char	     pdfFileName[ kPDFFileNameBufferLen ];
             char         numCopiesSwitch[ 5 ];
@@ -923,18 +967,19 @@ int macxp_ConvertPSFileToPDF( char *psFi
 
         /* Create the file name for the converted PDF and assemble the conversion command */
         snprintf( pdfFileName, pdfFileNameBufferLen-1, "%s%s", psFileName, kPDFFileExtension );
-	   
-	   sysCommandBuffer = (char *)malloc( sizeof(char) * ( strlen(kSysPrintSetupString) +
+	   int nBufferSize = sizeof(char) * ( strlen(kSysPrintSetupString) +
 	                                               strlen(kApplePS2PDFLocation) +
                                                     10 +	/* For " -r<DPI>" */
                                                     strlen(psFileName) +
                                                     strlen(pdfFileName) +
-                                                    10) );  /*  10 bytes fudge factor */
+                                          10);  /*  10 bytes fudge factor */
+       
+	   sysCommandBuffer = (char *)malloc( nBufferSize ); 
         if ( sysCommandBuffer == NULL )
             returnVal = -1;
         else
 	   {
-            sprintf( sysCommandBuffer, "%s;%s -r%d \"%s\" \"%s\"'", kSysPrintSetupString, kApplePS2PDFLocation, jobDPI, psFileName, pdfFileName );
+            snprintf( sysCommandBuffer, nBufferSize, "%s;%s -r%d \"%s\" \"%s\"'", kSysPrintSetupString, kApplePS2PDFLocation, jobDPI, psFileName, pdfFileName );
           #ifdef DEBUG
                 fprintf( stderr, "printerjob.cxx: converting document to PDF with command '%s'\n", sysCommandBuffer );
           #endif
@@ -1014,6 +1059,9 @@ PrinterJob::StartPage (const JobData& rJ
     maHeaderList.push_back (pPageHeader);
     maPageList.push_back (pPageBody);
 
+    if( ! (pPageHeader && pPageBody) )
+        return sal_False;
+
     /* #i7262# write setup only before first page
      *  don't do this in StartJob since the jobsetup there may be
      *  different.
@@ -1061,6 +1109,9 @@ PrinterJob::EndPage ()
     osl::File* pPageHeader = maHeaderList.back();
     osl::File* pPageBody   = maPageList.back();
 
+    if( ! (pPageBody && pPageHeader) )
+        return sal_False;
+
     // copy page to paper and write page trailer according to DSC
 
     sal_Char pTrailer[256];
@@ -1116,7 +1167,7 @@ bool PrinterJob::writeFeatureList( osl::
 
     // emit features ordered to OrderDependency
     // ignore features that are set to default
-    const PPDContext& rContext = rJob.m_aContext;
+
     // sanity check
     if( rJob.m_pParser == rJob.m_aContext.getParser() &&
         rJob.m_pParser &&
@@ -1223,10 +1274,55 @@ bool PrinterJob::writePageSetup( osl::Fi
     return bSuccess;
 }
 
-bool PrinterJob::writeProlog (osl::File* pFile)
+void PrinterJob::writeJobPatch( osl::File* pFile, const JobData& rJobData )
+{
+    const PPDKey* pKey = NULL;
+    
+    if( rJobData.m_pParser )
+        pKey = rJobData.m_pParser->getKey( OUString( RTL_CONSTASCII_USTRINGPARAM( "JobPatchFile" ) ) );
+    if( ! pKey )
+        return;
+
+    // order the patch files
+    // according to PPD spec the JobPatchFile options must be int
+    // and should be emitted in order
+    std::list< sal_Int32 > patch_order;
+    int nValueCount = pKey->countValues();
+    for( int i = 0; i < nValueCount; i++ )
+    {
+        const PPDValue* pVal = pKey->getValue( i );
+        patch_order.push_back( pVal->m_aOption.ToInt32() );
+        if( patch_order.back() == 0 && ! pVal->m_aOption.EqualsAscii( "0" ) )
+        {
+            WritePS( pFile, "% Warning: left out JobPatchFile option \"" );
+            OString aOption = OUStringToOString( pVal->m_aOption, RTL_TEXTENCODING_ASCII_US );
+            WritePS( pFile, aOption.getStr() );
+            WritePS( pFile,
+                     "\"\n% as it violates the PPD spec;\n"
+                     "% JobPatchFile options need to be numbered for ordering.\n" );
+        }
+    }
+
+    patch_order.sort();
+    patch_order.unique();
+
+    while( patch_order.begin() != patch_order.end() )
+    {
+        // note: this discards patch files not adhering to the "int" scheme
+        // as there won't be a value for them
+        writeFeature( pFile, pKey, pKey->getValue( OUString::valueOf( patch_order.front() ) ) );
+        patch_order.pop_front();
+    }
+}
+
+bool PrinterJob::writeProlog (osl::File* pFile, const JobData& rJobData )
 {
+    WritePS( pFile, "%%BeginProlog\n" );
+
+    // JobPatchFile feature needs to be emitted at begin of prolog
+    writeJobPatch( pFile, rJobData );
+
     const sal_Char pProlog[] = {
-        "%%BeginProlog\n"
         "%%BeginResource: procset PSPrint-Prolog 1.0 0\n"
         "/ISO1252Encoding [\n"
         "/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n"
@@ -1287,6 +1383,12 @@ bool PrinterJob::writeProlog (osl::File*
         "rlineto closepath } def\n"
         "/rectfill { rectangle fill } def\n"
         "/rectstroke { rectangle stroke } def } if\n"
+        "/bshow { currentlinewidth 3 1 roll currentpoint 3 index show moveto\n"
+        "setlinewidth false charpath stroke setlinewidth } def\n"
+        "/bxshow { currentlinewidth 4 1 roll setlinewidth exch dup length 1 sub\n"
+        "0 1 3 -1 roll { 1 string 2 index 2 index get 1 index exch 0 exch put dup\n"
+        "currentpoint 3 -1 roll show moveto currentpoint 3 -1 roll false charpath\n"
+        "stroke moveto 2 index exch get 0 rmoveto } for pop pop setlinewidth } def\n"
         "\n"
 		"/psp_lzwfilter { currentfile /ASCII85Decode filter /LZWDecode filter } def\n"
 		"/psp_ascii85filter { currentfile /ASCII85Decode filter } def\n"
Index: psprint/source/printergfx/psheader.ps
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/psheader.ps,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- psprint/source/printergfx/psheader.ps	26 Mar 2003 14:24:09 -0000	1.4
+++ psprint/source/printergfx/psheader.ps	25 Aug 2003 13:59:25 -0000	1.5
@@ -339,3 +339,65 @@ if 
     /psp_reencodedfont exch definefont
 } def
 
+% bshow shows a text in artificial bold
+% this is achieved by first showing the text
+% then stroking its outline over it with
+% the linewidth set to the second parameter
+% usage: (string) num bshow
+
+/bshow {
+  currentlinewidth		% save current linewidth
+  3 1 roll				% move it to the last stack position
+  currentpoint			% save the current point
+  3 index				% copy the string to show
+  show					% show it
+  moveto				% move to the original coordinates again
+  setlinewidth			% set the linewidth
+  false charpath		% create the outline path of the shown string
+  stroke				% and stroke it
+  setlinewidth			% reset the stored linewidth
+} def
+
+% bxshow shows a text with a delta array in artificial bold
+% that is it does what bshow does for show
+% usage: (string) [deltaarray] num bxshow
+
+/bxshow {
+  currentlinewidth		% save linewidth
+  4 1 roll				% move it to the last stack position
+  setlinewidth			% set the new linewidth
+  exch					% exchange string and delta array
+  dup
+  length				% get length of string
+  1 sub					% prepare parameters for {} for
+  0 1
+  3 -1 roll
+  {
+    1 string			% create a string object length 1
+    2 index				% get the text
+    2 index				% get charpos (for index variable)
+    get					% have char value at charpos
+    1 index				% prepare string for put
+    exch
+    0
+    exch
+    put					% put into string of length 1
+    dup					% duplicate the it
+    currentpoint		% save current position
+    3 -1 roll			% prepare show
+    show				% show the character
+    moveto				% move back to beginning
+    currentpoint		% save current position
+    3 -1 roll			% prepare outline path of character
+    false charpath
+    stroke				% stroke it
+    moveto				% move back
+    % now move to next point
+    2 index				% get advance array
+    exch				% get charpos
+    get					% get advance element
+    0 rmoveto			% advance current position
+  } for
+  pop pop				% remove string and delta array
+  setlinewidth			% restore linewidth
+} def
Index: psprint/source/printergfx/psputil.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/psputil.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- psprint/source/printergfx/psputil.cxx	20 Mar 2002 15:37:37 -0000	1.2
+++ psprint/source/printergfx/psputil.cxx	25 Aug 2003 13:59:34 -0000	1.3
@@ -193,7 +193,7 @@ WritePS (osl::File* pFile, const sal_Cha
     sal_uInt64 nInLength = rtl_str_getLength (pString);
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (pString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
@@ -204,7 +204,7 @@ WritePS (osl::File* pFile, const sal_Cha
 {
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (pString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
@@ -216,7 +216,7 @@ WritePS (osl::File* pFile, const rtl::OS
     sal_uInt64 nInLength = rString.getLength();
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (rString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
Index: psprint/source/printergfx/text_gfx.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/text_gfx.cxx,v
retrieving revision 1.20.20.1
retrieving revision 1.23
diff -u -p -u -r1.20.20.1 -r1.23
--- psprint/source/printergfx/text_gfx.cxx	9 Jan 2004 18:21:28 -0000	1.20.20.1
+++ psprint/source/printergfx/text_gfx.cxx	17 Mar 2004 10:52:41 -0000	1.23
@@ -176,7 +176,9 @@ PrinterGfx::SetFont(
                     sal_Int32 nHeight,
                     sal_Int32 nWidth,
                     sal_Int32 nAngle,
-                    bool bVertical
+                    bool bVertical,
+                    bool bArtItalic,
+                    bool bArtBold
                     )
 {
     // font and encoding will be set by drawText again immediately
@@ -186,6 +188,8 @@ PrinterGfx::SetFont(
     maVirtualStatus.maEncoding        = RTL_TEXTENCODING_DONTKNOW;
     maVirtualStatus.mnTextHeight      = nHeight;
     maVirtualStatus.mnTextWidth       = nWidth;
+    maVirtualStatus.mbArtItalic		  = bArtItalic;
+    maVirtualStatus.mbArtBold		  = bArtBold;
     mnTextAngle                       = nAngle;
     mbTextVertical                    = bVertical;
 
@@ -275,7 +279,6 @@ void PrinterGfx::DrawGlyphs(
         sal_Unicode* pTempUnicodes = (sal_Unicode*)alloca(sizeof(sal_Unicode)*nLen);
         sal_Int16 nTempLen = 0;
         sal_Int32 nTempFirstDelta = 0;
-        sal_Int32 nRot = 0;
         Point aRotPoint;
         sal_Int32 nTextHeight = maVirtualStatus.mnTextHeight;
         sal_Int32 nTextWidth  = maVirtualStatus.mnTextWidth ? maVirtualStatus.mnTextWidth : maVirtualStatus.mnTextHeight;
@@ -451,12 +454,17 @@ PrinterGfx::DrawText (
 
         while ((nTo < nLen) && (nFont == pFontMap[nTo]))
         {
-            pNewDeltaArray[ nTo ] = ((0.5 + pNewDeltaArray[ nTo ]) / 1000.0) - nDelta;
+            pNewDeltaArray[ nTo ] = (sal_Int32)(((0.5 + pNewDeltaArray[ nTo ]) / 1000.0) - nDelta);
             nTo++ ;
         }
 
-        SetFont( nFont, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
-                mnTextAngle, mbTextVertical );
+        SetFont( nFont,
+                 maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
+                 mnTextAngle,
+                 mbTextVertical,
+                 maVirtualStatus.mbArtItalic,
+                 maVirtualStatus.mbArtBold
+                 );
         
         if (mbTextVertical)
         {
@@ -483,8 +491,12 @@ PrinterGfx::DrawText (
     }
 
     // restore the original font settings
-    SetFont( nRestoreFont, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
-            mnTextAngle, mbTextVertical );
+    SetFont( nRestoreFont,
+             maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
+             mnTextAngle, mbTextVertical,
+             maVirtualStatus.mbArtItalic,
+             maVirtualStatus.mbArtBold
+             );
 }
 
 void PrinterGfx::drawVerticalizedText(
@@ -517,24 +529,30 @@ void PrinterGfx::drawVerticalizedText(
             i++;
         if( i <= nLen && i > nLastPos )
         {
-            int nWidth = 0;
             for( int n = nLastPos; n < i; n++ )
                 pDelta[n] = pDeltaArray[n] - (aPoint.X() - rPoint.X() );
             
-            SetFont( mnFontID, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, nNormalAngle, mbTextVertical );
+            SetFont( mnFontID,
+                     maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth,
+                     nNormalAngle, mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
             drawText( aPoint, pStr + nLastPos, i - nLastPos, pDelta + nLastPos );
             
-            aPoint.X() = rPoint.X() + ((double)pDeltaArray[i-1] * fCos);
-            aPoint.Y() = rPoint.Y() + ((double)pDeltaArray[i-1] * fSin);
+            aPoint.X() = (sal_Int32)(rPoint.X() + ((double)pDeltaArray[i-1] * fCos));
+            aPoint.Y() = (sal_Int32)(rPoint.Y() + ((double)pDeltaArray[i-1] * fSin));
         }
         if( i < nLen )
         {
             int nOldWidth	= maVirtualStatus.mnTextWidth;
             int nOldHeight	= maVirtualStatus.mnTextHeight;
-            SetFont( mnFontID, nTextScale,
+            SetFont( mnFontID,
+                     nTextScale,
                      maVirtualStatus.mnTextHeight,
                      nNormalAngle + nDeltaAngle, 
-                     mbTextVertical );
+                     mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
 
             double nA = nTextScale * aInfo.m_nAscend / 1000.0;
             double nD = nTextScale * aInfo.m_nDescend / 1000.0;
@@ -546,19 +564,19 @@ void PrinterGfx::drawVerticalizedText(
             switch( nDeltaAngle )
             {
                 case +900:
-                    aPos.X() += +nA * fCos + nD * fSin;
-                    aPos.Y() += -nA * fSin + nD * fCos;
+                    aPos.X() += (sal_Int32)(+nA * fCos + nD * fSin);
+                    aPos.Y() += (sal_Int32)(-nA * fSin + nD * fCos);
                     break;
                 case -900:
-                    aPos.X() += +nA * fSin + nD * fCos;
-                    aPos.Y() += -(nTextScale*fStretch - nD) * fCos;
+                    aPos.X() += (sal_Int32)(+nA * fSin + nD * fCos);
+                    aPos.Y() += (sal_Int32)(-(nTextScale*fStretch - nD) * fCos);
                     break;
             }
             drawText( aPos, pStr+i, 1, NULL );
             if( i < nLen-1 && pDeltaArray )
             {
-                aPoint.X() = rPoint.X() + ((double)pDeltaArray[i] * fCos);
-                aPoint.Y() = rPoint.Y() + ((double)pDeltaArray[i] * fSin);
+                aPoint.X() = (sal_Int32)(rPoint.X() + ((double)pDeltaArray[i] * fCos));
+                aPoint.Y() = (sal_Int32)(rPoint.Y() + ((double)pDeltaArray[i] * fSin));
             }
 
             // swap text width/height again
@@ -566,7 +584,9 @@ void PrinterGfx::drawVerticalizedText(
                      nOldHeight,
                      nOldWidth,
                      nNormalAngle, 
-                     mbTextVertical );
+                     mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
         }
         i++;
         nLastPos = i;
@@ -618,8 +638,6 @@ PrinterGfx::drawText(
         return;
 
     fonttype::type   eType          = mrFontMgr.getFontType (mnFontID);
-    fonttype::type   eEffectiveType = fonttype::Unknown;
-    rtl_TextEncoding nEncoding      = mrFontMgr.getFontEncoding (mnFontID);
 
     if (eType == fonttype::Type1)
         PSUploadPS1Font (mnFontID);
Index: psprint/util/makefile.mk
===================================================================
RCS file: /cvs/gsl/psprint/util/makefile.mk,v
retrieving revision 1.9.38.2
retrieving revision 1.12
diff -u -p -u -r1.9.38.2 -r1.12
--- psprint/util/makefile.mk	28 Jan 2004 11:26:14 -0000	1.9.38.2
+++ psprint/util/makefile.mk	1 Jun 2004 08:58:57 -0000	1.12
@@ -105,7 +105,7 @@ SHL1STDLIBS=$(UNOTOOLSLIB)		\
 			$(SALLIB)			\
 			-lX11
 .IF "$(SOLAR_JAVA)"!=""
-SHL1STDLIBS+=$(JVMACCESSLIB)
+SHL1STDLIBS+=$(JVMFWKLIB)
 .ENDIF
 
 SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
