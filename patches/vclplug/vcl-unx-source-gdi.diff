Index: vcl/unx/source/gdi/cdeint.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/cdeint.cxx,v
retrieving revision 1.8
retrieving revision 1.9
Index: vcl/unx/source/gdi/cdeint.cxx
===================================================================
--- vcl/unx/source/gdi/cdeint.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/cdeint.cxx	2004-09-14 14:09:32.367288400 +0200
@@ -64,14 +64,12 @@
 #include <salunx.h>
 #include <saldisp.hxx>
 #include <cdeint.hxx>
-#include <salframe.hxx>
 #include <settings.hxx>
 
 #include <tools/stream.hxx>
 #include <tools/debug.hxx>
 
-CDEIntegrator::CDEIntegrator( SalFrame* pFrame ) :
-		DtIntegrator( pFrame )
+CDEIntegrator::CDEIntegrator()
 {
 	meType = DtCDE;
 	mnRefCount++;
Index: vcl/unx/source/gdi/dtint.cxx
===================================================================
--- vcl/unx/source/gdi/dtint.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/dtint.cxx	2004-09-14 14:09:32.371287792 +0200
@@ -72,10 +72,8 @@
 #include <cdeint.hxx>
 #endif
 #include <kdeint.hxx>
-#include <gnomeint.hxx>
 #include <saldisp.hxx>
 #include <saldata.hxx>
-#include <salframe.hxx>
 #include <wmadaptor.hxx>
 
 #include <svapp.hxx>
@@ -103,16 +101,12 @@ BOOL bSymbolLoadFailed = FALSE;
 DtIntegratorList DtIntegrator::aIntegratorList;
 String DtIntegrator::aHomeDir;
 
-DtIntegrator::DtIntegrator( SalFrame* pFrame ) :
-		mpSalFrame( pFrame ),
+DtIntegrator::DtIntegrator() :
 		meType( DtGeneric ),
 		mnRefCount( 0 ),
         mnSystemLookCommandProcess( -1 )
 {
-    if( pFrame )
-        mpSalDisplay = pFrame->maFrameData.GetDisplay();
-    else
-        mpSalDisplay = GetSalData()->GetDefDisp();
+    mpSalDisplay = GetSalData()->GetDisplay();
 	mpDisplay = mpSalDisplay->GetDisplay();
 	aIntegratorList.Insert( this, LIST_APPEND );
     static const char* pHome = getenv( "HOME" );
@@ -123,16 +117,12 @@ DtIntegrator::~DtIntegrator()
 {
 }
 
-DtIntegrator* DtIntegrator::CreateDtIntegrator( SalFrame* pFrame )
+DtIntegrator* DtIntegrator::CreateDtIntegrator()
 {
-	// hack for sclient
-	if( ! pFrame && aIntegratorList.Count() )
-		return aIntegratorList.GetObject( 0 );
-
-    SalDisplay* pSalDisplay = pFrame ? pFrame->maFrameData.GetDisplay() : GetSalData()->GetDefDisp();
+    SalDisplay* pSalDisplay = GetSalData()->GetDisplay();
     Display* pDisplay = pSalDisplay->GetDisplay();
 
-	for( int i = 0; i < aIntegratorList.Count(); i++ )
+	for( unsigned int i = 0; i < aIntegratorList.Count(); i++ )
 	{
 		DtIntegrator* pIntegrator = aIntegratorList.GetObject( i );
 		if( pIntegrator->mpDisplay == pDisplay )
@@ -150,14 +140,12 @@ DtIntegrator* DtIntegrator::CreateDtInte
         OString aOver( pOverride );
 #if USE_CDE
         if( aOver.equalsIgnoreAsciiCase( "cde" ) )
-            return new CDEIntegrator( pFrame );
+            return new CDEIntegrator();
 #endif
         if( aOver.equalsIgnoreAsciiCase( "kde" ) )
-            return new KDEIntegrator( pFrame );
-        if( aOver.equalsIgnoreAsciiCase( "gnome" ) )
-            return new GNOMEIntegrator( pFrame );
+            return new KDEIntegrator();
         if( aOver.equalsIgnoreAsciiCase( "none" ) )
-            return new DtIntegrator( pFrame );
+            return new DtIntegrator();
     }
 
 	Atom nDtAtom = None;
@@ -168,461 +156,20 @@ DtIntegrator* DtIntegrator::CreateDtInte
 	// check dt type
 	// CDE
 	nDtAtom = XInternAtom( pDisplay, "_DT_WM_READY", True );
-	if( nDtAtom && ( pLibrary = dlopen( "libDtSvc.so", DLOPEN_MODE ) ) )
+	if( nDtAtom && ( pLibrary = dlopen( "/usr/dt/lib/libDtSvc.so", DLOPEN_MODE ) ) )
 	{
         dlclose( pLibrary );
-		return new CDEIntegrator( pFrame );
+		return new CDEIntegrator();
 	}
 #endif
 
     if( pSalDisplay->getWMAdaptor()->getWindowManagerName().EqualsAscii( "KWin" ) )
-		return new KDEIntegrator( pFrame );
-
-    // actually this is not that good an indicator for a GNOME running
-    // but there currently does not seem to be a better one
-    nDtAtom = XInternAtom( pDisplay, "GNOME_SM_PROXY", True );
-	Atom nDtAtom2 = XInternAtom( pDisplay, "NAUTILUS_DESKTOP_WINDOW_ID", True );
-    if( nDtAtom || nDtAtom2 )
-    {
-        int nProperties = 0;
-        Atom* pProperties = XListProperties( pDisplay, pSalDisplay->GetRootWindow(), &nProperties );
-        if( pProperties && nProperties )
-        {
-            for( int i = 0; i < nProperties; i++ )
-                if( pProperties[ i ] == nDtAtom ||
-					pProperties[ i ] == nDtAtom2 )
-                {
-                    XFree( pProperties );
-                    return new GNOMEIntegrator( pFrame );
-                }
-            XFree( pProperties );
-        }
-    }
+		return new KDEIntegrator();
 
 	// default: generic implementation
-	return new DtIntegrator( pFrame );
+	return new DtIntegrator();
 }
 
 void DtIntegrator::GetSystemLook( AllSettings& rSettings )
 {
 }
-
-Color DtIntegrator::parseColor( const ByteString& rLine )
-{
-    Color aColor;
-
-    xub_StrLen nPos1 = rLine.Search( '(' );
-    xub_StrLen nPos2 = rLine.Search( ')', nPos1 != STRING_NOTFOUND ? nPos1 : 0 );
-    if( nPos1 != STRING_NOTFOUND && nPos2 != STRING_NOTFOUND
-        && (int)nPos2 - (int)nPos1 > 5 )
-    {
-        ByteString aTriple( rLine.Copy( nPos1+1, nPos2-nPos1-1 ) );
-        xub_StrLen nIndex = 0;
-        int nRed, nGreen, nBlue, nColor = 0;
-        do
-        {
-            switch( nColor )
-            {
-                case 0: nRed = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
-                case 1: nGreen = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
-                case 2: nBlue = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
-            }
-            nColor++;
-        } while(  nIndex != STRING_NOTFOUND );
-        if( nColor == 3 )
-        {
-            aColor = Color( nRed, nGreen, nBlue );
-        }
-    }
-    return aColor;
-}
-
-Font DtIntegrator::parseFont( const ByteString& rLine )
-{
-    Font aFont;
-
-    xub_StrLen nPos1 = rLine.Search( '"' );
-    xub_StrLen nPos2 = rLine.Search( '"', nPos1 != STRING_NOTFOUND ? nPos1+1 : 0 );
-    if( nPos1 != STRING_NOTFOUND && nPos2 != STRING_NOTFOUND
-        && (int)nPos2 - (int)nPos1 > 1 )
-    {
-        aFont.SetName( String( rLine.Copy( nPos1+1, nPos2-nPos1-1 ), osl_getThreadTextEncoding() ) );
-        xub_StrLen nIndex = nPos2;
-        ByteString aToken = rLine.GetToken( 1, ',', nIndex );
-        if( aToken.Len() )
-        {
-            int nPixelHeight = aToken.ToInt32();
-            long nDPIX, nDPIY;
-            long nDispDPIY = mpSalDisplay->GetResolution().B();
-            mpSalDisplay->GetScreenFontResolution( nDPIX, nDPIY );
-            int nHeight = nPixelHeight * nDispDPIY / nDPIY;
-            // allow for rounding in back conversion (at SetFont)
-            while( (nHeight * nDPIY / nDispDPIY) > nPixelHeight )
-                nHeight--;
-            while( (nHeight * nDPIY / nDispDPIY) < nPixelHeight )
-                nHeight++;
-            aFont.SetHeight( nHeight );
-        }
-        while( nIndex != STRING_NOTFOUND )
-        {
-            aToken = rLine.GetToken( 0, ',', nIndex );
-            if( aToken.Equals( "bold" ) )
-                aFont.SetWeight( WEIGHT_BOLD );
-            else if( aToken.Equals( "light" ) )
-                aFont.SetWeight( WEIGHT_LIGHT );
-            else if( aToken.Equals( "italic" ) )
-                aFont.SetItalic( ITALIC_NORMAL );
-        }
-    }
-    return aFont;
-}
-
-bool DtIntegrator::StartSystemLookProcess( const char* pCommand )
-{
-    ByteString aCommand, aArgWindow;
-    if( pCommand[0] == '/' )
-        aCommand = pCommand;
-    else
-    {
-        OUString aExec;
-        OUString aSys;
-        osl_getExecutableFile( &aExec.pData );
-        if( osl_File_E_None != osl_getSystemPathFromFileURL( aExec.pData, &aSys.pData ) )
-            return false; // huh ?
-        aCommand = ByteString( String( aSys ), osl_getThreadTextEncoding() );
-        aCommand.Erase( aCommand.SearchBackward( '/' )+1 );
-        aCommand.Append( pCommand );
-    }
-    aArgWindow = ByteString::CreateFromInt32( mpSalDisplay->GetDrawable() );
-    mnSystemLookCommandProcess = fork();
-    if( mnSystemLookCommandProcess == 0 )
-    {
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "exec( \"%s --vcl-system-settings-window %s\" )\n", aCommand.GetBuffer(), aArgWindow.GetBuffer() );
-#endif
-        int nRedirect = open( "/dev/null", O_WRONLY );
-        if( nRedirect != -1 )
-        {
-            dup2( nRedirect, STDOUT_FILENO );
-            dup2( nRedirect, STDERR_FILENO );
-        }
-        execl( aCommand.GetBuffer(), aCommand.GetBuffer(), "--vcl-system-settings-window", aArgWindow.GetBuffer(), NULL );
-        _exit(1);
-    }
-    return mnSystemLookCommandProcess != -1;
-}
-
-void DtIntegrator::GetSystemLook( const char* pCommand, AllSettings& rSettings )
-{
-    BOOL bRet = FALSE;
-    std::list< ByteString > aLines;
-
-    if( pCommand )
-    {
-        char pBuffer[1024];
-        FILE* pOutput = NULL;
-
-        ByteString aCommand;
-        if( pCommand[0] == '/' )
-            aCommand = pCommand;
-        else
-        {
-            OUString aExec;
-            OUString aSys;
-            osl_getExecutableFile( &aExec.pData );
-            if( osl_File_E_None != osl_getSystemPathFromFileURL( aExec.pData, &aSys.pData ) )
-                return; // huh ?
-            aCommand = ByteString( String( aSys ), osl_getThreadTextEncoding() );
-            aCommand.Erase( aCommand.SearchBackward( '/' )+1 );
-            aCommand.Append( pCommand );
-        }
-#if OSL_DEBUG_LEVEL < 2
-        aCommand.Append( " 2>/dev/null" );
-#endif
-        pOutput = popen( aCommand.GetBuffer(), "r" );
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "popen( \"%s\", \"r\" ) = %p\n", aCommand.GetBuffer(), pOutput );
-#endif
-        while( fgets( pBuffer, sizeof( pBuffer ), pOutput ) )
-        {
-            aLines.push_back( ByteString( pBuffer ) );
-        }
-        pclose( pOutput );
-    }
-    else if( ! pCommand && mnSystemLookCommandProcess != -1 )
-    {
-        // get the lines from the VCL_SYSTEM_SETTINGS property
-        Atom nType = 0;
-        int nFormat = 0;
-        unsigned long nItems = 0, nBytes = 0;
-        char* pData = NULL;
-        // query size of the property
-        XGetWindowProperty( mpSalDisplay->GetDisplay(),
-                            mpSalDisplay->GetDrawable(),
-                            mpSalDisplay->getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ),
-                            0, 0,
-                            False,
-                            XA_STRING,
-                            &nType,
-                            &nFormat,
-                            &nItems,
-                            &nBytes,
-                            (unsigned char**)&pData );
-        if( nBytes )
-        {
-            // query the actual data
-            XGetWindowProperty( mpSalDisplay->GetDisplay(),
-                                mpSalDisplay->GetDrawable(),
-                                mpSalDisplay->getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ),
-                                0, (nBytes+3)/4,
-                                False,
-                                XA_STRING,
-                                &nType,
-                                &nFormat,
-                                &nItems,
-                                &nBytes,
-                                (unsigned char**)&pData );
-            // sanity check
-            if( nFormat == 8 && nType == XA_STRING && nItems )
-            {
-#if OSL_DEBUG_LEVEL > 1
-                fprintf( stderr, "got %d data items:\n%.*s", nItems, nItems, pData );
-#endif
-                // fill in the lines
-                char* pRun = pData;
-                char* pLastLine = pData;
-                while( (pRun-pData) <= nItems )
-                {
-                    if( *pRun == '\n' )
-                    {
-                        if( pRun-pLastLine > 1 )
-                        {
-                            aLines.push_back( ByteString( pLastLine, pRun - pLastLine ) );
-                            pLastLine = pRun+1;
-                        }
-                    }
-                    pRun++;
-                }
-            }
-#if OSL_DEBUG_LEVEL > 1
-            else
-                fprintf( stderr, "query of data failed with nFormat = %d, nType = %d, nItems = %d\n", nFormat, nType, nItems );
-#endif
-            XFree( pData );
-        }
-#if OSL_DEBUG_LEVEL > 1
-        else
-            fprintf( stderr, "query of bytes failed\n" );
-#endif
-    }
-
-    // nothing to do ?
-    if( aLines.begin() == aLines.end() )
-        return;
-
-    StyleSettings aStyleSettings( rSettings.GetStyleSettings() );
-    MouseSettings aMouseSettings( rSettings.GetMouseSettings() );
-    KeyboardSettings aKeyboardSettings( rSettings.GetKeyboardSettings() );
-
-    std::set< DtSetEnum > aItemSet;
-
-    while( aLines.begin() != aLines.end() )
-    {
-        ByteString aLine( aLines.front() );
-        aLines.pop_front();
-        if( aLine.GetChar( aLine.Len()-1 ) == '\n' )
-            aLine.Erase( aLine.Len()-1 ); // cut newline
-
-        USHORT nPos = aLine.Search( '=' );
-        if( nPos == STRING_NOTFOUND )
-            continue;
-
-        DtSetEnum aToken = (DtSetEnum)aLine.Copy( 0, nPos ).ToInt32();
-        aLine.Erase( 0, nPos+1 );
-
-        if( aToken )
-        {
-            bRet = TRUE;
-            aItemSet.insert( aToken );
-        }
-
-        switch( aToken )
-        {
-            case MouseOptions:			aMouseSettings.SetOptions( aLine.ToInt32() );break;
-            case DoubleClickTime:		aMouseSettings.SetDoubleClickTime( aLine.ToInt32() );break;
-            case DoubleClickWidth:		aMouseSettings.SetDoubleClickWidth( aLine.ToInt32() );break;
-            case DoubleClickHeight:		aMouseSettings.SetDoubleClickHeight( aLine.ToInt32() );break;
-            case StartDragWidth:		aMouseSettings.SetStartDragWidth( aLine.ToInt32() );break;
-            case StartDragHeight:		aMouseSettings.SetStartDragHeight( aLine.ToInt32() );break;
-            case DragMoveCode:			aMouseSettings.SetDragMoveCode( aLine.ToInt32() );break;
-            case DragCopyCode:			aMouseSettings.SetDragCopyCode( aLine.ToInt32() );break;
-            case DragLinkCode:			aMouseSettings.SetDragLinkCode( aLine.ToInt32() );break;
-            case ContextMenuCode:		aMouseSettings.SetContextMenuCode( aLine.ToInt32() );break;
-            case ContextMenuClicks:		aMouseSettings.SetContextMenuClicks( aLine.ToInt32() );break;
-            case ContextMenuDown:		aMouseSettings.SetContextMenuDown( aLine.ToInt32() );break;
-            case ScrollRepeat:			aMouseSettings.SetScrollRepeat( aLine.ToInt32() );break;
-            case ButtonStartRepeat:		aMouseSettings.SetButtonStartRepeat( aLine.ToInt32() );break;
-            case ButtonRepeat:			aMouseSettings.SetButtonRepeat( aLine.ToInt32() );break;
-            case ActionDelay:			aMouseSettings.SetActionDelay( aLine.ToInt32() );break;
-            case MenuDelay:				aMouseSettings.SetMenuDelay( aLine.ToInt32() );break;
-            case Follow:				aMouseSettings.SetFollow( aLine.ToInt32() );break;
-            case MiddleButtonAction:	aMouseSettings.SetMiddleButtonAction( aLine.ToInt32() );break;
-            case KeyboardOptions:		aKeyboardSettings.SetOptions( aLine.ToInt32() );break;
-            case StyleOptions:			aStyleSettings.SetOptions( aLine.ToInt32() );break;
-            case BorderSize:			aStyleSettings.SetBorderSize( aLine.ToInt32() );break;
-            case TitleHeight:			aStyleSettings.SetTitleHeight( aLine.ToInt32() );break;
-            case FloatTitleHeight:		aStyleSettings.SetFloatTitleHeight( aLine.ToInt32() );break;
-            case TearOffTitleHeight:	aStyleSettings.SetTearOffTitleHeight( aLine.ToInt32() );break;
-            case MenuBarHeight:			aStyleSettings.SetMenuBarHeight( aLine.ToInt32() );break;
-            case ScrollBarSize:			aStyleSettings.SetScrollBarSize( aLine.ToInt32() );break;
-            case SpinSize:				aStyleSettings.SetSpinSize( aLine.ToInt32() );break;
-            case SplitSize:				aStyleSettings.SetSplitSize( aLine.ToInt32() );break;
-            case IconHorzSpace:			aStyleSettings.SetIconHorzSpace( aLine.ToInt32() );break;
-            case IconVertSpace:			aStyleSettings.SetIconVertSpace( aLine.ToInt32() );break;
-            case CursorSize:			aStyleSettings.SetCursorSize( aLine.ToInt32() );break;
-            case CursorBlinkTime:		aStyleSettings.SetCursorBlinkTime( aLine.ToInt32() );break;
-            case ScreenZoom:			aStyleSettings.SetScreenZoom( aLine.ToInt32() );break;
-            case ScreenFontZoom:		aStyleSettings.SetScreenFontZoom( aLine.ToInt32() );break;
-            case LogoDisplayTime:		aStyleSettings.SetLogoDisplayTime( aLine.ToInt32() );break;
-            case DragFullOptions:		aStyleSettings.SetDragFullOptions( aLine.ToInt32() );break;
-            case AnimationOptions:		aStyleSettings.SetAnimationOptions( aLine.ToInt32() );break;
-            case SelectionOptions:		aStyleSettings.SetSelectionOptions( aLine.ToInt32() );break;
-            case DisplayOptions:		aStyleSettings.SetDisplayOptions( aLine.ToInt32() );break;
-            case AntialiasingMinPixelHeight: aStyleSettings.SetAntialiasingMinPixelHeight( aLine.ToInt32() );break;
-            case ThreeDColor:			aStyleSettings.Set3DColors( parseColor( aLine ) );break;
-            case FaceColor:				aStyleSettings.SetFaceColor( parseColor( aLine ) );break;
-            case CheckedColor:			aStyleSettings.SetCheckedColor( parseColor( aLine ) );break;
-            case LightColor:			aStyleSettings.SetLightColor( parseColor( aLine ) );break;
-            case LightBorderColor:		aStyleSettings.SetLightBorderColor( parseColor( aLine ) );break;
-            case ShadowColor:			aStyleSettings.SetShadowColor( parseColor( aLine ) );break;
-            case DarkShadowColor:		aStyleSettings.SetDarkShadowColor( parseColor( aLine ) );break;
-            case ButtonTextColor:		aStyleSettings.SetButtonTextColor( parseColor( aLine ) );break;
-            case RadioCheckTextColor:	aStyleSettings.SetRadioCheckTextColor( parseColor( aLine ) );break;
-            case GroupTextColor:		aStyleSettings.SetGroupTextColor( parseColor( aLine ) );break;
-            case LabelTextColor:		aStyleSettings.SetLabelTextColor( parseColor(aLine ) );break;
-            case InfoTextColor:			aStyleSettings.SetInfoTextColor( parseColor( aLine ) );break;
-            case WindowColor:			aStyleSettings.SetWindowColor( parseColor( aLine ) );break;
-            case WindowTextColor:		aStyleSettings.SetWindowTextColor( parseColor( aLine ) );break;
-            case DialogColor:			aStyleSettings.SetDialogColor( parseColor( aLine ) );break;
-            case DialogTextColor:		aStyleSettings.SetDialogTextColor( parseColor( aLine ) );break;
-            case WorkspaceColor:		aStyleSettings.SetWorkspaceColor( parseColor( aLine ) );break;
-            case FieldColor:			aStyleSettings.SetFieldColor( parseColor( aLine ) );break;
-            case FieldTextColor:		aStyleSettings.SetFieldTextColor( parseColor( aLine ) );break;
-            case ActiveColor:			aStyleSettings.SetActiveColor( parseColor( aLine ) );break;
-            case ActiveColor2:			aStyleSettings.SetActiveColor2( parseColor( aLine ) );break;
-            case ActiveTextColor:		aStyleSettings.SetActiveTextColor( parseColor( aLine ) );break;
-            case ActiveBorderColor:		aStyleSettings.SetActiveBorderColor( parseColor( aLine ) );break;
-            case DeactiveColor:			aStyleSettings.SetDeactiveColor( parseColor( aLine ) );break;
-            case DeactiveColor2:		aStyleSettings.SetDeactiveColor2( parseColor( aLine ) );break;
-            case DeactiveTextColor:		aStyleSettings.SetDeactiveTextColor( parseColor( aLine ) );break;
-            case DeactiveBorderColor:	aStyleSettings.SetDeactiveBorderColor( parseColor( aLine ) );break;
-            case HighlightColor:		aStyleSettings.SetHighlightColor( parseColor( aLine ) );break;
-            case HighlightTextColor:	aStyleSettings.SetHighlightTextColor( parseColor( aLine ) );break;
-            case DisableColor:			aStyleSettings.SetDisableColor( parseColor( aLine ) );break;
-            case HelpColor:				aStyleSettings.SetHelpColor( parseColor( aLine ) );break;
-            case HelpTextColor:			aStyleSettings.SetHelpTextColor( parseColor( aLine ) );break;
-            case MenuColor:				aStyleSettings.SetMenuColor( parseColor( aLine ) );break;
-            case MenuBarColor:			aStyleSettings.SetMenuBarColor( parseColor( aLine ) );break;
-            case MenuTextColor:			aStyleSettings.SetMenuTextColor( parseColor( aLine ) );break;
-            case MenuHighlightColor:	aStyleSettings.SetMenuHighlightColor( parseColor( aLine ) );break;
-            case MenuHighlightTextColor: aStyleSettings.SetMenuHighlightTextColor( parseColor( aLine ) );break;
-            case LinkColor:				aStyleSettings.SetLinkColor( parseColor( aLine ) );break;
-            case VisitedLinkColor:		aStyleSettings.SetVisitedLinkColor( parseColor( aLine ) );break;
-            case HighlightLinkColor:	aStyleSettings.SetHighlightLinkColor( parseColor( aLine ) );break;
-            case HighContrastMode:		aStyleSettings.SetHighContrastMode( aLine.ToInt32() );break;
-            case AppFont:				aStyleSettings.SetAppFont( parseFont( aLine ) );break;
-            case HelpFont:				aStyleSettings.SetHelpFont( parseFont( aLine ) );break;
-            case TitleFont:				aStyleSettings.SetTitleFont( parseFont( aLine ) );break;
-            case FloatTitleFont:		aStyleSettings.SetFloatTitleFont( parseFont( aLine ) );break;
-            case MenuFont:				aStyleSettings.SetMenuFont( parseFont( aLine ) );break;
-            case ToolFont:				aStyleSettings.SetToolFont( parseFont( aLine ) );break;
-            case GroupFont:				aStyleSettings.SetGroupFont( parseFont( aLine ) );break;
-            case LabelFont:				aStyleSettings.SetLabelFont( parseFont( aLine ) );break;
-            case InfoFont:				aStyleSettings.SetInfoFont( parseFont( aLine ) );break;
-            case RadioCheckFont:		aStyleSettings.SetRadioCheckFont( parseFont( aLine ) );break;
-            case PushButtonFont:		aStyleSettings.SetPushButtonFont( parseFont( aLine ) );break;
-            case FieldFont:				aStyleSettings.SetFieldFont( parseFont( aLine ) );break;
-            case IconFont:				aStyleSettings.SetIconFont( parseFont( aLine ) );break;
-            case RadioButtonStyle:		aStyleSettings.SetRadioButtonStyle( aLine.ToInt32() );break;
-            case CheckBoxStyle:			aStyleSettings.SetCheckBoxStyle( aLine.ToInt32() );break;
-            case PushButtonStyle:		aStyleSettings.SetPushButtonStyle( aLine.ToInt32() );break;
-            case TabControlStyle:		aStyleSettings.SetTabControlStyle( aLine.ToInt32() );
-                break;
-
-            case AllTextColors:
-            {
-                Color aTextColor = parseColor( aLine );
-                aStyleSettings.SetDialogTextColor( aTextColor );
-                aStyleSettings.SetMenuTextColor( aTextColor );
-                aStyleSettings.SetButtonTextColor( aTextColor );
-                aStyleSettings.SetRadioCheckTextColor( aTextColor );
-                aStyleSettings.SetGroupTextColor( aTextColor );
-                aStyleSettings.SetLabelTextColor( aTextColor );
-                aStyleSettings.SetInfoTextColor( aTextColor );
-                aStyleSettings.SetWindowTextColor( aTextColor );
-                aStyleSettings.SetFieldTextColor( aTextColor );
-            }
-            break;
-            case AllBackColors:
-            {
-                Color aBack = parseColor( aLine );
-                aStyleSettings.Set3DColors( aBack );
-                aStyleSettings.SetFaceColor( aBack );
-                aStyleSettings.SetDialogColor( aBack );
-                aStyleSettings.SetMenuColor( aBack );
-                aStyleSettings.SetMenuBarColor( aBack );
-                aStyleSettings.SetWindowColor( aBack );
-                aStyleSettings.SetFieldColor( aBack );
-                if( aBack == COL_LIGHTGRAY )
-                    aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
-                else
-                {
-                    Color aColor2 = aStyleSettings.GetLightColor();
-                    aStyleSettings.
-                        SetCheckedColor( Color(
-                                               (BYTE)(((USHORT)aBack.GetRed()+(USHORT)aColor2.GetRed())/2),
-                                               (BYTE)(((USHORT)aBack.GetGreen()+(USHORT)aColor2.GetGreen())/2),
-                                               (BYTE)(((USHORT)aBack.GetBlue()+(USHORT)aColor2.GetBlue())/2)
-                                               ) );
-                }
-            }
-            break;
-            case UIFont:
-                if( aStyleSettings.GetUseSystemUIFonts() )
-                {
-                    Font aFont = parseFont( aLine );
-                    aStyleSettings.SetAppFont( aFont );
-                    aStyleSettings.SetHelpFont( aFont );
-                    aStyleSettings.SetMenuFont( aFont );
-                    aStyleSettings.SetToolFont( aFont );
-                    aStyleSettings.SetLabelFont( aFont );
-                    aStyleSettings.SetInfoFont( aFont );
-                    aStyleSettings.SetRadioCheckFont( aFont );
-                    aStyleSettings.SetPushButtonFont( aFont );
-                    aStyleSettings.SetFieldFont( aFont );
-                    aStyleSettings.SetIconFont( aFont );
-                    aStyleSettings.SetGroupFont( aFont );
-                }
-                break;
-            case ToolbarIconSize:
-                if( aLine.EqualsIgnoreCaseAscii( "large" ) )
-                    aStyleSettings.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_LARGE );
-                else if( aLine.EqualsIgnoreCaseAscii( "small" ) )
-                    aStyleSettings.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_SMALL );
-                else
-                    aStyleSettings.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_UNKNOWN );
-                break;
-#if OSL_DEBUG_LEVEL > 1
-            default:
-                fprintf( stderr, "don't understand \"%d=%s\"\n", aToken, aLine.GetBuffer() );
-                break;
-#endif
-        }
-    }
-    if( bRet )
-    {
-        rSettings.SetKeyboardSettings( aKeyboardSettings );
-        rSettings.SetMouseSettings( aMouseSettings );
-        rSettings.SetStyleSettings( aStyleSettings );
-    }
-}
Index: vcl/unx/source/gdi/gcach_xpeer.cxx
===================================================================
--- vcl/unx/source/gdi/gcach_xpeer.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/gcach_xpeer.cxx	2004-09-14 14:09:32.372287640 +0200
@@ -61,6 +61,7 @@
 
 #include <rtl/ustring.hxx>
 #include <osl/module.h>
+#include <osl/thread.h>
 using namespace rtl;
 
 #include <gcach_xpeer.hxx>
@@ -138,7 +139,7 @@ void X11GlyphPeer::SetDisplay( Display* 
     if( !pRenderLib ) {
 #ifdef DEBUG
         fprintf( stderr, "Display can do XRender, but no %s installed.\n"
-            "Please install for improved display performance\n", xrenderLibraryName.getStr() );
+            "Please install for improved display performance\n", OUStringToOString( xrenderLibraryName.getStr(), osl_getThreadTextEncoding() ).getStr() );
 #endif
         return;
     }
@@ -296,15 +297,16 @@ void X11GlyphPeer::RemovingGlyph( Server
 
         case XRENDER_KIND:
             {
+/*
+				// TODO: reenable when it works without problems
                 Glyph nGlyphId = (Glyph)rGlyphData.GetExtPointer();
                 // XRenderFreeGlyphs not implemented yet for version<=0.2
                 // #108209# disabled because of crash potential,
                 // the glyph leak is not too bad because they will
                 // be cleaned up when the glyphset is released
-#if 0   // TODO: reenable when it works without problems
                 if( nRenderVersion >= 0x05 )
                     (*pXRenderFreeGlyphs)( mpDisplay, aGlyphSet, &nGlyphId, 1 );
-#endif
+*/
                 mnBytesUsed -= nHeight * ((nWidth + 3) & ~3);
             }
             break;
@@ -331,7 +333,7 @@ bool X11GlyphPeer::ForcedAntialiasing( c
 GlyphSet X11GlyphPeer::GetGlyphSet( ServerFont& rServerFont )
 {
     if( !mbUsingXRender )
-        return NULL;
+        return 0;
 
     GlyphSet aGlyphSet;
 
@@ -354,12 +356,12 @@ GlyphSet X11GlyphPeer::GetGlyphSet( Serv
                     rServerFont.SetExtended( XRENDER_KIND, (void*)aGlyphSet );
                 }
                 else
-                    aGlyphSet = NULL;
+                    aGlyphSet = 0;
             }
             break;
 
         default:
-            aGlyphSet = NULL;
+            aGlyphSet = 0;
             break;
     }
 
@@ -381,7 +383,7 @@ Pixmap X11GlyphPeer::GetPixmap( ServerFo
         {
             // #94666# circumvent bug in some X11 systems, e.g. XF410.LynxEM.v163
             ULONG nPixmapWidth = 8 * maRawBitmap.mnScanlineSize - 1;
-            nPixmapWidth = std::max( nPixmapWidth, maRawBitmap.mnWidth );
+            nPixmapWidth = Max( nPixmapWidth, maRawBitmap.mnWidth );
 
             rGlyphData.SetSize( Size( nPixmapWidth, maRawBitmap.mnHeight ) );
             rGlyphData.SetOffset( +maRawBitmap.mnXOffset, +maRawBitmap.mnYOffset );
Index: vcl/unx/source/gdi/kdeint.cxx
===================================================================
--- vcl/unx/source/gdi/kdeint.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/kdeint.cxx	2004-09-14 14:09:32.373287488 +0200
@@ -60,18 +60,18 @@
  ************************************************************************/
 
 #include <kdeint.hxx>
-#include <config.hxx>
+#include <tools/config.hxx>
 #include <settings.hxx>
 
 #include <osl/thread.h>
 
 #include <unistd.h>
+#include <cstdio>
 
 using namespace rtl;
 using namespace osl;
 
-KDEIntegrator::KDEIntegrator( SalFrame* pFrame ) :
-		DtIntegrator( pFrame )
+KDEIntegrator::KDEIntegrator()
 {
 	meType = DtKDE;
 }
@@ -80,7 +80,7 @@ KDEIntegrator::~KDEIntegrator()
 {
 }
 
-static char* pTryFiles[] =
+static const char* pTryFiles[] =
   {
 	"/usr/share/config/kdeglobals",
 	"/opt/kde/share/config/kdeglobals",
@@ -93,7 +93,7 @@ void KDEIntegrator::GetSystemLook( AllSe
 {
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
 
-	for( int i = 0; (i < sizeof( pTryFiles )/sizeof(pTryFiles[0])); i++ )
+	for( unsigned int i = 0; (i < sizeof( pTryFiles )/sizeof(pTryFiles[0])); i++ )
 	  {
 		String aFile;
 		if( pTryFiles[i][0] == '~' )
Index: vcl/unx/source/gdi/makefile.mk
===================================================================
--- vcl/unx/source/gdi/makefile.mk.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/makefile.mk	2004-09-14 14:09:32.374287336 +0200
@@ -80,24 +80,29 @@ dummy:
 
 .ELSE		# "$(GUIBASE)"!="unx"
 
-.IF "$(remote)"==""
 SLOFILES=	\
 		$(SLO)$/salgdi2.obj		\
 		$(SLO)$/salbmp.obj		\
 		$(SLO)$/salgdi.obj		\
 		$(SLO)$/salvd.obj		\
 		$(SLO)$/salogl.obj		\
-		$(SLO)$/charnames.obj	\
 		$(SLO)$/dtint.obj		\
-		$(SLO)$/kdeint.obj		\
-		$(SLO)$/gnomeint.obj	\
 		$(SLO)$/salcvt.obj		\
-		$(SLO)$/ansi1252.obj	\
 		$(SLO)$/xfont.obj		\
 		$(SLO)$/xlfd_attr.obj	\
 		$(SLO)$/xlfd_extd.obj	\
 		$(SLO)$/xlfd_smpl.obj	\
-		$(SLO)$/salgdi3.obj
+		$(SLO)$/salgdi3.obj		\
+		$(SLO)$/pspgraphics.obj
+
+.IF "$(WITH_WIDGETSET)"=="kde"
+	# salnativewidgets-kde.cxx contains own implementation of KDEintegrator
+	SLOFILES+=$(SLO)/salnativewidgets-kde.obj
+	CFLAGS+=$(WIDGETSET_CFLAGS)
+.ELSE
+	SLOFILES+= \
+		$(SLO)$/kdeint.obj
+.ENDIF
 
 .IF "$(USE_XPRINT)" == "TRUE"
 CFLAGS+=-D_USE_PRINT_EXTENSION_=1
@@ -115,8 +120,6 @@ ENVCFLAGS+=-DUSE_CDE
 SLOFILES+=	$(SLO)$/gcach_xpeer.obj
 .ENDIF
 
-.ENDIF
-
 .ENDIF	# "$(GUIBASE)"!="unx"
 
 # --- Targets ------------------------------------------------------
Index: vcl/unx/source/gdi/pspgraphics.cxx
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vcl/unx/source/gdi/pspgraphics.cxx	2004-09-14 14:09:32.377286880 +0200
@@ -0,0 +1,1355 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <pspgraphics.h>
+#include <psprint/jobdata.hxx>
+#include <psprint/printergfx.hxx>
+#include <psprint/printerinfomanager.hxx>
+#include <bmpacc.hxx>
+#include <salbmp.hxx>
+#include <glyphcache.hxx>
+#include <svapp.hxx>
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+using namespace psp;
+using namespace rtl;
+
+// ----- Implementation of PrinterBmp by means of SalBitmap/BitmapBuffer ---------------
+
+class SalPrinterBmp : public psp::PrinterBmp
+{
+	private:
+    BitmapBuffer*		mpBmpBuffer;
+    
+    FncGetPixel			mpFncGetPixel;
+    Scanline			mpScanAccess;
+    sal_Int32			mnScanOffset;
+    
+    sal_uInt32			ColorOf (BitmapColor& rColor) const;
+    sal_uInt8			GrayOf  (BitmapColor& rColor) const;
+    
+    SalPrinterBmp ();
+
+	public:
+
+							SalPrinterBmp (BitmapBuffer* pBitmap);
+		virtual				~SalPrinterBmp ();
+		virtual sal_uInt32	GetPaletteColor (sal_uInt32 nIdx) const;
+		virtual sal_uInt32	GetPaletteEntryCount () const;
+		virtual sal_uInt32	GetPixelRGB  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
+		virtual sal_uInt8	GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const;
+		virtual sal_uInt8	GetPixelIdx  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
+		virtual sal_uInt32	GetWidth () const;
+		virtual sal_uInt32	GetHeight() const;
+		virtual sal_uInt32	GetDepth ()	const;
+};
+
+SalPrinterBmp::SalPrinterBmp (BitmapBuffer* pBuffer) :
+		mpBmpBuffer (pBuffer)
+{
+	DBG_ASSERT (mpBmpBuffer, "SalPrinterBmp::SalPrinterBmp () can't acquire Bitmap");
+
+	// calibrate scanline buffer
+	if( BMP_SCANLINE_ADJUSTMENT( mpBmpBuffer->mnFormat ) == BMP_FORMAT_TOP_DOWN )
+	{
+		mpScanAccess = mpBmpBuffer->mpBits;
+		mnScanOffset = mpBmpBuffer->mnScanlineSize;
+	}
+	else
+	{
+		mpScanAccess = mpBmpBuffer->mpBits
+					   + (mpBmpBuffer->mnHeight - 1) * mpBmpBuffer->mnScanlineSize;
+		mnScanOffset = - mpBmpBuffer->mnScanlineSize;
+	}
+
+	// request read access to the pixels
+	switch( BMP_SCANLINE_FORMAT( mpBmpBuffer->mnFormat ) )
+	{
+		case BMP_FORMAT_1BIT_MSB_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_MSB_PAL;	 break;
+		case BMP_FORMAT_1BIT_LSB_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_LSB_PAL;	 break;
+		case BMP_FORMAT_4BIT_MSN_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_MSN_PAL;	 break;
+		case BMP_FORMAT_4BIT_LSN_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_LSN_PAL;	 break;
+		case BMP_FORMAT_8BIT_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_PAL; 	 break;
+		case BMP_FORMAT_8BIT_TC_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_TC_MASK;	 break;
+		case BMP_FORMAT_16BIT_TC_MSB_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_MSB_MASK; break;
+		case BMP_FORMAT_16BIT_TC_LSB_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_LSB_MASK; break;
+		case BMP_FORMAT_24BIT_TC_BGR:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_BGR;  break;
+		case BMP_FORMAT_24BIT_TC_RGB:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_RGB;  break;
+		case BMP_FORMAT_24BIT_TC_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_MASK; break;
+		case BMP_FORMAT_32BIT_TC_ABGR:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ABGR; break;
+		case BMP_FORMAT_32BIT_TC_ARGB:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ARGB; break;
+		case BMP_FORMAT_32BIT_TC_BGRA:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_BGRA; break;
+		case BMP_FORMAT_32BIT_TC_RGBA:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_RGBA; break;
+		case BMP_FORMAT_32BIT_TC_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_MASK; break;
+
+		default:
+			DBG_ERROR("Error: SalPrinterBmp::SalPrinterBmp() unknown bitmap format");
+		break;
+	}
+}
+
+SalPrinterBmp::~SalPrinterBmp ()
+{
+}
+
+sal_uInt32
+SalPrinterBmp::GetWidth () const
+{
+	return mpBmpBuffer->mnWidth;
+}
+
+sal_uInt32
+SalPrinterBmp::GetHeight () const
+{
+	return mpBmpBuffer->mnHeight;
+}
+
+sal_uInt32
+SalPrinterBmp::GetDepth () const
+{
+	sal_uInt32 nDepth;
+
+	switch (mpBmpBuffer->mnBitCount)
+	{
+		case 1:
+			nDepth = 1;
+			break;
+
+		case 4:
+		case 8:
+			nDepth = 8;
+			break;
+
+		case 16:
+		case 24:
+		case 32:
+			nDepth = 24;
+			break;
+
+		default:
+			DBG_ERROR ("Error: unsupported bitmap depth in SalPrinterBmp::GetDepth()");
+			break;
+	}
+
+	return nDepth;
+}
+
+sal_uInt32
+SalPrinterBmp::ColorOf (BitmapColor& rColor) const
+{
+	if (rColor.IsIndex())
+		return ColorOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
+	else
+		return 	  ((rColor.GetBlue()) 		 & 0x000000ff)
+				| ((rColor.GetGreen() <<  8) & 0x0000ff00)
+				| ((rColor.GetRed()   << 16) & 0x00ff0000);
+}
+
+sal_uInt8
+SalPrinterBmp::GrayOf (BitmapColor& rColor) const
+{
+	if (rColor.IsIndex())
+		return GrayOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
+	else
+		return (  rColor.GetBlue()  *  28UL
+				+ rColor.GetGreen() * 151UL
+				+ rColor.GetRed()   *  77UL ) >> 8;
+}
+
+sal_uInt32
+SalPrinterBmp::GetPaletteEntryCount () const
+{
+	return mpBmpBuffer->maPalette.GetEntryCount ();
+}
+
+sal_uInt32
+SalPrinterBmp::GetPaletteColor (sal_uInt32 nIdx) const
+{
+	return ColorOf (mpBmpBuffer->maPalette[nIdx]);
+}
+
+sal_uInt32
+SalPrinterBmp::GetPixelRGB (sal_uInt32 nRow, sal_uInt32 nColumn) const
+{
+	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
+	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
+
+	return ColorOf (aColor);
+}
+
+sal_uInt8
+SalPrinterBmp::GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const
+{
+	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
+	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
+
+	return GrayOf (aColor);
+}
+
+sal_uInt8
+SalPrinterBmp::GetPixelIdx (sal_uInt32 nRow, sal_uInt32 nColumn) const
+{
+	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
+	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
+
+	if (aColor.IsIndex())
+		return aColor.GetIndex();
+	else
+		return 0;
+}
+
+/*******************************************************
+ * PspGraphics                                         *
+ *******************************************************/
+
+PspGraphics::~PspGraphics()
+{
+}
+
+void PspGraphics::GetResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY )
+{
+	if (m_pJobData != NULL)
+	{
+		int x = m_pJobData->m_aContext.getRenderResolution();
+
+		rDPIX = x;
+		rDPIY = x;
+	}
+}
+
+void PspGraphics::GetScreenFontResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY )
+{
+    m_pPrinterGfx->GetScreenFontResolution (rDPIX, rDPIY);
+}
+
+USHORT PspGraphics::GetBitCount()
+{
+    return m_pPrinterGfx->GetBitCount();
+}
+
+long PspGraphics::GetGraphicsWidth()
+{
+    return 0;
+}
+
+void PspGraphics::ResetClipRegion()
+{
+    m_pPrinterGfx->ResetClipRegion ();
+}
+
+void PspGraphics::BeginSetClipRegion( ULONG n )
+{
+    m_pPrinterGfx->BeginSetClipRegion(n);
+}
+
+BOOL PspGraphics::unionClipRegion( long nX, long nY, long nDX, long nDY )
+{
+    return (BOOL)m_pPrinterGfx->UnionClipRegion (nX, nY, nDX, nDY);
+}
+
+void PspGraphics::EndSetClipRegion()
+{
+    m_pPrinterGfx->EndSetClipRegion ();
+}
+
+void PspGraphics::SetLineColor()
+{
+    m_pPrinterGfx->SetLineColor ();
+}
+
+void PspGraphics::SetLineColor( SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->SetLineColor (aColor);
+}
+
+void PspGraphics::SetFillColor()
+{
+    m_pPrinterGfx->SetFillColor ();
+}
+
+void PspGraphics::SetFillColor( SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->SetFillColor (aColor);
+}
+
+void PspGraphics::SetROPLineColor( SalROPColor nROPColor )
+{
+    DBG_ASSERT( 0, "Error: PrinterGfx::SetROPLineColor() not implemented" );
+}
+
+void PspGraphics::SetROPFillColor( SalROPColor nROPColor )
+{
+    DBG_ASSERT( 0, "Error: PrinterGfx::SetROPFillColor() not implemented" );
+}
+
+void PspGraphics::SetXORMode( BOOL bSet )
+{
+    DBG_ASSERT( !bSet, "Error: PrinterGfx::SetXORMode() not implemented" );
+}
+
+void PspGraphics::drawPixel( long nX, long nY )
+{
+    m_pPrinterGfx->DrawPixel (Point(nX, nY));
+}
+
+void PspGraphics::drawPixel( long nX, long nY, SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->DrawPixel (Point(nX, nY), aColor);
+}
+
+void PspGraphics::drawLine( long nX1, long nY1, long nX2, long nY2 )
+{
+    m_pPrinterGfx->DrawLine (Point(nX1, nY1), Point(nX2, nY2));
+}
+
+void PspGraphics::drawRect( long nX, long nY, long nDX, long nDY )
+{
+    m_pPrinterGfx->DrawRect (Rectangle(Point(nX, nY), Size(nDX, nDY)));
+}
+
+void PspGraphics::drawPolyLine( ULONG nPoints, const SalPoint *pPtAry )
+{
+    m_pPrinterGfx->DrawPolyLine (nPoints, (Point*)pPtAry);
+}
+
+void PspGraphics::drawPolygon( ULONG nPoints, const SalPoint* pPtAry )
+{
+	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
+    m_pPrinterGfx->DrawPolygon (nPoints, (Point*)pPtAry);
+}
+
+void PspGraphics::drawPolyPolygon( ULONG			nPoly,
+								   const ULONG	   *pPoints,
+								   PCONSTSALPOINT  *pPtAry )
+{
+    m_pPrinterGfx->DrawPolyPolygon (nPoly, pPoints, (const Point**)pPtAry);
+}
+
+sal_Bool PspGraphics::drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
+{
+    m_pPrinterGfx->DrawPolyLineBezier (nPoints, (Point*)pPtAry, pFlgAry);
+    return sal_True;
+}
+
+sal_Bool PspGraphics::drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
+{
+    m_pPrinterGfx->DrawPolygonBezier (nPoints, (Point*)pPtAry, pFlgAry);
+    return sal_True;
+}
+
+sal_Bool PspGraphics::drawPolyPolygonBezier( ULONG nPoly,
+                                             const ULONG* pPoints,
+                                             const SalPoint* const* pPtAry,
+                                             const BYTE* const* pFlgAry )
+{
+	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
+    m_pPrinterGfx->DrawPolyPolygonBezier (nPoly, pPoints, (Point**)pPtAry, (BYTE**)pFlgAry);
+    return sal_True;
+}
+
+void PspGraphics::invert( ULONG nPoints,
+                          const SalPoint* pPtAry,
+                          SalInvert nFlags )
+{
+    DBG_ASSERT( 0, "Error: PrinterGfx::Invert() not implemented" );
+}
+BOOL PspGraphics::drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize )
+{
+    return m_pPrinterGfx->DrawEPS( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ), pPtr, nSize );
+}
+
+void PspGraphics::copyBits( const SalTwoRect *pPosAry,
+                            SalGraphics	   *pSSrcGraphics )
+{
+    DBG_ERROR( "Error: PrinterGfx::CopyBits() not implemented" );
+}
+
+void PspGraphics::copyArea ( long nDestX,    long nDestY,
+                             long nSrcX,     long nSrcY,
+                             long nSrcWidth, long nSrcHeight,
+                             USHORT nFlags )
+{
+    DBG_ERROR( "Error: PrinterGfx::CopyArea() not implemented" );
+}
+
+void PspGraphics::drawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap )
+{
+    Rectangle aSrc (Point(pPosAry->mnSrcX, pPosAry->mnSrcY),
+                    Size(pPosAry->mnSrcWidth, pPosAry->mnSrcHeight));
+    Rectangle aDst (Point(pPosAry->mnDestX, pPosAry->mnDestY),
+                    Size(pPosAry->mnDestWidth, pPosAry->mnDestHeight));
+    
+    BitmapBuffer* pBuffer= const_cast<SalBitmap&>(rSalBitmap).AcquireBuffer(sal_True);
+    
+    SalPrinterBmp aBmp (pBuffer);
+    m_pPrinterGfx->DrawBitmap (aDst, aSrc, aBmp);
+    
+    const_cast<SalBitmap&>(rSalBitmap).ReleaseBuffer (pBuffer, sal_True);
+}
+
+void PspGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                              const SalBitmap& rSalBitmap,
+                              const SalBitmap& rTransBitmap )
+{
+    DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent bitmap");
+}
+
+void PspGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                              const SalBitmap& rSalBitmap,
+                              SalColor nTransparentColor )
+{
+    DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent color");
+}
+
+void PspGraphics::drawMask( const SalTwoRect* pPosAry,
+                            const SalBitmap &rSalBitmap,
+                            SalColor nMaskColor )
+{
+    DBG_ERROR("Error: PrinterGfx::DrawMask() not implemented");
+}
+
+SalBitmap* PspGraphics::getBitmap( long nX, long nY, long nDX, long nDY )
+{
+    DBG_WARNING ("Warning: PrinterGfx::GetBitmap() not implemented");
+    return NULL;
+}
+
+SalColor PspGraphics::getPixel( long nX, long nY )
+{
+    DBG_ERROR ("Warning: PrinterGfx::GetPixel() not implemented");
+    return 0;
+}
+
+void PspGraphics::invert(
+                         long		nX,
+                         long		nY,
+                         long		nDX,
+                         long		nDY,
+                         SalInvert	nFlags )
+{
+    DBG_ERROR ("Warning: PrinterGfx::Invert() not implemented");
+}
+
+/*
+ *  returns:
+ *  true: cut out positions rStart to rStop from output because fax number was swallowed
+ *  false: do nothing
+ */
+
+String PspGraphics::FaxPhoneComment( const String& rOrig, xub_StrLen nIndex, xub_StrLen& rLen, xub_StrLen& rCutStart, xub_StrLen& rCutStop ) const
+{
+    rCutStop = rCutStart = STRING_NOTFOUND;
+
+	if( ! m_pPhoneNr )
+		return String( rOrig );
+
+#define FAX_PHONE_TOKEN          "@@#"
+#define FAX_PHONE_TOKEN_LENGTH   3
+#define FAX_END_TOKEN            "@@"
+#define FAX_END_TOKEN_LENGTH     2
+
+	bool bRet = false;
+	bool bStarted = false;
+	bool bStopped = false;
+	USHORT nPos;
+	USHORT nStart = 0;
+	USHORT nStop = rLen;
+	String aPhone = rOrig.Copy( nIndex, rLen );
+
+	static String aPhoneNumber;
+	static bool bIsCollecting = false;
+
+	if( ! bIsCollecting )
+	{
+		if( ( nPos = aPhone.SearchAscii( FAX_PHONE_TOKEN ) ) != STRING_NOTFOUND )
+		{
+			nStart = nPos;
+			bIsCollecting = true;
+			aPhoneNumber.Erase();
+			bRet = true;
+			bStarted = true;
+		}
+	}
+	if( bIsCollecting )
+	{
+		bRet = true;
+		nPos = bStarted ? nStart + FAX_PHONE_TOKEN_LENGTH : 0;
+		if( ( nPos = aPhone.SearchAscii( FAX_END_TOKEN, nPos ) ) != STRING_NOTFOUND )
+		{
+			bIsCollecting = false;
+			nStop = nPos + FAX_END_TOKEN_LENGTH;
+			bStopped = true;
+		}
+		int nTokenStart = nStart + (bStarted ? FAX_PHONE_TOKEN_LENGTH : 0);
+		int nTokenStop = nStop - (bStopped ? FAX_END_TOKEN_LENGTH : 0);
+		aPhoneNumber += aPhone.Copy( nTokenStart, nTokenStop - nTokenStart );
+		if( ! bIsCollecting )
+		{
+			*m_pPhoneNr = aPhoneNumber;
+			aPhoneNumber.Erase();
+		}
+	}
+	if( aPhoneNumber.Len() > 1024 )
+	{
+		bIsCollecting = false;
+		aPhoneNumber.Erase();
+		bRet = false;
+	}
+
+    String aRet;
+    if( bRet && m_bSwallowFaxNo )
+    {
+        rLen -= nStop - nStart;
+        rCutStart = nStart+nIndex;
+        rCutStop = nStop+nIndex;
+        if( rCutStart )
+            aRet = rOrig.Copy( 0, rCutStart );
+        aRet += rOrig.Copy( rCutStop );
+    }
+    else
+        aRet = rOrig;
+
+    return aRet;
+}
+
+class PspFontLayout : public GenericSalLayout
+{
+public:
+                        PspFontLayout( ::psp::PrinterGfx& );
+    virtual bool        LayoutText( ImplLayoutArgs& );
+    virtual void        InitFont() const;
+    virtual void        DrawText( SalGraphics& ) const;
+private:
+    ::psp::PrinterGfx&  mrPrinterGfx;
+    int                 mnFontID;
+    int                 mnFontHeight;
+    int                 mnFontWidth;
+    bool                mbVertical;
+    bool				mbArtItalic;
+    bool				mbArtBold;
+};
+
+//--------------------------------------------------------------------------
+
+PspFontLayout::PspFontLayout( ::psp::PrinterGfx& rGfx )
+:   mrPrinterGfx( rGfx )
+{
+    mnFontID     = mrPrinterGfx.GetFontID();
+    mnFontHeight = mrPrinterGfx.GetFontHeight();
+    mnFontWidth  = mrPrinterGfx.GetFontWidth();
+    mbVertical   = mrPrinterGfx.GetFontVertical();
+    mbArtItalic	 = mrPrinterGfx.GetArtificialItalic();
+    mbArtBold	 = mrPrinterGfx.GetArtificialBold();
+}
+
+//--------------------------------------------------------------------------
+
+bool PspFontLayout::LayoutText( ImplLayoutArgs& rArgs )
+{
+    mbVertical = ((rArgs.mnFlags & SAL_LAYOUT_VERTICAL) != 0);
+
+    long nUnitsPerPixel = 1;
+    int nOldGlyphId = -1;
+    long nGlyphWidth = 0;
+    int nCharPos = -1;
+    Point aNewPos( 0, 0 );
+    GlyphItem aPrevItem;
+    rtl_TextEncoding aFontEnc = mrPrinterGfx.GetFontMgr().getFontEncoding( mnFontID );
+    for(;;)
+    {
+        bool bRightToLeft;
+        if( !rArgs.GetNextPos( &nCharPos, &bRightToLeft ) )
+            break;
+
+        sal_Unicode cChar = rArgs.mpStr[ nCharPos ];
+        if( bRightToLeft )
+            cChar = GetMirroredChar( cChar );
+        // symbol font aliasing: 0x0020-0x00ff -> 0xf020 -> 0xf0ff
+        if( aFontEnc == RTL_TEXTENCODING_SYMBOL )
+            if( cChar < 256 )
+                cChar += 0xf000;
+        int nGlyphIndex = cChar;  // printer glyphs = unicode
+
+        // update fallback_runs if needed
+        psp::CharacterMetric aMetric;
+        mrPrinterGfx.GetFontMgr().getMetrics( mnFontID, cChar, cChar, &aMetric, mbVertical );
+        if( aMetric.width == -1 && aMetric.height == -1 )
+            rArgs.NeedFallback( nCharPos, bRightToLeft );
+
+        // apply pair kerning to prev glyph if requested
+        if( SAL_LAYOUT_KERNING_PAIRS & rArgs.mnFlags )
+        {
+            if( nOldGlyphId > 0 )
+            {
+                const std::list< KernPair >& rKernPairs = mrPrinterGfx.getKernPairs(mbVertical);
+                for( std::list< KernPair >::const_iterator it = rKernPairs.begin();
+                     it != rKernPairs.end(); ++it )
+                {
+                    if( it->first == nOldGlyphId && it->second == nGlyphIndex )
+                    {
+                        int nTextScale = mrPrinterGfx.GetFontWidth();
+                        if( ! nTextScale )
+                            nTextScale = mrPrinterGfx.GetFontHeight();
+                        int nKern = (mbVertical ? it->kern_y : it->kern_x) * nTextScale;
+                        nGlyphWidth += nKern;
+                        aPrevItem.mnNewWidth = nGlyphWidth;
+                        break;
+                    }
+                }
+            }
+        }
+        
+        // finish previous glyph
+        if( nOldGlyphId >= 0 )
+            AppendGlyph( aPrevItem );
+        nOldGlyphId = nGlyphIndex;
+        aNewPos.X() += nGlyphWidth;
+
+        // prepare GlyphItem for appending it in next round
+        nUnitsPerPixel = mrPrinterGfx.GetCharWidth( cChar, cChar, &nGlyphWidth );
+        int nGlyphFlags = bRightToLeft ? GlyphItem::IS_RTL_GLYPH : 0;
+        nGlyphIndex |= GF_ISCHAR;
+        aPrevItem = GlyphItem( nCharPos, nGlyphIndex, aNewPos, nGlyphFlags, nGlyphWidth );
+    }
+
+    // append last glyph item if any
+    if( nOldGlyphId >= 0 )
+        AppendGlyph( aPrevItem );
+
+    SetOrientation( mrPrinterGfx.GetFontAngle() );
+    SetUnitsPerPixel( nUnitsPerPixel );
+    return (nOldGlyphId >= 0);
+}
+
+class PspServerFontLayout : public ServerFontLayout
+{
+public:
+    PspServerFontLayout( ::psp::PrinterGfx&, ServerFont& rFont );
+
+    virtual void        InitFont() const;
+private:
+    ::psp::PrinterGfx&  mrPrinterGfx;
+    int                 mnFontID;
+    int                 mnFontHeight;
+    int                 mnFontWidth;
+    bool                mbVertical;
+    bool				mbArtItalic;
+    bool				mbArtBold;
+};
+
+PspServerFontLayout::PspServerFontLayout( ::psp::PrinterGfx& rGfx, ServerFont& rFont )
+        :   ServerFontLayout( rFont ),
+            mrPrinterGfx( rGfx )
+{
+    mnFontID     = mrPrinterGfx.GetFontID();
+    mnFontHeight = mrPrinterGfx.GetFontHeight();
+    mnFontWidth  = mrPrinterGfx.GetFontWidth();
+    mbVertical   = mrPrinterGfx.GetFontVertical();
+    mbArtItalic	 = mrPrinterGfx.GetArtificialItalic();
+    mbArtBold	 = mrPrinterGfx.GetArtificialBold();
+}
+
+void PspServerFontLayout::InitFont() const
+{
+    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
+                          mnOrientation, mbVertical, mbArtItalic, mbArtBold );
+}
+
+//--------------------------------------------------------------------------
+
+void DrawPrinterLayout( const SalLayout& rLayout, ::psp::PrinterGfx& rGfx )
+{
+    const int nMaxGlyphs = 200;
+    sal_Int32   aGlyphAry[ nMaxGlyphs ];
+    sal_Int32   aWidthAry[ nMaxGlyphs ];
+    sal_Int32   aIdxAry  [ nMaxGlyphs ];
+    sal_Unicode aUnicodes[ nMaxGlyphs ];
+    Point aPos;
+    long nUnitsPerPixel = rLayout.GetUnitsPerPixel();
+    for( int nStart = 0;; )
+    {
+        int nGlyphCount = rLayout.GetNextGlyphs( nMaxGlyphs, aGlyphAry, aPos, nStart, aWidthAry );
+        if( !nGlyphCount )
+            break;
+
+        sal_Int32 nXOffset = 0;
+        for( int i = 0; i < nGlyphCount; ++i )
+        {
+            nXOffset += aWidthAry[ i ];
+            aIdxAry[ i ] = nXOffset / nUnitsPerPixel;
+            sal_uInt32 nGlyphIdx = aGlyphAry[i] & (GF_IDXMASK | GF_ROTMASK);
+            aUnicodes[i] = (aGlyphAry[i] & GF_ISCHAR) ? nGlyphIdx : 0;
+            aGlyphAry[i] = nGlyphIdx;
+        }
+
+        rGfx.DrawGlyphs( aPos, (sal_uInt32 *)aGlyphAry, aUnicodes, nGlyphCount, aIdxAry );
+    }
+}
+
+//--------------------------------------------------------------------------
+
+void PspFontLayout::InitFont() const
+{
+    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
+        mnOrientation, mbVertical, mbArtItalic, mbArtBold );
+}
+
+//--------------------------------------------------------------------------
+
+void PspFontLayout::DrawText( SalGraphics& ) const
+{
+    DrawPrinterLayout( *this, mrPrinterGfx );
+}
+
+void PspGraphics::DrawServerFontLayout( const ServerFontLayout& rLayout )
+{
+#ifdef USE_BUILTIN_RASTERIZER
+    // print complex text
+    DrawPrinterLayout( rLayout, *m_pPrinterGfx );
+#endif
+}
+
+ULONG PspGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
+
+{
+    ULONG nPairs = 0;
+#ifdef USE_BUILTIN_RASTERIZER
+    if( m_pServerFont[0] )
+        nPairs = m_pServerFont[0]->GetFontCodeRanges( pCodePairs );
+#endif //USE_BUILTIN_RASTERIZER
+    return nPairs;
+}
+
+USHORT PspGraphics::SetFont( ImplFontSelectData *pEntry, int nFallbackLevel )
+{
+    sal_Bool bVertical = pEntry->mbVertical;
+    sal_Int32 nID = pEntry->mpFontData ? (sal_Int32)pEntry->mpFontData->mpSysData : 0;
+
+    bool bArtItalic = false;
+    bool bArtBold = false;
+    if( pEntry->meItalic == ITALIC_OBLIQUE || pEntry->meItalic == ITALIC_NORMAL )
+    {
+        psp::italic::type eItalic = m_pPrinterGfx->GetFontMgr().getFontItalic( nID );
+        if( eItalic != psp::italic::Italic && eItalic != psp::italic::Oblique )
+            bArtItalic = true;
+    }
+    int nWeight = (int)pEntry->meWeight;
+    int nRealWeight = (int)m_pPrinterGfx->GetFontMgr().getFontWeight( nID );
+    if( nRealWeight < nWeight-2 ||
+        ( nRealWeight < (int)psp::weight::SemiBold && nWeight > (int)WEIGHT_NORMAL) )
+    {
+        bArtBold = true;
+    }
+
+    // also set the serverside font for layouting
+    m_bFontVertical	= pEntry->mbVertical;
+    for( int i = nFallbackLevel; i < MAX_FALLBACK; ++i )
+    {
+        if( m_pServerFont[i] != NULL )
+        {
+            // old server side font is no longer referenced
+            GlyphCache::GetInstance().UncacheFont( *m_pServerFont[i] );
+            m_pServerFont[i] = NULL;
+        }
+    }
+
+    if( pEntry->mpFontData )
+    {
+        // requesting a font provided by builtin rasterizer
+        ServerFont* pServerFont = GlyphCache::GetInstance().CacheFont( *pEntry );
+        if( pServerFont != NULL )
+        {
+            if( pServerFont->TestFont() )
+                m_pServerFont[ nFallbackLevel ] = pServerFont;
+            else
+                GlyphCache::GetInstance().UncacheFont( *pServerFont );
+        }
+        else
+            m_pServerFont[ nFallbackLevel ] = pServerFont;
+    }
+
+    // set the printer font
+    return m_pPrinterGfx->SetFont( nID,
+                                   pEntry->mnHeight,
+                                   pEntry->mnWidth,
+                                   pEntry->mnOrientation,
+                                   pEntry->mbVertical,
+                                   bArtItalic,
+                                   bArtBold
+                                   );
+}
+
+void PspGraphics::SetTextColor( SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->SetTextColor (aColor);
+}
+
+ImplFontData* PspGraphics::AddTempDevFont(const String& rFileURL, const String& rFontName )
+{
+    return NULL;
+}
+
+void PspGraphics::GetDevFontList( ImplDevFontList *pList )
+{
+    const char* pLangBoost = NULL;
+    const LanguageType aLang = Application::GetSettings().GetUILanguage();
+    switch( aLang )
+    {
+        case LANGUAGE_JAPANESE:
+            pLangBoost = "jan";    // japanese is default
+            break;
+        case LANGUAGE_CHINESE:
+        case LANGUAGE_CHINESE_SIMPLIFIED:
+        case LANGUAGE_CHINESE_SINGAPORE:
+            pLangBoost = "zhs";
+            break;
+        case LANGUAGE_CHINESE_TRADITIONAL:
+        case LANGUAGE_CHINESE_HONGKONG:
+        case LANGUAGE_CHINESE_MACAU:
+            pLangBoost = "zht";
+            break;
+        case LANGUAGE_KOREAN:
+        case LANGUAGE_KOREAN_JOHAB:
+            pLangBoost = "kor";
+            break;
+    }
+    
+    ::std::list< psp::fontID > aList;
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    rMgr.getFontList( aList, m_pJobData->m_pParser );
+    
+    ::std::list< psp::fontID >::iterator it;
+    for (it = aList.begin(); it != aList.end(); ++it)
+    {
+        psp::FastPrintFontInfo aInfo;
+        if (rMgr.getFontFastInfo (*it, aInfo))
+        {
+            ImplFontData *pFontData = new ImplFontData;
+            SetImplFontData( aInfo, *pFontData );
+            pFontData->mpSysData = (void*)*it;
+            if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
+                pFontData->maName = pFontData->maName.Copy( 4 );
+            if( aInfo.m_eType == psp::fonttype::TrueType )
+            {
+                // prefer truetype fonts
+                pFontData->mnQuality += 10;
+                // asian type 1 fonts are not known
+                ByteString aFileName( rMgr.getFontFileSysPath( *it ) );
+                int nPos = aFileName.SearchBackward( '_' );
+                if( nPos == STRING_NOTFOUND || aFileName.GetChar( nPos+1 ) == '.' )
+                    pFontData->mnQuality += 5;
+                else
+                {
+                    if( pLangBoost && aFileName.Copy( nPos+1, 3 ).EqualsIgnoreCaseAscii( pLangBoost ) )
+                        pFontData->mnQuality += 10;
+                }
+            }
+            pList->Add( pFontData );
+        }
+    }
+}
+
+void PspGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
+{
+    const psp::PrinterInfo& rInfo = psp::PrinterInfoManager::get().getPrinterInfo( m_pJobData->m_aPrinterName );
+    if( rInfo.m_bPerformFontSubstitution )
+    {
+        for( std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >::const_iterator it = rInfo.m_aFontSubstitutes.begin(); it != rInfo.m_aFontSubstitutes.end(); ++it )
+            pOutDev->ImplAddDevFontSubstitute( it->first, it->second, FONT_SUBSTITUTE_ALWAYS );
+    }
+}
+
+void PspGraphics::GetFontMetric( ImplFontMetricData *pMetric )
+{
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    psp::PrintFontInfo aInfo;
+    
+    if (rMgr.getFontInfo (m_pPrinterGfx->GetFontID(), aInfo))
+    {
+        sal_Int32 nTextHeight	= m_pPrinterGfx->GetFontHeight();
+        sal_Int32 nTextWidth	= m_pPrinterGfx->GetFontWidth();
+        if( ! nTextWidth )
+            nTextWidth = nTextHeight;
+        
+        pMetric->mnOrientation 	= m_pPrinterGfx->GetFontAngle();
+        pMetric->mnSlant		= 0;
+        pMetric->mbDevice		= aInfo.m_eType == psp::fonttype::Builtin ? sal_True : sal_False;
+        
+        pMetric->meCharSet		= aInfo.m_aEncoding;
+        
+        pMetric->meFamily		= ToFontFamily (aInfo.m_eFamilyStyle);
+        pMetric->meWeight		= ToFontWeight (aInfo.m_eWeight);
+        pMetric->mePitch		= ToFontPitch  (aInfo.m_ePitch);
+        pMetric->meItalic		= ToFontItalic (aInfo.m_eItalic);
+        pMetric->meType			= TYPE_SCALABLE;
+        
+        pMetric->mnFirstChar	=   0;
+        pMetric->mnLastChar		= 255;
+        
+        pMetric->mnWidth		= nTextWidth;
+        pMetric->mnAscent		= ( aInfo.m_nAscend * nTextHeight + 500 ) / 1000;
+        pMetric->mnDescent		= ( aInfo.m_nDescend * nTextHeight + 500 ) / 1000;
+        pMetric->mnLeading		= ( aInfo.m_nLeading * nTextHeight + 500 ) / 1000;
+    }
+}
+
+ULONG PspGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData *pKernPairs )
+{
+    const ::std::list< ::psp::KernPair >& rPairs( m_pPrinterGfx->getKernPairs() );
+    ULONG nHavePairs = rPairs.size();
+    if( pKernPairs && nPairs )
+    {
+        ::std::list< ::psp::KernPair >::const_iterator it;
+        int i;
+        int nTextScale = m_pPrinterGfx->GetFontWidth();
+        if( ! nTextScale )
+            nTextScale = m_pPrinterGfx->GetFontHeight();
+        for( i = 0, it = rPairs.begin(); i < nPairs && i < nHavePairs; i++, ++it )
+        {
+            pKernPairs[i].mnChar1	= it->first;
+            pKernPairs[i].mnChar2	= it->second;
+            pKernPairs[i].mnKern	= it->kern_x * nTextScale / 1000;
+        }
+        
+    }
+    return nHavePairs;
+}
+
+BOOL PspGraphics::GetGlyphBoundRect( long nGlyphIndex, Rectangle& rRect )
+{
+    int nLevel = nGlyphIndex >> GF_FONTSHIFT;
+    if( nLevel >= MAX_FALLBACK )
+        return FALSE;
+
+    ServerFont* pSF = m_pServerFont[ nLevel ];
+    if( !pSF )
+        return FALSE;
+
+    nGlyphIndex &= ~GF_FONTMASK;
+    const GlyphMetric& rGM = pSF->GetGlyphMetric( nGlyphIndex );
+    rRect = Rectangle( rGM.GetOffset(), rGM.GetSize() );
+    return TRUE;
+}
+
+BOOL PspGraphics::GetGlyphOutline( long nGlyphIndex, PolyPolygon& rPolyPoly )
+{
+    int nLevel = nGlyphIndex >> GF_FONTSHIFT;
+    if( nLevel >= MAX_FALLBACK )
+        return FALSE;
+
+    ServerFont* pSF = m_pServerFont[ nLevel ];
+    if( !pSF )
+        return FALSE;
+
+    nGlyphIndex &= ~GF_FONTMASK;
+    if( pSF->GetGlyphOutline( nGlyphIndex, rPolyPoly ) )
+        return TRUE;
+
+    return FALSE;
+}
+
+SalLayout* PspGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
+{
+    // workaround for printers not handling glyph indexing for non-TT fonts
+    int nFontId = m_pPrinterGfx->GetFontID();
+    if( psp::fonttype::TrueType != psp::PrintFontManager::get().getFontType( nFontId ) )
+        rArgs.mnFlags |= SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
+    else if( nFallbackLevel > 0 )
+        rArgs.mnFlags &= ~SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
+
+    GenericSalLayout* pLayout = NULL;
+
+    if( m_pServerFont[ nFallbackLevel ]
+        && !(rArgs.mnFlags & SAL_LAYOUT_DISABLE_GLYPH_PROCESSING) )
+        pLayout = new PspServerFontLayout( *m_pPrinterGfx, *m_pServerFont[nFallbackLevel] );
+    else
+        pLayout = new PspFontLayout( *m_pPrinterGfx );
+
+    return pLayout;
+}
+//--------------------------------------------------------------------------
+
+BOOL PspGraphics::CreateFontSubset(
+                                   const rtl::OUString& rToFile,
+                                   ImplFontData* pFont,
+                                   sal_Int32* pGlyphIDs,
+                                   sal_uInt8* pEncoding,
+                                   sal_Int32* pWidths,
+                                   int nGlyphs,
+                                   FontSubsetInfo& rInfo
+                                   )
+{
+    // in this context the sysdata member of pFont should
+    // contain a fontID as the X fonts should be filtered
+    // out of the font list available to PDF export (for
+    // which this method was created). The correct way would
+    // be to have the GlyphCache search for the ImplFontData pFont
+    psp::fontID aFont = (psp::fontID)pFont->mpSysData;
+    return PspGraphics::DoCreateFontSubset( rToFile, aFont, pGlyphIDs, pEncoding, pWidths, nGlyphs, rInfo );
+}
+
+//--------------------------------------------------------------------------
+
+const void* PspGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+{
+    // in this context the sysdata member of pFont should
+    // contain a fontID as the X fonts should be filtered
+    // out of the font list available to PDF export (for
+    // which this method was created). The correct way would
+    // be to have the GlyphCache search for the ImplFontData pFont
+    psp::fontID aFont = (psp::fontID)pFont->mpSysData;
+    return PspGraphics::DoGetEmbedFontData( aFont, pUnicodes, pWidths, rInfo, pDataLen );
+}
+
+//--------------------------------------------------------------------------
+
+void PspGraphics::FreeEmbedFontData( const void* pData, long nLen )
+{
+    PspGraphics::DoFreeEmbedFontData( pData, nLen );
+}
+
+//--------------------------------------------------------------------------
+
+const std::map< sal_Unicode, sal_Int32 >* PspGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+{
+    // in this context the sysdata member of pFont should
+    // contain a fontID as the X fonts should be filtered
+    // out of the font list available to PDF export (for
+    // which this method was created). The correct way would
+    // be to have the GlyphCache search for the ImplFontData pFont
+    psp::fontID aFont = (psp::fontID)pFont->mpSysData;
+    return PspGraphics::DoGetFontEncodingVector( aFont, pNonEncoded );
+}
+
+
+// static helpers of PspGraphics
+
+bool PspGraphics::DoCreateFontSubset( const rtl::OUString& rToFile,
+                                      psp::fontID aFont,
+                                      sal_Int32* pGlyphIDs,
+                                      sal_uInt8* pEncoding,
+                                      sal_Int32* pWidths,
+                                      int nGlyphs,
+                                      FontSubsetInfo& rInfo )
+{
+    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    psp::PrintFontInfo aFontInfo;
+    
+    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
+        return false;
+    
+    // fill in font info
+    switch( aFontInfo.m_eType )
+    {
+        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
+        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
+        default:
+            return false;
+    }
+    rInfo.m_nAscent     = aFontInfo.m_nAscend;
+    rInfo.m_nDescent    = aFontInfo.m_nDescend;
+    rInfo.m_aPSName     = rMgr.getPSName( aFont );
+    
+    int xMin, yMin, xMax, yMax;
+    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
+    
+    if( ! rMgr.createFontSubset( aFont,
+                                 rToFile,
+                                 pGlyphIDs,
+                                 pEncoding,
+                                 pWidths,
+                                 nGlyphs
+                                 ) )
+        return false;
+
+    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
+    rInfo.m_nCapHeight	= yMax; // Well ...
+
+    return true;
+}
+
+const void* PspGraphics::DoGetEmbedFontData( fontID aFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+{
+    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    
+    psp::PrintFontInfo aFontInfo;
+    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
+        return NULL;
+    
+    // fill in font info
+    switch( aFontInfo.m_eType )
+    {
+        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
+        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
+        default:
+            return NULL;
+    }
+    rInfo.m_nAscent		= aFontInfo.m_nAscend;
+    rInfo.m_nDescent	= aFontInfo.m_nDescend;
+    rInfo.m_aPSName		= rMgr.getPSName( aFont );
+    
+    int xMin, yMin, xMax, yMax;
+    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
+    
+    psp::CharacterMetric aMetrics[256];
+    sal_Unicode aUnicodes[256];
+    if( aFontInfo.m_aEncoding == RTL_TEXTENCODING_SYMBOL && aFontInfo.m_eType == psp::fonttype::Type1 )
+    {
+        for( int i = 0; i < 256; i++ )
+            aUnicodes[i] = pUnicodes[i] < 0x0100 ? pUnicodes[i] + 0xf000 : pUnicodes[i];
+        pUnicodes = aUnicodes;
+    }
+    if( ! rMgr.getMetrics( aFont, pUnicodes, 256, aMetrics ) )
+        return NULL;
+    
+    OString aSysPath = rMgr.getFontFileSysPath( aFont );
+    struct stat aStat;
+    if( stat( aSysPath.getStr(), &aStat ) )
+        return NULL;
+    int fd = open( aSysPath.getStr(), O_RDONLY );
+    if( fd < 0 )
+        return NULL;
+    void* pFile = mmap( NULL, aStat.st_size, PROT_READ, MAP_SHARED, fd, 0 );
+    close( fd );
+    if( pFile == MAP_FAILED )
+        return NULL;
+    
+    *pDataLen = aStat.st_size;
+    
+    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
+    rInfo.m_nCapHeight	= yMax; // Well ...
+    
+    for( int i = 0; i < 256; i++ )
+        
+        pWidths[i] = (aMetrics[i].width > 0 ? aMetrics[i].width : 0);
+    
+    return pFile;
+}
+
+void PspGraphics::DoFreeEmbedFontData( const void* pData, long nLen )
+{
+    if( pData )
+        munmap( (char*)pData, nLen );
+}
+
+const std::map< sal_Unicode, sal_Int32 >* PspGraphics::DoGetFontEncodingVector( fontID aFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+{
+    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    
+    psp::PrintFontInfo aFontInfo;
+    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
+    {
+        if( pNonEncoded )
+            *pNonEncoded = NULL;
+        return NULL;
+    }
+
+    return rMgr.getEncodingMap( aFont, pNonEncoded );
+}
+
+void PspGraphics::SetImplFontData( const psp::FastPrintFontInfo& aInfo, ImplFontData& rData )
+{
+	rData.meFamily     	= ToFontFamily (aInfo.m_eFamilyStyle);
+	rData.meWeight     	= ToFontWeight (aInfo.m_eWeight);
+
+	rData.meItalic     	= ToFontItalic (aInfo.m_eItalic);
+	rData.meWidthType  	= ToFontWidth  (aInfo.m_eWidth);
+	rData.mePitch	   	= ToFontPitch  (aInfo.m_ePitch);
+	rData.meCharSet    	= aInfo.m_aEncoding;
+	rData.maName		= aInfo.m_aFamilyName;
+	// rData.meScript		= SCRIPT_DONTKNOW;
+	/*rData.maStyleName	= XXX */
+
+	rData.mnWidth		= 0;
+	rData.mnHeight		= 0;
+	rData.mbOrientation	= TRUE;
+	rData.mnQuality		= (aInfo.m_eType == psp::fonttype::Builtin ? 1024 : 0);
+	rData.mnVerticalOrientation= 0;
+	rData.meType		= TYPE_SCALABLE;
+	rData.mbDevice		= (aInfo.m_eType == psp::fonttype::Builtin);
+    String aMapNames;
+    for( ::std::list< OUString >::const_iterator it = aInfo.m_aAliases.begin(); it != aInfo.m_aAliases.end(); ++it )
+    {
+        if( it != aInfo.m_aAliases.begin() )
+            aMapNames.Append(';');
+        aMapNames.Append( String( *it ) );
+    }
+    rData.maMapNames	= aMapNames;
+    switch( aInfo.m_eType )
+    {
+        case psp::fonttype::TrueType:
+            rData.mbSubsettable	= TRUE;
+            rData.mbEmbeddable	= FALSE;
+            break;
+        case psp::fonttype::Type1:
+            rData.mbSubsettable	= FALSE;
+            rData.mbEmbeddable	= TRUE;
+            break;
+        default:
+            rData.mbSubsettable = FALSE;
+            rData.mbEmbeddable	= FALSE;
+            break;
+    }
+}
+
+FontWidth PspGraphics::ToFontWidth (psp::width::type eWidth)
+{
+	switch (eWidth)
+	{
+		case psp::width::UltraCondensed: return WIDTH_ULTRA_CONDENSED;
+		case psp::width::ExtraCondensed: return WIDTH_EXTRA_CONDENSED;
+		case psp::width::Condensed:		 return WIDTH_CONDENSED;
+		case psp::width::SemiCondensed:	 return WIDTH_SEMI_CONDENSED;
+		case psp::width::Normal:		 return WIDTH_NORMAL;
+		case psp::width::SemiExpanded:	 return WIDTH_SEMI_EXPANDED;
+		case psp::width::Expanded:		 return WIDTH_EXPANDED;
+		case psp::width::ExtraExpanded:	 return WIDTH_EXTRA_EXPANDED;
+		case psp::width::UltraExpanded:	 return WIDTH_ULTRA_EXPANDED;
+	}
+	return WIDTH_DONTKNOW;
+}
+
+FontWeight PspGraphics::ToFontWeight (psp::weight::type eWeight)
+{
+	switch (eWeight)
+	{
+		case psp::weight::Thin:		  return WEIGHT_THIN;
+		case psp::weight::UltraLight: return WEIGHT_ULTRALIGHT;
+		case psp::weight::Light:	  return WEIGHT_LIGHT;
+		case psp::weight::SemiLight:  return WEIGHT_SEMILIGHT;
+		case psp::weight::Normal:	  return WEIGHT_NORMAL;
+		case psp::weight::Medium:	  return WEIGHT_MEDIUM;
+		case psp::weight::SemiBold:	  return WEIGHT_SEMIBOLD;
+		case psp::weight::Bold:		  return WEIGHT_BOLD;
+		case psp::weight::UltraBold:  return WEIGHT_ULTRABOLD;
+		case psp::weight::Black:	  return WEIGHT_BLACK;
+	}
+	return WEIGHT_DONTKNOW;
+}
+
+FontPitch PspGraphics::ToFontPitch (psp::pitch::type ePitch)
+{
+	switch (ePitch)
+	{
+		case psp::pitch::Fixed:		return PITCH_FIXED;
+		case psp::pitch::Variable:	return PITCH_VARIABLE;
+	}
+	return PITCH_DONTKNOW;
+}
+
+FontItalic PspGraphics::ToFontItalic (psp::italic::type eItalic)
+{
+	switch (eItalic)
+	{
+		case psp::italic::Upright:	return ITALIC_NONE;
+		case psp::italic::Oblique:	return ITALIC_OBLIQUE;
+		case psp::italic::Italic:	return ITALIC_NORMAL;
+	}
+	return ITALIC_DONTKNOW;
+}
+
+FontFamily PspGraphics::ToFontFamily (psp::family::type eFamily)
+{
+	switch (eFamily)
+	{
+		case psp::family::Decorative: return FAMILY_DECORATIVE;
+		case psp::family::Modern:	  return FAMILY_MODERN;
+		case psp::family::Roman:	  return FAMILY_ROMAN;
+		case psp::family::Script:	  return FAMILY_SCRIPT;
+		case psp::family::Swiss:	  return FAMILY_SWISS;
+		case psp::family::System:	  return FAMILY_SYSTEM;
+	}
+	return FAMILY_DONTKNOW;
+}
Index: vcl/unx/source/gdi/salbmp.cxx
===================================================================
--- vcl/unx/source/gdi/salbmp.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/salbmp.cxx	2004-09-14 14:09:32.382286120 +0200
@@ -59,20 +59,18 @@
  *
  ************************************************************************/
 
-#define _SV_SALBMP_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
 #include <string.h>
 #include <stdio.h>
 #include <errno.h>
 #ifdef FREEBSD
 #include <sys/types.h>
 #endif
-#include <sys/shm.h>
 #include <prex.h>
 #include <postx.h>
 #include <salunx.h>
+#ifndef _OSL_ENDIAN_H_
+#include <osl/endian.h>
+#endif
 #ifndef _RTL_MEMORY_H_
 #include <rtl/memory.h>
 #endif
@@ -85,11 +83,14 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
+#endif
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 // -----------
@@ -102,12 +103,17 @@
 // - SalBitmap -
 // -------------
 
-ImplSalBitmapCache*	SalBitmap::mpCache = NULL;
-ULONG				SalBitmap::mnCacheInstCount = 0;
+SalBitmap* X11SalInstance::CreateSalBitmap()
+{
+    return new X11SalBitmap();
+}
+
+ImplSalBitmapCache*	X11SalBitmap::mpCache = NULL;
+ULONG				X11SalBitmap::mnCacheInstCount = 0;
 
 // -----------------------------------------------------------------------------
 
-SalBitmap::SalBitmap() :
+X11SalBitmap::X11SalBitmap() :
 	mpDIB( NULL ),
 	mpDDB( NULL )
 {
@@ -115,14 +121,14 @@ SalBitmap::SalBitmap() :
 
 // -----------------------------------------------------------------------------
 
-SalBitmap::~SalBitmap()
+X11SalBitmap::~X11SalBitmap()
 {
 	Destroy();
 }
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ImplCreateCache()
+void X11SalBitmap::ImplCreateCache()
 {
 	if( !mnCacheInstCount++ )
 		mpCache = new ImplSalBitmapCache;
@@ -130,9 +136,9 @@ void SalBitmap::ImplCreateCache()
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ImplDestroyCache()
+void X11SalBitmap::ImplDestroyCache()
 {
-	DBG_ASSERT( mnCacheInstCount, "SalBitmap::ImplDestroyCache(): underflow" );
+	DBG_ASSERT( mnCacheInstCount, "X11SalBitmap::ImplDestroyCache(): underflow" );
 
 	if( mnCacheInstCount && !--mnCacheInstCount )
 		delete mpCache, mpCache = NULL;
@@ -140,7 +146,7 @@ void SalBitmap::ImplDestroyCache()
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ImplRemovedFromCache()
+void X11SalBitmap::ImplRemovedFromCache()
 {
 	if( mpDDB )
 		delete mpDDB, mpDDB = NULL;
@@ -148,7 +154,7 @@ void SalBitmap::ImplRemovedFromCache()
 
 // -----------------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+BitmapBuffer* X11SalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
 	DBG_ASSERT( nBitCount == 1 || nBitCount == 4 || nBitCount == 8 || nBitCount == 24, "Unsupported BitCount!" );
 
@@ -198,7 +204,7 @@ BitmapBuffer* SalBitmap::ImplCreateDIB( 
 
 // -----------------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::ImplCreateDIB( Drawable aDrawable,
+BitmapBuffer* X11SalBitmap::ImplCreateDIB( Drawable aDrawable,
 										long nDrawableDepth,
 										long nX, long nY,
 										long nWidth, long nHeight )
@@ -207,7 +213,7 @@ BitmapBuffer* SalBitmap::ImplCreateDIB( 
 
 	if( aDrawable && nWidth && nHeight && nDrawableDepth )
 	{
-		SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+		SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 		SalXLib*	pXLib = pSalDisp->GetXLib();
 		Display*	pXDisp = pSalDisp->GetDisplay();
 
@@ -342,13 +348,13 @@ BitmapBuffer* SalBitmap::ImplCreateDIB( 
 
 // -----------------------------------------------------------------------------
 
-XImage*	SalBitmap::ImplCreateXImage( SalDisplay *pSalDisp, long nDepth, const SalTwoRect& rTwoRect ) const
+XImage*	X11SalBitmap::ImplCreateXImage( SalDisplay *pSalDisp, long nDepth, const SalTwoRect& rTwoRect ) const
 {
 	XImage* pImage = NULL;
 
 	if( !mpDIB && mpDDB )
 	{
-	    ( (SalBitmap*) this )->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
+	    const_cast<X11SalBitmap*>(this)->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
 													  mpDDB->ImplGetDepth(),
 													  0, 0, 
 													  mpDDB->ImplGetWidth(), 
@@ -478,7 +484,7 @@ XImage*	SalBitmap::ImplCreateXImage( Sal
 
 // -----------------------------------------------------------------------------
 #ifdef _USE_PRINT_EXTENSION_
-BOOL SalBitmap::ImplCreateFromDrawable(  SalDisplay* pDisplay, Drawable aDrawable, long nDrawableDepth, 
+bool X11SalBitmap::ImplCreateFromDrawable(  SalDisplay* pDisplay, Drawable aDrawable, long nDrawableDepth, 
 										long nX, long nY, long nWidth, long nHeight )
 {
 	Destroy();
@@ -489,7 +495,7 @@ BOOL SalBitmap::ImplCreateFromDrawable( 
 	return( mpDDB != NULL );
 }
 #else
-BOOL SalBitmap::ImplCreateFromDrawable(  Drawable aDrawable, long nDrawableDepth, 
+bool X11SalBitmap::ImplCreateFromDrawable(  Drawable aDrawable, long nDrawableDepth, 
 										long nX, long nY, long nWidth, long nHeight )
 {
 	Destroy();
@@ -502,19 +508,8 @@ BOOL SalBitmap::ImplCreateFromDrawable( 
 // -----------------------------------------------------------------------------
 #endif
 
-BOOL SalBitmap::ImplCreateLocalFromDrawable(  Drawable aDrawable, long nDrawableDepth, 
-											  long nX, long nY, long nWidth, long nHeight )
-{
-	Destroy();
-
-	if( aDrawable && nWidth && nHeight && nDrawableDepth )
-        mpDIB = ImplCreateDIB( aDrawable, nDrawableDepth, nX, nY, nWidth, nHeight );
-
-	return( mpDIB != NULL );
-}
-
-BOOL 
-SalBitmap::SnapShot (Display* pDisplay, XLIB_Window hWindow)
+bool 
+X11SalBitmap::SnapShot (Display* pDisplay, XLIB_Window hWindow)
 {
     if (hWindow != None)
     {
@@ -577,7 +572,7 @@ SalBitmap::SnapShot (Display* pDisplay, 
                 {
                     XImage* pImage = XGetImage (pDisplay, aAttribute.root, 
                                                 x, y, width, height, AllPlanes, ZPixmap);
-                    BOOL bSnapShot = ImplCreateFromXImage (pDisplay, aAttribute.root, pImage);
+                    bool bSnapShot = ImplCreateFromXImage (pDisplay, aAttribute.root, pImage);
                     XDestroyImage (pImage);
 
                     return bSnapShot;
@@ -589,8 +584,8 @@ SalBitmap::SnapShot (Display* pDisplay, 
     return False;
 }
 
-BOOL 
-SalBitmap::ImplCreateFromXImage (Display* pDisplay, XLIB_Window hWindow, XImage* pImage)
+bool 
+X11SalBitmap::ImplCreateFromXImage (Display* pDisplay, XLIB_Window hWindow, XImage* pImage)
 {
     Destroy();
 
@@ -603,8 +598,8 @@ SalBitmap::ImplCreateFromXImage (Display
 }
 
 #ifdef _USE_PRINT_EXTENSION_
-void SalBitmap::ImplDraw( SalDisplay *pDisplay, Drawable aDrawable, long nDrawableDepth, 
-						  const SalTwoRect& rTwoRect, const GC& rGC ) const
+void X11SalBitmap::ImplDraw( SalDisplay *pDisplay, Drawable aDrawable, long nDrawableDepth, 
+						  const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const
 {
 	if( !mpDDB || !mpDDB->ImplMatches( nDrawableDepth, rTwoRect ) )
 	{
@@ -654,11 +649,11 @@ void SalBitmap::ImplDraw( SalDisplay *pD
 	}
 
 	if( mpDDB )
-		mpDDB->ImplDraw( pDisplay, aDrawable, nDrawableDepth, rTwoRect, rGC );
+		mpDDB->ImplDraw( pDisplay, aDrawable, nDrawableDepth, rTwoRect, rGC, bDstIsWindow );
 }
 #else
-void SalBitmap::ImplDraw( Drawable aDrawable, long nDrawableDepth, 
-						  const SalTwoRect& rTwoRect, const GC& rGC ) const
+void X11SalBitmap::ImplDraw( Drawable aDrawable, long nDrawableDepth, 
+						  const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const
 {
 	if( !mpDDB || !mpDDB->ImplMatches( nDrawableDepth, rTwoRect ) )
 	{
@@ -667,18 +662,18 @@ void SalBitmap::ImplDraw( Drawable aDraw
 			// do we already have a DIB? if not, create aDIB from current DDB first
 			if( !mpDIB )
 			{
-				( (SalBitmap*) this )->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
+				const_cast<X11SalBitmap*>(this)->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
 															  mpDDB->ImplGetDepth(),
 															  0, 0, 
 															  mpDDB->ImplGetWidth(), 
 															  mpDDB->ImplGetHeight() );
 			}
 
-			delete mpDDB, ( (SalBitmap*) this )->mpDDB = NULL;
+			delete mpDDB, const_cast<X11SalBitmap*>(this)->mpDDB = NULL;
 		}
 
 		if( mpCache )
-			mpCache->ImplRemove( const_cast<SalBitmap*>(this) );
+			mpCache->ImplRemove( const_cast<X11SalBitmap*>(this) );
 
 		SalTwoRect aTwoRect( rTwoRect );
 
@@ -693,28 +688,28 @@ void SalBitmap::ImplDraw( Drawable aDraw
 			aTwoRect.mnSrcHeight = aTwoRect.mnDestHeight = aSize.Height();
 		}
 
-		XImage*	pImage = ImplCreateXImage( GetSalData()->GetCurDisp(), 
+		XImage*	pImage = ImplCreateXImage( GetSalData()->GetDisplay(), 
 				nDrawableDepth, aTwoRect );
 
 		if( pImage )
 		{
-			( (SalBitmap*) this )->mpDDB = new ImplSalDDB( pImage, aDrawable, aTwoRect );
+			const_cast<X11SalBitmap*>(this)->mpDDB = new ImplSalDDB( pImage, aDrawable, aTwoRect );
 			delete[] pImage->data, pImage->data = NULL;
 			XDestroyImage( pImage );
 
 			if( mpCache )
-				mpCache->ImplAdd( const_cast<SalBitmap*>(this), mpDDB->ImplGetMemSize() );
+				mpCache->ImplAdd( const_cast<X11SalBitmap*>(this), mpDDB->ImplGetMemSize() );
 		}
 	}
 
 	if( mpDDB )
-		mpDDB->ImplDraw( aDrawable, nDrawableDepth, rTwoRect, rGC );
+		mpDDB->ImplDraw( aDrawable, nDrawableDepth, rTwoRect, rGC, bDstIsWindow );
 }
 #endif
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+bool X11SalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
 	Destroy();
 	mpDIB = ImplCreateDIB( rSize, nBitCount, rPal );
@@ -724,14 +719,14 @@ BOOL SalBitmap::Create( const Size& rSiz
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp )
+bool X11SalBitmap::Create( const SalBitmap& rSSalBmp )
 {
 	Destroy();
 
+    const X11SalBitmap& rSalBmp = static_cast<const X11SalBitmap&>( rSSalBmp );
+
 	if( rSalBmp.mpDIB )
 	{
-		const Size aSize( rSalBmp.GetSize() );
-
 		mpDIB = ImplCreateDIB( rSalBmp.GetSize(), rSalBmp.GetBitCount(), rSalBmp.mpDIB->maPalette );
 		
 		if( mpDIB )
@@ -752,21 +747,21 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
+bool X11SalBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
 {
 	return FALSE;
 }
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
+bool X11SalBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
 {
 	return FALSE;
 }
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::Destroy()
+void X11SalBitmap::Destroy()
 {
 	if( mpDIB )
 	{
@@ -783,7 +778,7 @@ void SalBitmap::Destroy()
 
 // -----------------------------------------------------------------------------
 
-Size SalBitmap::GetSize() const
+Size X11SalBitmap::GetSize() const
 {
 	Size aSize;
 
@@ -797,7 +792,7 @@ Size SalBitmap::GetSize() const
 
 // -----------------------------------------------------------------------------
 
-USHORT SalBitmap::GetBitCount() const
+USHORT X11SalBitmap::GetBitCount() const
 {
 	USHORT nBitCount;
 
@@ -825,7 +820,7 @@ USHORT SalBitmap::GetBitCount() const
 
 // -----------------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::AcquireBuffer( BOOL bReadOnly )
+BitmapBuffer* X11SalBitmap::AcquireBuffer( bool bReadOnly )
 {
 	if( !mpDIB && mpDDB )
 	{
@@ -838,7 +833,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, BOOL bReadOnly )
+void X11SalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly )
 {
 	if( !bReadOnly )
 	{
@@ -864,14 +859,14 @@ ImplSalDDB::ImplSalDDB( 
 	mnDepth		( pImage->depth )
 {
 #if !defined(_USE_PRINT_EXTENSION_)	
-	SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+	SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 	Display*	pXDisp = pSalDisp->GetDisplay();
 #else
 	Display*	pXDisp = pDisplay->GetDisplay();
 #endif
 
 
-	if( maPixmap = XCreatePixmap( pXDisp, aDrawable, ImplGetWidth(), ImplGetHeight(), ImplGetDepth() ) )
+	if( (maPixmap = XCreatePixmap( pXDisp, aDrawable, ImplGetWidth(), ImplGetHeight(), ImplGetDepth() )) )
 	{
 		XGCValues	aValues;
 		GC			aGC;
@@ -939,13 +934,13 @@ ImplSalDDB::ImplSalDDB( 
 	mnDepth( nDrawableDepth )
 {
 #if !defined(_USE_PRINT_EXTENSION_)	
-	SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+	SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 	Display*	pXDisp = pSalDisp->GetDisplay();
 #else
 	Display*	pXDisp = pDisplay->GetDisplay();
 #endif
 
-	if( maPixmap = XCreatePixmap( pXDisp, aDrawable, nWidth, nHeight, nDrawableDepth ) )
+	if( (maPixmap = XCreatePixmap( pXDisp, aDrawable, nWidth, nHeight, nDrawableDepth )) )
 	{
 		XGCValues	aValues;
 		GC			aGC;
@@ -962,10 +957,10 @@ ImplSalDDB::ImplSalDDB( 
 		aGC = XCreateGC( pXDisp, maPixmap, nValues, &aValues );
 #ifdef _USE_PRINT_EXTENSION_
 		ImplDraw( pDisplay, aDrawable, nDrawableDepth, maPixmap, mnDepth,
-				  nX, nY, nWidth, nHeight, 0, 0, aGC );
+				  nX, nY, nWidth, nHeight, 0, 0, aGC, false );
 #else
 		ImplDraw( aDrawable, nDrawableDepth, maPixmap, mnDepth,
-				  nX, nY, nWidth, nHeight, 0, 0, aGC );
+				  nX, nY, nWidth, nHeight, 0, 0, aGC, false );
 #endif
 		XFreeGC( pXDisp, aGC );
 
@@ -980,14 +975,14 @@ ImplSalDDB::ImplSalDDB( 
 ImplSalDDB::~ImplSalDDB()
 {
 	if( maPixmap && ImplGetSVData() )
-		XFreePixmap( GetSalData()->GetCurDisp()->GetDisplay(), maPixmap );
+		XFreePixmap( GetSalData()->GetDisplay()->GetDisplay(), maPixmap );
 }
 
 // -----------------------------------------------------------------------------
 
-BOOL ImplSalDDB::ImplMatches( long nDepth, const SalTwoRect& rTwoRect ) const
+bool ImplSalDDB::ImplMatches( long nDepth, const SalTwoRect& rTwoRect ) const
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
 
 	if( ( maPixmap != 0 ) && ( ( mnDepth == nDepth ) || ( 1 == mnDepth ) ) )
 	{
@@ -1017,18 +1012,18 @@ void ImplSalDDB::ImplDraw( 
 #ifdef _USE_PRINT_EXTENSION_
 				SalDisplay* pDisplay,
 #endif
-				Drawable aDrawable, long nDrawableDepth, const SalTwoRect& rTwoRect, const GC& rGC ) const
+				Drawable aDrawable, long nDrawableDepth, const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const
 {
 #ifdef _USE_PRINT_EXTENSION_
 	ImplDraw( pDisplay, maPixmap, mnDepth, aDrawable, nDrawableDepth, 
 			  rTwoRect.mnSrcX - maTwoRect.mnSrcX, rTwoRect.mnSrcY - maTwoRect.mnSrcY,
 			  rTwoRect.mnDestWidth, rTwoRect.mnDestHeight,
-			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC );
+			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC, bDstIsWindow );
 #else
 	ImplDraw( maPixmap, mnDepth, aDrawable, nDrawableDepth, 
 			  rTwoRect.mnSrcX - maTwoRect.mnSrcX, rTwoRect.mnSrcY - maTwoRect.mnSrcY,
 			  rTwoRect.mnDestWidth, rTwoRect.mnDestHeight,
-			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC );
+			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC, bDstIsWindow );
 #endif
 }
 
@@ -1042,10 +1037,10 @@ void ImplSalDDB::ImplDraw( 
 						   Drawable aDstDrawable, long nDstDrawableDepth,
 						   long nSrcX, long nSrcY, 
 						   long nDestWidth, long nDestHeight, 
-						   long nDestX, long nDestY, const GC& rGC )
+						   long nDestX, long nDestY, const GC& rGC, bool bDstIsWindow )
 {
 #if !defined(_USE_PRINT_EXTENSION_)
-	SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+	SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 	Display*	pXDisp = pSalDisp->GetDisplay();
 #else
 	Display*	pXDisp = pDisplay->GetDisplay();
@@ -1058,18 +1053,11 @@ void ImplSalDDB::ImplDraw( 
 	}
 	else
 	{
-		if( nDestWidth > SAL_DRAWPIXMAP_MAX_EXT )
-		{
-			// !!! Broken XCopyArea
-			XCopyArea( pXDisp, aSrcDrawable, aDstDrawable, rGC,
-					   nSrcX, nSrcY, nDestWidth, nDestHeight, nDestX, nDestY );
-		}
-		else
-		{
-			XCopyArea( pXDisp, aSrcDrawable, aDstDrawable, rGC,
-					   nSrcX, nSrcY, nDestWidth, nDestHeight, nDestX, nDestY );
-		}
+        XCopyArea( pXDisp, aSrcDrawable, aDstDrawable, rGC,
+                   nSrcX, nSrcY, nDestWidth, nDestHeight, nDestX, nDestY );
 	}
+    if( bDstIsWindow )
+        X11SalGraphics::YieldGraphicsExpose( pXDisp, NULL, aDstDrawable );
 }
 
 // ----------------------
@@ -1078,11 +1066,11 @@ void ImplSalDDB::ImplDraw( 
 
 struct ImplBmpObj
 {
-	SalBitmap*	mpBmp;
+	X11SalBitmap*	mpBmp;
 	ULONG		mnMemSize;
 	ULONG		mnFlags;
 
-				ImplBmpObj( SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags ) :
+				ImplBmpObj( X11SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags ) :
 					mpBmp( pBmp ), mnMemSize( nMemSize ), mnFlags( nFlags ) {}
 };
 
@@ -1102,10 +1090,10 @@ ImplSalBitmapCache::~ImplSalBitmapCache(
 
 // -----------------------------------------------------------------------------
 
-void ImplSalBitmapCache::ImplAdd( SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags )
+void ImplSalBitmapCache::ImplAdd( X11SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags )
 {
 	ImplBmpObj* pObj;
-	BOOL		bFound = FALSE;
+	bool		bFound = FALSE;
 
 	for( pObj = (ImplBmpObj*) maBmpList.Last(); pObj && !bFound; pObj = (ImplBmpObj*) maBmpList.Prev() )
 		if( pObj->mpBmp == pBmp )
@@ -1124,7 +1112,7 @@ void ImplSalBitmapCache::ImplAdd( SalBit
 
 // -----------------------------------------------------------------------------
 
-void ImplSalBitmapCache::ImplRemove( SalBitmap* pBmp )
+void ImplSalBitmapCache::ImplRemove( X11SalBitmap* pBmp )
 {
 	for( ImplBmpObj* pObj = (ImplBmpObj*) maBmpList.Last(); pObj; pObj = (ImplBmpObj*) maBmpList.Prev() )
 	{
Index: vcl/unx/source/gdi/salgdi.cxx
===================================================================
--- vcl/unx/source/gdi/salgdi.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/salgdi.cxx	2004-09-14 14:09:32.386285512 +0200
@@ -59,14 +59,22 @@
  *
  ************************************************************************/
 
-#define _SV_SALGDI_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 #include <stdio.h>
 #include <stdlib.h>
 
 #include <prex.h>
+// [ed] 6/15/02 There's a conflicting definition of INT8 within the Xmd.h header
+// and the solar.h OOo header.  So, wrap the X11 header with a bogus #define
+// to use the OOo definition of the symbol for INT8.
+// [fa] 4/12/04 With 64-bit changes, X11 headers also conflict with INT64
+
+#define INT8 blehBlahFooBarINT8
+#define INT64 blehBlahFooBarINT64
+
 #include <X11/Xproto.h>
+
+#undef INT8
+#undef INT64
 #include <postx.h>
 
 #include <salunx.h>
@@ -78,13 +86,13 @@
 #include <saldisp.hxx>
 #endif
 #ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 #include <tools/debug.hxx>
 
@@ -128,17 +136,13 @@ inline SalPolyLine::~SalPolyLine()
 { if( pFirst_ != Points_ ) delete [] pFirst_; }
 
 #undef STATIC_POINTS
-// -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-= X11SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphicsData::SalGraphicsData()
+X11SalGraphics::X11SalGraphics()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	m_pJobData			= NULL;
-	m_pPrinterGfx 		= NULL;
-	m_pPhoneNr			= NULL;
-#endif
     m_pFrame			= NULL;
     m_pVDev				= NULL;
+    m_pDeleteColormap	= NULL;
 	hDrawable_			= None;
 
 	pClipRegion_			= NULL;
@@ -188,38 +192,53 @@ SalGraphicsData::SalGraphicsData()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphicsData::~SalGraphicsData()
+X11SalGraphics::~X11SalGraphics()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if( ! ( m_pJobData || m_pPrinterGfx ) )
-#endif
-	{
-		Display *pDisplay = GetXDisplay();
+    Display *pDisplay = GetXDisplay();
+    
+    DBG_ASSERT( !pPaintRegion_, "pPaintRegion_" )
+        if( pClipRegion_ ) XDestroyRegion( pClipRegion_ );
+    
+    if( hBrush_ )		XFreePixmap( pDisplay, hBrush_ );
+    if( pPenGC_ )		XFreeGC( pDisplay, pPenGC_ );
+    if( pFontGC_ )		XFreeGC( pDisplay, pFontGC_ );
+    if( pBrushGC_ )		XFreeGC( pDisplay, pBrushGC_ );
+    if( pMonoGC_ )		XFreeGC( pDisplay, pMonoGC_ );
+    if( pCopyGC_ )		XFreeGC( pDisplay, pCopyGC_ );
+    if( pMaskGC_ )		XFreeGC( pDisplay, pMaskGC_ );
+    if( pInvertGC_ )	XFreeGC( pDisplay, pInvertGC_ );
+    if( pInvert50GC_ )	XFreeGC( pDisplay, pInvert50GC_ );
+    if( pStippleGC_ )	XFreeGC( pDisplay, pStippleGC_ );
+    if( pTrackingGC_ )	XFreeGC( pDisplay, pTrackingGC_ );
+    if( m_pDeleteColormap )
+        delete m_pDeleteColormap;
+}
 
-		DBG_ASSERT( !pPaintRegion_, "pPaintRegion_" )
-			if( pClipRegion_ ) XDestroyRegion( pClipRegion_ );
+// -=-= SalGraphics / X11SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-		if( hBrush_ )		XFreePixmap( pDisplay, hBrush_ );
-		if( pPenGC_ )		XFreeGC( pDisplay, pPenGC_ );
-		if( pFontGC_ )		XFreeGC( pDisplay, pFontGC_ );
-		if( pBrushGC_ )		XFreeGC( pDisplay, pBrushGC_ );
-		if( pMonoGC_ )		XFreeGC( pDisplay, pMonoGC_ );
-		if( pCopyGC_ )		XFreeGC( pDisplay, pCopyGC_ );
-		if( pMaskGC_ )		XFreeGC( pDisplay, pMaskGC_ );
-		if( pInvertGC_ )	XFreeGC( pDisplay, pInvertGC_ );
-		if( pInvert50GC_ )	XFreeGC( pDisplay, pInvert50GC_ );
-		if( pStippleGC_ )	XFreeGC( pDisplay, pStippleGC_ );
-		if( pTrackingGC_ )	XFreeGC( pDisplay, pTrackingGC_ );
-	}
+void X11SalGraphics::Init( SalFrame *pFrame, Drawable aTarget )
+{
+	m_pColormap		= &GetSalData()->GetDisplay()->GetColormap();
+	hDrawable_		= aTarget;
+
+	bWindow_		= TRUE;
+    m_pFrame		= pFrame;
+    m_pVDev			= NULL;
+
+	nPenPixel_		= GetPixel( nPenColor_ );
+	nTextPixel_ 	= GetPixel( nTextColor_ );
+	nBrushPixel_	= GetPixel( nBrushColor_ );
+    numClipRects_   = 0;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::DeInit()
+void X11SalGraphics::DeInit()
 {
+    hDrawable_ = None;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::SetClipRegion( GC pGC, XLIB_Region pXReg ) const
+void X11SalGraphics::SetClipRegion( GC pGC, XLIB_Region pXReg ) const
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -250,7 +269,7 @@ void SalGraphicsData::SetClipRegion( GC 
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::SelectPen()
+GC X11SalGraphics::SelectPen()
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -281,7 +300,7 @@ GC SalGraphicsData::SelectPen()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::SelectBrush()
+GC X11SalGraphics::SelectBrush()
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -334,7 +353,7 @@ GC SalGraphicsData::SelectBrush()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::GetTrackingGC()
+GC X11SalGraphics::GetTrackingGC()
 {
 	const char    dash_list[2] = {2, 2};
 
@@ -343,8 +362,8 @@ GC SalGraphicsData::GetTrackingGC()
 		XGCValues     values;
 
 		values.graphics_exposures   = True;
-    	values.foreground           = xColormap_->GetBlackPixel()
-			                          ^ xColormap_->GetWhitePixel();
+    	values.foreground           = m_pColormap->GetBlackPixel()
+			                          ^ m_pColormap->GetWhitePixel();
     	values.function             = GXxor;
     	values.line_width           = 1;
 		values.line_style			= LineOnOffDash;
@@ -366,7 +385,7 @@ GC SalGraphicsData::GetTrackingGC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::DrawLines( ULONG              nPoints,
+void X11SalGraphics::DrawLines( ULONG              nPoints,
 									   const SalPolyLine &rPoints,
 									   GC                 pGC )
 {
@@ -399,7 +418,7 @@ void SalGraphicsData::DrawLines( ULONG  
 #define P_DELTA			51
 #define DMAP( v, m )	((v % P_DELTA) > m ? (v / P_DELTA) + 1 : (v / P_DELTA))
 
-BOOL SalGraphicsData::GetDitherPixmap( SalColor nSalColor )
+BOOL X11SalGraphics::GetDitherPixmap( SalColor nSalColor )
 {
     static const short nOrdDither8Bit[ 8 ][ 8 ] =
 	{
@@ -475,49 +494,24 @@ BOOL SalGraphicsData::GetDitherPixmap( S
 	return TRUE;
 }
 
-// -=-= SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphics::SalGraphics()
-{ }
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphics::~SalGraphics()
-{ }
-
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::GetResolution( long &rDPIX, long &rDPIY ) // const
+void X11SalGraphics::GetResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY ) // const
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pJobData != NULL)
-	{
-		int x = maGraphicsData.m_pJobData->m_aContext.getRenderResolution();
-
-		rDPIX = x;
-		rDPIY = x;
-	}
-	else
-	{
-#endif
-
-        SalDisplay *pDisplay = _GetDisplay();
-
-        rDPIX = pDisplay->GetResolution().A();
-        rDPIY = pDisplay->GetResolution().B();
-        if ( rDPIY < 96 )
-        {
-            rDPIX = Divide( rDPIX * 96, rDPIY );
+    SalDisplay *pDisplay = GetDisplay();
+    
+    rDPIX = pDisplay->GetResolution().A();
+    rDPIY = pDisplay->GetResolution().B();
+    if( !pDisplay->GetExactResolution() && rDPIY < 96 )
+    {
+        rDPIX = Divide( rDPIX * 96, rDPIY );
             rDPIY = 96;
-        }
-        else if ( rDPIY > 200 )
-        {
-            rDPIX = Divide( rDPIX * 200, rDPIY );
-            rDPIY = 200;
-        }
- 
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-
+    }
+    else if ( rDPIY > 200 )
+    {
+        rDPIX = Divide( rDPIX * 200, rDPIY );
+        rDPIY = 200;
+    }
+    
     // #i12705# equalize x- and y-resolution if they are close enough
     if( rDPIX != rDPIY )
     {
@@ -535,731 +529,439 @@ void SalGraphics::GetResolution( long &r
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::GetScreenFontResolution( long &rDPIX, long &rDPIY ) // const
+void X11SalGraphics::GetScreenFontResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY ) // const
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->GetScreenFontResolution (rDPIX, rDPIY);
-	else
-#endif
-        _GetDisplay()->GetScreenFontResolution( rDPIX, rDPIY );
+    GetDisplay()->GetScreenFontResolution( rDPIX, rDPIY );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-USHORT SalGraphics::GetBitCount() // const
+USHORT X11SalGraphics::GetBitCount() // const
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		return maGraphicsData.m_pPrinterGfx->GetBitCount ();
-	else
-	{
-#endif
-
-        return _GetVisual()->GetDepth();
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    return GetVisual()->GetDepth();
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalGraphics::GetGraphicsWidth()
+long X11SalGraphics::GetGraphicsWidth()
 {
-    if( maGraphicsData.m_pFrame )
-        return maGraphicsData.m_pFrame->maGeometry.nWidth;
-    else if( maGraphicsData.m_pVDev )
-        return maGraphicsData.m_pVDev->maVirDevData.GetWidth();
+    if( m_pFrame )
+        return m_pFrame->maGeometry.nWidth;
+    else if( m_pVDev )
+        return m_pVDev->GetWidth();
     else
         return 0;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::ResetClipRegion()
+void X11SalGraphics::ResetClipRegion()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->ResetClipRegion ();
-	else
-	{
-#endif
-
-        if( _GetClipRegion() )
-        {
-            _IsPenGC()			= FALSE;
-            _IsFontGC()			= FALSE;
-            _IsBrushGC()		= FALSE;
-            _IsMonoGC()			= FALSE;
-            _IsCopyGC()			= FALSE;
-            _IsInvertGC()		= FALSE;
-            _IsInvert50GC()		= FALSE;
-            _IsStippleGC()		= FALSE;
-            _IsTrackingGC()		= FALSE;
-
-            XDestroyRegion( _GetClipRegion() );
-            _GetClipRegion()	= NULL;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( pClipRegion_ )
+    {
+        bPenGC_			= FALSE;
+        bFontGC_		= FALSE;
+        bBrushGC_		= FALSE;
+        bMonoGC_		= FALSE;
+        bCopyGC_		= FALSE;
+        bInvertGC_		= FALSE;
+        bInvert50GC_	= FALSE;
+        bStippleGC_		= FALSE;
+        bTrackingGC_	= FALSE;
+        
+        XDestroyRegion( pClipRegion_ );
+        pClipRegion_	= NULL;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::BeginSetClipRegion( ULONG n )
+void X11SalGraphics::BeginSetClipRegion( ULONG n )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->BeginSetClipRegion(n);
-	else
-	{
-#endif
-
-        if( _GetClipRegion() )
-            XDestroyRegion( _GetClipRegion() );
-        _GetClipRegion() = XCreateRegion();
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( pClipRegion_ )
+        XDestroyRegion( pClipRegion_ );
+    pClipRegion_ = XCreateRegion();
+    numClipRects_ = 0;
+    boundingClipRect_.SetEmpty();
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-BOOL SalGraphics::UnionClipRegion( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+BOOL X11SalGraphics::unionClipRegion( long nX, long nY, long nDX, long nDY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		return maGraphicsData.m_pPrinterGfx->UnionClipRegion (nX, nY, nDX, nDY);
-	else
-	{
-#endif
-
-        if (!nDX || !nDY)
-            return TRUE;
-
-        XRectangle aRect;
-        aRect.x			= (short)nX;
-        aRect.y			= (short)nY;
-        aRect.width		= (unsigned short)nDX;
-        aRect.height	= (unsigned short)nDY;
-
-        XUnionRectWithRegion( &aRect, _GetClipRegion(), _GetClipRegion() );
-
+    if (!nDX || !nDY)
         return TRUE;
 
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    numClipRects_++;
+    boundingClipRect_.Union( Rectangle( nX, nY, nX+nDX, nY+nDY ) );
+    
+    XRectangle aRect;
+    aRect.x			= (short)nX;
+    aRect.y			= (short)nY;
+    aRect.width		= (unsigned short)nDX;
+    aRect.height	= (unsigned short)nDY;
+    
+    XUnionRectWithRegion( &aRect, pClipRegion_, pClipRegion_ );
+    
+    return TRUE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::EndSetClipRegion()
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->EndSetClipRegion ();
-	else
-	{
-#endif
-
-        _IsPenGC()		= FALSE;
-        _IsFontGC()		= FALSE;
-        _IsBrushGC()	= FALSE;
-        _IsMonoGC()		= FALSE;
-        _IsCopyGC()		= FALSE;
-        _IsInvertGC()	= FALSE;
-        _IsInvert50GC()	= FALSE;
-        _IsStippleGC()	= FALSE;
-        _IsTrackingGC()	= FALSE;
-
-        if( XEmptyRegion( _GetClipRegion() ) )
-        {
-            XDestroyRegion( _GetClipRegion() );
-            _GetClipRegion()	= NULL;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+void X11SalGraphics::EndSetClipRegion()
+{
+    bPenGC_			= FALSE;
+    bFontGC_		= FALSE;
+    bBrushGC_		= FALSE;
+    bMonoGC_		= FALSE;
+    bCopyGC_		= FALSE;
+    bInvertGC_		= FALSE;
+    bInvert50GC_	= FALSE;
+    bStippleGC_		= FALSE;
+    bTrackingGC_	= FALSE;
+    
+    if( XEmptyRegion( pClipRegion_ ) )
+    {
+        XDestroyRegion( pClipRegion_ );
+        pClipRegion_= NULL;
+        numClipRects_ = 0;
+        boundingClipRect_.SetEmpty();
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetLineColor()
+void X11SalGraphics::SetLineColor()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->SetLineColor ();
-	else
-	{
-#endif
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-        {
-            _GetPenColor()		= 0xFFFFFFFF;
-            _IsPenGC()			= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ != 0xFFFFFFFF )
+    {
+        nPenColor_		= 0xFFFFFFFF;
+        bPenGC_			= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetLineColor( SalColor nSalColor )
+void X11SalGraphics::SetLineColor( SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-		maGraphicsData.m_pPrinterGfx->SetLineColor (aColor);
-	}
-	else
-	{
-#endif
-
-        if( _GetPenColor() != nSalColor )
-        {
-            _GetPenColor()		= nSalColor;
-            _GetPenPixel()		= _GetPixel( nSalColor );
-            _IsPenGC()			= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ != nSalColor )
+    {
+        nPenColor_		= nSalColor;
+        nPenPixel_		= GetPixel( nSalColor );
+        bPenGC_			= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetFillColor()
+void X11SalGraphics::SetFillColor()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->SetFillColor ();
-	else
-	{
-#endif
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-        {
-            _IsDitherBrush()	= FALSE;
-            _GetBrushColor()	= 0xFFFFFFFF;
-            _IsBrushGC()		= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nBrushColor_ != 0xFFFFFFFF )
+    {
+        bDitherBrush_	= FALSE;
+        nBrushColor_	= 0xFFFFFFFF;
+        bBrushGC_		= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetFillColor( SalColor nSalColor )
+void X11SalGraphics::SetFillColor( SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-		maGraphicsData.m_pPrinterGfx->SetFillColor (aColor);
-	}
-	else
-	{
-#endif
-
-        if( _GetBrushColor() != nSalColor )
-        {
-            _IsDitherBrush()	= FALSE;
-            _GetBrushColor()	= nSalColor;
-            _GetBrushPixel()	= _GetPixel( nSalColor );
-            if( TrueColor != _GetColormap().GetVisual()->GetClass()
-                && _GetColor( _GetBrushPixel() ) != _GetBrushColor()
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x00 ) // black
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x80 ) // blue
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x00 ) // green
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x80 ) // cyan
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x00 ) // red
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x80 ) // magenta
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x00 ) // brown
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x80 ) // gray
-                && nSalColor != MAKE_SALCOLOR( 0xC0, 0xC0, 0xC0 ) // light gray
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0xFF ) // light blue
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0x00 ) // light green
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0xFF ) // light cyan
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0x00 ) // light red
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0xFF ) // light magenta
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0x00 ) // light brown
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0xFF ) )
-                _IsDitherBrush() = maGraphicsData.GetDitherPixmap(nSalColor);
-            _IsBrushGC()		= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nBrushColor_ != nSalColor )
+    {
+        bDitherBrush_	= FALSE;
+        nBrushColor_	= nSalColor;
+        nBrushPixel_	= GetPixel( nSalColor );
+        if( TrueColor != GetColormap().GetVisual()->GetClass()
+            && GetColormap().GetColor( nBrushPixel_ ) != nBrushColor_
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x00 ) // black
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x80 ) // blue
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x00 ) // green
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x80 ) // cyan
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x00 ) // red
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x80 ) // magenta
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x00 ) // brown
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x80 ) // gray
+            && nSalColor != MAKE_SALCOLOR( 0xC0, 0xC0, 0xC0 ) // light gray
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0xFF ) // light blue
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0x00 ) // light green
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0xFF ) // light cyan
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0x00 ) // light red
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0xFF ) // light magenta
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0x00 ) // light brown
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0xFF ) )
+            bDitherBrush_ = GetDitherPixmap(nSalColor);
+        bBrushGC_		= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetROPLineColor( SalROPColor nROPColor )
+void X11SalGraphics::SetROPLineColor( SalROPColor nROPColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( 0, "Error: PrinterGfx::SetROPLineColor() not implemented" );
-	}
-	else
-	{
-#endif
-
-        switch( nROPColor )
-        {
-            case SAL_ROP_0 : // 0
-                _GetPenPixel() = (Pixel)0;
-                break;
-            case SAL_ROP_1 : // 1
-                _GetPenPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-            case SAL_ROP_INVERT : // 2
-                _GetPenPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-        }
-        _GetPenColor()	= _GetColor( _GetPenPixel() );
-        _IsPenGC()		= FALSE;
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    switch( nROPColor )
+    {
+        case SAL_ROP_0 : // 0
+            nPenPixel_ = (Pixel)0;
+            break;
+        case SAL_ROP_1 : // 1
+            nPenPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+        case SAL_ROP_INVERT : // 2
+            nPenPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+    }
+    nPenColor_	= GetColormap().GetColor( nPenPixel_ );
+    bPenGC_		= FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetROPFillColor( SalROPColor nROPColor )
+void X11SalGraphics::SetROPFillColor( SalROPColor nROPColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( 0, "Error: PrinterGfx::SetROPFillColor() not implemented" );
-	}
-	else
-	{
-#endif
-
-        switch( nROPColor )
-        {
-            case SAL_ROP_0 : // 0
-                _GetBrushPixel() = (Pixel)0;
-                break;
-            case SAL_ROP_1 : // 1
-                _GetBrushPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-            case SAL_ROP_INVERT : // 2
-                _GetBrushPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-        }
-        _IsDitherBrush()	= FALSE;
-        _GetBrushColor()	= _GetColor( _GetBrushPixel() );
-        _IsBrushGC()		= FALSE;
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    switch( nROPColor )
+    {
+        case SAL_ROP_0 : // 0
+            nBrushPixel_ = (Pixel)0;
+            break;
+        case SAL_ROP_1 : // 1
+            nBrushPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+        case SAL_ROP_INVERT : // 2
+            nBrushPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+    }
+    bDitherBrush_	= FALSE;
+    nBrushColor_	= GetColormap().GetColor( nBrushPixel_ );
+    bBrushGC_		= FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetXORMode( BOOL bSet )
+void X11SalGraphics::SetXORMode( BOOL bSet )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( !bSet, "Error: PrinterGfx::SetXORMode() not implemented" );
-	}
-	else
-	{
-#endif
-
-        if( !_IsXORMode() == bSet )
-        {
-            _IsXORMode() 	= bSet;
-            _IsPenGC()		= FALSE;
-            _IsBrushGC()	= FALSE;
-            _IsMonoGC()		= FALSE;
-            _IsCopyGC()		= FALSE;
-            _IsInvertGC()	= FALSE;
-            _IsInvert50GC()	= FALSE;
-            _IsStippleGC()	= FALSE;
-            _IsTrackingGC()	= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( !bXORMode_ == bSet )
+    {
+        bXORMode_ 	= bSet;
+        bPenGC_		= FALSE;
+        bBrushGC_	= FALSE;
+        bMonoGC_		= FALSE;
+        bCopyGC_		= FALSE;
+        bInvertGC_	= FALSE;
+        bInvert50GC_	= FALSE;
+        bStippleGC_	= FALSE;
+        bTrackingGC_	= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPixel( long nX, long nY, const OutputDevice* )
+void X11SalGraphics::drawPixel( long nX, long nY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPixel (Point(nX, nY));
-	else
-	{
-#endif
-
-        if( _GetPenColor() !=  0xFFFFFFFF )
-            XDrawPoint( _GetXDisplay(), _GetDrawable(), _SelectPen(), nX, nY );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ !=  0xFFFFFFFF )
+        XDrawPoint( GetXDisplay(), GetDrawable(), SelectPen(), nX, nY );
 }
 
-void SalGraphics::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice* )
+void X11SalGraphics::drawPixel( long nX, long nY, SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-		maGraphicsData.m_pPrinterGfx->DrawPixel (Point(nX, nY), aColor);
-	}
-	else
-	{
-#endif
-
-        if( nSalColor != 0xFFFFFFFF )
+    if( nSalColor != 0xFFFFFFFF )
+    {
+        Display *pDisplay = GetXDisplay();
+        
+        if( nPenColor_ == 0xFFFFFFFF && !bPenGC_ )
+        {
+            SetLineColor( nSalColor );
+            XDrawPoint( pDisplay, GetDrawable(), SelectPen(), nX, nY );
+            nPenColor_ = 0xFFFFFFFF;
+            bPenGC_ = False;
+        }
+        else
         {
-            Display *pDisplay = _GetXDisplay();
-
-            if( _GetPenColor() == 0xFFFFFFFF && !_IsPenGC() )
-            {
-                SetLineColor( nSalColor );
-                XDrawPoint( pDisplay, _GetDrawable(), _SelectPen(), nX, nY );
-                _GetPenColor() = 0xFFFFFFFF;
-                _IsPenGC() = False;
-            }
-            else
-            {
-                GC pGC = _SelectPen();
-
-                if( nSalColor != _GetPenColor() )
-                    XSetForeground( pDisplay, pGC, _GetPixel( nSalColor ) );
-
-                XDrawPoint( pDisplay, _GetDrawable(), pGC, nX, nY );
-
-                if( nSalColor != _GetPenColor() )
-                    XSetForeground( pDisplay, pGC, _GetPenPixel() );
-            }
+            GC pGC = SelectPen();
+            
+            if( nSalColor != nPenColor_ )
+                XSetForeground( pDisplay, pGC, GetPixel( nSalColor ) );
+            
+            XDrawPoint( pDisplay, GetDrawable(), pGC, nX, nY );
+            
+            if( nSalColor != nPenColor_ )
+                XSetForeground( pDisplay, pGC, nPenPixel_ );
         }
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice* )
+void X11SalGraphics::drawLine( long nX1, long nY1, long nX2, long nY2 )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawLine (Point(nX1, nY1), Point(nX2, nY2));
-	else
-	{
-#endif
-
-        if( _GetPenColor() != 0xFFFFFFFF )
+    if( nPenColor_ != 0xFFFFFFFF )
+    {
+        if ( GetDisplay()->GetProperties() & PROPERTY_BUG_DrawLine )
         {
-            if ( _GetDisplay()->GetProperties() & PROPERTY_BUG_DrawLine )
-            {
-                GC aGC = _SelectPen();
-                XDrawPoint (_GetXDisplay(), _GetDrawable(), aGC, (int)nX1, (int)nY1);
-                XDrawPoint (_GetXDisplay(), _GetDrawable(), aGC, (int)nX2, (int)nY2);
-                XDrawLine  (_GetXDisplay(), _GetDrawable(), aGC, nX1, nY1, nX2, nY2 );
+            GC aGC = SelectPen();
+            XDrawPoint (GetXDisplay(), GetDrawable(), aGC, (int)nX1, (int)nY1);
+            XDrawPoint (GetXDisplay(), GetDrawable(), aGC, (int)nX2, (int)nY2);
+            XDrawLine  (GetXDisplay(), GetDrawable(), aGC, nX1, nY1, nX2, nY2 );
 		}
-            else
-                XDrawLine( _GetXDisplay(), _GetDrawable(),_SelectPen(),
-                           nX1, nY1, nX2, nY2 );
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        else
+            XDrawLine( GetXDisplay(), GetDrawable(),SelectPen(),
+                       nX1, nY1, nX2, nY2 );
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawRect( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+void X11SalGraphics::drawRect( long nX, long nY, long nDX, long nDY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-
-		maGraphicsData.m_pPrinterGfx->DrawRect (Rectangle(Point(nX, nY), Size(nDX, nDY)));
-	else
-	{
-#endif
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-        {
-            XFillRectangle( _GetXDisplay(),
-                            _GetDrawable(),
-                            _SelectBrush(),
-                            nX, nY, nDX, nDY );
-        }
-        // Beschreibung DrawRect verkehrt, deshalb -1
-        if( _GetPenColor() != 0xFFFFFFFF )
-            XDrawRectangle( _GetXDisplay(),
-                            _GetDrawable(),
-                            _SelectPen(),
-                            nX, nY, nDX-1, nDY-1 );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nBrushColor_ != 0xFFFFFFFF )
+    {
+        XFillRectangle( GetXDisplay(),
+                        GetDrawable(),
+                        SelectBrush(),
+                        nX, nY, nDX, nDY );
+    }
+    // Beschreibung DrawRect verkehrt, deshalb -1
+    if( nPenColor_ != 0xFFFFFFFF )
+        XDrawRectangle( GetXDisplay(),
+                        GetDrawable(),
+                        SelectPen(),
+                        nX, nY, nDX-1, nDY-1 );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPolyLine( ULONG nPoints, const SalPoint *pPtAry, const OutputDevice* )
+void X11SalGraphics::drawPolyLine( ULONG nPoints, const SalPoint *pPtAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPolyLine (nPoints, (Point*)pPtAry);
-	else
-	{
-#endif
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-        {
-            SalPolyLine Points( nPoints, pPtAry );
-
-            maGraphicsData.DrawLines( nPoints, Points, _SelectPen() );
-        }
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ != 0xFFFFFFFF )
+    {
+        SalPolyLine Points( nPoints, pPtAry );
+        
+        DrawLines( nPoints, Points, SelectPen() );
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
+void X11SalGraphics::drawPolygon( ULONG nPoints, const SalPoint* pPtAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPolygon (nPoints, (Point*)pPtAry);
-	else
-	{
-#endif
-
-        if( nPoints < 3 )
+    if( nPoints < 3 )
+    {
+        if( !nPoints )
         {
-            if( !nPoints )
-            {
 #if OSL_DEBUG_LEVEL > 1
-                fprintf( stderr, "SalGraphics::DrawPolygon !nPoints\n" );
+            fprintf( stderr, "X11SalGraphicsDrawPolygon !nPoints\n" );
 #endif
-            }
-            else if( !_IsXORMode() )
-            {
-                if( 1 == nPoints  )
-                    DrawPixel( pPtAry[0].mnX, pPtAry[0].mnY, pOutDev );
-                else
-                    DrawLine( pPtAry[0].mnX, pPtAry[0].mnY,
-                              pPtAry[1].mnX, pPtAry[1].mnY, pOutDev );
-            }
-            return;
         }
-
-        SalPolyLine Points( nPoints, pPtAry );
-
-        nPoints++;
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-            XFillPolygon( _GetXDisplay(),
-					  _GetDrawable(),
-                          _SelectBrush(),
-                          &Points[0], nPoints,
-                          Complex, CoordModeOrigin );
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-            maGraphicsData.DrawLines( nPoints, Points, _SelectPen() );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        else if( !bXORMode_ )
+        {
+            if( 1 == nPoints  )
+                drawPixel( pPtAry[0].mnX, pPtAry[0].mnY );
+            else
+                drawLine( pPtAry[0].mnX, pPtAry[0].mnY,
+                          pPtAry[1].mnX, pPtAry[1].mnY );
+        }
+        return;
+    }
+    
+    SalPolyLine Points( nPoints, pPtAry );
+    
+    nPoints++;
+    
+    if( nBrushColor_ != 0xFFFFFFFF )
+        XFillPolygon( GetXDisplay(),
+					  GetDrawable(),
+                      SelectBrush(),
+                      &Points[0], nPoints,
+                      Complex, CoordModeOrigin );
+    
+    if( nPenColor_ != 0xFFFFFFFF )
+        DrawLines( nPoints, Points, SelectPen() );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPolyPolygon( ULONG			nPoly,
+void X11SalGraphics::drawPolyPolygon( ULONG			nPoly,
 								   const ULONG	   *pPoints,
-								   PCONSTSALPOINT  *pPtAry,
-                                   const OutputDevice *pOutDev )
+								   PCONSTSALPOINT  *pPtAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPolyPolygon (nPoly, pPoints, (const Point**)pPtAry);
-	else
-	{
-
-#endif
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-        {
-            ULONG		i, n;
-            XLIB_Region	pXRegA	= NULL;
-
-#ifdef CLIPPING
-            Size aOutSize = pOutDev->GetOutputSizePixel();
-
-            ClipRectangle aClippingRect( Point(0,0),
-                                         Point(aOutSize.Width(), aOutSize.Height()) );
-
-            ULONG nMax = pPoints[0];
-            for( i = 1; i < nPoly; i++ )
-                if( pPoints[i] > nMax )
-                    nMax = pPoints[i];
-
-            SalPolyLine Points( nMax * 2 );
-
-            for( i = 0; i < nPoly; i++ )
+    if( nBrushColor_ != 0xFFFFFFFF )
+    {
+        ULONG		i, n;
+        XLIB_Region	pXRegA	= NULL;
+        
+        for( i = 0; i < nPoly; i++ ) {
+            n = pPoints[i];
+            SalPolyLine Points( n, pPtAry[i] );
+            if( n > 2 )
             {
-                n = aClippingRect.ClipPolygon( pPoints[i], pPtAry[i], &Points[0] );
-#else
-            for( i = 0; i < nPoly; i++ ) {
-                n = pPoints[i];
-                SalPolyLine Points( n, pPtAry[i] );
-#endif
-                if( n > 2 )
+                XLIB_Region pXRegB = XPolygonRegion( &Points[0], n+1, WindingRule );
+                if( !pXRegA )
+                    pXRegA = pXRegB;
+                else
                 {
-                    XLIB_Region pXRegB = XPolygonRegion( &Points[0], n+1, WindingRule );
-                    if( !pXRegA )
-                        pXRegA = pXRegB;
-                    else
-                    {
-                        XXorRegion( pXRegA, pXRegB, pXRegA );
-                        XDestroyRegion( pXRegB );
-                    }
+                    XXorRegion( pXRegA, pXRegB, pXRegA );
+                    XDestroyRegion( pXRegB );
                 }
             }
-
-            if( pXRegA )
-            {
-                XRectangle aXRect;
-                XClipBox( pXRegA, &aXRect );
-
-                GC pGC = _SelectBrush();
-                maGraphicsData.SetClipRegion( pGC, pXRegA ); // ??? doppelt
-                XDestroyRegion( pXRegA );
-                _IsBrushGC() = FALSE;
-
-                XFillRectangle( _GetXDisplay(),
-                                _GetDrawable(),
-                                pGC,
-                                aXRect.x, aXRect.y, aXRect.width, aXRect.height );
-            }
         }
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-            for( ULONG i = 0; i < nPoly; i++ )
-                DrawPolyLine( pPoints[i], pPtAry[i], pOutDev );
-
-#ifndef _USE_PRINT_EXTENSION_
-    }
-#endif
+        
+        if( pXRegA )
+        {
+            XRectangle aXRect;
+            XClipBox( pXRegA, &aXRect );
+            
+            GC pGC = SelectBrush();
+            SetClipRegion( pGC, pXRegA ); // ??? doppelt
+            XDestroyRegion( pXRegA );
+            bBrushGC_ = FALSE;
+            
+            XFillRectangle( GetXDisplay(),
+                            GetDrawable(),
+                            pGC,
+                            aXRect.x, aXRect.y, aXRect.width, aXRect.height );
+        }
+   }
+        
+   if( nPenColor_ != 0xFFFFFFFF )
+       for( ULONG i = 0; i < nPoly; i++ )
+           drawPolyLine( pPoints[i], pPtAry[i] );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_Bool SalGraphics::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool X11SalGraphics::drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-		maGraphicsData.m_pPrinterGfx->DrawPolyLineBezier (nPoints, (Point*)pPtAry, pFlgAry);
-        return sal_True;
-    }
-#endif
     return sal_False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_Bool SalGraphics::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool X11SalGraphics::drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-		maGraphicsData.m_pPrinterGfx->DrawPolygonBezier (nPoints, (Point*)pPtAry, pFlgAry);
-        return sal_True;
-    }
-#endif
     return sal_False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_Bool SalGraphics::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
-                                             const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice* )
+sal_Bool X11SalGraphics::drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+                                                const SalPoint* const* pPtAry, const BYTE* const* pFlgAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-		maGraphicsData.m_pPrinterGfx->DrawPolyPolygonBezier (nPoly, pPoints, (Point**)pPtAry, (BYTE**)pFlgAry);
-        return sal_True;
-    }
-#endif
     return sal_False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalGraphics::Invert( ULONG nPoints,
-						  const SalPoint* pPtAry,
-						  SalInvert nFlags,
-                          const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( 0, "Error: PrinterGfx::Invert() not implemented" );
-	}
-	else
-	{
-#endif
-
-        SalDisplay *pDisp = _GetDisplay();
-        SalPolyLine Points ( nPoints, pPtAry );
-
-        GC pGC;
-        if( SAL_INVERT_50 & nFlags )
-            pGC = maGraphicsData.GetInvert50GC();
-        else
-            if ( SAL_INVERT_TRACKFRAME & nFlags )
-                pGC = maGraphicsData.GetTrackingGC();
-            else
-                pGC = maGraphicsData.GetInvertGC();
-
-        if( SAL_INVERT_TRACKFRAME & nFlags )
-            maGraphicsData.DrawLines ( nPoints, Points, pGC );
+void X11SalGraphics::invert( ULONG nPoints,
+                             const SalPoint* pPtAry,
+                             SalInvert nFlags )
+{
+    SalDisplay *pDisp = GetDisplay();
+    SalPolyLine Points ( nPoints, pPtAry );
+    
+    GC pGC;
+    if( SAL_INVERT_50 & nFlags )
+        pGC = GetInvert50GC();
+    else
+        if ( SAL_INVERT_TRACKFRAME & nFlags )
+            pGC = GetTrackingGC();
         else
-            XFillPolygon( _GetXDisplay(),
-                          _GetDrawable(),
-                          pGC,
-                          &Points[0], nPoints,
-                          Complex, CoordModeOrigin );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+            pGC = GetInvertGC();
+    
+    if( SAL_INVERT_TRACKFRAME & nFlags )
+        DrawLines ( nPoints, Points, pGC );
+    else
+        XFillPolygon( GetXDisplay(),
+                      GetDrawable(),
+                      pGC,
+                      &Points[0], nPoints,
+                      Complex, CoordModeOrigin );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-BOOL SalGraphics::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice* )
+BOOL X11SalGraphics::drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		return maGraphicsData.m_pPrinterGfx->DrawEPS( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ), pPtr, nSize );
-	}
-	else
-#endif
-        return FALSE;
+    return FALSE;
 }
-
Index: vcl/unx/source/gdi/salgdi2.cxx
===================================================================
--- vcl/unx/source/gdi/salgdi2.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/salgdi2.cxx	2004-09-14 14:09:32.406282472 +0200
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALGDI2_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <stdio.h>
 
 #include <salunx.h>
@@ -72,17 +69,17 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 
 #ifndef _USE_PRINT_EXTENSION_
@@ -115,7 +112,7 @@ static void sal_PrintImage( char *s, XIm
 #if (OSL_DEBUG_LEVEL > 1) && defined SALGDI2_TESTTRANS
 #define DBG_TESTTRANS( _def_drawable )								\
 {																	\
-	XCopyArea( pXDisp, _def_drawable, aDrawable, _GetCopyGC(),		\
+	XCopyArea( pXDisp, _def_drawable, aDrawable, GetCopyGC(),		\
 			   0, 0,												\
 			   pPosAry->mnDestWidth, pPosAry->mnDestHeight,			\
 			   0, 0 );												\
@@ -124,15 +121,15 @@ static void sal_PrintImage( char *s, XIm
 #define DBG_TESTTRANS( _def_drawable )
 #endif // (OSL_DEBUG_LEVEL > 1) && defined SALGDI2_TESTTRANS
 
-// -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-= X11SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::CreateGC( Drawable hDrawable, unsigned long nMask )
+GC X11SalGraphics::CreateGC( Drawable hDrawable, unsigned long nMask )
 {
 	XGCValues values;
 
 	values.graphics_exposures	= True;
-	values.foreground			= xColormap_->GetBlackPixel()
-		                          ^ xColormap_->GetWhitePixel();
+	values.foreground			= m_pColormap->GetBlackPixel()
+		                          ^ m_pColormap->GetWhitePixel();
 	values.function				= GXxor;
 	values.line_width			= 1;
 	values.fill_style			= FillStippled;
@@ -143,7 +140,7 @@ GC SalGraphicsData::CreateGC( Drawable h
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline GC SalGraphicsData::GetMonoGC( Pixmap hPixmap )
+inline GC X11SalGraphics::GetMonoGC( Pixmap hPixmap )
 {
 	if( !pMonoGC_ )
 		pMonoGC_ = CreateGC( hPixmap );
@@ -158,7 +155,7 @@ inline GC SalGraphicsData::GetMonoGC( Pi
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline GC SalGraphicsData::GetCopyGC()
+inline GC X11SalGraphics::GetCopyGC()
 {
 	if( bXORMode_ ) return GetInvertGC();
 
@@ -174,7 +171,7 @@ inline GC SalGraphicsData::GetCopyGC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::GetInvertGC()
+GC X11SalGraphics::GetInvertGC()
 {
 	if( !pInvertGC_ )
 		pInvertGC_ = CreateGC( GetDrawable(),
@@ -192,15 +189,15 @@ GC SalGraphicsData::GetInvertGC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::GetInvert50GC()
+GC X11SalGraphics::GetInvert50GC()
 {
 	if( !pInvert50GC_ )
 	{
 		XGCValues values;
 
 		values.graphics_exposures	= True;
-		values.foreground			= xColormap_->GetWhitePixel();
-		values.background			= xColormap_->GetBlackPixel();
+		values.foreground			= m_pColormap->GetWhitePixel();
+		values.background			= m_pColormap->GetBlackPixel();
 		values.function				= GXinvert;
 		values.line_width			= 1;
 		values.line_style			= LineSolid;
@@ -240,7 +237,7 @@ GC SalGraphicsData::GetInvert50GC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline GC SalGraphicsData::GetStippleGC()
+inline GC X11SalGraphics::GetStippleGC()
 {
 	if( !pStippleGC_ )
 		pStippleGC_ = CreateGC( GetDrawable(),
@@ -259,7 +256,7 @@ inline GC SalGraphicsData::GetStippleGC(
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-int SalGraphicsData::Clip( XLIB_Region   pRegion,
+int X11SalGraphics::Clip( XLIB_Region   pRegion,
 								 int          &nX,
 								 int          &nY,
 								 unsigned int &nDX,
@@ -297,7 +294,7 @@ int SalGraphicsData::Clip( XLIB_Region  
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-int SalGraphicsData::Clip( int          &nX,
+int X11SalGraphics::Clip( int          &nX,
 								 int          &nY,
 								 unsigned int &nDX,
 								 unsigned int &nDY,
@@ -339,7 +336,7 @@ int SalGraphicsData::Clip( int          
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::SetMask( int           &nX,
+GC X11SalGraphics::SetMask( int           &nX,
 								   int           &nY,
 								   unsigned int &nDX,
 								   unsigned int &nDY,
@@ -369,7 +366,7 @@ GC SalGraphicsData::SetMask( int        
 	if( !hPixmap )
 	{
 #if (OSL_DEBUG_LEVEL > 1) || defined DBG_UTIL
-		fprintf( stderr, "SalGraphicsData::SetMask !hPixmap\n" );
+		fprintf( stderr, "X11SalGraphics::SetMask !hPixmap\n" );
 #endif
 		return NULL;
 	}
@@ -399,771 +396,495 @@ GC SalGraphicsData::SetMask( int        
 	return pMaskGC_;
 }
 
-// ----- Implementation of PrinterBmp by means of SalBitmap/BitmapBuffer ---------------
-
-#ifndef _USE_PRINT_EXTENSION_
-class SalPrinterBmp : public psp::PrinterBmp
-{
-	private:
-
-		BitmapBuffer*		mpBmpBuffer;
-
-		FncGetPixel			mpFncGetPixel;
-		Scanline			mpScanAccess;
-		sal_Int32			mnScanOffset;
-
-		sal_uInt32			ColorOf (BitmapColor& rColor) const;
-		sal_uInt8			GrayOf  (BitmapColor& rColor) const;
-
-							SalPrinterBmp ();
-
-	public:
-
-							SalPrinterBmp (BitmapBuffer* pBitmap);
-		virtual				~SalPrinterBmp ();
-		virtual sal_uInt32	GetPaletteColor (sal_uInt32 nIdx) const;
-		virtual sal_uInt32	GetPaletteEntryCount () const;
-		virtual sal_uInt32	GetPixelRGB  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
-		virtual sal_uInt8	GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const;
-		virtual sal_uInt8	GetPixelIdx  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
-		virtual sal_uInt32	GetWidth () const;
-		virtual sal_uInt32	GetHeight() const;
-		virtual sal_uInt32	GetDepth ()	const;
-};
-
-SalPrinterBmp::SalPrinterBmp (BitmapBuffer* pBuffer) :
-		mpBmpBuffer (pBuffer)
-{
-	DBG_ASSERT (mpBmpBuffer, "SalPrinterBmp::SalPrinterBmp () can't acquire Bitmap");
-
-	// calibrate scanline buffer
-	if( BMP_SCANLINE_ADJUSTMENT( mpBmpBuffer->mnFormat ) == BMP_FORMAT_TOP_DOWN )
-	{
-		mpScanAccess = mpBmpBuffer->mpBits;
-		mnScanOffset = mpBmpBuffer->mnScanlineSize;
-	}
-	else
-	{
-		mpScanAccess = mpBmpBuffer->mpBits
-					   + (mpBmpBuffer->mnHeight - 1) * mpBmpBuffer->mnScanlineSize;
-		mnScanOffset = - mpBmpBuffer->mnScanlineSize;
-	}
-
-	// request read access to the pixels
-	switch( BMP_SCANLINE_FORMAT( mpBmpBuffer->mnFormat ) )
-	{
-		case BMP_FORMAT_1BIT_MSB_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_MSB_PAL;	 break;
-		case BMP_FORMAT_1BIT_LSB_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_LSB_PAL;	 break;
-		case BMP_FORMAT_4BIT_MSN_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_MSN_PAL;	 break;
-		case BMP_FORMAT_4BIT_LSN_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_LSN_PAL;	 break;
-		case BMP_FORMAT_8BIT_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_PAL; 	 break;
-		case BMP_FORMAT_8BIT_TC_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_TC_MASK;	 break;
-		case BMP_FORMAT_16BIT_TC_MSB_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_MSB_MASK; break;
-		case BMP_FORMAT_16BIT_TC_LSB_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_LSB_MASK; break;
-		case BMP_FORMAT_24BIT_TC_BGR:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_BGR;  break;
-		case BMP_FORMAT_24BIT_TC_RGB:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_RGB;  break;
-		case BMP_FORMAT_24BIT_TC_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_MASK; break;
-		case BMP_FORMAT_32BIT_TC_ABGR:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ABGR; break;
-		case BMP_FORMAT_32BIT_TC_ARGB:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ARGB; break;
-		case BMP_FORMAT_32BIT_TC_BGRA:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_BGRA; break;
-		case BMP_FORMAT_32BIT_TC_RGBA:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_RGBA; break;
-		case BMP_FORMAT_32BIT_TC_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_MASK; break;
-
-		default:
-			DBG_ERROR("Error: SalPrinterBmp::SalPrinterBmp() unknown bitmap format");
-		break;
-	}
-}
-
-SalPrinterBmp::~SalPrinterBmp ()
-{
-}
-
-sal_uInt32
-SalPrinterBmp::GetWidth () const
-{
-	return mpBmpBuffer->mnWidth;
-}
-
-sal_uInt32
-SalPrinterBmp::GetHeight () const
-{
-	return mpBmpBuffer->mnHeight;
-}
-
-sal_uInt32
-SalPrinterBmp::GetDepth () const
-{
-	sal_uInt32 nDepth;
-
-	switch (mpBmpBuffer->mnBitCount)
-	{
-		case 1:
-			nDepth = 1;
-			break;
-
-		case 4:
-		case 8:
-			nDepth = 8;
-			break;
-
-		case 16:
-		case 24:
-		case 32:
-			nDepth = 24;
-			break;
-
-		default:
-			DBG_ERROR ("Error: unsupported bitmap depth in SalPrinterBmp::GetDepth()");
-			break;
-	}
-
-	return nDepth;
-}
-
-sal_uInt32
-SalPrinterBmp::ColorOf (BitmapColor& rColor) const
-{
-	if (rColor.IsIndex())
-		return ColorOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
-	else
-		return 	  ((rColor.GetBlue()) 		 & 0x000000ff)
-				| ((rColor.GetGreen() <<  8) & 0x0000ff00)
-				| ((rColor.GetRed()   << 16) & 0x00ff0000);
-}
-
-sal_uInt8
-SalPrinterBmp::GrayOf (BitmapColor& rColor) const
-{
-	if (rColor.IsIndex())
-		return GrayOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
-	else
-		return (  rColor.GetBlue()  *  28UL
-				+ rColor.GetGreen() * 151UL
-				+ rColor.GetRed()   *  77UL ) >> 8;
-}
-
-sal_uInt32
-SalPrinterBmp::GetPaletteEntryCount () const
-{
-	return mpBmpBuffer->maPalette.GetEntryCount ();
-}
-
-sal_uInt32
-SalPrinterBmp::GetPaletteColor (sal_uInt32 nIdx) const
-{
-	return ColorOf (mpBmpBuffer->maPalette[nIdx]);
-}
+// -=-= SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_uInt32
-SalPrinterBmp::GetPixelRGB (sal_uInt32 nRow, sal_uInt32 nColumn) const
+extern "C" 
 {
-	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
-	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
-
-	return ColorOf (aColor);
+    static Bool GraphicsExposePredicate( Display* pDisplay, XEvent* pEvent, XPointer pFrameWindow )
+    {
+        Bool bRet = False;
+        if( (pEvent->type == GraphicsExpose || pEvent->type == NoExpose) &&
+            pEvent->xnoexpose.drawable == (Drawable)pFrameWindow )
+        {
+            bRet = True;
+        }
+        return bRet;
+    }
 }
 
-sal_uInt8
-SalPrinterBmp::GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const
-{
-	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
-	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
-
-	return GrayOf (aColor);
-}
 
-sal_uInt8
-SalPrinterBmp::GetPixelIdx (sal_uInt32 nRow, sal_uInt32 nColumn) const
+void X11SalGraphics::YieldGraphicsExpose( Display* pDisplay, SalFrame* pFrame, Drawable aWindow )
 {
-	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
-	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
-
-	if (aColor.IsIndex())
-		return aColor.GetIndex();
-	else
-		return 0;
-}
-#endif
+    // get frame if necessary
+    if( ! pFrame )
+    {
+        const std::list< SalFrame* >& rFrames = GetSalData()->GetDisplay()->getFrames();
+        for( std::list< SalFrame* >::const_iterator it = rFrames.begin(); it != rFrames.end() && ! pFrame; ++it )
+        {
+            const SystemEnvData* pEnvData = (*it)->GetSystemData();
+            if( pEnvData->aWindow == aWindow )
+                pFrame = *it;
+        }
+        if( ! pFrame )
+            return;
+    }
 
-// -=-= SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::CopyBits( const SalTwoRect *pPosAry,
-								  SalGraphics	   *pSrcGraphics,
-                                  const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev)
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR( "Error: PrinterGfx::CopyBits() not implemented" );
-	}
-	else
-	{
-#endif
+    XEvent aEvent;
+    while( XCheckTypedWindowEvent( pDisplay, aWindow, Expose, &aEvent ) )
+    {
+        SalPaintEvent aPEvt;
+        aPEvt.mnBoundX			= aEvent.xexpose.x;
+        aPEvt.mnBoundY			= aEvent.xexpose.y;
+        aPEvt.mnBoundWidth		= aEvent.xexpose.width+1;
+        aPEvt.mnBoundHeight 	= aEvent.xexpose.height+1;
+        pFrame->CallCallback( SALEVENT_PAINT, &aPEvt );
+    }
+
+    do
+    {
+        XIfEvent( pDisplay, &aEvent, GraphicsExposePredicate, (XPointer)aWindow );
+        if( aEvent.type == NoExpose )
+            break;
 
-        if( pPosAry->mnSrcWidth <= 0
-            || pPosAry->mnSrcHeight <= 0
-            || pPosAry->mnDestWidth <= 0
-            || pPosAry->mnDestHeight <= 0 )
+        if( pFrame )
         {
-            return;
+            SalPaintEvent aPEvt;
+            aPEvt.mnBoundX			= aEvent.xgraphicsexpose.x;
+            aPEvt.mnBoundY			= aEvent.xgraphicsexpose.y;
+            aPEvt.mnBoundWidth		= aEvent.xgraphicsexpose.width+1;
+            aPEvt.mnBoundHeight 	= aEvent.xgraphicsexpose.height+1;
+            pFrame->CallCallback( SALEVENT_PAINT, &aPEvt );
         }
+    } while( aEvent.xgraphicsexpose.count != 0 );
+}
 
-        int n;
-        if( !pSrcGraphics )
+void X11SalGraphics::copyBits( const SalTwoRect *pPosAry,
+								  SalGraphics	   *pSSrcGraphics )
+{
+    X11SalGraphics* pSrcGraphics = pSSrcGraphics
+        ? static_cast<X11SalGraphics*>(pSSrcGraphics)
+        : this;
+    
+    if( pPosAry->mnSrcWidth <= 0
+        || pPosAry->mnSrcHeight <= 0
+        || pPosAry->mnDestWidth <= 0
+        || pPosAry->mnDestHeight <= 0 )
+    {
+        return;
+    }
+    
+    int n;
+    if( pSrcGraphics == this )
+    {
+        n = 2;
+    }
+    else if( pSrcGraphics->bWindow_ )
+    {
+        // window or compatible virtual device
+        if( pSrcGraphics->GetDisplay() == GetDisplay() )
+            n = 2; // same Display
+        else
+            n = 1; // printer or other display
+    }
+    else if( pSrcGraphics->bVirDev_ )
+    {
+        // printer compatible virtual device
+        if( bPrinter_ )
+            n = 2; // printer or compatible virtual device == same display
+        else
+            n = 1; // window or compatible virtual device
+    }
+    else
+        n = 0;
+    
+    if( n == 2
+        && pPosAry->mnSrcWidth	== pPosAry->mnDestWidth
+        && pPosAry->mnSrcHeight == pPosAry->mnDestHeight )
+    {
+        if( bXORMode_
+            && !pSrcGraphics->bVirDev_
+            && (GetDisplay()->GetProperties() & PROPERTY_BUG_XCopyArea_GXxor) )
         {
-            pSrcGraphics = this;
-            n = 2;
+            Pixmap hPixmap = XCreatePixmap( GetXDisplay(),
+                                            pSrcGraphics->GetDrawable(),		// source
+                                            pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                                            pSrcGraphics->GetBitCount() );
+            XCopyArea( GetXDisplay(),
+                       pSrcGraphics->GetDrawable(),		// source
+                       hPixmap,								// destination
+                       GetDisplay()->GetCopyGC(),			// no clipping
+                       pPosAry->mnSrcX,     pPosAry->mnSrcY,
+                       pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                       0,    				0 );			// destination
+            XCopyArea( GetXDisplay(),
+                       hPixmap,								// source
+                       GetDrawable(),						// destination
+                       GetInvertGC(),		// destination clipping
+                       0,				    0,				// source
+                       pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                       pPosAry->mnDestX,    pPosAry->mnDestY );
+            XFreePixmap( GetXDisplay(), hPixmap );
         }
-        else if( pSrcGraphics->_IsWindow() )
-            // window or compatible virtual device
-            if( pSrcGraphics->_GetDisplay() == _GetDisplay() )
-                n = 2; // same Display
-            else
-                n = 1; // printer or other display
-        else if( pSrcGraphics->_IsVirtualDevice() )
-            // printer compatible virtual device
-            if( _IsPrinter() )
-                n = 2; // printer or compatible virtual device == same display
-            else
-                n = 1; // window or compatible virtual device
         else
-            n = 0;
+            XCopyArea( GetXDisplay(),
+                       pSrcGraphics->GetDrawable(),		// source
+                       GetDrawable(),						// destination
+                       GetCopyGC(),			// destination clipping
+                       pPosAry->mnSrcX,     pPosAry->mnSrcY,
+                       pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                       pPosAry->mnDestX,    pPosAry->mnDestY );
 
-        if( n == 2
-            && pPosAry->mnSrcWidth	== pPosAry->mnDestWidth
-            && pPosAry->mnSrcHeight == pPosAry->mnDestHeight )
+        if( bWindow_ && ! bVirDev_ )
         {
-            if( _IsXORMode()
-                && !pSrcGraphics->_IsVirtualDevice()
-                && (_GetDisplay()->GetProperties() & PROPERTY_BUG_XCopyArea_GXxor) )
-            {
-                Pixmap hPixmap = XCreatePixmap( _GetXDisplay(),
-                                                pSrcGraphics->_GetDrawable(),		// source
-                                                pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                                                pSrcGraphics->GetBitCount() );
-                XCopyArea( _GetXDisplay(),
-                           pSrcGraphics->_GetDrawable(),		// source
-                           hPixmap,								// destination
-                           _GetDisplay()->GetCopyGC(),			// no clipping
-                           pPosAry->mnSrcX,     pPosAry->mnSrcY,
-                           pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                           0,    				0 );			// destination
-                XCopyArea( _GetXDisplay(),
-                           hPixmap,								// source
-                           _GetDrawable(),						// destination
-                           maGraphicsData.GetInvertGC(),		// destination clipping
-                           0,				    0,				// source
-                           pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                           pPosAry->mnDestX,    pPosAry->mnDestY );
-                XFreePixmap( _GetXDisplay(), hPixmap );
-            }
-            else
-                XCopyArea( _GetXDisplay(),
-                           pSrcGraphics->_GetDrawable(),		// source
-                           _GetDrawable(),						// destination
-                           maGraphicsData.GetCopyGC(),			// destination clipping
-                           pPosAry->mnSrcX,     pPosAry->mnSrcY,
-                           pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                           pPosAry->mnDestX,    pPosAry->mnDestY );
-
-            if( _IsWindow() && ! _IsVirtualDevice() )
-            {
-                maGraphicsData.m_pFrame->maFrameData.YieldGraphicsExpose();
-            }
+            YieldGraphicsExpose( GetXDisplay(), m_pFrame, GetDrawable() );
         }
-        else if( n )
+    }
+    else if( n )
+    {
+        SalBitmap *pDDB = pSrcGraphics->getBitmap( pPosAry->mnSrcX,
+                                                   pPosAry->mnSrcY,
+                                                   pPosAry->mnSrcWidth,
+                                                   pPosAry->mnSrcHeight );
+        
+        if( !pDDB )
         {
-            SalBitmap *pDDB = pSrcGraphics->GetBitmap( pPosAry->mnSrcX,
-                                                       pPosAry->mnSrcY,
-                                                       pPosAry->mnSrcWidth,
-                                                       pPosAry->mnSrcHeight, pSrcOutDev );
-
-            if( !pDDB )
-            {
-                stderr0( "SalGraphics::CopyBits !pSrcGraphics->GetBitmap()\n" );
-                return;
-            }
-
-            SalTwoRect aPosAry( *pPosAry );
-
-            aPosAry.mnSrcX = 0,	aPosAry.mnSrcY = 0;
-            DrawBitmap( &aPosAry, *pDDB, pOutDev );
-
-            delete pDDB;
+            stderr0( "SalGraphics::CopyBits !pSrcGraphics->GetBitmap()\n" );
+            return;
         }
-        else
-            stderr0( "SalGraphics::CopyBits from Printer not yet implemented\n" );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        
+        SalTwoRect aPosAry( *pPosAry );
+        
+        aPosAry.mnSrcX = 0,	aPosAry.mnSrcY = 0;
+        drawBitmap( &aPosAry, *pDDB );
+        
+        delete pDDB;
+    }
+    else
+        stderr0( "X11SalGraphics::CopyBits from Printer not yet implemented\n" );
 }
 
 // --------------------------------------------------------------------------
 
-void SalGraphics::CopyArea ( long nDestX,    long nDestY,
+void X11SalGraphics::copyArea ( long nDestX,    long nDestY,
                                    long nSrcX,     long nSrcY,
                                    long nSrcWidth, long nSrcHeight,
-                                   USHORT nFlags, const OutputDevice *pOutDev )
+                                   USHORT nFlags )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR( "Error: PrinterGfx::CopyArea() not implemented" );
-	}
-	else
-	{
-#endif
-
-        SalTwoRect aPosAry;
-
-        aPosAry.mnDestX = nDestX;
-        aPosAry.mnDestY = nDestY;
-        aPosAry.mnDestWidth  = nSrcWidth;
-        aPosAry.mnDestHeight = nSrcHeight;
-
-        aPosAry.mnSrcX = nSrcX;
-        aPosAry.mnSrcY = nSrcY;
-        aPosAry.mnSrcWidth  = nSrcWidth;
-        aPosAry.mnSrcHeight = nSrcHeight;
-
-        SalGraphics::CopyBits ( &aPosAry, 0, pOutDev, pOutDev );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-}
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap, const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		Rectangle aSrc (Point(pPosAry->mnSrcX, pPosAry->mnSrcY),
-						Size(pPosAry->mnSrcWidth, pPosAry->mnSrcHeight));
-		Rectangle aDst (Point(pPosAry->mnDestX, pPosAry->mnDestY),
-						Size(pPosAry->mnDestWidth, pPosAry->mnDestHeight));
-
-		BitmapBuffer* pBuffer= const_cast<SalBitmap&>(rSalBitmap).AcquireBuffer(sal_True);
-
-		SalPrinterBmp aBmp (pBuffer);
-		maGraphicsData.m_pPrinterGfx->DrawBitmap (aDst, aSrc, aBmp);
-
-		const_cast<SalBitmap&>(rSalBitmap).ReleaseBuffer (pBuffer, sal_True);
-	}
-	else
-	{
-#endif
-
-        SalDisplay*			pSalDisp = maGraphicsData.GetDisplay();
-        Display*			pXDisp = pSalDisp->GetDisplay();
-        const Drawable		aDrawable( maGraphicsData.GetDrawable() );
+    SalTwoRect aPosAry;
+    
+    aPosAry.mnDestX = nDestX;
+    aPosAry.mnDestY = nDestY;
+    aPosAry.mnDestWidth  = nSrcWidth;
+    aPosAry.mnDestHeight = nSrcHeight;
+    
+    aPosAry.mnSrcX = nSrcX;
+    aPosAry.mnSrcY = nSrcY;
+    aPosAry.mnSrcWidth  = nSrcWidth;
+    aPosAry.mnSrcHeight = nSrcHeight;
+    
+    copyBits ( &aPosAry, 0 );
+}
+
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+void X11SalGraphics::drawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap )
+{
+    SalDisplay*			pSalDisp = GetDisplay();
+    Display*			pXDisp = pSalDisp->GetDisplay();
+    const Drawable		aDrawable( GetDrawable() );
+    const SalColormap&	rColMap = pSalDisp->GetColormap();
+    const long			nDepth = GetDisplay()->GetVisual()->GetDepth();
+    GC					aGC( GetCopyGC() );
+    XGCValues			aOldVal, aNewVal;
+    int					nValues = GCForeground | GCBackground;
+    
+    if( rSalBitmap.GetBitCount() == 1 )
+    {
+        // set foreground/background values for 1Bit bitmaps
+        XGetGCValues( pXDisp, aGC, nValues, &aOldVal );
+        aNewVal.foreground = rColMap.GetWhitePixel(), aNewVal.background = rColMap.GetBlackPixel();
+        XChangeGC( pXDisp, aGC, nValues, &aNewVal );
+    }
+    
+    static_cast<const X11SalBitmap&>(rSalBitmap).ImplDraw( aDrawable, nDepth, *pPosAry, aGC, bWindow_ );
+    
+    if( rSalBitmap.GetBitCount() == 1 )
+        XChangeGC( pXDisp, aGC, nValues, &aOldVal );
+    XFlush( pXDisp );
+}
+
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+void X11SalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                                 const SalBitmap& rSalBitmap,
+                                 const SalBitmap& rTransBitmap )
+{
+    DBG_ASSERT( !bPrinter_, "Drawing of transparent bitmaps on printer devices is strictly forbidden" );
+
+    SalDisplay*		pSalDisp = GetDisplay();
+    Display*		pXDisp = pSalDisp->GetDisplay();
+    Drawable		aDrawable( GetDrawable() );
+    const USHORT	nDepth = pSalDisp->GetVisual()->GetDepth();
+    Pixmap			aFG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
+                                        pPosAry->mnDestHeight, nDepth ) );
+    Pixmap			aBG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
+                                        pPosAry->mnDestHeight, nDepth ) );
+    
+    if( aFG && aBG )
+    {
+        GC					aTmpGC;
+        XGCValues			aValues;
         const SalColormap&	rColMap = pSalDisp->GetColormap();
-        const long			nDepth = maGraphicsData.GetDisplay()->GetVisual()->GetDepth();
-        GC					aGC( maGraphicsData.GetCopyGC() );
-        XGCValues			aOldVal, aNewVal;
-        int					nValues = GCForeground | GCBackground;
-
-		if( rSalBitmap.GetBitCount() == 1 )
-		{
-				// set foreground/background values for 1Bit bitmaps
-				XGetGCValues( pXDisp, aGC, nValues, &aOldVal );
-				aNewVal.foreground = rColMap.GetWhitePixel(), aNewVal.background = rColMap.GetBlackPixel();
-				XChangeGC( pXDisp, aGC, nValues, &aNewVal );
-		}
-
-#if defined(_USE_PRINT_EXTENSION_)
-		rSalBitmap.ImplDraw( pSalDisp, aDrawable, nDepth, *pPosAry,  aGC );
-#else
-		rSalBitmap.ImplDraw( aDrawable, nDepth, *pPosAry, aGC );
-#endif
-
-		if( rSalBitmap.GetBitCount() == 1 )
-				XChangeGC( pXDisp, aGC, nValues, &aOldVal );
-        XFlush( pXDisp );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-}
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap,
-									const SalBitmap& rTransBitmap, const OutputDevice *pOutDev )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent bitmap");
-	}
-	else
-	{
-#endif
-
-        DBG_ASSERT( !_IsPrinter(), "Drawing of transparent bitmaps on printer devices is strictly forbidden" );
-
-        SalDisplay*		pSalDisp = maGraphicsData.GetDisplay();
-        Display*		pXDisp = pSalDisp->GetDisplay();
-        Drawable		aDrawable( maGraphicsData.GetDrawable() );
-        const USHORT	nDepth = pSalDisp->GetVisual()->GetDepth();
-        Pixmap			aFG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
-                                            pPosAry->mnDestHeight, nDepth ) );
-        Pixmap			aBG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
-                                            pPosAry->mnDestHeight, nDepth ) );
-
-        if( aFG && aBG )
+        const int			nBlack = rColMap.GetBlackPixel(), nWhite = rColMap.GetWhitePixel();
+        const int			nValues = GCFunction | GCForeground | GCBackground;
+        SalTwoRect			aTmpRect( *pPosAry ); aTmpRect.mnDestX = aTmpRect.mnDestY = 0;
+        
+        // draw paint bitmap in pixmap #1
+        aValues.function = GXcopy, aValues.foreground = nWhite, aValues.background = nBlack;
+        aTmpGC = XCreateGC( pXDisp, aFG, nValues, &aValues );
+        static_cast<const X11SalBitmap&>(rSalBitmap).ImplDraw( aFG, nDepth, aTmpRect, aTmpGC, false );
+        DBG_TESTTRANS( aFG );
+
+        // draw background in pixmap #2
+        XCopyArea( pXDisp, aDrawable, aBG, aTmpGC,
+                   pPosAry->mnDestX, pPosAry->mnDestY,
+                   pPosAry->mnDestWidth, pPosAry->mnDestHeight,
+                   0, 0 );
+
+        DBG_TESTTRANS( aBG );
+        
+        // mask out paint bitmap in pixmap #1 (transparent areas 0)
+        aValues.function = GXand, aValues.foreground = 0x00000000, aValues.background = 0xffffffff;
+        XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
+        static_cast<const X11SalBitmap&>(rTransBitmap).ImplDraw( aFG, 1, aTmpRect, aTmpGC, false );
+        
+        DBG_TESTTRANS( aFG );
+        
+        // #105055# For XOR mode, keep background behind bitmap intact
+        if( !bXORMode_ )
         {
-            GC					aTmpGC;
-            XGCValues			aValues;
-            const SalColormap&	rColMap = pSalDisp->GetColormap();
-            const int			nBlack = rColMap.GetBlackPixel(), nWhite = rColMap.GetWhitePixel();
-            const int			nValues = GCFunction | GCForeground | GCBackground;
-            SalTwoRect			aTmpRect( *pPosAry ); aTmpRect.mnDestX = aTmpRect.mnDestY = 0;
-
-            // draw paint bitmap in pixmap #1
-            aValues.function = GXcopy, aValues.foreground = nWhite, aValues.background = nBlack;
-            aTmpGC = XCreateGC( pXDisp, aFG, nValues, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-            rSalBitmap.ImplDraw( pSalDisp, aFG, nDepth, aTmpRect, aTmpGC );
-#else
-            rSalBitmap.ImplDraw( aFG, nDepth, aTmpRect, aTmpGC );
-#endif
-            DBG_TESTTRANS( aFG );
-
-            // draw background in pixmap #2
-            XCopyArea( pXDisp, aDrawable, aBG, aTmpGC,
-                       pPosAry->mnDestX, pPosAry->mnDestY,
-                       pPosAry->mnDestWidth, pPosAry->mnDestHeight,
-                       0, 0 );
-            DBG_TESTTRANS( aBG );
-
-            // mask out paint bitmap in pixmap #1 (transparent areas 0)
-            aValues.function = GXand, aValues.foreground = 0x00000000, aValues.background = 0xffffffff;
+            // mask out background in pixmap #2 (nontransparent areas 0)
+            aValues.function = GXand, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
             XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-            rTransBitmap.ImplDraw( pSalDisp, aFG, 1, aTmpRect, aTmpGC );
-#else
-            rTransBitmap.ImplDraw( aFG, 1, aTmpRect, aTmpGC );
-#endif
-
-            DBG_TESTTRANS( aFG );
-
-            // #105055# For XOR mode, keep background behind bitmap intact
-            if( !maGraphicsData.bXORMode_ )
-            {
-                // mask out background in pixmap #2 (nontransparent areas 0)
-                aValues.function = GXand, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
-                XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-                rTransBitmap.ImplDraw( pSalDisp, aBG, 1, aTmpRect, aTmpGC );
-#else
-                rTransBitmap.ImplDraw( aBG, 1, aTmpRect, aTmpGC );
-#endif
-
-                DBG_TESTTRANS( aBG );
-            }
-
-            // merge pixmap #1 and pixmap #2 in pixmap #2
-            aValues.function = GXxor, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
-            XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
-            XCopyArea( pXDisp, aFG, aBG, aTmpGC,
-                       0, 0,
-                       pPosAry->mnDestWidth, pPosAry->mnDestHeight,
-				   0, 0 );
-            DBG_TESTTRANS( aBG );
-
-            // #105055# Disable XOR temporarily
-            BOOL bOldXORMode( maGraphicsData.bXORMode_ );
-            maGraphicsData.bXORMode_ = FALSE;
-
-            // copy pixmap #2 (result) to background
-            XCopyArea( pXDisp, aBG, aDrawable, maGraphicsData.GetCopyGC(),
-                       0, 0,
-                       pPosAry->mnDestWidth, pPosAry->mnDestHeight,
-                       pPosAry->mnDestX, pPosAry->mnDestY );
+            static_cast<const X11SalBitmap&>(rTransBitmap).ImplDraw( aBG, 1, aTmpRect, aTmpGC, false );
+            
             DBG_TESTTRANS( aBG );
-
-            maGraphicsData.bXORMode_ = bOldXORMode;
-
-            XFreeGC( pXDisp, aTmpGC );
-            XFlush( pXDisp );
         }
-        else
-            DrawBitmap( pPosAry, rSalBitmap, pOutDev );
-
-        if( aFG )
-            XFreePixmap( pXDisp, aFG );
-
-        if( aBG )
-            XFreePixmap( pXDisp, aBG );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        
+        // merge pixmap #1 and pixmap #2 in pixmap #2
+        aValues.function = GXxor, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
+        XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
+        XCopyArea( pXDisp, aFG, aBG, aTmpGC,
+                   0, 0,
+                   pPosAry->mnDestWidth, pPosAry->mnDestHeight,
+				   0, 0 );
+        DBG_TESTTRANS( aBG );
+        
+        // #105055# Disable XOR temporarily
+        BOOL bOldXORMode( bXORMode_ );
+        bXORMode_ = FALSE;
+        
+        // copy pixmap #2 (result) to background
+        XCopyArea( pXDisp, aBG, aDrawable, GetCopyGC(),
+                   0, 0,
+                   pPosAry->mnDestWidth, pPosAry->mnDestHeight,
+                   pPosAry->mnDestX, pPosAry->mnDestY );
+        YieldGraphicsExpose( pXDisp, bWindow_ ? m_pFrame : NULL, aDrawable );
+        
+        DBG_TESTTRANS( aBG );
+        
+        bXORMode_ = bOldXORMode;
+        
+        XFreeGC( pXDisp, aTmpGC );
+        XFlush( pXDisp );
+    }
+    else
+        drawBitmap( pPosAry, rSalBitmap );
+    
+    if( aFG )
+        XFreePixmap( pXDisp, aFG );
+    
+    if( aBG )
+        XFreePixmap( pXDisp, aBG );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap,
-							  SalColor nTransparentColor, const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent color");
-	}
-	else
-	{
-#endif
-
-        DBG_ERROR( "::DrawBitmap with transparent color not supported" );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+void X11SalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                                 const SalBitmap& rSalBitmap,
+                                 SalColor nTransparentColor )
+{
+    DBG_ERROR( "::DrawBitmap with transparent color not supported" );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawMask( const SalTwoRect* pPosAry, const SalBitmap &rSalBitmap,
-								  SalColor nMaskColor, const OutputDevice *pOutDev )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR("Error: PrinterGfx::DrawMask() not implemented");
-	}
-	else
-	{
-#endif
-
-        SalDisplay*	pSalDisp = maGraphicsData.GetDisplay();
-        Display*	pXDisp = pSalDisp->GetDisplay();
-        Drawable	aDrawable( maGraphicsData.GetDrawable() );
-        Pixmap		aStipple( XCreatePixmap( pXDisp, aDrawable,
-                                             pPosAry->mnDestWidth,
-                                             pPosAry->mnDestHeight, 1 ) );
-
-        if( aStipple )
-        {
-            SalTwoRect	aTwoRect( *pPosAry ); aTwoRect.mnDestX = aTwoRect.mnDestY = 0;
-            GC			aTmpGC;
-            XGCValues	aValues;
-
-            // create a stipple bitmap first (set bits are changed to unset bits and vice versa)
-            aValues.function = GXcopyInverted;
-            aValues.foreground = 1, aValues.background = 0;
-            aTmpGC = XCreateGC( pXDisp, aStipple, GCFunction | GCForeground | GCBackground, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-            rSalBitmap.ImplDraw( pSalDisp, aStipple, 1, aTwoRect, aTmpGC );
-#else
-            rSalBitmap.ImplDraw( aStipple, 1, aTwoRect, aTmpGC );
-#endif
-
-            XFreeGC( pXDisp, aTmpGC );
-
-            // Set stipple and draw rectangle
-            GC	aStippleGC( maGraphicsData.GetStippleGC() );
-            int	nX = pPosAry->mnDestX, nY = pPosAry->mnDestY;
-
-            XSetStipple( pXDisp, aStippleGC, aStipple );
-            XSetTSOrigin( pXDisp, aStippleGC, nX, nY );
-            XSetForeground( pXDisp, aStippleGC, _GetPixel( nMaskColor ) );
-            XFillRectangle( pXDisp, aDrawable, aStippleGC,
-                            nX, nY,
-                            pPosAry->mnDestWidth, pPosAry->mnDestHeight );
-            XFreePixmap( pXDisp, aStipple );
-            XFlush( pXDisp );
-        }
-        else
-            DrawBitmap( pPosAry, rSalBitmap, pOutDev );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+void X11SalGraphics::drawMask( const SalTwoRect* pPosAry,
+                               const SalBitmap &rSalBitmap,
+                               SalColor nMaskColor )
+{
+    SalDisplay*	pSalDisp = GetDisplay();
+    Display*	pXDisp = pSalDisp->GetDisplay();
+    Drawable	aDrawable( GetDrawable() );
+    Pixmap		aStipple( XCreatePixmap( pXDisp, aDrawable,
+                                         pPosAry->mnDestWidth,
+                                         pPosAry->mnDestHeight, 1 ) );
+    
+    if( aStipple )
+    {
+        SalTwoRect	aTwoRect( *pPosAry ); aTwoRect.mnDestX = aTwoRect.mnDestY = 0;
+        GC			aTmpGC;
+        XGCValues	aValues;
+        
+        // create a stipple bitmap first (set bits are changed to unset bits and vice versa)
+        aValues.function = GXcopyInverted;
+        aValues.foreground = 1, aValues.background = 0;
+        aTmpGC = XCreateGC( pXDisp, aStipple, GCFunction | GCForeground | GCBackground, &aValues );
+        static_cast<const X11SalBitmap&>(rSalBitmap).ImplDraw( aStipple, 1, aTwoRect, aTmpGC, false );
+        
+        XFreeGC( pXDisp, aTmpGC );
+        
+        // Set stipple and draw rectangle
+        GC	aStippleGC( GetStippleGC() );
+        int	nX = pPosAry->mnDestX, nY = pPosAry->mnDestY;
+        
+        XSetStipple( pXDisp, aStippleGC, aStipple );
+        XSetTSOrigin( pXDisp, aStippleGC, nX, nY );
+        XSetForeground( pXDisp, aStippleGC, GetPixel( nMaskColor ) );
+        XFillRectangle( pXDisp, aDrawable, aStippleGC,
+                        nX, nY,
+                        pPosAry->mnDestWidth, pPosAry->mnDestHeight );
+        XFreePixmap( pXDisp, aStipple );
+        XFlush( pXDisp );
+    }
+    else
+        drawBitmap( pPosAry, rSalBitmap );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalBitmap *SalGraphics::GetBitmap( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+SalBitmap *X11SalGraphics::getBitmap( long nX, long nY, long nDX, long nDY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_WARNING ("Warning: PrinterGfx::GetBitmap() not implemented");
-		return NULL;
-	}
-	else
-	{
-#endif
-
-        if( _IsPrinter() && !_IsVirtualDevice() )
+    if( bPrinter_ && !bVirDev_ )
+        return NULL;
+    
+    if( bWindow_ && !bVirDev_ )
+    {
+        // normalize
+        if( nDX < 0 )
+        {
+            nX += nDX;
+            nDX = -nDX;
+        }
+        if ( nDY < 0 )
+        {
+            nY += nDY;
+            nDY = -nDY;
+        }
+        
+        XWindowAttributes aAttrib;
+        
+        XGetWindowAttributes( GetXDisplay(), GetDrawable(), &aAttrib );
+        if( aAttrib.map_state != IsViewable )
+        {
+            stderr0( "X11SalGraphics::GetBitmap drawable not viewable\n" );
             return NULL;
-
-        if( _IsWindow() && !_IsVirtualDevice() )
+        }
+        
+        // am Window clippen (eg)
+        if ( nX < 0 )
         {
-            // normalize
-            if( nDX < 0 )
-            {
-                nX += nDX;
-                nDX = -nDX;
-            }
-            if ( nDY < 0 )
-            {
-                nY += nDY;
-                nDY = -nDY;
-            }
-
-            XWindowAttributes aAttrib;
-
-            XGetWindowAttributes( _GetXDisplay(), _GetDrawable(), &aAttrib );
-            if( aAttrib.map_state != IsViewable )
-            {
-                stderr0( "SalGraphics::GetBitmap drawable not viewable\n" );
-                return NULL;
-            }
-
-            // am Window clippen (eg)
-            if ( nX < 0 )
-            {
-                nDX += nX;
-                nX   = 0;
-            }
-            if ( nY < 0 )
-            {
-                nDY += nY;
-                nY   = 0;
-            }
-            if( nX + nDX > aAttrib.width )
-                nDX = aAttrib.width  - nX;
-            if( nY + nDY > aAttrib.height )
-                nDY = aAttrib.height - nY;
-
-            // nun alles ok ?
-            if( nDX <= 0 || nDY <= 0 )
-            {
-                stderr0( "SalGraphics::GetBitmap zero sized bitmap after clipping\n" );
-                return NULL;
-            }
+            nDX += nX;
+            nX   = 0;
         }
-
-        SalBitmap*	pSalBitmap = new SalBitmap;
-        USHORT		nBitCount = GetBitCount();
-
-        if( &_GetDisplay()->GetColormap() != &_GetColormap() )
-            nBitCount = 1;
-
-		pSalBitmap->ImplCreateLocalFromDrawable( _GetDrawable(), nBitCount, nX, nY, nDX, nDY );
-        return pSalBitmap;
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-}
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalColor SalGraphics::GetPixel( long nX, long nY, const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR ("Warning: PrinterGfx::GetPixel() not implemented");
-		return 0;
-	}
-	else
-	{
-#endif
-
-        if( _IsWindow() && !_IsVirtualDevice() )
+        if ( nY < 0 )
         {
-            XWindowAttributes aAttrib;
-
-            XGetWindowAttributes( _GetXDisplay(), _GetDrawable(), &aAttrib );
-            if( aAttrib.map_state != IsViewable )
-            {
-                stderr0( "SalGraphics::GetPixel drawable not viewable\n" );
-                return 0;
-            }
+            nDY += nY;
+            nY   = 0;
+        }
+        if( nX + nDX > aAttrib.width )
+            nDX = aAttrib.width  - nX;
+        if( nY + nDY > aAttrib.height )
+            nDY = aAttrib.height - nY;
+        
+        // nun alles ok ?
+        if( nDX <= 0 || nDY <= 0 )
+        {
+            stderr0( "X11SalGraphics::GetBitmap zero sized bitmap after clipping\n" );
+            return NULL;
         }
+    }
+    
+    X11SalBitmap*	pSalBitmap = new X11SalBitmap;
+    USHORT			nBitCount = GetBitCount();
+    
+    if( &GetDisplay()->GetColormap() != &GetColormap() )
+        nBitCount = 1;
+    
+    
+    pSalBitmap->ImplCreateFromDrawable( GetDrawable(), nBitCount, nX, nY, nDX, nDY );
+    return pSalBitmap;
+}
 
-        XImage *pXImage = XGetImage( _GetXDisplay(),
-                                     _GetDrawable(),
-                                     nX, nY,
-                                     1,  1,
-                                     AllPlanes,
-                                     ZPixmap );
-        if( !pXImage )
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+SalColor X11SalGraphics::getPixel( long nX, long nY )
+{
+    if( bWindow_ && !bVirDev_ )
+    {
+        XWindowAttributes aAttrib;
+        
+        XGetWindowAttributes( GetXDisplay(), GetDrawable(), &aAttrib );
+        if( aAttrib.map_state != IsViewable )
         {
-            stderr0( "SalGraphics::GetPixel !XGetImage()\n" );
+            stderr0( "X11SalGraphics::GetPixel drawable not viewable\n" );
             return 0;
         }
-
-        XColor aXColor;
-
-        aXColor.pixel = XGetPixel( pXImage, 0, 0 );
-        XDestroyImage( pXImage );
-
-        return _GetColormap().GetColor( aXColor.pixel );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    }
+    
+    XImage *pXImage = XGetImage( GetXDisplay(),
+                                     GetDrawable(),
+                                 nX, nY,
+                                 1,  1,
+                                 AllPlanes,
+                                 ZPixmap );
+    if( !pXImage )
+    {
+        stderr0( "X11SalGraphics::GetPixel !XGetImage()\n" );
+        return 0;
+    }
+    
+    XColor aXColor;
+    
+    aXColor.pixel = XGetPixel( pXImage, 0, 0 );
+    XDestroyImage( pXImage );
+    
+    return GetColormap().GetColor( aXColor.pixel );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::Invert( long		nX,
+void X11SalGraphics::invert( long		nX,
 								long		nY,
 								long		nDX,
 								long		nDY,
-								SalInvert	nFlags, const OutputDevice* )
+								SalInvert	nFlags )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR ("Warning: PrinterGfx::Invert() not implemented");
-	}
-	else
-	{
-#endif
-
-        SalDisplay *pDisp = _GetDisplay();
-
-        GC pGC;
-        if( SAL_INVERT_50 & nFlags )
+    SalDisplay *pDisp = GetDisplay();
+    
+    GC pGC;
+    if( SAL_INVERT_50 & nFlags )
+    {
+        pGC = GetInvert50GC();
+        XFillRectangle( GetXDisplay(), GetDrawable(), pGC, nX, nY, nDX, nDY );
+    }
+    else
+    {
+        if ( SAL_INVERT_TRACKFRAME & nFlags )
         {
-            pGC = maGraphicsData.GetInvert50GC();
-            XFillRectangle( _GetXDisplay(), _GetDrawable(), pGC, nX, nY, nDX, nDY );
+            pGC = GetTrackingGC();
+            XDrawRectangle( GetXDisplay(), GetDrawable(),  pGC, nX, nY, nDX, nDY );
         }
         else
-            if ( SAL_INVERT_TRACKFRAME & nFlags )
-            {
-                pGC = maGraphicsData.GetTrackingGC();
-                XDrawRectangle( _GetXDisplay(), _GetDrawable(),  pGC, nX, nY, nDX, nDY );
-            }
-            else
-            {
-                pGC = maGraphicsData.GetInvertGC();
-                XFillRectangle( _GetXDisplay(), _GetDrawable(),  pGC, nX, nY, nDX, nDY );
-            }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        {
+            pGC = GetInvertGC();
+            XFillRectangle( GetXDisplay(), GetDrawable(),  pGC, nX, nY, nDX, nDY );
+        }
+    }
 }
 
Index: vcl/unx/source/gdi/salgdi3.cxx
===================================================================
--- vcl/unx/source/gdi/salgdi3.cxx.orig	2004-09-12 14:46:23.000000000 +0200
+++ vcl/unx/source/gdi/salgdi3.cxx	2004-09-14 14:11:55.218571704 +0200
@@ -59,10 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALGDI3_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -76,9 +72,7 @@
 #include <alloca.h>
 #endif
 
-#ifdef USE_BUILTIN_RASTERIZER
 #include <gcach_xpeer.hxx>
-#endif // USE_BUILTIN_RASTERIZER
 
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
@@ -92,14 +86,17 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
+#endif
+#ifndef _VCL_PSPGRAPHICS_H
+#include <pspgraphics.h>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 #ifndef _SV_OUTDEV_H
 #include <outdev.h>
@@ -107,8 +104,8 @@
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _RTL_TENCINFO_H
 #include <rtl/tencinfo.h>
@@ -132,9 +129,6 @@
 #include <svapp.hxx>
 #endif
 
-#ifndef ANSI1252_HXX_
-#include "ansi1252.hxx"
-#endif
 #ifndef XLFD_ATTRIBUTE_HXX
 #include "xlfd_attr.hxx"
 #endif
@@ -155,106 +149,12 @@
 
 // -----------------------------------------------------------------------
 
-#ifdef USE_BUILTIN_RASTERIZER
 static X11GlyphPeer aX11GlyphPeer;
-#endif // USE_BUILTIN_RASTERIZER
 
 using namespace rtl;
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-/*
- *  returns:
- *  true: cut out positions rStart to rStop from output because fax number was swallowed
- *  false: do nothing
- */
-
-String SalGraphicsData::FaxPhoneComment( const String& rOrig, xub_StrLen nIndex, xub_StrLen& rLen, xub_StrLen& rCutStart, xub_StrLen& rCutStop ) const
-{
-    rCutStop = rCutStart = STRING_NOTFOUND;
-
-#ifdef _USE_PRINT_EXTENSION_
-    return String( rOrig );
-#else
-	if( ! m_pPhoneNr )
-		return String( rOrig );
-#endif
-
-#define FAX_PHONE_TOKEN          "@@#"
-#define FAX_PHONE_TOKEN_LENGTH   3
-#define FAX_END_TOKEN            "@@"
-#define FAX_END_TOKEN_LENGTH     2
-
-	bool bRet = false;
-	bool bStarted = false;
-	bool bStopped = false;
-	USHORT nPos;
-	USHORT nStart = 0;
-	USHORT nStop = rLen;
-	String aPhone = rOrig.Copy( nIndex, rLen );
-
-	static String aPhoneNumber;
-	static bool bIsCollecting = false;
-
-	if( ! bIsCollecting )
-	{
-		if( ( nPos = aPhone.SearchAscii( FAX_PHONE_TOKEN ) ) != STRING_NOTFOUND )
-		{
-			nStart = nPos;
-			bIsCollecting = true;
-			aPhoneNumber.Erase();
-			bRet = true;
-			bStarted = true;
-		}
-	}
-	if( bIsCollecting )
-	{
-		bRet = true;
-		nPos = bStarted ? nStart + FAX_PHONE_TOKEN_LENGTH : 0;
-		if( ( nPos = aPhone.SearchAscii( FAX_END_TOKEN, nPos ) ) != STRING_NOTFOUND )
-		{
-			bIsCollecting = false;
-			nStop = nPos + FAX_END_TOKEN_LENGTH;
-			bStopped = true;
-		}
-		int nTokenStart = nStart + (bStarted ? FAX_PHONE_TOKEN_LENGTH : 0);
-		int nTokenStop = nStop - (bStopped ? FAX_END_TOKEN_LENGTH : 0);
-		aPhoneNumber += aPhone.Copy( nTokenStart, nTokenStop - nTokenStart );
-		if( ! bIsCollecting )
-		{
-#ifndef PRINTER_DUMMY
-			*m_pPhoneNr = aPhoneNumber;
-#endif
-			aPhoneNumber.Erase();
-		}
-	}
-	if( aPhoneNumber.Len() > 1024 )
-	{
-		bIsCollecting = false;
-		aPhoneNumber.Erase();
-		bRet = false;
-	}
-
-    String aRet;
-    if( bRet
-#ifndef MACOSX
-        && m_bSwallowFaxNo
-#endif
-        )
-    {
-        rLen -= nStop - nStart;
-        rCutStart = nStart+nIndex;
-        rCutStop = nStop+nIndex;
-        if( rCutStart )
-            aRet = rOrig.Copy( 0, rCutStart );
-        aRet += rOrig.Copy( rCutStop );
-    }
-    else
-        aRet = rOrig;
-
-    return aRet;
-}
-
 // ----------------------------------------------------------------------------
 //
 // manage X11 fonts and self rastered fonts
@@ -263,9 +163,6 @@ String SalGraphicsData::FaxPhoneComment(
 
 #ifndef _USE_PRINT_EXTENSION_
 
-static FontItalic ToFontItalic (psp::italic::type eItalic);
-static FontWeight ToFontWeight (psp::weight::type eWeight);
-
 class FontLookup
 {
 	public:
@@ -278,21 +175,20 @@ class FontLookup
 
 	private:
 
+		rtl::OString		maName;
 		FontWeight 			mnWeight;
 		FontItalic 			mnItalic;
 		sal_Bool			mbDisplay;
 
-		rtl::OString		maName;
-
 	public:
 
 							FontLookup ( ::std::list< psp::fontID >::iterator& it,
 							 			 const psp::PrintFontManager& rMgr );
 							FontLookup (const Xlfd& rFont);
 							FontLookup (const FontLookup &rRef) :
+									maName   (rRef.maName),
 									mnWeight (rRef.mnWeight),
 									mnItalic (rRef.mnItalic),
-									maName   (rRef.maName),
 									mbDisplay(rRef.mbDisplay)
 							{}
 							~FontLookup ()
@@ -345,8 +241,8 @@ FontLookup::FontLookup ( ::std::list< ps
 	psp::FastPrintFontInfo aInfo;
 	if (rMgr.getFontFastInfo (*it, aInfo))
 	{
-		mnItalic = ToFontItalic (aInfo.m_eItalic);
-		mnWeight = ToFontWeight (aInfo.m_eWeight);
+		mnItalic = PspGraphics::ToFontItalic (aInfo.m_eItalic);
+		mnWeight = PspGraphics::ToFontWeight (aInfo.m_eWeight);
 		mbDisplay=    aInfo.m_eType == psp::fonttype::Builtin
 				   || aInfo.m_eType == psp::fonttype::Unknown ? False : True;
 		maName   = rtl::OUStringToOString
@@ -588,7 +484,7 @@ SalDisplay::GetFont( const ExtendedXlfd 
 				if( pFontCache_->GetCurPos() )
 				{
 					pFontCache_->Remove( pItem );
-					pFontCache_->Insert( pItem, 0UL );
+					pFontCache_->Insert( pItem, (sal_uInt32)0 );
 				}
 				return pItem;
 			}
@@ -618,7 +514,7 @@ SalDisplay::GetFont( const ExtendedXlfd 
 	ExtendedFontStruct *pItem = new ExtendedFontStruct( GetDisplay(),
 										rPixelSize, bVertical,
 										const_cast<ExtendedXlfd*>(pRequestedFont) );
-	pFontCache_->Insert( pItem, 0UL );
+	pFontCache_->Insert( pItem, (sal_uInt32)0 );
 	pItem->AddRef();
 
 	return pItem;
@@ -656,12 +552,12 @@ SalDisplay::DestroyFontCache()
 
 // ----------------------------------------------------------------------------
 //
-// SalGraphicsData
+// X11SalGraphics
 //
 // ----------------------------------------------------------------------------
 
 GC
-SalGraphicsData::SelectFont()
+X11SalGraphics::SelectFont()
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -697,9 +593,8 @@ SalGraphicsData::SelectFont()
 
 //--------------------------------------------------------------------------
 
-bool SalGraphicsData::SetFont( const ImplFontSelectData *pEntry, int nFallbackLevel )
+bool X11SalGraphics::setFont( const ImplFontSelectData *pEntry, int nFallbackLevel )
 {
-    nFontOrientation_   = pEntry->mnOrientation;
     bFontVertical_      = pEntry->mbVertical;
 
 #ifdef HDU_DEBUG
@@ -740,9 +635,6 @@ bool SalGraphicsData::SetFont( const Imp
         return true;
     }
 
-    if( m_pPrinterGfx != NULL )
-        return false;
-
     bFontGC_    = FALSE;
     ExtendedXlfd *pSysFont = (ExtendedXlfd*)pEntry->mpFontData->mpSysData;
     if( !pSysFont )
@@ -834,8 +726,7 @@ ConvertTextItem16( XTextItem16* pTextIte
 
 //--------------------------------------------------------------------------
 
-#ifdef USE_BUILTIN_RASTERIZER
-void SalGraphicsData::DrawServerAAFontString( const ServerFontLayout& rLayout )
+void X11SalGraphics::DrawServerAAFontString( const ServerFontLayout& rLayout )
 {
     Display* pDisplay = GetXDisplay();
     Visual* pVisual = GetDisplay()->GetVisual()->GetVisual();
@@ -843,7 +734,7 @@ void SalGraphicsData::DrawServerAAFontSt
 
     // create xrender Picture for font foreground
     static Pixmap aPixmap;
-    static Picture aSrc = NULL;
+    static Picture aSrc = 0;
     if( !aSrc )
     {
         int iDummy;
@@ -879,7 +770,7 @@ void SalGraphicsData::DrawServerAAFontSt
 
     Point aPos;
     static const int MAXGLYPHS = 160;
-    long aGlyphAry[ MAXGLYPHS ];
+    sal_Int32 aGlyphAry[ MAXGLYPHS ];
     int nMaxGlyphs = rLayout.GetOrientation() ? 1 : MAXGLYPHS;
     for( int nStart = 0;;)
     {
@@ -900,7 +791,7 @@ void SalGraphicsData::DrawServerAAFontSt
 
 //--------------------------------------------------------------------------
 
-bool SalGraphicsData::DrawServerAAForcedString( const ServerFontLayout& rLayout )
+bool X11SalGraphics::DrawServerAAForcedString( const ServerFontLayout& rLayout )
 {
     ServerFont& rFont = rLayout.GetServerFont();
 
@@ -908,7 +799,7 @@ bool SalGraphicsData::DrawServerAAForced
     int nXmin, nXmax, nYmin, nYmax;
     int nStart = 0;
     Point aPos;
-    long nGlyph;
+    sal_Int32 nGlyph;
     for( bool bFirst=true; rLayout.GetNextGlyphs( 1, &nGlyph, aPos, nStart ); )
     {
         const RawBitmap* const pRawBitmap = aX11GlyphPeer.GetRawBitmap( rFont, nGlyph );
@@ -947,7 +838,7 @@ bool SalGraphicsData::DrawServerAAForced
     if( m_pFrame )
         nWidth = m_pFrame->maGeometry.nWidth, nHeight = m_pFrame->maGeometry.nHeight;
     else if( m_pVDev )
-        nWidth = m_pVDev->maVirDevData.GetWidth(), nHeight = m_pVDev->maVirDevData.GetHeight();
+        nWidth = m_pVDev->GetWidth(), nHeight = m_pVDev->GetHeight();
 
     if( pClipRegion_ && !XEmptyRegion( pClipRegion_ ) )
     {
@@ -1082,7 +973,7 @@ bool SalGraphicsData::DrawServerAAForced
 
 //--------------------------------------------------------------------------
 
-void SalGraphicsData::DrawServerSimpleFontString( const ServerFontLayout& rSalLayout )
+void X11SalGraphics::DrawServerSimpleFontString( const ServerFontLayout& rSalLayout )
 {
     ServerFont& rFont = rSalLayout.GetServerFont();
 
@@ -1096,7 +987,7 @@ void SalGraphicsData::DrawServerSimpleFo
     XCopyGC( pDisplay, nGC, (1<<GCLastBit)-(1+GCFillStyle+GCLineWidth), tmpGC );
 
     Point aPos;
-    long nGlyph;
+    sal_Int32 nGlyph;
     for( int nStart = 0; rSalLayout.GetNextGlyphs( 1, &nGlyph, aPos, nStart ); )
     {
         Pixmap aStipple = aX11GlyphPeer.GetPixmap( rFont, nGlyph );
@@ -1124,200 +1015,27 @@ void SalGraphicsData::DrawServerSimpleFo
 
 //--------------------------------------------------------------------------
 
-#ifndef _USE_PRINT_EXTENSION_
-
-class PspFontLayout : public GenericSalLayout
-{
-public:
-                        PspFontLayout( ::psp::PrinterGfx& );
-    virtual bool        LayoutText( ImplLayoutArgs& );
-    virtual void        InitFont() const;
-    virtual void        DrawText( SalGraphics& ) const;
-private:
-    ::psp::PrinterGfx&  mrPrinterGfx;
-    int                 mnFontID;
-    int                 mnFontHeight;
-    int                 mnFontWidth;
-    bool                mbVertical;
-};
-
-//--------------------------------------------------------------------------
-
-PspFontLayout::PspFontLayout( ::psp::PrinterGfx& rGfx )
-:   mrPrinterGfx( rGfx )
-{
-    mnFontID     = mrPrinterGfx.GetFontID();
-    mnFontHeight = mrPrinterGfx.GetFontHeight();
-    mnFontWidth  = mrPrinterGfx.GetFontWidth();
-    mbVertical   = mrPrinterGfx.GetFontVertical();
-}
-
-//--------------------------------------------------------------------------
-
-bool PspFontLayout::LayoutText( ImplLayoutArgs& rArgs )
-{
-    mbVertical = ((rArgs.mnFlags & SAL_LAYOUT_VERTICAL) != 0);
-
-    long nUnitsPerPixel = 1;
-    int nOldGlyphId = -1;
-    long nGlyphWidth = 0;
-    int nCharPos = -1;
-    Point aNewPos( 0, 0 );
-    GlyphItem aPrevItem;
-    rtl_TextEncoding aFontEnc = mrPrinterGfx.GetFontMgr().getFontEncoding( mnFontID );
-    for(;;)
-    {
-        bool bRightToLeft;
-        if( !rArgs.GetNextPos( &nCharPos, &bRightToLeft ) )
-            break;
-
-        sal_Unicode cChar = rArgs.mpStr[ nCharPos ];
-        if( bRightToLeft )
-            cChar = GetMirroredChar( cChar );
-        // symbol font aliasing: 0x0020-0x00ff -> 0xf020 -> 0xf0ff
-        if( aFontEnc == RTL_TEXTENCODING_SYMBOL )
-            if( cChar < 256 )
-                cChar += 0xf000;
-        int nGlyphIndex = cChar;  // printer glyphs = unicode
-
-        // update fallback_runs if needed
-        psp::CharacterMetric aMetric;
-        mrPrinterGfx.GetFontMgr().getMetrics( mnFontID, cChar, cChar, &aMetric, mbVertical );
-        if( aMetric.width == -1 && aMetric.height == -1 )
-            rArgs.NeedFallback( nCharPos, bRightToLeft );
-
-        // apply pair kerning to prev glyph if requested
-        if( SAL_LAYOUT_KERNING_PAIRS & rArgs.mnFlags )
-        {
-            if( nOldGlyphId > 0 )
-            {
-                const std::list< psp::KernPair >& rKernPairs = mrPrinterGfx.getKernPairs(mbVertical);
-                for( std::list< psp::KernPair >::const_iterator it = rKernPairs.begin();
-                     it != rKernPairs.end(); ++it )
-                {
-                    if( it->first == nOldGlyphId && it->second == nGlyphIndex )
-                    {
-                        int nTextScale = mrPrinterGfx.GetFontWidth();
-                        if( ! nTextScale )
-                            nTextScale = mrPrinterGfx.GetFontHeight();
-                        int nKern = (mbVertical ? it->kern_y : it->kern_x) * nTextScale;
-                        nGlyphWidth += nKern;
-                        aPrevItem.mnNewWidth = nGlyphWidth;
-                        break;
-                    }
-                }
-            }
-        }
-        
-        // finish previous glyph
-        if( nOldGlyphId >= 0 )
-            AppendGlyph( aPrevItem );
-        nOldGlyphId = nGlyphIndex;
-        aNewPos.X() += nGlyphWidth;
-
-        // prepare GlyphItem for appending it in next round
-        nUnitsPerPixel = mrPrinterGfx.GetCharWidth( cChar, cChar, &nGlyphWidth );
-        int nGlyphFlags = bRightToLeft ? GlyphItem::IS_RTL_GLYPH : 0;
-        nGlyphIndex |= GF_ISCHAR;
-        aPrevItem = GlyphItem( nCharPos, nGlyphIndex, aNewPos, nGlyphFlags, nGlyphWidth );
-    }
-
-    // append last glyph item if any
-    if( nOldGlyphId >= 0 )
-        AppendGlyph( aPrevItem );
-
-    SetOrientation( mrPrinterGfx.GetFontAngle() );
-    SetUnitsPerPixel( nUnitsPerPixel );
-    return (nOldGlyphId >= 0);
-}
-
-class PspServerFontLayout : public ServerFontLayout
-{
-public:
-    PspServerFontLayout( ::psp::PrinterGfx&, ServerFont& rFont );
-
-    virtual void        InitFont() const;
-private:
-    ::psp::PrinterGfx&  mrPrinterGfx;
-    int                 mnFontID;
-    int                 mnFontHeight;
-    int                 mnFontWidth;
-    bool                mbVertical;
-};
-
-PspServerFontLayout::PspServerFontLayout( ::psp::PrinterGfx& rGfx, ServerFont& rFont )
-        :   ServerFontLayout( rFont ),
-            mrPrinterGfx( rGfx )
-{
-    mnFontID     = mrPrinterGfx.GetFontID();
-    mnFontHeight = mrPrinterGfx.GetFontHeight();
-    mnFontWidth  = mrPrinterGfx.GetFontWidth();
-    mbVertical   = mrPrinterGfx.GetFontVertical();
-}
-
-void PspServerFontLayout::InitFont() const
-{
-    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
-        mnOrientation, mbVertical );
-}
-
-//--------------------------------------------------------------------------
-
-void DrawPrinterLayout( const SalLayout& rLayout, ::psp::PrinterGfx& rGfx )
-{
-    const int nMaxGlyphs = 200;
-    long        aGlyphAry[ nMaxGlyphs ];
-    long        aWidthAry[ nMaxGlyphs ];
-    sal_Int32   aIdxAry  [ nMaxGlyphs ];
-    sal_Unicode aUnicodes[ nMaxGlyphs ];
-    Point aPos;
-    long nUnitsPerPixel = rLayout.GetUnitsPerPixel();
-    for( int nStart = 0;; )
-    {
-        int nGlyphCount = rLayout.GetNextGlyphs( nMaxGlyphs, aGlyphAry, aPos, nStart, aWidthAry );
-        if( !nGlyphCount )
-            break;
-
-        long nXOffset = 0;
-        for( int i = 0; i < nGlyphCount; ++i )
-        {
-            nXOffset += aWidthAry[ i ];
-            aIdxAry[ i ] = nXOffset / nUnitsPerPixel;
-            long nGlyphIdx = aGlyphAry[i] & (GF_IDXMASK | GF_ROTMASK);
-            aUnicodes[i] = (aGlyphAry[i] & GF_ISCHAR) ? nGlyphIdx : 0;
-            aGlyphAry[i] = nGlyphIdx;
-        }
-
-        rGfx.DrawGlyphs( aPos, (unsigned long*)aGlyphAry, aUnicodes, nGlyphCount, aIdxAry );
-    }
-}
-
-//--------------------------------------------------------------------------
-
-void PspFontLayout::InitFont() const
-{
-    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
-        mnOrientation, mbVertical );
-}
-
-//--------------------------------------------------------------------------
-
-void PspFontLayout::DrawText( SalGraphics& ) const
+static Point
+RotatedPoint( Point &rOrigin, int nDx, int nAngle )
 {
-    DrawPrinterLayout( *this, mrPrinterGfx );
+    Point   aPos( rOrigin.X() + nDx, rOrigin.Y() );
+    Polygon aPolygon(1);
+    aPolygon.SetPoint( aPos, 0 );
+    aPolygon.Rotate( rOrigin, nAngle );
+    return aPolygon.GetPoint( 0 );
 }
 
-#endif // _USE_PRINT_EXTENSION_
-
 //--------------------------------------------------------------------------
 
-void SalGraphicsData::DispatchServerFontString( const ServerFontLayout& rLayout )
+void X11SalGraphics::DrawServerFontLayout( const ServerFontLayout& rLayout )
 {
-    if( m_pPrinterGfx != NULL )
-    {
-        // print complex text
-        DrawPrinterLayout( rLayout, *m_pPrinterGfx );
-    }
+    // draw complex text
+    ServerFont& rFont = rLayout.GetServerFont();
+    
+    if( aX11GlyphPeer.GetGlyphSet( rFont ) )
+        DrawServerAAFontString( rLayout );
+    else if( aX11GlyphPeer.ForcedAntialiasing( rFont ) )
+        DrawServerAAForcedString( rLayout );
     else
     {
         // draw complex text
@@ -1340,35 +1058,7 @@ void SalGraphicsData::DispatchServerFont
 
 //--------------------------------------------------------------------------
 
-void ServerFontLayout::DrawText( SalGraphics& rSalGraphics ) const
-{
-    rSalGraphics.maGraphicsData.DispatchServerFontString( *this );
-}
-
-//--------------------------------------------------------------------------
-
-static Point
-RotatedPoint( Point &rOrigin, int nDx, int nAngle )
-{
-    Point   aPos( rOrigin.X() + nDx, rOrigin.Y() );
-    Polygon aPolygon(1);
-    aPolygon.SetPoint( aPos, 0 );
-    aPolygon.Rotate( rOrigin, nAngle );
-    return aPolygon.GetPoint( 0 );
-}
-
-//--------------------------------------------------------------------------
-
-void SalGraphicsData::DrawServerFontString( const ServerFontLayout& rLayout )
-{
-    DispatchServerFontString( rLayout );
-}
-
-#endif // USE_BUILTIN_RASTERIZER
-
-//--------------------------------------------------------------------------
-
-void SalGraphicsData::DrawStringUCS2MB( ExtendedFontStruct& rFont,
+void X11SalGraphics::DrawStringUCS2MB( ExtendedFontStruct& rFont,
     const Point& rPoint, const sal_Unicode* pStr, int nLength )
 {
     Display* pDisplay   = GetXDisplay();
@@ -1397,8 +1087,9 @@ void SalGraphicsData::DrawStringUCS2MB( 
     {
         XTextItem16 *pTextItem = (XTextItem16*)alloca( nLength * sizeof(XTextItem16) );
         XChar2b     *pMBChar   = (XChar2b*)pStr;
+        int nItem = 0;
 
-        for( int nChar = 0, nItem = 0; nChar < nLength; ++nChar )
+        for( int nChar = 0; nChar < nLength; ++nChar )
         {
             rtl_TextEncoding  nEnc;
             XFontStruct* pFontStruct = rFont.GetFontStruct( pStr[nChar], &nEnc );
@@ -1420,15 +1111,13 @@ void SalGraphicsData::DrawStringUCS2MB( 
 
 //--------------------------------------------------------------------------
 
-ULONG SalGraphicsData::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
+ULONG X11SalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
 
 {
     ULONG nPairs = 0;
-#ifdef USE_BUILTIN_RASTERIZER
     if( mpServerFont[0] )
         nPairs = mpServerFont[0]->GetFontCodeRanges( pCodePairs );
     else
-#endif //USE_BUILTIN_RASTERIZER
     if( mXFont[0] )
         nPairs = mXFont[0]->GetFontCodeRanges( pCodePairs );
     return nPairs;
@@ -1463,204 +1152,32 @@ CheckNoNegativeCoordinateWorkaround()
 //
 // ----------------------------------------------------------------------------
 
-USHORT SalGraphics::SetFont( ImplFontSelectData *pEntry, int nFallbackLevel )
+USHORT X11SalGraphics::SetFont( ImplFontSelectData *pEntry, int nFallbackLevel )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if( (maGraphicsData.m_pPrinterGfx != NULL) )
-    {
-        sal_Bool bVertical = pEntry->mbVertical;
-        sal_Int32 nID = pEntry->mpFontData ? (sal_Int32)pEntry->mpFontData->mpSysData : 0;
-
-        // also set the serverside font for layouting
-        maGraphicsData.SetFont( pEntry, nFallbackLevel );
-
-        // set the printer and the printer fallback font
-        return maGraphicsData.m_pPrinterGfx->SetFont(
-                                                    nID,
-                                                    pEntry->mnHeight,
-                                                    pEntry->mnWidth,
-                                                    pEntry->mnOrientation,
-                                                    pEntry->mbVertical
-                                                );
-    }
-    else
-#endif
-    {
-        USHORT nRetVal = 0;
-        if( !maGraphicsData.SetFont( pEntry, nFallbackLevel ) )
-            nRetVal |= SAL_SETFONT_BADFONT;
-        if( _IsPrinter() || (maGraphicsData.mpServerFont[ nFallbackLevel ] != NULL) )
-            nRetVal |= SAL_SETFONT_USEDRAWTEXTARRAY;
-        return nRetVal;
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-void SalGraphics::RemovingFont( ImplFontData* pFontData )
-{
-    // ImplFontData gets removed => notify all caches
-    GlyphCache::GetInstance().RemoveFont( pFontData );
+    USHORT nRetVal = 0;
+    if( !setFont( pEntry, nFallbackLevel ) )
+        nRetVal |= SAL_SETFONT_BADFONT;
+    if( bPrinter_ || (mpServerFont[ nFallbackLevel ] != NULL) )
+        nRetVal |= SAL_SETFONT_USEDRAWTEXTARRAY;
+    return nRetVal;
 }
 
 // ----------------------------------------------------------------------------
 
 void
-SalGraphics::SetTextColor( SalColor nSalColor )
+X11SalGraphics::SetTextColor( SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if (maGraphicsData.m_pPrinterGfx != NULL)
+    if( nTextColor_	!= nSalColor )
     {
-        psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-        maGraphicsData.m_pPrinterGfx->SetTextColor (aColor);
+        nTextColor_     = nSalColor;
+        nTextPixel_     = GetPixel( nSalColor );
+        bFontGC_         = FALSE;
     }
-    else
-    {
-#endif
-
-    if( _GetTextColor()	!= nSalColor )
-    {
-        _GetTextColor()     = nSalColor;
-        _GetTextPixel()     = _GetPixel( nSalColor );
-        _IsFontGC()         = FALSE;
-    }
-
-#ifndef _USE_PRINT_EXTENSION_
-    }
-#endif
 }
 
 // ----------------------------------------------------------------------------
 
-#ifndef _USE_PRINT_EXTENSION_
-
-static FontWidth
-ToFontWidth (psp::width::type eWidth)
-{
-	switch (eWidth)
-	{
-		case psp::width::UltraCondensed: return WIDTH_ULTRA_CONDENSED;
-		case psp::width::ExtraCondensed: return WIDTH_EXTRA_CONDENSED;
-		case psp::width::Condensed:		 return WIDTH_CONDENSED;
-		case psp::width::SemiCondensed:	 return WIDTH_SEMI_CONDENSED;
-		case psp::width::Normal:		 return WIDTH_NORMAL;
-		case psp::width::SemiExpanded:	 return WIDTH_SEMI_EXPANDED;
-		case psp::width::Expanded:		 return WIDTH_EXPANDED;
-		case psp::width::ExtraExpanded:	 return WIDTH_EXTRA_EXPANDED;
-		case psp::width::UltraExpanded:	 return WIDTH_ULTRA_EXPANDED;
-	}
-	return WIDTH_DONTKNOW;
-}
-
-static FontWeight
-ToFontWeight (psp::weight::type eWeight)
-{
-	switch (eWeight)
-	{
-		case psp::weight::Thin:		  return WEIGHT_THIN;
-		case psp::weight::UltraLight: return WEIGHT_ULTRALIGHT;
-		case psp::weight::Light:	  return WEIGHT_LIGHT;
-		case psp::weight::SemiLight:  return WEIGHT_SEMILIGHT;
-		case psp::weight::Normal:	  return WEIGHT_NORMAL;
-		case psp::weight::Medium:	  return WEIGHT_MEDIUM;
-		case psp::weight::SemiBold:	  return WEIGHT_SEMIBOLD;
-		case psp::weight::Bold:		  return WEIGHT_BOLD;
-		case psp::weight::UltraBold:  return WEIGHT_ULTRABOLD;
-		case psp::weight::Black:	  return WEIGHT_BLACK;
-	}
-	return WEIGHT_DONTKNOW;
-}
-
-static FontPitch
-ToFontPitch (psp::pitch::type ePitch)
-{
-	switch (ePitch)
-	{
-		case psp::pitch::Fixed:		return PITCH_FIXED;
-		case psp::pitch::Variable:	return PITCH_VARIABLE;
-	}
-	return PITCH_DONTKNOW;
-}
-
-static FontItalic
-ToFontItalic (psp::italic::type eItalic)
-{
-	switch (eItalic)
-	{
-		case psp::italic::Upright:	return ITALIC_NONE;
-		case psp::italic::Oblique:	return ITALIC_OBLIQUE;
-		case psp::italic::Italic:	return ITALIC_NORMAL;
-	}
-	return ITALIC_DONTKNOW;
-}
-
-static FontFamily
-ToFontFamily (psp::family::type eFamily)
-{
-	switch (eFamily)
-	{
-		case psp::family::Decorative: return FAMILY_DECORATIVE;
-		case psp::family::Modern:	  return FAMILY_MODERN;
-		case psp::family::Roman:	  return FAMILY_ROMAN;
-		case psp::family::Script:	  return FAMILY_SCRIPT;
-		case psp::family::Swiss:	  return FAMILY_SWISS;
-		case psp::family::System:	  return FAMILY_SYSTEM;
-	}
-	return FAMILY_DONTKNOW;
-}
-
-static void SetImplFontData( const psp::FastPrintFontInfo& aInfo, ImplFontData& rData )
-{
-	rData.meFamily     	= ToFontFamily (aInfo.m_eFamilyStyle);
-	rData.meWeight     	= ToFontWeight (aInfo.m_eWeight);
-
-	rData.meItalic     	= ToFontItalic (aInfo.m_eItalic);
-	rData.meWidthType  	= ToFontWidth  (aInfo.m_eWidth);
-	rData.mePitch	   	= ToFontPitch  (aInfo.m_ePitch);
-	rData.meCharSet    	= aInfo.m_aEncoding;
-	rData.maName		= aInfo.m_aFamilyName;
-	// rData.meScript		= SCRIPT_DONTKNOW;
-	/*rData.maStyleName	= XXX */
-
-	rData.mnWidth		= 0;
-	rData.mnHeight		= 0;
-	rData.mbOrientation	= TRUE;
-	rData.mnQuality		= (aInfo.m_eType == psp::fonttype::Builtin ? 1024 : 0);
-	rData.mnVerticalOrientation= 0;
-	rData.meType		= TYPE_SCALABLE;
-	rData.mbDevice		= (aInfo.m_eType == psp::fonttype::Builtin);
-    String aMapNames;
-    for( ::std::list< OUString >::const_iterator it = aInfo.m_aAliases.begin(); it != aInfo.m_aAliases.end(); ++it )
-    {
-        if( it != aInfo.m_aAliases.begin() )
-            aMapNames.Append(';');
-        aMapNames.Append( String( *it ) );
-    }
-    rData.maMapNames	= aMapNames;
-    switch( aInfo.m_eType )
-    {
-        case psp::fonttype::TrueType:
-            rData.mbSubsettable	= TRUE;
-            rData.mbEmbeddable	= FALSE;
-            break;
-        case psp::fonttype::Type1:
-            rData.mbSubsettable	= FALSE;
-            rData.mbEmbeddable	= TRUE;
-            break;
-        default:
-            rData.mbSubsettable = FALSE;
-            rData.mbEmbeddable	= FALSE;
-            break;
-    }
-}
-
-#endif
-
-// ----------------------------------------------------------------------------
-
-ImplFontData* SalGraphics::AddTempDevFont( const String& rFileURL, const String& rFontName )
+ImplFontData* X11SalGraphics::AddTempDevFont( const String& rFileURL, const String& rFontName )
 {
     // inform font manager
     rtl::OUString aUSystemPath;
@@ -1676,7 +1193,7 @@ ImplFontData* SalGraphics::AddTempDevFon
     psp::FastPrintFontInfo aInfo;
     rMgr.getFontFastInfo( nFontId, aInfo );
     ImplFontData* pFontData = new ImplFontData;
-    SetImplFontData( aInfo, *pFontData );
+    PspGraphics::SetImplFontData( aInfo, *pFontData );
     pFontData->maName = rFontName;
     pFontData->mnQuality += 5800;
 
@@ -1690,164 +1207,82 @@ ImplFontData* SalGraphics::AddTempDevFon
 
 // ----------------------------------------------------------------------------
 
-void SalGraphics::GetDevFontList( ImplDevFontList *pList )
+void X11SalGraphics::GetDevFontList( ImplDevFontList *pList )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if (maGraphicsData.m_pJobData != NULL)
-    {
-        const char* pLangBoost = NULL;
-        const LanguageType aLang = Application::GetSettings().GetUILanguage();
-        switch( aLang )
-        {
-            case LANGUAGE_JAPANESE:
-                pLangBoost = "jan";    // japanese is default
-                break;
-            case LANGUAGE_CHINESE:
-            case LANGUAGE_CHINESE_SIMPLIFIED:
-            case LANGUAGE_CHINESE_SINGAPORE:
-                pLangBoost = "zhs";
-                break;
-            case LANGUAGE_CHINESE_TRADITIONAL:
-            case LANGUAGE_CHINESE_HONGKONG:
-            case LANGUAGE_CHINESE_MACAU:
-                pLangBoost = "zht";
-                break;
-            case LANGUAGE_KOREAN:
-            case LANGUAGE_KOREAN_JOHAB:
-                pLangBoost = "kor";
-                break;
-        }
-
-        ::std::list< psp::fontID > aList;
-        const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-        rMgr.getFontList( aList, maGraphicsData.m_pJobData->m_pParser );
-
-        ::std::list< psp::fontID >::iterator it;
-        for (it = aList.begin(); it != aList.end(); ++it)
-        {
-            psp::FastPrintFontInfo aInfo;
-            if (rMgr.getFontFastInfo (*it, aInfo))
-            {
-                ImplFontData *pFontData = new ImplFontData;
-                SetImplFontData( aInfo, *pFontData );
-                pFontData->mpSysData = (void*)*it;
-                if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
-                    pFontData->maName = pFontData->maName.Copy( 4 );
-                if( aInfo.m_eType == psp::fonttype::TrueType )
-                {
-                    // prefer truetype fonts
-                    pFontData->mnQuality += 10;
-                    // asian type 1 fonts are not known
-                    ByteString aFileName( rMgr.getFontFileSysPath( *it ) );
-                    int nPos = aFileName.SearchBackward( '_' );
-                    if( nPos == STRING_NOTFOUND || aFileName.GetChar( nPos+1 ) == '.' )
-                        pFontData->mnQuality += 5;
-                    else
-                    {
-                        if( pLangBoost && aFileName.Copy( nPos+1, 3 ).EqualsIgnoreCaseAscii( pLangBoost ) )
-                            pFontData->mnQuality += 10;
-                    }
-                }
-                pList->Add( pFontData );
-            }
-        }
-    }
-    else
-#endif
-    {
-        XlfdStorage* pFonts = _GetDisplay()->GetXlfdList();
-
-        for ( int nIdx = 0; nIdx < pFonts->GetCount(); nIdx++ )
-        {
-            ImplFontData *pFontData = new ImplFontData;
+    XlfdStorage* pFonts = GetDisplay()->GetXlfdList();
+    
+    for ( int nIdx = 0; nIdx < pFonts->GetCount(); nIdx++ )
+    {
+        ImplFontData *pFontData = new ImplFontData;
+        pFonts->Get(nIdx)->ToImplFontData( pFontData );
+        if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
+            pFontData->maName = pFontData->maName.Copy( 4 );
+        pFontData->mbSubsettable    = FALSE;
+        pFontData->mbEmbeddable     = FALSE;
+        pList->Add( pFontData );
+    }
+    
+    aX11GlyphPeer.SetDisplay( GetXDisplay(),
+                              GetDisplay()->GetVisual()->GetVisual() );
 #ifdef MACOSX
-            // don't use bitmap X fonts on OS X
-            if ( pFonts->Get(nIdx)->GetFontType() != TYPE_RASTER )
-#endif
-            {
-                pFonts->Get(nIdx)->ToImplFontData( pFontData );
-                if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
-                    pFontData->maName = pFontData->maName.Copy( 4 );
-                pFontData->mbSubsettable    = FALSE;
-                pFontData->mbEmbeddable     = FALSE;
-                pList->Add( pFontData );
-            }
-        }
-
-#ifdef USE_BUILTIN_RASTERIZER
-        aX11GlyphPeer.SetDisplay( maGraphicsData.GetXDisplay(),
-            maGraphicsData.GetDisplay()->GetVisual()->GetVisual() );
-#ifdef MACOSX
-        GlyphCache::EnsureInstance( aX11GlyphPeer, true );
+    GlyphCache::EnsureInstance( aX11GlyphPeer, true );
 #else
-        GlyphCache::EnsureInstance( aX11GlyphPeer, false );
+    GlyphCache::EnsureInstance( aX11GlyphPeer, false );
 #endif
-        GlyphCache& rGC = GlyphCache::GetInstance();
-
-        const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-        ::std::list< psp::fontID > aList;
-        ::std::list< psp::fontID >::iterator it;
-        rMgr.getFontList( aList );
-        unicodeKernMap aKernTab;
-        for( it = aList.begin(); it != aList.end(); ++it )
+    GlyphCache& rGC = GlyphCache::GetInstance();
+    
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    ::std::list< psp::fontID > aList;
+    ::std::list< psp::fontID >::iterator it;
+    rMgr.getFontList( aList );
+    unicodeKernMap aKernTab;
+    for( it = aList.begin(); it != aList.end(); ++it )
+    {
+        psp::FastPrintFontInfo aInfo;
+        if( rMgr.getFontFastInfo( *it, aInfo ) )
         {
-            psp::FastPrintFontInfo aInfo;
-            if( rMgr.getFontFastInfo( *it, aInfo ) )
-            {
-                if( aInfo.m_eType == psp::fonttype::Builtin )
-                    continue;
-                ImplFontData aFontData;
-                SetImplFontData( aInfo, aFontData );
-                // prefer builtin_rasterizer fonts
-                aFontData.mnQuality += 4096;
-                // prefer truetype fonts
-                if( aInfo.m_eType == psp::fonttype::TrueType )
-                    aFontData.mnQuality += 1000;
-                int nFaceNum = rMgr.getFontFaceNumber( aInfo.m_nID );
-                if( aFontData.maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
-                    aFontData.maName = aFontData.maName.Copy( 4 );
-                if( nFaceNum < 0 )
-                    nFaceNum = 0;
+            if( aInfo.m_eType == psp::fonttype::Builtin )
+                continue;
+            ImplFontData aFontData;
+            PspGraphics::SetImplFontData( aInfo, aFontData );
+            // prefer builtin_rasterizer fonts
+            aFontData.mnQuality += 4096;
+            // prefer truetype fonts
+            if( aInfo.m_eType == psp::fonttype::TrueType )
+                aFontData.mnQuality += 1000;
+            int nFaceNum = rMgr.getFontFaceNumber( aInfo.m_nID );
+            if( aFontData.maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
+                aFontData.maName = aFontData.maName.Copy( 4 );
+            if( nFaceNum < 0 )
+                nFaceNum = 0;
+
             
-                const unicodeKernMap* pKernTab = NULL;
-                if( aInfo.m_eType == psp::fonttype::Type1 )
+            const unicodeKernMap* pKernTab = NULL;
+            if( aInfo.m_eType == psp::fonttype::Type1 )
+            {
+                const std::list< psp::KernPair >& rKernPairs = rMgr.getKernPairs( *it );
+                if( rKernPairs.size() )
                 {
-                    const std::list< psp::KernPair >& rKernPairs = rMgr.getKernPairs( *it );
-                    if( rKernPairs.size() )
-                    {
-                        aKernTab.clear();
-                        for( std::list< psp::KernPair >::const_iterator it = rKernPairs.begin();
-                             it != rKernPairs.end(); ++it )
-                            aKernTab[ it->first ][ it->second ] = it->kern_x;
-                        pKernTab = & aKernTab;
-                    }
+                    aKernTab.clear();
+                    for( std::list< psp::KernPair >::const_iterator it = rKernPairs.begin();
+                         it != rKernPairs.end(); ++it )
+                        aKernTab[ it->first ][ it->second ] = it->kern_x;
+                    pKernTab = & aKernTab;
                 }
-
-                rGC.AddFontFile( rMgr.getFontFileSysPath( aInfo.m_nID ), nFaceNum,
-                                 aInfo.m_nID, &aFontData, pKernTab );
             }
+            
+            // handling of alias names is done by GlyphCache::FetchFontList
+            rGC.AddFontFile( rMgr.getFontFileSysPath( aInfo.m_nID ), nFaceNum,
+                             aInfo.m_nID, &aFontData, pKernTab );
         }
-
-        rGC.FetchFontList( pList );
-#endif // USE_BUILTIN_RASTERIZER
     }
+    rGC.FetchFontList( pList );
 }
 
 // ----------------------------------------------------------------------------
 
-void SalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
+void X11SalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if( maGraphicsData.m_pPrinterGfx != NULL )
-    {
-        const psp::PrinterInfo& rInfo = psp::PrinterInfoManager::get().getPrinterInfo( maGraphicsData.m_pJobData->m_aPrinterName );
-        if( rInfo.m_bPerformFontSubstitution )
-        {
-            for( std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >::const_iterator it = rInfo.m_aFontSubstitutes.begin(); it != rInfo.m_aFontSubstitutes.end(); ++it )
-                pOutDev->ImplAddDevFontSubstitute( it->first, it->second, FONT_SUBSTITUTE_ALWAYS );
-        }
-    }
-#endif
 }
 
 // ----------------------------------------------------------------------------
@@ -1861,136 +1296,53 @@ sal_DivideNeg( long n1, long n2 )
 // ----------------------------------------------------------------------------
 
 void
-SalGraphics::GetFontMetric( ImplFontMetricData *pMetric )
+X11SalGraphics::GetFontMetric( ImplFontMetricData *pMetric )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-		psp::PrintFontInfo aInfo;
-
-		if (rMgr.getFontInfo (maGraphicsData.m_pPrinterGfx->GetFontID(), aInfo))
-		{
-			sal_Int32 nTextHeight	= maGraphicsData.m_pPrinterGfx->GetFontHeight();
-			sal_Int32 nTextWidth	= maGraphicsData.m_pPrinterGfx->GetFontWidth();
-			if( ! nTextWidth )
-				nTextWidth = nTextHeight;
-
-			pMetric->mnOrientation 	= maGraphicsData.m_pPrinterGfx->GetFontAngle();
-			pMetric->mnSlant		= 0;
-			pMetric->mbDevice		= aInfo.m_eType == psp::fonttype::Builtin ? sal_True : sal_False;
-
-			pMetric->meCharSet		= aInfo.m_aEncoding;
-
-			pMetric->meFamily		= ToFontFamily (aInfo.m_eFamilyStyle);
-			pMetric->meWeight		= ToFontWeight (aInfo.m_eWeight);
-			pMetric->mePitch		= ToFontPitch  (aInfo.m_ePitch);
-			pMetric->meItalic		= ToFontItalic (aInfo.m_eItalic);
-			pMetric->meType			= TYPE_SCALABLE;
-
-			pMetric->mnFirstChar	=   0;
-			pMetric->mnLastChar		= 255;
-
-			pMetric->mnWidth		= nTextWidth;
-			pMetric->mnAscent		= ( aInfo.m_nAscend * nTextHeight + 500 ) / 1000;
-			pMetric->mnDescent		= ( aInfo.m_nDescend * nTextHeight + 500 ) / 1000;
-			pMetric->mnLeading		= ( aInfo.m_nLeading * nTextHeight + 500 ) / 1000;
-		}
-        return;
-    }
-#endif
-
-    if( maGraphicsData.mpServerFont[0] != NULL )
+    if( mpServerFont[0] != NULL )
     {
         long rDummyFactor;
-        maGraphicsData.mpServerFont[0]->FetchFontMetric( *pMetric, rDummyFactor );
+        mpServerFont[0]->FetchFontMetric( *pMetric, rDummyFactor );
         return;
     }
 
-    ExtendedFontStruct* pFont = maGraphicsData.mXFont[0];
+    ExtendedFontStruct* pFont = mXFont[0];
     if( pFont != NULL )
     {
         pFont->ToImplFontMetricData( pMetric );
-        if ( maGraphicsData.bFontVertical_ )
+        if ( bFontVertical_ )
             pMetric->mnOrientation = 0;
     }
 }
 
 // ---------------------------------------------------------------------------
 
-static long
-InitializeWidthArray( long *pWidthArray, sal_Size nItems, int nValue = 0  )
-{
-    const long nPrecision = 1;
-
-    for ( int i = 0; i < nItems; i++, pWidthArray++ )
-        *pWidthArray = nValue;
-
-    return nPrecision;
-}
-
-// ---------------------------------------------------------------------------
-
-extern unsigned char TranslateCharName( char* );
-
 ULONG
-SalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData *pKernPairs )
+X11SalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData *pKernPairs )
 {
-    if( ! _IsPrinter() )
+    if( ! bPrinter_ )
     {
-        if( maGraphicsData.mpServerFont[0] != NULL )
+        if( mpServerFont[0] != NULL )
         {
             ImplKernPairData* pTmpKernPairs;
-            ULONG nGotPairs = maGraphicsData.mpServerFont[0]->GetKernPairs( &pTmpKernPairs );
+            ULONG nGotPairs = mpServerFont[0]->GetKernPairs( &pTmpKernPairs );
             for( int i = 0; i < nPairs && i < nGotPairs; ++i )
                 pKernPairs[ i ] = pTmpKernPairs[ i ];
             delete[] pTmpKernPairs;
             return nGotPairs;
         }
     }
-    else
-    {
-#ifndef _USE_PRINT_EXTENSION_
-		const ::std::list< ::psp::KernPair >& rPairs( maGraphicsData.m_pPrinterGfx->getKernPairs() );
-		ULONG nHavePairs = rPairs.size();
-		if( pKernPairs && nPairs )
-		{
-			::std::list< ::psp::KernPair >::const_iterator it;
-			int i;
-			int nTextScale = maGraphicsData.m_pPrinterGfx->GetFontWidth();
-			if( ! nTextScale )
-				nTextScale = maGraphicsData.m_pPrinterGfx->GetFontHeight();
-			for( i = 0, it = rPairs.begin(); i < nPairs && i < nHavePairs; i++, ++it )
-			{
-				pKernPairs[i].mnChar1	= it->first;
-				pKernPairs[i].mnChar2	= it->second;
-				pKernPairs[i].mnKern	= it->kern_x * nTextScale / 1000;
-			}
-
-		}
-		return nHavePairs;
-#endif
-	}
-
 	return 0;
 }
 
 // ---------------------------------------------------------------------------
 
-ULONG SalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
-{
-    return maGraphicsData.GetFontCodeRanges( pCodePairs );
-}
-
-// ---------------------------------------------------------------------------
-
-BOOL SalGraphics::GetGlyphBoundRect( long nGlyphIndex, Rectangle& rRect, const OutputDevice* )
+BOOL X11SalGraphics::GetGlyphBoundRect( long nGlyphIndex, Rectangle& rRect )
 {
     int nLevel = nGlyphIndex >> GF_FONTSHIFT;
     if( nLevel >= MAX_FALLBACK )
         return FALSE;
 
-    ServerFont* pSF = maGraphicsData.mpServerFont[ nLevel ];
+    ServerFont* pSF = mpServerFont[ nLevel ];
     if( !pSF )
         return FALSE;
 
@@ -2002,13 +1354,13 @@ BOOL SalGraphics::GetGlyphBoundRect( lon
 
 // ---------------------------------------------------------------------------
 
-BOOL SalGraphics::GetGlyphOutline( long nGlyphIndex, PolyPolygon& rPolyPoly, const OutputDevice* )
+BOOL X11SalGraphics::GetGlyphOutline( long nGlyphIndex, PolyPolygon& rPolyPoly )
 {
     int nLevel = nGlyphIndex >> GF_FONTSHIFT;
     if( nLevel >= MAX_FALLBACK )
         return FALSE;
 
-    ServerFont* pSF = maGraphicsData.mpServerFont[ nLevel ];
+    ServerFont* pSF = mpServerFont[ nLevel ];
     if( !pSF )
         return FALSE;
 
@@ -2021,29 +1373,13 @@ BOOL SalGraphics::GetGlyphOutline( long 
 
 //--------------------------------------------------------------------------
 
-SalLayout* SalGraphicsData::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
+SalLayout* X11SalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
 {
-#if !defined(_USE_PRINT_EXTENSION_)
-    // workaround for printers not handling glyph indexing for non-TT fonts
-    if( m_pPrinterGfx != NULL )
-    {
-        int nFontId = m_pPrinterGfx->GetFontID();
-        if( psp::fonttype::TrueType != psp::PrintFontManager::get().getFontType( nFontId ) )
-            rArgs.mnFlags |= SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
-        else if( nFallbackLevel > 0 )
-            rArgs.mnFlags &= ~SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
-    }
-#endif // !defined(_USE_PRINT_EXTENSION_)
-
     GenericSalLayout* pLayout = NULL;
 
     if( mpServerFont[ nFallbackLevel ]
     && !(rArgs.mnFlags & SAL_LAYOUT_DISABLE_GLYPH_PROCESSING) )
-        pLayout = m_pPrinterGfx ? new PspServerFontLayout( *m_pPrinterGfx, *mpServerFont[nFallbackLevel] ) : new ServerFontLayout( *mpServerFont[ nFallbackLevel ] );
-#if !defined(_USE_PRINT_EXTENSION_)
-    else if( m_pPrinterGfx != NULL )
-        pLayout = new PspFontLayout( *m_pPrinterGfx );
-#endif // !defined(_USE_PRINT_EXTENSION_)
+        pLayout = new ServerFontLayout( *mpServerFont[ nFallbackLevel ] );
     else if( mXFont[ nFallbackLevel ] )
         pLayout = new X11FontLayout( *mXFont[ nFallbackLevel ] );
     else
@@ -2054,18 +1390,10 @@ SalLayout* SalGraphicsData::GetTextLayou
 
 //--------------------------------------------------------------------------
 
-SalLayout* SalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
-{
-    SalLayout* pSalLayout = maGraphicsData.GetTextLayout( rArgs, nFallbackLevel );
-    return pSalLayout;
-}
-
-//--------------------------------------------------------------------------
-
-BOOL SalGraphics::CreateFontSubset(
+BOOL X11SalGraphics::CreateFontSubset(
                                    const rtl::OUString& rToFile,
                                    ImplFontData* pFont,
-                                   long* pGlyphIDs,
+                                   sal_Int32* pGlyphIDs,
                                    sal_uInt8* pEncoding,
                                    sal_Int32* pWidths,
                                    int nGlyphs,
@@ -2079,41 +1407,7 @@ BOOL SalGraphics::CreateFontSubset(
     // which this method was created). The correct way would
     // be to have the GlyphCache search for the ImplFontData pFont
     psp::fontID aFont = (psp::fontID)pFont->mpSysData;
-    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-
-    psp::PrintFontInfo aFontInfo;
-
-    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
-        return FALSE;
-
-    // fill in font info
-    switch( aFontInfo.m_eType )
-    {
-        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
-        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
-        default:
-            return FALSE;
-    }
-    rInfo.m_nAscent     = aFontInfo.m_nAscend;
-    rInfo.m_nDescent    = aFontInfo.m_nDescend;
-    rInfo.m_aPSName     = rMgr.getPSName( aFont );
-
-    int xMin, yMin, xMax, yMax;
-    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
-
-    if( ! rMgr.createFontSubset( aFont,
-                                 rToFile,
-                                 pGlyphIDs,
-                                 pEncoding,
-                                 pWidths,
-                                 nGlyphs
-                                 ) )
-        return FALSE;
-
-    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
-    rInfo.m_nCapHeight	= yMax; // Well ...
-
-    return TRUE;
+    return PspGraphics::DoCreateFontSubset( rToFile, aFont, pGlyphIDs, pEncoding, pWidths, nGlyphs, rInfo );
 #else
     return FALSE;
 #endif
@@ -2121,7 +1415,7 @@ BOOL SalGraphics::CreateFontSubset(
 
 //--------------------------------------------------------------------------
 
-const void* SalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+const void* X11SalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
 {
 #ifndef _USE_PRINT_EXTENSION_
     // in this context the sysdata member of pFont should
@@ -2130,61 +1424,7 @@ const void* SalGraphics::GetEmbedFontDat
     // which this method was created). The correct way would
     // be to have the GlyphCache search for the ImplFontData pFont
     psp::fontID aFont = (psp::fontID)pFont->mpSysData;
-    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-
-    psp::PrintFontInfo aFontInfo;
-    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
-        return NULL;
-
-    // fill in font info
-    switch( aFontInfo.m_eType )
-    {
-        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
-        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
-        default:
-            return NULL;
-    }
-    rInfo.m_nAscent		= aFontInfo.m_nAscend;
-    rInfo.m_nDescent	= aFontInfo.m_nDescend;
-    rInfo.m_aPSName		= rMgr.getPSName( aFont );
-
-    int xMin, yMin, xMax, yMax;
-    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
-
-    psp::CharacterMetric aMetrics[256];
-    sal_Unicode aUnicodes[256];
-    if( aFontInfo.m_aEncoding == RTL_TEXTENCODING_SYMBOL && aFontInfo.m_eType == psp::fonttype::Type1 )
-    {
-        for( int i = 0; i < 256; i++ )
-            aUnicodes[i] = pUnicodes[i] < 0x0100 ? pUnicodes[i] + 0xf000 : pUnicodes[i];
-        pUnicodes = aUnicodes;
-    }
-    if( ! rMgr.getMetrics( aFont, pUnicodes, 256, aMetrics ) )
-        return NULL;
-
-    OString aSysPath = rMgr.getFontFileSysPath( aFont );
-    struct stat aStat;
-    if( stat( aSysPath.getStr(), &aStat ) )
-        return NULL;
-    int fd = open( aSysPath.getStr(), O_RDONLY );
-    if( fd < 0 )
-        return NULL;
-    void* pFile = mmap( NULL, aStat.st_size, PROT_READ, MAP_SHARED, fd, 0 );
-    close( fd );
-    if( pFile == MAP_FAILED )
-        return NULL;
-
-    *pDataLen = aStat.st_size;
-
-    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
-    rInfo.m_nCapHeight	= yMax; // Well ...
-
-    for( int i = 0; i < 256; i++ )
-
-        pWidths[i] = (aMetrics[i].width > 0 ? aMetrics[i].width : 0);
-
-    return pFile;
-
+    return PspGraphics::DoGetEmbedFontData( aFont, pUnicodes, pWidths, rInfo, pDataLen );
 #else
     return NULL;
 #endif
@@ -2192,14 +1432,16 @@ const void* SalGraphics::GetEmbedFontDat
 
 //--------------------------------------------------------------------------
 
-void SalGraphics::FreeEmbedFontData( const void* pData, long nLen )
+void X11SalGraphics::FreeEmbedFontData( const void* pData, long nLen )
 {
-    munmap( (char*)pData, nLen );
+#ifndef _USE_PRINT_EXTENSION_
+    PspGraphics::DoFreeEmbedFontData( pData, nLen );
+#endif
 }
 
 //--------------------------------------------------------------------------
 
-const std::map< sal_Unicode, sal_Int32 >* SalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+const std::map< sal_Unicode, sal_Int32 >* X11SalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
 {
 #ifndef _USE_PRINT_EXTENSION_
     // in this context the sysdata member of pFont should
@@ -2208,17 +1450,7 @@ const std::map< sal_Unicode, sal_Int32 >
     // which this method was created). The correct way would
     // be to have the GlyphCache search for the ImplFontData pFont
     psp::fontID aFont = (psp::fontID)pFont->mpSysData;
-    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-
-    psp::PrintFontInfo aFontInfo;
-    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
-    {
-        if( pNonEncoded )
-            *pNonEncoded = NULL;
-        return NULL;
-    }
-
-    return rMgr.getEncodingMap( aFont, pNonEncoded );
+    return PspGraphics::DoGetFontEncodingVector( aFont, pNonEncoded );
 #else
     return NULL;
 #endif
Index: vcl/unx/source/gdi/salnativewidgets-kde.cxx
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vcl/unx/source/gdi/salnativewidgets-kde.cxx	2004-09-14 14:09:32.421280192 +0200
@@ -0,0 +1,1633 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *                  Jan Holesovsky <kendy@artax.karlin.mff.cuni.cz>
+ *                  Lukas Tinkl <lukas@kde.org>
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_KDE_CXX
+
+// Hack, but needed because of conflicting types...
+#define Region QtXRegion
+
+#include <qcheckbox.h>
+#include <qcombobox.h>
+#include <qframe.h>
+#include <qlineedit.h>
+#include <qlistview.h>
+#include <qpainter.h>
+#include <qpushbutton.h>
+#include <qradiobutton.h>
+#include <qrangecontrol.h>
+#include <qtabbar.h>
+#include <qtabwidget.h>
+#include <qwidget.h>
+
+#include <kaboutdata.h>
+#include <kapplication.h>
+#include <kcmdlineargs.h>
+#include <kconfig.h>
+#include <kglobal.h>
+#include <kmainwindow.h>
+#include <kmenubar.h>
+#include <kstyle.h>
+
+#undef Region
+
+#include <salunx.h>
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+
+#ifndef _SV_KDEINT_HXX
+#include <kdeint.hxx>
+#endif
+
+#ifndef _SV_SETTINGS_HXX
+#include <settings.hxx>
+#endif
+
+#include <iostream>
+
+using namespace ::rtl;
+
+/** Cached native widgets.
+ 
+    A class which caches and paints the native widgets.
+*/
+class WidgetPainter
+{
+    protected:
+	/** Cached push button.
+
+	    It is necessary for the QStyle::drawControl(). The buttons are created
+	    on demand and they are still hidden (no QWidget::show() is called).
+	*/
+	QPushButton  *m_pPushButton;
+
+	/** Cached radio button.
+
+	    @see m_pPushButton
+	*/
+	QRadioButton *m_pRadioButton;
+
+	/** Cached check box.
+
+	    @see m_pPushButton
+	*/
+	QCheckBox    *m_pCheckBox;
+
+	/** Cached combo box.
+
+	    @see m_pPushButton
+	*/
+	QComboBox    *m_pComboBox;
+
+	/** Cached editable combo box.
+
+	    Needed, because some styles do not like dynamic changes
+	    (QComboBox::setEditable()).
+
+	    @see m_pPushButton
+	*/
+	QComboBox    *m_pEditableComboBox;
+
+	/** Cached line edit box.
+
+	    @see m_pPushButton
+	*/
+	QLineEdit    *m_pLineEdit;
+
+	/** Cached spin box.
+
+	    @see m_pPushButton
+	*/
+	QSpinWidget  *m_pSpinWidget;
+
+	/** Cached spin box'es line edit.
+
+	    @see m_pPushButton
+	*/
+	QLineEdit    *m_pSpinEdit;
+
+	/** Cached tab.
+
+	    Left, middle, right tab and a tab which is alone.
+
+	    @see m_pPushButton
+	*/
+	QTab         *m_pTabLeft, *m_pTabMiddle, *m_pTabRight, *m_pTabAlone;
+
+	/** Cached tab bar's parent widget.
+
+	    Needed, because the Qt windows style checks for the availability
+	    of tab bar's parent. We cannot use m_pTabWidget, because
+	    TabWidget::setTabBar() and TabWidget::tabBar() methods are
+	    protected.
+
+	    @see m_pPushButton, m_pTabWidget
+	*/
+	QWidget      *m_pTabBarParent;
+
+	/** Cached tab bar widget.
+
+	    @see m_pPushButton
+	*/
+	QTabBar      *m_pTabBar;
+
+	/** Cached tab widget.
+
+	    We need it to draw the tab page. It cannot be used to draw the
+	    tabs themselves, because the drawing has to be tweaked a little
+	    due to not enough information from VCL.
+
+	    @see m_pPushButton, m_pTabBarParent
+	*/
+	QTabWidget   *m_pTabWidget;
+
+	/** Cached list view.
+
+	    @see m_pPushButton
+	*/
+	QListView    *m_pListView;
+
+	/** Cached scroll bar.
+
+	    @see m_pPushButton
+	*/
+	QScrollBar   *m_pScrollBar;
+
+	// TODO other widgets
+
+    public:
+	/** Implicit constructor.
+
+	    It creates an empty WidgetPainter with all the cached widgets initialized
+	    to NULL. The widgets are created on demand and they are still hidden
+	    (no QWidget::show()), because they are needed just as a parameter for
+	    QStyle::drawControl().
+
+	    @see m_pPushButton
+	*/
+	WidgetPainter( void );
+
+	/** Destructor.
+
+	    Destruct all the cached widgets.
+	*/
+	virtual ~WidgetPainter( void );
+
+	/** Paints the specified widget to the X window.
+
+	    Use X calls to bitblt (bit block transfer) the widget qWidget to
+	    the window specified by drawable with the style defined by nStyle.
+
+	    @param qWidget
+	    A pointer to the cached widget.
+
+	    @param nState
+	    The state of the control (focused, on/off, ...)
+
+	    @param aValue
+	    The value (true/false, ...)
+
+	    @param dpy
+	    The display to be used by the X calls.
+
+	    @param drawable
+	    The destination X window.
+
+	    @param gc
+	    The graphics context.
+	*/
+	BOOL drawStyledWidget( QWidget *pWidget,
+		ControlState nState, const ImplControlValue& aValue,
+		Display *dpy, XLIB_Window drawable, GC gc );
+
+	/** 'Get' method for push button.
+
+	    The method returns the cached push button. It is constructed if it
+	    does not exist. It has NULL as a parent and it stays hidden, but it
+	    is necessary for the drawStyledWidget() method.
+
+	    @return valid push button.
+	*/
+	QPushButton  *pushButton( const Region& rControlRegion, BOOL bDefault );
+
+	/** 'Get' method for radio button.
+
+	    @see pushButton()
+	*/
+	QRadioButton *radioButton( const Region& rControlRegion );
+
+	/** 'Get' method for check box.
+
+	    @see pushButton()
+	*/
+	QCheckBox    *checkBox( const Region& rControlRegion );
+
+	/** 'Get' method for combo box.
+
+	    It returns m_pComboBox or m_pEditableComboBox according to
+	    bEditable.
+
+	    @see pushButton(), m_pEditableComboBox
+	*/
+	QComboBox    *comboBox( const Region& rControlRegion, BOOL bEditable );
+
+	/** 'Get' method for line edit box.
+
+	    @see pushButton()
+	*/
+	QLineEdit    *lineEdit( const Region& rControlRegion );
+
+	/** 'Get' method for spin box.
+
+	    @see pushButton()
+	*/
+	QSpinWidget  *spinWidget( const Region& rControlRegion );
+
+	/** 'Get' method for tab bar.
+
+	    @see pushButton()
+	*/
+	QTabBar      *tabBar( const Region& rControlRegion );
+
+	/** 'Get' method for tab widget.
+
+	    @see pushButton()
+	*/
+	QTabWidget   *tabWidget( const Region& rControlRegion );
+
+	/** 'Get' method for list view.
+
+	    @see pushButton()
+	*/
+	QListView    *listView( const Region& rControlRegion );
+
+	/** 'Get' method for scroll bar.
+
+	    @see pushButton()
+	*/
+	QScrollBar   *scrollBar( const Region& rControlRegion,
+		BOOL bHorizontal, const ImplControlValue& aValue );
+
+	// TODO other widgets
+
+    protected:
+	/** Style conversion function.
+
+	    Conversion function between VCL ControlState together with
+	    ImplControlValue and Qt state flags.
+
+	    @param nState
+	    State of the widget (default, focused, ...) as defined in Native
+	    Widget Framework.
+
+	    @param aValue
+	    Value held by the widget (on, off, ...)
+	*/
+	QStyle::SFlags vclStateValue2SFlags( ControlState nState, const ImplControlValue& aValue );
+
+    public:
+	/** Convert VCL Region to QRect.
+
+	    @param rControlRegion
+	    The region to convert.
+
+	    @return
+	    The bounding box of the region.
+	*/
+	static QRect region2QRect( const Region& rControlRegion );
+};
+
+WidgetPainter::WidgetPainter( void )
+    : m_pPushButton( NULL ),
+      m_pRadioButton( NULL ),
+      m_pCheckBox( NULL ),
+      m_pComboBox( NULL ),
+      m_pEditableComboBox( NULL ),
+      m_pLineEdit( NULL ),
+      m_pSpinWidget( NULL ),
+      m_pSpinEdit( NULL ),
+      m_pTabLeft( NULL ),
+      m_pTabMiddle( NULL ),
+      m_pTabRight( NULL ),
+      m_pTabAlone( NULL ),
+      m_pTabBarParent( NULL ),
+      m_pTabBar( NULL ),
+      m_pTabWidget( NULL ),
+      m_pListView( NULL ),
+      m_pScrollBar( NULL )
+{
+}
+
+WidgetPainter::~WidgetPainter( void )
+{
+    delete m_pPushButton, m_pPushButton = NULL;
+    delete m_pRadioButton, m_pRadioButton = NULL;
+    delete m_pCheckBox, m_pCheckBox = NULL;
+    delete m_pComboBox, m_pComboBox = NULL;
+    delete m_pEditableComboBox, m_pEditableComboBox = NULL;
+    delete m_pLineEdit, m_pLineEdit = NULL;
+    delete m_pSpinWidget, m_pSpinWidget = NULL;
+    delete m_pSpinEdit, m_pSpinEdit = NULL;
+    delete m_pTabLeft, m_pTabLeft = NULL;
+    delete m_pTabMiddle, m_pTabMiddle = NULL;
+    delete m_pTabRight, m_pTabRight = NULL;
+    delete m_pTabAlone, m_pTabAlone = NULL;
+    delete m_pTabBarParent, m_pTabBarParent = NULL;
+    delete m_pTabBar, m_pTabBar = NULL;
+    delete m_pTabWidget, m_pTabWidget = NULL;
+    delete m_pListView, m_pListView = NULL;
+    delete m_pScrollBar, m_pScrollBar = NULL;
+}
+
+BOOL WidgetPainter::drawStyledWidget( QWidget *pWidget,
+	ControlState nState, const ImplControlValue& aValue,
+	Display *dpy, XLIB_Window drawable, GC gc )
+{
+    if ( !pWidget )
+	return FALSE;
+
+    // Normalize the widget
+    QPoint   qWidgetPos( pWidget->pos() );
+    pWidget->move( 0, 0 );
+
+    // Enable/disable the widget
+    pWidget->setEnabled( nState & CTRL_STATE_ENABLED );
+
+    // Create pixmap to paint to
+    QPixmap  qPixmap( pWidget->width(), pWidget->height() );
+    QPainter qPainter( &qPixmap );
+    QRect    qRect( 0, 0, pWidget->width(), pWidget->height() );
+
+    // Use the background of the widget
+    qPixmap.fill( pWidget, QPoint(0, 0) );
+    
+    // Convert the flags
+    QStyle::SFlags nStyle = vclStateValue2SFlags( nState, aValue );
+    
+    // Store the widget class
+    const char *pClassName = pWidget->className();
+    
+    // Draw the widget to the pixmap
+    if ( strcmp( "QPushButton", pClassName ) == 0 )
+    {
+	// Workaround for the Platinum style.
+	// Platinum takes the state directly from the widget, not from SFlags.
+	QPushButton *pPushButton = static_cast<QPushButton *>( pWidget->qt_cast( "QPushButton" ) );
+	if ( pPushButton )
+	{
+	    pPushButton->setDown   ( nStyle & QStyle::Style_Down );
+	    pPushButton->setOn     ( nStyle & QStyle::Style_On );
+	    pPushButton->setEnabled( nStyle & QStyle::Style_Enabled );
+	}
+	
+	kapp->style().drawControl( QStyle::CE_PushButton,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QRadioButton", pClassName ) == 0 )
+    {
+	// Bitblt from the screen, because the radio buttons are usually not
+	// rectangular, and there could be a bitmap under them
+	GC aTmpGC = XCreateGC( dpy, qPixmap.handle(), 0, NULL );
+	XCopyArea( dpy,
+		drawable, qPixmap.handle(),
+		aTmpGC,
+		qWidgetPos.x(), qWidgetPos.y(), qRect.width(), qRect.height(),
+		0, 0 );
+	XFreeGC( dpy, aTmpGC );
+
+	kapp->style().drawControl( QStyle::CE_RadioButton,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QCheckBox", pClassName ) == 0 )
+    {
+	kapp->style().drawControl( QStyle::CE_CheckBox,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QComboBox", pClassName ) == 0 )
+    {
+	kapp->style().drawComplexControl( QStyle::CC_ComboBox,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+	
+	// Editable combo box uses the background of the associated edit box
+	QComboBox *pComboBox = static_cast<QComboBox *>( pWidget->qt_cast( "QComboBox" ) );
+	if ( pComboBox && pComboBox->editable() && pComboBox->lineEdit() )
+	{
+	    QColorGroup::ColorRole eColorRole = ( pComboBox->isEnabled() )?
+		QColorGroup::Base: QColorGroup::Background;
+	    qPainter.fillRect( 
+		    kapp->style().querySubControlMetrics( QStyle::CC_ComboBox, 
+			pComboBox, QStyle::SC_ComboBoxEditField ),
+		    pComboBox->lineEdit()->colorGroup().brush( eColorRole ) );
+	}
+    }
+    else if ( strcmp( "QLineEdit", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_PanelLineEdit,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle | QStyle::Style_Sunken );
+    }
+    else if ( strcmp( "QSpinWidget", pClassName ) == 0 )
+    {
+	SpinbuttonValue *pValue = static_cast<SpinbuttonValue *> ( aValue.getOptionalVal() );
+	
+	// Is any of the buttons pressed?
+	QStyle::SCFlags eActive = QStyle::SC_None;
+	if ( pValue )
+	{
+	    if ( pValue->mnUpperState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_SpinWidgetUp;
+	    else if ( pValue->mnLowerState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_SpinWidgetDown;
+
+	    // Update the enable/disable state of the widget
+	    if ( ( nState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnUpperState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnLowerState & CTRL_STATE_ENABLED ) )
+	    {
+		pWidget->setEnabled( true );
+		nStyle |= QStyle::Style_Enabled;
+	    }
+	    else
+		pWidget->setEnabled( false );
+
+	    // Mouse-over effect
+	    if ( (pValue->mnUpperState & CTRL_STATE_ROLLOVER) ||
+		    (pValue->mnLowerState & CTRL_STATE_ROLLOVER) )
+		nStyle |= QStyle::Style_MouseOver;
+	}
+
+	// Spin widget uses the background of the associated edit box
+	QSpinWidget *pSpinWidget = static_cast<QSpinWidget *>( pWidget->qt_cast( "QSpinWidget" ) );
+	if ( pSpinWidget && pSpinWidget->editWidget() )
+	{
+	    QColorGroup::ColorRole eColorRole = ( pSpinWidget->isEnabled() )?
+		QColorGroup::Base: QColorGroup::Background;
+	    qPainter.fillRect( 
+		    kapp->style().querySubControlMetrics( QStyle::CC_SpinWidget, 
+			pSpinWidget, QStyle::SC_SpinWidgetEditField ),
+		    pSpinWidget->editWidget()->colorGroup().brush( eColorRole ) );
+	}
+
+	// Adjust the frame (needed for Motif Plus style)
+	QRect qFrameRect = kapp->style().querySubControlMetrics( QStyle::CC_SpinWidget,
+		pWidget, QStyle::SC_SpinWidgetFrame );
+	
+	kapp->style().drawComplexControl( QStyle::CC_SpinWidget,
+		&qPainter, pWidget, qFrameRect,
+		pWidget->colorGroup(), nStyle,
+		QStyle::SC_All, eActive );
+    }
+    else if ( strcmp( "QTabBar", pClassName ) == 0 )
+    {
+	TabitemValue *pValue = static_cast<TabitemValue *> ( aValue.getOptionalVal() );
+	
+	QTab *pTab = NULL;
+	if ( pValue )
+	{
+	    if ( ( pValue->isFirst() || pValue->isLeftAligned() ) && ( pValue->isLast() || pValue->isRightAligned() ) )
+		pTab = m_pTabAlone;
+	    else if ( pValue->isFirst() || pValue->isLeftAligned() )
+		pTab = m_pTabLeft;
+	    else if ( pValue->isLast() || pValue->isRightAligned() )
+		pTab = m_pTabRight;
+	    else
+		pTab = m_pTabMiddle;
+	}
+	if ( !pTab )
+	    return FALSE;
+	
+	pTab->setRect( qRect );
+	
+	kapp->style().drawControl( QStyle::CE_TabBarTab,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle,
+		QStyleOption( pTab ) );
+    }
+    else if ( strcmp( "QTabWidget", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_PanelTabWidget,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QListView", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_Panel,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle | QStyle::Style_Sunken );
+    }
+    else if ( strcmp( "QScrollBar", pClassName ) == 0 )
+    {
+	ScrollbarValue *pValue = static_cast<ScrollbarValue *> ( aValue.getOptionalVal() );
+
+	QStyle::SCFlags eActive = QStyle::SC_None;
+	if ( pValue )
+	{
+	    // Workaround for Style_MouseOver-aware themes.
+	    // Quite ugly, but I do not know about a better solution.
+	    const char *pStyleName = kapp->style().className();
+	    if ( strcmp( "QMotifPlusStyle", pStyleName ) == 0 )
+	    {
+		nStyle |= QStyle::Style_MouseOver;
+		if ( pValue->mnThumbState & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSlider;
+	    }
+	    else if ( strcmp( "QSGIStyle", pStyleName ) == 0 )
+	    {
+		nStyle |= QStyle::Style_MouseOver;
+		if ( pValue->mnButton1State & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSubLine;
+		else if ( pValue->mnButton2State & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarAddLine;
+		else if ( pValue->mnThumbState & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSlider;
+	    }
+
+	    if ( pValue->mnButton1State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSubLine;
+	    else if ( pValue->mnButton2State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarAddLine;
+	    else if ( pValue->mnThumbState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSlider;
+	    else if ( pValue->mnPage1State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSubPage;
+	    else if ( pValue->mnPage2State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarAddPage;
+
+	    // Update the enable/disable state of the widget
+	    if ( ( nState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnButton1State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnButton2State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnThumbState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnPage1State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnPage2State & CTRL_STATE_ENABLED ) )
+	    {
+		pWidget->setEnabled( true );
+		nStyle |= QStyle::Style_Enabled;
+	    }
+	    else
+		pWidget->setEnabled( false );
+	}
+	
+	// Is it a horizontal scroll bar?
+	QScrollBar *pScrollBar = static_cast<QScrollBar *> ( pWidget->qt_cast( "QScrollBar" ) );
+	QStyle::StyleFlags eHoriz = QStyle::Style_Default;
+	if ( pScrollBar && pScrollBar->orientation() == Qt::Horizontal )
+	    eHoriz = QStyle::Style_Horizontal;
+
+	kapp->style().drawComplexControl( QStyle::CC_ScrollBar,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle | eHoriz,
+		QStyle::SC_All, eActive );
+    }
+    else
+	return FALSE;
+
+    // Bitblt it to the screen
+    XCopyArea( dpy,
+	       qPixmap.handle(), drawable,
+	       gc,
+	       0, 0, qRect.width(), qRect.height(),
+	       qWidgetPos.x(), qWidgetPos.y() );
+
+    // Restore widget's position
+    pWidget->move( qWidgetPos );
+
+    return TRUE;
+}
+
+QPushButton *WidgetPainter::pushButton( const Region& rControlRegion,
+	BOOL bDefault )
+{
+    if ( !m_pPushButton )
+	m_pPushButton = new QPushButton( NULL, "push_button" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken styles which do not add
+    // QStyle::PM_ButtonDefaultIndicator to the size of the default button
+    // (for example Keramik)
+    // FIXME Fix Keramik style to be consistant with Qt built-in styles. Aargh!
+    if ( bDefault )
+    {
+	QSize qContentsSize( 50, 50 );
+	m_pPushButton->setDefault( false );
+	QSize qNormalSize = kapp->style().sizeFromContents( QStyle::CT_PushButton,
+		m_pPushButton, qContentsSize );
+	m_pPushButton->setDefault( true );
+	QSize qDefSize = kapp->style().sizeFromContents( QStyle::CT_PushButton,
+		m_pPushButton, qContentsSize );
+	
+	int nIndicatorSize = kapp->style().pixelMetric(
+		QStyle::PM_ButtonDefaultIndicator, m_pPushButton );
+	if ( qNormalSize.width() == qDefSize.width() )
+	    qRect.addCoords( nIndicatorSize, 0, -nIndicatorSize, 0 );
+	if ( qNormalSize.height() == qDefSize.height() )
+	    qRect.addCoords( 0, nIndicatorSize, 0, -nIndicatorSize );
+    }
+    
+    m_pPushButton->move( qRect.topLeft() );
+    m_pPushButton->resize( qRect.size() );
+    m_pPushButton->setDefault( bDefault );
+
+    return m_pPushButton;
+}
+
+QRadioButton *WidgetPainter::radioButton( const Region& rControlRegion )
+{
+    if ( !m_pRadioButton )
+	m_pRadioButton = new QRadioButton( NULL, "radio_button" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken themes which do not honor the given size.
+    // Quite ugly, but I do not know about a better solution.
+    const char *pStyleName = kapp->style().className();
+    if ( strcmp( "KThemeStyle", pStyleName ) == 0 )
+    {
+	QRect qOldRect( qRect );
+	
+	qRect.setWidth( kapp->style().pixelMetric(
+		QStyle::PM_ExclusiveIndicatorWidth, m_pRadioButton ) );
+	qRect.setHeight( kapp->style().pixelMetric(
+		QStyle::PM_ExclusiveIndicatorHeight, m_pRadioButton ) );
+	
+	qRect.moveBy( ( qOldRect.width() - qRect.width() ) / 2,
+		( qOldRect.height() - qRect.height() ) / 2 );
+    }
+
+    m_pRadioButton->move( qRect.topLeft() );
+    m_pRadioButton->resize( qRect.size() );
+    
+    return m_pRadioButton;
+}
+
+QCheckBox *WidgetPainter::checkBox( const Region& rControlRegion )
+{
+    if ( !m_pCheckBox )
+	m_pCheckBox = new QCheckBox( NULL, "check_box" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken themes which do not honor the given size.
+    // Quite ugly, but I do not know about a better solution.
+    const char *pStyleName = kapp->style().className();
+    if ( strcmp( "KThemeStyle", pStyleName ) == 0 )
+    {
+	QRect qOldRect( qRect );
+	
+	qRect.setWidth( kapp->style().pixelMetric(
+		QStyle::PM_IndicatorWidth, m_pCheckBox ) );
+	qRect.setHeight( kapp->style().pixelMetric(
+		QStyle::PM_IndicatorHeight, m_pCheckBox ) );
+	
+	qRect.moveBy( ( qOldRect.width() - qRect.width() ) / 2,
+		( qOldRect.height() - qRect.height() ) / 2 );
+    }
+
+    m_pCheckBox->move( qRect.topLeft() );
+    m_pCheckBox->resize( qRect.size() );
+
+    return m_pCheckBox;
+}
+
+QComboBox *WidgetPainter::comboBox( const Region& rControlRegion,
+	BOOL bEditable )
+{
+    QComboBox *pComboBox = NULL;
+    if ( bEditable )
+    {
+	if ( !m_pEditableComboBox )
+	    m_pEditableComboBox = new QComboBox( true, NULL, "combo_box_edit" );
+	pComboBox = m_pEditableComboBox;
+    }
+    else
+    {
+	if ( !m_pComboBox )
+	    m_pComboBox = new QComboBox( false, NULL, "combo_box" );
+	pComboBox = m_pComboBox;
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    pComboBox->move( qRect.topLeft() );
+    pComboBox->resize( qRect.size() );
+
+    return pComboBox;
+}
+
+QLineEdit *WidgetPainter::lineEdit( const Region& rControlRegion )
+{
+    if ( !m_pLineEdit )
+	m_pLineEdit = new QLineEdit( NULL, "line_edit" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pLineEdit->move( qRect.topLeft() );
+    m_pLineEdit->resize( qRect.size() );
+
+    return m_pLineEdit;
+}
+
+QSpinWidget *WidgetPainter::spinWidget( const Region& rControlRegion )
+{
+    if ( !m_pSpinWidget )
+    {
+	m_pSpinWidget = new QSpinWidget( NULL, "spin_widget" );
+	
+	m_pSpinEdit = new QLineEdit( NULL, "line_edit_spin" );
+	m_pSpinWidget->setEditWidget( m_pSpinEdit );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pSpinWidget->move( qRect.topLeft() );
+    m_pSpinWidget->resize( qRect.size() );
+    m_pSpinWidget->arrange();
+
+    return m_pSpinWidget;
+}
+
+QTabBar *WidgetPainter::tabBar( const Region& rControlRegion )
+{
+    if ( !m_pTabBar )
+    {
+	if ( !m_pTabBarParent )
+	    m_pTabBarParent = new QWidget( NULL, "tab_bar_parent" );
+
+	m_pTabBar = new QTabBar( m_pTabBarParent, "tab_bar" );
+	
+	m_pTabLeft = new QTab();
+	m_pTabMiddle = new QTab();
+	m_pTabRight = new QTab();
+	m_pTabAlone = new QTab();
+
+	m_pTabBar->addTab( m_pTabLeft );
+	m_pTabBar->addTab( m_pTabMiddle );
+	m_pTabBar->addTab( m_pTabRight );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    m_pTabBar->move( qRect.topLeft() );
+    m_pTabBar->resize( qRect.size() );
+    
+    m_pTabBar->setShape( QTabBar::RoundedAbove );
+
+    return m_pTabBar;
+}
+
+QTabWidget *WidgetPainter::tabWidget( const Region& rControlRegion )
+{
+    if ( !m_pTabWidget )
+	m_pTabWidget = new QTabWidget( NULL, "tab_widget" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    --qRect.rTop();
+    
+    m_pTabWidget->move( qRect.topLeft() );
+    m_pTabWidget->resize( qRect.size() );
+    
+    return m_pTabWidget;
+}
+
+QListView *WidgetPainter::listView( const Region& rControlRegion )
+{
+    if ( !m_pListView )
+	m_pListView = new QListView( NULL, "list_view" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pListView->move( qRect.topLeft() );
+    m_pListView->resize( qRect.size() );
+
+    return m_pListView;
+}
+
+QScrollBar *WidgetPainter::scrollBar( const Region& rControlRegion,
+	BOOL bHorizontal, const ImplControlValue& aValue )
+{
+    if ( !m_pScrollBar )
+    {
+	m_pScrollBar = new QScrollBar( NULL, "scroll_bar" );
+	m_pScrollBar->setTracking( false );
+	m_pScrollBar->setLineStep( 1 );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pScrollBar->move( qRect.topLeft() );
+    m_pScrollBar->resize( qRect.size() );
+    m_pScrollBar->setOrientation( bHorizontal? Qt::Horizontal: Qt::Vertical );
+
+    ScrollbarValue *pValue = static_cast<ScrollbarValue *> ( aValue.getOptionalVal() );
+    if ( pValue )
+    {
+	m_pScrollBar->setMinValue( pValue->mnMin );
+	m_pScrollBar->setMaxValue( pValue->mnMax - pValue->mnVisibleSize );
+	m_pScrollBar->setValue( pValue->mnCur );
+	m_pScrollBar->setPageStep( pValue->mnVisibleSize );
+    }
+
+    return m_pScrollBar;
+}
+
+QStyle::SFlags WidgetPainter::vclStateValue2SFlags( ControlState nState,
+	const ImplControlValue& aValue )
+{
+    QStyle::SFlags nStyle =
+	( (nState & CTRL_STATE_DEFAULT)?  QStyle::Style_ButtonDefault: QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_ENABLED)?  QStyle::Style_Enabled:       QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_FOCUSED)?  QStyle::Style_HasFocus:      QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_PRESSED)?  QStyle::Style_Down:          QStyle::Style_Raised )  |
+	( (nState & CTRL_STATE_SELECTED)? QStyle::Style_Selected :     QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_ROLLOVER)? QStyle::Style_MouseOver:     QStyle::Style_Default );
+	//TODO ( (nState & CTRL_STATE_HIDDEN)?   QStyle::Style_: QStyle::Style_Default ) |
+
+    switch ( aValue.getTristateVal() )
+    {
+	case BUTTONVALUE_ON:    nStyle |= QStyle::Style_On;       break;
+	case BUTTONVALUE_OFF:   nStyle |= QStyle::Style_Off;      break;
+	case BUTTONVALUE_MIXED: nStyle |= QStyle::Style_NoChange; break;
+    }
+
+    return nStyle;
+}
+
+QRect WidgetPainter::region2QRect( const Region& rControlRegion )
+{
+    Rectangle aRect = rControlRegion.GetBoundRect();
+
+    return QRect( QPoint( aRect.Left(), aRect.Top() ),
+		  QPoint( aRect.Right(), aRect.Bottom() ) );
+}
+
+/** Instance of WidgetPainter.
+
+    It is used to paint the widgets requested by NWF.
+*/
+static WidgetPainter widgetPainter;
+
+
+/** Initialization of KDE and local stuff.
+
+    It creates an instance of KApplication.
+*/
+void VCLInitNativeWidgets( void )
+{
+    KAboutData *kAboutData = new KAboutData( "OpenOffice.org",
+	    I18N_NOOP( "OpenOffice.org" ),
+	    "1.1.0",
+	    I18N_NOOP( "OpenOffice.org with KDE Native Widget Support." ),
+	    KAboutData::License_LGPL,
+	    "(c) 2003, Jan Holesovsky",
+	    I18N_NOOP( "OpenOffice.org is an office suite.\n" ),
+	    "http://kde.openoffice.org/index.html",
+	    "dev@kde.openoffice.org");
+    kAboutData->addAuthor( "Jan Holesovsky",
+	    I18N_NOOP( "Original author and maintainer of the KDE NWF." ),
+	    "kendy@artax.karlin.mff.cuni.cz",
+	    "http://artax.karlin.mff.cuni.cz/~kendy" );
+
+    // We ignore the arguments, KApplication has to be initialized according
+    // to the OOo's display.
+    int argc = 0;
+    char *argv[20] = { "soffice.bin", 0 };
+    KCmdLineArgs::init( argc, argv, kAboutData );
+
+    // Get display
+    SalDisplay *pSalDisplay = GetSalData()->GetCurDisp();
+    if ( !pSalDisplay )
+	::std::cerr << "Cannot get current display!" << ::std::endl;
+    else
+	new KApplication( pSalDisplay->GetDisplay(), argc, argv, "soffice.bin" );
+}
+
+/** Release KDE and local stuff
+
+    No operation for KDE.
+*/
+void VCLDeinitNativeWidgets( void )
+{
+}
+
+/** What widgets can be drawn the native way.
+
+    @param nType
+    Type of the widget.
+    
+    @param nPart
+    Specification of the widget's part if it consists of more than one.
+  
+    @return TRUE if the platform supports native drawing of the widget nType
+    defined by nPart.
+*/
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    return
+	( (nType == CTRL_PUSHBUTTON)  && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_RADIOBUTTON) && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_CHECKBOX)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_COMBOBOX)    && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	( (nType == CTRL_EDITBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	( (nType == CTRL_LISTBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW) ) ||
+	( (nType == CTRL_SPINBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	// no CTRL_SPINBUTTONS for KDE
+	( (nType == CTRL_TAB_ITEM)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_TAB_PANE)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	// no CTRL_TAB_BODY for KDE
+	( (nType == CTRL_SCROLLBAR)   && (nPart == PART_ENTIRE_CONTROL || nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT) ) ||
+	( (nType == CTRL_SCROLLBAR)   && (nPart == HAS_THREE_BUTTONS) ); // TODO small optimization is possible here: return this only if the style really has 3 buttons
+	// CTRL_GROUPBOX not supported
+	// CTRL_FIXEDLINE not supported
+	// CTRL_FIXEDBORDER not supported
+}
+
+
+/** Test whether the position is in the native widget.
+
+    If the return value is TRUE, bIsInside contains information whether
+    aPos was or was not inside the native widget specified by the
+    nType/nPart combination.
+*/
+BOOL SalGraphics::HitTestNativeControl( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, const Point& aPos,
+	SalControlHandle& rControlHandle, BOOL& rIsInside,
+	const OutputDevice* )
+{
+    if ( nType == CTRL_SCROLLBAR )
+    {
+	rIsInside = FALSE;
+
+	BOOL bHorizontal = ( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT );
+	
+	QScrollBar *pScrollBar = widgetPainter.scrollBar( rControlRegion,
+		bHorizontal, ImplControlValue() );
+	QRect qRectSubLine = kapp->style().querySubControlMetrics(
+		QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubLine );
+	QRect qRectAddLine = kapp->style().querySubControlMetrics(
+		QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarAddLine );
+
+	// There are 2 buttons on the right/bottom side of the scrollbar
+	BOOL bTwoSubButtons = FALSE;
+
+	// It is a Platinum style scroll bar
+	BOOL bPlatinumStyle = FALSE;
+
+	// Workaround for Platinum and 3 button style scroll bars.
+	// It makes the right/down button bigger.
+	if ( bHorizontal )
+	{
+	    qRectAddLine.setLeft( kapp->style().querySubControlMetrics(
+			QStyle::CC_ScrollBar, pScrollBar,
+			QStyle::SC_ScrollBarAddPage ).right() + 1 );
+	    if ( qRectAddLine.width() > qRectSubLine.width() )
+		bTwoSubButtons = TRUE;
+	    if ( qRectSubLine.left() > kapp->style().querySubControlMetrics( QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubPage ).left() )
+		bPlatinumStyle = TRUE;
+	}
+	else
+	{
+	    qRectAddLine.setTop( kapp->style().querySubControlMetrics(
+			QStyle::CC_ScrollBar, pScrollBar,
+			QStyle::SC_ScrollBarAddPage ).bottom() + 1 );
+	    if ( qRectAddLine.height() > qRectSubLine.height() )
+		bTwoSubButtons = TRUE;
+	    if ( qRectSubLine.top() > kapp->style().querySubControlMetrics( QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubPage ).top() )
+		bPlatinumStyle = TRUE;
+	}
+
+	switch ( nPart )
+	{
+	    case PART_BUTTON_LEFT:
+		if ( !bPlatinumStyle && qRectSubLine.contains( aPos.getX(), aPos.getY() ) )
+		    rIsInside = TRUE;
+		else if ( bTwoSubButtons )
+		{
+		    qRectAddLine.setWidth( qRectAddLine.width() / 2 );
+		    rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		}
+		break;
+		
+	    case PART_BUTTON_UP:
+		if ( !bPlatinumStyle && qRectSubLine.contains( aPos.getX(), aPos.getY() ) )
+		    rIsInside = TRUE;
+		else if ( bTwoSubButtons )
+		{
+		    qRectAddLine.setHeight( qRectAddLine.height() / 2 );
+		    rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		}
+		break;
+		
+	    case PART_BUTTON_RIGHT:
+		if ( bTwoSubButtons )
+		    qRectAddLine.setLeft( qRectAddLine.left() + qRectAddLine.width() / 2 );
+
+		rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		break;
+		
+	    case PART_BUTTON_DOWN:
+		if ( bTwoSubButtons )
+		    qRectAddLine.setTop( qRectAddLine.top() + qRectAddLine.height() / 2 );
+
+		rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		break;
+	}
+
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+/** Draw the requested control described by nPart/nState.
+ 
+    @param rControlRegion
+    The bounding region of the complete control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string).
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::DrawNativeControl( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption, const OutputDevice* )
+{
+    BOOL bReturn = FALSE;
+
+    Display *dpy = maGraphicsData.GetXDisplay();
+    XLIB_Window drawable = maGraphicsData.GetDrawable();
+    GC gc = maGraphicsData.SelectFont(); // GC with current clipping region set
+	
+    if ( (nType == CTRL_PUSHBUTTON) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.pushButton( rControlRegion, (nState & CTRL_STATE_DEFAULT) ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_RADIOBUTTON) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.radioButton( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_CHECKBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.checkBox( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_COMBOBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.comboBox( rControlRegion, TRUE ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_EDITBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.lineEdit( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_LISTBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.comboBox( rControlRegion, FALSE ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_LISTBOX) && (nPart == PART_WINDOW) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.listView( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_SPINBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.spinWidget( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType==CTRL_TAB_ITEM) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.tabBar( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType==CTRL_TAB_PANE) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.tabWidget( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_SCROLLBAR) && (nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.scrollBar( rControlRegion, nPart == PART_DRAW_BACKGROUND_HORZ, aValue ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+
+    return bReturn;
+}
+
+
+/** Draw text on the widget.
+ 
+    OPTIONAL. Draws the requested text for the control described by nPart/nState.
+    Used if text is not drawn by DrawNativeControl().
+ 
+    @param rControlRegion
+    The bounding region of the complete control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string)
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::DrawNativeControlText( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption, const OutputDevice* )
+{
+    return FALSE;
+}
+
+/** Check if the bounding regions match.
+
+    If the return value is TRUE, rNativeBoundingRegion
+    contains the true bounding region covered by the control
+    including any adornment, while rNativeContentRegion contains the area
+    within the control that can be safely drawn into without drawing over
+    the borders of the control.
+
+    @param rControlRegion
+    The bounding region of the control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string)
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::GetNativeControlRegion( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption,
+	Region &rNativeBoundingRegion, Region &rNativeContentRegion,
+	const OutputDevice* )
+{
+    BOOL bReturn = FALSE;
+    QRect qBoundingRect = WidgetPainter::region2QRect( rControlRegion );
+    QRect qRect;
+    
+    QWidget *pWidget = NULL;
+    switch ( nType )
+    {
+	// Metrics of the push button
+	case CTRL_PUSHBUTTON:
+	    pWidget = widgetPainter.pushButton( rControlRegion, ( nState & CTRL_STATE_DEFAULT ) );
+
+	    switch ( nPart )
+	    {
+		case PART_ENTIRE_CONTROL:
+		    qRect = qBoundingRect;
+
+		    if ( nState & CTRL_STATE_DEFAULT )
+		    {
+			int nIndicatorSize = kapp->style().pixelMetric(
+				QStyle::PM_ButtonDefaultIndicator, pWidget );
+			qBoundingRect.addCoords( -nIndicatorSize, -nIndicatorSize,
+				nIndicatorSize, nIndicatorSize );
+			bReturn = TRUE;
+		    }
+		    break;
+	    }
+	    break;
+
+	// Metrics of the combo box
+	case CTRL_COMBOBOX:
+	case CTRL_LISTBOX:
+	    pWidget = widgetPainter.comboBox( rControlRegion, ( nType == CTRL_COMBOBOX ) );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget, QStyle::SC_ComboBoxArrow );
+		    qRect.setLeft( kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget,
+			    QStyle::SC_ComboBoxEditField ).right() + 1 );
+		    bReturn = TRUE;
+		    break;
+
+		case PART_SUB_EDIT:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget, QStyle::SC_ComboBoxEditField );
+		    bReturn = TRUE;
+		    break;
+	    }
+	    break;
+
+	// Metrics of the spin box
+	case CTRL_SPINBOX:
+	    pWidget = widgetPainter.spinWidget( rControlRegion );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_UP:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_SpinWidget, pWidget, QStyle::SC_SpinWidgetUp );
+		    bReturn = TRUE;
+		    break;
+
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_SpinWidget, pWidget, QStyle::SC_SpinWidgetDown );
+		    bReturn = TRUE;
+		    break;
+	    }
+	    break;
+
+	// Metrics of the scroll bar
+	case CTRL_SCROLLBAR:
+	    pWidget = widgetPainter.scrollBar( rControlRegion,
+		    ( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT ),
+		    ImplControlValue() );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_LEFT:
+		case PART_BUTTON_UP:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ScrollBar, pWidget, QStyle::SC_ScrollBarSubLine );
+
+		    // Workaround for Platinum style scroll bars. It makes the
+		    // left/up button invisible.
+		    if ( nPart == PART_BUTTON_LEFT )
+		    {
+			if ( qRect.left() > kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarSubPage ).left() )
+			{
+			    qRect.setLeft( 0 );
+			    qRect.setRight( 0 );
+			}
+		    }
+		    else
+		    {
+			if ( qRect.top() > kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarSubPage ).top() )
+			{
+			    qRect.setTop( 0 );
+			    qRect.setBottom( 0 );
+			}
+		    }
+
+		    bReturn = TRUE;
+		    break;
+
+		case PART_BUTTON_RIGHT:
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ScrollBar, pWidget, QStyle::SC_ScrollBarAddLine );
+
+		    // Workaround for Platinum and 3 button style scroll bars.
+		    // It makes the right/down button bigger.
+		    if ( nPart == PART_BUTTON_RIGHT )
+			qRect.setLeft( kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarAddPage ).right() + 1 );
+		    else
+			qRect.setTop( kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarAddPage ).bottom() + 1 );
+
+		    bReturn = TRUE;
+		    break;
+	    }
+    }
+
+    // Fill rNativeBoundingRegion and rNativeContentRegion
+    if ( bReturn )
+    {
+	// Bounding region
+	Point aBPoint( qBoundingRect.x(), qBoundingRect.y() );
+	Size aBSize( qBoundingRect.width(), qBoundingRect.height() );
+	rNativeBoundingRegion = Region( Rectangle( aBPoint, aBSize ) );
+
+	// Region of the content
+	Point aPoint( qRect.x(), qRect.y() );
+	Size  aSize( qRect.width(), qRect.height() );
+	rNativeContentRegion = Region( Rectangle( aPoint, aSize ) );
+    }
+    
+    return bReturn;
+}
+
+/** Constructor.
+*/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+/** Destructor.
+*/
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+// -----------------------------------------------------------------------
+// KDEIntegrator implementation
+// -----------------------------------------------------------------------
+
+/** Constructor of the KDE integrator.
+*/
+KDEIntegrator::KDEIntegrator( SalFrame* pFrame ) :
+    DtIntegrator( pFrame )
+{
+    meType = DtKDE;
+}
+
+/** Destructor of the KDE integrator.
+*/
+KDEIntegrator::~KDEIntegrator()
+{
+}
+
+/** Helper function to convert colors.
+*/
+Color toColor( const QColor &rColor )
+{
+    return Color( rColor.red(), rColor.green(), rColor.blue() );
+}
+
+/** Helper function to read color from KConfig configuration repository.
+*/
+Color readColor( KConfig *pConfig, const char *pKey )
+{
+    return toColor( pConfig->readColorEntry( pKey ) );
+}
+
+/** Helper function to add information to Font from QFont.
+*/
+void modifyFont( Font &rFont, const QFont &rQFont )
+{
+    QFontInfo qFontInfo( rQFont );
+    
+    rFont.SetName( String( qFontInfo.family().utf8(), RTL_TEXTENCODING_UTF8 ) );
+    
+    // Do not set the height, it does not look good
+    // rFont.SetHeight( qFontInfo.pointSize() );
+    
+    rFont.SetItalic( qFontInfo.italic()? ITALIC_NORMAL: ITALIC_NONE );
+    
+    FontWeight eWeight = WEIGHT_DONTKNOW;
+    int nWeight = qFontInfo.weight();
+    if ( nWeight <= QFont::Light )
+        eWeight = WEIGHT_LIGHT;
+    else if ( nWeight <= QFont::Normal )
+        eWeight = WEIGHT_NORMAL;
+    else if ( nWeight <= QFont::DemiBold )
+        eWeight = WEIGHT_SEMIBOLD;
+    else if ( nWeight <= QFont::Bold )
+        eWeight = WEIGHT_BOLD;
+    else
+        eWeight = WEIGHT_BLACK;
+    rFont.SetWeight( eWeight );
+}
+
+/** Implementation of KDE integration's main method.
+*/
+void KDEIntegrator::GetSystemLook( AllSettings& rSettings )
+{
+    StyleSettings aStyleSettings( rSettings.GetStyleSettings() );
+
+    // WM settings
+    KConfig *pConfig = KGlobal::config();
+    if ( pConfig )
+    {
+        pConfig->setGroup( "WM" );
+        const char *pKey;
+
+        pKey = "activeBackground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveColor( readColor( pConfig, pKey ) );
+
+        pKey = "activeBlend";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveColor2( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveBackground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveColor( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveBlend";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveColor2( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveForeground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveTextColor( readColor( pConfig, pKey ) );
+
+        pKey = "activeForeground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveTextColor( readColor( pConfig, pKey ) );
+
+        pKey = "titleFont";
+        if ( pConfig->hasKey( pKey ) )
+        {
+            Font aFont= aStyleSettings.GetTitleFont();
+            modifyFont( aFont, pConfig->readFontEntry( pKey ) );
+            aStyleSettings.SetTitleFont( aFont );
+        }
+    }
+
+    // General settings
+    QColorGroup qColorGroup = kapp->palette().active();
+    
+    // Foreground
+    Color aFore = toColor( qColorGroup.foreground() );
+    aStyleSettings.SetRadioCheckTextColor( aFore );
+    aStyleSettings.SetLabelTextColor( aFore );
+    aStyleSettings.SetInfoTextColor( aFore );
+    aStyleSettings.SetDialogTextColor( aFore );
+    aStyleSettings.SetGroupTextColor( aFore );
+
+    // Input boxes, list boxes
+    aStyleSettings.SetFieldColor( toColor( qColorGroup.base() ) );
+    aStyleSettings.SetFieldTextColor( toColor( qColorGroup.text() ) );
+    
+    // Buttons
+    aStyleSettings.SetButtonTextColor( toColor( qColorGroup.buttonText() ) );
+
+    // Disable color
+    aStyleSettings.SetDisableColor( toColor( qColorGroup.mid() ) );
+
+    // Background
+    Color aBack = toColor( qColorGroup.background() );
+    aStyleSettings.Set3DColors( aBack );
+    aStyleSettings.SetFaceColor( aBack );
+    aStyleSettings.SetDialogColor( aBack );
+    if( aBack == COL_LIGHTGRAY )
+        aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
+    else
+    {
+        Color aColor2 = aStyleSettings.GetLightColor();
+        aStyleSettings.
+            SetCheckedColor( Color( (BYTE)(((USHORT)aBack.GetRed()+(USHORT)aColor2.GetRed())/2),
+                        (BYTE)(((USHORT)aBack.GetGreen()+(USHORT)aColor2.GetGreen())/2),
+                        (BYTE)(((USHORT)aBack.GetBlue()+(USHORT)aColor2.GetBlue())/2)
+                        ) );
+    }
+
+    // Selection
+    aStyleSettings.SetHighlightColor( toColor( qColorGroup.highlight() ) );
+    aStyleSettings.SetHighlightTextColor( toColor( qColorGroup.highlightedText() ) );
+
+    // Font
+    Font aFont= aStyleSettings.GetAppFont();
+    modifyFont( aFont, kapp->font() );
+
+    aStyleSettings.SetAppFont( aFont );
+    aStyleSettings.SetHelpFont( aFont );
+    aStyleSettings.SetMenuFont( aFont ); // will be changed according to pMenuBar
+    aStyleSettings.SetToolFont( aFont ); // will be changed according to pToolBar
+    aStyleSettings.SetLabelFont( aFont );
+    aStyleSettings.SetInfoFont( aFont );
+    aStyleSettings.SetRadioCheckFont( aFont );
+    aStyleSettings.SetPushButtonFont( aFont );
+    aStyleSettings.SetFieldFont( aFont );
+    aStyleSettings.SetIconFont( aFont );
+    aStyleSettings.SetGroupFont( aFont );
+
+    // Menu
+    KMainWindow qMainWindow;
+    qMainWindow.createGUI();
+
+    KMenuBar *pMenuBar = qMainWindow.menuBar();
+    if ( pMenuBar )
+    {
+        // Color
+        QColorGroup qMenuCG = pMenuBar->colorGroup();
+        aStyleSettings.SetMenuTextColor( toColor( qMenuCG.buttonText() ) );
+        aStyleSettings.SetMenuColor( toColor( qMenuCG.button() ) );
+        aStyleSettings.SetMenuBarColor( toColor( qMenuCG.button() ) );
+        aStyleSettings.SetMenuHighlightColor( toColor ( qMenuCG.highlight() ) );
+        aStyleSettings.SetMenuHighlightTextColor( toColor ( qMenuCG.highlightedText() ) );
+
+        // Font
+        Font aFont= aStyleSettings.GetMenuFont();
+        modifyFont( aFont, pMenuBar->font() );
+        aStyleSettings.SetMenuFont( aFont );
+    }
+
+    // Tool bar
+    KToolBar *pToolBar = qMainWindow.toolBar();
+    if ( pToolBar )
+    {
+        Font aFont= aStyleSettings.GetToolFont();
+        modifyFont( aFont, pToolBar->font() );
+        aStyleSettings.SetToolFont( aFont );
+    }
+
+    // Scroll bar size
+    aStyleSettings.SetScrollBarSize( kapp->style().pixelMetric( QStyle::PM_ScrollBarExtent ) );
+
+    rSettings.SetStyleSettings( aStyleSettings );
+}
+
+/* vim: set tabstop=8 shiftwidth=4: */
Index: vcl/unx/source/gdi/salogl.cxx
===================================================================
--- vcl/unx/source/gdi/salogl.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/salogl.cxx	2004-09-14 14:09:32.422280040 +0200
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALOGL_CXX
-
 #include <salunx.h>
 
 #ifndef _SV_SALDATA_HXX
@@ -71,18 +69,20 @@
 #include <saldisp.hxx>
 #endif
 
-#ifndef _SV_SALOGL_HXX
-#include <salogl.hxx>
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
 #endif
 
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
+using namespace rtl;
+
 // ------------
 // - Lib-Name -
 // ------------
@@ -97,55 +97,53 @@
 // - Macros -
 // ----------
 
-// NetBSD has neither RTLD_GLOBAL nor RTLD_NOW
-#if defined NETBSD
-#define DLOPEN_MODE 0
-#else
-#define DLOPEN_MODE (RTLD_NOW | RTLD_GLOBAL)
-#endif
-
-
 // -----------------
 // - Statics init. -
 // -----------------
 
 // Members
-GLXContext		SalOpenGL::maGLXContext = 0;
-Display*		SalOpenGL::mpDisplay    = 0;
-XVisualInfo*	SalOpenGL::mpVisualInfo = 0;
-BOOL			SalOpenGL::mbHaveGLVisual = FALSE;
-
-void *      SalOpenGL::mpGLLib    = 0;
-ULONG		SalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
-
-GLXContext (*SalOpenGL::pCreateContext)( Display *, XVisualInfo *, GLXContext, Bool ) = 0;
-void       (*SalOpenGL::pDestroyContext)( Display *, GLXContext ) = 0;
-GLXContext (*SalOpenGL::pGetCurrentContext)( ) = 0;
-Bool       (*SalOpenGL::pMakeCurrent)( Display *, GLXDrawable, GLXContext ) = 0;
-void		(*SalOpenGL::pSwapBuffers)( Display*, GLXDrawable ) = 0;
-int			(*SalOpenGL::pGetConfig)( Display*, XVisualInfo*, int, int* ) = 0;
-void       (*SalOpenGL::pFlush)() = 0;
+GLXContext		X11SalOpenGL::maGLXContext = 0;
+Display*		X11SalOpenGL::mpDisplay    = 0;
+XVisualInfo*	X11SalOpenGL::mpVisualInfo = 0;
+BOOL			X11SalOpenGL::mbHaveGLVisual = FALSE;
+
+#ifdef MACOSX
+oslModule      X11SalOpenGL::mpGLLib    = 0;
+#else
+void *      X11SalOpenGL::mpGLLib    = 0;
+#endif
+
+ULONG		X11SalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
+
+GLXContext (*X11SalOpenGL::pCreateContext)( Display *, XVisualInfo *, GLXContext, Bool ) = 0;
+void       (*X11SalOpenGL::pDestroyContext)( Display *, GLXContext ) = 0;
+GLXContext (*X11SalOpenGL::pGetCurrentContext)( ) = 0;
+Bool       (*X11SalOpenGL::pMakeCurrent)( Display *, GLXDrawable, GLXContext ) = 0;
+void		(*X11SalOpenGL::pSwapBuffers)( Display*, GLXDrawable ) = 0;
+int			(*X11SalOpenGL::pGetConfig)( Display*, XVisualInfo*, int, int* ) = 0;
+void       (*X11SalOpenGL::pFlush)() = 0;
 
 // -------------
-// - SalOpenGL -
+// - X11SalOpenGL -
 // -------------
 
-SalOpenGL::SalOpenGL( SalGraphics* pGraphics )
+X11SalOpenGL::X11SalOpenGL( SalGraphics* pSGraphics )
 {
-	mpDisplay    = pGraphics->maGraphicsData.GetXDisplay();
-	mpVisualInfo = pGraphics->maGraphicsData.GetDisplay()->GetVisual();
-	maDrawable   = pGraphics->maGraphicsData.GetDrawable();
+    X11SalGraphics* pGraphics = static_cast<X11SalGraphics*>(pSGraphics);
+	mpDisplay    = pGraphics->GetXDisplay();
+	mpVisualInfo = pGraphics->GetDisplay()->GetVisual();
+	maDrawable   = pGraphics->GetDrawable();
 }
 
 // ------------------------------------------------------------------------
 
-SalOpenGL::~SalOpenGL()
+X11SalOpenGL::~X11SalOpenGL()
 {
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::Create()
+bool X11SalOpenGL::IsValid()
 {
 	if( OGL_STATE_UNLOADED == mnOGLState )
 	{
@@ -205,7 +203,7 @@ BOOL SalOpenGL::Create()
 						GLX_DOUBLEBUFFER, &nDoubleBuffer );
 			if( nHaveGL && ! nDoubleBuffer )
 			{
-				SalDisplay* pSalDisplay = GetSalData()->GetDefDisp();
+				SalDisplay* pSalDisplay = GetSalData()->GetDisplay();
 				BOOL bPreviousState =
 					pSalDisplay->GetXLib()->GetIgnoreXErrors();
 				pSalDisplay->GetXLib()->SetIgnoreXErrors( TRUE );
@@ -244,36 +242,23 @@ BOOL SalOpenGL::Create()
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::Release()
+void X11SalOpenGL::Release()
 {
 	ImplFreeLib();
 }
 
 // ------------------------------------------------------------------------
 
-void* SalOpenGL::GetOGLFnc( const String& rFncName )
+void* X11SalOpenGL::GetOGLFnc( const char *pFncName )
 {
-	if( mpGLLib )
-	{
-		return dlsym( mpGLLib, ByteString( rFncName, RTL_TEXTENCODING_ASCII_US ).GetBuffer() );
-	}
-	return NULL;
-}
-
-void* SalOpenGL::GetOGLFnc( char *pFncName )
-{
-	if( mpGLLib )
-	{
-		return dlsym( mpGLLib, pFncName );
-	}
-	return NULL;
+    return resolveSymbol( pFncName );
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::OGLEntry( SalGraphics* pGraphics )
+void X11SalOpenGL::OGLEntry( SalGraphics* pGraphics )
 {
-	GLXDrawable aDrawable = pGraphics->maGraphicsData.GetDrawable();
+	GLXDrawable aDrawable = static_cast<X11SalGraphics*>(pGraphics)->GetDrawable();
 	if( aDrawable != maDrawable )
 	{
 		maDrawable = aDrawable;
@@ -283,19 +268,23 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::OGLExit( SalGraphics* pGraphics )
+void X11SalOpenGL::OGLExit( SalGraphics* pGraphics )
 {
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::ImplFreeLib()
+void X11SalOpenGL::ImplFreeLib()
 {
 	if( mpGLLib )
 	{
 		if( maGLXContext && pDestroyContext )
 			pDestroyContext( mpDisplay, maGLXContext );
-		dlclose( mpGLLib );
+#ifdef MACOSX
+		osl_unloadModule( (oslModule) mpGLLib );
+#else
+		osl_unloadModule( mpGLLib );
+#endif
 
 		mpGLLib				= 0;
 		pCreateContext		= 0;
@@ -309,37 +298,55 @@ void SalOpenGL::ImplFreeLib()
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::ImplInit()
+void* X11SalOpenGL::resolveSymbol( const char* pSymbol )
+{
+    void* pSym = NULL;
+    if( mpGLLib )
+    {
+        OUString aSym = OUString::createFromAscii( pSymbol );
+#ifdef MACOSX
+        pSym = osl_getSymbol( (oslModule) mpGLLib, aSym.pData );
+#else
+        pSym = osl_getSymbol( mpGLLib, aSym.pData );
+#endif
+    }
+    return pSym;
+}
+
+
+BOOL X11SalOpenGL::ImplInit()
 {
 	if( ! mpGLLib )
 	{
 		ByteString sNoGL( getenv( "SAL_NOOPENGL" ) );
-		if( sNoGL.ToLowerAscii() == "true"  ) return FALSE;
-		mpGLLib = dlopen( OGL_LIBNAME, DLOPEN_MODE );
+		if( sNoGL.ToLowerAscii() == "true"  )
+            return FALSE;
+        OUString aLibName( RTL_CONSTASCII_USTRINGPARAM( OGL_LIBNAME ) );
+        mpGLLib = osl_loadModule( aLibName.pData, SAL_LOADMODULE_NOW );
 	}
 	if( ! mpGLLib )
 	{
 #if OSL_DEBUG_LEVEL > 1
-		fprintf( stderr, OGL_LIBNAME "could not be opened: %s\n", dlerror() );
+		fprintf( stderr, OGL_LIBNAME "could not be opened\n" );
 #endif
 		return FALSE;
 	}
 
 	// Internal use
 	pCreateContext     = (GLXContext(*)(Display*,XVisualInfo*,GLXContext,Bool ))
-		GetOGLFnc( "glXCreateContext" );
+		resolveSymbol( "glXCreateContext" );
 	pDestroyContext    = (void(*)(Display*,GLXContext))
-		GetOGLFnc( "glXDestroyContext" );
+		resolveSymbol( "glXDestroyContext" );
 	pGetCurrentContext = (GLXContext(*)())
-		GetOGLFnc( "glXGetCurrentContext" );
+		resolveSymbol( "glXGetCurrentContext" );
 	pMakeCurrent       = (Bool(*)(Display*,GLXDrawable,GLXContext))
-		GetOGLFnc( "glXMakeCurrent" );
+		resolveSymbol( "glXMakeCurrent" );
 	pSwapBuffers=(void(*)(Display*, GLXDrawable))
-		GetOGLFnc( "glXSwapBuffers" );
+		resolveSymbol( "glXSwapBuffers" );
 	pGetConfig = (int(*)(Display*, XVisualInfo*, int, int* ))
-		GetOGLFnc( "glXGetConfig" );
+		resolveSymbol( "glXGetConfig" );
 	pFlush = (void(*)())
-		GetOGLFnc( "glFlush" );
+		resolveSymbol( "glFlush" );
 
 	BOOL bRet = pCreateContext && pDestroyContext && pGetCurrentContext && pMakeCurrent && pSwapBuffers && pGetConfig ? TRUE : FALSE;
 
@@ -351,14 +358,14 @@ BOOL SalOpenGL::ImplInit()
 	return bRet;
 }
 
-void SalOpenGL::StartScene( SalGraphics* pGraphics )
+void X11SalOpenGL::StartScene( SalGraphics* pGraphics )
 {
 	// flush pending operations which otherwise might be drawn
 	// at the wrong time
 	XSync( mpDisplay, False );
 }
 
-void SalOpenGL::StopScene()
+void X11SalOpenGL::StopScene()
 {
 	if( maDrawable )
 	{
@@ -367,7 +374,7 @@ void SalOpenGL::StopScene()
 	}
 }
 
-void SalOpenGL::MakeVisualWeights( Display* pDisplay,
+void X11SalOpenGL::MakeVisualWeights( Display* pDisplay,
 								   XVisualInfo* pInfos,
 								   int *pWeights,
 								   int nVisuals )
Index: vcl/unx/source/gdi/salprnpsp.cxx
===================================================================
--- vcl/unx/source/gdi/salprnpsp.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/salprnpsp.cxx	2004-09-14 14:09:32.426279432 +0200
@@ -79,14 +79,14 @@
 #ifndef _SV_JOBSET_H
 #include <jobset.h>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
 #endif
-#ifndef _SV_SALPRN_HXX
-#include <salprn.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALPRN_H
+#include <salprn.h>
 #endif
 #ifndef _SV_PRINT_H
 #include <print.h>
@@ -94,8 +94,11 @@
 #ifndef _SV_SALPTYPE_HXX
 #include <salptype.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
+#endif
+#ifndef _VCL_PSPGRAPHICS_H
+#include <pspgraphics.h>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
@@ -211,9 +214,9 @@ static void getPaLib()
 	}
 }
 
-inline PtTo10Mu( int nPoints ) { return (int)((((double)nPoints)*35.27777778)+0.5); }
+inline int PtTo10Mu( int nPoints ) { return (int)((((double)nPoints)*35.27777778)+0.5); }
 
-inline TenMuToPt( int nUnits ) { return (int)((((double)nUnits)/35.27777778)+0.5); }
+inline int TenMuToPt( int nUnits ) { return (int)((((double)nUnits)/35.27777778)+0.5); }
 
 static struct
 {
@@ -433,20 +436,19 @@ static bool createPdf( const String& rTo
 
 // -----------------------------------------------------------------------
 
-SalInfoPrinter* SalInstance::CreateInfoPrinter(
-	SalPrinterQueueInfo*	pQueueInfo,
-	ImplJobSetup*			pJobSetup )
+SalInfoPrinter* X11SalInstance::CreateInfoPrinter( SalPrinterQueueInfo*	pQueueInfo,
+                                                   ImplJobSetup*			pJobSetup )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	// create and initialize SalInfoPrinter
-	SalInfoPrinter* pPrinter = new SalInfoPrinter;
+	PspSalInfoPrinter* pPrinter = new PspSalInfoPrinter;
 
 	if( pJobSetup )
 	{
 		PrinterInfoManager& rManager( PrinterInfoManager::get() );
 		PrinterInfo aInfo( rManager.getPrinterInfo( pQueueInfo->maPrinterName ) );
-		pPrinter->maPrinterData.m_aJobData = aInfo;
-		pPrinter->maPrinterData.m_aPrinterGfx.Init( pPrinter->maPrinterData.m_aJobData );
+		pPrinter->m_aJobData = aInfo;
+		pPrinter->m_aPrinterGfx.Init( pPrinter->m_aJobData );
 
 		if( pJobSetup->mpDriverData )
 			JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, aInfo );
@@ -463,35 +465,35 @@ SalInfoPrinter* SalInstance::CreateInfoP
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
+void X11SalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
 {
 	delete pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-SalPrinter* SalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
+SalPrinter* X11SalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	// create and initialize SalPrinter
-	SalPrinter* pPrinter = new SalPrinter;
-	pPrinter->maPrinterData.m_aJobData = pInfoPrinter->maPrinterData.m_aJobData;
+	PspSalPrinter* pPrinter = new PspSalPrinter;
+	pPrinter->m_aJobData = static_cast<PspSalInfoPrinter*>(pInfoPrinter)->m_aJobData;
 
 	return pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyPrinter( SalPrinter* pPrinter )
+void X11SalInstance::DestroyPrinter( SalPrinter* pPrinter )
 {
 	delete pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
+void X11SalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	PrinterInfoManager& rManager( PrinterInfoManager::get() );
 	::std::list< OUString > aPrinters;
 	rManager.listPrinters( aPrinters );
@@ -524,56 +526,56 @@ void SalInstance::GetPrinterQueueInfo( I
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
+void X11SalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
 {
 	delete pInfo;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
+void X11SalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 }
 
 // -----------------------------------------------------------------------
 
-String SalInstance::GetDefaultPrinter()
+String X11SalInstance::GetDefaultPrinter()
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	PrinterInfoManager& rManager( PrinterInfoManager::get() );
 	return rManager.getDefaultPrinter();
 }
 
 // =======================================================================
 
-SalInfoPrinter::SalInfoPrinter()
+PspSalInfoPrinter::PspSalInfoPrinter()
 {
-	maPrinterData.m_pGraphics = NULL;
+	m_pGraphics = NULL;
     m_bPapersInit = false;
 }
 
 // -----------------------------------------------------------------------
 
-SalInfoPrinter::~SalInfoPrinter()
+PspSalInfoPrinter::~PspSalInfoPrinter()
 {
-	if( maPrinterData.m_pGraphics )
+	if( m_pGraphics )
 	{
-		delete maPrinterData.m_pGraphics;
-		maPrinterData.m_pGraphics = NULL;
+		delete m_pGraphics;
+		m_pGraphics = NULL;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
+void PspSalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
 {
     m_aPaperFormats.clear();
     m_bPapersInit = true;
 
-    if( maPrinterData.m_aJobData.m_pParser )
+    if( m_aJobData.m_pParser )
     {
-        const PPDKey* pKey = maPrinterData.m_aJobData.m_pParser->getKey( String( RTL_CONSTASCII_USTRINGPARAM( "PageSize" ) ) );
+        const PPDKey* pKey = m_aJobData.m_pParser->getKey( String( RTL_CONSTASCII_USTRINGPARAM( "PageSize" ) ) );
         if( pKey )
         {
             int nValues = pKey->countValues();
@@ -585,7 +587,7 @@ void SalInfoPrinter::InitPaperFormats( c
                 if( ! aInfo.m_aPaperName.Len() )
                     aInfo.m_aPaperName = pValue->m_aOption;
                 int nWidth = 0, nHeight = 0;
-                maPrinterData.m_aJobData.m_pParser->getPaperDimension( pValue->m_aOption, nWidth, nHeight );
+                m_aJobData.m_pParser->getPaperDimension( pValue->m_aOption, nWidth, nHeight );
                 aInfo.m_nPaperWidth = (unsigned long)((PtTo10Mu( nWidth )+50)/100);
                 aInfo.m_nPaperHeight = (unsigned long)((PtTo10Mu( nHeight )+50)/100);
                 m_aPaperFormats.push_back( aInfo );
@@ -596,46 +598,44 @@ void SalInfoPrinter::InitPaperFormats( c
 
 // -----------------------------------------------------------------------
 
-int SalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
+int PspSalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
 {
     return 900;
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalInfoPrinter::GetGraphics()
+SalGraphics* PspSalInfoPrinter::GetGraphics()
 {
 	// return a valid pointer only once
 	// the reasoning behind this is that we could have different
 	// SalGraphics that can run in multiple threads
 	// (future plans)
 	SalGraphics* pRet = NULL;
-	if( ! maPrinterData.m_pGraphics )
+	if( ! m_pGraphics )
 	{
-		maPrinterData.m_pGraphics = new SalGraphics;
-		maPrinterData.m_pGraphics->maGraphicsData.m_pJobData	= &maPrinterData.m_aJobData;
-		maPrinterData.m_pGraphics->maGraphicsData.m_pPrinterGfx	= &maPrinterData.m_aPrinterGfx;
-		maPrinterData.m_pGraphics->maGraphicsData.bPrinter_		= TRUE;
-		pRet = maPrinterData.m_pGraphics;
+		m_pGraphics = new PspGraphics( &m_aJobData, &m_aPrinterGfx );
+        m_pGraphics->SetLayout( 0 );
+		pRet = m_pGraphics;
 	}
 	return pRet;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::ReleaseGraphics( SalGraphics* pGraphics )
+void PspSalInfoPrinter::ReleaseGraphics( SalGraphics* pGraphics )
 {
-	if( pGraphics == maPrinterData.m_pGraphics )
+	if( pGraphics == m_pGraphics )
 	{
 		delete pGraphics;
-		maPrinterData.m_pGraphics = NULL;
+		m_pGraphics = NULL;
 	}
 	return;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pJobSetup )
+BOOL PspSalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pJobSetup )
 {
 	if( ! pFrame || ! pJobSetup )
 		return FALSE;
@@ -679,12 +679,12 @@ BOOL SalInfoPrinter::Setup( SalFrame* pF
 // data should be merged into the driver data
 // If pJobSetup->mpDriverData IS NULL, then the driver defaults
 // should be merged into the independent data
-BOOL SalInfoPrinter::SetPrinterData( ImplJobSetup* pJobSetup )
+BOOL PspSalInfoPrinter::SetPrinterData( ImplJobSetup* pJobSetup )
 {
 	if( pJobSetup->mpDriverData )
 		return SetData( ~0, pJobSetup );
 
-	copyJobDataToJobSetup( pJobSetup, maPrinterData.m_aJobData );
+	copyJobDataToJobSetup( pJobSetup, m_aJobData );
 	return TRUE;
 }
 
@@ -694,7 +694,7 @@ BOOL SalInfoPrinter::SetPrinterData( Imp
 // and sets the new independ data in pJobSetup
 // Only the data must be changed, where the bit
 // in nGetDataFlags is set
-BOOL SalInfoPrinter::SetData(
+BOOL PspSalInfoPrinter::SetData(
 	ULONG nSetDataFlags,
 	ImplJobSetup* pJobSetup )
 {
@@ -804,7 +804,7 @@ BOOL SalInfoPrinter::SetData(
 		if( nSetDataFlags & SAL_JOBSET_ORIENTATION )
 			aData.m_eOrientation = pJobSetup->meOrientation == ORIENTATION_LANDSCAPE ? orientation::Landscape : orientation::Portrait;
 
-		maPrinterData.m_aJobData = aData;
+		m_aJobData = aData;
 		copyJobDataToJobSetup( pJobSetup, aData );
 		return TRUE;
 	}
@@ -814,7 +814,7 @@ BOOL SalInfoPrinter::SetData(
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::GetPageInfo(
+void PspSalInfoPrinter::GetPageInfo(
 	const ImplJobSetup* pJobSetup,
 	long& rOutWidth, long& rOutHeight,
 	long& rPageOffX, long& rPageOffY,
@@ -858,7 +858,7 @@ void SalInfoPrinter::GetPageInfo(
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pJobSetup )
+ULONG PspSalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pJobSetup )
 {
 	if( ! pJobSetup )
 		return 0;
@@ -872,7 +872,7 @@ ULONG SalInfoPrinter::GetPaperBinCount( 
 
 // -----------------------------------------------------------------------
 
-String SalInfoPrinter::GetPaperBinName( const ImplJobSetup* pJobSetup, ULONG nPaperBin )
+String PspSalInfoPrinter::GetPaperBinName( const ImplJobSetup* pJobSetup, ULONG nPaperBin )
 {
 	JobData aData;
 	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, aData );
@@ -896,7 +896,7 @@ String SalInfoPrinter::GetPaperBinName( 
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetCapabilities( const ImplJobSetup* pJobSetup, USHORT nType )
+ULONG PspSalInfoPrinter::GetCapabilities( const ImplJobSetup* pJobSetup, USHORT nType )
 {
 	switch( nType )
 	{
@@ -951,13 +951,13 @@ ULONG SalInfoPrinter::GetCapabilities( c
  *	SalPrinter
  */
 
-SalPrinter::SalPrinter()
+PspSalPrinter::PspSalPrinter()
 {
 }
 
 // -----------------------------------------------------------------------
 
-SalPrinter::~SalPrinter()
+PspSalPrinter::~PspSalPrinter()
 {
 }
 
@@ -972,7 +972,7 @@ static String getTmpName()
     return aSys;
 }
 
-BOOL SalPrinter::StartJob(
+BOOL PspSalPrinter::StartJob(
 	const XubString* pFileName,
 	const XubString& rJobName,
 	const XubString& rAppName,
@@ -981,81 +981,81 @@ BOOL SalPrinter::StartJob(
 {
     vcl_sal::PrinterUpdate::jobStarted();
 
-	maPrinterData.m_bFax		= false;
-	maPrinterData.m_bPdf		= false;
-	maPrinterData.m_aFileName	= pFileName ? *pFileName : String();
-	maPrinterData.m_aTmpFile	= String();
-    maPrinterData.m_nCopies		= nCopies;
+	m_bFax		= false;
+	m_bPdf		= false;
+	m_aFileName	= pFileName ? *pFileName : String();
+	m_aTmpFile	= String();
+    m_nCopies		= nCopies;
 
-	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, maPrinterData.m_aJobData );
-    if( maPrinterData.m_nCopies > 1 )
+	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, m_aJobData );
+    if( m_nCopies > 1 )
         // in case user did not do anything (m_nCopies=1)
         // take the default from jobsetup
-        maPrinterData.m_aJobData.m_nCopies = maPrinterData.m_nCopies;
+        m_aJobData.m_nCopies = m_nCopies;
 
 	// check wether this printer is configured as fax
     int nMode = 0;
-	const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( maPrinterData.m_aJobData.m_aPrinterName ) );
+	const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( m_aJobData.m_aPrinterName ) );
     sal_Int32 nIndex = 0;
     while( nIndex != -1 )
 	{
 		OUString aToken( rInfo.m_aFeatures.getToken( 0, ',', nIndex ) );
 		if( ! aToken.compareToAscii( "fax", 3 ) )
 		{
-			maPrinterData.m_bFax = true;
-			maPrinterData.m_aTmpFile = getTmpName();
+			m_bFax = true;
+			m_aTmpFile = getTmpName();
             nMode = S_IRUSR | S_IWUSR;
 
 			::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >::const_iterator it;
 			it = pJobSetup->maValueMap.find( ::rtl::OUString::createFromAscii( "FAX#" ) );
 			if( it != pJobSetup->maValueMap.end() )
-				maPrinterData.m_aFaxNr = it->second;
+				m_aFaxNr = it->second;
 
             sal_Int32 nPos = 0;
-			maPrinterData.m_bSwallowFaxNo = ! aToken.getToken( 1, '=', nPos ).compareToAscii( "swallow", 7 ) ? true : false;
+			m_bSwallowFaxNo = ! aToken.getToken( 1, '=', nPos ).compareToAscii( "swallow", 7 ) ? true : false;
 
 			break;
 		}
 		if( ! aToken.compareToAscii( "pdf=", 4 ) )
 		{
-			maPrinterData.m_bPdf = true;
-			maPrinterData.m_aTmpFile = getTmpName();
+			m_bPdf = true;
+			m_aTmpFile = getTmpName();
             nMode = S_IRUSR | S_IWUSR;
 
-			if( ! maPrinterData.m_aFileName.Len() )
+			if( ! m_aFileName.Len() )
 			{
-				maPrinterData.m_aFileName = getPdfDir( rInfo );
-				maPrinterData.m_aFileName.Append( '/' );
-				maPrinterData.m_aFileName.Append( rJobName );
-				maPrinterData.m_aFileName.AppendAscii( ".pdf" );
+				m_aFileName = getPdfDir( rInfo );
+				m_aFileName.Append( '/' );
+				m_aFileName.Append( rJobName );
+				m_aFileName.AppendAscii( ".pdf" );
 			}
 			break;
 		}
 	}
-	maPrinterData.m_aPrinterGfx.Init( maPrinterData.m_aJobData );
-	return maPrinterData.m_aPrintJob.StartJob( maPrinterData.m_aTmpFile.Len() ? maPrinterData.m_aTmpFile : maPrinterData.m_aFileName, nMode, rJobName, rAppName, maPrinterData.m_aJobData, &maPrinterData.m_aPrinterGfx ) ? TRUE : FALSE;
+	m_aPrinterGfx.Init( m_aJobData );
+	return m_aPrintJob.StartJob( m_aTmpFile.Len() ? m_aTmpFile : m_aFileName, nMode, rJobName, rAppName, m_aJobData, &m_aPrinterGfx ) ? TRUE : FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndJob()
+BOOL PspSalPrinter::EndJob()
 {
-	BOOL bSuccess = maPrinterData.m_aPrintJob.EndJob();
+	BOOL bSuccess = m_aPrintJob.EndJob();
 
 	if( bSuccess )
 	{
 		// check for fax
-		if( maPrinterData.m_bFax )
+		if( m_bFax )
 		{
 
-			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( maPrinterData.m_aJobData.m_aPrinterName ) );
+			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( m_aJobData.m_aPrinterName ) );
 			// sendAFax removes the file after use
-			bSuccess = sendAFax( maPrinterData.m_aFaxNr, maPrinterData.m_aTmpFile, rInfo.m_aCommand );
+			bSuccess = sendAFax( m_aFaxNr, m_aTmpFile, rInfo.m_aCommand );
 		}
-		else if( maPrinterData.m_bPdf )
+		else if( m_bPdf )
 		{
-			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( maPrinterData.m_aJobData.m_aPrinterName ) );
-			bSuccess = createPdf( maPrinterData.m_aFileName, maPrinterData.m_aTmpFile, rInfo.m_aCommand );
+			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( m_aJobData.m_aPrinterName ) );
+			bSuccess = createPdf( m_aFileName, m_aTmpFile, rInfo.m_aCommand );
 		}
 	}
     vcl_sal::PrinterUpdate::jobEnded();
@@ -1064,47 +1064,43 @@ BOOL SalPrinter::EndJob()
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::AbortJob()
+BOOL PspSalPrinter::AbortJob()
 {
-    BOOL bAbort = maPrinterData.m_aPrintJob.AbortJob() ? TRUE : FALSE;
+    BOOL bAbort = m_aPrintJob.AbortJob() ? TRUE : FALSE;
     vcl_sal::PrinterUpdate::jobEnded();
 	return bAbort;
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalPrinter::StartPage( ImplJobSetup* pJobSetup, BOOL bNewJobData )
+SalGraphics* PspSalPrinter::StartPage( ImplJobSetup* pJobSetup, BOOL bNewJobData )
 {
-	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, maPrinterData.m_aJobData );
-	maPrinterData.m_pGraphics = new SalGraphics();
-	maPrinterData.m_pGraphics->maGraphicsData.m_pJobData		= &maPrinterData.m_aJobData;
-	maPrinterData.m_pGraphics->maGraphicsData.m_pPrinterGfx		= &maPrinterData.m_aPrinterGfx;
-	maPrinterData.m_pGraphics->maGraphicsData.bPrinter_			= true;
-	maPrinterData.m_pGraphics->maGraphicsData.m_pPhoneNr		= maPrinterData.m_bFax ? &maPrinterData.m_aFaxNr : NULL;
-	maPrinterData.m_pGraphics->maGraphicsData.m_bSwallowFaxNo	= maPrinterData.m_bSwallowFaxNo;
-    if( maPrinterData.m_nCopies > 1 )
+	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, m_aJobData );
+	m_pGraphics = new PspGraphics( &m_aJobData, &m_aPrinterGfx, m_bFax ? &m_aFaxNr : NULL, m_bSwallowFaxNo  );
+    m_pGraphics->SetLayout( 0 );
+    if( m_nCopies > 1 )
         // in case user did not do anything (m_nCopies=1)
         // take the default from jobsetup
-        maPrinterData.m_aJobData.m_nCopies = maPrinterData.m_nCopies;
+        m_aJobData.m_nCopies = m_nCopies;
 
-	maPrinterData.m_aPrintJob.StartPage( maPrinterData.m_aJobData, bNewJobData ? sal_True : sal_False );
-	maPrinterData.m_aPrinterGfx.Init( maPrinterData.m_aPrintJob );
+	m_aPrintJob.StartPage( m_aJobData, bNewJobData ? sal_True : sal_False );
+	m_aPrinterGfx.Init( m_aPrintJob );
 
-	return maPrinterData.m_pGraphics;
+	return m_pGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndPage()
+BOOL PspSalPrinter::EndPage()
 {
-	sal_Bool bResult = maPrinterData.m_aPrintJob.EndPage();
-	maPrinterData.m_aPrinterGfx.Clear();
+	sal_Bool bResult = m_aPrintJob.EndPage();
+	m_aPrinterGfx.Clear();
 	return bResult ? TRUE : FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalPrinter::GetErrorCode()
+ULONG PspSalPrinter::GetErrorCode()
 {
 	return 0;
 }
@@ -1116,39 +1112,16 @@ ULONG SalPrinter::GetErrorCode()
 Timer* vcl_sal::PrinterUpdate::pPrinterUpdateTimer = NULL;
 int vcl_sal::PrinterUpdate::nActiveJobs = 0;
 
-struct PrnFrameCall
-{
-    SalFrame* pFrame;
-    SalFrameDelData aDelData;
-
-    PrnFrameCall() : pFrame( NULL ) {}
-};
-
 void vcl_sal::PrinterUpdate::doUpdate()
 {
     ::psp::PrinterInfoManager& rManager( ::psp::PrinterInfoManager::get() );
     if( rManager.checkPrintersChanged() )
     {
-        std::list< PrnFrameCall > aList;
-        SalFrame* pFrame = GetSalData()->pFirstFrame_;
-        while( pFrame )
-        {
-            aList.push_back( PrnFrameCall() );
-            aList.back().pFrame = pFrame;
-            pFrame->maFrameData.RegisterDeleteData( &aList.back().aDelData );
-            pFrame = pFrame->maFrameData.GetNextFrame();
-        }
-
-        while( aList.begin() != aList.end() )
-        {
-            if( ! aList.front().aDelData.IsDeleted() )
-            {
-                aList.front().pFrame->maFrameData.Call( SALEVENT_PRINTERCHANGED, NULL );
-                if( !aList.front().aDelData.IsDeleted() )
-                    aList.front().pFrame->maFrameData.UnregisterDeleteData( &aList.front().aDelData );
-            }
-            aList.pop_front();
-        }
+        SalDisplay* pDisp = GetSalData()->GetDisplay();
+        const std::list< SalFrame* >& rList = pDisp->getFrames();
+        for( std::list< SalFrame* >::const_iterator it = rList.begin();
+             it != rList.end(); ++it )
+            pDisp->SendInternalEvent( *it, NULL, SALEVENT_PRINTERCHANGED );
     }
 }
 
Index: vcl/unx/source/gdi/salvd.cxx
===================================================================
--- vcl/unx/source/gdi/salvd.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/salvd.cxx	2004-09-14 14:09:32.427279280 +0200
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALVD_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <salunx.h>
 
 #ifndef _SV_SALDATA_HXX
@@ -73,53 +70,53 @@
 #ifndef _SV_SALINST_HXX
 #include <salinst.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 
 // -=-= SalInstance =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalVirtualDevice* SalInstance::CreateVirtualDevice( SalGraphics* pGraphics,
-													long nDX, long nDY,
-													USHORT nBitCount )
+SalVirtualDevice* X11SalInstance::CreateVirtualDevice( SalGraphics* pGraphics,
+                                                       long nDX, long nDY,
+                                                       USHORT nBitCount )
 {
-	SalVirtualDevice *pVDev = new SalVirtualDevice();
+	X11SalVirtualDevice *pVDev = new X11SalVirtualDevice();
 	if( !nBitCount && pGraphics )
 		nBitCount = pGraphics->GetBitCount();
-	if( !pVDev->maVirDevData.Init( pGraphics->maGraphicsData.GetDisplay(),
-								   nDX, nDY, nBitCount ) )
+	if( !pVDev->Init( GetSalData()->GetDisplay(), nDX, nDY, nBitCount ) )
 	{
 		delete pVDev;
 		return NULL;
 	}
 
-	pVDev->maVirDevData.InitGraphics( pVDev, pGraphics );
+	pVDev->InitGraphics( pVDev );
 	return pVDev;
 }
 
-void SalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
-{ delete pDevice; }
+void X11SalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
+{
+    delete pDevice;
+}
 
 // -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::Init( SalVirtualDevice *pDevice,
-								  SalGraphics      *pGraphics )
+void X11SalGraphics::Init( X11SalVirtualDevice *pDevice )
 {
-	SalDisplay *pDisplay  = pDevice->maVirDevData.GetDisplay();
+	SalDisplay *pDisplay  = pDevice->GetDisplay();
 	
 	int nVisualDepth = pDisplay->GetColormap().GetVisual()->GetDepth();
-	int nDeviceDepth = pDevice->maVirDevData.GetDepth();
+	int nDeviceDepth = pDevice->GetDepth();
 
 	if( nDeviceDepth == nVisualDepth )
-		xColormap_ = &pDisplay->GetColormap();
+		m_pColormap = &pDisplay->GetColormap();
 	else 
 	if( nDeviceDepth == 1 )
-		xColormap_ = new SalColormap();
+		m_pDeleteColormap = m_pColormap = new SalColormap();
 			 
-	hDrawable_   = pDevice->maVirDevData.GetDrawable();
+	hDrawable_   = pDevice->GetDrawable();
     m_pVDev		 = pDevice;
     m_pFrame	 = NULL;
 
@@ -133,12 +130,12 @@ void SalGraphicsData::Init( SalVirtualDe
 
 // -=-= SalVirDevData / SalVirtualDevice -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-BOOL SalVirDevData::Init( SalDisplay *pDisplay,
-								long nDX, long nDY,
+BOOL X11SalVirtualDevice::Init( SalDisplay *pDisplay,
+                                long nDX, long nDY,
 								USHORT nBitCount )
 {
-	pDisplay_               = pDisplay;
-	pGraphics_              = new SalGraphicsLayout();
+    pDisplay_               = pDisplay;
+    pGraphics_				= new X11SalGraphics();
     pGraphics_->SetLayout( 0 ); // by default no! mirroring for VirtualDevices, can be enabled with EnableRTL()
 	nDX_                    = nDX;
 	nDY_                    = nDY;
@@ -149,11 +146,13 @@ BOOL SalVirDevData::Init( SalDisplay *pD
 									 nDX_, nDY_,
 									 GetDepth() );
 
+    pGraphics_->Init( this );
+
 	return hDrawable_ != None ? TRUE : FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline SalVirDevData::SalVirDevData()
+X11SalVirtualDevice::X11SalVirtualDevice()
 {
 	pDisplay_               = (SalDisplay*)ILLEGAL_POINTER;
 	pGraphics_              = NULL;
@@ -164,78 +163,61 @@ inline SalVirDevData::SalVirDevData()
 	bGraphics_              = FALSE;
 }
 
-SalVirtualDevice::SalVirtualDevice() {}
-
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline SalVirDevData::~SalVirDevData()
+X11SalVirtualDevice::~X11SalVirtualDevice()
 {
 	if( pGraphics_ )
-	{
-		pGraphics_->maGraphicsData.DeInit();
 		delete pGraphics_;
-	}
 
 	if( GetDrawable() )
 		XFreePixmap( GetXDisplay(), GetDrawable() );
 }
 
-SalVirtualDevice::~SalVirtualDevice()
-{}
-
-// -=-= #defines -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-#define _GetDrawable()   maVirDevData.GetDrawable()
-#define _GetDisplay()    maVirDevData.GetDisplay()
-#define _GetXDisplay()   maVirDevData.GetXDisplay()
-#define _GetDepth()      maVirDevData.nDepth_
-
-// -=-= SalVirtualDevice -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphics* SalVirtualDevice::GetGraphics()
+SalGraphics* X11SalVirtualDevice::GetGraphics()
 {
-	if( maVirDevData.bGraphics_ )
+	if( bGraphics_ )
 		return NULL;
 
-	if( maVirDevData.pGraphics_ )
-		maVirDevData.bGraphics_ = TRUE;
+	if( pGraphics_ )
+		bGraphics_ = TRUE;
 
-	return maVirDevData.pGraphics_;
+	return pGraphics_;
 }
 
-void SalVirtualDevice::ReleaseGraphics( SalGraphics* )
-{ maVirDevData.bGraphics_ = FALSE; }
+void X11SalVirtualDevice::ReleaseGraphics( SalGraphics* )
+{ bGraphics_ = FALSE; }
 
-BOOL SalVirtualDevice::SetSize( long nDX, long nDY )
+BOOL X11SalVirtualDevice::SetSize( long nDX, long nDY )
 {
 	if( !nDX ) nDX = 1;
 	if( !nDY ) nDY = 1;
 
-	Pixmap h = XCreatePixmap( _GetXDisplay(),
-							  maVirDevData.pDisplay_->GetDrawable(),
-							  nDX, nDY, _GetDepth() );
+	Pixmap h = XCreatePixmap( GetXDisplay(),
+							  pDisplay_->GetDrawable(),
+							  nDX, nDY, nDepth_ );
 
 	if( !h )
 	{
-		if( !_GetDrawable() )
+		if( !GetDrawable() )
 		{
-			maVirDevData.hDrawable_ = XCreatePixmap( _GetXDisplay(),
-										 maVirDevData.pDisplay_->GetDrawable(),
-										 1, 1, _GetDepth() );
-			maVirDevData.nDX_ = 1;
-			maVirDevData.nDY_ = 1;
+			hDrawable_ = XCreatePixmap( GetXDisplay(),
+                                        pDisplay_->GetDrawable(),
+                                        1, 1, nDepth_ );
+			nDX_ = 1;
+			nDY_ = 1;
 		}
 		return FALSE;
 	}
 
-	if( _GetDrawable() )
-		XFreePixmap( _GetXDisplay(), _GetDrawable() );
-	maVirDevData.hDrawable_ = h;
+	if( GetDrawable() )
+		XFreePixmap( GetXDisplay(), GetDrawable() );
+	hDrawable_ = h;
 
-	maVirDevData.nDX_ = nDX;
-	maVirDevData.nDY_ = nDY;
+	nDX_ = nDX;
+	nDY_ = nDY;
 
-	if( maVirDevData.pGraphics_ )
-		maVirDevData.InitGraphics( this, maVirDevData.pGraphics_ );
+	if( pGraphics_ )
+		InitGraphics( this );
 	
 	return TRUE;
 }
Index: vcl/unx/source/gdi/xfont.cxx
===================================================================
--- vcl/unx/source/gdi/xfont.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/xfont.cxx	2004-09-14 14:09:32.428279128 +0200
@@ -76,8 +76,11 @@
 #ifndef _SV_OUTFONT_HXX
 #include <outfont.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
 #if OSL_DEBUG_LEVEL > 1
@@ -122,8 +125,8 @@ ExtendedFontStruct::ExtendedFontStruct( 
 		maPixelSize( rPixelSize ),
 		mfXScale(1.0), mfYScale(1.0),
 		mbVertical( bVertical ),
-		mpXlfd( pXlfd ),
 		mnCachedEncoding( RTL_TEXTENCODING_DONTKNOW ),
+		mpXlfd( pXlfd ),
         mpRangeCodes(NULL),
         mnRangeCount(-1)
 {
@@ -437,7 +440,7 @@ ExtendedFontStruct::GetDefaultWidth()
 // is compatible with iso8859-X at least in the range to 0x7f
 sal_Size
 ExtendedFontStruct::GetCharWidth8( sal_Unicode nFrom, sal_Unicode nTo,
-		long* pWidthArray, rtl_TextEncoding nEncoding )
+		sal_Int32* pWidthArray, rtl_TextEncoding nEncoding )
 {
 	if ( !(nFrom <= nTo) )
 		return 0;
@@ -480,7 +483,7 @@ ExtendedFontStruct::GetCharWidth8( sal_U
 // Handle utf16 encoded fonts, which do not require conversion
 sal_Size
 ExtendedFontStruct::GetCharWidthUTF16( sal_Unicode nFrom, sal_Unicode nTo,
-		long* pWidthArray )
+		sal_Int32* pWidthArray )
 {
 	if ( !(nFrom <= nTo) )
 		return 0;
@@ -526,7 +529,7 @@ ExtendedFontStruct::GetCharWidthUTF16( s
 // font in fontstruct, 8 and 16 bit fonts are handled the same way
 sal_Size
 ExtendedFontStruct::GetCharWidth16( sal_Unicode nFrom, sal_Unicode nTo,
-    long* pWidthArray, ExtendedFontStruct *pFallback )
+    sal_Int32* pWidthArray, ExtendedFontStruct *pFallback )
 {
     if ( nFrom > nTo )
         return 0;
@@ -611,8 +614,8 @@ ExtendedFontStruct::GetCharWidth16( sal_
 }
 
 sal_Size
-ExtendedFontStruct::GetCharWidth( sal_Unicode cChar, long *pPhysicalWidth,
-    long *pLogicalWidth )
+ExtendedFontStruct::GetCharWidth( sal_Unicode cChar, sal_Int32 *pPhysicalWidth,
+    sal_Int32 *pLogicalWidth )
 {
     sal_Size nConverted = 0;
 
@@ -710,7 +713,9 @@ bool X11FontLayout::LayoutText( ImplLayo
 {
     Point aNewPos( 0, 0 );
     bool bRightToLeft;
-    for( int nCharPos = -1; rArgs.GetNextPos( &nCharPos, &bRightToLeft ); )
+    int nCharPos;
+
+    for( nCharPos = -1; rArgs.GetNextPos( &nCharPos, &bRightToLeft ); )
     {
         sal_Unicode cChar = rArgs.mpStr[ nCharPos ];
         if( bRightToLeft )
@@ -725,7 +730,7 @@ bool X11FontLayout::LayoutText( ImplLayo
                 nGlyphIndex = 0; // drop NotDef fallback glyphs
         }
 
-        long nPhysGlyphWidth, nLogGlyphWidth;
+        sal_Int32 nPhysGlyphWidth, nLogGlyphWidth;
         mrFont.GetCharWidth( cChar, &nPhysGlyphWidth, &nLogGlyphWidth );
         int nGlyphFlags = (nPhysGlyphWidth > 0) ? 0 : GlyphItem::IS_IN_CLUSTER;
         if( bRightToLeft )
@@ -756,7 +761,7 @@ void X11FontLayout::DrawText( SalGraphic
     int nMaxGlyphs = GetOrientation() ? 1 : MAXGLYPHS;
 
     Point aPos;
-    long aGlyphAry[ MAXGLYPHS ];
+    sal_Int32 aGlyphAry[ MAXGLYPHS ];
     sal_Unicode pStr[ MAXGLYPHS ];
     for( int nStart=0;;)
     {
@@ -767,7 +772,7 @@ void X11FontLayout::DrawText( SalGraphic
         for( int i = 0; i < nGlyphCount; ++i )
             pStr[ i ] = aGlyphAry[ i ] & GF_IDXMASK;
 
-        rSalGraphics.maGraphicsData.DrawStringUCS2MB( mrFont, aPos, pStr, nGlyphCount );
+        static_cast<X11SalGraphics&>(rSalGraphics).DrawStringUCS2MB( mrFont, aPos, pStr, nGlyphCount );
     }
 }
 
Index: vcl/unx/source/gdi/xlfd_attr.cxx
===================================================================
--- vcl/unx/source/gdi/xlfd_attr.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/xlfd_attr.cxx	2004-09-14 14:09:32.433278368 +0200
@@ -120,10 +120,12 @@ Attribute::Compare( const char *p, int n
 const rtl::OString&
 Attribute::GetKey ()
 {
+    static rtl::OString aEmptyStr;
+
 	if (mpKeyName != NULL)
 		return *mpKeyName;
 	if (mnLength == NULL)
-		return rtl::OString();
+		return aEmptyStr;
 
 	sal_Char* pBuffer = (sal_Char*)alloca (mnLength);
 
Index: vcl/unx/source/gdi/xlfd_extd.cxx
===================================================================
--- vcl/unx/source/gdi/xlfd_extd.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/xlfd_extd.cxx	2004-09-14 14:09:32.435278064 +0200
@@ -652,7 +652,7 @@ ScalableBitmapXlfd::ToString( ByteString
 	rString += '-';
 	rString += ByteString::CreateFromInt32( rInfo.mnResolutionY );
 	rString += '-';
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-0";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -673,10 +673,10 @@ ScalableBitmapXlfd::ToString( ByteString
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -697,10 +697,10 @@ BitmapXlfd::ToString( ByteString &rStrin
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -774,28 +774,9 @@ BitmapXlfd::ToString( ByteString &rStrin
 	AppendAttribute( mpFactory->RetrieveAddstyle(rInfo.mnAddstyle), rString );
 	rString += '-';   
 	rString += ByteString::CreateFromInt32( mnPixelSize );
-	#ifdef __notdef__
-		// since mnPointSize is not asked when comparing two bitmap font xlfd
-		// it may differ (and it does) for two fonts with same pixelsize
-		rString += "-";
-		rString += ByteString::CreateFromInt32( mnPointSize );
-		rString += "-";
-		rString += ByteString::CreateFromInt32( rInfo.mnResolutionX );
-		rString += '-';
-		rString += ByteString::CreateFromInt32( rInfo.mnResolutionY );
-		rString += '-';
-	#else
-		rString += "-*-*-*-";
-	#endif /* __notdef__ */
-
-	rString += rInfo.mcSpacing;
-
-	#ifdef __notdef__
-		rString += '-';
-		rString += ByteString::CreateFromInt32( mnAverageWidth );
-	#else
-		rString += "-*";
-	#endif
+	rString += "-*-*-*-";
+	rString += static_cast< char >(rInfo.mcSpacing);
+	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
 }
@@ -836,7 +817,7 @@ ScalableXlfd::ToString( ByteString &rStr
 	rString += '-';
 	rString += ByteString::CreateFromInt32( nPixelSize );
 	rString += "-0-0-0-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-0";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -857,10 +838,10 @@ ScalableXlfd::ToString( ByteString &rStr
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -1018,7 +999,7 @@ VirtualXlfd::ToString( ByteString &rStri
 	rString += '-';
 	rString += ByteString::CreateFromInt32( nPixelSize );
 	rString += "-0-0-0-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-0";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -1045,10 +1026,10 @@ VirtualXlfd::ToString( ByteString &rStri
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
Index: vcl/unx/source/gdi/xlfd_extd.hxx
===================================================================
--- vcl/unx/source/gdi/xlfd_extd.hxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/xlfd_extd.hxx	2004-09-14 14:09:32.435278064 +0200
@@ -93,8 +93,8 @@ class XlfdStorage;
 
 class ExtendedXlfd {
 
-	friend VirtualXlfd;
-	friend XlfdStorage;
+	friend class VirtualXlfd;
+	friend class XlfdStorage;
 
 	public:
 			 				ExtendedXlfd();
Index: vcl/unx/source/gdi/xlfd_smpl.cxx
===================================================================
--- vcl/unx/source/gdi/xlfd_smpl.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/xlfd_smpl.cxx	2004-09-14 14:09:32.436277912 +0200
@@ -282,12 +282,12 @@ Xlfd::ToString( ByteString &rString ) co
 	AppendAttribute( mpFactory->RetrieveSetwidth(mnSetwidth), rString );
 	AppendAttribute( mpFactory->RetrieveAddstyle(mnAddstyle), rString );
 
-	rString += '-'; rString += ByteString::CreateFromInt32( mnPixelSize );
-	rString += '-'; rString += ByteString::CreateFromInt32( mnPointSize );
-	rString += '-'; rString += ByteString::CreateFromInt32( mnResolutionX );
-	rString += '-'; rString += ByteString::CreateFromInt32( mnResolutionY );
-	rString += '-'; rString += mcSpacing;
-	rString += '-'; rString += ByteString::CreateFromInt32( mnAverageWidth );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnPixelSize ) );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnPointSize ) );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnResolutionX ) );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnResolutionY ) );
+	rString.Append("-"); rString.Append( (char)mcSpacing );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnAverageWidth ) );
 
 	AppendAttribute( mpFactory->RetrieveCharset(mnCharset), rString );
 
Index: vcl/unx/source/gdi/xprintext.cxx
===================================================================
--- vcl/unx/source/gdi/xprintext.cxx.orig	2004-09-12 14:26:04.000000000 +0200
+++ vcl/unx/source/gdi/xprintext.cxx	2004-09-14 14:09:32.437277760 +0200
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _VCL_XPRINT_EXTENSION_CXX
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -432,7 +430,7 @@ SalPrinter::StartJob(
 	XpSelectInput (pDisplay, aContext, XPPrintMask);
 
 	char pJobName[ 64 ];
-	sprintf (pJobName, "%s.job-name: XPrint%d", pPrinterName, getpid() );
+	snprintf (pJobName, sizeof(pJobName), "%s.job-name: XPrint%d", pPrinterName, getpid() );
 
 	XpStartJob( pDisplay, XPSpool );
 
