Index: vcl/source/window/window.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/window.cxx,v
retrieving revision 1.195
retrieving revision 1.195.36.1
diff -w -u -r1.195 -r1.195.36.1
--- vcl/source/window/window.cxx	23 Jul 2004 10:04:58 -0000	1.195
+++ vcl/source/window/window.cxx	8 Sep 2004 14:01:49 -0000	1.195.36.1
@@ -2540,6 +2540,22 @@
     if ( !(mnPaintFlags & IMPL_PAINT_PAINTALL) )
         maInvalidateRegion.Union( *pRegion );
 
+    // Handle transparent windows correctly: invalidate must be done on the first opaque parent
+    if( ((IsPaintTransparent() && !(nFlags & INVALIDATE_NOTRANSPARENT)) || (nFlags & INVALIDATE_TRANSPARENT) ) 
+            && ImplGetParent() )
+    {
+        /* The following optimization shows problems when resizing (native) tabcontrols (eg the Help viewer)
+           So we pass a NULL region to the parent as well which will result in a IMPL_PAINT_PAINTALL on the parent...
+
+        Region aWindowRegion;
+        if( pRegion == NULL )
+            // compute real region to avoid full repaint in parent
+            aWindowRegion = Rectangle( Point( mnOutOffX, mnOutOffY ), Size( mnOutWidth, mnOutHeight ) );
+        ImplGetParent()->ImplInvalidateFrameRegion( pRegion==NULL ? &aWindowRegion : pRegion, nFlags );
+        */
+        ImplGetParent()->ImplInvalidateFrameRegion( pRegion, nFlags );
+    }
+    else
     ImplPostPaint();
 }
 
@@ -2571,7 +2587,10 @@
     if ( mbOverlapWin )
         mpFrameWindow->ImplInvalidateOverlapFrameRegion( rRegion );
     else
+    {
+        if( ImplGetParent() )
         ImplGetParent()->ImplInvalidateFrameRegion( &rRegion, INVALIDATE_CHILDREN );
+    }
 }
 
 // -----------------------------------------------------------------------
