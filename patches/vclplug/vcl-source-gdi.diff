Index: vcl/source/gdi/alpha.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/alpha.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/gdi/alpha.cxx	12 Sep 2002 09:30:55 -0000	1.3
+++ vcl/source/gdi/alpha.cxx	6 Jan 2004 13:26:28 -0000	1.4
@@ -59,16 +59,14 @@
  *
  ************************************************************************/
 
-#define _SV_ALPHA_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 #ifndef _SV_ALPHA_HXX
 #include <alpha.hxx>
Index: vcl/source/gdi/animate.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/animate.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/gdi/animate.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/animate.cxx	17 Jun 2004 12:14:23 -0000	1.4
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_ANIMATE_CXX
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 
 #ifndef _DEBUG_HXX
@@ -137,11 +136,11 @@ ULONG AnimationBitmap::GetChecksum() con
 // -------------
 
 Animation::Animation() :
-	mbIsInAnimation 	( FALSE ),
-	meCycleMode 		( CYCLE_NORMAL ),
 	mnLoopCount 		( 0 ),
 	mnLoops 			( 0 ),
 	mnPos				( 0 ),
+	meCycleMode 		( CYCLE_NORMAL ),
+	mbIsInAnimation 	( FALSE ),
 	mbLoopTerminated	( FALSE ),
 	mbIsWaiting 		( FALSE )
 {
@@ -153,12 +152,12 @@ Animation::Animation() :
 // -----------------------------------------------------------------------
 
 Animation::Animation( const Animation& rAnimation ) :
-	maGlobalSize		( rAnimation.maGlobalSize ),
 	maBitmapEx			( rAnimation.maBitmapEx ),
-	meCycleMode 		( rAnimation.meCycleMode ),
-	mbIsInAnimation 	( FALSE ),
+	maGlobalSize		( rAnimation.maGlobalSize ),
 	mnLoopCount 		( rAnimation.mnLoopCount ),
 	mnPos				( rAnimation.mnPos ),
+	meCycleMode 		( rAnimation.meCycleMode ),
+	mbIsInAnimation 	( FALSE ),
 	mbLoopTerminated	( rAnimation.mbLoopTerminated ),
 	mbIsWaiting 		( rAnimation.mbIsWaiting )
 {
@@ -490,10 +489,7 @@ void Animation::Draw( OutputDevice* pOut
 
 void Animation::ImplRestartTimer( ULONG nTimeout )
 {
-#ifdef REMOTE_APPSERVER
-	nTimeout = nTimeout > 40 ? nTimeout : 40;
-#endif
-	maTimer.SetTimeout( Max( nTimeout, MIN_TIMEOUT + ( mnAnimCount - 1 ) * INC_TIMEOUT ) * 10L );
+	maTimer.SetTimeout( Max( nTimeout, (ULONG)(MIN_TIMEOUT + ( mnAnimCount - 1 ) * INC_TIMEOUT) ) * 10L );
 	maTimer.Start();
 }
 
@@ -957,8 +953,6 @@ SvStream& operator>>( SvStream& rIStm, A
 		AnimationBitmap aAnimBmp;
 		BitmapEx		aBmpEx;
 		ByteString		aDummyStr;
-		Point			aPoint;
-		Size			aSize;
 		UINT32			nTmp32;
 		UINT16			nTmp16;
 		BYTE			cTmp;
Index: vcl/source/gdi/bitmap.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap.cxx,v
retrieving revision 1.7
retrieving revision 1.11
diff -u -p -u -r1.7 -r1.11
--- vcl/source/gdi/bitmap.cxx	24 Apr 2003 14:56:22 -0000	1.7
+++ vcl/source/gdi/bitmap.cxx	21 May 2004 16:22:22 -0000	1.11
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_BITMAP_CXX
-
 #ifndef _RTL_CRC_H_
 #include <rtl/crc.h>
 #endif
@@ -73,8 +71,8 @@
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
@@ -83,13 +81,13 @@
 #include <impbmp.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_BITMAP_HXX
 #include <bitmap.hxx>
 #endif
-#ifndef _SV_ALPHA_HXX
-#include <alpha.hxx>
+#ifndef _SV_BITMAPEX_HXX
+#include <bitmapex.hxx>
 #endif
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
@@ -98,7 +96,9 @@
 #include <image.hxx>
 #endif
 
-// ------------------------------------------------------------------
+// ----------
+// - Bitmap -
+// ----------
 
 Bitmap::Bitmap() :
 	mpImpBmp( NULL )
@@ -496,12 +486,6 @@ void Bitmap::ImplSetImpBitmap( ImpBitmap
 
 BitmapReadAccess* Bitmap::AcquireReadAccess()
 {
-#ifdef REMOTE_APPSERVER
-	BOOL bGottenFromServer = FALSE;
-	if( mpImpBmp && mpImpBmp->ImplIsGetPrepared() )
-		mpImpBmp->ImplResolveGet(), bGottenFromServer = TRUE;
-#endif
-
 	BitmapReadAccess* pReadAccess = new BitmapReadAccess( *this );
 
 	if( !*pReadAccess )
@@ -510,11 +494,6 @@ BitmapReadAccess* Bitmap::AcquireReadAcc
 		pReadAccess = NULL;
 	}
 
-#ifdef REMOTE_APPSERVER
-	if( pReadAccess && mpImpBmp && bGottenFromServer )
-		mpImpBmp->ImplReleaseRemoteBmp();
-#endif
-
 	return pReadAccess;
 }
 
@@ -522,11 +501,6 @@ BitmapReadAccess* Bitmap::AcquireReadAcc
 
 BitmapWriteAccess* Bitmap::AcquireWriteAccess()
 {
-#ifdef REMOTE_APPSERVER
-	if( mpImpBmp && mpImpBmp->ImplIsGetPrepared() )
-		mpImpBmp->ImplResolveGet();
-#endif
-
 	BitmapWriteAccess* pWriteAccess = new BitmapWriteAccess( *this );
 
 	if( !*pWriteAccess )
@@ -535,11 +509,6 @@ BitmapWriteAccess* Bitmap::AcquireWriteA
 		pWriteAccess = NULL;
 	}
 
-#ifdef REMOTE_APPSERVER
-	if( pWriteAccess && mpImpBmp )
-		mpImpBmp->ImplReleaseRemoteBmp();
-#endif
-
 	return pWriteAccess;
 }
 
@@ -560,8 +529,8 @@ BOOL Bitmap::Erase( const Color& rFillCo
 	if( pWriteAcc )
 	{
 		const ULONG nFormat = pWriteAcc->GetScanlineFormat();
-		BYTE		cIndex;
-		BOOL		bFast;
+		BYTE		cIndex = 0;
+		BOOL		bFast = FALSE;
 
 		switch( nFormat )
 		{
@@ -612,7 +581,7 @@ BOOL Bitmap::Erase( const Color& rFillCo
 		if( bFast )
 		{
 			const ULONG nBufSize = pWriteAcc->GetScanlineSize() * pWriteAcc->Height();
-			HMEMSET( pWriteAcc->GetBuffer(), cIndex, nBufSize );
+			memset( pWriteAcc->GetBuffer(), cIndex, nBufSize );
 		}
 		else
 		{
@@ -713,9 +682,9 @@ BOOL Bitmap::Mirror( ULONG nMirrorFlags 
 
 			for( long nY = 0L, nOther = nHeight1; nY < nHeight_2; nY++, nOther-- )
 			{
-				HMEMCPY( pBuffer, pAcc->GetScanline( nY ), nScanSize );
-				HMEMCPY( pAcc->GetScanline( nY ), pAcc->GetScanline( nOther ), nScanSize );
-				HMEMCPY( pAcc->GetScanline( nOther ), pBuffer, nScanSize );
+				memcpy( pBuffer, pAcc->GetScanline( nY ), nScanSize );
+				memcpy( pAcc->GetScanline( nY ), pAcc->GetScanline( nOther ), nScanSize );
+				memcpy( pAcc->GetScanline( nOther ), pBuffer, nScanSize );
 			}
 
 			delete[] pBuffer;
@@ -1069,6 +1038,9 @@ BOOL Bitmap::CopyPixel( const Rectangle&
 						}
 						else if( pReadAcc->HasPalette() )
 						{
+							for( long nSrcY = aRectSrc.Top(); nSrcY < nSrcEndY; nSrcY++, nDstY++ )
+								for( long nSrcX = aRectSrc.Left(), nDstX = aRectDst.Left(); nSrcX < nSrcEndX; nSrcX++, nDstX++ )
+									pWriteAcc->SetPixel( nDstY, nDstX, pReadAcc->GetPaletteColor( pReadAcc->GetPixel( nSrcY, nSrcX ) ) );
 						}
 						else
 							for( long nSrcY = aRectSrc.Top(); nSrcY < nSrcEndY; nSrcY++, nDstY++ )
@@ -1157,8 +1129,6 @@ BOOL Bitmap::Expand( ULONG nDX, ULONG nD
 
 		if( pReadAcc )
 		{
-// Was soll den das ?
-//			BitmapPalette		aBmpPal( pReadAcc ? pReadAcc->GetPalette() : BitmapPalette() );
 			BitmapPalette		aBmpPal( pReadAcc->GetPalette() );
 			Bitmap				aNewBmp( aNewSize, GetBitCount(), &aBmpPal );
 			BitmapWriteAccess*	pWriteAcc = aNewBmp.AcquireWriteAccess();
@@ -1166,7 +1136,6 @@ BOOL Bitmap::Expand( ULONG nDX, ULONG nD
 			if( pWriteAcc )
 			{
 				BitmapColor aColor;
-				const ULONG nScanlineSize = pReadAcc->GetScanlineSize();
 				const long	nNewX = nWidth;
 				const long	nNewY = nHeight;
 				const long	nNewWidth = pWriteAcc->Width();
@@ -1448,11 +1417,6 @@ Region Bitmap::CreateRegion( const Color
 	return aRegion;
 }
 
-//fuer WIN16 Borland
-#ifdef WIN
-#pragma codeseg BITMAP_SEG1
-#endif
-
 // ------------------------------------------------------------------
 
 BOOL Bitmap::Replace( const Bitmap& rMask, const Color& rReplaceColor )
@@ -1755,7 +1719,6 @@ Bitmap Bitmap::CreateDisplayBitmap( Outp
 {
 	Bitmap aDispBmp( *this );
 
-#ifndef REMOTE_APPSERVER
 	if( mpImpBmp && ( pDisplay->mpGraphics || pDisplay->ImplGetGraphics() ) )
 	{
 		ImpBitmap* pImpDispBmp = new ImpBitmap;
@@ -1765,7 +1728,6 @@ Bitmap Bitmap::CreateDisplayBitmap( Outp
 		else
 			delete pImpDispBmp;
 	}
-#endif
 
 	return aDispBmp;
 }
@@ -1971,80 +1945,3 @@ BOOL Bitmap::MakeMono( BYTE cThreshold )
 {
 	return ImplMakeMono( cThreshold );
 }
-
-// ------------------------------------------------------------------
-
-#ifdef REMOTE_APPSERVER
-
-void Bitmap::ImplDrawRemote( OutputDevice* pOut,
-							 const Point& rSrcPt, const Size& rSrcSz,
-							 const Point& rDestPt, const Size& rDestSz ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmp( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplDrawRemoteEx( OutputDevice* pOut,
-							 const Point& rSrcPt, const Size& rSrcSz,
-							 const Point& rDestPt, const Size& rDestSz,
-							 const Bitmap& rMask ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmpEx( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rMask );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplDrawRemoteAlpha( OutputDevice* pOut,
-								  const Point& rSrcPt, const Size& rSrcSz,
-								  const Point& rDestPt, const Size& rDestSz,
-								  const AlphaMask& rAlpha ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmpAlpha( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rAlpha );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplDrawRemoteMask( OutputDevice* pOut,
-							 const Point& rSrcPt, const Size& rSrcSz,
-							 const Point& rDestPt, const Size& rDestSz,
-							 const Color& rColor ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmpMask( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rColor );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplGetRemoteBmp( OutputDevice* pOut, const Point& rPt, const Size& rSz )
-{
-	DBG_ASSERT( !mpImpBmp, "Bitmap::ImplGetRemoteBmp???" );
-
-	mpImpBmp = new ImpBitmap;
-	mpImpBmp->ImplCreateRemoteBmp( *this, pOut, rPt, rSz );
-}
-
-#endif
Index: vcl/source/gdi/bitmap2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap2.cxx,v
retrieving revision 1.4
retrieving revision 1.6
diff -u -p -u -r1.4 -r1.6
--- vcl/source/gdi/bitmap2.cxx	24 Apr 2003 13:17:58 -0000	1.4
+++ vcl/source/gdi/bitmap2.cxx	17 Jun 2004 12:14:50 -0000	1.6
@@ -59,14 +59,6 @@
  *
  ************************************************************************/
 
-#ifdef WIN
-#ifndef _SV_SVSYS_HXX
-#include <svsys.h>
-#endif
-#endif
-
-#define _SV_BITMAP_CXX
-
 #include <tools/zcodec.hxx>
 #ifndef _TOOLS_NEW_HXX
 #include <tools/new.hxx>
@@ -130,8 +122,8 @@ struct DIBInfoHeader
 						nHeight( 0UL ),
 						nPlanes( 0 ),
 						nBitCount( 0 ),
-						nCompression( 0UL ),
-						nSizeImage( 0UL ),
+						nCompression( 0 ),
+						nSizeImage( 0 ),
 						nXPelsPerMeter( 0UL ),
 						nYPelsPerMeter( 0UL ),
 						nColsUsed( 0UL ),
@@ -196,8 +188,6 @@ BOOL Bitmap::ImplReadDIB( SvStream& rISt
 {
 	DIBInfoHeader	aHeader;
 	const ULONG 	nStmPos = rIStm.Tell();
-	BitmapPalette*	pPalette = NULL;
-	BOOL			bHeaderRead = FALSE;
 	BOOL			bRet = FALSE;
 
 	if( ImplReadDIBInfoHeader( rIStm, aHeader ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
@@ -665,7 +655,7 @@ BOOL Bitmap::ImplReadDIBBits( SvStream& 
 
 BOOL Bitmap::Write( SvStream& rOStm, BOOL bCompressed, BOOL bFileHeader ) const
 {
-	BMP_ASSERT( mpImpBmp, "Empty Bitmaps can't be saved" );
+	DBG_ASSERT( mpImpBmp, "Empty Bitmaps can't be saved" );
 
 	const Size	aSizePix( GetSizePixel() );
 	BOOL		bRet = FALSE;
@@ -711,7 +701,7 @@ BOOL Bitmap::ImplWriteDIB( SvStream& rOS
 	DIBInfoHeader	aHeader;
 	ULONG			nImageSizePos;
 	ULONG			nEndPos;
-	ULONG			nCompression = 0UL;
+	ULONG			nCompression = 0;
 	BOOL			bRet = FALSE;
 
 	aHeader.nSize = DIBINFOHEADERSIZE;
Index: vcl/source/gdi/bitmap3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap3.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/gdi/bitmap3.cxx	27 Aug 2001 12:57:08 -0000	1.3
+++ vcl/source/gdi/bitmap3.cxx	6 Jan 2004 13:28:34 -0000	1.4
@@ -60,11 +60,6 @@
  ************************************************************************/
 
 #include <stdlib.h>
-#define _SV_BITMAP_CXX
-
-#ifdef W31
-#include <tools/svwin.h>
-#endif
 #include <tools/new.hxx>
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
@@ -1033,7 +1028,7 @@ BOOL Bitmap::ImplScaleFast( const double
 
 					while( ( nActY < nNewHeight1 ) && ( pLutY[ nActY + 1 ] == nMapY ) )
 					{
-						HMEMCPY( pWriteAcc->GetScanline( nActY + 1L ),
+						memcpy( pWriteAcc->GetScanline( nActY + 1L ),
 								 pWriteAcc->GetScanline( nActY ), nScanlineSize );
 						nActY++;
 					}
@@ -1316,11 +1311,6 @@ BOOL Bitmap::Dither( ULONG nDitherFlags,
 	return bRet;
 }
 
-//fuer WIN16 Borland
-#ifdef WIN
-#pragma codeseg BITMAP3_SEG1
-#endif
-
 // ------------------------------------------------------------------------
 
 BOOL Bitmap::ImplDitherMatrix( const BitmapPalette* pDitherPal )
@@ -1413,7 +1403,6 @@ BOOL Bitmap::ImplDitherFloyd( const Bitm
 			long		nX;
 			long		nW = nWidth * 3L;
 			long		nW2 = nW - 3L;
-			long		nWLen = nW << 2;
 			long		nRErr, nGErr, nBErr;
 			long		nRC, nGC, nBC;
 			long		nTemp;
@@ -1491,7 +1480,8 @@ BOOL Bitmap::ImplDitherFloyd( const Bitm
 				pWriteAcc->SetPixel( nYAcc, 0, BitmapColor( (BYTE) ( nVCLBLut[ nBC ] + nVCLGLut[nGC ] + nVCLRLut[nRC ] ) ) );
 
 				// mittlere Pixel ueber Schleife
-				for ( long nX = 3L, nXAcc = 1L; nX < nW2; nXAcc++ )
+				long nX, nXAcc;
+				for ( nX = 3L, nXAcc = 1L; nX < nW2; nXAcc++ )
 				{
 					CALC_ERRORS;
 					CALC_TABLES7;
@@ -1908,12 +1898,12 @@ BOOL Bitmap::ImplReduceMedian( USHORT nC
 		if( pWAcc )
 		{
 			const ULONG	nSize = 32768UL * sizeof( ULONG );
-			HPULONG		pColBuf = (HPULONG) SvMemAlloc( nSize );
+			ULONG*		pColBuf = (ULONG*) SvMemAlloc( nSize );
 			const long	nWidth = pWAcc->Width();
 			const long	nHeight = pWAcc->Height();
 			long		nIndex = 0L;
 
-			HMEMSET( (HPBYTE) pColBuf, 0, nSize );
+			memset( (HPBYTE) pColBuf, 0, nSize );
 
 			// create Buffer
 			if( pRAcc->HasPalette() )
@@ -1986,7 +1976,7 @@ void Bitmap::ImplMedianCut( ULONG* pColB
 	const long	nGLen = nG2 - nG1; 
 	const long	nBLen = nB2 - nB1;
 	long 		nR, nG, nB;
-	HPULONG		pBuf = pColBuf;
+	ULONG*		pBuf = pColBuf;
 
 	if( !nRLen && !nGLen && !nBLen )
 	{
Index: vcl/source/gdi/bitmap4.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap4.cxx,v
retrieving revision 1.2.292.1
retrieving revision 1.5
diff -u -p -u -r1.2.292.1 -r1.5
--- vcl/source/gdi/bitmap4.cxx	15 Aug 2003 11:23:35 -0000	1.2.292.1
+++ vcl/source/gdi/bitmap4.cxx	6 Jan 2004 13:29:07 -0000	1.5
@@ -58,7 +58,6 @@
  *
  *
  ************************************************************************/
-#define _SV_BITMAP_CXX
 
 #include <stdlib.h>
 #include <vos/macros.hxx>
@@ -88,8 +87,7 @@
 
 BOOL Bitmap::Filter( BmpFilter eFilter, const BmpFilterParam* pFilterParam, const Link* pProgress )
 {
-	const USHORT	nBitCount = GetBitCount();
-	BOOL			bRet = FALSE;
+	BOOL bRet = FALSE;
 
 	switch( eFilter )
 	{

Index: vcl/source/gdi/color.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/color.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/color.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/color.cxx	6 Jan 2004 13:34:39 -0000	1.2
@@ -76,7 +76,7 @@
 #include <svapp.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
 //============================================================================
@@ -97,7 +97,7 @@ Color::Color( const ResId& rResId )
 		USHORT nGreen	= pResMgr->ReadShort();
 		USHORT nBlue	= pResMgr->ReadShort();
 		// one more historical USHORT
-		USHORT nDummy	= pResMgr->ReadShort();
+		pResMgr->ReadShort();
 
 		// RGB-Farbe
 		mnColor = RGB_COLORDATA( nRed>>8, nGreen>>8, nBlue>>8 );
Index: vcl/source/gdi/cvtgrf.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/cvtgrf.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/gdi/cvtgrf.cxx	27 Sep 2001 17:00:25 -0000	1.2
+++ vcl/source/gdi/cvtgrf.cxx	6 Jan 2004 13:35:07 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_CVTGRF_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -81,19 +79,6 @@
 // - Callback	-
 // --------------
 
-#ifndef REMOTE_APPSERVER
-
-ULONG ImplFilterCallback( void* pInst,
-						  ULONG nInFormat, void* pInBuffer, ULONG nInBufSize,
-						  ULONG nOutFormat, void** ppOutBuffer )
-{
-	return( ( (GraphicConverter*) pInst )->ImplConvert( nInFormat, 
-														pInBuffer, nInBufSize,
-														ppOutBuffer, nOutFormat ) );
-}
-
-#endif
-
 // --------------------
 // - GraphicConverter -
 // --------------------
@@ -101,9 +86,6 @@ ULONG ImplFilterCallback( void* pInst,
 GraphicConverter::GraphicConverter() :
 	mpConvertData( NULL )
 {
-#ifndef REMOTE_APPSERVER
-	SetFilterCallback( (void*)ImplFilterCallback, this );
-#endif	
 }
 
 // ------------------------------------------------------------------------
Index: vcl/source/gdi/cvtsvm.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/cvtsvm.cxx,v
retrieving revision 1.7
retrieving revision 1.9
diff -u -p -u -r1.7 -r1.9
--- vcl/source/gdi/cvtsvm.cxx	27 Mar 2003 17:57:56 -0000	1.7
+++ vcl/source/gdi/cvtsvm.cxx	17 Jun 2004 12:15:59 -0000	1.9
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_CVTSVM_CXX
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 
 #include <algorithm>
@@ -720,7 +719,7 @@ void SVMConverter::ImplConvertFromSVM1( 
 				case( GDI_TEXTARRAY_ACTION ):
 				{
 					ByteString	aByteStr;
-					long*		pDXAry = NULL;
+					sal_Int32*	pDXAry = NULL;
 					INT32		nIndex, nLen, nAryLen;
 
 					rIStm >> aPt >> nIndex >> nLen >> nTmp >> nAryLen;
@@ -731,7 +730,7 @@ void SVMConverter::ImplConvertFromSVM1( 
 					{
                         INT32 nStrLen( aStr.Len() );
 
-						pDXAry = new long[ ::std::max( nAryLen, nStrLen ) ];
+						pDXAry = new sal_Int32[ Max( nAryLen, nStrLen ) ];
 
 						for( long i = 0L; i < nAryLen; i++ )
 							rIStm >> nTmp, pDXAry[ i ] = nTmp;
@@ -741,7 +740,7 @@ void SVMConverter::ImplConvertFromSVM1( 
                         {
                             if( nAryLen+1 == nStrLen )
                             {
-                                long* pTmpAry = new long[nStrLen];
+                                sal_Int32* pTmpAry = new sal_Int32[nStrLen];
 
                                 aFontVDev.GetTextArray( aStr, pTmpAry, (USHORT) nIndex, (USHORT) nLen );
                                 
@@ -1195,7 +1194,6 @@ void SVMConverter::ImplConvertToSVM1( Sv
 	ULONG				nPos;
 	ULONG				nCountPos;
 	Font				aSaveFont;
-	const ULONG 		nActionCount = rMtf.GetActionCount();
 	const USHORT		nOldFormat = rOStm.GetNumberFormatInt();
 	rtl_TextEncoding	eActualCharSet = gsl_getSystemTextEncoding();
 	const Size			aPrefSize( rMtf.GetPrefSize() );
@@ -1461,7 +1459,7 @@ ULONG SVMConverter::ImplWriteActions( Sv
 				ULONG					nAryLen;
 				ULONG					nLen = pAct->GetLen();
 				const ULONG 			nTextLen = aText.Len();
-				long*					pDXArray = pAct->GetDXArray();
+				sal_Int32*				pDXArray = pAct->GetDXArray();
 
 				if ( ImplWriteUnicodeComment( rOStm, aUniText ) )
 					nCount++;
Index: vcl/source/gdi/font.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/font.cxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/source/gdi/font.cxx	27 Mar 2003 17:57:56 -0000	1.6
+++ vcl/source/gdi/font.cxx	6 Jan 2004 13:36:04 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_FONT_CXX
-
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
@@ -110,11 +108,11 @@ Impl_Font::Impl_Font() :
 // -----------------------------------------------------------------------
 
 Impl_Font::Impl_Font( const Impl_Font& rImplFont ) :
-	maColor( rImplFont.maColor ),
-	maFillColor( rImplFont.maFillColor ),
 	maName( rImplFont.maName ),
 	maStyleName( rImplFont.maStyleName ),
-	maSize( rImplFont.maSize )
+	maSize( rImplFont.maSize ),
+	maColor( rImplFont.maColor ),
+	maFillColor( rImplFont.maFillColor )
 {
 	mnRefCount			= 1;
 	meCharSet			= rImplFont.meCharSet;
@@ -158,11 +156,7 @@ Font::Font()
 {
 	DBG_CTOR( Font, NULL );
 
-#ifdef WIN
-	static Impl_Font _near aStaticImplFont;
-#else
 	static Impl_Font aStaticImplFont;
-#endif
 	// RefCount == 0 fuer statische Objekte
 	aStaticImplFont.mnRefCount = 0;
 	mpImplFont = &aStaticImplFont;
@@ -609,19 +603,16 @@ SvStream& operator>>( SvStream& rIStm, I
 	rIStm.ReadByteString( rImpl_Font.maName, rIStm.GetStreamCharSet() );
 	rIStm.ReadByteString( rImpl_Font.maStyleName, rIStm.GetStreamCharSet() );
 	rIStm >> rImpl_Font.maSize;
-//	rIStm >> rImpl_Font.maColor;									// removed since SUPD396
-//	rIStm >> rImpl_Font.maFillColor;								// removed since SUPD396
 
 	rIStm >> nTmp16; rImpl_Font.meCharSet = (rtl_TextEncoding) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meFamily = (FontFamily) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.mePitch = (FontPitch) nTmp16;
-//	rIStm >> nTmp16; rImpl_Font.meAlign = (FontAlign) nTmp16;		// removed since SUPD396
 	rIStm >> nTmp16; rImpl_Font.meWeight = (FontWeight) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meUnderline = (FontUnderline) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meStrikeout = (FontStrikeout) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meItalic = (FontItalic) nTmp16;
-	rIStm >> nTmp16; rImpl_Font.meLanguage = (LanguageType) nTmp16; // new since SUPD 396
-	rIStm >> nTmp16; rImpl_Font.meWidthType = (FontWidth) nTmp16;	// new since SUPD 396
+	rIStm >> nTmp16; rImpl_Font.meLanguage = (LanguageType) nTmp16;
+	rIStm >> nTmp16; rImpl_Font.meWidthType = (FontWidth) nTmp16;
 
 	rIStm >> rImpl_Font.mnOrientation;
 
@@ -629,7 +620,6 @@ SvStream& operator>>( SvStream& rIStm, I
 	rIStm >> bTmp; rImpl_Font.mbOutline = bTmp;
 	rIStm >> bTmp; rImpl_Font.mbShadow = bTmp;
 	rIStm >> nTmp8; rImpl_Font.mnKerning = nTmp8;
-//	rIStm >> bTmp; rImpl_Font.mbTransparent = bTmp; 				// removed since SUPD396
 
     if( aCompat.GetVersion() >= 2 )
     {
@@ -652,19 +642,16 @@ SvStream& operator<<( SvStream& rOStm, c
 	rOStm.WriteByteString( rImpl_Font.maName, rOStm.GetStreamCharSet() );
 	rOStm.WriteByteString( rImpl_Font.maStyleName, rOStm.GetStreamCharSet() );
 	rOStm << rImpl_Font.maSize;
-//	rOStm << rImpl_Font.maColor;				// removed since SUPD396
-//	rOStm << rImpl_Font.maFillColor;			// removed since SUPD396
 
 	rOStm << (UINT16) GetStoreCharSet( rImpl_Font.meCharSet, rOStm.GetVersion() );
 	rOStm << (UINT16) rImpl_Font.meFamily;
 	rOStm << (UINT16) rImpl_Font.mePitch;
-//	rOStm << (UINT16) rImpl_Font.meAlign;		// removed since SUPD396
 	rOStm << (UINT16) rImpl_Font.meWeight;
 	rOStm << (UINT16) rImpl_Font.meUnderline;
 	rOStm << (UINT16) rImpl_Font.meStrikeout;
 	rOStm << (UINT16) rImpl_Font.meItalic;
-	rOStm << (UINT16) rImpl_Font.meLanguage;	// new since SUPD 396
-	rOStm << (UINT16) rImpl_Font.meWidthType;	// new since SUPD 396
+	rOStm << (UINT16) rImpl_Font.meLanguage;
+	rOStm << (UINT16) rImpl_Font.meWidthType;
 
 	rOStm << rImpl_Font.mnOrientation;
 
@@ -672,7 +659,6 @@ SvStream& operator<<( SvStream& rOStm, c
 	rOStm << (BOOL) rImpl_Font.mbOutline;
 	rOStm << (BOOL) rImpl_Font.mbShadow;
 	rOStm << (BYTE) rImpl_Font.mnKerning;
-//	rOStm << (BOOL) rImpl_Font.mbTransparent;	// removed since SUPD396
 
     // new in version 2
     rOStm << (BYTE)		rImpl_Font.meRelief;
Index: vcl/source/gdi/fontcfg.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/fontcfg.cxx,v
retrieving revision 1.18.20.3
retrieving revision 1.28
diff -u -p -u -r1.18.20.3 -r1.28
--- vcl/source/gdi/fontcfg.cxx	26 Jan 2004 17:21:01 -0000	1.18.20.3
+++ vcl/source/gdi/fontcfg.cxx	25 Jun 2004 15:16:03 -0000	1.28
@@ -88,13 +88,12 @@
 #include <tools/isolang.hxx>
 #endif
 
-#if OSL_DEBUG_LEVEL > 1
-#include <stdio.h>
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
 #endif
 
-#if defined DEBUG_TIMING
+#if OSL_DEBUG_LEVEL > 1
 #include <stdio.h>
-#include <osl/time.h>
 #endif
 
 #include <string.h>
@@ -109,6 +108,7 @@ using namespace vcl;
 using namespace rtl;
 using namespace utl;
 using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
 using namespace com::sun::star::beans;
 
 struct KeyMap
@@ -221,36 +221,41 @@ void DefaultFontConfigItem::Commit()
 
     int i, nKeys = sizeof(aKeyMap)/sizeof(aKeyMap[0]);
 
-    ::std::map< int, ::std::map< int, OUString > >::const_iterator lang;
+    std::hash_map< Locale, std::hash_map< int, OUString >, LocaleHash >::const_iterator lang;
 
     for( lang = m_aDefaults.begin(); lang != m_aDefaults.end(); ++lang )
     {
-        int nLanguage = lang->first;
-        if( nLanguage == LANGUAGE_DONTKNOW		||
-            nLanguage == LANGUAGE_NONE			||
-            nLanguage == LANGUAGE_SYSTEM		||
-            ( nLanguage >= LANGUAGE_USER1 && nLanguage <= LANGUAGE_USER9 )
-            )
-            continue;
-        String aLanguage( ConvertLanguageToIsoString( nLanguage, '-' ).ToLowerAscii() );
-        if( ! aLanguage.Len() )
+        OUStringBuffer aLanguage(16);
+        aLanguage.append( lang->first.Language.toAsciiLowerCase() );
+        if( lang->first.Country.getLength() )
+        {
+            aLanguage.append( sal_Unicode('-') );
+            aLanguage.append( lang->first.Country.toAsciiLowerCase() );
+            if( lang->first.Variant.getLength() )
+            {
+                aLanguage.append( sal_Unicode('-') );
+                aLanguage.append( lang->first.Variant.toAsciiLowerCase() );
+            }
+        }
+        if( ! aLanguage.getLength() )
             continue;
 
-        String aKeyName( aLanguage );
-        sal_Bool bAdded = AddNode( OUString(), aLanguage ); // defaults for a not yet configured language may be added
+        OUString aKeyName = aLanguage.makeStringAndClear();
+        AddNode( OUString(), aKeyName ); // defaults for a not yet configured language may be added
         Sequence< PropertyValue > aValues( nKeys );
         PropertyValue* pValues = aValues.getArray();
         int nIndex = 0;
         for( i = 0; i < nKeys; i++ )
         {
-            ::std::map< int, OUString >::const_iterator it = lang->second.find( aKeyMap[i].nEnum );
+            std::hash_map< int, OUString >::const_iterator it = lang->second.find( aKeyMap[i].nEnum );
             if( it == lang->second.end() )
                 continue;
 
-            String aName( aKeyName );
-            aName.Append( '/' );
-            aName.AppendAscii( aKeyMap[i].pName, aKeyMap[i].nLen );
-            pValues[nIndex].Name	= aName;
+            OUStringBuffer aName( 64 );
+            aName.append( aKeyName );
+            aName.append( sal_Unicode('/') );
+            aName.appendAscii( aKeyMap[i].pName, aKeyMap[i].nLen );
+            pValues[nIndex].Name	= aName.makeStringAndClear();
             pValues[nIndex].Handle	= it->first;
             pValues[nIndex].Value <<= it->second;
             pValues[nIndex].State	= PropertyState_DIRECT_VALUE;
@@ -274,65 +279,19 @@ void DefaultFontConfigItem::Notify( cons
 /*
  *  DefaultFontConfigItem::getValues
  */
-#ifdef DEBUG_TIMING
-static double fTimeCorrection = 0.0;
-#define START_TIMING() osl_getSystemTime( &aTmpTV1 );
-#define END_TIMING()\
-    osl_getSystemTime( &aTmpTV2 );\
-    fTmp = (double)aTmpTV2.Seconds + 1e-9*(double)aTmpTV2.Nanosec - (double)aTmpTV1.Seconds -1e-9*(double)aTmpTV1.Nanosec;\
-    if( fTmp > 0.0005 )\
-        fConfigTime += fTmp;\
-    else\
-        fprintf( stderr, "warning: timining inaccurate: %g\n", fTmp );
-
-#else
-#define START_TIMING()
-#define END_TIMING()
-#endif
-
 void DefaultFontConfigItem::getValues()
 {
     if( ! IsValidConfigMgr() )
         return;
 
-#ifdef DEBUG_TIMING
-    static bool bOnce = false;
-    TimeValue aStart;
-    TimeValue aStop;
-    TimeValue aTmpTV1, aTmpTV2;
-    double fConfigTime = 0.0;
-    double fTmp;
-    if( ! bOnce )
-    {
-        bOnce = true;
-        START_TIMING();
-        for( int i = 0; i < 100000; i++ )
-            osl_getSystemTime( &aStop );
-        END_TIMING();
-        fTimeCorrection = fTmp/100000.0;
-        fprintf( stderr, "osl_getSystemTime takes an average of %g seconds\n", fTimeCorrection );
-    }
-    osl_getSystemTime( &aStart );
-    fConfigTime = 0.0;
-#endif
-
     m_aDefaults.clear();
 
     int i, j;
-    START_TIMING();
     Sequence< OUString > aNames( GetNodeNames( OUString() ) );
-    END_TIMING();
     for( j = 0; j < aNames.getLength(); j++ )
     {
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "found localized default font data for \"%s\"\n",
-                 OUStringToOString( aNames.getConstArray()[j], RTL_TEXTENCODING_ASCII_US ).getStr()
-                 );
-#endif
         String aKeyName( aNames.getConstArray()[j] );
-        START_TIMING();
         Sequence< OUString > aKeys( GetNodeNames( aKeyName ) );
-        END_TIMING();
         Sequence< OUString > aLocaleKeys( aKeys.getLength() );
         const OUString* pFrom = aKeys.getConstArray();
         OUString* pTo = aLocaleKeys.getArray();
@@ -343,10 +302,26 @@ void DefaultFontConfigItem::getValues()
             aName.Append( String( pFrom[m] ) );
             pTo[m] = aName;
         }
-        START_TIMING();
         Sequence< Any > aValues( GetProperties( aLocaleKeys ) );
-        END_TIMING();
-        int nLanguageType = ConvertIsoStringToLanguage( aNames.getConstArray()[j], '-' );
+        Locale aLocale;
+        sal_Int32 nIndex = 0;
+        const OUString* pIso = aNames.getConstArray() + j;
+        aLocale.Language = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+        if( nIndex > 0 )
+        {
+            aLocale.Country = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+            if( nIndex > 0 )
+                aLocale.Variant = pIso->copy( nIndex ).toAsciiLowerCase();
+        }
+#if OSL_DEBUG_LEVEL > 2
+        fprintf( stderr, "found localized default font data for \"%s\" = %s-%s-%s\n",
+                 OUStringToOString( *pIso, osl_getThreadTextEncoding() ).getStr(),
+                 OUStringToOString( aLocale.Language, osl_getThreadTextEncoding() ).getStr(),
+                 OUStringToOString( aLocale.Country, osl_getThreadTextEncoding() ).getStr(),
+                 OUStringToOString( aLocale.Variant, osl_getThreadTextEncoding() ).getStr()
+                 
+                 );
+#endif
         const Any* pValue = aValues.getConstArray();
         for( i = 0; i < aValues.getLength(); i++, pValue++ )
         {
@@ -354,8 +329,8 @@ void DefaultFontConfigItem::getValues()
             {
                 const OUString* pLine = (const OUString*)pValue->getValue();
                 if( pLine->getLength() )
-                    m_aDefaults[ nLanguageType ][ getKeyType( aKeys.getConstArray()[i] ) ] = *pLine;
-#if OSL_DEBUG_LEVEL > 1
+                    m_aDefaults[ aLocale ][ getKeyType( aKeys.getConstArray()[i] ) ] = *pLine;
+#if OSL_DEBUG_LEVEL > 2
                 fprintf( stderr, "   \"%s\"=\"%.30s\"\n",
                          OUStringToOString( aKeys.getConstArray()[i], RTL_TEXTENCODING_ASCII_US ).getStr(),
                          OUStringToOString( *pLine, RTL_TEXTENCODING_ASCII_US ).getStr()
@@ -364,36 +339,37 @@ void DefaultFontConfigItem::getValues()
             }
         }
     }
-#ifdef DEBUG_TIMING
-    osl_getSystemTime( &aStop );
-    double fElapse = (double)aStop.Seconds + 1e-9*(double)aStop.Nanosec;
-    fElapse -= (double)aStart.Seconds + 1e-9*(double)aStart.Nanosec;
-    fprintf( stderr, "DefaultFontConfigItem::getValues needed %g seconds\n", fElapse );
-    fprintf( stderr, "time spent in configuration: %g seconds (%g%%)\n", fConfigTime, fConfigTime/fElapse*100.0 );
-#endif
 }
 
 /*
  *  DefaultFontConfigItem::getDefaultFont
  */
 
-const OUString& DefaultFontConfigItem::getDefaultFont( int nLanguage, int nType ) const
+const OUString& DefaultFontConfigItem::getDefaultFont( const Locale& rLocale, int nType ) const
 {
-    ::std::map< int, ::std::map< int, OUString > >::const_iterator lang = m_aDefaults.find( nLanguage );
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+    std::hash_map< Locale, std::hash_map< int, OUString >, vcl::LocaleHash >::const_iterator lang = m_aDefaults.find( aLocale );
     if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
     {
-        String aLang, aCountry;
-        ConvertLanguageToIsoNames( nLanguage, aLang, aCountry );
-        nLanguage = ConvertIsoStringToLanguage( aLang );
-        lang = m_aDefaults.find( nLanguage );
+        aLocale.Variant = OUString();
+        lang = m_aDefaults.find( aLocale );
         if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
         {
-            nLanguage = LANGUAGE_ENGLISH;
-            lang = m_aDefaults.find( nLanguage );
+            aLocale.Country = OUString();
+
+            lang = m_aDefaults.find( aLocale );
             if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
             {
-                static OUString aEmpty;
-                return aEmpty;
+                aLocale.Language = OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) );
+                lang = m_aDefaults.find( aLocale );
+                if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
+                {
+                    static OUString aEmpty;
+                    return aEmpty;
+                }
             }
         }
     }
@@ -404,11 +380,17 @@ const OUString& DefaultFontConfigItem::g
  *  DefaultFontConfigItem::getUserInterfaceFont
  */
 
-const OUString& DefaultFontConfigItem::getUserInterfaceFont( int nLanguage ) const
+const OUString& DefaultFontConfigItem::getUserInterfaceFont( const Locale& rLocale ) const
 {
-    if( nLanguage == LANGUAGE_SYSTEM )
-        nLanguage = Application::GetSettings().GetUILanguage();
-    const OUString& aUIFont = getDefaultFont( nLanguage, DEFAULTFONT_UI_SANS );
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+
+    if( ! aLocale.Language.getLength() )
+        aLocale = Application::GetSettings().GetUILocale();
+
+    const OUString& aUIFont = getDefaultFont( aLocale, DEFAULTFONT_UI_SANS );
 
     if( aUIFont.getLength() )
         return aUIFont;
@@ -464,63 +446,43 @@ const OUString& DefaultFontConfigItem::g
     static const OUString aFallBackKorean( aFallBackKoreanLocalized );
    
     // optimize font list for some locales, as long as Andale Sans UI does not support them
-    switch( nLanguage )
+    if( aLocale.Language.equalsAscii( "ar" ) ||
+        aLocale.Language.equalsAscii( "he" ) ||
+        aLocale.Language.equalsAscii( "iw" ) )
     {
-       case LANGUAGE_ARABIC:
-       case LANGUAGE_ARABIC_SAUDI_ARABIA:
-       case LANGUAGE_ARABIC_IRAQ:
-       case LANGUAGE_ARABIC_EGYPT:
-       case LANGUAGE_ARABIC_LIBYA:
-       case LANGUAGE_ARABIC_ALGERIA:
-       case LANGUAGE_ARABIC_MOROCCO:
-       case LANGUAGE_ARABIC_TUNISIA:
-       case LANGUAGE_ARABIC_OMAN:
-       case LANGUAGE_ARABIC_YEMEN:
-       case LANGUAGE_ARABIC_SYRIA:
-       case LANGUAGE_ARABIC_JORDAN:
-       case LANGUAGE_ARABIC_LEBANON:
-       case LANGUAGE_ARABIC_KUWAIT:
-       case LANGUAGE_ARABIC_UAE:
-       case LANGUAGE_ARABIC_BAHRAIN:
-       case LANGUAGE_ARABIC_QATAR:
-       case LANGUAGE_HEBREW:
-           return aFallBackArabic;
-           break;
-       case LANGUAGE_THAI:
-           return aFallBackThai;
-           break;
-       case LANGUAGE_KOREAN:
-       case LANGUAGE_KOREAN_JOHAB:
-           return aFallBackKorean;
-           break;
-            // latin-2 (use luxi before vera)
-       case LANGUAGE_CZECH:
-       case LANGUAGE_HUNGARIAN:
-       case LANGUAGE_POLISH:
-       case LANGUAGE_ROMANIAN:
-       case LANGUAGE_CROATIAN:
-       case LANGUAGE_SLOVAK:
-       case LANGUAGE_SLOVENIAN:
-       case LANGUAGE_SORBIAN:
-           return aFallbackLatin2;
-           break;
-
-       case LANGUAGE_CHINESE:
-       case LANGUAGE_CHINESE_SIMPLIFIED:
+        return aFallBackArabic;
+    }
+    else if( aLocale.Language.equalsAscii( "th" ) )
+    {
+        return aFallBackThai;
+    }
+    else if( aLocale.Language.equalsAscii( "ko" ) )
+    {
+        return aFallBackKorean;
+    }
+    else if( aLocale.Language.equalsAscii( "cs" ) ||
+             aLocale.Language.equalsAscii( "hu" ) ||
+             aLocale.Language.equalsAscii( "pl" ) ||
+             aLocale.Language.equalsAscii( "ro" ) ||
+             aLocale.Language.equalsAscii( "rm" ) ||
+             aLocale.Language.equalsAscii( "hr" ) ||
+             aLocale.Language.equalsAscii( "sk" ) ||
+             aLocale.Language.equalsAscii( "sl" ) ||
+             aLocale.Language.equalsAscii( "sb" ) )
+    {
+        return aFallbackLatin2;
+    }
+    else if( aLocale.Language.equalsAscii( "zh" ) )
+    {
+        if( ! aLocale.Country.equalsAscii( "cn" ) )
+            return aFallBackChineseTRD;
+        else
             return aFallBackChineseSIM;
-            break;
-       case LANGUAGE_CHINESE_TRADITIONAL:
-       case LANGUAGE_CHINESE_HONGKONG:
-       case LANGUAGE_CHINESE_SINGAPORE:
-       case LANGUAGE_CHINESE_MACAU:
-           return aFallBackChineseTRD;
-           break;
-       case LANGUAGE_JAPANESE:
-           return aFallBackJapanese;
-           break;
-       default:
-           break;
-   }
+    }
+    else if( aLocale.Language.equalsAscii( "ja" ) )
+    {
+        return aFallBackJapanese;
+    }
    
    return aFallback;
 }
@@ -529,12 +491,17 @@ const OUString& DefaultFontConfigItem::g
  *  DefaultFontConfigItem::setDefaultFont
  */
 
-void DefaultFontConfigItem::setDefaultFont( int nLanguage, int nType, const OUString& rFont )
+void DefaultFontConfigItem::setDefaultFont( const Locale& rLocale, int nType, const OUString& rFont )
 {
-    bool bModified = m_aDefaults[ nLanguage ][ nType ] != rFont;
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+
+    bool bModified = m_aDefaults[ aLocale ][ nType ] != rFont;
     if( bModified )
     {
-        m_aDefaults[ nLanguage ][ nType ] = rFont;
+        m_aDefaults[ aLocale ][ nType ] = rFont;
         SetModified();
     }
 }
@@ -922,7 +889,7 @@ static BOOL ImplFindAndErase( String& rN
 // =======================================================================
 
 void FontSubstConfigItem::getMapName( const String& rOrgName, String& rShortName,
-    String& rFamilyName, FontWeight& rWeight, FontWidth& rWidth, unsigned long& rType )
+    String& rFamilyName, FontWeight& rWeight, FontWidth& rWidth, ULONG& rType )
 {
     rShortName = rOrgName;
 
@@ -1072,54 +1039,62 @@ void FontSubstConfigItem::getValues()
     if( ! IsValidConfigMgr() )
         return;
 
-#ifdef DEBUG_TIMING
-    TimeValue aStart;
-    TimeValue aStop;
-    TimeValue aTmpTV1, aTmpTV2;
-    osl_getSystemTime( &aStart );
-
-    double fConfigTime = 0.0;
-    double fTmp;
-#endif
-
-    START_TIMING();
     Sequence< OUString > aLocales( GetNodeNames( OUString( ) ) );
-    END_TIMING();
     for( int j = 0; j < aLocales.getLength(); j++ )
     {
-        String aKeyName( aLocales.getConstArray()[j] );
-        int nLanguageType = ConvertIsoStringToLanguage( aLocales.getConstArray()[j], '-' );
-        START_TIMING();
-        Sequence< OUString > aSubstFonts( GetNodeNames( aKeyName ) );
-        END_TIMING();
-#if OSL_DEBUG_LEVEL > 1
+        const OUString* pIso = aLocales.getConstArray() +j;
+        Locale aLocale;
+        sal_Int32 nIndex = 0;
+        aLocale.Language = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+        if( nIndex > 0 )
+        {
+            aLocale.Country = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+            if( nIndex > 0 )
+                aLocale.Variant = pIso->copy( nIndex ).toAsciiLowerCase();
+        }
+        Sequence< OUString > aSubstFonts( GetNodeNames( *pIso ) );
+#if OSL_DEBUG_LEVEL > 2
         fprintf( stderr, "reading %d font substitutions for locale %s\n",
                  aSubstFonts.getLength(),
-                 ByteString( aKeyName, RTL_TEXTENCODING_ASCII_US ).GetBuffer() );
+                 OUStringToOString( *pIso, RTL_TEXTENCODING_ASCII_US ).getStr() );
 #endif
         for( int i = 0; i < aSubstFonts.getLength(); i++ )
         {
             FontNameAttr aAttributes;
             aAttributes.Name = aSubstFonts.getConstArray()[i];
 
-            String aFontKey( aKeyName );
-            aFontKey.Append( '/' );
+            OUStringBuffer aFontKey( 128 );
+            aFontKey.append( *pIso );
+            aFontKey.append( sal_Unicode('/') );
             // must use the wrapped name in config paths due to non-ASCII chars (eg korean font names) !!!
-            String wrappedName = wrapConfigurationElementName( aAttributes.Name );
-            aFontKey.Append( wrappedName );  
+            OUString wrappedName = wrapConfigurationElementName( aAttributes.Name );
+            aFontKey.append( wrappedName );
             Sequence< OUString > aKeys( 7 );
             OUString* pKeys = aKeys.getArray();
-            aFontKey.Append( '/' );
-            pKeys[0] = aFontKey.Copy().AppendAscii( "SubstFonts" );
-            pKeys[1] = aFontKey.Copy().AppendAscii( "SubstFontsMS" );
-            pKeys[2] = aFontKey.Copy().AppendAscii( "SubstFontsPS" );
-            pKeys[3] = aFontKey.Copy().AppendAscii( "SubstFontsHTML" );
-            pKeys[4] = aFontKey.Copy().AppendAscii( "FontWidth" );
-            pKeys[5] = aFontKey.Copy().AppendAscii( "FontWeight" );
-            pKeys[6] = aFontKey.Copy().AppendAscii( "FontType" );
-            START_TIMING();
+            aFontKey.append( sal_Unicode('/') );
+            OUString aPath = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFonts" );
+            pKeys[0] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFontsMS" );
+            pKeys[1] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFontsPS" );
+            pKeys[2] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFontsHTML" );
+            pKeys[3] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "FontWidth" );
+            pKeys[4] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "FontWeight" );
+            pKeys[5] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "FontType" );
+            pKeys[6] = aFontKey.makeStringAndClear();
             Sequence< Any > aValues( GetProperties( aKeys ) );
-            END_TIMING();
             const Any* pValues = aValues.getConstArray();
             sal_Int32 nIndex = 0, width = -1, weight = -1, type = 0;
             const OUString* pLine;
@@ -1226,20 +1201,13 @@ void FontSubstConfigItem::getValues()
             }
             aAttributes.Type = type;
 
-            m_aSubstitutions[nLanguageType].push_back( aAttributes );
+            m_aSubstitutions[aLocale].push_back( aAttributes );
         }
-        ::std::sort( m_aSubstitutions[nLanguageType].begin(), m_aSubstitutions[nLanguageType].end(), StrictStringSort() );
+        std::sort( m_aSubstitutions[aLocale].begin(), m_aSubstitutions[aLocale].end(), StrictStringSort() );
     }
-#ifdef DEBUG_TIMING
-    osl_getSystemTime( &aStop );
-    double fElapse = (double)aStop.Seconds + 1e-9*(double)aStop.Nanosec;
-    fElapse -= (double)aStart.Seconds + 1e-9*(double)aStart.Nanosec;
-    fprintf( stderr, "FontSubstConfigItem::getValues needed %g seconds\n", fElapse );
-    fprintf( stderr, "time spent in configuration: %g seconds (%g%%)\n", fConfigTime, fConfigTime/fElapse*100.0 );
-#endif
 }
 
-const FontSubstConfigItem::FontNameAttr* FontSubstConfigItem::getSubstInfo( const String& rFontName, int nLanguage ) const
+const FontSubstConfigItem::FontNameAttr* FontSubstConfigItem::getSubstInfo( const String& rFontName, const Locale& rLocale ) const
 {
     if( !rFontName.Len() )
         return NULL;
@@ -1250,9 +1218,18 @@ const FontSubstConfigItem::FontNameAttr*
     aSearchFont.ToLowerAscii();
     FontNameAttr aSearchAttr;
     aSearchAttr.Name = aSearchFont;
-    for( int i = 0; i < 3; i++ )
+
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+
+    if( ! aLocale.Language.getLength() )
+        aLocale = Application::GetSettings().GetUILocale();
+
+    while( aLocale.Language.getLength() )
     {
-        ::std::map< int, ::std::vector< FontNameAttr > >::const_iterator lang = m_aSubstitutions.find( nLanguage );
+        std::hash_map< Locale, std::vector< FontNameAttr >, LocaleHash >::const_iterator lang = m_aSubstitutions.find( aLocale );
         if( lang != m_aSubstitutions.end() )
         {
             // try to find an exact match
@@ -1261,22 +1238,15 @@ const FontSubstConfigItem::FontNameAttr*
             if( it != lang->second.end() && aSearchFont.CompareTo( it->Name, aSearchFont.Len() ) == COMPARE_EQUAL )
                 return &(*it);
         }
-        switch( i )
-        {
-            case 0:
-            {
-                String aLang, aCountry;
-                ConvertLanguageToIsoNames( nLanguage, aLang, aCountry );
-                int nNewLanguage = ConvertIsoStringToLanguage( aLang );
-                if( nNewLanguage == nLanguage || nNewLanguage == LANGUAGE_DONTKNOW || nNewLanguage == LANGUAGE_NONE )
-                    nNewLanguage = LANGUAGE_ENGLISH;
-                nLanguage = nNewLanguage;
-            }
-            break;
-            case 1:
-                nLanguage = LANGUAGE_ENGLISH;
-                break;
-        }
+        // gradually become more unspecific
+        if( aLocale.Variant.getLength() )
+            aLocale.Variant = OUString();
+        else if( aLocale.Country.getLength() )
+            aLocale.Country = OUString();
+        else if( ! aLocale.Language.equalsAscii( "en" ) )
+            aLocale.Language = OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) );
+        else
+            aLocale.Language = OUString();
     }
     return NULL;
 }
@@ -1324,7 +1294,7 @@ void SettingsConfigItem::Commit()
     if( ! IsValidConfigMgr() )
         return;
 
-    ::std::hash_map< OUString, ::std::hash_map< OUString, OUString, OUStringHash >, OUStringHash >::const_iterator group;
+    std::hash_map< OUString, std::hash_map< OUString, OUString, OUStringHash >, OUStringHash >::const_iterator group;
 
     for( group = m_aSettings.begin(); group != m_aSettings.end(); ++group )
     {
@@ -1333,7 +1303,7 @@ void SettingsConfigItem::Commit()
         Sequence< PropertyValue > aValues( group->second.size() );
         PropertyValue* pValues = aValues.getArray();
         int nIndex = 0;
-        ::std::hash_map< OUString, OUString, OUStringHash >::const_iterator it;
+        std::hash_map< OUString, OUString, OUStringHash >::const_iterator it;
         for( it = group->second.begin(); it != group->second.end(); ++it )
         {
             String aName( aKeyName );
@@ -1372,7 +1342,7 @@ void SettingsConfigItem::getValues()
     Sequence< OUString > aNames( GetNodeNames( OUString() ) );
     for( j = 0; j < aNames.getLength(); j++ )
     {
-#if OSL_DEBUG_LEVEL > 1
+#if OSL_DEBUG_LEVEL > 2
         fprintf( stderr, "found settings data for \"%s\"\n",
                  OUStringToOString( aNames.getConstArray()[j], RTL_TEXTENCODING_ASCII_US ).getStr()
                  );
@@ -1398,7 +1368,7 @@ void SettingsConfigItem::getValues()
                 const OUString* pLine = (const OUString*)pValue->getValue();
                 if( pLine->getLength() )
                     m_aSettings[ aKeyName ][ pFrom[i] ] = *pLine;
-#if OSL_DEBUG_LEVEL > 1
+#if OSL_DEBUG_LEVEL > 2
                 fprintf( stderr, "   \"%s\"=\"%.30s\"\n",
                          OUStringToOString( aKeys.getConstArray()[i], RTL_TEXTENCODING_ASCII_US ).getStr(),
                          OUStringToOString( *pLine, RTL_TEXTENCODING_ASCII_US ).getStr()
Index: vcl/source/gdi/fontcvt.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/fontcvt.cxx,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -p -u -r1.13 -r1.14
--- vcl/source/gdi/fontcvt.cxx	10 Jun 2002 11:06:06 -0000	1.13
+++ vcl/source/gdi/fontcvt.cxx	6 Jan 2004 13:37:42 -0000	1.14
@@ -67,16 +67,16 @@
 #include <outdev.h>
 #endif
 
-#ifndef __SGI_STL_MAP
+#ifndef _STLP_MAP
 #include <map>
 #endif
-#ifndef __SGI_STL_VECTOR
+#ifndef _STLP_VECTOR
 #include <vector>
 #endif
-#ifndef __SGI_STL_ALGORITHM
+#ifndef _STLP_ALGORITHM
 #include <algorithm>
 #endif
-#ifndef __SGI_STL_FUNCTIONAL
+#ifndef _STLP_FUNCTIONAL
 #include <functional>
 #endif
 
@@ -1233,13 +1233,9 @@ StarSymbolToMSMultiFontImpl::StarSymbolT
         for (aEntry.cIndex = 0xFF; aEntry.cIndex >= 0x20; --aEntry.cIndex)
         {
             if (sal_Unicode cChar = r.pTab[aEntry.cIndex-0x20])
-#if 1
                 maMagicMap.insert(
                     ::std::multimap<sal_Unicode, SymbolEntry>::value_type(
                     cChar, aEntry));
-#else
-                maMagicMap.insert(::std::make_pair(cChar, aEntry));
-#endif
         }
     }
 
@@ -1270,14 +1266,9 @@ StarSymbolToMSMultiFontImpl::StarSymbolT
         for (int j = r.mnSize / sizeof(r.mpTable[0]); j >=0; --j)
         {
             aEntry.cIndex = r.mpTable[j].cMS;
-#if 1
             maMagicMap.insert(
                 ::std::multimap<sal_Unicode, SymbolEntry>::value_type(
                 r.mpTable[j].cStar, aEntry));
-#else
-            maMagicMap.insert(::std::make_pair(r.mpTable[j].cStar,aEntry));
-#endif
-
         }
     }
 }
Index: vcl/source/gdi/gdimtf.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/gdimtf.cxx,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -p -u -r1.9 -r1.10
--- vcl/source/gdi/gdimtf.cxx	18 Nov 2002 13:44:33 -0000	1.9
+++ vcl/source/gdi/gdimtf.cxx	6 Jan 2004 13:38:14 -0000	1.10
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_GDIMTF_CXX
-
 #ifndef _VOS_MACROS_HXX_
 #include <vos/macros.hxx>
 #endif
@@ -1174,8 +1172,6 @@ void GDIMetaFile::Rotate( long nAngle10 
 			    case( META_GRADIENTEX_ACTION ):
 			    {
 				    MetaGradientExAction* pAct = (MetaGradientExAction*) pAction;
-				    Gradient			  aGradient(  );
-
 				    aMtf.AddAction( new MetaGradientExAction( ImplGetRotatedPolyPolygon( pAct->GetPolyPolygon(), aRotAnchor, aRotOffset, fSin, fCos ),
                                                               pAct->GetGradient() ) );
 			    }
@@ -2178,7 +2174,6 @@ SvStream& operator>>( SvStream& rIStm, G
 		char	aId[ 7 ];
 		ULONG	nStmPos = rIStm.Tell();
 		USHORT	nOldFormat = rIStm.GetNumberFormatInt();
-		BOOL	bError = FALSE;
 
 		rIStm.SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
 
Index: vcl/source/gdi/gfxlink.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/gfxlink.cxx,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -p -u -r1.9 -r1.10
--- vcl/source/gdi/gfxlink.cxx	24 Jun 2003 07:32:36 -0000	1.9
+++ vcl/source/gdi/gfxlink.cxx	6 Jan 2004 13:39:16 -0000	1.10
@@ -79,9 +79,9 @@
 
 GfxLink::GfxLink() :
 	meType		( GFX_LINK_TYPE_NONE ),
-	mnBufSize	( 0 ),
 	mpBuf		( NULL ),
 	mpSwap		( NULL ),
+	mnBufSize	( 0 ),
 	mnUserId	( 0UL ),
     mpImpData   ( new ImpGfxLink )
 {
Index: vcl/source/gdi/gradient.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/gradient.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/gradient.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/gradient.cxx	6 Jan 2004 13:39:43 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_GRADIENT_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
Index: vcl/source/gdi/graph.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/graph.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/gdi/graph.cxx	27 Mar 2003 17:57:57 -0000	1.5
+++ vcl/source/gdi/graph.cxx	20 Apr 2004 13:54:00 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_GRAPH_CXX
-
 #ifndef _SV_IMPGRAPH_HXX
 #include <impgraph.hxx>
 #endif
@@ -446,14 +444,28 @@ BitmapEx Graphic::GetBitmapEx() const
 
 Bitmap Graphic::GetBitmap( const Size* pSizePixel ) const
 {
-    return mpImpGraphic->ImplGetBitmap( pSizePixel );
+    return mpImpGraphic->ImplGetBitmap( pSizePixel, FALSE );
 }
 
 // ------------------------------------------------------------------------
 
 BitmapEx Graphic::GetBitmapEx( const Size* pSizePixel ) const
 {
-    return mpImpGraphic->ImplGetBitmapEx( pSizePixel );
+    return mpImpGraphic->ImplGetBitmapEx( pSizePixel, FALSE );
+}
+
+// ------------------------------------------------------------------------
+
+Bitmap Graphic::GetUnlimitedBitmap( const Size* pSizePixel ) const
+{
+    return mpImpGraphic->ImplGetBitmap( pSizePixel, TRUE ) ;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx Graphic::GetUnlimitedBitmapEx( const Size* pSizePixel ) const
+{
+    return mpImpGraphic->ImplGetBitmapEx( pSizePixel, TRUE ) ;
 }
 
 // ------------------------------------------------------------------------
@@ -507,7 +519,7 @@ Size Graphic::GetSizePixel( const Output
     Size aRet;
 
     if( GRAPHIC_BITMAP == mpImpGraphic->ImplGetType() )
-        aRet = mpImpGraphic->ImplGetBitmapEx( NULL ).GetSizePixel();
+        aRet = mpImpGraphic->ImplGetBitmapEx( NULL, FALSE ).GetSizePixel();
     else
         aRet = ( pRefDevice ? pRefDevice : Application::GetDefaultDevice() )->LogicToPixel( GetPrefSize(), GetPrefMapMode() );
      
Index: vcl/source/gdi/hatch.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/hatch.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/hatch.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/hatch.cxx	6 Jan 2004 13:40:40 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_HATCH_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>

Index: vcl/source/gdi/impanmvw.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impanmvw.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/gdi/impanmvw.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/impanmvw.cxx	6 Jan 2004 13:42:16 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_IMPANMVW_CXX
-
 #define private public
 
 #include "impanmvw.hxx"
@@ -78,11 +76,11 @@ ImplAnimView::ImplAnimView( Animation* p
 							OutputDevice* pFirstFrameOutDev ) :
 		mpParent		( pParent ),
 		mpOut			( pFirstFrameOutDev ? pFirstFrameOutDev : pOut ),
+		mnExtraData		( nExtraData ),
 		maPt			( rPt ),
 		maSz			( rSz ),
-		maClip			( mpOut->GetClipRegion() ),
 		maSzPix			( mpOut->LogicToPixel( maSz ) ),
-		mnExtraData		( nExtraData ),
+		maClip			( mpOut->GetClipRegion() ),
 		mpBackground	( new VirtualDevice ),
 		mpRestore		( new VirtualDevice ),
 		meLastDisposal	( DISPOSE_BACK ),
@@ -345,10 +343,8 @@ void ImplAnimView::ImplDraw( ULONG nPos,
 			
 			delete pDev;
 
-#ifndef REMOTE_APPSERVER
 			if( mpOut->GetOutDevType() == OUTDEV_WINDOW )
 				( (Window*) mpOut )->Sync();
-#endif
 		}
 	}
 }
Index: vcl/source/gdi/impbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impbmp.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/gdi/impbmp.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/impbmp.cxx	6 Jan 2004 13:42:38 -0000	1.4
@@ -59,26 +59,19 @@
  *
  ************************************************************************/
 
-#define _SV_IMPBMP_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALBMP_HXX
 #include <salbmp.hxx>
 #endif
-#else
-#include <indbmp.hxx>
-#ifndef _SV_RMBITMAP_HXX
-#include <rmbitmap.hxx>
-#endif
-#endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 #include <impbmp.hxx>
 #include <bitmap.hxx>
+#include <svdata.hxx>
+#include <salinst.hxx>
 
 // --------------
 // - ImpBitmap	-
@@ -88,11 +81,7 @@ ImpBitmap::ImpBitmap() :
 			mnRefCount	( 1UL ),
 			mnChecksum	( 0UL ),
 			mpRMBitmap	( NULL ),
-#ifndef REMOTE_APPSERVER
-			mpSalBitmap ( new SalBitmap )
-#else
-			mpSalBitmap ( new ImplServerBitmap )
-#endif
+			mpSalBitmap ( ImplGetSVData()->mpDefInst->CreateSalBitmap() )
 {
 }
 
@@ -100,18 +89,11 @@ ImpBitmap::ImpBitmap() :
 
 ImpBitmap::~ImpBitmap()
 {
-#ifdef REMOTE_APPSERVER
-	ImplReleaseRemoteBmp();
-#endif
 	delete mpSalBitmap;
 }
 
 // -----------------------------------------------------------------------
-#ifndef REMOTE_APPSERVER
 void ImpBitmap::ImplSetSalBitmap( SalBitmap* pBitmap )
-#else
-void ImpBitmap::ImplSetSalBitmap( ImplServerBitmap* pBitmap )
-#endif
 {
 	delete mpSalBitmap, mpSalBitmap = pBitmap;
 }
@@ -195,115 +164,4 @@ void ImpBitmap::ImplReleaseBuffer( Bitma
 
 	if( !bReadOnly )
 		mnChecksum = 0;
-}
-
-#ifdef REMOTE_APPSERVER
-
-RMBitmap* ImpBitmap::ImplGetRemoteBmp()
-{
-	return mpRMBitmap;
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplCreateRemoteBmp( const Bitmap& rBitmap )
-{
-	DBG_ASSERT( !mpRMBitmap, "ImplCreateRemoteBmp( Bitmap& rBitmap )???" );
-
-	mpRMBitmap = new RMBitmap( &(Bitmap&) rBitmap );
-	mpRMBitmap->Create();
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplCreateRemoteBmp( const Bitmap& rBitmap,
-									 OutputDevice* pOut,
-									 const Point& rPt, const Size& rSz )
-{
-	DBG_ASSERT( !mpRMBitmap, "ImplCreateRemoteBmp( Bitmap& rBitmap )???" );
-
-	mpRMBitmap = new RMBitmap( &(Bitmap&) rBitmap );
-	mpRMBitmap->CreateGet( pOut, rPt, rSz );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplReleaseRemoteBmp()
-{
-	delete mpRMBitmap;
-	mpRMBitmap = NULL;
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmp( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->Draw( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmpEx( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz,
-							const Bitmap& rMask )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->DrawEx( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rMask );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmpAlpha( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz,
-							const AlphaMask& rAlpha )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->DrawAlpha( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rAlpha );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmpMask( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz,
-							const Color& rColor )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->DrawMask( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rColor );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImpBitmap::ImplIsGetPrepared() const
-{
-	return( mpRMBitmap ? mpRMBitmap->IsGetPrepared() : FALSE );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplResolveGet()
-{
-	if( mpRMBitmap )
-	{
-		Bitmap aBmp;
-		mpRMBitmap->Get( aBmp );
-		ImpBitmap* pGetImpBmp = aBmp.ImplGetImpBitmap();
-
-		if( pGetImpBmp )
-		{
-			// wir nehmen der gegetteten Bitmap einfach
-			// die SalBitmap weg; Null-Setzen nicht vergessen,
-			// da die Bitmap die SalBitmap sonst abraeumt
-			delete mpSalBitmap;
-			mpSalBitmap = pGetImpBmp->mpSalBitmap;
-			pGetImpBmp->mpSalBitmap = NULL;
-		}
-	}
-}
-
-#endif
+}
\ No newline at end of file
Index: vcl/source/gdi/impgraph.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impgraph.cxx,v
retrieving revision 1.14
retrieving revision 1.16
diff -u -p -u -r1.14 -r1.16
--- vcl/source/gdi/impgraph.cxx	24 Jun 2003 07:32:48 -0000	1.14
+++ vcl/source/gdi/impgraph.cxx	20 Apr 2004 13:54:19 -0000	1.16
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_IMPGRAPH_CXX
-
 #ifndef _VCOMPAT_HXX
 #include <tools/vcompat.hxx>
 #endif
@@ -166,8 +164,8 @@ ImpGraphic::ImpGraphic() :
 // ------------------------------------------------------------------------
 
 ImpGraphic::ImpGraphic( const ImpGraphic& rImpGraphic ) :
-		maEx			( rImpGraphic.maEx ),
 		maMetaFile		( rImpGraphic.maMetaFile ),
+		maEx			( rImpGraphic.maEx ),
 	    mpContext		( NULL ),
 		mpSwapFile		( rImpGraphic.mpSwapFile ),
 		meType			( rImpGraphic.meType ),
@@ -490,7 +488,7 @@ BOOL ImpGraphic::ImplIsAnimated() const
 
 // ------------------------------------------------------------------------
 
-Bitmap ImpGraphic::ImplGetBitmap( const Size* pSizePixel ) const
+Bitmap ImpGraphic::ImplGetBitmap( const Size* pSizePixel, BOOL bUnlimited ) const
 {
     Bitmap aRetBmp;
 
@@ -523,7 +521,7 @@ Bitmap ImpGraphic::ImplGetBitmap( const 
             aSizePix = *pSizePixel;
         }
 
-		if( aSizePix.Width() && aSizePix.Height() &&
+		if( aSizePix.Width() && aSizePix.Height() && !bUnlimited &&
 			( aSizePix.Width() > GRAPHIC_MTFTOBMP_MAXEXT || aSizePix.Height() > GRAPHIC_MTFTOBMP_MAXEXT ) )
 		{
 			const Size  aOldSizePix( aSizePix );
@@ -556,7 +554,7 @@ Bitmap ImpGraphic::ImplGetBitmap( const 
 
 // ------------------------------------------------------------------------
 
-BitmapEx ImpGraphic::ImplGetBitmapEx( const Size* pSizePixel ) const
+BitmapEx ImpGraphic::ImplGetBitmapEx( const Size* pSizePixel, BOOL bUnlimited ) const
 {
     BitmapEx aRetBmpEx;
 
@@ -570,7 +568,7 @@ BitmapEx ImpGraphic::ImplGetBitmapEx( co
     else if( ( meType != GRAPHIC_DEFAULT ) && ImplIsSupportedGraphic() )
     {
 		const ImpGraphic aMonoMask( maMetaFile.GetMonochromeMtf( COL_BLACK ) );
-		aRetBmpEx = BitmapEx( ImplGetBitmap( pSizePixel ), aMonoMask.ImplGetBitmap( pSizePixel ) );
+		aRetBmpEx = BitmapEx( ImplGetBitmap( pSizePixel, bUnlimited ), aMonoMask.ImplGetBitmap( pSizePixel, bUnlimited ) );
     }
 
     return aRetBmpEx;
@@ -1147,7 +1145,6 @@ BOOL ImpGraphic::ImplWriteEmbedded( SvSt
 		const MapMode	aMapMode( ImplGetPrefMapMode() );
 		const Size		aSize( ImplGetPrefSize() );
 		const USHORT	nOldFormat = rOStm.GetNumberFormatInt();
-		const ULONG		nStmPos1 = rOStm.Tell();
 		ULONG			nDataFieldPos;
 
 		rOStm.SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
Index: vcl/source/gdi/implncvt.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/implncvt.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/source/gdi/implncvt.cxx	27 Mar 2003 17:57:57 -0000	1.2
+++ vcl/source/gdi/implncvt.cxx	6 Jan 2004 13:44:03 -0000	1.3
@@ -134,11 +134,11 @@ ImplFloatPoint ImplFloatPoint::GetNVec( 
 // --------------------
 
 ImplLineConverter::ImplLineConverter( const Polygon& rPolygon, const LineInfo& rLineInfo, const Point* pRefPoint ) :
-	maLineInfo		( rLineInfo ),
 	mfWidthHalf		( rLineInfo.GetWidth() >> 1 ),
-	mpFloatPoint	( NULL ),
+	maLineInfo		( rLineInfo ),
 	mpFloat0		( new ImplFloatPoint[ 6 ] ),
 	mpFloat1		( new ImplFloatPoint[ 6 ] ),
+	mpFloatPoint	( NULL ),
 	mnLines			( 0 )
 {
 	UINT16	nIndex, nPolySize = rPolygon.GetSize();
@@ -249,7 +249,6 @@ const Polygon* ImplLineConverter::ImplGe
 				INT32 nDashLen = maLineInfo.GetDashLen() + nDistance;
 				INT32 nDashesLen = maLineInfo.GetDashCount() * nDashLen;
 				INT32 nDotLen = maLineInfo.GetDotLen() + nDistance;
-				INT32 nDotsLen = maLineInfo.GetDotCount() * nDotLen;
 
 				if ( mnRefDistance >= nDashesLen )
 				{
Index: vcl/source/gdi/implncvt.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/implncvt.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/implncvt.hxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/implncvt.hxx	6 Jan 2004 13:44:27 -0000	1.2
@@ -62,8 +62,8 @@
 #ifndef _SV_LINECONV_HXX
 #define _SV_LINECONV_HXX
 
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_LINEINFO_HXX
 #include <lineinfo.hxx>
Index: vcl/source/gdi/impprn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impprn.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/gdi/impprn.cxx	27 Mar 2003 17:57:57 -0000	1.5
+++ vcl/source/gdi/impprn.cxx	6 Jan 2004 13:44:52 -0000	1.7
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#ifndef REMOTE_APPSERVER
-
-#define _SV_IMPPRN_CXX
 #define _SPOOLPRINTER_EXT
 
 #ifndef _QUEUE_HXX
@@ -150,8 +147,6 @@ void ImplQPrinter::Destroy()
 
 void ImplQPrinter::ImplPrintMtf( GDIMetaFile& rMtf, long nMaxBmpDPIX, long nMaxBmpDPIY )
 {
-    const PrinterOptions& rPrinterOptions = GetPrinterOptions();
-
 	for( MetaAction* pAct = rMtf.FirstAction(); pAct && !mbAborted; pAct = rMtf.NextAction() )
 	{
 		const ULONG		nType = pAct->GetType();
@@ -191,8 +186,6 @@ void ImplQPrinter::ImplPrintMtf( GDIMeta
 
 				if( pAct && ( pAct->GetType() == META_BMPSCALE_ACTION ) )
 				{
-                    MetaBmpScaleAction* pBmpScaleAction = (MetaBmpScaleAction*) pAct;
-
                     // execute action here to avoid DPI processing of bitmap;
                     pAct->Execute( this );
 
@@ -403,8 +396,6 @@ IMPL_LINK( ImplQPrinter, ImplPrintHdl, T
 
 		for ( USHORT i = 0; i < nCopyCount; i++ )
 		{
-			ULONG nActionPos = 0UL;
-
 			if ( pActPage->mpSetup )
 			{
 				SetJobSetup( *pActPage->mpSetup );
@@ -476,5 +467,3 @@ void ImplQPrinter::AddQueuePage( GDIMeta
 		pQueuePage->mpSetup = new JobSetup( mpParent->GetJobSetup() );
 	mpQueue->Put( pQueuePage );
 }
-
-#endif
Index: vcl/source/gdi/impvect.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impvect.cxx,v
retrieving revision 1.3.120.1
retrieving revision 1.5
diff -u -p -u -r1.3.120.1 -r1.5
--- vcl/source/gdi/impvect.cxx	15 Jan 2004 14:03:27 -0000	1.3.120.1
+++ vcl/source/gdi/impvect.cxx	2 Mar 2004 10:35:43 -0000	1.5
@@ -59,15 +59,13 @@
  *
  ************************************************************************/
 
-#define _SV_IMPVECT_CXX
-
 #include <stdlib.h>
 #include <tools/new.hxx>
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_GDIMTF_HXX
 #include <gdimtf.hxx>
@@ -88,19 +86,6 @@
 #include <impvect.hxx>
 #endif
 
-// !!! ggf. einkommentieren, um Bitmaps zu erzeugen (nur, wenn File mit Debug uebersetzt wurde)
-// #define DEBUG_BMPOUTPUT
-
-#if (OSL_DEBUG_LEVEL > 1) && defined DEBUG_BMPOUTPUT
-#define DBG_BMP 1
-#else
-#undef	DBG_BMP
-#endif
-
-#ifdef DBG_BMP
-#include <tools/stream.hxx>
-#endif
-
 // -----------
 // - Defines -
 // -----------
@@ -221,15 +206,9 @@ extern "C" int __LOADONCALLAPI ImplColor
 // - ImplPointArray -
 // ------------------
 
-#ifdef WIN
-typedef Point* huge HPPoint;
-#else
-typedef Point*		HPPoint;
-#endif
-
 class ImplPointArray
 {
-	HPPoint				mpArray;
+	Point*				mpArray;
 	ULONG				mnSize;
 	ULONG				mnRealSize;
 
@@ -252,9 +231,9 @@ public:
 // -----------------------------------------------------------------------------
 
 ImplPointArray::ImplPointArray() :
+	mpArray		( NULL ),
 	mnSize		( 0UL ),
-	mnRealSize	( 0UL ),
-	mpArray		( NULL )
+	mnRealSize	( 0UL )
 
 {
 }
@@ -279,8 +258,8 @@ void ImplPointArray::ImplSetSize( ULONG 
 	if( mpArray )
 		SvMemFree( mpArray );
 
-	mpArray = (HPPoint) SvMemAlloc( nTotal );
-	HMEMSET( (HPBYTE) mpArray, 0, nTotal );
+	mpArray = (Point*) SvMemAlloc( nTotal );
+	memset( (HPBYTE) mpArray, 0, nTotal );
 }
 
 // -----------------------------------------------------------------------------
@@ -336,9 +315,6 @@ public:
 	inline BOOL		IsCont( long nY, long nX ) const;
 	inline BOOL		IsDone( long nY, long nX ) const;
 
-#ifdef DBG_BMP
-	Bitmap			GetBitmap() const;
-#endif // DBG_BMP
 };
 
 // -----------------------------------------------------------------------------
@@ -351,7 +327,7 @@ ImplVectMap::ImplVectMap( long nWidth, l
 	const long	nSize = nWidthAl * nHeight;
 	Scanline	pTmp = mpBuf = (Scanline) SvMemAlloc( nSize );
 
-	HMEMSET( mpBuf, 0, nSize );
+	memset( mpBuf, 0, nSize );
 	mpScan = (Scanline*) SvMemAlloc( nHeight * sizeof( Scanline ) );
 
 	for( long nY = 0L; nY < nHeight; pTmp += nWidthAl )
@@ -403,36 +379,6 @@ inline BOOL ImplVectMap::IsDone( long nY
 	return( VECT_DONE_INDEX == Get( nY, nX ) );
 }
 
-// -----------------------------------------------------------------------------
-
-#ifdef DBG_BMP
-Bitmap ImplVectMap::GetBitmap() const
-{
-	Bitmap				aBmp( Size( mnWidth, mnHeight ), 4 );
-	BitmapWriteAccess*	pAcc = aBmp.AcquireWriteAccess();
-
-	if( pAcc )
-	{
-		for( long nY = 0L; nY < mnHeight; nY++ )
-		{
-			for( long nX = 0L; nX < mnWidth; nX++ )
-			{
-				switch( Get( nY, nX ) )
-				{
-					case( VECT_FREE_INDEX ): pAcc->SetPixel( nY, nX, 15 ); break;
-					case( VECT_CONT_INDEX ): pAcc->SetPixel( nY, nX, 0 ); break;
-					case( VECT_DONE_INDEX ): pAcc->SetPixel( nY, nX, 2); break;
-				}
-			}
-		}
-
-		aBmp.ReleaseAccess( pAcc );
-	}
-
-	return aBmp;
-}
-#endif // DBG_BMP
-
 // -------------
 // - ImplChain -
 // -------------
@@ -470,8 +416,8 @@ public:
 // -----------------------------------------------------------------------------
 
 ImplChain::ImplChain( ULONG nInitCount, long nResize ) :
-	mnCount		( 0UL ),
 	mnArraySize	( nInitCount ),
+	mnCount		( 0UL ),
 	mnResize	( nResize )
 {
 	DBG_ASSERT( nInitCount && nResize, "ImplChain::ImplChain(): invalid parameters!" );
@@ -494,7 +440,7 @@ void ImplChain::ImplGetSpace()
 
 	mnArraySize = ( mnResize < 0L ) ? ( mnArraySize << 1UL ) : ( mnArraySize + (ULONG) mnResize );
 	pNewCodes = new BYTE[ mnArraySize ];
-	HMEMCPY( pNewCodes, mpCodes, nOldArraySize );
+	memcpy( pNewCodes, mpCodes, nOldArraySize );
 	delete[] mpCodes;
 	mpCodes = pNewCodes;
 }
@@ -542,7 +488,7 @@ void ImplChain::ImplEndAdd( ULONG nFlag 
 				const BYTE				cNextMove = mpCodes[ i + 1 ];
 				const ChainMove&		rMove = aImplMove[ cMove ];
 				const ChainMove&		rMoveInner = aImplMoveInner[ cMove ];
-				Point&					rPt = aArr[ nPolyPos ];
+//				Point&					rPt = aArr[ nPolyPos ];
 				BOOL					bDone = TRUE;
 
 				nLastX += rMove.nDX;
@@ -649,7 +595,7 @@ void ImplChain::ImplEndAdd( ULONG nFlag 
 				const BYTE				cNextMove = mpCodes[ i + 1 ];
 				const ChainMove&		rMove = aImplMove[ cMove ];
 				const ChainMove&		rMoveOuter = aImplMoveOuter[ cMove ];
-				Point&					rPt = aArr[ nPolyPos ];
+//				Point&					rPt = aArr[ nPolyPos ];
 				BOOL					bDone = TRUE;
 
 				nLastX += rMove.nDX;
@@ -889,7 +835,7 @@ BOOL ImplVectorizer::ImplVectorize( cons
 		{
 			const BitmapColor	aBmpCol( pRAcc->GetPaletteColor( pColorSet[ i ].mnIndex ) );
 			const Color			aFindColor( aBmpCol.GetRed(), aBmpCol.GetGreen(), aBmpCol.GetBlue() );
-			const BYTE			cLum = aFindColor.GetLuminance();
+//			const BYTE			cLum = aFindColor.GetLuminance();
 			ImplVectMap*		pMap = ImplExpand( pRAcc, aFindColor );
 
 			VECT_PROGRESS( pProgress, FRound( fPercent += fPercentStep_2 ) );
@@ -977,7 +923,7 @@ BOOL ImplVectorizer::ImplVectorize( cons
 		if( nFlags & BMP_VECTORIZE_REDUCE_EDGES )
 			rPolyPoly.Optimize( POLY_OPTIMIZE_EDGES );
 
-        // #i14895:setting the correct direction for polygons
+        // #i14895#:setting the correct direction for polygons
         // that represent holes and non-holes; non-hole polygons
         // need to have a right orientation, holes need to have a
         // left orientation in order to be treated correctly by
@@ -1172,14 +1118,6 @@ void ImplVectorizer::ImplCalculate( Impl
 {
 	const long nWidth = pMap->Width(), nHeight= pMap->Height();
 
-#ifdef DBG_BMP
-	if( pMap )
-	{
-		SvFileStream aOStm( "d:\\cont.bmp", STREAM_WRITE | STREAM_TRUNC );
-		aOStm << pMap->GetBitmap();
-	}
-#endif // DBG_BMP
-
 	for( long nY = 0L; nY < nHeight; nY++ )
 	{
 		long	nX = 0L;
@@ -1241,14 +1179,6 @@ void ImplVectorizer::ImplCalculate( Impl
 			}
 		}
 	}
-
-#ifdef DBG_BMP
-	if( pMap )
-	{
-		SvFileStream aOStm( "d:\\vect.bmp", STREAM_WRITE | STREAM_TRUNC );
-		aOStm << pMap->GetBitmap();
-	}
-#endif // DBG_BMP
 }
 
 // -----------------------------------------------------------------------------
Index: vcl/source/gdi/impvect.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impvect.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/impvect.hxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/impvect.hxx	6 Jan 2004 13:45:39 -0000	1.2
@@ -62,8 +62,8 @@
 #ifndef _SV_IMPVECT_HXX
 #define _SV_IMPVECT_HXX
 
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_GDIMTF_HXX
 #include <gdimtf.hxx>
Index: vcl/source/gdi/jobset.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/jobset.cxx,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -p -u -r1.7 -r1.8
--- vcl/source/gdi/jobset.cxx	19 Jun 2002 11:20:42 -0000	1.7
+++ vcl/source/gdi/jobset.cxx	6 Jan 2004 13:46:09 -0000	1.8
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_JOBSET_CXX
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
Index: vcl/source/gdi/lineinfo.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/lineinfo.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/lineinfo.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/lineinfo.cxx	6 Jan 2004 13:46:37 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_LINEINFO_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
Index: vcl/source/gdi/mapmod.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/mapmod.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/gdi/mapmod.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/mapmod.cxx	17 Mar 2004 10:04:58 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_MAPMOD_CXX
-
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
@@ -137,12 +135,11 @@ SvStream& operator<<( SvStream& rOStm, c
 
 static ImplMapMode* ImplGetStaticMapMode( MapUnit eUnit )
 {
-    // Achtung: Ganz fies und dreckig !!!
-#ifdef WIN
-    static long _near aStaticImplMapModeAry[(MAP_LASTENUMDUMMY)*sizeof(ImplMapMode)/sizeof(long)];
-#else
     static long aStaticImplMapModeAry[(MAP_LASTENUMDUMMY)*sizeof(ImplMapMode)/sizeof(long)];
-#endif
+
+    // #i19496 check for out-of-bounds
+     if( eUnit >= MAP_LASTENUMDUMMY )
+        return (ImplMapMode*)aStaticImplMapModeAry;
 
     ImplMapMode* pImplMapMode = ((ImplMapMode*)aStaticImplMapModeAry)+eUnit;
     if ( !pImplMapMode->mbSimple )
Index: vcl/source/gdi/metaact.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/metaact.cxx,v
retrieving revision 1.11.112.1
retrieving revision 1.14
diff -u -p -u -r1.11.112.1 -r1.14
--- vcl/source/gdi/metaact.cxx	9 Jan 2004 18:13:44 -0000	1.11.112.1
+++ vcl/source/gdi/metaact.cxx	17 Jun 2004 12:17:25 -0000	1.14
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_METAACT_CXX
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 
 #include <algorithm>
@@ -1364,8 +1363,8 @@ MetaTextArrayAction::MetaTextArrayAction
 	{
 		const ULONG nAryLen = mnLen;
 
-		mpDXAry = new long[ nAryLen ];
-		memcpy( mpDXAry, rAction.mpDXAry, nAryLen * sizeof( long ) );
+		mpDXAry = new sal_Int32[ nAryLen ];
+		memcpy( mpDXAry, rAction.mpDXAry, nAryLen * sizeof( sal_Int32 ) );
 	}
 	else
 		mpDXAry = NULL;
@@ -1375,7 +1374,7 @@ MetaTextArrayAction::MetaTextArrayAction
 
 MetaTextArrayAction::MetaTextArrayAction( const Point& rStartPt,
 										  const XubString& rStr,
-										  const long* pDXAry,
+										  const sal_Int32* pDXAry,
 										  USHORT nIndex,
 										  USHORT nLen ) :
 	MetaAction	( META_TEXTARRAY_ACTION ),
@@ -1388,8 +1387,8 @@ MetaTextArrayAction::MetaTextArrayAction
 
 	if( nAryLen )
 	{
-		mpDXAry = new long[ nAryLen ];
-		memcpy( mpDXAry, pDXAry, nAryLen * sizeof( long ) );
+		mpDXAry = new sal_Int32[ nAryLen ];
+		memcpy( mpDXAry, pDXAry, nAryLen * sizeof( sal_Int32 ) );
 	}
 	else
 		mpDXAry = NULL;
@@ -1492,8 +1491,8 @@ void MetaTextArrayAction::Read( SvStream
 	if( nAryLen )
 	{
         // #i9762#, #106172# Ensure that DX array is at least mnLen entries long
-        const ULONG nIntAryLen( ::std::max(nAryLen, static_cast<ULONG>(mnLen)) );
-		mpDXAry = new long[ nIntAryLen ];
+        const ULONG nIntAryLen( Max(nAryLen, static_cast<ULONG>(mnLen)) );
+		mpDXAry = new sal_Int32[ nIntAryLen ];
         
         ULONG i;
 		for( i = 0UL; i < nAryLen; i++ )
@@ -3964,7 +3963,7 @@ void MetaCommentAction::ImplInitDynamicD
 	if ( nDataSize && pData )
 	{
 		mnDataSize = nDataSize, mpData = new BYTE[ mnDataSize ];
-		HMEMCPY( mpData, pData, mnDataSize );
+		memcpy( mpData, pData, mnDataSize );
 	}
 	else
 	{
Index: vcl/source/gdi/octree.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/octree.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/octree.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/octree.cxx	6 Jan 2004 13:48:20 -0000	1.2
@@ -70,16 +70,6 @@
 #endif
 #include <octree.hxx>
 
-// ------------
-// - Typedefs -
-// ------------
-
-#ifdef WIN
-typedef ULONG huge* HPULONG;
-#else
-typedef ULONG*      HPULONG;
-#endif
-
 // ---------
 // - pMask -
 // ---------
@@ -345,13 +335,11 @@ void Octree::GetPalIndex( PNODE pNode )
 InverseColorMap::InverseColorMap( const BitmapPalette& rPal ) :
             nBits( 8 - OCTREE_BITS )
 {
-    HPULONG         cdp;
+    ULONG*			cdp;
     BYTE*           crgbp;
     const ULONG     nColorMax = 1 << OCTREE_BITS;
     const ULONG     xsqr = 1 << ( nBits << 1 );
     const ULONG     xsqr2 = xsqr << 1;
-    const ULONG     gstride =  nColorMax;
-    const ULONG     rstride = nColorMax * nColorMax;
     const ULONG     nColors = rPal.GetEntryCount();
     const long      x = 1L << nBits;
     const long      x2 = x >> 1L;
@@ -378,7 +366,7 @@ InverseColorMap::InverseColorMap( const 
         cginc = ( xsqr - ( cGreen << nBits ) ) << 1L;
         cbinc = ( xsqr - ( cBlue << nBits ) ) << 1L;
 
-        cdp = (HPULONG) pBuffer;
+        cdp = (ULONG*) pBuffer;
         crgbp = pMap;
 
         for( r = 0, rxx = crinc; r < nColorMax; rdist += rxx, r++, rxx += xsqr2 )
@@ -412,8 +400,8 @@ void InverseColorMap::ImplCreateBuffers(
     const ULONG nSize = nCount * sizeof( ULONG );
 
     pMap = (BYTE*) SvMemAlloc( nCount );
-    HMEMSET( pMap, 0x00, nCount );
+    memset( pMap, 0x00, nCount );
 
     pBuffer = (BYTE*) SvMemAlloc( nSize );
-    HMEMSET( pBuffer, 0xff, nSize );
+    memset( pBuffer, 0xff, nSize );
 }
Index: vcl/source/gdi/opengl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/opengl.cxx,v
retrieving revision 1.5
retrieving revision 1.8
diff -u -p -u -r1.5 -r1.8
--- vcl/source/gdi/opengl.cxx	28 Apr 2003 17:09:40 -0000	1.5
+++ vcl/source/gdi/opengl.cxx	6 Jan 2004 13:48:43 -0000	1.8
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_OPENGL_CXX
-
 #define private public
 #include <svsys.h>
 #include <window.hxx>
@@ -79,6 +77,12 @@
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
+#ifndef _SV_SVDATA_HXX
+#include <svdata.hxx>
+#endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
 
 
 #include <svapp.hxx>
@@ -88,9 +92,7 @@
 // - Defines -
 // -----------
 
-#ifdef WIN
-#define __OPENGL_CALL _far _pascal
-#elif defined WNT
+#ifdef WNT
 #define __OPENGL_CALL __stdcall
 #else
 #define __OPENGL_CALL
@@ -190,11 +192,7 @@ typedef void ( __OPENGL_CALL *OGLFncBlen
 
 #define PGRAPHICS mpOutDev->mpGraphics
 
-#ifndef REMOTE_APPSERVER
 #define OGL_INIT() (mpOGL && (mpOutDev->mpGraphics || mpOutDev->ImplGetGraphics()))
-#else
-#define OGL_INIT() (mpOGL && (mpOutDev->mpGraphics || mpOutDev->ImplGetGraphics()))
-#endif
 
 #define INIT_OGLFNC( FncName ) static OGLFnc##FncName pImplOpenGLFnc##FncName = NULL;
 #define GET_OGLFNC_GL( FncName )													\
@@ -297,7 +295,6 @@ INIT_OGLFNC( BlendFunc );
 
 BOOL OpenGL::ImplInitFncPointers()
 {
-#ifndef REMOTE_APPSERVER
 	BOOL bRet = TRUE;
 
 	GET_OGLFNC_GL( ClearDepth );
@@ -387,9 +384,6 @@ BOOL OpenGL::ImplInitFncPointers()
 	GET_OGLFNC_GL( BlendFunc );
 
 	return bRet;
-#else
-	return FALSE;
-#endif
 }
 
 BOOL OpenGL::mbNoOGL = FALSE;
@@ -406,22 +400,18 @@ OpenGL::OpenGL( OutputDevice* pOutDev ) 
 
 OpenGL::~OpenGL()
 {
-#ifndef REMOTE_APPSERVER
 	delete mpOGL;
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ImplInit()
 {
-#ifndef REMOTE_APPSERVER
 	if( ( PGRAPHICS || mpOutDev->ImplGetGraphics() ) && ! mbNoOGL )
 	{
-		mpOGL = new SalOpenGL( PGRAPHICS );
+		mpOGL = ImplGetSVData()->mpDefInst->CreateSalOpenGL( PGRAPHICS );
 
-		if ( !mpOGL->Create() || (!bImplOpenGLFncPtrInitialized && !ImplInitFncPointers()) )
+		if ( !mpOGL->IsValid() || (!bImplOpenGLFncPtrInitialized && !ImplInitFncPointers()) )
 		{
 			delete mpOGL;
 			mpOGL = NULL;
@@ -431,133 +421,105 @@ void OpenGL::ImplInit()
 	}
 	else
 		mpOGL = NULL;
-#else
-	mpOGL = NULL;
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::SetConnectOutputDevice( OutputDevice* pOutDev )
 {
-#ifndef REMOTE_APPSERVER
 	delete mpOGL;
 	mpOutDev = pOutDev;
 	ImplInit();
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ClearDepth( GLclampd fDepth )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncClearDepth( fDepth );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DepthFunc( GLenum eFunc )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDepthFunc( eFunc );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Enable( GLenum eCap )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEnable( eCap );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Disable( GLenum eCap )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDisable( eCap );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DepthMask( GLboolean bFlag )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDepthMask( bFlag );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ShadeModel( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncShadeModel( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::EdgeFlag( GLboolean bFlag )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEdgeFlag( bFlag );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Clear( GLbitfield nMask )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 #if defined UNX && ! defined MACOSX
@@ -567,30 +529,24 @@ void OpenGL::Clear( GLbitfield nMask )
 		pImplOpenGLFncClear( nMask );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Flush()
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncFlush();
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Finish()
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
@@ -600,15 +556,12 @@ void OpenGL::Finish()
 #endif
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Viewport( GLint nX, GLint nY, GLsizei nWidth, GLsizei nHeight )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		long nOutHeight;
@@ -625,7 +578,7 @@ void OpenGL::Viewport( GLint nX, GLint n
         {
             long lx = nX + mpOutDev->mnOutOffX;
             long lwidth = nWidth;
-            ((SalGraphicsLayout*)mpOutDev->mpGraphics)->mirror( lx, lwidth, mpOutDev );
+            mpOutDev->mpGraphics->mirror( lx, lwidth, mpOutDev );
             nX = lx - mpOutDev->mnOutOffX;
         }
 		pImplOpenGLFncViewport( nX + mpOutDev->mnOutOffX,
@@ -634,549 +587,438 @@ void OpenGL::Viewport( GLint nX, GLint n
 
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Begin( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncBegin( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::End()
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEnd();
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Vertex3dv( const GLdouble* fVar )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncVertex3dv( fVar );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Normal3dv( const GLdouble* fVar )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncNormal3dv( fVar );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Color4ub( GLubyte cRed, GLubyte cGreen, GLubyte cBlue, GLubyte cAlpha )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncColor4ub( cRed, cGreen, cBlue, cAlpha );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Materialfv( GLenum eFace, GLenum ePName, const GLfloat *fParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncMaterialfv( eFace, ePName, fParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Materialf( GLenum eFace, GLenum ePName, GLfloat fParam )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncMaterialf( eFace, ePName, fParam );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LightModelfv( GLenum ePName, const GLfloat *fParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightModelfv( ePName, fParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LightModelf( GLenum ePName, GLfloat fParam )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightModelf( ePName, fParam );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Lightfv( GLenum eLight, GLenum ePName, const GLfloat *fParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightfv( eLight, ePName, fParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Lightf( GLenum eLight, GLenum ePName, GLfloat fParam )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightf( eLight, ePName, fParam );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PolygonMode( GLenum eFace, GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPolygonMode( eFace, eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CullFace( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCullFace( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PointSize( GLfloat fSize )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPointSize( fSize );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LineWidth( GLfloat fWidth )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLineWidth( fWidth );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::MatrixMode( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncMatrixMode( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LoadMatrixd( const GLdouble *fM )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLoadMatrixd( fM );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexCoord2dv( const GLdouble *pParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexCoord2dv( pParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexCoord3dv( const GLdouble *fVar )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexCoord3dv( fVar );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexImage1D( GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexImage1D( target, level, internalformat, width, border, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexImage2D( GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexImage2D( target, level, internalformat, width, height, border, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexImage1D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexImage1D( target, level, internalFormat, x, y, width, border );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexImage2D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexImage2D( target, level, internalFormat, x, y, width, height, border );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexSubImage1D( target, level, xoffset, x, y, width );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexSubImage2D( target, level, xoffset, yoffset, x, y, width, height );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelTransferf( GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelTransferf( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelTransferi( GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelTransferi( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexLevelParameterfv( GLenum target, GLint level, GLenum pname, GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexLevelParameterfv( target, level, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexLevelParameteriv( GLenum target, GLint level, GLenum pname, GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexLevelParameteriv( target, level, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexParameterfv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexParameteriv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexSubImage1D( target, level, xoffset, width, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexSubImage2D( target, level, xoffset, yoffset, width, height, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelStoref( GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelStoref( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelStorei( GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelStorei( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GenTextures( GLsizei n, GLuint *textures )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGenTextures( n, textures );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
@@ -1185,16 +1027,12 @@ GLboolean OpenGL::IsTexture( GLuint text
 {
 	GLboolean bRet = FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		bRet = pImplOpenGLFncIsTexture( texture );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
-
 	return bRet;
 }
 
@@ -1202,30 +1040,24 @@ GLboolean OpenGL::IsTexture( GLuint text
 
 void OpenGL::BindTexture( GLenum target, GLuint texture )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncBindTexture( target, texture );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DeleteTextures( GLsizei n, const GLuint *textures )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDeleteTextures( n, textures );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
@@ -1233,17 +1065,12 @@ void OpenGL::DeleteTextures( GLsizei n, 
 GLboolean OpenGL::AreTexturesResident( GLsizei n, const GLuint *textures, GLboolean *residences )
 {
 	GLboolean bRet = FALSE;
-
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		bRet = pImplOpenGLFncAreTexturesResident( n, textures, residences );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
-
 	return bRet;
 }
 
@@ -1251,262 +1078,210 @@ GLboolean OpenGL::AreTexturesResident( G
 
 void OpenGL::PrioritizeTextures( GLsizei n, const GLuint *textures, const GLclampf *priorities )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPrioritizeTextures( n, textures, priorities );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnvf( GLenum target, GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnvf( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnvfv( GLenum target, GLenum pname, const GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnvfv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnvi( GLenum target, GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnvi( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnviv( GLenum target, GLenum pname, const GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnviv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameterf( GLenum target, GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameterf( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameterfv( GLenum target, GLenum pname, const GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameterfv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameteri( GLenum target, GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameteri( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameteriv( GLenum target, GLenum pname, const GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameteriv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGend( GLenum coord, GLenum pname, GLdouble param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGend( coord, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGendv( GLenum coord, GLenum pname, const GLdouble *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGendv( coord, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGenf( GLenum coord, GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGenf( coord, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGenfv( coord, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGeni( GLenum coord, GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGeni( coord, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGeniv( GLenum coord, GLenum pname, const GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGeniv( coord, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetIntegerv( GLenum pname, GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetIntegerv( pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PolygonOffset( GLfloat factor, GLfloat units )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPolygonOffset( factor, units );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Scissor( GLint nX, GLint nY, GLsizei nWidth, GLsizei nHeight )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		long nOutHeight;
@@ -1523,7 +1298,7 @@ void OpenGL::Scissor( GLint nX, GLint nY
         {
             long lx = nX + mpOutDev->mnOutOffX;
             long lwidth = nWidth;
-            ((SalGraphicsLayout*)mpOutDev->mpGraphics)->mirror( lx, lwidth, mpOutDev );
+            mpOutDev->mpGraphics->mirror( lx, lwidth, mpOutDev );
             nX = lx - mpOutDev->mnOutOffX;
         }
 		pImplOpenGLFncScissor( nX + mpOutDev->mnOutOffX,
@@ -1531,217 +1306,173 @@ void OpenGL::Scissor( GLint nX, GLint nY
 					 nWidth, nHeight );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::EnableClientState( GLenum array )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEnableClientState( array );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DisableClientState( GLenum array )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDisableClientState( array );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::VertexPointer( GLint size, GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncVertexPointer( size, type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ColorPointer( GLint size, GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncColorPointer( size, type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::IndexPointer( GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncIndexPointer( type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::NormalPointer( GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncNormalPointer( type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexCoordPointer( GLint size, GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexCoordPointer( size, type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::EdgeFlagPointer( GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEdgeFlagPointer( stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ArrayElement( GLint i )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncArrayElement( i );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DrawElements( GLenum mode, GLsizei count, GLenum type, const GLvoid *indices )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDrawElements( mode, count, type, indices );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DrawArrays( GLenum mode, GLint first, GLsizei count )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDrawArrays( mode, first, count );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::InterleavedArrays( GLenum format, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncInterleavedArrays( format, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LoadIdentity( )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLoadIdentity();
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::BlendFunc( GLenum sfactor, GLenum dfactor )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncBlendFunc( sfactor, dfactor);
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
Index: vcl/source/gdi/outdev.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev.cxx,v
retrieving revision 1.23
retrieving revision 1.29
diff -u -p -u -r1.23 -r1.29
--- vcl/source/gdi/outdev.cxx	24 Apr 2003 10:27:08 -0000	1.23
+++ vcl/source/gdi/outdev.cxx	3 Feb 2004 16:45:04 -0000	1.29
@@ -59,15 +59,10 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
 #include <tools/ref.hxx>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
@@ -83,12 +78,6 @@
 #ifndef _SV_SALPRN_HXX
 #include <salprn.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -153,8 +142,8 @@
 #include <com/sun/star/awt/XGraphics.hpp>
 
 DBG_NAME( OutputDevice );
-DBG_NAMEEX( Polygon );
-DBG_NAMEEX( PolyPolygon );
+DBG_NAME( Polygon );
+DBG_NAME( PolyPolygon );
 DBG_NAMEEX( Region );
 
 // -----------------------------------------------------------------------
@@ -184,19 +173,21 @@ const char* ImplDbgCheckOutputDevice( co
 
 struct ImplObjStack
 {
-	ImplObjStack*	mpPrev;
-	MapMode*		mpMapMode;
-	Region* 		mpClipRegion;
-	Color*			mpLineColor;
-	Color*			mpFillColor;
-	Font*			mpFont;
-	Color*			mpTextColor;
-	Color*			mpTextFillColor;
-	Color*			mpTextLineColor;
-	Point*			mpRefPoint;
-	TextAlign		meTextAlign;
-	RasterOp		meRasterOp;
-	USHORT			mnFlags;
+    ImplObjStack*   mpPrev;
+    MapMode*        mpMapMode;
+    Region*         mpClipRegion;
+    Color*          mpLineColor;
+    Color*          mpFillColor;
+    Font*           mpFont;
+    Color*          mpTextColor;
+    Color*          mpTextFillColor;
+    Color*          mpTextLineColor;
+    Point*          mpRefPoint;
+    TextAlign       meTextAlign;
+    RasterOp        meRasterOp;
+    ULONG           mnTextLayoutMode;
+    LanguageType    meTextLanguage;
+    USHORT          mnFlags;
 };
 
 // -----------------------------------------------------------------------
@@ -248,7 +239,6 @@ static void ImplDeleteObjStack( ImplObjS
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 
 BOOL OutputDevice::ImplSelectClipRegion( SalGraphics* pGraphics, const Region& rRegion, OutputDevice *pOutDev )
 {
@@ -277,7 +267,6 @@ BOOL OutputDevice::ImplSelectClipRegion(
 	return bClipRegion;
 }
 
-#endif
 
 // =======================================================================
 
@@ -305,7 +294,6 @@ PolyPolygon ImplSubdivideBezier( const P
 
 // =======================================================================
 
-#ifndef REMOTE_APPSERVER
 // #100127# Extracted from OutputDevice::DrawPolyPolygon()
 void OutputDevice::ImplDrawPolyPolygon( USHORT nPoly, const PolyPolygon& rPolyPoly )
 {
@@ -390,15 +378,14 @@ void OutputDevice::ImplDrawPolyPolygon( 
         delete[] pFlagAryAry;
     }
 }
-#endif
 
 // =======================================================================
 
 OutputDevice::OutputDevice() :
 	maRegion( REGION_NULL ),
-	maSettings( Application::GetSettings() ),
 	maFillColor( COL_WHITE ),
-	maTextLineColor( COL_TRANSPARENT )
+	maTextLineColor( COL_TRANSPARENT ),
+	maSettings( Application::GetSettings() )
 {
 	DBG_CTOR( OutputDevice, ImplDbgCheckOutputDevice );
 
@@ -416,6 +403,7 @@ OutputDevice::OutputDevice() :
 	mpOutDevData		= NULL;
 	mp3DContext 		= NULL;
     mpPDFWriter			= NULL;
+    mpAlphaVDev			= NULL;
 	mnOutOffX			= 0;
 	mnOutOffY			= 0;
 	mnOutWidth			= 0;
@@ -442,7 +430,6 @@ OutputDevice::OutputDevice() :
 	mbDevOutput 		= FALSE;
 	mbOutputClipped 	= FALSE;
 	maTextColor 		= maFont.GetColor();
-	maTextFillColorDummy= maFont.GetFillColor();
 	meTextAlign 		= maFont.GetAlign();
 	meRasterOp			= ROP_OVERPAINT;
 	mnAntialiasing		= 0;
@@ -523,6 +510,8 @@ OutputDevice::~OutputDevice()
         mpFontList->Clear();
         delete mpFontList;
     }
+
+    delete mpAlphaVDev;
 }
 
 // -----------------------------------------------------------------------
@@ -540,17 +529,18 @@ void OutputDevice::EnableRTL( BOOL bEnab
             if( ImplGetGraphics() )
                 mpGraphics->SetLayout( mbEnableRTL ? SAL_LAYOUT_BIDI_RTL : 0 );
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->EnableRTL( bEnable );
 }
 
 BOOL OutputDevice::ImplHasMirroredGraphics()
 {
-#ifndef REMOTE_APPSERVER
     return ( ImplGetGraphics() && (mpGraphics->GetLayout() & SAL_LAYOUT_BIDI_RTL) );
-#else
-    return FALSE;
-#endif
 }
 
+// note: the coordiantes to be remirrored are in frame coordiantes !
+
 void    OutputDevice::ImplReMirror( Point &rPoint ) const
 {
     rPoint.X() = mnOutOffX + mnOutWidth - 1 - rPoint.X() + mnOutOffX; 
@@ -590,8 +580,6 @@ void    OutputDevice::ImplReMirror( Regi
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
-
 int OutputDevice::ImplGetGraphics() const
 {
 	DBG_TESTSOLARMUTEX();
@@ -824,8 +812,6 @@ void OutputDevice::ImplReleaseGraphics( 
 	}
 }
 
-#endif
-
 // -----------------------------------------------------------------------
 
 void OutputDevice::ImplInitOutDevData()
@@ -871,7 +857,6 @@ void OutputDevice::ImplInitLineColor()
 {
 	DBG_TESTSOLARMUTEX();
 
-#ifndef REMOTE_APPSERVER
 	if( mbLineColor )
 	{
 		if( ROP_0 == meRasterOp )
@@ -885,9 +870,6 @@ void OutputDevice::ImplInitLineColor()
 	}
 	else
 		mpGraphics->SetLineColor();
-#else
-	mpGraphics->SetLineColor( maLineColor );
-#endif
 
 	mbInitLineColor = FALSE;
 }
@@ -898,7 +880,6 @@ void OutputDevice::ImplInitFillColor()
 {
 	DBG_TESTSOLARMUTEX();
 
-#ifndef REMOTE_APPSERVER
 	if( mbFillColor )
 	{
 		if( ROP_0 == meRasterOp )
@@ -912,9 +893,6 @@ void OutputDevice::ImplInitFillColor()
 	}
 	else
 		mpGraphics->SetFillColor();
-#else
-	mpGraphics->SetFillColor( maFillColor );
-#endif
 
 	mbInitFillColor = FALSE;
 }
@@ -950,11 +928,7 @@ void OutputDevice::ImplInitClipRegion()
 		else
 		{
 			mbOutputClipped = FALSE;
-#ifndef REMOTE_APPSERVER
 			ImplSelectClipRegion( mpGraphics, aRegion, this );
-#else
-			mpGraphics->SetClipRegion( aRegion );
-#endif
 		}
 		mbClipRegionSet = TRUE;
 	}
@@ -967,13 +941,9 @@ void OutputDevice::ImplInitClipRegion()
 			else
 			{
 				mbOutputClipped = FALSE;
-#ifndef REMOTE_APPSERVER
 				ImplSelectClipRegion( mpGraphics, 
                                       // #102532# Respect output offset also for clip region
                                       ImplPixelToDevicePixel( maRegion ), this );
-#else
-				mpGraphics->SetClipRegion( maRegion );
-#endif
 			}
 
 			mbClipRegionSet = TRUE;
@@ -982,11 +952,7 @@ void OutputDevice::ImplInitClipRegion()
 		{
 			if ( mbClipRegionSet )
 			{
-#ifndef REMOTE_APPSERVER
 				mpGraphics->ResetClipRegion();
-#else
-				mpGraphics->SetClipRegion();
-#endif
 				mbClipRegionSet = FALSE;
 			}
 
@@ -1031,6 +997,9 @@ void OutputDevice::SetClipRegion()
 		mpMetaFile->AddAction( new MetaClipRegionAction( Region(), FALSE ) );
 
 	ImplSetClipRegion( NULL );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetClipRegion();
 }
 
 // -----------------------------------------------------------------------
@@ -1051,6 +1020,9 @@ void OutputDevice::SetClipRegion( const 
 		Region aRegion = LogicToPixel( rRegion );
 		ImplSetClipRegion( &aRegion );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetClipRegion( rRegion );
 }
 
 // -----------------------------------------------------------------------
@@ -1101,6 +1073,9 @@ void OutputDevice::MoveClipRegion( long 
 					   ImplLogicHeightToDevicePixel( nVertMove ) );
 		mbInitClipRegion = TRUE;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->MoveClipRegion( nHorzMove, nVertMove );
 }
 
 // -----------------------------------------------------------------------
@@ -1117,6 +1092,9 @@ void OutputDevice::IntersectClipRegion( 
 	maRegion.Intersect( aRect );
 	mbClipRegion		= TRUE;
 	mbInitClipRegion	= TRUE;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->IntersectClipRegion( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -1139,6 +1117,9 @@ void OutputDevice::IntersectClipRegion( 
 		mbClipRegion		= TRUE;
 		mbInitClipRegion	= TRUE;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->IntersectClipRegion( rRegion );
 }
 
 // -----------------------------------------------------------------------
@@ -1149,6 +1130,9 @@ void OutputDevice::SetDrawMode( ULONG nD
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
 	mnDrawMode = nDrawMode;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetDrawMode( nDrawMode );
 }
 
 // -----------------------------------------------------------------------
@@ -1166,15 +1150,12 @@ void OutputDevice::SetRasterOp( RasterOp
 		meRasterOp = eRasterOp;
 		mbInitLineColor = mbInitFillColor = TRUE;
 
-#ifndef REMOTE_APPSERVER
 		if( mpGraphics || ImplGetGraphics() )
 			mpGraphics->SetXORMode( (ROP_INVERT == meRasterOp) || (ROP_XOR == meRasterOp) );
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if( pGraphics )
-			pGraphics->SetRasterOp( eRasterOp );
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRasterOp( eRasterOp );
 }
 
 // -----------------------------------------------------------------------
@@ -1193,6 +1174,9 @@ void OutputDevice::SetLineColor()
 		mbLineColor = FALSE;
 		maLineColor = Color( COL_TRANSPARENT );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetLineColor();
 }
 
 // -----------------------------------------------------------------------
@@ -1258,6 +1242,9 @@ void OutputDevice::SetLineColor( const C
 			maLineColor = aColor;
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetLineColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -1276,6 +1263,9 @@ void OutputDevice::SetFillColor()
 		mbFillColor = FALSE;
 		maFillColor = Color( COL_TRANSPARENT );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetFillColor();
 }
 
 // -----------------------------------------------------------------------
@@ -1345,6 +1335,9 @@ void OutputDevice::SetFillColor( const C
 			maFillColor = aColor;
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetFillColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -1356,6 +1349,9 @@ void OutputDevice::SetBackground()
 
 	maBackground = Wallpaper();
 	mbBackground = FALSE;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetBackground();
 }
 
 // -----------------------------------------------------------------------
@@ -1371,6 +1367,9 @@ void OutputDevice::SetBackground( const 
 		mbBackground = FALSE;
 	else
 		mbBackground = TRUE;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetBackground( rBackground );
 }
 
 // -----------------------------------------------------------------------
@@ -1385,6 +1384,9 @@ void OutputDevice::SetRefPoint()
 
 	mbRefPoint = FALSE;
 	maRefPoint.X() = maRefPoint.Y() = 0L;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRefPoint();
 }
 
 // -----------------------------------------------------------------------
@@ -1399,6 +1401,9 @@ void OutputDevice::SetRefPoint( const Po
 
 	mbRefPoint = TRUE;
 	maRefPoint = rRefPoint;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRefPoint( rRefPoint );
 }
 
 // -----------------------------------------------------------------------
@@ -1414,7 +1419,6 @@ void OutputDevice::DrawLine( const Point
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	if ( !mpGraphics )
 	{
 		if ( !ImplGetGraphics() )
@@ -1433,16 +1437,9 @@ void OutputDevice::DrawLine( const Point
 	Point aEndPt = ImplLogicToDevicePixel( rEndPt );
 
 	mpGraphics->DrawLine( aStartPt.X(), aStartPt.Y(), aEndPt.X(), aEndPt.Y(), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		pGraphics->DrawLine( ImplLogicToDevicePixel( rStartPt ),
-							 ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawLine( rStartPt, rEndPt );
 }
 
 // -----------------------------------------------------------------------
@@ -1465,8 +1462,6 @@ void OutputDevice::DrawLine( const Point
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || ( LINE_NONE == rLineInfo.GetStyle() ) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
-
 	if( !mpGraphics && !ImplGetGraphics() )
 		return;
 
@@ -1523,60 +1518,8 @@ void OutputDevice::DrawLine( const Point
 		mpGraphics->DrawLine( aStartPt.X(), aStartPt.Y(), aEndPt.X(), aEndPt.Y(), this );
 	}
 
-#else
-
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		const LineInfo aInfo( ImplLogicToDevicePixel( rLineInfo ) );
-
-		if( ( aInfo.GetWidth() > 1L ) || ( LINE_DASH == aInfo.GetStyle() ) )
-		{
-			Polygon 			aPoly( 2 ); aPoly[ 0 ] = rStartPt; aPoly[ 1 ] = rEndPt;
-			GDIMetaFile*		pOldMetaFile = mpMetaFile;
-			ImplLineConverter	aLineCvt( ImplLogicToDevicePixel( aPoly ), aInfo, ( mbRefPoint ) ? &maRefPoint : NULL );
-
-			mpMetaFile = NULL;
-
-			if ( aInfo.GetWidth() > 1 )
-			{
-				const Color 	aOldLineColor( maLineColor );
-				const Color 	aOldFillColor( maFillColor );
-
-				SetLineColor();
-				ImplInitLineColor();
-				SetFillColor( aOldLineColor );
-				ImplInitFillColor();
-
-				for( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() )
-					pGraphics->DrawPolygon( *pPoly );
-
-				SetLineColor( aOldLineColor );
-				SetFillColor( aOldFillColor );
-			}
-			else
-			{
-				if ( mbInitLineColor )
-					ImplInitLineColor();
-
-				for ( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() ) {
-					Point xPoint((*pPoly)[ 0 ].X(), (*pPoly)[ 0 ].Y());
-					Point yPoint((*pPoly)[ 1 ].X(), (*pPoly)[ 1 ].Y());
-					mpGraphics->DrawLine( xPoint, yPoint );
-				}
-			}
-			mpMetaFile = pOldMetaFile;
-		}
-		else
-		{
-			if ( mbInitLineColor )
-				ImplInitLineColor();
-
-			pGraphics->DrawLine( ImplLogicToDevicePixel( rStartPt ), ImplLogicToDevicePixel( rEndPt ) );
-		}
-	}
-
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawLine( rStartPt, rEndPt, rLineInfo );
 }
 
 // -----------------------------------------------------------------------
@@ -1598,7 +1541,6 @@ void OutputDevice::DrawRect( const Recta
 		return;
 	aRect.Justify();
 
-#ifndef REMOTE_APPSERVER
 	if ( !mpGraphics )
 	{
 		if ( !ImplGetGraphics() )
@@ -1616,17 +1558,9 @@ void OutputDevice::DrawRect( const Recta
 		ImplInitFillColor();
 
 	mpGraphics->DrawRect( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawRect( aRect );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -1645,7 +1579,6 @@ void OutputDevice::DrawPolyLine( const P
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || (nPoints < 2) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -1679,22 +1612,9 @@ void OutputDevice::DrawPolyLine( const P
     {
         mpGraphics->DrawPolyLine( nPoints, pPtAry, this );
     }
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-
-        Polygon aPoly = ImplLogicToDevicePixel( rPoly );
 
-        // #100127# TODO: maybe extend Polygon::operator>>
-        if( aPoly.HasFlags() )
-            aPoly = ImplSubdivideBezier( aPoly );
-        
-        pGraphics->DrawPolyLine( aPoly );
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyLine( rPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -1728,7 +1648,6 @@ void OutputDevice::DrawPolyLine( const P
         nPoints = aPoly.GetSize();
     }
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics && !ImplGetGraphics() )
 		return;
@@ -1774,48 +1693,9 @@ void OutputDevice::DrawPolyLine( const P
 		else
 			mpGraphics->DrawPolyLine( nPoints, (const SalPoint*) aPoly.GetConstPointAry(), this );
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
 
-	if ( pGraphics )
-	{
-		const LineInfo aInfo( ImplLogicToDevicePixel( rLineInfo ) );
-
-		if( aInfo.GetWidth() > 1L )
-		{
-			const Color 		aOldLineColor( maLineColor );
-			const Color 		aOldFillColor( maFillColor );
-			GDIMetaFile*		pOldMetaFile = mpMetaFile;
-			ImplLineConverter	aLineCvt( aPoly, aInfo, ( mbRefPoint ) ? &maRefPoint : NULL );
-
-			mpMetaFile = NULL;
-			SetLineColor();
-			ImplInitLineColor();
-			SetFillColor( aOldLineColor );
-			ImplInitFillColor();
-
-			for( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() )
-				pGraphics->DrawPolygon( *pPoly );
-
-			SetLineColor( aOldLineColor );
-			SetFillColor( aOldFillColor );
-			mpMetaFile = pOldMetaFile;
-		}
-		else
-		{
-			if ( mbInitLineColor )
-				ImplInitLineColor();
-			if ( LINE_DASH == aInfo.GetStyle() )
-			{
-				ImplLineConverter	aLineCvt( aPoly, aInfo, ( mbRefPoint ) ? &maRefPoint : NULL );
-				for( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() )
-					pGraphics->DrawPolyLine( *pPoly );
-			}
-			else
-				pGraphics->DrawPolyLine( aPoly );
-		}
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyLine( rPoly, rLineInfo );
 }
 
 // -----------------------------------------------------------------------
@@ -1834,7 +1714,6 @@ void OutputDevice::DrawPolygon( const Po
 	if ( !IsDeviceOutputNecessary() || (!mbLineColor && !mbFillColor) || (nPoints < 2) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -1870,24 +1749,8 @@ void OutputDevice::DrawPolygon( const Po
     {
         mpGraphics->DrawPolygon( nPoints, pPtAry, this );
     }
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-
-        Polygon aPoly = ImplLogicToDevicePixel( rPoly );
-
-        // #100127# TODO: maybe extend Polygon::operator>>
-        if( aPoly.HasFlags() )
-            aPoly = ImplSubdivideBezier( aPoly );
-
-		pGraphics->DrawPolygon( aPoly );
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolygon( rPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -1906,7 +1769,6 @@ void OutputDevice::DrawPolyPolygon( cons
 	if ( !IsDeviceOutputNecessary() || (!mbLineColor && !mbFillColor) || !nPoly || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -1945,47 +1807,8 @@ void OutputDevice::DrawPolyPolygon( cons
         // ImplLogicToDevicePixel calls
         ImplDrawPolyPolygon( nPoly, ImplLogicToDevicePixel( rPolyPoly ) );
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		if ( nPoly == 1 )
-		{
-			Polygon aPoly = ImplLogicToDevicePixel( rPolyPoly.GetObject( 0 ) );
-			USHORT nSize = aPoly.GetSize();
-			if ( nSize >= 2 )
-            {
-                // #100127# TODO: maybe extend Polygon::operator>>
-                if( aPoly.HasFlags() )
-                    aPoly = ImplSubdivideBezier( aPoly );
-
-				pGraphics->DrawPolygon( aPoly );
-            }
-		}
-		else
-        {
-            PolyPolygon aPolyPoly = ImplLogicToDevicePixel( rPolyPoly );
-
-            USHORT i, nPoints = aPolyPoly.Count();
-            for( i=0; i<nPoints; ++i )
-            {
-                if( aPolyPoly.GetObject( i ).HasFlags() )
-                {
-                    // #100127# TODO: maybe extend Polygon::operator>>
-                    aPolyPoly = ImplSubdivideBezier( aPolyPoly );
-                    break;
-                }
-            }
-
-			pGraphics->DrawPolyPolygon( aPolyPoly );
-        }
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyPolygon( rPolyPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -2038,6 +1861,10 @@ void OutputDevice::Push( USHORT nFlags )
 	}
 	if ( nFlags & PUSH_TEXTALIGN )
 		pData->meTextAlign = GetTextAlign();
+	if( nFlags & PUSH_TEXTLAYOUTMODE )
+		pData->mnTextLayoutMode = GetLayoutMode();
+	if( nFlags & PUSH_TEXTLANGUAGE )
+		pData->meTextLanguage = GetDigitLanguage();
 	if ( nFlags & PUSH_RASTEROP )
 		pData->meRasterOp = GetRasterOp();
 	if ( nFlags & PUSH_MAPMODE )
@@ -2061,6 +1888,9 @@ void OutputDevice::Push( USHORT nFlags )
 		else
 			pData->mpRefPoint = NULL;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->Push();
 }
 
 // -----------------------------------------------------------------------
@@ -2083,6 +1913,9 @@ void OutputDevice::Pop()
 		return;
 	}
 
+    if( mpAlphaVDev )
+        mpAlphaVDev->Pop();
+
 	mpObjStack = pData->mpPrev;
 
 	if ( pData->mnFlags & PUSH_LINECOLOR )
@@ -2119,6 +1952,10 @@ void OutputDevice::Pop()
 	}
 	if ( pData->mnFlags & PUSH_TEXTALIGN )
 		SetTextAlign( pData->meTextAlign );
+	if( pData->mnFlags & PUSH_TEXTLAYOUTMODE )
+		SetLayoutMode( pData->mnTextLayoutMode );
+	if( pData->mnFlags & PUSH_TEXTLANGUAGE )
+		SetDigitLanguage( pData->meTextLanguage );
 	if ( pData->mnFlags & PUSH_RASTEROP )
 		SetRasterOp( pData->meRasterOp );
 	if ( pData->mnFlags & PUSH_MAPMODE )
@@ -2145,6 +1982,33 @@ void OutputDevice::Pop()
 
 // -----------------------------------------------------------------------
 
+void OutputDevice::SetConnectMetaFile( GDIMetaFile* pMtf ) 
+{ 
+    mpMetaFile = pMtf; 
+}
+
+// -----------------------------------------------------------------------
+
+void OutputDevice::EnableOutput( BOOL bEnable ) 
+{ 
+    mbOutput = (bEnable != 0); 
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->EnableOutput( bEnable );
+}
+
+// -----------------------------------------------------------------------
+
+void OutputDevice::SetSettings( const AllSettings& rSettings ) 
+{ 
+    maSettings = rSettings; 
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetSettings( rSettings );
+}
+
+// -----------------------------------------------------------------------
+
 USHORT OutputDevice::GetBitCount() const
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
@@ -2152,20 +2016,33 @@ USHORT OutputDevice::GetBitCount() const
 	if ( meOutDevType == OUTDEV_VIRDEV )
 		return ((VirtualDevice*)this)->mnBitCount;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
 		if ( !((OutputDevice*)this)->ImplGetGraphics() )
 			return 0;
 	}
-#endif
 
 	return (USHORT)mpGraphics->GetBitCount();
 }
 
 // -----------------------------------------------------------------------
 
+USHORT OutputDevice::GetAlphaBitCount() const
+{
+	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
+
+	if ( meOutDevType == OUTDEV_VIRDEV &&
+        mpAlphaVDev != NULL )
+    {
+		return mpAlphaVDev->GetBitCount();
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
 ULONG OutputDevice::GetColorCount() const
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
@@ -2176,11 +2053,17 @@ ULONG OutputDevice::GetColorCount() cons
 
 // -----------------------------------------------------------------------
 
+BOOL OutputDevice::HasAlpha()
+{
+    return mpAlphaVDev != NULL;
+}
+
+// -----------------------------------------------------------------------
+
 OpenGL* OutputDevice::GetOpenGL()
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
-#ifndef REMOTE_APPSERVER
 	OpenGL* pOGL;
 
 	if( OUTDEV_PRINTER != meOutDevType )
@@ -2197,9 +2080,6 @@ OpenGL* OutputDevice::GetOpenGL()
 		pOGL = NULL;
 
 	return pOGL;
-#else
-	return NULL;
-#endif
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/gdi/outdev2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev2.cxx,v
retrieving revision 1.13.112.1
retrieving revision 1.22
diff -u -p -u -r1.13.112.1 -r1.22
--- vcl/source/gdi/outdev2.cxx	15 Jan 2004 14:04:04 -0000	1.13.112.1
+++ vcl/source/gdi/outdev2.cxx	24 May 2004 15:24:50 -0000	1.22
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV2_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -112,12 +110,16 @@
 #ifndef _SV_WINDOW_HXX
 #include <window.hxx>
 #endif
-#ifdef REMOTE_APPSERVER
-#include <rmoutdev.hxx>
-#endif
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif
+#ifndef _SV_IMAGE_H
+#include <image.h>
+#endif
+#ifndef _SV_IMAGE_HXX
+#include <image.hxx>
+#endif
+
 #define BAND_MAX_SIZE 512000
 
 // =======================================================================
@@ -130,8 +132,6 @@ DBG_NAMEEX( OutputDevice );
 // - Defines -
 // -----------
 
-#ifndef REMOTE_APPSERVER
-
 #define OUTDEV_INIT()						\
 {											\
 	if ( !IsDeviceOutputNecessary() )		\
@@ -148,24 +148,7 @@ DBG_NAMEEX( OutputDevice );
 		return; 							\
 }
 
-#else // !REMOTE_APPSERVER
-
-#define OUTDEV_INIT()											\
-{																\
-	if ( !IsDeviceOutputNecessary() )							\
-		return; 												\
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();	\
-	if ( !pGraphics )											\
-		return; 												\
-}
-
-#endif // REMOTE_APPSERVER
-
-#ifndef REMOTE_APPSERVER
 #define TwoRect 	SalTwoRect
-#else
-#define TwoRect 	RemoteTwoRect
-#endif
 
 // -------------
 // - externals -
@@ -241,11 +224,7 @@ ULONG ImplAdjustTwoRect( TwoRect& rTwoRe
 void OutputDevice::ImplDrawOutDevDirect( const OutputDevice* pSrcDev, void* pVoidPosAry )
 {
 	TwoRect*			pPosAry = (TwoRect*)pVoidPosAry;
-#ifndef REMOTE_APPSERVER
 	SalGraphics*		pGraphics2;
-#else
-	ImplServerGraphics* pGraphics2;
-#endif
 
 	if ( pPosAry->mnSrcWidth && pPosAry->mnSrcHeight && pPosAry->mnDestWidth && pPosAry->mnDestHeight )
 	{
@@ -256,13 +235,11 @@ void OutputDevice::ImplDrawOutDevDirect(
 			if ( (GetOutDevType() != pSrcDev->GetOutDevType()) ||
 				 (GetOutDevType() != OUTDEV_WINDOW) )
 			{
-#ifndef REMOTE_APPSERVER
 				if ( !pSrcDev->mpGraphics )
 				{
 					if ( !((OutputDevice*)pSrcDev)->ImplGetGraphics() )
 						return;
 				}
-#endif
 				pGraphics2 = pSrcDev->mpGraphics;
 			}
 			else
@@ -271,16 +248,13 @@ void OutputDevice::ImplDrawOutDevDirect(
 					pGraphics2 = NULL;
 				else
 				{
-#ifndef REMOTE_APPSERVER
 					if ( !pSrcDev->mpGraphics )
 					{
 						if ( !((OutputDevice*)pSrcDev)->ImplGetGraphics() )
 							return;
 					}
-#endif
 					pGraphics2 = pSrcDev->mpGraphics;
 
-#ifndef REMOTE_APPSERVER
 					if ( !mpGraphics )
 					{
 						if ( !ImplGetGraphics() )
@@ -288,7 +262,6 @@ void OutputDevice::ImplDrawOutDevDirect(
 					}
 					DBG_ASSERT( mpGraphics && pSrcDev->mpGraphics,
 								"OutputDevice::DrawOutDev(): We need more than one Graphics" );
-#endif
 				}
 			}
 		}
@@ -324,7 +297,7 @@ void OutputDevice::ImplDrawOutDevDirect(
             if( (GetOutDevType() != OUTDEV_WINDOW) && pGraphics2 && (pGraphics2->GetLayout() & SAL_LAYOUT_BIDI_RTL) )
             {
 		        SalTwoRect pPosAry2 = *pPosAry;
-			    ((SalGraphicsLayout*)pGraphics2)->mirror( pPosAry2.mnSrcX, pPosAry2.mnSrcWidth, pSrcDev ); 
+			    pGraphics2->mirror( pPosAry2.mnSrcX, pPosAry2.mnSrcWidth, pSrcDev ); 
 			    mpGraphics->CopyBits( &pPosAry2, pGraphics2, this, pSrcDev );
             }
             else
@@ -401,6 +374,9 @@ void OutputDevice::DrawOutDev( const Poi
 			mpGraphics->CopyBits( &aPosAry, NULL, this, NULL );
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawOutDev( rDestPt, rDestSize, rSrcPt, rSrcSize );
 }
 
 // ------------------------------------------------------------------
@@ -442,7 +418,38 @@ void OutputDevice::DrawOutDev( const Poi
 	aPosAry.mnDestWidth  = ImplLogicWidthToDevicePixel( rDestSize.Width() );
 	aPosAry.mnDestHeight = ImplLogicHeightToDevicePixel( rDestSize.Height() );
 
-	ImplDrawOutDevDirect( &rOutDev, &aPosAry );
+    if( mpAlphaVDev )
+    {
+        if( rOutDev.mpAlphaVDev )
+        {
+            // alpha-blend source over destination
+            DrawBitmapEx( rDestPt, rDestSize, rOutDev.GetBitmapEx(rSrcPt, rSrcSize) );
+
+            // This would be mode SOURCE:
+            // copy source alpha channel to our alpha channel
+            //mpAlphaVDev->DrawOutDev( rDestPt, rDestSize, rSrcPt, rSrcSize, *rOutDev.mpAlphaVDev );
+        }
+        else
+        {
+            ImplDrawOutDevDirect( &rOutDev, &aPosAry );
+
+            // make destination rectangle opaque - source has no alpha
+            mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
+        }
+    }
+    else
+    {
+        if( rOutDev.mpAlphaVDev )
+        {
+            // alpha-blend source over destination
+            DrawBitmapEx( rDestPt, rDestSize, rOutDev.GetBitmapEx(rSrcPt, rSrcSize) );
+        }
+        else
+        {
+            // no alpha at all, neither in source nor destination device
+            ImplDrawOutDevDirect( &rOutDev, &aPosAry );
+        }
+    }
 }
 
 // ------------------------------------------------------------------
@@ -496,17 +503,10 @@ void OutputDevice::CopyArea( const Point
 															   aPosAry.mnDestY-aPosAry.mnSrcY,
 															   FALSE );
 
-#ifndef REMOTE_APPSERVER
 				mpGraphics->CopyArea( aPosAry.mnDestX, aPosAry.mnDestY,
 									  aPosAry.mnSrcX, aPosAry.mnSrcY,
 									  aPosAry.mnSrcWidth, aPosAry.mnSrcHeight,
 									  SAL_COPYAREA_WINDOWINVALIDATE, this );
-#else
-				mpGraphics->CopyArea( aPosAry.mnDestX, aPosAry.mnDestY,
-									  aPosAry.mnSrcX, aPosAry.mnSrcY,
-									  aPosAry.mnSrcWidth, aPosAry.mnSrcHeight,
-									  COPYAREA_WINDOWINVALIDATE );
-#endif
 			}
 			else
 			{
@@ -518,6 +518,9 @@ void OutputDevice::CopyArea( const Point
 	}
 
 	SetRasterOp( eOldRop );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->CopyArea( rDestPt, rSrcPt, rSrcSize, nFlags );
 }
 
 // ------------------------------------------------------------------
@@ -534,7 +537,6 @@ void OutputDevice::ImplDrawFrameDev( con
 	mbMap = FALSE;
 	SetRasterOp( ROP_OVERPAINT );
 
-#ifndef REMOTE_APPSERVER
 	if ( !IsDeviceOutputNecessary() )
 		return;
 
@@ -543,24 +545,12 @@ void OutputDevice::ImplDrawFrameDev( con
 		if ( !ImplGetGraphics() )
 			return;
 	}
-#else
-	if ( !IsDeviceOutputNecessary() )
-		return;
-
-#endif
 
 	// ClipRegion zuruecksetzen
-#ifndef REMOTE_APPSERVER
 	if ( rRegion.IsNull() )
 		mpGraphics->ResetClipRegion();
 	else
 		ImplSelectClipRegion( mpGraphics, rRegion, this );
-#else
-	if ( rRegion.IsNull() )
-		mpGraphics->SetClipRegion();
-	else
-		mpGraphics->SetClipRegion( rRegion );
-#endif
 
 	TwoRect aPosAry;
 	aPosAry.mnSrcX		 = rDevPt.X();
@@ -605,6 +595,9 @@ void OutputDevice::DrawBitmap( const Poi
 
 	const Size aSizePix( rBitmap.GetSizePixel() );
 	ImplDrawBitmap( rDestPt, PixelToLogic( aSizePix ), Point(), aSizePix, rBitmap, META_BMP_ACTION );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, PixelToLogic( aSizePix )) );
 }
 
 // ------------------------------------------------------------------
@@ -617,6 +610,9 @@ void OutputDevice::DrawBitmap( const Poi
         return;
 
 	ImplDrawBitmap( rDestPt, rDestSize, Point(), rBitmap.GetSizePixel(), rBitmap, META_BMPSCALE_ACTION );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // ------------------------------------------------------------------
@@ -631,6 +627,9 @@ void OutputDevice::DrawBitmap( const Poi
         return;
 
 	ImplDrawBitmap( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, rBitmap, META_BMPSCALEPART_ACTION );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // -----------------------------------------------------------------------------
@@ -721,15 +720,7 @@ void OutputDevice::ImplDrawBitmap( const
 			if ( nMirrFlags )
 				aBmp.Mirror( nMirrFlags );
 
-#ifndef REMOTE_APPSERVER
 			mpGraphics->DrawBitmap( &aPosAry, *aBmp.ImplGetImpBitmap()->ImplGetSalBitmap(), this );
-#else
-			aBmp.ImplDrawRemote( this,
-						Point( aPosAry.mnSrcX, aPosAry.mnSrcY ),
-						Size( aPosAry.mnSrcWidth, aPosAry.mnSrcHeight ),
-						Point( aPosAry.mnDestX, aPosAry.mnDestY ),
-						Size( aPosAry.mnDestWidth, aPosAry.mnDestHeight ) );
-#endif
 		}
 	}
 }
@@ -873,13 +864,11 @@ void OutputDevice::ImplDrawBitmapEx( con
         }
 	    return;
 	}
-#ifndef REMOTE_APPSERVER
 	else if( rBitmapEx.IsAlpha() )
 	{
 		ImplDrawAlpha( aBmpEx.GetBitmap(), aBmpEx.GetAlpha(), rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel );
 		return;
 	}
-#endif
 
 	if( !( !aBmpEx ) )
 	{
@@ -898,7 +887,6 @@ void OutputDevice::ImplDrawBitmapEx( con
 
 		if( aPosAry.mnSrcWidth && aPosAry.mnSrcHeight && aPosAry.mnDestWidth && aPosAry.mnDestHeight )
 		{
-#ifndef REMOTE_APPSERVER
 
 			if( nMirrFlags )
 				aBmpEx.Mirror( nMirrFlags );
@@ -967,22 +955,29 @@ void OutputDevice::ImplDrawBitmapEx( con
 				mpGraphics->DrawBitmap( &aPosAry, *pImpBmp->ImplGetSalBitmap(), 
                                         *pMaskBmp->ImplGetSalBitmap(), 
                                         this );
+
+                // #110958# Paint mask to alpha channel. Luckily, the
+                // black and white representation of the mask maps to
+                // the alpha channel 
+
+                // #i25167# Restrict mask painting to _opaque_ areas
+                // of the mask, otherwise we spoil areas where no
+                // bitmap content was ever visible. Interestingly
+                // enough, this can be achieved by taking the mask as
+                // the transparency mask of itself
+                if( mpAlphaVDev )
+                    mpAlphaVDev->DrawBitmapEx( rDestPt, 
+                                               rDestSize, 
+                                               BitmapEx( rBitmapEx.GetMask(),
+                                                         rBitmapEx.GetMask() ) );
             }
 			else
+            {
 				mpGraphics->DrawBitmap( &aPosAry, *pImpBmp->ImplGetSalBitmap(), this );
 
-#else
-
-			if( nMirrFlags )
-				aBmpEx.Mirror( nMirrFlags );
-
-			aBmpEx.ImplDrawRemote( this,
-					Point( aPosAry.mnSrcX, aPosAry.mnSrcY ),
-					Size( aPosAry.mnSrcWidth, aPosAry.mnSrcHeight ),
-					Point( aPosAry.mnDestX, aPosAry.mnDestY ),
-					Size( aPosAry.mnDestWidth, aPosAry.mnDestHeight ) );
-
-#endif
+                if( mpAlphaVDev )
+                    mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
+            }
 		}
 	}
 }
@@ -999,6 +994,10 @@ void OutputDevice::DrawMask( const Point
 
 	const Size aSizePix( rBitmap.GetSizePixel() );
 	ImplDrawMask( rDestPt, PixelToLogic( aSizePix ), Point(), aSizePix, rBitmap, rMaskColor, META_MASK_ACTION );
+
+    // TODO: Use mask here
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, PixelToLogic( aSizePix )) );
 }
 
 // ------------------------------------------------------------------
@@ -1012,6 +1011,10 @@ void OutputDevice::DrawMask( const Point
         return;
 
 	ImplDrawMask( rDestPt, rDestSize, Point(), rBitmap.GetSizePixel(), rBitmap, rMaskColor, META_MASKSCALE_ACTION );
+
+    // TODO: Use mask here
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // ------------------------------------------------------------------
@@ -1026,6 +1029,10 @@ void OutputDevice::DrawMask( const Point
         return;
 
 	ImplDrawMask( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, rBitmap, rMaskColor, META_MASKSCALEPART_ACTION );
+
+    // TODO: Use mask here
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // ------------------------------------------------------------------
@@ -1066,16 +1073,13 @@ void OutputDevice::ImplDrawMask( const P
 
 	OUTDEV_INIT();
 
-#ifndef REMOTE_APPSERVER
 	if ( OUTDEV_PRINTER == meOutDevType )
 	{
 		ImplPrintMask( rBitmap, rMaskColor, rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel );
 		return;
 	}
-#endif
 
 	const ImpBitmap* pImpBmp = rBitmap.ImplGetImpBitmap();
-
 	if ( pImpBmp )
 	{
 		TwoRect aPosAry;
@@ -1146,13 +1214,10 @@ Bitmap OutputDevice::GetBitmap( const Po
 	long	nWidth = ImplLogicWidthToDevicePixel( rSize.Width() );
 	long	nHeight = ImplLogicHeightToDevicePixel( rSize.Height() );
 
-#ifndef REMOTE_APPSERVER
 	if ( mpGraphics || ( (OutputDevice*) this )->ImplGetGraphics() )
-#endif
 	{
 		if ( nWidth && nHeight )
 		{
-#ifndef REMOTE_APPSERVER
 			Rectangle	aRect( Point( nX, nY ), Size( nWidth, nHeight ) );
 			BOOL		bClipped = FALSE;
 
@@ -1232,9 +1297,6 @@ Bitmap OutputDevice::GetBitmap( const Po
 					aBmp.ImplSetImpBitmap( pImpBmp );
 				}
 			}
-#else
-			aBmp.ImplGetRemoteBmp( (OutputDevice*) this, Point( nX, nY ), Size( nWidth, nHeight ) );
-#endif
 		}
 	}
 
@@ -1243,6 +1305,27 @@ Bitmap OutputDevice::GetBitmap( const Po
 
 // ------------------------------------------------------------------
 
+BitmapEx OutputDevice::GetBitmapEx( const Point& rSrcPt, const Size& rSize ) const
+{
+	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
+
+    // #110958# Extract alpha value from VDev, if any
+    if( mpAlphaVDev )
+    {
+        Bitmap aAlphaBitmap( mpAlphaVDev->GetBitmap( rSrcPt, rSize ) );
+
+        // ensure 8 bit alpha
+        if( aAlphaBitmap.GetBitCount() > 8 )
+            aAlphaBitmap.Convert( BMP_CONVERSION_8BIT_GREYS );
+
+        return BitmapEx(GetBitmap( rSrcPt, rSize ), AlphaMask( aAlphaBitmap ) );
+    }
+    else
+        return GetBitmap( rSrcPt, rSize );
+}
+
+// ------------------------------------------------------------------
+
 void OutputDevice::ImplGetFrameBitmap( const Point& rDestPt, const Size& rSize,
 									   Bitmap& rBitmap ) const
 {
@@ -1262,7 +1345,6 @@ Color OutputDevice::GetPixel( const Poin
 
 	Color aColor;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpGraphics || ((OutputDevice*)this)->ImplGetGraphics() )
 	{
 		if ( mbInitClipRegion )
@@ -1278,16 +1360,6 @@ Color OutputDevice::GetPixel( const Poin
 			aColor.SetBlue( SALCOLOR_BLUE( aSalCol ) );
 		}
 	}
-#else // REMOTE_APPSERVER
-	ImplServerGraphics* pGraphics = ( (OutputDevice*) this )->ImplGetServerGraphics();
-	if( pGraphics )
-	{
-		const long nX = ImplLogicXToDevicePixel( rPt.X() );
-		const long nY = ImplLogicYToDevicePixel( rPt.Y() );
-		aColor = pGraphics->GetPixel( Point( nX, nY ) );
-	}
-#endif // REMOTE_APPSERVER
-
 	return aColor;
 }
 
@@ -1302,7 +1374,6 @@ Color* OutputDevice::GetPixel( const Pol
 
 	if( nSize )
 	{
-#ifndef REMOTE_APPSERVER
 		if ( mpGraphics || ((OutputDevice*)this)->ImplGetGraphics() )
 		{
 			if ( mbInitClipRegion )
@@ -1325,13 +1396,6 @@ Color* OutputDevice::GetPixel( const Pol
 				}
 			}
 		}
-#else // REMOTE_APPSERVER
-		ImplServerGraphics* pGraphics = ( (OutputDevice*) this )->ImplGetServerGraphics();
-		if( pGraphics )
-		{
-			pColors = pGraphics->GetPixel( ImplLogicToDevicePixel( rPts ) );
-		}
-#endif // REMOTE_APPSERVER
 	}
 
 	return pColors;
@@ -1350,7 +1414,6 @@ void OutputDevice::DrawPixel( const Poin
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	Point aPt = ImplLogicToDevicePixel( rPt );
 
 	// we need a graphics
@@ -1369,15 +1432,9 @@ void OutputDevice::DrawPixel( const Poin
 		ImplInitLineColor();
 
 	mpGraphics->DrawPixel( aPt.X(), aPt.Y(), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		pGraphics->DrawPixel( ImplLogicToDevicePixel( rPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPt );
 }
 
 // -----------------------------------------------------------------------
@@ -1428,7 +1485,6 @@ void OutputDevice::DrawPixel( const Poin
 	if ( !IsDeviceOutputNecessary() || ImplIsColorTransparent( aColor ) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	Point aPt = ImplLogicToDevicePixel( rPt );
 
 	// we need a graphics
@@ -1444,11 +1500,9 @@ void OutputDevice::DrawPixel( const Poin
 		return;
 
 	mpGraphics->DrawPixel( aPt.X(), aPt.Y(), ImplColorToSal( aColor ), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-		pGraphics->DrawPixel( ImplLogicToDevicePixel( rPt ), aColor );
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPt );
 }
 
 // -----------------------------------------------------------------------
@@ -1474,7 +1528,6 @@ void OutputDevice::DrawPixel( const Poly
 			if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
 				return;
 
-#ifndef REMOTE_APPSERVER
 			// we need a graphics
 			if ( mpGraphics || ImplGetGraphics() )
 			{
@@ -1490,15 +1543,11 @@ void OutputDevice::DrawPixel( const Poly
 					mpGraphics->DrawPixel( aPt.X(), aPt.Y(), ImplColorToSal( pColors[ i ] ), this );
 				}
 			}
-#else
-			ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-			if ( pGraphics )
-			{
-				pGraphics->DrawPixel( ImplLogicToDevicePixel( rPts ), pColors );
-			}
-#endif
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPts, pColors );
 }
 
 // -----------------------------------------------------------------------
@@ -1516,6 +1565,9 @@ void OutputDevice::DrawPixel( const Poly
 		DrawPixel( rPts, pColArray );
 		delete[] pColArray;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPts, rColor );
 }
 
 // ------------------------------------------------------------------------
@@ -1552,6 +1604,8 @@ void OutputDevice::ImplDrawAlpha( const 
 
 	if( !aDstRect.Intersection( Rectangle( aOutPt, aOutSz ) ).IsEmpty() )
 	{
+        VirtualDevice* pOldVDev = mpAlphaVDev;
+
 		Rectangle aBmpRect( aPt, rBmp.GetSizePixel() );
 
 		if( !aBmpRect.Intersection( Rectangle( rSrcPtPixel, rSrcSizePixel ) ).IsEmpty() )
@@ -1567,6 +1621,11 @@ void OutputDevice::ImplDrawAlpha( const 
             // access)
             aDstRect.SetSize( aBmp.GetSizePixel() );
 
+            // #110958# Disable alpha VDev, we're doing the necessary
+            // stuff explicitely furher below
+            if( mpAlphaVDev )
+                mpAlphaVDev = NULL;
+
 			BitmapColor 	aDstCol;
 			const long		nSrcWidth = aBmpRect.GetWidth(), nSrcHeight = aBmpRect.GetHeight();
 			const long		nDstWidth = aDstRect.GetWidth(), nDstHeight = aDstRect.GetHeight();
@@ -1600,12 +1659,17 @@ void OutputDevice::ImplDrawAlpha( const 
 					pMapY[ nY ] = nMirrOffY - pMapY[ nY ];
 			}
 
+            BitmapReadAccess*	pP = ( (Bitmap&) rBmp ).AcquireReadAccess();
+            BitmapReadAccess*	pA = ( (AlphaMask&) rAlpha ).AcquireReadAccess();
+
+            DBG_ASSERT( pA->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL ||
+                        pA->GetScanlineFormat() == BMP_FORMAT_8BIT_TC_MASK, 
+                        "OutputDevice::ImplDrawAlpha(): non-8bit alpha no longer supported!" );
+            
 			if( GetBitCount() <= 8 )
 			{
 				Bitmap				aDither( aBmp.GetSizePixel(), 8 );
 				BitmapColor 		aIndex( 0 );
-				BitmapReadAccess*	pP = ( (Bitmap&) rBmp ).AcquireReadAccess();
-				BitmapReadAccess*	pA = ( (AlphaMask&) rAlpha ).AcquireReadAccess();
 				BitmapReadAccess*	pB = aBmp.AcquireReadAccess();
 				BitmapWriteAccess*	pW = aDither.AcquireWriteAccess();
 
@@ -1631,126 +1695,210 @@ void OutputDevice::ImplDrawAlpha( const 
 					}
 				}
 
-				( (Bitmap&) rBmp ).ReleaseAccess( pP );
-				( (AlphaMask&) rAlpha ).ReleaseAccess( pA );
 				aBmp.ReleaseAccess( pB );
 				aDither.ReleaseAccess( pW );
 				DrawBitmap( aDstRect.TopLeft(), aDither );
 			}
 			else
 			{
-				BitmapReadAccess*	pP = ( (Bitmap&) rBmp ).AcquireReadAccess();
-				BitmapReadAccess*	pA = ( (AlphaMask&) rAlpha ).AcquireReadAccess();
 				BitmapWriteAccess*	pB = aBmp.AcquireWriteAccess();
 
 				if( pP && pA && pB )
 				{
-					if( pA->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL )
-					{
-						switch( pP->GetScanlineFormat() )
-						{
-							case( BMP_FORMAT_8BIT_PAL ):
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pPScan = pP->GetScanline( nMapY );
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long nMapX = pMapX[ nX ];
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetPaletteColor( pPScan[ nMapX ] ),
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-
-							case( BMP_FORMAT_24BIT_TC_BGR ):
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pPScan = pP->GetScanline( nMapY );
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long	nMapX = pMapX[ nX ];
-										Scanline	pTmp = pPScan + nMapX * 3;
-
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 2 ], pTmp[ 1 ], pTmp[ 0 ],
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-
-							case( BMP_FORMAT_24BIT_TC_RGB ):
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pPScan = pP->GetScanline( nMapY );
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long	nMapX = pMapX[ nX ];
-										Scanline	pTmp = pPScan + nMapX * 3;
-
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ],
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-
-							default:
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long nMapX = pMapX[ nX ];
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-						}
-					}
-					else
-					{
-						for( nY = 0; nY < nDstHeight; nY++ )
-						{
-							const long nMapY = pMapY[ nY ];
-
-							for( nX = 0; nX < nDstWidth; nX++ )
-							{
-								const long nMapX = pMapX[ nX ];
-								aDstCol = pB->GetPixel( nY, nX );
-								pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
-																	 (BYTE) pA->GetPixel( nMapY, nMapX ) ) );
-							}
-						}
-					}
+                    switch( pP->GetScanlineFormat() )
+                    {
+                        case( BMP_FORMAT_8BIT_PAL ):
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pPScan = pP->GetScanline( nMapY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetPaletteColor( pPScan[ nMapX ] ),
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+
+                        case( BMP_FORMAT_24BIT_TC_BGR ):
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pPScan = pP->GetScanline( nMapY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long	nMapX = pMapX[ nX ];
+                                    Scanline	pTmp = pPScan + nMapX * 3;
+
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 2 ], pTmp[ 1 ], pTmp[ 0 ],
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+
+                        case( BMP_FORMAT_24BIT_TC_RGB ):
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pPScan = pP->GetScanline( nMapY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long	nMapX = pMapX[ nX ];
+                                    Scanline	pTmp = pPScan + nMapX * 3;
+
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ],
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+
+                        default:
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+                    }
 				}
 
-				( (Bitmap&) rBmp ).ReleaseAccess( pP );
-				( (AlphaMask&) rAlpha ).ReleaseAccess( pA );
 				aBmp.ReleaseAccess( pB );
 				DrawBitmap( aDstRect.TopLeft(), aBmp );
 			}
+
+            // #110958# Enable alpha VDev again
+            mpAlphaVDev = pOldVDev;
+
+            // #110958# Perform merging of bitmap and VDev alpha channel
+            if( mpAlphaVDev )
+            {
+                BOOL bOldMapMode( IsMapModeEnabled() );
+                mpAlphaVDev->EnableMapMode(FALSE);
+                Bitmap aBitmap( mpAlphaVDev->GetBitmap( aDstRect.TopLeft(), aDstRect.GetSize() ) );
+				BitmapWriteAccess*	pW = aBitmap.AcquireWriteAccess();
+                BYTE nAlpha;
+
+                if( pW && pA )
+                {
+                    if( mpAlphaVDev->GetBitCount() < 8 )
+                    {
+                        // Less than 8 bit for backbuffer - try dithering of alpha channel
+                        BitmapColor	aIndex( 0 );
+
+                        for( nY = 0, nOutY = nOffY; nY < nDstHeight; nY++, nOutY++ )
+                        {
+                            const long nMapY = pMapY[ nY ];
+                            const long nModY = ( nOutY & 0x0FL ) << 4L;
+                            Scanline  pAScan = pA->GetScanline( nMapY );
+
+                            for( nX = 0, nOutX = nOffX; nX < nDstWidth; nX++, nOutX++ )
+                            {
+                                const long	nMapX = pMapX[ nX ];
+                                const ULONG nD = nVCLDitherLut[ nModY | ( nOutX & 0x0FL ) ];
+
+                                nAlpha = pAScan[ nMapX ];
+
+                                // Have to perform the compositing
+                                // 'algebra' in the inverse alpha
+                                // space (with 255 meaning opaque),
+                                // otherwise, transitivity is not
+                                // achieved.
+                                nAlpha = 255-COLOR_CHANNEL_MERGE( 255, (BYTE) 255-pW->GetColor( nY, nX ), 255-nAlpha );
+
+                                aIndex.SetIndex( (BYTE) ( nVCLRLut[ ( nVCLLut[ nAlpha ] + nD ) >> 16UL ] +
+                                                          nVCLGLut[ ( nVCLLut[ nAlpha ] + nD ) >> 16UL ] +
+                                                          nVCLBLut[ ( nVCLLut[ nAlpha ] + nD ) >> 16UL ] ) );
+                                pW->SetPixel( nY, nX, aIndex );
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if( pW->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL ||
+                            pW->GetScanlineFormat() == BMP_FORMAT_8BIT_TC_MASK )
+                        {
+                            // optimized handling for 8 bit alpha - 8 bit backbuffer
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pWScan = pW->GetScanline( nY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+                                
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+
+                                    nAlpha = pAScan[ nMapX ];
+
+                                    // Have to perform the compositing
+                                    // 'algebra' in the inverse alpha
+                                    // space (with 255 meaning opaque),
+                                    // otherwise, transitivity is not
+                                    // achieved.
+                                    pWScan[ nX ] = 255 - COLOR_CHANNEL_MERGE( 255, 255-pWScan[ nX ], 255-nAlpha );
+                                }
+                            }
+                        }
+                        else
+                        {
+                            // optimized handling for 8 bit alpha - >8 bit backbuffer
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+                                
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+                                    nAlpha = pAScan[ nMapX ];
+
+                                    // Have to perform the compositing
+                                    // 'algebra' in the inverse alpha
+                                    // space (with 255 meaning opaque),
+                                    // otherwise, transitivity is not
+                                    // achieved.
+                                    nAlpha = 255 - COLOR_CHANNEL_MERGE( 255, 255-pW->GetColor( nY, nX ).GetBlue(), 255-nAlpha );
+
+                                    pW->SetPixel( nY, nX, Color(nAlpha, nAlpha, nAlpha) );
+                                }
+                            }
+                        }
+                    }
+                }
+                                
+                aBitmap.ReleaseAccess( pW );
+ 				mpAlphaVDev->DrawBitmap( aDstRect.TopLeft(), aBitmap );
+                mpAlphaVDev->EnableMapMode( bOldMapMode );
+            }
+            
+            ( (Bitmap&) rBmp ).ReleaseAccess( pP );
+            ( (AlphaMask&) rAlpha ).ReleaseAccess( pA );
 
 			delete[] pMapX;
 			delete[] pMapY;
Index: vcl/source/gdi/outdev3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev3.cxx,v
retrieving revision 1.155.20.6
retrieving revision 1.173
diff -u -p -u -r1.155.20.6 -r1.173
--- vcl/source/gdi/outdev3.cxx	13 Feb 2004 14:03:37 -0000	1.155.20.6
+++ vcl/source/gdi/outdev3.cxx	25 Jun 2004 15:16:20 -0000	1.173
@@ -59,27 +59,20 @@
  *
  ************************************************************************/
 
-#include <math.h>
-#include <string.h>
+#include <cmath>
+#include <cstring>
 
+#ifndef _ISOLANG_HXX
+#include <tools/isolang.hxx>
+#endif
 
-#define _SV_OUTDEV_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif // REMOTE_APPSERVER
 
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
@@ -110,8 +103,8 @@
 #ifndef _SV_OUTFONT_HXX
 #include <outfont.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_OUTDEV_H
 #include <outdev.h>
@@ -153,6 +146,10 @@
 #include <osl/file.h>
 #endif
 
+#ifndef _SV_GLYPHCACHE_HXX
+#include <glyphcache.hxx>
+#endif
+
 #include <unohelp.hxx>
 #ifndef _VCL_PDFWRITER_IMPL_HXX
 #include <pdfwriter_impl.hxx>
@@ -179,9 +176,13 @@
 
 #if defined(WIN32)
 #include <malloc.h>
 #define alloca _alloca
-#elif defined(SOLARIS) || defined(IRIX)
-#include <alloca.h>
+#elif defined(SOLARIS) || defined(IRIX)
+  #include <alloca.h>
+#else
+#ifndef MACOSX
+  #include <malloc.h>
+#endif
 #endif
 
 #include <memory>
@@ -211,6 +209,9 @@ using namespace ::vcl;
 
 // =======================================================================
 
+//#ifdef USE_NEW_RTL_IMPLEMENTATION
+
+
 static void ImplRotatePos( long nOriginX, long nOriginY, long& rX, long& rY,
                            int nOrientation )
 {
@@ -296,11 +297,7 @@ void OutputDevice::ImplUpdateFontData( B
         if ( bNewFontLists )
         {
             // we need a graphics
-#ifndef REMOTE_APPSERVER
             if ( ImplGetGraphics() )
-#else
-            if ( ImplGetServerGraphics() )
-#endif
             {
                 if( mpFontList && mpFontList != pSVData->maGDIData.mpScreenFontList )
                     mpFontList->Clear();
@@ -395,10 +392,9 @@ void OutputDevice::ImplUpdateAllFontData
         pFrame = pSVData->maWinData.mpFirstFrame;
         if ( pFrame )
         {
-#ifndef REMOTE_APPSERVER
             if ( pFrame->ImplGetGraphics() )
-#endif
-                pFrame->mpGraphics->GetDevFontList( pFrame->mpFrameData->mpFontList );
+                // MT: Stupid typecast here and somewhere ((OutputDevice*)&aVDev)->, because bug in .NET2002 compiler.
+                ((OutputDevice*)pFrame)->mpGraphics->GetDevFontList( pFrame->mpFrameData->mpFontList );
         }
     }
 }
@@ -908,8 +904,8 @@ void OutputDevice::GetFontSubstitute( US
 
 // -----------------------------------------------------------------------
 
-static void ImplFontSubstitute( String& rFontName,
-                                USHORT nFlags, ImplFontSubstEntry* pDevSpecific )
+static BOOL ImplFontSubstitute( XubString& rFontName,
+                                USHORT nFlags1, USHORT nFlags2, ImplFontSubstEntry* pDevSpecific )
 {
 #ifdef DBG_UTIL
     String aTempName = rFontName;
@@ -917,33 +913,36 @@ static void ImplFontSubstitute( String& 
     DBG_ASSERT( aTempName == rFontName, "ImplFontSubstitute() called without a searchname" );
 #endif
 
-    // apply global replacement (e.g. from the Tools->Options->Fonts dialog)
-    ImplSVData* pSVData = ImplGetSVData();
-    const ImplFontSubstEntry* pEntry = pSVData->maGDIData.mpFirstFontSubst;
-    for(; pEntry; pEntry = pEntry->mpNext ) // linear search => TODO
+    // apply font replacement (eg, from the list in Tools->Options)
+    ImplSVData*         pSVData = ImplGetSVData();
+    ImplFontSubstEntry* pEntry = pSVData->maGDIData.mpFirstFontSubst;
+    while ( pEntry )
     {
-        // replace if ALWAYS or SCREENONLY flags match or nFlags is zero
-        if(((pEntry->mnFlags & nFlags) || !nFlags)
-        &&  (pEntry->maSearchName == rFontName) )
+        if ( ((pEntry->mnFlags & nFlags1) == nFlags2) &&
+             (pEntry->maSearchName == rFontName) )
         {
             rFontName = pEntry->maSearchReplaceName;
-            return;
+            return TRUE;
         }
-    }
 
-    // apply device specific replacement (e.g. Arial->Helvetica on a PS printer)
+        pEntry = pEntry->mpNext;
+    }
     if( pDevSpecific )
     {
-        for( pEntry = pDevSpecific; pEntry; pEntry = pEntry->mpNext )
+        pEntry = pDevSpecific;
+        while ( pEntry )
         {
-            if(((pEntry->mnFlags & nFlags) || !nFlags)
-            &&  (pEntry->maSearchName == rFontName) )
+            if ( ((pEntry->mnFlags & nFlags1) == nFlags2) &&
+                 (pEntry->maSearchName == rFontName) )
             {
                 rFontName = pEntry->maSearchReplaceName;
-                return;
+                return TRUE;
             }
+            pEntry = pEntry->mpNext;
         }
     }
+
+    return FALSE;
 }
 
 // =======================================================================
@@ -1034,14 +1033,25 @@ static void ImplAddTokenFontNames( Strin
 Font OutputDevice::GetDefaultFont( USHORT nType, LanguageType eLang,
                                    ULONG nFlags, const OutputDevice* pOutDev )
 {
+    DBG_TRACE( "OutputDevice::GetDefaultFont()" );
+
+    com::sun::star::lang::Locale aLocale;
     if( eLang == LANGUAGE_NONE || eLang == LANGUAGE_SYSTEM || eLang == LANGUAGE_DONTKNOW )
     {
-        eLang = Application::GetSettings().GetUILanguage();
+        aLocale = Application::GetSettings().GetUILocale();
     }
+    else
+    {
+        String aLang, aCountry;
+        ConvertLanguageToIsoNames( eLang, aLang, aCountry );
+        aLocale.Language= aLang;
+        aLocale.Country = aCountry;
+    }
+
 
     DefaultFontConfigItem* pDefaults = DefaultFontConfigItem::get();
-    String aSearch = pDefaults->getUserInterfaceFont( eLang ); // ensure a fallback
-    String aDefault = pDefaults->getDefaultFont( eLang, nType );
+    String aSearch = pDefaults->getUserInterfaceFont( aLocale ); // ensure a fallback
+    String aDefault = pDefaults->getDefaultFont( aLocale, nType );
     if( aDefault.Len() )
         aSearch = aDefault;
 
@@ -1166,6 +1176,47 @@ Font OutputDevice::GetDefaultFont( USHOR
                 aFont.SetName( aSearch );
         }
     }
+
+#if OSL_DEBUG_LEVEL > 2
+    const char* s = "DEFAULTFONT_SANS_UNKNOWN";
+    switch ( nType )
+    {
+	case DEFAULTFONT_SANS_UNICODE:	s = "DEFAULTFONT_SANS_UNICODE"; break;
+	case DEFAULTFONT_UI_SANS:	s = "DEFAULTFONT_UI_SANS"; break;
+
+	case DEFAULTFONT_SANS:	s = "DEFAULTFONT_SANS"; break;
+	case DEFAULTFONT_LATIN_HEADING:	s = "DEFAULTFONT_LATIN_HEADING"; break;
+	case DEFAULTFONT_LATIN_SPREADSHEET:	s = "DEFAULTFONT_LATIN_SPREADSHEET"; break;
+	case DEFAULTFONT_LATIN_DISPLAY:	s = "DEFAULTFONT_LATIN_DISPLAY"; break;
+
+	case DEFAULTFONT_SERIF:	s = "DEFAULTFONT_SERIF"; break;
+	case DEFAULTFONT_LATIN_TEXT:	s = "DEFAULTFONT_LATIN_TEXT"; break;
+	case DEFAULTFONT_LATIN_PRESENTATION:	s = "DEFAULTFONT_LATIN_PRESENTATION"; break;
+
+	case DEFAULTFONT_FIXED:	s = "DEFAULTFONT_FIXED"; break;
+	case DEFAULTFONT_LATIN_FIXED:	s = "DEFAULTFONT_LATIN_FIXED"; break;
+	case DEFAULTFONT_UI_FIXED:	s = "DEFAULTFONT_UI_FIXED"; break;
+
+	case DEFAULTFONT_SYMBOL:	s = "DEFAULTFONT_SYMBOL"; break;
+
+	case DEFAULTFONT_CJK_TEXT:	s = "DEFAULTFONT_CJK_TEXT"; break;
+	case DEFAULTFONT_CJK_PRESENTATION:	s = "DEFAULTFONT_CJK_PRESENTATION"; break;
+	case DEFAULTFONT_CJK_SPREADSHEET:	s = "DEFAULTFONT_CJK_SPREADSHEET"; break;
+	case DEFAULTFONT_CJK_HEADING:	s = "DEFAULTFONT_CJK_HEADING"; break;
+	case DEFAULTFONT_CJK_DISPLAY:	s = "DEFAULTFONT_CJK_DISPLAY"; break;
+
+	case DEFAULTFONT_CTL_TEXT:	s = "DEFAULTFONT_CTL_TEXT"; break;
+	case DEFAULTFONT_CTL_PRESENTATION:	s = "DEFAULTFONT_CTL_PRESENTATION"; break;
+	case DEFAULTFONT_CTL_SPREADSHEET:	s = "DEFAULTFONT_CTL_SPREADSHEET"; break;
+	case DEFAULTFONT_CTL_HEADING:	s = "DEFAULTFONT_CTL_HEADING"; break;
+	case DEFAULTFONT_CTL_DISPLAY:	s = "DEFAULTFONT_CTL_DISPLAY"; break;
+    }
+    fprintf( stderr, "   OutputDevice::GetDefaultFont() Type=\"%s\" lang=%d flags=%d FontName=\"%s\"\n",
+	     s, eLang, nFlags,
+	     OUStringToOString( aFont.GetName(), osl_getThreadTextEncoding() ).getStr()
+	     );
+#endif
+
     return aFont;
 }
 
@@ -1291,8 +1342,7 @@ static void ImplCalcType( ULONG& rType, 
 
 // =======================================================================
 
-ImplDevFontList::ImplDevFontList() :
-    List( CONTAINER_MAXBLOCKSIZE, 96, 32 )
+ImplDevFontList::ImplDevFontList() : List( CONTAINER_MAXBLOCKSIZE, 96, 32 )
 {
     mbMatchData = FALSE;
     mbMapNames  = FALSE;
@@ -1319,7 +1369,9 @@ void ImplDevFontList::ImplClear()
             ImplFontData* pNextFD = pFontData->mpNext;
 
             // tell lower layers about the imminent death
-            SalGraphics::RemovingFont( pFontData );
+#ifdef UNX
+            GlyphCache::GetInstance().RemoveFont( pFontData );
+#endif
             delete pFontData;
 
             pFontData = pNextFD;
@@ -1800,24 +1852,24 @@ ImplFontEntry* ImplFontCache::Get( ImplD
 
     ImplDevFontListData*    pFoundData;
     String                  aSearchName;
+    USHORT                  nSubstFlags1 = FONT_SUBSTITUTE_ALWAYS;
+    USHORT                  nSubstFlags2 = FONT_SUBSTITUTE_ALWAYS;
+    xub_StrLen              nFirstNameIndex = 0;
     xub_StrLen              nIndex = 0;
     int                     nToken = 0;
     ULONG                   i;
 
-    USHORT nSubstFlags = FONT_SUBSTITUTE_ALWAYS;
-    if ( !mbPrinter )
-        nSubstFlags |= FONT_SUBSTITUTE_SCREENONLY;
-
-    // check if the first font in the semicolon separated list of font names
-    // is available, substitute the font there is a matching entry in the
-    // Tools->Options->Fonts dialog with ALWAYS or SCREENONLY flags set
+    if ( mbPrinter )
+        nSubstFlags1 |= FONT_SUBSTITUTE_SCREENONLY;
+
+    // Test if one Font in the name list is available
     do
     {
         nToken++;
         String aToken = GetFontToken( aName, 0, nIndex );
         aSearchName = aToken;
         ImplGetEnglishSearchFontName( aSearchName );
-        ImplFontSubstitute( aSearchName, nSubstFlags, pDevSpecific );
+        ImplFontSubstitute( aSearchName, nSubstFlags1, nSubstFlags2, pDevSpecific );
         pFoundData = pFontList->ImplFind( aSearchName );
         if( pFoundData )
         {
@@ -1827,13 +1879,14 @@ ImplFontEntry* ImplFontCache::Get( ImplD
     }
     while ( nIndex != STRING_NOTFOUND );
 
-    // if the first font was not available find the next available font in
-    // the semicolon separated list of font names. A font is also considered
-    // available when there is a matching entry in the Tools->Options->Fonts
-    // dialog witho neither ALWAYS nor SCREENONLY flags set and the substitution
-    // font is available
-    if( !pFoundData )
+    // Danach versuchen wir es nocheinmal unter Beruecksichtigung
+    // der gloablen Fontersetzungstabelle, wobei wir jetzt auch
+    // die Fonts nehmen, die ersetzt werden sollen, wenn sie
+    // nicht vorhanden sind
+    if ( !pFoundData )
     {
+        nSubstFlags1 &= ~FONT_SUBSTITUTE_ALWAYS;
+        nSubstFlags2 &= ~FONT_SUBSTITUTE_ALWAYS;
         nIndex = 0;
         do
         {
@@ -1844,7 +1897,7 @@ ImplFontEntry* ImplFontCache::Get( ImplD
             }
             else
                 nIndex = STRING_NOTFOUND;
-            ImplFontSubstitute( aSearchName, 0, pDevSpecific );
+            ImplFontSubstitute( aSearchName, nSubstFlags1, nSubstFlags2, pDevSpecific );
             pFoundData = pFontList->ImplFind( aSearchName );
             if( pFoundData )
                 break;
@@ -1917,7 +1970,9 @@ ImplFontEntry* ImplFontCache::Get( ImplD
 
         if ( !pFoundData && bSymbolEncoding )
         {
-            String aFontname = DefaultFontConfigItem::get()->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SYMBOL );
+            com::sun::star::lang::Locale aLocale( OUString( RTL_CONSTASCII_USTRINGPARAM("en") ),
+                                                  OUString(), OUString() );
+            String aFontname = DefaultFontConfigItem::get()->getDefaultFont( aLocale, DEFAULTFONT_SYMBOL );
             ImplGetEnglishSearchFontName( aFontname );
             pFoundData = pFontList->ImplFindFontFromToken( aFontname );
         }
@@ -2378,23 +2433,25 @@ ImplFontEntry* ImplFontCache::Get( ImplD
             // Try to use a Standard Unicode or a Standard Font to get
             // as max as possible characters
             DefaultFontConfigItem* pDefaults = DefaultFontConfigItem::get();
-            String aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SANS_UNICODE );
+            com::sun::star::lang::Locale aLoc( OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) ),
+                                               OUString(), OUString() );
+            String aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_SANS_UNICODE );
             ImplGetEnglishSearchFontName( aFontname );
 
             pFoundData = pFontList->ImplFindFontFromToken( aFontname );
             if ( !pFoundData )
             {
-                aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SANS );
+                aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_SANS );
                 ImplGetEnglishSearchFontName( aFontname );
                 pFoundData = pFontList->ImplFindFontFromToken( aFontname );
                 if ( !pFoundData )
                 {
-                    aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SERIF );
+                    aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_SERIF );
                     ImplGetEnglishSearchFontName( aFontname );
                     pFoundData = pFontList->ImplFindFontFromToken( aFontname );
                     if ( !pFoundData )
                     {
-                        aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_FIXED );
+                        aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_FIXED );
                         ImplGetEnglishSearchFontName( aFontname );
                         pFoundData = pFontList->ImplFindFontFromToken( aFontname );
                     }
@@ -2626,7 +2683,7 @@ ImplFontEntry* ImplFontCache::GetFallbac
     {
         // TODO: implement dynamic lists or improve static lists
         #define FALLBACKFONT_NAMELIST \
-            "arialunicodems;andalesansui;cyberbit;starsymbol;opensymbol;lucidatypeWriter;"  \
+            "arialunicodems;andalesansui;cyberbit;starsymbol;opensymbol;lucidatypewriter;"  \
             "fzmingti;sunbatang;sundotum;baekmukdotum;"                     \
             "hgmincholightj;msunglightsc;msunglighttc;hymyeongjolightk;"    \
             "lucidasans;tahoma;"                                            \
@@ -2730,7 +2787,6 @@ void ImplFontCache::Clear()
     }
 
     // #112304# make sure the font cache is really clean
-    // #112304# there are still referenced entries
     mpFirstEntry = NULL;
 
     DBG_ASSERT( (mnRef0Count==0), "ImplFontCache::Clear() - mnRef0Count non-zero" );
@@ -2871,11 +2927,7 @@ void OutputDevice::ImplInitTextColor()
 
     if ( mbInitTextColor )
     {
-#ifndef REMOTE_APPSERVER
         mpGraphics->SetTextColor( ImplColorToSal( GetTextColor() ) );
-#else
-        mpGraphics->SetTextColor( GetTextColor() );
-#endif
         mbInitTextColor = FALSE;
     }
 }
@@ -2900,16 +2952,10 @@ int OutputDevice::ImplNewFont()
 
     mbNewFont = FALSE;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if ( !mpGraphics && !ImplGetGraphics() )
         return FALSE;
     SalGraphics* pGraphics = mpGraphics;
-#else
-    // due to clipping we may get NULL, so don't use return value
-    ImplGetServerGraphics();
-    ImplServerGraphics* pGraphics = mpGraphics;
-#endif
     ImplInitFontList();
 
     // convert to pixel height
@@ -3006,16 +3053,7 @@ int OutputDevice::ImplNewFont()
                 mpPDFWriter->getFontMetric( &pFontEntry->maFontSelData, &(pFontEntry->maMetric) );
             else
             {
-#ifndef REMOTE_APPSERVER
                 pGraphics->GetFontMetric( &(pFontEntry->maMetric) );
-#else
-                long nFactor = 0;
-                pGraphics->GetFontMetric(
-                                         pFontEntry->maMetric, nFactor,
-                                         0x21, 0x20, NULL,
-                                         (maFont.GetKerning() & KERNING_FONTSPECIFIC) != 0,
-                                         &pKernPairs, nKernPairs );
-#endif
             }
 
             pFontEntry->mbFixedFont     = pFontEntry->maMetric.mePitch == PITCH_FIXED;
@@ -3122,9 +3160,10 @@ inline bool CmpKernData( const ImplKernP
 
 static void ImplSortKernPairs( ImplKernPairData* pKernPairs, long l, long r )
 {
-#if 1 // TODO: use STL's insertion sort
-    long                i = l;
+	// TODO: use STL's insertion sort
+	// std::sort( pKernPairs+l, pKernPairs+r, CmpKernData );
 
+	long                i = l;
     long                j = r;
     ImplKernPairData*   pComp = pKernPairs + ((l+r) >> 1);
     sal_uInt32          nComp = *((sal_uInt32*)pComp);
@@ -3150,9 +3189,6 @@ static void ImplSortKernPairs( ImplKernP
         ImplSortKernPairs( pKernPairs, l, j );
     if ( i < r )
         ImplSortKernPairs( pKernPairs, i, r );
-#else
-    std::sort( pKernPairs+l, pKernPairs+r, CmpKernData );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -3174,7 +3210,6 @@ void OutputDevice::ImplInitKerningPairs(
             pFontEntry->mpKernPairs = NULL;
             return;
         }
-#ifndef REMOTE_APPSERVER
         pFontEntry->mnKernPairs = mpGraphics->GetKernPairs( 0, NULL );
         if ( pFontEntry->mnKernPairs )
         {
@@ -3183,12 +3218,6 @@ void OutputDevice::ImplInitKerningPairs(
             pFontEntry->mnKernPairs = mpGraphics->GetKernPairs( pFontEntry->mnKernPairs, pKernPairs );
             pFontEntry->mpKernPairs = pKernPairs;
         }
-#else
-        if ( !pKernPairs )
-            nKernPairs = mpGraphics->GetKernPairs( &pKernPairs );
-        if ( nKernPairs )
-            pFontEntry->mpKernPairs = pKernPairs;
-#endif
 
         // Sort Kerning Pairs
         if ( pFontEntry->mpKernPairs )
@@ -3256,21 +3285,12 @@ void OutputDevice::ImplDrawTextRect( lon
             Rectangle aRect( Point( nX, nY ), Size( nWidth+1, nHeight+1 ) );
             Polygon   aPoly( aRect );
             aPoly.Rotate( Point( nBaseX, nBaseY ), mpFontEntry->mnOrientation );
-#ifndef REMOTE_APPSERVER
             ImplDrawPolygon( aPoly );
-#else
-            mpGraphics->DrawPolygon( aPoly );
-#endif
             return;
         }
     }
 
-#ifndef REMOTE_APPSERVER
     mpGraphics->DrawRect( nX, nY, nWidth, nHeight, this );
-#else
-    Rectangle aRect( Point( nX, nY ), Size( nWidth, nHeight ) );
-    mpGraphics->DrawRect( aRect );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -3282,7 +3302,6 @@ void OutputDevice::ImplDrawTextBackgroun
     long nX = aBase.X();
     long nY = aBase.Y();
 
-#ifndef REMOTE_APPSERVER
     if ( mbLineColor || mbInitLineColor )
     {
         mpGraphics->SetLineColor();
@@ -3294,21 +3313,6 @@ void OutputDevice::ImplDrawTextBackgroun
     ImplDrawTextRect( nX, nY, nX, nY-mpFontEntry->maMetric.mnAscent-mnEmphasisAscent,
                       nWidth,
                       mpFontEntry->mnLineHeight+mnEmphasisAscent+mnEmphasisDescent );
-#else
-    Color aOldLineColor = GetLineColor();
-    Color aOldFillColor = GetFillColor();
-    SetLineColor();
-    SetFillColor( GetTextFillColor() );
-    if ( mbInitLineColor )
-        ImplInitLineColor();
-    if ( mbInitFillColor )
-        ImplInitFillColor();
-    ImplDrawTextRect( nX, nY, nX, nY-mpFontEntry->maMetric.mnAscent-mnEmphasisAscent,
-                      nWidth,
-                      mpFontEntry->mnLineHeight+mnEmphasisAscent+mnEmphasisDescent );
-    SetLineColor( aOldLineColor );
-    SetFillColor( aOldFillColor );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -3542,11 +3545,7 @@ void OutputDevice::ImplInitAboveTextLine
 static void ImplDrawWavePixel( long nOriginX, long nOriginY,
                                long nCurX, long nCurY,
                                short nOrientation,
-#ifndef REMOTE_APPSERVER
                                SalGraphics* pGraphics,
-#else
-                               ImplServerGraphics* pGraphics,
-#endif
                                OutputDevice* pOutDev,
                                BOOL bDrawPixAsRect,
 
@@ -3557,24 +3556,12 @@ static void ImplDrawWavePixel( long nOri
 
     if ( bDrawPixAsRect )
     {
-#ifndef REMOTE_APPSERVER
 
         pGraphics->DrawRect( nCurX, nCurY, nPixWidth, nPixHeight, pOutDev );
-#else
-        Point       aPos( nCurX, nCurY );
-        Size        aSize( nPixWidth, nPixHeight );
-        Rectangle   aRect( aPos, aSize );
-        pGraphics->DrawRect( aRect );
-#endif
     }
     else
     {
-#ifndef REMOTE_APPSERVER
         pGraphics->DrawPixel( nCurX, nCurY, pOutDev );
-#else
-        Point aPos( nCurX, nCurY );
-        pGraphics->DrawPixel( aPos );
-#endif
     }
 }
 
@@ -3592,15 +3579,8 @@ void OutputDevice::ImplDrawWaveLine( lon
     // Bei Hoehe von 1 Pixel reicht es, eine Linie auszugeben
     if ( (nLineWidth == 1) && (nHeight == 1) )
     {
-#ifndef REMOTE_APPSERVER
         mpGraphics->SetLineColor( ImplColorToSal( rColor ) );
         mbInitLineColor = TRUE;
-#else
-        Color aOldLineColor = GetLineColor();
-        SetLineColor( rColor );
-        if ( mbInitLineColor )
-            ImplInitLineColor();
-#endif
 
         long nEndX = nStartX+nWidth;
         long nEndY = nStartY;
@@ -3609,15 +3589,8 @@ void OutputDevice::ImplDrawWaveLine( lon
             ImplRotatePos( nBaseX, nBaseY, nStartX, nStartY, nOrientation );
             ImplRotatePos( nBaseX, nBaseY, nEndX, nEndY, nOrientation );
         }
-#ifndef REMOTE_APPSERVER
         mpGraphics->DrawLine( nStartX, nStartY, nEndX, nEndY, this );
-#else
-        mpGraphics->DrawLine( Point( nStartX, nStartY ), Point( nEndX, nEndY ) );
-#endif
 
-#ifdef REMOTE_APPSERVER
-        SetLineColor( aOldLineColor );
-#endif
     }
     else
     {
@@ -3632,15 +3605,9 @@ void OutputDevice::ImplDrawWaveLine( lon
         long    nPixWidth;
         long    nPixHeight;
         BOOL    bDrawPixAsRect;
-#ifdef REMOTE_APPSERVER
-        Color   aOldLineColor = GetLineColor();
-        Color   aOldFillColor = GetFillColor();
-
-#endif
         // Auf Druckern die Pixel per DrawRect() ausgeben
         if ( (GetOutDevType() == OUTDEV_PRINTER) || (nLineWidth > 1) )
         {
-#ifndef REMOTE_APPSERVER
             if ( mbLineColor || mbInitLineColor )
             {
                 mpGraphics->SetLineColor();
@@ -3648,29 +3615,14 @@ void OutputDevice::ImplDrawWaveLine( lon
             }
             mpGraphics->SetFillColor( ImplColorToSal( rColor ) );
             mbInitFillColor = TRUE;
-#else
-            SetLineColor();
-            SetFillColor( rColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-            if ( mbInitFillColor )
-                ImplInitFillColor();
-#endif
             bDrawPixAsRect  = TRUE;
             nPixWidth       = nLineWidth;
             nPixHeight      = ((nLineWidth*mnDPIX)+(mnDPIY/2))/mnDPIY;
         }
         else
         {
-#ifndef REMOTE_APPSERVER
             mpGraphics->SetLineColor( ImplColorToSal( rColor ) );
             mbInitLineColor = TRUE;
-#else
-            Color aOldLineColor = GetLineColor();
-            SetLineColor( rColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-#endif
             nPixWidth       = 1;
             nPixHeight      = 1;
             bDrawPixAsRect  = FALSE;
@@ -3732,10 +3684,6 @@ void OutputDevice::ImplDrawWaveLine( lon
             }
         }
 
-#ifdef REMOTE_APPSERVER
-        SetLineColor( aOldLineColor );
-        SetFillColor( aOldFillColor );
-#endif
     }
 }
 
@@ -3877,7 +3825,13 @@ void OutputDevice::ImplDrawTextLine( lon
         {
             if( mpFontEntry->mnOrientation )
                 ImplRotatePos( nBaseX, nBaseY, nX, nY, mpFontEntry->mnOrientation );
-            SalLayout* pSalLayout = ImplLayout( aStrikeoutText, 0, STRING_LEN, Point(nX,nY) );
+
+            // strikeout text has to be left aligned
+            ULONG nOrigTLM = mnTextLayoutMode;
+            mnTextLayoutMode = TEXT_LAYOUT_BIDI_STRONG | TEXT_LAYOUT_COMPLEX_DISABLED;
+            SalLayout* pSalLayout = ImplLayout( aStrikeoutText, 0, STRING_LEN );
+            mnTextLayoutMode = nOrigTLM;
+
             if( pSalLayout )
             {
                 pSalLayout->DrawBase() = Point( nX+mnTextOffX, nY+mnTextOffY );
@@ -3898,17 +3852,20 @@ void OutputDevice::ImplDrawTextLine( lon
             case UNDERLINE_WAVE:
             case UNDERLINE_DOUBLEWAVE:
             case UNDERLINE_BOLDWAVE:
+            {
                 bNormalLines = FALSE;
+            }
+            break;
+            default: 
+            {
+                ; // We don't want a gcc warning...
+            }
+                
         }
     }
 
     if ( bNormalLines )
     {
-#ifdef REMOTE_APPSERVER
-        Color aOldLineColor = GetLineColor();
-        Color aOldFillColor = GetFillColor();
-#endif
-
         if ( eUnderline > UNDERLINE_LAST )
             eUnderline = UNDERLINE_SINGLE;
 
@@ -3981,7 +3938,6 @@ void OutputDevice::ImplDrawTextLine( lon
 
         if ( nLineHeight )
         {
-#ifndef REMOTE_APPSERVER
             if ( mbLineColor || mbInitLineColor )
             {
                 mpGraphics->SetLineColor();
@@ -3989,14 +3945,6 @@ void OutputDevice::ImplDrawTextLine( lon
             }
             mpGraphics->SetFillColor( ImplColorToSal( aUnderlineColor ) );
             mbInitFillColor = TRUE;
-#else
-            SetLineColor();
-            SetFillColor( aUnderlineColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-            if ( mbInitFillColor )
-                ImplInitFillColor();
-#endif
 
             nLeft = nX;
 
@@ -4173,7 +4121,6 @@ void OutputDevice::ImplDrawTextLine( lon
 
         if ( nLineHeight )
         {
-#ifndef REMOTE_APPSERVER
             if ( mbLineColor || mbInitLineColor )
             {
                 mpGraphics->SetLineColor();
@@ -4181,14 +4128,6 @@ void OutputDevice::ImplDrawTextLine( lon
             }
             mpGraphics->SetFillColor( ImplColorToSal( aStrikeoutColor ) );
             mbInitFillColor = TRUE;
-#else
-            SetLineColor();
-            SetFillColor( aStrikeoutColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-            if ( mbInitFillColor )
-                ImplInitFillColor();
-#endif
 
             nLeft = nX;
 
@@ -4202,10 +4141,6 @@ void OutputDevice::ImplDrawTextLine( lon
             }
         }
 
-#ifdef REMOTE_APPSERVER
-        SetLineColor( aOldLineColor );
-        SetFillColor( aOldFillColor );
-#endif
     }
 }
 
@@ -4217,10 +4152,10 @@ void OutputDevice::ImplDrawTextLines( Sa
     if( bWordLine )
     {
         Point aPos, aStartPt;
-        long nWidth = 0, nAdvance=0;
+        sal_Int32 nWidth = 0, nAdvance=0;
         for( int nStart = 0;;)
         {
-            long nGlyphIndex;
+            sal_Int32 nGlyphIndex;
             if( !rSalLayout.GetNextGlyphs( 1, &nGlyphIndex, aPos, nStart, &nAdvance ) )
                 break;
 
@@ -4486,7 +4421,7 @@ void OutputDevice::ImplDrawEmphasisMarks
     BOOL                bOldMap         = mbMap;
     GDIMetaFile*        pOldMetaFile    = mpMetaFile;
     mpMetaFile = NULL;
-    mbMap = FALSE;
+    EnableMapMode( FALSE );
 
     FontEmphasisMark    nEmphasisMark = ImplGetEmphasisMarkStyle( maFont );
     PolyPolygon         aPolyPoly;
@@ -4534,11 +4469,11 @@ void OutputDevice::ImplDrawEmphasisMarks
     Rectangle aRectangle;
     for( int nStart = 0;;)
     {
-        long nGlyphIndex;
+        sal_Int32 nGlyphIndex;
         if( !rSalLayout.GetNextGlyphs( 1, &nGlyphIndex, aOutPoint, nStart ) )
             break;
 
-        if( !mpGraphics->GetGlyphBoundRect( nGlyphIndex, aRectangle, NULL ) )
+        if( !mpGraphics->GetGlyphBoundRect( nGlyphIndex, aRectangle ) )
             continue;
 
         if( !rSalLayout.IsSpacingGlyph( nGlyphIndex ) )
@@ -4557,7 +4492,7 @@ void OutputDevice::ImplDrawEmphasisMarks
 
     SetLineColor( aOldLineColor );
     SetFillColor( aOldFillColor );
-    mbMap = bOldMap;
+    EnableMapMode( bOldMap );
     mpMetaFile = pOldMetaFile;
 }
 
@@ -4604,7 +4539,7 @@ bool OutputDevice::ImplDrawRotateText( S
 
     // draw text into upper left corner
     rSalLayout.DrawBase() -= aBoundRect.TopLeft();
-    rSalLayout.DrawText( *pVDev->mpGraphics );
+    rSalLayout.DrawText( *((OutputDevice*)pVDev)->mpGraphics );
 
     Bitmap aBmp = pVDev->GetBitmap( Point(), aBoundRect.GetSize() );
     if ( !aBmp || !aBmp.Rotate( mpFontEntry->mnOwnOrientation, COL_WHITE ) )
@@ -4625,11 +4560,11 @@ bool OutputDevice::ImplDrawRotateText( S
     mnOutOffX   = 0L;
     mnOutOffY   = 0L;
     mpMetaFile  = NULL;
-    mbMap       = FALSE;
+    EnableMapMode( FALSE );
 
     DrawMask( aPoint, aBmp, GetTextColor() );
 
-    mbMap       = bOldMap;
+    EnableMapMode( bOldMap );
     mnOutOffX   = nOldOffX;
     mnOutOffY   = nOldOffY;
     mpMetaFile  = pOldMetaFile;
@@ -4655,9 +4590,15 @@ void OutputDevice::ImplDrawTextDirect( S
        		rSalLayout.DrawBase().X() = w - 1 - x;
             if( !IsRTLEnabled() )
             {
+                OutputDevice *pOutDevRef = (OutputDevice *)this;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+                if( meOutDevType == OUTDEV_WINDOW )
+                    pOutDevRef = (OutputDevice*) ((Window *) this)->mpDummy4;
+#endif
+
                 // mirror this window back
-                long devX = w-mnOutWidth-mnOutOffX;   // re-mirrored mnOutOffX
-                rSalLayout.DrawBase().X() = devX + ( mnOutWidth - 1 - (rSalLayout.DrawBase().X() - devX) ) ;
+                long devX = w-pOutDevRef->mnOutWidth-pOutDevRef->mnOutOffX;   // re-mirrored mnOutOffX
+                rSalLayout.DrawBase().X() = devX + ( pOutDevRef->mnOutWidth - 1 - (rSalLayout.DrawBase().X() - devX) ) ;
             }
         }
 
@@ -4897,6 +4838,9 @@ void OutputDevice::SetAntialiasing( USHO
         mnAntialiasing = nMode;
         mbInitFont = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetAntialiasing( nMode );
 }
 
 // -----------------------------------------------------------------------
@@ -4978,13 +4922,26 @@ void OutputDevice::SetFont( const Font& 
         mpMetaFile->AddAction( new MetaTextFillColorAction( aFont.GetFillColor(), !aFont.IsTransparent() ) );
     }
 
+#if OSL_DEBUG_LEVEL > 2
+    fprintf( stderr, "   OutputDevice::SetFont() FontName=\"%s\"\n",
+	     OUStringToOString( aFont.GetName(), osl_getThreadTextEncoding() ).getStr() );
+#endif
+
     if ( !maFont.IsSameInstance( aFont ) )
     {
-        if ( maFont.GetColor() != aFont.GetColor() )
+        // Optimization MT/HDU: COL_TRANSPARENT means SetFont should ignore the font color, 
+        // because SetTextColor() is used for this.
+        if ( ( aFont.GetColor() != COL_TRANSPARENT ) && ( maFont.GetColor() != aFont.GetColor() ) )
+		{
+			maTextColor = aFont.GetColor();
             mbInitTextColor = TRUE;
+		}
         maFont      = aFont;
         mbNewFont   = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetFont( rNewFont );
 }
 
 // -----------------------------------------------------------------------
@@ -4997,6 +4954,9 @@ void OutputDevice::SetLayoutMode( ULONG 
         mpMetaFile->AddAction( new MetaLayoutModeAction( nTextLayoutMode ) );
 
     mnTextLayoutMode = nTextLayoutMode;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetLayoutMode( nTextLayoutMode );
 }
 
 // -----------------------------------------------------------------------
@@ -5012,6 +4972,9 @@ void OutputDevice::SetDigitLanguage( Lan
         eTextLanguage = GetSystemLanguage();
 
     meTextLanguage = eTextLanguage;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetDigitLanguage( eTextLanguage );
 }
 
 // -----------------------------------------------------------------------
@@ -5050,11 +5013,14 @@ void OutputDevice::SetTextColor( const C
     if ( mpMetaFile )
         mpMetaFile->AddAction( new MetaTextColorAction( aColor ) );
 
-    if ( maFont.GetColor() != aColor )
+    if ( maTextColor != aColor )
     {
-        maFont.SetColor( aColor );
+        maTextColor = aColor;
         mbInitTextColor = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -5071,6 +5037,9 @@ void OutputDevice::SetTextFillColor()
         maFont.SetFillColor( Color( COL_TRANSPARENT ) );
     if ( !maFont.IsTransparent() )
         maFont.SetTransparent( TRUE );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextFillColor();
 }
 
 // -----------------------------------------------------------------------
@@ -5122,6 +5091,9 @@ void OutputDevice::SetTextFillColor( con
         maFont.SetFillColor( aColor );
     if ( maFont.IsTransparent() != bTransFill )
         maFont.SetTransparent( bTransFill );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextFillColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -5145,6 +5117,9 @@ void OutputDevice::SetTextLineColor()
         mpMetaFile->AddAction( new MetaTextLineColorAction( Color(), FALSE ) );
 
     maTextLineColor = Color( COL_TRANSPARENT );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextLineColor();
 }
 
 // -----------------------------------------------------------------------
@@ -5184,6 +5159,9 @@ void OutputDevice::SetTextLineColor( con
         mpMetaFile->AddAction( new MetaTextLineColorAction( aColor, TRUE ) );
 
     maTextLineColor = aColor;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextLineColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -5202,6 +5180,9 @@ void OutputDevice::SetTextAlign( TextAli
         maFont.SetAlign( eAlign );
         mbNewFont = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextAlign( eAlign );
 }
 
 // -----------------------------------------------------------------------
@@ -5224,7 +5205,6 @@ void OutputDevice::DrawTextLine( const P
     if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
         return;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return;
@@ -5232,10 +5212,6 @@ void OutputDevice::DrawTextLine( const P
         ImplInitClipRegion();
     if( mbOutputClipped )
         return;
-#else
-    if( !ImplGetServerGraphics() )
-        return;
-#endif
 
     // initialize font if needed to get text offsets
     // TODO: only needed for mnTextOff!=(0,0)
@@ -5249,6 +5225,9 @@ void OutputDevice::DrawTextLine( const P
     nWidth = ImplLogicWidthToDevicePixel( nWidth );
     aPos += Point( mnTextOffX, mnTextOffY );
     ImplDrawTextLine( aPos.X(), aPos.X(), aPos.Y(), nWidth, eStrikeout, eUnderline, bUnderlineAbove );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawTextLine( rPos, nWidth, eStrikeout, eUnderline, bUnderlineAbove );
 }
 
 // ------------------------------------------------------------------------
@@ -5266,7 +5245,6 @@ void OutputDevice::DrawWaveLine( const P
     DBG_TRACE( "OutputDevice::DrawWaveLine()" );
     DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
-#ifndef REMOTE_APPSERVER
     if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
         return;
 
@@ -5324,18 +5302,8 @@ void OutputDevice::DrawWaveLine( const P
      ImplDrawWaveLine( nStartX, nStartY, nStartX, nStartY,
                       nEndX-nStartX, nWaveHeight, 1,
                       nOrientation, GetLineColor() );
-#else
-    ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-    if ( pGraphics )
-    {
-        if ( mbInitLineColor )
-            ImplInitLineColor();
-
-        Point aPos1 = ImplLogicToDevicePixel( rStartPos );
-        Point aPos2 = ImplLogicToDevicePixel( rEndPos );
-        pGraphics->DrawWaveLine( aPos1, aPos2, nStyle );
-    }
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawWaveLine( rStartPos, rEndPos, nStyle );
 }
 
 // -----------------------------------------------------------------------
@@ -5354,6 +5322,11 @@ void OutputDevice::DrawText( const Point
     DBG_TRACE( "OutputDevice::DrawText()" );
     DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
+#if OSL_DEBUG_LEVEL > 2
+    fprintf( stderr, "   OutputDevice::DrawText(\"%s\")\n",
+	     OUStringToOString( rStr, osl_getThreadTextEncoding() ).getStr() );
+#endif
+
     if ( mpMetaFile )
         mpMetaFile->AddAction( new MetaTextAction( rStartPt, rStr, nIndex, nLen ) );
     if( pVector )
@@ -5405,25 +5378,15 @@ void OutputDevice::DrawText( const Point
 
     if ( !IsDeviceOutputNecessary() || pVector )
         return;
-#ifdef UNX
-    String aStr( rStr );
-    if( meOutDevType == OUTDEV_PRINTER )
-    {
-        if( !mpGraphics )
-            if( !ImplGetGraphics() )
-                return;
-        xub_StrLen nCutStart, nCutStop;
-        aStr = mpGraphics->maGraphicsData.FaxPhoneComment( rStr, nIndex, nLen, nCutStart, nCutStop );
-    }
-    SalLayout* pSalLayout = ImplLayout( aStr, nIndex, nLen, rStartPt );
-#else
     SalLayout* pSalLayout = ImplLayout( rStr, nIndex, nLen, rStartPt );
-#endif
     if( pSalLayout )
     {
         ImplDrawText( *pSalLayout );
         pSalLayout->Release();
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawText( rStartPt, rStr, nIndex, nLen, pVector, pDisplayText );
 }
 
 // -----------------------------------------------------------------------
@@ -5460,7 +5423,7 @@ long OutputDevice::GetTextHeight() const
 // -----------------------------------------------------------------------
 
 void OutputDevice::DrawTextArray( const Point& rStartPt, const String& rStr,
-                                  const long* pDXAry,
+                                  const sal_Int32* pDXAry,
                                   xub_StrLen nIndex, xub_StrLen nLen )
 {
     DBG_TRACE( "OutputDevice::DrawTextArray()" );
@@ -5472,38 +5435,20 @@ void OutputDevice::DrawTextArray( const 
     if ( !IsDeviceOutputNecessary() )
         return;
 
-#ifdef UNX
-    String aStr( rStr );
-    if( meOutDevType == OUTDEV_PRINTER )
-    {
-        if( !mpGraphics )
-            if( !ImplGetGraphics() )
-                return;
-        xub_StrLen nCutStart, nCutStop, nOrgLen = nLen;
-        aStr = mpGraphics->maGraphicsData.FaxPhoneComment( rStr, nIndex, nLen, nCutStart, nCutStop );
-        if( nCutStop != nCutStart )
-        {
-            long* pAry = (long*)alloca(sizeof(long)*nLen );
-            if( nCutStart > nIndex )
-                memcpy( pAry, pDXAry, sizeof(long)*(nCutStart-nIndex) );
-            memcpy( pAry+nCutStart-nIndex, pDXAry + nOrgLen - (nCutStop-nIndex), nLen - (nCutStop-nIndex) );
-            pDXAry = pAry;
-        }
-    }
-    SalLayout* pSalLayout = ImplLayout( aStr, nIndex, nLen, rStartPt, 0, pDXAry );
-#else
     SalLayout* pSalLayout = ImplLayout( rStr, nIndex, nLen, rStartPt, 0, pDXAry );
-#endif
     if( pSalLayout )
     {
         ImplDrawText( *pSalLayout );
         pSalLayout->Release();
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawTextArray( rStartPt, rStr, pDXAry, nIndex, nLen );
 }
 
 // -----------------------------------------------------------------------
 
-long OutputDevice::GetTextArray( const String& rStr, long* pDXAry,
+long OutputDevice::GetTextArray( const String& rStr, sal_Int32* pDXAry,
                                  xub_StrLen nIndex, xub_StrLen nLen ) const
 {
     DBG_TRACE( "OutputDevice::GetTextArray()" );
@@ -5550,9 +5495,9 @@ long OutputDevice::GetTextArray( const S
 
 // -----------------------------------------------------------------------
 
-bool OutputDevice::GetCaretPositions( const XubString& rStr, long* pCaretXArray,
+bool OutputDevice::GetCaretPositions( const XubString& rStr, sal_Int32* pCaretXArray,
     xub_StrLen nIndex, xub_StrLen nLen,
-    long* pDXAry, long nLayoutWidth,
+    sal_Int32* pDXAry, long nLayoutWidth,
     BOOL bCellBreaking ) const
 {
     DBG_TRACE( "OutputDevice::GetCaretPositions()" );
@@ -5632,44 +5577,29 @@ void OutputDevice::DrawStretchText( cons
     if ( !IsDeviceOutputNecessary() )
         return;
 
-#ifdef UNX
-    String aStr( rStr );
-    if( meOutDevType == OUTDEV_PRINTER )
-    {
-        if( !mpGraphics )
-            if( !ImplGetGraphics() )
-                return;
-        xub_StrLen nCutStart, nCutStop;
-        aStr = mpGraphics->maGraphicsData.FaxPhoneComment( rStr, nIndex, nLen, nCutStart, nCutStop );
-    }
-    SalLayout* pSalLayout = ImplLayout( aStr, nIndex, nLen, rStartPt, nWidth );
-#else
     SalLayout* pSalLayout = ImplLayout( rStr, nIndex, nLen, rStartPt, nWidth );
-#endif
     if( pSalLayout )
     {
         ImplDrawText( *pSalLayout );
         pSalLayout->Release();
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawStretchText( rStartPt, nWidth, rStr, nIndex, nLen );
 }
 
 // -----------------------------------------------------------------------
 
 SalLayout* OutputDevice::ImplLayout( const String& rOrigStr,
     xub_StrLen nMinIndex, xub_StrLen nLen,
-    const Point& rLogicalPos, long nLogicalWidth, const long* pDXArray ) const
+    const Point& rLogicalPos, long nLogicalWidth, const sal_Int32* pDXArray ) const
 {
     SalLayout* pSalLayout = NULL;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics )
         if( !ImplGetGraphics() )
             return NULL;
-#else
-    // due to clipping we may get NULL, so don't use return value
-    ImplGetServerGraphics();
-#endif
 
     // initialize font if needed
     if( mbNewFont )
@@ -5790,7 +5720,7 @@ SalLayout* OutputDevice::ImplLayout( con
     if( pDXArray && mbMap )
     {
         // convert from logical units to font units using a temporary array
-        long* pTempDXAry = (long*)alloca( nLength * sizeof(long) );
+        sal_Int32* pTempDXAry = (sal_Int32*)alloca( nLength * sizeof(sal_Int32) );
         // using base position for better rounding a.k.a. "dancing characters"
         int nPixelXOfs = ImplLogicWidthToDevicePixel( rLogicalPos.X() );
         for( int i = 0; i < nLength; ++i )
@@ -6017,7 +5947,6 @@ void OutputDevice::DrawText( const Recta
     if ( ( !IsDeviceOutputNecessary() && ! pVector ) || !rOrigStr.Len() || rRect.IsEmpty() )
         return;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return;
@@ -6025,10 +5954,6 @@ void OutputDevice::DrawText( const Recta
         ImplInitClipRegion();
     if( mbOutputClipped )
         return;
-#else
-    if( !ImplGetServerGraphics() )
-        return;
-#endif
 
     Color aOldTextColor;
     Color aOldTextFillColor;
@@ -6063,10 +5988,14 @@ void OutputDevice::DrawText( const Recta
             SetTextColor( COL_LIGHTGREEN );
         else
         {
+            // draw disabled text always without shadow
+            // as it fits better with native look
+            /*
             SetTextColor( GetSettings().GetStyleSettings().GetLightColor() );
             Rectangle aRect = rRect;
             aRect.Move( 1, 1 );
             DrawText( aRect, rOrigStr, nStyle & ~TEXT_DRAW_DISABLE );
+            */
             SetTextColor( GetSettings().GetStyleSettings().GetShadowColor() );
         }
     }
@@ -6176,7 +6105,7 @@ void OutputDevice::DrawText( const Recta
                         long        nMnemonicY;
                         long        nMnemonicWidth;
 
-                        long *pCaretXArray = (long*) alloca( 2 * sizeof(long) * nLineLen );
+                        sal_Int32* pCaretXArray = (sal_Int32*) alloca( 2 * sizeof(sal_Int32) * nLineLen );
                         BOOL bRet = GetCaretPositions( aStr, pCaretXArray,
                                                 nIndex, nLineLen);
                         long lc_x1 = pCaretXArray[2*(nMnemonicPos - nIndex)];
@@ -6184,11 +6113,7 @@ void OutputDevice::DrawText( const Recta
                         nMnemonicWidth = ::abs((int)(lc_x1 - lc_x2));
 
                         Point       aTempPos = LogicToPixel( aPos );
-#if (_MSC_VER < 1300)
-                        nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( std::min( lc_x1, lc_x2 ) );
-#else
-                        nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( min( lc_x1, lc_x2 ) );
-#endif
+                        nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( Min( lc_x1, lc_x2 ) );
                         nMnemonicY = mnOutOffY + aTempPos.Y() + ImplLogicWidthToDevicePixel( GetFontMetric().GetAscent() );
                         ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, nMnemonicWidth );
                     }
@@ -6251,18 +6176,14 @@ void OutputDevice::DrawText( const Recta
         long        nMnemonicWidth;
         if ( nMnemonicPos != STRING_NOTFOUND )
         {
-            long *pCaretXArray = (long*) alloca( 2 * sizeof(long) * aStr.Len() );
+            sal_Int32* pCaretXArray = (sal_Int32*) alloca( 2 * sizeof(sal_Int32) * aStr.Len() );
             BOOL bRet = GetCaretPositions( aStr, pCaretXArray, 0, aStr.Len() );
             long lc_x1 = pCaretXArray[2*(nMnemonicPos)];
             long lc_x2 = pCaretXArray[2*(nMnemonicPos)+1];
             nMnemonicWidth = ::abs((int)(lc_x1 - lc_x2));
 
             Point aTempPos = LogicToPixel( aPos );
-#if (_MSC_VER < 1300)
-            nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( std::min(lc_x1, lc_x2) );
-#else
-            nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( min(lc_x1, lc_x2) );
-#endif
+            nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( Min(lc_x1, lc_x2) );
             nMnemonicY = mnOutOffY + aTempPos.Y() + ImplLogicWidthToDevicePixel( GetFontMetric().GetAscent() );
         }
 
@@ -6295,6 +6216,9 @@ void OutputDevice::DrawText( const Recta
         if ( bRestoreFillColor )
             SetTextFillColor( aOldTextFillColor );
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawText( rRect, rOrigStr, nStyle, pVector, pDisplayText );
 }
 
 // -----------------------------------------------------------------------
@@ -6559,7 +6483,6 @@ void OutputDevice::DrawCtrlText( const P
         return;
 
     // better get graphics here because ImplDrawMnemonicLine() will not
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return;
@@ -6567,10 +6490,6 @@ void OutputDevice::DrawCtrlText( const P
         ImplInitClipRegion();
     if ( mbOutputClipped )
         return;
-#else
-    if( !ImplGetServerGraphics() )
-        return;
-#endif
 
     if( nIndex >= rStr.Len() )
         return;
@@ -6608,22 +6527,17 @@ void OutputDevice::DrawCtrlText( const P
                 nMnemonicPos = nLen-1;
             }
 
-            long *pCaretXArray = (long*)alloca( 2 * sizeof(long) * nLen );
+            sal_Int32* pCaretXArray = (sal_Int32*)alloca( 2 * sizeof(sal_Int32) * nLen );
             BOOL bRet = GetCaretPositions( aStr, pCaretXArray, nIndex, nLen );
             long lc_x1 = pCaretXArray[ 2*(nMnemonicPos - nIndex) ];
             long lc_x2 = pCaretXArray[ 2*(nMnemonicPos - nIndex)+1 ];
             nMnemonicWidth = ::abs((int)(lc_x1 - lc_x2));
 
-#if (_MSC_VER < 1300)
-            Point aTempPos( std::min(lc_x1,lc_x2), GetFontMetric().GetAscent() );
+            Point aTempPos( Min(lc_x1,lc_x2), GetFontMetric().GetAscent() );
             if( bInvalidPos )  // #106952#, place behind the (last) character
-                aTempPos = Point( std::max(lc_x1,lc_x2), GetFontMetric().GetAscent() );
-#else
-            Point aTempPos( min(lc_x1,lc_x2), GetFontMetric().GetAscent() );
-            if( bInvalidPos )  // #106952#, place behind the (last) character
-                aTempPos = Point( max(lc_x1,lc_x2), GetFontMetric().GetAscent() );
-#endif
-            aTempPos += rPos;
+                aTempPos = Point( Max(lc_x1,lc_x2), GetFontMetric().GetAscent() );
+
+			aTempPos += rPos;
             aTempPos = LogicToPixel( aTempPos );
             nMnemonicX = mnOutOffX + aTempPos.X();
             nMnemonicY = mnOutOffY + aTempPos.Y();
@@ -6688,6 +6602,9 @@ void OutputDevice::DrawCtrlText( const P
                 ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, nMnemonicWidth );
         }
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawCtrlText( rPos, rStr, nIndex, nLen, nStyle, pVector, pDisplayText );
 }
 
 // -----------------------------------------------------------------------
@@ -6835,6 +6752,10 @@ BOOL OutputDevice::AddTempDevFont( const
     if( !pFontData )
         return FALSE;
     mpFontList->Add( pFontData );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->AddTempDevFont( rFileURL, rFontName );
+
     return TRUE;
 }
 
@@ -7101,13 +7023,8 @@ BOOL OutputDevice::GetTextBoundRect( Rec
     long nXOffset = 0;
     if( nBase != nIndex )
     {
-#if (_MSC_VER < 1300)
-        xub_StrLen nStart = std::min( nBase, nIndex );
-        xub_StrLen nOfsLen = std::max( nBase, nIndex ) - nStart;
-#else
-        xub_StrLen nStart = min( nBase, nIndex );
-        xub_StrLen nOfsLen = max( nBase, nIndex ) - nStart;
-#endif
+        xub_StrLen nStart = Min( nBase, nIndex );
+        xub_StrLen nOfsLen = Max( nBase, nIndex ) - nStart;
         pSalLayout = ImplLayout( rStr, nStart, nOfsLen );
         if( pSalLayout )
         {
@@ -7269,7 +7186,7 @@ BOOL OutputDevice::GetTextBoundRect( Rec
 
 BOOL OutputDevice::GetTextOutline( PolyPolygon& rPolyPoly,
     const String& rStr, xub_StrLen nBase, xub_StrLen nIndex, xub_StrLen nLen,
-    BOOL bOptimize, const ULONG nTWidth, const long* pDXArray ) const
+    BOOL bOptimize, const ULONG nTWidth, const sal_Int32* pDXArray ) const
 {
     rPolyPoly.Clear();
     PolyPolyVector aVector;
@@ -7286,7 +7203,7 @@ BOOL OutputDevice::GetTextOutline( PolyP
 
 BOOL OutputDevice::GetTextOutlines( PolyPolyVector& rVector,
     const String& rStr, xub_StrLen nBase, xub_StrLen nIndex,
-    xub_StrLen nLen, BOOL bOptimize, const ULONG nTWidth, const long* pDXArray ) const
+    xub_StrLen nLen, BOOL bOptimize, const ULONG nTWidth, const sal_Int32* pDXArray ) const
 {
     BOOL bRet = FALSE;
     rVector.clear();
@@ -7309,13 +7226,8 @@ BOOL OutputDevice::GetTextOutlines( Poly
     long nXOffset = 0;
     if( nBase != nIndex )
     {
-#if (_MSC_VER < 1300)
-        xub_StrLen nStart = std::min( nBase, nIndex );
-        xub_StrLen nOfsLen = std::max( nBase, nIndex ) - nStart;
-#else
-        xub_StrLen nStart = min( nBase, nIndex );
-        xub_StrLen nOfsLen = max( nBase, nIndex ) - nStart;
-#endif
+        xub_StrLen nStart = Min( nBase, nIndex );
+        xub_StrLen nOfsLen = Max( nBase, nIndex ) - nStart;
         pSalLayout = ImplLayout( rStr, nStart, nOfsLen, Point( 0,0 ), nTWidth, pDXArray );
         if( pSalLayout )
         {
@@ -7401,8 +7313,8 @@ BOOL OutputDevice::GetTextOutlines( Poly
     if (pSalLayout == 0)
         return false;
     long nWidth = pSalLayout->GetTextWidth();
-    long nHeight = aVDev.mpFontEntry->mnLineHeight + aVDev.mnEmphasisAscent
-        + aVDev.mnEmphasisDescent;
+    long nHeight = ((OutputDevice*)&aVDev)->mpFontEntry->mnLineHeight + ((OutputDevice*)&aVDev)->mnEmphasisAscent
+        + ((OutputDevice*)&aVDev)->mnEmphasisDescent;
     pSalLayout->Release();
 
     if( !nWidth || !nHeight )
@@ -7446,8 +7358,8 @@ BOOL OutputDevice::GetTextOutlines( Poly
             // draw glyph into virtual device
             aVDev.Erase();
             pSalLayout->DrawBase() += aOffset;
-            pSalLayout->DrawBase() += Point( aVDev.mnTextOffX, aVDev.mnTextOffY );
-            pSalLayout->DrawText( *aVDev.mpGraphics );
+            pSalLayout->DrawBase() += Point( ((OutputDevice*)&aVDev)->mnTextOffX, ((OutputDevice*)&aVDev)->mnTextOffY );
+            pSalLayout->DrawText( *((OutputDevice*)&aVDev)->mpGraphics );
             pSalLayout->Release();
 
             // convert character image into outline
@@ -7467,11 +7379,11 @@ BOOL OutputDevice::GetTextOutlines( Poly
                         Point& rPt = rPoly[k];
                         rPt.X() = FRound(ImplDevicePixelToLogicWidth(
                                              nXOffset + rPt.X() - aOffset.X()
-                                             - aVDev.mnTextOffX)
+                                             - ((OutputDevice*)&aVDev)->mnTextOffX)
                                          * fScaleX);
                         rPt.Y() = FRound(ImplDevicePixelToLogicHeight(
                                              rPt.Y() - aOffset.Y()
-                                             - aVDev.mnTextOffY)
+                                             - ((OutputDevice*)&aVDev)->mnTextOffY)
                                          * fScaleY);
                     }
                 }
@@ -7499,13 +7411,9 @@ BOOL OutputDevice::GetFontCharMap( FontC
 {
     rFontCharMap.ImplSetDefaultRanges();
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return FALSE;
-#else
-    ImplGetServerGraphics();
-#endif
 
     if( mbNewFont )
         const_cast<OutputDevice&>(*this).ImplNewFont();
Index: vcl/source/gdi/outdev4.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev4.cxx,v
retrieving revision 1.13.136.1
retrieving revision 1.17
diff -u -p -u -r1.13.136.1 -r1.17
--- vcl/source/gdi/outdev4.cxx	9 Jan 2004 18:13:45 -0000	1.13.136.1
+++ vcl/source/gdi/outdev4.cxx	6 Jan 2004 13:50:37 -0000	1.17
@@ -59,24 +59,14 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
-
 #include <math.h>
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -95,14 +85,14 @@
 #ifndef _SV_OUTDATA_HXX
 #include <outdata.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_LINE_HXX
-#include <line.hxx>
+#ifndef _LINE_HXX
+#include <tools/line.hxx>
 #endif
 #ifndef _SV_HATCH_HXX
 #include <hatch.hxx>
@@ -147,8 +137,6 @@ DBG_NAMEEX( Gradient );
 
 // =======================================================================
 
-#ifndef REMOTE_APPSERVER
-
 void OutputDevice::ImplDrawPolygon( const Polygon& rPoly, const PolyPolygon* pClipPolyPoly )
 {
 	if( pClipPolyPoly )
@@ -224,8 +212,6 @@ void OutputDevice::ImplDrawPolyPolygon( 
 		delete pPolyPoly;
 }
 
-#endif
-
 // -----------------------------------------------------------------------
 
 inline UINT8 ImplGetGradientColorValue( long nValue )
@@ -395,10 +381,8 @@ void OutputDevice::ImplDrawLinearGradien
 
 	if ( bMtf )
 		mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
-#ifndef REMOTE_APPSERVER
 	else
 		mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
-#endif
 
 	// Startpolygon erzeugen (== Borderpolygon)
 	Polygon 	aPoly( 4 );
@@ -415,10 +399,8 @@ void OutputDevice::ImplDrawLinearGradien
 		// berechnetesPolygon ausgeben
 		if ( bMtf )
 			mpMetaFile->AddAction( new MetaPolygonAction( aPoly ) );
-#ifndef REMOTE_APPSERVER
 		else
 			ImplDrawPolygon( aPoly, pClipPolyPoly );
-#endif
 
 		// neues Polygon berechnen
 		aRect.Top() = (long)(fScanLine += fScanInc);
@@ -484,10 +466,8 @@ void OutputDevice::ImplDrawLinearGradien
 
 		if ( bMtf )
 			mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
-#ifndef REMOTE_APPSERVER
 		else
 			mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
-#endif
 	}
 }
 
@@ -630,17 +610,14 @@ void OutputDevice::ImplDrawComplexGradie
 
 	if( bMtf )
 		mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
-#ifndef REMOTE_APPSERVER
 	else
 		mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
-#endif
 
 	if( pPolyPoly )
 	{   
     	pPolyPoly->Insert( aPoly = rRect );
 		pPolyPoly->Insert( aPoly );
 	}
-#ifndef REMOTE_APPSERVER
 	else
     {
 	    // extend rect, to avoid missing bounding line
@@ -653,7 +630,6 @@ void OutputDevice::ImplDrawComplexGradie
 
 		ImplDrawPolygon( aPoly = aExtRect, pClipPolyPoly );
     }
-#endif
 
 	// Schleife, um nacheinander die Polygone/PolyPolygone auszugeben
 	for( long i = 1; i < nSteps; i++ )
@@ -690,10 +666,8 @@ void OutputDevice::ImplDrawComplexGradie
 
 			if( bMtf )
 				mpMetaFile->AddAction( new MetaPolyPolygonAction( *pPolyPoly ) );
-#ifndef REMOTE_APPSERVER
 			else
 				ImplDrawPolyPolygon( *pPolyPoly, pClipPolyPoly );
-#endif
 
             // #107349# Set fill color _after_ geometry painting:
             // pPolyPoly's geometry is the band from last iteration's
@@ -707,7 +681,6 @@ void OutputDevice::ImplDrawComplexGradie
             else
                 mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
 		}
-#ifndef REMOTE_APPSERVER
 		else
         {
             // #107349# Set fill color _before_ geometry painting
@@ -718,7 +691,6 @@ void OutputDevice::ImplDrawComplexGradie
 
 			ImplDrawPolygon( aPoly, pClipPolyPoly );
         }
-#endif
 	}
 
 	// Falls PolyPolygon-Ausgabe, muessen wir noch ein letztes inneres Polygon zeichnen
@@ -743,13 +715,11 @@ void OutputDevice::ImplDrawComplexGradie
 	    		mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
 				mpMetaFile->AddAction( new MetaPolygonAction( rPoly ) );
             }
-#ifndef REMOTE_APPSERVER
 		    else
             {
 			    mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
    				ImplDrawPolygon( rPoly, pClipPolyPoly );
             }
-#endif
 		}
 
 		delete pPolyPoly;
@@ -835,7 +805,6 @@ void OutputDevice::DrawGradient( const R
 	// Wenn Rechteck leer ist, brauchen wir nichts machen
 	if ( !aRect.IsEmpty() )
 	{
-#ifndef REMOTE_APPSERVER
 		// Clip Region sichern
 		Push( PUSH_CLIPREGION );
 		IntersectClipRegion( rRect );
@@ -879,12 +848,10 @@ void OutputDevice::DrawGradient( const R
 		}
 
 		Pop();
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-			pGraphics->DrawGradient( aRect, aGradient );
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -990,7 +957,6 @@ void OutputDevice::DrawGradient( const P
 			aGradient.SetEndColor( aEndCol );
 		}
 
-#ifndef REMOTE_APPSERVER
 		if( OUTDEV_PRINTER == meOutDevType )
 		{
 			const Rectangle	aBoundRect( rPolyPoly.GetBoundRect() );
@@ -1054,41 +1020,52 @@ void OutputDevice::DrawGradient( const P
 
 			if( !aDstRect.IsEmpty() )
 			{
-				VirtualDevice	aVDev;
+				VirtualDevice*	pVDev;
 				const Size		aDstSize( aDstRect.GetSize() );
 
-				if( aVDev.SetOutputSizePixel( aDstSize) )
+                if( HasAlpha() )
+                {
+                    // #110958# Pay attention to alpha VDevs here, otherwise, 
+                    // background will be wrong: Temp VDev has to have alpha, too.
+                    pVDev = new VirtualDevice( *this, 0, GetAlphaBitCount() > 1 ? 0 : 1 );
+                }
+                else
+                {
+                    // nothing special here. Plain VDev
+                    pVDev = new VirtualDevice();
+                }
+
+				if( pVDev->SetOutputSizePixel( aDstSize) )
 				{
 					MapMode			aVDevMap;
-					const RasterOp	eOldROP = GetRasterOp();
 					const BOOL		bOldMap = mbMap;
 
-					mbMap = FALSE;
+					EnableMapMode( FALSE );
 
-					aVDev.DrawOutDev( Point(), aDstSize, aDstRect.TopLeft(), aDstSize, *this );
-					aVDev.SetRasterOp( ROP_XOR );
+					pVDev->DrawOutDev( Point(), aDstSize, aDstRect.TopLeft(), aDstSize, *this );
+					pVDev->SetRasterOp( ROP_XOR );
 					aVDevMap.SetOrigin( Point( -aDstRect.Left(), -aDstRect.Top() ) );
-					aVDev.SetMapMode( aVDevMap );
-					aVDev.DrawGradient( aBoundRect, aGradient );
-					aVDev.SetFillColor( COL_BLACK );
-					aVDev.SetRasterOp( ROP_0 );
-					aVDev.DrawPolyPolygon( aPolyPoly );
-					aVDev.SetRasterOp( ROP_XOR );
-					aVDev.DrawGradient( aBoundRect, aGradient );
+					pVDev->SetMapMode( aVDevMap );
+					pVDev->DrawGradient( aBoundRect, aGradient );
+					pVDev->SetFillColor( COL_BLACK );
+					pVDev->SetRasterOp( ROP_0 );
+					pVDev->DrawPolyPolygon( aPolyPoly );
+					pVDev->SetRasterOp( ROP_XOR );
+					pVDev->DrawGradient( aBoundRect, aGradient );
 					aVDevMap.SetOrigin( Point() );
-					aVDev.SetMapMode( aVDevMap );
-					DrawOutDev( aDstRect.TopLeft(), aDstSize, Point(), aDstSize, aVDev );
+					pVDev->SetMapMode( aVDevMap );
+					DrawOutDev( aDstRect.TopLeft(), aDstSize, Point(), aDstSize, *pVDev );
 
-					mbMap = bOldMap;
+					EnableMapMode( bOldMap );
 				}
+
+                delete pVDev;
 			}
 		}
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-			pGraphics->DrawGradient( ImplLogicToDevicePixel( rPolyPoly ), aGradient );
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyPolygon( rPolyPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -1180,7 +1157,6 @@ void OutputDevice::DrawHatch( const Poly
 	if( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	if( !mpGraphics && !ImplGetGraphics() )
 		return;
 
@@ -1189,39 +1165,29 @@ void OutputDevice::DrawHatch( const Poly
 
 	if( mbOutputClipped )
 		return;
-#endif
 
 	if( rPolyPoly.Count() )
 	{ 
-#ifndef REMOTE_APPSERVER
 		PolyPolygon		aPolyPoly( LogicToPixel( rPolyPoly ) );
 		GDIMetaFile*	pOldMetaFile = mpMetaFile;
 		BOOL			bOldMap = mbMap;
 
 		aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
-		aHatch.SetDistance( ImplLogicWidthToDevicePixel( aHatch.GetDistance() ) );
+        aHatch.SetDistance( ImplLogicWidthToDevicePixel( aHatch.GetDistance() ) );
 
 		mpMetaFile = NULL;
-		mbMap = FALSE;
+		EnableMapMode( FALSE );
 		Push( PUSH_LINECOLOR );
 		SetLineColor( aHatch.GetColor() );
 		ImplInitLineColor();
 		ImplDrawHatch( aPolyPoly, aHatch, FALSE );
 		Pop();
-		mbMap = bOldMap;
+		EnableMapMode( bOldMap );
 		mpMetaFile = pOldMetaFile;
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-		{
-			PolyPolygon aPolyPoly( ImplLogicToDevicePixel( rPolyPoly ) );
-
-			aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
-			aHatch.SetDistance( ImplLogicWidthToDevicePixel( aHatch.GetDistance() ) );
-			pGraphics->DrawHatch( aPolyPoly, aHatch );
-		}
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawHatch( rPolyPoly, rHatch );
 }
 
 // -----------------------------------------------------------------------
@@ -1422,7 +1388,6 @@ void OutputDevice::ImplDrawHatchLine( co
 
 		if( rPoly.GetSize() > 1 )
 		{
-			Point	aIntersection;
 			Line	aCurSegment( rPoly[ 0 ], Point() );
 
 			for( long i = 1, nCount = rPoly.GetSize(); i <= nCount; i++ )
@@ -1482,20 +1447,19 @@ void OutputDevice::ImplDrawHatchLine( co
 		}
 		else
 		{
-#ifndef REMOTE_APPSERVER
 			for( long i = 0; i < nPCounter; i += 2 )
 			{
                 if( mpPDFWriter )
-                    mpPDFWriter->drawLine( pPtBuffer[i], pPtBuffer[i+1] );
+                {
+                    mpPDFWriter->drawLine( pPtBuffer[ i ], pPtBuffer[ i+1 ] );
+                }
                 else
                 {
                     const Point aPt1( ImplLogicToDevicePixel( pPtBuffer[ i ] ) );
                     const Point aPt2( ImplLogicToDevicePixel( pPtBuffer[ i + 1 ] ) );
-                    
                     mpGraphics->DrawLine( aPt1.X(), aPt1.Y(), aPt2.X(), aPt2.Y(), this );
                 }
 			}
-#endif
 		}
 	}
 }
Index: vcl/source/gdi/outdev5.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev5.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/gdi/outdev5.cxx	27 Mar 2003 17:58:00 -0000	1.3
+++ vcl/source/gdi/outdev5.cxx	6 Jan 2004 13:51:01 -0000	1.6
@@ -59,23 +59,14 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
 #include <tools/ref.hxx>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -84,7 +75,7 @@
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_METAACT_HXX
@@ -102,6 +93,9 @@
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
 #endif
+#ifndef _SV_VIRDEV_HXX
+#include <virdev.hxx>
+#endif
 
 // =======================================================================
 
@@ -129,7 +123,6 @@ void OutputDevice::DrawRect( const Recta
 	nHorzRound = ImplLogicWidthToDevicePixel( nHorzRound );
 	nVertRound = ImplLogicHeightToDevicePixel( nVertRound );
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -163,20 +156,9 @@ void OutputDevice::DrawRect( const Recta
 				mpGraphics->DrawPolygon( aRoundRectPoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		if ( !nHorzRound || !nVertRound )
-			pGraphics->DrawRect( aRect );
-		else
-			pGraphics->DrawRect( aRect, nHorzRound, nVertRound );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( rRect, nHorzRound, nVertRound );
 }
 
 // -----------------------------------------------------------------------
@@ -196,7 +178,6 @@ void OutputDevice::DrawEllipse( const Re
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -225,17 +206,9 @@ void OutputDevice::DrawEllipse( const Re
 			mpGraphics->DrawPolygon( aRectPoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawEllipse( aRect );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawEllipse( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -256,7 +229,6 @@ void OutputDevice::DrawArc( const Rectan
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -281,19 +253,9 @@ void OutputDevice::DrawArc( const Rectan
 		const SalPoint* pPtAry = (const SalPoint*)aArcPoly.GetConstPointAry();
 		mpGraphics->DrawPolyLine( aArcPoly.GetSize(), pPtAry, this );
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawArc( aRect,
-							ImplLogicToDevicePixel( rStartPt ),
-							ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawArc( rRect, rStartPt, rEndPt );
 }
 
 // -----------------------------------------------------------------------
@@ -314,7 +276,6 @@ void OutputDevice::DrawPie( const Rectan
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -346,19 +307,9 @@ void OutputDevice::DrawPie( const Rectan
 			mpGraphics->DrawPolygon( aPiePoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawPie( aRect,
-							ImplLogicToDevicePixel( rStartPt ),
-							ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPie( rRect, rStartPt, rEndPt );
 }
 
 // -----------------------------------------------------------------------
@@ -379,7 +330,6 @@ void OutputDevice::DrawChord( const Rect
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -411,17 +361,7 @@ void OutputDevice::DrawChord( const Rect
 			mpGraphics->DrawPolygon( aChordPoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawChord( aRect,
-							  ImplLogicToDevicePixel( rStartPt ),
-							  ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawChord( rRect, rStartPt, rEndPt );
 }
Index: vcl/source/gdi/outdev6.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev6.cxx,v
retrieving revision 1.5
retrieving revision 1.9
diff -u -p -u -r1.5 -r1.9
--- vcl/source/gdi/outdev6.cxx	8 Apr 2003 15:35:51 -0000	1.5
+++ vcl/source/gdi/outdev6.cxx	17 May 2004 16:00:10 -0000	1.9
@@ -59,19 +59,13 @@
  *
  ************************************************************************/
 
-#define _SV_WALL_CXX
-
 #include <math.h>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else // REMOTE_APPSERVER
-#include <tools/stream.hxx>
-#endif // REMOTE_APPSERVER
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -102,8 +96,8 @@
 #ifndef _SV_GRAPH_HXX
 #include <graph.hxx>
 #endif
-#ifdef REMOTE_APPSERVER
-#include <rmoutdev.hxx>
+#ifndef _SV_WALL2_HXX
+#include <wall2.hxx>
 #endif
 #ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
 #include <com/sun/star/uno/Sequence.hxx>
@@ -126,7 +120,6 @@ void OutputDevice::DrawGrid( const Recta
 	if( aDstRect.IsEmpty() || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	if( !mpGraphics && !ImplGetGraphics() )
 		return;
 
@@ -135,12 +128,6 @@ void OutputDevice::DrawGrid( const Recta
 
 	if( mbOutputClipped )
 		return;
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-
-	if( !pGraphics )
-		return;
-#endif
 
 	const long	nDistX = Max( rDist.Width(), 1L );
 	const long	nDistY = Max( rDist.Height(), 1L );
@@ -180,9 +167,8 @@ void OutputDevice::DrawGrid( const Recta
 	if( mbInitFillColor )
 		ImplInitFillColor();
 
-#ifndef REMOTE_APPSERVER
 	const BOOL bOldMap = mbMap;
-	mbMap = FALSE;
+	EnableMapMode( FALSE );
 
 	if( nFlags & GRID_DOTS )
 	{
@@ -211,12 +197,10 @@ void OutputDevice::DrawGrid( const Recta
 		}
 	}
 
-	mbMap = bOldMap;
-#else // REMOTE_APPSERVER
-	aHorzBuf.realloc( nHorzCount );
-	aVertBuf.realloc( nVertCount );
-	pGraphics->DrawGrid( nStartX, nEndX, aHorzBuf, nStartY, nEndY, aVertBuf, nFlags );
-#endif // REMOTE_APPSERVER
+	EnableMapMode( bOldMap );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawGrid( rRect, rDist, nFlags );
 }
 
 // ------------------------------------------------------------------------
@@ -241,6 +225,13 @@ void OutputDevice::DrawTransparent( cons
 		if( mpMetaFile )
 			mpMetaFile->AddAction( new MetaTransparentAction( rPolyPoly, nTransparencePercent ) );
 
+        VirtualDevice* pOldAlphaVDev = mpAlphaVDev;
+
+        // #110958# Disable alpha VDev, we perform the necessary
+        // operation explicitely further below.
+        if( mpAlphaVDev )
+            mpAlphaVDev = NULL;
+
 		if( !IsDeviceOutputNecessary() || ( !mbLineColor && !mbFillColor ) || ImplIsRecordLayout() )
 			return;
 
@@ -272,7 +263,7 @@ void OutputDevice::DrawTransparent( cons
 			Rectangle aRect( aPolyRect.TopLeft(), Size( aPolyRect.GetWidth(), nBaseExtent ) );
 
 			const BOOL bOldMap = mbMap;
-			mbMap = FALSE;
+			EnableMapMode( FALSE );
 
 			while( aRect.Top() <= aPolyRect.Bottom() )
 			{
@@ -287,12 +278,11 @@ void OutputDevice::DrawTransparent( cons
 				aRect.Move( nMove, 0 );
 			}
 
-			mbMap = bOldMap;
+			EnableMapMode( bOldMap );
 			Pop();
 		}
 		else
 		{
-#ifndef REMOTE_APPSERVER
 			PolyPolygon 	aPolyPoly( LogicToPixel( rPolyPoly ) );
 			Rectangle		aPolyRect( aPolyPoly.GetBoundRect() );
 			Point			aPoint;
@@ -321,7 +311,7 @@ void OutputDevice::DrawTransparent( cons
 				{
 					const BOOL bOldMap = mbMap;
 
-					mbMap = FALSE;
+					EnableMapMode( FALSE );
 
 					aVDev.SetLineColor( COL_BLACK );
 					aVDev.SetFillColor( COL_BLACK );
@@ -438,7 +428,7 @@ void OutputDevice::DrawTransparent( cons
 
                         DrawBitmap( aDstRect.TopLeft(), aPaint );
 
-                        mbMap = bOldMap;
+                        EnableMapMode( bOldMap );
 
                         if( mbLineColor )
                         {
@@ -452,20 +442,25 @@ void OutputDevice::DrawTransparent( cons
 				else
 					DrawPolyPolygon( rPolyPoly );
 			}
-#else // REMOTE_APPSERVER
-			ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-			if ( pGraphics )
-			{
-				if ( mbInitLineColor )
-					ImplInitLineColor();
-				if ( mbInitFillColor )
-					ImplInitFillColor();
-				pGraphics->DrawTransparent( ImplLogicToDevicePixel( rPolyPoly ), nTransparencePercent );
-			}
-#endif // REMOTE_APPSERVER
 		}
 
 		mpMetaFile = pOldMetaFile;
+
+        // #110958# Restore disabled alpha VDev
+        mpAlphaVDev = pOldAlphaVDev;
+
+        // #110958# Apply alpha value also to VDev alpha channel
+        if( mpAlphaVDev )
+        {
+            const Color aFillCol( mpAlphaVDev->GetFillColor() );
+            mpAlphaVDev->SetFillColor( Color(255*nTransparencePercent/100,
+                                             255*nTransparencePercent/100,
+                                             255*nTransparencePercent/100) );
+
+            mpAlphaVDev->DrawTransparent( rPolyPoly, nTransparencePercent );
+
+            mpAlphaVDev->SetFillColor( aFillCol );
+        }
 	}
 }
 
@@ -511,8 +506,8 @@ void OutputDevice::DrawTransparent( cons
 		{
 			VirtualDevice* pVDev = new VirtualDevice;
 
-			pVDev->mnDPIX = mnDPIX;
-			pVDev->mnDPIY = mnDPIY;
+			((OutputDevice*)pVDev)->mnDPIX = mnDPIX;
+			((OutputDevice*)pVDev)->mnDPIY = mnDPIY;
 
 			if( pVDev->SetOutputSizePixel( aDstRect.GetSize() ) )
 			{
@@ -553,17 +548,13 @@ void OutputDevice::DrawTransparent( cons
 				pVDev->EnableMapMode( FALSE );
 				pVDev->DrawMask( Point(), pVDev->GetOutputSizePixel(), aMask, Color( COL_WHITE ) );
 
-#ifndef REMOTE_APPSERVER
 				aAlpha = pVDev->GetBitmap( Point(), pVDev->GetOutputSizePixel() );
-#else
-				aAlpha.ImplSetBitmap( pVDev->GetBitmap( Point(), pVDev->GetOutputSizePixel() ) );
-#endif
 
 				delete pVDev;
 
-				mbMap = FALSE;
+				EnableMapMode( FALSE );
 				DrawBitmapEx( aDstRect.TopLeft(), BitmapEx( aPaint, aAlpha ) );
-				mbMap = bOldMap;
+				EnableMapMode( bOldMap );
 			}
 			else
 				delete pVDev;
@@ -579,7 +570,6 @@ void OutputDevice::ImplDrawColorWallpape
 										   long nWidth, long nHeight,
 										   const Wallpaper& rWallpaper )
 {
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -604,23 +594,6 @@ void OutputDevice::ImplDrawColorWallpape
 	mpGraphics->DrawRect( nX+mnOutOffX, nY+mnOutOffY, nWidth, nHeight, this );
 	SetLineColor( aOldLineColor );
 	SetFillColor( aOldFillColor );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		Color aOldLineColor = GetLineColor();
-		Color aOldFillColor = GetFillColor();
-		SetLineColor();
-		SetFillColor( rWallpaper.GetColor() );
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawRect( Rectangle( Point( nX+mnOutOffX, nY+mnOutOffY ), Size( nWidth, nHeight ) ) );
-		SetLineColor( aOldLineColor );
-		SetFillColor( aOldFillColor );
-	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -699,7 +672,7 @@ void OutputDevice::ImplDrawBitmapWallpap
 	}
 
 	mpMetaFile = NULL;
-	mbMap = FALSE;
+	EnableMapMode( FALSE );
 	Push( PUSH_CLIPREGION );
 	IntersectClipRegion( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ) );
 
@@ -862,7 +835,7 @@ void OutputDevice::ImplDrawBitmapWallpap
 	rWallpaper.ImplGetImpWallpaper()->ImplSetCachedBitmap( aBmpEx );
 
 	Pop();
-	mbMap = bOldMap;
+	EnableMapMode( bOldMap );
 	mpMetaFile = pOldMetaFile;
 }
 
@@ -884,14 +857,14 @@ void OutputDevice::ImplDrawGradientWallp
 		aBound = Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) );
 
 	mpMetaFile = NULL;
-	mbMap = FALSE;
+	EnableMapMode( FALSE );
 	Push( PUSH_CLIPREGION );
 	IntersectClipRegion( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ) );
 
 	DrawGradient( aBound, rWallpaper.GetGradient() );
 
 	Pop();
-	mbMap = bOldMap;
+	EnableMapMode( bOldMap );
 	mpMetaFile = pOldMetaFile;
 }
 
@@ -931,6 +904,9 @@ void OutputDevice::DrawWallpaper( const 
 							   rWallpaper );
 		}
 	}
+    
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawWallpaper( rRect, rWallpaper );
 }
 
 // -----------------------------------------------------------------------
@@ -949,6 +925,9 @@ void OutputDevice::Erase()
 		if ( eRasterOp != ROP_OVERPAINT )
 			SetRasterOp( eRasterOp );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->Erase();
 }
 
 // -----------------------------------------------------------------------
@@ -957,40 +936,12 @@ void OutputDevice::ImplDraw2ColorFrame( 
 										const Color& rLeftTopColor,
 										const Color& rRightBottomColor )
 {
-#ifndef REMOTE_APPSERVER
 	SetFillColor( rLeftTopColor );
 	DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Left(), rRect.Bottom()-1 ) ) );
 	DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Right()-1, rRect.Top() ) ) );
 	SetFillColor( rRightBottomColor );
 	DrawRect( Rectangle( rRect.BottomLeft(), rRect.BottomRight() ) );
 	DrawRect( Rectangle( rRect.TopRight(), rRect.BottomRight() ) );
-#else
-	if ( mpMetaFile )
-	{
-		BOOL bOutputEnabled = IsOutputEnabled();
-		EnableOutput( FALSE );
-		SetFillColor( rLeftTopColor );
-		DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Left(), rRect.Bottom()-1 ) ) );
-		DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Right()-1, rRect.Top() ) ) );
-		SetFillColor( rRightBottomColor );
-		DrawRect( Rectangle( rRect.BottomLeft(), rRect.BottomRight() ) );
-		DrawRect( Rectangle( rRect.TopRight(), rRect.BottomRight() ) );
-		EnableOutput( bOutputEnabled );
-	}
-
-	if ( IsDeviceOutputNecessary() && !rRect.IsEmpty() )
-	{
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-		{
-			if ( mbInitLineColor )
-				ImplInitLineColor();
-			Rectangle aRect( ImplLogicToDevicePixel( rRect ) );
-			pGraphics->Draw2ColorFrame( aRect, rLeftTopColor, rRightBottomColor );
-		}
-	}
-	SetFillColor( rRightBottomColor );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1011,6 +962,9 @@ void OutputDevice::DrawEPS( const Point&
 	if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
 		return;
 
+	if( mbOutputClipped )
+		return;
+
 	Rectangle	aRect( ImplLogicToDevicePixel( Rectangle( rPoint, rSize ) ) );
 	BOOL		bDrawn = FALSE;
 
@@ -1020,21 +974,14 @@ void OutputDevice::DrawEPS( const Point&
 
 		if( GetOutDevType() == OUTDEV_PRINTER )
 		{
-#ifndef REMOTE_APPSERVER
 			if( !mpGraphics && !ImplGetGraphics() )
 				return;
 
 			if( mbInitClipRegion )
 				ImplInitClipRegion();
 
-			if( !mbOutputClipped )
-			{
-				bDrawn = mpGraphics->DrawEPS( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(),
-											  (BYTE*) rGfxLink.GetData(), rGfxLink.GetDataSize(), this );
-			}
-#else
-			DBG_ERROR( "No direct EPS-support for remote appserver!" );
-#endif
+            bDrawn = mpGraphics->DrawEPS( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(),
+                                          (BYTE*) rGfxLink.GetData(), rGfxLink.GetDataSize(), this );
 		}
 
 		if( !bDrawn && pSubst )
@@ -1046,4 +993,7 @@ void OutputDevice::DrawEPS( const Point&
 			mpMetaFile = pOldMetaFile;
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawEPS( rPoint, rSize, rGfxLink, pSubst );
 }
Index: vcl/source/gdi/outmap.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outmap.cxx,v
retrieving revision 1.10.122.1
retrieving revision 1.13
diff -u -p -u -r1.10.122.1 -r1.13
--- vcl/source/gdi/outmap.cxx	17 Sep 2003 08:35:33 -0000	1.10.122.1
+++ vcl/source/gdi/outmap.cxx	6 Jan 2004 13:51:57 -0000	1.13
@@ -61,8 +61,6 @@
 
 #include <limits.h>
 
-#define _SV_OUTMAP_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -74,10 +72,13 @@
 #include <tools/debug.hxx>
 #endif
 
+#ifndef _SV_VIRDEV_HXX
+#include <virdev.hxx>
+#endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_REGION_HXX
@@ -811,6 +812,16 @@ Region OutputDevice::ImplPixelToDevicePi
 
 // -----------------------------------------------------------------------
 
+void OutputDevice::EnableMapMode( BOOL bEnable ) 
+{ 
+    mbMap = (bEnable != 0); 
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->EnableMapMode( bEnable );    
+}
+
+// -----------------------------------------------------------------------
+
 void OutputDevice::SetMapMode()
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
@@ -836,6 +847,9 @@ void OutputDevice::SetMapMode()
         mnOutOffLogicX = mnOutOffOrigX; // no mapping -> equal offsets
         mnOutOffLogicY = mnOutOffOrigY;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetMapMode();    
 }
 
 // -----------------------------------------------------------------------
@@ -859,6 +873,9 @@ void OutputDevice::SetMapMode( const Map
 	if ( maMapMode == rNewMapMode )
 		return;
 
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetMapMode( rNewMapMode );
+
 	// Ist Default-MapMode, dann bereche nichts
 	BOOL bOldMap = mbMap;
 	mbMap = !rNewMapMode.IsDefault();
@@ -999,6 +1016,9 @@ void OutputDevice::SetRelativeMapMode( c
 	mnOutOffLogicY = ImplPixelToLogic( mnOutOffOrigY, mnDPIY,
                                        maMapRes.mnMapScNumY, maMapRes.mnMapScDenomY,
                                        maThresRes.mnThresPixToLogY );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRelativeMapMode( rNewMapMode );
 }
 
 // -----------------------------------------------------------------------
@@ -2113,6 +2133,9 @@ void OutputDevice::SetPixelOffset( const
 	mnOutOffLogicY = ImplPixelToLogic( mnOutOffOrigY, mnDPIY,
                                        maMapRes.mnMapScNumY, maMapRes.mnMapScDenomY,
                                        maThresRes.mnThresPixToLogY );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetPixelOffset( rOffset );
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/gdi/pdfwriter.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pdfwriter.cxx,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -p -u -r1.8 -r1.9
--- vcl/source/gdi/pdfwriter.cxx	28 May 2003 12:30:50 -0000	1.8
+++ vcl/source/gdi/pdfwriter.cxx	17 Jun 2004 12:19:19 -0000	1.9
@@ -129,7 +129,7 @@ void PDFWriter::DrawTextLine(
 void PDFWriter::DrawTextArray(
                               const Point& rStartPt,
                               const XubString& rStr,
-                              const long* pDXAry,
+                              const sal_Int32* pDXAry,
                               xub_StrLen nIndex,
                               xub_StrLen nLen )
 {
Index: vcl/source/gdi/pdfwriter_impl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pdfwriter_impl.cxx,v
retrieving revision 1.55.10.6
retrieving revision 1.68
diff -u -p -u -r1.55.10.6 -r1.68
--- vcl/source/gdi/pdfwriter_impl.cxx	13 Feb 2004 13:20:46 -0000	1.55.10.6
+++ vcl/source/gdi/pdfwriter_impl.cxx	17 Jun 2004 12:39:36 -0000	1.68
@@ -59,6 +59,9 @@
  *
  ************************************************************************/
 
+#define _USE_MATH_DEFINES
+#include <math.h>
+
 #include <pdfwriter_impl.hxx>
 #include <rtl/strbuf.hxx>
 #include <tools/debug.hxx>
@@ -71,29 +74,19 @@
 #include <outdev.h>
 #include <sallayout.hxx>
 #include <metric.hxx>
-#ifndef REMOTE_APPSERVER
 #include <svsys.h>
 #include <salgdi.hxx>
-#else
-#include <rmoutdev.hxx>
-#endif
 #include <osl/thread.h>
 #include <osl/file.h>
 #include <rtl/crc.h>
 
 #include "implncvt.hxx"
 
-#include <math.h>
 #ifdef WNT
 // Aaarrgh
 #define M_PI 3.14159265
 #endif
 
-#define ENABLE_COMPRESSION
-#if OSL_DEBUG_LEVEL < 2
-#define COMPRESS_PAGES
-#endif
-
 using namespace vcl;
 using namespace rtl;
 
@@ -246,6 +234,117 @@ static void appendNonStrokingColor( cons
     }
 }
 
+// matrix helper class
+namespace vcl
+{
+/*	for sparse matrices of the form (2D linear transformations)
+ *  f[0] f[1] 0
+ *  f[2] f[3] 0
+ *  f[4] f[5] 1
+ */
+class Matrix3
+{
+    double f[6];
+
+    void set( double *pn ) { for( int i = 0 ; i < 5; i++ ) f[i] = pn[i]; }
+public:
+    Matrix3();
+    ~Matrix3() {}
+
+    void skew( double alpha, double beta );
+    void scale( double sx, double sy );
+    void rotate( double angle );
+    void translate( double tx, double ty );
+
+    void append( PDFWriterImpl::PDFPage& rPage, OStringBuffer& rBuffer, Point* pBack = NULL );
+
+    Point transform( const Point& rPoint );
+};
+}
+
+Matrix3::Matrix3()
+{
+    // initialize to unity
+    f[0] = 1.0;
+    f[1] = 0.0;
+    f[2] = 0.0;
+    f[3] = 1.0;
+    f[4] = 0.0;
+    f[5] = 0.0;
+}
+
+Point Matrix3::transform( const Point& rOrig )
+{
+    double x = (double)rOrig.X(), y = (double)rOrig.Y();
+    return Point( (int)(x*f[0] + y*f[2] + f[4]), (int)(x*f[1] + y*f[3] + f[5]) );
+}
+
+void Matrix3::skew( double alpha, double beta )
+{
+    double fn[6];
+    double tb = tan( beta );
+    fn[0] = f[0] + f[2]*tb;
+    fn[1] = f[1];
+    fn[2] = f[2] + f[3]*tb;
+    fn[3] = f[3];
+    fn[4] = f[4] + f[5]*tb;
+    fn[5] = f[5];
+    if( alpha != 0.0 )
+    {
+        double ta = tan( alpha );
+        fn[1] += f[0]*ta;
+        fn[3] += f[2]*ta;
+        fn[5] += f[4]*ta;
+    }
+    set( fn );
+}
+
+void Matrix3::scale( double sx, double sy )
+{
+    double fn[6];
+    fn[0] = sx*f[0];
+    fn[1] = sy*f[1];
+    fn[2] = sx*f[2];
+    fn[3] = sy*f[3];
+    fn[4] = sx*f[4];
+    fn[5] = sy*f[5];
+    set( fn );
+}
+
+void Matrix3::rotate( double angle )
+{
+    double fn[6];
+    double fSin = sin(angle);
+    double fCos = cos(angle);
+    fn[0] = f[0]*fCos - f[1]*fSin;
+    fn[1] = f[0]*fSin + f[1]*fCos;
+    fn[2] = f[2]*fCos - f[3]*fSin;
+    fn[3] = f[2]*fSin + f[3]*fCos;
+    fn[4] = f[4]*fCos - f[5]*fSin;
+    fn[5] = f[4]*fSin + f[5]*fCos;
+    set( fn );
+}
+
+void Matrix3::translate( double tx, double ty )
+{
+    f[4] += tx;
+    f[5] += ty;
+}
+
+void Matrix3::append( PDFWriterImpl::PDFPage& rPage, OStringBuffer& rBuffer, Point* pBack )
+{
+    appendDouble( f[0], rBuffer );
+    rBuffer.append( ' ' );
+    appendDouble( f[1], rBuffer );
+    rBuffer.append( ' ' );
+    appendDouble( f[2], rBuffer );
+    rBuffer.append( ' ' );
+    appendDouble( f[3], rBuffer );    
+    rBuffer.append( ' ' );
+    rPage.appendPoint( Point( (long)f[4], (long)f[5] ), rBuffer, false, pBack );
+}
+
+
 
 PDFWriterImpl::PDFPage::PDFPage( PDFWriterImpl* pWriter, sal_Int32 nPageWidth, sal_Int32 nPageHeight, PDFWriter::Orientation eOrientation )
         :
@@ -277,7 +376,7 @@ void PDFWriterImpl::PDFPage::beginStream
     aLine.append( " 0 obj\r\n<< /Length " );
     aLine.append( m_nStreamLengthObject );
     aLine.append( " 0 R\r\n" );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#if defined ( COMPRESS_PAGES ) && !defined ( DEBUG_DISABLE_PDFCOMPRESSION )
     aLine.append( "   /Filter /FlateDecode\r\n" );
 #endif
     aLine.append( ">>\r\nstream\r\n" );
@@ -288,7 +387,7 @@ void PDFWriterImpl::PDFPage::beginStream
         osl_closeFile( m_pWriter->m_aFile );
         m_pWriter->m_bOpen = false;
     }
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#if defined ( COMPRESS_PAGES ) && !defined ( DEBUG_DISABLE_PDFCOMPRESSION )
     m_pWriter->beginCompression();
 #endif
 }
@@ -329,9 +428,6 @@ bool PDFWriterImpl::PDFPage::emit(sal_In
                   "   /Parent " );
     aLine.append( nParentObject );
     aLine.append( " 0 R\r\n" );
-    aLine.append( "   /Resources " );
-    aLine.append( m_pWriter->m_nResourceDict );
-    aLine.append( " 0 R\r\n" );
     if( m_nPageWidth && m_nPageHeight )
     {
         aLine.append( "   /MediaBox [ 0 0 " );
@@ -428,9 +524,9 @@ void PDFWriterImpl::PDFPage::appendRect(
 {
     appendPoint( rRect.BottomLeft() + Point( 0, 1 ), rBuffer );
     rBuffer.append( ' ' );
-    appendMappedLength( rRect.GetWidth(), rBuffer, false );
+    appendMappedLength( (sal_Int32)rRect.GetWidth(), rBuffer, false );
     rBuffer.append( ' ' );
-    appendMappedLength( rRect.GetHeight(), rBuffer, true );
+    appendMappedLength( (sal_Int32)rRect.GetHeight(), rBuffer, true );
     rBuffer.append( " re" );
 }
 
@@ -545,23 +641,23 @@ void PDFWriterImpl::PDFPage::appendLineI
         rBuffer.append( "[ " );
         for( int n = 0; n < rInfo.GetDashCount(); n++ )
         {
-            appendMappedLength( rInfo.GetDashLen(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDashLen(), rBuffer );
             rBuffer.append( ' ' );
-            appendMappedLength( rInfo.GetDistance(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDistance(), rBuffer );
             rBuffer.append( ' ' );
         }
         for( int m = 0; m < rInfo.GetDotCount(); m++ )
         {
-            appendMappedLength( rInfo.GetDotLen(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDotLen(), rBuffer );
             rBuffer.append( ' ' );
-            appendMappedLength( rInfo.GetDistance(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDistance(), rBuffer );
             rBuffer.append( ' ' );
         }
         rBuffer.append( "] 0 d\r\n" );
     }
     if( rInfo.GetWidth() > 1 )
     {
-        appendMappedLength( rInfo.GetWidth(), rBuffer );
+        appendMappedLength( (sal_Int32)rInfo.GetWidth(), rBuffer );
         rBuffer.append( " w\r\n" );
     }
     else if( rInfo.GetWidth() == 0 )
@@ -620,7 +716,6 @@ PDFWriterImpl::PDFWriterImpl( const OUSt
         m_nInheritedPageHeight( 842 ), // default A4
         m_eInheritedOrientation( PDFWriter::Portrait ),
         m_nCurrentPage( -1 ),
-        m_nResourceDict( -1 ),
         m_eVersion( eVersion ),
         m_eCompression( eCompression ),
         m_aFileName( rFilename ),
@@ -695,7 +790,7 @@ void PDFWriterImpl::emitComment( const O
 
 void PDFWriterImpl::beginCompression()
 {
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     m_pCodec = new ZCodec( 0x4000, 0x4000 );
     m_pMemStream = new SvMemoryStream();
     m_pCodec->BeginCompression();
@@ -704,7 +799,7 @@ void PDFWriterImpl::beginCompression()
 
 void PDFWriterImpl::endCompression()
 {
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     if( m_pCodec )
     {
         m_pCodec->EndCompression();
@@ -753,24 +848,19 @@ OutputDevice* PDFWriterImpl::getReferenc
     if( ! m_pReferenceDevice )
     {
         VirtualDevice*  pVDev = new VirtualDevice( 0 );
-        sal_Int32       nDPI;
 
         m_pReferenceDevice = pVDev;
-        pVDev->SetReferenceDevice();
 
+        VirtualDevice::RefDevMode eMode = VirtualDevice::REFDEV_MODE06;
         switch( m_eCompression )
         {
-            case( PDFWriter::Print ): nDPI = 1200; break;
-            case( PDFWriter::Press ): nDPI = 2400; break;
-
-            default:
-                nDPI = 600;
-            break;
+            case( PDFWriter::Print ): eMode = VirtualDevice::REFDEV_MODE48; break;
+            case( PDFWriter::Press ): eMode = VirtualDevice::REFDEV_MODE96; break;
         }
+        pVDev->SetReferenceDevice( eMode );
 
         pVDev->SetOutputSizePixel( Size( 640, 480 ) );
         pVDev->SetMapMode( MAP_MM );
-        pVDev->mnDPIX = pVDev->mnDPIY = nDPI;
 
         m_pReferenceDevice->mpPDFWriter = this;
         m_pReferenceDevice->ImplUpdateFontData( TRUE );
@@ -781,7 +871,6 @@ OutputDevice* PDFWriterImpl::getReferenc
 ImplDevFontList* PDFWriterImpl::filterDevFontList( ImplDevFontList* pFontList )
 {
     DBG_ASSERT( m_aSubsets.size() == 0, "Fonts changing during PDF generation, document will be invalid" );
-
     ImplDevFontList* pFiltered = new ImplDevFontList();
 
     ImplDevFontListData* pData = pFontList->First();
@@ -1403,7 +1493,7 @@ std::map< sal_Int32, sal_Int32 > PDFWrit
                       "<< /Length " );
         aLine.append( nStreamLengthObject );
         aLine.append( " 0 R\r\n"
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
                       "   /Filter /FlateDecode\r\n"
 #endif
                       "   /Length1 " );
@@ -1764,7 +1854,7 @@ sal_Int32 PDFWriterImpl::createToUnicode
                       "CMapName currentdict /CMap defineresource pop\r\n"
                       "end\r\n"
                       "end\r\n" );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     ZCodec* pCodec = new ZCodec( 0x4000, 0x4000 );
     SvMemoryStream aStream;
     pCodec->BeginCompression();
@@ -1777,7 +1867,7 @@ sal_Int32 PDFWriterImpl::createToUnicode
 
     aLine.append( nStream );
     aLine.append( " 0 obj\r\n<< /Length " );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     sal_Int32 nLen = (sal_Int32)aStream.Tell();
     aStream.Seek( 0 );
     aLine.append( nLen );
@@ -1787,7 +1877,7 @@ sal_Int32 PDFWriterImpl::createToUnicode
 #endif
     aLine.append( " >>\r\nstream\r\n" );
     CHECK_RETURN( writeBuffer( aLine.getStr(), aLine.getLength() ) );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     CHECK_RETURN( writeBuffer( aStream.GetData(), nLen ) );
 #else
     CHECK_RETURN( writeBuffer( aContents.getStr(), aContents.getLength() ) );
@@ -1884,11 +1974,7 @@ sal_Int32 PDFWriterImpl::emitFonts()
     if( ! m_aSubsets.size() && ! m_aEmbeddedFonts.size() ) // no fonts
         return 0;
 
-#ifndef REMOTE_APPSERVER
     if( ! m_pReferenceDevice->ImplGetGraphics() )
-#else
-    if( ! m_pReferenceDevice->ImplGetServerGraphics() )
-#endif
         return 0;
 
     OStringBuffer aLine( 1024 );
@@ -1902,7 +1988,7 @@ sal_Int32 PDFWriterImpl::emitFonts()
     {
         for( FontEmitList::iterator lit = it->second.m_aSubsets.begin(); lit != it->second.m_aSubsets.end(); ++lit )
         {
-            long pGlyphIDs[ 256 ];
+            sal_Int32 pGlyphIDs[ 256 ];
             sal_Int32 pWidths[ 256 ];
             sal_uInt8 pEncoding[ 256 ];
             sal_Unicode pUnicodes[ 256 ];
@@ -1954,7 +2040,7 @@ sal_Int32 PDFWriterImpl::emitFonts()
                               "<< /Length " );
                 aLine.append( (sal_Int32)nStreamLengthObject );
                 aLine.append( " 0 R\r\n"
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
                               "   /Filter /FlateDecode\r\n"
 #endif
                               "   /Length1 " );
@@ -2226,14 +2312,13 @@ bool PDFWriterImpl::emitCatalog()
     // first create a page tree node id
     sal_Int32 nTreeNode = createObject();
 
-    // emit global resource dictionary (page emit needs it)
-    m_nResourceDict = emitResources();
-
     // emit all pages
     for( std::list<PDFPage>::iterator it = m_aPages.begin(); it != m_aPages.end(); ++it )
         if( ! it->emit( nTreeNode ) )
             return false;
 
+    sal_Int32 nResourceDict = emitResources();
+
     // adjust tree node file offset
     if( ! updateObject( nTreeNode ) )
         return false;
@@ -2244,7 +2329,7 @@ bool PDFWriterImpl::emitCatalog()
     aLine.append( " 0 obj\r\n" );
     aLine.append( "<< /Type /Pages\r\n" );
     aLine.append( "   /Resources " );
-    aLine.append( m_nResourceDict );
+    aLine.append( nResourceDict );
     aLine.append( " 0 R\r\n" );
     switch( m_eInheritedOrientation )
     {
@@ -2468,7 +2553,7 @@ bool PDFWriterImpl::emit()
 
 void PDFWriterImpl::registerGlyphs(
                                    int nGlyphs,
-                                   long* pGlyphs,
+                                   sal_Int32* pGlyphs,
                                    sal_Unicode* pUnicodes,
                                    sal_uInt8* pMappedGlyphs,
                                    sal_Int32* pMappedFontObjects,
@@ -2535,10 +2620,8 @@ void PDFWriterImpl::registerGlyphs(
 
             const std::map< sal_Unicode, sal_Int32 >* pEncoding = NULL;
             const std::map< sal_Unicode, rtl::OString >* pNonEncoded = NULL;
-#ifndef REMOTE_APPSERVER
             getReferenceDevice()->ImplGetGraphics();
             pEncoding = m_pReferenceDevice->mpGraphics->GetFontEncodingVector( pCurrentFont, &pNonEncoded );
-#endif
 
             std::map< sal_Unicode, sal_Int32 >::const_iterator enc_it;
             std::map< sal_Unicode, rtl::OString >::const_iterator nonenc_it;
@@ -2608,131 +2691,112 @@ void PDFWriterImpl::registerGlyphs(
     }
 }
 
-void PDFWriterImpl::drawLayout( SalLayout& rLayout, const String& rText, bool bTextLines )
+void PDFWriterImpl::drawRelief( SalLayout& rLayout, const String& rText, bool bTextLines )
 {
-    FontRelief eRelief = m_aCurrentPDFState.m_aFont.GetRelief();
-    // relief takes precedence over shadow (see outdev3.cxx)
-    if(  eRelief != RELIEF_NONE )
-    {
-        push( PUSH_ALL );
+    push( PUSH_ALL );
 
-        Color aTextColor = m_aCurrentPDFState.m_aFont.GetColor();
-        Color aTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
-        Color aReliefColor( COL_LIGHTGRAY );
-        if( aTextColor == COL_BLACK )
-            aTextColor = Color( COL_WHITE );
-        if( aTextLineColor == COL_BLACK )
-            aTextLineColor = Color( COL_WHITE );
-        if( aTextColor == COL_WHITE )
-            aReliefColor = Color( COL_BLACK );
-
-        Font aSetFont = m_aCurrentPDFState.m_aFont;
-        aSetFont.SetRelief( RELIEF_NONE );
-        aSetFont.SetShadow( FALSE );
-
-        aSetFont.SetColor( aReliefColor );
-        setTextLineColor( aTextLineColor );
-        setFont( aSetFont );
-        long nOff = 1 + getReferenceDevice()->mnDPIX/300;
-        if( eRelief == RELIEF_ENGRAVED )
-            nOff = -nOff;
+    FontRelief eRelief = m_aCurrentPDFState.m_aFont.GetRelief();
 
-        rLayout.DrawOffset() += Point( nOff, nOff );
-        updateGraphicsState();
-        drawLayout( rLayout, rText, bTextLines );
+    Color aTextColor = m_aCurrentPDFState.m_aFont.GetColor();
+    Color aTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
+    Color aReliefColor( COL_LIGHTGRAY );
+    if( aTextColor == COL_BLACK )
+        aTextColor = Color( COL_WHITE );
+    if( aTextLineColor == COL_BLACK )
+        aTextLineColor = Color( COL_WHITE );
+    if( aTextColor == COL_WHITE )
+        aReliefColor = Color( COL_BLACK );
+    
+    Font aSetFont = m_aCurrentPDFState.m_aFont;
+    aSetFont.SetRelief( RELIEF_NONE );
+    aSetFont.SetShadow( FALSE );
+    
+    aSetFont.SetColor( aReliefColor );
+    setTextLineColor( aTextLineColor );
+    setFont( aSetFont );
+    long nOff = 1 + getReferenceDevice()->mnDPIX/300;
+    if( eRelief == RELIEF_ENGRAVED )
+        nOff = -nOff;
+    
+    rLayout.DrawOffset() += Point( nOff, nOff );
+    updateGraphicsState();
+    drawLayout( rLayout, rText, bTextLines );
+    
+    rLayout.DrawOffset() -= Point( nOff, nOff );
+    setTextLineColor( aTextLineColor );
+    aSetFont.SetColor( aTextColor );
+    setFont( aSetFont );
+    updateGraphicsState();
+    drawLayout( rLayout, rText, bTextLines );
+    
+    // clean up the mess
+    pop();
+}
 
-        rLayout.DrawOffset() -= Point( nOff, nOff );
-        setTextLineColor( aTextLineColor );
-        aSetFont.SetColor( aTextColor );
-        setFont( aSetFont );
-        updateGraphicsState();
-        drawLayout( rLayout, rText, bTextLines );
+void PDFWriterImpl::drawShadow( SalLayout& rLayout, const String& rText, bool bTextLines )
+{
+    Font aSaveFont = m_aCurrentPDFState.m_aFont;
+    Color aSaveTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
+    
+    Font& rFont = m_aCurrentPDFState.m_aFont;
+    if( rFont.GetColor() == Color( COL_BLACK ) || rFont.GetColor().GetLuminance() < 8 )
+        rFont.SetColor( Color( COL_LIGHTGRAY ) );
+    else
+        rFont.SetColor( Color( COL_BLACK ) );
+    rFont.SetShadow( FALSE );
+    rFont.SetOutline( FALSE );
+    setFont( rFont );
+    setTextLineColor( rFont.GetColor() );
+    updateGraphicsState();
+    
+    long nOff = 1 + ((m_pReferenceDevice->mpFontEntry->mnLineHeight-24)/24);
+    if( rFont.IsOutline() )
+        nOff++;
+    rLayout.DrawBase() += Point( nOff, nOff );
+    drawLayout( rLayout, rText, bTextLines );
+    rLayout.DrawBase() -= Point( nOff, nOff );
+    
+    setFont( aSaveFont );
+    setTextLineColor( aSaveTextLineColor );
+    updateGraphicsState();
+}
 
-        // clean up the mess
-        pop();
+void PDFWriterImpl::drawLayout( SalLayout& rLayout, const String& rText, bool bTextLines )
+{
+    // relief takes precedence over shadow (see outdev3.cxx)
+    if(  m_aCurrentPDFState.m_aFont.GetRelief() != RELIEF_NONE )
+    {
+        drawRelief( rLayout, rText, bTextLines );
         return;
     }
     else if( m_aCurrentPDFState.m_aFont.IsShadow() )
-    {
-        Font aSaveFont = m_aCurrentPDFState.m_aFont;
-        Color aSaveTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
-
-        Font& rFont = m_aCurrentPDFState.m_aFont;
-        if( rFont.GetColor() == Color( COL_BLACK ) || rFont.GetColor().GetLuminance() < 8 )
-            rFont.SetColor( Color( COL_LIGHTGRAY ) );
-        else
-            rFont.SetColor( Color( COL_BLACK ) );
-        rFont.SetShadow( FALSE );
-        setFont( rFont );
-        setTextLineColor( rFont.GetColor() );
-        updateGraphicsState();
-
-        long nOff = 1 + ((m_pReferenceDevice->mpFontEntry->mnLineHeight-24)/24);
-        if( rFont.IsOutline() )
-            nOff++;
-        rLayout.DrawBase() += Point( nOff, nOff );
-        drawLayout( rLayout, rText, bTextLines );
-        rLayout.DrawBase() -= Point( nOff, nOff );
-
-        setFont( aSaveFont );
-        setTextLineColor( aSaveTextLineColor );
-        updateGraphicsState();
-    }
+        drawShadow( rLayout, rText, bTextLines );
 
     OStringBuffer aLine( 512 );
 
-    // setup text colors (if necessary)
-    bool bPop = false;
-    if( m_aCurrentPDFState.m_aFont.IsOutline() &&
-        m_aCurrentPDFState.m_aLineColor != m_aCurrentPDFState.m_aFont.GetColor() )
-    {
-        bPop = true;
-        aLine.append( "q " );
-        appendStrokingColor( m_aCurrentPDFState.m_aFont.GetColor(), aLine );
-        aLine.append( "\r\n" );
-    }
-    else if( m_aCurrentPDFState.m_aFillColor != m_aCurrentPDFState.m_aFont.GetColor() )
-    {
-        bPop = true;
-        aLine.append( "q " );
-        appendNonStrokingColor( m_aCurrentPDFState.m_aFont.GetColor(), aLine );
-        aLine.append( "\r\n" );
-    }
-
-    // begin text object
-    aLine.append( "BT\r\n" );
-    // outline attribute ?
-    if( m_aCurrentPDFState.m_aFont.IsOutline() )
-    {
-        aLine.append( "1 Tr " );
-        double fW = (double)m_aCurrentPDFState.m_aFont.GetHeight() / 30.0;
-        m_aPages.back().appendMappedLength( fW, aLine );
-        aLine.append ( " w\r\n" );
-    }
-
     const int nMaxGlyphs = 256;
 
-    // note: the layout calculates in outdevs device pixel !!
-
-    long pGlyphs[nMaxGlyphs];
+    sal_Int32 pGlyphs[nMaxGlyphs];
     sal_uInt8 pMappedGlyphs[nMaxGlyphs];
     sal_Int32 pMappedFontObjects[nMaxGlyphs];
     sal_Unicode pUnicodes[nMaxGlyphs];
     int pCharPosAry[nMaxGlyphs];
-    long nAdvanceWidths[nMaxGlyphs];
+    sal_Int32 nAdvanceWidths[nMaxGlyphs];
     ImplFontData* pFallbackFonts[nMaxGlyphs];
-    long *pAdvanceWidths = m_aCurrentPDFState.m_aFont.IsVertical() ? nAdvanceWidths : NULL;
-    long nGlyphFlags[nMaxGlyphs];
+    sal_Int32 *pAdvanceWidths = m_aCurrentPDFState.m_aFont.IsVertical() ? nAdvanceWidths : NULL;
+    sal_Int32 nGlyphFlags[nMaxGlyphs];
     int nGlyphs;
     int nIndex = 0;
     Point aPos, aLastPos(0, 0), aCumulativePos(0,0), aGlyphPos;
     bool bFirst = true, bWasYChange = false;
     int nMinCharPos = 0, nMaxCharPos = rText.Len()-1;
     double fXScale = 1.0;
+    double fSkew = 0.0;
     sal_Int32 nFontHeight = m_pReferenceDevice->mpFontEntry->maFontSelData.mnHeight;
     TextAlign eAlign = m_aCurrentPDFState.m_aFont.GetAlign();
 
     // transform font height back to current units
+    // note: the layout calculates in outdevs device pixel !!
     nFontHeight = m_pReferenceDevice->ImplDevicePixelToLogicHeight( nFontHeight );
     if( m_aCurrentPDFState.m_aFont.GetWidth() )
     {
@@ -2748,16 +2812,99 @@ void PDFWriterImpl::drawLayout( SalLayou
         // force state before GetFontMetric
         m_pReferenceDevice->ImplNewFont();
     }
+
+    // perform artificial italics if necessary
+    if( ( m_aCurrentPDFState.m_aFont.GetItalic() == ITALIC_NORMAL ||
+          m_aCurrentPDFState.m_aFont.GetItalic() == ITALIC_OBLIQUE ) &&
+        !( m_pReferenceDevice->mpFontEntry->maFontSelData.mpFontData->meItalic == ITALIC_NORMAL ||
+           m_pReferenceDevice->mpFontEntry->maFontSelData.mpFontData->meItalic == ITALIC_OBLIQUE )
+        )
+    {
+        fSkew = M_PI/12.0;
+    }
+
     // if the mapmode is distorted we need to adjust for that also
     if( m_aCurrentPDFState.m_aMapMode.GetScaleX() != m_aCurrentPDFState.m_aMapMode.GetScaleY() )
     {
         fXScale *= (double)(m_aCurrentPDFState.m_aMapMode.GetScaleX() / m_aCurrentPDFState.m_aMapMode.GetScaleY());
     }
 
-    double fAngle = (double)m_aCurrentPDFState.m_aFont.GetOrientation() * M_PI / 1800.0;
-    double fSin = sin( fAngle );
-    double fCos = cos( fAngle );
+    int nAngle = m_aCurrentPDFState.m_aFont.GetOrientation();
+    // normalize angles
+    while( nAngle < 0 )
+        nAngle += 3600;
+    nAngle = nAngle % 3600;
+    double fAngle = (double)nAngle * M_PI / 1800.0;
+
+    Matrix3 aRotScale;
+    aRotScale.scale( fXScale, 1.0 );
+    if( fAngle != 0.0 )
+        aRotScale.rotate( -fAngle );
     
+    bool bPop = false;
+    bool bABold = false;
+    // artificial bold necessary ?
+    int nBoldness = (int)m_aCurrentPDFState.m_aFont.GetWeight() - (int)m_pReferenceDevice->mpFontEntry->maFontSelData.mpFontData->meWeight;
+    if( nBoldness > 1 )
+    {
+        if( ! bPop )
+            aLine.append( "q " );
+        bPop = true;
+        bABold = true;
+    }
+    // setup text colors (if necessary)
+    Color aStrokeColor( COL_TRANSPARENT );
+    Color aNonStrokeColor( COL_TRANSPARENT );
+
+    if( m_aCurrentPDFState.m_aFont.IsOutline() )
+    {
+        aStrokeColor = m_aCurrentPDFState.m_aFont.GetColor();
+        aNonStrokeColor = Color( COL_WHITE );
+    }
+    else
+        aNonStrokeColor = m_aCurrentPDFState.m_aFont.GetColor();
+    if( bABold )
+        aStrokeColor = m_aCurrentPDFState.m_aFont.GetColor();
+
+    if( aStrokeColor != Color( COL_TRANSPARENT ) && aStrokeColor != m_aCurrentPDFState.m_aLineColor )
+    {
+        if( ! bPop )
+            aLine.append( "q " );
+        bPop = true;
+        appendStrokingColor( aStrokeColor, aLine );
+        aLine.append( "\r\n" );
+    }
+    if( aNonStrokeColor != Color( COL_TRANSPARENT ) && aNonStrokeColor != m_aCurrentPDFState.m_aFillColor )
+    {
+        if( ! bPop )
+            aLine.append( "q " );
+        bPop = true;
+        appendNonStrokingColor( aNonStrokeColor, aLine );
+        aLine.append( "\r\n" );
+    }
+
+    // begin text object
+    aLine.append( "BT\r\n" );
+    // outline attribute ?
+    if( m_aCurrentPDFState.m_aFont.IsOutline() || bABold )
+    {
+        // set correct text mode, set stroke width
+        aLine.append( "2 Tr " ); // fill, then stroke
+
+        if( m_aCurrentPDFState.m_aFont.IsOutline() )
+        {
+            // unclear what to do in case of outline and artificial bold
+            // for the time being outline wins
+            aLine.append( "0.25 w \r\n" );
+        }
+        else
+        {
+            double fW = (double)m_aCurrentPDFState.m_aFont.GetHeight() / 30.0;
+            m_aPages.back().appendMappedLength( fW, aLine );
+            aLine.append ( " w\r\n" );
+        }
+    }
+
     sal_Int32 nLastMappedFont = -1;
     while( (nGlyphs = rLayout.GetNextGlyphs( nMaxGlyphs, pGlyphs, aPos, nIndex, pAdvanceWidths, pCharPosAry )) )
     {
@@ -2774,8 +2921,7 @@ void PDFWriterImpl::drawLayout( SalLayou
 
         if( aDiff.X() || aDiff.Y() )
         {
-            aDiff = Point( (int)(fXScale * fCos * (double)aDiff.X() + fSin * (double)aDiff.Y()),
-                               -(int)(fXScale * fSin * (double)aDiff.X() - fCos * (double)aDiff.Y()) );
+            aDiff = aRotScale.transform( aDiff );
             aPos += aDiff;
         }
 
@@ -2816,6 +2962,8 @@ void PDFWriterImpl::drawLayout( SalLayou
                 double fDeltaAngle = 0.0;
                 double fYScale = 1.0;
                 double fTempXScale = fXScale;
+                double fSkewB = fSkew;
+                double fSkewA = 0.0;
 
                 Point aDeltaPos;
                 if( ( nGlyphFlags[n] & GF_ROTMASK ) == GF_ROTL )
@@ -2825,6 +2973,8 @@ void PDFWriterImpl::drawLayout( SalLayou
                     aDeltaPos.Y() = (int)((double)m_pReferenceDevice->GetFontMetric().GetDescent() * fXScale);
                     fYScale = fXScale;
                     fTempXScale = 1.0;
+                    fSkewA = -fSkewB;
+                    fSkewB = 0.0;
                 }
                 else if( ( nGlyphFlags[n] & GF_ROTMASK ) == GF_ROTR )
                 {
@@ -2833,6 +2983,8 @@ void PDFWriterImpl::drawLayout( SalLayou
                     aDeltaPos.Y() = -m_pReferenceDevice->GetFontMetric().GetAscent();
                     fYScale = fXScale;
                     fTempXScale = 1.0;
+                    fSkewA = fSkewB;
+                    fSkewB = 0.0;
                 }
                 aDeltaPos += (m_pReferenceDevice->PixelToLogic( Point( (int)((double)nXOffset/fXScale)/rLayout.GetUnitsPerPixel(), 0 ) ) - m_pReferenceDevice->PixelToLogic( Point() ) );
                 nXOffset += pAdvanceWidths[n];
@@ -2840,21 +2992,15 @@ void PDFWriterImpl::drawLayout( SalLayou
                     continue;
 
 
-                aDeltaPos = Point( (int)(fXScale * fCos * (double)aDeltaPos.X() + fSin * (double)aDeltaPos.Y()),
-                                   -(int)(fXScale * fSin * (double)aDeltaPos.X() - fCos * (double)aDeltaPos.Y()) );
+                aDeltaPos = aRotScale.transform( aDeltaPos );
 
-                double fDSin = sin( fAngle+fDeltaAngle );
-                double fDCos = cos( fAngle+fDeltaAngle );
-
-                appendDouble( fTempXScale*fDCos, aLine );
-                aLine.append( ' ' );
-                appendDouble( fDSin*fTempXScale, aLine );
-                aLine.append( ' ' );
-                appendDouble( -fDSin*fYScale, aLine );
-                aLine.append( ' ' );
-                appendDouble( fDCos*fYScale, aLine );
-                aLine.append( ' ' );
-                m_aPages.back().appendPoint( aPos+aDeltaPos, aLine );
+                Matrix3 aMat;
+                if( fSkewB != 0.0 || fSkewA != 0.0 )
+                    aMat.skew( fSkewA, fSkewB );
+                aMat.scale( fTempXScale, fYScale );
+                aMat.rotate( fAngle+fDeltaAngle );
+                aMat.translate( aPos.X()+aDeltaPos.X(), aPos.Y()+aDeltaPos.Y() );
+                aMat.append( m_aPages.back(), aLine );
                 aLine.append( " Tm" );
                 if( nLastMappedFont != pMappedFontObjects[n] )
                 {
@@ -2873,7 +3019,7 @@ void PDFWriterImpl::drawLayout( SalLayou
         else // normal case
         {
             // optimize use of Td vs. Tm
-            if( fXScale == 1.0 && fCos == 1.0 && fSin == 0.0 )
+            if( fAngle == 0.0 && fXScale == 1.0 && ( !bFirst || fSkew == 0.0 ) )
             {
                 if( bFirst )
                 {
@@ -2885,12 +3031,12 @@ void PDFWriterImpl::drawLayout( SalLayou
                 {
                     sal_Int32 nDiffL = 0;
                     Point aDiff = aPos - aLastPos;
-                    m_aPages.back().appendMappedLength( aDiff.X(), aLine, false, &nDiffL );
+                    m_aPages.back().appendMappedLength( (sal_Int32)aDiff.X(), aLine, false, &nDiffL );
                     aCumulativePos.X() += nDiffL;
                     aLine.append( ' ' );
                     if( bWasYChange )
                     {
-                        m_aPages.back().appendMappedLength( aDiff.Y(), aLine, true, &nDiffL );
+                        m_aPages.back().appendMappedLength( (sal_Int32)aDiff.Y(), aLine, true, &nDiffL );
                         aCumulativePos.Y() += nDiffL;
                     }
                     else
@@ -2912,17 +3058,16 @@ void PDFWriterImpl::drawLayout( SalLayou
             }
             else
             {
-                appendDouble( fXScale*fCos, aLine );
-                aLine.append( ' ' );
-                appendDouble( fSin*fXScale, aLine );
-                aLine.append( ' ' );
-                appendDouble( -fSin, aLine );
-                aLine.append( ' ' );
-                appendDouble( fCos, aLine );
-                aLine.append( ' ' );
-                m_aPages.back().appendPoint( aPos, aLine, false, &aCumulativePos );
+                Matrix3 aMat;
+                if( fSkew != 0.0 )
+                    aMat.skew( 0.0, fSkew );
+                aMat.scale( fXScale, 1.0 );
+                aMat.rotate( fAngle );
+                aMat.translate( aPos.X(), aPos.Y() );
+                aMat.append( m_aPages.back(), aLine, &aCumulativePos );
                 aLine.append( " Tm\r\n" );
                 aLastPos = aPos;
+                bFirst = false;
             }
             int nLast = 0;
             while( nLast < nGlyphs )
@@ -2979,10 +3124,10 @@ void PDFWriterImpl::drawLayout( SalLayou
         if( m_aCurrentPDFState.m_aFont.IsWordLineMode() )
         {
             Point aPos, aStartPt;
-            long nWidth = 0, nAdvance=0;
+            sal_Int32 nWidth = 0, nAdvance=0;
             for( int nStart = 0;;)
             {
-                long nGlyphIndex;
+                sal_Int32 nGlyphIndex;
                 if( !rLayout.GetNextGlyphs( 1, &nGlyphIndex, aPos, nStart, &nAdvance ) )
                     break;
 
@@ -3081,7 +3226,7 @@ void PDFWriterImpl::drawLayout( SalLayou
         for( int nStart = 0;;)
         {
             Point aPos;
-            long nGlyphIndex, nAdvance;
+            sal_Int32 nGlyphIndex, nAdvance;
             if( !rLayout.GetNextGlyphs( 1, &nGlyphIndex, aPos, nStart, &nAdvance ) )
                 break;
 
@@ -3089,8 +3234,7 @@ void PDFWriterImpl::drawLayout( SalLayou
             {
                 Point aAdjOffset = aOffset;
                 aAdjOffset.X() += (nAdvance - nEmphWidth) / 2;
-                aAdjOffset = Point( (int)(fXScale * fCos * (double)aAdjOffset.X() + fSin * (double)aAdjOffset.Y()),
-                                 -(int)(fXScale * fSin * (double)aAdjOffset.X() - fCos * (double)aAdjOffset.Y()) );
+                aAdjOffset = aRotScale.transform( aAdjOffset );
 
                 aAdjOffset -= Point( nEmphWidth2, nEmphHeight2 );
 
@@ -3113,7 +3257,7 @@ void PDFWriterImpl::drawEmphasisMark( lo
                                       const Rectangle& rRect1, const Rectangle& rRect2 )
 {
     // TODO: pass nWidth as width of this mark
-    long nWidth = 0;
+    // long nWidth = 0;
 
     if ( rPolyPoly.Count() )
     {
@@ -3163,7 +3307,7 @@ void PDFWriterImpl::drawText( const Poin
     }
 }
 
-void PDFWriterImpl::drawTextArray( const Point& rPos, const String& rText, const long* pDXArray, xub_StrLen nIndex, xub_StrLen nLen, bool bTextLines )
+void PDFWriterImpl::drawTextArray( const Point& rPos, const String& rText, const sal_Int32* pDXArray, xub_StrLen nIndex, xub_StrLen nLen, bool bTextLines )
 {
     MARK( "drawText with array" );
 
@@ -3219,7 +3363,6 @@ void PDFWriterImpl::drawText( const Rect
     Point       aPos            = rRect.TopLeft();
 
     long		nTextHeight		= m_pReferenceDevice->GetTextHeight();
-    TextAlign   eAlign			= m_aCurrentPDFState.m_aFont.GetAlign();
     xub_StrLen  nMnemonicPos    = STRING_NOTFOUND;
 
     String aStr = rOrigStr;
@@ -3346,7 +3489,7 @@ void PDFWriterImpl::drawLine( const Poin
 
     OStringBuffer aLine;
     m_aPages.back().appendPoint( rStart, aLine );
-    aLine.append( " m " );
+    aLine.append( "m " );
     m_aPages.back().appendPoint( rStop, aLine );
     aLine.append( " l S\r\n" );
 
@@ -3454,7 +3597,13 @@ void PDFWriterImpl::drawTextLine( const 
             setFont( aFont );
             updateGraphicsState();
         }
+
+        // strikeout string is left aligned non-CTL text
+        ULONG nOrigTLM = m_pReferenceDevice->GetLayoutMode();
+        m_pReferenceDevice->SetLayoutMode( TEXT_LAYOUT_BIDI_STRONG|TEXT_LAYOUT_COMPLEX_DISABLED );
         drawText( rPos, aStrikeout, 0, aStrikeout.Len(), false );
+        m_pReferenceDevice->SetLayoutMode( nOrigTLM );
+
         if( bShadow )
         {
             Font aFont = m_aCurrentPDFState.m_aFont;
@@ -3471,7 +3620,14 @@ void PDFWriterImpl::drawTextLine( const 
             case UNDERLINE_WAVE:
             case UNDERLINE_DOUBLEWAVE:
             case UNDERLINE_BOLDWAVE:
-                bNormalLines = false;
+            {
+                bNormalLines = FALSE;
+            }
+            break;
+            default:
+            {
+                ; // No gcc warning
+            }
         }
     }
 
@@ -3488,17 +3644,10 @@ void PDFWriterImpl::drawTextLine( const 
 
     // rotate and translate matrix
     double fAngle = (double)m_aCurrentPDFState.m_aFont.GetOrientation() * M_PI / 1800.0;
-    double fSin = sin( fAngle );
-    double fCos = cos( fAngle );
-    appendDouble( fCos, aLine );
-    aLine.append( ' ' );
-    appendDouble( fSin, aLine );
-    aLine.append( ' ' );
-    appendDouble( -fSin, aLine );
-    aLine.append( ' ' );
-    appendDouble( fCos, aLine );
-    aLine.append( ' ' );
-    m_aPages.back().appendPoint( aPos, aLine );
+    Matrix3 aMat;
+    aMat.rotate( fAngle );
+    aMat.translate( aPos.X(), aPos.Y() );
+    aMat.append( m_aPages.back(), aLine );
     aLine.append( " cm\r\n" );
 
     if ( aUnderlineColor.GetTransparency() != 0 )
@@ -3536,7 +3685,7 @@ void PDFWriterImpl::drawTextLine( const 
         if ( eUnderline == UNDERLINE_BOLDWAVE )
             nLineWidth = 3*nLineWidth/2;
 
-        m_aPages.back().appendMappedLength( nLineWidth, aLine );
+        m_aPages.back().appendMappedLength( (sal_Int32)nLineWidth, aLine );
         aLine.append( " w " );
 
         if ( eUnderline == UNDERLINE_DOUBLEWAVE )
@@ -3651,7 +3800,7 @@ void PDFWriterImpl::drawTextLine( const 
 
         if ( nLineHeight )
         {
-            m_aPages.back().appendMappedLength( nLineHeight, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, true );
             aLine.append( " w " );
             appendStrokingColor( aUnderlineColor, aLine );
             aLine.append( "\r\n" );
@@ -3660,7 +3809,7 @@ void PDFWriterImpl::drawTextLine( const 
                  (eUnderline == UNDERLINE_BOLDDOTTED) )
             {
                 aLine.append( "[ " );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( " ] 0 d\r\n" );
             }
             else if ( (eUnderline == UNDERLINE_DASH) ||
@@ -3670,12 +3819,8 @@ void PDFWriterImpl::drawTextLine( const 
             {
                 sal_Int32 nDashLength = 4*nLineHeight;
                 sal_Int32 nVoidLength = 2*nLineHeight;
-                switch( eUnderline )
-                {
-                    case UNDERLINE_LONGDASH:
-                    case UNDERLINE_BOLDLONGDASH:
-                        nDashLength = 8*nLineHeight;
-                }
+                if ( ( eUnderline == UNDERLINE_LONGDASH ) || ( eUnderline == UNDERLINE_BOLDLONGDASH ) )
+                    nDashLength = 8*nLineHeight;
 
                 aLine.append( "[ " );
                 m_aPages.back().appendMappedLength( nDashLength, aLine, false );
@@ -3693,7 +3838,7 @@ void PDFWriterImpl::drawTextLine( const 
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( " ] 0 d\r\n" );
@@ -3709,31 +3854,31 @@ void PDFWriterImpl::drawTextLine( const 
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( " ] 0 d\r\n" );
             }
 
             aLine.append( "0 " );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " m " );
-            m_aPages.back().appendMappedLength( nWidth, aLine, false );
+            m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, false );
             aLine.append( ' ' );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " l S\r\n" );
             if ( eUnderline == UNDERLINE_DOUBLE )
             {
                 aLine.append( "0 " );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " m " );
-                m_aPages.back().appendMappedLength( nWidth, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " l S\r\n" );
             }
         }
@@ -3769,27 +3914,27 @@ void PDFWriterImpl::drawTextLine( const 
 
         if ( nLineHeight )
         {
-            m_aPages.back().appendMappedLength( nLineHeight, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, true );
             aLine.append( " w " );
             appendStrokingColor( aStrikeoutColor, aLine );
             aLine.append( "\r\n" );
 
             aLine.append( "0 " );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " m " );
-            m_aPages.back().appendMappedLength( nWidth, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, true );
             aLine.append( ' ' );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " l S\r\n" );
 
             if ( eStrikeout == STRIKEOUT_DOUBLE )
             {
                 aLine.append( "0 " );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " m " );
-                m_aPages.back().appendMappedLength( nWidth, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, true );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " l S\r\n" );
 
             }
@@ -4366,7 +4511,7 @@ bool PDFWriterImpl::writeGradientFunctio
                   "   /Length " );
     aLine.append( nStreamLengthObject );
     aLine.append( " 0 R\r\n"
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
                   "   /Filter /FlateDecode\r\n"
 #endif
                   ">>\r\n"
@@ -4587,7 +4732,7 @@ bool PDFWriterImpl::writeBitmapObject( B
                   "   /Length " );
     aLine.append( nStreamLengthObject );
     aLine.append( " 0 R\r\n" );
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     aLine.append( "   /Filter /FlateDecode\r\n" );
 #endif
     if( ! bMask )
@@ -4768,9 +4913,9 @@ void PDFWriterImpl::drawJPGBitmap( SvStr
         delete pStream;
 
     aLine.append( "q " );
-    m_aPages.back().appendMappedLength( rTargetArea.GetWidth(), aLine, false );
+    m_aPages.back().appendMappedLength( (sal_Int32)rTargetArea.GetWidth(), aLine, false );
     aLine.append( " 0 0 " );
-    m_aPages.back().appendMappedLength( rTargetArea.GetHeight(), aLine, true );
+    m_aPages.back().appendMappedLength( (sal_Int32)rTargetArea.GetHeight(), aLine, true );
     aLine.append( ' ' );
     m_aPages.back().appendPoint( rTargetArea.BottomLeft(), aLine );
     aLine.append( " cm\r\n  /Im" );
@@ -4790,9 +4935,9 @@ void PDFWriterImpl::drawBitmap( const Po
         appendNonStrokingColor( rFillColor, aLine );
         aLine.append( ' ' );
     }
-    m_aPages.back().appendMappedLength( rDestSize.Width(), aLine, false );
+    m_aPages.back().appendMappedLength( (sal_Int32)rDestSize.Width(), aLine, false );
     aLine.append( " 0 0 " );
-    m_aPages.back().appendMappedLength( rDestSize.Height(), aLine, true );
+    m_aPages.back().appendMappedLength( (sal_Int32)rDestSize.Height(), aLine, true );
     aLine.append( ' ' );
     m_aPages.back().appendPoint( rDestPoint + Point( 0, rDestSize.Height()-1 ), aLine );
     aLine.append( " cm\r\n  /Im" );
@@ -4910,9 +5055,9 @@ void PDFWriterImpl::drawGradient( const 
     if( m_aGraphicsStack.front().m_aLineColor != Color( COL_TRANSPARENT ) )
         aLine.append( "q " );
     aLine.append( "0 0 " );
-    m_aPages.back().appendMappedLength( rRect.GetWidth(), aLine, false );
+    m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetWidth(), aLine, false );
     aLine.append( ' ' );
-    m_aPages.back().appendMappedLength( rRect.GetHeight(), aLine, true );
+    m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetHeight(), aLine, true );
     aLine.append( " re W n\r\n" );
 
     aLine.append( "/P" );
@@ -4921,9 +5066,9 @@ void PDFWriterImpl::drawGradient( const 
     if( m_aGraphicsStack.front().m_aLineColor != Color( COL_TRANSPARENT ) )
     {
         aLine.append( "Q 0 0 " );
-        m_aPages.back().appendMappedLength( rRect.GetWidth(), aLine, false );
+        m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetWidth(), aLine, false );
         aLine.append( ' ' );
-        m_aPages.back().appendMappedLength( rRect.GetHeight(), aLine, true );
+        m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetHeight(), aLine, true );
         aLine.append( " re S " );
     }
     aLine.append( "Q\r\n" );
@@ -4977,17 +5122,16 @@ void PDFWriterImpl::drawHatch( const Pol
     if( m_aGraphicsStack.front().m_aLineColor == Color( COL_TRANSPARENT ) &&
         m_aGraphicsStack.front().m_aFillColor == Color( COL_TRANSPARENT ) )
         return;
-
-    if( rPolyPoly.Count() )
-    {
-        PolyPolygon             aPolyPoly( rPolyPoly );
-        
-        aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
-        push( PUSH_LINECOLOR );
-        setLineColor( rHatch.GetColor() );
-        getReferenceDevice()->ImplDrawHatch( aPolyPoly, rHatch, FALSE );
-        pop();
-    }
+	if( rPolyPoly.Count() )
+	{ 
+		PolyPolygon		aPolyPoly( rPolyPoly );
+
+		aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
+		push( PUSH_LINECOLOR );
+		setLineColor( rHatch.GetColor() );
+		getReferenceDevice()->ImplDrawHatch( aPolyPoly, rHatch, FALSE );
+		pop();
+	}
 }
 
 void PDFWriterImpl::drawWallpaper( const Rectangle& rRect, const Wallpaper& rWall )
@@ -5056,6 +5200,7 @@ void PDFWriterImpl::drawWallpaper( const
                         aBmpPos.X() += aRect.GetWidth()-aBmpSize.Width();
                         aBmpPos.Y() += aRect.GetHeight()-aBmpSize.Height();
                         break;
+                    default: ;
                 }
             }
             else
Index: vcl/source/gdi/pdfwriter_impl.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pdfwriter_impl.hxx,v
retrieving revision 1.25.82.2
retrieving revision 1.28
diff -u -p -u -r1.25.82.2 -r1.28
--- vcl/source/gdi/pdfwriter_impl.hxx	26 Jan 2004 17:22:37 -0000	1.25.82.2
+++ vcl/source/gdi/pdfwriter_impl.hxx	17 Jun 2004 12:19:44 -0000	1.28
@@ -339,7 +339,6 @@ private:
     sal_Int32						m_nCurrentPage;
 
     sal_Int32						m_nCatalogObject;
-    sal_Int32						m_nResourceDict;
 
     PDFWriter::PDFVersion			m_eVersion;
     PDFWriter::Compression          m_eCompression;
@@ -406,11 +405,13 @@ private:
     SvMemoryStream*						m_pMemStream;
 
     /* creates fonts and subsets that will be emitted later */
-    void registerGlyphs( int nGlyphs, long* pGlyphs, sal_Unicode* pUnicodes, sal_uInt8* pMappedGlyphs, sal_Int32* pMappedFontObjects, ImplFontData* pFallbackFonts[] );
+    void registerGlyphs( int nGlyphs, sal_Int32* pGlyphs, sal_Unicode* pUnicodes, sal_uInt8* pMappedGlyphs, sal_Int32* pMappedFontObjects, ImplFontData* pFallbackFonts[] );
 
     /*  emits a text object according to the passed layout */
     /* TODO: remove rText as soon as SalLayout will change so that rText is not necessary anymore */
     void drawLayout( SalLayout& rLayout, const String& rText, bool bTextLines );
+    void drawRelief( SalLayout& rLayout, const String& rText, bool bTextLines );
+    void drawShadow( SalLayout& rLayout, const String& rText, bool bTextLines );
 
     /*  writes differences between graphics stack and current real PDF
      *   state to the file
@@ -569,7 +570,7 @@ public:
 
     /* actual drawing functions */
     void drawText( const Point& rPos, const String& rText, xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN, bool bTextLines = true );
-    void drawTextArray( const Point& rPos, const String& rText, const long* pDXArray = NULL, xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN, bool bTextLines = true );
+    void drawTextArray( const Point& rPos, const String& rText, const sal_Int32* pDXArray = NULL, xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN, bool bTextLines = true );
     void drawStretchText( const Point& rPos, ULONG nWidth, const String& rText,
                           xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN,
                           bool bTextLines = true  );
Index: vcl/source/gdi/pngread.cxx
===================================================================
RCS file: vcl/source/gdi/pngread.cxx
diff -N vcl/source/gdi/pngread.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/gdi/pngread.cxx	28 Jun 2004 16:23:30 -0000	1.6
@@ -0,0 +1,1499 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "pngread.hxx"
+
+#include <cmath>
+#include <rtl/crc.h>
+#include <rtl/memory.h>
+#include <rtl/alloc.h>
+#include <tools/zcodec.hxx>
+#include <tools/stream.hxx>
+#include "bmpacc.hxx"
+#include "svapp.hxx"
+#include "alpha.hxx"
+
+#ifndef _OSL_ENDIAN_H_
+#include <osl/endian.h>
+#endif
+
+// -----------
+// - Defines -
+// -----------
+
+#define PNGCHUNK_IHDR 		0x49484452
+#define PNGCHUNK_PLTE 		0x504c5445
+#define PNGCHUNK_IDAT 		0x49444154
+#define PNGCHUNK_IEND 		0x49454e44
+#define PNGCHUNK_bKGD 		0x624b4744
+#define PNGCHUNK_cHRM		0x6348524d
+#define PNGCHUNK_gAMA 		0x67414d41
+#define PNGCHUNK_hIST 		0x68495354
+#define PNGCHUNK_pHYs 		0x70485973
+#define PNGCHUNK_sBIT 		0x73425420
+#define PNGCHUNK_tIME		0x74494d45
+#define PNGCHUNK_tEXt		0x74455874
+#define PNGCHUNK_tRNS 		0x74524e53
+#define PNGCHUNK_zTXt 		0x7a545874
+#define PMGCHUNG_msOG		0x6d734f47		// Microsoft Office Animated GIF
+
+#define PNG_TRANS_VAL		0x1
+
+#define VIEWING_GAMMA		2.5
+#define DISPLAY_GAMMA		1.25
+
+namespace vcl
+{
+// -----------
+// - statics -
+// -----------
+
+static const BYTE aBlockHeight[ 8 ] = 
+{
+	0, 8, 8, 4, 4, 2, 2, 1 
+};
+
+// ------------------------------------------------------------------------------
+
+static const BYTE aBlockWidth[ 8 ]  = 
+{
+	0, 8, 4, 4, 2, 2, 1, 1 
+};
+
+// ------------------------------------------------------------------------------
+
+static const BYTE mpDefaultColorTable[ 256 ] =
+{	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
+	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
+	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
+	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
+	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
+};
+
+/* ------------------------------------------------------------------------
+   SJ: InitChunkSeq reads all PNG chunks. The rStm stream position will be at
+   the end of the file afterwards.
+*/ 
+const sal_Bool InitChunkSeq( SvStream& rStm, std::vector< vcl::PNGReader::ChunkData >& rChunkSeq )
+{
+	sal_Bool	bRet = sal_True;
+	sal_uInt16	nIStmOldMode = rStm.GetNumberFormatInt();
+	rStm.SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+
+	sal_uInt32 nDummy[ 2 ];
+	rStm >> nDummy[0] >> nDummy[1];
+	if( ! ( nDummy[0] == 0x89504e47 ) && ( nDummy[1] == 0x0d0a1a0a ) )
+		bRet = sal_False;
+	else
+	{
+		sal_uInt32 nChunkLen, nCRC32, nCheck, nType = 0;
+		while( !rStm.IsEof() && ( rStm.GetError() == ERRCODE_NONE ) )
+		{
+			rChunkSeq.resize( rChunkSeq.size() + 1 );
+			vcl::PNGReader::ChunkData& rChunkData = rChunkSeq.back();		
+			rStm >> nChunkLen
+				 >> nType;
+			
+			rChunkData.nType = nType;
+			#if defined(__LITTLEENDIAN) || defined(OSL_LITENDIAN)
+				nType = SWAPLONG( nType );
+			#endif
+			nCRC32 = rtl_crc32( 0, &nType, 4 );
+			if ( nChunkLen && !rStm.IsEof() )
+			{
+				rChunkData.aData.resize( nChunkLen );
+				sal_uInt8* pPtr = &rChunkData.aData[ 0 ];
+				rStm.Read( pPtr, nChunkLen );
+				nCRC32 = rtl_crc32( nCRC32, pPtr, nChunkLen );
+			}
+			rStm >> nCheck;
+			if ( nCRC32 != nCheck )
+			{
+				bRet = sal_False;
+				break;
+			}
+			if ( rChunkData.nType == PNGCHUNK_IEND )
+				break;
+		}
+		if ( !rChunkSeq.size() || ( rChunkSeq[ 0 ].nType != PNGCHUNK_IHDR ) )
+			bRet = sal_False;
+	}
+	rStm.SetNumberFormatInt( nIStmOldMode );
+	return bRet;
+}
+
+// -------------
+// - PNGReaderImpl -
+// -------------
+
+class PNGReaderImpl
+{
+	friend class vcl::PNGReader;
+
+	std::vector< vcl::PNGReader::ChunkData >	maChunkSeq;
+	std::vector< sal_uInt8 >::iterator			maDataIter;
+	std::vector< sal_uInt8 >::iterator			maDataEnd;
+	sal_Int32									mnChunkLen;
+
+	Bitmap*				mpBmp;
+	BitmapWriteAccess*	mpAcc;
+	Bitmap*				mpMaskBmp;
+	AlphaMask*			mpAlphaMask;
+	BitmapWriteAccess*	mpMaskAcc;
+	ZCodec* 			mpZCodec;
+	BYTE*				mpInflateInBuf; // as big as the size of a scanline + alphachannel + 1
+	BYTE*				mpScanprior;	// pointer to the latest scanline
+	BYTE*				mpTransTab;		//
+	BYTE*				mpScan;			// pointer in the current scanline
+	BYTE*				mpColorTable;	//
+	sal_uInt32			mnChunkType;	// Chunk which is currently open
+	sal_uInt32			mnWidth;
+	sal_uInt32			mnHeight;
+	sal_uInt32			mnBBP;			// number of bytes per pixel
+	sal_uInt32			mnScansize;		// max size of scanline
+	sal_uInt32			mnPrefWidth;	// preferred width in meter
+	sal_uInt32			mnPrefHeight;	// preferred Height in meter
+	sal_uInt32			mnYpos;			// latest y position;
+	USHORT				mnIStmOldMode;
+	USHORT				mnDepth;		// pixel depth
+	BYTE				mnTransRed;
+	BYTE				mnTransGreen;
+	BYTE				mnTransBlue;
+	BYTE				mnBitDepth;		// sample depth
+	BYTE				mnColorType;
+	BYTE				mnCompressionType;
+	BYTE				mnFilterType;
+	BYTE				mnInterlaceType;
+	BYTE				mnPass;			// if interlaced the latest pass ( 1..7 ) else 7
+	BYTE				cTransIndex1;
+	BYTE				cNonTransIndex1;
+	BOOL				mbStatus;
+	BOOL				mbTransparent;	// graphic includes an tRNS Chunk or an alpha Channel
+	BOOL				mbAlphaChannel;
+	BOOL				mbRGBTriple;
+	BOOL				mbPalette;		// FALSE if we need a Palette
+	BOOL				mbGrayScale;
+	BOOL				mbzCodecInUse;
+	BOOL				mbIDAT;			// TRUE if finished with the complete IDAT...
+	BOOL				mbGamma;		// TRUE if Gamma Correction available
+	BOOL				mbpHYs;			// TRUE if pysical size of pixel available
+
+	void				ImplSetPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor &, BOOL bTrans );
+	void				ImplSetPixel( sal_uInt32 y, sal_uInt32 x, BYTE nPalIndex, BOOL bTrans );
+	void				ImplSetAlphaPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor&, BYTE nAlpha );
+	void				ImplReadIDAT();
+	void				ImplResizeScanline();
+	void				ImplGetFilter( sal_uInt32 nXStart=0, sal_uInt32 nXAdd=1 );
+	void				ImplReadTransparent();
+	void				ImplGetGamma();
+	void				ImplGetBackground();
+	BYTE				ImplScaleColor();
+	BOOL				ImplReadHeader();
+	BOOL				ImplReadPalette();
+	void				ImplGetGrayPalette( sal_uInt32 );
+	sal_uInt32			ImplReadsal_uInt32();
+
+public:
+
+									PNGReaderImpl( SvStream& rStm );
+									~PNGReaderImpl();
+
+	BitmapEx						Read();	
+};
+
+// ------------------------------------------------------------------------------
+
+PNGReaderImpl::PNGReaderImpl( SvStream& rPNG ) :
+	mpAcc			( NULL ),
+	mpMaskAcc		( NULL ),
+	mpInflateInBuf	( NULL ),
+	mpScanprior 	( NULL ),
+	mpTransTab		( NULL ),
+	mpBmp			( NULL ),
+	mpMaskBmp		( NULL ),
+	mpAlphaMask		( NULL ),
+	mbGamma			( sal_False ),
+	mbzCodecInUse	( sal_False ),
+	mbpHYs			( sal_False ),
+	mpColorTable	( (sal_uInt8*) mpDefaultColorTable ),
+	mpZCodec		( new ZCodec( DEFAULT_IN_BUFSIZE, DEFAULT_OUT_BUFSIZE, MAX_MEM_USAGE ) )
+{
+	mbStatus = InitChunkSeq( rPNG, maChunkSeq );
+}
+
+// ------------------------------------------------------------------------
+
+PNGReaderImpl::~PNGReaderImpl()
+{
+	if ( mbzCodecInUse )
+		mpZCodec->EndCompression();
+
+	if( mpColorTable != mpDefaultColorTable )
+		delete[] mpColorTable;
+
+	rtl_freeMemory( mpScanprior );
+
+	delete mpBmp;
+	delete mpAlphaMask;
+	delete mpMaskBmp;
+	delete[] mpTransTab;
+	delete[] mpInflateInBuf;
+	delete mpZCodec;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx PNGReaderImpl::Read()
+{
+	BitmapEx	aRet;
+
+	std::vector< vcl::PNGReader::ChunkData >::iterator aIter( maChunkSeq.begin() );
+	std::vector< vcl::PNGReader::ChunkData >::iterator aEnd ( maChunkSeq.end() );
+
+	while( mbStatus && ( aIter != aEnd ) && ( aIter->nType != PNGCHUNK_IEND ) )
+	{
+		maDataIter = aIter->aData.begin();
+		maDataEnd  = aIter->aData.end();
+		mnChunkLen = aIter->aData.size();
+
+		switch ( aIter->nType )
+		{
+			case PNGCHUNK_IHDR :
+			{
+				mbStatus = ImplReadHeader();
+			}
+			break;
+
+			case PNGCHUNK_gAMA :								// the gamma chunk must precede
+			{
+				if ( mbIDAT == FALSE )							// the 'IDAT' and also the
+					ImplGetGamma(); 							// 'PLTE'(if available )
+			}
+			break;
+
+			case PNGCHUNK_PLTE :
+			{
+				if ( !mbPalette )
+					mbStatus = ImplReadPalette();
+			}
+			break;
+
+			case PNGCHUNK_tRNS :
+				ImplReadTransparent();
+			break;
+
+			case PNGCHUNK_bKGD :								// the background chunk must appear
+			{
+				if ( ( mbIDAT == FALSE ) && mbPalette ) 		// before the 'IDAT' and after the
+					ImplGetBackground();						// PLTE(if available ) chunk.
+			}
+			break;
+
+			case PNGCHUNK_IDAT :
+			{
+				if ( !mbIDAT )		// the gfx is finished, but there may be left a zlibCRC of about 4Bytes
+					ImplReadIDAT();
+			}
+			break;
+
+			case PNGCHUNK_pHYs :
+			{
+				if ( !mbIDAT && mnChunkLen == 9 )
+				{
+					mnPrefWidth = ImplReadsal_uInt32();
+					mnPrefHeight= ImplReadsal_uInt32();
+
+					sal_uInt8 nUnitSpecifier = *maDataIter++;
+
+					if ( nUnitSpecifier == 1 )
+						mbpHYs = sal_True;
+				}
+			}
+			break;
+		}
+		aIter++;
+	}
+	if ( mpAcc )
+		mpBmp->ReleaseAccess( mpAcc ), mpAcc = NULL;
+
+	if ( mpMaskAcc )
+	{
+		if ( mbAlphaChannel )
+			mpAlphaMask->ReleaseAccess( mpMaskAcc );
+		else
+			mpMaskBmp->ReleaseAccess( mpMaskAcc );
+
+		mpMaskAcc = NULL;
+	}
+	
+	if ( mbStatus )
+	{
+		if ( mbAlphaChannel )
+			aRet = BitmapEx( *mpBmp, *mpAlphaMask );
+		else if ( mbTransparent )
+			aRet = BitmapEx( *mpBmp, *mpMaskBmp );
+		else
+			aRet = *mpBmp;
+
+		if ( mbpHYs && mnPrefWidth && mnPrefHeight )
+		{
+			sal_Int32 nPrefSizeX = (sal_Int32)( 100000.0 * ( (double)mnWidth / mnPrefWidth ) );
+			sal_Int32 nPrefSizeY = (sal_Int32)( 100000.0 * ( (double)mnHeight / mnPrefHeight ) );
+			
+			aRet.SetPrefMapMode( MAP_100TH_MM );
+			aRet.SetPrefSize( Size( nPrefSizeX, nPrefSizeY ) );
+		}
+	}
+	if( !mbStatus )
+		aRet.Clear();
+
+	return aRet;
+}
+
+// ------------------------------------------------------------------------
+
+BOOL PNGReaderImpl::ImplReadHeader()
+{
+	mnWidth = ImplReadsal_uInt32();
+	mnHeight = ImplReadsal_uInt32();
+	
+	if ( ( mnWidth == 0 ) || ( mnHeight == 0 ) )
+		return FALSE;
+	
+	mnBitDepth = *maDataIter++;
+	mnColorType = *maDataIter++;
+	
+	if ( mnCompressionType = *maDataIter++ )
+		return FALSE;
+	
+	if ( mnFilterType = *maDataIter++ )
+		return FALSE;
+	
+	switch ( mnInterlaceType = *maDataIter++ )	// filter type valid ?
+	{
+		case 0 :
+			mnPass = 7;
+			break;
+		case 1 :
+			mnPass = 0;
+			break;
+		default:
+			return FALSE;
+	}
+	mnYpos = 0;
+	mbPalette = TRUE;
+	mbIDAT = mbAlphaChannel = mbTransparent = FALSE;
+	mbGrayScale = mbRGBTriple = FALSE;
+	mnDepth = mnBitDepth;
+	mnScansize = ( ( mnWidth * mnBitDepth ) + 7 ) >> 3;
+
+	// valid color types are 0,2,3,4 & 6
+	switch ( mnColorType )
+	{
+		case 0 :	// each pixel is a grayscale
+		{
+			switch ( mnBitDepth )
+			{
+				case 2 :
+					mnDepth = 8;	// we have to expand the bitmap
+				case 16 :
+					mnDepth >>= 1;	// we have to reduce the bitmap
+				case 1 :
+				case 4 :
+				case 8 :
+					mbGrayScale = TRUE;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 2 :	// each pixel is an RGB triple
+		{
+			mbRGBTriple = TRUE;
+			mnScansize*=3;
+			switch ( mnBitDepth )
+			{
+				case 16 :			// we have to reduce the bitmap
+				case 8 :
+					mnDepth = 24;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 3 :	// each pixel is a palette index
+		{
+			switch ( mnBitDepth )
+			{
+				case 2 :
+					mnDepth = 4;	// we have to expand the bitmap
+				case 1 :
+				case 4 :
+				case 8 :
+					mbPalette = FALSE;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 4 :	// each pixel is a grayscale sample followed by an alpha sample
+		{
+			mnScansize <<= 1;
+			mbAlphaChannel = TRUE;
+			switch ( mnBitDepth )
+			{
+				case 16 :
+					mnDepth >>= 1;	// we have to reduce the bitmap
+				case 8 :
+					mbGrayScale = TRUE;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 6 :	// each pixel is an RGB triple followed by an alpha sample
+		{
+			mbRGBTriple = TRUE;
+			mnScansize*=4;
+			mbAlphaChannel = TRUE;
+			switch (mnBitDepth )
+			{
+				case 16 :			// we have to reduce the bitmap
+				case 8 :
+					mnDepth = 24;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		default :
+			return FALSE;
+	}
+	mnBBP = mnScansize / mnWidth;
+	
+	if ( !mnBBP )
+		mnBBP = 1;
+
+	mnScansize++;		// each scanline includes one filterbyte
+	mpScan = mpInflateInBuf = new BYTE[ mnScansize ];
+	mpScanprior = (sal_uInt8*)rtl_allocateZeroMemory( mnScansize );
+
+	if ( mnInterlaceType )
+		ImplResizeScanline();
+
+	mpBmp = new Bitmap( Size( mnWidth, mnHeight ), mnDepth);
+	mpAcc = mpBmp->AcquireWriteAccess();
+
+	if ( mbAlphaChannel )
+	{
+		mpAlphaMask = new AlphaMask( Size( mnWidth, mnHeight ) );
+		mpAlphaMask->Erase( 128 );
+		mpMaskAcc = mpAlphaMask->AcquireWriteAccess();
+	}
+	else
+	{
+		mpMaskBmp = new Bitmap( Size( mnWidth, mnHeight ), 1 );
+		mpMaskBmp->Erase( Color( COL_WHITE ) );
+		mpMaskAcc = mpMaskBmp->AcquireWriteAccess();
+	}
+
+	if ( ( mpAcc == NULL ) || ( mpMaskAcc == NULL ) )
+		return FALSE;
+
+	const Color aWhite( COL_WHITE );
+	cTransIndex1 = (BYTE)mpMaskAcc->GetBestPaletteIndex( aWhite );
+	cNonTransIndex1 = cTransIndex1 ? 0 : 1;
+
+	if ( mbGrayScale )
+		ImplGetGrayPalette( mnDepth );
+
+	return TRUE;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplGetGrayPalette( sal_uInt32 nDepth )
+{
+	sal_uInt32 nAdd, nStart = 0;
+
+	mpAcc->SetPaletteEntryCount( 1 << nDepth );
+
+	switch ( nDepth )
+	{
+		case 1 : nAdd = 255; break;
+		case 2 : nAdd = 85; break;
+		case 4 : nAdd = 17; break;
+		case 8 : nAdd = 1; break;
+	}
+
+	for ( sal_uInt32 i = 0; nStart < 256; i++, nStart += nAdd )
+		mpAcc->SetPaletteColor( (USHORT)i, BitmapColor( mpColorTable[ nStart ],
+			mpColorTable[ nStart ], mpColorTable[ nStart ] ) );
+}
+
+// ------------------------------------------------------------------------
+
+BOOL PNGReaderImpl::ImplReadPalette()
+{
+	sal_uInt32 nCount = mnChunkLen / 3;
+
+	if ( ( ( mnChunkLen % 3 ) == 0 ) && ( ( 0 < nCount ) && ( nCount <= 256 ) ) && mpAcc )
+	{
+		BYTE 	nRed, nGreen, nBlue;
+
+		mbPalette = TRUE;
+		mpAcc->SetPaletteEntryCount( (USHORT) nCount );
+
+		for ( USHORT i = 0; i < nCount; i++ )
+		{
+			nRed =   mpColorTable[ *maDataIter++ ];
+			nGreen = mpColorTable[ *maDataIter++ ];
+			nBlue =  mpColorTable[ *maDataIter++ ];
+			mpAcc->SetPaletteColor( i, Color( nRed, nGreen, nBlue ) );
+		}
+	}
+	else
+		mbStatus = FALSE;
+
+	return mbStatus;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplReadTransparent()
+{
+	if ( mpTransTab == NULL )
+	{
+		switch ( mnColorType )
+		{
+			case 0 :
+			{
+				if ( mnChunkLen == 2 )
+				{
+					mpTransTab = new sal_uInt8[ 256 ];
+					rtl_fillMemory( mpTransTab, 256, 0xff );
+                    // color type 0 and 4 is always greyscale,
+                    // so the return value can be used as index
+                	sal_uInt8 nIndex = ImplScaleColor();
+					mpTransTab[ nIndex ] = 0;
+					mbTransparent = sal_True;
+				}
+			}
+			break;
+
+			case 2 :
+			{
+				if ( mnChunkLen == 6 )
+				{
+					mnTransRed = ImplScaleColor();
+					mnTransGreen = ImplScaleColor();
+					mnTransBlue = ImplScaleColor();
+				}
+			}
+			break;
+
+			case 3 :
+			{
+				if ( mnChunkLen <= 256 )
+				{
+					mpTransTab = new BYTE [ 256 ];
+					rtl_fillMemory( mpTransTab, 256, 0xff );
+					rtl_copyMemory( mpTransTab, maDataIter, mnChunkLen );
+					maDataIter += mnChunkLen;
+					mbTransparent = TRUE;
+				}
+			}
+			break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplGetGamma()
+{
+	sal_uInt32	nGammaValue = ImplReadsal_uInt32();
+	double		fGamma = ( ( VIEWING_GAMMA / DISPLAY_GAMMA ) * ( (double)nGammaValue / 100000 ) );
+	double 		fInvGamma = ( fGamma <= 0.0 || fGamma > 10.0 ) ? 1.0 : ( 1.0 / fGamma );
+
+	if ( fInvGamma != 1.0 )
+	{
+		mbGamma = TRUE;
+		
+		if ( mpColorTable == mpDefaultColorTable )
+			mpColorTable = new sal_uInt8[ 256 ];
+		
+		for ( sal_Int32 i = 0; i < 256; i++ )
+			mpColorTable[ i ] = (sal_uInt8)(pow((double)i/255.0, fInvGamma) * 255.0 + 0.5);
+
+		if ( mbGrayScale )
+			ImplGetGrayPalette( mnDepth );
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplGetBackground()
+{
+	Point 		aPoint;
+	Rectangle	aRectangle( aPoint, Size( mnWidth, mnHeight ) );
+
+	switch ( mnColorType )
+	{
+		case 3 :
+		{
+			if ( mnChunkLen == 1 )
+			{
+				UINT16 nCol = *maDataIter++;
+				if ( nCol < mpAcc->GetPaletteEntryCount() )
+				{
+					mpAcc->SetFillColor( (const Color&)mpAcc->GetPaletteColor( (BYTE)nCol ) );
+					mpAcc->FillRect( aRectangle );
+					break;
+				}
+			}			
+		}
+		break;
+
+		case 0 :
+		case 4 :
+		{
+			if ( mnChunkLen == 2 )
+			{
+                // the color type 0 and 4 is always greyscale,
+                // so the return value can be used as index
+				sal_uInt8 nIndex = ImplScaleColor();
+				mpAcc->SetFillColor( (const Color&)mpAcc->GetPaletteColor( nIndex ) );
+				mpAcc->FillRect( aRectangle );
+			}
+		}
+		break;
+	
+		case 2 :
+		case 6 :
+		{
+			if ( mnChunkLen == 6 )
+			{
+				sal_uInt8 nRed = ImplScaleColor();
+				sal_uInt8 nGreen = ImplScaleColor();
+				sal_uInt8 nBlue = ImplScaleColor();
+				mpAcc->SetFillColor( Color( nRed, nGreen, nBlue ) );
+				mpAcc->FillRect( aRectangle );
+			}
+		}
+		break;
+	}
+}
+
+// ------------------------------------------------------------------------
+
+// for color type 0 and 4 (greyscale) the return value is always index to the color
+//                2 and 6 (RGB)       the return value is always the 8 bit color component
+sal_uInt8 PNGReaderImpl::ImplScaleColor()
+{
+    sal_uInt32 nMask = ( ( 1 << mnBitDepth ) - 1 );
+	sal_uInt16 nCol = ( *maDataIter++ << 8 );
+	
+	nCol += *maDataIter++ & (sal_uInt16)nMask;
+	
+	if ( mnBitDepth > 8 )	// convert 16bit graphics to 8
+		nCol >>= 8;
+	
+	return (sal_uInt8) nCol;
+}
+
+// ------------------------------------------------------------------------
+// ImplReadIDAT reads as much bitmap data as possible
+
+void PNGReaderImpl::ImplReadIDAT()
+{
+	sal_uInt32 nToRead, nRead;
+	if ( mnChunkLen )		// Chunk empty ?
+	{
+		if ( mbzCodecInUse == FALSE )
+		{
+			mbzCodecInUse = TRUE;
+			mpZCodec->BeginCompression( ZCODEC_PNG_DEFAULT );
+		}
+		mpZCodec->SetBreak( mnChunkLen );
+		SvMemoryStream aIStrm( maDataIter, mnChunkLen, STREAM_READ );
+
+		while ( ( mpZCodec->GetBreak() ) )
+		{
+			// get bytes needed to fill the current scanline
+			nToRead = mnScansize - ( mpScan - mpInflateInBuf );
+
+			if ( ( nRead = mpZCodec->ReadAsynchron( aIStrm, mpScan, nToRead ) ) < 0 )
+			{
+				mbStatus = FALSE;
+				break;
+			}
+			if ( nRead < nToRead )
+			{
+				mpScan += nRead;			// ZStream is Broken
+				break;
+			}
+			else
+			{
+				mpScan = mpInflateInBuf;	// this scanline is Finished
+
+				if ( mnInterlaceType == 0	)
+				{
+					ImplGetFilter ( 0, 1 );
+					mnYpos++;
+				}
+				else
+				{
+					// interlace mode
+					switch ( mnPass )
+					{
+						case 1 :																			// pass 1
+						{
+							ImplGetFilter ( 0, 8 );
+							mnYpos += 8;
+						}
+						break;
+
+						case 2 :																			// pass 2
+						{
+							ImplGetFilter ( 4, 8 );
+							mnYpos += 8;
+						}
+						break;
+
+						case 3 :																			// pass 3
+						{
+							if ( mnYpos >= 4 )
+							{
+								ImplGetFilter ( 0, 4 );
+							}
+							mnYpos += 8;
+						}
+						break;
+
+						case 4 :																			// pass 4
+						{
+							ImplGetFilter ( 2, 4 );
+							mnYpos += 4;
+						}
+						break;
+
+						case 5 :																			// pass 5
+						{
+							if ( mnYpos >= 2 )
+							{
+								ImplGetFilter ( 0, 2 );
+							}
+							mnYpos += 4;
+						}
+						break;
+
+						case 6 :																			// pass 6
+						{
+								ImplGetFilter ( 1, 2 );
+								mnYpos += 2;
+						}
+						break;
+
+						case 7 :																			// pass 7
+						{
+							if ( mnYpos >= 1 )
+							{
+								ImplGetFilter ( 0, 1 );
+							}
+							mnYpos += 2;
+						}
+						break;
+					}
+				}
+			}
+
+			if ( mnYpos >= mnHeight )
+			{
+				if ( mnPass == 7 )
+					break;
+				else
+				{
+					ImplResizeScanline();
+				}
+			}
+		}
+	}
+
+	if ( ( mnPass >= 7 ) && ( mnYpos >= mnHeight ) )
+	{
+		mpZCodec->EndCompression();
+		mbzCodecInUse = FALSE;
+		mbIDAT = TRUE;
+	}
+}
+
+// ---------------------------------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplResizeScanline( void )
+{
+	long nScansize;
+
+	while ( mnPass < 7 )
+	{
+		sal_uInt32 nX = 0;
+
+		mnYpos = 0;
+		mnPass++;
+
+		switch ( mnPass )
+		{
+			case 1 :
+				nScansize = ( mnWidth + 7 ) >> 3;
+			break;
+
+			case 2 :
+				nX += 4;
+				nScansize = ( mnWidth + 3 ) >> 3;
+			break;
+
+			case 3 :
+				mnYpos += 4;
+				nScansize = ( mnWidth + 3 ) >> 2;
+			break;
+
+			case 4 :
+				nX += 2;
+				nScansize = ( mnWidth + 1) >> 2;
+			break;
+
+			case 5 :
+				mnYpos += 2;
+				nScansize = ( mnWidth + 1 ) >> 1;
+			break;
+
+			case 6 :
+				nX++;
+				nScansize = mnWidth >> 1;
+			break;
+
+			case 7 :
+				mnYpos++;
+				nScansize = mnWidth;
+			break;
+		}
+
+		if ( ( mnYpos >= mnHeight ) || ( nX >= mnWidth ) )	// is pass to be skipped ?
+			continue;
+
+		// in Interlace mode the size of scanline is not constant
+		// so first we calculate the number of entrys
+		mnScansize = nScansize * mnBitDepth;
+
+		if ( mbRGBTriple )
+			mnScansize *= 3;
+
+		// convert bitsize to byte
+		mnScansize = ( mnScansize + 7 ) >> 3;
+
+		if ( mbAlphaChannel )
+			mnScansize += ( ( nScansize * mnBitDepth ) >> 3 );
+
+		rtl_zeroMemory( mpScanprior, ++mnScansize );
+		break;
+	}
+}
+
+// ---------------------------------------------------------------------------------------------------
+// ImplGetFilter writes the complete Scanline (nY) - in interlace mode the parameter nXStart and nXAdd
+// appends to the currently used pass
+// the complete size of scanline will be returned - in interlace mode zero is possible!
+
+void PNGReaderImpl::ImplGetFilter ( sal_uInt32 nXStart, sal_uInt32 nXAdd )
+{
+	BYTE* 		pTmp = mpInflateInBuf;
+	BYTE* 		p1;
+	BYTE* 		p2;
+	BYTE* 		p3;
+	BYTE* 		p4;
+	BYTE  		nFilterType, nCol;
+	sal_uInt32	nXIndex, nX, nY = mnYpos, n1, n2, na, nb, nc;
+	sal_Int32	np, npa, npb, npc;
+
+	sal_uInt32 nBBP = mnBBP;
+
+	if ( nXStart < (sal_uInt32)mnWidth )
+	{
+		nFilterType = *pTmp++;	// the filter type may change each scanline
+
+		switch ( nFilterType )
+		{
+			case 1 :
+			{
+				p1 = pTmp + nBBP;
+				p2 = pTmp;
+		
+				while ( p1 < pTmp + mnScansize - 1 )
+					( *p1++ ) += ( *p2++ );
+			}
+			break;
+
+			case 2 :
+			{
+				p1 = pTmp;
+				p2 = mpScanprior+1;
+
+				while ( p1 < pTmp + mnScansize - 1 )
+					( *p1++ ) += ( *p2++ );
+			}
+			break;
+
+			case 3 :
+			{
+				p1 = pTmp;
+				p2 = mpScanprior + 1;
+				p3 = pTmp-nBBP;
+
+				while ( p1 < pTmp + mnScansize - 1 )
+				{
+					n1 = (BYTE)( *p2++ );
+					n2 = ( p3 >= pTmp ) ? (BYTE)*p3 : 0;
+					p3++;
+					( *p1++ ) += (BYTE)( ( n1 + n2 ) >> 1 );
+				}
+			}
+			break;
+
+			case 4 :
+			{
+				p1 = pTmp;
+				p2 = p1 - nBBP;
+				p3 = mpScanprior + 1;
+				p4 = p3 - nBBP;
+
+				while ( p1 < pTmp + mnScansize - 1 )
+				{
+					nb = *p3++;
+					if ( p2 >= pTmp )
+					{
+						na = *p2;
+						nc = *p4;
+					}
+					else
+						na = nc = 0;
+
+					np = na + nb;
+					np -= nc;
+					npa = np - na;
+					npb = np - nb;
+					npc = np - nc;
+					
+					if ( npa < 0 )
+						npa =-npa;
+					if ( npb < 0 )
+						npb =-npb;
+					if ( npc < 0 )
+						npc =-npc;
+
+					if ( ( npa <= npb ) && ( npa <= npc ) ) 
+						*p1++ += (BYTE)na;
+					else if ( npb <= npc )
+						*p1++ += (BYTE)nb;
+					else
+						*p1++ += (BYTE)nc;
+
+					p2++;
+					p4++;
+				}
+			}
+			break;
+			// undefined FilterType -> we will let them pass and display the data unfiltered
+		}
+		if ( mpAcc->HasPalette() )	// alphachannel is not allowed by pictures including palette entries
+		{
+			switch ( mpAcc->GetBitCount() )
+			{
+				case 1 :
+				{
+					if ( mbTransparent )
+					{
+						for ( nX = nXStart, nXIndex = 0; nX < (sal_uInt32)mnWidth; nX += nXAdd, nXIndex++ )
+						{
+							sal_uInt32 nShift = ( nXIndex & 7 ) ^ 7;
+					
+							if ( nShift == 0 )
+								nCol = ( *pTmp++ ) & 1;
+							else
+								nCol = ( *pTmp >> nShift ) & 1;
+	
+							ImplSetPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
+						}
+					}
+					else
+					{
+						for ( nX = nXStart, nXIndex = 0; nX < (sal_uInt32)mnWidth; nX += nXAdd, nXIndex++ )
+						{
+							sal_uInt32 nShift = ( nXIndex & 7 ) ^ 7;
+
+							if ( nShift == 0 )
+								ImplSetPixel( nY, nX, ( *pTmp++ & 1 ), FALSE );
+							else
+								ImplSetPixel( nY, nX, ( *pTmp >> nShift ) & 1, FALSE );
+						}
+					}
+				}
+				break;
+
+				case 4 :
+				{
+					if ( mbTransparent )
+					{
+						if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								if( nXIndex & 1 )
+								{
+									ImplSetPixel( nY, nX, *pTmp & 0x0f, mpTransTab[ *pTmp & 0x0f ] < PNG_TRANS_VAL );
+									pTmp++;
+								}
+								else
+								{
+									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, mpTransTab[ *pTmp >> 4 ] < PNG_TRANS_VAL );
+								}
+							}
+						}
+						else
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								switch( nXIndex & 3 )
+								{
+									case 0 :
+										nCol = *pTmp >> 6;
+									break;
+
+									case 1 :
+										nCol = ( *pTmp >> 4 ) & 0x03 ;
+									break;
+
+									case 2 :
+										nCol = ( *pTmp >> 2 ) & 0x03;
+									break;
+
+									case 3 :
+										nCol = ( *pTmp++ ) & 0x03;
+									break;
+								}
+
+								ImplSetPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
+							}
+						}
+					}
+					else
+					{
+						if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								if( nXIndex & 1 )
+									ImplSetPixel( nY, nX, *pTmp++ & 0x0f, FALSE );
+								else
+									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, FALSE );
+							}
+						}
+						else
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								switch( nXIndex & 3 )
+								{
+									case 0 :
+										ImplSetPixel( nY, nX, *pTmp >> 6, FALSE );
+									break;
+
+									case 1 :
+										ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x03, FALSE );
+									break;
+
+									case 2 :
+										ImplSetPixel( nY, nX, ( *pTmp >> 2 ) & 0x03, FALSE );
+									break;
+
+									case 3 :
+										ImplSetPixel( nY, nX, *pTmp++ & 0x03, FALSE );
+									break;
+								}
+							}
+						}
+					}
+				}
+				break;
+
+				case 8 :
+				{
+					if ( mbAlphaChannel )
+					{
+						if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
+						{
+							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
+								ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 1 ] );
+						}
+						else
+						{
+							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
+								ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 2 ] );
+						}
+					}
+					else
+					{
+						if ( mbTransparent )
+						{
+							if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp++ )
+									ImplSetPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
+							}
+							else
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
+									ImplSetPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
+							}
+						}
+						else
+						{
+							if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd )
+									ImplSetPixel( nY, nX, *pTmp++, FALSE );
+							}
+							else
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
+									ImplSetPixel( nY, nX, *pTmp, FALSE );
+							}
+						}
+					}
+				}
+				break;
+
+				default :
+					mbStatus = FALSE;
+				break;
+			}
+		}
+		else
+		{
+			if ( mbAlphaChannel || mbTransparent )
+			{
+				if ( mbAlphaChannel )
+				{
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
+							ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+																		mpColorTable[ pTmp[ 1 ] ],
+																			mpColorTable[ pTmp[ 2 ] ] ), pTmp[ 3 ] );
+					}
+					else
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 8 )
+							ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+																		mpColorTable[ pTmp[ 2 ] ],
+																			mpColorTable[ pTmp[ 4 ] ] ), pTmp[6] );
+					}
+				}
+				else // Transparency chunk
+				{
+					sal_Bool	bTransparent;
+					sal_uInt8	nRed, nGreen, nBlue;
+
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
+						{
+							nRed = pTmp[ 0 ];
+							nGreen = pTmp[ 1 ];
+							nBlue = pTmp[ 2 ];
+							bTransparent = ( ( nRed == mnTransRed )
+											&& ( nGreen == mnTransGreen )
+												&& ( nBlue == mnTransBlue ) );
+
+							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
+																mpColorTable[ nGreen ],
+																	mpColorTable[ nBlue ] ), bTransparent );
+						}
+					}
+					else
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 6 )
+						{
+							nRed = pTmp[ 0 ];
+							nGreen = pTmp[ 2 ];
+							nBlue = pTmp[ 4 ];
+							bTransparent = ( ( nRed == mnTransRed )
+											&& ( nGreen == mnTransGreen )
+												&& ( nBlue == mnTransBlue ) );
+
+							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
+																mpColorTable[ nGreen ],
+																	mpColorTable[ nBlue ] ), bTransparent );
+						}
+					}
+				}
+			}
+			else
+			{
+				if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+				{
+					for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
+						ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+															mpColorTable[ pTmp[ 1 ] ],
+																mpColorTable[ pTmp[ 2 ] ] ), FALSE );
+				}
+				else
+				{
+					for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 6 )
+						ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+															mpColorTable[ pTmp[ 2 ] ],
+																mpColorTable[ pTmp[ 4 ] ] ), FALSE );
+				}
+			}
+		}
+	}
+
+	rtl_copyMemory( mpScanprior, mpInflateInBuf, mnScansize );
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BOOL bTrans )
+{
+	if ( mnPass == 7 )
+	{
+		mpAcc->SetPixel( nY, nX, rBitmapColor );
+
+		if ( bTrans )
+			mpMaskAcc->SetPixel( nY, nX, cTransIndex1 );
+		else
+			mpMaskAcc->SetPixel( nY, nX, cNonTransIndex1 );
+	}
+	else
+	{
+		sal_uInt32 nTX;
+
+		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
+		{
+			nTX = nX;
+
+			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
+			{
+				mpAcc->SetPixel( nY, nTX, rBitmapColor );
+
+				if ( bTrans )
+					mpMaskAcc->SetPixel( nY, nTX, cTransIndex1 );
+				else
+					mpMaskAcc->SetPixel( nY, nTX, cNonTransIndex1 );
+
+				if ( ++nTX == mnWidth )
+					break;
+			}
+
+			if ( ++nY == mnHeight )
+				break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, BYTE nPalIndex, BOOL bTrans )
+{
+	if ( mnPass == 7 )
+	{
+		mpAcc->SetPixel( nY, nX, (BYTE)nPalIndex );
+
+		if ( bTrans )
+			mpMaskAcc->SetPixel( nY, nX, cTransIndex1 );
+		else
+			mpMaskAcc->SetPixel( nY, nX, cNonTransIndex1 );
+	}
+	else
+	{
+		sal_uInt32 nTX;
+
+		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
+		{
+			nTX = nX;
+
+			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
+			{
+				mpAcc->SetPixel( nY, nTX, (BYTE)nPalIndex );
+
+				if ( bTrans )
+					mpMaskAcc->SetPixel( nY, nTX, cTransIndex1 );
+				else
+					mpMaskAcc->SetPixel( nY, nTX, cNonTransIndex1 );
+
+				if ( ++nTX == mnWidth )
+					break;
+			}
+			if ( ++nY == mnHeight )
+				break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplSetAlphaPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BYTE nAlpha )
+{
+	if ( mnPass == 7 )
+	{
+		mpAcc->SetPixel( nY, nX, rBitmapColor );
+		mpMaskAcc->SetPixel( nY, nX, 255 - nAlpha );
+	}
+	else
+	{
+		sal_uInt32 nTX;
+
+		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
+		{
+			nTX = nX;
+
+			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
+			{
+				mpAcc->SetPixel( nY, nTX, rBitmapColor );
+				mpMaskAcc->SetPixel( nY, nTX, 255 - nAlpha );
+				if ( ++nTX == mnWidth )
+					break;
+			}
+
+			if ( ++nY == mnHeight )
+				break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+sal_uInt32 PNGReaderImpl::ImplReadsal_uInt32()
+{
+	sal_uInt32 nRet;
+	nRet = *maDataIter++;
+	nRet <<= 8;
+	nRet |= *maDataIter++;
+	nRet <<= 8;
+	nRet |= *maDataIter++;
+	nRet <<= 8;
+	nRet |= *maDataIter++;
+	return nRet;
+}
+
+// ------------------------------------------------------------------------
+
+// -------------
+// - PNGReader -
+// -------------
+
+PNGReader::PNGReader( SvStream& rIStm ) :
+	mpImpl( new ::vcl::PNGReaderImpl( rIStm ) )
+{
+}
+
+// ------------------------------------------------------------------------
+
+PNGReader::~PNGReader()
+{
+	delete mpImpl;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx PNGReader::Read()
+{
+	return mpImpl->Read();
+}
+
+// ------------------------------------------------------------------------
+
+const std::vector< vcl::PNGReader::ChunkData >& PNGReader::GetChunks() const
+{
+	return mpImpl->maChunkSeq;
+}
+
+} // namespace vcl
Index: vcl/source/gdi/pngwrite.cxx
===================================================================
RCS file: vcl/source/gdi/pngwrite.cxx
diff -N vcl/source/gdi/pngwrite.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/gdi/pngwrite.cxx	28 Jun 2004 16:23:56 -0000	1.4
@@ -0,0 +1,750 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "pngwrite.hxx"
+
+#include <cmath>
+#include <rtl/crc.h>
+#include <rtl/memory.h>
+#include <rtl/alloc.h>
+#include <tools/zcodec.hxx>
+#include <tools/stream.hxx>
+#include "bmpacc.hxx"
+#include "svapp.hxx"
+#include "alpha.hxx"
+
+#ifndef _OSL_ENDIAN_H_
+#include <osl/endian.h>
+#endif
+
+// -----------
+// - Defines -
+// -----------
+
+#define PNG_DEF_COMPRESSION 6
+
+#define PNGCHUNK_IHDR 0x49484452
+#define PNGCHUNK_PLTE 0x504c5445
+#define PNGCHUNK_IDAT 0x49444154
+#define PNGCHUNK_IEND 0x49454e44
+#define PNGCHUNK_bKGD 0x624b4744
+#define PNGCHUNK_cHRM 0x6348524d
+#define PNGCHUNK_gAMA 0x67414d41
+#define PNGCHUNK_hIST 0x68495354
+#define PNGCHUNK_pHYs 0x70485973
+#define PNGCHUNK_sBIT 0x73425420
+#define PNGCHUNK_tIME 0x74494d45
+#define PNGCHUNK_tEXt 0x74455874
+#define PNGCHUNK_tRNS 0x74524e53
+#define PNGCHUNK_zTXt 0x7a545874
+
+namespace vcl
+{
+// -----------------
+// - PNGWriterImplImpl -
+// -----------------
+
+class PNGWriterImpl
+{
+public:
+
+				PNGWriterImpl( const BitmapEx& BmpEx,
+					const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData = NULL );
+				~PNGWriterImpl();
+
+	sal_Bool	Write( SvStream& rOStm );
+
+	std::vector< vcl::PNGWriter::ChunkData >&	GetChunks();
+
+private:
+
+	std::vector< vcl::PNGWriter::ChunkData >	maChunkSeq;
+
+	sal_Int32			mnCompLevel;
+	sal_Int32			mnInterlaced;
+	BOOL				mbStatus;
+
+	BitmapReadAccess*	mpAccess;
+	BitmapReadAccess*	mpMaskAccess;
+	ZCodec*				mpZCodec;
+
+	BYTE*				mpDeflateInBuf;			// as big as the size of a scanline + alphachannel + 1
+	BYTE*				mpPreviousScan;			// as big as mpDeflateInBuf
+	BYTE*				mpCurrentScan;
+	ULONG				mnDeflateInSize;
+
+	ULONG				mnWidth, mnHeight;
+	BYTE				mnBitsPerPixel;
+	BYTE				mnFilterType;			// 0 oder 4;
+	ULONG				mnBBP;					// bytes per pixel ( needed for filtering )
+	BOOL				mbTrueAlpha;
+	ULONG				mnCRC;
+	long				mnChunkDatSize;
+	ULONG				mnLastPercent;
+
+	void				ImplWritepHYs( const BitmapEx& rBitmapEx );
+	void				ImplWriteIDAT();
+	ULONG				ImplGetFilter( ULONG nY, ULONG nXStart=0, ULONG nXAdd=1 );
+	void				ImplClearFirstScanline();
+	void				ImplWriteTransparent();
+	BOOL				ImplWriteHeader();
+	void				ImplWritePalette();
+	void				ImplOpenChunk( ULONG nChunkType );
+	void				ImplWriteChunk( BYTE nNumb );
+	void				ImplWriteChunk( ULONG nNumb );
+	void				ImplWriteChunk( unsigned char* pSource, sal_uInt32 nDatSize );
+	void				ImplCloseChunk( void );
+};
+
+// ------------------------------------------------------------------------
+
+PNGWriterImpl::PNGWriterImpl( const BitmapEx& rBmpEx,
+	const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData ) :
+		mnLastPercent	( 0UL ),
+		mnInterlaced	( 0 ),
+		mnCompLevel		( PNG_DEF_COMPRESSION ),
+		mpAccess		( NULL ),
+		mpMaskAccess	( NULL ),
+		mbStatus		( TRUE ),
+		mpZCodec		( new ZCodec( DEFAULT_IN_BUFSIZE, DEFAULT_OUT_BUFSIZE, MAX_MEM_USAGE ) )
+{
+	if ( !rBmpEx.IsEmpty() )
+	{
+		Bitmap			aBmp( rBmpEx.GetBitmap() );
+
+		if ( pFilterData )
+		{
+			sal_Int32 i = 0;
+			for ( i = 0; i < pFilterData->getLength(); i++ )
+			{
+				if ( (*pFilterData)[ i ].Name.equalsAscii( "Compression" ) )
+					(*pFilterData)[ i ].Value >>= mnCompLevel;
+				else if ( (*pFilterData)[ i ].Name.equalsAscii( "Interlaced" ) )
+					(*pFilterData)[ i ].Value >>= mnInterlaced;
+			}
+		}
+		mnBitsPerPixel = (BYTE)aBmp.GetBitCount();
+		
+		if( rBmpEx.IsTransparent() )
+		{
+			if ( mnBitsPerPixel <= 8 && rBmpEx.IsAlpha() )
+			{
+				aBmp.Convert( BMP_CONVERSION_24BIT );
+				mnBitsPerPixel = 24;
+			}
+	        
+			if ( mnBitsPerPixel <= 8 )					// transparent palette
+			{
+				aBmp.Convert( BMP_CONVERSION_8BIT_TRANS );
+				aBmp.Replace( rBmpEx.GetMask(), BMP_COL_TRANS );
+				mnBitsPerPixel = 8;
+				mpAccess = aBmp.AcquireReadAccess();
+				if ( mpAccess )
+				{
+					if ( ImplWriteHeader() )
+					{
+						ImplWritepHYs( rBmpEx );
+						ImplWritePalette();
+						ImplWriteTransparent();
+						ImplWriteIDAT();
+					}
+					aBmp.ReleaseAccess( mpAccess );
+				}
+				else
+					mbStatus = FALSE;
+			}
+			else
+			{
+				mpAccess = aBmp.AcquireReadAccess();	// TRUE RGB with alphachannel
+				if( mpAccess )
+				{
+					if ( ( mbTrueAlpha = rBmpEx.IsAlpha() ) )
+					{
+						AlphaMask aMask( rBmpEx.GetAlpha() );
+						mpMaskAccess = aMask.AcquireReadAccess();
+						if ( mpMaskAccess )
+						{
+							if ( ImplWriteHeader() )
+							{
+								ImplWritepHYs( rBmpEx );
+								ImplWriteIDAT();
+							}
+							aMask.ReleaseAccess( mpMaskAccess );
+						}
+						else
+							mbStatus = FALSE;
+					}
+					else
+					{
+						Bitmap aMask( rBmpEx.GetMask() );
+						mpMaskAccess = aMask.AcquireReadAccess();
+						if( mpMaskAccess )
+						{
+							if ( ImplWriteHeader() )
+							{
+								ImplWritepHYs( rBmpEx );
+								ImplWriteIDAT();
+							}
+							aMask.ReleaseAccess( mpMaskAccess );
+						}
+						else
+							mbStatus = FALSE;
+					}
+					aBmp.ReleaseAccess( mpAccess );
+				}
+				else
+					mbStatus = FALSE;
+			}
+		}
+		else
+		{
+			mpAccess = aBmp.AcquireReadAccess();		// palette + RGB without alphachannel
+			if( mpAccess )
+			{
+				if ( ImplWriteHeader() )
+				{
+					ImplWritepHYs( rBmpEx );
+					if( mpAccess->HasPalette() )
+						ImplWritePalette();
+
+					ImplWriteIDAT();
+				}
+				aBmp.ReleaseAccess( mpAccess );
+			}
+			else
+				mbStatus = FALSE;
+		}
+		if ( mbStatus )
+		{
+			ImplOpenChunk( PNGCHUNK_IEND );		// create an IEND chunk
+			ImplCloseChunk();
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+PNGWriterImpl::~PNGWriterImpl()
+{
+	delete mpZCodec;
+}
+
+// ------------------------------------------------------------------------
+
+sal_Bool PNGWriterImpl::Write( SvStream& rOStm )
+{
+   /* png signature is always an array of 8 bytes */
+	sal_uInt16 nOldMode = rOStm.GetNumberFormatInt();
+	rOStm.SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+	rOStm << (ULONG)0x89504e47;
+	rOStm << (ULONG)0x0d0a1a0a;
+
+	std::vector< vcl::PNGWriter::ChunkData >::iterator aBeg( maChunkSeq.begin() );
+	std::vector< vcl::PNGWriter::ChunkData >::iterator aEnd( maChunkSeq.end() );
+	while( aBeg != aEnd )
+	{
+		sal_uInt32 nType = aBeg->nType;
+	#if defined(__LITTLEENDIAN) || defined(OSL_LITENDIAN)
+		nType = SWAPLONG( nType );
+	#endif
+		sal_uInt32 nCRC = rtl_crc32( 0, &nType, 4 );
+		sal_uInt32 nDataSize = aBeg->aData.size();
+		if ( nDataSize )
+			nCRC = rtl_crc32( nCRC, &aBeg->aData[ 0 ], nDataSize );
+		rOStm << nDataSize
+			  << aBeg->nType;
+		rOStm.Write( &aBeg->aData[ 0 ], nDataSize );
+		rOStm << nCRC;
+		aBeg++;
+	}
+	rOStm.SetNumberFormatInt( nOldMode );
+	return mbStatus;
+}
+
+// ------------------------------------------------------------------------
+
+std::vector< vcl::PNGWriter::ChunkData >& PNGWriterImpl::GetChunks()
+{
+	return maChunkSeq;
+}
+
+// ------------------------------------------------------------------------
+
+BOOL PNGWriterImpl::ImplWriteHeader()
+{
+	ImplOpenChunk(PNGCHUNK_IHDR);
+	ImplWriteChunk( ( mnWidth = (ULONG)mpAccess->Width() ) );
+	ImplWriteChunk( ( mnHeight = (ULONG)mpAccess->Height() ) );
+
+	if ( mnWidth && mnHeight && mnBitsPerPixel && mbStatus )
+	{
+		BYTE nBitDepth = mnBitsPerPixel;
+		if ( mnBitsPerPixel <= 8 )
+			mnFilterType = 0;
+		else
+			mnFilterType = 4;
+
+		BYTE nColorType = 2;					// colortype:
+												// bit 0 -> palette is used
+		if ( mpAccess->HasPalette() )			// bit 1 -> color is used
+			nColorType |= 1;					// bit 2 -> alpha channel is used
+		else
+			nBitDepth /= 3;
+
+		if ( mpMaskAccess )
+			nColorType |= 4;
+
+		ImplWriteChunk( nBitDepth );
+		ImplWriteChunk( nColorType );			// colortype
+		ImplWriteChunk((BYTE) 0 );				// compression type
+		ImplWriteChunk((BYTE) 0 );				// filter type - is not supported in this version
+		ImplWriteChunk((BYTE) mnInterlaced );	// interlace type
+		ImplCloseChunk();
+	}
+	else
+		mbStatus = FALSE;
+	return mbStatus;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWritePalette()
+{
+	const ULONG	nCount = mpAccess->GetPaletteEntryCount();
+	BYTE*		pTempBuf = new BYTE[ nCount*3 ];
+	BYTE*		pTmp = pTempBuf;
+
+	ImplOpenChunk( PNGCHUNK_PLTE );
+
+	for ( USHORT i = 0; i < nCount; i++ )
+	{
+		const BitmapColor& rColor = mpAccess->GetPaletteColor( i );
+		*pTmp++ = rColor.GetRed();
+		*pTmp++ = rColor.GetGreen();
+		*pTmp++ = rColor.GetBlue();
+	}
+	ImplWriteChunk( pTempBuf, nCount*3 );
+	ImplCloseChunk();
+	delete[] pTempBuf;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWriteTransparent ()
+{
+	const ULONG nTransIndex = mpAccess->GetBestMatchingColor( BMP_COL_TRANS );
+
+	ImplOpenChunk( PNGCHUNK_tRNS );
+
+	for ( ULONG n = 0UL; n <= nTransIndex; n++ )
+		ImplWriteChunk( ( nTransIndex == n ) ? (BYTE) 0x0 : (BYTE) 0xff );
+
+	ImplCloseChunk();
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWritepHYs( const BitmapEx& rBmpEx )
+{
+	if ( rBmpEx.GetPrefMapMode() == MAP_100TH_MM )
+	{
+		Size aPrefSize( rBmpEx.GetPrefSize() );
+		if ( aPrefSize.Width() && aPrefSize.Height() )
+		{
+			ImplOpenChunk( PNGCHUNK_pHYs );
+			sal_uInt8 nMapUnit = 1;
+			sal_uInt32 nPrefSizeX = (sal_uInt32)( (double)100000.0 / ( (double)aPrefSize.Width() / mnWidth ) + 0.5 );
+			sal_uInt32 nPrefSizeY = (sal_uInt32)( (double)100000.0 / ( (double)aPrefSize.Height() / mnHeight ) + 0.5 );
+			ImplWriteChunk( nPrefSizeX );
+			ImplWriteChunk( nPrefSizeY );
+			ImplWriteChunk( nMapUnit );
+			ImplCloseChunk();
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWriteIDAT ()
+{
+	ImplOpenChunk( PNGCHUNK_IDAT );
+
+	mnDeflateInSize = mnBitsPerPixel;
+
+	if( mpMaskAccess )
+		mnDeflateInSize += 8;
+
+	mnBBP = ( mnDeflateInSize + 7 ) >> 3;
+
+	mnDeflateInSize = mnBBP * mnWidth + 1;
+
+	mpDeflateInBuf = new BYTE[ mnDeflateInSize ];
+
+	if ( mnFilterType )			// using filter type 4 we need memory for the scanline 3 times
+	{
+		mpPreviousScan = new BYTE[ mnDeflateInSize ];
+		mpCurrentScan = new BYTE[ mnDeflateInSize ];
+		ImplClearFirstScanline();
+	}
+	mpZCodec->BeginCompression( ZCODEC_PNG_DEFAULT + mnCompLevel );
+	mpZCodec->SetCRC( mnCRC );
+	SvMemoryStream aOStm;
+	if ( mnInterlaced == 0 )
+	{
+		for ( ULONG nY = 0; nY < mnHeight; nY++ )
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter( nY ) );
+	}
+	else
+	{
+		// interlace mode
+		ULONG nY;
+		for ( nY = 0; nY < mnHeight; nY+=8 )												// pass 1
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 8 ) );
+		ImplClearFirstScanline();
+
+		for ( nY = 0; nY < mnHeight; nY+=8 )												// pass 2
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 4, 8 ) );
+		ImplClearFirstScanline();
+
+		if ( mnHeight >= 5 )																// pass 3
+		{
+			for ( nY = 4; nY < mnHeight; nY+=8 )
+				mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 4 ) );
+			ImplClearFirstScanline();
+		}
+
+		for ( nY = 0; nY < mnHeight; nY+=4 )												// pass 4
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 2, 4 ) );
+		ImplClearFirstScanline();
+
+		if ( mnHeight >= 3 )																// pass 5
+		{
+			for ( nY = 2; nY < mnHeight; nY+=4 )
+				mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 2 ) );
+			ImplClearFirstScanline();
+		}
+
+		for ( nY = 0; nY < mnHeight; nY+=2 )												// pass 6
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 1, 2 ) );
+		ImplClearFirstScanline();
+
+		if ( mnHeight >= 2 )																// pass 7
+		{
+			for ( nY = 1; nY < mnHeight; nY+=2 )
+				mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 1 ) );
+		}
+	}
+	mpZCodec->EndCompression();
+	mnCRC = mpZCodec->GetCRC();
+
+	if ( mnFilterType )			// using filter type 4 we need memory for the scanline 3 times
+	{
+		delete[] mpCurrentScan;
+		delete[] mpPreviousScan;
+	}
+	delete[] mpDeflateInBuf;
+	ImplWriteChunk( (unsigned char*)aOStm.GetData(), aOStm.Tell() );
+	ImplCloseChunk();
+}
+
+// ---------------------------------------------------------------------------------------------------
+// ImplGetFilter writes the complete Scanline (nY) - in interlace mode the parameter nXStart and nXAdd
+// appends to the currently used pass
+// the complete size of scanline will be returned - in interlace mode zero is possible!
+
+ULONG PNGWriterImpl::ImplGetFilter ( ULONG nY, ULONG nXStart, ULONG nXAdd )
+{
+	BYTE* pDest;
+
+	if ( mnFilterType )
+		pDest = mpCurrentScan;
+	else
+		pDest = mpDeflateInBuf;
+
+	if ( nXStart < mnWidth )
+	{
+		*pDest++ = mnFilterType;		// in this version the filter type is either 0 or 4
+
+		if ( mpAccess->HasPalette() )	// alphachannel is not allowed by pictures including palette entries
+		{
+			switch ( mnBitsPerPixel )
+			{
+				case( 1 ):
+				{
+					ULONG nX, nXIndex;
+					for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX+=nXAdd, nXIndex++ )
+					{
+						ULONG nShift = ( nXIndex & 7 ) ^ 7;
+						if ( nShift == 7)
+							*pDest = (BYTE) mpAccess->GetPixel( nY, nX ) << nShift;
+						else if  ( nShift == 0 )
+							*pDest++ |= (BYTE) mpAccess->GetPixel( nY, nX ) << nShift;
+						else
+							*pDest |= (BYTE) mpAccess->GetPixel( nY, nX ) << nShift;
+					}
+					if ( ( nXIndex & 7 ) != 0 ) pDest++;	// byte is not completely used, so the
+				}											// bufferpointer is to correct
+				break;
+
+				case( 4 ):
+				{
+					ULONG nX, nXIndex;
+					for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX+= nXAdd, nXIndex++ )
+					{
+						if( nXIndex & 1 )
+							*pDest++ |= (BYTE) mpAccess->GetPixel( nY, nX );
+						else
+							*pDest = (BYTE) mpAccess->GetPixel( nY, nX ) << 4;
+					}
+					if ( nXIndex & 1 ) pDest++;
+				}
+				break;
+
+				case( 8 ):
+				{
+					for ( ULONG nX = nXStart; nX < mnWidth; nX+=nXAdd )
+						*pDest++ = mpAccess->GetPixel( nY, nX );
+				}
+				break;
+
+				default :
+					mbStatus = FALSE;
+				break;
+			}
+		}
+		else
+		{
+			if ( mpMaskAccess )				// mpMaskAccess != NULL -> alphachannel is to create
+			{
+				if ( mbTrueAlpha )
+				{
+					for ( ULONG nX = nXStart; nX < mnWidth; nX += nXAdd )
+					{
+						const BitmapColor& rColor = mpAccess->GetPixel( nY, nX );
+						*pDest++ = rColor.GetRed();
+						*pDest++ = rColor.GetGreen();
+						*pDest++ = rColor.GetBlue();
+						*pDest++ = 255 - mpMaskAccess->GetPixel( nY, nX );
+					}
+				}
+				else
+				{
+					const BitmapColor aTrans( mpMaskAccess->GetBestMatchingColor( Color( COL_WHITE ) ) );
+
+					for ( ULONG nX = nXStart; nX < mnWidth; nX+=nXAdd )
+					{
+						const BitmapColor& rColor = mpAccess->GetPixel( nY, nX );
+						*pDest++ = rColor.GetRed();
+						*pDest++ = rColor.GetGreen();
+						*pDest++ = rColor.GetBlue();
+
+						if( mpMaskAccess->GetPixel( nY, nX ) == aTrans )
+							*pDest++ = 0;
+						else
+							*pDest++ = 0xff;
+					}
+				}
+			}
+			else
+			{
+				for ( ULONG nX = nXStart; nX < mnWidth; nX+=nXAdd )
+				{
+					const BitmapColor& rColor = mpAccess->GetPixel( nY, nX );
+					*pDest++ = rColor.GetRed();
+					*pDest++ = rColor.GetGreen();
+					*pDest++ = rColor.GetBlue();
+				}
+			}
+		}
+	}
+	// filter type4 ( PAETH ) will be used only for 24bit graphics
+	if ( mnFilterType )
+	{
+		mnDeflateInSize = pDest - mpCurrentScan;
+		pDest = mpDeflateInBuf;
+		*pDest++ = 4;									// filter type
+
+		ULONG na, nb, nc;
+		long  np, npa, npb, npc;
+
+		BYTE* p1 = mpCurrentScan + 1;					// Current Pixel
+		BYTE* p2 = p1 - mnBBP;							// left pixel
+		BYTE* p3 = mpPreviousScan;						// upper pixel
+		BYTE* p4 = p3 - mnBBP;							// upperleft Pixel;
+
+		while ( pDest < mpDeflateInBuf + mnDeflateInSize )
+		{
+			nb = *p3++;
+			if ( p2 >= mpCurrentScan + 1 )
+			{
+				na = *p2;
+				nc = *p4;
+			}
+			else
+				na = nc = 0;
+
+			np = na + nb;
+			np -= nc;
+			npa = np - na;
+			npb = np - nb;
+			npc = np - nc;
+			if ( npa < 0 )
+				npa =-npa;
+			if ( npb < 0 )
+				npb =-npb;
+			if ( npc < 0 )
+				npc =-npc;
+			if ( ( npa <= npb ) && ( npa <= npc ) ) *pDest++ = *p1++ - (BYTE)na;
+			else if ( npb <= npc ) *pDest++ = *p1++ - (BYTE)nb;
+			else *pDest++ = *p1++ - (BYTE)nc;
+			p4++;
+			p2++;
+		}
+		for ( long i = 0; i < (long)( mnDeflateInSize - 1 ); i++ )
+			mpPreviousScan[ i ] = mpCurrentScan[ i + 1 ];
+	}
+	else
+		mnDeflateInSize = pDest - mpDeflateInBuf;
+	return ( mnDeflateInSize );
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplClearFirstScanline()
+{
+	if ( mnFilterType )
+		rtl_zeroMemory( mpPreviousScan, mnDeflateInSize );
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplOpenChunk ( ULONG nChunkType )
+{
+	maChunkSeq.resize( maChunkSeq.size() + 1 );
+	maChunkSeq.back().nType = nChunkType;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWriteChunk ( BYTE nSource )
+{
+	maChunkSeq.back().aData.push_back( nSource );
+}
+
+void PNGWriterImpl::ImplWriteChunk ( ULONG nSource )
+{
+	vcl::PNGWriter::ChunkData& rChunkData = maChunkSeq.back();
+	rChunkData.aData.push_back( (sal_uInt8)( nSource >> 24 ) );
+	rChunkData.aData.push_back( (sal_uInt8)( nSource >> 16 ) );
+	rChunkData.aData.push_back( (sal_uInt8)( nSource >> 8 ) );
+	rChunkData.aData.push_back( (sal_uInt8)( nSource ) );
+}
+
+void PNGWriterImpl::ImplWriteChunk ( unsigned char* pSource, sal_uInt32 nDatSize )
+{
+	if ( nDatSize )
+	{
+		vcl::PNGWriter::ChunkData& rChunkData = maChunkSeq.back();
+		sal_uInt32 nSize = rChunkData.aData.size();
+		rChunkData.aData.resize( nSize + nDatSize );
+		rtl_copyMemory( &rChunkData.aData[ nSize ], pSource, nDatSize );
+	}
+}
+
+// ------------------------------------------------------------------------
+// nothing to do
+void PNGWriterImpl::ImplCloseChunk ( void )
+{
+}
+
+// -------------
+// - PNGWriter -
+// -------------
+
+PNGWriter::PNGWriter( const BitmapEx& rBmpEx,
+	const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData ) :
+	mpImpl( new ::vcl::PNGWriterImpl( rBmpEx, pFilterData ) )
+{
+}
+
+// ------------------------------------------------------------------------
+
+PNGWriter::~PNGWriter()
+{
+	delete mpImpl;
+}
+
+// ------------------------------------------------------------------------
+
+sal_Bool PNGWriter::Write( SvStream& rIStm )
+{
+	return mpImpl->Write( rIStm );
+}
+
+// ------------------------------------------------------------------------
+
+std::vector< vcl::PNGWriter::ChunkData >& PNGWriter::GetChunks()
+{
+	return mpImpl->GetChunks();
+}
+
+} // namespace vcl
+
Index: vcl/source/gdi/polyscan.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/polyscan.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/polyscan.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/polyscan.cxx	6 Jan 2004 13:52:52 -0000	1.2
@@ -62,8 +62,11 @@
 #include <string.h>
 #include <tools/new.hxx>
 #include "salbtype.hxx"
-#include "poly.hxx"
 #include "polyscan.hxx"
+
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 
 // ----------------
 // - PolyScanline -
Index: vcl/source/gdi/print.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/print.cxx,v
retrieving revision 1.42.82.1
retrieving revision 1.45
diff -u -p -u -r1.42.82.1 -r1.45
--- vcl/source/gdi/print.cxx	26 Jan 2004 17:23:05 -0000	1.42.82.1
+++ vcl/source/gdi/print.cxx	6 Jan 2004 13:53:20 -0000	1.45
@@ -59,14 +59,11 @@
  *
  ************************************************************************/
 
-#define _SV_PRINT_CXX
 #define _SPOOLPRINTER_EXT
 #define _RMPRINTER_EXT
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 #include <list>
 
-#ifndef REMOTE_APPSERVER
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -85,44 +82,6 @@
 
 #include <unohelp.hxx>
 
-#else /* REMOTE_APPSERVER */
-
-#include "rvp.hxx"
-#include "rmoutdev.hxx"
-#include "rmwindow.hxx"
-
-struct SalPrinterQueueInfo
-{
-	XubString				maPrinterName;
-	XubString				maDriver;
-	XubString				maLocation;
-	XubString				maComment;
-	ULONG					mnStatus;
-	ULONG					mnJobs;
-	void*					mpSysData;
-
-							SalPrinterQueueInfo();
-							~SalPrinterQueueInfo();
-};
-#include "rmprint.hxx"
-
-#include <vos/mutex.hxx>
-#ifndef _VCL_UNOHELP_HXX
-#include <unohelp.hxx>
-#endif
-
-using namespace com::sun::star::portal::client;
-
-#if OSL_DEBUG_LEVEL > 1
-#ifdef PRODUCT
-#define OSL_DEBUG_LEVEL 0
-#else
-#define OSL_DEBUG_LEVEL 1
-#endif
-#endif
-
-#endif
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -371,27 +330,7 @@ static void ImplInitPrnQueueList()
 
 	pSVData->maGDIData.mpPrinterQueueList = new ImplPrnQueueList;
 
-#ifndef REMOTE_APPSERVER
 	pSVData->mpDefInst->GetPrinterQueueInfo( pSVData->maGDIData.mpPrinterQueueList );
-#else
-    BOOL		bPrinterInfoOk = FALSE;
-    const ULONG nCount = pSVData->mpPrinterEnvironment->Infos.getLength();
-    const RmQueueInfo* pInfos = pSVData->mpPrinterEnvironment->Infos.getConstArray();
-
-    for( ULONG i = 0; i < nCount; i++ )
-    {
-        SalPrinterQueueInfo*		pNewInfo = new SalPrinterQueueInfo;
-
-        pNewInfo->maPrinterName = pInfos[i].PrinterName;
-        pNewInfo->maDriver		= pInfos[i].Driver;
-        pNewInfo->maLocation	= pInfos[i].Location;
-        pNewInfo->maComment 	= pInfos[i].Comment;
-        pNewInfo->mnStatus		= pInfos[i].PrinterStatus;
-        pNewInfo->mnJobs		= pInfos[i].Jobs;
-        pNewInfo->mpSysData 	= NULL;
-        pSVData->maGDIData.mpPrinterQueueList->Add( pNewInfo );
-	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -409,11 +348,7 @@ void ImplDeletePrnQueueList()
 			if ( pInfo->mpQueueInfo )
 				delete pInfo->mpQueueInfo;
 
-#ifndef REMOTE_APPSERVER
 			pSVData->mpDefInst->DeletePrinterQueueInfo( pInfo->mpSalQueueInfo );
-#else
-			delete pInfo->mpSalQueueInfo;
-#endif
 
 			delete pInfo;
 			pInfo = pPrnList->Next();
@@ -457,12 +392,8 @@ const QueueInfo& Printer::GetQueueInfo( 
 
 	ImplPrnQueueData* pInfo = pSVData->maGDIData.mpPrinterQueueList->Get( nQueue );
 
-#ifndef REMOTE_APPSERVER
 	if ( bStatus )
 		pSVData->mpDefInst->GetPrinterQueueState( pInfo->mpSalQueueInfo );
-#else
-	// ???
-#endif
 
 	if ( !pInfo->mpQueueInfo )
 		pInfo->mpQueueInfo = new QueueInfo;
@@ -482,11 +413,7 @@ XubString Printer::GetDefaultPrinterName
 {
 	ImplSVData* pSVData = ImplGetSVData();
 
-#ifndef REMOTE_APPSERVER
 	return pSVData->mpDefInst->GetDefaultPrinter();
-#else
-	return pSVData->mpPrinterEnvironment->DefaultPrinter;
-#endif
 }
 
 // =======================================================================
@@ -524,9 +451,6 @@ void Printer::ImplInitData()
 	else
 		pSVData->maGDIData.mpLastPrinter = this;
 	pSVData->maGDIData.mpFirstPrinter = this;
-#ifdef REMOTE_APPSERVER
-    mpRemotePages = new ::std::vector< PrinterPage* >();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -557,7 +481,6 @@ void Printer::ImplInit( SalPrinterQueueI
 	pJobSetup->maPrinterName = maPrinterName;
 	pJobSetup->maDriver = maDriver;
 
-#ifndef REMOTE_APPSERVER
 	mpInfoPrinter	= pSVData->mpDefInst->CreateInfoPrinter( pInfo, pJobSetup );
 	mpPrinter		= NULL;
 	mpJobPrinter	= NULL;
@@ -576,73 +499,10 @@ void Printer::ImplInit( SalPrinterQueueI
 		ImplInitDisplay( NULL );
 		return;
 	}
-#else
-
-	mpInfoPrinter = new RmPrinter;
-
-	Reference< XRmPrinter > xPrinter;
-
-	if (pSVData->mxClientFactory.is() )
-	{
-        xPrinter = Reference< XRmPrinter >( pSVData->mxClientFactory->createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OfficePrinter.stardiv.de" ) ) ), NMSP_UNO::UNO_QUERY );
-        mpInfoPrinter->SetInterface( xPrinter );
-	}
-
-	if ( ! xPrinter.is() )
-	{
-		delete mpInfoPrinter;
-		mpInfoPrinter = NULL;
-		ImplInitDisplay( NULL );
-		return;
-	}
-	else
-	{
-		QueueInfo				aQInfo;
-		RmJobSetup 				aRmJobSetup;
-		const REF( XRmPrinter )&	rxPrinter = mpInfoPrinter->GetInterface();
-
-        const RmQueueInfo* 		pInfos = pSVData->mpPrinterEnvironment->Infos.getConstArray();
-        const RmQueueInfo* 		pSelectedInfo = NULL;
-        ::rtl::OUString aCompare( maPrinterName );
-        for( int i = 0; i < pSVData->mpPrinterEnvironment->Infos.getLength(); i++ )
-        {
-            if( pInfos[i].PrinterName == aCompare )
-            {
-                pSelectedInfo = pInfos+i;
-                break;
-            }
-        }
-
-        if( pSelectedInfo )
-        {
-            mpInfoPrinter->CreateInfoInstance( *pSelectedInfo, aRmJobSetup );
-            maJobSetup = aRmJobSetup;
-        }
-
-		if( rxPrinter.is() )
-		{
-			mpGraphics = new ImplServerGraphics( pSVData->mpAtoms );
-            REF( XRmOutputDevice ) aTmp( rxPrinter, UNO_QUERY );
-			mpGraphics->SetInterface( aTmp );
-		}
-
-		if( !mpGraphics->GetInterface().is() )
-		{
-			delete mpGraphics, mpGraphics = NULL;
-			delete mpInfoPrinter, mpInfoPrinter = NULL;
-			ImplInitDisplay( NULL );
-			return;
-		}
-		else
-		{
-			ImplGetServerGraphics();
-		}
-	}
-#endif
 
 	// Daten initialisieren
 	ImplUpdatePageData();
-	mpFontList = new ImplDevFontList;
+	mpFontList = new ImplDevFontList();
 	mpFontCache = new ImplFontCache( TRUE );
 	mpGraphics->GetDevFontList( mpFontList );
 }
@@ -666,10 +526,6 @@ void Printer::ImplInitDisplay( const Win
 	mpFontCache 		= pSVData->maGDIData.mpScreenFontCache;
 	mnDPIX				= mpDisplayDev->mnDPIX;
 	mnDPIY				= mpDisplayDev->mnDPIY;
-
-#ifdef REMOTE_APPSERVER
-	mpGraphics			= mpDisplayDev->mpGraphics;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -761,7 +617,6 @@ SalPrinterQueueInfo* Printer::ImplGetQue
 
 void Printer::ImplUpdatePageData()
 {
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !ImplGetGraphics() )
 		return;
@@ -771,15 +626,6 @@ void Printer::ImplUpdatePageData()
 								mnOutWidth, mnOutHeight,
 								maPageOffset.X(), maPageOffset.Y(),
 								maPaperSize.Width(), maPaperSize.Height() );
-#else
-	if ( mpInfoPrinter && mpGraphics )
-	{
-		mpGraphics->GetResolution( mnDPIX, mnDPIY );
-		mpInfoPrinter->GetPageInfo( mnOutWidth, mnOutHeight,
-									maPageOffset.X(), maPageOffset.Y(),
-									maPaperSize.Width(), maPaperSize.Height() );
-	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -869,37 +715,9 @@ Printer::~Printer()
 
     delete mpPrinterOptions;
 
-#ifndef REMOTE_APPSERVER
 	ImplReleaseGraphics();
 	if ( mpInfoPrinter )
 		ImplGetSVData()->mpDefInst->DestroyInfoPrinter( mpInfoPrinter );
-#else
-	if ( mpInfoPrinter )
-	{
-		if( mpGraphics ) {
-           REF( XRmOutputDevice ) aTmp;
-			mpGraphics->SetInterface( aTmp );
-        }
-
-		ImplReleaseServerGraphics();
-
-		if ( mpGetDevFontList )
-		{
-			delete mpGetDevFontList;
-			mpGetDevFontList = NULL;
-		}
-		if ( mpGetDevSizeList )
-		{
-			delete mpGetDevSizeList;
-			mpGetDevSizeList = NULL;
-		}
-		delete mpGraphics, mpGraphics = NULL;
-		delete mpInfoPrinter, mpInfoPrinter = NULL;
-	}
-    for( int i = 0; i < mpRemotePages->size(); i++ )
-        delete (*mpRemotePages)[i];
-    delete mpRemotePages;
-#endif
 	if ( mpDisplayDev )
 		delete mpDisplayDev;
 	else
@@ -944,11 +762,7 @@ ULONG Printer::GetCapabilities( USHORT n
 	if ( IsDisplayPrinter() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	return mpInfoPrinter->GetCapabilities( maJobSetup.ImplGetConstData(), nType );
-#else
-	return mpInfoPrinter->GetCapabilities( nType );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -989,7 +803,6 @@ BOOL Printer::SetJobSetup( const JobSetu
 
 	JobSetup aJobSetup = rSetup;
 
-#ifndef REMOTE_APPSERVER
 	ImplReleaseGraphics();
 	if ( mpInfoPrinter->SetPrinterData( aJobSetup.ImplGetData() ) )
 	{
@@ -1002,55 +815,10 @@ BOOL Printer::SetJobSetup( const JobSetu
 	}
 
 	return FALSE;
-#else
-	if ( mpInfoPrinter )
-	{
-		RmJobSetup aRmJobSetup;
-
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetJobSetup( aRmJobSetup ) )
-		{
-			mbNewJobSetup = TRUE;
-			maJobSetup = aRmJobSetup;
-			ImplUpdatePageData();
-			ImplUpdateFontList();
-			return TRUE;
-		}
-		else
-			return FALSE;
-	}
-	return FALSE;
-#endif
 }
 
 // -----------------------------------------------------------------------
 
-#ifdef REMOTE_APPSERVER
-IMPL_LINK( Printer, UserSetupCompleted, ::com::sun::star::uno::Any*, pResult )
-{
-	::vos::OGuard guard( Application::GetSolarMutex( ) );
-
-	if( pResult->hasValue() )
-	{
-		mbUserSetupResult = TRUE;
-
-		::com::sun::star::portal::client::RmJobSetup aRmJobSetup;
-		*pResult >>= aRmJobSetup;
-		JobSetup aJobSetup;
-        aJobSetup = aRmJobSetup;
-		ImplUpdateJobSetupPaper( aJobSetup );
-		mbNewJobSetup = TRUE;
-		maJobSetup = aJobSetup;
-		ImplUpdatePageData();
-		ImplUpdateFontList();
-	}
-	else
-		mbUserSetupResult = FALSE;
-
-	mbUserSetupCompleted = TRUE;
-	return 0;
-}
-#endif
 
 BOOL Printer::Setup( Window* pWindow )
 {
@@ -1060,7 +828,6 @@ BOOL Printer::Setup( Window* pWindow )
 	if ( IsJobActive() || IsPrinting() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	JobSetup aJobSetup = maJobSetup;
 	SalFrame* pFrame;
 	if ( !pWindow )
@@ -1084,21 +851,6 @@ BOOL Printer::Setup( Window* pWindow )
 		return TRUE;
 	}
 	return FALSE;
-#else
-	RmJobSetup aRmJobSetup;
-    maJobSetup.SetRmJobSetup( aRmJobSetup );
-	mpInfoPrinter->SetJobSetup( aRmJobSetup );
-	RmFrameWindow* pFrame;
-	if ( !pWindow )
-		pFrame = ImplGetDefaultWindow()->ImplGetFrame();
-	else
-		pFrame = pWindow->ImplGetFrame();
-	mbUserSetupCompleted = FALSE;
-	mpInfoPrinter->UserSetup( pFrame->GetFrameInterface(), pFrame->InsertUserEventLink( LINK( this, Printer, UserSetupCompleted ) ) );
-	while( ! mbUserSetupCompleted )
-		Application::Reschedule();
-	return mbUserSetupResult;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1123,22 +875,8 @@ BOOL Printer::SetPrinterProps( const Pri
 		// Alten Printer zerstoeren
 		if ( !IsDisplayPrinter() )
 		{
-#ifndef REMOTE_APPSERVER
 			ImplReleaseGraphics();
 			pSVData->mpDefInst->DestroyInfoPrinter( mpInfoPrinter );
-#else
-			if ( mpInfoPrinter )
-			{
-				if( mpGraphics ) {
-                    REF( XRmOutputDevice ) aTmp;
-					mpGraphics->SetInterface( aTmp );
-                }
-
-				ImplReleaseServerGraphics();
-				delete mpGraphics, mpGraphics = NULL;
-				delete mpInfoPrinter, mpInfoPrinter = NULL;
-			}
-#endif
 			if ( mpFontEntry )
 			{
 				mpFontCache->Release( mpFontEntry );
@@ -1173,9 +911,7 @@ BOOL Printer::SetPrinterProps( const Pri
 	// Alten Printer zerstoeren?
 	if ( GetName() != pPrinter->GetName() )
 	{
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
-#endif
 		if ( mpDisplayDev )
 		{
 			delete mpDisplayDev;
@@ -1183,21 +919,7 @@ BOOL Printer::SetPrinterProps( const Pri
 		}
 		else
 		{
-#ifndef REMOTE_APPSERVER
 			pSVData->mpDefInst->DestroyInfoPrinter( mpInfoPrinter );
-#else
-			if ( mpInfoPrinter )
-			{
-				if( mpGraphics ) {
-                    REF( XRmOutputDevice ) aTmp;
-					mpGraphics->SetInterface( aTmp );
-                }
-
-				ImplReleaseServerGraphics();
-				delete mpGraphics, mpGraphics = NULL;
-				delete mpInfoPrinter, mpInfoPrinter = NULL;
-			}
-#endif
 
 			if ( mpFontEntry )
 			{
@@ -1258,18 +980,10 @@ BOOL Printer::SetOrientation( Orientatio
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_ORIENTATION, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetOrientation( (unsigned short)eOrientation, aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1311,18 +1025,10 @@ BOOL Printer::SetPaperBin( USHORT nPaper
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_PAPERBIN, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetPaperBin( nPaperBin, aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1377,6 +1083,7 @@ void Printer::ImplFindPaperFormatForUser
 								 nPaperWidth,
 								 nPaperHeight ) )
 		{
+			pSetupData->meOrientation = ORIENTATION_PORTRAIT;
 			pSetupData->mePaperFormat = ImplGetPaperFormat( rPaperInfo.m_nPaperWidth*100,
 															rPaperInfo.m_nPaperHeight*100 );
 			break;
@@ -1399,6 +1106,7 @@ void Printer::ImplFindPaperFormatForUser
 									 nPaperHeight,
 									 nPaperWidth ))
 			{
+				pSetupData->meOrientation = ORIENTATION_LANDSCAPE;
 				pSetupData->mePaperFormat = ImplGetPaperFormat( rPaperInfo.m_nPaperWidth*100,
 																rPaperInfo.m_nPaperHeight*100 );
 				break;
@@ -1432,20 +1140,12 @@ BOOL Printer::SetPaper( Paper ePaper )
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		if ( ePaper == PAPER_USER )
 			ImplFindPaperFormatForUserSize( aJobSetup );
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_PAPERSIZE|SAL_JOBSET_ORIENTATION, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetPaper( (unsigned short)ePaper, aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1486,7 +1186,6 @@ BOOL Printer::SetPaperSizeUser( const Si
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		ImplFindPaperFormatForUserSize( aJobSetup );
 
@@ -1494,13 +1193,6 @@ BOOL Printer::SetPaperSizeUser( const Si
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_PAPERSIZE|SAL_JOBSET_ORIENTATION, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-        if ( mpInfoPrinter->SetPaperSizeUser( aPageSize.Width(), aPageSize.Height(), aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1611,14 +1303,7 @@ USHORT Printer::GetPaperBinCount() const
 	if ( IsDisplayPrinter() )
 		return 0;
 
-#ifndef REMOTE_APPSERVER
 	return (USHORT)mpInfoPrinter->GetPaperBinCount( maJobSetup.ImplGetConstData() );
-#else
-	if ( mpInfoPrinter )
-		return mpInfoPrinter->GetPaperBinCount();
-	else
-		return 0;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1628,17 +1313,10 @@ XubString Printer::GetPaperBinName( USHO
 	if ( IsDisplayPrinter() )
 		return ImplGetSVEmptyStr();
 
-#ifndef REMOTE_APPSERVER
 	if ( nPaperBin < GetPaperBinCount() )
 		return mpInfoPrinter->GetPaperBinName( maJobSetup.ImplGetConstData(), nPaperBin );
 	else
 		return ImplGetSVEmptyStr();
-#else
-	if ( mpInfoPrinter )
-		return (String)mpInfoPrinter->GetPaperBinName( nPaperBin );
-	else
-		return ImplGetSVEmptyStr();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1679,7 +1357,6 @@ void Printer::PrintPage()
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 
 ULONG ImplSalPrinterErrorCodeToVCL( ULONG nError )
 {
@@ -1724,10 +1401,6 @@ IMPL_LINK( Printer, ImplDestroyPrinterAs
 
 // -----------------------------------------------------------------------
 
-#endif
-
-// -----------------------------------------------------------------------
-
 BOOL Printer::StartJob( const XubString& rJobName )
 {
 	mnError = PRINTER_OK;
@@ -1738,7 +1411,6 @@ BOOL Printer::StartJob( const XubString&
 	if ( IsJobActive() || IsPrinting() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	ULONG	nCopies = mnCopyCount;
 	BOOL	bCollateCopy = mbCollateCopy;
 	BOOL	bUserCopy = FALSE;
@@ -1836,14 +1508,6 @@ BOOL Printer::StartJob( const XubString&
 			return FALSE;
 		}
 	}
-#else
-    mbNewJobSetup	= FALSE;
-    maJobName		= rJobName;
-    mnCurPage		= 1;
-    mnCurPrintPage	= 1;
-    mbJobActive 	= TRUE;
-    mbPrinting		= TRUE;
-#endif
 
 	return TRUE;
 }
@@ -1859,7 +1523,6 @@ BOOL Printer::EndJob()
 
 	mbJobActive = FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		ImplReleaseGraphics();
@@ -1886,75 +1549,6 @@ BOOL Printer::EndJob()
 
 		return TRUE;
 	}
-#else
-	ImplSVData* pSVData = ImplGetSVData();
-    sal_Bool bResult = sal_False;
-
-    try
-    {
-        mpPrinter = new RmPrinter();
-        mpPrinter->mxRemotePrinter = REF( XRmPrinter )( pSVData->mxClientFactory->createInstance( ::rtl::OUString::createFromAscii( "OfficePrinter.stardiv.de" ) ), NMSP_UNO::UNO_QUERY );
-        RmJobSetup aRmJobSetup;
-        maJobSetup.SetRmJobSetup( aRmJobSetup );
-        mpPrinter->CreatePrintInstance( aRmJobSetup );
-        if( mpPrinter->mxRemotePrinter.is() )
-        {
-            RmPageRequestor* pRequestor = new RmPageRequestor( this );
-            Reference< XRmPageRequestor > xReq( pRequestor );
-            CHECK_FOR_RVPSYNC_NORMAL();
-            bResult = mpPrinter->mxRemotePrinter->StartJob( mnCopyCount,
-                                                            mbCollateCopy,
-                                                            maJobName,
-                                                            maPrintFile,
-                                                            mbPrintFile,
-                                                            mpRemotePages->size(),
-                                                            xReq );
-            if( bResult )
-                do Application::Reschedule(); while( mbPrinting && ! pRequestor->isCompleted() );
-        }
-    }
-    catch( RuntimeException &e )
-    {
-        rvpExceptionHandler();
-        bResult = FALSE;
-        if( mpPrinter )
-        {
-            delete mpPrinter;
-            mpPrinter = NULL;
-        }
-    }
-
-    for( int i = 0; i < mpRemotePages->size(); i++ )
-        delete (*mpRemotePages)[i];
-    *mpRemotePages = ::std::vector< PrinterPage* >();
-
-	if ( mpPrinter )
-	{
-        if( bResult )
-        {
-            CHECK_FOR_RVPSYNC_NORMAL();
-            try
-            {
-                mpPrinter->mxRemotePrinter->EndJob( vcl::unohelper::GetMultiServiceFactory() );
-            }
-            catch( RuntimeException &e )
-            {
-                rvpExceptionHandler();
-            }
-        }
-		mbPrinting = FALSE;
-        mbDevOutput = FALSE;
-		mnCurPage = 0;
-		mnCurPrintPage = 0;
-		maJobName.Erase();
-		EndPrint();
-
-		delete mpPrinter;
-		mpPrinter = NULL;
-
-		return bResult;
-	}
-#endif
 
 	return FALSE;
 }
@@ -1972,7 +1566,6 @@ BOOL Printer::AbortJob()
 	mbInPrintPage	= FALSE;
 	mpJobGraphics	= NULL;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		mbPrinting		= FALSE;
@@ -2005,33 +1598,6 @@ BOOL Printer::AbortJob()
 
 		return TRUE;
 	}
-#else
-    mbPrinting		= FALSE;
-    mbDevOutput		= FALSE;
-    mnCurPage		= 0;
-    mnCurPrintPage	= 0;
-    maJobName.Erase();
-    if( mpPrinter )
-    {
-        if( mpPrinter->mxRemotePrinter.is() )
-        {
-            CHECK_FOR_RVPSYNC_NORMAL();
-            try
-            {
-                mpPrinter->mxRemotePrinter->AbortJob();
-            }
-            catch( RuntimeException &e )
-            {
-                rvpExceptionHandler();
-            }
-        }
-        delete mpPrinter;
-        mpPrinter = NULL;
-    }
-    EndPrint();
-
-    return TRUE;
-#endif
 
 	return FALSE;
 }
@@ -2043,7 +1609,6 @@ BOOL Printer::StartPage()
 	if ( !IsJobActive() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		if ( mpPrinter )
@@ -2083,18 +1648,6 @@ BOOL Printer::StartPage()
 
 		return TRUE;
 	}
-#else
-		mpQMtf = new GDIMetaFile;
-		mpQMtf->Record( this );
-		mpQMtf->SaveStatus();
-
-		mbInPrintPage = TRUE;
-		mnCurPage++;
-		mnCurPrintPage++;
-		PrintPage();
-
-		return TRUE;
-#endif
 
 	return FALSE;
 }
@@ -2108,7 +1661,6 @@ BOOL Printer::EndPage()
 
 	mbInPrintPage = FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		if ( mpPrinter )
@@ -2132,109 +1684,6 @@ BOOL Printer::EndPage()
 
 		return TRUE;
 	}
-#else
-    mpQMtf->Stop();
-    mpQMtf->WindStart();
-    mpRemotePages->push_back( new PrinterPage( mpQMtf, mbNewJobSetup, GetJobSetup() ) );
-    mpQMtf = NULL;
-    mbNewJobSetup = FALSE;
-
-    return TRUE;
-#endif
 
 	return FALSE;
 }
-
-#ifdef REMOTE_APPSERVER
-void Printer::GetRemotePageSetup( ULONG nPage, RmJobSetup& rSetup )
-{
-    if( nPage < mpRemotePages->size() )
-        (*mpRemotePages)[nPage]->GetJobSetup().SetRmJobSetup( rSetup );
-}
-
-void Printer::PrintRemotePage( ULONG nPage )
-{
-#if OSL_DEBUG_LEVEL > 1
-    fprintf( stderr, "printing page %d of %d\n", nPage, mpRemotePages->size() );
-#endif
-	if ( mpPrinter && mpPrinter->mxRemotePrinter.is() )
-	{
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "have printer\n", nPage );
-#endif
-        if( nPage >=  mpRemotePages->size() )
-        {
-            try
-            {
-                CHECK_FOR_RVPSYNC_NORMAL();
-                mpPrinter->mxRemotePrinter->StartPage();
-                CHECK_FOR_RVPSYNC_NORMAL();
-                mpPrinter->mxRemotePrinter->EndPage();
-            }
-            catch( RuntimeException &e )
-            {
-                rvpExceptionHandler();
-            }
-            return;
-        }
-
-        if( mpGraphics ) {
-            REF( XRmOutputDevice ) aTmp;
-            mpGraphics->SetInterface( aTmp );
-            delete mpGraphics;
-        }
-
-        PrinterPage* pPage = (*mpRemotePages)[nPage];
-
-		CHECK_FOR_RVPSYNC_NORMAL();
-        try
-        {
-            mpPrinter->mxRemotePrinter->StartPage();
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page started\n" );
-#endif
-        }
-        catch( RuntimeException &e )
-        {
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page started exception\n" );
-#endif
-            rvpExceptionHandler();
-        }
-
-        mpGraphics = new ImplServerGraphics( ImplGetSVData()->mpAtoms );
-		Reference< XRmOutputDevice > temp( mpPrinter->mxRemotePrinter, UNO_QUERY );
-        mpGraphics->SetInterface( temp );
-
-        mbDevOutput		= TRUE;
-		mbInPrintPage	= TRUE;
-		mnCurPage		= nPage;
-		mnCurPrintPage	= nPage;
-
-        pPage->GetGDIMetaFile()->WindStart();
-        pPage->GetGDIMetaFile()->Play( this );
-
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "metafile played %d actions\n", pPage->GetGDIMetaFile()->GetActionCount() );
-#endif
-
-		CHECK_FOR_RVPSYNC_NORMAL();
-        try
-        {
-		    mpPrinter->mxRemotePrinter->EndPage();
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page ended\n" );
-#endif
-        }
-        catch( RuntimeException &e )
-        {
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page ended exception\n" );
-#endif
-            rvpExceptionHandler();
-        }
-        mbDevOutput = FALSE;
-		mbNewJobSetup = FALSE;
-	}
-}
-#endif
Index: vcl/source/gdi/print2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/print2.cxx,v
retrieving revision 1.17.82.1
retrieving revision 1.19
diff -u -p -u -r1.17.82.1 -r1.19
--- vcl/source/gdi/print2.cxx	9 Jan 2004 18:13:47 -0000	1.17.82.1
+++ vcl/source/gdi/print2.cxx	6 Jan 2004 13:53:54 -0000	1.19
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_PRINT_CXX
 #define _SPOOLPRINTER_EXT
 
 #include <functional>
@@ -604,9 +603,6 @@ struct ConnectedComponents
 typedef ::std::list< ConnectedComponents > ConnectedComponentsList;	
 
 // remove comment to enable highlighting of generated output
-#ifdef DBG_UTIL
-//#define DEBUG_GetPreparedMetaFile
-#endif
 
 void Printer::GetPreparedMetaFile( const GDIMetaFile& rInMtf, GDIMetaFile& rOutMtf, 
                                    long nMaxBmpDPIX, long nMaxBmpDPIY )
@@ -1041,10 +1037,6 @@ void Printer::GetPreparedMetaFile( const
                                                                       aBandBmp, nMaxBmpDPIX, nMaxBmpDPIY );
                                     }
 
-#ifdef DEBUG_GetPreparedMetaFile
-                                    //aBandBmp.Invert();
-#endif
-
                                     rOutMtf.AddAction( new MetaCommentAction( "PRNSPOOL_TRANSPARENTBITMAP_BEGIN" ) );
                                     rOutMtf.AddAction( new MetaBmpScaleAction( aDstPtPix, aDstSzPix, aBandBmp ) );
                                     rOutMtf.AddAction( new MetaCommentAction( "PRNSPOOL_TRANSPARENTBITMAP_END" ) );
@@ -1140,20 +1132,6 @@ void Printer::GetPreparedMetaFile( const
 
         rOutMtf.SetPrefMapMode( rInMtf.GetPrefMapMode() );
         rOutMtf.SetPrefSize( rInMtf.GetPrefSize() );
-
-#ifdef DEBUG_GetPreparedMetaFile
-        // iterate over all aCCList members and generate rectangles for the bounding boxes
-        rOutMtf.AddAction( new MetaFillColorAction( COL_WHITE, FALSE ) );
-        for( aCurr = aCCList.begin(); aCurr != aLast; ++aCurr )
-        {
-            if( aCurr->bIsSpecial )
-                rOutMtf.AddAction( new MetaLineColorAction( COL_RED, TRUE) );
-            else
-                rOutMtf.AddAction( new MetaLineColorAction( COL_BLUE, TRUE) );
-
-            rOutMtf.AddAction( new MetaRectAction( aMapModeVDev.PixelToLogic( aCurr->aBounds ) ) );
-        }
-#endif
 	}
 }
 
Index: vcl/source/gdi/regband.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/regband.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/regband.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/regband.cxx	6 Jan 2004 13:54:21 -0000	1.2
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_REGBAND_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -633,7 +631,6 @@ void ImplRegionBand::XOr( long nXLeft, l
 		//	 -> reduce boundaries of new separation
 		if ( (nXLeft <= pSep->mnXLeft) && (nXRight >= pSep->mnXRight) )
 		{
-			int iOldXRight = pSep->mnXRight;
 			pSep->mnXRight = pSep->mnXLeft;
 			pSep->mnXLeft = nXLeft;
 			nXLeft = pSep->mnXRight;
@@ -644,7 +641,6 @@ void ImplRegionBand::XOr( long nXLeft, l
 		//	 -> set boundaries of new separation to right remainder
 		if ( (nXRight >= pSep->mnXLeft) && (nXLeft <= pSep->mnXLeft) )
 		{
-			int iOldXRight = pSep->mnXRight;
 			pSep->mnXRight = pSep->mnXLeft;
 			pSep->mnXLeft = nXLeft;
 			nXLeft = pSep->mnXRight;
Index: vcl/source/gdi/region.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/region.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/gdi/region.cxx	30 Sep 2002 17:28:03 -0000	1.3
+++ vcl/source/gdi/region.cxx	4 Feb 2004 14:42:24 -0000	1.6
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_REGION_CXX
-
 #include <limits.h>
 
 #ifndef _VCOMPAT_HXX
@@ -2202,49 +2200,6 @@ SvStream& operator<<( SvStream& rOStrm, 
 
 // -----------------------------------------------------------------------
 
-RegionOverlapType Region::GetOverlapType( const Rectangle& rRect ) const
-{
-	DBG_CHKTHIS( Region, ImplDbgTestRegion );
-
-	// is rectangle empty? -> not inside
-	if ( rRect.IsEmpty() )
-		return REGION_OUTSIDE;
-
-	((Region*)this)->ImplPolyPolyRegionToBandRegion();
-
-	// no instance data? -> not inside
-	if ( (mpImplRegion == &aImplEmptyRegion) || (mpImplRegion == &aImplNullRegion) )
-		return REGION_OUTSIDE;
-
-	// resolve pointer
-	ImplRegionBand* 	pBand	= mpImplRegion->mpFirstBand;
-	ImplRegionBandSep*	pSep	= pBand->mpFirstSep;
-
-	// complex region? don't check for now. This may change in the future...
-	if ( pBand->mpNextBand || pSep->mpNextSep )
-		return REGION_OVER;
-
-	// get justified rectangle
-	long nLeft		= Min( rRect.Left(), rRect.Right() );
-	long nTop		= Min( rRect.Top(), rRect.Bottom() );
-	long nRight 	= Max( rRect.Left(), rRect.Right() );
-	long nBottom	= Max( rRect.Top(), rRect.Bottom() );
-
-	// check rectangle region
-	BOOL boLeft   = (nLeft >= pSep->mnXLeft) && (nLeft < pSep->mnXRight);
-	BOOL boRight  = (nRight <= pSep->mnXRight) && (nRight > pSep->mnXLeft);
-	BOOL boTop	  = (nTop >= pBand->mnYTop) && (nTop < pBand->mnYBottom);
-	BOOL boBottom = (nBottom <= pBand->mnYBottom) && (nBottom > pBand->mnYTop);
-	if ( boLeft && boRight && boTop && boBottom )
-		return REGION_INSIDE;
-	if ( boLeft || boRight || boTop || boBottom )
-		return REGION_OVER;
-
-	return REGION_OUTSIDE;
-}
-
-// -----------------------------------------------------------------------
-
 void Region::ImplBeginAddRect()
 {
 	DBG_CHKTHIS( Region, ImplDbgTestRegion );
@@ -2440,13 +2395,13 @@ RegionHandle Region::BeginEnumRects()
 
 	// no internal data? -> region is empty!
 	if ( (mpImplRegion == &aImplEmptyRegion) || (mpImplRegion == &aImplNullRegion) )
-		return NULL;
+		return 0;
 
 	// no band in the list? -> region is empty!
 	if ( mpImplRegion->mpFirstBand == NULL )
 	{
 		DBG_ASSERT( mpImplRegion->mpFirstBand, "Region::BeginEnumRects() First Band is Empty!" );
-		return NULL;
+		return 0;
 	}
 
 	ImplRegionHandle* pData = new ImplRegionHandle;
Index: vcl/source/gdi/salgdilayout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/salgdilayout.cxx,v
retrieving revision 1.12
retrieving revision 1.17
diff -u -p -u -r1.12 -r1.17
--- vcl/source/gdi/salgdilayout.cxx	27 Mar 2003 17:58:03 -0000	1.12
+++ vcl/source/gdi/salgdilayout.cxx	10 May 2004 15:49:10 -0000	1.17
@@ -59,15 +59,11 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
 #include <tools/ref.hxx>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
@@ -80,11 +76,6 @@
 #ifndef _SV_SALPRN_HXX
 #include <salprn.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -95,7 +86,7 @@
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_REGION_HXX
@@ -149,9 +140,9 @@
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif
+#undef private
 
-#define IS_NOTRTL_ENABLED() ( pOutDev && !pOutDev->IsRTLEnabled() )
-
+//#define USE_NEW_RTL_IMPLEMENTATION
 
 // ----------------------------------------------------------------------------
 // The only common SalFrame method
@@ -174,68 +165,80 @@ SalFrameGeometry SalFrame::GetGeometry()
 
 // ----------------------------------------------------------------------------
 
-SalGraphicsLayout::SalGraphicsLayout() : SalGraphics()
+SalGraphics::SalGraphics() 
+        : m_nLayout( 0 )
 {
     // read global RTL settings
     if( Application::GetSettings().GetLayoutRTL() )
-	    mnLayout = SAL_LAYOUT_BIDI_RTL;
-    else
-        mnLayout = 0;
+	    m_nLayout = SAL_LAYOUT_BIDI_RTL;
 }
 
-SalGraphicsLayout::~SalGraphicsLayout()
+SalGraphics::~SalGraphics()
 {
 }
 
 // ----------------------------------------------------------------------------
 
-void SalGraphicsLayout::mirror( long& x, const OutputDevice *pOutDev )
+void SalGraphics::mirror( long& x, const OutputDevice *pOutDev )
 {
 	long w;
-    if( pOutDev && pOutDev->meOutDevType == OUTDEV_VIRDEV )
-        w = pOutDev->mnOutWidth;
+    if( pOutDev && pOutDev->GetOutDevType() == OUTDEV_VIRDEV )
+        w = pOutDev->GetOutputWidthPixel();
     else
         w = GetGraphicsWidth();
 
 	if( w )
     {
-		x = w-1-x;
-
         if( pOutDev && !pOutDev->IsRTLEnabled() )
         {
+            OutputDevice *pOutDevRef = (OutputDevice*) pOutDev;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            if( pOutDev->meOutDevType == OUTDEV_WINDOW )
+                pOutDevRef = (OutputDevice*) ((Window *) pOutDev)->mpDummy4; // top of non-mirroring hierarchy
+#endif
+
             // mirror this window back
-            long devX = w-pOutDev->mnOutWidth-pOutDev->mnOutOffX;   // re-mirrored mnOutOffX
-            x = devX + ( pOutDev->mnOutWidth - 1 - (x - devX) ) ;
+            long devX = w-pOutDevRef->GetOutputWidthPixel()-pOutDevRef->GetOutOffXPixel();   // re-mirrored mnOutOffX
+            x = devX + (x - pOutDevRef->GetOutOffXPixel());
         }
+        else
+		    x = w-1-x;
     }
 }
 
-void SalGraphicsLayout::mirror( long& x, long& nWidth, const OutputDevice *pOutDev )
+void SalGraphics::mirror( long& x, long& nWidth, const OutputDevice *pOutDev )
 {
 	long w;
-    if( pOutDev && pOutDev->meOutDevType == OUTDEV_VIRDEV )
-        w = pOutDev->mnOutWidth;
+    if( pOutDev && pOutDev->GetOutDevType() == OUTDEV_VIRDEV )
+        w = pOutDev->GetOutputWidthPixel();
     else
         w = GetGraphicsWidth();
 
 	if( w )
     {
-		x = w-nWidth-x;
-
         if( pOutDev && !pOutDev->IsRTLEnabled() )
         {
+            OutputDevice *pOutDevRef = (OutputDevice*) pOutDev;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            if( pOutDev->meOutDevType == OUTDEV_WINDOW )
+                pOutDevRef = (OutputDevice*) ((Window *) pOutDev)->mpDummy4; // top of non-mirroring hierarchy
+#endif
+
             // mirror this window back
-            long devX = w-pOutDev->mnOutWidth-pOutDev->mnOutOffX;   // re-mirrored mnOutOffX
-            x = devX + ( pOutDev->mnOutWidth - nWidth - (x - devX) ) ;
+            long devX = w-pOutDevRef->GetOutputWidthPixel()-pOutDevRef->GetOutOffXPixel();   // re-mirrored mnOutOffX
+            x = devX + (x - pOutDevRef->GetOutOffXPixel());
         }
+        else
+		    x = w-nWidth-x;
+
     }
 }
 
-BOOL SalGraphicsLayout::mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev )
+BOOL SalGraphics::mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev )
 {
 	long w;
-    if( pOutDev && pOutDev->meOutDevType == OUTDEV_VIRDEV )
-        w = pOutDev->mnOutWidth;
+    if( pOutDev && pOutDev->GetOutDevType() == OUTDEV_VIRDEV )
+        w = pOutDev->GetOutputWidthPixel();
     else
         w = GetGraphicsWidth();
 
@@ -245,12 +248,19 @@ BOOL SalGraphicsLayout::mirror( sal_uInt
 
         if( pOutDev && !pOutDev->IsRTLEnabled() )
         {
+            OutputDevice *pOutDevRef = (OutputDevice*) pOutDev;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            if( pOutDev->meOutDevType == OUTDEV_WINDOW )
+                pOutDevRef = (OutputDevice*) ((Window *) pOutDev)->mpDummy4; // top of non-mirroring hierarchy
+#endif
+
             // mirror this window back
-            long devX = w-pOutDev->mnOutWidth-pOutDev->mnOutOffX;   // re-mirrored mnOutOffX
+            long devX = w-pOutDevRef->GetOutputWidthPixel()-pOutDevRef->GetOutOffXPixel();   // re-mirrored mnOutOffX
 		    for( i=0, j=nPoints-1; i<nPoints; i++,j-- )
 		    {
-			    long x = w-1-pPtAry[i].mnX;
-			    pPtAry2[j].mnX = devX + ( pOutDev->mnOutWidth - 1 - (x - devX) );
+			    //long x = w-1-pPtAry[i].mnX;
+			    //pPtAry2[j].mnX = devX + ( pOutDevRef->mnOutWidth - 1 - (x - devX) );
+			    pPtAry2[j].mnX = devX + (pPtAry[i].mnX - pOutDevRef->GetOutOffXPixel());
 			    pPtAry2[j].mnY = pPtAry[i].mnY;
 		    }
         }
@@ -268,69 +278,81 @@ BOOL SalGraphicsLayout::mirror( sal_uInt
 		return FALSE;
 }
 
+void SalGraphics::mirror( Region& rRgn, const OutputDevice *pOutDev )
+{
+    // mirror the bounding rect and move Region by resulting offset
+    Rectangle aRect( rRgn.GetBoundRect() );
+    long nWidth = aRect.GetWidth();
+    long x      = aRect.Left();
+    long x_org = x;
+
+    mirror( x, nWidth, pOutDev );
+    rRgn.Move( x - x_org, 0 );
+}
+
 // ----------------------------------------------------------------------------
 
-BOOL	SalGraphicsLayout::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
+BOOL	SalGraphics::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	return SalGraphics::UnionClipRegion( nX, nY, nWidth, nHeight, NULL );
+	return unionClipRegion( nX, nY, nWidth, nHeight );
 }
 
-void	SalGraphicsLayout::DrawPixel( long nX, long nY, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPixel( long nX, long nY, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, pOutDev );
-	SalGraphics::DrawPixel( nX, nY, NULL );
+	drawPixel( nX, nY );
 }
-void	SalGraphicsLayout::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, pOutDev );
-	SalGraphics::DrawPixel( nX, nY, nSalColor, NULL );
+	drawPixel( nX, nY, nSalColor );
 }
-void	SalGraphicsLayout::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev )
+void	SalGraphics::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		mirror( nX1, pOutDev );
 		mirror( nX2, pOutDev );
 	}
-	SalGraphics::DrawLine( nX1, nY1, nX2, nY2, NULL );
+	drawLine( nX1, nY1, nX2, nY2 );
 }
-void	SalGraphicsLayout::DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
+void	SalGraphics::DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	SalGraphics::DrawRect( nX, nY, nWidth, nHeight, NULL );
+	drawRect( nX, nY, nWidth, nHeight );
 }
-void	SalGraphicsLayout::DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalPoint* pPtAry2 = new SalPoint[nPoints];
 		BOOL bCopied = mirror( nPoints, pPtAry, pPtAry2, pOutDev ); 
-		SalGraphics::DrawPolyLine( nPoints, bCopied ? pPtAry2 : pPtAry, NULL );
+		drawPolyLine( nPoints, bCopied ? pPtAry2 : pPtAry );
 		delete [] pPtAry2;
 	}
 	else
-		SalGraphics::DrawPolyLine( nPoints, pPtAry, NULL );
+		drawPolyLine( nPoints, pPtAry );
 }
-void	SalGraphicsLayout::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalPoint* pPtAry2 = new SalPoint[nPoints];
 		BOOL bCopied = mirror( nPoints, pPtAry, pPtAry2, pOutDev ); 
-		SalGraphics::DrawPolygon( nPoints, bCopied ? pPtAry2 : pPtAry, NULL );
+		drawPolygon( nPoints, bCopied ? pPtAry2 : pPtAry );
 		delete [] pPtAry2;
 	}
 	else
-		SalGraphics::DrawPolygon( nPoints, pPtAry, NULL );
+		drawPolygon( nPoints, pPtAry );
 }
-void	SalGraphicsLayout::DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
         // TODO: optimize, reduce new/delete calls
         SalPoint **pPtAry2 = new SalPoint*[nPoly];
@@ -339,148 +361,213 @@ void	SalGraphicsLayout::DrawPolyPolygon(
         {
             ULONG nPoints = pPoints[i];
             pPtAry2[i] = new SalPoint[ nPoints ];
-		    BOOL bCopied = mirror( nPoints, pPtAry[i], pPtAry2[i], pOutDev ); 
+		    mirror( nPoints, pPtAry[i], pPtAry2[i], pOutDev ); 
         }
 
-        SalGraphics::DrawPolyPolygon( nPoly, pPoints, (PCONSTSALPOINT*)pPtAry2, NULL );
+        drawPolyPolygon( nPoly, pPoints, (PCONSTSALPOINT*)pPtAry2 );
 
         for(i=0; i<nPoly; i++)
             delete [] pPtAry2[i];
         delete [] pPtAry2;
     }
     else
-	    SalGraphics::DrawPolyPolygon( nPoly, pPoints, pPtAry, NULL );
+	    drawPolyPolygon( nPoly, pPoints, pPtAry );
 }
-sal_Bool SalGraphicsLayout::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
+sal_Bool SalGraphics::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
 {
-    DBG_ASSERT( !(mnLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyLineBezier - no mirroring implemented"); 
-    return SalGraphics::DrawPolyLineBezier( nPoints, pPtAry, pFlgAry, NULL );
+    DBG_ASSERT( !(m_nLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyLineBezier - no mirroring implemented"); 
+    return drawPolyLineBezier( nPoints, pPtAry, pFlgAry );
 }
-sal_Bool SalGraphicsLayout::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
+sal_Bool SalGraphics::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
 {
-    DBG_ASSERT( !(mnLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolygonBezier - no mirroring implemented"); 
-    return SalGraphics::DrawPolygonBezier( nPoints, pPtAry, pFlgAry, NULL );
+    DBG_ASSERT( !(m_nLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolygonBezier - no mirroring implemented"); 
+    return drawPolygonBezier( nPoints, pPtAry, pFlgAry );
 }
-sal_Bool SalGraphicsLayout::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+sal_Bool SalGraphics::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
                                                    const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice *pOutDev )
 {
-    DBG_ASSERT( !(mnLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyPolygonBezier - no mirroring implemented"); 
-    return SalGraphics::DrawPolyPolygonBezier( nPoly, pPoints, pPtAry, pFlgAry, NULL );
+    DBG_ASSERT( !(m_nLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyPolygonBezier - no mirroring implemented"); 
+    return drawPolyPolygonBezier( nPoly, pPoints, pPtAry, pFlgAry );
 }
-void	SalGraphicsLayout::CopyArea( long nDestX, long nDestY,
-								  long nSrcX, long nSrcY,
-								  long nSrcWidth, long nSrcHeight,
-								  USHORT nFlags, const OutputDevice *pOutDev )
+void	SalGraphics::CopyArea( long nDestX, long nDestY,
+                               long nSrcX, long nSrcY,
+                               long nSrcWidth, long nSrcHeight,
+                               USHORT nFlags, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		mirror( nDestX, nSrcWidth, pOutDev );
 		mirror( nSrcX, nSrcWidth, pOutDev );
 	}
-	SalGraphics::CopyArea( nDestX, nDestY, nSrcX, nSrcY, nSrcWidth, nSrcHeight, nFlags, NULL );
+	copyArea( nDestX, nDestY, nSrcX, nSrcY, nSrcWidth, nSrcHeight, nFlags );
 }
-void	SalGraphicsLayout::CopyBits( const SalTwoRect* pPosAry,
-								  SalGraphics* pSrcGraphics, const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev )
+void	SalGraphics::CopyBits( const SalTwoRect* pPosAry,
+                               SalGraphics* pSrcGraphics, const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev )
 {
-	if( ( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) || 
+	if( ( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) || 
         (pSrcGraphics && (pSrcGraphics->GetLayout() & SAL_LAYOUT_BIDI_RTL) ) )
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		if( pSrcGraphics && (pSrcGraphics->GetLayout() & SAL_LAYOUT_BIDI_RTL) )
 			mirror( pPosAry2.mnSrcX, pPosAry2.mnSrcWidth, pSrcOutDev ); 
-		if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+		if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 			mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::CopyBits( &pPosAry2, pSrcGraphics, NULL, NULL );
+		copyBits( &pPosAry2, pSrcGraphics );
 	}
 	else
-		SalGraphics::CopyBits( pPosAry, pSrcGraphics, NULL, NULL );
+		copyBits( pPosAry, pSrcGraphics );
 }
-void	SalGraphicsLayout::DrawBitmap( const SalTwoRect* pPosAry,
+void	SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
 									const SalBitmap& rSalBitmap, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawBitmap( &pPosAry2, rSalBitmap, NULL );
+		drawBitmap( &pPosAry2, rSalBitmap );
 	}
 	else
-		SalGraphics::DrawBitmap( pPosAry, rSalBitmap, NULL );
+		drawBitmap( pPosAry, rSalBitmap );
 }
-void	SalGraphicsLayout::DrawBitmap( const SalTwoRect* pPosAry,
+void	SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
 									const SalBitmap& rSalBitmap,
 									SalColor nTransparentColor, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawBitmap( &pPosAry2, rSalBitmap, nTransparentColor, NULL );
+		drawBitmap( &pPosAry2, rSalBitmap, nTransparentColor );
 	}
 	else
-		SalGraphics::DrawBitmap( pPosAry, rSalBitmap, nTransparentColor, NULL );
+		drawBitmap( pPosAry, rSalBitmap, nTransparentColor );
 }
-void SalGraphicsLayout::DrawBitmap( const SalTwoRect* pPosAry,
-									const SalBitmap& rSalBitmap,
-									const SalBitmap& rTransparentBitmap, const OutputDevice *pOutDev )
+void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
+                              const SalBitmap& rSalBitmap,
+                              const SalBitmap& rTransparentBitmap, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawBitmap( &pPosAry2, rSalBitmap, rTransparentBitmap, NULL );
+		drawBitmap( &pPosAry2, rSalBitmap, rTransparentBitmap );
 	}
 	else
-		SalGraphics::DrawBitmap( pPosAry, rSalBitmap, rTransparentBitmap, NULL );
+		drawBitmap( pPosAry, rSalBitmap, rTransparentBitmap );
 }
-void	SalGraphicsLayout::DrawMask( const SalTwoRect* pPosAry,
+void	SalGraphics::DrawMask( const SalTwoRect* pPosAry,
 								  const SalBitmap& rSalBitmap,
 								  SalColor nMaskColor, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawMask( &pPosAry2, rSalBitmap, nMaskColor, NULL );
+		drawMask( &pPosAry2, rSalBitmap, nMaskColor );
 	}
 	else
-		SalGraphics::DrawMask( pPosAry, rSalBitmap, nMaskColor, NULL );
+		drawMask( pPosAry, rSalBitmap, nMaskColor );
 }
-SalBitmap*	SalGraphicsLayout::GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
+SalBitmap*	SalGraphics::GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	return SalGraphics::GetBitmap( nX, nY, nWidth, nHeight, NULL );
+	return getBitmap( nX, nY, nWidth, nHeight );
 }
-SalColor	SalGraphicsLayout::GetPixel( long nX, long nY, const OutputDevice *pOutDev )
+SalColor	SalGraphics::GetPixel( long nX, long nY, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, pOutDev );
-	return SalGraphics::GetPixel( nX, nY, NULL );
+	return getPixel( nX, nY );
 }
-void	SalGraphicsLayout::Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev )
+void	SalGraphics::Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	SalGraphics::Invert( nX, nY, nWidth, nHeight, nFlags, NULL );
+	invert( nX, nY, nWidth, nHeight, nFlags );
 }
-void	SalGraphicsLayout::Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev )
+void	SalGraphics::Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalPoint* pPtAry2 = new SalPoint[nPoints];
 		BOOL bCopied = mirror( nPoints, pPtAry, pPtAry2, pOutDev ); 
-		SalGraphics::Invert( nPoints, bCopied ? pPtAry2 : pPtAry, nFlags, NULL );
+		invert( nPoints, bCopied ? pPtAry2 : pPtAry, nFlags );
 		delete [] pPtAry2;
 	}
 	else
-		SalGraphics::Invert( nPoints, pPtAry, nFlags, NULL );
+		invert( nPoints, pPtAry, nFlags );
 }
 
-BOOL	SalGraphicsLayout::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev )
+BOOL	SalGraphics::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	return SalGraphics::DrawEPS( nX, nY, nWidth, nHeight,  pPtr, nSize, NULL );
+	return drawEPS( nX, nY, nWidth, nHeight,  pPtr, nSize );
 }
 
+BOOL SalGraphics::HitTestNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                const Point& aPos, SalControlHandle& rControlHandle, BOOL& rIsInside, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Point pt( aPos );
+        Region rgn( rControlRegion );
+        mirror( pt.X(), pOutDev );
+        mirror( rgn, pOutDev );
+        return hitTestNativeControl( nType, nPart, rgn, pt, rControlHandle, rIsInside );
+    }
+    else
+        return hitTestNativeControl( nType, nPart, rControlRegion, aPos, rControlHandle, rIsInside );
+}
+
+BOOL SalGraphics::DrawNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+                                                OUString aCaption, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        return drawNativeControl( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption );
+    }
+    else
+        return drawNativeControl( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+}
+
+BOOL SalGraphics::DrawNativeControlText( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                ControlState nState, const ImplControlValue& aValue,
+                                                SalControlHandle& rControlHandle, OUString aCaption, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        return drawNativeControlText( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption );
+    }
+    else
+        return drawNativeControlText( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+}
+
+BOOL SalGraphics::GetNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
+                                                const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption,
+                                                Region &rNativeBoundingRegion, Region &rNativeContentRegion, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        if( getNativeControlRegion( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption, 
+                                                rNativeBoundingRegion, rNativeContentRegion ) )
+        {
+            mirror( rNativeBoundingRegion, pOutDev );
+            mirror( rNativeContentRegion, pOutDev );
+            return TRUE;
+        }
+        else
+            return FALSE;
+    }
+    else
+        return getNativeControlRegion( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, 
+                                                rNativeBoundingRegion, rNativeContentRegion );
+}
Index: vcl/source/gdi/sallayout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/sallayout.cxx,v
retrieving revision 1.46.10.6
retrieving revision 1.58
diff -u -p -u -r1.46.10.6 -r1.58
--- vcl/source/gdi/sallayout.cxx	7 Apr 2004 11:02:20 -0000	1.46.10.6
+++ vcl/source/gdi/sallayout.cxx	17 Jun 2004 12:20:59 -0000	1.58
@@ -60,41 +60,37 @@
  ************************************************************************/
 
 #include <cstdio>
+
+#define _USE_MATH_DEFINES
 #include <math.h>
 
 #if defined(WIN32)
 #define M_PI 3.1415926536
 #include <malloc.h>
 #define alloca _alloca
-#elif defined(SOLARIS) || defined(IRIX)
-#include <alloca.h>
+#elif defined(SOLARIS) || defined(IRIX)  
+  #include <alloca.h>
+#else
+#ifndef MACOSX
+  #include <malloc.h>
+#endif
 #endif
 
-//#define _SV_OUTDEV_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif // REMOTE_APPSERVER
 
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif // _SV_SALLAYOUT_HXX
 
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
-#endif // _SV_POLY_HXX
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 
 #include <tools/lang.hxx>
 
@@ -133,13 +125,14 @@ sal_Unicode GetVerticalChar( sal_Unicode
 {
     return 0; // #i14788# input method is responsible vertical char changes
  
-    int nVert = 0;
+	int nVert = 0;
     switch( nChar )
     {
         // #104627# special treatment for some unicodes
         case 0x002C: nVert = 0x3001; break;
         case 0x002E: nVert = 0x3002; break;
-#if 0   // to few fonts have the compatibility forms, using
+		/*
+		// to few fonts have the compatibility forms, using
         // them will then cause more trouble than good
         // TODO: decide on a font specific basis
         case 0x2018: nVert = 0xFE41; break;
@@ -167,7 +160,7 @@ sal_Unicode GetVerticalChar( sal_Unicode
         case 0x300D: nVert = 0xFE42; break;
         case 0x300E: nVert = 0xFE43; break;
         case 0x300F: nVert = 0xFE44; break;
-#endif
+		*/
     }
 
     return nVert;
@@ -440,13 +433,14 @@ bool ImplLayoutRuns::GetRun( int* nMinRu
 
 ImplLayoutArgs::ImplLayoutArgs( const xub_Unicode* pStr, int nLength,
     int nMinCharPos, int nEndCharPos, int nFlags )
-:   mpStr( pStr ),
+:   
+    mnFlags( nFlags ),
     mnLength( nLength ),
     mnMinCharPos( nMinCharPos ),
     mnEndCharPos( nEndCharPos ),
-    mnFlags( nFlags ),
-    mnLayoutWidth( 0 ),
+    mpStr( pStr ),
     mpDXArray( NULL ),
+    mnLayoutWidth( 0 ),
     mnOrientation( 0 )
 {
     if( mnFlags & SAL_LAYOUT_BIDI_STRONG )
@@ -487,14 +481,13 @@ ImplLayoutArgs::ImplLayoutArgs( const xu
     for( int i = 0; i < nRunCount; ++i )
     {
         int32_t nMinPos, nLength;
-        UBiDiDirection nDir = ubidi_getVisualRun( pLineBidi, i, &nMinPos, &nLength );
+        ubidi_getVisualRun( pLineBidi, i, &nMinPos, &nLength );
         int nPos0 = nMinPos + mnMinCharPos;
         int nPos1 = nPos0 + nLength;
-#if 0
-        bool bRTL = (nDir == UBIDI_RTL);
-#else // workaround for #110273# (probably ICU problem TODO: analyze there)
+
+		// bool bRTL = (nDir == UBIDI_RTL);
+		// workaround for #110273# (probably ICU problem TODO: analyze there)
         bool bRTL = ((pParaLevels[ nPos0 ] & 1) != 0);
-#endif
 
         // remove control characters from runs by splitting them up
         if( !bRTL )
@@ -554,10 +547,10 @@ SalLayout::SalLayout()
 :   mnMinCharPos( -1 ),
     mnEndCharPos( -1 ),
     mnLayoutFlags( 0 ),
-    mnOrientation( 0 ),
-    maDrawOffset( 0, 0 ),
     mnUnitsPerPixel( 1 ),
-    mnRefCount( 1 )
+    mnOrientation( 0 ),
+    mnRefCount( 1 ),
+    maDrawOffset( 0, 0 )
 {}
 
 // -----------------------------------------------------------------------
@@ -673,12 +666,12 @@ bool SalLayout::GetOutline( SalGraphics&
     PolyPolygon aGlyphOutline;
     for( int nStart = 0;;)
     {
-        long nLGlyph;
+        sal_Int32 nLGlyph;
         if( !GetNextGlyphs( 1, &nLGlyph, aPos, nStart ) )
             break;
 
         // get outline of individual glyph, ignoring "empty" glyphs
-        bool bSuccess = rSalGraphics.GetGlyphOutline( nLGlyph, aGlyphOutline, NULL );
+        bool bSuccess = rSalGraphics.GetGlyphOutline( nLGlyph, aGlyphOutline );
         bRet &= bSuccess;
         // only add non-empty outlines
         if( bSuccess && (aGlyphOutline.Count() > 0) )
@@ -703,12 +696,12 @@ bool SalLayout::GetBoundRect( SalGraphic
     Rectangle aRectangle;
     for( int nStart = 0;;)
     {
-        long nLGlyph;
+        sal_Int32 nLGlyph;
         if( !GetNextGlyphs( 1, &nLGlyph, aPos, nStart ) )
             break;
 
         // get bounding rectangle of individual glyph
-        if( rSalGraphics.GetGlyphBoundRect( nLGlyph, aRectangle, NULL ) )
+        if( rSalGraphics.GetGlyphBoundRect( nLGlyph, aRectangle ) )
         {
             // merge rectangle
             aRectangle += aPos;
@@ -741,9 +734,10 @@ bool SalLayout::IsSpacingGlyph( long nGl
 // =======================================================================
 
 GenericSalLayout::GenericSalLayout()
-:   mnGlyphCount(0),
-    mnGlyphCapacity(0),
-    mpGlyphItems(0)
+:   mpGlyphItems(0),
+    mnGlyphCount(0),
+    mnGlyphCapacity(0)
+    
 {}
 
 // -----------------------------------------------------------------------
@@ -776,7 +770,7 @@ void GenericSalLayout::AppendGlyph( cons
 
 // -----------------------------------------------------------------------
 
-bool GenericSalLayout::GetCharWidths( long* pCharWidths ) const
+bool GenericSalLayout::GetCharWidths( sal_Int32* pCharWidths ) const
 {
     // initialize character extents buffer
     int nCharCount = mnEndCharPos - mnMinCharPos;
@@ -785,7 +779,6 @@ bool GenericSalLayout::GetCharWidths( lo
 
     // determine cluster extents
     const GlyphItem* pG = mpGlyphItems;
-    int nClusterIndex = 0;
     for( int i = mnGlyphCount; --i >= 0; ++pG )
     {
         // use cluster start to get char index
@@ -840,7 +833,7 @@ bool GenericSalLayout::GetCharWidths( lo
 
 // -----------------------------------------------------------------------
 
-long GenericSalLayout::FillDXArray( long* pCharWidths ) const
+long GenericSalLayout::FillDXArray( sal_Int32* pCharWidths ) const
 {
     if( pCharWidths )
         if( !GetCharWidths( pCharWidths ) )
@@ -915,7 +908,7 @@ void GenericSalLayout::ApplyDXArray( Imp
     }
 
     // calculate adjusted cluster widths
-    long* pNewGlyphWidths = (long*)alloca( mnGlyphCount * sizeof(long) );
+    sal_Int32* pNewGlyphWidths = (sal_Int32*)alloca( mnGlyphCount * sizeof(long) );
     for( i = 0; i < mnGlyphCount; ++i )
         pNewGlyphWidths[ i ] = 0;
 
@@ -937,7 +930,6 @@ void GenericSalLayout::ApplyDXArray( Imp
     long nDelta = 0;
     long nNewPos = 0;
     pG = mpGlyphItems;
-    const GlyphItem* const pGEnd = mpGlyphItems + mnGlyphCount;
     for( i = 0; i < mnGlyphCount; ++i, ++pG )
     {
         if( pG->IsClusterStart() )
@@ -1006,7 +998,7 @@ void GenericSalLayout::Justify( long nNe
 
     // interpolate inbetween glyph positions
     int nDiffWidth = nNewWidth - nOldWidth;
-    int nDiffSum = 0;
+    int nDeltaSum = 0;
     for( pG = mpGlyphItems; (pG < pGRight) && (nStretchable > 0); ++pG )
     {
         if( pG->mnOrigWidth <= 0 )
@@ -1017,12 +1009,11 @@ void GenericSalLayout::Justify( long nNe
         --nStretchable;
 
         pG->mnNewWidth += nDeltaWidth;
-        pG->maLinearPos.X() += nDiffSum;
-        nDiffSum += nDeltaWidth;
+        pG->maLinearPos.X() += nDeltaSum;
+	nDeltaSum += nDeltaWidth;
     }
 }
 
-
 // -----------------------------------------------------------------------
 
 void GenericSalLayout::ApplyAsianKerning( const sal_Unicode* pStr, int nLength )
@@ -1140,7 +1131,7 @@ void GenericSalLayout::KashidaJustify( l
 
 // -----------------------------------------------------------------------
 
-void GenericSalLayout::GetCaretPositions( int nMaxIndex, long* pCaretXArray ) const
+void GenericSalLayout::GetCaretPositions( int nMaxIndex, sal_Int32* pCaretXArray ) const
 {
     // initialize result array
     long nXPos = -1;
@@ -1176,7 +1167,7 @@ void GenericSalLayout::GetCaretPositions
 int GenericSalLayout::GetTextBreak( long nMaxWidth, long nCharExtra, int nFactor ) const
 {
     int nCharCapacity = mnEndCharPos - mnMinCharPos;
-    long* pCharWidths = (long*)alloca( nCharCapacity * sizeof(long) );
+    sal_Int32* pCharWidths = (sal_Int32*)alloca( nCharCapacity * sizeof(sal_Int32) );
     if( !GetCharWidths( pCharWidths ) )
         return STRING_LEN;
 
@@ -1194,8 +1185,8 @@ int GenericSalLayout::GetTextBreak( long
 
 // -----------------------------------------------------------------------
 
-int GenericSalLayout::GetNextGlyphs( int nLen, long* pGlyphs, Point& rPos,
-    int& nStart, long* pGlyphAdvAry, int* pCharPosAry ) const
+int GenericSalLayout::GetNextGlyphs( int nLen, sal_Int32* pGlyphs, Point& rPos,
+    int& nStart, sal_Int32* pGlyphAdvAry, int* pCharPosAry ) const
 {
     const GlyphItem* pG = mpGlyphItems + nStart;
 
@@ -1411,7 +1402,7 @@ void MultiSalLayout::AdjustLayout( ImplL
             mpLayouts[n]->SalLayout::AdjustLayout( aMultiArgs );
         // then we can measure the unmodified metrics
         int nCharCount = rArgs.mnEndCharPos - rArgs.mnMinCharPos;
-        long* pJustificationArray = (long*)alloca( nCharCount * sizeof(long) );
+        sal_Int32* pJustificationArray = (sal_Int32*)alloca( nCharCount * sizeof(sal_Int32) );
         FillDXArray( pJustificationArray );
         // #i17359# multilayout is not simplified yet, so calculating the
         // unjustified width needs handholding; also count the number of
@@ -1456,11 +1447,11 @@ void MultiSalLayout::AdjustLayout( ImplL
     int nStartOld[ MAX_FALLBACK ];
     int nStartNew[ MAX_FALLBACK ];
     int nCharPos[ MAX_FALLBACK ];
-    long nGlyphAdv[ MAX_FALLBACK ];
+    sal_Int32 nGlyphAdv[ MAX_FALLBACK ];
     int nValid[ MAX_FALLBACK ];
     const ImplLayoutRuns& rLastLevelRuns = maFallbackRuns[ mnLevel-1 ];
 
-    long nDummy;
+    sal_Int32 nDummy;
     Point aPos;
     int nLevel = 0, n;
     for( n = 0; n < mnLevel; ++n )
@@ -1501,6 +1492,7 @@ void MultiSalLayout::AdjustLayout( ImplL
 
     // merge the fallback levels
     long nXPos = 0;
+    int nFallbackUnitsPerPixel = 1;
     for( n = 0; n < nLevel; ++n )
         maFallbackRuns[n].ResetPos();
     while( nValid[0] )
@@ -1515,9 +1507,10 @@ void MultiSalLayout::AdjustLayout( ImplL
         {
             // use base(n==0) or fallback(n>=1) level
             long nNewPos = nXPos;
-            if( mpLayouts[n]->GetUnitsPerPixel() != mnUnitsPerPixel )
+            nFallbackUnitsPerPixel = mpLayouts[n]->GetUnitsPerPixel();
+            if( nFallbackUnitsPerPixel != mnUnitsPerPixel )
             {
-                nNewPos *= mpLayouts[n]->GetUnitsPerPixel();
+                nNewPos *= nFallbackUnitsPerPixel;
                 nNewPos /= mnUnitsPerPixel;
             }
             mpLayouts[n]->MoveGlyph( nStartOld[n], nNewPos );
@@ -1530,12 +1523,19 @@ void MultiSalLayout::AdjustLayout( ImplL
                 n = 0;  // keep NotDef in base level
             else
                 n = -1; // drop NotDef in base level
+            nFallbackUnitsPerPixel = mnUnitsPerPixel;
         }
 
         if( n >= 0 )
         {
             // use glyph from best matching layout
-            nXPos += nGlyphAdv[n] * mnUnitsPerPixel / mpLayouts[n]->GetUnitsPerPixel();
+            int nCurrentGlyphAdv = nGlyphAdv[n];
+            if( nFallbackUnitsPerPixel != mnUnitsPerPixel )
+            {
+                nCurrentGlyphAdv *= mnUnitsPerPixel;
+                nCurrentGlyphAdv /= nFallbackUnitsPerPixel;
+            }
+            nXPos += nCurrentGlyphAdv;
 
             // complete this glyph cluster, then advance to next
             for( int nActivePos = nCharPos[0];; )
@@ -1545,7 +1545,13 @@ void MultiSalLayout::AdjustLayout( ImplL
                     nStartNew[n], &nGlyphAdv[n], &nCharPos[n] );
                 if( !nValid[n] || (nCharPos[n] != nActivePos) )
                     break;
-                nXPos += nGlyphAdv[n] * mnUnitsPerPixel / mpLayouts[n]->GetUnitsPerPixel();
+                int nCurrentGlyphAdv = nGlyphAdv[n];
+                if( nFallbackUnitsPerPixel != mnUnitsPerPixel )
+                {
+                    nCurrentGlyphAdv *= mnUnitsPerPixel;
+                    nCurrentGlyphAdv /= nFallbackUnitsPerPixel;
+                }
+                nXPos += nCurrentGlyphAdv;
             }
 
             // performance optimization (fallback level is completed)
@@ -1557,7 +1563,7 @@ void MultiSalLayout::AdjustLayout( ImplL
         {
             // drop NotDef glyph from base layout
             mpLayouts[0]->DropGlyph( nStartOld[0] );
-            mpLayouts[0]->MoveGlyph( nStartNew[0], nXPos*mpLayouts[0]->GetUnitsPerPixel()/mnUnitsPerPixel );
+            mpLayouts[0]->MoveGlyph( nStartNew[0], nXPos );
 
             // get next glyph in base layout
             nStartOld[0] = nStartNew[0];
@@ -1613,7 +1619,7 @@ int MultiSalLayout::GetTextBreak( long n
         return mpLayouts[0]->GetTextBreak( nMaxWidth, nCharExtra, nFactor );
 
     int nCharCount = mnEndCharPos - mnMinCharPos;
-    long* pCharWidths = (long*)alloca( 2*nCharCount * sizeof(long) );
+    sal_Int32* pCharWidths = (sal_Int32*)alloca( 2*nCharCount * sizeof(sal_Int32) );
     mpLayouts[0]->FillDXArray( pCharWidths );
 
     for( int n = 1; n < mnLevel; ++n )
@@ -1642,18 +1648,18 @@ int MultiSalLayout::GetTextBreak( long n
 
 // -----------------------------------------------------------------------
 
-long MultiSalLayout::FillDXArray( long* pCharWidths ) const
+long MultiSalLayout::FillDXArray( sal_Int32* pCharWidths ) const
 {
     long nMaxWidth = 0;
 
     // prepare merging of fallback levels
-    long* pTempWidths = NULL;
+    sal_Int32* pTempWidths = NULL;
     const int nCharCount = mnEndCharPos - mnMinCharPos;
     if( pCharWidths )
     {
         for( int i = 0; i < nCharCount; ++i )
             pCharWidths[i] = 0;
-        pTempWidths = (long*)alloca( nCharCount * sizeof(long) );
+        pTempWidths = (sal_Int32*)alloca( nCharCount * sizeof(sal_Int32) );
     }
 
     for( int n = mnLevel; --n >= 0; )
@@ -1663,11 +1669,8 @@ long MultiSalLayout::FillDXArray( long* 
         if( !nWidth )
             continue;
         // merge results from current level
-        if( mnUnitsPerPixel != mpLayouts[n]->GetUnitsPerPixel() )
-        {
-            nWidth *= mnUnitsPerPixel;
-            nWidth /= mpLayouts[n]->GetUnitsPerPixel();
-        }
+        nWidth *= mnUnitsPerPixel;
+        nWidth /= mpLayouts[n]->GetUnitsPerPixel();
         if( nMaxWidth < nWidth )
             nMaxWidth = nWidth;
         if( !pCharWidths )
@@ -1693,14 +1696,14 @@ long MultiSalLayout::FillDXArray( long* 
 
 // -----------------------------------------------------------------------
 
-void MultiSalLayout::GetCaretPositions( int nMaxIndex, long* pCaretXArray ) const
+void MultiSalLayout::GetCaretPositions( int nMaxIndex, sal_Int32* pCaretXArray ) const
 {
     SalLayout& rLayout = *mpLayouts[ 0 ];
     rLayout.GetCaretPositions( nMaxIndex, pCaretXArray );
 
     if( mnLevel > 1 )
     {
-        long* pTempPos = (long*)alloca( nMaxIndex * sizeof(long) );
+        sal_Int32* pTempPos = (sal_Int32*)alloca( nMaxIndex * sizeof(sal_Int32) );
         for( int n = 1; n < mnLevel; ++n )
         {
             mpLayouts[ n ]->GetCaretPositions( nMaxIndex, pTempPos );
@@ -1718,8 +1721,8 @@ void MultiSalLayout::GetCaretPositions( 
 
 // -----------------------------------------------------------------------
 
-int MultiSalLayout::GetNextGlyphs( int nLen, long* pGlyphIdxAry, Point& rPos,
-    int& nStart, long* pGlyphAdvAry, int* pCharPosAry ) const
+int MultiSalLayout::GetNextGlyphs( int nLen, sal_Int32* pGlyphIdxAry, Point& rPos,
+    int& nStart, sal_Int32* pGlyphAdvAry, int* pCharPosAry ) const
 {
     // for multi-level fallback only single glyphs should be used
     if( mnLevel > 1 && nLen > 1 )
Index: vcl/source/gdi/salmisc.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/salmisc.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/gdi/salmisc.cxx	17 Jan 2002 15:35:33 -0000	1.3
+++ vcl/source/gdi/salmisc.cxx	6 Jan 2004 13:56:04 -0000	1.4
@@ -89,7 +89,7 @@ break
 #define DOUBLE_SCANLINES()														\
 while( ( nActY < nHeight1 ) && ( pMapY[ nActY + 1 ] == nMapY ) )				\
 {																				\
-	HMEMCPY( pDstScanMap[ nActY + 1L ], pDstScan, rDstBuffer.mnScanlineSize );	\
+	memcpy( pDstScanMap[ nActY + 1L ], pDstScan, rDstBuffer.mnScanlineSize );	\
 	nActY++;																	\
 }
 
Index: vcl/source/gdi/salnativewidgets-none.cxx
===================================================================
RCS file: vcl/source/gdi/salnativewidgets-none.cxx
diff -N vcl/source/gdi/salnativewidgets-none.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/gdi/salnativewidgets-none.cxx	10 May 2004 15:49:20 -0000	1.2
@@ -0,0 +1,172 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#include <salgdi.hxx>
+
+using namespace rtl;
+
+/****************************************************************
+ *  Placeholder for no native widgets
+ ***************************************************************/
+
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+	return( FALSE );
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL SalGraphics::hitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside )
+{
+	return( FALSE );
+}
+
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::drawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+	return( FALSE );
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::drawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption )
+{
+	return( FALSE );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the TRUE bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::getNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion )
+{
+	return( FALSE );
+}
+
Index: vcl/source/gdi/svcompat.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/svcompat.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/svcompat.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/svcompat.cxx	6 Jan 2004 13:56:30 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_COMPAT_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
Index: vcl/source/gdi/virdev.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/virdev.cxx,v
retrieving revision 1.9
retrieving revision 1.14
diff -u -p -u -r1.9 -r1.14
--- vcl/source/gdi/virdev.cxx	2 May 2003 14:36:42 -0000	1.9
+++ vcl/source/gdi/virdev.cxx	6 Jan 2004 13:57:02 -0000	1.14
@@ -59,13 +59,10 @@
  *
  ************************************************************************/
 
-#define _SV_VIRDEV_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALINST_HXX
 #include <salinst.hxx>
 #endif
@@ -78,7 +75,6 @@
 #ifndef _SV_SALVD_HXX
 #include <salvd.hxx>
 #endif
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -104,52 +100,6 @@
 
 using namespace ::com::sun::star::uno;
 
-// appserver
-#ifdef REMOTE_APPSERVER
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#ifndef _SV_RMVIRDEV_HXX
-#include <rmvirdev.hxx>
-#endif
-#ifndef _VCL_RMCACHE_HXX_
-#include <rmcache.hxx>
-#endif
-#endif
-
-// =======================================================================
-
-// interface cache
-#ifdef REMOTE_APPSERVER
-
-static ::vcl::InterfacePairCache< ::com::sun::star::portal::client::XRmVirtualDevice, ::com::sun::star::portal::client::XRmOutputDevice >* pRemoteVirdevCache = NULL;
-
-typedef ::std::pair< ::com::sun::star::uno::Reference< ::com::sun::star::portal::client::XRmVirtualDevice >, ::com::sun::star::uno::Reference< ::com::sun::star::portal::client::XRmOutputDevice > > virdevInterfacePair;
-
-
-void createRemoteVirdevCache( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aInterfaceSeq )
-{
-	if( ! pRemoteVirdevCache )
-	{
-		ImplSVData* pSVData = ImplGetSVData();
-		pRemoteVirdevCache = new ::vcl::InterfacePairCache< ::com::sun::star::portal::client::XRmVirtualDevice, ::com::sun::star::portal::client::XRmOutputDevice >(
-			pSVData->mxMultiFactory,
-			aInterfaceSeq,
-			::rtl::OUString::createFromAscii( "OfficeVirtualDevice.stardiv.de" ), 10, 40 );
-	}
-}
-
-void eraseRemoteVirdevCache()
-{
-	if( pRemoteVirdevCache )
-	{
-		delete pRemoteVirdevCache;
-		pRemoteVirdevCache = NULL;
-	}
-}
-
-#endif
-
 // =======================================================================
 
 void VirtualDevice::ImplInitVirDev( const OutputDevice* pOutDev,
@@ -169,7 +119,6 @@ void VirtualDevice::ImplInitVirDev( cons
 	if ( !pOutDev )
 		pOutDev = ImplGetDefaultWindow();
 
-#ifndef REMOTE_APPSERVER
 	SalGraphics* pGraphics;
 	if ( !pOutDev->mpGraphics )
 		((OutputDevice*)pOutDev)->ImplGetGraphics();
@@ -180,62 +129,13 @@ void VirtualDevice::ImplInitVirDev( cons
 		mpVirDev = NULL;
 	if ( !mpVirDev )
 		GetpApp()->Exception( EXC_SYSOBJNOTCREATED );
-#else
-
-	if( pOutDev->GetOutDevType() == OUTDEV_PRINTER || ! mpVirDev )
-	{
-		virdevInterfacePair aPair = pRemoteVirdevCache->takeInterface();
-		if( aPair.first.is() && aPair.second.is() )
-		{
-			if( ! mpVirDev )
-				mpVirDev = new RmVirtualDevice;
-			mpVirDev->SetInterface( aPair.first );
-			mpVirDev->Create( (ULONG) pOutDev, nDX, nDY, nBitCount );
-
-			if( ! mpGraphics )
-				mpGraphics = new ImplServerGraphics();
-			mpGraphics->SetInterface( aPair.second );
-		}
-	}
-	else
-	{
-		// this was done in ImpGetServerGraphics before
-		// and is now here because of interface caching
-		if( mpGraphics && mpGraphics->GetInterface().is() )
-		{
-			try
-			{
-				CHECK_FOR_RVPSYNC_NORMAL();
-				mpGraphics->GetInterface()->SetFillColor( mpGraphics->maFillColor.GetColor() );
-			}
-			catch (...)
-			{
-				if( mpGraphics )
-					delete mpGraphics, mpGraphics = NULL;
-
-				if( mpVirDev )
-				{
-					virdevInterfacePair aPair = pRemoteVirdevCache->takeInterface();
-					if( aPair.first.is() && aPair.second.is() )
-					{
-						mpVirDev->SetInterface( aPair.first );
-						mpVirDev->Create( (ULONG)NULL, mnOutWidth, mnOutHeight, mnBitCount );
-						mpGraphics = new ImplServerGraphics();
-						mpGraphics->SetInterface( aPair.second );
-					}
-					else
-						mpVirDev->SetInterface( REF( NMSP_CLIENT::XRmVirtualDevice )() );
-				}
-			}
-		}
-		ImplGetServerGraphics( TRUE );
-	}
-#endif
 
 	mnBitCount		= ( nBitCount ? nBitCount : pOutDev->GetBitCount() );
 	mnOutWidth		= nDX;
 	mnOutHeight 	= nDY;
 	mbScreenComp	= TRUE;
+	mbScreenComp	= FALSE;
+    mnAlphaDepth	= -1;
 
     if( mnBitCount < 8 )
         SetAntialiasing( ANTIALIASING_DISABLE_TEXT );
@@ -270,7 +170,8 @@ void VirtualDevice::ImplInitVirDev( cons
 // -----------------------------------------------------------------------
 
 VirtualDevice::VirtualDevice( USHORT nBitCount )
-	: mpVirDev( NULL )
+:   mpVirDev( NULL ),
+    meRefDevMode( REFDEV_NONE )
 {
 	DBG_TRACE1( "VirtualDevice::VirtualDevice( %hu )", nBitCount );
 
@@ -280,11 +181,25 @@ VirtualDevice::VirtualDevice( USHORT nBi
 // -----------------------------------------------------------------------
 
 VirtualDevice::VirtualDevice( const OutputDevice& rCompDev, USHORT nBitCount )
+	: mpVirDev( NULL ),
+    meRefDevMode( REFDEV_NONE )
+{
+	DBG_TRACE1( "VirtualDevice::VirtualDevice( %hu )", nBitCount );
+
+	ImplInitVirDev( &rCompDev, 1, 1, nBitCount );
+}
+
+// -----------------------------------------------------------------------
+
+VirtualDevice::VirtualDevice( const OutputDevice& rCompDev, USHORT nBitCount, USHORT nAlphaBitCount )
 	: mpVirDev( NULL )
 {
 	DBG_TRACE1( "VirtualDevice::VirtualDevice( %hu )", nBitCount );
 
 	ImplInitVirDev( &rCompDev, 1, 1, nBitCount );
+
+    // #110958# Enable alpha channel
+    mnAlphaDepth = nAlphaBitCount;
 }
 
 // -----------------------------------------------------------------------
@@ -295,33 +210,10 @@ VirtualDevice::~VirtualDevice()
 
    ImplSVData* pSVData = ImplGetSVData();
 
-#ifndef REMOTE_APPSERVER
 	ImplReleaseGraphics();
 
 	if ( mpVirDev )
 		pSVData->mpDefInst->DestroyVirtualDevice( mpVirDev );
-#else
-	if ( pRemoteVirdevCache && mpVirDev && mpGraphics )
-	{
-		virdevInterfacePair aPair( mpVirDev->GetInterface(), mpGraphics->GetInterface() );
-		CHECK_FOR_RVPSYNC_NORMAL();
-        try
-        {
-		    aPair.first->Create( 0, 0, 0, 0 );
-		    pRemoteVirdevCache->putInterface( aPair );
-        }
-        catch ( RuntimeException &e )
-        {
-            rvpExceptionHandler();
-        }
-	}
-
-    REF( NMSP_CLIENT::XRmOutputDevice ) aTmp;
-	mpGraphics->SetInterface( aTmp );
-	ImplReleaseServerGraphics();
-	delete mpVirDev;
-	delete mpGraphics;
-#endif
 
 	// VirDev aus der Liste eintragen
 	if( mpPrev )
@@ -337,9 +229,9 @@ VirtualDevice::~VirtualDevice()
 
 // -----------------------------------------------------------------------
 
-BOOL VirtualDevice::SetOutputSizePixel( const Size& rNewSize, BOOL bErase )
+BOOL VirtualDevice::ImplSetOutputSizePixel( const Size& rNewSize, BOOL bErase )
 {
-	DBG_TRACE3( "VirtualDevice::SetOutputSizePixel( %ld, %ld, %d )", rNewSize.Width(), rNewSize.Height(), (int)bErase );
+	DBG_TRACE3( "VirtualDevice::ImplSetOutputSizePixel( %ld, %ld, %d )", rNewSize.Width(), rNewSize.Height(), (int)bErase );
 
 	if ( !mpVirDev )
 		return FALSE;
@@ -350,33 +242,6 @@ BOOL VirtualDevice::SetOutputSizePixel( 
 		return TRUE;
 	}
 
-#ifdef REMOTE_APPSERVER
-	long nOldWidth = mnOutWidth, nOldHeight = mnOutHeight;
-
-	try
-	{
-		mnOutWidth	= rNewSize.Width();
-		mnOutHeight = rNewSize.Height();
-		mpVirDev->ResizeOutputSizePixel( mnOutWidth, mnOutHeight );
-	}
-	catch (...)
-	{
-		delete mpVirDev, mpVirDev = NULL;
-		ImplInitVirDev( NULL, mnOutWidth, mnOutHeight, mnBitCount );
-	}
-
-	if( bErase )
-		Erase();
-	else
-	{
-		if ( nOldWidth < mnOutWidth )
-			Erase( Rectangle( Point( nOldWidth, 0 ), Size( mnOutWidth-nOldWidth, Max( nOldHeight, mnOutHeight ) ) ) );
-		if ( nOldHeight< mnOutHeight )
-			Erase( Rectangle( Point( 0, nOldHeight ), Size( Max( nOldWidth, mnOutWidth ), mnOutHeight-nOldHeight ) ) );
-	}
-
-	return TRUE;
-#else
 	BOOL bRet;
 	long nNewWidth = rNewSize.Width(), nNewHeight = rNewSize.Height();
 
@@ -455,16 +320,79 @@ BOOL VirtualDevice::SetOutputSizePixel( 
 	}
 
 	return bRet;
-#endif
 }
 
-void VirtualDevice::SetReferenceDevice()
+// -----------------------------------------------------------------------
+
+BOOL VirtualDevice::SetOutputSizePixel( const Size& rNewSize, BOOL bErase )
 {
-    // reference device has 600dpi
-    mnDPIX = 600;
-    mnDPIY = 600;
+    if( ImplSetOutputSizePixel(rNewSize, bErase) )
+    {
+        if( mnAlphaDepth != -1 )
+        {
+            // #110958# Setup alpha bitmap
+			if(mpAlphaVDev && mpAlphaVDev->GetOutputSizePixel() != rNewSize)
+			{
+				delete mpAlphaVDev;
+				mpAlphaVDev = 0L;
+			}
+
+			if( !mpAlphaVDev )
+            {
+                mpAlphaVDev = new VirtualDevice( *this, mnAlphaDepth );
+                mpAlphaVDev->ImplSetOutputSizePixel(rNewSize, bErase);
+            }
+
+            // TODO: copy full outdev state to new one, here. Also needed in outdev2.cxx:DrawOutDev
+            if( GetLineColor() != Color( COL_TRANSPARENT ) )
+                mpAlphaVDev->SetLineColor( COL_BLACK );
+
+            if( GetFillColor() != Color( COL_TRANSPARENT ) )
+                mpAlphaVDev->SetFillColor( COL_BLACK );
+
+            mpAlphaVDev->SetMapMode( GetMapMode() );
+        }
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+// -----------------------------------------------------------------------
+
+void VirtualDevice::SetReferenceDevice( RefDevMode eRefDevMode )
+{
+    switch( eRefDevMode )
+    {
+    case REFDEV_NONE:
+    default:
+        DBG_ASSERT( FALSE, "VDev::SetRefDev illegal argument!" );
+        // fall through
+    case REFDEV_MODE06:
+        mnDPIX = mnDPIY = 600;
+        break;
+    case REFDEV_MODE48:
+        mnDPIX = mnDPIY = 4800;
+        break;
+    case REFDEV_MODE96:
+        mnDPIX = mnDPIY = 9600;
+        break;
+    }
+
+    EnableOutput( FALSE );  // prevent output on reference device
     mbScreenComp = FALSE;
 
+    // invalidate currently selected fonts
+    mbInitFont = TRUE;
+    mbNewFont = TRUE;
+
+    // avoid adjusting font lists when already in refdev mode
+    BYTE nOldRefDevMode = meRefDevMode;
+    meRefDevMode = (BYTE)eRefDevMode;
+    if( nOldRefDevMode != REFDEV_NONE )
+        return;
+
     // the reference device should have only scalable fonts
     // => clean up the original font lists before getting new ones
     if ( mpFontEntry )
@@ -491,6 +419,7 @@ void VirtualDevice::SetReferenceDevice()
         delete mpFontCache;
 
     // get font list with scalable fonts only
+    ImplGetGraphics();
     ImplDevFontList* pScalableDevFonts = new ImplDevFontList();
     ImplDevFontListData* pData = pSVData->maGDIData.mpScreenFontList->First();
     for(; pData; pData = pSVData->maGDIData.mpScreenFontList->Next() )
@@ -506,13 +435,11 @@ void VirtualDevice::SetReferenceDevice()
             pScalableDevFonts->Add( pNewData );
         }
     }
-    mpFontList = pScalableDevFonts;
 
     // prepare to use new font lists
+    mpFontList = pScalableDevFonts;
     mpFontCache = new ImplFontCache( FALSE );
-    mbInitFont = TRUE;
-    mbNewFont = TRUE;
-    
-    // TODO: increase maFont's size accordingly?
 }
 
+// -----------------------------------------------------------------------
+// eof
Index: vcl/source/gdi/wall.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/wall.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/wall.cxx	18 Sep 2000 17:05:39 -0000	1.1.1.1
+++ vcl/source/gdi/wall.cxx	6 Jan 2004 13:57:32 -0000	1.2
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_WALL_CXX
-
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
@@ -79,8 +77,10 @@
 #ifndef _SV_WALL_HXX
 #include <wall.hxx>
 #endif
+#ifndef _SV_WALL2_HXX
+#include <wall2.hxx>
+#endif
 
-// =======================================================================
 
 DBG_NAME( Wallpaper );
 
@@ -259,11 +259,7 @@ Wallpaper::Wallpaper()
 {
 	DBG_CTOR( Wallpaper, NULL );
 
-#ifdef WIN
-	static ImplWallpaper _near aStaticImplWallpaper;
-#else
 	static ImplWallpaper aStaticImplWallpaper;
-#endif
 
 	aStaticImplWallpaper.mnRefCount = 0;
 	mpImplWallpaper = &aStaticImplWallpaper;
@@ -349,6 +345,15 @@ void Wallpaper::SetColor( const Color& r
 
 // -----------------------------------------------------------------------
 
+const Color& Wallpaper::GetColor() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return mpImplWallpaper->maColor; 
+}
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetStyle( WallpaperStyle eStyle )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -359,6 +364,15 @@ void Wallpaper::SetStyle( WallpaperStyle
 
 // -----------------------------------------------------------------------
 
+WallpaperStyle Wallpaper::GetStyle() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return mpImplWallpaper->meStyle; 
+}
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetBitmap( const BitmapEx& rBitmap )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -416,6 +430,16 @@ BitmapEx Wallpaper::GetBitmap() const
 
 // -----------------------------------------------------------------------
 
+BOOL Wallpaper::IsBitmap() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return (mpImplWallpaper->mpBitmap != 0); 
+}
+
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetGradient( const Gradient& rGradient )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -462,6 +486,16 @@ Gradient Wallpaper::GetGradient() const
 
 // -----------------------------------------------------------------------
 
+BOOL Wallpaper::IsGradient() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return (mpImplWallpaper->mpGradient != 0); 
+}
+
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetRect( const Rectangle& rRect )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -513,6 +547,16 @@ Rectangle Wallpaper::GetRect() const
 		return aRect;
 	}
 }
+
+// -----------------------------------------------------------------------
+
+BOOL Wallpaper::IsRect() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return (mpImplWallpaper->mpRect != 0); 
+}
+
 
 // -----------------------------------------------------------------------
 
Index: vcl/source/gdi/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/makefile.mk,v
retrieving revision 1.14
diff -u -p -u -r1.14 makefile.mk
--- vcl/source/gdi/makefile.mk	27 Mar 2003 17:57:58 -0000	1.14
+++ vcl/source/gdi/makefile.mk	5 Jul 2004 14:27:07 -0000
@@ -132,37 +132,18 @@ SLOFILES=	$(SLO)$/salmisc.obj 	\
 			$(SLO)$/fontcfg.obj		\
 			$(SLO)$/base14.obj		\
 			$(SLO)$/pdfwriter.obj	\
 			$(SLO)$/pdfwriter_impl.obj\
-			$(SLO)$/bmpconv.obj
+			$(SLO)$/sallayout.obj		\
+			$(SLO)$/salgdilayout.obj	\
+			$(SLO)$/salnativewidgets-none.obj	\
+			$(SLO)$/bmpconv.obj		\
+			$(SLO)$/pngread.obj		
 
-.IF "$(remote)"==""
-	SLOFILES += $(SLO)$/salgdilayout.obj
-.ENDIF
-
-.IF "$(ENABLE_CTL)"!=""
-	SLOFILES +=     $(SLO)$/sallayout.obj
-.ENDIF
-
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=	$(SLO)$/bitmap.obj		\
-					$(SLO)$/color.obj		\
-					$(SLO)$/gfxlink.obj		\
-					$(SLO)$/impgraph.obj	\
-					$(SLO)$/impvect.obj 	\
-					$(SLO)$/outdev.obj		\
-					$(SLO)$/outdev3.obj 	\
-					$(SLO)$/outdev6.obj		\
-					$(SLO)$/print.obj		\
-					$(SLO)$/print2.obj		\
-					$(SLO)$/virdev.obj		
-
-.ELSE
 EXCEPTIONSFILES=	$(SLO)$/outdev.obj		\
 					$(SLO)$/gfxlink.obj		\
 					$(SLO)$/print.obj		\
 					$(SLO)$/impgraph.obj	\
 					$(SLO)$/bmpconv.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
