Index: vcl/source/control/button.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/button.cxx,v
retrieving revision 1.21.116.1
retrieving revision 1.27
diff -u -p -u -r1.21.116.1 -r1.27
--- vcl/source/control/button.cxx	9 Jan 2004 18:13:43 -0000	1.21.116.1
+++ vcl/source/control/button.cxx	10 May 2004 15:45:59 -0000	1.27
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_BUTTON_CXX
-
 #include <tools/debug.hxx>
 
 #ifndef _SV_SVIDS_HRC
@@ -93,8 +91,8 @@
 #ifndef _SV_FIXED_HXX
 #include <fixed.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_BUTTON_HXX
 #include <button.hxx>
@@ -102,12 +100,15 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGET_HXX
+#include <salnativewidgets.hxx>
+#endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -307,7 +308,28 @@ void PushButton::ImplInitSettings( BOOL 
     }
 
     if ( bBackground )
-        SetBackground();
+    {
+        Window* pParent = GetParent();
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL ) )
+        {
+            EnableChildTransparentMode( TRUE );
+            SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+            SetPaintTransparent( TRUE );
+            SetBackground();
+        }
+        else
+        {
+            EnableChildTransparentMode( FALSE );
+            SetParentClipMode( 0 );
+            SetPaintTransparent( FALSE );
+
+            if ( IsControlBackground() )
+                SetBackground( GetControlBackground() );
+            else
+                SetBackground( pParent->GetBackground() );
+        }
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -841,27 +863,111 @@ void PushButton::ImplDrawPushButton( boo
     if( !bLayout )
         HideFocus();
 
-    const StyleSettings&    rStyleSettings = GetSettings().GetStyleSettings();
     USHORT                  nButtonStyle = mnButtonState;
     Point                   aPoint;
     Size                    aOutSz( GetOutputSizePixel() );
     Rectangle               aRect( aPoint, aOutSz );
     Rectangle               aInRect = aRect;
     Rectangle               aTextRect;
+    BOOL                    bNativeOK = FALSE;
 
     // adjust style if button should be rendered 'pressed'
     if ( mbPressed )
         nButtonStyle |= BUTTON_DRAW_PRESSED;
 
-    // draw PushButtonFrame, aInRect has content size afterwards
-    if( ! bLayout )
-        ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+    // TODO: move this to Window class or make it a member !!!
+    ControlType aCtrlType = 0;
+    switch( GetParent()->GetType() )
+    {
+        case WINDOW_LISTBOX:
+        case WINDOW_MULTILISTBOX:
+        case WINDOW_TREELISTBOX:
+            aCtrlType = CTRL_LISTBOX;
+            break;
+
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            aCtrlType = CTRL_COMBOBOX;
+            break;
+        default:
+            break;
+    }
+
+    BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+    if( bDropDown && (aCtrlType == CTRL_COMBOBOX || aCtrlType == CTRL_LISTBOX ) )
+    {
+        if( GetParent()->IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) )
+        {
+            if( !GetParent()->IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+                // skip painting if the button was already drawn by the theme
+                bNativeOK = TRUE;
+            else
+            {
+                // let the theme draw it, note we then need support
+                // for CTRL_LISTBOX/PART_BUTTON_DOWN and CTRL_COMBOBOX/PART_BUTTON_DOWN
+
+                ImplControlValue    aControlValue;
+                Region              aCtrlRegion( aInRect );
+                ControlState        nState = 0;
 
-    // draw content
-    ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+                if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+                if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+                if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+                if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+                if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
 
-    if( ! bLayout )
+                if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+                    nState |= CTRL_STATE_ROLLOVER;
+
+                bNativeOK = DrawNativeControl( aCtrlType, PART_BUTTON_DOWN, aCtrlRegion, nState,
+                                                aControlValue, rtl::OUString() );
+            }
+        }
+    }
+
+    if( bNativeOK )
+        return;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
     {
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aInRect );
+        ControlState	 nState = 0;
+
+        if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED ) nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
+
+        if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     				aControlValue, rtl::OUString()/*PushButton::GetText()*/ );
+
+        // draw frame into invisible window to have aInRect modified correctly
+        // but do not shift the inner rect for pressed buttons (ie remove BUTTON_DRAW_PRESSED)
+        // this assumes the theme has enough visual cues to signalize the button was pressed
+        //Window aWin( this );
+        //ImplDrawPushButtonFrame( &aWin, aInRect, nButtonStyle & ~BUTTON_DRAW_PRESSED );
+
+        // looks better this way as symbols were displaced slightly using the above approach
+        aInRect.Top()+=4;
+        aInRect.Bottom()-=4;
+        aInRect.Left()+=4;
+        aInRect.Right()-=4;
+
+        // draw content using the same aInRect as non-native VCL would do
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
         maFocusRect = aTextRect;
         if( !maFocusRect.IsEmpty() )
         {
@@ -870,21 +976,97 @@ void PushButton::ImplDrawPushButton( boo
             maFocusRect.Right()++;
             maFocusRect.Bottom()++;
             if ( HasFocus() )
-            {
                 ShowFocus( maFocusRect );
-            }
         }
     }
+
+    if ( bNativeOK == FALSE )
+    {
+        // draw PushButtonFrame, aInRect has content size afterwards
+        if( ! bLayout )
+            ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+
+        // draw content
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
+        if( ! bLayout )
+        {
+            maFocusRect = aTextRect;
+            if( !maFocusRect.IsEmpty() )
+            {
+                maFocusRect.Left()--;
+                maFocusRect.Top()--;
+                maFocusRect.Right()++;
+                maFocusRect.Bottom()++;
+                if ( HasFocus() )
+                {
+                    ShowFocus( maFocusRect );
+                }
+            }
+        } 
+    }
 }
 
 // -----------------------------------------------------------------------
 
 void PushButton::ImplSetDefButton( BOOL bSet )
 {
+    Size aSize( GetSizePixel() );
+    Point aPos( GetPosPixel() );
+    int dLeft(0), dRight(0), dTop(0), dBottom(0);
+    BOOL bSetPos = FALSE;
+
+    if ( (IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        Region aBoundingRgn, aContentRgn;
+        Rectangle aCtrlRect( 0, 0, 80, 20 ); // use a constant size to avoid accumulating
+                                             // will not work if the theme has dynamic adornment sizes
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aCtrlRect );
+        ControlState	 nState = CTRL_STATE_DEFAULT|CTRL_STATE_ENABLED;
+
+        // get native size of a 'default' button
+        // and adjust the VCL button if more space for adornment is required
+        if( GetNativeControlRegion( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion,
+                                nState, aControlValue, rtl::OUString(),
+								aBoundingRgn, aContentRgn ) )
+        {
+            Rectangle aCont(aContentRgn.GetBoundRect());
+            Rectangle aBound(aBoundingRgn.GetBoundRect());
+
+            dLeft = aCont.Left() - aBound.Left();
+            dTop = aCont.Top() - aBound.Top();
+            dRight = aBound.Right() - aCont.Right();
+            dBottom = aBound.Bottom() - aCont.Bottom();
+            bSetPos = dLeft || dTop || dRight || dBottom;
+        }
+    }
+
     if ( bSet )
+    {
+        if( !(mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from non-default to default
+            aPos.Move(-dLeft, -dTop);
+            aSize.Width() += dLeft + dRight;
+            aSize.Height() += dTop + dBottom;
+        }
         mnButtonState |= BUTTON_DRAW_DEFAULT;
+    }
     else
+    {
+        if( (mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from default to non-default
+            aPos.Move(dLeft, dTop);
+            aSize.Width() -= dLeft + dRight;
+            aSize.Height() -= dTop + dBottom;
+        }
         mnButtonState &= ~BUTTON_DRAW_DEFAULT;
+    }
+    if( bSetPos )
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+
     Invalidate();
 }
 
@@ -1080,9 +1262,23 @@ void PushButton::Draw( OutputDevice* pDe
     pDev->SetMapMode();
     pDev->SetFont( aFont );
     if ( nFlags & WINDOW_DRAW_MONO )
+	{
         pDev->SetTextColor( Color( COL_BLACK ) );
+	}
     else
+	{
         pDev->SetTextColor( GetTextColor() );
+
+		// DecoView uses the FaceColor...
+		AllSettings aSettings = pDev->GetSettings();
+		StyleSettings aStyleSettings = aSettings.GetStyleSettings();
+		if ( IsControlBackground() )
+			aStyleSettings.SetFaceColor( GetControlBackground() );
+		else
+			aStyleSettings.SetFaceColor( GetSettings().GetStyleSettings().GetFaceColor() );
+		aSettings.SetStyleSettings( aStyleSettings );
+		pDev->SetSettings( aSettings );
+	}
     pDev->SetTextFillColor();
 
     DecorationView aDecoView( pDev );
@@ -1186,6 +1382,73 @@ void PushButton::DataChanged( const Data
 
 // -----------------------------------------------------------------------
 
+long PushButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+
+            // TODO: move this to Window class or make it a member !!!
+            ControlType aCtrlType = 0;
+            switch( GetParent()->GetType() )
+            {
+                case WINDOW_LISTBOX:
+                case WINDOW_MULTILISTBOX:
+                case WINDOW_TREELISTBOX:
+                    aCtrlType = CTRL_LISTBOX;
+                    break;
+
+                case WINDOW_COMBOBOX:
+                case WINDOW_PATTERNBOX:			
+                case WINDOW_NUMERICBOX:			
+                case WINDOW_METRICBOX:			
+                case WINDOW_CURRENCYBOX:
+                case WINDOW_DATEBOX:		
+                case WINDOW_TIMEBOX:			
+                case WINDOW_LONGCURRENCYBOX:
+                    aCtrlType = CTRL_COMBOBOX;
+                    break;
+                default:
+                    break;
+            }
+
+            BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+            if( bDropDown && GetParent()->IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) && 
+                   !GetParent()->IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+            {
+                Window *pBorder = GetParent()->GetWindow( WINDOW_BORDER );
+                if(aCtrlType == CTRL_COMBOBOX)
+                {
+                    // only paint the button part to avoid flickering of the combobox text
+                    Point aPt;
+                    Rectangle aClipRect( aPt, GetOutputSizePixel() );
+                    aClipRect.SetPos(pBorder->ScreenToOutputPixel(OutputToScreenPixel(aClipRect.TopLeft())));
+                    pBorder->Invalidate( aClipRect );
+                }
+                else
+                {
+                    pBorder->Invalidate( INVALIDATE_NOERASE );
+                    pBorder->Update();
+                }
+            }
+            else if( IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                Invalidate();
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void PushButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_PUSHBUTTON_TOGGLE );
@@ -1635,7 +1898,8 @@ void RadioButton::ImplInitSettings( BOOL
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -1669,7 +1933,31 @@ void RadioButton::DrawRadioButtonState( 
 void RadioButton::ImplDrawRadioButtonState()
 {
     USHORT nStyle = 0;
+    BOOL   bNativeOK = FALSE;
+
+    // no native drawing for image radio buttons
+    if ( !maImage && (bNativeOK=IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		    aControlValue( mbChecked ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Rectangle					aCtrlRect( maStateRect.TopLeft(), maStateRect.GetSize() );
+        Region						aCtrlRegion( aCtrlRect );
+        ControlState				nState = 0;
+
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
+
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue,rtl::OUString() );
+
+    }
 
+if ( bNativeOK == FALSE )
+{
     // kein Image-RadioButton
     if ( !maImage )
     {
@@ -1762,6 +2050,7 @@ void RadioButton::ImplDrawRadioButtonSta
             ShowFocus( maFocusRect );
     }
 }
+}
 
 // -----------------------------------------------------------------------
 
@@ -1812,6 +2101,7 @@ void RadioButton::ImplDraw( OutputDevice
             rFocusRect = rMouseRect;
             rFocusRect.Left()--;
             rFocusRect.Right()++;
+            //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
             rMouseRect.Left()   = rPos.X();
             rStateRect.Left()   = rPos.X();
@@ -1910,10 +2200,11 @@ void RadioButton::ImplDrawRadioButton( b
     aImageSize.Width()  = CalcZoom( aImageSize.Width() );
     aImageSize.Height() = CalcZoom( aImageSize.Height() );
 
+    // Draw control text
     ImplDraw( this, 0, Point(), GetOutputSizePixel(),
               aImageSize, IMPL_SEP_BUTTON_IMAGE, maStateRect, maMouseRect, maFocusRect, bLayout );
 
-    if( !bLayout )
+    if( !bLayout || (IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)==TRUE) )
     {
         if ( !maImage )
         {
@@ -2352,6 +2643,35 @@ void RadioButton::DataChanged( const Dat
 
 // -----------------------------------------------------------------------
 
+long RadioButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                     pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Invalidate( maStateRect );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void RadioButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_RADIOBUTTON_TOGGLE );
@@ -2611,7 +2931,8 @@ void CheckBox::ImplInitSettings( BOOL bF
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported( CTRL_CHECKBOX, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -2651,18 +2972,46 @@ void CheckBox::ImplLoadRes( const ResId&
 
 void CheckBox::ImplDrawCheckBoxState()
 {
-    USHORT nStyle = mnButtonState;
-    if ( !IsEnabled() )
-        nStyle |= BUTTON_DRAW_DISABLED;
-    if ( meState == STATE_DONTKNOW )
-        nStyle |= BUTTON_DRAW_DONTKNOW;
-    else if ( meState == STATE_CHECK )
-        nStyle |= BUTTON_DRAW_CHECKED;
-    Image aImage = GetCheckImage( GetSettings(), nStyle );
-    if ( IsZoom() )
-        DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
-    else
-        DrawImage( maStateRect.TopLeft(), aImage );
+    bool	bNativeOK = TRUE;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue    aControlValue( meState == STATE_CHECK ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Region              aCtrlRegion( maStateRect );
+        ControlState        nState = 0;
+
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
+
+        if ( meState == STATE_CHECK )
+            aControlValue.setTristateVal( BUTTONVALUE_ON );
+        else if ( meState == STATE_DONTKNOW )					
+            aControlValue.setTristateVal( BUTTONVALUE_MIXED );
+
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_CHECKBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+
+    if ( bNativeOK == FALSE )
+    {
+        USHORT nStyle = mnButtonState;
+        if ( !IsEnabled() )
+            nStyle |= BUTTON_DRAW_DISABLED;
+        if ( meState == STATE_DONTKNOW )
+            nStyle |= BUTTON_DRAW_DONTKNOW;
+        else if ( meState == STATE_CHECK )
+            nStyle |= BUTTON_DRAW_CHECKED;
+        Image aImage = GetCheckImage( GetSettings(), nStyle );
+        if ( IsZoom() )
+            DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
+        else
+            DrawImage( maStateRect.TopLeft(), aImage );
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -2711,11 +3060,11 @@ void CheckBox::ImplDraw( OutputDevice* p
         rFocusRect = rMouseRect;
         rFocusRect.Left()--;
         rFocusRect.Right()++;
+        //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
+        rStateRect.Left()   = rPos.X();
+        rStateRect.Top()    = rMouseRect.Top();
         rMouseRect.Left()   = rPos.X();
-        // add 1 so that checkboxes with and without text are aligned
-        rStateRect.Left()   = rPos.X()+1;
-        rStateRect.Top()    = rMouseRect.Top()+1;
 
         long nTextHeight = GetTextHeight();
         if ( nTextHeight > rImageSize.Height() )
@@ -2730,17 +3079,22 @@ void CheckBox::ImplDraw( OutputDevice* p
         if ( nWinStyle & WB_CENTER )
             rStateRect.Left() = rPos.X()+((rSize.Width()-rImageSize.Width())/2);
         else if ( nWinStyle & WB_RIGHT )
-            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width()-1;
+            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width();
         else
-            rStateRect.Left() = rPos.X()+1;
+            rStateRect.Left() = rPos.X();
         if ( nWinStyle & WB_VCENTER )
             rStateRect.Top() = rPos.Y()+((rSize.Height()-rImageSize.Height())/2);
         else if ( nWinStyle & WB_BOTTOM )
-            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height()-1;
+            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height();
         else
-            rStateRect.Top() = rPos.Y()+1;
+            rStateRect.Top() = rPos.Y();
         rStateRect.Right()  = rStateRect.Left()+rImageSize.Width()-1;
         rStateRect.Bottom() = rStateRect.Top()+rImageSize.Height()-1;
+        // provide space for focusrect
+        // note: this assumes that the control's size was adjusted
+        // accordingly in Get/LoseFocus, so the onscreen position won't change
+        if( HasFocus() )
+            rStateRect.Move( 1, 1 );    
         rMouseRect          = rStateRect;
 
         rFocusRect          = rStateRect;
@@ -3044,7 +3398,21 @@ void CheckBox::Resize()
 
 void CheckBox::GetFocus()
 {
-    ShowFocus( maFocusRect );
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // increase button size to have space for focus rect
+        // checkboxes without text will draw focusrect around the check
+        // See CheckBox::ImplDraw()
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(-1,-1);
+        aSize.Height() += 2;
+        aSize.Width() += 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
+    else
+        ShowFocus( maFocusRect );
     SetInputContext( InputContext( GetFont() ) );
     Button::GetFocus();
 }
@@ -3061,6 +3429,19 @@ void CheckBox::LoseFocus()
 
     HideFocus();
     Button::LoseFocus();
+
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // decrease button size again (see GetFocus())
+        // checkboxes without text will draw focusrect around the check
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(1,1);
+        aSize.Height() -= 2;
+        aSize.Width() -= 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -3131,6 +3512,35 @@ void CheckBox::DataChanged( const DataCh
         ImplInitSettings( TRUE, TRUE, TRUE );
         Invalidate();
     }
+}
+
+// -----------------------------------------------------------------------
+
+long CheckBox::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                    pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Invalidate( maStateRect );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/combobox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/combobox.cxx,v
retrieving revision 1.25
retrieving revision 1.31
diff -u -p -u -r1.25 -r1.31
--- vcl/source/control/combobox.cxx	12 Jun 2003 08:18:32 -0000	1.25
+++ vcl/source/control/combobox.cxx	17 Jun 2004 12:11:35 -0000	1.31
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_COMBOBOX_CXX
-
 #ifndef _TOOLS_TABLE_HXX
 #include <tools/table.hxx>
 #endif
@@ -69,7 +67,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -99,7 +97,7 @@
 #include <controllayout.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -191,7 +189,7 @@ void ComboBox::ImplInitData()
 
 void ComboBox::ImplCalcEditHeight()
 {
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	GetBorder( nLeft, nTop, nRight, nBottom );
 	mnDDHeight = (USHORT)(mpSubEdit->GetTextHeight() + nTop + nBottom + 4);
 	if ( !IsDropDownBox() )
@@ -248,7 +246,7 @@ void ComboBox::ImplInit( Window* pParent
 	}
 
 	mpSubEdit = new Edit( this, nEditStyle );
-    mpSubEdit->EnableRTL( FALSE );
+	mpSubEdit->EnableRTL( FALSE );
 	SetSubEdit( mpSubEdit );
 	mpSubEdit->SetPosPixel( Point() );
 	EnableAutocomplete( TRUE );
@@ -268,8 +266,8 @@ void ComboBox::ImplInit( Window* pParent
 
 	if ( mpFloatWin )
 		mpFloatWin->SetImplListBox( mpImplLB );
-//	else
-//		mpImplLB->GetMainWindow()->AllowGrabFocus( TRUE );
+	else
+		mpImplLB->GetMainWindow()->AllowGrabFocus( TRUE );
 
 	ImplCalcEditHeight();
 
@@ -336,6 +334,11 @@ IMPL_LINK( ComboBox, ImplClickBtnHdl, vo
     SetSelection( Selection( 0, SELECTION_MAX ) );
 	mpFloatWin->StartFloat( TRUE );
     ImplCallEventListeners( VCLEVENT_DROPDOWN_OPEN );
+
+    ImplClearLayoutData();
+    if( mpImplLB )
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
+
 	return 0;
 }
 
@@ -355,6 +358,10 @@ IMPL_LINK( ComboBox, ImplPopupModeEndHdl
         }
     }
 
+    ImplClearLayoutData();
+    if( mpImplLB )
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
+
 	mpBtn->SetPressed( FALSE );
     ImplCallEventListeners( VCLEVENT_DROPDOWN_CLOSE );
 	return 0;
@@ -630,7 +637,7 @@ void ComboBox::SetPosSizePixel( long nX,
 	if( IsDropDownBox() && ( nFlags & WINDOW_POSSIZE_SIZE ) )
 	{
 		Size aPrefSz = mpFloatWin->GetPrefSize();
-		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight > mnDDHeight ) )
+		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight >= 2*mnDDHeight ) )
 			aPrefSz.Height() = nHeight-mnDDHeight;
 		if ( nFlags & WINDOW_POSSIZE_WIDTH )
 			aPrefSz.Width() = nWidth;
@@ -653,9 +660,48 @@ void ComboBox::Resize()
 	if( IsDropDownBox() )
 	{
 		long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
-		nSBWidth = CalcZoom( nSBWidth );
-		mpSubEdit->SetSizePixel( Size( aOutSz.Width() - nSBWidth, aOutSz.Height() ) );
-		mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		long	nTop = 0;
+		long	nBottom = aOutSz.Height();
+
+        Window *pBorder = GetWindow( WINDOW_BORDER );
+		ImplControlValue aControlValue;
+		Point aPoint;
+		Region aContent, aBound;
+
+        // use the full extent of the control
+		Region aArea( Rectangle(aPoint, pBorder->GetOutputSizePixel()) );
+
+		if ( GetNativeControlRegion(CTRL_COMBOBOX, PART_BUTTON_DOWN,
+				aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+		{
+            // convert back from border space to local coordinates
+            aPoint = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aPoint ) );
+            aContent.Move(-aPoint.X(), -aPoint.Y());
+
+			// use the themes drop down size for the button
+            aOutSz.Width() = aContent.GetBoundRect().Left();
+		    mpBtn->SetPosSizePixel( aContent.GetBoundRect().Left(), nTop, aContent.GetBoundRect().getWidth(), (nBottom-nTop) );
+
+            // adjust the size of the edit field
+            if ( GetNativeControlRegion(CTRL_COMBOBOX, PART_SUB_EDIT,
+                        aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+            {
+                // convert back from border space to local coordinates
+                aContent.Move(-aPoint.X(), -aPoint.Y());
+
+                // use the themes drop down size
+                Rectangle aContentRect = aContent.GetBoundRect();
+                mpSubEdit->SetPosSizePixel( aContentRect.TopLeft(), aContentRect.GetSize() );
+            }
+            else
+                mpSubEdit->SetSizePixel( aOutSz );
+		}
+		else
+        {
+            nSBWidth = CalcZoom( nSBWidth );
+		    mpSubEdit->SetSizePixel( Size( aOutSz.Width() - nSBWidth, aOutSz.Height() ) );
+		    mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, nTop, nSBWidth, (nBottom-nTop) );
+        }
 	}
 	else
 	{
@@ -768,6 +814,8 @@ void ComboBox::DataChanged( const DataCh
 		}
 		Resize();
 		mpImplLB->Resize(); // Wird nicht durch ComboBox::Resize() gerufen, wenn sich die ImplLB nicht aendert.
+        SetBackground();    // due to a hack in Window::UpdateSettings the background must be reset 
+                            // otherwise it will overpaint NWF drawn comboboxes
 	}
 }
 
@@ -1072,7 +1120,7 @@ Size ComboBox::CalcMinimumSize() const
 Size ComboBox::CalcAdjustedSize( const Size& rPrefSize ) const
 {
 	Size aSz = rPrefSize;
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	((Window*)this)->GetBorder( nLeft, nTop, nRight, nBottom );
 	aSz.Height() -= nTop+nBottom;
 	if ( !IsDropDownBox() )
@@ -1281,14 +1329,6 @@ BOOL ComboBox::IsUserDrawEnabled() const
 
 // -----------------------------------------------------------------------
 
-#if SUPD < 593
-void ComboBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText )
-{
-	DBG_ASSERT( rEvt.GetDevice() == mpImplLB->GetMainWindow(), "DrawEntry?!" );
-	mpImplLB->GetMainWindow()->DrawEntry( rEvt.GetItemId(), bDrawImage, bDrawText );
-}
-#endif
-
 void ComboBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText, BOOL bDrawTextAtImagePos )
 {
 	DBG_ASSERT( rEvt.GetDevice() == mpImplLB->GetMainWindow(), "DrawEntry?!" );
@@ -1454,3 +1494,15 @@ Rectangle ComboBox::GetBoundingRectangle
     return aRect;
 }
 // -----------------------------------------------------------------------------
+
+void ComboBox::SetBorderStyle( USHORT nBorderStyle )
+{
+	Window::SetBorderStyle( nBorderStyle );
+	if ( !IsDropDownBox() )
+	{
+		mpSubEdit->SetBorderStyle( nBorderStyle );
+		mpImplLB->SetBorderStyle( nBorderStyle );
+	}
+}
+// -----------------------------------------------------------------------------
+
Index: vcl/source/control/ctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/ctrl.cxx,v
retrieving revision 1.10
retrieving revision 1.14
diff -u -p -u -r1.10 -r1.14
--- vcl/source/control/ctrl.cxx	4 Jun 2003 11:21:43 -0000	1.10
+++ vcl/source/control/ctrl.cxx	18 May 2004 10:54:12 -0000	1.14
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_CTRL_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -79,8 +77,11 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 
-#pragma hdrstop
 
 using namespace vcl;
 
@@ -205,7 +206,6 @@ long ControlLayoutData::GetIndexForPoint
 
 long Control::GetIndexForPoint( const Point& rPoint ) const
 {
-    long nIndex = -1;
     if( ! mpLayoutData )
         FillLayoutData();
     return mpLayoutData ? mpLayoutData->GetIndexForPoint( rPoint ) : -1;
@@ -266,6 +266,49 @@ Pair Control::GetLineStartEnd( long nLin
 
 // -----------------------------------------------------------------------
 
+long ControlLayoutData::ToRelativeLineIndex( long nIndex ) const
+{
+    // is the index sensible at all ?
+    if( nIndex >= 0 && nIndex < m_aDisplayText.Len() )
+    {
+        int nDisplayLines = m_aLineIndices.size();
+        // if only 1 line exists, then absolute and relative index are
+        // identical -> do nothing
+        if( nDisplayLines > 1 )
+        {
+            int nLine;
+            for( nLine = nDisplayLines-1; nLine >= 0; nLine-- )
+            {
+                if( m_aLineIndices[nLine] <= nIndex )
+                {
+                    nIndex -= m_aLineIndices[nLine];
+                    break;
+                }
+            }
+            if( nLine < 0 )
+            {
+                DBG_ASSERT( nLine >= 0, "ToRelativeLineIndex failed" );
+                nIndex = -1;
+            }
+        }
+    }
+    else
+        nIndex = -1;
+
+    return nIndex;
+}
+
+// -----------------------------------------------------------------------
+
+long Control::ToRelativeLineIndex( long nIndex ) const
+{
+    if( ! mpLayoutData )
+        FillLayoutData();
+    return mpLayoutData ? mpLayoutData->ToRelativeLineIndex( nIndex ) : -1;
+}
+
+// -----------------------------------------------------------------------
+
 String Control::GetDisplayText() const
 {
     if( ! mpLayoutData )
@@ -371,7 +414,7 @@ void Control::SetLayoutDataParent( const
 
 // -----------------------------------------------------------------
 
-void Control::ImplSubControlLayoutChanged() const
+void Control::ImplClearLayoutData() const
 {
     delete mpLayoutData, mpLayoutData = NULL;
 }
@@ -381,5 +424,5 @@ void Control::ImplSubControlLayoutChange
 ControlLayoutData::~ControlLayoutData()
 {
     if( m_pParent )
-        m_pParent->ImplSubControlLayoutChanged();
+        m_pParent->ImplClearLayoutData();
 }
Index: vcl/source/control/edit.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/edit.cxx,v
retrieving revision 1.59.60.1
retrieving revision 1.65
diff -u -p -u -r1.59.60.1 -r1.65
--- vcl/source/control/edit.cxx	15 Jan 2004 12:48:13 -0000	1.59.60.1
+++ vcl/source/control/edit.cxx	17 Jun 2004 12:12:07 -0000	1.65
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_EDIT_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -159,7 +157,7 @@
 #endif
 
 
-#pragma hdrstop
+
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
@@ -390,18 +388,26 @@ void Edit::ImplInit( Window* pParent, Wi
     if( Application::GetSettings().GetLayoutRTL() )
         mnAlign	= EDIT_ALIGN_RIGHT;
 
-	if ( nStyle & WB_RIGHT )
-		mnAlign = EDIT_ALIGN_RIGHT;
-	else if ( nStyle & WB_CENTER )
-		mnAlign = EDIT_ALIGN_CENTER;
+    if ( nStyle & WB_RIGHT )
+        mnAlign = EDIT_ALIGN_RIGHT;
+    else if ( nStyle & WB_CENTER )
+        mnAlign = EDIT_ALIGN_CENTER;
 
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
-	SetBackground( Wallpaper( rStyleSettings.GetFieldColor() ) );
-	SetFillColor( rStyleSettings.GetFieldColor() );
-	SetCursor( new Cursor );
+    const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+    if ( IsNativeControlSupported(ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE) )
+    {
+        SetBackground();
+        SetFillColor();
+    }
+    else
+    {
+        SetBackground( Wallpaper( rStyleSettings.GetFieldColor() ) );
+        SetFillColor( rStyleSettings.GetFieldColor() );
+    }
+    SetCursor( new Cursor );
 
-	SetPointer( Pointer( POINTER_TEXT ) );
-	ImplInitSettings( TRUE, TRUE, TRUE );
+    SetPointer( Pointer( POINTER_TEXT ) );
+    ImplInitSettings( TRUE, TRUE, TRUE );
 
     uno::Reference< datatransfer::dnd::XDragGestureListener> xDGL( mxDnDListener, uno::UNO_QUERY );
     uno::Reference< datatransfer::dnd::XDragGestureRecognizer > xDGR = GetDragGestureRecognizer();
@@ -470,7 +476,13 @@ void Edit::ImplInitSettings( BOOL bFont,
 
 	if ( bBackground )
 	{
-		if( IsControlBackground() )
+		if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		{
+			// Transparent background
+			SetBackground();
+			SetFillColor();
+		}
+		else if ( IsControlBackground() )
 		{
 			SetBackground( GetControlBackground() );
 			SetFillColor( GetControlBackground() );
@@ -528,15 +540,15 @@ void Edit::ImplRepaint( xub_StrLen nStar
     nStart = 0;
     nEnd = aText.Len();
 
-    long	nDXBuffer[256];
-    long*	pDXBuffer = NULL;
-    long*	pDX = nDXBuffer;
+    sal_Int32	nDXBuffer[256];
+    sal_Int32*	pDXBuffer = NULL;
+    sal_Int32*	pDX = nDXBuffer;
 
     if( aText.Len() )
     {
         if( 2*aText.Len() > sizeof(nDXBuffer)/sizeof(nDXBuffer[0]) )
         {
-            pDXBuffer = new long[2*(aText.Len()+1)];
+            pDXBuffer = new sal_Int32[2*(aText.Len()+1)];
             pDX = pDXBuffer;
         }
 
@@ -576,7 +588,11 @@ void Edit::ImplRepaint( xub_StrLen nStar
 	else
 		SetTextColor( rStyleSettings.GetDisableColor() );
 
-	SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
+	// Set background color of the normal text
+	if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		SetTextFillColor();
+	else
+		SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
 
 	BOOL bDrawSelection = maSelection.Len() && ( HasFocus() || ( GetStyle() & WB_NOHIDESELECTION ) || mbActivePopup );
 
@@ -596,7 +612,8 @@ void Edit::ImplRepaint( xub_StrLen nStar
 		Selection aTmpSel( maSelection );
 		aTmpSel.Justify();
         // selection is highlighted
-        for( int i = 0; i < aText.Len(); i++ )
+        int i;
+        for( i = 0; i < aText.Len(); i++ )
         {
             Rectangle aRect( aPos, Size( 10, nTH ) );
             aRect.Left() = pDX[2*i] + mnXOffset + ImplGetExtraOffset();
@@ -619,8 +636,14 @@ void Edit::ImplRepaint( xub_StrLen nStar
         // draw normal text
         Color aNormalTextColor = GetTextColor();
         SetClipRegion( aNormalClipRegion );
-        SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
+
+	    // Set background color when part of the text is selected
+	    if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		    SetTextFillColor();
+	    else
+		    SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
 		DrawText( aPos, aText, nStart, nEnd - nStart );
+
         // draw highlighted text
         SetClipRegion( aHiglightClipRegion );
         SetTextColor( rStyleSettings.GetHighlightTextColor() );
@@ -853,6 +876,51 @@ void Edit::ImplSetText( const XubString&
 
 // -----------------------------------------------------------------------
 
+int Edit::ImplGetNativeControlType()
+{
+    int nCtrl = 0;
+    Window *pControl = mbIsSubEdit ? GetParent() : this;
+
+    switch( pControl->GetType() )
+    {
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            nCtrl = CTRL_COMBOBOX;
+            break;
+
+        case WINDOW_EDIT:
+        case WINDOW_MULTILINEEDIT:
+        case WINDOW_PATTERNFIELD:
+        case WINDOW_METRICFIELD:
+        case WINDOW_CURRENCYFIELD:
+        case WINDOW_DATEFIELD:
+        case WINDOW_TIMEFIELD:
+        case WINDOW_LONGCURRENCYFIELD:
+        case WINDOW_NUMERICFIELD:
+        case WINDOW_SPINFIELD:
+            if( pControl->GetStyle() & WB_SPIN )
+                nCtrl = CTRL_SPINBOX;
+            else
+            {
+                if ( GetWindow( WINDOW_BORDER ) != this )
+                    nCtrl = CTRL_EDITBOX;
+                else
+                    nCtrl = CTRL_EDITBOX_NOBORDER;
+            }
+            break;
+
+        default:
+            nCtrl = CTRL_EDITBOX;
+    }
+    return nCtrl;
+}
+
 void Edit::ImplClearBackground( long nXStart, long nXEnd )
 {
 	Point aTmpPoint;
@@ -865,7 +933,43 @@ void Edit::ImplClearBackground( long nXS
 	if ( pCursor )
 		pCursor->Hide();
 
-	Erase( aRect );
+    if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+    {
+        // draw the inner part by painting the whole control using its border window
+        Window *pControl = this;
+        Window *pBorder = GetWindow( WINDOW_BORDER );
+        if( pBorder == this )
+        {
+            // we have no border, use parent
+            pControl = mbIsSubEdit ? GetParent() : this;
+            pBorder = pControl->GetWindow( WINDOW_BORDER );
+        }
+        
+        if( pBorder )
+        {
+            // set proper clipping region to not overdraw the whole control
+            Region aClipRgn = GetPaintRegion();
+            if( !aClipRgn.IsNull() )
+            {
+                // transform clipping region to border window's coordinate system
+                Point aBorderOffs;
+                aBorderOffs = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aBorderOffs ) );
+                aClipRgn.Move( aBorderOffs.X(), aBorderOffs.Y() );
+
+                Region oldRgn( pBorder->GetClipRegion() );
+                pBorder->SetClipRegion( aClipRgn );
+
+                pBorder->Paint( Rectangle() );
+
+                pBorder->SetClipRegion( oldRgn );
+            }
+            else
+                pBorder->Paint( Rectangle() );
+
+        }
+    }
+    else
+	    Erase( aRect );
 
 	if ( pCursor )
 		pCursor->Show();
@@ -883,15 +987,15 @@ void Edit::ImplShowCursor( BOOL bOnlyIfV
 
     long nTextPos = 0;
 
-    long	nDXBuffer[256];
-    long*	pDXBuffer = NULL;
-    long*	pDX = nDXBuffer;
+    sal_Int32	nDXBuffer[256];
+    sal_Int32*	pDXBuffer = NULL;
+    sal_Int32*	pDX = nDXBuffer;
 
     if( aText.Len() )
     {
         if( 2*aText.Len() > sizeof(nDXBuffer)/sizeof(nDXBuffer[0]) )
         {
-            pDXBuffer = new long[2*(aText.Len()+1)];
+            pDXBuffer = new sal_Int32[2*(aText.Len()+1)];
             pDX = pDXBuffer;
         }
         
@@ -1005,12 +1109,12 @@ xub_StrLen Edit::ImplGetCharPos( const P
     xub_StrLen nIndex = STRING_LEN;
     String aText = ImplGetText();
 
-    long	nDXBuffer[256];
-    long*	pDXBuffer = NULL;
-    long*	pDX = nDXBuffer;
+    sal_Int32	nDXBuffer[256];
+    sal_Int32*	pDXBuffer = NULL;
+    sal_Int32*	pDX = nDXBuffer;
     if( 2*aText.Len() > sizeof(nDXBuffer)/sizeof(nDXBuffer[0]) )
     {
-        pDXBuffer = new long[2*(aText.Len()+1)];
+        pDXBuffer = new sal_Int32[2*(aText.Len()+1)];
         pDX = pDXBuffer;
     }
 
@@ -1840,6 +1944,16 @@ void Edit::Command( const CommandEvent& 
 		SetInsertMode( bInsertMode );
 
 		ImplModified();
+
+        // #i25161# call auto complete handler for ext text commit also
+        if ( maAutocompleteHdl.IsSet() )
+        {
+            if ( (maSelection.Min() == maSelection.Max()) && (maSelection.Min() == maText.Len()) )
+            {
+                meAutocompleteAction = AUTOCOMPLETE_KEYINPUT;
+                maAutocompleteHdl.Call( this );
+            }
+        }
 	}
 	else if ( rCEvt.GetCommand() == COMMAND_EXTTEXTINPUT )
 	{
@@ -2517,7 +2631,6 @@ void Edit::drop( const ::com::sun::star:
 	if ( !mbReadOnly && mpDDInfo )
 	{
 		ImplHideDDCursor();
-		Point aMousePos( rDTDE.LocationX, rDTDE.LocationY );
 
 		Selection aSel( maSelection );
 		aSel.Justify();
@@ -2563,7 +2676,7 @@ void Edit::dragEnter( const ::com::sun::
     {
 		mpDDInfo = new DDInfo;
     }
-    sal_Bool bTextContent = mbReadOnly ? sal_False : sal_True;   // quiery from rDTDEE.SupportedDataFlavors()
+//    sal_Bool bTextContent = mbReadOnly ? sal_False : sal_True;   // quiery from rDTDEE.SupportedDataFlavors()
 //    if ( bTextContent )
 //        rDTDEE.Context->acceptDrop(datatransfer::dnd::DNDConstants::ACTION_COPY_OR_MOVE);
 //    else
Index: vcl/source/control/field.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/field.cxx,v
retrieving revision 1.9
retrieving revision 1.11
diff -u -p -u -r1.9 -r1.11
--- vcl/source/control/field.cxx	25 Oct 2002 11:44:53 -0000	1.9
+++ vcl/source/control/field.cxx	6 Jan 2004 13:17:34 -0000	1.11
@@ -59,19 +59,17 @@
  *
  ************************************************************************/
 
+#ifndef _BIGINT_HXX
 #define _TOOLS_BIGINT
-#define _SV_FIELD_CXX
+#include <tools/bigint.hxx>
+#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
-#ifndef _BIGINT_HXX
-#include <tools/bigint.hxx>
-#endif
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _TOOLS_RESARY_HXX
 #include <tools/resary.hxx>
@@ -85,7 +83,7 @@
 #include <svdata.hxx>
 #include <unohelp.hxx>
 
-#pragma hdrstop
+
 
 #ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
 #include <unotools/localedatawrapper.hxx>
@@ -395,14 +378,6 @@ void FormatterBase::ImplSetText( const X
 {
     if ( mpField )
     {
-        // !!! TH-18.2.99: Wenn wir Zeit haben sollte mal geklaert werden,
-        // !!! warum SetText() intern bei gleichem Text nicht ImplSetSelection
-        // !!! aufruft, sondern etwas anders macht, denn sehr haeufig kommt
-        // !!! hier der gleiche Text an.
-
-        // ggf. bleibt der Text gleich, aber die Selektion wird geaendert...
-        BOOL bTextChanged = (mpField->GetText() != rText);
-
         if ( pNewSelection )
             mpField->SetText( rText, *pNewSelection );
         else
@@ -412,14 +387,6 @@ void FormatterBase::ImplSetText( const X
             mpField->SetText( rText, aSel );
         }
 
-        // !!! TH-18.2.99: Wenn wir Zeit haben sollte mal geklaert werden,
-        // !!! warum hier der Modify-Handler gerufen wird !!!
-
-        // !!! MT-8.7.99: Erstmal auskommentiert, koentest recht haben,
-        // !!! Modify wird zu oft gerufen.
-//      if ( MustBeReformatted() && bTextChanged )
-//          mpField->Edit::Modify();    // Nur damit Modify-Hdl gerufen wird.
-
         MarkToBeReformatted( FALSE );
     }
 }
@@ -1168,48 +1135,6 @@ static FieldUnit ImplMetricGetUnit( cons
 {
     XubString aStr = ImplMetricGetUnitText( rStr );
     return ImplStringToMetric( aStr );
-/*
-    aStr.ToLowerAscii();
-
-    if ( aStr.EqualsAscii( "mm" ) )             // Milimeter
-        return FUNIT_MM;
-    else if ( aStr.EqualsAscii( "cm" ) )        // Centimeter
-        return FUNIT_CM;
-    else if ( aStr.EqualsAscii( "m" ) )         // Meter
-        return FUNIT_M;
-    else if ( aStr.EqualsAscii( "km" ) )        // Km
-        return FUNIT_KM;
-    else if ( aStr.EqualsAscii( "twip" ) )      // Twips
-        return FUNIT_TWIP;
-    else if ( aStr.EqualsAscii( "twips" ) )     // Twips
-        return FUNIT_TWIP;
-    else if ( aStr.EqualsAscii( "pt" ) )        // Point
-        return FUNIT_POINT;
-    else if ( aStr.EqualsAscii( "pi" ) )        // Pica
-        return FUNIT_PICA;
-    else if ( aStr.EqualsAscii( "\"" ) )        // Inch
-        return FUNIT_INCH;
-    else if ( aStr.EqualsAscii( "in" ) )        // Inch
-        return FUNIT_INCH;
-    else if ( aStr.EqualsAscii( "inch" ) )      // Inch
-        return FUNIT_INCH;
-    else if ( aStr.EqualsAscii( "'" ) )         // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "ft" ) )        // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "foot" ) )      // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "feet" ) )      // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "mile" ) )      // Mile
-        return FUNIT_MILE;
-    else if ( aStr.EqualsAscii( "miles" ) )     // Mile
-        return FUNIT_MILE;
-    else if ( aStr.EqualsAscii( "%" ) )         // Percent
-        return FUNIT_PERCENT;
-    else
-        return FUNIT_NONE;
-*/
 }
 
 #define K *1000L
@@ -1289,6 +1214,7 @@ long MetricField::ConvertValue( long nVa
 
 // -----------------------------------------------------------------------
 
+// MT: Not needed?
 long MetricField::ConvertValue( long nValue, USHORT nDigits,
                                 MapUnit eInUnit, FieldUnit eOutUnit )
 {
@@ -1297,10 +1223,11 @@ long MetricField::ConvertValue( long nVa
 
 // -----------------------------------------------------------------------
 
+// MT: Not needed?
 long MetricField::ConvertValue( long nValue, USHORT nDigits,
                                 FieldUnit eInUnit, MapUnit eOutUnit )
 {
-    return (long)ConvertValue( nValue, nDigits, eInUnit, eOutUnit );
+    return (long)ConvertDoubleValue( nValue, nDigits, eInUnit, eOutUnit );
 }
 
 // -----------------------------------------------------------------------
@@ -1591,48 +1518,6 @@ XubString MetricFormatter::CreateFieldTe
         aStr += ImplMetricToString( meUnit );
 
     return aStr;
-    /*
-    // Einheit dranhaengen
-    switch ( meUnit )
-    {
-        case FUNIT_MM:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "mm" ) );
-            break;
-        case FUNIT_CM:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "cm" ) );
-            break;
-        case FUNIT_M:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "m" ) );
-            break;
-        case FUNIT_KM:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "km" ) );
-            break;
-        case FUNIT_TWIP:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "twips" ) );
-            break;
-        case FUNIT_POINT:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "pt" ) );
-            break;
-        case FUNIT_PICA:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "pi" ) );
-            break;
-        case FUNIT_INCH:
-            aStr.Append( '"' );
-            break;
-        case FUNIT_FOOT:
-            aStr.Append( '\'' );
-            break;
-        case FUNIT_MILE:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "miles" ) );
-            break;
-        case FUNIT_CUSTOM:
-            aStr += maCustomUnitText;
-            break;
-        default:
-            break;
-    }
-    return aStr;
-    */
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/field2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/field2.cxx,v
retrieving revision 1.11
retrieving revision 1.16
diff -u -p -u -r1.11 -r1.16
--- vcl/source/control/field2.cxx	2 Sep 2002 13:41:36 -0000	1.11
+++ vcl/source/control/field2.cxx	2 Apr 2004 10:35:20 -0000	1.16
@@ -59,14 +59,12 @@
  *
  ************************************************************************/
 
-#define _SV_FIELD2_CXX
-
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -77,9 +75,6 @@
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
-#ifndef _SV_SYSTEM_HXX
-#include <system.hxx>
-#endif
 #ifndef _SV_SOUND_HXX
 #include <sound.hxx>
 #endif
@@ -106,7 +101,7 @@
 #include <com/sun/star/i18n/KCharacterType.hpp>
 #endif
 
-#pragma hdrstop
+
 
 #ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
 #include <unotools/localedatawrapper.hxx>
@@ -1191,35 +1186,14 @@ static ExtDateFieldFormat ImplGetExtForm
     {
         case DMY:   return XTDATEF_SHORT_DDMMYY;
         case MDY:   return XTDATEF_SHORT_MMDDYY;
-        case YMD:   return XTDATEF_SHORT_YYMMDD;
+        default:    return XTDATEF_SHORT_YYMMDD;
     }
 }
 
-static USHORT ImplCutMonthFromString( XubString& rStr, const CalendarWrapper& rCalendarWrapper )
-{
-    USHORT nPos;
-
-    //Nach Monatsnamen suchen
-    for ( USHORT i=1; i <= 12; i++ )
-    {
-        String aMonthName = rCalendarWrapper.getMonths()[i-1].FullName;
-        // Voller Monatsname ?
-        nPos = rStr.Search( aMonthName );
-        if ( nPos != STRING_NOTFOUND )
-        {
-            rStr.Erase( 0, nPos + aMonthName.Len() );
-            return i;
-        }
-        // Kurzer Monatsname ?
-        String aAbbrevMonthName = rCalendarWrapper.getMonths()[i-1].AbbrevName;
-        nPos = rStr.Search( aAbbrevMonthName );
-        if ( nPos != STRING_NOTFOUND )
-        {
-            rStr.Erase( 0, nPos + aAbbrevMonthName.Len() );
-            return i;
-        }
-    }
+// -----------------------------------------------------------------------
 
+static USHORT ImplCutNumberFromString( XubString& rStr )
+{
     // Nach Zahl suchen
     while ( rStr.Len() && !(rStr.GetChar( 0 ) >= '0' && rStr.GetChar( 0 ) <= '9') )
         rStr.Erase( 0, 1 );
@@ -1236,20 +1210,36 @@ static USHORT ImplCutMonthFromString( Xu
 
 // -----------------------------------------------------------------------
 
-static USHORT ImplCutNumberFromString( XubString& rStr )
+static BOOL ImplCutMonthName( XubString& rStr, const XubString& _rLookupMonthName )
 {
-    // Nach Zahl suchen
-    while ( rStr.Len() && !(rStr.GetChar( 0 ) >= '0' && rStr.GetChar( 0 ) <= '9') )
-        rStr.Erase( 0, 1 );
-    if ( !rStr.Len() )
-        return 0;
-    XubString aNumStr;
-    while ( rStr.Len() && (rStr.GetChar( 0 ) >= '0' && rStr.GetChar( 0 ) <= '9') )
+    USHORT nPos = rStr.Search( _rLookupMonthName );
+    if ( nPos != STRING_NOTFOUND )
     {
-        aNumStr.Insert( rStr.GetChar( 0 ) );
-        rStr.Erase( 0, 1 );
+        rStr.Erase( 0, nPos + _rLookupMonthName.Len() );
+        return TRUE;
     }
-    return (USHORT)aNumStr.ToInt32();
+    return FALSE;
+}
+
+// -----------------------------------------------------------------------
+
+static USHORT ImplCutMonthFromString( XubString& rStr, const CalendarWrapper& rCalendarWrapper )
+{
+    // search for a month' name
+    for ( USHORT i=1; i <= 12; i++ )
+    {
+        String aMonthName = rCalendarWrapper.getMonths()[i-1].FullName;
+        // long month name?
+        if ( ImplCutMonthName( rStr, aMonthName ) )
+            return i;
+
+        // short month name?
+        String aAbbrevMonthName = rCalendarWrapper.getMonths()[i-1].AbbrevName;
+        if ( ImplCutMonthName( rStr, aAbbrevMonthName ) )
+            return i;
+    }
+
+    return ImplCutNumberFromString( rStr );
 }
 
 // -----------------------------------------------------------------------
@@ -1428,11 +1418,6 @@ XubString DateFormatter::ImplGetDateAsTe
     BOOL bShowCentury = FALSE;
     switch ( GetExtDateFormat() )
     {
-        case XTDATEF_SYSTEM_SHORT:
-        {
-            bShowCentury = FALSE;   // ??? DEFAULT ???
-        }
-        break;
         case XTDATEF_SYSTEM_SHORT_YYYY:
         case XTDATEF_SYSTEM_LONG:
         case XTDATEF_SHORT_DDMMYYYY:
@@ -1443,6 +1428,10 @@ XubString DateFormatter::ImplGetDateAsTe
             bShowCentury = TRUE;
         }
         break;
+        default:
+        {
+            bShowCentury = FALSE;
+        }
     }
 
     if ( !bShowCentury )
@@ -1594,6 +1583,12 @@ static void ImplDateIncrementYear( Date&
 }
 
 // -----------------------------------------------------------------------
+BOOL DateFormatter::ImplAllowMalformedInput() const
+{
+    return ( NULL != GetField() ) && ( ( GetField()->GetStyle() & 0x80000000 ) != 0 );
+}
+
+// -----------------------------------------------------------------------
 
 void DateField::ImplDateSpinArea( BOOL bUp )
 {
@@ -1696,10 +1691,11 @@ void DateFormatter::ImplInit()
 // -----------------------------------------------------------------------
 
 DateFormatter::DateFormatter() :
+    maFieldDate( 0 ),
+    maLastDate( 0 ),
     maMin( 1, 1, 1900 ),
     maMax( 31, 12, 2200 ),
-    maFieldDate( 0 ),
-    maLastDate( 0 )
+    mbEnforceValidValue( TRUE )
 {
     ImplInit();
 }
@@ -1776,26 +1772,6 @@ CalendarWrapper& DateFormatter::GetCalen
     return *mpCalendarWrapper;
 }
 
-#if SUPD < 651
-
-// -----------------------------------------------------------------------
-
-void DateFormatter::SetDateFormat( DateFormat eFormat )
-{
-    DBG_ERROR( "Who is using DateFormatter::SetDateFormat?\nPlease report to Malte Timmermann" );
-    mnDateFormat = eFormat;
-}
-
-// -----------------------------------------------------------------------
-
-DateFormat DateFormatter::GetDateFormat() const
-{
-    DBG_ERROR( "Who is using DateFormatter::GetDateFormat?\nPlease report to Malte Timmermann" );
-    return ( mnDateFormat != 0xFFFF ) ? (DateFormat)mnDateFormat : ImplGetLocaleDataWrapper().getDateFormat();
-}
-
-#endif
-
 // -----------------------------------------------------------------------
 
 void DateFormatter::SetExtDateFormat( ExtDateFieldFormat eFormat )
@@ -1894,6 +1870,8 @@ void DateFormatter::SetShowDateCentury( 
                 SetExtDateFormat( XTDATEF_SHORT_YYYYMMDD );     break;
             case XTDATEF_SHORT_YYMMDD_DIN5008:
                 SetExtDateFormat( XTDATEF_SHORT_YYYYMMDD_DIN5008 ); break;
+            default:
+                ;
         }
     }
     else
@@ -1911,6 +1889,8 @@ void DateFormatter::SetShowDateCentury( 
                 SetExtDateFormat( XTDATEF_SHORT_YYMMDD );       break;
             case XTDATEF_SHORT_YYYYMMDD_DIN5008:
                 SetExtDateFormat( XTDATEF_SHORT_YYMMDD_DIN5008 );  break;
+            default:
+                ;
         }
     }
 
@@ -2000,10 +1980,15 @@ Date DateFormatter::GetDate() const
             // !!! allen anderen Feldern anders behandelt wird.
             // !!! Siehe dazu Bug: 52304
 
-            if ( maLastDate.GetDate() )
-                aDate = maLastDate;
-            else if ( !IsEmptyFieldValueEnabled() )
-                aDate = Date();
+            if ( !ImplAllowMalformedInput() )
+            {
+                if ( maLastDate.GetDate() )
+                    aDate = maLastDate;
+                else if ( !IsEmptyFieldValueEnabled() )
+                    aDate = Date();
+            }
+            else
+                aDate = GetInvalidDate();
         }
     }
 
@@ -2021,7 +2006,9 @@ Date DateFormatter::GetRealDate() const
 
     if ( GetField() )
     {
-        ImplDateGetValue( GetField()->GetText(), aDate, GetExtDateFormat(TRUE), ImplGetLocaleDataWrapper(), GetCalendarWrapper(), GetFieldSettings() );
+        if ( !ImplDateGetValue( GetField()->GetText(), aDate, GetExtDateFormat(TRUE), ImplGetLocaleDataWrapper(), GetCalendarWrapper(), GetFieldSettings() ) )
+            if ( ImplAllowMalformedInput() )
+                aDate = GetInvalidDate();
     }
 
     return aDate;
@@ -2216,7 +2203,18 @@ long DateField::Notify( NotifyEvent& rNE
 
             BOOL bTextLen = GetText().Len() != 0;
             if ( bTextLen || !IsEmptyFieldValueEnabled() )
-                Reformat();
+            {
+                if ( !ImplAllowMalformedInput() )
+                    Reformat();
+                else
+                {
+                    Date aDate( 0, 0, 0 );
+                    if ( ImplDateGetValue( GetText(), aDate, GetExtDateFormat(TRUE), ImplGetLocaleDataWrapper(), GetCalendarWrapper(), GetFieldSettings() ) )
+                        // even with strict text analysis, our text is a valid date -> do a complete
+                        // reformat
+                        Reformat();
+                }
+            }
             else if ( !bTextLen && IsEmptyFieldValueEnabled() )
             {
                 ResetLastDate();
@@ -2477,9 +2466,47 @@ static BOOL ImplTimeProcessKeyInput( Edi
 
 // -----------------------------------------------------------------------
 
+static BOOL ImplIsOnlyDigits( const String& _rStr )
+{
+    const sal_Unicode* _pChr = _rStr.GetBuffer();
+    for ( xub_StrLen i = 0; i < _rStr.Len(); ++i, ++_pChr )
+    {
+        if ( *_pChr < '0' || *_pChr > '9' )
+            return FALSE;
+    }
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+static BOOL ImplIsValidTimePortion( BOOL _bSkipInvalidCharacters, const String& _rStr )
+{
+    if ( !_bSkipInvalidCharacters )
+    {
+        if ( ( _rStr.Len() > 2 ) || ( _rStr.Len() < 1 ) || !ImplIsOnlyDigits( _rStr ) )
+            return FALSE;
+    }
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+static BOOL ImplCutTimePortion( String& _rStr, xub_StrLen _nSepPos, BOOL _bSkipInvalidCharacters, short* _pPortion )
+{
+    String sPortion = _rStr.Copy( 0, _nSepPos );
+    _rStr.Erase( 0, _nSepPos + 1 );
+
+    if ( !ImplIsValidTimePortion( _bSkipInvalidCharacters, sPortion ) )
+        return FALSE;
+    *_pPortion = (short)sPortion.ToInt32();
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
 static BOOL ImplTimeGetValue( const XubString& rStr, Time& rTime,
                               TimeFieldFormat eFormat, TimeFormat eTimeFormat, BOOL bDuration,
-                              const LocaleDataWrapper& rLocaleDataWrapper )
+                              const LocaleDataWrapper& rLocaleDataWrapper, BOOL _bSkipInvalidCharacters = TRUE )
 {
     XubString   aStr    = rStr;
     short       nHour   = 0;
@@ -2518,25 +2545,25 @@ static BOOL ImplTimeGetValue( const XubS
     if ( eFormat != TIMEF_SEC_CS )
     {
         if ( nSepPos == STRING_NOTFOUND )
+            nSepPos = aStr.Len();
+        if ( !ImplCutTimePortion( aStr, nSepPos, _bSkipInvalidCharacters, &nHour ) )
             return FALSE;
-        nHour = (short)aStr.Copy( 0, nSepPos ).ToInt32();
-        aStr.Erase( 0, nSepPos+1 );
 
         nSepPos = aStr.Search( rLocaleDataWrapper.getTimeSep() );
         if ( aStr.GetChar( 0 ) == '-' )
             bNegative = TRUE;
         if ( nSepPos != STRING_NOTFOUND )
         {
-            nMinute = (short)aStr.Copy( 0, nSepPos ).ToInt32();
-            aStr.Erase( 0, nSepPos+1 );
+            if ( !ImplCutTimePortion( aStr, nSepPos, _bSkipInvalidCharacters, &nMinute ) )
+                return FALSE;
 
             nSepPos = aStr.Search( rLocaleDataWrapper.getTimeSep() );
             if ( aStr.GetChar( 0 ) == '-' )
                 bNegative = TRUE;
             if ( nSepPos != STRING_NOTFOUND )
             {
-                nSecond = (short)aStr.Copy( 0, nSepPos ).ToInt32();
-                aStr.Erase( 0, nSepPos+1 );
+                if ( !ImplCutTimePortion( aStr, nSepPos, _bSkipInvalidCharacters, &nSecond ) )
+                    return FALSE;
                 if ( aStr.GetChar( 0 ) == '-' )
                     bNegative = TRUE;
                 n100Sec = (short)aStr.ToInt32();
@@ -2745,6 +2772,12 @@ BOOL TimeFormatter::ImplTimeReformat( co
 }
 
 // -----------------------------------------------------------------------
+BOOL TimeFormatter::ImplAllowMalformedInput() const
+{
+    return ( NULL != GetField() ) && ( ( GetField()->GetStyle() & 0x80000000 ) != 0 );
+}
+
+// -----------------------------------------------------------------------
 
 void TimeField::ImplTimeSpinArea( BOOL bUp )
 {
@@ -2826,10 +2859,11 @@ void TimeFormatter::ImplInit()
 // -----------------------------------------------------------------------
 
 TimeFormatter::TimeFormatter() :
+    maLastTime( 0, 0 ),
     maMin( 0, 0 ),
     maMax( 23, 59, 59, 99 ),
     maFieldTime( 0, 0 ),
-    maLastTime( 0, 0 )
+    mbEnforceValidValue( TRUE )
 {
     ImplInit();
 }
@@ -3055,7 +3089,8 @@ Time TimeFormatter::GetTime() const
 
     if ( GetField() )
     {
-        if ( ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper() ) )
+        BOOL bAllowMailformed = ImplAllowMalformedInput();
+        if ( ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper(), !bAllowMailformed ) )
         {
             if ( aTime > GetMax() )
                 aTime = GetMax();
@@ -3063,7 +3098,12 @@ Time TimeFormatter::GetTime() const
                 aTime = GetMin();
         }
         else
-            aTime = maLastTime;
+        {
+            if ( bAllowMailformed )
+                aTime = GetInvalidTime();
+            else
+                aTime = maLastTime;
+        }
     }
 
     return aTime;
@@ -3077,7 +3117,10 @@ Time TimeFormatter::GetRealTime() const
 
     if ( GetField() )
     {
-        ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper() );
+        BOOL bAllowMailformed = ImplAllowMalformedInput();
+        if ( !ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper(), !bAllowMailformed ) )
+            if ( bAllowMailformed )
+                aTime = GetInvalidTime();
     }
 
     return aTime;
@@ -3201,7 +3244,18 @@ long TimeField::Notify( NotifyEvent& rNE
     else if ( rNEvt.GetType() == EVENT_LOSEFOCUS )
     {
         if ( MustBeReformatted() && (GetText().Len() || !IsEmptyFieldValueEnabled()) )
-            Reformat();
+        {
+            if ( !ImplAllowMalformedInput() )
+                Reformat();
+            else
+            {
+                Time aTime( 0, 0, 0 );
+                if ( ImplTimeGetValue( GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper(), FALSE ) )
+                    // even with strict text analysis, our text is a valid time -> do a complete
+                    // reformat
+                    Reformat();
+            }
+        }
     }
 
     return SpinField::Notify( rNEvt );
Index: vcl/source/control/fixbrd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/fixbrd.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/control/fixbrd.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/fixbrd.cxx	10 May 2004 15:46:54 -0000	1.4
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_FIXBRD_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -71,7 +69,7 @@
 #include <fixbrd.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -164,8 +162,26 @@ void FixedBorder::ImplDraw( OutputDevice
 		 (rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
 		nBorderStyle |= FRAME_DRAW_MONO;
 
-	DecorationView	aDecoView( pDev );
-	aDecoView.DrawFrame( aRect, nBorderStyle );
+    /*
+    // seems only to be used in tools->options around a tabpage (ie, no tabcontrol!)
+    // as tabpages that are not embedded in a tabcontrol should not be drawn natively
+    // the fixedborder must also not be drawn (reason was, that it looks too ugly, dialogs must be redesigned)
+    Window *pWin = pDev->GetOutDevType() == OUTDEV_WINDOW ? (Window*) pDev : NULL;
+    if( !(nBorderStyle & FRAME_DRAW_MONO) && pWin && pWin->IsNativeControlSupported( CTRL_FIXEDBORDER, PART_ENTIRE_CONTROL ) )
+    {
+        ImplControlValue aControlValue;
+        Point aPt;
+        Region aCtrlRegion( Rectangle( aPt, GetOutputSizePixel() ) );
+        ControlState nState = IsEnabled() ? CTRL_STATE_ENABLED : 0;
+        pWin->DrawNativeControl( CTRL_FIXEDBORDER, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+    else
+    */
+    {
+	    DecorationView	aDecoView( pDev );
+	    aDecoView.DrawFrame( aRect, nBorderStyle );
+    }
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/fixed.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/fixed.cxx,v
retrieving revision 1.10
retrieving revision 1.12
diff -u -p -u -r1.10 -r1.12
--- vcl/source/control/fixed.cxx	17 Oct 2002 14:47:00 -0000	1.10
+++ vcl/source/control/fixed.cxx	6 Jan 2004 13:19:05 -0000	1.12
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_FIXED_CXX
-
 #ifndef _SV_DECOVIEW_HXX
 #include <decoview.hxx>
 #endif
@@ -74,9 +72,9 @@
 #include <controllayout.hxx>
 #endif
 
-#include <rc.h>
+#include <tools/rc.h>
+
 
-#pragma hdrstop
 
 // =======================================================================
 
Index: vcl/source/control/group.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/group.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/control/group.cxx	8 May 2002 16:01:30 -0000	1.2
+++ vcl/source/control/group.cxx	6 Jan 2004 13:19:32 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_GROUP_CXX
-
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
 #endif
@@ -72,10 +70,10 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/control/ilstbox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/ilstbox.cxx,v
retrieving revision 1.41
retrieving revision 1.47
diff -u -p -u -r1.41 -r1.47
--- vcl/source/control/ilstbox.cxx	24 Apr 2003 16:31:26 -0000	1.41
+++ vcl/source/control/ilstbox.cxx	17 Jun 2004 12:12:49 -0000	1.47
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_ILSTBOX_CXX
-
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -106,7 +104,7 @@
 #include <com/sun/star/accessibility/XAccessible.hpp>
 #endif
 
-#pragma hdrstop
+
 
 using namespace ::com::sun::star;
 
@@ -149,10 +147,14 @@ void ImplInitDropDownButton( PushButton*
 		pButton->SetSymbol( SYMBOL_SPIN_UPDOWN );
 	else
 		pButton->SetSymbol( SYMBOL_SPIN_DOWN );
+
+	if ( pButton->IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! pButton->IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+		pButton->SetBackground();
 }
 
 // =======================================================================
-
+
 ImplEntryList::ImplEntryList( Window* pWindow )
 {
     mpWindow = pWindow;
@@ -207,7 +209,7 @@ uno::Reference< i18n::XCollator > ImplGe
 		xCollator = vcl::unohelper::CreateCollator();
 	if( xCollator.is() )
 		xCollator->loadDefaultCollator (rLocale, 0);
-	
+
 	return xCollator;
 }
 
@@ -222,7 +224,7 @@ USHORT ImplEntryList::InsertEntry( USHOR
 	}
 	else
 	{
-		lang::Locale aLocale = Application::GetSettings().GetLocale(); 
+		lang::Locale aLocale = Application::GetSettings().GetLocale();
 		uno::Reference< i18n::XCollator > xCollator = ImplGetCollator(aLocale);
 
 		const XubString& rStr = pNewEntry->maStr;
@@ -289,8 +291,8 @@ USHORT ImplEntryList::InsertEntry( USHOR
 		{
 			// XXX this is arguable, if the exception occured because pNewEntry is
 			// garbage you wouldn't insert it. If the exception occured because the
-			// Collator implementation is garbage then give the user a chance to see 
-			// his stuff 
+			// Collator implementation is garbage then give the user a chance to see
+			// his stuff
 			Insert( pNewEntry, (ULONG)0 );
 		}
 
@@ -512,10 +514,12 @@ ImplListBoxWindow::ImplListBoxWindow( Wi
     mbHasFocusRect      = FALSE;
 	mbSimpleMode		= ( nWinStyle & WB_SIMPLEMODE ) ? TRUE : FALSE;
 	mbSort				= ( nWinStyle & WB_SORT ) ? TRUE : FALSE;
+	// pb: #106948# explicit mirroring for calc
+	mbMirroring			= FALSE;
 
 	mnCurrentPos			= LISTBOX_ENTRY_NOTFOUND;
 	mnTrackingSaveSelection = LISTBOX_ENTRY_NOTFOUND;
-	mnSeparatorPos		= LISTBOX_ENTRY_NOTFOUND;
+	mnSeparatorPos			= LISTBOX_ENTRY_NOTFOUND;
 
 	SetLineColor();
 	SetTextFillColor();
@@ -773,6 +777,16 @@ void ImplListBoxWindow::ImplHideFocusRec
 
 // -----------------------------------------------------------------------
 
+USHORT ImplListBoxWindow::GetEntryPosForPoint( const Point& rPoint ) const
+{
+    USHORT nSelect = (USHORT) ( ( rPoint.Y() + mnBorder ) / mnMaxHeight ) + (USHORT) mnTop;
+    if( nSelect < mnTop || nSelect >= mpEntryList->GetEntryCount() )
+        nSelect = LISTBOX_ENTRY_NOTFOUND;
+    return nSelect;
+}
+
+// -----------------------------------------------------------------------
+
 void ImplListBoxWindow::MouseButtonDown( const MouseEvent& rMEvt )
 {
 	mbMouseMoveSelect = FALSE;	// Nur bis zum ersten MouseButtonDown
@@ -782,8 +796,8 @@ void ImplListBoxWindow::MouseButtonDown(
 	{
 		if( rMEvt.GetClicks() == 1 )
 		{
-			USHORT nSelect = (USHORT) ( ( rMEvt.GetPosPixel().Y() + mnBorder ) / mnMaxHeight ) + (USHORT) mnTop;
-			if( nSelect < mpEntryList->GetEntryCount() )
+			USHORT nSelect = GetEntryPosForPoint( rMEvt.GetPosPixel() );
+			if( nSelect != LISTBOX_ENTRY_NOTFOUND )
 			{
 				if ( !mbMulti && GetEntryList()->GetSelectEntryCount() )
 					mnTrackingSaveSelection = GetEntryList()->GetSelectEntryPos( 0 );
@@ -815,12 +829,10 @@ void ImplListBoxWindow::MouseButtonDown(
 
 void ImplListBoxWindow::MouseMove( const MouseEvent& rMEvt )
 {
-    if ( rMEvt.IsLeaveWindow() ) 
+    if ( rMEvt.IsLeaveWindow() )
     {
 		if ( mbStackMode && IsMouseMoveSelect() && IsReallyVisible() )
 		{
-			Size aSz = GetOutputSizePixel();
-//			if ( ( rMEvt.GetPosPixel().X() < 0 ) || ( rMEvt.GetPosPixel().X() > aSz.Width() ) )
 			if ( rMEvt.GetPosPixel().Y() < 0 )
 			{
 				DeselectAll();
@@ -1212,7 +1224,7 @@ void ImplListBoxWindow::Tracking( const 
 				        if ( ( rTEvt.GetMouseEvent().GetPosPixel().Y() < 0 ) || ( rTEvt.GetMouseEvent().GetPosPixel().Y() > GetOutputSizePixel().Height() ) )
 				        {
                             BOOL bSelectionChanged = FALSE;
-                            if ( ( rTEvt.GetMouseEvent().GetPosPixel().Y() < 0 ) 
+                            if ( ( rTEvt.GetMouseEvent().GetPosPixel().Y() < 0 )
                                    && !mnCurrentPos )
                             {
                                 if ( mpEntryList->IsEntryPosSelected( 0 ) )
@@ -1525,8 +1537,6 @@ BOOL ImplListBoxWindow::ProcessKeyInput(
 		DBG_ASSERT( (nSelect != mnCurrentPos) || mbMulti, "ImplListBox: Selecting same Entry" );
 	    if( nSelect >= mpEntryList->GetEntryCount() )
             nSelect = mpEntryList->GetEntryCount()-1;
-        else if (nSelect < 0 )
-            nSelect = 0;
 		mnCurrentPos = nSelect;
 		if ( SelectEntries( nSelect, eLET, bShift, bCtrl ) )
 		{
@@ -1605,15 +1615,21 @@ void ImplListBoxWindow::DrawEntry( USHOR
 		nPos = mnUserDrawEntry; // real entry, not the matching entry from MRU
 
 	long nY = ( nPos - mnTop ) * mnMaxHeight;
+	Size aImgSz;
 
 	if( bDrawImage && mpEntryList->HasImages() && !bLayout )
 	{
 		Image aImage = mpEntryList->GetEntryImage( nPos );
 		if( !!aImage )
 		{
-			Size aImgSz = aImage.GetSizePixel();
+			aImgSz = aImage.GetSizePixel();
 			Point aPtImg( mnBorder - mnLeft, nY + ( ( mnMaxHeight - aImgSz.Height() ) / 2 ) );
 
+			// pb: #106948# explicit mirroring for calc
+			if ( mbMirroring )
+				// right aligned
+				aPtImg.X() = mnMaxWidth + mnBorder - aImgSz.Width() - mnLeft;
+
 			if ( !IsZoom() )
 			{
 				DrawImage( aPtImg, aImage );
@@ -1642,6 +1658,19 @@ void ImplListBoxWindow::DrawEntry( USHOR
 			}
             if( bLayout )
                 mpLayoutData->m_aLineIndices.push_back( mpLayoutData->m_aDisplayText.Len() );
+
+			// pb: #106948# explicit mirroring for calc
+			if ( mbMirroring )
+			{
+				// right aligned
+				long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
+				long nMaxWidth = Max( static_cast< long >( mnMaxWidth ),
+						      static_cast< long >( GetOutputSizePixel().Width() - 2*mnBorder ) );
+				aPtTxt.X() = nMaxWidth + mnBorder - GetTextWidth( aStr ) - mnLeft;
+				if ( aImgSz.Width() > 0 )
+					aPtTxt.X() -= ( aImgSz.Width() + IMG_TXT_DISTANCE );
+			}
+
 			DrawText( aPtTxt, aStr, 0, STRING_LEN, pVector, pDisplayText );
 		}
 	}
@@ -1714,7 +1743,7 @@ USHORT ImplListBoxWindow::GetDisplayLine
 {
 	USHORT nCount = mpEntryList->GetEntryCount();
 	long nHeight = GetOutputSizePixel().Height();// - mnMaxHeight + mnBorder;
-    USHORT nEntries = (nHeight + mnMaxHeight-1)/mnMaxHeight;
+    USHORT nEntries = static_cast< USHORT >( ( nHeight + mnMaxHeight - 1 ) / mnMaxHeight );
     if( nEntries > nCount-mnTop )
         nEntries = nCount-mnTop;
 
@@ -1737,6 +1766,8 @@ void ImplListBoxWindow::Resize()
 
     if ( bShowFocusRect )
         ImplShowFocusRect();
+
+    delete mpLayoutData, mpLayoutData = NULL;
 }
 
 // -----------------------------------------------------------------------
@@ -1900,6 +1931,7 @@ void ImplListBoxWindow::StateChanged( St
 		ImplInitSettings( FALSE, FALSE, TRUE );
 		Invalidate();
 	}
+    delete mpLayoutData, mpLayoutData = NULL;
 }
 
 // -----------------------------------------------------------------------
@@ -1926,6 +1958,9 @@ ImplListBox::ImplListBox( Window* pParen
 	Control( pParent, nWinStyle ),
 	maLBWindow( this, nWinStyle&(~WB_BORDER) )
 {
+    // for native widget rendering we must be able to detect this window type
+    SetType( WINDOW_LISTBOXWINDOW );
+
 	mpVScrollBar	= new ScrollBar( this, WB_VSCROLL | WB_DRAG );
 	mpHScrollBar	= new ScrollBar( this, WB_HSCROLL | WB_DRAG );
 	mpScrollBarBox	= new ScrollBarBox( this );
@@ -2192,13 +2227,17 @@ void ImplListBox::ImplResizeControls()
 	if ( mbHScroll )
 		aInnerSz.Height() -= nSBWidth;
 
-	maLBWindow.SetPosSizePixel( Point(), aInnerSz );
+	// pb: #106948# explicit mirroring for calc
+	// Scrollbar on left or right side?
+	BOOL bMirroring = maLBWindow.IsMirroring();
+	Point aWinPos( bMirroring && mbVScroll ? nSBWidth : 0, 0 );
+	maLBWindow.SetPosSizePixel( aWinPos, aInnerSz );
 
 	// ScrollBarBox
 	if( mbVScroll && mbHScroll )
 	{
-		mpScrollBarBox->SetPosSizePixel( Point( aInnerSz.Width(), aInnerSz.Height() ),
-										 Size( nSBWidth, nSBWidth ) );
+		Point aBoxPos( bMirroring ? 0 : aInnerSz.Width(), aInnerSz.Height() );
+		mpScrollBarBox->SetPosSizePixel( aBoxPos, Size( nSBWidth, nSBWidth ) );
 		mpScrollBarBox->Show();
 	}
 	else
@@ -2209,8 +2248,9 @@ void ImplListBox::ImplResizeControls()
 	// vert. ScrollBar
 	if( mbVScroll )
 	{
-		mpVScrollBar->SetPosSizePixel( Point( aOutSz.Width()-nSBWidth, 0 ),
-									   Size( nSBWidth, aInnerSz.Height() ) );
+		// Scrollbar on left or right side?
+		Point aVPos( bMirroring ? 0 : aOutSz.Width() - nSBWidth, 0 );
+		mpVScrollBar->SetPosSizePixel( aVPos, Size( nSBWidth, aInnerSz.Height() ) );
 		mpVScrollBar->Show();
 	}
 	else
@@ -2223,8 +2263,8 @@ void ImplListBox::ImplResizeControls()
 	// horz. ScrollBar
 	if( mbHScroll )
 	{
-		mpHScrollBar->SetPosSizePixel( Point( 0, aOutSz.Height()-nSBWidth ),
-									   Size( aInnerSz.Width(), nSBWidth ) );
+		Point aHPos( ( bMirroring && mbVScroll ) ? nSBWidth : 0, aOutSz.Height() - nSBWidth );
+		mpHScrollBar->SetPosSizePixel( aHPos, Size( aInnerSz.Width(), nSBWidth ) );
 		mpHScrollBar->Show();
 	}
 	else
@@ -2390,7 +2430,12 @@ XubString ImplListBox::GetMRUEntries( xu
 ImplWin::ImplWin( Window* pParent, WinBits nWinStyle ) :
 	Control ( pParent, nWinStyle )
 {
-	SetBackground( Wallpaper( GetSettings().GetStyleSettings().GetFieldColor() ) );
+	if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+		SetBackground();
+	else
+		SetBackground( Wallpaper( GetSettings().GetStyleSettings().GetFieldColor() ) );
+
 	mbInUserDraw = FALSE;
 	mbUserDrawEnabled = FALSE;
 	mnItemPos = LISTBOX_ENTRY_NOTFOUND;
@@ -2448,12 +2493,76 @@ void ImplWin::FillLayoutData() const
 
 // -----------------------------------------------------------------------
 
+long ImplWin::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+            if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+            {
+                GetParent()->GetWindow( WINDOW_BORDER )->Invalidate( INVALIDATE_NOERASE );
+                GetParent()->GetWindow( WINDOW_BORDER )->Update();
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void ImplWin::ImplDraw( bool bLayout )
 {
 	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 
+    BOOL bNativeOK = FALSE;
+
     if( ! bLayout )
     {
+        if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+        {
+	        // Repaint the (focused) area similarly to
+	        // ImplSmallBorderWindowView::DrawWindow() in
+	        // vcl/source/window/brdwin.cxx
+	        Window *pWin = GetParent();
+
+	        ImplControlValue aControlValue;
+	        ControlState nState = CTRL_STATE_ENABLED;
+	        if ( !pWin->IsEnabled() )
+		    nState &= ~CTRL_STATE_ENABLED;
+	        if ( pWin->HasFocus() )
+		    nState |= CTRL_STATE_FOCUSED;
+    	    
+	        // The listbox is painted over the entire control including the
+	        // border, but ImplWin does not contain the border => correction
+	        // needed.
+	        long nLeft, nTop, nRight, nBottom;
+	        pWin->GetBorder( nLeft, nTop, nRight, nBottom );
+	        Point aPoint( -nLeft, -nTop );
+	        Region aCtrlRegion( Rectangle( aPoint - GetPosPixel(), pWin->GetSizePixel() ) );
+
+            BOOL bMouseOver = FALSE;
+            if( GetParent() )
+            {
+                Window *pChild = GetParent()->GetWindow( WINDOW_FIRSTCHILD );
+                while( pChild && !(bMouseOver = pChild->IsMouseOver()) )
+                    pChild = pChild->GetWindow( WINDOW_NEXT );
+            }
+    	    
+            if( bMouseOver )
+                nState |= CTRL_STATE_ROLLOVER;
+
+	        bNativeOK = DrawNativeControl( CTRL_LISTBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+		        aControlValue, rtl::OUString() );
+	    }
+
         if( IsEnabled() )
         {
             if( HasFocus() )
@@ -2468,13 +2577,15 @@ void ImplWin::ImplDraw( bool bLayout )
                 if( IsControlForeground() )
                     aColor = GetControlForeground();
                 SetTextColor( aColor );
-                Erase( maFocusRect );
+		        if ( !bNativeOK )
+		            Erase( maFocusRect );
             }
         }
         else // Disabled
         {
             SetTextColor( rStyleSettings.GetDisableColor() );
-            Erase( maFocusRect );
+	        if ( !bNativeOK )
+		        Erase( maFocusRect );
         }
     }
 
@@ -2594,7 +2705,7 @@ void ImplWin::LoseFocus()
 }
 
 // =======================================================================
-
+
 ImplBtn::ImplBtn( Window* pParent, WinBits nWinStyle ) :
 	PushButton(  pParent, nWinStyle ),
 	mbDown	( FALSE )
@@ -2696,11 +2807,19 @@ void ImplListBoxFloatingWindow::SetPosSi
 
 // -----------------------------------------------------------------------
 
+void ImplListBoxFloatingWindow::Resize()
+{
+    mpImplLB->GetMainWindow()->ImplClearLayoutData();
+    FloatingWindow::Resize();
+}
+
+// -----------------------------------------------------------------------
+
 Size ImplListBoxFloatingWindow::CalcFloatSize()
 {
 	Size aFloatSz( maPrefSz );
 
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	GetBorder( nLeft, nTop, nRight, nBottom );
 
 	USHORT nLines = mpImplLB->GetEntryList()->GetEntryCount();
@@ -2783,5 +2902,7 @@ void ImplListBoxFloatingWindow::StartFlo
 
 		if ( mpImplLB->GetMainWindow()->IsGrabFocusAllowed() )
 			mpImplLB->GetMainWindow()->GrabFocus();
+
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
 	}
 }
Index: vcl/source/control/imgctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/imgctrl.cxx,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -p -u -r1.7 -r1.8
--- vcl/source/control/imgctrl.cxx	15 Aug 2002 14:48:40 -0000	1.7
+++ vcl/source/control/imgctrl.cxx	6 Jan 2004 13:20:30 -0000	1.8
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_IMGCTRL_CXX
-
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
 #endif
@@ -71,16 +69,16 @@
 ImageControl::ImageControl( Window* pParent, WinBits nStyle ) :
     FixedImage( pParent, nStyle )
 {
-    mnDummy1_mbScaleImage = TRUE;
+    mbScaleImage = TRUE;
 }
 
 // -----------------------------------------------------------------------
 
 void ImageControl::SetScaleImage( BOOL bScale )
 {
-    if ( bScale != mnDummy1_mbScaleImage )
+    if ( bScale != mbScaleImage )
     {
-        mnDummy1_mbScaleImage = bScale;
+        mbScaleImage = bScale;
         Invalidate();
     }
 }
@@ -90,7 +88,7 @@ void ImageControl::SetScaleImage( BOOL b
 BOOL ImageControl::IsScaleImage() const 
 {
     // Make inline when changing member from dummy... 
-    return (BOOL)mnDummy1_mbScaleImage; 
+    return mbScaleImage; 
 }
 
 
@@ -123,7 +121,7 @@ void ImageControl::UserDraw( const UserD
 		Image aImage( maBmp );
 		if ( !!aImage )
 		{
-			if ( mnDummy1_mbScaleImage )
+			if ( mbScaleImage )
 				rUDEvt.GetDevice()->DrawImage( rUDEvt.GetRect().TopLeft(),
 												rUDEvt.GetRect().GetSize(), 
 												aImage, nStyle );
@@ -139,7 +137,7 @@ void ImageControl::UserDraw( const UserD
 	}
 	else
 	{
-		if ( mnDummy1_mbScaleImage )
+		if ( mbScaleImage )
 		{
 			maBmp.Draw( rUDEvt.GetDevice(),
 						rUDEvt.GetRect().TopLeft(),
Index: vcl/source/control/longcurr.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/longcurr.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/control/longcurr.cxx	29 Jun 2001 10:39:19 -0000	1.5
+++ vcl/source/control/longcurr.cxx	6 Jan 2004 13:21:10 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define VCL_LONGCURR_CXX
-
 #include <sot/object.hxx>
 #define _TOOLS_BIGINT
 #include <sot/factory.hxx>
@@ -73,7 +71,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
 #include <event.hxx>
@@ -81,7 +79,7 @@
 #include <svdata.hxx>
 #include <longcurr.hxx>
 
-#pragma hdrstop
+
 
 #ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
 #include <unotools/localedatawrapper.hxx>
Index: vcl/source/control/lstbox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/lstbox.cxx,v
retrieving revision 1.22
retrieving revision 1.28
diff -u -p -u -r1.22 -r1.28
--- vcl/source/control/lstbox.cxx	12 Jun 2003 08:18:53 -0000	1.22
+++ vcl/source/control/lstbox.cxx	17 Jun 2004 12:13:15 -0000	1.28
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_LSTBOX_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -101,7 +99,7 @@
 #include <tools/debug.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -177,11 +175,11 @@ void ListBox::ImplInit( Window* pParent,
 
 	if( nStyle & WB_DROPDOWN )
 	{
-		long nLeft, nTop, nRight, nBottom;
+		sal_Int32 nLeft, nTop, nRight, nBottom;
 		GetBorder( nLeft, nTop, nRight, nBottom );
 		mnDDHeight = (USHORT)(GetTextHeight() + nTop + nBottom + 4);
 
-		mpFloatWin	= new ImplListBoxFloatingWindow( this );
+		mpFloatWin = new ImplListBoxFloatingWindow( this );
 		mpFloatWin->SetAutoWidth( TRUE );
 		mpFloatWin->SetPopupModeEndHdl( LINK( this, ListBox, ImplPopupModeEndHdl ) );
 
@@ -344,6 +342,12 @@ IMPL_LINK( ListBox, ImplClickBtnHdl, voi
 		mpBtn->SetPressed( TRUE );
 		mpFloatWin->StartFloat( TRUE );
         ImplCallEventListeners( VCLEVENT_DROPDOWN_OPEN );
+
+        ImplClearLayoutData();
+        if( mpImplLB )
+            mpImplLB->GetMainWindow()->ImplClearLayoutData();
+        if( mpImplWin )
+            mpImplWin->ImplClearLayoutData();
 	}
 
 	return 0;
@@ -366,6 +370,12 @@ IMPL_LINK( ListBox, ImplPopupModeEndHdl,
         }
     }
 
+    ImplClearLayoutData();
+    if( mpImplLB )
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
+    if( mpImplWin )
+        mpImplWin->ImplClearLayoutData();
+
     mpBtn->SetPressed( FALSE );
     ImplCallEventListeners( VCLEVENT_DROPDOWN_CLOSE );
 	return 0;
@@ -547,6 +557,8 @@ void ListBox::DataChanged( const DataCha
 		 ((rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
 		  (rDCEvt.GetFlags() & SETTINGS_STYLE)) )
 	{
+        SetBackground();    // due to a hack in Window::UpdateSettings the background must be reset 
+                            // otherwise it will overpaint NWF drawn listboxes
 		Resize();
 		mpImplLB->Resize(); // Wird nicht durch ListBox::Resize() gerufen, wenn sich die ImplLB nicht aendert.
 
@@ -619,7 +631,7 @@ void ListBox::SetPosSizePixel( long nX, 
 	if( IsDropDownBox() && ( nFlags & WINDOW_POSSIZE_SIZE ) )
 	{
 		Size aPrefSz = mpFloatWin->GetPrefSize();
-		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight > mnDDHeight ) )
+		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight >= 2*mnDDHeight ) )
 			aPrefSz.Height() = nHeight-mnDDHeight;
 		if ( nFlags & WINDOW_POSSIZE_WIDTH )
 			aPrefSz.Width() = nWidth;
@@ -639,10 +651,50 @@ void ListBox::Resize()
 	Size aOutSz = GetOutputSizePixel();
 	if( IsDropDownBox() )
 	{
+		// initialize the dropdown button size with the standard scrollbar width
 		long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
-		nSBWidth = CalcZoom( nSBWidth );
-		mpImplWin->SetPosSizePixel( 0, 0, aOutSz.Width() - nSBWidth, aOutSz.Height() );
-		mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		long	nTop = 0;
+		long	nBottom = aOutSz.Height();
+
+		Window *pBorder = GetWindow( WINDOW_BORDER );
+		ImplControlValue aControlValue;
+		Point aPoint;
+		Region aContent, aBound;
+
+		// use the full extent of the control
+		Region aArea( Rectangle(aPoint, pBorder->GetOutputSizePixel()) );
+
+		if ( GetNativeControlRegion( CTRL_LISTBOX, PART_BUTTON_DOWN,
+					aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+		{
+			// convert back from border space to local coordinates
+			aPoint = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aPoint ) );
+			aContent.Move( -aPoint.X(), -aPoint.Y() );
+
+			// use the themes drop down size for the button
+			aOutSz.Width() = aContent.GetBoundRect().Left();
+			mpBtn->SetPosSizePixel( aContent.GetBoundRect().Left(), nTop, aContent.GetBoundRect().Right(), (nBottom-nTop) );
+
+			// adjust the size of the edit field
+			if ( GetNativeControlRegion( CTRL_LISTBOX, PART_SUB_EDIT,
+						aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+			{
+				// convert back from border space to local coordinates
+				aContent.Move( -aPoint.X(), -aPoint.Y() );
+
+				// use the themes drop down size
+				Rectangle aContentRect = aContent.GetBoundRect();
+				mpImplWin->SetPosSizePixel( aContentRect.TopLeft(), aContentRect.GetSize() );
+			}
+			else
+				mpImplWin->SetSizePixel( aOutSz );
+		}
+		else
+		{
+			nSBWidth = CalcZoom( nSBWidth );
+			mpImplWin->SetPosSizePixel( 0, 0, aOutSz.Width() - nSBWidth, aOutSz.Height() );
+			mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		}
 	}
 	else
 	{
@@ -698,7 +809,13 @@ void ListBox::StateChanged( StateChanged
 		if( mpImplWin )
 		{
 			mpImplWin->Enable( IsEnabled() );
-			mpImplWin->Invalidate();
+			if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+					&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+			{
+				GetWindow( WINDOW_BORDER )->Invalidate( INVALIDATE_NOERASE );
+			}
+			else
+				mpImplWin->Invalidate();
 		}
 		if( mpBtn )
 			mpBtn->Enable( IsEnabled() );
@@ -745,8 +862,17 @@ void ListBox::StateChanged( StateChanged
 		mpImplLB->SetControlBackground( GetControlBackground() );
 		if ( mpImplWin )
 		{
-			mpImplWin->SetBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
-			mpImplWin->SetControlBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+			if ( mpImplWin->IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL) )
+			{
+				// Transparent background
+				mpImplWin->SetBackground();
+				mpImplWin->SetControlBackground();
+			}
+			else
+			{
+				mpImplWin->SetBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+				mpImplWin->SetControlBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+			}
 			mpImplWin->SetFont( mpImplLB->GetMainWindow()->GetFont() );
 			mpImplWin->Invalidate();
 		}
@@ -1134,7 +1260,7 @@ Size ListBox::CalcMinimumSize() const
 Size ListBox::CalcAdjustedSize( const Size& rPrefSize ) const
 {
 	Size aSz = rPrefSize;
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	((Window*)this)->GetBorder( nLeft, nTop, nRight, nBottom );
 	aSz.Height() -= nTop+nBottom;
 	if ( !IsDropDownBox() )
@@ -1232,16 +1358,6 @@ void ListBox::UserDraw( const UserDrawEv
 
 // -----------------------------------------------------------------------
 
-#if SUPD < 593
-void ListBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText )
-{
-	if ( rEvt.GetDevice() == mpImplLB->GetMainWindow() )
-		mpImplLB->GetMainWindow()->DrawEntry( rEvt.GetItemId(), bDrawImage, bDrawText );
-	else if ( rEvt.GetDevice() == mpImplWin )
-		mpImplWin->DrawEntry( bDrawImage, bDrawText );
-}
-#endif
-
 void ListBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText, BOOL bDrawTextAtImagePos )
 {
 	if ( rEvt.GetDevice() == mpImplLB->GetMainWindow() )
@@ -1354,6 +1470,15 @@ USHORT ListBox::GetMaxMRUCount() const
 USHORT ListBox::GetDisplayLineCount() const
 {
     return mpImplLB->GetDisplayLineCount();
+}
+
+// -----------------------------------------------------------------------
+
+// pb: #106948# explicit mirroring for calc
+
+void ListBox::EnableMirroring()
+{
+    mpImplLB->EnableMirroring();
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/control/makefile.mk,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/source/control/makefile.mk	4 Jun 2003 11:22:05 -0000	1.5
+++ vcl/source/control/makefile.mk	6 Jan 2004 13:22:11 -0000	1.6
@@ -100,23 +100,11 @@ SLOFILES=	$(SLO)$/button.obj		\
 			$(SLO)$/spinbtn.obj 	\
 			$(SLO)$/tabctrl.obj
 
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=					\
-			$(SLO)$/button.obj		\
-			$(SLO)$/ctrl.obj		\
-			$(SLO)$/edit.obj		\
-			$(SLO)$/field.obj		\
-			$(SLO)$/field2.obj		\
-			$(SLO)$/longcurr.obj	\
-			$(SLO)$/ilstbox.obj 	\
-			$(SLO)$/tabctrl.obj
-.ELSE
 EXCEPTIONSFILES=					\
 			$(SLO)$/edit.obj		\
 			$(SLO)$/field2.obj		\
 			$(SLO)$/ilstbox.obj		\
 			$(SLO)$/tabctrl.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/source/control/menubtn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/menubtn.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/control/menubtn.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/menubtn.cxx	6 Jan 2004 13:22:49 -0000	1.3
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_MENUBTN_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_DECOVIEW_HXX
 #include <decoview.hxx>
@@ -80,7 +78,7 @@
 #include <menubtn.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/control/morebtn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/morebtn.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/control/morebtn.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/morebtn.cxx	6 Jan 2004 13:23:15 -0000	1.3
@@ -59,17 +59,15 @@
  *
  ************************************************************************/
 
-#define _SV_MOREBTN_CXX
-
 #ifndef _SV_MOREBTN_HXX
 #include <morebtn.hxx>
 #endif
 
 #ifndef _SV_RD_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/control/scrbar.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/scrbar.cxx,v
retrieving revision 1.8
retrieving revision 1.13
diff -u -p -u -r1.8 -r1.13
--- vcl/source/control/scrbar.cxx	19 Jul 2002 11:12:18 -0000	1.8
+++ vcl/source/control/scrbar.cxx	10 May 2004 15:47:32 -0000	1.13
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SCRBAR_CXX
-
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
 #endif
@@ -73,12 +71,21 @@
 #ifndef _SV_SCRBAR_HXX
 #include <scrbar.hxx>
 #endif
+#ifndef _SV_TIMER_HXX
+#include <timer.hxx>
+#endif
+
+#ifndef _RTL_STRING_HXX_
+#include <rtl/string.hxx>
+#endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
+
+using namespace rtl;
 
 // =======================================================================
 
@@ -95,9 +102,10 @@ static long ImplMulDiv( long nNumber, lo
 #define SCRBAR_DRAW_PAGE1           ((USHORT)0x0004)
 #define SCRBAR_DRAW_PAGE2           ((USHORT)0x0008)
 #define SCRBAR_DRAW_THUMB           ((USHORT)0x0010)
+#define SCRBAR_DRAW_BACKGROUND      ((USHORT)0x0020)
 #define SCRBAR_DRAW_ALL             (SCRBAR_DRAW_BTN1 | SCRBAR_DRAW_BTN2 |  \
                                      SCRBAR_DRAW_PAGE1 | SCRBAR_DRAW_PAGE2 |\
-                                     SCRBAR_DRAW_THUMB)
+                                     SCRBAR_DRAW_THUMB | SCRBAR_DRAW_BACKGROUND )
 
 #define SCRBAR_STATE_BTN1_DOWN      ((USHORT)0x0001)
 #define SCRBAR_STATE_BTN1_DISABLE   ((USHORT)0x0002)
@@ -111,10 +119,17 @@ static long ImplMulDiv( long nNumber, lo
 
 #define SCRBAR_VIEW_STYLE           (WB_3DLOOK | WB_HORZ | WB_VERT)
 
+struct ImplScrollBarData
+{
+	AutoTimer		maTimer;			// Timer
+    BOOL            mbHide;
+};
+
 // =======================================================================
 
 void ScrollBar::ImplInit( Window* pParent, WinBits nStyle )
 {
+    mpData              = NULL;
     mnThumbPixRange     = 0;
     mnThumbPixPos       = 0;
     mnThumbPixSize      = 0;
@@ -176,6 +191,8 @@ ScrollBar::ScrollBar( Window* pParent, c
 
 ScrollBar::~ScrollBar()
 {
+    if( mpData )
+        delete mpData;
 }
 
 // -----------------------------------------------------------------------
@@ -202,8 +219,8 @@ void ScrollBar::ImplLoadRes( const ResId
 
 BOOL ScrollBar::ImplUpdateThumbRect( const Rectangle& rOldRect )
 {
-    Size aThumbRectSize  = rOldRect.GetSize();
 /* !!! Wegen ueberlappenden Fenstern ... !!!
+    Size aThumbRectSize  = rOldRect.GetSize();
     if ( aThumbRectSize == maThumbRect.GetSize() )
     {
         DrawOutDev( maThumbRect.TopLeft(), aThumbRectSize,
@@ -263,10 +280,15 @@ void ScrollBar::ImplUpdateRects( BOOL bU
         }
     }
 
-    if ( mnThumbPos == mnMinRange )
-        mnStateFlags |= SCRBAR_STATE_BTN1_DISABLE;
-    if ( mnThumbPos >= (mnMaxRange-mnVisibleSize) )
-        mnStateFlags |= SCRBAR_STATE_BTN2_DISABLE;
+    if( !IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+    {
+        // disable scrollbar buttons only in VCL's own 'theme'
+        // as it is uncommon on other platforms
+        if ( mnThumbPos == mnMinRange )
+            mnStateFlags |= SCRBAR_STATE_BTN1_DISABLE;
+        if ( mnThumbPos >= (mnMaxRange-mnVisibleSize) )
+            mnStateFlags |= SCRBAR_STATE_BTN2_DISABLE;
+    }
 
     if ( bUpdate )
     {
@@ -286,7 +308,7 @@ void ScrollBar::ImplUpdateRects( BOOL bU
             if ( !ImplUpdateThumbRect( aOldThumbRect ) )
                 nDraw |= SCRBAR_DRAW_THUMB;
         }
-        ImplDraw( nDraw );
+        ImplDraw( nDraw, this );
     }
 }
 
@@ -333,6 +355,10 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
         Size    aSize = GetOutputSizePixel();
         Size    aBtnSize;
 
+        Point aPoint( 0, 0 );
+        Region aControlRegion( Rectangle( aPoint, aSize ) );
+        Region aBtn1Region, aBtn2Region, aBoundingRegion;
+
         if ( GetStyle() & WB_HORZ )
         {
             if ( aSize.Height()*2 > aSize.Width()-SCRBAR_MIN_THUMB )
@@ -346,11 +372,22 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
             }
             else
             {
-                mnThumbPixRange         = aSize.Width()-(aSize.Height()*2);
-                aBtnSize                = Size( aSize.Height(), aSize.Height() );
-                maBtn2Rect.Left()       = aSize.Width()-aSize.Height();
-                maBtn1Rect.SetSize( aBtnSize );
-                maBtn2Rect.SetSize( aBtnSize );
+                if ( GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_LEFT,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn1Region ) &&
+                     GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_RIGHT,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn2Region ) )
+                {
+                    maBtn1Rect = aBtn1Region.GetBoundRect();
+                    maBtn2Rect = aBtn2Region.GetBoundRect();
+                }
+                else
+                {
+                    aBtnSize                = Size( aSize.Height(), aSize.Height() );
+                    maBtn2Rect.Left()       = aSize.Width()-aSize.Height();
+                    maBtn1Rect.SetSize( aBtnSize );
+                    maBtn2Rect.SetSize( aBtnSize );
+                }
+                mnThumbPixRange         = aSize.Width() - maBtn1Rect.GetWidth() - maBtn2Rect.GetWidth();
                 maPage1Rect.Left()      = maBtn1Rect.Right()+1;
                 maPage1Rect.Bottom()    = maBtn1Rect.Bottom();
                 maPage2Rect.Bottom()    = maBtn1Rect.Bottom();
@@ -370,11 +407,22 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
             }
             else
             {
-                mnThumbPixRange         = aSize.Height()-(aSize.Width()*2);
-                aBtnSize                = Size( aSize.Width(), aSize.Width() );
-                maBtn2Rect.Top()        = aSize.Height()-aSize.Width();
-                maBtn1Rect.SetSize( aBtnSize );
-                maBtn2Rect.SetSize( aBtnSize );
+                if ( GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_UP,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn1Region ) &&
+                     GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_DOWN,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn2Region ) )
+                {
+                    maBtn1Rect = aBtn1Region.GetBoundRect();
+                    maBtn2Rect = aBtn2Region.GetBoundRect();
+                }
+                else
+                {
+                    aBtnSize                = Size( aSize.Width(), aSize.Width() );
+                    maBtn2Rect.Top()        = aSize.Height()-aSize.Width();
+                    maBtn1Rect.SetSize( aBtnSize );
+                    maBtn2Rect.SetSize( aBtnSize );
+                }
+                mnThumbPixRange         = aSize.Height() - maBtn1Rect.GetHeight() - maBtn2Rect.GetHeight();
                 maPage1Rect.Top()       = maBtn1Rect.Bottom()+1;
                 maPage1Rect.Right()     = maBtn1Rect.Right();
                 maPage2Rect.Right()     = maBtn1Rect.Right();
@@ -434,12 +482,223 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
 
 // -----------------------------------------------------------------------
 
-void ScrollBar::ImplDraw( USHORT nDrawFlags )
+void ScrollBar::Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags )
 {
-    DecorationView          aDecoView( this );
+    Point       aPos  = pDev->LogicToPixel( rPos );
+    Size        aSize = pDev->LogicToPixel( rSize );
+    Rectangle   aRect( aPos, aSize );
+
+    pDev->Push();
+    pDev->SetMapMode();
+    if ( !(nFlags & WINDOW_DRAW_MONO) )
+	{
+		// DecoView uses the FaceColor...
+		AllSettings aSettings = pDev->GetSettings();
+		StyleSettings aStyleSettings = aSettings.GetStyleSettings();
+		if ( IsControlBackground() )
+			aStyleSettings.SetFaceColor( GetControlBackground() );
+		else
+			aStyleSettings.SetFaceColor( GetSettings().GetStyleSettings().GetFaceColor() );
+
+		aSettings.SetStyleSettings( aStyleSettings );
+		pDev->SetSettings( aSettings );
+	}
+
+    // for printing: 
+    // -calculate the size of the rects
+    // -because this is zero-based add the correct offset
+    // -print
+    // -force recalculate
+
+    if ( mbCalcSize )
+        ImplCalc( FALSE );
+
+    maBtn1Rect+=aPos;
+    maBtn2Rect+=aPos;
+    maThumbRect+=aPos;
+    maPage1Rect+=aPos;
+    maPage2Rect+=aPos;
+
+    ImplDraw( SCRBAR_DRAW_ALL, pDev );
+    pDev->Pop();
+
+    mbCalcSize = TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL ScrollBar::ImplDrawNative( USHORT nDrawFlags )
+{
+    BOOL bNativeOK = FALSE;
+    ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+    if( bNativeOK = IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+    {
+        BOOL bHorz = (GetStyle() & WB_HORZ ? true : false);
+
+        // Draw the entire background if the control supports it
+        if( IsNativeControlSupported(CTRL_SCROLLBAR, bHorz ? PART_DRAW_BACKGROUND_HORZ : PART_DRAW_BACKGROUND_VERT) )
+        {
+            Region  		aCtrlRegion;
+            ControlState		nState = ( IsEnabled() ? CTRL_STATE_ENABLED : 0 ) | ( HasFocus() ? CTRL_STATE_FOCUSED : 0 );
+            ScrollbarValue	scrValue;
+
+            scrValue.mnMin = mnMinRange;
+            scrValue.mnMax = mnMaxRange;
+            scrValue.mnCur = mnThumbPos;
+            scrValue.mnVisibleSize = mnVisibleSize;
+            scrValue.maThumbRect = maThumbRect;
+            scrValue.maButton1Rect = maBtn1Rect;
+            scrValue.maButton2Rect = maBtn2Rect;
+            scrValue.mnButton1State = ((mnStateFlags & SCRBAR_STATE_BTN1_DOWN) ? CTRL_STATE_PRESSED : 0) |
+								((!(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE)) ? CTRL_STATE_ENABLED : 0);
+            scrValue.mnButton2State = ((mnStateFlags & SCRBAR_STATE_BTN2_DOWN) ? CTRL_STATE_PRESSED : 0) |
+								((!(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE)) ? CTRL_STATE_ENABLED : 0);
+            scrValue.mnThumbState = nState | ((mnStateFlags & SCRBAR_STATE_THUMB_DOWN) ? CTRL_STATE_PRESSED : 0);
+            scrValue.mnPage1State = nState | ((mnStateFlags & SCRBAR_STATE_PAGE1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            scrValue.mnPage2State = nState | ((mnStateFlags & SCRBAR_STATE_PAGE2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maThumbRect )
+                        scrValue.mnThumbState |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn1Rect )
+                        scrValue.mnButton1State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn2Rect )
+                        scrValue.mnButton2State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage1Rect )
+                        scrValue.mnPage1State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage2Rect )
+                        scrValue.mnPage2State |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            aControlValue.setOptionalVal( (void *)(&scrValue) );
+
+            aCtrlRegion.Union( maBtn1Rect );
+            aCtrlRegion.Union( maBtn2Rect );
+            aCtrlRegion.Union( maPage1Rect );
+            aCtrlRegion.Union( maPage2Rect );
+            aCtrlRegion.Union( maThumbRect );
+
+            bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, (bHorz ? PART_DRAW_BACKGROUND_HORZ : PART_DRAW_BACKGROUND_VERT),
+                            aCtrlRegion, nState, aControlValue, rtl::OUString() );
+        }
+        else
+      {
+        if ( (nDrawFlags & SCRBAR_DRAW_PAGE1) || (nDrawFlags & SCRBAR_DRAW_PAGE2) )
+        {
+            sal_uInt32	part1 = bHorz ? PART_TRACK_HORZ_LEFT : PART_TRACK_VERT_UPPER;
+            sal_uInt32	part2 = bHorz ? PART_TRACK_HORZ_RIGHT : PART_TRACK_VERT_LOWER;
+            Region  	aCtrlRegion1( maPage1Rect );
+            Region  	aCtrlRegion2( maPage2Rect );
+            ControlState nState1 = (IsEnabled() ? CTRL_STATE_ENABLED : 0) | (HasFocus() ? CTRL_STATE_FOCUSED : 0);
+            ControlState nState2 = nState1;
+
+            nState1 |= ((mnStateFlags & SCRBAR_STATE_PAGE1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            nState2 |= ((mnStateFlags & SCRBAR_STATE_PAGE2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maPage1Rect )
+                        nState1 |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage2Rect )
+                        nState2 |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            if ( nDrawFlags & SCRBAR_DRAW_PAGE1 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part1, aCtrlRegion1, nState1, 
+                                aControlValue, rtl::OUString() );
+
+            if ( nDrawFlags & SCRBAR_DRAW_PAGE2 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part2, aCtrlRegion2, nState2, 
+                                aControlValue, rtl::OUString() );
+        }
+        if ( (nDrawFlags & SCRBAR_DRAW_BTN1) || (nDrawFlags & SCRBAR_DRAW_BTN2) )
+        {
+            sal_uInt32	part1 = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+            sal_uInt32	part2 = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+            Region  	aCtrlRegion1( maBtn1Rect );
+            Region  	aCtrlRegion2( maBtn2Rect );
+            ControlState nState1 = HasFocus() ? CTRL_STATE_FOCUSED : 0;
+            ControlState nState2 = nState1;
+
+            if ( !Window::IsEnabled() || !IsEnabled() )
+                nState1 = (nState2 &= ~CTRL_STATE_ENABLED);
+            else
+                nState1 = (nState2 |= CTRL_STATE_ENABLED);
+
+
+            nState1 |= ((mnStateFlags & SCRBAR_STATE_BTN1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            nState2 |= ((mnStateFlags & SCRBAR_STATE_BTN2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE)
+                nState1 &= ~CTRL_STATE_ENABLED;
+            if(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE)
+                nState2 &= ~CTRL_STATE_ENABLED;
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maBtn1Rect )
+                        nState1 |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn2Rect )
+                        nState2 |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            if ( nDrawFlags & SCRBAR_DRAW_BTN1 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part1, aCtrlRegion1, nState1, 
+                                aControlValue, rtl::OUString() );
+
+            if ( nDrawFlags & SCRBAR_DRAW_BTN2 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part2, aCtrlRegion2, nState2, 
+                                aControlValue, rtl::OUString() );
+        }
+        if ( (nDrawFlags & SCRBAR_DRAW_THUMB) && !maThumbRect.IsEmpty() )
+        {
+            ControlState	nState = IsEnabled() ? CTRL_STATE_ENABLED : 0;
+            Region		aCtrlRegion( maThumbRect );
+
+            if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
+                nState |= CTRL_STATE_PRESSED;
+
+            if ( HasFocus() )
+                nState |= CTRL_STATE_FOCUSED;
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maThumbRect )
+                        nState |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, (bHorz ? PART_THUMB_HORZ : PART_THUMB_VERT),
+                    aCtrlRegion, nState, aControlValue, rtl::OUString() );
+        }
+      }
+    }
+    return bNativeOK;
+}
+
+void ScrollBar::ImplDraw( USHORT nDrawFlags, OutputDevice* pOutDev )
+{
+    DecorationView          aDecoView( pOutDev );
     Rectangle               aTempRect;
     USHORT                  nStyle;
-    const StyleSettings&    rStyleSettings = GetSettings().GetStyleSettings();
+    const StyleSettings&    rStyleSettings = pOutDev->GetSettings().GetStyleSettings();
     SymbolType              eSymbolType;
     BOOL                    bEnabled = IsEnabled();
 
@@ -447,7 +706,18 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
     if ( mbCalcSize )
         ImplCalc( FALSE );
 
-    if ( nDrawFlags & SCRBAR_DRAW_BTN1 )
+    Window *pWin = NULL;
+    if( pOutDev->GetOutDevType() == OUTDEV_WINDOW )
+        pWin = (Window*) pOutDev;
+    
+    // Draw the entire control if the native theme engine needs it
+    if ( nDrawFlags && pWin && pWin->IsNativeControlSupported(CTRL_SCROLLBAR, PART_DRAW_BACKGROUND_HORZ) )
+    {
+        ImplDrawNative( SCRBAR_DRAW_BACKGROUND );
+        return;
+    }
+
+    if( (nDrawFlags & SCRBAR_DRAW_BTN1) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_BTN1 ) ) )
     {
         nStyle = BUTTON_DRAW_NOLIGHTBORDER;
         if ( mnStateFlags & SCRBAR_STATE_BTN1_DOWN )
@@ -474,7 +744,7 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
         aDecoView.DrawSymbol( aTempRect, eSymbolType, rStyleSettings.GetButtonTextColor(), nStyle );
     }
 
-    if ( nDrawFlags & SCRBAR_DRAW_BTN2 )
+    if ( (nDrawFlags & SCRBAR_DRAW_BTN2) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_BTN2 ) ) )
     {
         nStyle = BUTTON_DRAW_NOLIGHTBORDER;
         if ( mnStateFlags & SCRBAR_STATE_BTN2_DOWN )
@@ -501,19 +771,21 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
         aDecoView.DrawSymbol( aTempRect, eSymbolType, rStyleSettings.GetButtonTextColor(), nStyle );
     }
 
-    SetLineColor();
+    pOutDev->SetLineColor();
 
-    if ( nDrawFlags & SCRBAR_DRAW_THUMB )
+    if ( (nDrawFlags & SCRBAR_DRAW_THUMB) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_THUMB ) ) )
     {
         if ( !maThumbRect.IsEmpty() )
         {
             if ( bEnabled )
             {
                 nStyle = BUTTON_DRAW_NOLIGHTBORDER;
-                if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
-                    nStyle |= BUTTON_DRAW_PRESSED;
+                // pressed thumbs only in OS2 style
+                if ( rStyleSettings.GetOptions() & STYLE_OPTION_OS2STYLE )
+                    if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
+                        nStyle |= BUTTON_DRAW_PRESSED;
                 aTempRect = aDecoView.DrawButton( maThumbRect, nStyle );
-                // Im OS2-Look geben wir auch ein Muster auf dem Thumb aus
+                // OS2 style requires pattern on the thumb
                 if ( rStyleSettings.GetOptions() & STYLE_OPTION_OS2STYLE )
                 {
                     if ( GetStyle() & WB_HORZ )
@@ -529,12 +801,12 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
                                 if ( nX > aTempRect.Right()-1 )
                                     break;
 
-                                SetLineColor( rStyleSettings.GetButtonTextColor() );
-                                DrawLine( Point( nX, aTempRect.Top()+1 ),
+                                pOutDev->SetLineColor( rStyleSettings.GetButtonTextColor() );
+                                pOutDev->DrawLine( Point( nX, aTempRect.Top()+1 ),
                                           Point( nX, aTempRect.Bottom()-1 ) );
                                 nX++;
-                                SetLineColor( rStyleSettings.GetLightColor() );
-                                DrawLine( Point( nX, aTempRect.Top()+1 ),
+                                pOutDev->SetLineColor( rStyleSettings.GetLightColor() );
+                                pOutDev->DrawLine( Point( nX, aTempRect.Top()+1 ),
                                           Point( nX, aTempRect.Bottom()-1 ) );
                                 nX++;
                             }
@@ -553,43 +825,43 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
                                 if ( nY > aTempRect.Bottom()-1 )
                                     break;
 
-                                SetLineColor( rStyleSettings.GetButtonTextColor() );
-                                DrawLine( Point( aTempRect.Left()+1, nY ),
+                                pOutDev->SetLineColor( rStyleSettings.GetButtonTextColor() );
+                                pOutDev->DrawLine( Point( aTempRect.Left()+1, nY ),
                                           Point( aTempRect.Right()-1, nY ) );
                                 nY++;
-                                SetLineColor( rStyleSettings.GetLightColor() );
-                                DrawLine( Point( aTempRect.Left()+1, nY ),
+                                pOutDev->SetLineColor( rStyleSettings.GetLightColor() );
+                                pOutDev->DrawLine( Point( aTempRect.Left()+1, nY ),
                                           Point( aTempRect.Right()-1, nY ) );
                                 nY++;
                             }
                         }
                     }
-                    SetLineColor();
+                    pOutDev->SetLineColor();
                 }
             }
             else
             {
-                SetFillColor( rStyleSettings.GetCheckedColor() );
-                DrawRect( maThumbRect );
+                pOutDev->SetFillColor( rStyleSettings.GetCheckedColor() );
+                pOutDev->DrawRect( maThumbRect );
             }
         }
     }
 
-    if ( nDrawFlags & SCRBAR_DRAW_PAGE1 )
+    if ( (nDrawFlags & SCRBAR_DRAW_PAGE1) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_PAGE1 ) ) )
     {
         if ( mnStateFlags & SCRBAR_STATE_PAGE1_DOWN )
-            SetFillColor( rStyleSettings.GetShadowColor() );
+            pOutDev->SetFillColor( rStyleSettings.GetShadowColor() );
         else
-            SetFillColor( rStyleSettings.GetCheckedColor() );
-        DrawRect( maPage1Rect );
+            pOutDev->SetFillColor( rStyleSettings.GetCheckedColor() );
+        pOutDev->DrawRect( maPage1Rect );
     }
-    if ( nDrawFlags & SCRBAR_DRAW_PAGE2 )
+    if ( (nDrawFlags & SCRBAR_DRAW_PAGE2) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_PAGE2 ) ) )
     {
         if ( mnStateFlags & SCRBAR_STATE_PAGE2_DOWN )
-            SetFillColor( rStyleSettings.GetShadowColor() );
+            pOutDev->SetFillColor( rStyleSettings.GetShadowColor() );
         else
-            SetFillColor( rStyleSettings.GetCheckedColor() );
-        DrawRect( maPage2Rect );
+            pOutDev->SetFillColor( rStyleSettings.GetCheckedColor() );
+        pOutDev->DrawRect( maPage2Rect );
     }
 }
 
@@ -634,6 +906,8 @@ long ScrollBar::ImplDoAction( BOOL bCall
         case SCROLL_PAGEDOWN:
             nDelta = ImplScroll( mnThumbPos+mnPageSize, bCallEndScroll );
             break;
+        default:
+            ;
     }
 
     return nDelta;
@@ -645,11 +919,19 @@ void ScrollBar::ImplDoMouseAction( const
 {
     USHORT  nOldStateFlags = mnStateFlags;
     BOOL    bAction = FALSE;
+    BOOL    bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+    BOOL    bIsInside = FALSE;
+
+    Point aPoint( 0, 0 );
+    Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
 
     switch ( meScrollType )
     {
         case SCROLL_LINEUP:
-            if ( maBtn1Rect.IsInside( rMousePos ) )
+            if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                        aControlRegion, rMousePos, bIsInside )?
+                    bIsInside:
+                    maBtn1Rect.IsInside( rMousePos ) )
             {
                 bAction = bCallAction;
                 mnStateFlags |= SCRBAR_STATE_BTN1_DOWN;
@@ -659,7 +941,10 @@ void ScrollBar::ImplDoMouseAction( const
             break;
 
         case SCROLL_LINEDOWN:
-            if ( maBtn2Rect.IsInside( rMousePos ) )
+            if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                        aControlRegion, rMousePos, bIsInside )?
+                    bIsInside:
+                    maBtn2Rect.IsInside( rMousePos ) )
             {
                 bAction = bCallAction;
                 mnStateFlags |= SCRBAR_STATE_BTN2_DOWN;
@@ -687,10 +972,12 @@ void ScrollBar::ImplDoMouseAction( const
             else
                 mnStateFlags &= ~SCRBAR_STATE_PAGE2_DOWN;
             break;
+        default:
+            ;
     }
 
     if ( nOldStateFlags != mnStateFlags )
-        ImplDraw( mnDragDraw );
+        ImplDraw( mnDragDraw, this );
     if ( bAction )
         ImplDoAction( FALSE );
 }
@@ -703,8 +990,16 @@ void ScrollBar::MouseButtonDown( const M
     {
         const Point&    rMousePos = rMEvt.GetPosPixel();
         USHORT          nTrackFlags = 0;
+        BOOL            bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+        BOOL            bIsInside = FALSE;
 
-        if ( maBtn1Rect.IsInside( rMousePos ) )
+        Point aPoint( 0, 0 );
+        Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+
+        if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                    aControlRegion, rMousePos, bIsInside )?
+                bIsInside:
+                maBtn1Rect.IsInside( rMousePos ) )
         {
             if ( !(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE) )
             {
@@ -715,7 +1010,10 @@ void ScrollBar::MouseButtonDown( const M
             else
                 Sound::Beep( SOUND_DISABLE, this );
         }
-        else if ( maBtn2Rect.IsInside( rMousePos ) )
+        else if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                    aControlRegion, rMousePos, bIsInside )?
+                bIsInside:
+                maBtn2Rect.IsInside( rMousePos ) )
         {
             if ( !(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE) )
             {
@@ -728,6 +1026,13 @@ void ScrollBar::MouseButtonDown( const M
         }
         else if ( maThumbRect.IsInside( rMousePos ) )
         {
+            if( mpData )
+            {
+                mpData->mbHide = TRUE;  // disable focus blinking
+                if( HasFocus() )
+                    ImplDraw( SCRBAR_DRAW_THUMB, this ); // paint without focus
+            }
+
             if ( mnVisibleSize < mnMaxRange-mnMinRange )
             {
                 nTrackFlags     = 0;
@@ -740,12 +1045,8 @@ void ScrollBar::MouseButtonDown( const M
                 else
                     mnMouseOff = rMousePos.Y()-maThumbRect.Top();
 
-                // Im OS2-Look geben wir den Thumb gedrueck aus
-                if ( GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_OS2STYLE )
-                {
-                    mnStateFlags |= SCRBAR_STATE_THUMB_DOWN;
-                    ImplDraw( mnDragDraw );
-                }
+                mnStateFlags |= SCRBAR_STATE_THUMB_DOWN;
+                ImplDraw( mnDragDraw, this );
             }
             else
                 Sound::Beep( SOUND_DISABLE, this );
@@ -792,7 +1093,7 @@ void ScrollBar::Tracking( const Tracking
                           SCRBAR_STATE_PAGE1_DOWN | SCRBAR_STATE_PAGE2_DOWN |
                           SCRBAR_STATE_THUMB_DOWN);
         if ( nOldStateFlags != mnStateFlags )
-            ImplDraw( mnDragDraw );
+            ImplDraw( mnDragDraw, this );
         mnDragDraw = 0;
 
         // Bei Abbruch, die alte ThumbPosition wieder herstellen
@@ -822,6 +1123,10 @@ void ScrollBar::Tracking( const Tracking
         EndScroll();
         mnDelta = 0;
         meScrollType = SCROLL_DONTKNOW;
+
+        if( mpData )
+            mpData->mbHide = FALSE; // re-enable focus blinking
+
     }
     else
     {
@@ -912,7 +1217,7 @@ void ScrollBar::KeyInput( const KeyEvent
 
 void ScrollBar::Paint( const Rectangle& rRect )
 {
-    ImplDraw( SCRBAR_DRAW_ALL );
+    ImplDraw( SCRBAR_DRAW_ALL, this );
 }
 
 // -----------------------------------------------------------------------
@@ -928,6 +1233,60 @@ void ScrollBar::Resize()
 
 // -----------------------------------------------------------------------
 
+IMPL_LINK( ScrollBar, ImplAutoTimerHdl, AutoTimer*, EMPTYARG )
+{
+    if( mpData && mpData->mbHide )
+        return 0;
+    ImplInvert();
+    return 0;
+}
+
+void ScrollBar::ImplInvert()
+{
+    Rectangle aRect( maThumbRect );
+    if( aRect.getWidth() > 4 )
+    {
+        aRect.Left() += 2;
+        aRect.Right() -= 2;
+    }
+    if( aRect.getHeight() > 4 ) 
+    {
+        aRect.Top() += 2;
+        aRect.Bottom() -= 2;
+    }
+
+    Invert( aRect, 0 );
+}
+
+// -----------------------------------------------------------------------
+
+void ScrollBar::GetFocus()
+{
+    if( !mpData )
+    {
+	    mpData = new ImplScrollBarData;
+		mpData->maTimer.SetTimeoutHdl( LINK( this, ScrollBar, ImplAutoTimerHdl ) );
+        mpData->mbHide = FALSE;
+    }
+    ImplInvert();   // react immediately
+	mpData->maTimer.SetTimeout( GetSettings().GetStyleSettings().GetCursorBlinkTime() );
+    mpData->maTimer.Start();
+    Control::GetFocus();
+}
+
+// -----------------------------------------------------------------------
+
+void ScrollBar::LoseFocus()
+{
+    if( mpData )
+        mpData->maTimer.Stop();
+    ImplDraw( SCRBAR_DRAW_THUMB, this );
+
+    Control::LoseFocus();
+}
+
+// -----------------------------------------------------------------------
+
 void ScrollBar::StateChanged( StateChangedType nType )
 {
     Control::StateChanged( nType );
@@ -977,6 +1336,79 @@ void ScrollBar::DataChanged( const DataC
     if ( (rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
          (rDCEvt.GetFlags() & SETTINGS_STYLE) )
         Invalidate();
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* ScrollBar::ImplFindPartRect( const Point& rPt )
+{
+    BOOL    bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+    BOOL    bIsInside = FALSE;
+
+    Point aPoint( 0, 0 );
+    Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+
+    if( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                aControlRegion, rPt, bIsInside )?
+            bIsInside:
+            maBtn1Rect.IsInside( rPt ) )
+        return &maBtn1Rect;
+    else if( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                aControlRegion, rPt, bIsInside )?
+            bIsInside:
+            maBtn2Rect.IsInside( rPt ) )
+        return &maBtn2Rect;
+    else if( maPage1Rect.IsInside( rPt ) )
+        return &maPage1Rect;
+    else if( maPage2Rect.IsInside( rPt ) )
+        return &maPage2Rect;
+    else if( maThumbRect.IsInside( rPt ) )
+        return &maThumbRect;
+    else
+        return NULL;
+}
+
+long ScrollBar::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    Region aClipRegion;
+
+                    if ( pRect )
+                        aClipRegion.Union( *pRect );
+                    if ( pLastRect )
+                        aClipRegion.Union( *pLastRect );
+                    
+                    // Support for 3-button scroll bars
+                    BOOL bHas3Buttons = IsNativeControlSupported( CTRL_SCROLLBAR, HAS_THREE_BUTTONS );
+                    if ( bHas3Buttons && ( pRect == &maBtn1Rect || pLastRect == &maBtn1Rect ) )
+                    {
+                        aClipRegion.Union( maBtn2Rect );
+                    }
+
+                    SetClipRegion( aClipRegion );
+                    Paint( aClipRegion.GetBoundRect() );
+
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/slider.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/slider.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/control/slider.cxx	8 May 2002 16:01:30 -0000	1.2
+++ vcl/source/control/slider.cxx	6 Jan 2004 13:24:26 -0000	1.4
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_SLIDER_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -74,7 +72,7 @@
 #include <slider.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -176,7 +174,7 @@ void Slider::ImplLoadRes( const ResId& r
 	INT16 nThumbPos		= ReadShortRes();
 	INT16 nPage			= ReadShortRes();
 	INT16 nStep			= ReadShortRes();
-	INT16 nVisibleSize	= ReadShortRes();
+	/* INT16 nVisibleSize	= */ ReadShortRes();
 
 	SetRange( Range( nMin, nMax ) );
 	SetLineSize( nStep );
@@ -188,8 +186,6 @@ void Slider::ImplLoadRes( const ResId& r
 
 void Slider::ImplInitSettings()
 {
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
-
 	Window* pParent = GetParent();
 	if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
 	{
Index: vcl/source/control/spinbtn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/spinbtn.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/control/spinbtn.cxx	8 May 2002 16:01:30 -0000	1.3
+++ vcl/source/control/spinbtn.cxx	10 May 2004 15:47:45 -0000	1.6
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_SPIN_CXX
-
-#ifndef _SV_RCID_H
-#include <rcid.h>
+#ifndef _TOOLS_RCID_H
+#include <tools/rcid.h>
 #endif
 #ifndef _SV_SPIN_H
 #include <spin.h>
@@ -83,15 +81,15 @@ void SpinButton::ImplInit( Window* pPare
     mbInitialUp   = FALSE;
     mbInitialDown = FALSE;
 
-    if ( nStyle & WB_REPEAT )
-    {
-        mbRepeat = TRUE;
+    mnMinRange  = 0;
+    mnMaxRange  = 100;
+    mnValue     = 0;
+    mnValueStep = 1;
 
-        maRepeatTimer.SetTimeout( SPIN_DELAY );
-        maRepeatTimer.SetTimeoutHdl( LINK( this, SpinButton, ImplTimeout ) );
-    }
-    else
-        mbRepeat = FALSE;
+    maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
+    maRepeatTimer.SetTimeoutHdl( LINK( this, SpinButton, ImplTimeout ) );
+
+    mbRepeat = 0 != ( nStyle & WB_REPEAT );
 
     if ( nStyle & WB_HSCROLL )
         mbHorz = TRUE;
@@ -103,16 +101,18 @@ void SpinButton::ImplInit( Window* pPare
 
 // -----------------------------------------------------------------------
 
-SpinButton::SpinButton( Window* pParent, WinBits nStyle ) :
-    Control( WINDOW_SPINBUTTON )
+SpinButton::SpinButton( Window* pParent, WinBits nStyle )
+    :Control( WINDOW_SPINBUTTON )
+    ,mbUpperIsFocused( FALSE )
 {
     ImplInit( pParent, nStyle );
 }
 
 // -----------------------------------------------------------------------
 
-SpinButton::SpinButton( Window* pParent, const ResId& rResId ) :
-    Control( WINDOW_SPINBUTTON )
+SpinButton::SpinButton( Window* pParent, const ResId& rResId )
+    :Control( WINDOW_SPINBUTTON )
+    ,mbUpperIsFocused( FALSE )
 {
     rResId.SetRT( RSC_SPINBUTTON );
     ImplInit( pParent, ImplInitRes( rResId ) );
@@ -130,9 +130,9 @@ SpinButton::~SpinButton()
 
 IMPL_LINK( SpinButton, ImplTimeout, Timer*, pTimer )
 {
-    if ( pTimer->GetTimeout() == SPIN_DELAY )
+    if ( pTimer->GetTimeout() == GetSettings().GetMouseSettings().GetButtonStartRepeat() )
     {
-        pTimer->SetTimeout( SPIN_SPEED );
+        pTimer->SetTimeout( GetSettings().GetMouseSettings().GetButtonRepeat() );
         pTimer->Start();
     }
     else
@@ -150,6 +150,14 @@ IMPL_LINK( SpinButton, ImplTimeout, Time
 
 void SpinButton::Up()
 {
+    if ( ImplIsUpperEnabled() )
+    {
+        mnValue += mnValueStep;
+        StateChanged( STATE_CHANGE_DATA );
+
+        ImplMoveFocus( TRUE );
+    }
+
     ImplCallEventListeners( VCLEVENT_SPINBUTTON_UP );
     maUpHdlLink.Call( this );
 }
@@ -158,6 +166,14 @@ void SpinButton::Up()
 
 void SpinButton::Down()
 {
+    if ( ImplIsLowerEnabled() )
+    {
+        mnValue -= mnValueStep;
+        StateChanged( STATE_CHANGE_DATA );
+
+        ImplMoveFocus( FALSE );
+    }
+
     ImplCallEventListeners( VCLEVENT_SPINBUTTON_DOWN );
     maDownHdlLink.Call( this );
 }
@@ -173,8 +189,8 @@ void SpinButton::Resize()
     Rectangle aRect( aTmpPoint, aSize );
     if ( mbHorz )
     {
-        maUpperRect = Rectangle( 0, 0, aSize.Width()/2, aSize.Height()-1 );
-        maLowerRect = Rectangle( maUpperRect.TopRight(), aRect.BottomRight() );
+        maLowerRect = Rectangle( 0, 0, aSize.Width()/2, aSize.Height()-1 );
+        maUpperRect = Rectangle( maLowerRect.TopRight(), aRect.BottomRight() );
     }
     else
     {
@@ -182,29 +198,81 @@ void SpinButton::Resize()
         maLowerRect = Rectangle( maUpperRect.BottomLeft(), aRect.BottomRight() );
     }
 
+    ImplCalcFocusRect( ImplIsUpperEnabled() || !ImplIsLowerEnabled() );
+
     Invalidate();
 }
 
 // -----------------------------------------------------------------------
 
+void SpinButton::Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags )
+{
+    Point       aPos  = pDev->LogicToPixel( rPos );
+    Size        aSize = pDev->LogicToPixel( rSize );
+ 
+    pDev->Push();
+    pDev->SetMapMode();
+    if ( !(nFlags & WINDOW_DRAW_MONO) )
+	{
+		// DecoView uses the FaceColor...
+		AllSettings aSettings = pDev->GetSettings();
+		StyleSettings aStyleSettings = aSettings.GetStyleSettings();
+		if ( IsControlBackground() )
+			aStyleSettings.SetFaceColor( GetControlBackground() );
+		else
+			aStyleSettings.SetFaceColor( GetSettings().GetStyleSettings().GetFaceColor() );
+
+		aSettings.SetStyleSettings( aStyleSettings );
+		pDev->SetSettings( aSettings );
+	}
+
+    Rectangle   aRect( Point( 0, 0 ), aSize );
+    Rectangle aLowerRect, aUpperRect;
+    if ( mbHorz )
+    {
+        aLowerRect = Rectangle( 0, 0, aSize.Width()/2, aSize.Height()-1 );
+        aUpperRect = Rectangle( aLowerRect.TopRight(), aRect.BottomRight() );
+    }
+    else
+    {
+        aUpperRect = Rectangle( 0, 0, aSize.Width()-1, aSize.Height()/2 );
+        aLowerRect = Rectangle( aUpperRect.BottomLeft(), aRect.BottomRight() );
+    }
+
+    aUpperRect += aPos;
+    aLowerRect += aPos;
+
+    ImplDrawSpinButton( pDev, aUpperRect, aLowerRect, FALSE, FALSE,
+                        IsEnabled() && ImplIsUpperEnabled(),
+                        IsEnabled() && ImplIsLowerEnabled(), mbHorz, TRUE );
+    pDev->Pop();
+}
+
+
 void SpinButton::Paint( const Rectangle& )
 {
+    HideFocus();
+
     BOOL bEnable = IsEnabled();
     ImplDrawSpinButton( this, maUpperRect, maLowerRect, mbUpperIn, mbLowerIn,
-                        bEnable, bEnable, mbHorz );
+                        bEnable && ImplIsUpperEnabled(),
+                        bEnable && ImplIsLowerEnabled(), mbHorz, TRUE );
+
+    if ( HasFocus() )
+        ShowFocus( maFocusRect );
 }
 
 // -----------------------------------------------------------------------
 
 void SpinButton::MouseButtonDown( const MouseEvent& rMEvt )
 {
-    if ( maUpperRect.IsInside( rMEvt.GetPosPixel() ) )
+    if ( maUpperRect.IsInside( rMEvt.GetPosPixel() ) && ( ImplIsUpperEnabled() ) )
     {
         mbUpperIn   = TRUE;
         mbInitialUp = TRUE;
         Invalidate( maUpperRect );
     }
-    else if ( maLowerRect.IsInside( rMEvt.GetPosPixel() ) )
+    else if ( maLowerRect.IsInside( rMEvt.GetPosPixel() ) && ( ImplIsLowerEnabled() ) )
     {
         mbLowerIn     = TRUE;
         mbInitialDown = TRUE;
@@ -246,7 +314,7 @@ void SpinButton::MouseButtonUp( const Mo
     if ( mbRepeat )
     {
         maRepeatTimer.Stop();
-        maRepeatTimer.SetTimeout( SPIN_DELAY );
+        maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
     }
 }
 
@@ -299,10 +367,37 @@ void SpinButton::KeyInput( const KeyEven
 {
     KeyCode aCode = rKEvt.GetKeyCode();
 
-    if ( aCode.GetCode() == KEY_UP )
-        Up();
-    else if( aCode.GetCode() == KEY_DOWN )
-        Down();
+    if ( !rKEvt.GetKeyCode().GetModifier() )
+    {
+        switch ( rKEvt.GetKeyCode().GetCode() )
+        {
+        case KEY_LEFT:
+        case KEY_RIGHT:
+        {
+            BOOL bUp = KEY_RIGHT == rKEvt.GetKeyCode().GetCode();
+            if ( mbHorz && !ImplMoveFocus( bUp ) )
+                bUp ? Up() : Down();
+        }
+        break;
+
+        case KEY_UP:
+        case KEY_DOWN:
+        {
+            BOOL bUp = KEY_UP == rKEvt.GetKeyCode().GetCode();
+            if ( !mbHorz && !ImplMoveFocus( KEY_UP == rKEvt.GetKeyCode().GetCode() ) )
+                bUp ? Up() : Down();
+        }
+        break;
+
+        case KEY_SPACE:
+            mbUpperIsFocused ? Up() : Down();
+            break;
+
+        default:
+            Control::KeyInput( rKEvt );
+            break;
+        }
+    }
     else
         Control::KeyInput( rKEvt );
 }
@@ -311,7 +406,188 @@ void SpinButton::KeyInput( const KeyEven
 
 void SpinButton::StateChanged( StateChangedType nType )
 {
-    if ( nType == STATE_CHANGE_ENABLE )
+    switch ( nType )
+    {
+    case STATE_CHANGE_DATA:
+    case STATE_CHANGE_ENABLE:
         Invalidate();
+        break;
+
+    case STATE_CHANGE_STYLE:
+    {
+        BOOL bNewRepeat = 0 != ( GetStyle() & WB_REPEAT );
+        if ( bNewRepeat != mbRepeat )
+        {
+            if ( maRepeatTimer.IsActive() )
+            {
+                maRepeatTimer.Stop();
+                maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
+            }
+            mbRepeat = bNewRepeat;
+        }
+
+        BOOL bNewHorz = 0 != ( GetStyle() & WB_HSCROLL );
+        if ( bNewHorz != mbHorz )
+        {
+            mbHorz = bNewHorz;
+            Resize();
+        }
+    }
+    break;
+    }
+
     Control::StateChanged( nType );
 }
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetRangeMin( long nNewRange )
+{
+    SetRange( Range( nNewRange, GetRangeMax() ) );
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetRangeMax( long nNewRange )
+{
+    SetRange( Range( GetRangeMin(), nNewRange ) );
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetRange( const Range& rRange )
+{
+    // adjust rage
+    Range aRange = rRange;
+    aRange.Justify();
+    long nNewMinRange = aRange.Min();
+    long nNewMaxRange = aRange.Max();
+
+    // do something only if old and new range differ
+    if ( (mnMinRange != nNewMinRange) ||
+         (mnMaxRange != nNewMaxRange) )
+    {
+        mnMinRange = nNewMinRange;
+        mnMaxRange = nNewMaxRange;
+
+        // adjust value to new range, if necessary
+        if ( mnValue > mnMaxRange )
+            mnValue = mnMaxRange;
+        if ( mnValue < mnMinRange )
+            mnValue = mnMinRange;
+
+        StateChanged( STATE_CHANGE_DATA );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetValue( long nValue )
+{
+    // adjust, if necessary
+    if ( nValue > mnMaxRange )
+        nValue = mnMaxRange;
+    if ( nValue < mnMinRange )
+        nValue = mnMinRange;
+
+    if ( mnValue != nValue )
+    {
+        mnValue = nValue;
+        StateChanged( STATE_CHANGE_DATA );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::GetFocus()
+{
+    ShowFocus( maFocusRect );
+    Control::GetFocus();
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::LoseFocus()
+{
+    HideFocus();
+    Control::LoseFocus();
+}
+
+// -----------------------------------------------------------------------
+
+BOOL SpinButton::ImplMoveFocus( BOOL _bUpper )
+{
+    if ( _bUpper == mbUpperIsFocused )
+        return FALSE;
+
+    HideFocus();
+    ImplCalcFocusRect( _bUpper );
+    if ( HasFocus() )
+        ShowFocus( maFocusRect );
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::ImplCalcFocusRect( BOOL _bUpper )
+{
+    maFocusRect = _bUpper ? maUpperRect : maLowerRect;
+    // inflate by some pixels
+    maFocusRect.Left() += 2;
+    maFocusRect.Top() += 2;
+    maFocusRect.Right() -= 2;
+    maFocusRect.Bottom() -= 2;
+    mbUpperIsFocused = _bUpper;
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* SpinButton::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
Index: vcl/source/control/spinfld.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/spinfld.cxx,v
retrieving revision 1.10
retrieving revision 1.14
diff -u -p -u -r1.10 -r1.14
--- vcl/source/control/spinfld.cxx	12 Sep 2002 08:35:13 -0000	1.10
+++ vcl/source/control/spinfld.cxx	10 May 2004 15:47:58 -0000	1.14
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_SPINFLD_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -82,11 +80,116 @@
 
 // =======================================================================
 
+void ImplGetSpinbuttonValue( Window *pWin, const Rectangle& rUpperRect,
+                            const Rectangle& rLowerRect,
+                            BOOL bUpperIn, BOOL bLowerIn,
+                            BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz,
+                            SpinbuttonValue& rValue )
+{
+    // convert spinbutton data to a SpinbuttonValue structure for native painting
+
+    rValue.maUpperRect = rUpperRect;
+    rValue.maLowerRect = rLowerRect;
+
+    // convert rectangles to screen coordinates
+    Point aPt = pWin->OutputToScreenPixel( rValue.maUpperRect.TopLeft() );
+    rValue.maUpperRect.SetPos( aPt );
+    aPt = pWin->OutputToScreenPixel( rValue.maLowerRect.TopLeft() );
+    rValue.maLowerRect.SetPos( aPt );
+
+    ControlState nState = CTRL_STATE_ENABLED;
+    if ( bUpperIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bUpperEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    if( pWin->IsMouseOver() && rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnUpperState = nState;
+
+    nState = CTRL_STATE_ENABLED;
+    if ( bLowerIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bLowerEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    // for overlapping spins: highlight only one
+    if( pWin->IsMouseOver() && rLowerRect.IsInside( pWin->GetPointerPosPixel() ) &&
+                              !rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnLowerState = nState;
+
+    rValue.mnUpperPart = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+    rValue.mnLowerPart = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+}
+
+
+BOOL ImplDrawNativeSpinfield( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        if( pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnUpperPart) && 
+            pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnLowerPart) )
+        {
+            // only paint the embedded spin buttons, all buttons are painted at once
+            bNativeOK = pWin->DrawNativeControl( CTRL_SPINBOX, PART_ALL_BUTTONS, Region(), CTRL_STATE_ENABLED,
+                        aControlValue, rtl::OUString() );
+        }
+        else
+        {
+            // paint the spinbox as a whole, use borderwindow to have proper clipping
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // to not overwrite everything, set the button region as clipregion to the border window
+            Rectangle aClipRect( rSpinbuttonValue.maLowerRect );
+            aClipRect.Union( rSpinbuttonValue.maUpperRect );
+
+            // convert from screen space to borderwin space
+            aClipRect.SetPos( pBorder->ScreenToOutputPixel(aClipRect.TopLeft()) );
+
+            Region oldRgn( pBorder->GetClipRegion() );
+            pBorder->SetClipRegion( Region( aClipRect ) );
+
+            Point aPt;
+            Size aSize( pBorder->GetOutputSizePixel() );    // the size of the border window, i.e., the whole control
+            Region aRgn( Rectangle( aPt, aSize ) );
+            bNativeOK = pBorder->DrawNativeControl( CTRL_SPINBOX, PART_ENTIRE_CONTROL, aRgn, CTRL_STATE_ENABLED,
+                        aControlValue, rtl::OUString() );
+
+            pBorder->SetClipRegion( oldRgn );
+        }
+    }
+    return bNativeOK;
+}
+
+BOOL ImplDrawNativeSpinbuttons( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBUTTONS, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        // only paint the standalone spin buttons, all buttons are painted at once
+        bNativeOK = pWin->DrawNativeControl( CTRL_SPINBUTTONS, PART_ALL_BUTTONS, Region(), CTRL_STATE_ENABLED,
+                    aControlValue, rtl::OUString() );
+    }
+    return bNativeOK;
+}
+
 void ImplDrawSpinButton( OutputDevice* pOutDev,
 						 const Rectangle& rUpperRect,
 						 const Rectangle& rLowerRect,
 						 BOOL bUpperIn, BOOL bLowerIn,
-						 BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz )
+						 BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz, BOOL bMirrorHorz )
 {
 	DecorationView aDecoView( pOutDev );
 
@@ -98,10 +201,11 @@ void ImplDrawSpinButton( OutputDevice* p
 	const StyleSettings& rStyleSettings = pOutDev->GetSettings().GetStyleSettings();
 	if ( rStyleSettings.GetOptions() & STYLE_OPTION_SPINARROW )
 	{
+        // arrows are only use in OS/2 look
 		if ( bHorz )
 		{
-			eType1 = SYMBOL_ARROW_LEFT;
-			eType2 = SYMBOL_ARROW_RIGHT;
+            eType1 = bMirrorHorz ? SYMBOL_ARROW_RIGHT : SYMBOL_ARROW_LEFT;
+            eType2 = bMirrorHorz ? SYMBOL_ARROW_LEFT : SYMBOL_ARROW_RIGHT;
 		}
 		else
 		{
@@ -113,8 +217,8 @@ void ImplDrawSpinButton( OutputDevice* p
 	{
 		if ( bHorz )
 		{
-			eType1 = SYMBOL_SPIN_LEFT;
-			eType2 = SYMBOL_SPIN_RIGHT;
+            eType1 = bMirrorHorz ? SYMBOL_SPIN_RIGHT : SYMBOL_SPIN_LEFT;
+            eType2 = bMirrorHorz ? SYMBOL_SPIN_LEFT : SYMBOL_SPIN_RIGHT;
 		}
 		else
 		{
@@ -127,12 +231,55 @@ void ImplDrawSpinButton( OutputDevice* p
 	USHORT nTempStyle = nStyle;
 	if ( bUpperIn )
 		nTempStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
+
+    BOOL bNativeOK = FALSE;
+	Rectangle aUpRect;
+
+    if( pOutDev->GetOutDevType() == OUTDEV_WINDOW )
+    {
+        Window *pWin = (Window*) pOutDev;
+
+        // are we drawing standalone spin buttons or members of a spinfield ?
+        ControlType aControl = CTRL_SPINBUTTONS;
+        switch( pWin->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                aControl = CTRL_SPINBOX;
+                break;
+            default:
+                aControl = CTRL_SPINBUTTONS;
+                break;
+        }
+
+        SpinbuttonValue aValue;
+        ImplGetSpinbuttonValue( pWin, rUpperRect, rLowerRect,
+						        bUpperIn, bLowerIn, bUpperEnabled, bLowerEnabled,
+                                bHorz, aValue );
+
+        if( aControl == CTRL_SPINBOX )
+            bNativeOK = ImplDrawNativeSpinfield( pWin, aValue );
+        else if( aControl == CTRL_SPINBUTTONS )
+            bNativeOK = ImplDrawNativeSpinbuttons( pWin, aValue );
+    }
+
+    if( !bNativeOK )
+        aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
 
 	// Unteren/rechten Button malen
 	if ( bLowerIn )
 		nStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
+	Rectangle aLowRect;
+    if( !bNativeOK )
+	    aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
 
 	// Zusaetzliche Default-Kante wollen wir auch ausnutzen
 	aUpRect.Left()--;
@@ -177,11 +324,13 @@ void ImplDrawSpinButton( OutputDevice* p
 	nTempStyle = nSymStyle;
 	if ( !bUpperEnabled )
 		nTempStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
+    if( !bNativeOK )
+	    aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
 
 	if ( !bLowerEnabled )
 		nSymStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
+    if( !bNativeOK )
+        aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
 }
 
 // =======================================================================
@@ -209,14 +358,27 @@ void SpinField::ImplInit( Window* pParen
 	if ( nWinStyle & (WB_SPIN|WB_DROPDOWN) )
 	{
 		mbSpin = TRUE;
-		mpEdit = new Edit( this, WB_NOBORDER );
-        mpEdit->EnableRTL( FALSE );
+		
+		// Some themes want external spin buttons, therefore the main
+		// spinfield should not overdraw the border between its encapsulated
+		// edit field and the spin buttons
+		if ( (nWinStyle & WB_SPIN) &&
+		    IsNativeControlSupported(CTRL_SPINBOX, HAS_BACKGROUND_TEXTURE) ) 
+		{
+			SetBackground();
+			mpEdit = new Edit( this, WB_NOBORDER );
+			mpEdit->SetBackground();
+		}
+		else
+			mpEdit = new Edit( this, WB_NOBORDER );
+
+		mpEdit->EnableRTL( FALSE );
 		mpEdit->SetPosPixel( Point() );
 		mpEdit->Show();
 		SetSubEdit( mpEdit );
 
 		maRepeatTimer.SetTimeoutHdl( LINK( this, SpinField, ImplTimeout ) );
-		maRepeatTimer.SetTimeout( SPIN_DELAY );
+		maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
 		if ( nWinStyle & WB_REPEAT )
 			mbRepeat = TRUE;
 
@@ -346,7 +508,7 @@ void SpinField::MouseButtonUp( const Mou
 	ReleaseMouse();
 	mbInitialUp = mbInitialDown = FALSE;
 	maRepeatTimer.Stop();
-	maRepeatTimer.SetTimeout( SPIN_DELAY );
+	maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
 
 	if ( mbUpperIn )
 	{
@@ -518,9 +680,9 @@ void SpinField::Paint( const Rectangle& 
 {
 	if ( mbSpin )
 	{
-		BOOL bEnable = IsEnabled();
-		ImplDrawSpinButton( this, maUpperRect, maLowerRect,
-							mbUpperIn, mbLowerIn, bEnable, bEnable );
+		BOOL	bEnable = IsEnabled();
+        ImplDrawSpinButton( this, maUpperRect, maLowerRect,
+		                    mbUpperIn, mbLowerIn, bEnable, bEnable );
 	}
 
 	if ( GetStyle() & WB_DROPDOWN )
@@ -547,11 +709,13 @@ void SpinField::Paint( const Rectangle& 
 
 void SpinField::ImplCalcButtonAreas( OutputDevice* pDev, const Size& rOutSz, Rectangle& rDDArea, Rectangle& rSpinUpArea, Rectangle& rSpinDownArea )
 {
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+	const StyleSettings& rStyleSettings = pDev->GetSettings().GetStyleSettings();
 
 	Size aSize = rOutSz;
 	Size aDropDownSize;
 
+    DBG_ASSERT( !(GetStyle() & WB_DROPDOWN), "SpinField::ImplCalcButtonAreas(): SpinField with drop down not supported on all (native) platforms !" );
+
 	if ( GetStyle() & WB_DROPDOWN )
 	{
 		long nW = rStyleSettings.GetScrollBarSize();
@@ -568,13 +732,56 @@ void SpinField::ImplCalcButtonAreas( Out
 	if ( GetStyle() & WB_SPIN )
 	{
 		long nBottom1 = aSize.Height()/2;
+		long nBottom2 = aSize.Height()-1;
 		long nTop2 = nBottom1;
+		long nTop1 = 0;
 		if ( !(aSize.Height() & 0x01) )
 			nBottom1--;
 
-		aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
-		rSpinUpArea = Rectangle( aSize.Width(), 0, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
-		rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), aSize.Height()-1 );
+        BOOL bNativeRegionOK = FALSE;
+        Region aContentUp, aContentDown;
+
+		if ( (pDev->GetOutDevType() == OUTDEV_WINDOW) && 
+            IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+        {
+            Window *pWin = (Window*) pDev;
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // get the system's spin button size
+		    ImplControlValue aControlValue;
+		    Region aBound;
+		    Point aPoint;
+
+            // use the full extent of the control
+		    Region aArea( Rectangle( aPoint, pBorder->GetOutputSizePixel() ) );
+
+		    bNativeRegionOK = 
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_UP,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentUp) &&
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_DOWN,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentDown);
+
+            if( bNativeRegionOK )
+            {
+                // convert back from border space to local coordinates
+                aPoint = pBorder->ScreenToOutputPixel( pWin->OutputToScreenPixel( aPoint ) );
+                aContentUp.Move(-aPoint.X(), -aPoint.Y());
+                aContentDown.Move(-aPoint.X(), -aPoint.Y());
+            }
+        }
+
+        if( bNativeRegionOK )
+        {
+		    rSpinUpArea = aContentUp.GetBoundRect();
+		    rSpinDownArea = aContentDown.GetBoundRect();
+        }
+        else
+        {
+		    aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
+
+		    rSpinUpArea = Rectangle( aSize.Width(), nTop1, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
+		    rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), nBottom2 );
+        }
 	}
 	else
 	{
@@ -589,14 +796,13 @@ void SpinField::Resize()
 {
 	if ( mbSpin )
 	{
-        Control::Resize();
+		Control::Resize();
 		Size aSize = GetOutputSizePixel();
 
 		if ( GetStyle() & (WB_SPIN|WB_DROPDOWN) )
 		{
 			ImplCalcButtonAreas( this, aSize, maDropDownRect, maUpperRect, maLowerRect );
-			aSize.Width() -= maDropDownRect.GetWidth();
-			aSize.Width() -= maUpperRect.GetWidth();
+			aSize.Width() = maUpperRect.Left();
 		}
 
 		mpEdit->SetSizePixel( aSize );
@@ -682,6 +888,56 @@ void SpinField::DataChanged( const DataC
 
 // -----------------------------------------------------------------------
 
+Rectangle* SpinField::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinField::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Edit::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void SpinField::EndDropDown()
 {
 	mbInDropDown = FALSE;
@@ -736,9 +992,9 @@ USHORT SpinField::GetMaxVisChars() const
 
 IMPL_LINK( SpinField, ImplTimeout, Timer*, pTimer )
 {
-	if ( pTimer->GetTimeout() == SPIN_DELAY )
+	if ( pTimer->GetTimeout() == GetSettings().GetMouseSettings().GetButtonStartRepeat() )
 	{
-		pTimer->SetTimeout( SPIN_SPEED );
+		pTimer->SetTimeout( GetSettings().GetMouseSettings().GetButtonRepeat() );
 		pTimer->Start();
 	}
 	else
@@ -755,7 +1011,7 @@ IMPL_LINK( SpinField, ImplTimeout, Timer
 
 void SpinField::Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags )
 {
-    Edit::Draw( pDev, rPos, rSize, nFlags );
+	Edit::Draw( pDev, rPos, rSize, nFlags );
 
 	WinBits nStyle = GetStyle();
 	if ( !(nFlags & WINDOW_DRAW_NOCONTROLS ) && ( nStyle & (WB_SPIN|WB_DROPDOWN) ) )
Index: vcl/source/control/tabctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/tabctrl.cxx,v
retrieving revision 1.17
retrieving revision 1.21
diff -u -p -u -r1.17 -r1.21
--- vcl/source/control/tabctrl.cxx	12 Jun 2003 07:51:17 -0000	1.17
+++ vcl/source/control/tabctrl.cxx	10 May 2004 15:48:11 -0000	1.21
@@ -59,14 +59,12 @@
  *
  ************************************************************************/
 
-#define _SV_TABCTRL_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -102,8 +97,6 @@
 #include <hash_map>
 #include <vector>
 
-#pragma hdrstop
-
 // =======================================================================
 
 struct ImplTabCtrlData
@@ -176,6 +169,9 @@ void TabControl::ImplInit( Window* pPare
     if ( !(nStyle & WB_NODIALOGCONTROL) )
         nStyle |= WB_DIALOGCONTROL;
 
+    // no single line tabs since NWF
+    nStyle &= ~WB_SINGLELINE;
+
     Control::ImplInit( pParent, nStyle, NULL );
 
     mpItemList          		= new ImplTabItemList( 8, 8 );
@@ -199,11 +195,13 @@ void TabControl::ImplInit( Window* pPare
     mpTabCtrlData->mpLeftBtn    = NULL;
     mpTabCtrlData->mpRightBtn   = NULL;
 
-    if ( (GetSettings().GetStyleSettings().GetTabControlStyle() & STYLE_TABCONTROL_SINGLELINE) ||
-         (nStyle & WB_SINGLELINE) )
-        mbSingleLine = TRUE;
 
     ImplInitSettings( TRUE, TRUE, TRUE );
+
+    // if the tabcontrol is drawn (ie filled) by a native widget, make sure all contols will have transparent background
+    // otherwise they will paint with a wrong background
+    if( IsNativeControlSupported(CTRL_TAB_PANE, PART_ENTIRE_CONTROL) )
+        EnableChildTransparentMode( TRUE );
 }
 
 // -----------------------------------------------------------------------
@@ -235,8 +233,13 @@ void TabControl::ImplInitSettings( BOOL 
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported(CTRL_TAB_PANE, PART_ENTIRE_CONTROL) 
+            || IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL) )
+
         {
+            // set transparent mode for NWF tabcontrols to have
+            // the background always cleared properly
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
             SetPaintTransparent( TRUE );
@@ -255,8 +258,6 @@ void TabControl::ImplInitSettings( BOOL 
         }
     }
 
-    // Sollen TabReiter farbig dargestellt werden
-    mbColored =  (rStyleSettings.GetTabControlStyle() & STYLE_TABCONTROL_COLOR) != 0;
     ImplScrollBtnsColor();
 }
 
@@ -365,17 +366,8 @@ void TabControl::ImplScrollBtnsColor()
 {
     if ( mpTabCtrlData && mpTabCtrlData->mpLeftBtn )
     {
-        if ( mbColored )
-        {
-            Color aScrollBtnColor( COL_LIGHTBLUE );
-            mpTabCtrlData->mpLeftBtn->SetControlForeground( aScrollBtnColor );
-            mpTabCtrlData->mpRightBtn->SetControlForeground( aScrollBtnColor );
-        }
-        else
-        {
-            mpTabCtrlData->mpLeftBtn->SetControlForeground();
-            mpTabCtrlData->mpRightBtn->SetControlForeground();
-        }
+        mpTabCtrlData->mpLeftBtn->SetControlForeground();
+        mpTabCtrlData->mpRightBtn->SetControlForeground();
     }
 }
 
@@ -493,15 +485,11 @@ Rectangle TabControl::ImplGetTabRect( US
     if ( nPos == TAB_PAGERECT )
     {
         USHORT nLastPos;
-        if ( mbSingleLine )
-            nLastPos = mnFirstPagePos;
+        if ( mnCurPageId )
+            nLastPos = GetPagePos( mnCurPageId );
         else
-        {
-            if ( mnCurPageId )
-                nLastPos = GetPagePos( mnCurPageId );
-            else
-                nLastPos = 0;
-        }
+            nLastPos = 0;
+
         Rectangle aRect = ImplGetTabRect( nLastPos, nWidth, nHeight );
         aRect = Rectangle( Point( TAB_OFFSET, aRect.Bottom()+TAB_OFFSET ),
                            Size( nWidth-TAB_OFFSET*2,
@@ -545,86 +533,7 @@ Rectangle TabControl::ImplGetTabRect( US
             nMaxWidth = mnMaxPageWidth;
 
         mbScroll = FALSE;
-        if ( mbSingleLine )
-        {
-            // Zuerst ermitteln wir, ob wir scrollen muessen
-            pItem = mpItemList->First();
-            while ( pItem )
-            {
-                aSize = ImplGetItemSize( pItem, nMaxWidth );
-                pItem->maRect = Rectangle( Point( nX, nY ), aSize );
-                pItem->mnLine = 1;
-                pItem->mbFullVisible = TRUE;
-                nX += aSize.Width();
-
-                if ( (nX > nWidth-2) && (nWidth > 4) )
-                    mbScroll = TRUE;
-
-                pItem = mpItemList->Next();
-            }
-
-            // Wenn wir Scrollen muessen, dann muessen die Reiter
-            // entsprechend angeordnet werden
-            if ( mbScroll )
-            {
-                // Zuerst ermitteln wir den letzten TabReiter, bei dem
-                // die restlichen noch sichtbar bleiben und passen
-                // gegebenenfalls den ersten sichtbaren Writer an
-                mnBtnSize = GetTextHeight()+(TAB_TABOFFSET_Y*2);
-                long    nMaxWidth = nWidth-(mnBtnSize*2);
-                long    nTempWidth = 0;
-                USHORT  nPageCount = GetPageCount();
-                mnLastFirstPagePos = nPageCount;
-                pItem = mpItemList->Last();
-                while ( pItem )
-                {
-                    nTempWidth += pItem->maRect.GetSize().Width();
-                    if ( nTempWidth > nMaxWidth )
-                        break;
-
-                    mnLastFirstPagePos--;
-                    pItem = mpItemList->Prev();
-                }
-                if ( mnLastFirstPagePos > nPageCount-1 )
-                    mnLastFirstPagePos = nPageCount-1;
-                if ( mnFirstPagePos > mnLastFirstPagePos )
-                   mnFirstPagePos = mnLastFirstPagePos;
-
-                // Jetzt die TabReiter anordnen und die Reiter ausblenden,
-                // die nicht zu sehen sind
-                nPos = 0;
-                nX = 2;
-                pItem = mpItemList->First();
-                while ( pItem )
-                {
-                    if ( (nPos < mnFirstPagePos) ||
-                         ((nX > nWidth-2) && (nWidth > 4)) )
-                    {
-                        pItem->mbFullVisible = FALSE;
-                        pItem->maRect.SetEmpty();
-                        mbSmallInvalidate = FALSE;
-                    }
-                    else
-                    {
-                        aSize = pItem->maRect.GetSize();
-                        Rectangle aNewRect( Point( nX, nY ), aSize );
-                        if ( mbSmallInvalidate && (pItem->maRect != aNewRect) )
-                            mbSmallInvalidate = FALSE;
-                        pItem->maRect = aNewRect;
-                        nX += aSize.Width();
-                    }
-
-                    if ( nX > nMaxWidth )
-                        pItem->mbFullVisible = FALSE;
-
-                    pItem = mpItemList->Next();
-                    nPos++;
-                }
-            }
-            else
-                mnFirstPagePos = 0;
-        }
-        else
+        if( 1 )
         {
             USHORT          nLines = 0;
             USHORT          nCurLine = 0;
@@ -815,6 +724,17 @@ void TabControl::ImplChangeTabPage( USHO
     if ( pOldPage )
         pOldPage->Hide();
 
+    // Invalidate the same region that will be send to NWF
+    // to always allow for bitmap caching
+    // see Window::DrawNativeControl()
+    if( IsNativeControlSupported( CTRL_TAB_PANE, PART_ENTIRE_CONTROL ) )
+    {
+        aRect.Left()   -= TAB_OFFSET;
+        aRect.Top()    -= TAB_OFFSET;
+        aRect.Right()  += TAB_OFFSET;
+        aRect.Bottom() += TAB_OFFSET;
+    }
+    
     Invalidate( aRect );
 }
 
@@ -865,32 +782,7 @@ void TabControl::ImplActivateTabPage( BO
 
 void TabControl::ImplSetFirstPagePos( USHORT nPagePos )
 {
-    if ( !mbSingleLine )
-        return;
-
-    ImplFreeLayoutData();
-
-    if ( mbFormat )
-        mnFirstPagePos = nPagePos;
-    else
-    {
-        if ( nPagePos > mnLastFirstPagePos )
-            nPagePos = mnLastFirstPagePos;
-
-        if ( nPagePos != mnFirstPagePos )
-        {
-            // Neu auszugebene Rechteck berechnen
-            Rectangle aRect = ImplGetTabRect( TAB_PAGERECT );
-            aRect.Bottom()  = aRect.Top();
-            aRect.Left()    = 0;
-            aRect.Top()     = 0;
-            aRect.Right()   = Control::GetOutputSizePixel().Width();
-
-            mbFormat = TRUE;
-            mnFirstPagePos = nPagePos;
-            Invalidate( aRect, INVALIDATE_NOCHILDREN );
-        }
-    }
+    return; // was only required for single line
 }
 
 // -----------------------------------------------------------------------
@@ -922,7 +814,7 @@ void TabControl::ImplShowFocus()
 
 // -----------------------------------------------------------------------
 
-void TabControl::ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout )
+void TabControl::ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout, bool bFirstInGroup, bool bLastInGroup, bool bIsCurrentItem )
 {
     if ( pItem->maRect.IsEmpty() )
         return;
@@ -945,6 +837,7 @@ void TabControl::ImplDrawItem( ImplTabIt
     BOOL                    bLeftBorder = TRUE;
     BOOL                    bRightBorder = TRUE;
     USHORT                  nOff;
+    BOOL                    bNativeOK = FALSE;
 
     USHORT nOff2 = 0;
     USHORT nOff3 = 0;
@@ -982,36 +875,59 @@ void TabControl::ImplDrawItem( ImplTabIt
         }
     }
 
-    if( ! bLayout )
+    if( !bLayout && (bNativeOK = IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		aControlValue;
+        Region				aCtrlRegion( pItem->maRect );
+        ControlState		nState = 0;
+
+        if( pItem->mnId == mnCurPageId )
+            nState |= CTRL_STATE_SELECTED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        if ( IsEnabled() )
+            nState |= CTRL_STATE_ENABLED;
+        if( IsMouseOver() && pItem->maRect.IsInside( GetPointerPosPixel() ) )
+        {
+            nState |= CTRL_STATE_ROLLOVER;
+            ImplTabItem* pI;
+            int idx=0;
+            while( (pI = mpItemList->GetObject(idx++)) )
+                if( (pI != pItem) && (pI->maRect.IsInside( GetPointerPosPixel() ) ) )
+                {
+                    nState &= ~CTRL_STATE_ROLLOVER; // avoid multiple highlighted tabs
+                    break;
+                }
+        }
+
+        TabitemValue tiValue;
+        if(pItem->maRect.Left() < 5)
+            tiValue.mnAlignment |= TABITEM_LEFTALIGNED;
+        if(pItem->maRect.Right() > mnLastWidth - 5)
+            tiValue.mnAlignment |= TABITEM_RIGHTALIGNED;
+        if ( bFirstInGroup )
+            tiValue.mnAlignment |= TABITEM_FIRST_IN_GROUP;
+        if ( bLastInGroup )
+            tiValue.mnAlignment |= TABITEM_LAST_IN_GROUP;
+        aControlValue.setOptionalVal( (void *)(&tiValue) );
+
+        bNativeOK = DrawNativeControl( CTRL_TAB_ITEM, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue, rtl::OUString() );
+    }
+
+    if( ! bLayout && !bNativeOK )
     {
         if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
         {
-            if ( mbColored )
-            {
-                USHORT  nPos = (USHORT)mpItemList->GetPos( pItem );
-                Color   aOldFillColor = GetFillColor();
-                SetLineColor();
-                SetFillColor( aImplTabColorAry[nPos%TABCOLORCOUNT] );
-                Rectangle aColorRect;
-                aColorRect.Left()   = aRect.Left()-nOff2+1;
-                aColorRect.Top()    = aRect.Top()-nOff2+1;
-                aColorRect.Right()  = aRect.Right()+nOff2-3;
-                aColorRect.Bottom() = nLeftBottom;
-                if ( pItem->mnId != mnCurPageId )
-                    aColorRect.Bottom()--;
-                DrawRect( aColorRect );
-                SetFillColor( aOldFillColor );
-            }
-            
             SetLineColor( rStyleSettings.GetLightColor() );
-            DrawPixel( Point( aRect.Left()+1-nOff2, aRect.Top()+1-nOff2 ) );
+            DrawPixel( Point( aRect.Left()+1-nOff2, aRect.Top()+1-nOff2 ) );    // diagonally indented top-left pixel
             if ( bLeftBorder )
             {
                 DrawLine( Point( aRect.Left()-nOff2, aRect.Top()+2-nOff2 ),
                           Point( aRect.Left()-nOff2, nLeftBottom-1 ) );
             }
-            DrawLine( Point( aRect.Left()+2-nOff2, aRect.Top()-nOff2 ),
-                      Point( aRect.Right()+nOff2-3, aRect.Top()-nOff2 ) );
+            DrawLine( Point( aRect.Left()+2-nOff2, aRect.Top()-nOff2 ),         // top line starting 2px from left border
+                      Point( aRect.Right()+nOff2-3, aRect.Top()-nOff2 ) );      // ending 3px from right border
             
             if ( bRightBorder )
             {
@@ -1053,6 +969,13 @@ void TabControl::ImplDrawItem( ImplTabIt
         mpTabCtrlData->maTabRectangles.push_back( aRect );
     }
 
+    // set font accordingly, current item is painted bold
+    // we set the font attributes always before drawing to be re-entrant (DrawNativeControl may trigger additional paints)
+    Font aFont( GetFont() );
+    aFont.SetTransparent( TRUE );
+    aFont.SetWeight( bIsCurrentItem ? WEIGHT_BOLD : WEIGHT_LIGHT );
+    SetFont( aFont );
+
     Size aTabSize = aRect.GetSize();
     long nTextHeight = GetTextHeight();
     long nTextWidth = GetCtrlTextWidth( pItem->maFormatText );
@@ -1069,10 +992,6 @@ void TabControl::ImplDrawItem( ImplTabIt
 
 IMPL_LINK( TabControl, ImplScrollBtnHdl, PushButton*, pBtn )
 {
-    if ( pBtn == mpTabCtrlData->mpRightBtn )
-        ImplSetFirstPagePos( mnFirstPagePos+1 );
-    else
-        ImplSetFirstPagePos( mnFirstPagePos-1 );
     ImplSetScrollBtnsState();
     return 0;
 }
@@ -1121,15 +1040,7 @@ void TabControl::ImplPaint( const Rectan
     // Hier wird gegebenenfalls auch neu formatiert
     Rectangle aRect = ImplGetTabRect( TAB_PAGERECT );
 
-    // Fonts entsprechend setzen
-    Font aFont( GetFont() );
-    Font aLightFont = aFont;
-    aFont.SetTransparent( TRUE );
-    aFont.SetWeight( WEIGHT_BOLD );
-    aLightFont.SetTransparent( TRUE );
-    aLightFont.SetWeight( WEIGHT_LIGHT );
-
-    // Aktuelles Item ermitteln
+    // find current item
     ImplTabItem* pPrevCurItem = NULL;
     ImplTabItem* pCurItem = NULL;
     ImplTabItem* pItem = mpItemList->First();
@@ -1145,7 +1056,7 @@ void TabControl::ImplPaint( const Rectan
         pItem = mpItemList->Next();
     }
 
-    // Border um TabPage zeichnen
+    // Draw the TabPage border
     const StyleSettings&    rStyleSettings  = GetSettings().GetStyleSettings();
     Rectangle               aCurRect;
     long                    nTopOff = 1;
@@ -1153,65 +1064,127 @@ void TabControl::ImplPaint( const Rectan
     aRect.Top()    -= TAB_OFFSET;
     aRect.Right()  += TAB_OFFSET;
     aRect.Bottom() += TAB_OFFSET;
-    if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
-        SetLineColor( rStyleSettings.GetLightColor() );
-    else
-        SetLineColor( Color( COL_BLACK ) );
-    if ( pCurItem && !pCurItem->maRect.IsEmpty() )
+
+    BOOL bNativeOK = FALSE;
+    if( (bNativeOK = IsNativeControlSupported( CTRL_TAB_PANE, PART_ENTIRE_CONTROL) ) == TRUE )
     {
-        aCurRect = pCurItem->maRect;
-        if( ! bLayout )
-            DrawLine( aRect.TopLeft(), Point( aCurRect.Left()-2, aRect.Top() ) );
-        if ( aCurRect.Right()+1 < aRect.Right() )
-        {
-            if( ! bLayout )
-                DrawLine( Point( aCurRect.Right(), aRect.Top() ), aRect.TopRight() );
-        }
-        else
-            nTopOff = 0;
+        const ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+        ControlState nState = CTRL_STATE_ENABLED;
+        int part = PART_ENTIRE_CONTROL;
+        if ( !IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        
+        Region aClipRgn( GetActiveClipRegion() );
+        aClipRgn.Intersect( aRect );
+        if( !rRect.IsEmpty() )
+            aClipRgn.Intersect( rRect );
+        
+        Region aCtrlRegion( aRect );
+        Rectangle aClipRect( aClipRgn.GetBoundRect() );
+        if( !aClipRgn.IsEmpty() ) //&& aClipRect.getHeight() && aClipRect.getWidth() )
+            bNativeOK = DrawNativeControl( CTRL_TAB_PANE, part, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
     }
     else
-        if( ! bLayout )
-            DrawLine( aRect.TopLeft(), aRect.TopRight() );
-
-    if( ! bLayout )
     {
-        DrawLine( aRect.TopLeft(), aRect.BottomLeft() );
-
         if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
+            SetLineColor( rStyleSettings.GetLightColor() );
+        else
+            SetLineColor( Color( COL_BLACK ) );
+        if ( pCurItem && !pCurItem->maRect.IsEmpty() )
         {
-            SetLineColor( rStyleSettings.GetShadowColor() );
-            DrawLine( Point( 1, aRect.Bottom()-1 ),
-                      Point( aRect.Right()-1, aRect.Bottom()-1 ) );
-            DrawLine( Point( aRect.Right()-1, aRect.Top()+nTopOff ),
-                      Point( aRect.Right()-1, aRect.Bottom()-1 ) );
-            SetLineColor( rStyleSettings.GetDarkShadowColor() );
-            DrawLine( Point( 0, aRect.Bottom() ),
-                      Point( aRect.Right(), aRect.Bottom() ) );
-            DrawLine( Point( aRect.Right(), aRect.Top()+nTopOff ),
-                      Point( aRect.Right(), aRect.Bottom() ) );
+            aCurRect = pCurItem->maRect;
+            if( ! bLayout )
+                DrawLine( aRect.TopLeft(), Point( aCurRect.Left()-2, aRect.Top() ) );
+            if ( aCurRect.Right()+1 < aRect.Right() )
+            {
+                if( ! bLayout )
+                    DrawLine( Point( aCurRect.Right(), aRect.Top() ), aRect.TopRight() );
+            }
+            else
+                nTopOff = 0;
         }
         else
+            if( ! bLayout )
+                DrawLine( aRect.TopLeft(), aRect.TopRight() );
+
+        if( ! bLayout )
         {
-            DrawLine( aRect.TopRight(), aRect.BottomRight() );
-            DrawLine( aRect.BottomLeft(), aRect.BottomRight() );
+            DrawLine( aRect.TopLeft(), aRect.BottomLeft() );
+
+            if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
+            {
+                SetLineColor( rStyleSettings.GetShadowColor() );
+                DrawLine( Point( 1, aRect.Bottom()-1 ),
+                        Point( aRect.Right()-1, aRect.Bottom()-1 ) );
+                DrawLine( Point( aRect.Right()-1, aRect.Top()+nTopOff ),
+                        Point( aRect.Right()-1, aRect.Bottom()-1 ) );
+                SetLineColor( rStyleSettings.GetDarkShadowColor() );
+                DrawLine( Point( 0, aRect.Bottom() ),
+                        Point( aRect.Right(), aRect.Bottom() ) );
+                DrawLine( Point( aRect.Right(), aRect.Top()+nTopOff ),
+                        Point( aRect.Right(), aRect.Bottom() ) );
+            }
+            else
+            {
+                DrawLine( aRect.TopRight(), aRect.BottomRight() );
+                DrawLine( aRect.BottomLeft(), aRect.BottomRight() );
+            }
         }
     }
 
-    // Alle Items bis auf das aktuelle Zeichnen (nicht fett)
-    SetFont( aLightFont );
-    pItem = mpItemList->First();
-    while ( pItem )
+    // Some native toolkits (GTK+) draw tabs right-to-left, with an
+    // overlap between adjacent tabs
+    bool			bDrawTabsRTL = IsNativeControlSupported( CTRL_TAB_ITEM, PART_TABS_DRAW_RTL );
+    ImplTabItem *	pFirstTab = NULL;
+    ImplTabItem *	pLastTab = NULL;
+    unsigned idx;
+
+    // Event though there is a tab overlap with GTK+, the first tab is not
+    // overlapped on the left side.  Other tookits ignore this option.
+    if ( bDrawTabsRTL )
+    {
+        pFirstTab = mpItemList->First();
+        pLastTab = mpItemList->Last();
+        idx = mpItemList->Count()-1;
+    }
+    else
+    {
+        pLastTab = mpItemList->Last();
+        pFirstTab = mpItemList->First();
+        idx = 0;
+    }
+
+    while ( (pItem = mpItemList->GetObject(idx)) != NULL )
     {
         if ( pItem != pCurItem )
-            ImplDrawItem( pItem, aCurRect, bLayout );
-        pItem = mpItemList->Next();
+        {
+            Region aClipRgn( GetActiveClipRegion() );
+            aClipRgn.Intersect( pItem->maRect );
+            if( !rRect.IsEmpty() )
+                aClipRgn.Intersect( rRect );
+            if( bLayout || !aClipRgn.IsEmpty() )
+                ImplDrawItem( pItem, aCurRect, bLayout, (pItem==pFirstTab), (pItem==pLastTab), FALSE );
+        }
+
+        if ( bDrawTabsRTL )
+            idx--;
+        else
+            idx++;
     }
 
-    // aktuelles Item zeichnen wir fett
-    SetFont( aFont );
     if ( pCurItem )
-        ImplDrawItem( pCurItem, aCurRect, bLayout );
+    {
+        Region aClipRgn( GetActiveClipRegion() );
+        aClipRgn.Intersect( pCurItem->maRect );
+        if( !rRect.IsEmpty() )
+            aClipRgn.Intersect( rRect );
+        if( bLayout || !aClipRgn.IsEmpty() )
+            ImplDrawItem( pCurItem, aCurRect, bLayout, (pCurItem==pFirstTab), (pItem==pLastTab), TRUE );
+    }
 
     if ( !bLayout && HasFocus() )
         ImplShowFocus();
@@ -1266,6 +1239,7 @@ void TabControl::Resize()
             Invalidate( aRect, INVALIDATE_NOCHILDREN );
         else
             Invalidate( aRect );
+            
     }
     else
     {
@@ -1451,6 +1425,76 @@ void TabControl::DataChanged( const Data
 
 // -----------------------------------------------------------------------
 
+Rectangle* TabControl::ImplFindPartRect( const Point& rPt )
+{
+    ImplTabItem* pItem = mpItemList->First();
+    ImplTabItem* pFoundItem = NULL;
+    int nFound = 0;
+    while ( pItem )
+    {
+        if ( pItem->maRect.IsInside( rPt ) )
+        {
+            // assure that only one tab is highlighted at a time
+            nFound++;
+            pFoundItem = pItem;
+        }
+        pItem = mpItemList->Next();
+    }
+    // assure that only one tab is highlighted at a time
+    return nFound == 1 ? &pFoundItem->maRect : NULL;
+}
+
+long TabControl::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aClipRgn;
+                    if( pLastRect )
+                    {
+                        // allow for slightly bigger tabitems
+                        // as used by gtk
+                        // TODO: query for the correct sizes
+                        Rectangle aRect(*pLastRect);
+                        aRect.nLeft-=2;
+                        aRect.nRight+=2;
+                        aRect.nTop-=3;
+                        aClipRgn.Union( aRect );
+                    }
+                    if( pRect )
+                    {
+                        // allow for slightly bigger tabitems
+                        // as used by gtk
+                        // TODO: query for the correct sizes
+                        Rectangle aRect(*pRect);
+                        aRect.nLeft-=2;
+                        aRect.nRight+=2;
+                        aRect.nTop-=3;
+                        aClipRgn.Union( aRect );
+                    }
+                    if( !aClipRgn.IsEmpty() )
+                        Invalidate( aClipRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 long TabControl::Notify( NotifyEvent& rNEvt )
 {
     if ( (rNEvt.GetType() == EVENT_KEYINPUT) && (GetPageCount() > 1) )
@@ -1580,7 +1624,7 @@ void TabControl::InsertPage( USHORT nPag
 
     ImplFreeLayoutData();
 
-	ImplCallEventListeners( VCLEVENT_TABPAGE_INSERTED, (void*) nPageId );
+	ImplCallEventListeners( VCLEVENT_TABPAGE_INSERTED, (void*) (ULONG)nPageId );
 }
 
 // -----------------------------------------------------------------------
@@ -1620,7 +1664,7 @@ void TabControl::RemovePage( USHORT nPag
 
         ImplFreeLayoutData();
 
-		ImplCallEventListeners( VCLEVENT_TABPAGE_REMOVED, (void*) nPageId );
+		ImplCallEventListeners( VCLEVENT_TABPAGE_REMOVED, (void*) (ULONG) nPageId );
     }
 }
 
@@ -1717,8 +1761,6 @@ void TabControl::SetCurPageId( USHORT nP
             mnActPageId = nPageId;
         else
         {
-            if ( pItem->maRect.IsEmpty() || !pItem->mbFullVisible )
-                SetFirstPageId( nPageId );
             mbFormat = TRUE;
             USHORT nOldId = mnCurPageId;
             mnCurPageId = nPageId;
@@ -1741,9 +1783,7 @@ USHORT TabControl::GetCurPageId() const
 
 void TabControl::SetFirstPageId( USHORT nPageId )
 {
-    USHORT nPos = GetPagePos( nPageId );
-    if ( (nPos != TAB_PAGE_NOTFOUND) && (nPos != mnFirstPagePos) )
-        ImplSetFirstPagePos( nPos );
+    return; // was only required for single line
 }
 
 // -----------------------------------------------------------------------
@@ -1754,7 +1794,7 @@ void TabControl::SelectTabPage( USHORT n
     {
         ImplFreeLayoutData();
 
-		ImplCallEventListeners( VCLEVENT_TABPAGE_DEACTIVATE, (void*) mnCurPageId );
+		ImplCallEventListeners( VCLEVENT_TABPAGE_DEACTIVATE, (void*) (ULONG) mnCurPageId );
         if ( DeactivatePage() )
         {
             mnActPageId = nPageId;
@@ -1763,7 +1803,7 @@ void TabControl::SelectTabPage( USHORT n
             nPageId = mnActPageId;
             mnActPageId = 0;
             SetCurPageId( nPageId );
-			ImplCallEventListeners( VCLEVENT_TABPAGE_ACTIVATE, (void*) nPageId );
+			ImplCallEventListeners( VCLEVENT_TABPAGE_ACTIVATE, (void*) (ULONG) nPageId );
         }
     }
 }
@@ -1830,7 +1870,7 @@ void TabControl::SetPageText( USHORT nPa
         if ( IsUpdateMode() )
             Invalidate();
         ImplFreeLayoutData();
-		ImplCallEventListeners( VCLEVENT_TABPAGE_PAGETEXTCHANGED, (void*) nPageId );
+		ImplCallEventListeners( VCLEVENT_TABPAGE_PAGETEXTCHANGED, (void*) (ULONG) nPageId );
     }
 }
 
