--- vcl/win/source/gdi/salbmp.cxx	27 Jun 2007 20:57:18 -0000	1.11
+++ vcl/win/source/gdi/salbmp.cxx	25 Feb 2008 18:00:39 -0000
@@ -59,6 +59,9 @@
 #include <vcl/bitmap.hxx> // for BitmapSystemData
 #endif
 #include <string.h>
+#include <com/sun/star/beans/XFastPropertySet.hpp>
+
+using namespace ::com::sun::star;
 
 // -----------
 // - Inlines -
@@ -288,8 +291,20 @@ bool WinSalBitmap::Create( const SalBitm
 
 // ------------------------------------------------------------------
 
-bool WinSalBitmap::Create( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > /*xBitmapCanvas*/, Size& /*rSize*/, bool /*bMask*/ )
+bool WinSalBitmap::Create( const uno::Reference< rendering::XBitmapCanvas > xBitmapCanvas, Size& /*rSize*/, bool bMask )
 {
+    ::com::sun::star::uno::Reference< beans::XFastPropertySet > xFastPropertySet( xBitmapCanvas, uno::UNO_QUERY );
+    if( xFastPropertySet.get() ) 
+    {
+        uno::Sequence< uno::Any > args;
+        if( xFastPropertySet->getFastPropertyValue(bMask ? 2 : 1) >>= args ) 
+        {
+            sal_Int64 hBmp;
+            if( (args[0] >>= hBmp) )
+                return Create( (HBITMAP)hBmp, FALSE, FALSE );
+        }
+    }
+
     return false;
 }
 
--- canvas/source/directx/dx_canvasbitmap.hxx
+++ canvas/source/directx/dx_canvasbitmap.hxx
@@ -36,11 +36,12 @@
 #ifndef _DXCANVAS_CANVASBITMAP_HXX
 #define _DXCANVAS_CANVASBITMAP_HXX
 
-#include <cppuhelper/compbase3.hxx>
+#include <cppuhelper/compbase4.hxx>
 
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#include <com/sun/star/beans/XFastPropertySet.hpp>
 
 #include <basegfx/vector/b2isize.hxx>
 
@@ -57,9 +57,10 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper3< ::com::sun::star::rendering::XBitmapCanvas,
+    typedef ::cppu::WeakComponentImplHelper4< ::com::sun::star::rendering::XBitmapCanvas,
 											  ::com::sun::star::rendering::XIntegerBitmap,
-                         					  ::com::sun::star::lang::XServiceInfo >  	CanvasBitmapBase_Base;
+                         					  ::com::sun::star::lang::XServiceInfo,
+                         					  ::com::sun::star::beans::XFastPropertySet >  	CanvasBitmapBase_Base;
     typedef ::canvas::IntegerBitmapBase< ::canvas::BaseMutexHelper< CanvasBitmapBase_Base >,
                                          CanvasHelper,
                                          ::osl::MutexGuard,
@@ -91,6 +91,9 @@
         // bitmapFromXBitmap()!
         DXBitmapSharedPtr getSurface() { return mpSurface; };
 
+        virtual ::com::sun::star::uno::Any SAL_CALL getFastPropertyValue(sal_Int32 nHandle)  throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setFastPropertyValue(sal_Int32, const ::com::sun::star::uno::Any&)  throw (::com::sun::star::uno::RuntimeException) {}
+
     private:
         /** MUST hold here, too, since CanvasHelper only contains a
             raw pointer (without refcounting)
--- canvas/source/directx/dx_canvasbitmap.cxx	1 Nov 2007 17:51:48 -0000	1.2
+++ canvas/source/directx/dx_canvasbitmap.cxx	25 Feb 2008 17:55:44 -0000
@@ -37,6 +37,11 @@
 #include <canvas/debug.hxx>
 #include <canvas/canvastools.hxx>
 
+#include <vcl/bitmapex.hxx>
+
+#include <boost/preprocessor/iteration/local.hpp>
+#include <boost/scoped_array.hpp>
+
 #include "dx_canvasbitmap.hxx"
 #include "dx_impltools.hxx"
 
@@ -67,6 +70,191 @@ namespace dxcanvas
         CanvasBitmap_Base::disposing();
     }
 
+    struct AlphaDIB
+    { 
+        BITMAPINFOHEADER bmiHeader; 
+        RGBQUAD          bmiColors[256];
+    };
+
+    uno::Any SAL_CALL CanvasBitmap::getFastPropertyValue( sal_Int32 nHandle )  throw (uno::RuntimeException)
+    {
+        uno::Any aRes;
+        // 0 ... get BitmapEx
+        // 1 ... get Pixbuf with bitmap RGB content
+        // 2 ... get Pixbuf with bitmap alpha mask
+        switch( nHandle ) 
+        {
+            // sorry, no BitmapEx here...
+            case 0:
+                aRes = ::com::sun::star::uno::Any( reinterpret_cast<sal_Int64>( (BitmapEx*) NULL ) );
+                break;
+
+            case 1: 
+            {     
+                if(!mpSurface->hasAlpha())
+                {
+                    HBITMAP aHBmp;
+                    mpSurface->getBitmap()->GetHBITMAP(Gdiplus::Color(), &aHBmp );
+
+                    uno::Sequence< uno::Any > args(1);
+                    args[0] = uno::Any( sal_Int64(aHBmp) );
+                    
+                    aRes <<= args;
+                }
+                else
+                {
+                    // need to copy&convert the bitmap, since dx
+                    // canvas uses inline alpha channel
+                    HDC hScreenDC=GetDC(NULL);
+                    const basegfx::B2IVector aSize(mpSurface->getSize());
+                    HBITMAP hBmpBitmap = CreateCompatibleBitmap( hScreenDC, 
+                                                                 aSize.getX(), 
+                                                                 aSize.getY() );
+                    if( !hBmpBitmap )
+                        return aRes;
+                    
+                    BITMAPINFOHEADER aBIH;
+
+                    aBIH.biSize = sizeof( BITMAPINFOHEADER );
+                    aBIH.biWidth = aSize.getX();
+                    aBIH.biHeight = -aSize.getY();
+                    aBIH.biPlanes = 1;
+                    aBIH.biBitCount = 32;
+                    aBIH.biCompression = BI_RGB; // expects pixel in
+                                                 // bbggrrxx format
+                                                 // (little endian)
+                    aBIH.biSizeImage = 0;
+                    aBIH.biXPelsPerMeter = 0;
+                    aBIH.biYPelsPerMeter = 0;
+                    aBIH.biClrUsed = 0;
+                    aBIH.biClrImportant = 0;
+
+                    Gdiplus::BitmapData aBmpData;
+                    aBmpData.Width		 = aSize.getX();
+                    aBmpData.Height		 = aSize.getY();
+                    aBmpData.Stride 	 = 4*aBmpData.Width;
+                    aBmpData.PixelFormat = PixelFormat32bppARGB;
+                    aBmpData.Scan0		 = NULL;
+                    const Gdiplus::Rect aRect( 0,0,aSize.getX(),aSize.getY() );
+                    BitmapSharedPtr pGDIPlusBitmap=mpSurface->getBitmap();
+                    if( Gdiplus::Ok != pGDIPlusBitmap->LockBits( &aRect,
+                                                                 Gdiplus::ImageLockModeRead,
+                                                                 PixelFormat32bppARGB, // outputs ARGB (big endian)
+                                                                 &aBmpData ) )
+                    {
+                        // failed to lock, bail out 
+                        return aRes;
+                    }
+
+                    // now aBmpData.Scan0 contains our bits - push
+                    // them into HBITMAP, ignoring alpha
+                    SetDIBits( hScreenDC, hBmpBitmap, 0, aSize.getY(), aBmpData.Scan0, (PBITMAPINFO)&aBIH, DIB_RGB_COLORS );
+
+                    pGDIPlusBitmap->UnlockBits( &aBmpData );
+
+                    uno::Sequence< uno::Any > args(1);
+                    args[0] = uno::Any( sal_Int64(hBmpBitmap) );
+                    
+                    aRes <<= args;
+                }
+            }
+            break;
+
+            case 2: 
+            {
+                if(!mpSurface->hasAlpha())
+                {
+                    return aRes;
+                }
+                else
+                {
+                    static AlphaDIB aDIB=
+                        {
+                            {0,0,0,1,8,BI_RGB,0,0,0,0,0},
+                            {
+                                // this here fills palette with grey
+                                // level colors, starting from 0,0,0
+                                // up to 255,255,255
+#define BOOST_PP_LOCAL_MACRO(n_) \
+                    BOOST_PP_COMMA_IF(n_) \
+                    {n_,n_,n_,n_}
+#define BOOST_PP_LOCAL_LIMITS     (0, 255)
+#include BOOST_PP_LOCAL_ITERATE()
+                            }
+                        };
+
+                    // need to copy&convert the bitmap, since dx
+                    // canvas uses inline alpha channel
+                    HDC hScreenDC=GetDC(NULL);
+                    const basegfx::B2IVector aSize(mpSurface->getSize());
+                    HBITMAP hBmpBitmap = CreateCompatibleBitmap( hScreenDC, aSize.getX(), aSize.getY() );
+                    if( !hBmpBitmap )
+                        return aRes;
+                    
+                    aDIB.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
+                    aDIB.bmiHeader.biWidth = aSize.getX();
+                    aDIB.bmiHeader.biHeight = -aSize.getY();
+                    aDIB.bmiHeader.biPlanes = 1;
+                    aDIB.bmiHeader.biBitCount = 8;
+                    aDIB.bmiHeader.biCompression = BI_RGB;
+                    aDIB.bmiHeader.biSizeImage = 0;
+                    aDIB.bmiHeader.biXPelsPerMeter = 0;
+                    aDIB.bmiHeader.biYPelsPerMeter = 0;
+                    aDIB.bmiHeader.biClrUsed = 0;
+                    aDIB.bmiHeader.biClrImportant = 0;
+
+                    Gdiplus::BitmapData aBmpData;
+                    aBmpData.Width		 = aSize.getX();
+                    aBmpData.Height		 = aSize.getY();
+                    aBmpData.Stride 	 = 4*aBmpData.Width;
+                    aBmpData.PixelFormat = PixelFormat32bppARGB;
+                    aBmpData.Scan0		 = NULL;
+                    const Gdiplus::Rect aRect( 0,0,aSize.getX(),aSize.getY() );
+                    BitmapSharedPtr pGDIPlusBitmap=mpSurface->getBitmap();
+                    if( Gdiplus::Ok != pGDIPlusBitmap->LockBits( &aRect,
+                                                                 Gdiplus::ImageLockModeRead,
+                                                                 PixelFormat32bppARGB, // outputs ARGB (big endian)
+                                                                 &aBmpData ) )
+                    {
+                        // failed to lock, bail out 
+                        return aRes;
+                    }
+
+                    // copy only alpha channel to pAlphaBits
+                    const sal_Int32 nScanWidth((aSize.getX() + 3) & ~3);
+                    boost::scoped_array<sal_uInt8> pAlphaBits( new sal_uInt8[nScanWidth*aSize.getY()] );
+                    const sal_uInt8* pInBits=(sal_uInt8*)aBmpData.Scan0;
+                    pInBits+=3;
+                    sal_uInt8* pOutBits;
+                    for( sal_Int32 y=0; y<aSize.getY(); ++y )
+                    {
+                        pOutBits=pAlphaBits.get()+y*nScanWidth;
+                        for( sal_Int32 x=0; x<aSize.getX(); ++x )
+                        {
+                            *pOutBits++ = 255-*pInBits;
+                            pInBits += 4;
+                        }
+                    }
+
+                    pGDIPlusBitmap->UnlockBits( &aBmpData );
+
+                    // set bits to newly create HBITMAP
+                    SetDIBits( hScreenDC, hBmpBitmap, 0, 
+                               aSize.getY(), pAlphaBits.get(), 
+                               (PBITMAPINFO)&aDIB, DIB_RGB_COLORS );
+
+                    uno::Sequence< uno::Any > args(1);
+                    args[0] = uno::Any( sal_Int64(hBmpBitmap) );
+                    
+                    aRes <<= args;
+                }
+            }
+            break;
+        }
+
+        return aRes;
+    }
+
 #define IMPLEMENTATION_NAME "DXCanvas.CanvasBitmap"
 #define SERVICE_NAME "com.sun.star.rendering.CanvasBitmap"
 
--- canvas/source/directx/dx_canvashelper_texturefill.cxx
+++ canvas/source/directx/dx_canvashelper_texturefill.cxx
@@ -711,8 +711,8 @@
                     const ::canvas::ParametricPolyPolygon::Values& rValues(
                         pGradient->getValues() );
 
-                    const Gdiplus::Color aColor1(tools::sequenceToArgb(rValues.maColor1));
-                    const Gdiplus::Color aColor2(tools::sequenceToArgb(rValues.maColor2));
+                    const Gdiplus::Color aColor1(tools::sequenceToArgb(rValues.maColors[0]));
+                    const Gdiplus::Color aColor2(tools::sequenceToArgb(rValues.maColors[rValues.maColors.getLength()-1]));
 
                     // TODO(E1): Return value
                     // TODO(F1): FillRule
