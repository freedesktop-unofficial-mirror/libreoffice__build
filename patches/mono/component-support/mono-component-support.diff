diff --git cli_ure/prj/build.lst cli_ure/prj/build.lst
index 6de9c94..2caa5c8 100644
--- cli_ure/prj/build.lst
+++ cli_ure/prj/build.lst
@@ -10,5 +10,6 @@ ure	cli_ure\unotypes				nmake   -       all     ure_unotypes ure_source_version
 ure	cli_ure\source\ure                      nmake   -       all     ure_source_ure ure_source_bootstrap.u ure_source_version ure_source_source ure_unotypes ure_inc NULL
 ure	cli_ure\source\uno_bridge		nmake	-		w,vc7	ure_source_uno_bridge ure_source_basetypes ure_unotypes ure_source_ure ure_inc NULL
 ure	cli_ure\source\mono_bridge      nmake   -       u       ure_source_mono_bridge ure_unotypes ure_source_ure ure_inc NULL
+ure	cli_ure\source\mono_loader      nmake   -       u       ure_source_mono_loader ure_unotypes ure_source_ure ure_inc NULL
 ure	cli_ure\source\native           nmake   -       w,vc7   ure_source_native ure_source_version ure_source_source ure_source_ure ure_unotypes ure_source_uno_bridge ure_inc NULL
 #ure	cli_ure\util                    nmake   -       w,vc7   ure_util ure_source_ure ure_source_native NULL
diff --git cli_ure/prj/d.lst cli_ure/prj/d.lst
index 53cc64a..1bbd0cc 100644
--- cli_ure/prj/d.lst
+++ cli_ure/prj/d.lst
@@ -3,6 +3,8 @@
 ..\%__SRC%\bin\climaker.pdb %_DEST%\bin%_EXT%\climaker.pdb
 ..\%__SRC%\bin\climaker.exe.config %_DEST%\bin%_EXT%\climaker.exe.config
 
+..\%__SRC%\bin\mono_loader*.dll %_DEST%\bin%_EXT%\mono_loader*.dll
+..\%__SRC%\lib\mono_loader*.so %_DEST%\lib%_EXT%\mono_loader*.so
 ..\%__SRC%\bin\cli_*.dll %_DEST%\bin%_EXT%\cli_*.dll
 ..\%__SRC%\lib\libcli*.so %_DEST%\lib%_EXT%\libcli*.so
 ..\%__SRC%\bin\cli_*.pdb %_DEST%\bin%_EXT%\cli_*.pdb
diff --git cli_ure/source/mono_bridge/.mono_bridge.cxx.swp cli_ure/source/mono_bridge/.mono_bridge.cxx.swp
deleted file mode 100644
index f53b465..0000000
diff --git cli_ure/source/mono_bridge/makefile.mk cli_ure/source/mono_bridge/makefile.mk
index 94b0e5e..6921aa1 100644
--- cli_ure/source/mono_bridge/makefile.mk
+++ cli_ure/source/mono_bridge/makefile.mk
@@ -82,7 +82,8 @@ CFLAGS+=$(MONO_CFLAGS)
 ALLTAR : 				\
 	$(SHL1TARGETN)			\
 	$(BIN)$/cli_uno_bridge.dll
-
+# put monoloader in here temporarily as I don't have the
+# stomach for trying to write a new makefile.mk
 CSFILES= 			\
 	assemblyinfo.cs		\
 	binaryuno.cs 		\
@@ -104,6 +105,7 @@ $(BIN)$/cli_uno_bridge.dll : $(CSFILES)
 		-keyfile:$(BIN)$/cliuno.snk \
 		-reference:$(BIN)$/cli_basetypes.dll	\
 		-reference:$(BIN)$/cli_uretypes.dll	\
+		-reference:$(BIN)$/cli_ure.dll	\
 		$(CSFILES)
 
 SLOFILES=                       \
diff --git cli_ure/source/mono_loader/makefile.mk cli_ure/source/mono_loader/makefile.mk
new file mode 100644
index 0000000..6fadcd2
--- /dev/null
+++ cli_ure/source/mono_loader/makefile.mk
@@ -0,0 +1,78 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.0 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=cli_ure
+TARGET=mono_loader
+
+VISIBILITY_HIDDEN=TRUE
+NO_BSYMBOLIC=	TRUE
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+CFLAGS+=$(MONO_CFLAGS)
+DLLPRE =
+
+# ------------------------------------------------------------------
+
+#.INCLUDE :  ..$/cppumaker.mk
+
+SLOFILES= \
+		$(SLO)$/service.obj \
+		$(SLO)$/mono_loader.obj
+
+SHL1TARGET= $(TARGET)$(DLLPOSTFIX).uno
+SHL1IMPLIB=     i$(TARGET)
+
+SHL1VERSIONMAP=$(SOLARENV)/src/component.map
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=$(SHL1TARGET)
+                                                                              
+SHL1STDLIBS= \
+                $(CPPUHELPERLIB) \
+		$(COMPHELPERLIB) \
+                $(CPPULIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)
+
+SHL1STDLIBS+=$(MONO_LIBS)
+                                                                              
+SHL1DEPN=
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
diff --git cli_ure/source/mono_loader/mono_loader.cxx cli_ure/source/mono_loader/mono_loader.cxx
new file mode 100644
index 0000000..a396802
--- /dev/null
+++ cli_ure/source/mono_loader/mono_loader.cxx
@@ -0,0 +1,259 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: eventhelper.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_cli_ure.hxx"
+#include <comphelper/processfactory.hxx>
+#include <comphelper/uno3.hxx>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/loader/XImplementationLoader.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/util/XMacroExpander.hpp>
+#include <cppuhelper/implbase2.hxx>
+#include "uno/mapping.hxx"
+
+// for debug
+#include <comphelper/anytostring.hxx>
+
+extern "C" {
+#include <mono/jit/jit.h>
+#include <mono/metadata/object.h>
+#include <mono/metadata/environment.h>
+#include <mono/metadata/assembly.h>
+#include <mono/metadata/debug-helpers.h>
+#include <string.h>
+#include <stdlib.h>
+}
+//#include <glib.h>
+
+using namespace ::com::sun::star;
+#define OUSTR(x) ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(x) )
+
+//static const char CLIURE_DLL[] = "$URE_LIB_DIR/cli_ure.dll";
+static const char CLIURE_DLL[] = "$URE_INTERNAL_LIB_DIR/cli_ure.dll";
+typedef ::cppu::WeakImplHelper2< loader::XImplementationLoader, lang::XServiceInfo > MonoLoader_BASE;
+
+namespace mono_loader
+{
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    uno::Reference< uno::XInterface > SAL_CALL create( uno::Reference< uno::XComponentContext > const & xContext ) SAL_THROW( () );
+
+    uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+}
+
+uno::Reference< loader::XImplementationLoader >
+create_object (MonoDomain *domain, MonoImage *image)
+{
+	MonoClass *klass;
+
+	//klass = mono_class_from_name (image, "com.sun.star.loader", "MonoLoader");
+	klass = mono_class_from_name (image, "com.sun.star.loader", "ManagedCodeLoader");
+	if (!klass) {
+		OSL_TRACE ("Can't find ManagedCodeLoader in assembly %s", mono_image_get_filename (image));
+		return NULL;
+	}
+	MonoObject* obj = mono_object_new (domain, klass);
+	/* mono_object_new () only allocates the storage: 
+	 * it doesn't run any constructor. Tell the runtime to run
+	 * the default argumentless constructor.
+	 */
+	mono_runtime_object_init (obj);
+        uno::Reference< loader::XImplementationLoader > xLoader;
+
+        // not sure if this is correct ( I'm loosely following 'to_uno'
+        // method in cli_ure/source/native/native_share.h ) 
+
+        loader::XImplementationLoader* pLoader = NULL;
+        OSL_TRACE("About to call mapInterface for XImplementionLoader returned from Mono");
+        // we are storing the object so... I guess we need to tell the gc not
+        // to bother about this object
+        //mono_gchandle_new( obj, false ); // where do we release that ? do we even need to do this?
+        guint32 nHandle = mono_gchandle_new( obj, true ); // where do we release that ? do we even need to do this?
+        uno::Mapping mapping( OUSTR( UNO_LB_CLI ), OUSTR( CPPU_CURRENT_LANGUAGE_BINDING_NAME ) );
+        OSL_ASSERT( mapping.is() );
+        if (! mapping.is() )
+            return NULL;
+
+        mapping.mapInterface( 
+            reinterpret_cast< void ** >( &pLoader ), 
+            reinterpret_cast< void * >( obj ), ::getCppuType( &xLoader ) );
+        //mono_gchandle_free ( nHandle ); // again copying what cli_ure/source/native/native_share.h does for DotNet 
+        xLoader.set( pLoader, SAL_NO_ACQUIRE /* takeover ownership */ );  
+        OSL_TRACE("We appear to have got an XImplementationLoader that has a value? %s", xLoader.is() ? "yes" : "no " );
+        return xLoader;
+}
+
+uno::Reference< loader::XImplementationLoader >
+getLoader( const char* file) {
+        OSL_TRACE("** enter getLoader()");
+	MonoDomain *domain;
+
+	/*
+	 * mono_jit_init() creates a domain: each assembly is
+	 * loaded and run in a MonoDomain.
+	 */
+	domain = mono_jit_init (file);
+	MonoAssembly *assembly;
+       
+	assembly = mono_domain_assembly_open (domain, file);
+        OSL_TRACE("** open of assembly %s = 0x%x", file, assembly);
+        if ( !assembly )
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to open assembly " ) ) + rtl::OUString::createFromAscii( file ), NULL );
+        return create_object (domain, mono_assembly_get_image (assembly));         
+        // when would we do this stuff now? surely the mono environment will
+        // last the office lifetime ( especially since we will have a single
+        // monoloader instance ( which is of course implemented in mono )
+//	retval = mono_environment_exitcode_get ();
+	
+//	mono_jit_cleanup (domain);
+}
+
+
+class MonoLoader : public MonoLoader_BASE
+{
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< loader::XImplementationLoader > mxLoader;
+    uno::Reference< util::XMacroExpander > mxExpander;
+public:
+    MonoLoader( const uno::Reference< uno::XComponentContext >& rxContext ) : mxContext( rxContext )
+    {
+        if (!(mxContext->getValueByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "/singletons/com.sun.star.util.theMacroExpander"))) >>= mxExpander)
+        || !mxExpander.is())
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "component context fails to supply singleton" " com.sun.star.util.theMacroExpander of type" " com.sun.star.util.XMacroExpander")), mxContext);        
+        }
+        rtl::OUString dllPath =  mxExpander->expandMacros( rtl::OUString(  RTL_CONSTASCII_USTRINGPARAM( CLIURE_DLL ) ) );
+        OSL_TRACE("**** location for dll is %s", rtl::OUStringToOString( dllPath, RTL_TEXTENCODING_UTF8 ).getStr() );
+        OSL_TRACE("** MonoLoader::MonoLoader() ");
+        mxLoader = getLoader( rtl::OUStringToOString( dllPath, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if ( mxLoader.is() )
+        {
+            // set the service factory
+            uno::Sequence< uno::Any > args(1);
+            args[ 0 ] <<= rxContext->getServiceManager();
+            uno::Reference< lang::XInitialization > xInitialize( mxLoader, uno::UNO_QUERY_THROW );
+            OSL_TRACE("MonoLoader::MonoLoader() about to call initialise");
+            xInitialize->initialize( args );
+/*
+            OSL_TRACE("**  MonoLoader::MonoLoader(): about to do sanity check call on 0x%x", mxLoader.get() );
+            //call with some dummy test data
+            mxLoader->activate( OUSTR("test1"), OUSTR("test2"), OUSTR("test3"), uno::Reference< registry::XRegistryKey >() );
+            mxLoader->writeRegistryInfo( uno::Reference< registry::XRegistryKey >(), OUSTR("test1"), OUSTR("test2") );
+            OSL_TRACE("**  MonoLoader::MonoLoader(): after sanity check call on 0x%x", mxLoader.get());
+*/
+        }
+        else 
+            OSL_TRACE("**  MonoLoader::MonoLoader(): No Mono loader found ");
+
+    }
+    ~MonoLoader()
+    {
+        OSL_TRACE("** MonoLoader::~MonoLoader() ");
+    }
+    // Methods
+    virtual uno::Reference< uno::XInterface > SAL_CALL activate( const ::rtl::OUString& implementationName, const ::rtl::OUString& implementationLoaderUrl, const ::rtl::OUString& locationUrl, const uno::Reference< registry::XRegistryKey >& xKey ) throw (loader::CannotActivateFactoryException, uno::RuntimeException)
+    {
+        // try to instatiate a mono loader and return a reference to it
+        OSL_TRACE("**** in MonoLoader::activate");
+        if ( mxLoader.is() )
+        {
+            OSL_TRACE("*** MonoLoader::activate() about to call activate on 0x%x", mxLoader.get() );
+            return mxLoader->activate( implementationName, implementationLoaderUrl, locationUrl, xKey );
+        }
+        return NULL;
+    }
+
+    virtual ::sal_Bool SAL_CALL writeRegistryInfo( const uno::Reference< registry::XRegistryKey >& xKey, const ::rtl::OUString& implementationLoaderUrl, const ::rtl::OUString& locationUrl ) throw (registry::CannotRegisterImplementationException, uno::RuntimeException)
+    { 
+        if ( mxLoader.is() )
+            return mxLoader->writeRegistryInfo( xKey, implementationLoaderUrl, locationUrl );
+        return sal_False;
+    }
+    virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (uno::RuntimeException){ return mono_loader::getImplementationName(); }
+    virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (uno::RuntimeException)
+    {
+        sal_Bool bRes = sal_False;
+        uno::Sequence< ::rtl::OUString > sServices = mono_loader::getSupportedServiceNames();
+        const ::rtl::OUString* pService = sServices.getConstArray();
+        const ::rtl::OUString* pEnd = sServices.getConstArray() + sServices.getLength();
+        for ( ; pService != pEnd ;  ++pService )
+        {
+            if ( (*pService).equals( ServiceName ) )
+            {
+                bRes = sal_True;
+                break;
+            }
+        }
+        return bRes;
+    }
+    virtual uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) throw (uno::RuntimeException){ return mono_loader::getSupportedServiceNames(); }
+
+};
+
+namespace mono_loader
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.loader.MonoLoader" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< uno::XInterface > SAL_CALL create(
+    uno::Reference< uno::XComponentContext > const & xContext )
+    SAL_THROW( () )
+    {
+        OSL_TRACE("** In create for monoloader");
+        // mimic java loader, just hava a single entry point ( Mono implementation 
+        // loader )
+        // #FIXME use whatever boiler plate static initialisatioon foo that is 
+        // available ( seem to recall there is some helpers for that )
+        static uno::Reference < lang::XTypeProvider  > xLoader( new MonoLoader( xContext ) );
+        return xLoader;
+    }
+
+    uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+        const ::rtl::OUString strName( ::mono_loader::getImplementationName() );
+        return uno::Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
diff --git cli_ure/source/mono_loader/mono_loader.xml cli_ure/source/mono_loader/mono_loader.xml
new file mode 100644
index 0000000..06e6c73
--- /dev/null
+++ cli_ure/source/mono_loader/mono_loader.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>mono_loader</module-name>
+    
+    <component-description>
+        <author>Noel Power </author>
+        <name>Mono Loader</name>
+        <description>Loader for components located in mono assemblies</description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>c++</language>
+        <status value="drafts"/>
+        <supported-service>org.openoffice.loader.MonoLoader</supported-service>
+        <type>com.sun.star.uno.XComponentContext</type>        
+    </component-description>
+    
+    <project-build-dependency>cppuhelper</project-build-dependency>
+    <project-build-dependency>cppu</project-build-dependency>
+    <project-build-dependency>sal</project-build-dependency>
+
+    <runtime-module-dependency>cppuhelper3$(COM)</runtime-module-dependency>
+    <runtime-module-dependency>cppu3</runtime-module-dependency>
+    <runtime-module-dependency>sal3</runtime-module-dependency>
+    
+</module-description>
diff --git cli_ure/source/mono_loader/service.cxx cli_ure/source/mono_loader/service.cxx
new file mode 100644
index 0000000..39eed95
--- /dev/null
+++ cli_ure/source/mono_loader/service.cxx
@@ -0,0 +1,133 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: service.cxx,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_cli_ure.hxx"
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace mono_loader
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end mono_loader
+
+namespace mono_testcomponent
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end mono_testcomponent
+
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::mono_loader::create, ::mono_loader::getImplementationName,
+            ::mono_loader::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+/*
+        {
+            ::mono_testcomponent::create, ::mono_testcomponent::getImplementationName,
+            ::mono_testcomponent::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+*/
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    SAL_DLLPUBLIC_EXPORT  void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** )
+    {
+        OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    SAL_DLLPUBLIC_EXPORT  sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+            return sal_True;
+        return sal_False;
+    }
+
+    SAL_DLLPUBLIC_EXPORT  void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
diff --git cli_ure/source/ure/makefile.mk cli_ure/source/ure/makefile.mk
index e3ca4a8..ddfff54 100644
--- cli_ure/source/ure/makefile.mk
+++ cli_ure/source/ure/makefile.mk
@@ -65,6 +65,9 @@ CSFILES = \
     uno$/util$/WeakAdapter.cs					\
     uno$/util$/WeakBase.cs						\
     uno$/util$/WeakComponentBase.cs	\
+    uno$/util$/RegistrationClassFinder.cs \
+    uno$/util$/Factory.cs \
+    uno$/util$/ManagedCodeLoader.cs \
     $(ASSEMBLY_ATTRIBUTES)
 
 .IF "$(COM)" == "MSC" && "$(CCNUMVER)" <= "001399999999"
@@ -87,6 +90,7 @@ $(BIN)$/cli_ure.dll : $(CSFILES) $(BIN)$/cli_uretypes.dll $(BIN)$/cliureversion.
         -target:library \
         -out:$@ \
         -reference:$(OUT)$/bin$/cli_uretypes.dll \
+        -reference:$(OUT)$/bin$/cli_basetypes.dll \
         -reference:System.dll \
         $(CSFILES)
     @echo "If code has changed then provide a policy assembly and change the version!"
diff --git cli_ure/source/ure/uno/util/Factory.cs cli_ure/source/ure/uno/util/Factory.cs
new file mode 100644
index 0000000..c14af46
--- /dev/null
+++ cli_ure/source/ure/uno/util/Factory.cs
@@ -0,0 +1,186 @@
+using System;
+using System.Reflection;
+
+using unoidl.com.sun.star.lang;
+using unoidl.com.sun.star.uno;
+using unoidl.com.sun.star.registry;
+namespace uno.util {
+
+public class Factory : WeakComponentBase , unoidl.com.sun.star.lang.XSingleComponentFactory, unoidl.com.sun.star.lang.XServiceInfo
+{
+    public static XSingleComponentFactory createComponentFactory(
+        Type impl_class, String[] supported_services )
+    {
+        return new Factory( impl_class, supported_services );
+    }
+
+    public static bool writeRegistryServiceInfo(
+        String impl_name, String[] supported_services, XRegistryKey xKey )
+    {
+        Console.WriteLine( "#####  HERE ##### ");
+        try
+        {
+            Console.WriteLine( "##### " + typeof( Factory ).ToString() + ".writeRegistryServiceInfo creating new key for SERVICES" );
+ 
+            unoidl.com.sun.star.registry.XRegistryKey xNewKey = xKey.createKey( "/" + impl_name + "/UNO/SERVICES" );
+            for ( int nPos = 0; nPos < supported_services.Length; ++nPos )
+            {
+                xNewKey.createKey( supported_services[ nPos ] );
+                Console.WriteLine( "##### " + typeof( Factory ).ToString() + ".writeRegistryServiceInfo created new key fo " + supported_services[ nPos ] );
+            }
+            return true;
+        }
+        //catch ( unoidl.com.sun.star.registry.InvalidRegistryException exc)
+        catch ( System.Exception e )
+        {
+            Console.WriteLine( "##### " + typeof( Factory ).ToString() + ".writeRegistryServiceInfo - exc: " + e );
+        }
+        return false;
+    }
+    
+    private String m_impl_name;
+    private String [] m_supported_services;
+    private Type m_impl_class;
+    private MethodInfo m_method;
+    private ConstructorInfo m_ctor;
+    
+    // ctor
+    private Factory( Type impl_class, String[] supported_services )
+        //throws com.sun.star.uno.RuntimeException
+    {
+        m_impl_name = impl_class.ToString();
+        m_supported_services = supported_services;
+        m_impl_class = impl_class;
+        m_method = null;
+        m_ctor = null;
+        
+        Type[] mparams = { typeof ( unoidl.com.sun.star.uno.XComponentContext ) };
+        
+        try
+        {
+            // seeking for "public static Object __create( XComponentContext )"
+            // #FIXME we should check the return type too, should be Object
+            m_method = m_impl_class.GetMethod("__create", BindingFlags.Public | BindingFlags.Static, null, CallingConventions.Any, mparams, null );
+/*
+            if ( m_method.ReturnType != typeof ( Object ) )
+                m_method = null;
+*/
+
+        }
+        catch (System.Exception /*exc*/)
+        {
+        }
+        
+        if (null == m_method)
+        {
+            try
+            {
+                Console.WriteLine( "searching for ctor with unoidl.com.sun.star.uno.XComponentContext ");
+                // ctor with context
+                m_ctor = m_impl_class.GetConstructor( new Type[] { typeof ( unoidl.com.sun.star.uno.XComponentContext ) }  );
+                Console.WriteLine( "found ctor ? " + ( m_ctor != null ).ToString() );
+            
+            }
+            catch (System.Exception /*exc*/)
+            {
+
+                // else take default ctor
+                m_ctor = m_impl_class.GetConstructor(null);
+            }
+        }
+    }
+    
+    //______________________________________________________________________________________________
+    private Object instantiate( XComponentContext xContext )
+//        throws com.sun.star.uno.Exception
+    {
+        try
+        {
+            Console.WriteLine( "instantiating " + m_impl_class.ToString() + " using " );
+            if (null != m_method)
+            {
+                Console.WriteLine( "\t__create( XComponentContext )..." );
+                return m_method.Invoke( null, new Object [] { xContext } );
+            }
+            if (null != m_ctor)
+            {
+                Console.WriteLine( "\tctor( XComponentContext )..." );
+                return m_ctor.Invoke( new Object[] { xContext } );
+            }
+            Console.WriteLine( "\tdefault ctor ..." );
+            // #FIXME check this
+            return m_impl_class.GetConstructor(null).Invoke(null); // default ctor
+        }
+        catch ( System.Exception e )
+        {
+            Console.WriteLine( "\tcontructing component " + m_impl_class.ToString() + " failed exc: " + e );
+            throw new unoidl.com.sun.star.uno.RuntimeException( e.ToString(), null );
+        }
+        // #FIXME sort out the exception foo below
+/*
+        catch (java.lang.reflect.InvocationTargetException exc)
+        {
+            Throwable targetException = exc.getTargetException();
+            if (targetException instanceof java.lang.RuntimeException)
+                throw (java.lang.RuntimeException)targetException;
+            else if (targetException instanceof com.sun.star.uno.RuntimeException)
+                throw (com.sun.star.uno.RuntimeException)targetException;
+            else if (targetException instanceof com.sun.star.uno.Exception)
+                throw (com.sun.star.uno.Exception)targetException;
+            else
+                throw new com.sun.star.uno.Exception( targetException.toString(), this );
+        }
+        catch (IllegalAccessException exc)
+        {
+            throw new com.sun.star.uno.RuntimeException( exc.toString(), this );
+        }
+        catch (InstantiationException exc)
+        {
+            throw new com.sun.star.uno.RuntimeException( exc.toString(), this );
+        }
+*/
+    }
+    // XSingleComponentFactory impl
+    //______________________________________________________________________________________________
+    public Object createInstanceWithContext(
+        unoidl.com.sun.star.uno.XComponentContext xContext )
+//        throws com.sun.star.uno.Exception
+    {
+        return instantiate( xContext );
+    }
+    //______________________________________________________________________________________________
+    public Object createInstanceWithArgumentsAndContext(
+        uno.Any[] arguments, unoidl.com.sun.star.uno.XComponentContext xContext )
+//        throws com.sun.star.uno.Exception
+    {
+        Object inst = instantiate( xContext );
+        unoidl.com.sun.star.lang.XInitialization xInit = ( unoidl.com.sun.star.lang.XInitialization ) inst;
+        xInit.initialize( arguments );
+        return inst;
+    }
+    
+    // XServiceInfo impl
+    //______________________________________________________________________________________________
+    public String getImplementationName()
+    {
+        return m_impl_name;
+    }
+    //______________________________________________________________________________________________
+    public bool supportsService( String service_name )
+    {
+        for ( int nPos = 0; nPos < m_supported_services.Length; ++nPos )
+        {
+            if (m_supported_services[ nPos ] == service_name )
+                return true;
+        }
+        return false;
+    }
+    //______________________________________________________________________________________________
+    public String [] getSupportedServiceNames()
+    {
+        return m_supported_services;
+    }
+}
+
+}
+
diff --git cli_ure/source/ure/uno/util/ManagedCodeLoader.cs cli_ure/source/ure/uno/util/ManagedCodeLoader.cs
new file mode 100644
index 0000000..8ac8d50
--- /dev/null
+++ cli_ure/source/ure/uno/util/ManagedCodeLoader.cs
@@ -0,0 +1,205 @@
+using System;
+using System.Reflection;
+
+using unoidl.com.sun.star.lang;
+using unoidl.com.sun.star.uno;
+using unoidl.com.sun.star.registry;
+
+namespace com.sun.star.loader
+{
+class MyCrappyDecoder 
+{
+    private class MyCrappyInner : Uri
+    {
+        public MyCrappyInner() : base( "http://localhost" ) {}
+        public String Decode( String foo ) { return base.Unescape(foo); }
+    }
+    static private MyCrappyInner aInst = new MyCrappyInner();
+    public static String Decode( String foo ) { return aInst.Decode( foo ); }
+}
+  
+
+// loader for cs components
+public class ManagedCodeLoader : uno.util.WeakBase, unoidl.com.sun.star.loader.XImplementationLoader, unoidl.com.sun.star.lang.XServiceInfo, unoidl.com.sun.star.lang.XInitialization
+{
+    private unoidl.com.sun.star.lang.XMultiServiceFactory multiServiceFactory;
+    private String[] supportedServices = {
+        "com.sun.star.loader.ManagedCodeLoader"
+    };
+
+    private unoidl.com.sun.star.util.XMacroExpander m_xMacroExpander = null;
+    private String EXPAND_PROTOCOL_PREFIX = "vnd.sun.star.expand:";
+
+    /** Expands macrofied url using the macro expander singleton.
+     */
+    private String expand_url( String url )
+    {
+            Console.WriteLine( "#1 expand_url " + url );
+
+        if (url != null && url.StartsWith( EXPAND_PROTOCOL_PREFIX ))
+        {
+            try
+            {
+                if (m_xMacroExpander == null)
+                {
+                    Console.WriteLine( "#2 attempt to get macroexpander ");
+                    unoidl.com.sun.star.beans.XPropertySet xProps = ( unoidl.com.sun.star.beans.XPropertySet ) multiServiceFactory;
+                    if (xProps == null)
+                    {
+                        throw new unoidl.com.sun.star.uno.RuntimeException(
+                            "service manager does not support XPropertySet!",
+                            this );
+                    }
+                    unoidl.com.sun.star.uno.XComponentContext xContext = (unoidl.com.sun.star.uno.XComponentContext) xProps.getPropertyValue( "DefaultContext" ).Value;
+                    m_xMacroExpander = ( unoidl.com.sun.star.util.XMacroExpander )xContext.getValueByName( "/singletons/com.sun.star.util.theMacroExpander" ).Value;
+                    Console.WriteLine( "#3 got macroexpander ");
+                }
+                /* #FIXME there must be a better way of doing this
+                   1. the Uri.UnescapeDataString is not available
+                   for mono on sled ( not sure about what later versions on
+                   other platforms provide
+                   2. unescape probably won't do exactly what we want
+                   3. unescape besides being deprecated is protected :-/ hence
+                      MyCrappyDecoder 
+                */
+                String macro = MyCrappyDecoder.Decode( url.Substring( EXPAND_PROTOCOL_PREFIX.Length ).Replace( "+", "%2B" ) );
+                Console.WriteLine( "#4 decoded url " + macro);
+                // decode uric class chars
+/*
+                String macro = URLDecoder.decode(
+                    StringHelper.replace(
+                        url.substring( EXPAND_PROTOCOL_PREFIX.length() ),
+                        '+', "%2B" ) );
+*/
+                // expand macro string
+                String ret = m_xMacroExpander.expandMacros( macro );
+                Console.WriteLine( "#5 decoded & expanded url " + ret);
+                return ret;
+            }
+            catch (unoidl.com.sun.star.uno.Exception exc)
+            {
+                throw new unoidl.com.sun.star.uno.RuntimeException(
+                    exc.ToString(), this );
+            }
+            catch ( System.Exception exc)
+            {
+                throw new unoidl.com.sun.star.uno.RuntimeException(
+                    exc.ToString(), this );
+            }
+        }
+        return url;
+    }
+
+    // XImplementationLoader 
+    public System.Object activate(String implementationName, String implementationLoaderUrl, String locationUrl, unoidl.com.sun.star.registry.XRegistryKey key )
+    {
+        locationUrl = expand_url( locationUrl ); 
+        Console.WriteLine( "*** *** ManagedCodeLoader.activate( " +  implementationName + ", " + implementationLoaderUrl + ", " + locationUrl + ") ****" );
+        // implementationName will be the class ( or Type ) name
+        // locationUrl is the name of the assembly it will be in
+        
+        // here's a cheap and nasty facimile of what the java loader does
+        Type clazz = null;
+
+        try
+        {
+            clazz = RegistrationClassFinder.find( locationUrl );
+        }
+        catch (System.NullReferenceException e)
+        {
+            throw new unoidl.com.sun.star.uno.RuntimeException( "Failed to instatiate " + implementationName + "\nexc: " + e, null );
+        }
+
+        System.Object returnObject = null;
+        MethodInfo compfac_method;
+        try
+        {
+            Type[] compParams = { typeof(String) };
+            compfac_method =  clazz.GetMethod( "__getComponentFactory" , compParams );
+            if ( compfac_method != null )
+            {
+                Object ret = compfac_method.Invoke( clazz, new Object [] { implementationName } );
+                if ( ret != null )
+                    returnObject = ( unoidl.com.sun.star.lang.XSingleComponentFactory )ret;
+            }
+    
+        }
+        catch ( System.Exception e )
+        {
+            throw new unoidl.com.sun.star.uno.RuntimeException( "Failed to activate factory for " + implementationName + "\nexc: " + e, null );
+        }
+        return returnObject;
+    }
+    public bool writeRegistryInfo(unoidl.com.sun.star.registry.XRegistryKey key, String implementationLoaderUrl, String locationUrl)
+    {
+        locationUrl = expand_url( locationUrl ); 
+        Console.WriteLine( "*** *** ManagedCodeLoader.writeRegistryInfo( " + implementationLoaderUrl  + ", " +  locationUrl + ") ****" );
+        bool bReturn = false;
+        // implementationName will be the class ( or Type ) name
+        // locationUrl is the name of the assembly it will be in
+        
+        // here's a cheap and nasty facsimile of what the java loader does
+        Type clazz = null;
+
+        try
+        {
+            clazz = RegistrationClassFinder.find( locationUrl );
+        }
+        catch (System.NullReferenceException /*e*/)
+        {
+            throw new unoidl.com.sun.star.uno.RuntimeException(  "Failed to find " + clazz.ToString(), null );
+        }
+
+        MethodInfo compfac_method;
+        try
+        {
+            Type[] regParams = { typeof(unoidl.com.sun.star.registry.XRegistryKey ) };
+            compfac_method =  clazz.GetMethod( "__writeRegistryServiceInfo" , regParams );
+            if ( compfac_method != null )
+            {
+                Object ret = compfac_method.Invoke( clazz, new Object [] { key } );
+                if ( ret != null )
+                    bReturn = ( bool )ret;
+            }
+    
+        }
+        catch ( System.Exception /*e*/ )
+        {
+            throw new unoidl.com.sun.star.uno.RuntimeException(  "Failed to activate factory for " + clazz.ToString(), null );
+        }
+        return bReturn;
+
+    }
+    // XInitialization
+    public void initialize( uno.Any[] args )
+    {
+        Console.WriteLine( "*** *** Entering ManagedCodeLoader.initialize() ");
+        if ( args.Length == 0 )
+            // probably need to change to uno.Exception
+            throw new System.Exception("No arguments passed to initialize");
+        multiServiceFactory = (unoidl.com.sun.star.lang.XMultiServiceFactory)args[0].Value;
+        if ( multiServiceFactory == null )
+            Console.WriteLine( " Bad multiservice factory " );
+        Console.WriteLine( "*** *** Leaving ManagedCodeLoader.initialize() ");
+        
+    }
+    // XServiceInfo
+    public String getImplementationName() 
+    {
+        return GetType().ToString();
+    }    
+    public bool supportsService(String serviceName) 
+    {
+        for ( int i = 0; i < supportedServices.Length; i++ ) {
+            if ( supportedServices[i] == serviceName )
+                return true;
+        }
+        return false;
+    }
+    public String[] getSupportedServiceNames() 
+    {
+        return supportedServices;
+    }    
+}
+
+}
diff --git cli_ure/source/ure/uno/util/RegistrationClassFinder.cs cli_ure/source/ure/uno/util/RegistrationClassFinder.cs
new file mode 100644
index 0000000..b5e5f46
--- /dev/null
+++ cli_ure/source/ure/uno/util/RegistrationClassFinder.cs
@@ -0,0 +1,26 @@
+using System;
+using System.Reflection;
+
+namespace com.sun.star.loader
+{
+public class RegistrationClassFinder
+{
+    public static Type find( String url )
+    {
+        Assembly assem = Assembly.LoadFrom( url );
+        // we expect a component providing assembly to provide a Registration class
+        // name. The name is in the static field 'name' of a class called 
+        // 'component.RegistrationClass'. The 'name' is the actual name of the 
+        // class that provides the following component methods
+        // __getComponentFactory & __writeRegistryServiceInfo that are needed by the
+        // loader
+        // Of course we could use someother method, maybe bury the name in 
+        // the component.dll.config ?
+        FieldInfo f = assem.GetType("component.RegistrationClass").GetField( "name", BindingFlags.Public | BindingFlags.Static );
+        String sTypeName = (String)f.GetValue( null );
+        // Try to find the RegistrationClass
+        return assem.GetType( sTypeName );
+        
+    }
+}
+}
diff --git desktop/source/deployment/registry/component/dp_component.cxx desktop/source/deployment/registry/component/dp_component.cxx
index 4a7c0ce..1feac99 100644
--- desktop/source/deployment/registry/component/dp_component.cxx
+++ desktop/source/deployment/registry/component/dp_component.cxx
@@ -589,6 +589,11 @@ Reference<deployment::XPackage> BackendImpl::bindPackage_(
                                 this, url, name, m_xPythonComponentTypeInfo,
                                 OUSTR("com.sun.star.loader.Python") );
                         }
+                        if (value.EqualsIgnoreCaseAscii("Mono")) {
+                            return new BackendImpl::ComponentPackageImpl(
+                                this, url, name, m_xPythonComponentTypeInfo,
+                                OUSTR("org.openoffice.loader.MonoLoader") );
+                        }
                     }
                 }
             }
diff --git scp2/source/ooo/ure.scp scp2/source/ooo/ure.scp
index cf94c6b..db1cc3a 100644
--- scp2/source/ooo/ure.scp
+++ scp2/source/ooo/ure.scp
@@ -706,6 +706,18 @@ File gid_File_Dl_Bootstrap
     // CompID = "2620B307-25DB-498F-B2B8-46D928165331";
 End
 
+File gid_File_Dl_MonoLoader
+    TXT_FILE_BODY;
+    Dir = SCP2_URE_DL_DIR;
+  #ifdef UNX
+    Name = STRING(CONCAT4(mono_loader,DLLPOSTFIX,.uno,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT4(mono_loader,DLLPOSTFIX,.uno,.dll));
+  #endif
+    Styles = (PACKED, UNO_COMPONENT, VERSION_INDEPENDENT_COMP_ID);
+    RegistryID = gid_Starregistry_Services_Rdb_Ure;
+End
+
 File gid_File_Dl_Bridgefac
     TXT_FILE_BODY;
     Dir = SCP2_URE_DL_DIR;
