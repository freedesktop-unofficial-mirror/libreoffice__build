From 96934d52a431410610272bd7164225d974cf8266 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:54:47 +0200
Subject: [PATCH 124/878] webdav-locking.diff

---
 .../data/org/openoffice/ucb/Configuration.xcu      |   22 ++
 sc/source/ui/docshell/docsh.cxx                    |    2 +-
 sfx2/inc/sfx2/docfile.hxx                          |    4 +-
 sfx2/source/doc/docfile.cxx                        |   59 +++-
 sfx2/source/view/viewfrm.cxx                       |    5 +
 tools/inc/tools/urlobj.hxx                         |   11 +-
 tools/source/fsys/urlobj.cxx                       |   48 ++-
 tools/workben/urltest.cxx                          |    8 +-
 ucb/source/ucp/webdav/DAVRequestEnvironment.hxx    |    8 +-
 ucb/source/ucp/webdav/DAVResourceAccess.cxx        |  115 +++++-
 ucb/source/ucp/webdav/DAVResourceAccess.hxx        |   16 +-
 ucb/source/ucp/webdav/DAVSession.hxx               |   24 +-
 ucb/source/ucp/webdav/NeonInputStream.cxx          |  195 +++++++++--
 ucb/source/ucp/webdav/NeonInputStream.hxx          |   70 +++-
 ucb/source/ucp/webdav/NeonSession.cxx              |  291 ++++++++++-----
 ucb/source/ucp/webdav/NeonSession.hxx              |   34 +-
 ucb/source/ucp/webdav/NeonTypes.hxx                |    4 +
 ucb/source/ucp/webdav/webdavcontent.cxx            |  394 +++++++++++++++++++-
 ucb/source/ucp/webdav/webdavcontent.hxx            |   17 +
 ucb/source/ucp/webdav/webdavcontentcaps.cxx        |   18 +
 ucb/source/ucp/webdav/webdavprovider.cxx           |   61 ++--
 ucb/source/ucp/webdav/webdavprovider.hxx           |    9 +-
 unotools/source/ucbhelper/ucblockbytes.cxx         |   12 +-
 23 files changed, 1173 insertions(+), 254 deletions(-)

diff --git a/officecfg/registry/data/org/openoffice/ucb/Configuration.xcu b/officecfg/registry/data/org/openoffice/ucb/Configuration.xcu
index df824b5..6adb964 100644
--- a/officecfg/registry/data/org/openoffice/ucb/Configuration.xcu
+++ b/officecfg/registry/data/org/openoffice/ucb/Configuration.xcu
@@ -175,6 +175,28 @@
                 <value/>
               </prop>
             </node>
+            <node oor:name="Provider14" oor:op="replace">
+              <prop oor:name="ServiceName">
+                <value>com.sun.star.ucb.WebDAVContentProvider</value>
+              </prop>
+              <prop oor:name="URLTemplate">
+                <value>webdav</value>
+              </prop>
+              <prop oor:name="Arguments">
+                <value/>
+              </prop>
+            </node>
+            <node oor:name="Provider15" oor:op="replace">
+              <prop oor:name="ServiceName">
+                <value>com.sun.star.ucb.WebDAVContentProvider</value>
+              </prop>
+              <prop oor:name="URLTemplate">
+                <value>webdavs</value>
+              </prop>
+              <prop oor:name="Arguments">
+                <value/>
+              </prop>
+            </node>
             <!-- We want the Provider to be the final fallback provider -->
             <node oor:name="Provider999" oor:op="replace" install:module="gio">
               <prop oor:name="ServiceName">
diff --git a/sc/source/ui/docshell/docsh.cxx b/sc/source/ui/docshell/docsh.cxx
index dd7027d..03cb7b9 100644
--- a/sc/source/ui/docshell/docsh.cxx
+++ b/sc/source/ui/docshell/docsh.cxx
@@ -872,7 +872,7 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
     //	Alle Filter brauchen die komplette Datei am Stueck (nicht asynchron),
     //	darum vorher per CreateFileStream dafuer sorgen, dass die komplette
     //	Datei uebertragen wird.
-    rMedium.GetPhysicalName();	//! CreateFileStream direkt rufen, wenn verfuegbar
+    rMedium.GetPhysicalName( sal_False );	//! CreateFileStream direkt rufen, wenn verfuegbar
 
     SFX_ITEMSET_ARG( rMedium.GetItemSet(), pUpdateDocItem, SfxUInt16Item, SID_UPDATEDOCMODE, sal_False);
     nCanUpdate = pUpdateDocItem ? pUpdateDocItem->GetValue() : com::sun::star::document::UpdateDocMode::NO_UPDATE;
diff --git a/sfx2/inc/sfx2/docfile.hxx b/sfx2/inc/sfx2/docfile.hxx
index 3b173a2..571ed6d 100644
--- a/sfx2/inc/sfx2/docfile.hxx
+++ b/sfx2/inc/sfx2/docfile.hxx
@@ -184,7 +184,7 @@ public:
     ::com::sun::star::util::DateTime GetInitFileDate( sal_Bool bIgnoreOldValue );
 
     ::com::sun::star::uno::Reference< ::com::sun::star::ucb::XContent > GetContent() const;
-    const String&       GetPhysicalName() const;
+    const String&       GetPhysicalName( sal_Bool bForceCreateTempIfRemote = sal_True ) const;
     void                SetTemporary( sal_Bool bTemp );
     sal_Bool            IsTemporary() const;
     sal_Bool            IsRemote();
@@ -254,6 +254,8 @@ public:
     void				SetCharset( ::rtl::OUString );
     ::rtl::OUString     GetBaseURL( bool bForSaving=false );
 
+    sal_Bool            SupportsActiveStreaming( const rtl::OUString &rName ) const;
+
 #if _SOLAR__PRIVATE
     SAL_DLLPRIVATE BOOL HasStorage_Impl() const;
 
diff --git a/sfx2/source/doc/docfile.cxx b/sfx2/source/doc/docfile.cxx
index eac8589..34a3401 100644
--- a/sfx2/source/doc/docfile.cxx
+++ b/sfx2/source/doc/docfile.cxx
@@ -583,7 +583,7 @@ void SfxMedium::CheckFileDate( const util::DateTime& aInitDate )
 //------------------------------------------------------------------
 sal_Bool SfxMedium::DocNeedsFileDateCheck()
 {
-    return ( !IsReadOnly() && ::utl::LocalFileHelper::IsLocalFile( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) );
+    return ( !IsReadOnly() && SupportsActiveStreaming( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) );
 }
 
 //------------------------------------------------------------------
@@ -808,10 +808,13 @@ sal_Bool SfxMedium::CloseOutStream_Impl()
 }
 
 //------------------------------------------------------------------
-const String& SfxMedium::GetPhysicalName() const
+const String& SfxMedium::GetPhysicalName( sal_Bool bForceCreateTempIfRemote ) const
 {
     if ( !aName.Len() && aLogicName.Len() )
-        (( SfxMedium*)this)->CreateFileStream();
+    {
+        if ( bForceCreateTempIfRemote || !SupportsActiveStreaming( aLogicName ) )
+            (( SfxMedium*)this)->CreateFileStream();
+    }
 
     // return the name then
     return aName;
@@ -921,6 +924,26 @@ sal_Bool SfxMedium::IsPreview_Impl()
 }
 
 //------------------------------------------------------------------
+sal_Bool SfxMedium::SupportsActiveStreaming( const rtl::OUString &rName ) const
+{
+    if ( ::utl::LocalFileHelper::IsLocalFile( rName ) )
+        return sal_True;
+
+    ::ucbhelper::Content aTmpContent;
+    Reference< ::com::sun::star::ucb::XCommandEnvironment > xDummyEnv;
+    if ( ::ucbhelper::Content::create( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ), xDummyEnv, aTmpContent ) )
+    {
+        Any aAny = aTmpContent.getPropertyValue(
+                ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "SupportsActiveStreaming" )) );
+
+        sal_Bool bSupportsStreaming = sal_False;
+        return ( ( aAny >>= bSupportsStreaming ) && bSupportsStreaming );
+    }
+
+    return sal_False;
+}
+
+//------------------------------------------------------------------
 void SfxMedium::StorageBackup_Impl()
 {
     ::ucbhelper::Content aOriginalContent;
@@ -928,7 +951,7 @@ void SfxMedium::StorageBackup_Impl()
 
     sal_Bool bBasedOnOriginalFile = ( !pImp->pTempFile && !( aLogicName.Len() && pImp->m_bSalvageMode )
         && GetURLObject().GetMainURL( INetURLObject::NO_DECODE ).getLength()
-        && ::utl::LocalFileHelper::IsLocalFile( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) )
+        && SupportsActiveStreaming( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) )
         && ::utl::UCBContentHelper::IsDocument( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) );
 
     if ( bBasedOnOriginalFile && !pImp->m_aBackupURL.getLength()
@@ -2012,7 +2035,7 @@ void SfxMedium::Transfer_Impl()
             xComEnv = new ::ucbhelper::CommandEnvironment( xInteractionHandler,
                                                       Reference< ::com::sun::star::ucb::XProgressHandler >() );
 
-        if ( ::utl::LocalFileHelper::IsLocalFile( aDest.GetMainURL( INetURLObject::NO_DECODE ) ) || !aDest.removeSegment() )
+        if ( SupportsActiveStreaming( aDest.GetMainURL( INetURLObject::NO_DECODE ) ) || !aDest.removeSegment() )
         {
             TransactedTransferForFS_Impl( aSource, aDest, xComEnv );
         }
@@ -2125,11 +2148,20 @@ void SfxMedium::DoInternalBackup_Impl( const ::ucbhelper::Content& aOriginalCont
     if ( pImp->m_aBackupURL.getLength() )
         return; // the backup was done already
 
-    ::utl::TempFile aTransactTemp( aPrefix, &aExtension, &aDestDir );
-    aTransactTemp.EnableKillingFile( sal_False );
+    ::rtl::OUString aBackupName;
+    ::rtl::OUString aBackupURL;
+    {
+        // a living aTransactTemp kills WebDAV with SAL_ENABLE_FILE_LOCKING=1,
+        // because then it attempts to have 2 file handles pointing to the same
+        // file name...
+        ::utl::TempFile aTransactTemp( aPrefix, &aExtension, &aDestDir );
+        aTransactTemp.EnableKillingFile( sal_True );
+
+        INetURLObject aBackObj( aTransactTemp.GetURL() );
 
-    INetURLObject aBackObj( aTransactTemp.GetURL() );
-    ::rtl::OUString aBackupName = aBackObj.getName( INetURLObject::LAST_SEGMENT, true, INetURLObject::DECODE_WITH_CHARSET );
+        aBackupName = aBackObj.getName( INetURLObject::LAST_SEGMENT, true, INetURLObject::DECODE_WITH_CHARSET );
+        aBackupURL = aBackObj.GetMainURL( INetURLObject::NO_DECODE );
+    }
 
     Reference < ::com::sun::star::ucb::XCommandEnvironment > xDummyEnv;
     ::ucbhelper::Content aBackupCont;
@@ -2142,16 +2174,13 @@ void SfxMedium::DoInternalBackup_Impl( const ::ucbhelper::Content& aOriginalCont
                                             aBackupName,
                                             NameClash::OVERWRITE ) )
             {
-                pImp->m_aBackupURL = aBackObj.GetMainURL( INetURLObject::NO_DECODE );
+                pImp->m_aBackupURL = aBackupURL;
                 pImp->m_bRemoveBackup = sal_True;
             }
         }
         catch( Exception& )
         {}
     }
-
-    if ( !pImp->m_aBackupURL.getLength() )
-        aTransactTemp.EnableKillingFile( sal_True );
 }
 
 //------------------------------------------------------------------
@@ -2390,7 +2419,7 @@ void SfxMedium::GetMedium_Impl()
                         aMedium.erase( comphelper::MediaDescriptor::PROP_READONLY() );
                         aMedium.addInputStream();
                     }
-                    else if ( ::utl::LocalFileHelper::IsLocalFile( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) )
+                else if ( SupportsActiveStreaming( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) )
                     {
                         // use the special locking approach only for file URLs
                         aMedium.addInputStreamOwnLock();
@@ -3516,7 +3545,7 @@ void SfxMedium::CreateTempFile( sal_Bool bReplace )
         sal_Bool bTransferSuccess = sal_False;
 
         if ( GetContent().is()
-          && ::utl::LocalFileHelper::IsLocalFile( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) )
+          && SupportsActiveStreaming( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) )
           && ::utl::UCBContentHelper::IsDocument( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) )
         {
             // if there is already such a document, we should copy it
diff --git a/sfx2/source/view/viewfrm.cxx b/sfx2/source/view/viewfrm.cxx
index 2dcd93c..4794f57 100644
--- a/sfx2/source/view/viewfrm.cxx
+++ b/sfx2/source/view/viewfrm.cxx
@@ -629,6 +629,11 @@ void SfxViewFrame::ExecReload_Impl( SfxRequest& rReq )
                 sal_Bool bHandsOff =
                     ( pMedium->GetURLObject().GetProtocol() == INET_PROT_FILE && !xOldObj->IsDocShared() );
 
+                // we must do the same for the contents that support active
+                // streaming
+                if ( !bHandsOff && pMedium && pMedium->SupportsActiveStreaming( aURL ) )
+                    bHandsOff = sal_True;
+
                 // bestehende SfxMDIFrames f"ur dieses Doc leeren
                 // eigenes Format oder R/O jetzt editierbar "offnen?
                 SfxViewNotificatedFrameList_Impl aFrames;
diff --git a/tools/inc/tools/urlobj.hxx b/tools/inc/tools/urlobj.hxx
index c24c68c..9e9707e 100644
--- a/tools/inc/tools/urlobj.hxx
+++ b/tools/inc/tools/urlobj.hxx
@@ -138,9 +138,14 @@ enum INetProtocol
     INET_PROT_TELNET = 28,
     INET_PROT_VND_SUN_STAR_EXPAND = 29,
     INET_PROT_VND_SUN_STAR_TDOC = 30,
-    INET_PROT_GENERIC = 31,
-    INET_PROT_SMB = 32,
-    INET_PROT_END = 33
+    INET_PROT_SMB = 31,
+    INET_PROT_DAV = 32,
+    INET_PROT_DAVS = 33,
+    INET_PROT_WEBDAV = 34,
+    INET_PROT_WEBDAVS = 35,
+    INET_PROT_GENERIC = 36,
+    INET_PROT_GENERIC_HIERARCHICAL = 37,
+    INET_PROT_END = 38
 };
 
 //============================================================================
diff --git a/tools/source/fsys/urlobj.cxx b/tools/source/fsys/urlobj.cxx
index 623eb1a..6ad6239 100644
--- a/tools/source/fsys/urlobj.cxx
+++ b/tools/source/fsys/urlobj.cxx
@@ -371,21 +371,21 @@ static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
           false },
         { "ftp", "ftp://", 21, true, true, false, true, true, true, true,
           false },
-        { "http", "http://", 80, true, false, false, false, true, true,
+        { "http", "http://", 80, true, true, false, true, true, true,
           true, true },
         { "file", "file://", 0, true, false, false, false, true, false,
           true, false },
         { "mailto", "mailto:", 0, false, false, false, false, false,
           false, false, true },
-        { "vnd.sun.star.webdav", "vnd.sun.star.webdav://", 80, true, false,
-          false, false, true, true, true, true },
+        { "vnd.sun.star.webdav", "vnd.sun.star.webdav://", 80, true, true,
+          false, true, true, true, true, true },
         { "news", "news:", 0, false, false, false, false, false, false, false,
           false },
         { "private", "private:", 0, false, false, false, false, false,
           false, false, true },
         { "vnd.sun.star.help", "vnd.sun.star.help://", 0, true, false, false,
           false, false, false, true, true },
-        { "https", "https://", 443, true, false, false, false, true, true,
+        { "https", "https://", 443, true, true, false, true, true, true,
           true, true },
         { "slot", "slot:", 0, false, false, false, false, false, false,
           false, true },
@@ -429,9 +429,19 @@ static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
           false, false, false, false, false },
         { "vnd.sun.star.tdoc", "vnd.sun.star.tdoc:", 0, false, false, false,
           false, false, false, true, false },
-        { "", "", 0, false, false, false, false, false, false, false, false },
         { "smb", "smb://", 139, true, true, false, true, true, true, true,
-          true } };
+          true },
+        { "dav", "dav://", 80, true, true, false, true, true, true, true,
+          true },
+        { "davs", "davs://", 443, true, true, false, true, true, true,
+          true, true },
+        { "webdav", "webdav://", 80, true, true, false, true, true, true, true,
+          true },
+        { "webdavs", "webdavs://", 443, true, true, false, true, true, true,
+          true, true },
+        { "", "", 0, false, false, false, false, false, false, false, false },
+        { "", "", 0, false, false, false, false, false, false, true, false }
+      };
 
 // static
 inline INetURLObject::SchemeInfo const &
@@ -846,7 +856,10 @@ bool INetURLObject::setAbsURIRef(rtl::OUString const & rTheAbsURIRef,
             aSynScheme = parseScheme(&p1, pEnd, nFragmentDelimiter);
             if (aSynScheme.getLength() > 0)
             {
-                m_eScheme = INET_PROT_GENERIC;
+                if (p1 != pEnd && *p1 == '/')
+                    m_eScheme = INET_PROT_GENERIC_HIERARCHICAL;
+                else
+                    m_eScheme = INET_PROT_GENERIC;
                 pPos = p1;
             }
         }
@@ -863,8 +876,9 @@ bool INetURLObject::setAbsURIRef(rtl::OUString const & rTheAbsURIRef,
             return false;
         }
 
-        if (m_eScheme != INET_PROT_GENERIC) {
-            aSynScheme = rtl::OUString::createFromAscii(getSchemeInfo().m_pScheme);
+        const char *pSchemeName = getSchemeInfo().m_pScheme;
+        if (pSchemeName[0] != '\0') {
+            aSynScheme = rtl::OUString::createFromAscii(pSchemeName);
         }
         m_aScheme.set(aSynAbsURIRef, aSynScheme, aSynAbsURIRef.getLength());
         aSynAbsURIRef.append(sal_Unicode(':'));
@@ -2122,6 +2136,8 @@ INetURLObject::getPrefix(sal_Unicode const *& rBegin,
               PrefixInfo::INTERNAL },
             { "cid:", 0, INET_PROT_CID, PrefixInfo::OFFICIAL },
             { "data:", 0, INET_PROT_DATA, PrefixInfo::OFFICIAL },
+            { "dav:", 0, INET_PROT_DAV, PrefixInfo::OFFICIAL },
+            { "davs:", 0, INET_PROT_DAVS, PrefixInfo::OFFICIAL },
             { "db:", "staroffice.db:", INET_PROT_DB, PrefixInfo::INTERNAL },
             { "file:", 0, INET_PROT_FILE, PrefixInfo::OFFICIAL },
             { "ftp:", 0, INET_PROT_FTP, PrefixInfo::OFFICIAL },
@@ -2203,6 +2219,8 @@ INetURLObject::getPrefix(sal_Unicode const *& rBegin,
               PrefixInfo::OFFICIAL },
             { "vnd.sun.star.wfs:", 0, INET_PROT_VND_SUN_STAR_WFS,
               PrefixInfo::OFFICIAL },
+            { "webdav:", 0, INET_PROT_WEBDAV, PrefixInfo::OFFICIAL },
+            { "webdavs:", 0, INET_PROT_WEBDAVS, PrefixInfo::OFFICIAL },
             { "wfs:", "vnd.sun.star.wfs:", INET_PROT_VND_SUN_STAR_WFS,
               PrefixInfo::ALIAS } };
     PrefixInfo const * pFirst = aMap + 1;
@@ -3006,6 +3024,10 @@ bool INetURLObject::parsePath(INetProtocol eScheme,
         case INET_PROT_VND_SUN_STAR_WEBDAV:
         case INET_PROT_HTTPS:
         case INET_PROT_SMB:
+        case INET_PROT_DAV:
+        case INET_PROT_DAVS:
+        case INET_PROT_WEBDAV:
+        case INET_PROT_WEBDAVS:
             if (pPos < pEnd && *pPos != '/')
                 return false;
             while (pPos < pEnd && *pPos != nQueryDelimiter
@@ -3424,6 +3446,7 @@ bool INetURLObject::parsePath(INetProtocol eScheme,
             break;
 
         case INET_PROT_GENERIC:
+        case INET_PROT_GENERIC_HIERARCHICAL:
             while (pPos < pEnd && *pPos != nFragmentDelimiter)
             {
                 EscapeType eEscapeType;
@@ -4135,10 +4158,13 @@ bool INetURLObject::ConcatData(INetProtocol eTheScheme,
 {
     setInvalid();
     m_eScheme = eTheScheme;
-    if (HasError() || m_eScheme == INET_PROT_GENERIC)
+    const char *pSchemeName = getSchemeInfo().m_pScheme;
+
+    if (HasError() || pSchemeName[0] == '\0')
         return false;
+
     m_aAbsURIRef.setLength(0);
-    m_aAbsURIRef.appendAscii(getSchemeInfo().m_pScheme);
+    m_aAbsURIRef.appendAscii(pSchemeName);
     m_aAbsURIRef.append(sal_Unicode(':'));
     if (getSchemeInfo().m_bAuthority)
     {
diff --git a/tools/workben/urltest.cxx b/tools/workben/urltest.cxx
index 709bcb8..92e0440 100644
--- a/tools/workben/urltest.cxx
+++ b/tools/workben/urltest.cxx
@@ -1492,7 +1492,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("A-b.3:/%2f?x#y"));
         urlobj = INetURLObject(url);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("a-b.3:/%2F?x#y")),
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
@@ -1520,7 +1520,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("foo:/"));
         urlobj = INetURLObject(url);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, url,
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
@@ -1558,7 +1558,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("A-b.3:/%2f?x#y"));
         urlobj = INetURLObject(url, INET_PROT_CID);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("a-b.3:/%2F?x#y")),
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
@@ -1579,7 +1579,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("foo:/"));
         urlobj = INetURLObject(url, INET_PROT_CID);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, url,
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
diff --git a/ucb/source/ucp/webdav/DAVRequestEnvironment.hxx b/ucb/source/ucp/webdav/DAVRequestEnvironment.hxx
index c4a5ae7..d0b46d3 100644
--- a/ucb/source/ucp/webdav/DAVRequestEnvironment.hxx
+++ b/ucb/source/ucp/webdav/DAVRequestEnvironment.hxx
@@ -31,6 +31,8 @@
 #include <rtl/ref.hxx>
 #include "DAVAuthListener.hxx"
 
+#include <com/sun/star/ucb/XCommandEnvironment.hpp>
+
 namespace webdav_ucp
 {
     typedef std::pair< rtl::OUString, rtl::OUString > DAVRequestHeader;
@@ -43,12 +45,12 @@ struct DAVRequestEnvironment
 //    rtl::Reference< DAVStatusListener >   m_xStatusListener;
 //    rtl::Reference< DAVProgressListener > m_xStatusListener;
     DAVRequestHeaders                     m_aRequestHeaders;
-    uno::Reference< ucb::XCommandEnvironment > m_xEnv;
+    com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > m_xEnv;
 
-DAVRequestEnvironment( const rtl::OUString & rRequestURI,
+    DAVRequestEnvironment( const rtl::OUString & rRequestURI,
                            const rtl::Reference< DAVAuthListener > & xListener,
                            const DAVRequestHeaders & rRequestHeaders,
-                           const uno::Reference< ucb::XCommandEnvironment > & xEnv)
+                           const com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > & xEnv)
     : m_aRequestURI( rRequestURI ), 
       m_xAuthListener( xListener ),
       m_aRequestHeaders( rRequestHeaders ),
diff --git a/ucb/source/ucp/webdav/DAVResourceAccess.cxx b/ucb/source/ucp/webdav/DAVResourceAccess.cxx
index 62e68fb..2a8a3e1 100644
--- a/ucb/source/ucp/webdav/DAVResourceAccess.cxx
+++ b/ucb/source/ucp/webdav/DAVResourceAccess.cxx
@@ -39,6 +39,9 @@
 #include "DAVAuthListenerImpl.hxx"
 #include "DAVResourceAccess.hxx"
 
+#include <comphelper/processfactory.hxx>
+#include <ucbhelper/commandenvironment.hxx>
+
 using namespace webdav_ucp;
 using namespace com::sun::star;
 
@@ -60,11 +63,18 @@ int DAVAuthListener_Impl::authenticate(
     sal_Bool bAllowPersistentStoring,
     sal_Bool bCanUseSystemCredentials )
 {
+    uno::Reference< task::XInteractionHandler > xIH;
+
     if ( m_xEnv.is() )
     {
-        uno::Reference< task::XInteractionHandler > xIH
-            = m_xEnv->getInteractionHandler();
-        if ( xIH.is() )
+        xIH = m_xEnv->getInteractionHandler();
+    }
+    else
+    {
+        xIH = DAVResourceAccess::createCommandEnvironment()->getInteractionHandler();
+    }
+
+    {
         {
             // #102871# - Supply username and password from previous try.
             // Password container service depends on this!
@@ -462,15 +472,16 @@ void DAVResourceAccess::GET(
 }
 
 //=========================================================================
-uno::Reference< io::XInputStream > DAVResourceAccess::GET(
+uno::Reference< io::XStream > DAVResourceAccess::GET(
     const std::vector< rtl::OUString > & rHeaderNames,
     DAVResource & rResource,
-    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv,
+    sal_Bool bAllowEmpty )
   throw( DAVException )
 {
     initialize();
 
-    uno::Reference< io::XInputStream > xStream;
+    uno::Reference< io::XStream > xStream;
     int errorCount = 0;
     bool bRetry;
     do
@@ -490,7 +501,8 @@ uno::Reference< io::XInputStream > DAVResourceAccess::GET(
                                        DAVRequestEnvironment(
                                            getRequestURI(),
                                            new DAVAuthListener_Impl( xEnv, m_aURL ),
-                                           aHeaders, xEnv ) );
+                                           aHeaders, xEnv ),
+                                       bAllowEmpty );
         }
         catch ( DAVException & e )
         {
@@ -632,6 +644,45 @@ void DAVResourceAccess::PUT(
 }
 
 //=========================================================================
+void DAVResourceAccess::PUT(
+        const char * buffer, size_t size,
+        const uno::Reference< ucb::XCommandEnvironment > & xEnv )
+throw( DAVException )
+{
+    initialize();
+
+    bool bRetry = false;
+    int errorCount = 0;
+    do
+    {
+        bRetry = false;
+        try
+        {
+            DAVRequestHeaders aHeaders;
+            getUserRequestHeaders( xEnv,
+                                   getRequestURI(),
+                                   rtl::OUString::createFromAscii( "PUT" ),
+                                   aHeaders );
+
+            m_xSession->PUT( getRequestURI(),
+                             buffer, size,
+                             DAVRequestEnvironment(
+                                 getRequestURI(),
+                                 new DAVAuthListener_Impl( xEnv, m_aURL ),
+                                 aHeaders, xEnv ) );
+        }
+        catch ( DAVException & e )
+        {
+            errorCount++;
+            bRetry = handleException( e, errorCount );
+            if ( !bRetry )
+                throw;
+        }
+    }
+    while ( bRetry );
+}
+
+//=========================================================================
 uno::Reference< io::XInputStream > DAVResourceAccess::POST(
     const rtl::OUString & rContentType,
     const rtl::OUString & rReferer,
@@ -914,22 +965,44 @@ void DAVResourceAccess::DESTROY(
 
 //=========================================================================
 void DAVResourceAccess::LOCK ( 
-    const ucb::Lock & /*rLock*/,
-    const uno::Reference< ucb::XCommandEnvironment > & /*xEnv*/ )
+    ucb::Lock & rLock,
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
   throw( DAVException )
 {
-//    initialize();
-    OSL_ENSURE( sal_False, "DAVResourceAccess::LOCK - NYI" );
+    initialize();
+
+    DAVRequestHeaders aHeaders;
+    getUserRequestHeaders( xEnv,
+            getRequestURI(),
+            rtl::OUString::createFromAscii( "LOCK" ),
+            aHeaders );
+
+    m_xSession->LOCK( rLock,
+            DAVRequestEnvironment(
+                getRequestURI(),
+                new DAVAuthListener_Impl( xEnv, m_aURL ),
+                aHeaders, xEnv ) );
 }
 
 //=========================================================================
 void DAVResourceAccess::UNLOCK ( 
-    const ucb::Lock & /*rLock*/,
-    const uno::Reference< ucb::XCommandEnvironment > & /*xEnv*/ )
+    ucb::Lock & rLock,
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
   throw( DAVException )
 {
-//    initialize();
-    OSL_ENSURE( sal_False, "DAVResourceAccess::UNLOCK - NYI" );
+    initialize();
+
+    DAVRequestHeaders aHeaders;
+    getUserRequestHeaders( xEnv,
+            getRequestURI(),
+            rtl::OUString::createFromAscii( "UNLOCK" ),
+            aHeaders );
+
+    m_xSession->UNLOCK( rLock,
+            DAVRequestEnvironment(
+                getRequestURI(),
+                new DAVAuthListener_Impl( xEnv, m_aURL ),
+                aHeaders, xEnv ) );
 }
 
 //=========================================================================
@@ -1034,6 +1107,18 @@ void DAVResourceAccess::getUserRequestHeaders(
     }
 }
 
+// static
+com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > DAVResourceAccess::createCommandEnvironment( void )
+{
+    uno::Reference< lang::XMultiServiceFactory > xFactory( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+    uno::Reference< task::XInteractionHandler > xInteractionHandler = uno::Reference< task::XInteractionHandler > (
+            xFactory->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uui.InteractionHandler") ) ), uno::UNO_QUERY );
+    ucbhelper::CommandEnvironment* pCommandEnv = new ::ucbhelper::CommandEnvironment( xInteractionHandler, uno::Reference< ucb::XProgressHandler >() );
+
+    return uno::Reference< ucb::XCommandEnvironment >( static_cast< ucb::XCommandEnvironment* >( pCommandEnv ), uno::UNO_QUERY );
+}
+
+
 //=========================================================================
 sal_Bool DAVResourceAccess::detectRedirectCycle(
                                 const rtl::OUString& rRedirectURL )
diff --git a/ucb/source/ucp/webdav/DAVResourceAccess.hxx b/ucb/source/ucp/webdav/DAVResourceAccess.hxx
index 013cb2a..134ed5b 100644
--- a/ucb/source/ucp/webdav/DAVResourceAccess.hxx
+++ b/ucb/source/ucp/webdav/DAVResourceAccess.hxx
@@ -131,11 +131,12 @@ public:
          com::sun::star::ucb::XCommandEnvironment > & xEnv )
         throw( DAVException );
 
-    com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
+    com::sun::star::uno::Reference< com::sun::star::io::XStream >
     GET( const std::vector< rtl::OUString > & rHeaderNames, // empty == 'all'
          DAVResource & rResource,
          const com::sun::star::uno::Reference<
-         com::sun::star::ucb::XCommandEnvironment > & xEnv )
+         com::sun::star::ucb::XCommandEnvironment > & xEnv,
+         sal_Bool bAllowEmpty = sal_False )
         throw( DAVException );
 
     void
@@ -154,6 +155,11 @@ public:
          com::sun::star::ucb::XCommandEnvironment > & xEnv )
     throw( DAVException );
 
+    void
+    PUT( const char * buffer, size_t size,
+         const com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > & xEnv )
+        throw( DAVException );
+
     com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
     POST( const rtl::OUString & rContentType,
       const rtl::OUString & rReferer,
@@ -201,13 +207,13 @@ public:
     throw( DAVException );
 
     void
-    LOCK( const com::sun::star::ucb::Lock & rLock,
+    LOCK( com::sun::star::ucb::Lock & rLock,
       const com::sun::star::uno::Reference<
           com::sun::star::ucb::XCommandEnvironment > & xEnv )
     throw( DAVException );
 
     void
-    UNLOCK( const com::sun::star::ucb::Lock & rLock,
+    UNLOCK( com::sun::star::ucb::Lock & rLock,
         const com::sun::star::uno::Reference<
             com::sun::star::ucb::XCommandEnvironment > & xEnv )
     throw( DAVException );
@@ -224,6 +230,8 @@ public:
     const rtl::OUString & rMethod,
     DAVRequestHeaders & rRequestHeaders );
 
+    static com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > createCommandEnvironment( void );
+
 private:
     const rtl::OUString & getRequestURI() const;
     sal_Bool detectRedirectCycle( const rtl::OUString& rRedirectURL )
diff --git a/ucb/source/ucp/webdav/DAVSession.hxx b/ucb/source/ucp/webdav/DAVSession.hxx
index 65f8b98..8f7992c 100644
--- a/ucb/source/ucp/webdav/DAVSession.hxx
+++ b/ucb/source/ucp/webdav/DAVSession.hxx
@@ -30,8 +30,11 @@
 
 #include <memory>
 #include <rtl/ustring.hxx>
+#include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XInputStream.hpp>
 #include <com/sun/star/io/XOutputStream.hpp>
+#include <com/sun/star/ucb/Lock.hpp>
+
 #include "DAVException.hxx"
 #include "DAVProperties.hxx"
 #include "DAVResource.hxx"
@@ -39,8 +42,6 @@
 #include "DAVTypes.hxx"
 #include "DAVRequestEnvironment.hxx"
 
-
-
 namespace webdav_ucp
 {
 
@@ -111,11 +112,12 @@ public:
         const DAVRequestEnvironment & rEnv )
         throw( DAVException ) = 0;
 
-    virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
+    virtual com::sun::star::uno::Reference< com::sun::star::io::XStream >
                     GET( const ::rtl::OUString & inPath,
                          const std::vector< ::rtl::OUString > & inHeaderNames,
                          DAVResource & ioResource,
-                         const DAVRequestEnvironment & rEnv )
+                         const DAVRequestEnvironment & rEnv,
+                         sal_Bool bAllowEmpty )
         throw( DAVException ) = 0;
 
     virtual void    GET( const ::rtl::OUString & inPath,
@@ -134,6 +136,12 @@ public:
     virtual void	ABORT()
         throw( DAVException ) = 0;
 
+    virtual void PUT( const ::rtl::OUString & inPath,
+             const char * buffer,
+             size_t size,
+             const DAVRequestEnvironment & rEnv )
+        throw ( DAVException ) = 0;
+
     virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
                     POST( const rtl::OUString & inPath,
                           const rtl::OUString & rContentType,
@@ -173,16 +181,14 @@ public:
                              const DAVRequestEnvironment & rEnv )
         throw( DAVException ) = 0;
 
-    // Note: Uncomment the following if locking support is required
-    /*
-    virtual void LOCK ( const Lock & inLock,
+    virtual void LOCK ( com::sun::star::ucb::Lock & rLock,
                         const DAVRequestEnvironment & rEnv )
         throw( DAVException ) = 0;
 
-    virtual void UNLOCK ( const Lock & inLock,
+    virtual void UNLOCK ( com::sun::star::ucb::Lock & rLock,
                           const DAVRequestEnvironment & rEnv )
         throw( DAVException ) = 0;
-    */
+
 protected:
     rtl::Reference< DAVSessionFactory > m_xFactory;
 
diff --git a/ucb/source/ucp/webdav/NeonInputStream.cxx b/ucb/source/ucp/webdav/NeonInputStream.cxx
index 2e142af..e9fa799 100644
--- a/ucb/source/ucp/webdav/NeonInputStream.cxx
+++ b/ucb/source/ucp/webdav/NeonInputStream.cxx
@@ -28,21 +28,28 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_ucb.hxx"
 #include "NeonInputStream.hxx"
+#include "DAVResourceAccess.hxx"
+
 #include <rtl/memory.h>
+#include <com/sun/star/ucb/CommandFailedException.hpp>
+
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+#include <cstdio>
 
 using namespace cppu;
-using namespace rtl;
 using namespace com::sun::star::io;
-using namespace com::sun::star::uno;
+using namespace com::sun::star;
 using namespace webdav_ucp;
 
-
 // -------------------------------------------------------------------
 // Constructor
 // -------------------------------------------------------------------
-NeonInputStream::NeonInputStream( void )
-: mLen( 0 ),
-  mPos( 0 )
+NeonInputStream::NeonInputStream()
+: m_nLen( 0 ),
+  m_nPos( 0 ),
+  m_bDirty( sal_False )
 {
 }
 
@@ -59,24 +66,59 @@ NeonInputStream::~NeonInputStream( void )
 // -------------------------------------------------------------------
 void NeonInputStream::AddToStream( const char * inBuf, sal_Int32 inLen )
 {
-    mInputBuffer.realloc( sal::static_int_cast<sal_Int32>(mLen) + inLen );
-    rtl_copyMemory( mInputBuffer.getArray() + mLen, inBuf, inLen );
-    mLen += inLen;
+    OSL_ENSURE( !m_bDirty, "Cannot AddToStream() when it was already written to it." );
+
+    m_aInputBuffer.realloc( sal::static_int_cast<sal_Int32>(m_nLen) + inLen );
+    rtl_copyMemory( m_aInputBuffer.getArray() + m_nLen, inBuf, inLen );
+    m_nLen += inLen;
+}
+
+// -------------------------------------------------------------------
+// Associate a URL with this stream
+// -------------------------------------------------------------------
+void NeonInputStream::SetURL( const rtl::OUString &rURL )
+{
+    osl::MutexGuard aGuard( m_aLock );
+
+    m_aURL = rURL;
 }
 
 // -------------------------------------------------------------------
 // queryInterface
 // -------------------------------------------------------------------
-Any NeonInputStream::queryInterface( const Type &type )
-                        throw( RuntimeException )
+uno::Any NeonInputStream::queryInterface( const uno::Type &type )
+                        throw( uno::RuntimeException )
 {
-    Any aRet = ::cppu::queryInterface( type,
-                                       static_cast< XInputStream * >( this ),
-                                       static_cast< XSeekable * >( this ) );
+    uno::Any aRet = ::cppu::queryInterface( type,
+            static_cast< XStream * >( this ),
+            static_cast< XInputStream * >( this ),
+            static_cast< XOutputStream * >( this ),
+            static_cast< XSeekable * >( this ),
+            static_cast< XTruncate * >( this ) );
     return aRet.hasValue() ? aRet : OWeakObject::queryInterface( type );
 }
 
 // -------------------------------------------------------------------
+// getInputStream
+// -------------------------------------------------------------------
+com::sun::star::uno::Reference< com::sun::star::io::XInputStream > SAL_CALL
+NeonInputStream::getInputStream( void )
+    throw( com::sun::star::uno::RuntimeException )
+{
+    return uno::Reference< XInputStream >( this );
+}
+
+// -------------------------------------------------------------------
+// getOutputStream
+// -------------------------------------------------------------------
+com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > SAL_CALL
+NeonInputStream::getOutputStream( void )
+    throw( com::sun::star::uno::RuntimeException )
+{
+    return uno::Reference< XOutputStream >( this );
+}
+
+// -------------------------------------------------------------------
 // readBytes
 // "Reads" the specified number of bytes from the stream
 // -------------------------------------------------------------------
@@ -89,7 +131,7 @@ sal_Int32 SAL_CALL NeonInputStream::readBytes(
 {
     // Work out how much we're actually going to write
     sal_Int32 theBytes2Read = nBytesToRead;
-    sal_Int32 theBytesLeft  = sal::static_int_cast<sal_Int32>(mLen - mPos);
+    sal_Int32 theBytesLeft  = sal::static_int_cast<sal_Int32>(m_nLen - m_nPos);
     if ( theBytes2Read > theBytesLeft )
         theBytes2Read = theBytesLeft;
 
@@ -98,10 +140,10 @@ sal_Int32 SAL_CALL NeonInputStream::readBytes(
 
     // Write the data
     rtl_copyMemory(
-        aData.getArray(), mInputBuffer.getConstArray() + mPos, theBytes2Read );
+        aData.getArray(), m_aInputBuffer.getConstArray() + m_nPos, theBytes2Read );
 
     // Update our stream position for next time
-    mPos += theBytes2Read;
+    m_nPos += theBytes2Read;
 
     return theBytes2Read;
 }
@@ -130,9 +172,9 @@ void SAL_CALL NeonInputStream::skipBytes( sal_Int32 nBytesToSkip )
                ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException )
 {
-    mPos += nBytesToSkip;
-    if ( mPos >= mLen )
-        mPos = mLen;
+    m_nPos += nBytesToSkip;
+    if ( m_nPos >= m_nLen )
+        m_nPos = m_nLen;
 }
 
 // -------------------------------------------------------------------
@@ -144,7 +186,7 @@ sal_Int32 SAL_CALL NeonInputStream::available(  )
                ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException )
 {
-    return sal::static_int_cast<sal_Int32>(mLen - mPos);
+    return sal::static_int_cast<sal_Int32>(m_nLen - m_nPos);
 }
 
 // -------------------------------------------------------------------
@@ -168,8 +210,8 @@ void SAL_CALL NeonInputStream::seek( sal_Int64 location )
     if ( location < 0 )
         throw ::com::sun::star::lang::IllegalArgumentException();
 
-    if ( location <= mLen )
-        mPos = location;
+    if ( location <= m_nLen )
+        m_nPos = location;
     else
         throw ::com::sun::star::lang::IllegalArgumentException();
 }
@@ -181,7 +223,7 @@ sal_Int64 SAL_CALL NeonInputStream::getPosition()
         throw( ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException )
 {
-    return mPos;
+    return m_nPos;
 }
 
 // -------------------------------------------------------------------
@@ -191,5 +233,108 @@ sal_Int64 SAL_CALL NeonInputStream::getLength()
         throw( ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException )
 {
-    return mLen;
+    return m_nLen;
+}
+
+// -------------------------------------------------------------------
+// writeBytes
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::writeBytes( const com::sun::star::uno::Sequence< sal_Int8 >& aData )
+    throw( com::sun::star::io::NotConnectedException,
+           com::sun::star::io::BufferSizeExceededException,
+           com::sun::star::io::IOException,
+           com::sun::star::uno::RuntimeException)
+{
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: writeBytes()\n" );
+#endif
+
+    sal_Int32 nDataLen = aData.getLength();
+    OSL_ASSERT( nDataLen >= 0 );
+
+    // Anything to do?
+    if ( nDataLen == 0 )
+        return;
+
+    // Update the length of the stream & size of the buffer
+    if ( m_nLen < m_nPos + nDataLen )
+    {
+        m_nLen = m_nPos + nDataLen;
+        if ( m_aInputBuffer.getLength() < m_nLen )
+            m_aInputBuffer.realloc( sal::static_int_cast<sal_Int32>( m_nLen ) );
+    }
+
+    rtl_copyMemory( m_aInputBuffer.getArray() + m_nPos, aData.getConstArray(), nDataLen );
+    m_nPos += nDataLen;
+
+    m_bDirty = sal_True;
+}
+
+// -------------------------------------------------------------------
+// flush
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::flush( void )
+    throw( NotConnectedException, BufferSizeExceededException,
+           IOException, uno::RuntimeException )
+{
+    if ( m_bDirty )
+    {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: flush(), saving the changed file.\n" );
+#endif
+        // FIXME It's really hacky to create the new session
+        // But so far it seems I have no other chance...
+        uno::Reference< lang::XMultiServiceFactory > xFactory( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        rtl::Reference< DAVSessionFactory > rDAVFactory( new DAVSessionFactory() );
+
+        DAVResourceAccess aResourceAccess( xFactory, rDAVFactory, m_aURL );
+
+        try {
+            aResourceAccess.PUT( reinterpret_cast<const char*>( m_aInputBuffer.getConstArray() ), m_nLen,
+                    DAVResourceAccess::createCommandEnvironment() );
+        }
+        catch ( DAVException & e )
+        {
+            throw ucb::CommandFailedException(
+                    e.getData(),
+                    uno::Reference< uno::XInterface >(),
+                    uno::makeAny( e.getData() ) );
+        }
+
+        m_bDirty = sal_False;
+    }
+}
+
+// -------------------------------------------------------------------
+// closeOutput
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::closeOutput( void )
+    throw( com::sun::star::io::NotConnectedException,
+           com::sun::star::io::IOException,
+           com::sun::star::uno::RuntimeException )
+{
+    if ( m_bDirty )
+    {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: TODO write on closeOutput(), the stream is dirty!\n" );
+#endif
+    }
+}
+
+// -------------------------------------------------------------------
+// truncate
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::truncate( void )
+    throw( com::sun::star::io::IOException,
+           com::sun::star::uno::RuntimeException )
+{
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: truncate()\n" );
+#endif
+
+    if ( m_nLen > 0 )
+    {
+        m_nLen = m_nPos = 0;
+        m_bDirty = sal_True;
+    }
 }
diff --git a/ucb/source/ucp/webdav/NeonInputStream.hxx b/ucb/source/ucp/webdav/NeonInputStream.hxx
index c7fee59..a3a1480 100644
--- a/ucb/source/ucp/webdav/NeonInputStream.hxx
+++ b/ucb/source/ucp/webdav/NeonInputStream.hxx
@@ -28,11 +28,19 @@
 #define _NEONINPUTSTREAM_HXX_
 
 #include <sal/types.h>
+#include <osl/mutex.hxx>
+#include <osl/signal.h>
 #include <rtl/ustring.hxx>
 #include <cppuhelper/weak.hxx>
+
+#include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/io/XSeekable.hpp>
+#include <com/sun/star/io/XTruncate.hpp>
+#include <com/sun/star/ucb/Lock.hpp>
 
+#include "DAVRequestEnvironment.hxx"
 
 namespace webdav_ucp
 {
@@ -42,21 +50,33 @@ namespace webdav_ucp
 // A simple XInputStream implementation provided specifically for use
 // by the DAVSession::GET method.
 // -------------------------------------------------------------------
-class NeonInputStream : public ::com::sun::star::io::XInputStream,
+class NeonInputStream : public ::com::sun::star::io::XStream,
+                        public ::com::sun::star::io::XInputStream,
+                        public ::com::sun::star::io::XOutputStream,
                         public ::com::sun::star::io::XSeekable,
+                        public ::com::sun::star::io::XTruncate,
                         public ::cppu::OWeakObject
 {
-    private:
-        com::sun::star::uno::Sequence< sal_Int8 > mInputBuffer;
-        sal_Int64 mLen;
-        sal_Int64 mPos;
+private:
+    com::sun::star::uno::Sequence< sal_Int8 > m_aInputBuffer;
+    sal_Int64                  m_nLen; // cannot be just m_aInputBuffer.getLength() - the buffer can be bigger
+    sal_Int64                  m_nPos;
+
+    sal_Bool                   m_bDirty;
+
+    rtl::OUString              m_aURL;
+
+    osl::Mutex                 m_aLock;
 
-    public:
-                 NeonInputStream( void );
-        virtual ~NeonInputStream();
+public:
+             NeonInputStream( void );
+    virtual ~NeonInputStream();
 
-        // Add some data to the end of the stream
-        void AddToStream( const char * inBuf, sal_Int32 inLen );
+    // Add some data to the end of the stream
+    void AddToStream( const char * inBuf, sal_Int32 inLen );
+
+    // Associate a URL with this stream
+    void SetURL( const rtl::OUString &rURL );
 
     // XInterface
     virtual com::sun::star::uno::Any SAL_CALL queryInterface(
@@ -71,6 +91,12 @@ class NeonInputStream : public ::com::sun::star::io::XInputStream,
                             throw()
                                 { OWeakObject::release(); }
 
+    // XStream
+    virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream > SAL_CALL getInputStream( void )
+        throw( com::sun::star::uno::RuntimeException );
+
+    virtual com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > SAL_CALL getOutputStream( void )
+        throw( com::sun::star::uno::RuntimeException );
 
     // XInputStream
     virtual sal_Int32 SAL_CALL readBytes(
@@ -118,6 +144,30 @@ class NeonInputStream : public ::com::sun::star::io::XInputStream,
     virtual sal_Int64 SAL_CALL getLength()
         throw( ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException );
+
+    // XOutputStream
+    virtual void SAL_CALL writeBytes( const com::sun::star::uno::Sequence< sal_Int8 >& aData )
+        throw( com::sun::star::io::NotConnectedException,
+                com::sun::star::io::BufferSizeExceededException,
+                com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL flush( void )
+        throw( com::sun::star::io::NotConnectedException,
+                com::sun::star::io::BufferSizeExceededException,
+                com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException);
+
+
+    virtual void SAL_CALL closeOutput( void )
+        throw( com::sun::star::io::NotConnectedException,
+                com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException );
+
+    // XTruncate
+    virtual void SAL_CALL truncate( void )
+        throw( com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException );
 };
 
 } // namespace webdav_ucp
diff --git a/ucb/source/ucp/webdav/NeonSession.cxx b/ucb/source/ucp/webdav/NeonSession.cxx
index 170e601..aad391d 100644
--- a/ucb/source/ucp/webdav/NeonSession.cxx
+++ b/ucb/source/ucp/webdav/NeonSession.cxx
@@ -41,6 +41,7 @@
 #include "rtl/ustrbuf.hxx"
 #include "comphelper/sequence.hxx"
 #include "ucbhelper/simplecertificatevalidationrequest.hxx"
+#include "ucbhelper/cancelcommandexecution.hxx"
 
 #include "DAVAuthListener.hxx"
 #include "NeonTypes.hxx"
@@ -144,6 +145,12 @@ static sal_uInt16 makeStatusCode( const rtl::OUString & rStatusText )
     return sal_uInt16( rStatusText.copy( 0, nPos ).toInt32() );
 }
 
+static sal_uInt16 getStatusCode( HttpSession *pSession )
+{
+    rtl::OUString aText = rtl::OUString::createFromAscii( ne_get_error( pSession ) );
+    return makeStatusCode( aText );
+}
+
 // -------------------------------------------------------------------
 struct NeonRequestContext
 {
@@ -187,12 +194,13 @@ struct NeonRequestContext
 // -------------------------------------------------------------------
 
 #if NEON_VERSION >= 0x0250
-extern "C" int NeonSession_ResponseBlockReader(void * inUserData, 
+extern "C" int
 #else
-extern "C" void NeonSession_ResponseBlockReader(void * inUserData, 
+extern "C" void
 #endif
-                                               const char * inBuf, 
-                                               size_t inLen )
+NeonSession_ResponseBlockReader( void * inUserData,
+                                 const char * inBuf,
+                                 size_t inLen )
 {
     // neon calls this function with (inLen == 0)...
     if ( inLen > 0 )
@@ -217,12 +225,13 @@ extern "C" void NeonSession_ResponseBlockReader(void * inUserData,
 // -------------------------------------------------------------------
 
 #if NEON_VERSION >= 0x0250
-extern "C" int NeonSession_ResponseBlockWriter( void * inUserData, 
+extern "C" int
 #else
-extern "C" void NeonSession_ResponseBlockWriter( void * inUserData, 
+extern "C" void
 #endif
-                                                const char * inBuf, 
-                                                size_t inLen )
+NeonSession_ResponseBlockWriter( void * inUserData,
+                                 const char * inBuf,
+                                 size_t inLen )
 {
     // neon calls this function with (inLen == 0)...
     if ( inLen > 0 )
@@ -291,11 +300,10 @@ extern "C" int NeonSession_NeonAuth( void *       inUserData,
 
         try
         {
-            NeonUri uri( theSession->getRequestEnvironment().m_aRequestURI );
-            rtl::OUString aUserInfo( uri.GetUserInfo() );
+            rtl::OUString aUserInfo( theSession->getUserInfo() );
             if ( aUserInfo.getLength() )
             {
-                sal_Int32 nPos = aUserInfo.indexOf( '@' );
+                sal_Int32 nPos = aUserInfo.indexOf( ':' );
                 if ( nPos == -1 )
                 {
                     theUserName = aUserInfo;
@@ -637,6 +645,8 @@ extern "C" void NeonSession_PreSendRequest( ne_request * req,
 
 } // namespace
 
+NeonLockStore * NeonSession::s_aNeonLockStore = NULL;
+
 // -------------------------------------------------------------------
 // Constructor
 // -------------------------------------------------------------------
@@ -654,6 +664,7 @@ NeonSession::NeonSession(
     m_aScheme    = theUri.GetScheme();
     m_aHostName  = theUri.GetHost();
     m_nPort      = theUri.GetPort();
+    m_aUserInfo  = theUri.GetUserInfo();
 
 //   Init();
 }
@@ -667,14 +678,6 @@ NeonSession::~NeonSession( )
     {
         ne_session_destroy( m_pHttpSession );
         m_pHttpSession = 0;
-    // Note: Uncomment the following if locking support is required
-    /*
-      if ( mNeonLockSession != NULL )
-      {
-      ne_lock_unregister( mNeonLockSession );
-      mNeonLockSession = NULL;
-      }
-    */
     }
 
     delete static_cast<RequestDataMap*>(m_pRequestData);
@@ -702,6 +705,9 @@ void NeonSession::Init()
                 throw DAVException( DAVException::DAV_SESSION_CREATE,
                                     NeonUri::makeConnectionEndPointString(
                                                     m_aHostName, m_nPort ) );
+#if OSL_DEBUG_LEVEL > 0
+            ne_debug_init( stderr, NE_DBG_LOCKS );
+#endif
             // #122205# - libxml2 needs to be initialized once if used by 
             // multithreaded programs like OOo.
             xmlInitParser();
@@ -818,14 +824,15 @@ void NeonSession::Init()
                               m_nProxyPort );
         }
 
-        // Note: Uncomment the following if locking support is required
-        /*
-        mNeonLockSession = ne_lock_register( m_pHttpSession );
+        if ( !s_aNeonLockStore )
+            s_aNeonLockStore = ne_lockstore_create();
 
-        if ( mNeonLockSession == NULL )
+        if ( s_aNeonLockStore == NULL )
             throw DAVException( DAVException::DAV_SESSION_CREATE,
-                                theUri::makeConnectionEndPointString() );
-        */
+                                NeonUri::makeConnectionEndPointString( m_aHostName, m_nPort ) );
+
+        // Register the lock store
+        ne_lockstore_register( s_aNeonLockStore, m_pHttpSession );
 
         // Register for redirects.
         ne_redirect_register( m_pHttpSession );
@@ -1153,11 +1160,12 @@ void NeonSession::GET( const rtl::OUString &                 inPath,
 // -------------------------------------------------------------------
 // GET
 // -------------------------------------------------------------------
-uno::Reference< io::XInputStream > 
+uno::Reference< io::XStream >
 NeonSession::GET( const rtl::OUString & inPath,
           const std::vector< ::rtl::OUString > & inHeaderNames,
           DAVResource & ioResource,
-          const DAVRequestEnvironment & rEnv )
+          const DAVRequestEnvironment & rEnv,
+          sal_Bool bAllowEmpty )
     throw ( DAVException )
 {
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
@@ -1169,16 +1177,23 @@ NeonSession::GET( const rtl::OUString & inPath,
     ioResource.uri = inPath;
     ioResource.properties.clear();
 
-    rtl::Reference< NeonInputStream > xInputStream( new NeonInputStream );
-    NeonRequestContext aCtx( xInputStream, inHeaderNames, ioResource );
+    rtl::Reference< NeonInputStream > xStream( new NeonInputStream );
+    NeonRequestContext aCtx( xStream, inHeaderNames, ioResource );
     int theRetVal = GET( m_pHttpSession,
                          rtl::OUStringToOString(
                              inPath, RTL_TEXTENCODING_UTF8 ),
                          NeonSession_ResponseBlockReader,
                          true,
                          &aCtx );
-    HandleError( theRetVal );
-    return uno::Reference< io::XInputStream >( xInputStream.get() );
+    try {
+        HandleError( theRetVal );
+    }
+    catch ( DAVException const & e )
+    {
+        if ( !bAllowEmpty || ( e.getStatus() != SC_NOT_FOUND ) )
+            throw;
+    }
+    return uno::Reference< io::XStream >( xStream.get() );
 }
 
 // -------------------------------------------------------------------
@@ -1218,22 +1233,38 @@ void NeonSession::PUT( const rtl::OUString &                      inPath,
                        const DAVRequestEnvironment & rEnv )
     throw ( DAVException )
 {
+    // initialization etc. is performed in the other PUT
+
+    uno::Sequence< sal_Int8 > aDataToSend;
+    if ( !getDataFromInputStream( inInputStream, aDataToSend, false ) )
+        throw DAVException( DAVException::DAV_INVALID_ARG );
+
+    PUT( inPath,
+            reinterpret_cast< const char * >( aDataToSend.getConstArray() ),
+            aDataToSend.getLength(),
+            rEnv );
+}
+
+// -------------------------------------------------------------------
+// PUT
+// -------------------------------------------------------------------
+void NeonSession::PUT( const rtl::OUString &inPath,
+                       const char * buffer,
+                       size_t size,
+                       const DAVRequestEnvironment & rEnv )
+    throw ( DAVException )
+{
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
 
     Init();
 
     m_aEnv = rEnv;
 
-    uno::Sequence< sal_Int8 > aDataToSend;
-    if ( !getDataFromInputStream( inInputStream, aDataToSend, false ) )
-        throw DAVException( DAVException::DAV_INVALID_ARG );
-
     int theRetVal = PUT( m_pHttpSession,
                          rtl::OUStringToOString(
                             inPath, RTL_TEXTENCODING_UTF8 ),
-                         reinterpret_cast< const char * >(
-                            aDataToSend.getConstArray() ),
-                         aDataToSend.getLength() );
+                         buffer,
+                         size );
 
     HandleError( theRetVal );
 }
@@ -1422,9 +1453,7 @@ void NeonSession::DESTROY( const rtl::OUString & inPath,
 // -------------------------------------------------------------------
 // LOCK
 // -------------------------------------------------------------------
-// Note: Uncomment the following if locking support is required
-/*
-void NeonSession::LOCK( const Lock & inLock,
+void NeonSession::LOCK( ucb::Lock & rLock,
                         const DAVRequestEnvironment & rEnv )
     throw ( DAVException )
 {
@@ -1434,16 +1463,13 @@ void NeonSession::LOCK( const Lock & inLock,
 
     m_aEnv = rEnv;
 
-    Lockit( inLock, true );
+    Lockit( rLock, true );
 }
-*/
 
 // -------------------------------------------------------------------
 // UNLOCK
 // -------------------------------------------------------------------
-// Note: Uncomment the following if locking support is required
-/*
-void NeonSession::UNLOCK( const Lock & inLock,
+void NeonSession::UNLOCK( ucb::Lock & rLock,
                           const DAVRequestEnvironment & rEnv )
     throw ( DAVException )
 {
@@ -1453,9 +1479,8 @@ void NeonSession::UNLOCK( const Lock & inLock,
 
     m_aEnv = rEnv;
 
-    Lockit( inLock, false );
+    Lockit( rLock, false );
 }
-*/
 
 // -------------------------------------------------------------------
 const ucbhelper::InternetProxyServer & NeonSession::getProxySettings() const
@@ -1494,7 +1519,10 @@ void NeonSession::HandleError( int nError )
         case NE_ERROR:        // Generic error
         {
             rtl::OUString aText = rtl::OUString::createFromAscii(
-        ne_get_error( m_pHttpSession ) );
+                    ne_get_error( m_pHttpSession ) );
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: got error '%s'\n", rtl::OUStringToOString( aText, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
             throw DAVException( DAVException::DAV_HTTP_ERROR,
                                 aText,
                                 makeStatusCode( aText ) );
@@ -1551,77 +1579,156 @@ void NeonSession::HandleError( int nError )
     }
 }
 
-// Note: Uncomment the following if locking support is required
-/*
-void NeonSession::Lockit( const Lock & inLock, bool inLockit )
+void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
     throw ( DAVException )
 {
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
 
-    // Create the neon lock
-    NeonLock * theLock = new NeonLock;
-    int theRetVal;
+    if ( !s_aNeonLockStore )
+        throw DAVException( DAVException::DAV_INVALID_ARG );
+
+    ne_uri aUri;
+    ne_uri_parse( rtl::OUStringToOString( m_aEnv.m_aRequestURI, RTL_TEXTENCODING_UTF8 ).getStr(),
+            &aUri );
 
-    // Set the lock uri
-    NeonUri theUri( inLock.uri );
-    theLock->uri = const_cast< char * >
-        ( rtl::OUStringToOString(
-                theUri.GetPath(), RTL_TEXTENCODING_UTF8 ).getStr() );
+#if NEON_VERSION < 0x0260
+#define FILLIN( field, val ) aUri.field = aUri.field? aUri.field: strdup( rtl::OUStringToOString( val, RTL_TEXTENCODING_UTF8 ).getStr() )
+    FILLIN( scheme, m_aScheme );
+    FILLIN( host, m_aHostName );
+    aUri.port = aUri.port? aUri.port: m_nPort;
+#undef FILLIN
+#endif
 
-    if ( inLockit )
+    // Create the neon lock
+    NeonLock * theLock = ne_lockstore_findbyuri( s_aNeonLockStore, &aUri );
+    bool bAlreadyExists = false;
+    if ( theLock )
+        bAlreadyExists = true;
+    else
     {
+        theLock = ne_lock_create();
+
+        // Set the lock uri
+        theLock->uri = aUri;
+
         // Set the lock depth
-        switch( inLock.depth )
+        switch( rLock.Depth )
         {
-            case DAVZERO:
-            case DAVINFINITY:
-                theLock->depth = int ( inLock.depth );
-                break;
+            case ucb::LockDepth_ZERO:     theLock->depth = NE_DEPTH_ZERO;     break;
+            case ucb::LockDepth_ONE:      theLock->depth = NE_DEPTH_ONE;      break;
+            case ucb::LockDepth_INFINITY: theLock->depth = NE_DEPTH_INFINITE; break;
             default:
-                throw DAVException( DAVException::DAV_INVALID_ARG );
-                break;
+                                          throw DAVException( DAVException::DAV_INVALID_ARG );
         }
 
         // Set the lock scope
-        switch ( inLock.scope )
+        switch ( rLock.Scope )
         {
-            case EXCLUSIVE:
-                theLock->scope = ne_lockscope_exclusive;
-                break;
-            case SHARED:
-                theLock->scope = ne_lockscope_shared;
-                break;
+            case ucb::LockScope_EXCLUSIVE: theLock->scope = ne_lockscope_exclusive; break;
+            case ucb::LockScope_SHARED:    theLock->scope = ne_lockscope_shared;    break;
             default:
-                throw DAVException( DAVException::DAV_INVALID_ARG );
-                break;
+                                           throw DAVException( DAVException::DAV_INVALID_ARG );
+                                           break;
         }
 
         // Set the lock owner
-        const char * theOwner = rtl::OUStringToOString( inLock.owner,
-                                                        RTL_TEXTENCODING_UTF8 );
-        theLock->owner = const_cast< char * > ( theOwner );
+        rtl::OUString aValue;
+        rLock.Owner >>= aValue;
+
+        theLock->owner = strdup( rtl::OUStringToOString( aValue, RTL_TEXTENCODING_UTF8 ).getStr() );
 
         // Set the lock timeout
-        // Note: Neon ignores the timeout
-        //theLock->timeout = inLock.timeout;
+        // We re-new the lock while the stream is open
+        theLock->timeout = rLock.Timeout;
+    }
+
+    if ( bLockit )
+    {
+        int nRet;
+        if ( bAlreadyExists )
+        {
+#if NEON_VERSION >= 0x0260
+            nRet = ne_lock_refresh( m_pHttpSession, theLock );
+#else
+            // workaround for a bug in neon 0.24
+            // we have to call with a bigger structure that is used internally
+            // and initialize parts of it
+
+            struct lock_ctx
+            {
+                struct ne_lock active; /* activelock */
+                char *token; /* the token we're after. */
+                int found;
+                ne_buffer *cdata;
+            };
+
+            struct lock_ctx ctx;
+
+            memset( &ctx, 0, sizeof ctx );
+            ctx.cdata = ne_buffer_create();
+
+            memcpy( &ctx, theLock, sizeof( *theLock ) );
+            nRet = ne_lock_refresh( m_pHttpSession, reinterpret_cast<NeonLock*>( &ctx ) );
+
+            ne_buffer_destroy( ctx.cdata );
+#endif
+            if ( ( nRet == NE_ERROR ) && strncmp (ne_get_error (m_pHttpSession), "No activelock ", strlen ("No activelock ")) == 0 )
+            {
+                bAlreadyExists = false;
+                ne_lockstore_remove( s_aNeonLockStore, theLock );
+            }
+        }
+        if ( !bAlreadyExists )
+        {
+            nRet = ne_lock( m_pHttpSession, theLock );
+
+            if ( nRet == NE_OK )
+            {
+                ne_lockstore_add( s_aNeonLockStore, theLock );
+
+                uno::Sequence< rtl::OUString > aTokens( 1 );
+                aTokens[0] = rtl::OUString::createFromAscii( theLock->token );
+                rLock.LockTokens = aTokens;
+
+#if OSL_DEBUG_LEVEL > 0
+                fprintf( stderr, "WebDAV: locked the URL, the token is: %s\n", theLock->token );
+#endif
+            }
+        }
 
-        theRetVal = ne_lock( m_pHttpSession, theLock );
+        if ( ( nRet == NE_ERROR ) && getStatusCode( m_pHttpSession ) == SC_LOCKED )
+        {
+            ucbhelper::cancelCommandExecution( ucb::IOErrorCode_LOCKING_VIOLATION,
+                    uno::Sequence< uno::Any >( 0 ), // FIXME more info about the file?
+                    m_aEnv.m_xEnv,
+                    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "a locking error occured" ) ),
+                    uno::Reference< ucb::XCommandProcessor >() );
+        }
+#if OSL_DEBUG_LEVEL > 0
+        else if ( nRet == NE_OK )
+            fprintf( stderr, "WebDAV: locked/refreshed lock OK\n" );
+        else
+            fprintf( stderr, "WebDAV: failed to lock the file: %s\n", ne_get_error( m_pHttpSession ) );
+#endif
     }
     else
     {
-
         // Set the lock token
-        rtl::OUString theToken = inLock.locktoken.getConstArray()[ 0 ];
-        theLock->token = const_cast< char * >
-            ( rtl::OUStringToOString(
-                    theToken, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if ( rLock.LockTokens.getLength() > 0 )
+        {
+            rtl::OUString theToken = rLock.LockTokens.getConstArray()[ 0 ];
+            theLock->token = strdup( rtl::OUStringToOString( theToken, RTL_TEXTENCODING_UTF8 ).getStr() );
 
-        theRetVal = ne_unlock( m_pHttpSession, theLock );
-    }
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: going to unlock the URL, the token is: %s\n", theLock->token );
+#endif
 
-    HandleError( theRetVal );
+            ne_unlock( m_pHttpSession, theLock );
+            ne_lockstore_remove( s_aNeonLockStore, theLock );
+            // FIXME even ne_lock_destroy( theLock )?
+        }
+    }
 }
-*/
 
 // -------------------------------------------------------------------
 namespace {
diff --git a/ucb/source/ucp/webdav/NeonSession.hxx b/ucb/source/ucp/webdav/NeonSession.hxx
index d43ee5b..a653071 100644
--- a/ucb/source/ucp/webdav/NeonSession.hxx
+++ b/ucb/source/ucp/webdav/NeonSession.hxx
@@ -54,6 +54,7 @@ class NeonSession : public DAVSession
         rtl::OUString     m_aScheme;
         rtl::OUString     m_aHostName;
         rtl::OUString     m_aProxyName;
+        rtl::OUString     m_aUserInfo;
         sal_Int32         m_nPort;
         sal_Int32         m_nProxyPort;
         HttpSession *     m_pHttpSession;
@@ -67,8 +68,7 @@ class NeonSession : public DAVSession
         // moment.
         DAVRequestEnvironment m_aEnv;
 
-        // Note: Uncomment the following if locking support is required
-        // NeonLockSession *      mNeonLockSession;
+        static NeonLockStore *s_aNeonLockStore;
 
         static bool       m_bGlobalsInited;
 
@@ -89,6 +89,8 @@ class NeonSession : public DAVSession
         const DAVRequestEnvironment & getRequestEnvironment() const
         { return m_aEnv; }
 
+        const rtl::OUString & getUserInfo() const { return m_aUserInfo; }
+
         virtual void
         OPTIONS( const ::rtl::OUString &  inPath,
                  DAVCapabilities & outCapabilities,
@@ -139,11 +141,12 @@ class NeonSession : public DAVSession
             throw ( DAVException );
 
         virtual com::sun::star::uno::Reference<
-            com::sun::star::io::XInputStream >
+            com::sun::star::io::XStream >
         GET( const ::rtl::OUString & inPath,
              const std::vector< ::rtl::OUString > & inHeaderNames,
              DAVResource & ioResource,
-             const DAVRequestEnvironment & rEnv )
+             const DAVRequestEnvironment & rEnv,
+             sal_Bool bAllowEmpty = sal_False )
             throw ( DAVException );
 
         virtual void
@@ -162,6 +165,13 @@ class NeonSession : public DAVSession
                 const DAVRequestEnvironment & rEnv )
             throw ( DAVException );
 
+        virtual void
+        PUT( const ::rtl::OUString & inPath,
+             const char * buffer,
+             size_t size,
+             const DAVRequestEnvironment & rEnv )
+            throw ( DAVException );
+
         virtual com::sun::star::uno::Reference<
             com::sun::star::io::XInputStream >
         POST( const rtl::OUString & inPath,
@@ -209,16 +219,13 @@ class NeonSession : public DAVSession
         virtual void ABORT()
             throw ( DAVException );
 
-        // Note: Uncomment the following if locking support is required
-        /*
-        virtual void LOCK (const Lock & inLock,
-                           const DAVRequestEnvironment & rEnv )
+        virtual void LOCK ( com::sun::star::ucb::Lock & rLock,
+                            const DAVRequestEnvironment & rEnv )
             throw ( DAVException );
 
-        virtual void UNLOCK (const Lock & inLock,
-                             const DAVRequestEnvironment & rEnv )
+        virtual void UNLOCK ( com::sun::star::ucb::Lock & rLock,
+                              const DAVRequestEnvironment & rEnv )
             throw ( DAVException );
-        */
 
         // helpers
         const rtl::OUString & getHostName() const { return m_aHostName; }
@@ -239,9 +246,8 @@ class NeonSession : public DAVSession
 
         const ucbhelper::InternetProxyServer & getProxySettings() const;
 
-        // Note: Uncomment the following if locking support is required
-        // void			Lockit( const Lock & inLock, bool inLockit )
-        //	throw ( DAVException );
+        void Lockit( com::sun::star::ucb::Lock & rLock, bool bLockit )
+            throw ( DAVException );
 
         // low level GET implementation, used by public GET implementations
         static int GET( ne_session * sess,
diff --git a/ucb/source/ucp/webdav/NeonTypes.hxx b/ucb/source/ucp/webdav/NeonTypes.hxx
index b5c1473..67375c5 100644
--- a/ucb/source/ucp/webdav/NeonTypes.hxx
+++ b/ucb/source/ucp/webdav/NeonTypes.hxx
@@ -32,6 +32,7 @@
 #include <ne_utils.h>
 #include <ne_basic.h>
 #include <ne_props.h>
+#include <ne_locks.h>
 
 typedef ne_session                  HttpSession;
 typedef ne_status                   HttpStatus;
@@ -40,4 +41,7 @@ typedef ne_server_capabilities      HttpServerCapabilities;
 typedef ne_propname                 NeonPropName;
 typedef ne_prop_result_set          NeonPropFindResultSet;
 
+typedef ne_lock_store               NeonLockStore;
+typedef struct ne_lock              NeonLock;
+
 #endif // _NEONTYPES_HXX_
diff --git a/ucb/source/ucp/webdav/webdavcontent.cxx b/ucb/source/ucp/webdav/webdavcontent.cxx
index d2a1ab0..d9250a6 100644
--- a/ucb/source/ucp/webdav/webdavcontent.cxx
+++ b/ucb/source/ucp/webdav/webdavcontent.cxx
@@ -34,6 +34,7 @@
 
  *************************************************************************/
 #include <osl/diagnose.h>
+#include <osl/thread.hxx>
 
 #include "osl/doublecheckedlocking.h"
 #include <rtl/uri.hxx>
@@ -45,20 +46,17 @@
 #include <com/sun/star/beans/PropertySetInfoChangeEvent.hpp>
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/io/XActiveDataSink.hpp>
+#include <com/sun/star/io/XActiveDataStreamer.hpp>
 #include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/lang/IllegalAccessException.hpp>
 #include "com/sun/star/ucb/AuthenticationRequest.hpp"
 #include <com/sun/star/ucb/CommandFailedException.hpp>
 #include <com/sun/star/ucb/ContentInfoAttribute.hpp>
 #include <com/sun/star/ucb/InsertCommandArgument.hpp>
-#ifndef _COM_SUN_STAR_UCB_INTERACTIVEBADTRANSFRERURLEXCEPTION_HPP_
 #include <com/sun/star/ucb/InteractiveBadTransferURLException.hpp>
-#endif
 #include <com/sun/star/ucb/InteractiveAugmentedIOException.hpp>
 #include <com/sun/star/ucb/InteractiveNetworkConnectException.hpp>
-#ifndef _COM_SUN_STAR_UCB_INTERACTIVENETWORKGENBERALEXCEPTION_HPP_
 #include <com/sun/star/ucb/InteractiveNetworkGeneralException.hpp>
-#endif
 #include <com/sun/star/ucb/InteractiveNetworkReadException.hpp>
 #include <com/sun/star/ucb/InteractiveNetworkResolveNameException.hpp>
 #include <com/sun/star/ucb/InteractiveNetworkWriteException.hpp>
@@ -87,6 +85,8 @@
 #include "NeonUri.hxx"
 #include "UCBDeadPropertyValue.hxx"
 
+#include "NeonInputStream.hxx"
+
 using namespace com::sun::star;
 using namespace webdav_ucp;
 
@@ -342,6 +342,123 @@ void SAL_CALL CommandEnvironment_Impl::handle(
 //=========================================================================
 //=========================================================================
 
+// Our signal - 246 is just a random number ;-)
+#define TICKER_THREAD_USER_SIGNAL ( OSL_SIGNAL_USER_RESERVED + 246 )
+
+// -------------------------------------------------------------------
+// A thread that 'ticks' - emits the user signal every second
+// -------------------------------------------------------------------
+class TickerThread : public osl::Thread
+{
+    bool m_bFinish;
+
+public:
+
+    TickerThread() : osl::Thread(), m_bFinish( false ) {}
+
+    void finish() { m_bFinish = true; }
+
+protected:
+
+    virtual void SAL_CALL run();
+};
+
+void TickerThread::run()
+{
+    // we have to go through the loop more often to be able to finish ~quickly
+    const int nNth = 25;
+
+    int nCount = nNth;
+    while ( !m_bFinish )
+    {
+        if ( nCount-- <= 0 )
+        {
+            osl_raiseSignal( TICKER_THREAD_USER_SIGNAL, NULL );
+            nCount = nNth;
+        }
+
+        TimeValue aTV;
+        aTV.Seconds = 0;
+        aTV.Nanosec = 1000000000/nNth;
+        wait( aTV );
+    }
+}
+
+// -------------------------------------------------------------------
+// A class that takes care of creating and destroying the ticker thread
+// -------------------------------------------------------------------
+class TickerThreadController
+{
+    osl::Mutex    m_aMutex;
+    int           m_nCount;
+    TickerThread *m_pTickerThread;
+
+public:
+
+    TickerThreadController() : m_nCount( 0 ), m_pTickerThread( NULL ) {}
+
+    void start();
+    void stop();
+};
+
+void TickerThreadController::start()
+{
+    osl::MutexGuard aGuard( m_aMutex );
+
+    if ( ( m_nCount++ == 0 ) && !m_pTickerThread )
+    {
+        m_pTickerThread = new TickerThread();
+        m_pTickerThread->create();
+    }
+}
+
+void TickerThreadController::stop()
+{
+    osl::MutexGuard aGuard( m_aMutex );
+
+    if ( ( --m_nCount == 0 ) && m_pTickerThread )
+    {
+        m_pTickerThread->finish();
+        m_pTickerThread->join();
+
+        delete m_pTickerThread;
+        m_pTickerThread = NULL;
+    }
+}
+
+// -------------------------------------------------------------------
+// Signal handler
+// -------------------------------------------------------------------
+oslSignalAction Content::HandleLockingSignal( void* pData, oslSignalInfo* pSignalInfo )
+{
+    Content *pContent = static_cast< Content *>( pData );
+
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "Content::HandleLockingSignal: pContent=%p pSignalInfo=%p\n", pContent, pSignalInfo );
+#endif
+
+    if ( !pContent )
+        return osl_Signal_ActCallNextHdl;
+
+    if ( pSignalInfo  &&
+            pSignalInfo->Signal == osl_Signal_User &&
+            pSignalInfo->UserSignal == TICKER_THREAD_USER_SIGNAL )
+    {
+        pContent->RefreshLock();
+    }
+    else if ( !pSignalInfo || ( pSignalInfo->Signal != osl_Signal_User ) )
+    {
+        // terminating or something
+        pContent->m_xResAccess->UNLOCK( *pContent->m_pLock, pContent->m_xLockEnv );
+        delete pContent->m_pLock;
+        pContent->m_pLock = NULL;
+    }
+
+    return osl_Signal_ActCallNextHdl;
+}
+
+static TickerThreadController sTickerThreadController;
+
 //=========================================================================
 // ctr for content on an existing webdav resource
 Content::Content(
@@ -355,7 +472,11 @@ Content::Content(
   m_pProvider( pProvider ),
   m_bTransient( false ),
   m_bCollection( false ),
-  m_bDidGetOrHead( false )
+  m_bDidGetOrHead( false ),
+  m_bForceReadOnly( false ),
+  m_pLock( NULL ),
+  m_nToExpire( -1 ),
+  m_pSignalHandler( NULL )
 {
     try
     {
@@ -366,6 +487,14 @@ Content::Content(
 
         NeonUri aURI( Identifier->getContentIdentifier() );
         m_aEscapedTitle = aURI.GetPathBaseName();
+
+        m_pSignalHandler = osl_addSignalHandler( HandleLockingSignal, this );
+
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "Content::Content (existing resource): this=%p m_pSignalHandler=%p\n", this, m_pSignalHandler );
+        fprintf( stderr, " identifier=%s\n", rtl::OUStringToOString( Identifier->getContentIdentifier(), RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+        sTickerThreadController.start();
     }
     catch ( DAVException const & )
     {
@@ -387,12 +516,24 @@ Content::Content(
   m_pProvider( pProvider ),
   m_bTransient( true ),
   m_bCollection( isCollection ),
-  m_bDidGetOrHead( false )
+  m_bDidGetOrHead( false ),
+  m_bForceReadOnly( false ),
+  m_pLock( NULL ),
+  m_nToExpire( -1 ),
+  m_pSignalHandler( NULL )
 {
     try
     {
         m_xResAccess.reset( new DAVResourceAccess(
             rxSMgr, rSessionFactory, Identifier->getContentIdentifier() ) );
+
+        m_pSignalHandler = osl_addSignalHandler( HandleLockingSignal, this );
+
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "Content::Content (nonexistent resource): this=%p m_pSignalHandler=%p\n", this, m_pSignalHandler );
+        fprintf( stderr, " identifier=%s\n", rtl::OUStringToOString( Identifier->getContentIdentifier(), RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+        sTickerThreadController.start();
     }
     catch ( DAVException const & )
     {
@@ -406,6 +547,47 @@ Content::Content(
 // virtual
 Content::~Content()
 {
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "Content::~Content: this=%p m_pSignalHandler=%p\n", this, m_pSignalHandler );
+#endif
+    sTickerThreadController.stop();
+
+    osl_removeSignalHandler( m_pSignalHandler );
+
+    if (m_pLock != NULL)
+    {
+        try {
+            m_xResAccess->UNLOCK( *m_pLock, m_xLockEnv );
+            delete m_pLock;
+            m_pLock = NULL;
+        }
+        catch ( ucb::CommandFailedException const & )
+        {
+        }
+    }
+}
+
+// -------------------------------------------------------------------
+// Lock the resource again
+// -------------------------------------------------------------------
+void Content::RefreshLock( void )
+{
+    osl::MutexGuard aGuard( m_aLock );
+
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "Content::RefreshLock(): m_nToExpire=%d m_pLock=%p\n", m_nToExpire, m_pLock);
+#endif
+
+    if ( m_nToExpire > 0 )
+        --m_nToExpire;
+
+    // Refresh the lock if it expires in less than 30 s
+    if ( m_pLock && m_nToExpire >= 0 && m_nToExpire < 30 )
+    {
+        m_xResAccess->LOCK( *m_pLock, m_xLockEnv );
+
+        m_nToExpire = m_pLock->Timeout;
+    }
 }
 
 //=========================================================================
@@ -627,6 +809,11 @@ uno::Any SAL_CALL Content::execute(
            ucb::CommandAbortedException,
            uno::RuntimeException )
 {
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::execute(): this=%p command=%s\n",
+             this, rtl::OUStringToOString( aCommand.Name, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+
     uno::Any aRet;
     
     if ( aCommand.Name.equalsAsciiL(
@@ -896,6 +1083,11 @@ void SAL_CALL Content::addProperty( const rtl::OUString& Name,
     if ( !Name.getLength() )
         throw lang::IllegalArgumentException();
 
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::addProperty(): this=%p property=%s\n",
+             this, rtl::OUStringToOString( Name, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+
     // Check property type.
     if ( !UCBDeadPropertyValue::supportsType( DefaultValue.getValueType() ) )
     {
@@ -1045,6 +1237,11 @@ void SAL_CALL Content::removeProperty( const rtl::OUString& Name )
     // Try to remove property from server.
     //////////////////////////////////////////////////////////////////////
 
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::removeProperty(): this=%p property=%s\n",
+             this, rtl::OUStringToOString( Name, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+
     try
     {
         std::vector< ProppatchValue > aProppatchValues;
@@ -1358,6 +1555,31 @@ uno::Reference< sdbc::XRow > Content::getPropertyValues(
     uno::Reference< ucb::XContentIdentifier >    xIdentifier;
     rtl::Reference< ::ucbhelper::ContentProviderImplHelper > xProvider;
 
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::getPropertyValues(): answering the following properties: " );
+    for ( int i = 0; i < rProperties.getLength(); ++i )
+        fprintf( stderr, " %s,",
+                rtl::OUStringToOString( rProperties[i].Name, RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( stderr, "\n" );
+#endif
+
+    // WebDAV supports XActiveDataStreamer
+    // We have to return TRUE on
+    // - SupportsActiveStreaming - always
+    // - IsReadOnly - if we forced read only due to failed locking
+    if ( rProperties.getLength() == 1 )
+    {
+        if ( rProperties[ 0 ].Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "SupportsActiveStreaming" ) ) ||
+             ( rProperties[ 0 ].Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) && m_bForceReadOnly ) )
+        {
+            rtl::Reference< ::ucbhelper::PropertyValueSet > xRow
+                = new ::ucbhelper::PropertyValueSet( m_xSMgr );
+            xRow->appendBoolean( rProperties[0], sal_True );
+
+            return uno::Reference< sdbc::XRow >( xRow.get() );
+        }
+    }
+
     {
         osl::Guard< osl::Mutex > aGuard( m_aMutex );
 
@@ -1484,8 +1706,13 @@ uno::Reference< sdbc::XRow > Content::getPropertyValues(
                         
                         if ( !bNetworkAccessAllowed )
                         {
-                            cancelCommandExecution( e, xEnv );
-                            // unreachable
+                            if ( e.getStatus() == SC_NOT_FOUND )
+                                xProps.reset();
+                            else
+                            {
+                                cancelCommandExecution( e, xEnv );
+                                // unreachable
+                            }
                         }
                     }
                 }
@@ -2060,6 +2287,10 @@ uno::Any Content::open(
 {
     uno::Any aRet;
 
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::open() this=%p\n", this );
+#endif
+
     sal_Bool bOpenFolder = ( ( rArg.Mode == ucb::OpenMode::ALL ) ||
                              ( rArg.Mode == ucb::OpenMode::FOLDERS ) ||
                              ( rArg.Mode == ucb::OpenMode::DOCUMENTS ) );
@@ -2101,13 +2332,16 @@ uno::Any Content::open(
         }
     }
 
-    if ( rArg.Sink.is() )
-    {
-        // Open document.
+    if ( !rArg.Sink.is() )
+        return aRet;
+
+       // Open document.
 
-        if ( ( rArg.Mode == ucb::OpenMode::DOCUMENT_SHARE_DENY_NONE ) ||
-             ( rArg.Mode == ucb::OpenMode::DOCUMENT_SHARE_DENY_WRITE ) )
+    if ( rArg.Mode == ucb::OpenMode::DOCUMENT_SHARE_DENY_WRITE )
         {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Mode currently(?) unsupported\n" );
+#endif
             // Currently(?) unsupported.
             ucbhelper::cancelCommandExecution(
                 uno::makeAny(
@@ -2124,6 +2358,9 @@ uno::Any Content::open(
             = uno::Reference< io::XOutputStream >( rArg.Sink, uno::UNO_QUERY );
         if ( xOut.is() )
         {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XOutputStream\n" );
+#endif
             // PUSH: write data
             try
             {
@@ -2168,6 +2405,60 @@ uno::Any Content::open(
                                                          uno::UNO_QUERY );
             if ( xDataSink.is() )
             {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataSink\n" );
+#endif
+            // PULL: wait for client read
+            try
+            {
+                {
+                    osl::MutexGuard aGuard( m_aMutex );
+
+                    // throw away previously cached headers.
+                    m_xCachedProps.reset();
+                }
+                // fill inputsream sync; return if all data present
+                DAVResource aResource;
+                std::vector< rtl::OUString > aHeaders;
+                //                        // Obtain list containing all HTTP headers that can
+                //                        // be mapped to UCB properties.
+                //                        ContentProperties::getMappableHTTPHeaders( aHeaders );
+                uno::Reference< io::XInputStream > xIn
+                    = m_xResAccess->GET( aHeaders, aResource, xEnv )->getInputStream();
+
+                {
+                    osl::MutexGuard aGuard( m_aMutex );
+
+                    m_xCachedProps.reset(
+                            new ContentProperties( aResource ) );
+                }
+
+                xDataSink->setInputStream( xIn );
+            }
+            catch ( DAVException const & e )
+            {
+                cancelCommandExecution( e, xEnv );
+                // Unreachable
+            }
+        }
+        else
+        {
+            uno::Reference< io::XActiveDataStreamer > xDataStreamer
+                = uno::Reference< io::XActiveDataStreamer >( rArg.Sink,
+                        uno::UNO_QUERY );
+            if ( xDataStreamer.is() && !m_bForceReadOnly )
+            {
+#if OSL_DEBUG_LEVEL > 0
+                fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataStreamer\n" );
+#endif
+                // prepare the lock
+                m_pLock = new ucb::Lock;
+                m_pLock->Depth = ucb::LockDepth_ZERO;
+                m_pLock->Scope = ucb::LockScope_EXCLUSIVE;
+                m_pLock->Timeout = 2*60; // 2 minutes
+
+                m_nToExpire = m_pLock->Timeout;
+
                 // PULL: wait for client read
                 try
                 {
@@ -2183,9 +2474,31 @@ uno::Any Content::open(
                     DAVResource aResource;
                     std::vector< rtl::OUString > aHeaders;
 
-                    uno::Reference< io::XInputStream > xIn
-                        = xResAccess->GET( aHeaders, aResource, xEnv );
+                    try {
+                        xResAccess->LOCK( *m_pLock, xEnv );
+                        m_xLockEnv = xEnv;
+                    }
+                    catch ( ucb::CommandFailedException const &e )
+                    {
+                        // stream locked?
+                        ucb::InteractiveIOException aIoException;
+                        if ( ( e.Reason >>= aIoException ) && ( aIoException.Code == ucb::IOErrorCode_LOCKING_VIOLATION ) )
+                        {
+                            delete m_pLock;
+                            m_pLock = NULL;
+                            // yes => we must be read only at the next try
+                            m_bForceReadOnly = sal_True;
+                        }
+
+                        throw;
+                    }
+
+                    uno::Reference< io::XStream > xStream
+                        = xResAccess->GET( aHeaders, aResource, xEnv, sal_True );
                     m_bDidGetOrHead = true;
+
+                    // pass the URL to the stream
+                    static_cast< NeonInputStream* >( xStream.get() )->SetURL( m_xResAccess->getURL() );
                     
                     {
                         osl::MutexGuard aGuard( m_aMutex );
@@ -2200,16 +2513,24 @@ uno::Any Content::open(
                             new DAVResourceAccess( *xResAccess.get() ) );
                     }
 
-                    xDataSink->setInputStream( xIn );
+                    xDataStreamer->setStream( xStream );
                 }
                 catch ( DAVException const & e )
                 {
+                    m_xResAccess->UNLOCK( *m_pLock, xEnv );
+                    delete m_pLock;
+                    m_pLock = NULL;
+                    m_bForceReadOnly = sal_False;
+
                     cancelCommandExecution( e, xEnv );
                     // Unreachable
                 }
             }
             else
             {
+#if OSL_DEBUG_LEVEL > 0
+                fprintf( stderr, "WebDAV: unsupported rArg.Sink\n" );
+#endif
                 // Note: aOpenCommand.Sink may contain an XStream
                 //       implementation. Support for this type of
                 //       sink is optional...
@@ -2234,9 +2555,16 @@ void Content::post(
                 const uno::Reference< ucb::XCommandEnvironment > & xEnv )
     throw( uno::Exception )
 {
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::post() this=%p\n", this );
+#endif
+
     uno::Reference< io::XActiveDataSink > xSink( rArg.Sink, uno::UNO_QUERY );
     if ( xSink.is() )
     {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataSink\n" );
+#endif
         try
         {
             std::auto_ptr< DAVResourceAccess > xResAccess;
@@ -2271,6 +2599,9 @@ void Content::post(
         uno::Reference< io::XOutputStream > xResult( rArg.Sink, uno::UNO_QUERY );
         if ( xResult.is() )
         {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XOutputStream\n" );
+#endif
             try
             {
                 std::auto_ptr< DAVResourceAccess > xResAccess;
@@ -2300,6 +2631,9 @@ void Content::post(
         }
         else
         {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataStreamer (or something)\n" );
+#endif
             ucbhelper::cancelCommandExecution(
                 uno::makeAny(
                     ucb::UnsupportedDataSinkException(
@@ -2374,6 +2708,10 @@ void Content::insert(
     rtl::OUString aEscapedTitle;
     std::auto_ptr< DAVResourceAccess > xResAccess;
 
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Content::insert() this=%p\n", this );
+#endif
+
     {
         osl::Guard< osl::Mutex > aGuard( m_aMutex );
 
@@ -2652,11 +2990,23 @@ void Content::transfer(
                 rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
         }
         else if ( aScheme.equalsAsciiL(
+                RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAV_URL_SCHEME ) ) )
+        {
+            sourceURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
+        }
+        else if ( aScheme.equalsAsciiL(
                 RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) )
         {
             sourceURI.SetScheme(
                 rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
         }
+        else if ( aScheme.equalsAsciiL(
+                RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAVS_URL_SCHEME ) ) )
+        {
+            sourceURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
+        }
         else
         {
             if ( !aScheme.equalsAsciiL(
@@ -2683,6 +3033,18 @@ void Content::transfer(
                  RTL_CONSTASCII_STRINGPARAM( DAV_URL_SCHEME ) ) )
             targetURI.SetScheme(
                 rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
+        else if ( targetURI.GetScheme().toAsciiLowerCase().equalsAsciiL(
+                 RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAV_URL_SCHEME ) ) )
+            targetURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
+        else if ( targetURI.GetScheme().toAsciiLowerCase().equalsAsciiL(
+                 RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) )
+            targetURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
+        else if ( targetURI.GetScheme().toAsciiLowerCase().equalsAsciiL(
+                 RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAVS_URL_SCHEME ) ) )
+            targetURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
     
         // @@@ This implementation of 'transfer' only works
         //     if the source and target are located at same host.
diff --git a/ucb/source/ucp/webdav/webdavcontent.hxx b/ucb/source/ucp/webdav/webdavcontent.hxx
index 26fae76..dcaa506 100644
--- a/ucb/source/ucp/webdav/webdavcontent.hxx
+++ b/ucb/source/ucp/webdav/webdavcontent.hxx
@@ -30,10 +30,13 @@
 
 #include <memory>
 #include <list>
+#include <osl/signal.h>
 #include <rtl/ref.hxx>
 #include <com/sun/star/ucb/ContentCreationException.hpp>
 #include <com/sun/star/ucb/XContentCreator.hpp>
+#include <com/sun/star/ucb/Lock.hpp>
 #include <ucbhelper/contenthelper.hxx>
+
 #include "DAVResourceAccess.hxx"
 #include "PropertyMap.hxx"
 
@@ -88,6 +91,9 @@ class Content : public ::ucbhelper::ContentImplHelper,
       bool			  m_bTransient;
     bool              m_bCollection;
     bool              m_bDidGetOrHead;
+    bool              m_bForceReadOnly;
+    com::sun::star::ucb::Lock *m_pLock;
+    uno::Reference< ucb::XCommandEnvironment > m_xLockEnv;
     std::vector< rtl::OUString > m_aFailedPropNames;
 
 private:
@@ -181,6 +187,17 @@ private:
 
     static bool shouldAccessNetworkAfterException( const DAVException & e );
 
+    oslSignalHandler           m_pSignalHandler;
+    int                        m_nToExpire;
+    osl::Mutex                 m_aLock;
+
+    // Refresh the lock of the resource
+    void RefreshLock( void );
+
+    // Refresh the lock if necessary, or unlock the resource when
+    // OOo crashes or is terminated
+    static oslSignalAction HandleLockingSignal( void* pData, oslSignalInfo* pInfo );
+
 public:
       Content( const ::com::sun::star::uno::Reference<
                 ::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
diff --git a/ucb/source/ucp/webdav/webdavcontentcaps.cxx b/ucb/source/ucp/webdav/webdavcontentcaps.cxx
index 2f60d77..0c059db 100644
--- a/ucb/source/ucp/webdav/webdavcontentcaps.cxx
+++ b/ucb/source/ucp/webdav/webdavcontentcaps.cxx
@@ -260,6 +260,24 @@ bool ContentProvider::getProperty(
                     -1,
                     getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
                     beans::PropertyAttribute::BOUND ) );
+
+            m_pProps->insert(
+                beans::Property(
+                    rtl::OUString(
+                        RTL_CONSTASCII_USTRINGPARAM( "SupportsActiveStreaming" ) ),
+                    -1,
+                    getCppuBooleanType(),
+                    beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ) );
+
+            m_pProps->insert(
+                beans::Property(
+                    rtl::OUString(
+                        RTL_CONSTASCII_USTRINGPARAM( "IsReadOnly" ) ),
+                    -1,
+                    getCppuBooleanType(),
+                    beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ) );
         }
     }
 
diff --git a/ucb/source/ucp/webdav/webdavprovider.cxx b/ucb/source/ucp/webdav/webdavprovider.cxx
index cc9c69a..357cc9d 100644
--- a/ucb/source/ucp/webdav/webdavprovider.cxx
+++ b/ucb/source/ucp/webdav/webdavprovider.cxx
@@ -33,6 +33,9 @@
  **************************************************************************
 
  *************************************************************************/
+
+#include <string.h>
+
 #include <ucbhelper/contentidentifier.hxx>
 #include "webdavprovider.hxx"
 #include "webdavcontent.hxx"
@@ -135,7 +138,11 @@ ContentProvider::queryContent(
             RTL_CONSTASCII_STRINGPARAM( DAV_URL_SCHEME ) ) &&
          !aScheme.equalsAsciiL(
             RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) &&
-          !aScheme.equalsAsciiL(
+         !aScheme.equalsAsciiL(
+            RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAV_URL_SCHEME ) ) &&
+         !aScheme.equalsAsciiL(
+            RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAVS_URL_SCHEME ) ) &&
+         !aScheme.equalsAsciiL(
              RTL_CONSTASCII_STRINGPARAM( FTP_URL_SCHEME ) )       )
         throw ucb::IllegalIdentifierException();
 
@@ -154,32 +161,27 @@ ContentProvider::queryContent(
     uno::Reference< ucb::XContentIdentifier > xCanonicId;
 
     bool bNewId = false;
-    if ( aScheme.equalsAsciiL(
-            RTL_CONSTASCII_STRINGPARAM( WEBDAV_URL_SCHEME ) ) )
-    {
-        aURL = aURL.replaceAt( 0,
-                               WEBDAV_URL_SCHEME_LENGTH,
-                               rtl::OUString::createFromAscii(
-                                                    HTTP_URL_SCHEME ) );
-        bNewId = true;
-    }
-    else if ( aScheme.equalsAsciiL(
-            RTL_CONSTASCII_STRINGPARAM( DAV_URL_SCHEME ) ) )
+    struct {
+        const char *from;
+        const char *to;
+    } const *pScheme, pReplace[] = {
+        { WEBDAV_URL_SCHEME, HTTP_URL_SCHEME },
+        { DAV_URL_SCHEME, HTTP_URL_SCHEME },
+        { DAVS_URL_SCHEME, HTTPS_URL_SCHEME },
+        { PLAIN_WEBDAV_URL_SCHEME, HTTP_URL_SCHEME },
+        { PLAIN_WEBDAVS_URL_SCHEME, HTTPS_URL_SCHEME },
+        { NULL, NULL }
+    };
+    for ( pScheme = pReplace; pScheme->from ; ++pScheme )
     {
-        aURL = aURL.replaceAt( 0,
-                               DAV_URL_SCHEME_LENGTH,
-                               rtl::OUString::createFromAscii(
-                                                    HTTP_URL_SCHEME ) );
-        bNewId = true;
-    }
-    else if ( aScheme.equalsAsciiL(
-            RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) )
-    {
-        aURL = aURL.replaceAt( 0,
-                               DAVS_URL_SCHEME_LENGTH,
-                               rtl::OUString::createFromAscii(
-                                                    HTTPS_URL_SCHEME ) );
-        bNewId = true;
+        if ( aScheme.equalsAscii( pScheme->from ) )
+        {
+            aURL = aURL.replaceAt( 0,
+                    strlen( pScheme->from ),
+                    rtl::OUString::createFromAscii( pScheme->to ) );
+            bNewId = true;
+            break;
+        }
     }
 
     sal_Int32 nPos = aURL.lastIndexOf( '/' );
@@ -203,6 +205,12 @@ ContentProvider::queryContent(
     else
         xCanonicId = Identifier;
 
+#if OSL_DEBUG_LEVEL > 0
+       fprintf( stderr, "ContentProvider::queryContent(): bNewId=%s, xCanonicId=%s\n",
+                bNewId ? "YES" : "NO",
+                rtl::OUStringToOString( xCanonicId->getContentIdentifier(), RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+
     osl::MutexGuard aGuard( m_aMutex );
 
     // Check, if a content with given id already exists...
@@ -229,4 +237,3 @@ ContentProvider::queryContent(
 
     return xContent;
 }
-
diff --git a/ucb/source/ucp/webdav/webdavprovider.hxx b/ucb/source/ucp/webdav/webdavprovider.hxx
index 6583c8d..b28881e 100644
--- a/ucb/source/ucp/webdav/webdavprovider.hxx
+++ b/ucb/source/ucp/webdav/webdavprovider.hxx
@@ -49,13 +49,10 @@ namespace webdav_ucp {
 // contents ) according to this scheme.
 #define WEBDAV_URL_SCHEME \
                 "vnd.sun.star.webdav"
-#define WEBDAV_URL_SCHEME_LENGTH	19
 
 #define HTTP_URL_SCHEME 		"http"
-#define HTTP_URL_SCHEME_LENGTH	4
 
 #define HTTPS_URL_SCHEME 		"https"
-#define HTTPS_URL_SCHEME_LENGTH	5
 
 #define DAV_URL_SCHEME			"dav"
 #define DAV_URL_SCHEME_LENGTH	3	
@@ -67,6 +64,12 @@ namespace webdav_ucp {
 
 #define FTP_URL_SCHEME "ftp"
 
+#define DAV_URL_SCHEME "dav"
+#define DAVS_URL_SCHEME "davs"
+
+#define PLAIN_WEBDAV_URL_SCHEME "webdav"
+#define PLAIN_WEBDAVS_URL_SCHEME "webdavs"
+
 #define HTTP_CONTENT_TYPE \
                 "application/" HTTP_URL_SCHEME "-content"
 
diff --git a/unotools/source/ucbhelper/ucblockbytes.cxx b/unotools/source/ucbhelper/ucblockbytes.cxx
index f21855d..8f69f72 100644
--- a/unotools/source/ucbhelper/ucblockbytes.cxx
+++ b/unotools/source/ucbhelper/ucblockbytes.cxx
@@ -961,6 +961,10 @@ static sal_Bool UCBOpenContentSync(
     if( ! aScheme.equalsIgnoreAsciiCaseAscii("http")                &&
         ! aScheme.equalsIgnoreAsciiCaseAscii("https")                &&
         ! aScheme.equalsIgnoreAsciiCaseAscii("vnd.sun.star.webdav") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("dav") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("davs") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("webdav") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("webdavs") &&
         ! aScheme.equalsIgnoreAsciiCaseAscii("ftp"))
         return _UCBOpenContentSync(
             xLockBytes,xContent,rArg,xSink,xInteract,xProgress,xHandler);
@@ -1538,7 +1542,13 @@ ErrCode UcbLockBytes::Flush() const
     Reference <XOutputStream > xOutputStream = getOutputStream_Impl();
     if ( !xOutputStream.is() )
         return ERRCODE_IO_CANTWRITE;
-    xOutputStream->flush();
+    try {
+        xOutputStream->flush();
+    }
+    catch (...)
+    {
+        return ERRCODE_IO_CANTWRITE;
+    }
     return ERRCODE_NONE;
 }
 
-- 
1.7.0.1

