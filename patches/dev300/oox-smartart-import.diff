load smart art shapes in oox

From: Thorsten Behrens <thb@openoffice.org>


---

 oox/inc/oox/core/filterbase.hxx                    |    5 
 oox/inc/oox/core/xmlfilterbase.hxx                 |   45 +
 oox/inc/oox/drawingml/chart/converterbase.hxx      |    2 
 oox/inc/oox/drawingml/customshapeproperties.hxx    |    5 
 oox/inc/oox/drawingml/diagram/datamodelcontext.hxx |   57 --
 oox/inc/oox/drawingml/diagram/diagram.hxx          |  242 +------
 .../drawingml/diagram/diagramfragmenthandler.hxx   |  103 ---
 .../oox/drawingml/diagram/diagramlayoutatoms.hxx   |  212 ------
 oox/inc/oox/drawingml/drawingmltypes.hxx           |    3 
 oox/inc/oox/drawingml/graphicshapecontext.hxx      |    5 
 oox/inc/oox/drawingml/scene3dcontext.hxx           |   56 ++
 oox/inc/oox/drawingml/shape.hxx                    |   29 +
 oox/inc/oox/drawingml/shape3dproperties.hxx        |  134 ++++
 oox/inc/oox/drawingml/theme.hxx                    |    8 
 oox/inc/oox/ppt/dgmimport.hxx                      |   68 ++
 oox/inc/oox/ppt/dgmlayout.hxx                      |   69 ++
 oox/inc/oox/ppt/pptimport.hxx                      |    2 
 oox/inc/oox/xls/excelfilter.hxx                    |    2 
 oox/inc/oox/xls/workbookhelper.hxx                 |    2 
 oox/source/core/facreg.cxx                         |    6 
 oox/source/core/filterbase.cxx                     |   17 
 oox/source/core/filterdetect.cxx.orig              |  385 +++++++++++
 oox/source/core/xmlfilterbase.cxx                  |  162 ++++-
 oox/source/drawingml/chart/chartspaceconverter.cxx |    5 
 oox/source/drawingml/chart/converterbase.cxx       |    4 
 oox/source/drawingml/chart/datasourceconverter.cxx |   12 
 oox/source/drawingml/clrscheme.cxx                 |    2 
 oox/source/drawingml/color.cxx                     |    4 
 oox/source/drawingml/customshapegeometry.cxx       |    6 
 .../drawingml/diagram/constraintlistcontext.cxx    |  102 +++
 .../drawingml/diagram/constraintlistcontext.hxx    |   54 ++
 oox/source/drawingml/diagram/datamodelcontext.cxx  |  234 +++++--
 oox/source/drawingml/diagram/datamodelcontext.hxx  |   57 ++
 oox/source/drawingml/diagram/diagram.cxx           |  506 ++++++++++++--
 oox/source/drawingml/diagram/diagram.hxx           |  319 +++++++++
 .../drawingml/diagram/diagramdefinitioncontext.cxx |   15 
 .../drawingml/diagram/diagramdefinitioncontext.hxx |    2 
 .../drawingml/diagram/diagramfragmenthandler.cxx   |  192 +++--
 .../drawingml/diagram/diagramfragmenthandler.hxx   |  117 +++
 .../drawingml/diagram/diagramlayoutatoms.cxx       |  703 +++++++++++++++++++-
 .../drawingml/diagram/diagramlayoutatoms.hxx       |  318 +++++++++
 oox/source/drawingml/diagram/layoutnodecontext.cxx |  145 +++-
 oox/source/drawingml/diagram/layoutnodecontext.hxx |    3 
 oox/source/drawingml/diagram/makefile.mk           |    1 
 oox/source/drawingml/drawingmltypes.cxx            |    4 
 oox/source/drawingml/fillproperties.cxx            |    3 
 oox/source/drawingml/graphicshapecontext.cxx       |   60 --
 oox/source/drawingml/lineproperties.cxx            |    6 
 oox/source/drawingml/makefile.mk                   |    1 
 oox/source/drawingml/scene3dcontext.cxx            |  189 +++++
 oox/source/drawingml/shape.cxx                     |   39 +
 oox/source/drawingml/shape3dproperties.cxx         |   70 ++
 oox/source/drawingml/shapepropertiescontext.cxx    |    6 
 oox/source/drawingml/textparagraph.cxx             |    9 
 oox/source/drawingml/textparagraphproperties.cxx   |    1 
 oox/source/helper/storagebase.cxx                  |   20 -
 oox/source/ppt/dgmimport.cxx                       |  124 ++++
 oox/source/ppt/dgmlayout.cxx                       |  183 +++++
 oox/source/ppt/makefile.mk                         |    2 
 oox/source/ppt/pptimport.cxx                       |    4 
 oox/source/ppt/presentationfragmenthandler.cxx     |   13 
 oox/source/ppt/slidepersist.cxx                    |   11 
 oox/source/shape/ShapeFilterBase.cxx               |    4 
 oox/source/shape/ShapeFilterBase.hxx               |    2 
 oox/source/xls/excelfilter.cxx                     |    2 
 oox/source/xls/workbookhelper.cxx                  |    4 
 sc/source/filter/excel/xestream.cxx                |    5 
 sc/source/filter/inc/xestream.hxx                  |    2 
 110 files changed, 5179 insertions(+), 1084 deletions(-)


diff --git oox/inc/oox/core/filterbase.hxx oox/inc/oox/core/filterbase.hxx
index 445123f..d9ac5ed 100644
--- oox/inc/oox/core/filterbase.hxx
+++ oox/inc/oox/core/filterbase.hxx
@@ -50,6 +50,7 @@ namespace com { namespace sun { namespace star {
     namespace frame { class XModel; }
     namespace task { class XStatusIndicator; }
     namespace task { class XInteractionHandler; }
+    namespace drawing { class XShape; }
     namespace io { class XInputStream; }
     namespace io { class XOutputStream; }
     namespace io { class XStream; }
@@ -100,6 +101,10 @@ public:
     const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >&
                         getModel() const;
 
+    /// Returns the parent shape to load into (if any)
+    const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >&
+                        getParentShape() const;
+
     /** Returns the status indicator. */
     const ::com::sun::star::uno::Reference< ::com::sun::star::task::XStatusIndicator >&
                         getStatusIndicator() const;
diff --git oox/inc/oox/core/xmlfilterbase.hxx oox/inc/oox/core/xmlfilterbase.hxx
index c46ee40..794a88b 100644
--- oox/inc/oox/core/xmlfilterbase.hxx
+++ oox/inc/oox/core/xmlfilterbase.hxx
@@ -42,8 +42,10 @@
 
 namespace com { namespace sun { namespace star {
     namespace container { class XNameContainer; }
+    namespace xml { namespace dom { class XDocument; } }
     namespace xml { namespace sax { class XLocator; } }
     namespace xml { namespace sax { class XFastDocumentHandler; } }
+    namespace xml { namespace sax { class XFastSAXSerializable; } }
 } } }
 
 namespace oox { namespace drawingml { class Theme; } }
@@ -80,17 +82,19 @@ public:
     /** Has to be implemented by each filter to resolve scheme colors. */
     virtual sal_Int32   getSchemeClr( sal_Int32 nColorSchemeToken ) const = 0;
 
-    /** Has to be implemented by each filter to return drawings collection. */
+    /** Has to be implemented by each filter to return the table style list. */
+	virtual const ::oox::drawingml::table::TableStyleListPtr getTableStyles() = 0;
+
+    // ------------------------------------------------------------------------
+
+    /** Override to return drawings collection. */
     virtual const ::oox::vml::DrawingPtr
-                        getDrawings() = 0;
+                        getDrawings();
 
-    /** Has to be implemented by each filter, returns a filter-specific chart
+    /** Override to return a filter-specific chart
         converter object, that should be global per imported document. */
-    virtual ::oox::drawingml::chart::ChartConverter&
-                        getChartConverter() = 0;
-
-    /** Has to be implemented by each filter to return the table style list. */
-	virtual const ::oox::drawingml::table::TableStyleListPtr getTableStyles() = 0;
+    virtual ::oox::drawingml::chart::ChartConverter*
+                        getChartConverter();
 
     // ------------------------------------------------------------------------
 
@@ -105,6 +109,31 @@ public:
      */
     bool                importFragment( const ::rtl::Reference< FragmentHandler >& rxHandler );
 
+    /** Imports a fragment into an xml::dom::XDocument.
+
+        @param rFragmentPath path to fragment
+
+        @return a non-empty reference to the XDocument, if the
+        fragment could be imported.
+     */
+    ::com::sun::star::uno::Reference<
+       ::com::sun::star::xml::dom::XDocument> importFragment( const ::rtl::OUString& rFragmentPath );
+
+    /** Imports a fragment from an xml::dom::XDocument using the
+        passed fragment handler
+
+        @param rxHandler fragment handler; path to fragment is
+        ignored, input source is the rxSerializer
+
+        @param rxSerializer usually retrieved from a
+        xml::dom::XDocument, will get serialized into rxHandler
+
+        @return true, if the fragment could be imported.
+     */
+    bool importFragment( const ::rtl::Reference< FragmentHandler >& rxHandler,
+                         const ::com::sun::star::uno::Reference< 
+                               ::com::sun::star::xml::sax::XFastSAXSerializable >& rxSerializer );
+
     /** Imports the relations fragment associated with the specified fragment.
 
         @return  The relations collection of the specified fragment.
diff --git oox/inc/oox/drawingml/chart/converterbase.hxx oox/inc/oox/drawingml/chart/converterbase.hxx
index f456d95..35fa990 100644
--- oox/inc/oox/drawingml/chart/converterbase.hxx
+++ oox/inc/oox/drawingml/chart/converterbase.hxx
@@ -79,7 +79,7 @@ protected:
     /** Returns the filter object of the imported/exported document. */
     ::oox::core::XmlFilterBase& getFilter() const;
     /** Returns the chart converter. */
-    ChartConverter&     getChartConverter() const;
+    ChartConverter*     getChartConverter() const;
     /** Returns the API chart document model. */
     ::com::sun::star::uno::Reference< ::com::sun::star::chart2::XChartDocument >
                         getChartDocument() const;
diff --git oox/inc/oox/drawingml/customshapeproperties.hxx oox/inc/oox/drawingml/customshapeproperties.hxx
index 2fe36f2..db3810c 100644
--- oox/inc/oox/drawingml/customshapeproperties.hxx
+++ oox/inc/oox/drawingml/customshapeproperties.hxx
@@ -76,8 +76,9 @@ public:
 			const ::com::sun::star::uno::Reference < ::com::sun::star::beans::XPropertySet > & xPropSet,
                         const ::com::sun::star::uno::Reference < ::com::sun::star::drawing::XShape > & xShape) const;
 
-	void setShapePresetType( const rtl::OUString& rShapePresetType ){ maShapePresetType = rShapePresetType; };
-	std::vector< CustomShapeGuide >& getAdjustmentValues(){ return maAdjustmentValues; };
+	void setShapePresetType( const rtl::OUString& rShapePresetType ){ maShapePresetType = rShapePresetType; }
+	const rtl::OUString& getShapePresetType() const { return maShapePresetType; }
+	std::vector< CustomShapeGuide >& getAdjustmentValues(){ return maAdjustmentValues; }
 
 	double getValue( const std::vector< CustomShapeGuide >&, sal_uInt32 nIndex ) const;
 
diff --git oox/inc/oox/drawingml/diagram/datamodelcontext.hxx oox/inc/oox/drawingml/diagram/datamodelcontext.hxx
deleted file mode 100644
index 9cbeb96..0000000
--- oox/inc/oox/drawingml/diagram/datamodelcontext.hxx
+++ /dev/null
@@ -1,57 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: datamodelcontext.hxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-
-#ifndef OOX_DRAWINGML_SHAPECONTEXT_HXX
-#define OOX_DRAWINGML_SHAPECONTEXT_HXX
-
-#include <com/sun/star/drawing/XShapes.hpp>
-
-#include "oox/core/contexthandler.hxx"
-#include "oox/drawingml/diagram/diagram.hxx"
-
-namespace oox { namespace drawingml {
-
-// CT_DataModel
-class DataModelContext : public ::oox::core::ContextHandler
-{
-public:
-    DataModelContext( ::oox::core::ContextHandler& rParent, const DiagramDataPtr & pDataModelPtr );
-	virtual ~DataModelContext();
-
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-
-protected:
-    DiagramDataPtr mpDataModel;
-};
-
-} }
-
-#endif  //  OOX_DRAWINGML_SHAPEGROUPCONTEXT_HXX
diff --git oox/inc/oox/drawingml/diagram/diagram.hxx oox/inc/oox/drawingml/diagram/diagram.hxx
index b1c2ddd..732959b 100644
--- oox/inc/oox/drawingml/diagram/diagram.hxx
+++ oox/inc/oox/drawingml/diagram/diagram.hxx
@@ -28,232 +28,40 @@
  *
  ************************************************************************/
 
-
-
 #ifndef OOX_DRAWINGML_DIAGRAM_HXX
 #define OOX_DRAWINGML_DIAGRAM_HXX
 
-#include <vector>
-#include <boost/shared_ptr.hpp>
-#include <boost/enable_shared_from_this.hpp>
+#include <rtl/ustring.hxx>
 #include "oox/drawingml/shape.hxx"
-#include "oox/drawingml/diagram/diagramlayoutatoms.hxx"
-
-namespace oox { namespace drawingml {
-
-namespace dgm {
+#include "oox/core/xmlfilterbase.hxx"
 
-/** A Connection
- */
-class Connection
-{
-public:
-	Connection()
-		: mnType( 0 )
-		, mnSourceOrder( 0 )
-		, mnDestOrder( 0 )
-		{
-		}
+#include <com/sun/star/xml/dom/XDocument.hpp>
 
-	void dump();
-
-	sal_Int32 mnType;
-	::rtl::OUString msModelId;
-	::rtl::OUString msSourceId;
-	::rtl::OUString msDestId;
-	::rtl::OUString msParTransId;
-	::rtl::OUString msPresId;
-	::rtl::OUString msSibTransId;
-	sal_Int32 mnSourceOrder;
-	sal_Int32 mnDestOrder;
-
-};
-
-typedef boost::shared_ptr< Connection > ConnectionPtr;
-typedef std::vector< ConnectionPtr > Connections;
+namespace oox { namespace drawingml {
 
-class Point;
+/** load diagram data, and put resulting graphic into shape
 
-typedef boost::shared_ptr< Point > PointPtr;
-typedef std::vector< PointPtr >      Points;
-/** A point
+    This method loads the diagram data fragments from the given paths,
+    generate and layout the shapes, and push it as children into the
+    referenced shape.
  */
-class Point
-{
-public:
-	Point();
-	ShapePtr & getShape( )
-		{ return mpShape; }
-
-	void setCnxId( const ::rtl::OUString & sCnxId )
-		{ msCnxId = sCnxId; }
-	void setModelId( const ::rtl::OUString & sModelId );
-	const ::rtl::OUString & getModelId() const
-		{ return msModelId; }
-	void setType( const sal_Int32 nType )
-		{ mnType = nType; }
-	sal_Int32 getType() const
-		{ return mnType; }
-
-	void dump();
-private:
-	ShapePtr        mpShape;
-	::rtl::OUString msCnxId;
-	::rtl::OUString msModelId;
-	sal_Int32       mnType;
-};
-
-
-class PointsTree;
-typedef boost::shared_ptr< PointsTree > PointsTreePtr;
-
-/** a points tree node */
-class PointsTree
-	: public boost::enable_shared_from_this< PointsTree >
-{
-public:
-	typedef std::vector< PointsTreePtr > Childrens;
-	PointsTree()
-		{};
-	PointsTree( const PointPtr & pPoint )
-		: mpNode( pPoint )
-		{ }
-	bool addChild( const PointsTreePtr & pChild );
-	const PointPtr & getPoint() const
-		{ return mpNode; }
-	PointsTreePtr getParent() const;
-	Childrens::const_iterator beginChild() const
-		{ return maChildrens.begin(); }
-	Childrens::const_iterator endChild() const
-		{ return maChildrens.end(); }
-private:
-	PointPtr                           mpNode;
-	boost::weak_ptr< PointsTree >      mpParent;
-	Childrens       maChildrens;
-};
-
-}
-
-////////////////////
-
-class DiagramData
-{
-public:
-
-	DiagramData();
-	FillPropertiesPtr & getFillProperties()
-		{ return mpFillProperties; }
-	dgm::Connections & getConnections()
-		{ return maConnections; }
-	dgm::Points & getPoints()
-		{ return maPoints; }
-	void dump();
-private:
-	FillPropertiesPtr   mpFillProperties;
-	dgm::Connections    maConnections;
-	dgm::Points         maPoints;
-};
-
-typedef boost::shared_ptr< DiagramData > DiagramDataPtr;
-
-
-
-////////////////////
-
-class DiagramLayout
-{
-public:
-	void setDefStyle( const ::rtl::OUString & sDefStyle )
-		{ msDefStyle = sDefStyle; }
-	void setMinVer( const ::rtl::OUString & sMinVer )
-		{ msMinVer = sMinVer; }
-	void setUniqueId( const ::rtl::OUString & sUniqueId )
-		{ msUniqueId = sUniqueId; }
-	const ::rtl::OUString & getUniqueId()
-		{ return msUniqueId; }
-	void setTitle( const ::rtl::OUString & sTitle )
-		{ msTitle = sTitle; }
-	void setDesc( const ::rtl::OUString & sDesc )
-		{ msDesc = sDesc; }
-
-	LayoutNodePtr & getNode()
-		{ return mpNode; }
-	const LayoutNodePtr & getNode() const
-		{ return mpNode; }
-	DiagramDataPtr & getSampData()
-		{ return mpSampData; }
-	const DiagramDataPtr & getSampData() const
-		{ return mpSampData; }
-	DiagramDataPtr & getStyleData()
-		{ return mpStyleData; }
-	const DiagramDataPtr & getStyleData() const
-		{ return mpStyleData; }
-
-	void layout( const dgm::PointsTreePtr & pTree, const com::sun::star::awt::Point & pt );
-private:
-	::rtl::OUString msDefStyle;
-	::rtl::OUString msMinVer;
-	::rtl::OUString msUniqueId;
-
-	::rtl::OUString msTitle;
-	::rtl::OUString msDesc;
-	LayoutNodePtr  mpNode;
-	DiagramDataPtr mpSampData;
-	DiagramDataPtr mpStyleData;
-	// TODO
-	// catLst
-	// clrData
-};
-
-typedef boost::shared_ptr< DiagramLayout > DiagramLayoutPtr;
-
-///////////////////////
-
-class DiagramQStyles
-{
-
-};
-
-typedef boost::shared_ptr< DiagramQStyles > DiagramQStylesPtr;
-
-///////////////////////
-
-class DiagramColors
-{
-
-};
-
-typedef boost::shared_ptr< DiagramColors > DiagramColorsPtr;
-
-///////////////////////
-
-class Diagram
-{
-public:
-	void setData( const DiagramDataPtr & );
-	void setLayout( const DiagramLayoutPtr & );
-	DiagramLayoutPtr getLayout() const
-		{
-			return mpLayout;
-		}
-	void setQStyles( const DiagramQStylesPtr & );
-	void setColors( const DiagramColorsPtr & );
-
-	void addTo( const ShapePtr & pShape );
-	::rtl::OUString getLayoutId() const;
-private:
-	void build( );
-	DiagramDataPtr    mpData;
-	DiagramLayoutPtr  mpLayout;
-	DiagramQStylesPtr mpQStyles;
-	DiagramColorsPtr  mpColors;
-	std::map< ::rtl::OUString, ShapePtr > maShapeMap;
-	dgm::PointsTreePtr  mpRoot;
-};
-
-
-typedef boost::shared_ptr< Diagram > DiagramPtr;
-
+void loadDiagram( const ShapePtr& pShape,
+                  core::XmlFilterBase& rFilter,
+                  const ::rtl::OUString& rDataModelPath,
+                  const ::rtl::OUString& rLayoutPath,
+                  const ::rtl::OUString& rQStylePath,
+                  const ::rtl::OUString& rColorStylePath );
+
+void loadDiagram( const ShapePtr& pShape,
+                  core::XmlFilterBase& rFilter,
+                  const ::com::sun::star::uno::Reference<
+                     ::com::sun::star::xml::dom::XDocument>& rXDataModelDom,
+                  const ::com::sun::star::uno::Reference<
+                     ::com::sun::star::xml::dom::XDocument>& rXLayoutDom,
+                  const ::com::sun::star::uno::Reference<
+                     ::com::sun::star::xml::dom::XDocument>& rXQStyleDom,
+                  const ::com::sun::star::uno::Reference<
+                     ::com::sun::star::xml::dom::XDocument>& rXColorStyleDom );
 } }
 
 #endif
diff --git oox/inc/oox/drawingml/diagram/diagramfragmenthandler.hxx oox/inc/oox/drawingml/diagram/diagramfragmenthandler.hxx
deleted file mode 100644
index 278dfe5..0000000
--- oox/inc/oox/drawingml/diagram/diagramfragmenthandler.hxx
+++ /dev/null
@@ -1,103 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: diagramfragmenthandler.hxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-
-#ifndef OOX_DRAWINGML_DIAGRAMFRAGMENTHANDLER
-#define OOX_DRAWINGML_DIAGRAMFRAGMENTHANDLER
-
-#include "oox/core/fragmenthandler.hxx"
-#include "oox/drawingml/diagram/diagram.hxx"
-
-namespace oox { namespace drawingml {
-
-
-class DiagramDataFragmentHandler : public ::oox::core::FragmentHandler
-{
-public:
-    DiagramDataFragmentHandler( oox::core::XmlFilterBase& rFilter, const ::rtl::OUString& rFragmentPath, const DiagramDataPtr pDataPtr ) throw();
-	virtual ~DiagramDataFragmentHandler() throw();
-
-    virtual void SAL_CALL endDocument() throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-
-private:
-
-	DiagramDataPtr	mpDataPtr;
-};
-
-
-
-class DiagramLayoutFragmentHandler : public ::oox::core::FragmentHandler
-{
-public:
-    DiagramLayoutFragmentHandler( oox::core::XmlFilterBase& rFilter, const ::rtl::OUString& rFragmentPath, const DiagramLayoutPtr pDataPtr ) throw();
-	virtual ~DiagramLayoutFragmentHandler() throw();
-
-    virtual void SAL_CALL endDocument() throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-
-private:
-
-	DiagramLayoutPtr	mpDataPtr;
-};
-
-class DiagramQStylesFragmentHandler : public ::oox::core::FragmentHandler
-{
-public:
-    DiagramQStylesFragmentHandler( oox::core::XmlFilterBase& rFilter, const ::rtl::OUString& rFragmentPath, const DiagramQStylesPtr pDataPtr ) throw();
-	virtual ~DiagramQStylesFragmentHandler() throw();
-
-    virtual void SAL_CALL endDocument() throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-
-private:
-
-	DiagramQStylesPtr	mpDataPtr;
-};
-
-
-class DiagramColorsFragmentHandler : public ::oox::core::FragmentHandler
-{
-public:
-    DiagramColorsFragmentHandler( ::oox::core::XmlFilterBase& rFilter, const ::rtl::OUString& rFragmentPath, const DiagramColorsPtr pDataPtr ) throw();
-	virtual ~DiagramColorsFragmentHandler() throw();
-
-    virtual void SAL_CALL endDocument() throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
-
-private:
-
-	DiagramColorsPtr	mpDataPtr;
-};
-
-} }
-
-
-#endif
diff --git oox/inc/oox/drawingml/diagram/diagramlayoutatoms.hxx oox/inc/oox/drawingml/diagram/diagramlayoutatoms.hxx
deleted file mode 100644
index 80c2dcd..0000000
--- oox/inc/oox/drawingml/diagram/diagramlayoutatoms.hxx
+++ /dev/null
@@ -1,212 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: diagramlayoutatoms.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-
-
-
-
-#ifndef OOX_DRAWINGML_DIAGRAMLAYOUTATOMS_HXX
-#define OOX_DRAWINGML_DIAGRAMLAYOUTATOMS_HXX
-
-#include <map>
-#include <string>
-
-#include <boost/shared_ptr.hpp>
-#include <boost/array.hpp>
-
-#include <com/sun/star/uno/Any.hxx>
-#include <com/sun/star/xml/sax/XFastAttributeList.hpp>
-
-#include "oox/drawingml/shape.hxx"
-
-
-namespace oox { namespace drawingml {
-
-
-// AG_IteratorAttributes
-class IteratorAttr
-{
-public:
-	IteratorAttr();
-
-	// not sure this belong here, but wth
-	void loadFromXAttr( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes );
-
-private:
-	sal_Int32 mnAxis;
-	sal_Int32 mnCnt;
-	sal_Bool  mbHideLastTrans;
-	sal_Int32 mnPtType;
-	sal_Int32 mnSt;
-	sal_Int32 mnStep;
-};
-
-class ConditionAttr
-{
-public:
-	ConditionAttr();
-
-	// not sure this belong here, but wth
-	void loadFromXAttr( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes );
-
-private:
-	sal_Int32 mnFunc;
-	sal_Int32 mnArg;
-	sal_Int32 mnOp;
-	::rtl::OUString msVal;
-};
-
-class LayoutAtom;
-
-typedef boost::shared_ptr< LayoutAtom > LayoutAtomPtr;
-
-/** abstract Atom for the layout */
-class LayoutAtom
-{
-public:
-	virtual ~LayoutAtom()
-		{}
-	// TODO change signature to the proper one
-	virtual void processAtom() = 0;
-	void setName( const ::rtl::OUString & sName )
-		{ msName = sName; }
-	void addChild( const LayoutAtomPtr & pNode )
-		{ mpChildNodes.push_back( pNode ); }
-
-	// dump for debug
-	virtual void dump(int level = 0);
-protected:
-	std::vector< LayoutAtomPtr > mpChildNodes;
-	::rtl::OUString msName;
-};
-
-class AlgAtom
-	: public LayoutAtom
-{
-public:
-	virtual ~AlgAtom()
-		{}
-	typedef std::map< std::string, ::com::sun::star::uno::Any > ParamMap;
-
-	virtual void processAtom()
-		{}
-private:
-	ParamMap mParams;
-};
-
-
-class ForEachAtom
-	: public LayoutAtom
-{
-public:
-	virtual ~ForEachAtom()
-		{}
-	
-	IteratorAttr & iterator()
-		{ return maIter; }
-	virtual void processAtom();
-private:
-	IteratorAttr maIter;
-};
-
-typedef boost::shared_ptr< ForEachAtom > ForEachAtomPtr;
-
-
-class ConditionAtom
-	: public LayoutAtom
-{
-public:
-	ConditionAtom( bool bElse = false )
-		: LayoutAtom( )
-		, mbElse( bElse )
-		{}
-	virtual ~ConditionAtom()
-		{}
-	bool test();
-	virtual void processAtom()
-		{}
-	IteratorAttr & iterator()
-		{ return maIter; }
-	ConditionAttr & cond()
-		{ return maCond; }
-private:
-	bool          mbElse;
-	IteratorAttr  maIter;
-	ConditionAttr maCond;
-};
-
-typedef boost::shared_ptr< ConditionAtom > ConditionAtomPtr;
-
-
-/** "choose" statements. Atoms will be tested in order. */
-class ChooseAtom
-	: public LayoutAtom
-{
-public:
-	virtual ~ChooseAtom()
-		{}
-	virtual void processAtom();
-};
-
-class LayoutNode
-	: public LayoutAtom
-{
-public:
-	enum {
-		VAR_animLvl = 0,
-		VAR_animOne,
-		VAR_bulletEnabled,
-		VAR_chMax,
-		VAR_chPref,
-		VAR_dir,
-		VAR_hierBranch,
-		VAR_orgChart,
-		VAR_resizeHandles
-	};
-	// we know that the array is of fixed size
-	// the use of Any allow having empty values
-	typedef boost::array< ::com::sun::star::uno::Any, 9 > VarMap;
-
-	virtual ~LayoutNode()
-		{}
-	virtual void processAtom()
-		{}
-	VarMap & variables()
-		{ return mVariables; }
-private:
-	VarMap                       mVariables;
-	std::vector< ShapePtr >      mpShapes;
-};
-
-typedef boost::shared_ptr< LayoutNode > LayoutNodePtr;
-
-} }
-
-#endif
diff --git oox/inc/oox/drawingml/drawingmltypes.hxx oox/inc/oox/drawingml/drawingmltypes.hxx
index 7c8174d..16c404b 100644
--- oox/inc/oox/drawingml/drawingmltypes.hxx
+++ oox/inc/oox/drawingml/drawingmltypes.hxx
@@ -49,6 +49,9 @@ typedef ::boost::shared_ptr< LineProperties > LinePropertiesPtr;
 struct FillProperties;
 typedef ::boost::shared_ptr< FillProperties > FillPropertiesPtr;
 
+struct Shape3DProperties;
+typedef ::boost::shared_ptr< Shape3DProperties > Shape3DPropertiesPtr;
+
 struct TextCharacterProperties;
 typedef ::boost::shared_ptr< TextCharacterProperties > TextCharacterPropertiesPtr;
 
diff --git oox/inc/oox/drawingml/graphicshapecontext.hxx oox/inc/oox/drawingml/graphicshapecontext.hxx
index 74ef1a8..5ae1715 100644
--- oox/inc/oox/drawingml/graphicshapecontext.hxx
+++ oox/inc/oox/drawingml/graphicshapecontext.hxx
@@ -33,7 +33,6 @@
 
 #include "oox/drawingml/shape.hxx"
 #include "oox/drawingml/shapecontext.hxx"
-#include "oox/drawingml/diagram/diagram.hxx"
 
 namespace oox { namespace drawingml {
 
@@ -78,6 +77,8 @@ private:
 
 // ====================================================================
 
+class Diagram;
+
 class DiagramGraphicDataContext
 	: public ShapeContext
 {
@@ -87,8 +88,6 @@ public:
 	virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
 
 private:
-	DiagramPtr loadDiagram();
-
 	::rtl::OUString msDm;
 	::rtl::OUString msLo;
 	::rtl::OUString msQs;
diff --git oox/inc/oox/drawingml/scene3dcontext.hxx oox/inc/oox/drawingml/scene3dcontext.hxx
new file mode 100644
index 0000000..840075a
--- /dev/null
+++ oox/inc/oox/drawingml/scene3dcontext.hxx
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: fillpropertiesgroupcontext.hxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_DRAWINGML_SCENE3DPROPERTIESCONTEXT_HPP
+#define OOX_DRAWINGML_SCENE3DPROPERTIESCONTEXT_HPP
+
+#include "oox/core/contexthandler.hxx"
+
+namespace oox { namespace drawingml {
+
+struct Shape3DProperties;
+
+// ---------------------------------------------------------------------
+
+class Scene3DPropertiesContext : public ::oox::core::ContextHandler
+{
+public:
+    Scene3DPropertiesContext( ::oox::core::ContextHandler& rParent, Shape3DProperties& r3DProperties ) throw();
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs )
+			throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException );
+
+private:
+	Shape3DProperties& mr3DProperties;
+};
+
+} }
+
+#endif // OOX_DRAWINGML_SCENE3DPROPERTIESCONTEXT_HPP
diff --git oox/inc/oox/drawingml/shape.hxx oox/inc/oox/drawingml/shape.hxx
index 5a7e7e5..5e945da 100644
--- oox/inc/oox/drawingml/shape.hxx
+++ oox/inc/oox/drawingml/shape.hxx
@@ -35,6 +35,7 @@
 #include "oox/drawingml/drawingmltypes.hxx"
 #include "oox/drawingml/customshapeproperties.hxx"
 #include "oox/drawingml/textliststyle.hxx"
+#include "oox/drawingml/shape3dproperties.hxx"
 
 #include <com/sun/star/frame/XModel.hpp>
 #include <com/sun/star/drawing/XDrawPage.hpp>
@@ -80,7 +81,8 @@ class Shape
 {
 public:
 
-    Shape( const sal_Char* pServiceType = NULL );
+    explicit Shape( const sal_Char* pServiceType = NULL );
+    explicit Shape( const ShapePtr& pSourceShape );
     virtual ~Shape();
 
     rtl::OUString&                  getServiceName(){ return msServiceName; }
@@ -97,10 +99,17 @@ public:
     FillPropertiesPtr               getGraphicProperties() { return mpGraphicPropertiesPtr; }
     CustomShapePropertiesPtr        getCustomShapeProperties(){ return mpCustomShapePropertiesPtr; }
 
+    Shape3DProperties&              get3DProperties() { return *mp3DPropertiesPtr; }
+    const Shape3DProperties&        get3DProperties() const { return *mp3DPropertiesPtr; }
+
 	table::TablePropertiesPtr		getTableProperties();
 
-    void                            setPosition( com::sun::star::awt::Point nPosition ){ maPosition = nPosition; }
-    void                            setSize( com::sun::star::awt::Size aSize ){ maSize = aSize; }
+    void                              setPosition( com::sun::star::awt::Point nPosition ){ maPosition = nPosition; }
+    const com::sun::star::awt::Point& getPosition() const { return maPosition; }
+
+    void                              setSize( com::sun::star::awt::Size aSize ){ maSize = aSize; }
+    const com::sun::star::awt::Size&  getSize() const { return maSize; }
+
     void                            setRotation( sal_Int32 nRotation ) { mnRotation = nRotation; }
     void                            setFlip( sal_Bool bFlipH, sal_Bool bFlipV ) { mbFlipH = bFlipH; mbFlipV = bFlipV; }
     void                            addChild( const ShapePtr pChildPtr ) { maChildren.push_back( pChildPtr ); }
@@ -135,6 +144,13 @@ public:
                             const ::com::sun::star::awt::Rectangle* pShapeRect = 0,
                             ShapeIdMap* pShapeMap = 0 );
 
+    void                addChildren(
+                            const ::oox::core::XmlFilterBase& rFilterBase,
+                            const ThemePtr& rxTheme,
+                            const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
+                            const ::com::sun::star::awt::Rectangle* pShapeRect = 0,
+                            ShapeIdMap* pShapeMap = 0 );
+
     void				setXShape( const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >& rXShape )
 							{ mxShape = rXShape; };
     const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > &
@@ -167,6 +183,7 @@ protected:
     FillPropertiesPtr           mpGraphicPropertiesPtr;
     CustomShapePropertiesPtr    mpCustomShapePropertiesPtr;
 	table::TablePropertiesPtr	mpTablePropertiesPtr;
+    Shape3DPropertiesPtr        mp3DPropertiesPtr;
     PropertyMap                 maShapeProperties;
     TextListStylePtr            mpMasterTextListStyle;
     ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > mxShape;
@@ -189,7 +206,11 @@ private:
     sal_Bool                        mbFlipV;
 };
 
-::rtl::OUString GetShapeType( sal_Int32 nType );
+// ---------------------------------------------------------------------
+
+/** Get custom shape preset string from xml token id
+ */
+::rtl::OUString GetShapePresetType( sal_Int32 nType );
 
 } }
 
diff --git oox/inc/oox/drawingml/shape3dproperties.hxx oox/inc/oox/drawingml/shape3dproperties.hxx
new file mode 100644
index 0000000..a46ff19
--- /dev/null
+++ oox/inc/oox/drawingml/shape3dproperties.hxx
@@ -0,0 +1,134 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: fillproperties.hxx,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_DRAWINGML_SHAPE3DPROPERTIES_HXX
+#define OOX_DRAWINGML_SHAPE3DPROPERTIES_HXX
+
+#include <map>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/geometry/IntegerRectangle2D.hpp>
+#include "oox/drawingml/color.hxx"
+#include "oox/helper/helper.hxx"
+
+namespace oox { class PropertyMap; }
+namespace oox { class PropertySet; }
+namespace oox { namespace core { class ModelObjectContainer; } }
+
+namespace oox {
+namespace drawingml {
+
+// ============================================================================
+
+struct Shape3DPropertyNames
+{
+    ::rtl::OUString     maFillStyle;
+    ::rtl::OUString     maFillColor;
+    ::rtl::OUString     maFillTransparence;
+    ::rtl::OUString     maFillGradient;
+    ::rtl::OUString     maFillBitmap;
+    ::rtl::OUString     maFillBitmapMode;
+    ::rtl::OUString     maFillBitmapTile;
+    ::rtl::OUString     maFillBitmapStretch;
+    ::rtl::OUString     maFillBitmapLogicalSize;
+    ::rtl::OUString     maFillBitmapSizeX;
+    ::rtl::OUString     maFillBitmapSizeY;
+    ::rtl::OUString     maFillBitmapOffsetX;
+    ::rtl::OUString     maFillBitmapOffsetY;
+    ::rtl::OUString     maFillBitmapRectanglePoint;
+    bool                mbNamedFillGradient;
+    bool                mbNamedFillBitmap;
+    bool                mbTransformGraphic;
+
+    Shape3DPropertyNames();
+};
+
+// ============================================================================
+
+struct Shape3DProperties
+{
+    typedef ::std::map< double, Color > GradientStopMap;
+
+    OptValue< sal_Int32 > moFillType;           /// Fill type (OOXML token).
+    OptValue< bool >    moRotateWithShape;      /// True = rotate gradient/bitmap with shape.
+    Color               maFillColor;            /// Solid fill color and transparence.
+    GradientStopMap     maGradientStops;        /// Gradient stops (colors/transparence).
+    OptValue< sal_Int32 > moGradientPath;       /// If set, gradient follows rectangle, circle, or shape.
+    OptValue< sal_Int32 > moShadeAngle;         /// Rotation angle of linear gradients.
+    OptValue< bool >    moShadeScaled;
+    OptValue< sal_Int32 > moFlipModeToken;
+    OptValue< com::sun::star::geometry::IntegerRectangle2D > moFillToRect;
+    OptValue< com::sun::star::geometry::IntegerRectangle2D > moTileRect;
+    OptValue< sal_Int32 > moPattPreset;         /// Preset pattern type.
+    Color               maPattFgColor;          /// Pattern foreground color.
+    Color               maPattBgColor;          /// Pattern background color.
+    ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphic > mxGraphic;
+    Color               maColorChangeFrom;      /// Start color of color transformation.
+    Color               maColorChangeTo;        /// Destination color of color transformation.
+    OptValue< sal_Int32 > moBitmapMode;         /// Bitmap tile or stretch.
+    OptValue< sal_Int32 > moTileX;              /// Width of bitmap tiles.
+    OptValue< sal_Int32 > moTileY;              /// Height of bitmap tiles.
+    OptValue< sal_Int32 > moTileSX;
+    OptValue< sal_Int32 > moTileSY;
+    OptValue< sal_Int32 > moTileAlign;          /// Anchor point inside bitmap.
+
+    static Shape3DPropertyNames DEFAULTNAMES;      /// Default fill property names for shape fill.
+    static Shape3DPropertyNames DEFAULTPICNAMES;   /// Default fill property names for pictures.
+
+    /** Overwrites all members that are explicitly set in rSourceProps. */
+    void                assignUsed( const Shape3DProperties& rSourceProps );
+
+    /** Tries to resolve current settings to a solid color, e.g. returns the
+        start color of a gradient. */
+    Color               getBestSolidColor() const;
+
+    /** Writes the properties to the passed property map. */
+    void                pushToPropMap(
+                            PropertyMap& rPropMap,
+                            const Shape3DPropertyNames& rPropNames,
+                            const ::oox::core::XmlFilterBase& rFilter,
+                            ::oox::core::ModelObjectContainer& rObjContainer,
+                            sal_Int32 nShapeRotation, sal_Int32 nPhClr ) const;
+
+    /** Writes the properties to the passed property set. */
+    void                pushToPropSet(
+                            PropertySet& rPropSet,
+                            const Shape3DPropertyNames& rPropNames,
+                            const ::oox::core::XmlFilterBase& rFilter,
+                            ::oox::core::ModelObjectContainer& rObjContainer,
+                            sal_Int32 nShapeRotation, sal_Int32 nPhClr ) const;
+};
+
+// ============================================================================
+
+} // namespace drawingml
+} // namespace oox
+
+#endif
+
diff --git oox/inc/oox/drawingml/theme.hxx oox/inc/oox/drawingml/theme.hxx
index 17f23e5..2f34a33 100644
--- oox/inc/oox/drawingml/theme.hxx
+++ oox/inc/oox/drawingml/theme.hxx
@@ -35,6 +35,7 @@
 #include "oox/drawingml/clrscheme.hxx"
 #include "oox/drawingml/shape.hxx"
 #include "oox/drawingml/textfont.hxx"
+#include <com/sun/star/xml/dom/XDocument.hpp>
 
 namespace oox {
 namespace drawingml {
@@ -97,6 +98,11 @@ public:
     inline Shape&                   getTxDef() { return maTxDef; }
     inline const Shape&             getTxDef() const { return maTxDef; }
 
+    void                            setFragment( const ::com::sun::star::uno::Reference<
+                                                    ::com::sun::star::xml::dom::XDocument>& xRef ) { mxFragment=xRef; }
+    const ::com::sun::star::uno::Reference<
+        ::com::sun::star::xml::dom::XDocument>& getFragment() const { return mxFragment; }
+
 private:
     ::rtl::OUString     maStyleName;
     ClrScheme           maClrScheme;
@@ -108,6 +114,8 @@ private:
     Shape               maSpDef;
     Shape               maLnDef;
     Shape               maTxDef;
+    ::com::sun::star::uno::Reference<
+        ::com::sun::star::xml::dom::XDocument> mxFragment;
 };
 
 // ============================================================================
diff --git oox/inc/oox/ppt/dgmimport.hxx oox/inc/oox/ppt/dgmimport.hxx
new file mode 100644
index 0000000..bfb2f38
--- /dev/null
+++ oox/inc/oox/ppt/dgmimport.hxx
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptimport.hxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_POWERPOINT_QUICKDIAGRAMMINGIMPORT_HXX
+#define OOX_POWERPOINT_QUICKDIAGRAMMINGIMPORT_HXX
+
+#include "oox/core/xmlfilterbase.hxx"
+
+#include <com/sun/star/animations/XAnimationNode.hpp>
+#include <oox/drawingml/theme.hxx>
+#include "oox/ppt/presentationfragmenthandler.hxx"
+#include "oox/ppt/slidepersist.hxx"
+#include "tokens.hxx"
+#include <vector>
+#include <map>
+
+namespace oox { namespace ppt {
+
+// ---------------------------------------------------------------------
+
+class QuickDiagrammingImport : public oox::core::XmlFilterBase
+{
+public:
+
+	QuickDiagrammingImport( const com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > & rSMgr  );
+
+    // from FilterBase
+    virtual bool importDocument() throw();
+    virtual bool exportDocument() throw();
+
+    virtual const ::oox::drawingml::Theme* getCurrentTheme() const;
+    virtual sal_Int32 getSchemeClr( sal_Int32 nColorSchemeToken ) const;
+	virtual const oox::drawingml::table::TableStyleListPtr getTableStyles();
+
+private:
+    virtual ::rtl::OUString implGetImplementationName() const;
+};
+
+} }
+
+#endif // OOX_POWERPOINT_QUICKDIAGRAMMINGIMPORT_HXX
diff --git oox/inc/oox/ppt/dgmlayout.hxx oox/inc/oox/ppt/dgmlayout.hxx
new file mode 100644
index 0000000..d597ef4
--- /dev/null
+++ oox/inc/oox/ppt/dgmlayout.hxx
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptimport.hxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_POWERPOINT_QUICKDIAGRAMMINGLAYOUT_HXX
+#define OOX_POWERPOINT_QUICKDIAGRAMMINGLAYOUT_HXX
+
+#include "oox/core/xmlfilterbase.hxx"
+
+#include <com/sun/star/animations/XAnimationNode.hpp>
+#include <oox/drawingml/theme.hxx>
+#include "oox/ppt/presentationfragmenthandler.hxx"
+#include "oox/ppt/slidepersist.hxx"
+#include "tokens.hxx"
+#include <vector>
+#include <map>
+
+namespace oox { namespace ppt {
+
+// ---------------------------------------------------------------------
+
+class QuickDiagrammingLayout : public oox::core::XmlFilterBase
+{
+public:
+
+	QuickDiagrammingLayout( const com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > & rSMgr  );
+
+    // from FilterBase
+    virtual bool importDocument() throw();
+    virtual bool exportDocument() throw();
+
+    virtual const ::oox::drawingml::Theme* getCurrentTheme() const;
+    virtual sal_Int32 getSchemeClr( sal_Int32 nColorSchemeToken ) const;
+	virtual const oox::drawingml::table::TableStyleListPtr getTableStyles();
+
+private:
+    virtual ::rtl::OUString implGetImplementationName() const;
+    drawingml::ThemePtr mpThemePtr;
+};
+
+} }
+
+#endif // OOX_POWERPOINT_QUICKDIAGRAMMINGLAYOUT_HXX
diff --git oox/inc/oox/ppt/pptimport.hxx oox/inc/oox/ppt/pptimport.hxx
index 6d4fd19..694b5f9 100644
--- oox/inc/oox/ppt/pptimport.hxx
+++ oox/inc/oox/ppt/pptimport.hxx
@@ -62,7 +62,7 @@ public:
 
 	virtual const oox::vml::DrawingPtr getDrawings();
 	virtual const oox::drawingml::table::TableStyleListPtr getTableStyles();
-    virtual ::oox::drawingml::chart::ChartConverter& getChartConverter();
+    virtual ::oox::drawingml::chart::ChartConverter* getChartConverter();
 
 	void													setActualSlidePersist( SlidePersistPtr pActualSlidePersist ){ mpActualSlidePersist = pActualSlidePersist; };
 	std::map< rtl::OUString, oox::drawingml::ThemePtr >&	getThemes(){ return maThemes; };
diff --git oox/inc/oox/xls/excelfilter.hxx oox/inc/oox/xls/excelfilter.hxx
index 4ed3418..ad812ce 100644
--- oox/inc/oox/xls/excelfilter.hxx
+++ oox/inc/oox/xls/excelfilter.hxx
@@ -56,7 +56,7 @@ public:
 
 	virtual const ::oox::vml::DrawingPtr getDrawings();
 	virtual const ::oox::drawingml::table::TableStyleListPtr getTableStyles();
-    virtual ::oox::drawingml::chart::ChartConverter& getChartConverter();
+    virtual ::oox::drawingml::chart::ChartConverter* getChartConverter();
 
 private:
     virtual ::rtl::OUString implGetImplementationName() const;
diff --git oox/inc/oox/xls/workbookhelper.hxx oox/inc/oox/xls/workbookhelper.hxx
index e9f5ed9..11120a9 100644
--- oox/inc/oox/xls/workbookhelper.hxx
+++ oox/inc/oox/xls/workbookhelper.hxx
@@ -231,7 +231,7 @@ public:
     /** Returns the converter for string to cell address/range conversion. */
     AddressConverter&   getAddressConverter() const;
     /** Returns the chart object converter. */
-    ExcelChartConverter& getChartConverter() const;
+    ExcelChartConverter* getChartConverter() const;
 
     // property helpers -------------------------------------------------------
 
diff --git oox/source/core/facreg.cxx oox/source/core/facreg.cxx
index 9ff1951..3dcb93c 100644
--- oox/source/core/facreg.cxx
+++ oox/source/core/facreg.cxx
@@ -60,6 +60,8 @@ extern uno::Reference< uno::XInterface > SAL_CALL className##_createInstance(
 namespace oox {
     namespace core { SERVICE( FilterDetect ); }
     namespace ppt { SERVICE( PowerPointImport ); }
+    namespace ppt { SERVICE( QuickDiagrammingImport ); }
+    namespace ppt { SERVICE( QuickDiagrammingLayout ); }
     namespace xls { SERVICE( BiffDetector ); }
     namespace xls { SERVICE( ExcelFilter ); }
     namespace xls { SERVICE( ExcelBiffFilter ); }
@@ -102,6 +104,8 @@ OOX_DLLPUBLIC sal_Bool SAL_CALL component_writeInfo( void * , void * pRegistryKe
 
             WRITEINFO( ::oox::core::FilterDetect );
 			WRITEINFO( ::oox::ppt::PowerPointImport );
+			WRITEINFO( ::oox::ppt::QuickDiagrammingImport );
+			WRITEINFO( ::oox::ppt::QuickDiagrammingLayout );
             WRITEINFO( ::oox::xls::BiffDetector );
             WRITEINFO( ::oox::xls::ExcelFilter );
             WRITEINFO( ::oox::xls::ExcelBiffFilter );
@@ -150,6 +154,8 @@ OOX_DLLPUBLIC void * SAL_CALL component_getFactory( const sal_Char * pImplName,
 		// impress oasis import
         SINGLEFACTORY( ::oox::core::FilterDetect )
         else SINGLEFACTORY( oox::ppt::PowerPointImport )
+        else SINGLEFACTORY( oox::ppt::QuickDiagrammingImport )
+        else SINGLEFACTORY( oox::ppt::QuickDiagrammingLayout )
         else SINGLEFACTORY( ::oox::xls::BiffDetector )
         else SINGLEFACTORY( ::oox::xls::ExcelFilter )
         else SINGLEFACTORY( ::oox::xls::ExcelBiffFilter )
diff --git oox/source/core/filterbase.cxx oox/source/core/filterbase.cxx
index e3babee..37e7128 100644
--- oox/source/core/filterbase.cxx
+++ oox/source/core/filterbase.cxx
@@ -32,6 +32,7 @@
 #include <com/sun/star/frame/XModel.hpp>
 #include <com/sun/star/task/XStatusIndicator.hpp>
 #include <com/sun/star/task/XInteractionHandler.hpp>
+#include <com/sun/star/drawing/XShape.hpp>
 #include <rtl/uri.hxx>
 #include <comphelper/mediadescriptor.hxx>
 
@@ -52,6 +53,7 @@ using ::com::sun::star::io::XOutputStream;
 using ::com::sun::star::io::XStream;
 using ::com::sun::star::task::XStatusIndicator;
 using ::com::sun::star::task::XInteractionHandler;
+using ::com::sun::star::drawing::XShape;
 using ::comphelper::MediaDescriptor;
 
 namespace oox {
@@ -72,6 +74,7 @@ struct FilterBaseImpl
     Reference< XStream >                mxStream;
     Reference< XStatusIndicator >       mxStatusIndicator;
     Reference< XInteractionHandler >    mxInteractionHandler;
+    Reference< XShape >                 mxParentShape;
 
     explicit            FilterBaseImpl( const Reference< XMultiServiceFactory >& rxFactory );
     void                setMediaDescriptor( const Sequence< PropertyValue >& rDescriptor );
@@ -89,14 +92,15 @@ void FilterBaseImpl::setMediaDescriptor( const Sequence< PropertyValue >& rDescr
 {
     maDescriptor = rDescriptor;
 
+    mxStream = maDescriptor.getUnpackedValueOrDefault( MediaDescriptor::PROP_STREAMFOROUTPUT(), mxStream );
+    if( !mxStream.is() )
+        maDescriptor.addInputStream();
+
     maFileUrl = maDescriptor.getUnpackedValueOrDefault( MediaDescriptor::PROP_URL(), maFileUrl );
     mxInStream = maDescriptor.getUnpackedValueOrDefault( MediaDescriptor::PROP_INPUTSTREAM(), mxInStream );
-    mxStream = maDescriptor.getUnpackedValueOrDefault( MediaDescriptor::PROP_STREAMFOROUTPUT(), mxStream );
     mxStatusIndicator = maDescriptor.getUnpackedValueOrDefault( MediaDescriptor::PROP_STATUSINDICATOR(), mxStatusIndicator );
     mxInteractionHandler = maDescriptor.getUnpackedValueOrDefault( MediaDescriptor::PROP_INTERACTIONHANDLER(), mxInteractionHandler );
-
-    if( mxInStream.is() )
-        maDescriptor.addInputStream();
+    mxParentShape = maDescriptor.getUnpackedValueOrDefault( CREATE_OUSTRING( "ParentShape" ), mxParentShape );
 }
 
 // ============================================================================
@@ -137,6 +141,11 @@ const Reference< XModel >& FilterBase::getModel() const
     return mxImpl->mxModel;
 }
 
+const Reference< XShape >& FilterBase::getParentShape() const
+{
+    return mxImpl->mxParentShape;
+}
+
 const Reference< XStatusIndicator >& FilterBase::getStatusIndicator() const
 {
     return mxImpl->mxStatusIndicator;
diff --git oox/source/core/filterdetect.cxx.orig oox/source/core/filterdetect.cxx.orig
new file mode 100644
index 0000000..b0496de
--- /dev/null
+++ oox/source/core/filterdetect.cxx.orig
@@ -0,0 +1,385 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: filterdetect.cxx,v $
+ * $Revision: 1.5.4.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <com/sun/star/document/XExtendedFilterDetection.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/embed/XHierarchicalStorageAccess.hpp>
+
+#include <com/sun/star/xml/sax/XFastDocumentHandler.hpp>
+#include <com/sun/star/xml/sax/XFastContextHandler.hpp>
+#include <com/sun/star/xml/sax/XFastParser.hpp>
+
+#include <comphelper/mediadescriptor.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+#include "oox/helper/attributelist.hxx"
+#include "oox/helper/zipstorage.hxx"
+#include "oox/core/fasttokenhandler.hxx"
+#include "oox/core/namespaces.hxx"
+#include "tokens.hxx"
+
+#include <vector>
+
+using ::rtl::OUString;
+using ::rtl::OString;
+using ::comphelper::MediaDescriptor;
+using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::io;
+using namespace ::com::sun::star::embed;
+using namespace ::com::sun::star::xml::sax;
+
+namespace oox {
+namespace core {
+
+// ============================================================================
+
+/** Document handler specifically designed for detecting OOXML file formats.
+
+    It takes a reference to the filter string object via its constructor, and
+    puts the name of the detected filter to it if it successfully finds one.
+ */
+class FilterDetectDocHandler : public ::cppu::WeakImplHelper1< XFastDocumentHandler >
+{
+public:
+    explicit            FilterDetectDocHandler( OUString& rFilter );
+    virtual             ~FilterDetectDocHandler();
+
+    // XFastDocumentHandler
+    virtual void SAL_CALL startDocument() throw (SAXException, RuntimeException);
+    virtual void SAL_CALL endDocument() throw (SAXException, RuntimeException);
+    virtual void SAL_CALL setDocumentLocator( const Reference< XLocator >& xLocator ) throw (SAXException, RuntimeException);
+
+    // XFastContextHandler
+    virtual void SAL_CALL startFastElement( sal_Int32 nElement, const Reference< XFastAttributeList >& Attribs ) throw (SAXException, RuntimeException);
+    virtual void SAL_CALL startUnknownElement( const OUString& Namespace, const OUString& Name, const Reference< XFastAttributeList >& Attribs ) throw (SAXException, RuntimeException);
+    virtual void SAL_CALL endFastElement( sal_Int32 Element ) throw (SAXException, RuntimeException);
+    virtual void SAL_CALL endUnknownElement( const OUString& Namespace, const OUString& Name ) throw (SAXException, RuntimeException);
+    virtual Reference< XFastContextHandler > SAL_CALL createFastChildContext( sal_Int32 Element, const Reference< XFastAttributeList >& Attribs ) throw (SAXException, RuntimeException);
+    virtual Reference< XFastContextHandler > SAL_CALL createUnknownChildContext( const OUString& Namespace, const OUString& Name, const Reference< XFastAttributeList >& Attribs ) throw (SAXException, RuntimeException);
+    virtual void SAL_CALL characters( const OUString& aChars ) throw (SAXException, RuntimeException);
+    virtual void SAL_CALL ignorableWhitespace( const OUString& aWhitespaces ) throw (SAXException, RuntimeException);
+    virtual void SAL_CALL processingInstruction( const OUString& aTarget, const OUString& aData ) throw (SAXException, RuntimeException);
+
+private:
+    void                parseRelationship( const AttributeList& rAttribs );
+
+    OUString            getFilterNameFromContentType( const OUString& rContentType ) const;
+    void                parseContentTypesDefault( const AttributeList& rAttribs );
+    void                parseContentTypesOverride( const AttributeList& rAttribs );
+
+private:
+    typedef ::std::vector< sal_Int32 > ContextVector;
+
+    OUString&           mrFilter;
+    ContextVector       maContextStack;
+    OUString            maTargetPath;
+};
+
+// ============================================================================
+
+FilterDetectDocHandler::FilterDetectDocHandler( OUString& rFilter ) :
+    mrFilter( rFilter )
+{
+    maContextStack.reserve( 2 );
+}
+
+FilterDetectDocHandler::~FilterDetectDocHandler()
+{
+}
+
+void SAL_CALL FilterDetectDocHandler::startDocument()
+    throw (SAXException, RuntimeException)
+{
+}
+
+void SAL_CALL FilterDetectDocHandler::endDocument()
+    throw (SAXException, RuntimeException)
+{
+}
+
+void SAL_CALL FilterDetectDocHandler::setDocumentLocator( const Reference<XLocator>& /*xLocator*/ )
+    throw (SAXException, RuntimeException)
+{
+}
+
+// ===========================================================================
+
+void SAL_CALL FilterDetectDocHandler::startFastElement(
+        sal_Int32 nElement, const Reference< XFastAttributeList >& rAttribs )
+    throw (SAXException,RuntimeException)
+{
+    AttributeList aAttribs( rAttribs );
+    switch ( nElement )
+    {
+        // cases for _rels/.rels
+        case NMSP_PACKAGE_RELATIONSHIPS|XML_Relationships:
+        break;
+        case NMSP_PACKAGE_RELATIONSHIPS|XML_Relationship:
+            if( !maContextStack.empty() && (maContextStack.back() == (NMSP_PACKAGE_RELATIONSHIPS|XML_Relationships)) )
+                parseRelationship( aAttribs );
+        break;
+
+        // cases for [Content_Types].xml
+        case NMSP_CONTENT_TYPES|XML_Types:
+        break;
+        case NMSP_CONTENT_TYPES|XML_Default:
+            if( !maContextStack.empty() && (maContextStack.back() == (NMSP_CONTENT_TYPES|XML_Types)) )
+                parseContentTypesDefault( aAttribs );
+        break;
+        case NMSP_CONTENT_TYPES|XML_Override:
+            if( !maContextStack.empty() && (maContextStack.back() == (NMSP_CONTENT_TYPES|XML_Types)) )
+                parseContentTypesOverride( aAttribs );
+        break;
+    }
+    maContextStack.push_back( nElement );
+}
+
+void SAL_CALL FilterDetectDocHandler::startUnknownElement(
+    const OUString& /*Namespace*/, const OUString& /*Name*/, const Reference<XFastAttributeList>& /*Attribs*/ )
+    throw (SAXException, RuntimeException)
+{
+}
+
+void SAL_CALL FilterDetectDocHandler::endFastElement( sal_Int32 /*nElement*/ )
+    throw (SAXException, RuntimeException)
+{
+    maContextStack.pop_back();
+}
+
+void SAL_CALL FilterDetectDocHandler::endUnknownElement(
+    const OUString& /*Namespace*/, const OUString& /*Name*/ ) throw (SAXException, RuntimeException)
+{
+}
+
+Reference<XFastContextHandler> SAL_CALL FilterDetectDocHandler::createFastChildContext(
+    sal_Int32 /*Element*/, const Reference<XFastAttributeList>& /*Attribs*/ )
+    throw (SAXException, RuntimeException)
+{
+    return this;
+}
+
+Reference<XFastContextHandler> SAL_CALL FilterDetectDocHandler::createUnknownChildContext(
+    const OUString& /*Namespace*/, const OUString& /*Name*/, const Reference<XFastAttributeList>& /*Attribs*/)
+    throw (SAXException, RuntimeException)
+{
+    return this;
+}
+
+void SAL_CALL FilterDetectDocHandler::characters( const OUString& /*aChars*/ )
+    throw (SAXException, RuntimeException)
+{
+}
+
+void SAL_CALL FilterDetectDocHandler::ignorableWhitespace( const OUString& /*aWhitespaces*/ )
+    throw (SAXException, RuntimeException)
+{
+}
+
+void SAL_CALL FilterDetectDocHandler::processingInstruction(
+    const OUString& /*aTarget*/, const OUString& /*aData*/ )
+    throw (SAXException, RuntimeException)
+{
+}
+
+// ============================================================================
+
+void FilterDetectDocHandler::parseRelationship( const AttributeList& rAttribs )
+{
+    OUString aType = rAttribs.getString( XML_Type, OUString() );
+    if( aType.equalsAscii( "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" ) )
+        maTargetPath = OUString( sal_Unicode( '/' ) ) + rAttribs.getString( XML_Target, OUString() );
+}
+
+OUString FilterDetectDocHandler::getFilterNameFromContentType( const OUString& rContentType ) const
+{
+    if( rContentType.equalsAscii( "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" ) ||
+        rContentType.equalsAscii( "application/vnd.ms-excel.sheet.macroEnabled.main+xml" ) )
+        return CREATE_OUSTRING( "MS Excel 2007 XML" );
+
+    if( rContentType.equalsAscii( "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml" ) ||
+        rContentType.equalsAscii( "application/vnd.ms-excel.template.macroEnabled.main+xml" ) )
+        return CREATE_OUSTRING( "MS Excel 2007 XML Template" );
+
+    if( rContentType.equalsAscii( "application/vnd.ms-excel.sheet.binary.macroEnabled.main" ) )
+        return CREATE_OUSTRING( "MS Excel 2007 Binary" );
+
+    if( rContentType.equalsAscii( "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml" ) ||
+        rContentType.equalsAscii( "application/vnd.ms-powerpoint.presentation.macroEnabled.main+xml" ) )
+        return CREATE_OUSTRING( "MS PowerPoint 2007 XML" );
+
+    if( rContentType.equalsAscii( "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml" ) ||
+        rContentType.equalsAscii( "application/vnd.ms-powerpoint.template.macroEnabled.main+xml" ) )
+        return CREATE_OUSTRING( "MS PowerPoint 2007 XML Template" );
+
+    return OUString();
+}
+
+void FilterDetectDocHandler::parseContentTypesDefault( const AttributeList& rAttribs )
+{
+    // only if no overridden part name found
+    if( mrFilter.getLength() == 0 )
+    {
+        // check if target path ends with extension
+        OUString aExtension = rAttribs.getString( XML_Extension, OUString() );
+        sal_Int32 nExtPos = maTargetPath.getLength() - aExtension.getLength();
+        if( (nExtPos > 0) && (maTargetPath[ nExtPos - 1 ] == '.') && maTargetPath.match( aExtension, nExtPos ) )
+            mrFilter = getFilterNameFromContentType( rAttribs.getString( XML_ContentType, OUString() ) );
+    }
+}
+
+void FilterDetectDocHandler::parseContentTypesOverride( const AttributeList& rAttribs )
+{
+    if( rAttribs.getString( XML_PartName, OUString() ).equals( maTargetPath ) )
+        mrFilter = getFilterNameFromContentType( rAttribs.getString( XML_ContentType, OUString() ) );
+}
+
+// ============================================================================
+
+class FilterDetect : public ::cppu::WeakImplHelper2< XExtendedFilterDetection, XServiceInfo >
+{
+public:
+    explicit            FilterDetect( const Reference< XMultiServiceFactory >& xFactory );
+    virtual             ~FilterDetect();
+
+    // XServiceInfo
+    virtual OUString SAL_CALL getImplementationName() throw( RuntimeException );
+    virtual sal_Bool SAL_CALL supportsService( const OUString& rServiceName ) throw( RuntimeException );
+    virtual Sequence< OUString > SAL_CALL getSupportedServiceNames() throw( RuntimeException );
+
+    // XExtendedFilterDetect
+    virtual OUString SAL_CALL detect( Sequence< PropertyValue >& lDescriptor ) throw( RuntimeException );
+
+private:
+    Reference< XMultiServiceFactory > mxFactory;
+};
+
+// ----------------------------------------------------------------------------
+
+/* Helper for XServiceInfo */
+Sequence< OUString > FilterDetect_getSupportedServiceNames()
+{
+    Sequence< OUString > aServiceNames( 1 );
+    aServiceNames[ 0 ] = CREATE_OUSTRING( "com.sun.star.frame.ExtendedTypeDetection" );
+    return aServiceNames;
+}
+
+/* Helper for XServiceInfo */
+OUString FilterDetect_getImplementationName()
+{
+    return CREATE_OUSTRING( "com.sun.star.comp.oox.FormatDetector" );
+}
+
+/* Helper for registry */
+Reference< XInterface > SAL_CALL FilterDetect_createInstance( const Reference< XMultiServiceFactory >& xServiceManager ) throw( Exception )
+{
+    return Reference< XInterface >( *new FilterDetect( xServiceManager ) );
+}
+
+FilterDetect::FilterDetect( const Reference< XMultiServiceFactory >& xFactory ) :
+    mxFactory( xFactory )
+{
+    OSL_ENSURE( mxFactory.is(), "FilterDetect::FilterDetect - no service factory" );
+}
+
+FilterDetect::~FilterDetect()
+{
+}
+
+// com.sun.star.document.XExtendedFilterDetect interface ----------------------
+
+OUString SAL_CALL FilterDetect::detect( Sequence< PropertyValue >& lDescriptor ) throw( RuntimeException )
+{
+    OUString aFilter;
+
+    if( mxFactory.is() ) try
+    {
+        Reference< XFastParser > xParser( mxFactory->createInstance(
+            CREATE_OUSTRING( "com.sun.star.xml.sax.FastParser" ) ), UNO_QUERY_THROW );
+
+        xParser->setFastDocumentHandler( new FilterDetectDocHandler( aFilter ) );
+        xParser->setTokenHandler( new FastTokenHandler );
+
+        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/package/2006/relationships" ), NMSP_PACKAGE_RELATIONSHIPS );
+        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/officeDocument/2006/relationships" ), NMSP_RELATIONSHIPS );
+        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/package/2006/content-types" ), NMSP_CONTENT_TYPES );
+
+        MediaDescriptor aDescriptor( lDescriptor );
+        aDescriptor.addInputStream();
+        Reference< XInputStream > xInputStream( aDescriptor[ MediaDescriptor::PROP_INPUTSTREAM() ], UNO_QUERY_THROW );
+        StorageRef xStorage( new ZipStorage( mxFactory, xInputStream ) );
+
+        // Parse _rels/.rels to get the target path.
+        InputSource aParserInput;
+        aParserInput.sSystemId = CREATE_OUSTRING( "_rels/.rels" );
+        aParserInput.aInputStream = xStorage->openInputStream( aParserInput.sSystemId );
+        xParser->parseStream( aParserInput );
+
+        // Parse [Content_Types].xml to determine the content type of the part at the target path.
+        aParserInput.sSystemId = CREATE_OUSTRING( "[Content_Types].xml" );
+        aParserInput.aInputStream = xStorage->openInputStream( aParserInput.sSystemId );
+        xParser->parseStream( aParserInput );
+    }
+    catch ( const Exception& )
+    {
+    }
+
+    return aFilter;
+}
+
+// com.sun.star.lang.XServiceInfo interface -----------------------------------
+
+OUString SAL_CALL FilterDetect::getImplementationName() throw( RuntimeException )
+{
+    return FilterDetect_getImplementationName();
+}
+
+sal_Bool SAL_CALL FilterDetect::supportsService( const OUString& rServiceName ) throw( RuntimeException )
+{
+    const Sequence< OUString > aServices = FilterDetect_getSupportedServiceNames();
+    const OUString* pArray = aServices.getConstArray();
+    const OUString* pArrayEnd = pArray + aServices.getLength();
+    return ::std::find( pArray, pArrayEnd, rServiceName ) != pArrayEnd;
+}
+
+Sequence< OUString > SAL_CALL FilterDetect::getSupportedServiceNames() throw( RuntimeException )
+{
+    return FilterDetect_getSupportedServiceNames();
+}
+
+// ============================================================================
+
+} // namespace core
+} // namespace oox
+
diff --git oox/source/core/xmlfilterbase.cxx oox/source/core/xmlfilterbase.cxx
index 3e6d72b..eaa64e4 100644
--- oox/source/core/xmlfilterbase.cxx
+++ oox/source/core/xmlfilterbase.cxx
@@ -32,14 +32,18 @@
 #include <set>
 #include <stdio.h>
 #include <rtl/ustrbuf.hxx>
+#include <rtl/instance.hxx>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/document/XDocumentSubStorageSupplier.hpp>
 #include <com/sun/star/embed/ElementModes.hpp>
 #include <com/sun/star/embed/XTransactedObject.hpp>
 #include <com/sun/star/embed/XRelationshipAccess.hpp>
+#include <com/sun/star/xml/dom/XDocument.hpp>
+#include <com/sun/star/xml/dom/XDocumentBuilder.hpp>
 #include <com/sun/star/xml/sax/InputSource.hpp>
 #include <com/sun/star/xml/sax/XFastParser.hpp>
+#include <com/sun/star/xml/sax/XFastSAXSerializable.hpp>
 #include <sax/fshelper.hxx>
 #include "oox/helper/containerhelper.hxx"
 #include "oox/helper/zipstorage.hxx"
@@ -54,6 +58,7 @@ using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
 using ::com::sun::star::beans::XPropertySet;
 using ::com::sun::star::beans::StringPair;
+using ::com::sun::star::beans::Pair;
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::uno::Exception;
@@ -70,6 +75,8 @@ using ::com::sun::star::io::XOutputStream;
 using ::com::sun::star::io::XStream;
 using ::com::sun::star::container::XNameContainer;
 using ::com::sun::star::document::XDocumentSubStorageSupplier;
+using ::com::sun::star::xml::dom::XDocument;
+using ::com::sun::star::xml::dom::XDocumentBuilder;
 using ::com::sun::star::xml::sax::XFastParser;
 using ::com::sun::star::xml::sax::XFastTokenHandler;
 using ::com::sun::star::xml::sax::XFastDocumentHandler;
@@ -77,6 +84,7 @@ using ::com::sun::star::xml::sax::InputSource;
 using ::com::sun::star::xml::sax::SAXException;
 using ::sax_fastparser::FastSerializerHelper;
 using ::sax_fastparser::FSHelperPtr;
+using namespace ::com::sun::star;
 
 namespace oox {
 namespace core {
@@ -109,6 +117,64 @@ XmlFilterBaseImpl::XmlFilterBaseImpl() :
 
 // ============================================================================
 
+namespace 
+{ 
+    struct NamespaceIds: public rtl::StaticWithInit<
+        Sequence< Pair< OUString, sal_Int32 > >,
+        NamespaceIds> 
+    {
+        Sequence< Pair< OUString, sal_Int32 > > operator()()
+        {
+            static const char* const namespaceURIs[] = {
+                "http://www.w3.org/XML/1998/namespace",
+                "http://schemas.openxmlformats.org/package/2006/relationships",
+                "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
+                "http://schemas.openxmlformats.org/drawingml/2006/main",
+                "http://schemas.openxmlformats.org/drawingml/2006/diagram",
+                "http://schemas.openxmlformats.org/drawingml/2006/chart",
+                "urn:schemas-microsoft-com:vml",
+                "urn:schemas-microsoft-com:office:office",
+                "urn:schemas-microsoft-com:office:word",
+                "urn:schemas-microsoft-com:office:excel",
+                "urn:schemas-microsoft-com:office:powerpoint",
+                "http://schemas.microsoft.com/office/2006/activeX",
+                "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
+                "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
+                "http://schemas.microsoft.com/office/excel/2006/main",
+                "http://schemas.openxmlformats.org/presentationml/2006/main"
+            };
+
+            static const sal_Int32 namespaceIds[] = {
+                NMSP_XML,
+                NMSP_PACKAGE_RELATIONSHIPS,
+                NMSP_RELATIONSHIPS,
+                NMSP_DRAWINGML,
+                NMSP_DIAGRAM,
+                NMSP_CHART,
+                NMSP_VML,
+                NMSP_OFFICE,
+                NMSP_VML_DOC,
+                NMSP_VML_XLS,
+                NMSP_VML_PPT,
+                NMSP_AX,
+                NMSP_XLS,
+                NMSP_XDR,
+                NMSP_XM,
+                NMSP_PPT
+            };
+
+            Sequence< Pair< OUString, sal_Int32 > > aRet(STATIC_ARRAY_SIZE(namespaceIds));
+            for( sal_Int32 i=0; i<aRet.getLength(); ++i )
+                aRet[i] = beans::make_Pair(
+                    ::rtl::OUString::createFromAscii(namespaceURIs[i]),
+                    namespaceIds[i]);
+            return aRet;
+        }
+    }; 
+}
+
+// ============================================================================
+
 XmlFilterBase::XmlFilterBase( const Reference< XMultiServiceFactory >& rxFactory ) :
     FilterBase( rxFactory ),
     mxImpl( new XmlFilterBaseImpl ),
@@ -123,6 +189,18 @@ XmlFilterBase::~XmlFilterBase()
 
 // ----------------------------------------------------------------------------
 
+const ::oox::vml::DrawingPtr XmlFilterBase::getDrawings()
+{
+    return ::oox::vml::DrawingPtr();
+}
+
+::oox::drawingml::chart::ChartConverter* XmlFilterBase::getChartConverter()
+{
+    return 0;
+}
+
+// ----------------------------------------------------------------------------
+
 OUString XmlFilterBase::getFragmentPathFromType( const OUString& rType )
 {
     return importRelations( OUString() )->getTargetFromType( rType );
@@ -183,26 +261,10 @@ bool XmlFilterBase::importFragment( const ::rtl::Reference< FragmentHandler >& r
         xParser->setTokenHandler( mxImpl->mxTokenHandler );
 
         // register XML namespaces
-        xParser->registerNamespace( CREATE_OUSTRING( "http://www.w3.org/XML/1998/namespace" ), NMSP_XML );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/package/2006/relationships" ), NMSP_PACKAGE_RELATIONSHIPS );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/officeDocument/2006/relationships" ), NMSP_RELATIONSHIPS );
-
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/drawingml/2006/main" ), NMSP_DRAWINGML );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/drawingml/2006/diagram" ), NMSP_DIAGRAM );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/drawingml/2006/chart" ), NMSP_CHART );
-
-        xParser->registerNamespace( CREATE_OUSTRING( "urn:schemas-microsoft-com:vml" ), NMSP_VML );
-        xParser->registerNamespace( CREATE_OUSTRING( "urn:schemas-microsoft-com:office:office" ), NMSP_OFFICE );
-        xParser->registerNamespace( CREATE_OUSTRING( "urn:schemas-microsoft-com:office:word" ), NMSP_VML_DOC );
-        xParser->registerNamespace( CREATE_OUSTRING( "urn:schemas-microsoft-com:office:excel" ), NMSP_VML_XLS );
-        xParser->registerNamespace( CREATE_OUSTRING( "urn:schemas-microsoft-com:office:powerpoint" ), NMSP_VML_PPT );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.microsoft.com/office/2006/activeX" ), NMSP_AX );
-
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/spreadsheetml/2006/main"), NMSP_XLS );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing" ), NMSP_XDR );
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.microsoft.com/office/excel/2006/main" ), NMSP_XM );
-
-        xParser->registerNamespace( CREATE_OUSTRING( "http://schemas.openxmlformats.org/presentationml/2006/main"), NMSP_PPT );
+        const Sequence< Pair< OUString, sal_Int32 > > ids=
+            NamespaceIds::get();
+        for( sal_Int32 i=0; i<ids.getLength(); ++i )
+            xParser->registerNamespace( ids[i].First, ids[i].Second );
 
         // create the input source and parse the stream
         InputSource aSource;
@@ -217,6 +279,66 @@ bool XmlFilterBase::importFragment( const ::rtl::Reference< FragmentHandler >& r
     return false;
 }
 
+Reference<XDocument> XmlFilterBase::importFragment( const ::rtl::OUString& aFragmentPath )
+{
+    Reference<XDocument> xRet;
+
+    // path to fragment stream valid?
+    OSL_ENSURE( aFragmentPath.getLength() > 0, "XmlFilterBase::importFragment - empty fragment path" );
+    if( aFragmentPath.getLength() == 0 )
+        return xRet;
+
+    // try to open the fragment stream (this may fail - do not assert)
+    Reference< XInputStream > xInStrm = openInputStream( aFragmentPath );
+    if( !xInStrm.is() )
+        return xRet;
+
+    // binary streams (fragment extension is '.bin') currently not supported
+    sal_Int32 nBinSuffixPos = aFragmentPath.getLength() - mxImpl->maBinSuffix.getLength();
+    if( (nBinSuffixPos >= 0) && aFragmentPath.match( mxImpl->maBinSuffix, nBinSuffixPos ) )
+        return xRet;
+
+    // try to import XML stream
+    try
+    {
+        // create the dom parser
+        Reference<XDocumentBuilder> xDomBuilder( 
+            getGlobalFactory()->createInstance(
+                CREATE_OUSTRING( "com.sun.star.xml.dom.DocumentBuilder" ) ), 
+            UNO_QUERY_THROW );
+
+        // create DOM from fragment
+        xRet = xDomBuilder->parse(xInStrm);
+    }
+    catch( Exception& )
+    {
+    }
+
+    return xRet;
+}
+
+bool XmlFilterBase::importFragment( const ::rtl::Reference< FragmentHandler >& rxHandler,
+                                    const Reference< xml::sax::XFastSAXSerializable >& rxSerializer )
+{
+    Reference< XFastDocumentHandler > xDocHandler( rxHandler.get() );
+    if( !xDocHandler.is() )
+        return false;
+
+    // try to import XML stream
+    try
+    {
+        rxSerializer->fastSerialize( xDocHandler,
+                                     mxImpl->mxTokenHandler,
+                                     uno::Sequence< beans::StringPair >(),
+                                     NamespaceIds::get() );
+        return true;
+    }
+    catch( Exception& )
+    {}
+
+    return false;
+}
+
 RelationsRef XmlFilterBase::importRelations( const OUString& rFragmentPath )
 {
     // try to find cached relations
diff --git oox/source/drawingml/chart/chartspaceconverter.cxx oox/source/drawingml/chart/chartspaceconverter.cxx
index 0e01b3a..088d975 100644
--- oox/source/drawingml/chart/chartspaceconverter.cxx
+++ oox/source/drawingml/chart/chartspaceconverter.cxx
@@ -65,9 +65,12 @@ ChartSpaceConverter::~ChartSpaceConverter()
 
 void ChartSpaceConverter::convertFromModel()
 {
+    if( !getChartConverter() )
+        return;
+
     /*  create data provider (virtual function in the ChartConverter class,
         derived converters may create an external data provider) */
-    getChartConverter().createDataProvider( getChartDocument() );
+    getChartConverter()->createDataProvider( getChartDocument() );
 
     // attach number formatter of container document to data receiver
     try
diff --git oox/source/drawingml/chart/converterbase.cxx oox/source/drawingml/chart/converterbase.cxx
index c9b91e3..c5509c2 100644
--- oox/source/drawingml/chart/converterbase.cxx
+++ oox/source/drawingml/chart/converterbase.cxx
@@ -145,9 +145,9 @@ XmlFilterBase& ConverterRoot::getFilter() const
     return mxData->mrFilter;
 }
 
-ChartConverter& ConverterRoot::getChartConverter() const
+ChartConverter* ConverterRoot::getChartConverter() const
 {
-    return mxData->mrConverter;
+    return &mxData->mrConverter;
 }
 
 Reference< XChartDocument > ConverterRoot::getChartDocument() const
diff --git oox/source/drawingml/chart/datasourceconverter.cxx oox/source/drawingml/chart/datasourceconverter.cxx
index be55030..ee880cc 100644
--- oox/source/drawingml/chart/datasourceconverter.cxx
+++ oox/source/drawingml/chart/datasourceconverter.cxx
@@ -56,11 +56,15 @@ DataSequenceConverter::~DataSequenceConverter()
 Reference< XDataSequence > DataSequenceConverter::createDataSequence( const OUString& rRole )
 {
     // create data sequence from data source model (virtual call at chart converter)
-    Reference< XDataSequence > xDataSeq = getChartConverter().createDataSequence( getChartDocument()->getDataProvider(), mrModel );
+    Reference< XDataSequence > xDataSeq;
+    if( getChartConverter() )
+    {
+        getChartConverter()->createDataSequence( getChartDocument()->getDataProvider(), mrModel );
 
-    // set sequence role
-    PropertySet aSeqProp( xDataSeq );
-    aSeqProp.setProperty( CREATE_OUSTRING( "Role" ), rRole );
+        // set sequence role
+        PropertySet aSeqProp( xDataSeq );
+        aSeqProp.setProperty( CREATE_OUSTRING( "Role" ), rRole );
+    }
 
     return xDataSeq;
 }
diff --git oox/source/drawingml/clrscheme.cxx oox/source/drawingml/clrscheme.cxx
index 5aa23cd..e733649 100644
--- oox/source/drawingml/clrscheme.cxx
+++ oox/source/drawingml/clrscheme.cxx
@@ -28,6 +28,7 @@
  *
  ************************************************************************/
 
+#include <osl/diagnose.h>
 #include "oox/drawingml/clrscheme.hxx"
 #include "tokens.hxx"
 
@@ -64,6 +65,7 @@ ClrScheme::~ClrScheme()
 
 sal_Bool ClrScheme::getColor( sal_Int32 nSchemeClrToken, sal_Int32& rColor ) const
 {
+    OSL_ASSERT((nSchemeClrToken & sal_Int32(0xFFFF0000))==0);
 	switch( nSchemeClrToken )
 	{
         case XML_bg1 : nSchemeClrToken = XML_lt1; break;
diff --git oox/source/drawingml/color.cxx oox/source/drawingml/color.cxx
index b5b02cd..3931ea4 100644
--- oox/source/drawingml/color.cxx
+++ oox/source/drawingml/color.cxx
@@ -116,6 +116,7 @@ Color::~Color()
 
 sal_Int32 Color::getPresetColor( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
     switch( nToken )
     {
         case XML_aliceBlue:         return 0xF0F8FF;
@@ -265,6 +266,8 @@ sal_Int32 Color::getPresetColor( sal_Int32 nToken )
 
 sal_Int32 Color::getSystemColor( sal_Int32 nToken, sal_Int32 nDefault )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
+
     //! TODO: get colors from system
     switch( nToken )
     {
@@ -381,6 +384,7 @@ sal_Int32 Color::getColor( const ::oox::core::XmlFilterBase& rFilter, sal_Int32
 
     for( TransformVec::const_iterator aIt = maTransforms.begin(), aEnd = maTransforms.end(); aIt != aEnd; ++aIt )
     {
+        OSL_ASSERT((aIt->mnToken & sal_Int32(0xFFFF0000))==0);
         switch( aIt->mnToken )
         {
             case XML_red:       toCrgb(); lclSetValue( mnC1, aIt->mnValue );    break;
diff --git oox/source/drawingml/customshapegeometry.cxx oox/source/drawingml/customshapegeometry.cxx
index 752c7b1..09ff58d 100644
--- oox/source/drawingml/customshapegeometry.cxx
+++ oox/source/drawingml/customshapegeometry.cxx
@@ -184,8 +184,9 @@ Reference< XFastContextHandler > AdjustmentValueContext::createFastChildContext(
 
 // ---------------------------------------------------------------------
 
-OUString GetShapeType( sal_Int32 nType )
+OUString GetShapePresetType( sal_Int32 nType )
 {
+    OSL_ASSERT((nType & sal_Int32(0xFFFF0000))==0);
 	OUString sType;
  	switch( nType )
 	{
@@ -813,6 +814,7 @@ OUString GetShapeType( sal_Int32 nType )
 
 static OUString GetTextShapeType( sal_Int32 nType )
 {
+    OSL_ASSERT((nType & sal_Int32(0xFFFF0000))==0);
 	OUString sType;
 	switch( nType )
 	{
@@ -1018,7 +1020,7 @@ PresetShapeGeometryContext::PresetShapeGeometryContext( ContextHandler& rParent,
 	OUString sShapeType;
 	sal_Int32 nShapeType = xAttribs->getOptionalValueToken( XML_prst, FastToken::DONTKNOW );
 	if ( nShapeType != FastToken::DONTKNOW )
-		sShapeType = GetShapeType( nShapeType );
+		sShapeType = GetShapePresetType( nShapeType );
 	OSL_ENSURE( sShapeType.getLength(), "oox::drawingml::CustomShapeCustomGeometryContext::CustomShapeCustomGeometryContext(), unknown shape type" );
 	mrCustomShapeProperties.setShapePresetType( sShapeType );
 }
diff --git oox/source/drawingml/diagram/constraintlistcontext.cxx oox/source/drawingml/diagram/constraintlistcontext.cxx
new file mode 100644
index 0000000..6ef7f18
--- /dev/null
+++ oox/source/drawingml/diagram/constraintlistcontext.cxx
@@ -0,0 +1,102 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "constraintlistcontext.hxx"
+#include "oox/helper/attributelist.hxx"
+#include "oox/core/namespaces.hxx"
+
+using namespace ::oox::core;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::xml::sax;
+using ::rtl::OUString;
+
+namespace oox { namespace drawingml {
+
+// CT_ConstraintLists
+ConstraintListContext::ConstraintListContext( ContextHandler& rParent,
+                                              const Reference< XFastAttributeList >&,
+                                              const LayoutAtomPtr &pNode )
+    : ContextHandler( rParent )
+	, mpNode( pNode )
+{
+	OSL_ENSURE( pNode, "Node must NOT be NULL" );
+}
+
+
+ConstraintListContext::~ConstraintListContext()
+{
+}
+
+void SAL_CALL ConstraintListContext::endFastElement( ::sal_Int32 )
+	throw (SAXException, RuntimeException)
+{
+}
+
+Reference< XFastContextHandler > SAL_CALL
+ConstraintListContext::createFastChildContext( ::sal_Int32 aElement,
+                                               const Reference< XFastAttributeList >& xAttribs )
+	throw (SAXException, RuntimeException)
+{
+	Reference< XFastContextHandler > xRet;
+
+    OUString aEmptyStr;
+
+	switch( aElement )
+	{
+	case NMSP_DIAGRAM|XML_constr:
+	{
+		ConstraintAtomPtr pNode( new ConstraintAtom() );
+		mpNode->addChild( pNode );
+
+        AttributeList aAttribs( xAttribs );
+        pNode->setFor( aAttribs.getToken( XML_for, XML_none ) );
+        pNode->setForName( aAttribs.getString( XML_forName, aEmptyStr ) );
+        pNode->setPointType( aAttribs.getToken( XML_ptType, XML_none ) );
+        pNode->setType( aAttribs.getToken( XML_type, XML_none ) );
+        pNode->setRefFor( aAttribs.getToken( XML_refFor, XML_none ) );
+        pNode->setRefForName( aAttribs.getString( XML_refForName, aEmptyStr ) );
+        pNode->setRefType( aAttribs.getToken( XML_refType, XML_none ) );
+        pNode->setRefPointType( aAttribs.getToken( XML_refPtType, XML_none ) );
+        pNode->setFactor( aAttribs.getDouble( XML_fact, 1.0 ) );
+        pNode->setValue( aAttribs.getDouble( XML_val, 0.0 ) );
+        pNode->setOperator( aAttribs.getToken( XML_op, XML_none ) );
+		break;
+	}
+	default:
+		break;
+	}
+	if( !xRet.is() )
+		xRet.set(this);
+
+	return xRet;
+}
+
+
+} }
diff --git oox/source/drawingml/diagram/constraintlistcontext.hxx oox/source/drawingml/diagram/constraintlistcontext.hxx
new file mode 100644
index 0000000..7d48811
--- /dev/null
+++ oox/source/drawingml/diagram/constraintlistcontext.hxx
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_DRAWINGML_CONSTRAINTLISTCONTEXT_HXX
+#define OOX_DRAWINGML_CONSTRAINTLISTCONTEXT_HXX
+
+#include "oox/core/contexthandler.hxx"
+#include "diagramlayoutatoms.hxx"
+#include "diagram.hxx"
+
+namespace oox { namespace drawingml {
+
+class ConstraintListContext : public ::oox::core::ContextHandler
+{
+public:
+    ConstraintListContext( ContextHandler& rParent, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes, const LayoutAtomPtr &pNode );
+	virtual ~ConstraintListContext();
+
+	virtual void SAL_CALL endFastElement( ::sal_Int32 Element ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+	virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+private:
+	LayoutAtomPtr mpNode;
+};
+
+} }
+
+#endif
diff --git oox/source/drawingml/diagram/datamodelcontext.cxx oox/source/drawingml/diagram/datamodelcontext.cxx
index a3537bb..f9c0248 100644
--- oox/source/drawingml/diagram/datamodelcontext.cxx
+++ oox/source/drawingml/diagram/datamodelcontext.cxx
@@ -28,7 +28,7 @@
  *
  ************************************************************************/
 
-#include "oox/drawingml/diagram/datamodelcontext.hxx"
+#include "datamodelcontext.hxx"
 #include "oox/helper/attributelist.hxx"
 #include "oox/core/skipcontext.hxx"
 #include "oox/core/namespaces.hxx"
@@ -43,43 +43,46 @@ using ::rtl::OUString;
 
 namespace oox { namespace drawingml {
 
-
-
-// CL_Cxn
-class CxnContext
+// CT_CxnList
+class CxnListContext
     : public ContextHandler
 {
 public:
-    CxnContext( ContextHandler& rParent,
-				const Reference< XFastAttributeList >& xAttribs,
-				const dgm::ConnectionPtr & pConnection )
+    CxnListContext( ContextHandler& rParent,  dgm::Connections & aConnections )
         : ContextHandler( rParent )
-		, mpConnection( pConnection )
+		, mrConnections( aConnections )
 		{
-			sal_Int32 nType = xAttribs->getOptionalValueToken( XML_type, XML_parOf );
-			pConnection->mnType = nType;
-			pConnection->msModelId = xAttribs->getOptionalValue( XML_modelId );
-			pConnection->msSourceId = xAttribs->getOptionalValue( XML_srcId );
-			pConnection->msDestId  = xAttribs->getOptionalValue( XML_destId );
-			pConnection->msPresId  = xAttribs->getOptionalValue( XML_presId );
-			pConnection->msSibTransId  = xAttribs->getOptionalValue( XML_sibTransId );
-			AttributeList attribs( xAttribs );
-			pConnection->mnSourceOrder = attribs.getInteger( XML_srcOrd, 0 );
-			pConnection->mnDestOrder = attribs.getInteger( XML_destOrd, 0 );
 		}
-
     virtual Reference< XFastContextHandler > SAL_CALL
 	createFastChildContext( sal_Int32 aElementToken,
-							const Reference< XFastAttributeList >& /*xAttribs*/ )
+							const Reference< XFastAttributeList >& xAttribs )
 		throw (SAXException, RuntimeException)
 		{
 			Reference< XFastContextHandler > xRet;
 
 			switch( aElementToken )
 			{
-			case NMSP_DIAGRAM|XML_extLst:
+			case NMSP_DIAGRAM|XML_cxn:
+			{
+				mrConnections.push_back( dgm::Connection() );
+                dgm::Connection& rConnection=mrConnections.back();
+
+                const sal_Int32 nType = xAttribs->getOptionalValueToken( XML_type, XML_parOf );
+                rConnection.mnType = nType;
+                rConnection.msModelId = xAttribs->getOptionalValue( XML_modelId );
+                rConnection.msSourceId = xAttribs->getOptionalValue( XML_srcId );
+                rConnection.msDestId  = xAttribs->getOptionalValue( XML_destId );
+                rConnection.msPresId  = xAttribs->getOptionalValue( XML_presId );
+                rConnection.msSibTransId  = xAttribs->getOptionalValue( XML_sibTransId );
+                rConnection.msParTransId  = xAttribs->getOptionalValue( XML_parTransId );
+                const AttributeList attribs( xAttribs );
+                rConnection.mnSourceOrder = attribs.getInteger( XML_srcOrd, 0 );
+                rConnection.mnDestOrder = attribs.getInteger( XML_destOrd, 0 );
+
+                // skip CT_extLst
                 xRet.set( new SkipContext( *this ) );
 				break;
+			}
 			default:
 				break;
 			}
@@ -87,35 +90,135 @@ public:
 				xRet.set( this );
 			return xRet;
 		}
+
 private:
-	dgm::ConnectionPtr mpConnection;
+	dgm::Connections& mrConnections;
 };
 
 
-// CT_CxnList
-class CxnListContext
+// CT_presLayoutVars
+class PresLayoutVarsContext
     : public ContextHandler
 {
 public:
-    CxnListContext( ContextHandler& rParent,  dgm::Connections & aConnections )
-        : ContextHandler( rParent )
-		, maConnections( aConnections )
+    PresLayoutVarsContext( ContextHandler& rParent,
+                           dgm::Point & rPoint ) :
+        ContextHandler( rParent ),
+		mrPoint( rPoint )
+    {
+    }
+    virtual Reference< XFastContextHandler > SAL_CALL
+	createFastChildContext( sal_Int32 aElementToken,
+							const Reference< XFastAttributeList >& xAttribs )
+		throw (SAXException, RuntimeException)
 		{
+			Reference< XFastContextHandler > xRet;
+            AttributeList aAttribs( xAttribs );
+
+			switch( aElementToken )
+			{
+                // TODO
+			case NMSP_DIAGRAM|XML_animLvl:
+			case NMSP_DIAGRAM|XML_animOne:
+				break;
+			case NMSP_DIAGRAM|XML_bulletEnabled:
+                mrPoint.mbBulletEnabled = aAttribs.getBool( XML_val, false );
+                break;
+			case NMSP_DIAGRAM|XML_chMax:
+                mrPoint.mnMaxChildren = aAttribs.getInteger( XML_val, -1 );
+                break;
+			case NMSP_DIAGRAM|XML_chPref:
+                mrPoint.mnPreferredChildren = aAttribs.getInteger( XML_val, -1 );
+                break;
+			case NMSP_DIAGRAM|XML_dir:
+                mrPoint.mnDirection = aAttribs.getToken( XML_val, XML_norm );
+                break;
+			case NMSP_DIAGRAM|XML_hierBranch:
+                mrPoint.mnHierarchyBranch = aAttribs.getToken( XML_val, XML_std );
+                break;
+			case NMSP_DIAGRAM|XML_orgChart:
+                mrPoint.mbOrgChartEnabled = aAttribs.getBool( XML_val, false );
+                break;
+			case NMSP_DIAGRAM|XML_resizeHandles:
+                mrPoint.mnResizeHandles = aAttribs.getToken( XML_val, XML_rel );
+                break;
+			default:
+				break;
+			}
+			if( !xRet.is() )
+				xRet.set( this );
+			return xRet;
 		}
+
+private:
+    dgm::Point& mrPoint;
+};
+
+
+// CT_prSet
+class PropertiesContext
+    : public ContextHandler
+{
+public:
+    PropertiesContext( ContextHandler& rParent,
+                       dgm::Point & rPoint,
+                       const Reference< XFastAttributeList >& xAttribs ) :
+        ContextHandler( rParent ),
+		mrPoint( rPoint )
+    {
+        OUString aEmptyStr;
+        AttributeList aAttribs( xAttribs );
+
+        mrPoint.msColorTransformCategoryId = aAttribs.getString( XML_csCatId, aEmptyStr );
+        mrPoint.msColorTransformTypeId = aAttribs.getString( XML_csTypeId, aEmptyStr );
+        mrPoint.msLayoutCategoryId = aAttribs.getString( XML_loCatId, aEmptyStr );
+        mrPoint.msLayoutTypeId = aAttribs.getString( XML_loTypeId, aEmptyStr );
+        mrPoint.msPlaceholderText = aAttribs.getString( XML_phldrT, aEmptyStr );
+        mrPoint.msPresentationAssociationId = aAttribs.getString( XML_presAssocID, aEmptyStr );
+        mrPoint.msPresentationLayoutName = aAttribs.getString( XML_presName, aEmptyStr );
+        mrPoint.msPresentationLayoutStyleLabel = aAttribs.getString( XML_presStyleLbl, aEmptyStr );
+        mrPoint.msQuickStyleCategoryId = aAttribs.getString( XML_qsCatId, aEmptyStr );
+        mrPoint.msQuickStyleTypeId = aAttribs.getString( XML_qsTypeId, aEmptyStr );
+
+        mrPoint.mnCustomAngle = aAttribs.getInteger( XML_custAng, -1 );
+        mrPoint.mnPercentageNeighbourWidth = aAttribs.getInteger( XML_custLinFactNeighborX, -1 );
+        mrPoint.mnPercentageNeighbourHeight = aAttribs.getInteger( XML_custLinFactNeighborY, -1 );
+        mrPoint.mnPercentageOwnWidth = aAttribs.getInteger( XML_custLinFactX, -1 );
+        mrPoint.mnPercentageOwnHeight = aAttribs.getInteger( XML_custLinFactY, -1 );
+        mrPoint.mnIncludeAngleScale = aAttribs.getInteger( XML_custRadScaleInc, -1 );
+        mrPoint.mnRadiusScale = aAttribs.getInteger( XML_custRadScaleRad, -1 );
+        mrPoint.mnWidthScale = aAttribs.getInteger( XML_custScaleX, -1 );
+        mrPoint.mnHeightScale = aAttribs.getInteger( XML_custScaleY, -1 );
+        mrPoint.mnWidthOverride = aAttribs.getInteger( XML_custSzX, -1 );
+        mrPoint.mnHeightOverride = aAttribs.getInteger( XML_custSzY, -1 );
+        mrPoint.mnLayoutStyleCount = aAttribs.getInteger( XML_presStyleCnt, -1 );
+        mrPoint.mnLayoutStyleIndex = aAttribs.getInteger( XML_presStyleIdx, -1 );
+
+        mrPoint.mbCoherent3DOffset = aAttribs.getBool( XML_coherent3DOff, false );
+        mrPoint.mbCustomHorizontalFlip = aAttribs.getBool( XML_custFlipHor, false );
+        mrPoint.mbCustomVerticalFlip = aAttribs.getBool( XML_custFlipVert, false );
+        mrPoint.mbCustomText = aAttribs.getBool( XML_custT, false );
+        mrPoint.mbIsPlaceholder = aAttribs.getBool( XML_phldr, false );
+    }
     virtual Reference< XFastContextHandler > SAL_CALL
 	createFastChildContext( sal_Int32 aElementToken,
-							const Reference< XFastAttributeList >& xAttribs )
+							const Reference< XFastAttributeList >& )
 		throw (SAXException, RuntimeException)
 		{
 			Reference< XFastContextHandler > xRet;
 
 			switch( aElementToken )
 			{
-			case NMSP_DIAGRAM|XML_cxn:
+			case NMSP_DIAGRAM|XML_presLayoutVars:
+			{
+                xRet.set( new PresLayoutVarsContext( *this, mrPoint ) );
+				break;
+			}
+			case NMSP_DIAGRAM|XML_style:
 			{
-				dgm::ConnectionPtr pConnection( new dgm::Connection() );
-				maConnections.push_back( pConnection );
-                xRet.set( new CxnContext( *this, xAttribs, pConnection ) );
+                // TODO
+                // skip CT_shapeStyle
+                xRet.set( new SkipContext( *this ) );
 				break;
 			}
 			default:
@@ -127,11 +230,10 @@ public:
 		}
 
 private:
-	dgm::Connections  & maConnections;
+    dgm::Point& mrPoint;
 };
 
 
-
 // CL_Pt
 class PtContext
     : public ContextHandler
@@ -139,27 +241,25 @@ class PtContext
 public:
     PtContext( ContextHandler& rParent,
 			   const Reference< XFastAttributeList >& xAttribs,
-			   const dgm::PointPtr & pPoint)
-        : ContextHandler( rParent )
-		, mpPoint( pPoint )
-		{
-			mpPoint->setModelId( xAttribs->getOptionalValue( XML_modelId ) );
-			//
-			// the default type is XML_node
-			sal_Int32 nType  = xAttribs->getOptionalValueToken( XML_type, XML_node );
-			mpPoint->setType( nType );
-
-			// ignore the cxnId unless it is this type. See 5.15.3.1.3 in Primer
-			if( ( nType == XML_parTrans ) || ( nType == XML_sibTrans ) )
-			{
-				mpPoint->setCnxId( xAttribs->getOptionalValue( XML_cxnId ) );
-			}
-		}
+			   dgm::Point & rPoint):
+        ContextHandler( rParent ),
+		mrPoint( rPoint )
+    {
+        mrPoint.msModelId = xAttribs->getOptionalValue( XML_modelId );
+
+        // the default type is XML_node
+        const sal_Int32 nType  = xAttribs->getOptionalValueToken( XML_type, XML_node );
+        mrPoint.mnType = nType;
+        
+        // ignore the cxnId unless it is this type. See 5.15.3.1.3 in Primer    
+        if( ( nType == XML_parTrans ) || ( nType == XML_sibTrans ) )
+            mrPoint.msCnxId = xAttribs->getOptionalValue( XML_cxnId );
+    }
 
 
     virtual Reference< XFastContextHandler > SAL_CALL
 	createFastChildContext( sal_Int32 aElementToken,
-							const Reference< XFastAttributeList >& /*xAttribs*/ )
+							const Reference< XFastAttributeList >& xAttribs )
 		throw (SAXException, RuntimeException)
 		{
 			Reference< XFastContextHandler > xRet;
@@ -170,18 +270,22 @@ public:
                 xRet.set( new SkipContext( *this ) );
 				break;
 			case NMSP_DIAGRAM|XML_prSet:
-				// TODO
-				// CT_ElemPropSet
+				OSL_TRACE( "diagram property set for point");
+                xRet = new PropertiesContext( *this, mrPoint, xAttribs );
 				break;
 			case NMSP_DIAGRAM|XML_spPr:
 				OSL_TRACE( "shape props for point");
-                xRet = new ShapePropertiesContext( *this, *mpPoint->getShape() );
+                if( !mrPoint.mpShape )
+                    mrPoint.mpShape.reset( new Shape() );
+                xRet = new ShapePropertiesContext( *this, *(mrPoint.mpShape) );
 				break;
 			case NMSP_DIAGRAM|XML_t:
 			{
 				OSL_TRACE( "shape text body for point");
                 TextBodyPtr xTextBody( new TextBody );
-                mpPoint->getShape()->setTextBody( xTextBody );
+                if( !mrPoint.mpShape )
+                    mrPoint.mpShape.reset( new Shape() );
+                mrPoint.mpShape->setTextBody( xTextBody );
                 xRet = new TextBodyContext( *this, *xTextBody );
 				break;
 			}
@@ -194,7 +298,7 @@ public:
 		}
 
 private:
-	dgm::PointPtr mpPoint;
+	dgm::Point& mrPoint;
 };
 
 
@@ -204,11 +308,10 @@ class PtListContext
     : public ContextHandler
 {
 public:
-    PtListContext( ContextHandler& rParent,  dgm::Points & aPoints)
-        : ContextHandler( rParent )
-		, maPoints( aPoints )
-		{
-		}
+    PtListContext( ContextHandler& rParent,  dgm::Points& rPoints) :
+        ContextHandler( rParent ),
+		mrPoints( rPoints )
+    {}
     virtual Reference< XFastContextHandler > SAL_CALL
 	createFastChildContext( sal_Int32 aElementToken,
 							const Reference< XFastAttributeList >& xAttribs )
@@ -221,9 +324,8 @@ public:
 			case NMSP_DIAGRAM|XML_pt:
 			{
 				// CT_Pt
-				dgm::PointPtr pPoint( new dgm::Point() );
-				maPoints.push_back( pPoint );
-                xRet.set( new PtContext( *this, xAttribs, pPoint ) );
+				mrPoints.push_back( dgm::Point() );
+                xRet.set( new PtContext( *this, xAttribs, mrPoints.back() ) );
 				break;
 			}
 			default:
@@ -235,7 +337,7 @@ public:
 		}
 
 private:
-	dgm::Points  & maPoints;
+	dgm::Points& mrPoints;
 };
 
 // CT_BackgroundFormatting
diff --git oox/source/drawingml/diagram/datamodelcontext.hxx oox/source/drawingml/diagram/datamodelcontext.hxx
new file mode 100644
index 0000000..526385b
--- /dev/null
+++ oox/source/drawingml/diagram/datamodelcontext.hxx
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: datamodelcontext.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+#ifndef OOX_DRAWINGML_SHAPECONTEXT_HXX
+#define OOX_DRAWINGML_SHAPECONTEXT_HXX
+
+#include <com/sun/star/drawing/XShapes.hpp>
+
+#include "oox/core/contexthandler.hxx"
+#include "diagram.hxx"
+
+namespace oox { namespace drawingml {
+
+// CT_DataModel
+class DataModelContext : public ::oox::core::ContextHandler
+{
+public:
+    DataModelContext( ::oox::core::ContextHandler& rParent, const DiagramDataPtr & pDataModelPtr );
+	virtual ~DataModelContext();
+
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+
+protected:
+    DiagramDataPtr mpDataModel;
+};
+
+} }
+
+#endif  //  OOX_DRAWINGML_SHAPEGROUPCONTEXT_HXX
diff --git oox/source/drawingml/diagram/diagram.cxx oox/source/drawingml/diagram/diagram.cxx
index 3bb89a2..2045633 100644
--- oox/source/drawingml/diagram/diagram.cxx
+++ oox/source/drawingml/diagram/diagram.cxx
@@ -34,10 +34,22 @@
 
 #include <com/sun/star/awt/Point.hpp>
 #include <com/sun/star/awt/Size.hpp>
+#include <com/sun/star/xml/dom/XDocument.hpp>
+#include <com/sun/star/xml/sax/XFastSAXSerializable.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "oox/drawingml/textbody.hxx"
+#include "oox/drawingml/textparagraph.hxx"
+#include "oox/drawingml/textrun.hxx"
 #include "oox/drawingml/diagram/diagram.hxx"
 #include "oox/drawingml/fillproperties.hxx"
 #include "oox/core/namespaces.hxx"
 #include "tokens.hxx"
+#include "diagram.hxx"
+#include "diagramlayoutatoms.hxx"
+#include "diagramfragmenthandler.hxx"
+
+#include <iostream>
+#include <fstream>
 
 using rtl::OUString;
 using namespace ::com::sun::star;
@@ -49,58 +61,26 @@ namespace dgm {
 
 void Connection::dump()
 {
-	OSL_TRACE("dgm: cnx modelId %s, srcId %s, dstId %s",
-			  OUSTRING_TO_CSTR( msModelId ),
+	OSL_TRACE("dgm: cnx modelId %s, srcId %s, dstId %s, parTransId %s, presId %s, sibTransId %s, srcOrd %d, dstOrd %d",
+			  OUSTRING_TO_CSTR( msModelId ), 
 			  OUSTRING_TO_CSTR( msSourceId ),
-			  OUSTRING_TO_CSTR( msDestId ) );
-}
-
-Point::Point()
-	: mpShape( new Shape( "com.sun.star.drawing.GraphicObjectShape" ) )
-	, mnType( 0 )
-{
+			  OUSTRING_TO_CSTR( msDestId ),
+			  OUSTRING_TO_CSTR( msParTransId ),
+			  OUSTRING_TO_CSTR( msPresId ),
+			  OUSTRING_TO_CSTR( msSibTransId ),
+			  mnSourceOrder,
+			  mnDestOrder );
 }
 
 void Point::dump()
 {
-	OSL_TRACE( "dgm: pt cnxId %s, modelId %s",
+	OSL_TRACE( "dgm: pt text %x, cnxId %s, modelId %s, type %d",
+			   mpShape.get(),
 			   OUSTRING_TO_CSTR( msCnxId ),
-			   OUSTRING_TO_CSTR( msModelId ) );
-}
-
-void Point::setModelId( const ::rtl::OUString & sModelId )
-{
-	msModelId = sModelId;
-	mpShape->setName( msModelId );
-}
-
-
-bool PointsTree::addChild( const PointsTreePtr & pChild )
-{
-	bool added = false;
-
-	OSL_ENSURE( pChild->mpParent.expired(), "can't add, has already a parent" );
-	OSL_ENSURE( mpNode, "has no node" );
-	if( mpNode && pChild->mpParent.expired() )
-	{
-		pChild->mpParent = shared_from_this();
-		maChildrens.push_back( pChild );
-		added = true;
-	}
-
-	return added;
-}
-
-PointsTreePtr PointsTree::getParent() const
-{
-	if( !mpParent.expired() )
-	{
-		return mpParent.lock() ;
-	}
-	return PointsTreePtr();
+			   OUSTRING_TO_CSTR( msModelId ),
+               mnType );
 }
 
-
 } // dgm namespace
 
 DiagramData::DiagramData()
@@ -118,18 +98,10 @@ void DiagramData::dump()
 				  boost::bind( &dgm::Point::dump, _1 ) );
 }
 
-static void setPosition( const dgm::PointPtr & pPoint, const awt::Point & pt )
-{
-	ShapePtr pShape = pPoint->getShape();
-	awt::Size sz;
-	sz.Width = 50;
-	sz.Height = 50;
-	pShape->setPosition( pt );
-	pShape->setSize( sz );
-}
-
-void DiagramLayout::layout( const dgm::PointsTreePtr & pTree, const awt::Point & pt )
+void DiagramLayout::layout( const dgm::Points & pTree, const awt::Point & pt )
 {
+    // TODO
+#if 0
 	setPosition( pTree->getPoint(), pt );
 	awt::Point nextPt = pt;
 	nextPt.Y += 50;
@@ -139,6 +111,7 @@ void DiagramLayout::layout( const dgm::PointsTreePtr & pTree, const awt::Point &
 		layout( *iter, nextPt );
 		nextPt.X += 50;
 	}
+#endif
 }
 
 void Diagram::setData( const DiagramDataPtr & pData)
@@ -152,19 +125,244 @@ void Diagram::setLayout( const DiagramLayoutPtr & pLayout)
 	mpLayout = pLayout;
 }
 
-void Diagram::setQStyles( const DiagramQStylesPtr & pStyles)
+#if OSL_DEBUG_LEVEL > 1
+rtl::OString normalizeDotName( const rtl::OUString& rStr )
 {
-	mpQStyles = pStyles;
-}
+    rtl::OUStringBuffer aBuf;
+    aBuf.append((sal_Unicode)'N');
+
+    const sal_Int32 nLen(rStr.getLength());
+    sal_Int32 nCurrIndex(0);
+    while( nCurrIndex < nLen )
+    {
+        const sal_Int32 aChar=rStr.iterateCodePoints(&nCurrIndex);
+        if( aChar != '-' && aChar != '{' && aChar != '}' )
+            aBuf.append((sal_Unicode)aChar);
+    }
 
+    return rtl::OUStringToOString(aBuf.makeStringAndClear(),
+                                  RTL_TEXTENCODING_UTF8);
+}
+#endif
 
-void Diagram::setColors( const DiagramColorsPtr & pColors)
+static sal_Int32 calcDepth( const rtl::OUString& rNodeName, 
+                            const dgm::Connections& rCnx )
 {
-	mpColors = pColors;
+    // find length of longest path in 'isChild' graph, ending with rNodeName
+	dgm::Connections::const_iterator aCurrCxn( rCnx.begin() );
+	const dgm::Connections::const_iterator aEndCxn( rCnx.end() );
+    while( aCurrCxn != aEndCxn )
+    {
+        if( aCurrCxn->msParTransId.getLength() &&
+            aCurrCxn->msSibTransId.getLength() &&
+            aCurrCxn->msSourceId.getLength() &&
+            aCurrCxn->msDestId.getLength() &&
+            aCurrCxn->mnType != XML_presOf && 
+            aCurrCxn->mnType != XML_presParOf &&
+            rNodeName == aCurrCxn->msDestId )
+        {
+            return calcDepth(aCurrCxn->msSourceId,
+                             rCnx) + 1;
+        }
+        ++aCurrCxn;
+    }
+
+    return 0;
 }
 
+
 void Diagram::build(  )
 {
+    // build name-object maps
+    // ======================
+
+#if OSL_DEBUG_LEVEL > 1
+    std::ofstream output("/tmp/tree.dot");
+
+    output << "digraph datatree {" << std::endl;
+#endif
+
+	dgm::Points::iterator aCurrPoint( getData()->getPoints( ).begin() );
+	const dgm::Points::iterator aEndPoint( getData()->getPoints( ).end() );
+    while( aCurrPoint != aEndPoint )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        output << "\t" 
+               << normalizeDotName(aCurrPoint->msModelId).getStr()
+               << "[";
+
+        if( aCurrPoint->msPresentationLayoutName.getLength() )
+            output << "label=\"" 
+                   << rtl::OUStringToOString(
+                       aCurrPoint->msPresentationLayoutName,
+                       RTL_TEXTENCODING_UTF8).getStr() << "\", ";
+        else
+            output << "label=\"" 
+                   << rtl::OUStringToOString(
+                       aCurrPoint->msModelId,
+                       RTL_TEXTENCODING_UTF8).getStr() << "\", ";
+
+        switch( aCurrPoint->mnType )
+        {
+            case XML_doc: output << "style=filled, color=red"; break;
+            case XML_asst: output << "style=filled, color=green"; break;
+            default:
+            case XML_node: output << "style=filled, color=blue"; break;
+            case XML_pres: output << "style=filled, color=yellow"; break;
+            case XML_parTrans: output << "color=grey"; break;
+            case XML_sibTrans: output << " "; break;
+        }
+
+        output << "];" << std::endl;
+
+        // does currpoint have any text set?
+        if( aCurrPoint->mpShape && 
+            aCurrPoint->mpShape->getTextBody() &&
+            !aCurrPoint->mpShape->getTextBody()->getParagraphs().empty() &&
+            !aCurrPoint->mpShape->getTextBody()->getParagraphs().front()->getRuns().empty() )
+        {
+            static sal_Int32 nCount=0;
+
+            output << "\t" 
+                   << "textNode" << nCount
+                   << " ["
+                   << "label=\""
+                   << rtl::OUStringToOString(
+                       aCurrPoint->mpShape->getTextBody()->getParagraphs().front()->getRuns().front()->getText(),
+                       RTL_TEXTENCODING_UTF8).getStr()
+                   << "\"" << "];" << std::endl;
+            output << "\t" 
+                   << normalizeDotName(aCurrPoint->msModelId).getStr()
+                   << " -> "
+                   << "textNode" << nCount++
+                   << ";" << std::endl;
+        }
+            
+
+#if 0
+        // msPresentationAssociationId does not appear to be
+        // valid/used, the relation this imposed for several examples
+        // was ~broken
+        if( aCurrPoint->msPresentationAssociationId.getLength() )
+            output << "\t" 
+                   << normalizeDotName(aCurrPoint->msModelId).getStr()
+                   << " -> "
+                   << normalizeDotName(aCurrPoint->msPresentationAssociationId).getStr()
+                   << " [style=dotted, color=red, "
+                   << "label=\"presAssocID\"];" << std::endl;
+#endif
+
+#endif
+
+        const bool bInserted1=getData()->getPointNameMap().insert(
+            std::make_pair(aCurrPoint->msModelId,&(*aCurrPoint))).second;
+        (void)bInserted1;
+
+        OSL_ENSURE(bInserted1,"Diagram::build(): non-unique point model id");
+
+        if( aCurrPoint->msPresentationLayoutName.getLength() )
+        {
+            DiagramData::PointsNameMap::value_type::second_type& rVec=
+                getData()->getPointsPresNameMap()[aCurrPoint->msPresentationLayoutName];
+            rVec.push_back(&(*aCurrPoint));
+        }
+        ++aCurrPoint;
+    }
+
+	dgm::Connections::const_iterator aCurrCxn( getData()->getConnections( ).begin() );
+	const dgm::Connections::const_iterator aEndCxn( getData()->getConnections( ).end() );
+    while( aCurrCxn != aEndCxn )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        if( aCurrCxn->msParTransId.getLength() || 
+            aCurrCxn->msSibTransId.getLength() )
+        {
+            if( aCurrCxn->msSourceId.getLength() || 
+                aCurrCxn->msDestId.getLength() )
+            {
+                output << "\t" 
+                       << normalizeDotName(aCurrCxn->msSourceId).getStr()
+                       << " -> "
+                       << normalizeDotName(aCurrCxn->msParTransId).getStr()
+                       << " -> "
+                       << normalizeDotName(aCurrCxn->msSibTransId).getStr()
+                       << " -> "
+                       << normalizeDotName(aCurrCxn->msDestId).getStr()
+                       << " [style=dotted,"
+                       << ((aCurrCxn->mnType == XML_presOf) ? " color=red, " : ((aCurrCxn->mnType == XML_presParOf) ? " color=green, " : " "))
+                       << "label=\"" 
+                       << rtl::OUStringToOString(aCurrCxn->msModelId,
+                                                 RTL_TEXTENCODING_UTF8 ).getStr()
+                       << "\"];" << std::endl;
+            }
+            else
+            {
+                output << "\t" 
+                       << normalizeDotName(aCurrCxn->msParTransId).getStr()
+                       << " -> "
+                       << normalizeDotName(aCurrCxn->msSibTransId).getStr()
+                       << " ["
+                       << ((aCurrCxn->mnType == XML_presOf) ? " color=red, " : ((aCurrCxn->mnType == XML_presParOf) ? " color=green, " : " "))
+                       << "label=\"" 
+                       << rtl::OUStringToOString(aCurrCxn->msModelId,
+                                                 RTL_TEXTENCODING_UTF8 ).getStr()
+                       << "\"];" << std::endl;
+            }
+        }
+        else if( aCurrCxn->msSourceId.getLength() || 
+                 aCurrCxn->msDestId.getLength() )
+            output << "\t" 
+                   << normalizeDotName(aCurrCxn->msSourceId).getStr()
+                   << " -> "
+                   << normalizeDotName(aCurrCxn->msDestId).getStr()
+                   << " [label=\"" 
+                   << rtl::OUStringToOString(aCurrCxn->msModelId,
+                                             RTL_TEXTENCODING_UTF8 ).getStr()
+                   << ((aCurrCxn->mnType == XML_presOf) ? "\", color=red]" : ((aCurrCxn->mnType == XML_presParOf) ? "\", color=green]" : "\"]"))
+                   << ";" << std::endl;
+#endif
+
+        const bool bInserted1=getData()->getConnectionNameMap().insert(
+            std::make_pair(aCurrCxn->msModelId,&(*aCurrCxn))).second;
+        (void)bInserted1;
+
+        OSL_ENSURE(bInserted1,"Diagram::build(): non-unique connection model id");
+
+        if( aCurrCxn->mnType == XML_presOf )
+        {
+            DiagramData::StringMap::value_type::second_type& rVec=getData()->getPresOfNameMap()[aCurrCxn->msDestId];
+            rVec.push_back(
+                std::make_pair(
+                    aCurrCxn->msSourceId,sal_Int32(0)));
+        }
+
+        ++aCurrCxn;
+    }
+
+    // assign outline levels
+    DiagramData::StringMap::iterator aPresOfIter=getData()->getPresOfNameMap().begin();
+    const DiagramData::StringMap::iterator aPresOfEnd=getData()->getPresOfNameMap().end();
+    while( aPresOfIter != aPresOfEnd )
+    {
+        DiagramData::StringMap::value_type::second_type::iterator aPresOfNodeIterCalcLevel=aPresOfIter->second.begin();
+        const DiagramData::StringMap::value_type::second_type::iterator aPresOfNodeEnd=aPresOfIter->second.end();
+        while(aPresOfNodeIterCalcLevel != aPresOfNodeEnd)
+        {
+            const sal_Int32 nDepth=calcDepth(aPresOfNodeIterCalcLevel->first, 
+                                             getData()->getConnections());
+            aPresOfNodeIterCalcLevel->second = nDepth != 0 ? nDepth : -1;
+            ++aPresOfNodeIterCalcLevel;
+        }
+
+        ++aPresOfIter;
+    }
+
+#if OSL_DEBUG_LEVEL > 1
+    output << "}" << std::endl;
+#endif
+
+    // TODO
+#if 0
 	OSL_TRACE( "building diagram" );
 	typedef std::map< OUString, dgm::PointPtr > PointsMap;
 	PointsMap aPointsMap;
@@ -240,30 +438,33 @@ void Diagram::build(  )
 	}
 	// check bounds
 	OSL_ENSURE( aRoots.size() == 1, "more than one root" );
-    // #i92239# roots may be empty
-    if( !aRoots.empty() )
-    {
-        mpRoot = aRoots.begin()->second;
-        OSL_TRACE( "root is %s", OUSTRING_TO_CSTR( mpRoot->getPoint()->getModelId() ) );
-        for( PointsTreeMap::iterator iter = aTreeMap.begin();
-             iter != aTreeMap.end(); iter++ )
-        {
-            if(! iter->second->getParent() )
-            {
-                OSL_TRACE("node without parent %s", OUSTRING_TO_CSTR( iter->first ) );
-            }
-        }
-    }
+	mpRoot = aRoots.begin()->second;
+	OSL_TRACE( "root is %s", OUSTRING_TO_CSTR( mpRoot->getPoint()->getModelId() ) );
+	for( PointsTreeMap::iterator iter = aTreeMap.begin();
+		 iter != aTreeMap.end(); iter++ )
+	{
+		if(! iter->second->getParent() ) 
+		{
+			OSL_TRACE("node without parent %s", OUSTRING_TO_CSTR( iter->first ) );
+		}
+	}
+#endif
 }
 
 
 void Diagram::addTo( const ShapePtr & pParentShape )
 {
+    // collect data, init maps
+	build( );
+    
+    // create Shape hierarchy
+    ShapeCreationVisitor aCreationVisitor(pParentShape, *this);
+    mpLayout->getNode()->accept(aCreationVisitor);
+
+#if 0
 	dgm::Points & aPoints( mpData->getPoints( ) );
 	dgm::Points::iterator aPointsIter;
-	build( );
-    if( mpRoot.get() )
-        mpLayout->layout( mpRoot, awt::Point( 0, 0 ) );
+	mpLayout->layout( mpRoot, awt::Point( 0, 0 ) );
 
 	for( aPointsIter = aPoints.begin(); aPointsIter != aPoints.end(); ++aPointsIter )
 	{
@@ -286,6 +487,7 @@ void Diagram::addTo( const ShapePtr & pParentShape )
 	{
 		OSL_TRACE( "Dgm: shape name %s", OUSTRING_TO_CSTR( (*iter)->getName() ) );
 	}
+#endif
 }
 
 OUString Diagram::getLayoutId() const
@@ -298,5 +500,155 @@ OUString Diagram::getLayoutId() const
 	return sLayoutId;
 }
 
+uno::Reference<xml::dom::XDocument> loadFragment( 
+    core::XmlFilterBase& rFilter,
+    const rtl::Reference< core::FragmentHandler >& rxHandler )
+{
+    // load diagramming fragments into DOM representation, that later
+    // gets serialized back to SAX events and parsed
+    return rFilter.importFragment( rxHandler->getFragmentPath() );
+}
+
+void importFragment( core::XmlFilterBase& rFilter,
+                     const uno::Reference<xml::dom::XDocument>& rXDom,
+                     const char* pPropName,
+                     const ShapePtr& pShape,
+                     const rtl::Reference< core::FragmentHandler >& rxHandler )
+{
+    uno::Reference<xml::sax::XFastSAXSerializable> xSerializer( 
+        rXDom, uno::UNO_QUERY_THROW);
+
+    // now serialize DOM tree into internal data structures
+    rFilter.importFragment( rxHandler, xSerializer );
+
+    // not yet
+#if 0
+    // tack XDocument onto shape
+    pShape->getShapeProperties().setProperty(
+        OUString::createFromAscii(pPropName),
+        rXDom);
+#endif
+}
+
+void loadDiagram( const ShapePtr& pShape,
+                  core::XmlFilterBase& rFilter,
+                  const ::rtl::OUString& rDataModelPath,
+                  const ::rtl::OUString& rLayoutPath,
+                  const ::rtl::OUString& rQStylePath,
+                  const ::rtl::OUString& rColorStylePath )
+{
+	DiagramPtr pDiagram( new Diagram() );
+
+    DiagramDataPtr pData( new DiagramData() );
+    pDiagram->setData( pData );
+    
+    DiagramLayoutPtr pLayout( new DiagramLayout() );
+    pDiagram->setLayout( pLayout );
+    
+	// data
+	if( rDataModelPath.getLength() > 0 )
+    {
+        rtl::Reference< core::FragmentHandler > xRef(
+            new DiagramDataFragmentHandler( rFilter, rDataModelPath, pData ));
+
+        importFragment(rFilter,
+                       loadFragment(rFilter,xRef),
+                       "DiagramData",
+                       pShape,
+                       xRef);
+    }
+
+	// layout
+	if( rLayoutPath.getLength() > 0 )
+    {
+        rtl::Reference< core::FragmentHandler > xRef(
+            new DiagramLayoutFragmentHandler( rFilter, rLayoutPath, pLayout ));
+        importFragment(rFilter,
+                       loadFragment(rFilter,xRef),
+                       "DiagramLayout",
+                       pShape,
+                       xRef);
+    }
+
+	// style
+	if( rQStylePath.getLength() > 0 )
+    {
+        rtl::Reference< core::FragmentHandler > xRef(
+            new DiagramQStylesFragmentHandler( rFilter, rQStylePath, pDiagram->getStyles() ));
+        importFragment(rFilter,
+                       loadFragment(rFilter,xRef),
+                       "DiagramQStyle",
+                       pShape,
+                       xRef);
+    }
+
+	// colors
+	if( rColorStylePath.getLength() > 0 )
+    {
+        rtl::Reference< core::FragmentHandler > xRef(
+            new ColorFragmentHandler( rFilter, rColorStylePath, pDiagram->getColors() ));
+        importFragment(rFilter,
+                       loadFragment(rFilter,xRef),
+                       "DiagramColorStyle",
+                       pShape,
+                       xRef);
+    }
+    
+    // diagram loaded. now lump together & attach to shape
+	pDiagram->addTo(pShape);
+}
+
+void loadDiagram( const ShapePtr& pShape,
+                  core::XmlFilterBase& rFilter,
+                  const uno::Reference<xml::dom::XDocument>& rXDataModelDom,
+                  const uno::Reference<xml::dom::XDocument>& rXLayoutDom,
+                  const uno::Reference<xml::dom::XDocument>& rXQStyleDom,
+                  const uno::Reference<xml::dom::XDocument>& rXColorStyleDom )
+{
+	DiagramPtr pDiagram( new Diagram() );
+
+    DiagramDataPtr pData( new DiagramData() );
+    pDiagram->setData( pData );
+    
+    DiagramLayoutPtr pLayout( new DiagramLayout() );
+    pDiagram->setLayout( pLayout );
+
+    OUString aEmpty;
+    
+	// data
+	if( rXDataModelDom.is() )
+        importFragment(rFilter,
+                       rXDataModelDom,
+                       "DiagramData",
+                       pShape,
+                       new DiagramDataFragmentHandler( rFilter, aEmpty, pData ));
+
+	// layout
+	if( rXLayoutDom.is() )
+        importFragment(rFilter,
+                       rXLayoutDom,
+                       "DiagramLayout",
+                       pShape,
+                       new DiagramLayoutFragmentHandler( rFilter, aEmpty, pLayout ));
+
+	// style
+	if( rXQStyleDom.is() )
+        importFragment(rFilter,
+                       rXQStyleDom,
+                       "DiagramQStyle",
+                       pShape,
+                       new DiagramQStylesFragmentHandler( rFilter, aEmpty, pDiagram->getStyles() ));
+
+	// colors
+	if( rXColorStyleDom.is() )
+        importFragment(rFilter,
+                       rXColorStyleDom,
+                       "DiagramColorStyle",
+                       pShape,
+                       new ColorFragmentHandler( rFilter, aEmpty, pDiagram->getColors() ));
+    
+    // diagram loaded. now lump together & attach to shape
+	pDiagram->addTo(pShape);
+}
 
 } }
diff --git oox/source/drawingml/diagram/diagram.hxx oox/source/drawingml/diagram/diagram.hxx
new file mode 100644
index 0000000..9f68ac5
--- /dev/null
+++ oox/source/drawingml/diagram/diagram.hxx
@@ -0,0 +1,319 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_DRAWINGML_DIAGRAM_DIAGRAM_HXX
+#define OOX_DRAWINGML_DIAGRAM_DIAGRAM_HXX
+
+#include <map>
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/enable_shared_from_this.hpp>
+
+#include <rtl/ustring.hxx>
+
+#include "oox/drawingml/shape.hxx"
+#include "oox/drawingml/fillproperties.hxx"
+
+namespace com { namespace sun { namespace star {
+    namespace xml { namespace dom { class XDocument; } }
+} } }
+
+namespace oox { namespace drawingml {
+
+namespace dgm {
+
+/** A Connection 
+ */
+struct Connection
+{
+	Connection() : 
+        mnType( 0 ),
+		mnSourceOrder( 0 ),
+		mnDestOrder( 0 )
+    {}
+
+	void dump();
+
+	sal_Int32 mnType;
+	::rtl::OUString msModelId;
+	::rtl::OUString msSourceId;
+	::rtl::OUString msDestId;
+	::rtl::OUString msParTransId;
+	::rtl::OUString msPresId;
+	::rtl::OUString msSibTransId;
+	sal_Int32 mnSourceOrder;
+	sal_Int32 mnDestOrder;
+	
+};
+
+typedef std::vector< Connection > Connections;
+
+
+/** A point
+ */
+struct Point
+{
+	Point() : 
+        mnType(0),
+        mnMaxChildren(-1),
+        mnPreferredChildren(-1),
+        mnDirection(XML_norm),
+        mnHierarchyBranch(XML_std),
+        mnResizeHandles(XML_rel),
+        mnCustomAngle(-1),
+        mnPercentageNeighbourWidth(-1),
+        mnPercentageNeighbourHeight(-1),
+        mnPercentageOwnWidth(-1),
+        mnPercentageOwnHeight(-1),
+        mnIncludeAngleScale(-1),
+        mnRadiusScale(-1),
+        mnWidthScale(-1),
+        mnHeightScale(-1),
+        mnWidthOverride(-1),
+        mnHeightOverride(-1),
+        mnLayoutStyleCount(-1),
+        mnLayoutStyleIndex(-1),
+
+        mbOrgChartEnabled(false),
+        mbBulletEnabled(false),
+        mbCoherent3DOffset(false),
+        mbCustomHorizontalFlip(false),
+        mbCustomVerticalFlip(false),
+        mbCustomText(false),
+        mbIsPlaceholder(false)
+    {}
+	void dump();
+
+    ShapePtr      mpShape;
+
+    rtl::OUString msCnxId;
+    rtl::OUString msModelId;
+    rtl::OUString msColorTransformCategoryId;
+    rtl::OUString msColorTransformTypeId;
+    rtl::OUString msLayoutCategoryId;
+    rtl::OUString msLayoutTypeId;
+    rtl::OUString msPlaceholderText;
+    rtl::OUString msPresentationAssociationId;
+    rtl::OUString msPresentationLayoutName;
+    rtl::OUString msPresentationLayoutStyleLabel;
+    rtl::OUString msQuickStyleCategoryId;
+    rtl::OUString msQuickStyleTypeId; 
+
+    sal_Int32     mnType;
+    sal_Int32     mnMaxChildren;
+    sal_Int32     mnPreferredChildren;
+    sal_Int32     mnDirection;
+    sal_Int32     mnHierarchyBranch;
+    sal_Int32     mnResizeHandles;
+    sal_Int32     mnCustomAngle;
+    sal_Int32     mnPercentageNeighbourWidth;
+    sal_Int32     mnPercentageNeighbourHeight;
+    sal_Int32     mnPercentageOwnWidth;
+    sal_Int32     mnPercentageOwnHeight;
+    sal_Int32     mnIncludeAngleScale;
+    sal_Int32     mnRadiusScale;
+    sal_Int32     mnWidthScale;
+    sal_Int32     mnHeightScale;
+    sal_Int32     mnWidthOverride;
+    sal_Int32     mnHeightOverride;
+    sal_Int32     mnLayoutStyleCount;
+    sal_Int32     mnLayoutStyleIndex;
+
+    bool          mbOrgChartEnabled;
+    bool          mbBulletEnabled;
+    bool          mbCoherent3DOffset;
+    bool          mbCustomHorizontalFlip;
+    bool          mbCustomVerticalFlip;
+    bool          mbCustomText;
+    bool          mbIsPlaceholder;
+};
+
+typedef std::vector< Point >        Points;
+
+}
+
+class LayoutNode;
+typedef boost::shared_ptr< LayoutNode > LayoutNodePtr;
+
+////////////////////
+
+class DiagramData 
+{
+public:
+    typedef std::map< rtl::OUString, dgm::Point* > PointNameMap;
+    typedef std::map< rtl::OUString, 
+                      std::vector<dgm::Point*> >   PointsNameMap;
+    typedef std::map< rtl::OUString, const dgm::Connection* > ConnectionNameMap;
+    typedef std::map< rtl::OUString, 
+                      std::vector<std::pair<rtl::OUString,sal_Int32> > > StringMap;
+
+	DiagramData();
+	FillPropertiesPtr & getFillProperties()
+		{ return mpFillProperties; }
+	dgm::Connections & getConnections()
+		{ return maConnections; }
+	dgm::Points & getPoints()
+		{ return maPoints; }
+	ConnectionNameMap & getConnectionNameMap()
+		{ return maConnectionNameMap; }
+	StringMap & getPresOfNameMap()
+		{ return maPresOfNameMap; }
+	PointNameMap & getPointNameMap()
+		{ return maPointNameMap; }
+	PointsNameMap & getPointsPresNameMap()
+		{ return maPointsPresNameMap; }
+	void dump();
+private:
+    FillPropertiesPtr mpFillProperties;
+    dgm::Connections  maConnections;
+    dgm::Points       maPoints;
+    PointNameMap      maPointNameMap;
+    PointsNameMap     maPointsPresNameMap;
+    ConnectionNameMap maConnectionNameMap;
+    StringMap         maPresOfNameMap;
+};
+
+typedef boost::shared_ptr< DiagramData > DiagramDataPtr;
+
+
+
+////////////////////
+
+class DiagramLayout
+{
+public:
+	void setDefStyle( const ::rtl::OUString & sDefStyle )
+		{ msDefStyle = sDefStyle; }
+	void setMinVer( const ::rtl::OUString & sMinVer )
+		{ msMinVer = sMinVer; }
+	void setUniqueId( const ::rtl::OUString & sUniqueId )
+		{ msUniqueId = sUniqueId; }
+	const ::rtl::OUString & getUniqueId()
+		{ return msUniqueId; }
+	void setTitle( const ::rtl::OUString & sTitle )
+		{ msTitle = sTitle; }
+	void setDesc( const ::rtl::OUString & sDesc )
+		{ msDesc = sDesc; }
+
+	LayoutNodePtr & getNode()
+		{ return mpNode; }
+	const LayoutNodePtr & getNode() const
+		{ return mpNode; }
+	DiagramDataPtr & getSampData()
+		{ return mpSampData; }
+	const DiagramDataPtr & getSampData() const
+		{ return mpSampData; }
+	DiagramDataPtr & getStyleData()
+		{ return mpStyleData; }
+	const DiagramDataPtr & getStyleData() const
+		{ return mpStyleData; }
+
+	void layout( const dgm::Points & pTree, const com::sun::star::awt::Point & pt );
+
+private:
+	::rtl::OUString msDefStyle;
+	::rtl::OUString msMinVer;
+	::rtl::OUString msUniqueId;	
+
+	::rtl::OUString msTitle;
+	::rtl::OUString msDesc;
+	LayoutNodePtr  mpNode;
+	DiagramDataPtr mpSampData;
+	DiagramDataPtr mpStyleData;
+	// TODO
+	// catLst
+	// clrData
+};
+
+typedef boost::shared_ptr< DiagramLayout > DiagramLayoutPtr;
+
+///////////////////////
+
+struct DiagramStyle
+{
+    ShapeStyleRef maFillStyle;
+    ShapeStyleRef maLineStyle;
+    ShapeStyleRef maEffectStyle;
+    ShapeStyleRef maTextStyle;
+};
+
+typedef std::map<rtl::OUString,DiagramStyle> DiagramQStyleMap;
+
+struct DiagramColor
+{
+    oox::drawingml::Color maFillColor;
+    oox::drawingml::Color maLineColor;
+    oox::drawingml::Color maEffectColor;
+    oox::drawingml::Color maTextFillColor;
+    oox::drawingml::Color maTextLineColor;
+    oox::drawingml::Color maTextEffectColor;
+};
+
+typedef std::map<rtl::OUString,DiagramColor> DiagramColorMap;
+
+///////////////////////
+
+class Diagram
+{
+public:
+	void setData( const DiagramDataPtr & );
+	DiagramDataPtr getData() const
+		{
+			return mpData;
+		}
+	void setLayout( const DiagramLayoutPtr & );
+	DiagramLayoutPtr getLayout() const
+		{
+			return mpLayout;
+		}
+
+    DiagramQStyleMap& getStyles() { return maStyles; }
+    const DiagramQStyleMap& getStyles() const { return maStyles; }
+    DiagramColorMap& getColors() { return maColors; }
+    const DiagramColorMap& getColors() const { return maColors; }
+
+	void addTo( const ShapePtr & pShape );
+	::rtl::OUString getLayoutId() const;
+private:
+	void build( );
+	DiagramDataPtr                             mpData;
+	DiagramLayoutPtr                           mpLayout;
+	DiagramQStyleMap                           maStyles;
+	DiagramColorMap                            maColors;
+	std::map< ::rtl::OUString, ShapePtr >      maShapeMap;
+};
+
+
+typedef boost::shared_ptr< Diagram > DiagramPtr;
+
+} }
+
+#endif
diff --git oox/source/drawingml/diagram/diagramdefinitioncontext.cxx oox/source/drawingml/diagram/diagramdefinitioncontext.cxx
index c28e8eb..296dc4e 100644
--- oox/source/drawingml/diagram/diagramdefinitioncontext.cxx
+++ oox/source/drawingml/diagram/diagramdefinitioncontext.cxx
@@ -30,10 +30,9 @@
 
 #include "oox/core/skipcontext.hxx"
 #include "oox/core/namespaces.hxx"
-#include "oox/helper/helper.hxx"
-#include "layoutnodecontext.hxx"
 #include "diagramdefinitioncontext.hxx"
-#include "oox/drawingml/diagram/datamodelcontext.hxx"
+#include "layoutnodecontext.hxx"
+#include "datamodelcontext.hxx"
 
 using namespace ::oox::core;
 using namespace ::com::sun::star::uno;
@@ -90,9 +89,15 @@ DiagramDefinitionContext::createFastChildContext( ::sal_Int32 aElement,
 		mpLayout->setDesc( xAttribs->getOptionalValue( XML_val ) );
 		break;
 	case NMSP_DIAGRAM|XML_layoutNode:
-		mpLayout->getNode().reset( new LayoutNode() );
-        xRet.set( new LayoutNodeContext( *this, xAttribs, mpLayout->getNode() ) );
+    {
+		LayoutNodePtr pNode( new LayoutNode() );
+		mpLayout->getNode() = pNode;
+        pNode->setChildOrder( xAttribs->getOptionalValueToken( XML_chOrder, XML_b ) );
+        pNode->setMoveWith( xAttribs->getOptionalValue( XML_moveWith ) );
+        pNode->setStyleLabel( xAttribs->getOptionalValue( XML_styleLbl ) );
+        xRet.set( new LayoutNodeContext( *this, xAttribs, pNode ) );
 		break;
+    }
  	case NMSP_DIAGRAM|XML_clrData:
 		// TODO, does not matter for the UI. skip.
         xRet.set( new SkipContext( *this ) );
diff --git oox/source/drawingml/diagram/diagramdefinitioncontext.hxx oox/source/drawingml/diagram/diagramdefinitioncontext.hxx
index c427967..408b8da 100644
--- oox/source/drawingml/diagram/diagramdefinitioncontext.hxx
+++ oox/source/drawingml/diagram/diagramdefinitioncontext.hxx
@@ -32,7 +32,7 @@
 #define OOX_DRAWINGML_DIAGRAMDEFINITIONCONTEXT_HXX
 
 #include "oox/core/contexthandler.hxx"
-#include "oox/drawingml/diagram/diagram.hxx"
+#include "diagram.hxx"
 
 namespace oox { namespace drawingml {
 
diff --git oox/source/drawingml/diagram/diagramfragmenthandler.cxx oox/source/drawingml/diagram/diagramfragmenthandler.cxx
index fc5fe05..58a839b 100644
--- oox/source/drawingml/diagram/diagramfragmenthandler.cxx
+++ oox/source/drawingml/diagram/diagramfragmenthandler.cxx
@@ -30,10 +30,12 @@
 
 #include <osl/diagnose.h>
 
-#include "oox/drawingml/diagram/diagramfragmenthandler.hxx"
-#include "oox/drawingml/diagram/datamodelcontext.hxx"
 #include "oox/core/namespaces.hxx"
+#include "oox/drawingml/colorchoicecontext.hxx"
+#include "oox/drawingml/stylematrixreferencecontext.hxx"
 #include "diagramdefinitioncontext.hxx"
+#include "diagramfragmenthandler.hxx"
+#include "datamodelcontext.hxx"
 
 
 using namespace ::oox::core;
@@ -134,94 +136,144 @@ DiagramLayoutFragmentHandler::createFastChildContext( ::sal_Int32 aElement,
 ///////////////////////
 
 DiagramQStylesFragmentHandler::DiagramQStylesFragmentHandler( XmlFilterBase& rFilter,
-														const OUString& rFragmentPath,
-														const DiagramQStylesPtr pDataPtr )
-	throw( )
-    : FragmentHandler( rFilter, rFragmentPath )
-	, mpDataPtr( pDataPtr )
+                                                              const OUString& rFragmentPath,
+                                                              DiagramQStyleMap& rStylesMap ) :
+    FragmentHandler2( rFilter, rFragmentPath ),
+    maStyleName(),
+    maStyleEntry(),
+	mrStylesMap( rStylesMap )
+{}
+
+::oox::core::ContextWrapper DiagramQStylesFragmentHandler::createStyleMatrixContext(
+    sal_Int32 nElement, 
+    const AttributeList& rAttribs,
+    ShapeStyleRef& o_rStyle )
 {
+    o_rStyle.mnThemedIdx = (nElement == (NMSP_DRAWINGML|XML_fontRef)) ? 
+        rAttribs.getToken( XML_idx, XML_none ) : rAttribs.getInteger( XML_idx, 0 );
+    return new StyleMatrixReferenceContext( *this, 
+                                            o_rStyle.maPhClr );
 }
 
-DiagramQStylesFragmentHandler::~DiagramQStylesFragmentHandler( ) throw ()
+::oox::core::ContextWrapper DiagramQStylesFragmentHandler::onCreateContext( sal_Int32 nElement, 
+                                                                            const AttributeList& rAttribs )
 {
-
+    // state-table like way of navigating the color fragment. we
+    // currently ignore everything except styleLbl in the colorsDef
+    // element
+    switch( getCurrentElement() )
+    {
+        case XML_ROOT_CONTEXT:
+            return nElement == (NMSP_DIAGRAM|XML_styleDef);
+        case NMSP_DIAGRAM|XML_styleDef:
+            return nElement == (NMSP_DIAGRAM|XML_styleLbl);
+        case NMSP_DIAGRAM|XML_styleLbl:
+            return nElement == (NMSP_DIAGRAM|XML_style);
+        case NMSP_DIAGRAM|XML_style:
+        {
+            switch( nElement )
+            {
+                case NMSP_DRAWINGML|XML_lnRef :     // CT_StyleMatrixReference
+                    return createStyleMatrixContext(nElement,rAttribs,
+                                                    maStyleEntry.maLineStyle);
+                case NMSP_DRAWINGML|XML_fillRef :   // CT_StyleMatrixReference
+                    return createStyleMatrixContext(nElement,rAttribs,
+                                                    maStyleEntry.maFillStyle);
+                case NMSP_DRAWINGML|XML_effectRef : // CT_StyleMatrixReference
+                    return createStyleMatrixContext(nElement,rAttribs,
+                                                    maStyleEntry.maEffectStyle);
+                case NMSP_DRAWINGML|XML_fontRef :   // CT_FontRe    ference
+                    return createStyleMatrixContext(nElement,rAttribs,
+                                                    maStyleEntry.maTextStyle);
+            }
+            return false;
+        }
+    }
+
+    return false;
 }
 
-void SAL_CALL DiagramQStylesFragmentHandler::endDocument()
-	throw (SAXException, RuntimeException)
+void DiagramQStylesFragmentHandler::onStartElement( const AttributeList& rAttribs )
 {
-
+    if( getCurrentElement() == (NMSP_DIAGRAM|XML_styleLbl) )
+    {
+        maStyleName = rAttribs.getString( XML_name, OUString() );
+        maStyleEntry = mrStylesMap[maStyleName];
+    }
 }
 
-
-Reference< XFastContextHandler > SAL_CALL
-DiagramQStylesFragmentHandler::createFastChildContext( ::sal_Int32 aElement,
-													const Reference< XFastAttributeList >& )
-	throw ( SAXException, RuntimeException)
+void DiagramQStylesFragmentHandler::onEndElement( const ::rtl::OUString& )
 {
-	Reference< XFastContextHandler > xRet;
-
-	switch( aElement )
-	{
-	case NMSP_DIAGRAM|XML_styleDef:
-		// TODO
-		break;
-	default:
-		break;
-	}
-
-	if( !xRet.is() )
-        xRet = getFastContextHandler();
-
-	return xRet;
+    if( getCurrentElement() == (NMSP_DIAGRAM|XML_styleLbl) )
+        mrStylesMap[maStyleName] = maStyleEntry;
 }
 
-/////////////////////
-
-DiagramColorsFragmentHandler::DiagramColorsFragmentHandler( XmlFilterBase& rFilter,
-														const OUString& rFragmentPath,
-														const DiagramColorsPtr pDataPtr )
-	throw( )
-    : FragmentHandler( rFilter, rFragmentPath )
-	, mpDataPtr( pDataPtr )
-{
-}
+///////////////////////
 
-DiagramColorsFragmentHandler::~DiagramColorsFragmentHandler( ) throw ()
+ColorFragmentHandler::ColorFragmentHandler( ::oox::core::XmlFilterBase& rFilter,
+                                            const ::rtl::OUString& rFragmentPath,
+                                            DiagramColorMap& rColorsMap ) :
+    FragmentHandler2(rFilter,rFragmentPath),
+    maColorName(),
+    maColorEntry(),
+    mrColorsMap(rColorsMap)
+{}
+
+::oox::core::ContextWrapper ColorFragmentHandler::onCreateContext( sal_Int32 nElement, 
+                                                                   const AttributeList& /*rAttribs*/ )
 {
-
+    // state-table like way of navigating the color fragment. we
+    // currently ignore everything except styleLbl in the colorsDef
+    // element
+    switch( getCurrentElement() )
+    {
+        case XML_ROOT_CONTEXT:
+            return nElement == (NMSP_DIAGRAM|XML_colorsDef);
+        case NMSP_DIAGRAM|XML_colorsDef:
+            return nElement == (NMSP_DIAGRAM|XML_styleLbl);
+        case NMSP_DIAGRAM|XML_styleLbl:
+            return  (nElement == (NMSP_DIAGRAM|XML_fillClrLst)) ||
+                (nElement == (NMSP_DIAGRAM|XML_linClrLst)) ||
+                (nElement == (NMSP_DIAGRAM|XML_effectClrLst)) ||
+                (nElement == (NMSP_DIAGRAM|XML_txLinClrLst)) ||
+                (nElement == (NMSP_DIAGRAM|XML_txFillClrLst)) ||
+                (nElement == (NMSP_DIAGRAM|XML_txEffectClrLst));
+
+        // the actual colors - defer to color fragment handlers. 
+            
+        // TODO(F1): well, actually, there might be *several* color
+        // definitions in it, after all it's called list. but
+        // apparently colorChoiceContext doesn't handle that anyway...
+        case NMSP_DIAGRAM|XML_fillClrLst:
+            return new colorChoiceContext( *this, maColorEntry.maFillColor );
+        case NMSP_DIAGRAM|XML_linClrLst:
+            return new colorChoiceContext( *this, maColorEntry.maLineColor );
+        case NMSP_DIAGRAM|XML_effectClrLst:
+            return new colorChoiceContext( *this, maColorEntry.maEffectColor );
+        case NMSP_DIAGRAM|XML_txFillClrLst:
+            return new colorChoiceContext( *this, maColorEntry.maTextFillColor );
+        case NMSP_DIAGRAM|XML_txLinClrLst:
+            return new colorChoiceContext( *this, maColorEntry.maTextLineColor );
+        case NMSP_DIAGRAM|XML_txEffectClrLst:
+            return new colorChoiceContext( *this, maColorEntry.maTextEffectColor );
+    }
+
+    return false;
 }
 
-void SAL_CALL DiagramColorsFragmentHandler::endDocument()
-	throw (SAXException, RuntimeException)
+void ColorFragmentHandler::onStartElement( const AttributeList& rAttribs )
 {
-
+    if( getCurrentElement() == (NMSP_DIAGRAM|XML_styleLbl) )
+    {
+        maColorName = rAttribs.getString( XML_name, OUString() );
+        maColorEntry = mrColorsMap[maColorName];
+    }
 }
 
-
-Reference< XFastContextHandler > SAL_CALL
-DiagramColorsFragmentHandler::createFastChildContext( ::sal_Int32 aElement,
-													const Reference< XFastAttributeList >& )
-	throw ( SAXException, RuntimeException)
+void ColorFragmentHandler::onEndElement( const ::rtl::OUString& )
 {
-	Reference< XFastContextHandler > xRet;
-
-	switch( aElement )
-	{
-	case NMSP_DIAGRAM|XML_colorsDef:
-		// TODO
-		break;
-	default:
-		break;
-	}
-
-	if( !xRet.is() )
-        xRet = getFastContextHandler();
-
-	return xRet;
+    if( getCurrentElement() == (NMSP_DIAGRAM|XML_styleLbl) )
+        mrColorsMap[maColorName] = maColorEntry;
 }
 
-
-
-
 } }
diff --git oox/source/drawingml/diagram/diagramfragmenthandler.hxx oox/source/drawingml/diagram/diagramfragmenthandler.hxx
new file mode 100644
index 0000000..67bfbb2
--- /dev/null
+++ oox/source/drawingml/diagram/diagramfragmenthandler.hxx
@@ -0,0 +1,117 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: diagramfragmenthandler.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+#ifndef OOX_DRAWINGML_DIAGRAMFRAGMENTHANDLER
+#define OOX_DRAWINGML_DIAGRAMFRAGMENTHANDLER
+
+#include "oox/core/fragmenthandler.hxx"
+#include "oox/core/fragmenthandler2.hxx"
+#include "oox/drawingml/diagram/diagram.hxx"
+
+namespace oox { namespace drawingml {
+
+
+class DiagramDataFragmentHandler : public ::oox::core::FragmentHandler
+{
+public:
+    DiagramDataFragmentHandler( oox::core::XmlFilterBase& rFilter, const ::rtl::OUString& rFragmentPath, const DiagramDataPtr pDataPtr ) throw();
+	virtual ~DiagramDataFragmentHandler() throw();
+
+    virtual void SAL_CALL endDocument() throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+
+private:
+
+	DiagramDataPtr	mpDataPtr;
+};
+
+
+
+class DiagramLayoutFragmentHandler : public ::oox::core::FragmentHandler
+{
+public:
+    DiagramLayoutFragmentHandler( oox::core::XmlFilterBase& rFilter, const ::rtl::OUString& rFragmentPath, const DiagramLayoutPtr pDataPtr ) throw();
+	virtual ~DiagramLayoutFragmentHandler() throw();
+
+    virtual void SAL_CALL endDocument() throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+
+private:
+
+	DiagramLayoutPtr	mpDataPtr;
+};
+
+class DiagramQStylesFragmentHandler : public ::oox::core::FragmentHandler2
+{
+public:
+    DiagramQStylesFragmentHandler( 
+        oox::core::XmlFilterBase& rFilter, 
+        const ::rtl::OUString& rFragmentPath,
+        DiagramQStyleMap& rStylesMap );
+
+    virtual ::oox::core::ContextWrapper onCreateContext( sal_Int32 nElement, const AttributeList& rAttribs );
+
+    virtual void onStartElement( const AttributeList& rAttribs );
+    virtual void onEndElement( const ::rtl::OUString& rChars );
+
+private:
+    ::oox::core::ContextWrapper createStyleMatrixContext(sal_Int32 nElement, 
+                                                         const AttributeList& rAttribs,
+                                                         ShapeStyleRef& o_rStyle);
+
+    ::rtl::OUString   maStyleName;
+    DiagramStyle      maStyleEntry;
+	DiagramQStyleMap& mrStylesMap;
+};
+
+class ColorFragmentHandler : public ::oox::core::FragmentHandler2
+{
+public:
+    ColorFragmentHandler(
+        ::oox::core::XmlFilterBase& rFilter,
+        const ::rtl::OUString& rFragmentPath,
+        DiagramColorMap& rColorMap );
+
+    virtual ::oox::core::ContextWrapper onCreateContext( sal_Int32 nElement, const AttributeList& rAttribs );
+
+    virtual void onStartElement( const AttributeList& rAttribs );
+    virtual void onEndElement( const ::rtl::OUString& rChars );
+
+private:
+    ::rtl::OUString   maColorName;
+    DiagramColor      maColorEntry;
+    DiagramColorMap&  mrColorsMap;
+};
+
+} }
+
+
+#endif
diff --git oox/source/drawingml/diagram/diagramlayoutatoms.cxx oox/source/drawingml/diagram/diagramlayoutatoms.cxx
index 8fad074..ef9b760 100644
--- oox/source/drawingml/diagram/diagramlayoutatoms.cxx
+++ oox/source/drawingml/diagram/diagramlayoutatoms.cxx
@@ -28,14 +28,23 @@
  *
  ************************************************************************/
 
-#include "oox/drawingml/diagram/diagramlayoutatoms.hxx"
+#include "diagramlayoutatoms.hxx"
 
 #include <functional>
 #include <boost/bind.hpp>
 
+#include <basegfx/numeric/ftools.hxx>
+
 #include "oox/helper/attributelist.hxx"
+#include "oox/drawingml/fillproperties.hxx"
+#include "oox/drawingml/lineproperties.hxx"
+#include "oox/drawingml/textbody.hxx"
+#include "oox/drawingml/textparagraph.hxx"
+#include "oox/drawingml/textrun.hxx"
+#include "diagramlayoutatoms.hxx"
 #include "layoutnodecontext.hxx"
 
+using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::xml::sax;
 using namespace ::oox::core;
@@ -45,7 +54,7 @@ namespace oox { namespace drawingml {
 
 IteratorAttr::IteratorAttr( )
 	: mnAxis( 0 )
-	, mnCnt( 0 )
+	, mnCnt( -1 )
 	, mbHideLastTrans( false )
 	, mnPtType( 0 )
 	, mnSt( 0 )
@@ -57,7 +66,7 @@ void IteratorAttr::loadFromXAttr( const Reference< XFastAttributeList >& xAttr )
 {
 	AttributeList attr( xAttr );
 	mnAxis = xAttr->getOptionalValueToken( XML_axis, 0 );
-	mnCnt = attr.getInteger( XML_cnt, 0 );
+	mnCnt = attr.getInteger( XML_cnt, -1 );
 	mbHideLastTrans = attr.getBool( XML_hideLastTrans, false );
 	mnPtType = xAttr->getOptionalValueToken( XML_ptType, 0 );
 	mnSt = attr.getInteger( XML_st, 0 );
@@ -90,55 +99,673 @@ void LayoutAtom::dump(int level)
 	OSL_TRACE( "level = %d - %s of type %s", level,
 			   OUSTRING_TO_CSTR( msName ),
 			   typeid(*this).name() );
-	std::for_each( mpChildNodes.begin(), mpChildNodes.end(),
-				  boost::bind( &LayoutAtom::dump, _1, level + 1 ) );
+    const std::vector<LayoutAtomPtr>& pChildren=getChildren();
+	std::for_each( pChildren.begin(), pChildren.end(),
+                   boost::bind( &LayoutAtom::dump, _1, level + 1 ) );
+}
+
+
+ForEachAtom::ForEachAtom(const Reference< XFastAttributeList >& xAttributes) 
+{
+    maIter.loadFromXAttr(xAttributes);
+}
+
+void ForEachAtom::accept( LayoutAtomVisitor& rVisitor )
+{
+    rVisitor.visit(*this);
+}
+
+void ChooseAtom::accept( LayoutAtomVisitor& rVisitor )
+{
+    rVisitor.visit(*this);
+}
+
+ConditionAtom::ConditionAtom(const Reference< XFastAttributeList >& xAttributes) : 
+    mbElse( false )
+{
+    maIter.loadFromXAttr( xAttributes );
+    maCond.loadFromXAttr( xAttributes );
+}
+
+const std::vector<LayoutAtomPtr>& ConditionAtom::getChildren() const
+{
+    bool bDecisionVar=true;
+    // HACK
+    if( maCond.mnFunc==XML_var && maCond.mnArg==XML_dir && 
+        maCond.mnOp==XML_equ && !maCond.msVal.equalsAscii("norm") )
+        bDecisionVar=false;
+
+    if( bDecisionVar )
+        return mpChildNodes;
+    else
+        return mpElseChildNodes;
+}
+
+void ConditionAtom::accept( LayoutAtomVisitor& rVisitor )
+{
+    rVisitor.visit(*this);
+}
+
+void ConditionAtom::addChild( const LayoutAtomPtr & pNode )
+{
+    if( mbElse )
+        mpElseChildNodes.push_back( pNode ); 
+    else
+        mpChildNodes.push_back( pNode ); 
+}
+
+void ConstraintAtom::accept( LayoutAtomVisitor& rVisitor )
+{
+    rVisitor.visit(*this);
+}
+
+void AlgAtom::accept( LayoutAtomVisitor& rVisitor )
+{
+    rVisitor.visit(*this);
+}
+
+void AlgAtom::layoutShape( const ShapePtr& rShape, 
+                           const Diagram& rDgm,
+                           const rtl::OUString& rName ) const
+{
+    switch(mnType)
+    {
+        case XML_composite:
+        {
+            if( rShape->getChildren().empty() )
+            {
+                rShape->setSize(awt::Size(50,50));
+                break;
+            }
+
+            // just put stuff below each other
+            const sal_Int32 nIncX=0;
+            const sal_Int32 nIncY=1;
+
+            std::vector<ShapePtr>::const_iterator aCurrShape=rShape->getChildren().begin();
+            const std::vector<ShapePtr>::const_iterator aLastShape=rShape->getChildren().end();
+
+            // find biggest shape
+            awt::Size aMaxSize;
+            while( aCurrShape != aLastShape )
+            {
+                const awt::Size& sz=(*aCurrShape)->getSize();
+
+                aMaxSize.Width = std::max(
+                    aMaxSize.Width,
+                    sz.Width);
+                aMaxSize.Height = std::max(
+                    aMaxSize.Height,
+                    sz.Height);
+
+                ++aCurrShape;
+            }
+
+            aCurrShape=rShape->getChildren().begin();
+            const awt::Point aStartPos=(*aCurrShape)->getPosition();
+            awt::Point aCurrPos=aStartPos;
+            awt::Size  aTotalSize;
+            aTotalSize.Width = aMaxSize.Width;
+            while( aCurrShape != aLastShape )
+            {
+                const awt::Size& sz=(*aCurrShape)->getSize();
+                (*aCurrShape)->setPosition(aCurrPos);
+                (*aCurrShape)->setSize(
+                    awt::Size(aMaxSize.Width,
+                              sz.Height));
+
+                aTotalSize.Height = std::max(
+                    aTotalSize.Height,
+                    aCurrPos.Y + sz.Height);
+
+                aCurrPos.X += nIncX*sz.Width;
+                aCurrPos.Y += nIncY*sz.Height;
+
+                ++aCurrShape;
+            }
+
+            rShape->setSize(aTotalSize);
+            break;
+        }
+
+        case XML_conn:
+            break;
+
+        case XML_cycle:
+        {
+            if( rShape->getChildren().empty() )
+            {
+                rShape->setSize(awt::Size(50,50));
+                break;
+            }
+
+            const sal_Int32 nStartAngle=maMap.count(XML_stAng) ? maMap.find(XML_stAng)->second : 0;
+            const sal_Int32 nSpanAngle=maMap.count(XML_spanAng) ? maMap.find(XML_spanAng)->second : 360;
+
+            std::vector<ShapePtr>::const_iterator aCurrShape=rShape->getChildren().begin();
+            const std::vector<ShapePtr>::const_iterator aLastShape=rShape->getChildren().end();
+            const sal_Int32 nShapes=aLastShape-aCurrShape;
+
+            // find biggest shape
+            awt::Size aMaxSize;
+            while( aCurrShape != aLastShape )
+            {
+                const awt::Size& sz=(*aCurrShape)->getSize();
+
+                aMaxSize.Width = std::max(
+                    aMaxSize.Width,
+                    sz.Width);
+                aMaxSize.Height = std::max(
+                    aMaxSize.Height,
+                    sz.Height);
+
+                ++aCurrShape;
+            }
+
+            // layout shapes
+            const sal_Int32 nMaxDim=std::max(aMaxSize.Width,aMaxSize.Height);
+            awt::Size aTotalSize;
+            aCurrShape=rShape->getChildren().begin();
+            for( sal_Int32 i=0; i<nShapes; ++i, ++aCurrShape )
+            {
+                const awt::Size& sz=(*aCurrShape)->getSize();
+
+                const double r=nShapes*nMaxDim/F_2PI * 360.0/nSpanAngle;
+                const awt::Point aCurrPos(
+                    r + r*sin( (double(i)*nSpanAngle/nShapes + nStartAngle)*F_PI180 ),
+                    r - r*cos( (double(i)*nSpanAngle/nShapes + nStartAngle)*F_PI180 ) );
+                (*aCurrShape)->setPosition(aCurrPos);
+
+                aTotalSize.Width = std::max(
+                    aTotalSize.Width,
+                    aCurrPos.X + sz.Width);
+                aTotalSize.Height = std::max(
+                    aTotalSize.Height,
+                    aCurrPos.Y + sz.Height);
+            }
+
+            rShape->setSize(aTotalSize);
+            break;
+        }
+
+        case XML_hierChild:
+        case XML_hierRoot:
+            break;
+
+        case XML_lin:
+        {
+            if( rShape->getChildren().empty() )
+            {
+                rShape->setSize(awt::Size(50,50));
+                break;
+            }
+
+            const sal_Int32 nDir=maMap.count(XML_linDir) ? maMap.find(XML_linDir)->second : XML_fromL;
+            const sal_Int32 nIncX=nDir==XML_fromL ? 1 : (nDir==XML_fromR ? -1 : 0);
+            const sal_Int32 nIncY=nDir==XML_fromT ? 1 : (nDir==XML_fromB ? -1 : 0);
+
+            std::vector<ShapePtr>::const_iterator aCurrShape=rShape->getChildren().begin();
+            const std::vector<ShapePtr>::const_iterator aLastShape=rShape->getChildren().end();
+            const awt::Point aStartPos=(*aCurrShape)->getPosition();
+            awt::Point aCurrPos=aStartPos;
+            awt::Size  aTotalSize;
+            while( aCurrShape != aLastShape )
+            {
+                const awt::Size& sz=(*aCurrShape)->getSize();
+                (*aCurrShape)->setPosition(aCurrPos);
+
+                aTotalSize.Width = std::max(
+                    aTotalSize.Width,
+                    aCurrPos.X + sz.Width);
+                aTotalSize.Height = std::max(
+                    aTotalSize.Height,
+                    aCurrPos.Y + sz.Height);
+
+                // HACK: the spacing is arbitrary
+                aCurrPos.X += nIncX*(sz.Width+5);
+                aCurrPos.Y += nIncY*(sz.Height+5);
+
+                ++aCurrShape;
+            }
+
+            rShape->setSize(aTotalSize);
+            break;
+        }
+
+        case XML_pyra:
+        case XML_snake:
+            break;
+
+        case XML_sp:
+            // HACK. Handled one level higher. Or rather, planned to
+            break;
+
+        case XML_tx:
+        {
+            TextBodyPtr pTextBody=rShape->getTextBody();
+            if( !pTextBody ||
+                pTextBody->getParagraphs().empty() ||
+                pTextBody->getParagraphs().front()->getRuns().empty() )
+            {
+                rShape->setSize(awt::Size(5,5));
+                break;
+            }
+
+            // HACK - count chars & paragraphs to come up with *some*
+            // notion of necessary size
+            const sal_Int32 nHackyFontHeight=50;
+            const sal_Int32 nHackyFontWidth=20;
+            awt::Size aTotalSize;
+            for( sal_Int32 nPara=0; nPara<pTextBody->getParagraphs().size(); ++nPara )
+            {
+                aTotalSize.Height += nHackyFontHeight;
+
+                sal_Int32 nLocalWidth=0;
+                for( sal_Int32 nRun=0; nRun<pTextBody->getParagraphs().at(nPara)->getRuns().size(); ++nRun )
+                    nLocalWidth += 
+                        pTextBody->getParagraphs().at(nPara)->getRuns().at(nRun)->getText().getLength() 
+                        * nHackyFontWidth;
+
+                aTotalSize.Width = std::max(
+                    aTotalSize.Width,
+                    nLocalWidth);
+            }
+
+            rShape->setSize(aTotalSize);
+        }
+
+        default:
+            break;
+    }
+
+    OSL_TRACE("Layouting shape %s: (%d,%d,%d,%d)",
+              OUSTRING_TO_CSTR( rName ),
+              rShape->getPosition().X,
+              rShape->getPosition().Y,
+              rShape->getSize().Width,
+              rShape->getSize().Height);
+}
+
+void LayoutNode::accept( LayoutAtomVisitor& rVisitor )
+{
+    rVisitor.visit(*this);
+}
+
+bool LayoutNode::setupShape( const ShapePtr& rShape, const Diagram& rDgm, sal_Int32 nIdx ) const
+{
+    // find the data node to grab text from
+    DiagramData::PointsNameMap::const_iterator aDataNode=rDgm.getData()->getPointsPresNameMap().find(msName);
+    if( aDataNode != rDgm.getData()->getPointsPresNameMap().end() )
+    {
+        OSL_TRACE( "Filling content from %d th layout node named \"%s\", modelId \"%s\"", 
+                   nIdx,
+                   OUSTRING_TO_CSTR( msName ),
+                   OUSTRING_TO_CSTR( aDataNode->second.at(nIdx)->msModelId ) );
+        
+        // got the presentation node - now, need the actual data node:
+        const DiagramData::StringMap::const_iterator aNodeName=rDgm.getData()->getPresOfNameMap().find(
+            aDataNode->second.at(nIdx)->msModelId);
+        if( aNodeName != rDgm.getData()->getPresOfNameMap().end() )
+        {
+            DiagramData::StringMap::value_type::second_type::const_iterator aVecIter=aNodeName->second.begin();
+            const DiagramData::StringMap::value_type::second_type::const_iterator aVecEnd=aNodeName->second.end();
+            while( aVecIter != aVecEnd )
+            {
+                DiagramData::PointNameMap::const_iterator aDataNode2=rDgm.getData()->getPointNameMap().find(aVecIter->first);
+                if( aVecIter->second == 0 )
+                {
+                    // grab shape attr from topmost element(s)
+                    rShape->getShapeProperties() = aDataNode2->second->mpShape->getShapeProperties();
+                    rShape->getLineProperties() = aDataNode2->second->mpShape->getLineProperties();
+                    rShape->getFillProperties() = aDataNode2->second->mpShape->getFillProperties();
+                    rShape->getCustomShapeProperties() = aDataNode2->second->mpShape->getCustomShapeProperties();
+                    rShape->setMasterTextListStyle( aDataNode2->second->mpShape->getMasterTextListStyle() );
+
+                    OSL_TRACE( "Custom shape with preset type %s added for layout node named \"%s\"", 
+                               OUSTRING_TO_CSTR( 
+                                   rShape->getCustomShapeProperties()->getShapePresetType()),
+                               OUSTRING_TO_CSTR( msName ) );
+                }
+
+                // append text with right outline level
+                if( aDataNode2->second->mpShape->getTextBody() &&
+                    !aDataNode2->second->mpShape->getTextBody()->getParagraphs().empty() &&
+                    !aDataNode2->second->mpShape->getTextBody()->getParagraphs().front()->getRuns().empty() )
+                {
+                    TextBodyPtr pTextBody=rShape->getTextBody();
+                    if( !pTextBody )
+                    {
+                        pTextBody.reset( new TextBody() );
+
+                        // also copy text attrs
+                        pTextBody->getTextListStyle() = 
+                            aDataNode2->second->mpShape->getTextBody()->getTextListStyle();
+                        pTextBody->getTextProperties() = 
+                            aDataNode2->second->mpShape->getTextBody()->getTextProperties();
+
+                        rShape->setTextBody(pTextBody);
+                    }
+
+                    TextParagraph& rPara=pTextBody->addParagraph();
+                    if( aVecIter->second != -1 )
+                        rPara.getProperties().setLevel(aVecIter->second);
+
+                    rPara.addRun(
+                        aDataNode2->second->mpShape->getTextBody()->getParagraphs().front()->getRuns().front());
+                    rPara.getProperties().apply(
+                        aDataNode2->second->mpShape->getTextBody()->getParagraphs().front()->getProperties());
+                }
+
+                ++aVecIter;
+            }
+        }
+        else
+        {
+            OSL_TRACE("ShapeCreationVisitor::visit: no data node name found while processing shape type %s for layout node named \"%s\"", 
+                      OUSTRING_TO_CSTR( 
+                          rShape->getCustomShapeProperties()->getShapePresetType()),
+                      OUSTRING_TO_CSTR( msName ) );
+        }
+
+        // TODO(Q1): apply styling & coloring - taking
+        // layout node's styleLbl for both style & color
+        // now, but docs are a bit unclear on this
+        if( msStyleLabel.getLength() )
+        {
+            OSL_TRACE("setting style with label %s", 
+                      OUSTRING_TO_CSTR( msStyleLabel ) ); 
+
+            const DiagramQStyleMap::const_iterator aStyle=rDgm.getStyles().find(msStyleLabel);
+            if( aStyle != rDgm.getStyles().end() )
+            {
+                rShape->getShapeStyleRefs()[XML_fillRef] = aStyle->second.maFillStyle;
+                OSL_TRACE("added fill style with id %d", aStyle->second.maFillStyle.mnThemedIdx);
+                rShape->getShapeStyleRefs()[XML_lnRef] = aStyle->second.maLineStyle;
+                OSL_TRACE("added line style with id %d", aStyle->second.maLineStyle.mnThemedIdx);
+                rShape->getShapeStyleRefs()[XML_effectRef] = aStyle->second.maEffectStyle;
+                OSL_TRACE("added effect style with id %d", aStyle->second.maEffectStyle.mnThemedIdx);
+                rShape->getShapeStyleRefs()[XML_fontRef] = aStyle->second.maTextStyle;
+                OSL_TRACE("added fontref style with id %d", aStyle->second.maTextStyle.mnThemedIdx);
+                Color aColor=aStyle->second.maTextStyle.maPhClr;
+                OSL_TRACE("added fontref color with alpha %d", aColor.getTransparence() );
+            }
+
+            const DiagramColorMap::const_iterator aColor=rDgm.getColors().find(msStyleLabel);
+            if( aColor != rDgm.getColors().end() )
+            {
+                const DiagramColor& rColor=aColor->second;
+                if( rColor.maFillColor.isUsed() )
+                    rShape->getShapeStyleRefs()[XML_fillRef].maPhClr = rColor.maFillColor;
+                if( rColor.maLineColor.isUsed() )
+                    rShape->getShapeStyleRefs()[XML_lnRef].maPhClr = rColor.maLineColor;
+                if( rColor.maEffectColor.isUsed() )
+                    rShape->getShapeStyleRefs()[XML_effectRef].maPhClr = rColor.maEffectColor;
+                if( rColor.maTextFillColor.isUsed() )
+                    rShape->getShapeStyleRefs()[XML_fontRef].maPhClr = rColor.maTextFillColor;
+            }
+        }
+
+        // even if no data node found, successful anyway. it's
+        // contained at the layoutnode
+        return true;
+    }
+    else
+    {
+        OSL_TRACE("ShapeCreationVisitor::visit: no text found while processing shape type %s for layout node named \"%s\"", 
+                  OUSTRING_TO_CSTR( 
+                      rShape->getCustomShapeProperties()->getShapePresetType()),
+                  OUSTRING_TO_CSTR( msName ) );
+    }
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////////////////
+//
+// Visitation
+//
+
+class ShapeLayoutingVisitor : public LayoutAtomVisitor
+{
+    ShapePtr mpParentShape;
+    const Diagram& mrDgm;
+    rtl::OUString maName;
+
+    virtual void visit(ConstraintAtom& rAtom);
+    virtual void visit(AlgAtom& rAtom);
+    virtual void visit(ForEachAtom& rAtom);
+    virtual void visit(ConditionAtom& rAtom);
+    virtual void visit(ChooseAtom& rAtom);
+    virtual void visit(LayoutNode& rAtom);
+
+public:
+    ShapeLayoutingVisitor(const ShapePtr& rParentShape, 
+                          const Diagram& rDgm,
+                          const rtl::OUString& rName) :
+        mpParentShape(rParentShape),
+        mrDgm(rDgm),
+        maName(rName)
+    {}
+
+    void defaultVisit(LayoutAtom& rAtom);
+};
+
+class ShallowPresNameVisitor : public LayoutAtomVisitor
+{
+    const Diagram& mrDgm;
+    size_t mnCnt;
+
+    void defaultVisit(LayoutAtom& rAtom);
+    virtual void visit(ConstraintAtom& rAtom);
+    virtual void visit(AlgAtom& rAtom);
+    virtual void visit(ForEachAtom& rAtom);
+    virtual void visit(ConditionAtom& rAtom);
+    virtual void visit(ChooseAtom& rAtom);
+    virtual void visit(LayoutNode& rAtom);
+
+public:
+    ShallowPresNameVisitor(const Diagram& rDgm) :
+        mrDgm(rDgm),
+        mnCnt(0)
+    {}
+
+    size_t getCount() const 
+        { return mnCnt; }
+};
+
+void ShapeCreationVisitor::defaultVisit(LayoutAtom& rAtom)
+{
+    const std::vector<LayoutAtomPtr>& pChildren=rAtom.getChildren();
+    std::for_each( pChildren.begin(), pChildren.end(),
+                   boost::bind( &LayoutAtom::accept, 
+                                _1,
+                                boost::ref(*this)) );
+}
+
+void ShapeCreationVisitor::visit(ConstraintAtom& /*rAtom*/)
+{
+    // TODO: eval the constraints
 }
 
+void ShapeCreationVisitor::visit(AlgAtom& rAtom)
+{
+    defaultVisit(rAtom);
+}
 
-void ForEachAtom::processAtom()
+void ShapeCreationVisitor::visit(ForEachAtom& rAtom)
 {
-	// TODO there is likely some conditions
-	std::for_each( mpChildNodes.begin(), mpChildNodes.end(),
-				   boost::bind( &LayoutAtom::processAtom, _1 ) );
+    const std::vector<LayoutAtomPtr>& pChildren=rAtom.getChildren();
+
+    sal_Int32 nChildren=1;
+    if( rAtom.iterator().mnPtType == XML_node )
+    {
+        // cound child data nodes - check all child Atoms for "name"
+        // attribute that is contained in diagram's
+        // getPointsPresNameMap()
+        ShallowPresNameVisitor aVisitor(mrDgm);
+        std::for_each( pChildren.begin(), pChildren.end(),
+                       boost::bind( &LayoutAtom::accept,
+                                    _1,
+                                    boost::ref(aVisitor)) );
+        nChildren = aVisitor.getCount();
+    }
+    
+    const sal_Int32 nCnt = std::min(
+        nChildren,
+        rAtom.iterator().mnCnt==-1 ? nChildren : rAtom.iterator().mnCnt);
+
+    const sal_Int32 nOldIdx=mnCurrIdx;
+    const sal_Int32 nStep=rAtom.iterator().mnStep;
+    for( mnCurrIdx=0; mnCurrIdx<nCnt; mnCurrIdx+=nStep )
+    {
+        // TODO there is likely some conditions
+        std::for_each( pChildren.begin(), pChildren.end(),
+                       boost::bind( &LayoutAtom::accept,
+                                    _1,
+                                    boost::ref(*this)) );
+    }
+
+    // and restore idx
+    mnCurrIdx = nOldIdx;
 }
 
-/** call ConditionAtom::test() if pAtom is one
- * if it is not a ConditionAtom, then return false.
- */
-static bool _test_atom( const LayoutAtomPtr & pAtom)
+void ShapeCreationVisitor::visit(ConditionAtom& rAtom)
 {
-	try {
-		bool bResult = false;
-		const ConditionAtomPtr pCond = boost::dynamic_pointer_cast< ConditionAtom >(pAtom);
-		if( pCond )
-		{
-			bResult = pCond->test();
-		}
-		return bResult;
-	}
-	catch(...)
-	{
-	}
-	return false;
+    defaultVisit(rAtom);
 }
 
-void ChooseAtom::processAtom()
+void ShapeCreationVisitor::visit(ChooseAtom& rAtom)
 {
-	std::vector< LayoutAtomPtr >::iterator
-		iter = std::find_if( mpChildNodes.begin(), mpChildNodes.end(),
-							 boost::bind( &_test_atom, _1 ) );
-	if( iter != mpChildNodes.end() )
-	{
-		// TODO do something
-		(*iter)->processAtom();
-	}
+    defaultVisit(rAtom);
 }
 
-bool ConditionAtom::test()
+void ShapeCreationVisitor::visit(LayoutNode& rAtom)
 {
-	// TODO
-	return false;
+    ShapePtr pCurrParent(mpParentShape);
+    ShapePtr pCurrShape(rAtom.getShape());
+    if( pCurrShape )
+    {
+        OSL_TRACE("ShapeCreationVisitor::visit: processing shape type %s",
+                  OUSTRING_TO_CSTR(
+                      pCurrShape->getCustomShapeProperties()->getShapePresetType()) );
+
+        // TODO(F3): cloned shape shares all properties by reference,
+        // don't change them!
+        ShapePtr pClonedShape(
+            new Shape( pCurrShape ));
+
+        if( rAtom.setupShape(pClonedShape, mrDgm, mnCurrIdx) )
+        {
+            pCurrParent->addChild(pClonedShape);
+            pCurrParent = pClonedShape;
+        }
+    }
+    else
+    {
+        OSL_TRACE("ShapeCreationVisitor::visit: no shape set while processing layoutnode named %s",
+                  OUSTRING_TO_CSTR( rAtom.getName() ) );
+    }
+
+    // set new parent for children
+    ShapePtr pPreviousParent(mpParentShape);
+    mpParentShape=pCurrParent;
+
+    // process children
+    defaultVisit(rAtom);
+
+    // restore parent
+    mpParentShape=pPreviousParent;
+
+    // layout shapes - now all child shapes are created
+    ShapeLayoutingVisitor aLayoutingVisitor(pCurrParent, 
+                                            mrDgm,
+                                            rAtom.getName());
+    aLayoutingVisitor.defaultVisit(rAtom);
 }
 
+void ShapeLayoutingVisitor::defaultVisit(LayoutAtom& rAtom)
+{
+    // visit all children, one of them need to be the layout algoritm
+    const std::vector<LayoutAtomPtr>& pChildren=rAtom.getChildren();
+    std::for_each( pChildren.begin(), pChildren.end(),
+                   boost::bind( &LayoutAtom::accept, 
+                                _1,
+                                boost::ref(*this)) );
+}
+
+void ShapeLayoutingVisitor::visit(ConstraintAtom& rAtom)
+{
+    // stop processing
+}
+
+void ShapeLayoutingVisitor::visit(AlgAtom& rAtom)
+{
+    rAtom.layoutShape(mpParentShape,mrDgm,maName);
+}
+
+void ShapeLayoutingVisitor::visit(ForEachAtom& rAtom)
+{
+    // stop processing
+}
+
+void ShapeLayoutingVisitor::visit(ConditionAtom& rAtom)
+{
+    defaultVisit(rAtom);
+}
+
+void ShapeLayoutingVisitor::visit(ChooseAtom& rAtom)
+{
+    defaultVisit(rAtom);
+}
+
+void ShapeLayoutingVisitor::visit(LayoutNode& rAtom)
+{
+    // stop processing - only traverse Condition/Choose atoms
+}
+
+void ShallowPresNameVisitor::defaultVisit(LayoutAtom& rAtom)
+{
+    // visit all children, at least one of them needs to have proper
+    // name set
+    const std::vector<LayoutAtomPtr>& pChildren=rAtom.getChildren();
+    std::for_each( pChildren.begin(), pChildren.end(),
+                   boost::bind( &LayoutAtom::accept, 
+                                _1,
+                                boost::ref(*this)) );
+}
+
+void ShallowPresNameVisitor::visit(ConstraintAtom& rAtom)
+{
+    // stop processing
+}
+
+void ShallowPresNameVisitor::visit(AlgAtom& rAtom)
+{
+    // stop processing
+}
+
+void ShallowPresNameVisitor::visit(ForEachAtom& rAtom)
+{
+    defaultVisit(rAtom);
+}
+
+void ShallowPresNameVisitor::visit(ConditionAtom& rAtom)
+{
+    defaultVisit(rAtom);
+}
+
+void ShallowPresNameVisitor::visit(ChooseAtom& rAtom)
+{
+    defaultVisit(rAtom);
+}
+
+void ShallowPresNameVisitor::visit(LayoutNode& rAtom)
+{
+    DiagramData::PointsNameMap::const_iterator aDataNode=
+        mrDgm.getData()->getPointsPresNameMap().find(rAtom.getName());
+    if( aDataNode != mrDgm.getData()->getPointsPresNameMap().end() )
+        mnCnt = std::max(mnCnt,
+                         aDataNode->second.size());
+}
 
 } }
diff --git oox/source/drawingml/diagram/diagramlayoutatoms.hxx oox/source/drawingml/diagram/diagramlayoutatoms.hxx
new file mode 100644
index 0000000..ae9e7c3
--- /dev/null
+++ oox/source/drawingml/diagram/diagramlayoutatoms.hxx
@@ -0,0 +1,318 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: diagramlayoutatoms.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef OOX_DRAWINGML_DIAGRAMLAYOUTATOMS_HXX
+#define OOX_DRAWINGML_DIAGRAMLAYOUTATOMS_HXX
+
+#include <map>
+#include <string>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/array.hpp>
+
+#include <com/sun/star/uno/Any.hxx>
+#include <com/sun/star/xml/sax/XFastAttributeList.hpp>
+
+#include "oox/drawingml/shape.hxx"
+#include "diagram.hxx"
+
+
+namespace oox { namespace drawingml {
+
+class DiagramLayout;
+typedef boost::shared_ptr< DiagramLayout > DiagramLayoutPtr;
+
+// AG_IteratorAttributes
+struct IteratorAttr
+{
+	IteratorAttr();
+
+	// not sure this belong here, but wth
+	void loadFromXAttr( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes );
+
+	sal_Int32 mnAxis;
+	sal_Int32 mnCnt;
+	sal_Bool  mbHideLastTrans;
+	sal_Int32 mnPtType;
+	sal_Int32 mnSt;
+	sal_Int32 mnStep;
+};
+
+struct ConditionAttr
+{
+	ConditionAttr();
+
+	// not sure this belong here, but wth
+	void loadFromXAttr( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes );
+
+	sal_Int32 mnFunc;
+	sal_Int32 mnArg;
+	sal_Int32 mnOp;
+	::rtl::OUString msVal;
+};
+
+struct LayoutAtomVisitor;
+class LayoutAtom;
+
+typedef boost::shared_ptr< LayoutAtom > LayoutAtomPtr;
+
+/** abstract Atom for the layout */
+class LayoutAtom
+{
+public:
+	/** visitor acceptance
+     */
+	virtual void accept( LayoutAtomVisitor& ) = 0;
+
+	void setName( const ::rtl::OUString& sName )
+		{ msName = sName; }
+	const ::rtl::OUString& getName() const
+		{ return msName; }
+
+	virtual void addChild( const LayoutAtomPtr & pNode )
+		{ mpChildNodes.push_back( pNode ); }
+    virtual const std::vector<LayoutAtomPtr>& getChildren() const 
+        { return mpChildNodes; }
+
+	// dump for debug
+	void dump(int level = 0);
+protected:
+    std::vector< LayoutAtomPtr > mpChildNodes;
+    ::rtl::OUString              msName;
+};
+
+class ConstraintAtom
+	: public LayoutAtom
+{
+public:
+    ConstraintAtom() :
+        mnFor(-1), msForName(), mnPointType(-1), mnType(-1), mnRefFor(-1), msRefForName(),
+        mnRefType(-1), mnRefPointType(-1), mfFactor(1.0), mfValue(0.0), mnOperator(0)
+    {}
+
+	virtual void accept( LayoutAtomVisitor& );
+
+	void setFor( sal_Int32 nToken )
+		{ mnFor = nToken; }
+	void setForName( const ::rtl::OUString & sName )
+		{ msForName = sName; }
+	void setPointType( sal_Int32 nToken )
+		{ mnPointType = nToken; }
+	void setType( sal_Int32 nToken )
+		{ mnType = nToken; }
+	void setRefFor( sal_Int32 nToken )
+		{ mnRefFor = nToken; }
+	void setRefForName( const ::rtl::OUString & sName )
+		{ msRefForName = sName; }
+	void setRefType( sal_Int32 nToken )
+		{ mnRefType = nToken; }
+	void setRefPointType( sal_Int32 nToken )
+		{ mnRefPointType = nToken; }
+	void setFactor( const double& fVal )
+		{ mfFactor = fVal; }
+	void setValue( const double& fVal )
+		{ mfValue = fVal; }
+	void setOperator( sal_Int32 nToken )
+		{ mnOperator = nToken; }
+private:
+    sal_Int32 mnFor;
+    ::rtl::OUString msForName;
+	sal_Int32 mnPointType;
+	sal_Int32 mnType;
+	sal_Int32 mnRefFor;
+	::rtl::OUString msRefForName;
+	sal_Int32 mnRefType;
+	sal_Int32 mnRefPointType;
+	double mfFactor;
+	double mfValue;
+	sal_Int32 mnOperator;
+};
+
+typedef boost::shared_ptr< ConstraintAtom > ConstraintAtomPtr;
+
+class AlgAtom
+	: public LayoutAtom
+{
+public:
+    AlgAtom() : mnType(0), maMap() {}
+
+    typedef std::map<sal_Int32,sal_Int32> ParamMap;
+
+	virtual void accept( LayoutAtomVisitor& );
+
+	void setType( sal_Int32 nToken )
+		{ mnType = nToken; }
+	void addParam( sal_Int32 nType, sal_Int32 nVal )
+        { maMap[nType]=nVal; }
+    void layoutShape( const ShapePtr& rShape, 
+                      const Diagram& rDgm,
+                      const rtl::OUString& rName ) const;
+private:
+	sal_Int32 mnType;
+    ParamMap  maMap;
+};
+
+typedef boost::shared_ptr< AlgAtom > AlgAtomPtr;
+
+class ForEachAtom
+	: public LayoutAtom
+{
+public:
+    explicit ForEachAtom(const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes);
+	
+	IteratorAttr & iterator()
+		{ return maIter; }
+	virtual void accept( LayoutAtomVisitor& );
+
+private:
+	IteratorAttr maIter;
+};
+
+typedef boost::shared_ptr< ForEachAtom > ForEachAtomPtr;
+
+
+class ConditionAtom
+	: public LayoutAtom
+{
+public:
+    explicit ConditionAtom(const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& xAttributes);
+	bool test();
+	virtual void accept( LayoutAtomVisitor& );
+	IteratorAttr & iterator()
+		{ return maIter; }
+	ConditionAttr & cond()
+		{ return maCond; }
+    void readElseBranch() 
+		{ mbElse=true; }
+    virtual void addChild( const LayoutAtomPtr & pNode );
+    virtual const std::vector<LayoutAtomPtr>& getChildren() const;
+private:
+	bool          mbElse;
+	IteratorAttr  maIter;
+	ConditionAttr maCond;
+    std::vector< LayoutAtomPtr > mpElseChildNodes;
+};
+
+typedef boost::shared_ptr< ConditionAtom > ConditionAtomPtr;
+
+
+/** "choose" statements. Atoms will be tested in order. */
+class ChooseAtom
+	: public LayoutAtom
+{
+public:
+	virtual void accept( LayoutAtomVisitor& );
+};
+
+class LayoutNode
+	: public LayoutAtom
+{
+public:
+	enum {
+		VAR_animLvl = 0,
+		VAR_animOne,
+		VAR_bulletEnabled,
+		VAR_chMax,
+		VAR_chPref,
+		VAR_dir,
+		VAR_hierBranch,
+		VAR_orgChart,
+		VAR_resizeHandles
+	};
+	// we know that the array is of fixed size
+	// the use of Any allow having empty values
+	typedef boost::array< ::com::sun::star::uno::Any, 9 > VarMap;
+
+    LayoutNode() : mnChildOrder(0) {}
+	virtual void accept( LayoutAtomVisitor& );
+	VarMap & variables()
+		{ return mVariables; }
+	void setMoveWith( const ::rtl::OUString & sName )
+		{ msMoveWith = sName; }
+	void setStyleLabel( const ::rtl::OUString & sLabel )
+		{ msStyleLabel = sLabel; }
+	void setChildOrder( sal_Int32 nOrder )
+		{ mnChildOrder = nOrder; }
+	void setShape( const ShapePtr& pShape )
+		{ mpShape = pShape; }
+    const ShapePtr& getShape() const
+        { return mpShape; }
+
+    bool setupShape( const ShapePtr& rShape,
+                     const Diagram& rDgm,
+                     sal_Int32 nIdx ) const;
+
+private:
+    VarMap                       mVariables;
+    ::rtl::OUString              msMoveWith;
+    ::rtl::OUString              msStyleLabel;
+    ShapePtr                     mpShape;
+    sal_Int32                    mnChildOrder;
+};
+
+typedef boost::shared_ptr< LayoutNode > LayoutNodePtr;
+
+struct LayoutAtomVisitor
+{
+    virtual ~LayoutAtomVisitor() {}
+    virtual void visit(ConstraintAtom& rAtom) = 0;
+    virtual void visit(AlgAtom& rAtom) = 0;
+    virtual void visit(ForEachAtom& rAtom) = 0;
+    virtual void visit(ConditionAtom& rAtom) = 0;
+    virtual void visit(ChooseAtom& rAtom) = 0;
+    virtual void visit(LayoutNode& rAtom) = 0;
+};
+
+class ShapeCreationVisitor : public LayoutAtomVisitor
+{
+    ShapePtr mpParentShape;
+    const Diagram& mrDgm;
+    sal_Int32 mnCurrIdx;
+
+    void defaultVisit(LayoutAtom& rAtom);
+    virtual void visit(ConstraintAtom& rAtom);
+    virtual void visit(AlgAtom& rAtom);
+    virtual void visit(ForEachAtom& rAtom);
+    virtual void visit(ConditionAtom& rAtom);
+    virtual void visit(ChooseAtom& rAtom);
+    virtual void visit(LayoutNode& rAtom);
+
+public:
+    ShapeCreationVisitor(const ShapePtr& rParentShape,
+                         const Diagram& rDgm) :
+        mpParentShape(rParentShape),
+        mrDgm(rDgm),
+        mnCurrIdx(0)
+    {}
+};
+
+} }
+
+#endif
diff --git oox/source/drawingml/diagram/layoutnodecontext.cxx oox/source/drawingml/diagram/layoutnodecontext.cxx
index d1f96b2..5a8fa9e 100644
--- oox/source/drawingml/diagram/layoutnodecontext.cxx
+++ oox/source/drawingml/diagram/layoutnodecontext.cxx
@@ -36,6 +36,7 @@
 #include "oox/drawingml/diagram/diagram.hxx"
 #include "oox/drawingml/shapecontext.hxx"
 #include "diagramdefinitioncontext.hxx"
+#include "constraintlistcontext.hxx"
 
 using namespace ::oox::core;
 using namespace ::com::sun::star::uno;
@@ -50,15 +51,9 @@ class IfContext
 public:
     IfContext( ContextHandler& rParent,
 			   const Reference< XFastAttributeList >& xAttribs,
-			   const LayoutAtomPtr & pNode )
-        : LayoutNodeContext( rParent, xAttribs, pNode )
-		{
-			ConditionAtomPtr pAtom( boost::dynamic_pointer_cast< ConditionAtom >(pNode) );
-			OSL_ENSURE( pAtom, "Must pass a ConditionAtom" );
-
-			pAtom->iterator().loadFromXAttr( xAttribs );
-			pAtom->cond().loadFromXAttr( xAttribs );
-		}
+			   const ConditionAtomPtr& pAtom )
+        : LayoutNodeContext( rParent, xAttribs, pAtom )
+    {}
 };
 
 
@@ -67,21 +62,47 @@ class AlgorithmContext
     : public ContextHandler
 {
 public:
-    AlgorithmContext( ContextHandler& rParent, const Reference< XFastAttributeList >& xAttribs, const LayoutAtomPtr & pNode )
+    AlgorithmContext( ContextHandler& rParent, const Reference< XFastAttributeList >& xAttribs, const AlgAtomPtr & pNode )
         : ContextHandler( rParent )
 		, mnRevision( 0 )
-		, mnType( 0 )
 		, mpNode( pNode )
 		{
 			AttributeList aAttribs( xAttribs );
 			mnRevision = aAttribs.getInteger( XML_rev, 0 );
-			mnType = xAttribs->getOptionalValueToken( XML_type, 0 );
+            pNode->setType(xAttribs->getOptionalValueToken(XML_type, 0));
+		}
+
+	virtual Reference< XFastContextHandler > SAL_CALL
+	createFastChildContext( ::sal_Int32 aElement,
+							const Reference< XFastAttributeList >& xAttribs )
+		throw (SAXException, RuntimeException)
+		{
+			Reference< XFastContextHandler > xRet;
+
+			switch( getToken(aElement) )
+			{
+                case XML_param:
+                {
+                    AttributeList aAttribs( xAttribs );
+                    const sal_Int32 nValTok=aAttribs.getToken( XML_val, 0 );
+                    mpNode->addParam(
+                        aAttribs.getToken( XML_type, 0 ),
+                        nValTok>0 ? nValTok : aAttribs.getInteger( XML_val, 0 ) );
+                    break;
+                }
+                default:
+                    break;
+			}
+
+			if( !xRet.is() )
+				xRet.set(this);
+
+			return xRet;
 		}
 
 private:
-	sal_Int32     mnRevision;
-	sal_Int32     mnType;
-	LayoutAtomPtr mpNode;
+	sal_Int32  mnRevision;
+	AlgAtomPtr mpNode;
 };
 
 
@@ -91,7 +112,6 @@ class ChooseContext
 public:
     ChooseContext( ContextHandler& rParent, const Reference< XFastAttributeList >& xAttribs, const LayoutAtomPtr & pNode )
         : ContextHandler( rParent )
-		, mbHasElse( false )
 		, mpNode( pNode )
 		{
 			msName = xAttribs->getOptionalValue( XML_name );
@@ -104,24 +124,23 @@ public:
 		{
 			Reference< XFastContextHandler > xRet;
 
-			switch( aElement )
+			switch( getToken(aElement) )
 			{
 			case XML_if:
 			{
 				// CT_When
-				LayoutAtomPtr pAtom( new ConditionAtom( false ) );
-				mpNode->addChild( pAtom );
-                xRet.set( new IfContext( *this, xAttribs, pAtom ) );
+				mpConditionNode.reset( new ConditionAtom(xAttribs) );
+				mpNode->addChild( mpConditionNode );
+                xRet.set( new IfContext( *this, xAttribs, mpConditionNode ) );
 				break;
 			}
 			case XML_else:
 				// CT_Otherwise
-				if( !mbHasElse )
+				if( mpConditionNode )
 				{
-					LayoutAtomPtr pAtom( new ConditionAtom( true ) );
-					mpNode->addChild( pAtom );
-                    xRet.set( new IfContext( *this, xAttribs, pAtom ) );
-					mbHasElse = true;
+                    mpConditionNode->readElseBranch();
+                    xRet.set( new IfContext( *this, xAttribs, mpConditionNode ) );
+                    mpConditionNode.reset();
 				}
 				else
 				{
@@ -138,9 +157,9 @@ public:
 			return xRet;
 		}
 private:
-	bool     mbHasElse;
 	OUString msName;
 	LayoutAtomPtr mpNode;
+	ConditionAtomPtr mpConditionNode;
 };
 
 
@@ -150,13 +169,10 @@ class ForEachContext
 	: public LayoutNodeContext
 {
 public:
-    ForEachContext( ContextHandler& rParent, const Reference< XFastAttributeList >& xAttribs, const LayoutAtomPtr & pNode )
-        : LayoutNodeContext( rParent, xAttribs, pNode )
+    ForEachContext( ContextHandler& rParent, const Reference< XFastAttributeList >& xAttribs, const ForEachAtomPtr& pAtom )
+        : LayoutNodeContext( rParent, xAttribs, pAtom )
 		{
-			ForEachAtomPtr pAtom( boost::dynamic_pointer_cast< ForEachAtom >(pNode) );
-			OSL_ENSURE( pAtom, "Must pass a ForEachAtom" );
 			xAttribs->getOptionalValue( XML_ref );
-
 			pAtom->iterator().loadFromXAttr( xAttribs );
 		}
 };
@@ -200,17 +216,12 @@ private:
 // CT_LayoutNode
 LayoutNodeContext::LayoutNodeContext( ContextHandler& rParent,
 									  const Reference< XFastAttributeList >& xAttribs,
-									  const LayoutAtomPtr &pNode )
+									  const LayoutAtomPtr& pAtom )
     : ContextHandler( rParent )
-	, mpNode( pNode )
+	, mpNode( pAtom )
 {
-	OSL_ENSURE( pNode, "Node must NOT be NULL" );
+	OSL_ENSURE( pAtom, "Node must NOT be NULL" );
 	mpNode->setName( xAttribs->getOptionalValue( XML_name ) );
-	// TODO shall we even bother?
-	// b or t
-//	sal_Int32 nChOrder = xAttributes->getOptionalValueToken( XML_chOrder, XML_b );
-//	OUString sMoveWith = xAttributes->getOptionalValue( XML_moveWith );
-//	OUString sStyleLbl = xAttributes->getOptionalValue( XML_styleLbl );
 }
 
 
@@ -231,33 +242,33 @@ void SAL_CALL LayoutNodeContext::endFastElement( ::sal_Int32 )
 sal_Int32 LayoutNodeContext::tagToVarIdx( sal_Int32 aTag )
 {
 	sal_Int32 nIdx = -1;
-	switch( aTag )
+	switch( aTag & ~NMSP_DIAGRAM )
 	{
-	case NMSP_DIAGRAM|XML_animLvl:
+	case XML_animLvl:
 		nIdx = LayoutNode::VAR_animLvl;
 		break;
-	case NMSP_DIAGRAM|XML_animOne:
+	case XML_animOne:
 		nIdx = LayoutNode::VAR_animOne;
 		break;
-	case NMSP_DIAGRAM|XML_bulletEnabled:
+	case XML_bulletEnabled:
 		nIdx = LayoutNode::VAR_bulletEnabled;
 		break;
-	case NMSP_DIAGRAM|XML_chMax:
+	case XML_chMax:
 		nIdx = LayoutNode::VAR_chMax;
 		break;
-	case NMSP_DIAGRAM|XML_chPref:
+	case XML_chPref:
 		nIdx = LayoutNode::VAR_chPref;
 		break;
-	case NMSP_DIAGRAM|XML_dir:
+	case XML_dir:
 		nIdx = LayoutNode::VAR_dir;
 		break;
-	case NMSP_DIAGRAM|XML_hierBranch:
+	case XML_hierBranch:
 		nIdx = LayoutNode::VAR_hierBranch;
 		break;
-	case NMSP_DIAGRAM|XML_orgChart:
+	case XML_orgChart:
 		nIdx = LayoutNode::VAR_orgChart;
 		break;
-	case NMSP_DIAGRAM|XML_resizeHandles:
+	case XML_resizeHandles:
 		nIdx = LayoutNode::VAR_resizeHandles;
 		break;
 	default:
@@ -280,13 +291,39 @@ LayoutNodeContext::createFastChildContext( ::sal_Int32 aElement,
 	{
 		LayoutNodePtr pNode( new LayoutNode() );
 		mpNode->addChild( pNode );
+        pNode->setChildOrder( xAttribs->getOptionalValueToken( XML_chOrder, XML_b ) );
+        pNode->setMoveWith( xAttribs->getOptionalValue( XML_moveWith ) );
+        pNode->setStyleLabel( xAttribs->getOptionalValue( XML_styleLbl ) );
         xRet.set( new LayoutNodeContext( *this, xAttribs, pNode ) );
 		break;
 	}
 	case NMSP_DIAGRAM|XML_shape:
 	{
-		ShapePtr pShape( new Shape() );
-        xRet.set( new ShapeContext( *this, ShapePtr(), pShape ) );
+		LayoutNodePtr pNode( boost::dynamic_pointer_cast< LayoutNode >( mpNode ) );
+		if( pNode )
+        {
+            ShapePtr pShape;
+
+            if( xAttribs->hasAttribute( XML_type ) )
+            {
+                pShape.reset( new Shape("com.sun.star.drawing.CustomShape") );
+                const sal_Int32 nType(xAttribs->getOptionalValueToken( XML_type, XML_obj ));
+                pShape->setSubType( nType );
+                pShape->getCustomShapeProperties()->setShapePresetType( 
+                    GetShapePresetType( nType ) );
+            }
+            else
+            {
+                pShape.reset( new Shape("com.sun.star.drawing.GroupShape") );
+            }
+
+            pNode->setShape( pShape );
+            xRet.set( new ShapeContext( *this, ShapePtr(), pShape ) );
+        }
+		else
+		{
+			OSL_TRACE( "OOX: encountered a shape in a non layoutNode context" );
+		}
 		break;
 	}
 	case NMSP_DIAGRAM|XML_extLst:
@@ -295,7 +332,7 @@ LayoutNodeContext::createFastChildContext( ::sal_Int32 aElement,
 	case NMSP_DIAGRAM|XML_alg:
 	{
 		// CT_Algorithm
-		LayoutAtomPtr pAtom( new AlgAtom );
+		AlgAtomPtr pAtom( new AlgAtom );
 		mpNode->addChild( pAtom );
         xRet.set( new AlgorithmContext( *this, xAttribs, pAtom ) );
 		break;
@@ -311,14 +348,14 @@ LayoutNodeContext::createFastChildContext( ::sal_Int32 aElement,
 	case NMSP_DIAGRAM|XML_forEach:
 	{
 		// CT_ForEach
-		LayoutAtomPtr pAtom( new ForEachAtom );
+		ForEachAtomPtr pAtom( new ForEachAtom(xAttribs) );
 		mpNode->addChild( pAtom );
         xRet.set( new ForEachContext( *this, xAttribs, pAtom ) );
 		break;
 	}
 	case NMSP_DIAGRAM|XML_constrLst:
 		// CT_Constraints
-		// TODO
+        xRet.set( new ConstraintListContext( *this, xAttribs, mpNode ) );
 		break;
 	case NMSP_DIAGRAM|XML_presOf:
 	{
diff --git oox/source/drawingml/diagram/layoutnodecontext.hxx oox/source/drawingml/diagram/layoutnodecontext.hxx
index 999993e..4efa66e 100644
--- oox/source/drawingml/diagram/layoutnodecontext.hxx
+++ oox/source/drawingml/diagram/layoutnodecontext.hxx
@@ -32,7 +32,8 @@
 #define OOX_DRAWINGML_LAYOUTNODECONTEXT_HXX
 
 #include "oox/core/contexthandler.hxx"
-#include "oox/drawingml/diagram/diagram.hxx"
+#include "diagramlayoutatoms.hxx"
+#include "diagram.hxx"
 
 namespace oox { namespace drawingml {
 
diff --git oox/source/drawingml/diagram/makefile.mk oox/source/drawingml/diagram/makefile.mk
index 11fca2a..3863d31 100644
--- oox/source/drawingml/diagram/makefile.mk
+++ oox/source/drawingml/diagram/makefile.mk
@@ -45,6 +45,7 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Files --------------------------------------------------------
 
 SLOFILES = \
+	$(SLO)$/constraintlistcontext.obj \
 	$(SLO)$/diagram.obj \
 	$(SLO)$/diagramfragmenthandler.obj \
 	$(SLO)$/diagramdefinitioncontext.obj \
diff --git oox/source/drawingml/drawingmltypes.cxx oox/source/drawingml/drawingmltypes.cxx
index 9974feb..e107c21 100644
--- oox/source/drawingml/drawingmltypes.cxx
+++ oox/source/drawingml/drawingmltypes.cxx
@@ -141,6 +141,7 @@ float GetFontHeight( sal_Int32 nHeight )
 
 sal_Int16 GetFontUnderline( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
 	switch( nToken )
 	{
         case XML_none:              return FontUnderline::NONE;
@@ -167,6 +168,7 @@ sal_Int16 GetFontUnderline( sal_Int32 nToken )
 
 sal_Int16 GetFontStrikeout( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
 	switch( nToken )
 	{
         case XML_dblStrike: return FontStrikeout::DOUBLE;
@@ -189,6 +191,7 @@ sal_Int16 GetCaseMap( sal_Int32 nToken )
 /** converts a paragraph align to a ParaAdjust */
 sal_Int16 GetParaAdjust( sal_Int32 nAlign )
 {
+    OSL_ASSERT((nAlign & sal_Int32(0xFFFF0000))==0);
 	sal_Int16 nEnum;
 	switch( nAlign )
 	{
@@ -217,6 +220,7 @@ sal_Int16 GetParaAdjust( sal_Int32 nAlign )
 
 TabAlign GetTabAlign( sal_Int32 aToken )
 {
+    OSL_ASSERT((aToken & sal_Int32(0xFFFF0000))==0);
 	TabAlign nEnum;
 	switch( aToken )
 	{
diff --git oox/source/drawingml/fillproperties.cxx oox/source/drawingml/fillproperties.cxx
index 25db80f..877da44 100644
--- oox/source/drawingml/fillproperties.cxx
+++ oox/source/drawingml/fillproperties.cxx
@@ -83,6 +83,7 @@ static const sal_Char* const sppcDefaultPicNames[] =
 
 BitmapMode lclGetBitmapMode( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
     switch( nToken )
     {
         case XML_tile:      return BitmapMode_REPEAT;
@@ -93,6 +94,7 @@ BitmapMode lclGetBitmapMode( sal_Int32 nToken )
 
 RectanglePoint lclGetRectanglePoint( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
     switch( nToken )
     {
         case XML_tl:    return RectanglePoint_LEFT_TOP;
@@ -275,6 +277,7 @@ void FillProperties::pushToPropMap( PropertyMap& rPropMap, const FillPropertyNam
             nShapeRotation = 0;
 
         FillStyle eFillStyle = FillStyle_NONE;
+        OSL_ASSERT((moFillType.get() & sal_Int32(0xFFFF0000))==0);
         switch( moFillType.get() )
         {
             case XML_noFill:
diff --git oox/source/drawingml/graphicshapecontext.cxx oox/source/drawingml/graphicshapecontext.cxx
index 42e6156..3ca447f 100644
--- oox/source/drawingml/graphicshapecontext.cxx
+++ oox/source/drawingml/graphicshapecontext.cxx
@@ -32,8 +32,9 @@
 
 #include "oox/drawingml/fillpropertiesgroupcontext.hxx"
 #include "oox/drawingml/graphicshapecontext.hxx"
-#include "oox/drawingml/diagram/diagramfragmenthandler.hxx"
+#include "oox/drawingml/diagram/diagram.hxx"
 #include "oox/drawingml/table/tablecontext.hxx"
+#include "oox/drawingml/diagram/diagram.hxx"
 #include "oox/core/namespaces.hxx"
 #include "oox/core/xmlfilterbase.hxx"
 #include "oox/helper/attributelist.hxx"
@@ -91,7 +92,7 @@ Reference< XFastContextHandler > GraphicShapeContext::createFastChildContext( sa
             (mpShapePtr->getCustomShapeProperties());
 
         sal_uInt32 nType = aElementToken & (~ NMSP_MASK);
-        OUString sType(GetShapeType(nType));
+        OUString sType(GetShapePresetType(nType));
 
         if (sType.getLength() > 0)
             pCstmShpProps->setShapePresetType(sType);
@@ -114,6 +115,7 @@ Reference< XFastContextHandler > GraphicalObjectFrameContext::createFastChildCon
 {
 	Reference< XFastContextHandler > xRet;
 
+    OSL_ASSERT(((aElementToken &(~NMSP_MASK)) & sal_Int32(0xFFFF0000))==0);
 	switch( aElementToken &(~NMSP_MASK) )
 	{
 	// CT_ShapeProperties
@@ -235,6 +237,7 @@ Reference< XFastContextHandler > PresentationOle2006Context::createFastChildCont
 {
 	Reference< XFastContextHandler > xRet;
 
+    OSL_ASSERT(((aElementToken &(~NMSP_MASK)) & sal_Int32(0xFFFF0000))==0);
 	switch( aElementToken &(~NMSP_MASK) )
 	{
 		case XML_oleObj:
@@ -276,48 +279,6 @@ DiagramGraphicDataContext::~DiagramGraphicDataContext()
 
 }
 
-DiagramPtr DiagramGraphicDataContext::loadDiagram()
-{
-	DiagramPtr pDiagram( new Diagram() );
-    XmlFilterBase& rFilter = getFilter();
-
-	// data
-    OUString sDmPath = getFragmentPathFromRelId( msDm );
-	if( sDmPath.getLength() > 0 )
-	{
-		DiagramDataPtr pData( new DiagramData() );
-		pDiagram->setData( pData );
-        rFilter.importFragment( new DiagramDataFragmentHandler( rFilter, sDmPath, pData ) );
-	}
-	// layout
-    OUString sLoPath = getFragmentPathFromRelId( msLo );
-	if( sLoPath.getLength() > 0 )
-	{
-		DiagramLayoutPtr pLayout( new DiagramLayout() );
-		pDiagram->setLayout( pLayout );
-        rFilter.importFragment( new DiagramLayoutFragmentHandler( rFilter, sLoPath, pLayout ) );
-	}
-	// style
-    OUString sQsPath = getFragmentPathFromRelId( msQs );
-	if( sQsPath.getLength() > 0 )
-	{
-		DiagramQStylesPtr pStyles( new DiagramQStyles() );
-		pDiagram->setQStyles( pStyles );
-        rFilter.importFragment( new DiagramQStylesFragmentHandler( rFilter, sQsPath, pStyles ) );
-	}
-	// colors
-    OUString sCsPath = getFragmentPathFromRelId( msCs );
-	if( sCsPath.getLength() > 0 )
-	{
-		DiagramColorsPtr pColors( new DiagramColors() );
-		pDiagram->setColors( pColors );
-        rFilter.importFragment( new DiagramColorsFragmentHandler( rFilter, sCsPath, pColors ) ) ;
-	}
-
-	return pDiagram;
-}
-
-
 Reference< XFastContextHandler > DiagramGraphicDataContext::createFastChildContext( ::sal_Int32 aElementToken, const Reference< XFastAttributeList >& xAttribs )
 	throw (SAXException, RuntimeException)
 {
@@ -331,8 +292,12 @@ Reference< XFastContextHandler > DiagramGraphicDataContext::createFastChildConte
 		msLo = xAttribs->getOptionalValue( NMSP_RELATIONSHIPS|XML_lo );
 		msQs = xAttribs->getOptionalValue( NMSP_RELATIONSHIPS|XML_qs );
 		msCs = xAttribs->getOptionalValue( NMSP_RELATIONSHIPS|XML_cs );
-		DiagramPtr pDiagram = loadDiagram();
-		pDiagram->addTo( mpShapePtr );
+		loadDiagram(mpShapePtr,
+                    getFilter(),
+                    getFragmentPathFromRelId( msDm ),
+                    getFragmentPathFromRelId( msLo ),
+                    getFragmentPathFromRelId( msQs ),
+                    getFragmentPathFromRelId( msCs ));
 		OSL_TRACE("diagram added shape %s of type %s", OUSTRING_TO_CSTR( mpShapePtr->getName() ),
 				  OUSTRING_TO_CSTR( mpShapePtr->getServiceName() ) );
 		break;
@@ -387,7 +352,8 @@ void CreateChartCallback::onCreateXShape( const Reference< drawing::XShape >& rx
 
         // convert imported chart model to chart document
         Reference< chart2::XChartDocument > xChartDoc( xDocModel, UNO_QUERY_THROW );
-        mrFilter.getChartConverter().convertFromModel( mrFilter, aModel, xChartDoc );
+        if( mrFilter.getChartConverter() )
+            mrFilter.getChartConverter()->convertFromModel( mrFilter, aModel, xChartDoc );
     }
     catch( Exception& )
     {
diff --git oox/source/drawingml/lineproperties.cxx oox/source/drawingml/lineproperties.cxx
index d46d46e..4e7a591 100644
--- oox/source/drawingml/lineproperties.cxx
+++ oox/source/drawingml/lineproperties.cxx
@@ -76,6 +76,7 @@ static const sal_Char* const sppcDefaultLineNames[] =
 
 DashStyle lclGetDashStyle( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
     switch( nToken )
     {
         case XML_rnd:   return DashStyle_ROUNDRELATIVE;
@@ -87,6 +88,7 @@ DashStyle lclGetDashStyle( sal_Int32 nToken )
 
 LineJoint lclGetLineJoint( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
     switch( nToken )
     {
         case XML_round: return LineJoint_ROUND;
@@ -102,6 +104,7 @@ const sal_Int32 OOX_ARROWSIZE_LARGE     = 2;
 
 sal_Int32 lclGetArrowSize( sal_Int32 nToken )
 {
+    OSL_ASSERT((nToken & sal_Int32(0xFFFF0000))==0);
     switch( nToken )
     {
         case XML_sm:    return OOX_ARROWSIZE_SMALL;
@@ -123,6 +126,7 @@ void lclPushMarkerProperties( PropertyMap& rPropMap, const LineArrowProperties&
 
     OUStringBuffer aBuffer;
     sal_Int32 nArrowType = rArrowProps.moArrowType.get( XML_none );
+    OSL_ASSERT((nArrowType & sal_Int32(0xFFFF0000))==0);
     switch( nArrowType )
     {
         case XML_triangle:
@@ -179,6 +183,7 @@ void lclPushMarkerProperties( PropertyMap& rPropMap, const LineArrowProperties&
 #define OOX_ARROW_POINT( x, y ) Point( static_cast< sal_Int32 >( fArrowWidth * x ), static_cast< sal_Int32 >( fArrowLength * y ) )
 
             ::std::vector< Point > aPoints;
+            OSL_ASSERT((rArrowProps.moArrowType.get() & sal_Int32(0xFFFF0000))==0);
             switch( rArrowProps.moArrowType.get() )
             {
                 case XML_triangle:
@@ -347,6 +352,7 @@ void LineProperties::pushToPropMap( PropertyMap& rPropMap, const LinePropertyNam
             aLineDash.DashLen = 8 * nLineWidth;
             aLineDash.Distance = 3 * nLineWidth;
 
+            OSL_ASSERT((moPresetDash.get() & sal_Int32(0xFFFF0000))==0);
             switch( moPresetDash.get() )
             {
                 default:
diff --git oox/source/drawingml/makefile.mk oox/source/drawingml/makefile.mk
index bc10fd0..9cd2c5c 100644
--- oox/source/drawingml/makefile.mk
+++ oox/source/drawingml/makefile.mk
@@ -63,6 +63,7 @@ SLOFILES =	\
 		$(SLO)$/linepropertiescontext.obj\
 		$(SLO)$/objectdefaultcontext.obj\
 		$(SLO)$/shape.obj\
+		$(SLO)$/shape3dproperties.obj\
 		$(SLO)$/shapecontext.obj\
 		$(SLO)$/shapegroupcontext.obj\
 		$(SLO)$/shapepropertiescontext.obj\
diff --git oox/source/drawingml/scene3dcontext.cxx oox/source/drawingml/scene3dcontext.cxx
new file mode 100644
index 0000000..e7008eb
--- /dev/null
+++ oox/source/drawingml/scene3dcontext.cxx
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: fillpropertiesgroupcontext.cxx,v $
+ * $Revision: 1.8.6.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "oox/drawingml/scene3dcontext.hxx"
+#include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
+#include <cppuhelper/exc_hlp.hxx>
+#include <comphelper/anytostring.hxx>
+#include "oox/drawingml/colorchoicecontext.hxx"
+#include "oox/drawingml/drawingmltypes.hxx"
+#include "oox/drawingml/fillproperties.hxx"
+#include "oox/core/namespaces.hxx"
+#include "oox/core/xmlfilterbase.hxx"
+#include "oox/helper/attributelist.hxx"
+
+using ::rtl::OUString;
+using ::oox::core::ContextHandler;
+using ::oox::core::XmlFilterBase;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::xml::sax;
+
+namespace oox { namespace drawingml {
+
+Scene3DContext::Scene3DContext( ContextHandler& rParent, Shape3DProperties& r3DProperties ) throw()
+: ContextHandler( rParent )
+, mr3DProperties( r3DProperties )
+{
+}
+
+Reference< XFastContextHandler > Scene3DContext::createFastChildContext( sal_Int32 aElementToken, const Reference< XFastAttributeList >& xAttribs )
+	throw ( SAXException, RuntimeException )
+{
+    AttributeList aAttribs( xAttribs );
+    Reference< XFastContextHandler > xRet;
+
+	switch( aElementToken )
+	{
+	case NMSP_DRAWINGML|XML_camera:
+        mr3DProperties.mfFieldOfVision = aAttribs.getInteger( XML_fov, 0 ) / 36000000.0;
+        mr3DProperties.mfZoom = aAttribs.getInteger( XML_zoom, 100000 ) / 100000.0;
+        mr3DProperties.mnPreset = aAttribs.getToken( XML_prst, XML_none );
+
+legacyObliqueTopLeft
+legacyObliqueTop
+legacyObliqueTopRight
+legacyObliqueLeft
+legacyObliqueFront
+legacyObliqueRight
+legacyObliqueBottomLeft
+legacyObliqueBottom
+legacyObliqueBottomRight
+legacyPerspectiveTopLeft
+legacyPerspectiveTop
+legacyPerspectiveTopRight
+legacyPerspectiveLeft
+legacyPerspectiveFront
+legacyPerspectiveRight
+legacyPerspectiveBottomLeft
+legacyPerspectiveBottom
+legacyPerspectiveBottomRight
+orthographicFront
+isometricTopUp
+isometricTopDown
+isometricBottomUp
+isometricBottomDown
+isometricLeftUp
+isometricLeftDown
+isometricRightUp
+isometricRightDown
+isometricOffAxis1Left
+isometricOffAxis1Right
+isometricOffAxis1Top
+isometricOffAxis2Left
+isometricOffAxis2Right
+isometricOffAxis2Top
+isometricOffAxis3Left
+isometricOffAxis3Right
+isometricOffAxis3Bottom
+isometricOffAxis4Left
+isometricOffAxis4Right
+isometricOffAxis4Bottom
+obliqueTopLeft
+obliqueTop
+obliqueTopRight
+obliqueLeft
+obliqueRight
+obliqueBottomLeft
+obliqueBottom
+obliqueBottomRight
+perspectiveFront
+perspectiveLeft
+perspectiveRight
+perspectiveAbove
+perspectiveBelow
+perspectiveAboveLeftFacing
+perspectiveAboveRightFacing
+perspectiveContrastingLeftFacing
+perspectiveContrastingRightFacing
+perspectiveHeroicLeftFacing
+perspectiveHeroicRightFacing
+perspectiveHeroicExtremeLeftFacing
+perspectiveHeroicExtremeRightFacing
+perspectiveRelaxed
+perspectiveRelaxedModerately
+
+
+        // TODO: nested element XML_rot
+		break;
+	case NMSP_DRAWINGML|XML_lightRig:
+        mr3DProperties.mnLightRigDirection = aAttribs.getToken( XML_dir, XML_none );
+
+XML_tl
+XML_t
+XML_tr
+XML_l
+XML_r
+XML_bl
+XML_b
+XML_br
+
+
+        mr3DProperties.mnLightRigType = aAttribs.getToken( XML_rig, XML_none );
+
+XML_legacyFlat1
+XML_legacyFlat2
+XML_legacyFlat3
+XML_legacyFlat4
+XML_legacyNormal1
+XML_legacyNormal2
+XML_legacyNormal3
+XML_legacyNormal4
+XML_legacyHarsh1
+XML_legacyHarsh2
+XML_legacyHarsh3
+XML_legacyHarsh4
+XML_threePt
+XML_balanced
+XML_soft
+XML_harsh
+XML_flood
+XML_contrasting
+XML_morning
+XML_sunrise
+XML_sunset
+XML_chilly
+XML_freezing
+XML_flat
+XML_twoPt
+XML_glow
+XML_brightRoom
+
+        // TODO: nested element XML_rot
+		break;
+    case NMSP_DRAWINGML|XML_backdrop:
+    case NMSP_DRAWINGML|XML_extLst:
+        return xRet; // TODO: later (backdrop is not supported by core anyway)
+	}
+	return xRet;
+}
+
+} }
diff --git oox/source/drawingml/shape.cxx oox/source/drawingml/shape.cxx
index b1f3559..c0b582d 100644
--- oox/source/drawingml/shape.cxx
+++ oox/source/drawingml/shape.cxx
@@ -42,8 +42,10 @@
 #include <tools/solar.h>        // for the F_PI180 define
 #include <com/sun/star/graphic/XGraphic.hpp>
 #include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/beans/XMultiPropertySet.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/xml/AttributeData.hpp>
 #include <com/sun/star/drawing/HomogenMatrix3.hpp>
 #include <com/sun/star/text/XText.hpp>
 #include <basegfx/point/b2dpoint.hxx>
@@ -86,6 +88,30 @@ Shape::Shape( const sal_Char* pServiceName )
         msServiceName = OUString::createFromAscii( pServiceName );
     setDefaults();
 }
+
+Shape::Shape( const ShapePtr& pSourceShape )
+: maChildren()
+, mpTextBody(pSourceShape->mpTextBody)
+, mpLinePropertiesPtr( pSourceShape->mpLinePropertiesPtr )
+, mpFillPropertiesPtr( pSourceShape->mpFillPropertiesPtr )
+, mpGraphicPropertiesPtr( pSourceShape->mpGraphicPropertiesPtr )
+, mpCustomShapePropertiesPtr( pSourceShape->mpCustomShapePropertiesPtr )
+, maShapeProperties( pSourceShape->maShapeProperties )
+, mpMasterTextListStyle( pSourceShape->mpMasterTextListStyle )
+, mxShape()
+, msServiceName( pSourceShape->msServiceName )
+, msName( pSourceShape->msName )
+, msId( pSourceShape->msId )
+, mnSubType( pSourceShape->mnSubType )
+, mnIndex( pSourceShape->mnIndex )
+, maSize( pSourceShape->maSize )
+, maPosition( pSourceShape->maPosition )
+, mxCreateCallback( pSourceShape->mxCreateCallback )
+, mnRotation( pSourceShape->mnRotation )
+, mbFlipH( pSourceShape->mbFlipH )
+, mbFlipV( pSourceShape->mbFlipV )
+{}
+
 Shape::~Shape()
 {
 }
@@ -175,6 +201,19 @@ void Shape::applyShapeReference( const Shape& rReferencedShape )
     mbFlipV = rReferencedShape.mbFlipV;
 }
 
+void Shape::addChildren( const ::oox::core::XmlFilterBase& rFilterBase,
+                         const ThemePtr& rxTheme,
+                         const Reference< XShapes >& rxShapes,
+                         const awt::Rectangle* pShapeRect,
+                         ShapeIdMap* pShapeMap )
+{
+    addChildren(rFilterBase, *this, rxTheme, rxShapes, 
+                pShapeRect ? 
+                 *pShapeRect : 
+                 awt::Rectangle( maPosition.X, maPosition.Y, maSize.Width, maSize.Height ), 
+                pShapeMap);
+}
+
 // for group shapes, the following method is also adding each child
 void Shape::addChildren(
         const ::oox::core::XmlFilterBase& rFilterBase,
diff --git oox/source/drawingml/shape3dproperties.cxx oox/source/drawingml/shape3dproperties.cxx
new file mode 100644
index 0000000..31c833e
--- /dev/null
+++ oox/source/drawingml/shape3dproperties.cxx
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: fillproperties.cxx,v $
+ * $Revision: 1.7.6.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "oox/drawingml/shape3dproperties.hxx"
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/frame/XFramesSupplier.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/awt/Gradient.hpp>
+#include <com/sun/star/awt/Size.hpp>
+#include <com/sun/star/awt/XBitmap.hpp>
+#include <com/sun/star/awt/XDevice.hpp>
+#include <com/sun/star/drawing/BitmapMode.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/RectanglePoint.hpp>
+#include <com/sun/star/graphic/XGraphicTransformer.hpp>
+#include "oox/core/modelobjectcontainer.hxx"
+#include "oox/core/xmlfilterbase.hxx"
+#include "oox/helper/propertymap.hxx"
+#include "oox/helper/propertyset.hxx"
+#include "tokens.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::drawing;
+using namespace ::com::sun::star::graphic;
+
+using ::rtl::OUString;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::oox::core::ModelObjectContainer;
+using ::oox::core::XmlFilterBase;
+
+namespace oox {
+namespace drawingml {
+
+// ============================================================================
+
+// ============================================================================
+
+} // namespace drawingml
+} // namespace oox
+
diff --git oox/source/drawingml/shapepropertiescontext.cxx oox/source/drawingml/shapepropertiescontext.cxx
index 9ef39a4..0291a0d 100644
--- oox/source/drawingml/shapepropertiescontext.cxx
+++ oox/source/drawingml/shapepropertiescontext.cxx
@@ -37,6 +37,7 @@
 #include <com/sun/star/container/XNamed.hpp>
 
 #include "oox/core/namespaces.hxx"
+#include "oox/drawingml/scene3dcontext.hxx"
 #include "oox/drawingml/linepropertiescontext.hxx"
 #include "oox/drawingml/fillpropertiesgroupcontext.hxx"
 #include "oox/drawingml/transform2dcontext.hxx"
@@ -108,8 +109,11 @@ Reference< XFastContextHandler > ShapePropertiesContext::createFastChildContext(
 	case NMSP_DRAWINGML|XML_effectDag:	// CT_EffectContainer
 		break;
 
-	// todo
 	case NMSP_DRAWINGML|XML_scene3d:	// CT_Scene3D
+//        xRet.set( new Scene3DContext( *this, xAttribs, *(mrShape.get3DShapeProperties()) ) );
+        break;
+
+	// todo
 	case NMSP_DRAWINGML|XML_sp3d:		// CT_Shape3D
 		break;
 	}
diff --git oox/source/drawingml/textparagraph.cxx oox/source/drawingml/textparagraph.cxx
index e59f59a..190511f 100644
--- oox/source/drawingml/textparagraph.cxx
+++ oox/source/drawingml/textparagraph.cxx
@@ -64,6 +64,9 @@ void TextParagraph::insertAt(
         Reference< XTextRange > xStart( xAt, UNO_QUERY );
 
         sal_Int16 nLevel = maProperties.getLevel();
+
+        OSL_TRACE("TextParagraph::insertAt() - level %d", nLevel);
+
         const TextParagraphPropertiesVector& rListStyle = rTextListStyle.getListStyle();
         if ( nLevel >= static_cast< sal_Int16 >( rListStyle.size() ) )
             nLevel = 0;
@@ -114,6 +117,12 @@ void TextParagraph::insertAt(
 			const OUString sNumberingLevel( CREATE_OUSTRING( "NumberingLevel" ) );
 			xProps->setPropertyValue( sNumberingLevel, Any( static_cast< sal_Int16 >( -1 ) ) );
         }
+        else if ( nLevel > 1 )
+        {
+            // Even more UGLY HACK
+			const OUString sNumberingLevel( CREATE_OUSTRING( "NumberingLevel" ) );
+			xProps->setPropertyValue( sNumberingLevel, Any( static_cast< sal_Int16 >( nLevel-1 ) ) );
+        }
 
 // FIXME this is causing a lot of dispruption (ie does not work). I wonder what to do -- Hub
 //          Reference< XTextRange > xEnd( xAt, UNO_QUERY );
diff --git oox/source/drawingml/textparagraphproperties.cxx oox/source/drawingml/textparagraphproperties.cxx
index b75aa08..7b78d6c 100644
--- oox/source/drawingml/textparagraphproperties.cxx
+++ oox/source/drawingml/textparagraphproperties.cxx
@@ -113,6 +113,7 @@ void BulletList::setSuffixMinusRight()
 
 void BulletList::setType( sal_Int32 nType )
 {
+    OSL_ASSERT((nType & sal_Int32(0xFFFF0000))==0);
 //	OSL_TRACE( "OOX: set list numbering type %d", nType);
 	switch( nType )
 	{
diff --git oox/source/helper/storagebase.cxx oox/source/helper/storagebase.cxx
index 9b853e0..1933257 100644
--- oox/source/helper/storagebase.cxx
+++ oox/source/helper/storagebase.cxx
@@ -49,17 +49,25 @@ namespace oox {
 
 namespace {
 
-void lclSplitFirstElement( OUString& orElement, OUString& orRemainder, const OUString& rFullName )
+void lclSplitFirstElement( OUString& orElement, OUString& orRemainder, OUString aFullName )
 {
-    sal_Int32 nSlashPos = rFullName.indexOf( '/' );
-    if( (0 <= nSlashPos) && (nSlashPos < rFullName.getLength()) )
+    sal_Int32  nSlashPos = aFullName.indexOf( '/' );
+
+    // strip leading slashes
+    while( nSlashPos == 0 )
+    {
+        aFullName = aFullName.copy(1);
+        nSlashPos = aFullName.indexOf( '/' );
+    }
+
+    if( (0 <= nSlashPos) && (nSlashPos < aFullName.getLength()) )
     {
-        orElement = rFullName.copy( 0, nSlashPos );
-        orRemainder = rFullName.copy( nSlashPos + 1 );
+        orElement = aFullName.copy( 0, nSlashPos );
+        orRemainder = aFullName.copy( nSlashPos + 1 );
     }
     else
     {
-        orElement = rFullName;
+        orElement = aFullName;
     }
 }
 
diff --git oox/source/ppt/dgmimport.cxx oox/source/ppt/dgmimport.cxx
new file mode 100644
index 0000000..a091212
--- /dev/null
+++ oox/source/ppt/dgmimport.cxx
@@ -0,0 +1,124 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptimport.cxx,v $
+ * $Revision: 1.8.6.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "oox/ppt/dgmimport.hxx"
+#include "oox/drawingml/theme.hxx"
+#include "oox/drawingml/diagram/diagram.hxx"
+#include "oox/dump/pptxdumper.hxx"
+
+#include <com/sun/star/drawing/XShape.hpp>
+
+using ::rtl::OUString;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::xml::sax;
+using namespace oox::core;
+
+namespace oox { namespace ppt {
+
+OUString SAL_CALL QuickDiagrammingImport_getImplementationName() throw()
+{
+    return CREATE_OUSTRING( "com.sun.star.comp.Impress.oox.QuickDiagrammingImport" );
+}
+
+uno::Sequence< OUString > SAL_CALL QuickDiagrammingImport_getSupportedServiceNames() throw()
+{
+    const OUString aServiceName = CREATE_OUSTRING( "com.sun.star.comp.ooxpptx.dgm.import" );
+    const Sequence< OUString > aSeq( &aServiceName, 1 );
+    return aSeq;
+}
+
+uno::Reference< uno::XInterface > SAL_CALL QuickDiagrammingImport_createInstance(const uno::Reference< lang::XMultiServiceFactory > & rSMgr ) throw( uno::Exception )
+{
+    return (cppu::OWeakObject*)new QuickDiagrammingImport( rSMgr );
+}
+
+QuickDiagrammingImport::QuickDiagrammingImport( const uno::Reference< lang::XMultiServiceFactory > & rSMgr  )
+    : XmlFilterBase( rSMgr )
+{}
+
+bool QuickDiagrammingImport::importDocument() throw()
+{
+    /*  to activate the PPTX dumper, define the environment variable
+        OOO_PPTXDUMPER and insert the full path to the file
+        file:///<path-to-oox-module>/source/dump/pptxdumper.ini. */
+    OOX_DUMP_FILE( ::oox::dump::pptx::Dumper );
+
+    OUString aEmpty;
+    OUString aFragmentPath = getFragmentPathFromType( CREATE_OFFICEDOC_RELATIONSTYPE( "diagramLayout" ) );
+
+    Reference<drawing::XShapes> xParentShape(getParentShape(),
+                                             UNO_QUERY_THROW);
+    oox::drawingml::ShapePtr pShape( 
+        new oox::drawingml::Shape( "com.sun.star.drawing.DiagramShape" ) );
+    drawingml::loadDiagram(pShape, 
+                           *this, 
+                           aEmpty, 
+                           aFragmentPath,
+                           aEmpty,
+                           aEmpty);
+    pShape->addShape( *this,
+                      oox::drawingml::ThemePtr(
+                          new oox::drawingml::Theme()),
+                      xParentShape, 
+                      NULL, 
+                      NULL );
+
+    return true;
+}
+
+bool QuickDiagrammingImport::exportDocument() throw()
+{
+	return false;
+}
+
+const ::oox::drawingml::Theme* QuickDiagrammingImport::getCurrentTheme() const
+{
+    // TODO
+    return 0;
+}
+
+sal_Int32 QuickDiagrammingImport::getSchemeClr( sal_Int32 /*nColorSchemeToken*/ ) const
+{
+    // TODO
+	return 0;
+}
+
+const oox::drawingml::table::TableStyleListPtr QuickDiagrammingImport::getTableStyles()
+{
+    return oox::drawingml::table::TableStyleListPtr();
+}
+
+OUString QuickDiagrammingImport::implGetImplementationName() const
+{
+    return QuickDiagrammingImport_getImplementationName();
+}
+
+}}
diff --git oox/source/ppt/dgmlayout.cxx oox/source/ppt/dgmlayout.cxx
new file mode 100644
index 0000000..f893b18
--- /dev/null
+++ oox/source/ppt/dgmlayout.cxx
@@ -0,0 +1,183 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptimport.cxx,v $
+ * $Revision: 1.8.6.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "oox/ppt/dgmlayout.hxx"
+#include "oox/drawingml/theme.hxx"
+#include "oox/drawingml/themefragmenthandler.hxx"
+#include "oox/drawingml/diagram/diagram.hxx"
+#include "oox/dump/pptxdumper.hxx"
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/drawing/XMasterPageTarget.hpp>
+#include <com/sun/star/xml/dom/XDocument.hpp>
+#include <com/sun/star/xml/sax/XFastSAXSerializable.hpp>
+#include <com/sun/star/container/XChild.hpp>
+
+using ::rtl::OUString;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::xml::sax;
+using namespace oox::core;
+using namespace ::oox::drawingml;
+
+namespace oox { namespace ppt {
+
+OUString SAL_CALL QuickDiagrammingLayout_getImplementationName() throw()
+{
+    return CREATE_OUSTRING( "com.sun.star.comp.Impress.oox.QuickDiagrammingLayout" );
+}
+
+uno::Sequence< OUString > SAL_CALL QuickDiagrammingLayout_getSupportedServiceNames() throw()
+{
+    const OUString aServiceName = CREATE_OUSTRING( "com.sun.star.comp.ooxpptx.dgm.layout" );
+    const Sequence< OUString > aSeq( &aServiceName, 1 );
+    return aSeq;
+}
+
+uno::Reference< uno::XInterface > SAL_CALL QuickDiagrammingLayout_createInstance(const uno::Reference< lang::XMultiServiceFactory > & rSMgr ) throw( uno::Exception )
+{
+    return (cppu::OWeakObject*)new QuickDiagrammingLayout( rSMgr );
+}
+
+QuickDiagrammingLayout::QuickDiagrammingLayout( const uno::Reference< lang::XMultiServiceFactory > & rSMgr  )
+    : XmlFilterBase( rSMgr ),
+    mpThemePtr(new drawingml::Theme())
+{}
+
+bool QuickDiagrammingLayout::importDocument() throw()
+{
+    Reference<drawing::XShape>  xParentShape(getParentShape(),
+                                             UNO_QUERY_THROW);
+    Reference<drawing::XShapes> xParentShapes(xParentShape,
+                                              UNO_QUERY_THROW);
+    Reference<beans::XPropertySet> xPropSet(xParentShape,
+                                            UNO_QUERY_THROW);
+
+    // can we grab the theme from the master page?
+    Reference<container::XChild> xChild(xParentShape,
+                                        UNO_QUERY);
+    if( xChild.is() )
+    {
+        // TODO: cater for diagram shapes inside groups
+        Reference<drawing::XMasterPageTarget> xMasterPageTarget(xChild->getParent(),
+                                                                UNO_QUERY);
+        if( xMasterPageTarget.is() )
+        {
+            uno::Reference<drawing::XDrawPage> xMasterPage(
+                xMasterPageTarget->getMasterPage());
+
+            Reference<beans::XPropertySet> xPropSet2(xMasterPage,
+                                                     UNO_QUERY_THROW);
+            Reference<xml::dom::XDocument> xThemeFragment;
+            xPropSet2->getPropertyValue(
+                CREATE_OUSTRING("PPTTheme")) >>= xThemeFragment;
+
+            importFragment(
+                new ThemeFragmentHandler( 
+                    *this, OUString(), *mpThemePtr ),
+                Reference<xml::sax::XFastSAXSerializable>(
+                    xThemeFragment,
+                    UNO_QUERY_THROW));
+        }
+    }
+
+    Reference<xml::dom::XDocument> xDataModelDom;
+    Reference<xml::dom::XDocument> xLayoutDom;
+    Reference<xml::dom::XDocument> xQStyleDom;
+    Reference<xml::dom::XDocument> xColorStyleDom;
+
+    xPropSet->getPropertyValue(
+        CREATE_OUSTRING("DiagramData")) >>= xDataModelDom;
+    xPropSet->getPropertyValue(
+        CREATE_OUSTRING("DiagramLayout")) >>= xLayoutDom;
+    xPropSet->getPropertyValue(
+        CREATE_OUSTRING("DiagramQStyle")) >>= xQStyleDom;
+    xPropSet->getPropertyValue(
+        CREATE_OUSTRING("DiagramColorStyle")) >>= xColorStyleDom;
+
+    oox::drawingml::ShapePtr pShape( 
+        new oox::drawingml::Shape( "com.sun.star.drawing.DiagramShape" ) );
+    drawingml::loadDiagram(pShape, 
+                           *this, 
+                           xDataModelDom,
+                           xLayoutDom,
+                           xQStyleDom,
+                           xColorStyleDom);
+
+    // don't add pShape itself, but only its children
+    pShape->setXShape(getParentShape());
+
+    const awt::Size& rSize=xParentShape->getSize();
+    const awt::Point& rPoint=xParentShape->getPosition();
+    const long nScaleFactor=360;
+    const awt::Rectangle aRect(nScaleFactor*rPoint.X, 
+                               nScaleFactor*rPoint.Y, 
+                               nScaleFactor*rSize.Width, 
+                               nScaleFactor*rSize.Height);
+
+    pShape->addChildren( *this,
+                         mpThemePtr,
+                         xParentShapes, 
+                         &aRect, 
+                         NULL );
+
+    return true;
+}
+
+bool QuickDiagrammingLayout::exportDocument() throw()
+{
+	return false;
+}
+
+const ::oox::drawingml::Theme* QuickDiagrammingLayout::getCurrentTheme() const
+{
+    return mpThemePtr.get();
+}
+
+sal_Int32 QuickDiagrammingLayout::getSchemeClr( sal_Int32 nColorSchemeToken ) const
+{
+	sal_Int32 nColor = 0;
+    if( mpThemePtr )
+        mpThemePtr->getClrScheme().getColor( nColorSchemeToken, 
+                                             nColor );
+	return nColor;
+}
+
+const oox::drawingml::table::TableStyleListPtr QuickDiagrammingLayout::getTableStyles()
+{
+    return oox::drawingml::table::TableStyleListPtr();
+}
+
+OUString QuickDiagrammingLayout::implGetImplementationName() const
+{
+    return QuickDiagrammingLayout_getImplementationName();
+}
+
+}}
diff --git oox/source/ppt/makefile.mk oox/source/ppt/makefile.mk
index 1dfc87c..cd7cfae 100644
--- oox/source/ppt/makefile.mk
+++ oox/source/ppt/makefile.mk
@@ -54,6 +54,8 @@ SLOFILES =	\
 		$(SLO)$/commontimenodecontext.obj \
 		$(SLO)$/conditioncontext.obj \
 		$(SLO)$/customshowlistcontext.obj \
+		$(SLO)$/dgmimport.obj\
+		$(SLO)$/dgmlayout.obj\
 		$(SLO)$/layoutfragmenthandler.obj\
 		$(SLO)$/pptfilterhelpers.obj\
 		$(SLO)$/pptimport.obj\
diff --git oox/source/ppt/pptimport.cxx oox/source/ppt/pptimport.cxx
index 421987d..682c43c 100644
--- oox/source/ppt/pptimport.cxx
+++ oox/source/ppt/pptimport.cxx
@@ -151,9 +151,9 @@ const oox::drawingml::table::TableStyleListPtr PowerPointImport::getTableStyles(
 	return mpTableStyleList;;
 }
 
-::oox::drawingml::chart::ChartConverter& PowerPointImport::getChartConverter()
+::oox::drawingml::chart::ChartConverter* PowerPointImport::getChartConverter()
 {
-    return *mxChartConv;
+    return mxChartConv.get();
 }
 
 OUString PowerPointImport::implGetImplementationName() const
diff --git oox/source/ppt/presentationfragmenthandler.cxx oox/source/ppt/presentationfragmenthandler.cxx
index 8176573..9a9c41d 100644
--- oox/source/ppt/presentationfragmenthandler.cxx
+++ oox/source/ppt/presentationfragmenthandler.cxx
@@ -35,6 +35,8 @@
 #include <com/sun/star/drawing/XDrawPages.hpp>
 #include <com/sun/star/drawing/XDrawPagesSupplier.hpp>
 #include <com/sun/star/drawing/XMasterPageTarget.hpp>
+#include <com/sun/star/xml/dom/XDocument.hpp>
+#include <com/sun/star/xml/sax/XFastSAXSerializable.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/style/XStyle.hpp>
 #include <com/sun/star/presentation/XPresentationPage.hpp>
@@ -176,8 +178,17 @@ void PresentationFragmentHandler::endDocument() throw (SAXException, RuntimeExce
                                 {
                                     oox::drawingml::ThemePtr pThemePtr( new oox::drawingml::Theme() );
                                     pMasterPersistPtr->setTheme( pThemePtr );
-                                    rFilter.importFragment( new ThemeFragmentHandler( rFilter, aThemeFragmentPath, *pThemePtr ) );
+                                    Reference<xml::dom::XDocument> xDoc=
+                                        rFilter.importFragment(aThemeFragmentPath);
+
+                                    rFilter.importFragment(
+                                        new ThemeFragmentHandler( 
+                                            rFilter, aThemeFragmentPath, *pThemePtr ),
+                                        Reference<xml::sax::XFastSAXSerializable>(
+                                            xDoc,
+                                            UNO_QUERY_THROW));
                                     rThemes[ aThemeFragmentPath ] = pThemePtr;
+                                    pThemePtr->setFragment(xDoc);
                                 }
                                 else
                                 {
diff --git oox/source/ppt/slidepersist.cxx oox/source/ppt/slidepersist.cxx
index 1f889d0..7245c86 100644
--- oox/source/ppt/slidepersist.cxx
+++ oox/source/ppt/slidepersist.cxx
@@ -166,6 +166,17 @@ void SlidePersist::createXShapes( const XmlFilterBase& rFilterBase )
             pNode->setNode( rFilterBase, xNode, pSlidePtr );
 		}
 	}
+
+    // not yet
+#if 0
+    if( getTheme() )
+    { 
+        uno::Reference< beans::XPropertySet > xPagePropSet( mxPage, uno::UNO_QUERY_THROW );
+        xPagePropSet->setPropertyValue( 
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "PPTTheme" )),
+            uno::makeAny(getTheme()->getFragment()));
+    }
+#endif
 }
 
 void SlidePersist::createBackground( const XmlFilterBase& rFilterBase )
diff --git oox/source/shape/ShapeFilterBase.cxx oox/source/shape/ShapeFilterBase.cxx
index b8ebcd9..fb6e6eb 100644
--- oox/source/shape/ShapeFilterBase.cxx
+++ oox/source/shape/ShapeFilterBase.cxx
@@ -68,9 +68,9 @@ const ::oox::drawingml::table::TableStyleListPtr ShapeFilterBase::getTableStyles
 	return ::oox::drawingml::table::TableStyleListPtr();
 }
 
-::oox::drawingml::chart::ChartConverter& ShapeFilterBase::getChartConverter()
+::oox::drawingml::chart::ChartConverter* ShapeFilterBase::getChartConverter()
 {
-    return *mxChartConv;
+    return mxChartConv.get();
 }
 
 ::rtl::OUString ShapeFilterBase::implGetImplementationName() const
diff --git oox/source/shape/ShapeFilterBase.hxx oox/source/shape/ShapeFilterBase.hxx
index b1ad56b..e9546b1 100644
--- oox/source/shape/ShapeFilterBase.hxx
+++ oox/source/shape/ShapeFilterBase.hxx
@@ -64,7 +64,7 @@ public:
     /** Has to be implemented by each filter to return TableStyles. */
 	virtual const ::oox::drawingml::table::TableStyleListPtr getTableStyles();
 
-    virtual ::oox::drawingml::chart::ChartConverter& getChartConverter();
+    virtual ::oox::drawingml::chart::ChartConverter* getChartConverter();
 
     virtual rtl::OUString implGetImplementationName() const;
 
diff --git oox/source/xls/excelfilter.cxx oox/source/xls/excelfilter.cxx
index cb02ba3..fbbad0c 100644
--- oox/source/xls/excelfilter.cxx
+++ oox/source/xls/excelfilter.cxx
@@ -137,7 +137,7 @@ const TableStyleListPtr ExcelFilter::getTableStyles()
     return TableStyleListPtr();
 }
 
-::oox::drawingml::chart::ChartConverter& ExcelFilter::getChartConverter()
+::oox::drawingml::chart::ChartConverter* ExcelFilter::getChartConverter()
 {
     OSL_ENSURE( mpHelper, "ExcelFilter::getChartConverter - no workbook helper" );
     return mpHelper->getChartConverter();
diff --git oox/source/xls/workbookhelper.cxx oox/source/xls/workbookhelper.cxx
index 03a0cc8..49cb5b6 100644
--- oox/source/xls/workbookhelper.cxx
+++ oox/source/xls/workbookhelper.cxx
@@ -230,7 +230,7 @@ public:
     /** Returns the converter for string to cell address/range conversion. */
     inline AddressConverter& getAddressConverter() const { return *mxAddrConverter; }
     /** Returns the chart object converter. */
-    inline ExcelChartConverter& getChartConverter() const { return *mxChartConverter; }
+    inline ExcelChartConverter* getChartConverter() const { return mxChartConverter.get(); }
 
     // property helpers -------------------------------------------------------
 
@@ -846,7 +846,7 @@ AddressConverter& WorkbookHelper::getAddressConverter() const
     return mrBookData.getAddressConverter();
 }
 
-ExcelChartConverter& WorkbookHelper::getChartConverter() const
+ExcelChartConverter* WorkbookHelper::getChartConverter() const
 {
     return mrBookData.getChartConverter();
 }
diff --git sc/source/filter/excel/xestream.cxx sc/source/filter/excel/xestream.cxx
index a279b9d..0f8262c 100644
--- sc/source/filter/excel/xestream.cxx
+++ sc/source/filter/excel/xestream.cxx
@@ -1001,10 +1001,9 @@ const oox::drawingml::table::TableStyleListPtr XclExpXmlStream::getTableStyles()
     return oox::drawingml::table::TableStyleListPtr();
 }
 
-oox::drawingml::chart::ChartConverter& XclExpXmlStream::getChartConverter()
+oox::drawingml::chart::ChartConverter* XclExpXmlStream::getChartConverter()
 {
-    // DO NOT CALL
-    return * (oox::drawingml::chart::ChartConverter*) NULL;
+    return NULL;
 }
 
 bool XclExpXmlStream::exportDocument() throw()
diff --git sc/source/filter/inc/xestream.hxx sc/source/filter/inc/xestream.hxx
index 3b49017..a7a7840 100644
--- sc/source/filter/inc/xestream.hxx
+++ sc/source/filter/inc/xestream.hxx
@@ -341,7 +341,7 @@ public:
 	virtual const oox::vml::DrawingPtr getDrawings();
     virtual const oox::drawingml::Theme* getCurrentTheme() const;
     virtual const oox::drawingml::table::TableStyleListPtr getTableStyles();
-    virtual oox::drawingml::chart::ChartConverter& getChartConverter();
+    virtual oox::drawingml::chart::ChartConverter* getChartConverter();
 
     void Trace( const char* format, ...);
 private:
