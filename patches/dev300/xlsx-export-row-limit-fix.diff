diff --git sc/source/filter/inc/xlconst.hxx sc/source/filter/inc/xlconst.hxx
index eeb3fb3..2a176a9 100644
--- sc/source/filter/inc/xlconst.hxx
+++ sc/source/filter/inc/xlconst.hxx
@@ -77,6 +77,10 @@ const SCCOL EXC_MAXCOL8                     = EXC_MAXCOL5;
 const SCROW EXC_MAXROW8                     = 65535;
 const SCTAB EXC_MAXTAB8                     = EXC_MAXTAB5;
 
+const SCCOL EXC_MAXCOL_XML_2007             = 16383;
+const SCROW EXC_MAXROW_XML_2007             = 1048575;
+const SCTAB EXC_MAXTAB_XML_2007             = 1023;
+
 const sal_uInt16 EXC_NOTAB                  = SAL_MAX_UINT16;   /// An invalid Excel sheet index, for common use.
 const SCTAB SCTAB_INVALID                   = SCTAB_MAX;        /// An invalid Calc sheet index, for common use.
 const SCTAB SCTAB_GLOBAL                    = SCTAB_MAX;        /// A Calc sheet index for the workbook globals.
diff --git sc/source/filter/xlsx/xehelper.hxx sc/source/filter/xlsx/xehelper.hxx
new file mode 100644
index 0000000..b9ed319
--- /dev/null
+++ sc/source/filter/xlsx/xehelper.hxx
@@ -0,0 +1,454 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xehelper.hxx,v $
+ * $Revision: 1.20.32.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XEHELPER_HXX
+#define SC_XEHELPER_HXX
+
+#include "xladdress.hxx"
+#include "xeroot.hxx"
+#include "xestring.hxx"
+
+// Export progress bar ========================================================
+
+class ScfProgressBar;
+
+/** The main progress bar for the export filter.
+
+    This class encapsulates creation and initialization of sub progress
+    segments. The Activate***Segment() functions activate a specific segement
+    of the main progress bar. The implementation of these functions contain the
+    calculation of the needed size of the segment. Following calls of the
+    Progress() function increase the currently activated sub segment.
+ */
+class XclExpProgressBar : protected XclExpRoot
+{
+public:
+    explicit            XclExpProgressBar( const XclExpRoot& rRoot );
+    virtual             ~XclExpProgressBar();
+
+    /** Initializes all segments and sub progress bars. */
+    void                Initialize();
+
+    /** Increases the number of existing ROW records by 1. */
+    void                IncRowRecordCount();
+
+    /** Activates the progress segment to create ROW records. */
+    void                ActivateCreateRowsSegment();
+    /** Activates the progress segment to finalize ROW records. */
+    void                ActivateFinalRowsSegment();
+
+    /** Increases the currently activated (sub) progress bar by 1 step. */
+    void                Progress();
+
+private:
+    typedef ::std::auto_ptr< ScfProgressBar > ScfProgressBarPtr;
+
+    ScfProgressBarPtr   mxProgress;         /// Progress bar implementation.
+    ScfProgressBar*     mpSubProgress;      /// Current sub progress bar.
+
+    ScfProgressBar*     mpSubRowCreate;     /// Sub progress bar for creating table rows.
+    ScfInt32Vec         maSubSegRowCreate;  /// Segment ID's for all sheets in sub progress bar.
+
+    ScfProgressBar*     mpSubRowFinal;      /// Sub progress bar for finalizing ROW records.
+    sal_Int32           mnSegRowFinal;      /// Progress segment for finalizing ROW records.
+
+    sal_Size            mnRowCount;         /// Number of created ROW records.
+};
+
+// Calc->Excel cell address/range conversion ==================================
+
+/** Provides functions to convert Calc cell addresses to Excel cell addresses. */
+class XclExpAddressConverter : public XclAddressConverterBase
+{
+public:
+    explicit            XclExpAddressConverter( const XclExpRoot& rRoot );
+
+    // cell address -----------------------------------------------------------
+
+    /** Checks if the passed Calc cell address is valid.
+        @param rScPos  The Calc cell address to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell address is not valid.
+        @return  true = Cell address in rScPos is valid. */
+    bool                CheckAddress( const ScAddress& rScPos, bool bWarn );
+
+    /** Converts the passed Calc cell address to an Excel cell address.
+        @param rXclPos  (Out) The converted Excel cell address, if valid.
+        @param rScPos  The Calc cell address to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell address is not valid.
+        @return  true = Cell address returned in rXclPos is valid. */
+    bool                ConvertAddress( XclAddress& rXclPos,
+                            const ScAddress& rScPos, bool bWarn );
+
+    /** Returns a valid cell address by moving it into allowed dimensions.
+        @param rScPos  The Calc cell address to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell address is invalid.
+        @return  The converted Excel cell address. */
+    XclAddress          CreateValidAddress( const ScAddress& rScPos, bool bWarn );
+
+    // cell range -------------------------------------------------------------
+
+    /** Checks if the passed cell range is valid (checks start and end position).
+        @param rScRange  The Calc cell range to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell range is not valid.
+        @return  true = Cell range in rScRange is valid. */
+    bool                CheckRange( const ScRange& rScRange, bool bWarn );
+
+    /** Checks and eventually crops the cell range to valid dimensions.
+        @descr  The start position of the range will not be modified.
+        @param rScRange  (In/out) The cell range to validate.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell range contains invalid
+            cells. If the range is partly valid, this function sets the warning
+            flag, corrects the range and returns true.
+        @return  true = Cell range in rScRange is valid (original or cropped). */
+    bool                ValidateRange( ScRange& rScRange, bool bWarn );
+
+    /** Converts the passed Calc cell range to an Excel cell range.
+        @param rXclRange  (Out) The converted Excel cell range, if valid.
+        @param rScRange  The Calc cell range to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell range contains invalid cells.
+        @return  true = Cell range returned in rXclRange is valid (original or cropped). */
+    bool                ConvertRange( XclRange& rXclRange, const ScRange& rScRange, bool bWarn );
+
+//UNUSED2008-05  /** Returns a valid cell range by moving it into allowed dimensions.
+//UNUSED2008-05      @descr  The start and/or end position of the range may be modified.
+//UNUSED2008-05      @param rScRange  The Calc cell range to convert.
+//UNUSED2008-05      @param bWarn  true = Sets the internal flag that produces a warning box
+//UNUSED2008-05          after loading/saving the file, if the cell range contains invalid cells.
+//UNUSED2008-05      @return  The converted Excel cell range. */
+//UNUSED2008-05  XclRange            CreateValidRange( const ScRange& rScRange, bool bWarn );
+
+    // cell range list --------------------------------------------------------
+
+//UNUSED2008-05  /** Checks if the passed cell range list is valid.
+//UNUSED2008-05      @param rScRanges  The Calc cell range list to check.
+//UNUSED2008-05      @param bWarn  true = Sets the internal flag that produces a warning box
+//UNUSED2008-05          after loading/saving the file, if the cell range list contains at
+//UNUSED2008-05          least one invalid range.
+//UNUSED2008-05      @return  true = Cell range list in rScRanges is completly valid. */
+//UNUSED2008-05  bool                CheckRangeList( const ScRangeList& rScRanges, bool bWarn );
+
+    /** Checks and eventually crops the cell ranges to valid dimensions.
+        @descr  The start position of the ranges will not be modified. Cell
+            ranges that fit partly into valid dimensions are cropped
+            accordingly. Cell ranges that do not fit at all, are removed from
+            the cell range list.
+        @param rScRanges  (In/out) The cell range list to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if at least one of the cell ranges
+            contains invalid cells. */
+    void                ValidateRangeList( ScRangeList& rScRanges, bool bWarn );
+
+    /** Converts the passed Calc cell range list to an Excel cell range list.
+        @descr  The start position of the ranges will not be modified. Cell
+            ranges that fit partly into valid dimensions are cropped
+            accordingly. Cell ranges that do not fit at all, are not inserted
+            into the Excel cell range list.
+        @param rXclRanges  (Out) The converted Excel cell range list.
+        @param rScRanges  The Calc cell range list to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if at least one of the cell ranges
+            contains invalid cells. */
+    void                ConvertRangeList( XclRangeList& rXclRanges,
+                            const ScRangeList& rScRanges, bool bWarn );
+};
+
+// EditEngine->String conversion ==============================================
+
+class SvxURLField;
+class XclExpHyperlink;
+
+/** Helper to create HLINK records during creation of formatted cell strings.
+
+    In Excel it is not possible to have more than one hyperlink in a cell. This
+    helper detects multiple occurences of hyperlinks and fills a string which
+    is used to create a cell note containing all URLs. Only cells containing
+    one hyperlink are exported as hyperlink cells.
+ */
+class XclExpHyperlinkHelper : protected XclExpRoot
+{
+public:
+    typedef ScfRef< XclExpHyperlink > XclExpHyperlinkRef;
+
+    explicit            XclExpHyperlinkHelper( const XclExpRoot& rRoot, const ScAddress& rScPos );
+                        ~XclExpHyperlinkHelper();
+
+    /** Processes the passed URL field (tries to create a HLINK record).
+        @return  The representation string of the URL field. */
+    String              ProcessUrlField( const SvxURLField& rUrlField );
+
+    /** Returns true, if a single HLINK record has been created. */
+    bool                HasLinkRecord() const;
+    /** Returns the craeted single HLINk record, or an empty reference. */
+    XclExpHyperlinkRef  GetLinkRecord();
+
+    /** Returns true, if multiple URLs have been processed. */
+    inline bool         HasMultipleUrls() const { return mbMultipleUrls; }
+    /** Returns a string containing all processed URLs. */
+    inline const String& GetUrlList() { return maUrlList; }
+
+private:
+    XclExpHyperlinkRef  mxLinkRec;          /// Created HLINK record.
+    ScAddress           maScPos;            /// Cell position to set at the HLINK record.
+    String              maUrlList;          /// List with all processed URLs.
+    bool                mbMultipleUrls;     /// true = Multiple URL fields processed.
+};
+
+// ----------------------------------------------------------------------------
+
+class EditEngine;
+class SdrTextObj;
+class ScStringCell;
+class ScEditCell;
+class ScPatternAttr;
+
+/** This class provides methods to create an XclExpString.
+    @descr  The string can be created from an edit engine text object or
+    directly from a Calc edit cell. */
+class XclExpStringHelper : ScfNoInstance
+{
+public:
+    /** Creates a new unformatted string from the passed string.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param rString  The source string.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            const String& rString,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new unformatted string from the passed character.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param cChar  The source character. The NUL character is explicitly allowed.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            sal_Unicode cChar,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Appends an unformatted string to an Excel string object.
+        @descr  Selects the correct Append() function depending on the current
+                BIFF version contained in the passed XclExpRoot object.
+        @param rXclString  The Excel string object.
+        @param rString  The source string. */
+    static void         AppendString(
+                            XclExpString& rXclString,
+                            const XclExpRoot& rRoot,
+                            const String& rString );
+
+    /** Appends a character to an Excel string object.
+        @descr  Selects the correct Append() function depending on the current
+                BIFF version contained in the passed XclExpRoot object.
+        @param rXclString  The Excel string object.
+        @param rString  The source string. */
+    static void         AppendChar(
+                            XclExpString& rXclString,
+                            const XclExpRoot& rRoot,
+                            sal_Unicode cChar );
+
+    /** Creates a new formatted string from a Calc string cell.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+                May create a formatted string object, if the cell text contains
+                different script types.
+        @param rStringCell  The Calc string cell object.
+        @param pCellAttr  The set item containing the cell formatting.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateCellString(
+                            const XclExpRoot& rRoot,
+                            const ScStringCell& rStringCell,
+                            const ScPatternAttr* pCellAttr,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new formatted string from a Calc edit cell.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param rEditCell  The Calc edit cell object.
+        @param pCellAttr  The set item containing the cell formatting.
+        @param rLinkHelper  Helper object for hyperlink conversion.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateCellString(
+                            const XclExpRoot& rRoot,
+                            const ScEditCell& rEditCell,
+                            const ScPatternAttr* pCellAttr,
+                            XclExpHyperlinkHelper& rLinkHelper,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new formatted string from a drawing text box.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param rTextObj  The text box object.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            const SdrTextObj& rTextObj,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new formatted string from a edit text string.
+        @param rEditObj  The edittext object.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen The maximum number of characters to store in this string.
+        @return  The new string object. */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            const EditTextObject& rEditObj,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Returns the script type first text portion different to WEAK, or the system
+        default script type, if there is only weak script in the passed string. */
+    static sal_Int16    GetLeadingScriptType( const XclExpRoot& rRoot, const String& rString );
+};
+
+// Header/footer conversion ===================================================
+
+class EditEngine;
+
+/** Converts edit engine text objects to an Excel header/footer string.
+    @descr  Header/footer content is divided into three parts: Left, center and
+    right portion. All formatting information will be encoded in the Excel string
+    using special character seuences. A control sequence starts with the ampersand
+    character.
+
+    Supported control sequences:
+    &L                      start of left portion
+    &C                      start of center portion
+    &R                      start of right portion
+    &P                      current page number
+    &N                      page count
+    &D                      current date
+    &T                      current time
+    &A                      table name
+    &F                      file name without path
+    &Z                      file path without file name
+    &Z&F                    file path and name
+    &U                      underlining on/off
+    &E                      double underlining on/off
+    &S                      strikeout characters on/off
+    &X                      superscript on/off
+    &Y                      subscript on/off
+    &"fontname,fontstyle"   use font with name 'fontname' and style 'fontstyle'
+    &fontheight             set font height in points ('fontheight' is a decimal value)
+
+    Known but unsupported control sequences:
+    &G                      picture
+ */
+class XclExpHFConverter : protected XclExpRoot, ScfNoCopy
+{
+public:
+    explicit            XclExpHFConverter( const XclExpRoot& rRoot );
+
+    /** Generates the header/footer string from the passed edit engine text objects. */
+    void                GenerateString(
+                            const EditTextObject* pLeftObj,
+                            const EditTextObject* pCenterObj,
+                            const EditTextObject* pRightObj );
+
+    /** Returns the last generated header/footer string. */
+    inline const String& GetHFString() const { return maHFString; }
+    /** Returns the total height of the last generated header/footer in twips. */
+    inline sal_Int32    GetTotalHeight() const { return mnTotalHeight; }
+
+private:
+    /** Converts the text object contents and stores it in the passed string. */
+    void                AppendPortion(
+                            const EditTextObject* pTextObj,
+                            sal_Unicode cPortionCode );
+
+private:
+    EditEngine&         mrEE;           /// The header/footer edit engine.
+    String              maHFString;     /// The last generated header/footer string.
+    sal_Int32           mnTotalHeight;  /// Total height of the last header/footer (twips).
+};
+
+// URL conversion =============================================================
+
+/** This class contains static methods to encode a file URL.
+    @descr  Excel stores URLs in a format that contains special control characters,
+    i.e. for directory separators or volume names. */
+class XclExpUrlHelper : ScfNoInstance
+{
+public:
+    /** Encodes and returns the URL passed in rAbsUrl to an Excel like URL.
+        @param pTableName  Optional pointer to a table name to be encoded in this URL. */
+    static String       EncodeUrl( const XclExpRoot& rRoot, const String& rAbsUrl, const String* pTableName = 0 );
+    /** Encodes and returns the passed DDE link to an Excel like DDE link. */
+    static String       EncodeDde( const String& rApplic, const String rTopic );
+};
+
+// ----------------------------------------------------------------------------
+class ScDocument;
+class ScMatrix;
+
+/** Contains cached values in a 2-dimensional array. */
+class XclExpCachedMatrix
+{
+    void            GetDimensions( SCSIZE & nCols, SCSIZE & nRows ) const;
+public:
+    /** Constructs and fills a new matrix.
+        @param rMatrix  The Calc value matrix. */
+    explicit        XclExpCachedMatrix( const ScMatrix& rMatrix );
+                   ~XclExpCachedMatrix();
+
+    /** Returns the byte count of all contained data. */
+    sal_Size        GetSize() const;
+    /** Writes the complete matrix to stream. */
+    void            Save( XclExpStream& rStrm ) const;
+
+private:
+    const ScMatrix& mrMatrix;
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xeroot.hxx sc/source/filter/xlsx/xeroot.hxx
new file mode 100644
index 0000000..f4e1d25
--- /dev/null
+++ sc/source/filter/xlsx/xeroot.hxx
@@ -0,0 +1,173 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xeroot.hxx,v $
+ * $Revision: 1.21 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XEROOT_HXX
+#define SC_XEROOT_HXX
+
+#include "xlroot.hxx"
+
+// Forward declarations of objects in public use ==============================
+
+class XclExpStream;
+class XclExpRecordBase;
+class XclExpString;
+
+typedef ScfRef< XclExpRecordBase >  XclExpRecordRef;
+typedef ScfRef< XclExpString >      XclExpStringRef;
+
+// Global data ================================================================
+
+class XclExpTabInfo;
+class XclExpAddressConverter;
+class XclExpFormulaCompiler;
+class XclExpProgressBar;
+class XclExpSst;
+class XclExpPalette;
+class XclExpFontBuffer;
+class XclExpNumFmtBuffer;
+class XclExpXFBuffer;
+class XclExpLinkManager;
+class XclExpNameManager;
+class XclExpFilterManager;
+class XclExpPivotTableManager;
+
+/** Stores global buffers and data needed for Excel export filter. */
+struct XclExpRootData : public XclRootData
+{
+    typedef ScfRef< XclExpTabInfo >             XclExpTabInfoRef;
+    typedef ScfRef< XclExpAddressConverter >    XclExpAddrConvRef;
+    typedef ScfRef< XclExpFormulaCompiler >     XclExpFmlaCompRef;
+    typedef ScfRef< XclExpProgressBar >         XclExpProgressRef;
+
+    typedef ScfRef< XclExpSst >                 XclExpSstRef;
+    typedef ScfRef< XclExpPalette >             XclExpPaletteRef;
+    typedef ScfRef< XclExpFontBuffer >          XclExpFontBfrRef;
+    typedef ScfRef< XclExpNumFmtBuffer >        XclExpNumFmtBfrRef;
+    typedef ScfRef< XclExpXFBuffer >            XclExpXFBfrRef;
+    typedef ScfRef< XclExpNameManager >         XclExpNameMgrRef;
+    typedef ScfRef< XclExpLinkManager >         XclExpLinkMgrRef;
+    typedef ScfRef< XclExpFilterManager >       XclExpFilterMgrRef;
+    typedef ScfRef< XclExpPivotTableManager >   XclExpPTableMgrRef;
+
+    XclExpTabInfoRef    mxTabInfo;          /// Calc->Excel sheet index conversion.
+    XclExpAddrConvRef   mxAddrConv;         /// The address converter.
+    XclExpFmlaCompRef   mxFmlaComp;         /// The formula compiler.
+    XclExpProgressRef   mxProgress;         /// The export progress bar.
+
+    XclExpSstRef        mxSst;              /// The shared string table.
+    XclExpPaletteRef    mxPalette;          /// The color buffer.
+    XclExpFontBfrRef    mxFontBfr;          /// All fonts in the file.
+    XclExpNumFmtBfrRef  mxNumFmtBfr;        /// All number formats in the file.
+    XclExpXFBfrRef      mxXFBfr;            /// All XF records in the file.
+    XclExpNameMgrRef    mxNameMgr;          /// Internal defined names.
+    XclExpLinkMgrRef    mxGlobLinkMgr;      /// Global link manager for defined names.
+    XclExpLinkMgrRef    mxLocLinkMgr;       /// Local link manager for a sheet.
+    XclExpFilterMgrRef  mxFilterMgr;        /// Manager for filtered areas in all sheets.
+    XclExpPTableMgrRef  mxPTableMgr;        /// All pivot tables and pivot caches.
+
+    bool                mbRelUrl;           /// true = Store URLs relative.
+
+    explicit            XclExpRootData( XclBiff eBiff, SfxMedium& rMedium,
+                            SotStorageRef xRootStrg, ScDocument& rDoc, rtl_TextEncoding eTextEnc );
+    virtual             ~XclExpRootData();
+};
+
+// ----------------------------------------------------------------------------
+
+/** Access to global data from other classes. */
+class XclExpRoot : public XclRoot
+{
+public:
+    explicit            XclExpRoot( XclExpRootData& rExpRootData );
+
+    /** Returns this root instance - for code readability in derived classes. */
+    inline const XclExpRoot& GetRoot() const { return *this; }
+    /** Returns true, if URLs should be stored relative to the document location. */
+    inline bool         IsRelUrl() const { return mrExpData.mbRelUrl; }
+
+    /** Returns the buffer for Calc->Excel sheet index conversion. */
+    XclExpTabInfo&      GetTabInfo() const;
+    /** Returns the address converter. */
+    XclExpAddressConverter& GetAddressConverter() const;
+    /** Returns the formula compiler to produce formula token arrays. */
+    XclExpFormulaCompiler& GetFormulaCompiler() const;
+    /** Returns the export progress bar. */
+    XclExpProgressBar&  GetProgressBar() const;
+
+    /** Returns the shared string table. */
+    XclExpSst&          GetSst() const;
+    /** Returns the color buffer. */
+    XclExpPalette&      GetPalette() const;
+    /** Returns the font buffer. */
+    XclExpFontBuffer&   GetFontBuffer() const;
+    /** Returns the number format buffer. */
+    XclExpNumFmtBuffer& GetNumFmtBuffer() const;
+    /** Returns the cell formatting attributes buffer. */
+    XclExpXFBuffer&     GetXFBuffer() const;
+    /** Returns the global link manager for defined names. */
+    XclExpLinkManager&  GetGlobalLinkManager() const;
+    /** Returns the local link manager for the current sheet. */
+    XclExpLinkManager&  GetLocalLinkManager() const;
+    /** Returns the buffer that contains internal defined names. */
+    XclExpNameManager&  GetNameManager() const;
+    /** Returns the filter manager. */
+    XclExpFilterManager& GetFilterManager() const;
+    /** Returns the pivot table manager. */
+    XclExpPivotTableManager& GetPivotTableManager() const;
+
+    /** Is called when export filter starts to create the Excel document (all BIFF versions). */
+    void                InitializeConvert();
+    /** Is called when export filter starts to create the workbook global data (>=BIFF5). */
+    void                InitializeGlobals();
+    /** Is called when export filter starts to create data for a single sheet (all BIFF versions). */
+    void                InitializeTable( SCTAB nScTab );
+    /** Is called before export filter starts to write the records to the stream. */
+    void                InitializeSave();
+    /** Returns the reference to a record (or record list) representing a root object.
+        @param nRecId  Identifier that specifies which record is returned. */
+    XclExpRecordRef     CreateRecord( sal_uInt16 nRecId ) const;
+
+    bool                IsDocumentEncrypted() const;
+
+    const String        GetPassword() const;
+
+private:
+
+    /** Returns the local or global link manager, depending on current context. */
+    XclExpRootData::XclExpLinkMgrRef GetLocalLinkMgrRef() const;
+
+private:
+    mutable XclExpRootData& mrExpData;      /// Reference to the global export data struct.
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xetable.hxx sc/source/filter/xlsx/xetable.hxx
index 2beb423..66a9e06 100644
--- sc/source/filter/xlsx/xetable.hxx
+++ sc/source/filter/xlsx/xetable.hxx
@@ -73,7 +73,7 @@ class XclExpRangeFmlaBase : public XclExpRecord
 {
 public:
     /** Returns true, if the passed cell position is equal to own base position. */
-    bool                IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const;
+    bool                IsBasePos( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const;
 
     /** Derived classes create the token array for a corresponding FORMULA cell record. */
     virtual XclTokenArrayRef CreateCellTokenArray( const XclExpRoot& rRoot ) const = 0;
@@ -240,9 +240,9 @@ private:
     SCTAB               mnScTab;        /// Sheet index of this record.
     sal_uInt16          mnLastAppXclCol;/// Column index of last appended cell.
     sal_uInt16          mnColInpXclCol; /// Column index of column input cell.
-    sal_uInt16          mnColInpXclRow; /// Row index of column input cell.
+    sal_uInt32          mnColInpXclRow; /// Row index of column input cell.
     sal_uInt16          mnRowInpXclCol; /// Column index of row input cell.
-    sal_uInt16          mnRowInpXclRow; /// Row index of row input cell.
+    sal_uInt32          mnRowInpXclRow; /// Row index of row input cell.
     sal_uInt8           mnScMode;       /// Type of the multiple operation (Calc constant).
     bool                mbValid;        /// true = Contains valid references.
 };
@@ -289,7 +289,7 @@ public:
     /** Returns the (first) Excel column index of the cell(s). */
     inline sal_uInt16   GetXclCol() const { return maXclPos.mnCol; }
     /** Returns the Excel row index of the cell. */
-    inline sal_uInt16   GetXclRow() const { return maXclPos.mnRow; }
+    inline sal_uInt32   GetXclRow() const { return maXclPos.mnRow; }
 
     /** Derived classes return the column index of the last contained cell. */
     virtual sal_uInt16  GetLastXclCol() const = 0;
@@ -317,7 +317,7 @@ protected:
     /** Sets this record to a new column position. */
     inline void         SetXclCol( sal_uInt16 nXclCol ) { maXclPos.mnCol = nXclCol; }
     /** Sets this record to a new row position. */
-    inline void         SetXclRow( sal_uInt16 nXclRow ) { maXclPos.mnRow = nXclRow; }
+    inline void         SetXclRow( sal_uInt32 nXclRow ) { maXclPos.mnRow = nXclRow; }
 
 private:
     XclAddress          maXclPos;       /// Address of the cell.
@@ -900,11 +900,11 @@ public:
     /** Constructs the ROW record and converts the Calc row settings.
         @param bAlwaysEmpty  true = This row will not be filled with blank cells
             in the Finalize() function. */
-    explicit            XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
+    explicit            XclExpRow( const XclExpRoot& rRoot, sal_uInt32 nXclRow,
                             XclExpRowOutlineBuffer& rOutlineBfr, bool bAlwaysEmpty );
 
     /** Returns the excel row index of this ROW record. */
-    inline sal_uInt16   GetXclRow() const { return mnXclRow; }
+    inline sal_uInt32   GetXclRow() const { return mnXclRow; }
     /** Returns the height of the row in twips. */
     inline sal_uInt16   GetHeight() const { return mnHeight; }
     /** Returns true, if this row does not contain at least one valid cell. */
@@ -959,7 +959,7 @@ private:
     typedef XclExpRecordList< XclExpCellBase > XclExpCellList;
 
     XclExpCellList      maCellList;         /// List of cell records for this row.
-    sal_uInt16          mnXclRow;           /// Excel row index of this row.
+    sal_uInt32          mnXclRow;           /// Excel row index of this row.
     sal_uInt16          mnHeight;           /// Row height in twips.
     sal_uInt16          mnFlags;            /// Flags for the ROW record.
     sal_uInt16          mnXFIndex;          /// Default row formatting.
@@ -1002,7 +1002,7 @@ private:
     /** Returns access to the specified ROW record. Inserts preceding missing ROW records.
         @param bRowAlwaysEmpty  true = Created rows will not be filled with blank cells
             in the XclExpRow::Finalize() function. */
-    XclExpRow&          GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysEmpty );
+    XclExpRow&          GetOrCreateRow( sal_uInt32 nXclRow, bool bRowAlwaysEmpty );
 
 private:
     typedef XclExpRecordList< XclExpRow >   XclExpRowList;
@@ -1012,7 +1012,7 @@ private:
     XclExpRowOutlineBuffer maOutlineBfr;    /// Buffer for row outline groups.
     XclExpDimensions    maDimensions;       /// DIMENSIONS record for used area.
     XclExpRow*          mpLastUsedRow;      /// Last used row for faster access.
-    sal_uInt16          mnLastUsedXclRow;   /// Last used row for faster access.
+    sal_uInt32          mnLastUsedXclRow;   /// Last used row for faster access.
 };
 
 // ============================================================================
diff --git sc/source/filter/xlsx/xeview.hxx sc/source/filter/xlsx/xeview.hxx
index 5c54ecd..592d3ff 100644
--- sc/source/filter/xlsx/xeview.hxx
+++ sc/source/filter/xlsx/xeview.hxx
@@ -111,7 +111,7 @@ private:
 
 private:
     sal_uInt16          mnSplitX;           /// Split X position, or frozen column.
-    sal_uInt16          mnSplitY;           /// Split Y position, or frozen row.
+    sal_uInt32          mnSplitY;           /// Split Y position, or frozen row.
     XclAddress          maSecondXclPos;     /// First visible cell in additional panes.
     sal_uInt8           mnActivePane;       /// Active pane (with cell cursor).
 };
diff --git sc/source/filter/xlsx/xladdress.hxx sc/source/filter/xlsx/xladdress.hxx
new file mode 100644
index 0000000..1d3030a
--- /dev/null
+++ sc/source/filter/xlsx/xladdress.hxx
@@ -0,0 +1,153 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xladdress.hxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLADDRESS_HXX
+#define SC_XLADDRESS_HXX
+
+#include <vector>
+#include "address.hxx"
+
+class ScRangeList;
+class XclImpStream;
+class XclExpStream;
+
+// ============================================================================
+
+/** A 2D cell address struct with Excel column and row indexes. */
+struct XclAddress
+{
+    sal_uInt16          mnCol;
+    sal_uInt32          mnRow;
+
+    inline explicit     XclAddress( ScAddress::Uninitialized ) {}
+    inline explicit     XclAddress() : mnCol( 0 ), mnRow( 0 ) {}
+    inline explicit     XclAddress( sal_uInt16 nCol, sal_uInt32 nRow ) : mnCol( nCol ), mnRow( nRow ) {}
+
+    inline void         Set( sal_uInt16 nCol, sal_uInt32 nRow ) { mnCol = nCol; mnRow = nRow; }
+};
+
+inline bool operator==( const XclAddress& rL, const XclAddress& rR )
+{
+    return (rL.mnCol == rR.mnCol) && (rL.mnRow == rR.mnRow);
+}
+
+inline bool operator<( const XclAddress& rL, const XclAddress& rR )
+{
+    return (rL.mnCol < rR.mnCol) || ((rL.mnCol == rR.mnCol) && (rL.mnRow < rR.mnRow));
+}
+
+// ----------------------------------------------------------------------------
+
+/** A 2D cell range address struct with Excel column and row indexes. */
+struct XclRange
+{
+    XclAddress          maFirst;
+    XclAddress          maLast;
+
+    inline explicit     XclRange( ScAddress::Uninitialized e ) : maFirst( e ), maLast( e ) {}
+    inline explicit     XclRange() {}
+    inline explicit     XclRange( const XclAddress& rPos ) : maFirst( rPos ), maLast( rPos ) {}
+    inline explicit     XclRange( const XclAddress& rFirst, const XclAddress& rLast ) : maFirst( rFirst ), maLast( rLast ) {}
+    inline explicit     XclRange( sal_uInt16 nCol1, sal_uInt32 nRow1, sal_uInt16 nCol2, sal_uInt32 nRow2 ) :
+                            maFirst( nCol1, nRow1 ), maLast( nCol2, nRow2 ) {}
+
+    inline void         Set( const XclAddress& rFirst, const XclAddress& rLast )
+                            { maFirst = rFirst; maLast = rLast; }
+    inline void         Set( sal_uInt16 nCol1, sal_uInt32 nRow1, sal_uInt16 nCol2, sal_uInt32 nRow2 )
+                            { maFirst.Set( nCol1, nRow1 ); maLast.Set( nCol2, nRow2 ); }
+
+    inline sal_uInt16   GetColCount() const { return maLast.mnCol - maFirst.mnCol + 1; }
+    inline sal_uInt32   GetRowCount() const { return maLast.mnRow - maFirst.mnRow + 1; }
+    bool                Contains( const XclAddress& rPos ) const;
+};
+
+inline bool operator==( const XclRange& rL, const XclRange& rR )
+{
+    return (rL.maFirst == rR.maFirst) && (rL.maLast == rR.maLast);
+}
+
+inline bool operator<( const XclRange& rL, const XclRange& rR )
+{
+    return (rL.maFirst < rR.maFirst) || ((rL.maFirst == rR.maFirst) && (rL.maLast < rR.maLast));
+}
+
+// ----------------------------------------------------------------------------
+
+/** A 2D cell range address list with Excel column and row indexes. */
+class XclRangeList : public ::std::vector< XclRange >
+{
+public:
+    inline explicit     XclRangeList() {}
+
+    XclRange            GetEnclosingRange() const;
+};
+
+// ============================================================================
+
+class XclTracer;
+
+/** Base class for import/export address converters. */
+class XclAddressConverterBase
+{
+public:
+    explicit            XclAddressConverterBase( XclTracer& rTracer, const ScAddress& rMaxPos );
+    virtual             ~XclAddressConverterBase();
+
+    /** Returns whether the "some columns have been cut" warning box should be shown. */
+    inline bool         IsColTruncated() const { return mbColTrunc; }
+    /** Returns whether the "some rows have been cut" warning box should be shown. */
+    inline bool         IsRowTruncated() const { return mbRowTrunc; }
+    /** Returns whether the "some sheets have been cut" warning box should be shown. */
+    inline bool         IsTabTruncated() const { return mbTabTrunc; }
+
+    // ------------------------------------------------------------------------
+
+    /** Checks if the passed sheet index is valid.
+        @param nScTab  The sheet index to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the sheet index is not valid.
+        @return  true = Sheet index in nScTab is valid. */
+    bool                CheckScTab( SCTAB nScTab, bool bWarn );
+
+    // ------------------------------------------------------------------------
+protected:
+    XclTracer&          mrTracer;       /// Tracer for invalid addresses.
+    ScAddress           maMaxPos;       /// Default maximum position.
+    sal_uInt16          mnMaxCol;       /// Maximum column index, as 16-bit value.
+    sal_uInt32          mnMaxRow;       /// Maximum row index.
+    bool                mbColTrunc;     /// Flag for "columns truncated" warning box.
+    bool                mbRowTrunc;     /// Flag for "rows truncated" warning box.
+    bool                mbTabTrunc;     /// Flag for "tables truncated" warning box.
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xlescher.hxx sc/source/filter/xlsx/xlescher.hxx
new file mode 100644
index 0000000..d6c9b7c
--- /dev/null
+++ sc/source/filter/xlsx/xlescher.hxx
@@ -0,0 +1,454 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlescher.hxx,v $
+ * $Revision: 1.22.90.12 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLESCHER_HXX
+#define SC_XLESCHER_HXX
+
+#include <vcl/mapunit.hxx>
+#include "fapihelper.hxx"
+#include "xladdress.hxx"
+#include "xlstyle.hxx"
+
+namespace com { namespace sun { namespace star {
+    namespace drawing { class XShape; }
+    namespace awt { class XControlModel; }
+    namespace script { struct ScriptEventDescriptor; }
+} } }
+
+class SdrObject;
+class Rectangle;
+class ScDocument;
+class SvStream;
+class XclImpStream;
+class XclExpStream;
+
+// Constants and Enumerations =================================================
+
+// (0x001C) NOTE --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_NOTE                = 0x001C;
+const sal_uInt16 EXC_NOTE_VISIBLE           = 0x0002;
+const sal_uInt16 EXC_NOTE5_MAXLEN           = 2048;
+
+// (0x005D) OBJ ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_OBJ                 = 0x005D;
+
+const sal_uInt16 EXC_OBJ_INVALID_ID         = 0;
+
+// object types
+const sal_uInt16 EXC_OBJTYPE_GROUP          = 0;
+const sal_uInt16 EXC_OBJTYPE_LINE           = 1;
+const sal_uInt16 EXC_OBJTYPE_RECTANGLE      = 2;
+const sal_uInt16 EXC_OBJTYPE_OVAL           = 3;
+const sal_uInt16 EXC_OBJTYPE_ARC            = 4;
+const sal_uInt16 EXC_OBJTYPE_CHART          = 5;
+const sal_uInt16 EXC_OBJTYPE_TEXT           = 6;
+const sal_uInt16 EXC_OBJTYPE_BUTTON         = 7;
+const sal_uInt16 EXC_OBJTYPE_PICTURE        = 8;
+const sal_uInt16 EXC_OBJTYPE_POLYGON        = 9;        // new in BIFF4
+const sal_uInt16 EXC_OBJTYPE_CHECKBOX       = 11;       // new in BIFF5
+const sal_uInt16 EXC_OBJTYPE_OPTIONBUTTON   = 12;
+const sal_uInt16 EXC_OBJTYPE_EDIT           = 13;
+const sal_uInt16 EXC_OBJTYPE_LABEL          = 14;
+const sal_uInt16 EXC_OBJTYPE_DIALOG         = 15;
+const sal_uInt16 EXC_OBJTYPE_SPIN           = 16;
+const sal_uInt16 EXC_OBJTYPE_SCROLLBAR      = 17;
+const sal_uInt16 EXC_OBJTYPE_LISTBOX        = 18;
+const sal_uInt16 EXC_OBJTYPE_GROUPBOX       = 19;
+const sal_uInt16 EXC_OBJTYPE_DROPDOWN       = 20;
+const sal_uInt16 EXC_OBJTYPE_NOTE           = 25;       // new in BIFF8
+const sal_uInt16 EXC_OBJTYPE_DRAWING        = 30;
+const sal_uInt16 EXC_OBJTYPE_UNKNOWN        = 0xFFFF;   /// For internal use only.
+
+// BIFF3-BIFF5 flags
+const sal_uInt16 EXC_OBJ_HIDDEN             = 0x0100;
+const sal_uInt16 EXC_OBJ_VISIBLE            = 0x0200;
+const sal_uInt16 EXC_OBJ_PRINTABLE          = 0x0400;
+
+// BIFF5 line formatting
+const sal_uInt8 EXC_OBJ_LINE_AUTOCOLOR      = 64;
+
+const sal_uInt8 EXC_OBJ_LINE_SOLID          = 0;
+const sal_uInt8 EXC_OBJ_LINE_DASH           = 1;
+const sal_uInt8 EXC_OBJ_LINE_DOT            = 2;
+const sal_uInt8 EXC_OBJ_LINE_DASHDOT        = 3;
+const sal_uInt8 EXC_OBJ_LINE_DASHDOTDOT     = 4;
+const sal_uInt8 EXC_OBJ_LINE_MEDTRANS       = 5;
+const sal_uInt8 EXC_OBJ_LINE_DARKTRANS      = 6;
+const sal_uInt8 EXC_OBJ_LINE_LIGHTTRANS     = 7;
+const sal_uInt8 EXC_OBJ_LINE_NONE           = 255;
+
+const sal_uInt8 EXC_OBJ_LINE_HAIR           = 0;
+const sal_uInt8 EXC_OBJ_LINE_THIN           = 1;
+const sal_uInt8 EXC_OBJ_LINE_MEDIUM         = 2;
+const sal_uInt8 EXC_OBJ_LINE_THICK          = 3;
+
+const sal_uInt8 EXC_OBJ_LINE_AUTO           = 0x01;
+
+const sal_uInt8 EXC_OBJ_ARROW_NONE          = 0;
+const sal_uInt8 EXC_OBJ_ARROW_OPEN          = 1;
+const sal_uInt8 EXC_OBJ_ARROW_FILLED        = 2;
+const sal_uInt8 EXC_OBJ_ARROW_OPENBOTH      = 3;
+const sal_uInt8 EXC_OBJ_ARROW_FILLEDBOTH    = 4;
+
+const sal_uInt8 EXC_OBJ_ARROW_NARROW        = 0;
+const sal_uInt8 EXC_OBJ_ARROW_MEDIUM        = 1;
+const sal_uInt8 EXC_OBJ_ARROW_WIDE          = 2;
+
+const sal_uInt8 EXC_OBJ_LINE_TL             = 0;
+const sal_uInt8 EXC_OBJ_LINE_TR             = 1;
+const sal_uInt8 EXC_OBJ_LINE_BR             = 2;
+const sal_uInt8 EXC_OBJ_LINE_BL             = 3;
+
+// BIFF5 fill formatting
+const sal_uInt8 EXC_OBJ_FILL_AUTOCOLOR      = 65;
+
+const sal_uInt8 EXC_OBJ_FILL_AUTO           = 0x01;
+
+// BIFF5 frame formatting
+const sal_uInt16 EXC_OBJ_FRAME_SHADOW       = 0x0002;
+
+// BIFF5 text objects
+const sal_uInt8 EXC_OBJ_HOR_LEFT            = 1;
+const sal_uInt8 EXC_OBJ_HOR_CENTER          = 2;
+const sal_uInt8 EXC_OBJ_HOR_RIGHT           = 3;
+const sal_uInt8 EXC_OBJ_HOR_JUSTIFY         = 4;
+
+const sal_uInt8 EXC_OBJ_VER_TOP             = 1;
+const sal_uInt8 EXC_OBJ_VER_CENTER          = 2;
+const sal_uInt8 EXC_OBJ_VER_BOTTOM          = 3;
+const sal_uInt8 EXC_OBJ_VER_JUSTIFY         = 4;
+
+const sal_uInt16 EXC_OBJ_ORIENT_NONE        = 0;
+const sal_uInt16 EXC_OBJ_ORIENT_STACKED     = 1;        /// Stacked top to bottom.
+const sal_uInt16 EXC_OBJ_ORIENT_90CCW       = 2;        /// 90 degr. counterclockwise.
+const sal_uInt16 EXC_OBJ_ORIENT_90CW        = 3;        /// 90 degr. clockwise.
+
+const sal_uInt16 EXC_OBJ_TEXT_AUTOSIZE      = 0x0080;
+const sal_uInt16 EXC_OBJ_TEXT_LOCKED        = 0x0200;
+
+const sal_Int32 EXC_OBJ_TEXT_MARGIN         = 20000;    /// Automatic text margin (EMUs).
+
+// BIFF5 arc objects
+const sal_uInt8 EXC_OBJ_ARC_TR              = 0;
+const sal_uInt8 EXC_OBJ_ARC_TL              = 1;
+const sal_uInt8 EXC_OBJ_ARC_BL              = 2;
+const sal_uInt8 EXC_OBJ_ARC_BR              = 3;
+
+// BIFF5 polygon objects
+const sal_uInt16 EXC_OBJ_POLY_CLOSED        = 0x0100;
+
+// BIFF5 pictures/OLE objects
+const sal_uInt16 EXC_OBJ_PIC_MANUALSIZE     = 0x0001;
+const sal_uInt16 EXC_OBJ_PIC_DDE            = 0x0002;
+const sal_uInt16 EXC_OBJ_PIC_SYMBOL         = 0x0008;
+const sal_uInt16 EXC_OBJ_PIC_CONTROL        = 0x0010;   /// Form control (BIFF8).
+const sal_uInt16 EXC_OBJ_PIC_CTLSSTREAM     = 0x0020;   /// Data in Ctls stream (BIFF8).
+const sal_uInt16 EXC_OBJ_PIC_AUTOLOAD       = 0x0200;   /// Auto-load form control (BIFF8).
+
+// BIFF5 button objects
+const sal_uInt16 EXC_OBJ_BUTTON_DEFAULT     = 0x0001;
+const sal_uInt16 EXC_OBJ_BUTTON_HELP        = 0x0002;
+const sal_uInt16 EXC_OBJ_BUTTON_CANCEL      = 0x0004;
+const sal_uInt16 EXC_OBJ_BUTTON_CLOSE       = 0x0008;
+
+// BIFF5 checkboxs, radio buttons
+const sal_uInt16 EXC_OBJ_CHECKBOX_UNCHECKED = 0;
+const sal_uInt16 EXC_OBJ_CHECKBOX_CHECKED   = 1;
+const sal_uInt16 EXC_OBJ_CHECKBOX_TRISTATE  = 2;
+const sal_uInt16 EXC_OBJ_CHECKBOX_FLAT      = 0x0001;
+
+// BIFF5 editbox objects
+const sal_uInt16 EXC_OBJ_EDIT_TEXT          = 0;
+const sal_uInt16 EXC_OBJ_EDIT_INTEGER       = 1;
+const sal_uInt16 EXC_OBJ_EDIT_DOUBLE        = 2;
+const sal_uInt16 EXC_OBJ_EDIT_REFERENCE     = 3;
+const sal_uInt16 EXC_OBJ_EDIT_FORMULA       = 4;
+
+// BIFF5 scrollbars/spinbuttons
+const sal_uInt16 EXC_OBJ_SCROLLBAR_MIN      = 0;
+const sal_uInt16 EXC_OBJ_SCROLLBAR_MAX      = 30000;
+
+const sal_uInt16 EXC_OBJ_SCROLLBAR_HOR      = 0x0001;
+
+const sal_uInt16 EXC_OBJ_SCROLLBAR_DEFFLAGS = 0x0001;
+const sal_uInt16 EXC_OBJ_SCROLLBAR_FLAT     = 0x0008;
+
+// BIFF5 listboxes/dropdowns
+const sal_uInt8 EXC_OBJ_LISTBOX_SINGLE      = 0;        /// Single selection.
+const sal_uInt8 EXC_OBJ_LISTBOX_MULTI       = 1;        /// Multi selection.
+const sal_uInt8 EXC_OBJ_LISTBOX_RANGE       = 2;        /// Range selection.
+
+const sal_uInt16 EXC_OBJ_LISTBOX_EDIT       = 0x0002;
+const sal_uInt16 EXC_OBJ_LISTBOX_FLAT       = 0x0008;
+
+// BIFF5 dropdown listboxes
+const sal_uInt16 EXC_OBJ_DROPDOWN_LISTBOX   = 0;        /// Listbox, text not editable.
+const sal_uInt16 EXC_OBJ_DROPDOWN_COMBOBOX  = 1;        /// Dropdown listbox with editable text.
+const sal_uInt16 EXC_OBJ_DROPDOWN_SIMPLE    = 2;        /// Dropdown button only, no text area.
+const sal_uInt16 EXC_OBJ_DROPDOWN_MAX       = 3;
+const sal_uInt16 EXC_OBJ_DROPDOWN_FILTERED  = 0x0008;   /// Drowdown style: filtered.
+
+// BIFF5 groupboxes
+const sal_uInt16 EXC_OBJ_GROUPBOX_FLAT      = 0x0001;
+
+// BIFF8 sub records
+const sal_uInt16 EXC_ID_OBJEND              = 0x0000;   /// End of OBJ.
+const sal_uInt16 EXC_ID_OBJMACRO            = 0x0004;   /// Macro link.
+const sal_uInt16 EXC_ID_OBJBUTTON           = 0x0005;   /// Button data.
+const sal_uInt16 EXC_ID_OBJGMO              = 0x0006;   /// Group marker.
+const sal_uInt16 EXC_ID_OBJCF               = 0x0007;   /// Clipboard format.
+const sal_uInt16 EXC_ID_OBJFLAGS            = 0x0008;   /// Option flags.
+const sal_uInt16 EXC_ID_OBJPICTFMLA         = 0x0009;   /// OLE link formula.
+const sal_uInt16 EXC_ID_OBJCBLS             = 0x000A;   /// Check box/radio button data.
+const sal_uInt16 EXC_ID_OBJRBO              = 0x000B;   /// Radio button group data.
+const sal_uInt16 EXC_ID_OBJSBS              = 0x000C;   /// Scroll bar data.
+const sal_uInt16 EXC_ID_OBJNTS              = 0x000D;   /// Note data.
+const sal_uInt16 EXC_ID_OBJSBSFMLA          = 0x000E;   /// Scroll bar/list box/combo box cell link.
+const sal_uInt16 EXC_ID_OBJGBODATA          = 0x000F;   /// Group box data.
+const sal_uInt16 EXC_ID_OBJEDODATA          = 0x0010;   /// Edit box data.
+const sal_uInt16 EXC_ID_OBJRBODATA          = 0x0011;   /// Radio button group data.
+const sal_uInt16 EXC_ID_OBJCBLSDATA         = 0x0012;   /// Check box/radio button data.
+const sal_uInt16 EXC_ID_OBJLBSDATA          = 0x0013;   /// List box/combo box data.
+const sal_uInt16 EXC_ID_OBJCBLSFMLA         = 0x0014;   /// Check box/radio button cell link.
+const sal_uInt16 EXC_ID_OBJCMO              = 0x0015;   /// Common object settings.
+const sal_uInt16 EXC_ID_OBJUNKNOWN          = 0xFFFF;   /// For internal use only.
+
+// BIFF8 OBJCMO: flags
+const sal_uInt16 EXC_OBJCMO_PRINTABLE       = 0x0010;   /// Object printable.
+const sal_uInt16 EXC_OBJCMO_AUTOLINE        = 0x2000;   /// Automatic line formatting.
+const sal_uInt16 EXC_OBJCMO_AUTOFILL        = 0x4000;   /// Automatic fill formatting.
+
+/** Value binding mode for cells linked to form controls. */
+enum XclCtrlBindMode
+{
+    EXC_CTRL_BINDCONTENT,       /// Binds cell to content of control.
+    EXC_CTRL_BINDPOSITION       /// Binds cell to position in control (e.g. listbox selection index).
+};
+
+// (0x007F) IMGDATA -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID3_IMGDATA            = 0x007F;
+const sal_uInt16 EXC_ID8_IMGDATA            = 0x00E9;
+
+const sal_uInt16 EXC_IMGDATA_WMF            = 2;
+const sal_uInt16 EXC_IMGDATA_BMP            = 9;
+
+const sal_uInt16 EXC_IMGDATA_WIN            = 1;
+const sal_uInt16 EXC_IMGDATA_MAC            = 2;
+
+const sal_uInt32 EXC_IMGDATA_MAXREC8        = 0x201C;
+const sal_uInt32 EXC_IMGDATA_MAXCONT8       = 0x2014;
+
+// (0x00A9) COORDLIST ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_COORDLIST           = 0x00A9;
+
+// (0x00EB) MSODRAWINGGROUP ---------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGGROUP     = 0x00EB;
+
+// (0x00EC) MSODRAWING --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWING          = 0x00EC;
+
+// additional flags not extant in svx headers
+const sal_uInt16 EXC_ESC_ANCHOR_POSLOCKED   = 0x0001;
+const sal_uInt16 EXC_ESC_ANCHOR_SIZELOCKED  = 0x0002;
+const sal_uInt16 EXC_ESC_ANCHOR_LOCKED      = EXC_ESC_ANCHOR_POSLOCKED|EXC_ESC_ANCHOR_SIZELOCKED;
+
+// (0x00ED) MSODRAWINGSELECTION -----------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGSEL       = 0x00ED;
+
+// (0x01B6) TXO ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_TXO                 = 0x01B6;
+
+// TXO constants are eqzal to BIFF5 OBJ text object flags
+
+// Structs and classes ========================================================
+
+/** Identifies a drawing object by sheet index and object identifier. */
+struct XclObjId
+{
+    SCTAB               mnScTab;        /// Calc sheet index.
+    sal_uInt16          mnObjId;        /// Excel object identifier.
+
+    explicit            XclObjId();
+    explicit            XclObjId( SCTAB nScTab, sal_uInt16 nObjId );
+};
+
+bool operator==( const XclObjId& rL, const XclObjId& rR );
+bool operator<( const XclObjId& rL, const XclObjId& rR );
+
+// ----------------------------------------------------------------------------
+
+/** Represents the position (anchor) of an object in a Calc document. */
+struct XclObjAnchor : public XclRange
+{
+    SCTAB               mnScTab;    /// Calc sheet index.
+    sal_uInt16          mnLX;       /// X offset in left column (1/1024 of column width).
+    sal_uInt16          mnTY;       /// Y offset in top row (1/256 of row height).
+    sal_uInt16          mnRX;       /// X offset in right column (1/1024 of column width).
+    sal_uInt16          mnBY;       /// Y offset in bottom row (1/256 of row height).
+
+    explicit            XclObjAnchor( SCTAB nScTab );
+
+    /** Calculates a rectangle from the contained coordinates. */
+    Rectangle           GetRect( ScDocument& rDoc, MapUnit eMapUnit ) const;
+    /** Initializes the anchor coordinates from a rectangle. */
+    void                SetRect( ScDocument& rDoc, const Rectangle& rRect, MapUnit eMapUnit );
+};
+
+template< typename StreamType >
+StreamType& operator>>( StreamType& rStrm, XclObjAnchor& rAnchor )
+{
+    return rStrm
+        >> rAnchor.maFirst.mnCol >> rAnchor.mnLX
+        >> rAnchor.maFirst.mnRow >> rAnchor.mnTY
+        >> rAnchor.maLast.mnCol  >> rAnchor.mnRX
+        >> rAnchor.maLast.mnRow  >> rAnchor.mnBY;
+}
+
+template< typename StreamType >
+StreamType& operator<<( StreamType& rStrm, const XclObjAnchor& rAnchor )
+{
+    return rStrm
+        << rAnchor.maFirst.mnCol << rAnchor.mnLX
+        << rAnchor.maFirst.mnRow << rAnchor.mnTY
+        << rAnchor.maLast.mnCol  << rAnchor.mnRX
+        << rAnchor.maLast.mnRow  << rAnchor.mnBY;
+}
+
+// ----------------------------------------------------------------------------
+
+struct XclObjLineData
+{
+    sal_uInt8           mnColorIdx;
+    sal_uInt8           mnStyle;
+    sal_uInt8           mnWidth;
+    sal_uInt8           mnAuto;
+
+    explicit            XclObjLineData();
+
+    inline bool         IsAuto() const { return ::get_flag( mnAuto, EXC_OBJ_LINE_AUTO ); }
+    inline bool         IsVisible() const { return IsAuto() || (mnStyle != EXC_OBJ_LINE_NONE); }
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclObjLineData& rLineData );
+
+// ----------------------------------------------------------------------------
+
+struct XclObjFillData
+{
+    sal_uInt8           mnBackColorIdx;
+    sal_uInt8           mnPattColorIdx;
+    sal_uInt8           mnPattern;
+    sal_uInt8           mnAuto;
+
+    explicit            XclObjFillData();
+
+    inline bool         IsAuto() const { return ::get_flag( mnAuto, EXC_OBJ_FILL_AUTO ); }
+    inline bool         IsFilled() const { return IsAuto() || (mnPattern != EXC_PATT_NONE); }
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclObjFillData& rFillData );
+
+// ----------------------------------------------------------------------------
+
+struct XclObjTextData
+{
+    sal_uInt16          mnTextLen;
+    sal_uInt16          mnFormatSize;
+    sal_uInt16          mnLinkSize;
+    sal_uInt16          mnDefFontIdx;
+    sal_uInt16          mnFlags;
+    sal_uInt16          mnOrient;
+    sal_uInt16          mnButtonFlags;
+    sal_uInt16          mnShortcut;
+    sal_uInt16          mnShortcutEA;
+
+    explicit            XclObjTextData();
+
+    /** Reads text data from a BIFF3/BIFF4 OBJ record. */
+    void                ReadObj3( XclImpStream& rStrm );
+    /** Reads text data from a BIFF5 OBJ record. */
+    void                ReadObj5( XclImpStream& rStrm );
+    /** Reads text data from a BIFF8 TXO record. */
+    void                ReadTxo8( XclImpStream& rStrm );
+
+    inline sal_uInt8    GetHorAlign() const { return ::extract_value< sal_uInt8 >( mnFlags, 1, 3 ); }
+    inline sal_uInt8    GetVerAlign() const { return ::extract_value< sal_uInt8 >( mnFlags, 4, 3 ); }
+};
+
+// ============================================================================
+
+enum XclTbxEventType
+{
+    EXC_TBX_EVENT_ACTION,       /// XActionListener.actionPerformed
+    EXC_TBX_EVENT_MOUSE,        /// XMouseListener.mouseReleased
+    EXC_TBX_EVENT_TEXT,         /// XTextListener.textChanged
+    EXC_TBX_EVENT_VALUE,        /// XAdjustmentListener.adjustmentValueChanged
+    EXC_TBX_EVENT_CHANGE        /// XChangeListener.changed
+};
+
+// ----------------------------------------------------------------------------
+
+/** Provides static helper functions for form controls. */
+class XclControlHelper
+{
+public:
+    /** Returns the API control model from the passed API shape object. */
+    static ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >
+                        GetControlModel( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+
+    /** Returns the Calc macro name from an Excel macro name. */
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+
+    /** Returns the Excel macro name from a Calc macro name. */
+    static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
+
+    /** Fills the macro descriptor according to the passed macro name. */
+    static bool         FillMacroDescriptor(
+                            ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
+                            XclTbxEventType eEventType,
+                            const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+    /** Tries to extract an Excel macro name from the passed macro descriptor. */
+    static String       ExtractFromMacroDescriptor(
+                            const ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
+                            XclTbxEventType eEventType );
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xlpivot.hxx sc/source/filter/xlsx/xlpivot.hxx
new file mode 100644
index 0000000..8b5bd4e
--- /dev/null
+++ sc/source/filter/xlsx/xlpivot.hxx
@@ -0,0 +1,820 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlpivot.hxx,v $
+ * $Revision: 1.12.32.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLPIVOT_HXX
+#define SC_XLPIVOT_HXX
+
+#include <com/sun/star/sheet/GeneralFunction.hpp>
+#include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
+#include <com/sun/star/sheet/DataPilotFieldSortMode.hpp>
+#include <com/sun/star/sheet/DataPilotFieldShowItemsMode.hpp>
+#include <com/sun/star/sheet/DataPilotFieldLayoutMode.hpp>
+#include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
+#include <com/sun/star/sheet/DataPilotFieldReferenceItemType.hpp>
+#include <tools/datetime.hxx>
+#include "ftools.hxx"
+#include "xladdress.hxx"
+#include "dpobject.hxx"
+
+#include <memory>
+
+class XclImpStream;
+class XclExpStream;
+
+// Constants and Enumerations =================================================
+
+// misc -----------------------------------------------------------------------
+
+#define EXC_STORAGE_PTCACHE         CREATE_STRING( "_SX_DB_CUR" )
+
+// strings
+const sal_uInt16 EXC_PT_NOSTRING            = 0xFFFF;
+const sal_uInt16 EXC_PT_MAXSTRLEN           = 0xFFFE;
+
+// pivot cache fields
+const size_t EXC_PC_MAXFIELDCOUNT           = 0xFFFE;
+const sal_uInt16 EXC_PC_NOFIELD             = 0xFFFF;
+const xub_StrLen EXC_PC_MAXSTRLEN           = 255;
+
+// pivot cache items
+const size_t EXC_PC_MAXITEMCOUNT            = 32500;
+const sal_uInt16 EXC_PC_NOITEM              = 0xFFFF;
+
+// pivot table fields
+const sal_uInt16 EXC_PT_MAXFIELDCOUNT       = 0xFFFE;
+const sal_uInt16 EXC_PT_MAXROWCOLCOUNT      = EXC_PT_MAXFIELDCOUNT;
+const sal_uInt16 EXC_PT_MAXPAGECOUNT        = 256;
+const sal_uInt16 EXC_PT_MAXDATACOUNT        = 256;
+
+// pivot table items
+const sal_uInt16 EXC_PT_MAXITEMCOUNT        = 32500;
+
+const sal_uInt16 EXC_PT_AUTOFMT_HEADER      = 0x810;
+const sal_uInt16 EXC_PT_AUTOFMT_ZERO        = 0;
+const sal_uInt32 EXC_PT_AUTOFMT_FLAGS       = 0x20;
+
+/** Data type of a pivot cache item. */
+enum XclPCItemType
+{
+    EXC_PCITEM_INVALID,         /// Special state, not used in Excel files.
+    EXC_PCITEM_EMPTY,           /// Empty cell.
+    EXC_PCITEM_TEXT,            /// String data.
+    EXC_PCITEM_DOUBLE,          /// Floating-point value.
+    EXC_PCITEM_DATETIME,        /// Date/time.
+    EXC_PCITEM_INTEGER,         /// 16-bit integer value.
+    EXC_PCITEM_BOOL,            /// Boolean value.
+    EXC_PCITEM_ERROR            /// Error code.
+};
+
+/** Specifies the type of a pivot cache field. */
+enum XclPCFieldType
+{
+    EXC_PCFIELD_STANDARD,       /// Standard field without grouping.
+    EXC_PCFIELD_STDGROUP,       /// Standard grouping field.
+    EXC_PCFIELD_NUMGROUP,       /// Numeric grouping field.
+    EXC_PCFIELD_DATEGROUP,      /// First date grouping field (opt. with child grouping field).
+    EXC_PCFIELD_DATECHILD,      /// Additional date grouping field.
+    EXC_PCFIELD_CALCED,         /// Calculated field.
+    EXC_PCFIELD_UNKNOWN         /// Unknown field state, handled like standard field.
+};
+
+// (0x0051,0x0052) DCONREF, DCONNAME ------------------------------------------
+
+const sal_uInt16 EXC_ID_DCONREF             = 0x0051;
+const sal_uInt16 EXC_ID_DCONNAME            = 0x0052;
+
+// (0x00B0) SXVIEW ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVIEW              = 0x00B0;
+
+const sal_uInt16 EXC_SXVIEW_ROWGRAND        = 0x0001;
+const sal_uInt16 EXC_SXVIEW_COLGRAND        = 0x0002;
+const sal_uInt16 EXC_SXVIEW_DEFAULTFLAGS    = 0x0208;
+
+const sal_uInt16 EXC_SXVIEW_DATALAST        = 0xFFFF;
+const sal_uInt16 EXC_SXVIEW_AUTOFMT         = 0x0001;
+
+// (0x00B1) SXVD --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVD                = 0x00B1;
+
+const sal_uInt16 EXC_SXVD_AXIS_NONE         = 0x0000;
+const sal_uInt16 EXC_SXVD_AXIS_ROW          = 0x0001;
+const sal_uInt16 EXC_SXVD_AXIS_COL          = 0x0002;
+const sal_uInt16 EXC_SXVD_AXIS_PAGE         = 0x0004;
+const sal_uInt16 EXC_SXVD_AXIS_DATA         = 0x0008;
+const sal_uInt16 EXC_SXVD_AXIS_ROWCOL       = EXC_SXVD_AXIS_ROW | EXC_SXVD_AXIS_COL;
+const sal_uInt16 EXC_SXVD_AXIS_ROWCOLPAGE   = EXC_SXVD_AXIS_ROWCOL | EXC_SXVD_AXIS_PAGE;
+
+const sal_uInt16 EXC_SXVD_SUBT_NONE         = 0x0000;
+const sal_uInt16 EXC_SXVD_SUBT_DEFAULT      = 0x0001;
+const sal_uInt16 EXC_SXVD_SUBT_SUM          = 0x0002;
+const sal_uInt16 EXC_SXVD_SUBT_COUNT        = 0x0004;
+const sal_uInt16 EXC_SXVD_SUBT_AVERAGE      = 0x0008;
+const sal_uInt16 EXC_SXVD_SUBT_MAX          = 0x0010;
+const sal_uInt16 EXC_SXVD_SUBT_MIN          = 0x0020;
+const sal_uInt16 EXC_SXVD_SUBT_PROD         = 0x0040;
+const sal_uInt16 EXC_SXVD_SUBT_COUNTNUM     = 0x0080;
+const sal_uInt16 EXC_SXVD_SUBT_STDDEV       = 0x0100;
+const sal_uInt16 EXC_SXVD_SUBT_STDDEVP      = 0x0200;
+const sal_uInt16 EXC_SXVD_SUBT_VAR          = 0x0400;
+const sal_uInt16 EXC_SXVD_SUBT_VARP         = 0x0800;
+
+const sal_uInt16 EXC_SXVD_DEFAULT_CACHE     = EXC_PC_NOFIELD;
+
+// (0x00B2) SXVI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVI                = 0x00B2;
+
+const sal_uInt16 EXC_SXVI_TYPE_PAGE         = 0x00FE;
+const sal_uInt16 EXC_SXVI_TYPE_NULL         = 0x00FF;
+const sal_uInt16 EXC_SXVI_TYPE_DATA         = 0x0000;
+const sal_uInt16 EXC_SXVI_TYPE_DEFAULT      = 0x0001;
+const sal_uInt16 EXC_SXVI_TYPE_SUM          = 0x0002;
+const sal_uInt16 EXC_SXVI_TYPE_COUNT        = 0x0003;
+const sal_uInt16 EXC_SXVI_TYPE_AVERAGE      = 0x0004;
+const sal_uInt16 EXC_SXVI_TYPE_MAX          = 0x0005;
+const sal_uInt16 EXC_SXVI_TYPE_MIN          = 0x0006;
+const sal_uInt16 EXC_SXVI_TYPE_PROD         = 0x0007;
+const sal_uInt16 EXC_SXVI_TYPE_COUNTNUM     = 0x0008;
+const sal_uInt16 EXC_SXVI_TYPE_STDDEV       = 0x0009;
+const sal_uInt16 EXC_SXVI_TYPE_STDDEVP      = 0x000A;
+const sal_uInt16 EXC_SXVI_TYPE_VAR          = 0x000B;
+const sal_uInt16 EXC_SXVI_TYPE_VARP         = 0x000C;
+const sal_uInt16 EXC_SXVI_TYPE_GRAND        = 0x000D;
+
+const sal_uInt16 EXC_SXVI_DEFAULTFLAGS      = 0x0000;
+const sal_uInt16 EXC_SXVI_HIDDEN            = 0x0001;
+const sal_uInt16 EXC_SXVI_HIDEDETAIL        = 0x0002;
+const sal_uInt16 EXC_SXVI_FORMULA           = 0x0004;
+const sal_uInt16 EXC_SXVI_MISSING           = 0x0008;
+
+const sal_uInt16 EXC_SXVI_DEFAULT_CACHE     = EXC_PC_NOFIELD;
+
+// (0x00B4) SXIVD -------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXIVD               = 0x00B4;
+const sal_uInt16 EXC_SXIVD_DATA             = 0xFFFE;
+
+// (0x00B5) SXLI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXLI                = 0x00B5;
+const sal_uInt16 EXC_SXLI_DEFAULTFLAGS      = 0x0000;
+
+// (0x00B6) SXPI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXPI                = 0x00B6;
+const sal_uInt16 EXC_SXPI_ALLITEMS          = 0x7FFD;
+
+// (0x00C5) SXDI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDI                = 0x00C5;
+
+const sal_uInt16 EXC_SXDI_FUNC_SUM          = 0x0000;
+const sal_uInt16 EXC_SXDI_FUNC_COUNT        = 0x0001;
+const sal_uInt16 EXC_SXDI_FUNC_AVERAGE      = 0x0002;
+const sal_uInt16 EXC_SXDI_FUNC_MAX          = 0x0003;
+const sal_uInt16 EXC_SXDI_FUNC_MIN          = 0x0004;
+const sal_uInt16 EXC_SXDI_FUNC_PRODUCT      = 0x0005;
+const sal_uInt16 EXC_SXDI_FUNC_COUNTNUM     = 0x0006;
+const sal_uInt16 EXC_SXDI_FUNC_STDDEV       = 0x0007;
+const sal_uInt16 EXC_SXDI_FUNC_STDDEVP      = 0x0008;
+const sal_uInt16 EXC_SXDI_FUNC_VAR          = 0x0009;
+const sal_uInt16 EXC_SXDI_FUNC_VARP         = 0x000A;
+
+const sal_uInt16 EXC_SXDI_REF_NORMAL        = 0x0000;
+const sal_uInt16 EXC_SXDI_REF_DIFF          = 0x0001;
+const sal_uInt16 EXC_SXDI_REF_PERC          = 0x0002;
+const sal_uInt16 EXC_SXDI_REF_PERC_DIFF     = 0x0003;
+const sal_uInt16 EXC_SXDI_REF_RUN_TOTAL     = 0x0004;
+const sal_uInt16 EXC_SXDI_REF_PERC_ROW      = 0x0005;
+const sal_uInt16 EXC_SXDI_REF_PERC_COL      = 0x0006;
+const sal_uInt16 EXC_SXDI_REF_PERC_TOTAL    = 0x0007;
+const sal_uInt16 EXC_SXDI_REF_INDEX         = 0x0008;
+
+const sal_uInt16 EXC_SXDI_PREVITEM          = 0x7FFB;
+const sal_uInt16 EXC_SXDI_NEXTITEM          = 0x7FFC;
+
+// (0x00C6) SXDB --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDB                = 0x00C6;
+
+const sal_uInt16 EXC_SXDB_SAVEDATA          = 0x0001;
+const sal_uInt16 EXC_SXDB_INVALID           = 0x0002;
+const sal_uInt16 EXC_SXDB_REFRESH_LOAD      = 0x0004;
+const sal_uInt16 EXC_SXDB_OPT_CACHE         = 0x0008;
+const sal_uInt16 EXC_SXDB_BG_QUERY          = 0x0010;
+const sal_uInt16 EXC_SXDB_ENABLE_REFRESH    = 0x0020;
+const sal_uInt16 EXC_SXDB_DEFAULTFLAGS      = EXC_SXDB_SAVEDATA | EXC_SXDB_ENABLE_REFRESH;
+
+const sal_uInt16 EXC_SXDB_BLOCKRECS         = 0x1FFF;
+
+const sal_uInt16 EXC_SXDB_SRC_SHEET         = 0x0001;
+const sal_uInt16 EXC_SXDB_SRC_EXTERN        = 0x0002;
+const sal_uInt16 EXC_SXDB_SRC_CONSOLID      = 0x0004;
+const sal_uInt16 EXC_SXDB_SRC_SCENARIO      = 0x0008;
+
+// (0x00C7) SXFIELD -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFIELD             = 0x00C7;
+
+const sal_uInt16 EXC_SXFIELD_HASITEMS       = 0x0001;
+const sal_uInt16 EXC_SXFIELD_POSTPONE       = 0x0002;
+const sal_uInt16 EXC_SXFIELD_CALCED         = 0x0004;
+const sal_uInt16 EXC_SXFIELD_HASCHILD       = 0x0008;
+const sal_uInt16 EXC_SXFIELD_NUMGROUP       = 0x0010;
+const sal_uInt16 EXC_SXFIELD_16BIT          = 0x0200;
+
+const sal_uInt16 EXC_SXFIELD_DATA_MASK      = 0x0DE0;
+// known data types
+const sal_uInt16 EXC_SXFIELD_DATA_NONE      = 0x0000;   /// Special state for groupings.
+const sal_uInt16 EXC_SXFIELD_DATA_STR       = 0x0480;   /// Only strings, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_INT       = 0x0520;   /// Only integers, opt. with doubles.
+const sal_uInt16 EXC_SXFIELD_DATA_DBL       = 0x0560;   /// Only doubles, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_STR_INT   = 0x05A0;   /// Only strings and integers, opt. with doubles.
+const sal_uInt16 EXC_SXFIELD_DATA_STR_DBL   = 0x05E0;   /// Only strings and doubles, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_DATE      = 0x0900;   /// Only dates, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_DATE_EMP  = 0x0980;   /// Dates and empty strings, nothing else (?).
+const sal_uInt16 EXC_SXFIELD_DATA_DATE_NUM  = 0x0D00;   /// Dates with integers or doubles without strings.
+const sal_uInt16 EXC_SXFIELD_DATA_DATE_STR  = 0x0D80;   /// Dates and strings, opt. with integers or doubles.
+
+const sal_uInt16 EXC_SXFIELD_INDEX_MIN      = 0;        /// List index for minimum item in groupings.
+const sal_uInt16 EXC_SXFIELD_INDEX_MAX      = 1;        /// List index for maximum item in groupings.
+const sal_uInt16 EXC_SXFIELD_INDEX_STEP     = 2;        /// List index for step item in groupings.
+
+// (0x00C8) SXINDEXLIST -------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXINDEXLIST         = 0x00C8;
+
+// (0x00C9) SXDOUBLE ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDOUBLE            = 0x00C9;
+
+// (0x00CA) SXBOOLEAN ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXBOOLEAN           = 0x00CA;
+
+// (0x00CB) SXERROR -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXERROR             = 0x00CB;
+
+// (0x00CC) SXINTEGER ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXINTEGER           = 0x00CC;
+
+// (0x00CD) SXSTRING ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXSTRING            = 0x00CD;
+
+// (0x00CE) SXDATETIME --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDATETIME          = 0x00CE;
+
+// (0x00CF) SXEMPTY -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXEMPTY             = 0x00CF;
+
+// (0x00D5) SXIDSTM -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXIDSTM             = 0x00D5;
+
+// (0x00D8) SXNUMGROUP --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXNUMGROUP          = 0x00D8;
+
+const sal_uInt16 EXC_SXNUMGROUP_AUTOMIN     = 0x0001;
+const sal_uInt16 EXC_SXNUMGROUP_AUTOMAX     = 0x0002;
+
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_SEC    = 1;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_MIN    = 2;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_HOUR   = 3;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_DAY    = 4;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_MONTH  = 5;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_QUART  = 6;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_YEAR   = 7;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_NUM    = 8;
+
+// (0x00D9) SXGROUPINFO -------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXGROUPINFO         = 0x00D9;
+
+// (0x00DC) SXEXT -------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXEXT               = 0x00DC;
+
+// (0x00E3) SXVS --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVS                = 0x00E3;
+
+const sal_uInt16 EXC_SXVS_UNKNOWN           = 0x0000;
+const sal_uInt16 EXC_SXVS_SHEET             = 0x0001;
+const sal_uInt16 EXC_SXVS_EXTERN            = 0x0002;
+const sal_uInt16 EXC_SXVS_CONSOLID          = 0x0004;
+const sal_uInt16 EXC_SXVS_PIVOTTAB          = 0x0008;
+const sal_uInt16 EXC_SXVS_SCENARIO          = 0x0010;
+
+// (0x00F0) SXRULE ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXRULE              = 0x00F0;
+
+// (0x00F1) SXEX --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXEX                = 0x00F1;
+
+const sal_uInt32 EXC_SXEX_DRILLDOWN         = 0x00020000;
+const sal_uInt32 EXC_SXEX_DEFAULTFLAGS      = 0x004F0200;
+
+// (0x00F2) SXFILT ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFILT              = 0x00F2;
+
+// (0x00F5) -------------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_00F5                = 0x00F5;   /// Unknown record
+
+// (0x00F6) SXNAME ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXNAME              = 0x00F6;
+
+// (0x00F8) SXPAIR ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXPAIR              = 0x00F8;
+
+// (0x00F9) SXFMLA ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFMLA              = 0x00F9;
+
+// (0x0100) SXVDEX ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVDEX              = 0x0100;
+
+const sal_uInt32 EXC_SXVDEX_SHOWALL         = 0x00000001;
+const sal_uInt32 EXC_SXVDEX_SORT            = 0x00000200;
+const sal_uInt32 EXC_SXVDEX_SORT_ASC        = 0x00000400;
+const sal_uInt32 EXC_SXVDEX_AUTOSHOW        = 0x00000800;
+const sal_uInt32 EXC_SXVDEX_AUTOSHOW_ASC    = 0x00001000;
+const sal_uInt32 EXC_SXVDEX_LAYOUT_REPORT   = 0x00200000;
+const sal_uInt32 EXC_SXVDEX_LAYOUT_BLANK    = 0x00400000;
+const sal_uInt32 EXC_SXVDEX_LAYOUT_TOP      = 0x00800000;
+const sal_uInt32 EXC_SXVDEX_DEFAULTFLAGS    = 0x0A00001E | EXC_SXVDEX_SORT_ASC | EXC_SXVDEX_AUTOSHOW_ASC;
+
+const sal_uInt16 EXC_SXVDEX_SORT_OWN        = 0xFFFF;
+const sal_uInt16 EXC_SXVDEX_SHOW_NONE       = 0xFFFF;
+const sal_uInt16 EXC_SXVDEX_FORMAT_NONE     = 0x0000;
+
+// (0x0103) SXFORMULA ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFORMULA           = 0x0103;
+
+// (0x0122) SXDBEX ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDBEX              = 0x0122;
+const double EXC_SXDBEX_CREATION_DATE       = 51901.029652778;
+
+// (0x01BB) SXFDBTYPE ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFDBTYPE           = 0x01BB;
+const sal_uInt16 EXC_SXFDBTYPE_DEFAULT      = 0x0000;
+
+// (0x0810) SXVIEWEX9 ---------------------------------------------------------
+const sal_uInt16 EXC_ID_SXVIEWEX9       = 0x0810;
+
+// ============================================================================
+// Pivot cache
+// ============================================================================
+
+/** Represents a data item of any type in a pivot cache. Supposed as base class for import and export. */
+class XclPCItem
+{
+public:
+    explicit            XclPCItem();
+    virtual             ~XclPCItem();
+
+    /** Sets the item to 'empty' type. */
+    void                SetEmpty();
+    /** Sets the item to 'text' type and adds the passed text. */
+    void                SetText( const String& rText );
+    /** Sets the item to 'double' type and adds the passed value. */
+    void                SetDouble( double fValue );
+    /** Sets the item to 'date/time' type and adds the passed date. */
+    void                SetDateTime( const DateTime& rDateTime );
+    /** Sets the item to 'integer' type and adds the passed value. */
+    void                SetInteger( sal_Int16 nValue );
+    /** Sets the item to 'error' type and adds the passed Excel error code. */
+    void                SetError( sal_uInt16 nError );
+    /** Sets the item to 'boolean' type and adds the passed Boolean value. */
+    void                SetBool( bool bValue );
+
+    /** Returns the current item type. */
+    inline XclPCItemType GetType() const { return meType; }
+    /** Returns the text representation of the item. */
+    inline const String& ConvertToText() const { return maText; }
+
+    /** Returns true, if the passed iterm equals this item. */
+    bool                IsEqual( const XclPCItem& rItem ) const;
+
+    /** Returns true, if the item type is 'empty'. */
+    bool                IsEmpty() const;
+    /** Returns pointer to text, if the item type is 'text', otherwise 0. */
+    const String*       GetText() const;
+    /** Returns pointer to value, if the item type is 'double', otherwise 0. */
+    const double*       GetDouble() const;
+    /** Returns pointer to date, if the item type is 'date/time', otherwise 0. */
+    const DateTime*     GetDateTime() const;
+    /** Returns pointer to integer, if the item type is 'integer', otherwise 0. */
+    const sal_Int16*    GetInteger() const;
+    /** Returns pointer to error code, if the item type is 'error', otherwise 0. */
+    const sal_uInt16*   GetError() const;
+    /** Returns pointer to Boolean value, if the item type is 'boolean', otherwise 0. */
+    const bool*         GetBool() const;
+
+private:
+    XclPCItemType       meType;         /// Type of the item.
+    String              maText;         /// Text representation of the item.
+    DateTime            maDateTime;     /// Value of a date/time item.
+    union
+    {
+        double              mfValue;        /// Value of a floating-point item.
+        sal_Int16           mnValue;        /// Value of an integer item.
+        sal_uInt16          mnError;        /// Error code of an error item.
+        bool                mbValue;        /// Value of a boolean item.
+    };
+};
+
+inline bool operator==( const XclPCItem& rLeft, const XclPCItem& rRight ) { return rLeft.IsEqual( rRight ); }
+inline bool operator!=( const XclPCItem& rLeft, const XclPCItem& rRight ) { return !(rLeft == rRight); }
+
+// Field settings =============================================================
+
+/** Contains data for a pivot cache field (SXFIELD record). */
+struct XclPCFieldInfo
+{
+    String              maName;         /// Name of the pivot cache field.
+    sal_uInt16          mnFlags;        /// Various flags.
+    sal_uInt16          mnGroupChild;   /// Field containing grouping info for this field.
+    sal_uInt16          mnGroupBase;    /// Base field if this field contains grouping info.
+    sal_uInt16          mnVisItems;     /// Number of visible items for this field.
+    sal_uInt16          mnGroupItems;   /// Number of special items in a grouping field.
+    sal_uInt16          mnBaseItems;    /// Number of items in the base field.
+    sal_uInt16          mnOrigItems;    /// Number of original source data items.
+
+    explicit            XclPCFieldInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPCFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPCFieldInfo& rInfo );
+
+// Numeric grouping field settings ============================================
+
+/** Contains data for a numeric grouping field (SXNUMGROUP record). */
+struct XclPCNumGroupInfo
+{
+    sal_uInt16          mnFlags;        /// Various flags.
+
+    explicit            XclPCNumGroupInfo();
+
+    void                SetNumType();
+
+    sal_Int32           GetScDateType() const;
+    void                SetScDateType( sal_Int32 nScType );
+
+    sal_uInt16          GetXclDataType() const;
+    void                SetXclDataType( sal_uInt16 nXclType );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPCNumGroupInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPCNumGroupInfo& rInfo );
+
+// Base class for pivot cache fields ==========================================
+
+/** Represents a field in a pivot cache. Supposed as base class for import and export. */
+class XclPCField
+{
+public:
+    explicit            XclPCField( XclPCFieldType eFieldType, sal_uInt16 nFieldIdx );
+    virtual             ~XclPCField();
+
+    /** Returns the index of this field in the containing pivot cache. */
+    inline sal_uInt16   GetFieldIndex() const { return mnFieldIdx; }
+
+    /** Returns true, if the type of the field is supported by Calc. */
+    bool                IsSupportedField() const;
+
+    /** Returns true, if this is a standard field build directly from source data. */
+    bool                IsStandardField() const;
+  
+//UNUSED2008-05  /** Returns true, if the items of the field are calculated from a formula. */
+//UNUSED2008-05  bool                IsCalculatedField() const;
+
+    /** Returns true, if this field is a grouping field. */
+    bool                IsStdGroupField() const;
+    /** Returns true, if this field is a numeric grouping field. */
+    bool                IsNumGroupField() const;
+    /** Returns true, if this field is a date/time grouping field. */
+    bool                IsDateGroupField() const;
+    /** Returns true, if this field is a grouping field of any type. */
+    bool                IsGroupField() const;
+
+    /** Returns true, if this field has a child field in a grouping. */
+    bool                IsGroupBaseField() const;
+    /** Returns true, if this field is a child field in a grouping (it has a base field). */
+    bool                IsGroupChildField() const;
+    /** Returns the index of the base field, if exists, otherwise the own index. */
+    sal_uInt16          GetBaseFieldIndex() const;
+
+    /** Returns true, if the field is based on a column in the source data area. */
+    bool                HasOrigItems() const;
+    /** Returns true, if any items are stored after the SXFIELD record. */
+    bool                HasInlineItems() const;
+    /** Returns true, if the items are stored separately after the last field. */
+    bool                HasPostponedItems() const;
+    /** Returns true, if the item indexes in the SXINDEXLIST record are stored as 16-bit values. */
+    bool                Has16BitIndexes() const;
+
+protected:
+    XclPCFieldInfo      maFieldInfo;        /// Pivot cache field info (SXFIELD record).
+    XclPCFieldType      meFieldType;        /// Type of this pivot cache field.
+    sal_uInt16          mnFieldIdx;         /// Own field index in pivot cache.
+    ScfUInt16Vec        maGroupOrder;       /// Order of items in a grouping field (SXGROUPINFO record).
+    XclPCNumGroupInfo   maNumGroupInfo;     /// Info for numeric grouping (SXNUMGROUP record).
+};
+
+// Pivot cache settings =======================================================
+
+/** Contains data for a pivot cache (SXDB record). */
+struct XclPCInfo
+{
+    sal_uInt32          mnSrcRecs;      /// Records in source database.
+    sal_uInt16          mnStrmId;       /// Stream identifier.
+    sal_uInt16          mnFlags;        /// Flags for the cache.
+    sal_uInt16          mnBlockRecs;    /// Records in a source database block.
+    sal_uInt16          mnStdFields;    /// Number of standard pivot cache fields.
+    sal_uInt16          mnTotalFields;  /// Number of all fields (standard, grouped, calculated).
+    sal_uInt16          mnSrcType;      /// Database type.
+    String              maUserName;     /// Name of user who last modified the cache.
+
+    explicit            XclPCInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPCInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPCInfo& rInfo );
+
+// ============================================================================
+// Pivot table
+// ============================================================================
+
+// cached name ================================================================
+
+/** A name for various pivot table info structs. Includes 'use cache' state. */
+struct XclPTCachedName
+{
+    String              maName;         /// The visible name, if used.
+    bool                mbUseCache;     /// true = Use name in cache instead of maName.
+
+    inline explicit     XclPTCachedName() : mbUseCache( true ) {}
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTCachedName& rCachedName );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTCachedName& rCachedName );
+
+// ----------------------------------------------------------------------------
+
+/** Base struct for named info structs. Supports explicit naming and using the cache. */
+struct XclPTVisNameInfo
+{
+    XclPTCachedName     maVisName;      /// The displayed name of the item.
+
+    /** Returns true, if the name is set explicitly (maVisName.mbUseCache is false). */
+    inline bool         HasVisName() const { return !maVisName.mbUseCache; }
+    /** Returns the name, if set explicitly (maVisName.mbUseCache is false). */
+    const String*       GetVisName() const;
+    /** Sets the visible name and enables usage of cache if name is empty. */
+    void                SetVisName( const String& rName );
+};
+
+// Field item settings ========================================================
+
+/** Contains data for a pivot table data item (SXVI record). */
+struct XclPTItemInfo : public XclPTVisNameInfo
+{
+    sal_uInt16          mnType;         /// Type of the item (e.g. data, function, grand total).
+    sal_uInt16          mnFlags;        /// Several flags.
+    sal_uInt16          mnCacheIdx;     /// Index into cache for item name.
+
+    explicit            XclPTItemInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTItemInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTItemInfo& rInfo );
+
+// General field settings =====================================================
+
+typedef ::std::vector< USHORT > XclPTSubtotalVec;
+
+/** Contains data for a pivot table field (SXVD record). */
+struct XclPTFieldInfo : public XclPTVisNameInfo
+{
+    sal_uInt16          mnAxes;         /// Flags for axes this field is part of.
+    sal_uInt16          mnSubtCount;    /// Number of subtotal functions.
+    sal_uInt16          mnSubtotals;    /// Bitfield for subtotal functions.
+    sal_uInt16          mnItemCount;    /// Number of items of this field.
+    sal_uInt16          mnCacheIdx;     /// Index into cache for field name (not part of record).
+
+    explicit            XclPTFieldInfo();
+
+    /** Returns the API enum representing the orientation (first of row/col/page/data).
+        @param nMask  Restricts the axes taken into account.
+        @return  The first found axis orientation, that is allowed in nMask parameter. */
+    ::com::sun::star::sheet::DataPilotFieldOrientation GetApiOrient( sal_uInt16 nMask ) const;
+    /** Adds the axis orientation represented by the passed API enum. */
+    void                AddApiOrient( ::com::sun::star::sheet::DataPilotFieldOrientation eOrient );
+
+    /** Returns a vector of all set subtotal functions. */
+    void                GetSubtotals( XclPTSubtotalVec& rSubtotals ) const;
+    /** Sets the subtotal functions contained in the passed sequence. */
+    void                SetSubtotals( const XclPTSubtotalVec& rSubtotals );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldInfo& rInfo );
+
+// Extended field settings ====================================================
+
+/** Contains extended data for a pivot table field (SXVDEX record). */
+struct XclPTFieldExtInfo
+{
+    sal_uInt32          mnFlags;        /// Several flags and number of items for AutoShow.
+    sal_uInt16          mnSortField;    /// Index to data field sorting bases on.
+    sal_uInt16          mnShowField;    /// Index to data field AutoShow bases on.
+    sal_uInt16          mnNumFmt;
+    ::std::auto_ptr<rtl::OUString> mpFieldTotalName;
+
+    explicit            XclPTFieldExtInfo();
+
+    /** Returns the API constant representing the sorting mode. */
+    sal_Int32           GetApiSortMode() const;
+    /** Sets the sorting mode represented by the passed API constant. */
+    void                SetApiSortMode( sal_Int32 nSortMode );
+
+    /** Returns the API constant representing the AutoShow mode. */
+    sal_Int32           GetApiAutoShowMode() const;
+    /** Sets the AutoShow mode represented by the passed API constant. */
+    void                SetApiAutoShowMode( sal_Int32 nShowMode );
+
+    /** Returns the number of items to be shown in AutoShow mode. */
+    sal_Int32           GetApiAutoShowCount() const;
+    /** Sets the number of items to be shown in AutoShow mode. */
+    void                SetApiAutoShowCount( sal_Int32 nShowCount );
+
+    /** Returns the API constant representing the layout mode. */
+    sal_Int32           GetApiLayoutMode() const;
+    /** Sets the layout mode represented by the passed API constant. */
+    void                SetApiLayoutMode( sal_Int32 nLayoutMode );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldExtInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldExtInfo& rInfo );
+
+// Page field settings ========================================================
+
+/** Contains data for a pivot table page field (part of SXPI record). */
+struct XclPTPageFieldInfo
+{
+    sal_uInt16          mnField;        /// Base field for this page info.
+    sal_uInt16          mnSelItem;      /// Index to selected item.
+    sal_uInt16          mnObjId;        /// Escher object ID of dropdown listbox.
+
+    explicit            XclPTPageFieldInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTPageFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTPageFieldInfo& rInfo );
+
+// Data field settings ========================================================
+
+/** Contains data for a pivot table data field (SXDI record). */
+struct XclPTDataFieldInfo : public XclPTVisNameInfo
+{
+    sal_uInt16          mnField;        /// Base field for this data info.
+    sal_uInt16          mnAggFunc;      /// Data aggregation function.
+    sal_uInt16          mnRefType;      /// Result reference type.
+    sal_uInt16          mnRefField;     /// Index to SXVD of referred field used for the results.
+    sal_uInt16          mnRefItem;      /// Index to SXVI of referred item of the used field.
+    sal_uInt16          mnNumFmt;       /// Number format of the results.
+
+    explicit            XclPTDataFieldInfo();
+
+    /** Returns the API enum representing the aggregation function. */
+    ::com::sun::star::sheet::GeneralFunction GetApiAggFunc() const;
+    /** Sets the aggregation function represented by the passed API enum. */
+    void                SetApiAggFunc( ::com::sun::star::sheet::GeneralFunction eAggFunc );
+
+    /** Returns the API constant representing the result reference type. */
+    sal_Int32           GetApiRefType() const;
+    /** Sets the result reference type represented by the passed API constant. */
+    void                SetApiRefType( sal_Int32 nRefType );
+
+    /** Returns the API constant representing the result reference item type. */
+    sal_Int32           GetApiRefItemType() const;
+    /** Sets the result reference item type represented by the passed API constant. */
+    void                SetApiRefItemType( sal_Int32 nRefItemType );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTDataFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTDataFieldInfo& rInfo );
+
+// Pivot table settings =======================================================
+
+/** Contains data for a pivot table (SXVIEW record). */
+struct XclPTInfo
+{
+    String              maTableName;        /// The name of the pivot table.
+    String              maDataName;         /// The visible name of the data field.
+    XclRange            maOutXclRange;      /// Output range.
+    XclAddress          maDataXclPos;       /// First cell containing data.
+    sal_uInt16          mnFirstHeadRow;     /// First heading row.
+    sal_uInt16          mnCacheIdx;         /// 0-based index of the pivot cache.
+    sal_uInt16          mnDataAxis;         /// Orientation of data fields.
+    sal_uInt16          mnDataPos;          /// Position of data fields.
+    sal_uInt16          mnFields;           /// Number of all fields.
+    sal_uInt16          mnRowFields;        /// Number of row fields.
+    sal_uInt16          mnColFields;        /// Number of column fields.
+    sal_uInt16          mnPageFields;       /// Number of page fields.
+    sal_uInt16          mnDataFields;       /// Number of data fields.
+    sal_uInt16          mnDataRows;         /// Number of rows containing data.
+    sal_uInt16          mnDataCols;         /// Number of columns containing data.
+    sal_uInt16          mnFlags;            /// Flags for the entire pivot table.
+    sal_uInt16          mnAutoFmtIdx;       /// Index to pivot table autoformat.
+
+    explicit            XclPTInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTInfo& rInfo );
+
+// Extended pivot table settings ==============================================
+
+/** Extended information about a pivot table (SXEX record). */
+struct XclPTExtInfo
+{
+    sal_uInt16          mnSxformulaRecs;    /// Number of SXFORMULA records.
+    sal_uInt16          mnSxselectRecs;     /// Number of SXSELECT records.
+    sal_uInt16          mnPagePerRow;       /// Number of page fields per row.
+    sal_uInt16          mnPagePerCol;       /// Number of page fields per column.
+    sal_uInt32          mnFlags;            /// Flags for the entire pivot table.
+
+    explicit            XclPTExtInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTExtInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTExtInfo& rInfo );
+
+// ============================================================================
+
+// Pivot table autoformat settings ==============================================
+
+/** Pivot table autoformat settings (SXVIEWEX9 record). */
+struct XclPTViewEx9Info
+{
+    sal_uInt32          mbReport;           /// 2 for report* fmts ?
+    sal_uInt8           mnAutoFormat;       /// AutoFormat ID
+    sal_uInt8           mnGridLayout;       /// 0 == gridlayout, 0x10 == modern
+    String              maGrandTotalName;
+
+    explicit            XclPTViewEx9Info();
+    void                Init( const ScDPObject& rDPObj );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTViewEx9Info& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTViewEx9Info& rInfo );
+
+// ============================================================================
+#endif
+
diff --git sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx
index a4c908b..fed4d1a 100644
--- sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx
+++ sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx
@@ -72,6 +72,7 @@ static OString lcl_DateTimeToOString( const DateTime& rDateTime )
 //___________________________________________________________________
 // local functions
 
+#if 0 // xlsx
 void lcl_WriteDateTime( XclExpStream& rStrm, const DateTime& rDateTime )
 {
     rStrm.SetSliceSize( 7 );
@@ -95,6 +96,7 @@ void lcl_WriteFixedString( XclExpStream& rStrm, const XclExpString& rString, sal
     if( nLength > nStrBytes )
         rStrm.WriteZeroBytes( nLength - nStrBytes );
 }
+#endif // xlsx
 
 inline void lcl_GenerateGUID( sal_uInt8* pGUID, sal_Bool& rValidGUID )
 {
@@ -339,12 +341,14 @@ XclExpChTr0x0194::~XclExpChTr0x0194()
 {
 }
 
-void XclExpChTr0x0194::SaveCont( XclExpStream& rStrm )
+void XclExpChTr0x0194::SaveCont( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << (sal_uInt32) 0;
     lcl_WriteDateTime( rStrm, aDateTime );
     rStrm << (sal_uInt8) 0;
     lcl_WriteFixedString( rStrm, sUsername, 147 );
+#endif // xlsx
 }
 
 UINT16 XclExpChTr0x0194::GetNum() const
@@ -412,8 +416,9 @@ XclExpChTrInfo::~XclExpChTrInfo()
 {
 }
 
-void XclExpChTrInfo::SaveCont( XclExpStream& rStrm )
+void XclExpChTrInfo::SaveCont( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm	<< (sal_uInt32)	0xFFFFFFFF
             << (sal_uInt32)	0x00000000
             << (sal_uInt32)	0x00000020
@@ -424,6 +429,7 @@ void XclExpChTrInfo::SaveCont( XclExpStream& rStrm )
     lcl_WriteDateTime( rStrm, aDateTime );
     rStrm	<< (sal_uInt8)	0x0000
             << (sal_uInt16)	0x0002;
+#endif // xlsx
 }
 
 UINT16 XclExpChTrInfo::GetNum() const
@@ -741,6 +747,7 @@ void XclExpChTrData::Clear()
     nSize = 0;
 }
 
+#if 0 // xlsx
 void XclExpChTrData::WriteFormula( XclExpStream& rStrm, const XclExpChTrTabIdBuffer& rTabIdBuffer )
 {
     DBG_ASSERT( mxTokArr.is() && !mxTokArr->Empty(), "XclExpChTrData::Write - no formula" );
@@ -787,6 +794,7 @@ void XclExpChTrData::Write( XclExpStream& rStrm, const XclExpChTrTabIdBuffer& rT
         break;
     }
 }
+#endif // xlsx
 
 //___________________________________________________________________
 
@@ -918,8 +926,9 @@ void XclExpChTrCellContent::GetCellData(
     }
 }
 
-void XclExpChTrCellContent::SaveActionData( XclExpStream& rStrm ) const
+void XclExpChTrCellContent::SaveActionData( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     WriteTabId( rStrm, aPosition.Tab() );
     rStrm	<< (sal_uInt16)((pOldData ? (pOldData->nType << 3) : 0x0000) | (pNewData ? pNewData->nType : 0x0000))
             << (sal_uInt16) 0x0000;
@@ -930,6 +939,7 @@ void XclExpChTrCellContent::SaveActionData( XclExpStream& rStrm ) const
         pOldData->Write( rStrm, rIdBuffer );
     if( pNewData )
         pNewData->Write( rStrm, rIdBuffer );
+#endif // xlsx
 }
 
 UINT16 XclExpChTrCellContent::GetNum() const
@@ -1172,13 +1182,15 @@ XclExpChTrInsertTab::~XclExpChTrInsertTab()
 {
 }
 
-void XclExpChTrInsertTab::SaveActionData( XclExpStream& rStrm ) const
+void XclExpChTrInsertTab::SaveActionData( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     WriteTabId( rStrm, nTab );
     rStrm << sal_uInt32( 0 );
     lcl_WriteFixedString( rStrm, XclExpString( GetTabInfo().GetScTabName( nTab ) ), 127 );
     lcl_WriteDateTime( rStrm, GetDateTime() );
     rStrm.WriteZeroBytes( 133 );
+#endif // xlsx
 }
 
 UINT16 XclExpChTrInsertTab::GetNum() const
diff --git sc/source/filter/xlsx/xlsx-colrowst.cxx sc/source/filter/xlsx/xlsx-colrowst.cxx
index c1d0369..bf99f17 100644
--- sc/source/filter/xlsx/xlsx-colrowst.cxx
+++ sc/source/filter/xlsx/xlsx-colrowst.cxx
@@ -33,6 +33,7 @@
 
 
 
+#if 0 // xlsx
 #include "colrowst.hxx"
 
 #include <string.h>
@@ -319,3 +320,4 @@ void XclImpColRowSettings::ConvertHiddenFlags( SCTAB nScTab )
         rDoc.ShowRows( mnLastScRow + 1, MAXROW, nScTab, FALSE );
 }
 
+#endif // xlsx 
diff --git sc/source/filter/xlsx/xlsx-exctools.cxx sc/source/filter/xlsx/xlsx-exctools.cxx
index a6b1fe3..58b0973 100644
--- sc/source/filter/xlsx/xlsx-exctools.cxx
+++ sc/source/filter/xlsx/xlsx-exctools.cxx
@@ -304,8 +304,9 @@ void ExcScenarioCell::SetValue( const String& r )
 #define	EXCSCNEXT()				((ExcScenarioCell*)List::Next())
 
 
-ExcScenario::ExcScenario( XclImpStream& rIn, const RootData& rR ) : nTab( rR.pIR->GetCurrScTab() )
+ExcScenario::ExcScenario( XclImpStream& /*rIn*/, const RootData& rR ) : nTab( rR.pIR->GetCurrScTab() )
 {
+#if 0 // xlsx
     UINT16			nCref;
     UINT8			nName, nComment;
 
@@ -349,6 +350,7 @@ ExcScenario::ExcScenario( XclImpStream& rIn, const RootData& rR ) : nTab( rR.pIR
 
         p = EXCSCNEXT();
     }
+#endif // xlsx 
 }
 
 
@@ -371,8 +373,9 @@ ExcScenario::~ExcScenario()
 }
 
 
-void ExcScenario::Apply( const XclImpRoot& rRoot, const BOOL bLast )
+void ExcScenario::Apply( const XclImpRoot& /*rRoot*/, const BOOL /*bLast*/ )
 {
+#if 0 // xlsx
     ScDocument&         r = rRoot.GetDoc();
     ExcScenarioCell*	p = EXCSCFIRST();
     String				aSzenName( *pName );
@@ -407,6 +410,7 @@ void ExcScenario::Apply( const XclImpRoot& rRoot, const BOOL bLast )
     if( (static_cast< SCCOL >( nTab ) < rDocSett.mnDisplTab) && (rDocSett.mnDisplTab < MAXTAB) )
         ++rDocSett.mnDisplTab;
     rRoot.GetTabInfo().InsertScTab( nNewTab );
+#endif // xlsx 
 }
 
 
diff --git sc/source/filter/xlsx/xlsx-namebuff.cxx sc/source/filter/xlsx/xlsx-namebuff.cxx
index 5ecea62..babae35 100644
--- sc/source/filter/xlsx/xlsx-namebuff.cxx
+++ sc/source/filter/xlsx/xlsx-namebuff.cxx
@@ -303,6 +303,7 @@ BOOL ExtName::IsOLE( void ) const
 }
 
 
+#if 0 // xlsx
 ExtNameBuff::ExtNameBuff( const XclImpRoot& rRoot ) :
     XclImpRoot( rRoot )
 {
@@ -345,3 +346,4 @@ void ExtNameBuff::Reset( void )
 }
 
 
+#endif // xlsx 
diff --git sc/source/filter/xlsx/xlsx-read.cxx sc/source/filter/xlsx/xlsx-read.cxx
index 02e9058..aad3e13 100644
--- sc/source/filter/xlsx/xlsx-read.cxx
+++ sc/source/filter/xlsx/xlsx-read.cxx
@@ -35,6 +35,7 @@
 
 //------------------------------------------------------------------------
 
+#if 0 // xlsx
 #include <stdlib.h>
 #include <stdio.h>
 
@@ -1310,3 +1311,4 @@ FltError ImportExcel8::Read( void )
 
 //___________________________________________________________________
 
+#endif // xlsx
diff --git sc/source/filter/xlsx/xlsx-xechart.cxx sc/source/filter/xlsx/xlsx-xechart.cxx
index 3e06c27..3cb3e5e 100644
--- sc/source/filter/xlsx/xlsx-xechart.cxx
+++ sc/source/filter/xlsx/xlsx-xechart.cxx
@@ -113,6 +113,7 @@ using ::formula::FormulaToken;
 
 namespace {
 
+#if 0 // xlsx
 XclExpStream& operator<<( XclExpStream& rStrm, const XclChRectangle& rRect )
 {
     return rStrm << rRect.mnX << rRect.mnY << rRect.mnWidth << rRect.mnHeight;
@@ -142,6 +143,7 @@ void lclWriteChFrBlockRecord( XclExpStream& rStrm, const XclChFrBlock& rFrBlock,
     rStrm << nRecId << EXC_FUTUREREC_EMPTYFLAGS << rFrBlock.mnType << rFrBlock.mnContext << rFrBlock.mnValue1 << rFrBlock.mnValue2;
     rStrm.EndRecord();
 }
+#endif // xlsx
 
 template< typename Type >
 inline bool lclIsAutoAnyOrGetValue( Type& rValue, const Any& rAny, bool bPercent )
@@ -208,8 +210,9 @@ void XclExpChRootData::RegisterFutureRecBlock( const XclChFrBlock& rFrBlock )
     maUnwrittenFrBlocks.push_back( rFrBlock );
 }
 
-void XclExpChRootData::InitializeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRootData::InitializeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // first call from a future record writes all missing CHFRBLOCKBEGIN records
     if( !maUnwrittenFrBlocks.empty() )
     {
@@ -231,10 +234,12 @@ void XclExpChRootData::InitializeFutureRecBlock( XclExpStream& rStrm )
         maWrittenFrBlocks.insert( maWrittenFrBlocks.end(), maUnwrittenFrBlocks.begin(), maUnwrittenFrBlocks.end() );
         maUnwrittenFrBlocks.clear();
     }
+#endif // xlsx
 }
 
-void XclExpChRootData::FinalizeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRootData::FinalizeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( !maUnwrittenFrBlocks.empty() || !maWrittenFrBlocks.empty(), "XclExpChRootData::FinalizeFutureRecBlock - no future record level found" );
     if( !maUnwrittenFrBlocks.empty() )
     {
@@ -247,6 +252,7 @@ void XclExpChRootData::FinalizeFutureRecBlock( XclExpStream& rStrm )
         lclWriteChFrBlockRecord( rStrm, maWrittenFrBlocks.back(), false );
         maWrittenFrBlocks.pop_back();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -344,14 +350,18 @@ void XclExpChRoot::RegisterFutureRecBlock( const XclChFrBlock& rFrBlock )
     mxChData->RegisterFutureRecBlock( rFrBlock );
 }
 
-void XclExpChRoot::InitializeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRoot::InitializeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxChData->InitializeFutureRecBlock( rStrm );
+#endif // xlsx
 }
 
-void XclExpChRoot::FinalizeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRoot::FinalizeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxChData->FinalizeFutureRecBlock( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -368,8 +378,9 @@ XclExpChGroupBase::~XclExpChGroupBase()
 {
 }
 
-void XclExpChGroupBase::Save( XclExpStream& rStrm )
+void XclExpChGroupBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // header record
     XclExpRecord::Save( rStrm );
     // group records
@@ -386,6 +397,7 @@ void XclExpChGroupBase::Save( XclExpStream& rStrm )
         // CHEND record
         XclExpEmptyRecord( EXC_ID_CHEND ).Save( rStrm );
     }
+#endif // xlsx
 }
 
 bool XclExpChGroupBase::HasSubRecords() const
@@ -409,10 +421,12 @@ XclExpChFutureRecordBase::XclExpChFutureRecordBase( const XclExpChRoot& rRoot,
 {
 }
 
-void XclExpChFutureRecordBase::Save( XclExpStream& rStrm )
+void XclExpChFutureRecordBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     InitializeFutureRecBlock( rStrm );
     XclExpFutureRecord::Save( rStrm );
+#endif // xlsx
 }
 
 // Frame formatting ===========================================================
@@ -475,11 +489,13 @@ bool XclExpChLineFormat::IsDefault( XclChFrameType eDefFrameType ) const
         ((eDefFrameType == EXC_CHFRAMETYPE_AUTO) && IsAuto());
 }
 
-void XclExpChLineFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChLineFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maColor << maData.mnPattern << maData.mnWeight << maData.mnFlags;
     if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
         rStrm << rStrm.GetRoot().GetPalette().GetColorIndex( mnColorId );
+#endif // xlsx
 }
 
 namespace {
@@ -566,14 +582,16 @@ bool XclExpChAreaFormat::IsDefault( XclChFrameType eDefFrameType ) const
         ((eDefFrameType == EXC_CHFRAMETYPE_AUTO) && IsAuto());
 }
 
-void XclExpChAreaFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChAreaFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maPattColor << maData.maBackColor << maData.mnPattern << maData.mnFlags;
     if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
     {
         const XclExpPalette& rPal = rStrm.GetRoot().GetPalette();
         rStrm << rPal.GetColorIndex( mnPattColorId ) << rPal.GetColorIndex( mnBackColorId );
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -600,8 +618,9 @@ bool XclExpChEscherFormat::IsValid() const
     return maData.mxEscherSet.is();
 }
 
-void XclExpChEscherFormat::Save( XclExpStream& rStrm )
+void XclExpChEscherFormat::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( maData.mxEscherSet.is() )
     {
         // replace RGB colors with palette indexes in the Escher container
@@ -612,6 +631,7 @@ void XclExpChEscherFormat::Save( XclExpStream& rStrm )
         // save the record group
         XclExpChGroupBase::Save( rStrm );
     }
+#endif // xlsx
 }
 
 bool XclExpChEscherFormat::HasSubRecords() const
@@ -620,11 +640,13 @@ bool XclExpChEscherFormat::HasSubRecords() const
     return maPicFmt.mnBmpMode != EXC_CHPICFORMAT_NONE;
 }
 
-void XclExpChEscherFormat::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChEscherFormat::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_CHPICFORMAT, 14 );
     rStrm << maPicFmt.mnBmpMode << maPicFmt.mnFormat << maPicFmt.mnFlags << maPicFmt.mfScale;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 sal_uInt32 XclExpChEscherFormat::RegisterColor( sal_uInt16 nPropId )
@@ -642,14 +664,16 @@ sal_uInt32 XclExpChEscherFormat::RegisterColor( sal_uInt16 nPropId )
     return XclExpPalette::GetColorIdFromIndex( EXC_COLOR_CHWINDOWBACK );
 }
 
-void XclExpChEscherFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChEscherFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( maData.mxEscherSet.is(), "XclExpChEscherFormat::WriteBody - missing property container" );
     // write Escher property container via temporary memory stream
     SvMemoryStream aMemStrm;
     maData.mxEscherSet->Commit( aMemStrm );
     aMemStrm.Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( aMemStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -707,11 +731,13 @@ bool XclExpChFrameBase::IsDefaultFrameBase( XclChFrameType eDefFrameType ) const
         (!mxAreaFmt || mxAreaFmt->IsDefault( eDefFrameType ));
 }
 
-void XclExpChFrameBase::WriteFrameRecords( XclExpStream& rStrm )
+void XclExpChFrameBase::WriteFrameRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxLineFmt );
     lclSaveRecord( rStrm, mxAreaFmt );
     lclSaveRecord( rStrm, mxEscherFmt );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -737,8 +763,9 @@ bool XclExpChFrame::IsDeleteable() const
     return IsDefault() && GetFormatInfo( meObjType ).mbDeleteDefFrame;
 }
 
-void XclExpChFrame::Save( XclExpStream& rStrm )
+void XclExpChFrame::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( meObjType )
     {
         // wall/floor frame without CHFRAME header record
@@ -749,16 +776,21 @@ void XclExpChFrame::Save( XclExpStream& rStrm )
         default:
             XclExpChGroupBase::Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpChFrame::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChFrame::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteFrameRecords( rStrm );
+#endif // xlsx
 }
 
-void XclExpChFrame::WriteBody( XclExpStream& rStrm )
+void XclExpChFrame::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnFormat << maData.mnFlags;
+#endif // xlsx
 }
 
 namespace {
@@ -983,8 +1015,9 @@ void XclExpChSourceLink::AppendString( const String& rStr )
     XclExpStringHelper::AppendString( *mxString, GetRoot(), rStr );
 }
 
-void XclExpChSourceLink::Save( XclExpStream& rStrm )
+void XclExpChSourceLink::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // CHFORMATRUNS record
     if( mxString.is() && mxString->IsRich() )
     {
@@ -1002,15 +1035,18 @@ void XclExpChSourceLink::Save( XclExpStream& rStrm )
         rStrm << sal_uInt16( 0 ) << *mxString;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpChSourceLink::WriteBody( XclExpStream& rStrm )
+void XclExpChSourceLink::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnDestType
             << maData.mnLinkType
             << maData.mnFlags
             << maData.mnNumFmtIdx
             << mxLinkFmla;
+#endif // xlsx
 }
 
 // Text =======================================================================
@@ -1029,9 +1065,11 @@ XclExpChObjectLink::XclExpChObjectLink( sal_uInt16 nLinkTarget, const XclChDataP
     maData.maPointPos = rPointPos;
 }
 
-void XclExpChObjectLink::WriteBody( XclExpStream& rStrm )
+void XclExpChObjectLink::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnTarget << maData.maPointPos.mnSeriesIdx << maData.maPointPos.mnPointIdx;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1057,10 +1095,12 @@ void XclExpChFrLabelProps::Convert( const ScfPropertySet& rPropSet, bool bShowSe
         maData.maSeparator = String( sal_Unicode( ' ' ) );
 }
 
-void XclExpChFrLabelProps::WriteBody( XclExpStream& rStrm )
+void XclExpChFrLabelProps::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclExpString aXclSep( maData.maSeparator, EXC_STR_FORCEUNICODE | EXC_STR_SMARTFLAGS );
     rStrm << maData.mnFlags << aXclSep;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1281,8 +1321,9 @@ sal_uInt16 XclExpChText::GetAttLabelFlags() const
     return nFlags;
 }
 
-void XclExpChText::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChText::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // CHFONT record
     lclSaveRecord( rStrm, mxFont );
     // CHSOURCELINK group
@@ -1293,10 +1334,12 @@ void XclExpChText::WriteSubRecords( XclExpStream& rStrm )
     lclSaveRecord( rStrm, mxObjLink );
     // CHFRLABELPROPS record
     lclSaveRecord( rStrm, mxLabelProps );
+#endif // xlsx
 }
 
-void XclExpChText::WriteBody( XclExpStream& rStrm )
+void XclExpChText::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnHAlign
             << maData.mnVAlign
             << maData.mnBackMode
@@ -1310,6 +1353,7 @@ void XclExpChText::WriteBody( XclExpStream& rStrm )
                 << maData.mnPlacement
                 << maData.mnRotation;
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1396,14 +1440,16 @@ void XclExpChMarkerFormat::RegisterColors( const XclExpChRoot& rRoot )
     }
 }
 
-void XclExpChMarkerFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChMarkerFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maLineColor << maData.maFillColor << maData.mnMarkerType << maData.mnFlags;
     if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
     {
         const XclExpPalette& rPal = rStrm.GetRoot().GetPalette();
         rStrm << rPal.GetColorIndex( mnLineColorId ) << rPal.GetColorIndex( mnFillColorId ) << maData.mnMarkerSize;
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1457,9 +1503,11 @@ void XclExpCh3dDataFormat::Convert( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpCh3dDataFormat::WriteBody( XclExpStream& rStrm )
+void XclExpCh3dDataFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnBase << maData.mnTop;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1534,22 +1582,26 @@ void XclExpChDataFormat::ConvertLine( const ScfPropertySet& rPropSet, XclChObjec
     ConvertFrameBase( GetChRoot(), rPropSet, eObjType );
 }
 
-void XclExpChDataFormat::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChDataFormat::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mx3dDataFmt );
     WriteFrameRecords( rStrm );
     lclSaveRecord( rStrm, mxPieFmt );
     lclSaveRecord( rStrm, mxMarkerFmt );
     lclSaveRecord( rStrm, mxSeriesFmt );
     lclSaveRecord( rStrm, mxAttLabel );
+#endif // xlsx
 }
 
-void XclExpChDataFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChDataFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.maPointPos.mnPointIdx
             << maData.maPointPos.mnSeriesIdx
             << maData.mnFormatIdx
             << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1607,8 +1659,9 @@ bool XclExpChSerTrendLine::Convert( Reference< XRegressionCurve > xRegCurve, sal
     return true;
 }
 
-void XclExpChSerTrendLine::WriteBody( XclExpStream& rStrm )
+void XclExpChSerTrendLine::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnLineType
             << maData.mnOrder
             << maData.mfIntercept
@@ -1616,6 +1669,7 @@ void XclExpChSerTrendLine::WriteBody( XclExpStream& rStrm )
             << maData.mnShowRSquared
             << maData.mfForecastFor
             << maData.mfForecastBack;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1689,14 +1743,16 @@ bool XclExpChSerErrorBar::Convert( XclExpChSourceLink& rValueLink, sal_uInt16& r
     return bOk;
 }
 
-void XclExpChSerErrorBar::WriteBody( XclExpStream& rStrm )
+void XclExpChSerErrorBar::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnBarType
             << maData.mnSourceType
             << maData.mnLineEnd
             << sal_uInt8( 1 )       // must be 1 to make line visible
             << maData.mfValue
             << maData.mnValueCount;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1931,8 +1987,9 @@ void XclExpChSeries::ConvertCategSequence( Reference< XLabeledDataSequence > xCa
         maData.mnCategCount = mxCategLink->ConvertDataSequence( xCategSeq->getValues(), false );
 }
 
-void XclExpChSeries::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChSeries::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxTitleLink );
     lclSaveRecord( rStrm, mxValueLink );
     lclSaveRecord( rStrm, mxCategLink );
@@ -1945,6 +2002,7 @@ void XclExpChSeries::WriteSubRecords( XclExpStream& rStrm )
         XclExpUInt16Record( EXC_ID_CHSERPARENT, mnParentIdx ).Save( rStrm );
     lclSaveRecord( rStrm, mxTrendLine );
     lclSaveRecord( rStrm, mxErrorBar );
+#endif // xlsx
 }
 
 void XclExpChSeries::InitFromParent( const XclExpChSeries& rParent )
@@ -1997,11 +2055,13 @@ void XclExpChSeries::CreateErrorBar( const ScfPropertySet& rPropSet,
     }
 }
 
-void XclExpChSeries::WriteBody( XclExpStream& rStrm )
+void XclExpChSeries::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnCategType << maData.mnValueType << maData.mnCategCount << maData.mnValueCount;
     if( GetBiff() == EXC_BIFF8 )
         rStrm << maData.mnBubbleType << maData.mnBubbleCount;
+#endif // xlsx
 }
 
 // Chart type groups ==========================================================
@@ -2077,8 +2137,9 @@ void XclExpChType::SetStacked( bool bPercent )
     }
 }
 
-void XclExpChType::WriteBody( XclExpStream& rStrm )
+void XclExpChType::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( GetRecId() )
     {
         case EXC_ID_CHBAR:
@@ -2106,6 +2167,7 @@ void XclExpChType::WriteBody( XclExpStream& rStrm )
         default:
             DBG_ERRORFILE( "XclExpChType::WriteBody - unknown chart type" );
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2152,8 +2214,9 @@ void XclExpChChart3d::Convert( const ScfPropertySet& rPropSet, bool b3dWallChart
     }
 }
 
-void XclExpChChart3d::WriteBody( XclExpStream& rStrm )
+void XclExpChChart3d::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnRotation
             << maData.mnElevation
             << maData.mnEyeDist
@@ -2161,6 +2224,7 @@ void XclExpChChart3d::WriteBody( XclExpStream& rStrm )
             << maData.mnRelDepth
             << maData.mnDepthGap
             << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2181,15 +2245,19 @@ void XclExpChLegend::Convert( const ScfPropertySet& rPropSet )
     GetChartPropSetHelper().ReadLegendProperties( maData, rPropSet );
 }
 
-void XclExpChLegend::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChLegend::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxText );
     lclSaveRecord( rStrm, mxFrame );
+#endif // xlsx
 }
 
-void XclExpChLegend::WriteBody( XclExpStream& rStrm )
+void XclExpChLegend::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maRect << maData.mnDockMode << maData.mnSpacing << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2209,14 +2277,18 @@ void XclExpChDropBar::Convert( const ScfPropertySet& rPropSet )
         SetDefaultFrameBase( GetChRoot(), EXC_CHFRAMETYPE_INVISIBLE, true );
 }
 
-void XclExpChDropBar::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChDropBar::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteFrameRecords( rStrm );
+#endif // xlsx
 }
 
-void XclExpChDropBar::WriteBody( XclExpStream& rStrm )
+void XclExpChDropBar::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << mnBarDist;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2338,8 +2410,9 @@ void XclExpChTypeGroup::ConvertLegend( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpChTypeGroup::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChTypeGroup::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maType.Save( rStrm );
     lclSaveRecord( rStrm, mxChart3d );
     lclSaveRecord( rStrm, mxLegend );
@@ -2347,6 +2420,7 @@ void XclExpChTypeGroup::WriteSubRecords( XclExpStream& rStrm )
     lclSaveRecord( rStrm, mxDownBar );
     for( XclExpChLineFormatMap::iterator aLIt = maChartLines.begin(), aLEnd = maChartLines.end(); aLIt != aLEnd; ++aLIt )
         lclSaveRecord( rStrm, aLIt->second, EXC_ID_CHCHARTLINE, aLIt->first );
+#endif // xlsx
 }
 
 sal_uInt16 XclExpChTypeGroup::GetFreeFormatIdx() const
@@ -2423,9 +2497,11 @@ bool XclExpChTypeGroup::CreateStockSeries( Reference< XDataSeries > xDataSeries,
     return bOk;
 }
 
-void XclExpChTypeGroup::WriteBody( XclExpStream& rStrm )
+void XclExpChTypeGroup::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maRect << maData.mnFlags << maData.mnGroupIdx;
+#endif // xlsx
 }
 
 // Axes =======================================================================
@@ -2465,9 +2541,11 @@ void XclExpChLabelRange::ConvertAxisPosition( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpChLabelRange::WriteBody( XclExpStream& rStrm )
+void XclExpChLabelRange::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnCross << maData.mnLabelFreq << maData.mnTickFreq << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2538,14 +2616,16 @@ void XclExpChValueRange::ConvertAxisPosition( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpChValueRange::WriteBody( XclExpStream& rStrm )
+void XclExpChValueRange::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mfMin
             << maData.mfMax
             << maData.mfMajorStep
             << maData.mfMinorStep
             << maData.mfCross
             << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2626,8 +2706,9 @@ void XclExpChTick::SetRotation( sal_uInt16 nRotation )
     ::insert_value( maData.mnFlags, XclTools::GetXclOrientFromRot( nRotation ), 2, 3 );
 }
 
-void XclExpChTick::WriteBody( XclExpStream& rStrm )
+void XclExpChTick::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnMajor
             << maData.mnMinor
             << maData.mnLabelPos
@@ -2637,6 +2718,7 @@ void XclExpChTick::WriteBody( XclExpStream& rStrm )
             << maData.mnFlags;
     if( GetBiff() == EXC_BIFF8 )
         rStrm << GetPalette().GetColorIndex( mnTextColorId ) << maData.mnRotation;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2771,8 +2853,9 @@ void XclExpChAxis::ConvertWall( XDiagramRef xDiagram )
     }
 }
 
-void XclExpChAxis::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChAxis::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxLabelRange );
     lclSaveRecord( rStrm, mxValueRange );
     if( mnNumFmtIdx != EXC_FORMAT_NOTFOUND )
@@ -2783,11 +2866,14 @@ void XclExpChAxis::WriteSubRecords( XclExpStream& rStrm )
     lclSaveRecord( rStrm, mxMajorGrid, EXC_ID_CHAXISLINE, EXC_CHAXISLINE_MAJORGRID );
     lclSaveRecord( rStrm, mxMinorGrid, EXC_ID_CHAXISLINE, EXC_CHAXISLINE_MINORGRID );
     lclSaveRecord( rStrm, mxWallFrame, EXC_ID_CHAXISLINE, EXC_CHAXISLINE_WALLS );
+#endif // xlsx
 }
 
-void XclExpChAxis::WriteBody( XclExpStream& rStrm )
+void XclExpChAxis::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnType << maData.maRect;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2933,8 +3019,9 @@ bool XclExpChAxesSet::Is3dChart() const
     return xTypeGroup.is() && xTypeGroup->Is3dChart();
 }
 
-void XclExpChAxesSet::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChAxesSet::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxXAxis );
     lclSaveRecord( rStrm, mxYAxis );
     lclSaveRecord( rStrm, mxZAxis );
@@ -2947,6 +3034,7 @@ void XclExpChAxesSet::WriteSubRecords( XclExpStream& rStrm )
         mxPlotFrame->Save( rStrm );
     }
     maTypeGroups.Save( rStrm );
+#endif // xlsx
 }
 
 XclExpChTypeGroupRef XclExpChAxesSet::GetFirstTypeGroup() const
@@ -2979,9 +3067,11 @@ void XclExpChAxesSet::ConvertAxis(
     rxChAxisTitle = lclCreateTitle( GetChRoot(), xTitled, nTitleTarget );
 }
 
-void XclExpChAxesSet::WriteBody( XclExpStream& rStrm )
+void XclExpChAxesSet::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnAxesSetId << maData.maRect;
+#endif // xlsx
 }
 
 // The chart object ===========================================================
@@ -3093,8 +3183,9 @@ void XclExpChChart::SetDataLabel( XclExpChTextRef xText )
         maLabels.AppendRecord( xText );
 }
 
-void XclExpChChart::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChChart::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // background format
     lclSaveRecord( rStrm, mxFrame );
 
@@ -3116,11 +3207,14 @@ void XclExpChChart::WriteSubRecords( XclExpStream& rStrm )
     // chart title and data labels
     lclSaveRecord( rStrm, mxTitle );
     maLabels.Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpChChart::WriteBody( XclExpStream& rStrm )
+void XclExpChChart::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
      rStrm << maRect;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
diff --git sc/source/filter/xlsx/xlsx-xecontent.cxx sc/source/filter/xlsx/xlsx-xecontent.cxx
index 4575fca..c639e6b 100644
--- sc/source/filter/xlsx/xlsx-xecontent.cxx
+++ sc/source/filter/xlsx/xlsx-xecontent.cxx
@@ -166,8 +166,9 @@ sal_uInt32 XclExpSstImpl::Insert( XclExpStringRef xString )
     return nSstIndex;
 }
 
-void XclExpSstImpl::Save( XclExpStream& rStrm )
+void XclExpSstImpl::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( maStringList.empty() )
         return;
 
@@ -257,6 +258,7 @@ void XclExpSstImpl::Save( XclExpStream& rStrm )
     rStrm.CopyFromStream( aExtSst );
 
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 void XclExpSstImpl::SaveXml( XclExpXmlStream& rStrm )
@@ -306,9 +308,11 @@ sal_uInt32 XclExpSst::Insert( XclExpStringRef xString )
     return mxImpl->Insert( xString );
 }
 
-void XclExpSst::Save( XclExpStream& rStrm )
+void XclExpSst::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpSst::SaveXml( XclExpXmlStream& rStrm )
@@ -343,8 +347,9 @@ sal_uInt32 XclExpMergedcells::GetBaseXFId( const ScAddress& rPos ) const
     return EXC_XFID_NOTFOUND;
 }
 
-void XclExpMergedcells::Save( XclExpStream& rStrm )
+void XclExpMergedcells::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( GetBiff() == EXC_BIFF8 )
     {
         XclRangeList aXclRanges;
@@ -361,6 +366,7 @@ void XclExpMergedcells::Save( XclExpStream& rStrm )
             nRemainingRanges -= nRangeCount;
         }
     }
+#endif // xlsx
 }
 
 void XclExpMergedcells::SaveXml( XclExpXmlStream& rStrm )
@@ -397,15 +403,19 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
     INetURLObject aUrlObj( rUrl );
     const INetProtocol eProtocol = aUrlObj.GetProtocol();
     bool bWithRepr = rRepr.Len() > 0;
+#if 0 // xlsx
     XclExpStream aXclStrm( *mxVarData, rRoot );         // using in raw write mode.
+#endif // xlsx
 
     // description
     if( bWithRepr )
     {
         XclExpString aDescr( rRepr, EXC_STR_FORCEUNICODE, 255 );
+#if 0 // xlsx
         aXclStrm << sal_uInt32( aDescr.Len() + 1 );     // string length + 1 trailing zero word
         aDescr.WriteBuffer( aXclStrm );                 // NO flags
         aXclStrm << sal_uInt16( 0 );
+#endif // xlsx
 
         mnFlags |= EXC_HLINK_DESCR;
         mxRepr.reset( new String( rRepr ) );
@@ -432,6 +442,7 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
 
         ByteString aAsciiLink( aFileName, rRoot.GetTextEncoding() );
         XclExpString aLink( aFileName, EXC_STR_FORCEUNICODE, 255 );
+#if 0 // xlsx
         aXclStrm    << XclTools::maGuidFileMoniker
                     << nLevel
                     << sal_uInt32( aAsciiLink.Len() + 1 );      // string length + 1 trailing zero byte
@@ -443,6 +454,7 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
                     << sal_uInt32( aLink.GetBufferSize() )      // byte count, not string length
                     << sal_uInt16( 0x0003 );
         aLink.WriteBuffer( aXclStrm );                          // NO flags
+#endif // xlsx
 
         if( !mxRepr.get() )
             mxRepr.reset( new String( aFileName ) );
@@ -452,10 +464,12 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
     else if( eProtocol != INET_PROT_NOT_VALID )
     {
         XclExpString aUrl( aUrlObj.GetURLNoMark(), EXC_STR_FORCEUNICODE, 255 );
+#if 0 // xlsx
         aXclStrm    << XclTools::maGuidUrlMoniker
                     << sal_uInt32( aUrl.GetBufferSize() + 2 );  // byte count + 1 trailing zero word
         aUrl.WriteBuffer( aXclStrm );                           // NO flags
         aXclStrm    << sal_uInt16( 0 );
+#endif // xlsx
 
         mnFlags |= EXC_HLINK_BODY | EXC_HLINK_ABS;
         if( !mxRepr.get() )
@@ -476,9 +490,11 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
 
     if( mxTextMark.get() )
     {
+#if 0 // xlsx
         aXclStrm    << sal_uInt32( mxTextMark->Len() + 1 );  // string length + 1 trailing zero word
         mxTextMark->WriteBuffer( aXclStrm );                 // NO flags
         aXclStrm    << sal_uInt16( 0 );
+#endif // xlsx
 
         mnFlags |= EXC_HLINK_MARK;
     }
@@ -523,22 +539,26 @@ String XclExpHyperlink::BuildFileName(
     return aDosName;
 }
 
-void XclExpHyperlink::WriteBody( XclExpStream& rStrm )
+void XclExpHyperlink::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( maScPos.Col() );
     sal_uInt16 nXclRow = static_cast< sal_uInt16 >( maScPos.Row() );
     rStrm   << nXclRow << nXclRow << nXclCol << nXclCol;
     WriteEmbeddedData( rStrm );
+#endif // xlsx
 }
 
-void XclExpHyperlink::WriteEmbeddedData( XclExpStream& rStrm )
+void XclExpHyperlink::WriteEmbeddedData( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << XclTools::maGuidStdLink
             << sal_uInt32( 2 )
             << mnFlags;
 
     mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( *mxVarData );
+#endif // xlsx
 }
 
 void XclExpHyperlink::SaveXml( XclExpXmlStream& rStrm )
@@ -585,8 +605,9 @@ void XclExpLabelranges::FillRangeList( ScRangeList& rScRanges,
     }
 }
 
-void XclExpLabelranges::Save( XclExpStream& rStrm )
+void XclExpLabelranges::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclExpAddressConverter& rAddrConv = GetAddressConverter();
     XclRangeList aRowXclRanges, aColXclRanges;
     rAddrConv.ConvertRangeList( aRowXclRanges, maRowRanges, false );
@@ -597,6 +618,7 @@ void XclExpLabelranges::Save( XclExpStream& rStrm )
         rStrm << aRowXclRanges << aColXclRanges;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
 // Conditional formatting  ====================================================
@@ -716,8 +738,9 @@ XclExpCFImpl::XclExpCFImpl( const XclExpRoot& rRoot, const ScCondFormatEntry& rF
     }
 }
 
-void XclExpCFImpl::WriteBody( XclExpStream& rStrm )
+void XclExpCFImpl::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // *** mode and comparison operator ***
 
     rStrm << mnType << mnOperator;
@@ -806,6 +829,7 @@ void XclExpCFImpl::WriteBody( XclExpStream& rStrm )
         mxTokArr1->WriteArray( rStrm );
     if( mxTokArr2.get() )
         mxTokArr2->WriteArray( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -821,9 +845,11 @@ XclExpCF::~XclExpCF()
 {
 }
 
-void XclExpCF::WriteBody( XclExpStream& rStrm )
+void XclExpCF::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->WriteBody( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -853,17 +879,20 @@ bool XclExpCondfmt::IsValid() const
     return !maCFList.IsEmpty() && !maXclRanges.empty();
 }
 
-void XclExpCondfmt::Save( XclExpStream& rStrm )
+void XclExpCondfmt::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( IsValid() )
     {
         XclExpRecord::Save( rStrm );
         maCFList.Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpCondfmt::WriteBody( XclExpStream& rStrm )
+void XclExpCondfmt::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( !maCFList.IsEmpty(), "XclExpCondfmt::WriteBody - no CF records to write" );
     DBG_ASSERT( !maXclRanges.empty(), "XclExpCondfmt::WriteBody - no cell ranges found" );
 
@@ -871,6 +900,7 @@ void XclExpCondfmt::WriteBody( XclExpStream& rStrm )
             << sal_uInt16( 1 )
             << maXclRanges.GetEnclosingRange()
             << maXclRanges;
+#endif // xlsx
 }
 
 void XclExpCondfmt::SaveXml( XclExpXmlStream& rStrm )
@@ -911,9 +941,11 @@ XclExpCondFormatBuffer::XclExpCondFormatBuffer( const XclExpRoot& rRoot ) :
     }
 }
 
-void XclExpCondFormatBuffer::Save( XclExpStream& rStrm )
+void XclExpCondFormatBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maCondfmtList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpCondFormatBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -926,22 +958,26 @@ void XclExpCondFormatBuffer::SaveXml( XclExpXmlStream& rStrm )
 namespace {
 
 /** Writes a formula for the DV record. */
-void lclWriteDvFormula( XclExpStream& rStrm, const XclTokenArray* pXclTokArr )
+void lclWriteDvFormula( XclExpStream& /*rStrm*/, const XclTokenArray* /*pXclTokArr*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nFmlaSize = pXclTokArr ? pXclTokArr->GetSize() : 0;
     rStrm << nFmlaSize << sal_uInt16( 0 );
     if( pXclTokArr )
         pXclTokArr->WriteArray( rStrm );
+#endif // xlsx
 }
 
 /** Writes a formula for the DV record, based on a single string. */
-void lclWriteDvFormula( XclExpStream& rStrm, const XclExpString& rString )
+void lclWriteDvFormula( XclExpStream& /*rStrm*/, const XclExpString& /*rString*/ )
 {
+#if 0 // xlsx
     // fake a formula with a single tStr token
     rStrm   << static_cast< sal_uInt16 >( rString.GetSize() + 1 )
             << sal_uInt16( 0 )
             << EXC_TOKID_STR
             << rString;
+#endif // xlsx
 }
 
 const char* lcl_GetValidationType( sal_uInt32 nFlags )
@@ -1146,8 +1182,9 @@ bool XclExpDV::Finalize()
     return (mnScHandle != ULONG_MAX) && !maXclRanges.empty();
 }
 
-void XclExpDV::WriteBody( XclExpStream& rStrm )
+void XclExpDV::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // flags and strings
     rStrm << mnFlags << maPromptTitle << maErrorTitle << maPromptText << maErrorText;
     // condition formulas
@@ -1158,6 +1195,7 @@ void XclExpDV::WriteBody( XclExpStream& rStrm )
     lclWriteDvFormula( rStrm, mxTokArr2.get() );
     // cell ranges
     rStrm << maXclRanges;
+#endif // xlsx
 }
 
 void XclExpDV::SaveXml( XclExpXmlStream& rStrm )
@@ -1214,8 +1252,9 @@ void XclExpDval::InsertCellRange( const ScRange& rRange, ULONG nScHandle )
     }
 }
 
-void XclExpDval::Save( XclExpStream& rStrm )
+void XclExpDval::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // check all records
     size_t nPos = maDVList.GetSize();
     while( nPos )
@@ -1232,6 +1271,7 @@ void XclExpDval::Save( XclExpStream& rStrm )
         XclExpRecord::Save( rStrm );
         maDVList.Save( rStrm );
     }
+#endif // xlsx
 }
 
 void XclExpDval::SaveXml( XclExpXmlStream& rStrm )
@@ -1290,10 +1330,12 @@ XclExpDV& XclExpDval::SearchOrCreateDv( ULONG nScHandle )
     return *mxLastFoundDV;
 }
 
-void XclExpDval::WriteBody( XclExpStream& rStrm )
+void XclExpDval::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm.WriteZeroBytes( 10 );
     rStrm << EXC_DVAL_NOOBJ << static_cast< sal_uInt32 >( maDVList.GetSize() );
+#endif // xlsx
 }
 
 // Web Queries ================================================================
@@ -1336,8 +1378,9 @@ XclExpWebQuery::~XclExpWebQuery()
 {
 }
 
-void XclExpWebQuery::Save( XclExpStream& rStrm )
+void XclExpWebQuery::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( !mbEntireDoc || !mxQryTables.get(), "XclExpWebQuery::Save - illegal mode" );
     sal_uInt16 nFlags;
 
@@ -1401,6 +1444,7 @@ void XclExpWebQuery::Save( XclExpStream& rStrm )
                 << *mxQryTables;            // comma separated list of source tables
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
diff --git sc/source/filter/xlsx/xlsx-xeescher.cxx sc/source/filter/xlsx/xlsx-xeescher.cxx
index 918e491..e224fc2 100644
--- sc/source/filter/xlsx/xlsx-xeescher.cxx
+++ sc/source/filter/xlsx/xlsx-xeescher.cxx
@@ -102,8 +102,9 @@ XclExpImgData::XclExpImgData( const Graphic& rGraphic, sal_uInt16 nRecId ) :
 {
 }
 
-void XclExpImgData::Save( XclExpStream& rStrm )
+void XclExpImgData::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     Bitmap aBmp = maGraphic.GetBitmap();
     if( aBmp.GetBitCount() != 24 )
         aBmp.Convert( BMP_CONVERSION_24BIT );
@@ -142,6 +143,7 @@ void XclExpImgData::Save( XclExpStream& rStrm )
         }
         aBmp.ReleaseAccess( pAccess );
     }
+#endif // xlsx
 }
 
 void XclExpImgData::SaveXml( XclExpXmlStream& rStrm )
@@ -220,20 +222,24 @@ void XclExpControlHelper::ConvertSheetLinks( Reference< XShape > xShape )
     }
 }
 
-void XclExpControlHelper::WriteFormula( XclExpStream& rStrm, const XclTokenArray& rTokArr ) const
+void XclExpControlHelper::WriteFormula( XclExpStream& /*rStrm*/, const XclTokenArray& /*rTokArr*/ ) const
 {
+#if 0 // xlsx
     sal_uInt16 nFmlaSize = rTokArr.GetSize();
     rStrm << nFmlaSize << sal_uInt32( 0 );
     rTokArr.WriteArray( rStrm );
     if( nFmlaSize & 1 )             // pad to 16-bit
         rStrm << sal_uInt8( 0 );
+#endif // xlsx
 }
 
-void XclExpControlHelper::WriteFormulaSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId, const XclTokenArray& rTokArr ) const
+void XclExpControlHelper::WriteFormulaSubRec( XclExpStream& /*rStrm*/, sal_uInt16 /*nSubRecId*/, const XclTokenArray& /*rTokArr*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( nSubRecId, (rTokArr.GetSize() + 5) & ~1 );
     WriteFormula( rStrm, rTokArr );
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -296,8 +302,9 @@ XclExpOcxControlObj::XclExpOcxControlObj( const XclExpRoot& rRoot, Reference< XS
     ConvertSheetLinks( xShape );
 }
 
-void XclExpOcxControlObj::WriteSubRecs( XclExpStream& rStrm )
+void XclExpOcxControlObj::WriteSubRecs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // OBJCF - clipboard format
     rStrm.StartRecord( EXC_ID_OBJCF, 2 );
     rStrm << sal_uInt16( 2 );
@@ -343,6 +350,7 @@ void XclExpOcxControlObj::WriteSubRecs( XclExpStream& rStrm )
         WriteFormula( rStrm, *pSrcRange );
 
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 #else
@@ -613,8 +621,9 @@ bool XclExpTbxControlObj::SetMacroLink( const ScriptEventDescriptor& rEvent )
 */
 }
 
-void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
+void XclExpTbxControlObj::WriteSubRecs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( mnObjType )
     {
         // *** Push buttons, labels ***
@@ -749,16 +758,20 @@ void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
         }
         break;
     }
+#endif // xlsx
 }
 
-void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId )
+void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& /*rStrm*/, sal_uInt16 /*nSubRecId*/ )
 {
+#if 0 // xlsx
     if( const XclTokenArray* pCellLink = GetCellLinkTokArr() )
         WriteFormulaSubRec( rStrm, nSubRecId, *pCellLink );
+#endif // xlsx
 }
 
-void XclExpTbxControlObj::WriteSbs( XclExpStream& rStrm )
+void XclExpTbxControlObj::WriteSbs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nOrient = 0;
     ::set_flag( nOrient, EXC_OBJ_SCROLLBAR_HOR, mbScrollHor );
     sal_uInt16 nStyle = EXC_OBJ_SCROLLBAR_DEFFLAGS;
@@ -775,6 +788,7 @@ void XclExpTbxControlObj::WriteSbs( XclExpStream& rStrm )
             << sal_uInt16( 15 )             // thumb width
             << nStyle;                      // flags/style
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 #endif
@@ -830,12 +844,14 @@ XclExpChartObj::~XclExpChartObj()
 {
 }
 
-void XclExpChartObj::Save( XclExpStream& rStrm )
+void XclExpChartObj::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // content of OBJ record
     XclObj::Save( rStrm );
     // chart substream
     mxChart->Save( rStrm );
+#endif // xlsx
 }
 
 // ============================================================================
@@ -878,8 +894,9 @@ XclExpNote::XclExpNote( const XclExpRoot& rRoot, const ScAddress& rScPos,
     }
 }
 
-void XclExpNote::Save( XclExpStream& rStrm )
+void XclExpNote::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( rStrm.GetRoot().GetBiff() )
     {
         case EXC_BIFF5:
@@ -923,11 +940,13 @@ void XclExpNote::Save( XclExpStream& rStrm )
 
         default:    DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 
-void XclExpNote::WriteBody( XclExpStream& rStrm )
+void XclExpNote::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // BIFF5/BIFF7 is written separately
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() == EXC_BIFF8 );
 
@@ -940,6 +959,7 @@ void XclExpNote::WriteBody( XclExpStream& rStrm )
             << mnObjId
             << maAuthor
             << sal_uInt8( 0 );
+#endif // xlsx
 }
 
 void XclExpNote::WriteXml( sal_Int32 nAuthorId, XclExpXmlStream& rStrm )
@@ -976,10 +996,12 @@ XclMacroHelper::~XclMacroHelper()
 {
 }
 
-void XclMacroHelper::WriteMacroSubRec( XclExpStream& rStrm )
+void XclMacroHelper::WriteMacroSubRec( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mxMacroLink.is() )
         WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
+#endif // xlsx
 }
 
 bool 
@@ -1023,10 +1045,12 @@ XclExpShapeObj::~XclExpShapeObj()
 {
 }
 
-void XclExpShapeObj::WriteSubRecs( XclExpStream& rStrm )
+void XclExpShapeObj::WriteSubRecs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclObjAny::WriteSubRecs( rStrm );
     WriteMacroSubRec( rStrm );
+#endif // xlsx
 }
 
 // ============================================================================
diff --git sc/source/filter/xlsx/xlsx-xeformula.cxx sc/source/filter/xlsx/xlsx-xeformula.cxx
index 849ac08..7f71543 100644
--- sc/source/filter/xlsx/xlsx-xeformula.cxx
+++ sc/source/filter/xlsx/xlsx-xeformula.cxx
@@ -1835,7 +1835,7 @@ void XclExpFmlaCompImpl::ConvertRefData(
             rnScRow = mnMaxAbsRow;
         else if( (rnScRow < 0) || (rnScRow > mnMaxAbsRow) )
             rRefData.SetRowDeleted( TRUE );
-        rXclPos.mnRow = static_cast< sal_uInt16 >( rnScRow ) & mnMaxRowMask;
+        rXclPos.mnRow = static_cast< sal_uInt32 >( rnScRow ) & mnMaxRowMask;
     }
     else
     {
@@ -1847,7 +1847,7 @@ void XclExpFmlaCompImpl::ConvertRefData(
 
         // convert row index (2-step-cast ScsROW->sal_Int16->sal_uInt16 to get all bits correctly)
         sal_Int16 nXclRelRow = static_cast< sal_Int16 >( rRefData.IsRowRel() ? rRefData.nRelRow : rRefData.nRow );
-        rXclPos.mnRow = static_cast< sal_uInt16 >( nXclRelRow ) & mnMaxRowMask;
+        rXclPos.mnRow = static_cast< sal_uInt32 >( nXclRelRow ) & mnMaxRowMask;
 
         // resolve relative tab index if possible
         if( rRefData.IsTabRel() && !IsInGlobals() && (GetCurrScTab() < GetDoc().GetTableCount()) )
@@ -1863,9 +1863,11 @@ void XclExpFmlaCompImpl::ConvertRefData(
     }
     else
     {
+#if 0 // FIXME : doesn't build in xlsx
         sal_uInt16& rnRelField = (meBiff <= EXC_BIFF5) ? rXclPos.mnRow : rXclPos.mnCol;
         ::set_flag( rnRelField, EXC_TOK_REF_COLREL, rRefData.IsColRel() );
         ::set_flag( rnRelField, EXC_TOK_REF_ROWREL, rRefData.IsRowRel() );
+#endif
     }
 }
 
diff --git sc/source/filter/xlsx/xlsx-xehelper.cxx sc/source/filter/xlsx/xlsx-xehelper.cxx
index 54043ce..53bd290 100644
--- sc/source/filter/xlsx/xlsx-xehelper.cxx
+++ sc/source/filter/xlsx/xlsx-xehelper.cxx
@@ -159,7 +159,7 @@ namespace {
 inline void lclFillAddress( XclAddress& rXclPos, SCCOL nScCol, SCROW nScRow )
 {
     rXclPos.mnCol = static_cast< sal_uInt16 >( nScCol );
-    rXclPos.mnRow = static_cast< sal_uInt16 >( nScRow );
+    rXclPos.mnRow = static_cast< sal_uInt32 >( nScRow );
 }
 
 } // namespace
diff --git sc/source/filter/xlsx/xlsx-xename.cxx sc/source/filter/xlsx/xlsx-xename.cxx
index f04c4e4..6b3e91c 100644
--- sc/source/filter/xlsx/xlsx-xename.cxx
+++ sc/source/filter/xlsx/xlsx-xename.cxx
@@ -310,12 +310,14 @@ bool XclExpName::IsMacroCall( bool bVBasic, bool bFunc ) const
         (::get_flag( mnFlags, EXC_NAME_FUNC ) == bFunc);
 }
 
-void XclExpName::Save( XclExpStream& rStrm )
+void XclExpName::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( mxName.is() && (mxName->Len() > 0), "XclExpName::Save - missing name" );
     DBG_ASSERT( !(IsGlobal() && ::get_flag( mnFlags, EXC_NAME_BUILTIN )), "XclExpName::Save - global built-in name" );
     SetRecSize( 11 + mxName->GetSize() + (mxTokArr.is() ? mxTokArr->GetSize() : 2) );
     XclExpRecord::Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpName::SaveXml( XclExpXmlStream& rStrm )
@@ -346,8 +348,9 @@ void XclExpName::SaveXml( XclExpXmlStream& rStrm )
     rWorkbook->endElement( XML_definedName );
 }
 
-void XclExpName::WriteBody( XclExpStream& rStrm )
+void XclExpName::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nFmlaSize = mxTokArr.is() ? mxTokArr->GetSize() : 0;
 
     rStrm   << mnFlags                  // flags
@@ -361,6 +364,7 @@ void XclExpName::WriteBody( XclExpStream& rStrm )
     mxName->WriteBuffer( rStrm );       // character array of the name
     if( mxTokArr.is() )
         mxTokArr->WriteArray( rStrm );  // token array without size
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -467,9 +471,11 @@ const XclExpName* XclExpNameManagerImpl::GetName( sal_uInt16 nNameIdx ) const
     return maNameList.GetRecord( nNameIdx - 1 ).get();
 }
 
-void XclExpNameManagerImpl::Save( XclExpStream& rStrm )
+void XclExpNameManagerImpl::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maNameList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpNameManagerImpl::SaveXml( XclExpXmlStream& rStrm )
@@ -780,9 +786,11 @@ bool XclExpNameManager::IsVolatile( sal_uInt16 nNameIdx ) const
     return pName && pName->IsVolatile();
 }
 
-void XclExpNameManager::Save( XclExpStream& rStrm )
+void XclExpNameManager::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpNameManager::SaveXml( XclExpXmlStream& rStrm )
diff --git sc/source/filter/xlsx/xlsx-xepivot.cxx sc/source/filter/xlsx/xlsx-xepivot.cxx
index 66a885e..e509ce7 100644
--- sc/source/filter/xlsx/xlsx-xepivot.cxx
+++ sc/source/filter/xlsx/xlsx-xepivot.cxx
@@ -173,8 +173,9 @@ bool XclExpPCItem::EqualsBool( bool bValue ) const
 
 // ----------------------------------------------------------------------------
 
-void XclExpPCItem::WriteBody( XclExpStream& rStrm )
+void XclExpPCItem::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( const String* pText = GetText() )
     {
         rStrm << XclExpString( *pText );
@@ -207,6 +208,7 @@ void XclExpPCItem::WriteBody( XclExpStream& rStrm )
         // nothing to do for SXEMPTY
         DBG_ASSERT( IsEmpty(), "XclExpPCItem::WriteBody - no data found" );
     }
+#endif // xlsx
 }
 
 // ============================================================================
@@ -309,8 +311,9 @@ sal_Size XclExpPCField::GetIndexSize() const
     return Has16BitIndexes() ? 2 : 1;
 }
 
-void XclExpPCField::WriteIndex( XclExpStream& rStrm, sal_uInt32 nSrcRow ) const
+void XclExpPCField::WriteIndex( XclExpStream& /*rStrm*/, sal_uInt32 /*nSrcRow*/ ) const
 {
+#if 0 // xlsx
     // only standard fields write item indexes
     if( nSrcRow < maIndexVec.size() )
     {
@@ -320,10 +323,12 @@ void XclExpPCField::WriteIndex( XclExpStream& rStrm, sal_uInt32 nSrcRow ) const
         else
             rStrm << static_cast< sal_uInt8 >( nIndex );
     }
+#endif // xlsx
 }
 
-void XclExpPCField::Save( XclExpStream& rStrm )
+void XclExpPCField::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( IsSupportedField(), "XclExpPCField::Save - unknown field type" );
     // SXFIELD
     XclExpRecord::Save( rStrm );
@@ -337,6 +342,7 @@ void XclExpPCField::Save( XclExpStream& rStrm )
     WriteSxnumgroup( rStrm );
     // list of original items
     maOrigItemList.Save( rStrm );
+#endif // xlsx
 }
 
 // private --------------------------------------------------------------------
@@ -591,8 +597,9 @@ void XclExpPCField::Finalize()
     maFieldInfo.mnOrigItems = static_cast< sal_uInt16 >( maOrigItemList.GetSize() );
 }
 
-void XclExpPCField::WriteSxnumgroup( XclExpStream& rStrm )
+void XclExpPCField::WriteSxnumgroup( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( IsNumGroupField() || IsDateGroupField() )
     {
         // SXNUMGROUP record
@@ -605,10 +612,12 @@ void XclExpPCField::WriteSxnumgroup( XclExpStream& rStrm )
             "XclExpPCField::WriteSxnumgroup - missing numeric grouping limits" );
         maNumGroupLimits.Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpPCField::WriteSxgroupinfo( XclExpStream& rStrm )
+void XclExpPCField::WriteSxgroupinfo( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( IsStdGroupField() != maGroupOrder.empty(),
         "XclExpPCField::WriteSxgroupinfo - missing grouping info" );
     if( IsStdGroupField() && !maGroupOrder.empty() )
@@ -618,11 +627,14 @@ void XclExpPCField::WriteSxgroupinfo( XclExpStream& rStrm )
             rStrm << *aIt;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPCField::WriteBody( XclExpStream& rStrm )
+void XclExpPCField::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maFieldInfo;
+#endif // xlsx
 }
 
 // ============================================================================
@@ -726,8 +738,9 @@ bool XclExpPivotCache::HasEqualDataSource( const ScDPObject& rDPObj ) const
     return false;
 }
 
-void XclExpPivotCache::Save( XclExpStream& rStrm )
+void XclExpPivotCache::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( mbValid, "XclExpPivotCache::Save - invalid pivot cache" );
     // SXIDSTM
     XclExpUInt16Record( EXC_ID_SXIDSTM, maPCInfo.mnStrmId ).Save( rStrm );
@@ -737,6 +750,7 @@ void XclExpPivotCache::Save( XclExpStream& rStrm )
     WriteDconref( rStrm );
     // create the pivot cache storage stream
     WriteCacheStream();
+#endif // xlsx
 }
 
 void XclExpPivotCache::SaveXml( XclExpXmlStream& rStrm )
@@ -843,8 +857,9 @@ void XclExpPivotCache::AddCalcFields( const ScDPObject& /*rDPObj*/ )
     // not supported
 }
 
-void XclExpPivotCache::WriteDconref( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteDconref( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     XclExpString aRef( XclExpUrlHelper::EncodeUrl( GetRoot(), EMPTY_STRING, &maTabName ) );
     rStrm.StartRecord( EXC_ID_DCONREF, 7 + aRef.GetSize() );
     rStrm   << static_cast< sal_uInt16 >( maExpSrcRange.aStart.Row() )
@@ -854,10 +869,12 @@ void XclExpPivotCache::WriteDconref( XclExpStream& rStrm ) const
             << aRef
             << sal_uInt8( 0 );
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 void XclExpPivotCache::WriteCacheStream()
 {
+#if 0 // xlsx
     SotStorageRef xSvStrg = OpenStorage( EXC_STORAGE_PTCACHE );
     SotStorageStreamRef xSvStrm = OpenStream( xSvStrg, ScfTools::GetHexStr( maPCInfo.mnStrmId ) );
     if( xSvStrm.Is() )
@@ -874,25 +891,31 @@ void XclExpPivotCache::WriteCacheStream()
         // EOF
         XclExpEmptyRecord( EXC_ID_EOF ).Save( aStrm );
     }
+#endif // xlsx
 }
 
-void XclExpPivotCache::WriteSxdb( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteSxdb( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXDB, 21 );
     rStrm << maPCInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotCache::WriteSxdbex( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteSxdbex( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXDBEX, 12 );
     rStrm   << EXC_SXDBEX_CREATION_DATE
             << sal_uInt32( 0 );             // number of SXFORMULA records
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotCache::WriteSxindexlistList( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteSxindexlistList( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( HasItemIndexList() )
     {
         sal_Size nRecSize = 0;
@@ -908,6 +931,7 @@ void XclExpPivotCache::WriteSxindexlistList( XclExpStream& rStrm ) const
             rStrm.EndRecord();
         }
     }
+#endif // xlsx
 }
 
 // ============================================================================
@@ -986,9 +1010,11 @@ void XclExpPTItem::SetPropertiesFromMember( const ScDPSaveMember& rSaveMem )
         maItemInfo.SetVisName(*pVisName);
 }
 
-void XclExpPTItem::WriteBody( XclExpStream& rStrm )
+void XclExpPTItem::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maItemInfo;
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1191,13 +1217,16 @@ void XclExpPTField::AppendSubtotalItems()
 
 // records --------------------------------------------------------------------
 
-void XclExpPTField::WriteSxpiEntry( XclExpStream& rStrm ) const
+void XclExpPTField::WriteSxpiEntry( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm << maPageInfo;
+#endif // xlsx
 }
 
-void XclExpPTField::WriteSxdi( XclExpStream& rStrm, sal_uInt16 nDataInfoIdx ) const
+void XclExpPTField::WriteSxdi( XclExpStream& /*rStrm*/, sal_uInt16 /*nDataInfoIdx*/ ) const
 {
+#if 0 // xlsx
     DBG_ASSERT( nDataInfoIdx < maDataInfoVec.size(), "XclExpPTField::WriteSxdi - data field not found" );
     if( nDataInfoIdx < maDataInfoVec.size() )
     {
@@ -1205,16 +1234,19 @@ void XclExpPTField::WriteSxdi( XclExpStream& rStrm, sal_uInt16 nDataInfoIdx ) co
         rStrm << maDataInfoVec[ nDataInfoIdx ];
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPTField::Save( XclExpStream& rStrm )
+void XclExpPTField::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // SXVD
     WriteSxvd( rStrm );
     // list of SXVI records
     maItemList.Save( rStrm );
     // SXVDEX
     WriteSxvdex( rStrm );
+#endif // xlsx
 }
 
 // private --------------------------------------------------------------------
@@ -1234,18 +1266,22 @@ void XclExpPTField::AppendSubtotalItem( sal_uInt16 nItemType )
     ++maFieldInfo.mnItemCount;
 }
 
-void XclExpPTField::WriteSxvd( XclExpStream& rStrm ) const
+void XclExpPTField::WriteSxvd( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXVD, 10 );
     rStrm << maFieldInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPTField::WriteSxvdex( XclExpStream& rStrm ) const
+void XclExpPTField::WriteSxvdex( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXVDEX, 20 );
     rStrm << maFieldExtInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1329,8 +1365,9 @@ sal_uInt16 XclExpPivotTable::GetDataFieldIndex( const String& rName, sal_uInt16
     return nDefaultIdx;
 }
 
-void XclExpPivotTable::Save( XclExpStream& rStrm )
+void XclExpPivotTable::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mbValid )
     {
         // SXVIEW
@@ -1354,6 +1391,7 @@ void XclExpPivotTable::Save( XclExpStream& rStrm )
         // SXVIEWEX9
         WriteSxViewEx9( rStrm );
     }
+#endif // xlsx
 }
 
 void XclExpPivotTable::SaveXml( XclExpXmlStream& rStrm )
@@ -1626,9 +1664,9 @@ void XclExpPivotTable::Finalize()
 
     // update output range (initialized in ctor)
     sal_uInt16& rnXclCol1 = maPTInfo.maOutXclRange.maFirst.mnCol;
-    sal_uInt16& rnXclRow1 = maPTInfo.maOutXclRange.maFirst.mnRow;
+    sal_uInt32& rnXclRow1 = maPTInfo.maOutXclRange.maFirst.mnRow;
     sal_uInt16& rnXclCol2 = maPTInfo.maOutXclRange.maLast.mnCol;
-    sal_uInt16& rnXclRow2 = maPTInfo.maOutXclRange.maLast.mnRow;
+    sal_uInt32& rnXclRow2 = maPTInfo.maOutXclRange.maLast.mnRow;
     // exclude page fields from output range
     rnXclRow1 = rnXclRow1 + maPTInfo.mnPageFields;
     // exclude filter button from output range
@@ -1640,7 +1678,7 @@ void XclExpPivotTable::Finalize()
 
     // data area
     sal_uInt16& rnDataXclCol = maPTInfo.maDataXclPos.mnCol;
-    sal_uInt16& rnDataXclRow = maPTInfo.maDataXclPos.mnRow;
+    sal_uInt32& rnDataXclRow = maPTInfo.maDataXclPos.mnRow;
     rnDataXclCol = rnXclCol1 + maPTInfo.mnRowFields;
     rnDataXclRow = rnXclRow1 + maPTInfo.mnColFields + 1;
     if( maDataFields.empty() )
@@ -1664,15 +1702,18 @@ void XclExpPivotTable::Finalize()
 
 // records ----------------------------------------------------------------
 
-void XclExpPivotTable::WriteSxview( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxview( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXVIEW, 46 + maPTInfo.maTableName.Len() + maPTInfo.maDataName.Len() );
     rStrm << maPTInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxivd( XclExpStream& rStrm, const ScfUInt16Vec& rFields ) const
+void XclExpPivotTable::WriteSxivd( XclExpStream& /*rStrm*/, const ScfUInt16Vec& /*rFields*/ ) const
 {
+#if 0 // xlsx
     if( !rFields.empty() )
     {
         rStrm.StartRecord( EXC_ID_SXIVD, rFields.size() * 2 );
@@ -1680,10 +1721,12 @@ void XclExpPivotTable::WriteSxivd( XclExpStream& rStrm, const ScfUInt16Vec& rFie
             rStrm << *aIt;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxpi( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxpi( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( !maPageFields.empty() )
     {
         rStrm.StartRecord( EXC_ID_SXPI, maPageFields.size() * 6 );
@@ -1696,20 +1739,24 @@ void XclExpPivotTable::WriteSxpi( XclExpStream& rStrm ) const
         }
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxdiList( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxdiList( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     for( XclPTDataFieldPosVec::const_iterator aIt = maDataFields.begin(), aEnd = maDataFields.end(); aIt != aEnd; ++aIt )
     {
         XclExpPTFieldRef xField = maFieldList.GetRecord( aIt->first );
         if( xField.is() )
             xField->WriteSxdi( rStrm, aIt->second );
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxli( XclExpStream& rStrm, sal_uInt16 nLineCount, sal_uInt16 nIndexCount ) const
+void XclExpPivotTable::WriteSxli( XclExpStream& /*rStrm*/, sal_uInt16 /*nLineCount*/, sal_uInt16 /*nIndexCount*/ ) const
 {
+#if 0 // xlsx
     if( nLineCount > 0 )
     {
         sal_uInt16 nLineSize = 8 + 2 * nIndexCount;
@@ -1730,17 +1777,21 @@ void XclExpPivotTable::WriteSxli( XclExpStream& rStrm, sal_uInt16 nLineCount, sa
         }
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxex( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxex( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXEX, 24 );
     rStrm << maPTExtInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteQsiSxTag( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteQsiSxTag( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( 0x0802, 32 );
 
     sal_uInt16 nRecordType = 0x0802;
@@ -1791,10 +1842,12 @@ void XclExpPivotTable::WriteQsiSxTag( XclExpStream& rStrm ) const
     rStrm << static_cast<sal_uInt16>(0x0001); // no idea what this is for.
 
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxViewEx9( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxViewEx9( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     // Until we sync the autoformat ids only export if using grid header layout
     // That could only have been set via xls import so far.
     if ( 0 == maPTViewEx9Info.mnGridLayout )
@@ -1803,6 +1856,7 @@ void XclExpPivotTable::WriteSxViewEx9( XclExpStream& rStrm ) const
         rStrm << maPTViewEx9Info;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1829,12 +1883,14 @@ XclExpPivotRecWrapper::XclExpPivotRecWrapper( XclExpPivotTableManager& rPTMgr, S
 {
 }
 
-void XclExpPivotRecWrapper::Save( XclExpStream& rStrm )
+void XclExpPivotRecWrapper::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mnScTab == EXC_PTMGR_PIVOTCACHES )
         mrPTMgr.WritePivotCaches( rStrm );
     else
         mrPTMgr.WritePivotTables( rStrm, mnScTab );
+#endif // xlsx
 }
 
 void XclExpPivotRecWrapper::SaveXml( XclExpXmlStream& rStrm )
@@ -1874,9 +1930,11 @@ XclExpRecordRef XclExpPivotTableManager::CreatePivotTablesRecord( SCTAB nScTab )
     return XclExpRecordRef( new XclExpPivotRecWrapper( *this, nScTab ) );
 }
 
-void XclExpPivotTableManager::WritePivotCaches( XclExpStream& rStrm )
+void XclExpPivotTableManager::WritePivotCaches( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maPCacheList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpPivotTableManager::WritePivotCachesXml( XclExpXmlStream& rStrm )
@@ -1892,14 +1950,16 @@ void XclExpPivotTableManager::WritePivotCachesXml( XclExpXmlStream& rStrm )
 #endif /* XLSX_PIVOT_CACHE */
 }
 
-void XclExpPivotTableManager::WritePivotTables( XclExpStream& rStrm, SCTAB nScTab )
+void XclExpPivotTableManager::WritePivotTables( XclExpStream& /*rStrm*/, SCTAB /*nScTab*/ )
 {
+#if 0 // xlsx
     for( size_t nPos = 0, nSize = maPTableList.GetSize(); nPos < nSize; ++nPos )
     {
         XclExpPivotTableRef xPTable = maPTableList.GetRecord( nPos );
         if( xPTable->GetScTab() == nScTab )
             xPTable->Save( rStrm );
     }
+#endif // xlsx
 }
 
 void XclExpPivotTableManager::WritePivotTablesXml( XclExpXmlStream& rStrm, SCTAB nScTab )
diff --git sc/source/filter/xlsx/xlsx-xestream.cxx sc/source/filter/xlsx/xlsx-xestream.cxx
index e79283b..97a3639 100644
--- sc/source/filter/xlsx/xlsx-xestream.cxx
+++ sc/source/filter/xlsx/xlsx-xestream.cxx
@@ -820,8 +862,9 @@ static ScAddress lcl_ToAddress( const XclAddress& rAddress )
     // For some reason, ScRange::Format() returns omits row numbers if
     // the row is >= MAXROW or the column is >= MAXCOL, and Excel doesn't
     // like "A:IV" (i.e. no row numbers).  Prevent this.
-    aAddress.SetRow( std::min<sal_Int32>( rAddress.mnRow, MAXROW-1 ) );
-    aAddress.SetCol( static_cast<sal_Int16>(std::min<sal_Int32>( rAddress.mnCol, MAXCOL-1 )) );
+    // KOHEI: Find out if the above comment is still true.
+    aAddress.SetRow( std::min<sal_Int32>( rAddress.mnRow, MAXROW ) );
+    aAddress.SetCol( static_cast<sal_Int16>(std::min<sal_Int32>( rAddress.mnCol, MAXCOL )) );
 
     return aAddress;
 }
@@ -1134,6 +1178,11 @@ bool XclExpXmlStream::exportDocument() throw()
 
     XclExpRootData aData( EXC_BIFF8, *pShell->GetMedium (), rStorage, *pDoc, RTL_TEXTENCODING_DONTKNOW );
     aData.meOutput = EXC_OUTPUT_XML_2007;
+    aData.maXclMaxPos.Set( EXC_MAXCOL_XML_2007, EXC_MAXROW_XML_2007, EXC_MAXTAB_XML_2007 );
+    aData.maMaxPos.SetCol( ::std::min( aData.maScMaxPos.Col(), aData.maXclMaxPos.Col() ) );
+    aData.maMaxPos.SetRow( ::std::min( aData.maScMaxPos.Row(), aData.maXclMaxPos.Row() ) );
+    aData.maMaxPos.SetTab( ::std::min( aData.maScMaxPos.Tab(), aData.maXclMaxPos.Tab() ) );
+
     XclExpRoot aRoot( aData );
 
     mpRoot = &aRoot;
diff --git sc/source/filter/xlsx/xlsx-xestyle.cxx sc/source/filter/xlsx/xlsx-xestyle.cxx
index d3cecdc..3ce16a0 100644
--- sc/source/filter/xlsx/xlsx-xestyle.cxx
+++ sc/source/filter/xlsx/xlsx-xestyle.cxx
@@ -496,11 +496,13 @@ bool XclExpPaletteImpl::IsDefaultPalette() const
     return bDefault;
 }
 
-void XclExpPaletteImpl::WriteBody( XclExpStream& rStrm )
+void XclExpPaletteImpl::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << static_cast< sal_uInt16 >( maPalette.size() );
     for( XclPaletteColorVec::const_iterator aIt = maPalette.begin(), aEnd = maPalette.end(); aIt != aEnd; ++aIt )
         rStrm << aIt->maColor;
+#endif // xlsx
 }
 
 void XclExpPaletteImpl::SaveXml( XclExpXmlStream& rStrm )
@@ -803,10 +805,12 @@ ColorData XclExpPalette::GetColorData( sal_uInt16 nXclIndex ) const
     return mxImpl->GetColorData( nXclIndex );
 }
 
-void XclExpPalette::Save( XclExpStream& rStrm )
+void XclExpPalette::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( !mxImpl->IsDefaultPalette() )
         XclExpRecord::Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpPalette::SaveXml( XclExpXmlStream& rStrm )
@@ -815,9 +819,11 @@ void XclExpPalette::SaveXml( XclExpXmlStream& rStrm )
         mxImpl->SaveXml( rStrm );
 }
 
-void XclExpPalette::WriteBody( XclExpStream& rStrm )
+void XclExpPalette::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->WriteBody( rStrm );
+#endif // xlsx
 }
 
 // FONT record - font information =============================================
@@ -876,8 +882,9 @@ void XclExpFont::SaveXml( XclExpXmlStream& rStrm )
 
 // private --------------------------------------------------------------------
 
-void XclExpFont::WriteBody( XclExpStream& rStrm )
+void XclExpFont::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nAttr = EXC_FONTATTR_NONE;
     ::set_flag( nAttr, EXC_FONTATTR_ITALIC, maData.mbItalic );
     ::set_flag( nAttr, EXC_FONTATTR_STRIKEOUT, maData.mbStrikeout );
@@ -901,6 +908,7 @@ void XclExpFont::WriteBody( XclExpStream& rStrm )
             << maData.mnCharSet
             << sal_uInt8( 0 )
             << aFontName;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1003,9 +1011,11 @@ sal_uInt16 XclExpFontBuffer::Insert( const ScPatternAttr& rPattern,
     return Insert( rPattern.GetItemSet(), nScript, eColorType, bAppFont );
 }
 
-void XclExpFontBuffer::Save( XclExpStream& rStrm )
+void XclExpFontBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maFontList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpFontBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -1226,10 +1236,12 @@ sal_uInt16 XclExpNumFmtBuffer::Insert( ULONG nScNumFmt )
     return 0;
 }
 
-void XclExpNumFmtBuffer::Save( XclExpStream& rStrm )
+void XclExpNumFmtBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     for( XclExpNumFmtVec::const_iterator aIt = maFormatMap.begin(), aEnd = maFormatMap.end(); aIt != aEnd; ++aIt )
         WriteFormatRecord( rStrm, *aIt );
+#endif // xlsx
 }
 
 void XclExpNumFmtBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -1251,8 +1263,9 @@ void XclExpNumFmtBuffer::SaveXml( XclExpXmlStream& rStrm )
     rStyleSheet->endElement( XML_numFmts );
 }
 
-void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& rStrm, sal_uInt16 nXclNumFmt, const String& rFormatStr )
+void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& /*rStrm*/, sal_uInt16 /*nXclNumFmt*/, const String& /*rFormatStr*/ )
 {
+#if 0 // xlsx
     XclExpString aExpStr;
     if( GetBiff() <= EXC_BIFF5 )
         aExpStr.AssignByte( rFormatStr, GetTextEncoding(), EXC_STR_8BITLENGTH );
@@ -1262,11 +1275,14 @@ void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& rStrm, sal_uInt16 nXcl
     rStrm.StartRecord( EXC_ID4_FORMAT, 2 + aExpStr.GetSize() );
     rStrm << nXclNumFmt << aExpStr;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& rStrm, const XclExpNumFmt& rFormat )
+void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& /*rStrm*/, const XclExpNumFmt& /*rFormat*/ )
 {
+#if 0 // xlsx
     WriteFormatRecord( rStrm, rFormat.mnXclNumFmt, GetFormatCode( rFormat ) );
+#endif // xlsx
 }
 
 String XclExpNumFmtBuffer::GetFormatCode( const XclExpNumFmt& rFormat )
@@ -1990,8 +2006,9 @@ sal_uInt8 XclExpXF::GetUsedFlags() const
     return nUsedFlags;
 }
 
-void XclExpXF::WriteBody5( XclExpStream& rStrm )
+void XclExpXF::WriteBody5( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nTypeProt = 0, nAlign = 0;
     sal_uInt32 nArea = 0, nBorder = 0;
 
@@ -2005,10 +2022,12 @@ void XclExpXF::WriteBody5( XclExpStream& rStrm )
     maArea.FillToXF5( nArea );
 
     rStrm << mnXclFont << mnXclNumFmt << nTypeProt << nAlign << nArea << nBorder;
+#endif // xlsx
 }
 
-void XclExpXF::WriteBody8( XclExpStream& rStrm )
+void XclExpXF::WriteBody8( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nTypeProt = 0, nAlign = 0, nMiscAttrib = 0, nArea = 0;
     sal_uInt32 nBorder1 = 0, nBorder2 = 0;
 
@@ -2022,10 +2041,12 @@ void XclExpXF::WriteBody8( XclExpStream& rStrm )
     maArea.FillToXF8( nBorder2, nArea );
 
     rStrm << mnXclFont << mnXclNumFmt << nTypeProt << nAlign << nMiscAttrib << nBorder1 << nBorder2 << nArea;
+#endif // xlsx
 }
 
-void XclExpXF::WriteBody( XclExpStream& rStrm )
+void XclExpXF::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclExpXFId aParentId( mnParentXFId );
     aParentId.ConvertXFIndex( GetRoot() );
     mnParent = aParentId.mnXFIndex;
@@ -2035,6 +2056,7 @@ void XclExpXF::WriteBody( XclExpStream& rStrm )
         case EXC_BIFF8: WriteBody8( rStrm );    break;
         default:        DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 void XclExpXF::SetXmlIds( sal_uInt32 nBorderId, sal_uInt32 nFillId )
@@ -2164,8 +2186,9 @@ XclExpStyle::XclExpStyle( sal_uInt32 nXFId, sal_uInt8 nStyleId, sal_uInt8 nLevel
 {
 }
 
-void XclExpStyle::WriteBody( XclExpStream& rStrm )
+void XclExpStyle::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maXFId.ConvertXFIndex( rStrm.GetRoot() );
     ::set_flag( maXFId.mnXFIndex, EXC_STYLE_BUILTIN, IsBuiltIn() );
     rStrm << maXFId.mnXFIndex;
@@ -2183,6 +2206,7 @@ void XclExpStyle::WriteBody( XclExpStream& rStrm )
             aNameEx.AssignByte( maName, rStrm.GetRoot().GetTextEncoding(), EXC_STR_8BITLENGTH );
         rStrm << aNameEx;
     }
+#endif // xlsx
 }
 
 static const char* lcl_StyleNameFromId( sal_Int32 nStyleId )
@@ -2471,12 +2495,14 @@ sal_Int32 XclExpXFBuffer::GetXmlCellIndex( sal_uInt32 nXFIndex ) const
     return maCellIndexes[ nXFIndex ];
 }
 
-void XclExpXFBuffer::Save( XclExpStream& rStrm )
+void XclExpXFBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // save all XF records contained in the maSortedXFList vector (sorted by XF index)
     maSortedXFList.Save( rStrm );
     // save all STYLE records
     maStyleList.Save( rStrm );
+#endif // xlsx
 }
 
 static void lcl_GetCellCounts( const XclExpRecordList< XclExpXF >& rXFList, sal_Int32& rCells, sal_Int32& rStyles )
diff --git sc/source/filter/xlsx/xlsx-xetable.cxx sc/source/filter/xlsx/xlsx-xetable.cxx
index 9b73ef5..36de8e5 100644
--- sc/source/filter/xlsx/xlsx-xetable.cxx
+++ sc/source/filter/xlsx/xlsx-xetable.cxx
@@ -67,9 +67,11 @@ XclExpStringRec::XclExpStringRec( const XclExpRoot& rRoot, const String& rResult
     SetRecSize( mxResult->GetSize() );
 }
 
-void XclExpStringRec::WriteBody( XclExpStream& rStrm )
+void XclExpStringRec::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << *mxResult;
+#endif // xlsx
 }
 
 // Additional records for special formula ranges ==============================
@@ -98,7 +100,7 @@ XclExpRangeFmlaBase::XclExpRangeFmlaBase(
     maBaseXclPos = maXclRange.maFirst;
 }
 
-bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
+bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const
 {
     return (maBaseXclPos.mnCol == nXclCol) && (maBaseXclPos.mnRow == nXclRow);
 }
@@ -106,16 +108,18 @@ bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) co
 void XclExpRangeFmlaBase::Extend( const ScAddress& rScPos )
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( rScPos.Col() );
-    sal_uInt16 nXclRow = static_cast< sal_uInt16 >( rScPos.Row() );
+    sal_uInt32 nXclRow = static_cast< sal_uInt32 >( rScPos.Row() );
     maXclRange.maFirst.mnCol = ::std::min( maXclRange.maFirst.mnCol, nXclCol );
     maXclRange.maFirst.mnRow = ::std::min( maXclRange.maFirst.mnRow, nXclRow );
     maXclRange.maLast.mnCol  = ::std::max( maXclRange.maLast.mnCol,  nXclCol );
     maXclRange.maLast.mnRow  = ::std::max( maXclRange.maLast.mnRow,  nXclRow );
 }
 
-void XclExpRangeFmlaBase::WriteRangeAddress( XclExpStream& rStrm ) const
+void XclExpRangeFmlaBase::WriteRangeAddress( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     maXclRange.Write( rStrm, false );
+#endif // xlsx
 }
 
 // Array formulas =============================================================
@@ -136,12 +140,14 @@ bool XclExpArray::IsVolatile() const
     return mxTokArr->IsVolatile();
 }
 
-void XclExpArray::WriteBody( XclExpStream& rStrm )
+void XclExpArray::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteRangeAddress( rStrm );
     sal_uInt16 nFlags = EXC_ARRAY_DEFAULTFLAGS;
     ::set_flag( nFlags, EXC_ARRAY_RECALC_ALWAYS, IsVolatile() );
     rStrm << nFlags << sal_uInt32( 0 ) << *mxTokArr;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -206,10 +212,12 @@ bool XclExpShrfmla::IsVolatile() const
     return mxTokArr->IsVolatile();
 }
 
-void XclExpShrfmla::WriteBody( XclExpStream& rStrm )
+void XclExpShrfmla::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteRangeAddress( rStrm );
     rStrm << sal_uInt8( 0 ) << mnUsedCount << *mxTokArr;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -367,10 +375,12 @@ bool XclExpTableop::IsVolatile() const
     return true;
 }
 
-void XclExpTableop::Save( XclExpStream& rStrm )
+void XclExpTableop::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mbValid )
         XclExpRangeFmlaBase::Save( rStrm );
+#endif // xlsx
 }
 
 bool XclExpTableop::IsAppendable( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
@@ -380,8 +390,9 @@ bool XclExpTableop::IsAppendable( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
             ((mnLastAppXclCol == maXclRange.maLast.mnCol) && (nXclCol == maXclRange.maFirst.mnCol) && (nXclRow == maXclRange.maLast.mnRow + 1));
 }
 
-void XclExpTableop::WriteBody( XclExpStream& rStrm )
+void XclExpTableop::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nFlags = EXC_TABLEOP_DEFAULTFLAGS;
     ::set_flag( nFlags, EXC_TABLEOP_RECALC_ALWAYS, IsVolatile() );
     switch( mnScMode )
@@ -396,6 +407,7 @@ void XclExpTableop::WriteBody( XclExpStream& rStrm )
         rStrm << mnRowInpXclRow << mnRowInpXclCol << mnColInpXclRow << mnColInpXclCol;
     else
         rStrm << mnColInpXclRow << mnColInpXclCol << sal_uInt32( 0 );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -559,17 +571,21 @@ void XclExpSingleCellBase::ConvertXFIndexes( const XclExpRoot& rRoot )
     maXFId.ConvertXFIndex( rRoot );
 }
 
-void XclExpSingleCellBase::Save( XclExpStream& rStrm )
+void XclExpSingleCellBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF3 );
     AddRecSize( mnContSize );
     XclExpCellBase::Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpSingleCellBase::WriteBody( XclExpStream& rStrm )
+void XclExpSingleCellBase::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << GetXclRow() << GetXclCol() << maXFId.mnXFIndex;
     WriteContents( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -613,9 +629,11 @@ void XclExpNumberCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpNumberCell::WriteContents( XclExpStream& rStrm )
+void XclExpNumberCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << mfValue;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -646,9 +664,11 @@ void XclExpBooleanCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpBooleanCell::WriteContents( XclExpStream& rStrm )
+void XclExpBooleanCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << sal_uInt16( mbValue ? 1 : 0 ) << EXC_BOOLERR_BOOL;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -775,8 +795,9 @@ void XclExpLabelCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpLabelCell::WriteContents( XclExpStream& rStrm )
+void XclExpLabelCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( rStrm.GetRoot().GetBiff() )
     {
         case EXC_BIFF5:
@@ -792,6 +813,7 @@ void XclExpLabelCell::WriteContents( XclExpStream& rStrm )
         break;
         default:    DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -898,8 +920,9 @@ XclExpFormulaCell::XclExpFormulaCell(
         mxTokArr = rRoot.GetFormulaCompiler().CreateFormula( EXC_FMLATYPE_CELL, rScTokArr, &aScPos );
 }
 
-void XclExpFormulaCell::Save( XclExpStream& rStrm )
+void XclExpFormulaCell::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // create token array for FORMULA cells with additional record
     if( mxAddRec.is() )
         mxTokArr = mxAddRec->CreateCellTokenArray( rStrm.GetRoot() );
@@ -918,6 +941,7 @@ void XclExpFormulaCell::Save( XclExpStream& rStrm )
     // STRING record for string result
     if( mxStringRec.is() )
         mxStringRec->Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpFormulaCell::SaveXml( XclExpXmlStream& rStrm )
@@ -967,8 +991,9 @@ void XclExpFormulaCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpFormulaCell::WriteContents( XclExpStream& rStrm )
+void XclExpFormulaCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // result of the formula
     switch( mrScFmlaCell.GetFormatType() )
     {
@@ -1019,6 +1044,7 @@ void XclExpFormulaCell::WriteContents( XclExpStream& rStrm )
     ::set_flag( nFlags, EXC_FORMULA_RECALC_ALWAYS, mxTokArr->IsVolatile() || (mxAddRec.is() && mxAddRec->IsVolatile()) );
     ::set_flag( nFlags, EXC_FORMULA_SHARED, mxAddRec.is() && (mxAddRec->GetRecId() == EXC_ID_SHRFMLA) );
     rStrm << nFlags << sal_uInt32( 0 ) << *mxTokArr;
+#endif // xlsx
 }
 
 // Multiple cell records ======================================================
@@ -1052,8 +1078,9 @@ void XclExpMultiCellBase::ConvertXFIndexes( const XclExpRoot& rRoot )
         aIt->ConvertXFIndex( rRoot );
 }
 
-void XclExpMultiCellBase::Save( XclExpStream& rStrm )
+void XclExpMultiCellBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF3 );
 
     XclExpMultiXFIdDeq::const_iterator aEnd = maXFIds.end();
@@ -1107,6 +1134,7 @@ void XclExpMultiCellBase::Save( XclExpStream& rStrm )
             rStrm.EndRecord();
         }
     }
+#endif // xlsx
 }
 
 void XclExpMultiCellBase::SaveXml( XclExpXmlStream& rStrm )
@@ -1321,10 +1349,12 @@ void XclExpRkCell::WriteXmlContents( XclExpXmlStream& rStrm, const XclAddress& r
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpRkCell::WriteContents( XclExpStream& rStrm, sal_uInt16 nRelCol )
+void XclExpRkCell::WriteContents( XclExpStream& /*rStrm*/, sal_uInt16 /*nRelCol*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( nRelCol < maRkValues.size(), "XclExpRkCell::WriteContents - overflow error" );
     rStrm << maRkValues[ nRelCol ];
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1421,9 +1451,11 @@ XclExpGuts::XclExpGuts( const XclExpRoot& rRoot ) :
     }
 }
 
-void XclExpGuts::WriteBody( XclExpStream& rStrm )
+void XclExpGuts::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << mnRowWidth << mnColWidth << mnRowLevels << mnColLevels;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1472,8 +1504,9 @@ void XclExpDimensions::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpDimensions::WriteBody( XclExpStream& rStrm )
+void XclExpDimensions::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclBiff eBiff = rStrm.GetRoot().GetBiff();
     if( eBiff == EXC_BIFF8 )
         rStrm << mnFirstUsedXclRow << mnFirstFreeXclRow;
@@ -1482,6 +1515,7 @@ void XclExpDimensions::WriteBody( XclExpStream& rStrm )
     rStrm << mnFirstUsedXclCol << mnFirstFreeXclCol;
     if( eBiff >= EXC_BIFF3 )
         rStrm << sal_uInt16( 0 );
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1572,8 +1606,9 @@ bool XclExpColinfo::TryMerge( const XclExpColinfo& rColInfo )
     return false;
 }
 
-void XclExpColinfo::WriteBody( XclExpStream& rStrm )
+void XclExpColinfo::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // if last column is equal to last possible column, Excel adds one more
     sal_uInt16 nLastXclCol = mnLastXclCol;
     if( nLastXclCol == static_cast< sal_uInt16 >( rStrm.GetRoot().GetMaxPos().Col() ) )
@@ -1585,6 +1620,7 @@ void XclExpColinfo::WriteBody( XclExpStream& rStrm )
             << maXFId.mnXFIndex
             << mnFlags
             << sal_uInt16( 0 );
+#endif // xlsx
 }
 
 void XclExpColinfo::SaveXml( XclExpXmlStream& rStrm )
@@ -1684,12 +1720,14 @@ void XclExpColinfoBuffer::Finalize( ScfUInt16Vec& rXFIndexes )
     }
 }
 
-void XclExpColinfoBuffer::Save( XclExpStream& rStrm )
+void XclExpColinfoBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // DEFCOLWIDTH
     maDefcolwidth.Save( rStrm );
     // COLINFO records
     maColInfos.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpColinfoBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -1738,15 +1776,17 @@ void XclExpDefrowheight::SetDefaultData( const XclExpDefaultRowData& rDefData )
     maDefData = rDefData;
 }
 
-void XclExpDefrowheight::WriteBody( XclExpStream& rStrm )
+void XclExpDefrowheight::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF3 );
     rStrm << maDefData.mnFlags << maDefData.mnHeight;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
 
-XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
+XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt32 nXclRow,
         XclExpRowOutlineBuffer& rOutlineBfr, bool bAlwaysEmpty ) :
     XclExpRecord( EXC_ID3_ROW, 16 ),
     XclExpRoot( rRoot ),
@@ -1968,16 +2008,20 @@ void XclExpRow::DisableIfDefault( const XclExpDefaultRowData& rDefRowData )
         (IsUnsynced() != rDefRowData.IsUnsynced());
 }
 
-void XclExpRow::WriteCellList( XclExpStream& rStrm )
+void XclExpRow::WriteCellList( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( mbEnabled || maCellList.IsEmpty(), "XclExpRow::WriteCellList - cells in disabled row" );
     maCellList.Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpRow::Save( XclExpStream& rStrm )
+void XclExpRow::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mbEnabled )
         XclExpRecord::Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpRow::InsertCell( XclExpCellRef xCell, size_t nPos, bool bIsMergedBase )
@@ -2004,8 +2048,9 @@ void XclExpRow::InsertCell( XclExpCellRef xCell, size_t nPos, bool bIsMergedBase
         maCellList.RemoveRecord( nPos );
 }
 
-void XclExpRow::WriteBody( XclExpStream& rStrm )
+void XclExpRow::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << mnXclRow
             << GetFirstUsedXclCol()
             << GetFirstFreeXclCol()
@@ -2013,6 +2058,7 @@ void XclExpRow::WriteBody( XclExpStream& rStrm )
             << sal_uInt32( 0 )
             << mnFlags
             << mnXFIndex;
+#endif // xlsx
 }
 
 void XclExpRow::SaveXml( XclExpXmlStream& rStrm )
@@ -2091,7 +2137,7 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         #i59220# Tolerance of +-128 rows for inserted/removed rows. */
     if( (nDefaultXclRow < 31872) || (nDefaultXclRow > 32128) )
     {
-        sal_uInt16 nLastXclRow = static_cast< sal_uInt16 >( GetMaxPos().Row() );
+        sal_uInt32 nLastXclRow = static_cast< sal_uInt32 >( GetMaxPos().Row() );
         if( nDefaultXclRow <= nLastXclRow )
         {
             // create a dummy ROW record and fill aMaxDefData
@@ -2153,7 +2199,7 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         // find used row range
         if( xRow->IsEnabled() )
         {
-            sal_uInt16 nXclRow = xRow->GetXclRow();
+            sal_uInt32 nXclRow = xRow->GetXclRow();
             nFirstUsedXclRow = ::std::min< sal_uInt32 >( nFirstUsedXclRow, nXclRow );
             nFirstFreeXclRow = ::std::max< sal_uInt32 >( nFirstFreeXclRow, nXclRow + 1 );
         }
@@ -2168,8 +2214,9 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         nFirstUsedXclCol, nFirstUsedXclRow, nFirstFreeXclCol, nFirstFreeXclRow );
 }
 
-void XclExpRowBuffer::Save( XclExpStream& rStrm )
+void XclExpRowBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // DIMENSIONS record
     maDimensions.Save( rStrm );
 
@@ -2197,6 +2244,7 @@ void XclExpRowBuffer::Save( XclExpStream& rStrm )
         nBlockStart = nBlockEnd;
         nStartXclRow += EXC_ROW_ROWBLOCKSIZE;
     }
+#endif // xlsx
 }
 
 void XclExpRowBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -2226,7 +2274,7 @@ XclExpDimensions* XclExpRowBuffer::GetDimensions()
     return &maDimensions;
 }
 
-XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysEmpty )
+XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt32 nXclRow, bool bRowAlwaysEmpty )
 {
     if( !mpLastUsedRow || (mnLastUsedXclRow != nXclRow) )
     {
@@ -2234,7 +2282,7 @@ XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysE
         // do not use sal_uInt16 for nFirstFreeXclRow, would cause loop in full sheets
         for( size_t nFirstFreeXclRow = maRowList.GetSize(); nFirstFreeXclRow <= nXclRow; ++nFirstFreeXclRow )
             maRowList.AppendNewRecord( new XclExpRow(
-                GetRoot(), static_cast< sal_uInt16 >( nFirstFreeXclRow ), maOutlineBfr, bRowAlwaysEmpty ) );
+                GetRoot(), static_cast< sal_uInt32 >( nFirstFreeXclRow ), maOutlineBfr, bRowAlwaysEmpty ) );
 
         mpLastUsedRow = maRowList.GetRecord( nXclRow ).get();
         mnLastUsedXclRow = nXclRow;
@@ -2319,7 +2367,7 @@ XclExpCellTable::XclExpCellTable( const XclExpRoot& rRoot ) :
         SCCOL nLastScCol = aIt.GetEndCol();
         ScAddress aScPos( nScCol, nScRow, nScTab );
 
-        XclAddress aXclPos( static_cast< sal_uInt16 >( nScCol ), static_cast< sal_uInt16 >( nScRow ) );
+        XclAddress aXclPos( static_cast< sal_uInt16 >( nScCol ), static_cast< sal_uInt32 >( nScRow ) );
         sal_uInt16 nLastXclCol = static_cast< sal_uInt16 >( nLastScCol );
 
         const ScBaseCell* pScCell = aIt.GetCell();
@@ -2506,12 +2554,14 @@ XclExpRecordRef XclExpCellTable::CreateRecord( sal_uInt16 nRecId ) const
     return xRec;
 }
 
-void XclExpCellTable::Save( XclExpStream& rStrm )
+void XclExpCellTable::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // DEFCOLWIDTH and COLINFOs
     maColInfoBfr.Save( rStrm );
     // ROWs and cell records
     maRowBfr.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpCellTable::SaveXml( XclExpXmlStream& rStrm )
diff --git sc/source/filter/xlsx/xlsx-xeview.cxx sc/source/filter/xlsx/xlsx-xeview.cxx
index d15634b..8b983a1 100644
--- sc/source/filter/xlsx/xlsx-xeview.cxx
+++ sc/source/filter/xlsx/xlsx-xeview.cxx
@@ -79,8 +79,9 @@ void XclExpWindow1::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpWindow1::WriteBody( XclExpStream& rStrm )
+void XclExpWindow1::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     const XclExpTabInfo& rTabInfo = rStrm.GetRoot().GetTabInfo();
 
     rStrm   << sal_uInt16( 0 )              // X position of the window
@@ -92,6 +93,7 @@ void XclExpWindow1::WriteBody( XclExpStream& rStrm )
             << rTabInfo.GetFirstVisXclTab()
             << rTabInfo.GetXclSelectedCount()
             << mnTabBarSize;
+#endif // xlsx
 }
 
 // Sheet view settings records ================================================
@@ -120,8 +122,9 @@ XclExpWindow2::XclExpWindow2( const XclExpRoot& rRoot,
     ::set_flag( mnFlags, EXC_WIN2_PAGEBREAKMODE,    rData.mbPageMode );
 }
 
-void XclExpWindow2::WriteBody( XclExpStream& rStrm )
+void XclExpWindow2::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     const XclExpRoot& rRoot = rStrm.GetRoot();
 
     rStrm   << mnFlags
@@ -143,6 +146,7 @@ void XclExpWindow2::WriteBody( XclExpStream& rStrm )
         break;
         default:    DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -165,10 +169,12 @@ void XclExpScl::Shorten( sal_uInt16 nFactor )
     }
 }
 
-void XclExpScl::WriteBody( XclExpStream& rStrm )
+void XclExpScl::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF4 );
     rStrm << mnNum << mnDenom;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -206,14 +212,16 @@ void XclExpPane::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpPane::WriteBody( XclExpStream& rStrm )
+void XclExpPane::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << mnSplitX
             << mnSplitY
             << maSecondXclPos
             << mnActivePane;
     if( rStrm.GetRoot().GetBiff() >= EXC_BIFF5 )
         rStrm << sal_uInt8( 0 );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -251,12 +259,14 @@ void XclExpSelection::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpSelection::WriteBody( XclExpStream& rStrm )
+void XclExpSelection::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << mnPane                   // pane for this selection
             << maSelData.maXclCursor    // cell cursor
             << maSelData.mnCursorIdx;   // index to range containing cursor
     maSelData.maXclSelection.Write( rStrm, false );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -271,8 +281,9 @@ XclExpTabBgColor::XclExpTabBgColor( const XclTabViewData& rTabViewData ) :
 {
 }*/
 
-void XclExpTabBgColor::WriteBody( XclExpStream& rStrm )
+void XclExpTabBgColor::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if ( mrTabViewData.IsDefaultTabBgColor() )
         return;
     sal_uInt16 rt = 0x0862; //rt
@@ -286,6 +297,7 @@ void XclExpTabBgColor::WriteBody( XclExpStream& rStrm )
     if (TabBgColorIndex < 8 || TabBgColorIndex > 63 ) // only numbers 8 - 63 are valid numbers
         TabBgColorIndex = 127; //Excel specs: 127 makes excel ignore tab color information.
     rStrm << rt << grbitFrt << unused << unused << cb << TabBgColorIndex << reserved;
+#endif // xlsx
 }
 
 // Sheet view settings ========================================================
@@ -355,7 +367,7 @@ XclExpTabViewSettings::XclExpTabViewSettings( const XclExpRoot& rRoot, SCTAB nSc
                 maData.mnSplitX = static_cast< sal_uInt16 >( nFreezeScCol ) - maData.maFirstXclPos.mnCol;
             SCROW nFreezeScRow = rTabSett.maFreezePos.Row();
             if( (0 < nFreezeScRow) && (nFreezeScRow <= GetXclMaxPos().Row()) )
-                maData.mnSplitY = static_cast< sal_uInt16 >( nFreezeScRow ) - maData.maFirstXclPos.mnRow;
+                maData.mnSplitY = static_cast< sal_uInt32 >( nFreezeScRow ) - maData.maFirstXclPos.mnRow;
             // if both splits are left out (address overflow), remove the frozen flag
             maData.mbFrozenPanes = maData.IsSplit();
 
@@ -408,8 +420,9 @@ XclExpTabViewSettings::XclExpTabViewSettings( const XclExpRoot& rRoot, SCTAB nSc
     }
 }
 
-void XclExpTabViewSettings::Save( XclExpStream& rStrm )
+void XclExpTabViewSettings::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteWindow2( rStrm );
     WriteScl( rStrm );
     WritePane( rStrm );
@@ -418,6 +431,7 @@ void XclExpTabViewSettings::Save( XclExpStream& rStrm )
     WriteSelection( rStrm, EXC_PANE_BOTTOMLEFT );
     WriteSelection( rStrm, EXC_PANE_BOTTOMRIGHT );
     WriteTabBgColor( rStrm );
+#endif // xlsx
 }
 
 static void lcl_WriteSelection( XclExpXmlStream& rStrm, const XclTabViewData& rData, sal_uInt8 nPane )
@@ -501,22 +515,27 @@ void XclExpTabViewSettings::CreateSelectionData( sal_uInt8 nPane,
     }
 }
 
-void XclExpTabViewSettings::WriteWindow2( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WriteWindow2( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
 //  #i43553# GCC 3.3 parse error
 //    XclExpWindow2( GetRoot(), maData, mnGridColorId ).Save( rStrm );
     XclExpWindow2 aWindow2( GetRoot(), maData, mnGridColorId );
     aWindow2.Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WriteScl( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WriteScl( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( maData.mnCurrentZoom != 0 )
         XclExpScl( maData.mnCurrentZoom ).Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WritePane( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WritePane( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( maData.IsSplit() )
 //  #i43553# GCC 3.3 parse error
 //        XclExpPane( GetRoot(), maData ).Save( rStrm );
@@ -524,18 +543,23 @@ void XclExpTabViewSettings::WritePane( XclExpStream& rStrm ) const
         XclExpPane aPane( maData );
         aPane.Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WriteSelection( XclExpStream& rStrm, sal_uInt8 nPane ) const
+void XclExpTabViewSettings::WriteSelection( XclExpStream& /*rStrm*/, sal_uInt8 /*nPane*/ ) const
 {
+#if 0 // xlsx
     if( maData.HasPane( nPane ) )
         XclExpSelection( maData, nPane ).Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WriteTabBgColor( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WriteTabBgColor( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if ( !maData.IsDefaultTabBgColor() )
         XclExpTabBgColor( maData ).Save( rStrm );
+#endif // xlsx
 }
 // ============================================================================
 
diff --git sc/source/filter/xlsx/xlsx-xladdress.cxx sc/source/filter/xlsx/xlsx-xladdress.cxx
index 290a7dc..ed5e051 100644
--- sc/source/filter/xlsx/xlsx-xladdress.cxx
+++ sc/source/filter/xlsx/xlsx-xladdress.cxx
@@ -37,53 +37,12 @@
 
 // ============================================================================
 
-void XclAddress::Read( XclImpStream& rStrm, bool bCol16Bit )
-{
-    rStrm >> mnRow;
-    if( bCol16Bit )
-        rStrm >> mnCol;
-    else
-        mnCol = rStrm.ReaduInt8();
-}
-
-void XclAddress::Write( XclExpStream& rStrm, bool bCol16Bit ) const
-{
-    rStrm << mnRow;
-    if( bCol16Bit )
-        rStrm << mnCol;
-    else
-        rStrm << static_cast< sal_uInt8 >( mnCol );
-}
-
-// ----------------------------------------------------------------------------
-
 bool XclRange::Contains( const XclAddress& rPos ) const
 {
     return  (maFirst.mnCol <= rPos.mnCol) && (rPos.mnCol <= maLast.mnCol) &&
             (maFirst.mnRow <= rPos.mnRow) && (rPos.mnRow <= maLast.mnRow);
 }
 
-void XclRange::Read( XclImpStream& rStrm, bool bCol16Bit )
-{
-    rStrm >> maFirst.mnRow >> maLast.mnRow;
-    if( bCol16Bit )
-        rStrm >> maFirst.mnCol >> maLast.mnCol;
-    else
-    {
-        maFirst.mnCol = rStrm.ReaduInt8();
-        maLast.mnCol = rStrm.ReaduInt8();
-    }
-}
-
-void XclRange::Write( XclExpStream& rStrm, bool bCol16Bit ) const
-{
-    rStrm << maFirst.mnRow << maLast.mnRow;
-    if( bCol16Bit )
-        rStrm << maFirst.mnCol << maLast.mnCol;
-    else
-        rStrm << static_cast< sal_uInt8 >( maFirst.mnCol ) << static_cast< sal_uInt8 >( maLast.mnCol );
-}
-
 // ----------------------------------------------------------------------------
 
 XclRange XclRangeList::GetEnclosingRange() const
@@ -104,32 +63,6 @@ XclRange XclRangeList::GetEnclosingRange() const
     return aXclRange;
 }
 
-void XclRangeList::Read( XclImpStream& rStrm, bool bCol16Bit )
-{
-    sal_uInt16 nCount;
-    rStrm >> nCount;
-    size_t nOldSize = size();
-    resize( nOldSize + nCount );
-    for( iterator aIt = begin() + nOldSize; rStrm.IsValid() && (nCount > 0); --nCount, ++aIt )
-        aIt->Read( rStrm, bCol16Bit );
-}
-
-void XclRangeList::Write( XclExpStream& rStrm, bool bCol16Bit ) const
-{
-    WriteSubList( rStrm, 0, size(), bCol16Bit );
-}
-
-void XclRangeList::WriteSubList( XclExpStream& rStrm, size_t nBegin, size_t nCount, bool bCol16Bit ) const
-{
-    DBG_ASSERT( nBegin <= size(), "XclRangeList::WriteSubList - invalid start position" );
-    size_t nEnd = ::std::min< size_t >( nBegin + nCount, size() );
-    sal_uInt16 nXclCount = ulimit_cast< sal_uInt16 >( nEnd - nBegin );
-    rStrm << nXclCount;
-    rStrm.SetSliceSize( bCol16Bit ? 8 : 6 );
-    for( const_iterator aIt = begin() + nBegin, aEnd = begin() + nEnd; aIt != aEnd; ++aIt )
-        aIt->Write( rStrm, bCol16Bit );
-}
-
 // ============================================================================
 
 XclAddressConverterBase::XclAddressConverterBase( XclTracer& rTracer, const ScAddress& rMaxPos ) :
@@ -142,7 +75,7 @@ XclAddressConverterBase::XclAddressConverterBase( XclTracer& rTracer, const ScAd
     mbTabTrunc( false )
 {
     DBG_ASSERT( static_cast< size_t >( rMaxPos.Col() ) <= SAL_MAX_UINT16, "XclAddressConverterBase::XclAddressConverterBase - invalid max column" );
-    DBG_ASSERT( static_cast< size_t >( rMaxPos.Row() ) <= SAL_MAX_UINT16, "XclAddressConverterBase::XclAddressConverterBase - invalid max row" );
+    DBG_ASSERT( static_cast< size_t >( rMaxPos.Row() ) <= SAL_MAX_UINT32, "XclAddressConverterBase::XclAddressConverterBase - invalid max row" );
 }
 
 XclAddressConverterBase::~XclAddressConverterBase()
diff --git sc/source/filter/xlsx/xlsx-xlescher.cxx sc/source/filter/xlsx/xlsx-xlescher.cxx
index 066eb57..9f5fc9b 100644
--- sc/source/filter/xlsx/xlsx-xlescher.cxx
+++ sc/source/filter/xlsx/xlsx-xlescher.cxx
@@ -138,7 +138,7 @@ void lclGetColFromX(
 /** Calculates an object row position from a drawing layer Y position (in twips). */
 void lclGetRowFromY(
         ScDocument& rDoc, SCTAB nScTab,
-        sal_uInt16& rnXclRow, sal_uInt16& rnOffset, sal_uInt16 nXclStartRow,
+        sal_uInt32& rnXclRow, sal_uInt16& rnOffset, sal_uInt16 nXclStartRow,
         long& rnStartH, long nY, double fScale )
 {
     // rnStartH in conjunction with nXclStartRow is used as buffer for previously calculated height
@@ -223,6 +223,7 @@ XclObjLineData::XclObjLineData() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclObjLineData& rLineData )
 {
     return rStrm
@@ -231,6 +232,7 @@ XclImpStream& operator>>( XclImpStream& rStrm, XclObjLineData& rLineData )
         >> rLineData.mnWidth
         >> rLineData.mnAuto;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
@@ -242,6 +244,7 @@ XclObjFillData::XclObjFillData() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclObjFillData& rFillData )
 {
     return rStrm
@@ -250,6 +253,7 @@ XclImpStream& operator>>( XclImpStream& rStrm, XclObjFillData& rFillData )
         >> rFillData.mnPattern
         >> rFillData.mnAuto;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
@@ -266,6 +270,7 @@ XclObjTextData::XclObjTextData() :
 {
 }
 
+#if 0 // xlsx
 void XclObjTextData::ReadObj3( XclImpStream& rStrm )
 {
     rStrm >> mnTextLen;
@@ -293,6 +298,7 @@ void XclObjTextData::ReadTxo8( XclImpStream& rStrm )
 {
     rStrm >> mnFlags >> mnOrient >> mnButtonFlags >> mnShortcut >> mnShortcutEA >> mnTextLen >> mnFormatSize;
 }
+#endif // xlsx
 
 // ============================================================================
 
diff --git sc/source/filter/xlsx/xlsx-xlformula.cxx sc/source/filter/xlsx/xlsx-xlformula.cxx
index b8c18eb..91cb2de 100644
--- sc/source/filter/xlsx/xlsx-xlformula.cxx
+++ sc/source/filter/xlsx/xlsx-xlformula.cxx
@@ -470,6 +470,7 @@ sal_uInt16 XclTokenArray::GetSize() const
     return limit_cast< sal_uInt16 >( maTokVec.size() );
 }
 
+#if 0 // xlsx
 void XclTokenArray::ReadSize( XclImpStream& rStrm )
 {
     sal_uInt16 nSize;
@@ -507,12 +508,14 @@ void XclTokenArray::Write( XclExpStream& rStrm ) const
     WriteSize( rStrm );
     WriteArray( rStrm );
 }
+#endif // xlsx
 
 bool XclTokenArray::operator==( const XclTokenArray& rTokArr ) const
 {
     return (mbVolatile == rTokArr.mbVolatile) && (maTokVec == rTokArr.maTokVec) && (maExtDataVec == rTokArr.maExtDataVec);
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclTokenArray& rTokArr )
 {
     rTokArr.Read( rStrm );
@@ -541,6 +544,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclTokenArrayRef& rxTokArr
         rStrm << sal_uInt16( 0 );
     return rStrm;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
diff --git sc/source/filter/xlsx/xlsx-xlpivot.cxx sc/source/filter/xlsx/xlsx-xlpivot.cxx
index c915903..3704f40 100644
--- sc/source/filter/xlsx/xlsx-xlpivot.cxx
+++ sc/source/filter/xlsx/xlsx-xlpivot.cxx
@@ -178,6 +178,7 @@ XclPCFieldInfo::XclPCFieldInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPCFieldInfo& rInfo )
 {
     rStrm   >> rInfo.mnFlags
@@ -206,6 +207,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCFieldInfo& rInfo )
         << rInfo.mnOrigItems
         << XclExpString( rInfo.maName );
 }
+#endif // xlsx
 
 // Numeric grouping field settings ============================================
 
@@ -264,6 +266,7 @@ void XclPCNumGroupInfo::SetXclDataType( sal_uInt16 nXclType )
     ::insert_value( mnFlags, nXclType, 2, 4 );
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPCNumGroupInfo& rInfo )
 {
     return rStrm >> rInfo.mnFlags;
@@ -273,6 +276,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCNumGroupInfo& rInfo )
 {
     return rStrm << rInfo.mnFlags;
 }
+#endif // xlsx
 
 // Base class for pivot cache fields ==========================================
 
@@ -370,6 +374,7 @@ XclPCInfo::XclPCInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPCInfo& rInfo )
 {
     rStrm   >> rInfo.mnSrcRecs
@@ -397,6 +402,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCInfo& rInfo )
         << rInfo.mnSrcType
         << XclExpString( rInfo.maUserName );
 }
+#endif // xlsx
 
 // ============================================================================
 // Pivot table
@@ -404,6 +410,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCInfo& rInfo )
 
 // cached name ================================================================
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTCachedName& rCachedName )
 {
     sal_uInt16 nStrLen;
@@ -424,6 +431,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTCachedName& rCachedNam
         rStrm << XclExpString( rCachedName.maName, EXC_STR_DEFAULT, EXC_PT_MAXSTRLEN );
     return rStrm;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
@@ -447,6 +455,7 @@ XclPTItemInfo::XclPTItemInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTItemInfo& rInfo )
 {
     return rStrm
@@ -464,6 +473,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTItemInfo& rInfo )
         << rInfo.mnCacheIdx
         << rInfo.maVisName;
 }
+#endif // xlsx
 
 // General field settings =====================================================
 
@@ -555,6 +565,7 @@ void XclPTFieldInfo::SetSubtotals( const XclPTSubtotalVec& rSubtotals )
             ++mnSubtCount;
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldInfo& rInfo )
 {
     // rInfo.mnCacheIdx is not part of the SXVD record
@@ -576,6 +587,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldInfo& rInfo )
         << rInfo.mnItemCount
         << rInfo.maVisName;
 }
+#endif // xlsx
 
 // Extended field settings ====================================================
 
@@ -640,6 +652,7 @@ void XclPTFieldExtInfo::SetApiLayoutMode( sal_Int32 nLayoutMode )
     ::set_flag( mnFlags, EXC_SXVDEX_LAYOUT_TOP, nLayoutMode == ScDPLayoutMode::OUTLINE_SUBTOTALS_TOP );
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldExtInfo& rInfo )
 {
     sal_uInt8 nNameLen = 0;
@@ -681,6 +694,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldExtInfo& rInfo )
     }
     return rStrm;
 }
+#endif // xlsx
 
 // Page field settings ========================================================
 
@@ -691,6 +705,7 @@ XclPTPageFieldInfo::XclPTPageFieldInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTPageFieldInfo& rInfo )
 {
     return rStrm
@@ -706,6 +721,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTPageFieldInfo& rInfo )
         << rInfo.mnSelItem
         << rInfo.mnObjId;
 }
+#endif // xlsx
 
 // Data field settings ========================================================
 
@@ -819,6 +835,7 @@ void XclPTDataFieldInfo::SetApiRefItemType( sal_Int32 nRefItemType )
     }
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTDataFieldInfo& rInfo )
 {
     return rStrm
@@ -842,6 +859,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTDataFieldInfo& rInfo )
         << rInfo.mnNumFmt
         << rInfo.maVisName;
 }
+#endif // xlsx
 
 // Pivot table settings =======================================================
 
@@ -862,6 +880,7 @@ XclPTInfo::XclPTInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTInfo& rInfo )
 {
     sal_uInt16 nTabLen, nDataLen;
@@ -908,6 +927,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTInfo& rInfo )
     aXclDataName.WriteBuffer( rStrm );
     return rStrm;
 }
+#endif // xlsx
 
 // Extended pivot table settings ==============================================
 
@@ -920,6 +940,7 @@ XclPTExtInfo::XclPTExtInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTExtInfo& rInfo )
 {
     rStrm >> rInfo.mnSxformulaRecs;
@@ -946,6 +967,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTExtInfo& rInfo )
         << EXC_PT_NOSTRING              // length of table style name
         << EXC_PT_NOSTRING;             // length of vacate style name
 }
+#endif // xlsx
 
 // ============================================================================
 
@@ -1010,6 +1032,7 @@ void XclPTViewEx9Info::Init( const ScDPObject& rDPObj )
     }
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTViewEx9Info& rInfo )
 {
     rStrm.Ignore( 2 );
@@ -1031,4 +1054,5 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTViewEx9Info& rInfo )
         << rInfo.mnGridLayout
         << XclExpString(rInfo.maGrandTotalName, EXC_STR_DEFAULT, EXC_PT_MAXSTRLEN);
 }
+#endif // xlsx
 
diff --git sc/source/filter/xlsx/xlsx-xltools.cxx sc/source/filter/xlsx/xlsx-xltools.cxx
index 6398e25..e4d9ae8 100644
--- sc/source/filter/xlsx/xlsx-xltools.cxx
+++ sc/source/filter/xlsx/xlsx-xltools.cxx
@@ -87,6 +87,7 @@ bool operator<( const XclGuid& rCmp1, const XclGuid& rCmp2 )
         rCmp2.mpnData, STATIC_TABLE_END( rCmp2.mpnData ) );
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclGuid& rGuid )
 {
     rStrm.Read( rGuid.mpnData, 16 );     // mpnData always in little endian
@@ -98,6 +99,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclGuid& rGuid )
     rStrm.Write( rGuid.mpnData, 16 );    // mpnData already in little endian
     return rStrm;
 }
+#endif // xlsx
 
 // Excel Tools ================================================================
 
@@ -663,6 +665,7 @@ bool XclTools::IsCondFormatStyleName( const String& rStyleName, xub_StrLen* pnNe
 
 // stream handling ------------------------------------------------------------
 
+#if 0 // xlsx
 void XclTools::SkipSubStream( XclImpStream& rStrm )
 {
     bool bLoop = true;
@@ -689,6 +692,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const Color& rColor )
 {
     return rStrm << rColor.GetRed() << rColor.GetGreen() << rColor.GetBlue() << sal_uInt8( 0 );
 }
+#endif // xlsx
 
 // ============================================================================
 
diff --git sc/source/filter/xlsx/xlview.hxx sc/source/filter/xlsx/xlview.hxx
new file mode 100644
index 0000000..3070c28
--- /dev/null
+++ sc/source/filter/xlsx/xlview.hxx
@@ -0,0 +1,181 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlview.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLVIEW_HXX
+#define SC_XLVIEW_HXX
+
+#include <map>
+#include <tools/color.hxx>
+#include "ftools.hxx"
+#include "xladdress.hxx"
+
+// Constants and enumerations =================================================
+
+const sal_uInt16 EXC_ZOOM_MIN               = 10;
+const sal_uInt16 EXC_ZOOM_MAX               = 400;
+
+// (0x001D) SELECTION ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SELECTION           = 0x001D;
+
+// (0x003D) WINDOW1 -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_WINDOW1             = 0x003D;
+
+const sal_uInt16 EXC_WIN1_HIDDEN            = 0x0001;
+const sal_uInt16 EXC_WIN1_MINIMIZED         = 0x0002;
+const sal_uInt16 EXC_WIN1_HOR_SCROLLBAR     = 0x0008;
+const sal_uInt16 EXC_WIN1_VER_SCROLLBAR     = 0x0010;
+const sal_uInt16 EXC_WIN1_TABBAR            = 0x0020;
+
+// (0x003E, 0x023E) WINDOW2 ---------------------------------------------------
+
+const sal_uInt16 EXC_ID2_WINDOW2            = 0x003E;
+const sal_uInt16 EXC_ID_WINDOW2             = 0x023E;
+
+const sal_uInt16 EXC_WIN2_SHOWFORMULAS      = 0x0001;
+const sal_uInt16 EXC_WIN2_SHOWGRID          = 0x0002;
+const sal_uInt16 EXC_WIN2_SHOWHEADINGS      = 0x0004;
+const sal_uInt16 EXC_WIN2_FROZEN            = 0x0008;
+const sal_uInt16 EXC_WIN2_SHOWZEROS         = 0x0010;
+const sal_uInt16 EXC_WIN2_DEFGRIDCOLOR      = 0x0020;
+const sal_uInt16 EXC_WIN2_MIRRORED          = 0x0040;
+const sal_uInt16 EXC_WIN2_SHOWOUTLINE       = 0x0080;
+const sal_uInt16 EXC_WIN2_FROZENNOSPLIT     = 0x0100;
+const sal_uInt16 EXC_WIN2_SELECTED          = 0x0200;
+const sal_uInt16 EXC_WIN2_DISPLAYED         = 0x0400;
+const sal_uInt16 EXC_WIN2_PAGEBREAKMODE     = 0x0800;
+
+const sal_uInt16 EXC_WIN2_NORMALZOOM_DEF    = 100;      /// Default zoom for normal view.
+const sal_uInt16 EXC_WIN2_PAGEZOOM_DEF      = 60;       /// Default zoom for pagebreak preview.
+
+// (0x0041) PANE --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_PANE                = 0x0041;
+
+const sal_uInt8 EXC_PANE_BOTTOMRIGHT        = 0;        /// Bottom-right pane.
+const sal_uInt8 EXC_PANE_TOPRIGHT           = 1;        /// Right, or top-right pane.
+const sal_uInt8 EXC_PANE_BOTTOMLEFT         = 2;        /// Bottom, or bottom-left pane.
+const sal_uInt8 EXC_PANE_TOPLEFT            = 3;        /// Single, top, left, or top-left pane.
+
+// (0x00A0) SCL ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SCL                 = 0x00A0;
+
+// (0x0862) SHEETEXT ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SHEETEXT            = 0x0862; 	/// header id for sheetext
+const sal_uInt8 EXC_SHEETEXT_TABCOLOR       = 0x7F; 	/// mask for tab color
+const sal_uInt16 EXC_COLOR_NOTABBG          = 0x7F;     /// Excel ignores Tab color when set to this value...
+// Structs ====================================================================
+
+/** Contains all view settings for the entire document. */
+struct XclDocViewData
+{
+    sal_uInt16          mnWinX;             /// X position of the document window (twips).
+    sal_uInt16          mnWinY;             /// Y position of the document window (twips).
+    sal_uInt16          mnWinWidth;         /// Width of the document window (twips).
+    sal_uInt16          mnWinHeight;        /// Height of the document window (twips).
+    sal_uInt16          mnFlags;            /// Additional flags.
+    sal_uInt16          mnDisplXclTab;      /// Displayed (active) sheet.
+    sal_uInt16          mnFirstVisXclTab;   /// First visible sheet.
+    sal_uInt16          mnXclSelectCnt;     /// Number of selected sheets.
+    sal_uInt16          mnTabBarWidth;      /// Width of sheet tabbar (1/1000 of window width).
+
+    explicit            XclDocViewData();
+};
+
+// ----------------------------------------------------------------------------
+
+/** Contains all settings for a selection in a single pane of a sheet. */
+struct XclSelectionData
+{
+    XclAddress          maXclCursor;        /// Cell cursor position.
+    XclRangeList        maXclSelection;     /// Selected cell ranges.
+    sal_uInt16          mnCursorIdx;        /// Index of cursor in selection list.
+
+    inline explicit     XclSelectionData() : mnCursorIdx( 0 ) {}
+};
+
+typedef ScfRef< XclSelectionData > XclSelectionDataRef;
+
+// ----------------------------------------------------------------------------
+
+/** Contains all view settings for a single sheet. */
+struct XclTabViewData
+{
+    typedef ::std::map< sal_uInt8, XclSelectionDataRef > XclSelectionMap;
+
+    XclSelectionMap     maSelMap;           /// Selections of all panes.
+    Color               maGridColor;        /// Grid color.
+    XclAddress          maFirstXclPos;      /// First visible cell.
+    XclAddress          maSecondXclPos;     /// First visible cell in additional panes.
+    sal_uInt16          mnSplitX;           /// Split X position, or number of frozen columns.
+    sal_uInt16          mnSplitY;           /// Split Y position, or number of frozen rows.
+    sal_uInt16          mnNormalZoom;       /// Zoom factor for normal view.
+    sal_uInt16          mnPageZoom;         /// Zoom factor for pagebreak preview.
+    sal_uInt16          mnCurrentZoom;      /// Zoom factor for current view.
+    sal_uInt8           mnActivePane;       /// Active pane (with cell cursor).
+    bool                mbSelected;         /// true = Sheet is selected.
+    bool                mbDisplayed;        /// true = Sheet is displayed (active).
+    bool                mbMirrored;         /// true = Mirrored (right-to-left) sheet.
+    bool                mbFrozenPanes;      /// true = Frozen panes; false = split window.
+    bool                mbPageMode;         /// true = Pagebreak preview; false = Normal view.
+    bool                mbDefGridColor;     /// true = Default grid color.
+    bool                mbShowFormulas;     /// true = Show formulas instead of results.
+    bool                mbShowGrid;         /// true = Show cell grid.
+    bool                mbShowHeadings;     /// true = Show column/row headings.
+    bool                mbShowZeros;        /// true = Show zero value zells.
+    bool                mbShowOutline;      /// true = Show outlines.
+    Color               maTabBgColor;       /// Tab Color default = (COL_AUTO )
+    bool                IsDefaultTabBgColor() const { return maTabBgColor == Color(COL_AUTO) ? TRUE : FALSE; };
+    sal_uInt32          mnTabBgColorId;         /// pallette color id
+
+    explicit            XclTabViewData();
+                        ~XclTabViewData();
+
+    /** Sets Excel default view settings. */
+    void                SetDefaults();
+
+    /** Returns true, if the window is split in any direction. */
+    bool                IsSplit() const;
+    /** Returns true, if the specified pane (EXC_PANE_*) is available. */
+    bool                HasPane( sal_uInt8 nPaneId ) const;
+
+    /** Returns the selection data, if available, otherwise 0. */
+    const XclSelectionData* GetSelectionData( sal_uInt8 nPane ) const;
+    /** Returns read/write access to the selection data of the specified pane. */
+    XclSelectionData&   CreateSelectionData( sal_uInt8 nPane );
+};
+
+// ============================================================================
+
+#endif
+
