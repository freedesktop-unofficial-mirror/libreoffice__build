diff --git sc/source/filter/inc/xlconst.hxx sc/source/filter/inc/xlconst.hxx
index eeb3fb3..2a176a9 100644
--- sc/source/filter/inc/xlconst.hxx
+++ sc/source/filter/inc/xlconst.hxx
@@ -77,6 +77,10 @@ const SCCOL EXC_MAXCOL8                     = EXC_MAXCOL5;
 const SCROW EXC_MAXROW8                     = 65535;
 const SCTAB EXC_MAXTAB8                     = EXC_MAXTAB5;
 
+const SCCOL EXC_MAXCOL_XML_2007             = 16383;
+const SCROW EXC_MAXROW_XML_2007             = 1048575;
+const SCTAB EXC_MAXTAB_XML_2007             = 1023;
+
 const sal_uInt16 EXC_NOTAB                  = SAL_MAX_UINT16;   /// An invalid Excel sheet index, for common use.
 const SCTAB SCTAB_INVALID                   = SCTAB_MAX;        /// An invalid Calc sheet index, for common use.
 const SCTAB SCTAB_GLOBAL                    = SCTAB_MAX;        /// A Calc sheet index for the workbook globals.
diff --git sc/source/filter/xlsx/makefile.mk sc/source/filter/xlsx/makefile.mk
index 7c4c43b..708ccea 100644
--- sc/source/filter/xlsx/makefile.mk
+++ sc/source/filter/xlsx/makefile.mk
@@ -53,16 +53,11 @@ CDEFS+=-DXLSX_GUARD
 SLOFILES =	\
 		$(SLO)$/xlsx-colrowst.obj				\
 		$(SLO)$/xlsx-excdoc.obj					\
-		$(SLO)$/xlsx-excel.obj					\
-		$(SLO)$/xlsx-excform.obj					\
-		$(SLO)$/xlsx-excform8.obj				\
-		$(SLO)$/xlsx-excimp8.obj					\
 		$(SLO)$/xlsx-excrecds.obj				\
 		$(SLO)$/xlsx-exctools.obj				\
 		$(SLO)$/xlsx-expop2.obj					\
 		$(SLO)$/xlsx-fontbuff.obj				\
 		$(SLO)$/xlsx-frmbase.obj					\
-		$(SLO)$/xlsx-impop.obj					\
 		$(SLO)$/xlsx-namebuff.obj				\
 		$(SLO)$/xlsx-read.obj					\
 		$(SLO)$/xlsx-tokstack.obj				\
@@ -82,20 +77,6 @@ SLOFILES =	\
 		$(SLO)$/xlsx-xestyle.obj					\
 		$(SLO)$/xlsx-xetable.obj					\
 		$(SLO)$/xlsx-xeview.obj					\
-		$(SLO)$/xlsx-xichart.obj					\
-		$(SLO)$/xlsx-xicontent.obj				\
-		$(SLO)$/xlsx-xiescher.obj				\
-		$(SLO)$/xlsx-xiformula.obj				\
-		$(SLO)$/xlsx-xihelper.obj				\
-		$(SLO)$/xlsx-xilink.obj					\
-		$(SLO)$/xlsx-xiname.obj					\
-		$(SLO)$/xlsx-xipage.obj					\
-		$(SLO)$/xlsx-xipivot.obj					\
-		$(SLO)$/xlsx-xiroot.obj					\
-		$(SLO)$/xlsx-xistream.obj				\
-		$(SLO)$/xlsx-xistring.obj				\
-		$(SLO)$/xlsx-xistyle.obj					\
-		$(SLO)$/xlsx-xiview.obj					\
 		$(SLO)$/xlsx-xladdress.obj				\
 		$(SLO)$/xlsx-xlchart.obj					\
 		$(SLO)$/xlsx-xlescher.obj				\
@@ -108,7 +89,6 @@ SLOFILES =	\
 		$(SLO)$/xlsx-xltoolbar.obj					\
 		$(SLO)$/xlsx-xltracer.obj				\
 		$(SLO)$/xlsx-XclExpChangeTrack.obj				\
-		$(SLO)$/xlsx-XclImpChangeTrack.obj				\
 		$(SLO)$/xlsx-xcl97esc.obj				\
 		$(SLO)$/xlsx-xcl97rec.obj				\
 		$(SLO)$/xlsx-xlview.obj
@@ -120,10 +100,6 @@ NOOPTFILES = \
 
 EXCEPTIONSFILES = \
 		$(SLO)$/xlsx-excdoc.obj					\
-		$(SLO)$/xlsx-excel.obj					\
-		$(SLO)$/xlsx-excform.obj					\
-		$(SLO)$/xlsx-excform8.obj				\
-		$(SLO)$/xlsx-excimp8.obj					\
 		$(SLO)$/xlsx-excrecds.obj				\
 		$(SLO)$/xlsx-expop2.obj					\
 		$(SLO)$/xlsx-namebuff.obj				\
@@ -142,18 +118,7 @@ EXCEPTIONSFILES = \
 		$(SLO)$/xlsx-xestyle.obj					\
 		$(SLO)$/xlsx-xetable.obj					\
 		$(SLO)$/xlsx-xeview.obj					\
-		$(SLO)$/xlsx-xichart.obj					\
-		$(SLO)$/xlsx-xicontent.obj				\
-		$(SLO)$/xlsx-xiescher.obj				\
-		$(SLO)$/xlsx-xihelper.obj				\
-		$(SLO)$/xlsx-xilink.obj					\
-		$(SLO)$/xlsx-xipage.obj					\
-		$(SLO)$/xlsx-xipivot.obj					\
-		$(SLO)$/xlsx-xistream.obj				\
-		$(SLO)$/xlsx-xistring.obj				\
-		$(SLO)$/xlsx-xistyle.obj					\
 		$(SLO)$/xlsx-xladdress.obj				\
-		$(SLO)$/xlsx-xiescher.obj				\
 		$(SLO)$/xlsx-xlchart.obj					\
 		$(SLO)$/xlsx-xlformula.obj				\
 		$(SLO)$/xlsx-xlpivot.obj					\
diff --git sc/source/filter/xlsx/xehelper.hxx sc/source/filter/xlsx/xehelper.hxx
new file mode 100644
index 0000000..b9ed319
--- /dev/null
+++ sc/source/filter/xlsx/xehelper.hxx
@@ -0,0 +1,454 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xehelper.hxx,v $
+ * $Revision: 1.20.32.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XEHELPER_HXX
+#define SC_XEHELPER_HXX
+
+#include "xladdress.hxx"
+#include "xeroot.hxx"
+#include "xestring.hxx"
+
+// Export progress bar ========================================================
+
+class ScfProgressBar;
+
+/** The main progress bar for the export filter.
+
+    This class encapsulates creation and initialization of sub progress
+    segments. The Activate***Segment() functions activate a specific segement
+    of the main progress bar. The implementation of these functions contain the
+    calculation of the needed size of the segment. Following calls of the
+    Progress() function increase the currently activated sub segment.
+ */
+class XclExpProgressBar : protected XclExpRoot
+{
+public:
+    explicit            XclExpProgressBar( const XclExpRoot& rRoot );
+    virtual             ~XclExpProgressBar();
+
+    /** Initializes all segments and sub progress bars. */
+    void                Initialize();
+
+    /** Increases the number of existing ROW records by 1. */
+    void                IncRowRecordCount();
+
+    /** Activates the progress segment to create ROW records. */
+    void                ActivateCreateRowsSegment();
+    /** Activates the progress segment to finalize ROW records. */
+    void                ActivateFinalRowsSegment();
+
+    /** Increases the currently activated (sub) progress bar by 1 step. */
+    void                Progress();
+
+private:
+    typedef ::std::auto_ptr< ScfProgressBar > ScfProgressBarPtr;
+
+    ScfProgressBarPtr   mxProgress;         /// Progress bar implementation.
+    ScfProgressBar*     mpSubProgress;      /// Current sub progress bar.
+
+    ScfProgressBar*     mpSubRowCreate;     /// Sub progress bar for creating table rows.
+    ScfInt32Vec         maSubSegRowCreate;  /// Segment ID's for all sheets in sub progress bar.
+
+    ScfProgressBar*     mpSubRowFinal;      /// Sub progress bar for finalizing ROW records.
+    sal_Int32           mnSegRowFinal;      /// Progress segment for finalizing ROW records.
+
+    sal_Size            mnRowCount;         /// Number of created ROW records.
+};
+
+// Calc->Excel cell address/range conversion ==================================
+
+/** Provides functions to convert Calc cell addresses to Excel cell addresses. */
+class XclExpAddressConverter : public XclAddressConverterBase
+{
+public:
+    explicit            XclExpAddressConverter( const XclExpRoot& rRoot );
+
+    // cell address -----------------------------------------------------------
+
+    /** Checks if the passed Calc cell address is valid.
+        @param rScPos  The Calc cell address to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell address is not valid.
+        @return  true = Cell address in rScPos is valid. */
+    bool                CheckAddress( const ScAddress& rScPos, bool bWarn );
+
+    /** Converts the passed Calc cell address to an Excel cell address.
+        @param rXclPos  (Out) The converted Excel cell address, if valid.
+        @param rScPos  The Calc cell address to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell address is not valid.
+        @return  true = Cell address returned in rXclPos is valid. */
+    bool                ConvertAddress( XclAddress& rXclPos,
+                            const ScAddress& rScPos, bool bWarn );
+
+    /** Returns a valid cell address by moving it into allowed dimensions.
+        @param rScPos  The Calc cell address to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell address is invalid.
+        @return  The converted Excel cell address. */
+    XclAddress          CreateValidAddress( const ScAddress& rScPos, bool bWarn );
+
+    // cell range -------------------------------------------------------------
+
+    /** Checks if the passed cell range is valid (checks start and end position).
+        @param rScRange  The Calc cell range to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell range is not valid.
+        @return  true = Cell range in rScRange is valid. */
+    bool                CheckRange( const ScRange& rScRange, bool bWarn );
+
+    /** Checks and eventually crops the cell range to valid dimensions.
+        @descr  The start position of the range will not be modified.
+        @param rScRange  (In/out) The cell range to validate.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell range contains invalid
+            cells. If the range is partly valid, this function sets the warning
+            flag, corrects the range and returns true.
+        @return  true = Cell range in rScRange is valid (original or cropped). */
+    bool                ValidateRange( ScRange& rScRange, bool bWarn );
+
+    /** Converts the passed Calc cell range to an Excel cell range.
+        @param rXclRange  (Out) The converted Excel cell range, if valid.
+        @param rScRange  The Calc cell range to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the cell range contains invalid cells.
+        @return  true = Cell range returned in rXclRange is valid (original or cropped). */
+    bool                ConvertRange( XclRange& rXclRange, const ScRange& rScRange, bool bWarn );
+
+//UNUSED2008-05  /** Returns a valid cell range by moving it into allowed dimensions.
+//UNUSED2008-05      @descr  The start and/or end position of the range may be modified.
+//UNUSED2008-05      @param rScRange  The Calc cell range to convert.
+//UNUSED2008-05      @param bWarn  true = Sets the internal flag that produces a warning box
+//UNUSED2008-05          after loading/saving the file, if the cell range contains invalid cells.
+//UNUSED2008-05      @return  The converted Excel cell range. */
+//UNUSED2008-05  XclRange            CreateValidRange( const ScRange& rScRange, bool bWarn );
+
+    // cell range list --------------------------------------------------------
+
+//UNUSED2008-05  /** Checks if the passed cell range list is valid.
+//UNUSED2008-05      @param rScRanges  The Calc cell range list to check.
+//UNUSED2008-05      @param bWarn  true = Sets the internal flag that produces a warning box
+//UNUSED2008-05          after loading/saving the file, if the cell range list contains at
+//UNUSED2008-05          least one invalid range.
+//UNUSED2008-05      @return  true = Cell range list in rScRanges is completly valid. */
+//UNUSED2008-05  bool                CheckRangeList( const ScRangeList& rScRanges, bool bWarn );
+
+    /** Checks and eventually crops the cell ranges to valid dimensions.
+        @descr  The start position of the ranges will not be modified. Cell
+            ranges that fit partly into valid dimensions are cropped
+            accordingly. Cell ranges that do not fit at all, are removed from
+            the cell range list.
+        @param rScRanges  (In/out) The cell range list to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if at least one of the cell ranges
+            contains invalid cells. */
+    void                ValidateRangeList( ScRangeList& rScRanges, bool bWarn );
+
+    /** Converts the passed Calc cell range list to an Excel cell range list.
+        @descr  The start position of the ranges will not be modified. Cell
+            ranges that fit partly into valid dimensions are cropped
+            accordingly. Cell ranges that do not fit at all, are not inserted
+            into the Excel cell range list.
+        @param rXclRanges  (Out) The converted Excel cell range list.
+        @param rScRanges  The Calc cell range list to convert.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if at least one of the cell ranges
+            contains invalid cells. */
+    void                ConvertRangeList( XclRangeList& rXclRanges,
+                            const ScRangeList& rScRanges, bool bWarn );
+};
+
+// EditEngine->String conversion ==============================================
+
+class SvxURLField;
+class XclExpHyperlink;
+
+/** Helper to create HLINK records during creation of formatted cell strings.
+
+    In Excel it is not possible to have more than one hyperlink in a cell. This
+    helper detects multiple occurences of hyperlinks and fills a string which
+    is used to create a cell note containing all URLs. Only cells containing
+    one hyperlink are exported as hyperlink cells.
+ */
+class XclExpHyperlinkHelper : protected XclExpRoot
+{
+public:
+    typedef ScfRef< XclExpHyperlink > XclExpHyperlinkRef;
+
+    explicit            XclExpHyperlinkHelper( const XclExpRoot& rRoot, const ScAddress& rScPos );
+                        ~XclExpHyperlinkHelper();
+
+    /** Processes the passed URL field (tries to create a HLINK record).
+        @return  The representation string of the URL field. */
+    String              ProcessUrlField( const SvxURLField& rUrlField );
+
+    /** Returns true, if a single HLINK record has been created. */
+    bool                HasLinkRecord() const;
+    /** Returns the craeted single HLINk record, or an empty reference. */
+    XclExpHyperlinkRef  GetLinkRecord();
+
+    /** Returns true, if multiple URLs have been processed. */
+    inline bool         HasMultipleUrls() const { return mbMultipleUrls; }
+    /** Returns a string containing all processed URLs. */
+    inline const String& GetUrlList() { return maUrlList; }
+
+private:
+    XclExpHyperlinkRef  mxLinkRec;          /// Created HLINK record.
+    ScAddress           maScPos;            /// Cell position to set at the HLINK record.
+    String              maUrlList;          /// List with all processed URLs.
+    bool                mbMultipleUrls;     /// true = Multiple URL fields processed.
+};
+
+// ----------------------------------------------------------------------------
+
+class EditEngine;
+class SdrTextObj;
+class ScStringCell;
+class ScEditCell;
+class ScPatternAttr;
+
+/** This class provides methods to create an XclExpString.
+    @descr  The string can be created from an edit engine text object or
+    directly from a Calc edit cell. */
+class XclExpStringHelper : ScfNoInstance
+{
+public:
+    /** Creates a new unformatted string from the passed string.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param rString  The source string.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            const String& rString,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new unformatted string from the passed character.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param cChar  The source character. The NUL character is explicitly allowed.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            sal_Unicode cChar,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Appends an unformatted string to an Excel string object.
+        @descr  Selects the correct Append() function depending on the current
+                BIFF version contained in the passed XclExpRoot object.
+        @param rXclString  The Excel string object.
+        @param rString  The source string. */
+    static void         AppendString(
+                            XclExpString& rXclString,
+                            const XclExpRoot& rRoot,
+                            const String& rString );
+
+    /** Appends a character to an Excel string object.
+        @descr  Selects the correct Append() function depending on the current
+                BIFF version contained in the passed XclExpRoot object.
+        @param rXclString  The Excel string object.
+        @param rString  The source string. */
+    static void         AppendChar(
+                            XclExpString& rXclString,
+                            const XclExpRoot& rRoot,
+                            sal_Unicode cChar );
+
+    /** Creates a new formatted string from a Calc string cell.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+                May create a formatted string object, if the cell text contains
+                different script types.
+        @param rStringCell  The Calc string cell object.
+        @param pCellAttr  The set item containing the cell formatting.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateCellString(
+                            const XclExpRoot& rRoot,
+                            const ScStringCell& rStringCell,
+                            const ScPatternAttr* pCellAttr,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new formatted string from a Calc edit cell.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param rEditCell  The Calc edit cell object.
+        @param pCellAttr  The set item containing the cell formatting.
+        @param rLinkHelper  Helper object for hyperlink conversion.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateCellString(
+                            const XclExpRoot& rRoot,
+                            const ScEditCell& rEditCell,
+                            const ScPatternAttr* pCellAttr,
+                            XclExpHyperlinkHelper& rLinkHelper,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new formatted string from a drawing text box.
+        @descr  Creates a Unicode string or a byte string, depending on the
+                current BIFF version contained in the passed XclExpRoot object.
+        @param rTextObj  The text box object.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen  The maximum number of characters to store in this string.
+        @return  The new string object (shared pointer). */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            const SdrTextObj& rTextObj,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Creates a new formatted string from a edit text string.
+        @param rEditObj  The edittext object.
+        @param nFlags  Modifiers for string export.
+        @param nMaxLen The maximum number of characters to store in this string.
+        @return  The new string object. */
+    static XclExpStringRef CreateString(
+                            const XclExpRoot& rRoot,
+                            const EditTextObject& rEditObj,
+                            XclStrFlags nFlags = EXC_STR_DEFAULT,
+                            sal_uInt16 nMaxLen = EXC_STR_MAXLEN );
+
+    /** Returns the script type first text portion different to WEAK, or the system
+        default script type, if there is only weak script in the passed string. */
+    static sal_Int16    GetLeadingScriptType( const XclExpRoot& rRoot, const String& rString );
+};
+
+// Header/footer conversion ===================================================
+
+class EditEngine;
+
+/** Converts edit engine text objects to an Excel header/footer string.
+    @descr  Header/footer content is divided into three parts: Left, center and
+    right portion. All formatting information will be encoded in the Excel string
+    using special character seuences. A control sequence starts with the ampersand
+    character.
+
+    Supported control sequences:
+    &L                      start of left portion
+    &C                      start of center portion
+    &R                      start of right portion
+    &P                      current page number
+    &N                      page count
+    &D                      current date
+    &T                      current time
+    &A                      table name
+    &F                      file name without path
+    &Z                      file path without file name
+    &Z&F                    file path and name
+    &U                      underlining on/off
+    &E                      double underlining on/off
+    &S                      strikeout characters on/off
+    &X                      superscript on/off
+    &Y                      subscript on/off
+    &"fontname,fontstyle"   use font with name 'fontname' and style 'fontstyle'
+    &fontheight             set font height in points ('fontheight' is a decimal value)
+
+    Known but unsupported control sequences:
+    &G                      picture
+ */
+class XclExpHFConverter : protected XclExpRoot, ScfNoCopy
+{
+public:
+    explicit            XclExpHFConverter( const XclExpRoot& rRoot );
+
+    /** Generates the header/footer string from the passed edit engine text objects. */
+    void                GenerateString(
+                            const EditTextObject* pLeftObj,
+                            const EditTextObject* pCenterObj,
+                            const EditTextObject* pRightObj );
+
+    /** Returns the last generated header/footer string. */
+    inline const String& GetHFString() const { return maHFString; }
+    /** Returns the total height of the last generated header/footer in twips. */
+    inline sal_Int32    GetTotalHeight() const { return mnTotalHeight; }
+
+private:
+    /** Converts the text object contents and stores it in the passed string. */
+    void                AppendPortion(
+                            const EditTextObject* pTextObj,
+                            sal_Unicode cPortionCode );
+
+private:
+    EditEngine&         mrEE;           /// The header/footer edit engine.
+    String              maHFString;     /// The last generated header/footer string.
+    sal_Int32           mnTotalHeight;  /// Total height of the last header/footer (twips).
+};
+
+// URL conversion =============================================================
+
+/** This class contains static methods to encode a file URL.
+    @descr  Excel stores URLs in a format that contains special control characters,
+    i.e. for directory separators or volume names. */
+class XclExpUrlHelper : ScfNoInstance
+{
+public:
+    /** Encodes and returns the URL passed in rAbsUrl to an Excel like URL.
+        @param pTableName  Optional pointer to a table name to be encoded in this URL. */
+    static String       EncodeUrl( const XclExpRoot& rRoot, const String& rAbsUrl, const String* pTableName = 0 );
+    /** Encodes and returns the passed DDE link to an Excel like DDE link. */
+    static String       EncodeDde( const String& rApplic, const String rTopic );
+};
+
+// ----------------------------------------------------------------------------
+class ScDocument;
+class ScMatrix;
+
+/** Contains cached values in a 2-dimensional array. */
+class XclExpCachedMatrix
+{
+    void            GetDimensions( SCSIZE & nCols, SCSIZE & nRows ) const;
+public:
+    /** Constructs and fills a new matrix.
+        @param rMatrix  The Calc value matrix. */
+    explicit        XclExpCachedMatrix( const ScMatrix& rMatrix );
+                   ~XclExpCachedMatrix();
+
+    /** Returns the byte count of all contained data. */
+    sal_Size        GetSize() const;
+    /** Writes the complete matrix to stream. */
+    void            Save( XclExpStream& rStrm ) const;
+
+private:
+    const ScMatrix& mrMatrix;
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xeroot.hxx sc/source/filter/xlsx/xeroot.hxx
new file mode 100644
index 0000000..f4e1d25
--- /dev/null
+++ sc/source/filter/xlsx/xeroot.hxx
@@ -0,0 +1,173 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xeroot.hxx,v $
+ * $Revision: 1.21 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XEROOT_HXX
+#define SC_XEROOT_HXX
+
+#include "xlroot.hxx"
+
+// Forward declarations of objects in public use ==============================
+
+class XclExpStream;
+class XclExpRecordBase;
+class XclExpString;
+
+typedef ScfRef< XclExpRecordBase >  XclExpRecordRef;
+typedef ScfRef< XclExpString >      XclExpStringRef;
+
+// Global data ================================================================
+
+class XclExpTabInfo;
+class XclExpAddressConverter;
+class XclExpFormulaCompiler;
+class XclExpProgressBar;
+class XclExpSst;
+class XclExpPalette;
+class XclExpFontBuffer;
+class XclExpNumFmtBuffer;
+class XclExpXFBuffer;
+class XclExpLinkManager;
+class XclExpNameManager;
+class XclExpFilterManager;
+class XclExpPivotTableManager;
+
+/** Stores global buffers and data needed for Excel export filter. */
+struct XclExpRootData : public XclRootData
+{
+    typedef ScfRef< XclExpTabInfo >             XclExpTabInfoRef;
+    typedef ScfRef< XclExpAddressConverter >    XclExpAddrConvRef;
+    typedef ScfRef< XclExpFormulaCompiler >     XclExpFmlaCompRef;
+    typedef ScfRef< XclExpProgressBar >         XclExpProgressRef;
+
+    typedef ScfRef< XclExpSst >                 XclExpSstRef;
+    typedef ScfRef< XclExpPalette >             XclExpPaletteRef;
+    typedef ScfRef< XclExpFontBuffer >          XclExpFontBfrRef;
+    typedef ScfRef< XclExpNumFmtBuffer >        XclExpNumFmtBfrRef;
+    typedef ScfRef< XclExpXFBuffer >            XclExpXFBfrRef;
+    typedef ScfRef< XclExpNameManager >         XclExpNameMgrRef;
+    typedef ScfRef< XclExpLinkManager >         XclExpLinkMgrRef;
+    typedef ScfRef< XclExpFilterManager >       XclExpFilterMgrRef;
+    typedef ScfRef< XclExpPivotTableManager >   XclExpPTableMgrRef;
+
+    XclExpTabInfoRef    mxTabInfo;          /// Calc->Excel sheet index conversion.
+    XclExpAddrConvRef   mxAddrConv;         /// The address converter.
+    XclExpFmlaCompRef   mxFmlaComp;         /// The formula compiler.
+    XclExpProgressRef   mxProgress;         /// The export progress bar.
+
+    XclExpSstRef        mxSst;              /// The shared string table.
+    XclExpPaletteRef    mxPalette;          /// The color buffer.
+    XclExpFontBfrRef    mxFontBfr;          /// All fonts in the file.
+    XclExpNumFmtBfrRef  mxNumFmtBfr;        /// All number formats in the file.
+    XclExpXFBfrRef      mxXFBfr;            /// All XF records in the file.
+    XclExpNameMgrRef    mxNameMgr;          /// Internal defined names.
+    XclExpLinkMgrRef    mxGlobLinkMgr;      /// Global link manager for defined names.
+    XclExpLinkMgrRef    mxLocLinkMgr;       /// Local link manager for a sheet.
+    XclExpFilterMgrRef  mxFilterMgr;        /// Manager for filtered areas in all sheets.
+    XclExpPTableMgrRef  mxPTableMgr;        /// All pivot tables and pivot caches.
+
+    bool                mbRelUrl;           /// true = Store URLs relative.
+
+    explicit            XclExpRootData( XclBiff eBiff, SfxMedium& rMedium,
+                            SotStorageRef xRootStrg, ScDocument& rDoc, rtl_TextEncoding eTextEnc );
+    virtual             ~XclExpRootData();
+};
+
+// ----------------------------------------------------------------------------
+
+/** Access to global data from other classes. */
+class XclExpRoot : public XclRoot
+{
+public:
+    explicit            XclExpRoot( XclExpRootData& rExpRootData );
+
+    /** Returns this root instance - for code readability in derived classes. */
+    inline const XclExpRoot& GetRoot() const { return *this; }
+    /** Returns true, if URLs should be stored relative to the document location. */
+    inline bool         IsRelUrl() const { return mrExpData.mbRelUrl; }
+
+    /** Returns the buffer for Calc->Excel sheet index conversion. */
+    XclExpTabInfo&      GetTabInfo() const;
+    /** Returns the address converter. */
+    XclExpAddressConverter& GetAddressConverter() const;
+    /** Returns the formula compiler to produce formula token arrays. */
+    XclExpFormulaCompiler& GetFormulaCompiler() const;
+    /** Returns the export progress bar. */
+    XclExpProgressBar&  GetProgressBar() const;
+
+    /** Returns the shared string table. */
+    XclExpSst&          GetSst() const;
+    /** Returns the color buffer. */
+    XclExpPalette&      GetPalette() const;
+    /** Returns the font buffer. */
+    XclExpFontBuffer&   GetFontBuffer() const;
+    /** Returns the number format buffer. */
+    XclExpNumFmtBuffer& GetNumFmtBuffer() const;
+    /** Returns the cell formatting attributes buffer. */
+    XclExpXFBuffer&     GetXFBuffer() const;
+    /** Returns the global link manager for defined names. */
+    XclExpLinkManager&  GetGlobalLinkManager() const;
+    /** Returns the local link manager for the current sheet. */
+    XclExpLinkManager&  GetLocalLinkManager() const;
+    /** Returns the buffer that contains internal defined names. */
+    XclExpNameManager&  GetNameManager() const;
+    /** Returns the filter manager. */
+    XclExpFilterManager& GetFilterManager() const;
+    /** Returns the pivot table manager. */
+    XclExpPivotTableManager& GetPivotTableManager() const;
+
+    /** Is called when export filter starts to create the Excel document (all BIFF versions). */
+    void                InitializeConvert();
+    /** Is called when export filter starts to create the workbook global data (>=BIFF5). */
+    void                InitializeGlobals();
+    /** Is called when export filter starts to create data for a single sheet (all BIFF versions). */
+    void                InitializeTable( SCTAB nScTab );
+    /** Is called before export filter starts to write the records to the stream. */
+    void                InitializeSave();
+    /** Returns the reference to a record (or record list) representing a root object.
+        @param nRecId  Identifier that specifies which record is returned. */
+    XclExpRecordRef     CreateRecord( sal_uInt16 nRecId ) const;
+
+    bool                IsDocumentEncrypted() const;
+
+    const String        GetPassword() const;
+
+private:
+
+    /** Returns the local or global link manager, depending on current context. */
+    XclExpRootData::XclExpLinkMgrRef GetLocalLinkMgrRef() const;
+
+private:
+    mutable XclExpRootData& mrExpData;      /// Reference to the global export data struct.
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xetable.hxx sc/source/filter/xlsx/xetable.hxx
index 2beb423..66a9e06 100644
--- sc/source/filter/xlsx/xetable.hxx
+++ sc/source/filter/xlsx/xetable.hxx
@@ -73,7 +73,7 @@ class XclExpRangeFmlaBase : public XclExpRecord
 {
 public:
     /** Returns true, if the passed cell position is equal to own base position. */
-    bool                IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const;
+    bool                IsBasePos( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const;
 
     /** Derived classes create the token array for a corresponding FORMULA cell record. */
     virtual XclTokenArrayRef CreateCellTokenArray( const XclExpRoot& rRoot ) const = 0;
@@ -240,9 +240,9 @@ private:
     SCTAB               mnScTab;        /// Sheet index of this record.
     sal_uInt16          mnLastAppXclCol;/// Column index of last appended cell.
     sal_uInt16          mnColInpXclCol; /// Column index of column input cell.
-    sal_uInt16          mnColInpXclRow; /// Row index of column input cell.
+    sal_uInt32          mnColInpXclRow; /// Row index of column input cell.
     sal_uInt16          mnRowInpXclCol; /// Column index of row input cell.
-    sal_uInt16          mnRowInpXclRow; /// Row index of row input cell.
+    sal_uInt32          mnRowInpXclRow; /// Row index of row input cell.
     sal_uInt8           mnScMode;       /// Type of the multiple operation (Calc constant).
     bool                mbValid;        /// true = Contains valid references.
 };
@@ -289,7 +289,7 @@ public:
     /** Returns the (first) Excel column index of the cell(s). */
     inline sal_uInt16   GetXclCol() const { return maXclPos.mnCol; }
     /** Returns the Excel row index of the cell. */
-    inline sal_uInt16   GetXclRow() const { return maXclPos.mnRow; }
+    inline sal_uInt32   GetXclRow() const { return maXclPos.mnRow; }
 
     /** Derived classes return the column index of the last contained cell. */
     virtual sal_uInt16  GetLastXclCol() const = 0;
@@ -317,7 +317,7 @@ protected:
     /** Sets this record to a new column position. */
     inline void         SetXclCol( sal_uInt16 nXclCol ) { maXclPos.mnCol = nXclCol; }
     /** Sets this record to a new row position. */
-    inline void         SetXclRow( sal_uInt16 nXclRow ) { maXclPos.mnRow = nXclRow; }
+    inline void         SetXclRow( sal_uInt32 nXclRow ) { maXclPos.mnRow = nXclRow; }
 
 private:
     XclAddress          maXclPos;       /// Address of the cell.
@@ -900,11 +900,11 @@ public:
     /** Constructs the ROW record and converts the Calc row settings.
         @param bAlwaysEmpty  true = This row will not be filled with blank cells
             in the Finalize() function. */
-    explicit            XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
+    explicit            XclExpRow( const XclExpRoot& rRoot, sal_uInt32 nXclRow,
                             XclExpRowOutlineBuffer& rOutlineBfr, bool bAlwaysEmpty );
 
     /** Returns the excel row index of this ROW record. */
-    inline sal_uInt16   GetXclRow() const { return mnXclRow; }
+    inline sal_uInt32   GetXclRow() const { return mnXclRow; }
     /** Returns the height of the row in twips. */
     inline sal_uInt16   GetHeight() const { return mnHeight; }
     /** Returns true, if this row does not contain at least one valid cell. */
@@ -959,7 +959,7 @@ private:
     typedef XclExpRecordList< XclExpCellBase > XclExpCellList;
 
     XclExpCellList      maCellList;         /// List of cell records for this row.
-    sal_uInt16          mnXclRow;           /// Excel row index of this row.
+    sal_uInt32          mnXclRow;           /// Excel row index of this row.
     sal_uInt16          mnHeight;           /// Row height in twips.
     sal_uInt16          mnFlags;            /// Flags for the ROW record.
     sal_uInt16          mnXFIndex;          /// Default row formatting.
@@ -1002,7 +1002,7 @@ private:
     /** Returns access to the specified ROW record. Inserts preceding missing ROW records.
         @param bRowAlwaysEmpty  true = Created rows will not be filled with blank cells
             in the XclExpRow::Finalize() function. */
-    XclExpRow&          GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysEmpty );
+    XclExpRow&          GetOrCreateRow( sal_uInt32 nXclRow, bool bRowAlwaysEmpty );
 
 private:
     typedef XclExpRecordList< XclExpRow >   XclExpRowList;
@@ -1012,7 +1012,7 @@ private:
     XclExpRowOutlineBuffer maOutlineBfr;    /// Buffer for row outline groups.
     XclExpDimensions    maDimensions;       /// DIMENSIONS record for used area.
     XclExpRow*          mpLastUsedRow;      /// Last used row for faster access.
-    sal_uInt16          mnLastUsedXclRow;   /// Last used row for faster access.
+    sal_uInt32          mnLastUsedXclRow;   /// Last used row for faster access.
 };
 
 // ============================================================================
diff --git sc/source/filter/xlsx/xeview.hxx sc/source/filter/xlsx/xeview.hxx
index 5c54ecd..592d3ff 100644
--- sc/source/filter/xlsx/xeview.hxx
+++ sc/source/filter/xlsx/xeview.hxx
@@ -111,7 +111,7 @@ private:
 
 private:
     sal_uInt16          mnSplitX;           /// Split X position, or frozen column.
-    sal_uInt16          mnSplitY;           /// Split Y position, or frozen row.
+    sal_uInt32          mnSplitY;           /// Split Y position, or frozen row.
     XclAddress          maSecondXclPos;     /// First visible cell in additional panes.
     sal_uInt8           mnActivePane;       /// Active pane (with cell cursor).
 };
diff --git sc/source/filter/xlsx/xladdress.hxx sc/source/filter/xlsx/xladdress.hxx
new file mode 100644
index 0000000..1d3030a
--- /dev/null
+++ sc/source/filter/xlsx/xladdress.hxx
@@ -0,0 +1,153 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xladdress.hxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLADDRESS_HXX
+#define SC_XLADDRESS_HXX
+
+#include <vector>
+#include "address.hxx"
+
+class ScRangeList;
+class XclImpStream;
+class XclExpStream;
+
+// ============================================================================
+
+/** A 2D cell address struct with Excel column and row indexes. */
+struct XclAddress
+{
+    sal_uInt16          mnCol;
+    sal_uInt32          mnRow;
+
+    inline explicit     XclAddress( ScAddress::Uninitialized ) {}
+    inline explicit     XclAddress() : mnCol( 0 ), mnRow( 0 ) {}
+    inline explicit     XclAddress( sal_uInt16 nCol, sal_uInt32 nRow ) : mnCol( nCol ), mnRow( nRow ) {}
+
+    inline void         Set( sal_uInt16 nCol, sal_uInt32 nRow ) { mnCol = nCol; mnRow = nRow; }
+};
+
+inline bool operator==( const XclAddress& rL, const XclAddress& rR )
+{
+    return (rL.mnCol == rR.mnCol) && (rL.mnRow == rR.mnRow);
+}
+
+inline bool operator<( const XclAddress& rL, const XclAddress& rR )
+{
+    return (rL.mnCol < rR.mnCol) || ((rL.mnCol == rR.mnCol) && (rL.mnRow < rR.mnRow));
+}
+
+// ----------------------------------------------------------------------------
+
+/** A 2D cell range address struct with Excel column and row indexes. */
+struct XclRange
+{
+    XclAddress          maFirst;
+    XclAddress          maLast;
+
+    inline explicit     XclRange( ScAddress::Uninitialized e ) : maFirst( e ), maLast( e ) {}
+    inline explicit     XclRange() {}
+    inline explicit     XclRange( const XclAddress& rPos ) : maFirst( rPos ), maLast( rPos ) {}
+    inline explicit     XclRange( const XclAddress& rFirst, const XclAddress& rLast ) : maFirst( rFirst ), maLast( rLast ) {}
+    inline explicit     XclRange( sal_uInt16 nCol1, sal_uInt32 nRow1, sal_uInt16 nCol2, sal_uInt32 nRow2 ) :
+                            maFirst( nCol1, nRow1 ), maLast( nCol2, nRow2 ) {}
+
+    inline void         Set( const XclAddress& rFirst, const XclAddress& rLast )
+                            { maFirst = rFirst; maLast = rLast; }
+    inline void         Set( sal_uInt16 nCol1, sal_uInt32 nRow1, sal_uInt16 nCol2, sal_uInt32 nRow2 )
+                            { maFirst.Set( nCol1, nRow1 ); maLast.Set( nCol2, nRow2 ); }
+
+    inline sal_uInt16   GetColCount() const { return maLast.mnCol - maFirst.mnCol + 1; }
+    inline sal_uInt32   GetRowCount() const { return maLast.mnRow - maFirst.mnRow + 1; }
+    bool                Contains( const XclAddress& rPos ) const;
+};
+
+inline bool operator==( const XclRange& rL, const XclRange& rR )
+{
+    return (rL.maFirst == rR.maFirst) && (rL.maLast == rR.maLast);
+}
+
+inline bool operator<( const XclRange& rL, const XclRange& rR )
+{
+    return (rL.maFirst < rR.maFirst) || ((rL.maFirst == rR.maFirst) && (rL.maLast < rR.maLast));
+}
+
+// ----------------------------------------------------------------------------
+
+/** A 2D cell range address list with Excel column and row indexes. */
+class XclRangeList : public ::std::vector< XclRange >
+{
+public:
+    inline explicit     XclRangeList() {}
+
+    XclRange            GetEnclosingRange() const;
+};
+
+// ============================================================================
+
+class XclTracer;
+
+/** Base class for import/export address converters. */
+class XclAddressConverterBase
+{
+public:
+    explicit            XclAddressConverterBase( XclTracer& rTracer, const ScAddress& rMaxPos );
+    virtual             ~XclAddressConverterBase();
+
+    /** Returns whether the "some columns have been cut" warning box should be shown. */
+    inline bool         IsColTruncated() const { return mbColTrunc; }
+    /** Returns whether the "some rows have been cut" warning box should be shown. */
+    inline bool         IsRowTruncated() const { return mbRowTrunc; }
+    /** Returns whether the "some sheets have been cut" warning box should be shown. */
+    inline bool         IsTabTruncated() const { return mbTabTrunc; }
+
+    // ------------------------------------------------------------------------
+
+    /** Checks if the passed sheet index is valid.
+        @param nScTab  The sheet index to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the sheet index is not valid.
+        @return  true = Sheet index in nScTab is valid. */
+    bool                CheckScTab( SCTAB nScTab, bool bWarn );
+
+    // ------------------------------------------------------------------------
+protected:
+    XclTracer&          mrTracer;       /// Tracer for invalid addresses.
+    ScAddress           maMaxPos;       /// Default maximum position.
+    sal_uInt16          mnMaxCol;       /// Maximum column index, as 16-bit value.
+    sal_uInt32          mnMaxRow;       /// Maximum row index.
+    bool                mbColTrunc;     /// Flag for "columns truncated" warning box.
+    bool                mbRowTrunc;     /// Flag for "rows truncated" warning box.
+    bool                mbTabTrunc;     /// Flag for "tables truncated" warning box.
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xlescher.hxx sc/source/filter/xlsx/xlescher.hxx
new file mode 100644
index 0000000..d6c9b7c
--- /dev/null
+++ sc/source/filter/xlsx/xlescher.hxx
@@ -0,0 +1,454 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlescher.hxx,v $
+ * $Revision: 1.22.90.12 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLESCHER_HXX
+#define SC_XLESCHER_HXX
+
+#include <vcl/mapunit.hxx>
+#include "fapihelper.hxx"
+#include "xladdress.hxx"
+#include "xlstyle.hxx"
+
+namespace com { namespace sun { namespace star {
+    namespace drawing { class XShape; }
+    namespace awt { class XControlModel; }
+    namespace script { struct ScriptEventDescriptor; }
+} } }
+
+class SdrObject;
+class Rectangle;
+class ScDocument;
+class SvStream;
+class XclImpStream;
+class XclExpStream;
+
+// Constants and Enumerations =================================================
+
+// (0x001C) NOTE --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_NOTE                = 0x001C;
+const sal_uInt16 EXC_NOTE_VISIBLE           = 0x0002;
+const sal_uInt16 EXC_NOTE5_MAXLEN           = 2048;
+
+// (0x005D) OBJ ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_OBJ                 = 0x005D;
+
+const sal_uInt16 EXC_OBJ_INVALID_ID         = 0;
+
+// object types
+const sal_uInt16 EXC_OBJTYPE_GROUP          = 0;
+const sal_uInt16 EXC_OBJTYPE_LINE           = 1;
+const sal_uInt16 EXC_OBJTYPE_RECTANGLE      = 2;
+const sal_uInt16 EXC_OBJTYPE_OVAL           = 3;
+const sal_uInt16 EXC_OBJTYPE_ARC            = 4;
+const sal_uInt16 EXC_OBJTYPE_CHART          = 5;
+const sal_uInt16 EXC_OBJTYPE_TEXT           = 6;
+const sal_uInt16 EXC_OBJTYPE_BUTTON         = 7;
+const sal_uInt16 EXC_OBJTYPE_PICTURE        = 8;
+const sal_uInt16 EXC_OBJTYPE_POLYGON        = 9;        // new in BIFF4
+const sal_uInt16 EXC_OBJTYPE_CHECKBOX       = 11;       // new in BIFF5
+const sal_uInt16 EXC_OBJTYPE_OPTIONBUTTON   = 12;
+const sal_uInt16 EXC_OBJTYPE_EDIT           = 13;
+const sal_uInt16 EXC_OBJTYPE_LABEL          = 14;
+const sal_uInt16 EXC_OBJTYPE_DIALOG         = 15;
+const sal_uInt16 EXC_OBJTYPE_SPIN           = 16;
+const sal_uInt16 EXC_OBJTYPE_SCROLLBAR      = 17;
+const sal_uInt16 EXC_OBJTYPE_LISTBOX        = 18;
+const sal_uInt16 EXC_OBJTYPE_GROUPBOX       = 19;
+const sal_uInt16 EXC_OBJTYPE_DROPDOWN       = 20;
+const sal_uInt16 EXC_OBJTYPE_NOTE           = 25;       // new in BIFF8
+const sal_uInt16 EXC_OBJTYPE_DRAWING        = 30;
+const sal_uInt16 EXC_OBJTYPE_UNKNOWN        = 0xFFFF;   /// For internal use only.
+
+// BIFF3-BIFF5 flags
+const sal_uInt16 EXC_OBJ_HIDDEN             = 0x0100;
+const sal_uInt16 EXC_OBJ_VISIBLE            = 0x0200;
+const sal_uInt16 EXC_OBJ_PRINTABLE          = 0x0400;
+
+// BIFF5 line formatting
+const sal_uInt8 EXC_OBJ_LINE_AUTOCOLOR      = 64;
+
+const sal_uInt8 EXC_OBJ_LINE_SOLID          = 0;
+const sal_uInt8 EXC_OBJ_LINE_DASH           = 1;
+const sal_uInt8 EXC_OBJ_LINE_DOT            = 2;
+const sal_uInt8 EXC_OBJ_LINE_DASHDOT        = 3;
+const sal_uInt8 EXC_OBJ_LINE_DASHDOTDOT     = 4;
+const sal_uInt8 EXC_OBJ_LINE_MEDTRANS       = 5;
+const sal_uInt8 EXC_OBJ_LINE_DARKTRANS      = 6;
+const sal_uInt8 EXC_OBJ_LINE_LIGHTTRANS     = 7;
+const sal_uInt8 EXC_OBJ_LINE_NONE           = 255;
+
+const sal_uInt8 EXC_OBJ_LINE_HAIR           = 0;
+const sal_uInt8 EXC_OBJ_LINE_THIN           = 1;
+const sal_uInt8 EXC_OBJ_LINE_MEDIUM         = 2;
+const sal_uInt8 EXC_OBJ_LINE_THICK          = 3;
+
+const sal_uInt8 EXC_OBJ_LINE_AUTO           = 0x01;
+
+const sal_uInt8 EXC_OBJ_ARROW_NONE          = 0;
+const sal_uInt8 EXC_OBJ_ARROW_OPEN          = 1;
+const sal_uInt8 EXC_OBJ_ARROW_FILLED        = 2;
+const sal_uInt8 EXC_OBJ_ARROW_OPENBOTH      = 3;
+const sal_uInt8 EXC_OBJ_ARROW_FILLEDBOTH    = 4;
+
+const sal_uInt8 EXC_OBJ_ARROW_NARROW        = 0;
+const sal_uInt8 EXC_OBJ_ARROW_MEDIUM        = 1;
+const sal_uInt8 EXC_OBJ_ARROW_WIDE          = 2;
+
+const sal_uInt8 EXC_OBJ_LINE_TL             = 0;
+const sal_uInt8 EXC_OBJ_LINE_TR             = 1;
+const sal_uInt8 EXC_OBJ_LINE_BR             = 2;
+const sal_uInt8 EXC_OBJ_LINE_BL             = 3;
+
+// BIFF5 fill formatting
+const sal_uInt8 EXC_OBJ_FILL_AUTOCOLOR      = 65;
+
+const sal_uInt8 EXC_OBJ_FILL_AUTO           = 0x01;
+
+// BIFF5 frame formatting
+const sal_uInt16 EXC_OBJ_FRAME_SHADOW       = 0x0002;
+
+// BIFF5 text objects
+const sal_uInt8 EXC_OBJ_HOR_LEFT            = 1;
+const sal_uInt8 EXC_OBJ_HOR_CENTER          = 2;
+const sal_uInt8 EXC_OBJ_HOR_RIGHT           = 3;
+const sal_uInt8 EXC_OBJ_HOR_JUSTIFY         = 4;
+
+const sal_uInt8 EXC_OBJ_VER_TOP             = 1;
+const sal_uInt8 EXC_OBJ_VER_CENTER          = 2;
+const sal_uInt8 EXC_OBJ_VER_BOTTOM          = 3;
+const sal_uInt8 EXC_OBJ_VER_JUSTIFY         = 4;
+
+const sal_uInt16 EXC_OBJ_ORIENT_NONE        = 0;
+const sal_uInt16 EXC_OBJ_ORIENT_STACKED     = 1;        /// Stacked top to bottom.
+const sal_uInt16 EXC_OBJ_ORIENT_90CCW       = 2;        /// 90 degr. counterclockwise.
+const sal_uInt16 EXC_OBJ_ORIENT_90CW        = 3;        /// 90 degr. clockwise.
+
+const sal_uInt16 EXC_OBJ_TEXT_AUTOSIZE      = 0x0080;
+const sal_uInt16 EXC_OBJ_TEXT_LOCKED        = 0x0200;
+
+const sal_Int32 EXC_OBJ_TEXT_MARGIN         = 20000;    /// Automatic text margin (EMUs).
+
+// BIFF5 arc objects
+const sal_uInt8 EXC_OBJ_ARC_TR              = 0;
+const sal_uInt8 EXC_OBJ_ARC_TL              = 1;
+const sal_uInt8 EXC_OBJ_ARC_BL              = 2;
+const sal_uInt8 EXC_OBJ_ARC_BR              = 3;
+
+// BIFF5 polygon objects
+const sal_uInt16 EXC_OBJ_POLY_CLOSED        = 0x0100;
+
+// BIFF5 pictures/OLE objects
+const sal_uInt16 EXC_OBJ_PIC_MANUALSIZE     = 0x0001;
+const sal_uInt16 EXC_OBJ_PIC_DDE            = 0x0002;
+const sal_uInt16 EXC_OBJ_PIC_SYMBOL         = 0x0008;
+const sal_uInt16 EXC_OBJ_PIC_CONTROL        = 0x0010;   /// Form control (BIFF8).
+const sal_uInt16 EXC_OBJ_PIC_CTLSSTREAM     = 0x0020;   /// Data in Ctls stream (BIFF8).
+const sal_uInt16 EXC_OBJ_PIC_AUTOLOAD       = 0x0200;   /// Auto-load form control (BIFF8).
+
+// BIFF5 button objects
+const sal_uInt16 EXC_OBJ_BUTTON_DEFAULT     = 0x0001;
+const sal_uInt16 EXC_OBJ_BUTTON_HELP        = 0x0002;
+const sal_uInt16 EXC_OBJ_BUTTON_CANCEL      = 0x0004;
+const sal_uInt16 EXC_OBJ_BUTTON_CLOSE       = 0x0008;
+
+// BIFF5 checkboxs, radio buttons
+const sal_uInt16 EXC_OBJ_CHECKBOX_UNCHECKED = 0;
+const sal_uInt16 EXC_OBJ_CHECKBOX_CHECKED   = 1;
+const sal_uInt16 EXC_OBJ_CHECKBOX_TRISTATE  = 2;
+const sal_uInt16 EXC_OBJ_CHECKBOX_FLAT      = 0x0001;
+
+// BIFF5 editbox objects
+const sal_uInt16 EXC_OBJ_EDIT_TEXT          = 0;
+const sal_uInt16 EXC_OBJ_EDIT_INTEGER       = 1;
+const sal_uInt16 EXC_OBJ_EDIT_DOUBLE        = 2;
+const sal_uInt16 EXC_OBJ_EDIT_REFERENCE     = 3;
+const sal_uInt16 EXC_OBJ_EDIT_FORMULA       = 4;
+
+// BIFF5 scrollbars/spinbuttons
+const sal_uInt16 EXC_OBJ_SCROLLBAR_MIN      = 0;
+const sal_uInt16 EXC_OBJ_SCROLLBAR_MAX      = 30000;
+
+const sal_uInt16 EXC_OBJ_SCROLLBAR_HOR      = 0x0001;
+
+const sal_uInt16 EXC_OBJ_SCROLLBAR_DEFFLAGS = 0x0001;
+const sal_uInt16 EXC_OBJ_SCROLLBAR_FLAT     = 0x0008;
+
+// BIFF5 listboxes/dropdowns
+const sal_uInt8 EXC_OBJ_LISTBOX_SINGLE      = 0;        /// Single selection.
+const sal_uInt8 EXC_OBJ_LISTBOX_MULTI       = 1;        /// Multi selection.
+const sal_uInt8 EXC_OBJ_LISTBOX_RANGE       = 2;        /// Range selection.
+
+const sal_uInt16 EXC_OBJ_LISTBOX_EDIT       = 0x0002;
+const sal_uInt16 EXC_OBJ_LISTBOX_FLAT       = 0x0008;
+
+// BIFF5 dropdown listboxes
+const sal_uInt16 EXC_OBJ_DROPDOWN_LISTBOX   = 0;        /// Listbox, text not editable.
+const sal_uInt16 EXC_OBJ_DROPDOWN_COMBOBOX  = 1;        /// Dropdown listbox with editable text.
+const sal_uInt16 EXC_OBJ_DROPDOWN_SIMPLE    = 2;        /// Dropdown button only, no text area.
+const sal_uInt16 EXC_OBJ_DROPDOWN_MAX       = 3;
+const sal_uInt16 EXC_OBJ_DROPDOWN_FILTERED  = 0x0008;   /// Drowdown style: filtered.
+
+// BIFF5 groupboxes
+const sal_uInt16 EXC_OBJ_GROUPBOX_FLAT      = 0x0001;
+
+// BIFF8 sub records
+const sal_uInt16 EXC_ID_OBJEND              = 0x0000;   /// End of OBJ.
+const sal_uInt16 EXC_ID_OBJMACRO            = 0x0004;   /// Macro link.
+const sal_uInt16 EXC_ID_OBJBUTTON           = 0x0005;   /// Button data.
+const sal_uInt16 EXC_ID_OBJGMO              = 0x0006;   /// Group marker.
+const sal_uInt16 EXC_ID_OBJCF               = 0x0007;   /// Clipboard format.
+const sal_uInt16 EXC_ID_OBJFLAGS            = 0x0008;   /// Option flags.
+const sal_uInt16 EXC_ID_OBJPICTFMLA         = 0x0009;   /// OLE link formula.
+const sal_uInt16 EXC_ID_OBJCBLS             = 0x000A;   /// Check box/radio button data.
+const sal_uInt16 EXC_ID_OBJRBO              = 0x000B;   /// Radio button group data.
+const sal_uInt16 EXC_ID_OBJSBS              = 0x000C;   /// Scroll bar data.
+const sal_uInt16 EXC_ID_OBJNTS              = 0x000D;   /// Note data.
+const sal_uInt16 EXC_ID_OBJSBSFMLA          = 0x000E;   /// Scroll bar/list box/combo box cell link.
+const sal_uInt16 EXC_ID_OBJGBODATA          = 0x000F;   /// Group box data.
+const sal_uInt16 EXC_ID_OBJEDODATA          = 0x0010;   /// Edit box data.
+const sal_uInt16 EXC_ID_OBJRBODATA          = 0x0011;   /// Radio button group data.
+const sal_uInt16 EXC_ID_OBJCBLSDATA         = 0x0012;   /// Check box/radio button data.
+const sal_uInt16 EXC_ID_OBJLBSDATA          = 0x0013;   /// List box/combo box data.
+const sal_uInt16 EXC_ID_OBJCBLSFMLA         = 0x0014;   /// Check box/radio button cell link.
+const sal_uInt16 EXC_ID_OBJCMO              = 0x0015;   /// Common object settings.
+const sal_uInt16 EXC_ID_OBJUNKNOWN          = 0xFFFF;   /// For internal use only.
+
+// BIFF8 OBJCMO: flags
+const sal_uInt16 EXC_OBJCMO_PRINTABLE       = 0x0010;   /// Object printable.
+const sal_uInt16 EXC_OBJCMO_AUTOLINE        = 0x2000;   /// Automatic line formatting.
+const sal_uInt16 EXC_OBJCMO_AUTOFILL        = 0x4000;   /// Automatic fill formatting.
+
+/** Value binding mode for cells linked to form controls. */
+enum XclCtrlBindMode
+{
+    EXC_CTRL_BINDCONTENT,       /// Binds cell to content of control.
+    EXC_CTRL_BINDPOSITION       /// Binds cell to position in control (e.g. listbox selection index).
+};
+
+// (0x007F) IMGDATA -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID3_IMGDATA            = 0x007F;
+const sal_uInt16 EXC_ID8_IMGDATA            = 0x00E9;
+
+const sal_uInt16 EXC_IMGDATA_WMF            = 2;
+const sal_uInt16 EXC_IMGDATA_BMP            = 9;
+
+const sal_uInt16 EXC_IMGDATA_WIN            = 1;
+const sal_uInt16 EXC_IMGDATA_MAC            = 2;
+
+const sal_uInt32 EXC_IMGDATA_MAXREC8        = 0x201C;
+const sal_uInt32 EXC_IMGDATA_MAXCONT8       = 0x2014;
+
+// (0x00A9) COORDLIST ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_COORDLIST           = 0x00A9;
+
+// (0x00EB) MSODRAWINGGROUP ---------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGGROUP     = 0x00EB;
+
+// (0x00EC) MSODRAWING --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWING          = 0x00EC;
+
+// additional flags not extant in svx headers
+const sal_uInt16 EXC_ESC_ANCHOR_POSLOCKED   = 0x0001;
+const sal_uInt16 EXC_ESC_ANCHOR_SIZELOCKED  = 0x0002;
+const sal_uInt16 EXC_ESC_ANCHOR_LOCKED      = EXC_ESC_ANCHOR_POSLOCKED|EXC_ESC_ANCHOR_SIZELOCKED;
+
+// (0x00ED) MSODRAWINGSELECTION -----------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGSEL       = 0x00ED;
+
+// (0x01B6) TXO ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_TXO                 = 0x01B6;
+
+// TXO constants are eqzal to BIFF5 OBJ text object flags
+
+// Structs and classes ========================================================
+
+/** Identifies a drawing object by sheet index and object identifier. */
+struct XclObjId
+{
+    SCTAB               mnScTab;        /// Calc sheet index.
+    sal_uInt16          mnObjId;        /// Excel object identifier.
+
+    explicit            XclObjId();
+    explicit            XclObjId( SCTAB nScTab, sal_uInt16 nObjId );
+};
+
+bool operator==( const XclObjId& rL, const XclObjId& rR );
+bool operator<( const XclObjId& rL, const XclObjId& rR );
+
+// ----------------------------------------------------------------------------
+
+/** Represents the position (anchor) of an object in a Calc document. */
+struct XclObjAnchor : public XclRange
+{
+    SCTAB               mnScTab;    /// Calc sheet index.
+    sal_uInt16          mnLX;       /// X offset in left column (1/1024 of column width).
+    sal_uInt16          mnTY;       /// Y offset in top row (1/256 of row height).
+    sal_uInt16          mnRX;       /// X offset in right column (1/1024 of column width).
+    sal_uInt16          mnBY;       /// Y offset in bottom row (1/256 of row height).
+
+    explicit            XclObjAnchor( SCTAB nScTab );
+
+    /** Calculates a rectangle from the contained coordinates. */
+    Rectangle           GetRect( ScDocument& rDoc, MapUnit eMapUnit ) const;
+    /** Initializes the anchor coordinates from a rectangle. */
+    void                SetRect( ScDocument& rDoc, const Rectangle& rRect, MapUnit eMapUnit );
+};
+
+template< typename StreamType >
+StreamType& operator>>( StreamType& rStrm, XclObjAnchor& rAnchor )
+{
+    return rStrm
+        >> rAnchor.maFirst.mnCol >> rAnchor.mnLX
+        >> rAnchor.maFirst.mnRow >> rAnchor.mnTY
+        >> rAnchor.maLast.mnCol  >> rAnchor.mnRX
+        >> rAnchor.maLast.mnRow  >> rAnchor.mnBY;
+}
+
+template< typename StreamType >
+StreamType& operator<<( StreamType& rStrm, const XclObjAnchor& rAnchor )
+{
+    return rStrm
+        << rAnchor.maFirst.mnCol << rAnchor.mnLX
+        << rAnchor.maFirst.mnRow << rAnchor.mnTY
+        << rAnchor.maLast.mnCol  << rAnchor.mnRX
+        << rAnchor.maLast.mnRow  << rAnchor.mnBY;
+}
+
+// ----------------------------------------------------------------------------
+
+struct XclObjLineData
+{
+    sal_uInt8           mnColorIdx;
+    sal_uInt8           mnStyle;
+    sal_uInt8           mnWidth;
+    sal_uInt8           mnAuto;
+
+    explicit            XclObjLineData();
+
+    inline bool         IsAuto() const { return ::get_flag( mnAuto, EXC_OBJ_LINE_AUTO ); }
+    inline bool         IsVisible() const { return IsAuto() || (mnStyle != EXC_OBJ_LINE_NONE); }
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclObjLineData& rLineData );
+
+// ----------------------------------------------------------------------------
+
+struct XclObjFillData
+{
+    sal_uInt8           mnBackColorIdx;
+    sal_uInt8           mnPattColorIdx;
+    sal_uInt8           mnPattern;
+    sal_uInt8           mnAuto;
+
+    explicit            XclObjFillData();
+
+    inline bool         IsAuto() const { return ::get_flag( mnAuto, EXC_OBJ_FILL_AUTO ); }
+    inline bool         IsFilled() const { return IsAuto() || (mnPattern != EXC_PATT_NONE); }
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclObjFillData& rFillData );
+
+// ----------------------------------------------------------------------------
+
+struct XclObjTextData
+{
+    sal_uInt16          mnTextLen;
+    sal_uInt16          mnFormatSize;
+    sal_uInt16          mnLinkSize;
+    sal_uInt16          mnDefFontIdx;
+    sal_uInt16          mnFlags;
+    sal_uInt16          mnOrient;
+    sal_uInt16          mnButtonFlags;
+    sal_uInt16          mnShortcut;
+    sal_uInt16          mnShortcutEA;
+
+    explicit            XclObjTextData();
+
+    /** Reads text data from a BIFF3/BIFF4 OBJ record. */
+    void                ReadObj3( XclImpStream& rStrm );
+    /** Reads text data from a BIFF5 OBJ record. */
+    void                ReadObj5( XclImpStream& rStrm );
+    /** Reads text data from a BIFF8 TXO record. */
+    void                ReadTxo8( XclImpStream& rStrm );
+
+    inline sal_uInt8    GetHorAlign() const { return ::extract_value< sal_uInt8 >( mnFlags, 1, 3 ); }
+    inline sal_uInt8    GetVerAlign() const { return ::extract_value< sal_uInt8 >( mnFlags, 4, 3 ); }
+};
+
+// ============================================================================
+
+enum XclTbxEventType
+{
+    EXC_TBX_EVENT_ACTION,       /// XActionListener.actionPerformed
+    EXC_TBX_EVENT_MOUSE,        /// XMouseListener.mouseReleased
+    EXC_TBX_EVENT_TEXT,         /// XTextListener.textChanged
+    EXC_TBX_EVENT_VALUE,        /// XAdjustmentListener.adjustmentValueChanged
+    EXC_TBX_EVENT_CHANGE        /// XChangeListener.changed
+};
+
+// ----------------------------------------------------------------------------
+
+/** Provides static helper functions for form controls. */
+class XclControlHelper
+{
+public:
+    /** Returns the API control model from the passed API shape object. */
+    static ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >
+                        GetControlModel( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+
+    /** Returns the Calc macro name from an Excel macro name. */
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+
+    /** Returns the Excel macro name from a Calc macro name. */
+    static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
+
+    /** Fills the macro descriptor according to the passed macro name. */
+    static bool         FillMacroDescriptor(
+                            ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
+                            XclTbxEventType eEventType,
+                            const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+    /** Tries to extract an Excel macro name from the passed macro descriptor. */
+    static String       ExtractFromMacroDescriptor(
+                            const ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
+                            XclTbxEventType eEventType );
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/xlpivot.hxx sc/source/filter/xlsx/xlpivot.hxx
new file mode 100644
index 0000000..8b5bd4e
--- /dev/null
+++ sc/source/filter/xlsx/xlpivot.hxx
@@ -0,0 +1,820 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlpivot.hxx,v $
+ * $Revision: 1.12.32.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLPIVOT_HXX
+#define SC_XLPIVOT_HXX
+
+#include <com/sun/star/sheet/GeneralFunction.hpp>
+#include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
+#include <com/sun/star/sheet/DataPilotFieldSortMode.hpp>
+#include <com/sun/star/sheet/DataPilotFieldShowItemsMode.hpp>
+#include <com/sun/star/sheet/DataPilotFieldLayoutMode.hpp>
+#include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
+#include <com/sun/star/sheet/DataPilotFieldReferenceItemType.hpp>
+#include <tools/datetime.hxx>
+#include "ftools.hxx"
+#include "xladdress.hxx"
+#include "dpobject.hxx"
+
+#include <memory>
+
+class XclImpStream;
+class XclExpStream;
+
+// Constants and Enumerations =================================================
+
+// misc -----------------------------------------------------------------------
+
+#define EXC_STORAGE_PTCACHE         CREATE_STRING( "_SX_DB_CUR" )
+
+// strings
+const sal_uInt16 EXC_PT_NOSTRING            = 0xFFFF;
+const sal_uInt16 EXC_PT_MAXSTRLEN           = 0xFFFE;
+
+// pivot cache fields
+const size_t EXC_PC_MAXFIELDCOUNT           = 0xFFFE;
+const sal_uInt16 EXC_PC_NOFIELD             = 0xFFFF;
+const xub_StrLen EXC_PC_MAXSTRLEN           = 255;
+
+// pivot cache items
+const size_t EXC_PC_MAXITEMCOUNT            = 32500;
+const sal_uInt16 EXC_PC_NOITEM              = 0xFFFF;
+
+// pivot table fields
+const sal_uInt16 EXC_PT_MAXFIELDCOUNT       = 0xFFFE;
+const sal_uInt16 EXC_PT_MAXROWCOLCOUNT      = EXC_PT_MAXFIELDCOUNT;
+const sal_uInt16 EXC_PT_MAXPAGECOUNT        = 256;
+const sal_uInt16 EXC_PT_MAXDATACOUNT        = 256;
+
+// pivot table items
+const sal_uInt16 EXC_PT_MAXITEMCOUNT        = 32500;
+
+const sal_uInt16 EXC_PT_AUTOFMT_HEADER      = 0x810;
+const sal_uInt16 EXC_PT_AUTOFMT_ZERO        = 0;
+const sal_uInt32 EXC_PT_AUTOFMT_FLAGS       = 0x20;
+
+/** Data type of a pivot cache item. */
+enum XclPCItemType
+{
+    EXC_PCITEM_INVALID,         /// Special state, not used in Excel files.
+    EXC_PCITEM_EMPTY,           /// Empty cell.
+    EXC_PCITEM_TEXT,            /// String data.
+    EXC_PCITEM_DOUBLE,          /// Floating-point value.
+    EXC_PCITEM_DATETIME,        /// Date/time.
+    EXC_PCITEM_INTEGER,         /// 16-bit integer value.
+    EXC_PCITEM_BOOL,            /// Boolean value.
+    EXC_PCITEM_ERROR            /// Error code.
+};
+
+/** Specifies the type of a pivot cache field. */
+enum XclPCFieldType
+{
+    EXC_PCFIELD_STANDARD,       /// Standard field without grouping.
+    EXC_PCFIELD_STDGROUP,       /// Standard grouping field.
+    EXC_PCFIELD_NUMGROUP,       /// Numeric grouping field.
+    EXC_PCFIELD_DATEGROUP,      /// First date grouping field (opt. with child grouping field).
+    EXC_PCFIELD_DATECHILD,      /// Additional date grouping field.
+    EXC_PCFIELD_CALCED,         /// Calculated field.
+    EXC_PCFIELD_UNKNOWN         /// Unknown field state, handled like standard field.
+};
+
+// (0x0051,0x0052) DCONREF, DCONNAME ------------------------------------------
+
+const sal_uInt16 EXC_ID_DCONREF             = 0x0051;
+const sal_uInt16 EXC_ID_DCONNAME            = 0x0052;
+
+// (0x00B0) SXVIEW ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVIEW              = 0x00B0;
+
+const sal_uInt16 EXC_SXVIEW_ROWGRAND        = 0x0001;
+const sal_uInt16 EXC_SXVIEW_COLGRAND        = 0x0002;
+const sal_uInt16 EXC_SXVIEW_DEFAULTFLAGS    = 0x0208;
+
+const sal_uInt16 EXC_SXVIEW_DATALAST        = 0xFFFF;
+const sal_uInt16 EXC_SXVIEW_AUTOFMT         = 0x0001;
+
+// (0x00B1) SXVD --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVD                = 0x00B1;
+
+const sal_uInt16 EXC_SXVD_AXIS_NONE         = 0x0000;
+const sal_uInt16 EXC_SXVD_AXIS_ROW          = 0x0001;
+const sal_uInt16 EXC_SXVD_AXIS_COL          = 0x0002;
+const sal_uInt16 EXC_SXVD_AXIS_PAGE         = 0x0004;
+const sal_uInt16 EXC_SXVD_AXIS_DATA         = 0x0008;
+const sal_uInt16 EXC_SXVD_AXIS_ROWCOL       = EXC_SXVD_AXIS_ROW | EXC_SXVD_AXIS_COL;
+const sal_uInt16 EXC_SXVD_AXIS_ROWCOLPAGE   = EXC_SXVD_AXIS_ROWCOL | EXC_SXVD_AXIS_PAGE;
+
+const sal_uInt16 EXC_SXVD_SUBT_NONE         = 0x0000;
+const sal_uInt16 EXC_SXVD_SUBT_DEFAULT      = 0x0001;
+const sal_uInt16 EXC_SXVD_SUBT_SUM          = 0x0002;
+const sal_uInt16 EXC_SXVD_SUBT_COUNT        = 0x0004;
+const sal_uInt16 EXC_SXVD_SUBT_AVERAGE      = 0x0008;
+const sal_uInt16 EXC_SXVD_SUBT_MAX          = 0x0010;
+const sal_uInt16 EXC_SXVD_SUBT_MIN          = 0x0020;
+const sal_uInt16 EXC_SXVD_SUBT_PROD         = 0x0040;
+const sal_uInt16 EXC_SXVD_SUBT_COUNTNUM     = 0x0080;
+const sal_uInt16 EXC_SXVD_SUBT_STDDEV       = 0x0100;
+const sal_uInt16 EXC_SXVD_SUBT_STDDEVP      = 0x0200;
+const sal_uInt16 EXC_SXVD_SUBT_VAR          = 0x0400;
+const sal_uInt16 EXC_SXVD_SUBT_VARP         = 0x0800;
+
+const sal_uInt16 EXC_SXVD_DEFAULT_CACHE     = EXC_PC_NOFIELD;
+
+// (0x00B2) SXVI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVI                = 0x00B2;
+
+const sal_uInt16 EXC_SXVI_TYPE_PAGE         = 0x00FE;
+const sal_uInt16 EXC_SXVI_TYPE_NULL         = 0x00FF;
+const sal_uInt16 EXC_SXVI_TYPE_DATA         = 0x0000;
+const sal_uInt16 EXC_SXVI_TYPE_DEFAULT      = 0x0001;
+const sal_uInt16 EXC_SXVI_TYPE_SUM          = 0x0002;
+const sal_uInt16 EXC_SXVI_TYPE_COUNT        = 0x0003;
+const sal_uInt16 EXC_SXVI_TYPE_AVERAGE      = 0x0004;
+const sal_uInt16 EXC_SXVI_TYPE_MAX          = 0x0005;
+const sal_uInt16 EXC_SXVI_TYPE_MIN          = 0x0006;
+const sal_uInt16 EXC_SXVI_TYPE_PROD         = 0x0007;
+const sal_uInt16 EXC_SXVI_TYPE_COUNTNUM     = 0x0008;
+const sal_uInt16 EXC_SXVI_TYPE_STDDEV       = 0x0009;
+const sal_uInt16 EXC_SXVI_TYPE_STDDEVP      = 0x000A;
+const sal_uInt16 EXC_SXVI_TYPE_VAR          = 0x000B;
+const sal_uInt16 EXC_SXVI_TYPE_VARP         = 0x000C;
+const sal_uInt16 EXC_SXVI_TYPE_GRAND        = 0x000D;
+
+const sal_uInt16 EXC_SXVI_DEFAULTFLAGS      = 0x0000;
+const sal_uInt16 EXC_SXVI_HIDDEN            = 0x0001;
+const sal_uInt16 EXC_SXVI_HIDEDETAIL        = 0x0002;
+const sal_uInt16 EXC_SXVI_FORMULA           = 0x0004;
+const sal_uInt16 EXC_SXVI_MISSING           = 0x0008;
+
+const sal_uInt16 EXC_SXVI_DEFAULT_CACHE     = EXC_PC_NOFIELD;
+
+// (0x00B4) SXIVD -------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXIVD               = 0x00B4;
+const sal_uInt16 EXC_SXIVD_DATA             = 0xFFFE;
+
+// (0x00B5) SXLI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXLI                = 0x00B5;
+const sal_uInt16 EXC_SXLI_DEFAULTFLAGS      = 0x0000;
+
+// (0x00B6) SXPI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXPI                = 0x00B6;
+const sal_uInt16 EXC_SXPI_ALLITEMS          = 0x7FFD;
+
+// (0x00C5) SXDI --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDI                = 0x00C5;
+
+const sal_uInt16 EXC_SXDI_FUNC_SUM          = 0x0000;
+const sal_uInt16 EXC_SXDI_FUNC_COUNT        = 0x0001;
+const sal_uInt16 EXC_SXDI_FUNC_AVERAGE      = 0x0002;
+const sal_uInt16 EXC_SXDI_FUNC_MAX          = 0x0003;
+const sal_uInt16 EXC_SXDI_FUNC_MIN          = 0x0004;
+const sal_uInt16 EXC_SXDI_FUNC_PRODUCT      = 0x0005;
+const sal_uInt16 EXC_SXDI_FUNC_COUNTNUM     = 0x0006;
+const sal_uInt16 EXC_SXDI_FUNC_STDDEV       = 0x0007;
+const sal_uInt16 EXC_SXDI_FUNC_STDDEVP      = 0x0008;
+const sal_uInt16 EXC_SXDI_FUNC_VAR          = 0x0009;
+const sal_uInt16 EXC_SXDI_FUNC_VARP         = 0x000A;
+
+const sal_uInt16 EXC_SXDI_REF_NORMAL        = 0x0000;
+const sal_uInt16 EXC_SXDI_REF_DIFF          = 0x0001;
+const sal_uInt16 EXC_SXDI_REF_PERC          = 0x0002;
+const sal_uInt16 EXC_SXDI_REF_PERC_DIFF     = 0x0003;
+const sal_uInt16 EXC_SXDI_REF_RUN_TOTAL     = 0x0004;
+const sal_uInt16 EXC_SXDI_REF_PERC_ROW      = 0x0005;
+const sal_uInt16 EXC_SXDI_REF_PERC_COL      = 0x0006;
+const sal_uInt16 EXC_SXDI_REF_PERC_TOTAL    = 0x0007;
+const sal_uInt16 EXC_SXDI_REF_INDEX         = 0x0008;
+
+const sal_uInt16 EXC_SXDI_PREVITEM          = 0x7FFB;
+const sal_uInt16 EXC_SXDI_NEXTITEM          = 0x7FFC;
+
+// (0x00C6) SXDB --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDB                = 0x00C6;
+
+const sal_uInt16 EXC_SXDB_SAVEDATA          = 0x0001;
+const sal_uInt16 EXC_SXDB_INVALID           = 0x0002;
+const sal_uInt16 EXC_SXDB_REFRESH_LOAD      = 0x0004;
+const sal_uInt16 EXC_SXDB_OPT_CACHE         = 0x0008;
+const sal_uInt16 EXC_SXDB_BG_QUERY          = 0x0010;
+const sal_uInt16 EXC_SXDB_ENABLE_REFRESH    = 0x0020;
+const sal_uInt16 EXC_SXDB_DEFAULTFLAGS      = EXC_SXDB_SAVEDATA | EXC_SXDB_ENABLE_REFRESH;
+
+const sal_uInt16 EXC_SXDB_BLOCKRECS         = 0x1FFF;
+
+const sal_uInt16 EXC_SXDB_SRC_SHEET         = 0x0001;
+const sal_uInt16 EXC_SXDB_SRC_EXTERN        = 0x0002;
+const sal_uInt16 EXC_SXDB_SRC_CONSOLID      = 0x0004;
+const sal_uInt16 EXC_SXDB_SRC_SCENARIO      = 0x0008;
+
+// (0x00C7) SXFIELD -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFIELD             = 0x00C7;
+
+const sal_uInt16 EXC_SXFIELD_HASITEMS       = 0x0001;
+const sal_uInt16 EXC_SXFIELD_POSTPONE       = 0x0002;
+const sal_uInt16 EXC_SXFIELD_CALCED         = 0x0004;
+const sal_uInt16 EXC_SXFIELD_HASCHILD       = 0x0008;
+const sal_uInt16 EXC_SXFIELD_NUMGROUP       = 0x0010;
+const sal_uInt16 EXC_SXFIELD_16BIT          = 0x0200;
+
+const sal_uInt16 EXC_SXFIELD_DATA_MASK      = 0x0DE0;
+// known data types
+const sal_uInt16 EXC_SXFIELD_DATA_NONE      = 0x0000;   /// Special state for groupings.
+const sal_uInt16 EXC_SXFIELD_DATA_STR       = 0x0480;   /// Only strings, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_INT       = 0x0520;   /// Only integers, opt. with doubles.
+const sal_uInt16 EXC_SXFIELD_DATA_DBL       = 0x0560;   /// Only doubles, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_STR_INT   = 0x05A0;   /// Only strings and integers, opt. with doubles.
+const sal_uInt16 EXC_SXFIELD_DATA_STR_DBL   = 0x05E0;   /// Only strings and doubles, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_DATE      = 0x0900;   /// Only dates, nothing else.
+const sal_uInt16 EXC_SXFIELD_DATA_DATE_EMP  = 0x0980;   /// Dates and empty strings, nothing else (?).
+const sal_uInt16 EXC_SXFIELD_DATA_DATE_NUM  = 0x0D00;   /// Dates with integers or doubles without strings.
+const sal_uInt16 EXC_SXFIELD_DATA_DATE_STR  = 0x0D80;   /// Dates and strings, opt. with integers or doubles.
+
+const sal_uInt16 EXC_SXFIELD_INDEX_MIN      = 0;        /// List index for minimum item in groupings.
+const sal_uInt16 EXC_SXFIELD_INDEX_MAX      = 1;        /// List index for maximum item in groupings.
+const sal_uInt16 EXC_SXFIELD_INDEX_STEP     = 2;        /// List index for step item in groupings.
+
+// (0x00C8) SXINDEXLIST -------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXINDEXLIST         = 0x00C8;
+
+// (0x00C9) SXDOUBLE ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDOUBLE            = 0x00C9;
+
+// (0x00CA) SXBOOLEAN ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXBOOLEAN           = 0x00CA;
+
+// (0x00CB) SXERROR -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXERROR             = 0x00CB;
+
+// (0x00CC) SXINTEGER ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXINTEGER           = 0x00CC;
+
+// (0x00CD) SXSTRING ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXSTRING            = 0x00CD;
+
+// (0x00CE) SXDATETIME --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDATETIME          = 0x00CE;
+
+// (0x00CF) SXEMPTY -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXEMPTY             = 0x00CF;
+
+// (0x00D5) SXIDSTM -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXIDSTM             = 0x00D5;
+
+// (0x00D8) SXNUMGROUP --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXNUMGROUP          = 0x00D8;
+
+const sal_uInt16 EXC_SXNUMGROUP_AUTOMIN     = 0x0001;
+const sal_uInt16 EXC_SXNUMGROUP_AUTOMAX     = 0x0002;
+
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_SEC    = 1;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_MIN    = 2;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_HOUR   = 3;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_DAY    = 4;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_MONTH  = 5;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_QUART  = 6;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_YEAR   = 7;
+const sal_uInt16 EXC_SXNUMGROUP_TYPE_NUM    = 8;
+
+// (0x00D9) SXGROUPINFO -------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXGROUPINFO         = 0x00D9;
+
+// (0x00DC) SXEXT -------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXEXT               = 0x00DC;
+
+// (0x00E3) SXVS --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVS                = 0x00E3;
+
+const sal_uInt16 EXC_SXVS_UNKNOWN           = 0x0000;
+const sal_uInt16 EXC_SXVS_SHEET             = 0x0001;
+const sal_uInt16 EXC_SXVS_EXTERN            = 0x0002;
+const sal_uInt16 EXC_SXVS_CONSOLID          = 0x0004;
+const sal_uInt16 EXC_SXVS_PIVOTTAB          = 0x0008;
+const sal_uInt16 EXC_SXVS_SCENARIO          = 0x0010;
+
+// (0x00F0) SXRULE ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXRULE              = 0x00F0;
+
+// (0x00F1) SXEX --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXEX                = 0x00F1;
+
+const sal_uInt32 EXC_SXEX_DRILLDOWN         = 0x00020000;
+const sal_uInt32 EXC_SXEX_DEFAULTFLAGS      = 0x004F0200;
+
+// (0x00F2) SXFILT ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFILT              = 0x00F2;
+
+// (0x00F5) -------------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_00F5                = 0x00F5;   /// Unknown record
+
+// (0x00F6) SXNAME ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXNAME              = 0x00F6;
+
+// (0x00F8) SXPAIR ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXPAIR              = 0x00F8;
+
+// (0x00F9) SXFMLA ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFMLA              = 0x00F9;
+
+// (0x0100) SXVDEX ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXVDEX              = 0x0100;
+
+const sal_uInt32 EXC_SXVDEX_SHOWALL         = 0x00000001;
+const sal_uInt32 EXC_SXVDEX_SORT            = 0x00000200;
+const sal_uInt32 EXC_SXVDEX_SORT_ASC        = 0x00000400;
+const sal_uInt32 EXC_SXVDEX_AUTOSHOW        = 0x00000800;
+const sal_uInt32 EXC_SXVDEX_AUTOSHOW_ASC    = 0x00001000;
+const sal_uInt32 EXC_SXVDEX_LAYOUT_REPORT   = 0x00200000;
+const sal_uInt32 EXC_SXVDEX_LAYOUT_BLANK    = 0x00400000;
+const sal_uInt32 EXC_SXVDEX_LAYOUT_TOP      = 0x00800000;
+const sal_uInt32 EXC_SXVDEX_DEFAULTFLAGS    = 0x0A00001E | EXC_SXVDEX_SORT_ASC | EXC_SXVDEX_AUTOSHOW_ASC;
+
+const sal_uInt16 EXC_SXVDEX_SORT_OWN        = 0xFFFF;
+const sal_uInt16 EXC_SXVDEX_SHOW_NONE       = 0xFFFF;
+const sal_uInt16 EXC_SXVDEX_FORMAT_NONE     = 0x0000;
+
+// (0x0103) SXFORMULA ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFORMULA           = 0x0103;
+
+// (0x0122) SXDBEX ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXDBEX              = 0x0122;
+const double EXC_SXDBEX_CREATION_DATE       = 51901.029652778;
+
+// (0x01BB) SXFDBTYPE ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SXFDBTYPE           = 0x01BB;
+const sal_uInt16 EXC_SXFDBTYPE_DEFAULT      = 0x0000;
+
+// (0x0810) SXVIEWEX9 ---------------------------------------------------------
+const sal_uInt16 EXC_ID_SXVIEWEX9       = 0x0810;
+
+// ============================================================================
+// Pivot cache
+// ============================================================================
+
+/** Represents a data item of any type in a pivot cache. Supposed as base class for import and export. */
+class XclPCItem
+{
+public:
+    explicit            XclPCItem();
+    virtual             ~XclPCItem();
+
+    /** Sets the item to 'empty' type. */
+    void                SetEmpty();
+    /** Sets the item to 'text' type and adds the passed text. */
+    void                SetText( const String& rText );
+    /** Sets the item to 'double' type and adds the passed value. */
+    void                SetDouble( double fValue );
+    /** Sets the item to 'date/time' type and adds the passed date. */
+    void                SetDateTime( const DateTime& rDateTime );
+    /** Sets the item to 'integer' type and adds the passed value. */
+    void                SetInteger( sal_Int16 nValue );
+    /** Sets the item to 'error' type and adds the passed Excel error code. */
+    void                SetError( sal_uInt16 nError );
+    /** Sets the item to 'boolean' type and adds the passed Boolean value. */
+    void                SetBool( bool bValue );
+
+    /** Returns the current item type. */
+    inline XclPCItemType GetType() const { return meType; }
+    /** Returns the text representation of the item. */
+    inline const String& ConvertToText() const { return maText; }
+
+    /** Returns true, if the passed iterm equals this item. */
+    bool                IsEqual( const XclPCItem& rItem ) const;
+
+    /** Returns true, if the item type is 'empty'. */
+    bool                IsEmpty() const;
+    /** Returns pointer to text, if the item type is 'text', otherwise 0. */
+    const String*       GetText() const;
+    /** Returns pointer to value, if the item type is 'double', otherwise 0. */
+    const double*       GetDouble() const;
+    /** Returns pointer to date, if the item type is 'date/time', otherwise 0. */
+    const DateTime*     GetDateTime() const;
+    /** Returns pointer to integer, if the item type is 'integer', otherwise 0. */
+    const sal_Int16*    GetInteger() const;
+    /** Returns pointer to error code, if the item type is 'error', otherwise 0. */
+    const sal_uInt16*   GetError() const;
+    /** Returns pointer to Boolean value, if the item type is 'boolean', otherwise 0. */
+    const bool*         GetBool() const;
+
+private:
+    XclPCItemType       meType;         /// Type of the item.
+    String              maText;         /// Text representation of the item.
+    DateTime            maDateTime;     /// Value of a date/time item.
+    union
+    {
+        double              mfValue;        /// Value of a floating-point item.
+        sal_Int16           mnValue;        /// Value of an integer item.
+        sal_uInt16          mnError;        /// Error code of an error item.
+        bool                mbValue;        /// Value of a boolean item.
+    };
+};
+
+inline bool operator==( const XclPCItem& rLeft, const XclPCItem& rRight ) { return rLeft.IsEqual( rRight ); }
+inline bool operator!=( const XclPCItem& rLeft, const XclPCItem& rRight ) { return !(rLeft == rRight); }
+
+// Field settings =============================================================
+
+/** Contains data for a pivot cache field (SXFIELD record). */
+struct XclPCFieldInfo
+{
+    String              maName;         /// Name of the pivot cache field.
+    sal_uInt16          mnFlags;        /// Various flags.
+    sal_uInt16          mnGroupChild;   /// Field containing grouping info for this field.
+    sal_uInt16          mnGroupBase;    /// Base field if this field contains grouping info.
+    sal_uInt16          mnVisItems;     /// Number of visible items for this field.
+    sal_uInt16          mnGroupItems;   /// Number of special items in a grouping field.
+    sal_uInt16          mnBaseItems;    /// Number of items in the base field.
+    sal_uInt16          mnOrigItems;    /// Number of original source data items.
+
+    explicit            XclPCFieldInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPCFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPCFieldInfo& rInfo );
+
+// Numeric grouping field settings ============================================
+
+/** Contains data for a numeric grouping field (SXNUMGROUP record). */
+struct XclPCNumGroupInfo
+{
+    sal_uInt16          mnFlags;        /// Various flags.
+
+    explicit            XclPCNumGroupInfo();
+
+    void                SetNumType();
+
+    sal_Int32           GetScDateType() const;
+    void                SetScDateType( sal_Int32 nScType );
+
+    sal_uInt16          GetXclDataType() const;
+    void                SetXclDataType( sal_uInt16 nXclType );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPCNumGroupInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPCNumGroupInfo& rInfo );
+
+// Base class for pivot cache fields ==========================================
+
+/** Represents a field in a pivot cache. Supposed as base class for import and export. */
+class XclPCField
+{
+public:
+    explicit            XclPCField( XclPCFieldType eFieldType, sal_uInt16 nFieldIdx );
+    virtual             ~XclPCField();
+
+    /** Returns the index of this field in the containing pivot cache. */
+    inline sal_uInt16   GetFieldIndex() const { return mnFieldIdx; }
+
+    /** Returns true, if the type of the field is supported by Calc. */
+    bool                IsSupportedField() const;
+
+    /** Returns true, if this is a standard field build directly from source data. */
+    bool                IsStandardField() const;
+  
+//UNUSED2008-05  /** Returns true, if the items of the field are calculated from a formula. */
+//UNUSED2008-05  bool                IsCalculatedField() const;
+
+    /** Returns true, if this field is a grouping field. */
+    bool                IsStdGroupField() const;
+    /** Returns true, if this field is a numeric grouping field. */
+    bool                IsNumGroupField() const;
+    /** Returns true, if this field is a date/time grouping field. */
+    bool                IsDateGroupField() const;
+    /** Returns true, if this field is a grouping field of any type. */
+    bool                IsGroupField() const;
+
+    /** Returns true, if this field has a child field in a grouping. */
+    bool                IsGroupBaseField() const;
+    /** Returns true, if this field is a child field in a grouping (it has a base field). */
+    bool                IsGroupChildField() const;
+    /** Returns the index of the base field, if exists, otherwise the own index. */
+    sal_uInt16          GetBaseFieldIndex() const;
+
+    /** Returns true, if the field is based on a column in the source data area. */
+    bool                HasOrigItems() const;
+    /** Returns true, if any items are stored after the SXFIELD record. */
+    bool                HasInlineItems() const;
+    /** Returns true, if the items are stored separately after the last field. */
+    bool                HasPostponedItems() const;
+    /** Returns true, if the item indexes in the SXINDEXLIST record are stored as 16-bit values. */
+    bool                Has16BitIndexes() const;
+
+protected:
+    XclPCFieldInfo      maFieldInfo;        /// Pivot cache field info (SXFIELD record).
+    XclPCFieldType      meFieldType;        /// Type of this pivot cache field.
+    sal_uInt16          mnFieldIdx;         /// Own field index in pivot cache.
+    ScfUInt16Vec        maGroupOrder;       /// Order of items in a grouping field (SXGROUPINFO record).
+    XclPCNumGroupInfo   maNumGroupInfo;     /// Info for numeric grouping (SXNUMGROUP record).
+};
+
+// Pivot cache settings =======================================================
+
+/** Contains data for a pivot cache (SXDB record). */
+struct XclPCInfo
+{
+    sal_uInt32          mnSrcRecs;      /// Records in source database.
+    sal_uInt16          mnStrmId;       /// Stream identifier.
+    sal_uInt16          mnFlags;        /// Flags for the cache.
+    sal_uInt16          mnBlockRecs;    /// Records in a source database block.
+    sal_uInt16          mnStdFields;    /// Number of standard pivot cache fields.
+    sal_uInt16          mnTotalFields;  /// Number of all fields (standard, grouped, calculated).
+    sal_uInt16          mnSrcType;      /// Database type.
+    String              maUserName;     /// Name of user who last modified the cache.
+
+    explicit            XclPCInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPCInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPCInfo& rInfo );
+
+// ============================================================================
+// Pivot table
+// ============================================================================
+
+// cached name ================================================================
+
+/** A name for various pivot table info structs. Includes 'use cache' state. */
+struct XclPTCachedName
+{
+    String              maName;         /// The visible name, if used.
+    bool                mbUseCache;     /// true = Use name in cache instead of maName.
+
+    inline explicit     XclPTCachedName() : mbUseCache( true ) {}
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTCachedName& rCachedName );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTCachedName& rCachedName );
+
+// ----------------------------------------------------------------------------
+
+/** Base struct for named info structs. Supports explicit naming and using the cache. */
+struct XclPTVisNameInfo
+{
+    XclPTCachedName     maVisName;      /// The displayed name of the item.
+
+    /** Returns true, if the name is set explicitly (maVisName.mbUseCache is false). */
+    inline bool         HasVisName() const { return !maVisName.mbUseCache; }
+    /** Returns the name, if set explicitly (maVisName.mbUseCache is false). */
+    const String*       GetVisName() const;
+    /** Sets the visible name and enables usage of cache if name is empty. */
+    void                SetVisName( const String& rName );
+};
+
+// Field item settings ========================================================
+
+/** Contains data for a pivot table data item (SXVI record). */
+struct XclPTItemInfo : public XclPTVisNameInfo
+{
+    sal_uInt16          mnType;         /// Type of the item (e.g. data, function, grand total).
+    sal_uInt16          mnFlags;        /// Several flags.
+    sal_uInt16          mnCacheIdx;     /// Index into cache for item name.
+
+    explicit            XclPTItemInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTItemInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTItemInfo& rInfo );
+
+// General field settings =====================================================
+
+typedef ::std::vector< USHORT > XclPTSubtotalVec;
+
+/** Contains data for a pivot table field (SXVD record). */
+struct XclPTFieldInfo : public XclPTVisNameInfo
+{
+    sal_uInt16          mnAxes;         /// Flags for axes this field is part of.
+    sal_uInt16          mnSubtCount;    /// Number of subtotal functions.
+    sal_uInt16          mnSubtotals;    /// Bitfield for subtotal functions.
+    sal_uInt16          mnItemCount;    /// Number of items of this field.
+    sal_uInt16          mnCacheIdx;     /// Index into cache for field name (not part of record).
+
+    explicit            XclPTFieldInfo();
+
+    /** Returns the API enum representing the orientation (first of row/col/page/data).
+        @param nMask  Restricts the axes taken into account.
+        @return  The first found axis orientation, that is allowed in nMask parameter. */
+    ::com::sun::star::sheet::DataPilotFieldOrientation GetApiOrient( sal_uInt16 nMask ) const;
+    /** Adds the axis orientation represented by the passed API enum. */
+    void                AddApiOrient( ::com::sun::star::sheet::DataPilotFieldOrientation eOrient );
+
+    /** Returns a vector of all set subtotal functions. */
+    void                GetSubtotals( XclPTSubtotalVec& rSubtotals ) const;
+    /** Sets the subtotal functions contained in the passed sequence. */
+    void                SetSubtotals( const XclPTSubtotalVec& rSubtotals );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldInfo& rInfo );
+
+// Extended field settings ====================================================
+
+/** Contains extended data for a pivot table field (SXVDEX record). */
+struct XclPTFieldExtInfo
+{
+    sal_uInt32          mnFlags;        /// Several flags and number of items for AutoShow.
+    sal_uInt16          mnSortField;    /// Index to data field sorting bases on.
+    sal_uInt16          mnShowField;    /// Index to data field AutoShow bases on.
+    sal_uInt16          mnNumFmt;
+    ::std::auto_ptr<rtl::OUString> mpFieldTotalName;
+
+    explicit            XclPTFieldExtInfo();
+
+    /** Returns the API constant representing the sorting mode. */
+    sal_Int32           GetApiSortMode() const;
+    /** Sets the sorting mode represented by the passed API constant. */
+    void                SetApiSortMode( sal_Int32 nSortMode );
+
+    /** Returns the API constant representing the AutoShow mode. */
+    sal_Int32           GetApiAutoShowMode() const;
+    /** Sets the AutoShow mode represented by the passed API constant. */
+    void                SetApiAutoShowMode( sal_Int32 nShowMode );
+
+    /** Returns the number of items to be shown in AutoShow mode. */
+    sal_Int32           GetApiAutoShowCount() const;
+    /** Sets the number of items to be shown in AutoShow mode. */
+    void                SetApiAutoShowCount( sal_Int32 nShowCount );
+
+    /** Returns the API constant representing the layout mode. */
+    sal_Int32           GetApiLayoutMode() const;
+    /** Sets the layout mode represented by the passed API constant. */
+    void                SetApiLayoutMode( sal_Int32 nLayoutMode );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldExtInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldExtInfo& rInfo );
+
+// Page field settings ========================================================
+
+/** Contains data for a pivot table page field (part of SXPI record). */
+struct XclPTPageFieldInfo
+{
+    sal_uInt16          mnField;        /// Base field for this page info.
+    sal_uInt16          mnSelItem;      /// Index to selected item.
+    sal_uInt16          mnObjId;        /// Escher object ID of dropdown listbox.
+
+    explicit            XclPTPageFieldInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTPageFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTPageFieldInfo& rInfo );
+
+// Data field settings ========================================================
+
+/** Contains data for a pivot table data field (SXDI record). */
+struct XclPTDataFieldInfo : public XclPTVisNameInfo
+{
+    sal_uInt16          mnField;        /// Base field for this data info.
+    sal_uInt16          mnAggFunc;      /// Data aggregation function.
+    sal_uInt16          mnRefType;      /// Result reference type.
+    sal_uInt16          mnRefField;     /// Index to SXVD of referred field used for the results.
+    sal_uInt16          mnRefItem;      /// Index to SXVI of referred item of the used field.
+    sal_uInt16          mnNumFmt;       /// Number format of the results.
+
+    explicit            XclPTDataFieldInfo();
+
+    /** Returns the API enum representing the aggregation function. */
+    ::com::sun::star::sheet::GeneralFunction GetApiAggFunc() const;
+    /** Sets the aggregation function represented by the passed API enum. */
+    void                SetApiAggFunc( ::com::sun::star::sheet::GeneralFunction eAggFunc );
+
+    /** Returns the API constant representing the result reference type. */
+    sal_Int32           GetApiRefType() const;
+    /** Sets the result reference type represented by the passed API constant. */
+    void                SetApiRefType( sal_Int32 nRefType );
+
+    /** Returns the API constant representing the result reference item type. */
+    sal_Int32           GetApiRefItemType() const;
+    /** Sets the result reference item type represented by the passed API constant. */
+    void                SetApiRefItemType( sal_Int32 nRefItemType );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTDataFieldInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTDataFieldInfo& rInfo );
+
+// Pivot table settings =======================================================
+
+/** Contains data for a pivot table (SXVIEW record). */
+struct XclPTInfo
+{
+    String              maTableName;        /// The name of the pivot table.
+    String              maDataName;         /// The visible name of the data field.
+    XclRange            maOutXclRange;      /// Output range.
+    XclAddress          maDataXclPos;       /// First cell containing data.
+    sal_uInt16          mnFirstHeadRow;     /// First heading row.
+    sal_uInt16          mnCacheIdx;         /// 0-based index of the pivot cache.
+    sal_uInt16          mnDataAxis;         /// Orientation of data fields.
+    sal_uInt16          mnDataPos;          /// Position of data fields.
+    sal_uInt16          mnFields;           /// Number of all fields.
+    sal_uInt16          mnRowFields;        /// Number of row fields.
+    sal_uInt16          mnColFields;        /// Number of column fields.
+    sal_uInt16          mnPageFields;       /// Number of page fields.
+    sal_uInt16          mnDataFields;       /// Number of data fields.
+    sal_uInt16          mnDataRows;         /// Number of rows containing data.
+    sal_uInt16          mnDataCols;         /// Number of columns containing data.
+    sal_uInt16          mnFlags;            /// Flags for the entire pivot table.
+    sal_uInt16          mnAutoFmtIdx;       /// Index to pivot table autoformat.
+
+    explicit            XclPTInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTInfo& rInfo );
+
+// Extended pivot table settings ==============================================
+
+/** Extended information about a pivot table (SXEX record). */
+struct XclPTExtInfo
+{
+    sal_uInt16          mnSxformulaRecs;    /// Number of SXFORMULA records.
+    sal_uInt16          mnSxselectRecs;     /// Number of SXSELECT records.
+    sal_uInt16          mnPagePerRow;       /// Number of page fields per row.
+    sal_uInt16          mnPagePerCol;       /// Number of page fields per column.
+    sal_uInt32          mnFlags;            /// Flags for the entire pivot table.
+
+    explicit            XclPTExtInfo();
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTExtInfo& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTExtInfo& rInfo );
+
+// ============================================================================
+
+// Pivot table autoformat settings ==============================================
+
+/** Pivot table autoformat settings (SXVIEWEX9 record). */
+struct XclPTViewEx9Info
+{
+    sal_uInt32          mbReport;           /// 2 for report* fmts ?
+    sal_uInt8           mnAutoFormat;       /// AutoFormat ID
+    sal_uInt8           mnGridLayout;       /// 0 == gridlayout, 0x10 == modern
+    String              maGrandTotalName;
+
+    explicit            XclPTViewEx9Info();
+    void                Init( const ScDPObject& rDPObj );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclPTViewEx9Info& rInfo );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclPTViewEx9Info& rInfo );
+
+// ============================================================================
+#endif
+
diff --git sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx
index a4c908b..fed4d1a 100644
--- sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx
+++ sc/source/filter/xlsx/xlsx-XclExpChangeTrack.cxx
@@ -72,6 +72,7 @@ static OString lcl_DateTimeToOString( const DateTime& rDateTime )
 //___________________________________________________________________
 // local functions
 
+#if 0 // xlsx
 void lcl_WriteDateTime( XclExpStream& rStrm, const DateTime& rDateTime )
 {
     rStrm.SetSliceSize( 7 );
@@ -95,6 +96,7 @@ void lcl_WriteFixedString( XclExpStream& rStrm, const XclExpString& rString, sal
     if( nLength > nStrBytes )
         rStrm.WriteZeroBytes( nLength - nStrBytes );
 }
+#endif // xlsx
 
 inline void lcl_GenerateGUID( sal_uInt8* pGUID, sal_Bool& rValidGUID )
 {
@@ -339,12 +341,14 @@ XclExpChTr0x0194::~XclExpChTr0x0194()
 {
 }
 
-void XclExpChTr0x0194::SaveCont( XclExpStream& rStrm )
+void XclExpChTr0x0194::SaveCont( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << (sal_uInt32) 0;
     lcl_WriteDateTime( rStrm, aDateTime );
     rStrm << (sal_uInt8) 0;
     lcl_WriteFixedString( rStrm, sUsername, 147 );
+#endif // xlsx
 }
 
 UINT16 XclExpChTr0x0194::GetNum() const
@@ -412,8 +416,9 @@ XclExpChTrInfo::~XclExpChTrInfo()
 {
 }
 
-void XclExpChTrInfo::SaveCont( XclExpStream& rStrm )
+void XclExpChTrInfo::SaveCont( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm	<< (sal_uInt32)	0xFFFFFFFF
             << (sal_uInt32)	0x00000000
             << (sal_uInt32)	0x00000020
@@ -424,6 +429,7 @@ void XclExpChTrInfo::SaveCont( XclExpStream& rStrm )
     lcl_WriteDateTime( rStrm, aDateTime );
     rStrm	<< (sal_uInt8)	0x0000
             << (sal_uInt16)	0x0002;
+#endif // xlsx
 }
 
 UINT16 XclExpChTrInfo::GetNum() const
@@ -741,6 +747,7 @@ void XclExpChTrData::Clear()
     nSize = 0;
 }
 
+#if 0 // xlsx
 void XclExpChTrData::WriteFormula( XclExpStream& rStrm, const XclExpChTrTabIdBuffer& rTabIdBuffer )
 {
     DBG_ASSERT( mxTokArr.is() && !mxTokArr->Empty(), "XclExpChTrData::Write - no formula" );
@@ -787,6 +794,7 @@ void XclExpChTrData::Write( XclExpStream& rStrm, const XclExpChTrTabIdBuffer& rT
         break;
     }
 }
+#endif // xlsx
 
 //___________________________________________________________________
 
@@ -918,8 +926,9 @@ void XclExpChTrCellContent::GetCellData(
     }
 }
 
-void XclExpChTrCellContent::SaveActionData( XclExpStream& rStrm ) const
+void XclExpChTrCellContent::SaveActionData( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     WriteTabId( rStrm, aPosition.Tab() );
     rStrm	<< (sal_uInt16)((pOldData ? (pOldData->nType << 3) : 0x0000) | (pNewData ? pNewData->nType : 0x0000))
             << (sal_uInt16) 0x0000;
@@ -930,6 +939,7 @@ void XclExpChTrCellContent::SaveActionData( XclExpStream& rStrm ) const
         pOldData->Write( rStrm, rIdBuffer );
     if( pNewData )
         pNewData->Write( rStrm, rIdBuffer );
+#endif // xlsx
 }
 
 UINT16 XclExpChTrCellContent::GetNum() const
@@ -1172,13 +1182,15 @@ XclExpChTrInsertTab::~XclExpChTrInsertTab()
 {
 }
 
-void XclExpChTrInsertTab::SaveActionData( XclExpStream& rStrm ) const
+void XclExpChTrInsertTab::SaveActionData( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     WriteTabId( rStrm, nTab );
     rStrm << sal_uInt32( 0 );
     lcl_WriteFixedString( rStrm, XclExpString( GetTabInfo().GetScTabName( nTab ) ), 127 );
     lcl_WriteDateTime( rStrm, GetDateTime() );
     rStrm.WriteZeroBytes( 133 );
+#endif // xlsx
 }
 
 UINT16 XclExpChTrInsertTab::GetNum() const
diff --git sc/source/filter/xlsx/xlsx-XclImpChangeTrack.cxx sc/source/filter/xlsx/xlsx-XclImpChangeTrack.cxx
deleted file mode 100644
index 0b6b3e3..0000000
--- sc/source/filter/xlsx/xlsx-XclImpChangeTrack.cxx
+++ /dev/null
@@ -1,505 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: XclImpChangeTrack.cxx,v $
- * $Revision: 1.34.48.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "XclImpChangeTrack.hxx"
-#include <tools/debug.hxx>
-#include <sot/storage.hxx>
-#include <svtools/zforlist.hxx>
-#include "chgviset.hxx"
-#include "cell.hxx"
-#include "chgtrack.hxx"
-#include "xihelper.hxx"
-#include "xilink.hxx"
-#include "externalrefmgr.hxx"
-
-//___________________________________________________________________
-// class XclImpChangeTrack
-
-XclImpChangeTrack::XclImpChangeTrack( const XclImpRoot& rRoot, const XclImpStream& rBookStrm ) :
-    XclImpRoot( rRoot ),
-    aRecHeader(),
-    sOldUsername(),
-    pChangeTrack( NULL ),
-    pStrm( NULL ),
-    nTabIdCount( 0 ),
-    bGlobExit( sal_False ),
-    eNestedMode( nmBase )
-{
-    // Verify that the User Names stream exists before going any further. Excel adds both
-    // "Revision Log" and "User Names" streams when Change Tracking is active but the Revision log
-    // remains if Change Tracking is turned off.
-    SotStorageStreamRef xUserStrm = OpenStream( EXC_STREAM_USERNAMES );
-    if( !xUserStrm.Is() )
-        return;
-
-    xInStrm = OpenStream( EXC_STREAM_REVLOG );
-    if( xInStrm.Is() )
-    {
-        xInStrm->Seek( STREAM_SEEK_TO_END );
-        ULONG nStreamLen = xInStrm->Tell();
-        if( (xInStrm->GetErrorCode() == ERRCODE_NONE) && (nStreamLen != STREAM_SEEK_TO_END) )
-        {
-            xInStrm->Seek( STREAM_SEEK_TO_BEGIN );
-            pStrm = new XclImpStream( *xInStrm, GetRoot() );
-            pStrm->CopyDecrypterFrom( rBookStrm );
-            pChangeTrack = new ScChangeTrack( GetDocPtr() );
-
-            sOldUsername = pChangeTrack->GetUser();
-            pChangeTrack->SetUseFixDateTime( TRUE );
-
-            ReadRecords();
-        }
-    }
-}
-
-XclImpChangeTrack::~XclImpChangeTrack()
-{
-    delete pChangeTrack;
-    delete pStrm;
-}
-
-void XclImpChangeTrack::DoAcceptRejectAction( ScChangeAction* pAction )
-{
-    if( !pAction ) return;
-    switch( aRecHeader.nAccept )
-    {
-        case EXC_CHTR_ACCEPT:
-            pChangeTrack->Accept( pAction );
-        break;
-        case EXC_CHTR_REJECT:
-        break;
-    }
-}
-
-void XclImpChangeTrack::DoAcceptRejectAction( sal_uInt32 nFirst, sal_uInt32 nLast )
-{
-    for( sal_uInt32 nIndex = nFirst; nIndex <= nLast; nIndex++ )
-        DoAcceptRejectAction( pChangeTrack->GetAction( nIndex ) );
-}
-
-void XclImpChangeTrack::DoInsertRange( const ScRange& rRange )
-{
-    sal_uInt32 nFirst = pChangeTrack->GetActionMax() + 1;
-    pChangeTrack->AppendInsert( rRange );
-    sal_uInt32 nLast = pChangeTrack->GetActionMax();
-    DoAcceptRejectAction( nFirst, nLast );
-}
-
-void XclImpChangeTrack::DoDeleteRange( const ScRange& rRange )
-{
-    ULONG nFirst, nLast;
-    pChangeTrack->AppendDeleteRange( rRange, NULL, nFirst, nLast );
-    DoAcceptRejectAction( nFirst, nLast );
-}
-
-SCTAB XclImpChangeTrack::ReadTabNum()
-{
-    return static_cast<SCTAB>(GetTabInfo().GetCurrentIndex(
-                pStrm->ReaduInt16(), nTabIdCount ));
-}
-
-void XclImpChangeTrack::ReadDateTime( DateTime& rDateTime )
-{
-    sal_uInt16 nYear;
-    sal_uInt8 nMonth, nDay, nHour, nMin, nSec;
-
-    *pStrm >> nYear >> nMonth >> nDay >> nHour >> nMin >> nSec;
-
-    rDateTime.SetYear( nYear );
-    rDateTime.SetMonth( nMonth );
-    rDateTime.SetDay( nDay );
-    rDateTime.SetHour( nHour );
-    rDateTime.SetMin( nMin );
-    rDateTime.SetSec( nSec );
-    rDateTime.Set100Sec( 0 );
-}
-
-sal_Bool XclImpChangeTrack::CheckRecord( sal_uInt16 nOpCode )
-{
-    if( (nOpCode != EXC_CHTR_OP_UNKNOWN) && (aRecHeader.nOpCode != nOpCode) )
-    {
-        DBG_ERROR( "XclImpChangeTrack::CheckRecord - unknown action" );
-        return sal_False;
-    }
-    return aRecHeader.nIndex != 0;
-}
-
-sal_Bool XclImpChangeTrack::Read3DTabRefInfo( SCTAB& rFirstTab, SCTAB& rLastTab, ExcelToSc8::ExternalTabInfo& rExtInfo )
-{
-    if( LookAtuInt8() == 0x01 )
-    {
-        rExtInfo.mbExternal = false;
-        // internal ref - read tab num and return sc tab num (position in TABID list)
-        pStrm->Ignore( 3 );
-        rFirstTab = static_cast< SCTAB >( GetTabInfo().GetCurrentIndex( pStrm->ReaduInt16(), nTabIdCount ) );
-        sal_uInt8 nFillByte = pStrm->ReaduInt8();
-        rLastTab = (nFillByte == 0x00) ?
-            static_cast< SCTAB >( GetTabInfo().GetCurrentIndex( pStrm->ReaduInt16(), nTabIdCount ) ) : rFirstTab;
-    }
-    else
-    {
-        // external ref - read doc and tab name and find sc tab num
-        // - URL
-        String aEncUrl( pStrm->ReadUniString() );
-        String aUrl;
-        bool bSelf;
-        XclImpUrlHelper::DecodeUrl( aUrl, bSelf, GetRoot(), aEncUrl );
-        pStrm->Ignore( 1 );
-        // - sheet name, always separated from URL
-        String aTabName( pStrm->ReadUniString() );
-        pStrm->Ignore( 1 );
-
-        rExtInfo.mbExternal = true;
-        ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
-        pRefMgr->convertToAbsName(aUrl);
-        rExtInfo.mnFileId = pRefMgr->getExternalFileId(aUrl);
-        rExtInfo.maTabName = aTabName;
-        rFirstTab = rLastTab = 0;
-    }
-    return sal_True;
-}
-
-void XclImpChangeTrack::ReadFormula( ScTokenArray*& rpTokenArray, const ScAddress& rPosition )
-{
-    sal_uInt16 nFmlSize;
-    *pStrm >> nFmlSize;
-
-    // create a memory stream and copy the formula to be able to read simultaneously
-    // the formula and the additional 3D tab ref data following the formula
-    // here we have to simulate an Excel record to be able to use an XclImpStream...
-    // 2do: remove the stream member from formula converter and add it as a parameter
-    // to the Convert() routine (to prevent the construction/destruction of the
-    // converter in each formula)
-    SvMemoryStream aMemStrm;
-    aMemStrm << (sal_uInt16) 0x0001 << nFmlSize;
-    pStrm->CopyToStream( aMemStrm, nFmlSize );
-    XclImpStream aFmlaStrm( aMemStrm, GetRoot() );
-    aFmlaStrm.StartNextRecord();
-    XclImpChTrFmlConverter aFmlConv( GetRoot(), *this );
-
-    // read the formula, 3D tab refs from extended data
-    const ScTokenArray* pArray = NULL;
-    aFmlConv.Reset( rPosition );
-    BOOL bOK = (aFmlConv.Convert( pArray, aFmlaStrm, nFmlSize, false, FT_CellFormula) == ConvOK);	// JEG : Check This
-    rpTokenArray = (bOK && pArray) ? new ScTokenArray( *pArray ) : NULL;
-    pStrm->Ignore( 1 );
-}
-
-void XclImpChangeTrack::ReadCell(
-        ScBaseCell*& rpCell,
-        sal_uInt32& rFormat,
-        sal_uInt16 nFlags,
-        const ScAddress& rPosition )
-{
-    rpCell = NULL;
-    rFormat = 0;
-    switch( nFlags & EXC_CHTR_TYPE_MASK )
-    {
-        case EXC_CHTR_TYPE_EMPTY:
-        break;
-        case EXC_CHTR_TYPE_RK:
-        {
-            double fValue = ReadRK();
-            if( pStrm->IsValid() )
-                rpCell = new ScValueCell( fValue );
-        }
-        break;
-        case EXC_CHTR_TYPE_DOUBLE:
-        {
-            double fValue;
-            *pStrm >> fValue;
-            if( pStrm->IsValid() )
-                rpCell = new ScValueCell( fValue );
-        }
-        break;
-        case EXC_CHTR_TYPE_STRING:
-        {
-            String sString( pStrm->ReadUniString() );
-            if( pStrm->IsValid() )
-                rpCell = new ScStringCell( sString );
-        }
-        break;
-        case EXC_CHTR_TYPE_BOOL:
-        {
-            double fValue = (double) ReadBool();
-            if( pStrm->IsValid() )
-            {
-                rpCell = new ScValueCell( fValue );
-                rFormat = GetFormatter().GetStandardFormat( NUMBERFORMAT_LOGICAL, ScGlobal::eLnge );
-            }
-        }
-        break;
-        case EXC_CHTR_TYPE_FORMULA:
-        {
-            ScTokenArray* pTokenArray = NULL;
-            ReadFormula( pTokenArray, rPosition );
-            if( pStrm->IsValid() && pTokenArray )
-                rpCell = new ScFormulaCell( GetDocPtr(), rPosition, pTokenArray );
-        }
-        break;
-        default:
-            DBG_ERROR( "XclImpChangeTrack::ReadCell - unknown data type" );
-    }
-}
-
-void XclImpChangeTrack::ReadChTrInsert()
-{
-    *pStrm >> aRecHeader;
-    if( CheckRecord( EXC_CHTR_OP_UNKNOWN ) )
-    {
-        if( (aRecHeader.nOpCode != EXC_CHTR_OP_INSROW) &&
-            (aRecHeader.nOpCode != EXC_CHTR_OP_INSCOL) &&
-            (aRecHeader.nOpCode != EXC_CHTR_OP_DELROW) &&
-            (aRecHeader.nOpCode != EXC_CHTR_OP_DELCOL) )
-        {
-            DBG_ERROR( "XclImpChangeTrack::ReadChTrInsert - unknown action" );
-            return;
-        }
-
-        ScRange aRange;
-        aRange.aStart.SetTab( ReadTabNum() );
-        aRange.aEnd.SetTab( aRange.aStart.Tab() );
-        pStrm->Ignore( 2 );
-        Read2DRange( aRange );
-
-        if( aRecHeader.nOpCode & EXC_CHTR_OP_COLFLAG )
-            aRange.aEnd.SetRow( MAXROW );
-        else
-            aRange.aEnd.SetCol( MAXCOL );
-
-        BOOL bValid = pStrm->IsValid();
-        if( FoundNestedMode() )
-            ReadNestedRecords();
-
-        if( bValid )
-        {
-            if( aRecHeader.nOpCode & EXC_CHTR_OP_DELFLAG )
-                DoDeleteRange( aRange );
-            else
-                DoInsertRange( aRange );
-        }
-    }
-}
-
-void XclImpChangeTrack::ReadChTrInfo()
-{
-    pStrm->DisableDecryption();
-    pStrm->Ignore( 32 );
-    String sUsername( pStrm->ReadUniString() );
-    if( !pStrm->IsValid() ) return;
-
-    if( sUsername.Len() )
-        pChangeTrack->SetUser( sUsername );
-    pStrm->Seek( 148 );
-    if( !pStrm->IsValid() ) return;
-
-    DateTime aDateTime;
-    ReadDateTime( aDateTime );
-    if( pStrm->IsValid() )
-        pChangeTrack->SetFixDateTimeLocal( aDateTime );
-}
-
-void XclImpChangeTrack::ReadChTrCellContent()
-{
-    *pStrm >> aRecHeader;
-    if( CheckRecord( EXC_CHTR_OP_CELL ) )
-    {
-        ScAddress aPosition;
-        SCTAB nTab = ReadTabNum();
-        aPosition.SetTab( nTab );
-        sal_uInt16 nValueType;
-        *pStrm >> nValueType;
-        sal_uInt16 nOldValueType = (nValueType >> 3) & EXC_CHTR_TYPE_MASK;
-        sal_uInt16 nNewValueType = nValueType & EXC_CHTR_TYPE_MASK;
-        pStrm->Ignore( 2 );
-        Read2DAddress( aPosition );
-        sal_uInt16 nOldSize;
-        *pStrm >> nOldSize;
-        DBG_ASSERT( (nOldSize == 0) == (nOldValueType == EXC_CHTR_TYPE_EMPTY),
-            "XclImpChangeTrack::ReadChTrCellContent - old value mismatch" );
-        pStrm->Ignore( 4 );
-        switch( nValueType & EXC_CHTR_TYPE_FORMATMASK )
-        {
-            case 0x0000:							break;
-            case 0x1100:    pStrm->Ignore( 16 );    break;
-            case 0x1300:    pStrm->Ignore( 8 );     break;
-            default:		DBG_ERROR( "XclImpChangeTrack::ReadChTrCellContent - unknown format info" );
-        }
-
-        ScBaseCell* pOldCell;
-        ScBaseCell* pNewCell;
-        sal_uInt32 nOldFormat;
-        sal_uInt32 nNewFormat;
-        ReadCell( pOldCell, nOldFormat, nOldValueType, aPosition );
-        ReadCell( pNewCell, nNewFormat, nNewValueType, aPosition );
-        if( !pStrm->IsValid() || (pStrm->GetRecLeft() > 0) )
-        {
-            DBG_ERROR( "XclImpChangeTrack::ReadChTrCellContent - bytes left, action ignored" );
-            if( pOldCell )
-                pOldCell->Delete();
-            if( pNewCell )
-                pNewCell->Delete();
-        }
-        else
-        {
-            ScChangeActionContent* pNewAction =
-                pChangeTrack->AppendContentOnTheFly( aPosition, pOldCell, pNewCell, nOldFormat, nNewFormat );
-            DoAcceptRejectAction( pNewAction );
-        }
-    }
-}
-
-void XclImpChangeTrack::ReadChTrTabId()
-{
-    if( nTabIdCount == 0 )  // read only 1st time, otherwise calculated by <ReadChTrInsertTab()>
-        nTabIdCount = static_cast< sal_uInt16 >( pStrm->GetRecLeft() >> 1 );
-}
-
-void XclImpChangeTrack::ReadChTrMoveRange()
-{
-    *pStrm >> aRecHeader;
-    if( CheckRecord( EXC_CHTR_OP_MOVE ) )
-    {
-        ScRange aSourceRange;
-        ScRange aDestRange;
-        aDestRange.aStart.SetTab( ReadTabNum() );
-        aDestRange.aEnd.SetTab( aDestRange.aStart.Tab() );
-        Read2DRange( aSourceRange );
-        Read2DRange( aDestRange );
-        aSourceRange.aStart.SetTab( ReadTabNum() );
-        aSourceRange.aEnd.SetTab( aSourceRange.aStart.Tab() );
-
-        BOOL bValid = pStrm->IsValid();
-        if( FoundNestedMode() )
-            ReadNestedRecords();
-
-        if( bValid )
-        {
-            pChangeTrack->AppendMove( aSourceRange, aDestRange, NULL );
-            DoAcceptRejectAction( pChangeTrack->GetLast() );
-        }
-    }
-}
-
-void XclImpChangeTrack::ReadChTrInsertTab()
-{
-    *pStrm >> aRecHeader;
-    if( CheckRecord( EXC_CHTR_OP_INSTAB ) )
-    {
-        SCTAB nTab = ReadTabNum();
-        if( pStrm->IsValid() )
-        {
-            nTabIdCount++;
-            DoInsertRange( ScRange( 0, 0, nTab, MAXCOL, MAXROW, nTab ) );
-        }
-    }
-}
-
-void XclImpChangeTrack::InitNestedMode()
-{
-    DBG_ASSERT( eNestedMode == nmBase, "XclImpChangeTrack::InitNestedMode - unexpected nested mode" );
-    if( eNestedMode == nmBase )
-        eNestedMode = nmFound;
-}
-
-void XclImpChangeTrack::ReadNestedRecords()
-{
-    DBG_ASSERT( eNestedMode == nmFound, "XclImpChangeTrack::StartNestedMode - missing nested mode" );
-    if( eNestedMode == nmFound )
-    {
-        eNestedMode = nmNested;
-        ReadRecords();
-    }
-}
-
-sal_Bool XclImpChangeTrack::EndNestedMode()
-{
-    DBG_ASSERT( eNestedMode != nmBase, "XclImpChangeTrack::EndNestedMode - missing nested mode" );
-    sal_Bool bReturn = (eNestedMode == nmNested);
-    eNestedMode = nmBase;
-    return bReturn;
-}
-
-void XclImpChangeTrack::ReadRecords()
-{
-    sal_Bool bExitLoop = sal_False;
-
-    while( !bExitLoop && !bGlobExit && pStrm->StartNextRecord() )
-    {
-        switch( pStrm->GetRecId() )
-        {
-            case 0x000A:	bGlobExit = sal_True;			break;
-            case 0x0137:	ReadChTrInsert();				break;
-            case 0x0138:	ReadChTrInfo();					break;
-            case 0x013B:	ReadChTrCellContent();			break;
-            case 0x013D:	ReadChTrTabId();				break;
-            case 0x0140:	ReadChTrMoveRange();			break;
-            case 0x014D:	ReadChTrInsertTab();			break;
-            case 0x014E:
-            case 0x0150:	InitNestedMode();				break;
-            case 0x014F:
-            case 0x0151:	bExitLoop = EndNestedMode();	break;
-        }
-    }
-}
-
-void XclImpChangeTrack::Apply()
-{
-    if( pChangeTrack )
-    {
-        pChangeTrack->SetUser( sOldUsername );
-        pChangeTrack->SetUseFixDateTime( FALSE );
-
-        GetDoc().SetChangeTrack( pChangeTrack );
-        pChangeTrack = NULL;
-
-        ScChangeViewSettings aSettings;
-        aSettings.SetShowChanges( TRUE );
-        GetDoc().SetChangeViewSettings( aSettings );
-    }
-}
-
-//___________________________________________________________________
-// class XclImpChTrFmlConverter
-
-XclImpChTrFmlConverter::~XclImpChTrFmlConverter()
-{
-}
-
-// virtual, called from ExcToSc8::Convert()
-bool XclImpChTrFmlConverter::Read3DTabReference( UINT16 /*nIxti*/, SCTAB& rFirstTab, SCTAB& rLastTab, 
-                                                 ExternalTabInfo& rExtInfo )
-{
-    return rChangeTrack.Read3DTabRefInfo( rFirstTab, rLastTab, rExtInfo );
-}
-
diff --git sc/source/filter/xlsx/xlsx-colrowst.cxx sc/source/filter/xlsx/xlsx-colrowst.cxx
index c1d0369..bf99f17 100644
--- sc/source/filter/xlsx/xlsx-colrowst.cxx
+++ sc/source/filter/xlsx/xlsx-colrowst.cxx
@@ -33,6 +33,7 @@
 
 
 
+#if 0 // xlsx
 #include "colrowst.hxx"
 
 #include <string.h>
@@ -319,3 +320,4 @@ void XclImpColRowSettings::ConvertHiddenFlags( SCTAB nScTab )
         rDoc.ShowRows( mnLastScRow + 1, MAXROW, nScTab, FALSE );
 }
 
+#endif // xlsx 
diff --git sc/source/filter/xlsx/xlsx-excel.cxx sc/source/filter/xlsx/xlsx-excel.cxx
deleted file mode 100644
index 5bfa13c..0000000
--- sc/source/filter/xlsx/xlsx-excel.cxx
+++ /dev/null
@@ -1,290 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: excel.cxx,v $
- * $Revision: 1.26.32.2 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include <sfx2/docfile.hxx>
-#include <sfx2/objsh.hxx>
-#include <sfx2/app.hxx>
-#include <sot/storage.hxx>
-#include <sot/exchange.hxx>
-#include <tools/globname.hxx>
-#include <comphelper/mediadescriptor.hxx>
-#include <comphelper/processfactory.hxx>
-#include <com/sun/star/beans/NamedValue.hpp>
-#include <com/sun/star/document/XFilter.hpp>
-#include <com/sun/star/document/XImporter.hpp>
-#include "scitems.hxx"
-#include <svtools/stritem.hxx>
-#include "filter.hxx"
-#include "document.hxx"
-#include "xistream.hxx"
-
-#include "scerrors.hxx"
-#include "root.hxx"
-#include "imp_op.hxx"
-#include "excimp8.hxx"
-#include "exp_op.hxx"
-
-
-FltError ScFormatFilterPluginImpl::ScImportExcel( SfxMedium& rMedium, ScDocument* pDocument, const EXCIMPFORMAT eFormat )
-{
-    // check the passed Calc document
-    DBG_ASSERT( pDocument, "::ScImportExcel - no document" );
-    if( !pDocument ) return eERR_INTERN;        // should not happen
-
-    /*  Import all BIFF versions regardless on eFormat, needed for import of
-        external cells (file type detection returns Excel4.0). */
-    if( (eFormat != EIF_AUTO) && (eFormat != EIF_BIFF_LE4) && (eFormat != EIF_BIFF5) && (eFormat != EIF_BIFF8) )
-    {
-        DBG_ERRORFILE( "::ScImportExcel - wrong file format specification" );
-        return eERR_FORMAT;
-    }
-
-    // check the input stream from medium
-    SvStream* pMedStrm = rMedium.GetInStream();
-    DBG_ASSERT( pMedStrm, "::ScImportExcel - medium without input stream" );
-    if( !pMedStrm ) return eERR_OPEN;           // should not happen
-
-#if OSL_DEBUG_LEVEL > 0
-    using namespace ::com::sun::star;
-    using namespace ::comphelper;
-
-    /*  Environment variable "OOO_OOXBIFFFILTER":
-        - "1" = use new OOX filter for import;
-        - undef/other = use old sc filter for import (OOX only as file dumper). */
-    const sal_Char* pcFileName = ::getenv( "OOO_OOXBIFFFILTER" );
-    bool bUseOoxFilter = pcFileName && (*pcFileName == '1') && (*(pcFileName + 1) == 0);
-    if( SfxObjectShell* pDocShell = pDocument->GetDocumentShell() ) try
-    {
-        uno::Reference< lang::XComponent > xComponent( pDocShell->GetModel(), uno::UNO_QUERY_THROW );
-
-        uno::Sequence< beans::NamedValue > aArgSeq( 1 );
-        aArgSeq[ 0 ].Name = CREATE_OUSTRING( "UseBiffFilter" );
-        aArgSeq[ 0 ].Value <<= bUseOoxFilter;
-
-        uno::Sequence< uno::Any > aArgs( 2 );
-        aArgs[ 0 ] <<= getProcessServiceFactory();
-        aArgs[ 1 ] <<= aArgSeq;
-        uno::Reference< document::XImporter > xImporter( ScfApiHelper::CreateInstanceWithArgs(
-            CREATE_OUSTRING( "com.sun.star.comp.oox.ExcelBiffFilter" ), aArgs ), uno::UNO_QUERY_THROW );
-        xImporter->setTargetDocument( xComponent );
-
-        MediaDescriptor aMediaDesc;
-        SfxItemSet* pItemSet = rMedium.GetItemSet();
-        if( pItemSet )
-        {
-            if( const SfxStringItem* pItem = static_cast< const SfxStringItem* >( pItemSet->GetItem( SID_FILE_NAME ) ) )
-                aMediaDesc[ MediaDescriptor::PROP_URL() ] <<= ::rtl::OUString( pItem->GetValue() );
-            if( const SfxStringItem* pItem = static_cast< const SfxStringItem* >( pItemSet->GetItem( SID_PASSWORD ) ) )
-                aMediaDesc[ MediaDescriptor::PROP_PASSWORD() ] <<= ::rtl::OUString( pItem->GetValue() );
-        }
-        aMediaDesc[ MediaDescriptor::PROP_INPUTSTREAM() ] <<= rMedium.GetInputStream();
-        aMediaDesc[ MediaDescriptor::PROP_INTERACTIONHANDLER() ] <<= rMedium.GetInteractionHandler();
-
-        // call the filter
-        uno::Reference< document::XFilter > xFilter( xImporter, uno::UNO_QUERY_THROW );
-        bool bResult = xFilter->filter( aMediaDesc.getAsConstPropertyValueList() );
-
-        // if filter returns false, document is invalid, or dumper has disabled import -> exit here
-        if( !bResult )
-            return ERRCODE_ABORT;
-
-        // if OOX filter has been used, exit with OK code
-        if( bUseOoxFilter )
-            return eERR_OK;
-    }
-    catch( uno::Exception& )
-    {
-        if( bUseOoxFilter )
-            return ERRCODE_ABORT;
-        // else ignore exception and import the document with this filter
-    }
-#endif
-
-    SvStream* pBookStrm = 0;            // The "Book"/"Workbook" stream containing main data.
-    XclBiff eBiff = EXC_BIFF_UNKNOWN;   // The BIFF version of the main stream.
-
-    // try to open an OLE storage
-    SotStorageRef xRootStrg;
-    SotStorageStreamRef xStrgStrm;
-    if( SotStorage::IsStorageFile( pMedStrm ) )
-    {
-        xRootStrg = new SotStorage( pMedStrm, FALSE );
-        if( xRootStrg->GetError() )
-            xRootStrg = 0;
-    }
-
-    // try to open "Book" or "Workbook" stream in OLE storage
-    if( xRootStrg.Is() )
-    {
-        // try to open the "Book" stream
-        SotStorageStreamRef xBookStrm = ScfTools::OpenStorageStreamRead( xRootStrg, EXC_STREAM_BOOK );
-        XclBiff eBookBiff = xBookStrm.Is() ?  XclImpStream::DetectBiffVersion( *xBookStrm ) : EXC_BIFF_UNKNOWN;
-
-        // try to open the "Workbook" stream
-        SotStorageStreamRef xWorkbookStrm = ScfTools::OpenStorageStreamRead( xRootStrg, EXC_STREAM_WORKBOOK );
-        XclBiff eWorkbookBiff = xWorkbookStrm.Is() ?  XclImpStream::DetectBiffVersion( *xWorkbookStrm ) : EXC_BIFF_UNKNOWN;
-
-        // decide which stream to use
-        if( (eWorkbookBiff != EXC_BIFF_UNKNOWN) && ((eBookBiff == EXC_BIFF_UNKNOWN) || (eWorkbookBiff > eBookBiff)) )
-        {
-            /*  Only "Workbook" stream exists; or both streams exist,
-                and "Workbook" has higher BIFF version than "Book" stream. */
-            xStrgStrm = xWorkbookStrm;
-            eBiff = eWorkbookBiff;
-        }
-        else if( eBookBiff != EXC_BIFF_UNKNOWN )
-        {
-            /*  Only "Book" stream exists; or both streams exist,
-                and "Book" has higher BIFF version than "Workbook" stream. */
-            xStrgStrm = xBookStrm;
-            eBiff = eBookBiff;
-        }
-
-        pBookStrm = xStrgStrm;
-    }
-
-    // no "Book" or "Workbook" stream found, try plain input stream from medium (even for BIFF5+)
-    if( !pBookStrm )
-    {
-        eBiff = XclImpStream::DetectBiffVersion( *pMedStrm );
-        if( eBiff != EXC_BIFF_UNKNOWN )
-            pBookStrm = pMedStrm;
-    }
-
-    // try to import the file
-    FltError eRet = eERR_UNKN_BIFF;
-    if( pBookStrm )
-    {
-        pBookStrm->SetBufferSize( 0x8000 );     // still needed?
-
-        XclImpRootData aImpData( eBiff, rMedium, xRootStrg, *pDocument, RTL_TEXTENCODING_MS_1252 );
-        ::std::auto_ptr< ImportExcel > xFilter;
-        switch( eBiff )
-        {
-            case EXC_BIFF2:
-            case EXC_BIFF3:
-            case EXC_BIFF4:
-            case EXC_BIFF5:
-                xFilter.reset( new ImportExcel( aImpData, *pBookStrm ) );
-            break;
-            case EXC_BIFF8:
-                xFilter.reset( new ImportExcel8( aImpData, *pBookStrm ) );
-            break;
-            default:    DBG_ERROR_BIFF();
-        }
-
-        eRet = xFilter.get() ? xFilter->Read() : eERR_INTERN;
-    }
-
-    return eRet;
-}
-
-
-static FltError lcl_ExportExcelBiff( SfxMedium& rMedium, ScDocument *pDocument,
-        SvStream* pMedStrm, BOOL bBiff8, CharSet eNach )
-{
-    // try to open an OLE storage
-    SotStorageRef xRootStrg = new SotStorage( pMedStrm, FALSE );
-    if( xRootStrg->GetError() ) return eERR_OPEN;
-
-    // create BIFF dependent strings
-    String aStrmName, aClipName, aClassName;
-    if( bBiff8 )
-    {
-        aStrmName = EXC_STREAM_WORKBOOK;
-        aClipName = CREATE_STRING( "Biff8" );
-        aClassName = CREATE_STRING( "Microsoft Excel 97-Tabelle" );
-    }
-    else
-    {
-        aStrmName = EXC_STREAM_BOOK;
-        aClipName = CREATE_STRING( "Biff5" );
-        aClassName = CREATE_STRING( "Microsoft Excel 5.0-Tabelle" );
-    }
-
-    // open the "Book"/"Workbook" stream
-    SotStorageStreamRef xStrgStrm = ScfTools::OpenStorageStreamWrite( xRootStrg, aStrmName );
-    if( !xStrgStrm.Is() || xStrgStrm->GetError() ) return eERR_OPEN;
-
-    xStrgStrm->SetBufferSize( 0x8000 );     // still needed?
-
-    FltError eRet = eERR_UNKN_BIFF;
-    XclExpRootData aExpData( bBiff8 ? EXC_BIFF8 : EXC_BIFF5, rMedium, xRootStrg, *pDocument, eNach );
-    if ( bBiff8 )
-    {
-        ExportBiff8 aFilter( aExpData, *xStrgStrm );
-        eRet = aFilter.Write();
-    }
-    else
-    {
-        ExportBiff5 aFilter( aExpData, *xStrgStrm );
-        eRet = aFilter.Write();
-    }
-
-    if( eRet == eERR_RNGOVRFLW )
-        eRet = SCWARN_EXPORT_MAXROW;
-
-    SvGlobalName aGlobName( 0x00020810, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 );
-    sal_uInt32 nClip = SotExchange::RegisterFormatName( aClipName );
-    xRootStrg->SetClass( aGlobName, nClip, aClassName );
-
-    xStrgStrm->Commit();
-    xRootStrg->Commit();
-
-    return eRet;
-}
-
-FltError ScFormatFilterPluginImpl::ScExportExcel5( SfxMedium& rMedium, ScDocument *pDocument,
-    ExportFormatExcel eFormat, CharSet eNach )
-{
-    if( eFormat != ExpBiff5 && eFormat != ExpBiff8 )
-        return eERR_NI;
-
-    // check the passed Calc document
-    DBG_ASSERT( pDocument, "::ScImportExcel - no document" );
-    if( !pDocument ) return eERR_INTERN;        // should not happen
-
-    // check the output stream from medium
-    SvStream* pMedStrm = rMedium.GetOutStream();
-    DBG_ASSERT( pMedStrm, "::ScExportExcel5 - medium without output stream" );
-    if( !pMedStrm ) return eERR_OPEN;           // should not happen
-
-    FltError eRet = eERR_UNKN_BIFF;
-    if( eFormat == ExpBiff5 || eFormat == ExpBiff8 )
-        eRet = lcl_ExportExcelBiff( rMedium, pDocument, pMedStrm, eFormat == ExpBiff8, eNach );
-
-    return eRet;
-}
-
-
-
diff --git sc/source/filter/xlsx/xlsx-excform.cxx sc/source/filter/xlsx/xlsx-excform.cxx
deleted file mode 100644
index 9ba7441..0000000
--- sc/source/filter/xlsx/xlsx-excform.cxx
+++ /dev/null
@@ -1,2017 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: excform.cxx,v $
- * $Revision: 1.52.4.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "excform.hxx"
-#include <osl/endian.h>
-
-#include "cell.hxx"
-#include "document.hxx"
-#include "rangenam.hxx"
-#include "global.hxx"
-#include "formula/errorcodes.hxx"
-
-#include "imp_op.hxx"
-#include "root.hxx"
-#include "xltracer.hxx"
-#include "xihelper.hxx"
-#include "xilink.hxx"
-#include "xiname.hxx"
-
-using ::std::vector;
-
-const UINT16 ExcelToSc::nRowMask = 0x3FFF;
-const UINT16 ExcelToSc::nLastInd = 399;
-
-
-
-
-void ImportExcel::Formula25()
-{
-    XclAddress aXclPos;
-    UINT16  nXF = 0, nFormLen;
-    double	fCurVal;
-    BYTE	nAttr0, nFlag0;
-    BOOL	bShrFmla;
-
-    aIn >> aXclPos;
-
-    if( GetBiff() == EXC_BIFF2 )
-    {//						BIFF2
-        BYTE nDummy;
-
-        aIn.Ignore( 3 );
-
-        aIn >> fCurVal;
-        aIn.Ignore( 1 );
-        aIn >> nDummy;
-        nFormLen = nDummy;
-        bShrFmla = FALSE;
-        nAttr0 = 0x01;	// Always calculate
-    }
-    else
-    {//						BIFF5
-        aIn >> nXF >> fCurVal >> nFlag0;
-        aIn.Ignore( 5 );
-
-        aIn >> nFormLen;
-
-        bShrFmla = nFlag0 & 0x08;	// shared or not shared
-    }
-
-    nLastXF = nXF;
-
-    Formula( aXclPos, nXF, nFormLen, fCurVal, bShrFmla );
-}
-
-
-void ImportExcel::Formula3()
-{
-    Formula4();
-}
-
-
-void ImportExcel::Formula4()
-{
-    XclAddress aXclPos;
-    UINT16  nXF, nFormLen;
-    double	fCurVal;
-    BYTE	nFlag0;
-
-    aIn >> aXclPos >> nXF >> fCurVal >> nFlag0;
-    aIn.Ignore( 1 );
-    aIn >> nFormLen;
-
-    nLastXF = nXF;
-
-    Formula( aXclPos, nXF, nFormLen, fCurVal, FALSE );
-}
-
-
-void ImportExcel::Formula( const XclAddress& rXclPos,
-    UINT16 nXF, UINT16 nFormLen, double& rCurVal, BOOL bShrFmla )
-{
-    ConvErr eErr = ConvOK;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, rXclPos, GetCurrScTab(), true ) )
-    {
-        // jetzt steht Lesemarke auf Formel, Laenge in nFormLen
-        const ScTokenArray* pErgebnis = 0;
-        BOOL				bConvert;
-
-        pFormConv->Reset( aScPos );
-
-        if( bShrFmla )
-            bConvert = !pFormConv->GetShrFmla( pErgebnis, maStrm, nFormLen );
-        else
-            bConvert = TRUE;
-
-        if( bConvert )
-            eErr = pFormConv->Convert( pErgebnis, maStrm, nFormLen, true, FT_CellFormula);
-
-        ScFormulaCell*		pZelle = NULL;
-
-        if( pErgebnis )
-        {
-            pZelle = new ScFormulaCell( pD, aScPos, pErgebnis );
-            pD->PutCell( aScPos.Col(), aScPos.Row(), aScPos.Tab(), pZelle, (BOOL)TRUE );
-        }
-        else
-        {
-            CellType		eCellType;
-            ScBaseCell*		pBaseCell;
-            pD->GetCellType( aScPos.Col(), aScPos.Row(), aScPos.Tab(), eCellType );
-            if( eCellType == CELLTYPE_FORMULA )
-            {
-                pD->GetCell( aScPos.Col(), aScPos.Row(), aScPos.Tab(), pBaseCell );
-                pZelle = ( ScFormulaCell* ) pBaseCell;
-                if( pZelle )
-                    pZelle->AddRecalcMode( RECALCMODE_ONLOAD_ONCE );
-            }
-        }
-
-        if( pZelle )
-        {
-            if( eErr != ConvOK )
-                ExcelToSc::SetError( *pZelle, eErr );
-#if 0
-            else
-                ExcelToSc::SetCurVal( *pZelle, rCurVal );
-#else
-            (void)rCurVal;
-#endif
-        }
-
-        GetXFRangeBuffer().SetXF( aScPos, nXF );
-    }
-}
-
-
-
-
-ExcelToSc::ExcelToSc( const XclImpRoot& rRoot ) :
-    ExcelConverterBase( 512 ),
-    XclImpRoot( rRoot ),
-    maFuncProv( rRoot ),
-    meBiff( rRoot.GetBiff() )
-{
-}
-
-ExcelToSc::~ExcelToSc()
-{
-}
-
-void ExcelToSc::GetDummy( const ScTokenArray*& pErgebnis )
-{
-    aPool.Store( CREATE_STRING( "Dummy()" ) );
-    aPool >> aStack;
-    pErgebnis = aPool[ aStack.Get() ];
-}
-
-
-// if bAllowArrays is false stream seeks to first byte after <nFormulaLen>
-// otherwise it will seek to the first byte after the additional content (eg
-// inline arrays) following <nFormulaLen>
-ConvErr ExcelToSc::Convert( const ScTokenArray*& pErgebnis, XclImpStream& aIn, sal_Size nFormulaLen, bool bAllowArrays, const FORMULA_TYPE eFT )
-{
-    RootData&       rR = GetOldRoot();
-    BYTE			nOp, nLen, nByte;
-    UINT16          nUINT16;
-    INT16			nINT16;
-    double			fDouble;
-    String			aString;
-    BOOL			bError = FALSE;
-    BOOL			bArrayFormula = FALSE;
-    TokenId			nMerk0;
-    const BOOL		bRangeName = eFT == FT_RangeName;
-    const BOOL		bSharedFormula = eFT == FT_SharedFormula;
-    const BOOL		bRNorSF = bRangeName || bSharedFormula;
-
-    ScSingleRefData		aSRD;
-    ScComplexRefData		aCRD;
-    ExtensionTypeVec    aExtensions;
-
-    bExternName = FALSE;
-
-    if( eStatus != ConvOK )
-    {
-        aIn.Ignore( nFormulaLen );
-        return eStatus;
-    }
-
-    if( nFormulaLen == 0 )
-    {
-        aPool.Store( CREATE_STRING( "-/-" ) );
-        aPool >> aStack;
-        pErgebnis = aPool[ aStack.Get() ];
-        return ConvOK;
-    }
-
-    sal_Size nEndPos = aIn.GetRecPos() + nFormulaLen;
-
-    while( (aIn.GetRecPos() < nEndPos) && !bError )
-    {
-        aIn >> nOp;
-
-        // #98524# always reset flags
-        aSRD.InitFlags();
-        aCRD.InitFlags();
-
-        switch( nOp )	//								Buch Seite:
-        {			//										SDK4 SDK5
-            case 0x01: // Array Formula							[325    ]
-                       // Array Formula or Shared Formula		[    277]
-            case 0x02: // Data Table							[325 277]
-                nUINT16 = 3;
-
-                if( meBiff != EXC_BIFF2 )
-                    nUINT16++;
-
-                aIn.Ignore( nUINT16 );
-
-                bArrayFormula = TRUE;
-                break;
-            case 0x03: // Addition								[312 264]
-                aStack >> nMerk0;
-                aPool <<  aStack << ocAdd << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x04: // Subtraction							[313 264]
-                // SECOMD-TOP minus TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocSub << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x05: // Multiplication						[313 264]
-                aStack >> nMerk0;
-                aPool << aStack << ocMul << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x06: // Division								[313 264]
-                // divide TOP by SECOND-TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocDiv << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x07: // Exponetiation							[313 265]
-                // raise SECOND-TOP to power of TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocPow << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x08: // Concatenation							[313 265]
-                // append TOP to SECOND-TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocAmpersand << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x09: // Less Than								[313 265]
-                // SECOND-TOP < TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocLess << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0A: // Less Than or Equal					[313 265]
-                // SECOND-TOP <= TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocLessEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0B: // Equal									[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0C: // Greater Than or Equal					[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocGreaterEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0D: // Greater Than							[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocGreater << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0E: // Not Equal								[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocNotEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0F: // Intersection							[314 265]
-                aStack >> nMerk0;
-                aPool << aStack << ocIntersect << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x10: // Union									[314 265]
-                // ocSep behelfsweise statt 'ocUnion'
-                aStack >> nMerk0;
-//#100928#      aPool << ocOpen << aStack << ocSep << nMerk0 << ocClose;
-                aPool << aStack << ocSep << nMerk0;
-                    // doesn't fit exactly, but is more Excel-like
-                aPool >> aStack;
-                break;
-            case 0x11: // Range									[314 265]
-                aStack >> nMerk0;
-                aPool << aStack << ocRange << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x12: // Unary Plus							[312 264]
-                aPool << ocAdd << aStack;
-                aPool >> aStack;
-                break;
-            case 0x13: // Unary Minus							[312 264]
-                aPool << ocNegSub << aStack;
-                aPool >> aStack;
-                break;
-            case 0x14: // Percent Sign							[312 264]
-                aPool << aStack << ocPercentSign;
-                aPool >> aStack;
-                break;
-            case 0x15: // Parenthesis							[326 278]
-                aPool << ocOpen << aStack << ocClose;
-                aPool >> aStack;
-                break;
-            case 0x16: // Missing Argument						[314 266]
-                aPool << ocMissing;
-                aPool >> aStack;
-                GetTracer().TraceFormulaMissingArg();
-                break;
-            case 0x17: // String Constant						[314 266]
-                aIn >> nLen;
-                aString = aIn.ReadRawByteString( nLen );
-
-                aStack << aPool.Store( aString );
-                break;
-            case 0x19: // Special Attribute						[327 279]
-            {
-                UINT16	nData, nFakt;
-                BYTE	nOpt;
-
-                aIn >> nOpt;
-
-                if( meBiff == EXC_BIFF2 )
-                {
-                    nData = aIn.ReaduInt8();
-                    nFakt = 1;
-                }
-                else
-                {
-                    aIn >> nData;
-                    nFakt = 2;
-                }
-
-                if( nOpt & 0x04 )
-                {// nFakt -> Bytes oder Words ueberlesen	AttrChoose
-                    nData++;
-                    aIn.Ignore( nData * nFakt );
-                }
-                else if( nOpt & 0x10 )						// AttrSum
-                    DoMulArgs( ocSum, 1 );
-            }
-                break;
-            case 0x1A: // External Reference					[330    ]
-                switch( meBiff )
-                {
-                    case EXC_BIFF2: aIn.Ignore( 7 );    break;
-                    case EXC_BIFF3:
-                    case EXC_BIFF4: aIn.Ignore( 10 );   break;
-                    case EXC_BIFF5:
-                        DBG_WARNING( "-ExcelToSc::Convert(): 0x1A gibt's nicht in Biff5!" );
-                    default:
-                        DBG_WARNING( "-ExcelToSc::Convert(): Ein wenig vergesslich, was?" );
-                }
-                break;
-            case 0x1B: // End External Reference				[330    ]
-                switch( meBiff )
-                {
-                    case EXC_BIFF2: aIn.Ignore( 3 );    break;
-                    case EXC_BIFF3:
-                    case EXC_BIFF4: aIn.Ignore( 4 );    break;
-                    case EXC_BIFF5:
-                        DBG_WARNING( "-ExcelToSc::Convert(): 0x1B gibt's nicht in Biff5!" );
-                    default:
-                        DBG_WARNING( "-ExcelToSc::Convert(): Ein wenig vergesslich, was?" );
-                }
-                break;
-            case 0x1C: // Error Value							[314 266]
-            {
-                aIn >> nByte;
-#if 0   // erAck
-                aPool.StoreError( XclTools::GetScErrorCode( nByte ) );
-#else
-                DefTokenId			eOc;
-                switch( nByte )
-                {
-                    case EXC_ERR_NULL:
-                    case EXC_ERR_DIV0:
-                    case EXC_ERR_VALUE:
-                    case EXC_ERR_REF:
-                    case EXC_ERR_NAME:
-                    case EXC_ERR_NUM:   eOc = ocStop;       break;
-                    case EXC_ERR_NA:    eOc = ocNotAvail;   break;
-                    default:            eOc = ocNoName;
-                }
-                aPool << eOc;
-                if( eOc != ocStop )
-                    aPool << ocOpen << ocClose;
-#endif
-                aPool >> aStack;
-            }
-                break;
-            case 0x1D: // Boolean								[315 266]
-                aIn >> nByte;
-                if( nByte == 0 )
-                    aPool << ocFalse << ocOpen << ocClose;
-                else
-                    aPool << ocTrue << ocOpen << ocClose;
-                aPool >> aStack;
-                break;
-            case 0x1E: // Integer								[315 266]
-                aIn >> nUINT16;
-                aStack << aPool.Store( ( double ) nUINT16 );
-                break;
-            case 0x1F: // Number								[315 266]
-                aIn >> fDouble;
-                aStack << aPool.Store( fDouble );
-                break;
-            case 0x40:
-            case 0x60:
-            case 0x20: // Array Constant						[317 268]
-                aIn >> nByte >> nUINT16;
-                aIn.Ignore( (meBiff == EXC_BIFF2) ? 3 : 4 );
-                if( bAllowArrays )
-                {
-                    aStack << aPool.StoreMatrix();
-                    aExtensions.push_back( EXTENSION_ARRAY );
-                }
-                else
-                {
-                    aPool << ocBad;
-                    aPool >> aStack;
-                }
-                break;
-            case 0x41:
-            case 0x61:
-            case 0x21: // Function, Fixed Number of Arguments	[333 282]
-            {
-                sal_uInt16 nXclFunc;
-                if( meBiff <= EXC_BIFF3 )
-                    nXclFunc = aIn.ReaduInt8();
-                else
-                    aIn >> nXclFunc;
-                if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, pFuncInfo->mnMaxParamCount, pFuncInfo->mnMinParamCount );
-                else
-                    DoMulArgs( ocNoName, 0 );
-            }
-            break;
-            case 0x42:
-            case 0x62:
-            case 0x22: // Function, Variable Number of Arg.		[333 283]
-            {
-                sal_uInt16 nXclFunc;
-                sal_uInt8 nParamCount;
-                aIn >> nParamCount;
-                nParamCount &= 0x7F;
-                if( meBiff <= EXC_BIFF3 )
-                    nXclFunc = aIn.ReaduInt8();
-                else
-                    aIn >> nXclFunc;
-                if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, nParamCount, pFuncInfo->mnMinParamCount );
-                else
-                    DoMulArgs( ocNoName, 0 );
-            }
-            break;
-            case 0x43:
-            case 0x63:
-            case 0x23: // Name									[318 269]
-            {
-                aIn >> nUINT16;
-                switch( meBiff )
-                {
-                    case EXC_BIFF2: aIn.Ignore( 5 );    break;
-                    case EXC_BIFF3:
-                    case EXC_BIFF4: aIn.Ignore( 8 );    break;
-                    case EXC_BIFF5: aIn.Ignore( 12 );   break;
-                    default:
-                        DBG_ERROR(
-                        "-ExcelToSc::Convert(): Ein wenig vergesslich, was?" );
-                }
-                const XclImpName* pName = GetNameManager().GetName( nUINT16 );
-                if(pName && !pName->GetScRangeData())
-                    aStack << aPool.Store( ocMacro, pName->GetXclName() );
-                else
-                    aStack << aPool.Store( nUINT16 );
-            }
-                break;
-            case 0x44:
-            case 0x64:
-            case 0x24: // Cell Reference						[319 270]
-            case 0x4A:
-            case 0x6A:
-            case 0x2A: // Deleted Cell Reference				[323 273]
-                aIn >> nUINT16 >> nByte;
-                aSRD.nCol = static_cast<SCsCOL>(nByte);
-                aSRD.nRow = nUINT16 & 0x3FFF;
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel( nUINT16, nByte, aSRD, bRangeName );
-
-                switch ( nOp )
-                {
-                    case 0x4A:
-                    case 0x6A:
-                    case 0x2A: // Deleted Cell Reference	 	[323 273]
-                        // no information which part is deleted, set both
-                        aSRD.SetColDeleted( TRUE );
-                        aSRD.SetRowDeleted( TRUE );
-                }
-
-                aStack << aPool.Store( aSRD );
-                break;
-            case 0x45:
-            case 0x65:
-            case 0x25: // Area Reference						[320 270]
-            case 0x4B:
-            case 0x6B:
-            case 0x2B: // Deleted Area Refernce					[323 273]
-            {
-                UINT16			nRowFirst, nRowLast;
-                UINT8			nColFirst, nColLast;
-                ScSingleRefData&	rSRef1 = aCRD.Ref1;
-                ScSingleRefData&	rSRef2 = aCRD.Ref2;
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                rSRef1.nRelTab = rSRef2.nRelTab = 0;
-                rSRef1.SetTabRel( TRUE );
-                rSRef2.SetTabRel( TRUE );
-                rSRef1.SetFlag3D( bRangeName );
-                rSRef2.SetFlag3D( bRangeName );
-
-                ExcRelToScRel( nRowFirst, nColFirst, aCRD.Ref1, bRangeName );
-                ExcRelToScRel( nRowLast, nColLast, aCRD.Ref2, bRangeName );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-                switch ( nOp )
-                {
-                    case 0x4B:
-                    case 0x6B:
-                    case 0x2B: // Deleted Area Refernce			[323 273]
-                        // no information which part is deleted, set all
-                        rSRef1.SetColDeleted( TRUE );
-                        rSRef1.SetRowDeleted( TRUE );
-                        rSRef2.SetColDeleted( TRUE );
-                        rSRef2.SetRowDeleted( TRUE );
-                }
-
-                aStack << aPool.Store( aCRD );
-            }
-                break;
-            case 0x46:
-            case 0x66:
-            case 0x26: // Constant Reference Subexpression		[321 271]
-                aExtensions.push_back( EXTENSION_MEMAREA );
-                // fall through
-
-            case 0x47:
-            case 0x67:
-            case 0x27: // Erroneous Constant Reference Subexpr.	[322 272]
-            case 0x48:
-            case 0x68:
-            case 0x28: // Incomplete Constant Reference Subexpr.[331 281]
-                aIn.Ignore( (meBiff == EXC_BIFF2) ? 4 : 6 );
-                break;
-            case 0x4C:
-            case 0x6C:
-            case 0x2C: // Cell Reference Within a Name			[323    ]
-                       // Cell Reference Within a Shared Formula[    273]
-            {
-                aIn >> nUINT16 >> nByte;	// >> Attribute, Row >> Col
-
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel( nUINT16, nByte, aSRD, bRNorSF );
-
-                aStack << aPool.Store( aSRD );
-            }
-                break;
-            case 0x4D:
-            case 0x6D:
-            case 0x2D: // Area Reference Within a Name			[324    ]
-            {	   // Area Reference Within a Shared Formula[    274]
-                UINT16					nRowFirst, nRowLast;
-                UINT8					nColFirst, nColLast;
-
-                aCRD.Ref1.nRelTab = aCRD.Ref2.nRelTab = 0;
-                aCRD.Ref1.SetTabRel( TRUE );
-                aCRD.Ref2.SetTabRel( TRUE );
-                aCRD.Ref1.SetFlag3D( bRangeName );
-                aCRD.Ref2.SetFlag3D( bRangeName );
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                ExcRelToScRel( nRowFirst, nColFirst, aCRD.Ref1, bRNorSF );
-                ExcRelToScRel( nRowLast, nColLast, aCRD.Ref2, bRNorSF );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-                aStack << aPool.Store( aCRD );
-            }
-                break;
-            case 0x49:
-            case 0x69:
-            case 0x29: // Variable Reference Subexpression      [331 281]
-            case 0x4E:
-            case 0x6E:
-            case 0x2E: // Reference Subexpression Within a Name	[332 282]
-            case 0x4F:
-            case 0x6F:
-            case 0x2F: // Incomplete Reference Subexpression...	[332 282]
-                aIn.Ignore( (meBiff == EXC_BIFF2) ? 1 : 2 );
-                break;
-            case 0x58:
-            case 0x78:
-            case 0x38: // Command-Equivalent Function			[333    ]
-                aString.AssignAscii( "COMM_EQU_FUNC" );
-                aIn >> nByte;
-                aString += String::CreateFromInt32( nByte );
-                aIn >> nByte;
-                aStack << aPool.Store( aString );
-                DoMulArgs( ocPush, nByte + 1 );
-                break;
-            case 0x59:
-            case 0x79:
-            case 0x39: // Name or External Name					[    275]
-                aIn >> nINT16;
-                aIn.Ignore( 8 );
-                aIn >> nUINT16;
-                if( nINT16 >= 0 )
-                {
-                    const ExtName* pExtName = rR.pExtNameBuff->GetNameByIndex( nINT16, nUINT16 );
-                    if( pExtName && pExtName->IsDDE() &&
-                        rR.pExtSheetBuff->IsLink( ( UINT16 ) nINT16 ) )
-                    {
-                        String			aAppl, aExtDoc;
-                        TokenId			nPar1, nPar2;
-
-                        rR.pExtSheetBuff->GetLink( ( UINT16 ) nINT16 , aAppl, aExtDoc );
-                        nPar1 = aPool.Store( aAppl );
-                        nPar2 = aPool.Store( aExtDoc );
-                        nMerk0 = aPool.Store( pExtName->aName );
-                        aPool	<< ocDde << ocOpen << nPar1 << ocSep << nPar2 << ocSep
-                                << nMerk0 << ocClose;
-
-                        GetDoc().CreateDdeLink( aAppl, aExtDoc, pExtName->aName, SC_DDE_DEFAULT );
-                    }
-                    else
-                        aPool << ocBad;
-
-                    aPool >> aStack;
-                }
-                else
-                    aStack << aPool.Store( nUINT16 );
-                aIn.Ignore( 12 );
-                break;
-            case 0x5A:
-            case 0x7A:
-            case 0x3A: // 3-D Cell Reference					[    275]
-            case 0x5C:
-            case 0x7C:
-            case 0x3C: // Deleted 3-D Cell Reference			[    277]
-            {
-                UINT16			nTabFirst, nTabLast, nRow;
-                INT16			nExtSheet;
-                BYTE			nCol;
-
-                aIn >> nExtSheet;
-                aIn.Ignore( 8 );
-                aIn >> nTabFirst >> nTabLast >> nRow >> nCol;
-
-                if( nExtSheet >= 0 )
-                {	// von extern
-                    if( rR.pExtSheetBuff->GetScTabIndex( nExtSheet, nTabLast ) )
-                    {
-                        nTabFirst = nTabLast;
-                        nExtSheet = 0;		// gefunden
-                    }
-                    else
-                    {
-                        aPool << ocBad;
-                        aPool >> aStack;
-                        nExtSheet = 1;		// verhindert Erzeugung einer SingleRef
-                    }
-                }
-
-                if( nExtSheet <= 0 )
-                {	// in aktuellem Workbook
-                    aSRD.nTab = static_cast<SCTAB>(nTabFirst);
-                    aSRD.SetFlag3D( TRUE );
-                    aSRD.SetTabRel( FALSE );
-
-                    ExcRelToScRel( nRow, nCol, aSRD, bRangeName );
-
-                    switch ( nOp )
-                    {
-                        case 0x5C:
-                        case 0x7C:
-                        case 0x3C: // Deleted 3-D Cell Reference	[    277]
-                            // no information which part is deleted, set both
-                            aSRD.SetColDeleted( TRUE );
-                            aSRD.SetRowDeleted( TRUE );
-                    }
-                    if ( !ValidTab(static_cast<SCTAB>(nTabFirst)) )
-                        aSRD.SetTabDeleted( TRUE );
-
-                    if( nTabLast != nTabFirst )
-                    {
-                        aCRD.Ref1 = aCRD.Ref2 = aSRD;
-                        aCRD.Ref2.nTab = static_cast<SCTAB>(nTabLast);
-                        aCRD.Ref2.SetTabDeleted( !ValidTab(static_cast<SCTAB>(nTabLast)) );
-                        aStack << aPool.Store( aCRD );
-                    }
-                    else
-                        aStack << aPool.Store( aSRD );
-                }
-            }
-
-                break;
-            case 0x5B:
-            case 0x7B:
-            case 0x3B: // 3-D Area Reference					[    276]
-            case 0x5D:
-            case 0x7D:
-            case 0x3D: // Deleted 3-D Area Reference			[    277]
-            {
-                UINT16		nTabFirst, nTabLast, nRowFirst, nRowLast;
-                INT16		nExtSheet;
-                BYTE		nColFirst, nColLast;
-
-                aIn >> nExtSheet;
-                aIn.Ignore( 8 );
-                aIn >> nTabFirst >> nTabLast >> nRowFirst >> nRowLast
-                    >> nColFirst >> nColLast;
-
-                if( nExtSheet >= 0 )
-                    // von extern
-                {
-                    if( rR.pExtSheetBuff->GetScTabIndex( nExtSheet, nTabLast ) )
-                    {
-                        nTabFirst = nTabLast;
-                        nExtSheet = 0;		// gefunden
-                    }
-                    else
-                    {
-                        aPool << ocBad;
-                        aPool >> aStack;
-                        nExtSheet = 1;		// verhindert Erzeugung einer CompleteRef
-                    }
-                }
-
-                if( nExtSheet <= 0 )
-                {// in aktuellem Workbook
-                    // erster Teil des Bereichs
-                    ScSingleRefData&	rR1 = aCRD.Ref1;
-                    ScSingleRefData&	rR2 = aCRD.Ref2;
-
-                    rR1.nTab = static_cast<SCTAB>(nTabFirst);
-                    rR2.nTab = static_cast<SCTAB>(nTabLast);
-                    rR1.SetFlag3D( TRUE );
-                    rR1.SetTabRel( FALSE );
-                    rR2.SetFlag3D( nTabFirst != nTabLast );
-                    rR2.SetTabRel( FALSE );
-
-                    ExcRelToScRel( nRowFirst, nColFirst, aCRD.Ref1, bRangeName );
-                    ExcRelToScRel( nRowLast, nColLast, aCRD.Ref2, bRangeName );
-
-                    if( IsComplColRange( nColFirst, nColLast ) )
-                        SetComplCol( aCRD );
-                    else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                        SetComplRow( aCRD );
-
-                    switch ( nOp )
-                    {
-                        case 0x5D:
-                        case 0x7D:
-                        case 0x3D: // Deleted 3-D Area Reference	[    277]
-                               // no information which part is deleted, set all
-                            rR1.SetColDeleted( TRUE );
-                            rR1.SetRowDeleted( TRUE );
-                            rR2.SetColDeleted( TRUE );
-                            rR2.SetRowDeleted( TRUE );
-                    }
-                    if ( !ValidTab(static_cast<SCTAB>(nTabFirst)) )
-                        rR1.SetTabDeleted( TRUE );
-                    if ( !ValidTab(static_cast<SCTAB>(nTabLast)) )
-                        rR2.SetTabDeleted( TRUE );
-
-                    aStack << aPool.Store( aCRD );
-                }//ENDE in aktuellem Workbook
-            }
-                break;
-            default: bError = TRUE;
-        }
-        bError |= !aIn.IsValid();
-    }
-
-    ConvErr eRet;
-
-    if( bError )
-    {
-        aPool << ocBad;
-        aPool >> aStack;
-        pErgebnis = aPool[ aStack.Get() ];
-        eRet = ConvErrNi;
-    }
-    else if( aIn.GetRecPos() != nEndPos )
-    {
-        aPool << ocBad;
-        aPool >> aStack;
-        pErgebnis = aPool[ aStack.Get() ];
-        eRet = ConvErrCount;
-    }
-    else if( bExternName )
-    {
-        pErgebnis = aPool[ aStack.Get() ];
-        eRet = ConvErrExternal;
-    }
-    else if( bArrayFormula )
-    {
-        pErgebnis = NULL;
-        eRet = ConvOK;
-    }
-    else
-    {
-        pErgebnis = aPool[ aStack.Get() ];
-        eRet = ConvOK;
-    }
-
-    aIn.Seek( nEndPos );
-
-    if( eRet == ConvOK )
-        ReadExtensions( aExtensions, aIn );
-
-    return eRet;
-}
-
-
-// stream seeks to first byte after <nFormulaLen>
-ConvErr ExcelToSc::Convert( _ScRangeListTabs& rRangeList, XclImpStream& aIn, sal_Size nFormulaLen,
-							SCsTAB nTab, const FORMULA_TYPE eFT )
-{
-    RootData&       rR = GetOldRoot();
-    BYTE			nOp, nLen;
-    sal_Size        nIgnore;
-    UINT16			nUINT16;
-    UINT8			nByte;
-    BOOL			bError = FALSE;
-    BOOL			bArrayFormula = FALSE;
-    const BOOL		bRangeName = eFT == FT_RangeName;
-    const BOOL		bSharedFormula = eFT == FT_SharedFormula;
-    const BOOL		bRNorSF = bRangeName || bSharedFormula;
-
-    ScSingleRefData	aSRD;
-    ScComplexRefData	aCRD;
-    aCRD.Ref1.nTab = aCRD.Ref2.nTab = aEingPos.Tab();
-
-    bExternName = FALSE;
-
-    if( eStatus != ConvOK )
-    {
-        aIn.Ignore( nFormulaLen );
-        return eStatus;
-    }
-
-    if( nFormulaLen == 0 )
-        return ConvOK;
-
-    sal_Size nEndPos = aIn.GetRecPos() + nFormulaLen;
-
-    while( (aIn.GetRecPos() < nEndPos) && !bError )
-    {
-        aIn >> nOp;
-        nIgnore = 0;
-
-        // #98524# always reset flags
-        aSRD.InitFlags();
-        aCRD.InitFlags();
-
-        switch( nOp )	//								Buch Seite:
-        {			//										SDK4 SDK5
-            case 0x01: // Array Formula							[325    ]
-                       // Array Formula or Shared Formula		[    277]
-                nIgnore = (meBiff == EXC_BIFF2) ? 3 : 4;
-                bArrayFormula = TRUE;
-                break;
-            case 0x02: // Data Table							[325 277]
-                nIgnore = (meBiff == EXC_BIFF2) ? 3 : 4;
-                break;
-            case 0x03: // Addition								[312 264]
-            case 0x04: // Subtraction							[313 264]
-            case 0x05: // Multiplication						[313 264]
-            case 0x06: // Division								[313 264]
-            case 0x07: // Exponetiation							[313 265]
-            case 0x08: // Concatenation							[313 265]
-            case 0x09: // Less Than								[313 265]
-            case 0x0A: // Less Than or Equal					[313 265]
-            case 0x0B: // Equal									[313 265]
-            case 0x0C: // Greater Than or Equal					[313 265]
-            case 0x0D: // Greater Than							[313 265]
-            case 0x0E: // Not Equal								[313 265]
-            case 0x0F: // Intersection							[314 265]
-            case 0x10: // Union									[314 265]
-            case 0x11: // Range									[314 265]
-            case 0x12: // Unary Plus							[312 264]
-            case 0x13: // Unary Minus							[312 264]
-            case 0x14: // Percent Sign							[312 264]
-            case 0x15: // Parenthesis							[326 278]
-            case 0x16: // Missing Argument						[314 266]
-                break;
-            case 0x17: // String Constant						[314 266]
-                aIn >> nLen;
-                nIgnore = nLen;
-                break;
-            case 0x19: // Special Attribute						[327 279]
-            {
-                UINT16 nData, nFakt;
-                BYTE nOpt;
-
-                aIn >> nOpt;
-
-                if( meBiff == EXC_BIFF2 )
-                {
-                    nData = aIn.ReaduInt8();
-                    nFakt = 1;
-                }
-                else
-                {
-                    aIn >> nData;
-                    nFakt = 2;
-                }
-
-                if( nOpt & 0x04 )
-                {// nFakt -> Bytes oder Words ueberlesen	AttrChoose
-                    nData++;
-                    aIn.Ignore( nData * nFakt );
-                }
-            }
-                break;
-            case 0x1A: // External Reference					[330    ]
-                switch( meBiff )
-                {
-                    case EXC_BIFF2: nIgnore = 7;    break;
-                    case EXC_BIFF3:
-                    case EXC_BIFF4: nIgnore = 10;   break;
-                    case EXC_BIFF5: DBG_WARNING( "-ExcelToSc::Convert(): 0x1A gibt's nicht in Biff5!" );
-                    default:        DBG_WARNING( "-ExcelToSc::Convert(): Ein wenig vergesslich, was?" );
-                }
-                break;
-            case 0x1B: // End External Reference				[330    ]
-                switch( meBiff )
-                {
-                    case EXC_BIFF2: nIgnore = 3;        break;
-                    case EXC_BIFF3:
-                    case EXC_BIFF4: nIgnore = 4;        break;
-                    case EXC_BIFF5: DBG_WARNING( "-ExcelToSc::Convert(): 0x1B gibt's nicht in Biff5!" );
-                    default:        DBG_WARNING( "-ExcelToSc::Convert(): Ein wenig vergesslich, was?" );
-                }
-                break;
-            case 0x1C: // Error Value							[314 266]
-            case 0x1D: // Boolean								[315 266]
-                nIgnore = 1;
-                break;
-            case 0x1E: // Integer								[315 266]
-                nIgnore = 2;
-                break;
-            case 0x1F: // Number								[315 266]
-                nIgnore = 8;
-                break;
-            case 0x40:
-            case 0x60:
-            case 0x20: // Array Constant						[317 268]
-                nIgnore = (meBiff == EXC_BIFF2) ? 6 : 7;
-                break;
-            case 0x41:
-            case 0x61:
-            case 0x21: // Function, Fixed Number of Arguments	[333 282]
-                nIgnore = (meBiff <= EXC_BIFF3) ? 1 : 2;
-                break;
-            case 0x42:
-            case 0x62:
-            case 0x22: // Function, Variable Number of Arg.		[333 283]
-                nIgnore = (meBiff <= EXC_BIFF3) ? 2 : 3;
-                break;
-            case 0x43:
-            case 0x63:
-            case 0x23: // Name									[318 269]
-                switch( meBiff )
-                {
-                    case EXC_BIFF2: nIgnore = 7;    break;
-                    case EXC_BIFF3:
-                    case EXC_BIFF4: nIgnore = 10;   break;
-                    case EXC_BIFF5: nIgnore = 14;   break;
-                    default:        DBG_ERROR( "-ExcelToSc::Convert(): Ein wenig vergesslich, was?" );
-                }
-                break;
-            case 0x44:
-            case 0x64:
-            case 0x24: // Cell Reference						[319 270]
-                aIn >> nUINT16 >> nByte;
-                aSRD.nCol = static_cast<SCsCOL>(nByte);
-                aSRD.nRow = nUINT16 & 0x3FFF;
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel( nUINT16, nByte, aSRD, bRangeName );
-
-				rRangeList.Append( aSRD, nTab );
-                break;
-            case 0x45:
-            case 0x65:
-            case 0x25: // Area Reference						[320 270]
-            {
-                UINT16			nRowFirst, nRowLast;
-                UINT8			nColFirst, nColLast;
-                ScSingleRefData	&rSRef1 = aCRD.Ref1;
-                ScSingleRefData	&rSRef2 = aCRD.Ref2;
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                rSRef1.nRelTab = rSRef2.nRelTab = 0;
-                rSRef1.SetTabRel( TRUE );
-                rSRef2.SetTabRel( TRUE );
-                rSRef1.SetFlag3D( bRangeName );
-                rSRef2.SetFlag3D( bRangeName );
-
-                ExcRelToScRel( nRowFirst, nColFirst, aCRD.Ref1, bRangeName );
-                ExcRelToScRel( nRowLast, nColLast, aCRD.Ref2, bRangeName );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-				rRangeList.Append( aCRD, nTab );
-            }
-                break;
-            case 0x46:
-            case 0x66:
-            case 0x26: // Constant Reference Subexpression		[321 271]
-            case 0x47:
-            case 0x67:
-            case 0x27: // Erroneous Constant Reference Subexpr.	[322 272]
-            case 0x48:
-            case 0x68:
-            case 0x28: // Incomplete Constant Reference Subexpr.[331 281]
-                nIgnore = (meBiff == EXC_BIFF2) ? 4 : 6;
-                break;
-            case 0x4A:
-            case 0x6A:
-            case 0x2A: // Deleted Cell Reference				[323 273]
-                nIgnore = 3;
-                break;
-            case 0x4B:
-            case 0x6B:
-            case 0x2B: // Deleted Area Refernce					[323 273]
-                nIgnore = 6;
-                break;
-            case 0x4C:
-            case 0x6C:
-            case 0x2C: // Cell Reference Within a Name			[323    ]
-                       // Cell Reference Within a Shared Formula[    273]
-            {
-                aIn >> nUINT16 >> nByte;	// >> Attribute, Row >> Col
-
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel( nUINT16, nByte, aSRD, bRNorSF );
-
-				rRangeList.Append( aSRD, nTab );
-            }
-                break;
-            case 0x4D:
-            case 0x6D:
-            case 0x2D: // Area Reference Within a Name			[324    ]
-            {	   // Area Reference Within a Shared Formula[    274]
-                UINT16					nRowFirst, nRowLast;
-                UINT8					nColFirst, nColLast;
-
-                aCRD.Ref1.nRelTab = aCRD.Ref2.nRelTab = 0;
-                aCRD.Ref1.SetTabRel( TRUE );
-                aCRD.Ref2.SetTabRel( TRUE );
-                aCRD.Ref1.SetFlag3D( bRangeName );
-                aCRD.Ref2.SetFlag3D( bRangeName );
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                ExcRelToScRel( nRowFirst, nColFirst, aCRD.Ref1, bRNorSF );
-                ExcRelToScRel( nRowLast, nColLast, aCRD.Ref2, bRNorSF );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-				rRangeList.Append( aCRD, nTab );
-            }
-                break;
-            case 0x49:
-            case 0x69:
-            case 0x29: // Variable Reference Subexpression      [331 281]
-            case 0x4E:
-            case 0x6E:
-            case 0x2E: // Reference Subexpression Within a Name	[332 282]
-            case 0x4F:
-            case 0x6F:
-            case 0x2F: // Incomplete Reference Subexpression...	[332 282]
-                nIgnore = (meBiff == EXC_BIFF2) ? 1 : 2;
-                break;
-            case 0x58:
-            case 0x78:
-            case 0x38: // Command-Equivalent Function			[333    ]
-                nIgnore = 2;
-                break;
-            case 0x59:
-            case 0x79:
-            case 0x39: // Name or External Name					[    275]
-                nIgnore = 24;
-                break;
-            case 0x5A:
-            case 0x7A:
-            case 0x3A: // 3-D Cell Reference					[    275]
-            {
-                UINT16			nTabFirst, nTabLast, nRow;
-                INT16			nExtSheet;
-                BYTE			nCol;
-
-                aIn >> nExtSheet;
-                aIn.Ignore( 8 );
-                aIn >> nTabFirst >> nTabLast >> nRow >> nCol;
-
-                if( nExtSheet >= 0 )
-                    // von extern
-                {
-                    if( rR.pExtSheetBuff->GetScTabIndex( nExtSheet, nTabLast ) )
-                    {
-                        nTabFirst = nTabLast;
-                        nExtSheet = 0;		// gefunden
-                    }
-                    else
-                    {
-                        aPool << ocBad;
-                        aPool >> aStack;
-                        nExtSheet = 1;		// verhindert Erzeugung einer SingleRef
-                    }
-                }
-
-                if( nExtSheet <= 0 )
-                {// in aktuellem Workbook
-                    BOOL b3D = ( static_cast<SCTAB>(nTabFirst) != aEingPos.Tab() ) || bRangeName;
-                    aSRD.nTab = static_cast<SCTAB>(nTabFirst);
-                    aSRD.SetFlag3D( b3D );
-                    aSRD.SetTabRel( FALSE );
-
-                    ExcRelToScRel( nRow, nCol, aSRD, bRangeName );
-
-                    if( nTabLast != nTabFirst )
-                    {
-                        aCRD.Ref1 = aSRD;
-                        aCRD.Ref2.nCol = aSRD.nCol;
-                        aCRD.Ref2.nRow = aSRD.nRow;
-                        aCRD.Ref2.nTab = static_cast<SCTAB>(nTabLast);
-                        b3D = ( static_cast<SCTAB>(nTabLast) != aEingPos.Tab() );
-                        aCRD.Ref2.SetFlag3D( b3D );
-                        aCRD.Ref2.SetTabRel( FALSE );
-						rRangeList.Append( aCRD, nTab );
-                    }
-                    else
-						rRangeList.Append( aSRD, nTab );
-                }
-            }
-
-                break;
-            case 0x5B:
-            case 0x7B:
-            case 0x3B: // 3-D Area Reference					[    276]
-            {
-                UINT16		nTabFirst, nTabLast, nRowFirst, nRowLast;
-                INT16		nExtSheet;
-                BYTE		nColFirst, nColLast;
-
-                aIn >> nExtSheet;
-                aIn.Ignore( 8 );
-                aIn >> nTabFirst >> nTabLast >> nRowFirst >> nRowLast
-                    >> nColFirst >> nColLast;
-
-                if( nExtSheet >= 0 )
-                    // von extern
-                {
-                    if( rR.pExtSheetBuff->GetScTabIndex( nExtSheet, nTabLast ) )
-                    {
-                        nTabFirst = nTabLast;
-                        nExtSheet = 0;		// gefunden
-                    }
-                    else
-                    {
-                        aPool << ocBad;
-                        aPool >> aStack;
-                        nExtSheet = 1;		// verhindert Erzeugung einer CompleteRef
-                    }
-                }
-
-                if( nExtSheet <= 0 )
-                {// in aktuellem Workbook
-                    // erster Teil des Bereichs
-                    ScSingleRefData	&rR1 = aCRD.Ref1;
-                    ScSingleRefData	&rR2 = aCRD.Ref2;
-
-                    rR1.nTab = static_cast<SCTAB>(nTabFirst);
-                    rR2.nTab = static_cast<SCTAB>(nTabLast);
-                    rR1.SetFlag3D( ( static_cast<SCTAB>(nTabFirst) != aEingPos.Tab() ) || bRangeName );
-                    rR1.SetTabRel( FALSE );
-                    rR2.SetFlag3D( ( static_cast<SCTAB>(nTabLast) != aEingPos.Tab() ) || bRangeName );
-                    rR2.SetTabRel( FALSE );
-
-                    ExcRelToScRel( nRowFirst, nColFirst, aCRD.Ref1, bRangeName );
-                    ExcRelToScRel( nRowLast, nColLast, aCRD.Ref2, bRangeName );
-
-                    if( IsComplColRange( nColFirst, nColLast ) )
-                        SetComplCol( aCRD );
-                    else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                        SetComplRow( aCRD );
-
-					rRangeList.Append( aCRD, nTab );
-                }//ENDE in aktuellem Workbook
-            }
-                break;
-            case 0x5C:
-            case 0x7C:
-            case 0x3C: // Deleted 3-D Cell Reference			[    277]
-                nIgnore = 17;
-                break;
-            case 0x5D:
-            case 0x7D:
-            case 0x3D: // Deleted 3-D Area Reference			[    277]
-                nIgnore = 20;
-                break;
-            default: bError = TRUE;
-        }
-        bError |= !aIn.IsValid();
-
-        aIn.Ignore( nIgnore );
-    }
-
-    ConvErr eRet;
-
-    if( bError )
-        eRet = ConvErrNi;
-    else if( aIn.GetRecPos() != nEndPos )
-        eRet = ConvErrCount;
-    else if( bExternName )
-        eRet = ConvErrExternal;
-    else if( bArrayFormula )
-        eRet = ConvOK;
-    else
-        eRet = ConvOK;
-
-    aIn.Seek( nEndPos );
-    return eRet;
-}
-
-ConvErr ExcelToSc::ConvertExternName( const ScTokenArray*& /*rpArray*/, XclImpStream& /*rStrm*/, sal_Size /*nFormulaLen*/,
-                                      const String& /*rUrl*/, const vector<String>& /*rTabNames*/ )
-{
-    // not implemented ...
-    return ConvErrNi;
-}
-
-BOOL ExcelToSc::GetAbsRefs( ScRangeList& rRangeList, XclImpStream& rStrm, sal_Size nLen )
-{
-    DBG_ASSERT_BIFF( GetBiff() == EXC_BIFF5 );
-    if( GetBiff() != EXC_BIFF5 )
-        return FALSE;
-
-    sal_uInt8 nOp;
-    sal_uInt16 nRow1, nRow2;
-    sal_uInt8 nCol1, nCol2;
-    SCTAB nTab1, nTab2;
-    sal_uInt16 nTabFirst, nTabLast;
-    sal_Int16 nRefIdx;
-
-    sal_Size nSeek;
-    sal_Size nEndPos = rStrm.GetRecPos() + nLen;
-
-    while( rStrm.IsValid() && (rStrm.GetRecPos() < nEndPos) )
-    {
-        rStrm >> nOp;
-        nSeek = 0;
-
-        switch( nOp )
-        {
-            case 0x44:
-            case 0x64:
-            case 0x24: // Cell Reference                        [319 270]
-            case 0x4C:
-            case 0x6C:
-            case 0x2C: // Cell Reference Within a Name          [323    ]
-                       // Cell Reference Within a Shared Formula[    273]
-                rStrm >> nRow1 >> nCol1;
-
-                nRow2 = nRow1;
-                nCol2 = nCol1;
-                nTab1 = nTab2 = GetCurrScTab();
-                goto _common;
-            case 0x45:
-            case 0x65:
-            case 0x25: // Area Reference                        [320 270]
-            case 0x4D:
-            case 0x6D:
-            case 0x2D: // Area Reference Within a Name          [324    ]
-                       // Area Reference Within a Shared Formula[    274]
-                rStrm >> nRow1 >> nRow2 >> nCol1 >> nCol2;
-
-                nTab1 = nTab2 = GetCurrScTab();
-                goto _common;
-            case 0x5A:
-            case 0x7A:
-            case 0x3A: // 3-D Cell Reference                    [    275]
-                rStrm >> nRefIdx;
-                rStrm.Ignore( 8 );
-                rStrm >> nTabFirst >> nTabLast >> nRow1 >> nCol1;
-
-                nRow2 = nRow1;
-                nCol2 = nCol1;
-
-                goto _3d_common;
-            case 0x5B:
-            case 0x7B:
-            case 0x3B: // 3-D Area Reference                    [    276]
-                rStrm >> nRefIdx;
-                rStrm.Ignore( 8 );
-                rStrm >> nTabFirst >> nTabLast >> nRow1 >> nRow2 >> nCol1 >> nCol2;
-
-    _3d_common:
-                nTab1 = static_cast< SCTAB >( nTabFirst );
-                nTab2 = static_cast< SCTAB >( nTabLast );
-
-                // #122885# skip references to deleted sheets
-                if( (nRefIdx >= 0) || !ValidTab( nTab1 ) || (nTab1 != nTab2) )
-                    break;
-
-                goto _common;
-    _common:
-                // do not check abs/rel flags, linked controls have set them!
-//               if( !(( nCol1 & 0xC000 ) || ( nCol2 & 0xC000 )) )
-                {
-                    ScRange aScRange;
-                    nRow1 &= 0x3FFF;
-                    nRow2 &= 0x3FFF;
-                    if( GetAddressConverter().ConvertRange( aScRange, XclRange( nCol1, nRow1, nCol2, nRow2 ), nTab1, nTab2, true ) )
-                        rRangeList.Append( aScRange );
-                }
-                break;
-
-            case 0x03: // Addition                              [312 264]
-            case 0x04: // Subtraction                           [313 264]
-            case 0x05: // Multiplication                        [313 264]
-            case 0x06: // Division                              [313 264]
-            case 0x07: // Exponetiation                         [313 265]
-            case 0x08: // Concatenation                         [313 265]
-            case 0x09: // Less Than                             [313 265]
-            case 0x0A: // Less Than or Equal                    [313 265]
-            case 0x0B: // Equal                                 [313 265]
-            case 0x0C: // Greater Than or Equal                 [313 265]
-            case 0x0D: // Greater Than                          [313 265]
-            case 0x0E: // Not Equal                             [313 265]
-            case 0x0F: // Intersection                          [314 265]
-            case 0x10: // Union                                 [314 265]
-            case 0x11: // Range                                 [314 265]
-            case 0x12: // Unary Plus                            [312 264]
-            case 0x13: // Unary Minus                           [312 264]
-            case 0x14: // Percent Sign                          [312 264]
-            case 0x15: // Parenthesis                           [326 278]
-            case 0x16: // Missing Argument                      [314 266]
-                break;
-            case 0x1C: // Error Value                           [314 266]
-            case 0x1D: // Boolean                               [315 266]
-                nSeek = 1;
-                break;
-            case 0x1E: // Integer                               [315 266]
-            case 0x41:
-            case 0x61:
-            case 0x21: // Function, Fixed Number of Arguments   [333 282]
-            case 0x49:
-            case 0x69:
-            case 0x29: // Variable Reference Subexpression      [331 281]
-            case 0x4E:
-            case 0x6E:
-            case 0x2E: // Reference Subexpression Within a Name [332 282]
-            case 0x4F:
-            case 0x6F:
-            case 0x2F: // Incomplete Reference Subexpression... [332 282]
-            case 0x58:
-            case 0x78:
-            case 0x38: // Command-Equivalent Function           [333    ]
-                nSeek = 2;
-                break;
-            case 0x42:
-            case 0x62:
-            case 0x22: // Function, Variable Number of Arg.     [333 283]
-            case 0x4A:
-            case 0x6A:
-            case 0x2A: // Deleted Cell Reference                [323 273]
-                nSeek = 3;
-                break;
-            case 0x01: // Array Formula                         [325    ]
-                       // Array Formula or Shared Formula       [    277]
-            case 0x02: // Data Table                            [325 277]
-                nSeek = 4;
-                break;
-            case 0x46:
-            case 0x66:
-            case 0x26: // Constant Reference Subexpression      [321 271]
-            case 0x47:
-            case 0x67:
-            case 0x27: // Erroneous Constant Reference Subexpr. [322 272]
-            case 0x48:
-            case 0x68:
-            case 0x28: // Incomplete Constant Reference Subexpr.[331 281]
-            case 0x4B:
-            case 0x6B:
-            case 0x2B: // Deleted Area Refernce                 [323 273]
-                nSeek = 6;
-                break;
-            case 0x40:
-            case 0x60:
-            case 0x20: // Array Constant                        [317 268]
-                nSeek = 7;
-                break;
-            case 0x1F: // Number                                [315 266]
-                nSeek = 8;
-                break;
-            case 0x43:
-            case 0x63:
-            case 0x23: // Name                                  [318 269]
-                nSeek = 14;
-                break;
-            case 0x5C:
-            case 0x7C:
-            case 0x3C: // Deleted 3-D Cell Reference            [    277]
-                nSeek = 17;
-                break;
-            case 0x5D:
-            case 0x7D:
-            case 0x3D: // Deleted 3-D Area Reference            [    277]
-                nSeek = 20;
-                break;
-            case 0x59:
-            case 0x79:
-            case 0x39: // Name or External Name                 [    275]
-                nSeek = 24;
-                break;
-            case 0x17: // String Constant                       [314 266]
-                nSeek = rStrm.ReaduInt8();
-                break;
-            case 0x19: // Special Attribute                     [327 279]
-            {
-                BYTE nOpt;
-                UINT16 nData;
-                rStrm >> nOpt >> nData;
-                if( nOpt & 0x04 )
-                    nSeek = nData * 2 + 2;
-            }
-                break;
-        }
-
-        rStrm.Ignore( nSeek );
-    }
-    rStrm.Seek( nEndPos );
-
-    return rRangeList.Count() != 0;
-}
-
-void ExcelToSc::DoMulArgs( DefTokenId eId, sal_uInt8 nAnz, sal_uInt8 nMinParamCount )
-{
-    TokenId					eParam[ 256 ];
-    INT32					nLauf;
-
-    if( eId == ocCeil || eId == ocFloor )
-    {
-        aStack << aPool.Store( 1.0 );	// default, da in Excel nicht vorhanden
-        nAnz++;
-    }
-
-    for( nLauf = 0; aStack.HasMoreTokens() && (nLauf < nAnz); nLauf++ )
-        aStack >> eParam[ nLauf ];
-    // #i70925# reduce parameter count, if no more tokens available on token stack
-    if( nLauf < nAnz )
-        nAnz = static_cast< sal_uInt8 >( nLauf );
-
-    if( nAnz > 0 && eId == ocExternal )
-    {
-        TokenId				n = eParam[ nAnz - 1 ];
-//##### GRUETZE FUER BASIC-FUNCS RICHTEN!
-        if( const String* pExt = aPool.GetExternal( n ) )
-        {
-            if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclMacroName( *pExt ) )
-                aPool << pFuncInfo->meOpCode;
-            else
-                aPool << n;
-            nAnz--;
-        }
-        else
-            aPool << eId;
-    }
-    else
-        aPool << eId;
-
-    aPool << ocOpen;
-
-    if( nAnz > 0 )
-    {
-        // attention: 0 = last parameter, nAnz-1 = first parameter
-        INT16 nNull = -1;		// skip this parameter
-        INT16 nSkipEnd = -1;	// skip all parameters <= nSkipEnd
-
-        INT16 nLast = nAnz - 1;
-
-        // Funktionen, bei denen Parameter wegfallen muessen
-        if( eId == ocPercentrank && nAnz == 3 )
-            nSkipEnd = 0;		// letzten Parameter bei Bedarf weglassen
-
-        // Joost-Spezialfaelle
-        else if( eId == ocIf )
-        {
-            UINT16			nNullParam = 0;
-            for( nLauf = 0 ; nLauf < nAnz ; nLauf++ )
-            {
-                if( aPool.IsSingleOp( eParam[ nLauf ], ocMissing ) )
-                {
-                    if( !nNullParam )
-                        nNullParam = (UINT16) aPool.Store( ( double ) 0.0 );
-                    eParam[ nLauf ] = nNullParam;
-                }
-            }
-        }
-
-        // FIXME: ideally we'd want to import all missing args, but this
-        // conflicts with lots of fn's understanding of nParams - we need
-        // a function table, and pre-call argument normalisation 1st.
-        INT16 nLastRemovable = nLast - nMinParamCount;
-
-        // #84453# skip missing parameters at end of parameter list
-        while( nSkipEnd < nLastRemovable &&
-               aPool.IsSingleOp( eParam[ nSkipEnd + 1 ], ocMissing ) )
-            nSkipEnd++;
-
-//		fprintf (stderr, "Fn %d nSkipEnd %d nLast %d nMinParamCnt %d %d\n",
-//				 eId, nSkipEnd, nLast, nMinParamCount, nLastRemovable);
-
-        // [Parameter{;Parameter}]
-        if( nLast > nSkipEnd )
-        {
-            aPool << eParam[ nLast ];
-            for( nLauf = nLast - 1 ; nLauf > nSkipEnd ; nLauf-- )
-            {
-                if( nLauf != nNull )
-                    aPool << ocSep << eParam[ nLauf ];
-            }
-        }
-    }
-    aPool << ocClose;
-
-    aPool >> aStack;
-}
-
-
-void ExcelToSc::ExcRelToScRel( UINT16 nRow, UINT8 nCol, ScSingleRefData &rSRD, const BOOL bName )
-{
-    if( bName )
-    {
-        // C O L
-        if( nRow & 0x4000 )
-        {//															rel Col
-            rSRD.SetColRel( TRUE );
-            rSRD.nRelCol = static_cast<SCsCOL>(static_cast<INT8>(nCol));
-        }
-        else
-        {//															abs Col
-            rSRD.SetColRel( FALSE );
-            rSRD.nCol = static_cast<SCCOL>(nCol);
-        }
-
-        // R O W
-        if( nRow & 0x8000 )
-        {//															rel Row
-            rSRD.SetRowRel( TRUE );
-            if( nRow & 0x2000 )	// Bit 13 gesetzt?
-                //												-> Row negativ
-                rSRD.nRelRow = static_cast<SCsROW>(static_cast<INT16>(nRow | 0xC000));
-            else
-                //												-> Row positiv
-                rSRD.nRelRow = static_cast<SCsROW>(nRow & nRowMask);
-        }
-        else
-        {//															abs Row
-            rSRD.SetRowRel( FALSE );
-            rSRD.nRow = static_cast<SCROW>(nRow & nRowMask);
-        }
-
-        // T A B
-        // #67965# abs needed if rel in shared formula for ScCompiler UpdateNameReference
-        if ( rSRD.IsTabRel() && !rSRD.IsFlag3D() )
-            rSRD.nTab = GetCurrScTab();
-    }
-    else
-    {
-        // C O L
-        rSRD.SetColRel( ( nRow & 0x4000 ) > 0 );
-        rSRD.nCol = static_cast<SCsCOL>(nCol);
-
-        // R O W
-        rSRD.SetRowRel( ( nRow & 0x8000 ) > 0 );
-        rSRD.nRow = static_cast<SCsROW>(nRow & nRowMask);
-
-        if ( rSRD.IsColRel() )
-            rSRD.nRelCol = rSRD.nCol - aEingPos.Col();
-        if ( rSRD.IsRowRel() )
-            rSRD.nRelRow = rSRD.nRow - aEingPos.Row();
-
-        // T A B
-        // #i10184# abs needed if rel in shared formula for ScCompiler UpdateNameReference
-        if ( rSRD.IsTabRel() && !rSRD.IsFlag3D() )
-            rSRD.nTab = GetCurrScTab() + rSRD.nRelTab;
-    }
-}
-
-
-const ScTokenArray* ExcelToSc::GetBoolErr( XclBoolError eType )
-{
-    UINT16					nError;
-    aPool.Reset();
-    aStack.Reset();
-
-    DefTokenId				eOc;
-
-    switch( eType )
-    {
-        case xlErrNull:     eOc = ocStop;       nError = errNoCode;             break;
-        case xlErrDiv0:     eOc = ocStop;       nError = errDivisionByZero;     break;
-        case xlErrValue:    eOc = ocStop;       nError = errNoValue;            break;
-        case xlErrRef:      eOc = ocStop;       nError = errNoRef;              break;
-        case xlErrName:     eOc = ocStop;       nError = errNoName;             break;
-        case xlErrNum:      eOc = ocStop;       nError = errIllegalFPOperation; break;
-        case xlErrNA:       eOc = ocNotAvail;   nError = NOTAVAILABLE;          break;
-        case xlErrTrue:     eOc = ocTrue;       nError = 0;                     break;
-        case xlErrFalse:    eOc = ocFalse;      nError = 0;                     break;
-        case xlErrUnknown:  eOc = ocStop;       nError = errUnknownState;       break;
-        default:
-            DBG_ERROR( "ExcelToSc::GetBoolErr - wrong enum!" );
-            eOc = ocNoName;
-            nError = errUnknownState;
-    }
-
-    aPool << eOc;
-    if( eOc != ocStop )
-        aPool << ocOpen << ocClose;
-
-    aPool >> aStack;
-
-    const ScTokenArray*		pErgebnis = aPool[ aStack.Get() ];
-    if( nError )
-        ( ( ScTokenArray* ) pErgebnis )->SetCodeError( nError );
-
-    ( ( ScTokenArray* ) pErgebnis )->SetRecalcModeNormal();
-
-    return pErgebnis;
-}
-
-
-// if a shared formula was found, stream seeks to first byte after <nFormulaLen>,
-// else stream pointer stays unchanged
-BOOL ExcelToSc::GetShrFmla( const ScTokenArray*& rpErgebnis, XclImpStream& aIn, sal_Size nFormulaLen )
-{
-    BYTE			nOp;
-    BOOL			bRet = TRUE;
-
-    if( nFormulaLen == 0 )
-        bRet = FALSE;
-    else
-    {
-        aIn.PushPosition();
-
-        aIn >> nOp;
-
-        if( nOp == 0x01 )	// Shared Formula		[    277]
-        {
-            UINT16 nCol, nRow;
-
-            aIn >> nRow >> nCol;
-
-            aStack << aPool.Store( GetOldRoot().pShrfmlaBuff->Find(
-                ScAddress( static_cast<SCCOL>(nCol), static_cast<SCROW>(nRow), GetCurrScTab() ) ) );
-
-            bRet = TRUE;
-        }
-        else
-            bRet = FALSE;
-
-        aIn.PopPosition();
-    }
-
-    if( bRet )
-    {
-        aIn.Ignore( nFormulaLen );
-        rpErgebnis = aPool[ aStack.Get() ];
-    }
-    else
-        rpErgebnis = NULL;
-
-    return bRet;
-}
-
-
-#if 0
-BOOL ExcelToSc::SetCurVal( ScFormulaCell &rCell, double &rfCurVal )
-{
-    UINT16	nInd;
-    BYTE	nType;
-    BYTE	nVal;
-    BOOL	bString = FALSE;
-
-#ifdef OSL_BIGENDIAN
-    // Code fuer alle anstaendigen Prozessoren
-    nType = *( ( ( BYTE * ) &rfCurVal ) + 7 );
-    nVal = *( ( ( BYTE * ) &rfCurVal ) + 5 );
-    nInd = *( ( UINT16 * ) &rfCurVal );
-#else
-    // fuer Schund-Prozessoren
-    nType = *( ( BYTE * ) &rfCurVal );
-    nVal = *( ( ( BYTE * ) &rfCurVal ) + 2 );
-    nInd = *( ( ( UINT16 * ) &rfCurVal ) + 3 );
-#endif
-
-    if( ( UINT16 ) ~nInd )
-        // Wert ist Float
-        rCell.SetHybridDouble( rfCurVal );
-    else
-    {
-        switch( nType )
-        {
-            case 0:		// String
-                bString = TRUE;
-                break;
-            case 1:		// Bool
-                if( nVal )
-                    rfCurVal = 1.0;
-                else
-                    rfCurVal = 0.0;
-                rCell.SetHybridDouble( rfCurVal );
-                break;
-            case 2:		// Error
-                rCell.SetErrCode( XclTools::GetScErrorCode( nVal ) );
-                break;
-        }
-    }
-
-    return bString;
-}
-#endif
-
-
-void ExcelToSc::SetError( ScFormulaCell &rCell, const ConvErr eErr )
-{
-    UINT16	nInd;
-
-    switch( eErr )
-    {
-        case ConvErrNi:			nInd = errUnknownToken; break;
-        case ConvErrNoMem:		nInd = errCodeOverflow; break;
-        case ConvErrExternal:	nInd = errNoName; break;
-        case ConvErrCount:		nInd = errCodeOverflow; break;
-        default:				nInd = errNoCode;	// hier fiel mir nichts
-                                                    //  Besseres ein...
-    }
-
-    rCell.SetErrCode( nInd );
-}
-
-
-void ExcelToSc::SetComplCol( ScComplexRefData &rCRD )
-{
-    ScSingleRefData	&rSRD = rCRD.Ref2;
-    if( rSRD.IsColRel() )
-        rSRD.nRelCol = MAXCOL - aEingPos.Col();
-    else
-        rSRD.nCol = MAXCOL;
-}
-
-
-void ExcelToSc::SetComplRow( ScComplexRefData &rCRD )
-{
-    ScSingleRefData	&rSRD = rCRD.Ref2;
-    if( rSRD.IsRowRel() )
-        rSRD.nRelRow = MAXROW - aEingPos.Row();
-    else
-        rSRD.nRow = MAXROW;
-}
-
-void ExcelToSc::ReadExtensionArray( unsigned int n, XclImpStream& aIn )
-{
-    // printf( "inline array;\n" );
-
-    BYTE        nByte;
-    UINT16      nUINT16;
-    double      fDouble;
-    String      aString;
-    ScMatrix*   pMatrix;
-
-    aIn >> nByte >> nUINT16;
-
-    SCSIZE nC, nCols;
-    SCSIZE nR, nRows;
-    if( GetBiff() == EXC_BIFF8 )
-    {
-        nCols = nByte + 1;
-        nRows = nUINT16 + 1;
-    }
-    else
-    {
-        nCols = nByte ? nByte : 256;
-        nRows = nUINT16;
-    }
-
-    pMatrix = aPool.GetMatrix( n );
-
-    if( NULL != pMatrix )
-    {
-        pMatrix->Resize(nCols, nRows);
-        pMatrix->GetDimensions( nC, nR);
-        if( nC != nCols || nR != nRows )
-        {
-            DBG_ERRORFILE( "ExcelToSc::ReadExtensionArray - matrix size mismatch" );
-            pMatrix = NULL;
-        }
-    }
-    else
-    {
-        DBG_ERRORFILE( "ExcelToSc::ReadExtensionArray - missing matrix" );
-    }
-
-    for( nR = 0 ; nR < nRows; nR++ )
-    {
-        for( nC = 0 ; nC < nCols; nC++ )
-        {
-            aIn >> nByte;
-            switch( nByte )
-            {
-                case EXC_CACHEDVAL_EMPTY:
-                    aIn.Ignore( 8 );
-                    if( NULL != pMatrix )
-                    {
-                        pMatrix->PutEmpty( nC, nR );
-                    }
-                    break;
-
-                case EXC_CACHEDVAL_DOUBLE:
-                    aIn >> fDouble;
-                    if( NULL != pMatrix )
-                    {
-                        pMatrix->PutDouble( fDouble, nC, nR );
-                    }
-                    break;
-
-                case EXC_CACHEDVAL_STRING:
-                    if( GetBiff() == EXC_BIFF8 )
-                    {
-                        aIn >> nUINT16;
-                        aString = aIn.ReadUniString( nUINT16 );
-                    }
-                    else
-                    {
-                        aIn >> nByte;
-                        aString = aIn.ReadRawByteString( nByte );
-                    }
-                    if( NULL != pMatrix )
-                    {
-                        pMatrix->PutString( aString, nC, nR );
-                    }
-                    break;
-
-                case EXC_CACHEDVAL_BOOL:
-                    aIn >> nByte;
-                    aIn.Ignore( 7 );
-                    if( NULL != pMatrix )
-                    {
-                        pMatrix->PutBoolean( nByte != 0, nC, nR );
-                    }
-                    break;
-
-                case EXC_CACHEDVAL_ERROR:
-                    aIn >> nByte;
-                    aIn.Ignore( 7 );
-                    if( NULL != pMatrix )
-                    {
-                        pMatrix->PutError( XclTools::GetScErrorCode( nByte ), nC, nR );
-                    }
-                    break;
-            }
-        }
-    }
-}
-
-void ExcelToSc::ReadExtensionNlr( XclImpStream& aIn )
-{
-    // printf( "natural lang fmla;\n" );
-
-    sal_uInt32 nFlags;
-    aIn >> nFlags;
-
-    sal_uInt32 nCount = nFlags & EXC_TOK_NLR_ADDMASK;
-    aIn.Ignore( nCount * 4 ); // Drop the cell positions
-}
-
-void ExcelToSc::ReadExtensionMemArea( XclImpStream& aIn )
-{
-    // printf( "mem area;\n" );
-
-    sal_uInt16 nCount;
-    aIn >> nCount;
-
-    aIn.Ignore( nCount * ((GetBiff() == EXC_BIFF8) ? 8 : 6) ); // drop the ranges
-}
-
-void ExcelToSc::ReadExtensions( const ExtensionTypeVec& rExtensions,
-                                XclImpStream& aIn )
-{
-    unsigned int nArray = 0;
-
-    for( unsigned int i = 0 ; i < rExtensions.size() ; i++ )
-    {
-        ExtensionType eType = rExtensions[i];
-
-        switch( eType )
-        {
-            case EXTENSION_ARRAY:
-                ReadExtensionArray( nArray++, aIn );
-                break;
-
-            case EXTENSION_NLR:
-                ReadExtensionNlr( aIn );
-                break;
-
-            case EXTENSION_MEMAREA:
-                ReadExtensionMemArea( aIn );
-                break;
-        }
-    }
-}
-
diff --git sc/source/filter/xlsx/xlsx-excform8.cxx sc/source/filter/xlsx/xlsx-excform8.cxx
deleted file mode 100644
index 056f573..0000000
--- sc/source/filter/xlsx/xlsx-excform8.cxx
+++ /dev/null
@@ -1,1600 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: excform8.cxx,v $
- * $Revision: 1.47.134.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "excform.hxx"
-
-#include "cell.hxx"
-#include "document.hxx"
-#include "rangenam.hxx"
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xilink.hxx"
-#include "xiname.hxx"
-
-#include "externalrefmgr.hxx"
-
-#include <vector>
-
-using ::std::vector;
-
-ExcelToSc8::ExternalTabInfo::ExternalTabInfo() :
-    mnFileId(0), mbExternal(false)
-{
-}
-
-// ============================================================================
-
-ExcelToSc8::ExcelToSc8( const XclImpRoot& rRoot ) :
-    ExcelToSc( rRoot ),
-    rLinkMan( rRoot.GetLinkManager() )
-{
-}
-
-
-ExcelToSc8::~ExcelToSc8()
-{
-}
-
-bool ExcelToSc8::GetExternalFileIdFromXti( UINT16 nIxti, sal_uInt16& rFileId ) const
-{
-    const String* pFileUrl = rLinkMan.GetSupbookUrl(nIxti);
-    if (!pFileUrl || pFileUrl->Len() == 0 || !GetDocShell())
-        return false;
-
-    String aFileUrl = ScGlobal::GetAbsDocName(*pFileUrl, GetDocShell());
-    ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
-    rFileId = pRefMgr->getExternalFileId(aFileUrl);
-
-    return true;
-}
-
-bool ExcelToSc8::Read3DTabReference( UINT16 nIxti, SCTAB& rFirstTab, SCTAB& rLastTab, ExternalTabInfo& rExtInfo )
-{
-    rFirstTab = rLastTab = 0;
-    rExtInfo.mbExternal = !rLinkMan.IsSelfRef(nIxti);
-    bool bSuccess = rLinkMan.GetScTabRange(rFirstTab, rLastTab, nIxti);
-    if (!bSuccess)
-        return false;
-
-    if (!rExtInfo.mbExternal)
-        // This is internal reference.  Stop here.
-        return true;
-
-    rExtInfo.maTabName = rLinkMan.GetSupbookTabName(nIxti, rFirstTab);
-    return GetExternalFileIdFromXti(nIxti, rExtInfo.mnFileId);
-}
-
-
-// if bAllowArrays is false stream seeks to first byte after <nFormulaLen>
-// otherwise it will seek to the first byte past additional content after <nFormulaLen>
-ConvErr ExcelToSc8::Convert( const ScTokenArray*& rpTokArray, XclImpStream& aIn, sal_Size nFormulaLen, bool bAllowArrays, const FORMULA_TYPE eFT )
-{
-    BYTE					nOp, nLen, nByte;
-    UINT16                  nUINT16;
-    double					fDouble;
-    String					aString;
-    BOOL					bError = FALSE;
-    BOOL					bArrayFormula = FALSE;
-    TokenId					nMerk0;
-    const BOOL				bRangeName = eFT == FT_RangeName;
-    const BOOL				bSharedFormula = eFT == FT_SharedFormula;
-    const BOOL				bRNorSF = bRangeName || bSharedFormula;
-
-    ScSingleRefData			aSRD;
-    ScComplexRefData			aCRD;
-    ExtensionTypeVec		aExtensions;
-
-    if( eStatus != ConvOK )
-    {
-        aIn.Ignore( nFormulaLen );
-        return eStatus;
-    }
-
-    if( nFormulaLen == 0 )
-    {
-        aPool.Store( CREATE_STRING( "-/-" ) );
-        aPool >> aStack;
-        rpTokArray = aPool[ aStack.Get() ];
-        return ConvOK;
-    }
-
-    sal_Size nEndPos = aIn.GetRecPos() + nFormulaLen;
-
-    while( (aIn.GetRecPos() < nEndPos) && !bError )
-    {
-        aIn >> nOp;
-
-        // #98524# always reset flags
-        aSRD.InitFlags();
-        aCRD.InitFlags();
-
-        switch( nOp )	//								Buch Seite:
-        {			//										SDK4 SDK5
-            case 0x01: // Array Formula							[325    ]
-                       // Array Formula or Shared Formula		[    277]
-            case 0x02: // Data Table							[325 277]
-                aIn.Ignore( 4 );
-
-                bArrayFormula = TRUE;
-                break;
-            case 0x03: // Addition								[312 264]
-                aStack >> nMerk0;
-                aPool <<  aStack << ocAdd << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x04: // Subtraction							[313 264]
-                // SECOMD-TOP minus TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocSub << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x05: // Multiplication						[313 264]
-                aStack >> nMerk0;
-                aPool << aStack << ocMul << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x06: // Division								[313 264]
-                // divide TOP by SECOND-TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocDiv << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x07: // Exponetiation							[313 265]
-                // raise SECOND-TOP to power of TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocPow << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x08: // Concatenation							[313 265]
-                // append TOP to SECOND-TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocAmpersand << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x09: // Less Than								[313 265]
-                // SECOND-TOP < TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocLess << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0A: // Less Than or Equal					[313 265]
-                // SECOND-TOP <= TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocLessEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0B: // Equal									[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0C: // Greater Than or Equal					[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocGreaterEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0D: // Greater Than							[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocGreater << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0E: // Not Equal								[313 265]
-                // SECOND-TOP == TOP
-                aStack >> nMerk0;
-                aPool << aStack << ocNotEqual << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x0F: // Intersection							[314 265]
-                aStack >> nMerk0;
-                aPool << aStack << ocIntersect << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x10: // Union									[314 265]
-                // ocSep behelfsweise statt 'ocUnion'
-                aStack >> nMerk0;
-//#100928#      aPool << ocOpen << aStack << ocSep << nMerk0 << ocClose;
-                aPool << aStack << ocSep << nMerk0;
-                    // doesn't fit exactly, but is more Excel-like
-                aPool >> aStack;
-                break;
-            case 0x11: // Range									[314 265]
-                aStack >> nMerk0;
-                aPool << aStack << ocRange << nMerk0;
-                aPool >> aStack;
-                break;
-            case 0x12: // Unary Plus							[312 264]
-                aPool << ocAdd << aStack;
-                aPool >> aStack;
-                break;
-            case 0x13: // Unary Minus							[312 264]
-                aPool << ocNegSub << aStack;
-                aPool >> aStack;
-                break;
-            case 0x14: // Percent Sign							[312 264]
-                aPool << aStack << ocPercentSign;
-                aPool >> aStack;
-                break;
-            case 0x15: // Parenthesis							[326 278]
-                aPool << ocOpen << aStack << ocClose;
-                aPool >> aStack;
-                break;
-            case 0x16: // Missing Argument						[314 266]
-                aPool << ocMissing;
-                aPool >> aStack;
-                GetTracer().TraceFormulaMissingArg();
-                break;
-            case 0x17: // String Constant						[314 266]
-                aIn >> nLen;		// und?
-                aString = aIn.ReadUniString( nLen );            // reads Grbit even if nLen==0
-
-                aStack << aPool.Store( aString );
-                break;
-            case 0x18:											// natural language formula
-                {
-                UINT8	nEptg;
-                UINT16	nCol, nRow;
-                aIn >> nEptg;
-                switch( nEptg )
-                {							//	name		size	ext		type
-                    case 0x01:				//	Lel			4		-		err
-                        aIn.Ignore( 4 );
-                        aPool << ocBad;
-                        aPool >> aStack;
-                    break;
-                    case 0x02:				//	Rw			4		-		ref
-                    case 0x03:				//	Col			4		-		ref
-                    case 0x06:				//	RwV			4		-		val
-                    case 0x07:				//	ColV		4		-		val
-                        aIn >> nRow >> nCol;
-
-                        aSRD.InitAddress( ScAddress( static_cast<SCCOL>(nCol & 0xFF), static_cast<SCROW>(nRow), aEingPos.Tab() ) );
-
-                        if( nEptg == 0x02 || nEptg == 0x06 )
-                            aSRD.SetRowRel( TRUE );
-                        else
-                            aSRD.SetColRel( TRUE );
-
-                        aSRD.CalcRelFromAbs( aEingPos );
-
-                        aStack << aPool.StoreNlf( aSRD );
-                        break;
-                    case 0x0A:				//	Radical		13		-		ref
-                        aIn >> nRow >> nCol;
-                        aIn.Ignore( 9 );
-
-                        aSRD.InitAddress( ScAddress( static_cast<SCCOL>(nCol & 0xFF), static_cast<SCROW>(nRow), aEingPos.Tab() ) );
-
-                        aSRD.SetColRel( TRUE );
-
-                        aSRD.CalcRelFromAbs( aEingPos );
-
-                        aStack << aPool.StoreNlf( aSRD );
-                        break;
-                    case 0x0B:				//	RadicalS	13		x		ref
-                        aIn.Ignore( 13 );
-                        aExtensions.push_back( EXTENSION_NLR );
-                        aPool << ocBad;
-                        aPool >> aStack;
-                    break;
-                    case 0x0C:				//	RwS			4		x		ref
-                    case 0x0D:              //  ColS        4       x       ref
-                    case 0x0E:              //  RwSV        4       x       val
-                    case 0x0F:              //  ColSV       4       x       val
-                        aIn.Ignore( 4 );
-                        aExtensions.push_back( EXTENSION_NLR );
-                        aPool << ocBad;
-                        aPool >> aStack;
-                    break;
-                    case 0x10:				//	RadicalLel	4		-		err
-                    case 0x1D:              //  SxName      4       -       val
-                        aIn.Ignore( 4 );
-                        aPool << ocBad;
-                        aPool >> aStack;
-                    break;
-                    default:
-                        aPool << ocBad;
-                        aPool >> aStack;
-                }
-                }
-                break;
-            case 0x19: // Special Attribute						[327 279]
-            {
-                UINT16 nData, nFakt;
-                BYTE nOpt;
-
-                aIn >> nOpt >> nData;
-                nFakt = 2;
-
-                if( nOpt & 0x04 )
-                {// nFakt -> Bytes oder Words ueberlesen	AttrChoose
-                    nData++;
-                    aIn.Ignore( nData * nFakt );
-                }
-                else if( nOpt & 0x10 )						// AttrSum
-                    DoMulArgs( ocSum, 1 );
-            }
-                break;
-            case 0x1C: // Error Value							[314 266]
-            {
-                aIn >> nByte;
-#if 0   // erAck
-                aPool.StoreError( XclTools::GetScErrorCode( nByte ) );
-#else
-                DefTokenId			eOc;
-                switch( nByte )
-                {
-                    case EXC_ERR_NULL:
-                    case EXC_ERR_DIV0:
-                    case EXC_ERR_VALUE:
-                    case EXC_ERR_REF:
-                    case EXC_ERR_NAME:
-                    case EXC_ERR_NUM:   eOc = ocStop;       break;
-                    case EXC_ERR_NA:    eOc = ocNotAvail;   break;
-                    default:            eOc = ocNoName;
-                }
-                aPool << eOc;
-                if( eOc != ocStop )
-                    aPool << ocOpen << ocClose;
-#endif
-                aPool >> aStack;
-            }
-                break;
-            case 0x1D: // Boolean								[315 266]
-                aIn >> nByte;
-                if( nByte == 0 )
-                    aPool << ocFalse << ocOpen << ocClose;
-                else
-                    aPool << ocTrue << ocOpen << ocClose;
-                aPool >> aStack;
-                break;
-            case 0x1E: // Integer								[315 266]
-                aIn >> nUINT16;
-                aStack << aPool.Store( ( double ) nUINT16 );
-                break;
-            case 0x1F: // Number								[315 266]
-                aIn >> fDouble;
-                aStack << aPool.Store( fDouble );
-                break;
-            case 0x40:
-            case 0x60:
-            case 0x20: // Array Constant						[317 268]
-                aIn >> nByte >> nUINT16;
-                aIn.Ignore( 4 );
-                if( bAllowArrays )
-                {
-                    aStack << aPool.StoreMatrix();
-                    aExtensions.push_back( EXTENSION_ARRAY );
-                }
-                else
-                {
-                    aPool << ocBad;
-                    aPool >> aStack;
-                }
-                break;
-            case 0x41:
-            case 0x61:
-            case 0x21: // Function, Fixed Number of Arguments	[333 282]
-            {
-                sal_uInt16 nXclFunc;
-                aIn >> nXclFunc;
-                if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, pFuncInfo->mnMaxParamCount );
-                else
-                    DoMulArgs( ocNoName, 0 );
-            }
-            break;
-            case 0x42:
-            case 0x62:
-            case 0x22: // Function, Variable Number of Arg.		[333 283]
-            {
-                sal_uInt16 nXclFunc;
-                sal_uInt8 nParamCount;
-                aIn >> nParamCount >> nXclFunc;
-                nParamCount &= 0x7F;
-                if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, nParamCount, pFuncInfo->mnMinParamCount );
-                else
-                    DoMulArgs( ocNoName, 0 );
-            }
-            break;
-            case 0x43:
-            case 0x63:
-            case 0x23: // Name									[318 269]
-                aIn >> nUINT16;
-            {
-                aIn.Ignore( 2 );
-                //Determine if this is a user-defined Macro name.
-                const XclImpName* pName = GetNameManager().GetName( nUINT16 );
-                if(pName && !pName->GetScRangeData())
-                    aStack << aPool.Store( ocMacro, pName->GetXclName() );
-                else
-                    aStack << aPool.Store( nUINT16 );
-            }
-            break;
-            case 0x44:
-            case 0x64:
-            case 0x24: // Cell Reference						[319 270]
-            case 0x4A:
-            case 0x6A:
-            case 0x2A: // Deleted Cell Reference				[323 273]
-            {
-                UINT16			nCol, nRow;
-
-                aIn >> nRow >> nCol;
-
-                aSRD.nCol = static_cast<SCCOL>(nCol);
-                aSRD.nRow = nRow & 0x3FFF;
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel8( nRow, nCol, aSRD, bRangeName );
-
-                switch ( nOp )
-                {
-                    case 0x4A:
-                    case 0x6A:
-                    case 0x2A: // Deleted Cell Reference	 	[323 273]
-                        // no information which part is deleted, set both
-                        aSRD.SetColDeleted( TRUE );
-                        aSRD.SetRowDeleted( TRUE );
-                }
-
-                aStack << aPool.Store( aSRD );
-            }
-                break;
-            case 0x45:
-            case 0x65:
-            case 0x25: // Area Reference						[320 270]
-            case 0x4B:
-            case 0x6B:
-            case 0x2B: // Deleted Area Refernce					[323 273]
-            {
-                UINT16			nRowFirst, nRowLast;
-                UINT16			nColFirst, nColLast;
-                ScSingleRefData	&rSRef1 = aCRD.Ref1;
-                ScSingleRefData	&rSRef2 = aCRD.Ref2;
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                rSRef1.nRelTab = rSRef2.nRelTab = 0;
-                rSRef1.SetTabRel( TRUE );
-                rSRef2.SetTabRel( TRUE );
-                rSRef1.SetFlag3D( bRangeName );
-                rSRef2.SetFlag3D( bRangeName );
-
-                ExcRelToScRel8( nRowFirst, nColFirst, aCRD.Ref1, bRangeName );
-                ExcRelToScRel8( nRowLast, nColLast, aCRD.Ref2, bRangeName );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-                switch ( nOp )
-                {
-                    case 0x4B:
-                    case 0x6B:
-                    case 0x2B: // Deleted Area Refernce			[323 273]
-                        // no information which part is deleted, set all
-                        rSRef1.SetColDeleted( TRUE );
-                        rSRef1.SetRowDeleted( TRUE );
-                        rSRef2.SetColDeleted( TRUE );
-                        rSRef2.SetRowDeleted( TRUE );
-                }
-
-                aStack << aPool.Store( aCRD );
-            }
-                break;
-            case 0x46:
-            case 0x66:
-            case 0x26: // Constant Reference Subexpression		[321 271]
-                aExtensions.push_back( EXTENSION_MEMAREA );
-                aIn.Ignore( 6 );       // mehr steht da nicht!
-                break;
-            case 0x47:
-            case 0x67:
-            case 0x27: // Erroneous Constant Reference Subexpr.	[322 272]
-                aIn.Ignore( 6 );   // mehr steht da nicht!
-//               aPool << ocBad;
-//               aPool >> aStack;
-                break;
-            case 0x48:
-            case 0x68:
-            case 0x28: // Incomplete Constant Reference Subexpr.[331 281]
-                aIn.Ignore( 6 );   // mehr steht da nicht!
-//               aPool << ocBad;
-//               aPool >> aStack;
-                break;
-            case 0x49:
-            case 0x69:
-            case 0x29: // Variable Reference Subexpression		[331 281]
-                aIn.Ignore( 2 );   // mehr steht da nicht!
-                break;
-            case 0x4C:
-            case 0x6C:
-            case 0x2C: // Cell Reference Within a Name			[323    ]
-                       // Cell Reference Within a Shared Formula[    273]
-            {
-                UINT16		nRow, nCol;
-
-                aIn >> nRow >> nCol;
-
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel8( nRow, nCol, aSRD, bRNorSF );
-
-                aStack << aPool.Store( aSRD );
-            }
-                break;
-            case 0x4D:
-            case 0x6D:
-            case 0x2D: // Area Reference Within a Name			[324    ]
-            {	   // Area Reference Within a Shared Formula[    274]
-                UINT16					nRowFirst, nRowLast;
-                UINT16					nColFirst, nColLast;
-
-                aCRD.Ref1.nRelTab = aCRD.Ref2.nRelTab = 0;
-                aCRD.Ref1.SetTabRel( TRUE );
-                aCRD.Ref2.SetTabRel( TRUE );
-                aCRD.Ref1.SetFlag3D( bRangeName );
-                aCRD.Ref2.SetFlag3D( bRangeName );
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                ExcRelToScRel8( nRowFirst, nColFirst, aCRD.Ref1, bRNorSF );
-                ExcRelToScRel8( nRowLast, nColLast, aCRD.Ref2, bRNorSF );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-                aStack << aPool.Store( aCRD );
-            }
-                break;
-            case 0x4E:
-            case 0x6E:
-            case 0x2E: // Reference Subexpression Within a Name	[332 282]
-                aIn.Ignore( 2 );   // mehr steht da nicht!
-//               aPool << ocBad;
-//               aPool >> aStack;
-                break;
-            case 0x4F:
-            case 0x6F:
-            case 0x2F: // Incomplete Reference Subexpression...	[332 282]
-                aIn.Ignore( 2 );   // mehr steht da nicht!
-//               aPool << ocBad;
-//               aPool >> aStack;
-                break;
-            case 0x58:
-            case 0x78:
-            case 0x38: // Command-Equivalent Function			[333    ]
-                aString.AssignAscii( "COMM_EQU_FUNC" );
-                aIn >> nByte;
-                aString += String::CreateFromInt32( nByte );
-                aIn >> nByte;
-                aStack << aPool.Store( aString );
-                DoMulArgs( ocPush, nByte + 1 );
-                break;
-            case 0x59:
-            case 0x79:
-            case 0x39: // Name or External Name					[    275]
-            {
-                sal_uInt16 nXtiIndex, nNameIdx;
-                aIn >> nXtiIndex >> nNameIdx;
-                aIn.Ignore( 2 );
-
-                if( rLinkMan.IsSelfRef( nXtiIndex ) )
-                {
-                    // internal defined name with explicit sheet, i.e.: =Sheet1!AnyName
-                    const XclImpName* pName = GetNameManager().GetName( nNameIdx );
-                    if( pName && !pName->GetScRangeData() )
-                        aStack << aPool.Store( ocMacro, pName->GetXclName() );
-                    else
-                        aStack << aPool.Store( nNameIdx );
-                }
-                else if( const XclImpExtName* pExtName = rLinkMan.GetExternName( nXtiIndex, nNameIdx ) )
-                {
-                    switch( pExtName->GetType() )
-                    {
-                        case xlExtName:
-                        {
-                            /* FIXME: enable this code for #i4385# once
-                             * external name reference can be stored in ODF,
-                             * which remains to be done for #i3740#. Until then
-                             * create a #NAME? token. */
-#if 1
-                            sal_uInt16 nFileId;
-                            if (!GetExternalFileIdFromXti(nXtiIndex, nFileId) || !pExtName->HasFormulaTokens())
-                            {
-                                aStack << aPool.Store(ocNoName, pExtName->GetName());
-                                break;
-                            }
-
-                            aStack << aPool.StoreExtName(nFileId, pExtName->GetName());
-                            pExtName->CreateExtNameData(GetDoc(), nFileId);
-#else
-                            aStack << aPool.Store( ocNoName, pExtName->GetName() );
-#endif
-                        }
-                        break;
-
-                        case xlExtAddIn:
-                        {
-                            aStack << aPool.Store( ocExternal, pExtName->GetName() );
-                        }
-                        break;
-
-                        case xlExtDDE:
-                        {
-                            String aApplic, aTopic;
-                            if( rLinkMan.GetLinkData( aApplic, aTopic, nXtiIndex ) )
-                            {
-                                TokenId nPar1 = aPool.Store( aApplic );
-                                TokenId nPar2 = aPool.Store( aTopic );
-                                nMerk0 = aPool.Store( pExtName->GetName() );
-                                aPool   << ocDde << ocOpen << nPar1 << ocSep << nPar2 << ocSep
-                                        << nMerk0 << ocClose;
-                                aPool >> aStack;
-                                pExtName->CreateDdeData( GetDoc(), aApplic, aTopic );
-                            }
-                        }
-                        break;
-
-                        case xlExtEuroConvert:
-                            {
-                                aStack << aPool.Store( ocEuroConvert, String() );
-                            }
-                        break;
-
-                        default:    // OLE link
-                        {
-                            aPool << ocBad;
-                            aPool >> aStack;
-                        }
-                    }
-                }
-                else
-                {
-                    //aStack << ocNoName;
-                    aPool << ocBad;
-                    aPool >> aStack;
-                }
-            }
-                break;
-            case 0x5A:
-            case 0x7A:
-            case 0x3A: // 3-D Cell Reference					[    275]
-            case 0x5C:
-            case 0x7C:
-            case 0x3C: // Deleted 3-D Cell Reference			[    277]
-            {
-                UINT16 nIxti, nRw, nGrbitCol;
-                SCTAB nTabFirst, nTabLast;
-
-                aIn >> nIxti >> nRw >> nGrbitCol;
-
-                ExternalTabInfo aExtInfo;
-                if (!Read3DTabReference(nIxti, nTabFirst, nTabLast, aExtInfo))
-                {
-                    aPool << ocBad;
-                    aPool >> aStack;
-                    break;
-                }
-
-                aSRD.nTab = nTabFirst;
-                aSRD.SetFlag3D( TRUE );
-                aSRD.SetTabRel( FALSE );
-
-                ExcRelToScRel8( nRw, nGrbitCol, aSRD, bRangeName );
-
-                switch ( nOp )
-                {
-                    case 0x5C:
-                    case 0x7C:
-                    case 0x3C: // Deleted 3-D Cell Reference	[    277]
-                        // no information which part is deleted, set both
-                        aSRD.SetColDeleted( TRUE );
-                        aSRD.SetRowDeleted( TRUE );
-                }
-
-                if (aExtInfo.mbExternal)
-                {
-                    // nTabFirst and nTabLast are the indices of the refernced
-                    // sheets in the SUPBOOK record, hence do not represent
-                    // the actual indices of the original sheets since the
-                    // SUPBOOK record only stores referenced sheets and skips
-                    // the ones that are not referenced.
-
-                    if (nTabLast != nTabFirst)
-                    {
-                        aCRD.Ref1 = aCRD.Ref2 = aSRD;
-                        aCRD.Ref2.nTab = nTabLast;
-                        aStack << aPool.StoreExtRef(aExtInfo.mnFileId, aExtInfo.maTabName, aCRD);
-                    }
-                    else
-                        aStack << aPool.StoreExtRef(aExtInfo.mnFileId, aExtInfo.maTabName, aSRD);
-                }
-                else
-                {
-                    if ( !ValidTab(nTabFirst))
-                        aSRD.SetTabDeleted( TRUE );
-
-                    if( nTabLast != nTabFirst )
-                    {
-                        aCRD.Ref1 = aCRD.Ref2 = aSRD;
-                        aCRD.Ref2.nTab = nTabLast;
-                        aCRD.Ref2.SetTabDeleted( !ValidTab(nTabLast) );
-                        aStack << aPool.Store( aCRD );
-                    }
-                    else
-                        aStack << aPool.Store( aSRD );
-                }
-            }
-                break;
-            case 0x5B:
-            case 0x7B:
-            case 0x3B: // 3-D Area Reference					[    276]
-            case 0x5D:
-            case 0x7D:
-            case 0x3D: // Deleted 3-D Area Reference			[    277]
-            {
-                UINT16 nIxti, nRw1, nGrbitCol1, nRw2, nGrbitCol2;
-                SCTAB nTabFirst, nTabLast;
-                aIn >> nIxti >> nRw1 >> nRw2 >> nGrbitCol1 >> nGrbitCol2;
-
-                ExternalTabInfo aExtInfo;
-                if (!Read3DTabReference(nIxti, nTabFirst, nTabLast, aExtInfo))
-                {
-                    aPool << ocBad;
-                    aPool >> aStack;
-                    break;
-                }
-                ScSingleRefData	&rR1 = aCRD.Ref1;
-                ScSingleRefData	&rR2 = aCRD.Ref2;
-
-
-                rR1.nTab = nTabFirst;
-                rR2.nTab = nTabLast;
-                rR1.SetFlag3D( TRUE );
-                rR1.SetTabRel( FALSE );
-                rR2.SetFlag3D( nTabFirst != nTabLast );
-                rR2.SetTabRel( FALSE );
-
-                ExcRelToScRel8( nRw1, nGrbitCol1, aCRD.Ref1, bRangeName );
-                ExcRelToScRel8( nRw2, nGrbitCol2, aCRD.Ref2, bRangeName );
-
-                if( IsComplColRange( nGrbitCol1, nGrbitCol2 ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRw1, nRw2 ) )
-                    SetComplRow( aCRD );
-
-                switch ( nOp )
-                {
-                    case 0x5D:
-                    case 0x7D:
-                    case 0x3D: // Deleted 3-D Area Reference	[    277]
-                        // no information which part is deleted, set all
-                        rR1.SetColDeleted( TRUE );
-                        rR1.SetRowDeleted( TRUE );
-                        rR2.SetColDeleted( TRUE );
-                        rR2.SetRowDeleted( TRUE );
-                }
-
-                if (aExtInfo.mbExternal)
-                {
-                    aStack << aPool.StoreExtRef(aExtInfo.mnFileId, aExtInfo.maTabName, aCRD);
-                }
-                else
-                {
-                    if ( !ValidTab(nTabFirst) )
-                        rR1.SetTabDeleted( TRUE );
-                    if ( !ValidTab(nTabLast) )
-                        rR2.SetTabDeleted( TRUE );
-
-                    aStack << aPool.Store( aCRD );
-                }
-            }
-                break;
-            default: bError = TRUE;
-        }
-        bError |= !aIn.IsValid();
-    }
-
-    ConvErr eRet;
-
-    if( bError )
-    {
-        aPool << ocBad;
-        aPool >> aStack;
-        rpTokArray = aPool[ aStack.Get() ];
-        eRet = ConvErrNi;
-    }
-    else if( aIn.GetRecPos() != nEndPos )
-    {
-        aPool << ocBad;
-        aPool >> aStack;
-        rpTokArray = aPool[ aStack.Get() ];
-        eRet = ConvErrCount;
-    }
-    else if( bArrayFormula )
-    {
-        rpTokArray = NULL;
-        eRet = ConvOK;
-    }
-    else
-    {
-        rpTokArray = aPool[ aStack.Get() ];
-        eRet = ConvOK;
-    }
-
-    aIn.Seek( nEndPos );
-
-    if( eRet == ConvOK)
-        ReadExtensions( aExtensions, aIn );
-
-    return eRet;
-}
-
-
-// stream seeks to first byte after <nFormulaLen>
-ConvErr ExcelToSc8::Convert( _ScRangeListTabs& rRangeList, XclImpStream& aIn, sal_Size nFormulaLen,
-							  SCsTAB nTab, const FORMULA_TYPE eFT )
-{
-    BYTE					nOp, nLen;//, nByte;
-    BOOL					bError = FALSE;
-    BOOL					bArrayFormula = FALSE;
-    const BOOL				bRangeName = eFT == FT_RangeName;
-    const BOOL				bSharedFormula = eFT == FT_SharedFormula;
-    const BOOL				bRNorSF = bRangeName || bSharedFormula;
-
-    ScSingleRefData			aSRD;
-    ScComplexRefData			aCRD;
-
-    bExternName = FALSE;
-
-    if( eStatus != ConvOK )
-    {
-        aIn.Ignore( nFormulaLen );
-        return eStatus;
-    }
-
-    if( nFormulaLen == 0 )
-        return ConvOK;
-
-    sal_Size nEndPos = aIn.GetRecPos() + nFormulaLen;
-
-    while( (aIn.GetRecPos() < nEndPos) && !bError )
-    {
-        aIn >> nOp;
-
-        // #98524# always reset flags
-        aSRD.InitFlags();
-        aCRD.InitFlags();
-
-        switch( nOp )	//								Buch Seite:
-        {			//										SDK4 SDK5
-            case 0x01: // Array Formula							[325    ]
-                       // Array Formula or Shared Formula		[    277]
-                aIn.Ignore( 4 );
-
-                bArrayFormula = TRUE;
-                break;
-            case 0x02: // Data Table							[325 277]
-                aIn.Ignore( 4 );
-                break;
-            case 0x03: // Addition								[312 264]
-            case 0x04: // Subtraction							[313 264]
-            case 0x05: // Multiplication						[313 264]
-            case 0x06: // Division								[313 264]
-            case 0x07: // Exponetiation							[313 265]
-            case 0x08: // Concatenation							[313 265]
-            case 0x09: // Less Than								[313 265]
-            case 0x0A: // Less Than or Equal					[313 265]
-            case 0x0B: // Equal									[313 265]
-            case 0x0C: // Greater Than or Equal					[313 265]
-            case 0x0D: // Greater Than							[313 265]
-            case 0x0E: // Not Equal								[313 265]
-            case 0x0F: // Intersection							[314 265]
-            case 0x10: // Union									[314 265]
-            case 0x11: // Range									[314 265]
-            case 0x12: // Unary Plus							[312 264]
-            case 0x13: // Unary Minus							[312 264]
-            case 0x14: // Percent Sign							[312 264]
-            case 0x15: // Parenthesis							[326 278]
-            case 0x16: // Missing Argument						[314 266]
-                break;
-            case 0x17: // String Constant						[314 266]
-                aIn >> nLen;		// und?
-
-                aIn.IgnoreUniString( nLen );		// reads Grbit even if nLen==0
-                break;
-            case 0x19: // Special Attribute						[327 279]
-            {
-                UINT16 nData, nFakt;
-                BYTE nOpt;
-
-                aIn >> nOpt >> nData;
-                nFakt = 2;
-
-                if( nOpt & 0x04 )
-                {// nFakt -> Bytes oder Words ueberlesen	AttrChoose
-                    nData++;
-                    aIn.Ignore( nData * nFakt );
-                }
-            }
-                break;
-            case 0x1C: // Error Value							[314 266]
-            case 0x1D: // Boolean								[315 266]
-                aIn.Ignore( 1 );
-                break;
-            case 0x1E: // Integer								[315 266]
-                aIn.Ignore( 2 );
-                break;
-            case 0x1F: // Number								[315 266]
-                aIn.Ignore( 8 );
-                break;
-            case 0x40:
-            case 0x60:
-            case 0x20: // Array Constant						[317 268]
-                aIn.Ignore( 7 );
-                break;
-            case 0x41:
-            case 0x61:
-            case 0x21: // Function, Fixed Number of Arguments	[333 282]
-                aIn.Ignore( 2 );
-                break;
-            case 0x42:
-            case 0x62:
-            case 0x22: // Function, Variable Number of Arg.		[333 283]
-                aIn.Ignore( 3 );
-                break;
-            case 0x43:
-            case 0x63:
-            case 0x23: // Name									[318 269]
-                aIn.Ignore( 4 );
-                break;
-            case 0x44:
-            case 0x64:
-            case 0x24: // Cell Reference						[319 270]
-            {
-                UINT16			nCol, nRow;
-
-                aIn >> nRow >> nCol;
-
-                aSRD.nCol = static_cast<SCCOL>(nCol);
-                aSRD.nRow = nRow & 0x3FFF;
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel8( nRow, nCol, aSRD, bRangeName );
-
-				rRangeList.Append( aSRD, nTab );
-            }
-                break;
-            case 0x45:
-            case 0x65:
-            case 0x25: // Area Reference						[320 270]
-            {
-                UINT16			nRowFirst, nRowLast;
-                UINT16			nColFirst, nColLast;
-                ScSingleRefData	&rSRef1 = aCRD.Ref1;
-                ScSingleRefData	&rSRef2 = aCRD.Ref2;
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                rSRef1.nRelTab = rSRef2.nRelTab = 0;
-                rSRef1.SetTabRel( TRUE );
-                rSRef2.SetTabRel( TRUE );
-                rSRef1.SetFlag3D( bRangeName );
-                rSRef2.SetFlag3D( bRangeName );
-
-                ExcRelToScRel8( nRowFirst, nColFirst, aCRD.Ref1, bRangeName );
-                ExcRelToScRel8( nRowLast, nColLast, aCRD.Ref2, bRangeName );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-				rRangeList.Append( aCRD, nTab );
-            }
-                break;
-            case 0x46:
-            case 0x66:
-            case 0x26: // Constant Reference Subexpression		[321 271]
-            case 0x47:
-            case 0x67:
-            case 0x27: // Erroneous Constant Reference Subexpr.	[322 272]
-            case 0x48:
-            case 0x68:
-            case 0x28: // Incomplete Constant Reference Subexpr.[331 281]
-                aIn.Ignore( 6 );   // mehr steht da nicht!
-                break;
-            case 0x49:
-            case 0x69:
-            case 0x29: // Variable Reference Subexpression		[331 281]
-                aIn.Ignore( 2 );   // mehr steht da nicht!
-                break;
-            case 0x4A:
-            case 0x6A:
-            case 0x2A: // Deleted Cell Reference				[323 273]
-                aIn.Ignore( 3 );
-                break;
-            case 0x4B:
-            case 0x6B:
-            case 0x2B: // Deleted Area Refernce					[323 273]
-                aIn.Ignore( 6 );
-                break;
-            case 0x4C:
-            case 0x6C:
-            case 0x2C: // Cell Reference Within a Name			[323    ]
-                       // Cell Reference Within a Shared Formula[    273]
-            {
-                UINT16		nRow, nCol;
-
-                aIn >> nRow >> nCol;
-
-                aSRD.nRelTab = 0;
-                aSRD.SetTabRel( TRUE );
-                aSRD.SetFlag3D( bRangeName );
-
-                ExcRelToScRel8( nRow, nCol, aSRD, bRNorSF );
-
-				rRangeList.Append( aSRD, nTab );
-            }
-                break;
-            case 0x4D:
-            case 0x6D:
-            case 0x2D: // Area Reference Within a Name			[324    ]
-            {	   // Area Reference Within a Shared Formula[    274]
-                UINT16					nRowFirst, nRowLast;
-                UINT16					nColFirst, nColLast;
-
-                aCRD.Ref1.nRelTab = aCRD.Ref2.nRelTab = 0;
-                aCRD.Ref1.SetTabRel( TRUE );
-                aCRD.Ref2.SetTabRel( TRUE );
-                aCRD.Ref1.SetFlag3D( bRangeName );
-                aCRD.Ref2.SetFlag3D( bRangeName );
-
-                aIn >> nRowFirst >> nRowLast >> nColFirst >> nColLast;
-
-                ExcRelToScRel8( nRowFirst, nColFirst, aCRD.Ref1, bRNorSF );
-                ExcRelToScRel8( nRowLast, nColLast, aCRD.Ref2, bRNorSF );
-
-                if( IsComplColRange( nColFirst, nColLast ) )
-                    SetComplCol( aCRD );
-                else if( IsComplRowRange( nRowFirst, nRowLast ) )
-                    SetComplRow( aCRD );
-
-				rRangeList.Append( aCRD, nTab );
-            }
-                break;
-            case 0x4E:
-            case 0x6E:
-            case 0x2E: // Reference Subexpression Within a Name	[332 282]
-            case 0x4F:
-            case 0x6F:
-            case 0x2F: // Incomplete Reference Subexpression...	[332 282]
-            case 0x58:
-            case 0x78:
-            case 0x38: // Command-Equivalent Function			[333    ]
-                aIn.Ignore( 2 );
-                break;
-            case 0x59:
-            case 0x79:
-            case 0x39: // Name or External Name					[    275]
-                aIn.Ignore( 24 );
-                break;
-            case 0x5A:
-            case 0x7A:
-            case 0x3A: // 3-D Cell Reference					[    275]
-            {
-                UINT16			nIxti, nRw, nGrbitCol;
-
-                aIn >> nIxti >> nRw >> nGrbitCol;
-
-                SCTAB nFirstScTab, nLastScTab;
-                if( rLinkMan.GetScTabRange( nFirstScTab, nLastScTab, nIxti ) )
-                {
-                    aSRD.nTab = nFirstScTab;
-                    aSRD.SetFlag3D( TRUE );
-                    aSRD.SetTabRel( FALSE );
-
-                    ExcRelToScRel8( nRw, nGrbitCol, aSRD, bRangeName );
-
-                    if( nFirstScTab != nLastScTab )
-                    {
-                        aCRD.Ref1 = aSRD;
-                        aCRD.Ref2.nCol = aSRD.nCol;
-                        aCRD.Ref2.nRow = aSRD.nRow;
-                        aCRD.Ref2.nTab = nLastScTab;
-						rRangeList.Append( aCRD, nTab );
-                    }
-                    else
-						rRangeList.Append( aSRD, nTab );
-                }
-            }
-                break;
-            case 0x5B:
-            case 0x7B:
-            case 0x3B: // 3-D Area Reference					[    276]
-            {
-                UINT16			nIxti, nRw1, nGrbitCol1, nRw2, nGrbitCol2;
-
-                aIn >> nIxti >> nRw1 >> nRw2 >> nGrbitCol1 >> nGrbitCol2;
-
-                SCTAB nFirstScTab, nLastScTab;
-                if( rLinkMan.GetScTabRange( nFirstScTab, nLastScTab, nIxti ) )
-                {
-                    ScSingleRefData	&rR1 = aCRD.Ref1;
-                    ScSingleRefData	&rR2 = aCRD.Ref2;
-
-                    rR1.nTab = nFirstScTab;
-                    rR2.nTab = nLastScTab;
-                    rR1.SetFlag3D( TRUE );
-                    rR1.SetTabRel( FALSE );
-                    rR2.SetFlag3D( nFirstScTab != nLastScTab );
-                    rR2.SetTabRel( FALSE );
-
-                    ExcRelToScRel8( nRw1, nGrbitCol1, aCRD.Ref1, bRangeName );
-                    ExcRelToScRel8( nRw2, nGrbitCol2, aCRD.Ref2, bRangeName );
-
-                    if( IsComplColRange( nGrbitCol1, nGrbitCol2 ) )
-                        SetComplCol( aCRD );
-                    else if( IsComplRowRange( nRw1, nRw2 ) )
-                        SetComplRow( aCRD );
-
-					rRangeList.Append( aCRD, nTab );
-                }
-            }
-                break;
-            case 0x5C:
-            case 0x7C:
-            case 0x3C: // Deleted 3-D Cell Reference			[    277]
-                aIn.Ignore( 6 );
-                break;
-            case 0x5D:
-            case 0x7D:
-            case 0x3D: // Deleted 3-D Area Reference			[    277]
-                aIn.Ignore( 10 );
-                break;
-            default:
-                bError = TRUE;
-        }
-        bError |= !aIn.IsValid();
-    }
-
-    ConvErr eRet;
-
-    if( bError )
-        eRet = ConvErrNi;
-    else if( aIn.GetRecPos() != nEndPos )
-        eRet = ConvErrCount;
-    else if( bExternName )
-        eRet = ConvErrExternal;
-    else
-        eRet = ConvOK;
-
-    aIn.Seek( nEndPos );
-    return eRet;
-}
-
-ConvErr ExcelToSc8::ConvertExternName( const ScTokenArray*& rpArray, XclImpStream& rStrm, sal_Size nFormulaLen,
-                                       const String& rUrl, const vector<String>& rTabNames )
-{
-    if( !GetDocShell() )
-        return ConvErrNi;
-
-    String aFileUrl = ScGlobal::GetAbsDocName(rUrl, GetDocShell());
-
-    sal_uInt8               nOp, nByte;
-    bool                    bError = false;
-
-    ScSingleRefData           aSRD;
-    ScComplexRefData            aCRD;
-
-    if (eStatus != ConvOK)
-    {
-        rStrm.Ignore(nFormulaLen);
-        return eStatus;
-    }
-
-    if (nFormulaLen == 0)
-    {
-        aPool.Store(CREATE_STRING("-/-"));
-        aPool >> aStack;
-        rpArray = aPool[aStack.Get()];
-        return ConvOK;
-    }
-
-    ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
-    sal_uInt16 nFileId = pRefMgr->getExternalFileId(aFileUrl);
-    sal_uInt16 nTabCount = static_cast< sal_uInt16 >( rTabNames.size() );
-
-    sal_Size nEndPos = rStrm.GetRecPos() + nFormulaLen;
-
-    while( (rStrm.GetRecPos() < nEndPos) && !bError )
-    {
-        rStrm >> nOp;
-
-        // #98524# always reset flags
-        aSRD.InitFlags();
-        aCRD.InitFlags();
-
-        switch( nOp )
-        {
-            case 0x1C: // Error Value
-            {
-                rStrm >> nByte;
-                DefTokenId eOc;
-                switch( nByte )
-                {
-                    case EXC_ERR_NULL:
-                    case EXC_ERR_DIV0:
-                    case EXC_ERR_VALUE:
-                    case EXC_ERR_REF:
-                    case EXC_ERR_NAME:
-                    case EXC_ERR_NUM:   eOc = ocStop;       break;
-                    case EXC_ERR_NA:    eOc = ocNotAvail;   break;
-                    default:            eOc = ocNoName;
-                }
-                aPool << eOc;
-                if( eOc != ocStop )
-                    aPool << ocOpen << ocClose;
-                aPool >> aStack;
-            }
-            break;
-            case 0x3A:
-            {
-                // cell reference in external range name
-                sal_uInt16 nExtTab1, nExtTab2, nRow, nGrbitCol;
-                rStrm >> nExtTab1 >> nExtTab2 >> nRow >> nGrbitCol;
-                if (nExtTab1 >= nTabCount || nExtTab2 >= nTabCount)
-                {
-                    bError = true;
-                    break;
-                }
-
-                aSRD.nTab = nExtTab1;
-                aSRD.SetFlag3D(true);
-                aSRD.SetTabRel(false);
-                ExcRelToScRel8(nRow, nGrbitCol, aSRD, true);
-                aCRD.Ref1 = aCRD.Ref2 = aSRD;
-                String aTabName = rTabNames[nExtTab1];
-
-                if (nExtTab1 == nExtTab2)
-                {
-                    // single cell reference
-                    aStack << aPool.StoreExtRef(nFileId, aTabName, aSRD);
-                }
-                else
-                {
-                    // area reference
-                    aCRD.Ref2.nTab = nExtTab2;
-                    aStack << aPool.StoreExtRef(nFileId, aTabName, aCRD);
-                }
-            }
-            break;
-            case 0x3B:
-            {
-                // area reference
-                sal_uInt16 nExtTab1, nExtTab2, nRow1, nRow2, nGrbitCol1, nGrbitCol2;
-                rStrm >> nExtTab1 >> nExtTab2 >> nRow1 >> nRow2 >> nGrbitCol1 >> nGrbitCol2;
-                ScSingleRefData& rR1 = aCRD.Ref1;
-                ScSingleRefData& rR2 = aCRD.Ref2;
-
-                rR1.nTab = nExtTab1;
-                rR1.SetFlag3D(true);
-                rR1.SetTabRel(false);
-                ExcRelToScRel8(nRow1, nGrbitCol1, rR1, true);
-
-                rR2.nTab = nExtTab2;
-                rR2.SetFlag3D(true);
-                rR2.SetTabRel(false);
-                ExcRelToScRel8(nRow2, nGrbitCol2, rR2, true);
-
-                String aTabName = rTabNames[nExtTab1];
-                aStack << aPool.StoreExtRef(nFileId, aTabName, aCRD);
-            }
-            break;
-            default:
-                bError = true;
-        }
-        bError |= !rStrm.IsValid();
-    }
-
-    ConvErr eRet;
-
-    if( bError )
-    {
-        aPool << ocBad;
-        aPool >> aStack;
-        rpArray = aPool[ aStack.Get() ];
-        eRet = ConvErrNi;
-    }
-    else if( rStrm.GetRecPos() != nEndPos )
-    {
-        aPool << ocBad;
-        aPool >> aStack;
-        rpArray = aPool[ aStack.Get() ];
-        eRet = ConvErrCount;
-    }
-    else
-    {
-        rpArray = aPool[ aStack.Get() ];
-        eRet = ConvOK;
-    }
-
-    rStrm.Seek(nEndPos);
-    return eRet;
-}
-
-void ExcelToSc8::ExcRelToScRel8( UINT16 nRow, UINT16 nC, ScSingleRefData &rSRD, const BOOL bName )
-{
-    const BOOL		bColRel = ( nC & 0x4000 ) != 0;
-    const BOOL		bRowRel = ( nC & 0x8000 ) != 0;
-    const UINT8		nCol = static_cast<UINT8>(nC);
-
-    rSRD.SetColRel( bColRel );
-    rSRD.SetRowRel( bRowRel );
-
-    if( bName )
-    {
-        // C O L
-        if( bColRel )
-            //															rel Col
-            rSRD.nRelCol = static_cast<SCsCOL>(static_cast<INT8>(nC));
-        else
-            //															abs Col
-            rSRD.nCol = static_cast<SCCOL>(nCol);
-
-        // R O W
-        if( bRowRel )
-            //															rel Row
-            rSRD.nRelRow = static_cast<SCsROW>(static_cast<INT16>(nRow));
-        else
-            //															abs Row
-            rSRD.nRow = Min( static_cast<SCROW>(nRow), MAXROW);
-
-        // T A B
-        // #67965# abs needed if rel in shared formula for ScCompiler UpdateNameReference
-        if ( rSRD.IsTabRel() && !rSRD.IsFlag3D() )
-            rSRD.nTab = GetCurrScTab();
-    }
-    else
-    {
-        // C O L
-        if ( bColRel )
-            rSRD.nRelCol = static_cast<SCsCOL>(nCol) - aEingPos.Col();
-        else
-            rSRD.nCol = static_cast<SCCOL>(nCol);
-
-        // R O W
-        if ( bRowRel )
-            rSRD.nRelRow = static_cast<SCsROW>(nRow) - aEingPos.Row();
-        else
-            rSRD.nRow = static_cast<SCROW>(nRow);
-
-        // T A B
-        // #i10184# abs needed if rel in shared formula for ScCompiler UpdateNameReference
-        if ( rSRD.IsTabRel() && !rSRD.IsFlag3D() )
-            rSRD.nTab = GetCurrScTab() + rSRD.nRelTab;
-    }
-}
-
-
-// stream seeks to first byte after <nLen>
-BOOL ExcelToSc8::GetAbsRefs( ScRangeList& r, XclImpStream& aIn, sal_Size nLen )
-{
-    UINT8					nOp;
-    UINT16					nRow1, nRow2, nCol1, nCol2;
-    SCTAB                                   nTab1, nTab2;
-    UINT16					nIxti;
-
-    sal_Size nSeek;
-
-    sal_Size nEndPos = aIn.GetRecPos() + nLen;
-
-    while( aIn.IsValid() && (aIn.GetRecPos() < nEndPos) )
-    {
-        aIn >> nOp;
-        nSeek = 0;
-
-        switch( nOp )
-        {
-            case 0x44:
-            case 0x64:
-            case 0x24: // Cell Reference						[319 270]
-            case 0x4C:
-            case 0x6C:
-            case 0x2C: // Cell Reference Within a Name			[323    ]
-                       // Cell Reference Within a Shared Formula[    273]
-                aIn >> nRow1 >> nCol1;
-
-                nRow2 = nRow1;
-                nCol2 = nCol1;
-                nTab1 = nTab2 = GetCurrScTab();
-                goto _common;
-            case 0x45:
-            case 0x65:
-            case 0x25: // Area Reference						[320 270]
-            case 0x4D:
-            case 0x6D:
-            case 0x2D: // Area Reference Within a Name			[324    ]
-                       // Area Reference Within a Shared Formula[    274]
-                aIn >> nRow1 >> nRow2 >> nCol1 >> nCol2;
-
-                nTab1 = nTab2 = GetCurrScTab();
-                goto _common;
-            case 0x5A:
-            case 0x7A:
-            case 0x3A: // 3-D Cell Reference					[    275]
-                aIn >> nIxti >> nRow1 >> nCol1;
-
-                nRow2 = nRow1;
-                nCol2 = nCol1;
-
-                goto _3d_common;
-            case 0x5B:
-            case 0x7B:
-            case 0x3B: // 3-D Area Reference					[    276]
-                aIn >> nIxti >> nRow1 >> nRow2 >> nCol1 >> nCol2;
-
-    _3d_common:
-                // #122885# skip references to deleted sheets
-                if( !rLinkMan.GetScTabRange( nTab1, nTab2, nIxti ) || !ValidTab( nTab1 ) || !ValidTab( nTab2 ) )
-                    break;
-
-                goto _common;
-    _common:
-                // do not check abs/rel flags, linked controls have set them!
-//               if( !(( nCol1 & 0xC000 ) || ( nCol2 & 0xC000 )) )
-                {
-                    ScRange aScRange;
-                    nCol1 &= 0x3FFF;
-                    nCol2 &= 0x3FFF;
-                    if( GetAddressConverter().ConvertRange( aScRange, XclRange( nCol1, nRow1, nCol2, nRow2 ), nTab1, nTab2, true ) )
-                        r.Append( aScRange );
-                }
-                break;
-            case 0x1C: // Error Value							[314 266]
-            case 0x1D: // Boolean								[315 266]
-                nSeek = 1;
-                break;
-            case 0x1E: // Integer								[315 266]
-            case 0x41:
-            case 0x61:
-            case 0x21: // Function, Fixed Number of Arguments	[333 282]
-            case 0x49:
-            case 0x69:
-            case 0x29: // Variable Reference Subexpression		[331 281]
-            case 0x4E:
-            case 0x6E:
-            case 0x2E: // Reference Subexpression Within a Name	[332 282]
-            case 0x4F:
-            case 0x6F:
-            case 0x2F: // Incomplete Reference Subexpression...	[332 282]
-            case 0x58:
-            case 0x78:
-            case 0x38: // Command-Equivalent Function			[333    ]
-                nSeek = 2;
-                break;
-            case 0x42:
-            case 0x62:
-            case 0x22: // Function, Variable Number of Arg.		[333 283]
-                nSeek = 3;
-                break;
-            case 0x01: // Array Formula							[325    ]
-            case 0x02: // Data Table							[325 277]
-            case 0x43:
-            case 0x63:
-            case 0x23: // Name									[318 269]
-            case 0x4A:
-            case 0x6A:
-            case 0x2A: // Deleted Cell Reference				[323 273]
-                nSeek = 4;
-                break;
-            case 0x46:
-            case 0x66:
-            case 0x26: // Constant Reference Subexpression		[321 271]
-            case 0x47:
-            case 0x67:
-            case 0x27: // Erroneous Constant Reference Subexpr.	[322 272]
-            case 0x48:
-            case 0x68:
-            case 0x28: // Incomplete Constant Reference Subexpr.[331 281]
-            case 0x5C:
-            case 0x7C:
-            case 0x3C: // Deleted 3-D Cell Reference			[    277]
-            case 0x59:
-            case 0x79:
-            case 0x39: // Name or External Name                 [    275]
-                nSeek = 6;
-                break;
-            case 0x40:
-            case 0x60:
-            case 0x20: // Array Constant						[317 268]
-                nSeek = 7;
-                break;
-            case 0x1F: // Number								[315 266]
-            case 0x4B:
-            case 0x6B:
-            case 0x2B: // Deleted Area Refernce					[323 273]
-                nSeek = 8;
-                break;
-            case 0x5D:
-            case 0x7D:
-            case 0x3D: // Deleted 3-D Area Reference			[    277]
-                nSeek = 10;
-                break;
-            case 0x17: // String Constant						[314 266]
-            {
-                UINT8 nStrLen;
-                aIn >> nStrLen;
-                aIn.IgnoreUniString( nStrLen );     // reads Grbit even if nLen==0
-                nSeek = 0;
-            }
-                break;
-            case 0x19: // Special Attribute						[327 279]
-            {
-                UINT16	nData;
-                UINT8	nOpt;
-                aIn >> nOpt >> nData;
-                if( nOpt & 0x04 )
-                {// nFakt -> Bytes oder Words ueberlesen	AttrChoose
-                    nData++;
-                    nSeek = nData * 2;
-            }
-            }
-                break;
-        }
-
-        aIn.Ignore( nSeek );
-    }
-    aIn.Seek( nEndPos );
-
-    return r.Count() != 0;
-}
-
-
-
-
-
diff --git sc/source/filter/xlsx/xlsx-excimp8.cxx sc/source/filter/xlsx/xlsx-excimp8.cxx
deleted file mode 100644
index 4cd1863..0000000
--- sc/source/filter/xlsx/xlsx-excimp8.cxx
+++ /dev/null
@@ -1,777 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: excimp8.cxx,v $
- * $Revision: 1.127.4.2 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "excimp8.hxx"
-
-
-#include <scitems.hxx>
-#include <comphelper/processfactory.hxx>
-#include <svtools/fltrcfg.hxx>
-
-#include <svtools/wmf.hxx>
-
-#include <svx/eeitem.hxx>
-
-#include <sfx2/docfile.hxx>
-#include <sfx2/objsh.hxx>
-#include <svx/brshitem.hxx>
-#include <svx/editdata.hxx>
-#include <svx/editeng.hxx>
-#include <svx/editobj.hxx>
-#include <svx/editstat.hxx>
-#include <svx/colritem.hxx>
-#include <svx/udlnitem.hxx>
-#include <svx/wghtitem.hxx>
-#include <svx/postitem.hxx>
-#include <svx/crsditem.hxx>
-#include <svx/flditem.hxx>
-#include <svx/xflclit.hxx>
-#include <svx/svxmsbas.hxx>
-
-#include <vcl/graph.hxx>
-#include <vcl/bmpacc.hxx>
-#include <sot/exchange.hxx>
-
-#include <sfx2/docinf.hxx>
-
-#include <tools/string.hxx>
-#include <tools/urlobj.hxx>
-#include <rtl/math.hxx>
-#include <unotools/localedatawrapper.hxx>
-#include <unotools/charclass.hxx>
-#include <drwlayer.hxx>
-
-#include <boost/scoped_array.hpp>
-
-#include "cell.hxx"
-#include "document.hxx"
-#include "patattr.hxx"
-#include "docpool.hxx"
-#include "attrib.hxx"
-#include "conditio.hxx"
-#include "dbcolect.hxx"
-#include "editutil.hxx"
-#include "markdata.hxx"
-#include "rangenam.hxx"
-#include "docoptio.hxx"
-#include "globstr.hrc"
-#include "fprogressbar.hxx"
-#include "xltracer.hxx"
-#include "xihelper.hxx"
-#include "xipage.hxx"
-#include "xicontent.hxx"
-#include "xilink.hxx"
-#include "xiescher.hxx"
-#include "xipivot.hxx"
-
-#include "excform.hxx"
-#include "scextopt.hxx"
-#include "stlpool.hxx"
-#include "stlsheet.hxx"
-#include "detfunc.hxx"
-#include "macromgr.hxx"
-
-#include <com/sun/star/document/XDocumentProperties.hpp>
-#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
-#include <com/sun/star/script/ModuleInfo.hpp>
-#include <basic/basmgr.hxx>
-#include <cppuhelper/component_context.hxx>
-
-#include <com/sun/star/container/XNameContainer.hpp>
-#include <sfx2/app.hxx>
-#include "xltoolbar.hxx"
-using namespace com::sun::star;
-
-
-#define	INVALID_POS		0xFFFFFFFF
-
-// defined in docfunc.cxx ( really this needs a new name )
-script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
-
-ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm ), mnTab(0)
-{
-    delete pFormConv;
-
-    pFormConv = pExcRoot->pFmlaConverter = new ExcelToSc8( GetRoot() );
-
-    bHasBasic = FALSE;
-}
-
-
-ImportExcel8::~ImportExcel8()
-{
-}
-
-
-void ImportExcel8::Calccount( void )
-{
-    ScDocOptions	aOpt = pD->GetDocOptions();
-    aOpt.SetIterCount( aIn.ReaduInt16() );
-    pD->SetDocOptions( aOpt );
-}
-
-
-void ImportExcel8::Precision( void )
-{
-    ScDocOptions aOpt = pD->GetDocOptions();
-    aOpt.SetCalcAsShown( aIn.ReaduInt16() == 0 );
-    pD->SetDocOptions( aOpt );
-}
-
-
-void ImportExcel8::Delta( void )
-{
-    ScDocOptions	aOpt = pD->GetDocOptions();
-    aOpt.SetIterEps( aIn.ReadDouble() );
-    pD->SetDocOptions( aOpt );
-}
-
-
-void ImportExcel8::Iteration( void )
-{
-    ScDocOptions	aOpt = pD->GetDocOptions();
-    aOpt.SetIter( aIn.ReaduInt16() == 1 );
-    pD->SetDocOptions( aOpt );
-}
-
-
-void ImportExcel8::Boundsheet( void )
-{
-    UINT8			nLen;
-    UINT16			nGrbit;
-
-    aIn.DisableDecryption();
-    maSheetOffsets.push_back( aIn.ReaduInt32() );
-    aIn.EnableDecryption();
-    aIn >> nGrbit >> nLen;
-
-    String aName( aIn.ReadUniString( nLen ) );
-    GetTabInfo().AppendXclTabName( aName, nBdshtTab );
-
-    SCTAB nScTab = static_cast< SCTAB >( nBdshtTab );
-    if( nScTab > 0 )
-    {
-        DBG_ASSERT( !pD->HasTable( nScTab ), "ImportExcel8::Boundsheet - sheet exists already" );
-        pD->MakeTable( nScTab );
-    }
-
-    if( ( nGrbit & 0x0001 ) || ( nGrbit & 0x0002 ) )
-        pD->SetVisible( nScTab, FALSE );
-
-    if( !pD->RenameTab( nScTab, aName ) )
-    {
-        pD->CreateValidTabName( aName );
-        pD->RenameTab( nScTab, aName );
-    }
-
-    nBdshtTab++;
-}
-
-
-void ImportExcel8::Scenman( void )
-{
-    UINT16				nLastDispl;
-
-    aIn.Ignore( 4 );
-    aIn >> nLastDispl;
-
-    aScenList.SetLast( nLastDispl );
-}
-
-
-void ImportExcel8::Scenario( void )
-{
-    aScenList.Append( new ExcScenario( aIn, *pExcRoot ) );
-}
-
-
-void ImportExcel8::Labelsst( void )
-{
-    XclAddress aXclPos;
-    UINT16 nXF;
-    UINT32  nSst;
-
-    aIn >> aXclPos >> nXF >> nSst;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        GetXFRangeBuffer().SetXF( aScPos, nXF );
-        if( ScBaseCell* pCell = GetSst().CreateCell( nSst, nXF ) )
-            GetDoc().PutCell( aScPos.Col(), aScPos.Row(), aScPos.Tab(), pCell );
-    }
-}
-
-
-void ImportExcel8::Codename( BOOL bWorkbookGlobals )
-{
-    if( bHasBasic )
-    {
-        String aName( aIn.ReadUniString() );
-        if( aName.Len() )
-        {
-            if( bWorkbookGlobals )
-            {
-                GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
-                GetDoc().SetCodeName( aName );
-            }
-            else
-            {
-                GetExtDocOptions().AppendCodeName( aName );
-                GetDoc().SetCodeName( GetCurrScTab(), aName );
-            }
-        }
-    }
-}
-
-void ImportExcel8::SheetProtection( void )
-{
-    GetSheetProtectBuffer().ReadOptions( aIn, GetCurrScTab() );
-}
-
-void ImportExcel8::ReadBasic( void )
-{
-    //bHasBasic = TRUE;
-    bHasBasic = TRUE;
-
-    SfxObjectShell* pShell = GetDocShell();
-    SotStorageRef xRootStrg = GetRootStorage();
-    SvtFilterOptions* pFilterOpt = SvtFilterOptions::Get();
-    if( pShell && xRootStrg.Is() && pFilterOpt )
-    {
-        bool bLoadCode = pFilterOpt->IsLoadExcelBasicCode();
-        bool bLoadExecutable = pFilterOpt->IsLoadExcelBasicExecutable();
-        bool bLoadStrg = pFilterOpt->IsLoadExcelBasicStorage();
-        if( bLoadCode || bLoadStrg )
-        {
-            SvxImportMSVBasic aBasicImport( *pShell, *xRootStrg, bLoadCode, bLoadStrg );
-	    bool bAsComment = !bLoadExecutable;
-            aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, AutoGeneratedCodeNames, bAsComment );
-            if ( !bAsComment )
-            {
-                GetObjectManager().SetOleNameOverrideInfo( aBasicImport.ControlNameForObjectId() );
-                ScDocument& rDoc = GetDoc();
-#if 1
-                // see if we have the XCB stream
-                SvStorageStreamRef xXCB = xRootStrg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "XCB" ) ), STREAM_STD_READ | STREAM_NOCREATE  );
-                if ( xXCB.Is()|| SVSTREAM_OK == xXCB->GetError() )
-                {
-                    CTBWrapper wrapper;
-                    if ( wrapper.Read( xXCB ) )
-                    {
-#if DEBUG
-                        wrapper.Print( stderr ); 
-#endif
-                        wrapper.ImportCustomToolBar( *pShell );
-                    }
-                }
-#endif
-
-            }
-        }
-    }
-}
-
-void ImportExcel8::EndSheet( void )
-{
-    GetCondFormatManager().Apply();
-    ImportExcel::EndSheet();
-}
-
-
-void ImportExcel8::PostDocLoad( void )
-{
-    // delay reading basic until sheet object ( codenames etc. ) are read
-
-    if ( bHasBasic ) 
-        ReadBasic();
-    // #i11776# filtered ranges before outlines and hidden rows
-    if( pExcRoot->pAutoFilterBuffer )
-        pExcRoot->pAutoFilterBuffer->Apply();
-
-    GetWebQueryBuffer().Apply();    //! test if extant
-    GetSheetProtectBuffer().Apply();
-    GetDocProtectBuffer().Apply();
-
-    ImportExcel::PostDocLoad();
-
-    // Scenarien bemachen! ACHTUNG: Hier wird Tabellen-Anzahl im Dokument erhoeht!!
-    if( !pD->IsClipboard() && aScenList.Count() )
-    {
-        pD->UpdateChartListenerCollection();	// references in charts must be updated
-
-        aScenList.Apply( GetRoot() );
-    }
-
-    // read doc info (no docshell while pasting from clipboard)
-    if( SfxObjectShell* pShell = GetDocShell() )
-    {
-        // BIFF5+ without storage is possible
-        SotStorageRef xRootStrg = GetRootStorage();
-        if( xRootStrg.Is() )
-        {
-            uno::Reference<document::XDocumentPropertiesSupplier> xDPS(
-                pShell->GetModel(), uno::UNO_QUERY_THROW);
-            uno::Reference<document::XDocumentProperties> xDocProps
-                = xDPS->getDocumentProperties();
-            sfx2::LoadOlePropertySet(xDocProps, GetRootStorage());
-        }
-    }
-
-    // #i45843# Pivot tables are now handled outside of PostDocLoad, so they are available
-    // when formula cells are calculated, for the GETPIVOTDATA function.
-}
-
-
-//___________________________________________________________________
-// autofilter
-
-void ImportExcel8::FilterMode( void )
-{
-    // The FilterMode record exists: if either the AutoFilter
-    // record exists or an Advanced Filter is saved and stored
-    // in the sheet. Thus if the FilterMode records only exists
-    // then the latter is true..
-    if( !pExcRoot->pAutoFilterBuffer ) return;
-
-    pExcRoot->pAutoFilterBuffer->IncrementActiveAF();
-
-    XclImpAutoFilterData* pData = pExcRoot->pAutoFilterBuffer->GetByTab( GetCurrScTab() );
-    if( pData )
-        pData->SetAutoOrAdvanced();
-}
-
-void ImportExcel8::AutoFilterInfo( void )
-{
-    if( !pExcRoot->pAutoFilterBuffer ) return;
-
-    XclImpAutoFilterData* pData = pExcRoot->pAutoFilterBuffer->GetByTab( GetCurrScTab() );
-    if( pData )
-    {
-        pData->SetAdvancedRange( NULL );
-        pData->Activate();
-    }
-}
-
-void ImportExcel8::AutoFilter( void )
-{
-    if( !pExcRoot->pAutoFilterBuffer ) return;
-
-    XclImpAutoFilterData* pData = pExcRoot->pAutoFilterBuffer->GetByTab( GetCurrScTab() );
-    if( pData )
-        pData->ReadAutoFilter( aIn );
-}
-
-
-
-XclImpAutoFilterData::XclImpAutoFilterData( RootData* pRoot, const ScRange& rRange, const String& rName ) :
-        ExcRoot( pRoot ),
-        pCurrDBData(NULL),
-        nFirstEmpty( 0 ),
-        bActive( FALSE ),
-        bHasConflict( FALSE ),
-        bCriteria( FALSE ),
-        bAutoOrAdvanced(FALSE),
-        aFilterName(rName)
-{
-    aParam.nCol1 = rRange.aStart.Col();
-    aParam.nRow1 = rRange.aStart.Row();
-    aParam.nTab = rRange.aStart.Tab();
-    aParam.nCol2 = rRange.aEnd.Col();
-    aParam.nRow2 = rRange.aEnd.Row();
-
-    aParam.bInplace = TRUE;
-
-}
-
-void XclImpAutoFilterData::CreateFromDouble( String& rStr, double fVal )
-{
-    rStr += String( ::rtl::math::doubleToUString( fVal,
-                rtl_math_StringFormat_Automatic, rtl_math_DecimalPlaces_Max,
-                ScGlobal::pLocaleData->getNumDecimalSep().GetChar(0), TRUE));
-}
-
-void XclImpAutoFilterData::SetCellAttribs()
-{
-    ScDocument& rDoc = pExcRoot->pIR->GetDoc();
-    for ( SCCOL nCol = StartCol(); nCol <= EndCol(); nCol++ )
-    {
-        INT16 nFlag = ((ScMergeFlagAttr*) rDoc.GetAttr( nCol, StartRow(), Tab(), ATTR_MERGE_FLAG ))->GetValue();
-        rDoc.ApplyAttr( nCol, StartRow(), Tab(), ScMergeFlagAttr( nFlag | SC_MF_AUTO) );
-    }
-}
-
-void XclImpAutoFilterData::InsertQueryParam()
-{
-    if( pCurrDBData && !bHasConflict )
-    {
-        ScRange	aAdvRange;
-        BOOL	bHasAdv = pCurrDBData->GetAdvancedQuerySource( aAdvRange );
-        if( bHasAdv )
-            pExcRoot->pIR->GetDoc().CreateQueryParam( aAdvRange.aStart.Col(),
-                aAdvRange.aStart.Row(), aAdvRange.aEnd.Col(), aAdvRange.aEnd.Row(),
-                aAdvRange.aStart.Tab(), aParam );
-
-        pCurrDBData->SetQueryParam( aParam );
-        if( bHasAdv )
-            pCurrDBData->SetAdvancedQuerySource( &aAdvRange );
-        else
-        {
-            pCurrDBData->SetAutoFilter( TRUE );
-            SetCellAttribs();
-        }
-    }
-}
-
-static void ExcelQueryToOooQuery( ScQueryEntry& rEntry )
-{
-    if( ( rEntry.eOp != SC_EQUAL && rEntry.eOp != SC_NOT_EQUAL ) || rEntry.pStr == NULL )
-        return;
-    else
-    {
-        xub_StrLen nLen = rEntry.pStr->Len();
-        sal_Unicode nStart = rEntry.pStr->GetChar( 0 );
-        sal_Unicode nEnd   = rEntry.pStr->GetChar( nLen-1 );
-        if( nLen >2 && nStart == '*' && nEnd == '*' )
-        {
-            rEntry.pStr->Erase( nLen-1, 1 );
-            rEntry.pStr->Erase( 0, 1 );
-            rEntry.eOp = ( rEntry.eOp == SC_EQUAL ) ? SC_CONTAINS : SC_DOES_NOT_CONTAIN;
-        }
-        else if( nLen > 1 && nStart == '*' && nEnd != '*' )
-        {
-            rEntry.pStr->Erase( 0, 1 );
-            rEntry.eOp = ( rEntry.eOp == SC_EQUAL ) ? SC_ENDS_WITH : SC_DOES_NOT_END_WITH;
-        }
-        else if( nLen > 1 && nStart != '*' && nEnd == '*' )
-        {
-            rEntry.pStr->Erase( nLen-1, 1 );
-            rEntry.eOp = ( rEntry.eOp == SC_EQUAL ) ? SC_BEGINS_WITH : SC_DOES_NOT_BEGIN_WITH;
-        }
-        else if( nLen == 2 && nStart == '*' && nEnd == '*' )
-        {
-            rEntry.pStr->Erase( 0, 1 );
-        }
-    }
-}
-
-void XclImpAutoFilterData::ReadAutoFilter( XclImpStream& rStrm )
-{
-    UINT16 nCol, nFlags;
-    rStrm >> nCol >> nFlags;
-
-    ScQueryConnect  eConn       = ::get_flagvalue( nFlags, EXC_AFFLAG_ANDORMASK, SC_OR, SC_AND );
-    BOOL            bTop10      = ::get_flag( nFlags, EXC_AFFLAG_TOP10 );
-    BOOL            bTopOfTop10 = ::get_flag( nFlags, EXC_AFFLAG_TOP10TOP );
-    BOOL            bPercent    = ::get_flag( nFlags, EXC_AFFLAG_TOP10PERC );
-    UINT16			nCntOfTop10	= nFlags >> 7;
-    SCSIZE			nCount		= aParam.GetEntryCount();
-
-    if( bTop10 )
-    {
-        if( nFirstEmpty < nCount )
-        {
-            ScQueryEntry& aEntry = aParam.GetEntry( nFirstEmpty );
-            aEntry.bDoQuery = TRUE;
-            aEntry.bQueryByString = TRUE;
-            aEntry.nField = static_cast<SCCOLROW>(StartCol() + static_cast<SCCOL>(nCol));
-            aEntry.eOp = bTopOfTop10 ?
-                (bPercent ? SC_TOPPERC : SC_TOPVAL) : (bPercent ? SC_BOTPERC : SC_BOTVAL);
-            aEntry.eConnect = SC_AND;
-            aEntry.pStr->Assign( String::CreateFromInt32( (sal_Int32) nCntOfTop10 ) );
-
-            rStrm.Ignore( 20 );
-            nFirstEmpty++;
-        }
-    }
-    else
-    {
-        UINT8	nE, nType, nOper, nBoolErr, nVal;
-        INT32   nRK;
-        double	fVal;
-        BOOL	bIgnore;
-
-        UINT8	nStrLen[ 2 ]	= { 0, 0 };
-        ScQueryEntry *pQueryEntries[ 2 ] = { NULL, NULL };
-
-        for( nE = 0; nE < 2; nE++ )
-        {
-            if( nFirstEmpty < nCount )
-            {
-                ScQueryEntry& aEntry = aParam.GetEntry( nFirstEmpty );
-                pQueryEntries[ nE ] = &aEntry;
-                bIgnore = FALSE;
-
-                rStrm >> nType >> nOper;
-                switch( nOper )
-                {
-                    case EXC_AFOPER_LESS:
-                        aEntry.eOp = SC_LESS;
-                    break;
-                    case EXC_AFOPER_EQUAL:
-                        aEntry.eOp = SC_EQUAL;
-                    break;
-                    case EXC_AFOPER_LESSEQUAL:
-                        aEntry.eOp = SC_LESS_EQUAL;
-                    break;
-                    case EXC_AFOPER_GREATER:
-                        aEntry.eOp = SC_GREATER;
-                    break;
-                    case EXC_AFOPER_NOTEQUAL:
-                        aEntry.eOp = SC_NOT_EQUAL;
-                    break;
-                    case EXC_AFOPER_GREATEREQUAL:
-                        aEntry.eOp = SC_GREATER_EQUAL;
-                    break;
-                    default:
-                        aEntry.eOp = SC_EQUAL;
-                }
-
-                switch( nType )
-                {
-                    case EXC_AFTYPE_RK:
-                        rStrm >> nRK;
-                        rStrm.Ignore( 4 );
-                        CreateFromDouble( *aEntry.pStr, XclTools::GetDoubleFromRK( nRK ) );
-                    break;
-                    case EXC_AFTYPE_DOUBLE:
-                        rStrm >> fVal;
-                        CreateFromDouble( *aEntry.pStr, fVal );
-                    break;
-                    case EXC_AFTYPE_STRING:
-                        rStrm.Ignore( 4 );
-                        rStrm >> nStrLen[ nE ];
-                        rStrm.Ignore( 3 );
-                        aEntry.pStr->Erase();
-                    break;
-                    case EXC_AFTYPE_BOOLERR:
-                        rStrm >> nBoolErr >> nVal;
-                        rStrm.Ignore( 6 );
-                        aEntry.pStr->Assign( String::CreateFromInt32( (sal_Int32) nVal ) );
-                        bIgnore = (BOOL) nBoolErr;
-                    break;
-                    case EXC_AFTYPE_EMPTY:
-                        aEntry.bQueryByString = FALSE;
-                        aEntry.nVal = SC_EMPTYFIELDS;
-                        aEntry.eOp = SC_EQUAL;
-                    break;
-                    case EXC_AFTYPE_NOTEMPTY:
-                        aEntry.bQueryByString = FALSE;
-                        aEntry.nVal = SC_NONEMPTYFIELDS;
-                        aEntry.eOp = SC_EQUAL;
-                    break;
-                    default:
-                        rStrm.Ignore( 8 );
-                        bIgnore = TRUE;
-                }
-
-                /*  #i39464# conflict, if two conditions of one column are 'OR'ed,
-                    and they follow conditions of other columns.
-                    Example: Let A1 be a condition of column A, and B1 and B2
-                    conditions of column B, connected with OR. Excel performs
-                    'A1 AND (B1 OR B2)' in this case, but Calc would do
-                    '(A1 AND B1) OR B2' instead. */
-                if( (nFirstEmpty > 1) && nE && (eConn == SC_OR) && !bIgnore )
-                    bHasConflict = TRUE;
-                if( !bHasConflict && !bIgnore )
-                {
-                    aEntry.bDoQuery = TRUE;
-                    aEntry.bQueryByString = TRUE;
-                    aEntry.nField = static_cast<SCCOLROW>(StartCol() + static_cast<SCCOL>(nCol));
-                    aEntry.eConnect = nE ? eConn : SC_AND;
-                    nFirstEmpty++;
-                }
-            }
-            else
-                rStrm.Ignore( 10 );
-        }
-
-        for( nE = 0; nE < 2; nE++ )
-            if( nStrLen[ nE ] && pQueryEntries[ nE ] )
-            {
-                pQueryEntries[ nE ]->pStr->Assign ( rStrm.ReadUniString( nStrLen[ nE ] ) );
-                ExcelQueryToOooQuery( *pQueryEntries[ nE ] );
-            }
-                
-    }
-}
-
-void XclImpAutoFilterData::SetAdvancedRange( const ScRange* pRange )
-{
-    if (pRange)
-    {
-        aCriteriaRange = *pRange;
-        bCriteria = TRUE;
-    }
-    else
-        bCriteria = FALSE;
-}
-
-void XclImpAutoFilterData::SetExtractPos( const ScAddress& rAddr )
-{
-    aParam.nDestCol = rAddr.Col();
-    aParam.nDestRow = rAddr.Row();
-    aParam.nDestTab = rAddr.Tab();
-    aParam.bInplace = FALSE;
-    aParam.bDestPers = TRUE;
-}
-
-void XclImpAutoFilterData::Apply( const BOOL bUseUnNamed )
-{
-    CreateScDBData(bUseUnNamed);
-
-    if( bActive )
-    {
-        InsertQueryParam();
-
-        // #i38093# rows hidden by filter need extra flag, but CR_FILTERED is not set here yet
-//        SCROW nRow1 = StartRow();
-//        SCROW nRow2 = EndRow();
-//        size_t nRows = nRow2 - nRow1 + 1;
-//        boost::scoped_array<BYTE> pFlags( new BYTE[nRows]);
-//        pExcRoot->pDoc->GetRowFlagsArray( Tab()).FillDataArray( nRow1, nRow2,
-//                pFlags.get());
-//        for (size_t j=0; j<nRows; ++j)
-//        {
-//            if ((pFlags[j] & CR_HIDDEN) && !(pFlags[j] & CR_FILTERED))
-//                pExcRoot->pDoc->SetRowFlags( nRow1 + j, Tab(),
-//                        pFlags[j] | CR_FILTERED );
-//        }
-    }
-}
-
-void XclImpAutoFilterData::CreateScDBData( const BOOL bUseUnNamed )
-{
-
-    // Create the ScDBData() object if the AutoFilter is activated
-    // or if we need to create the Advanced Filter.
-    if( bActive || bCriteria)
-    {
-        ScDBCollection& rColl = pExcRoot->pIR->GetDatabaseRanges();
-        pCurrDBData	= rColl.GetDBAtArea( Tab(), StartCol(), StartRow(), EndCol(), EndRow() );
-        if( !pCurrDBData )
-        {
-            AmendAFName(bUseUnNamed);
-
-            pCurrDBData = new ScDBData( aFilterName, Tab(), StartCol(), StartRow(), EndCol(), EndRow() );
-
-            if( pCurrDBData )
-            {
-                if(bCriteria)
-                {
-                    EnableRemoveFilter();
-
-                    pCurrDBData->SetQueryParam( aParam );
-                    pCurrDBData->SetAdvancedQuerySource(&aCriteriaRange);
-                }
-                else
-                    pCurrDBData->SetAdvancedQuerySource(NULL);
-                rColl.Insert( pCurrDBData );
-            }
-        }
-    }
-
-}
-
-void XclImpAutoFilterData::EnableRemoveFilter()
-{
-    // only if this is a saved Advanced filter
-    if( !bActive && bAutoOrAdvanced )
-    {
-        ScQueryEntry& aEntry = aParam.GetEntry( nFirstEmpty );
-        aEntry.bDoQuery = TRUE;
-        ++nFirstEmpty;
-    }
-
-    // TBD: force the automatic activation of the
-    // "Remove Filter" by setting a virtual mouse click
-    // inside the advanced range
-}
-
-void XclImpAutoFilterData::AmendAFName(const BOOL bUseUnNamed)
-{
-    // If-and-only-if we have one AF filter then
-    // use the Calc "unnamed" range name. Calc
-    // only supports one in total while Excel
-    // supports one per sheet.
-    if( bUseUnNamed && bAutoOrAdvanced )
-        aFilterName = ScGlobal::GetRscString(STR_DB_NONAME);
-}
-
-XclImpAutoFilterBuffer::XclImpAutoFilterBuffer() :
-    nAFActiveCount( 0 )
-{
-}
-
-XclImpAutoFilterBuffer::~XclImpAutoFilterBuffer()
-{
-    for( XclImpAutoFilterData* pData = _First(); pData; pData = _Next() )
-        delete pData;
-}
-
-void XclImpAutoFilterBuffer::Insert( RootData* pRoot, const ScRange& rRange,
-                                    const String& rName )
-{
-    if( !GetByTab( rRange.aStart.Tab() ) )
-        Append( new XclImpAutoFilterData( pRoot, rRange, rName ) );
-}
-
-void XclImpAutoFilterBuffer::AddAdvancedRange( const ScRange& rRange )
-{
-    XclImpAutoFilterData* pData = GetByTab( rRange.aStart.Tab() );
-    if( pData )
-        pData->SetAdvancedRange( &rRange );
-}
-
-void XclImpAutoFilterBuffer::AddExtractPos( const ScRange& rRange )
-{
-    XclImpAutoFilterData* pData = GetByTab( rRange.aStart.Tab() );
-    if( pData )
-        pData->SetExtractPos( rRange.aStart );
-}
-
-void XclImpAutoFilterBuffer::Apply()
-{
-    for( XclImpAutoFilterData* pData = _First(); pData; pData = _Next() )
-        pData->Apply(UseUnNamed());
-}
-
-XclImpAutoFilterData* XclImpAutoFilterBuffer::GetByTab( SCTAB nTab )
-{
-    for( XclImpAutoFilterData* pData = _First(); pData; pData = _Next() )
-        if( pData->Tab() == nTab )
-            return pData;
-    return NULL;
-}
-
diff --git sc/source/filter/xlsx/xlsx-exctools.cxx sc/source/filter/xlsx/xlsx-exctools.cxx
index a6b1fe3..58b0973 100644
--- sc/source/filter/xlsx/xlsx-exctools.cxx
+++ sc/source/filter/xlsx/xlsx-exctools.cxx
@@ -304,8 +304,9 @@ void ExcScenarioCell::SetValue( const String& r )
 #define	EXCSCNEXT()				((ExcScenarioCell*)List::Next())
 
 
-ExcScenario::ExcScenario( XclImpStream& rIn, const RootData& rR ) : nTab( rR.pIR->GetCurrScTab() )
+ExcScenario::ExcScenario( XclImpStream& /*rIn*/, const RootData& rR ) : nTab( rR.pIR->GetCurrScTab() )
 {
+#if 0 // xlsx
     UINT16			nCref;
     UINT8			nName, nComment;
 
@@ -349,6 +350,7 @@ ExcScenario::ExcScenario( XclImpStream& rIn, const RootData& rR ) : nTab( rR.pIR
 
         p = EXCSCNEXT();
     }
+#endif // xlsx 
 }
 
 
@@ -371,8 +373,9 @@ ExcScenario::~ExcScenario()
 }
 
 
-void ExcScenario::Apply( const XclImpRoot& rRoot, const BOOL bLast )
+void ExcScenario::Apply( const XclImpRoot& /*rRoot*/, const BOOL /*bLast*/ )
 {
+#if 0 // xlsx
     ScDocument&         r = rRoot.GetDoc();
     ExcScenarioCell*	p = EXCSCFIRST();
     String				aSzenName( *pName );
@@ -407,6 +410,7 @@ void ExcScenario::Apply( const XclImpRoot& rRoot, const BOOL bLast )
     if( (static_cast< SCCOL >( nTab ) < rDocSett.mnDisplTab) && (rDocSett.mnDisplTab < MAXTAB) )
         ++rDocSett.mnDisplTab;
     rRoot.GetTabInfo().InsertScTab( nNewTab );
+#endif // xlsx 
 }
 
 
diff --git sc/source/filter/xlsx/xlsx-impop.cxx sc/source/filter/xlsx/xlsx-impop.cxx
deleted file mode 100644
index 48c678e..0000000
--- sc/source/filter/xlsx/xlsx-impop.cxx
+++ /dev/null
@@ -1,1341 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: impop.cxx,v $
- * $Revision: 1.95.36.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "imp_op.hxx"
-
-#include <svx/countryid.hxx>
-
-#include "scitems.hxx"
-#include <svx/eeitem.hxx>
-
-#include <svx/editdata.hxx>
-#include <svx/editeng.hxx>
-#include <svx/editobj.hxx>
-#include <svx/editstat.hxx>
-#include <svx/flditem.hxx>
-#include <svx/pageitem.hxx>
-#include <svx/colritem.hxx>
-#include <sfx2/printer.hxx>
-#include <sfx2/docfile.hxx>
-#include <svtools/zforlist.hxx>
-
-#include <sfx2/objsh.hxx>
-#include "docuno.hxx"
-
-#include "cell.hxx"
-#include "document.hxx"
-#include "rangenam.hxx"
-#include "compiler.hxx"
-#include "patattr.hxx"
-#include "attrib.hxx"
-#include "globstr.hrc"
-#include "global.hxx"
-#include "markdata.hxx"
-#include "olinetab.hxx"
-#include "stlsheet.hxx"
-#include "stlpool.hxx"
-#include "compiler.hxx"
-#include "viewopti.hxx"
-#include "docoptio.hxx"
-#include "scextopt.hxx"
-#include "editutil.hxx"
-#include "filtopt.hxx"
-#include "scerrors.hxx"
-#include "unonames.hxx"
-#include "paramisc.hxx"
-#include "postit.hxx"
-
-#include "fapihelper.hxx"
-#include "xltools.hxx"
-#include "xltable.hxx"
-#include "xlview.hxx"
-#include "xltracer.hxx"
-#include "xihelper.hxx"
-#include "xipage.hxx"
-#include "xiview.hxx"
-#include "xilink.hxx"
-#include "xiescher.hxx"
-#include "xicontent.hxx"
-
-#include "excimp8.hxx"
-#include "excform.hxx"
-
-#if defined( WNT ) || defined( WIN )
-#include <math.h>
-#else
-#include <stdlib.h>
-#endif
-
-using namespace ::com::sun::star;
-
-
-const double ImportExcel::fExcToTwips =
-    ( double ) TWIPS_PER_CHAR / 256.0;
-
-
-ImportTyp::ImportTyp( ScDocument* pDoc, CharSet eQ )
-{
-    eQuellChar = eQ;
-    pD = pDoc;
-}
-
-
-ImportTyp::~ImportTyp()
-{
-}
-
-
-FltError ImportTyp::Read()
-{
-    return eERR_INTERN;
-}
-
-
-ImportExcel::ImportExcel( XclImpRootData& rImpData, SvStream& rStrm ):
-    ImportTyp( &rImpData.mrDoc, rImpData.meTextEnc ),
-    XclImpRoot( rImpData ),
-    maStrm( rStrm, GetRoot() ),
-    aIn( maStrm )
-{
-    mnLastRefIdx = 0;
-    nBdshtTab = 0;
-    nIxfeIndex = 0;		// zur Sicherheit auf 0
-
-    // Root-Daten fuellen - nach new's ohne Root als Parameter
-    pExcRoot = &GetOldRoot();
-    pExcRoot->pIR = this;   // ExcRoot -> XclImpRoot
-    pExcRoot->eDateiTyp = BiffX;
-    pExcRoot->pExtSheetBuff = new ExtSheetBuffer( pExcRoot );	//&aExtSheetBuff;
-    pExcRoot->pShrfmlaBuff = new ShrfmlaBuffer( pExcRoot );		//&aShrfrmlaBuff;
-    pExcRoot->pExtNameBuff = new ExtNameBuff ( *this );
-
-    pExtNameBuff = new NameBuffer( pExcRoot );          //#94039# prevent empty rootdata
-    pExtNameBuff->SetBase( 1 );
-
-    pOutlineListBuffer = new XclImpOutlineListBuffer( );
-
-    // ab Biff8
-    pFormConv = pExcRoot->pFmlaConverter = new ExcelToSc( GetRoot() );
-
-    bTabTruncated = FALSE;
-
-    // Excel-Dokument per Default auf 31.12.1899, entspricht Excel-Einstellungen mit 1.1.1900
-    ScDocOptions aOpt = pD->GetDocOptions();
-    aOpt.SetDate( 30, 12, 1899 );
-    pD->SetDocOptions( aOpt );
-    pD->GetFormatTable()->ChangeNullDate( 30, 12, 1899 );
-
-    ScDocOptions aDocOpt( pD->GetDocOptions() );
-    aDocOpt.SetIgnoreCase( TRUE );              // always in Excel
-    aDocOpt.SetFormulaRegexEnabled( FALSE );    // regular expressions? what's that?
-    aDocOpt.SetLookUpColRowNames( FALSE );      // default: no natural language refs
-    pD->SetDocOptions( aDocOpt );
-}
-
-
-ImportExcel::~ImportExcel( void )
-{
-    GetDoc().SetSrcCharSet( GetTextEncoding() );
-
-    delete pExtNameBuff;
-
-    delete pOutlineListBuffer;
-
-    delete pFormConv;
-}
-
-
-void ImportExcel::ReadFileSharing()
-{
-    sal_uInt16 nRecommendReadOnly, nPasswordHash;
-    maStrm >> nRecommendReadOnly >> nPasswordHash;
-
-    if( (nRecommendReadOnly != 0) || (nPasswordHash != 0) )
-        if( SfxItemSet* pItemSet = GetMedium().GetItemSet() )
-            pItemSet->Put( SfxBoolItem( SID_DOC_READONLY, TRUE ) );
-
-    if( nPasswordHash != 0 )
-    {
-        if( SfxObjectShell* pDocShell = GetDocShell() )
-        {
-            ScfPropertySet aPropSet( pDocShell->GetModel() );
-            aPropSet.SetProperty( CREATE_OUSTRING( "WriteProtectionPassword" ), static_cast< sal_Int32 >( nPasswordHash ) );
-        }
-    }
-}
-
-sal_uInt16 ImportExcel::ReadXFIndex( bool bBiff2 )
-{
-    sal_uInt16 nXFIdx = 0;
-    if( bBiff2 )
-    {
-        sal_uInt8 nXFIdx2;
-        maStrm >> nXFIdx2;
-        maStrm.Ignore( 2 );
-        nXFIdx = nXFIdx2 & 0x3F;
-        if( nXFIdx == 63 )
-            nXFIdx = nIxfeIndex;
-    }
-    else
-        aIn >> nXFIdx;
-    return nXFIdx;
-}
-
-void ImportExcel::ReadDimensions()
-{
-    XclRange aXclUsedArea( ScAddress::UNINITIALIZED );
-    if( (maStrm.GetRecId() == EXC_ID2_DIMENSIONS) || (GetBiff() <= EXC_BIFF5) )
-    {
-        maStrm >> aXclUsedArea;
-        if( (aXclUsedArea.GetColCount() > 1) && (aXclUsedArea.GetRowCount() > 1) )
-        {
-            // Excel stores first unused row/column index
-            --aXclUsedArea.maLast.mnCol;
-            --aXclUsedArea.maLast.mnRow;
-            // create the Calc range
-            SCTAB nScTab = GetCurrScTab();
-            ScRange& rScUsedArea = GetExtDocOptions().GetOrCreateTabSettings( nScTab ).maUsedArea;
-            GetAddressConverter().ConvertRange( rScUsedArea, aXclUsedArea, nScTab, nScTab, false );
-            // if any error occurs in ConvertRange(), rScUsedArea keeps untouched
-        }
-    }
-    else
-    {
-        sal_uInt32 nXclRow1, nXclRow2;
-        maStrm >> nXclRow1 >> nXclRow2 >> aXclUsedArea.maFirst.mnCol >> aXclUsedArea.maLast.mnCol;
-        if( (nXclRow1 < nXclRow2) && (aXclUsedArea.GetColCount() > 1) &&
-            (nXclRow1 <= static_cast< sal_uInt32 >( GetScMaxPos().Row() )) )
-        {
-            // Excel stores first unused row/column index
-            --nXclRow2;
-            --aXclUsedArea.maLast.mnCol;
-            // convert row indexes to 16-bit values
-            aXclUsedArea.maFirst.mnRow = static_cast< sal_uInt16 >( nXclRow1 );
-            aXclUsedArea.maLast.mnRow = limit_cast< sal_uInt16 >( nXclRow2, aXclUsedArea.maFirst.mnRow, SAL_MAX_UINT16 );
-            // create the Calc range
-            SCTAB nScTab = GetCurrScTab();
-            ScRange& rScUsedArea = GetExtDocOptions().GetOrCreateTabSettings( nScTab ).maUsedArea;
-            GetAddressConverter().ConvertRange( rScUsedArea, aXclUsedArea, nScTab, nScTab, false );
-            // if any error occurs in ConvertRange(), rScUsedArea keeps untouched
-        }
-    }
-}
-
-void ImportExcel::ReadBlank()
-{
-    XclAddress aXclPos;
-    aIn >> aXclPos;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        sal_uInt16 nXFIdx = ReadXFIndex( maStrm.GetRecId() == EXC_ID2_BLANK );
-
-        GetXFRangeBuffer().SetBlankXF( aScPos, nXFIdx );
-    }
-}
-
-void ImportExcel::ReadInteger()
-{
-    XclAddress aXclPos;
-    maStrm >> aXclPos;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        sal_uInt16 nXFIdx = ReadXFIndex( true );
-        sal_uInt16 nValue;
-        maStrm >> nValue;
-
-        GetXFRangeBuffer().SetXF( aScPos, nXFIdx );
-        GetDoc().PutCell( aScPos, new ScValueCell( nValue ) );
-    }
-}
-
-void ImportExcel::ReadNumber()
-{
-    XclAddress aXclPos;
-    maStrm >> aXclPos;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        sal_uInt16 nXFIdx = ReadXFIndex( maStrm.GetRecId() == EXC_ID2_NUMBER );
-        double fValue;
-        maStrm >> fValue;
-
-        GetXFRangeBuffer().SetXF( aScPos, nXFIdx );
-        GetDoc().PutCell( aScPos, new ScValueCell( fValue ) );
-    }
-}
-
-void ImportExcel::ReadLabel()
-{
-    XclAddress aXclPos;
-    maStrm >> aXclPos;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        /*  Record ID   BIFF    XF type     String type
-            0x0004      2-7     3 byte      8-bit length, byte string
-            0x0004      8       3 byte      16-bit length, unicode string
-            0x0204      2-7     2 byte      16-bit length, byte string
-            0x0204      8       2 byte      16-bit length, unicode string */
-        bool bBiff2 = maStrm.GetRecId() == EXC_ID2_LABEL;
-        sal_uInt16 nXFIdx = ReadXFIndex( bBiff2 );
-        XclStrFlags nFlags = (bBiff2 && (GetBiff() <= EXC_BIFF5)) ? EXC_STR_8BITLENGTH : EXC_STR_DEFAULT;
-        XclImpString aString;
-
-        // #i63105# use text encoding from FONT record
-        rtl_TextEncoding eOldTextEnc = GetTextEncoding();
-        if( const XclImpFont* pFont = GetXFBuffer().GetFont( nXFIdx ) )
-            SetTextEncoding( pFont->GetFontEncoding() );
-        aString.Read( maStrm, nFlags );
-        SetTextEncoding( eOldTextEnc );
-
-        GetXFRangeBuffer().SetXF( aScPos, nXFIdx );
-        if( ScBaseCell* pCell = XclImpStringHelper::CreateCell( GetRoot(), aString, nXFIdx ) )
-            GetDoc().PutCell( aScPos, pCell );
-    }
-}
-
-void ImportExcel::ReadBoolErr()
-{
-    XclAddress aXclPos;
-    maStrm >> aXclPos;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        sal_uInt16 nXFIdx = ReadXFIndex( maStrm.GetRecId() == EXC_ID2_BOOLERR );
-        sal_uInt8 nValue, nType;
-        maStrm >> nValue >> nType;
-
-        if( nType == EXC_BOOLERR_BOOL )
-            GetXFRangeBuffer().SetBoolXF( aScPos, nXFIdx );
-        else
-            GetXFRangeBuffer().SetXF( aScPos, nXFIdx );
-
-        double fValue;
-        const ScTokenArray* pScTokArr = ErrorToFormula( nType, nValue, fValue );
-        ScFormulaCell* pCell = new ScFormulaCell( pD, aScPos, pScTokArr );
-        pCell->SetHybridDouble( fValue );
-        GetDoc().PutCell( aScPos, pCell );
-    }
-}
-
-void ImportExcel::ReadRk()
-{
-    XclAddress aXclPos;
-    maStrm >> aXclPos;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        sal_uInt16 nXFIdx = ReadXFIndex( false );
-        sal_Int32 nRk;
-        maStrm >> nRk;
-
-        GetXFRangeBuffer().SetXF( aScPos, nXFIdx );
-        GetDoc().PutCell( aScPos, new ScValueCell( XclTools::GetDoubleFromRK( nRk ) ) );
-    }
-}
-
-
-void ImportExcel::Window1()
-{
-    GetDocViewSettings().ReadWindow1( maStrm );
-}
-
-
-
-
-void ImportExcel::Row25( void )
-{
-    UINT16	nRow, nRowHeight;
-
-    aIn >> nRow;
-    aIn.Ignore( 4 );   // Mic und Mac ueberspringen
-
-    if( ValidRow( nRow ) )
-    {
-        aIn >> nRowHeight;	// direkt in Twips angegeben
-        aIn.Ignore( 2 );
-
-        if( GetBiff() == EXC_BIFF2 )
-        {// -------------------- BIFF2
-            pColRowBuff->SetHeight( nRow, nRowHeight );
-        }
-        else
-        {// -------------------- BIFF5
-            UINT16	nGrbit;
-
-            aIn.Ignore( 2 );   // reserved
-            aIn >> nGrbit;
-
-            sal_uInt8 nLevel = ::extract_value< sal_uInt8 >( nGrbit, 0, 3 );
-            pRowOutlineBuff->SetLevel( nRow, nLevel,
-                ::get_flag( nGrbit, EXC_ROW_COLLAPSED ), ::get_flag( nGrbit, EXC_ROW_HIDDEN ) );
-
-            pColRowBuff->SetRowSettings( nRow, nRowHeight, nGrbit );
-        }
-    }
-}
-
-
-void ImportExcel::Bof2( void )
-{
-    sal_uInt16 nSubType;
-    maStrm.DisableDecryption();
-    maStrm.Ignore( 2 );
-    maStrm >> nSubType;
-
-    if( nSubType == 0x0020 )        // Chart
-        pExcRoot->eDateiTyp = Biff2C;
-    else if( nSubType == 0x0040 )   // Macro
-        pExcRoot->eDateiTyp = Biff2M;
-    else                            // #i51490# Excel interprets invalid indexes as worksheet
-        pExcRoot->eDateiTyp = Biff2;
-}
-
-
-void ImportExcel::Eof( void )
-{
-    //	POST: darf nur nach einer GUELTIGEN Tabelle gerufen werden!
-    EndSheet();
-    IncCurrScTab();
-}
-
-
-void ImportExcel::SheetPassword( void )
-{
-    if (GetRoot().GetBiff() != EXC_BIFF8)
-        return;
-
-    GetRoot().GetSheetProtectBuffer().ReadPasswordHash( aIn, GetCurrScTab() );
-}
-
-
-void ImportExcel::Externsheet( void )
-{
-    String aUrl, aTabName;
-    bool bSameWorkBook;
-    String aEncodedUrl( aIn.ReadByteString( false ) );
-    XclImpUrlHelper::DecodeUrl( aUrl, aTabName, bSameWorkBook, *pExcRoot->pIR, aEncodedUrl );
-    mnLastRefIdx = pExcRoot->pExtSheetBuff->Add( aUrl, aTabName, bSameWorkBook );
-}
-
-
-void ImportExcel:: WinProtection( void )
-{
-    if (GetRoot().GetBiff() != EXC_BIFF8)
-        return;
-
-    GetRoot().GetDocProtectBuffer().ReadWinProtect( aIn );
-}
-
-
-void ImportExcel::Columndefault( void )
-{// Default Cell Attributes
-    UINT16	nColMic, nColMac;
-    BYTE	nOpt0;
-
-    aIn >> nColMic >> nColMac;
-
-    DBG_ASSERT( aIn.GetRecLeft() == (sal_Size)(nColMac - nColMic) * 3 + 2,
-                "ImportExcel::Columndefault - wrong record size" );
-
-    nColMac--;
-
-    if( nColMac > MAXCOL )
-        nColMac = static_cast<UINT16>(MAXCOL);
-
-    for( UINT16 nCol = nColMic ; nCol <= nColMac ; nCol++ )
-    {
-        aIn >> nOpt0;
-        aIn.Ignore( 2 );   // nur 0. Attribut-Byte benutzt
-
-        if( nOpt0 & 0x80 )	// Col hidden?
-            pColRowBuff->HideCol( nCol );
-    }
-}
-
-
-void ImportExcel::Array25( void )
-{
-    UINT16		nFirstRow, nLastRow, nFormLen;
-    BYTE		nFirstCol, nLastCol;
-
-    aIn >> nFirstRow >> nLastRow >> nFirstCol >> nLastCol;
-
-    if( GetBiff() == EXC_BIFF2 )
-    {//						BIFF2
-        aIn.Ignore( 1 );
-        nFormLen = aIn.ReaduInt8();
-    }
-    else
-    {//						BIFF5
-        aIn.Ignore( 6 );
-        aIn >> nFormLen;
-    }
-
-    if( ValidColRow( nLastCol, nLastRow ) )
-    {
-        // jetzt steht Lesemarke auf Formel, Laenge in nFormLen
-        const ScTokenArray*	pErgebnis;
-
-        pFormConv->Reset( ScAddress( static_cast<SCCOL>(nFirstCol),
-                    static_cast<SCROW>(nFirstRow), GetCurrScTab() ) );
-        pFormConv->Convert( pErgebnis, maStrm, nFormLen, true, FT_CellFormula);
-
-        DBG_ASSERT( pErgebnis, "*ImportExcel::Array25(): ScTokenArray ist NULL!" );
-
-        ScMarkData			aMarkData;
-        aMarkData.SelectOneTable( GetCurrScTab() );
-        pD->InsertMatrixFormula( static_cast<SCCOL>(nFirstCol),
-                static_cast<SCROW>(nFirstRow), static_cast<SCCOL>(nLastCol),
-                static_cast<SCROW>(nLastRow), aMarkData, EMPTY_STRING,
-                pErgebnis );
-    }
-}
-
-
-void ImportExcel::Rec1904( void )
-{
-    UINT16	n1904;
-
-    aIn >> n1904;
-
-    if( n1904 )
-    {// 1904 date system
-        ScDocOptions aOpt = pD->GetDocOptions();
-        aOpt.SetDate( 1, 1, 1904 );
-        pD->SetDocOptions( aOpt );
-        pD->GetFormatTable()->ChangeNullDate( 1, 1, 1904 );
-    }
-}
-
-
-void ImportExcel::Externname25( void )
-{
-    UINT32		nRes;
-    UINT16		nOpt;
-
-    aIn >> nOpt >> nRes;
-
-    String aName( aIn.ReadByteString( FALSE ) );
-
-    if( ( nOpt & 0x0001 ) || ( ( nOpt & 0xFFFE ) == 0x0000 ) )
-    {// external name
-        ScfTools::ConvertToScDefinedName( aName );
-        pExcRoot->pExtNameBuff->AddName( aName, mnLastRefIdx );
-    }
-    else if( nOpt & 0x0010 )
-    {// ole link
-        pExcRoot->pExtNameBuff->AddOLE( aName, mnLastRefIdx, nRes );        // nRes is storage ID
-    }
-    else
-    {// dde link
-        pExcRoot->pExtNameBuff->AddDDE( aName, mnLastRefIdx );
-    }
-}
-
-
-void ImportExcel::Colwidth( void )
-{// Column Width
-    BYTE	nColFirst, nColLast;
-    UINT16	nColWidth;
-
-    aIn >> nColFirst >> nColLast >> nColWidth;
-
-//! TODO: add a check for the unlikely case of changed MAXCOL (-> XclImpAddressConverter)
-//   if( nColLast > MAXCOL )
-//       nColLast = static_cast<UINT16>(MAXCOL);
-
-    USHORT nScWidth = XclTools::GetScColumnWidth( nColWidth, GetCharWidth() );
-    pColRowBuff->SetWidthRange( nColFirst, nColLast, nScWidth );
-}
-
-
-void ImportExcel::Defrowheight2( void )
-{
-    sal_uInt16 nDefHeight;
-    maStrm >> nDefHeight;
-    nDefHeight &= 0x7FFF;
-    pColRowBuff->SetDefHeight( nDefHeight, EXC_DEFROW_UNSYNCED );
-}
-
-
-void ImportExcel::SheetProtect( void )
-{
-    if (GetRoot().GetBiff() != EXC_BIFF8)
-        return;
-
-    GetRoot().GetSheetProtectBuffer().ReadProtect( aIn, GetCurrScTab() );
-}
-
-void ImportExcel::DocProtect( void )
-{
-    if (GetRoot().GetBiff() != EXC_BIFF8)
-        return;
-
-    GetRoot().GetDocProtectBuffer().ReadDocProtect( aIn );
-}
-
-void ImportExcel::DocPasssword( void )
-{
-    if (GetRoot().GetBiff() != EXC_BIFF8)
-        return;
-
-    GetRoot().GetDocProtectBuffer().ReadPasswordHash( aIn );
-}
-
-void ImportExcel::Codepage( void )
-{
-    SetCodePage( maStrm.ReaduInt16() );
-}
-
-
-void ImportExcel::Ixfe( void )
-{
-    aIn >> nIxfeIndex;
-}
-
-
-void ImportExcel::DefColWidth( void )
-{
-    // stored as entire characters -> convert to 1/256 of characters (as in COLINFO)
-    double fDefWidth = 256.0 * maStrm.ReaduInt16();
-
-    // #i3006# additional space for default width - Excel adds space depending on font size
-    long nFontHt = GetFontBuffer().GetAppFontData().mnHeight;
-    fDefWidth += XclTools::GetXclDefColWidthCorrection( nFontHt );
-
-    USHORT nScWidth = XclTools::GetScColumnWidth( limit_cast< sal_uInt16 >( fDefWidth ), GetCharWidth() );
-    pColRowBuff->SetDefWidth( nScWidth );
-}
-
-
-void ImportExcel::Builtinfmtcnt( void )
-{
-}
-
-
-void ImportExcel::Colinfo( void )
-{// Column Formatting Information
-    UINT16	nColFirst, nColLast, nColWidth, nXF;
-    UINT16	nOpt;
-
-    aIn >> nColFirst >> nColLast >> nColWidth >> nXF >> nOpt;
-
-    if( nColFirst > MAXCOL )
-        return;
-
-    if( nColLast > MAXCOL )
-        nColLast = static_cast<UINT16>(MAXCOL);
-
-    bool bHidden = ::get_flag( nOpt, EXC_COLINFO_HIDDEN );
-    bool bCollapsed = ::get_flag( nOpt, EXC_COLINFO_COLLAPSED );
-    sal_uInt8 nLevel = ::extract_value< sal_uInt8 >( nOpt, 8, 3 );
-    pColOutlineBuff->SetLevelRange( nColFirst, nColLast, nLevel, bCollapsed, bHidden );
-
-    if( bHidden )
-        pColRowBuff->HideColRange( nColFirst, nColLast );
-
-    USHORT nScWidth = XclTools::GetScColumnWidth( nColWidth, GetCharWidth() );
-    pColRowBuff->SetWidthRange( nColFirst, nColLast, nScWidth );
-    pColRowBuff->SetDefaultXF( nColFirst, nColLast, nXF );
-}
-
-
-void ImportExcel::Wsbool( void )
-{
-    UINT16 nFlags;
-    aIn >> nFlags;
-
-    pRowOutlineBuff->SetButtonMode( ::get_flag( nFlags, EXC_WSBOOL_ROWBELOW ) );
-    pColOutlineBuff->SetButtonMode( ::get_flag( nFlags, EXC_WSBOOL_COLBELOW ) );
-
-    GetPageSettings().SetFitToPages( ::get_flag( nFlags, EXC_WSBOOL_FITTOPAGE ) );
-}
-
-
-void ImportExcel::Boundsheet( void )
-{
-    UINT16 nGrbit = 0;
-
-    if( GetBiff() == EXC_BIFF5 )
-    {
-        aIn.DisableDecryption();
-        maSheetOffsets.push_back( aIn.ReaduInt32() );
-        aIn.EnableDecryption();
-        aIn >> nGrbit;
-    }
-
-    String aName( aIn.ReadByteString( FALSE ) );
-
-    SCTAB nScTab = static_cast< SCTAB >( nBdshtTab );
-    if( nScTab > 0 )
-    {
-        DBG_ASSERT( !pD->HasTable( nScTab ), "ImportExcel::Boundsheet - sheet exists already" );
-        pD->MakeTable( nScTab );
-    }
-
-    if( ( nGrbit & 0x0001 ) || ( nGrbit & 0x0002 ) )
-        pD->SetVisible( nScTab, FALSE );
-
-    if( !pD->RenameTab( nScTab, aName ) )
-    {
-        pD->CreateValidTabName( aName );
-        pD->RenameTab( nScTab, aName );
-    }
-
-    nBdshtTab++;
-}
-
-
-void ImportExcel::Country( void )
-{
-    sal_uInt16 nUICountry, nDocCountry;
-    maStrm >> nUICountry >> nDocCountry;
-
-    // Store system language in XclRoot
-    LanguageType eLanguage = ::svx::ConvertCountryToLanguage( static_cast< ::svx::CountryId >( nDocCountry ) );
-    if( eLanguage != LANGUAGE_DONTKNOW )
-        SetDocLanguage( eLanguage );
-
-    // Set Excel UI language in add-in name translator
-    eLanguage = ::svx::ConvertCountryToLanguage( static_cast< ::svx::CountryId >( nUICountry ) );
-    if( eLanguage != LANGUAGE_DONTKNOW )
-        SetUILanguage( eLanguage );
-}
-
-
-void ImportExcel::ReadUsesElfs()
-{
-    if( maStrm.ReaduInt16() != 0 )
-    {
-        ScDocOptions aDocOpt = GetDoc().GetDocOptions();
-        aDocOpt.SetLookUpColRowNames( TRUE );
-        GetDoc().SetDocOptions( aDocOpt );
-    }
-}
-
-
-void ImportExcel::Hideobj( void )
-{
-    UINT16		nHide;
-    ScVObjMode	eOle, eChart, eDraw;
-
-    aIn >> nHide;
-
-    ScViewOptions aOpts( pD->GetViewOptions() );
-
-    switch( nHide )
-    {
-        case 1:							// Placeholders
-            eOle   = VOBJ_MODE_SHOW;	// in Excel 97 werden nur Charts als Platzhalter angezeigt
-            eChart = VOBJ_MODE_SHOW;	//#i80528# VOBJ_MODE_DUMMY replaced by VOBJ_MODE_SHOW now
-            eDraw  = VOBJ_MODE_SHOW;
-            break;
-        case 2:							// Hide all
-            eOle   = VOBJ_MODE_HIDE;
-            eChart = VOBJ_MODE_HIDE;
-            eDraw  = VOBJ_MODE_HIDE;
-            break;
-        default:						// Show all
-            eOle   = VOBJ_MODE_SHOW;
-            eChart = VOBJ_MODE_SHOW;
-            eDraw  = VOBJ_MODE_SHOW;
-            break;
-    }
-
-    aOpts.SetObjMode( VOBJ_TYPE_OLE,   eOle );
-    aOpts.SetObjMode( VOBJ_TYPE_CHART, eChart );
-    aOpts.SetObjMode( VOBJ_TYPE_DRAW,  eDraw );
-
-    pD->SetViewOptions( aOpts );
-}
-
-
-void ImportExcel::Bundleheader( void )
-{
-}
-
-
-void ImportExcel::Standardwidth( void )
-{
-    USHORT nScWidth = XclTools::GetScColumnWidth( maStrm.ReaduInt16(), GetCharWidth() );
-    pColRowBuff->SetDefWidth( nScWidth, TRUE );
-}
-
-
-void ImportExcel::Shrfmla( void )
-{
-    UINT16				nFirstRow, nLastRow, nLenExpr;
-    BYTE				nFirstCol, nLastCol;
-
-    aIn >> nFirstRow >> nLastRow >> nFirstCol >> nLastCol;
-    aIn.Ignore( 2 );
-    aIn >> nLenExpr;
-
-    // jetzt steht Lesemarke an der Formel
-
-    const ScTokenArray*	pErgebnis;
-
-    pFormConv->Reset();
-    pFormConv->Convert( pErgebnis, maStrm, nLenExpr, true, FT_SharedFormula );
-
-
-    DBG_ASSERT( pErgebnis, "+ImportExcel::Shrfmla(): ScTokenArray ist NULL!" );
-
-    pExcRoot->pShrfmlaBuff->Store( ScRange( static_cast<SCCOL>(nFirstCol),
-                static_cast<SCROW>(nFirstRow), GetCurrScTab(),
-                static_cast<SCCOL>(nLastCol), static_cast<SCROW>(nLastRow),
-                GetCurrScTab()), *pErgebnis );
-}
-
-
-void ImportExcel::Mulrk( void )
-{
-    XclAddress aXclPos;
-    UINT16  nXF;
-    INT32   nRkNum;
-
-    aIn >> aXclPos;
-
-    for( XclAddress aCurrXclPos( aXclPos ); (aXclPos.mnCol <= aCurrXclPos.mnCol) && (aIn.GetRecLeft() > 2); ++aCurrXclPos.mnCol )
-    {
-        aIn >> nXF >> nRkNum;
-
-        ScAddress aScPos( ScAddress::UNINITIALIZED );
-        if( GetAddressConverter().ConvertAddress( aScPos, aCurrXclPos, GetCurrScTab(), true ) )
-        {
-            GetXFRangeBuffer().SetXF( aScPos, nXF );
-            GetDoc().PutCell( aScPos, new ScValueCell( XclTools::GetDoubleFromRK( nRkNum ) ) );
-        }
-    }
-}
-
-
-void ImportExcel::Mulblank( void )
-{
-    XclAddress aXclPos;
-    UINT16  nXF;
-
-    aIn >> aXclPos;
-
-    for( XclAddress aCurrXclPos( aXclPos ); (aXclPos.mnCol <= aCurrXclPos.mnCol) && (aIn.GetRecLeft() > 2); ++aCurrXclPos.mnCol )
-    {
-        aIn >> nXF;
-
-        ScAddress aScPos( ScAddress::UNINITIALIZED );
-        if( GetAddressConverter().ConvertAddress( aScPos, aCurrXclPos, GetCurrScTab(), true ) )
-            GetXFRangeBuffer().SetBlankXF( aScPos, nXF );
-    }
-}
-
-
-void ImportExcel::Rstring( void )
-{
-    XclAddress aXclPos;
-    sal_uInt16 nXFIdx;
-    aIn >> aXclPos >> nXFIdx;
-
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScPos, aXclPos, GetCurrScTab(), true ) )
-    {
-        // unformatted Unicode string with separate formatting information
-        XclImpString aString;
-
-        // #i63105# use text encoding from FONT record
-        rtl_TextEncoding eOldTextEnc = GetTextEncoding();
-        if( const XclImpFont* pFont = GetXFBuffer().GetFont( nXFIdx ) )
-            SetTextEncoding( pFont->GetFontEncoding() );
-        aString.Read( maStrm );
-        SetTextEncoding( eOldTextEnc );
-
-        // character formatting runs
-        if( !aString.IsRich() )
-            aString.ReadFormats( maStrm );
-
-        GetXFRangeBuffer().SetXF( aScPos, nXFIdx );
-        if( ScBaseCell* pCell = XclImpStringHelper::CreateCell( *this, aString, nXFIdx ) )
-            GetDoc().PutCell( aScPos, pCell );
-    }
-}
-
-
-void ImportExcel::Cellmerging()
-{
-    XclImpAddressConverter& rAddrConv = GetAddressConverter();
-    SCTAB nScTab = GetCurrScTab();
-
-    sal_uInt16 nCount;
-    maStrm >> nCount;
-    for( sal_uInt16 nIdx = 0; (nIdx < nCount) && (maStrm.GetRecLeft() >= 8); ++nIdx )
-    {
-        XclRange aXclRange;
-        maStrm >> aXclRange;    // 16-bit rows and columns
-        ScRange aScRange( ScAddress::UNINITIALIZED );
-        if( rAddrConv.ConvertRange( aScRange, aXclRange, nScTab, nScTab, true ) )
-            GetXFRangeBuffer().SetMerge( aScRange.aStart.Col(), aScRange.aStart.Row(), aScRange.aEnd.Col(), aScRange.aEnd.Row() );
-    }
-}
-
-
-void ImportExcel::Olesize( void )
-{
-    XclRange aXclOleSize( ScAddress::UNINITIALIZED );
-    maStrm.Ignore( 2 );
-    aXclOleSize.Read( maStrm, false );
-
-    SCTAB nScTab = GetCurrScTab();
-    ScRange& rOleSize = GetExtDocOptions().GetDocSettings().maOleSize;
-    GetAddressConverter().ConvertRange( rOleSize, aXclOleSize, nScTab, nScTab, false );
-}
-
-
-void ImportExcel::Row34( void )
-{
-    UINT16	nRow, nRowHeight, nGrbit, nXF;
-
-    aIn >> nRow;
-    aIn.Ignore( 4 );   // Mic und Mac ueberspringen
-
-    SCROW nScRow = static_cast< SCROW >( nRow );
-
-    if( ValidRow( nScRow ) )
-    {
-        aIn >> nRowHeight;	// direkt in Twips angegeben
-        aIn.Ignore( 4 );
-
-        aIn >> nGrbit >> nXF;
-
-        sal_uInt8 nLevel = ::extract_value< sal_uInt8 >( nGrbit, 0, 3 );
-        pRowOutlineBuff->SetLevel( nScRow, nLevel,
-            ::get_flag( nGrbit, EXC_ROW_COLLAPSED ), ::get_flag( nGrbit, EXC_ROW_HIDDEN ) );
-
-        pColRowBuff->SetRowSettings( nScRow, nRowHeight, nGrbit );
-
-        if( nGrbit & EXC_ROW_USEDEFXF )
-            GetXFRangeBuffer().SetRowDefXF( nScRow, nXF & EXC_ROW_XFMASK );
-    }
-}
-
-
-void ImportExcel::Bof3( void )
-{
-    sal_uInt16 nSubType;
-    maStrm.DisableDecryption();
-    maStrm.Ignore( 2 );
-    maStrm >> nSubType;
-
-    DBG_ASSERT( nSubType != 0x0100, "*ImportExcel::Bof3(): Biff3 als Workbook?!" );
-    if( nSubType == 0x0100 )        // Book
-        pExcRoot->eDateiTyp = Biff3W;
-    else if( nSubType == 0x0020 )   // Chart
-        pExcRoot->eDateiTyp = Biff3C;
-    else if( nSubType == 0x0040 )   // Macro
-        pExcRoot->eDateiTyp = Biff3M;
-    else                            // #i51490# Excel interprets invalid indexes as worksheet
-        pExcRoot->eDateiTyp = Biff3;
-}
-
-
-void ImportExcel::Array34( void )
-{
-    UINT16					nFirstRow, nLastRow, nFormLen;
-    BYTE					nFirstCol, nLastCol;
-
-    aIn >> nFirstRow >> nLastRow >> nFirstCol >> nLastCol;
-    aIn.Ignore( (GetBiff() >= EXC_BIFF5) ? 6 : 2 );
-    aIn >> nFormLen;
-
-    if( ValidColRow( nLastCol, nLastRow ) )
-    {
-        // jetzt steht Lesemarke auf Formel, Laenge in nFormLen
-        const ScTokenArray*	pErgebnis;
-
-        pFormConv->Reset( ScAddress( static_cast<SCCOL>(nFirstCol),
-                    static_cast<SCROW>(nFirstRow), GetCurrScTab() ) );
-        pFormConv->Convert( pErgebnis, maStrm, nFormLen, true, FT_CellFormula);
-
-        DBG_ASSERT( pErgebnis, "+ImportExcel::Array34(): ScTokenArray ist NULL!" );
-
-        ScMarkData			aMarkData;
-        aMarkData.SelectOneTable( GetCurrScTab() );
-        pD->InsertMatrixFormula( static_cast<SCCOL>(nFirstCol),
-                static_cast<SCROW>(nFirstRow), static_cast<SCCOL>(nLastCol),
-                static_cast<SCROW>(nLastRow), aMarkData, EMPTY_STRING,
-                pErgebnis);
-    }
-}
-
-
-void ImportExcel::Externname34( void )
-{
-}
-
-
-void ImportExcel::Defrowheight345( void )
-{
-    sal_uInt16 nFlags, nDefHeight;
-    maStrm >> nFlags >> nDefHeight;
-    pColRowBuff->SetDefHeight( nDefHeight, nFlags );
-}
-
-
-void ImportExcel::TableOp( void )
-{
-    UINT16 nFirstRow, nLastRow;
-    UINT8 nFirstCol, nLastCol;
-    UINT16 nGrbit;
-    UINT16 nInpRow, nInpCol, nInpRow2, nInpCol2;
-
-    aIn >> nFirstRow >> nLastRow >> nFirstCol >> nLastCol >> nGrbit
-        >> nInpRow >> nInpCol >> nInpRow2 >> nInpCol2;
-
-    if( ValidColRow( nLastCol, nLastRow ) )
-    {
-        if( nFirstCol && nFirstRow )
-        {
-            ScTabOpParam aTabOpParam;
-            aTabOpParam.nMode = (nGrbit & EXC_TABLEOP_BOTH) ? 2 : ((nGrbit & EXC_TABLEOP_ROW) ? 1 : 0 );
-            USHORT nCol = nFirstCol - 1;
-            USHORT nRow = nFirstRow - 1;
-            SCTAB nTab = GetCurrScTab();
-            switch( aTabOpParam.nMode )
-            {
-                case 0:		// COL
-                    aTabOpParam.aRefFormulaCell.Set(
-                            static_cast<SCCOL>(nFirstCol),
-                            static_cast<SCROW>(nFirstRow - 1), nTab, FALSE,
-                            FALSE, FALSE );
-                    aTabOpParam.aRefFormulaEnd.Set(
-                            static_cast<SCCOL>(nLastCol),
-                            static_cast<SCROW>(nFirstRow - 1), nTab, FALSE,
-                            FALSE, FALSE );
-                    aTabOpParam.aRefColCell.Set( static_cast<SCCOL>(nInpCol),
-                            static_cast<SCROW>(nInpRow), nTab, FALSE, FALSE,
-                            FALSE );
-                    nRow++;
-                break;
-                case 1:		// ROW
-                    aTabOpParam.aRefFormulaCell.Set(
-                            static_cast<SCCOL>(nFirstCol - 1),
-                            static_cast<SCROW>(nFirstRow), nTab, FALSE, FALSE,
-                            FALSE );
-                    aTabOpParam.aRefFormulaEnd.Set(
-                            static_cast<SCCOL>(nFirstCol - 1),
-                            static_cast<SCROW>(nLastRow), nTab, FALSE, FALSE,
-                            FALSE );
-                    aTabOpParam.aRefRowCell.Set( static_cast<SCCOL>(nInpCol),
-                            static_cast<SCROW>(nInpRow), nTab, FALSE, FALSE,
-                            FALSE );
-                    nCol++;
-                break;
-                case 2:		// TWO-INPUT
-                    aTabOpParam.aRefFormulaCell.Set(
-                            static_cast<SCCOL>(nFirstCol - 1),
-                            static_cast<SCROW>(nFirstRow - 1), nTab, FALSE,
-                            FALSE, FALSE );
-                    aTabOpParam.aRefRowCell.Set( static_cast<SCCOL>(nInpCol),
-                            static_cast<SCROW>(nInpRow), nTab, FALSE, FALSE,
-                            FALSE );
-                    aTabOpParam.aRefColCell.Set( static_cast<SCCOL>(nInpCol2),
-                            static_cast<SCROW>(nInpRow2), nTab, FALSE, FALSE,
-                            FALSE );
-                break;
-            }
-
-            ScMarkData aMarkData;
-            aMarkData.SelectOneTable( nTab );
-            pD->InsertTableOp( aTabOpParam, static_cast<SCCOL>(nCol),
-                    static_cast<SCROW>(nRow), static_cast<SCCOL>(nLastCol),
-                    static_cast<SCROW>(nLastRow), aMarkData );
-        }
-    }
-    else
-    {
-        bTabTruncated = TRUE;
-        GetTracer().TraceInvalidRow(GetCurrScTab(), nLastRow, MAXROW);
-    }
-}
-
-
-void ImportExcel::Bof4( void )
-{
-    sal_uInt16 nSubType;
-    maStrm.DisableDecryption();
-    maStrm.Ignore( 2 );
-    maStrm >> nSubType;
-
-    if( nSubType == 0x0100 )        // Book
-        pExcRoot->eDateiTyp = Biff4W;
-    else if( nSubType == 0x0020 )   // Chart
-        pExcRoot->eDateiTyp = Biff4C;
-    else if( nSubType == 0x0040 )   // Macro
-        pExcRoot->eDateiTyp = Biff4M;
-    else                            // #i51490# Excel interprets invalid indexes as worksheet
-        pExcRoot->eDateiTyp = Biff4;
-}
-
-
-void ImportExcel::Bof5( void )
-{
-    //POST:	eDateiTyp = Typ der zu lesenden Datei
-    UINT16		nSubType, nVers;
-    BiffTyp		eDatei;
-
-    maStrm.DisableDecryption();
-    maStrm >> nVers >> nSubType;
-
-    switch( nSubType )
-    {
-        case 0x0005:    eDatei = Biff5W;    break;  // workbook globals
-        case 0x0006:    eDatei = Biff5V;    break;  // VB module
-        case 0x0010:    eDatei = Biff5;     break;  // worksheet
-        case 0x0020:    eDatei = Biff5C;    break;  // chart
-        case 0x0040:    eDatei = Biff5M4;   break;  // macro sheet
-        default:
-            pExcRoot->eDateiTyp = BiffX;
-            return;
-    }
-
-    if( nVers == 0x0600 && (GetBiff() == EXC_BIFF8) )
-        eDatei = ( BiffTyp ) ( eDatei - Biff5 + Biff8 );
-
-    pExcRoot->eDateiTyp = eDatei;
-}
-
-void ImportExcel::EndSheet( void )
-{
-    pExcRoot->pExtSheetBuff->Reset();
-
-    if( GetBiff() <= EXC_BIFF5 )
-    {
-        pExcRoot->pExtNameBuff->Reset();
-        mnLastRefIdx = 0;
-    }
-
-    FinalizeTable();
-}
-
-
-void ImportExcel::NeueTabelle( void )
-{
-    SCTAB nTab = GetCurrScTab();
-    if( nTab > 0 && !pD->HasTable( nTab ) )
-        pD->MakeTable( nTab );
-
-    pExcRoot->pShrfmlaBuff->Clear();
-
-    InitializeTable( nTab );
-
-    pOutlineListBuffer->Append( new XclImpOutlineDataBuffer( GetRoot(), nTab ) );
-
-    pExcRoot->pColRowBuff = pColRowBuff = pOutlineListBuffer->Last()->GetColRowBuff();
-    pColOutlineBuff = pOutlineListBuffer->Last()->GetColOutline();
-    pRowOutlineBuff = pOutlineListBuffer->Last()->GetRowOutline();
-}
-
-
-const ScTokenArray* ImportExcel::ErrorToFormula( BYTE bErrOrVal, BYTE nError, double& rVal )
-{
-    return pFormConv->GetBoolErr( XclTools::ErrorToEnum( rVal, bErrOrVal, nError ) );
-}
-
-
-void ImportExcel::AdjustRowHeight()
-{
-    /*  #93255# Speed up chart import: import all sheets without charts, then
-        update row heights (here), last load all charts -> do not any longer
-        update inside of ScDocShell::ConvertFrom() (causes update of existing
-        charts during each and every change of row height). */
-    if( ScModelObj* pDocObj = GetDocModelObj() )
-        pDocObj->UpdateAllRowHeights();
-}
-
-
-void ImportExcel::PostDocLoad( void )
-{
-    /*  Set automatic page numbering in Default page style (default is "page number = 1").
-        Otherwise hidden tables (i.e. for scenarios) which have Default page style will
-        break automatic page numbering. */
-    if( SfxStyleSheetBase* pStyleSheet = GetStyleSheetPool().Find( ScGlobal::GetRscString( STR_STYLENAME_STANDARD ), SFX_STYLE_FAMILY_PAGE ) )
-        pStyleSheet->GetItemSet().Put( SfxUInt16Item( ATTR_PAGE_FIRSTPAGENO, 0 ) );
-
-    // outlines for all sheets, sets hidden rows and columns (#i11776# after filtered ranges)
-    for( XclImpOutlineDataBuffer* pBuffer = pOutlineListBuffer->First(); pBuffer; pBuffer = pOutlineListBuffer->Next() )
-        pBuffer->Convert();
-
-    // document view settings (before visible OLE area)
-    GetDocViewSettings().Finalize();
-
-    // process all drawing objects (including OLE, charts, controls; after hiding rows/columns; before visible OLE area)
-    GetObjectManager().ConvertObjects();
-
-    // visible area if embedded OLE
-    if( ScModelObj* pDocObj = GetDocModelObj() )
-    {
-        if( SfxObjectShell* pEmbObj = pDocObj->GetEmbeddedObject() )
-        {
-            // visible area if embedded
-            const ScExtDocSettings& rDocSett = GetExtDocOptions().GetDocSettings();
-            SCTAB nDisplScTab = rDocSett.mnDisplTab;
-
-            // first try if there was an OLESIZE record
-            ScRange aScOleSize = rDocSett.maOleSize;
-
-            /*  #i44077# If a new OLE object is inserted from file, there
-                is no OLESIZE record in the Excel file. Calculate used area
-                from file contents (used cells and drawing objects). */
-            if( !aScOleSize.IsValid() )
-            {
-                // used area of displayed sheet (cell contents)
-                if( const ScExtTabSettings* pTabSett = GetExtDocOptions().GetTabSettings( nDisplScTab ) )
-                    aScOleSize = pTabSett->maUsedArea;
-                // add all valid drawing objects
-                ScRange aScObjArea = GetObjectManager().GetUsedArea( nDisplScTab );
-                if( aScObjArea.IsValid() )
-                    aScOleSize.ExtendTo( aScObjArea );
-            }
-
-            // valid size found - set it at the document
-            if( aScOleSize.IsValid() )
-            {
-                pEmbObj->SetVisArea( GetDoc().GetMMRect(
-                    aScOleSize.aStart.Col(), aScOleSize.aStart.Row(),
-                    aScOleSize.aEnd.Col(), aScOleSize.aEnd.Row(), nDisplScTab ) );
-                GetDoc().SetVisibleTab( nDisplScTab );
-            }
-        }
-
-        // #111099# open forms in alive mode (has no effect, if no controls in document)
-        pDocObj->setPropertyValue( CREATE_OUSTRING( SC_UNO_APPLYFMDES ), ::comphelper::makeBoolAny( sal_False ) );
-    }
-
-    // enables extended options to be set to the view after import
-    GetExtDocOptions().SetChanged( true );
-
-    // root data owns the extended document options -> create a new object
-    GetDoc().SetExtDocOptions( new ScExtDocOptions( GetExtDocOptions() ) );
-
-    const SCTAB		nLast = pD->GetTableCount();
-    const ScRange*		p;
-
-    if( pExcRoot->pPrintRanges->HasRanges() )
-    {
-        for( SCTAB n = 0 ; n < nLast ; n++ )
-        {
-            p = pExcRoot->pPrintRanges->First( static_cast<UINT16>(n) );
-            if( p )
-            {
-                DBG_ASSERT( pExcRoot->pPrintRanges->GetActList(),
-                            "-ImportExcel::PostDocLoad(): Imaginaere Tabelle gefunden!" );
-
-                pD->ClearPrintRanges( n );
-                while( p )
-                {
-                    pD->AddPrintRange( n, *p );
-                    p = pExcRoot->pPrintRanges->Next();
-                }
-            }
-            else
-            {
-                // #i4063# no print ranges -> print entire sheet
-                pD->SetPrintEntireSheet( n );
-            }
-        }
-        GetTracer().TracePrintRange();
-    }
-
-    if( pExcRoot->pPrintTitles->HasRanges() )
-    {
-        for( SCTAB n = 0 ; n < nLast ; n++ )
-        {
-            p = pExcRoot->pPrintTitles->First( static_cast<UINT16>(n) );
-            if( p )
-            {
-                DBG_ASSERT( pExcRoot->pPrintTitles->GetActList(),
-                    "-ImportExcel::PostDocLoad(): Imaginaere Tabelle gefunden!" );
-
-                BOOL	bRowVirgin = TRUE;
-                BOOL	bColVirgin = TRUE;
-
-                while( p )
-                {
-                    if( p->aStart.Col() == 0 && p->aEnd.Col() == MAXCOL && bRowVirgin )
-                    {
-                        pD->SetRepeatRowRange( n, p );
-                        bRowVirgin = FALSE;
-                    }
-
-                    if( p->aStart.Row() == 0 && p->aEnd.Row() == MAXROW && bColVirgin )
-                    {
-                        pD->SetRepeatColRange( n, p );
-                        bColVirgin = FALSE;
-                    }
-
-                    p = pExcRoot->pPrintTitles->Next();
-                }
-            }
-        }
-    }
-}
-
-XclImpOutlineDataBuffer::XclImpOutlineDataBuffer( const XclImpRoot& rRoot, SCTAB nScTab ) :
-    XclImpRoot( rRoot ),
-    mxColOutlineBuff( new XclImpOutlineBuffer( MAXCOLCOUNT ) ),
-    mxRowOutlineBuff( new XclImpOutlineBuffer( MAXROWCOUNT ) ),
-    mxColRowBuff( new XclImpColRowSettings( rRoot ) ),
-    mnScTab( nScTab )
-{
-}
-
-XclImpOutlineDataBuffer::~XclImpOutlineDataBuffer()
-{
-}
-
-void XclImpOutlineDataBuffer::Convert()
-{
-    mxColOutlineBuff->SetOutlineArray( GetDoc().GetOutlineTable( mnScTab, TRUE )->GetColArray() );
-    mxColOutlineBuff->MakeScOutline();
-
-    mxRowOutlineBuff->SetOutlineArray( GetDoc().GetOutlineTable( mnScTab, TRUE )->GetRowArray() );
-    mxRowOutlineBuff->MakeScOutline();
-
-    mxColRowBuff->ConvertHiddenFlags( mnScTab );
-}
diff --git sc/source/filter/xlsx/xlsx-namebuff.cxx sc/source/filter/xlsx/xlsx-namebuff.cxx
index 5ecea62..babae35 100644
--- sc/source/filter/xlsx/xlsx-namebuff.cxx
+++ sc/source/filter/xlsx/xlsx-namebuff.cxx
@@ -303,6 +303,7 @@ BOOL ExtName::IsOLE( void ) const
 }
 
 
+#if 0 // xlsx
 ExtNameBuff::ExtNameBuff( const XclImpRoot& rRoot ) :
     XclImpRoot( rRoot )
 {
@@ -345,3 +346,4 @@ void ExtNameBuff::Reset( void )
 }
 
 
+#endif // xlsx 
diff --git sc/source/filter/xlsx/xlsx-read.cxx sc/source/filter/xlsx/xlsx-read.cxx
index 02e9058..aad3e13 100644
--- sc/source/filter/xlsx/xlsx-read.cxx
+++ sc/source/filter/xlsx/xlsx-read.cxx
@@ -35,6 +35,7 @@
 
 //------------------------------------------------------------------------
 
+#if 0 // xlsx
 #include <stdlib.h>
 #include <stdio.h>
 
@@ -1310,3 +1311,4 @@ FltError ImportExcel8::Read( void )
 
 //___________________________________________________________________
 
+#endif // xlsx
diff --git sc/source/filter/xlsx/xlsx-xechart.cxx sc/source/filter/xlsx/xlsx-xechart.cxx
index 3e06c27..3cb3e5e 100644
--- sc/source/filter/xlsx/xlsx-xechart.cxx
+++ sc/source/filter/xlsx/xlsx-xechart.cxx
@@ -113,6 +113,7 @@ using ::formula::FormulaToken;
 
 namespace {
 
+#if 0 // xlsx
 XclExpStream& operator<<( XclExpStream& rStrm, const XclChRectangle& rRect )
 {
     return rStrm << rRect.mnX << rRect.mnY << rRect.mnWidth << rRect.mnHeight;
@@ -142,6 +143,7 @@ void lclWriteChFrBlockRecord( XclExpStream& rStrm, const XclChFrBlock& rFrBlock,
     rStrm << nRecId << EXC_FUTUREREC_EMPTYFLAGS << rFrBlock.mnType << rFrBlock.mnContext << rFrBlock.mnValue1 << rFrBlock.mnValue2;
     rStrm.EndRecord();
 }
+#endif // xlsx
 
 template< typename Type >
 inline bool lclIsAutoAnyOrGetValue( Type& rValue, const Any& rAny, bool bPercent )
@@ -208,8 +210,9 @@ void XclExpChRootData::RegisterFutureRecBlock( const XclChFrBlock& rFrBlock )
     maUnwrittenFrBlocks.push_back( rFrBlock );
 }
 
-void XclExpChRootData::InitializeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRootData::InitializeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // first call from a future record writes all missing CHFRBLOCKBEGIN records
     if( !maUnwrittenFrBlocks.empty() )
     {
@@ -231,10 +234,12 @@ void XclExpChRootData::InitializeFutureRecBlock( XclExpStream& rStrm )
         maWrittenFrBlocks.insert( maWrittenFrBlocks.end(), maUnwrittenFrBlocks.begin(), maUnwrittenFrBlocks.end() );
         maUnwrittenFrBlocks.clear();
     }
+#endif // xlsx
 }
 
-void XclExpChRootData::FinalizeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRootData::FinalizeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( !maUnwrittenFrBlocks.empty() || !maWrittenFrBlocks.empty(), "XclExpChRootData::FinalizeFutureRecBlock - no future record level found" );
     if( !maUnwrittenFrBlocks.empty() )
     {
@@ -247,6 +252,7 @@ void XclExpChRootData::FinalizeFutureRecBlock( XclExpStream& rStrm )
         lclWriteChFrBlockRecord( rStrm, maWrittenFrBlocks.back(), false );
         maWrittenFrBlocks.pop_back();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -344,14 +350,18 @@ void XclExpChRoot::RegisterFutureRecBlock( const XclChFrBlock& rFrBlock )
     mxChData->RegisterFutureRecBlock( rFrBlock );
 }
 
-void XclExpChRoot::InitializeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRoot::InitializeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxChData->InitializeFutureRecBlock( rStrm );
+#endif // xlsx
 }
 
-void XclExpChRoot::FinalizeFutureRecBlock( XclExpStream& rStrm )
+void XclExpChRoot::FinalizeFutureRecBlock( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxChData->FinalizeFutureRecBlock( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -368,8 +378,9 @@ XclExpChGroupBase::~XclExpChGroupBase()
 {
 }
 
-void XclExpChGroupBase::Save( XclExpStream& rStrm )
+void XclExpChGroupBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // header record
     XclExpRecord::Save( rStrm );
     // group records
@@ -386,6 +397,7 @@ void XclExpChGroupBase::Save( XclExpStream& rStrm )
         // CHEND record
         XclExpEmptyRecord( EXC_ID_CHEND ).Save( rStrm );
     }
+#endif // xlsx
 }
 
 bool XclExpChGroupBase::HasSubRecords() const
@@ -409,10 +421,12 @@ XclExpChFutureRecordBase::XclExpChFutureRecordBase( const XclExpChRoot& rRoot,
 {
 }
 
-void XclExpChFutureRecordBase::Save( XclExpStream& rStrm )
+void XclExpChFutureRecordBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     InitializeFutureRecBlock( rStrm );
     XclExpFutureRecord::Save( rStrm );
+#endif // xlsx
 }
 
 // Frame formatting ===========================================================
@@ -475,11 +489,13 @@ bool XclExpChLineFormat::IsDefault( XclChFrameType eDefFrameType ) const
         ((eDefFrameType == EXC_CHFRAMETYPE_AUTO) && IsAuto());
 }
 
-void XclExpChLineFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChLineFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maColor << maData.mnPattern << maData.mnWeight << maData.mnFlags;
     if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
         rStrm << rStrm.GetRoot().GetPalette().GetColorIndex( mnColorId );
+#endif // xlsx
 }
 
 namespace {
@@ -566,14 +582,16 @@ bool XclExpChAreaFormat::IsDefault( XclChFrameType eDefFrameType ) const
         ((eDefFrameType == EXC_CHFRAMETYPE_AUTO) && IsAuto());
 }
 
-void XclExpChAreaFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChAreaFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maPattColor << maData.maBackColor << maData.mnPattern << maData.mnFlags;
     if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
     {
         const XclExpPalette& rPal = rStrm.GetRoot().GetPalette();
         rStrm << rPal.GetColorIndex( mnPattColorId ) << rPal.GetColorIndex( mnBackColorId );
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -600,8 +618,9 @@ bool XclExpChEscherFormat::IsValid() const
     return maData.mxEscherSet.is();
 }
 
-void XclExpChEscherFormat::Save( XclExpStream& rStrm )
+void XclExpChEscherFormat::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( maData.mxEscherSet.is() )
     {
         // replace RGB colors with palette indexes in the Escher container
@@ -612,6 +631,7 @@ void XclExpChEscherFormat::Save( XclExpStream& rStrm )
         // save the record group
         XclExpChGroupBase::Save( rStrm );
     }
+#endif // xlsx
 }
 
 bool XclExpChEscherFormat::HasSubRecords() const
@@ -620,11 +640,13 @@ bool XclExpChEscherFormat::HasSubRecords() const
     return maPicFmt.mnBmpMode != EXC_CHPICFORMAT_NONE;
 }
 
-void XclExpChEscherFormat::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChEscherFormat::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_CHPICFORMAT, 14 );
     rStrm << maPicFmt.mnBmpMode << maPicFmt.mnFormat << maPicFmt.mnFlags << maPicFmt.mfScale;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 sal_uInt32 XclExpChEscherFormat::RegisterColor( sal_uInt16 nPropId )
@@ -642,14 +664,16 @@ sal_uInt32 XclExpChEscherFormat::RegisterColor( sal_uInt16 nPropId )
     return XclExpPalette::GetColorIdFromIndex( EXC_COLOR_CHWINDOWBACK );
 }
 
-void XclExpChEscherFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChEscherFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( maData.mxEscherSet.is(), "XclExpChEscherFormat::WriteBody - missing property container" );
     // write Escher property container via temporary memory stream
     SvMemoryStream aMemStrm;
     maData.mxEscherSet->Commit( aMemStrm );
     aMemStrm.Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( aMemStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -707,11 +731,13 @@ bool XclExpChFrameBase::IsDefaultFrameBase( XclChFrameType eDefFrameType ) const
         (!mxAreaFmt || mxAreaFmt->IsDefault( eDefFrameType ));
 }
 
-void XclExpChFrameBase::WriteFrameRecords( XclExpStream& rStrm )
+void XclExpChFrameBase::WriteFrameRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxLineFmt );
     lclSaveRecord( rStrm, mxAreaFmt );
     lclSaveRecord( rStrm, mxEscherFmt );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -737,8 +763,9 @@ bool XclExpChFrame::IsDeleteable() const
     return IsDefault() && GetFormatInfo( meObjType ).mbDeleteDefFrame;
 }
 
-void XclExpChFrame::Save( XclExpStream& rStrm )
+void XclExpChFrame::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( meObjType )
     {
         // wall/floor frame without CHFRAME header record
@@ -749,16 +776,21 @@ void XclExpChFrame::Save( XclExpStream& rStrm )
         default:
             XclExpChGroupBase::Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpChFrame::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChFrame::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteFrameRecords( rStrm );
+#endif // xlsx
 }
 
-void XclExpChFrame::WriteBody( XclExpStream& rStrm )
+void XclExpChFrame::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnFormat << maData.mnFlags;
+#endif // xlsx
 }
 
 namespace {
@@ -983,8 +1015,9 @@ void XclExpChSourceLink::AppendString( const String& rStr )
     XclExpStringHelper::AppendString( *mxString, GetRoot(), rStr );
 }
 
-void XclExpChSourceLink::Save( XclExpStream& rStrm )
+void XclExpChSourceLink::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // CHFORMATRUNS record
     if( mxString.is() && mxString->IsRich() )
     {
@@ -1002,15 +1035,18 @@ void XclExpChSourceLink::Save( XclExpStream& rStrm )
         rStrm << sal_uInt16( 0 ) << *mxString;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpChSourceLink::WriteBody( XclExpStream& rStrm )
+void XclExpChSourceLink::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnDestType
             << maData.mnLinkType
             << maData.mnFlags
             << maData.mnNumFmtIdx
             << mxLinkFmla;
+#endif // xlsx
 }
 
 // Text =======================================================================
@@ -1029,9 +1065,11 @@ XclExpChObjectLink::XclExpChObjectLink( sal_uInt16 nLinkTarget, const XclChDataP
     maData.maPointPos = rPointPos;
 }
 
-void XclExpChObjectLink::WriteBody( XclExpStream& rStrm )
+void XclExpChObjectLink::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnTarget << maData.maPointPos.mnSeriesIdx << maData.maPointPos.mnPointIdx;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1057,10 +1095,12 @@ void XclExpChFrLabelProps::Convert( const ScfPropertySet& rPropSet, bool bShowSe
         maData.maSeparator = String( sal_Unicode( ' ' ) );
 }
 
-void XclExpChFrLabelProps::WriteBody( XclExpStream& rStrm )
+void XclExpChFrLabelProps::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclExpString aXclSep( maData.maSeparator, EXC_STR_FORCEUNICODE | EXC_STR_SMARTFLAGS );
     rStrm << maData.mnFlags << aXclSep;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1281,8 +1321,9 @@ sal_uInt16 XclExpChText::GetAttLabelFlags() const
     return nFlags;
 }
 
-void XclExpChText::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChText::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // CHFONT record
     lclSaveRecord( rStrm, mxFont );
     // CHSOURCELINK group
@@ -1293,10 +1334,12 @@ void XclExpChText::WriteSubRecords( XclExpStream& rStrm )
     lclSaveRecord( rStrm, mxObjLink );
     // CHFRLABELPROPS record
     lclSaveRecord( rStrm, mxLabelProps );
+#endif // xlsx
 }
 
-void XclExpChText::WriteBody( XclExpStream& rStrm )
+void XclExpChText::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnHAlign
             << maData.mnVAlign
             << maData.mnBackMode
@@ -1310,6 +1353,7 @@ void XclExpChText::WriteBody( XclExpStream& rStrm )
                 << maData.mnPlacement
                 << maData.mnRotation;
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1396,14 +1440,16 @@ void XclExpChMarkerFormat::RegisterColors( const XclExpChRoot& rRoot )
     }
 }
 
-void XclExpChMarkerFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChMarkerFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maLineColor << maData.maFillColor << maData.mnMarkerType << maData.mnFlags;
     if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
     {
         const XclExpPalette& rPal = rStrm.GetRoot().GetPalette();
         rStrm << rPal.GetColorIndex( mnLineColorId ) << rPal.GetColorIndex( mnFillColorId ) << maData.mnMarkerSize;
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1457,9 +1503,11 @@ void XclExpCh3dDataFormat::Convert( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpCh3dDataFormat::WriteBody( XclExpStream& rStrm )
+void XclExpCh3dDataFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnBase << maData.mnTop;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1534,22 +1582,26 @@ void XclExpChDataFormat::ConvertLine( const ScfPropertySet& rPropSet, XclChObjec
     ConvertFrameBase( GetChRoot(), rPropSet, eObjType );
 }
 
-void XclExpChDataFormat::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChDataFormat::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mx3dDataFmt );
     WriteFrameRecords( rStrm );
     lclSaveRecord( rStrm, mxPieFmt );
     lclSaveRecord( rStrm, mxMarkerFmt );
     lclSaveRecord( rStrm, mxSeriesFmt );
     lclSaveRecord( rStrm, mxAttLabel );
+#endif // xlsx
 }
 
-void XclExpChDataFormat::WriteBody( XclExpStream& rStrm )
+void XclExpChDataFormat::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.maPointPos.mnPointIdx
             << maData.maPointPos.mnSeriesIdx
             << maData.mnFormatIdx
             << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1607,8 +1659,9 @@ bool XclExpChSerTrendLine::Convert( Reference< XRegressionCurve > xRegCurve, sal
     return true;
 }
 
-void XclExpChSerTrendLine::WriteBody( XclExpStream& rStrm )
+void XclExpChSerTrendLine::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnLineType
             << maData.mnOrder
             << maData.mfIntercept
@@ -1616,6 +1669,7 @@ void XclExpChSerTrendLine::WriteBody( XclExpStream& rStrm )
             << maData.mnShowRSquared
             << maData.mfForecastFor
             << maData.mfForecastBack;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1689,14 +1743,16 @@ bool XclExpChSerErrorBar::Convert( XclExpChSourceLink& rValueLink, sal_uInt16& r
     return bOk;
 }
 
-void XclExpChSerErrorBar::WriteBody( XclExpStream& rStrm )
+void XclExpChSerErrorBar::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnBarType
             << maData.mnSourceType
             << maData.mnLineEnd
             << sal_uInt8( 1 )       // must be 1 to make line visible
             << maData.mfValue
             << maData.mnValueCount;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1931,8 +1987,9 @@ void XclExpChSeries::ConvertCategSequence( Reference< XLabeledDataSequence > xCa
         maData.mnCategCount = mxCategLink->ConvertDataSequence( xCategSeq->getValues(), false );
 }
 
-void XclExpChSeries::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChSeries::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxTitleLink );
     lclSaveRecord( rStrm, mxValueLink );
     lclSaveRecord( rStrm, mxCategLink );
@@ -1945,6 +2002,7 @@ void XclExpChSeries::WriteSubRecords( XclExpStream& rStrm )
         XclExpUInt16Record( EXC_ID_CHSERPARENT, mnParentIdx ).Save( rStrm );
     lclSaveRecord( rStrm, mxTrendLine );
     lclSaveRecord( rStrm, mxErrorBar );
+#endif // xlsx
 }
 
 void XclExpChSeries::InitFromParent( const XclExpChSeries& rParent )
@@ -1997,11 +2055,13 @@ void XclExpChSeries::CreateErrorBar( const ScfPropertySet& rPropSet,
     }
 }
 
-void XclExpChSeries::WriteBody( XclExpStream& rStrm )
+void XclExpChSeries::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnCategType << maData.mnValueType << maData.mnCategCount << maData.mnValueCount;
     if( GetBiff() == EXC_BIFF8 )
         rStrm << maData.mnBubbleType << maData.mnBubbleCount;
+#endif // xlsx
 }
 
 // Chart type groups ==========================================================
@@ -2077,8 +2137,9 @@ void XclExpChType::SetStacked( bool bPercent )
     }
 }
 
-void XclExpChType::WriteBody( XclExpStream& rStrm )
+void XclExpChType::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( GetRecId() )
     {
         case EXC_ID_CHBAR:
@@ -2106,6 +2167,7 @@ void XclExpChType::WriteBody( XclExpStream& rStrm )
         default:
             DBG_ERRORFILE( "XclExpChType::WriteBody - unknown chart type" );
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2152,8 +2214,9 @@ void XclExpChChart3d::Convert( const ScfPropertySet& rPropSet, bool b3dWallChart
     }
 }
 
-void XclExpChChart3d::WriteBody( XclExpStream& rStrm )
+void XclExpChChart3d::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnRotation
             << maData.mnElevation
             << maData.mnEyeDist
@@ -2161,6 +2224,7 @@ void XclExpChChart3d::WriteBody( XclExpStream& rStrm )
             << maData.mnRelDepth
             << maData.mnDepthGap
             << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2181,15 +2245,19 @@ void XclExpChLegend::Convert( const ScfPropertySet& rPropSet )
     GetChartPropSetHelper().ReadLegendProperties( maData, rPropSet );
 }
 
-void XclExpChLegend::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChLegend::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxText );
     lclSaveRecord( rStrm, mxFrame );
+#endif // xlsx
 }
 
-void XclExpChLegend::WriteBody( XclExpStream& rStrm )
+void XclExpChLegend::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maRect << maData.mnDockMode << maData.mnSpacing << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2209,14 +2277,18 @@ void XclExpChDropBar::Convert( const ScfPropertySet& rPropSet )
         SetDefaultFrameBase( GetChRoot(), EXC_CHFRAMETYPE_INVISIBLE, true );
 }
 
-void XclExpChDropBar::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChDropBar::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteFrameRecords( rStrm );
+#endif // xlsx
 }
 
-void XclExpChDropBar::WriteBody( XclExpStream& rStrm )
+void XclExpChDropBar::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << mnBarDist;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2338,8 +2410,9 @@ void XclExpChTypeGroup::ConvertLegend( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpChTypeGroup::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChTypeGroup::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maType.Save( rStrm );
     lclSaveRecord( rStrm, mxChart3d );
     lclSaveRecord( rStrm, mxLegend );
@@ -2347,6 +2420,7 @@ void XclExpChTypeGroup::WriteSubRecords( XclExpStream& rStrm )
     lclSaveRecord( rStrm, mxDownBar );
     for( XclExpChLineFormatMap::iterator aLIt = maChartLines.begin(), aLEnd = maChartLines.end(); aLIt != aLEnd; ++aLIt )
         lclSaveRecord( rStrm, aLIt->second, EXC_ID_CHCHARTLINE, aLIt->first );
+#endif // xlsx
 }
 
 sal_uInt16 XclExpChTypeGroup::GetFreeFormatIdx() const
@@ -2423,9 +2497,11 @@ bool XclExpChTypeGroup::CreateStockSeries( Reference< XDataSeries > xDataSeries,
     return bOk;
 }
 
-void XclExpChTypeGroup::WriteBody( XclExpStream& rStrm )
+void XclExpChTypeGroup::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.maRect << maData.mnFlags << maData.mnGroupIdx;
+#endif // xlsx
 }
 
 // Axes =======================================================================
@@ -2465,9 +2541,11 @@ void XclExpChLabelRange::ConvertAxisPosition( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpChLabelRange::WriteBody( XclExpStream& rStrm )
+void XclExpChLabelRange::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnCross << maData.mnLabelFreq << maData.mnTickFreq << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2538,14 +2616,16 @@ void XclExpChValueRange::ConvertAxisPosition( const ScfPropertySet& rPropSet )
     }
 }
 
-void XclExpChValueRange::WriteBody( XclExpStream& rStrm )
+void XclExpChValueRange::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mfMin
             << maData.mfMax
             << maData.mfMajorStep
             << maData.mfMinorStep
             << maData.mfCross
             << maData.mnFlags;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2626,8 +2706,9 @@ void XclExpChTick::SetRotation( sal_uInt16 nRotation )
     ::insert_value( maData.mnFlags, XclTools::GetXclOrientFromRot( nRotation ), 2, 3 );
 }
 
-void XclExpChTick::WriteBody( XclExpStream& rStrm )
+void XclExpChTick::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << maData.mnMajor
             << maData.mnMinor
             << maData.mnLabelPos
@@ -2637,6 +2718,7 @@ void XclExpChTick::WriteBody( XclExpStream& rStrm )
             << maData.mnFlags;
     if( GetBiff() == EXC_BIFF8 )
         rStrm << GetPalette().GetColorIndex( mnTextColorId ) << maData.mnRotation;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2771,8 +2853,9 @@ void XclExpChAxis::ConvertWall( XDiagramRef xDiagram )
     }
 }
 
-void XclExpChAxis::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChAxis::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxLabelRange );
     lclSaveRecord( rStrm, mxValueRange );
     if( mnNumFmtIdx != EXC_FORMAT_NOTFOUND )
@@ -2783,11 +2866,14 @@ void XclExpChAxis::WriteSubRecords( XclExpStream& rStrm )
     lclSaveRecord( rStrm, mxMajorGrid, EXC_ID_CHAXISLINE, EXC_CHAXISLINE_MAJORGRID );
     lclSaveRecord( rStrm, mxMinorGrid, EXC_ID_CHAXISLINE, EXC_CHAXISLINE_MINORGRID );
     lclSaveRecord( rStrm, mxWallFrame, EXC_ID_CHAXISLINE, EXC_CHAXISLINE_WALLS );
+#endif // xlsx
 }
 
-void XclExpChAxis::WriteBody( XclExpStream& rStrm )
+void XclExpChAxis::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnType << maData.maRect;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -2933,8 +3019,9 @@ bool XclExpChAxesSet::Is3dChart() const
     return xTypeGroup.is() && xTypeGroup->Is3dChart();
 }
 
-void XclExpChAxesSet::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChAxesSet::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     lclSaveRecord( rStrm, mxXAxis );
     lclSaveRecord( rStrm, mxYAxis );
     lclSaveRecord( rStrm, mxZAxis );
@@ -2947,6 +3034,7 @@ void XclExpChAxesSet::WriteSubRecords( XclExpStream& rStrm )
         mxPlotFrame->Save( rStrm );
     }
     maTypeGroups.Save( rStrm );
+#endif // xlsx
 }
 
 XclExpChTypeGroupRef XclExpChAxesSet::GetFirstTypeGroup() const
@@ -2979,9 +3067,11 @@ void XclExpChAxesSet::ConvertAxis(
     rxChAxisTitle = lclCreateTitle( GetChRoot(), xTitled, nTitleTarget );
 }
 
-void XclExpChAxesSet::WriteBody( XclExpStream& rStrm )
+void XclExpChAxesSet::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maData.mnAxesSetId << maData.maRect;
+#endif // xlsx
 }
 
 // The chart object ===========================================================
@@ -3093,8 +3183,9 @@ void XclExpChChart::SetDataLabel( XclExpChTextRef xText )
         maLabels.AppendRecord( xText );
 }
 
-void XclExpChChart::WriteSubRecords( XclExpStream& rStrm )
+void XclExpChChart::WriteSubRecords( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // background format
     lclSaveRecord( rStrm, mxFrame );
 
@@ -3116,11 +3207,14 @@ void XclExpChChart::WriteSubRecords( XclExpStream& rStrm )
     // chart title and data labels
     lclSaveRecord( rStrm, mxTitle );
     maLabels.Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpChChart::WriteBody( XclExpStream& rStrm )
+void XclExpChChart::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
      rStrm << maRect;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
diff --git sc/source/filter/xlsx/xlsx-xecontent.cxx sc/source/filter/xlsx/xlsx-xecontent.cxx
index 4575fca..c639e6b 100644
--- sc/source/filter/xlsx/xlsx-xecontent.cxx
+++ sc/source/filter/xlsx/xlsx-xecontent.cxx
@@ -166,8 +166,9 @@ sal_uInt32 XclExpSstImpl::Insert( XclExpStringRef xString )
     return nSstIndex;
 }
 
-void XclExpSstImpl::Save( XclExpStream& rStrm )
+void XclExpSstImpl::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( maStringList.empty() )
         return;
 
@@ -257,6 +258,7 @@ void XclExpSstImpl::Save( XclExpStream& rStrm )
     rStrm.CopyFromStream( aExtSst );
 
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 void XclExpSstImpl::SaveXml( XclExpXmlStream& rStrm )
@@ -306,9 +308,11 @@ sal_uInt32 XclExpSst::Insert( XclExpStringRef xString )
     return mxImpl->Insert( xString );
 }
 
-void XclExpSst::Save( XclExpStream& rStrm )
+void XclExpSst::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpSst::SaveXml( XclExpXmlStream& rStrm )
@@ -343,8 +347,9 @@ sal_uInt32 XclExpMergedcells::GetBaseXFId( const ScAddress& rPos ) const
     return EXC_XFID_NOTFOUND;
 }
 
-void XclExpMergedcells::Save( XclExpStream& rStrm )
+void XclExpMergedcells::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( GetBiff() == EXC_BIFF8 )
     {
         XclRangeList aXclRanges;
@@ -361,6 +366,7 @@ void XclExpMergedcells::Save( XclExpStream& rStrm )
             nRemainingRanges -= nRangeCount;
         }
     }
+#endif // xlsx
 }
 
 void XclExpMergedcells::SaveXml( XclExpXmlStream& rStrm )
@@ -397,15 +403,19 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
     INetURLObject aUrlObj( rUrl );
     const INetProtocol eProtocol = aUrlObj.GetProtocol();
     bool bWithRepr = rRepr.Len() > 0;
+#if 0 // xlsx
     XclExpStream aXclStrm( *mxVarData, rRoot );         // using in raw write mode.
+#endif // xlsx
 
     // description
     if( bWithRepr )
     {
         XclExpString aDescr( rRepr, EXC_STR_FORCEUNICODE, 255 );
+#if 0 // xlsx
         aXclStrm << sal_uInt32( aDescr.Len() + 1 );     // string length + 1 trailing zero word
         aDescr.WriteBuffer( aXclStrm );                 // NO flags
         aXclStrm << sal_uInt16( 0 );
+#endif // xlsx
 
         mnFlags |= EXC_HLINK_DESCR;
         mxRepr.reset( new String( rRepr ) );
@@ -432,6 +442,7 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
 
         ByteString aAsciiLink( aFileName, rRoot.GetTextEncoding() );
         XclExpString aLink( aFileName, EXC_STR_FORCEUNICODE, 255 );
+#if 0 // xlsx
         aXclStrm    << XclTools::maGuidFileMoniker
                     << nLevel
                     << sal_uInt32( aAsciiLink.Len() + 1 );      // string length + 1 trailing zero byte
@@ -443,6 +454,7 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
                     << sal_uInt32( aLink.GetBufferSize() )      // byte count, not string length
                     << sal_uInt16( 0x0003 );
         aLink.WriteBuffer( aXclStrm );                          // NO flags
+#endif // xlsx
 
         if( !mxRepr.get() )
             mxRepr.reset( new String( aFileName ) );
@@ -452,10 +464,12 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
     else if( eProtocol != INET_PROT_NOT_VALID )
     {
         XclExpString aUrl( aUrlObj.GetURLNoMark(), EXC_STR_FORCEUNICODE, 255 );
+#if 0 // xlsx
         aXclStrm    << XclTools::maGuidUrlMoniker
                     << sal_uInt32( aUrl.GetBufferSize() + 2 );  // byte count + 1 trailing zero word
         aUrl.WriteBuffer( aXclStrm );                           // NO flags
         aXclStrm    << sal_uInt16( 0 );
+#endif // xlsx
 
         mnFlags |= EXC_HLINK_BODY | EXC_HLINK_ABS;
         if( !mxRepr.get() )
@@ -476,9 +490,11 @@ XclExpHyperlink::XclExpHyperlink( const XclExpRoot& rRoot, const SvxURLField& rU
 
     if( mxTextMark.get() )
     {
+#if 0 // xlsx
         aXclStrm    << sal_uInt32( mxTextMark->Len() + 1 );  // string length + 1 trailing zero word
         mxTextMark->WriteBuffer( aXclStrm );                 // NO flags
         aXclStrm    << sal_uInt16( 0 );
+#endif // xlsx
 
         mnFlags |= EXC_HLINK_MARK;
     }
@@ -523,22 +539,26 @@ String XclExpHyperlink::BuildFileName(
     return aDosName;
 }
 
-void XclExpHyperlink::WriteBody( XclExpStream& rStrm )
+void XclExpHyperlink::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( maScPos.Col() );
     sal_uInt16 nXclRow = static_cast< sal_uInt16 >( maScPos.Row() );
     rStrm   << nXclRow << nXclRow << nXclCol << nXclCol;
     WriteEmbeddedData( rStrm );
+#endif // xlsx
 }
 
-void XclExpHyperlink::WriteEmbeddedData( XclExpStream& rStrm )
+void XclExpHyperlink::WriteEmbeddedData( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << XclTools::maGuidStdLink
             << sal_uInt32( 2 )
             << mnFlags;
 
     mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( *mxVarData );
+#endif // xlsx
 }
 
 void XclExpHyperlink::SaveXml( XclExpXmlStream& rStrm )
@@ -585,8 +605,9 @@ void XclExpLabelranges::FillRangeList( ScRangeList& rScRanges,
     }
 }
 
-void XclExpLabelranges::Save( XclExpStream& rStrm )
+void XclExpLabelranges::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclExpAddressConverter& rAddrConv = GetAddressConverter();
     XclRangeList aRowXclRanges, aColXclRanges;
     rAddrConv.ConvertRangeList( aRowXclRanges, maRowRanges, false );
@@ -597,6 +618,7 @@ void XclExpLabelranges::Save( XclExpStream& rStrm )
         rStrm << aRowXclRanges << aColXclRanges;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
 // Conditional formatting  ====================================================
@@ -716,8 +738,9 @@ XclExpCFImpl::XclExpCFImpl( const XclExpRoot& rRoot, const ScCondFormatEntry& rF
     }
 }
 
-void XclExpCFImpl::WriteBody( XclExpStream& rStrm )
+void XclExpCFImpl::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // *** mode and comparison operator ***
 
     rStrm << mnType << mnOperator;
@@ -806,6 +829,7 @@ void XclExpCFImpl::WriteBody( XclExpStream& rStrm )
         mxTokArr1->WriteArray( rStrm );
     if( mxTokArr2.get() )
         mxTokArr2->WriteArray( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -821,9 +845,11 @@ XclExpCF::~XclExpCF()
 {
 }
 
-void XclExpCF::WriteBody( XclExpStream& rStrm )
+void XclExpCF::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->WriteBody( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -853,17 +879,20 @@ bool XclExpCondfmt::IsValid() const
     return !maCFList.IsEmpty() && !maXclRanges.empty();
 }
 
-void XclExpCondfmt::Save( XclExpStream& rStrm )
+void XclExpCondfmt::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( IsValid() )
     {
         XclExpRecord::Save( rStrm );
         maCFList.Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpCondfmt::WriteBody( XclExpStream& rStrm )
+void XclExpCondfmt::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( !maCFList.IsEmpty(), "XclExpCondfmt::WriteBody - no CF records to write" );
     DBG_ASSERT( !maXclRanges.empty(), "XclExpCondfmt::WriteBody - no cell ranges found" );
 
@@ -871,6 +900,7 @@ void XclExpCondfmt::WriteBody( XclExpStream& rStrm )
             << sal_uInt16( 1 )
             << maXclRanges.GetEnclosingRange()
             << maXclRanges;
+#endif // xlsx
 }
 
 void XclExpCondfmt::SaveXml( XclExpXmlStream& rStrm )
@@ -911,9 +941,11 @@ XclExpCondFormatBuffer::XclExpCondFormatBuffer( const XclExpRoot& rRoot ) :
     }
 }
 
-void XclExpCondFormatBuffer::Save( XclExpStream& rStrm )
+void XclExpCondFormatBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maCondfmtList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpCondFormatBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -926,22 +958,26 @@ void XclExpCondFormatBuffer::SaveXml( XclExpXmlStream& rStrm )
 namespace {
 
 /** Writes a formula for the DV record. */
-void lclWriteDvFormula( XclExpStream& rStrm, const XclTokenArray* pXclTokArr )
+void lclWriteDvFormula( XclExpStream& /*rStrm*/, const XclTokenArray* /*pXclTokArr*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nFmlaSize = pXclTokArr ? pXclTokArr->GetSize() : 0;
     rStrm << nFmlaSize << sal_uInt16( 0 );
     if( pXclTokArr )
         pXclTokArr->WriteArray( rStrm );
+#endif // xlsx
 }
 
 /** Writes a formula for the DV record, based on a single string. */
-void lclWriteDvFormula( XclExpStream& rStrm, const XclExpString& rString )
+void lclWriteDvFormula( XclExpStream& /*rStrm*/, const XclExpString& /*rString*/ )
 {
+#if 0 // xlsx
     // fake a formula with a single tStr token
     rStrm   << static_cast< sal_uInt16 >( rString.GetSize() + 1 )
             << sal_uInt16( 0 )
             << EXC_TOKID_STR
             << rString;
+#endif // xlsx
 }
 
 const char* lcl_GetValidationType( sal_uInt32 nFlags )
@@ -1146,8 +1182,9 @@ bool XclExpDV::Finalize()
     return (mnScHandle != ULONG_MAX) && !maXclRanges.empty();
 }
 
-void XclExpDV::WriteBody( XclExpStream& rStrm )
+void XclExpDV::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // flags and strings
     rStrm << mnFlags << maPromptTitle << maErrorTitle << maPromptText << maErrorText;
     // condition formulas
@@ -1158,6 +1195,7 @@ void XclExpDV::WriteBody( XclExpStream& rStrm )
     lclWriteDvFormula( rStrm, mxTokArr2.get() );
     // cell ranges
     rStrm << maXclRanges;
+#endif // xlsx
 }
 
 void XclExpDV::SaveXml( XclExpXmlStream& rStrm )
@@ -1214,8 +1252,9 @@ void XclExpDval::InsertCellRange( const ScRange& rRange, ULONG nScHandle )
     }
 }
 
-void XclExpDval::Save( XclExpStream& rStrm )
+void XclExpDval::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // check all records
     size_t nPos = maDVList.GetSize();
     while( nPos )
@@ -1232,6 +1271,7 @@ void XclExpDval::Save( XclExpStream& rStrm )
         XclExpRecord::Save( rStrm );
         maDVList.Save( rStrm );
     }
+#endif // xlsx
 }
 
 void XclExpDval::SaveXml( XclExpXmlStream& rStrm )
@@ -1290,10 +1330,12 @@ XclExpDV& XclExpDval::SearchOrCreateDv( ULONG nScHandle )
     return *mxLastFoundDV;
 }
 
-void XclExpDval::WriteBody( XclExpStream& rStrm )
+void XclExpDval::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm.WriteZeroBytes( 10 );
     rStrm << EXC_DVAL_NOOBJ << static_cast< sal_uInt32 >( maDVList.GetSize() );
+#endif // xlsx
 }
 
 // Web Queries ================================================================
@@ -1336,8 +1378,9 @@ XclExpWebQuery::~XclExpWebQuery()
 {
 }
 
-void XclExpWebQuery::Save( XclExpStream& rStrm )
+void XclExpWebQuery::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( !mbEntireDoc || !mxQryTables.get(), "XclExpWebQuery::Save - illegal mode" );
     sal_uInt16 nFlags;
 
@@ -1401,6 +1444,7 @@ void XclExpWebQuery::Save( XclExpStream& rStrm )
                 << *mxQryTables;            // comma separated list of source tables
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
diff --git sc/source/filter/xlsx/xlsx-xeescher.cxx sc/source/filter/xlsx/xlsx-xeescher.cxx
index 918e491..e224fc2 100644
--- sc/source/filter/xlsx/xlsx-xeescher.cxx
+++ sc/source/filter/xlsx/xlsx-xeescher.cxx
@@ -102,8 +102,9 @@ XclExpImgData::XclExpImgData( const Graphic& rGraphic, sal_uInt16 nRecId ) :
 {
 }
 
-void XclExpImgData::Save( XclExpStream& rStrm )
+void XclExpImgData::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     Bitmap aBmp = maGraphic.GetBitmap();
     if( aBmp.GetBitCount() != 24 )
         aBmp.Convert( BMP_CONVERSION_24BIT );
@@ -142,6 +143,7 @@ void XclExpImgData::Save( XclExpStream& rStrm )
         }
         aBmp.ReleaseAccess( pAccess );
     }
+#endif // xlsx
 }
 
 void XclExpImgData::SaveXml( XclExpXmlStream& rStrm )
@@ -220,20 +222,24 @@ void XclExpControlHelper::ConvertSheetLinks( Reference< XShape > xShape )
     }
 }
 
-void XclExpControlHelper::WriteFormula( XclExpStream& rStrm, const XclTokenArray& rTokArr ) const
+void XclExpControlHelper::WriteFormula( XclExpStream& /*rStrm*/, const XclTokenArray& /*rTokArr*/ ) const
 {
+#if 0 // xlsx
     sal_uInt16 nFmlaSize = rTokArr.GetSize();
     rStrm << nFmlaSize << sal_uInt32( 0 );
     rTokArr.WriteArray( rStrm );
     if( nFmlaSize & 1 )             // pad to 16-bit
         rStrm << sal_uInt8( 0 );
+#endif // xlsx
 }
 
-void XclExpControlHelper::WriteFormulaSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId, const XclTokenArray& rTokArr ) const
+void XclExpControlHelper::WriteFormulaSubRec( XclExpStream& /*rStrm*/, sal_uInt16 /*nSubRecId*/, const XclTokenArray& /*rTokArr*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( nSubRecId, (rTokArr.GetSize() + 5) & ~1 );
     WriteFormula( rStrm, rTokArr );
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -296,8 +302,9 @@ XclExpOcxControlObj::XclExpOcxControlObj( const XclExpRoot& rRoot, Reference< XS
     ConvertSheetLinks( xShape );
 }
 
-void XclExpOcxControlObj::WriteSubRecs( XclExpStream& rStrm )
+void XclExpOcxControlObj::WriteSubRecs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // OBJCF - clipboard format
     rStrm.StartRecord( EXC_ID_OBJCF, 2 );
     rStrm << sal_uInt16( 2 );
@@ -343,6 +350,7 @@ void XclExpOcxControlObj::WriteSubRecs( XclExpStream& rStrm )
         WriteFormula( rStrm, *pSrcRange );
 
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 #else
@@ -613,8 +621,9 @@ bool XclExpTbxControlObj::SetMacroLink( const ScriptEventDescriptor& rEvent )
 */
 }
 
-void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
+void XclExpTbxControlObj::WriteSubRecs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( mnObjType )
     {
         // *** Push buttons, labels ***
@@ -749,16 +758,20 @@ void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
         }
         break;
     }
+#endif // xlsx
 }
 
-void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId )
+void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& /*rStrm*/, sal_uInt16 /*nSubRecId*/ )
 {
+#if 0 // xlsx
     if( const XclTokenArray* pCellLink = GetCellLinkTokArr() )
         WriteFormulaSubRec( rStrm, nSubRecId, *pCellLink );
+#endif // xlsx
 }
 
-void XclExpTbxControlObj::WriteSbs( XclExpStream& rStrm )
+void XclExpTbxControlObj::WriteSbs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nOrient = 0;
     ::set_flag( nOrient, EXC_OBJ_SCROLLBAR_HOR, mbScrollHor );
     sal_uInt16 nStyle = EXC_OBJ_SCROLLBAR_DEFFLAGS;
@@ -775,6 +788,7 @@ void XclExpTbxControlObj::WriteSbs( XclExpStream& rStrm )
             << sal_uInt16( 15 )             // thumb width
             << nStyle;                      // flags/style
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 #endif
@@ -830,12 +844,14 @@ XclExpChartObj::~XclExpChartObj()
 {
 }
 
-void XclExpChartObj::Save( XclExpStream& rStrm )
+void XclExpChartObj::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // content of OBJ record
     XclObj::Save( rStrm );
     // chart substream
     mxChart->Save( rStrm );
+#endif // xlsx
 }
 
 // ============================================================================
@@ -878,8 +894,9 @@ XclExpNote::XclExpNote( const XclExpRoot& rRoot, const ScAddress& rScPos,
     }
 }
 
-void XclExpNote::Save( XclExpStream& rStrm )
+void XclExpNote::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( rStrm.GetRoot().GetBiff() )
     {
         case EXC_BIFF5:
@@ -923,11 +940,13 @@ void XclExpNote::Save( XclExpStream& rStrm )
 
         default:    DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 
-void XclExpNote::WriteBody( XclExpStream& rStrm )
+void XclExpNote::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // BIFF5/BIFF7 is written separately
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() == EXC_BIFF8 );
 
@@ -940,6 +959,7 @@ void XclExpNote::WriteBody( XclExpStream& rStrm )
             << mnObjId
             << maAuthor
             << sal_uInt8( 0 );
+#endif // xlsx
 }
 
 void XclExpNote::WriteXml( sal_Int32 nAuthorId, XclExpXmlStream& rStrm )
@@ -976,10 +996,12 @@ XclMacroHelper::~XclMacroHelper()
 {
 }
 
-void XclMacroHelper::WriteMacroSubRec( XclExpStream& rStrm )
+void XclMacroHelper::WriteMacroSubRec( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mxMacroLink.is() )
         WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
+#endif // xlsx
 }
 
 bool 
@@ -1023,10 +1045,12 @@ XclExpShapeObj::~XclExpShapeObj()
 {
 }
 
-void XclExpShapeObj::WriteSubRecs( XclExpStream& rStrm )
+void XclExpShapeObj::WriteSubRecs( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclObjAny::WriteSubRecs( rStrm );
     WriteMacroSubRec( rStrm );
+#endif // xlsx
 }
 
 // ============================================================================
diff --git sc/source/filter/xlsx/xlsx-xeformula.cxx sc/source/filter/xlsx/xlsx-xeformula.cxx
index 849ac08..7f71543 100644
--- sc/source/filter/xlsx/xlsx-xeformula.cxx
+++ sc/source/filter/xlsx/xlsx-xeformula.cxx
@@ -1835,7 +1835,7 @@ void XclExpFmlaCompImpl::ConvertRefData(
             rnScRow = mnMaxAbsRow;
         else if( (rnScRow < 0) || (rnScRow > mnMaxAbsRow) )
             rRefData.SetRowDeleted( TRUE );
-        rXclPos.mnRow = static_cast< sal_uInt16 >( rnScRow ) & mnMaxRowMask;
+        rXclPos.mnRow = static_cast< sal_uInt32 >( rnScRow ) & mnMaxRowMask;
     }
     else
     {
@@ -1847,7 +1847,7 @@ void XclExpFmlaCompImpl::ConvertRefData(
 
         // convert row index (2-step-cast ScsROW->sal_Int16->sal_uInt16 to get all bits correctly)
         sal_Int16 nXclRelRow = static_cast< sal_Int16 >( rRefData.IsRowRel() ? rRefData.nRelRow : rRefData.nRow );
-        rXclPos.mnRow = static_cast< sal_uInt16 >( nXclRelRow ) & mnMaxRowMask;
+        rXclPos.mnRow = static_cast< sal_uInt32 >( nXclRelRow ) & mnMaxRowMask;
 
         // resolve relative tab index if possible
         if( rRefData.IsTabRel() && !IsInGlobals() && (GetCurrScTab() < GetDoc().GetTableCount()) )
@@ -1863,9 +1863,11 @@ void XclExpFmlaCompImpl::ConvertRefData(
     }
     else
     {
+#if 0 // FIXME : doesn't build in xlsx
         sal_uInt16& rnRelField = (meBiff <= EXC_BIFF5) ? rXclPos.mnRow : rXclPos.mnCol;
         ::set_flag( rnRelField, EXC_TOK_REF_COLREL, rRefData.IsColRel() );
         ::set_flag( rnRelField, EXC_TOK_REF_ROWREL, rRefData.IsRowRel() );
+#endif
     }
 }
 
diff --git sc/source/filter/xlsx/xlsx-xehelper.cxx sc/source/filter/xlsx/xlsx-xehelper.cxx
index 54043ce..53bd290 100644
--- sc/source/filter/xlsx/xlsx-xehelper.cxx
+++ sc/source/filter/xlsx/xlsx-xehelper.cxx
@@ -159,7 +159,7 @@ namespace {
 inline void lclFillAddress( XclAddress& rXclPos, SCCOL nScCol, SCROW nScRow )
 {
     rXclPos.mnCol = static_cast< sal_uInt16 >( nScCol );
-    rXclPos.mnRow = static_cast< sal_uInt16 >( nScRow );
+    rXclPos.mnRow = static_cast< sal_uInt32 >( nScRow );
 }
 
 } // namespace
diff --git sc/source/filter/xlsx/xlsx-xename.cxx sc/source/filter/xlsx/xlsx-xename.cxx
index f04c4e4..6b3e91c 100644
--- sc/source/filter/xlsx/xlsx-xename.cxx
+++ sc/source/filter/xlsx/xlsx-xename.cxx
@@ -310,12 +310,14 @@ bool XclExpName::IsMacroCall( bool bVBasic, bool bFunc ) const
         (::get_flag( mnFlags, EXC_NAME_FUNC ) == bFunc);
 }
 
-void XclExpName::Save( XclExpStream& rStrm )
+void XclExpName::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( mxName.is() && (mxName->Len() > 0), "XclExpName::Save - missing name" );
     DBG_ASSERT( !(IsGlobal() && ::get_flag( mnFlags, EXC_NAME_BUILTIN )), "XclExpName::Save - global built-in name" );
     SetRecSize( 11 + mxName->GetSize() + (mxTokArr.is() ? mxTokArr->GetSize() : 2) );
     XclExpRecord::Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpName::SaveXml( XclExpXmlStream& rStrm )
@@ -346,8 +348,9 @@ void XclExpName::SaveXml( XclExpXmlStream& rStrm )
     rWorkbook->endElement( XML_definedName );
 }
 
-void XclExpName::WriteBody( XclExpStream& rStrm )
+void XclExpName::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nFmlaSize = mxTokArr.is() ? mxTokArr->GetSize() : 0;
 
     rStrm   << mnFlags                  // flags
@@ -361,6 +364,7 @@ void XclExpName::WriteBody( XclExpStream& rStrm )
     mxName->WriteBuffer( rStrm );       // character array of the name
     if( mxTokArr.is() )
         mxTokArr->WriteArray( rStrm );  // token array without size
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -467,9 +471,11 @@ const XclExpName* XclExpNameManagerImpl::GetName( sal_uInt16 nNameIdx ) const
     return maNameList.GetRecord( nNameIdx - 1 ).get();
 }
 
-void XclExpNameManagerImpl::Save( XclExpStream& rStrm )
+void XclExpNameManagerImpl::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maNameList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpNameManagerImpl::SaveXml( XclExpXmlStream& rStrm )
@@ -780,9 +786,11 @@ bool XclExpNameManager::IsVolatile( sal_uInt16 nNameIdx ) const
     return pName && pName->IsVolatile();
 }
 
-void XclExpNameManager::Save( XclExpStream& rStrm )
+void XclExpNameManager::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpNameManager::SaveXml( XclExpXmlStream& rStrm )
diff --git sc/source/filter/xlsx/xlsx-xepivot.cxx sc/source/filter/xlsx/xlsx-xepivot.cxx
index 66a885e..e509ce7 100644
--- sc/source/filter/xlsx/xlsx-xepivot.cxx
+++ sc/source/filter/xlsx/xlsx-xepivot.cxx
@@ -173,8 +173,9 @@ bool XclExpPCItem::EqualsBool( bool bValue ) const
 
 // ----------------------------------------------------------------------------
 
-void XclExpPCItem::WriteBody( XclExpStream& rStrm )
+void XclExpPCItem::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( const String* pText = GetText() )
     {
         rStrm << XclExpString( *pText );
@@ -207,6 +208,7 @@ void XclExpPCItem::WriteBody( XclExpStream& rStrm )
         // nothing to do for SXEMPTY
         DBG_ASSERT( IsEmpty(), "XclExpPCItem::WriteBody - no data found" );
     }
+#endif // xlsx
 }
 
 // ============================================================================
@@ -309,8 +311,9 @@ sal_Size XclExpPCField::GetIndexSize() const
     return Has16BitIndexes() ? 2 : 1;
 }
 
-void XclExpPCField::WriteIndex( XclExpStream& rStrm, sal_uInt32 nSrcRow ) const
+void XclExpPCField::WriteIndex( XclExpStream& /*rStrm*/, sal_uInt32 /*nSrcRow*/ ) const
 {
+#if 0 // xlsx
     // only standard fields write item indexes
     if( nSrcRow < maIndexVec.size() )
     {
@@ -320,10 +323,12 @@ void XclExpPCField::WriteIndex( XclExpStream& rStrm, sal_uInt32 nSrcRow ) const
         else
             rStrm << static_cast< sal_uInt8 >( nIndex );
     }
+#endif // xlsx
 }
 
-void XclExpPCField::Save( XclExpStream& rStrm )
+void XclExpPCField::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( IsSupportedField(), "XclExpPCField::Save - unknown field type" );
     // SXFIELD
     XclExpRecord::Save( rStrm );
@@ -337,6 +342,7 @@ void XclExpPCField::Save( XclExpStream& rStrm )
     WriteSxnumgroup( rStrm );
     // list of original items
     maOrigItemList.Save( rStrm );
+#endif // xlsx
 }
 
 // private --------------------------------------------------------------------
@@ -591,8 +597,9 @@ void XclExpPCField::Finalize()
     maFieldInfo.mnOrigItems = static_cast< sal_uInt16 >( maOrigItemList.GetSize() );
 }
 
-void XclExpPCField::WriteSxnumgroup( XclExpStream& rStrm )
+void XclExpPCField::WriteSxnumgroup( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( IsNumGroupField() || IsDateGroupField() )
     {
         // SXNUMGROUP record
@@ -605,10 +612,12 @@ void XclExpPCField::WriteSxnumgroup( XclExpStream& rStrm )
             "XclExpPCField::WriteSxnumgroup - missing numeric grouping limits" );
         maNumGroupLimits.Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpPCField::WriteSxgroupinfo( XclExpStream& rStrm )
+void XclExpPCField::WriteSxgroupinfo( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( IsStdGroupField() != maGroupOrder.empty(),
         "XclExpPCField::WriteSxgroupinfo - missing grouping info" );
     if( IsStdGroupField() && !maGroupOrder.empty() )
@@ -618,11 +627,14 @@ void XclExpPCField::WriteSxgroupinfo( XclExpStream& rStrm )
             rStrm << *aIt;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPCField::WriteBody( XclExpStream& rStrm )
+void XclExpPCField::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maFieldInfo;
+#endif // xlsx
 }
 
 // ============================================================================
@@ -726,8 +738,9 @@ bool XclExpPivotCache::HasEqualDataSource( const ScDPObject& rDPObj ) const
     return false;
 }
 
-void XclExpPivotCache::Save( XclExpStream& rStrm )
+void XclExpPivotCache::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( mbValid, "XclExpPivotCache::Save - invalid pivot cache" );
     // SXIDSTM
     XclExpUInt16Record( EXC_ID_SXIDSTM, maPCInfo.mnStrmId ).Save( rStrm );
@@ -737,6 +750,7 @@ void XclExpPivotCache::Save( XclExpStream& rStrm )
     WriteDconref( rStrm );
     // create the pivot cache storage stream
     WriteCacheStream();
+#endif // xlsx
 }
 
 void XclExpPivotCache::SaveXml( XclExpXmlStream& rStrm )
@@ -843,8 +857,9 @@ void XclExpPivotCache::AddCalcFields( const ScDPObject& /*rDPObj*/ )
     // not supported
 }
 
-void XclExpPivotCache::WriteDconref( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteDconref( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     XclExpString aRef( XclExpUrlHelper::EncodeUrl( GetRoot(), EMPTY_STRING, &maTabName ) );
     rStrm.StartRecord( EXC_ID_DCONREF, 7 + aRef.GetSize() );
     rStrm   << static_cast< sal_uInt16 >( maExpSrcRange.aStart.Row() )
@@ -854,10 +869,12 @@ void XclExpPivotCache::WriteDconref( XclExpStream& rStrm ) const
             << aRef
             << sal_uInt8( 0 );
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 void XclExpPivotCache::WriteCacheStream()
 {
+#if 0 // xlsx
     SotStorageRef xSvStrg = OpenStorage( EXC_STORAGE_PTCACHE );
     SotStorageStreamRef xSvStrm = OpenStream( xSvStrg, ScfTools::GetHexStr( maPCInfo.mnStrmId ) );
     if( xSvStrm.Is() )
@@ -874,25 +891,31 @@ void XclExpPivotCache::WriteCacheStream()
         // EOF
         XclExpEmptyRecord( EXC_ID_EOF ).Save( aStrm );
     }
+#endif // xlsx
 }
 
-void XclExpPivotCache::WriteSxdb( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteSxdb( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXDB, 21 );
     rStrm << maPCInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotCache::WriteSxdbex( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteSxdbex( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXDBEX, 12 );
     rStrm   << EXC_SXDBEX_CREATION_DATE
             << sal_uInt32( 0 );             // number of SXFORMULA records
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotCache::WriteSxindexlistList( XclExpStream& rStrm ) const
+void XclExpPivotCache::WriteSxindexlistList( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( HasItemIndexList() )
     {
         sal_Size nRecSize = 0;
@@ -908,6 +931,7 @@ void XclExpPivotCache::WriteSxindexlistList( XclExpStream& rStrm ) const
             rStrm.EndRecord();
         }
     }
+#endif // xlsx
 }
 
 // ============================================================================
@@ -986,9 +1010,11 @@ void XclExpPTItem::SetPropertiesFromMember( const ScDPSaveMember& rSaveMem )
         maItemInfo.SetVisName(*pVisName);
 }
 
-void XclExpPTItem::WriteBody( XclExpStream& rStrm )
+void XclExpPTItem::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << maItemInfo;
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1191,13 +1217,16 @@ void XclExpPTField::AppendSubtotalItems()
 
 // records --------------------------------------------------------------------
 
-void XclExpPTField::WriteSxpiEntry( XclExpStream& rStrm ) const
+void XclExpPTField::WriteSxpiEntry( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm << maPageInfo;
+#endif // xlsx
 }
 
-void XclExpPTField::WriteSxdi( XclExpStream& rStrm, sal_uInt16 nDataInfoIdx ) const
+void XclExpPTField::WriteSxdi( XclExpStream& /*rStrm*/, sal_uInt16 /*nDataInfoIdx*/ ) const
 {
+#if 0 // xlsx
     DBG_ASSERT( nDataInfoIdx < maDataInfoVec.size(), "XclExpPTField::WriteSxdi - data field not found" );
     if( nDataInfoIdx < maDataInfoVec.size() )
     {
@@ -1205,16 +1234,19 @@ void XclExpPTField::WriteSxdi( XclExpStream& rStrm, sal_uInt16 nDataInfoIdx ) co
         rStrm << maDataInfoVec[ nDataInfoIdx ];
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPTField::Save( XclExpStream& rStrm )
+void XclExpPTField::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // SXVD
     WriteSxvd( rStrm );
     // list of SXVI records
     maItemList.Save( rStrm );
     // SXVDEX
     WriteSxvdex( rStrm );
+#endif // xlsx
 }
 
 // private --------------------------------------------------------------------
@@ -1234,18 +1266,22 @@ void XclExpPTField::AppendSubtotalItem( sal_uInt16 nItemType )
     ++maFieldInfo.mnItemCount;
 }
 
-void XclExpPTField::WriteSxvd( XclExpStream& rStrm ) const
+void XclExpPTField::WriteSxvd( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXVD, 10 );
     rStrm << maFieldInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPTField::WriteSxvdex( XclExpStream& rStrm ) const
+void XclExpPTField::WriteSxvdex( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXVDEX, 20 );
     rStrm << maFieldExtInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1329,8 +1365,9 @@ sal_uInt16 XclExpPivotTable::GetDataFieldIndex( const String& rName, sal_uInt16
     return nDefaultIdx;
 }
 
-void XclExpPivotTable::Save( XclExpStream& rStrm )
+void XclExpPivotTable::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mbValid )
     {
         // SXVIEW
@@ -1354,6 +1391,7 @@ void XclExpPivotTable::Save( XclExpStream& rStrm )
         // SXVIEWEX9
         WriteSxViewEx9( rStrm );
     }
+#endif // xlsx
 }
 
 void XclExpPivotTable::SaveXml( XclExpXmlStream& rStrm )
@@ -1626,9 +1664,9 @@ void XclExpPivotTable::Finalize()
 
     // update output range (initialized in ctor)
     sal_uInt16& rnXclCol1 = maPTInfo.maOutXclRange.maFirst.mnCol;
-    sal_uInt16& rnXclRow1 = maPTInfo.maOutXclRange.maFirst.mnRow;
+    sal_uInt32& rnXclRow1 = maPTInfo.maOutXclRange.maFirst.mnRow;
     sal_uInt16& rnXclCol2 = maPTInfo.maOutXclRange.maLast.mnCol;
-    sal_uInt16& rnXclRow2 = maPTInfo.maOutXclRange.maLast.mnRow;
+    sal_uInt32& rnXclRow2 = maPTInfo.maOutXclRange.maLast.mnRow;
     // exclude page fields from output range
     rnXclRow1 = rnXclRow1 + maPTInfo.mnPageFields;
     // exclude filter button from output range
@@ -1640,7 +1678,7 @@ void XclExpPivotTable::Finalize()
 
     // data area
     sal_uInt16& rnDataXclCol = maPTInfo.maDataXclPos.mnCol;
-    sal_uInt16& rnDataXclRow = maPTInfo.maDataXclPos.mnRow;
+    sal_uInt32& rnDataXclRow = maPTInfo.maDataXclPos.mnRow;
     rnDataXclCol = rnXclCol1 + maPTInfo.mnRowFields;
     rnDataXclRow = rnXclRow1 + maPTInfo.mnColFields + 1;
     if( maDataFields.empty() )
@@ -1664,15 +1702,18 @@ void XclExpPivotTable::Finalize()
 
 // records ----------------------------------------------------------------
 
-void XclExpPivotTable::WriteSxview( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxview( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXVIEW, 46 + maPTInfo.maTableName.Len() + maPTInfo.maDataName.Len() );
     rStrm << maPTInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxivd( XclExpStream& rStrm, const ScfUInt16Vec& rFields ) const
+void XclExpPivotTable::WriteSxivd( XclExpStream& /*rStrm*/, const ScfUInt16Vec& /*rFields*/ ) const
 {
+#if 0 // xlsx
     if( !rFields.empty() )
     {
         rStrm.StartRecord( EXC_ID_SXIVD, rFields.size() * 2 );
@@ -1680,10 +1721,12 @@ void XclExpPivotTable::WriteSxivd( XclExpStream& rStrm, const ScfUInt16Vec& rFie
             rStrm << *aIt;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxpi( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxpi( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( !maPageFields.empty() )
     {
         rStrm.StartRecord( EXC_ID_SXPI, maPageFields.size() * 6 );
@@ -1696,20 +1739,24 @@ void XclExpPivotTable::WriteSxpi( XclExpStream& rStrm ) const
         }
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxdiList( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxdiList( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     for( XclPTDataFieldPosVec::const_iterator aIt = maDataFields.begin(), aEnd = maDataFields.end(); aIt != aEnd; ++aIt )
     {
         XclExpPTFieldRef xField = maFieldList.GetRecord( aIt->first );
         if( xField.is() )
             xField->WriteSxdi( rStrm, aIt->second );
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxli( XclExpStream& rStrm, sal_uInt16 nLineCount, sal_uInt16 nIndexCount ) const
+void XclExpPivotTable::WriteSxli( XclExpStream& /*rStrm*/, sal_uInt16 /*nLineCount*/, sal_uInt16 /*nIndexCount*/ ) const
 {
+#if 0 // xlsx
     if( nLineCount > 0 )
     {
         sal_uInt16 nLineSize = 8 + 2 * nIndexCount;
@@ -1730,17 +1777,21 @@ void XclExpPivotTable::WriteSxli( XclExpStream& rStrm, sal_uInt16 nLineCount, sa
         }
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxex( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxex( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( EXC_ID_SXEX, 24 );
     rStrm << maPTExtInfo;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteQsiSxTag( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteQsiSxTag( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     rStrm.StartRecord( 0x0802, 32 );
 
     sal_uInt16 nRecordType = 0x0802;
@@ -1791,10 +1842,12 @@ void XclExpPivotTable::WriteQsiSxTag( XclExpStream& rStrm ) const
     rStrm << static_cast<sal_uInt16>(0x0001); // no idea what this is for.
 
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpPivotTable::WriteSxViewEx9( XclExpStream& rStrm ) const
+void XclExpPivotTable::WriteSxViewEx9( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     // Until we sync the autoformat ids only export if using grid header layout
     // That could only have been set via xls import so far.
     if ( 0 == maPTViewEx9Info.mnGridLayout )
@@ -1803,6 +1856,7 @@ void XclExpPivotTable::WriteSxViewEx9( XclExpStream& rStrm ) const
         rStrm << maPTViewEx9Info;
         rStrm.EndRecord();
     }
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1829,12 +1883,14 @@ XclExpPivotRecWrapper::XclExpPivotRecWrapper( XclExpPivotTableManager& rPTMgr, S
 {
 }
 
-void XclExpPivotRecWrapper::Save( XclExpStream& rStrm )
+void XclExpPivotRecWrapper::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mnScTab == EXC_PTMGR_PIVOTCACHES )
         mrPTMgr.WritePivotCaches( rStrm );
     else
         mrPTMgr.WritePivotTables( rStrm, mnScTab );
+#endif // xlsx
 }
 
 void XclExpPivotRecWrapper::SaveXml( XclExpXmlStream& rStrm )
@@ -1874,9 +1930,11 @@ XclExpRecordRef XclExpPivotTableManager::CreatePivotTablesRecord( SCTAB nScTab )
     return XclExpRecordRef( new XclExpPivotRecWrapper( *this, nScTab ) );
 }
 
-void XclExpPivotTableManager::WritePivotCaches( XclExpStream& rStrm )
+void XclExpPivotTableManager::WritePivotCaches( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maPCacheList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpPivotTableManager::WritePivotCachesXml( XclExpXmlStream& rStrm )
@@ -1892,14 +1950,16 @@ void XclExpPivotTableManager::WritePivotCachesXml( XclExpXmlStream& rStrm )
 #endif /* XLSX_PIVOT_CACHE */
 }
 
-void XclExpPivotTableManager::WritePivotTables( XclExpStream& rStrm, SCTAB nScTab )
+void XclExpPivotTableManager::WritePivotTables( XclExpStream& /*rStrm*/, SCTAB /*nScTab*/ )
 {
+#if 0 // xlsx
     for( size_t nPos = 0, nSize = maPTableList.GetSize(); nPos < nSize; ++nPos )
     {
         XclExpPivotTableRef xPTable = maPTableList.GetRecord( nPos );
         if( xPTable->GetScTab() == nScTab )
             xPTable->Save( rStrm );
     }
+#endif // xlsx
 }
 
 void XclExpPivotTableManager::WritePivotTablesXml( XclExpXmlStream& rStrm, SCTAB nScTab )
diff --git sc/source/filter/xlsx/xlsx-xestream.cxx sc/source/filter/xlsx/xlsx-xestream.cxx
index e79283b..97a3639 100644
--- sc/source/filter/xlsx/xlsx-xestream.cxx
+++ sc/source/filter/xlsx/xlsx-xestream.cxx
@@ -820,8 +862,9 @@ static ScAddress lcl_ToAddress( const XclAddress& rAddress )
     // For some reason, ScRange::Format() returns omits row numbers if
     // the row is >= MAXROW or the column is >= MAXCOL, and Excel doesn't
     // like "A:IV" (i.e. no row numbers).  Prevent this.
-    aAddress.SetRow( std::min<sal_Int32>( rAddress.mnRow, MAXROW-1 ) );
-    aAddress.SetCol( static_cast<sal_Int16>(std::min<sal_Int32>( rAddress.mnCol, MAXCOL-1 )) );
+    // KOHEI: Find out if the above comment is still true.
+    aAddress.SetRow( std::min<sal_Int32>( rAddress.mnRow, MAXROW ) );
+    aAddress.SetCol( static_cast<sal_Int16>(std::min<sal_Int32>( rAddress.mnCol, MAXCOL )) );
 
     return aAddress;
 }
@@ -1134,6 +1178,11 @@ bool XclExpXmlStream::exportDocument() throw()
 
     XclExpRootData aData( EXC_BIFF8, *pShell->GetMedium (), rStorage, *pDoc, RTL_TEXTENCODING_DONTKNOW );
     aData.meOutput = EXC_OUTPUT_XML_2007;
+    aData.maXclMaxPos.Set( EXC_MAXCOL_XML_2007, EXC_MAXROW_XML_2007, EXC_MAXTAB_XML_2007 );
+    aData.maMaxPos.SetCol( ::std::min( aData.maScMaxPos.Col(), aData.maXclMaxPos.Col() ) );
+    aData.maMaxPos.SetRow( ::std::min( aData.maScMaxPos.Row(), aData.maXclMaxPos.Row() ) );
+    aData.maMaxPos.SetTab( ::std::min( aData.maScMaxPos.Tab(), aData.maXclMaxPos.Tab() ) );
+
     XclExpRoot aRoot( aData );
 
     mpRoot = &aRoot;
diff --git sc/source/filter/xlsx/xlsx-xestyle.cxx sc/source/filter/xlsx/xlsx-xestyle.cxx
index d3cecdc..3ce16a0 100644
--- sc/source/filter/xlsx/xlsx-xestyle.cxx
+++ sc/source/filter/xlsx/xlsx-xestyle.cxx
@@ -496,11 +496,13 @@ bool XclExpPaletteImpl::IsDefaultPalette() const
     return bDefault;
 }
 
-void XclExpPaletteImpl::WriteBody( XclExpStream& rStrm )
+void XclExpPaletteImpl::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << static_cast< sal_uInt16 >( maPalette.size() );
     for( XclPaletteColorVec::const_iterator aIt = maPalette.begin(), aEnd = maPalette.end(); aIt != aEnd; ++aIt )
         rStrm << aIt->maColor;
+#endif // xlsx
 }
 
 void XclExpPaletteImpl::SaveXml( XclExpXmlStream& rStrm )
@@ -803,10 +805,12 @@ ColorData XclExpPalette::GetColorData( sal_uInt16 nXclIndex ) const
     return mxImpl->GetColorData( nXclIndex );
 }
 
-void XclExpPalette::Save( XclExpStream& rStrm )
+void XclExpPalette::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( !mxImpl->IsDefaultPalette() )
         XclExpRecord::Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpPalette::SaveXml( XclExpXmlStream& rStrm )
@@ -815,9 +819,11 @@ void XclExpPalette::SaveXml( XclExpXmlStream& rStrm )
         mxImpl->SaveXml( rStrm );
 }
 
-void XclExpPalette::WriteBody( XclExpStream& rStrm )
+void XclExpPalette::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     mxImpl->WriteBody( rStrm );
+#endif // xlsx
 }
 
 // FONT record - font information =============================================
@@ -876,8 +882,9 @@ void XclExpFont::SaveXml( XclExpXmlStream& rStrm )
 
 // private --------------------------------------------------------------------
 
-void XclExpFont::WriteBody( XclExpStream& rStrm )
+void XclExpFont::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nAttr = EXC_FONTATTR_NONE;
     ::set_flag( nAttr, EXC_FONTATTR_ITALIC, maData.mbItalic );
     ::set_flag( nAttr, EXC_FONTATTR_STRIKEOUT, maData.mbStrikeout );
@@ -901,6 +908,7 @@ void XclExpFont::WriteBody( XclExpStream& rStrm )
             << maData.mnCharSet
             << sal_uInt8( 0 )
             << aFontName;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1003,9 +1011,11 @@ sal_uInt16 XclExpFontBuffer::Insert( const ScPatternAttr& rPattern,
     return Insert( rPattern.GetItemSet(), nScript, eColorType, bAppFont );
 }
 
-void XclExpFontBuffer::Save( XclExpStream& rStrm )
+void XclExpFontBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maFontList.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpFontBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -1226,10 +1236,12 @@ sal_uInt16 XclExpNumFmtBuffer::Insert( ULONG nScNumFmt )
     return 0;
 }
 
-void XclExpNumFmtBuffer::Save( XclExpStream& rStrm )
+void XclExpNumFmtBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     for( XclExpNumFmtVec::const_iterator aIt = maFormatMap.begin(), aEnd = maFormatMap.end(); aIt != aEnd; ++aIt )
         WriteFormatRecord( rStrm, *aIt );
+#endif // xlsx
 }
 
 void XclExpNumFmtBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -1251,8 +1263,9 @@ void XclExpNumFmtBuffer::SaveXml( XclExpXmlStream& rStrm )
     rStyleSheet->endElement( XML_numFmts );
 }
 
-void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& rStrm, sal_uInt16 nXclNumFmt, const String& rFormatStr )
+void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& /*rStrm*/, sal_uInt16 /*nXclNumFmt*/, const String& /*rFormatStr*/ )
 {
+#if 0 // xlsx
     XclExpString aExpStr;
     if( GetBiff() <= EXC_BIFF5 )
         aExpStr.AssignByte( rFormatStr, GetTextEncoding(), EXC_STR_8BITLENGTH );
@@ -1262,11 +1275,14 @@ void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& rStrm, sal_uInt16 nXcl
     rStrm.StartRecord( EXC_ID4_FORMAT, 2 + aExpStr.GetSize() );
     rStrm << nXclNumFmt << aExpStr;
     rStrm.EndRecord();
+#endif // xlsx
 }
 
-void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& rStrm, const XclExpNumFmt& rFormat )
+void XclExpNumFmtBuffer::WriteFormatRecord( XclExpStream& /*rStrm*/, const XclExpNumFmt& /*rFormat*/ )
 {
+#if 0 // xlsx
     WriteFormatRecord( rStrm, rFormat.mnXclNumFmt, GetFormatCode( rFormat ) );
+#endif // xlsx
 }
 
 String XclExpNumFmtBuffer::GetFormatCode( const XclExpNumFmt& rFormat )
@@ -1990,8 +2006,9 @@ sal_uInt8 XclExpXF::GetUsedFlags() const
     return nUsedFlags;
 }
 
-void XclExpXF::WriteBody5( XclExpStream& rStrm )
+void XclExpXF::WriteBody5( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nTypeProt = 0, nAlign = 0;
     sal_uInt32 nArea = 0, nBorder = 0;
 
@@ -2005,10 +2022,12 @@ void XclExpXF::WriteBody5( XclExpStream& rStrm )
     maArea.FillToXF5( nArea );
 
     rStrm << mnXclFont << mnXclNumFmt << nTypeProt << nAlign << nArea << nBorder;
+#endif // xlsx
 }
 
-void XclExpXF::WriteBody8( XclExpStream& rStrm )
+void XclExpXF::WriteBody8( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nTypeProt = 0, nAlign = 0, nMiscAttrib = 0, nArea = 0;
     sal_uInt32 nBorder1 = 0, nBorder2 = 0;
 
@@ -2022,10 +2041,12 @@ void XclExpXF::WriteBody8( XclExpStream& rStrm )
     maArea.FillToXF8( nBorder2, nArea );
 
     rStrm << mnXclFont << mnXclNumFmt << nTypeProt << nAlign << nMiscAttrib << nBorder1 << nBorder2 << nArea;
+#endif // xlsx
 }
 
-void XclExpXF::WriteBody( XclExpStream& rStrm )
+void XclExpXF::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclExpXFId aParentId( mnParentXFId );
     aParentId.ConvertXFIndex( GetRoot() );
     mnParent = aParentId.mnXFIndex;
@@ -2035,6 +2056,7 @@ void XclExpXF::WriteBody( XclExpStream& rStrm )
         case EXC_BIFF8: WriteBody8( rStrm );    break;
         default:        DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 void XclExpXF::SetXmlIds( sal_uInt32 nBorderId, sal_uInt32 nFillId )
@@ -2164,8 +2186,9 @@ XclExpStyle::XclExpStyle( sal_uInt32 nXFId, sal_uInt8 nStyleId, sal_uInt8 nLevel
 {
 }
 
-void XclExpStyle::WriteBody( XclExpStream& rStrm )
+void XclExpStyle::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     maXFId.ConvertXFIndex( rStrm.GetRoot() );
     ::set_flag( maXFId.mnXFIndex, EXC_STYLE_BUILTIN, IsBuiltIn() );
     rStrm << maXFId.mnXFIndex;
@@ -2183,6 +2206,7 @@ void XclExpStyle::WriteBody( XclExpStream& rStrm )
             aNameEx.AssignByte( maName, rStrm.GetRoot().GetTextEncoding(), EXC_STR_8BITLENGTH );
         rStrm << aNameEx;
     }
+#endif // xlsx
 }
 
 static const char* lcl_StyleNameFromId( sal_Int32 nStyleId )
@@ -2471,12 +2495,14 @@ sal_Int32 XclExpXFBuffer::GetXmlCellIndex( sal_uInt32 nXFIndex ) const
     return maCellIndexes[ nXFIndex ];
 }
 
-void XclExpXFBuffer::Save( XclExpStream& rStrm )
+void XclExpXFBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // save all XF records contained in the maSortedXFList vector (sorted by XF index)
     maSortedXFList.Save( rStrm );
     // save all STYLE records
     maStyleList.Save( rStrm );
+#endif // xlsx
 }
 
 static void lcl_GetCellCounts( const XclExpRecordList< XclExpXF >& rXFList, sal_Int32& rCells, sal_Int32& rStyles )
diff --git sc/source/filter/xlsx/xlsx-xetable.cxx sc/source/filter/xlsx/xlsx-xetable.cxx
index 9b73ef5..36de8e5 100644
--- sc/source/filter/xlsx/xlsx-xetable.cxx
+++ sc/source/filter/xlsx/xlsx-xetable.cxx
@@ -67,9 +67,11 @@ XclExpStringRec::XclExpStringRec( const XclExpRoot& rRoot, const String& rResult
     SetRecSize( mxResult->GetSize() );
 }
 
-void XclExpStringRec::WriteBody( XclExpStream& rStrm )
+void XclExpStringRec::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << *mxResult;
+#endif // xlsx
 }
 
 // Additional records for special formula ranges ==============================
@@ -98,7 +100,7 @@ XclExpRangeFmlaBase::XclExpRangeFmlaBase(
     maBaseXclPos = maXclRange.maFirst;
 }
 
-bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
+bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const
 {
     return (maBaseXclPos.mnCol == nXclCol) && (maBaseXclPos.mnRow == nXclRow);
 }
@@ -106,16 +108,18 @@ bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) co
 void XclExpRangeFmlaBase::Extend( const ScAddress& rScPos )
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( rScPos.Col() );
-    sal_uInt16 nXclRow = static_cast< sal_uInt16 >( rScPos.Row() );
+    sal_uInt32 nXclRow = static_cast< sal_uInt32 >( rScPos.Row() );
     maXclRange.maFirst.mnCol = ::std::min( maXclRange.maFirst.mnCol, nXclCol );
     maXclRange.maFirst.mnRow = ::std::min( maXclRange.maFirst.mnRow, nXclRow );
     maXclRange.maLast.mnCol  = ::std::max( maXclRange.maLast.mnCol,  nXclCol );
     maXclRange.maLast.mnRow  = ::std::max( maXclRange.maLast.mnRow,  nXclRow );
 }
 
-void XclExpRangeFmlaBase::WriteRangeAddress( XclExpStream& rStrm ) const
+void XclExpRangeFmlaBase::WriteRangeAddress( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     maXclRange.Write( rStrm, false );
+#endif // xlsx
 }
 
 // Array formulas =============================================================
@@ -136,12 +140,14 @@ bool XclExpArray::IsVolatile() const
     return mxTokArr->IsVolatile();
 }
 
-void XclExpArray::WriteBody( XclExpStream& rStrm )
+void XclExpArray::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteRangeAddress( rStrm );
     sal_uInt16 nFlags = EXC_ARRAY_DEFAULTFLAGS;
     ::set_flag( nFlags, EXC_ARRAY_RECALC_ALWAYS, IsVolatile() );
     rStrm << nFlags << sal_uInt32( 0 ) << *mxTokArr;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -206,10 +212,12 @@ bool XclExpShrfmla::IsVolatile() const
     return mxTokArr->IsVolatile();
 }
 
-void XclExpShrfmla::WriteBody( XclExpStream& rStrm )
+void XclExpShrfmla::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteRangeAddress( rStrm );
     rStrm << sal_uInt8( 0 ) << mnUsedCount << *mxTokArr;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -367,10 +375,12 @@ bool XclExpTableop::IsVolatile() const
     return true;
 }
 
-void XclExpTableop::Save( XclExpStream& rStrm )
+void XclExpTableop::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mbValid )
         XclExpRangeFmlaBase::Save( rStrm );
+#endif // xlsx
 }
 
 bool XclExpTableop::IsAppendable( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
@@ -380,8 +390,9 @@ bool XclExpTableop::IsAppendable( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
             ((mnLastAppXclCol == maXclRange.maLast.mnCol) && (nXclCol == maXclRange.maFirst.mnCol) && (nXclRow == maXclRange.maLast.mnRow + 1));
 }
 
-void XclExpTableop::WriteBody( XclExpStream& rStrm )
+void XclExpTableop::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     sal_uInt16 nFlags = EXC_TABLEOP_DEFAULTFLAGS;
     ::set_flag( nFlags, EXC_TABLEOP_RECALC_ALWAYS, IsVolatile() );
     switch( mnScMode )
@@ -396,6 +407,7 @@ void XclExpTableop::WriteBody( XclExpStream& rStrm )
         rStrm << mnRowInpXclRow << mnRowInpXclCol << mnColInpXclRow << mnColInpXclCol;
     else
         rStrm << mnColInpXclRow << mnColInpXclCol << sal_uInt32( 0 );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -559,17 +571,21 @@ void XclExpSingleCellBase::ConvertXFIndexes( const XclExpRoot& rRoot )
     maXFId.ConvertXFIndex( rRoot );
 }
 
-void XclExpSingleCellBase::Save( XclExpStream& rStrm )
+void XclExpSingleCellBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF3 );
     AddRecSize( mnContSize );
     XclExpCellBase::Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpSingleCellBase::WriteBody( XclExpStream& rStrm )
+void XclExpSingleCellBase::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << GetXclRow() << GetXclCol() << maXFId.mnXFIndex;
     WriteContents( rStrm );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -613,9 +629,11 @@ void XclExpNumberCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpNumberCell::WriteContents( XclExpStream& rStrm )
+void XclExpNumberCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << mfValue;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -646,9 +664,11 @@ void XclExpBooleanCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpBooleanCell::WriteContents( XclExpStream& rStrm )
+void XclExpBooleanCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << sal_uInt16( mbValue ? 1 : 0 ) << EXC_BOOLERR_BOOL;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -775,8 +795,9 @@ void XclExpLabelCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpLabelCell::WriteContents( XclExpStream& rStrm )
+void XclExpLabelCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     switch( rStrm.GetRoot().GetBiff() )
     {
         case EXC_BIFF5:
@@ -792,6 +813,7 @@ void XclExpLabelCell::WriteContents( XclExpStream& rStrm )
         break;
         default:    DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -898,8 +920,9 @@ XclExpFormulaCell::XclExpFormulaCell(
         mxTokArr = rRoot.GetFormulaCompiler().CreateFormula( EXC_FMLATYPE_CELL, rScTokArr, &aScPos );
 }
 
-void XclExpFormulaCell::Save( XclExpStream& rStrm )
+void XclExpFormulaCell::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // create token array for FORMULA cells with additional record
     if( mxAddRec.is() )
         mxTokArr = mxAddRec->CreateCellTokenArray( rStrm.GetRoot() );
@@ -918,6 +941,7 @@ void XclExpFormulaCell::Save( XclExpStream& rStrm )
     // STRING record for string result
     if( mxStringRec.is() )
         mxStringRec->Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpFormulaCell::SaveXml( XclExpXmlStream& rStrm )
@@ -967,8 +991,9 @@ void XclExpFormulaCell::SaveXml( XclExpXmlStream& rStrm )
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpFormulaCell::WriteContents( XclExpStream& rStrm )
+void XclExpFormulaCell::WriteContents( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // result of the formula
     switch( mrScFmlaCell.GetFormatType() )
     {
@@ -1019,6 +1044,7 @@ void XclExpFormulaCell::WriteContents( XclExpStream& rStrm )
     ::set_flag( nFlags, EXC_FORMULA_RECALC_ALWAYS, mxTokArr->IsVolatile() || (mxAddRec.is() && mxAddRec->IsVolatile()) );
     ::set_flag( nFlags, EXC_FORMULA_SHARED, mxAddRec.is() && (mxAddRec->GetRecId() == EXC_ID_SHRFMLA) );
     rStrm << nFlags << sal_uInt32( 0 ) << *mxTokArr;
+#endif // xlsx
 }
 
 // Multiple cell records ======================================================
@@ -1052,8 +1078,9 @@ void XclExpMultiCellBase::ConvertXFIndexes( const XclExpRoot& rRoot )
         aIt->ConvertXFIndex( rRoot );
 }
 
-void XclExpMultiCellBase::Save( XclExpStream& rStrm )
+void XclExpMultiCellBase::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF3 );
 
     XclExpMultiXFIdDeq::const_iterator aEnd = maXFIds.end();
@@ -1107,6 +1134,7 @@ void XclExpMultiCellBase::Save( XclExpStream& rStrm )
             rStrm.EndRecord();
         }
     }
+#endif // xlsx
 }
 
 void XclExpMultiCellBase::SaveXml( XclExpXmlStream& rStrm )
@@ -1321,10 +1349,12 @@ void XclExpRkCell::WriteXmlContents( XclExpXmlStream& rStrm, const XclAddress& r
     rWorksheet->endElement( XML_c );
 }
 
-void XclExpRkCell::WriteContents( XclExpStream& rStrm, sal_uInt16 nRelCol )
+void XclExpRkCell::WriteContents( XclExpStream& /*rStrm*/, sal_uInt16 /*nRelCol*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( nRelCol < maRkValues.size(), "XclExpRkCell::WriteContents - overflow error" );
     rStrm << maRkValues[ nRelCol ];
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1421,9 +1451,11 @@ XclExpGuts::XclExpGuts( const XclExpRoot& rRoot ) :
     }
 }
 
-void XclExpGuts::WriteBody( XclExpStream& rStrm )
+void XclExpGuts::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm << mnRowWidth << mnColWidth << mnRowLevels << mnColLevels;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -1472,8 +1504,9 @@ void XclExpDimensions::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpDimensions::WriteBody( XclExpStream& rStrm )
+void XclExpDimensions::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     XclBiff eBiff = rStrm.GetRoot().GetBiff();
     if( eBiff == EXC_BIFF8 )
         rStrm << mnFirstUsedXclRow << mnFirstFreeXclRow;
@@ -1482,6 +1515,7 @@ void XclExpDimensions::WriteBody( XclExpStream& rStrm )
     rStrm << mnFirstUsedXclCol << mnFirstFreeXclCol;
     if( eBiff >= EXC_BIFF3 )
         rStrm << sal_uInt16( 0 );
+#endif // xlsx
 }
 
 // ============================================================================
@@ -1572,8 +1606,9 @@ bool XclExpColinfo::TryMerge( const XclExpColinfo& rColInfo )
     return false;
 }
 
-void XclExpColinfo::WriteBody( XclExpStream& rStrm )
+void XclExpColinfo::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // if last column is equal to last possible column, Excel adds one more
     sal_uInt16 nLastXclCol = mnLastXclCol;
     if( nLastXclCol == static_cast< sal_uInt16 >( rStrm.GetRoot().GetMaxPos().Col() ) )
@@ -1585,6 +1620,7 @@ void XclExpColinfo::WriteBody( XclExpStream& rStrm )
             << maXFId.mnXFIndex
             << mnFlags
             << sal_uInt16( 0 );
+#endif // xlsx
 }
 
 void XclExpColinfo::SaveXml( XclExpXmlStream& rStrm )
@@ -1684,12 +1720,14 @@ void XclExpColinfoBuffer::Finalize( ScfUInt16Vec& rXFIndexes )
     }
 }
 
-void XclExpColinfoBuffer::Save( XclExpStream& rStrm )
+void XclExpColinfoBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // DEFCOLWIDTH
     maDefcolwidth.Save( rStrm );
     // COLINFO records
     maColInfos.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpColinfoBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -1738,15 +1776,17 @@ void XclExpDefrowheight::SetDefaultData( const XclExpDefaultRowData& rDefData )
     maDefData = rDefData;
 }
 
-void XclExpDefrowheight::WriteBody( XclExpStream& rStrm )
+void XclExpDefrowheight::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF3 );
     rStrm << maDefData.mnFlags << maDefData.mnHeight;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
 
-XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
+XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt32 nXclRow,
         XclExpRowOutlineBuffer& rOutlineBfr, bool bAlwaysEmpty ) :
     XclExpRecord( EXC_ID3_ROW, 16 ),
     XclExpRoot( rRoot ),
@@ -1968,16 +2008,20 @@ void XclExpRow::DisableIfDefault( const XclExpDefaultRowData& rDefRowData )
         (IsUnsynced() != rDefRowData.IsUnsynced());
 }
 
-void XclExpRow::WriteCellList( XclExpStream& rStrm )
+void XclExpRow::WriteCellList( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT( mbEnabled || maCellList.IsEmpty(), "XclExpRow::WriteCellList - cells in disabled row" );
     maCellList.Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpRow::Save( XclExpStream& rStrm )
+void XclExpRow::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if( mbEnabled )
         XclExpRecord::Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpRow::InsertCell( XclExpCellRef xCell, size_t nPos, bool bIsMergedBase )
@@ -2004,8 +2048,9 @@ void XclExpRow::InsertCell( XclExpCellRef xCell, size_t nPos, bool bIsMergedBase
         maCellList.RemoveRecord( nPos );
 }
 
-void XclExpRow::WriteBody( XclExpStream& rStrm )
+void XclExpRow::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << mnXclRow
             << GetFirstUsedXclCol()
             << GetFirstFreeXclCol()
@@ -2013,6 +2058,7 @@ void XclExpRow::WriteBody( XclExpStream& rStrm )
             << sal_uInt32( 0 )
             << mnFlags
             << mnXFIndex;
+#endif // xlsx
 }
 
 void XclExpRow::SaveXml( XclExpXmlStream& rStrm )
@@ -2091,7 +2137,7 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         #i59220# Tolerance of +-128 rows for inserted/removed rows. */
     if( (nDefaultXclRow < 31872) || (nDefaultXclRow > 32128) )
     {
-        sal_uInt16 nLastXclRow = static_cast< sal_uInt16 >( GetMaxPos().Row() );
+        sal_uInt32 nLastXclRow = static_cast< sal_uInt32 >( GetMaxPos().Row() );
         if( nDefaultXclRow <= nLastXclRow )
         {
             // create a dummy ROW record and fill aMaxDefData
@@ -2153,7 +2199,7 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         // find used row range
         if( xRow->IsEnabled() )
         {
-            sal_uInt16 nXclRow = xRow->GetXclRow();
+            sal_uInt32 nXclRow = xRow->GetXclRow();
             nFirstUsedXclRow = ::std::min< sal_uInt32 >( nFirstUsedXclRow, nXclRow );
             nFirstFreeXclRow = ::std::max< sal_uInt32 >( nFirstFreeXclRow, nXclRow + 1 );
         }
@@ -2168,8 +2214,9 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         nFirstUsedXclCol, nFirstUsedXclRow, nFirstFreeXclCol, nFirstFreeXclRow );
 }
 
-void XclExpRowBuffer::Save( XclExpStream& rStrm )
+void XclExpRowBuffer::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // DIMENSIONS record
     maDimensions.Save( rStrm );
 
@@ -2197,6 +2244,7 @@ void XclExpRowBuffer::Save( XclExpStream& rStrm )
         nBlockStart = nBlockEnd;
         nStartXclRow += EXC_ROW_ROWBLOCKSIZE;
     }
+#endif // xlsx
 }
 
 void XclExpRowBuffer::SaveXml( XclExpXmlStream& rStrm )
@@ -2226,7 +2274,7 @@ XclExpDimensions* XclExpRowBuffer::GetDimensions()
     return &maDimensions;
 }
 
-XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysEmpty )
+XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt32 nXclRow, bool bRowAlwaysEmpty )
 {
     if( !mpLastUsedRow || (mnLastUsedXclRow != nXclRow) )
     {
@@ -2234,7 +2282,7 @@ XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysE
         // do not use sal_uInt16 for nFirstFreeXclRow, would cause loop in full sheets
         for( size_t nFirstFreeXclRow = maRowList.GetSize(); nFirstFreeXclRow <= nXclRow; ++nFirstFreeXclRow )
             maRowList.AppendNewRecord( new XclExpRow(
-                GetRoot(), static_cast< sal_uInt16 >( nFirstFreeXclRow ), maOutlineBfr, bRowAlwaysEmpty ) );
+                GetRoot(), static_cast< sal_uInt32 >( nFirstFreeXclRow ), maOutlineBfr, bRowAlwaysEmpty ) );
 
         mpLastUsedRow = maRowList.GetRecord( nXclRow ).get();
         mnLastUsedXclRow = nXclRow;
@@ -2319,7 +2367,7 @@ XclExpCellTable::XclExpCellTable( const XclExpRoot& rRoot ) :
         SCCOL nLastScCol = aIt.GetEndCol();
         ScAddress aScPos( nScCol, nScRow, nScTab );
 
-        XclAddress aXclPos( static_cast< sal_uInt16 >( nScCol ), static_cast< sal_uInt16 >( nScRow ) );
+        XclAddress aXclPos( static_cast< sal_uInt16 >( nScCol ), static_cast< sal_uInt32 >( nScRow ) );
         sal_uInt16 nLastXclCol = static_cast< sal_uInt16 >( nLastScCol );
 
         const ScBaseCell* pScCell = aIt.GetCell();
@@ -2506,12 +2554,14 @@ XclExpRecordRef XclExpCellTable::CreateRecord( sal_uInt16 nRecId ) const
     return xRec;
 }
 
-void XclExpCellTable::Save( XclExpStream& rStrm )
+void XclExpCellTable::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     // DEFCOLWIDTH and COLINFOs
     maColInfoBfr.Save( rStrm );
     // ROWs and cell records
     maRowBfr.Save( rStrm );
+#endif // xlsx
 }
 
 void XclExpCellTable::SaveXml( XclExpXmlStream& rStrm )
diff --git sc/source/filter/xlsx/xlsx-xeview.cxx sc/source/filter/xlsx/xlsx-xeview.cxx
index d15634b..8b983a1 100644
--- sc/source/filter/xlsx/xlsx-xeview.cxx
+++ sc/source/filter/xlsx/xlsx-xeview.cxx
@@ -79,8 +79,9 @@ void XclExpWindow1::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpWindow1::WriteBody( XclExpStream& rStrm )
+void XclExpWindow1::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     const XclExpTabInfo& rTabInfo = rStrm.GetRoot().GetTabInfo();
 
     rStrm   << sal_uInt16( 0 )              // X position of the window
@@ -92,6 +93,7 @@ void XclExpWindow1::WriteBody( XclExpStream& rStrm )
             << rTabInfo.GetFirstVisXclTab()
             << rTabInfo.GetXclSelectedCount()
             << mnTabBarSize;
+#endif // xlsx
 }
 
 // Sheet view settings records ================================================
@@ -120,8 +122,9 @@ XclExpWindow2::XclExpWindow2( const XclExpRoot& rRoot,
     ::set_flag( mnFlags, EXC_WIN2_PAGEBREAKMODE,    rData.mbPageMode );
 }
 
-void XclExpWindow2::WriteBody( XclExpStream& rStrm )
+void XclExpWindow2::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     const XclExpRoot& rRoot = rStrm.GetRoot();
 
     rStrm   << mnFlags
@@ -143,6 +146,7 @@ void XclExpWindow2::WriteBody( XclExpStream& rStrm )
         break;
         default:    DBG_ERROR_BIFF();
     }
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -165,10 +169,12 @@ void XclExpScl::Shorten( sal_uInt16 nFactor )
     }
 }
 
-void XclExpScl::WriteBody( XclExpStream& rStrm )
+void XclExpScl::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() >= EXC_BIFF4 );
     rStrm << mnNum << mnDenom;
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -206,14 +212,16 @@ void XclExpPane::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpPane::WriteBody( XclExpStream& rStrm )
+void XclExpPane::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << mnSplitX
             << mnSplitY
             << maSecondXclPos
             << mnActivePane;
     if( rStrm.GetRoot().GetBiff() >= EXC_BIFF5 )
         rStrm << sal_uInt8( 0 );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -251,12 +259,14 @@ void XclExpSelection::SaveXml( XclExpXmlStream& rStrm )
             FSEND );
 }
 
-void XclExpSelection::WriteBody( XclExpStream& rStrm )
+void XclExpSelection::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     rStrm   << mnPane                   // pane for this selection
             << maSelData.maXclCursor    // cell cursor
             << maSelData.mnCursorIdx;   // index to range containing cursor
     maSelData.maXclSelection.Write( rStrm, false );
+#endif // xlsx
 }
 
 // ----------------------------------------------------------------------------
@@ -271,8 +281,9 @@ XclExpTabBgColor::XclExpTabBgColor( const XclTabViewData& rTabViewData ) :
 {
 }*/
 
-void XclExpTabBgColor::WriteBody( XclExpStream& rStrm )
+void XclExpTabBgColor::WriteBody( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     if ( mrTabViewData.IsDefaultTabBgColor() )
         return;
     sal_uInt16 rt = 0x0862; //rt
@@ -286,6 +297,7 @@ void XclExpTabBgColor::WriteBody( XclExpStream& rStrm )
     if (TabBgColorIndex < 8 || TabBgColorIndex > 63 ) // only numbers 8 - 63 are valid numbers
         TabBgColorIndex = 127; //Excel specs: 127 makes excel ignore tab color information.
     rStrm << rt << grbitFrt << unused << unused << cb << TabBgColorIndex << reserved;
+#endif // xlsx
 }
 
 // Sheet view settings ========================================================
@@ -355,7 +367,7 @@ XclExpTabViewSettings::XclExpTabViewSettings( const XclExpRoot& rRoot, SCTAB nSc
                 maData.mnSplitX = static_cast< sal_uInt16 >( nFreezeScCol ) - maData.maFirstXclPos.mnCol;
             SCROW nFreezeScRow = rTabSett.maFreezePos.Row();
             if( (0 < nFreezeScRow) && (nFreezeScRow <= GetXclMaxPos().Row()) )
-                maData.mnSplitY = static_cast< sal_uInt16 >( nFreezeScRow ) - maData.maFirstXclPos.mnRow;
+                maData.mnSplitY = static_cast< sal_uInt32 >( nFreezeScRow ) - maData.maFirstXclPos.mnRow;
             // if both splits are left out (address overflow), remove the frozen flag
             maData.mbFrozenPanes = maData.IsSplit();
 
@@ -408,8 +420,9 @@ XclExpTabViewSettings::XclExpTabViewSettings( const XclExpRoot& rRoot, SCTAB nSc
     }
 }
 
-void XclExpTabViewSettings::Save( XclExpStream& rStrm )
+void XclExpTabViewSettings::Save( XclExpStream& /*rStrm*/ )
 {
+#if 0 // xlsx
     WriteWindow2( rStrm );
     WriteScl( rStrm );
     WritePane( rStrm );
@@ -418,6 +431,7 @@ void XclExpTabViewSettings::Save( XclExpStream& rStrm )
     WriteSelection( rStrm, EXC_PANE_BOTTOMLEFT );
     WriteSelection( rStrm, EXC_PANE_BOTTOMRIGHT );
     WriteTabBgColor( rStrm );
+#endif // xlsx
 }
 
 static void lcl_WriteSelection( XclExpXmlStream& rStrm, const XclTabViewData& rData, sal_uInt8 nPane )
@@ -501,22 +515,27 @@ void XclExpTabViewSettings::CreateSelectionData( sal_uInt8 nPane,
     }
 }
 
-void XclExpTabViewSettings::WriteWindow2( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WriteWindow2( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
 //  #i43553# GCC 3.3 parse error
 //    XclExpWindow2( GetRoot(), maData, mnGridColorId ).Save( rStrm );
     XclExpWindow2 aWindow2( GetRoot(), maData, mnGridColorId );
     aWindow2.Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WriteScl( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WriteScl( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( maData.mnCurrentZoom != 0 )
         XclExpScl( maData.mnCurrentZoom ).Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WritePane( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WritePane( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if( maData.IsSplit() )
 //  #i43553# GCC 3.3 parse error
 //        XclExpPane( GetRoot(), maData ).Save( rStrm );
@@ -524,18 +543,23 @@ void XclExpTabViewSettings::WritePane( XclExpStream& rStrm ) const
         XclExpPane aPane( maData );
         aPane.Save( rStrm );
     }
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WriteSelection( XclExpStream& rStrm, sal_uInt8 nPane ) const
+void XclExpTabViewSettings::WriteSelection( XclExpStream& /*rStrm*/, sal_uInt8 /*nPane*/ ) const
 {
+#if 0 // xlsx
     if( maData.HasPane( nPane ) )
         XclExpSelection( maData, nPane ).Save( rStrm );
+#endif // xlsx
 }
 
-void XclExpTabViewSettings::WriteTabBgColor( XclExpStream& rStrm ) const
+void XclExpTabViewSettings::WriteTabBgColor( XclExpStream& /*rStrm*/ ) const
 {
+#if 0 // xlsx
     if ( !maData.IsDefaultTabBgColor() )
         XclExpTabBgColor( maData ).Save( rStrm );
+#endif // xlsx
 }
 // ============================================================================
 
diff --git sc/source/filter/xlsx/xlsx-xichart.cxx sc/source/filter/xlsx/xlsx-xichart.cxx
deleted file mode 100644
index 3b02436..0000000
--- sc/source/filter/xlsx/xlsx-xichart.cxx
+++ /dev/null
@@ -1,3844 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xichart.cxx,v $
- * $Revision: 1.20.62.14 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "xichart.hxx"
-
-#include <algorithm>
-#include <memory>
-
-#include <com/sun/star/frame/XModel.hpp>
-#include <com/sun/star/drawing/Direction3D.hpp>
-#include <com/sun/star/drawing/ProjectionMode.hpp>
-#include <com/sun/star/drawing/ShadeMode.hpp>
-#include <com/sun/star/chart/ChartAxisArrangeOrderType.hpp>
-#include <com/sun/star/chart/ChartAxisLabelPosition.hpp>
-#include <com/sun/star/chart/ChartAxisMarkPosition.hpp>
-#include <com/sun/star/chart/ChartAxisPosition.hpp>
-#include <com/sun/star/chart/XChartDocument.hpp>
-#include <com/sun/star/chart2/XChartDocument.hpp>
-#include <com/sun/star/chart2/XDiagram.hpp>
-#include <com/sun/star/chart2/XCoordinateSystemContainer.hpp>
-#include <com/sun/star/chart2/XChartTypeContainer.hpp>
-#include <com/sun/star/chart2/XDataSeriesContainer.hpp>
-#include <com/sun/star/chart2/XRegressionCurveContainer.hpp>
-#include <com/sun/star/chart2/XTitled.hpp>
-#include <com/sun/star/chart2/data/XDataProvider.hpp>
-#include <com/sun/star/chart2/data/XDataReceiver.hpp>
-#include <com/sun/star/chart2/data/XDataSink.hpp>
-#include <com/sun/star/chart2/AxisType.hpp>
-#include <com/sun/star/chart2/CurveStyle.hpp>
-#include <com/sun/star/chart2/DataPointGeometry3D.hpp>
-#include <com/sun/star/chart2/DataPointLabel.hpp>
-#include <com/sun/star/chart2/StackingDirection.hpp>
-#include <com/sun/star/chart2/TickmarkStyle.hpp>
-#include <com/sun/star/chart/DataLabelPlacement.hpp>
-#include <com/sun/star/chart/ErrorBarStyle.hpp>
-#include <com/sun/star/chart/MissingValueTreatment.hpp>
-
-#include <sfx2/objsh.hxx>
-
-#include "document.hxx"
-#include "drwlayer.hxx"
-#include "rangeutl.hxx"
-#include "tokenarray.hxx"
-#include "token.hxx"
-#include "compiler.hxx"
-#include "reftokenhelper.hxx"
-#include "chartlis.hxx"
-#include "fprogressbar.hxx"
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xiformula.hxx"
-#include "xistyle.hxx"
-#include "xipage.hxx"
-#include "xiview.hxx"
-#include "xiescher.hxx"
-
-using ::rtl::OUString;
-using ::rtl::OUStringBuffer;
-using ::com::sun::star::uno::Any;
-using ::com::sun::star::uno::Reference;
-using ::com::sun::star::uno::Sequence;
-using ::com::sun::star::uno::UNO_QUERY;
-using ::com::sun::star::uno::UNO_QUERY_THROW;
-using ::com::sun::star::uno::Exception;
-using ::com::sun::star::beans::XPropertySet;
-using ::com::sun::star::lang::XMultiServiceFactory;
-using ::com::sun::star::frame::XModel;
-using ::com::sun::star::util::XNumberFormatsSupplier;
-
-using ::com::sun::star::chart2::XChartDocument;
-using ::com::sun::star::chart2::XDiagram;
-using ::com::sun::star::chart2::XCoordinateSystemContainer;
-using ::com::sun::star::chart2::XCoordinateSystem;
-using ::com::sun::star::chart2::XChartTypeContainer;
-using ::com::sun::star::chart2::XChartType;
-using ::com::sun::star::chart2::XDataSeriesContainer;
-using ::com::sun::star::chart2::XDataSeries;
-using ::com::sun::star::chart2::XRegressionCurve;
-using ::com::sun::star::chart2::XRegressionCurveContainer;
-using ::com::sun::star::chart2::XAxis;
-using ::com::sun::star::chart2::XScaling;
-using ::com::sun::star::chart2::ScaleData;
-using ::com::sun::star::chart2::IncrementData;
-using ::com::sun::star::chart2::SubIncrement;
-using ::com::sun::star::chart2::XLegend;
-using ::com::sun::star::chart2::XTitled;
-using ::com::sun::star::chart2::XTitle;
-using ::com::sun::star::chart2::XFormattedString;
-
-using ::com::sun::star::chart2::data::XDataProvider;
-using ::com::sun::star::chart2::data::XDataReceiver;
-using ::com::sun::star::chart2::data::XDataSink;
-using ::com::sun::star::chart2::data::XLabeledDataSequence;
-using ::com::sun::star::chart2::data::XDataSequence;
-
-using ::formula::FormulaToken;
-using ::formula::StackVar;
-
-using ::std::vector;
-
-// Helpers ====================================================================
-
-namespace {
-
-XclImpStream& operator>>( XclImpStream& rStrm, XclChRectangle& rRect )
-{
-    return rStrm >> rRect.mnX >> rRect.mnY >> rRect.mnWidth >> rRect.mnHeight;
-}
-
-template< typename Type >
-void lclSetValueOrClearAny( Any& rAny, const Type& rValue, bool bClear )
-{
-    if( bClear )
-        rAny.clear();
-    else
-        rAny <<= rValue;
-}
-
-void lclSetExpValueOrClearAny( Any& rAny, double fValue, bool bLogScale, bool bClear )
-{
-    if( !bClear && bLogScale )
-        fValue = pow( 10.0, fValue );
-    lclSetValueOrClearAny( rAny, fValue, bClear );
-}
-
-} // namespace
-
-// Common =====================================================================
-
-/** Stores global data needed in various classes of the Chart import filter. */
-class XclImpChRootData : public XclChRootData
-{
-public:
-    explicit            XclImpChRootData( XclImpChChart* pChartData );
-
-    /** Returns a reference to the parent chart data object. */
-    inline XclImpChChart& GetChartData() const { return *mpChartData; }
-
-private:
-    XclImpChChart*      mpChartData;            /// Pointer to the chart data object.
-};
-
-XclImpChRootData::XclImpChRootData( XclImpChChart* pChartData ) :
-    mpChartData( pChartData )
-{
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChRoot::XclImpChRoot( const XclImpRoot& rRoot, XclImpChChart* pChartData ) :
-    XclImpRoot( rRoot ),
-    mxChData( new XclImpChRootData( pChartData ) )
-{
-}
-
-XclImpChRoot::~XclImpChRoot()
-{
-}
-
-XclImpChChart& XclImpChRoot::GetChartData() const
-{
-    return mxChData->GetChartData();
-}
-
-const XclChTypeInfo& XclImpChRoot::GetChartTypeInfo( XclChTypeId eType ) const
-{
-    return mxChData->GetTypeInfoProvider().GetTypeInfo( eType );
-}
-
-const XclChTypeInfo& XclImpChRoot::GetChartTypeInfo( sal_uInt16 nRecId ) const
-{
-    return mxChData->GetTypeInfoProvider().GetTypeInfoFromRecId( nRecId );
-}
-
-const XclChFormatInfo& XclImpChRoot::GetFormatInfo( XclChObjectType eObjType ) const
-{
-    return mxChData->GetFormatInfoProvider().GetFormatInfo( eObjType );
-}
-
-Color XclImpChRoot::GetFontAutoColor() const
-{
-    return GetPalette().GetColor( EXC_COLOR_CHWINDOWTEXT );
-}
-
-Color XclImpChRoot::GetSeriesLineAutoColor( sal_uInt16 nFormatIdx ) const
-{
-    return GetPalette().GetColor( XclChartHelper::GetSeriesLineAutoColorIdx( nFormatIdx ) );
-}
-
-Color XclImpChRoot::GetSeriesFillAutoColor( sal_uInt16 nFormatIdx ) const
-{
-    const XclImpPalette& rPal = GetPalette();
-    Color aColor = rPal.GetColor( XclChartHelper::GetSeriesFillAutoColorIdx( nFormatIdx ) );
-    sal_uInt8 nTrans = XclChartHelper::GetSeriesFillAutoTransp( nFormatIdx );
-    return ScfTools::GetMixedColor( aColor, rPal.GetColor( EXC_COLOR_CHWINDOWBACK ), nTrans );
-}
-
-void XclImpChRoot::InitConversion( Reference< XChartDocument > xChartDoc ) const
-{
-    // create formatting object tables
-    mxChData->InitConversion( xChartDoc );
-
-    // lock the model to suppress any internal updates
-    Reference< XModel > xModel( xChartDoc, UNO_QUERY );
-    if( xModel.is() )
-        xModel->lockControllers();
-
-    SfxObjectShell* pDocShell = GetDocShell();
-    Reference< XDataReceiver > xDataRec( xChartDoc, UNO_QUERY );
-    if( pDocShell && xDataRec.is() )
-    {
-        // create and register a data provider
-        Reference< XDataProvider > xDataProv(
-            ScfApiHelper::CreateInstance( pDocShell, SERVICE_CHART2_DATAPROVIDER ), UNO_QUERY );
-        if( xDataProv.is() )
-            xDataRec->attachDataProvider( xDataProv );
-        // attach the number formatter
-        Reference< XNumberFormatsSupplier > xNumFmtSupp( pDocShell->GetModel(), UNO_QUERY );
-        if( xNumFmtSupp.is() )
-            xDataRec->attachNumberFormatsSupplier( xNumFmtSupp );
-    }
-}
-
-void XclImpChRoot::FinishConversion( ScfProgressBar& rProgress ) const
-{
-    rProgress.Progress( EXC_CHART_PROGRESS_SIZE );
-    // unlock the model
-    Reference< XModel > xModel( mxChData->GetChartDoc(), UNO_QUERY );
-    if( xModel.is() )
-        xModel->unlockControllers();
-    rProgress.Progress( EXC_CHART_PROGRESS_SIZE );
-
-    mxChData->FinishConversion();
-}
-
-Reference< XDataProvider > XclImpChRoot::GetDataProvider() const
-{
-    return mxChData->GetChartDoc()->getDataProvider();
-}
-
-void XclImpChRoot::ConvertLineFormat( ScfPropertySet& rPropSet,
-        const XclChLineFormat& rLineFmt, XclChPropertyMode ePropMode ) const
-{
-    GetChartPropSetHelper().WriteLineProperties(
-        rPropSet, mxChData->GetLineDashTable(), rLineFmt, ePropMode );
-}
-
-void XclImpChRoot::ConvertAreaFormat( ScfPropertySet& rPropSet,
-        const XclChAreaFormat& rAreaFmt, XclChPropertyMode ePropMode ) const
-{
-    GetChartPropSetHelper().WriteAreaProperties( rPropSet, rAreaFmt, ePropMode );
-}
-
-void XclImpChRoot::ConvertEscherFormat( ScfPropertySet& rPropSet,
-        const XclChEscherFormat& rEscherFmt, const XclChPicFormat& rPicFmt,
-        XclChPropertyMode ePropMode ) const
-{
-    GetChartPropSetHelper().WriteEscherProperties( rPropSet,
-        mxChData->GetGradientTable(), mxChData->GetHatchTable(), mxChData->GetBitmapTable(),
-        rEscherFmt, rPicFmt, ePropMode );
-}
-
-void XclImpChRoot::ConvertFont( ScfPropertySet& rPropSet,
-        sal_uInt16 nFontIdx, const Color* pFontColor ) const
-{
-    GetFontBuffer().WriteFontProperties( rPropSet, EXC_FONTPROPSET_CHART, nFontIdx, pFontColor );
-}
-
-void XclImpChRoot::ConvertPieRotation( ScfPropertySet& rPropSet, sal_uInt16 nAngle )
-{
-    sal_Int32 nApiRot = (450 - (nAngle % 360)) % 360;
-    rPropSet.SetProperty( EXC_CHPROP_STARTINGANGLE, nApiRot );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChGroupBase::~XclImpChGroupBase()
-{
-}
-
-void XclImpChGroupBase::ReadRecordGroup( XclImpStream& rStrm )
-{
-    // read contents of the header record
-    ReadHeaderRecord( rStrm );
-
-    // only read sub records, if the next record is a CHBEGIN
-    if( rStrm.GetNextRecId() == EXC_ID_CHBEGIN )
-    {
-        // read the CHBEGIN record, may be used for special initial processing
-        rStrm.StartNextRecord();
-        ReadSubRecord( rStrm );
-
-        // read the nested records
-        bool bLoop = true;
-        while( bLoop && rStrm.StartNextRecord() )
-        {
-            sal_uInt16 nRecId = rStrm.GetRecId();
-            bLoop = nRecId != EXC_ID_CHEND;
-            // skip unsupported nested blocks
-            if( nRecId == EXC_ID_CHBEGIN )
-                SkipBlock( rStrm );
-            else
-                ReadSubRecord( rStrm );
-        }
-    }
-    /*  Returns with current CHEND record or unchanged stream, if no record
-        group present. In every case another call to StartNextRecord() will go
-        to next record of interest. */
-}
-
-void XclImpChGroupBase::SkipBlock( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecId() == EXC_ID_CHBEGIN, "XclImpChGroupBase::SkipBlock - no CHBEGIN record" );
-    // do nothing if current record is not CHBEGIN
-    bool bLoop = rStrm.GetRecId() == EXC_ID_CHBEGIN;
-    while( bLoop && rStrm.StartNextRecord() )
-    {
-        sal_uInt16 nRecId = rStrm.GetRecId();
-        bLoop = nRecId != EXC_ID_CHEND;
-        // skip nested record groups
-        if( nRecId == EXC_ID_CHBEGIN )
-            SkipBlock( rStrm );
-    }
-}
-
-// Frame formatting ===========================================================
-
-void XclImpChFramePos::ReadChFramePos( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnObjType >> maData.mnSizeMode >> maData.maRect;
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpChLineFormat::ReadChLineFormat( XclImpStream& rStrm )
-{
-    rStrm >> maData.maColor >> maData.mnPattern >> maData.mnWeight >> maData.mnFlags;
-
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    if( rRoot.GetBiff() == EXC_BIFF8 )
-        // #116397# BIFF8: index into palette used instead of RGB data
-        maData.maColor = rRoot.GetPalette().GetColor( rStrm.ReaduInt16() );
-}
-
-void XclImpChLineFormat::Convert( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, XclChObjectType eObjType, sal_uInt16 nFormatIdx ) const
-{
-    const XclChFormatInfo& rFmtInfo = rRoot.GetFormatInfo( eObjType );
-    if( IsAuto() )
-    {
-        XclChLineFormat aLineFmt;
-        aLineFmt.maColor = (eObjType == EXC_CHOBJTYPE_LINEARSERIES) ?
-            rRoot.GetSeriesLineAutoColor( nFormatIdx ) :
-            rRoot.GetPalette().GetColor( rFmtInfo.mnAutoLineColorIdx );
-        aLineFmt.mnPattern = EXC_CHLINEFORMAT_SOLID;
-        aLineFmt.mnWeight = rFmtInfo.mnAutoLineWeight;
-        rRoot.ConvertLineFormat( rPropSet, aLineFmt, rFmtInfo.mePropMode );
-    }
-    else
-    {
-        rRoot.ConvertLineFormat( rPropSet, maData, rFmtInfo.mePropMode );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpChAreaFormat::ReadChAreaFormat( XclImpStream& rStrm )
-{
-    rStrm >> maData.maPattColor >> maData.maBackColor >> maData.mnPattern >> maData.mnFlags;
-
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    if( rRoot.GetBiff() == EXC_BIFF8 )
-    {
-        // #116397# BIFF8: index into palette used instead of RGB data
-        const XclImpPalette& rPal = rRoot.GetPalette();
-        maData.maPattColor = rPal.GetColor( rStrm.ReaduInt16() );
-        maData.maBackColor = rPal.GetColor( rStrm.ReaduInt16());
-    }
-}
-
-void XclImpChAreaFormat::Convert( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, XclChObjectType eObjType, sal_uInt16 nFormatIdx ) const
-{
-    const XclChFormatInfo& rFmtInfo = rRoot.GetFormatInfo( eObjType );
-    if( IsAuto() )
-    {
-        XclChAreaFormat aAreaFmt;
-        aAreaFmt.maPattColor = (eObjType == EXC_CHOBJTYPE_FILLEDSERIES) ?
-            rRoot.GetSeriesFillAutoColor( nFormatIdx ) :
-            rRoot.GetPalette().GetColor( rFmtInfo.mnAutoPattColorIdx );
-        aAreaFmt.mnPattern = EXC_PATT_SOLID;
-        rRoot.ConvertAreaFormat( rPropSet, aAreaFmt, rFmtInfo.mePropMode );
-    }
-    else
-    {
-        rRoot.ConvertAreaFormat( rPropSet, maData, rFmtInfo.mePropMode );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChEscherFormat::XclImpChEscherFormat( const XclImpRoot& rRoot )
-{
-    maData.mxItemSet.reset(
-        new SfxItemSet( rRoot.GetDoc().GetDrawLayer()->GetItemPool() ) );
-}
-
-void XclImpChEscherFormat::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    // read from stream - CHESCHERFORMAT uses own ID for record continuation
-    XclImpDffPropSet aPropSet( rStrm.GetRoot() );
-    rStrm.ResetRecord( true, rStrm.GetRecId() );
-    rStrm >> aPropSet;
-    // get the data
-    aPropSet.FillToItemSet( *maData.mxItemSet );
-    // get bitmap mode from DFF item set
-    sal_uInt32 nType = aPropSet.GetPropertyValue( DFF_Prop_fillType, mso_fillSolid );
-    maPicFmt.mnBmpMode = (nType == mso_fillPicture) ? EXC_CHPICFORMAT_STRETCH : EXC_CHPICFORMAT_STACK;
-}
-
-void XclImpChEscherFormat::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHPICFORMAT:
-            rStrm >> maPicFmt.mnBmpMode >> maPicFmt.mnFormat >> maPicFmt.mnFlags >> maPicFmt.mfScale;
-        break;
-    }
-}
-
-void XclImpChEscherFormat::Convert( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, XclChObjectType eObjType ) const
-{
-    const XclChFormatInfo& rFmtInfo = rRoot.GetFormatInfo( eObjType );
-    rRoot.ConvertEscherFormat( rPropSet, maData, maPicFmt, rFmtInfo.mePropMode );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChFrameBase::XclImpChFrameBase( const XclChFormatInfo& rFmtInfo )
-{
-    if( rFmtInfo.mbCreateDefFrame ) switch( rFmtInfo.meDefFrameType )
-    {
-        case EXC_CHFRAMETYPE_AUTO:
-            mxLineFmt.reset( new XclImpChLineFormat );
-            if( rFmtInfo.mbIsFrame )
-                mxAreaFmt.reset( new XclImpChAreaFormat );
-        break;
-        case EXC_CHFRAMETYPE_INVISIBLE:
-        {
-            XclChLineFormat aLineFmt;
-            ::set_flag( aLineFmt.mnFlags, EXC_CHLINEFORMAT_AUTO, false );
-            aLineFmt.mnPattern = EXC_CHLINEFORMAT_NONE;
-            mxLineFmt.reset( new XclImpChLineFormat( aLineFmt ) );
-            if( rFmtInfo.mbIsFrame )
-            {
-                XclChAreaFormat aAreaFmt;
-                ::set_flag( aAreaFmt.mnFlags, EXC_CHAREAFORMAT_AUTO, false );
-                aAreaFmt.mnPattern = EXC_PATT_NONE;
-                mxAreaFmt.reset( new XclImpChAreaFormat( aAreaFmt ) );
-            }
-        }
-        break;
-        default:
-            DBG_ERRORFILE( "XclImpChFrameBase::XclImpChFrameBase - unknown frame type" );
-    }
-}
-
-void XclImpChFrameBase::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHLINEFORMAT:
-            mxLineFmt.reset( new XclImpChLineFormat );
-            mxLineFmt->ReadChLineFormat( rStrm );
-        break;
-        case EXC_ID_CHAREAFORMAT:
-            mxAreaFmt.reset( new XclImpChAreaFormat );
-            mxAreaFmt->ReadChAreaFormat( rStrm );
-        break;
-        case EXC_ID_CHESCHERFORMAT:
-            mxEscherFmt.reset( new XclImpChEscherFormat( rStrm.GetRoot() ) );
-            mxEscherFmt->ReadRecordGroup( rStrm );
-        break;
-    }
-}
-
-void XclImpChFrameBase::ConvertLineBase( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, XclChObjectType eObjType, sal_uInt16 nFormatIdx ) const
-{
-    if( mxLineFmt.is() )
-        mxLineFmt->Convert( rRoot, rPropSet, eObjType, nFormatIdx );
-}
-
-void XclImpChFrameBase::ConvertAreaBase( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, XclChObjectType eObjType, sal_uInt16 nFormatIdx ) const
-{
-    if( rRoot.GetFormatInfo( eObjType ).mbIsFrame )
-    {
-        // CHESCHERFORMAT overrides CHAREAFORMAT (even if it is auto)
-        if( mxEscherFmt.is() )
-            mxEscherFmt->Convert( rRoot, rPropSet, eObjType );
-        else if( mxAreaFmt.is() )
-            mxAreaFmt->Convert( rRoot, rPropSet, eObjType, nFormatIdx );
-    }
-}
-
-void XclImpChFrameBase::ConvertFrameBase( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, XclChObjectType eObjType, sal_uInt16 nFormatIdx ) const
-{
-    ConvertLineBase( rRoot, rPropSet, eObjType, nFormatIdx );
-    ConvertAreaBase( rRoot, rPropSet, eObjType, nFormatIdx );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChFrame::XclImpChFrame( const XclImpChRoot& rRoot, XclChObjectType eObjType ) :
-    XclImpChFrameBase( rRoot.GetFormatInfo( eObjType ) ),
-    XclImpChRoot( rRoot ),
-    meObjType( eObjType )
-{
-}
-
-void XclImpChFrame::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnFormat >> maData.mnFlags;
-}
-
-void XclImpChFrame::UpdateObjFrame( const XclObjLineData& rLineData, const XclObjFillData& rFillData )
-{
-    const XclImpPalette& rPal = GetPalette();
-
-    if( rLineData.IsVisible() && (!mxLineFmt || !mxLineFmt->HasLine()) )
-    {
-        // line formatting
-        XclChLineFormat aLineFmt;
-        aLineFmt.maColor = rPal.GetColor( rLineData.mnColorIdx );
-        switch( rLineData.mnStyle )
-        {
-            case EXC_OBJ_LINE_SOLID:        aLineFmt.mnPattern = EXC_CHLINEFORMAT_SOLID;        break;
-            case EXC_OBJ_LINE_DASH:         aLineFmt.mnPattern = EXC_CHLINEFORMAT_DASH;         break;
-            case EXC_OBJ_LINE_DOT:          aLineFmt.mnPattern = EXC_CHLINEFORMAT_DOT;          break;
-            case EXC_OBJ_LINE_DASHDOT:      aLineFmt.mnPattern = EXC_CHLINEFORMAT_DASHDOT;      break;
-            case EXC_OBJ_LINE_DASHDOTDOT:   aLineFmt.mnPattern = EXC_CHLINEFORMAT_DASHDOTDOT;   break;
-            case EXC_OBJ_LINE_MEDTRANS:     aLineFmt.mnPattern = EXC_CHLINEFORMAT_MEDTRANS;     break;
-            case EXC_OBJ_LINE_DARKTRANS:    aLineFmt.mnPattern = EXC_CHLINEFORMAT_DARKTRANS;    break;
-            case EXC_OBJ_LINE_LIGHTTRANS:   aLineFmt.mnPattern = EXC_CHLINEFORMAT_LIGHTTRANS;   break;
-            case EXC_OBJ_LINE_NONE:         aLineFmt.mnPattern = EXC_CHLINEFORMAT_NONE;         break;
-            default:                        aLineFmt.mnPattern = EXC_CHLINEFORMAT_SOLID;
-        }
-        switch( rLineData.mnWidth )
-        {
-            case EXC_OBJ_LINE_HAIR:     aLineFmt.mnWeight = EXC_CHLINEFORMAT_HAIR;      break;
-            case EXC_OBJ_LINE_THIN:     aLineFmt.mnWeight = EXC_CHLINEFORMAT_SINGLE;    break;
-            case EXC_OBJ_LINE_MEDIUM:   aLineFmt.mnWeight = EXC_CHLINEFORMAT_DOUBLE;    break;
-            case EXC_OBJ_LINE_THICK:    aLineFmt.mnWeight = EXC_CHLINEFORMAT_TRIPLE;    break;
-            default:                    aLineFmt.mnWeight = EXC_CHLINEFORMAT_HAIR;
-        }
-        ::set_flag( aLineFmt.mnFlags, EXC_CHLINEFORMAT_AUTO, rLineData.IsAuto() );
-        mxLineFmt.reset( new XclImpChLineFormat( aLineFmt ) );
-    }
-
-    if( rFillData.IsFilled() && (!mxAreaFmt || !mxAreaFmt->HasArea()) && !mxEscherFmt )
-    {
-        // area formatting
-        XclChAreaFormat aAreaFmt;
-        aAreaFmt.maPattColor = rPal.GetColor( rFillData.mnPattColorIdx );
-        aAreaFmt.maBackColor = rPal.GetColor( rFillData.mnBackColorIdx );
-        aAreaFmt.mnPattern = rFillData.mnPattern;
-        ::set_flag( aAreaFmt.mnFlags, EXC_CHAREAFORMAT_AUTO, rFillData.IsAuto() );
-        mxAreaFmt.reset( new XclImpChAreaFormat( aAreaFmt ) );
-    }
-}
-
-void XclImpChFrame::Convert( ScfPropertySet& rPropSet ) const
-{
-    ConvertFrameBase( GetChRoot(), rPropSet, meObjType );
-}
-
-// Source links ===============================================================
-
-namespace {
-
-/** Creates a labeled data sequence object, adds link for series title if present. */
-Reference< XLabeledDataSequence > lclCreateLabeledDataSequence(
-        XclImpChSourceLinkRef xValueLink, const OUString& rValueRole,
-        const XclImpChSourceLink* pTitleLink = 0 )
-{
-    // create data sequence for values and title
-    Reference< XDataSequence > xValueSeq;
-    if( xValueLink.is() )
-        xValueSeq = xValueLink->CreateDataSequence( rValueRole );
-    Reference< XDataSequence > xTitleSeq;
-    if( pTitleLink )
-        xTitleSeq = pTitleLink->CreateDataSequence( EXC_CHPROP_ROLE_LABEL );
-
-    // create the labeled data sequence, if values or title are present
-    Reference< XLabeledDataSequence > xLabeledSeq;
-    if( xValueSeq.is() || xTitleSeq.is() )
-        xLabeledSeq.set( ScfApiHelper::CreateInstance( SERVICE_CHART2_LABELEDDATASEQ ), UNO_QUERY );
-    if( xLabeledSeq.is() )
-    {
-        if( xValueSeq.is() )
-            xLabeledSeq->setValues( xValueSeq );
-        if( xTitleSeq.is() )
-            xLabeledSeq->setLabel( xTitleSeq );
-    }
-    return xLabeledSeq;
-}
-
-} // namespace
-
-// ----------------------------------------------------------------------------
-
-XclImpChSourceLink::XclImpChSourceLink( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-XclImpChSourceLink::~XclImpChSourceLink()
-{
-}
-
-void XclImpChSourceLink::ReadChSourceLink( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnDestType
-            >> maData.mnLinkType
-            >> maData.mnFlags
-            >> maData.mnNumFmtIdx;
-
-    mxTokenArray.reset();
-    if( GetLinkType() == EXC_CHSRCLINK_WORKSHEET )
-    {
-        // read token array
-        XclTokenArray aXclTokArr;
-        rStrm >> aXclTokArr;
-
-        // convert BIFF formula tokens to Calc token array
-        if( const ScTokenArray* pTokens = GetFormulaCompiler().CreateFormula( EXC_FMLATYPE_CHART, aXclTokArr ) )
-            mxTokenArray.reset( pTokens->Clone() );
-    }
-
-    // try to read a following CHSTRING record
-    if( (rStrm.GetNextRecId() == EXC_ID_CHSTRING) && rStrm.StartNextRecord() )
-    {
-        mxString.reset( new XclImpString );
-        rStrm.Ignore( 2 );
-        mxString->Read( rStrm, EXC_STR_8BITLENGTH | EXC_STR_SEPARATEFORMATS );
-    }
-}
-
-void XclImpChSourceLink::SetString( const String& rString )
-{
-    if( !mxString )
-        mxString.reset( new XclImpString );
-    mxString->SetText( rString );
-}
-
-void XclImpChSourceLink::SetTextFormats( const XclFormatRunVec& rFormats )
-{
-    if( mxString.is() )
-        mxString->SetFormats( rFormats );
-}
-
-sal_uInt16 XclImpChSourceLink::GetCellCount() const
-{
-    sal_uInt32 nCellCount = 0;
-    if( mxTokenArray.is() )
-    {
-        mxTokenArray->Reset();
-        for( const FormulaToken* pToken = mxTokenArray->First(); pToken; pToken = mxTokenArray->Next() )
-        {
-            switch( pToken->GetType() )
-            {
-                case ::formula::svSingleRef:
-                case ::formula::svExternalSingleRef:
-                    // single cell
-                    ++nCellCount;
-                break;
-                case ::formula::svDoubleRef:
-                case ::formula::svExternalDoubleRef:
-                {
-                    // cell range
-                    const ScComplexRefData& rComplexRef = static_cast< const ScToken* >( pToken )->GetDoubleRef();
-                    const ScSingleRefData& rRef1 = rComplexRef.Ref1;
-                    const ScSingleRefData& rRef2 = rComplexRef.Ref2;
-                    sal_uInt32 nTabs = static_cast< sal_uInt32 >( rRef2.nTab - rRef1.nTab + 1 );
-                    sal_uInt32 nCols = static_cast< sal_uInt32 >( rRef2.nCol - rRef1.nCol + 1 );
-                    sal_uInt32 nRows = static_cast< sal_uInt32 >( rRef2.nRow - rRef1.nRow + 1 );
-                    nCellCount += nCols * nRows * nTabs;
-                }
-                break;
-                default: ;
-            }
-        }
-    }
-    return limit_cast< sal_uInt16 >( nCellCount );
-}
-
-void XclImpChSourceLink::ConvertNumFmt( ScfPropertySet& rPropSet, bool bPercent ) const
-{
-    bool bLinkToSource = ::get_flag( maData.mnFlags, EXC_CHSRCLINK_NUMFMT );
-    sal_uInt32 nScNumFmt = bLinkToSource ? GetNumFmtBuffer().GetScFormat( maData.mnNumFmtIdx ) : NUMBERFORMAT_ENTRY_NOT_FOUND;
-    OUString aPropName = bPercent ? EXC_CHPROP_PERCENTAGENUMFMT : EXC_CHPROP_NUMBERFORMAT;
-    if( nScNumFmt != NUMBERFORMAT_ENTRY_NOT_FOUND )
-        rPropSet.SetProperty( aPropName, static_cast< sal_Int32 >( nScNumFmt ) );
-    else
-        // restore 'link to source' at data point (series may contain manual number format)
-        rPropSet.SetAnyProperty( aPropName, Any() );
-}
-
-Reference< XDataSequence > XclImpChSourceLink::CreateDataSequence( const OUString& rRole ) const
-{
-    Reference< XDataSequence > xDataSeq;
-    Reference< XDataProvider > xDataProv = GetDataProvider();
-    if( xDataProv.is() && mxTokenArray.is() )
-    {
-        ScCompiler aComp( GetDocPtr(), ScAddress(), *mxTokenArray );
-        aComp.SetGrammar( ::formula::FormulaGrammar::GRAM_ENGLISH );
-        OUStringBuffer aRangeRep;
-        aComp.CreateStringFromTokenArray( aRangeRep );
-        try
-        {
-            xDataSeq = xDataProv->createDataSequenceByRangeRepresentation( aRangeRep.makeStringAndClear() );
-            // set sequence role
-            ScfPropertySet aSeqProp( xDataSeq );
-            aSeqProp.SetProperty( EXC_CHPROP_ROLE, rRole );
-        }
-        catch( Exception& )
-        {
-//            DBG_ERRORFILE( "XclImpChSourceLink::CreateDataSequence - cannot create data sequence" );
-        }
-    }
-    return xDataSeq;
-}
-
-Sequence< Reference< XFormattedString > > XclImpChSourceLink::CreateStringSequence(
-        const XclImpChRoot& rRoot, sal_uInt16 nLeadFontIdx, const Color& rLeadFontColor ) const
-{
-    ::std::vector< Reference< XFormattedString > > aStringVec;
-    if( mxString.is() )
-    {
-        for( XclImpStringIterator aIt( *mxString ); aIt.Is(); ++aIt )
-        {
-            Reference< XFormattedString > xFmtStr(
-                ScfApiHelper::CreateInstance( SERVICE_CHART2_FORMATTEDSTRING ), UNO_QUERY );
-            if( xFmtStr.is() )
-            {
-                // set text data
-                xFmtStr->setString( aIt.GetPortionText() );
-
-                // set font formatting and font color
-                ScfPropertySet aStringProp( xFmtStr );
-                sal_uInt16 nFontIdx = aIt.GetPortionFont();
-                if( (nFontIdx == EXC_FONT_NOTFOUND) && (aIt.GetPortionIndex() == 0) )
-                    // leading unformatted portion - use passed font settings
-                    rRoot.ConvertFont( aStringProp, nLeadFontIdx, &rLeadFontColor );
-                else
-                    rRoot.ConvertFont( aStringProp, nFontIdx );
-
-                // add string to vector of strings
-                aStringVec.push_back( xFmtStr );
-            }
-        }
-    }
-    return ScfApiHelper::VectorToSequence( aStringVec );
-}
-
-void XclImpChSourceLink::FillSourceLink(vector<ScSharedTokenRef>& rTokens) const
-{
-    if (!mxTokenArray.is())
-        // no links to fill.
-        return;
-
-    mxTokenArray->Reset();
-    for (FormulaToken* p = mxTokenArray->First(); p; p = mxTokenArray->Next())
-    {
-        ScSharedTokenRef pToken(static_cast<ScToken*>(p->Clone()));
-        if (ScRefTokenHelper::isRef(pToken))
-            // This is a reference token.  Store it.
-            ScRefTokenHelper::join(rTokens, pToken);
-    }
-}
-
-// Text =======================================================================
-
-XclImpChFontBase::~XclImpChFontBase()
-{
-}
-
-void XclImpChFontBase::ConvertFontBase( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const
-{
-    Color aFontColor = GetFontColor();
-    rRoot.ConvertFont( rPropSet, GetFontIndex(), &aFontColor );
-}
-
-void XclImpChFontBase::ConvertRotationBase( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet, bool bSupportsStacked ) const
-{
-    rRoot.GetChartPropSetHelper().WriteRotationProperties( rPropSet, GetRotation(), bSupportsStacked );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChFont::XclImpChFont() :
-    mnFontIdx( EXC_FONT_NOTFOUND )
-{
-}
-
-void XclImpChFont::ReadChFont( XclImpStream& rStrm )
-{
-    rStrm >> mnFontIdx;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChText::XclImpChText( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChText::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnHAlign
-            >> maData.mnVAlign
-            >> maData.mnBackMode
-            >> maData.maTextColor
-            >> maData.maRect
-            >> maData.mnFlags;
-
-    if( GetBiff() == EXC_BIFF8 )
-    {
-        // #116397# BIFF8: index into palette used instead of RGB data
-        maData.maTextColor = GetPalette().GetColor( rStrm.ReaduInt16() );
-        // placement and rotation
-        rStrm >> maData.mnPlacement >> maData.mnRotation;
-        // lower 4 bits used for placement, other bits contain garbage
-        maData.mnPlacement &= 0x000F;
-    }
-    else
-    {
-        // BIFF2-BIFF7: get rotation from text orientation
-        sal_uInt8 nOrient = ::extract_value< sal_uInt8 >( maData.mnFlags, 8, 3 );
-        maData.mnRotation = XclTools::GetXclRotFromOrient( nOrient );
-    }
-}
-
-void XclImpChText::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHFONT:
-            mxFont.reset( new XclImpChFont );
-            mxFont->ReadChFont( rStrm );
-        break;
-        case EXC_ID_CHFORMATRUNS:
-            if( GetBiff() == EXC_BIFF8 )
-                XclImpString::ReadFormats( rStrm, maFormats );
-        break;
-        case EXC_ID_CHSOURCELINK:
-            mxSrcLink.reset( new XclImpChSourceLink( GetChRoot() ) );
-            mxSrcLink->ReadChSourceLink( rStrm );
-        break;
-        case EXC_ID_CHFRAME:
-            mxFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_TEXT ) );
-            mxFrame->ReadRecordGroup( rStrm );
-        break;
-        case EXC_ID_CHOBJECTLINK:
-            rStrm >> maObjLink.mnTarget >> maObjLink.maPointPos.mnSeriesIdx >> maObjLink.maPointPos.mnPointIdx;
-        break;
-        case EXC_ID_CHFRLABELPROPS:
-            ReadChFrLabelProps( rStrm );
-        break;
-        case EXC_ID_CHEND:
-            if( mxSrcLink.is() && !maFormats.empty() )
-                mxSrcLink->SetTextFormats( maFormats );
-        break;
-    }
-}
-
-sal_uInt16 XclImpChText::GetFontIndex() const
-{
-    return mxFont.is() ? mxFont->GetFontIndex() : EXC_FONT_NOTFOUND;
-}
-
-Color XclImpChText::GetFontColor() const
-{
-    return ::get_flag( maData.mnFlags, EXC_CHTEXT_AUTOCOLOR ) ? GetFontAutoColor() : maData.maTextColor;
-}
-
-sal_uInt16 XclImpChText::GetRotation() const
-{
-    return maData.mnRotation;
-}
-
-void XclImpChText::SetString( const String& rString )
-{
-    if( !mxSrcLink )
-        mxSrcLink.reset( new XclImpChSourceLink( GetChRoot() ) );
-    mxSrcLink->SetString( rString );
-}
-
-void XclImpChText::UpdateText( const XclImpChText* pParentText )
-{
-    if( pParentText )
-    {
-        // update missing members
-        if( !mxFrame )
-            mxFrame = pParentText->mxFrame;
-        if( !mxFont )
-        {
-            mxFont = pParentText->mxFont;
-            // text color is taken from CHTEXT record, not from font in CHFONT
-            ::set_flag( maData.mnFlags, EXC_CHTEXT_AUTOCOLOR, ::get_flag( pParentText->maData.mnFlags, EXC_CHTEXT_AUTOCOLOR ) );
-            maData.maTextColor = pParentText->maData.maTextColor;
-        }
-    }
-}
-
-void XclImpChText::UpdateDataLabel( bool bCateg, bool bValue, bool bPercent )
-{
-    ::set_flag( maData.mnFlags, EXC_CHTEXT_SHOWCATEG,     bCateg );
-    ::set_flag( maData.mnFlags, EXC_CHTEXT_SHOWVALUE,     bValue );
-    ::set_flag( maData.mnFlags, EXC_CHTEXT_SHOWPERCENT,   bPercent );
-    ::set_flag( maData.mnFlags, EXC_CHTEXT_SHOWCATEGPERC, bCateg && bPercent );
-    ::set_flag( maData.mnFlags, EXC_CHTEXT_DELETED,       !bCateg && !bValue && !bPercent );
-}
-
-void XclImpChText::ConvertFont( ScfPropertySet& rPropSet ) const
-{
-    ConvertFontBase( GetChRoot(), rPropSet );
-}
-
-void XclImpChText::ConvertRotation( ScfPropertySet& rPropSet, bool bSupportsStacked ) const
-{
-    ConvertRotationBase( GetChRoot(), rPropSet, bSupportsStacked );
-}
-
-void XclImpChText::ConvertFrame( ScfPropertySet& rPropSet ) const
-{
-    if( mxFrame.is() )
-        mxFrame->Convert( rPropSet );
-}
-
-void XclImpChText::ConvertNumFmt( ScfPropertySet& rPropSet, bool bPercent ) const
-{
-    if( mxSrcLink.is() )
-        mxSrcLink->ConvertNumFmt( rPropSet, bPercent );
-}
-
-void XclImpChText::ConvertDataLabel( ScfPropertySet& rPropSet, const XclChTypeInfo& rTypeInfo ) const
-{
-    // existing CHFRLABELPROPS record wins over flags from CHTEXT
-    sal_uInt16 nShowFlags = mxLabelProps.is() ? mxLabelProps->mnFlags : maData.mnFlags;
-    sal_uInt16 SHOWANYCATEG   = mxLabelProps.is() ? EXC_CHFRLABELPROPS_SHOWCATEG : (EXC_CHTEXT_SHOWCATEGPERC | EXC_CHTEXT_SHOWCATEG);
-    sal_uInt16 SHOWANYVALUE   = mxLabelProps.is() ? EXC_CHFRLABELPROPS_SHOWVALUE : EXC_CHTEXT_SHOWVALUE;
-    sal_uInt16 SHOWANYPERCENT = mxLabelProps.is() ? EXC_CHFRLABELPROPS_SHOWPERCENT : (EXC_CHTEXT_SHOWPERCENT | EXC_CHTEXT_SHOWCATEGPERC);
-    sal_uInt16 SHOWANYBUBBLE  = mxLabelProps.is() ? EXC_CHFRLABELPROPS_SHOWBUBBLE : EXC_CHTEXT_SHOWBUBBLE;
-
-    // get raw flags for label values
-    bool bShowNone    = IsDeleted();
-    bool bShowCateg   = !bShowNone && ::get_flag( nShowFlags, SHOWANYCATEG );
-    bool bShowPercent = !bShowNone && ::get_flag( nShowFlags, SHOWANYPERCENT );
-    bool bShowValue   = !bShowNone && ::get_flag( nShowFlags, SHOWANYVALUE );
-    bool bShowBubble  = !bShowNone && ::get_flag( nShowFlags, SHOWANYBUBBLE );
-
-    // adjust to Chart2 behaviour
-    if( rTypeInfo.meTypeId == EXC_CHTYPEID_BUBBLES )
-         bShowValue = bShowBubble;  // Chart2 bubble charts show bubble size if 'ShowValue' is set
-
-    // other flags
-    bool bShowAny = bShowValue || bShowPercent || bShowCateg;
-    bool bShowSymbol = bShowAny && ::get_flag( maData.mnFlags, EXC_CHTEXT_SHOWSYMBOL );
-
-    // create API struct for label values, set API label separator
-    namespace cssc = ::com::sun::star::chart2;
-    cssc::DataPointLabel aPointLabel( bShowValue, bShowPercent, bShowCateg, bShowSymbol );
-    rPropSet.SetProperty( EXC_CHPROP_LABEL, aPointLabel );
-    String aSep = mxLabelProps.is() ? mxLabelProps->maSeparator : String( sal_Unicode( '\n' ) );
-    if( aSep.Len() == 0 )
-        aSep = CREATE_STRING( "; " );
-    rPropSet.SetStringProperty( EXC_CHPROP_LABELSEPARATOR, aSep );
-
-    // text properties of attached label
-    if( bShowAny )
-    {
-        ConvertFont( rPropSet );
-        ConvertRotation( rPropSet, false );
-        // label placement
-        using namespace ::com::sun::star::chart::DataLabelPlacement;
-        sal_Int32 nPlacement = rTypeInfo.mnDefaultLabelPos;
-        switch( maData.mnPlacement )
-        {
-            case EXC_CHTEXT_POS_DEFAULT:    nPlacement = rTypeInfo.mnDefaultLabelPos;   break;
-            case EXC_CHTEXT_POS_OUTSIDE:    nPlacement = OUTSIDE;                       break;
-            case EXC_CHTEXT_POS_INSIDE:     nPlacement = INSIDE;                        break;
-            case EXC_CHTEXT_POS_CENTER:     nPlacement = CENTER;                        break;
-            case EXC_CHTEXT_POS_AXIS:       nPlacement = NEAR_ORIGIN;                   break;
-            case EXC_CHTEXT_POS_ABOVE:      nPlacement = TOP;                           break;
-            case EXC_CHTEXT_POS_BELOW:      nPlacement = BOTTOM;                        break;
-            case EXC_CHTEXT_POS_LEFT:       nPlacement = LEFT;                          break;
-            case EXC_CHTEXT_POS_RIGHT:      nPlacement = RIGHT;                         break;
-            case EXC_CHTEXT_POS_AUTO:       nPlacement = AVOID_OVERLAP;                 break;
-        }
-        rPropSet.SetProperty( EXC_CHPROP_LABELPLACEMENT, nPlacement );
-        // label number format (percentage format wins over value format)
-        if( bShowPercent || bShowValue )
-            ConvertNumFmt( rPropSet, bShowPercent );
-    }
-}
-
-Reference< XTitle > XclImpChText::CreateTitle() const
-{
-    Reference< XTitle > xTitle;
-    if( mxSrcLink.is() && mxSrcLink->HasString() )
-    {
-        // create the formatted strings
-        Sequence< Reference< XFormattedString > > aStringSeq(
-            mxSrcLink->CreateStringSequence( GetChRoot(), GetFontIndex(), GetFontColor() ) );
-        if( aStringSeq.hasElements() )
-        {
-            // create the title object
-            xTitle.set( ScfApiHelper::CreateInstance( SERVICE_CHART2_TITLE ), UNO_QUERY );
-            if( xTitle.is() )
-            {
-                // set the formatted strings
-                xTitle->setText( aStringSeq );
-                // more title formatting properties
-                ScfPropertySet aTitleProp( xTitle );
-                ConvertFrame( aTitleProp );
-                ConvertRotation( aTitleProp, true );
-            }
-        }
-    }
-    return xTitle;
-}
-
-void XclImpChText::ReadChFrLabelProps( XclImpStream& rStrm )
-{
-    if( GetBiff() == EXC_BIFF8 )
-    {
-        mxLabelProps.reset( new XclChFrLabelProps );
-        sal_uInt16 nSepLen;
-        rStrm.Ignore( 12 );
-        rStrm >> mxLabelProps->mnFlags >> nSepLen;
-        if( nSepLen > 0 )
-            mxLabelProps->maSeparator = rStrm.ReadUniString( nSepLen );
-    }
-}
-
-namespace {
-
-void lclUpdateText( XclImpChTextRef& rxText, XclImpChTextRef xDefText )
-{
-    if( rxText.is() )
-        rxText->UpdateText( xDefText.get() );
-    else
-        rxText = xDefText;
-}
-
-void lclFinalizeTitle( XclImpChTextRef& rxTitle, XclImpChTextRef xDefText )
-{
-    /*  Do not update a title, if it is not visible (if rxTitle is null).
-        Existing reference indicates enabled title. */
-    if( rxTitle.is() )
-    {
-        if( rxTitle->HasString() )
-            rxTitle->UpdateText( xDefText.get() );
-        else
-            rxTitle.reset();
-    }
-}
-
-} // namespace
-
-// Data series ================================================================
-
-void XclImpChMarkerFormat::ReadChMarkerFormat( XclImpStream& rStrm )
-{
-    rStrm >> maData.maLineColor >> maData.maFillColor >> maData.mnMarkerType >> maData.mnFlags;
-
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    if( rRoot.GetBiff() == EXC_BIFF8 )
-    {
-        // #116397# BIFF8: index into palette used instead of RGB data
-        const XclImpPalette& rPal = rRoot.GetPalette();
-        maData.maLineColor = rPal.GetColor( rStrm.ReaduInt16() );
-        maData.maFillColor = rPal.GetColor( rStrm.ReaduInt16() );
-        // marker size
-        rStrm >> maData.mnMarkerSize;
-    }
-}
-
-void XclImpChMarkerFormat::Convert( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx, sal_Int16 nLineWeight ) const
-{
-    if( IsAuto() )
-    {
-        XclChMarkerFormat aMarkerFmt;
-        // line and fill color of the symbol are equal to series line color
-        //! TODO: Excel sets no fill color for specific symbols (e.g. cross)
-        aMarkerFmt.maLineColor = aMarkerFmt.maFillColor = rRoot.GetSeriesLineAutoColor( nFormatIdx );
-        switch( nLineWeight )
-        {
-            case EXC_CHLINEFORMAT_HAIR:     aMarkerFmt.mnMarkerSize = EXC_CHMARKERFORMAT_HAIRSIZE;      break;
-            case EXC_CHLINEFORMAT_SINGLE:   aMarkerFmt.mnMarkerSize = EXC_CHMARKERFORMAT_SINGLESIZE;    break;
-            case EXC_CHLINEFORMAT_DOUBLE:   aMarkerFmt.mnMarkerSize = EXC_CHMARKERFORMAT_DOUBLESIZE;    break;
-            case EXC_CHLINEFORMAT_TRIPLE:   aMarkerFmt.mnMarkerSize = EXC_CHMARKERFORMAT_TRIPLESIZE;    break;
-            default:                        aMarkerFmt.mnMarkerSize = EXC_CHMARKERFORMAT_SINGLESIZE;
-        }
-        aMarkerFmt.mnMarkerType = XclChartHelper::GetAutoMarkerType( nFormatIdx );
-        rRoot.GetChartPropSetHelper().WriteMarkerProperties( rPropSet, aMarkerFmt );
-    }
-    else
-    {
-        rRoot.GetChartPropSetHelper().WriteMarkerProperties( rPropSet, maData );
-    }
-}
-
-void XclImpChMarkerFormat::ConvertColor( const XclImpChRoot& rRoot,
-        ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const
-{
-    Color aLineColor = IsAuto() ? rRoot.GetSeriesLineAutoColor( nFormatIdx ) : maData.maFillColor;
-    rPropSet.SetColorProperty( EXC_CHPROP_COLOR, aLineColor );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChPieFormat::XclImpChPieFormat() :
-    mnPieDist( 0 )
-{
-}
-
-void XclImpChPieFormat::ReadChPieFormat( XclImpStream& rStrm )
-{
-    rStrm >> mnPieDist;
-}
-
-void XclImpChPieFormat::Convert( ScfPropertySet& rPropSet ) const
-{
-    double fApiDist = ::std::min< double >( mnPieDist / 100.0, 1.0 );
-    rPropSet.SetProperty( EXC_CHPROP_OFFSET, fApiDist );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChSeriesFormat::XclImpChSeriesFormat() :
-    mnFlags( 0 )
-{
-}
-
-void XclImpChSeriesFormat::ReadChSeriesFormat( XclImpStream& rStrm )
-{
-    rStrm >> mnFlags;
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpCh3dDataFormat::ReadCh3dDataFormat( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnBase >> maData.mnTop;
-}
-
-void XclImpCh3dDataFormat::Convert( ScfPropertySet& rPropSet ) const
-{
-    using namespace ::com::sun::star::chart2::DataPointGeometry3D;
-    sal_Int32 nApiType = (maData.mnBase == EXC_CH3DDATAFORMAT_RECT) ?
-        ((maData.mnTop == EXC_CH3DDATAFORMAT_STRAIGHT) ? CUBOID : PYRAMID) :
-        ((maData.mnTop == EXC_CH3DDATAFORMAT_STRAIGHT) ? CYLINDER : CONE);
-    rPropSet.SetProperty( EXC_CHPROP_GEOMETRY3D, nApiType );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChAttachedLabel::XclImpChAttachedLabel( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot ),
-    mnFlags( 0 )
-{
-}
-
-void XclImpChAttachedLabel::ReadChAttachedLabel( XclImpStream& rStrm )
-{
-    rStrm >> mnFlags;
-}
-
-XclImpChTextRef XclImpChAttachedLabel::CreateDataLabel( XclImpChTextRef xParent ) const
-{
-    const sal_uInt16 EXC_CHATTLABEL_SHOWANYVALUE = EXC_CHATTLABEL_SHOWVALUE;
-    const sal_uInt16 EXC_CHATTLABEL_SHOWANYPERCENT = EXC_CHATTLABEL_SHOWPERCENT | EXC_CHATTLABEL_SHOWCATEGPERC;
-    const sal_uInt16 EXC_CHATTLABEL_SHOWANYCATEG = EXC_CHATTLABEL_SHOWCATEG | EXC_CHATTLABEL_SHOWCATEGPERC;
-
-    XclImpChTextRef xLabel( xParent.is() ? new XclImpChText( *xParent ) : new XclImpChText( GetChRoot() ) );
-    xLabel->UpdateDataLabel(
-        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYCATEG ),
-        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYVALUE ),
-        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYPERCENT ) );
-    return xLabel;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChDataFormat::XclImpChDataFormat( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChDataFormat::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm   >> maData.maPointPos.mnPointIdx
-            >> maData.maPointPos.mnSeriesIdx
-            >> maData.mnFormatIdx
-            >> maData.mnFlags;
-}
-
-void XclImpChDataFormat::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHMARKERFORMAT:
-            mxMarkerFmt.reset( new XclImpChMarkerFormat );
-            mxMarkerFmt->ReadChMarkerFormat( rStrm );
-        break;
-        case EXC_ID_CHPIEFORMAT:
-            mxPieFmt.reset( new XclImpChPieFormat );
-            mxPieFmt->ReadChPieFormat( rStrm );
-        break;
-        case EXC_ID_CHSERIESFORMAT:
-            mxSeriesFmt.reset( new XclImpChSeriesFormat );
-            mxSeriesFmt->ReadChSeriesFormat( rStrm );
-        break;
-        case EXC_ID_CH3DDATAFORMAT:
-            mx3dDataFmt.reset( new XclImpCh3dDataFormat );
-            mx3dDataFmt->ReadCh3dDataFormat( rStrm );
-        break;
-        case EXC_ID_CHATTACHEDLABEL:
-            mxAttLabel.reset( new XclImpChAttachedLabel( GetChRoot() ) );
-            mxAttLabel->ReadChAttachedLabel( rStrm );
-        break;
-        default:
-            XclImpChFrameBase::ReadSubRecord( rStrm );
-    }
-}
-
-void XclImpChDataFormat::SetPointPos( const XclChDataPointPos& rPointPos, sal_uInt16 nFormatIdx )
-{
-    maData.maPointPos = rPointPos;
-    maData.mnFormatIdx = nFormatIdx;
-}
-
-void XclImpChDataFormat::UpdateGroupFormat( const XclChExtTypeInfo& rTypeInfo )
-{
-    // remove formats not used for the current chart type
-    RemoveUnusedFormats( rTypeInfo );
-}
-
-void XclImpChDataFormat::UpdateSeriesFormat( const XclChExtTypeInfo& rTypeInfo, const XclImpChDataFormat* pGroupFmt )
-{
-    // update missing formats from passed chart type group format
-    if( pGroupFmt )
-    {
-        if( !mxLineFmt )
-            mxLineFmt = pGroupFmt->mxLineFmt;
-        if( !mxAreaFmt && !mxEscherFmt )
-        {
-            mxAreaFmt = pGroupFmt->mxAreaFmt;
-            mxEscherFmt = pGroupFmt->mxEscherFmt;
-        }
-        if( !mxMarkerFmt )
-            mxMarkerFmt = pGroupFmt->mxMarkerFmt;
-        if( !mxPieFmt )
-            mxPieFmt = pGroupFmt->mxPieFmt;
-        if( !mxSeriesFmt )
-            mxSeriesFmt = pGroupFmt->mxSeriesFmt;
-        if( !mx3dDataFmt )
-            mx3dDataFmt = pGroupFmt->mx3dDataFmt;
-        if( !mxAttLabel )
-            mxAttLabel = pGroupFmt->mxAttLabel;
-    }
-
-    /*  Create missing but required formats. Existing line, area, and marker
-        format objects are needed to create automatic series formatting. */
-    if( !mxLineFmt )
-        mxLineFmt.reset( new XclImpChLineFormat );
-    if( !mxAreaFmt && !mxEscherFmt )
-        mxAreaFmt.reset( new XclImpChAreaFormat );
-    if( !mxMarkerFmt )
-        mxMarkerFmt.reset( new XclImpChMarkerFormat );
-
-    // remove formats not used for the current chart type
-    RemoveUnusedFormats( rTypeInfo );
-    // update data label
-    UpdateDataLabel( pGroupFmt );
-}
-
-void XclImpChDataFormat::UpdatePointFormat( const XclChExtTypeInfo& rTypeInfo, const XclImpChDataFormat* pSeriesFmt )
-{
-    // remove formats if they are automatic in this and in the passed series format
-    if( pSeriesFmt )
-    {
-        if( IsAutoLine() && pSeriesFmt->IsAutoLine() )
-            mxLineFmt.reset();
-        if( IsAutoArea() && pSeriesFmt->IsAutoArea() )
-            mxAreaFmt.reset();
-        if( IsAutoMarker() && pSeriesFmt->IsAutoMarker() )
-            mxMarkerFmt.reset();
-        mxSeriesFmt.reset();
-    }
-
-    // Excel ignores 3D bar format for single data points
-    mx3dDataFmt.reset();
-    // remove point line formats for linear chart types, TODO: implement in OOChart
-    if( !rTypeInfo.IsSeriesFrameFormat() )
-        mxLineFmt.reset();
-
-    // remove formats not used for the current chart type
-    RemoveUnusedFormats( rTypeInfo );
-    // update data label
-    UpdateDataLabel( pSeriesFmt );
-}
-
-void XclImpChDataFormat::UpdateTrendLineFormat()
-{
-    if( !mxLineFmt )
-        mxLineFmt.reset( new XclImpChLineFormat );
-    mxAreaFmt.reset();
-    mxEscherFmt.reset();
-    mxMarkerFmt.reset();
-    mxPieFmt.reset();
-    mxSeriesFmt.reset();
-    mx3dDataFmt.reset();
-    mxAttLabel.reset();
-    // update data label
-    UpdateDataLabel( 0 );
-}
-
-void XclImpChDataFormat::Convert( ScfPropertySet& rPropSet, const XclChExtTypeInfo& rTypeInfo ) const
-{
-    // line and area format
-    ConvertFrameBase( GetChRoot(), rPropSet, rTypeInfo.GetSeriesObjectType(), maData.mnFormatIdx );
-#if EXC_CHART2_3DBAR_HAIRLINES_ONLY
-    // #i83151# only hair lines in 3D charts with filled data points
-    if( rTypeInfo.mb3dChart && rTypeInfo.IsSeriesFrameFormat() && mxLineFmt.is() && mxLineFmt->HasLine() )
-        rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "BorderWidth" ), 0 );
-#endif
-
-    // other formatting
-    if( mxMarkerFmt.is() )
-        mxMarkerFmt->Convert( GetChRoot(), rPropSet, maData.mnFormatIdx, GetLineWeight() );
-    if( mxPieFmt.is() )
-        mxPieFmt->Convert( rPropSet );
-    if( mx3dDataFmt.is() )
-        mx3dDataFmt->Convert( rPropSet );
-    if( mxLabel.is() )
-        mxLabel->ConvertDataLabel( rPropSet, rTypeInfo );
-
-    // 3D settings
-    rPropSet.SetProperty< sal_Int16 >( EXC_CHPROP_PERCENTDIAGONAL, 0 );
-
-    /*  Special case: set marker color as line color, if series line is not
-        visible. This makes the color visible in the marker area.
-        TODO: remove this if OOChart supports own colors in markers. */
-    if( !rTypeInfo.IsSeriesFrameFormat() && !HasLine() && mxMarkerFmt.is() )
-        mxMarkerFmt->ConvertColor( GetChRoot(), rPropSet, maData.mnFormatIdx );
-}
-
-void XclImpChDataFormat::ConvertLine( ScfPropertySet& rPropSet, XclChObjectType eObjType ) const
-{
-    ConvertLineBase( GetChRoot(), rPropSet, eObjType );
-}
-
-void XclImpChDataFormat::ConvertArea( ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const
-{
-    ConvertAreaBase( GetChRoot(), rPropSet, EXC_CHOBJTYPE_FILLEDSERIES, nFormatIdx );
-}
-
-void XclImpChDataFormat::RemoveUnusedFormats( const XclChExtTypeInfo& rTypeInfo )
-{
-    // data point marker only in linear 2D charts
-    if( rTypeInfo.IsSeriesFrameFormat() )
-        mxMarkerFmt.reset();
-    // pie format only in pie/donut charts
-    if( rTypeInfo.meTypeCateg != EXC_CHTYPECATEG_PIE )
-        mxPieFmt.reset();
-    // 3D format only in 3D bar charts
-    if( !rTypeInfo.mb3dChart || (rTypeInfo.meTypeCateg != EXC_CHTYPECATEG_BAR) )
-        mx3dDataFmt.reset();
-}
-
-void XclImpChDataFormat::UpdateDataLabel( const XclImpChDataFormat* pParentFmt )
-{
-    /*  CHTEXT groups linked to data labels override existing CHATTACHEDLABEL
-        records. Only if there is a CHATTACHEDLABEL record without a CHTEXT
-        group, the contents of the CHATTACHEDLABEL record are used. In this
-        case a new CHTEXT group is created and filled with the settings from
-        the CHATTACHEDLABEL record. */
-    XclImpChTextRef xDefText;
-    if( pParentFmt )
-        xDefText = pParentFmt->GetDataLabel();
-    if( !xDefText )
-        xDefText = GetChartData().GetDefaultText( EXC_CHTEXTTYPE_DATALABEL );
-    if( mxLabel.is() )
-        mxLabel->UpdateText( xDefText.get() );
-    else if( mxAttLabel.is() )
-        mxLabel = mxAttLabel->CreateDataLabel( xDefText );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChSerTrendLine::XclImpChSerTrendLine( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChSerTrendLine::ReadChSerTrendLine( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnLineType
-            >> maData.mnOrder
-            >> maData.mfIntercept
-            >> maData.mnShowEquation
-            >> maData.mnShowRSquared
-            >> maData.mfForecastFor
-            >> maData.mfForecastBack;
-}
-
-Reference< XRegressionCurve > XclImpChSerTrendLine::CreateRegressionCurve() const
-{
-    // trend line type
-    OUString aService;
-    switch( maData.mnLineType )
-    {
-        case EXC_CHSERTREND_POLYNOMIAL:
-            // TODO: only linear trend lines are supported by OOChart (#i20819#)
-            if( maData.mnOrder == 1 )
-                aService = SERVICE_CHART2_LINEARREGCURVE;
-        break;
-        case EXC_CHSERTREND_EXPONENTIAL:
-            aService = SERVICE_CHART2_EXPREGCURVE;
-        break;
-        case EXC_CHSERTREND_LOGARITHMIC:
-            aService = SERVICE_CHART2_LOGREGCURVE;
-        break;
-        case EXC_CHSERTREND_POWER:
-            aService = SERVICE_CHART2_POTREGCURVE;
-        break;
-    }
-    Reference< XRegressionCurve > xRegCurve;
-    if( aService.getLength() > 0 )
-        xRegCurve.set( ScfApiHelper::CreateInstance( aService ), UNO_QUERY );
-
-    // trend line formatting
-    if( xRegCurve.is() && mxDataFmt.is() )
-    {
-        ScfPropertySet aPropSet( xRegCurve );
-        mxDataFmt->ConvertLine( aPropSet, EXC_CHOBJTYPE_TRENDLINE );
-
-        // #i83100# show equation and correlation coefficient
-        ScfPropertySet aLabelProp( xRegCurve->getEquationProperties() );
-        aLabelProp.SetBoolProperty( EXC_CHPROP_SHOWEQUATION, maData.mnShowEquation != 0 );
-        aLabelProp.SetBoolProperty( EXC_CHPROP_SHOWCORRELATION, maData.mnShowRSquared != 0 );
-
-        // #i83100# formatting of the equation text box
-        if( const XclImpChText* pLabel = mxDataFmt->GetDataLabel().get() )
-        {
-            pLabel->ConvertFont( aLabelProp );
-            pLabel->ConvertFrame( aLabelProp );
-            pLabel->ConvertNumFmt( aLabelProp, false );
-        }
-    }
-
-    // missing features
-    // #i20819# polynomial trend lines
-    // #i66819# moving average trend lines
-    // #i5085# manual trend line size
-    // #i34093# manual crossing point
-
-    return xRegCurve;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChSerErrorBar::XclImpChSerErrorBar( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChSerErrorBar::ReadChSerErrorBar( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnBarType >> maData.mnSourceType >> maData.mnLineEnd;
-    rStrm.Ignore( 1 );
-    rStrm >> maData.mfValue >> maData.mnValueCount;
-}
-
-void XclImpChSerErrorBar::SetSeriesData( XclImpChSourceLinkRef xValueLink, XclImpChDataFormatRef xDataFmt )
-{
-    mxValueLink = xValueLink;
-    mxDataFmt = xDataFmt;
-}
-
-Reference< XLabeledDataSequence > XclImpChSerErrorBar::CreateValueSequence() const
-{
-    return lclCreateLabeledDataSequence( mxValueLink, XclChartHelper::GetErrorBarValuesRole( maData.mnBarType ) );
-}
-
-Reference< XPropertySet > XclImpChSerErrorBar::CreateErrorBar( const XclImpChSerErrorBar* pPosBar, const XclImpChSerErrorBar* pNegBar )
-{
-    Reference< XPropertySet > xErrorBar;
-
-    if( const XclImpChSerErrorBar* pPrimaryBar = pPosBar ? pPosBar : pNegBar )
-    {
-        xErrorBar.set( ScfApiHelper::CreateInstance( SERVICE_CHART2_ERRORBAR ), UNO_QUERY );
-        ScfPropertySet aBarProp( xErrorBar );
-
-        // plus/minus bars visible?
-        aBarProp.SetBoolProperty( EXC_CHPROP_SHOWPOSITIVEERROR, pPosBar != 0 );
-        aBarProp.SetBoolProperty( EXC_CHPROP_SHOWNEGATIVEERROR, pNegBar != 0 );
-
-        // type of displayed error
-        namespace cssc = ::com::sun::star::chart;
-        switch( pPrimaryBar->maData.mnSourceType )
-        {
-            case EXC_CHSERERR_PERCENT:
-                aBarProp.SetProperty( EXC_CHPROP_ERRORBARSTYLE, cssc::ErrorBarStyle::RELATIVE );
-                aBarProp.SetProperty( EXC_CHPROP_POSITIVEERROR, pPrimaryBar->maData.mfValue );
-                aBarProp.SetProperty( EXC_CHPROP_NEGATIVEERROR, pPrimaryBar->maData.mfValue );
-            break;
-            case EXC_CHSERERR_FIXED:
-                aBarProp.SetProperty( EXC_CHPROP_ERRORBARSTYLE, cssc::ErrorBarStyle::ABSOLUTE );
-                aBarProp.SetProperty( EXC_CHPROP_POSITIVEERROR, pPrimaryBar->maData.mfValue );
-                aBarProp.SetProperty( EXC_CHPROP_NEGATIVEERROR, pPrimaryBar->maData.mfValue );
-            break;
-            case EXC_CHSERERR_STDDEV:
-                aBarProp.SetProperty( EXC_CHPROP_ERRORBARSTYLE, cssc::ErrorBarStyle::STANDARD_DEVIATION );
-                aBarProp.SetProperty( EXC_CHPROP_WEIGHT, pPrimaryBar->maData.mfValue );
-            break;
-            case EXC_CHSERERR_STDERR:
-                aBarProp.SetProperty( EXC_CHPROP_ERRORBARSTYLE, cssc::ErrorBarStyle::STANDARD_ERROR );
-            break;
-            case EXC_CHSERERR_CUSTOM:
-            {
-                aBarProp.SetProperty( EXC_CHPROP_ERRORBARSTYLE, cssc::ErrorBarStyle::FROM_DATA );
-                // attach data sequences to erorr bar
-                Reference< XDataSink > xDataSink( xErrorBar, UNO_QUERY );
-                if( xDataSink.is() )
-                {
-                    // create vector of all value sequences
-                    ::std::vector< Reference< XLabeledDataSequence > > aLabeledSeqVec;
-                    // add positive values
-                    if( pPosBar )
-                    {
-                        Reference< XLabeledDataSequence > xValueSeq = pPosBar->CreateValueSequence();
-                        if( xValueSeq.is() )
-                            aLabeledSeqVec.push_back( xValueSeq );
-                    }
-                    // add negative values
-                    if( pNegBar )
-                    {
-                        Reference< XLabeledDataSequence > xValueSeq = pNegBar->CreateValueSequence();
-                        if( xValueSeq.is() )
-                            aLabeledSeqVec.push_back( xValueSeq );
-                    }
-                    // attach labeled data sequences to series
-                    if( aLabeledSeqVec.empty() )
-                        xErrorBar.clear();
-                    else
-                        xDataSink->setData( ScfApiHelper::VectorToSequence( aLabeledSeqVec ) );
-                }
-            }
-            break;
-            default:
-                xErrorBar.clear();
-        }
-
-        // error bar formatting
-        if( pPrimaryBar->mxDataFmt.is() && xErrorBar.is() )
-            pPrimaryBar->mxDataFmt->ConvertLine( aBarProp, EXC_CHOBJTYPE_ERRORBAR );
-    }
-
-    return xErrorBar;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChSeries::XclImpChSeries( const XclImpChRoot& rRoot, sal_uInt16 nSeriesIdx ) :
-    XclImpChRoot( rRoot ),
-    mnGroupIdx( EXC_CHSERGROUP_NONE ),
-    mnSeriesIdx( nSeriesIdx ),
-    mnParentIdx( EXC_CHSERIES_INVALID )
-{
-}
-
-void XclImpChSeries::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnCategType >> maData.mnValueType >> maData.mnCategCount >> maData.mnValueCount;
-    if( GetBiff() == EXC_BIFF8 )
-        rStrm >> maData.mnBubbleType >> maData.mnBubbleCount;
-}
-
-void XclImpChSeries::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHSOURCELINK:
-            ReadChSourceLink( rStrm );
-        break;
-        case EXC_ID_CHDATAFORMAT:
-            ReadChDataFormat( rStrm );
-        break;
-        case EXC_ID_CHSERGROUP:
-            rStrm >> mnGroupIdx;
-        break;
-        case EXC_ID_CHSERPARENT:
-            ReadChSerParent( rStrm );
-        break;
-        case EXC_ID_CHSERTRENDLINE:
-            ReadChSerTrendLine( rStrm );
-        break;
-        case EXC_ID_CHSERERRORBAR:
-            ReadChSerErrorBar( rStrm );
-        break;
-    }
-}
-
-void XclImpChSeries::SetDataFormat( XclImpChDataFormatRef xDataFmt )
-{
-    if( xDataFmt.is() )
-    {
-        XclImpChDataFormatRef* pxDataFmt = GetDataFormatRef( xDataFmt->GetPointPos().mnPointIdx );
-        // do not overwrite existing data format
-        if( pxDataFmt && !*pxDataFmt )
-        {
-            *pxDataFmt = xDataFmt;
-            // #i51639# register series format index at chart type group
-            if( (pxDataFmt == &mxSeriesFmt) && !HasParentSeries() )
-                if( XclImpChTypeGroup* pTypeGroup = GetChartData().GetTypeGroup( mnGroupIdx ).get() )
-                    pTypeGroup->SetUsedFormatIndex( xDataFmt->GetFormatIdx() );
-        }
-    }
-}
-
-void XclImpChSeries::SetDataLabel( XclImpChTextRef xLabel )
-{
-    if( xLabel.is() )
-    {
-        XclImpChTextRef* pxLabel = GetDataLabelRef( xLabel->GetPointPos().mnPointIdx );
-        if( pxLabel && !*pxLabel )
-            *pxLabel = xLabel;
-    }
-}
-
-void XclImpChSeries::AddChildSeries( const XclImpChSeries& rSeries )
-{
-    DBG_ASSERT( !HasParentSeries(), "XclImpChSeries::AddChildSeries - not allowed for child series" );
-
-    /*  In Excel, trend lines and error bars are stored as own series. In Calc,
-        these are properties of the parent series. This function adds the
-        settings of the passed series to this series. */
-    maTrendLines.insert( maTrendLines.end(), rSeries.maTrendLines.begin(), rSeries.maTrendLines.end() );
-    maErrorBars.insert( rSeries.maErrorBars.begin(), rSeries.maErrorBars.end() );
-}
-
-void XclImpChSeries::FinalizeDataFormats()
-{
-    if( HasParentSeries() )
-    {
-        // *** series is a child series, e.g. trend line or error bar ***
-
-        // create missing series format
-        if( !mxSeriesFmt )
-            mxSeriesFmt = CreateDataFormat( EXC_CHDATAFORMAT_ALLPOINTS, 0 );
-
-        if( mxSeriesFmt.is() )
-        {
-            // #i83100# set text label format, e.g. for trend line equations
-            mxSeriesFmt->SetDataLabel( maLabels.get( EXC_CHDATAFORMAT_ALLPOINTS ) );
-            // create missing automatic formats
-            mxSeriesFmt->UpdateTrendLineFormat();
-        }
-
-        // copy series formatting to child objects
-        for( XclImpChSerTrendLineList::iterator aLIt = maTrendLines.begin(), aLEnd = maTrendLines.end(); aLIt != aLEnd; ++aLIt )
-            (*aLIt)->SetDataFormat( mxSeriesFmt );
-        for( XclImpChSerErrorBarMap::iterator aMIt = maErrorBars.begin(), aMEnd = maErrorBars.end(); aMIt != aMEnd; ++aMIt )
-            aMIt->second->SetSeriesData( mxValueLink, mxSeriesFmt );
-    }
-    else if( XclImpChTypeGroup* pTypeGroup = GetChartData().GetTypeGroup( mnGroupIdx ).get() )
-    {
-        // *** series is a regular data series ***
-
-        // create missing series format
-        if( !mxSeriesFmt )
-        {
-            // #i51639# use a new unused format index to create series default format
-            sal_uInt16 nFormatIdx = pTypeGroup->PopUnusedFormatIndex();
-            mxSeriesFmt = CreateDataFormat( EXC_CHDATAFORMAT_ALLPOINTS, nFormatIdx );
-        }
-
-        // set text labels to data formats
-        for( XclImpChTextMap::iterator aTIt = maLabels.begin(), aTEnd = maLabels.end(); aTIt != aTEnd; ++aTIt )
-        {
-            if( XclImpChDataFormatRef* pxDataFmt = GetDataFormatRef( aTIt->first ) )
-            {
-                if( !*pxDataFmt )
-                    *pxDataFmt = CreateDataFormat( aTIt->first, EXC_CHDATAFORMAT_DEFAULT );
-                (*pxDataFmt)->SetDataLabel( aTIt->second );
-            }
-        }
-
-        // update series format (copy missing formatting from group default format)
-        if( mxSeriesFmt.is() )
-            mxSeriesFmt->UpdateSeriesFormat( pTypeGroup->GetTypeInfo(), pTypeGroup->GetGroupFormat().get() );
-
-        // update data point formats (removes unchanged automatic formatting)
-        for( XclImpChDataFormatMap::iterator aFIt = maPointFmts.begin(), aFEnd = maPointFmts.end(); aFIt != aFEnd; ++aFIt )
-            aFIt->second->UpdatePointFormat( pTypeGroup->GetTypeInfo(), mxSeriesFmt.get() );
-    }
-}
-
-namespace {
-
-/** Returns the property set of the specified data point. */
-ScfPropertySet lclGetPointPropSet( Reference< XDataSeries > xDataSeries, sal_uInt16 nPointIdx )
-{
-    ScfPropertySet aPropSet;
-    try
-    {
-        aPropSet.Set( xDataSeries->getDataPointByIndex( static_cast< sal_Int32 >( nPointIdx ) ) );
-    }
-    catch( Exception& )
-    {
-        DBG_ERRORFILE( "lclGetPointPropSet - no data point property set" );
-    }
-    return aPropSet;
-}
-
-} // namespace
-
-Reference< XLabeledDataSequence > XclImpChSeries::CreateValueSequence( const OUString& rValueRole ) const
-{
-    return lclCreateLabeledDataSequence( mxValueLink, rValueRole, mxTitleLink.get() );
-}
-
-Reference< XLabeledDataSequence > XclImpChSeries::CreateCategSequence( const OUString& rCategRole ) const
-{
-    return lclCreateLabeledDataSequence( mxCategLink, rCategRole );
-}
-
-Reference< XDataSeries > XclImpChSeries::CreateDataSeries() const
-{
-    Reference< XDataSeries > xDataSeries;
-    if( const XclImpChTypeGroup* pTypeGroup = GetChartData().GetTypeGroup( mnGroupIdx ).get() )
-    {
-        const XclChExtTypeInfo& rTypeInfo = pTypeGroup->GetTypeInfo();
-
-        // create the data series object
-        xDataSeries.set( ScfApiHelper::CreateInstance( SERVICE_CHART2_DATASERIES ), UNO_QUERY );
-
-        // attach data and title sequences to series
-        Reference< XDataSink > xDataSink( xDataSeries, UNO_QUERY );
-        if( xDataSink.is() )
-        {
-            // create vector of all value sequences
-            ::std::vector< Reference< XLabeledDataSequence > > aLabeledSeqVec;
-            // add Y values
-            Reference< XLabeledDataSequence > xYValueSeq =
-                CreateValueSequence( EXC_CHPROP_ROLE_YVALUES );
-            if( xYValueSeq.is() )
-                aLabeledSeqVec.push_back( xYValueSeq );
-            // add X values
-            if( !rTypeInfo.mbCategoryAxis )
-            {
-                Reference< XLabeledDataSequence > xXValueSeq =
-                    CreateCategSequence( EXC_CHPROP_ROLE_XVALUES );
-                if( xXValueSeq.is() )
-                    aLabeledSeqVec.push_back( xXValueSeq );
-                // add size values of bubble charts
-                if( rTypeInfo.meTypeId == EXC_CHTYPEID_BUBBLES )
-                {
-                    Reference< XLabeledDataSequence > xSizeValueSeq =
-                        lclCreateLabeledDataSequence( mxBubbleLink, EXC_CHPROP_ROLE_SIZEVALUES, mxTitleLink.get() );
-                    if( xSizeValueSeq.is() )
-                        aLabeledSeqVec.push_back( xSizeValueSeq );
-                }
-            }
-            // attach labeled data sequences to series
-            if( !aLabeledSeqVec.empty() )
-                xDataSink->setData( ScfApiHelper::VectorToSequence( aLabeledSeqVec ) );
-        }
-
-        // series formatting
-        ScfPropertySet aSeriesProp( xDataSeries );
-        if( mxSeriesFmt.is() )
-            mxSeriesFmt->Convert( aSeriesProp, rTypeInfo );
-
-        // trend lines
-        ConvertTrendLines( xDataSeries );
-
-        // error bars
-        Reference< XPropertySet > xErrorBarX = CreateErrorBar( EXC_CHSERERR_XPLUS, EXC_CHSERERR_XMINUS );
-        if( xErrorBarX.is() )
-            aSeriesProp.SetProperty( EXC_CHPROP_ERRORBARX, xErrorBarX );
-        Reference< XPropertySet > xErrorBarY = CreateErrorBar( EXC_CHSERERR_YPLUS, EXC_CHSERERR_YMINUS );
-        if( xErrorBarY.is() )
-            aSeriesProp.SetProperty( EXC_CHPROP_ERRORBARY, xErrorBarY );
-
-        // own area formatting for every data point (TODO: varying line color not supported)
-        bool bVarPointFmt = pTypeGroup->HasVarPointFormat() && rTypeInfo.IsSeriesFrameFormat();
-#if EXC_CHART2_VARYCOLORSBY_PROP
-        aSeriesProp.SetBoolProperty( EXC_CHPROP_VARYCOLORSBY, bVarPointFmt );
-#else
-        aSeriesProp.SetBoolProperty( EXC_CHPROP_VARYCOLORSBY, rTypeInfo.meTypeCateg == EXC_CHTYPECATEG_PIE );
-#endif
-        // #i91271# always set area formatting for every point in pie/doughnut charts
-        if( mxSeriesFmt.is() && ((bVarPointFmt && mxSeriesFmt->IsAutoArea()) || (rTypeInfo.meTypeCateg == EXC_CHTYPECATEG_PIE)) )
-        {
-            for( sal_uInt16 nPointIdx = 0, nPointCount = mxValueLink->GetCellCount(); nPointIdx < nPointCount; ++nPointIdx )
-            {
-                ScfPropertySet aPointProp = lclGetPointPropSet( xDataSeries, nPointIdx );
-                mxSeriesFmt->ConvertArea( aPointProp, bVarPointFmt ? nPointIdx : mnSeriesIdx );
-            }
-        }
-
-        // data point formatting
-        for( XclImpChDataFormatMap::const_iterator aIt = maPointFmts.begin(), aEnd = maPointFmts.end(); aIt != aEnd; ++aIt )
-        {
-            ScfPropertySet aPointProp = lclGetPointPropSet( xDataSeries, aIt->first );
-            aIt->second->Convert( aPointProp, rTypeInfo );
-        }
-    }
-    return xDataSeries;
-}
-
-void XclImpChSeries::FillAllSourceLinks(vector<ScSharedTokenRef>& rTokens) const
-{
-    mxValueLink->FillSourceLink(rTokens);
-    mxCategLink->FillSourceLink(rTokens);
-    mxTitleLink->FillSourceLink(rTokens);
-    mxBubbleLink->FillSourceLink(rTokens);
-}
-
-void XclImpChSeries::ReadChSourceLink( XclImpStream& rStrm )
-{
-    XclImpChSourceLinkRef xSrcLink( new XclImpChSourceLink( GetChRoot() ) );
-    xSrcLink->ReadChSourceLink( rStrm );
-    switch( xSrcLink->GetDestType() )
-    {
-        case EXC_CHSRCLINK_TITLE:       mxTitleLink = xSrcLink;     break;
-        case EXC_CHSRCLINK_VALUES:      mxValueLink = xSrcLink;     break;
-        case EXC_CHSRCLINK_CATEGORY:    mxCategLink = xSrcLink;     break;
-        case EXC_CHSRCLINK_BUBBLES:     mxBubbleLink = xSrcLink;    break;
-    }
-}
-
-void XclImpChSeries::ReadChDataFormat( XclImpStream& rStrm )
-{
-    // #i51639# chart stores all data formats and assigns them later to the series
-    GetChartData().ReadChDataFormat( rStrm );
-}
-
-void XclImpChSeries::ReadChSerParent( XclImpStream& rStrm )
-{
-    rStrm >> mnParentIdx;
-    // index to parent series is 1-based, convert it to 0-based
-    if( mnParentIdx > 0 )
-        --mnParentIdx;
-    else
-        mnParentIdx = EXC_CHSERIES_INVALID;
-}
-
-void XclImpChSeries::ReadChSerTrendLine( XclImpStream& rStrm )
-{
-    XclImpChSerTrendLineRef xTrendLine( new XclImpChSerTrendLine( GetChRoot() ) );
-    xTrendLine->ReadChSerTrendLine( rStrm );
-    maTrendLines.push_back( xTrendLine );
-}
-
-void XclImpChSeries::ReadChSerErrorBar( XclImpStream& rStrm )
-{
-    XclImpChSerErrorBarRef xErrorBar( new XclImpChSerErrorBar( GetChRoot() ) );
-    xErrorBar->ReadChSerErrorBar( rStrm );
-    maErrorBars[ xErrorBar->GetBarType() ] = xErrorBar;
-}
-
-XclImpChDataFormatRef XclImpChSeries::CreateDataFormat( sal_uInt16 nPointIdx, sal_uInt16 nFormatIdx )
-{
-    XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
-    xDataFmt->SetPointPos( XclChDataPointPos( mnSeriesIdx, nPointIdx ), nFormatIdx );
-    return xDataFmt;
-}
-
-XclImpChDataFormatRef* XclImpChSeries::GetDataFormatRef( sal_uInt16 nPointIdx )
-{
-    if( nPointIdx == EXC_CHDATAFORMAT_ALLPOINTS )
-        return &mxSeriesFmt;
-    if( nPointIdx < EXC_CHDATAFORMAT_MAXPOINTCOUNT )
-        return &maPointFmts[ nPointIdx ];
-    return 0;
-}
-
-XclImpChTextRef* XclImpChSeries::GetDataLabelRef( sal_uInt16 nPointIdx )
-{
-    if( (nPointIdx == EXC_CHDATAFORMAT_ALLPOINTS) || (nPointIdx < EXC_CHDATAFORMAT_MAXPOINTCOUNT) )
-        return &maLabels[ nPointIdx ];
-    return 0;
-}
-
-void XclImpChSeries::ConvertTrendLines( Reference< XDataSeries > xDataSeries ) const
-{
-    Reference< XRegressionCurveContainer > xRegCurveCont( xDataSeries, UNO_QUERY );
-    if( xRegCurveCont.is() )
-    {
-        for( XclImpChSerTrendLineList::const_iterator aIt = maTrendLines.begin(), aEnd = maTrendLines.end(); aIt != aEnd; ++aIt )
-        {
-            try
-            {
-                Reference< XRegressionCurve > xRegCurve = (*aIt)->CreateRegressionCurve();
-                if( xRegCurve.is() )
-                    xRegCurveCont->addRegressionCurve( xRegCurve );
-            }
-            catch( Exception& )
-            {
-                DBG_ERRORFILE( "XclImpChSeries::ConvertTrendLines - cannot add regression curve" );
-            }
-        }
-    }
-}
-
-Reference< XPropertySet > XclImpChSeries::CreateErrorBar( sal_uInt8 nPosBarId, sal_uInt8 nNegBarId ) const
-{
-    return XclImpChSerErrorBar::CreateErrorBar( maErrorBars.get( nPosBarId ).get(), maErrorBars.get( nNegBarId ).get() );
-}
-
-// Chart type groups ==========================================================
-
-XclImpChType::XclImpChType( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot ),
-    mnRecId( EXC_ID_CHUNKNOWN ),
-    maTypeInfo( rRoot.GetChartTypeInfo( EXC_CHTYPEID_UNKNOWN ) )
-{
-}
-
-void XclImpChType::ReadChType( XclImpStream& rStrm )
-{
-    sal_uInt16 nRecId = rStrm.GetRecId();
-    bool bKnownType = true;
-
-    switch( nRecId )
-    {
-        case EXC_ID_CHBAR:
-            rStrm >> maData.mnOverlap >> maData.mnGap >> maData.mnFlags;
-        break;
-
-        case EXC_ID_CHLINE:
-        case EXC_ID_CHAREA:
-        case EXC_ID_CHRADARLINE:
-        case EXC_ID_CHRADARAREA:
-            rStrm >> maData.mnFlags;
-        break;
-
-        case EXC_ID_CHPIE:
-            rStrm >> maData.mnRotation >> maData.mnPieHole;
-            if( GetBiff() == EXC_BIFF8 )
-                rStrm >> maData.mnFlags;
-            else
-                maData.mnFlags = 0;
-        break;
-
-        case EXC_ID_CHPIEEXT:
-            maData.mnRotation = 0;
-            maData.mnPieHole = 0;
-            maData.mnFlags = 0;
-        break;
-
-        case EXC_ID_CHSCATTER:
-            if( GetBiff() == EXC_BIFF8 )
-                rStrm >> maData.mnBubbleSize >> maData.mnBubbleType >> maData.mnFlags;
-            else
-                maData.mnFlags = 0;
-        break;
-
-        case EXC_ID_CHSURFACE:
-            rStrm >> maData.mnFlags;
-        break;
-
-        default:
-            bKnownType = false;
-    }
-
-    if( bKnownType )
-        mnRecId = nRecId;
-}
-
-void XclImpChType::Finalize( bool bStockChart )
-{
-    switch( mnRecId )
-    {
-        case EXC_ID_CHLINE:
-            maTypeInfo = GetChartTypeInfo( bStockChart ?
-                EXC_CHTYPEID_STOCK : EXC_CHTYPEID_LINE );
-        break;
-        case EXC_ID_CHBAR:
-            maTypeInfo = GetChartTypeInfo( ::get_flagvalue(
-                maData.mnFlags, EXC_CHBAR_HORIZONTAL,
-                EXC_CHTYPEID_HORBAR, EXC_CHTYPEID_BAR ) );
-        break;
-        case EXC_ID_CHPIE:
-            maTypeInfo = GetChartTypeInfo( (maData.mnPieHole > 0) ?
-                EXC_CHTYPEID_DONUT : EXC_CHTYPEID_PIE );
-        break;
-        case EXC_ID_CHSCATTER:
-            maTypeInfo = GetChartTypeInfo( ::get_flagvalue(
-                maData.mnFlags, EXC_CHSCATTER_BUBBLES,
-                EXC_CHTYPEID_BUBBLES, EXC_CHTYPEID_SCATTER ) );
-        break;
-        default:
-            maTypeInfo = GetChartTypeInfo( mnRecId );
-    }
-
-    switch( maTypeInfo.meTypeId )
-    {
-        case EXC_CHTYPEID_PIEEXT:
-        case EXC_CHTYPEID_BUBBLES:
-        case EXC_CHTYPEID_SURFACE:
-        case EXC_CHTYPEID_UNKNOWN:
-            GetTracer().TraceChartUnKnownType();
-        break;
-        default:;
-    }
-}
-
-bool XclImpChType::IsStacked() const
-{
-    bool bStacked = false;
-    if( maTypeInfo.mbSupportsStacking ) switch( maTypeInfo.meTypeCateg )
-    {
-        case EXC_CHTYPECATEG_LINE:
-            bStacked =
-                ::get_flag( maData.mnFlags, EXC_CHLINE_STACKED ) &&
-                !::get_flag( maData.mnFlags, EXC_CHLINE_PERCENT );
-        break;
-        case EXC_CHTYPECATEG_BAR:
-            bStacked =
-                ::get_flag( maData.mnFlags, EXC_CHBAR_STACKED ) &&
-                !::get_flag( maData.mnFlags, EXC_CHBAR_PERCENT );
-        break;
-        default:;
-    }
-    return bStacked;
-}
-
-bool XclImpChType::IsPercent() const
-{
-    bool bPercent = false;
-    if( maTypeInfo.mbSupportsStacking ) switch( maTypeInfo.meTypeCateg )
-    {
-        case EXC_CHTYPECATEG_LINE:
-            bPercent =
-                ::get_flag( maData.mnFlags, EXC_CHLINE_STACKED ) &&
-                ::get_flag( maData.mnFlags, EXC_CHLINE_PERCENT );
-        break;
-        case EXC_CHTYPECATEG_BAR:
-            bPercent =
-                ::get_flag( maData.mnFlags, EXC_CHBAR_STACKED ) &&
-                ::get_flag( maData.mnFlags, EXC_CHBAR_PERCENT );
-        break;
-        default:;
-    }
-    return bPercent;
-}
-
-bool XclImpChType::HasCategoryLabels() const
-{
-    // radar charts disable category labels in chart type, not in CHTICK of X axis
-    return (maTypeInfo.meTypeCateg != EXC_CHTYPECATEG_RADAR) || ::get_flag( maData.mnFlags, EXC_CHRADAR_AXISLABELS );
-}
-
-Reference< XCoordinateSystem > XclImpChType::CreateCoordSystem( bool b3dChart ) const
-{
-    // service name
-    OUString aCoordSysService;
-    if( maTypeInfo.mbPolarCoordSystem )
-    {
-        if( b3dChart )
-            aCoordSysService = SERVICE_CHART2_POLARCOORDSYS3D;
-        else
-            aCoordSysService = SERVICE_CHART2_POLARCOORDSYS2D;
-    }
-    else
-    {
-        if( b3dChart )
-            aCoordSysService = SERVICE_CHART2_CARTESIANCOORDSYS3D;
-        else
-            aCoordSysService = SERVICE_CHART2_CARTESIANCOORDSYS2D;
-    }
-
-    // create the coordinate system object
-    Reference< XCoordinateSystem > xCoordSystem( ScfApiHelper::CreateInstance( aCoordSysService ), UNO_QUERY );
-
-    // swap X and Y axis
-    if( maTypeInfo.mbSwappedAxesSet )
-    {
-        ScfPropertySet aCoordSysProp( xCoordSystem );
-        aCoordSysProp.SetBoolProperty( EXC_CHPROP_SWAPXANDYAXIS, true );
-    }
-
-    return xCoordSystem;
-}
-
-Reference< XChartType > XclImpChType::CreateChartType( Reference< XDiagram > xDiagram, bool b3dChart ) const
-{
-    OUString aService = OUString::createFromAscii( maTypeInfo.mpcServiceName );
-    Reference< XChartType > xChartType( ScfApiHelper::CreateInstance( aService ), UNO_QUERY );
-
-    // additional properties
-    switch( maTypeInfo.meTypeCateg )
-    {
-        case EXC_CHTYPECATEG_LINE:
-        {
-            ScfPropertySet aTypeProp(xChartType);
-            bool bStacked = (maData.mnFlags & EXC_CHLINE_STACKED);
-            bool bPercent = (maData.mnFlags & EXC_CHLINE_PERCENT);
-            aTypeProp.SetBoolProperty(EXC_CHPROP_STACKED, bStacked);
-            aTypeProp.SetBoolProperty(EXC_CHPROP_PERCENT, bPercent);
-        }
-        break;
-        case EXC_CHTYPECATEG_BAR:
-        {
-            ScfPropertySet aTypeProp( xChartType );
-            Sequence< sal_Int32 > aInt32Seq( 2 );
-            aInt32Seq[ 0 ] = aInt32Seq[ 1 ] = -maData.mnOverlap;
-            aTypeProp.SetProperty( EXC_CHPROP_OVERLAPSEQ, aInt32Seq );
-            aInt32Seq[ 0 ] = aInt32Seq[ 1 ] = maData.mnGap;
-            aTypeProp.SetProperty( EXC_CHPROP_GAPWIDTHSEQ, aInt32Seq );
-            bool bStacked = (maData.mnFlags & EXC_CHBAR_STACKED);
-            bool bPercent = (maData.mnFlags & EXC_CHBAR_PERCENT);
-            aTypeProp.SetBoolProperty(EXC_CHPROP_STACKED, bStacked);
-            aTypeProp.SetBoolProperty(EXC_CHPROP_PERCENT, bPercent);
-        }
-        break;
-        case EXC_CHTYPECATEG_PIE:
-        {
-            ScfPropertySet aTypeProp( xChartType );
-            aTypeProp.SetBoolProperty( EXC_CHPROP_USERINGS, maTypeInfo.meTypeId == EXC_CHTYPEID_DONUT );
-            /*  #i85166# starting angle of first pie slice. 3D pie charts use Y
-                rotation setting in view3D element. Of-pie charts do not
-                support pie rotation. */
-            if( !b3dChart && (maTypeInfo.meTypeId != EXC_CHTYPEID_PIEEXT) )
-            {
-                ScfPropertySet aDiaProp( xDiagram );
-                XclImpChRoot::ConvertPieRotation( aDiaProp, maData.mnRotation );
-            }
-        }
-        break;
-        default:;
-    }
-
-    return xChartType;
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpChChart3d::ReadChChart3d( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnRotation
-            >> maData.mnElevation
-            >> maData.mnEyeDist
-            >> maData.mnRelHeight
-            >> maData.mnRelDepth
-            >> maData.mnDepthGap
-            >> maData.mnFlags;
-}
-
-void XclImpChChart3d::Convert( ScfPropertySet& rPropSet, bool b3dWallChart ) const
-{
-    namespace cssd = ::com::sun::star::drawing;
-
-//    #i104057# do not assert this, written by broken external generators
-//    DBG_ASSERT( ::get_flag( maData.mnFlags, EXC_CHCHART3D_HASWALLS ) == b3dWallChart, "XclImpChChart3d::Convert - wrong wall flag" );
-
-    sal_Int32 nRotationY = 0;
-    sal_Int32 nRotationX = 0;
-    sal_Int32 nPerspective = 15;
-    bool bRightAngled = false;
-    cssd::ProjectionMode eProjMode = cssd::ProjectionMode_PERSPECTIVE;
-    Color aAmbientColor, aLightColor;
-
-    if( b3dWallChart )
-    {
-        // Y rotation (Excel [0..359], Chart2 [-179,180])
-        nRotationY = maData.mnRotation % 360;
-        if( nRotationY > 180 ) nRotationY -= 360;
-        // X rotation a.k.a. elevation (Excel [-90..90], Chart2 [-179,180])
-        nRotationX = limit_cast< sal_Int32, sal_Int32 >( maData.mnElevation, -90, 90 );
-        // perspective (Excel and Chart2 [0,100])
-        nPerspective = limit_cast< sal_Int32, sal_Int32 >( maData.mnEyeDist, 0, 100 );
-        // right-angled axes
-        bRightAngled = !::get_flag( maData.mnFlags, EXC_CHCHART3D_REAL3D );
-        // projection mode (parallel axes, if right-angled, #i90360# or if perspective is at 0%)
-        bool bParallel = bRightAngled || (nPerspective == 0);
-        eProjMode = bParallel ? cssd::ProjectionMode_PARALLEL : cssd::ProjectionMode_PERSPECTIVE;
-        // ambient color (Gray 20%)
-        aAmbientColor.SetColor( RGB_COLORDATA( 204, 204, 204 ) );
-        // light color (Gray 60%)
-        aLightColor.SetColor( RGB_COLORDATA( 102, 102, 102 ) );
-    }
-    else
-    {
-        // Y rotation not used in pie charts, but 'first pie slice angle'
-        nRotationY = 0;
-        XclImpChRoot::ConvertPieRotation( rPropSet, maData.mnRotation );
-        // X rotation a.k.a. elevation (map Excel [10..80] to Chart2 [-80,-10])
-        nRotationX = limit_cast< sal_Int32, sal_Int32 >( maData.mnElevation, 10, 80 ) - 90;
-        // perspective (Excel and Chart2 [0,100])
-        nPerspective = limit_cast< sal_Int32, sal_Int32 >( maData.mnEyeDist, 0, 100 );
-        // no right-angled axes in pie charts, but parallel projection
-        bRightAngled = false;
-        eProjMode = cssd::ProjectionMode_PARALLEL;
-        // ambient color (Gray 30%)
-        aAmbientColor.SetColor( RGB_COLORDATA( 179, 179, 179 ) );
-        // light color (Gray 70%)
-        aLightColor.SetColor( RGB_COLORDATA( 76, 76, 76 ) );
-    }
-
-    // properties
-    rPropSet.SetProperty( EXC_CHPROP_ROTATIONVERTICAL, nRotationY );
-    rPropSet.SetProperty( EXC_CHPROP_ROTATIONHORIZONTAL, nRotationX );
-    rPropSet.SetProperty( EXC_CHPROP_PERSPECTIVE, nPerspective );
-    rPropSet.SetBoolProperty( EXC_CHPROP_RIGHTANGLEDAXES, bRightAngled );
-    rPropSet.SetProperty( EXC_CHPROP_D3DSCENEPERSPECTIVE, eProjMode );
-
-    // light settings
-    rPropSet.SetProperty( EXC_CHPROP_D3DSCENESHADEMODE, cssd::ShadeMode_FLAT );
-    rPropSet.SetColorProperty( EXC_CHPROP_D3DSCENEAMBIENTCOLOR, aAmbientColor );
-    rPropSet.SetBoolProperty( EXC_CHPROP_D3DSCENELIGHTON1, false );
-    rPropSet.SetBoolProperty( EXC_CHPROP_D3DSCENELIGHTON2, true );
-    rPropSet.SetColorProperty( EXC_CHPROP_D3DSCENELIGHTCOLOR2, aLightColor );
-    rPropSet.SetProperty( EXC_CHPROP_D3DSCENELIGHTDIR2, cssd::Direction3D( 0.2, 0.4, 1.0 ) );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChLegend::XclImpChLegend( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChLegend::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.maRect >> maData.mnDockMode >> maData.mnSpacing >> maData.mnFlags;
-
-    // trace unsupported features
-    if( GetTracer().IsEnabled() )
-    {
-        if( maData.mnDockMode == EXC_CHLEGEND_NOTDOCKED )
-            GetTracer().TraceChartLegendPosition();
-        if( ::get_flag( maData.mnFlags, EXC_CHLEGEND_DATATABLE ) )
-            GetTracer().TraceChartDataTable();
-    }
-}
-
-void XclImpChLegend::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHTEXT:
-            mxText.reset( new XclImpChText( GetChRoot() ) );
-            mxText->ReadRecordGroup( rStrm );
-        break;
-        case EXC_ID_CHFRAME:
-            mxFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_LEGEND ) );
-            mxFrame->ReadRecordGroup( rStrm );
-        break;
-    }
-}
-
-void XclImpChLegend::Finalize()
-{
-    // legend default formatting differs in OOChart and Excel, missing frame means automatic
-    if( !mxFrame )
-        mxFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_LEGEND ) );
-    // Update text formatting. If mxText is empty, the passed default text is used.
-    lclUpdateText( mxText, GetChartData().GetDefaultText( EXC_CHTEXTTYPE_LEGEND ) );
-}
-
-Reference< XLegend > XclImpChLegend::CreateLegend() const
-{
-    Reference< XLegend > xLegend( ScfApiHelper::CreateInstance( SERVICE_CHART2_LEGEND ), UNO_QUERY );
-    if( xLegend.is() )
-    {
-        ScfPropertySet aLegendProp( xLegend );
-
-        // frame properties
-        if( mxFrame.is() )
-            mxFrame->Convert( aLegendProp );
-        // text properties
-        if( mxText.is() )
-            mxText->ConvertFont( aLegendProp );
-        // special legend properties
-        GetChartPropSetHelper().WriteLegendProperties( aLegendProp, maData );
-    }
-    return xLegend;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChDropBar::XclImpChDropBar( sal_uInt16 nDropBar ) :
-    mnDropBar( nDropBar ),
-    mnBarDist( 0 )
-{
-}
-
-void XclImpChDropBar::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> mnBarDist;
-}
-
-void XclImpChDropBar::Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const
-{
-    XclChObjectType eObjType = EXC_CHOBJTYPE_BACKGROUND;
-    switch( mnDropBar )
-    {
-        case EXC_CHDROPBAR_UP:      eObjType = EXC_CHOBJTYPE_WHITEDROPBAR;  break;
-        case EXC_CHDROPBAR_DOWN:    eObjType = EXC_CHOBJTYPE_BLACKDROPBAR;  break;
-    }
-    ConvertFrameBase( rRoot, rPropSet, eObjType );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChTypeGroup::XclImpChTypeGroup( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot ),
-    maType( rRoot ),
-    maTypeInfo( maType.GetTypeInfo() )
-{
-    // Initialize unused format indexes set. At this time, all formats are unused.
-    for( sal_uInt16 nFormatIdx = 0; nFormatIdx <= EXC_CHSERIES_MAXSERIES; ++nFormatIdx )
-        maUnusedFormats.insert( maUnusedFormats.end(), nFormatIdx );
-}
-
-void XclImpChTypeGroup::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.maRect >> maData.mnFlags >> maData.mnGroupIdx;
-}
-
-void XclImpChTypeGroup::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHCHART3D:
-            mxChart3d.reset( new XclImpChChart3d );
-            mxChart3d->ReadChChart3d( rStrm );
-        break;
-        case EXC_ID_CHLEGEND:
-            mxLegend.reset( new XclImpChLegend( GetChRoot() ) );
-            mxLegend->ReadRecordGroup( rStrm );
-        break;
-        case EXC_ID_CHDEFAULTTEXT:
-            GetChartData().ReadChDefaultText( rStrm );
-        break;
-        case EXC_ID_CHDROPBAR:
-            ReadChDropBar( rStrm );
-        break;
-        case EXC_ID_CHCHARTLINE:
-            ReadChChartLine( rStrm );
-        break;
-        case EXC_ID_CHDATAFORMAT:
-            ReadChDataFormat( rStrm );
-        break;
-        default:
-            maType.ReadChType( rStrm );
-    }
-}
-
-void XclImpChTypeGroup::Finalize()
-{
-    // check and set valid chart type
-    bool bStockChart =
-        (maType.GetRecId() == EXC_ID_CHLINE) &&         // must be a line chart
-        !mxChart3d &&                                   // must be a 2d chart
-        HasHiLoLine() &&                                // must contain hi-lo lines
-        (maSeries.size() == static_cast<XclImpChSeriesVec::size_type>(HasDropBars() ? 4 : 3));   // correct series count
-    maType.Finalize( bStockChart );
-
-    // extended type info
-    maTypeInfo.Set( maType.GetTypeInfo(), mxChart3d.is(), false );
-
-    // reverse series order for some unstacked 2D chart types
-    if( maTypeInfo.mbReverseSeries && !Is3dChart() && !maType.IsStacked() && !maType.IsPercent() )
-        ::std::reverse( maSeries.begin(), maSeries.end() );
-
-    // update chart type group format, may depend on chart type finalized above
-    if( mxGroupFmt.is() )
-        mxGroupFmt->UpdateGroupFormat( maTypeInfo );
-}
-
-void XclImpChTypeGroup::AddSeries( XclImpChSeriesRef xSeries )
-{
-    if( xSeries.is() )
-        maSeries.push_back( xSeries );
-    // store first inserted series separately, series order may be reversed later
-    if( !mxFirstSeries )
-        mxFirstSeries = xSeries;
-}
-
-void XclImpChTypeGroup::SetUsedFormatIndex( sal_uInt16 nFormatIdx )
-{
-    maUnusedFormats.erase( nFormatIdx );
-}
-
-sal_uInt16 XclImpChTypeGroup::PopUnusedFormatIndex()
-{
-    DBG_ASSERT( !maUnusedFormats.empty(), "XclImpChTypeGroup::PopUnusedFormatIndex - no more format indexes available" );
-    sal_uInt16 nFormatIdx = maUnusedFormats.empty() ? 0 : *maUnusedFormats.begin();
-    SetUsedFormatIndex( nFormatIdx );
-    return nFormatIdx;
-}
-
-bool XclImpChTypeGroup::HasVarPointFormat() const
-{
-    return ::get_flag( maData.mnFlags, EXC_CHTYPEGROUP_VARIEDCOLORS ) &&
-        ((maTypeInfo.meVarPointMode == EXC_CHVARPOINT_MULTI) ||         // multiple series allowed
-            ((maTypeInfo.meVarPointMode == EXC_CHVARPOINT_SINGLE) &&    // or exactly 1 series?
-                (maSeries.size() == 1)));
-}
-
-bool XclImpChTypeGroup::HasConnectorLines() const
-{
-    // existence of connector lines (only in stacked bar charts)
-    bool bAnyStacked = maType.IsStacked() || maType.IsPercent();
-    XclImpChLineFormatRef xConnLine = maChartLines.get( EXC_CHCHARTLINE_CONNECT );
-    return bAnyStacked && (maTypeInfo.meTypeCateg == EXC_CHTYPECATEG_BAR) && xConnLine.is() && xConnLine->HasLine();
-}
-
-const String& XclImpChTypeGroup::GetSingleSeriesTitle() const
-{
-    // no automatic title for series with trendlines or error bars
-    // pie charts always show an automatic title, even if more series exist
-    return (mxFirstSeries.is() && !mxFirstSeries->HasChildSeries() && (maTypeInfo.mbSingleSeriesVis || (maSeries.size() == 1))) ?
-        mxFirstSeries->GetTitle() : String::EmptyString();
-}
-
-void XclImpChTypeGroup::ConvertChart3d( ScfPropertySet& rPropSet ) const
-{
-    if( mxChart3d.is() )
-        mxChart3d->Convert( rPropSet, Is3dWallChart() );
-}
-
-Reference< XCoordinateSystem > XclImpChTypeGroup::CreateCoordSystem() const
-{
-    return maType.CreateCoordSystem( Is3dChart() );
-}
-
-Reference< XChartType > XclImpChTypeGroup::CreateChartType( Reference< XDiagram > xDiagram, sal_Int32 nApiAxesSetIdx ) const
-{
-    DBG_ASSERT( IsValidGroup(), "XclImpChTypeGroup::CreateChartType - type group without series" );
-
-    // create the chart type object
-    Reference< XChartType > xChartType = maType.CreateChartType( xDiagram, Is3dChart() );
-
-    // bar chart connector lines
-    if( HasConnectorLines() )
-    {
-        ScfPropertySet aDiaProp( xDiagram );
-        aDiaProp.SetBoolProperty( EXC_CHPROP_CONNECTBARS, true );
-    }
-
-    /*  Stock chart needs special processing. Create one 'big' series with
-        data sequences of different roles. */
-    if( maTypeInfo.meTypeId == EXC_CHTYPEID_STOCK )
-        CreateStockSeries( xChartType, nApiAxesSetIdx );
-    else
-        CreateDataSeries( xChartType, nApiAxesSetIdx );
-
-    return xChartType;
-}
-
-Reference< XLabeledDataSequence > XclImpChTypeGroup::CreateCategSequence() const
-{
-    Reference< XLabeledDataSequence > xLabeledSeq;
-    // create category sequence from first visible series
-    if( mxFirstSeries.is() )
-        xLabeledSeq = mxFirstSeries->CreateCategSequence( EXC_CHPROP_ROLE_CATEG );
-    return xLabeledSeq;
-}
-
-void XclImpChTypeGroup::ReadChDropBar( XclImpStream& rStrm )
-{
-    sal_uInt16 nDropBar = EXC_CHDROPBAR_NONE;
-    if( !maDropBars.has( EXC_CHDROPBAR_UP ) )
-        nDropBar = EXC_CHDROPBAR_UP;
-    else if( !maDropBars.has( EXC_CHDROPBAR_DOWN ) )
-        nDropBar = EXC_CHDROPBAR_DOWN;
-
-    if( nDropBar != EXC_CHDROPBAR_NONE )
-    {
-        XclImpChDropBarRef xDropBar( new XclImpChDropBar( nDropBar ) );
-        xDropBar->ReadRecordGroup( rStrm );
-        maDropBars[ nDropBar ] = xDropBar;
-    }
-}
-
-void XclImpChTypeGroup::ReadChChartLine( XclImpStream& rStrm )
-{
-    sal_uInt16 nLineId = rStrm.ReaduInt16();
-    if( (rStrm.GetNextRecId() == EXC_ID_CHLINEFORMAT) && rStrm.StartNextRecord() )
-    {
-        XclImpChLineFormatRef xLineFmt( new XclImpChLineFormat );
-        xLineFmt->ReadChLineFormat( rStrm );
-        maChartLines[ nLineId ] = xLineFmt;
-    }
-}
-
-void XclImpChTypeGroup::ReadChDataFormat( XclImpStream& rStrm )
-{
-    // global series and data point format
-    XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
-    xDataFmt->ReadRecordGroup( rStrm );
-    const XclChDataPointPos& rPos = xDataFmt->GetPointPos();
-    if( (rPos.mnSeriesIdx == 0) && (rPos.mnPointIdx == 0) &&
-            (xDataFmt->GetFormatIdx() == EXC_CHDATAFORMAT_DEFAULT) )
-        mxGroupFmt = xDataFmt;
-}
-
-
-void XclImpChTypeGroup::InsertDataSeries( Reference< XChartType > xChartType,
-        Reference< XDataSeries > xSeries, sal_Int32 nApiAxesSetIdx ) const
-{
-    Reference< XDataSeriesContainer > xSeriesCont( xChartType, UNO_QUERY );
-    if( xSeriesCont.is() && xSeries.is() )
-    {
-        // series stacking mode
-        namespace cssc = ::com::sun::star::chart2;
-        cssc::StackingDirection eStacking = cssc::StackingDirection_NO_STACKING;
-        // stacked overrides deep-3d
-        if( maType.IsStacked() || maType.IsPercent() )
-            eStacking = cssc::StackingDirection_Y_STACKING;
-        else if( Is3dDeepChart() )
-            eStacking = cssc::StackingDirection_Z_STACKING;
-
-        // additional series properties
-        ScfPropertySet aSeriesProp( xSeries );
-        aSeriesProp.SetProperty( EXC_CHPROP_STACKINGDIR, eStacking );
-        aSeriesProp.SetProperty( EXC_CHPROP_ATTAXISINDEX, nApiAxesSetIdx );
-
-        // insert series into container
-        try
-        {
-            xSeriesCont->addDataSeries( xSeries );
-        }
-        catch( Exception& )
-        {
-            DBG_ERRORFILE( "XclImpChTypeGroup::InsertDataSeries - cannot add data series" );
-        }
-    }
-}
-
-void XclImpChTypeGroup::CreateDataSeries( Reference< XChartType > xChartType, sal_Int32 nApiAxesSetIdx ) const
-{
-    bool bSpline = false;
-    for( XclImpChSeriesVec::const_iterator aIt = maSeries.begin(), aEnd = maSeries.end(); aIt != aEnd; ++aIt )
-    {
-        Reference< XDataSeries > xDataSeries = (*aIt)->CreateDataSeries();
-        InsertDataSeries( xChartType, xDataSeries, nApiAxesSetIdx );
-        bSpline |= (*aIt)->HasSpline();
-    }
-    // spline - TODO: set at single series (#i66858#)
-    if( bSpline && !maTypeInfo.IsSeriesFrameFormat() && (maTypeInfo.meTypeCateg != EXC_CHTYPECATEG_RADAR) )
-    {
-        ScfPropertySet aTypeProp( xChartType );
-        aTypeProp.SetProperty( EXC_CHPROP_CURVESTYLE, ::com::sun::star::chart2::CurveStyle_CUBIC_SPLINES );
-    }
-}
-
-void XclImpChTypeGroup::CreateStockSeries( Reference< XChartType > xChartType, sal_Int32 nApiAxesSetIdx ) const
-{
-    // create the data series object
-    Reference< XDataSeries > xDataSeries( ScfApiHelper::CreateInstance( SERVICE_CHART2_DATASERIES ), UNO_QUERY );
-    Reference< XDataSink > xDataSink( xDataSeries, UNO_QUERY );
-    if( xDataSink.is() )
-    {
-        // create a list of data sequences from all series
-        ::std::vector< Reference< XLabeledDataSequence > > aLabeledSeqVec;
-        DBG_ASSERT( maSeries.size() >= 3, "XclImpChTypeGroup::CreateChartType - missing stock series" );
-        int nRoleIdx = (maSeries.size() == 3) ? 1 : 0;
-        for( XclImpChSeriesVec::const_iterator aIt = maSeries.begin(), aEnd = maSeries.end();
-                (nRoleIdx < 4) && (aIt != aEnd); ++nRoleIdx, ++aIt )
-        {
-            // create a data sequence with a specific role
-            OUString aRole;
-            switch( nRoleIdx )
-            {
-                case 0: aRole = EXC_CHPROP_ROLE_OPENVALUES;     break;
-                case 1: aRole = EXC_CHPROP_ROLE_HIGHVALUES;     break;
-                case 2: aRole = EXC_CHPROP_ROLE_LOWVALUES;      break;
-                case 3: aRole = EXC_CHPROP_ROLE_CLOSEVALUES;    break;
-            }
-            Reference< XLabeledDataSequence > xDataSeq = (*aIt)->CreateValueSequence( aRole );
-            if( xDataSeq.is() )
-                aLabeledSeqVec.push_back( xDataSeq );
-        }
-
-        // attach labeled data sequences to series and insert series into chart type
-        xDataSink->setData( ScfApiHelper::VectorToSequence( aLabeledSeqVec ) );
-
-        // formatting of special stock chart elements
-        ScfPropertySet aTypeProp( xChartType );
-        aTypeProp.SetBoolProperty( EXC_CHPROP_JAPANESE, HasDropBars() );
-        aTypeProp.SetBoolProperty( EXC_CHPROP_SHOWFIRST, HasDropBars() );
-        aTypeProp.SetBoolProperty( EXC_CHPROP_SHOWHIGHLOW, true );
-        // hi-lo line format
-        XclImpChLineFormatRef xHiLoLine = maChartLines.get( EXC_CHCHARTLINE_HILO );
-        if( xHiLoLine.is() )
-        {
-            ScfPropertySet aSeriesProp( xDataSeries );
-            xHiLoLine->Convert( GetChRoot(), aSeriesProp, EXC_CHOBJTYPE_HILOLINE );
-        }
-        // white dropbar format
-        XclImpChDropBarRef xUpBar = maDropBars.get( EXC_CHDROPBAR_UP );
-        Reference< XPropertySet > xWhitePropSet;
-        if( xUpBar.is() && aTypeProp.GetProperty( xWhitePropSet, EXC_CHPROP_WHITEDAY ) )
-        {
-            ScfPropertySet aBarProp( xWhitePropSet );
-            xUpBar->Convert( GetChRoot(), aBarProp );
-        }
-        // black dropbar format
-        XclImpChDropBarRef xDownBar = maDropBars.get( EXC_CHDROPBAR_DOWN );
-        Reference< XPropertySet > xBlackPropSet;
-        if( xDownBar.is() && aTypeProp.GetProperty( xBlackPropSet, EXC_CHPROP_BLACKDAY ) )
-        {
-            ScfPropertySet aBarProp( xBlackPropSet );
-            xDownBar->Convert( GetChRoot(), aBarProp );
-        }
-
-        // insert the series into the chart type object
-        InsertDataSeries( xChartType, xDataSeries, nApiAxesSetIdx );
-    }
-}
-
-// Axes =======================================================================
-
-XclImpChLabelRange::XclImpChLabelRange( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChLabelRange::ReadChLabelRange( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnCross >> maData.mnLabelFreq >> maData.mnTickFreq >> maData.mnFlags;
-}
-
-void XclImpChLabelRange::Convert( ScfPropertySet& rPropSet, ScaleData& rScaleData, bool bMirrorOrient ) const
-{
-    // do not overlap text unless all labels are visible
-    rPropSet.SetBoolProperty( EXC_CHPROP_TEXTOVERLAP, maData.mnLabelFreq == 1 );
-    // do not break text into several lines unless all labels are visible
-    rPropSet.SetBoolProperty( EXC_CHPROP_TEXTBREAK, maData.mnLabelFreq == 1 );
-    // do not stagger labels in two lines
-    namespace cssc = ::com::sun::star::chart;
-    rPropSet.SetProperty( EXC_CHPROP_ARRANGEORDER, cssc::ChartAxisArrangeOrderType_SIDE_BY_SIDE );
-
-    // reverse order
-    namespace cssc2 = ::com::sun::star::chart2;
-    bool bReverse = ::get_flag( maData.mnFlags, EXC_CHLABELRANGE_REVERSE ) != bMirrorOrient;
-    rScaleData.Orientation = bReverse ? cssc2::AxisOrientation_REVERSE : cssc2::AxisOrientation_MATHEMATICAL;
-
-    //! TODO #i58731# show n-th category
-}
-
-void XclImpChLabelRange::ConvertAxisPosition( ScfPropertySet& rPropSet, bool b3dChart ) const
-{
-    /*  Crossing mode (max-cross flag overrides other crossing settings). Excel
-        does not move the Y axis in 3D charts, regardless of actual settings.
-        But: the Y axis has to be moved to "end", if the X axis is mirrored,
-        to keep it at the left end of the chart. */
-    bool bMaxCross = ::get_flag( maData.mnFlags, b3dChart ? EXC_CHLABELRANGE_REVERSE : EXC_CHLABELRANGE_MAXCROSS );
-    namespace cssc = ::com::sun::star::chart;
-    cssc::ChartAxisPosition eAxisPos = bMaxCross ? cssc::ChartAxisPosition_END : cssc::ChartAxisPosition_VALUE;
-    rPropSet.SetProperty( EXC_CHPROP_CROSSOVERPOSITION, eAxisPos );
-
-    // crossing position
-    double fCrossingPos = b3dChart ? 1.0 : maData.mnCross;
-    rPropSet.SetProperty( EXC_CHPROP_CROSSOVERVALUE, fCrossingPos );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChValueRange::XclImpChValueRange( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChValueRange::ReadChValueRange( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mfMin
-            >> maData.mfMax
-            >> maData.mfMajorStep
-            >> maData.mfMinorStep
-            >> maData.mfCross
-            >> maData.mnFlags;
-}
-
-void XclImpChValueRange::Convert( ScaleData& rScaleData, bool bMirrorOrient, bool bPercent ) const
-{
-    // scaling algorithm
-    bool bLogScale = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_LOGSCALE );
-    OUString aScalingService = bLogScale ? SERVICE_CHART2_LOGSCALING : SERVICE_CHART2_LINEARSCALING;
-    rScaleData.Scaling.set( ScfApiHelper::CreateInstance( aScalingService ), UNO_QUERY );
-
-    // min/max
-    double fMinVal = bPercent ? maData.mfMin/100.0 : maData.mfMin;
-    double fMaxVal = bPercent ? maData.mfMax/100.0 : maData.mfMax;
-    lclSetExpValueOrClearAny( rScaleData.Minimum, fMinVal, bLogScale, ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_AUTOMIN ) );
-    lclSetExpValueOrClearAny( rScaleData.Maximum, fMaxVal, bLogScale, ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_AUTOMAX ) );
-
-    // increment
-    bool bAutoMajor = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_AUTOMAJOR );
-    bool bAutoMinor = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_AUTOMINOR );
-    // major increment
-    IncrementData& rIncrementData = rScaleData.IncrementData;
-    double fMajorStep = bPercent ? maData.mfMajorStep/100.0 : maData.mfMajorStep;
-    lclSetValueOrClearAny( rIncrementData.Distance, fMajorStep, bAutoMajor );
-    // minor increment
-    Sequence< SubIncrement >& rSubIncrementSeq = rIncrementData.SubIncrements;
-    rSubIncrementSeq.realloc( 1 );
-    Any& rIntervalCount = rSubIncrementSeq[ 0 ].IntervalCount;
-    if( bLogScale )
-    {
-        rIntervalCount <<= sal_Int32( 10 );
-    }
-    else
-    {
-        sal_Int32 nCount = 0;
-        if( !bAutoMajor && !bAutoMinor && (0.0 < maData.mfMinorStep) && (maData.mfMinorStep <= maData.mfMajorStep) )
-        {
-            double fCount = maData.mfMajorStep / maData.mfMinorStep + 0.5;
-            if( fCount < 1001.0 )
-                nCount = static_cast< sal_Int32 >( fCount );
-        }
-        lclSetValueOrClearAny( rIntervalCount, nCount, nCount == 0 );
-    }
-
-    // reverse order
-    namespace cssc2 = ::com::sun::star::chart2;
-    bool bReverse = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_REVERSE ) != bMirrorOrient;
-    rScaleData.Orientation = bReverse ? cssc2::AxisOrientation_REVERSE : cssc2::AxisOrientation_MATHEMATICAL;
-}
-
-void XclImpChValueRange::ConvertAxisPosition( ScfPropertySet& rPropSet ) const
-{
-    bool bMaxCross = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_MAXCROSS );
-    bool bAutoCross = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_AUTOCROSS );
-    bool bLogScale = ::get_flag( maData.mnFlags, EXC_CHVALUERANGE_LOGSCALE );
-
-    // crossing mode (max-cross flag overrides other crossing settings)
-    namespace cssc = ::com::sun::star::chart;
-    cssc::ChartAxisPosition eAxisPos = bMaxCross ? cssc::ChartAxisPosition_END : cssc::ChartAxisPosition_VALUE;
-    rPropSet.SetProperty( EXC_CHPROP_CROSSOVERPOSITION, eAxisPos );
-
-    // crossing position
-    double fCrossingPos = bAutoCross ? 0.0 : maData.mfCross;
-    if( bLogScale ) fCrossingPos = pow( 10.0, fCrossingPos );
-    rPropSet.SetProperty( EXC_CHPROP_CROSSOVERVALUE, fCrossingPos );
-}
-
-// ----------------------------------------------------------------------------
-
-namespace {
-
-sal_Int32 lclGetApiTickmarks( sal_uInt8 nXclTickPos )
-{
-    using namespace ::com::sun::star::chart2::TickmarkStyle;
-    sal_Int32 nApiTickmarks = NONE;
-    ::set_flag( nApiTickmarks, INNER, ::get_flag( nXclTickPos, EXC_CHTICK_INSIDE ) );
-    ::set_flag( nApiTickmarks, OUTER, ::get_flag( nXclTickPos, EXC_CHTICK_OUTSIDE ) );
-    return nApiTickmarks;
-}
-
-::com::sun::star::chart::ChartAxisLabelPosition lclGetApiLabelPosition( sal_Int8 nXclLabelPos )
-{
-    using namespace ::com::sun::star::chart;
-    switch( nXclLabelPos )
-    {
-        case EXC_CHTICK_LOW:    return ChartAxisLabelPosition_OUTSIDE_START;
-        case EXC_CHTICK_HIGH:   return ChartAxisLabelPosition_OUTSIDE_END;
-        case EXC_CHTICK_NEXT:   return ChartAxisLabelPosition_NEAR_AXIS;
-    }
-    return ChartAxisLabelPosition_NEAR_AXIS;
-}
-
-} // namespace
-
-XclImpChTick::XclImpChTick( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChTick::ReadChTick( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnMajor
-            >> maData.mnMinor
-            >> maData.mnLabelPos
-            >> maData.mnBackMode
-            >> maData.maRect
-            >> maData.maTextColor
-            >> maData.mnFlags;
-
-    if( GetBiff() == EXC_BIFF8 )
-    {
-        // #116397# BIFF8: index into palette used instead of RGB data
-        maData.maTextColor = GetPalette().GetColor( rStrm.ReaduInt16() );
-        // rotation
-        rStrm >> maData.mnRotation;
-    }
-    else
-    {
-        // BIFF2-BIFF7: get rotation from text orientation
-        sal_uInt8 nOrient = ::extract_value< sal_uInt8 >( maData.mnFlags, 2, 3 );
-        maData.mnRotation = XclTools::GetXclRotFromOrient( nOrient );
-    }
-}
-
-Color XclImpChTick::GetFontColor() const
-{
-    return ::get_flag( maData.mnFlags, EXC_CHTICK_AUTOCOLOR ) ? GetFontAutoColor() : maData.maTextColor;
-}
-
-sal_uInt16 XclImpChTick::GetRotation() const
-{
-    return ::get_flag( maData.mnFlags, EXC_CHTICK_AUTOROT ) ? EXC_CHART_AUTOROTATION : maData.mnRotation;
-}
-
-void XclImpChTick::Convert( ScfPropertySet& rPropSet ) const
-{
-    rPropSet.SetProperty( EXC_CHPROP_MAJORTICKS, lclGetApiTickmarks( maData.mnMajor ) );
-    rPropSet.SetProperty( EXC_CHPROP_MINORTICKS, lclGetApiTickmarks( maData.mnMinor ) );
-    rPropSet.SetProperty( EXC_CHPROP_LABELPOSITION, lclGetApiLabelPosition( maData.mnLabelPos ) );
-    rPropSet.SetProperty( EXC_CHPROP_MARKPOSITION, ::com::sun::star::chart::ChartAxisMarkPosition_AT_AXIS );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChAxis::XclImpChAxis( const XclImpChRoot& rRoot, sal_uInt16 nAxisType ) :
-    XclImpChRoot( rRoot ),
-    mnNumFmtIdx( EXC_FORMAT_NOTFOUND )
-{
-    maData.mnType = nAxisType;
-}
-
-void XclImpChAxis::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnType >> maData.maRect;
-}
-
-void XclImpChAxis::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHLABELRANGE:
-            mxLabelRange.reset( new XclImpChLabelRange( GetChRoot() ) );
-            mxLabelRange->ReadChLabelRange( rStrm );
-        break;
-        case EXC_ID_CHVALUERANGE:
-            mxValueRange.reset( new XclImpChValueRange( GetChRoot() ) );
-            mxValueRange->ReadChValueRange( rStrm );
-        break;
-        case EXC_ID_CHFORMAT:
-            rStrm >> mnNumFmtIdx;
-        break;
-        case EXC_ID_CHTICK:
-            mxTick.reset( new XclImpChTick( GetChRoot() ) );
-            mxTick->ReadChTick( rStrm );
-        break;
-        case EXC_ID_CHFONT:
-            mxFont.reset( new XclImpChFont );
-            mxFont->ReadChFont( rStrm );
-        break;
-        case EXC_ID_CHAXISLINE:
-            ReadChAxisLine( rStrm );
-        break;
-    }
-}
-
-void XclImpChAxis::Finalize()
-{
-    // add default scaling, needed e.g. to adjust rotation direction of pie and radar charts
-    if( !mxLabelRange )
-        mxLabelRange.reset( new XclImpChLabelRange( GetChRoot() ) );
-    if( !mxValueRange )
-        mxValueRange.reset( new XclImpChValueRange( GetChRoot() ) );
-    // remove invisible grid lines completely
-    if( mxMajorGrid.is() && !mxMajorGrid->HasLine() )
-        mxMajorGrid.reset();
-    if( mxMinorGrid.is() && !mxMinorGrid->HasLine() )
-        mxMinorGrid.reset();
-    // default tick settings different in OOChart and Excel
-    if( !mxTick )
-        mxTick.reset( new XclImpChTick( GetChRoot() ) );
-    // #i4140# different default axis line color
-    if( !mxAxisLine )
-    {
-        XclChLineFormat aLineFmt;
-        // set "show axis" flag, default if line format record is missing
-        ::set_flag( aLineFmt.mnFlags, EXC_CHLINEFORMAT_SHOWAXIS );
-        mxAxisLine.reset( new XclImpChLineFormat( aLineFmt ) );
-    }
-    // add wall/floor frame for 3d charts
-    if( !mxWallFrame )
-        CreateWallFrame();
-}
-
-sal_uInt16 XclImpChAxis::GetFontIndex() const
-{
-    return mxFont.is() ? mxFont->GetFontIndex() : EXC_FONT_NOTFOUND;
-}
-
-Color XclImpChAxis::GetFontColor() const
-{
-    return mxTick.is() ? mxTick->GetFontColor() : GetFontAutoColor();
-}
-
-sal_uInt16 XclImpChAxis::GetRotation() const
-{
-    return mxTick.is() ? mxTick->GetRotation() : EXC_CHART_AUTOROTATION;
-}
-
-Reference< XAxis > XclImpChAxis::CreateAxis( const XclImpChTypeGroup& rTypeGroup, const XclImpChAxis* pCrossingAxis ) const
-{
-    namespace cssc2 = ::com::sun::star::chart2;
-
-    // create the axis object (always)
-    Reference< XAxis > xAxis( ScfApiHelper::CreateInstance( SERVICE_CHART2_AXIS ), UNO_QUERY );
-    if( xAxis.is() )
-    {
-        ScfPropertySet aAxisProp( xAxis );
-        // #i58688# axis enabled
-        aAxisProp.SetBoolProperty( EXC_CHPROP_SHOW, IsActivated() );
-
-        // axis line properties
-        if( mxAxisLine.is() )
-            mxAxisLine->Convert( GetChRoot(), aAxisProp, EXC_CHOBJTYPE_AXISLINE );
-        // axis ticks properties
-        if( mxTick.is() )
-            mxTick->Convert( aAxisProp );
-
-        // axis caption text --------------------------------------------------
-
-        // radar charts disable their category labels via chart type, not via axis
-        bool bHasLabels = HasLabels() &&
-            ((GetAxisType() != EXC_CHAXIS_X) || rTypeGroup.HasCategoryLabels());
-        aAxisProp.SetBoolProperty( EXC_CHPROP_DISPLAYLABELS, bHasLabels );
-        if( bHasLabels )
-        {
-            // font settings from CHFONT record or from default text
-            if( mxFont.is() )
-                ConvertFontBase( GetChRoot(), aAxisProp );
-            else if( const XclImpChText* pDefText = GetChartData().GetDefaultText( EXC_CHTEXTTYPE_AXISLABEL ).get() )
-                pDefText->ConvertFont( aAxisProp );
-            // label text rotation
-            ConvertRotationBase( GetChRoot(), aAxisProp, true );
-            // number format
-            sal_uInt32 nScNumFmt = GetNumFmtBuffer().GetScFormat( mnNumFmtIdx );
-            if( nScNumFmt != NUMBERFORMAT_ENTRY_NOT_FOUND )
-                aAxisProp.SetProperty( EXC_CHPROP_NUMBERFORMAT, static_cast< sal_Int32 >( nScNumFmt ) );
-        }
-
-        // axis scaling and increment -----------------------------------------
-
-        const XclChExtTypeInfo& rTypeInfo = rTypeGroup.GetTypeInfo();
-        ScaleData aScaleData = xAxis->getScaleData();
-        // set axis type
-        switch( GetAxisType() )
-        {
-            case EXC_CHAXIS_X:
-                if( rTypeInfo.mbCategoryAxis )
-                {
-                    aScaleData.AxisType = cssc2::AxisType::CATEGORY;
-                    aScaleData.Categories = rTypeGroup.CreateCategSequence();
-                }
-                else
-                    aScaleData.AxisType = cssc2::AxisType::REALNUMBER;
-            break;
-            case EXC_CHAXIS_Y:
-                aScaleData.AxisType = rTypeGroup.IsPercent() ?
-                    cssc2::AxisType::PERCENT : cssc2::AxisType::REALNUMBER;
-            break;
-            case EXC_CHAXIS_Z:
-                aScaleData.AxisType = cssc2::AxisType::SERIES;
-            break;
-        }
-        // axis scaling settings, dependent on axis type
-        switch( aScaleData.AxisType )
-        {
-            case cssc2::AxisType::CATEGORY:
-            case cssc2::AxisType::SERIES:
-                // #i71684# radar charts have reversed rotation direction
-                mxLabelRange->Convert( aAxisProp, aScaleData, rTypeInfo.meTypeCateg == EXC_CHTYPECATEG_RADAR );
-            break;
-            case cssc2::AxisType::REALNUMBER:
-            case cssc2::AxisType::PERCENT:
-            {
-                bool bPercent = (aScaleData.AxisType == cssc2::AxisType::PERCENT);
-                // #i85167# pie/donut charts have reversed rotation direction (at Y axis!)
-                mxValueRange->Convert( aScaleData, rTypeInfo.meTypeCateg == EXC_CHTYPECATEG_PIE, bPercent );
-            }
-            break;
-            default:
-                DBG_ERRORFILE( "XclImpChAxis::CreateAxis - unknown axis type" );
-        }
-
-        /*  Do not set a value to the Origin member anymore (will be done via
-            new axis properties 'CrossoverPosition' and 'CrossoverValue'). */
-        aScaleData.Origin.clear();
-
-        // write back
-        xAxis->setScaleData( aScaleData );
-
-        // grid ---------------------------------------------------------------
-
-        // main grid
-        ScfPropertySet aGridProp( xAxis->getGridProperties() );
-        aGridProp.SetBoolProperty( EXC_CHPROP_SHOW, HasMajorGrid() );
-        if( mxMajorGrid.is() )
-            mxMajorGrid->Convert( GetChRoot(), aGridProp, EXC_CHOBJTYPE_GRIDLINE );
-        // sub grid
-        Sequence< Reference< XPropertySet > > aSubGridPropSeq = xAxis->getSubGridProperties();
-        if( aSubGridPropSeq.hasElements() )
-        {
-            ScfPropertySet aSubGridProp( aSubGridPropSeq[ 0 ] );
-            aSubGridProp.SetBoolProperty( EXC_CHPROP_SHOW, HasMinorGrid() );
-            if( mxMinorGrid.is() )
-                mxMinorGrid->Convert( GetChRoot(), aSubGridProp, EXC_CHOBJTYPE_GRIDLINE );
-        }
-
-        // position of crossing axis ------------------------------------------
-
-        if( pCrossingAxis )
-            pCrossingAxis->ConvertAxisPosition( aAxisProp, rTypeGroup );
-    }
-    return xAxis;
-}
-
-void XclImpChAxis::ConvertWall( ScfPropertySet& rPropSet ) const
-{
-    if( mxWallFrame.is() )
-        mxWallFrame->Convert( rPropSet );
-}
-
-void XclImpChAxis::ConvertAxisPosition( ScfPropertySet& rPropSet, const XclImpChTypeGroup& rTypeGroup ) const
-{
-    if( ((GetAxisType() == EXC_CHAXIS_X) && rTypeGroup.GetTypeInfo().mbCategoryAxis) || (GetAxisType() == EXC_CHAXIS_Z) )
-        mxLabelRange->ConvertAxisPosition( rPropSet, rTypeGroup.Is3dChart() );
-    else
-        mxValueRange->ConvertAxisPosition( rPropSet );
-}
-
-void XclImpChAxis::ReadChAxisLine( XclImpStream& rStrm )
-{
-    XclImpChLineFormatRef* pxLineFmt = 0;
-    bool bWallFrame = false;
-    switch( rStrm.ReaduInt16() )
-    {
-        case EXC_CHAXISLINE_AXISLINE:   pxLineFmt = &mxAxisLine;    break;
-        case EXC_CHAXISLINE_MAJORGRID:  pxLineFmt = &mxMajorGrid;   break;
-        case EXC_CHAXISLINE_MINORGRID:  pxLineFmt = &mxMinorGrid;   break;
-        case EXC_CHAXISLINE_WALLS:      bWallFrame = true;          break;
-    }
-    if( bWallFrame )
-        CreateWallFrame();
-
-    bool bLoop = pxLineFmt || bWallFrame;
-    while( bLoop )
-    {
-        sal_uInt16 nRecId = rStrm.GetNextRecId();
-        bLoop = ((nRecId == EXC_ID_CHLINEFORMAT) ||
-                 (nRecId == EXC_ID_CHAREAFORMAT) ||
-                 (nRecId == EXC_ID_CHESCHERFORMAT))
-                 && rStrm.StartNextRecord();
-        if( bLoop )
-        {
-            if( pxLineFmt && (nRecId == EXC_ID_CHLINEFORMAT) )
-            {
-                pxLineFmt->reset( new XclImpChLineFormat );
-                (*pxLineFmt)->ReadChLineFormat( rStrm );
-            }
-            else if( bWallFrame && mxWallFrame.is() )
-            {
-                mxWallFrame->ReadSubRecord( rStrm );
-            }
-        }
-    }
-}
-
-void XclImpChAxis::CreateWallFrame()
-{
-    switch( GetAxisType() )
-    {
-        case EXC_CHAXIS_X:
-            mxWallFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_WALL3D ) );
-        break;
-        case EXC_CHAXIS_Y:
-            mxWallFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_FLOOR3D ) );
-        break;
-        default:
-            mxWallFrame.reset();
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChAxesSet::XclImpChAxesSet( const XclImpChRoot& rRoot, sal_uInt16 nAxesSetId ) :
-    XclImpChRoot( rRoot )
-{
-    maData.mnAxesSetId = nAxesSetId;
-}
-
-void XclImpChAxesSet::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnAxesSetId >> maData.maRect;
-}
-
-void XclImpChAxesSet::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHFRAMEPOS:
-            mxPos.reset( new XclImpChFramePos );
-            mxPos->ReadChFramePos( rStrm );
-        break;
-        case EXC_ID_CHAXIS:
-            ReadChAxis( rStrm );
-        break;
-        case EXC_ID_CHTEXT:
-            ReadChText( rStrm );
-        break;
-        case EXC_ID_CHPLOTFRAME:
-            ReadChPlotFrame( rStrm );
-        break;
-        case EXC_ID_CHTYPEGROUP:
-            ReadChTypeGroup( rStrm );
-        break;
-    }
-}
-
-void XclImpChAxesSet::Finalize()
-{
-    if( IsValidAxesSet() )
-    {
-        // finalize chart type groups, erase empty groups without series
-        XclImpChTypeGroupMap aValidGroups;
-        for( XclImpChTypeGroupMap::const_iterator aIt = maTypeGroups.begin(), aEnd = maTypeGroups.end(); aIt != aEnd; ++aIt )
-        {
-            XclImpChTypeGroupRef xTypeGroup = aIt->second;
-            xTypeGroup->Finalize();
-            if( xTypeGroup->IsValidGroup() )
-                aValidGroups[ aIt->first ] = xTypeGroup;
-        }
-        maTypeGroups.swap( aValidGroups );
-    }
-
-    // invalid chart type groups are deleted now, check again with IsValidAxesSet()
-    if( IsValidAxesSet() )
-    {
-        // always create missing axis objects
-        if( !mxXAxis )
-            mxXAxis.reset( new XclImpChAxis( GetChRoot(), EXC_CHAXIS_X ) );
-        if( !mxYAxis )
-            mxYAxis.reset( new XclImpChAxis( GetChRoot(), EXC_CHAXIS_Y ) );
-        if( !mxZAxis && GetFirstTypeGroup()->Is3dDeepChart() )
-            mxZAxis.reset( new XclImpChAxis( GetChRoot(), EXC_CHAXIS_Z ) );
-
-        // finalize axes
-        if( mxXAxis.is() ) mxXAxis->Finalize();
-        if( mxYAxis.is() ) mxYAxis->Finalize();
-        if( mxZAxis.is() ) mxZAxis->Finalize();
-
-        // finalize axis titles
-        XclImpChTextRef xDefText = GetChartData().GetDefaultText( EXC_CHTEXTTYPE_AXISTITLE );
-        lclFinalizeTitle( mxXAxisTitle, xDefText );
-        lclFinalizeTitle( mxYAxisTitle, xDefText );
-        lclFinalizeTitle( mxZAxisTitle, xDefText );
-
-        // #i47745# missing plot frame -> invisible border and area
-        if( !mxPlotFrame )
-            mxPlotFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_PLOTFRAME ) );
-    }
-}
-
-XclImpChTypeGroupRef XclImpChAxesSet::GetFirstTypeGroup() const
-{
-    XclImpChTypeGroupRef xTypeGroup;
-    if( !maTypeGroups.empty() )
-        xTypeGroup = maTypeGroups.begin()->second;
-    return xTypeGroup;
-}
-
-XclImpChLegendRef XclImpChAxesSet::GetLegend() const
-{
-    XclImpChLegendRef xLegend;
-    for( XclImpChTypeGroupMap::const_iterator aIt = maTypeGroups.begin(), aEnd = maTypeGroups.end(); !xLegend && (aIt != aEnd); ++aIt )
-        xLegend = aIt->second->GetLegend();
-    return xLegend;
-}
-
-const String& XclImpChAxesSet::GetSingleSeriesTitle() const
-{
-    return (maTypeGroups.size() == 1) ? maTypeGroups.begin()->second->GetSingleSeriesTitle() : String::EmptyString();
-}
-
-void XclImpChAxesSet::Convert( Reference< XDiagram > xDiagram ) const
-{
-    if( IsValidAxesSet() && xDiagram.is() )
-    {
-        // diagram background formatting
-        if( GetAxesSetId() == EXC_CHAXESSET_PRIMARY )
-            ConvertBackground( xDiagram );
-
-        // create the coordinate system, this inserts all chart types and series
-        Reference< XCoordinateSystem > xCoordSystem = CreateCoordSystem( xDiagram );
-        if( xCoordSystem.is() )
-        {
-            // insert coordinate system, if not already done
-            try
-            {
-                Reference< XCoordinateSystemContainer > xCoordSystemCont( xDiagram, UNO_QUERY_THROW );
-                Sequence< Reference< XCoordinateSystem > > aCoordSystems = xCoordSystemCont->getCoordinateSystems();
-                if( aCoordSystems.getLength() == 0 )
-                    xCoordSystemCont->addCoordinateSystem( xCoordSystem );
-            }
-            catch( Exception& )
-            {
-                DBG_ERRORFILE( "XclImpChAxesSet::Convert - cannot insert coordinate system" );
-            }
-
-            // create the axes with grids and axis titles and insert them into the diagram
-            ConvertAxis( mxXAxis, mxXAxisTitle, xCoordSystem, mxYAxis.get() );
-            ConvertAxis( mxYAxis, mxYAxisTitle, xCoordSystem, mxXAxis.get() );
-            ConvertAxis( mxZAxis, mxZAxisTitle, xCoordSystem, 0 );
-        }
-    }
-}
-
-void XclImpChAxesSet::ReadChAxis( XclImpStream& rStrm )
-{
-    XclImpChAxisRef xAxis( new XclImpChAxis( GetChRoot() ) );
-    xAxis->ReadRecordGroup( rStrm );
-
-    switch( xAxis->GetAxisType() )
-    {
-        case EXC_CHAXIS_X:  mxXAxis = xAxis;    break;
-        case EXC_CHAXIS_Y:  mxYAxis = xAxis;    break;
-        case EXC_CHAXIS_Z:  mxZAxis = xAxis;    break;
-    }
-}
-
-void XclImpChAxesSet::ReadChText( XclImpStream& rStrm )
-{
-    XclImpChTextRef xText( new XclImpChText( GetChRoot() ) );
-    xText->ReadRecordGroup( rStrm );
-
-    switch( xText->GetLinkTarget() )
-    {
-        case EXC_CHOBJLINK_XAXIS:   mxXAxisTitle = xText;   break;
-        case EXC_CHOBJLINK_YAXIS:   mxYAxisTitle = xText;   break;
-        case EXC_CHOBJLINK_ZAXIS:   mxZAxisTitle = xText;   break;
-    }
-}
-
-void XclImpChAxesSet::ReadChPlotFrame( XclImpStream& rStrm )
-{
-    if( (rStrm.GetNextRecId() == EXC_ID_CHFRAME) && rStrm.StartNextRecord() )
-    {
-        mxPlotFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_PLOTFRAME ) );
-        mxPlotFrame->ReadRecordGroup( rStrm );
-    }
-}
-
-void XclImpChAxesSet::ReadChTypeGroup( XclImpStream& rStrm )
-{
-    XclImpChTypeGroupRef xTypeGroup( new XclImpChTypeGroup( GetChRoot() ) );
-    xTypeGroup->ReadRecordGroup( rStrm );
-    maTypeGroups[ xTypeGroup->GetGroupIdx() ] = xTypeGroup;
-}
-
-Reference< XCoordinateSystem > XclImpChAxesSet::CreateCoordSystem( Reference< XDiagram > xDiagram ) const
-{
-    Reference< XCoordinateSystem > xCoordSystem;
-
-    /*  Try to get existing ccordinate system. For now, all series from primary
-        and secondary axes sets are inserted into one coordinate system. Later,
-        this should be changed to use one coordinate system for each axes set. */
-    Reference< XCoordinateSystemContainer > xCoordSystemCont( xDiagram, UNO_QUERY );
-    if( xCoordSystemCont.is() )
-    {
-        Sequence< Reference< XCoordinateSystem > > aCoordSystems = xCoordSystemCont->getCoordinateSystems();
-        DBG_ASSERT( aCoordSystems.getLength() <= 1, "XclImpChAxesSet::CreateCoordSystem - too many existing coordinate systems" );
-        if( aCoordSystems.getLength() > 0 )
-            xCoordSystem = aCoordSystems[ 0 ];
-    }
-
-    // create the coordinate system according to the first chart type
-    if( !xCoordSystem.is() )
-    {
-        XclImpChTypeGroupRef xTypeGroup = GetFirstTypeGroup();
-        if( xTypeGroup.is() )
-        {
-            xCoordSystem = xTypeGroup->CreateCoordSystem();
-            // convert 3d chart settings
-            ScfPropertySet aDiaProp( xDiagram );
-            xTypeGroup->ConvertChart3d( aDiaProp );
-        }
-    }
-
-    /*  Create XChartType objects for all chart type groups. Each group will
-        add its series to the data provider attached to the chart document. */
-    Reference< XChartTypeContainer > xChartTypeCont( xCoordSystem, UNO_QUERY );
-    if( xChartTypeCont.is() )
-    {
-        sal_Int32 nApiAxesSetIdx = GetApiAxesSetIndex();
-        for( XclImpChTypeGroupMap::const_iterator aIt = maTypeGroups.begin(), aEnd = maTypeGroups.end(); aIt != aEnd; ++aIt )
-        {
-            try
-            {
-                Reference< XChartType > xChartType = aIt->second->CreateChartType( xDiagram, nApiAxesSetIdx );
-                if( xChartType.is() )
-                    xChartTypeCont->addChartType( xChartType );
-            }
-            catch( Exception& )
-            {
-                DBG_ERRORFILE( "XclImpChAxesSet::CreateCoordSystem - cannot add chart type" );
-            }
-        }
-    }
-
-    return xCoordSystem;
-}
-
-void XclImpChAxesSet::ConvertAxis(
-        XclImpChAxisRef xChAxis, XclImpChTextRef xChAxisTitle,
-        Reference< XCoordinateSystem > xCoordSystem, const XclImpChAxis* pCrossingAxis ) const
-{
-    if( xChAxis.is() )
-    {
-        // create and attach the axis object
-        Reference< XAxis > xAxis = CreateAxis( *xChAxis, pCrossingAxis );
-        if( xAxis.is() )
-        {
-            // create and attach the axis title
-            if( xChAxisTitle.is() )
-            {
-                Reference< XTitled > xTitled( xAxis, UNO_QUERY );
-                if( xTitled.is() )
-                    xTitled->setTitleObject( xChAxisTitle->CreateTitle() );
-            }
-
-            // insert axis into coordinate system
-            try
-            {
-                sal_Int32 nApiAxisDim = xChAxis->GetApiAxisDimension();
-                sal_Int32 nApiAxesSetIdx = GetApiAxesSetIndex();
-                xCoordSystem->setAxisByDimension( nApiAxisDim, xAxis, nApiAxesSetIdx );
-            }
-            catch( Exception& )
-            {
-                DBG_ERRORFILE( "XclImpChAxesSet::ConvertAxis - cannot set axis" );
-            }
-        }
-    }
-}
-
-Reference< XAxis > XclImpChAxesSet::CreateAxis( const XclImpChAxis& rChAxis, const XclImpChAxis* pCrossingAxis ) const
-{
-    Reference< XAxis > xAxis;
-    if( const XclImpChTypeGroup* pTypeGroup = GetFirstTypeGroup().get() )
-        xAxis = rChAxis.CreateAxis( *pTypeGroup, pCrossingAxis );
-    return xAxis;
-}
-
-void XclImpChAxesSet::ConvertBackground( Reference< XDiagram > xDiagram ) const
-{
-    XclImpChTypeGroupRef xTypeGroup = GetFirstTypeGroup();
-    if( xTypeGroup.is() && xTypeGroup->Is3dWallChart() )
-    {
-        // wall/floor formatting (3D charts)
-        if( mxXAxis.is() )
-        {
-            ScfPropertySet aWallProp( xDiagram->getWall() );
-            mxXAxis->ConvertWall( aWallProp );
-        }
-        if( mxYAxis.is() )
-        {
-            ScfPropertySet aFloorProp( xDiagram->getFloor() );
-            mxYAxis->ConvertWall( aFloorProp );
-        }
-    }
-    else if( mxPlotFrame.is() )
-    {
-        // diagram background formatting
-        ScfPropertySet aWallProp( xDiagram->getWall() );
-        mxPlotFrame->Convert( aWallProp );
-    }
-}
-
-// The chart object ===========================================================
-
-XclImpChChart::XclImpChChart( const XclImpRoot& rRoot ) :
-    XclImpChRoot( rRoot, this )
-{
-    mxPrimAxesSet.reset( new XclImpChAxesSet( GetChRoot(), EXC_CHAXESSET_PRIMARY ) );
-    mxSecnAxesSet.reset( new XclImpChAxesSet( GetChRoot(), EXC_CHAXESSET_SECONDARY ) );
-}
-
-XclImpChChart::~XclImpChChart()
-{
-}
-
-void XclImpChChart::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    // coordinates are stored as 16.16 fixed point
-    rStrm >> maRect;
-}
-
-void XclImpChChart::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHFRAME:
-            mxFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_BACKGROUND ) );
-            mxFrame->ReadRecordGroup( rStrm );
-        break;
-        case EXC_ID_CHSERIES:
-            ReadChSeries( rStrm );
-        break;
-        case EXC_ID_CHPROPERTIES:
-            ReadChProperties( rStrm );
-        break;
-        case EXC_ID_CHDEFAULTTEXT:
-            ReadChDefaultText( rStrm );
-        break;
-        case EXC_ID_CHAXESSET:
-            ReadChAxesSet( rStrm );
-        break;
-        case EXC_ID_CHTEXT:
-            ReadChText( rStrm );
-        break;
-        case EXC_ID_CHEND:
-            Finalize();     // finalize the entire chart object
-        break;
-    }
-}
-
-void XclImpChChart::ReadChDefaultText( XclImpStream& rStrm )
-{
-    sal_uInt16 nTextId = rStrm.ReaduInt16();
-    if( (rStrm.GetNextRecId() == EXC_ID_CHTEXT) && rStrm.StartNextRecord() )
-    {
-        XclImpChTextRef xText( new XclImpChText( GetChRoot() ) );
-        xText->ReadRecordGroup( rStrm );
-        maDefTexts[ nTextId ] = xText;
-    }
-}
-
-void XclImpChChart::ReadChDataFormat( XclImpStream& rStrm )
-{
-    XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
-    xDataFmt->ReadRecordGroup( rStrm );
-    if( xDataFmt->GetPointPos().mnSeriesIdx <= EXC_CHSERIES_MAXSERIES )
-    {
-        XclImpChDataFormatRef& rxMapFmt = maDataFmts[ xDataFmt->GetPointPos() ];
-        /*  Do not overwrite existing data format group, Excel always uses the
-            first data format group occuring in any CHSERIES group. */
-        if( !rxMapFmt )
-            rxMapFmt = xDataFmt;
-    }
-}
-
-void XclImpChChart::UpdateObjFrame( const XclObjLineData& rLineData, const XclObjFillData& rFillData )
-{
-    if( !mxFrame )
-        mxFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_BACKGROUND ) );
-    mxFrame->UpdateObjFrame( rLineData, rFillData );
-}
-
-XclImpChTypeGroupRef XclImpChChart::GetTypeGroup( sal_uInt16 nGroupIdx ) const
-{
-    XclImpChTypeGroupRef xTypeGroup = mxPrimAxesSet->GetTypeGroup( nGroupIdx );
-    if( !xTypeGroup ) xTypeGroup = mxSecnAxesSet->GetTypeGroup( nGroupIdx );
-    if( !xTypeGroup ) xTypeGroup = mxPrimAxesSet->GetFirstTypeGroup();
-    return xTypeGroup;
-}
-
-XclImpChTextRef XclImpChChart::GetDefaultText( XclChTextType eTextType ) const
-{
-    sal_uInt16 nDefTextId = EXC_CHDEFTEXT_GLOBAL;
-    bool bBiff8 = GetBiff() == EXC_BIFF8;
-    switch( eTextType )
-    {
-        case EXC_CHTEXTTYPE_TITLE:      nDefTextId = EXC_CHDEFTEXT_GLOBAL;                                  break;
-        case EXC_CHTEXTTYPE_LEGEND:     nDefTextId = EXC_CHDEFTEXT_GLOBAL;                                  break;
-        case EXC_CHTEXTTYPE_AXISTITLE:  nDefTextId = bBiff8 ? EXC_CHDEFTEXT_AXESSET : EXC_CHDEFTEXT_GLOBAL; break;
-        case EXC_CHTEXTTYPE_AXISLABEL:  nDefTextId = bBiff8 ? EXC_CHDEFTEXT_AXESSET : EXC_CHDEFTEXT_GLOBAL; break;
-        case EXC_CHTEXTTYPE_DATALABEL:  nDefTextId = bBiff8 ? EXC_CHDEFTEXT_AXESSET : EXC_CHDEFTEXT_GLOBAL; break;
-    }
-    return maDefTexts.get( nDefTextId );
-}
-
-void XclImpChChart::Convert( Reference< XChartDocument > xChartDoc, ScfProgressBar& rProgress, const OUString& rObjName ) const
-{
-    // initialize conversion (locks the model to suppress any internal updates)
-    InitConversion( xChartDoc );
-
-    // chart frame and title
-    if( mxFrame.is() )
-    {
-        ScfPropertySet aFrameProp( xChartDoc->getPageBackground() );
-        mxFrame->Convert( aFrameProp );
-    }
-    if( mxTitle.is() )
-    {
-        Reference< XTitled > xTitled( xChartDoc, UNO_QUERY );
-        Reference< XTitle > xTitle = mxTitle->CreateTitle();
-        if( xTitled.is() && xTitle.is() )
-            xTitled->setTitleObject( xTitle );
-    }
-
-    /*  Create the diagram object and attach it to the chart document. Currently,
-        one diagram is used to carry all coordinate systems and data series. */
-    Reference< XDiagram > xDiagram = CreateDiagram();
-    xChartDoc->setFirstDiagram( xDiagram );
-
-    // coordinate systems and chart types, convert axis settings
-    mxPrimAxesSet->Convert( xDiagram );
-    mxSecnAxesSet->Convert( xDiagram );
-
-    // legend
-    if( xDiagram.is() && mxLegend.is() )
-        xDiagram->setLegend( mxLegend->CreateLegend() );
-
-    // set the IncludeHiddenCells property via the old API as only this ensures that the data provider and al created sequences get this flag correctly
-    Reference< com::sun::star::chart::XChartDocument > xStandardApiChartDoc( xChartDoc, UNO_QUERY );
-    if( xStandardApiChartDoc.is() )
-    {
-        ScfPropertySet aDiagramProp( xStandardApiChartDoc->getDiagram() );
-        bool bShowVisCells = (maProps.mnFlags & EXC_CHPROPS_SHOWVISIBLEONLY);
-        aDiagramProp.SetBoolProperty( EXC_CHPROP_INCLUDEHIDDENCELLS, !bShowVisCells  );
-    }
-
-    // unlock the model
-    FinishConversion( rProgress );
-
-    ScDocument* pDoc = &GetRoot().GetDoc();
-    ScChartListenerCollection* pChartCollection = pDoc->GetChartListenerCollection();
-    if (pChartCollection)
-    {
-        // Now, start listening to this chart.
-        ::std::auto_ptr< vector<ScSharedTokenRef> > pRefTokens(new vector<ScSharedTokenRef>);
-        for (XclImpChSeriesVec::const_iterator itr = maSeries.begin(), itrEnd = maSeries.end(); itr != itrEnd; ++itr)
-        {
-            const XclImpChSeriesRef& rSeries = *itr;
-            rSeries->FillAllSourceLinks(*pRefTokens);
-        }
-        if (!pRefTokens->empty())
-        {
-            ::std::auto_ptr<ScChartListener> pListener(
-                new ScChartListener(rObjName, pDoc, pRefTokens.release()));
-            pListener->SetDirty(true);
-            pListener->StartListeningTo();
-            pChartCollection->Insert(pListener.release());
-
-        }
-    }
-}
-
-void XclImpChChart::ReadChSeries( XclImpStream& rStrm )
-{
-    sal_uInt16 nNewSeriesIdx = static_cast< sal_uInt16 >( maSeries.size() );
-    XclImpChSeriesRef xSeries( new XclImpChSeries( GetChRoot(), nNewSeriesIdx ) );
-    xSeries->ReadRecordGroup( rStrm );
-    maSeries.push_back( xSeries );
-}
-
-void XclImpChChart::ReadChProperties( XclImpStream& rStrm )
-{
-    rStrm >> maProps.mnFlags >> maProps.mnEmptyMode;
-}
-
-void XclImpChChart::ReadChAxesSet( XclImpStream& rStrm )
-{
-    XclImpChAxesSetRef xAxesSet( new XclImpChAxesSet( GetChRoot(), EXC_CHAXESSET_NONE ) );
-    xAxesSet->ReadRecordGroup( rStrm );
-    switch( xAxesSet->GetAxesSetId() )
-    {
-        case EXC_CHAXESSET_PRIMARY:     mxPrimAxesSet = xAxesSet;   break;
-        case EXC_CHAXESSET_SECONDARY:   mxSecnAxesSet = xAxesSet;   break;
-    }
-}
-
-void XclImpChChart::ReadChText( XclImpStream& rStrm )
-{
-    XclImpChTextRef xText( new XclImpChText( GetChRoot() ) );
-    xText->ReadRecordGroup( rStrm );
-    switch( xText->GetLinkTarget() )
-    {
-        case EXC_CHOBJLINK_TITLE:
-            mxTitle = xText;
-        break;
-        case EXC_CHOBJLINK_DATA:
-        {
-            sal_uInt16 nSeriesIdx = xText->GetPointPos().mnSeriesIdx;
-            if( nSeriesIdx < maSeries.size() )
-                maSeries[ nSeriesIdx ]->SetDataLabel( xText );
-        }
-        break;
-    }
-}
-
-void XclImpChChart::Finalize()
-{
-    // finalize series (must be done first)
-    FinalizeSeries();
-    // #i49218# legend may be attached to primary or secondary axes set
-    mxLegend = mxPrimAxesSet->GetLegend();
-    if( !mxLegend )
-        mxLegend = mxSecnAxesSet->GetLegend();
-    if( mxLegend.is() )
-        mxLegend->Finalize();
-    // axes sets, updates chart type group default formats -> must be called before FinalizeDataFormats()
-    mxPrimAxesSet->Finalize();
-    mxSecnAxesSet->Finalize();
-    // formatting of all series
-    FinalizeDataFormats();
-    // #i47745# missing frame -> invisible border and area
-    if( !mxFrame )
-        mxFrame.reset( new XclImpChFrame( GetChRoot(), EXC_CHOBJTYPE_BACKGROUND ) );
-    // chart title
-    FinalizeTitle();
-}
-
-void XclImpChChart::FinalizeSeries()
-{
-    for( XclImpChSeriesVec::iterator aSIt = maSeries.begin(), aSEnd = maSeries.end(); aSIt != aSEnd; ++aSIt )
-    {
-        XclImpChSeriesRef xSeries = *aSIt;
-        if( xSeries->HasParentSeries() )
-        {
-            /*  Process child series (trend lines and error bars). Data of
-                child series will be set at the connected parent series. */
-            if( xSeries->GetParentIdx() < maSeries.size() )
-                maSeries[ xSeries->GetParentIdx() ]->AddChildSeries( *xSeries );
-        }
-        else
-        {
-            // insert the series into the related chart type group
-            if( XclImpChTypeGroup* pTypeGroup = GetTypeGroup( xSeries->GetGroupIdx() ).get() )
-                pTypeGroup->AddSeries( xSeries );
-        }
-    }
-}
-
-void XclImpChChart::FinalizeDataFormats()
-{
-    /*  #i51639# (part 1): CHDATAFORMAT groups are part of CHSERIES groups.
-        Each CHDATAFORMAT group specifies the series and data point it is
-        assigned to. This makes it possible to have a data format that is
-        related to another series, e.g. a CHDATAFORMAT group for series 2 is
-        part of a CHSERIES group that describes series 1. Therefore the chart
-        itself has collected all CHDATAFORMAT groups to be able to store data
-        format groups for series that have not been imported at that time. This
-        loop finally assigns these groups to the related series. */
-    for( XclImpChDataFormatMap::const_iterator aMIt = maDataFmts.begin(), aMEnd = maDataFmts.end(); aMIt != aMEnd; ++aMIt )
-    {
-        sal_uInt16 nSeriesIdx = aMIt->first.mnSeriesIdx;
-        if( nSeriesIdx < maSeries.size() )
-            maSeries[ nSeriesIdx ]->SetDataFormat( aMIt->second );
-    }
-
-    /*  #i51639# (part 2): Finalize data formats of all series. This adds for
-        example missing CHDATAFORMAT groups for entire series that are needed
-        for automatic colors of lines and areas. */
-    for( XclImpChSeriesVec::iterator aVIt = maSeries.begin(), aVEnd = maSeries.end(); aVIt != aVEnd; ++aVIt )
-        (*aVIt)->FinalizeDataFormats();
-}
-
-void XclImpChChart::FinalizeTitle()
-{
-    if( (!mxTitle || (!mxTitle->IsDeleted() && !mxTitle->HasString())) && !mxSecnAxesSet->IsValidAxesSet() )
-    {
-        /*  Chart title is auto-generated from series title, if there is only
-            one series with title in the chart. */
-        const String& rSerTitle = mxPrimAxesSet->GetSingleSeriesTitle();
-        if( rSerTitle.Len() > 0 )
-        {
-            if( !mxTitle )
-                mxTitle.reset( new XclImpChText( GetChRoot() ) );
-            mxTitle->SetString( rSerTitle );
-        }
-    }
-
-    // will reset mxTitle, if it does not contain a string
-    lclFinalizeTitle( mxTitle, GetDefaultText( EXC_CHTEXTTYPE_TITLE ) );
-}
-
-Reference< XDiagram > XclImpChChart::CreateDiagram() const
-{
-    // create a diagram object
-    Reference< XDiagram > xDiagram( ScfApiHelper::CreateInstance( SERVICE_CHART2_DIAGRAM ), UNO_QUERY );
-
-    // convert global chart settings
-    ScfPropertySet aDiaProp( xDiagram );
-
-    // treatment of missing values
-    using namespace ::com::sun::star::chart::MissingValueTreatment;
-    sal_Int32 nMissingValues = LEAVE_GAP;
-    switch( maProps.mnEmptyMode )
-    {
-        case EXC_CHPROPS_EMPTY_SKIP:        nMissingValues = LEAVE_GAP; break;
-        case EXC_CHPROPS_EMPTY_ZERO:        nMissingValues = USE_ZERO;  break;
-        case EXC_CHPROPS_EMPTY_INTERPOLATE: nMissingValues = CONTINUE;  break;
-    }
-    aDiaProp.SetProperty( EXC_CHPROP_MISSINGVALUETREATMENT, nMissingValues );
-
-    return xDiagram;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChart::XclImpChart( const XclImpRoot& rRoot, bool bOwnTab ) :
-    XclImpRoot( rRoot ),
-    mbOwnTab( bOwnTab ),
-    mbIsPivotChart( false )
-{
-}
-
-void XclImpChart::ReadChartSubStream( XclImpStream& rStrm )
-{
-    XclImpPageSettings& rPageSett = GetPageSettings();
-    XclImpTabViewSettings& rTabViewSett = GetTabViewSettings();
-
-    bool bLoop = true;
-    while( bLoop && rStrm.StartNextRecord() )
-    {
-        // page settings - only for charts in entire sheet
-        if( mbOwnTab ) switch( rStrm.GetRecId() )
-        {
-            case EXC_ID_HORPAGEBREAKS:
-            case EXC_ID_VERPAGEBREAKS:  rPageSett.ReadPageBreaks( rStrm );      break;
-            case EXC_ID_HEADER:
-            case EXC_ID_FOOTER:         rPageSett.ReadHeaderFooter( rStrm );    break;
-            case EXC_ID_LEFTMARGIN:
-            case EXC_ID_RIGHTMARGIN:
-            case EXC_ID_TOPMARGIN:
-            case EXC_ID_BOTTOMMARGIN:   rPageSett.ReadMargin( rStrm );          break;
-            case EXC_ID_PRINTHEADERS:   rPageSett.ReadPrintHeaders( rStrm );    break;
-            case EXC_ID_PRINTGRIDLINES: rPageSett.ReadPrintGridLines( rStrm );  break;
-            case EXC_ID_HCENTER:
-            case EXC_ID_VCENTER:        rPageSett.ReadCenter( rStrm );          break;
-            case EXC_ID_SETUP:          rPageSett.ReadSetup( rStrm );           break;
-            case EXC_ID8_IMGDATA:       rPageSett.ReadImgData( rStrm );         break;
-
-            case EXC_ID_WINDOW2:        rTabViewSett.ReadWindow2( rStrm, true );break;
-            case EXC_ID_SCL:            rTabViewSett.ReadScl( rStrm );          break;
-            case EXC_ID_SHEETEXT: //0x0862
-            {
-                XclImpPalette& rPal = GetPalette();
-                rTabViewSett.ReadTabBgColor( rStrm,  rPal);
-            }
-            break;
-        }
-
-        switch( rStrm.GetRecId() )
-        {
-            case EXC_ID_EOF:            bLoop = false;                          break;
-
-            // #i31882# ignore embedded chart objects
-            case EXC_ID2_BOF:
-            case EXC_ID3_BOF:
-            case EXC_ID4_BOF:
-            case EXC_ID5_BOF:           XclTools::SkipSubStream( rStrm );       break;
-
-            case EXC_ID_CHCHART:        ReadChChart( rStrm );                   break;
-            case EXC_ID_OBJ:            GetTracer().TraceChartEmbeddedObj();    break;
-
-            case EXC_ID8_CHPIVOTREF:
-                GetTracer().TracePivotChartExists();
-                mbIsPivotChart = true;
-            break;
-        }
-    }
-}
-
-void XclImpChart::UpdateObjFrame( const XclObjLineData& rLineData, const XclObjFillData& rFillData )
-{
-    if( !mxChartData )
-        mxChartData.reset( new XclImpChChart( GetRoot() ) );
-    mxChartData->UpdateObjFrame( rLineData, rFillData );
-}
-
-sal_Size XclImpChart::GetProgressSize() const
-{
-    return mxChartData.is() ? mxChartData->GetProgressSize() : 0;
-}
-
-void XclImpChart::Convert( Reference< XModel > xModel, ScfProgressBar& rProgress, const OUString& rObjName ) const
-{
-    Reference< XChartDocument > xChartDoc( xModel, UNO_QUERY );
-    if( mxChartData.is() && xChartDoc.is() )
-        mxChartData->Convert( xChartDoc, rProgress, rObjName );
-}
-
-void XclImpChart::ReadChChart( XclImpStream& rStrm )
-{
-    mxChartData.reset( new XclImpChChart( GetRoot() ) );
-    mxChartData->ReadRecordGroup( rStrm );
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xicontent.cxx sc/source/filter/xlsx/xlsx-xicontent.cxx
deleted file mode 100644
index 0470830..0000000
--- sc/source/filter/xlsx/xlsx-xicontent.cxx
+++ /dev/null
@@ -1,1322 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xicontent.cxx,v $
- * $Revision: 1.31.88.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xicontent.hxx"
-#include <sfx2/objsh.hxx>
-#include <sfx2/docfile.hxx>
-#include <tools/urlobj.hxx>
-#include <svx/editeng.hxx>
-#include <svx/editobj.hxx>
-#include <svx/linkmgr.hxx>
-#include <svtools/itemset.hxx>
-#include "scitems.hxx"
-#include <svx/eeitem.hxx>
-#include <svtools/intitem.hxx>
-#include <svtools/stritem.hxx>
-#include <svx/flditem.hxx>
-#include <svx/fhgtitem.hxx>
-#include <svx/wghtitem.hxx>
-#include <svx/udlnitem.hxx>
-#include <svx/postitem.hxx>
-#include <svx/colritem.hxx>
-#include <svx/crsditem.hxx>
-#include "document.hxx"
-#include "editutil.hxx"
-#include "cell.hxx"
-#include "validat.hxx"
-#include "patattr.hxx"
-#include "docpool.hxx"
-#include "rangenam.hxx"
-#include "arealink.hxx"
-#include "stlsheet.hxx"
-#include "scextopt.hxx"
-#include "xlformula.hxx"
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xistyle.hxx"
-#include "xiescher.hxx"
-#include "xiname.hxx"
-
-#include "excform.hxx"
-#include "tabprotection.hxx"
-
-#include <memory>
-
-using ::com::sun::star::uno::Sequence;
-using ::std::auto_ptr;
-
-// Shared string table ========================================================
-
-XclImpSst::XclImpSst( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpSst::ReadSst( XclImpStream& rStrm )
-{
-    sal_uInt32 nStrCount;
-    rStrm.Ignore( 4 );
-    rStrm >> nStrCount;
-    maStrings.clear();
-    maStrings.reserve( static_cast< size_t >( nStrCount ) );
-    while( (nStrCount > 0) && rStrm.IsValid() )
-    {
-        XclImpString aString;
-        aString.Read( rStrm );
-        maStrings.push_back( aString );
-        --nStrCount;
-    }
-}
-
-const XclImpString* XclImpSst::GetString( sal_uInt32 nSstIndex ) const
-{
-    return (nSstIndex < maStrings.size()) ? &maStrings[ nSstIndex ] : 0;
-}
-
-ScBaseCell* XclImpSst::CreateCell( sal_uInt32 nSstIndex, sal_uInt16 nXFIndex ) const
-{
-    ScBaseCell* pCell = 0;
-    if( const XclImpString* pString = GetString( nSstIndex ) )
-        pCell = XclImpStringHelper::CreateCell( *this, *pString, nXFIndex );
-    return pCell;
-}
-
-// Hyperlinks =================================================================
-
-namespace {
-
-/** Reads character array and stores it into rString.
-    @param nChars  Number of following characters (not byte count!).
-    @param b16Bit  true = 16-bit characters, false = 8-bit characters. */
-void lclAppendString32( String& rString, XclImpStream& rStrm, sal_uInt32 nChars, bool b16Bit )
-{
-    sal_uInt16 nReadChars = ulimit_cast< sal_uInt16 >( nChars );
-    rString.Append( rStrm.ReadRawUniString( nReadChars, b16Bit ) );
-    // ignore remaining chars
-    sal_Size nIgnore = nChars - nReadChars;
-    if( b16Bit )
-        nIgnore *= 2;
-    rStrm.Ignore( nIgnore );
-}
-
-/** Reads 32-bit string length and the character array and stores it into rString.
-    @param b16Bit  true = 16-bit characters, false = 8-bit characters. */
-void lclAppendString32( String& rString, XclImpStream& rStrm, bool b16Bit )
-{
-    lclAppendString32( rString, rStrm, rStrm.ReaduInt32(), b16Bit );
-}
-
-/** Reads 32-bit string length and ignores following character array.
-    @param b16Bit  true = 16-bit characters, false = 8-bit characters. */
-void lclIgnoreString32( XclImpStream& rStrm, bool b16Bit )
-{
-    sal_uInt32 nChars;
-    rStrm >> nChars;
-    if( b16Bit )
-        nChars *= 2;
-    rStrm.Ignore( nChars );
-}
-
-/** Converts a path to an absolute path.
-    @param rPath  The source path. The resulting path is returned here.
-    @param nLevel  Number of parent directories to add in front of the path. */
-void lclGetAbsPath( String& rPath, sal_uInt16 nLevel, SfxObjectShell* pDocShell )
-{
-    String aTmpStr;
-    while( nLevel )
-    {
-        aTmpStr.AppendAscii( "../" );
-        --nLevel;
-    }
-    aTmpStr += rPath;
-
-    if( pDocShell )
-    {
-        bool bWasAbs = false;
-        rPath = pDocShell->GetMedium()->GetURLObject().smartRel2Abs( aTmpStr, bWasAbs ).GetMainURL( INetURLObject::NO_DECODE );
-        // full path as stored in SvxURLField must be encoded
-    }
-    else
-        rPath = aTmpStr;
-}
-
-/** Inserts the URL into a text cell. Does not modify value or formula cells. */
-void lclInsertUrl( const XclImpRoot& rRoot, const String& rUrl, SCCOL nScCol, SCROW nScRow, SCTAB nScTab )
-{
-    ScDocument& rDoc = rRoot.GetDoc();
-    ScAddress aScPos( nScCol, nScRow, nScTab );
-    CellType eCellType = rDoc.GetCellType( aScPos );
-    switch( eCellType )
-    {
-        // #i54261# hyperlinks in string cells
-        case CELLTYPE_STRING:
-        case CELLTYPE_EDIT:
-        {
-            String aDisplText;
-            rDoc.GetString( nScCol, nScRow, nScTab, aDisplText );
-            if( !aDisplText.Len() )
-                aDisplText = rUrl;
-
-            ScEditEngineDefaulter& rEE = rRoot.GetEditEngine();
-            SvxURLField aUrlField( rUrl, aDisplText, SVXURLFORMAT_APPDEFAULT );
-
-            const ScEditCell* pEditCell = (eCellType == CELLTYPE_EDIT) ? static_cast< const ScEditCell* >( rDoc.GetCell( aScPos ) ) : 0;
-            const EditTextObject* pEditObj = pEditCell ? pEditCell->GetData() : 0;
-            if( pEditObj )
-            {
-                rEE.SetText( *pEditObj );
-                rEE.QuickInsertField( SvxFieldItem( aUrlField, EE_FEATURE_FIELD ), ESelection( 0, 0, 0xFFFF, 0 ) );
-            }
-            else
-            {
-                rEE.SetText( EMPTY_STRING );
-                rEE.QuickInsertField( SvxFieldItem( aUrlField, EE_FEATURE_FIELD ), ESelection() );
-                if( const ScPatternAttr* pPattern = rDoc.GetPattern( aScPos.Col(), aScPos.Row(), nScTab ) )
-                {
-                    SfxItemSet aItemSet( rEE.GetEmptyItemSet() );
-                    pPattern->FillEditItemSet( &aItemSet );
-                    rEE.QuickSetAttribs( aItemSet, ESelection( 0, 0, 0xFFFF, 0 ) );
-                }
-            }
-            ::std::auto_ptr< EditTextObject > xTextObj( rEE.CreateTextObject() );
-
-            ScEditCell* pCell = new ScEditCell( xTextObj.get(), &rDoc, rEE.GetEditTextObjectPool() );
-            rDoc.PutCell( aScPos, pCell );
-        }
-        break;
-
-        // fix for #i31050# disabled, HYPERLINK is not able to return numeric value (#i91351#)
-#if 0
-        case CELLTYPE_VALUE:
-        {
-            // #i31050# replace number with HYPERLINK function
-            ScTokenArray aTokenArray;
-            aTokenArray.AddOpCode( ocHyperLink );
-            aTokenArray.AddOpCode( ocOpen );
-            aTokenArray.AddString( rUrl );
-            aTokenArray.AddOpCode( ocSep );
-            aTokenArray.AddDouble( rDoc.GetValue( aScPos ) );
-            aTokenArray.AddOpCode( ocClose );
-            rDoc.PutCell( aScPos, new ScFormulaCell( &rDoc, aScPos, &aTokenArray ) );
-        }
-        break;
-#endif
-
-        default:;
-    }
-}
-
-} // namespace
-
-// ----------------------------------------------------------------------------
-
-void XclImpHyperlink::ReadHlink( XclImpStream& rStrm )
-{
-    XclRange aXclRange( ScAddress::UNINITIALIZED );
-    rStrm >> aXclRange;
-    // #i80006# Excel silently ignores invalid hi-byte of column index (TODO: everywhere?)
-    aXclRange.maFirst.mnCol &= 0xFF;
-    aXclRange.maLast.mnCol &= 0xFF;
-    String aString = ReadEmbeddedData( rStrm );
-    if ( aString.Len() > 0 )
-        rStrm.GetRoot().GetXFRangeBuffer().SetHyperlink( aXclRange, aString );
-}
-
-String XclImpHyperlink::ReadEmbeddedData( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    SfxObjectShell* pDocShell = rRoot.GetDocShell();
-
-    DBG_ASSERT_BIFF( rRoot.GetBiff() == EXC_BIFF8 );
-
-    sal_uInt32 nFlags;
-    XclGuid aGuid;
-    rStrm >> aGuid;
-    rStrm.Ignore( 4 );
-    rStrm >> nFlags;
-
-    DBG_ASSERT( aGuid == XclTools::maGuidStdLink, "XclImpHyperlink::ReadEmbeddedData - unknown header GUID" );
-
-    sal_uInt16 nLevel = 0;                  // counter for level to climb down in path
-    ::std::auto_ptr< String > xLongName;    // link / file name
-    ::std::auto_ptr< String > xShortName;   // 8.3-representation of file name
-    ::std::auto_ptr< String > xTextMark;    // text mark
-
-    // description (ignore)
-    if( ::get_flag( nFlags, EXC_HLINK_DESCR ) )
-        lclIgnoreString32( rStrm, true );
-    // target frame (ignore) !! DESCR/FRAME - is this the right order? (never seen them together)
-    if( ::get_flag( nFlags, EXC_HLINK_FRAME ) )
-        lclIgnoreString32( rStrm, true );
-
-    // URL fields are zero-terminated - do not let the stream replace them
-    // in the lclAppendString32() with the '?' character.
-    rStrm.SetNulSubstChar( '\0' );
-
-    // UNC path
-    if( ::get_flag( nFlags, EXC_HLINK_UNC ) )
-    {
-        xLongName.reset( new String );
-        lclAppendString32( *xLongName, rStrm, true );
-        lclGetAbsPath( *xLongName, 0, pDocShell );
-    }
-    // file link or URL
-    else if( ::get_flag( nFlags, EXC_HLINK_BODY ) )
-    {
-        rStrm >> aGuid;
-
-        if( aGuid == XclTools::maGuidFileMoniker )
-        {
-            rStrm >> nLevel;
-            xShortName.reset( new String );
-            lclAppendString32( *xShortName, rStrm, false );
-            rStrm.Ignore( 24 );
-
-            sal_uInt32 nStrLen;
-            rStrm >> nStrLen;
-            if( nStrLen )
-            {
-                rStrm >> nStrLen;
-                nStrLen /= 2;       // it's byte count here...
-                rStrm.Ignore( 2 );
-                xLongName.reset( new String );
-                lclAppendString32( *xLongName, rStrm, nStrLen, true );
-                lclGetAbsPath( *xLongName, nLevel, pDocShell );
-            }
-            else
-                lclGetAbsPath( *xShortName, nLevel, pDocShell );
-        }
-        else if( aGuid == XclTools::maGuidUrlMoniker )
-        {
-            sal_uInt32 nStrLen;
-            rStrm >> nStrLen;
-            nStrLen /= 2;       // it's byte count here...
-            xLongName.reset( new String );
-            lclAppendString32( *xLongName, rStrm, nStrLen, true );
-            if( !::get_flag( nFlags, EXC_HLINK_ABS ) )
-                lclGetAbsPath( *xLongName, 0, pDocShell );
-        }
-        else
-        {
-            DBG_ERRORFILE( "XclImpHyperlink::ReadEmbeddedData - unknown content GUID" );
-        }
-    }
-
-    // text mark
-    if( ::get_flag( nFlags, EXC_HLINK_MARK ) )
-    {
-        xTextMark.reset( new String );
-        lclAppendString32( *xTextMark, rStrm, true );
-    }
-
-    rStrm.SetNulSubstChar();    // back to default
-
-    DBG_ASSERT( rStrm.GetRecLeft() == 0, "XclImpHyperlink::ReadEmbeddedData - record size mismatch" );
-
-    if( !xLongName.get() && xShortName.get() )
-        xLongName = xShortName;
-    else if( !xLongName.get() && xTextMark.get() )
-        xLongName.reset( new String );
-
-    if( xLongName.get() )
-    {
-        if( xTextMark.get() )
-        {
-            if( xLongName->Len() == 0 )
-                xTextMark->SearchAndReplaceAll( '!', '.' );
-            xLongName->Append( '#' );
-            xLongName->Append( *xTextMark );
-        }
-        return *xLongName;
-    }
-    return String::EmptyString();
-}
-
-void XclImpHyperlink::ConvertToValidTabName(String& rUrl)
-{
-    xub_StrLen n = rUrl.Len();
-    if (n < 4)
-        // Needs at least 4 characters.
-        return;
-
-    sal_Unicode c = rUrl.GetChar(0);
-    if (c != sal_Unicode('#'))
-        // the 1st character must be '#'.
-        return;
-
-    String aNewUrl(sal_Unicode('#')), aTabName;
-
-    bool bInQuote = false;
-    bool bQuoteTabName = false;
-    for (xub_StrLen i = 1; i < n; ++i)
-    {
-        c = rUrl.GetChar(i);
-        if (c == sal_Unicode('\''))
-        {
-            if (bInQuote && i+1 < n && rUrl.GetChar(i+1) == sal_Unicode('\''))
-            {
-                // Two consecutive single quotes ('') signify a single literal
-                // quite.  When this occurs, the whole table name needs to be
-                // quoted.
-                bQuoteTabName = true;
-                aTabName.Append(c);
-                aTabName.Append(c);
-                ++i;
-                continue;
-            }
-
-            bInQuote = !bInQuote;
-            if (!bInQuote && aTabName.Len() > 0)
-            {
-                if (bQuoteTabName)
-                    aNewUrl.Append(sal_Unicode('\''));
-                aNewUrl.Append(aTabName);
-                if (bQuoteTabName)
-                    aNewUrl.Append(sal_Unicode('\''));
-            }
-        }
-        else if (bInQuote)
-            aTabName.Append(c);
-        else
-            aNewUrl.Append(c);
-    }
-
-    if (bInQuote)
-        // It should be outside the quotes!
-        return;
-
-    // All is good.  Pass the new URL.
-    rUrl = aNewUrl;
-}
-
-void XclImpHyperlink::InsertUrl( const XclImpRoot& rRoot, const XclRange& rXclRange, const String& rUrl )
-{
-    String aUrl(rUrl);
-    ConvertToValidTabName(aUrl);
-
-    SCTAB nScTab = rRoot.GetCurrScTab();
-    ScRange aScRange( ScAddress::UNINITIALIZED );
-    if( rRoot.GetAddressConverter().ConvertRange( aScRange, rXclRange, nScTab, nScTab, true ) )
-    {
-        SCCOL nScCol1, nScCol2;
-        SCROW nScRow1, nScRow2;
-        aScRange.GetVars( nScCol1, nScRow1, nScTab, nScCol2, nScRow2, nScTab );
-        for( SCCOL nScCol = nScCol1; nScCol <= nScCol2; ++nScCol )
-            for( SCROW nScRow = nScRow1; nScRow <= nScRow2; ++nScRow )
-                lclInsertUrl( rRoot, aUrl, nScCol, nScRow, nScTab );
-    }
-}
-
-// Label ranges ===============================================================
-
-void XclImpLabelranges::ReadLabelranges( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    DBG_ASSERT_BIFF( rRoot.GetBiff() == EXC_BIFF8 );
-
-    ScDocument& rDoc = rRoot.GetDoc();
-    SCTAB nScTab = rRoot.GetCurrScTab();
-    XclImpAddressConverter& rAddrConv = rRoot.GetAddressConverter();
-    ScRangePairListRef xLabelRangesRef;
-    const ScRange* pScRange = 0;
-
-    XclRangeList aRowXclRanges, aColXclRanges;
-    rStrm >> aRowXclRanges >> aColXclRanges;
-
-    // row label ranges
-    ScRangeList aRowScRanges;
-    rAddrConv.ConvertRangeList( aRowScRanges, aRowXclRanges, nScTab, false );
-    xLabelRangesRef = rDoc.GetRowNameRangesRef();
-    for( pScRange = aRowScRanges.First(); pScRange; pScRange = aRowScRanges.Next() )
-    {
-        ScRange aDataRange( *pScRange );
-        if( aDataRange.aEnd.Col() < MAXCOL )
-        {
-            aDataRange.aStart.SetCol( aDataRange.aEnd.Col() + 1 );
-            aDataRange.aEnd.SetCol( MAXCOL );
-        }
-        else if( aDataRange.aStart.Col() > 0 )
-        {
-            aDataRange.aEnd.SetCol( aDataRange.aStart.Col() - 1 );
-            aDataRange.aStart.SetCol( 0 );
-        }
-        xLabelRangesRef->Append( ScRangePair( *pScRange, aDataRange ) );
-    }
-
-    // column label ranges
-    ScRangeList aColScRanges;
-    rAddrConv.ConvertRangeList( aColScRanges, aColXclRanges, nScTab, false );
-    xLabelRangesRef = rDoc.GetColNameRangesRef();
-    for( pScRange = aColScRanges.First(); pScRange; pScRange = aColScRanges.Next() )
-    {
-        ScRange aDataRange( *pScRange );
-        if( aDataRange.aEnd.Row() < MAXROW )
-        {
-            aDataRange.aStart.SetRow( aDataRange.aEnd.Row() + 1 );
-            aDataRange.aEnd.SetRow( MAXROW );
-        }
-        else if( aDataRange.aStart.Row() > 0 )
-        {
-            aDataRange.aEnd.SetRow( aDataRange.aStart.Row() - 1 );
-            aDataRange.aStart.SetRow( 0 );
-        }
-        xLabelRangesRef->Append( ScRangePair( *pScRange, aDataRange ) );
-    }
-}
-
-// Conditional formatting =====================================================
-
-XclImpCondFormat::XclImpCondFormat( const XclImpRoot& rRoot, sal_uInt32 nFormatIndex ) :
-    XclImpRoot( rRoot ),
-    mnFormatIndex( nFormatIndex ),
-    mnCondCount( 0 ),
-    mnCondIndex( 0 )
-{
-}
-
-XclImpCondFormat::~XclImpCondFormat()
-{
-}
-
-void XclImpCondFormat::ReadCondfmt( XclImpStream& rStrm )
-{
-    DBG_ASSERT( !mnCondCount, "XclImpCondFormat::ReadCondfmt - already initialized" );
-    XclRangeList aXclRanges;
-    rStrm >> mnCondCount;
-    rStrm.Ignore( 10 );
-    rStrm >> aXclRanges;
-    GetAddressConverter().ConvertRangeList( maRanges, aXclRanges, GetCurrScTab(), true );
-}
-
-void XclImpCondFormat::ReadCF( XclImpStream& rStrm )
-{
-    if( mnCondIndex >= mnCondCount )
-    {
-        DBG_ERRORFILE( "XclImpCondFormat::ReadCF - CF without leading CONDFMT" );
-        return;
-    }
-
-    // entire conditional format outside of valid range?
-    if( !maRanges.Count() )
-        return;
-
-    sal_uInt8 nType, nOperator;
-    sal_uInt16 nFmlaSize1, nFmlaSize2;
-    sal_uInt32 nFlags;
-
-    rStrm >> nType >> nOperator >> nFmlaSize1 >> nFmlaSize2 >> nFlags;
-    rStrm.Ignore( 2 );
-
-    // *** mode and comparison operator ***
-
-    ScConditionMode eMode = SC_COND_NONE;
-    switch( nType )
-    {
-        case EXC_CF_TYPE_CELL:
-        {
-            switch( nOperator )
-            {
-                case EXC_CF_CMP_BETWEEN:        eMode = SC_COND_BETWEEN;    break;
-                case EXC_CF_CMP_NOT_BETWEEN:    eMode = SC_COND_NOTBETWEEN; break;
-                case EXC_CF_CMP_EQUAL:          eMode = SC_COND_EQUAL;      break;
-                case EXC_CF_CMP_NOT_EQUAL:      eMode = SC_COND_NOTEQUAL;   break;
-                case EXC_CF_CMP_GREATER:        eMode = SC_COND_GREATER;    break;
-                case EXC_CF_CMP_LESS:           eMode = SC_COND_LESS;       break;
-                case EXC_CF_CMP_GREATER_EQUAL:  eMode = SC_COND_EQGREATER;  break;
-                case EXC_CF_CMP_LESS_EQUAL:     eMode = SC_COND_EQLESS;     break;
-                default:
-                    DBG_ERROR1( "XclImpCondFormat::ReadCF - unknown CF comparison 0x%02hX", nOperator );
-            }
-        }
-        break;
-
-        case EXC_CF_TYPE_FMLA:
-            eMode = SC_COND_DIRECT;
-        break;
-
-        default:
-            DBG_ERROR1( "XclImpCondFormat::ReadCF - unknown CF mode 0x%02hX", nType );
-            return;
-    }
-
-    // *** create style sheet ***
-
-    String aStyleName( XclTools::GetCondFormatStyleName( GetCurrScTab(), mnFormatIndex, mnCondIndex ) );
-    SfxItemSet& rStyleItemSet = ScfTools::MakeCellStyleSheet( GetStyleSheetPool(), aStyleName, true ).GetItemSet();
-
-    const XclImpPalette& rPalette = GetPalette();
-
-    // *** font block ***
-
-    if( ::get_flag( nFlags, EXC_CF_BLOCK_FONT ) )
-    {
-        XclImpFont aFont( GetRoot() );
-        aFont.ReadCFFontBlock( rStrm );
-        aFont.FillToItemSet( rStyleItemSet, EXC_FONTITEM_CELL );
-    }
-
-    // *** border block ***
-
-    if( ::get_flag( nFlags, EXC_CF_BLOCK_BORDER ) )
-    {
-        sal_uInt16 nLineStyle;
-        sal_uInt32 nLineColor;
-        rStrm >> nLineStyle >> nLineColor;
-        rStrm.Ignore( 2 );
-
-        XclImpCellBorder aBorder;
-        aBorder.FillFromCF8( nLineStyle, nLineColor, nFlags );
-        aBorder.FillToItemSet( rStyleItemSet, rPalette );
-    }
-
-    // *** pattern block ***
-
-    if( ::get_flag( nFlags, EXC_CF_BLOCK_AREA ) )
-    {
-        sal_uInt16 nPattern, nColor;
-        rStrm >> nPattern >> nColor;
-
-        XclImpCellArea aArea;
-        aArea.FillFromCF8( nPattern, nColor, nFlags );
-        aArea.FillToItemSet( rStyleItemSet, rPalette );
-    }
-
-    // *** formulas ***
-
-    const ScAddress& rPos = maRanges.GetObject( 0 )->aStart;    // assured above that maRanges is not empty
-    ExcelToSc& rFmlaConv = GetOldFmlaConverter();
-
-    ::std::auto_ptr< ScTokenArray > xTokArr1;
-    if( nFmlaSize1 > 0 )
-    {
-        const ScTokenArray* pTokArr = 0;
-        rFmlaConv.Reset( rPos );
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize1, false, FT_RangeName );
-        // formula converter owns pTokArr -> create a copy of the token array
-        if( pTokArr )
-            xTokArr1.reset( pTokArr->Clone() );
-    }
-
-    ::std::auto_ptr< ScTokenArray > pTokArr2;
-    if( nFmlaSize2 > 0 )
-    {
-        const ScTokenArray* pTokArr = 0;
-        rFmlaConv.Reset( rPos );
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize2, false, FT_RangeName );
-        // formula converter owns pTokArr -> create a copy of the token array
-        if( pTokArr )
-            pTokArr2.reset( pTokArr->Clone() );
-    }
-
-    // *** create the Calc conditional formatting ***
-
-    if( !mxScCondFmt.get() )
-    {
-        ULONG nKey = 0;
-        mxScCondFmt.reset( new ScConditionalFormat( nKey, GetDocPtr() ) );
-    }
-
-    ScCondFormatEntry aEntry( eMode, xTokArr1.get(), pTokArr2.get(), GetDocPtr(), rPos, aStyleName );
-    mxScCondFmt->AddEntry( aEntry );
-    ++mnCondIndex;
-}
-
-void XclImpCondFormat::Apply()
-{
-    if( mxScCondFmt.get() )
-    {
-        ScDocument& rDoc = GetDoc();
-
-        ULONG nKey = rDoc.AddCondFormat( *mxScCondFmt );
-        ScPatternAttr aPattern( rDoc.GetPool() );
-        aPattern.GetItemSet().Put( SfxUInt32Item( ATTR_CONDITIONAL, nKey ) );
-
-        // maRanges contains only valid cell ranges
-        for( const ScRange* pScRange = maRanges.First(); pScRange; pScRange = maRanges.Next() )
-        {
-            rDoc.ApplyPatternAreaTab(
-                pScRange->aStart.Col(), pScRange->aStart.Row(),
-                pScRange->aEnd.Col(), pScRange->aEnd.Row(),
-                pScRange->aStart.Tab(), aPattern );
-        }
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpCondFormatManager::XclImpCondFormatManager( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpCondFormatManager::ReadCondfmt( XclImpStream& rStrm )
-{
-    XclImpCondFormat* pFmt = new XclImpCondFormat( GetRoot(), maCondFmtList.Count() );
-    pFmt->ReadCondfmt( rStrm );
-    maCondFmtList.Append( pFmt );
-}
-
-void XclImpCondFormatManager::ReadCF( XclImpStream& rStrm )
-{
-    DBG_ASSERT( !maCondFmtList.Empty(), "XclImpCondFormatManager::ReadCF - CF without leading CONDFMT" );
-    if( !maCondFmtList.Empty() )
-        maCondFmtList.GetObject( maCondFmtList.Count() - 1 )->ReadCF( rStrm );
-}
-
-void XclImpCondFormatManager::Apply()
-{
-    for( XclImpCondFormat* pFmt = maCondFmtList.First(); pFmt; pFmt = maCondFmtList.Next() )
-        pFmt->Apply();
-    maCondFmtList.Clear();
-}
-
-// Data Validation ============================================================
-
-void XclImpValidation::ReadDval( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    DBG_ASSERT_BIFF( rRoot.GetBiff() == EXC_BIFF8 );
-
-    sal_uInt32 nObjId;
-    rStrm.Ignore( 10 );
-    rStrm >> nObjId;
-    if( nObjId != EXC_DVAL_NOOBJ )
-    {
-        DBG_ASSERT( nObjId <= 0xFFFF, "XclImpValidation::ReadDval - invalid object ID" );
-        rRoot.GetObjectManager().SetSkipObj( rRoot.GetCurrScTab(), static_cast< sal_uInt16 >( nObjId ) );
-    }
-}
-
-void XclImpValidation::ReadDV( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    DBG_ASSERT_BIFF( rRoot.GetBiff() == EXC_BIFF8 );
-
-    ScDocument& rDoc = rRoot.GetDoc();
-    SCTAB nScTab = rRoot.GetCurrScTab();
-    ExcelToSc& rFmlaConv = rRoot.GetOldFmlaConverter();
-
-    // flags
-    sal_uInt32 nFlags;
-    rStrm >> nFlags;
-
-    // message strings
-    /*  Empty strings are single NUL characters in Excel (string length is 1).
-        -> Do not let the stream replace them with '?' characters. */
-    rStrm.SetNulSubstChar( '\0' );
-    String aPromptTitle(   rStrm.ReadUniString() );
-    String aErrorTitle(    rStrm.ReadUniString() );
-    String aPromptMessage( rStrm.ReadUniString() );
-    String aErrorMessage(  rStrm.ReadUniString() );
-    rStrm.SetNulSubstChar();    // back to default
-
-    // formula(s)
-    if( rStrm.GetRecLeft() > 8 )
-    {
-        sal_uInt16 nLen;
-
-        // first formula
-        // string list is single tStr token with NUL separators -> replace them with LF
-        rStrm.SetNulSubstChar( '\n' );
-        ::std::auto_ptr< ScTokenArray > xTokArr1;
-        rStrm >> nLen;
-        rStrm.Ignore( 2 );
-        if( nLen > 0 )
-        {
-            const ScTokenArray* pTokArr = 0;
-            rFmlaConv.Reset();
-            rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
-            // formula converter owns pTokArr -> create a copy of the token array
-            if( pTokArr )
-                xTokArr1.reset( pTokArr->Clone() );
-        }
-        rStrm.SetNulSubstChar();    // back to default
-
-        // second formula
-        ::std::auto_ptr< ScTokenArray > xTokArr2;
-        rStrm >> nLen;
-        rStrm.Ignore( 2 );
-        if( nLen > 0 )
-        {
-            const ScTokenArray* pTokArr = 0;
-            rFmlaConv.Reset();
-            rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
-            // formula converter owns pTokArr -> create a copy of the token array
-            if( pTokArr )
-                xTokArr2.reset( pTokArr->Clone() );
-        }
-
-        // read all cell ranges
-        XclRangeList aXclRanges;
-        rStrm >> aXclRanges;
-
-        // convert to Calc range list
-        ScRangeList aScRanges;
-        rRoot.GetAddressConverter().ConvertRangeList( aScRanges, aXclRanges, nScTab, true );
-
-        // only continue if there are valid ranges
-        if( aScRanges.Count() )
-        {
-            bool bIsValid = true;   // valid settings in flags field
-
-            ScValidationMode eValMode = SC_VALID_ANY;
-            switch( nFlags & EXC_DV_MODE_MASK )
-            {
-                case EXC_DV_MODE_ANY:       eValMode = SC_VALID_ANY;        break;
-                case EXC_DV_MODE_WHOLE:     eValMode = SC_VALID_WHOLE;      break;
-                case EXC_DV_MODE_DECIMAL:   eValMode = SC_VALID_DECIMAL;    break;
-                case EXC_DV_MODE_LIST:      eValMode = SC_VALID_LIST;       break;
-                case EXC_DV_MODE_DATE:      eValMode = SC_VALID_DATE;       break;
-                case EXC_DV_MODE_TIME:      eValMode = SC_VALID_TIME;       break;
-                case EXC_DV_MODE_TEXTLEN:   eValMode = SC_VALID_TEXTLEN;    break;
-                case EXC_DV_MODE_CUSTOM:    eValMode = SC_VALID_CUSTOM;     break;
-                default:                    bIsValid = false;
-            }
-            rRoot.GetTracer().TraceDVType(eValMode == SC_VALID_CUSTOM);
-
-            ScConditionMode eCondMode = SC_COND_BETWEEN;
-            switch( nFlags & EXC_DV_COND_MASK )
-            {
-                case EXC_DV_COND_BETWEEN:   eCondMode = SC_COND_BETWEEN;    break;
-                case EXC_DV_COND_NOTBETWEEN:eCondMode = SC_COND_NOTBETWEEN; break;
-                case EXC_DV_COND_EQUAL:     eCondMode = SC_COND_EQUAL;      break;
-                case EXC_DV_COND_NOTEQUAL:  eCondMode = SC_COND_NOTEQUAL;   break;
-                case EXC_DV_COND_GREATER:   eCondMode = SC_COND_GREATER;    break;
-                case EXC_DV_COND_LESS:      eCondMode = SC_COND_LESS;       break;
-                case EXC_DV_COND_EQGREATER: eCondMode = SC_COND_EQGREATER;  break;
-                case EXC_DV_COND_EQLESS:    eCondMode = SC_COND_EQLESS;     break;
-                default:                    bIsValid = false;
-            }
-
-            if( bIsValid )
-            {
-                // first range for base address for relative references
-                const ScRange& rScRange = *aScRanges.GetObject( 0 );    // aScRanges is not empty
-
-                // process string list of a list validity (convert to list of string tokens)
-                if( xTokArr1.get() && (eValMode == SC_VALID_LIST) && ::get_flag( nFlags, EXC_DV_STRINGLIST ) )
-                    XclTokenArrayHelper::ConvertStringToList( *xTokArr1, '\n', true );
-
-                ScValidationData aValidData( eValMode, eCondMode, xTokArr1.get(), xTokArr2.get(), &rDoc, rScRange.aStart );
-
-                aValidData.SetIgnoreBlank( ::get_flag( nFlags, EXC_DV_IGNOREBLANK ) );
-                aValidData.SetListType( ::get_flagvalue( nFlags, EXC_DV_SUPPRESSDROPDOWN, ValidListType::INVISIBLE, ValidListType::UNSORTED ) );
-
-                // *** prompt box ***
-                if( aPromptTitle.Len() || aPromptMessage.Len() )
-                {
-                    // set any text stored in the record
-                    aValidData.SetInput( aPromptTitle, aPromptMessage );
-                    if( !::get_flag( nFlags, EXC_DV_SHOWPROMPT ) )
-                        aValidData.ResetInput();
-                }
-
-                // *** error box ***
-                ScValidErrorStyle eErrStyle = SC_VALERR_STOP;
-                switch( nFlags & EXC_DV_ERROR_MASK )
-                {
-                    case EXC_DV_ERROR_WARNING:  eErrStyle = SC_VALERR_WARNING;  break;
-                    case EXC_DV_ERROR_INFO:     eErrStyle = SC_VALERR_INFO;     break;
-                }
-                // set texts and error style
-                aValidData.SetError( aErrorTitle, aErrorMessage, eErrStyle );
-                if( !::get_flag( nFlags, EXC_DV_SHOWERROR ) )
-                    aValidData.ResetError();
-
-                // set the handle ID
-                ULONG nHandle = rDoc.AddValidationEntry( aValidData );
-                ScPatternAttr aPattern( rDoc.GetPool() );
-                aPattern.GetItemSet().Put( SfxUInt32Item( ATTR_VALIDDATA, nHandle ) );
-
-                // apply all ranges
-                for( const ScRange* pScRange = aScRanges.First(); pScRange; pScRange = aScRanges.Next() )
-                    rDoc.ApplyPatternAreaTab( pScRange->aStart.Col(), pScRange->aStart.Row(),
-                        pScRange->aEnd.Col(), pScRange->aEnd.Row(), nScTab, aPattern );
-            }
-        }
-    }
-}
-
-// Web queries ================================================================
-
-XclImpWebQuery::XclImpWebQuery( const ScRange& rDestRange ) :
-    maDestRange( rDestRange ),
-    meMode( xlWQUnknown ),
-    mnRefresh( 0 )
-{
-}
-
-void XclImpWebQuery::ReadParamqry( XclImpStream& rStrm )
-{
-    sal_uInt16 nFlags = rStrm.ReaduInt16();
-    sal_uInt16 nType = ::extract_value< sal_uInt16 >( nFlags, 0, 3 );
-    if( (nType == EXC_PQRYTYPE_WEBQUERY) && ::get_flag( nFlags, EXC_PQRY_WEBQUERY ) )
-    {
-        if( ::get_flag( nFlags, EXC_PQRY_TABLES ) )
-        {
-            meMode = xlWQAllTables;
-            maTables = ScfTools::GetHTMLTablesName();
-        }
-        else
-        {
-            meMode = xlWQDocument;
-            maTables = ScfTools::GetHTMLDocName();
-        }
-    }
-}
-
-void XclImpWebQuery::ReadWqstring( XclImpStream& rStrm )
-{
-    maURL = rStrm.ReadUniString();
-}
-
-void XclImpWebQuery::ReadWqsettings( XclImpStream& rStrm )
-{
-    sal_uInt16 nFlags;
-    rStrm.Ignore( 10 );
-    rStrm >> nFlags;
-    rStrm.Ignore( 10 );
-    rStrm >> mnRefresh;
-
-    if( ::get_flag( nFlags, EXC_WQSETT_SPECTABLES ) && (meMode == xlWQAllTables) )
-        meMode = xlWQSpecTables;
-}
-
-void XclImpWebQuery::ReadWqtables( XclImpStream& rStrm )
-{
-    if( meMode == xlWQSpecTables )
-    {
-        rStrm.Ignore( 4 );
-        String aTables( rStrm.ReadUniString() );
-
-        const sal_Unicode cSep = ';';
-        aTables.SearchAndReplaceAll( ',', cSep );
-        String aQuotedPairs( RTL_CONSTASCII_USTRINGPARAM( "\"\"" ) );
-        xub_StrLen nTokenCnt = aTables.GetQuotedTokenCount( aQuotedPairs, cSep );
-        maTables.Erase();
-        xub_StrLen nStringIx = 0;
-        for( xub_StrLen nToken = 0; nToken < nTokenCnt; ++nToken )
-        {
-            String aToken( aTables.GetQuotedToken( 0, aQuotedPairs, cSep, nStringIx ) );
-            sal_Int32 nTabNum = CharClass::isAsciiNumeric( aToken ) ? aToken.ToInt32() : 0;
-            if( nTabNum > 0 )
-                ScGlobal::AddToken( maTables, ScfTools::GetNameFromHTMLIndex( static_cast< sal_uInt32 >( nTabNum ) ), cSep );
-            else
-            {
-                ScGlobal::EraseQuotes( aToken, '"', false );
-                if( aToken.Len() )
-                    ScGlobal::AddToken( maTables, ScfTools::GetNameFromHTMLName( aToken ), cSep );
-            }
-        }
-    }
-}
-
-void XclImpWebQuery::Apply( ScDocument& rDoc, const String& rFilterName )
-{
-    if( maURL.Len() && (meMode != xlWQUnknown) && rDoc.GetDocumentShell() )
-    {
-        ScAreaLink* pLink = new ScAreaLink( rDoc.GetDocumentShell(),
-            maURL, rFilterName, EMPTY_STRING, maTables, maDestRange, mnRefresh * 60UL );
-        rDoc.GetLinkManager()->InsertFileLink( *pLink, OBJECT_CLIENT_FILE,
-            maURL, &rFilterName, &maTables );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpWebQueryBuffer::XclImpWebQueryBuffer( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpWebQueryBuffer::ReadQsi( XclImpStream& rStrm )
-{
-    if( GetBiff() == EXC_BIFF8 )
-    {
-        rStrm.Ignore( 10 );
-        String aXclName( rStrm.ReadUniString() );
-
-        // #i64794# Excel replaces spaces with underscores
-        aXclName.SearchAndReplaceAll( ' ', '_' );
-
-        // #101529# find the defined name used in Calc
-        if( const XclImpName* pName = GetNameManager().FindName( aXclName, GetCurrScTab() ) )
-        {
-            if( const ScRangeData* pRangeData = pName->GetScRangeData() )
-            {
-                ScRange aRange;
-                if( pRangeData->IsReference( aRange ) )
-                    maWQList.Append( new XclImpWebQuery( aRange ) );
-            }
-        }
-    }
-    else
-    {
-        DBG_ERROR_BIFF();
-    }
-}
-
-void XclImpWebQueryBuffer::ReadParamqry( XclImpStream& rStrm )
-{
-    if( XclImpWebQuery* pQuery = maWQList.Last() )
-        pQuery->ReadParamqry( rStrm );
-}
-
-void XclImpWebQueryBuffer::ReadWqstring( XclImpStream& rStrm )
-{
-    if( XclImpWebQuery* pQuery = maWQList.Last() )
-        pQuery->ReadWqstring( rStrm );
-}
-
-void XclImpWebQueryBuffer::ReadWqsettings( XclImpStream& rStrm )
-{
-    if( XclImpWebQuery* pQuery = maWQList.Last() )
-        pQuery->ReadWqsettings( rStrm );
-}
-
-void XclImpWebQueryBuffer::ReadWqtables( XclImpStream& rStrm )
-{
-    if( XclImpWebQuery* pQuery = maWQList.Last() )
-        pQuery->ReadWqtables( rStrm );
-}
-
-void XclImpWebQueryBuffer::Apply()
-{
-    ScDocument& rDoc = GetDoc();
-    String aFilterName( RTL_CONSTASCII_USTRINGPARAM( EXC_WEBQRY_FILTER ) );
-    for( XclImpWebQuery* pQuery = maWQList.First(); pQuery; pQuery = maWQList.Next() )
-        pQuery->Apply( rDoc, aFilterName );
-}
-
-// Decryption =================================================================
-
-namespace {
-
-XclImpDecrypterRef lclReadFilepass5( XclImpStream& rStrm )
-{
-    XclImpDecrypterRef xDecr;
-    DBG_ASSERT( rStrm.GetRecLeft() == 4, "lclReadFilepass5 - wrong record size" );
-    if( rStrm.GetRecLeft() == 4 )
-    {
-        sal_uInt16 nKey, nHash;
-        rStrm >> nKey >> nHash;
-        xDecr.reset( new XclImpBiff5Decrypter( nKey, nHash ) );
-    }
-    return xDecr;
-}
-
-XclImpDecrypterRef lclReadFilepass8_Standard( XclImpStream& rStrm )
-{
-    XclImpDecrypterRef xDecr;
-    DBG_ASSERT( rStrm.GetRecLeft() == 48, "lclReadFilepass8 - wrong record size" );
-    if( rStrm.GetRecLeft() == 48 )
-    {
-        sal_uInt8 pnSalt[ 16 ];
-        sal_uInt8 pnVerifier[ 16 ];
-        sal_uInt8 pnVerifierHash[ 16 ];
-        rStrm.Read( pnSalt, 16 );
-        rStrm.Read( pnVerifier, 16 );
-        rStrm.Read( pnVerifierHash, 16 );
-        xDecr.reset( new XclImpBiff8Decrypter( pnSalt, pnVerifier, pnVerifierHash ) );
-    }
-    return xDecr;
-}
-
-XclImpDecrypterRef lclReadFilepass8_Strong( XclImpStream& /*rStrm*/ )
-{
-    // not supported
-    return XclImpDecrypterRef();
-}
-
-XclImpDecrypterRef lclReadFilepass8( XclImpStream& rStrm )
-{
-    XclImpDecrypterRef xDecr;
-
-    sal_uInt16 nMode;
-    rStrm >> nMode;
-    switch( nMode )
-    {
-        case EXC_FILEPASS_BIFF5:
-            xDecr = lclReadFilepass5( rStrm );
-        break;
-
-        case EXC_FILEPASS_BIFF8:
-        {
-            rStrm.Ignore( 2 );
-            sal_uInt16 nSubMode;
-            rStrm >> nSubMode;
-            switch( nSubMode )
-            {
-                case EXC_FILEPASS_BIFF8_STD:
-                    xDecr = lclReadFilepass8_Standard( rStrm );
-                break;
-                case EXC_FILEPASS_BIFF8_STRONG:
-                    xDecr = lclReadFilepass8_Strong( rStrm );
-                break;
-                default:
-                    DBG_ERRORFILE( "lclReadFilepass8 - unknown BIFF8 encryption sub mode" );
-            }
-        }
-        break;
-
-        default:
-            DBG_ERRORFILE( "lclReadFilepass8 - unknown encryption mode" );
-    }
-
-    return xDecr;
-}
-
-} // namespace
-
-// ----------------------------------------------------------------------------
-
-ErrCode XclImpDecryptHelper::ReadFilepass( XclImpStream& rStrm )
-{
-    XclImpDecrypterRef xDecr;
-    rStrm.DisableDecryption();
-
-    // read the FILEPASS record and create a new decrypter object
-    switch( rStrm.GetRoot().GetBiff() )
-    {
-        case EXC_BIFF2:
-        case EXC_BIFF3:
-        case EXC_BIFF4:
-        case EXC_BIFF5: xDecr = lclReadFilepass5( rStrm );  break;
-        case EXC_BIFF8: xDecr = lclReadFilepass8( rStrm );  break;
-        default:        DBG_ERROR_BIFF();
-    };
-
-    // set decrypter at import stream
-    rStrm.SetDecrypter( xDecr );
-
-    // request and verify a password (decrypter implements IDocPasswordVerifier)
-    if( xDecr.is() )
-        rStrm.GetRoot().RequestPassword( *xDecr );
-
-    // return error code (success, wrong password, etc.)
-    return xDecr.is() ? xDecr->GetError() : EXC_ENCR_ERROR_UNSUPP_CRYPT;
-}
-
-// Document protection ========================================================
-
-XclImpDocProtectBuffer::XclImpDocProtectBuffer( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mnPassHash(0x0000),
-    mbDocProtect(false),
-    mbWinProtect(false)
-{
-}
-
-void XclImpDocProtectBuffer::ReadDocProtect( XclImpStream& rStrm )
-{
-    mbDocProtect = rStrm.ReaduInt16() ? true : false;
-}
-
-void XclImpDocProtectBuffer::ReadWinProtect( XclImpStream& rStrm )
-{
-    mbWinProtect = rStrm.ReaduInt16() ? true : false;
-}
-
-void XclImpDocProtectBuffer::ReadPasswordHash( XclImpStream& rStrm )
-{
-    rStrm.EnableDecryption();
-    mnPassHash = rStrm.ReaduInt16();
-}
-
-void XclImpDocProtectBuffer::Apply() const
-{
-    if (!mbDocProtect && !mbWinProtect)
-        // Excel requires either the structure or windows protection is set.
-        // If neither is set then the document is not protected at all.
-        return;
-
-    auto_ptr<ScDocProtection> pProtect(new ScDocProtection);
-    pProtect->setProtected(true);
-
-#if ENABLE_SHEET_PROTECTION
-    if (mnPassHash)
-    {
-        // 16-bit password pash.
-        Sequence<sal_Int8> aPass(2);
-        aPass[0] = (mnPassHash >> 8) & 0xFF;
-        aPass[1] = mnPassHash & 0xFF;
-        pProtect->setPasswordHash(aPass, PASSHASH_XL);
-    }
-#endif
-
-    // document protection options
-    pProtect->setOption(ScDocProtection::STRUCTURE, mbDocProtect);
-    pProtect->setOption(ScDocProtection::WINDOWS,   mbWinProtect);
-
-    GetDoc().SetDocProtection(pProtect.get());
-}
-
-// Sheet Protection ===========================================================
-
-XclImpSheetProtectBuffer::Sheet::Sheet() :
-    mbProtected(false),
-    mnPasswordHash(0x0000),
-    mnOptions(0x4400)
-{
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpSheetProtectBuffer::Sheet::Sheet(const Sheet& r) :
-    mbProtected(r.mbProtected),
-    mnPasswordHash(r.mnPasswordHash),
-    mnOptions(r.mnOptions)
-{
-}
-
-XclImpSheetProtectBuffer::XclImpSheetProtectBuffer( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpSheetProtectBuffer::ReadProtect( XclImpStream& rStrm, SCTAB nTab )
-{
-    if ( rStrm.ReaduInt16() )
-    {
-        Sheet* pSheet = GetSheetItem(nTab);
-        if (pSheet)
-            pSheet->mbProtected = true;
-    }
-}
-
-void XclImpSheetProtectBuffer::ReadOptions( XclImpStream& rStrm, SCTAB nTab )
-{
-    rStrm.Ignore(12);
-
-    // feature type can be either 2 or 4.  If 2, this record stores flag for 
-    // enhanced protection, whereas if 4 it stores flag for smart tag.
-    sal_uInt16 nFeatureType;
-    rStrm >> nFeatureType;
-    if (nFeatureType != 2)
-        // We currently only support import of enhanced protection data.
-        return;
-
-    rStrm.Ignore(1); // always 1
-
-    // The flag size specifies the size of bytes that follows that stores 
-    // feature data.  If -1 it depends on the feature type imported earlier.
-    // For enhanced protection data, the size is always 4.  For the most xls
-    // documents out there this value is almost always -1.
-    sal_Int32 nFlagSize;
-    rStrm >> nFlagSize;
-    if (nFlagSize != -1)
-        return;
-
-    // There are actually 4 bytes to read, but the upper 2 bytes currently 
-    // don't store any bits.
-    sal_uInt16 nOptions;
-    rStrm >> nOptions;
-
-    Sheet* pSheet = GetSheetItem(nTab);
-    if (pSheet)
-        pSheet->mnOptions = nOptions;
-}
-
-void XclImpSheetProtectBuffer::ReadPasswordHash( XclImpStream& rStrm, SCTAB nTab )
-{
-    sal_uInt16 nHash;
-    rStrm >> nHash;
-    Sheet* pSheet = GetSheetItem(nTab);
-    if (pSheet)
-        pSheet->mnPasswordHash = nHash;
-}
-
-void XclImpSheetProtectBuffer::Apply() const
-{
-    for (ProtectedSheetMap::const_iterator itr = maProtectedSheets.begin(), itrEnd = maProtectedSheets.end();
-         itr != itrEnd; ++itr)
-    {
-        if (!itr->second.mbProtected)
-            // This sheet is (for whatever reason) not protected.
-            continue;
-
-        auto_ptr<ScTableProtection> pProtect(new ScTableProtection);
-        pProtect->setProtected(true);
-
-#if ENABLE_SHEET_PROTECTION
-        // 16-bit hash password
-        const sal_uInt16 nHash = itr->second.mnPasswordHash;
-        if (nHash)
-        {
-            Sequence<sal_Int8> aPass(2);
-            aPass[0] = (nHash >> 8) & 0xFF;
-            aPass[1] = nHash & 0xFF;
-            pProtect->setPasswordHash(aPass, PASSHASH_XL);
-        }
-#endif
-
-        // sheet protection options
-        const sal_uInt16 nOptions = itr->second.mnOptions;
-        pProtect->setOption( ScTableProtection::OBJECTS,               (nOptions & 0x0001) );
-        pProtect->setOption( ScTableProtection::SCENARIOS,             (nOptions & 0x0002) );
-        pProtect->setOption( ScTableProtection::FORMAT_CELLS,          (nOptions & 0x0004) );
-        pProtect->setOption( ScTableProtection::FORMAT_COLUMNS,        (nOptions & 0x0008) );
-        pProtect->setOption( ScTableProtection::FORMAT_ROWS,           (nOptions & 0x0010) );
-        pProtect->setOption( ScTableProtection::INSERT_COLUMNS,        (nOptions & 0x0020) );
-        pProtect->setOption( ScTableProtection::INSERT_ROWS,           (nOptions & 0x0040) );
-        pProtect->setOption( ScTableProtection::INSERT_HYPERLINKS,     (nOptions & 0x0080) );
-        pProtect->setOption( ScTableProtection::DELETE_COLUMNS,        (nOptions & 0x0100) );
-        pProtect->setOption( ScTableProtection::DELETE_ROWS,           (nOptions & 0x0200) );
-        pProtect->setOption( ScTableProtection::SELECT_LOCKED_CELLS,   (nOptions & 0x0400) );
-        pProtect->setOption( ScTableProtection::SORT,                  (nOptions & 0x0800) );
-        pProtect->setOption( ScTableProtection::AUTOFILTER,            (nOptions & 0x1000) );
-        pProtect->setOption( ScTableProtection::PIVOT_TABLES,          (nOptions & 0x2000) );
-        pProtect->setOption( ScTableProtection::SELECT_UNLOCKED_CELLS, (nOptions & 0x4000) );
-
-        // all done.  now commit.
-        GetDoc().SetTabProtection(itr->first, pProtect.get());
-    }
-}
-
-XclImpSheetProtectBuffer::Sheet* XclImpSheetProtectBuffer::GetSheetItem( SCTAB nTab )
-{
-    ProtectedSheetMap::iterator itr = maProtectedSheets.find(nTab);
-    if (itr == maProtectedSheets.end())
-    {
-        // new sheet
-        if ( !maProtectedSheets.insert( ProtectedSheetMap::value_type(nTab, Sheet()) ).second )
-            return NULL;
-
-        itr = maProtectedSheets.find(nTab);
-    }
-
-    return &itr->second;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xiescher.cxx sc/source/filter/xlsx/xlsx-xiescher.cxx
deleted file mode 100644
index 90a52d9..0000000
--- sc/source/filter/xlsx/xlsx-xiescher.cxx
+++ /dev/null
@@ -1,4046 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xiescher.cxx,v $
- * $Revision: 1.57.52.8 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "xiescher.hxx"
-
-#include <com/sun/star/beans/NamedValue.hpp>
-#include <com/sun/star/container/XIndexContainer.hpp>
-#include <com/sun/star/container/XNameContainer.hpp>
-#include <com/sun/star/embed/Aspects.hpp>
-#include <com/sun/star/embed/XEmbeddedObject.hpp>
-#include <com/sun/star/embed/XEmbedPersist.hpp>
-#include <com/sun/star/awt/PushButtonType.hpp>
-#include <com/sun/star/awt/ScrollBarOrientation.hpp>
-#include <com/sun/star/awt/VisualEffect.hpp>
-#include <com/sun/star/style/HorizontalAlignment.hpp>
-#include <com/sun/star/style/VerticalAlignment.hpp>
-#include <com/sun/star/drawing/XControlShape.hpp>
-#include <com/sun/star/form/XForm.hpp>
-#include <com/sun/star/form/XFormsSupplier.hpp>
-#include <com/sun/star/form/binding/XBindableValue.hpp>
-#include <com/sun/star/form/binding/XValueBinding.hpp>
-#include <com/sun/star/form/binding/XListEntrySink.hpp>
-#include <com/sun/star/form/binding/XListEntrySource.hpp>
-#include <com/sun/star/script/ScriptEventDescriptor.hpp>
-#include <com/sun/star/script/XEventAttacherManager.hpp>
-
-#include <rtl/logfile.hxx>
-#include <sfx2/objsh.hxx>
-#include <svtools/moduleoptions.hxx>
-#include <svtools/fltrcfg.hxx>
-#include <svtools/wmf.hxx>
-#include <comphelper/types.hxx>
-#include <comphelper/classids.hxx>
-#include <toolkit/helper/vclunohelper.hxx>
-#include <basegfx/point/b2dpoint.hxx>
-#include <basegfx/polygon/b2dpolygon.hxx>
-
-#include <basic/sbstar.hxx>
-#include <basic/sbmod.hxx>
-#include <basic/sbmeth.hxx>
-
-#include <svx/svdopath.hxx>
-#include <svx/svdocirc.hxx>
-#include <svx/svdoedge.hxx>
-#include <svx/svdogrp.hxx>
-#include <svx/svdoashp.hxx>
-#include <svx/svdograf.hxx>
-#include <svx/svdoole2.hxx>
-#include <svx/svdocapt.hxx>
-#include <svx/svdouno.hxx>
-#include <svx/svdpage.hxx>
-#include <svx/editobj.hxx>
-#include <svx/outliner.hxx>
-#include <svx/outlobj.hxx>
-#include <svx/unoapi.hxx>
-#include <svx/svditer.hxx>
-#include <svx/writingmodeitem.hxx>
-
-#include "scitems.hxx"
-#include <svx/eeitem.hxx>
-#include <svx/colritem.hxx>
-#include <svx/xflclit.hxx>
-#include <svx/adjitem.hxx>
-#include <svx/xlineit.hxx>
-#include <svx/xlinjoit.hxx>
-#include <svx/xlntrit.hxx>
-#include <svx/xbtmpit.hxx>
-
-#include "document.hxx"
-#include "drwlayer.hxx"
-#include "userdat.hxx"
-#include "chartarr.hxx"
-#include "detfunc.hxx"
-#include "unonames.hxx"
-#include "convuno.hxx"
-#include "postit.hxx"
-#include "globstr.hrc"
-
-#include "fprogressbar.hxx"
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xiformula.hxx"
-#include "xilink.hxx"
-#include "xistyle.hxx"
-#include "xipage.hxx"
-#include "xichart.hxx"
-#include "xicontent.hxx"
-#include "scextopt.hxx"
-
-#include "namebuff.hxx"
-
-using ::rtl::OUString;
-using ::rtl::OUStringBuffer;
-using ::com::sun::star::uno::Reference;
-using ::com::sun::star::uno::Sequence;
-using ::com::sun::star::uno::Any;
-using ::com::sun::star::uno::XInterface;
-using ::com::sun::star::uno::Exception;
-using ::com::sun::star::uno::UNO_QUERY;
-using ::com::sun::star::uno::UNO_QUERY_THROW;
-using ::com::sun::star::beans::NamedValue;
-using ::com::sun::star::lang::XMultiServiceFactory;
-using ::com::sun::star::container::XIndexContainer;
-using ::com::sun::star::container::XNameContainer;
-using ::com::sun::star::frame::XModel;
-using ::com::sun::star::awt::XControlModel;
-using ::com::sun::star::embed::XEmbeddedObject;
-using ::com::sun::star::embed::XEmbedPersist;
-using ::com::sun::star::drawing::XControlShape;
-using ::com::sun::star::drawing::XShape;
-using ::com::sun::star::form::XForm;
-using ::com::sun::star::form::XFormComponent;
-using ::com::sun::star::form::XFormsSupplier;
-using ::com::sun::star::form::binding::XBindableValue;
-using ::com::sun::star::form::binding::XValueBinding;
-using ::com::sun::star::form::binding::XListEntrySink;
-using ::com::sun::star::form::binding::XListEntrySource;
-using ::com::sun::star::script::ScriptEventDescriptor;
-using ::com::sun::star::script::XEventAttacherManager;
-using ::com::sun::star::table::CellAddress;
-using ::com::sun::star::table::CellRangeAddress;
-
-// ============================================================================
-
-namespace {
-
-/** Helper class which mimics the auto_ptr< SdrObject > semantics, but calls
-    SdrObject::Free instead of deleting the SdrObject directly. */
-template< typename SdrObjType >
-class TSdrObjectPtr
-{
-public:
-    inline explicit     TSdrObjectPtr( SdrObjType* pObj = 0 ) : mpObj( pObj ) {}
-    inline              ~TSdrObjectPtr() { free(); }
-
-    inline const SdrObjType* operator->() const { return mpObj; }
-    inline SdrObjType*  operator->() { return mpObj; }
-
-    inline const SdrObjType* get() const { return mpObj; }
-    inline SdrObjType*  get() { return mpObj; }
-
-    inline const SdrObjType& operator*() const { return *mpObj; }
-    inline SdrObjType& operator*() { return *mpObj; }
-
-    inline bool         is() const { return mpObj != 0; }
-    inline bool         operator!() const { return mpObj == 0; }
-
-    inline void         reset( SdrObjType* pObj = 0 ) { free(); mpObj = pObj; }
-    inline SdrObjType*  release() { SdrObjType* pObj = mpObj; mpObj = 0; return pObj; }
-
-private:
-                        TSdrObjectPtr( const TSdrObjectPtr& );    // not implemented
-    TSdrObjectPtr&      operator=( TSdrObjectPtr& rxObj );        // not implemented
-
-    inline void         free() { SdrObject* pObj = mpObj; mpObj = 0; SdrObject::Free( pObj ); }
-
-private:
-    SdrObjType*         mpObj;
-};
-
-typedef TSdrObjectPtr< SdrObject > SdrObjectPtr;
-
-} // namespace
-
-// Drawing objects ============================================================
-
-XclImpDrawObjBase::XclImpDrawObjBase( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maObjId( rRoot.GetCurrScTab(), EXC_OBJ_INVALID_ID ),
-    mnObjType( EXC_OBJTYPE_UNKNOWN ),
-    mnDffShapeId( 0 ),
-    mnDffFlags( 0 ),
-    mbHidden( false ),
-    mbVisible( true ),
-    mbPrintable( true ),
-    mbAreaObj( false ),
-    mbAutoMargin( true ),
-    mbSimpleMacro( true ),
-    mbProcessSdr( true ),
-    mbInsertSdr( true ),
-    mbCustomDff( false )
-{
-}
-
-XclImpDrawObjBase::~XclImpDrawObjBase()
-{
-}
-
-XclImpDrawObjRef XclImpDrawObjBase::ReadObj3( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    XclImpDrawObjRef xDrawObj;
-
-    if( rStrm.GetRecLeft() >= 30 )
-    {
-        sal_uInt16 nObjType;
-        rStrm.Ignore( 4 );
-        rStrm >> nObjType;
-        switch( nObjType )
-        {
-            case EXC_OBJTYPE_GROUP:         xDrawObj.reset( new XclImpGroupObj( rRoot ) );          break;
-            case EXC_OBJTYPE_LINE:          xDrawObj.reset( new XclImpLineObj( rRoot ) );           break;
-            case EXC_OBJTYPE_RECTANGLE:     xDrawObj.reset( new XclImpRectObj( rRoot ) );           break;
-            case EXC_OBJTYPE_OVAL:          xDrawObj.reset( new XclImpOvalObj( rRoot ) );           break;
-            case EXC_OBJTYPE_ARC:           xDrawObj.reset( new XclImpArcObj( rRoot ) );            break;
-            case EXC_OBJTYPE_CHART:         xDrawObj.reset( new XclImpChartObj( rRoot ) );          break;
-            case EXC_OBJTYPE_TEXT:          xDrawObj.reset( new XclImpTextObj( rRoot ) );           break;
-            case EXC_OBJTYPE_BUTTON:        xDrawObj.reset( new XclImpButtonObj( rRoot ) );         break;
-            case EXC_OBJTYPE_PICTURE:       xDrawObj.reset( new XclImpPictureObj( rRoot ) );        break;
-            default:
-                DBG_ERROR1( "XclImpDrawObjBase::ReadObj3 - unknown object type 0x%04hX", nObjType );
-                rRoot.GetTracer().TraceUnsupportedObjects();
-                xDrawObj.reset( new XclImpPhObj( rRoot ) );
-        }
-    }
-
-    xDrawObj->ImplReadObj3( rStrm );
-    return xDrawObj;
-}
-
-XclImpDrawObjRef XclImpDrawObjBase::ReadObj4( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    XclImpDrawObjRef xDrawObj;
-
-    if( rStrm.GetRecLeft() >= 30 )
-    {
-        sal_uInt16 nObjType;
-        rStrm.Ignore( 4 );
-        rStrm >> nObjType;
-        switch( nObjType )
-        {
-            case EXC_OBJTYPE_GROUP:         xDrawObj.reset( new XclImpGroupObj( rRoot ) );          break;
-            case EXC_OBJTYPE_LINE:          xDrawObj.reset( new XclImpLineObj( rRoot ) );           break;
-            case EXC_OBJTYPE_RECTANGLE:     xDrawObj.reset( new XclImpRectObj( rRoot ) );           break;
-            case EXC_OBJTYPE_OVAL:          xDrawObj.reset( new XclImpOvalObj( rRoot ) );           break;
-            case EXC_OBJTYPE_ARC:           xDrawObj.reset( new XclImpArcObj( rRoot ) );            break;
-            case EXC_OBJTYPE_CHART:         xDrawObj.reset( new XclImpChartObj( rRoot ) );          break;
-            case EXC_OBJTYPE_TEXT:          xDrawObj.reset( new XclImpTextObj( rRoot ) );           break;
-            case EXC_OBJTYPE_BUTTON:        xDrawObj.reset( new XclImpButtonObj( rRoot ) );         break;
-            case EXC_OBJTYPE_PICTURE:       xDrawObj.reset( new XclImpPictureObj( rRoot ) );        break;
-            case EXC_OBJTYPE_POLYGON:       xDrawObj.reset( new XclImpPolygonObj( rRoot ) );        break;
-            default:
-                DBG_ERROR1( "XclImpDrawObjBase::ReadObj4 - unknown object type 0x%04hX", nObjType );
-                rRoot.GetTracer().TraceUnsupportedObjects();
-                xDrawObj.reset( new XclImpPhObj( rRoot ) );
-        }
-    }
-
-    xDrawObj->ImplReadObj4( rStrm );
-    return xDrawObj;
-}
-
-XclImpDrawObjRef XclImpDrawObjBase::ReadObj5( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    XclImpDrawObjRef xDrawObj;
-
-    if( rStrm.GetRecLeft() >= 34 )
-    {
-        sal_uInt16 nObjType;
-        rStrm.Ignore( 4 );
-        rStrm >> nObjType;
-        switch( nObjType )
-        {
-            case EXC_OBJTYPE_GROUP:         xDrawObj.reset( new XclImpGroupObj( rRoot ) );          break;
-            case EXC_OBJTYPE_LINE:          xDrawObj.reset( new XclImpLineObj( rRoot ) );           break;
-            case EXC_OBJTYPE_RECTANGLE:     xDrawObj.reset( new XclImpRectObj( rRoot ) );           break;
-            case EXC_OBJTYPE_OVAL:          xDrawObj.reset( new XclImpOvalObj( rRoot ) );           break;
-            case EXC_OBJTYPE_ARC:           xDrawObj.reset( new XclImpArcObj( rRoot ) );            break;
-            case EXC_OBJTYPE_CHART:         xDrawObj.reset( new XclImpChartObj( rRoot ) );          break;
-            case EXC_OBJTYPE_TEXT:          xDrawObj.reset( new XclImpTextObj( rRoot ) );           break;
-            case EXC_OBJTYPE_BUTTON:        xDrawObj.reset( new XclImpButtonObj( rRoot ) );         break;
-            case EXC_OBJTYPE_PICTURE:       xDrawObj.reset( new XclImpPictureObj( rRoot ) );        break;
-            case EXC_OBJTYPE_POLYGON:       xDrawObj.reset( new XclImpPolygonObj( rRoot ) );        break;
-            case EXC_OBJTYPE_CHECKBOX:      xDrawObj.reset( new XclImpCheckBoxObj( rRoot ) );       break;
-            case EXC_OBJTYPE_OPTIONBUTTON:  xDrawObj.reset( new XclImpOptionButtonObj( rRoot ) );   break;
-            case EXC_OBJTYPE_EDIT:          xDrawObj.reset( new XclImpEditObj( rRoot ) );           break;
-            case EXC_OBJTYPE_LABEL:         xDrawObj.reset( new XclImpLabelObj( rRoot ) );          break;
-            case EXC_OBJTYPE_DIALOG:        xDrawObj.reset( new XclImpDialogObj( rRoot ) );         break;
-            case EXC_OBJTYPE_SPIN:          xDrawObj.reset( new XclImpSpinButtonObj( rRoot ) );     break;
-            case EXC_OBJTYPE_SCROLLBAR:     xDrawObj.reset( new XclImpScrollBarObj( rRoot ) );      break;
-            case EXC_OBJTYPE_LISTBOX:       xDrawObj.reset( new XclImpListBoxObj( rRoot ) );        break;
-            case EXC_OBJTYPE_GROUPBOX:      xDrawObj.reset( new XclImpGroupBoxObj( rRoot ) );       break;
-            case EXC_OBJTYPE_DROPDOWN:      xDrawObj.reset( new XclImpDropDownObj( rRoot ) );       break;
-            default:
-                DBG_ERROR1( "XclImpDrawObjBase::ReadObj5 - unknown object type 0x%04hX", nObjType );
-                rRoot.GetTracer().TraceUnsupportedObjects();
-                xDrawObj.reset( new XclImpPhObj( rRoot ) );
-        }
-    }
-
-    xDrawObj->ImplReadObj5( rStrm );
-    return xDrawObj;
-}
-
-XclImpDrawObjRef XclImpDrawObjBase::ReadObj8( XclImpStream& rStrm )
-{
-    const XclImpRoot& rRoot = rStrm.GetRoot();
-    XclImpDrawObjRef xDrawObj;
-
-    if( rStrm.GetRecLeft() >= 10 )
-    {
-        sal_uInt16 nSubRecId, nSubRecSize, nObjType;
-        rStrm >> nSubRecId >> nSubRecSize >> nObjType;
-        DBG_ASSERT( nSubRecId == EXC_ID_OBJCMO, "XclImpDrawObjBase::ReadObj8 - OBJCMO subrecord expected" );
-        if( (nSubRecId == EXC_ID_OBJCMO) && (nSubRecSize >= 6) )
-        {
-            switch( nObjType )
-            {
-                // in BIFF8, all simple objects support text
-                case EXC_OBJTYPE_LINE:
-                case EXC_OBJTYPE_ARC:
-                    xDrawObj.reset( new XclImpTextObj( rRoot ) );
-                    // lines and arcs may be 2-dimensional
-                    xDrawObj->SetAreaObj( false );
-                break;
-
-                // in BIFF8, all simple objects support text
-                case EXC_OBJTYPE_RECTANGLE:
-                case EXC_OBJTYPE_OVAL:
-                case EXC_OBJTYPE_POLYGON:
-                case EXC_OBJTYPE_DRAWING:
-                case EXC_OBJTYPE_TEXT:
-                    xDrawObj.reset( new XclImpTextObj( rRoot ) );
-                break;
-
-                case EXC_OBJTYPE_GROUP:         xDrawObj.reset( new XclImpGroupObj( rRoot ) );          break;
-                case EXC_OBJTYPE_CHART:         xDrawObj.reset( new XclImpChartObj( rRoot ) );          break;
-                case EXC_OBJTYPE_BUTTON:        xDrawObj.reset( new XclImpButtonObj( rRoot ) );         break;
-                case EXC_OBJTYPE_PICTURE:       xDrawObj.reset( new XclImpPictureObj( rRoot ) );        break;
-                case EXC_OBJTYPE_CHECKBOX:      xDrawObj.reset( new XclImpCheckBoxObj( rRoot ) );       break;
-                case EXC_OBJTYPE_OPTIONBUTTON:  xDrawObj.reset( new XclImpOptionButtonObj( rRoot ) );   break;
-                case EXC_OBJTYPE_EDIT:          xDrawObj.reset( new XclImpEditObj( rRoot ) );           break;
-                case EXC_OBJTYPE_LABEL:         xDrawObj.reset( new XclImpLabelObj( rRoot ) );          break;
-                case EXC_OBJTYPE_DIALOG:        xDrawObj.reset( new XclImpDialogObj( rRoot ) );         break;
-                case EXC_OBJTYPE_SPIN:          xDrawObj.reset( new XclImpSpinButtonObj( rRoot ) );     break;
-                case EXC_OBJTYPE_SCROLLBAR:     xDrawObj.reset( new XclImpScrollBarObj( rRoot ) );      break;
-                case EXC_OBJTYPE_LISTBOX:       xDrawObj.reset( new XclImpListBoxObj( rRoot ) );        break;
-                case EXC_OBJTYPE_GROUPBOX:      xDrawObj.reset( new XclImpGroupBoxObj( rRoot ) );       break;
-                case EXC_OBJTYPE_DROPDOWN:      xDrawObj.reset( new XclImpDropDownObj( rRoot ) );       break;
-                case EXC_OBJTYPE_NOTE:          xDrawObj.reset( new XclImpNoteObj( rRoot ) );           break;
-
-                default:
-                    DBG_ERROR1( "XclImpDrawObjBase::ReadObj8 - unknown object type 0x%04hX", nObjType );
-                    rRoot.GetTracer().TraceUnsupportedObjects();
-                    xDrawObj.reset( new XclImpPhObj( rRoot ) );
-            }
-        }
-    }
-
-    xDrawObj->ImplReadObj8( rStrm );
-    return xDrawObj;
-}
-
-void XclImpDrawObjBase::SetDffData( const DffObjData& rDffObjData, const String& rObjName, const String& rHyperlink, bool bVisible, bool bAutoMargin )
-{
-    mnDffShapeId = rDffObjData.nShapeId;
-    mnDffFlags = rDffObjData.nSpFlags;
-    maObjName = rObjName;
-    maHyperlink = rHyperlink;
-    mbVisible = bVisible;
-    mbAutoMargin = bAutoMargin;
-}
-
-void XclImpDrawObjBase::SetAnchor( const XclObjAnchor& rAnchor )
-{
-    mxAnchor.reset( new XclObjAnchor( rAnchor ) );
-}
-
-String XclImpDrawObjBase::GetObjName() const
-{
-    /*  #118053# #i51348# Always return a non-empty name. Create English
-        default names depending on the object type. This is not implemented as
-        virtual functions in derived classes, as class type and object type may
-        not match. */
-    return (maObjName.Len() > 0) ? maObjName : GetObjectManager().GetDefaultObjName( *this );
-}
-
-bool XclImpDrawObjBase::IsValidSize( const Rectangle& rAnchorRect ) const
-{
-    // XclObjAnchor rounds up the width, width of 3 is the result of an Excel width of 0
-    return mbAreaObj ?
-        ((rAnchorRect.GetWidth() > 3) && (rAnchorRect.GetHeight() > 1)) :
-        ((rAnchorRect.GetWidth() > 3) || (rAnchorRect.GetHeight() > 1));
-}
-
-ScRange XclImpDrawObjBase::GetUsedArea() const
-{
-    ScRange aScUsedArea( ScAddress::INITIALIZE_INVALID );
-    if( mxAnchor.is() )
-    {
-        // #i44077# object inserted -> update used area for OLE object import
-        if( GetAddressConverter().ConvertRange( aScUsedArea, *mxAnchor, GetScTab(), GetScTab(), false ) )
-        {
-            // reduce range, if object ends directly on borders between two columns or rows
-            if( (mxAnchor->mnRX == 0) && (aScUsedArea.aStart.Col() < aScUsedArea.aEnd.Col()) )
-                aScUsedArea.aEnd.IncCol( -1 );
-            if( (mxAnchor->mnBY == 0) && (aScUsedArea.aStart.Row() < aScUsedArea.aEnd.Row()) )
-                aScUsedArea.aEnd.IncRow( -1 );
-        }
-    }
-    return aScUsedArea;
-}
-
-Rectangle XclImpDrawObjBase::GetAnchorRect() const
-{
-    Rectangle aAnchorRect;
-    if( mxAnchor.is() )
-        aAnchorRect = mxAnchor->GetRect( GetDoc(), MAP_100TH_MM );
-    return aAnchorRect;
-}
-
-sal_Size XclImpDrawObjBase::GetProgressSize() const
-{
-    return DoGetProgressSize();
-}
-
-SdrObject* XclImpDrawObjBase::CreateSdrObject( const Rectangle& rAnchorRect, ScfProgressBar& rProgress, bool bDffImport ) const
-{
-    SdrObjectPtr xSdrObj;
-    if( bDffImport && !mbCustomDff )
-    {
-        rProgress.Progress( GetProgressSize() );
-    }
-    else
-    {
-        xSdrObj.reset( DoCreateSdrObj( rAnchorRect, rProgress ) );
-        if( xSdrObj.is() )
-            xSdrObj->SetModel( GetDoc().GetDrawLayer() );
-    }
-    return xSdrObj.release();
-}
-
-void XclImpDrawObjBase::ProcessSdrObject( SdrObject& rSdrObj ) const
-{
-    // default: front layer, derived classes may have to set other layer in DoProcessSdrObj()
-    rSdrObj.NbcSetLayer( SC_LAYER_FRONT );
-
-    // set object name (GetObjName() will always return a non-empty name)
-    rSdrObj.SetName( GetObjName() );
-
-    // #i39167# full width for all objects regardless of horizontal alignment
-    rSdrObj.SetMergedItem( SdrTextHorzAdjustItem( SDRTEXTHORZADJUST_BLOCK ) );
-
-    // automatic text margin
-    if( mbAutoMargin )
-    {
-        sal_Int32 nMargin = GetObjectManager().GetDffManager().GetDefaultTextMargin();
-        rSdrObj.SetMergedItem( SdrTextLeftDistItem( nMargin ) );
-        rSdrObj.SetMergedItem( SdrTextRightDistItem( nMargin ) );
-        rSdrObj.SetMergedItem( SdrTextUpperDistItem( nMargin ) );
-        rSdrObj.SetMergedItem( SdrTextLowerDistItem( nMargin ) );
-    }
-
-    // macro and hyperlink
-    if( mbSimpleMacro && ((maMacroName.Len() > 0) ||
- (maHyperlink.Len() > 0)) )
-    {
-        if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
-        {
-            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName, GetDocShell() ) );
-            pInfo->SetHlink( maHyperlink );
-        }
-    }
-
-    // call virtual function for object type specific processing
-    DoProcessSdrObj( rSdrObj );
-}
-
-// protected ------------------------------------------------------------------
-
-void XclImpDrawObjBase::ReadName5( XclImpStream& rStrm, sal_uInt16 nNameLen )
-{
-    maObjName.Erase();
-    if( nNameLen > 0 )
-    {
-        // name length field is repeated before the name
-        maObjName = rStrm.ReadByteString( false );
-        // skip padding byte for word boundaries
-        if( rStrm.GetRecPos() & 1 ) rStrm.Ignore( 1 );
-    }
-}
-
-void XclImpDrawObjBase::ReadMacro3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    maMacroName.Erase();
-    rStrm.Ignore( nMacroSize );
-    // skip padding byte for word boundaries, not contained in nMacroSize
-    if( rStrm.GetRecPos() & 1 ) rStrm.Ignore( 1 );
-}
-
-void XclImpDrawObjBase::ReadMacro4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    maMacroName.Erase();
-    rStrm.Ignore( nMacroSize );
-}
-
-void XclImpDrawObjBase::ReadMacro5( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    maMacroName.Erase();
-    rStrm.Ignore( nMacroSize );
-}
-
-void XclImpDrawObjBase::ReadMacro8( XclImpStream& rStrm )
-{
-    maMacroName.Erase();
-    if( rStrm.GetRecLeft() > 6 )
-    {
-        // macro is stored in a tNameXR token containing a link to a defined name
-        sal_uInt16 nFmlaSize;
-        rStrm >> nFmlaSize;
-        rStrm.Ignore( 4 );
-        DBG_ASSERT( nFmlaSize == 7, "XclImpDrawObjBase::ReadMacro - unexpected formula size" );
-        if( nFmlaSize == 7 )
-        {
-            sal_uInt8 nTokenId;
-            sal_uInt16 nExtSheet, nExtName;
-            rStrm >> nTokenId >> nExtSheet >> nExtName;
-            DBG_ASSERT( nTokenId == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ),
-                "XclImpDrawObjBase::ReadMacro - tNameXR token expected" );
-            if( nTokenId == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ) )
-            {
-                maMacroName = GetLinkManager().GetMacroName( nExtSheet, nExtName );
-                // #i38718# missing module name - try to find the macro in the imported modules
-                if( maMacroName.Len() && (maMacroName.Search( '.' ) == STRING_NOTFOUND) )
-                    if( SfxObjectShell* pDocShell = GetDocShell() )
-                        if( StarBASIC* pBasic = pDocShell->GetBasic() )
-                            if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( maMacroName, SbxCLASS_METHOD ) ) )
-                                if( SbModule* pModule = pMethod->GetModule() )
-                                    maMacroName.Insert( '.', 0 ).Insert( pModule->GetName(), 0 );
-            }
-        }
-    }
-}
-
-void XclImpDrawObjBase::ConvertLineStyle( SdrObject& rSdrObj, const XclObjLineData& rLineData ) const
-{
-    if( rLineData.IsAuto() )
-    {
-        XclObjLineData aAutoData;
-        aAutoData.mnAuto = 0;
-        ConvertLineStyle( rSdrObj, aAutoData );
-    }
-    else
-    {
-        long nLineWidth = 35 * ::std::min( rLineData.mnWidth, EXC_OBJ_LINE_THICK );
-        rSdrObj.SetMergedItem( XLineWidthItem( nLineWidth ) );
-        rSdrObj.SetMergedItem( XLineColorItem( EMPTY_STRING, GetPalette().GetColor( rLineData.mnColorIdx ) ) );
-        rSdrObj.SetMergedItem( XLineJointItem( XLINEJOINT_MITER ) );
-
-        ULONG nDotLen = ::std::max< ULONG >( 70 * rLineData.mnWidth, 35 );
-        ULONG nDashLen = 3 * nDotLen;
-        ULONG nDist = 2 * nDotLen;
-
-        switch( rLineData.mnStyle )
-        {
-            default:
-            case EXC_OBJ_LINE_SOLID:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_SOLID ) );
-            break;
-            case EXC_OBJ_LINE_DASH:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_DASH ) );
-                rSdrObj.SetMergedItem( XLineDashItem( EMPTY_STRING, XDash( XDASH_RECT, 0, nDotLen, 1, nDashLen, nDist ) ) );
-            break;
-            case EXC_OBJ_LINE_DOT:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_DASH ) );
-                rSdrObj.SetMergedItem( XLineDashItem( EMPTY_STRING, XDash( XDASH_RECT, 1, nDotLen, 0, nDashLen, nDist ) ) );
-            break;
-            case EXC_OBJ_LINE_DASHDOT:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_DASH ) );
-                rSdrObj.SetMergedItem( XLineDashItem( EMPTY_STRING, XDash( XDASH_RECT, 1, nDotLen, 1, nDashLen, nDist ) ) );
-            break;
-            case EXC_OBJ_LINE_DASHDOTDOT:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_DASH ) );
-                rSdrObj.SetMergedItem( XLineDashItem( EMPTY_STRING, XDash( XDASH_RECT, 2, nDotLen, 1, nDashLen, nDist ) ) );
-            break;
-            case EXC_OBJ_LINE_MEDTRANS:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_SOLID ) );
-                rSdrObj.SetMergedItem( XLineTransparenceItem( 50 ) );
-            break;
-            case EXC_OBJ_LINE_DARKTRANS:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_SOLID ) );
-                rSdrObj.SetMergedItem( XLineTransparenceItem( 25 ) );
-            break;
-            case EXC_OBJ_LINE_LIGHTTRANS:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_SOLID ) );
-                rSdrObj.SetMergedItem( XLineTransparenceItem( 75 ) );
-            break;
-            case EXC_OBJ_LINE_NONE:
-                rSdrObj.SetMergedItem( XLineStyleItem( XLINE_NONE ) );
-            break;
-        }
-    }
-}
-
-void XclImpDrawObjBase::ConvertFillStyle( SdrObject& rSdrObj, const XclObjFillData& rFillData ) const
-{
-    if( rFillData.IsAuto() )
-    {
-        XclObjFillData aAutoData;
-        aAutoData.mnAuto = 0;
-        ConvertFillStyle( rSdrObj, aAutoData );
-    }
-    else if( rFillData.mnPattern == EXC_PATT_NONE )
-    {
-        rSdrObj.SetMergedItem( XFillStyleItem( XFILL_NONE ) );
-    }
-    else
-    {
-        Color aPattColor = GetPalette().GetColor( rFillData.mnPattColorIdx );
-        Color aBackColor = GetPalette().GetColor( rFillData.mnBackColorIdx );
-        if( (rFillData.mnPattern == EXC_PATT_SOLID) || (aPattColor == aBackColor) )
-        {
-            rSdrObj.SetMergedItem( XFillStyleItem( XFILL_SOLID ) );
-            rSdrObj.SetMergedItem( XFillColorItem( EMPTY_STRING, aPattColor ) );
-        }
-        else
-        {
-            static const sal_uInt8 sppnPatterns[][ 8 ] =
-            {
-                { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
-                { 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD },
-                { 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22 },
-                { 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00 },
-                { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC },
-                { 0x33, 0x66, 0xCC, 0x99, 0x33, 0x66, 0xCC, 0x99 },
-                { 0xCC, 0x66, 0x33, 0x99, 0xCC, 0x66, 0x33, 0x99 },
-                { 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33 },
-                { 0xCC, 0xFF, 0x33, 0xFF, 0xCC, 0xFF, 0x33, 0xFF },
-                { 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00 },
-                { 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88 },
-                { 0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88 },
-                { 0x88, 0x44, 0x22, 0x11, 0x88, 0x44, 0x22, 0x11 },
-                { 0xFF, 0x11, 0x11, 0x11, 0xFF, 0x11, 0x11, 0x11 },
-                { 0xAA, 0x44, 0xAA, 0x11, 0xAA, 0x44, 0xAA, 0x11 },
-                { 0x88, 0x00, 0x22, 0x00, 0x88, 0x00, 0x22, 0x00 },
-                { 0x80, 0x00, 0x08, 0x00, 0x80, 0x00, 0x08, 0x00 }
-            };
-            const sal_uInt8* const pnPattern = sppnPatterns[ ::std::min< size_t >( rFillData.mnPattern - 2, STATIC_TABLE_SIZE( sppnPatterns ) ) ];
-            // create 2-colored 8x8 DIB
-            SvMemoryStream aMemStrm;
-            aMemStrm << sal_uInt32( 12 ) << sal_Int16( 8 ) << sal_Int16( 8 ) << sal_uInt16( 1 ) << sal_uInt16( 1 );
-            aMemStrm << sal_uInt8( 0xFF ) << sal_uInt8( 0xFF ) << sal_uInt8( 0xFF );
-            aMemStrm << sal_uInt8( 0x00 ) << sal_uInt8( 0x00 ) << sal_uInt8( 0x00 );
-            for( size_t nIdx = 0; nIdx < 8; ++nIdx )
-                aMemStrm << sal_uInt32( pnPattern[ nIdx ] ); // 32-bit little-endian
-            aMemStrm.Seek( STREAM_SEEK_TO_BEGIN );
-            Bitmap aBitmap;
-            aBitmap.Read( aMemStrm, FALSE );
-            XOBitmap aXOBitmap( aBitmap );
-            aXOBitmap.Bitmap2Array();
-            aXOBitmap.SetBitmapType( XBITMAP_8X8 );
-            if( aXOBitmap.GetBackgroundColor().GetColor() == COL_BLACK )
-                ::std::swap( aPattColor, aBackColor );
-            aXOBitmap.SetPixelColor( aPattColor );
-            aXOBitmap.SetBackgroundColor( aBackColor );
-            rSdrObj.SetMergedItem( XFillStyleItem( XFILL_BITMAP ) );
-            rSdrObj.SetMergedItem( XFillBitmapItem( EMPTY_STRING, aXOBitmap ) );
-        }
-    }
-}
-
-void XclImpDrawObjBase::ConvertFrameStyle( SdrObject& rSdrObj, sal_uInt16 nFrameFlags ) const
-{
-    if( ::get_flag( nFrameFlags, EXC_OBJ_FRAME_SHADOW ) )
-    {
-        rSdrObj.SetMergedItem( SdrShadowItem( TRUE ) );
-        rSdrObj.SetMergedItem( SdrShadowXDistItem( 35 ) );
-        rSdrObj.SetMergedItem( SdrShadowYDistItem( 35 ) );
-        rSdrObj.SetMergedItem( SdrShadowColorItem( EMPTY_STRING, GetPalette().GetColor( EXC_COLOR_WINDOWTEXT ) ) );
-    }
-}
-
-Color XclImpDrawObjBase::GetSolidLineColor( const XclObjLineData& rLineData ) const
-{
-    Color aColor( COL_TRANSPARENT );
-    if( rLineData.IsAuto() )
-    {
-        XclObjLineData aAutoData;
-        aAutoData.mnAuto = 0;
-        aColor = GetSolidLineColor( aAutoData );
-    }
-    else if( rLineData.mnStyle != EXC_OBJ_LINE_NONE )
-    {
-        aColor = GetPalette().GetColor( rLineData.mnColorIdx );
-    }
-    return aColor;
-}
-
-Color XclImpDrawObjBase::GetSolidFillColor( const XclObjFillData& rFillData ) const
-{
-    Color aColor( COL_TRANSPARENT );
-    if( rFillData.IsAuto() )
-    {
-        XclObjFillData aAutoData;
-        aAutoData.mnAuto = 0;
-        aColor = GetSolidFillColor( aAutoData );
-    }
-    else if( rFillData.mnPattern != EXC_PATT_NONE )
-    {
-        Color aPattColor = GetPalette().GetColor( rFillData.mnPattColorIdx );
-        Color aBackColor = GetPalette().GetColor( rFillData.mnBackColorIdx );
-        aColor = XclTools::GetPatternColor( aPattColor, aBackColor, rFillData.mnPattern );
-    }
-    return aColor;
-}
-
-void XclImpDrawObjBase::DoReadObj3( XclImpStream&, sal_uInt16 )
-{
-}
-
-void XclImpDrawObjBase::DoReadObj4( XclImpStream&, sal_uInt16 )
-{
-}
-
-void XclImpDrawObjBase::DoReadObj5( XclImpStream&, sal_uInt16, sal_uInt16 )
-{
-}
-
-void XclImpDrawObjBase::DoReadObj8SubRec( XclImpStream&, sal_uInt16, sal_uInt16 )
-{
-}
-
-sal_Size XclImpDrawObjBase::DoGetProgressSize() const
-{
-    return 1;
-}
-
-SdrObject* XclImpDrawObjBase::DoCreateSdrObj( const Rectangle&, ScfProgressBar& rProgress ) const
-{
-    rProgress.Progress( GetProgressSize() );
-    return 0;
-}
-
-void XclImpDrawObjBase::DoProcessSdrObj( SdrObject& /*rSdrObj*/ ) const
-{
-    // trace if object is not printable
-    if( !IsPrintable() )
-        GetTracer().TraceObjectNotPrintable();
-}
-
-void XclImpDrawObjBase::ImplReadObj3( XclImpStream& rStrm )
-{
-    sal_uInt16 nObjFlags, nMacroSize;
-    XclObjAnchor aAnchor( GetCurrScTab() );
-
-    // back to offset 4 (ignore object count field)
-    rStrm.Seek( 4 );
-    rStrm >> mnObjType >> maObjId.mnObjId >> nObjFlags >> aAnchor >> nMacroSize;
-    rStrm.Ignore( 2 );
-
-    mbHidden = ::get_flag( nObjFlags, EXC_OBJ_HIDDEN );
-    mbVisible = ::get_flag( nObjFlags, EXC_OBJ_VISIBLE );
-    SetAnchor( aAnchor );
-    DoReadObj3( rStrm, nMacroSize );
-}
-
-void XclImpDrawObjBase::ImplReadObj4( XclImpStream& rStrm )
-{
-    sal_uInt16 nObjFlags, nMacroSize;
-    XclObjAnchor aAnchor( GetCurrScTab() );
-
-    // back to offset 4 (ignore object count field)
-    rStrm.Seek( 4 );
-    rStrm >> mnObjType >> maObjId.mnObjId >> nObjFlags >> aAnchor >> nMacroSize;
-    rStrm.Ignore( 2 );
-
-    mbHidden = ::get_flag( nObjFlags, EXC_OBJ_HIDDEN );
-    mbVisible = ::get_flag( nObjFlags, EXC_OBJ_VISIBLE );
-    mbPrintable = ::get_flag( nObjFlags, EXC_OBJ_PRINTABLE );
-    SetAnchor( aAnchor );
-    DoReadObj4( rStrm, nMacroSize );
-}
-
-void XclImpDrawObjBase::ImplReadObj5( XclImpStream& rStrm )
-{
-    sal_uInt16 nObjFlags, nMacroSize, nNameLen;
-    XclObjAnchor aAnchor( GetCurrScTab() );
-
-    // back to offset 4 (ignore object count field)
-    rStrm.Seek( 4 );
-    rStrm >> mnObjType >> maObjId.mnObjId >> nObjFlags >> aAnchor >> nMacroSize;
-    rStrm.Ignore( 2 );
-    rStrm >> nNameLen;
-    rStrm.Ignore( 2 );
-
-    mbHidden = ::get_flag( nObjFlags, EXC_OBJ_HIDDEN );
-    mbVisible = ::get_flag( nObjFlags, EXC_OBJ_VISIBLE );
-    mbPrintable = ::get_flag( nObjFlags, EXC_OBJ_PRINTABLE );
-    SetAnchor( aAnchor );
-    DoReadObj5( rStrm, nNameLen, nMacroSize );
-}
-
-void XclImpDrawObjBase::ImplReadObj8( XclImpStream& rStrm )
-{
-    // back to beginning
-    rStrm.Seek( EXC_REC_SEEK_TO_BEGIN );
-
-    bool bLoop = true;
-    while( bLoop && (rStrm.GetRecLeft() >= 4) )
-    {
-        sal_uInt16 nSubRecId, nSubRecSize;
-        rStrm >> nSubRecId >> nSubRecSize;
-        rStrm.PushPosition();
-        // sometimes the last subrecord has an invalid length (OBJLBSDATA) -> min()
-        nSubRecSize = static_cast< sal_uInt16 >( ::std::min< sal_Size >( nSubRecSize, rStrm.GetRecLeft() ) );
-
-        switch( nSubRecId )
-        {
-            case EXC_ID_OBJCMO:
-                DBG_ASSERT( rStrm.GetRecPos() == 4, "XclImpDrawObjBase::ImplReadObj8 - unexpected OBJCMO subrecord" );
-                if( (rStrm.GetRecPos() == 4) && (nSubRecSize >= 6) )
-                {
-                    sal_uInt16 nObjFlags;
-                    rStrm >> mnObjType >> maObjId.mnObjId >> nObjFlags;
-                    mbPrintable = ::get_flag( nObjFlags, EXC_OBJCMO_PRINTABLE );
-                }
-            break;
-            case EXC_ID_OBJMACRO:
-                ReadMacro8( rStrm );
-            break;
-            case EXC_ID_OBJEND:
-                bLoop = false;
-            break;
-            default:
-                DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-        }
-
-        rStrm.PopPosition();
-        rStrm.Ignore( nSubRecSize );
-    }
-
-    /*  Call DoReadObj8SubRec() with EXC_ID_OBJEND for further stream
-        processing (e.g. charts), even if the OBJEND subrecord is missing. */
-    DoReadObj8SubRec( rStrm, EXC_ID_OBJEND, 0 );
-
-    /*  Pictures that Excel reads from BIFF5 and writes to BIFF8 still have the
-        IMGDATA record following the OBJ record (but they use the image data
-        stored in DFF). The IMGDATA record may be continued by several CONTINUE
-        records. But the last CONTINUE record may be in fact an MSODRAWING
-        record that contains the DFF data of the next drawing object! So we
-        have to skip just enough CONTINUE records to look at the next
-        MSODRAWING/CONTINUE record. */
-    if( (rStrm.GetNextRecId() == EXC_ID3_IMGDATA) && rStrm.StartNextRecord() )
-    {
-        sal_uInt32 nDataSize;
-        rStrm.Ignore( 4 );
-        rStrm >> nDataSize;
-        nDataSize -= rStrm.GetRecLeft();
-        // skip following CONTINUE records until IMGDATA ends
-        while( (nDataSize > 0) && (rStrm.GetNextRecId() == EXC_ID_CONT) && rStrm.StartNextRecord() )
-        {
-            DBG_ASSERT( nDataSize >= rStrm.GetRecLeft(), "XclImpDrawObjBase::ImplReadObj8 - CONTINUE too long" );
-            nDataSize -= ::std::min< sal_uInt32 >( rStrm.GetRecLeft(), nDataSize );
-        }
-        DBG_ASSERT( nDataSize == 0, "XclImpDrawObjBase::ImplReadObj8 - missing CONTINUE records" );
-        // next record may be MSODRAWING or CONTINUE or anything else
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpDrawObjVector::InsertGrouped( XclImpDrawObjRef xDrawObj )
-{
-    if( !empty() )
-        if( XclImpGroupObj* pGroupObj = dynamic_cast< XclImpGroupObj* >( back().get() ) )
-            if( pGroupObj->TryInsert( xDrawObj ) )
-                return;
-    push_back( xDrawObj );
-}
-
-sal_Size XclImpDrawObjVector::GetProgressSize() const
-{
-    sal_Size nProgressSize = 0;
-    for( const_iterator aIt = begin(), aEnd = end(); aIt != aEnd; ++aIt )
-        nProgressSize += (*aIt)->GetProgressSize();
-    return nProgressSize;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpPhObj::XclImpPhObj( const XclImpRoot& rRoot ) :
-    XclImpDrawObjBase( rRoot )
-{
-    SetProcessSdrObj( false );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpGroupObj::XclImpGroupObj( const XclImpRoot& rRoot ) :
-    XclImpDrawObjBase( rRoot ),
-    mnFirstUngrouped( 0 )
-{
-}
-
-bool XclImpGroupObj::TryInsert( XclImpDrawObjRef xDrawObj )
-{
-    if( (xDrawObj->GetScTab() != GetScTab()) || (xDrawObj->GetObjId().mnObjId == mnFirstUngrouped) )
-        return false;
-    // insert into own list or into nested group
-    maChildren.InsertGrouped( xDrawObj );
-    return true;
-}
-
-void XclImpGroupObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    rStrm.Ignore( 4 );
-    rStrm >> mnFirstUngrouped;
-    rStrm.Ignore( 16 );
-    ReadMacro3( rStrm, nMacroSize );
-}
-
-void XclImpGroupObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    rStrm.Ignore( 4 );
-    rStrm >> mnFirstUngrouped;
-    rStrm.Ignore( 16 );
-    ReadMacro4( rStrm, nMacroSize );
-}
-
-void XclImpGroupObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    rStrm.Ignore( 4 );
-    rStrm >> mnFirstUngrouped;
-    rStrm.Ignore( 16 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-}
-
-sal_Size XclImpGroupObj::DoGetProgressSize() const
-{
-    return XclImpDrawObjBase::DoGetProgressSize() + maChildren.GetProgressSize();
-}
-
-SdrObject* XclImpGroupObj::DoCreateSdrObj( const Rectangle& /*rAnchorRect*/, ScfProgressBar& rProgress ) const
-{
-    TSdrObjectPtr< SdrObjGroup > xSdrObj( new SdrObjGroup );
-    // child objects in BIFF2-BIFF5 have absolute size, not needed to pass own anchor rectangle
-    for( XclImpDrawObjVector::const_iterator aIt = maChildren.begin(), aEnd = maChildren.end(); aIt != aEnd; ++aIt )
-        GetObjectManager().GetDffManager().ProcessObject( xSdrObj->GetSubList(), **aIt );
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpLineObj::XclImpLineObj( const XclImpRoot& rRoot ) :
-    XclImpDrawObjBase( rRoot ),
-    mnArrows( 0 ),
-    mnStartPoint( EXC_OBJ_LINE_TL )
-{
-    SetAreaObj( false );
-}
-
-void XclImpLineObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    rStrm >> maLineData >> mnArrows >> mnStartPoint;
-    rStrm.Ignore( 1 );
-    ReadMacro3( rStrm, nMacroSize );
-}
-
-void XclImpLineObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    rStrm >> maLineData >> mnArrows >> mnStartPoint;
-    rStrm.Ignore( 1 );
-    ReadMacro4( rStrm, nMacroSize );
-}
-
-void XclImpLineObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    rStrm >> maLineData >> mnArrows >> mnStartPoint;
-    rStrm.Ignore( 1 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-}
-
-SdrObject* XclImpLineObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    ::basegfx::B2DPolygon aB2DPolygon;
-    switch( mnStartPoint )
-    {
-        default:
-        case EXC_OBJ_LINE_TL:
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Left(), rAnchorRect.Top() ) );
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Right(), rAnchorRect.Bottom() ) );
-        break;
-        case EXC_OBJ_LINE_TR:
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Right(), rAnchorRect.Top() ) );
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Left(), rAnchorRect.Bottom() ) );
-        break;
-        case EXC_OBJ_LINE_BR:
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Right(), rAnchorRect.Bottom() ) );
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Left(), rAnchorRect.Top() ) );
-        break;
-        case EXC_OBJ_LINE_BL:
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Left(), rAnchorRect.Bottom() ) );
-            aB2DPolygon.append( ::basegfx::B2DPoint( rAnchorRect.Right(), rAnchorRect.Top() ) );
-        break;
-    }
-    SdrObjectPtr xSdrObj( new SdrPathObj( OBJ_LINE, ::basegfx::B2DPolyPolygon( aB2DPolygon ) ) );
-    ConvertLineStyle( *xSdrObj, maLineData );
-
-    // line ends
-    sal_uInt8 nArrowType = ::extract_value< sal_uInt8 >( mnArrows, 0, 4 );
-    bool bLineStart = false;
-    bool bLineEnd = false;
-    bool bFilled = false;
-    switch( nArrowType )
-    {
-        case EXC_OBJ_ARROW_OPEN:        bLineStart = false; bLineEnd = true;  bFilled = false;  break;
-        case EXC_OBJ_ARROW_OPENBOTH:    bLineStart = true;  bLineEnd = true;  bFilled = false;  break;
-        case EXC_OBJ_ARROW_FILLED:      bLineStart = false; bLineEnd = true;  bFilled = true;   break;
-        case EXC_OBJ_ARROW_FILLEDBOTH:  bLineStart = true;  bLineEnd = true;  bFilled = true;   break;
-    }
-    if( bLineStart || bLineEnd )
-    {
-        sal_uInt8 nArrowWidth = ::extract_value< sal_uInt8 >( mnArrows, 4, 4 );
-        double fArrowWidth = 3.0;
-        switch( nArrowWidth )
-        {
-            case EXC_OBJ_ARROW_NARROW:  fArrowWidth = 2.0;  break;
-            case EXC_OBJ_ARROW_MEDIUM:  fArrowWidth = 3.0;  break;
-            case EXC_OBJ_ARROW_WIDE:    fArrowWidth = 5.0;  break;
-        }
-
-        sal_uInt8 nArrowLength = ::extract_value< sal_uInt8 >( mnArrows, 8, 4 );
-        double fArrowLength = 3.0;
-        switch( nArrowLength )
-        {
-            case EXC_OBJ_ARROW_NARROW:  fArrowLength = 2.5; break;
-            case EXC_OBJ_ARROW_MEDIUM:  fArrowLength = 3.5; break;
-            case EXC_OBJ_ARROW_WIDE:    fArrowLength = 6.0; break;
-        }
-
-        ::basegfx::B2DPolygon aArrowPoly;
-#define EXC_ARROW_POINT( x, y ) ::basegfx::B2DPoint( fArrowWidth * (x), fArrowLength * (y) )
-        if( bFilled )
-        {
-            aArrowPoly.append( EXC_ARROW_POINT(   0, 100 ) );
-            aArrowPoly.append( EXC_ARROW_POINT(  50,   0 ) );
-            aArrowPoly.append( EXC_ARROW_POINT( 100, 100 ) );
-        }
-        else
-        {
-            sal_uInt8 nLineWidth = ::limit_cast< sal_uInt8 >( maLineData.mnWidth, EXC_OBJ_LINE_THIN, EXC_OBJ_LINE_THICK );
-            aArrowPoly.append( EXC_ARROW_POINT( 50, 0 ) );
-            aArrowPoly.append( EXC_ARROW_POINT( 100, 100 - 3 * nLineWidth ) );
-            aArrowPoly.append( EXC_ARROW_POINT( 100 - 5 * nLineWidth, 100 ) );
-            aArrowPoly.append( EXC_ARROW_POINT( 50, 12 * nLineWidth ) );
-            aArrowPoly.append( EXC_ARROW_POINT( 5 * nLineWidth, 100 ) );
-            aArrowPoly.append( EXC_ARROW_POINT( 0, 100 - 3 * nLineWidth ) );
-        }
-#undef EXC_ARROW_POINT
-
-        ::basegfx::B2DPolyPolygon aArrowPolyPoly( aArrowPoly );
-        long nWidth = static_cast< long >( 125 * fArrowWidth );
-        if( bLineStart )
-        {
-            xSdrObj->SetMergedItem( XLineStartItem( EMPTY_STRING, aArrowPolyPoly ) );
-            xSdrObj->SetMergedItem( XLineStartWidthItem( nWidth ) );
-            xSdrObj->SetMergedItem( XLineStartCenterItem( FALSE ) );
-        }
-        if( bLineEnd )
-        {
-            xSdrObj->SetMergedItem( XLineEndItem( EMPTY_STRING, aArrowPolyPoly ) );
-            xSdrObj->SetMergedItem( XLineEndWidthItem( nWidth ) );
-            xSdrObj->SetMergedItem( XLineEndCenterItem( FALSE ) );
-        }
-    }
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpRectObj::XclImpRectObj( const XclImpRoot& rRoot ) :
-    XclImpDrawObjBase( rRoot ),
-    mnFrameFlags( 0 )
-{
-    SetAreaObj( true );
-}
-
-void XclImpRectObj::ReadFrameData( XclImpStream& rStrm )
-{
-    rStrm >> maFillData >> maLineData >> mnFrameFlags;
-}
-
-void XclImpRectObj::ConvertRectStyle( SdrObject& rSdrObj ) const
-{
-    ConvertLineStyle( rSdrObj, maLineData );
-    ConvertFillStyle( rSdrObj, maFillData );
-    ConvertFrameStyle( rSdrObj, mnFrameFlags );
-}
-
-void XclImpRectObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    ReadMacro3( rStrm, nMacroSize );
-}
-
-void XclImpRectObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    ReadMacro4( rStrm, nMacroSize );
-}
-
-void XclImpRectObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-}
-
-SdrObject* XclImpRectObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    SdrObjectPtr xSdrObj( new SdrRectObj( rAnchorRect ) );
-    ConvertRectStyle( *xSdrObj );
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpOvalObj::XclImpOvalObj( const XclImpRoot& rRoot ) :
-    XclImpRectObj( rRoot )
-{
-}
-
-SdrObject* XclImpOvalObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    SdrObjectPtr xSdrObj( new SdrCircObj( OBJ_CIRC, rAnchorRect ) );
-    ConvertRectStyle( *xSdrObj );
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpArcObj::XclImpArcObj( const XclImpRoot& rRoot ) :
-    XclImpDrawObjBase( rRoot ),
-    mnQuadrant( EXC_OBJ_ARC_TR )
-{
-    SetAreaObj( false );    // arc may be 2-dimensional
-}
-
-void XclImpArcObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    rStrm >> maFillData >> maLineData >> mnQuadrant;
-    rStrm.Ignore( 1 );
-    ReadMacro3( rStrm, nMacroSize );
-}
-
-void XclImpArcObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    rStrm >> maFillData >> maLineData >> mnQuadrant;
-    rStrm.Ignore( 1 );
-    ReadMacro4( rStrm, nMacroSize );
-}
-
-void XclImpArcObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    rStrm >> maFillData >> maLineData >> mnQuadrant;
-    rStrm.Ignore( 1 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-}
-
-SdrObject* XclImpArcObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    Rectangle aNewRect = rAnchorRect;
-    long nStartAngle = 0;
-    long nEndAngle = 0;
-    switch( mnQuadrant )
-    {
-        default:
-        case EXC_OBJ_ARC_TR:
-            nStartAngle = 0;
-            nEndAngle = 9000;
-            aNewRect.Left() -= rAnchorRect.GetWidth();
-            aNewRect.Bottom() += rAnchorRect.GetHeight();
-        break;
-        case EXC_OBJ_ARC_TL:
-            nStartAngle = 9000;
-            nEndAngle = 18000;
-            aNewRect.Right() += rAnchorRect.GetWidth();
-            aNewRect.Bottom() += rAnchorRect.GetHeight();
-        break;
-        case EXC_OBJ_ARC_BL:
-            nStartAngle = 18000;
-            nEndAngle = 27000;
-            aNewRect.Right() += rAnchorRect.GetWidth();
-            aNewRect.Top() -= rAnchorRect.GetHeight();
-        break;
-        case EXC_OBJ_ARC_BR:
-            nStartAngle = 27000;
-            nEndAngle = 0;
-            aNewRect.Left() -= rAnchorRect.GetWidth();
-            aNewRect.Top() -= rAnchorRect.GetHeight();
-        break;
-    }
-    SdrObjKind eObjKind = maFillData.IsFilled() ? OBJ_SECT : OBJ_CARC;
-    SdrObjectPtr xSdrObj( new SdrCircObj( eObjKind, aNewRect, nStartAngle, nEndAngle ) );
-    ConvertFillStyle( *xSdrObj, maFillData );
-    ConvertLineStyle( *xSdrObj, maLineData );
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpPolygonObj::XclImpPolygonObj( const XclImpRoot& rRoot ) :
-    XclImpRectObj( rRoot ),
-    mnPolyFlags( 0 ),
-    mnPointCount( 0 )
-{
-    SetAreaObj( false );    // polygon may be 2-dimensional
-}
-
-void XclImpPolygonObj::ReadCoordList( XclImpStream& rStrm )
-{
-    if( (rStrm.GetNextRecId() == EXC_ID_COORDLIST) && rStrm.StartNextRecord() )
-    {
-        DBG_ASSERT( rStrm.GetRecLeft() / 4 == mnPointCount, "XclImpPolygonObj::ReadCoordList - wrong polygon point count" );
-        while( rStrm.GetRecLeft() >= 4 )
-        {
-            sal_uInt16 nX, nY;
-            rStrm >> nX >> nY;
-            maCoords.push_back( Point( nX, nY ) );
-        }
-    }
-}
-
-void XclImpPolygonObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    rStrm >> mnPolyFlags;
-    rStrm.Ignore( 10 );
-    rStrm >> mnPointCount;
-    rStrm.Ignore( 8 );
-    ReadMacro4( rStrm, nMacroSize );
-    ReadCoordList( rStrm );
-}
-
-void XclImpPolygonObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    rStrm >> mnPolyFlags;
-    rStrm.Ignore( 10 );
-    rStrm >> mnPointCount;
-    rStrm.Ignore( 8 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-    ReadCoordList( rStrm );
-}
-
-namespace {
-
-::basegfx::B2DPoint lclGetPolyPoint( const Rectangle& rAnchorRect, const Point& rPoint )
-{
-    return ::basegfx::B2DPoint(
-        rAnchorRect.Left() + static_cast< sal_Int32 >( ::std::min< double >( rPoint.X(), 16384.0 ) / 16384.0 * rAnchorRect.GetWidth() + 0.5 ),
-        rAnchorRect.Top() + static_cast< sal_Int32 >( ::std::min< double >( rPoint.Y(), 16384.0 ) / 16384.0 * rAnchorRect.GetHeight() + 0.5 ) );
-}
-
-} // namespace
-
-SdrObject* XclImpPolygonObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    SdrObjectPtr xSdrObj;
-    if( maCoords.size() >= 2 )
-    {
-        // create the polygon
-        ::basegfx::B2DPolygon aB2DPolygon;
-        for( PointVector::const_iterator aIt = maCoords.begin(), aEnd = maCoords.end(); aIt != aEnd; ++aIt )
-            aB2DPolygon.append( lclGetPolyPoint( rAnchorRect, *aIt ) );
-        // close polygon if specified
-        if( ::get_flag( mnPolyFlags, EXC_OBJ_POLY_CLOSED ) && (maCoords.front() != maCoords.back()) )
-            aB2DPolygon.append( lclGetPolyPoint( rAnchorRect, maCoords.front() ) );
-        // create the SdrObject
-        SdrObjKind eObjKind = maFillData.IsFilled() ? OBJ_PATHPOLY : OBJ_PATHPLIN;
-        xSdrObj.reset( new SdrPathObj( eObjKind, ::basegfx::B2DPolyPolygon( aB2DPolygon ) ) );
-        ConvertRectStyle( *xSdrObj );
-    }
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpObjTextData::ReadByteString( XclImpStream& rStrm )
-{
-    mxString.reset();
-    if( maData.mnTextLen > 0 )
-    {
-        mxString.reset( new XclImpString( rStrm.ReadRawByteString( maData.mnTextLen ) ) );
-        // skip padding byte for word boundaries
-        if( rStrm.GetRecPos() & 1 ) rStrm.Ignore( 1 );
-    }
-}
-
-void XclImpObjTextData::ReadFormats( XclImpStream& rStrm )
-{
-    if( mxString.is() )
-        mxString->ReadObjFormats( rStrm, maData.mnFormatSize );
-    else
-        rStrm.Ignore( maData.mnFormatSize );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpTextObj::XclImpTextObj( const XclImpRoot& rRoot ) :
-    XclImpRectObj( rRoot )
-{
-}
-
-void XclImpTextObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    maTextData.maData.ReadObj3( rStrm );
-    ReadMacro3( rStrm, nMacroSize );
-    maTextData.ReadByteString( rStrm );
-    maTextData.ReadFormats( rStrm );
-}
-
-void XclImpTextObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    maTextData.maData.ReadObj3( rStrm );
-    ReadMacro4( rStrm, nMacroSize );
-    maTextData.ReadByteString( rStrm );
-    maTextData.ReadFormats( rStrm );
-}
-
-void XclImpTextObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    ReadFrameData( rStrm );
-    maTextData.maData.ReadObj5( rStrm );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-    maTextData.ReadByteString( rStrm );
-    rStrm.Ignore( maTextData.maData.mnLinkSize );   // ignore text link formula
-    maTextData.ReadFormats( rStrm );
-}
-
-SdrObject* XclImpTextObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    TSdrObjectPtr< SdrObjCustomShape > xSdrObj( new SdrObjCustomShape );
-    xSdrObj->NbcSetSnapRect( rAnchorRect );
-    OUString aRectType = CREATE_OUSTRING( "rectangle" );
-    xSdrObj->MergeDefaultAttributes( &aRectType );
-    ConvertRectStyle( *xSdrObj );
-    BOOL bAutoSize = ::get_flag( maTextData.maData.mnFlags, EXC_OBJ_TEXT_AUTOSIZE );
-    xSdrObj->SetMergedItem( SdrTextAutoGrowWidthItem( bAutoSize ) );
-    xSdrObj->SetMergedItem( SdrTextAutoGrowHeightItem( bAutoSize ) );
-    xSdrObj->SetMergedItem( SdrTextWordWrapItem( TRUE ) );
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-void XclImpTextObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
-{
-    // set text data
-    if( SdrTextObj* pTextObj = dynamic_cast< SdrTextObj* >( &rSdrObj ) )
-    {
-        if( maTextData.mxString.is() )
-        {
-            if( maTextData.mxString->IsRich() )
-            {
-                // rich text
-                ::std::auto_ptr< EditTextObject > xEditObj(
-                    XclImpStringHelper::CreateTextObject( GetRoot(), *maTextData.mxString ) );
-                OutlinerParaObject* pOutlineObj = new OutlinerParaObject( *xEditObj );
-                pOutlineObj->SetOutlinerMode( OUTLINERMODE_TEXTOBJECT );
-                // text object takes ownership of the outliner object
-                pTextObj->NbcSetOutlinerParaObject( pOutlineObj );
-            }
-            else
-            {
-                // plain text
-                pTextObj->NbcSetText( maTextData.mxString->GetText() );
-            }
-
-            /*  #i96858# Do not apply any formatting if there is no text.
-                SdrObjCustomShape::SetVerticalWriting (initiated from
-                SetMergedItem) calls SdrTextObj::ForceOutlinerParaObject which
-                ensures that we can erroneously write a ClientTextbox record
-                (with no content) while exporting to XLS, which can cause a
-                corrupted exported document. */
-
-            // horizontal text alignment
-            SvxAdjust eHorAlign = SVX_ADJUST_LEFT;
-            switch( maTextData.maData.GetHorAlign() )
-            {
-                case EXC_OBJ_HOR_LEFT:      eHorAlign = SVX_ADJUST_LEFT;    break;
-                case EXC_OBJ_HOR_CENTER:    eHorAlign = SVX_ADJUST_CENTER;  break;
-                case EXC_OBJ_HOR_RIGHT:     eHorAlign = SVX_ADJUST_RIGHT;   break;
-                case EXC_OBJ_HOR_JUSTIFY:   eHorAlign = SVX_ADJUST_BLOCK;   break;
-            }
-            rSdrObj.SetMergedItem( SvxAdjustItem( eHorAlign, EE_PARA_JUST ) );
-
-            // vertical text alignment
-            SdrTextVertAdjust eVerAlign = SDRTEXTVERTADJUST_TOP;
-            switch( maTextData.maData.GetVerAlign() )
-            {
-                case EXC_OBJ_VER_TOP:       eVerAlign = SDRTEXTVERTADJUST_TOP;      break;
-                case EXC_OBJ_VER_CENTER:    eVerAlign = SDRTEXTVERTADJUST_CENTER;   break;
-                case EXC_OBJ_VER_BOTTOM:    eVerAlign = SDRTEXTVERTADJUST_BOTTOM;   break;
-                case EXC_OBJ_VER_JUSTIFY:   eVerAlign = SDRTEXTVERTADJUST_BLOCK;    break;
-            }
-            rSdrObj.SetMergedItem( SdrTextVertAdjustItem( eVerAlign ) );
-
-            // orientation (this is only a fake, drawing does not support real text orientation)
-            namespace csst = ::com::sun::star::text;
-            csst::WritingMode eWriteMode = csst::WritingMode_LR_TB;
-            switch( maTextData.maData.mnOrient )
-            {
-                case EXC_OBJ_ORIENT_NONE:       eWriteMode = csst::WritingMode_LR_TB;   break;
-                case EXC_OBJ_ORIENT_STACKED:    eWriteMode = csst::WritingMode_TB_RL;   break;
-                case EXC_OBJ_ORIENT_90CCW:      eWriteMode = csst::WritingMode_TB_RL;   break;
-                case EXC_OBJ_ORIENT_90CW:       eWriteMode = csst::WritingMode_TB_RL;   break;
-            }
-            rSdrObj.SetMergedItem( SvxWritingModeItem( eWriteMode, SDRATTR_TEXTDIRECTION ) );
-        }
-    }
-    // base class processing
-    XclImpRectObj::DoProcessSdrObj( rSdrObj );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChartObj::XclImpChartObj( const XclImpRoot& rRoot, bool bOwnTab ) :
-    XclImpRectObj( rRoot ),
-    mbOwnTab( bOwnTab )
-{
-    SetSimpleMacro( false );
-    SetCustomDffObj( true );
-}
-
-void XclImpChartObj::ReadChartSubStream( XclImpStream& rStrm )
-{
-    if( mbOwnTab ? (rStrm.GetRecId() == EXC_ID5_BOF) : ((rStrm.GetNextRecId() == EXC_ID5_BOF) && rStrm.StartNextRecord()) )
-    {
-        sal_uInt16 nBofType;
-        rStrm.Seek( 2 );
-        rStrm >> nBofType;
-        DBG_ASSERT( nBofType == EXC_BOF_CHART, "XclImpChartObj::ReadChartSubStream - no chart BOF record" );
-
-        // read chart, even if BOF record contains wrong substream identifier
-        mxChart.reset( new XclImpChart( GetRoot(), mbOwnTab ) );
-        mxChart->ReadChartSubStream( rStrm );
-        if( mbOwnTab )
-            FinalizeTabChart();
-    }
-    else
-    {
-        DBG_ERRORFILE( "XclImpChartObj::ReadChartSubStream - missing chart substream" );
-    }
-}
-
-void XclImpChartObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    // read OBJ record and the following chart substream
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 18 );
-    ReadMacro3( rStrm, nMacroSize );
-#if 0
-    ReadChartSubStream( rStrm );
-#endif
-    // set frame format from OBJ record, it is used if chart itself is transparent
-    if( mxChart.is() )
-        mxChart->UpdateObjFrame( maLineData, maFillData );
-}
-
-void XclImpChartObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    // read OBJ record and the following chart substream
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 18 );
-    ReadMacro4( rStrm, nMacroSize );
-#if 0
-    ReadChartSubStream( rStrm );
-#endif
-    // set frame format from OBJ record, it is used if chart itself is transparent
-    if( mxChart.is() )
-        mxChart->UpdateObjFrame( maLineData, maFillData );
-}
-
-void XclImpChartObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    // read OBJ record and the following chart substream
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 18 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-    ReadChartSubStream( rStrm );
-    // set frame format from OBJ record, it is used if chart itself is transparent
-    if( mxChart.is() )
-        mxChart->UpdateObjFrame( maLineData, maFillData );
-}
-
-void XclImpChartObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 /*nSubRecSize*/ )
-{
-    // read the following chart substream
-    if( nSubRecId == EXC_ID_OBJEND )
-    {
-        // enable CONTINUE handling for the entire chart substream
-        rStrm.ResetRecord( true );
-        ReadChartSubStream( rStrm );
-        /*  #90118# disable CONTINUE handling again to be able to read
-            following CONTINUE records as MSODRAWING records. */
-        rStrm.ResetRecord( false );
-    }
-}
-
-sal_Size XclImpChartObj::DoGetProgressSize() const
-{
-    return mxChart.is() ? mxChart->GetProgressSize() : 1;
-}
-
-SdrObject* XclImpChartObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    SdrObjectPtr xSdrObj;
-    SfxObjectShell* pDocShell = GetDocShell();
-    if( SvtModuleOptions().IsChart() && pDocShell && mxChart.is() && !mxChart->IsPivotChart() )
-    {
-        // create embedded chart object
-        OUString aEmbObjName;
-        Reference< XEmbeddedObject > xEmbObj = pDocShell->GetEmbeddedObjectContainer().
-                CreateEmbeddedObject( SvGlobalName( SO3_SCH_CLASSID ).GetByteSequence(), aEmbObjName );
-
-        /*  Set the size to the embedded object, this prevents that font sizes
-            of text objects are changed in the chart when the object is
-            inserted into the draw page. */
-        sal_Int64 nAspect = ::com::sun::star::embed::Aspects::MSOLE_CONTENT;
-        MapUnit aUnit = VCLUnoHelper::UnoEmbed2VCLMapUnit( xEmbObj->getMapUnit( nAspect ) );
-        Size aSize( Window::LogicToLogic( rAnchorRect.GetSize(), MapMode( MAP_100TH_MM ), MapMode( aUnit ) ) );
-        ::com::sun::star::awt::Size aAwtSize( aSize.Width(), aSize.Height() );
-        xEmbObj->setVisualAreaSize( nAspect, aAwtSize );
-
-        // create the container OLE object
-        xSdrObj.reset( new SdrOle2Obj( svt::EmbeddedObjectRef( xEmbObj, nAspect ), aEmbObjName, rAnchorRect ) );
-
-        // convert Excel chart to OOo Chart
-        if( svt::EmbeddedObjectRef::TryRunningState( xEmbObj ) )
-        {
-            Reference< XModel > xModel( xEmbObj->getComponent(), UNO_QUERY );
-            mxChart->Convert( xModel, rProgress, aEmbObjName );
-
-            Reference< XEmbedPersist > xPers( xEmbObj, UNO_QUERY );
-            if( xPers.is() )
-                xPers->storeOwn();
-        }
-    }
-
-    return xSdrObj.release();
-}
-
-void XclImpChartObj::FinalizeTabChart()
-{
-    /*  #i44077# Calculate and store DFF anchor for sheet charts.
-        Needed to get used area if this chart is inserted as OLE object. */
-    DBG_ASSERT( mbOwnTab, "XclImpChartObj::FinalizeTabChart - not allowed for embedded chart objects" );
-
-    // set uninitialized page to landscape
-    if( !GetPageSettings().GetPageData().mbValid )
-        GetPageSettings().SetPaperSize( EXC_PAPERSIZE_DEFAULT, false );
-
-    // calculate size of the chart object
-    const XclPageData& rPageData = GetPageSettings().GetPageData();
-    Size aPaperSize( rPageData.GetScPaperSize() );
-
-    long nWidth = XclTools::GetHmmFromTwips( aPaperSize.Width() );
-    long nHeight = XclTools::GetHmmFromTwips( aPaperSize.Height() );
-
-    // subtract page margins, give 1cm extra space
-    nWidth -= (XclTools::GetHmmFromInch( rPageData.mfLeftMargin + rPageData.mfRightMargin ) + 2000);
-    nHeight -= (XclTools::GetHmmFromInch( rPageData.mfTopMargin + rPageData.mfBottomMargin ) + 1000);
-
-    // print column/row headers?
-    if( rPageData.mbPrintHeadings )
-    {
-        nWidth -= 2000;
-        nHeight -= 1000;
-    }
-
-    // create the object anchor
-    XclObjAnchor aAnchor( GetScTab() );
-    aAnchor.SetRect( GetDoc(), Rectangle( 1000, 500, nWidth, nHeight ), MAP_100TH_MM );
-    SetAnchor( aAnchor );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpNoteObj::XclImpNoteObj( const XclImpRoot& rRoot ) :
-    XclImpTextObj( rRoot ),
-    maScPos( ScAddress::INITIALIZE_INVALID ),
-    mnNoteFlags( 0 )
-{
-    SetSimpleMacro( false );
-    // caption object will be created manually
-    SetInsertSdrObj( false );
-}
-
-void XclImpNoteObj::SetNoteData( const ScAddress& rScPos, sal_uInt16 nNoteFlags )
-{
-    maScPos = rScPos;
-    mnNoteFlags = nNoteFlags;
-}
-
-void XclImpNoteObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
-{
-    // create formatted text
-    XclImpTextObj::DoProcessSdrObj( rSdrObj );
-    OutlinerParaObject* pOutlinerObj = rSdrObj.GetOutlinerParaObject();
-    if( maScPos.IsValid() && pOutlinerObj )
-    {
-        // create cell note with all data from drawing object
-        ScNoteUtil::CreateNoteFromObjectData(
-            GetDoc(), maScPos,
-            rSdrObj.GetMergedItemSet().Clone(),             // new object on heap expected
-            new OutlinerParaObject( *pOutlinerObj ),        // new object on heap expected
-            rSdrObj.GetLogicRect(),
-            ::get_flag( mnNoteFlags, EXC_NOTE_VISIBLE ),
-            false );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpControlHelper::XclImpControlHelper( const XclImpRoot& rRoot, XclCtrlBindMode eBindMode ) :
-    mrRoot( rRoot ),
-    meBindMode( eBindMode )
-{
-}
-
-XclImpControlHelper::~XclImpControlHelper()
-{
-}
-
-SdrObject* XclImpControlHelper::CreateSdrObjectFromShape(
-        const Reference< XShape >& rxShape, const Rectangle& rAnchorRect ) const
-{
-    mxShape = rxShape;
-    SdrObjectPtr xSdrObj( SdrObject::getSdrObjectFromXShape( rxShape ) );
-    if( xSdrObj.is() )
-    {
-        xSdrObj->NbcSetSnapRect( rAnchorRect );
-        // #i30543# insert into control layer
-        xSdrObj->NbcSetLayer( SC_LAYER_CONTROLS );
-    }
-    return xSdrObj.release();
-}
-
-void XclImpControlHelper::ApplySheetLinkProps() const
-{
-
-    Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
-    if( !xCtrlModel.is() )
-        return;
-    ScfPropertySet aPropSet( xCtrlModel );
-
-   // sheet links
-    if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
-    {
-        Reference< XMultiServiceFactory > xFactory( pDocShell->GetModel(), UNO_QUERY );
-        if( xFactory.is() )
-        {
-            // cell link
-            if( mxCellLink.is() ) try
-            {
-                Reference< XBindableValue > xBindable( xCtrlModel, UNO_QUERY_THROW );
-
-                // create argument sequence for createInstanceWithArguments()
-                CellAddress aApiAddress;
-                ScUnoConversion::FillApiAddress( aApiAddress, *mxCellLink );
-
-                NamedValue aValue;
-                aValue.Name = CREATE_OUSTRING( SC_UNONAME_BOUNDCELL );
-                aValue.Value <<= aApiAddress;
-
-                Sequence< Any > aArgs( 1 );
-                aArgs[ 0 ] <<= aValue;
-
-                // create the CellValueBinding instance and set at the control model
-                OUString aServiceName;
-                switch( meBindMode )
-                {
-                    case EXC_CTRL_BINDCONTENT:  aServiceName = CREATE_OUSTRING( SC_SERVICENAME_VALBIND );       break;
-                    case EXC_CTRL_BINDPOSITION: aServiceName = CREATE_OUSTRING( SC_SERVICENAME_LISTCELLBIND );  break;
-                }
-                Reference< XValueBinding > xBinding(
-                    xFactory->createInstanceWithArguments( aServiceName, aArgs ), UNO_QUERY_THROW );
-                xBindable->setValueBinding( xBinding );
-            }
-            catch( const Exception& )
-            {
-            }
-
-            // source range
-            if( mxSrcRange.is() ) try
-            {
-                Reference< XListEntrySink > xEntrySink( xCtrlModel, UNO_QUERY_THROW );
-
-                // create argument sequence for createInstanceWithArguments()
-                CellRangeAddress aApiRange;
-                ScUnoConversion::FillApiRange( aApiRange, *mxSrcRange );
-
-                NamedValue aValue;
-                aValue.Name = CREATE_OUSTRING( SC_UNONAME_CELLRANGE );
-                aValue.Value <<= aApiRange;
-
-                Sequence< Any > aArgs( 1 );
-                aArgs[ 0 ] <<= aValue;
-
-                // create the EntrySource instance and set at the control model
-                Reference< XListEntrySource > xEntrySource( xFactory->createInstanceWithArguments(
-                    CREATE_OUSTRING( SC_SERVICENAME_LISTSOURCE ), aArgs ), UNO_QUERY_THROW );
-                xEntrySink->setListEntrySource( xEntrySource );
-            }
-            catch( const Exception& )
-            {
-            }
-        }
-    }
-}
-
-void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
-{
-    Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
-    if( !xCtrlModel.is() )
-        return;
-
-    ApplySheetLinkProps();
-
-    ScfPropertySet aPropSet( xCtrlModel );
-
-    // #118053# #i51348# set object name at control model
-    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
-
-    // control visible and printable?
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
-
- 
-    // virtual call for type specific processing
-    DoProcessControl( aPropSet );
-}
-
-void XclImpControlHelper::ReadCellLinkFormula( XclImpStream& rStrm, bool bWithBoundSize )
-{
-    ScRangeList aScRanges;
-    ReadRangeList( aScRanges, rStrm, bWithBoundSize );
-    // Use first cell of first range
-    if( const ScRange* pScRange = aScRanges.GetObject( 0 ) )
-        mxCellLink.reset( new ScAddress( pScRange->aStart ) );
-}
-
-void XclImpControlHelper::ReadSourceRangeFormula( XclImpStream& rStrm, bool bWithBoundSize )
-{
-    ScRangeList aScRanges;
-    ReadRangeList( aScRanges, rStrm, bWithBoundSize );
-    // Use first range
-    if( const ScRange* pScRange = aScRanges.GetObject( 0 ) )
-        mxSrcRange.reset( new ScRange( *pScRange ) );
-}
-
-void XclImpControlHelper::DoProcessControl( ScfPropertySet& ) const
-{
-}
-
-void XclImpControlHelper::ReadRangeList( ScRangeList& rScRanges, XclImpStream& rStrm )
-{
-    XclTokenArray aXclTokArr;
-    aXclTokArr.ReadSize( rStrm );
-    rStrm.Ignore( 4 );
-    aXclTokArr.ReadArray( rStrm );
-    mrRoot.GetFormulaCompiler().CreateRangeList( rScRanges, EXC_FMLATYPE_CONTROL, aXclTokArr, rStrm );
-}
-
-void XclImpControlHelper::ReadRangeList( ScRangeList& rScRanges, XclImpStream& rStrm, bool bWithBoundSize )
-{
-    if( bWithBoundSize )
-    {
-        sal_uInt16 nSize;
-        rStrm >> nSize;
-        if( nSize > 0 )
-        {
-            rStrm.PushPosition();
-            ReadRangeList( rScRanges, rStrm );
-            rStrm.PopPosition();
-            rStrm.Ignore( nSize );
-        }
-    }
-    else
-    {
-        ReadRangeList( rScRanges, rStrm );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpTbxObjBase::XclImpTbxObjBase( const XclImpRoot& rRoot ) :
-    XclImpTextObj( rRoot ),
-    XclImpControlHelper( rRoot, EXC_CTRL_BINDPOSITION )
-{
-    SetSimpleMacro( false );
-    SetCustomDffObj( true );
-}
-
-namespace {
-
-void lclExtractColor( sal_uInt8& rnColorIdx, const DffPropSet& rDffPropSet, sal_uInt32 nPropId )
-{
-    if( rDffPropSet.IsProperty( nPropId ) )
-    {
-        sal_uInt32 nColor = rDffPropSet.GetPropertyValue( nPropId );
-        if( (nColor & 0xFF000000) == 0x08000000 )
-            rnColorIdx = ::extract_value< sal_uInt8 >( nColor, 0, 8 );
-    }
-}
-
-} // namespace
-
-void XclImpTbxObjBase::SetDffProperties( const DffPropSet& rDffPropSet )
-{
-    maFillData.mnPattern = rDffPropSet.GetPropertyBool( DFF_Prop_fFilled ) ? EXC_PATT_SOLID : EXC_PATT_NONE;
-    lclExtractColor( maFillData.mnBackColorIdx, rDffPropSet, DFF_Prop_fillBackColor );
-    lclExtractColor( maFillData.mnPattColorIdx, rDffPropSet, DFF_Prop_fillColor );
-    ::set_flag( maFillData.mnAuto, EXC_OBJ_LINE_AUTO, false );
-
-    maLineData.mnStyle = rDffPropSet.GetPropertyBool( DFF_Prop_fLine ) ? EXC_OBJ_LINE_SOLID : EXC_OBJ_LINE_NONE;
-    lclExtractColor( maLineData.mnColorIdx, rDffPropSet, DFF_Prop_lineColor );
-    ::set_flag( maLineData.mnAuto, EXC_OBJ_FILL_AUTO, false );
-}
-
-bool XclImpTbxObjBase::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor ) const
-{
-    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName(), GetDocShell() );
-}
-
-void XclImpTbxObjBase::ConvertFont( ScfPropertySet& rPropSet ) const
-{
-    if( maTextData.mxString.is() )
-    {
-        const XclFormatRunVec& rFormatRuns = maTextData.mxString->GetFormats();
-        if( rFormatRuns.empty() )
-            GetFontBuffer().WriteDefaultCtrlFontProperties( rPropSet );
-        else
-            GetFontBuffer().WriteFontProperties( rPropSet, EXC_FONTPROPSET_CONTROL, rFormatRuns.front().mnFontIdx );
-    }
-}
-
-void XclImpTbxObjBase::ConvertLabel( ScfPropertySet& rPropSet ) const
-{
-    if( maTextData.mxString.is() )
-    {
-        String aLabel = maTextData.mxString->GetText();
-        if( maTextData.maData.mnShortcut > 0 )
-        {
-            xub_StrLen nPos = aLabel.Search( static_cast< sal_Unicode >( maTextData.maData.mnShortcut ) );
-            if( nPos != STRING_NOTFOUND )
-                aLabel.Insert( '~', nPos );
-        }
-        rPropSet.SetStringProperty( CREATE_OUSTRING( "Label" ), aLabel );
-    }
-    ConvertFont( rPropSet );
-}
-
-SdrObject* XclImpTbxObjBase::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    SdrObjectPtr xSdrObj( GetObjectManager().GetDffManager().CreateSdrObject( *this, rAnchorRect ) );
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-void XclImpTbxObjBase::DoProcessSdrObj( SdrObject& /*rSdrObj*/ ) const
-{
-    // do not call DoProcessSdrObj() from base class (to skip text processing)
-    ProcessControl( *this );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpButtonObj::XclImpButtonObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot )
-{
-}
-
-void XclImpButtonObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // label and text formatting
-    ConvertLabel( rPropSet );
-
-    /*  Horizontal text alignment. For unknown reason, the property type is a
-        simple sal_Int16 and not a com.sun.star.style.HorizontalAlignment. */
-    sal_Int16 nHorAlign = 1;
-    switch( maTextData.maData.GetHorAlign() )
-    {
-        case EXC_OBJ_HOR_LEFT:      nHorAlign = 0;  break;
-        case EXC_OBJ_HOR_CENTER:    nHorAlign = 1;  break;
-        case EXC_OBJ_HOR_RIGHT:     nHorAlign = 2;  break;
-    }
-    rPropSet.SetProperty( CREATE_OUSTRING( "Align" ), nHorAlign );
-
-    // vertical text alignment
-    namespace csss = ::com::sun::star::style;
-    csss::VerticalAlignment eVerAlign = csss::VerticalAlignment_MIDDLE;
-    switch( maTextData.maData.GetVerAlign() )
-    {
-        case EXC_OBJ_VER_TOP:       eVerAlign = csss::VerticalAlignment_TOP;    break;
-        case EXC_OBJ_VER_CENTER:    eVerAlign = csss::VerticalAlignment_MIDDLE; break;
-        case EXC_OBJ_VER_BOTTOM:    eVerAlign = csss::VerticalAlignment_BOTTOM; break;
-    }
-    rPropSet.SetProperty( CREATE_OUSTRING( "VerticalAlign" ), eVerAlign );
-
-    // always wrap text automatically
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "MultiLine" ), true );
-
-    // default button
-    bool bDefButton = ::get_flag( maTextData.maData.mnButtonFlags, EXC_OBJ_BUTTON_DEFAULT );
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "DefaultButton" ), bDefButton );
-
-    // button type (flags cannot be combined in OOo)
-    namespace cssa = ::com::sun::star::awt;
-    cssa::PushButtonType eButtonType = cssa::PushButtonType_STANDARD;
-    if( ::get_flag( maTextData.maData.mnButtonFlags, EXC_OBJ_BUTTON_CLOSE ) )
-        eButtonType = cssa::PushButtonType_OK;
-    else if( ::get_flag( maTextData.maData.mnButtonFlags, EXC_OBJ_BUTTON_CANCEL ) )
-        eButtonType = cssa::PushButtonType_CANCEL;
-    else if( ::get_flag( maTextData.maData.mnButtonFlags, EXC_OBJ_BUTTON_HELP ) )
-        eButtonType = cssa::PushButtonType_HELP;
-    // property type is short, not enum
-    rPropSet.SetProperty( CREATE_OUSTRING( "PushButtonType" ), sal_Int16( eButtonType ) );
-}
-
-OUString XclImpButtonObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.CommandButton" );
-}
-
-XclTbxEventType XclImpButtonObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_ACTION;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpCheckBoxObj::XclImpCheckBoxObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot ),
-    mnState( EXC_OBJ_CHECKBOX_UNCHECKED ),
-    mnCheckBoxFlags( 0 )
-{
-}
-
-void XclImpCheckBoxObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 10 );
-    rStrm >> maTextData.maData.mnFlags;
-    rStrm.Ignore( 20 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    ReadCellLinkFormula( rStrm, true );
-    rStrm >> maTextData.maData.mnTextLen;
-    maTextData.ReadByteString( rStrm );
-    rStrm >> mnState >> maTextData.maData.mnShortcut >> maTextData.maData.mnShortcutEA >> mnCheckBoxFlags;
-}
-
-void XclImpCheckBoxObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJCBLS:
-            // do not read EXC_ID_OBJCBLSDATA, not written by OOo Excel export
-            rStrm >> mnState;
-            rStrm.Ignore( 4 );
-            rStrm >> maTextData.maData.mnShortcut >> maTextData.maData.mnShortcutEA >> mnCheckBoxFlags;
-        break;
-        case EXC_ID_OBJCBLSFMLA:
-            ReadCellLinkFormula( rStrm, false );
-        break;
-        default:
-            XclImpTbxObjBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-void XclImpCheckBoxObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // label and text formatting
-    ConvertLabel( rPropSet );
-
-    // state
-    bool bSupportsTristate = GetObjType() == EXC_OBJTYPE_CHECKBOX;
-    sal_Int16 nApiState = 0;
-    switch( mnState )
-    {
-        case EXC_OBJ_CHECKBOX_UNCHECKED:    nApiState = 0;                          break;
-        case EXC_OBJ_CHECKBOX_CHECKED:      nApiState = 1;                          break;
-        case EXC_OBJ_CHECKBOX_TRISTATE:     nApiState = bSupportsTristate ? 2 : 1;  break;
-    }
-    if( bSupportsTristate )
-        rPropSet.SetBoolProperty( CREATE_OUSTRING( "TriState" ), nApiState == 2 );
-    rPropSet.SetProperty( CREATE_OUSTRING( "DefaultState" ), nApiState );
-
-    // box style
-    namespace AwtVisualEffect = ::com::sun::star::awt::VisualEffect;
-    sal_Int16 nEffect = ::get_flagvalue( mnCheckBoxFlags, EXC_OBJ_CHECKBOX_FLAT, AwtVisualEffect::FLAT, AwtVisualEffect::LOOK3D );
-    rPropSet.SetProperty( CREATE_OUSTRING( "VisualEffect" ), nEffect );
-
-    // do not wrap text automatically
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "MultiLine" ), false );
-
-    // #i40279# always centered vertically
-    namespace csss = ::com::sun::star::style;
-    rPropSet.SetProperty( CREATE_OUSTRING( "VerticalAlign" ), csss::VerticalAlignment_MIDDLE );
-
-    // background color
-    if( maFillData.IsFilled() )
-    {
-        sal_Int32 nColor = static_cast< sal_Int32 >( GetSolidFillColor( maFillData ).GetColor() );
-        rPropSet.SetProperty( CREATE_OUSTRING( "BackgroundColor" ), nColor );
-    }
-}
-
-OUString XclImpCheckBoxObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.CheckBox" );
-}
-
-XclTbxEventType XclImpCheckBoxObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_ACTION;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpOptionButtonObj::XclImpOptionButtonObj( const XclImpRoot& rRoot ) :
-    XclImpCheckBoxObj( rRoot ),
-    mnNextInGroup( 0 ),
-    mnFirstInGroup( 1 )
-{
-}
-
-void XclImpOptionButtonObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 10 );
-    rStrm >> maTextData.maData.mnFlags;
-    rStrm.Ignore( 32 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    ReadCellLinkFormula( rStrm, true );
-    rStrm >> maTextData.maData.mnTextLen;
-    maTextData.ReadByteString( rStrm );
-    rStrm >> mnState >> maTextData.maData.mnShortcut >> maTextData.maData.mnShortcutEA;
-    rStrm >> mnCheckBoxFlags >> mnNextInGroup >> mnFirstInGroup;
-}
-
-void XclImpOptionButtonObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJRBODATA:
-            rStrm >> mnNextInGroup >> mnFirstInGroup;
-        break;
-        default:
-            XclImpCheckBoxObj::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-void XclImpOptionButtonObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    XclImpCheckBoxObj::DoProcessControl( rPropSet );
-    // TODO: grouping
-    XclImpOptionButtonObj* pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().FindDrawObj( XclObjId( GetScTab(), mnNextInGroup ) ).get() );
-    if ( ( pTbxObj && pTbxObj->mnFirstInGroup ) )
-    {
-        // Group has terminated
-        // traverse each RadioButton in group and 
-        //     a) apply the groupname 
-        //     b) propagate the linked cell from the lead radiobutton
-        //     c) apply the correct Ref value
-        XclImpOptionButtonObj* pLeader = pTbxObj;
- ;
-        sal_Int32 nRefVal = 1;
-        OSL_TRACE( "0x%x start group ", pLeader->GetObjId().mnObjId );
-        do 
-        {
-           
-            Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( pTbxObj->mxShape );
-            if ( xCtrlModel.is() )
-            {
-                ScfPropertySet aProps( xCtrlModel );
-                rtl::OUString sGroupName = rtl::OUString::valueOf( static_cast< sal_Int32 >( pLeader->GetDffShapeId() ) );
-
-                aProps.SetStringProperty( CREATE_OUSTRING( "GroupName" ), sGroupName );
-                aProps.SetStringProperty( CREATE_OUSTRING( "RefValue" ), rtl::OUString::valueOf( nRefVal++ ) );
-                if ( pLeader->HasCellLink() && !pTbxObj->HasCellLink() )
-                {
-                    // propagate cell link info
-                    pTbxObj->mxCellLink.reset( new ScAddress( *pLeader->mxCellLink.get() ) );                
-                    pTbxObj->ApplySheetLinkProps();
-                }
-                pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().FindDrawObj( XclObjId( GetScTab(), pTbxObj->mnNextInGroup ) ).get() );
-            }
-            else
-                pTbxObj = NULL;
-        } while ( pTbxObj && !( pTbxObj->mnFirstInGroup == 1 ) );
-    }
-    else
-    {
-        // not the leader? try and find it
-    }
-}
-
-OUString XclImpOptionButtonObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.RadioButton" );
-}
-
-XclTbxEventType XclImpOptionButtonObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_ACTION;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpLabelObj::XclImpLabelObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot )
-{
-}
-
-void XclImpLabelObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // label and text formatting
-    ConvertLabel( rPropSet );
-
-    // text alignment (always top/left aligned)
-    rPropSet.SetProperty( CREATE_OUSTRING( "Align" ), sal_Int16( 0 ) );
-    namespace csss = ::com::sun::star::style;
-    rPropSet.SetProperty( CREATE_OUSTRING( "VerticalAlign" ), csss::VerticalAlignment_TOP );
-
-    // always wrap text automatically
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "MultiLine" ), true );
-}
-
-OUString XclImpLabelObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.FixedText" );
-}
-
-XclTbxEventType XclImpLabelObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_MOUSE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpGroupBoxObj::XclImpGroupBoxObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot ),
-    mnGroupBoxFlags( 0 )
-{
-}
-
-void XclImpGroupBoxObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 10 );
-    rStrm >> maTextData.maData.mnFlags;
-    rStrm.Ignore( 26 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    rStrm >> maTextData.maData.mnTextLen;
-    maTextData.ReadByteString( rStrm );
-    rStrm >> maTextData.maData.mnShortcut >> maTextData.maData.mnShortcutEA >> mnGroupBoxFlags;
-}
-
-void XclImpGroupBoxObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJGBODATA:
-            rStrm >> maTextData.maData.mnShortcut >> maTextData.maData.mnShortcutEA >> mnGroupBoxFlags;
-        break;
-        default:
-            XclImpTbxObjBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-void XclImpGroupBoxObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // label and text formatting
-    ConvertLabel( rPropSet );
-}
-
-OUString XclImpGroupBoxObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.GroupBox" );
-}
-
-XclTbxEventType XclImpGroupBoxObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_MOUSE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpDialogObj::XclImpDialogObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot )
-{
-}
-
-void XclImpDialogObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // label and text formatting
-    ConvertLabel( rPropSet );
-}
-
-OUString XclImpDialogObj::DoGetServiceName() const
-{
-    // dialog frame faked by a groupbox
-    return CREATE_OUSTRING( "com.sun.star.form.component.GroupBox" );
-}
-
-XclTbxEventType XclImpDialogObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_MOUSE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpEditObj::XclImpEditObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot ),
-    mnContentType( EXC_OBJ_EDIT_TEXT ),
-    mnMultiLine( 0 ),
-    mnScrollBar( 0 ),
-    mnListBoxObjId( 0 )
-{
-}
-
-bool XclImpEditObj::IsNumeric() const
-{
-    return (mnContentType == EXC_OBJ_EDIT_INTEGER) || (mnContentType == EXC_OBJ_EDIT_DOUBLE);
-}
-
-void XclImpEditObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 10 );
-    rStrm >> maTextData.maData.mnFlags;
-    rStrm.Ignore( 14 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    rStrm >> maTextData.maData.mnTextLen;
-    maTextData.ReadByteString( rStrm );
-    rStrm >> mnContentType >> mnMultiLine >> mnScrollBar >> mnListBoxObjId;
-}
-
-void XclImpEditObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJEDODATA:
-            rStrm >> mnContentType >> mnMultiLine >> mnScrollBar >> mnListBoxObjId;
-        break;
-        default:
-            XclImpTbxObjBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-void XclImpEditObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    if( maTextData.mxString.is() )
-    {
-        OUString aText = maTextData.mxString->GetText();
-        if( IsNumeric() )
-        {
-            // TODO: OUString::toDouble() does not handle local decimal separator
-            rPropSet.SetProperty( CREATE_OUSTRING( "DefaultValue" ), aText.toDouble() );
-            rPropSet.SetBoolProperty( CREATE_OUSTRING( "Spin" ), mnScrollBar != 0 );
-        }
-        else
-        {
-            rPropSet.SetProperty( CREATE_OUSTRING( "DefaultText" ), aText );
-            rPropSet.SetBoolProperty( CREATE_OUSTRING( "MultiLine" ), mnMultiLine != 0 );
-            rPropSet.SetBoolProperty( CREATE_OUSTRING( "VScroll" ), mnScrollBar != 0 );
-        }
-    }
-    ConvertFont( rPropSet );
-}
-
-OUString XclImpEditObj::DoGetServiceName() const
-{
-    return IsNumeric() ?
-        CREATE_OUSTRING( "com.sun.star.form.component.NumericField" ) :
-        CREATE_OUSTRING( "com.sun.star.form.component.TextField" );
-}
-
-XclTbxEventType XclImpEditObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_TEXT;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpTbxObjScrollableBase::XclImpTbxObjScrollableBase( const XclImpRoot& rRoot ) :
-    XclImpTbxObjBase( rRoot ),
-    mnValue( 0 ),
-    mnMin( 0 ),
-    mnMax( 100 ),
-    mnStep( 1 ),
-    mnPageStep( 10 ),
-    mnOrient( 0 ),
-    mnThumbWidth( 1 ),
-    mnScrollFlags( 0 )
-{
-}
-
-void XclImpTbxObjScrollableBase::ReadSbs( XclImpStream& rStrm )
-{
-    rStrm.Ignore( 4 );
-    rStrm >> mnValue >> mnMin >> mnMax >> mnStep >> mnPageStep >> mnOrient >> mnThumbWidth >> mnScrollFlags;
-}
-
-void XclImpTbxObjScrollableBase::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJSBS:
-            ReadSbs( rStrm );
-        break;
-        case EXC_ID_OBJSBSFMLA:
-            ReadCellLinkFormula( rStrm, false );
-        break;
-        default:
-            XclImpTbxObjBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpSpinButtonObj::XclImpSpinButtonObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjScrollableBase( rRoot )
-{
-}
-
-void XclImpSpinButtonObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    ReadSbs( rStrm );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    ReadCellLinkFormula( rStrm, true );
-}
-
-void XclImpSpinButtonObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // Calc's "Border" property is not the 3D/flat style effect in Excel (#i34712#)
-    rPropSet.SetProperty( CREATE_OUSTRING( "Border" ), ::com::sun::star::awt::VisualEffect::NONE );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "DefaultSpinValue" ), mnValue );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "SpinValueMin" ), mnMin );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "SpinValueMax" ), mnMax );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "SpinIncrement" ), mnStep );
-
-    // Excel spin buttons always vertical
-    rPropSet.SetProperty( CREATE_OUSTRING( "Orientation" ), ::com::sun::star::awt::ScrollBarOrientation::VERTICAL );
-}
-
-OUString XclImpSpinButtonObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.SpinButton" );
-}
-
-XclTbxEventType XclImpSpinButtonObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_VALUE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpScrollBarObj::XclImpScrollBarObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjScrollableBase( rRoot )
-{
-}
-
-void XclImpScrollBarObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    ReadSbs( rStrm );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    ReadCellLinkFormula( rStrm, true );
-}
-
-void XclImpScrollBarObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // Calc's "Border" property is not the 3D/flat style effect in Excel (#i34712#)
-    rPropSet.SetProperty( CREATE_OUSTRING( "Border" ), ::com::sun::star::awt::VisualEffect::NONE );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "DefaultScrollValue" ), mnValue );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "ScrollValueMin" ), mnMin );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "ScrollValueMax" ), mnMax );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "LineIncrement" ), mnStep );
-    rPropSet.SetProperty< sal_Int32 >( CREATE_OUSTRING( "BlockIncrement" ), mnPageStep );
-    rPropSet.SetProperty( CREATE_OUSTRING( "VisibleSize" ), ::std::min< sal_Int32 >( mnPageStep, 1 ) );
-
-    namespace AwtScrollOrient = ::com::sun::star::awt::ScrollBarOrientation;
-    sal_Int32 nApiOrient = ::get_flagvalue( mnOrient, EXC_OBJ_SCROLLBAR_HOR, AwtScrollOrient::HORIZONTAL, AwtScrollOrient::VERTICAL );
-    rPropSet.SetProperty( CREATE_OUSTRING( "Orientation" ), nApiOrient );
-}
-
-OUString XclImpScrollBarObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.ScrollBar" );
-}
-
-XclTbxEventType XclImpScrollBarObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_VALUE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpTbxObjListBase::XclImpTbxObjListBase( const XclImpRoot& rRoot ) :
-    XclImpTbxObjScrollableBase( rRoot ),
-    mnEntryCount( 0 ),
-    mnSelEntry( 0 ),
-    mnListFlags( 0 ),
-    mnEditObjId( 0 ),
-    mbHasDefFontIdx( false )
-{
-}
-
-void XclImpTbxObjListBase::ReadLbsData( XclImpStream& rStrm )
-{
-    ReadSourceRangeFormula( rStrm, true );
-    rStrm >> mnEntryCount >> mnSelEntry >> mnListFlags >> mnEditObjId;
-}
-
-void XclImpTbxObjListBase::SetBoxFormatting( ScfPropertySet& rPropSet ) const
-{
-    // border style
-    namespace AwtVisualEffect = ::com::sun::star::awt::VisualEffect;
-    sal_Int16 nApiBorder = ::get_flagvalue( mnListFlags, EXC_OBJ_LISTBOX_FLAT, AwtVisualEffect::FLAT, AwtVisualEffect::LOOK3D );
-    rPropSet.SetProperty( CREATE_OUSTRING( "Border" ), nApiBorder );
-
-    // font formatting
-    if( mbHasDefFontIdx )
-        GetFontBuffer().WriteFontProperties( rPropSet, EXC_FONTPROPSET_CONTROL, maTextData.maData.mnDefFontIdx );
-    else
-        GetFontBuffer().WriteDefaultCtrlFontProperties( rPropSet );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpListBoxObj::XclImpListBoxObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjListBase( rRoot )
-{
-}
-
-void XclImpListBoxObj::ReadFullLbsData( XclImpStream& rStrm, sal_Size nRecLeft )
-{
-    sal_Size nRecEnd = rStrm.GetRecPos() + nRecLeft;
-    ReadLbsData( rStrm );
-    DBG_ASSERT( (rStrm.GetRecPos() == nRecEnd) || (rStrm.GetRecPos() + mnEntryCount == nRecEnd),
-        "XclImpListBoxObj::ReadFullLbsData - invalid size of OBJLBSDATA record" );
-    while( rStrm.IsValid() && (rStrm.GetRecPos() < nRecEnd) )
-        maSelection.push_back( rStrm.ReaduInt8() );
-}
-
-void XclImpListBoxObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    ReadSbs( rStrm );
-    rStrm.Ignore( 18 );
-    rStrm >> maTextData.maData.mnDefFontIdx;
-    rStrm.Ignore( 4 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    ReadCellLinkFormula( rStrm, true );
-    ReadFullLbsData( rStrm, rStrm.GetRecLeft() );
-    mbHasDefFontIdx = true;
-}
-
-void XclImpListBoxObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJLBSDATA:
-            ReadFullLbsData( rStrm, nSubRecSize );
-        break;
-        default:
-            XclImpTbxObjListBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-void XclImpListBoxObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // listbox formatting
-    SetBoxFormatting( rPropSet );
-
-    // selection type
-    sal_uInt8 nSelType = ::extract_value< sal_uInt8 >( mnListFlags, 4, 2 );
-    bool bMultiSel = nSelType != EXC_OBJ_LISTBOX_SINGLE;
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "MultiSelection" ), bMultiSel );
-
-    // selection (do not set, if listbox is linked to a cell)
-    if( !HasCellLink() )
-    {
-        ScfInt16Vec aSelVec;
-
-        // multi selection: API expects sequence of list entry indexes
-        if( bMultiSel )
-            for( ScfUInt8Vec::const_iterator aBeg = maSelection.begin(), aIt = aBeg, aEnd = maSelection.end(); aIt != aEnd; ++aIt )
-                if( *aIt != 0 )
-                    aSelVec.push_back( static_cast< sal_Int16 >( aIt - aBeg ) );
-        // single selection: mnSelEntry is one-based, API expects zero-based
-        else if( mnSelEntry > 0 )
-            aSelVec.push_back( static_cast< sal_Int16 >( mnSelEntry - 1 ) );
-
-        if( !aSelVec.empty() )
-        {
-            Sequence< sal_Int16 > aSelSeq( &aSelVec.front(), static_cast< sal_Int32 >( aSelVec.size() ) );
-            rPropSet.SetProperty( CREATE_OUSTRING( "DefaultSelection" ), aSelSeq );
-        }
-    }
-}
-
-OUString XclImpListBoxObj::DoGetServiceName() const
-{
-    return CREATE_OUSTRING( "com.sun.star.form.component.ListBox" );
-}
-
-XclTbxEventType XclImpListBoxObj::DoGetEventType() const
-{
-    return EXC_TBX_EVENT_CHANGE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpDropDownObj::XclImpDropDownObj( const XclImpRoot& rRoot ) :
-    XclImpTbxObjListBase( rRoot ),
-    mnLeft( 0 ),
-    mnTop( 0 ),
-    mnRight( 0 ),
-    mnBottom( 0 ),
-    mnDropDownFlags( 0 ),
-    mnLineCount( 0 ),
-    mnMinWidth( 0 )
-{
-}
-
-sal_uInt16 XclImpDropDownObj::GetDropDownType() const
-{
-    return ::extract_value< sal_uInt8 >( mnDropDownFlags, 0, 2 );
-}
-
-void XclImpDropDownObj::ReadFullLbsData( XclImpStream& rStrm )
-{
-    ReadLbsData( rStrm );
-    rStrm >> mnDropDownFlags >> mnLineCount >> mnMinWidth >> maTextData.maData.mnTextLen;
-    maTextData.ReadByteString( rStrm );
-    // dropdowns of auto-filters have 'simple' style, they don't have a text area
-    if( GetDropDownType() == EXC_OBJ_DROPDOWN_SIMPLE )
-        SetProcessSdrObj( false );
-}
-
-void XclImpDropDownObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 /*nMacroSize*/ )
-{
-    ReadFrameData( rStrm );
-    ReadSbs( rStrm );
-    rStrm.Ignore( 18 );
-    rStrm >> maTextData.maData.mnDefFontIdx;
-    rStrm.Ignore( 14 );
-    rStrm >> mnLeft >> mnTop >> mnRight >> mnBottom;
-    rStrm.Ignore( 4 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, rStrm.ReaduInt16() );   // fist macro size invalid and unused
-    ReadCellLinkFormula( rStrm, true );
-    ReadFullLbsData( rStrm );
-    mbHasDefFontIdx = true;
-}
-
-void XclImpDropDownObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJLBSDATA:
-            ReadFullLbsData( rStrm );
-        break;
-        default:
-            XclImpTbxObjListBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-void XclImpDropDownObj::DoProcessControl( ScfPropertySet& rPropSet ) const
-{
-    // dropdown listbox formatting
-    SetBoxFormatting( rPropSet );
-    // enable dropdown button
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "Dropdown" ), true );
-    // dropdown line count
-    rPropSet.SetProperty( CREATE_OUSTRING( "LineCount" ), mnLineCount );
-
-    if( GetDropDownType() == EXC_OBJ_DROPDOWN_COMBOBOX )
-    {
-        // text of editable combobox
-        if( maTextData.mxString.is() )
-            rPropSet.SetStringProperty( CREATE_OUSTRING( "DefaultText" ), maTextData.mxString->GetText() );
-    }
-    else
-    {
-        // selection (do not set, if dropdown is linked to a cell)
-        if( !HasCellLink() && (mnSelEntry > 0) )
-        {
-            Sequence< sal_Int16 > aSelSeq( 1 );
-            aSelSeq[ 0 ] = mnSelEntry - 1;
-            rPropSet.SetProperty( CREATE_OUSTRING( "DefaultSelection" ), aSelSeq );
-        }
-    }
-}
-
-OUString XclImpDropDownObj::DoGetServiceName() const
-{
-    return (GetDropDownType() == EXC_OBJ_DROPDOWN_COMBOBOX) ?
-        CREATE_OUSTRING( "com.sun.star.form.component.ComboBox" ) :
-        CREATE_OUSTRING( "com.sun.star.form.component.ListBox" );
-}
-
-XclTbxEventType XclImpDropDownObj::DoGetEventType() const
-{
-    return (GetDropDownType() == EXC_OBJ_DROPDOWN_COMBOBOX) ? EXC_TBX_EVENT_TEXT : EXC_TBX_EVENT_CHANGE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpPictureObj::XclImpPictureObj( const XclImpRoot& rRoot ) :
-    XclImpRectObj( rRoot ),
-    XclImpControlHelper( rRoot, EXC_CTRL_BINDCONTENT ),
-    mnStorageId( 0 ),
-    mnCtlsStrmPos( 0 ),
-    mnCtlsStrmSize( 0 ),
-    mbEmbedded( false ),
-    mbLinked( false ),
-    mbSymbol( false ),
-    mbControl( false ),
-    mbUseCtlsStrm( false )
-{
-    SetAreaObj( true );
-    SetSimpleMacro( false );
-    SetCustomDffObj( true );
-}
-
-String XclImpPictureObj::GetOleStorageName() const
-{
-    String aStrgName;
-    if( (mbEmbedded || mbLinked) && !mbControl && (mnStorageId > 0) )
-    {
-        aStrgName = mbEmbedded ? EXC_STORAGE_OLE_EMBEDDED : EXC_STORAGE_OLE_LINKED;
-        static const sal_Char spcHexChars[] = "0123456789ABCDEF";
-        for( sal_uInt8 nIndex = 32; nIndex > 0; nIndex -= 4 )
-            aStrgName.Append( sal_Unicode( spcHexChars[ ::extract_value< sal_uInt8 >( mnStorageId, nIndex - 4, 4 ) ] ) );
-    }
-    return aStrgName;
-}
-
-void XclImpPictureObj::DoReadObj3( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    sal_uInt16 nLinkSize;
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 6 );
-    rStrm >> nLinkSize;
-    rStrm.Ignore( 2 );
-    ReadFlags3( rStrm );
-    ReadMacro3( rStrm, nMacroSize );
-    ReadPictFmla( rStrm, nLinkSize );
-
-    if( (rStrm.GetNextRecId() == EXC_ID3_IMGDATA) && rStrm.StartNextRecord() )
-        maGraphic = XclImpObjectManager::ReadImgData( rStrm );
-}
-
-void XclImpPictureObj::DoReadObj4( XclImpStream& rStrm, sal_uInt16 nMacroSize )
-{
-    sal_uInt16 nLinkSize;
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 6 );
-    rStrm >> nLinkSize;
-    rStrm.Ignore( 2 );
-    ReadFlags3( rStrm );
-    ReadMacro4( rStrm, nMacroSize );
-    ReadPictFmla( rStrm, nLinkSize );
-
-    if( (rStrm.GetNextRecId() == EXC_ID3_IMGDATA) && rStrm.StartNextRecord() )
-        maGraphic = XclImpObjectManager::ReadImgData( rStrm );
-}
-
-void XclImpPictureObj::DoReadObj5( XclImpStream& rStrm, sal_uInt16 nNameLen, sal_uInt16 nMacroSize )
-{
-    sal_uInt16 nLinkSize;
-    ReadFrameData( rStrm );
-    rStrm.Ignore( 6 );
-    rStrm >> nLinkSize;
-    rStrm.Ignore( 2 );
-    ReadFlags3( rStrm );
-    rStrm.Ignore( 4 );
-    ReadName5( rStrm, nNameLen );
-    ReadMacro5( rStrm, nMacroSize );
-    ReadPictFmla( rStrm, nLinkSize );
-
-    if( (rStrm.GetNextRecId() == EXC_ID3_IMGDATA) && rStrm.StartNextRecord() )
-    {
-        // page background is stored as hidden picture with name "__BkgndObj"
-        if( IsHidden() && (GetObjName() == CREATE_STRING( "__BkgndObj" )) )
-            GetPageSettings().ReadImgData( rStrm );
-        else
-            maGraphic = XclImpObjectManager::ReadImgData( rStrm );
-    }
-}
-
-void XclImpPictureObj::DoReadObj8SubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
-{
-    switch( nSubRecId )
-    {
-        case EXC_ID_OBJFLAGS:
-            ReadFlags8( rStrm );
-        break;
-        case EXC_ID_OBJPICTFMLA:
-            ReadPictFmla( rStrm, rStrm.ReaduInt16() );
-        break;
-        default:
-            XclImpDrawObjBase::DoReadObj8SubRec( rStrm, nSubRecId, nSubRecSize );
-    }
-}
-
-SdrObject* XclImpPictureObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const
-{
-    // try to create an OLE object or form control
-    SdrObjectPtr xSdrObj( GetObjectManager().GetDffManager().CreateSdrObject( *this, rAnchorRect ) );
-
-    // no OLE - create a plain picture from IMGDATA record data
-    if( !xSdrObj && (maGraphic.GetType() != GRAPHIC_NONE) )
-    {
-        xSdrObj.reset( new SdrGrafObj( maGraphic, rAnchorRect ) );
-        ConvertRectStyle( *xSdrObj );
-    }
-
-    rProgress.Progress();
-    return xSdrObj.release();
-}
-
-String XclImpPictureObj::GetObjName() const
-{
-    if( IsOcxControl() )
-    {
-        String sName( GetObjectManager().GetOleNameOverride( GetObjId() ) );
-        if ( sName.Len() > 0 )
-            return sName;
-    }
-    return XclImpDrawObjBase::GetObjName();
-}
-
-void XclImpPictureObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
-{
-    if( IsOcxControl() )
-    {
-        // do not call XclImpRectObj::DoProcessSdrObj(), it would trace missing "printable" feature
-        ProcessControl( *this );
-    }
-    else if( mbEmbedded || mbLinked )
-    {
-        // trace missing "printable" feature
-        XclImpRectObj::DoProcessSdrObj( rSdrObj );
-
-        SfxObjectShell* pDocShell = GetDocShell();
-        SdrOle2Obj* pOleSdrObj = dynamic_cast< SdrOle2Obj* >( &rSdrObj );
-        if( pOleSdrObj && pDocShell )
-        {
-            comphelper::EmbeddedObjectContainer& rEmbObjCont = pDocShell->GetEmbeddedObjectContainer();
-            Reference< XEmbeddedObject > xEmbObj = pOleSdrObj->GetObjRef();
-            OUString aOldName( pOleSdrObj->GetPersistName() );
-
-            /*  The object persistence should be already in the storage, but
-                the object still might not be inserted into the container. */
-            if( rEmbObjCont.HasEmbeddedObject( aOldName ) )
-            {
-                if( !rEmbObjCont.HasEmbeddedObject( xEmbObj ) )
-                    // filter code is allowed to call the following method
-                    rEmbObjCont.AddEmbeddedObject( xEmbObj, aOldName );
-            }
-            else
-            {
-                /*  If the object is still not in container it must be inserted
-                    there, the name must be generated in this case. */
-                OUString aNewName;
-                rEmbObjCont.InsertEmbeddedObject( xEmbObj, aNewName );
-                if( aOldName != aNewName )
-                    // #95381# SetPersistName, not SetName
-                    pOleSdrObj->SetPersistName( aNewName );
-            }
-        }
-    }
-}
-
-void XclImpPictureObj::ReadFlags3( XclImpStream& rStrm )
-{
-    sal_uInt16 nFlags;
-    rStrm >> nFlags;
-    mbSymbol = ::get_flag( nFlags, EXC_OBJ_PIC_SYMBOL );
-}
-
-void XclImpPictureObj::ReadFlags8( XclImpStream& rStrm )
-{
-    sal_uInt16 nFlags;
-    rStrm >> nFlags;
-    mbSymbol      = ::get_flag( nFlags, EXC_OBJ_PIC_SYMBOL );
-    mbControl     = ::get_flag( nFlags, EXC_OBJ_PIC_CONTROL );
-    mbUseCtlsStrm = ::get_flag( nFlags, EXC_OBJ_PIC_CTLSSTREAM );
-    DBG_ASSERT( mbControl || !mbUseCtlsStrm, "XclImpPictureObj::ReadFlags8 - CTLS stream for controls only" );
-    SetProcessSdrObj( mbControl || !mbUseCtlsStrm );
-}
-
-void XclImpPictureObj::ReadPictFmla( XclImpStream& rStrm, sal_uInt16 nLinkSize )
-{
-    sal_Size nLinkEnd = rStrm.GetRecPos() + nLinkSize;
-    if( nLinkSize >= 6 )
-    {
-        sal_uInt16 nFmlaSize;
-        rStrm >> nFmlaSize;
-        DBG_ASSERT( nFmlaSize > 0, "XclImpPictureObj::ReadPictFmla - missing link formula" );
-        // BIFF3/BIFF4 do not support storages, nothing to do here
-        if( (nFmlaSize > 0) && (GetBiff() >= EXC_BIFF5) )
-        {
-            rStrm.Ignore( 4 );
-            sal_uInt8 nToken;
-            rStrm >> nToken;
-
-            // different processing for linked vs. embedded OLE objects
-            if( nToken == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ) )
-            {
-                mbLinked = true;
-                switch( GetBiff() )
-                {
-                    case EXC_BIFF5:
-                    {
-                        sal_Int16 nRefIdx;
-                        sal_uInt16 nNameIdx;
-                        rStrm >> nRefIdx;
-                        rStrm.Ignore( 8 );
-                        rStrm >> nNameIdx;
-                        rStrm.Ignore( 12 );
-                        const ExtName* pExtName = GetOldRoot().pExtNameBuff->GetNameByIndex( nRefIdx, nNameIdx );
-                        if( pExtName && pExtName->IsOLE() )
-                            mnStorageId = pExtName->nStorageId;
-                    }
-                    break;
-                    case EXC_BIFF8:
-                    {
-                        sal_uInt16 nXti, nExtName;
-                        rStrm >> nXti >> nExtName;
-                        const XclImpExtName* pExtName = GetLinkManager().GetExternName( nXti, nExtName );
-                        if( pExtName && (pExtName->GetType() == xlExtOLE) )
-                            mnStorageId = pExtName->GetStorageId();
-                    }
-                    break;
-                    default:
-                        DBG_ERROR_BIFF();
-                }
-            }
-            else if( nToken == XclTokenArrayHelper::GetTokenId( EXC_TOKID_TBL, EXC_TOKCLASS_NONE ) )
-            {
-                mbEmbedded = true;
-                DBG_ASSERT( nFmlaSize == 5, "XclImpPictureObj::ReadPictFmla - unexpected formula size" );
-                rStrm.Ignore( nFmlaSize - 1 );      // token ID already read
-                if( nFmlaSize & 1 )
-                    rStrm.Ignore( 1 );              // padding byte
-
-                // a class name may follow inside the picture link
-                if( rStrm.GetRecPos() + 2 <= nLinkEnd )
-                {
-                    sal_uInt16 nLen;
-                    rStrm >> nLen;
-                    if( nLen > 0 )
-                        maClassName = (GetBiff() == EXC_BIFF8) ? rStrm.ReadUniString( nLen ) : rStrm.ReadRawByteString( nLen );
-                }
-            }
-            // else: ignore other formulas, e.g. pictures linked to cell ranges
-        }
-    }
-
-    // seek behind picture link data
-    rStrm.Seek( nLinkEnd );
-
-    // read additional data for embedded OLE objects following the picture link
-    if( IsOcxControl() )
-    {
-        // #i26521# form controls to be ignored
-        if( maClassName.EqualsAscii( "Forms.HTML:Hidden.1" ) )
-        {
-            SetProcessSdrObj( false );
-            return;
-        }
-
-        if( rStrm.GetRecLeft() <= 8 ) return;
-
-        // position and size of control data in 'Ctls' stream
-        mnCtlsStrmPos = static_cast< sal_Size >( rStrm.ReaduInt32() );
-        mnCtlsStrmSize = static_cast< sal_Size >( rStrm.ReaduInt32() );
-
-        if( rStrm.GetRecLeft() <= 8 ) return;
-
-        // additional string (16-bit characters), e.g. for progress bar control
-        sal_uInt32 nAddStrSize;
-        rStrm >> nAddStrSize;
-        DBG_ASSERT( rStrm.GetRecLeft() >= nAddStrSize + 4, "XclImpPictureObj::ReadPictFmla - missing data" );
-        if( rStrm.GetRecLeft() >= nAddStrSize + 4 )
-        {
-            rStrm.Ignore( nAddStrSize );
-            // cell link and source range
-            ReadCellLinkFormula( rStrm, true );
-            ReadSourceRangeFormula( rStrm, true );
-        }
-    }
-    else if( mbEmbedded && (rStrm.GetRecLeft() >= 4) )
-    {
-        rStrm >> mnStorageId;
-    }
-}
-
-// DFF stream conversion ======================================================
-
-//UNUSED2009-05 void XclImpSolverContainer::ReadSolverContainer( SvStream& rDffStrm )
-//UNUSED2009-05 {
-//UNUSED2009-05     rDffStrm >> *this;
-//UNUSED2009-05 }
-
-void XclImpSolverContainer::InsertSdrObjectInfo( SdrObject& rSdrObj, sal_uInt32 nDffShapeId, sal_uInt32 nDffFlags )
-{
-    if( nDffShapeId > 0 )
-    {
-        maSdrInfoMap[ nDffShapeId ].Set( &rSdrObj, nDffFlags );
-        maSdrObjMap[ &rSdrObj ] = nDffShapeId;
-    }
-}
-
-void XclImpSolverContainer::RemoveSdrObjectInfo( SdrObject& rSdrObj )
-{
-    // remove info of passed object from the maps
-    XclImpSdrObjMap::iterator aIt = maSdrObjMap.find( &rSdrObj );
-    if( aIt != maSdrObjMap.end() )
-    {
-        maSdrInfoMap.erase( aIt->second );
-        maSdrObjMap.erase( aIt );
-    }
-
-    // remove info of all child objects of a group object
-    if( SdrObjGroup* pGroupObj = dynamic_cast< SdrObjGroup* >( &rSdrObj ) )
-    {
-        if( SdrObjList* pSubList = pGroupObj->GetSubList() )
-        {
-            // iterate flat over the list because this function already works recursively
-            SdrObjListIter aObjIt( *pSubList, IM_FLAT );
-            for( SdrObject* pChildObj = aObjIt.Next(); pChildObj; pChildObj = aObjIt.Next() )
-                RemoveSdrObjectInfo( *pChildObj );
-        }
-    }
-}
-
-void XclImpSolverContainer::UpdateConnectorRules()
-{
-    for( SvxMSDffConnectorRule* pRule = GetFirstRule(); pRule; pRule = GetNextRule() )
-    {
-        UpdateConnection( pRule->nShapeA, pRule->pAObj, &pRule->nSpFlagsA );
-        UpdateConnection( pRule->nShapeB, pRule->pBObj, &pRule->nSpFlagsB );
-        UpdateConnection( pRule->nShapeC, pRule->pCObj );
-    }
-}
-
-void XclImpSolverContainer::RemoveConnectorRules()
-{
-    // base class from SVX uses plain untyped tools/List
-    for( SvxMSDffConnectorRule* pRule = GetFirstRule(); pRule; pRule = GetNextRule() )
-        delete pRule;
-    aCList.Clear();
-
-    maSdrInfoMap.clear();
-    maSdrObjMap.clear();
-}
-
-SvxMSDffConnectorRule* XclImpSolverContainer::GetFirstRule()
-{
-    return static_cast< SvxMSDffConnectorRule* >( aCList.First() );
-}
-
-SvxMSDffConnectorRule* XclImpSolverContainer::GetNextRule()
-{
-    return static_cast< SvxMSDffConnectorRule* >( aCList.Next() );
-}
-
-void XclImpSolverContainer::UpdateConnection( sal_uInt32 nDffShapeId, SdrObject*& rpSdrObj, sal_uInt32* pnDffFlags )
-{
-    XclImpSdrInfoMap::const_iterator aIt = maSdrInfoMap.find( nDffShapeId );
-    if( aIt != maSdrInfoMap.end() )
-    {
-        rpSdrObj = aIt->second.mpSdrObj;
-        if( pnDffFlags )
-            *pnDffFlags = aIt->second.mnDffFlags;
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpSimpleDffManager::XclImpSimpleDffManager( const XclImpRoot& rRoot, SvStream& rDffStrm ) :
-    SvxMSDffManager( rDffStrm, rRoot.GetBasePath(), 0, 0, rRoot.GetDoc().GetDrawLayer(), 1440, COL_DEFAULT, 24, 0, &rRoot.GetTracer().GetBaseTracer() ),
-    XclImpRoot( rRoot )
-{
-    SetSvxMSDffSettings( SVXMSDFF_SETTINGS_CROP_BITMAPS | SVXMSDFF_SETTINGS_IMPORT_EXCEL );
-}
-
-XclImpSimpleDffManager::~XclImpSimpleDffManager()
-{
-}
-
-FASTBOOL XclImpSimpleDffManager::GetColorFromPalette( USHORT nIndex, Color& rColor ) const
-{
-    ColorData nColor = GetPalette().GetColorData( static_cast< sal_uInt16 >( nIndex ) );
-
-    if( nColor == COL_AUTO )
-        return FALSE;
-
-    rColor.SetColor( nColor );
-    return TRUE;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpDffManager::XclImpDffManager(
-        const XclImpRoot& rRoot, XclImpObjectManager& rObjManager, SvStream& rDffStrm ) :
-    XclImpSimpleDffManager( rRoot, rDffStrm ),
-    SvxMSConvertOCXControls( rRoot.GetDocShell(), 0 ),
-    mrObjManager( rObjManager ),
-    mnOleImpFlags( 0 ),
-    mnLastCtrlIndex( -1 ),
-    mnCurrFormScTab( -1 )
-{
-    if( SvtFilterOptions* pFilterOpt = SvtFilterOptions::Get() )
-    {
-        if( pFilterOpt->IsMathType2Math() )
-            mnOleImpFlags |= OLE_MATHTYPE_2_STARMATH;
-        if( pFilterOpt->IsWinWord2Writer() )
-            mnOleImpFlags |= OLE_WINWORD_2_STARWRITER;
-        if( pFilterOpt->IsPowerPoint2Impress() )
-            mnOleImpFlags |= OLE_POWERPOINT_2_STARIMPRESS;
-    }
-
-    // try to open the 'Ctls' storage stream containing OCX control properties
-    mxCtlsStrm = OpenStream( EXC_STREAM_CTLS );
-
-    // default text margin (convert EMU to drawing layer units)
-    mnDefTextMargin = EXC_OBJ_TEXT_MARGIN;
-    ScaleEmu( mnDefTextMargin );
-}
-
-XclImpDffManager::~XclImpDffManager()
-{
-}
-
-String XclImpObjectManager::GetOleNameOverride( const XclObjId& nObjId )
-{
-    String sOleName; 
-    String sCodeName = GetExtDocOptions().GetCodeName( nObjId.mnScTab );
-    
-    CodeNameToCntrlObjIdInfo::iterator it = maOleCtrlNameOverride.find( sCodeName );
-    if ( it != maOleCtrlNameOverride.end() )
-    {
-        CntrlObjIdToName::iterator it_id = it->second.find( nObjId.mnObjId );
-        if ( it_id != it->second.end() )
-        {
-            sOleName = it_id->second;
-        }
-    }
-    return sOleName;
-}
-
-void XclImpDffManager::StartProgressBar( sal_Size nProgressSize )
-{
-    mxProgress.reset( new ScfProgressBar( GetDocShell(), STR_PROGRESS_CALCULATING ) );
-    mxProgress->AddSegment( nProgressSize );
-    mxProgress->Activate();
-}
-
-void XclImpDffManager::ProcessObject( SdrObjList* pObjList, const XclImpDrawObjBase& rDrawObj )
-{
-    Rectangle aAnchorRect = rDrawObj.GetAnchorRect();
-    if( rDrawObj.IsProcessSdrObj() && rDrawObj.IsValidSize( aAnchorRect ) )
-    {
-        // CreateSdrObject() recursively creates embedded child objects
-        SdrObjectPtr xSdrObj( rDrawObj.CreateSdrObject( aAnchorRect, *mxProgress, false ) );
-        if( xSdrObj.is() )
-            rDrawObj.ProcessSdrObject( *xSdrObj );
-        // call InsertSdrObject() also, if SdrObject is missing
-        InsertSdrObject( pObjList, rDrawObj, xSdrObj.release() );
-        UpdateUsedArea( rDrawObj );
-    }
-}
-
-void XclImpDffManager::ProcessDrawingGroup( SvStream& rDffStrm )
-{
-    rDffStrm.Seek( STREAM_SEEK_TO_BEGIN );
-    DffRecordHeader aHeader;
-    rDffStrm >> aHeader;
-    if( aHeader.nRecType == DFF_msofbtDggContainer )
-        ProcessDggContainer( rDffStrm, aHeader );
-    else
-    {
-        DBG_ERRORFILE( "XclImpDffManager::ProcessDrawingGroup - unexpected record" );
-    }
-}
-
-void XclImpDffManager::ProcessDrawing( SvStream& rDffStrm, sal_Size nStrmPos )
-{
-    rDffStrm.Seek( nStrmPos );
-    DffRecordHeader aHeader;
-    rDffStrm >> aHeader;
-    if( aHeader.nRecType == DFF_msofbtDgContainer )
-        ProcessDgContainer( rDffStrm, aHeader );
-    else
-    {
-        DBG_ERRORFILE( "XclImpDffManager::ProcessDrawing - unexpected record" );
-    }
-}
-
-SdrObject* XclImpDffManager::CreateSdrObject( const XclImpTbxObjBase& rTbxObj, const Rectangle& rAnchorRect )
-{
-    SdrObjectPtr xSdrObj;
-
-    OUString aServiceName = rTbxObj.GetServiceName();
-    if( aServiceName.getLength() > 0 ) try
-    {
-        // create the form control from scratch
-        Reference< XFormComponent > xFormComp( ScfApiHelper::CreateInstance( GetDocShell(), aServiceName ), UNO_QUERY_THROW );
-        // set current controls form, needed in virtual function InsertControl()
-        SetCurrentForm( rTbxObj.GetScTab() );
-        // try to insert the control into the form
-        ::com::sun::star::awt::Size aDummySize;
-        Reference< XShape > xShape;
-        if( mxCurrForm.is() && InsertControl( xFormComp, aDummySize, &xShape, TRUE ) )
-        {
-            xSdrObj.reset( rTbxObj.CreateSdrObjectFromShape( xShape, rAnchorRect ) );
-            // try to attach a macro to the control
-            ScriptEventDescriptor aDescriptor;
-            if( (mnLastCtrlIndex >= 0) && rTbxObj.FillMacroDescriptor( aDescriptor ) )
-            {
-                Reference< XEventAttacherManager > xEventMgr( mxCurrForm, UNO_QUERY_THROW );
-                xEventMgr->registerScriptEvent( mnLastCtrlIndex, aDescriptor );
-            }
-        }
-    }
-    catch( Exception& )
-    {
-    }
-
-    return xSdrObj.release();
-}
-
-SdrObject* XclImpDffManager::CreateSdrObject( const XclImpPictureObj& rPicObj, const Rectangle& rAnchorRect )
-{
-    SdrObjectPtr xSdrObj;
-
-    if( rPicObj.IsOcxControl() )
-    {
-        if( mxCtlsStrm.Is() ) try
-        {
-            /*  set current controls form, needed in virtual function InsertControl()
-                called from ReadOCXExcelKludgeStream() */
-            SetCurrentForm( rPicObj.GetScTab() );
-            // seek to stream position of the extra data for this control
-            mxCtlsStrm->Seek( rPicObj.GetCtlsStreamPos() );
-            // read from mxCtlsStrm into xShape, insert the control model into the form
-            Reference< XShape > xShape;
-            if( mxCurrForm.is() && ReadOCXExcelKludgeStream( mxCtlsStrm, &xShape, TRUE ) )
-                xSdrObj.reset( rPicObj.CreateSdrObjectFromShape( xShape, rAnchorRect ) );
-        }
-        catch( Exception& )
-        {
-        }
-    }
-    else
-    {
-        SfxObjectShell* pDocShell = GetDocShell();
-        SotStorageRef xSrcStrg = GetRootStorage();
-        String aStrgName = rPicObj.GetOleStorageName();
-        if( pDocShell && xSrcStrg.Is() && (aStrgName.Len() > 0) )
-        {
-            // first try to resolve graphic from DFF storage
-            Graphic aGraphic;
-            Rectangle aVisArea;
-            if( !GetBLIP( GetPropertyValue( DFF_Prop_pib ), aGraphic, &aVisArea ) )
-            {
-                // if not found, use graphic from object (imported from IMGDATA record)
-                aGraphic = rPicObj.GetGraphic();
-                aVisArea = rPicObj.GetVisArea();
-            }
-            if( aGraphic.GetType() != GRAPHIC_NONE )
-            {
-                ErrCode nError = ERRCODE_NONE;
-                namespace cssea = ::com::sun::star::embed::Aspects;
-                sal_Int64 nAspects = rPicObj.IsSymbol() ? cssea::MSOLE_ICON : cssea::MSOLE_CONTENT;
-                xSdrObj.reset( CreateSdrOLEFromStorage(
-                    aStrgName, xSrcStrg, pDocShell->GetStorage(), aGraphic,
-                    rAnchorRect, aVisArea, 0, nError, mnOleImpFlags, nAspects ) );
-            }
-        }
-    }
-
-    return xSdrObj.release();
-}
-
-ScRange XclImpDffManager::GetUsedArea( SCTAB nScTab ) const
-{
-    ScRange aScUsedArea( ScAddress::INITIALIZE_INVALID );
-    ScRangeMap::const_iterator aIt = maUsedAreaMap.find( nScTab );
-    if( aIt != maUsedAreaMap.end() )
-        aScUsedArea = aIt->second;
-    return aScUsedArea;
-}
-
-// virtual functions ----------------------------------------------------------
-
-void XclImpDffManager::ProcessClientAnchor2( SvStream& rDffStrm,
-        DffRecordHeader& rHeader, void* /*pClientData*/, DffObjData& rObjData )
-{
-    // find the OBJ record data related to the processed shape
-    if( XclImpDrawObjBase* pDrawObj = mrObjManager.FindDrawObj( rObjData.rSpHd ).get() )
-    {
-        DBG_ASSERT( rHeader.nRecType == DFF_msofbtClientAnchor, "XclImpDffManager::ProcessClientAnchor2 - no client anchor record" );
-        XclObjAnchor aAnchor( pDrawObj->GetScTab() );
-        rHeader.SeekToContent( rDffStrm );
-        rDffStrm.SeekRel( 2 );  // flags
-        rDffStrm >> aAnchor;    // anchor format equal to BIFF5 OBJ records
-        pDrawObj->SetAnchor( aAnchor );
-        rObjData.aChildAnchor = pDrawObj->GetAnchorRect();
-        rObjData.bChildAnchor = sal_True;
-    }
-}
-
-SdrObject* XclImpDffManager::ProcessObj( SvStream& rDffStrm,
-        DffObjData& rDffObjData, void* pClientData, Rectangle& /*rTextRect*/, SdrObject* pOldSdrObj )
-{
-    /*  pOldSdrObj passes a generated SdrObject. This function owns this object
-        and can modify it. The function has either to return it back to caller
-        or to delete it by itself. */
-    SdrObjectPtr xSdrObj( pOldSdrObj );
-
-    // find the OBJ record data related to the processed shape
-    XclImpDrawObjRef xDrawObj = mrObjManager.FindDrawObj( rDffObjData.rSpHd );
-    const Rectangle& rAnchorRect = rDffObjData.aChildAnchor;
-
-    // #102378# Do not process the global page group shape (flag SP_FPATRIARCH)
-    bool bGlobalPageGroup = ::get_flag< sal_uInt32 >( rDffObjData.nSpFlags, SP_FPATRIARCH );
-    if( !xDrawObj || !xDrawObj->IsProcessSdrObj() || bGlobalPageGroup )
-        return 0;   // simply return, xSdrObj will be destroyed
-
-    /*  Pass pointer to top-level object back to caller. If the processed
-        object is embedded in a group, the pointer is already set to the
-        top-level parent object. */
-    XclImpDrawObjBase** ppTopLevelObj = reinterpret_cast< XclImpDrawObjBase** >( pClientData );
-    bool bIsTopLevel = !ppTopLevelObj || !*ppTopLevelObj;
-    if( ppTopLevelObj && bIsTopLevel )
-        *ppTopLevelObj = xDrawObj.get();
-
-    // #119010# connectors don't have to be area objects
-    if( dynamic_cast< SdrEdgeObj* >( xSdrObj.get() ) )
-        xDrawObj->SetAreaObj( false );
-
-    /*  Check for valid size for all objects. Needed to ignore lots of invisible
-        phantom objects from deleted rows or columns (for performance reasons).
-        #i30816# Include objects embedded in groups.
-        #i58780# Ignore group shapes, size is not initialized. */
-    bool bEmbeddedGroup = !bIsTopLevel && dynamic_cast< SdrObjGroup* >( xSdrObj.get() );
-    if( !bEmbeddedGroup && !xDrawObj->IsValidSize( rAnchorRect ) )
-        return 0;   // simply return, xSdrObj will be destroyed
-
-    // set shape information from DFF stream
-    String aObjName = GetPropertyString( DFF_Prop_wzName, rDffStrm );
-    String aHyperlink = ReadHlinkProperty( rDffStrm );
-    bool bVisible = !GetPropertyBool( DFF_Prop_fHidden );
-    bool bAutoMargin = GetPropertyBool( DFF_Prop_AutoTextMargin );
-    xDrawObj->SetDffData( rDffObjData, aObjName, aHyperlink, bVisible, bAutoMargin );
-
-    /*  Connect textbox data (string, alignment, text orientation) to object.
-        #98132# don't ask for a text-ID, DFF export doesn't set one. */
-    if( XclImpTextObj* pTextObj = dynamic_cast< XclImpTextObj* >( xDrawObj.get() ) )
-        if( const XclImpObjTextData* pTextData = mrObjManager.FindTextData( rDffObjData.rSpHd ) )
-            pTextObj->SetTextData( *pTextData );
-
-    // copy line and fill formatting of TBX form controls from DFF properties
-    if( XclImpTbxObjBase* pTbxObj = dynamic_cast< XclImpTbxObjBase* >( xDrawObj.get() ) )
-        pTbxObj->SetDffProperties( *this );
-
-    // try to create a custom SdrObject that overwrites the passed object
-    SdrObjectPtr xNewSdrObj( xDrawObj->CreateSdrObject( rAnchorRect, *mxProgress, true ) );
-    if( xNewSdrObj.is() )
-        xSdrObj.reset( xNewSdrObj.release() );
-
-    // process the SdrObject
-    if( xSdrObj.is() )
-    {
-        // filled without color -> set system window color
-        if( GetPropertyBool( DFF_Prop_fFilled ) && !IsProperty( DFF_Prop_fillColor ) )
-            xSdrObj->SetMergedItem( XFillColorItem( EMPTY_STRING, GetPalette().GetColor( EXC_COLOR_WINDOWBACK ) ) );
-
-        // additional processing on the SdrObject
-        xDrawObj->ProcessSdrObject( *xSdrObj );
-
-        // add the area used by this object to the internal map of used areas
-        UpdateUsedArea( *xDrawObj );
-
-        /*  If the SdrObject will not be inserted into the draw page, delete it
-            here. Happens e.g. for notes: The ProcessSdrObject() call above has
-            inserted the note into the document, and the SdrObject is not
-            needed anymore. */
-        if( !xDrawObj->IsInsertSdrObj() )
-            xSdrObj.reset();
-    }
-
-    /*  Store the relation between shape ID and SdrObject for connectors. Must
-        be done here (and not in InsertSdrObject() function), otherwise all
-        SdrObjects embedded in groups would be lost. */
-    if( xSdrObj.is() )
-        maSolverCont.InsertSdrObjectInfo( *xSdrObj, xDrawObj->GetDffShapeId(), xDrawObj->GetDffFlags() );
-
-    return xSdrObj.release();
-}
-
-ULONG XclImpDffManager::Calc_nBLIPPos( ULONG /*nOrgVal*/, ULONG nStreamPos ) const
-{
-    return nStreamPos + 4;
-}
-
-sal_Bool XclImpDffManager::InsertControl( const Reference< XFormComponent >& rxFormComp,
-        const ::com::sun::star::awt::Size& /*rSize*/, Reference< XShape >* pxShape,
-        BOOL /*bFloatingCtrl*/ )
-{
-    if( GetDocShell() ) try
-    {
-        Reference< XIndexContainer > xFormIC( mxCurrForm, UNO_QUERY_THROW );
-        Reference< XControlModel > xCtrlModel( rxFormComp, UNO_QUERY_THROW );
-
-        // create the control shape
-        Reference< XShape > xShape( ScfApiHelper::CreateInstance( GetDocShell(), CREATE_OUSTRING( "com.sun.star.drawing.ControlShape" ) ), UNO_QUERY_THROW );
-        Reference< XControlShape > xCtrlShape( xShape, UNO_QUERY_THROW );
-
-        // insert the new control into the form
-        sal_Int32 nNewIndex = xFormIC->getCount();
-        xFormIC->insertByIndex( nNewIndex, Any( rxFormComp ) );
-        // on success: store new index of the control for later use (macro events)
-        mnLastCtrlIndex = nNewIndex;
-
-        // set control model at control shape and pass back shape to caller
-        xCtrlShape->setControl( xCtrlModel );
-        if( pxShape ) *pxShape = xShape;
-        return sal_True;
-    }
-    catch( Exception& )
-    {
-        DBG_ERRORFILE( "XclImpDffManager::InsertControl - cannot create form control" );
-    }
-
-    return sal_False;
-}
-
-// private --------------------------------------------------------------------
-
-String XclImpDffManager::ReadHlinkProperty( SvStream& rDffStrm ) const
-{
-    /*  Reads hyperlink data from a complex DFF property. Contents of this
-        property are equal to the HLINK record, import of this record is
-        implemented in class XclImpHyperlink. This function has to create an
-        instance of the XclImpStream class to be able to reuse the
-        functionality of XclImpHyperlink. */
-    String aString;
-    sal_uInt32 nBufferSize = GetPropertyValue( DFF_Prop_pihlShape );
-    if( (0 < nBufferSize) && (nBufferSize <= 0xFFFF) && SeekToContent( DFF_Prop_pihlShape, rDffStrm ) )
-    {
-        // create a faked BIFF record that can be read by XclImpStream class
-        SvMemoryStream aMemStream;
-        aMemStream << sal_uInt16( 0 ) << static_cast< sal_uInt16 >( nBufferSize );
-
-        // copy from DFF stream to memory stream
-        ::std::vector< sal_uInt8 > aBuffer( nBufferSize );
-        sal_uInt8* pnData = &aBuffer.front();
-        if( rDffStrm.Read( pnData, nBufferSize ) == nBufferSize )
-        {
-            aMemStream.Write( pnData, nBufferSize );
-
-            // create BIFF import stream to be able to use XclImpHyperlink class
-            XclImpStream aXclStrm( aMemStream, GetRoot() );
-            if( aXclStrm.StartNextRecord() )
-                aString = XclImpHyperlink::ReadEmbeddedData( aXclStrm );
-        }
-    }
-    return aString;
-}
-
-void XclImpDffManager::ProcessDggContainer( SvStream& rDffStrm, const DffRecordHeader& rDggHeader )
-{
-    // seek to end of drawing group container
-    rDggHeader.SeekToEndOfRecord( rDffStrm );
-}
-
-void XclImpDffManager::ProcessDgContainer( SvStream& rDffStrm, const DffRecordHeader& rDgHeader )
-{
-    sal_Size nEndPos = rDgHeader.GetRecEndFilePos();
-    while( rDffStrm.Tell() < nEndPos )
-    {
-        DffRecordHeader aHeader;
-        rDffStrm >> aHeader;
-        switch( aHeader.nRecType )
-        {
-            case DFF_msofbtSolverContainer:
-                ProcessSolverContainer( rDffStrm, aHeader );
-            break;
-            case DFF_msofbtSpgrContainer:
-                ProcessShGrContainer( rDffStrm, aHeader );
-            break;
-            default:
-                aHeader.SeekToEndOfRecord( rDffStrm );
-        }
-    }
-    // seek to end of drawing page container
-    rDgHeader.SeekToEndOfRecord( rDffStrm );
-
-    // #i12638# #i37900# connector rules
-    maSolverCont.UpdateConnectorRules();
-    SolveSolver( maSolverCont );
-    maSolverCont.RemoveConnectorRules();
-}
-
-void XclImpDffManager::ProcessShGrContainer( SvStream& rDffStrm, const DffRecordHeader& rShGrHeader )
-{
-    sal_Size nEndPos = rShGrHeader.GetRecEndFilePos();
-    while( rDffStrm.Tell() < nEndPos )
-    {
-        DffRecordHeader aHeader;
-        rDffStrm >> aHeader;
-        switch( aHeader.nRecType )
-        {
-            case DFF_msofbtSpgrContainer:
-            case DFF_msofbtSpContainer:
-                ProcessShContainer( rDffStrm, aHeader );
-            break;
-            default:
-                aHeader.SeekToEndOfRecord( rDffStrm );
-        }
-    }
-    // seek to end of shape group container
-    rShGrHeader.SeekToEndOfRecord( rDffStrm );
-}
-
-void XclImpDffManager::ProcessSolverContainer( SvStream& rDffStrm, const DffRecordHeader& rSolverHeader )
-{
-    // solver container wants to read the solver container header again
-    rSolverHeader.SeekToBegOfRecord( rDffStrm );
-    // read the entire solver container
-    rDffStrm >> maSolverCont;
-    // seek to end of solver container
-    rSolverHeader.SeekToEndOfRecord( rDffStrm );
-}
-
-void XclImpDffManager::ProcessShContainer( SvStream& rDffStrm, const DffRecordHeader& rShHeader )
-{
-    rShHeader.SeekToBegOfRecord( rDffStrm );
-    Rectangle aDummy;
-    const XclImpDrawObjBase* pDrawObj = 0;
-    /*  The call to ImportObj() creates and returns a new SdrObject for the
-        processed shape. We take ownership of the returned object here. If the
-        shape is a group object, all embedded objects are created recursively,
-        and the returned group object contains them all. ImportObj() calls the
-        virtual functions ProcessClientAnchor2() and ProcessObj() and writes
-        the pointer to the related draw object data (OBJ record) into pDrawObj. */
-    SdrObjectPtr xSdrObj( ImportObj( rDffStrm, &pDrawObj, aDummy, aDummy, 0, 0 ) );
-    if( pDrawObj && xSdrObj.is() )
-        InsertSdrObject( GetSdrPage( pDrawObj->GetScTab() ), *pDrawObj, xSdrObj.release() );
-    rShHeader.SeekToEndOfRecord( rDffStrm );
-}
-
-void XclImpDffManager::InsertSdrObject( SdrObjList* pObjList, const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj )
-{
-    /*  Take ownership of the passed object. If insertion fails (e.g. rDrawObj
-        states to skip insertion, or missing draw page), the object is
-        automatically deleted. */
-    SdrObjectPtr xSdrObj( pSdrObj );
-    if( pObjList && xSdrObj.is() && rDrawObj.IsInsertSdrObj() )
-        pObjList->NbcInsertObject( xSdrObj.release() );
-    // SdrObject still here? Insertion failed, remove data from shape ID map.
-    if( xSdrObj.is() )
-        maSolverCont.RemoveSdrObjectInfo( *xSdrObj );
-}
-
-void XclImpDffManager::SetCurrentForm( SCTAB nScTab )
-{
-    if( nScTab != mnCurrFormScTab )
-    {
-        mxCurrForm.clear();
-        mnCurrFormScTab = nScTab;
-
-        SdrPage* pSdrPage = GetSdrPage( nScTab );
-        if( GetDocShell() && pSdrPage ) try
-        {
-            Reference< XFormsSupplier > xFormsSupplier( pSdrPage->getUnoPage(), UNO_QUERY_THROW );
-            Reference< XNameContainer > xFormsNC = xFormsSupplier->getForms();
-            if( xFormsNC.is() )
-            {
-                // find or create the Standard form used to insert the imported controls
-                OUString aFormName = CREATE_OUSTRING( "Standard" );
-                if( xFormsNC->hasByName( aFormName ) )
-                {
-                    xFormsNC->getByName( aFormName ) >>= mxCurrForm;
-                }
-                else
-                {
-                    mxCurrForm.set( ScfApiHelper::CreateInstance( GetDocShell(), CREATE_OUSTRING( "com.sun.star.form.component.Form" ) ), UNO_QUERY_THROW );
-                    xFormsNC->insertByName( aFormName, Any( mxCurrForm ) );
-                }
-            }
-        }
-        catch( Exception& )
-        {
-        }
-    }
-}
-
-void XclImpDffManager::UpdateUsedArea( const XclImpDrawObjBase& rDrawObj )
-{
-    ScRange aScObjArea = rDrawObj.GetUsedArea();
-    if( aScObjArea.IsValid() )
-    {
-        ScRange* pScTabArea = 0;
-        ScRangeMap::iterator aIt = maUsedAreaMap.find( rDrawObj.GetScTab() );
-        if( aIt == maUsedAreaMap.end() )
-        {
-            pScTabArea = &maUsedAreaMap[ rDrawObj.GetScTab() ];
-            pScTabArea->SetInvalid();
-        }
-        else
-            pScTabArea = &aIt->second;
-
-        if( pScTabArea )
-            pScTabArea->ExtendTo( aScObjArea );
-    }
-}
-
-// The object manager =========================================================
-
-XclImpObjectManager::XclImpObjectManager( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-    maDefObjNames[ EXC_OBJTYPE_GROUP ]          = CREATE_STRING( "Group" );
-    maDefObjNames[ EXC_OBJTYPE_LINE ]           = ScGlobal::GetRscString( STR_SHAPE_LINE );
-    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = ScGlobal::GetRscString( STR_SHAPE_RECTANGLE );
-    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = ScGlobal::GetRscString( STR_SHAPE_OVAL );
-    maDefObjNames[ EXC_OBJTYPE_ARC ]            = CREATE_STRING( "Arc" );
-    maDefObjNames[ EXC_OBJTYPE_CHART ]          = CREATE_STRING( "Chart" );
-    maDefObjNames[ EXC_OBJTYPE_TEXT ]           = CREATE_STRING( "Text" );
-    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         =  ScGlobal::GetRscString( STR_FORM_BUTTON );
-    maDefObjNames[ EXC_OBJTYPE_PICTURE ]        = CREATE_STRING( "Picture" );
-    maDefObjNames[ EXC_OBJTYPE_POLYGON ]        = CREATE_STRING( "Freeform" );
-    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = ScGlobal::GetRscString( STR_FORM_CHECKBOX ); 
-    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = ScGlobal::GetRscString( STR_FORM_OPTIONBUTTON );
-    maDefObjNames[ EXC_OBJTYPE_EDIT ]           = CREATE_STRING( "Edit Box" );
-    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = ScGlobal::GetRscString( STR_FORM_LABEL );
-    maDefObjNames[ EXC_OBJTYPE_DIALOG ]         = CREATE_STRING( "Dialog Frame" );
-    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = ScGlobal::GetRscString( STR_FORM_SPINNER );
-    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = ScGlobal::GetRscString( STR_FORM_SCROLLBAR );
-    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = ScGlobal::GetRscString( STR_FORM_LISTBOX );
-    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = ScGlobal::GetRscString( STR_FORM_GROUPBOX );
-    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = ScGlobal::GetRscString( STR_FORM_DROPDOWN );
-    maDefObjNames[ EXC_OBJTYPE_NOTE ]           = CREATE_STRING( "Comment" );
-    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = ScGlobal::GetRscString( STR_SHAPE_AUTOSHAPE );
-}
-
-XclImpObjectManager::~XclImpObjectManager()
-{
-}
-
-// *** Read Excel records *** -------------------------------------------------
-
-Graphic XclImpObjectManager::ReadImgData( XclImpStream& rStrm ) // static helper
-{
-    Graphic aGraphic;
-    sal_uInt16 nFormat, nEnv;
-    sal_uInt32 nDataSize;
-    rStrm >> nFormat >> nEnv >> nDataSize;
-    if( nDataSize <= rStrm.GetRecLeft() )
-    {
-        switch( nFormat )
-        {
-            case EXC_IMGDATA_WMF:   ReadWmf( aGraphic, rStrm ); break;
-            case EXC_IMGDATA_BMP:   ReadBmp( aGraphic, rStrm ); break;
-            default:    DBG_ERRORFILE( "XclImpObjectManager::ReadImgData - unknown image format" );
-        }
-    }
-    return aGraphic;
-}
-
-void XclImpObjectManager::ReadObj( XclImpStream& rStrm )
-{
-    XclImpDrawObjRef xDrawObj;
-
-    /*  #i61786# In BIFF8 streams, OBJ records may occur without MSODRAWING
-        records. In this case, the OBJ records are in BIFF5 format. Do a sanity
-        check here that there is no DFF data loaded before. */
-    DBG_ASSERT( maDffStrm.Tell() == 0, "XclImpObjectManager::ReadObj - unexpected DFF stream data, OBJ will be ignored" );
-    if( maDffStrm.Tell() == 0 ) switch( GetBiff() )
-    {
-        case EXC_BIFF3:
-            xDrawObj = XclImpDrawObjBase::ReadObj3( rStrm );
-        break;
-        case EXC_BIFF4:
-            xDrawObj = XclImpDrawObjBase::ReadObj4( rStrm );
-        break;
-        case EXC_BIFF5:
-        case EXC_BIFF8:
-            xDrawObj = XclImpDrawObjBase::ReadObj5( rStrm );
-        break;
-        default:
-            DBG_ERROR_BIFF();
-    }
-
-    if( xDrawObj.is() )
-    {
-        // insert into maRawObjs or into the last open group object
-        maRawObjs.InsertGrouped( xDrawObj );
-        // to be able to find objects by ID
-        maObjMapId[ xDrawObj->GetObjId() ] = xDrawObj;
-    }
-}
-
-void XclImpObjectManager::ReadMsoDrawingGroup( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() == EXC_BIFF8 );
-    // Excel continues this record with MSODRAWINGGROUP and CONTINUE records, hmm.
-    rStrm.ResetRecord( true, EXC_ID_MSODRAWINGGROUP );
-    ReadDffRecord( rStrm );
-}
-
-void XclImpObjectManager::ReadMsoDrawing( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() == EXC_BIFF8 );
-    // disable internal CONTINUE handling
-    rStrm.ResetRecord( false );
-    /*  #i60510# real life: MSODRAWINGSELECTION record may contain garbage -
-        this makes it impossible to process the DFF stream in one run.
-        Store stream start position for every sheet separately, will be used
-        to seek the stream to these positions later, when processing the next
-        sheet. */
-    size_t nTabIdx = static_cast< size_t >( GetCurrScTab() );
-    if( nTabIdx >= maTabStrmPos.size() )
-    {
-        maTabStrmPos.resize( nTabIdx, STREAM_SEEK_TO_END );
-        maTabStrmPos.push_back( maDffStrm.Tell() );
-    }
-    // read leading MSODRAWING record
-    ReadDffRecord( rStrm );
-
-    // read following drawing records, but do not start following unrelated record
-    bool bLoop = true;
-    while( bLoop ) switch( rStrm.GetNextRecId() )
-    {
-        case EXC_ID_MSODRAWING:
-        case EXC_ID_MSODRAWINGSEL:
-        case EXC_ID_CONT:
-            rStrm.StartNextRecord();
-            ReadDffRecord( rStrm );
-        break;
-        case EXC_ID_OBJ:
-            rStrm.StartNextRecord();
-            ReadObj8( rStrm );
-        break;
-        case EXC_ID_TXO:
-            rStrm.StartNextRecord();
-            ReadTxo( rStrm );
-        break;
-        default:
-            bLoop = false;
-    }
-
-    // re-enable internal CONTINUE handling
-    rStrm.ResetRecord( true );
-}
-
-void XclImpObjectManager::ReadNote( XclImpStream& rStrm )
-{
-    switch( GetBiff() )
-    {
-        case EXC_BIFF2:
-        case EXC_BIFF3:
-        case EXC_BIFF4:
-        case EXC_BIFF5:
-            ReadNote3( rStrm );
-        break;
-        case EXC_BIFF8:
-            ReadNote8( rStrm );
-        break;
-        default:
-            DBG_ERROR_BIFF();
-    }
-}
-
-void XclImpObjectManager::ReadTabChart( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() >= EXC_BIFF5 );
-    ScfRef< XclImpChartObj > xChartObj( new XclImpChartObj( GetRoot(), true ) );
-    xChartObj->ReadChartSubStream( rStrm );
-    // insert the chart as raw object without connected DFF data
-    maRawObjs.push_back( xChartObj );
-}
-
-// *** Drawing objects *** ----------------------------------------------------
-
-XclImpDrawObjRef XclImpObjectManager::FindDrawObj( const DffRecordHeader& rHeader ) const
-{
-    /*  maObjMap stores objects by position of the client data (OBJ record) in
-        the DFF stream, which is always behind shape start position of the
-        passed header. The function upper_bound() finds the first element in
-        the map whose key is greater than the start position of the header. Its
-        end position is used to test whether the found object is really related
-        to the shape. */
-    XclImpDrawObjRef xDrawObj;
-    XclImpObjMap::const_iterator aIt = maObjMap.upper_bound( rHeader.GetRecBegFilePos() );
-    if( (aIt != maObjMap.end()) && (aIt->first <= rHeader.GetRecEndFilePos()) )
-        xDrawObj = aIt->second;
-    return xDrawObj;
-}
-
-XclImpDrawObjRef XclImpObjectManager::FindDrawObj( const XclObjId& rObjId ) const
-{
-    XclImpDrawObjRef xDrawObj;
-    XclImpObjMapById::const_iterator aIt = maObjMapId.find( rObjId );
-    if( aIt != maObjMapId.end() )
-        xDrawObj = aIt->second;
-    return xDrawObj;
-}
-
-const XclImpObjTextData* XclImpObjectManager::FindTextData( const DffRecordHeader& rHeader ) const
-{
-    /*  maTextMap stores textbox data by position of the client data (TXO
-        record) in the DFF stream, which is always behind shape start position
-        of the passed header. The function upper_bound() finds the first
-        element in the map whose key is greater than the start position of the
-        header. Its end position is used to test whether the found object is
-        really related to the shape. */
-    XclImpObjTextMap::const_iterator aIt = maTextMap.upper_bound( rHeader.GetRecBegFilePos() );
-    if( (aIt != maTextMap.end()) && (aIt->first <= rHeader.GetRecEndFilePos()) )
-        return aIt->second.get();
-    return 0;
-}
-
-void XclImpObjectManager::SetSkipObj( SCTAB nScTab, sal_uInt16 nObjId )
-{
-    maSkipObjs.push_back( XclObjId( nScTab, nObjId ) );
-}
-
-// *** Drawing object conversion *** ------------------------------------------
-
-XclImpDffManager& XclImpObjectManager::GetDffManager()
-{
-    if( !mxDffManager )
-        mxDffManager.reset( new XclImpDffManager( GetRoot(), *this, maDffStrm ) );
-    return *mxDffManager;
-}
-
-void XclImpObjectManager::ConvertObjects()
-{
-    RTL_LOGFILE_CONTEXT_AUTHOR( aLog, "sc", "dr104026", "XclImpObjectManager::ConvertObjects" );
-
-    // do nothing if the document does not contain a drawing layer
-    if( GetDoc().GetDrawLayer() )
-    {
-        // process list of identifiers of objects to be skipped
-        for( XclObjIdVec::const_iterator aVIt = maSkipObjs.begin(), aVEnd = maSkipObjs.end(); aVIt != aVEnd; ++aVIt )
-            if( XclImpDrawObjBase* pDrawObj = FindDrawObj( *aVIt ).get() )
-                pDrawObj->SetProcessSdrObj( false );
-
-        // get progress bar size for all valid objects
-        sal_Size nProgressSize = GetProgressSize();
-        if( nProgressSize > 0 )
-        {
-            XclImpDffManager& rDffManager = GetDffManager();
-            rDffManager.StartProgressBar( nProgressSize );
-            // process drawing objects without DFF data
-            for( XclImpDrawObjVector::const_iterator aVIt = maRawObjs.begin(), aVEnd = maRawObjs.end(); aVIt != aVEnd; ++aVIt )
-                rDffManager.ProcessObject( GetSdrPage( (*aVIt)->GetScTab() ), **aVIt );
-            // process the global DFF container, contains pictures
-            if( !maTabStrmPos.empty() && (maTabStrmPos.front() > 0) )
-                rDffManager.ProcessDrawingGroup( maDffStrm );
-            // process the sheet records, this inserts the objects into the drawing layer
-            for( StreamPosVec::const_iterator aPIt = maTabStrmPos.begin(), aPEnd = maTabStrmPos.end(); aPIt != aPEnd; ++aPIt )
-                if( *aPIt != STREAM_SEEK_TO_END )
-                    rDffManager.ProcessDrawing( maDffStrm, *aPIt );
-        }
-    }
-}
-
-String XclImpObjectManager::GetDefaultObjName( const XclImpDrawObjBase& rDrawObj ) const
-{
-    String aDefName;
-    DefObjNameMap::const_iterator aIt = maDefObjNames.find( rDrawObj.GetObjType() );
-    if( aIt != maDefObjNames.end() )
-        aDefName.Append( aIt->second );
-    return aDefName.Append( sal_Unicode( ' ' ) ).Append( String::CreateFromInt32( rDrawObj.GetObjId().mnObjId ) );
-}
-
-ScRange XclImpObjectManager::GetUsedArea( SCTAB nScTab ) const
-{
-    ScRange aScUsedArea( ScAddress::INITIALIZE_INVALID );
-    if( mxDffManager.is() )
-        aScUsedArea = mxDffManager->GetUsedArea( nScTab );
-    return aScUsedArea;
-}
-
-// private --------------------------------------------------------------------
-
-void XclImpObjectManager::ReadWmf( Graphic& rGraphic, XclImpStream& rStrm ) // static helper
-{
-    // extract graphic data from IMGDATA and following CONTINUE records
-    rStrm.Ignore( 8 );
-    SvMemoryStream aMemStrm;
-    rStrm.CopyToStream( aMemStrm, rStrm.GetRecLeft() );
-    aMemStrm.Seek( STREAM_SEEK_TO_BEGIN );
-    // import the graphic from memory stream
-    GDIMetaFile aGDIMetaFile;
-    if( ::ReadWindowMetafile( aMemStrm, aGDIMetaFile, 0 ) )
-        rGraphic = aGDIMetaFile;
-}
-
-void XclImpObjectManager::ReadBmp( Graphic& rGraphic, XclImpStream& rStrm ) // static helper
-{
-    // extract graphic data from IMGDATA and following CONTINUE records
-    SvMemoryStream aMemStrm;
-
-    /*  Excel 3 and 4 seem to write broken BMP data. Usually they write a
-        DIBCOREHEADER (12 bytes) containing width, height, planes = 1, and
-        pixel depth = 32 bit. After that, 3 unused bytes are added before the
-        actual pixel data. This does even confuse Excel 5 and later, which
-        cannot read the image data correctly. */
-    if( rStrm.GetRoot().GetBiff() <= EXC_BIFF4 )
-    {
-        rStrm.PushPosition();
-        sal_uInt32 nHdrSize;
-        sal_uInt16 nWidth, nHeight, nPlanes, nDepth;
-        rStrm >> nHdrSize >> nWidth >> nHeight >> nPlanes >> nDepth;
-        if( (nHdrSize == 12) && (nPlanes == 1) && (nDepth == 32) )
-        {
-            rStrm.Ignore( 3 );
-            aMemStrm.SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
-            aMemStrm << nHdrSize << nWidth << nHeight << nPlanes << nDepth;
-            rStrm.CopyToStream( aMemStrm, rStrm.GetRecLeft() );
-        }
-        rStrm.PopPosition();
-    }
-
-    // no special handling above -> just copy the remaining record data
-    if( aMemStrm.Tell() == 0 )
-        rStrm.CopyToStream( aMemStrm, rStrm.GetRecLeft() );
-
-    // import the graphic from memory stream
-    aMemStrm.Seek( STREAM_SEEK_TO_BEGIN );
-    Bitmap aBitmap;
-    if( aBitmap.Read( aMemStrm, FALSE ) )   // read DIB without file header
-        rGraphic = aBitmap;
-}
-
-void XclImpObjectManager::ReadDffRecord( XclImpStream& rStrm )
-{
-    maDffStrm.Seek( STREAM_SEEK_TO_END );
-    rStrm.CopyRecordToStream( maDffStrm );
-}
-
-void XclImpObjectManager::ReadObj8( XclImpStream& rStrm )
-{
-    XclImpDrawObjRef xDrawObj = XclImpDrawObjBase::ReadObj8( rStrm );
-    // store the new object in the internal containers
-    maObjMap[ maDffStrm.Tell() ] = xDrawObj;
-    maObjMapId[ xDrawObj->GetObjId() ] = xDrawObj;
-}
-
-void XclImpObjectManager::ReadTxo( XclImpStream& rStrm )
-{
-    XclImpObjTextRef xTextData( new XclImpObjTextData );
-    maTextMap[ maDffStrm.Tell() ] = xTextData;
-
-    // 1) read the TXO record
-    xTextData->maData.ReadTxo8( rStrm );
-
-    // 2) first CONTINUE with string
-    xTextData->mxString.reset();
-    bool bValid = true;
-    if( xTextData->maData.mnTextLen > 0 )
-    {
-        bValid = (rStrm.GetNextRecId() == EXC_ID_CONT) && rStrm.StartNextRecord();
-        DBG_ASSERT( bValid, "XclImpObjectManager::ReadTxo - missing CONTINUE record" );
-        if( bValid )
-            xTextData->mxString.reset( new XclImpString( rStrm.ReadUniString( xTextData->maData.mnTextLen ) ) );
-    }
-
-    // 3) second CONTINUE with formatting runs
-    if( xTextData->maData.mnFormatSize > 0 )
-    {
-        bValid = (rStrm.GetNextRecId() == EXC_ID_CONT) && rStrm.StartNextRecord();
-        DBG_ASSERT( bValid, "XclImpObjectManager::ReadTxo - missing CONTINUE record" );
-        if( bValid )
-            xTextData->ReadFormats( rStrm );
-    }
-}
-
-void XclImpObjectManager::ReadNote3( XclImpStream& rStrm )
-{
-    XclAddress aXclPos;
-    sal_uInt16 nTotalLen;
-    rStrm >> aXclPos >> nTotalLen;
-
-    SCTAB nScTab = GetCurrScTab();
-    ScAddress aScNotePos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScNotePos, aXclPos, nScTab, true ) )
-    {
-        sal_uInt16 nPartLen = ::std::min( nTotalLen, static_cast< sal_uInt16 >( rStrm.GetRecLeft() ) );
-        String aNoteText = rStrm.ReadRawByteString( nPartLen );
-        nTotalLen = nTotalLen - nPartLen;
-        while( (nTotalLen > 0) && (rStrm.GetNextRecId() == EXC_ID_NOTE) && rStrm.StartNextRecord() )
-        {
-            rStrm >> aXclPos >> nPartLen;
-            DBG_ASSERT( aXclPos.mnRow == 0xFFFF, "XclImpObjectManager::ReadNote3 - missing continuation NOTE record" );
-            if( aXclPos.mnRow == 0xFFFF )
-            {
-                DBG_ASSERT( nPartLen <= nTotalLen, "XclImpObjectManager::ReadNote3 - string too long" );
-                aNoteText.Append( rStrm.ReadRawByteString( nPartLen ) );
-                nTotalLen = nTotalLen - ::std::min( nTotalLen, nPartLen );
-            }
-            else
-            {
-                // seems to be a new note, record already started -> load the note
-                rStrm.Seek( EXC_REC_SEEK_TO_BEGIN );
-                ReadNote( rStrm );
-                nTotalLen = 0;
-            }
-        }
-        ScNoteUtil::CreateNoteFromString( GetDoc(), aScNotePos, aNoteText, false, false );
-    }
-}
-
-void XclImpObjectManager::ReadNote8( XclImpStream& rStrm )
-{
-    XclAddress aXclPos;
-    sal_uInt16 nFlags, nObjId;
-    rStrm >> aXclPos >> nFlags >> nObjId;
-
-    SCTAB nScTab = GetCurrScTab();
-    ScAddress aScNotePos( ScAddress::UNINITIALIZED );
-    if( GetAddressConverter().ConvertAddress( aScNotePos, aXclPos, nScTab, true ) )
-        if( nObjId != EXC_OBJ_INVALID_ID )
-            if( XclImpNoteObj* pNoteObj = dynamic_cast< XclImpNoteObj* >( FindDrawObj( XclObjId( nScTab, nObjId ) ).get() ) )
-                pNoteObj->SetNoteData( aScNotePos, nFlags );
-}
-
-sal_Size XclImpObjectManager::GetProgressSize() const
-{
-    sal_Size nProgressSize = maRawObjs.GetProgressSize();
-    for( XclImpObjMap::const_iterator aMIt = maObjMap.begin(), aMEnd = maObjMap.end(); aMIt != aMEnd; ++aMIt )
-        nProgressSize += aMIt->second->GetProgressSize();
-    return nProgressSize;
-}
-
-// DFF property set helper ====================================================
-
-XclImpDffPropSet::XclImpDffPropSet( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maDffManager( rRoot, maDummyStrm )
-{
-}
-
-void XclImpDffPropSet::Read( XclImpStream& rStrm )
-{
-    sal_uInt32 nPropSetSize;
-
-    rStrm.PushPosition();
-    rStrm.Ignore( 4 );
-    rStrm >> nPropSetSize;
-    rStrm.PopPosition();
-
-    mxMemStrm.reset( new SvMemoryStream );
-    rStrm.CopyToStream( *mxMemStrm, 8 + nPropSetSize );
-    mxMemStrm->Seek( STREAM_SEEK_TO_BEGIN );
-    maDffManager.ReadPropSet( *mxMemStrm, 0 );
-}
-
-sal_uInt32 XclImpDffPropSet::GetPropertyValue( sal_uInt16 nPropId, sal_uInt32 nDefault ) const
-{
-    return maDffManager.GetPropertyValue( nPropId, nDefault );
-}
-
-void XclImpDffPropSet::FillToItemSet( SfxItemSet& rItemSet ) const
-{
-    if( mxMemStrm.get() )
-        maDffManager.ApplyAttributes( *mxMemStrm, rItemSet );
-}
-
-XclImpStream& operator>>( XclImpStream& rStrm, XclImpDffPropSet& rPropSet )
-{
-    rPropSet.Read( rStrm );
-    return rStrm;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xiformula.cxx sc/source/filter/xlsx/xlsx-xiformula.cxx
deleted file mode 100644
index 240358e..0000000
--- sc/source/filter/xlsx/xlsx-xiformula.cxx
+++ /dev/null
@@ -1,130 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xiformula.cxx,v $
- * $Revision: 1.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "precompiled_sc.hxx"
-#include "xiformula.hxx"
-#include "rangelst.hxx"
-#include "xistream.hxx"
-
-#include "excform.hxx"
-
-// Formula compiler ===========================================================
-
-/** Implementation class of the export formula compiler. */
-class XclImpFmlaCompImpl : protected XclImpRoot, protected XclTokenArrayHelper
-{
-public:
-    explicit            XclImpFmlaCompImpl( const XclImpRoot& rRoot );
-
-    /** Creates a range list from the passed Excel token array. */
-    void                CreateRangeList(
-                            ScRangeList& rScRanges, XclFormulaType eType,
-                            const XclTokenArray& rXclTokArr, XclImpStream& rStrm );
-
-    const ScTokenArray* CreateFormula( XclFormulaType eType, const XclTokenArray& rXclTokArr );
-
-    // ------------------------------------------------------------------------
-private:
-    XclFunctionProvider maFuncProv;     /// Excel function data provider.
-    const XclBiff       meBiff;         /// Cached BIFF version to save GetBiff() calls.
-};
-
-// ----------------------------------------------------------------------------
-
-XclImpFmlaCompImpl::XclImpFmlaCompImpl( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maFuncProv( rRoot ),
-    meBiff( rRoot.GetBiff() )
-{
-}
-
-void XclImpFmlaCompImpl::CreateRangeList(
-        ScRangeList& rScRanges, XclFormulaType /*eType*/,
-        const XclTokenArray& rXclTokArr, XclImpStream& /*rStrm*/ )
-{
-    rScRanges.RemoveAll();
-
-    //! evil hack, using old formula import :-)
-    if( !rXclTokArr.Empty() )
-    {
-        SvMemoryStream aMemStrm;
-        aMemStrm << EXC_ID_EOF << rXclTokArr.GetSize();
-        aMemStrm.Write( rXclTokArr.GetData(), rXclTokArr.GetSize() );
-        XclImpStream aFmlaStrm( aMemStrm, GetRoot() );
-        aFmlaStrm.StartNextRecord();
-        GetOldFmlaConverter().GetAbsRefs( rScRanges, aFmlaStrm, aFmlaStrm.GetRecSize() );
-    }
-}
-
-const ScTokenArray* XclImpFmlaCompImpl::CreateFormula(
-        XclFormulaType /*eType*/, const XclTokenArray& rXclTokArr )
-{
-    if (rXclTokArr.Empty())
-        return NULL;
-
-    // evil hack!  are we trying to phase out the old style formula converter ?
-    SvMemoryStream aMemStrm;
-    aMemStrm << EXC_ID_EOF << rXclTokArr.GetSize();
-    aMemStrm.Write( rXclTokArr.GetData(), rXclTokArr.GetSize() );
-    XclImpStream aFmlaStrm( aMemStrm, GetRoot() );
-    aFmlaStrm.StartNextRecord();
-    const ScTokenArray* pArray = NULL;
-    GetOldFmlaConverter().Reset();
-    GetOldFmlaConverter().Convert(pArray, aFmlaStrm, aFmlaStrm.GetRecSize(), true);
-    return pArray;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpFormulaCompiler::XclImpFormulaCompiler( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mxImpl( new XclImpFmlaCompImpl( rRoot ) )
-{
-}
-
-XclImpFormulaCompiler::~XclImpFormulaCompiler()
-{
-}
-
-void XclImpFormulaCompiler::CreateRangeList(
-        ScRangeList& rScRanges, XclFormulaType eType,
-        const XclTokenArray& rXclTokArr, XclImpStream& rStrm )
-{
-    mxImpl->CreateRangeList( rScRanges, eType, rXclTokArr, rStrm );
-}
-
-const ScTokenArray* XclImpFormulaCompiler::CreateFormula(
-        XclFormulaType eType, const XclTokenArray& rXclTokArr )
-{
-    return mxImpl->CreateFormula(eType, rXclTokArr);
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xihelper.cxx sc/source/filter/xlsx/xlsx-xihelper.cxx
deleted file mode 100644
index f39bb1e..0000000
--- sc/source/filter/xlsx/xlsx-xihelper.cxx
+++ /dev/null
@@ -1,921 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xihelper.cxx,v $
- * $Revision: 1.29 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xihelper.hxx"
-#include <svtools/itemset.hxx>
-#include <svx/editobj.hxx>
-#include <tools/urlobj.hxx>
-#include "scitems.hxx"
-#include <svx/eeitem.hxx>
-#include <svx/flditem.hxx>
-#include "document.hxx"
-#include "cell.hxx"
-#include "rangelst.hxx"
-#include "editutil.hxx"
-#include "attrib.hxx"
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xistyle.hxx"
-
-#include "excform.hxx"
-
-// Excel->Calc cell address/range conversion ==================================
-
-namespace {
-
-/** Fills the passed Calc address with the passed Excel cell coordinates without checking any limits. */
-inline void lclFillAddress( ScAddress& rScPos, sal_uInt16 nXclCol, sal_uInt16 nXclRow, SCTAB nScTab )
-{
-    rScPos.SetCol( static_cast< SCCOL >( nXclCol ) );
-    rScPos.SetRow( static_cast< SCROW >( nXclRow ) );
-    rScPos.SetTab( nScTab );
-}
-
-} // namespace
-
-// ----------------------------------------------------------------------------
-
-XclImpAddressConverter::XclImpAddressConverter( const XclImpRoot& rRoot ) :
-    XclAddressConverterBase( rRoot.GetTracer(), rRoot.GetScMaxPos() )
-{
-}
-
-// cell address ---------------------------------------------------------------
-
-bool XclImpAddressConverter::CheckAddress( const XclAddress& rXclPos, bool bWarn )
-{
-    bool bValidCol = rXclPos.mnCol <= mnMaxCol;
-    bool bValidRow = rXclPos.mnRow <= mnMaxRow;
-    bool bValid = bValidCol && bValidRow;
-    if( !bValid && bWarn )
-    {
-        mbColTrunc |= !bValidCol;
-        mbRowTrunc |= !bValidRow;
-        mrTracer.TraceInvalidAddress( ScAddress(
-            static_cast< SCCOL >( rXclPos.mnCol ), static_cast< SCROW >( rXclPos.mnRow ), 0 ), maMaxPos );
-    }
-    return bValid;
-}
-
-bool XclImpAddressConverter::ConvertAddress( ScAddress& rScPos,
-        const XclAddress& rXclPos, SCTAB nScTab, bool bWarn )
-{
-    bool bValid = CheckAddress( rXclPos, bWarn );
-    if( bValid )
-        lclFillAddress( rScPos, rXclPos.mnCol, rXclPos.mnRow, nScTab );
-    return bValid;
-}
-
-ScAddress XclImpAddressConverter::CreateValidAddress(
-        const XclAddress& rXclPos, SCTAB nScTab, bool bWarn )
-{
-    ScAddress aScPos( ScAddress::UNINITIALIZED );
-    if( !ConvertAddress( aScPos, rXclPos, nScTab, bWarn ) )
-    {
-        aScPos.SetCol( static_cast< SCCOL >( ::std::min( rXclPos.mnCol, mnMaxCol ) ) );
-        aScPos.SetRow( static_cast< SCROW >( ::std::min( rXclPos.mnRow, mnMaxRow ) ) );
-        aScPos.SetTab( limit_cast< SCTAB >( nScTab, 0, maMaxPos.Tab() ) );
-    }
-    return aScPos;
-}
-
-// cell range -----------------------------------------------------------------
-
-bool XclImpAddressConverter::CheckRange( const XclRange& rXclRange, bool bWarn )
-{
-    return CheckAddress( rXclRange.maFirst, bWarn ) && CheckAddress( rXclRange.maLast, bWarn );
-}
-
-bool XclImpAddressConverter::ConvertRange( ScRange& rScRange,
-        const XclRange& rXclRange, SCTAB nScTab1, SCTAB nScTab2, bool bWarn )
-{
-    // check start position
-    bool bValidStart = CheckAddress( rXclRange.maFirst, bWarn );
-    if( bValidStart )
-    {
-        lclFillAddress( rScRange.aStart, rXclRange.maFirst.mnCol, rXclRange.maFirst.mnRow, nScTab1 );
-
-        // check & correct end position
-        sal_uInt16 nXclCol2 = rXclRange.maLast.mnCol;
-        sal_uInt16 nXclRow2 = rXclRange.maLast.mnRow;
-        if( !CheckAddress( rXclRange.maLast, bWarn ) )
-        {
-            nXclCol2 = ::std::min( nXclCol2, mnMaxCol );
-            nXclRow2 = ::std::min( nXclRow2, mnMaxRow );
-        }
-        lclFillAddress( rScRange.aEnd, nXclCol2, nXclRow2, nScTab2 );
-    }
-    return bValidStart;
-}
-
-//UNUSED2009-05 ScRange XclImpAddressConverter::CreateValidRange(
-//UNUSED2009-05         const XclRange& rXclRange, SCTAB nScTab1, SCTAB nScTab2, bool bWarn )
-//UNUSED2009-05 {
-//UNUSED2009-05     return ScRange(
-//UNUSED2009-05         CreateValidAddress( rXclRange.maFirst, nScTab1, bWarn ),
-//UNUSED2009-05         CreateValidAddress( rXclRange.maLast,  nScTab2, bWarn ) );
-//UNUSED2009-05 }
-
-// cell range list ------------------------------------------------------------
-
-//UNUSED2009-05 bool XclImpAddressConverter::CheckRangeList( const XclRangeList& rXclRanges, bool bWarn )
-//UNUSED2009-05 {
-//UNUSED2009-05     for( XclRangeList::const_iterator aIt = rXclRanges.begin(), aEnd = rXclRanges.end(); aIt != aEnd; ++aIt )
-//UNUSED2009-05         if( !CheckRange( *aIt, bWarn ) )
-//UNUSED2009-05             return false;
-//UNUSED2009-05     return true;
-//UNUSED2009-05 }
-
-void XclImpAddressConverter::ConvertRangeList( ScRangeList& rScRanges,
-        const XclRangeList& rXclRanges, SCTAB nScTab, bool bWarn )
-{
-    rScRanges.RemoveAll();
-    for( XclRangeList::const_iterator aIt = rXclRanges.begin(), aEnd = rXclRanges.end(); aIt != aEnd; ++aIt )
-    {
-        ScRange aScRange( ScAddress::UNINITIALIZED );
-        if( ConvertRange( aScRange, *aIt, nScTab, nScTab, bWarn ) )
-            rScRanges.Append( aScRange );
-    }
-}
-
-// String->EditEngine conversion ==============================================
-
-namespace {
-
-EditTextObject* lclCreateTextObject( const XclImpRoot& rRoot,
-        const XclImpString& rString, XclFontItemType eType, sal_uInt16 nXFIndex )
-{
-    EditTextObject* pTextObj = 0;
-
-    const XclImpXFBuffer& rXFBuffer = rRoot.GetXFBuffer();
-    const XclImpFont* pFirstFont = rXFBuffer.GetFont( nXFIndex );
-    bool bFirstEscaped = pFirstFont && pFirstFont->HasEscapement();
-
-    if( rString.IsRich() || bFirstEscaped )
-    {
-        const XclImpFontBuffer& rFontBuffer = rRoot.GetFontBuffer();
-        const XclFormatRunVec& rFormats = rString.GetFormats();
-
-        ScEditEngineDefaulter& rEE = (eType == EXC_FONTITEM_NOTE) ?
-            static_cast< ScEditEngineDefaulter& >( rRoot.GetDoc().GetNoteEngine() ) : rRoot.GetEditEngine();
-        rEE.SetText( rString.GetText() );
-
-        SfxItemSet aItemSet( rEE.GetEmptyItemSet() );
-        if( bFirstEscaped )
-            rFontBuffer.FillToItemSet( aItemSet, eType, rXFBuffer.GetFontIndex( nXFIndex ) );
-        ESelection aSelection;
-
-        XclFormatRun aNextRun;
-        XclFormatRunVec::const_iterator aIt = rFormats.begin();
-        XclFormatRunVec::const_iterator aEnd = rFormats.end();
-
-        if( aIt != aEnd )
-            aNextRun = *aIt++;
-        else
-            aNextRun.mnChar = 0xFFFF;
-
-        xub_StrLen nLen = rString.GetText().Len();
-        for( sal_uInt16 nChar = 0; nChar < nLen; ++nChar )
-        {
-            // reached new different formatted text portion
-            if( nChar >= aNextRun.mnChar )
-            {
-                // send items to edit engine
-                rEE.QuickSetAttribs( aItemSet, aSelection );
-
-                // start new item set
-                aItemSet.ClearItem();
-                rFontBuffer.FillToItemSet( aItemSet, eType, aNextRun.mnFontIdx );
-
-                // read new formatting information
-                if( aIt != aEnd )
-                    aNextRun = *aIt++;
-                else
-                    aNextRun.mnChar = 0xFFFF;
-
-                // reset selection start to current position
-                aSelection.nStartPara = aSelection.nEndPara;
-                aSelection.nStartPos = aSelection.nEndPos;
-            }
-
-            // set end of selection to current position
-            if( rString.GetText().GetChar( nChar ) == '\n' )
-            {
-                ++aSelection.nEndPara;
-                aSelection.nEndPos = 0;
-            }
-            else
-                ++aSelection.nEndPos;
-        }
-
-        // send items of last text portion to edit engine
-        rEE.QuickSetAttribs( aItemSet, aSelection );
-
-        pTextObj = rEE.CreateTextObject();
-    }
-
-    return pTextObj;
-}
-
-} // namespace
-
-EditTextObject* XclImpStringHelper::CreateTextObject(
-        const XclImpRoot& rRoot, const XclImpString& rString )
-{
-    return lclCreateTextObject( rRoot, rString, EXC_FONTITEM_EDITENG, 0 );
-}
-
-//UNUSED2009-05 EditTextObject* XclImpStringHelper::CreateNoteObject(
-//UNUSED2009-05         const XclImpRoot& rRoot, const XclImpString& rString )
-//UNUSED2009-05 {
-//UNUSED2009-05     return lclCreateTextObject( rRoot, rString, EXC_FONTITEM_NOTE, 0 );
-//UNUSED2009-05 }
-
-ScBaseCell* XclImpStringHelper::CreateCell(
-        const XclImpRoot& rRoot, const XclImpString& rString, sal_uInt16 nXFIndex )
-{
-    ScBaseCell* pCell = 0;
-
-    if( rString.GetText().Len() )
-    {
-        ::std::auto_ptr< EditTextObject > pTextObj( lclCreateTextObject( rRoot, rString, EXC_FONTITEM_EDITENG, nXFIndex ) );
-        ScDocument& rDoc = rRoot.GetDoc();
-
-        if( pTextObj.get() )
-            // ScEditCell creates own copy of text object
-            pCell = new ScEditCell( pTextObj.get(), &rDoc, rRoot.GetEditEngine().GetEditTextObjectPool() );
-        else
-            pCell = ScBaseCell::CreateTextCell( rString.GetText(), &rDoc );
-    }
-
-    return pCell;
-}
-
-// Header/footer conversion ===================================================
-
-XclImpHFConverter::XclImpHFPortionInfo::XclImpHFPortionInfo() :
-    mnHeight( 0 ),
-    mnMaxLineHt( 0 )
-{
-    maSel.nStartPara = maSel.nEndPara = 0;
-    maSel.nStartPos = maSel.nEndPos = 0;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpHFConverter::XclImpHFConverter( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mrEE( rRoot.GetHFEditEngine() ),
-    mxFontData( new XclFontData ),
-    meCurrObj( EXC_HF_CENTER )
-{
-}
-
-XclImpHFConverter::~XclImpHFConverter()
-{
-}
-
-void XclImpHFConverter::ParseString( const String& rHFString )
-{
-    // edit engine objects
-    mrEE.SetText( EMPTY_STRING );
-    maInfos.clear();
-    maInfos.resize( EXC_HF_PORTION_COUNT );
-    meCurrObj = EXC_HF_CENTER;
-
-    // parser temporaries
-    maCurrText.Erase();
-    String aReadFont;           // current font name
-    String aReadStyle;          // current font style
-    sal_uInt16 nReadHeight = 0; // current font height
-    ResetFontData();
-
-    /** State of the parser. */
-    enum XclHFParserState
-    {
-        xlPSText,           /// Read text, search for functions.
-        xlPSFunc,           /// Read function (token following a '&').
-        xlPSFont,           /// Read font name ('&' is followed by '"', reads until next '"' or ',').
-        xlPSFontStyle,      /// Read font style name (font part after ',', reads until next '"').
-        xlPSHeight          /// Read font height ('&' is followed by num. digits, reads until non-digit).
-    } eState = xlPSText;
-
-    const sal_Unicode* pChar = rHFString.GetBuffer();
-    const sal_Unicode* pNull = pChar + rHFString.Len(); // pointer to teminating null char
-    while( *pChar )
-    {
-        switch( eState )
-        {
-
-// --- read text character ---
-
-            case xlPSText:
-            {
-                switch( *pChar )
-                {
-                    case '&':           // new command
-                        InsertText();
-                        eState = xlPSFunc;
-                    break;
-                    case '\n':          // line break
-                        InsertText();
-                        InsertLineBreak();
-                    break;
-                    default:
-                        maCurrText += *pChar;
-                }
-            }
-            break;
-
-// --- read control sequence ---
-
-            case xlPSFunc:
-            {
-                eState = xlPSText;
-                switch( *pChar )
-                {
-                    case '&':   maCurrText += '&';  break;  // the '&' character
-
-                    case 'L':   SetNewPortion( EXC_HF_LEFT );   break;  // Left portion
-                    case 'C':   SetNewPortion( EXC_HF_CENTER ); break;  // Center portion
-                    case 'R':   SetNewPortion( EXC_HF_RIGHT );  break;  // Right portion
-
-                    case 'P':   InsertField( SvxFieldItem( SvxPageField(), EE_FEATURE_FIELD ) );      break;  // page
-                    case 'N':   InsertField( SvxFieldItem( SvxPagesField(), EE_FEATURE_FIELD ) );     break;  // page count
-                    case 'D':   InsertField( SvxFieldItem( SvxDateField(), EE_FEATURE_FIELD ) );      break;  // date
-                    case 'T':   InsertField( SvxFieldItem( SvxTimeField(), EE_FEATURE_FIELD ) );      break;  // time
-                    case 'A':   InsertField( SvxFieldItem( SvxTableField(), EE_FEATURE_FIELD ) );     break;  // table name
-
-                    case 'Z':           // file path
-                        InsertField( SvxFieldItem( SvxExtFileField(), EE_FEATURE_FIELD ) );   // convert to full name
-                        if( (pNull - pChar >= 2) && (*(pChar + 1) == '&') && (*(pChar + 2) == 'F') )
-                        {
-                            // &Z&F found - ignore the &F part
-                            pChar += 2;
-                        }
-                    break;
-                    case 'F':           // file name
-                        InsertField( SvxFieldItem( SvxExtFileField( EMPTY_STRING, SVXFILETYPE_VAR, SVXFILEFORMAT_NAME_EXT ), EE_FEATURE_FIELD ) );
-                    break;
-
-                    case 'U':           // underline
-                        SetAttribs();
-                        mxFontData->mnUnderline = (mxFontData->mnUnderline == EXC_FONTUNDERL_SINGLE) ?
-                            EXC_FONTUNDERL_NONE : EXC_FONTUNDERL_SINGLE;
-                    break;
-                    case 'E':           // double underline
-                        SetAttribs();
-                        mxFontData->mnUnderline = (mxFontData->mnUnderline == EXC_FONTUNDERL_DOUBLE) ?
-                            EXC_FONTUNDERL_NONE : EXC_FONTUNDERL_DOUBLE;
-                    break;
-                    case 'S':           // strikeout
-                        SetAttribs();
-                        mxFontData->mbStrikeout = !mxFontData->mbStrikeout;
-                    break;
-                    case 'X':           // superscript
-                        SetAttribs();
-                        mxFontData->mnEscapem = (mxFontData->mnEscapem == EXC_FONTESC_SUPER) ?
-                            EXC_FONTESC_NONE : EXC_FONTESC_SUPER;
-                    break;
-                    case 'Y':           // subsrcipt
-                        SetAttribs();
-                        mxFontData->mnEscapem = (mxFontData->mnEscapem == EXC_FONTESC_SUB) ?
-                            EXC_FONTESC_NONE : EXC_FONTESC_SUB;
-                    break;
-
-                    case '\"':          // font name
-                        aReadFont.Erase();
-                        aReadStyle.Erase();
-                        eState = xlPSFont;
-                    break;
-                    default:
-                        if( ('0' <= *pChar) && (*pChar <= '9') )    // font size
-                        {
-                            nReadHeight = *pChar - '0';
-                            eState = xlPSHeight;
-                        }
-                }
-            }
-            break;
-
-// --- read font name ---
-
-            case xlPSFont:
-            {
-                switch( *pChar )
-                {
-                    case '\"':
-                        --pChar;
-                        // run through
-                    case ',':
-                        eState = xlPSFontStyle;
-                    break;
-                    default:
-                        aReadFont += *pChar;
-                }
-            }
-            break;
-
-// --- read font style ---
-
-            case xlPSFontStyle:
-            {
-                switch( *pChar )
-                {
-                    case '\"':
-                        SetAttribs();
-                        if( aReadFont.Len() )
-                            mxFontData->maName = aReadFont;
-                        mxFontData->maStyle = aReadStyle;
-                        eState = xlPSText;
-                    break;
-                    default:
-                        aReadStyle += *pChar;
-                }
-            }
-            break;
-
-// --- read font height ---
-
-            case xlPSHeight:
-            {
-                if( ('0' <= *pChar) && (*pChar <= '9') )
-                {
-                    if( nReadHeight != 0xFFFF )
-                    {
-                        nReadHeight *= 10;
-                        nReadHeight += (*pChar - '0');
-                        if( nReadHeight > 1600 )    // max 1600pt = 32000twips
-                            nReadHeight = 0xFFFF;
-                    }
-                }
-                else
-                {
-                    if( (nReadHeight != 0) && (nReadHeight != 0xFFFF) )
-                    {
-                        SetAttribs();
-                        mxFontData->mnHeight = nReadHeight * 20;
-                    }
-                    --pChar;
-                    eState = xlPSText;
-                }
-            }
-            break;
-        }
-        ++pChar;
-    }
-
-    // finalize
-    CreateCurrObject();
-    maInfos[ EXC_HF_LEFT   ].mnHeight += GetMaxLineHeight( EXC_HF_LEFT );
-    maInfos[ EXC_HF_CENTER ].mnHeight += GetMaxLineHeight( EXC_HF_CENTER );
-    maInfos[ EXC_HF_RIGHT  ].mnHeight += GetMaxLineHeight( EXC_HF_RIGHT );
-}
-
-void XclImpHFConverter::FillToItemSet( SfxItemSet& rItemSet, sal_uInt16 nWhichId ) const
-{
-    ScPageHFItem aHFItem( nWhichId );
-    if( maInfos[ EXC_HF_LEFT ].mxObj.get() )
-        aHFItem.SetLeftArea( *maInfos[ EXC_HF_LEFT ].mxObj );
-    if( maInfos[ EXC_HF_CENTER ].mxObj.get() )
-        aHFItem.SetCenterArea( *maInfos[ EXC_HF_CENTER ].mxObj );
-    if( maInfos[ EXC_HF_RIGHT ].mxObj.get() )
-        aHFItem.SetRightArea( *maInfos[ EXC_HF_RIGHT ].mxObj );
-    rItemSet.Put( aHFItem );
-}
-
-sal_Int32 XclImpHFConverter::GetTotalHeight() const
-{
-    return ::std::max( maInfos[ EXC_HF_LEFT ].mnHeight,
-        ::std::max( maInfos[ EXC_HF_CENTER ].mnHeight, maInfos[ EXC_HF_RIGHT ].mnHeight ) );
-}
-
-// private --------------------------------------------------------------------
-
-sal_uInt16 XclImpHFConverter::GetMaxLineHeight( XclImpHFPortion ePortion ) const
-{
-    sal_uInt16 nMaxHt = maInfos[ ePortion ].mnMaxLineHt;
-    return (nMaxHt == 0) ? mxFontData->mnHeight : nMaxHt;
-}
-
-sal_uInt16 XclImpHFConverter::GetCurrMaxLineHeight() const
-{
-    return GetMaxLineHeight( meCurrObj );
-}
-
-void XclImpHFConverter::UpdateMaxLineHeight( XclImpHFPortion ePortion )
-{
-    sal_uInt16& rnMaxHt = maInfos[ ePortion ].mnMaxLineHt;
-    rnMaxHt = ::std::max( rnMaxHt, mxFontData->mnHeight );
-}
-
-void XclImpHFConverter::UpdateCurrMaxLineHeight()
-{
-    UpdateMaxLineHeight( meCurrObj );
-}
-
-void XclImpHFConverter::SetAttribs()
-{
-    ESelection& rSel = GetCurrSel();
-    if( (rSel.nStartPara != rSel.nEndPara) || (rSel.nStartPos != rSel.nEndPos) )
-    {
-        SfxItemSet aItemSet( mrEE.GetEmptyItemSet() );
-        XclImpFont aFont( GetRoot(), *mxFontData );
-        aFont.FillToItemSet( aItemSet, EXC_FONTITEM_HF );
-        mrEE.QuickSetAttribs( aItemSet, rSel );
-        rSel.nStartPara = rSel.nEndPara;
-        rSel.nStartPos = rSel.nEndPos;
-    }
-}
-
-void XclImpHFConverter::ResetFontData()
-{
-    if( const XclImpFont* pFirstFont = GetFontBuffer().GetFont( EXC_FONT_APP ) )
-        *mxFontData = pFirstFont->GetFontData();
-    else
-    {
-        mxFontData->Clear();
-        mxFontData->mnHeight = 200;
-    }
-}
-
-void XclImpHFConverter::InsertText()
-{
-    if( maCurrText.Len() )
-    {
-        ESelection& rSel = GetCurrSel();
-        mrEE.QuickInsertText( maCurrText, ESelection( rSel.nEndPara, rSel.nEndPos, rSel.nEndPara, rSel.nEndPos ) );
-        rSel.nEndPos = rSel.nEndPos + maCurrText.Len();
-        maCurrText.Erase();
-        UpdateCurrMaxLineHeight();
-    }
-}
-
-void XclImpHFConverter::InsertField( const SvxFieldItem& rFieldItem )
-{
-    ESelection& rSel = GetCurrSel();
-    mrEE.QuickInsertField( rFieldItem, ESelection( rSel.nEndPara, rSel.nEndPos, rSel.nEndPara, rSel.nEndPos ) );
-    ++rSel.nEndPos;
-    UpdateCurrMaxLineHeight();
-}
-
-void XclImpHFConverter::InsertLineBreak()
-{
-    ESelection& rSel = GetCurrSel();
-    mrEE.QuickInsertText( String( '\n' ), ESelection( rSel.nEndPara, rSel.nEndPos, rSel.nEndPara, rSel.nEndPos ) );
-    ++rSel.nEndPara;
-    rSel.nEndPos = 0;
-    GetCurrInfo().mnHeight += GetCurrMaxLineHeight();
-    GetCurrInfo().mnMaxLineHt = 0;
-}
-
-void XclImpHFConverter::CreateCurrObject()
-{
-    InsertText();
-    SetAttribs();
-    GetCurrObj().reset( mrEE.CreateTextObject() );
-}
-
-void XclImpHFConverter::SetNewPortion( XclImpHFPortion eNew )
-{
-    if( eNew != meCurrObj )
-    {
-        CreateCurrObject();
-        meCurrObj = eNew;
-        if( GetCurrObj().get() )
-            mrEE.SetText( *GetCurrObj() );
-        else
-            mrEE.SetText( EMPTY_STRING );
-        ResetFontData();
-    }
-}
-
-// URL conversion =============================================================
-
-namespace {
-
-void lclAppendUrlChar( String& rUrl, sal_Unicode cChar )
-{
-    // #126855# encode special characters
-    switch( cChar )
-    {
-        case '#':   rUrl.AppendAscii( "%23" );  break;
-        case '%':   rUrl.AppendAscii( "%25" );  break;
-        default:    rUrl.Append( cChar );
-    }
-}
-
-} // namespace
-
-void XclImpUrlHelper::DecodeUrl(
-        String& rUrl, String& rTabName, bool& rbSameWb,
-        const XclImpRoot& rRoot, const String& rEncodedUrl )
-{
-    enum
-    {
-        xlUrlInit,              /// Initial state, read string mode character.
-        xlUrlPath,              /// Read URL path.
-        xlUrlFileName,          /// Read file name.
-        xlUrlSheetName,         /// Read sheet name.
-        xlUrlRaw                /// Raw mode. No control characters will occur.
-    } eState = xlUrlInit;
-
-    bool bEncoded = true;
-    rbSameWb = false;
-
-    sal_Unicode cCurrDrive = 0;
-    String aDosBase( INetURLObject( rRoot.GetBasePath() ).getFSysPath( INetURLObject::FSYS_DOS ) );
-    if( (aDosBase.Len() > 2) && aDosBase.EqualsAscii( ":\\", 1, 2 ) )
-        cCurrDrive = aDosBase.GetChar( 0 );
-
-    const sal_Unicode* pChar = rEncodedUrl.GetBuffer();
-    while( *pChar )
-    {
-        switch( eState )
-        {
-
-// --- first character ---
-
-            case xlUrlInit:
-            {
-                switch( *pChar )
-                {
-                    case EXC_URLSTART_ENCODED:
-                        eState = xlUrlPath;
-                    break;
-                    case EXC_URLSTART_SELF:
-                    case EXC_URLSTART_SELFENCODED:
-                        rbSameWb = true;
-                        eState = xlUrlSheetName;
-                    break;
-                    case '[':
-                        bEncoded = false;
-                        eState = xlUrlFileName;
-                    break;
-                    default:
-                        bEncoded = false;
-                        lclAppendUrlChar( rUrl, *pChar );
-                        eState = xlUrlPath;
-                }
-            }
-            break;
-
-// --- URL path ---
-
-            case xlUrlPath:
-            {
-                switch( *pChar )
-                {
-                    case EXC_URL_DOSDRIVE:
-                    {
-                        if( *(pChar + 1) )
-                        {
-                            ++pChar;
-                            if( *pChar == '@' )
-                                rUrl.AppendAscii( "\\\\" );
-                            else
-                            {
-                                lclAppendUrlChar( rUrl, *pChar );
-                                rUrl.AppendAscii( ":\\" );
-                            }
-                        }
-                        else
-                            rUrl.AppendAscii( "<NULL-DRIVE!>" );
-                    }
-                    break;
-                    case EXC_URL_DRIVEROOT:
-                        if( cCurrDrive )
-                        {
-                            lclAppendUrlChar( rUrl, cCurrDrive );
-                            rUrl.Append( ':' );
-                        }
-                        // run through
-                    case EXC_URL_SUBDIR:
-                        if( bEncoded )
-                            rUrl.Append( '\\' );
-                        else    // control character in raw name -> DDE link
-                        {
-                            rUrl.Append( EXC_DDE_DELIM );
-                            eState = xlUrlRaw;
-                        }
-                    break;
-                    case EXC_URL_PARENTDIR:
-                        rUrl.AppendAscii( "..\\" );
-                    break;
-                    case EXC_URL_RAW:
-                    {
-                        if( *(pChar + 1) )
-                        {
-                            xub_StrLen nLen = *++pChar;
-                            for( xub_StrLen nChar = 0; (nChar < nLen) && *(pChar + 1); ++nChar )
-                                lclAppendUrlChar( rUrl, *++pChar );
-//                            rUrl.Append( ':' );
-                        }
-                    }
-                    break;
-                    case '[':
-                        eState = xlUrlFileName;
-                    break;
-                    default:
-                        lclAppendUrlChar( rUrl, *pChar );
-                }
-            }
-            break;
-
-// --- file name ---
-
-            case xlUrlFileName:
-            {
-                switch( *pChar )
-                {
-                    case ']':   eState = xlUrlSheetName;    break;
-                    default:    lclAppendUrlChar( rUrl, *pChar );
-                }
-            }
-            break;
-
-// --- sheet name ---
-
-            case xlUrlSheetName:
-                rTabName.Append( *pChar );
-            break;
-
-// --- raw read mode ---
-
-            case xlUrlRaw:
-                lclAppendUrlChar( rUrl, *pChar );
-            break;
-        }
-
-        ++pChar;
-    }
-}
-
-void XclImpUrlHelper::DecodeUrl(
-        String& rUrl, bool& rbSameWb, const XclImpRoot& rRoot, const String& rEncodedUrl )
-{
-    String aTabName;
-    DecodeUrl( rUrl, aTabName, rbSameWb, rRoot, rEncodedUrl );
-    DBG_ASSERT( !aTabName.Len(), "XclImpUrlHelper::DecodeUrl - sheet name ignored" );
-}
-
-bool XclImpUrlHelper::DecodeLink( String& rApplic, String& rTopic, const String rEncUrl )
-{
-    xub_StrLen nPos = rEncUrl.Search( EXC_DDE_DELIM );
-    if( (nPos != STRING_NOTFOUND) && (0 < nPos) && (nPos + 1 < rEncUrl.Len()) )
-    {
-        rApplic = rEncUrl.Copy( 0, nPos );
-        rTopic = rEncUrl.Copy( nPos + 1 );
-        return true;
-    }
-    return false;
-}
-
-// Cached Values ==============================================================
-
-XclImpCachedValue::XclImpCachedValue( XclImpStream& rStrm ) :
-    mfValue( 0.0 ),
-    mnBoolErr( 0 )
-{
-    rStrm >> mnType;
-    switch( mnType )
-    {
-        case EXC_CACHEDVAL_EMPTY:
-            rStrm.Ignore( 8 );
-        break;
-        case EXC_CACHEDVAL_DOUBLE:
-            rStrm >> mfValue;
-        break;
-        case EXC_CACHEDVAL_STRING:
-            mxStr.reset( new String( rStrm.ReadUniString() ) );
-        break;
-        case EXC_CACHEDVAL_BOOL:
-        case EXC_CACHEDVAL_ERROR:
-        {
-            double fVal;
-            rStrm >> mnBoolErr;
-            rStrm.Ignore( 7 );
-
-            const ScTokenArray* pScTokArr = rStrm.GetRoot().GetOldFmlaConverter().GetBoolErr(
-                XclTools::ErrorToEnum( fVal, mnType == EXC_CACHEDVAL_ERROR, mnBoolErr ) );
-            if( pScTokArr )
-                mxTokArr.reset( pScTokArr->Clone() );
-        }
-        break;
-        default:
-            DBG_ERRORFILE( "XclImpCachedValue::XclImpCachedValue - unknown data type" );
-    }
-}
-
-XclImpCachedValue::~XclImpCachedValue()
-{
-}
-
-USHORT XclImpCachedValue::GetError() const
-{
-    return (mnType == EXC_CACHEDVAL_ERROR) ? XclTools::GetScErrorCode( mnBoolErr ) : 0;
-}
-
-// Matrix Cached Values ==============================================================
-
-XclImpCachedMatrix::XclImpCachedMatrix( XclImpStream& rStrm ) :
-    mnScCols( 0 ),
-    mnScRows( 0 )
-{
-    mnScCols = rStrm.ReaduInt8();
-    mnScRows = rStrm.ReaduInt16();
-
-    if( rStrm.GetRoot().GetBiff() <= EXC_BIFF5 )
-    {
-        // in BIFF2-BIFF7: 256 columns represented by 0 columns
-        if( mnScCols == 0 )
-            mnScCols = 256;
-    }
-    else
-    {
-        // in BIFF8: columns and rows decreaed by 1
-        ++mnScCols;
-        ++mnScRows;
-    }
-
-    for( SCSIZE nScRow = 0; nScRow < mnScRows; ++nScRow )
-        for( SCSIZE nScCol = 0; nScCol < mnScCols; ++nScCol )
-            maValueList.Append( new XclImpCachedValue( rStrm ) );
-}
-
-XclImpCachedMatrix::~XclImpCachedMatrix()
-{
-}
-
-ScMatrixRef XclImpCachedMatrix::CreateScMatrix() const
-{
-    ScMatrixRef xScMatrix;
-    DBG_ASSERT( mnScCols * mnScRows == maValueList.Count(), "XclImpCachedMatrix::CreateScMatrix - element count mismatch" );
-    if( mnScCols && mnScRows && static_cast< ULONG >( mnScCols * mnScRows ) <= maValueList.Count() )
-    {
-        xScMatrix = new ScMatrix( mnScCols, mnScRows );
-        const XclImpCachedValue* pValue = maValueList.First();
-        for( SCSIZE nScRow = 0; nScRow < mnScRows; ++nScRow )
-        {
-            for( SCSIZE nScCol = 0; nScCol < mnScCols; ++nScCol )
-            {
-                switch( pValue->GetType() )
-                {
-                    case EXC_CACHEDVAL_EMPTY:
-                        // Excel shows 0.0 here, not an empty cell
-                        xScMatrix->PutEmpty( nScCol, nScRow );
-                    break;
-                    case EXC_CACHEDVAL_DOUBLE:
-                        xScMatrix->PutDouble( pValue->GetValue(), nScCol, nScRow );
-                    break;
-                    case EXC_CACHEDVAL_STRING:
-                        xScMatrix->PutString( pValue->GetString(), nScCol, nScRow );
-                    break;
-                    case EXC_CACHEDVAL_BOOL:
-                        xScMatrix->PutBoolean( pValue->GetBool(), nScCol, nScRow );
-                    break;
-                    case EXC_CACHEDVAL_ERROR:
-                        xScMatrix->PutError( pValue->GetError(), nScCol, nScRow );
-                    break;
-                    default:
-                        DBG_ERRORFILE( "XclImpCachedMatrix::CreateScMatrix - unknown value type" );
-                        xScMatrix->PutEmpty( nScCol, nScRow );
-                }
-                pValue = maValueList.Next();
-            }
-        }
-    }
-    return xScMatrix;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xilink.cxx sc/source/filter/xlsx/xlsx-xilink.cxx
deleted file mode 100644
index 0026821..0000000
--- sc/source/filter/xlsx/xlsx-xilink.cxx
+++ /dev/null
@@ -1,801 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xilink.cxx,v $
- * $Revision: 1.25.46.7 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xilink.hxx"
-#include "document.hxx"
-#include "cell.hxx"
-#include "scextopt.hxx"
-#include "tablink.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xiname.hxx"
-#include "excform.hxx"
-#include "tokenarray.hxx"
-#include "externalrefmgr.hxx"
-
-#include <vector>
-
-using ::std::vector;
-
-// ============================================================================
-// *** Helper classes ***
-// ============================================================================
-
-// Cached external cells ======================================================
-
-/** Contains the address and value of an external referenced cell. */
-class XclImpCrn : public XclImpCachedValue
-{
-public:
-    /** Reads a cached value and stores it with its cell address. */
-    explicit            XclImpCrn( XclImpStream& rStrm, const XclAddress& rXclPos );
-
-    const XclAddress&   GetAddress() const;
-
-private:
-    XclAddress          maXclPos;       /// Excel position of the cached cell.
-};
-
-// Sheet in an external document ==============================================
-
-/** Contains the name and sheet index of one sheet in an external document. */
-class XclImpSupbookTab
-{
-public:
-    /** Stores the sheet name and marks the sheet index as invalid.
-        The sheet index is set while creating the Calc sheet with CreateTable(). */
-    explicit            XclImpSupbookTab( const String& rTabName );
-                        ~XclImpSupbookTab();
-
-    inline const String& GetTabName() const { return maTabName; }
-
-    /** Reads a CRN record (external referenced cell) at the specified address. */
-    void                ReadCrn( XclImpStream& rStrm, const XclAddress& rXclPos );
-
-    void                LoadCachedValues(ScExternalRefCache::TableTypeRef pCacheTable);
-
-private:
-    typedef ScfDelList< XclImpCrn > XclImpCrnList;
-
-    XclImpCrnList       maCrnList;      /// List of CRN records (cached cell values).
-    String              maTabName;      /// Name of the external sheet.
-    SCTAB               mnScTab;        /// New sheet index in Calc document.
-};
-
-// External document (SUPBOOK) ================================================
-
-/** This class represents an external linked document (record SUPBOOK).
-    @descr  Contains a list of all referenced sheets in the document. */
-class XclImpSupbook : protected XclImpRoot
-{
-public:
-    /** Reads the SUPBOOK record from stream. */
-    explicit            XclImpSupbook( XclImpStream& rStrm );
-
-    /** Reads an XCT record (count of following CRNs and current sheet). */
-    void                ReadXct( XclImpStream& rStrm );
-    /** Reads a CRN record (external referenced cell). */
-    void                ReadCrn( XclImpStream& rStrm );
-    /** Reads an EXTERNNAME record. */
-    void                ReadExternname( XclImpStream& rStrm, ExcelToSc* pFormulaConv = NULL );
-
-    /** Returns the SUPBOOK record type. */
-    inline XclSupbookType GetType() const { return meType; }
-
-    /** Returns the URL of the external document. */
-    inline const String& GetXclUrl() const { return maXclUrl; }
-
-    /** Returns the external name specified by an index from the Excel document (one-based). */
-    const XclImpExtName* GetExternName( sal_uInt16 nXclIndex ) const;
-    /** Tries to decode the URL to OLE or DDE link components.
-        @descr  For DDE links: Decodes to application name and topic.
-        For OLE object links: Decodes to class name and document URL.
-        @return  true = decoding was successful, returned strings are valid (not empty). */
-    bool                GetLinkData( String& rApplic, String& rDoc ) const;
-    /** Returns the specified macro name (1-based) or an empty string on error. */
-    const String&       GetMacroName( sal_uInt16 nXclNameIdx ) const;
-
-    const String&       GetTabName( sal_uInt16 nXtiTab ) const;
-
-    sal_uInt16          GetTabCount() const;
-
-    void                LoadCachedValues();
-
-private:
-    typedef ScfDelList< XclImpSupbookTab >  XclImpSupbookTabList;
-    typedef ScfDelList< XclImpExtName >     XclImpExtNameList;
-
-    XclImpSupbookTabList maSupbTabList;     /// All sheet names of the document.
-    XclImpExtNameList   maExtNameList;      /// All external names of the document.
-    String              maXclUrl;           /// URL of the external document (Excel mode).
-    String              maFilterName;       /// Detected filer name.
-    String              maFilterOpt;        /// Detected filer options.
-    XclSupbookType      meType;             /// Type of the supbook record.
-    sal_uInt16          mnSBTab;            /// Current Excel sheet index from SUPBOOK for XCT/CRN records.
-};
-
-// Import link manager ========================================================
-
-/** Contains the SUPBOOK index and sheet indexes of an external link.
-    @descr  It is possible to enter a formula like =SUM(Sheet1:Sheet3!A1),
-    therefore here occurs a sheet range. */
-struct XclImpXti
-{
-    sal_uInt16          mnSupbook;      /// Index to SUPBOOK record.
-    sal_uInt16          mnSBTabFirst;   /// Index to the first sheet of the range in the SUPBOOK.
-    sal_uInt16          mnSBTabLast;    /// Index to the last sheet of the range in the SUPBOOK.
-    inline explicit     XclImpXti() : mnSupbook( SAL_MAX_UINT16 ), mnSBTabFirst( SAL_MAX_UINT16 ), mnSBTabLast( SAL_MAX_UINT16 ) {}
-};
-
-inline XclImpStream& operator>>( XclImpStream& rStrm, XclImpXti& rXti )
-{
-    return rStrm >> rXti.mnSupbook >> rXti.mnSBTabFirst >> rXti.mnSBTabLast;
-}
-
-// ----------------------------------------------------------------------------
-
-/** Implementation of the link manager. */
-class XclImpLinkManagerImpl : protected XclImpRoot
-{
-public:
-    explicit            XclImpLinkManagerImpl( const XclImpRoot& rRoot );
-
-    /** Reads the EXTERNSHEET record. */
-    void                ReadExternsheet( XclImpStream& rStrm );
-    /** Reads a SUPBOOK record. */
-    void                ReadSupbook( XclImpStream& rStrm );
-    /** Reads an XCT record and appends it to the current SUPBOOK. */
-    void                ReadXct( XclImpStream& rStrm );
-    /** Reads a CRN record and appends it to the current SUPBOOK. */
-    void                ReadCrn( XclImpStream& rStrm );
-    /** Reads an EXTERNNAME record and appends it to the current SUPBOOK. */
-    void                ReadExternname( XclImpStream& rStrm, ExcelToSc* pFormulaConv = NULL );
-
-    /** Returns true, if the specified XTI entry contains an internal reference. */
-    bool                IsSelfRef( sal_uInt16 nXtiIndex ) const;
-    /** Returns the Calc sheet index range of the specified XTI entry.
-        @return  true = XTI data found, returned sheet index range is valid. */
-    bool                GetScTabRange(
-                            SCTAB& rnFirstScTab, SCTAB& rnLastScTab,
-                            sal_uInt16 nXtiIndex ) const;
-    /** Returns the specified external name or 0 on error. */
-    const XclImpExtName* GetExternName( sal_uInt16 nXtiIndex, sal_uInt16 nExtName ) const;
-
-    /** Returns the absolute file URL of a supporting workbook specified by
-        the index. */
-    const String*       GetSupbookUrl( sal_uInt16 nXtiIndex ) const;
-
-    const String&       GetSupbookTabName( sal_uInt16 nXti, sal_uInt16 nXtiTab ) const;
-
-    /** Tries to decode the URL of the specified XTI entry to OLE or DDE link components.
-        @descr  For DDE links: Decodes to application name and topic.
-        For OLE object links: Decodes to class name and document URL.
-        @return  true = decoding was successful, returned strings are valid (not empty). */
-    bool                GetLinkData( String& rApplic, String& rTopic, sal_uInt16 nXtiIndex ) const;
-    /** Returns the specified macro name or an empty string on error. */
-    const String&       GetMacroName( sal_uInt16 nExtSheet, sal_uInt16 nExtName ) const;
-
-private:
-    /** Returns the specified XTI (link entry from BIFF8 EXTERNSHEET record). */
-    const XclImpXti*    GetXti( sal_uInt16 nXtiIndex ) const;
-    /** Returns the specified SUPBOOK (external document). */
-    const XclImpSupbook* GetSupbook( sal_uInt16 nXtiIndex ) const;
-//UNUSED2009-05 /** Returns the SUPBOOK (external workbook) specified by its URL. */
-//UNUSED2009-05 const XclImpSupbook* GetSupbook( const String& rUrl ) const;
-
-    void                LoadCachedValues();
-
-//UNUSED2009-05 /** Finds the largest range of sheet indexes in a SUPBOOK after a start sheet index.
-//UNUSED2009-05     @param rnSBTabFirst  (out-param) The first sheet index of the range in SUPBOOK is returned here.
-//UNUSED2009-05     @param rnSBTabLast  (out-param) The last sheet index of the range in SUPBOOK is returned here (inclusive).
-//UNUSED2009-05     @param nSupbook  The list index of the SUPBOOK.
-//UNUSED2009-05     @param nSBTabStart  The first allowed sheet index. Sheet ranges with an earlier start index are ignored.
-//UNUSED2009-05     @return  true = the return values are valid; false = nothing found. */
-//UNUSED2009-05 bool                FindNextTabRange(
-//UNUSED2009-05                         sal_uInt16& rnSBTabFirst, sal_uInt16& rnSBTabLast,
-//UNUSED2009-05                         sal_uInt16 nSupbook, sal_uInt16 nSBTabStart ) const;
-
-private:
-    typedef ::std::vector< XclImpXti >  XclImpXtiVector;
-    typedef ScfDelList< XclImpSupbook > XclImpSupbookList;
-
-    XclImpXtiVector     maXtiList;          /// List of all XTI structures.
-    XclImpSupbookList   maSupbookList;      /// List of external documents.
-    bool                mbCreated;          /// true = Calc sheets already created.
-};
-
-// ============================================================================
-// *** Implementation ***
-// ============================================================================
-
-// Excel sheet indexes ========================================================
-
-// original Excel sheet names -------------------------------------------------
-
-void XclImpTabInfo::AppendXclTabName( const String& rXclTabName, SCTAB nScTab )
-{
-    maTabNames[ rXclTabName ] = nScTab;
-}
-
-void XclImpTabInfo::InsertScTab( SCTAB nScTab )
-{
-    for( XclTabNameMap::iterator aIt = maTabNames.begin(), aEnd = maTabNames.end(); aIt != aEnd; ++aIt )
-        if( aIt->second >= nScTab )
-            ++aIt->second;
-}
-
-SCTAB XclImpTabInfo::GetScTabFromXclName( const String& rXclTabName ) const
-{
-    XclTabNameMap::const_iterator aIt = maTabNames.find( rXclTabName );
-    return (aIt != maTabNames.end()) ? aIt->second : SCTAB_INVALID;
-}
-
-// record creation order - TABID record ---------------------------------------
-
-void XclImpTabInfo::ReadTabid( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( rStrm.GetRoot().GetBiff() == EXC_BIFF8 );
-    if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
-    {
-        rStrm.EnableDecryption();
-        sal_Size nReadCount = rStrm.GetRecLeft() / 2;
-        DBG_ASSERT( nReadCount <= 0xFFFF, "XclImpTabInfo::ReadTabid - record too long" );
-        maTabIdVec.clear();
-        maTabIdVec.reserve( nReadCount );
-        for( sal_Size nIndex = 0; rStrm.IsValid() && (nIndex < nReadCount); ++nIndex )
-            // #93471# zero index is not allowed in BIFF8, but it seems that it occurs in real life
-            maTabIdVec.push_back( rStrm.ReaduInt16() );
-    }
-}
-
-sal_uInt16 XclImpTabInfo::GetCurrentIndex( sal_uInt16 nCreatedId, sal_uInt16 nMaxTabId ) const
-{
-    sal_uInt16 nReturn = 0;
-    for( ScfUInt16Vec::const_iterator aIt = maTabIdVec.begin(), aEnd = maTabIdVec.end(); aIt != aEnd; ++aIt )
-    {
-        sal_uInt16 nValue = *aIt;
-        if( nValue == nCreatedId )
-            return nReturn;
-        if( nValue <= nMaxTabId )
-            ++nReturn;
-    }
-    return 0;
-}
-
-// External names =============================================================
-
-XclImpExtName::XclImpExtName( const XclImpSupbook& rSupbook, XclImpStream& rStrm, XclSupbookType eSubType, ExcelToSc* pFormulaConv )
-{
-    sal_uInt16 nFlags;
-    sal_uInt8 nLen;
-
-    rStrm >> nFlags >> mnStorageId >> nLen ;
-    maName = rStrm.ReadUniString( nLen );
-    if( ::get_flag( nFlags, EXC_EXTN_BUILTIN ) || !::get_flag( nFlags, EXC_EXTN_OLE_OR_DDE ) )
-    {
-        if( eSubType == EXC_SBTYPE_ADDIN )
-        {
-            meType = xlExtAddIn;
-            maName = rStrm.GetRoot().GetScAddInName( maName );
-        }
-        else if ( (eSubType == EXC_SBTYPE_EUROTOOL) &&
-                maName.EqualsIgnoreCaseAscii( "EUROCONVERT" ) )
-            meType = xlExtEuroConvert;
-        else
-        {
-            meType = xlExtName;
-            ScfTools::ConvertToScDefinedName( maName );
-        }
-    }
-    else
-    {
-        meType = ::get_flagvalue( nFlags, EXC_EXTN_OLE, xlExtOLE, xlExtDDE );
-    }
-
-    if( (meType == xlExtDDE) && (rStrm.GetRecLeft() > 1) )
-        mxDdeMatrix.reset( new XclImpCachedMatrix( rStrm ) );
-
-    if (meType == xlExtName)
-    {
-        // TODO: For now, only global external names are supported.  In future
-        // we should extend this to supporting per-sheet external names.
-        if (mnStorageId == 0)
-        {
-            if (pFormulaConv)
-            {
-                const ScTokenArray* pArray = NULL;
-                sal_uInt16 nFmlaLen;
-                rStrm >> nFmlaLen;
-                vector<String> aTabNames;
-                sal_uInt16 nCount = rSupbook.GetTabCount();
-                aTabNames.reserve(nCount);
-                for (sal_uInt16 i = 0; i < nCount; ++i)
-                    aTabNames.push_back(rSupbook.GetTabName(i));
-
-                pFormulaConv->ConvertExternName(pArray, rStrm, nFmlaLen, rSupbook.GetXclUrl(), aTabNames);
-                if (pArray)
-                    mxArray.reset(pArray->Clone());
-            }
-        }
-    }
-}
-
-XclImpExtName::~XclImpExtName()
-{
-}
-
-void XclImpExtName::CreateDdeData( ScDocument& rDoc, const String& rApplic, const String& rTopic ) const
-{
-    ScMatrixRef xResults;
-    if( mxDdeMatrix.get() )
-        xResults = mxDdeMatrix->CreateScMatrix();
-    rDoc.CreateDdeLink( rApplic, rTopic, maName, SC_DDE_DEFAULT, xResults );
-}
-
-void XclImpExtName::CreateExtNameData( ScDocument& rDoc, sal_uInt16 nFileId ) const
-{
-    if (!mxArray.get())
-        return;
-
-    ScExternalRefManager* pRefMgr = rDoc.GetExternalRefManager();
-    pRefMgr->storeRangeNameTokens(nFileId, maName, *mxArray);
-}
-
-bool XclImpExtName::HasFormulaTokens() const
-{
-    return (mxArray.get() != NULL);
-}
-
-// Cached external cells ======================================================
-
-XclImpCrn::XclImpCrn( XclImpStream& rStrm, const XclAddress& rXclPos ) :
-    XclImpCachedValue( rStrm ),
-    maXclPos( rXclPos )
-{
-}
-
-const XclAddress& XclImpCrn::GetAddress() const
-{
-    return maXclPos;
-}
-
-// Sheet in an external document ==============================================
-
-XclImpSupbookTab::XclImpSupbookTab( const String& rTabName ) :
-    maTabName( rTabName ),
-    mnScTab( SCTAB_INVALID )
-{
-}
-
-XclImpSupbookTab::~XclImpSupbookTab()
-{
-}
-
-void XclImpSupbookTab::ReadCrn( XclImpStream& rStrm, const XclAddress& rXclPos )
-{
-    maCrnList.Append( new XclImpCrn( rStrm, rXclPos ) );
-}
-
-void XclImpSupbookTab::LoadCachedValues(ScExternalRefCache::TableTypeRef pCacheTable)
-{
-    if (maCrnList.Empty())
-        return;
-
-    for (XclImpCrn* p = maCrnList.First(); p; p = maCrnList.Next())
-    {
-        const XclAddress& rAddr = p->GetAddress();
-        switch (p->GetType())
-        {
-            case EXC_CACHEDVAL_BOOL:
-            break;
-            case EXC_CACHEDVAL_DOUBLE:
-            {
-                double f = p->GetValue();
-                ScExternalRefCache::TokenRef pToken(new formula::FormulaDoubleToken(f));
-                pCacheTable->setCell(rAddr.mnCol, rAddr.mnRow, pToken);
-            }
-            break;
-            case EXC_CACHEDVAL_EMPTY:
-            break;
-            case EXC_CACHEDVAL_ERROR:
-            break;
-            case EXC_CACHEDVAL_STRING:
-            {
-                const String& rStr = p->GetString();
-                ScExternalRefCache::TokenRef pToken(new formula::FormulaStringToken(rStr));
-                pCacheTable->setCell(rAddr.mnCol, rAddr.mnRow, pToken);
-            }
-            break;
-            default:
-                ;
-        }
-    }
-}
-
-// External document (SUPBOOK) ================================================
-
-XclImpSupbook::XclImpSupbook( XclImpStream& rStrm ) :
-    XclImpRoot( rStrm.GetRoot() ),
-    meType( EXC_SBTYPE_UNKNOWN ),
-    mnSBTab( EXC_TAB_DELETED )
-{
-    sal_uInt16 nSBTabCnt;
-    rStrm >> nSBTabCnt;
-
-    if( rStrm.GetRecLeft() == 2 )
-    {
-        switch( rStrm.ReaduInt16() )
-        {
-            case EXC_SUPB_SELF:     meType = EXC_SBTYPE_SELF;   break;
-            case EXC_SUPB_ADDIN:    meType = EXC_SBTYPE_ADDIN;  break;
-            default:    DBG_ERRORFILE( "XclImpSupbook::XclImpSupbook - unknown special SUPBOOK type" );
-        }
-        return;
-    }
-
-    String aEncUrl( rStrm.ReadUniString() );
-    bool bSelf = false;
-    XclImpUrlHelper::DecodeUrl( maXclUrl, bSelf, GetRoot(), aEncUrl );
-
-    if( maXclUrl.EqualsIgnoreCaseAscii( "\010EUROTOOL.XLA" ) )
-    {
-        meType = EXC_SBTYPE_EUROTOOL;
-        maSupbTabList.Append( new XclImpSupbookTab( maXclUrl ) );
-    }
-    else if( nSBTabCnt )
-    {
-        meType = EXC_SBTYPE_EXTERN;
-        for( sal_uInt16 nSBTab = 0; nSBTab < nSBTabCnt; ++nSBTab )
-        {
-            String aTabName( rStrm.ReadUniString() );
-            maSupbTabList.Append( new XclImpSupbookTab( aTabName ) );
-        }
-    }
-    else
-    {
-        meType = EXC_SBTYPE_SPECIAL;
-        // create dummy list entry
-        maSupbTabList.Append( new XclImpSupbookTab( maXclUrl ) );
-    }
-}
-
-void XclImpSupbook::ReadXct( XclImpStream& rStrm )
-{
-    rStrm.Ignore( 2 );
-    rStrm >> mnSBTab;
-}
-
-void XclImpSupbook::ReadCrn( XclImpStream& rStrm )
-{
-    if( XclImpSupbookTab* pSBTab = maSupbTabList.GetObject( mnSBTab ) )
-    {
-        sal_uInt8 nXclColLast, nXclColFirst;
-        sal_uInt16 nXclRow;
-        rStrm >> nXclColLast >> nXclColFirst >> nXclRow;
-
-        for( sal_uInt8 nXclCol = nXclColFirst; (nXclCol <= nXclColLast) && (rStrm.GetRecLeft() > 1); ++nXclCol )
-            pSBTab->ReadCrn( rStrm, XclAddress( nXclCol, nXclRow ) );
-    }
-}
-
-void XclImpSupbook::ReadExternname( XclImpStream& rStrm, ExcelToSc* pFormulaConv )
-{
-    maExtNameList.Append( new XclImpExtName( *this, rStrm, meType, pFormulaConv ) );
-}
-
-const XclImpExtName* XclImpSupbook::GetExternName( sal_uInt16 nXclIndex ) const
-{
-    DBG_ASSERT( nXclIndex > 0, "XclImpSupbook::GetExternName - index must be >0" );
-    return (meType == EXC_SBTYPE_SELF) ? 0 : maExtNameList.GetObject( nXclIndex - 1 );
-}
-
-bool XclImpSupbook::GetLinkData( String& rApplic, String& rTopic ) const
-{
-    return (meType == EXC_SBTYPE_SPECIAL) && XclImpUrlHelper::DecodeLink( rApplic, rTopic, maXclUrl );
-}
-
-const String& XclImpSupbook::GetMacroName( sal_uInt16 nXclNameIdx ) const
-{
-    DBG_ASSERT( nXclNameIdx > 0, "XclImpSupbook::GetMacroName - index must be >0" );
-    const XclImpName* pName = (meType == EXC_SBTYPE_SELF) ? GetNameManager().GetName( nXclNameIdx ) : 0;
-    return (pName && pName->IsVBName()) ? pName->GetScName() : EMPTY_STRING;
-}
-
-const String& XclImpSupbook::GetTabName( sal_uInt16 nXtiTab ) const
-{
-    if (maSupbTabList.Empty())
-        return EMPTY_STRING;
-
-    sal_uInt16 i = 0;
-    for (XclImpSupbookTab* p = maSupbTabList.First(); p; p = maSupbTabList.Next(), ++i)
-    {
-        if (i == nXtiTab)
-            return p->GetTabName();
-    }
-
-    return EMPTY_STRING;
-}
-
-sal_uInt16 XclImpSupbook::GetTabCount() const
-{
-    return ulimit_cast<sal_uInt16>(maSupbTabList.Count());
-}
-
-void XclImpSupbook::LoadCachedValues()
-{
-    if (meType != EXC_SBTYPE_EXTERN || GetExtDocOptions().GetDocSettings().mnLinkCnt > 0 || !GetDocShell())
-        return;
-
-    String aAbsUrl( ScGlobal::GetAbsDocName(maXclUrl, GetDocShell()) );
-
-    ScExternalRefManager* pRefMgr = GetRoot().GetDoc().GetExternalRefManager();
-    sal_uInt16 nFileId = pRefMgr->getExternalFileId(aAbsUrl);
-
-    sal_uInt16 nCount = static_cast< sal_uInt16 >( maSupbTabList.Count() );
-    for (sal_uInt16 i = 0; i < nCount; ++i)
-    {
-        XclImpSupbookTab* pTab = maSupbTabList.GetObject(i);
-        if (!pTab)
-            return;
-
-        const String& rTabName = pTab->GetTabName();
-        ScExternalRefCache::TableTypeRef pCacheTable = pRefMgr->getCacheTable(nFileId, rTabName, true);
-        pTab->LoadCachedValues(pCacheTable);
-    }
-}
-
-// Import link manager ========================================================
-
-XclImpLinkManagerImpl::XclImpLinkManagerImpl( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mbCreated( false )
-{
-}
-
-void XclImpLinkManagerImpl::ReadExternsheet( XclImpStream& rStrm )
-{
-    sal_uInt16 nXtiCount;
-    rStrm >> nXtiCount;
-    DBG_ASSERT( static_cast< sal_Size >( nXtiCount * 6 ) == rStrm.GetRecLeft(), "XclImpLinkManagerImpl::ReadExternsheet - invalid count" );
-    nXtiCount = static_cast< sal_uInt16 >( ::std::min< sal_Size >( nXtiCount, rStrm.GetRecLeft() / 6 ) );
-
-    /*  #i104057# A weird external XLS generator writes multiple EXTERNSHEET
-        records instead of only one as expected. Surprisingly, Excel seems to
-        insert the entries of the second record before the entries of the first
-        record. */
-    XclImpXtiVector aNewEntries( nXtiCount );
-    for( XclImpXtiVector::iterator aIt = aNewEntries.begin(), aEnd = aNewEntries.end(); rStrm.IsValid() && (aIt != aEnd); ++aIt )
-        rStrm >> *aIt;
-    maXtiList.insert( maXtiList.begin(), aNewEntries.begin(), aNewEntries.end() );
-
-    LoadCachedValues();
-}
-
-void XclImpLinkManagerImpl::ReadSupbook( XclImpStream& rStrm )
-{
-    maSupbookList.Append( new XclImpSupbook( rStrm ) );
-}
-
-void XclImpLinkManagerImpl::ReadXct( XclImpStream& rStrm )
-{
-    if( XclImpSupbook* pSupbook = maSupbookList.Last() )
-        pSupbook->ReadXct( rStrm );
-}
-
-void XclImpLinkManagerImpl::ReadCrn( XclImpStream& rStrm )
-{
-    if( XclImpSupbook* pSupbook = maSupbookList.Last() )
-        pSupbook->ReadCrn( rStrm );
-}
-
-void XclImpLinkManagerImpl::ReadExternname( XclImpStream& rStrm, ExcelToSc* pFormulaConv )
-{
-    if( XclImpSupbook* pSupbook = maSupbookList.Last() )
-        pSupbook->ReadExternname( rStrm, pFormulaConv );
-}
-
-bool XclImpLinkManagerImpl::IsSelfRef( sal_uInt16 nXtiIndex ) const
-{
-    const XclImpSupbook* pSupbook = GetSupbook( nXtiIndex );
-    return pSupbook && (pSupbook->GetType() == EXC_SBTYPE_SELF);
-}
-
-bool XclImpLinkManagerImpl::GetScTabRange(
-        SCTAB& rnFirstScTab, SCTAB& rnLastScTab, sal_uInt16 nXtiIndex ) const
-{
-    if( const XclImpXti* pXti = GetXti( nXtiIndex ) )
-    {
-        if (maSupbookList.GetObject(pXti->mnSupbook))
-        {
-            rnFirstScTab = pXti->mnSBTabFirst;
-            rnLastScTab  = pXti->mnSBTabLast;
-            return true;
-        }
-    }
-    return false;
-}
-
-const XclImpExtName* XclImpLinkManagerImpl::GetExternName( sal_uInt16 nXtiIndex, sal_uInt16 nExtName ) const
-{
-    const XclImpSupbook* pSupbook = GetSupbook( nXtiIndex );
-    return pSupbook ? pSupbook->GetExternName( nExtName ) : 0;
-}
-
-const String* XclImpLinkManagerImpl::GetSupbookUrl( sal_uInt16 nXtiIndex ) const
-{
-    const XclImpSupbook* p = GetSupbook( nXtiIndex );
-    if (!p)
-        return NULL;
-    return &p->GetXclUrl();
-}
-
-const String& XclImpLinkManagerImpl::GetSupbookTabName( sal_uInt16 nXti, sal_uInt16 nXtiTab ) const
-{
-    const XclImpSupbook* p = GetSupbook(nXti);
-    return p ? p->GetTabName(nXtiTab) : EMPTY_STRING;
-}
-
-bool XclImpLinkManagerImpl::GetLinkData( String& rApplic, String& rTopic, sal_uInt16 nXtiIndex ) const
-{
-    const XclImpSupbook* pSupbook = GetSupbook( nXtiIndex );
-    return pSupbook && pSupbook->GetLinkData( rApplic, rTopic );
-}
-
-const String& XclImpLinkManagerImpl::GetMacroName( sal_uInt16 nExtSheet, sal_uInt16 nExtName ) const
-{
-    const XclImpSupbook* pSupbook = GetSupbook( nExtSheet );
-    return pSupbook ? pSupbook->GetMacroName( nExtName ) : EMPTY_STRING;
-}
-
-const XclImpXti* XclImpLinkManagerImpl::GetXti( sal_uInt16 nXtiIndex ) const
-{
-    return (nXtiIndex < maXtiList.size()) ? &maXtiList[ nXtiIndex ] : 0;
-}
-
-const XclImpSupbook* XclImpLinkManagerImpl::GetSupbook( sal_uInt16 nXtiIndex ) const
-{
-    const XclImpXti* pXti = GetXti( nXtiIndex );
-    return pXti ? maSupbookList.GetObject( pXti->mnSupbook ) : 0;
-}
-
-//UNUSED2009-05 const XclImpSupbook* XclImpLinkManagerImpl::GetSupbook( const String& rUrl ) const
-//UNUSED2009-05 {
-//UNUSED2009-05     for( const XclImpSupbook* pSupbook = maSupbookList.First(); pSupbook; pSupbook = maSupbookList.Next() )
-//UNUSED2009-05         if( pSupbook->GetXclUrl() == rUrl )
-//UNUSED2009-05             return pSupbook;
-//UNUSED2009-05     return 0;
-//UNUSED2009-05 }
-
-void XclImpLinkManagerImpl::LoadCachedValues()
-{
-    // Read all CRN records which can be accessed via XclImpSupbook, and store
-    // the cached values to the external reference manager.
-
-    sal_uInt32 nCount = maSupbookList.Count();
-    for (sal_uInt16 nSupbook = 0; nSupbook < nCount; ++nSupbook)
-    {
-        XclImpSupbook* pSupbook = maSupbookList.GetObject(nSupbook);
-        pSupbook->LoadCachedValues();
-    }
-}
-
-//UNUSED2009-05 bool XclImpLinkManagerImpl::FindNextTabRange(
-//UNUSED2009-05         sal_uInt16& rnSBTabFirst, sal_uInt16& rnSBTabLast,
-//UNUSED2009-05         sal_uInt16 nSupbook, sal_uInt16 nSBTabStart ) const
-//UNUSED2009-05 {
-//UNUSED2009-05     rnSBTabFirst = rnSBTabLast = EXC_NOTAB;
-//UNUSED2009-05     for( const XclImpXti* pXti = maXtiList.First(); pXti; pXti = maXtiList.Next() )
-//UNUSED2009-05     {
-//UNUSED2009-05         if( (nSupbook == pXti->mnSupbook) && (nSBTabStart <= pXti->mnSBTabLast) && (pXti->mnSBTabFirst < rnSBTabFirst) )
-//UNUSED2009-05         {
-//UNUSED2009-05             rnSBTabFirst = ::std::max( nSBTabStart, pXti->mnSBTabFirst );
-//UNUSED2009-05             rnSBTabLast = pXti->mnSBTabLast;
-//UNUSED2009-05         }
-//UNUSED2009-05     }
-//UNUSED2009-05     return rnSBTabFirst != EXC_NOTAB;
-//UNUSED2009-05 }
-
-// ============================================================================
-
-XclImpLinkManager::XclImpLinkManager( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mxImpl( new XclImpLinkManagerImpl( rRoot ) )
-{
-}
-
-XclImpLinkManager::~XclImpLinkManager()
-{
-}
-
-void XclImpLinkManager::ReadExternsheet( XclImpStream& rStrm )
-{
-    mxImpl->ReadExternsheet( rStrm );
-}
-
-void XclImpLinkManager::ReadSupbook( XclImpStream& rStrm )
-{
-    mxImpl->ReadSupbook( rStrm );
-}
-
-void XclImpLinkManager::ReadXct( XclImpStream& rStrm )
-{
-    mxImpl->ReadXct( rStrm );
-}
-
-void XclImpLinkManager::ReadCrn( XclImpStream& rStrm )
-{
-    mxImpl->ReadCrn( rStrm );
-}
-
-void XclImpLinkManager::ReadExternname( XclImpStream& rStrm, ExcelToSc* pFormulaConv )
-{
-    mxImpl->ReadExternname( rStrm, pFormulaConv );
-}
-
-bool XclImpLinkManager::IsSelfRef( sal_uInt16 nXtiIndex ) const
-{
-    return mxImpl->IsSelfRef( nXtiIndex );
-}
-
-bool XclImpLinkManager::GetScTabRange(
-        SCTAB& rnFirstScTab, SCTAB& rnLastScTab, sal_uInt16 nXtiIndex ) const
-{
-    return mxImpl->GetScTabRange( rnFirstScTab, rnLastScTab, nXtiIndex );
-}
-
-const XclImpExtName* XclImpLinkManager::GetExternName( sal_uInt16 nXtiIndex, sal_uInt16 nExtName ) const
-{
-    return mxImpl->GetExternName( nXtiIndex, nExtName );
-}
-
-const String* XclImpLinkManager::GetSupbookUrl( sal_uInt16 nXtiIndex ) const
-{
-    return mxImpl->GetSupbookUrl(nXtiIndex);
-}
-
-const String& XclImpLinkManager::GetSupbookTabName( sal_uInt16 nXti,  sal_uInt16 nXtiTab ) const
-{
-    return mxImpl->GetSupbookTabName(nXti, nXtiTab);
-}
-
-bool XclImpLinkManager::GetLinkData( String& rApplic, String& rTopic, sal_uInt16 nXtiIndex ) const
-{
-    return mxImpl->GetLinkData( rApplic, rTopic, nXtiIndex );
-}
-
-const String& XclImpLinkManager::GetMacroName( sal_uInt16 nExtSheet, sal_uInt16 nExtName ) const
-{
-    return mxImpl->GetMacroName( nExtSheet, nExtName );
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xiname.cxx sc/source/filter/xlsx/xlsx-xiname.cxx
deleted file mode 100644
index 8f52b17..0000000
--- sc/source/filter/xlsx/xlsx-xiname.cxx
+++ /dev/null
@@ -1,286 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xiname.cxx,v $
- * $Revision: 1.10 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xiname.hxx"
-#include "rangenam.hxx"
-#include "xistream.hxx"
-
-// for formula compiler
-#include "excform.hxx"
-// for filter manager
-#include "excimp8.hxx"
-#include "scextopt.hxx"
-#include "document.hxx"
-// ============================================================================
-// *** Implementation ***
-// ============================================================================
-
-XclImpName::XclImpName( XclImpStream& rStrm, sal_uInt16 nXclNameIdx ) :
-    XclImpRoot( rStrm.GetRoot() ),
-    mpScData( 0 ),
-    mcBuiltIn( EXC_BUILTIN_UNKNOWN ),
-    mnScTab( SCTAB_MAX ),
-    mbVBName( false )
-{
-    ExcelToSc& rFmlaConv = GetOldFmlaConverter();
-    ScRangeName& rRangeNames = GetNamedRanges();
-
-    // 1) *** read data from stream *** ---------------------------------------
-
-    sal_uInt16 nFlags = 0, nFmlaSize = 0, nExtSheet = EXC_NAME_GLOBAL, nXclTab = EXC_NAME_GLOBAL;
-    sal_uInt8 nNameLen = 0, nShortCut;
-
-    switch( GetBiff() )
-    {
-        case EXC_BIFF2:
-        {
-            sal_uInt8 nFlagsBiff2;
-            rStrm >> nFlagsBiff2;
-            rStrm.Ignore( 1 );
-            rStrm >> nShortCut >> nNameLen;
-            nFmlaSize = rStrm.ReaduInt8();
-            ::set_flag( nFlags, EXC_NAME_FUNC, ::get_flag( nFlagsBiff2, EXC_NAME2_FUNC ) );
-        }
-        break;
-
-        case EXC_BIFF3:
-        case EXC_BIFF4:
-        {
-            rStrm >> nFlags >> nShortCut >> nNameLen >> nFmlaSize;
-        }
-        break;
-
-        case EXC_BIFF5:
-        case EXC_BIFF8:
-        {
-            rStrm >> nFlags >> nShortCut >> nNameLen >> nFmlaSize >> nExtSheet >> nXclTab;
-            rStrm.Ignore( 4 );
-        }
-        break;
-
-        default: DBG_ERROR_BIFF();
-    }
-
-    if( GetBiff() <= EXC_BIFF5 )
-        maXclName = rStrm.ReadRawByteString( nNameLen );
-    else
-        maXclName = rStrm.ReadUniString( nNameLen );
-
-    // 2) *** convert sheet index and name *** --------------------------------
-
-    // Visual Basic procedure
-    mbVBName = ::get_flag( nFlags, EXC_NAME_VB );
-
-    // get built-in name, or convert characters invalid in Calc
-    bool bBuiltIn = ::get_flag( nFlags, EXC_NAME_BUILTIN );
-
-    // special case for BIFF5 filter range - name appears as plain text without built-in flag
-    if( (GetBiff() == EXC_BIFF5) && (maXclName == XclTools::GetXclBuiltInDefName( EXC_BUILTIN_FILTERDATABASE )) )
-    {
-        bBuiltIn = true;
-        maXclName.Assign( EXC_BUILTIN_FILTERDATABASE );
-    }
-
-    // convert Excel name to Calc name
-    if( mbVBName )
-    {
-        // VB macro name
-        maScName = maXclName;
-    }
-    else if( bBuiltIn )
-    {
-        // built-in name
-        if( maXclName.Len() )
-            mcBuiltIn = maXclName.GetChar( 0 );
-        if( mcBuiltIn == '?' )      // NUL character is imported as '?'
-            mcBuiltIn = '\0';
-        maScName = XclTools::GetBuiltInDefName( mcBuiltIn );
-    }
-    else
-    {
-        // any other name
-        maScName = maXclName;
-        ScfTools::ConvertToScDefinedName( maScName );
-    }
-    rtl::OUString aRealOrigName = maScName;
-
-    // add index for local names
-    if( nXclTab != EXC_NAME_GLOBAL )
-    {
-        sal_uInt16 nUsedTab = (GetBiff() == EXC_BIFF8) ? nXclTab : nExtSheet;
-        maScName.Append( '_' ).Append( String::CreateFromInt32( nUsedTab ) );
-        // TODO: may not work for BIFF5, handle skipped sheets (all BIFF)
-        mnScTab = static_cast< SCTAB >( nUsedTab - 1 );
-    }
-
-    // find an unused name
-    String aOrigName( maScName );
-    sal_Int32 nCounter = 0;
-    USHORT nDummy;
-    while( rRangeNames.SearchName( maScName, nDummy ) )
-        maScName.Assign( aOrigName ).Append( ' ' ).Append( String::CreateFromInt32( ++nCounter ) );
-
-    // 3) *** convert the name definition formula *** -------------------------
-
-    rFmlaConv.Reset();
-    const ScTokenArray* pTokArr = 0; // pointer to token array, owned by rFmlaConv
-    RangeType nNameType = RT_NAME;
-
-    if( ::get_flag( nFlags, EXC_NAME_BIG ) )
-    {
-        // special, unsupported name
-        rFmlaConv.GetDummy( pTokArr );
-    }
-    else if( bBuiltIn )
-    {
-        SCsTAB const nLocalTab = (nXclTab == EXC_NAME_GLOBAL) ? SCTAB_MAX : (nXclTab - 1);
-
-        // --- print ranges or title ranges ---
-        rStrm.PushPosition();
-        switch( mcBuiltIn )
-        {
-            case EXC_BUILTIN_PRINTAREA:
-                if( rFmlaConv.Convert( GetPrintAreaBuffer(), rStrm, nFmlaSize, nLocalTab, FT_RangeName ) == ConvOK )
-                    nNameType |= RT_PRINTAREA;
-            break;
-            case EXC_BUILTIN_PRINTTITLES:
-                if( rFmlaConv.Convert( GetTitleAreaBuffer(), rStrm, nFmlaSize, nLocalTab, FT_RangeName ) == ConvOK )
-                    nNameType |= RT_COLHEADER | RT_ROWHEADER;
-            break;
-        }
-        rStrm.PopPosition();
-
-        // --- name formula ---
-        // JEG : double check this.  It is clearly false for normal names
-        //  but some of the builtins (sheettitle?) might be able to handle arrays
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize, false, FT_RangeName );
-
-        // --- auto or advanced filter ---
-        if( (GetBiff() == EXC_BIFF8) && pTokArr && bBuiltIn )
-        {
-            ScRange aRange;
-            if( pTokArr->IsReference( aRange ) )
-            {
-                switch( mcBuiltIn )
-                {
-                    case EXC_BUILTIN_FILTERDATABASE:
-                        GetFilterManager().Insert( &GetOldRoot(), aRange, maScName );
-                    break;
-                    case EXC_BUILTIN_CRITERIA:
-                        GetFilterManager().AddAdvancedRange( aRange );
-                        nNameType |= RT_CRITERIA;
-                    break;
-                    case EXC_BUILTIN_EXTRACT:
-                        if( pTokArr->IsValidReference( aRange ) )
-                            GetFilterManager().AddExtractPos( aRange );
-                    break;
-                }
-            }
-        }
-    }
-    else if( nFmlaSize > 0 )
-    {
-        // regular defined name
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize, true, FT_RangeName );
-    }
-
-    // 4) *** create a defined name in the Calc document *** ------------------
-
-    if( pTokArr && (bBuiltIn || !::get_flag( nFlags, EXC_NAME_HIDDEN )) && !mbVBName )
-    {
-        // create the Calc name data
-        ScRangeData* pData = new ScRangeData( GetDocPtr(), maScName, *pTokArr, ScAddress(), nNameType );
-        pData->GuessPosition();             // calculate base position for relative refs
-        pData->SetIndex( nXclNameIdx );     // used as unique identifier in formulas
-        rRangeNames.Insert( pData );        // takes ownership of pData
-        if( nXclTab != EXC_NAME_GLOBAL )
-        {
-            if (GetBiff() == EXC_BIFF8)
-            {
-                ScRange aRange;
-                // discard deleted ranges ( for the moment at least )
-                if ( pData->IsValidReference( aRange ) )
-                {
-                    ScExtTabSettings& rTabSett = GetExtDocOptions().GetOrCreateTabSettings( nXclTab );
-                    // create a mapping between the unmodified localname to
-                    // the name in the global name container for named ranges
-                    OSL_TRACE(" mapping local name to global name for tab %d which exists? %s", nXclTab, GetDoc().HasTable( mnScTab ) ? "true" : "false" );
-                    SCTAB nTab( static_cast< SCTAB >( mnScTab ) );
-                    NameToNameMap* pMap = GetDoc().GetLocalNameMap( nTab );
-                    if ( pMap )
-                       (*pMap)[ aRealOrigName ] = maScName;
-                }
-            }
-        }
-        mpScData = pData;                   // cache for later use
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpNameManager::XclImpNameManager( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpNameManager::ReadName( XclImpStream& rStrm )
-{
-    ULONG nCount = maNameList.Count();
-    if( nCount < 0xFFFF )
-        maNameList.Append( new XclImpName( rStrm, static_cast< sal_uInt16 >( nCount + 1 ) ) );
-}
-
-const XclImpName* XclImpNameManager::FindName( const String& rXclName, SCTAB nScTab ) const
-{
-    const XclImpName* pGlobalName = 0;   // a found global name
-    const XclImpName* pLocalName = 0;    // a found local name
-    for( const XclImpName* pName = maNameList.First(); pName && !pLocalName; pName = maNameList.Next() )
-    {
-        if( pName->GetXclName() == rXclName )
-        {
-            if( pName->GetScTab() == nScTab )
-                pLocalName = pName;
-            else if( pName->IsGlobal() )
-                pGlobalName = pName;
-        }
-    }
-    return pLocalName ? pLocalName : pGlobalName;
-}
-
-const XclImpName* XclImpNameManager::GetName( sal_uInt16 nXclNameIdx ) const
-{
-    DBG_ASSERT( nXclNameIdx > 0, "XclImpNameManager::GetName - index must be >0" );
-    return maNameList.GetObject( nXclNameIdx - 1 );
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xipage.cxx sc/source/filter/xlsx/xlsx-xipage.cxx
deleted file mode 100644
index cb1aba2..0000000
--- sc/source/filter/xlsx/xlsx-xipage.cxx
+++ /dev/null
@@ -1,393 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xipage.cxx,v $
- * $Revision: 1.18.90.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xipage.hxx"
-#include <svtools/itemset.hxx>
-#include <vcl/graph.hxx>
-#include "scitems.hxx"
-#include <svtools/eitem.hxx>
-#include <svtools/intitem.hxx>
-#include <svx/pageitem.hxx>
-#include <svx/sizeitem.hxx>
-#include <svx/lrspitem.hxx>
-#include <svx/ulspitem.hxx>
-#include <svx/brshitem.hxx>
-#include "document.hxx"
-#include "stlsheet.hxx"
-#include "attrib.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xiescher.hxx"
-
-// Page settings ==============================================================
-
-XclImpPageSettings::XclImpPageSettings( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-    Initialize();
-}
-
-void XclImpPageSettings::Initialize()
-{
-    maData.SetDefaults();
-    mbValidPaper = false;
-}
-
-void XclImpPageSettings::ReadSetup( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() >= EXC_BIFF4 );
-    if( GetBiff() < EXC_BIFF4 )
-        return;
-
-    // BIFF4 - BIFF8
-    sal_uInt16 nFlags;
-    rStrm   >> maData.mnPaperSize >> maData.mnScaling >> maData.mnStartPage
-            >> maData.mnFitToWidth >> maData.mnFitToHeight >> nFlags;
-
-    mbValidPaper = maData.mbValid = !::get_flag( nFlags, EXC_SETUP_INVALID );
-    maData.mbPrintInRows = ::get_flag( nFlags, EXC_SETUP_INROWS );
-    maData.mbPortrait = ::get_flag( nFlags, EXC_SETUP_PORTRAIT );
-    maData.mbBlackWhite = ::get_flag( nFlags, EXC_SETUP_BLACKWHITE );
-    maData.mbManualStart = true;
-
-    // new in BIFF5 - BIFF8
-    if( GetBiff() >= EXC_BIFF5 )
-    {
-        rStrm   >> maData.mnHorPrintRes >> maData.mnVerPrintRes
-                >> maData.mfHeaderMargin >> maData.mfFooterMargin >> maData.mnCopies;
-
-        maData.mbDraftQuality = ::get_flag( nFlags, EXC_SETUP_DRAFT );
-        maData.mbPrintNotes = ::get_flag( nFlags, EXC_SETUP_PRINTNOTES );
-        maData.mbManualStart = ::get_flag( nFlags, EXC_SETUP_STARTPAGE );
-    }
-}
-
-void XclImpPageSettings::ReadMargin( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_LEFTMARGIN:     rStrm >> maData.mfLeftMargin;   break;
-        case EXC_ID_RIGHTMARGIN:    rStrm >> maData.mfRightMargin;  break;
-        case EXC_ID_TOPMARGIN:      rStrm >> maData.mfTopMargin;    break;
-        case EXC_ID_BOTTOMMARGIN:   rStrm >> maData.mfBottomMargin; break;
-        default:    DBG_ERRORFILE( "XclImpPageSettings::ReadMargin - unknown record" );
-    }
-}
-
-void XclImpPageSettings::ReadCenter( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() >= EXC_BIFF3 );  // read it anyway
-    bool bCenter = (rStrm.ReaduInt16() != 0);
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_HCENTER:    maData.mbHorCenter = bCenter;   break;
-        case EXC_ID_VCENTER:    maData.mbVerCenter = bCenter;   break;
-        default:    DBG_ERRORFILE( "XclImpPageSettings::ReadCenter - unknown record" );
-    }
-}
-
-void XclImpPageSettings::ReadHeaderFooter( XclImpStream& rStrm )
-{
-    String aString;
-    if( rStrm.GetRecLeft() )
-        aString = (GetBiff() <= EXC_BIFF5) ? rStrm.ReadByteString( false ) : rStrm.ReadUniString();
-
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_HEADER:     maData.maHeader = aString;  break;
-        case EXC_ID_FOOTER:     maData.maFooter = aString;  break;
-        default:    DBG_ERRORFILE( "XclImpPageSettings::ReadHeaderFooter - unknown record" );
-    }
-}
-
-void XclImpPageSettings::ReadPageBreaks( XclImpStream& rStrm )
-{
-    ScfUInt16Vec* pVec = 0;
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_HORPAGEBREAKS:  pVec = &maData.maHorPageBreaks;     break;
-        case EXC_ID_VERPAGEBREAKS:  pVec = &maData.maVerPageBreaks;     break;
-        default:    DBG_ERRORFILE( "XclImpPageSettings::ReadPageBreaks - unknown record" );
-    }
-
-    if( pVec )
-    {
-        bool bIgnore = GetBiff() == EXC_BIFF8;  // ignore start/end columns or rows in BIFF8
-
-        sal_uInt16 nCount, nBreak;
-        rStrm >> nCount;
-        pVec->clear();
-        pVec->reserve( nCount );
-
-        while( nCount-- )
-        {
-            rStrm >> nBreak;
-            if( nBreak )
-                pVec->push_back( nBreak );
-            if( bIgnore )
-                rStrm.Ignore( 4 );
-        }
-    }
-}
-
-void XclImpPageSettings::ReadPrintHeaders( XclImpStream& rStrm )
-{
-    maData.mbPrintHeadings = (rStrm.ReaduInt16() != 0);
-}
-
-void XclImpPageSettings::ReadPrintGridLines( XclImpStream& rStrm )
-{
-    maData.mbPrintGrid = (rStrm.ReaduInt16() != 0);
-}
-
-void XclImpPageSettings::ReadImgData( XclImpStream& rStrm )
-{
-    Graphic aGraphic = XclImpObjectManager::ReadImgData( rStrm );
-    if( aGraphic.GetType() != GRAPHIC_NONE )
-        maData.mxBrushItem.reset( new SvxBrushItem( aGraphic, GPOS_TILED, ATTR_BACKGROUND ) );
-}
-
-void XclImpPageSettings::SetPaperSize( sal_uInt16 nXclPaperSize, bool bPortrait )
-{
-    maData.mnPaperSize = nXclPaperSize;
-    maData.mbPortrait = bPortrait;
-    mbValidPaper = true;
-}
-
-// ----------------------------------------------------------------------------
-
-namespace {
-
-void lclPutMarginItem( SfxItemSet& rItemSet, sal_uInt16 nRecId, double fMarginInch )
-{
-    sal_uInt16 nMarginTwips = XclTools::GetTwipsFromInch( fMarginInch );
-    switch( nRecId )
-    {
-        case EXC_ID_TOPMARGIN:
-        case EXC_ID_BOTTOMMARGIN:
-        {
-            SvxULSpaceItem aItem( GETITEM( rItemSet, SvxULSpaceItem, ATTR_ULSPACE ) );
-            if( nRecId == EXC_ID_TOPMARGIN )
-                aItem.SetUpperValue( nMarginTwips );
-            else
-                aItem.SetLowerValue( nMarginTwips );
-            rItemSet.Put( aItem );
-        }
-        break;
-        case EXC_ID_LEFTMARGIN:
-        case EXC_ID_RIGHTMARGIN:
-        {
-            SvxLRSpaceItem aItem( GETITEM( rItemSet, SvxLRSpaceItem, ATTR_LRSPACE ) );
-            if( nRecId == EXC_ID_LEFTMARGIN )
-                aItem.SetLeftValue( nMarginTwips );
-            else
-                aItem.SetRightValue( nMarginTwips );
-            rItemSet.Put( aItem );
-        }
-        break;
-        default:
-            DBG_ERRORFILE( "XclImpPageSettings::SetMarginItem - unknown record id" );
-    }
-}
-
-} // namespace
-
-void XclImpPageSettings::Finalize()
-{
-    ScDocument& rDoc = GetDoc();
-    SCTAB nScTab = GetCurrScTab();
-
-    // *** create page style sheet ***
-
-    String aStyleName( RTL_CONSTASCII_USTRINGPARAM( "PageStyle_" ) );
-    String aTableName;
-    if( GetDoc().GetName( nScTab, aTableName ) )
-        aStyleName.Append( aTableName );
-    else
-        aStyleName.Append( String::CreateFromInt32( nScTab + 1 ) );
-
-    ScStyleSheet& rStyleSheet = ScfTools::MakePageStyleSheet( GetStyleSheetPool(), aStyleName, false );
-    SfxItemSet& rItemSet = rStyleSheet.GetItemSet();
-
-    // *** page settings ***
-
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_PAGE_TOPDOWN,    !maData.mbPrintInRows ),    true );
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_PAGE_HORCENTER,  maData.mbHorCenter ),       true );
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_PAGE_VERCENTER,  maData.mbVerCenter ),       true );
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_PAGE_HEADERS,    maData.mbPrintHeadings ),   true );
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_PAGE_GRID,       maData.mbPrintGrid ),       true );
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_PAGE_NOTES,      maData.mbPrintNotes ),      true );
-
-    sal_uInt16 nStartPage = maData.mbManualStart ? maData.mnStartPage : 0;
-    ScfTools::PutItem( rItemSet, SfxUInt16Item( ATTR_PAGE_FIRSTPAGENO, nStartPage ), true );
-
-    if( maData.mxBrushItem.get() )
-        rItemSet.Put( *maData.mxBrushItem );
-
-    if( mbValidPaper )
-    {
-        SvxPageItem aPageItem( GETITEM( rItemSet, SvxPageItem, ATTR_PAGE ) );
-        aPageItem.SetLandscape( !maData.mbPortrait );
-        rItemSet.Put( aPageItem );
-        ScfTools::PutItem( rItemSet, SvxSizeItem( ATTR_PAGE_SIZE, maData.GetScPaperSize() ), true );
-    }
-
-    if( maData.mbFitToPages )
-        rItemSet.Put( ScPageScaleToItem( maData.mnFitToWidth, maData.mnFitToHeight ) );
-    else if( maData.mbValid )
-        rItemSet.Put( SfxUInt16Item( ATTR_PAGE_SCALE, maData.mnScaling ) );
-
-    // *** margin preparations ***
-
-    double fLeftMargin   = maData.mfLeftMargin;
-    double fRightMargin  = maData.mfRightMargin;
-    double fTopMargin    = maData.mfTopMargin;
-    double fBottomMargin = maData.mfBottomMargin;
-    // distances between header/footer and page area
-    double fHeaderHeight = 0.0;
-    double fHeaderDist = 0.0;
-    double fFooterHeight = 0.0;
-    double fFooterDist = 0.0;
-    // in Calc, "header/footer left/right margin" is X distance between header/footer and page margin
-    double fHdrLeftMargin  = maData.mfHdrLeftMargin  - maData.mfLeftMargin;
-    double fHdrRightMargin = maData.mfHdrRightMargin - maData.mfRightMargin;
-    double fFtrLeftMargin  = maData.mfFtrLeftMargin  - maData.mfLeftMargin;
-    double fFtrRightMargin = maData.mfFtrRightMargin - maData.mfRightMargin;
-
-    // *** header and footer ***
-
-    XclImpHFConverter aHFConv( GetRoot() );
-
-    // header
-    bool bHasHeader = (maData.maHeader.Len() != 0);
-    SvxSetItem aHdrSetItem( GETITEM( rItemSet, SvxSetItem, ATTR_PAGE_HEADERSET ) );
-    SfxItemSet& rHdrItemSet = aHdrSetItem.GetItemSet();
-    rHdrItemSet.Put( SfxBoolItem( ATTR_PAGE_ON, bHasHeader ) );
-    if( bHasHeader )
-    {
-        aHFConv.ParseString( maData.maHeader );
-        aHFConv.FillToItemSet( rItemSet, ATTR_PAGE_HEADERLEFT );
-        aHFConv.FillToItemSet( rItemSet, ATTR_PAGE_HEADERRIGHT );
-        // #i23296# In Calc, "top margin" is distance to header
-        fTopMargin = maData.mfHeaderMargin;
-        // Calc uses distance between header and sheet data area
-        fHeaderHeight = XclTools::GetInchFromTwips( aHFConv.GetTotalHeight() );
-        fHeaderDist = maData.mfTopMargin - maData.mfHeaderMargin - fHeaderHeight;
-    }
-    if( fHeaderDist < 0.0 )
-    {
-        /*  #i23296# Header overlays sheet data:
-            -> set fixed header height to get correct sheet data position. */
-        ScfTools::PutItem( rHdrItemSet, SfxBoolItem( ATTR_PAGE_DYNAMIC, false ), true );
-        // shrink header height
-        long nHdrHeight = XclTools::GetTwipsFromInch( fHeaderHeight + fHeaderDist );
-        ScfTools::PutItem( rHdrItemSet, SvxSizeItem( ATTR_PAGE_SIZE, Size( 0, nHdrHeight ) ), true );
-        lclPutMarginItem( rHdrItemSet, EXC_ID_BOTTOMMARGIN, 0.0 );
-    }
-    else
-    {
-        // use dynamic header height
-        ScfTools::PutItem( rHdrItemSet, SfxBoolItem( ATTR_PAGE_DYNAMIC, true ), true );
-        lclPutMarginItem( rHdrItemSet, EXC_ID_BOTTOMMARGIN, fHeaderDist );
-    }
-    lclPutMarginItem( rHdrItemSet, EXC_ID_LEFTMARGIN,   fHdrLeftMargin );
-    lclPutMarginItem( rHdrItemSet, EXC_ID_RIGHTMARGIN,  fHdrRightMargin );
-    rItemSet.Put( aHdrSetItem );
-
-    // footer
-    bool bHasFooter = (maData.maFooter.Len() != 0);
-    SvxSetItem aFtrSetItem( GETITEM( rItemSet, SvxSetItem, ATTR_PAGE_FOOTERSET ) );
-    SfxItemSet& rFtrItemSet = aFtrSetItem.GetItemSet();
-    rFtrItemSet.Put( SfxBoolItem( ATTR_PAGE_ON, bHasFooter ) );
-    if( bHasFooter )
-    {
-        aHFConv.ParseString( maData.maFooter );
-        aHFConv.FillToItemSet( rItemSet, ATTR_PAGE_FOOTERLEFT );
-        aHFConv.FillToItemSet( rItemSet, ATTR_PAGE_FOOTERRIGHT );
-        // #i23296# In Calc, "bottom margin" is distance to footer
-        fBottomMargin = maData.mfFooterMargin;
-        // Calc uses distance between footer and sheet data area
-        fFooterHeight = XclTools::GetInchFromTwips( aHFConv.GetTotalHeight() );
-        fFooterDist = maData.mfBottomMargin - maData.mfFooterMargin - fFooterHeight;
-    }
-    if( fFooterDist < 0.0 )
-    {
-        /*  #i23296# Footer overlays sheet data:
-            -> set fixed footer height to get correct sheet data end position. */
-        ScfTools::PutItem( rFtrItemSet, SfxBoolItem( ATTR_PAGE_DYNAMIC, false ), true );
-        // shrink footer height
-        long nFtrHeight = XclTools::GetTwipsFromInch( fFooterHeight + fFooterDist );
-        ScfTools::PutItem( rFtrItemSet, SvxSizeItem( ATTR_PAGE_SIZE, Size( 0, nFtrHeight ) ), true );
-        lclPutMarginItem( rFtrItemSet, EXC_ID_TOPMARGIN, 0.0 );
-    }
-    else
-    {
-        // use dynamic footer height
-        ScfTools::PutItem( rFtrItemSet, SfxBoolItem( ATTR_PAGE_DYNAMIC, true ), true );
-        lclPutMarginItem( rFtrItemSet, EXC_ID_TOPMARGIN, fFooterDist );
-    }
-    lclPutMarginItem( rFtrItemSet, EXC_ID_LEFTMARGIN,   fFtrLeftMargin );
-    lclPutMarginItem( rFtrItemSet, EXC_ID_RIGHTMARGIN,  fFtrRightMargin );
-    rItemSet.Put( aFtrSetItem );
-
-    // *** set final margins ***
-
-    lclPutMarginItem( rItemSet, EXC_ID_LEFTMARGIN,   fLeftMargin );
-    lclPutMarginItem( rItemSet, EXC_ID_RIGHTMARGIN,  fRightMargin );
-    lclPutMarginItem( rItemSet, EXC_ID_TOPMARGIN,    fTopMargin );
-    lclPutMarginItem( rItemSet, EXC_ID_BOTTOMMARGIN, fBottomMargin );
-
-    // *** put style sheet into document ***
-
-    rDoc.SetPageStyle( nScTab, rStyleSheet.GetName() );
-
-    // *** page breaks ***
-
-    ScfUInt16Vec::const_iterator aIt, aEnd;
-
-    for( aIt = maData.maHorPageBreaks.begin(), aEnd = maData.maHorPageBreaks.end(); aIt != aEnd; ++aIt )
-    {
-        SCROW nScRow = static_cast< SCROW >( *aIt );
-        if( nScRow <= MAXROW )
-            rDoc.SetRowBreak(nScRow, nScTab, false, true);
-    }
-
-    for( aIt = maData.maVerPageBreaks.begin(), aEnd = maData.maVerPageBreaks.end(); aIt != aEnd; ++aIt )
-    {
-        SCCOL nScCol = static_cast< SCCOL >( *aIt );
-        if( nScCol <= MAXCOL )
-            rDoc.SetColBreak(nScCol, nScTab, false, true);
-    }
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xipivot.cxx sc/source/filter/xlsx/xlsx-xipivot.cxx
deleted file mode 100644
index 1aef359..0000000
--- sc/source/filter/xlsx/xlsx-xipivot.cxx
+++ /dev/null
@@ -1,1641 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xipivot.cxx,v $
- * $Revision: 1.20.4.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "xipivot.hxx"
-
-#include <com/sun/star/sheet/DataPilotFieldSortInfo.hpp>
-#include <com/sun/star/sheet/DataPilotFieldAutoShowInfo.hpp>
-#include <com/sun/star/sheet/DataPilotFieldLayoutInfo.hpp>
-#include <com/sun/star/sheet/DataPilotFieldReference.hpp>
-
-#include <tools/datetime.hxx>
-#include <svtools/zformat.hxx>
-#include <svtools/intitem.hxx>
-
-#include "document.hxx"
-#include "cell.hxx"
-#include "dpsave.hxx"
-#include "dpdimsave.hxx"
-#include "dpobject.hxx"
-#include "dpshttab.hxx"
-#include "dpoutputgeometry.hxx"
-#include "scitems.hxx"
-#include "attrib.hxx"
-
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xilink.hxx"
-#include "xiescher.hxx"
-
-//! TODO ExcelToSc usage
-#include "excform.hxx"
-#include "xltable.hxx"
-
-#include <vector>
-
-using ::rtl::OUString;
-using ::rtl::OUStringBuffer;
-using ::com::sun::star::sheet::DataPilotFieldOrientation;
-using ::com::sun::star::sheet::DataPilotFieldOrientation_DATA;
-using ::com::sun::star::sheet::DataPilotFieldSortInfo;
-using ::com::sun::star::sheet::DataPilotFieldAutoShowInfo;
-using ::com::sun::star::sheet::DataPilotFieldLayoutInfo;
-using ::com::sun::star::sheet::DataPilotFieldReference;
-using ::std::vector;
-
-// ============================================================================
-// Pivot cache
-// ============================================================================
-
-XclImpPCItem::XclImpPCItem( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_SXDOUBLE:   ReadSxdouble( rStrm );      break;
-        case EXC_ID_SXBOOLEAN:  ReadSxboolean( rStrm );     break;
-        case EXC_ID_SXERROR:    ReadSxerror( rStrm );       break;
-        case EXC_ID_SXINTEGER:  ReadSxinteger( rStrm );     break;
-        case EXC_ID_SXSTRING:   ReadSxstring( rStrm );      break;
-        case EXC_ID_SXDATETIME: ReadSxdatetime( rStrm );    break;
-        case EXC_ID_SXEMPTY:    ReadSxempty( rStrm );       break;
-        default:    DBG_ERRORFILE( "XclImpPCItem::XclImpPCItem - unknown record id" );
-    }
-}
-
-namespace {
-
-void lclSetValue( const XclImpRoot& rRoot, const ScAddress& rScPos, double fValue, short nFormatType )
-{
-    ScDocument& rDoc = rRoot.GetDoc();
-    rDoc.SetValue( rScPos.Col(), rScPos.Row(), rScPos.Tab(), fValue );
-    sal_uInt32 nScNumFmt = rRoot.GetFormatter().GetStandardFormat( nFormatType, rRoot.GetDocLanguage() );
-    rDoc.ApplyAttr( rScPos.Col(), rScPos.Row(), rScPos.Tab(), SfxUInt32Item( ATTR_VALUE_FORMAT, nScNumFmt ) );
-}
-
-} // namespace
-
-void XclImpPCItem::WriteToSource( const XclImpRoot& rRoot, const ScAddress& rScPos ) const
-{
-    ScDocument& rDoc = rRoot.GetDoc();
-    if( const String* pText = GetText() )
-        rDoc.SetString( rScPos.Col(), rScPos.Row(), rScPos.Tab(), *pText );
-    else if( const double* pfValue = GetDouble() )
-        rDoc.SetValue( rScPos.Col(), rScPos.Row(), rScPos.Tab(), *pfValue );
-    else if( const sal_Int16* pnValue = GetInteger() )
-        rDoc.SetValue( rScPos.Col(), rScPos.Row(), rScPos.Tab(), *pnValue );
-    else if( const bool* pbValue = GetBool() )
-        lclSetValue( rRoot, rScPos, *pbValue ? 1.0 : 0.0, NUMBERFORMAT_LOGICAL );
-    else if( const DateTime* pDateTime = GetDateTime() )
-    {
-        // set number format date, time, or date/time, depending on the value
-        double fValue = rRoot.GetDoubleFromDateTime( *pDateTime );
-        double fInt = 0.0;
-        double fFrac = modf( fValue, &fInt );
-        short nFormatType = ((fFrac == 0.0) && (fInt != 0.0)) ? NUMBERFORMAT_DATE :
-            ((fInt == 0.0) ? NUMBERFORMAT_TIME : NUMBERFORMAT_DATETIME);
-        lclSetValue( rRoot, rScPos, fValue, nFormatType );
-    }
-    else if( const sal_uInt16* pnError = GetError() )
-    {
-        double fValue;
-        sal_uInt8 nErrCode = static_cast< sal_uInt8 >( *pnError );
-        const ScTokenArray* pScTokArr = rRoot.GetOldFmlaConverter().GetBoolErr(
-            XclTools::ErrorToEnum( fValue, EXC_BOOLERR_ERROR, nErrCode ) );
-        ScFormulaCell* pCell = new ScFormulaCell( &rDoc, rScPos, pScTokArr );
-        pCell->SetHybridDouble( fValue );
-        rDoc.PutCell( rScPos, pCell );
-    }
-}
-
-void XclImpPCItem::ReadSxdouble( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecSize() == 8, "XclImpPCItem::ReadSxdouble - wrong record size" );
-    SetDouble( rStrm.ReadDouble() );
-}
-
-void XclImpPCItem::ReadSxboolean( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecSize() == 2, "XclImpPCItem::ReadSxboolean - wrong record size" );
-    SetBool( rStrm.ReaduInt16() != 0 );
-}
-
-void XclImpPCItem::ReadSxerror( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecSize() == 2, "XclImpPCItem::ReadSxerror - wrong record size" );
-    SetError( rStrm.ReaduInt16() );
-}
-
-void XclImpPCItem::ReadSxinteger( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecSize() == 2, "XclImpPCItem::ReadSxinteger - wrong record size" );
-    SetInteger( rStrm.ReadInt16() );
-}
-
-void XclImpPCItem::ReadSxstring( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecSize() >= 3, "XclImpPCItem::ReadSxstring - wrong record size" );
-    SetText( rStrm.ReadUniString() );
-}
-
-void XclImpPCItem::ReadSxdatetime( XclImpStream& rStrm )
-{
-    DBG_ASSERT( rStrm.GetRecSize() == 8, "XclImpPCItem::ReadSxdatetime - wrong record size" );
-    sal_uInt16 nYear, nMonth;
-    sal_uInt8 nDay, nHour, nMin, nSec;
-    rStrm >> nYear >> nMonth >> nDay >> nHour >> nMin >> nSec;
-    SetDateTime( DateTime( Date( nDay, nMonth, nYear ), Time( nHour, nMin, nSec ) ) );
-}
-
-void XclImpPCItem::ReadSxempty( XclImpStream& rStrm )
-{
-    (void)rStrm;    // avoid compiler warning
-    DBG_ASSERT( rStrm.GetRecSize() == 0, "XclImpPCItem::ReadSxempty - wrong record size" );
-    SetEmpty();
-}
-
-// ============================================================================
-
-XclImpPCField::XclImpPCField( const XclImpRoot& rRoot, XclImpPivotCache& rPCache, sal_uInt16 nFieldIdx ) :
-    XclPCField( EXC_PCFIELD_UNKNOWN, nFieldIdx ),
-    XclImpRoot( rRoot ),
-    mrPCache( rPCache ),
-    mnSourceScCol( -1 ),
-    mbNumGroupInfoRead( false )
-{
-}
-
-XclImpPCField::~XclImpPCField()
-{
-}
-
-// general field/item access --------------------------------------------------
-
-const String& XclImpPCField::GetFieldName( const ScfStringVec& rVisNames ) const
-{
-    if( IsGroupChildField() && (mnFieldIdx < rVisNames.size()) )
-    {
-        const String& rVisName = rVisNames[ mnFieldIdx ];
-        if( rVisName.Len() > 0 )
-            return rVisName;
-    }
-    return maFieldInfo.maName;
-}
-
-const XclImpPCField* XclImpPCField::GetGroupBaseField() const
-{
-    DBG_ASSERT( IsGroupChildField(), "XclImpPCField::GetGroupBaseField - this field type does not have a base field" );
-    return IsGroupChildField() ? mrPCache.GetField( maFieldInfo.mnGroupBase ) : 0;
-}
-
-sal_uInt16 XclImpPCField::GetItemCount() const
-{
-    return static_cast< sal_uInt16 >( maItems.size() );
-}
-
-const XclImpPCItem* XclImpPCField::GetItem( sal_uInt16 nItemIdx ) const
-{
-    return (nItemIdx < maItems.size()) ? maItems[ nItemIdx ].get() : 0;
-}
-
-const XclImpPCItem* XclImpPCField::GetLimitItem( sal_uInt16 nItemIdx ) const
-{
-    DBG_ASSERT( nItemIdx < 3, "XclImpPCField::GetLimitItem - invalid item index" );
-    DBG_ASSERT( nItemIdx < maNumGroupItems.size(), "XclImpPCField::GetLimitItem - no item found" );
-    return (nItemIdx < maNumGroupItems.size()) ? maNumGroupItems[ nItemIdx ].get() : 0;
-}
-
-void XclImpPCField::WriteFieldNameToSource( SCCOL nScCol, SCTAB nScTab ) const
-{
-    DBG_ASSERT( HasOrigItems(), "XclImpPCField::WriteFieldNameToSource - only for standard fields" );
-    GetDoc().SetString( nScCol, 0, nScTab, maFieldInfo.maName );
-    mnSourceScCol = nScCol;
-}
-
-void XclImpPCField::WriteOrigItemToSource( SCROW nScRow, SCTAB nScTab, sal_uInt16 nItemIdx ) const
-{
-    if( nItemIdx < maOrigItems.size() )
-        maOrigItems[ nItemIdx ]->WriteToSource( GetRoot(), ScAddress( mnSourceScCol, nScRow, nScTab ) );
-}
-
-void XclImpPCField::WriteLastOrigItemToSource( SCROW nScRow, SCTAB nScTab ) const
-{
-    if( !maOrigItems.empty() )
-        maOrigItems.back()->WriteToSource( GetRoot(), ScAddress( mnSourceScCol, nScRow, nScTab ) );
-}
-
-// records --------------------------------------------------------------------
-
-void XclImpPCField::ReadSxfield( XclImpStream& rStrm )
-{
-    rStrm >> maFieldInfo;
-
-    /*  Detect the type of this field. This is done very restrictive to detect
-        any unexpected state. */
-    meFieldType = EXC_PCFIELD_UNKNOWN;
-
-    bool bItems  = ::get_flag( maFieldInfo.mnFlags, EXC_SXFIELD_HASITEMS );
-    bool bPostp  = ::get_flag( maFieldInfo.mnFlags, EXC_SXFIELD_POSTPONE );
-    bool bCalced = ::get_flag( maFieldInfo.mnFlags, EXC_SXFIELD_CALCED );
-    bool bChild  = ::get_flag( maFieldInfo.mnFlags, EXC_SXFIELD_HASCHILD );
-    bool bNum    = ::get_flag( maFieldInfo.mnFlags, EXC_SXFIELD_NUMGROUP );
-
-    sal_uInt16 nVisC   = maFieldInfo.mnVisItems;
-    sal_uInt16 nGroupC = maFieldInfo.mnGroupItems;
-    sal_uInt16 nBaseC  = maFieldInfo.mnBaseItems;
-    sal_uInt16 nOrigC  = maFieldInfo.mnOrigItems;
-    DBG_ASSERT( nVisC > 0, "XclImpPCField::ReadSxfield - field without visible items" );
-
-    sal_uInt16 nType = maFieldInfo.mnFlags & EXC_SXFIELD_DATA_MASK;
-    bool bType =
-        (nType == EXC_SXFIELD_DATA_STR) ||
-        (nType == EXC_SXFIELD_DATA_INT) ||
-        (nType == EXC_SXFIELD_DATA_DBL) ||
-        (nType == EXC_SXFIELD_DATA_STR_INT) ||
-        (nType == EXC_SXFIELD_DATA_STR_DBL) ||
-        (nType == EXC_SXFIELD_DATA_DATE) ||
-        (nType == EXC_SXFIELD_DATA_DATE_EMP) ||
-        (nType == EXC_SXFIELD_DATA_DATE_NUM) ||
-        (nType == EXC_SXFIELD_DATA_DATE_STR);
-    bool bTypeNone =
-        (nType == EXC_SXFIELD_DATA_NONE);
-    // for now, ignore data type of calculated fields
-    DBG_ASSERT( bCalced || bType || bTypeNone, "XclImpPCField::ReadSxfield - unknown item data type" );
-
-    if( nVisC > 0 || bPostp )
-    {
-        if( bItems && !bPostp )
-        {
-            if( !bCalced )
-            {
-                // 1) standard fields and standard grouping fields
-                if( !bNum )
-                {
-                    // 1a) standard field without grouping
-                    if( bType && (nGroupC == 0) && (nBaseC == 0) && (nOrigC == nVisC) )
-                        meFieldType = EXC_PCFIELD_STANDARD;
-
-                    // 1b) standard grouping field
-                    else if( bTypeNone && (nGroupC == nVisC) && (nBaseC > 0) && (nOrigC == 0) )
-                        meFieldType = EXC_PCFIELD_STDGROUP;
-                }
-                // 2) numerical grouping fields
-                else if( (nGroupC == nVisC) && (nBaseC == 0) )
-                {
-                    // 2a) single num/date grouping field without child grouping field
-                    if( !bChild && bType && (nOrigC > 0) )
-                    {
-                        switch( nType )
-                        {
-                            case EXC_SXFIELD_DATA_INT:
-                            case EXC_SXFIELD_DATA_DBL:  meFieldType = EXC_PCFIELD_NUMGROUP;     break;
-                            case EXC_SXFIELD_DATA_DATE: meFieldType = EXC_PCFIELD_DATEGROUP;    break;
-                            default:    DBG_ERRORFILE( "XclImpPCField::ReadSxfield - numeric group with wrong data type" );
-                        }
-                    }
-
-                    // 2b) first date grouping field with child grouping field
-                    else if( bChild && (nType == EXC_SXFIELD_DATA_DATE) && (nOrigC > 0) )
-                        meFieldType = EXC_PCFIELD_DATEGROUP;
-
-                    // 2c) additional date grouping field
-                    else if( bTypeNone && (nOrigC == 0) )
-                        meFieldType = EXC_PCFIELD_DATECHILD;
-                }
-                DBG_ASSERT( meFieldType != EXC_PCFIELD_UNKNOWN, "XclImpPCField::ReadSxfield - invalid standard or grouped field" );
-            }
-
-            // 3) calculated field
-            else
-            {
-                if( !bChild && !bNum && (nGroupC == 0) && (nBaseC == 0) && (nOrigC == 0) )
-                    meFieldType = EXC_PCFIELD_CALCED;
-                DBG_ASSERT( meFieldType == EXC_PCFIELD_CALCED, "XclImpPCField::ReadSxfield - invalid calculated field" );
-            }
-        }
-
-        else if( !bItems && bPostp )
-        {
-            // 4) standard field with postponed items
-            if( !bCalced && !bChild && !bNum && bType && (nGroupC == 0) && (nBaseC == 0) && (nOrigC == 0) )
-                meFieldType = EXC_PCFIELD_STANDARD;
-            DBG_ASSERT( meFieldType == EXC_PCFIELD_STANDARD, "XclImpPCField::ReadSxfield - invalid postponed field" );
-        }
-    }
-}
-
-void XclImpPCField::ReadItem( XclImpStream& rStrm )
-{
-    DBG_ASSERT( HasInlineItems() || HasPostponedItems(), "XclImpPCField::ReadItem - field does not expect items" );
-
-    // read the item
-    XclImpPCItemRef xItem( new XclImpPCItem( rStrm ) );
-
-    // try to insert into an item list
-    if( mbNumGroupInfoRead )
-    {
-        // there are 3 items after SXNUMGROUP that contain grouping limits and step count
-        if( maNumGroupItems.size() < 3 )
-            maNumGroupItems.push_back( xItem );
-        else
-            maOrigItems.push_back( xItem );
-    }
-    else if( HasInlineItems() || HasPostponedItems() )
-    {
-        maItems.push_back( xItem );
-        // visible item is original item in standard fields
-        if( IsStandardField() )
-            maOrigItems.push_back( xItem );
-    }
-}
-
-void XclImpPCField::ReadSxnumgroup( XclImpStream& rStrm )
-{
-    DBG_ASSERT( IsNumGroupField() || IsDateGroupField(), "XclImpPCField::ReadSxnumgroup - SXNUMGROUP outside numeric grouping field" );
-    DBG_ASSERT( !mbNumGroupInfoRead, "XclImpPCField::ReadSxnumgroup - multiple SXNUMGROUP records" );
-    DBG_ASSERT( maItems.size() == maFieldInfo.mnGroupItems, "XclImpPCField::ReadSxnumgroup - SXNUMGROUP out of record order" );
-    rStrm >> maNumGroupInfo;
-    mbNumGroupInfoRead = IsNumGroupField() || IsDateGroupField();
-}
-
-void XclImpPCField::ReadSxgroupinfo( XclImpStream& rStrm )
-{
-    DBG_ASSERT( IsStdGroupField(), "XclImpPCField::ReadSxgroupinfo - SXGROUPINFO outside grouping field" );
-    DBG_ASSERT( maGroupOrder.empty(), "XclImpPCField::ReadSxgroupinfo - multiple SXGROUPINFO records" );
-    DBG_ASSERT( maItems.size() == maFieldInfo.mnGroupItems, "XclImpPCField::ReadSxgroupinfo - SXGROUPINFO out of record order" );
-    DBG_ASSERT( (rStrm.GetRecLeft() / 2) == maFieldInfo.mnBaseItems, "XclImpPCField::ReadSxgroupinfo - wrong SXGROUPINFO size" );
-    maGroupOrder.clear();
-    size_t nSize = rStrm.GetRecLeft() / 2;
-    maGroupOrder.resize( nSize, 0 );
-    for( size_t nIdx = 0; nIdx < nSize; ++nIdx )
-        rStrm >> maGroupOrder[ nIdx ];
-}
-
-// grouping -------------------------------------------------------------------
-
-void XclImpPCField::ConvertGroupField( ScDPSaveData& rSaveData, const ScfStringVec& rVisNames ) const
-{
-    if( GetFieldName( rVisNames ).Len() > 0 )
-    {
-        if( IsStdGroupField() )
-            ConvertStdGroupField( rSaveData, rVisNames );
-        else if( IsNumGroupField() )
-            ConvertNumGroupField( rSaveData, rVisNames );
-        else if( IsDateGroupField() )
-            ConvertDateGroupField( rSaveData, rVisNames );
-    }
-}
-
-// private --------------------------------------------------------------------
-
-void XclImpPCField::ConvertStdGroupField( ScDPSaveData& rSaveData, const ScfStringVec& rVisNames ) const
-{
-    if( const XclImpPCField* pBaseField = GetGroupBaseField() )
-    {
-        const String& rBaseFieldName = pBaseField->GetFieldName( rVisNames );
-        if( rBaseFieldName.Len() > 0 )
-        {
-            // *** create a ScDPSaveGroupItem for each own item, they collect base item names ***
-            typedef ::std::vector< ScDPSaveGroupItem > ScDPSaveGroupItemVec;
-            ScDPSaveGroupItemVec aGroupItems;
-            aGroupItems.reserve( maItems.size() );
-            // initialize with own item names
-            for( XclImpPCItemVec::const_iterator aIt = maItems.begin(), aEnd = maItems.end(); aIt != aEnd; ++aIt )
-                aGroupItems.push_back( ScDPSaveGroupItem( (*aIt)->ConvertToText() ) );
-
-            // *** iterate over all base items, set their names at corresponding own items ***
-            for( sal_uInt16 nItemIdx = 0, nItemCount = static_cast< sal_uInt16 >( maGroupOrder.size() ); nItemIdx < nItemCount; ++nItemIdx )
-                if( maGroupOrder[ nItemIdx ] < aGroupItems.size() )
-                    if( const XclImpPCItem* pBaseItem = pBaseField->GetItem( nItemIdx ) )
-                        if( const XclImpPCItem* pGroupItem = GetItem( maGroupOrder[ nItemIdx ] ) )
-                            if( *pBaseItem != *pGroupItem )
-                                aGroupItems[ maGroupOrder[ nItemIdx ] ].AddElement( pBaseItem->ConvertToText() );
-
-            // *** create the ScDPSaveGroupDimension object, fill with grouping info ***
-            ScDPSaveGroupDimension aGroupDim( rBaseFieldName, GetFieldName( rVisNames ) );
-            for( ScDPSaveGroupItemVec::const_iterator aIt = aGroupItems.begin(), aEnd = aGroupItems.end(); aIt != aEnd; ++aIt )
-                if( !aIt->IsEmpty() )
-                    aGroupDim.AddGroupItem( *aIt );
-            rSaveData.GetDimensionData()->AddGroupDimension( aGroupDim );
-        }
-    }
-}
-
-void XclImpPCField::ConvertNumGroupField( ScDPSaveData& rSaveData, const ScfStringVec& rVisNames ) const
-{
-    ScDPNumGroupInfo aNumInfo( GetScNumGroupInfo() );
-    ScDPSaveNumGroupDimension aNumGroupDim( GetFieldName( rVisNames ), aNumInfo );
-    rSaveData.GetDimensionData()->AddNumGroupDimension( aNumGroupDim );
-}
-
-void XclImpPCField::ConvertDateGroupField( ScDPSaveData& rSaveData, const ScfStringVec& rVisNames ) const
-{
-    ScDPNumGroupInfo aDateInfo( GetScDateGroupInfo() );
-    sal_Int32 nScDateType = maNumGroupInfo.GetScDateType();
-
-    switch( meFieldType )
-    {
-        case EXC_PCFIELD_DATEGROUP:
-        {
-            if( aDateInfo.DateValues )
-            {
-                // special case for days only with step value - create numeric grouping
-                ScDPSaveNumGroupDimension aNumGroupDim( GetFieldName( rVisNames ), aDateInfo );
-                rSaveData.GetDimensionData()->AddNumGroupDimension( aNumGroupDim );
-            }
-            else
-            {
-                ScDPSaveNumGroupDimension aNumGroupDim( GetFieldName( rVisNames ), ScDPNumGroupInfo() );
-                aNumGroupDim.SetDateInfo( aDateInfo, nScDateType );
-                rSaveData.GetDimensionData()->AddNumGroupDimension( aNumGroupDim );
-            }
-        }
-        break;
-
-        case EXC_PCFIELD_DATECHILD:
-        {
-            if( const XclImpPCField* pBaseField = GetGroupBaseField() )
-            {
-                const String& rBaseFieldName = pBaseField->GetFieldName( rVisNames );
-                if( rBaseFieldName.Len() > 0 )
-                {
-                    ScDPSaveGroupDimension aGroupDim( rBaseFieldName, GetFieldName( rVisNames ) );
-                    aGroupDim.SetDateInfo( aDateInfo, nScDateType );
-                    rSaveData.GetDimensionData()->AddGroupDimension( aGroupDim );
-                }
-            }
-        }
-        break;
-
-        default:
-            DBG_ERRORFILE( "XclImpPCField::ConvertDateGroupField - unknown date field type" );
-    }
-}
-
-ScDPNumGroupInfo XclImpPCField::GetScNumGroupInfo() const
-{
-    ScDPNumGroupInfo aNumInfo;
-    aNumInfo.Enable = sal_True;
-    aNumInfo.DateValues = sal_False;
-    aNumInfo.AutoStart = sal_True;
-    aNumInfo.AutoEnd = sal_True;
-
-    if( const double* pfMinValue = GetNumGroupLimit( EXC_SXFIELD_INDEX_MIN ) )
-    {
-        aNumInfo.Start = *pfMinValue;
-        aNumInfo.AutoStart = ::get_flag( maNumGroupInfo.mnFlags, EXC_SXNUMGROUP_AUTOMIN );
-    }
-    if( const double* pfMaxValue = GetNumGroupLimit( EXC_SXFIELD_INDEX_MAX ) )
-    {
-        aNumInfo.End = *pfMaxValue;
-        aNumInfo.AutoEnd = ::get_flag( maNumGroupInfo.mnFlags, EXC_SXNUMGROUP_AUTOMAX );
-    }
-    if( const double* pfStepValue = GetNumGroupLimit( EXC_SXFIELD_INDEX_STEP ) )
-        aNumInfo.Step = *pfStepValue;
-
-    return aNumInfo;
-}
-
-ScDPNumGroupInfo XclImpPCField::GetScDateGroupInfo() const
-{
-    ScDPNumGroupInfo aDateInfo;
-    aDateInfo.Enable = sal_True;
-    aDateInfo.DateValues = sal_False;
-    aDateInfo.AutoStart = sal_True;
-    aDateInfo.AutoEnd = sal_True;
-
-    if( const DateTime* pMinDate = GetDateGroupLimit( EXC_SXFIELD_INDEX_MIN ) )
-    {
-        aDateInfo.Start = GetDoubleFromDateTime( *pMinDate );
-        aDateInfo.AutoStart = ::get_flag( maNumGroupInfo.mnFlags, EXC_SXNUMGROUP_AUTOMIN );
-    }
-    if( const DateTime* pMaxDate = GetDateGroupLimit( EXC_SXFIELD_INDEX_MAX ) )
-    {
-        aDateInfo.End = GetDoubleFromDateTime( *pMaxDate );
-        aDateInfo.AutoEnd = ::get_flag( maNumGroupInfo.mnFlags, EXC_SXNUMGROUP_AUTOMAX );
-    }
-    // GetDateGroupStep() returns a value for date type "day" in single date groups only
-    if( const sal_Int16* pnStepValue = GetDateGroupStep() )
-    {
-        aDateInfo.Step = *pnStepValue;
-        aDateInfo.DateValues = sal_True;
-    }
-
-    return aDateInfo;
-}
-
-const double* XclImpPCField::GetNumGroupLimit( sal_uInt16 nLimitIdx ) const
-{
-    DBG_ASSERT( IsNumGroupField(), "XclImpPCField::GetNumGroupLimit - only for numeric grouping fields" );
-    if( const XclImpPCItem* pItem = GetLimitItem( nLimitIdx ) )
-    {
-        DBG_ASSERT( pItem->GetDouble(), "XclImpPCField::GetNumGroupLimit - SXDOUBLE item expected" );
-        return pItem->GetDouble();
-    }
-    return 0;
-}
-
-const DateTime* XclImpPCField::GetDateGroupLimit( sal_uInt16 nLimitIdx ) const
-{
-    DBG_ASSERT( IsDateGroupField(), "XclImpPCField::GetDateGroupLimit - only for date grouping fields" );
-    if( const XclImpPCItem* pItem = GetLimitItem( nLimitIdx ) )
-    {
-        DBG_ASSERT( pItem->GetDateTime(), "XclImpPCField::GetDateGroupLimit - SXDATETIME item expected" );
-        return pItem->GetDateTime();
-    }
-    return 0;
-}
-
-const sal_Int16* XclImpPCField::GetDateGroupStep() const
-{
-    // only for single date grouping fields, not for grouping chains
-    if( !IsGroupBaseField() && !IsGroupChildField() )
-    {
-        // only days may have a step value, return 0 for all other date types
-        if( maNumGroupInfo.GetXclDataType() == EXC_SXNUMGROUP_TYPE_DAY )
-        {
-            if( const XclImpPCItem* pItem = GetLimitItem( EXC_SXFIELD_INDEX_STEP ) )
-            {
-                DBG_ASSERT( pItem->GetInteger(), "XclImpPCField::GetDateGroupStep - SXINTEGER item expected" );
-                if( const sal_Int16* pnStep = pItem->GetInteger() )
-                {
-                    DBG_ASSERT( *pnStep > 0, "XclImpPCField::GetDateGroupStep - invalid step count" );
-                    // return nothing for step count 1 - this is also a standard date group in Excel
-                    return (*pnStep > 1) ? pnStep : 0;
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-// ============================================================================
-
-XclImpPivotCache::XclImpPivotCache( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maSrcRange( ScAddress::INITIALIZE_INVALID ),
-    mnStrmId( 0 ),
-    mnSrcType( EXC_SXVS_UNKNOWN ),
-    mbSelfRef( false )
-{
-}
-
-XclImpPivotCache::~XclImpPivotCache()
-{
-}
-
-// data access ----------------------------------------------------------------
-
-sal_uInt16 XclImpPivotCache::GetFieldCount() const
-{
-    return static_cast< sal_uInt16 >( maFields.size() );
-}
-
-const XclImpPCField* XclImpPivotCache::GetField( sal_uInt16 nFieldIdx ) const
-{
-    return (nFieldIdx < maFields.size()) ? maFields[ nFieldIdx ].get() : 0;
-}
-
-// records --------------------------------------------------------------------
-
-void XclImpPivotCache::ReadSxidstm( XclImpStream& rStrm )
-{
-    rStrm >> mnStrmId;
-}
-
-void XclImpPivotCache::ReadSxvs( XclImpStream& rStrm )
-{
-    rStrm >> mnSrcType;
-    GetTracer().TracePivotDataSource( mnSrcType != EXC_SXVS_SHEET );
-}
-
-void XclImpPivotCache::ReadDconref( XclImpStream& rStrm )
-{
-    /*  Read DCONREF only once (by checking maTabName), there may be other
-        DCONREF records in another context. Read reference only if a leading
-        SXVS record is present (by checking mnSrcType). */
-    if( (maTabName.Len() > 0) || (mnSrcType != EXC_SXVS_SHEET) )
-        return;
-
-    XclRange aXclRange( ScAddress::UNINITIALIZED );
-    aXclRange.Read( rStrm, false );
-    String aEncUrl = rStrm.ReadUniString();
-
-    XclImpUrlHelper::DecodeUrl( maUrl, maTabName, mbSelfRef, GetRoot(), aEncUrl );
-
-    /*  Do not convert maTabName to Calc sheet name -> original name is used to
-        find the sheet in the document. Sheet index of source range will be
-        found later in XclImpPivotCache::ReadPivotCacheStream(), because sheet
-        may not exist yet. */
-    if( mbSelfRef )
-        GetAddressConverter().ConvertRange( maSrcRange, aXclRange, 0, 0, true );
-}
-
-void XclImpPivotCache::ReadPivotCacheStream( XclImpStream& rStrm )
-{
-    if( (mnSrcType != EXC_SXVS_SHEET) && (mnSrcType != EXC_SXVS_EXTERN) )
-        return;
-
-    ScDocument& rDoc = GetDoc();
-    SCCOL nFieldScCol = 0;              // column index of source data for next field
-    SCROW nItemScRow = 0;               // row index of source data for current items
-    SCTAB nScTab = 0;                   // sheet index of source data
-    bool bGenerateSource = false;       // true = write source data from cache to dummy table
-
-    if( mbSelfRef )
-    {
-        // try to find internal sheet containing the source data
-        nScTab = GetTabInfo().GetScTabFromXclName( maTabName );
-        if( rDoc.HasTable( nScTab ) )
-        {
-            // set sheet index to source range
-            maSrcRange.aStart.SetTab( nScTab );
-            maSrcRange.aEnd.SetTab( nScTab );
-        }
-        else
-        {
-            // create dummy sheet for deleted internal sheet
-            bGenerateSource = true;
-        }
-    }
-    else
-    {
-        // create dummy sheet for external sheet
-        bGenerateSource = true;
-    }
-
-    // create dummy sheet for source data from external or deleted sheet
-    if( bGenerateSource )
-    {
-        if( rDoc.GetTableCount() >= MAXTABCOUNT )
-            // cannot create more sheets -> exit
-            return;
-
-        nScTab = rDoc.GetTableCount();
-        rDoc.MakeTable( nScTab );
-        String aDummyName = CREATE_STRING( "DPCache" );
-        if( maTabName.Len() > 0 )
-            aDummyName.Append( '_' ).Append( maTabName );
-        rDoc.CreateValidTabName( aDummyName );
-        rDoc.RenameTab( nScTab, aDummyName );
-        // set sheet index to source range
-        maSrcRange.aStart.SetTab( nScTab );
-        maSrcRange.aEnd.SetTab( nScTab );
-    }
-
-    // open pivot cache storage stream
-    SotStorageRef xSvStrg = OpenStorage( EXC_STORAGE_PTCACHE );
-    SotStorageStreamRef xSvStrm = OpenStream( xSvStrg, ScfTools::GetHexStr( mnStrmId ) );
-    if( !xSvStrm.Is() )
-        return;
-
-    // create Excel record stream object
-    XclImpStream aPCStrm( *xSvStrm, GetRoot() );
-    aPCStrm.CopyDecrypterFrom( rStrm );     // pivot cache streams are encrypted
-
-    XclImpPCFieldRef xCurrField;    // current field for new items
-    XclImpPCFieldVec aOrigFields;   // all standard fields with inline original  items
-    XclImpPCFieldVec aPostpFields;  // all standard fields with postponed original items
-    size_t nPostpIdx = 0;           // index to current field with postponed items
-    bool bLoop = true;              // true = continue loop
-
-    while( bLoop && aPCStrm.StartNextRecord() )
-    {
-        switch( aPCStrm.GetRecId() )
-        {
-            case EXC_ID_EOF:
-                bLoop = false;
-            break;
-
-            case EXC_ID_SXDB:
-                aPCStrm >> maPCInfo;
-            break;
-
-            case EXC_ID_SXFIELD:
-            {
-                xCurrField.reset();
-                sal_uInt16 nNewFieldIdx = GetFieldCount();
-                if( nNewFieldIdx < EXC_PC_MAXFIELDCOUNT )
-                {
-                    xCurrField.reset( new XclImpPCField( GetRoot(), *this, nNewFieldIdx ) );
-                    maFields.push_back( xCurrField );
-                    xCurrField->ReadSxfield( aPCStrm );
-                    if( xCurrField->HasOrigItems() )
-                    {
-                        if( xCurrField->HasPostponedItems() )
-                            aPostpFields.push_back( xCurrField );
-                        else
-                            aOrigFields.push_back( xCurrField );
-                        // insert field name into generated source data, field remembers its column index
-                        if( bGenerateSource && (nFieldScCol <= MAXCOL) )
-                            xCurrField->WriteFieldNameToSource( nFieldScCol++, nScTab );
-                    }
-                    // do not read items into invalid/postponed fields
-                    if( !xCurrField->HasInlineItems() )
-                        xCurrField.reset();
-                }
-            }
-            break;
-
-            case EXC_ID_SXINDEXLIST:
-                // read index list and insert all items into generated source data
-                if( bGenerateSource && (nItemScRow <= MAXROW) && (++nItemScRow <= MAXROW) )
-                {
-                    for( XclImpPCFieldVec::const_iterator aIt = aOrigFields.begin(), aEnd = aOrigFields.end(); aIt != aEnd; ++aIt )
-                    {
-                        sal_uInt16 nItemIdx = (*aIt)->Has16BitIndexes() ? aPCStrm.ReaduInt16() : aPCStrm.ReaduInt8();
-                        (*aIt)->WriteOrigItemToSource( nItemScRow, nScTab, nItemIdx );
-                    }
-                }
-                xCurrField.reset();
-            break;
-
-            case EXC_ID_SXDOUBLE:
-            case EXC_ID_SXBOOLEAN:
-            case EXC_ID_SXERROR:
-            case EXC_ID_SXINTEGER:
-            case EXC_ID_SXSTRING:
-            case EXC_ID_SXDATETIME:
-            case EXC_ID_SXEMPTY:
-                if( xCurrField.is() )                   // inline items
-                {
-                    xCurrField->ReadItem( aPCStrm );
-                }
-                else if( !aPostpFields.empty() )        // postponed items
-                {
-                    // read postponed item
-                    aPostpFields[ nPostpIdx ]->ReadItem( aPCStrm );
-                    // write item to source
-                    if( bGenerateSource && (nItemScRow <= MAXROW) )
-                    {
-                        // start new row, if there are only postponed fields
-                        if( aOrigFields.empty() && (nPostpIdx == 0) )
-                            ++nItemScRow;
-                        if( nItemScRow <= MAXROW )
-                            aPostpFields[ nPostpIdx ]->WriteLastOrigItemToSource( nItemScRow, nScTab );
-                    }
-                    // get index of next postponed field
-                    ++nPostpIdx;
-                    if( nPostpIdx >= aPostpFields.size() )
-                        nPostpIdx = 0;
-                }
-            break;
-
-            case EXC_ID_SXNUMGROUP:
-                if( xCurrField.is() )
-                    xCurrField->ReadSxnumgroup( aPCStrm );
-            break;
-
-            case EXC_ID_SXGROUPINFO:
-                if( xCurrField.is() )
-                    xCurrField->ReadSxgroupinfo( aPCStrm );
-            break;
-
-            // known but ignored records
-            case EXC_ID_SXRULE:
-            case EXC_ID_SXFILT:
-            case EXC_ID_00F5:
-            case EXC_ID_SXNAME:
-            case EXC_ID_SXPAIR:
-            case EXC_ID_SXFMLA:
-            case EXC_ID_SXFORMULA:
-            case EXC_ID_SXDBEX:
-            case EXC_ID_SXFDBTYPE:
-            break;
-
-            default:
-                DBG_ERROR1( "XclImpPivotCache::ReadPivotCacheStream - unknown record 0x%04hX", aPCStrm.GetRecId() );
-        }
-    }
-
-    DBG_ASSERT( maPCInfo.mnTotalFields == maFields.size(),
-        "XclImpPivotCache::ReadPivotCacheStream - field count mismatch" );
-
-    // set source range for external source data
-    if( bGenerateSource && (nFieldScCol > 0) )
-    {
-        maSrcRange.aStart.SetCol( 0 );
-        maSrcRange.aStart.SetRow( 0 );
-        // nFieldScCol points to first unused column
-        maSrcRange.aEnd.SetCol( nFieldScCol - 1 );
-        // nItemScRow points to last used row
-        maSrcRange.aEnd.SetRow( nItemScRow );
-    }
-}
-
-bool XclImpPivotCache::IsRefreshOnLoad() const
-{
-    return static_cast<bool>(maPCInfo.mnFlags & 0x0004);
-}
-
-// ============================================================================
-// Pivot table
-// ============================================================================
-
-XclImpPTItem::XclImpPTItem( const XclImpPCField* pCacheField ) :
-    mpCacheField( pCacheField )
-{
-}
-
-const String* XclImpPTItem::GetItemName() const
-{
-    if( mpCacheField )
-        if( const XclImpPCItem* pCacheItem = mpCacheField->GetItem( maItemInfo.mnCacheIdx ) )
-            //! TODO: use XclImpPCItem::ConvertToText(), if all conversions are available
-            return pCacheItem->IsEmpty() ? &String::EmptyString() : pCacheItem->GetText();
-    return 0;
-}
-
-const String* XclImpPTItem::GetVisItemName() const
-{
-    return maItemInfo.HasVisName() ? maItemInfo.GetVisName() : GetItemName();
-}
-
-void XclImpPTItem::ReadSxvi( XclImpStream& rStrm )
-{
-    rStrm >> maItemInfo;
-}
-
-void XclImpPTItem::ConvertItem( ScDPSaveDimension& rSaveDim ) const
-{
-    if( const String* pItemName = GetItemName() )
-    {
-        ScDPSaveMember& rMember = *rSaveDim.GetMemberByName( *pItemName );
-        rMember.SetIsVisible( !::get_flag( maItemInfo.mnFlags, EXC_SXVI_HIDDEN ) );
-        rMember.SetShowDetails( !::get_flag( maItemInfo.mnFlags, EXC_SXVI_HIDEDETAIL ) );
-        if (maItemInfo.HasVisName())
-            rMember.SetLayoutName(*maItemInfo.GetVisName());
-    }
-}
-
-// ============================================================================
-
-XclImpPTField::XclImpPTField( const XclImpPivotTable& rPTable, sal_uInt16 nCacheIdx ) :
-    mrPTable( rPTable )
-{
-    maFieldInfo.mnCacheIdx = nCacheIdx;
-}
-
-// general field/item access --------------------------------------------------
-
-const XclImpPCField* XclImpPTField::GetCacheField() const
-{
-    XclImpPivotCacheRef xPCache = mrPTable.GetPivotCache();
-    return xPCache.is() ? xPCache->GetField( maFieldInfo.mnCacheIdx ) : 0;
-}
-
-const String& XclImpPTField::GetFieldName() const
-{
-    const XclImpPCField* pField = GetCacheField();
-    return pField ? pField->GetFieldName( mrPTable.GetVisFieldNames() ) : String::EmptyString();
-}
-
-const String& XclImpPTField::GetVisFieldName() const
-{
-    const String* pVisName = maFieldInfo.GetVisName();
-    return pVisName ? *pVisName : String::EmptyString();
-}
-
-const XclImpPTItem* XclImpPTField::GetItem( sal_uInt16 nItemIdx ) const
-{
-    return (nItemIdx < maItems.size()) ? maItems[ nItemIdx ].get() : 0;
-}
-
-const String* XclImpPTField::GetItemName( sal_uInt16 nItemIdx ) const
-{
-    const XclImpPTItem* pItem = GetItem( nItemIdx );
-    return pItem ? pItem->GetItemName() : 0;
-}
-
-const String* XclImpPTField::GetVisItemName( sal_uInt16 nItemIdx ) const
-{
-    const XclImpPTItem* pItem = GetItem( nItemIdx );
-    return pItem ? pItem->GetVisItemName() : 0;
-}
-
-// records --------------------------------------------------------------------
-
-void XclImpPTField::ReadSxvd( XclImpStream& rStrm )
-{
-    rStrm >> maFieldInfo;
-}
-
-void XclImpPTField::ReadSxvdex( XclImpStream& rStrm )
-{
-    rStrm >> maFieldExtInfo;
-}
-
-void XclImpPTField::ReadSxvi( XclImpStream& rStrm )
-{
-    XclImpPTItemRef xItem( new XclImpPTItem( GetCacheField() ) );
-    maItems.push_back( xItem );
-    xItem->ReadSxvi( rStrm );
-}
-
-// row/column fields ----------------------------------------------------------
-
-void XclImpPTField::ConvertRowColField( ScDPSaveData& rSaveData ) const
-{
-    DBG_ASSERT( maFieldInfo.mnAxes & EXC_SXVD_AXIS_ROWCOL, "XclImpPTField::ConvertRowColField - no row/column field" );
-    // special data orientation field?
-    if( maFieldInfo.mnCacheIdx == EXC_SXIVD_DATA )
-        rSaveData.GetDataLayoutDimension()->SetOrientation( static_cast< USHORT >( maFieldInfo.GetApiOrient( EXC_SXVD_AXIS_ROWCOL ) ) );
-    else
-        ConvertRCPField( rSaveData );
-}
-
-// page fields ----------------------------------------------------------------
-
-void XclImpPTField::SetPageFieldInfo( const XclPTPageFieldInfo& rPageInfo )
-{
-    maPageInfo = rPageInfo;
-}
-
-void XclImpPTField::ConvertPageField( ScDPSaveData& rSaveData ) const
-{
-    DBG_ASSERT( maFieldInfo.mnAxes & EXC_SXVD_AXIS_PAGE, "XclImpPTField::ConvertPageField - no page field" );
-    if( ScDPSaveDimension* pSaveDim = ConvertRCPField( rSaveData ) )
-        pSaveDim->SetCurrentPage( GetItemName( maPageInfo.mnSelItem ) );
-}
-
-// hidden fields --------------------------------------------------------------
-
-void XclImpPTField::ConvertHiddenField( ScDPSaveData& rSaveData ) const
-{
-    DBG_ASSERT( (maFieldInfo.mnAxes & EXC_SXVD_AXIS_ROWCOLPAGE) == 0, "XclImpPTField::ConvertHiddenField - field not hidden" );
-    ConvertRCPField( rSaveData );
-}
-
-// data fields ----------------------------------------------------------------
-
-bool XclImpPTField::HasDataFieldInfo() const
-{
-    return !maDataInfoList.empty();
-}
-
-void XclImpPTField::AddDataFieldInfo( const XclPTDataFieldInfo& rDataInfo )
-{
-    DBG_ASSERT( maFieldInfo.mnAxes & EXC_SXVD_AXIS_DATA, "XclImpPTField::AddDataFieldInfo - no data field" );
-    maDataInfoList.push_back( rDataInfo );
-}
-
-void XclImpPTField::ConvertDataField( ScDPSaveData& rSaveData ) const
-{
-    DBG_ASSERT( maFieldInfo.mnAxes & EXC_SXVD_AXIS_DATA, "XclImpPTField::ConvertDataField - no data field" );
-    DBG_ASSERT( !maDataInfoList.empty(), "XclImpPTField::ConvertDataField - no data field info" );
-    if( !maDataInfoList.empty() )
-    {
-        const String& rFieldName = GetFieldName();
-        if( rFieldName.Len() > 0 )
-        {
-            XclPTDataFieldInfoList::const_iterator aIt = maDataInfoList.begin(), aEnd = maDataInfoList.end();
-
-            ScDPSaveDimension& rSaveDim = *rSaveData.GetNewDimensionByName( rFieldName );
-            ConvertDataField( rSaveDim, *aIt );
-
-            // multiple data fields -> clone dimension
-            for( ++aIt; aIt != aEnd; ++aIt )
-            {
-                ScDPSaveDimension& rDupDim = rSaveData.DuplicateDimension( rSaveDim );
-                ConvertDataFieldInfo( rDupDim, *aIt );
-            }
-        }
-    }
-}
-
-// private --------------------------------------------------------------------
-
-/** 
- * Convert Excel-encoded subtotal name to a Calc-encoded one.  
- */
-static OUString lcl_convertExcelSubtotalName(const OUString& rName)
-{
-    OUStringBuffer aBuf;
-    const sal_Unicode* p = rName.getStr();
-    sal_Int32 n = rName.getLength();
-    for (sal_Int32 i = 0; i < n; ++i)
-    {
-        const sal_Unicode c = p[i];
-        if (c == sal_Unicode('\\'))
-        {
-            aBuf.append(c);
-            aBuf.append(c);
-        }
-        else
-            aBuf.append(c);
-    }
-    return aBuf.makeStringAndClear();
-}
-
-ScDPSaveDimension* XclImpPTField::ConvertRCPField( ScDPSaveData& rSaveData ) const
-{
-    const String& rFieldName = GetFieldName();
-    if( rFieldName.Len() == 0 )
-        return 0;
-
-    const XclImpPCField* pCacheField = GetCacheField();
-    if( !pCacheField || !pCacheField->IsSupportedField() )
-        return 0;
-
-    ScDPSaveDimension& rSaveDim = *rSaveData.GetNewDimensionByName( rFieldName );
-
-    // orientation
-    rSaveDim.SetOrientation( static_cast< USHORT >( maFieldInfo.GetApiOrient( EXC_SXVD_AXIS_ROWCOLPAGE ) ) );
-
-    // general field info
-    ConvertFieldInfo( rSaveDim );
-
-    // visible name
-    if( const String* pVisName = maFieldInfo.GetVisName() )
-        if( pVisName->Len() > 0 )
-            rSaveDim.SetLayoutName( *pVisName );
-
-    // subtotal function(s)
-    XclPTSubtotalVec aSubtotalVec;
-    maFieldInfo.GetSubtotals( aSubtotalVec );
-    if( !aSubtotalVec.empty() )
-        rSaveDim.SetSubTotals( static_cast< long >( aSubtotalVec.size() ), &aSubtotalVec[ 0 ] );
-
-    // sorting
-    DataPilotFieldSortInfo aSortInfo;
-    aSortInfo.Field = mrPTable.GetDataFieldName( maFieldExtInfo.mnSortField );
-    aSortInfo.IsAscending = ::get_flag( maFieldExtInfo.mnFlags, EXC_SXVDEX_SORT_ASC );
-    aSortInfo.Mode = maFieldExtInfo.GetApiSortMode();
-    rSaveDim.SetSortInfo( &aSortInfo );
-
-    // auto show
-    DataPilotFieldAutoShowInfo aShowInfo;
-    aShowInfo.IsEnabled = ::get_flag( maFieldExtInfo.mnFlags, EXC_SXVDEX_AUTOSHOW );
-    aShowInfo.ShowItemsMode = maFieldExtInfo.GetApiAutoShowMode();
-    aShowInfo.ItemCount = maFieldExtInfo.GetApiAutoShowCount();
-    aShowInfo.DataField = mrPTable.GetDataFieldName( maFieldExtInfo.mnShowField );
-    rSaveDim.SetAutoShowInfo( &aShowInfo );
-
-    // layout
-    DataPilotFieldLayoutInfo aLayoutInfo;
-    aLayoutInfo.LayoutMode = maFieldExtInfo.GetApiLayoutMode();
-    aLayoutInfo.AddEmptyLines = ::get_flag( maFieldExtInfo.mnFlags, EXC_SXVDEX_LAYOUT_BLANK );
-    rSaveDim.SetLayoutInfo( &aLayoutInfo );
-
-    // grouping info
-    pCacheField->ConvertGroupField( rSaveData, mrPTable.GetVisFieldNames() );
-
-    // custom subtotal name
-    if (maFieldExtInfo.mpFieldTotalName.get())
-    {
-        OUString aSubName = lcl_convertExcelSubtotalName(*maFieldExtInfo.mpFieldTotalName);
-        rSaveDim.SetSubtotalName(aSubName);
-    }
-
-    return &rSaveDim;
-}
-
-void XclImpPTField::ConvertFieldInfo( ScDPSaveDimension& rSaveDim ) const
-{
-    rSaveDim.SetShowEmpty( ::get_flag( maFieldExtInfo.mnFlags, EXC_SXVDEX_SHOWALL ) );
-    ConvertItems( rSaveDim );
-}
-
-void XclImpPTField::ConvertDataField( ScDPSaveDimension& rSaveDim, const XclPTDataFieldInfo& rDataInfo ) const
-{
-    // orientation
-    rSaveDim.SetOrientation( DataPilotFieldOrientation_DATA );
-    // general field info
-    ConvertFieldInfo( rSaveDim );
-    // extended data field info
-    ConvertDataFieldInfo( rSaveDim, rDataInfo );
-}
-
-void XclImpPTField::ConvertDataFieldInfo( ScDPSaveDimension& rSaveDim, const XclPTDataFieldInfo& rDataInfo ) const
-{
-    // visible name
-    if( const String* pVisName = rDataInfo.GetVisName() )
-        if( pVisName->Len() > 0 )
-            rSaveDim.SetLayoutName( *pVisName );
-
-    // aggregation function
-    rSaveDim.SetFunction( static_cast< USHORT >( rDataInfo.GetApiAggFunc() ) );
-
-    // result field reference
-    sal_Int32 nRefType = rDataInfo.GetApiRefType();
-    if( nRefType != ::com::sun::star::sheet::DataPilotFieldReferenceType::NONE )
-    {
-        DataPilotFieldReference aFieldRef;
-        aFieldRef.ReferenceType = nRefType;
-
-        if( const XclImpPTField* pRefField = mrPTable.GetField( rDataInfo.mnRefField ) )
-        {
-            aFieldRef.ReferenceField = pRefField->GetFieldName();
-            aFieldRef.ReferenceItemType = rDataInfo.GetApiRefItemType();
-            if( aFieldRef.ReferenceItemType == ::com::sun::star::sheet::DataPilotFieldReferenceItemType::NAMED )
-                if( const String* pRefItemName = pRefField->GetItemName( rDataInfo.mnRefItem ) )
-                    aFieldRef.ReferenceItemName = *pRefItemName;
-        }
-
-        rSaveDim.SetReferenceValue( &aFieldRef );
-    }
-}
-
-void XclImpPTField::ConvertItems( ScDPSaveDimension& rSaveDim ) const
-{
-    for( XclImpPTItemVec::const_iterator aIt = maItems.begin(), aEnd = maItems.end(); aIt != aEnd; ++aIt )
-        (*aIt)->ConvertItem( rSaveDim );
-}
-
-// ============================================================================
-
-XclImpPivotTable::XclImpPivotTable( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maDataOrientField( *this, EXC_SXIVD_DATA ),
-    mpDPObj(NULL)
-{
-}
-
-XclImpPivotTable::~XclImpPivotTable()
-{
-}
-
-// cache/field access, misc. --------------------------------------------------
-
-sal_uInt16 XclImpPivotTable::GetFieldCount() const
-{
-    return static_cast< sal_uInt16 >( maFields.size() );
-}
-
-const XclImpPTField* XclImpPivotTable::GetField( sal_uInt16 nFieldIdx ) const
-{
-    return (nFieldIdx == EXC_SXIVD_DATA) ? &maDataOrientField :
-        ((nFieldIdx < maFields.size()) ? maFields[ nFieldIdx ].get() : 0);
-}
-
-XclImpPTField* XclImpPivotTable::GetFieldAcc( sal_uInt16 nFieldIdx )
-{
-    // do not return maDataOrientField
-    return (nFieldIdx < maFields.size()) ? maFields[ nFieldIdx ].get() : 0;
-}
-
-const String& XclImpPivotTable::GetFieldName( sal_uInt16 nFieldIdx ) const
-{
-    if( const XclImpPTField* pField = GetField( nFieldIdx ) )
-        return pField->GetFieldName();
-    return EMPTY_STRING;
-}
-
-const XclImpPTField* XclImpPivotTable::GetDataField( sal_uInt16 nDataFieldIdx ) const
-{
-    if( nDataFieldIdx < maOrigDataFields.size() )
-        return GetField( maOrigDataFields[ nDataFieldIdx ] );
-    return 0;
-}
-
-const String& XclImpPivotTable::GetDataFieldName( sal_uInt16 nDataFieldIdx ) const
-{
-    if( const XclImpPTField* pField = GetDataField( nDataFieldIdx ) )
-        return pField->GetFieldName();
-    return EMPTY_STRING;
-}
-
-// records --------------------------------------------------------------------
-
-void XclImpPivotTable::ReadSxview( XclImpStream& rStrm )
-{
-    rStrm >> maPTInfo;
-
-    GetAddressConverter().ConvertRange(
-        maOutScRange, maPTInfo.maOutXclRange, GetCurrScTab(), GetCurrScTab(), true );
-
-    mxPCache = GetPivotTableManager().GetPivotCache( maPTInfo.mnCacheIdx );
-    mxCurrField.reset();
-}
-
-void XclImpPivotTable::ReadSxvd( XclImpStream& rStrm )
-{
-    sal_uInt16 nFieldCount = GetFieldCount();
-    if( nFieldCount < EXC_PT_MAXFIELDCOUNT )
-    {
-        // cache index for the field is equal to the SXVD record index
-        mxCurrField.reset( new XclImpPTField( *this, nFieldCount ) );
-        maFields.push_back( mxCurrField );
-        mxCurrField->ReadSxvd( rStrm );
-        // add visible name of new field to list of visible names
-        maVisFieldNames.push_back( mxCurrField->GetVisFieldName() );
-        DBG_ASSERT( maFields.size() == maVisFieldNames.size(),
-            "XclImpPivotTable::ReadSxvd - wrong size of visible name array" );
-    }
-    else
-        mxCurrField.reset();
-}
-
-void XclImpPivotTable::ReadSxvi( XclImpStream& rStrm )
-{
-    if( mxCurrField.is() )
-        mxCurrField->ReadSxvi( rStrm );
-}
-
-void XclImpPivotTable::ReadSxvdex( XclImpStream& rStrm )
-{
-    if( mxCurrField.is() )
-        mxCurrField->ReadSxvdex( rStrm );
-}
-
-void XclImpPivotTable::ReadSxivd( XclImpStream& rStrm )
-{
-    mxCurrField.reset();
-
-    // find the index vector to fill (row SXIVD doesn't exist without row fields)
-    ScfUInt16Vec* pFieldVec = 0;
-    if( maRowFields.empty() && (maPTInfo.mnRowFields > 0) )
-        pFieldVec = &maRowFields;
-    else if( maColFields.empty() && (maPTInfo.mnColFields > 0) )
-        pFieldVec = &maColFields;
-
-    // fill the vector from record data
-    if( pFieldVec )
-    {
-        sal_uInt16 nSize = ulimit_cast< sal_uInt16 >( rStrm.GetRecSize() / 2, EXC_PT_MAXROWCOLCOUNT );
-        pFieldVec->reserve( nSize );
-        for( sal_uInt16 nIdx = 0; nIdx < nSize; ++nIdx )
-        {
-            sal_uInt16 nFieldIdx;
-            rStrm >> nFieldIdx;
-            pFieldVec->push_back( nFieldIdx );
-
-            // set orientation at special data orientation field
-            if( nFieldIdx == EXC_SXIVD_DATA )
-            {
-                sal_uInt16 nAxis = (pFieldVec == &maRowFields) ? EXC_SXVD_AXIS_ROW : EXC_SXVD_AXIS_COL;
-                maDataOrientField.SetAxes( nAxis );
-            }
-        }
-    }
-}
-
-void XclImpPivotTable::ReadSxpi( XclImpStream& rStrm )
-{
-    mxCurrField.reset();
-
-    sal_uInt16 nSize = ulimit_cast< sal_uInt16 >( rStrm.GetRecSize() / 6 );
-    for( sal_uInt16 nEntry = 0; nEntry < nSize; ++nEntry )
-    {
-        XclPTPageFieldInfo aPageInfo;
-        rStrm >> aPageInfo;
-        if( XclImpPTField* pField = GetFieldAcc( aPageInfo.mnField ) )
-        {
-            maPageFields.push_back( aPageInfo.mnField );
-            pField->SetPageFieldInfo( aPageInfo );
-        }
-        GetObjectManager().SetSkipObj( GetCurrScTab(), aPageInfo.mnObjId );
-    }
-}
-
-void XclImpPivotTable::ReadSxdi( XclImpStream& rStrm )
-{
-    mxCurrField.reset();
-
-    XclPTDataFieldInfo aDataInfo;
-    rStrm >> aDataInfo;
-    if( XclImpPTField* pField = GetFieldAcc( aDataInfo.mnField ) )
-    {
-        maOrigDataFields.push_back( aDataInfo.mnField );
-        // DataPilot does not support double data fields -> add first appearence to index list only
-        if( !pField->HasDataFieldInfo() )
-            maFiltDataFields.push_back( aDataInfo.mnField );
-        pField->AddDataFieldInfo( aDataInfo );
-    }
-}
-
-void XclImpPivotTable::ReadSxex( XclImpStream& rStrm )
-{
-    rStrm >> maPTExtInfo;
-}
-
-void XclImpPivotTable::ReadSxViewEx9( XclImpStream& rStrm )
-{
-    rStrm >> maPTViewEx9Info;
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpPivotTable::Convert()
-{
-    if( !mxPCache || !mxPCache->GetSourceRange().IsValid() )
-        return;
-
-    ScDPSaveData aSaveData;
-
-    // *** global settings ***
-
-    aSaveData.SetRowGrand( ::get_flag( maPTInfo.mnFlags, EXC_SXVIEW_ROWGRAND ) );
-    aSaveData.SetColumnGrand( ::get_flag( maPTInfo.mnFlags, EXC_SXVIEW_COLGRAND ) );
-    aSaveData.SetFilterButton( FALSE );
-    aSaveData.SetDrillDown( ::get_flag( maPTExtInfo.mnFlags, EXC_SXEX_DRILLDOWN ) );
-
-    // *** fields ***
-
-    ScfUInt16Vec::const_iterator aIt, aEnd;
-
-    // row fields
-    for( aIt = maRowFields.begin(), aEnd = maRowFields.end(); aIt != aEnd; ++aIt )
-        if( const XclImpPTField* pField = GetField( *aIt ) )
-            pField->ConvertRowColField( aSaveData );
-
-    // column fields
-    for( aIt = maColFields.begin(), aEnd = maColFields.end(); aIt != aEnd; ++aIt )
-        if( const XclImpPTField* pField = GetField( *aIt ) )
-            pField->ConvertRowColField( aSaveData );
-
-    // page fields
-    for( aIt = maPageFields.begin(), aEnd = maPageFields.end(); aIt != aEnd; ++aIt )
-        if( const XclImpPTField* pField = GetField( *aIt ) )
-            pField->ConvertPageField( aSaveData );
-
-    // We need to import hidden fields because hidden fields may contain
-    // special settings for subtotals (aggregation function, filters, custom
-    // name etc.) and members (hidden, custom name etc.).
-
-    // hidden fields
-    for( sal_uInt16 nField = 0, nCount = GetFieldCount(); nField < nCount; ++nField )
-        if( const XclImpPTField* pField = GetField( nField ) )
-            if( (pField->GetAxes() & EXC_SXVD_AXIS_ROWCOLPAGE) == 0 )
-                pField->ConvertHiddenField( aSaveData );
-
-    // data fields
-    for( aIt = maFiltDataFields.begin(), aEnd = maFiltDataFields.end(); aIt != aEnd; ++aIt )
-        if( const XclImpPTField* pField = GetField( *aIt ) )
-            pField->ConvertDataField( aSaveData );
-
-    // *** insert into Calc document ***
-
-    // create source descriptor
-    ScSheetSourceDesc aDesc;
-    aDesc.aSourceRange = mxPCache->GetSourceRange();
-
-    // adjust output range to include the page fields
-    ScRange aOutRange( maOutScRange );
-    if( !maPageFields.empty() )
-    {
-        SCsROW nDecRows = ::std::min< SCsROW >( aOutRange.aStart.Row(), maPageFields.size() + 1 );
-        aOutRange.aStart.IncRow( -nDecRows );
-    }
-
-    // create the DataPilot
-    ScDPObject* pDPObj = new ScDPObject( GetDocPtr() );
-    pDPObj->SetName( maPTInfo.maTableName );
-    if (maPTInfo.maDataName.Len() > 0)
-        aSaveData.GetDataLayoutDimension()->SetLayoutName(maPTInfo.maDataName);
-
-    if (maPTViewEx9Info.maGrandTotalName.Len() > 0)
-        aSaveData.SetGrandTotalName(maPTViewEx9Info.maGrandTotalName);
-
-    pDPObj->SetSaveData( aSaveData );
-    pDPObj->SetSheetDesc( aDesc );
-    pDPObj->SetOutRange( aOutRange );
-    pDPObj->SetAlive( TRUE );
-    pDPObj->SetHeaderLayout( maPTViewEx9Info.mnGridLayout == 0 );
-
-    GetDoc().GetDPCollection()->InsertNewTable(pDPObj);
-    mpDPObj = pDPObj;
-
-    ApplyMergeFlags(aOutRange, aSaveData);
-}
-
-void XclImpPivotTable::MaybeRefresh()
-{
-    if (mpDPObj && mxPCache->IsRefreshOnLoad())
-    {
-        // 'refresh table on load' flag is set.  Refresh the table now.  Some
-        // Excel files contain partial table output when this flag is set.
-        ScRange aOutRange = mpDPObj->GetOutRange();
-        mpDPObj->Output(aOutRange.aStart);
-    }
-}
-
-void XclImpPivotTable::ApplyMergeFlags(const ScRange& rOutRange, const ScDPSaveData& rSaveData)
-{
-    // Apply merge flags for varoius datapilot controls.
-
-    ScDPOutputGeometry aGeometry(rOutRange, false, ScDPOutputGeometry::XLS);
-    aGeometry.setColumnFieldCount(maPTInfo.mnColFields);
-    aGeometry.setPageFieldCount(maPTInfo.mnPageFields);
-    aGeometry.setDataFieldCount(maPTInfo.mnDataFields);
-
-    // Excel includes data layout field in the row field count.  We need to 
-    // subtract it.
-    bool bDataLayout = maPTInfo.mnDataFields > 1;
-    aGeometry.setRowFieldCount(maPTInfo.mnRowFields - static_cast<sal_uInt32>(bDataLayout));
-
-    ScDocument& rDoc = GetDoc();
-
-    vector<ScAddress> aPageBtns;
-    aGeometry.getPageFieldPositions(aPageBtns);
-    vector<ScAddress>::const_iterator itr = aPageBtns.begin(), itrEnd = aPageBtns.end();
-    for (; itr != itrEnd; ++itr)
-    {
-        sal_uInt16 nMFlag = SC_MF_BUTTON;
-        String aName;
-        rDoc.GetString(itr->Col(), itr->Row(), itr->Tab(), aName);
-        if (rSaveData.HasInvisibleMember(aName))
-            nMFlag |= SC_MF_HIDDEN_MEMBER;
-
-        rDoc.ApplyFlagsTab(itr->Col(), itr->Row(), itr->Col(), itr->Row(), itr->Tab(), nMFlag);
-        rDoc.ApplyFlagsTab(itr->Col()+1, itr->Row(), itr->Col()+1, itr->Row(), itr->Tab(), SC_MF_AUTO);
-    }
-
-    vector<ScAddress> aColBtns;
-    aGeometry.getColumnFieldPositions(aColBtns);
-    itr    = aColBtns.begin();
-    itrEnd = aColBtns.end();
-    for (; itr != itrEnd; ++itr)
-    {
-        sal_Int16 nMFlag = SC_MF_BUTTON | SC_MF_BUTTON_POPUP;
-        String aName;
-        rDoc.GetString(itr->Col(), itr->Row(), itr->Tab(), aName);
-        if (rSaveData.HasInvisibleMember(aName))
-            nMFlag |= SC_MF_HIDDEN_MEMBER;
-        rDoc.ApplyFlagsTab(itr->Col(), itr->Row(), itr->Col(), itr->Row(), itr->Tab(), nMFlag);
-    }
-
-    vector<ScAddress> aRowBtns;
-    aGeometry.getRowFieldPositions(aRowBtns);
-    if (aRowBtns.empty())
-    {
-        if (bDataLayout)
-        {
-            // No row fields, but the data layout button exists.
-            SCROW nRow = aGeometry.getRowFieldHeaderRow();
-            SCCOL nCol = rOutRange.aStart.Col();
-            SCTAB nTab = rOutRange.aStart.Tab();
-            rDoc.ApplyFlagsTab(nCol, nRow, nCol, nRow, nTab, SC_MF_BUTTON);
-        }
-    }
-    else
-    {
-        itr    = aRowBtns.begin();
-        itrEnd = aRowBtns.end();
-        for (; itr != itrEnd; ++itr)
-        {
-            sal_Int16 nMFlag = SC_MF_BUTTON | SC_MF_BUTTON_POPUP;
-            String aName;
-            rDoc.GetString(itr->Col(), itr->Row(), itr->Tab(), aName);
-            if (rSaveData.HasInvisibleMember(aName))
-                nMFlag |= SC_MF_HIDDEN_MEMBER;
-            rDoc.ApplyFlagsTab(itr->Col(), itr->Row(), itr->Col(), itr->Row(), itr->Tab(), nMFlag);
-        }
-        if (bDataLayout)
-        {
-            --itr; // move back to the last row field position.
-            rDoc.ApplyFlagsTab(itr->Col(), itr->Row(), itr->Col(), itr->Row(), itr->Tab(), SC_MF_BUTTON);
-        }
-    }
-}
-
-// ============================================================================
-// ============================================================================
-
-XclImpPivotTableManager::XclImpPivotTableManager( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-XclImpPivotTableManager::~XclImpPivotTableManager()
-{
-}
-
-// pivot cache records --------------------------------------------------------
-
-XclImpPivotCacheRef XclImpPivotTableManager::GetPivotCache( sal_uInt16 nCacheIdx )
-{
-    XclImpPivotCacheRef xPCache;
-    if( nCacheIdx < maPCaches.size() )
-        xPCache = maPCaches[ nCacheIdx ];
-    return xPCache;
-}
-
-void XclImpPivotTableManager::ReadSxidstm( XclImpStream& rStrm )
-{
-    XclImpPivotCacheRef xPCache( new XclImpPivotCache( GetRoot() ) );
-    maPCaches.push_back( xPCache );
-    xPCache->ReadSxidstm( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxvs( XclImpStream& rStrm )
-{
-    if( !maPCaches.empty() )
-        maPCaches.back()->ReadSxvs( rStrm );
-}
-
-void XclImpPivotTableManager::ReadDconref( XclImpStream& rStrm )
-{
-    if( !maPCaches.empty() )
-        maPCaches.back()->ReadDconref( rStrm );
-}
-
-// pivot table records --------------------------------------------------------
-
-void XclImpPivotTableManager::ReadSxview( XclImpStream& rStrm )
-{
-    XclImpPivotTableRef xPTable( new XclImpPivotTable( GetRoot() ) );
-    maPTables.push_back( xPTable );
-    xPTable->ReadSxview( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxvd( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxvd( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxvdex( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxvdex( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxivd( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxivd( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxpi( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxpi( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxdi( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxdi( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxvi( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxvi( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxex( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxex( rStrm );
-}
-
-void XclImpPivotTableManager::ReadSxViewEx9( XclImpStream& rStrm )
-{
-    if( !maPTables.empty() )
-        maPTables.back()->ReadSxViewEx9( rStrm );
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpPivotTableManager::ReadPivotCaches( XclImpStream& rStrm )
-{
-    for( XclImpPivotCacheVec::iterator aIt = maPCaches.begin(), aEnd = maPCaches.end(); aIt != aEnd; ++aIt )
-        (*aIt)->ReadPivotCacheStream( rStrm );
-}
-
-void XclImpPivotTableManager::ConvertPivotTables()
-{
-    for( XclImpPivotTableVec::iterator aIt = maPTables.begin(), aEnd = maPTables.end(); aIt != aEnd; ++aIt )
-        (*aIt)->Convert();
-}
-
-void XclImpPivotTableManager::MaybeRefreshPivotTables()
-{
-    for( XclImpPivotTableVec::iterator aIt = maPTables.begin(), aEnd = maPTables.end(); aIt != aEnd; ++aIt )
-        (*aIt)->MaybeRefresh();
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xiroot.cxx sc/source/filter/xlsx/xlsx-xiroot.cxx
deleted file mode 100644
index 30cab47..0000000
--- sc/source/filter/xlsx/xlsx-xiroot.cxx
+++ /dev/null
@@ -1,273 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xiroot.cxx,v $
- * $Revision: 1.24.88.2 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xiroot.hxx"
-#include "addincol.hxx"
-#include "xltracer.hxx"
-#include "xihelper.hxx"
-#include "xiformula.hxx"
-#include "xilink.hxx"
-#include "xiname.hxx"
-#include "xistyle.hxx"
-#include "xicontent.hxx"
-#include "xiescher.hxx"
-#include "xipivot.hxx"
-#include "xipage.hxx"
-#include "xiview.hxx"
-
-#include "root.hxx"
-#include "excimp8.hxx"
-
-// Global data ================================================================
-
-XclImpRootData::XclImpRootData( XclBiff eBiff, SfxMedium& rMedium,
-        SotStorageRef xRootStrg, ScDocument& rDoc, rtl_TextEncoding eTextEnc ) :
-    XclRootData( eBiff, rMedium, xRootStrg, rDoc, eTextEnc, false ),
-    mbHasCodePage( false )
-{
-}
-
-XclImpRootData::~XclImpRootData()
-{
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpRoot::XclImpRoot( XclImpRootData& rImpRootData ) :
-    XclRoot( rImpRootData ),
-    mrImpData( rImpRootData )
-{
-    mrImpData.mxAddrConv.reset( new XclImpAddressConverter( GetRoot() ) );
-    mrImpData.mxFmlaComp.reset( new XclImpFormulaCompiler( GetRoot() ) );
-    mrImpData.mxPalette.reset( new XclImpPalette( GetRoot() ) );
-    mrImpData.mxFontBfr.reset( new XclImpFontBuffer( GetRoot() ) );
-    mrImpData.mxNumFmtBfr.reset( new XclImpNumFmtBuffer( GetRoot() ) );
-    mrImpData.mpXFBfr.reset( new XclImpXFBuffer( GetRoot() ) );
-    mrImpData.mxXFRangeBfr.reset( new XclImpXFRangeBuffer( GetRoot() ) );
-    mrImpData.mxTabInfo.reset( new XclImpTabInfo );
-    mrImpData.mxNameMgr.reset( new XclImpNameManager( GetRoot() ) );
-    mrImpData.mxObjMgr.reset( new XclImpObjectManager( GetRoot() ) );
-
-    if( GetBiff() == EXC_BIFF8 )
-    {
-        mrImpData.mxLinkMgr.reset( new XclImpLinkManager( GetRoot() ) );
-        mrImpData.mxSst.reset( new XclImpSst( GetRoot() ) );
-        mrImpData.mxCondFmtMgr.reset( new XclImpCondFormatManager( GetRoot() ) );
-        // TODO still in old RootData (deleted by RootData)
-        GetOldRoot().pAutoFilterBuffer = new XclImpAutoFilterBuffer;
-        mrImpData.mxWebQueryBfr.reset( new XclImpWebQueryBuffer( GetRoot() ) );
-        mrImpData.mxPTableMgr.reset( new XclImpPivotTableManager( GetRoot() ) );
-        mrImpData.mxTabProtect.reset( new XclImpSheetProtectBuffer( GetRoot() ) );
-        mrImpData.mxDocProtect.reset( new XclImpDocProtectBuffer( GetRoot() ) );
-    }
-
-    mrImpData.mxPageSett.reset( new XclImpPageSettings( GetRoot() ) );
-    mrImpData.mxDocViewSett.reset( new XclImpDocViewSettings( GetRoot() ) );
-    mrImpData.mxTabViewSett.reset( new XclImpTabViewSettings( GetRoot() ) );
-}
-
-void XclImpRoot::SetCodePage( sal_uInt16 nCodePage )
-{
-    SetTextEncoding( XclTools::GetTextEncoding( nCodePage ) );
-    mrImpData.mbHasCodePage = true;
-}
-
-void XclImpRoot::SetAppFontEncoding( rtl_TextEncoding eAppFontEnc )
-{
-    if( !mrImpData.mbHasCodePage )
-        SetTextEncoding( eAppFontEnc );
-}
-
-void XclImpRoot::InitializeTable( SCTAB /*nScTab*/ )
-{
-    if( GetBiff() <= EXC_BIFF4 )
-    {
-        GetPalette().Initialize();
-        GetFontBuffer().Initialize();
-        GetNumFmtBuffer().Initialize();
-        GetXFBuffer().Initialize();
-    }
-    GetXFRangeBuffer().Initialize();
-    GetPageSettings().Initialize();
-    GetTabViewSettings().Initialize();
-}
-
-void XclImpRoot::FinalizeTable()
-{
-    GetXFRangeBuffer().Finalize();
-    GetOldRoot().pColRowBuff->Convert( GetCurrScTab() );
-    GetPageSettings().Finalize();
-    GetTabViewSettings().Finalize();
-}
-
-XclImpAddressConverter& XclImpRoot::GetAddressConverter() const
-{
-    return *mrImpData.mxAddrConv;
-}
-
-XclImpFormulaCompiler& XclImpRoot::GetFormulaCompiler() const
-{
-    return *mrImpData.mxFmlaComp;
-}
-
-ExcelToSc& XclImpRoot::GetOldFmlaConverter() const
-{
-    // TODO still in old RootData
-    return *GetOldRoot().pFmlaConverter;
-}
-
-XclImpSst& XclImpRoot::GetSst() const
-{
-    DBG_ASSERT( mrImpData.mxSst.is(), "XclImpRoot::GetSst - invalid call, wrong BIFF" );
-    return *mrImpData.mxSst;
-}
-
-XclImpPalette& XclImpRoot::GetPalette() const
-{
-    return *mrImpData.mxPalette;
-}
-
-XclImpFontBuffer& XclImpRoot::GetFontBuffer() const
-{
-    return *mrImpData.mxFontBfr;
-}
-
-XclImpNumFmtBuffer& XclImpRoot::GetNumFmtBuffer() const
-{
-    return *mrImpData.mxNumFmtBfr;
-}
-
-XclImpXFBuffer& XclImpRoot::GetXFBuffer() const
-{
-    return *mrImpData.mpXFBfr;
-}
-
-XclImpXFRangeBuffer& XclImpRoot::GetXFRangeBuffer() const
-{
-    return *mrImpData.mxXFRangeBfr;
-}
-
-_ScRangeListTabs& XclImpRoot::GetPrintAreaBuffer() const
-{
-    // TODO still in old RootData
-    return *GetOldRoot().pPrintRanges;
-}
-
-_ScRangeListTabs& XclImpRoot::GetTitleAreaBuffer() const
-{
-    // TODO still in old RootData
-    return *GetOldRoot().pPrintTitles;
-}
-
-XclImpTabInfo& XclImpRoot::GetTabInfo() const
-{
-    return *mrImpData.mxTabInfo;
-}
-
-XclImpNameManager& XclImpRoot::GetNameManager() const
-{
-    return *mrImpData.mxNameMgr;
-}
-
-XclImpLinkManager& XclImpRoot::GetLinkManager() const
-{
-    DBG_ASSERT( mrImpData.mxLinkMgr.is(), "XclImpRoot::GetLinkManager - invalid call, wrong BIFF" );
-    return *mrImpData.mxLinkMgr;
-}
-
-XclImpObjectManager& XclImpRoot::GetObjectManager() const
-{
-    return *mrImpData.mxObjMgr;
-}
-
-XclImpCondFormatManager& XclImpRoot::GetCondFormatManager() const
-{
-    DBG_ASSERT( mrImpData.mxCondFmtMgr.is(), "XclImpRoot::GetCondFormatManager - invalid call, wrong BIFF" );
-    return *mrImpData.mxCondFmtMgr;
-}
-
-XclImpAutoFilterBuffer& XclImpRoot::GetFilterManager() const
-{
-    // TODO still in old RootData
-    DBG_ASSERT( GetOldRoot().pAutoFilterBuffer, "XclImpRoot::GetFilterManager - invalid call, wrong BIFF" );
-    return *GetOldRoot().pAutoFilterBuffer;
-}
-
-XclImpWebQueryBuffer& XclImpRoot::GetWebQueryBuffer() const
-{
-    DBG_ASSERT( mrImpData.mxWebQueryBfr.is(), "XclImpRoot::GetWebQueryBuffer - invalid call, wrong BIFF" );
-    return *mrImpData.mxWebQueryBfr;
-}
-
-XclImpPivotTableManager& XclImpRoot::GetPivotTableManager() const
-{
-    DBG_ASSERT( mrImpData.mxPTableMgr.is(), "XclImpRoot::GetPivotTableManager - invalid call, wrong BIFF" );
-    return *mrImpData.mxPTableMgr;
-}
-
-XclImpSheetProtectBuffer& XclImpRoot::GetSheetProtectBuffer() const
-{
-    DBG_ASSERT( mrImpData.mxTabProtect.is(), "XclImpRoot::GetSheetProtectBuffer - invalid call, wrong BIFF" );
-    return *mrImpData.mxTabProtect;
-}
-
-XclImpDocProtectBuffer& XclImpRoot::GetDocProtectBuffer() const
-{
-    DBG_ASSERT( mrImpData.mxDocProtect.is(), "XclImpRoot::GetDocProtectBuffer - invalid call, wrong BIFF" );
-    return *mrImpData.mxDocProtect;
-}
-
-XclImpPageSettings& XclImpRoot::GetPageSettings() const
-{
-    return *mrImpData.mxPageSett;
-}
-
-XclImpDocViewSettings& XclImpRoot::GetDocViewSettings() const
-{
-    return *mrImpData.mxDocViewSett;
-}
-
-XclImpTabViewSettings& XclImpRoot::GetTabViewSettings() const
-{
-    return *mrImpData.mxTabViewSett;
-}
-
-String XclImpRoot::GetScAddInName( const String& rXclName ) const
-{
-    String aScName;
-    if( ScGlobal::GetAddInCollection()->GetCalcName( rXclName, aScName ) )
-        return aScName;
-    return rXclName;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xistream.cxx sc/source/filter/xlsx/xlsx-xistream.cxx
deleted file mode 100644
index a040f21..0000000
--- sc/source/filter/xlsx/xlsx-xistream.cxx
+++ /dev/null
@@ -1,1105 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xistream.cxx,v $
- * $Revision: 1.22.30.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-
-#include "xistream.hxx"
-#include "xlstring.hxx"
-#include "xiroot.hxx"
-
-#include <vector>
-
-using ::rtl::OString;
-using ::rtl::OUString;
-using ::rtl::OUStringToOString;
-
-// ============================================================================
-// Decryption
-// ============================================================================
-
-XclImpDecrypter::XclImpDecrypter() :
-    mnError( EXC_ENCR_ERROR_UNSUPP_CRYPT ),
-    mnOldPos( STREAM_SEEK_TO_END ),
-    mnRecSize( 0 )
-{
-}
-
-XclImpDecrypter::XclImpDecrypter( const XclImpDecrypter& rSrc ) :
-    ::comphelper::IDocPasswordVerifier(),
-    mnError( rSrc.mnError ),
-    mnOldPos( STREAM_SEEK_TO_END ),
-    mnRecSize( 0 )
-{
-}
-
-XclImpDecrypter::~XclImpDecrypter()
-{
-}
-
-XclImpDecrypterRef XclImpDecrypter::Clone() const
-{
-    XclImpDecrypterRef xNewDecr;
-    if( IsValid() )
-        xNewDecr.reset( OnClone() );
-    return xNewDecr;
-}
-
-::comphelper::DocPasswordVerifierResult XclImpDecrypter::verifyPassword( const OUString& rPassword )
-{
-    bool bValid = OnVerify( rPassword );
-    mnError = bValid ? ERRCODE_NONE : ERRCODE_ABORT;
-    return bValid ? ::comphelper::DocPasswordVerifierResult_OK : ::comphelper::DocPasswordVerifierResult_WRONG_PASSWORD;
-}
-
-void XclImpDecrypter::Update( SvStream& rStrm, sal_uInt16 nRecSize )
-{
-    if( IsValid() )
-    {
-        sal_Size nNewPos = rStrm.Tell();
-        if( (mnOldPos != nNewPos) || (mnRecSize != nRecSize) )
-        {
-            OnUpdate( mnOldPos, nNewPos, nRecSize );
-            mnOldPos = nNewPos;
-            mnRecSize = nRecSize;
-        }
-    }
-}
-
-sal_uInt16 XclImpDecrypter::Read( SvStream& rStrm, void* pData, sal_uInt16 nBytes )
-{
-    sal_uInt16 nRet = 0;
-    if( pData && nBytes )
-    {
-        if( IsValid() )
-        {
-            Update( rStrm, mnRecSize );
-            nRet = OnRead( rStrm, reinterpret_cast< sal_uInt8* >( pData ), nBytes );
-            mnOldPos = rStrm.Tell();
-        }
-        else
-            nRet = static_cast< sal_uInt16 >( rStrm.Read( pData, nBytes ) );
-    }
-    return nRet;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpBiff5Decrypter::XclImpBiff5Decrypter( sal_uInt16 nKey, sal_uInt16 nHash ) :
-    maPassword( 16 ),
-    mnKey( nKey ),
-    mnHash( nHash )
-{
-}
-
-XclImpBiff5Decrypter::XclImpBiff5Decrypter( const XclImpBiff5Decrypter& rSrc ) :
-    XclImpDecrypter( rSrc ),
-    maPassword( rSrc.maPassword ),
-    mnKey( rSrc.mnKey ),
-    mnHash( rSrc.mnHash )
-{
-    if( IsValid() )
-        maCodec.InitKey( &maPassword.front() );
-}
-
-XclImpBiff5Decrypter* XclImpBiff5Decrypter::OnClone() const
-{
-    return new XclImpBiff5Decrypter( *this );
-}
-
-bool XclImpBiff5Decrypter::OnVerify( const OUString& rPassword )
-{
-    /*  Convert password to a byte string. TODO: this needs some finetuning
-        according to the spec... */
-    OString aBytePassword = OUStringToOString( rPassword, osl_getThreadTextEncoding() );
-    sal_Int32 nLen = aBytePassword.getLength();
-    if( (0 < nLen) && (nLen < 16) )
-    {
-        // copy byte string to sal_uInt8 array
-        maPassword.clear();
-        maPassword.resize( 16, 0 );
-        memcpy( &maPassword.front(), aBytePassword.getStr(), static_cast< size_t >( nLen ) );
-
-        // init codec
-        maCodec.InitKey( &maPassword.front() );
-        return maCodec.VerifyKey( mnKey, mnHash );
-    }
-    return false;
-}
-
-void XclImpBiff5Decrypter::OnUpdate( sal_Size /*nOldStrmPos*/, sal_Size nNewStrmPos, sal_uInt16 nRecSize )
-{
-    maCodec.InitCipher();
-    maCodec.Skip( (nNewStrmPos + nRecSize) & 0x0F );
-}
-
-sal_uInt16 XclImpBiff5Decrypter::OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes )
-{
-    sal_uInt16 nRet = static_cast< sal_uInt16 >( rStrm.Read( pnData, nBytes ) );
-    maCodec.Decode( pnData, nRet );
-    return nRet;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpBiff8Decrypter::XclImpBiff8Decrypter( sal_uInt8 pnSalt[ 16 ],
-        sal_uInt8 pnVerifier[ 16 ], sal_uInt8 pnVerifierHash[ 16 ] ) :
-    maPassword( 16, 0 ),
-    maSalt( pnSalt, pnSalt + 16 ),
-    maVerifier( pnVerifier, pnVerifier + 16 ),
-    maVerifierHash( pnVerifierHash, pnVerifierHash + 16 )
-{
-}
-
-XclImpBiff8Decrypter::XclImpBiff8Decrypter( const XclImpBiff8Decrypter& rSrc ) :
-    XclImpDecrypter( rSrc ),
-    maPassword( rSrc.maPassword ),
-    maSalt( rSrc.maSalt ),
-    maVerifier( rSrc.maVerifier ),
-    maVerifierHash( rSrc.maVerifierHash )
-{
-    if( IsValid() )
-        maCodec.InitKey( &maPassword.front(), &maSalt.front() );
-}
-
-XclImpBiff8Decrypter* XclImpBiff8Decrypter::OnClone() const
-{
-    return new XclImpBiff8Decrypter( *this );
-}
-
-bool XclImpBiff8Decrypter::OnVerify( const OUString& rPassword )
-{
-    sal_Int32 nLen = rPassword.getLength();
-    if( (0 < nLen) && (nLen < 16) )
-    {
-        // copy string to sal_uInt16 array
-        maPassword.clear();
-        maPassword.resize( 16, 0 );
-        const sal_Unicode* pcChar = rPassword.getStr();
-        const sal_Unicode* pcCharEnd = pcChar + nLen;
-        ::std::vector< sal_uInt16 >::iterator aIt = maPassword.begin();
-        for( ; pcChar < pcCharEnd; ++pcChar, ++aIt )
-            *aIt = static_cast< sal_uInt16 >( *pcChar );
-
-        // init codec
-        maCodec.InitKey( &maPassword.front(), &maSalt.front() );
-        return maCodec.VerifyKey( &maVerifier.front(), &maVerifierHash.front() );
-    }
-    return false;
-}
-
-void XclImpBiff8Decrypter::OnUpdate( sal_Size nOldStrmPos, sal_Size nNewStrmPos, sal_uInt16 /*nRecSize*/ )
-{
-    if( nNewStrmPos != nOldStrmPos )
-    {
-        sal_uInt32 nOldBlock = GetBlock( nOldStrmPos );
-        sal_uInt16 nOldOffset = GetOffset( nOldStrmPos );
-
-        sal_uInt32 nNewBlock = GetBlock( nNewStrmPos );
-        sal_uInt16 nNewOffset = GetOffset( nNewStrmPos );
-
-        /*  Rekey cipher, if block changed or if previous offset in same block. */
-        if( (nNewBlock != nOldBlock) || (nNewOffset < nOldOffset) )
-        {
-            maCodec.InitCipher( nNewBlock );
-            nOldOffset = 0;     // reset nOldOffset for next if() statement
-        }
-
-        /*  Seek to correct offset. */
-        if( nNewOffset > nOldOffset )
-            maCodec.Skip( nNewOffset - nOldOffset );
-    }
-}
-
-sal_uInt16 XclImpBiff8Decrypter::OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes )
-{
-    sal_uInt16 nRet = 0;
-
-    sal_uInt8* pnCurrData = pnData;
-    sal_uInt16 nBytesLeft = nBytes;
-    while( nBytesLeft )
-    {
-        sal_uInt16 nBlockLeft = EXC_ENCR_BLOCKSIZE - GetOffset( rStrm.Tell() );
-        sal_uInt16 nDecBytes = ::std::min< sal_uInt16 >( nBytesLeft, nBlockLeft );
-
-        // read the block from stream
-        nRet = nRet + static_cast< sal_uInt16 >( rStrm.Read( pnCurrData, nDecBytes ) );
-        // decode the block inplace
-        maCodec.Decode( pnCurrData, nDecBytes, pnCurrData, nDecBytes );
-        if( GetOffset( rStrm.Tell() ) == 0 )
-            maCodec.InitCipher( GetBlock( rStrm.Tell() ) );
-
-        pnCurrData += nDecBytes;
-        nBytesLeft = nBytesLeft - nDecBytes;
-    }
-
-    return nRet;
-}
-
-sal_uInt32 XclImpBiff8Decrypter::GetBlock( sal_Size nStrmPos ) const
-{
-    return static_cast< sal_uInt32 >( nStrmPos / EXC_ENCR_BLOCKSIZE );
-}
-
-sal_uInt16 XclImpBiff8Decrypter::GetOffset( sal_Size nStrmPos ) const
-{
-    return static_cast< sal_uInt16 >( nStrmPos % EXC_ENCR_BLOCKSIZE );
-}
-
-// ============================================================================
-// Stream
-// ============================================================================
-
-XclImpStreamPos::XclImpStreamPos() :
-    mnPos( STREAM_SEEK_TO_BEGIN ),
-    mnNextPos( STREAM_SEEK_TO_BEGIN ),
-    mnCurrSize( 0 ),
-    mnRawRecId( EXC_ID_UNKNOWN ),
-    mnRawRecSize( 0 ),
-    mnRawRecLeft( 0 ),
-    mbValid( false )
-{
-}
-
-void XclImpStreamPos::Set(
-        const SvStream& rStrm, sal_Size nNextPos, sal_Size nCurrSize,
-        sal_uInt16 nRawRecId, sal_uInt16 nRawRecSize, sal_uInt16 nRawRecLeft,
-        bool bValid )
-{
-    mnPos = rStrm.Tell();
-    mnNextPos = nNextPos;
-    mnCurrSize = nCurrSize;
-    mnRawRecId = nRawRecId;
-    mnRawRecSize = nRawRecSize;
-    mnRawRecLeft = nRawRecLeft;
-    mbValid = bValid;
-}
-
-void XclImpStreamPos::Get(
-        SvStream& rStrm, sal_Size& rnNextPos, sal_Size& rnCurrSize,
-        sal_uInt16& rnRawRecId, sal_uInt16& rnRawRecSize, sal_uInt16& rnRawRecLeft,
-        bool& rbValid ) const
-{
-    rStrm.Seek( mnPos );
-    rnNextPos = mnNextPos;
-    rnCurrSize = mnCurrSize;
-    rnRawRecId = mnRawRecId;
-    rnRawRecSize = mnRawRecSize;
-    rnRawRecLeft = mnRawRecLeft;
-    rbValid = mbValid;
-}
-
-// ============================================================================
-
-XclBiff XclImpStream::DetectBiffVersion( SvStream& rStrm )
-{
-    XclBiff eBiff = EXC_BIFF_UNKNOWN;
-
-    rStrm.Seek( STREAM_SEEK_TO_BEGIN );
-    sal_uInt16 nBofId, nBofSize;
-    rStrm >> nBofId >> nBofSize;
-
-    if( (4 <= nBofSize) && (nBofSize <= 16) ) switch( nBofId )
-    {
-        case EXC_ID2_BOF:
-            eBiff = EXC_BIFF2;
-        break;
-        case EXC_ID3_BOF:
-            eBiff = EXC_BIFF3;
-        break;
-        case EXC_ID4_BOF:
-            eBiff = EXC_BIFF4;
-        break;
-        case EXC_ID5_BOF:
-        {
-            sal_uInt16 nVersion;
-            rStrm >> nVersion;
-            // #i23425# #i44031# #i62752# there are some *really* broken documents out there...
-            switch( nVersion & 0xFF00 )
-            {
-                case 0:             eBiff = EXC_BIFF5;  break;  // #i44031# #i62752#
-                case EXC_BOF_BIFF2: eBiff = EXC_BIFF2;  break;
-                case EXC_BOF_BIFF3: eBiff = EXC_BIFF3;  break;
-                case EXC_BOF_BIFF4: eBiff = EXC_BIFF4;  break;
-                case EXC_BOF_BIFF5: eBiff = EXC_BIFF5;  break;
-                case EXC_BOF_BIFF8: eBiff = EXC_BIFF8;  break;
-                default:    DBG_ERROR1( "XclImpStream::DetectBiffVersion - unknown BIFF version: 0x%04hX", nVersion );
-            }
-        }
-        break;
-    }
-    return eBiff;
-}
-
-XclImpStream::XclImpStream( SvStream& rInStrm, const XclImpRoot& rRoot, bool bContLookup ) :
-    mrStrm( rInStrm ),
-    mrRoot( rRoot ),
-    mnGlobRecId( EXC_ID_UNKNOWN ),
-    mbGlobValidRec( false ),
-    mbHasGlobPos( false ),
-    mnNextRecPos( STREAM_SEEK_TO_BEGIN ),
-    mnCurrRecSize( 0 ),
-    mnComplRecSize( 0 ),
-    mbHasComplRec( false ),
-    mnRecId( EXC_ID_UNKNOWN ),
-    mnAltContId( EXC_ID_UNKNOWN ),
-    mnRawRecId( EXC_ID_UNKNOWN ),
-    mnRawRecSize( 0 ),
-    mnRawRecLeft( 0 ),
-    mcNulSubst( '?' ),
-    mbCont( bContLookup ),
-    mbUseDecr( false ),
-    mbValidRec( false ),
-    mbValid( false )
-{
-    mrStrm.Seek( STREAM_SEEK_TO_END );
-    mnStreamSize = mrStrm.Tell();
-    mrStrm.Seek( STREAM_SEEK_TO_BEGIN );
-    DBG_ASSERT( mnStreamSize < STREAM_SEEK_TO_END, "XclImpStream::XclImpStream - stream error" );
-}
-
-XclImpStream::~XclImpStream()
-{
-}
-
-bool XclImpStream::StartNextRecord()
-{
-    maPosStack.clear();
-
-    /*  #i4266# Counter to ignore zero records (id==len==0) (i.e. the application
-        "Crystal Report" writes zero records between other records) */
-    sal_Size nZeroRecCount = 5;
-    bool bIsZeroRec = false;
-
-    do
-    {
-        mbValidRec = ReadNextRawRecHeader();
-        bIsZeroRec = (mnRawRecId == 0) && (mnRawRecSize == 0);
-        if( bIsZeroRec ) --nZeroRecCount;
-        mnNextRecPos = mrStrm.Tell() + mnRawRecSize;
-    }
-    while( mbValidRec && ((mbCont && IsContinueId( mnRawRecId )) || (bIsZeroRec && nZeroRecCount)) );
-
-    mbValidRec = mbValidRec && !bIsZeroRec;
-    mbValid = mbValidRec;
-    SetupRecord();
-
-    return mbValidRec;
-}
-
-bool XclImpStream::StartNextRecord( sal_Size nNextRecPos )
-{
-    mnNextRecPos = nNextRecPos;
-    return StartNextRecord();
-}
-
-void XclImpStream::ResetRecord( bool bContLookup, sal_uInt16 nAltContId )
-{
-    if( mbValidRec )
-    {
-        maPosStack.clear();
-        RestorePosition( maFirstRec );
-        mnCurrRecSize = mnComplRecSize = mnRawRecSize;
-        mbHasComplRec = !bContLookup;
-        mbCont = bContLookup;
-        mnAltContId = nAltContId;
-        EnableDecryption();
-    }
-}
-
-void XclImpStream::SetDecrypter( XclImpDecrypterRef xDecrypter )
-{
-    mxDecrypter = xDecrypter;
-    EnableDecryption();
-    SetupDecrypter();
-}
-
-void XclImpStream::CopyDecrypterFrom( const XclImpStream& rStrm )
-{
-    XclImpDecrypterRef xNewDecr;
-    if( rStrm.mxDecrypter.is() )
-        xNewDecr = rStrm.mxDecrypter->Clone();
-    SetDecrypter( xNewDecr );
-}
-
-bool XclImpStream::HasValidDecrypter() const
-{
-    return mxDecrypter.is() && mxDecrypter->IsValid();
-}
-
-void XclImpStream::EnableDecryption( bool bEnable )
-{
-    mbUseDecr = bEnable && HasValidDecrypter();
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpStream::PushPosition()
-{
-    maPosStack.push_back( XclImpStreamPos() );
-    StorePosition( maPosStack.back() );
-}
-
-void XclImpStream::PopPosition()
-{
-    DBG_ASSERT( !maPosStack.empty(), "XclImpStream::PopPosition - stack empty" );
-    if( !maPosStack.empty() )
-    {
-        RestorePosition( maPosStack.back() );
-        maPosStack.pop_back();
-    }
-}
-
-//UNUSED2008-05  void XclImpStream::RejectPosition()
-//UNUSED2008-05  {
-//UNUSED2008-05      DBG_ASSERT( !maPosStack.empty(), "XclImpStream::RejectPosition - stack empty" );
-//UNUSED2008-05      if( !maPosStack.empty() )
-//UNUSED2008-05          maPosStack.pop_back();
-//UNUSED2008-05  }
-
-void XclImpStream::StoreGlobalPosition()
-{
-    StorePosition( maGlobPos );
-    mnGlobRecId = mnRecId;
-    mbGlobValidRec = mbValidRec;
-    mbHasGlobPos = true;
-}
-
-void XclImpStream::SeekGlobalPosition()
-{
-    DBG_ASSERT( mbHasGlobPos, "XclImpStream::SeekGlobalPosition - no position stored" );
-    if( mbHasGlobPos )
-    {
-        RestorePosition( maGlobPos );
-        mnRecId = mnGlobRecId;
-        mnComplRecSize = mnCurrRecSize;
-        mbHasComplRec = !mbCont;
-        mbValidRec = mbGlobValidRec;
-    }
-}
-
-sal_Size XclImpStream::GetRecPos() const
-{
-    return mbValid ? (mnCurrRecSize - mnRawRecLeft) : EXC_REC_SEEK_TO_END;
-}
-
-sal_Size XclImpStream::GetRecSize()
-{
-    if( !mbHasComplRec )
-    {
-        PushPosition();
-        while( JumpToNextContinue() ) ;  // JumpToNextContinue() adds up mnCurrRecSize
-        mnComplRecSize = mnCurrRecSize;
-        mbHasComplRec = true;
-        PopPosition();
-    }
-    return mnComplRecSize;
-}
-
-sal_Size XclImpStream::GetRecLeft()
-{
-    return mbValid ? (GetRecSize() - GetRecPos()) : 0;
-}
-
-sal_uInt16 XclImpStream::GetNextRecId()
-{
-    sal_uInt16 nRecId = EXC_ID_UNKNOWN;
-    if( mbValidRec )
-    {
-        PushPosition();
-        while( JumpToNextContinue() ) ;  // skip following CONTINUE records
-        if( mnNextRecPos < mnStreamSize )
-        {
-            mrStrm.Seek( mnNextRecPos );
-            mrStrm >> nRecId;
-        }
-        PopPosition();
-    }
-    return nRecId;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpStream& XclImpStream::operator>>( sal_Int8& rnValue )
-{
-    if( EnsureRawReadSize( 1 ) )
-    {
-        if( mbUseDecr )
-            mxDecrypter->Read( mrStrm, &rnValue, 1 );
-        else
-            mrStrm >> rnValue;
-        --mnRawRecLeft;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( sal_uInt8& rnValue )
-{
-    if( EnsureRawReadSize( 1 ) )
-    {
-        if( mbUseDecr )
-            mxDecrypter->Read( mrStrm, &rnValue, 1 );
-        else
-            mrStrm >> rnValue;
-        --mnRawRecLeft;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( sal_Int16& rnValue )
-{
-    if( EnsureRawReadSize( 2 ) )
-    {
-        if( mbUseDecr )
-        {
-            SVBT16 pnBuffer;
-            mxDecrypter->Read( mrStrm, pnBuffer, 2 );
-            rnValue = static_cast< sal_Int16 >( SVBT16ToShort( pnBuffer ) );
-        }
-        else
-            mrStrm >> rnValue;
-        mnRawRecLeft -= 2;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( sal_uInt16& rnValue )
-{
-    if( EnsureRawReadSize( 2 ) )
-    {
-        if( mbUseDecr )
-        {
-            SVBT16 pnBuffer;
-            mxDecrypter->Read( mrStrm, pnBuffer, 2 );
-            rnValue = SVBT16ToShort( pnBuffer );
-        }
-        else
-            mrStrm >> rnValue;
-        mnRawRecLeft -= 2;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( sal_Int32& rnValue )
-{
-    if( EnsureRawReadSize( 4 ) )
-    {
-        if( mbUseDecr )
-        {
-            SVBT32 pnBuffer;
-            mxDecrypter->Read( mrStrm, pnBuffer, 4 );
-            rnValue = static_cast< sal_Int32 >( SVBT32ToUInt32( pnBuffer ) );
-        }
-        else
-            mrStrm >> rnValue;
-        mnRawRecLeft -= 4;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( sal_uInt32& rnValue )
-{
-    if( EnsureRawReadSize( 4 ) )
-    {
-        if( mbUseDecr )
-        {
-            SVBT32 pnBuffer;
-            mxDecrypter->Read( mrStrm, pnBuffer, 4 );
-            rnValue = SVBT32ToUInt32( pnBuffer );
-        }
-        else
-            mrStrm >> rnValue;
-        mnRawRecLeft -= 4;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( float& rfValue )
-{
-    if( EnsureRawReadSize( 4 ) )
-    {
-        if( mbUseDecr )
-        {
-            SVBT32 pnBuffer;
-            mxDecrypter->Read( mrStrm, pnBuffer, 4 );
-            sal_uInt32 nValue = SVBT32ToUInt32( pnBuffer );
-            memcpy( &rfValue, &nValue, 4 );
-        }
-        else
-            mrStrm >> rfValue;
-        mnRawRecLeft -= 4;
-    }
-    return *this;
-}
-
-XclImpStream& XclImpStream::operator>>( double& rfValue )
-{
-    if( EnsureRawReadSize( 8 ) )
-    {
-        if( mbUseDecr )
-        {
-            SVBT64 pnBuffer;
-            mxDecrypter->Read( mrStrm, pnBuffer, 8 );
-            rfValue = SVBT64ToDouble( pnBuffer );
-        }
-        else
-            mrStrm >> rfValue;
-        mnRawRecLeft -= 8;
-    }
-    return *this;
-}
-
-sal_Int8 XclImpStream::ReadInt8()
-{
-    sal_Int8 nValue;
-    operator>>( nValue );
-    return nValue;
-}
-
-sal_uInt8 XclImpStream::ReaduInt8()
-{
-    sal_uInt8 nValue;
-    operator>>( nValue );
-    return nValue;
-}
-
-sal_Int16 XclImpStream::ReadInt16()
-{
-    sal_Int16 nValue;
-    operator>>( nValue );
-    return nValue;
-}
-
-sal_uInt16 XclImpStream::ReaduInt16()
-{
-    sal_uInt16 nValue;
-    operator>>( nValue );
-    return nValue;
-}
-
-sal_Int32 XclImpStream::ReadInt32()
-{
-    sal_Int32 nValue;
-    operator>>( nValue );
-    return nValue;
-}
-
-sal_uInt32 XclImpStream::ReaduInt32()
-{
-    sal_uInt32 nValue;
-    operator>>( nValue );
-    return nValue;
-}
-
-float XclImpStream::ReadFloat()
-{
-    float fValue;
-    operator>>( fValue );
-    return fValue;
-}
-
-double XclImpStream::ReadDouble()
-{
-    double fValue;
-    operator>>( fValue );
-    return fValue;
-}
-
-sal_Size XclImpStream::Read( void* pData, sal_Size nBytes )
-{
-    sal_Size nRet = 0;
-    if( mbValid && pData && (nBytes > 0) )
-    {
-        sal_uInt8* pnBuffer = reinterpret_cast< sal_uInt8* >( pData );
-        sal_Size nBytesLeft = nBytes;
-
-        while( mbValid && (nBytesLeft > 0) )
-        {
-            sal_uInt16 nReadSize = GetMaxRawReadSize( nBytesLeft );
-            sal_uInt16 nReadRet = ReadRawData( pnBuffer, nReadSize );
-            nRet += nReadRet;
-            mbValid = (nReadSize == nReadRet);
-            DBG_ASSERT( mbValid, "XclImpStream::Read - stream read error" );
-            pnBuffer += nReadRet;
-            nBytesLeft -= nReadRet;
-            if( mbValid && (nBytesLeft > 0) )
-                JumpToNextContinue();
-            DBG_ASSERT( mbValid, "XclImpStream::Read - record overread" );
-        }
-    }
-    return nRet;
-}
-
-sal_Size XclImpStream::CopyToStream( SvStream& rOutStrm, sal_Size nBytes )
-{
-    sal_Size nRet = 0;
-    if( mbValid && (nBytes > 0) )
-    {
-        const sal_Size nMaxBuffer = 4096;
-        sal_uInt8* pnBuffer = new sal_uInt8[ ::std::min( nBytes, nMaxBuffer ) ];
-        sal_Size nBytesLeft = nBytes;
-
-        while( mbValid && (nBytesLeft > 0) )
-        {
-            sal_Size nReadSize = ::std::min( nBytesLeft, nMaxBuffer );
-            nRet += Read( pnBuffer, nReadSize );
-            rOutStrm.Write( pnBuffer, nReadSize );
-            nBytesLeft -= nReadSize;
-        }
-
-        delete[] pnBuffer;
-    }
-    return nRet;
-}
-
-sal_Size XclImpStream::CopyRecordToStream( SvStream& rOutStrm )
-{
-    sal_Size nRet = 0;
-    if( mbValidRec )
-    {
-        PushPosition();
-        RestorePosition( maFirstRec );
-        nRet = CopyToStream( rOutStrm, GetRecSize() );
-        PopPosition();
-    }
-    return nRet;
-}
-
-void XclImpStream::Seek( sal_Size nPos )
-{
-    if( mbValidRec )
-    {
-        sal_Size nCurrPos = GetRecPos();
-        if( !mbValid || (nPos < nCurrPos) ) // from invalid state or backward
-        {
-            RestorePosition( maFirstRec );
-            Ignore( nPos );
-        }
-        else if( nPos > nCurrPos )          // forward
-        {
-            Ignore( nPos - nCurrPos );
-        }
-    }
-}
-
-void XclImpStream::Ignore( sal_Size nBytes )
-{
-    // implementation similar to Read(), but without really reading anything
-    sal_Size nBytesLeft = nBytes;
-    while( mbValid && (nBytesLeft > 0) )
-    {
-        sal_uInt16 nReadSize = GetMaxRawReadSize( nBytesLeft );
-        mrStrm.SeekRel( nReadSize );
-        mnRawRecLeft = mnRawRecLeft - nReadSize;
-        nBytesLeft -= nReadSize;
-        if( nBytesLeft > 0 )
-            JumpToNextContinue();
-        DBG_ASSERT( mbValid, "XclImpStream::Ignore - record overread" );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-sal_Size XclImpStream::ReadUniStringExtHeader(
-        bool& rb16Bit, bool& rbRich, bool& rbFareast,
-        sal_uInt16& rnFormatRuns, sal_uInt32& rnExtInf, sal_uInt8 nFlags )
-{
-    DBG_ASSERT( !::get_flag( nFlags, EXC_STRF_UNKNOWN ), "XclImpStream::ReadUniStringExt - unknown flags" );
-    rb16Bit = ::get_flag( nFlags, EXC_STRF_16BIT );
-    rbRich = ::get_flag( nFlags, EXC_STRF_RICH );
-    rbFareast = ::get_flag( nFlags, EXC_STRF_FAREAST );
-    rnFormatRuns = rbRich ? ReaduInt16() : 0;
-    rnExtInf = rbFareast ? ReaduInt32() : 0;
-    return rnExtInf + 4 * rnFormatRuns;
-}
-
-sal_Size XclImpStream::ReadUniStringExtHeader( bool& rb16Bit, sal_uInt8 nFlags )
-{
-    bool bRich, bFareast;
-    sal_uInt16 nCrun;
-    sal_uInt32 nExtInf;
-    return ReadUniStringExtHeader( rb16Bit, bRich, bFareast, nCrun, nExtInf, nFlags );
-}
-
-// ----------------------------------------------------------------------------
-
-String XclImpStream::ReadRawUniString( sal_uInt16 nChars, bool b16Bit )
-{
-    String aRet;
-    sal_uInt16 nCharsLeft = nChars;
-    sal_uInt16 nReadSize;
-
-    sal_Unicode* pcBuffer = new sal_Unicode[ nCharsLeft + 1 ];
-
-    while( IsValid() && (nCharsLeft > 0) )
-    {
-        if( b16Bit )
-        {
-            nReadSize = ::std::min< sal_uInt16 >( nCharsLeft, mnRawRecLeft / 2 );
-            DBG_ASSERT( (nReadSize <= nCharsLeft) || !(mnRawRecLeft & 0x1),
-                "XclImpStream::ReadRawUniString - missing a byte" );
-        }
-        else
-            nReadSize = GetMaxRawReadSize( nCharsLeft );
-
-        sal_Unicode* pcUniChar = pcBuffer;
-        sal_Unicode* pcEndChar = pcBuffer + nReadSize;
-
-        if( b16Bit )
-        {
-            sal_uInt16 nReadChar;
-            for( ; IsValid() && (pcUniChar < pcEndChar); ++pcUniChar )
-            {
-                operator>>( nReadChar );
-                (*pcUniChar) = (nReadChar == EXC_NUL) ? mcNulSubst : static_cast< sal_Unicode >( nReadChar );
-            }
-        }
-        else
-        {
-            sal_uInt8 nReadChar;
-            for( ; IsValid() && (pcUniChar < pcEndChar); ++pcUniChar )
-            {
-                operator>>( nReadChar );
-                (*pcUniChar) = (nReadChar == EXC_NUL_C) ? mcNulSubst : static_cast< sal_Unicode >( nReadChar );
-            }
-        }
-
-        *pcEndChar = '\0';
-        aRet.Append( pcBuffer );
-
-        nCharsLeft = nCharsLeft - nReadSize;
-        if( nCharsLeft > 0 )
-            JumpToNextStringContinue( b16Bit );
-    }
-
-    delete[] pcBuffer;
-    return aRet;
-}
-
-String XclImpStream::ReadUniString( sal_uInt16 nChars, sal_uInt8 nFlags )
-{
-    bool b16Bit;
-    sal_Size nExtSize = ReadUniStringExtHeader( b16Bit, nFlags );
-    String aRet( ReadRawUniString( nChars, b16Bit ) );
-    Ignore( nExtSize );
-    return aRet;
-}
-
-String XclImpStream::ReadUniString( sal_uInt16 nChars )
-{
-    return ReadUniString( nChars, ReaduInt8() );
-}
-
-String XclImpStream::ReadUniString()
-{
-    return ReadUniString( ReaduInt16() );
-}
-
-void XclImpStream::IgnoreRawUniString( sal_uInt16 nChars, bool b16Bit )
-{
-    sal_uInt16 nCharsLeft = nChars;
-    sal_uInt16 nReadSize;
-
-    while( IsValid() && (nCharsLeft > 0) )
-    {
-        if( b16Bit )
-        {
-            nReadSize = ::std::min< sal_uInt16 >( nCharsLeft, mnRawRecLeft / 2 );
-            DBG_ASSERT( (nReadSize <= nCharsLeft) || !(mnRawRecLeft & 0x1),
-                "XclImpStream::IgnoreRawUniString - missing a byte" );
-            Ignore( nReadSize * 2 );
-        }
-        else
-        {
-            nReadSize = GetMaxRawReadSize( nCharsLeft );
-            Ignore( nReadSize );
-        }
-
-        nCharsLeft = nCharsLeft - nReadSize;
-        if( nCharsLeft > 0 )
-            JumpToNextStringContinue( b16Bit );
-    }
-}
-
-void XclImpStream::IgnoreUniString( sal_uInt16 nChars, sal_uInt8 nFlags )
-{
-    bool b16Bit;
-    sal_Size nExtSize = ReadUniStringExtHeader( b16Bit, nFlags );
-    IgnoreRawUniString( nChars, b16Bit );
-    Ignore( nExtSize );
-}
-
-void XclImpStream::IgnoreUniString( sal_uInt16 nChars )
-{
-    IgnoreUniString( nChars, ReaduInt8() );
-}
-
-void XclImpStream::IgnoreUniString()
-{
-    IgnoreUniString( ReaduInt16() );
-}
-
-// ----------------------------------------------------------------------------
-
-String XclImpStream::ReadRawByteString( sal_uInt16 nChars )
-{
-    sal_Char* pcBuffer = new sal_Char[ nChars + 1 ];
-    sal_uInt16 nCharsRead = ReadRawData( pcBuffer, nChars );
-    pcBuffer[ nCharsRead ] = '\0';
-    String aRet( pcBuffer, mrRoot.GetTextEncoding() );
-    delete[] pcBuffer;
-    return aRet;
-}
-
-String XclImpStream::ReadByteString( bool b16BitLen )
-{
-    return ReadRawByteString( ReadByteStrLen( b16BitLen ) );
-}
-
-// private --------------------------------------------------------------------
-
-void XclImpStream::StorePosition( XclImpStreamPos& rPos )
-{
-    rPos.Set( mrStrm, mnNextRecPos, mnCurrRecSize, mnRawRecId, mnRawRecSize, mnRawRecLeft, mbValid );
-}
-
-void XclImpStream::RestorePosition( const XclImpStreamPos& rPos )
-{
-    rPos.Get( mrStrm, mnNextRecPos, mnCurrRecSize, mnRawRecId, mnRawRecSize, mnRawRecLeft, mbValid );
-    SetupDecrypter();
-}
-
-bool XclImpStream::ReadNextRawRecHeader()
-{
-    mrStrm.Seek( mnNextRecPos );
-    bool bRet = mnNextRecPos + 4 <= mnStreamSize;
-    if( bRet )
-        mrStrm >> mnRawRecId >> mnRawRecSize;
-    return bRet;
-}
-
-void XclImpStream::SetupDecrypter()
-{
-    if( mxDecrypter.is() )
-        mxDecrypter->Update( mrStrm, mnRawRecSize );
-}
-
-void XclImpStream::SetupRawRecord()
-{
-    // pre: mnRawRecSize contains current raw record size
-    // pre: mrStrm points to start of raw record data
-    mnNextRecPos = mrStrm.Tell() + mnRawRecSize;
-    mnRawRecLeft = mnRawRecSize;
-    mnCurrRecSize += mnRawRecSize;
-    SetupDecrypter();   // decrypter works on raw record level
-}
-
-void XclImpStream::SetupRecord()
-{
-    mnRecId = mnRawRecId;
-    mnAltContId = EXC_ID_UNKNOWN;
-    mnCurrRecSize = 0;
-    mnComplRecSize = mnRawRecSize;
-    mbHasComplRec = !mbCont;
-    SetupRawRecord();
-    SetNulSubstChar();
-    EnableDecryption();
-    StorePosition( maFirstRec );
-}
-
-bool XclImpStream::IsContinueId( sal_uInt16 nRecId ) const
-{
-    return (nRecId == EXC_ID_CONT) || (nRecId == mnAltContId);
-}
-
-bool XclImpStream::JumpToNextContinue()
-{
-    mbValid = mbValid && mbCont && ReadNextRawRecHeader() && IsContinueId( mnRawRecId );
-    if( mbValid )   // do not setup a following non-CONTINUE record
-        SetupRawRecord();
-    return mbValid;
-}
-
-bool XclImpStream::JumpToNextStringContinue( bool& rb16Bit )
-{
-    DBG_ASSERT( mnRawRecLeft == 0, "XclImpStream::JumpToNextStringContinue - unexpected garbage" );
-
-    if( mbCont && (GetRecLeft() > 0) )
-    {
-        JumpToNextContinue();
-    }
-    else if( mnRecId == EXC_ID_CONT )
-    {
-        // CONTINUE handling is off, but we have started reading in a CONTINUE record
-        // -> start next CONTINUE for TXO import
-        mbValidRec = ReadNextRawRecHeader() && ((mnRawRecId != 0) || (mnRawRecSize > 0));
-        mbValid = mbValidRec && (mnRawRecId == EXC_ID_CONT);
-        // we really start a new record here - no chance to return to string origin
-        if( mbValid )
-            SetupRecord();
-    }
-    else
-        mbValid = false;
-
-    if( mbValid )
-        rb16Bit = ::get_flag( ReaduInt8(), EXC_STRF_16BIT );
-    return mbValid;
-}
-
-bool XclImpStream::EnsureRawReadSize( sal_uInt16 nBytes )
-{
-    if( mbValid && nBytes )
-    {
-        while( mbValid && !mnRawRecLeft ) JumpToNextContinue();
-        mbValid = mbValid && (nBytes <= mnRawRecLeft);
-        DBG_ASSERT( mbValid, "XclImpStream::EnsureRawReadSize - record overread" );
-    }
-    return mbValid;
-}
-
-sal_uInt16 XclImpStream::GetMaxRawReadSize( sal_Size nBytes ) const
-{
-    return static_cast< sal_uInt16 >( ::std::min< sal_Size >( nBytes, mnRawRecLeft ) );
-}
-
-sal_uInt16 XclImpStream::ReadRawData( void* pData, sal_uInt16 nBytes )
-{
-    DBG_ASSERT( (nBytes <= mnRawRecLeft), "XclImpStream::ReadRawData - record overread" );
-    sal_uInt16 nRet = 0;
-    if( mbUseDecr )
-        nRet = mxDecrypter->Read( mrStrm, pData, nBytes );
-    else
-        nRet = static_cast< sal_uInt16 >( mrStrm.Read( pData, nBytes ) );
-    mnRawRecLeft = mnRawRecLeft - nRet;
-    return nRet;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xistring.cxx sc/source/filter/xlsx/xlsx-xistring.cxx
deleted file mode 100644
index d6e0b31..0000000
--- sc/source/filter/xlsx/xlsx-xistring.cxx
+++ /dev/null
@@ -1,216 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xistring.cxx,v $
- * $Revision: 1.5.90.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "precompiled_sc.hxx"
-#include "xistring.hxx"
-#include "xlstyle.hxx"
-#include "xistream.hxx"
-#include "xiroot.hxx"
-
-// Byte/Unicode strings =======================================================
-
-/** All allowed flags for import. */
-const XclStrFlags nAllowedFlags = EXC_STR_8BITLENGTH | EXC_STR_SMARTFLAGS | EXC_STR_SEPARATEFORMATS;
-
-// ----------------------------------------------------------------------------
-
-XclImpString::XclImpString()
-{
-}
-
-XclImpString::XclImpString( const String& rString ) :
-    maString( rString )
-{
-}
-
-XclImpString::~XclImpString()
-{
-}
-
-void XclImpString::Read( XclImpStream& rStrm, XclStrFlags nFlags )
-{
-    if( !::get_flag( nFlags, EXC_STR_SEPARATEFORMATS ) )
-        maFormats.clear();
-
-    DBG_ASSERT( (nFlags & ~nAllowedFlags) == 0, "XclImpString::Read - unknown flag" );
-    bool b16BitLen = !::get_flag( nFlags, EXC_STR_8BITLENGTH );
-
-    switch( rStrm.GetRoot().GetBiff() )
-    {
-        case EXC_BIFF2:
-        case EXC_BIFF3:
-        case EXC_BIFF4:
-        case EXC_BIFF5:
-            // no integrated formatting in BIFF2-BIFF7
-            maString = rStrm.ReadByteString( b16BitLen );
-        break;
-
-        case EXC_BIFF8:
-        {
-            // --- string header ---
-            sal_uInt16 nChars = b16BitLen ? rStrm.ReaduInt16() : rStrm.ReaduInt8();
-            sal_uInt8 nFlagField = 0;
-            if( nChars || !::get_flag( nFlags, EXC_STR_SMARTFLAGS ) )
-                rStrm >> nFlagField;
-
-            bool b16Bit, bRich, bFarEast;
-            sal_uInt16 nRunCount;
-            sal_uInt32 nExtInf;
-            rStrm.ReadUniStringExtHeader( b16Bit, bRich, bFarEast, nRunCount, nExtInf, nFlagField );
-            // #122185# ignore the flags, they may be wrong
-
-            // --- character array ---
-            maString = rStrm.ReadRawUniString( nChars, b16Bit );
-
-            // --- formatting ---
-            if( nRunCount > 0 )
-                ReadFormats( rStrm, nRunCount );
-
-            // --- extended (FarEast) information ---
-            rStrm.Ignore( nExtInf );
-        }
-        break;
-
-        default:
-            DBG_ERROR_BIFF();
-    }
-}
-
-void XclImpString::AppendFormat( XclFormatRunVec& rFormats, sal_uInt16 nChar, sal_uInt16 nFontIdx )
-{
-    // #i33341# real life -- same character index may occur several times
-    DBG_ASSERT( rFormats.empty() || (rFormats.back().mnChar <= nChar), "XclImpString::AppendFormat - wrong char order" );
-    if( rFormats.empty() || (rFormats.back().mnChar < nChar) )
-        rFormats.push_back( XclFormatRun( nChar, nFontIdx ) );
-    else
-        rFormats.back().mnFontIdx = nFontIdx;
-}
-
-void XclImpString::ReadFormats( XclImpStream& rStrm, XclFormatRunVec& rFormats )
-{
-    bool bBiff8 = rStrm.GetRoot().GetBiff() == EXC_BIFF8;
-    sal_uInt16 nRunCount = bBiff8 ? rStrm.ReaduInt16() : rStrm.ReaduInt8();
-    ReadFormats( rStrm, rFormats, nRunCount );
-}
-
-void XclImpString::ReadFormats( XclImpStream& rStrm, XclFormatRunVec& rFormats, sal_uInt16 nRunCount )
-{
-    rFormats.clear();
-    rFormats.reserve( nRunCount );
-    /*  #i33341# real life -- same character index may occur several times
-        -> use AppendFormat() to validate formats */
-    if( rStrm.GetRoot().GetBiff() == EXC_BIFF8 )
-    {
-        for( sal_uInt16 nIdx = 0; nIdx < nRunCount; ++nIdx )
-        {
-            sal_uInt16 nChar, nFontIdx;
-            rStrm >> nChar >> nFontIdx;
-            AppendFormat( rFormats, nChar, nFontIdx );
-        }
-    }
-    else
-    {
-        for( sal_uInt16 nIdx = 0; nIdx < nRunCount; ++nIdx )
-        {
-            sal_uInt8 nChar, nFontIdx;
-            rStrm >> nChar >> nFontIdx;
-            AppendFormat( rFormats, nChar, nFontIdx );
-        }
-    }
-}
-
-void XclImpString::ReadObjFormats( XclImpStream& rStrm, XclFormatRunVec& rFormats, sal_uInt16 nFormatSize )
-{
-    // number of formatting runs, each takes 8 bytes
-    sal_uInt16 nRunCount = nFormatSize / 8;
-    rFormats.clear();
-    rFormats.reserve( nRunCount );
-    for( sal_uInt16 nIdx = 0; nIdx < nRunCount; ++nIdx )
-    {
-        sal_uInt16 nChar, nFontIdx;
-        rStrm >> nChar >> nFontIdx;
-        rStrm.Ignore( 4 );
-        AppendFormat( rFormats, nChar, nFontIdx );
-    }
-}
-
-// String iterator ============================================================
-
-XclImpStringIterator::XclImpStringIterator( const XclImpString& rString ) :
-    mrText( rString.GetText() ),
-    mrFormats( rString.GetFormats() ),
-    mnPortion( 0 ),
-    mnTextBeg( 0 ),
-    mnTextEnd( 0 ),
-    mnFormatsBeg( 0 ),
-    mnFormatsEnd( 0 )
-{
-    // first portion is formatted, adjust vector index to next portion
-    if( !mrFormats.empty() && (mrFormats.front().mnChar == 0) )
-        ++mnFormatsEnd;
-    // find end position of the first portion
-    mnTextEnd = static_cast< xub_StrLen >( (mnFormatsEnd < mrFormats.size()) ?
-        mrFormats[ mnFormatsEnd ].mnChar : mrText.Len() );
-}
-
-String XclImpStringIterator::GetPortionText() const
-{
-    return String( mrText, mnTextBeg, mnTextEnd - mnTextBeg );
-}
-
-sal_uInt16 XclImpStringIterator::GetPortionFont() const
-{
-    return (mnFormatsBeg < mnFormatsEnd) ? mrFormats[ mnFormatsBeg ].mnFontIdx : EXC_FONT_NOTFOUND;
-}
-
-XclImpStringIterator& XclImpStringIterator::operator++()
-{
-    if( Is() )
-    {
-        ++mnPortion;
-        do
-        {
-            // indexes into vector of formatting runs
-            if( mnFormatsBeg < mnFormatsEnd )
-                ++mnFormatsBeg;
-            if( mnFormatsEnd < mrFormats.size() )
-                ++mnFormatsEnd;
-            // character positions of next portion
-            mnTextBeg = mnTextEnd;
-            mnTextEnd = static_cast< xub_StrLen >( (mnFormatsEnd < mrFormats.size()) ?
-                mrFormats[ mnFormatsEnd ].mnChar : mrText.Len() );
-        }
-        while( Is() && (mnTextBeg == mnTextEnd) );
-    }
-    return *this;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xistyle.cxx sc/source/filter/xlsx/xlsx-xistyle.cxx
deleted file mode 100644
index 2adea30..0000000
--- sc/source/filter/xlsx/xlsx-xistyle.cxx
+++ /dev/null
@@ -1,1889 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xistyle.cxx,v $
- * $Revision: 1.38.14.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xistyle.hxx"
-#include <sfx2/printer.hxx>
-#include <sfx2/objsh.hxx>
-#include <svtools/ctrltool.hxx>
-#include <svx/editobj.hxx>
-#include "scitems.hxx"
-#include <svx/fontitem.hxx>
-#include <svx/fhgtitem.hxx>
-#include <svx/wghtitem.hxx>
-#include <svx/udlnitem.hxx>
-#include <svx/postitem.hxx>
-#include <svx/crsditem.hxx>
-#include <svx/cntritem.hxx>
-#include <svx/shdditem.hxx>
-#include <svx/escpitem.hxx>
-#include <svx/algitem.hxx>
-#include <svx/boxitem.hxx>
-#include <svx/bolnitem.hxx>
-#include <svx/rotmodit.hxx>
-#include <svx/colritem.hxx>
-#include <svx/brshitem.hxx>
-#include <svx/frmdiritem.hxx>
-#include <svx/eeitem.hxx>
-#include <svx/flstitem.hxx>
-#include "document.hxx"
-#include "docpool.hxx"
-#include "attrib.hxx"
-#include "stlpool.hxx"
-#include "stlsheet.hxx"
-#include "cell.hxx"
-#include "globstr.hrc"
-#include "xltracer.hxx"
-#include "xistream.hxx"
-#include "xicontent.hxx"
-
-#include "root.hxx"
-#include "colrowst.hxx"
-
-#include <cppuhelper/implbase1.hxx>
-#include <com/sun/star/container/XIndexAccess.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-using namespace ::com::sun::star;
-
-typedef ::cppu::WeakImplHelper1< container::XIndexAccess > XIndexAccess_BASE;
-typedef ::std::vector< ColorData > ColorDataVec;
-
-class PaletteIndex : public XIndexAccess_BASE
-{
-public:
-    PaletteIndex( const ColorDataVec& rColorDataTable ) : maColorData( rColorDataTable ) {}
-
-    // Methods XIndexAccess
-    virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException)
-    {
-         return  maColorData.size();
-    }
-
-    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
-    {
-        //--Index;  // apparently the palette is already 1 based
-        return uno::makeAny( sal_Int32( maColorData[ Index ] ) );
-    }
-
-    // Methods XElementAcess
-    virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
-    {
-        return ::getCppuType( (sal_Int32*)0 );
-    }
-    virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException)
-    {
-        return (maColorData.size() > 0);
-    }
-
-private:
-    ColorDataVec        maColorData; 
-};
-
-void
-XclImpPalette::ExportPalette()
-{
-    if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
-    {
-        // copy values in color palette
-        sal_Int16 nColors =  maColorTable.size();
-        ColorDataVec aColors;
-        aColors.resize( nColors );
-        for( sal_uInt16 nIndex = 0; nIndex < nColors; ++nIndex )
-            aColors[ nIndex ] = GetColorData( nIndex );
-
-        uno::Reference< beans::XPropertySet > xProps( pDocShell->GetModel(), uno::UNO_QUERY );
-        if ( xProps.is() )
-        {
-            uno::Reference< container::XIndexAccess > xIndex( new PaletteIndex( aColors ) ); 
-            xProps->setPropertyValue( CREATE_OUSTRING("ColorPalette"), uno::makeAny( xIndex ) ); 
-        }
-    }
-            
-}
-// PALETTE record - color information =========================================
-
-XclImpPalette::XclImpPalette( const XclImpRoot& rRoot ) :
-    XclDefaultPalette( rRoot ), mrRoot( rRoot )
-{
-}
-
-void XclImpPalette::Initialize()
-{
-    maColorTable.clear();
-}
-
-ColorData XclImpPalette::GetColorData( sal_uInt16 nXclIndex ) const
-{
-    if( nXclIndex >= EXC_COLOR_USEROFFSET )
-    {
-        sal_uInt32 nIx = nXclIndex - EXC_COLOR_USEROFFSET;
-        if( nIx < maColorTable.size() )
-            return maColorTable[ nIx ];
-    }
-    return GetDefColorData( nXclIndex );
-}
-
-void XclImpPalette::ReadPalette( XclImpStream& rStrm )
-{
-    sal_uInt16 nCount;
-    rStrm >> nCount;
-    DBG_ASSERT( rStrm.GetRecLeft() == static_cast< sal_Size >( 4 * nCount ),
-        "XclImpPalette::ReadPalette - size mismatch" );
-
-    maColorTable.resize( nCount );
-    Color aColor;
-    for( sal_uInt16 nIndex = 0; nIndex < nCount; ++nIndex )
-    {
-        rStrm >> aColor;
-        maColorTable[ nIndex ] = aColor.GetColor();
-    }
-    ExportPalette();
-}
-
-// FONT record - font information =============================================
-
-XclImpFont::XclImpFont( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mbHasCharSet( false ),
-    mbHasWstrn( true ),
-    mbHasAsian( false ),
-    mbHasCmplx( false )
-{
-    SetAllUsedFlags( false );
-}
-
-XclImpFont::XclImpFont( const XclImpRoot& rRoot, const XclFontData& rFontData ) :
-    XclImpRoot( rRoot )
-{
-    SetFontData( rFontData, false );
-}
-
-void XclImpFont::SetAllUsedFlags( bool bUsed )
-{
-    mbFontNameUsed = mbHeightUsed = mbColorUsed = mbWeightUsed = mbEscapemUsed =
-        mbUnderlUsed = mbItalicUsed = mbStrikeUsed = mbOutlineUsed = mbShadowUsed = bUsed;
-}
-
-void XclImpFont::SetFontData( const XclFontData& rFontData, bool bHasCharSet )
-{
-    maData = rFontData;
-    mbHasCharSet = bHasCharSet;
-    if( maData.maStyle.Len() )
-    {
-        if( SfxObjectShell* pDocShell = GetDocShell() )
-        {
-            if( const SvxFontListItem* pInfoItem = static_cast< const SvxFontListItem* >(
-                pDocShell->GetItem( SID_ATTR_CHAR_FONTLIST ) ) )
-            {
-                if( const FontList* pFontList = pInfoItem->GetFontList() )
-                {
-                    FontInfo aFontInfo( pFontList->Get( maData.maName, maData.maStyle ) );
-                    maData.SetScWeight( aFontInfo.GetWeight() );
-                    maData.SetScPosture( aFontInfo.GetItalic() );
-                }
-            }
-        }
-        maData.maStyle.Erase();
-    }
-    GuessScriptType();
-    SetAllUsedFlags( true );
-}
-
-rtl_TextEncoding XclImpFont::GetFontEncoding() const
-{
-    // #i63105# use text encoding from FONT record
-    // #i67768# BIFF2-BIFF4 FONT records do not contain character set
-    rtl_TextEncoding eFontEnc = mbHasCharSet ? maData.GetFontEncoding() : GetTextEncoding();
-    return (eFontEnc == RTL_TEXTENCODING_DONTKNOW) ? GetTextEncoding() : eFontEnc;
-}
-
-void XclImpFont::ReadFont( XclImpStream& rStrm )
-{
-    switch( GetBiff() )
-    {
-        case EXC_BIFF2:
-            ReadFontData2( rStrm );
-            ReadFontName2( rStrm );
-        break;
-        case EXC_BIFF3:
-        case EXC_BIFF4:
-            ReadFontData2( rStrm );
-            ReadFontColor( rStrm );
-            ReadFontName2( rStrm );
-        break;
-        case EXC_BIFF5:
-            ReadFontData5( rStrm );
-            ReadFontName2( rStrm );
-        break;
-        case EXC_BIFF8:
-            ReadFontData5( rStrm );
-            ReadFontName8( rStrm );
-        break;
-        default:
-            DBG_ERROR_BIFF();
-            return;
-    }
-    GuessScriptType();
-    SetAllUsedFlags( true );
-}
-
-void XclImpFont::ReadEfont( XclImpStream& rStrm )
-{
-    ReadFontColor( rStrm );
-}
-
-void XclImpFont::ReadCFFontBlock( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() == EXC_BIFF8 );
-    if( GetBiff() != EXC_BIFF8 )
-        return;
-
-    sal_uInt32 nHeight, nStyle, nColor, nFontFlags1, nFontFlags2, nFontFlags3;
-    sal_uInt16 nWeight, nEscapem;
-    sal_uInt8 nUnderl;
-
-    rStrm.Ignore( 64 );
-    rStrm >> nHeight >> nStyle >> nWeight >> nEscapem >> nUnderl;
-    rStrm.Ignore( 3 );
-    rStrm >> nColor;
-    rStrm.Ignore( 4 );
-    rStrm >> nFontFlags1 >> nFontFlags2 >> nFontFlags3;
-    rStrm.Ignore( 18 );
-
-    if( (mbHeightUsed = (nHeight <= 0x7FFF)) == true )
-        maData.mnHeight = static_cast< sal_uInt16 >( nHeight );
-    if( (mbWeightUsed = !::get_flag( nFontFlags1, EXC_CF_FONT_STYLE ) && (nWeight < 0x7FFF)) == true )
-        maData.mnWeight = static_cast< sal_uInt16 >( nWeight );
-    if( (mbItalicUsed = !::get_flag( nFontFlags1, EXC_CF_FONT_STYLE )) == true )
-        maData.mbItalic = ::get_flag( nStyle, EXC_CF_FONT_STYLE );
-    if( (mbUnderlUsed = !::get_flag( nFontFlags3, EXC_CF_FONT_UNDERL ) && (nUnderl <= 0x7F)) == true )
-        maData.mnUnderline = nUnderl;
-    if( (mbColorUsed = (nColor <= 0x7FFF)) == true )
-        maData.maColor = GetPalette().GetColor( static_cast< sal_uInt16 >( nColor ) );
-    if( (mbStrikeUsed = !::get_flag( nFontFlags1, EXC_CF_FONT_STRIKEOUT )) == true )
-        maData.mbStrikeout = ::get_flag( nStyle, EXC_CF_FONT_STRIKEOUT );
-}
-
-void XclImpFont::FillToItemSet( SfxItemSet& rItemSet, XclFontItemType eType, bool bSkipPoolDefs ) const
-{
-    // true = edit engine Which-IDs (EE_CHAR_*); false = Calc Which-IDs (ATTR_*)
-    bool bEE = eType != EXC_FONTITEM_CELL;
-
-// item = the item to put into the item set
-// sc_which = the Calc Which-ID of the item
-// ee_which = the edit engine Which-ID of the item
-#define PUTITEM( item, sc_which, ee_which ) \
-    ScfTools::PutItem( rItemSet, item, (bEE ? (ee_which) : (sc_which)), bSkipPoolDefs )
-
-// Font item
-    // #i36997# do not set default Tahoma font from notes
-    bool bDefNoteFont = (eType == EXC_FONTITEM_NOTE) && (maData.maName.EqualsIgnoreCaseAscii( "Tahoma" ));
-    if( mbFontNameUsed && !bDefNoteFont )
-    {
-        rtl_TextEncoding eFontEnc = maData.GetFontEncoding();
-        rtl_TextEncoding eTempTextEnc = (bEE && (eFontEnc == GetTextEncoding())) ?
-            ScfTools::GetSystemTextEncoding() : eFontEnc;
-
-        SvxFontItem aFontItem( maData.GetScFamily( GetTextEncoding() ), maData.maName, EMPTY_STRING,
-                PITCH_DONTKNOW, eTempTextEnc, ATTR_FONT );
-        // #91658# set only for valid script types
-        if( mbHasWstrn )
-            PUTITEM( aFontItem, ATTR_FONT,      EE_CHAR_FONTINFO );
-        if( mbHasAsian )
-            PUTITEM( aFontItem, ATTR_CJK_FONT,  EE_CHAR_FONTINFO_CJK );
-        if( mbHasCmplx )
-            PUTITEM( aFontItem, ATTR_CTL_FONT,  EE_CHAR_FONTINFO_CTL );
-    }
-
-// Font height (for all script types)
-    if( mbHeightUsed )
-    {
-        sal_Int32 nHeight = maData.mnHeight;
-        if( bEE && (eType != EXC_FONTITEM_HF) )     // do not convert header/footer height
-            nHeight = (nHeight * 127 + 36) / EXC_POINTS_PER_INCH;   // #98527# 1 in == 72 pt
-
-        SvxFontHeightItem aHeightItem( nHeight, 100, ATTR_FONT_HEIGHT );
-        PUTITEM( aHeightItem,   ATTR_FONT_HEIGHT,       EE_CHAR_FONTHEIGHT );
-        PUTITEM( aHeightItem,   ATTR_CJK_FONT_HEIGHT,   EE_CHAR_FONTHEIGHT_CJK );
-        PUTITEM( aHeightItem,   ATTR_CTL_FONT_HEIGHT,   EE_CHAR_FONTHEIGHT_CTL );
-    }
-
-// Font color - pass AUTO_COL to item
-    if( mbColorUsed )
-        PUTITEM( SvxColorItem( maData.maColor, ATTR_FONT_COLOR  ), ATTR_FONT_COLOR, EE_CHAR_COLOR );
-
-// Font weight (for all script types)
-    if( mbWeightUsed )
-    {
-        SvxWeightItem aWeightItem( maData.GetScWeight(), ATTR_FONT_WEIGHT );
-        PUTITEM( aWeightItem,   ATTR_FONT_WEIGHT,       EE_CHAR_WEIGHT );
-        PUTITEM( aWeightItem,   ATTR_CJK_FONT_WEIGHT,   EE_CHAR_WEIGHT_CJK );
-        PUTITEM( aWeightItem,   ATTR_CTL_FONT_WEIGHT,   EE_CHAR_WEIGHT_CTL );
-    }
-
-// Font underline
-    if( mbUnderlUsed )
-    {
-        SvxUnderlineItem aUnderlItem( maData.GetScUnderline(), ATTR_FONT_UNDERLINE );
-        PUTITEM( aUnderlItem,   ATTR_FONT_UNDERLINE,    EE_CHAR_UNDERLINE );
-    }
-
-// Font posture (for all script types)
-    if( mbItalicUsed )
-    {
-        SvxPostureItem aPostItem( maData.GetScPosture(), ATTR_FONT_POSTURE );
-        PUTITEM( aPostItem, ATTR_FONT_POSTURE,      EE_CHAR_ITALIC );
-        PUTITEM( aPostItem, ATTR_CJK_FONT_POSTURE,  EE_CHAR_ITALIC_CJK );
-        PUTITEM( aPostItem, ATTR_CTL_FONT_POSTURE,  EE_CHAR_ITALIC_CTL );
-    }
-
-// Boolean attributes crossed out, contoured, shadowed
-    if( mbStrikeUsed )
-        PUTITEM( SvxCrossedOutItem( maData.GetScStrikeout(), ATTR_FONT_CROSSEDOUT ), ATTR_FONT_CROSSEDOUT, EE_CHAR_STRIKEOUT );
-    if( mbOutlineUsed )
-        PUTITEM( SvxContourItem( maData.mbOutline, ATTR_FONT_CONTOUR ), ATTR_FONT_CONTOUR, EE_CHAR_OUTLINE );
-    if( mbShadowUsed )
-        PUTITEM( SvxShadowedItem( maData.mbShadow, ATTR_FONT_SHADOWED ), ATTR_FONT_SHADOWED, EE_CHAR_SHADOW );
-
-// Super-/subscript: only on edit engine objects
-    if( mbEscapemUsed && bEE )
-        rItemSet.Put( SvxEscapementItem( maData.GetScEscapement(), EE_CHAR_ESCAPEMENT ) );
-
-#undef PUTITEM
-}
-
-void XclImpFont::WriteFontProperties( ScfPropertySet& rPropSet,
-        XclFontPropSetType eType, const Color* pFontColor ) const
-{
-    GetFontPropSetHelper().WriteFontProperties(
-        rPropSet, eType, maData, mbHasWstrn, mbHasAsian, mbHasCmplx, pFontColor );
-}
-
-void XclImpFont::ReadFontData2( XclImpStream& rStrm )
-{
-    sal_uInt16 nFlags;
-    rStrm >> maData.mnHeight >> nFlags;
-
-    maData.mnWeight     = ::get_flagvalue( nFlags, EXC_FONTATTR_BOLD, EXC_FONTWGHT_BOLD, EXC_FONTWGHT_NORMAL );
-    maData.mnUnderline  = ::get_flagvalue( nFlags, EXC_FONTATTR_UNDERLINE, EXC_FONTUNDERL_SINGLE, EXC_FONTUNDERL_NONE );
-    maData.mbItalic     = ::get_flag( nFlags, EXC_FONTATTR_ITALIC );
-    maData.mbStrikeout  = ::get_flag( nFlags, EXC_FONTATTR_STRIKEOUT );
-    maData.mbOutline    = ::get_flag( nFlags, EXC_FONTATTR_OUTLINE );
-    maData.mbShadow     = ::get_flag( nFlags, EXC_FONTATTR_SHADOW );
-    mbHasCharSet = false;
-}
-
-void XclImpFont::ReadFontData5( XclImpStream& rStrm )
-{
-    sal_uInt16 nFlags;
-
-    rStrm >> maData.mnHeight >> nFlags;
-    ReadFontColor( rStrm );
-    rStrm >> maData.mnWeight >> maData.mnEscapem >> maData.mnUnderline >> maData.mnFamily >> maData.mnCharSet;
-    rStrm.Ignore( 1 );
-
-    maData.mbItalic     = ::get_flag( nFlags, EXC_FONTATTR_ITALIC );
-    maData.mbStrikeout  = ::get_flag( nFlags, EXC_FONTATTR_STRIKEOUT );
-    maData.mbOutline    = ::get_flag( nFlags, EXC_FONTATTR_OUTLINE );
-    maData.mbShadow     = ::get_flag( nFlags, EXC_FONTATTR_SHADOW );
-    mbHasCharSet = true;
-}
-
-void XclImpFont::ReadFontColor( XclImpStream& rStrm )
-{
-    maData.maColor = GetPalette().GetColor( rStrm.ReaduInt16() );
-}
-
-void XclImpFont::ReadFontName2( XclImpStream& rStrm )
-{
-    maData.maName = rStrm.ReadByteString( false );
-}
-
-void XclImpFont::ReadFontName8( XclImpStream& rStrm )
-{
-    maData.maName = rStrm.ReadUniString( rStrm.ReaduInt8() );
-}
-
-void XclImpFont::GuessScriptType()
-{
-    mbHasWstrn = true;
-    mbHasAsian = mbHasCmplx = false;
-
-    // #91658# #113783# find the script types for which the font contains characters
-    if( OutputDevice* pPrinter = GetPrinter() )
-    {
-        Font aFont( maData.maName, Size( 0, 10 ) );
-        FontCharMap aCharMap;
-
-        pPrinter->SetFont( aFont );
-        if( pPrinter->GetFontCharMap( aCharMap ) )
-        {
-            // #91658# CJK fonts
-            mbHasAsian =
-                aCharMap.HasChar( 0x3041 ) ||   // 3040-309F: Hiragana
-                aCharMap.HasChar( 0x30A1 ) ||   // 30A0-30FF: Katakana
-                aCharMap.HasChar( 0x3111 ) ||   // 3100-312F: Bopomofo
-                aCharMap.HasChar( 0x3131 ) ||   // 3130-318F: Hangul Compatibility Jamo
-                aCharMap.HasChar( 0x3301 ) ||   // 3300-33FF: CJK Compatibility
-                aCharMap.HasChar( 0x3401 ) ||   // 3400-4DBF: CJK Unified Ideographs Extension A
-                aCharMap.HasChar( 0x4E01 ) ||   // 4E00-9FAF: CJK Unified Ideographs
-                aCharMap.HasChar( 0x7E01 ) ||   // 4E00-9FAF: CJK unified ideographs
-                aCharMap.HasChar( 0xA001 ) ||   // A001-A48F: Yi Syllables
-                aCharMap.HasChar( 0xAC01 ) ||   // AC00-D7AF: Hangul Syllables
-                aCharMap.HasChar( 0xCC01 ) ||   // AC00-D7AF: Hangul Syllables
-                aCharMap.HasChar( 0xF901 ) ||   // F900-FAFF: CJK Compatibility Ideographs
-                aCharMap.HasChar( 0xFF71 );     // FF00-FFEF: Halfwidth/Fullwidth Forms
-            // #113783# CTL fonts
-            mbHasCmplx =
-                aCharMap.HasChar( 0x05D1 ) ||   // 0590-05FF: Hebrew
-                aCharMap.HasChar( 0x0631 ) ||   // 0600-06FF: Arabic
-                aCharMap.HasChar( 0x0721 ) ||   // 0700-074F: Syriac
-                aCharMap.HasChar( 0x0911 ) ||   // 0900-0DFF: Indic scripts
-                aCharMap.HasChar( 0x0E01 ) ||   // 0E00-0E7F: Thai
-                aCharMap.HasChar( 0xFB21 ) ||   // FB1D-FB4F: Hebrew Presentation Forms
-                aCharMap.HasChar( 0xFB51 ) ||   // FB50-FDFF: Arabic Presentation Forms-A
-                aCharMap.HasChar( 0xFE71 );     // FE70-FEFF: Arabic Presentation Forms-B
-            // Western fonts
-            mbHasWstrn = (!mbHasAsian && !mbHasCmplx) || aCharMap.HasChar( 'A' );
-        }
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpFontBuffer::XclImpFontBuffer( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maFont4( rRoot ),
-    maCtrlFont( rRoot )
-{
-    Initialize();
-
-    // default font for form controls without own font information
-    XclFontData aCtrlFontData;
-    switch( GetBiff() )
-    {
-        case EXC_BIFF2:
-        case EXC_BIFF3:
-        case EXC_BIFF4:
-        case EXC_BIFF5:
-            aCtrlFontData.maName.AssignAscii( "Helv" );
-            aCtrlFontData.mnHeight = 160;
-            aCtrlFontData.mnWeight = EXC_FONTWGHT_BOLD;
-        break;
-        case EXC_BIFF8:
-            aCtrlFontData.maName.AssignAscii( "Tahoma" );
-            aCtrlFontData.mnHeight = 160;
-            aCtrlFontData.mnWeight = EXC_FONTWGHT_NORMAL;
-        break;
-        default:
-            DBG_ERROR_BIFF();
-    }
-    maCtrlFont.SetFontData( aCtrlFontData, false );
-}
-
-void XclImpFontBuffer::Initialize()
-{
-    maFontList.Clear();
-
-    // application font for column width calculation, later filled with first font from font list
-    XclFontData aAppFontData;
-    aAppFontData.maName.AssignAscii( "Arial" );
-    aAppFontData.mnHeight = 200;
-    aAppFontData.mnWeight = EXC_FONTWGHT_NORMAL;
-    UpdateAppFont( aAppFontData, false );
-}
-
-const XclImpFont* XclImpFontBuffer::GetFont( sal_uInt16 nFontIndex ) const
-{
-    /*  Font with index 4 is not stored in an Excel file, but used e.g. by
-        BIFF5 form pushbutton objects. It is the bold default font. */
-    return (nFontIndex == 4) ? &maFont4 :
-        maFontList.GetObject( (nFontIndex < 4) ? nFontIndex : (nFontIndex - 1) );
-}
-
-void XclImpFontBuffer::ReadFont( XclImpStream& rStrm )
-{
-    XclImpFont* pFont = new XclImpFont( GetRoot() );
-    pFont->ReadFont( rStrm );
-    maFontList.Append( pFont );
-
-    if( maFontList.Count() == 1 )
-    {
-        UpdateAppFont( pFont->GetFontData(), pFont->HasCharSet() );
-        // #i71033# set text encoding from application font, if CODEPAGE is missing
-        SetAppFontEncoding( pFont->GetFontEncoding() );
-    }
-}
-
-void XclImpFontBuffer::ReadEfont( XclImpStream& rStrm )
-{
-    if( XclImpFont* pFont = maFontList.Last() )
-        pFont->ReadEfont( rStrm );
-}
-
-void XclImpFontBuffer::FillToItemSet(
-        SfxItemSet& rItemSet, XclFontItemType eType,
-        sal_uInt16 nFontIdx, bool bSkipPoolDefs ) const
-{
-    if( const XclImpFont* pFont = GetFont( nFontIdx ) )
-        pFont->FillToItemSet( rItemSet, eType, bSkipPoolDefs );
-}
-
-void XclImpFontBuffer::WriteFontProperties( ScfPropertySet& rPropSet,
-        XclFontPropSetType eType, sal_uInt16 nFontIdx, const Color* pFontColor ) const
-{
-    if( const XclImpFont* pFont = GetFont( nFontIdx ) )
-        pFont->WriteFontProperties( rPropSet, eType, pFontColor );
-}
-
-void XclImpFontBuffer::WriteDefaultCtrlFontProperties( ScfPropertySet& rPropSet ) const
-{
-    maCtrlFont.WriteFontProperties( rPropSet, EXC_FONTPROPSET_CONTROL );
-}
-
-void XclImpFontBuffer::UpdateAppFont( const XclFontData& rFontData, bool bHasCharSet )
-{
-    maAppFont = rFontData;
-    // #i3006# Calculate the width of '0' from first font and current printer.
-    SetCharWidth( maAppFont );
-
-    // font 4 is bold font 0
-    XclFontData aFont4Data( maAppFont );
-    aFont4Data.mnWeight = EXC_FONTWGHT_BOLD;
-    maFont4.SetFontData( aFont4Data, bHasCharSet );
-}
-
-// FORMAT record - number formats =============================================
-
-XclImpNumFmtBuffer::XclImpNumFmtBuffer( const XclImpRoot& rRoot ) :
-    XclNumFmtBuffer( rRoot ),
-    XclImpRoot( rRoot ),
-    mnNextXclIdx( 0 )
-{
-}
-
-void XclImpNumFmtBuffer::Initialize()
-{
-    maIndexMap.clear();
-    mnNextXclIdx = 0;
-    InitializeImport();     // base class
-}
-
-void XclImpNumFmtBuffer::ReadFormat( XclImpStream& rStrm )
-{
-    String aFormat;
-    switch( GetBiff() )
-    {
-        case EXC_BIFF2:
-        case EXC_BIFF3:
-            aFormat = rStrm.ReadByteString( false );
-        break;
-
-        case EXC_BIFF4:
-            rStrm.Ignore( 2 );  // in BIFF4 the index field exists, but is undefined
-            aFormat = rStrm.ReadByteString( false );
-        break;
-
-        case EXC_BIFF5:
-            rStrm >> mnNextXclIdx;
-            aFormat = rStrm.ReadByteString( false );
-        break;
-
-        case EXC_BIFF8:
-            rStrm >> mnNextXclIdx;
-            aFormat = rStrm.ReadUniString();
-        break;
-
-        default:
-            DBG_ERROR_BIFF();
-            return;
-    }
-
-    if( mnNextXclIdx < 0xFFFF )
-    {
-        InsertFormat( mnNextXclIdx, aFormat );
-        ++mnNextXclIdx;
-    }
-}
-
-void XclImpNumFmtBuffer::CreateScFormats()
-{
-    DBG_ASSERT( maIndexMap.empty(), "XclImpNumFmtBuffer::CreateScFormats - already created" );
-
-    SvNumberFormatter& rFormatter = GetFormatter();
-    for( XclNumFmtMap::const_iterator aIt = GetFormatMap().begin(), aEnd = GetFormatMap().end(); aIt != aEnd; ++aIt )
-    {
-        const XclNumFmt& rNumFmt = aIt->second;
-
-        // insert/convert the Excel number format
-        xub_StrLen nCheckPos;
-        short nType = NUMBERFORMAT_DEFINED;
-        sal_uInt32 nKey;
-        if( rNumFmt.maFormat.Len() )
-        {
-            String aFormat( rNumFmt.maFormat );
-            rFormatter.PutandConvertEntry( aFormat, nCheckPos,
-                nType, nKey, LANGUAGE_ENGLISH_US, rNumFmt.meLanguage );
-        }
-        else
-            nKey = rFormatter.GetFormatIndex( rNumFmt.meOffset, rNumFmt.meLanguage );
-
-        // insert the resulting format key into the Excel->Calc index map
-        maIndexMap[ aIt->first ] = nKey;
-    }
-}
-
-ULONG XclImpNumFmtBuffer::GetScFormat( sal_uInt16 nXclNumFmt ) const
-{
-    XclImpIndexMap::const_iterator aIt = maIndexMap.find( nXclNumFmt );
-    return (aIt != maIndexMap.end()) ? aIt->second : NUMBERFORMAT_ENTRY_NOT_FOUND;
-}
-
-void XclImpNumFmtBuffer::FillToItemSet( SfxItemSet& rItemSet, sal_uInt16 nXclNumFmt, bool bSkipPoolDefs ) const
-{
-    ULONG nScNumFmt = GetScFormat( nXclNumFmt );
-    if( nScNumFmt == NUMBERFORMAT_ENTRY_NOT_FOUND )
-        nScNumFmt = GetStdScNumFmt();
-    FillScFmtToItemSet( rItemSet, nScNumFmt, bSkipPoolDefs );
-}
-
-void XclImpNumFmtBuffer::FillScFmtToItemSet( SfxItemSet& rItemSet, ULONG nScNumFmt, bool bSkipPoolDefs ) const
-{
-    DBG_ASSERT( nScNumFmt != NUMBERFORMAT_ENTRY_NOT_FOUND, "XclImpNumFmtBuffer::FillScFmtToItemSet - invalid number format" );
-    ScfTools::PutItem( rItemSet, SfxUInt32Item( ATTR_VALUE_FORMAT, nScNumFmt ), bSkipPoolDefs );
-    if( rItemSet.GetItemState( ATTR_VALUE_FORMAT, FALSE ) == SFX_ITEM_SET )
-        ScGlobal::AddLanguage( rItemSet, GetFormatter() );
-}
-
-// XF, STYLE record - Cell formatting =========================================
-
-void XclImpCellProt::FillFromXF2( sal_uInt8 nNumFmt )
-{
-    mbLocked = ::get_flag( nNumFmt, EXC_XF2_LOCKED );
-    mbHidden = ::get_flag( nNumFmt, EXC_XF2_HIDDEN );
-}
-
-void XclImpCellProt::FillFromXF3( sal_uInt16 nProt )
-{
-    mbLocked = ::get_flag( nProt, EXC_XF_LOCKED );
-    mbHidden = ::get_flag( nProt, EXC_XF_HIDDEN );
-}
-
-void XclImpCellProt::FillToItemSet( SfxItemSet& rItemSet, bool bSkipPoolDefs ) const
-{
-    ScfTools::PutItem( rItemSet, ScProtectionAttr( mbLocked, mbHidden ), bSkipPoolDefs );
-}
-
-
-// ----------------------------------------------------------------------------
-
-void XclImpCellAlign::FillFromXF2( sal_uInt8 nFlags )
-{
-    mnHorAlign = ::extract_value< sal_uInt8 >( nFlags, 0, 3 );
-}
-
-void XclImpCellAlign::FillFromXF3( sal_uInt16 nAlign )
-{
-    mnHorAlign = ::extract_value< sal_uInt8 >( nAlign, 0, 3 );
-    mbLineBreak = ::get_flag( nAlign, EXC_XF_LINEBREAK );   // new in BIFF3
-}
-
-void XclImpCellAlign::FillFromXF4( sal_uInt16 nAlign )
-{
-    FillFromXF3( nAlign );
-    mnVerAlign = ::extract_value< sal_uInt8 >( nAlign, 4, 2 );  // new in BIFF4
-    mnOrient = ::extract_value< sal_uInt8 >( nAlign, 6, 2 );    // new in BIFF4
-}
-
-void XclImpCellAlign::FillFromXF5( sal_uInt16 nAlign )
-{
-    mnHorAlign = ::extract_value< sal_uInt8 >( nAlign, 0, 3 );
-    mnVerAlign = ::extract_value< sal_uInt8 >( nAlign, 4, 3 );
-    mbLineBreak = ::get_flag( nAlign, EXC_XF_LINEBREAK );
-    mnOrient = ::extract_value< sal_uInt8 >( nAlign, 8, 2 );
-}
-
-void XclImpCellAlign::FillFromXF8( sal_uInt16 nAlign, sal_uInt16 nMiscAttrib )
-{
-    mnHorAlign = ::extract_value< sal_uInt8 >( nAlign, 0, 3 );
-    mnVerAlign = ::extract_value< sal_uInt8 >( nAlign, 4, 3 );
-    mbLineBreak = ::get_flag( nAlign, EXC_XF_LINEBREAK );
-    mnRotation = ::extract_value< sal_uInt8 >( nAlign, 8, 8 );      // new in BIFF8
-    mnIndent = ::extract_value< sal_uInt8 >( nMiscAttrib, 0, 4 );   // new in BIFF8
-    mbShrink = ::get_flag( nMiscAttrib, EXC_XF8_SHRINK );           // new in BIFF8
-    mnTextDir = ::extract_value< sal_uInt8 >( nMiscAttrib, 6, 2 );  // new in BIFF8
-}
-
-void XclImpCellAlign::FillToItemSet( SfxItemSet& rItemSet, const XclImpFont* pFont, bool bSkipPoolDefs ) const
-{
-    // horizontal alignment
-    ScfTools::PutItem( rItemSet, SvxHorJustifyItem( GetScHorAlign(), ATTR_HOR_JUSTIFY ), bSkipPoolDefs );
-
-    // text wrap (#i74508# always if vertical alignment is justified or distributed)
-    bool bLineBreak = mbLineBreak || (mnVerAlign == EXC_XF_VER_JUSTIFY) || (mnVerAlign == EXC_XF_VER_DISTRIB);
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_LINEBREAK, bLineBreak ), bSkipPoolDefs );
-
-    // vertical alignment
-    ScfTools::PutItem( rItemSet, SvxVerJustifyItem( GetScVerAlign(), ATTR_VER_JUSTIFY ), bSkipPoolDefs );
-
-    // indent
-    sal_uInt16 nScIndent = mnIndent * 200; // 1 Excel unit == 10 pt == 200 twips
-    ScfTools::PutItem( rItemSet, SfxUInt16Item( ATTR_INDENT, nScIndent ), bSkipPoolDefs );
-
-    // shrink to fit
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_SHRINKTOFIT, mbShrink ), bSkipPoolDefs );
-
-    // text orientation/rotation (BIFF2-BIFF7 sets mnOrient)
-    sal_uInt8 nXclRot = (mnOrient == EXC_ORIENT_NONE) ? mnRotation : XclTools::GetXclRotFromOrient( mnOrient );
-    bool bStacked = (nXclRot == EXC_ROT_STACKED);
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_STACKED, bStacked ), bSkipPoolDefs );
-    // set an angle in the range from -90 to 90 degrees
-    sal_Int32 nAngle = XclTools::GetScRotation( nXclRot, 0 );
-    ScfTools::PutItem( rItemSet, SfxInt32Item( ATTR_ROTATE_VALUE, nAngle ), bSkipPoolDefs );
-    // #105933# set "Use asian vertical layout", if cell is stacked and font contains CKJ characters
-    bool bAsianVert = bStacked && pFont && pFont->HasAsianChars();
-    ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_VERTICAL_ASIAN, bAsianVert ), bSkipPoolDefs );
-
-    // CTL text direction
-    ScfTools::PutItem( rItemSet, SvxFrameDirectionItem( GetScFrameDir(), ATTR_WRITINGDIR ), bSkipPoolDefs );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpCellBorder::XclImpCellBorder()
-{
-    SetUsedFlags( false, false );
-}
-
-void XclImpCellBorder::SetUsedFlags( bool bOuterUsed, bool bDiagUsed )
-{
-    mbLeftUsed = mbRightUsed = mbTopUsed = mbBottomUsed = bOuterUsed;
-    mbDiagUsed = bDiagUsed;
-}
-
-void XclImpCellBorder::FillFromXF2( sal_uInt8 nFlags )
-{
-    mnLeftLine   = ::get_flagvalue( nFlags, EXC_XF2_LEFTLINE,   EXC_LINE_THIN, EXC_LINE_NONE );
-    mnRightLine  = ::get_flagvalue( nFlags, EXC_XF2_RIGHTLINE,  EXC_LINE_THIN, EXC_LINE_NONE );
-    mnTopLine    = ::get_flagvalue( nFlags, EXC_XF2_TOPLINE,    EXC_LINE_THIN, EXC_LINE_NONE );
-    mnBottomLine = ::get_flagvalue( nFlags, EXC_XF2_BOTTOMLINE, EXC_LINE_THIN, EXC_LINE_NONE );
-    mnLeftColor = mnRightColor = mnTopColor = mnBottomColor = EXC_COLOR_BIFF2_BLACK;
-    SetUsedFlags( true, false );
-}
-
-void XclImpCellBorder::FillFromXF3( sal_uInt32 nBorder )
-{
-    mnTopLine     = ::extract_value< sal_uInt8  >( nBorder,  0, 3 );
-    mnLeftLine    = ::extract_value< sal_uInt8  >( nBorder,  8, 3 );
-    mnBottomLine  = ::extract_value< sal_uInt8  >( nBorder, 16, 3 );
-    mnRightLine   = ::extract_value< sal_uInt8  >( nBorder, 24, 3 );
-    mnTopColor    = ::extract_value< sal_uInt16 >( nBorder,  3, 5 );
-    mnLeftColor   = ::extract_value< sal_uInt16 >( nBorder, 11, 5 );
-    mnBottomColor = ::extract_value< sal_uInt16 >( nBorder, 19, 5 );
-    mnRightColor  = ::extract_value< sal_uInt16 >( nBorder, 27, 5 );
-    SetUsedFlags( true, false );
-}
-
-void XclImpCellBorder::FillFromXF5( sal_uInt32 nBorder, sal_uInt32 nArea )
-{
-    mnTopLine     = ::extract_value< sal_uInt8  >( nBorder,  0, 3 );
-    mnLeftLine    = ::extract_value< sal_uInt8  >( nBorder,  3, 3 );
-    mnBottomLine  = ::extract_value< sal_uInt8  >( nArea,   22, 3 );
-    mnRightLine   = ::extract_value< sal_uInt8  >( nBorder,  6, 3 );
-    mnTopColor    = ::extract_value< sal_uInt16 >( nBorder,  9, 7 );
-    mnLeftColor   = ::extract_value< sal_uInt16 >( nBorder, 16, 7 );
-    mnBottomColor = ::extract_value< sal_uInt16 >( nArea,   25, 7 );
-    mnRightColor  = ::extract_value< sal_uInt16 >( nBorder, 23, 7 );
-    SetUsedFlags( true, false );
-}
-
-void XclImpCellBorder::FillFromXF8( sal_uInt32 nBorder1, sal_uInt32 nBorder2 )
-{
-    mnLeftLine    = ::extract_value< sal_uInt8  >( nBorder1,  0, 4 );
-    mnRightLine   = ::extract_value< sal_uInt8  >( nBorder1,  4, 4 );
-    mnTopLine     = ::extract_value< sal_uInt8  >( nBorder1,  8, 4 );
-    mnBottomLine  = ::extract_value< sal_uInt8  >( nBorder1, 12, 4 );
-    mnLeftColor   = ::extract_value< sal_uInt16 >( nBorder1, 16, 7 );
-    mnRightColor  = ::extract_value< sal_uInt16 >( nBorder1, 23, 7 );
-    mnTopColor    = ::extract_value< sal_uInt16 >( nBorder2,  0, 7 );
-    mnBottomColor = ::extract_value< sal_uInt16 >( nBorder2,  7, 7 );
-    mbDiagTLtoBR  = ::get_flag( nBorder1, EXC_XF_DIAGONAL_TL_TO_BR );
-    mbDiagBLtoTR  = ::get_flag( nBorder1, EXC_XF_DIAGONAL_BL_TO_TR );
-    if( mbDiagTLtoBR || mbDiagBLtoTR )
-    {
-        mnDiagLine  = ::extract_value< sal_uInt8 >( nBorder2, 21, 4 );
-        mnDiagColor = ::extract_value< sal_uInt16 >( nBorder2, 14, 7 );
-    }
-    SetUsedFlags( true, true );
-}
-
-void XclImpCellBorder::FillFromCF8( sal_uInt16 nLineStyle, sal_uInt32 nLineColor, sal_uInt32 nFlags )
-{
-    mnLeftLine    = ::extract_value< sal_uInt8  >( nLineStyle,  0, 4 );
-    mnRightLine   = ::extract_value< sal_uInt8  >( nLineStyle,  4, 4 );
-    mnTopLine     = ::extract_value< sal_uInt8  >( nLineStyle,  8, 4 );
-    mnBottomLine  = ::extract_value< sal_uInt8  >( nLineStyle, 12, 4 );
-    mnLeftColor   = ::extract_value< sal_uInt16 >( nLineColor,  0, 7 );
-    mnRightColor  = ::extract_value< sal_uInt16 >( nLineColor,  7, 7 );
-    mnTopColor    = ::extract_value< sal_uInt16 >( nLineColor, 16, 7 );
-    mnBottomColor = ::extract_value< sal_uInt16 >( nLineColor, 23, 7 );
-    mbLeftUsed    = !::get_flag( nFlags, EXC_CF_BORDER_LEFT );
-    mbRightUsed   = !::get_flag( nFlags, EXC_CF_BORDER_RIGHT );
-    mbTopUsed     = !::get_flag( nFlags, EXC_CF_BORDER_TOP );
-    mbBottomUsed  = !::get_flag( nFlags, EXC_CF_BORDER_BOTTOM );
-    mbDiagUsed    = false;
-}
-
-bool XclImpCellBorder::HasAnyOuterBorder() const
-{
-    return
-        (mbLeftUsed   && (mnLeftLine != EXC_LINE_NONE)) ||
-        (mbRightUsed  && (mnRightLine != EXC_LINE_NONE)) ||
-        (mbTopUsed    && (mnTopLine != EXC_LINE_NONE)) ||
-        (mbBottomUsed && (mnBottomLine != EXC_LINE_NONE));
-}
-
-namespace {
-
-/** Converts the passed line style to a SvxBorderLine, or returns false, if style is "no line". */
-bool lclConvertBorderLine( SvxBorderLine& rLine, const XclImpPalette& rPalette, sal_uInt8 nXclLine, sal_uInt16 nXclColor )
-{
-    static const sal_uInt16 ppnLineParam[][ 3 ] =
-    {
-        //  outer width,        inner width,        distance
-        {   0,                  0,                  0 },                // 0 = none
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // 1 = thin
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // 2 = medium
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // 3 = dashed
-        {   DEF_LINE_WIDTH_0,   0,                  0 },                // 4 = dotted
-        {   DEF_LINE_WIDTH_3,   0,                  0 },                // 5 = thick
-        {   DEF_LINE_WIDTH_1,   DEF_LINE_WIDTH_1,   DEF_LINE_WIDTH_1 }, // 6 = double
-        {   DEF_LINE_WIDTH_0,   0,                  0 },                // 7 = hair
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // 8 = med dash
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // 9 = thin dashdot
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // A = med dashdot
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // B = thin dashdotdot
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // C = med dashdotdot
-        {   DEF_LINE_WIDTH_2,   0,                  0 }                 // D = med slant dashdot
-    };
-
-    if( nXclLine == EXC_LINE_NONE )
-        return false;
-    if( nXclLine >= STATIC_TABLE_SIZE( ppnLineParam ) )
-        nXclLine = EXC_LINE_THIN;
-
-    rLine.SetColor( rPalette.GetColor( nXclColor ) );
-    rLine.SetOutWidth( ppnLineParam[ nXclLine ][ 0 ] );
-    rLine.SetInWidth(  ppnLineParam[ nXclLine ][ 1 ] );
-    rLine.SetDistance( ppnLineParam[ nXclLine ][ 2 ] );
-    return true;
-}
-
-} // namespace
-
-void XclImpCellBorder::FillToItemSet( SfxItemSet& rItemSet, const XclImpPalette& rPalette, bool bSkipPoolDefs ) const
-{
-    if( mbLeftUsed || mbRightUsed || mbTopUsed || mbBottomUsed )
-    {
-        SvxBoxItem aBoxItem( ATTR_BORDER );
-        SvxBorderLine aLine;
-        if( mbLeftUsed && lclConvertBorderLine( aLine, rPalette, mnLeftLine, mnLeftColor ) )
-            aBoxItem.SetLine( &aLine, BOX_LINE_LEFT );
-        if( mbRightUsed && lclConvertBorderLine( aLine, rPalette, mnRightLine, mnRightColor ) )
-            aBoxItem.SetLine( &aLine, BOX_LINE_RIGHT );
-        if( mbTopUsed && lclConvertBorderLine( aLine, rPalette, mnTopLine, mnTopColor ) )
-            aBoxItem.SetLine( &aLine, BOX_LINE_TOP );
-        if( mbBottomUsed && lclConvertBorderLine( aLine, rPalette, mnBottomLine, mnBottomColor ) )
-            aBoxItem.SetLine( &aLine, BOX_LINE_BOTTOM );
-        ScfTools::PutItem( rItemSet, aBoxItem, bSkipPoolDefs );
-    }
-    if( mbDiagUsed )
-    {
-        SvxLineItem aTLBRItem( ATTR_BORDER_TLBR );
-        SvxLineItem aBLTRItem( ATTR_BORDER_BLTR );
-        SvxBorderLine aLine;
-        if( lclConvertBorderLine( aLine, rPalette, mnDiagLine, mnDiagColor ) )
-        {
-            if( mbDiagTLtoBR )
-                aTLBRItem.SetLine( &aLine );
-            if( mbDiagBLtoTR )
-                aBLTRItem.SetLine( &aLine );
-        }
-        ScfTools::PutItem( rItemSet, aTLBRItem, bSkipPoolDefs );
-        ScfTools::PutItem( rItemSet, aBLTRItem, bSkipPoolDefs );
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpCellArea::XclImpCellArea()
-{
-    SetUsedFlags( false );
-}
-
-void XclImpCellArea::SetUsedFlags( bool bUsed )
-{
-    mbForeUsed = mbBackUsed = mbPattUsed = bUsed;
-}
-
-void XclImpCellArea::FillFromXF2( sal_uInt8 nFlags )
-{
-    mnPattern = ::get_flagvalue( nFlags, EXC_XF2_BACKGROUND, EXC_PATT_12_5_PERC, EXC_PATT_NONE );
-    mnForeColor = EXC_COLOR_BIFF2_BLACK;
-    mnBackColor = EXC_COLOR_BIFF2_WHITE;
-    SetUsedFlags( true );
-}
-
-void XclImpCellArea::FillFromXF3( sal_uInt16 nArea )
-{
-    mnPattern   = ::extract_value< sal_uInt8  >( nArea,  0, 6 );
-    mnForeColor = ::extract_value< sal_uInt16 >( nArea,  6, 5 );
-    mnBackColor = ::extract_value< sal_uInt16 >( nArea, 11, 5 );
-    SetUsedFlags( true );
-}
-
-void XclImpCellArea::FillFromXF5( sal_uInt32 nArea )
-{
-    mnPattern   = ::extract_value< sal_uInt8  >( nArea, 16, 6 );
-    mnForeColor = ::extract_value< sal_uInt16 >( nArea,  0, 7 );
-    mnBackColor = ::extract_value< sal_uInt16 >( nArea,  7, 7 );
-    SetUsedFlags( true );
-}
-
-void XclImpCellArea::FillFromXF8( sal_uInt32 nBorder2, sal_uInt16 nArea )
-{
-    mnPattern   = ::extract_value< sal_uInt8  >( nBorder2, 26, 6 );
-    mnForeColor = ::extract_value< sal_uInt16 >( nArea,     0, 7 );
-    mnBackColor = ::extract_value< sal_uInt16 >( nArea,     7, 7 );
-    SetUsedFlags( true );
-}
-
-void XclImpCellArea::FillFromCF8( sal_uInt16 nPattern, sal_uInt16 nColor, sal_uInt32 nFlags )
-{
-    mnForeColor = ::extract_value< sal_uInt16 >( nColor,    0, 7 );
-    mnBackColor = ::extract_value< sal_uInt16 >( nColor,    7, 7 );
-    mnPattern   = ::extract_value< sal_uInt8  >( nPattern, 10, 6 );
-    mbForeUsed  = !::get_flag( nFlags, EXC_CF_AREA_FGCOLOR );
-    mbBackUsed  = !::get_flag( nFlags, EXC_CF_AREA_BGCOLOR );
-    mbPattUsed  = !::get_flag( nFlags, EXC_CF_AREA_PATTERN );
-
-    if( mbBackUsed && (!mbPattUsed || (mnPattern == EXC_PATT_SOLID)) )
-    {
-        mnForeColor = mnBackColor;
-        mnPattern = EXC_PATT_SOLID;
-        mbForeUsed = mbPattUsed = true;
-    }
-    else if( !mbBackUsed && mbPattUsed && (mnPattern == EXC_PATT_SOLID) )
-    {
-        mbPattUsed = false;
-    }
-}
-
-void XclImpCellArea::FillToItemSet( SfxItemSet& rItemSet, const XclImpPalette& rPalette, bool bSkipPoolDefs ) const
-{
-    if( mbPattUsed )    // colors may be both unused in cond. formats
-    {
-        SvxBrushItem aBrushItem( ATTR_BACKGROUND );
-
-        // #108935# do not use IsTransparent() - old Calc filter writes tranparency with different color indexes
-        if( mnPattern == EXC_PATT_NONE )
-        {
-            aBrushItem.SetColor( Color( COL_TRANSPARENT ) );
-        }
-        else
-        {
-            Color aFore( rPalette.GetColor( mbForeUsed ? mnForeColor : EXC_COLOR_WINDOWTEXT ) );
-            Color aBack( rPalette.GetColor( mbBackUsed ? mnBackColor : EXC_COLOR_WINDOWBACK ) );
-            aBrushItem.SetColor( XclTools::GetPatternColor( aFore, aBack, mnPattern ) );
-        }
-
-        ScfTools::PutItem( rItemSet, aBrushItem, bSkipPoolDefs );
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-
-XclImpXF::XclImpXF( const XclImpRoot& rRoot ) :
-    XclXFBase( true ),      // default is cell XF
-    XclImpRoot( rRoot ),
-    mpStyleSheet( 0 ),
-    mnXclNumFmt( 0 ),
-    mnXclFont( 0 )
-{
-}
-
-XclImpXF::~XclImpXF()
-{
-}
-
-void XclImpXF::ReadXF2( XclImpStream& rStrm )
-{
-    sal_uInt8 nReadFont, nReadNumFmt, nFlags;
-    rStrm >> nReadFont;
-    rStrm.Ignore( 1 );
-    rStrm >> nReadNumFmt >> nFlags;
-
-    // XF type always cell, no parent, used flags always true
-    SetAllUsedFlags( true );
-
-    // attributes
-    maProtection.FillFromXF2( nReadNumFmt );
-    mnXclFont = nReadFont;
-    mnXclNumFmt = nReadNumFmt & EXC_XF2_VALFMT_MASK;
-    maAlignment.FillFromXF2( nFlags );
-    maBorder.FillFromXF2( nFlags );
-    maArea.FillFromXF2( nFlags );
-}
-
-void XclImpXF::ReadXF3( XclImpStream& rStrm )
-{
-    sal_uInt32 nBorder;
-    sal_uInt16 nTypeProt, nAlign, nArea;
-    sal_uInt8 nReadFont, nReadNumFmt;
-    rStrm >> nReadFont >> nReadNumFmt >> nTypeProt >> nAlign >> nArea >> nBorder;
-
-    // XF type/parent, attribute used flags
-    mbCellXF = !::get_flag( nTypeProt, EXC_XF_STYLE );          // new in BIFF3
-    mnParent = ::extract_value< sal_uInt16 >( nAlign, 4, 12 );  // new in BIFF3
-    SetUsedFlags( ::extract_value< sal_uInt8 >( nTypeProt, 10, 6 ) );
-
-    // attributes
-    maProtection.FillFromXF3( nTypeProt );
-    mnXclFont = nReadFont;
-    mnXclNumFmt = nReadNumFmt;
-    maAlignment.FillFromXF3( nAlign );
-    maBorder.FillFromXF3( nBorder );
-    maArea.FillFromXF3( nArea );                        // new in BIFF3
-}
-
-void XclImpXF::ReadXF4( XclImpStream& rStrm )
-{
-    sal_uInt32 nBorder;
-    sal_uInt16 nTypeProt, nAlign, nArea;
-    sal_uInt8 nReadFont, nReadNumFmt;
-    rStrm >> nReadFont >> nReadNumFmt >> nTypeProt >> nAlign >> nArea >> nBorder;
-
-    // XF type/parent, attribute used flags
-    mbCellXF = !::get_flag( nTypeProt, EXC_XF_STYLE );
-    mnParent = ::extract_value< sal_uInt16 >( nTypeProt, 4, 12 );
-    SetUsedFlags( ::extract_value< sal_uInt8 >( nAlign, 10, 6 ) );
-
-    // attributes
-    maProtection.FillFromXF3( nTypeProt );
-    mnXclFont = nReadFont;
-    mnXclNumFmt = nReadNumFmt;
-    maAlignment.FillFromXF4( nAlign );
-    maBorder.FillFromXF3( nBorder );
-    maArea.FillFromXF3( nArea );
-}
-
-void XclImpXF::ReadXF5( XclImpStream& rStrm )
-{
-    sal_uInt32 nArea, nBorder;
-    sal_uInt16 nTypeProt, nAlign;
-    rStrm >> mnXclFont >> mnXclNumFmt >> nTypeProt >> nAlign >> nArea >> nBorder;
-
-    // XF type/parent, attribute used flags
-    mbCellXF = !::get_flag( nTypeProt, EXC_XF_STYLE );
-    mnParent = ::extract_value< sal_uInt16 >( nTypeProt, 4, 12 );
-    SetUsedFlags( ::extract_value< sal_uInt8 >( nAlign, 10, 6 ) );
-
-    // attributes
-    maProtection.FillFromXF3( nTypeProt );
-    maAlignment.FillFromXF5( nAlign );
-    maBorder.FillFromXF5( nBorder, nArea );
-    maArea.FillFromXF5( nArea );
-}
-
-void XclImpXF::ReadXF8( XclImpStream& rStrm )
-{
-    sal_uInt32 nBorder1, nBorder2;
-    sal_uInt16 nTypeProt, nAlign, nMiscAttrib, nArea;
-    rStrm >> mnXclFont >> mnXclNumFmt >> nTypeProt >> nAlign >> nMiscAttrib >> nBorder1 >> nBorder2 >> nArea;
-
-    // XF type/parent, attribute used flags
-    mbCellXF = !::get_flag( nTypeProt, EXC_XF_STYLE );
-    mnParent = ::extract_value< sal_uInt16 >( nTypeProt, 4, 12 );
-    SetUsedFlags( ::extract_value< sal_uInt8 >( nMiscAttrib, 10, 6 ) );
-
-    // attributes
-    maProtection.FillFromXF3( nTypeProt );
-    maAlignment.FillFromXF8( nAlign, nMiscAttrib );
-    maBorder.FillFromXF8( nBorder1, nBorder2 );
-    maArea.FillFromXF8( nBorder2, nArea );
-}
-
-void XclImpXF::ReadXF( XclImpStream& rStrm )
-{
-    switch( GetBiff() )
-    {
-        case EXC_BIFF2: ReadXF2( rStrm );   break;
-        case EXC_BIFF3: ReadXF3( rStrm );   break;
-        case EXC_BIFF4: ReadXF4( rStrm );   break;
-        case EXC_BIFF5: ReadXF5( rStrm );   break;
-        case EXC_BIFF8: ReadXF8( rStrm );   break;
-        default:        DBG_ERROR_BIFF();
-    }
-}
-
-const ScPatternAttr& XclImpXF::CreatePattern( bool bSkipPoolDefs )
-{
-    if( mpPattern.get() )
-        return *mpPattern;
-
-    // create new pattern attribute set
-    mpPattern.reset( new ScPatternAttr( GetDoc().GetPool() ) );
-    SfxItemSet& rItemSet = mpPattern->GetItemSet();
-    XclImpXF* pParentXF = IsCellXF() ? GetXFBuffer().GetXF( mnParent ) : 0;
-
-    // parent cell style
-    if( IsCellXF() && !mpStyleSheet )
-    {
-        mpStyleSheet = GetXFBuffer().CreateStyleSheet( mnParent );
-        if (pParentXF)
-            UpdateUsedFlags( *pParentXF );
-    }
-
-    // cell protection
-    if( mbProtUsed )
-        maProtection.FillToItemSet( rItemSet, bSkipPoolDefs );
-
-    // font
-    if( mbFontUsed )
-        GetFontBuffer().FillToItemSet( rItemSet, EXC_FONTITEM_CELL, mnXclFont, bSkipPoolDefs );
-
-    // value format
-    if( mbFmtUsed )
-    {
-        GetNumFmtBuffer().FillToItemSet( rItemSet, mnXclNumFmt, bSkipPoolDefs );
-        // Trace occurrences of Windows date formats
-        GetTracer().TraceDates( mnXclNumFmt );
-    }
-
-    // alignment
-    if( mbAlignUsed )
-        maAlignment.FillToItemSet( rItemSet, GetFontBuffer().GetFont( mnXclFont ), bSkipPoolDefs );
-
-    // border
-    if( mbBorderUsed )
-    {
-        maBorder.FillToItemSet( rItemSet, GetPalette(), bSkipPoolDefs );
-        GetTracer().TraceBorderLineStyle(maBorder.mnLeftLine > EXC_LINE_HAIR ||
-            maBorder.mnRightLine > EXC_LINE_HAIR || maBorder.mnTopLine > EXC_LINE_HAIR ||
-            maBorder.mnBottomLine > EXC_LINE_HAIR );
-    }
-
-    // area
-    if( mbAreaUsed )
-    {
-        maArea.FillToItemSet( rItemSet, GetPalette(), bSkipPoolDefs );
-        GetTracer().TraceFillPattern(maArea.mnPattern != EXC_PATT_NONE &&
-            maArea.mnPattern != EXC_PATT_SOLID);
-    }
-
-    /*  #i38709# Decide which rotation reference mode to use. If any outer
-        border line of the cell is set (either explicitly or via cell style),
-        and the cell contents are rotated, set rotation reference to bottom of
-        cell. This causes the borders to be painted rotated with the text. */
-    if( mbAlignUsed || mbBorderUsed )
-    {
-        SvxRotateMode eRotateMode = SVX_ROTATE_MODE_STANDARD;
-        const XclImpCellAlign* pAlign = mbAlignUsed ? &maAlignment : (pParentXF ? &pParentXF->maAlignment : 0);
-        const XclImpCellBorder* pBorder = mbBorderUsed ? &maBorder : (pParentXF ? &pParentXF->maBorder : 0);
-        if( pAlign && pBorder && (0 < pAlign->mnRotation) && (pAlign->mnRotation <= 180) && pBorder->HasAnyOuterBorder() )
-            eRotateMode = SVX_ROTATE_MODE_BOTTOM;
-        ScfTools::PutItem( rItemSet, SvxRotateModeItem( eRotateMode, ATTR_ROTATE_MODE ), bSkipPoolDefs );
-    }
-
-    return *mpPattern;
-}
-
-void XclImpXF::ApplyPattern(
-        SCCOL nScCol1, SCROW nScRow1, SCCOL nScCol2, SCROW nScRow2,
-        SCTAB nScTab, ULONG nForceScNumFmt )
-{
-    // force creation of cell style and hard formatting, do it here to have mpStyleSheet
-    const ScPatternAttr& rPattern = CreatePattern();
-
-    // insert into document
-    ScDocument& rDoc = GetDoc();
-    if( IsCellXF() && mpStyleSheet )
-        rDoc.ApplyStyleAreaTab( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, *mpStyleSheet );
-    if( HasUsedFlags() )
-        rDoc.ApplyPatternAreaTab( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, rPattern );
-
-    // #108770# apply special number format
-    if( nForceScNumFmt != NUMBERFORMAT_ENTRY_NOT_FOUND )
-    {
-        ScPatternAttr aPattern( GetDoc().GetPool() );
-        GetNumFmtBuffer().FillScFmtToItemSet( aPattern.GetItemSet(), nForceScNumFmt );
-        rDoc.ApplyPatternAreaTab( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, aPattern );
-    }
-}
-
-void XclImpXF::SetUsedFlags( sal_uInt8 nUsedFlags )
-{
-    /*  Notes about finding the mb***Used flags:
-        - In cell XFs a *set* bit means a used attribute.
-        - In style XFs a *cleared* bit means a used attribute.
-        The mb***Used members always store true, if the attribute is used.
-        The "mbCellXF == ::get_flag(...)" construct evaluates to true in
-        both mentioned cases: cell XF and set bit; or style XF and cleared bit.
-     */
-    mbProtUsed   = (mbCellXF == ::get_flag( nUsedFlags, EXC_XF_DIFF_PROT ));
-    mbFontUsed   = (mbCellXF == ::get_flag( nUsedFlags, EXC_XF_DIFF_FONT ));
-    mbFmtUsed    = (mbCellXF == ::get_flag( nUsedFlags, EXC_XF_DIFF_VALFMT ));
-    mbAlignUsed  = (mbCellXF == ::get_flag( nUsedFlags, EXC_XF_DIFF_ALIGN ));
-    mbBorderUsed = (mbCellXF == ::get_flag( nUsedFlags, EXC_XF_DIFF_BORDER ));
-    mbAreaUsed   = (mbCellXF == ::get_flag( nUsedFlags, EXC_XF_DIFF_AREA ));
-}
-
-void XclImpXF::UpdateUsedFlags( const XclImpXF& rParentXF )
-{
-    /*  Enables mb***Used flags, if the formatting attributes differ from
-        the passed XF record. In cell XFs Excel uses the cell attributes,
-        if they differ from the parent style XF.
-        #109899# ...or if the respective flag is not set in parent style XF. */
-    if( !mbProtUsed )
-        mbProtUsed = !rParentXF.mbProtUsed || !(maProtection == rParentXF.maProtection);
-    if( !mbFontUsed )
-        mbFontUsed = !rParentXF.mbFontUsed || (mnXclFont != rParentXF.mnXclFont);
-    if( !mbFmtUsed )
-        mbFmtUsed = !rParentXF.mbFmtUsed || (mnXclNumFmt != rParentXF.mnXclNumFmt);
-    if( !mbAlignUsed )
-        mbAlignUsed = !rParentXF.mbAlignUsed || !(maAlignment == rParentXF.maAlignment);
-    if( !mbBorderUsed )
-        mbBorderUsed = !rParentXF.mbBorderUsed || !(maBorder == rParentXF.maBorder);
-    if( !mbAreaUsed )
-        mbAreaUsed = !rParentXF.mbAreaUsed || !(maArea == rParentXF.maArea);
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpStyle::XclImpStyle( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    mnXfId( EXC_XF_NOTFOUND ),
-    mnBuiltinId( EXC_STYLE_USERDEF ),
-    mnLevel( EXC_STYLE_NOLEVEL ),
-    mbBuiltin( false ),
-    mbCustom( false ),
-    mbHidden( false ),
-    mpStyleSheet( 0 )
-{
-}
-
-void XclImpStyle::ReadStyle( XclImpStream& rStrm )
-{
-    DBG_ASSERT_BIFF( GetBiff() >= EXC_BIFF3 );
-
-    sal_uInt16 nXFIndex;
-    rStrm >> nXFIndex;
-    mnXfId = nXFIndex & EXC_STYLE_XFMASK;
-    mbBuiltin = ::get_flag( nXFIndex, EXC_STYLE_BUILTIN );
-
-    if( mbBuiltin )
-    {
-        rStrm >> mnBuiltinId >> mnLevel;
-    }
-    else
-    {
-        maName = (GetBiff() <= EXC_BIFF5) ? rStrm.ReadByteString( false ) : rStrm.ReadUniString();
-        // #i103281# check if this is a new built-in style introduced in XL2007
-        if( (GetBiff() == EXC_BIFF8) && (rStrm.GetNextRecId() == EXC_ID_STYLEEXT) && rStrm.StartNextRecord() )
-        {
-            sal_uInt8 nExtFlags;
-            rStrm.Ignore( 12 );
-            rStrm >> nExtFlags;
-            mbBuiltin = ::get_flag( nExtFlags, EXC_STYLEEXT_BUILTIN );
-            mbCustom = ::get_flag( nExtFlags, EXC_STYLEEXT_CUSTOM );
-            mbHidden = ::get_flag( nExtFlags, EXC_STYLEEXT_HIDDEN );
-            if( mbBuiltin )
-            {
-                rStrm.Ignore( 1 );  // category
-                rStrm >> mnBuiltinId >> mnLevel;
-            }
-        }
-    }
-}
-
-ScStyleSheet* XclImpStyle::CreateStyleSheet()
-{
-    // #i1624# #i1768# ignore unnamed user styles
-    if( !mpStyleSheet && (maFinalName.Len() > 0) )
-    {
-        bool bCreatePattern = false;
-        XclImpXF* pXF = GetXFBuffer().GetXF( mnXfId );
-
-        bool bDefStyle = mbBuiltin && (mnBuiltinId == EXC_STYLE_NORMAL);
-        if( bDefStyle )
-        {
-            // set all flags to true to get all items in XclImpXF::CreatePattern()
-            if( pXF ) pXF->SetAllUsedFlags( true );
-            // use existing "Default" style sheet
-            mpStyleSheet = static_cast< ScStyleSheet* >( GetStyleSheetPool().Find(
-                ScGlobal::GetRscString( STR_STYLENAME_STANDARD ), SFX_STYLE_FAMILY_PARA ) );
-            DBG_ASSERT( mpStyleSheet, "XclImpStyle::CreateStyleSheet - Default style not found" );
-            bCreatePattern = true;
-        }
-        else
-        {
-            /*  #i103281# do not create another style sheet of the same name,
-                if it exists already. This is needed to prevent that styles
-                pasted from clipboard get duplicated over and over. */
-            mpStyleSheet = static_cast< ScStyleSheet* >( GetStyleSheetPool().Find( maFinalName, SFX_STYLE_FAMILY_PARA ) );
-            if( !mpStyleSheet )
-            {
-                mpStyleSheet = &static_cast< ScStyleSheet& >( GetStyleSheetPool().Make( maFinalName, SFX_STYLE_FAMILY_PARA, SFXSTYLEBIT_USERDEF ) );
-                bCreatePattern = true;
-            }
-        }
-
-        // bDefStyle==true omits default pool items in CreatePattern()
-        if( bCreatePattern && mpStyleSheet && pXF )
-            mpStyleSheet->GetItemSet().Put( pXF->CreatePattern( bDefStyle ).GetItemSet() );
-    }
-    return mpStyleSheet;
-}
-
-void XclImpStyle::CreateUserStyle( const String& rFinalName )
-{
-    maFinalName = rFinalName;
-    if( !IsBuiltin() || mbCustom )
-        CreateStyleSheet();
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpXFBuffer::XclImpXFBuffer( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpXFBuffer::Initialize()
-{
-    maXFList.Clear();
-    maBuiltinStyles.Clear();
-    maUserStyles.Clear();
-    maStylesByXf.clear();
-}
-
-void XclImpXFBuffer::ReadXF( XclImpStream& rStrm )
-{
-    XclImpXF* pXF = new XclImpXF( GetRoot() );
-    pXF->ReadXF( rStrm );
-    maXFList.Append( pXF );
-}
-
-void XclImpXFBuffer::ReadStyle( XclImpStream& rStrm )
-{
-    XclImpStyle* pStyle = new XclImpStyle( GetRoot() );
-    pStyle->ReadStyle( rStrm );
-    (pStyle->IsBuiltin() ? maBuiltinStyles : maUserStyles).Append( pStyle );
-    DBG_ASSERT( maStylesByXf.count( pStyle->GetXfId() ) == 0, "XclImpXFBuffer::ReadStyle - multiple styles with equal XF identifier" );
-    maStylesByXf[ pStyle->GetXfId() ] = pStyle;
-}
-
-sal_uInt16 XclImpXFBuffer::GetFontIndex( sal_uInt16 nXFIndex ) const
-{
-    const XclImpXF* pXF = GetXF( nXFIndex );
-    return pXF ? pXF->GetFontIndex() : EXC_FONT_NOTFOUND;
-}
-
-const XclImpFont* XclImpXFBuffer::GetFont( sal_uInt16 nXFIndex ) const
-{
-    return GetFontBuffer().GetFont( GetFontIndex( nXFIndex ) );
-}
-
-namespace {
-
-/** Functor for case-insensitive string comparison, usable in maps etc. */
-struct IgnoreCaseCompare
-{
-    inline bool operator()( const String& rName1, const String& rName2 ) const
-        { return rName1.CompareIgnoreCaseToAscii( rName2 ) == COMPARE_LESS; }
-};
-
-} // namespace
-
-void XclImpXFBuffer::CreateUserStyles()
-{
-    // calculate final names of all styles
-    typedef ::std::map< String, XclImpStyle*, IgnoreCaseCompare > CellStyleNameMap;
-    typedef ::std::vector< XclImpStyle* > XclImpStyleVector;
-
-    CellStyleNameMap aCellStyles;
-    XclImpStyleVector aConflictNameStyles;
-
-    /*  First, reserve style names that are built-in in Calc. This causes that
-        imported cell styles get different unused names and thus do not try to
-        overwrite these built-in styles. For BIFF4 workbooks (which contain a
-        separate list of cell styles per sheet), reserve all existing styles if
-        current sheet is not the first sheet (this styles buffer will be
-        initialized again for every new sheet). This will create unique names
-        for styles in different sheets with the same name. Assuming that the
-        BIFF4W import filter is never used to import from clipboard... */
-    bool bReserveAll = (GetBiff() == EXC_BIFF4) && (GetCurrScTab() > 0);
-    SfxStyleSheetIterator aStyleIter( GetDoc().GetStyleSheetPool(), SFX_STYLE_FAMILY_PARA );
-    String aStandardName = ScGlobal::GetRscString( STR_STYLENAME_STANDARD );
-    for( SfxStyleSheetBase* pStyleSheet = aStyleIter.First(); pStyleSheet; pStyleSheet = aStyleIter.Next() )
-        if( (pStyleSheet->GetName() != aStandardName) && (bReserveAll || !pStyleSheet->IsUserDefined()) )
-            if( aCellStyles.count( pStyleSheet->GetName() ) == 0 )
-                aCellStyles[ pStyleSheet->GetName() ] = 0;
-
-    /*  Calculate names of built-in styles. Store styles with reserved names
-        in the aConflictNameStyles list. */
-    for( XclImpStyle* pStyle = maBuiltinStyles.First(); pStyle; pStyle = maBuiltinStyles.Next() )
-    {
-        String aStyleName = XclTools::GetBuiltInStyleName( pStyle->GetBuiltinId(), pStyle->GetName(), pStyle->GetLevel() );
-        DBG_ASSERT( bReserveAll || (aCellStyles.count( aStyleName ) == 0),
-            "XclImpXFBuffer::CreateUserStyles - multiple styles with equal built-in identifier" );
-        if( aCellStyles.count( aStyleName ) > 0 )
-            aConflictNameStyles.push_back( pStyle );
-        else
-            aCellStyles[ aStyleName ] = pStyle;
-    }
-
-    /*  Calculate names of user defined styles. Store styles with reserved
-        names in the aConflictNameStyles list. */
-    for( XclImpStyle* pStyle = maUserStyles.First(); pStyle; pStyle = maUserStyles.Next() )
-    {
-        // #i1624# #i1768# ignore unnamed user styles
-        if( pStyle->GetName().Len() > 0 )
-        {
-            if( aCellStyles.count( pStyle->GetName() ) > 0 )
-                aConflictNameStyles.push_back( pStyle );
-            else
-                aCellStyles[ pStyle->GetName() ] = pStyle;
-        }
-    }
-
-    // find unused names for all styles with conflicting names
-    for( XclImpStyleVector::iterator aIt = aConflictNameStyles.begin(), aEnd = aConflictNameStyles.end(); aIt != aEnd; ++aIt )
-    {
-        XclImpStyle* pStyle = *aIt;
-        String aUnusedName;
-        sal_Int32 nIndex = 0;
-        do
-        {
-            aUnusedName.Assign( pStyle->GetName() ).Append( ' ' ).Append( String::CreateFromInt32( ++nIndex ) );
-        }
-        while( aCellStyles.count( aUnusedName ) > 0 );
-        aCellStyles[ aUnusedName ] = pStyle;
-    }
-
-    // set final names and create user-defined and modified built-in cell styles
-    for( CellStyleNameMap::iterator aIt = aCellStyles.begin(), aEnd = aCellStyles.end(); aIt != aEnd; ++aIt )
-        if( aIt->second )
-            aIt->second->CreateUserStyle( aIt->first );
-}
-
-ScStyleSheet* XclImpXFBuffer::CreateStyleSheet( sal_uInt16 nXFIndex )
-{
-    XclImpStyleMap::iterator aIt = maStylesByXf.find( nXFIndex );
-    return (aIt == maStylesByXf.end()) ? 0 : aIt->second->CreateStyleSheet();
-}
-
-void XclImpXFBuffer::ApplyPattern(
-        SCCOL nScCol1, SCROW nScRow1, SCCOL nScCol2, SCROW nScRow2,
-        SCTAB nScTab, const XclImpXFIndex& rXFIndex )
-{
-    if( XclImpXF* pXF = GetXF( rXFIndex.GetXFIndex() ) )
-    {
-        // #108770# set 'Standard' number format for all Boolean cells
-        ULONG nForceScNumFmt = rXFIndex.IsBoolCell() ? GetNumFmtBuffer().GetStdScNumFmt() : NUMBERFORMAT_ENTRY_NOT_FOUND;
-        pXF->ApplyPattern( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, nForceScNumFmt );
-    }
-}
-
-// Buffer for XF indexes in cells =============================================
-
-IMPL_FIXEDMEMPOOL_NEWDEL( XclImpXFRange, 100, 500 )
-
-bool XclImpXFRange::Expand( SCROW nScRow, const XclImpXFIndex& rXFIndex )
-{
-    if( maXFIndex != rXFIndex )
-        return false;
-
-    if( mnScRow2 + 1 == nScRow )
-    {
-        ++mnScRow2;
-        return true;
-    }
-    if( mnScRow1 > 0 && (mnScRow1 - 1 == nScRow) )
-    {
-        --mnScRow1;
-        return true;
-    }
-
-    return false;
-}
-
-bool XclImpXFRange::Expand( const XclImpXFRange& rNextRange )
-{
-    DBG_ASSERT( mnScRow2 < rNextRange.mnScRow1, "XclImpXFRange::Expand - rows out of order" );
-    if( (maXFIndex == rNextRange.maXFIndex) && (mnScRow2 + 1 == rNextRange.mnScRow1) )
-    {
-        mnScRow2 = rNextRange.mnScRow2;
-        return true;
-    }
-    return false;
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpXFRangeColumn::SetDefaultXF( const XclImpXFIndex& rXFIndex )
-{
-    // List should be empty when inserting the default column format.
-    // Later explicit SetXF() calls will break up this range.
-    DBG_ASSERT( maIndexList.Empty(), "XclImpXFRangeColumn::SetDefaultXF - Setting Default Column XF is not empty" );
-
-    // insert a complete row range with one insert.
-    maIndexList.Append( new XclImpXFRange( 0, MAXROW, rXFIndex ) );
-}
-
-// ----------------------------------------------------------------------------
-
-void XclImpXFRangeColumn::SetXF( SCROW nScRow, const XclImpXFIndex& rXFIndex )
-{
-    XclImpXFRange* pPrevRange;
-    XclImpXFRange* pNextRange;
-    ULONG nNextIndex;
-
-    Find( pPrevRange, pNextRange, nNextIndex, nScRow );
-
-    // previous range:
-    // try to overwrite XF (if row is contained in) or try to expand range
-    if( pPrevRange )
-    {
-        if( pPrevRange->Contains( nScRow ) )        // overwrite old XF
-        {
-            if( rXFIndex == pPrevRange->maXFIndex )
-                return;
-
-            SCROW nFirstScRow = pPrevRange->mnScRow1;
-            SCROW nLastScRow = pPrevRange->mnScRow2;
-            ULONG nIndex = nNextIndex - 1;
-            XclImpXFRange* pThisRange = pPrevRange;
-            pPrevRange = nIndex ? maIndexList.GetObject( nIndex - 1 ) : 0;
-
-            if( nFirstScRow == nLastScRow )         // replace solely XF
-            {
-                pThisRange->maXFIndex = rXFIndex;
-                TryConcatPrev( nNextIndex );        // try to concat. next with this
-                TryConcatPrev( nIndex );            // try to concat. this with previous
-            }
-            else if( nFirstScRow == nScRow )        // replace first XF
-            {
-                ++(pThisRange->mnScRow1);
-                // try to concatenate with previous of this
-                if( !pPrevRange || !pPrevRange->Expand( nScRow, rXFIndex ) )
-                    maIndexList.Insert( new XclImpXFRange( nScRow, rXFIndex ), nIndex );
-            }
-            else if( nLastScRow == nScRow )         // replace last XF
-            {
-                --(pThisRange->mnScRow2);
-                if( !pNextRange || !pNextRange->Expand( nScRow, rXFIndex ) )
-                    maIndexList.Insert( new XclImpXFRange( nScRow, rXFIndex ), nNextIndex );
-            }
-            else                                    // insert in the middle of the range
-            {
-                pThisRange->mnScRow1 = nScRow + 1;
-                // List::Insert() moves entries towards end of list, so insert twice at nIndex
-                maIndexList.Insert( new XclImpXFRange( nScRow, rXFIndex ), nIndex );
-                maIndexList.Insert( new XclImpXFRange( nFirstScRow, nScRow - 1, pThisRange->maXFIndex ), nIndex );
-            }
-            return;
-        }
-        else if( pPrevRange->Expand( nScRow, rXFIndex ) )    // try to expand
-        {
-            TryConcatPrev( nNextIndex );    // try to concatenate next with expanded
-            return;
-        }
-    }
-
-    // try to expand next range
-    if( pNextRange && pNextRange->Expand( nScRow, rXFIndex ) )
-        return;
-
-    // create new range
-    maIndexList.Insert( new XclImpXFRange( nScRow, rXFIndex ), nNextIndex );
-}
-
-void XclImpXFRangeColumn::Find(
-        XclImpXFRange*& rpPrevRange, XclImpXFRange*& rpNextRange,
-        ULONG& rnNextIndex, SCROW nScRow ) const
-{
-
-    // test whether list is empty
-    if( maIndexList.Empty() )
-    {
-        rpPrevRange = rpNextRange = 0;
-        rnNextIndex = 0;
-        return;
-    }
-
-    rpPrevRange = maIndexList.GetObject( 0 );
-    rpNextRange = maIndexList.GetObject( maIndexList.Count() - 1 );
-
-    // test whether row is at end of list (contained in or behind last range)
-    // rpPrevRange will contain a possible existing row
-    if( rpNextRange->mnScRow1 <= nScRow )
-    {
-        rpPrevRange = rpNextRange;
-        rpNextRange = 0;
-        rnNextIndex = maIndexList.Count();
-        return;
-    }
-
-    // test whether row is at beginning of list (really before first range)
-    if( nScRow < rpPrevRange->mnScRow1 )
-    {
-        rpNextRange = rpPrevRange;
-        rpPrevRange = 0;
-        rnNextIndex = 0;
-        return;
-    }
-
-    // loop: find range entries before and after new row
-    // break the loop if there is no more range between first and last -or-
-    // if rpPrevRange contains nScRow (rpNextRange will never contain nScRow)
-    ULONG nPrevIndex = 0;
-    ULONG nMidIndex;
-    rnNextIndex = maIndexList.Count() - 1;
-    XclImpXFRange* pMidRange;
-    while( ((rnNextIndex - nPrevIndex) > 1) && (rpPrevRange->mnScRow2 < nScRow) )
-    {
-        nMidIndex = (nPrevIndex + rnNextIndex) / 2;
-        pMidRange = maIndexList.GetObject( nMidIndex );
-        DBG_ASSERT( pMidRange, "XclImpXFRangeColumn::Find - missing XF index range" );
-        if( nScRow < pMidRange->mnScRow1 )      // row is really before pMidRange
-        {
-            rpNextRange = pMidRange;
-            rnNextIndex = nMidIndex;
-        }
-        else                                    // row is in or after pMidRange
-        {
-            rpPrevRange = pMidRange;
-            nPrevIndex = nMidIndex;
-        }
-    }
-
-    // find next rpNextRange if rpPrevRange contains nScRow
-    if( nScRow <= rpPrevRange->mnScRow2 )
-    {
-        rnNextIndex = nPrevIndex + 1;
-        rpNextRange = maIndexList.GetObject( rnNextIndex );
-    }
-}
-
-void XclImpXFRangeColumn::TryConcatPrev( ULONG nIndex )
-{
-    if( !nIndex )
-        return;
-
-    XclImpXFRange* pPrevRange = maIndexList.GetObject( nIndex - 1 );
-    XclImpXFRange* pNextRange = maIndexList.GetObject( nIndex );
-    if( !pPrevRange || !pNextRange )
-        return;
-
-    if( pPrevRange->Expand( *pNextRange ) )
-        maIndexList.Delete( nIndex );
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpXFRangeBuffer::XclImpXFRangeBuffer( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-XclImpXFRangeBuffer::~XclImpXFRangeBuffer()
-{
-}
-
-void XclImpXFRangeBuffer::Initialize()
-{
-    maColumns.clear();
-    maHyperlinks.clear();
-    maMergeList.RemoveAll();
-}
-
-void XclImpXFRangeBuffer::SetXF( const ScAddress& rScPos, sal_uInt16 nXFIndex, XclImpXFInsertMode eMode )
-{
-    SCCOL nScCol = rScPos.Col();
-    SCROW nScRow = rScPos.Row();
-
-    // set cell XF's
-    size_t nIndex = static_cast< size_t >( nScCol );
-    if( maColumns.size() <= nIndex )
-        maColumns.resize( nIndex + 1 );
-    if( !maColumns[ nIndex ] )
-        maColumns[ nIndex ].reset( new XclImpXFRangeColumn );
-    // #108770# remember all Boolean cells, they will get 'Standard' number format
-    maColumns[ nIndex ]->SetXF( nScRow, XclImpXFIndex( nXFIndex, eMode == xlXFModeBoolCell ) );
-
-    // set "center across selection" and "fill" attribute for all following empty cells
-    // #97130# ignore it on row default XFs
-    if( eMode != xlXFModeRow )
-    {
-        const XclImpXF* pXF = GetXFBuffer().GetXF( nXFIndex );
-        if( pXF && ((pXF->GetHorAlign() == EXC_XF_HOR_CENTER_AS) || (pXF->GetHorAlign() == EXC_XF_HOR_FILL)) )
-        {
-            // expand last merged range if this attribute is set repeatedly
-            ScRange* pRange = maMergeList.Last();
-            if( pRange && (pRange->aEnd.Row() == nScRow) && (pRange->aEnd.Col() + 1 == nScCol)
-                    && (eMode == xlXFModeBlank) )
-                pRange->aEnd.IncCol();
-            else if( eMode != xlXFModeBlank )   // #108781# do not merge empty cells
-                SetMerge( nScCol, nScRow );
-        }
-    }
-}
-
-void XclImpXFRangeBuffer::SetXF( const ScAddress& rScPos, sal_uInt16 nXFIndex )
-{
-    SetXF( rScPos, nXFIndex, xlXFModeCell );
-}
-
-void XclImpXFRangeBuffer::SetBlankXF( const ScAddress& rScPos, sal_uInt16 nXFIndex )
-{
-    SetXF( rScPos, nXFIndex, xlXFModeBlank );
-}
-
-void XclImpXFRangeBuffer::SetBoolXF( const ScAddress& rScPos, sal_uInt16 nXFIndex )
-{
-    SetXF( rScPos, nXFIndex, xlXFModeBoolCell );
-}
-
-void XclImpXFRangeBuffer::SetRowDefXF( SCROW nScRow, sal_uInt16 nXFIndex )
-{
-    for( SCCOL nScCol = 0; nScCol <= MAXCOL; ++nScCol )
-        SetXF( ScAddress( nScCol, nScRow, 0 ), nXFIndex, xlXFModeRow );
-}
-
-void XclImpXFRangeBuffer::SetColumnDefXF( SCCOL nScCol, sal_uInt16 nXFIndex )
-{
-    // our array should not have values when creating the default column format.
-    size_t nIndex = static_cast< size_t >( nScCol );
-    if( maColumns.size() <= nIndex )
-        maColumns.resize( nIndex + 1 );
-    DBG_ASSERT( !maColumns[ nIndex ], "XclImpXFRangeBuffer::SetColumnDefXF - default column of XFs already has values" );
-    maColumns[ nIndex ].reset( new XclImpXFRangeColumn );
-    maColumns[ nIndex ]->SetDefaultXF( XclImpXFIndex( nXFIndex ) );
-}
-
-void XclImpXFRangeBuffer::SetBorderLine( const ScRange& rRange, SCTAB nScTab, USHORT nLine )
-{
-    SCCOL nFromScCol = (nLine == BOX_LINE_RIGHT) ? rRange.aEnd.Col() : rRange.aStart.Col();
-    SCROW nFromScRow = (nLine == BOX_LINE_BOTTOM) ? rRange.aEnd.Row() : rRange.aStart.Row();
-    ScDocument& rDoc = GetDoc();
-
-    const SvxBoxItem* pFromItem = static_cast< const SvxBoxItem* >(
-        rDoc.GetAttr( nFromScCol, nFromScRow, nScTab, ATTR_BORDER ) );
-    const SvxBoxItem* pToItem = static_cast< const SvxBoxItem* >(
-        rDoc.GetAttr( rRange.aStart.Col(), rRange.aStart.Row(), nScTab, ATTR_BORDER ) );
-
-    SvxBoxItem aNewItem( *pToItem );
-    aNewItem.SetLine( pFromItem->GetLine( nLine ), nLine );
-    rDoc.ApplyAttr( rRange.aStart.Col(), rRange.aStart.Row(), nScTab, aNewItem );
-}
-
-void XclImpXFRangeBuffer::SetHyperlink( const XclRange& rXclRange, const String& rUrl )
-{
-    maHyperlinks.push_back( XclImpHyperlinkRange( rXclRange, rUrl ) );
-}
-
-void XclImpXFRangeBuffer::SetMerge( SCCOL nScCol, SCROW nScRow )
-{
-    maMergeList.Append( ScRange( nScCol, nScRow, 0 ) );
-}
-
-void XclImpXFRangeBuffer::SetMerge( SCCOL nScCol1, SCROW nScRow1, SCCOL nScCol2, SCROW nScRow2 )
-{
-    if( (nScCol1 < nScCol2) || (nScRow1 < nScRow2) )
-        maMergeList.Append( ScRange( nScCol1, nScRow1, 0, nScCol2, nScRow2, 0 ) );
-}
-
-void XclImpXFRangeBuffer::Finalize()
-{
-    ScDocument& rDoc = GetDoc();
-    SCTAB nScTab = GetCurrScTab();
-
-    // apply patterns
-    XclImpXFBuffer& rXFBuffer = GetXFBuffer();
-    for( XclImpXFRangeColumnVec::const_iterator aVBeg = maColumns.begin(), aVEnd = maColumns.end(), aVIt = aVBeg; aVIt != aVEnd; ++aVIt )
-    {
-        // apply all cell styles of an existing column
-        if( aVIt->is() )
-        {
-            XclImpXFRangeColumn& rColumn = **aVIt;
-            SCCOL nScCol = static_cast< SCCOL >( aVIt - aVBeg );
-            for( XclImpXFRange* pStyle = rColumn.First(); pStyle; pStyle = rColumn.Next() )
-                rXFBuffer.ApplyPattern( nScCol, pStyle->mnScRow1, nScCol, pStyle->mnScRow2, nScTab, pStyle->maXFIndex );
-        }
-    }
-
-    // insert hyperlink cells
-    for( XclImpHyperlinkList::const_iterator aLIt = maHyperlinks.begin(), aLEnd = maHyperlinks.end(); aLIt != aLEnd; ++aLIt )
-        XclImpHyperlink::InsertUrl( GetRoot(), aLIt->first, aLIt->second );
-
-    // apply cell merging
-    for( const ScRange* pRange = maMergeList.First(); pRange; pRange = maMergeList.Next() )
-    {
-        const ScAddress& rStart = pRange->aStart;
-        const ScAddress& rEnd = pRange->aEnd;
-        bool bMultiCol = rStart.Col() != rEnd.Col();
-        bool bMultiRow = rStart.Row() != rEnd.Row();
-        // set correct right border
-        if( bMultiCol )
-            SetBorderLine( *pRange, nScTab, BOX_LINE_RIGHT );
-        // set correct lower border
-        if( bMultiRow )
-            SetBorderLine( *pRange, nScTab, BOX_LINE_BOTTOM );
-        // do merge
-        if( bMultiCol || bMultiRow )
-            rDoc.DoMerge( nScTab, rStart.Col(), rStart.Row(), rEnd.Col(), rEnd.Row() );
-        // #i93609# merged range in a single row: test if manual row height is needed
-        if( !bMultiRow )
-        {
-            bool bTextWrap = static_cast< const SfxBoolItem* >( rDoc.GetAttr( rStart.Col(), rStart.Row(), rStart.Tab(), ATTR_LINEBREAK ) )->GetValue();
-            if( !bTextWrap && (rDoc.GetCellType( rStart ) == CELLTYPE_EDIT) )
-                if( const EditTextObject* pEditObj = static_cast< const ScEditCell* >( rDoc.GetCell( rStart ) )->GetData() )
-                    bTextWrap = pEditObj->GetParagraphCount() > 1;
-            if( bTextWrap )
-                GetOldRoot().pColRowBuff->SetManualRowHeight( rStart.Row() );
-        }
-    }
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xiview.cxx sc/source/filter/xlsx/xlsx-xiview.cxx
deleted file mode 100644
index ce76483..0000000
--- sc/source/filter/xlsx/xlsx-xiview.cxx
+++ /dev/null
@@ -1,309 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: xiview.cxx,v $
- * $Revision: 1.9.90.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_sc.hxx"
-#include "xiview.hxx"
-#include "document.hxx"
-#include "scextopt.hxx"
-#include "viewopti.hxx"
-#include "xistream.hxx"
-#include "xihelper.hxx"
-#include "xistyle.hxx"
-
-// Document view settings =====================================================
-
-XclImpDocViewSettings::XclImpDocViewSettings( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpDocViewSettings::ReadWindow1( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnWinX
-            >> maData.mnWinY
-            >> maData.mnWinWidth
-            >> maData.mnWinHeight
-            >> maData.mnFlags;
-    if( GetBiff() >= EXC_BIFF5 )
-    {
-        rStrm   >> maData.mnDisplXclTab
-                >> maData.mnFirstVisXclTab
-                >> maData.mnXclSelectCnt
-                >> maData.mnTabBarWidth;
-    }
-}
-
-SCTAB XclImpDocViewSettings::GetDisplScTab() const
-{
-    /*  Simply cast Excel index to Calc index.
-        TODO: This may fail if the document contains scenarios. */
-    sal_uInt16 nMaxXclTab = static_cast< sal_uInt16 >( GetMaxPos().Tab() );
-    return static_cast< SCTAB >( (maData.mnDisplXclTab <= nMaxXclTab) ? maData.mnDisplXclTab : 0 );
-}
-
-void XclImpDocViewSettings::Finalize()
-{
-    ScViewOptions aViewOpt( GetDoc().GetViewOptions() );
-    aViewOpt.SetOption( VOPT_HSCROLL,       ::get_flag( maData.mnFlags, EXC_WIN1_HOR_SCROLLBAR ) );
-    aViewOpt.SetOption( VOPT_VSCROLL,       ::get_flag( maData.mnFlags, EXC_WIN1_VER_SCROLLBAR ) );
-    aViewOpt.SetOption( VOPT_TABCONTROLS,   ::get_flag( maData.mnFlags, EXC_WIN1_TABBAR ) );
-    GetDoc().SetViewOptions( aViewOpt );
-
-    // displayed sheet
-    GetExtDocOptions().GetDocSettings().mnDisplTab = GetDisplScTab();
-
-    // width of the tabbar with sheet names
-    if( maData.mnTabBarWidth <= 1000 )
-        GetExtDocOptions().GetDocSettings().mfTabBarWidth = static_cast< double >( maData.mnTabBarWidth ) / 1000.0;
-}
-
-// Sheet view settings ========================================================
-
-namespace {
-
-long lclGetScZoom( sal_uInt16 nXclZoom, sal_uInt16 nDefZoom )
-{
-    return static_cast< long >( nXclZoom ? nXclZoom : nDefZoom );
-}
-
-} // namespace
-
-// ----------------------------------------------------------------------------
-
-XclImpTabViewSettings::XclImpTabViewSettings( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-    Initialize();
-}
-
-void XclImpTabViewSettings::Initialize()
-{
-    maData.SetDefaults();
-}
-
-void XclImpTabViewSettings::ReadTabBgColor( XclImpStream& rStrm, XclImpPalette& rPal )
-{
-    DBG_ASSERT_BIFF( GetBiff() >= EXC_BIFF8 );
-    if( GetBiff() < EXC_BIFF8 )
-        return;
-
-    sal_uInt8 ColorIndex;
-    Color TabBgColor;
-
-    rStrm.Ignore( 16 );
-    ColorIndex = rStrm.ReaduInt8() & EXC_SHEETEXT_TABCOLOR; //0x7F
-    if ( ColorIndex >= 8 && ColorIndex <= 63 ) //only accept valid index values
-    {
-        TabBgColor = rPal.GetColor( ColorIndex );
-        maData.maTabBgColor = TabBgColor;
-    }
-}
-
-void XclImpTabViewSettings::ReadWindow2( XclImpStream& rStrm, bool bChart )
-{
-    if( GetBiff() == EXC_BIFF2 )
-    {
-        maData.mbShowFormulas   = rStrm.ReaduInt8() != 0;
-        maData.mbShowGrid       = rStrm.ReaduInt8() != 0;
-        maData.mbShowHeadings   = rStrm.ReaduInt8() != 0;
-        maData.mbFrozenPanes    = rStrm.ReaduInt8() != 0;
-        maData.mbShowZeros      = rStrm.ReaduInt8() != 0;
-        rStrm >> maData.maFirstXclPos;
-        maData.mbDefGridColor   = rStrm.ReaduInt8() != 0;
-        rStrm >> maData.maGridColor;
-    }
-    else
-    {
-        sal_uInt16 nFlags;
-        rStrm >> nFlags >> maData.maFirstXclPos;
-
-        // #i59590# #158194# real life: Excel ignores some view settings in chart sheets
-        maData.mbSelected       = ::get_flag( nFlags, EXC_WIN2_SELECTED );
-        maData.mbDisplayed      = ::get_flag( nFlags, EXC_WIN2_DISPLAYED );
-        maData.mbMirrored       = !bChart && ::get_flag( nFlags, EXC_WIN2_MIRRORED );
-        maData.mbFrozenPanes    = !bChart && ::get_flag( nFlags, EXC_WIN2_FROZEN );
-        maData.mbPageMode       = !bChart && ::get_flag( nFlags, EXC_WIN2_PAGEBREAKMODE );
-        maData.mbDefGridColor   = bChart || ::get_flag( nFlags, EXC_WIN2_DEFGRIDCOLOR );
-        maData.mbShowFormulas   = !bChart && ::get_flag( nFlags, EXC_WIN2_SHOWFORMULAS );
-        maData.mbShowGrid       = bChart || ::get_flag( nFlags, EXC_WIN2_SHOWGRID );
-        maData.mbShowHeadings   = bChart || ::get_flag( nFlags, EXC_WIN2_SHOWHEADINGS );
-        maData.mbShowZeros      = bChart || ::get_flag( nFlags, EXC_WIN2_SHOWZEROS );
-        maData.mbShowOutline    = bChart || ::get_flag( nFlags, EXC_WIN2_SHOWOUTLINE );
-
-        switch( GetBiff() )
-        {
-            case EXC_BIFF3:
-            case EXC_BIFF4:
-            case EXC_BIFF5:
-                rStrm >> maData.maGridColor;
-            break;
-            case EXC_BIFF8:
-            {
-                sal_uInt16 nGridColorIdx;
-                rStrm >> nGridColorIdx;
-                // zoom data not included in chart sheets
-                if( rStrm.GetRecLeft() >= 6 )
-                {
-                    rStrm.Ignore( 2 );
-                    rStrm >> maData.mnPageZoom >> maData.mnNormalZoom;
-                }
-
-                if( !maData.mbDefGridColor )
-                    maData.maGridColor = GetPalette().GetColor( nGridColorIdx );
-            }
-            break;
-            default:    DBG_ERROR_BIFF();
-        }
-    }
-
-    // do not scroll chart sheets
-    if( bChart )
-        maData.maFirstXclPos.Set( 0, 0 );
-}
-
-void XclImpTabViewSettings::ReadScl( XclImpStream& rStrm )
-{
-    sal_uInt16 nNum, nDenom;
-    rStrm >> nNum >> nDenom;
-    DBG_ASSERT( nDenom > 0, "XclImpPageSettings::ReadScl - invalid denominator" );
-    if( nDenom > 0 )
-        maData.mnCurrentZoom = limit_cast< sal_uInt16 >( (nNum * 100) / nDenom );
-}
-
-void XclImpTabViewSettings::ReadPane( XclImpStream& rStrm )
-{
-    rStrm   >> maData.mnSplitX
-            >> maData.mnSplitY
-            >> maData.maSecondXclPos
-            >> maData.mnActivePane;
-}
-
-void XclImpTabViewSettings::ReadSelection( XclImpStream& rStrm )
-{
-    // pane of this selection
-    sal_uInt8 nPane;
-    rStrm >> nPane;
-    XclSelectionData& rSelData = maData.CreateSelectionData( nPane );
-    // cursor position and selection
-    rStrm >> rSelData.maXclCursor >> rSelData.mnCursorIdx;
-    rSelData.maXclSelection.Read( rStrm, false );
-}
-
-void XclImpTabViewSettings::Finalize()
-{
-    SCTAB nScTab = GetCurrScTab();
-    ScDocument& rDoc = GetDoc();
-    XclImpAddressConverter& rAddrConv = GetAddressConverter();
-    ScExtTabSettings& rTabSett = GetExtDocOptions().GetOrCreateTabSettings( nScTab );
-    bool bDisplayed = GetDocViewSettings().GetDisplScTab() == nScTab;
-
-    // *** sheet options: cursor, selection, splits, zoom ***
-
-    // sheet flags
-    if( maData.mbMirrored )
-        // do not call this function with FALSE, it would mirror away all drawing objects
-        rDoc.SetLayoutRTL( nScTab, TRUE );
-    rTabSett.mbSelected = maData.mbSelected || bDisplayed;
-
-    // first visible cell in top-left pane and in additional pane(s)
-    rTabSett.maFirstVis = rAddrConv.CreateValidAddress( maData.maFirstXclPos, nScTab, false );
-    rTabSett.maSecondVis = rAddrConv.CreateValidAddress( maData.maSecondXclPos, nScTab, false );
-
-    // cursor position and selection
-    if( const XclSelectionData* pSelData = maData.GetSelectionData( maData.mnActivePane ) )
-    {
-        rTabSett.maCursor = rAddrConv.CreateValidAddress( pSelData->maXclCursor, nScTab, false );
-        rAddrConv.ConvertRangeList( rTabSett.maSelection, pSelData->maXclSelection, nScTab, false );
-    }
-
-    // active pane
-    switch( maData.mnActivePane )
-    {
-        case EXC_PANE_TOPLEFT:      rTabSett.meActivePane = SCEXT_PANE_TOPLEFT;     break;
-        case EXC_PANE_TOPRIGHT:     rTabSett.meActivePane = SCEXT_PANE_TOPRIGHT;    break;
-        case EXC_PANE_BOTTOMLEFT:   rTabSett.meActivePane = SCEXT_PANE_BOTTOMLEFT;  break;
-        case EXC_PANE_BOTTOMRIGHT:  rTabSett.meActivePane = SCEXT_PANE_BOTTOMRIGHT; break;
-    }
-
-    // freeze/split position
-    rTabSett.mbFrozenPanes = maData.mbFrozenPanes;
-    if( maData.mbFrozenPanes )
-    {
-        /*  Frozen panes: handle split position as row/column positions.
-            #i35812# Excel uses number of visible rows/columns, Calc uses position of freeze. */
-        if( (maData.mnSplitX > 0) && (maData.maFirstXclPos.mnCol + maData.mnSplitX <= GetScMaxPos().Col()) )
-            rTabSett.maFreezePos.SetCol( static_cast< SCCOL >( maData.maFirstXclPos.mnCol + maData.mnSplitX ) );
-        if( (maData.mnSplitY > 0) && (maData.maFirstXclPos.mnRow + maData.mnSplitY <= GetScMaxPos().Row()) )
-            rTabSett.maFreezePos.SetRow( static_cast< SCROW >( maData.maFirstXclPos.mnRow + maData.mnSplitY ) );
-    }
-    else
-    {
-        // split window: position is in twips
-        rTabSett.maSplitPos.X() = static_cast< long >( maData.mnSplitX );
-        rTabSett.maSplitPos.Y() = static_cast< long >( maData.mnSplitY );
-    }
-
-    // grid color
-    if( maData.mbDefGridColor )
-        rTabSett.maGridColor.SetColor( COL_AUTO );
-    else
-        rTabSett.maGridColor = maData.maGridColor;
-
-    // show grid option
-    rTabSett.mbShowGrid      = maData.mbShowGrid;
-
-    // view mode and zoom
-    if( maData.mnCurrentZoom != 0 )
-        (maData.mbPageMode ? maData.mnPageZoom : maData.mnNormalZoom) = maData.mnCurrentZoom;
-    rTabSett.mbPageMode      = maData.mbPageMode;
-    rTabSett.mnNormalZoom    = lclGetScZoom( maData.mnNormalZoom, EXC_WIN2_NORMALZOOM_DEF );
-    rTabSett.mnPageZoom      = lclGetScZoom( maData.mnPageZoom, EXC_WIN2_PAGEZOOM_DEF );
-
-    // *** additional handling for displayed sheet ***
-
-    if( bDisplayed )
-    {
-        // set Excel sheet settings globally at Calc document, take settings from displayed sheet
-        ScViewOptions aViewOpt( rDoc.GetViewOptions() );
-        aViewOpt.SetOption( VOPT_FORMULAS, maData.mbShowFormulas );
-        aViewOpt.SetOption( VOPT_HEADER,   maData.mbShowHeadings );
-        aViewOpt.SetOption( VOPT_NULLVALS, maData.mbShowZeros );
-        aViewOpt.SetOption( VOPT_OUTLINER, maData.mbShowOutline );
-        rDoc.SetViewOptions( aViewOpt );
-    }
-
-    // *** set tab bg color
-    if ( !maData.IsDefaultTabBgColor() )
-        rTabSett.maTabBgColor = maData.maTabBgColor;
-}
-
-// ============================================================================
-
diff --git sc/source/filter/xlsx/xlsx-xladdress.cxx sc/source/filter/xlsx/xlsx-xladdress.cxx
index 290a7dc..ed5e051 100644
--- sc/source/filter/xlsx/xlsx-xladdress.cxx
+++ sc/source/filter/xlsx/xlsx-xladdress.cxx
@@ -37,53 +37,12 @@
 
 // ============================================================================
 
-void XclAddress::Read( XclImpStream& rStrm, bool bCol16Bit )
-{
-    rStrm >> mnRow;
-    if( bCol16Bit )
-        rStrm >> mnCol;
-    else
-        mnCol = rStrm.ReaduInt8();
-}
-
-void XclAddress::Write( XclExpStream& rStrm, bool bCol16Bit ) const
-{
-    rStrm << mnRow;
-    if( bCol16Bit )
-        rStrm << mnCol;
-    else
-        rStrm << static_cast< sal_uInt8 >( mnCol );
-}
-
-// ----------------------------------------------------------------------------
-
 bool XclRange::Contains( const XclAddress& rPos ) const
 {
     return  (maFirst.mnCol <= rPos.mnCol) && (rPos.mnCol <= maLast.mnCol) &&
             (maFirst.mnRow <= rPos.mnRow) && (rPos.mnRow <= maLast.mnRow);
 }
 
-void XclRange::Read( XclImpStream& rStrm, bool bCol16Bit )
-{
-    rStrm >> maFirst.mnRow >> maLast.mnRow;
-    if( bCol16Bit )
-        rStrm >> maFirst.mnCol >> maLast.mnCol;
-    else
-    {
-        maFirst.mnCol = rStrm.ReaduInt8();
-        maLast.mnCol = rStrm.ReaduInt8();
-    }
-}
-
-void XclRange::Write( XclExpStream& rStrm, bool bCol16Bit ) const
-{
-    rStrm << maFirst.mnRow << maLast.mnRow;
-    if( bCol16Bit )
-        rStrm << maFirst.mnCol << maLast.mnCol;
-    else
-        rStrm << static_cast< sal_uInt8 >( maFirst.mnCol ) << static_cast< sal_uInt8 >( maLast.mnCol );
-}
-
 // ----------------------------------------------------------------------------
 
 XclRange XclRangeList::GetEnclosingRange() const
@@ -104,32 +63,6 @@ XclRange XclRangeList::GetEnclosingRange() const
     return aXclRange;
 }
 
-void XclRangeList::Read( XclImpStream& rStrm, bool bCol16Bit )
-{
-    sal_uInt16 nCount;
-    rStrm >> nCount;
-    size_t nOldSize = size();
-    resize( nOldSize + nCount );
-    for( iterator aIt = begin() + nOldSize; rStrm.IsValid() && (nCount > 0); --nCount, ++aIt )
-        aIt->Read( rStrm, bCol16Bit );
-}
-
-void XclRangeList::Write( XclExpStream& rStrm, bool bCol16Bit ) const
-{
-    WriteSubList( rStrm, 0, size(), bCol16Bit );
-}
-
-void XclRangeList::WriteSubList( XclExpStream& rStrm, size_t nBegin, size_t nCount, bool bCol16Bit ) const
-{
-    DBG_ASSERT( nBegin <= size(), "XclRangeList::WriteSubList - invalid start position" );
-    size_t nEnd = ::std::min< size_t >( nBegin + nCount, size() );
-    sal_uInt16 nXclCount = ulimit_cast< sal_uInt16 >( nEnd - nBegin );
-    rStrm << nXclCount;
-    rStrm.SetSliceSize( bCol16Bit ? 8 : 6 );
-    for( const_iterator aIt = begin() + nBegin, aEnd = begin() + nEnd; aIt != aEnd; ++aIt )
-        aIt->Write( rStrm, bCol16Bit );
-}
-
 // ============================================================================
 
 XclAddressConverterBase::XclAddressConverterBase( XclTracer& rTracer, const ScAddress& rMaxPos ) :
@@ -142,7 +75,7 @@ XclAddressConverterBase::XclAddressConverterBase( XclTracer& rTracer, const ScAd
     mbTabTrunc( false )
 {
     DBG_ASSERT( static_cast< size_t >( rMaxPos.Col() ) <= SAL_MAX_UINT16, "XclAddressConverterBase::XclAddressConverterBase - invalid max column" );
-    DBG_ASSERT( static_cast< size_t >( rMaxPos.Row() ) <= SAL_MAX_UINT16, "XclAddressConverterBase::XclAddressConverterBase - invalid max row" );
+    DBG_ASSERT( static_cast< size_t >( rMaxPos.Row() ) <= SAL_MAX_UINT32, "XclAddressConverterBase::XclAddressConverterBase - invalid max row" );
 }
 
 XclAddressConverterBase::~XclAddressConverterBase()
diff --git sc/source/filter/xlsx/xlsx-xlescher.cxx sc/source/filter/xlsx/xlsx-xlescher.cxx
index 066eb57..9f5fc9b 100644
--- sc/source/filter/xlsx/xlsx-xlescher.cxx
+++ sc/source/filter/xlsx/xlsx-xlescher.cxx
@@ -138,7 +138,7 @@ void lclGetColFromX(
 /** Calculates an object row position from a drawing layer Y position (in twips). */
 void lclGetRowFromY(
         ScDocument& rDoc, SCTAB nScTab,
-        sal_uInt16& rnXclRow, sal_uInt16& rnOffset, sal_uInt16 nXclStartRow,
+        sal_uInt32& rnXclRow, sal_uInt16& rnOffset, sal_uInt16 nXclStartRow,
         long& rnStartH, long nY, double fScale )
 {
     // rnStartH in conjunction with nXclStartRow is used as buffer for previously calculated height
@@ -223,6 +223,7 @@ XclObjLineData::XclObjLineData() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclObjLineData& rLineData )
 {
     return rStrm
@@ -231,6 +232,7 @@ XclImpStream& operator>>( XclImpStream& rStrm, XclObjLineData& rLineData )
         >> rLineData.mnWidth
         >> rLineData.mnAuto;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
@@ -242,6 +244,7 @@ XclObjFillData::XclObjFillData() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclObjFillData& rFillData )
 {
     return rStrm
@@ -250,6 +253,7 @@ XclImpStream& operator>>( XclImpStream& rStrm, XclObjFillData& rFillData )
         >> rFillData.mnPattern
         >> rFillData.mnAuto;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
@@ -266,6 +270,7 @@ XclObjTextData::XclObjTextData() :
 {
 }
 
+#if 0 // xlsx
 void XclObjTextData::ReadObj3( XclImpStream& rStrm )
 {
     rStrm >> mnTextLen;
@@ -293,6 +298,7 @@ void XclObjTextData::ReadTxo8( XclImpStream& rStrm )
 {
     rStrm >> mnFlags >> mnOrient >> mnButtonFlags >> mnShortcut >> mnShortcutEA >> mnTextLen >> mnFormatSize;
 }
+#endif // xlsx
 
 // ============================================================================
 
diff --git sc/source/filter/xlsx/xlsx-xlformula.cxx sc/source/filter/xlsx/xlsx-xlformula.cxx
index b8c18eb..91cb2de 100644
--- sc/source/filter/xlsx/xlsx-xlformula.cxx
+++ sc/source/filter/xlsx/xlsx-xlformula.cxx
@@ -470,6 +470,7 @@ sal_uInt16 XclTokenArray::GetSize() const
     return limit_cast< sal_uInt16 >( maTokVec.size() );
 }
 
+#if 0 // xlsx
 void XclTokenArray::ReadSize( XclImpStream& rStrm )
 {
     sal_uInt16 nSize;
@@ -507,12 +508,14 @@ void XclTokenArray::Write( XclExpStream& rStrm ) const
     WriteSize( rStrm );
     WriteArray( rStrm );
 }
+#endif // xlsx
 
 bool XclTokenArray::operator==( const XclTokenArray& rTokArr ) const
 {
     return (mbVolatile == rTokArr.mbVolatile) && (maTokVec == rTokArr.maTokVec) && (maExtDataVec == rTokArr.maExtDataVec);
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclTokenArray& rTokArr )
 {
     rTokArr.Read( rStrm );
@@ -541,6 +544,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclTokenArrayRef& rxTokArr
         rStrm << sal_uInt16( 0 );
     return rStrm;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
diff --git sc/source/filter/xlsx/xlsx-xlpivot.cxx sc/source/filter/xlsx/xlsx-xlpivot.cxx
index c915903..3704f40 100644
--- sc/source/filter/xlsx/xlsx-xlpivot.cxx
+++ sc/source/filter/xlsx/xlsx-xlpivot.cxx
@@ -178,6 +178,7 @@ XclPCFieldInfo::XclPCFieldInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPCFieldInfo& rInfo )
 {
     rStrm   >> rInfo.mnFlags
@@ -206,6 +207,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCFieldInfo& rInfo )
         << rInfo.mnOrigItems
         << XclExpString( rInfo.maName );
 }
+#endif // xlsx
 
 // Numeric grouping field settings ============================================
 
@@ -264,6 +266,7 @@ void XclPCNumGroupInfo::SetXclDataType( sal_uInt16 nXclType )
     ::insert_value( mnFlags, nXclType, 2, 4 );
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPCNumGroupInfo& rInfo )
 {
     return rStrm >> rInfo.mnFlags;
@@ -273,6 +276,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCNumGroupInfo& rInfo )
 {
     return rStrm << rInfo.mnFlags;
 }
+#endif // xlsx
 
 // Base class for pivot cache fields ==========================================
 
@@ -370,6 +374,7 @@ XclPCInfo::XclPCInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPCInfo& rInfo )
 {
     rStrm   >> rInfo.mnSrcRecs
@@ -397,6 +402,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCInfo& rInfo )
         << rInfo.mnSrcType
         << XclExpString( rInfo.maUserName );
 }
+#endif // xlsx
 
 // ============================================================================
 // Pivot table
@@ -404,6 +410,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPCInfo& rInfo )
 
 // cached name ================================================================
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTCachedName& rCachedName )
 {
     sal_uInt16 nStrLen;
@@ -424,6 +431,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTCachedName& rCachedNam
         rStrm << XclExpString( rCachedName.maName, EXC_STR_DEFAULT, EXC_PT_MAXSTRLEN );
     return rStrm;
 }
+#endif // xlsx
 
 // ----------------------------------------------------------------------------
 
@@ -447,6 +455,7 @@ XclPTItemInfo::XclPTItemInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTItemInfo& rInfo )
 {
     return rStrm
@@ -464,6 +473,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTItemInfo& rInfo )
         << rInfo.mnCacheIdx
         << rInfo.maVisName;
 }
+#endif // xlsx
 
 // General field settings =====================================================
 
@@ -555,6 +565,7 @@ void XclPTFieldInfo::SetSubtotals( const XclPTSubtotalVec& rSubtotals )
             ++mnSubtCount;
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldInfo& rInfo )
 {
     // rInfo.mnCacheIdx is not part of the SXVD record
@@ -576,6 +587,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldInfo& rInfo )
         << rInfo.mnItemCount
         << rInfo.maVisName;
 }
+#endif // xlsx
 
 // Extended field settings ====================================================
 
@@ -640,6 +652,7 @@ void XclPTFieldExtInfo::SetApiLayoutMode( sal_Int32 nLayoutMode )
     ::set_flag( mnFlags, EXC_SXVDEX_LAYOUT_TOP, nLayoutMode == ScDPLayoutMode::OUTLINE_SUBTOTALS_TOP );
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTFieldExtInfo& rInfo )
 {
     sal_uInt8 nNameLen = 0;
@@ -681,6 +694,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTFieldExtInfo& rInfo )
     }
     return rStrm;
 }
+#endif // xlsx
 
 // Page field settings ========================================================
 
@@ -691,6 +705,7 @@ XclPTPageFieldInfo::XclPTPageFieldInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTPageFieldInfo& rInfo )
 {
     return rStrm
@@ -706,6 +721,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTPageFieldInfo& rInfo )
         << rInfo.mnSelItem
         << rInfo.mnObjId;
 }
+#endif // xlsx
 
 // Data field settings ========================================================
 
@@ -819,6 +835,7 @@ void XclPTDataFieldInfo::SetApiRefItemType( sal_Int32 nRefItemType )
     }
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTDataFieldInfo& rInfo )
 {
     return rStrm
@@ -842,6 +859,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTDataFieldInfo& rInfo )
         << rInfo.mnNumFmt
         << rInfo.maVisName;
 }
+#endif // xlsx
 
 // Pivot table settings =======================================================
 
@@ -862,6 +880,7 @@ XclPTInfo::XclPTInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTInfo& rInfo )
 {
     sal_uInt16 nTabLen, nDataLen;
@@ -908,6 +927,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTInfo& rInfo )
     aXclDataName.WriteBuffer( rStrm );
     return rStrm;
 }
+#endif // xlsx
 
 // Extended pivot table settings ==============================================
 
@@ -920,6 +940,7 @@ XclPTExtInfo::XclPTExtInfo() :
 {
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTExtInfo& rInfo )
 {
     rStrm >> rInfo.mnSxformulaRecs;
@@ -946,6 +967,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTExtInfo& rInfo )
         << EXC_PT_NOSTRING              // length of table style name
         << EXC_PT_NOSTRING;             // length of vacate style name
 }
+#endif // xlsx
 
 // ============================================================================
 
@@ -1010,6 +1032,7 @@ void XclPTViewEx9Info::Init( const ScDPObject& rDPObj )
     }
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclPTViewEx9Info& rInfo )
 {
     rStrm.Ignore( 2 );
@@ -1031,4 +1054,5 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclPTViewEx9Info& rInfo )
         << rInfo.mnGridLayout
         << XclExpString(rInfo.maGrandTotalName, EXC_STR_DEFAULT, EXC_PT_MAXSTRLEN);
 }
+#endif // xlsx
 
diff --git sc/source/filter/xlsx/xlsx-xltools.cxx sc/source/filter/xlsx/xlsx-xltools.cxx
index 6398e25..e4d9ae8 100644
--- sc/source/filter/xlsx/xlsx-xltools.cxx
+++ sc/source/filter/xlsx/xlsx-xltools.cxx
@@ -87,6 +87,7 @@ bool operator<( const XclGuid& rCmp1, const XclGuid& rCmp2 )
         rCmp2.mpnData, STATIC_TABLE_END( rCmp2.mpnData ) );
 }
 
+#if 0 // xlsx
 XclImpStream& operator>>( XclImpStream& rStrm, XclGuid& rGuid )
 {
     rStrm.Read( rGuid.mpnData, 16 );     // mpnData always in little endian
@@ -98,6 +99,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const XclGuid& rGuid )
     rStrm.Write( rGuid.mpnData, 16 );    // mpnData already in little endian
     return rStrm;
 }
+#endif // xlsx
 
 // Excel Tools ================================================================
 
@@ -663,6 +665,7 @@ bool XclTools::IsCondFormatStyleName( const String& rStyleName, xub_StrLen* pnNe
 
 // stream handling ------------------------------------------------------------
 
+#if 0 // xlsx
 void XclTools::SkipSubStream( XclImpStream& rStrm )
 {
     bool bLoop = true;
@@ -689,6 +692,7 @@ XclExpStream& operator<<( XclExpStream& rStrm, const Color& rColor )
 {
     return rStrm << rColor.GetRed() << rColor.GetGreen() << rColor.GetBlue() << sal_uInt8( 0 );
 }
+#endif // xlsx
 
 // ============================================================================
 
diff --git sc/source/filter/xlsx/xlview.hxx sc/source/filter/xlsx/xlview.hxx
new file mode 100644
index 0000000..3070c28
--- /dev/null
+++ sc/source/filter/xlsx/xlview.hxx
@@ -0,0 +1,181 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlview.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLVIEW_HXX
+#define SC_XLVIEW_HXX
+
+#include <map>
+#include <tools/color.hxx>
+#include "ftools.hxx"
+#include "xladdress.hxx"
+
+// Constants and enumerations =================================================
+
+const sal_uInt16 EXC_ZOOM_MIN               = 10;
+const sal_uInt16 EXC_ZOOM_MAX               = 400;
+
+// (0x001D) SELECTION ---------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SELECTION           = 0x001D;
+
+// (0x003D) WINDOW1 -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_WINDOW1             = 0x003D;
+
+const sal_uInt16 EXC_WIN1_HIDDEN            = 0x0001;
+const sal_uInt16 EXC_WIN1_MINIMIZED         = 0x0002;
+const sal_uInt16 EXC_WIN1_HOR_SCROLLBAR     = 0x0008;
+const sal_uInt16 EXC_WIN1_VER_SCROLLBAR     = 0x0010;
+const sal_uInt16 EXC_WIN1_TABBAR            = 0x0020;
+
+// (0x003E, 0x023E) WINDOW2 ---------------------------------------------------
+
+const sal_uInt16 EXC_ID2_WINDOW2            = 0x003E;
+const sal_uInt16 EXC_ID_WINDOW2             = 0x023E;
+
+const sal_uInt16 EXC_WIN2_SHOWFORMULAS      = 0x0001;
+const sal_uInt16 EXC_WIN2_SHOWGRID          = 0x0002;
+const sal_uInt16 EXC_WIN2_SHOWHEADINGS      = 0x0004;
+const sal_uInt16 EXC_WIN2_FROZEN            = 0x0008;
+const sal_uInt16 EXC_WIN2_SHOWZEROS         = 0x0010;
+const sal_uInt16 EXC_WIN2_DEFGRIDCOLOR      = 0x0020;
+const sal_uInt16 EXC_WIN2_MIRRORED          = 0x0040;
+const sal_uInt16 EXC_WIN2_SHOWOUTLINE       = 0x0080;
+const sal_uInt16 EXC_WIN2_FROZENNOSPLIT     = 0x0100;
+const sal_uInt16 EXC_WIN2_SELECTED          = 0x0200;
+const sal_uInt16 EXC_WIN2_DISPLAYED         = 0x0400;
+const sal_uInt16 EXC_WIN2_PAGEBREAKMODE     = 0x0800;
+
+const sal_uInt16 EXC_WIN2_NORMALZOOM_DEF    = 100;      /// Default zoom for normal view.
+const sal_uInt16 EXC_WIN2_PAGEZOOM_DEF      = 60;       /// Default zoom for pagebreak preview.
+
+// (0x0041) PANE --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_PANE                = 0x0041;
+
+const sal_uInt8 EXC_PANE_BOTTOMRIGHT        = 0;        /// Bottom-right pane.
+const sal_uInt8 EXC_PANE_TOPRIGHT           = 1;        /// Right, or top-right pane.
+const sal_uInt8 EXC_PANE_BOTTOMLEFT         = 2;        /// Bottom, or bottom-left pane.
+const sal_uInt8 EXC_PANE_TOPLEFT            = 3;        /// Single, top, left, or top-left pane.
+
+// (0x00A0) SCL ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SCL                 = 0x00A0;
+
+// (0x0862) SHEETEXT ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_SHEETEXT            = 0x0862; 	/// header id for sheetext
+const sal_uInt8 EXC_SHEETEXT_TABCOLOR       = 0x7F; 	/// mask for tab color
+const sal_uInt16 EXC_COLOR_NOTABBG          = 0x7F;     /// Excel ignores Tab color when set to this value...
+// Structs ====================================================================
+
+/** Contains all view settings for the entire document. */
+struct XclDocViewData
+{
+    sal_uInt16          mnWinX;             /// X position of the document window (twips).
+    sal_uInt16          mnWinY;             /// Y position of the document window (twips).
+    sal_uInt16          mnWinWidth;         /// Width of the document window (twips).
+    sal_uInt16          mnWinHeight;        /// Height of the document window (twips).
+    sal_uInt16          mnFlags;            /// Additional flags.
+    sal_uInt16          mnDisplXclTab;      /// Displayed (active) sheet.
+    sal_uInt16          mnFirstVisXclTab;   /// First visible sheet.
+    sal_uInt16          mnXclSelectCnt;     /// Number of selected sheets.
+    sal_uInt16          mnTabBarWidth;      /// Width of sheet tabbar (1/1000 of window width).
+
+    explicit            XclDocViewData();
+};
+
+// ----------------------------------------------------------------------------
+
+/** Contains all settings for a selection in a single pane of a sheet. */
+struct XclSelectionData
+{
+    XclAddress          maXclCursor;        /// Cell cursor position.
+    XclRangeList        maXclSelection;     /// Selected cell ranges.
+    sal_uInt16          mnCursorIdx;        /// Index of cursor in selection list.
+
+    inline explicit     XclSelectionData() : mnCursorIdx( 0 ) {}
+};
+
+typedef ScfRef< XclSelectionData > XclSelectionDataRef;
+
+// ----------------------------------------------------------------------------
+
+/** Contains all view settings for a single sheet. */
+struct XclTabViewData
+{
+    typedef ::std::map< sal_uInt8, XclSelectionDataRef > XclSelectionMap;
+
+    XclSelectionMap     maSelMap;           /// Selections of all panes.
+    Color               maGridColor;        /// Grid color.
+    XclAddress          maFirstXclPos;      /// First visible cell.
+    XclAddress          maSecondXclPos;     /// First visible cell in additional panes.
+    sal_uInt16          mnSplitX;           /// Split X position, or number of frozen columns.
+    sal_uInt16          mnSplitY;           /// Split Y position, or number of frozen rows.
+    sal_uInt16          mnNormalZoom;       /// Zoom factor for normal view.
+    sal_uInt16          mnPageZoom;         /// Zoom factor for pagebreak preview.
+    sal_uInt16          mnCurrentZoom;      /// Zoom factor for current view.
+    sal_uInt8           mnActivePane;       /// Active pane (with cell cursor).
+    bool                mbSelected;         /// true = Sheet is selected.
+    bool                mbDisplayed;        /// true = Sheet is displayed (active).
+    bool                mbMirrored;         /// true = Mirrored (right-to-left) sheet.
+    bool                mbFrozenPanes;      /// true = Frozen panes; false = split window.
+    bool                mbPageMode;         /// true = Pagebreak preview; false = Normal view.
+    bool                mbDefGridColor;     /// true = Default grid color.
+    bool                mbShowFormulas;     /// true = Show formulas instead of results.
+    bool                mbShowGrid;         /// true = Show cell grid.
+    bool                mbShowHeadings;     /// true = Show column/row headings.
+    bool                mbShowZeros;        /// true = Show zero value zells.
+    bool                mbShowOutline;      /// true = Show outlines.
+    Color               maTabBgColor;       /// Tab Color default = (COL_AUTO )
+    bool                IsDefaultTabBgColor() const { return maTabBgColor == Color(COL_AUTO) ? TRUE : FALSE; };
+    sal_uInt32          mnTabBgColorId;         /// pallette color id
+
+    explicit            XclTabViewData();
+                        ~XclTabViewData();
+
+    /** Sets Excel default view settings. */
+    void                SetDefaults();
+
+    /** Returns true, if the window is split in any direction. */
+    bool                IsSplit() const;
+    /** Returns true, if the specified pane (EXC_PANE_*) is available. */
+    bool                HasPane( sal_uInt8 nPaneId ) const;
+
+    /** Returns the selection data, if available, otherwise 0. */
+    const XclSelectionData* GetSelectionData( sal_uInt8 nPane ) const;
+    /** Returns read/write access to the selection data of the specified pane. */
+    XclSelectionData&   CreateSelectionData( sal_uInt8 nPane );
+};
+
+// ============================================================================
+
+#endif
+
