diff -u -p -r1.5 dx_9rm.cxx
--- canvas/source/directx/dx_9rm.cxx	24 Jun 2008 10:30:05 -0000	1.5
+++ canvas/source/directx/dx_9rm.cxx	8 Dec 2008 23:04:21 -0000
@@ -53,6 +53,7 @@
 #include <canvas/debug.hxx>
 #include <canvas/verbosetrace.hxx>
 #include <tools/diagnose_ex.h>
+#include <osl/thread.h>
 
 #include <canvas/elapsedtime.hxx>
 #include <canvas/canvastools.hxx>
@@ -956,11 +957,43 @@ namespace dxcanvas
 			{
 				if(hr != D3DERR_DEVICELOST)
 					return false;
-				hr = mpDevice->Reset(&mad3dpp);
-				if(SUCCEEDED(hr))
-					return true;
-				if(hr == D3DERR_DEVICELOST)
-					return true;
+
+                // interestingly enough, sometimes the Reset() below
+                // *still* causes DeviceLost errors. So, cycle until
+                // DX was kind enough to really reset the device...
+                do
+                {
+                    mpVertexBuffer.reset();
+                    hr = mpDevice->Reset(&mad3dpp);
+                    if(SUCCEEDED(hr))
+                    {
+                        IDirect3DVertexBuffer9 *pVB(NULL);
+                        DWORD aFVF(D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1);
+                        if( FAILED(mpDevice->CreateVertexBuffer(sizeof(dxvertex)*maNumVertices,
+                                                                D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY,
+                                                                aFVF,
+                                                                D3DPOOL_DEFAULT,
+                                                                &pVB,
+                                                                NULL)) )
+                        {
+                            throw lang::NoSupportException(
+                                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                                     "Could not create DirectX device - out of memory!")),NULL);
+                        }
+                        mpVertexBuffer=COMReference<IDirect3DVertexBuffer9>(pVB);
+
+                        // retry after the restore
+                        if(SUCCEEDED(mpSwapChain->Present(&aRect,&aRect,NULL,NULL,0)))
+                            return true;
+                    }
+
+                    TimeValue aTimeout;
+                    aTimeout.Seconds=1;
+                    aTimeout.Nanosec=0;
+                    osl_waitThread(&aTimeout);
+                }
+                while(hr == D3DERR_DEVICELOST);
+
 				return false;
 			}
 
diff -u -p -r1.2 dx_surfacebitmap.cxx
--- canvas/source/directx/dx_surfacebitmap.cxx	24 Jun 2008 10:39:05 -0000	1.2
+++ canvas/source/directx/dx_surfacebitmap.cxx	8 Dec 2008 23:04:23 -0000
@@ -57,91 +57,6 @@ namespace dxcanvas
 	namespace
 	{
 		//////////////////////////////////////////////////////////////////////////////////
-		// DXColorBuffer
-		//////////////////////////////////////////////////////////////////////////////////
-
-		struct DXColorBuffer : public canvas::IColorBuffer
-		{
-        public:
-            DXColorBuffer( const COMReference<surface_type>& rSurface,
-						   const ::basegfx::B2IVector&       rSize ) :
-                mpSurface(rSurface),
-                maSize(rSize),
-                mbAlpha(false)
-            {
-            }
-
-		// implementation of the 'IColorBuffer' interface
-        public:
-
-            virtual sal_uInt8* lock() const;
-            virtual void       unlock() const;
-            virtual sal_uInt32 getWidth() const;
-            virtual sal_uInt32 getHeight() const;
-            virtual sal_uInt32 getStride() const;
-            virtual Format     getFormat() const;
-
-        private:
-
-            ::basegfx::B2IVector maSize;
-#if DIRECTX_VERSION < 0x0900
-			mutable DDSURFACEDESC aSurfaceDesc;
-#else
-			mutable D3DLOCKED_RECT maLockedRect;
-#endif
-			mutable COMReference<surface_type> mpSurface;
-            bool mbAlpha;
-		};
-
-		sal_uInt8* DXColorBuffer::lock() const
-		{
-#if DIRECTX_VERSION < 0x0900
-			rtl_fillMemory((void *)&aSurfaceDesc,sizeof(DDSURFACEDESC),0);
-			aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-			const DWORD dwFlags = DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_READONLY;
-			if(SUCCEEDED(mpSurface->Lock(NULL,&aSurfaceDesc,dwFlags,NULL)))
-				return static_cast<sal_uInt8 *>(aSurfaceDesc.lpSurface);
-#else
-			if(SUCCEEDED(mpSurface->LockRect(&maLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)))
-				return static_cast<sal_uInt8 *>(maLockedRect.pBits);
-#endif
-			return NULL;
-		}
-
-		void DXColorBuffer::unlock() const
-		{
-#if DIRECTX_VERSION < 0x0900
-			mpSurface->Unlock(NULL);
-#else
-			mpSurface->UnlockRect();
-#endif
-		}
-
-		sal_uInt32 DXColorBuffer::getWidth() const
-		{
-			return maSize.getX();
-		}
-
-		sal_uInt32 DXColorBuffer::getHeight() const
-		{
-			return maSize.getY();
-		}
-
-		sal_uInt32 DXColorBuffer::getStride() const
-		{
-#if DIRECTX_VERSION < 0x0900
-			return aSurfaceDesc.lPitch;
-#else
-			return maLockedRect.Pitch;
-#endif
-		}
-
-		canvas::IColorBuffer::Format DXColorBuffer::getFormat() const
-		{
-			return canvas::IColorBuffer::FMT_X8R8G8B8; 
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////
 		// GDIColorBuffer
 		//////////////////////////////////////////////////////////////////////////////////
 
@@ -233,7 +148,6 @@ namespace dxcanvas
         mpRenderModule(rRenderModule),
         mpSurfaceManager(rMgr),
         mpSurfaceProxy(),
-        mpSurface(),
 		mpGDIPlusBitmap(),
         mpGraphics(),
         mpColorBuffer(),
@@ -267,24 +181,24 @@ namespace dxcanvas
 					maSize.getY(),
 					PixelFormat32bppARGB 
 					));
-            mpGraphics.reset( tools::createGraphicsFromBitmap(mpGDIPlusBitmap) );
-
-			// create the colorbuffer object, which is basically a simple
-			// wrapper around the directx surface. the colorbuffer is the
-			// interface which is used by the surfaceproxy to support any
-			// kind of underlying structure for the pixel data container.
-			mpColorBuffer.reset(new GDIColorBuffer(mpGDIPlusBitmap,maSize));
 		}
 		else
 		{
-			mpSurface = mpRenderModule->createSystemMemorySurface(maSize);
-
-			// create the colorbuffer object, which is basically a simple
-			// wrapper around the directx surface. the colorbuffer is the
-			// interface which is used by the surfaceproxy to support any
-			// kind of underlying structure for the pixel data container.
-			mpColorBuffer.reset(new DXColorBuffer(mpSurface,maSize));
+			mpGDIPlusBitmap.reset( 
+				new Gdiplus::Bitmap( 
+					maSize.getX(),
+					maSize.getY(),
+					PixelFormat24bppRGB 
+					));
 		}
+            
+        mpGraphics.reset( tools::createGraphicsFromBitmap(mpGDIPlusBitmap) );
+
+        // create the colorbuffer object, which is basically a simple
+        // wrapper around the directx surface. the colorbuffer is the
+        // interface which is used by the surfaceproxy to support any
+        // kind of underlying structure for the pixel data container.
+        mpColorBuffer.reset(new GDIColorBuffer(mpGDIPlusBitmap,maSize));
 
 		// create a (possibly hardware accelerated) mirror surface.
 		mpSurfaceProxy = mpSurfaceManager->createSurfaceProxy(mpColorBuffer);
@@ -337,11 +251,7 @@ namespace dxcanvas
 		// to ensure that the corrosponding dxsurface will
 		// be updated.
 		mbIsSurfaceDirty = true;
-
-		if(hasAlpha())
-            return mpGraphics;
-        else
-            return createSurfaceGraphics(mpSurface);
+        return mpGraphics;
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
@@ -350,52 +260,7 @@ namespace dxcanvas
 
 	BitmapSharedPtr DXSurfaceBitmap::getBitmap() const
 	{
-		if(hasAlpha())
-			return mpGDIPlusBitmap;
-
-		BitmapSharedPtr pResult;
-
-#if DIRECTX_VERSION < 0x0900
-		DDSURFACEDESC aSurfaceDesc;
-		rtl_fillMemory(&aSurfaceDesc,sizeof(DDSURFACEDESC),0);
-		aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-		const DWORD dwFlags = DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_READONLY;
-
-		// lock the directx surface to receive the pointer to the surface memory.
-		if(SUCCEEDED(mpSurface->Lock(NULL,&aSurfaceDesc,dwFlags,NULL))) 
-        {
-			// decide about the format we pass the gdi+, the directx surface is always
-			// 32bit, either with or without alpha component.
-			Gdiplus::PixelFormat nFormat = hasAlpha() ? PixelFormat32bppARGB : PixelFormat32bppRGB;
-
-			// construct a gdi+ bitmap from the raw pixel data. 
-			pResult.reset(new Gdiplus::Bitmap( maSize.getX(),maSize.getY(),
-                                               aSurfaceDesc.lPitch,
-                                               nFormat,
-                                               (BYTE *)aSurfaceDesc.lpSurface ));
-            
-			// unlock the directx surface
-			mpSurface->Unlock(NULL);
-		}
-#else
-		D3DLOCKED_RECT aLockedRect;
-		if(SUCCEEDED(mpSurface->LockRect(&aLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)))
-		{
-			// decide about the format we pass the gdi+, the directx surface is always
-			// 32bit, either with or without alpha component.
-			Gdiplus::PixelFormat nFormat = hasAlpha() ? PixelFormat32bppARGB : PixelFormat32bppRGB;
-
-			// construct a gdi+ bitmap from the raw pixel data. 
-			pResult.reset(new Gdiplus::Bitmap( maSize.getX(),maSize.getY(),
-												aLockedRect.Pitch,
-												nFormat,
-												(BYTE *)aLockedRect.pBits ));
-
-			mpSurface->UnlockRect();
-		}
-#endif
-
-		return pResult;
+        return mpGDIPlusBitmap;
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
@@ -473,125 +338,41 @@ namespace dxcanvas
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
-	// DXSurfaceBitmap::imageDebugger
-	//////////////////////////////////////////////////////////////////////////////////
-#if defined(DX_DEBUG_IMAGES)
-# if OSL_DEBUG_LEVEL > 0
-	void DXSurfaceBitmap::imageDebugger()
-	{
-#if DIRECTX_VERSION < 0x0900
-		DDSURFACEDESC aSurfaceDesc;
-		rtl_fillMemory( &aSurfaceDesc,sizeof(DDSURFACEDESC),0 );
-		aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-
-		if( FAILED(mpSurface->Lock( NULL, 
-									&aSurfaceDesc, 
-									DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_READONLY,
-									NULL)) )
-			return;
-
-        imdebug("bgra w=%d h=%d %p", aSurfaceDesc.dwWidth, aSurfaceDesc.dwHeight, aSurfaceDesc.lpSurface);
-
-        mpSurface->Unlock(NULL);
-#else
-		D3DLOCKED_RECT aLockedRect;
-		if( FAILED(mpSurface->LockRect(&aLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)) )
-            return;
-
-        imdebug("bgra w=%d h=%d %p", maSize.getX(), 
-                maSize.getY(), aLockedRect.pBits);
-        mpSurface->UnlockRect();
-#endif
-	}
-# endif
-#endif
-
-	//////////////////////////////////////////////////////////////////////////////////
 	// DXSurfaceBitmap::getData
 	//////////////////////////////////////////////////////////////////////////////////
 
     uno::Sequence< sal_Int8 > DXSurfaceBitmap::getData( rendering::IntegerBitmapLayout&     /*bitmapLayout*/, 
                                                         const geometry::IntegerRectangle2D& rect )
     {
-		if(hasAlpha())
-		{
-			uno::Sequence< sal_Int8 > aRes( (rect.X2-rect.X1)*(rect.Y2-rect.Y1)*4 ); // TODO(F1): Be format-agnostic here
-
-			const Gdiplus::Rect aRect( tools::gdiPlusRectFromIntegerRectangle2D( rect ) );
-
-			Gdiplus::BitmapData aBmpData;
-			aBmpData.Width		 = rect.X2-rect.X1;
-			aBmpData.Height		 = rect.Y2-rect.Y1;
-			aBmpData.Stride 	 = 4*aBmpData.Width;
-			aBmpData.PixelFormat = PixelFormat32bppARGB;
-			aBmpData.Scan0		 = aRes.getArray(); 
-
-			// TODO(F1): Support more pixel formats natively
-
-			// read data from bitmap
-			if( Gdiplus::Ok != mpGDIPlusBitmap->LockBits( &aRect,
-												Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeUserInputBuf,
-												PixelFormat32bppARGB, // TODO(F1): Adapt to
-                                               							// Graphics native
-				                    									// format/change
-                														// getMemoryLayout
-												&aBmpData ) )
-			{
-				// failed to lock, bail out
-				return uno::Sequence< sal_Int8 >();
-			}
+        uno::Sequence< sal_Int8 > aRes( (rect.X2-rect.X1)*(rect.Y2-rect.Y1)*4 ); // TODO(F1): Be format-agnostic here
 
-			mpGDIPlusBitmap->UnlockBits( &aBmpData );
+        const Gdiplus::Rect aRect( tools::gdiPlusRectFromIntegerRectangle2D( rect ) );
 
-			return aRes;
-		}
-		else
-		{
-			sal_uInt32 nWidth = rect.X2-rect.X1;
-			sal_uInt32 nHeight = rect.Y2-rect.Y1;
+        Gdiplus::BitmapData aBmpData;
+        aBmpData.Width		 = rect.X2-rect.X1;
+        aBmpData.Height		 = rect.Y2-rect.Y1;
+        aBmpData.Stride 	 = 4*aBmpData.Width;
+        aBmpData.PixelFormat = PixelFormat32bppARGB;
+        aBmpData.Scan0		 = aRes.getArray(); 
+
+        // TODO(F1): Support more pixel formats natively
+
+        // read data from bitmap
+        if( Gdiplus::Ok != mpGDIPlusBitmap->LockBits( &aRect,
+                                                      Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeUserInputBuf,
+                                                      PixelFormat32bppARGB, // TODO(F1): Adapt to
+                                                      // Graphics native
+                                                      // format/change
+                                                      // getMemoryLayout
+                                                      &aBmpData ) )
+        {
+            // failed to lock, bail out
+            return uno::Sequence< sal_Int8 >();
+        }
 
-			uno::Sequence< sal_Int8 > aRes(nWidth*nHeight*4);
+        mpGDIPlusBitmap->UnlockBits( &aBmpData );
 
-#if DIRECTX_VERSION < 0x0900
-			DDSURFACEDESC aSurfaceDesc;
-			rtl_fillMemory(&aSurfaceDesc,sizeof(DDSURFACEDESC),0);
-			aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-			const DWORD dwFlags = DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_READONLY;
-
-			// lock the directx surface to receive the pointer to the surface memory.
-			if(FAILED(mpSurface->Lock(NULL,&aSurfaceDesc,dwFlags,NULL)))
-				return uno::Sequence< sal_Int8 >();
-
-			sal_uInt8 *pSrc = (sal_uInt8 *)((((BYTE *)aSurfaceDesc.lpSurface)+(rect.Y1*aSurfaceDesc.lPitch))+rect.X1);
-			sal_uInt8 *pDst = (sal_uInt8 *)aRes.getArray();
-			sal_uInt32 nSegmentSizeInBytes = nWidth<<4;
-			for(sal_uInt32 y=0; y<nHeight; ++y) 
-			{
-				rtl_copyMemory(pDst,pSrc,nSegmentSizeInBytes);
-				pDst += nSegmentSizeInBytes;
-				pSrc += aSurfaceDesc.lPitch;
-			}
-
-			mpSurface->Unlock(NULL);
-#else
-			D3DLOCKED_RECT aLockedRect;
-			if(FAILED(mpSurface->LockRect(&aLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)))
-				return uno::Sequence< sal_Int8 >();
-
-			sal_uInt8 *pSrc = (sal_uInt8 *)((((BYTE *)aLockedRect.pBits)+(rect.Y1*aLockedRect.Pitch))+rect.X1);
-			sal_uInt8 *pDst = (sal_uInt8 *)aRes.getArray();
-			sal_uInt32 nSegmentSizeInBytes = nWidth<<4;
-			for(sal_uInt32 y=0; y<nHeight; ++y) 
-			{
-				rtl_copyMemory(pDst,pSrc,nSegmentSizeInBytes);
-				pDst += nSegmentSizeInBytes;
-				pSrc += aLockedRect.Pitch;
-			}
-
-			mpSurface->UnlockRect();
-#endif
-			return aRes;
-		}
+        return aRes;
     }
 
 	//////////////////////////////////////////////////////////////////////////////////
@@ -602,78 +383,30 @@ namespace dxcanvas
                                    const rendering::IntegerBitmapLayout& /*bitmapLayout*/, 
                                    const geometry::IntegerRectangle2D& 	 rect )
     {
-		if(hasAlpha())
-		{
-			const Gdiplus::Rect aRect( tools::gdiPlusRectFromIntegerRectangle2D( rect ) );
+        const Gdiplus::Rect aRect( tools::gdiPlusRectFromIntegerRectangle2D( rect ) );
 
-			Gdiplus::BitmapData aBmpData;
-			aBmpData.Width		 = rect.X2-rect.X1;
-			aBmpData.Height		 = rect.Y2-rect.Y1;
-			aBmpData.Stride 	 = 4*aBmpData.Width;
-			aBmpData.PixelFormat = PixelFormat32bppARGB;
-			aBmpData.Scan0		 = (void*)data.getConstArray(); 
-
-			// TODO(F1): Support more pixel formats natively
-
-			if( Gdiplus::Ok != mpGDIPlusBitmap->LockBits( &aRect,
-												Gdiplus::ImageLockModeWrite | Gdiplus::ImageLockModeUserInputBuf,
-												PixelFormat32bppARGB, // TODO: Adapt to
-                                               							// Graphics native
-                                                  						// format/change
-                                                  						// getMemoryLayout
-												&aBmpData ) )
-			{
-				throw uno::RuntimeException();
-			}
-
-			// commit data to bitmap
-			mpGDIPlusBitmap->UnlockBits( &aBmpData );
-		}
-		else
-		{
-			sal_uInt32 nWidth = rect.X2-rect.X1;
-			sal_uInt32 nHeight = rect.Y2-rect.Y1;
-
-#if DIRECTX_VERSION < 0x0900
-			DDSURFACEDESC aSurfaceDesc;
-			rtl_fillMemory(&aSurfaceDesc,sizeof(DDSURFACEDESC),0);
-			aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-			const DWORD dwFlags = DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_WRITEONLY;
-
-			// lock the directx surface to receive the pointer to the surface memory.
-			if(FAILED(mpSurface->Lock(NULL,&aSurfaceDesc,dwFlags,NULL)))
-				throw uno::RuntimeException();
-
-			sal_uInt8 *pSrc = (sal_uInt8 *)data.getConstArray();
-			sal_uInt8 *pDst = (sal_uInt8 *)((((BYTE *)aSurfaceDesc.lpSurface)+(rect.Y1*aSurfaceDesc.lPitch))+rect.X1);
-			sal_uInt32 nSegmentSizeInBytes = nWidth<<4;
-			for(sal_uInt32 y=0; y<nHeight; ++y) 
-			{
-				rtl_copyMemory(pDst,pSrc,nSegmentSizeInBytes);
-				pSrc += nSegmentSizeInBytes;
-				pDst += aSurfaceDesc.lPitch;
-			}
-
-			mpSurface->Unlock(NULL);
-#else
-			// lock the directx surface to receive the pointer to the surface memory.
-			D3DLOCKED_RECT aLockedRect;
-			if(FAILED(mpSurface->LockRect(&aLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)))
-				throw uno::RuntimeException();
-
-			sal_uInt8 *pSrc = (sal_uInt8 *)data.getConstArray();
-			sal_uInt8 *pDst = (sal_uInt8 *)((((BYTE *)aLockedRect.pBits)+(rect.Y1*aLockedRect.Pitch))+rect.X1);
-			sal_uInt32 nSegmentSizeInBytes = nWidth<<4;
-			for(sal_uInt32 y=0; y<nHeight; ++y) 
-			{
-				rtl_copyMemory(pDst,pSrc,nSegmentSizeInBytes);
-				pSrc += nSegmentSizeInBytes;
-				pDst += aLockedRect.Pitch;
-			}
+        Gdiplus::BitmapData aBmpData;
+        aBmpData.Width		 = rect.X2-rect.X1;
+        aBmpData.Height		 = rect.Y2-rect.Y1;
+        aBmpData.Stride 	 = 4*aBmpData.Width;
+        aBmpData.PixelFormat = PixelFormat32bppARGB;
+        aBmpData.Scan0		 = (void*)data.getConstArray(); 
+
+        // TODO(F1): Support more pixel formats natively
+
+        if( Gdiplus::Ok != mpGDIPlusBitmap->LockBits( &aRect,
+                                                      Gdiplus::ImageLockModeWrite | Gdiplus::ImageLockModeUserInputBuf,
+                                                      PixelFormat32bppARGB, // TODO: Adapt to
+                                                      // Graphics native
+                                                      // format/change
+                                                      // getMemoryLayout
+                                                      &aBmpData ) )
+        {
+            throw uno::RuntimeException();
+        }
 
-			mpSurface->UnlockRect();
-#endif
-		}
+        // commit data to bitmap
+        mpGDIPlusBitmap->UnlockBits( &aBmpData );
 
         mbIsSurfaceDirty = true;
     }
@@ -686,58 +419,20 @@ namespace dxcanvas
                                     const rendering::IntegerBitmapLayout& /*bitmapLayout*/, 
                                     const geometry::IntegerPoint2D&       pos )
     {
-		if(hasAlpha())
-		{
-			const geometry::IntegerSize2D aSize( maSize.getX(),maSize.getY() );
+        const geometry::IntegerSize2D aSize( maSize.getX(),maSize.getY() );
 
-			ENSURE_ARG_OR_THROW( pos.X >= 0 && pos.X < aSize.Width, 
-							"CanvasHelper::setPixel: X coordinate out of bounds" );
-			ENSURE_ARG_OR_THROW( pos.Y >= 0 && pos.Y < aSize.Height, 
-							"CanvasHelper::setPixel: Y coordinate out of bounds" );
-			ENSURE_ARG_OR_THROW( color.getLength() > 3, 
-							"CanvasHelper::setPixel: not enough color components" );
-
-			if( Gdiplus::Ok != mpGDIPlusBitmap->SetPixel( pos.X, pos.Y, 
-												Gdiplus::Color( tools::sequenceToArgb( color ))))
-			{
-				throw uno::RuntimeException();
-			}
-		}
-		else
-		{
-			ENSURE_ARG_OR_THROW( pos.X >= 0 && pos.X < maSize.getX(), 
-							"CanvasHelper::setPixel: X coordinate out of bounds" );
-			ENSURE_ARG_OR_THROW( pos.Y >= 0 && pos.Y < maSize.getY(), 
-							"CanvasHelper::setPixel: Y coordinate out of bounds" );
-			ENSURE_ARG_OR_THROW( color.getLength() > 3, 
-							"CanvasHelper::setPixel: not enough color components" );
-
-			Gdiplus::Color aColor(tools::sequenceToArgb(color));
-
-#if DIRECTX_VERSION < 0x0900
-			DDSURFACEDESC aSurfaceDesc;
-			rtl_fillMemory(&aSurfaceDesc,sizeof(DDSURFACEDESC),0);
-			aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-			const DWORD dwFlags = DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_WRITEONLY;
-
-			// lock the directx surface to receive the pointer to the surface memory.
-			if(FAILED(mpSurface->Lock(NULL,&aSurfaceDesc,dwFlags,NULL)))
-				throw uno::RuntimeException();
-
-			sal_uInt32 *pDst = (sal_uInt32 *)((((BYTE *)aSurfaceDesc.lpSurface)+(pos.Y*aSurfaceDesc.lPitch))+pos.X);
-			*pDst = aColor.GetValue();
-			mpSurface->Unlock(NULL);
-#else
-			// lock the directx surface to receive the pointer to the surface memory.
-			D3DLOCKED_RECT aLockedRect;
-			if(FAILED(mpSurface->LockRect(&aLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)))
-				throw uno::RuntimeException();
-
-			sal_uInt32 *pDst = (sal_uInt32 *)((((BYTE *)aLockedRect.pBits)+(pos.Y*aLockedRect.Pitch))+pos.X);
-			*pDst = aColor.GetValue();
-			mpSurface->UnlockRect();
-#endif
-		}
+        ENSURE_ARG_OR_THROW( pos.X >= 0 && pos.X < aSize.Width, 
+                             "CanvasHelper::setPixel: X coordinate out of bounds" );
+        ENSURE_ARG_OR_THROW( pos.Y >= 0 && pos.Y < aSize.Height, 
+                             "CanvasHelper::setPixel: Y coordinate out of bounds" );
+        ENSURE_ARG_OR_THROW( color.getLength() > 3, 
+                             "CanvasHelper::setPixel: not enough color components" );
+
+        if( Gdiplus::Ok != mpGDIPlusBitmap->SetPixel( pos.X, pos.Y, 
+                                                      Gdiplus::Color( tools::sequenceToArgb( color ))))
+        {
+            throw uno::RuntimeException();
+        }
 
         mbIsSurfaceDirty = true;
     }
@@ -749,55 +444,19 @@ namespace dxcanvas
     uno::Sequence< sal_Int8 > DXSurfaceBitmap::getPixel( rendering::IntegerBitmapLayout&   /*bitmapLayout*/, 
                                                          const geometry::IntegerPoint2D&   pos )
     {
-		if(hasAlpha())
-		{
-			const geometry::IntegerSize2D aSize( maSize.getX(),maSize.getY() );
+        const geometry::IntegerSize2D aSize( maSize.getX(),maSize.getY() );
 
-			ENSURE_ARG_OR_THROW( pos.X >= 0 && pos.X < aSize.Width, 
-							"CanvasHelper::getPixel: X coordinate out of bounds" );
-			ENSURE_ARG_OR_THROW( pos.Y >= 0 && pos.Y < aSize.Height, 
-							"CanvasHelper::getPixel: Y coordinate out of bounds" );
+        ENSURE_ARG_OR_THROW( pos.X >= 0 && pos.X < aSize.Width, 
+                             "CanvasHelper::getPixel: X coordinate out of bounds" );
+        ENSURE_ARG_OR_THROW( pos.Y >= 0 && pos.Y < aSize.Height, 
+                             "CanvasHelper::getPixel: Y coordinate out of bounds" );
 
-			Gdiplus::Color aColor;
+        Gdiplus::Color aColor;
 
-			if( Gdiplus::Ok != mpGDIPlusBitmap->GetPixel( pos.X, pos.Y, &aColor ) )
-				return uno::Sequence< sal_Int8 >();
+        if( Gdiplus::Ok != mpGDIPlusBitmap->GetPixel( pos.X, pos.Y, &aColor ) )
+            return uno::Sequence< sal_Int8 >();
 	        
-			return tools::argbToIntSequence(aColor.GetValue());
-		}
-		else
-		{
-			ENSURE_ARG_OR_THROW( pos.X >= 0 && pos.X < maSize.getX(), 
-							"CanvasHelper::getPixel: X coordinate out of bounds" );
-			ENSURE_ARG_OR_THROW( pos.Y >= 0 && pos.Y < maSize.getY(), 
-							"CanvasHelper::getPixel: Y coordinate out of bounds" );
-
-#if DIRECTX_VERSION < 0x0900
-			DDSURFACEDESC aSurfaceDesc;
-			rtl_fillMemory(&aSurfaceDesc,sizeof(DDSURFACEDESC),0);
-			aSurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
-			const DWORD dwFlags = DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT|DDLOCK_READONLY;
-
-			// lock the directx surface to receive the pointer to the surface memory.
-			if(FAILED(mpSurface->Lock(NULL,&aSurfaceDesc,dwFlags,NULL)))
-				throw uno::RuntimeException();
-
-			sal_uInt32 *pDst = (sal_uInt32 *)((((BYTE *)aSurfaceDesc.lpSurface)+(pos.Y*aSurfaceDesc.lPitch))+pos.X);
-			Gdiplus::Color aColor(*pDst);
-			mpSurface->Unlock(NULL);
-#else
-			// lock the directx surface to receive the pointer to the surface memory.
-			D3DLOCKED_RECT aLockedRect;
-			if(FAILED(mpSurface->LockRect(&aLockedRect,NULL,D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY)))
-				throw uno::RuntimeException();
-
-			sal_uInt32 *pDst = (sal_uInt32 *)((((BYTE *)aLockedRect.pBits)+(pos.Y*aLockedRect.Pitch))+pos.X);
-			Gdiplus::Color aColor(*pDst);
-			mpSurface->UnlockRect();
-#endif
-			
-			return tools::argbToIntSequence(aColor.GetValue());
-		}
+        return tools::argbToIntSequence(aColor.GetValue());
     }
 
 	//////////////////////////////////////////////////////////////////////////////////
diff -u -p -r1.2 dx_surfacebitmap.hxx
--- canvas/source/directx/dx_surfacebitmap.hxx	24 Jun 2008 10:39:16 -0000	1.2
+++ canvas/source/directx/dx_surfacebitmap.hxx	8 Dec 2008 23:04:23 -0000
@@ -57,8 +57,6 @@ namespace dxcanvas
         virtual ::basegfx::B2IVector      getSize() const;
         virtual bool                      hasAlpha() const;
 
-        COMReference<surface_type>				getSurface() const { return mpSurface; }
-
         bool draw( double							fAlpha,
                    const ::basegfx::B2DPoint&		rPos,
                    const ::basegfx::B2DHomMatrix&	rTransform );
@@ -120,10 +118,6 @@ namespace dxcanvas
         // the hardware-dependent rendering stuff.
         canvas::ISurfaceProxySharedPtr mpSurfaceProxy;
 
-        // container for pixel data, we need to use a directx
-        // surface since GDI+ sucks...
-        COMReference<surface_type> mpSurface;
-
 		// since GDI+ does not work correctly in case we
 		// run on a 16bit display [don't ask me why] we need
 		// to occasionally render to a native GDI+ bitmap.
