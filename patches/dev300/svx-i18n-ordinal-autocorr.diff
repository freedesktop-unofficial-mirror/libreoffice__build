diff --git editeng/source/misc/svxacorr.cxx editeng/source/misc/svxacorr.cxx
index db86806..a4e6273 100644
--- editeng/source/misc/svxacorr.cxx
+++ editeng/source/misc/svxacorr.cxx
@@ -47,6 +47,7 @@
 #include <com/sun/star/i18n/UnicodeType.hdl>
 #include <unotools/collatorwrapper.hxx>
 #include <com/sun/star/i18n/CollatorOptions.hpp>
+#include <com/sun/star/i18n/XOrdinalSuffix.hpp>
 #include <unotools/localedatawrapper.hxx>
 #include <unotools/transliterationwrapper.hxx>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
@@ -488,48 +489,54 @@ BOOL SvxAutoCorrect::FnChgOrdinalNumber(
         if( !lcl_IsInAsciiArr( sImplEndSkipChars, rTxt.GetChar( nEndPos - 1 ) ))
             break;
 
-    if( 2 < nEndPos - nSttPos &&
-        rCC.isDigit( rTxt, nEndPos - 3 ) )
+
+    // Get the last number in the string to check
+    xub_StrLen nNumEnd = nEndPos;
+    bool foundEnd = false;
+    bool validNumber = true;
+    xub_StrLen i = nEndPos;
+   
+    do
     {
-        static sal_Char __READONLY_DATA
-            sAll[]		= "th",			/* rest */
-            sFirst[]	= "st",      	/* 1 */
-            sSecond[]	= "nd",       	/* 2 */
-            sThird[]	= "rd";       	/* 3 */
-        static const sal_Char* __READONLY_DATA aNumberTab[ 4 ] =
+        i--;
+        bool isDigit = rCC.isDigit( rTxt, i );
+        if ( foundEnd )
+            validNumber |= isDigit;
+
+        if ( isDigit && !foundEnd ) 
         {
-            sAll, sFirst, sSecond, sThird
-        };
-
-        sal_Unicode c = rTxt.GetChar( nEndPos - 3 );
-        if( ( c -= '0' ) > 3 )
-            c = 0;
-
-        bChg = ( ((sal_Unicode)*((aNumberTab[ c ])+0)) ==
-                                        rTxt.GetChar( nEndPos - 2 ) &&
-                 ((sal_Unicode)*((aNumberTab[ c ])+1)) ==
-                                         rTxt.GetChar( nEndPos - 1 )) ||
-               ( 3 < nEndPos - nSttPos &&
-                ( ((sal_Unicode)*(sAll+0)) == rTxt.GetChar( nEndPos - 2 ) &&
-                  ((sal_Unicode)*(sAll+1)) == rTxt.GetChar( nEndPos - 1 )));
-
-        if( bChg )
+            foundEnd = true;
+            nNumEnd = i;
+        }
+    }
+    while ( i > nSttPos );
+
+    if ( foundEnd && validNumber ) {
+        sal_Int32 nNum = rTxt.Copy( nSttPos, nNumEnd - nSttPos + 1 ).ToInt32( );
+    
+        // Check if the characters after that number correspond to the ordinal suffix
+        rtl::OUString sServiceName = rtl::OUString::createFromAscii( "com.sun.star.i18n.OrdinalSuffix" );
+        uno::Reference< i18n::XOrdinalSuffix > xOrdSuffix( 
+                comphelper::createProcessComponent( sServiceName ),
+                uno::UNO_QUERY );
+    
+        if ( xOrdSuffix.is( ) ) 
         {
-            // dann pruefe mal, ob alle bis zum Start alle Zahlen sind
-            for( xub_StrLen n = nEndPos - 3; nSttPos < n; )
-                if( !rCC.isDigit( rTxt, --n ) )
-                {
-                    bChg = !rCC.isLetter( rTxt, n );
-                    break;
-                }
+            String sSuffix( xOrdSuffix->getOrdinalSuffix( nNum, rCC.getLocale( ) ) );
+            String sEnd = rTxt.Copy( nNumEnd + 1, nEndPos - nNumEnd - 1 );
 
-            if( bChg )		// dann setze mal das Escapement Attribut
+            if ( sSuffix == sEnd )
             {
-                SvxEscapementItem aSvxEscapementItem( DFLT_ESC_AUTO_SUPER,
-                                                    DFLT_ESC_PROP, SID_ATTR_CHAR_ESCAPEMENT );
-                rDoc.SetAttr( nEndPos - 2, nEndPos,
-                                SID_ATTR_CHAR_ESCAPEMENT,
-                                aSvxEscapementItem);
+                // Check if the ordinal suffix has to be set as super script
+                if ( rCC.isLetter( sSuffix ) )
+                {
+                    // Do the change
+                    SvxEscapementItem aSvxEscapementItem( DFLT_ESC_AUTO_SUPER,
+                                                        DFLT_ESC_PROP, SID_ATTR_CHAR_ESCAPEMENT );
+                    rDoc.SetAttr( nNumEnd + 1 , nEndPos,
+                                    SID_ATTR_CHAR_ESCAPEMENT,
+                                    aSvxEscapementItem);
+                }
             }
         }
 
diff --git i18npool/source/ordinalsuffix/ordinalsuffix.cxx i18npool/source/ordinalsuffix/ordinalsuffix.cxx
index 378a95b..d3cae97 100644
--- i18npool/source/ordinalsuffix/ordinalsuffix.cxx
+++ i18npool/source/ordinalsuffix/ordinalsuffix.cxx
@@ -31,10 +31,14 @@
 #include <string.h>
 #include "ordinalsuffix.hxx"
 
+#include <unicode/rbnf.h>
+#include <unicode/normlzr.h>
+
+#define CSTR( ouStr ) rtl::OUStringToOString( ouStr, RTL_TEXTENCODING_UTF8 ).getStr( )
 
 using namespace ::com::sun::star::i18n;
 using namespace ::com::sun::star::uno;
-using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star;
 using namespace ::rtl;
 
 namespace com { namespace sun { namespace star { namespace i18n {
@@ -83,13 +87,49 @@ static OUString getOrdinalSuffixEn( sal_Int32 nNumber )
 }
 
 
+/*
+ * For this method to properly return the ordinal suffix for other locales
+ * than english ones, ICU 4.2+ has to be used.
+ */
 OUString SAL_CALL OrdinalSuffix::getOrdinalSuffix( sal_Int32 nNumber,
-        const Locale &aLocale ) throw( RuntimeException )
+        const lang::Locale &aLocale ) throw( RuntimeException )
 {
     OUString retValue;
-
-    if (aLocale.Language.equalsAsciiL("en",2))
-        retValue = getOrdinalSuffixEn( nNumber );
+    
+    // Get the value from ICU
+    UErrorCode nCode = U_ZERO_ERROR;
+    const icu::Locale rIcuLocale( 
+            CSTR( aLocale.Language ), 
+            CSTR( aLocale.Country ), 
+            CSTR( aLocale.Variant ) );
+    icu::RuleBasedNumberFormat formatter( 
+            icu::URBNF_ORDINAL, rIcuLocale, nCode );
+
+    if ( U_SUCCESS( nCode ) ) 
+    {
+        // format the string
+        icu::UnicodeString icuRet;
+        formatter.format( (int32_t)nNumber, icuRet );
+
+        // Apply NFKC normalization to get normal letters
+        icu::UnicodeString normalized;
+        nCode = U_ZERO_ERROR;
+        icu::Normalizer::normalize( icuRet, UNORM_NFKC, 0, normalized, nCode );
+        if ( U_SUCCESS( nCode ) ) 
+        {
+            // Convert the normalized UnicodeString to OUString
+            OUString sValue( reinterpret_cast<const sal_Unicode *>( normalized.getBuffer( ) ), normalized.length() );
+
+            // Remove the number to get the prefix
+            sal_Int32 len = OUString::valueOf( nNumber ).getLength( );
+            retValue = sValue.copy( len );
+        }
+    }
+    else 
+    { 
+        if (aLocale.Language.equalsAsciiL("en",2))
+            retValue = getOrdinalSuffixEn( nNumber );
+    }
 
     return retValue;
 }
