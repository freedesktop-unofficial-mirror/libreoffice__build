diff --git sc/inc/scmatrix.hxx sc/inc/scmatrix.hxx
index c557e08..5c450ac 100644
--- sc/inc/scmatrix.hxx
+++ sc/inc/scmatrix.hxx
@@ -106,6 +106,7 @@ class SC_DLLPUBLIC ScMatrix
     void ResetIsString();
     void DeleteIsString();
     void CreateMatrix( SCSIZE nC, SCSIZE nR);
+    void Clear();
 
     // pStr may be NULL, bFlag MUST NOT be 0
     void PutStringEntry( const String* pStr, BYTE bFlag, SCSIZE nIndex );
@@ -178,6 +179,12 @@ public:
     /** Clone the matrix. */
     ScMatrix* Clone() const;
 
+    /** 
+     * Resize the matrix to specified new dimension.  Note that this operation
+     * clears all stored values. 
+     */
+    void Resize( SCSIZE nC, SCSIZE nR);
+
     /** Clone the matrix and extend it to the new size. nNewCols and nNewRows
         MUST be at least of the size of the original matrix. */
     ScMatrix* CloneAndExtend( SCSIZE nNewCols, SCSIZE nNewRows ) const;
diff --git sc/source/core/tool/address.cxx sc/source/core/tool/address.cxx
index 906b9e7..506b276 100644
--- sc/source/core/tool/address.cxx
+++ sc/source/core/tool/address.cxx
@@ -631,7 +631,9 @@ lcl_ScRange_Parse_XL_R1C1( ScRange& r,
 {
     const sal_Unicode* pTmp = NULL;
     String aExternDocName, aStartTabName, aEndTabName;
-    USHORT nFlags = SCA_VALID | SCA_VALID_TAB, nFlags2 = SCA_VALID_TAB2;
+    USHORT nFlags = SCA_VALID | SCA_VALID_TAB;
+    // Keep in mind that nFlags2 gets left-shifted by 4 bits before being merged.
+    USHORT nFlags2 = SCA_VALID_TAB;
 
 #if 0
     {
diff --git sc/source/core/tool/scmatrix.cxx sc/source/core/tool/scmatrix.cxx
index 35541bc..2686d9d 100644
--- sc/source/core/tool/scmatrix.cxx
+++ sc/source/core/tool/scmatrix.cxx
@@ -65,12 +65,17 @@ void ScMatrix::CreateMatrix(SCSIZE nC, SCSIZE nR)		// nur fuer ctor
     mnNonValue = 0;
 }
 
-ScMatrix::~ScMatrix()
+void ScMatrix::Clear()
 {
     DeleteIsString();
     delete [] pMat;
 }
 
+ScMatrix::~ScMatrix()
+{
+    Clear();
+}
+
 ScMatrix* ScMatrix::Clone() const
 {
     ScMatrix* pScMat = new ScMatrix( nColCount, nRowCount);
@@ -79,6 +84,12 @@ ScMatrix* ScMatrix::Clone() const
     return pScMat;
 }
 
+void ScMatrix::Resize( SCSIZE nC, SCSIZE nR)
+{
+    Clear();
+    CreateMatrix(nC, nR);
+}
+
 ScMatrix* ScMatrix::CloneAndExtend( SCSIZE nNewCols, SCSIZE nNewRows ) const
 {
     ScMatrix* pScMat = new ScMatrix( nNewCols, nNewRows);
diff --git sc/source/filter/excel/excform.cxx sc/source/filter/excel/excform.cxx
index 5ee0285..7e38419 100644
--- sc/source/filter/excel/excform.cxx
+++ sc/source/filter/excel/excform.cxx
@@ -474,10 +474,7 @@ ConvErr ExcelToSc::Convert( const ScTokenArray*& pErgebnis, XclImpStream& aIn, s
                 aIn.Ignore( (meBiff == EXC_BIFF2) ? 3 : 4 );
                 if( bAllowArrays )
                 {
-                    SCSIZE nC = nByte ? nByte : 256;
-                    SCSIZE nR = nUINT16;
-
-                    aStack << aPool.StoreMatrix( nC, nR );
+                    aStack << aPool.StoreMatrix();
                     aExtensions.push_back( EXTENSION_ARRAY );
                 }
                 else
@@ -1895,6 +1892,7 @@ void ExcelToSc::ReadExtensionArray( unsigned int n, XclImpStream& aIn )
 
     if( NULL != pMatrix )
     {
+        pMatrix->Resize(nCols, nRows);
         pMatrix->GetDimensions( nC, nR);
         if( nC != nCols || nR != nRows )
         {
diff --git sc/source/filter/excel/excform8.cxx sc/source/filter/excel/excform8.cxx
index 015f06d..f3c3f1b 100644
--- sc/source/filter/excel/excform8.cxx
+++ sc/source/filter/excel/excform8.cxx
@@ -395,10 +395,7 @@ ConvErr ExcelToSc8::Convert( const ScTokenArray*& rpTokArray, XclImpStream& aIn,
                 aIn.Ignore( 4 );
                 if( bAllowArrays )
                 {
-                    SCSIZE nC = nByte + 1;
-                    SCSIZE nR = nUINT16 + 1;
-
-                    aStack << aPool.StoreMatrix( nC, nR );
+                    aStack << aPool.StoreMatrix();
                     aExtensions.push_back( EXTENSION_ARRAY );
                 }
                 else
diff --git sc/source/filter/excel/tokstack.cxx sc/source/filter/excel/tokstack.cxx
index d24dac4..7f51b39 100644
--- sc/source/filter/excel/tokstack.cxx
+++ sc/source/filter/excel/tokstack.cxx
@@ -740,7 +740,7 @@ const TokenId TokenPool::StoreNlf( const ScSingleRefData& rTr )
     return ( const TokenId ) nElementAkt;
 }
 
-const TokenId TokenPool::StoreMatrix( SCSIZE nC, SCSIZE nR )
+const TokenId TokenPool::StoreMatrix()
 {
     ScMatrix* pM;
 
@@ -753,8 +753,7 @@ const TokenId TokenPool::StoreMatrix( SCSIZE nC, SCSIZE nR )
     pElement[ nElementAkt ] = nP_MatrixAkt;
     pType[ nElementAkt ] = T_Matrix;
 
-    pM = new ScMatrix( nC, nR );
-    pM->FillDouble( 0., 0,0, nC-1, nR-1 );
+    pM = new ScMatrix( 0, 0 );
     pM->IncRef( );
     ppP_Matrix[ nP_MatrixAkt ] = pM;
 
diff --git sc/source/filter/excel/xicontent.cxx sc/source/filter/excel/xicontent.cxx
index 7b5fb22..0470830 100644
--- sc/source/filter/excel/xicontent.cxx
+++ sc/source/filter/excel/xicontent.cxx
@@ -1216,7 +1216,29 @@ void XclImpSheetProtectBuffer::ReadProtect( XclImpStream& rStrm, SCTAB nTab )
 
 void XclImpSheetProtectBuffer::ReadOptions( XclImpStream& rStrm, SCTAB nTab )
 {
-    rStrm.Ignore(19);
+    rStrm.Ignore(12);
+
+    // feature type can be either 2 or 4.  If 2, this record stores flag for 
+    // enhanced protection, whereas if 4 it stores flag for smart tag.
+    sal_uInt16 nFeatureType;
+    rStrm >> nFeatureType;
+    if (nFeatureType != 2)
+        // We currently only support import of enhanced protection data.
+        return;
+
+    rStrm.Ignore(1); // always 1
+
+    // The flag size specifies the size of bytes that follows that stores 
+    // feature data.  If -1 it depends on the feature type imported earlier.
+    // For enhanced protection data, the size is always 4.  For the most xls
+    // documents out there this value is almost always -1.
+    sal_Int32 nFlagSize;
+    rStrm >> nFlagSize;
+    if (nFlagSize != -1)
+        return;
+
+    // There are actually 4 bytes to read, but the upper 2 bytes currently 
+    // don't store any bits.
     sal_uInt16 nOptions;
     rStrm >> nOptions;
 
diff --git sc/source/filter/inc/tokstack.hxx sc/source/filter/inc/tokstack.hxx
index e11c280..2002da7 100644
--- sc/source/filter/inc/tokstack.hxx
+++ sc/source/filter/inc/tokstack.hxx
@@ -210,7 +210,7 @@ class TokenPool
         const TokenId				Store( const DefTokenId eId, const String& rName );
                                         // 4 externals (e.g. AddIns, Makros...)
         const TokenId				StoreNlf( const ScSingleRefData& rTr );
-        const TokenId				StoreMatrix( SCSIZE nC, SCSIZE nR );
+        const TokenId               StoreMatrix();
         const TokenId               StoreExtName( sal_uInt16 nFileId, const String& rName );
         const TokenId               StoreExtRef( sal_uInt16 nFileId, const String& rTabName, const ScSingleRefData& rRef );
         const TokenId               StoreExtRef( sal_uInt16 nFileId, const String& rTabName, const ScComplexRefData& rRef );
diff --git sc/source/ui/inc/gridwin.hxx sc/source/ui/inc/gridwin.hxx
index 4c701ad..cdf3804 100644
--- sc/source/ui/inc/gridwin.hxx
+++ sc/source/ui/inc/gridwin.hxx
@@ -277,7 +277,7 @@ private:
 
     void			PasteSelection( const Point& rPosPixel );
 
-    void			SelectForContextMenu( const Point& rPosPixel );
+    void			SelectForContextMenu( const Point& rPosPixel, SCsCOL nCellX, SCsROW nCellY );
 
     void            GetSelectionRects( ::std::vector< Rectangle >& rPixelRects );
 
diff --git sc/source/ui/inc/hdrcont.hxx sc/source/ui/inc/hdrcont.hxx
index 20cc822..497140f 100644
--- sc/source/ui/inc/hdrcont.hxx
+++ sc/source/ui/inc/hdrcont.hxx
@@ -80,7 +80,7 @@ private:
 
     long			GetScrPos( SCCOLROW nEntryNo );
     SCCOLROW		GetMousePos( const MouseEvent& rMEvt, BOOL& rBorder );
-
+    bool            IsSelectionAllowed(SCCOLROW nPos) const;
     void			ShowDragHelp();
 
     void			DoPaint( SCCOLROW nStart, SCCOLROW nEnd );
diff --git sc/source/ui/view/gridwin.cxx sc/source/ui/view/gridwin.cxx
index 5e389ef..4076386 100644
--- sc/source/ui/view/gridwin.cxx
+++ sc/source/ui/view/gridwin.cxx
@@ -2696,9 +2696,32 @@ void __EXPORT ScGridWindow::Command( const CommandEvent& rCEvt )
 
         if ( bMouse )
         {
+            SCsCOL nCellX = -1;
+            SCsROW nCellY = -1;
+            pViewData->GetPosFromPixel(aPosPixel.X(), aPosPixel.Y(), eWhich, nCellX, nCellY);
+            ScDocument* pDoc = pViewData->GetDocument();
+            SCTAB nTab = pViewData->GetTabNo();
+            const ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+            bool bSelectAllowed = true;
+            if ( pProtect && pProtect->isProtected() )
+            {
+                // This sheet is protected.  Check if a context menu is allowed on this cell.
+                bool bCellProtected = pDoc->HasAttrib(nCellX, nCellY, nTab, nCellX, nCellY, nTab, HASATTR_PROTECTED);
+                bool bSelProtected   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+                bool bSelUnprotected = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+                if (bCellProtected)
+                    bSelectAllowed = bSelProtected;
+                else
+                    bSelectAllowed = bSelUnprotected;
+            }
+            if (!bSelectAllowed)
+                // Selecting this cell is not allowed, neither is context menu.
+                return;
+
             //	#i18735# First select the item under the mouse pointer.
             //	This can change the selection, and the view state (edit mode, etc).
-            SelectForContextMenu( aPosPixel );
+            SelectForContextMenu( aPosPixel, nCellX, nCellY );
         }
 
         BOOL bDone = FALSE;
@@ -2793,15 +2816,12 @@ void __EXPORT ScGridWindow::Command( const CommandEvent& rCEvt )
     }
 }
 
-void ScGridWindow::SelectForContextMenu( const Point& rPosPixel )
+void ScGridWindow::SelectForContextMenu( const Point& rPosPixel, SCsCOL nCellX, SCsROW nCellY )
 {
     //  #i18735# if the click was outside of the current selection,
     //  the cursor is moved or an object at the click position selected.
     //  (see SwEditWin::SelectMenuPosition in Writer)
 
-    SCsCOL nCellX;
-    SCsROW nCellY;
-    pViewData->GetPosFromPixel( rPosPixel.X(), rPosPixel.Y(), eWhich, nCellX, nCellY );
     ScTabView* pView = pViewData->GetView();
     ScDrawView* pDrawView = pView->GetScDrawView();
 
diff --git sc/source/ui/view/hdrcont.cxx sc/source/ui/view/hdrcont.cxx
index c44d200..37763b2 100644
--- sc/source/ui/view/hdrcont.cxx
+++ sc/source/ui/view/hdrcont.cxx
@@ -47,6 +47,7 @@
 #include "scmod.hxx"		// Optionen
 #include "inputopt.hxx"		// Optionen
 #include "gridmerg.hxx"
+#include "document.hxx"
 
 // -----------------------------------------------------------------------
 
@@ -655,6 +656,39 @@ SCCOLROW ScHeaderControl::GetMousePos( const MouseEvent& rMEvt, BOOL& rBorder )
     return nHitNo;
 }
 
+bool ScHeaderControl::IsSelectionAllowed(SCCOLROW nPos) const
+{
+    ScTabViewShell* pViewSh = dynamic_cast<ScTabViewShell*>(SfxViewShell::Current());
+    if (!pViewSh)
+        return false;
+
+    ScViewData* pViewData = pViewSh->GetViewData();
+    USHORT nTab = pViewData->GetTabNo();
+    ScDocument* pDoc = pViewData->GetDocument();
+    const ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+    bool bSelectAllowed = true;
+    if ( pProtect && pProtect->isProtected() )
+    {
+        // This sheet is protected.  Check if a context menu is allowed on this cell.
+        bool bCellsProtected = false;
+        if (bVertical)
+            // row header
+            bCellsProtected = pDoc->HasAttrib(0, nPos, nTab, MAXCOL, nPos, nTab, HASATTR_PROTECTED);
+        else
+            // column header
+            bCellsProtected = pDoc->HasAttrib(nPos, 0, nTab, nPos, MAXROW, nTab, HASATTR_PROTECTED);
+
+        bool bSelProtected   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+        bool bSelUnprotected = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+        if (bCellsProtected)
+            bSelectAllowed = bSelProtected;
+        else
+            bSelectAllowed = bSelUnprotected;
+    }
+    return bSelectAllowed;
+}
+
 void __EXPORT ScHeaderControl::MouseButtonDown( const MouseEvent& rMEvt )
 {
     if (IsDisabled())
@@ -665,6 +699,8 @@ void __EXPORT ScHeaderControl::MouseButtonDown( const MouseEvent& rMEvt )
 
     BOOL bFound;
     SCCOLROW nHitNo = GetMousePos( rMEvt, bFound );
+    if (!IsSelectionAllowed(nHitNo))
+        return;
 
     if ( bFound && rMEvt.IsLeft() && ResizeAllowed() )
     {
@@ -848,8 +884,11 @@ void __EXPORT ScHeaderControl::Command( const CommandEvent& rCEvt )
                 MouseEvent aMEvt( rCEvt.GetMousePosPixel() );
                 BOOL bBorder;
                 SCCOLROW nPos = GetMousePos( aMEvt, bBorder );
-                USHORT nTab = pViewData->GetTabNo();
+                if (!IsSelectionAllowed(nPos))
+                    // Selecting this cell is not allowed, neither is context menu.
+                    return;
 
+                SCTAB nTab = pViewData->GetTabNo();
                 ScRange aNewRange;
                 if ( bVertical )
                     aNewRange = ScRange( 0, sal::static_int_cast<SCROW>(nPos), nTab,
