From dee543d7e9f5634e2c974b308eeea2490a3aaa3a Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:52:54 +0200
Subject: [PATCH 025/878] cws-kohei04-sc.diff

---
 sc/inc/scmatrix.hxx                  |    7 +++++
 sc/source/core/tool/address.cxx      |    4 ++-
 sc/source/core/tool/scmatrix.cxx     |   13 ++++++++++-
 sc/source/filter/excel/excform.cxx   |    6 +---
 sc/source/filter/excel/excform8.cxx  |    5 +---
 sc/source/filter/excel/tokstack.cxx  |    5 +--
 sc/source/filter/excel/xicontent.cxx |   24 +++++++++++++++++++-
 sc/source/filter/inc/tokstack.hxx    |    2 +-
 sc/source/ui/inc/gridwin.hxx         |    2 +-
 sc/source/ui/inc/hdrcont.hxx         |    2 +-
 sc/source/ui/view/gridwin.cxx        |   30 ++++++++++++++++++++----
 sc/source/ui/view/hdrcont.cxx        |   41 +++++++++++++++++++++++++++++++++-
 12 files changed, 118 insertions(+), 23 deletions(-)

diff --git a/sc/inc/scmatrix.hxx b/sc/inc/scmatrix.hxx
index 50fc42c..a65a554 100644
--- a/sc/inc/scmatrix.hxx
+++ b/sc/inc/scmatrix.hxx
@@ -103,6 +103,7 @@ class SC_DLLPUBLIC ScMatrix
     void ResetIsString();
     void DeleteIsString();
     void CreateMatrix( SCSIZE nC, SCSIZE nR);
+    void Clear();
 
     // pStr may be NULL, bFlag MUST NOT be 0
     void PutStringEntry( const String* pStr, BYTE bFlag, SCSIZE nIndex );
@@ -175,6 +176,12 @@ public:
     /** Clone the matrix. */
     ScMatrix* Clone() const;
 
+    /**
+     * Resize the matrix to specified new dimension.  Note that this operation
+     * clears all stored values.
+     */
+    void Resize( SCSIZE nC, SCSIZE nR);
+
     /** Clone the matrix and extend it to the new size. nNewCols and nNewRows
         MUST be at least of the size of the original matrix. */
     ScMatrix* CloneAndExtend( SCSIZE nNewCols, SCSIZE nNewRows ) const;
diff --git a/sc/source/core/tool/address.cxx b/sc/source/core/tool/address.cxx
index f5256ff..5910298 100644
--- a/sc/source/core/tool/address.cxx
+++ b/sc/source/core/tool/address.cxx
@@ -634,7 +634,9 @@ lcl_ScRange_Parse_XL_R1C1( ScRange& r,
 {
     const sal_Unicode* pTmp = NULL;
     String aExternDocName, aStartTabName, aEndTabName;
-    USHORT nFlags = SCA_VALID | SCA_VALID_TAB, nFlags2 = SCA_VALID_TAB2;
+    USHORT nFlags = SCA_VALID | SCA_VALID_TAB;
+    // Keep in mind that nFlags2 gets left-shifted by 4 bits before being merged.
+    USHORT nFlags2 = SCA_VALID_TAB;
 
 #if 0
     {
diff --git a/sc/source/core/tool/scmatrix.cxx b/sc/source/core/tool/scmatrix.cxx
index 0a99b6f..649f9a7 100644
--- a/sc/source/core/tool/scmatrix.cxx
+++ b/sc/source/core/tool/scmatrix.cxx
@@ -62,12 +62,17 @@ void ScMatrix::CreateMatrix(SCSIZE nC, SCSIZE nR)		// nur fuer ctor
     mnNonValue = 0;
 }
 
-ScMatrix::~ScMatrix()
+void ScMatrix::Clear()
 {
     DeleteIsString();
     delete [] pMat;
 }
 
+ScMatrix::~ScMatrix()
+{
+    Clear();
+}
+
 ScMatrix* ScMatrix::Clone() const
 {
     ScMatrix* pScMat = new ScMatrix( nColCount, nRowCount);
@@ -76,6 +81,12 @@ ScMatrix* ScMatrix::Clone() const
     return pScMat;
 }
 
+void ScMatrix::Resize( SCSIZE nC, SCSIZE nR)
+{
+    Clear();
+    CreateMatrix(nC, nR);
+}
+
 ScMatrix* ScMatrix::CloneAndExtend( SCSIZE nNewCols, SCSIZE nNewRows ) const
 {
     ScMatrix* pScMat = new ScMatrix( nNewCols, nNewRows);
diff --git a/sc/source/filter/excel/excform.cxx b/sc/source/filter/excel/excform.cxx
index d58eddb..4d9822d 100644
--- a/sc/source/filter/excel/excform.cxx
+++ b/sc/source/filter/excel/excform.cxx
@@ -471,10 +471,7 @@ ConvErr ExcelToSc::Convert( const ScTokenArray*& pErgebnis, XclImpStream& aIn, s
                 aIn.Ignore( (meBiff == EXC_BIFF2) ? 3 : 4 );
                 if( bAllowArrays )
                 {
-                    SCSIZE nC = nByte ? nByte : 256;
-                    SCSIZE nR = nUINT16;
-
-                    aStack << aPool.StoreMatrix( nC, nR );
+                    aStack << aPool.StoreMatrix();
                     aExtensions.push_back( EXTENSION_ARRAY );
                 }
                 else
@@ -1892,6 +1889,7 @@ void ExcelToSc::ReadExtensionArray( unsigned int n, XclImpStream& aIn )
 
     if( NULL != pMatrix )
     {
+        pMatrix->Resize(nCols, nRows);
         pMatrix->GetDimensions( nC, nR);
         if( nC != nCols || nR != nRows )
         {
diff --git a/sc/source/filter/excel/excform8.cxx b/sc/source/filter/excel/excform8.cxx
index 69788c7..9e52770 100644
--- a/sc/source/filter/excel/excform8.cxx
+++ b/sc/source/filter/excel/excform8.cxx
@@ -392,10 +392,7 @@ ConvErr ExcelToSc8::Convert( const ScTokenArray*& rpTokArray, XclImpStream& aIn,
                 aIn.Ignore( 4 );
                 if( bAllowArrays )
                 {
-                    SCSIZE nC = nByte + 1;
-                    SCSIZE nR = nUINT16 + 1;
-
-                    aStack << aPool.StoreMatrix( nC, nR );
+                    aStack << aPool.StoreMatrix();
                     aExtensions.push_back( EXTENSION_ARRAY );
                 }
                 else
diff --git a/sc/source/filter/excel/tokstack.cxx b/sc/source/filter/excel/tokstack.cxx
index bd19a0d..0bc3954 100644
--- a/sc/source/filter/excel/tokstack.cxx
+++ b/sc/source/filter/excel/tokstack.cxx
@@ -737,7 +737,7 @@ const TokenId TokenPool::StoreNlf( const ScSingleRefData& rTr )
     return ( const TokenId ) nElementAkt;
 }
 
-const TokenId TokenPool::StoreMatrix( SCSIZE nC, SCSIZE nR )
+const TokenId TokenPool::StoreMatrix()
 {
     ScMatrix* pM;
 
@@ -750,8 +750,7 @@ const TokenId TokenPool::StoreMatrix( SCSIZE nC, SCSIZE nR )
     pElement[ nElementAkt ] = nP_MatrixAkt;
     pType[ nElementAkt ] = T_Matrix;
 
-    pM = new ScMatrix( nC, nR );
-    pM->FillDouble( 0., 0,0, nC-1, nR-1 );
+    pM = new ScMatrix( 0, 0 );
     pM->IncRef( );
     ppP_Matrix[ nP_MatrixAkt ] = pM;
 
diff --git a/sc/source/filter/excel/xicontent.cxx b/sc/source/filter/excel/xicontent.cxx
index b147cb0..840d7c0 100644
--- a/sc/source/filter/excel/xicontent.cxx
+++ b/sc/source/filter/excel/xicontent.cxx
@@ -1213,7 +1213,29 @@ void XclImpSheetProtectBuffer::ReadProtect( XclImpStream& rStrm, SCTAB nTab )
 
 void XclImpSheetProtectBuffer::ReadOptions( XclImpStream& rStrm, SCTAB nTab )
 {
-    rStrm.Ignore(19);
+    rStrm.Ignore(12);
+
+    // feature type can be either 2 or 4.  If 2, this record stores flag for
+    // enhanced protection, whereas if 4 it stores flag for smart tag.
+    sal_uInt16 nFeatureType;
+    rStrm >> nFeatureType;
+    if (nFeatureType != 2)
+        // We currently only support import of enhanced protection data.
+        return;
+
+    rStrm.Ignore(1); // always 1
+
+    // The flag size specifies the size of bytes that follows that stores
+    // feature data.  If -1 it depends on the feature type imported earlier.
+    // For enhanced protection data, the size is always 4.  For the most xls
+    // documents out there this value is almost always -1.
+    sal_Int32 nFlagSize;
+    rStrm >> nFlagSize;
+    if (nFlagSize != -1)
+        return;
+
+    // There are actually 4 bytes to read, but the upper 2 bytes currently
+    // don't store any bits.
     sal_uInt16 nOptions;
     rStrm >> nOptions;
 
diff --git a/sc/source/filter/inc/tokstack.hxx b/sc/source/filter/inc/tokstack.hxx
index 955f8df..2102cce 100644
--- a/sc/source/filter/inc/tokstack.hxx
+++ b/sc/source/filter/inc/tokstack.hxx
@@ -207,7 +207,7 @@ class TokenPool
         const TokenId				Store( const DefTokenId eId, const String& rName );
                                         // 4 externals (e.g. AddIns, Makros...)
         const TokenId				StoreNlf( const ScSingleRefData& rTr );
-        const TokenId				StoreMatrix( SCSIZE nC, SCSIZE nR );
+        const TokenId               StoreMatrix();
         const TokenId               StoreExtName( sal_uInt16 nFileId, const String& rName );
         const TokenId               StoreExtRef( sal_uInt16 nFileId, const String& rTabName, const ScSingleRefData& rRef );
         const TokenId               StoreExtRef( sal_uInt16 nFileId, const String& rTabName, const ScComplexRefData& rRef );
diff --git a/sc/source/ui/inc/gridwin.hxx b/sc/source/ui/inc/gridwin.hxx
index 04e2ce3..fed2c6b 100644
--- a/sc/source/ui/inc/gridwin.hxx
+++ b/sc/source/ui/inc/gridwin.hxx
@@ -274,7 +274,7 @@ private:
 
     void			PasteSelection( const Point& rPosPixel );
 
-    void			SelectForContextMenu( const Point& rPosPixel );
+    void			SelectForContextMenu( const Point& rPosPixel, SCsCOL nCellX, SCsROW nCellY );
 
     void            GetSelectionRects( ::std::vector< Rectangle >& rPixelRects );
 
diff --git a/sc/source/ui/inc/hdrcont.hxx b/sc/source/ui/inc/hdrcont.hxx
index 1bbad4c..a81a3e6 100644
--- a/sc/source/ui/inc/hdrcont.hxx
+++ b/sc/source/ui/inc/hdrcont.hxx
@@ -77,7 +77,7 @@ private:
 
     long			GetScrPos( SCCOLROW nEntryNo );
     SCCOLROW		GetMousePos( const MouseEvent& rMEvt, BOOL& rBorder );
-
+    bool            IsSelectionAllowed(SCCOLROW nPos) const;
     void			ShowDragHelp();
 
     void			DoPaint( SCCOLROW nStart, SCCOLROW nEnd );
diff --git a/sc/source/ui/view/gridwin.cxx b/sc/source/ui/view/gridwin.cxx
index 26111b1..fca812e 100644
--- a/sc/source/ui/view/gridwin.cxx
+++ b/sc/source/ui/view/gridwin.cxx
@@ -2693,9 +2693,32 @@ void __EXPORT ScGridWindow::Command( const CommandEvent& rCEvt )
 
         if ( bMouse )
         {
+            SCsCOL nCellX = -1;
+            SCsROW nCellY = -1;
+            pViewData->GetPosFromPixel(aPosPixel.X(), aPosPixel.Y(), eWhich, nCellX, nCellY);
+            ScDocument* pDoc = pViewData->GetDocument();
+            SCTAB nTab = pViewData->GetTabNo();
+            const ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+            bool bSelectAllowed = true;
+            if ( pProtect && pProtect->isProtected() )
+            {
+                // This sheet is protected.  Check if a context menu is allowed on this cell.
+                bool bCellProtected = pDoc->HasAttrib(nCellX, nCellY, nTab, nCellX, nCellY, nTab, HASATTR_PROTECTED);
+                bool bSelProtected   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+                bool bSelUnprotected = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+                if (bCellProtected)
+                    bSelectAllowed = bSelProtected;
+                else
+                    bSelectAllowed = bSelUnprotected;
+            }
+            if (!bSelectAllowed)
+                // Selecting this cell is not allowed, neither is context menu.
+                return;
+
             //	#i18735# First select the item under the mouse pointer.
             //	This can change the selection, and the view state (edit mode, etc).
-            SelectForContextMenu( aPosPixel );
+            SelectForContextMenu( aPosPixel, nCellX, nCellY );
         }
 
         BOOL bDone = FALSE;
@@ -2790,15 +2813,12 @@ void __EXPORT ScGridWindow::Command( const CommandEvent& rCEvt )
     }
 }
 
-void ScGridWindow::SelectForContextMenu( const Point& rPosPixel )
+void ScGridWindow::SelectForContextMenu( const Point& rPosPixel, SCsCOL nCellX, SCsROW nCellY )
 {
     //  #i18735# if the click was outside of the current selection,
     //  the cursor is moved or an object at the click position selected.
     //  (see SwEditWin::SelectMenuPosition in Writer)
 
-    SCsCOL nCellX;
-    SCsROW nCellY;
-    pViewData->GetPosFromPixel( rPosPixel.X(), rPosPixel.Y(), eWhich, nCellX, nCellY );
     ScTabView* pView = pViewData->GetView();
     ScDrawView* pDrawView = pView->GetScDrawView();
 
diff --git a/sc/source/ui/view/hdrcont.cxx b/sc/source/ui/view/hdrcont.cxx
index 290924e..ad14aed 100644
--- a/sc/source/ui/view/hdrcont.cxx
+++ b/sc/source/ui/view/hdrcont.cxx
@@ -44,6 +44,7 @@
 #include "scmod.hxx"		// Optionen
 #include "inputopt.hxx"		// Optionen
 #include "gridmerg.hxx"
+#include "document.hxx"
 
 // -----------------------------------------------------------------------
 
@@ -652,6 +653,39 @@ SCCOLROW ScHeaderControl::GetMousePos( const MouseEvent& rMEvt, BOOL& rBorder )
     return nHitNo;
 }
 
+bool ScHeaderControl::IsSelectionAllowed(SCCOLROW nPos) const
+{
+    ScTabViewShell* pViewSh = dynamic_cast<ScTabViewShell*>(SfxViewShell::Current());
+    if (!pViewSh)
+        return false;
+
+    ScViewData* pViewData = pViewSh->GetViewData();
+    USHORT nTab = pViewData->GetTabNo();
+    ScDocument* pDoc = pViewData->GetDocument();
+    const ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+    bool bSelectAllowed = true;
+    if ( pProtect && pProtect->isProtected() )
+    {
+        // This sheet is protected.  Check if a context menu is allowed on this cell.
+        bool bCellsProtected = false;
+        if (bVertical)
+            // row header
+            bCellsProtected = pDoc->HasAttrib(0, nPos, nTab, MAXCOL, nPos, nTab, HASATTR_PROTECTED);
+        else
+            // column header
+            bCellsProtected = pDoc->HasAttrib(nPos, 0, nTab, nPos, MAXROW, nTab, HASATTR_PROTECTED);
+
+        bool bSelProtected   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+        bool bSelUnprotected = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+        if (bCellsProtected)
+            bSelectAllowed = bSelProtected;
+        else
+            bSelectAllowed = bSelUnprotected;
+    }
+    return bSelectAllowed;
+}
+
 void __EXPORT ScHeaderControl::MouseButtonDown( const MouseEvent& rMEvt )
 {
     if (IsDisabled())
@@ -662,6 +696,8 @@ void __EXPORT ScHeaderControl::MouseButtonDown( const MouseEvent& rMEvt )
 
     BOOL bFound;
     SCCOLROW nHitNo = GetMousePos( rMEvt, bFound );
+    if (!IsSelectionAllowed(nHitNo))
+        return;
 
     if ( bFound && rMEvt.IsLeft() && ResizeAllowed() )
     {
@@ -845,8 +881,11 @@ void __EXPORT ScHeaderControl::Command( const CommandEvent& rCEvt )
                 MouseEvent aMEvt( rCEvt.GetMousePosPixel() );
                 BOOL bBorder;
                 SCCOLROW nPos = GetMousePos( aMEvt, bBorder );
-                USHORT nTab = pViewData->GetTabNo();
+                if (!IsSelectionAllowed(nPos))
+                    // Selecting this cell is not allowed, neither is context menu.
+                    return;
 
+                SCTAB nTab = pViewData->GetTabNo();
                 ScRange aNewRange;
                 if ( bVertical )
                     aNewRange = ScRange( 0, sal::static_int_cast<SCROW>(nPos), nTab,
-- 
1.7.0.1

