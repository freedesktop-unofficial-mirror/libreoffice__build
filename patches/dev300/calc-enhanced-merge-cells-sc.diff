diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index 123a716..fde95e5 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -67,6 +67,7 @@
 #include "attrib.hxx"
 #include "autoform.hxx"
 #include "cell.hxx"
+#include "cellmergeoption.hxx"
 #include "detdata.hxx"
 #include "detfunc.hxx"
 #include "docpool.hxx"
@@ -101,6 +102,7 @@
 #include "tabprotection.hxx"
 
 #include <memory>
+#include <set>
 
 using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
@@ -3974,86 +3976,110 @@ BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir e
 
 //------------------------------------------------------------------------
 
-BOOL ScDocFunc::MergeCells( const ScRange& rRange, BOOL bContents, BOOL bRecord, BOOL bApi )
+BOOL ScDocFunc::MergeCells( const ScCellMergeOption& rOption, BOOL bContents, BOOL bRecord, BOOL bApi )
 {
+    using ::std::set;
+
 	ScDocShellModificator aModificator( rDocShell );
 
-	ScDocument* pDoc = rDocShell.GetDocument();
-	SCCOL nStartCol = rRange.aStart.Col();
-	SCROW nStartRow = rRange.aStart.Row();
-	SCCOL nEndCol = rRange.aEnd.Col();
-	SCROW nEndRow = rRange.aEnd.Row();
-	SCTAB nTab = rRange.aStart.Tab();
+    SCCOL nStartCol = rOption.mnStartCol;
+    SCROW nStartRow = rOption.mnStartRow;
+    SCCOL nEndCol = rOption.mnEndCol;
+    SCROW nEndRow = rOption.mnEndRow;
+    if (nStartCol == nEndCol && nStartRow == nEndRow || rOption.maTabs.empty())
+    {
+        // Nothing to do.  Bail out quick.
+        return TRUE;
+    }
+
+    ScDocument* pDoc = rDocShell.GetDocument();
+    set<SCTAB>::const_iterator itrBeg = rOption.maTabs.begin(), itrEnd = rOption.maTabs.end();
+    SCTAB nTab1 = *itrBeg, nTab2 = *rOption.maTabs.rbegin();
 
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
 
-	ScEditableTester aTester( pDoc, nTab, nStartCol, nStartRow, nEndCol, nEndRow );
-	if (!aTester.IsEditable())
-	{
-		if (!bApi)
-			rDocShell.ErrorMessage(aTester.GetMessageId());
-		return FALSE;
-	}
+    for (set<SCTAB>::const_iterator itr = itrBeg; itr != itrEnd; ++itr)
+    {
+        ScEditableTester aTester( pDoc, *itr, nStartCol, nStartRow, nEndCol, nEndRow );
+        if (!aTester.IsEditable())
+        {
+            if (!bApi)
+                rDocShell.ErrorMessage(aTester.GetMessageId());
+            return FALSE;
+        }
 
-	if ( nStartCol == nEndCol && nStartRow == nEndRow )
-	{
-		// nichts zu tun
-		return TRUE;
-	}
+        if ( pDoc->HasAttrib( nStartCol, nStartRow, *itr, nEndCol, nEndRow, *itr,
+                                HASATTR_MERGED | HASATTR_OVERLAPPED ) )
+        {
+            // "Zusammenfassen nicht verschachteln !"
+            if (!bApi)
+                rDocShell.ErrorMessage(STR_MSSG_MERGECELLS_0);
+            return FALSE;
+        }
+    }
 
-	if ( pDoc->HasAttrib( nStartCol, nStartRow, nTab, nEndCol, nEndRow, nTab,
-							HASATTR_MERGED | HASATTR_OVERLAPPED ) )
-	{
-		// "Zusammenfassen nicht verschachteln !"
-		if (!bApi)
-			rDocShell.ErrorMessage(STR_MSSG_MERGECELLS_0);
-		return FALSE;
-	}
+    ScDocument* pUndoDoc = NULL;
+    bool bNeedContentsUndo = false;
+    for (set<SCTAB>::const_iterator itr = itrBeg; itr != itrEnd; ++itr)
+    {
+        SCTAB nTab = *itr;
+        bool bNeedContents = bContents &&
+                ( !pDoc->IsBlockEmpty( nTab, nStartCol,nStartRow+1, nStartCol,nEndRow, true ) ||
+                  !pDoc->IsBlockEmpty( nTab, nStartCol+1,nStartRow, nEndCol,nEndRow, true ) );
+    
+        if (bRecord)
+        {
+            // test if the range contains other notes which also implies that we need an undo document
+            bool bHasNotes = false;
+            for( ScAddress aPos( nStartCol, nStartRow, nTab ); !bHasNotes && (aPos.Col() <= nEndCol); aPos.IncCol() )
+                for( aPos.SetRow( nStartRow ); !bHasNotes && (aPos.Row() <= nEndRow); aPos.IncRow() )
+                    bHasNotes = ((aPos.Col() != nStartCol) || (aPos.Row() != nStartRow)) && (pDoc->GetNote( aPos ) != 0);
 
-	BOOL bNeedContents = bContents &&
-			( !pDoc->IsBlockEmpty( nTab, nStartCol,nStartRow+1, nStartCol,nEndRow, true ) ||
-			  !pDoc->IsBlockEmpty( nTab, nStartCol+1,nStartRow, nEndCol,nEndRow, true ) );
+            if (bNeedContents || bHasNotes || rOption.mbCenter)
+            {
+                if (!pUndoDoc)
+                {
+                    pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
+                    pUndoDoc->InitUndo(pDoc, nTab1, nTab2);
+                }
+                // note captions are collected by drawing undo
+                pDoc->CopyToDocument( nStartCol, nStartRow, nTab, nEndCol, nEndRow, nTab,
+                                      IDF_ALL|IDF_NOCAPTIONS, FALSE, pUndoDoc );
+            }
+            if( bHasNotes )
+                pDoc->BeginDrawUndo();
+        }
 
-    ScDocument* pUndoDoc = 0;
-	if (bRecord)
-	{
-        // test if the range contains other notes which also implies that we need an undo document
-        bool bHasNotes = false;
-        for( ScAddress aPos( nStartCol, nStartRow, nTab ); !bHasNotes && (aPos.Col() <= nEndCol); aPos.IncCol() )
-            for( aPos.SetRow( nStartRow ); !bHasNotes && (aPos.Row() <= nEndRow); aPos.IncRow() )
-                bHasNotes = ((aPos.Col() != nStartCol) || (aPos.Row() != nStartRow)) && (pDoc->GetNote( aPos ) != 0);
+        if (bNeedContents)
+            pDoc->DoMergeContents( nTab, nStartCol,nStartRow, nEndCol,nEndRow );
+        pDoc->DoMerge( nTab, nStartCol,nStartRow, nEndCol,nEndRow );
+	
+        if (rOption.mbCenter)
+        {
+            pDoc->ApplyAttr( nStartCol, nStartRow, nTab, SvxHorJustifyItem( SVX_HOR_JUSTIFY_CENTER, ATTR_HOR_JUSTIFY ) );
+            pDoc->ApplyAttr( nStartCol, nStartRow, nTab, SvxVerJustifyItem( SVX_VER_JUSTIFY_CENTER, ATTR_VER_JUSTIFY ) );
+        }
 
-		if (bNeedContents || bHasNotes)
-		{
-			pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
-			pUndoDoc->InitUndo( pDoc, nTab, nTab );
-            // note captions are collected by drawing undo
-			pDoc->CopyToDocument( nStartCol, nStartRow, nTab, nEndCol, nEndRow, nTab,
-                                    IDF_ALL|IDF_NOCAPTIONS, FALSE, pUndoDoc );
-		}
-        if( bHasNotes )
-            pDoc->BeginDrawUndo();
-	}
+        if ( !AdjustRowHeight( ScRange( 0,nStartRow,nTab, MAXCOL,nEndRow,nTab ) ) )
+            rDocShell.PostPaint( nStartCol, nStartRow, nTab,
+                                 nEndCol, nEndRow, nTab, PAINT_GRID );
+        if (bNeedContents || rOption.mbCenter)
+        {    
+            ScRange aRange(nStartCol, nStartRow, nTab, nEndCol, nEndRow, nTab);
+            pDoc->SetDirty(aRange);
+        }
 
-	if (bNeedContents)
-		pDoc->DoMergeContents( nTab, nStartCol,nStartRow, nEndCol,nEndRow );
-	pDoc->DoMerge( nTab, nStartCol,nStartRow, nEndCol,nEndRow );
+        bNeedContentsUndo != bNeedContents;
+    }
 
-    if( bRecord )
+    if (pUndoDoc)
     {
-        SdrUndoGroup* pDrawUndo = pDoc->GetDrawLayer() ? pDoc->GetDrawLayer()->GetCalcUndo() : 0;
+        SdrUndoGroup* pDrawUndo = pDoc->GetDrawLayer() ? pDoc->GetDrawLayer()->GetCalcUndo() : NULL;
         rDocShell.GetUndoManager()->AddUndoAction(
-            new ScUndoMerge( &rDocShell,
-                            nStartCol, nStartRow, nTab,
-                            nEndCol, nEndRow, nTab, bNeedContents, pUndoDoc, pDrawUndo ) );
+            new ScUndoMerge(&rDocShell, rOption, bNeedContentsUndo, pUndoDoc, pDrawUndo) );
     }
 
-	if ( !AdjustRowHeight( ScRange( 0,nStartRow,nTab, MAXCOL,nEndRow,nTab ) ) )
-		rDocShell.PostPaint( nStartCol, nStartRow, nTab,
-											nEndCol, nEndRow, nTab, PAINT_GRID );
-	if (bNeedContents)
-		pDoc->SetDirty( rRange );
 	aModificator.SetDocumentModified();
 
 	SfxBindings* pBindings = rDocShell.GetViewBindings();
@@ -4069,49 +4095,81 @@ BOOL ScDocFunc::MergeCells( const ScRange& rRange, BOOL bContents, BOOL bRecord,
 
 BOOL ScDocFunc::UnmergeCells( const ScRange& rRange, BOOL bRecord, BOOL bApi )
 {
-	ScDocShellModificator aModificator( rDocShell );
+    ScCellMergeOption aOption(rRange.aStart.Col(), rRange.aStart.Row(), rRange.aEnd.Col(), rRange.aEnd.Row());
+    SCTAB nTab1 = rRange.aStart.Tab(), nTab2 = rRange.aEnd.Tab();
+    for (SCTAB i = nTab1; i <= nTab2; ++i)
+        aOption.maTabs.insert(i);
 
+    return UnmergeCells(aOption, bRecord, bApi);
+}
+
+bool ScDocFunc::UnmergeCells( const ScCellMergeOption& rOption, BOOL bRecord, BOOL bApi )
+{
+    using ::std::set;
+
+    if (rOption.maTabs.empty())
+        // Nothing to unmerge.
+        return true;
+
+	ScDocShellModificator aModificator( rDocShell );
 	ScDocument* pDoc = rDocShell.GetDocument();
-	SCTAB nTab = rRange.aStart.Tab();
 
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
 
-	if ( pDoc->HasAttrib( rRange, HASATTR_MERGED ) )
-	{
-		ScRange aExtended = rRange;
-		pDoc->ExtendMerge( aExtended );
-		ScRange aRefresh = aExtended;
-		pDoc->ExtendOverlapped( aRefresh );
+    ScDocument* pUndoDoc = NULL;
+    bool bBeep = false;
+    for (set<SCTAB>::const_iterator itr = rOption.maTabs.begin(), itrEnd = rOption.maTabs.end();
+          itr != itrEnd; ++itr)
+    {
+        SCTAB nTab = *itr;
+        ScRange aRange = rOption.getSingleRange(nTab);
+        if ( !pDoc->HasAttrib(aRange, HASATTR_MERGED) )
+        {
+            bBeep = true;
+            continue;
+        }
 
-		if (bRecord)
-		{
-			ScDocument* pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
-			pUndoDoc->InitUndo( pDoc, nTab, nTab );
-			pDoc->CopyToDocument( aExtended, IDF_ATTRIB, FALSE, pUndoDoc );
-			rDocShell.GetUndoManager()->AddUndoAction(
-				new ScUndoRemoveMerge( &rDocShell, rRange, pUndoDoc ) );
-		}
+        ScRange aExtended = aRange;
+        pDoc->ExtendMerge(aExtended);
+        ScRange aRefresh = aExtended;
+        pDoc->ExtendOverlapped(aRefresh);
 
-		const SfxPoolItem& rDefAttr = pDoc->GetPool()->GetDefaultItem( ATTR_MERGE );
-		ScPatternAttr aPattern( pDoc->GetPool() );
-		aPattern.GetItemSet().Put( rDefAttr );
-		pDoc->ApplyPatternAreaTab( rRange.aStart.Col(), rRange.aStart.Row(),
-									rRange.aEnd.Col(), rRange.aEnd.Row(), nTab,
-									aPattern );
+        if (bRecord)
+        {
+            if (!pUndoDoc)
+            {
+                pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
+                pUndoDoc->InitUndo(pDoc, *rOption.maTabs.begin(), *rOption.maTabs.rbegin());
+            }
+            pDoc->CopyToDocument(aExtended, IDF_ATTRIB, FALSE, pUndoDoc);
+        }
 
-		pDoc->RemoveFlagsTab( aExtended.aStart.Col(), aExtended.aStart.Row(),
-								aExtended.aEnd.Col(), aExtended.aEnd.Row(), nTab,
-								SC_MF_HOR | SC_MF_VER );
+        const SfxPoolItem& rDefAttr = pDoc->GetPool()->GetDefaultItem( ATTR_MERGE );
+        ScPatternAttr aPattern( pDoc->GetPool() );
+        aPattern.GetItemSet().Put( rDefAttr );
+        pDoc->ApplyPatternAreaTab( aRange.aStart.Col(), aRange.aStart.Row(),
+                                   aRange.aEnd.Col(), aRange.aEnd.Row(), nTab,
+                                   aPattern );
 
-		pDoc->ExtendMerge( aRefresh, TRUE, FALSE );
+        pDoc->RemoveFlagsTab( aExtended.aStart.Col(), aExtended.aStart.Row(),
+                              aExtended.aEnd.Col(), aExtended.aEnd.Row(), nTab,
+                              SC_MF_HOR | SC_MF_VER );
 
-		if ( !AdjustRowHeight( aExtended ) )
-			rDocShell.PostPaint( aExtended, PAINT_GRID );
-		aModificator.SetDocumentModified();
-	}
-	else if (!bApi)
-		Sound::Beep();		//! FALSE zurueck???
+        pDoc->ExtendMerge( aRefresh, TRUE, FALSE );
+
+        if ( !AdjustRowHeight( aExtended ) )
+            rDocShell.PostPaint( aExtended, PAINT_GRID );
+    }
+    if (bBeep && !bApi)
+        Sound::Beep();
+
+    if (bRecord)
+    {
+        rDocShell.GetUndoManager()->AddUndoAction(
+            new ScUndoRemoveMerge( &rDocShell, rOption, pUndoDoc ) );
+    }
+    aModificator.SetDocumentModified();
 
 	return TRUE;
 }
diff --git sc/source/ui/inc/cellmergeoption.hxx sc/source/ui/inc/cellmergeoption.hxx
new file mode 100644
index 0000000..2e2dff2
--- /dev/null
+++ sc/source/ui/inc/cellmergeoption.hxx
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: docfunc.hxx,v $
+ * $Revision: 1.18.30.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_CELLMERGEOPTION_HXX
+#define SC_CELLMERGEOPTION_HXX
+
+#include "address.hxx"
+
+#include <set>
+
+class ScRange;
+
+struct ScCellMergeOption
+{
+    ::std::set<SCTAB> maTabs;
+    SCCOL mnStartCol;
+    SCROW mnStartRow;
+    SCCOL mnEndCol;
+    SCROW mnEndRow;
+    bool mbCenter;
+
+    explicit ScCellMergeOption();
+    explicit ScCellMergeOption(SCCOL nStartCol, SCROW nStartRow, 
+                               SCCOL nEndCol, SCROW nEndRow, 
+                               bool bCenter = false);
+    explicit ScCellMergeOption(const ScCellMergeOption& r);
+
+    ScRange getSingleRange(SCTAB nTab) const;
+    ScRange getFirstSingleRange() const;
+};
+
+
+#endif
diff --git sc/source/ui/inc/docfunc.hxx sc/source/ui/inc/docfunc.hxx
index 8490bab..9976230 100644
--- sc/source/ui/inc/docfunc.hxx
+++ sc/source/ui/inc/docfunc.hxx
@@ -49,6 +49,7 @@ class ScBaseCell;
 class ScTokenArray;
 struct ScTabOpParam;
 class ScTableProtection;
+struct ScCellMergeOption;
 
 // ---------------------------------------------------------------------------
 
@@ -172,9 +173,10 @@ public:
 
 	BOOL			ResizeMatrix( const ScRange& rOldRange, const ScAddress& rNewEnd, BOOL bApi );
 
-	BOOL			MergeCells( const ScRange& rRange, BOOL bContents,
+	BOOL			MergeCells( const ScCellMergeOption& rOption, BOOL bContents,
 								BOOL bRecord, BOOL bApi );
-	BOOL			UnmergeCells( const ScRange& rRange, BOOL bRecord, BOOL bApi );
+ 	BOOL			UnmergeCells( const ScRange& rRange, BOOL bRecord, BOOL bApi );
+	bool			UnmergeCells( const ScCellMergeOption& rOption, BOOL bRecord, BOOL bApi );
 
     BOOL            SetNewRangeNames( ScRangeName* pNewRanges, BOOL bApi );     // takes ownership of pNewRanges
 	BOOL			ModifyRangeNames( const ScRangeName& rNewRanges, BOOL bApi );
diff --git sc/source/ui/inc/undoblk.hxx sc/source/ui/inc/undoblk.hxx
index 31932fd..2320502 100644
--- sc/source/ui/inc/undoblk.hxx
+++ sc/source/ui/inc/undoblk.hxx
@@ -34,6 +34,7 @@
 #include "markdata.hxx"
 #include "viewutil.hxx"
 #include "spellparam.hxx"
+#include "cellmergeoption.hxx"
 
 #include "cell.hxx"
 
@@ -454,10 +455,8 @@ class ScUndoMerge: public ScSimpleUndo
 {
 public:
 					TYPEINFO();
-					ScUndoMerge( ScDocShell* pNewDocShell,
-								 SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
-								 SCCOL nEndX,   SCROW nEndY,   SCTAB nEndZ,
-                                 bool bMergeContents, ScDocument* pUndoDoc, SdrUndoAction* pDrawUndo );
+                    ScUndoMerge( ScDocShell* pNewDocShell, const ScCellMergeOption& rOption,
+                                 bool bMergeContents, ScDocument* pUndoDoc, SdrUndoAction* pDrawUndo);
 	virtual 		~ScUndoMerge();
 
 	virtual void	Undo();
@@ -468,7 +467,7 @@ public:
 	virtual String	GetComment() const;
 
 private:
-    ScRange         maRange;
+    ScCellMergeOption maOption;
     bool            mbMergeContents;        // Merge contents in Redo().
     ScDocument*		mpUndoDoc;              // wenn Daten zusammengefasst
     SdrUndoAction*  mpDrawUndo;
@@ -920,7 +919,7 @@ class ScUndoRemoveMerge: public ScBlockUndo
 public:
 					TYPEINFO();
 					ScUndoRemoveMerge( ScDocShell* pNewDocShell,
-									   const ScRange& rArea,
+									   const ScCellMergeOption& rOption,
 									   ScDocument* pNewUndoDoc );
 	virtual 		~ScUndoRemoveMerge();
 
@@ -932,6 +931,9 @@ public:
 	virtual String	GetComment() const;
 
 private:
+    void            SetCurTab();
+
+    ScCellMergeOption maOption;
 	ScDocument*		pUndoDoc;
 };
 
diff --git sc/source/ui/inc/viewfunc.hxx sc/source/ui/inc/viewfunc.hxx
index 1f5102e..051a705 100644
--- sc/source/ui/inc/viewfunc.hxx
+++ sc/source/ui/inc/viewfunc.hxx
@@ -242,7 +242,7 @@ public:
 	BOOL			TestMergeCells();
 	BOOL			TestRemoveMerge();
 
-	BOOL			MergeCells( BOOL bApi, BOOL& rDoContents, BOOL bRecord = TRUE );
+	BOOL			MergeCells( BOOL bApi, BOOL& rDoContents, BOOL bRecord = TRUE, BOOL bCenter = FALSE );
 	BOOL			RemoveMerge( BOOL bRecord = TRUE );
 
 	void			FillSimple( FillDir eDir, BOOL bRecord = TRUE );
diff --git sc/source/ui/undo/undoblk.cxx sc/source/ui/undo/undoblk.cxx
index 5b3e219..fe2c7bc 100644
--- sc/source/ui/undo/undoblk.cxx
+++ sc/source/ui/undo/undoblk.cxx
@@ -66,6 +66,7 @@
 #include "undoolk.hxx"
 #include "sc.hrc"
 
+#include <set>
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -2066,8 +2067,9 @@ BOOL __EXPORT ScUndoRemoveBreaks::CanRepeat(SfxRepeatTarget& rTarget) const
 //
 
 ScUndoRemoveMerge::ScUndoRemoveMerge( ScDocShell* pNewDocShell,
-									   const ScRange& rArea, ScDocument* pNewUndoDoc ) :
-	ScBlockUndo( pNewDocShell, rArea, SC_UNDO_SIMPLE ),
+                                      const ScCellMergeOption& rOption, ScDocument* pNewUndoDoc ) :
+	ScBlockUndo( pNewDocShell, rOption.getFirstSingleRange(), SC_UNDO_SIMPLE ),
+    maOption(rOption),
 	pUndoDoc( pNewUndoDoc )
 {
 }
@@ -2084,66 +2086,78 @@ String __EXPORT ScUndoRemoveMerge::GetComment() const
 
 void __EXPORT ScUndoRemoveMerge::Undo()
 {
-	BeginUndo();
-
-	ScDocument* pDoc = pDocShell->GetDocument();
+    using ::std::set;
 
-	ScRange aExtended = aBlockRange;
-	pUndoDoc->ExtendMerge( aExtended );
+    SetCurTab();
+    BeginUndo();
 
-	pDoc->DeleteAreaTab( aExtended, IDF_ATTRIB );
-	pUndoDoc->CopyToDocument( aExtended, IDF_ATTRIB, FALSE, pDoc );
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
 
-	BOOL bDidPaint = FALSE;
-	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
-	if ( pViewShell )
-	{
-		pViewShell->SetTabNo( aExtended.aStart.Tab() );
-		bDidPaint = pViewShell->AdjustRowHeight( aExtended.aStart.Row(), aExtended.aEnd.Row() );
-	}
-	if (!bDidPaint)
-		ScUndoUtil::PaintMore( pDocShell, aExtended );
+	ScDocument* pDoc = pDocShell->GetDocument();
+    for (set<SCTAB>::const_iterator itr = maOption.maTabs.begin(), itrEnd = maOption.maTabs.end();
+          itr != itrEnd; ++itr)
+    {
+        // There is no need to extend merge area because it's already been extended.
+        ScRange aRange = maOption.getSingleRange(*itr);    
+        pDoc->DeleteAreaTab(aRange, IDF_ATTRIB);
+        pUndoDoc->CopyToDocument(aRange, IDF_ATTRIB, FALSE, pDoc);
+    
+        bool bDidPaint = false;
+        if ( pViewShell )
+        {
+            pViewShell->SetTabNo(*itr);
+            bDidPaint = pViewShell->AdjustRowHeight(maOption.mnStartRow, maOption.mnEndRow);
+        }
+        if (!bDidPaint)
+            ScUndoUtil::PaintMore(pDocShell, aRange);
+    }
 
 	EndUndo();
 }
 
 void __EXPORT ScUndoRemoveMerge::Redo()
 {
+    using ::std::set;
+
+    SetCurTab();
 	BeginRedo();
 
-	SCTAB nTab = aBlockRange.aStart.Tab();
 	ScDocument* pDoc = pDocShell->GetDocument();
-	ScRange aExtended = aBlockRange;
-	pDoc->ExtendMerge( aExtended );
-	ScRange aRefresh = aExtended;
-	pDoc->ExtendOverlapped( aRefresh );
-
-	//	ausfuehren
-
-	const SfxPoolItem& rDefAttr = pDoc->GetPool()->GetDefaultItem( ATTR_MERGE );
-	ScPatternAttr aPattern( pDoc->GetPool() );
-	aPattern.GetItemSet().Put( rDefAttr );
-	pDoc->ApplyPatternAreaTab( aBlockRange.aStart.Col(), aBlockRange.aStart.Row(),
-								aBlockRange.aEnd.Col(), aBlockRange.aEnd.Row(), nTab,
-								aPattern );
-
-	pDoc->RemoveFlagsTab( aExtended.aStart.Col(), aExtended.aStart.Row(),
-							aExtended.aEnd.Col(), aExtended.aEnd.Row(), nTab,
-							SC_MF_HOR | SC_MF_VER );
-
-	pDoc->ExtendMerge( aRefresh, TRUE, FALSE );
-
-	//	Paint
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
 
-	BOOL bDidPaint = FALSE;
-	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
-	if ( pViewShell )
-	{
-		pViewShell->SetTabNo( aExtended.aStart.Tab() );
-		bDidPaint = pViewShell->AdjustRowHeight( aExtended.aStart.Row(), aExtended.aEnd.Row() );
-	}
-	if (!bDidPaint)
-		ScUndoUtil::PaintMore( pDocShell, aExtended );
+    for (set<SCTAB>::const_iterator itr = maOption.maTabs.begin(), itrEnd = maOption.maTabs.end();
+          itr != itrEnd; ++itr)
+    {
+        SCTAB nTab = *itr;
+        // There is no need to extend merge area because it's already been extended.
+        ScRange aRange = maOption.getSingleRange(nTab);
+    
+        //	ausfuehren
+    
+        const SfxPoolItem& rDefAttr = pDoc->GetPool()->GetDefaultItem( ATTR_MERGE );
+        ScPatternAttr aPattern( pDoc->GetPool() );
+        aPattern.GetItemSet().Put( rDefAttr );
+        pDoc->ApplyPatternAreaTab( maOption.mnStartCol, maOption.mnStartRow,
+                                   maOption.mnEndCol, maOption.mnEndRow, nTab,
+                                   aPattern );
+    
+        pDoc->RemoveFlagsTab( maOption.mnStartCol, maOption.mnStartRow,
+                              maOption.mnEndCol, maOption.mnEndRow, nTab,
+                              SC_MF_HOR | SC_MF_VER );
+    
+        pDoc->ExtendMerge(aRange, TRUE, FALSE);
+
+        //	Paint
+
+        BOOL bDidPaint = FALSE;
+        if ( pViewShell )
+        {
+            pViewShell->SetTabNo(nTab);
+            bDidPaint = pViewShell->AdjustRowHeight(maOption.mnStartRow, maOption.mnEndRow);
+        }
+        if (!bDidPaint)
+            ScUndoUtil::PaintMore(pDocShell, aRange);
+    }
 
 	EndRedo();
 }
@@ -2159,6 +2173,13 @@ BOOL __EXPORT ScUndoRemoveMerge::CanRepeat(SfxRepeatTarget& rTarget) const
 	return (rTarget.ISA(ScTabViewTarget));
 }
 
+void ScUndoRemoveMerge::SetCurTab()
+{
+    SCTAB nCurTab = pDocShell->GetCurTab();
+    aBlockRange.aStart.SetTab(nCurTab);
+    aBlockRange.aEnd.SetTab(nCurTab);
+}
+
 // -----------------------------------------------------------------------
 //
 //		nur Umrandung setzen, per ScRangeList (StarOne)
diff --git sc/source/ui/undo/undoblk3.cxx sc/source/ui/undo/undoblk3.cxx
index 5521813..f3f006c 100644
--- sc/source/ui/undo/undoblk3.cxx
+++ sc/source/ui/undo/undoblk3.cxx
@@ -34,6 +34,7 @@
 // INCLUDE -------------------------------------------------------------------
 
 #include "scitems.hxx"
+#include <svx/algitem.hxx>
 #include <svx/boxitem.hxx>
 #include <svx/srchitem.hxx>
 #include <svx/linkmgr.hxx>
@@ -814,14 +815,12 @@ BOOL __EXPORT ScUndoAutoFill::CanRepeat(SfxRepeatTarget& rTarget) const
 
 //----------------------------------------------------------------------------
 
-ScUndoMerge::ScUndoMerge( ScDocShell* pNewDocShell,
-							SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
-							SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
-                            bool bMergeContents, ScDocument* pUndoDoc, SdrUndoAction* pDrawUndo )
+ScUndoMerge::ScUndoMerge( ScDocShell* pNewDocShell, const ScCellMergeOption& rOption,
+                          bool bMergeContents, ScDocument* pUndoDoc, SdrUndoAction* pDrawUndo )
 		//
 	:	ScSimpleUndo( pNewDocShell ),
 		//
-		maRange( nStartX, nStartY, nStartZ, nEndX, nEndY, nEndZ ),
+        maOption(rOption),
         mbMergeContents( bMergeContents ),
         mpUndoDoc( pUndoDoc ),
         mpDrawUndo( pDrawUndo )
@@ -850,51 +849,77 @@ String ScUndoMerge::GetComment() const
 
 void ScUndoMerge::DoChange( bool bUndo ) const
 {
-	ScDocument* pDoc = pDocShell->GetDocument();
+    using ::std::set;
 
-	ScUndoUtil::MarkSimpleBlock( pDocShell, maRange );
+    if (maOption.maTabs.empty())
+        // Nothing to do.
+        return;
 
-	if (bUndo)
-        // remove merge (contents are copied back below from undo document)
-		pDoc->RemoveMerge( maRange.aStart.Col(), maRange.aStart.Row(), maRange.aStart.Tab() );
-	else
-        // repeat merge, but do not remove note captions (will be done by drawing redo below)
-/*!*/	pDoc->DoMerge( maRange.aStart.Tab(),
-					   maRange.aStart.Col(), maRange.aStart.Row(),
-                       maRange.aEnd.Col(),   maRange.aEnd.Row(), false );
+    ScDocument* pDoc = pDocShell->GetDocument();
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
 
-    // undo -> copy back deleted contents
-	if (bUndo && mpUndoDoc)
-    {
-        pDoc->DeleteAreaTab( maRange, IDF_CONTENTS|IDF_NOCAPTIONS );
-        mpUndoDoc->CopyToDocument( maRange, IDF_ALL|IDF_NOCAPTIONS, FALSE, pDoc );
-    }
+    ScRange aCurRange = maOption.getSingleRange(pDocShell->GetCurTab());                          
+    ScUndoUtil::MarkSimpleBlock(pDocShell, aCurRange);                                            
+                                                                                                  
+    for (set<SCTAB>::const_iterator itr = maOption.maTabs.begin(), itrEnd = maOption.maTabs.end();
+          itr != itrEnd; ++itr)                                                                   
+    {                                                                                             
+        SCTAB nTab = *itr;                                                                        
+        ScRange aRange = maOption.getSingleRange(nTab);                                           
 
-    // redo -> merge contents again
-    else if (!bUndo && mbMergeContents)
-    {
-/*!*/   pDoc->DoMergeContents( maRange.aStart.Tab(),
-							   maRange.aStart.Col(), maRange.aStart.Row(),
-							   maRange.aEnd.Col(),   maRange.aEnd.Row()   );
+        if (bUndo)
+            // remove merge (contents are copied back below from undo document)
+            pDoc->RemoveMerge( aRange.aStart.Col(), aRange.aStart.Row(), aRange.aStart.Tab() );
+        else
+        {    
+            // repeat merge, but do not remove note captions (will be done by drawing redo below)
+            pDoc->DoMerge( aRange.aStart.Tab(),
+                           aRange.aStart.Col(), aRange.aStart.Row(),
+                           aRange.aEnd.Col(),   aRange.aEnd.Row(), false );
+    
+            if (maOption.mbCenter)
+            {
+                pDoc->ApplyAttr( aRange.aStart.Col(), aRange.aStart.Row(),
+                                 aRange.aStart.Tab(),
+                                 SvxHorJustifyItem( SVX_HOR_JUSTIFY_CENTER, ATTR_HOR_JUSTIFY ) );
+                pDoc->ApplyAttr( aRange.aStart.Col(), aRange.aStart.Row(),
+                                 aRange.aStart.Tab(),
+                                 SvxVerJustifyItem( SVX_VER_JUSTIFY_CENTER, ATTR_VER_JUSTIFY ) );
+            }
+        }
+    
+        // undo -> copy back deleted contents
+        if (bUndo && mpUndoDoc)
+        {
+            pDoc->DeleteAreaTab( aRange, IDF_CONTENTS|IDF_NOCAPTIONS );
+            mpUndoDoc->CopyToDocument( aRange, IDF_ALL|IDF_NOCAPTIONS, FALSE, pDoc );
+        }
+    
+        // redo -> merge contents again
+        else if (!bUndo && mbMergeContents)
+        {
+            pDoc->DoMergeContents( aRange.aStart.Tab(),
+                                   aRange.aStart.Col(), aRange.aStart.Row(),
+                                   aRange.aEnd.Col(), aRange.aEnd.Row() );
+        }
+    
+        if (bUndo)
+            DoSdrUndoAction( mpDrawUndo, pDoc );
+        else
+            RedoSdrUndoAction( mpDrawUndo );
+    
+        bool bDidPaint = false;
+        if ( pViewShell )
+        {
+            pViewShell->SetTabNo(nTab);
+            bDidPaint = pViewShell->AdjustRowHeight(maOption.mnStartRow, maOption.mnEndRow);
+        }
+    
+        if (!bDidPaint)
+            ScUndoUtil::PaintMore(pDocShell, aRange);
     }
 
-    if (bUndo)
-        DoSdrUndoAction( mpDrawUndo, pDoc );
-    else
-        RedoSdrUndoAction( mpDrawUndo );
-
-	BOOL bDidPaint = FALSE;
-	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
-	if ( pViewShell )
-	{
-		pViewShell->SetTabNo( maRange.aStart.Tab() );
-		bDidPaint = pViewShell->AdjustRowHeight( maRange.aStart.Row(), maRange.aEnd.Row() );
-	}
-
-	if (!bDidPaint)
-		ScUndoUtil::PaintMore( pDocShell, maRange );
-
-	ShowTable( maRange );
+	ShowTable(aCurRange);
 }
 
 
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index c2eb810..d4cfb42 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -71,6 +71,7 @@
 #include <com/sun/star/text/WritingMode2.hpp>
 
 #include "autoform.hxx"
+#include "cellmergeoption.hxx"
 #include "cellsuno.hxx"
 #include "cursuno.hxx"
 #include "textuno.hxx"
@@ -5404,10 +5405,14 @@ void SAL_CALL ScCellRangeObj::merge( sal_Bool bMerge ) throw(uno::RuntimeExcepti
 	if ( pDocSh )
 	{
 		ScDocFunc aFunc(*pDocSh);
+        ScCellMergeOption aMergeOption(
+            aRange.aStart.Col(), aRange.aStart.Row(), 
+            aRange.aEnd.Col(), aRange.aEnd.Row(), false);
+        aMergeOption.maTabs.insert(aRange.aStart.Tab());
 		if ( bMerge )
-			aFunc.MergeCells( aRange, FALSE, TRUE, TRUE );
+			aFunc.MergeCells( aMergeOption, FALSE, TRUE, TRUE );
 		else
-			aFunc.UnmergeCells( aRange, TRUE, TRUE );
+			aFunc.UnmergeCells( aMergeOption, TRUE, TRUE );
 
 		//!	Fehler abfangen?
 	}
diff --git sc/source/ui/view/cellmergeoption.cxx sc/source/ui/view/cellmergeoption.cxx
new file mode 100644
index 0000000..ed6b8cb
--- /dev/null
+++ sc/source/ui/view/cellmergeoption.cxx
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: docfunc.hxx,v $
+ * $Revision: 1.18.30.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "cellmergeoption.hxx"
+#include "address.hxx"
+
+ScCellMergeOption::ScCellMergeOption() :
+    mnStartCol(0),
+    mnStartRow(0),
+    mnEndCol(0),
+    mnEndRow(0),
+    mbCenter(false)
+{
+}
+
+ScCellMergeOption::ScCellMergeOption(SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol, SCROW nEndRow, bool bCenter) :
+    mnStartCol(nStartCol),
+    mnStartRow(nStartRow),
+    mnEndCol(nEndCol),
+    mnEndRow(nEndRow),
+    mbCenter(bCenter)
+{
+}
+
+ScCellMergeOption::ScCellMergeOption(const ScCellMergeOption& r) :
+    maTabs(r.maTabs),
+    mnStartCol(r.mnStartCol),
+    mnStartRow(r.mnStartRow),
+    mnEndCol(r.mnEndCol),
+    mnEndRow(r.mnEndRow),
+    mbCenter(r.mbCenter)
+{
+}
+
+ScRange ScCellMergeOption::getSingleRange(SCTAB nTab) const
+{
+    return ScRange(mnStartCol, mnStartRow, nTab, mnEndCol, mnEndRow, nTab);
+}
+
+ScRange ScCellMergeOption::getFirstSingleRange() const
+{
+    SCTAB nTab = 0;
+    if (!maTabs.empty())
+        nTab = *maTabs.begin();
+
+    return getSingleRange(nTab);
+}
diff --git sc/source/ui/view/cellsh3.cxx sc/source/ui/view/cellsh3.cxx
index 57309e3..c689fa1 100644
--- sc/source/ui/view/cellsh3.cxx
+++ sc/source/ui/view/cellsh3.cxx
@@ -772,6 +772,7 @@ void ScCellShell::Execute( SfxRequest& rReq )
             {
                 // test whether to merge or to split
                 bool bMerge = false;
+                BOOL bCenter = FALSE;
                 switch( nSlot )
                 {
                     case FID_MERGE_ON:
@@ -782,6 +783,7 @@ void ScCellShell::Execute( SfxRequest& rReq )
                     break;
                     case FID_MERGE_TOGGLE:
                     {
+                        bCenter = TRUE;
                         SfxPoolItem* pItem = 0;
                         if( rBindings.QueryState( nSlot, pItem ) >= SFX_ITEM_DEFAULT )
                             bMerge = !static_cast< SfxBoolItem* >( pItem )->GetValue();
@@ -802,7 +804,7 @@ void ScCellShell::Execute( SfxRequest& rReq )
                         bMoveContents = ((const SfxBoolItem*)pItem)->GetValue();
                     }
 
-                    if (pTabViewShell->MergeCells( bApi, bMoveContents ))
+                    if (pTabViewShell->MergeCells( bApi, bMoveContents, TRUE, bCenter ))
                     {
                         if (!bApi && bMoveContents)             // "ja" im Dialog geklickt
                             rReq.AppendItem( SfxBoolItem( nSlot, bMoveContents ) );
diff --git sc/source/ui/view/makefile.mk sc/source/ui/view/makefile.mk
index 48395f3..46b8122 100644
--- sc/source/ui/view/makefile.mk
+++ sc/source/ui/view/makefile.mk
@@ -100,6 +100,7 @@ SLOFILES =  \
         $(SLO)$/output3.obj \
         $(SLO)$/gridmerg.obj \
         $(SLO)$/invmerge.obj \
+        $(SLO)$/cellmergeoption.obj \
         $(SLO)$/select.obj \
         $(SLO)$/olinewin.obj \
         $(SLO)$/hintwin.obj \
diff --git sc/source/ui/view/viewfun2.cxx sc/source/ui/view/viewfun2.cxx
index c563b9a..d6fd25d 100644
--- sc/source/ui/view/viewfun2.cxx
+++ sc/source/ui/view/viewfun2.cxx
@@ -70,6 +70,7 @@ using namespace com::sun::star;
 #include "attrib.hxx"
 #include "autoform.hxx"
 #include "cell.hxx"					// EnterAutoSum
+#include "cellmergeoption.hxx"
 #include "compiler.hxx"
 #include "docfunc.hxx"
 #include "docpool.hxx"
@@ -1087,7 +1088,7 @@ BOOL ScViewFunc::TestMergeCells()			// Vorab-Test (fuer Menue)
 
 //----------------------------------------------------------------------------
 
-BOOL ScViewFunc::MergeCells( BOOL bApi, BOOL& rDoContents, BOOL bRecord )
+BOOL ScViewFunc::MergeCells( BOOL bApi, BOOL& rDoContents, BOOL bRecord, BOOL bCenter )
 {
 	//	Editable- und Verschachtelungs-Abfrage muss vorneweg sein (auch in DocFunc),
 	//	damit dann nicht die Inhalte-QueryBox kommt
@@ -1130,10 +1131,26 @@ BOOL ScViewFunc::MergeCells( BOOL bApi, BOOL& rDoContents, BOOL bRecord )
 		return FALSE;
 	}
 
+    // Check for the contents of all selected tables.
+    bool bAskDialog = false;
+    SCTAB nTabCount = pDoc->GetTableCount();
+    ScCellMergeOption aMergeOption(nStartCol, nStartRow, nEndCol, nEndRow, bCenter);
+    for (SCTAB i = 0; i < nTabCount; ++i)
+    {
+        if (!rMark.GetTableSelect(i))
+            // this table is not selected.
+            continue;
+
+        aMergeOption.maTabs.insert(i);
+
+        if (!pDoc->IsBlockEmpty(i, nStartCol, nStartRow+1, nStartCol, nEndRow) ||
+            !pDoc->IsBlockEmpty(i, nStartCol+1, nStartRow, nEndCol, nEndRow))
+            bAskDialog = true;
+    }
+
 	BOOL bOk = TRUE;
 
-	if ( !pDoc->IsBlockEmpty( nStartTab, nStartCol,nStartRow+1, nStartCol,nEndRow, true ) ||
-		 !pDoc->IsBlockEmpty( nStartTab, nStartCol+1,nStartRow, nEndCol,nEndRow, true ) )
+    if (bAskDialog)
 	{
 		if (!bApi)
 		{
@@ -1153,7 +1170,7 @@ BOOL ScViewFunc::MergeCells( BOOL bApi, BOOL& rDoContents, BOOL bRecord )
 	if (bOk)
 	{
 		HideCursor();
-		bOk = pDocSh->GetDocFunc().MergeCells( aMarkRange, rDoContents, bRecord, bApi );
+		bOk = pDocSh->GetDocFunc().MergeCells( aMergeOption, rDoContents, bRecord, bApi );
 		ShowCursor();
 
 		if (bOk)
@@ -1189,6 +1206,32 @@ BOOL ScViewFunc::TestRemoveMerge()
 
 //----------------------------------------------------------------------------
 
+static bool lcl_extendMergeRange(ScCellMergeOption& rOption, const ScRange& rRange)
+{
+    bool bExtended = false;
+    if (rOption.mnStartCol > rRange.aStart.Col())
+    {    
+        rOption.mnStartCol = rRange.aStart.Col();
+        bExtended = true;
+    }
+    if (rOption.mnStartRow > rRange.aStart.Row())
+    {    
+        rOption.mnStartRow = rRange.aStart.Row();
+        bExtended = true;
+    }
+    if (rOption.mnEndCol < rRange.aEnd.Col())
+    {    
+        rOption.mnEndCol = rRange.aEnd.Col();
+        bExtended = true;
+    }
+    if (rOption.mnEndRow < rRange.aEnd.Row())
+    {    
+        rOption.mnEndRow = rRange.aEnd.Row();
+        bExtended = true;
+    }
+    return bExtended;
+}
+
 BOOL ScViewFunc::RemoveMerge( BOOL bRecord )
 {
 	ScRange aRange;
@@ -1200,12 +1243,39 @@ BOOL ScViewFunc::RemoveMerge( BOOL bRecord )
     }
 	else if (GetViewData()->GetSimpleArea( aRange ) == SC_MARK_SIMPLE)
 	{
+        ScDocument* pDoc = GetViewData()->GetDocument();
         ScRange aExtended( aRange );
-        GetViewData()->GetDocument()->ExtendMerge( aExtended );
+        pDoc->ExtendMerge( aExtended );
 		ScDocShell* pDocSh = GetViewData()->GetDocShell();
+        const ScMarkData& rMark = GetViewData()->GetMarkData();
+        SCTAB nTabCount = pDoc->GetTableCount();
+        ScCellMergeOption aOption(aRange.aStart.Col(), aRange.aStart.Row(), aRange.aEnd.Col(), aRange.aEnd.Row());
+        bool bExtended = false;
+        do
+        {
+            bExtended = false;
+            for (SCTAB i = 0; i < nTabCount; ++i)
+            {
+                if (!rMark.GetTableSelect(i))
+                    // This table is not selected.
+                    continue;
+    
+                aOption.maTabs.insert(i);
+                aExtended.aStart.SetTab(i);
+                aExtended.aEnd.SetTab(i);
+                pDoc->ExtendMerge(aExtended);
+                pDoc->ExtendOverlapped(aExtended);
+    
+                // Expand the current range to be inclusive of all merged
+                // areas on all sheets.
+                bExtended = lcl_extendMergeRange(aOption, aExtended);
+            }
+        }
+        while (bExtended);
 
 		HideCursor();
-		BOOL bOk = pDocSh->GetDocFunc().UnmergeCells( aRange, bRecord, FALSE );
+		BOOL bOk = pDocSh->GetDocFunc().UnmergeCells(aOption, bRecord, FALSE );
+        aExtended = aOption.getFirstSingleRange();
         MarkRange( aExtended );
 		ShowCursor();
 
diff --git sc/uiconfig/scalc/menubar/menubar.xml sc/uiconfig/scalc/menubar/menubar.xml
index 118fac7..322d448 100644
--- sc/uiconfig/scalc/menubar/menubar.xml
+++ sc/uiconfig/scalc/menubar/menubar.xml
@@ -218,7 +218,13 @@
                     <menu:menuitem menu:id=".uno:SetTabBgColor"/>
                 </menu:menupopup>
             </menu:menu>
-            <menu:menuitem menu:id=".uno:ToggleMergeCells"/>
+            <menu:menu menu:id=".uno:MergeCellsMenu">
+                <menu:menupopup>
+                    <menu:menuitem menu:id=".uno:ToggleMergeCells"/>
+                    <menu:menuitem menu:id=".uno:MergeCells"/>
+                    <menu:menuitem menu:id=".uno:SplitCell"/>
+                </menu:menupopup>
+            </menu:menu>
             <menu:menuseparator/>
             <menu:menuitem menu:id=".uno:PageFormatDialog"/>
             <menu:menu menu:id=".uno:PrintRangesMenu">
