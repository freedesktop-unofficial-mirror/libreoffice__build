--- writerperfect/source/filter/DocumentCollector.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/DocumentCollector.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -39,6 +39,8 @@
 
 #include "DocumentCollector.hxx"
 #include "DocumentElement.hxx"
+#include "DocumentHandler.hxx"
+#include "InternalHandler.hxx"
 #include "TextRunStyle.hxx"
 #include "FontStyle.hxx"
 #include "ListStyle.hxx"
@@ -47,6 +49,7 @@
 #include "TableStyle.hxx"
 #include "FilterInternal.hxx"
 #include "WriterProperties.hxx"
+#include "OdgExporter.hxx"
 
 _WriterDocumentState::_WriterDocumentState() :
 	mbFirstElement(true),
@@ -54,27 +57,40 @@
 	mbListElementOpenedAtCurrentLevel(false),
 	mbTableCellOpened(false),
 	mbHeaderRow(false),
-	mbInNote(false)
+	mbInNote(false),
+	mbInTextBox(false),
+	mbInFrame(false)
 {
 }
 
-DocumentCollector::DocumentCollector(WPSInputStream *pInput, DocumentHandler *pHandler) :
-        mpInput(pInput),
-        mpHandler(pHandler),
+_WriterListState::_WriterListState() :
+	mpCurrentListStyle(NULL),
+	miCurrentListLevel(0),
+	miLastListLevel(0),
+	miLastListNumber(0),
+	mbListContinueNumbering(false),
+	mbListElementParagraphOpened(false),
+	mbListElementOpened()
+{
+}
+
+DocumentCollector::DocumentCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler) :
+	mpInput(pInput),
+	mpHandler(pHandler),
 	mbUsed(false),
+	mWriterDocumentStates(),
+	mWriterListStates(),
 	mfSectionSpaceAfter(0.0f),
 	miNumListStyles(0),
 	mpCurrentContentElements(&mBodyElements),
 	mpCurrentPageSpan(NULL),
 	miNumPageStyles(0),
-	mpCurrentListStyle(NULL),
-	miCurrentListLevel(0),
-	miLastListLevel(0),
-	miLastListNumber(0),
-	mbListContinueNumbering(false),
-	mbListElementOpened(false),
-	mbListElementParagraphOpened(false)
+	miObjectNumber(0),
+	mbIsFlatXML(true),
+	mpPassword(NULL)
 {
+	mWriterDocumentStates.push(WriterDocumentState());
+	mWriterListStates.push(WriterListState());
 }
 
 DocumentCollector::~DocumentCollector()
@@ -91,18 +107,18 @@
 	mbUsed = true;
 
 	// parse & write
-        // WLACH_REFACTORING: Remove these args..
  	if (!parseSourceDocument(*mpInput))
 		return false;
 	if (!_writeTargetDocument(mpHandler))
 		return false;
 
+
  	// clean up the mess we made
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Cleaning up our mess..\n"));
 
 	WRITER_DEBUG_MSG(("Destroying the body elements\n"));
 	for (std::vector<DocumentElement *>::iterator iterBody = mBodyElements.begin(); iterBody != mBodyElements.end(); iterBody++) {
-		delete((*iterBody));
+		delete (*iterBody);
 		(*iterBody) = NULL;
 	}
 
@@ -115,90 +131,113 @@
 
 	WRITER_DEBUG_MSG(("Destroying the rest of the styles elements\n"));
 	for (std::map<WPXString, ParagraphStyle *, ltstr>::iterator iterTextStyle = mTextStyleHash.begin(); iterTextStyle != mTextStyleHash.end(); iterTextStyle++) {
-		delete iterTextStyle->second;
+		delete (iterTextStyle->second);
 	}
 	for (std::map<WPXString, SpanStyle *, ltstr>::iterator iterSpanStyle = mSpanStyleHash.begin(); iterSpanStyle != mSpanStyleHash.end(); iterSpanStyle++) {
-		delete iterSpanStyle->second;
+		delete(iterSpanStyle->second);
 	}
 
 	for (std::map<WPXString, FontStyle *, ltstr>::iterator iterFont = mFontHash.begin(); iterFont != mFontHash.end(); iterFont++) {
-		delete iterFont->second;
+		delete(iterFont->second);
 	}
 
 	for (std::vector<ListStyle *>::iterator iterListStyles = mListStyles.begin(); iterListStyles != mListStyles.end(); iterListStyles++) {
-		delete (*iterListStyles);
+		delete(*iterListStyles);
 	}
 	for (std::vector<SectionStyle *>::iterator iterSectionStyles = mSectionStyles.begin(); iterSectionStyles != mSectionStyles.end(); iterSectionStyles++) {
-		delete (*iterSectionStyles);
+		delete(*iterSectionStyles);
 	}
 	for (std::vector<TableStyle *>::iterator iterTableStyles = mTableStyles.begin(); iterTableStyles != mTableStyles.end(); iterTableStyles++) {
-		delete (*iterTableStyles);
+		delete((*iterTableStyles));
 	}
 
 	for (std::vector<PageSpan *>::iterator iterPageSpans = mPageSpans.begin(); iterPageSpans != mPageSpans.end(); iterPageSpans++) {
-		delete (*iterPageSpans);
+		delete(*iterPageSpans);
+	}
+	for (std::vector<DocumentElement *>::iterator iterFrameStyles = mFrameStyles.begin(); iterFrameStyles != mFrameStyles.end(); iterFrameStyles++) {
+		delete(*iterFrameStyles);
+	}
+	for (std::vector<DocumentElement *>::iterator iterFrameAutomaticStyles = mFrameAutomaticStyles.begin();
+		iterFrameAutomaticStyles != mFrameAutomaticStyles.end(); iterFrameAutomaticStyles++) {
+		delete(*iterFrameAutomaticStyles);
+	}
+	for (std::vector<DocumentElement *>::iterator iterMetaData = mMetaData.begin(); iterMetaData != mMetaData.end(); iterMetaData++) {
+		delete(*iterMetaData);
 	}
 
  	return true;
 }
 
-void DocumentCollector::_writeDefaultStyles(DocumentHandler *pHandler)
+void DocumentCollector::_writeDefaultStyles(DocumentHandlerInterface *pHandler)
 {
-	TagOpenElement stylesOpenElement("office:styles");
-	stylesOpenElement.write(pHandler);
+	TagOpenElement("office:styles").write(pHandler);
 
 	TagOpenElement defaultParagraphStyleOpenElement("style:default-style");
 	defaultParagraphStyleOpenElement.addAttribute("style:family", "paragraph");
 	defaultParagraphStyleOpenElement.write(pHandler);
 
-	TagOpenElement defaultParagraphStylePropertiesOpenElement("style:properties");
-	defaultParagraphStylePropertiesOpenElement.addAttribute("style:family", "paragraph");
-	defaultParagraphStylePropertiesOpenElement.addAttribute("style:tab-stop-distance", "0.5inch");
+	TagOpenElement defaultParagraphStylePropertiesOpenElement("style:paragraph-properties");
+	defaultParagraphStylePropertiesOpenElement.addAttribute("style:tab-stop-distance", "0.5in");
 	defaultParagraphStylePropertiesOpenElement.write(pHandler);
-	TagCloseElement defaultParagraphStylePropertiesCloseElement("style:properties");
+	TagCloseElement defaultParagraphStylePropertiesCloseElement("style:paragraph-properties");
 	defaultParagraphStylePropertiesCloseElement.write(pHandler);
 
-	TagCloseElement defaultParagraphStyleCloseElement("style:default-style");
-	defaultParagraphStyleCloseElement.write(pHandler);
+	pHandler->endElement("style:default-style");
 
-	TagOpenElement standardStyleOpenElement("style:style");
-        standardStyleOpenElement.addAttribute("style:name", "Standard");
-        standardStyleOpenElement.addAttribute("style:family", "paragraph");
-        standardStyleOpenElement.addAttribute("style:class", "text");
-        standardStyleOpenElement.write(pHandler);
-        TagCloseElement standardStyleCloseElement("style:style");
-        standardStyleCloseElement.write(pHandler);
-
-        TagOpenElement textBodyStyleOpenElement("style:style");
-        textBodyStyleOpenElement.addAttribute("style:name", "Text Body");
-        textBodyStyleOpenElement.addAttribute("style:family", "paragraph");
-        textBodyStyleOpenElement.addAttribute("style:parent-style-name", "Standard");
-        textBodyStyleOpenElement.addAttribute("style:class", "text");
-        textBodyStyleOpenElement.write(pHandler);
-        TagCloseElement textBodyStyleCloseElement("style:style");
-        textBodyStyleCloseElement.write(pHandler);
-
-        TagOpenElement tableContentsStyleOpenElement("style:style");
-        tableContentsStyleOpenElement.addAttribute("style:name", "Table Contents");
-        tableContentsStyleOpenElement.addAttribute("style:family", "paragraph");
-        tableContentsStyleOpenElement.addAttribute("style:parent-style-name", "Text Body");
-        tableContentsStyleOpenElement.addAttribute("style:class", "extra");
-        tableContentsStyleOpenElement.write(pHandler);
-        TagCloseElement tableContentsStyleCloseElement("style:style");
-        tableContentsStyleCloseElement.write(pHandler);
-
-        TagOpenElement tableHeadingStyleOpenElement("style:style");
-        tableHeadingStyleOpenElement.addAttribute("style:name", "Table Heading");
-        tableHeadingStyleOpenElement.addAttribute("style:family", "paragraph");
-        tableHeadingStyleOpenElement.addAttribute("style:parent-style-name", "Table Contents");
-        tableHeadingStyleOpenElement.addAttribute("style:class", "extra");
-        tableHeadingStyleOpenElement.write(pHandler);
-        TagCloseElement tableHeadingStyleCloseElement("style:style");
-        tableHeadingStyleCloseElement.write(pHandler);
+	TagOpenElement defaultTableRowStyleOpenElement("style:default-style");
+	defaultTableRowStyleOpenElement.addAttribute("style:family", "table-row");
+	defaultTableRowStyleOpenElement.write(pHandler);
+
+	TagOpenElement defaultTableRowPropertiesOpenElement("style:table-row-properties");
+	defaultTableRowPropertiesOpenElement.addAttribute("fo:keep-together", "auto");
+	defaultTableRowPropertiesOpenElement.write(pHandler);
+
+	pHandler->endElement("style:table-row-properties");
+	pHandler->endElement("style:default-style");
 
-	TagCloseElement stylesCloseElement("office:styles");
-	stylesCloseElement.write(pHandler);
+	TagOpenElement standardStyleOpenElement("style:style");
+	standardStyleOpenElement.addAttribute("style:name", "Standard");
+	standardStyleOpenElement.addAttribute("style:family", "paragraph");
+	standardStyleOpenElement.addAttribute("style:class", "text");
+	standardStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	TagOpenElement textBodyStyleOpenElement("style:style");
+	textBodyStyleOpenElement.addAttribute("style:name", "Text_Body");
+	textBodyStyleOpenElement.addAttribute("style:display-name", "Text Body");
+	textBodyStyleOpenElement.addAttribute("style:family", "paragraph");
+	textBodyStyleOpenElement.addAttribute("style:parent-style-name", "Standard");
+	textBodyStyleOpenElement.addAttribute("style:class", "text");
+	textBodyStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	TagOpenElement tableContentsStyleOpenElement("style:style");
+	tableContentsStyleOpenElement.addAttribute("style:name", "Table_Contents");
+	tableContentsStyleOpenElement.addAttribute("style:display-name", "Table Contents");
+	tableContentsStyleOpenElement.addAttribute("style:family", "paragraph");
+	tableContentsStyleOpenElement.addAttribute("style:parent-style-name", "Text_Body");
+	tableContentsStyleOpenElement.addAttribute("style:class", "extra");
+	tableContentsStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	TagOpenElement tableHeadingStyleOpenElement("style:style");
+	tableHeadingStyleOpenElement.addAttribute("style:name", "Table_Heading");
+	tableHeadingStyleOpenElement.addAttribute("style:display-name", "Table Heading");
+	tableHeadingStyleOpenElement.addAttribute("style:family", "paragraph");
+	tableHeadingStyleOpenElement.addAttribute("style:parent-style-name", "Table_Contents");
+	tableHeadingStyleOpenElement.addAttribute("style:class", "extra");
+	tableHeadingStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	for (std::vector<DocumentElement *>::const_iterator iter = mFrameStyles.begin();
+		iter != mFrameStyles.end(); iter++)
+		(*iter)->write(pHandler);
 
+	pHandler->endElement("office:styles");
 }
 
 // writes everything up to the automatic styles declarations..
@@ -206,11 +245,9 @@
 {
 }
 
-void DocumentCollector::_writeMasterPages(DocumentHandler *pHandler)
+void DocumentCollector::_writeMasterPages(DocumentHandlerInterface *pHandler)
 {
-        WPXPropertyList xBlankAttrList;
-
-	pHandler->startElement("office:master-styles", xBlankAttrList);
+	TagOpenElement("office:master-styles").write(mpHandler);
 	int pageNumber = 1;
 	for (unsigned int i=0; i<mPageSpans.size(); i++)
 	{
@@ -222,99 +259,118 @@
 	pHandler->endElement("office:master-styles");
 }
 
-void DocumentCollector::_writePageMasters(DocumentHandler *pHandler)
+void DocumentCollector::_writePageLayouts(DocumentHandlerInterface *pHandler)
 {
 	for (unsigned int i=0; i<mPageSpans.size(); i++)
 	{
-		mPageSpans[i]->writePageMaster(i, pHandler);
+		mPageSpans[i]->writePageLayout(i, pHandler);
 	}
 }
 
-bool DocumentCollector::_writeTargetDocument(DocumentHandler *pHandler)
-{        
+bool DocumentCollector::_writeTargetDocument(DocumentHandlerInterface *pHandler)
+{
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Printing out the header stuff..\n"));
-	WPXPropertyList xBlankAttrList;
 
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Start Document\n"));
 	mpHandler->startDocument();
 
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: preamble\n"));
-        WPXPropertyList docContentPropList;
-	docContentPropList.insert("xmlns:office", "http://openoffice.org/2000/office");
-	docContentPropList.insert("xmlns:style", "http://openoffice.org/2000/style");
-	docContentPropList.insert("xmlns:text", "http://openoffice.org/2000/text");
-	docContentPropList.insert("xmlns:table", "http://openoffice.org/2000/table");
-	docContentPropList.insert("xmlns:draw", "http://openoffice.org/2000/draw");
-	docContentPropList.insert("xmlns:fo", "http://www.w3.org/1999/XSL/Format");
+	WPXPropertyList docContentPropList;
+	docContentPropList.insert("xmlns:office", "urn:oasis:names:tc:opendocument:xmlns:office:1.0");
+	docContentPropList.insert("xmlns:meta", "urn:oasis:names:tc:opendocument:xmlns:meta:1.0");
+	docContentPropList.insert("xmlns:dc", "http://purl.org/dc/elements/1.1/");
+	docContentPropList.insert("xmlns:config", "urn:oasis:names:tc:opendocument:xmlns:config:1.0");
+	docContentPropList.insert("xmlns:text", "urn:oasis:names:tc:opendocument:xmlns:text:1.0");
+	docContentPropList.insert("xmlns:table", "urn:oasis:names:tc:opendocument:xmlns:table:1.0");
+	docContentPropList.insert("xmlns:draw", "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0");
+	docContentPropList.insert("xmlns:fo", "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0");
 	docContentPropList.insert("xmlns:xlink", "http://www.w3.org/1999/xlink");
 	docContentPropList.insert("xmlns:number", "http://openoffice.org/2000/datastyle");
-	docContentPropList.insert("xmlns:svg", "http://www.w3.org/2000/svg");
-	docContentPropList.insert("xmlns:chart", "http://openoffice.org/2000/chart");
-	docContentPropList.insert("xmlns:dr3d", "http://openoffice.org/2000/dr3d");
+	docContentPropList.insert("xmlns:svg", "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0");
+	docContentPropList.insert("xmlns:chart", "urn:oasis:names:tc:opendocument:xmlns:chart:1.0");
+	docContentPropList.insert("xmlns:dr3d", "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0");
 	docContentPropList.insert("xmlns:math", "http://www.w3.org/1998/Math/MathML");
-	docContentPropList.insert("xmlns:form", "http://openoffice.org/2000/form");
-	docContentPropList.insert("xmlns:script", "http://openoffice.org/2000/script");
-	docContentPropList.insert("office:class", "text");
+	docContentPropList.insert("xmlns:form", "urn:oasis:names:tc:opendocument:xmlns:form:1.0");
+	docContentPropList.insert("xmlns:script", "urn:oasis:names:tc:opendocument:xmlns:script:1.0");
+	docContentPropList.insert("xmlns:style", "urn:oasis:names:tc:opendocument:xmlns:style:1.0");
 	docContentPropList.insert("office:version", "1.0");
-        mpHandler->startElement("office:document-content", docContentPropList);
+	if (mbIsFlatXML)
+	{
+		docContentPropList.insert("office:mimetype", "application/vnd.oasis.opendocument.text");
+		mpHandler->startElement("office:document", docContentPropList);
+	}
+	else
+		mpHandler->startElement("office:document-content", docContentPropList);
+
+	// write out the metadata
+	TagOpenElement("office:meta").write(mpHandler);
+	for (std::vector<DocumentElement *>::const_iterator iterMetaData = mMetaData.begin(); iterMetaData != mMetaData.end(); iterMetaData++) {
+		(*iterMetaData)->write(mpHandler);
+	}
+	mpHandler->endElement("office:meta");
 
 	// write out the font styles
-	mpHandler->startElement("office:font-decls", xBlankAttrList);
+	TagOpenElement("office:font-face-decls").write(mpHandler);
 	for (std::map<WPXString, FontStyle *, ltstr>::iterator iterFont = mFontHash.begin(); iterFont != mFontHash.end(); iterFont++) {
 		iterFont->second->write(mpHandler);
 	}
-	TagOpenElement symbolFontOpen("style:font-decl");
+	TagOpenElement symbolFontOpen("style:font-face");
 	symbolFontOpen.addAttribute("style:name", "StarSymbol");
-	symbolFontOpen.addAttribute("fo:font-family", "StarSymbol");
+	symbolFontOpen.addAttribute("svg:font-family", "StarSymbol");
 	symbolFontOpen.addAttribute("style:font-charset", "x-symbol");
 	symbolFontOpen.write(mpHandler);
-        mpHandler->endElement("style:font-decl");
-
-	mpHandler->endElement("office:font-decls");
+	mpHandler->endElement("style:font-face");
 
+	mpHandler->endElement("office:font-face-decls");
 
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Writing out the styles..\n"));
 
 	// write default styles
 	_writeDefaultStyles(mpHandler);
 
-	mpHandler->startElement("office:automatic-styles", xBlankAttrList);
+	TagOpenElement("office:automatic-styles").write(mpHandler);
 
-	for (std::map<WPXString, ParagraphStyle *, ltstr>::iterator iterTextStyle = mTextStyleHash.begin(); 
-             iterTextStyle != mTextStyleHash.end(); iterTextStyle++) 
-        {
+	for (std::vector<DocumentElement *>::const_iterator iterFrameAutomaticStyles = mFrameAutomaticStyles.begin();
+		iterFrameAutomaticStyles != mFrameAutomaticStyles.end(); iterFrameAutomaticStyles++)
+	{
+		(*iterFrameAutomaticStyles)->write(pHandler);
+	}
+
+	for (std::map<WPXString, ParagraphStyle *, ltstr>::const_iterator iterTextStyle = mTextStyleHash.begin(); 
+	     iterTextStyle != mTextStyleHash.end(); iterTextStyle++) 
+	{
 		// writing out the paragraph styles
 		if (strcmp((iterTextStyle->second)->getName().cstr(), "Standard")) 
-                {
+		{
 			// don't write standard paragraph "no styles" style
 			(iterTextStyle->second)->write(pHandler);
 		}
 	}
 
-        // span styles..
-	for (std::map<WPXString, SpanStyle *, ltstr>::iterator iterSpanStyle = mSpanStyleHash.begin(); 
-             iterSpanStyle != mSpanStyleHash.end(); iterSpanStyle++) 
-        {
-                (iterSpanStyle->second)->write(pHandler);
+	// span styles..
+	for (std::map<WPXString, SpanStyle *, ltstr>::const_iterator iterSpanStyle = mSpanStyleHash.begin(); 
+	     iterSpanStyle != mSpanStyleHash.end(); iterSpanStyle++) 
+	{
+		(iterSpanStyle->second)->write(pHandler);
 	}
 
  	// writing out the sections styles
-	for (std::vector<SectionStyle *>::iterator iterSectionStyles = mSectionStyles.begin(); iterSectionStyles != mSectionStyles.end(); iterSectionStyles++) {
+	for (std::vector<SectionStyle *>::const_iterator iterSectionStyles = mSectionStyles.begin(); iterSectionStyles != mSectionStyles.end(); iterSectionStyles++) {
 		(*iterSectionStyles)->write(pHandler);
 	}
 
 	// writing out the lists styles
-	for (std::vector<ListStyle *>::iterator iterListStyles = mListStyles.begin(); iterListStyles != mListStyles.end(); iterListStyles++) {
+	for (std::vector<ListStyle *>::const_iterator iterListStyles = mListStyles.begin(); iterListStyles != mListStyles.end(); iterListStyles++) {
 		(*iterListStyles)->write(pHandler);
 	}
 
  	// writing out the table styles
-	for (std::vector<TableStyle *>::iterator iterTableStyles = mTableStyles.begin(); iterTableStyles != mTableStyles.end(); iterTableStyles++) {
+	for (std::vector<TableStyle *>::const_iterator iterTableStyles = mTableStyles.begin(); iterTableStyles != mTableStyles.end(); iterTableStyles++) {
 		(*iterTableStyles)->write(pHandler);
 	}
 
 	// writing out the page masters
-	_writePageMasters(pHandler);
+	_writePageLayouts(pHandler);
 
 
 	pHandler->endElement("office:automatic-styles");
@@ -323,15 +379,20 @@
 
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Writing out the document..\n"));
  	// writing out the document
-	pHandler->startElement("office:body", xBlankAttrList);
+	TagOpenElement("office:body").write(mpHandler);
+	TagOpenElement("office:text").write(mpHandler);
 
-	for (std::vector<DocumentElement *>::iterator iterBodyElements = mBodyElements.begin(); iterBodyElements != mBodyElements.end(); iterBodyElements++) {
+	for (std::vector<DocumentElement *>::const_iterator iterBodyElements = mBodyElements.begin(); iterBodyElements != mBodyElements.end(); iterBodyElements++) {
 		(*iterBodyElements)->write(pHandler);
 	}
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Finished writing all doc els..\n"));
 
+	pHandler->endElement("office:text");
 	pHandler->endElement("office:body");
-	pHandler->endElement("office:document-content");
+	if (mbIsFlatXML)
+		pHandler->endElement("office:document");
+	else
+		pHandler->endElement("office:document-content");
 
 	pHandler->endDocument();
 
@@ -341,32 +402,32 @@
 
 WPXString propListToStyleKey(const WPXPropertyList & xPropList)
 {
-        WPXString sKey;
-        WPXPropertyList::Iter i(xPropList);
-        for (i.rewind(); i.next(); )
-        {
-                WPXString sProp;
-                sProp.sprintf("[%s:%s]", i.key(), i()->getStr().cstr());
-                sKey.append(sProp);
-        }
+	WPXString sKey;
+	WPXPropertyList::Iter i(xPropList);
+	for (i.rewind(); i.next(); )
+	{
+		WPXString sProp;
+		sProp.sprintf("[%s:%s]", i.key(), i()->getStr().cstr());
+		sKey.append(sProp);
+	}
 
-        return sKey;
+	return sKey;
 }
 
 WPXString getParagraphStyleKey(const WPXPropertyList & xPropList, const WPXPropertyListVector & xTabStops)
 {
-        WPXString sKey = propListToStyleKey(xPropList);
-        
-        WPXString sTabStops;
-        sTabStops.sprintf("[num-tab-stops:%i]", xTabStops.count());
-        WPXPropertyListVector::Iter i(xTabStops);
-        for (i.rewind(); i.next();)
-        {
-                sTabStops.append(propListToStyleKey(i()));
-        }
-        sKey.append(sTabStops);
+	WPXString sKey = propListToStyleKey(xPropList);
+
+	WPXString sTabStops;
+	sTabStops.sprintf("[num-tab-stops:%i]", xTabStops.count());
+	WPXPropertyListVector::Iter i(xTabStops);
+	for (i.rewind(); i.next();)
+	{
+		sTabStops.append(propListToStyleKey(i()));
+	}
+	sKey.append(sTabStops);
 
-        return sKey;
+	return sKey;
 }
 
 // _allocateFontName: add a (potentially mapped) font style to the hash if it's not already there, do nothing otherwise
@@ -379,11 +440,29 @@
 	}
 }
 
+void DocumentCollector::setDocumentMetaData(const WPXPropertyList &propList)
+{
+        WPXPropertyList::Iter i(propList);
+        for (i.rewind(); i.next(); )
+        {
+                // filter out libwpd elements
+                if (strncmp(i.key(), "libwpd", 6) != 0 && strncmp(i.key(), "dcterms", 7) != 0)
+		{
+			mMetaData.push_back(new TagOpenElement(i.key()));
+			WPXString sStringValue(i()->getStr(), true);
+			mMetaData.push_back(new CharDataElement(sStringValue.cstr()));
+			mMetaData.push_back(new TagCloseElement(i.key()));
+		}
+        }
+
+}
+
 void DocumentCollector::openPageSpan(const WPXPropertyList &propList)
 {
 	PageSpan *pPageSpan = new PageSpan(propList);
 	mPageSpans.push_back(pPageSpan);
 	mpCurrentPageSpan = pPageSpan;
+	miNumPageStyles++;
 }
 
 void DocumentCollector::openHeader(const WPXPropertyList &propList)
@@ -391,9 +470,9 @@
 	std::vector<DocumentElement *> * pHeaderFooterContentElements = new std::vector<DocumentElement *>;
 
 	if (propList["libwpd:occurence"]->getStr() == "even")
-                mpCurrentPageSpan->setHeaderLeftContent(pHeaderFooterContentElements);
-        else
-                mpCurrentPageSpan->setHeaderContent(pHeaderFooterContentElements);
+		mpCurrentPageSpan->setHeaderLeftContent(pHeaderFooterContentElements);
+	else
+		mpCurrentPageSpan->setHeaderContent(pHeaderFooterContentElements);
 
 	mpCurrentContentElements = pHeaderFooterContentElements;
 }
@@ -408,9 +487,9 @@
 	std::vector<DocumentElement *> * pHeaderFooterContentElements = new std::vector<DocumentElement *>;
 
 	if (propList["libwpd:occurence"]->getStr() == "even")
-                mpCurrentPageSpan->setFooterLeftContent(pHeaderFooterContentElements);
-        else
-                mpCurrentPageSpan->setFooterContent(pHeaderFooterContentElements);
+		mpCurrentPageSpan->setFooterLeftContent(pHeaderFooterContentElements);
+	else
+		mpCurrentPageSpan->setFooterContent(pHeaderFooterContentElements);
 
 	mpCurrentContentElements = pHeaderFooterContentElements;
 }
@@ -422,7 +501,7 @@
 
 void DocumentCollector::openSection(const WPXPropertyList &propList, const WPXPropertyListVector &columns)
 {
-        int iNumColumns = columns.count();
+	int iNumColumns = columns.count();
 	float fSectionMarginLeft = 0.0f;
 	float fSectionMarginRight = 0.0f;
 	if (propList["fo:margin-left"])
@@ -432,38 +511,33 @@
 
 	if (iNumColumns > 1 || fSectionMarginLeft != 0 || fSectionMarginRight != 0)
 	{
-		mfSectionSpaceAfter = propList["fo:margin-bottom"]->getFloat();
+		if (propList["fo:margin-bottom"])
+			mfSectionSpaceAfter = propList["fo:margin-bottom"]->getFloat();
+		else if (propList["libwpd:margin-bottom"])
+			mfSectionSpaceAfter =  propList["libwpd:margin-bottom"]->getFloat();
+
 		WPXString sSectionName;
 		sSectionName.sprintf("Section%i", mSectionStyles.size());
-		
+
 		SectionStyle *pSectionStyle = new SectionStyle(propList, columns, sSectionName.cstr());
 		mSectionStyles.push_back(pSectionStyle);
-		
+
 		TagOpenElement *pSectionOpenElement = new TagOpenElement("text:section");
 		pSectionOpenElement->addAttribute("text:style-name", pSectionStyle->getName());
 		pSectionOpenElement->addAttribute("text:name", pSectionStyle->getName());
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pSectionOpenElement));
+		mpCurrentContentElements->push_back(pSectionOpenElement);
 	}
 	else
-		mWriterDocumentState.mbInFakeSection = true;
+		mWriterDocumentStates.top().mbInFakeSection = true;
 }
 
 void DocumentCollector::closeSection()
 {
-	if (!mWriterDocumentState.mbInFakeSection)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:section")));
+	if (!mWriterDocumentStates.top().mbInFakeSection)
+		mpCurrentContentElements->push_back(new TagCloseElement("text:section"));
 	else
-		mWriterDocumentState.mbInFakeSection = false;
+		mWriterDocumentStates.top().mbInFakeSection = false;
 
-	// open as many paragraphs as needed to simulate section space after
-	// WLACH_REFACTORING: disable this for now..
-	#if 0
-	for (float f=0.0f; f<mfSectionSpaceAfter; f+=1.0f) {
-		vector<WPXTabStop> dummyTabStops;
-		openParagraph(WPX_PARAGRAPH_JUSTIFICATION_LEFT, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, dummyTabStops, false, false);
-		closeParagraph();
-	}
-	#endif
 	mfSectionSpaceAfter = 0.0f;
 }
 
@@ -471,11 +545,11 @@
 {
 	// FIXMENOW: What happens if we open a footnote inside a table? do we then inherit the footnote's style
 	// from "Table Contents"
-	
+
 	WPXPropertyList *pPersistPropList = new WPXPropertyList(propList);
 	ParagraphStyle *pStyle = NULL;
 
-	if (mWriterDocumentState.mbFirstElement && mpCurrentContentElements == &mBodyElements)
+	if (mWriterDocumentStates.top().mbFirstElement && mpCurrentContentElements == &mBodyElements)
 	{
 		// we don't have to go through the fuss of determining if the paragraph style is 
 		// unique in this case, because if we are the first document element, then we
@@ -487,31 +561,35 @@
 		sName.sprintf("FS");
 
 		WPXString sParagraphHashKey("P|FS");
-		pPersistPropList->insert("style:master-page-name", "Page Style 1");
-                pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
+		pPersistPropList->insert("style:master-page-name", "Page_Style_1");
+		pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
 		mTextStyleHash[sParagraphHashKey] = pStyle;
-		mWriterDocumentState.mbFirstElement = false;
+		mWriterDocumentStates.top().mbFirstElement = false;
  	}
 	else
 	{
-		if (mWriterDocumentState.mbTableCellOpened)
+//		WPXString sPageStyleName;
+//		sPageStyleName.sprintf("Page_Style_%i", miNumPageStyles);
+//		pPersistPropList->insert("style:master-page-name", sPageStyleName);
+		if (mWriterDocumentStates.top().mbTableCellOpened)
 		{
-			if (mWriterDocumentState.mbHeaderRow)
-				pPersistPropList->insert("style:parent-style-name", "Table Heading");
+			if (mWriterDocumentStates.top().mbHeaderRow)
+				pPersistPropList->insert("style:parent-style-name", "Table_Heading");
 			else
-				pPersistPropList->insert("style:parent-style-name", "Table Contents");
+				pPersistPropList->insert("style:parent-style-name", "Table_Contents");
 		}
 		else
 			pPersistPropList->insert("style:parent-style-name", "Standard");
 
-                WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
+		WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
 
-		if (mTextStyleHash.find(sKey) == mTextStyleHash.end()) {
+		if (mTextStyleHash.find(sKey) == mTextStyleHash.end())
+		{
 			WPXString sName;
 			sName.sprintf("S%i", mTextStyleHash.size()); 
-			
+
 			pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
-	
+
 			mTextStyleHash[sKey] = pStyle;
 		}
 		else
@@ -523,56 +601,56 @@
 	// create a document element corresponding to the paragraph, and append it to our list of document elements
 	TagOpenElement *pParagraphOpenElement = new TagOpenElement("text:p");
 	pParagraphOpenElement->addAttribute("text:style-name", pStyle->getName());
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pParagraphOpenElement));
+	mpCurrentContentElements->push_back(pParagraphOpenElement);
 }
 
 void DocumentCollector::closeParagraph()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:p")));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
 }
 
 void DocumentCollector::openSpan(const WPXPropertyList &propList)
 {
-        if (propList["style:font-name"])
-                _allocateFontName(propList["style:font-name"]->getStr());
+	if (propList["style:font-name"])
+		_allocateFontName(propList["style:font-name"]->getStr());
 	WPXString sSpanHashKey = propListToStyleKey(propList);
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Span Hash Key: %s\n", sSpanHashKey.cstr()));
 
 	// Get the style
-        WPXString sName;
+	WPXString sName;
 	if (mSpanStyleHash.find(sSpanHashKey) == mSpanStyleHash.end())
-        {
+	{
 		// allocate a new paragraph style
 		sName.sprintf("Span%i", mSpanStyleHash.size());
-		SpanStyle *pStyle = new SpanStyle(sName.cstr(), propList);                
+		SpanStyle *pStyle = new SpanStyle(sName.cstr(), propList);
 
 		mSpanStyleHash[sSpanHashKey] = pStyle;
 	}
 	else 
-        {
+	{
 		sName.sprintf("%s", mSpanStyleHash.find(sSpanHashKey)->second->getName().cstr());
 	}
 
 	// create a document element corresponding to the paragraph, and append it to our list of document elements
 	TagOpenElement *pSpanOpenElement = new TagOpenElement("text:span");
 	pSpanOpenElement->addAttribute("text:style-name", sName.cstr());
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pSpanOpenElement));
+	mpCurrentContentElements->push_back(pSpanOpenElement);
 }
 
 void DocumentCollector::closeSpan()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:span")));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:span"));
 }
 
 void DocumentCollector::defineOrderedListLevel(const WPXPropertyList &propList)
 {
-        int id = 0;
-        if (propList["libwpd:id"])
-                id = propList["libwpd:id"]->getInt();
+	int id = 0;
+	if (propList["libwpd:id"])
+		id = propList["libwpd:id"]->getInt();
 
  	OrderedListStyle *pOrderedListStyle = NULL;
-	if (mpCurrentListStyle && mpCurrentListStyle->getListID() == id)
-		pOrderedListStyle = static_cast<OrderedListStyle *>(mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
+	if (mWriterListStates.top().mpCurrentListStyle && mWriterListStates.top().mpCurrentListStyle->getListID() == id)
+		pOrderedListStyle = static_cast<OrderedListStyle *>(mWriterListStates.top().mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
 
 	// this rather appalling conditional makes sure we only start a new list (rather than continue an old
 	// one) if: (1) we have no prior list OR (2) the prior list is actually definitively different
@@ -580,168 +658,174 @@
 	// is starting a new list at level 1 (and only level 1)
 	if (pOrderedListStyle == NULL || pOrderedListStyle->getListID() != id  ||
 	    (propList["libwpd:level"] && propList["libwpd:level"]->getInt()==1 && 
-             (propList["text:start-value"] && (unsigned int)(propList["text:start-value"]->getInt()) != (miLastListNumber+1))))
+	     (propList["text:start-value"] && (unsigned)propList["text:start-value"]->getInt() != (mWriterListStates.top().miLastListNumber+1))))
 	{
 		WRITER_DEBUG_MSG(("Attempting to create a new ordered list style (listid: %i)\n", id));
 		WPXString sName;
 		sName.sprintf("OL%i", miNumListStyles);
 		miNumListStyles++;
-		pOrderedListStyle = new OrderedListStyle(sName.cstr(), propList["libwpd:id"]->getInt());
-		mListStyles.push_back(static_cast<ListStyle *>(pOrderedListStyle));
-		mpCurrentListStyle = static_cast<ListStyle *>(pOrderedListStyle);
-		mbListContinueNumbering = false;
-		miLastListNumber = 0;
+		pOrderedListStyle = new OrderedListStyle(sName.cstr(), id);
+		mListStyles.push_back(pOrderedListStyle);
+		mWriterListStates.top().mpCurrentListStyle = pOrderedListStyle;
+		mWriterListStates.top().mbListContinueNumbering = false;
+		mWriterListStates.top().miLastListNumber = 0;
 	}
 	else
-		mbListContinueNumbering = true;
+		mWriterListStates.top().mbListContinueNumbering = true;
 
 	// Iterate through ALL list styles with the same WordPerfect list id and define a level if it is not already defined
 	// This solves certain problems with lists that start and finish without reaching certain levels and then begin again
 	// and reach those levels. See gradguide0405_PC.wpd in the regression suite
 	for (std::vector<ListStyle *>::iterator iterOrderedListStyles = mListStyles.begin(); iterOrderedListStyles != mListStyles.end(); iterOrderedListStyles++)
 	{
-		if ((* iterOrderedListStyles)->getListID() == propList["libwpd:id"]->getInt())
+		if ((* iterOrderedListStyles)->getListID() == id)
 			(* iterOrderedListStyles)->updateListLevel((propList["libwpd:level"]->getInt() - 1), propList);
 	}
 }
 
 void DocumentCollector::defineUnorderedListLevel(const WPXPropertyList &propList)
 {
-        int id = 0;
-        if (propList["libwpd:id"])
-                id = propList["libwpd:id"]->getInt();
+	int id = 0;
+	if (propList["libwpd:id"])
+		id = propList["libwpd:id"]->getInt();
 
  	UnorderedListStyle *pUnorderedListStyle = NULL;
-	if (mpCurrentListStyle && mpCurrentListStyle->getListID() == id)
-		pUnorderedListStyle = static_cast<UnorderedListStyle *>(mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
+	if (mWriterListStates.top().mpCurrentListStyle && mWriterListStates.top().mpCurrentListStyle->getListID() == id)
+		pUnorderedListStyle = static_cast<UnorderedListStyle *>(mWriterListStates.top().mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
 
 	if (pUnorderedListStyle == NULL) {
 		WRITER_DEBUG_MSG(("Attempting to create a new unordered list style (listid: %i)\n", id));
 		WPXString sName;
 		sName.sprintf("UL%i", miNumListStyles);
+		miNumListStyles++;
 		pUnorderedListStyle = new UnorderedListStyle(sName.cstr(), id);
-		mListStyles.push_back(static_cast<ListStyle *>(pUnorderedListStyle));
-		mpCurrentListStyle = static_cast<ListStyle *>(pUnorderedListStyle);
+		mListStyles.push_back(pUnorderedListStyle);
+		mWriterListStates.top().mpCurrentListStyle = pUnorderedListStyle;
 	}
 
 	// See comment in DocumentCollector::defineOrderedListLevel
 	for (std::vector<ListStyle *>::iterator iterUnorderedListStyles = mListStyles.begin(); iterUnorderedListStyles != mListStyles.end(); iterUnorderedListStyles++)
 	{
-		if ((* iterUnorderedListStyles)->getListID() == propList["libwpd:id"]->getInt())
+		if ((* iterUnorderedListStyles)->getListID() == id)
 			(* iterUnorderedListStyles)->updateListLevel((propList["libwpd:level"]->getInt() - 1), propList);
 	}
 }
 
 void DocumentCollector::openOrderedListLevel(const WPXPropertyList & /* propList */)
 {
-	miCurrentListLevel++;
-	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:ordered-list");
+	if (mWriterListStates.top().mbListElementParagraphOpened)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
+		mWriterListStates.top().mbListElementParagraphOpened = false;
+	}
+	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:list");
 	_openListLevel(pListLevelOpenElement);
 
-	if (mbListContinueNumbering) {
+	if (mWriterListStates.top().mbListContinueNumbering) {
 		pListLevelOpenElement->addAttribute("text:continue-numbering", "true");
 	}
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pListLevelOpenElement));
+	mpCurrentContentElements->push_back(pListLevelOpenElement);
 }
 
 void DocumentCollector::openUnorderedListLevel(const WPXPropertyList & /* propList */)
 {
-	miCurrentListLevel++;
-	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:unordered-list");
+	if (mWriterListStates.top().mbListElementParagraphOpened)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
+		mWriterListStates.top().mbListElementParagraphOpened = false;
+	}
+	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:list");
 	_openListLevel(pListLevelOpenElement);
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pListLevelOpenElement));
+	mpCurrentContentElements->push_back(pListLevelOpenElement);
 }
 
 void DocumentCollector::_openListLevel(TagOpenElement *pListLevelOpenElement)
 {
-  	if (!mbListElementOpened && miCurrentListLevel > 1)
-  	{
-  		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:list-item")));
-  	}
-	else if (mbListElementParagraphOpened)
+	if (!mWriterListStates.top().mbListElementOpened.empty() &&
+		!mWriterListStates.top().mbListElementOpened.top())
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:p")));
-		mbListElementParagraphOpened = false;
+		mpCurrentContentElements->push_back(new TagOpenElement("text:list-item"));
+		mWriterListStates.top().mbListElementOpened.top() = true;
 	}
 
-	if (miCurrentListLevel==1) {
-		pListLevelOpenElement->addAttribute("text:style-name", mpCurrentListStyle->getName());
+	mWriterListStates.top().mbListElementOpened.push(false);
+	if (mWriterListStates.top().mbListElementOpened.size() == 1) {
+		pListLevelOpenElement->addAttribute("text:style-name", mWriterListStates.top().mpCurrentListStyle->getName());
 	}
-
-	mbListElementOpened = false;
 }
 
 void DocumentCollector::closeOrderedListLevel()
 {
-	_closeListLevel("ordered-list");
+	_closeListLevel();
 }
 
 void DocumentCollector::closeUnorderedListLevel()
 {
-	_closeListLevel("unordered-list");
+	_closeListLevel();
 }
 
-void DocumentCollector::_closeListLevel(const char *szListType)
+void DocumentCollector::_closeListLevel()
 {
-	if (mbListElementOpened)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:list-item")));
-
-	miCurrentListLevel--;
+	if (mWriterListStates.top().mbListElementOpened.top())
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:list-item"));
+		mWriterListStates.top().mbListElementOpened.top() = false;
+	}
 
-	WPXString sCloseElement;
-	sCloseElement.sprintf("text:%s", szListType);
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement(sCloseElement.cstr())));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:list"));
 
-	if (miCurrentListLevel > 0)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:list-item")));
-	mbListElementOpened = false;
+	if (!mWriterListStates.top().mbListElementOpened.empty())
+	{
+		mWriterListStates.top().mbListElementOpened.pop();
+	}
 }
 
 void DocumentCollector::openListElement(const WPXPropertyList &propList, const WPXPropertyListVector &tabStops)
 {
-	miLastListLevel = miCurrentListLevel;
-	if (miCurrentListLevel == 1)
-		miLastListNumber++;
+	mWriterListStates.top().miLastListLevel = mWriterListStates.top().miCurrentListLevel;
+	if (mWriterListStates.top().miCurrentListLevel == 1)
+		mWriterListStates.top().miLastListNumber++;
 
-	if (mbListElementOpened)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:list-item")));
+	if (mWriterListStates.top().mbListElementOpened.top())
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:list-item"));
+		mWriterListStates.top().mbListElementOpened.top() = false;
+	}
 
 	ParagraphStyle *pStyle = NULL;
 
 	WPXPropertyList *pPersistPropList = new WPXPropertyList(propList);
-	pPersistPropList->insert("style:list-style-name", mpCurrentListStyle->getName());
+	pPersistPropList->insert("style:list-style-name", mWriterListStates.top().mpCurrentListStyle->getName());
 	pPersistPropList->insert("style:parent-style-name", "Standard");
 
-        WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
+	WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
 
-        if (mTextStyleHash.find(sKey) == mTextStyleHash.end()) 
-        {
-                WPXString sName;
-                sName.sprintf("S%i", mTextStyleHash.size()); 
-		
-                pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
-                
-                mTextStyleHash[sKey] = pStyle;
-        }
-        else
-        {
-                pStyle = mTextStyleHash[sKey];
-                delete pPersistPropList;
-        }
+	if (mTextStyleHash.find(sKey) == mTextStyleHash.end()) 
+	{
+		WPXString sName;
+		sName.sprintf("S%i", mTextStyleHash.size()); 
 
-	TagOpenElement *pOpenListElement = new TagOpenElement("text:list-item");
-	TagOpenElement *pOpenListElementParagraph = new TagOpenElement("text:p");
+		pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
+
+		mTextStyleHash[sKey] = pStyle;
+	}
+	else
+	{
+		pStyle = mTextStyleHash[sKey];
+		delete pPersistPropList;
+	}
+
+	mpCurrentContentElements->push_back(new TagOpenElement("text:list-item"));
 
+	TagOpenElement *pOpenListElementParagraph = new TagOpenElement("text:p");
 	pOpenListElementParagraph->addAttribute("text:style-name", pStyle->getName());
+	mpCurrentContentElements->push_back(pOpenListElementParagraph);
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenListElement));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenListElementParagraph));
-		
-	mbListElementOpened = true;
-	mbListElementParagraphOpened = true;
-	mbListContinueNumbering = false;
+	mWriterListStates.top().mbListElementOpened.top() = true;
+	mWriterListStates.top().mbListElementParagraphOpened = true;
+	mWriterListStates.top().mbListContinueNumbering = false;
 }
 
 void DocumentCollector::closeListElement()
@@ -750,183 +834,234 @@
 	// could contain another list level in OOo's implementation of lists). that is done in the closeListLevel
 	// code (or when we open another list element)
 
-	if (mbListElementParagraphOpened)
+	if (mWriterListStates.top().mbListElementParagraphOpened)
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:p")));
-		mbListElementParagraphOpened = false;
+		mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
+		mWriterListStates.top().mbListElementParagraphOpened = false;
 	}
 }
 
 void DocumentCollector::openFootnote(const WPXPropertyList &propList)
 {
-	TagOpenElement *pOpenFootNote = new TagOpenElement("text:footnote");
+	mWriterListStates.push(WriterListState());
+	TagOpenElement *pOpenFootNote = new TagOpenElement("text:note");
+	pOpenFootNote->addAttribute("text:note-class", "footnote");
 	if (propList["libwpd:number"])
 	{
 		WPXString tmpString("ftn");
 		tmpString.append(propList["libwpd:number"]->getStr());
 		pOpenFootNote->addAttribute("text:id", tmpString);
 	}
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenFootNote));
+	mpCurrentContentElements->push_back(pOpenFootNote);
+
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-citation"));
+	if (propList["libwpd:number"])
+		mpCurrentContentElements->push_back(new CharDataElement(propList["libwpd:number"]->getStr().cstr()));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-citation"));
+
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-body"));
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:footnote-citation")));
-        if (propList["libwpd:number"])
-                mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new CharDataElement(propList["libwpd:number"]->getStr().cstr())));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:footnote-citation")));
-
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:footnote-body")));
-	
-	mWriterDocumentState.mbInNote = true;
+	mWriterDocumentStates.top().mbInNote = true;
 }
 
 void DocumentCollector::closeFootnote()
 {
-	mWriterDocumentState.mbInNote = false;
+	mWriterDocumentStates.top().mbInNote = false;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:footnote-body")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:footnote")));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-body"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note"));
 }
 
 void DocumentCollector::openEndnote(const WPXPropertyList &propList)
 {
-	TagOpenElement *pOpenEndNote = new TagOpenElement("text:endnote");
+	mWriterListStates.push(WriterListState());
+	TagOpenElement *pOpenEndNote = new TagOpenElement("text:note");
+	pOpenEndNote->addAttribute("text:note-class", "endnote");
 	if (propList["libwpd:number"])
 	{
 		WPXString tmpString("edn");
 		tmpString.append(propList["libwpd:number"]->getStr());
 		pOpenEndNote->addAttribute("text:id", tmpString);
 	}
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenEndNote));
+	mpCurrentContentElements->push_back(pOpenEndNote);
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:endnote-citation")));
-        if (propList["libwpd:number"])
-                mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new CharDataElement(propList["libwpd:number"]->getStr().cstr())));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:endnote-citation")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-citation"));
+	if (propList["libwpd:number"])
+		mpCurrentContentElements->push_back(new CharDataElement(propList["libwpd:number"]->getStr().cstr()));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-citation"));
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:endnote-body")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-body"));
 
+	mWriterDocumentStates.top().mbInNote = true;
 }
+
 void DocumentCollector::closeEndnote()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:endnote-body")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:endnote")));
+	mWriterDocumentStates.top().mbInNote = false;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
+
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-body"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note"));
 }
 
-void DocumentCollector::openTable(const WPXPropertyList &propList, const WPXPropertyListVector &columns)
+void DocumentCollector::openComment(const WPXPropertyList & /* propList */)
 {
-	WPXString sTableName;
-	sTableName.sprintf("Table%i", mTableStyles.size());
+	mWriterListStates.push(WriterListState());
+	mpCurrentContentElements->push_back(new TagOpenElement("office:annotation"));
 
-	// FIXME: we base the table style off of the page's margin left, ignoring (potential) wordperfect margin
-	// state which is transmitted inside the page. could this lead to unacceptable behaviour?
-        // WLACH_REFACTORING: characterize this behaviour, probably should nip it at the bud within libwpd
-	TableStyle *pTableStyle = new TableStyle(propList, columns, sTableName.cstr());
+	mWriterDocumentStates.top().mbInNote = true;
+}
+
+void DocumentCollector::closeComment()
+{
+	mWriterDocumentStates.top().mbInNote = false;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
 
-	if (mWriterDocumentState.mbFirstElement && mpCurrentContentElements == &mBodyElements)
+	mpCurrentContentElements->push_back(new TagCloseElement("office:annotation"));
+}
+
+void DocumentCollector::openTable(const WPXPropertyList &propList, const WPXPropertyListVector &columns)
+{
+	if (!mWriterDocumentStates.top().mbInNote)
 	{
-		WPXString sMasterPageName("Page Style 1");
-		pTableStyle->setMasterPageName(sMasterPageName);
-		mWriterDocumentState.mbFirstElement = false;
-	}
+		WPXString sTableName;
+		sTableName.sprintf("Table%i", mTableStyles.size());
+
+		// FIXME: we base the table style off of the page's margin left, ignoring (potential) wordperfect margin
+		// state which is transmitted inside the page. could this lead to unacceptable behaviour?
+		// WLACH_REFACTORING: characterize this behaviour, probably should nip it at the bud within libwpd
+		TableStyle *pTableStyle = new TableStyle(propList, columns, sTableName.cstr());
 
-	mTableStyles.push_back(pTableStyle);
+		if (mWriterDocumentStates.top().mbFirstElement && mpCurrentContentElements == &mBodyElements)
+		{
+			WPXString sMasterPageName("Page_Style_1");
+			pTableStyle->setMasterPageName(sMasterPageName);
+			mWriterDocumentStates.top().mbFirstElement = false;
+		}
 
-	mpCurrentTableStyle = pTableStyle;
+		mTableStyles.push_back(pTableStyle);
 
-	TagOpenElement *pTableOpenElement = new TagOpenElement("table:table");
+		mpCurrentTableStyle = pTableStyle;
 
-	pTableOpenElement->addAttribute("table:name", sTableName.cstr());
-	pTableOpenElement->addAttribute("table:style-name", sTableName.cstr());
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pTableOpenElement));
+		TagOpenElement *pTableOpenElement = new TagOpenElement("table:table");
 
-	for (int i=0; i<pTableStyle->getNumColumns(); i++) 
-        {
-		TagOpenElement *pTableColumnOpenElement = new TagOpenElement("table:table-column");
-		WPXString sColumnStyleName;
-		sColumnStyleName.sprintf("%s.Column%i", sTableName.cstr(), (i+1));
-		pTableColumnOpenElement->addAttribute("table:style-name", sColumnStyleName.cstr());
-		mpCurrentContentElements->push_back(pTableColumnOpenElement);
+		pTableOpenElement->addAttribute("table:name", sTableName.cstr());
+		pTableOpenElement->addAttribute("table:style-name", sTableName.cstr());
+		mpCurrentContentElements->push_back(pTableOpenElement);
 
-		TagCloseElement *pTableColumnCloseElement = new TagCloseElement("table:table-column");
-		mpCurrentContentElements->push_back(pTableColumnCloseElement);
+		for (int i=0; i<pTableStyle->getNumColumns(); i++) 
+		{
+			TagOpenElement *pTableColumnOpenElement = new TagOpenElement("table:table-column");
+			WPXString sColumnStyleName;
+			sColumnStyleName.sprintf("%s.Column%i", sTableName.cstr(), (i+1));
+			pTableColumnOpenElement->addAttribute("table:style-name", sColumnStyleName.cstr());
+			mpCurrentContentElements->push_back(pTableColumnOpenElement);
+
+			TagCloseElement *pTableColumnCloseElement = new TagCloseElement("table:table-column");
+			mpCurrentContentElements->push_back(pTableColumnCloseElement);
+		}
 	}
 }
 
 void DocumentCollector::openTableRow(const WPXPropertyList &propList)
 {
-	if (propList["libwpd:is-header-row"] && (propList["libwpd:is-header-row"]->getInt()))
+	if (!mWriterDocumentStates.top().mbInNote)
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("table:table-header-rows")));
-		mWriterDocumentState.mbHeaderRow = true;
-	}
+		if (propList["libwpd:is-header-row"] && (propList["libwpd:is-header-row"]->getInt()))
+		{
+			mpCurrentContentElements->push_back(new TagOpenElement("table:table-header-rows"));
+			mWriterDocumentStates.top().mbHeaderRow = true;
+		}
 
-	WPXString sTableRowStyleName;
-	sTableRowStyleName.sprintf("%s.Row%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableRowStyles());
-	TableRowStyle *pTableRowStyle = new TableRowStyle(propList, sTableRowStyleName.cstr());
-	mpCurrentTableStyle->addTableRowStyle(pTableRowStyle);
-	
-	TagOpenElement *pTableRowOpenElement = new TagOpenElement("table:table-row");
-	pTableRowOpenElement->addAttribute("table:style-name", sTableRowStyleName);
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pTableRowOpenElement));
+		WPXString sTableRowStyleName;
+		sTableRowStyleName.sprintf("%s.Row%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableRowStyles());
+		TableRowStyle *pTableRowStyle = new TableRowStyle(propList, sTableRowStyleName.cstr());
+		mpCurrentTableStyle->addTableRowStyle(pTableRowStyle);
+
+		TagOpenElement *pTableRowOpenElement = new TagOpenElement("table:table-row");
+		pTableRowOpenElement->addAttribute("table:style-name", sTableRowStyleName);
+		mpCurrentContentElements->push_back(pTableRowOpenElement);
+	}
 }
 
 void DocumentCollector::closeTableRow()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table-row")));
-	if (mWriterDocumentState.mbHeaderRow)
+	if (!mWriterDocumentStates.top().mbInNote)
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table-header-rows")));
-		mWriterDocumentState.mbHeaderRow = false;
+		mpCurrentContentElements->push_back(new TagCloseElement("table:table-row"));
+		if (mWriterDocumentStates.top().mbHeaderRow)
+		{
+			mpCurrentContentElements->push_back(new TagCloseElement("table:table-header-rows"));
+			mWriterDocumentStates.top().mbHeaderRow = false;
+		}
 	}
 }
 
 void DocumentCollector::openTableCell(const WPXPropertyList &propList)
 {
-	WPXString sTableCellStyleName;
-	sTableCellStyleName.sprintf( "%s.Cell%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableCellStyles());
-	TableCellStyle *pTableCellStyle = new TableCellStyle(propList, sTableCellStyleName.cstr());
-	mpCurrentTableStyle->addTableCellStyle(pTableCellStyle);
-
-	TagOpenElement *pTableCellOpenElement = new TagOpenElement("table:table-cell");
-	pTableCellOpenElement->addAttribute("table:style-name", sTableCellStyleName);
-	if (propList["table:number-columns-spanned"])
-                pTableCellOpenElement->addAttribute("table:number-columns-spanned", 
-                                                    propList["table:number-columns-spanned"]->getStr().cstr());
-        if (propList["table:number-rows-spanned"])
-                pTableCellOpenElement->addAttribute("table:number-rows-spanned",
-                                                    propList["table:number-rows-spanned"]->getStr().cstr());
-	pTableCellOpenElement->addAttribute("table:value-type", "string");
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pTableCellOpenElement));
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		WPXString sTableCellStyleName;
+		sTableCellStyleName.sprintf( "%s.Cell%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableCellStyles());
+		TableCellStyle *pTableCellStyle = new TableCellStyle(propList, sTableCellStyleName.cstr());
+		mpCurrentTableStyle->addTableCellStyle(pTableCellStyle);
+
+		TagOpenElement *pTableCellOpenElement = new TagOpenElement("table:table-cell");
+		pTableCellOpenElement->addAttribute("table:style-name", sTableCellStyleName);
+		if (propList["table:number-columns-spanned"])
+			pTableCellOpenElement->addAttribute("table:number-columns-spanned", 
+							    propList["table:number-columns-spanned"]->getStr().cstr());
+		if (propList["table:number-rows-spanned"])
+			pTableCellOpenElement->addAttribute("table:number-rows-spanned",
+							    propList["table:number-rows-spanned"]->getStr().cstr());
+		// pTableCellOpenElement->addAttribute("table:value-type", "string");
+		mpCurrentContentElements->push_back(pTableCellOpenElement);
 
-	mWriterDocumentState.mbTableCellOpened = true;
+		mWriterDocumentStates.top().mbTableCellOpened = true;
+	}
 }
 
 void DocumentCollector::closeTableCell()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table-cell")));
-	mWriterDocumentState.mbTableCellOpened = false;
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("table:table-cell"));
+		mWriterDocumentStates.top().mbTableCellOpened = false;
+	}
 }
 
 void DocumentCollector::insertCoveredTableCell(const WPXPropertyList & /* propList */)
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("table:covered-table-cell")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:covered-table-cell")));
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		mpCurrentContentElements->push_back(new TagOpenElement("table:covered-table-cell"));
+		mpCurrentContentElements->push_back(new TagCloseElement("table:covered-table-cell"));
+	}
 }
 
 void DocumentCollector::closeTable()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table")));
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("table:table"));
+	}
 }
 
+
 void DocumentCollector::insertTab()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:tab-stop")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:tab-stop")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:tab"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:tab"));
 }
 
 void DocumentCollector::insertLineBreak()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:line-break")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:line-break")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:line-break"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:line-break"));
 }
 
 void DocumentCollector::insertText(const WPXString &text)
@@ -934,3 +1069,195 @@
 	DocumentElement *pText = new TextElement(text);
 	mpCurrentContentElements->push_back(pText);
 }
+
+void DocumentCollector::openFrame(const WPXPropertyList &propList)
+{
+	mWriterListStates.push(WriterListState());
+
+	// First, let's create a Frame Style for this box
+	TagOpenElement *frameStyleOpenElement = new TagOpenElement("style:style");
+	WPXString frameStyleName;
+	frameStyleName.sprintf("GraphicFrame_%i", miObjectNumber);
+	frameStyleOpenElement->addAttribute("style:name", frameStyleName);
+	frameStyleOpenElement->addAttribute("style:family", "graphic");
+
+	mFrameStyles.push_back(frameStyleOpenElement);
+
+	TagOpenElement *frameStylePropertiesOpenElement = new TagOpenElement("style:graphic-properties");
+
+	if (propList["text:anchor-type"])
+		frameStylePropertiesOpenElement->addAttribute("text:anchor-type", propList["text:anchor-type"]->getStr());
+	else
+		frameStylePropertiesOpenElement->addAttribute("text:anchor-type","paragraph");
+
+	if (propList["text:anchor-page-number"])
+		frameStylePropertiesOpenElement->addAttribute("text:anchor-page-number", propList["text:anchor-page-number"]->getStr());
+
+	if (propList["svg:x"])
+		frameStylePropertiesOpenElement->addAttribute("svg:x", propList["svg:x"]->getStr());
+
+	if (propList["svg:y"])
+		frameStylePropertiesOpenElement->addAttribute("svg:y", propList["svg:y"]->getStr());
+
+	if (propList["svg:width"])
+		frameStylePropertiesOpenElement->addAttribute("svg:width", propList["svg:width"]->getStr());
+
+	if (propList["svg:height"])
+		frameStylePropertiesOpenElement->addAttribute("svg:height", propList["svg:height"]->getStr());
+
+	if (propList["style:rel-width"])
+		frameStylePropertiesOpenElement->addAttribute("style:rel-width", propList["style:rel-width"]->getStr());
+
+	if (propList["style:rel-height"])
+		frameStylePropertiesOpenElement->addAttribute("style:rel-height", propList["style:rel-height"]->getStr());
+
+	if (propList["fo:max-width"])
+		frameStylePropertiesOpenElement->addAttribute("fo:max-width", propList["fo:max-width"]->getStr());
+
+	if (propList["fo:max-height"])
+		frameStylePropertiesOpenElement->addAttribute("fo:max-height", propList["fo:max-height"]->getStr());
+
+	mFrameStyles.push_back(frameStylePropertiesOpenElement);
+
+	mFrameStyles.push_back(new TagCloseElement("style:graphic-properties"));
+
+	mFrameStyles.push_back(new TagCloseElement("style:style"));
+
+	// Now, let's create an automatic style for this frame
+	TagOpenElement *frameAutomaticStyleElement = new TagOpenElement("style:style");
+	WPXString frameAutomaticStyleName;
+	frameAutomaticStyleName.sprintf("fr%i", miObjectNumber);
+	frameAutomaticStyleElement->addAttribute("style:name", frameAutomaticStyleName);
+	frameAutomaticStyleElement->addAttribute("style:family", "graphic");
+	frameAutomaticStyleElement->addAttribute("style:parent-style-name", frameStyleName);
+
+	mFrameAutomaticStyles.push_back(frameAutomaticStyleElement);
+
+	TagOpenElement *frameAutomaticStylePropertiesElement = new TagOpenElement("style:graphic-properties");
+	if (propList["style:horizontal-pos"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-pos", propList["style:horizontal-pos"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-pos", "left");
+
+	if (propList["style:horizontal-rel"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-rel", propList["style:horizontal-rel"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-rel", "paragraph");
+
+	if (propList["style:vertical-pos"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-pos", propList["style:vertical-pos"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-pos", "top");
+
+	if (propList["style:vertical-rel"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-rel", propList["style:vertical-rel"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-rel", "page-content");
+
+	if (propList["fo:max-width"])
+		frameAutomaticStylePropertiesElement->addAttribute("fo:max-width", propList["fo:max-width"]->getStr());
+
+	if (propList["fo:max-height"])
+		frameAutomaticStylePropertiesElement->addAttribute("fo:max-height", propList["fo:max-height"]->getStr());
+
+	frameAutomaticStylePropertiesElement->addAttribute("draw:ole-draw-aspect", "1");
+
+	mFrameAutomaticStyles.push_back(frameAutomaticStylePropertiesElement);
+
+	mFrameAutomaticStyles.push_back(new TagCloseElement("style:graphic-properties"));
+
+	mFrameAutomaticStyles.push_back(new TagCloseElement("style:style"));
+
+	// And write the frame itself
+	TagOpenElement *drawFrameOpenElement = new TagOpenElement("draw:frame");
+
+	drawFrameOpenElement->addAttribute("draw:style-name", frameAutomaticStyleName);
+	WPXString objectName;
+	objectName.sprintf("Object%i", miObjectNumber++);
+	drawFrameOpenElement->addAttribute("draw:name", objectName);
+	if (propList["text:anchor-type"])
+		drawFrameOpenElement->addAttribute("text:anchor-type", propList["text:anchor-type"]->getStr());
+	else
+		drawFrameOpenElement->addAttribute("text:anchor-type","paragraph");
+
+	if (propList["text:anchor-page-number"])
+		drawFrameOpenElement->addAttribute("text:anchor-page-number", propList["text:anchor-page-number"]->getStr());
+
+	if (propList["svg:x"])
+		drawFrameOpenElement->addAttribute("svg:x", propList["svg:x"]->getStr());
+
+	if (propList["svg:y"])
+		drawFrameOpenElement->addAttribute("svg:y", propList["svg:y"]->getStr());
+
+	if (propList["svg:width"])
+		drawFrameOpenElement->addAttribute("svg:width", propList["svg:width"]->getStr());
+
+	if (propList["svg:height"])
+		drawFrameOpenElement->addAttribute("svg:height", propList["svg:height"]->getStr());
+
+	if (propList["style:rel-width"])
+		drawFrameOpenElement->addAttribute("style:rel-width", propList["style:rel-width"]->getStr());
+
+	if (propList["style:rel-height"])
+		drawFrameOpenElement->addAttribute("style:rel-height", propList["style:rel-height"]->getStr());
+
+	mpCurrentContentElements->push_back(drawFrameOpenElement);
+
+	mWriterDocumentStates.top().mbInFrame = true;
+}
+
+void DocumentCollector::closeFrame()
+{
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
+
+	mpCurrentContentElements->push_back(new TagCloseElement("draw:frame"));
+
+	mWriterDocumentStates.top().mbInFrame = false;
+}
+
+void DocumentCollector::insertBinaryObject(const WPXPropertyList &propList, const WPXBinaryData *object)
+{
+	if (!object || !object->size())
+		return;
+	if (!mWriterDocumentStates.top().mbInFrame) // Embedded objects without a frame simply don't make sense for us
+		return;
+	if (!propList["libwpd:mimetype"] || !(propList["libwpd:mimetype"]->getStr() == "image/x-wpg"))
+		return;
+
+	std::vector<DocumentElement *> tmpContentElements;
+	InternalHandler tmpHandler(&tmpContentElements);
+	OdgExporter exporter(&tmpHandler, true);
+
+	if (libwpg::WPGraphics::parse(const_cast<WPXInputStream *>(object->getDataStream()), &exporter) && !tmpContentElements.empty())
+	{
+		mpCurrentContentElements->push_back(new TagOpenElement("draw:object"));
+		for (std::vector<DocumentElement *>::const_iterator iter = tmpContentElements.begin(); iter != tmpContentElements.end(); iter++)
+			mpCurrentContentElements->push_back(*iter);
+		mpCurrentContentElements->push_back(new TagCloseElement("draw:object"));
+	}
+}
+
+void DocumentCollector::openTextBox(const WPXPropertyList & /* propList */)
+{
+	if (!mWriterDocumentStates.top().mbInFrame) // Text box without a frame simply doesn't make sense for us
+		return;
+	mWriterListStates.push(WriterListState());
+	mWriterDocumentStates.push(WriterDocumentState());
+	mpCurrentContentElements->push_back(new TagOpenElement("draw:text-box"));
+	mWriterDocumentStates.top().mbInTextBox = true;
+	mWriterDocumentStates.top().mbFirstElement = false;
+}
+
+void DocumentCollector::closeTextBox()
+{
+	if (!mWriterDocumentStates.top().mbInTextBox)
+		return;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
+	if (mWriterDocumentStates.size() > 1)
+		mWriterDocumentStates.pop();
+
+	mpCurrentContentElements->push_back(new TagCloseElement("draw:text-box"));
+}
+
--- writerperfect/source/filter/DocumentCollector.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/DocumentCollector.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -45,8 +45,9 @@
 #include <stack>
 #include <string.h>
 
+#include "DocumentHandlerInterface.hxx"
+
 class DocumentElement;
-class DocumentHandler;
 class TagOpenElement;
 class FontStyle;
 class ListStyle;
@@ -61,33 +62,50 @@
 struct _WriterDocumentState
 {
 	_WriterDocumentState();
-
+		
 	bool mbFirstElement;
 	bool mbInFakeSection;
 	bool mbListElementOpenedAtCurrentLevel;
 	bool mbTableCellOpened;
 	bool mbHeaderRow;
 	bool mbInNote;
+	bool mbInTextBox;
+	bool mbInFrame;
+};
+
+// list state
+typedef struct _WriterListState WriterListState;
+struct _WriterListState
+{
+	_WriterListState();
+
+	ListStyle *mpCurrentListStyle;
+	unsigned int miCurrentListLevel;
+	unsigned int miLastListLevel;
+	unsigned int miLastListNumber;
+	bool mbListContinueNumbering;
+	bool mbListElementParagraphOpened;
+	std::stack<bool> mbListElementOpened;
 };
 
 enum WriterListType { unordered, ordered };
 
 struct ltstr
 {
-  bool operator()(const WPXString & s1, const WPXString & s2) const
-  {
-    return strcmp(s1.cstr(), s2.cstr()) < 0;
-  }
+	bool operator()(const WPXString & s1, const WPXString & s2) const
+	{
+		return strcmp(s1.cstr(), s2.cstr()) < 0;
+	}
 };
 
-class DocumentCollector : public WPXHLListenerImpl
+class DocumentCollector : public WPXDocumentInterface
 {
 public:
-	DocumentCollector(WPSInputStream *pInput, DocumentHandler *pHandler);
+	DocumentCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler);
 	virtual ~DocumentCollector();
 	bool filter();
 
- 	virtual void setDocumentMetaData(const WPXPropertyList & /* propList */) {}
+ 	virtual void setDocumentMetaData(const WPXPropertyList &propList);
 	virtual void startDocument() {}
 	virtual void endDocument() {}
 
@@ -126,6 +144,10 @@
 	virtual void closeFootnote();
 	virtual void openEndnote(const WPXPropertyList &propList);
 	virtual void closeEndnote();
+	virtual void openComment(const WPXPropertyList &propList);
+	virtual void closeComment();
+	virtual void openTextBox(const WPXPropertyList &propList);
+	virtual void closeTextBox();
 
  	virtual void openTable(const WPXPropertyList &propList, const WPXPropertyListVector &columns);
  	virtual void openTableRow(const WPXPropertyList &propList);
@@ -134,25 +156,33 @@
 	virtual void closeTableCell();
 	virtual void insertCoveredTableCell(const WPXPropertyList &propList);
  	virtual void closeTable();
-	virtual bool parseSourceDocument(WPSInputStream &input) = 0;
+
+	virtual void openFrame(const WPXPropertyList & propList);
+	virtual void closeFrame();
+	
+	virtual void insertBinaryObject(const WPXPropertyList &propList, const WPXBinaryData *object);
+
+	virtual bool parseSourceDocument(WPXInputStream &input) = 0;
 
 protected:
 	void _resetDocumentState();
-	bool _writeTargetDocument(DocumentHandler *pHandler);
-	void _writeDefaultStyles(DocumentHandler *pHandler);
-	void _writeMasterPages(DocumentHandler *pHandler);
-	void _writePageMasters(DocumentHandler *pHandler);
+	bool _writeTargetDocument(DocumentHandlerInterface *pHandler);
+	void _writeDefaultStyles(DocumentHandlerInterface *pHandler);
+	void _writeMasterPages(DocumentHandlerInterface *pHandler);
+	void _writePageLayouts(DocumentHandlerInterface *pHandler);
 	void _allocateFontName(const WPXString &);
 
 private:
 	void _openListLevel(TagOpenElement *pListLevelOpenElement);
-	void _closeListLevel(const char *szListType);
+	void _closeListLevel();
 
-        WPSInputStream *mpInput;
-        DocumentHandler *mpHandler;
+	WPXInputStream *mpInput;
+	DocumentHandlerInterface *mpHandler;
 	bool mbUsed; // whether or not it has been before (you can only use me once!)
 
-	WriterDocumentState mWriterDocumentState;
+	std::stack<WriterDocumentState> mWriterDocumentStates;
+	
+	std::stack<WriterListState> mWriterListStates;
 
 	// paragraph styles
 	std::map<WPXString, ParagraphStyle *, ltstr> mTextStyleHash;
@@ -170,10 +200,18 @@
 
 	// table styles
 	std::vector<TableStyle *> mTableStyles;
+	
+	// frame styles
+	std::vector<DocumentElement *> mFrameStyles;
+	
+	std::vector<DocumentElement *> mFrameAutomaticStyles;
+	
+	// metadata
+	std::vector<DocumentElement *> mMetaData;
 
 	// list styles
 	unsigned int miNumListStyles;
-
+	
 	// style elements
 	std::vector<DocumentElement *> mStylesElements;
 	// content elements
@@ -186,18 +224,18 @@
 	PageSpan *mpCurrentPageSpan;
 	int miNumPageStyles;
 
-	// list styles / state
-	ListStyle *mpCurrentListStyle;
-	unsigned int miCurrentListLevel;
-	unsigned int miLastListLevel;
-	unsigned int miLastListNumber;
+	// list styles
 	std::vector<ListStyle *> mListStyles;
-	bool mbListContinueNumbering;
-	bool mbListElementOpened;
-	bool mbListElementParagraphOpened;
+	
+	// object state
+	unsigned miObjectNumber;
 
 	// table state
 	TableStyle *mpCurrentTableStyle;
+
+	const bool mbIsFlatXML;
+	
+	const char * mpPassword;
 };
 
 #endif
--- writerperfect/source/filter/DocumentElement.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/DocumentElement.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -26,6 +26,7 @@
  */
 
 #include "DocumentElement.hxx"
+#include "DocumentHandler.hxx"
 #include "FilterInternal.hxx"
 #include <string.h>
 
@@ -36,7 +37,7 @@
 	WRITER_DEBUG_MSG(("%s\n", msTagName.cstr()));
 }
 
-void TagOpenElement::write(DocumentHandler *pHandler) const
+void TagOpenElement::write(DocumentHandlerInterface *pHandler) const
 {
 	pHandler->startElement(getTagName().cstr(), maAttrList);
 }
@@ -51,14 +52,14 @@
         maAttrList.insert(szAttributeName, sAttributeValue);
 }
 
-void TagCloseElement::write(DocumentHandler *pHandler) const
+void TagCloseElement::write(DocumentHandlerInterface *pHandler) const
 {
 	WRITER_DEBUG_MSG(("TagCloseElement: write (%s)\n", getTagName().cstr()));
 
 	pHandler->endElement(getTagName().cstr());
 }
 
-void CharDataElement::write(DocumentHandler *pHandler) const
+void CharDataElement::write(DocumentHandlerInterface *pHandler) const
 {
 	WRITER_DEBUG_MSG(("TextElement: write\n"));
 	pHandler->characters(msData);
@@ -71,8 +72,10 @@
 
 // write: writes a text run, appropriately converting spaces to <text:s>
 // elements
-void TextElement::write(DocumentHandler *pHandler) const
+void TextElement::write(DocumentHandlerInterface *pHandler) const
 {
+	if (msTextBuf.len() <= 0)
+		return;
 	WPXPropertyList xBlankAttrList;
         
 	WPXString sTemp;
--- writerperfect/source/filter/DocumentElement.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/DocumentElement.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -21,36 +21,31 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 
 #ifndef _DOCUMENTELEMENT_H
 #define _DOCUMENTELEMENT_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
 #include <libwpd/WPXProperty.h>
 #include <libwpd/WPXString.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include <vector>
 
-#include "DocumentHandler.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class DocumentElement
 {
-public:
+public:	
 	virtual ~DocumentElement() {}
-	virtual void write(DocumentHandler *pHandler) const = 0;
+	virtual void write(DocumentHandlerInterface *pHandler) const = 0;
 	virtual void print() const {}
 };
 
 class TagElement : public DocumentElement
 {
 public:
+	virtual ~TagElement() {}
 	TagElement(const char *szTagName) : msTagName(szTagName) {}
 	const WPXString & getTagName() const { return msTagName; }
 	virtual void print() const;
@@ -62,9 +57,9 @@
 {
 public:
 	TagOpenElement(const char *szTagName) : TagElement(szTagName) {}
-	~TagOpenElement() {}
+	virtual ~TagOpenElement() {}
 	void addAttribute(const char *szAttributeName, const WPXString &sAttributeValue);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	virtual void print () const;
 private:
 	WPXPropertyList maAttrList;
@@ -74,14 +69,16 @@
 {
 public:
 	TagCloseElement(const char *szTagName) : TagElement(szTagName) {}
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~TagCloseElement() {}
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 };
 
 class CharDataElement : public DocumentElement
 {
 public:
 	CharDataElement(const char *sData) : DocumentElement(), msData(sData) {}
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~CharDataElement() {}
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 private:
 	WPXString msData;
 };
@@ -90,10 +87,11 @@
 {
 public:
 	TextElement(const WPXString & sTextBuf);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~TextElement() {}
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 
 private:
 	WPXString msTextBuf;
 };
-
+ 
 #endif
--- writerperfect/source/filter/DocumentHandler.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/DocumentHandler.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -13,10 +13,12 @@
 #pragma warning( pop )
 #endif
 
+#include "DocumentHandlerInterface.hxx"
+
 using com::sun::star::uno::Reference;
 using com::sun::star::xml::sax::XDocumentHandler;
 
-class DocumentHandler
+class DocumentHandler: public DocumentHandlerInterface
 {
 public:
         DocumentHandler(Reference < XDocumentHandler > &xHandler);
--- writerperfect/source/filter/DocumentHandlerInterface.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/DocumentHandlerInterface.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2004 William Lachance (wlach@interlog.com)
+ * Copyright (C) 2004 Net Integration Technologies (http://www.net-itech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ *  Contributor(s): Martin Gallwey (gallwey@sun.com)
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#ifndef _DOCUMENTHANDLERINTERFACE_H
+#define _DOCUMENTHANDLERINTERFACE_H
+#include <libwpd/libwpd.h>
+#include <libwpd/WPXProperty.h>
+#include <libwpd/WPXString.h>
+
+class DocumentHandlerInterface
+{
+public:
+	DocumentHandlerInterface() {};
+	virtual ~DocumentHandlerInterface() {};
+	
+        virtual void startDocument() = 0;
+        virtual void endDocument() = 0;
+        virtual void startElement(const char *psName, const WPXPropertyList &xPropList) = 0;
+        virtual void endElement(const char *psName) = 0;
+        virtual void characters(const WPXString &sCharacters) = 0;
+};
+#endif
--- writerperfect/source/filter/FontStyle.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/FontStyle.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -29,7 +29,7 @@
 #include "DocumentElement.hxx"
 
 FontStyle::FontStyle(const char *psName, const char *psFontFamily) : Style(psName),
-	msFontFamily(psFontFamily),
+	msFontFamily(psFontFamily, true),
 	msFontPitch(IMP_DEFAULT_FONT_PITCH)
 {
 }
@@ -38,13 +38,13 @@
 {
 }
 
-void FontStyle::write(DocumentHandler *pHandler) const
+void FontStyle::write(DocumentHandlerInterface *pHandler) const
 {        
-	TagOpenElement styleOpen("style:font-decl");
+	TagOpenElement styleOpen("style:font-face");
 	styleOpen.addAttribute("style:name", getName());
-	styleOpen.addAttribute("fo:font-family", msFontFamily);
-	styleOpen.addAttribute("style:font-pitch", msFontPitch);
+	styleOpen.addAttribute("svg:font-family", msFontFamily);
+//	styleOpen.addAttribute("style:font-pitch", msFontPitch);
 	styleOpen.write(pHandler);
-	TagCloseElement styleClose("style:font-decl");
+	TagCloseElement styleClose("style:font-face");
 	styleClose.write(pHandler);
 }
--- writerperfect/source/filter/FontStyle.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/FontStyle.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -21,28 +21,23 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _FONTSTYLE_H
 #define _FONTSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class FontStyle : public Style
 {
 public:
 	FontStyle(const char *psName, const char *psFontFamily);
 	~FontStyle();
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	const WPXString &getFontFamily() const { return msFontFamily; }
 
 private:
--- writerperfect/source/filter/GraphicsStyle.cxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/GraphicsStyle.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,40 @@
+/* GraphicsStyle:
+ *
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * For further information visit http://libwpd.sourceforge.net
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#include "GraphicsStyle.hxx"
+#include "WriterProperties.hxx"
+#include "DocumentElement.hxx"
+
+GraphicsStyle::GraphicsStyle(const char *psName) : Style(psName)
+{
+}
+
+GraphicsStyle::~GraphicsStyle() 
+{
+}
+
+void GraphicsStyle::write(DocumentHandlerInterface * /* pHandler */) const
+{        
+}
--- writerperfect/source/filter/GraphicsStyle.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/GraphicsStyle.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,40 @@
+/* GraphicsStyle:
+ *
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * For further information visit http://libwpd.sourceforge.net
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#ifndef _GRAPHICSSTYLE_H
+#define _GRAPHICSSTYLE_H
+
+#include "Style.hxx"
+#include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
+
+class GraphicsStyle : public Style
+{
+public:
+	GraphicsStyle(const char *psName);
+	~GraphicsStyle();
+	virtual void write(DocumentHandlerInterface *pHandler) const;
+};
+#endif
--- writerperfect/source/filter/InternalHandler.cxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/InternalHandler.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+ 
+#include "InternalHandler.hxx"
+
+#include <string.h>
+
+InternalHandler::InternalHandler(std::vector<DocumentElement *> *elements):
+	mpElements(elements)
+{
+}
+
+void InternalHandler::startElement(const char *psName, const WPXPropertyList &xPropList)
+{
+	TagOpenElement	*element = new TagOpenElement(psName);
+	WPXPropertyList::Iter i(xPropList);
+	for (i.rewind(); i.next(); )
+	{
+		// filter out libwpd elements
+		if (strncmp(i.key(), "libwpd", 6) != 0)
+			element->addAttribute(i.key(), i()->getStr());
+	}
+	mpElements->push_back(element);
+}
+
+void InternalHandler::endElement(const char *psName)
+{
+	mpElements->push_back(new TagCloseElement(psName));
+}
+
+void InternalHandler::characters(const WPXString &sCharacters)
+{
+	mpElements->push_back(new CharDataElement(sCharacters.cstr()));
+}
--- writerperfect/source/filter/InternalHandler.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/InternalHandler.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+ 
+#ifndef _INTERNALHANDLER_H
+#define _INTERNALHANDLER_H
+#include <libwpd/libwpd.h>
+#include <libwpd/WPXProperty.h>
+#include <libwpd/WPXString.h>
+#include "DocumentElement.hxx"
+#include "DocumentHandlerInterface.hxx"
+
+class InternalHandler : public DocumentHandlerInterface
+{
+public:
+	InternalHandler(std::vector<DocumentElement *> *elements);
+	~InternalHandler() {};
+	
+	void startDocument() {};
+	void endDocument() {};
+	void startElement(const char *psName, const WPXPropertyList &xPropList);
+	void endElement(const char *psName);
+	void characters(const WPXString &sCharacters);
+private:
+	std::vector<DocumentElement *> *mpElements;
+};
+#endif
--- writerperfect/source/filter/ListStyle.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/ListStyle.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -29,7 +29,7 @@
 #include "DocumentElement.hxx"
 
 OrderedListLevelStyle::OrderedListLevelStyle(const WPXPropertyList &xPropList) : 
-        mPropList(xPropList)
+	mPropList(xPropList)
 {
 }
 
@@ -41,34 +41,44 @@
 	    setListLevel(iLevel, new OrderedListLevelStyle(xPropList));
 }
 
-void OrderedListLevelStyle::write(DocumentHandler *pHandler, int iLevel) const
+void OrderedListLevelStyle::write(DocumentHandlerInterface *pHandler, int iLevel) const
 {
 	WPXString sLevel;
 	sLevel.sprintf("%i", (iLevel+1));
 
 	TagOpenElement listLevelStyleOpen("text:list-level-style-number");
 	listLevelStyleOpen.addAttribute("text:level", sLevel);
-	listLevelStyleOpen.addAttribute("text:style-name", "Numbering Symbols");
-        if (mPropList["style:num-prefix"])
-                listLevelStyleOpen.addAttribute("style:num-prefix", mPropList["style:num-prefix"]->getStr());
-        if (mPropList["style:num-suffix"])
-                listLevelStyleOpen.addAttribute("style:num-suffix", mPropList["style:num-suffix"]->getStr());
-        if (mPropList["style:num-format"])
-                listLevelStyleOpen.addAttribute("style:num-format", mPropList["style:num-format"]->getStr());
-        if (mPropList["text:start-value"])
-                listLevelStyleOpen.addAttribute("text:start-value", mPropList["text:start-value"]->getStr());
+	listLevelStyleOpen.addAttribute("text:style-name", "Numbering_Symbols");
+	if (mPropList["style:num-prefix"])
+	{
+		WPXString sEscapedString(mPropList["style:num-prefix"]->getStr(), true);
+		listLevelStyleOpen.addAttribute("style:num-prefix", sEscapedString);
+	}
+	if (mPropList["style:num-suffix"])
+	{
+		WPXString sEscapedString(mPropList["style:num-suffix"]->getStr(), true);
+		listLevelStyleOpen.addAttribute("style:num-suffix", sEscapedString);
+	}
+	if (mPropList["style:num-format"])
+		listLevelStyleOpen.addAttribute("style:num-format", mPropList["style:num-format"]->getStr());
+	if (mPropList["text:start-value"])
+		// odf as to the version 1.1 does require the text:start-value to be a positive integer, means > 0
+		if (mPropList["text:start-value"]->getInt() > 0)
+			listLevelStyleOpen.addAttribute("text:start-value", mPropList["text:start-value"]->getStr());
+		else
+			listLevelStyleOpen.addAttribute("text:start-value", "1");
 	listLevelStyleOpen.write(pHandler);
 
-	TagOpenElement stylePropertiesOpen("style:properties");
-        if (mPropList["text:space-before"])
-                stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
-	if (mPropList["text:min-label-width"])
+	TagOpenElement stylePropertiesOpen("style:list-level-properties");
+	if (mPropList["text:space-before"] && mPropList["text:space-before"]->getFloat() > 0.0f)
+		stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
+	if (mPropList["text:min-label-width"] && mPropList["text:min-label-width"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-width", mPropList["text:min-label-width"]->getStr());
-	if (mPropList["text:min-label-distance"])
+	if (mPropList["text:min-label-distance"] && mPropList["text:min-label-distance"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-distance", mPropList["text:min-label-distance"]->getStr());
 	stylePropertiesOpen.write(pHandler);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:list-level-properties");
 	pHandler->endElement("text:list-level-style-number");
 }
 
@@ -85,29 +95,38 @@
 		setListLevel(iLevel, new UnorderedListLevelStyle(xPropList));
 }
 
-void UnorderedListLevelStyle::write(DocumentHandler *pHandler, int iLevel) const
+void UnorderedListLevelStyle::write(DocumentHandlerInterface *pHandler, int iLevel) const
 {
 	WPXString sLevel;
 	sLevel.sprintf("%i", (iLevel+1));
 	TagOpenElement listLevelStyleOpen("text:list-level-style-bullet");
 	listLevelStyleOpen.addAttribute("text:level", sLevel);
-	listLevelStyleOpen.addAttribute("text:style-name", "Bullet Symbols");
-	listLevelStyleOpen.addAttribute("style:num-suffice", ".");
-        if (mPropList["text:bullet-char"])
-                listLevelStyleOpen.addAttribute("text:bullet-char", mPropList["text:bullet-char"]->getStr());
+	listLevelStyleOpen.addAttribute("text:style-name", "Bullet_Symbols");
+	if (mPropList["text:bullet-char"] && (mPropList["text:bullet-char"]->getStr().len()))
+	{
+		// The following is needed because the odf format does not accept bullet chars longer than one character
+		WPXString::Iter i(mPropList["text:bullet-char"]->getStr()); i.rewind();
+		WPXString sEscapedString(".");
+		if (i.next())
+			sEscapedString = WPXString(i(), true);
+		listLevelStyleOpen.addAttribute("text:bullet-char", sEscapedString);
+		
+	}
+	else
+		listLevelStyleOpen.addAttribute("text:bullet-char", ".");
 	listLevelStyleOpen.write(pHandler);
 
-	TagOpenElement stylePropertiesOpen("style:properties");
-        if (mPropList["text:space-before"])
-                stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
-	if (mPropList["text:min-label-width"])
+	TagOpenElement stylePropertiesOpen("style:list-level-properties");
+	if (mPropList["text:space-before"] && mPropList["text:space-before"]->getFloat() > 0.0f)
+		stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
+	if (mPropList["text:min-label-width"] && mPropList["text:min-label-width"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-width", mPropList["text:min-label-width"]->getStr());
-	if (mPropList["text:min-label-distance"])
+	if (mPropList["text:min-label-distance"] && mPropList["text:min-label-distance"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-distance", mPropList["text:min-label-distance"]->getStr());
 	stylePropertiesOpen.addAttribute("style:font-name", "OpenSymbol");
 	stylePropertiesOpen.write(pHandler);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:list-level-properties");
 	pHandler->endElement("text:list-level-style-bullet");
 }
 
@@ -146,7 +165,7 @@
 		mppListLevels[iLevel] = iListLevelStyle;
 }
 
-void ListStyle::write(DocumentHandler *pHandler) const
+void ListStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement listStyleOpenElement("text:list-style");
 	listStyleOpenElement.addAttribute("style:name", getName());
--- writerperfect/source/filter/ListStyle.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/ListStyle.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -21,23 +21,18 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _LISTSTYLE_H
 #define _LISTSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #define WP6_NUM_LIST_LEVELS 8 // see WP6FileStructure.h (we shouldn't need to reference this)
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class DocumentElement;
 
@@ -45,14 +40,14 @@
 {
 public:
 	virtual ~ListLevelStyle() {};
-	virtual void write(DocumentHandler *pHandler, int iLevel) const = 0;
+	virtual void write(DocumentHandlerInterface *pHandler, int iLevel) const = 0;
 };
 
 class OrderedListLevelStyle : public ListLevelStyle
 {
 public:
 	OrderedListLevelStyle(const WPXPropertyList &xPropList);
-	void write(DocumentHandler *pHandler, int iLevel) const;
+	void write(DocumentHandlerInterface *pHandler, int iLevel) const;
 private:
         WPXPropertyList mPropList;
 };
@@ -61,7 +56,7 @@
 {
 public:
 	UnorderedListLevelStyle(const WPXPropertyList &xPropList);
-	void write(DocumentHandler *pHandler, int iLevel) const;
+	void write(DocumentHandlerInterface *pHandler, int iLevel) const;
 private:
         WPXPropertyList mPropList;
 };
@@ -72,7 +67,7 @@
 	ListStyle(const char *psName, const int iListID);
 	virtual ~ListStyle();
 	virtual void updateListLevel(const int iLevel, const WPXPropertyList &xPropList) = 0;
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	const int getListID() { return miListID; }
 	const bool isListLevelDefined(int iLevel) const;
 
--- writerperfect/source/filter/makefile.mk	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/makefile.mk	2008-04-09 11:04:24.000000000 +0200
@@ -12,6 +12,10 @@
 INCPRE+=$(LIBWPD_CFLAGS)
 .ENDIF
 
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+INCPRE+=$(LIBWPG_CFLAGS)
+.ENDIF
+
 .IF "$(SYSTEM_LIBWPS)" == "YES"
 INCPRE+=$(LIBWPS_CFLAGS)
 .ENDIF
@@ -18,14 +22,17 @@ 
 INCPRE+= -I..
 
 SLOFILES= \
-	$(SLO)$/DocumentElement.obj		\
-	$(SLO)$/FontStyle.obj			\
-	$(SLO)$/ListStyle.obj			\
-	$(SLO)$/DocumentHandler.obj		\
-	$(SLO)$/PageSpan.obj			\
-	$(SLO)$/SectionStyle.obj		\
-	$(SLO)$/TableStyle.obj			\
-	$(SLO)$/TextRunStyle.obj 		\
-	$(SLO)$/DocumentCollector.obj
+	$(SLO)$/DocumentCollector.obj \
+	$(SLO)$/DocumentElement.obj \
+	$(SLO)$/DocumentHandler.obj \
+	$(SLO)$/FontStyle.obj \
+	$(SLO)$/GraphicsStyle.obj \
+	$(SLO)$/InternalHandler.obj \
+	$(SLO)$/ListStyle.obj \
+	$(SLO)$/OdgExporter.obj \
+	$(SLO)$/PageSpan.obj \
+	$(SLO)$/SectionStyle.obj \
+	$(SLO)$/TableStyle.obj \
+	$(SLO)$/TextRunStyle.obj
 
 .INCLUDE :  target.mk
--- writerperfect/source/filter/OdgExporter.cxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/OdgExporter.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,615 @@
+/* libwpg
+ * Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+ * Copyright (C) 2006 Fridrich Strba .strba@bluewin.ch)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#include "OdgExporter.hxx"
+#include "DocumentElement.hxx"
+#include "DocumentHandlerInterface.hxx"
+#include <locale.h>
+#include <string>
+
+OdgExporter::OdgExporter(DocumentHandlerInterface *pHandler, const bool isFlatXML):
+	mpHandler(pHandler),
+	mxFillRule(AlternatingFill),
+	miGradientIndex(1),
+	miDashIndex(1), 
+	miGraphicsStyleIndex(1),
+	mfWidth(0.0f),
+	mfHeight(0.0f),
+	mbIsFlatXML(isFlatXML)
+{
+}
+
+OdgExporter::~OdgExporter()
+{
+
+	for (std::vector<DocumentElement *>::iterator iterBody = mBodyElements.begin(); iterBody != mBodyElements.end(); iterBody++)
+	{
+		delete (*iterBody);
+		(*iterBody) = NULL;
+	}
+
+	for (std::vector<DocumentElement *>::iterator iterGraphicsAutomaticStyles = mGraphicsAutomaticStyles.begin();
+		iterGraphicsAutomaticStyles != mGraphicsAutomaticStyles.end(); iterGraphicsAutomaticStyles++)
+	{
+		delete((*iterGraphicsAutomaticStyles));
+	}
+
+	for (std::vector<DocumentElement *>::iterator iterGraphicsStrokeDashStyles = mGraphicsStrokeDashStyles.begin();
+		iterGraphicsStrokeDashStyles != mGraphicsStrokeDashStyles.end(); iterGraphicsStrokeDashStyles++)
+	{
+		delete((*iterGraphicsStrokeDashStyles));
+	}
+
+	for (std::vector<DocumentElement *>::iterator iterGraphicsGradientStyles = mGraphicsGradientStyles.begin();
+		iterGraphicsGradientStyles != mGraphicsGradientStyles.end(); iterGraphicsGradientStyles++)
+	{
+		delete((*iterGraphicsGradientStyles));
+	}
+}
+
+void OdgExporter::startGraphics(double width, double height)
+{
+	miGradientIndex = 1;
+	miDashIndex = 1;
+	miGraphicsStyleIndex = 1;
+	mfWidth = width;
+	mfHeight = height;
+
+	mpHandler->startDocument();
+	TagOpenElement tmpOfficeDocumentContent("office:document");
+	tmpOfficeDocumentContent.addAttribute("xmlns:office", "urn:oasis:names:tc:opendocument:xmlns:office:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:style", "urn:oasis:names:tc:opendocument:xmlns:style:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:text", "urn:oasis:names:tc:opendocument:xmlns:text:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:draw", "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:dc", "http://purl.org/dc/elements/1.1/");
+	tmpOfficeDocumentContent.addAttribute("xmlns:svg", "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:fo", "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:config", "urn:oasis:names:tc:opendocument:xmlns:config:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:ooo", "http://openoffice.org/2004/office");
+	tmpOfficeDocumentContent.addAttribute("office:version", "1.0");
+	if (mbIsFlatXML)
+		tmpOfficeDocumentContent.addAttribute("office:mimetype", "application/vnd.oasis.opendocument.graphics");	
+	tmpOfficeDocumentContent.write(mpHandler);
+	
+	TagOpenElement("office:settings").write(mpHandler);
+	
+	TagOpenElement configItemSetOpenElement("config:config-item-set");
+	configItemSetOpenElement.addAttribute("config:name", "ooo:view-settings");
+	configItemSetOpenElement.write(mpHandler);
+	
+	TagOpenElement configItemOpenElement("config:config-item");
+
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaTop");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	mpHandler->characters("0");
+	mpHandler->endElement("config:config-item");
+	
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaLeft");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	mpHandler->characters("0");
+	mpHandler->endElement("config:config-item");
+	
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaWidth");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	WPXString sWidth; sWidth.sprintf("%li", (unsigned long)(2540 * width));
+	mpHandler->characters(sWidth);
+	mpHandler->endElement("config:config-item");
+	
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaHeight");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	WPXString sHeight; sHeight.sprintf("%li", (unsigned long)(2540 * height));
+	mpHandler->characters(sHeight);
+	mpHandler->endElement("config:config-item");
+	
+	mpHandler->endElement("config:config-item-set");
+	
+	mpHandler->endElement("office:settings");
+}
+
+void OdgExporter::endGraphics()
+{
+	TagOpenElement("office:styles").write(mpHandler);
+
+	for (std::vector<DocumentElement *>::const_iterator iterGraphicsStrokeDashStyles = mGraphicsStrokeDashStyles.begin();
+		iterGraphicsStrokeDashStyles != mGraphicsStrokeDashStyles.end(); iterGraphicsStrokeDashStyles++)
+	{
+		(*iterGraphicsStrokeDashStyles)->write(mpHandler);
+	}
+
+	for (std::vector<DocumentElement *>::const_iterator iterGraphicsGradientStyles = mGraphicsGradientStyles.begin();
+		iterGraphicsGradientStyles != mGraphicsGradientStyles.end(); iterGraphicsGradientStyles++)
+	{
+		(*iterGraphicsGradientStyles)->write(mpHandler);
+	}
+	
+	mpHandler->endElement("office:styles");
+	
+	TagOpenElement("office:automatic-styles").write(mpHandler);
+
+	// writing out the graphics automatic styles
+	for (std::vector<DocumentElement *>::iterator iterGraphicsAutomaticStyles = mGraphicsAutomaticStyles.begin();
+		iterGraphicsAutomaticStyles != mGraphicsAutomaticStyles.end(); iterGraphicsAutomaticStyles++)
+	{
+		(*iterGraphicsAutomaticStyles)->write(mpHandler);
+	}
+
+	TagOpenElement tmpStylePageLayoutOpenElement("style:page-layout");
+	tmpStylePageLayoutOpenElement.addAttribute("style:name", "PM0");
+	tmpStylePageLayoutOpenElement.write(mpHandler);
+
+	TagOpenElement tmpStylePageLayoutPropertiesOpenElement("style:page-layout-properties");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-top", "0in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-bottom", "0in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-left", "0in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-right", "0in");
+	WPXString sValue;
+	sValue = doubleToString(mfWidth); sValue.append("in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:page-width", sValue);
+	sValue = doubleToString(mfHeight); sValue.append("in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:page-height", sValue);
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("style:print-orientation", "portrait");
+	tmpStylePageLayoutPropertiesOpenElement.write(mpHandler);
+
+	mpHandler->endElement("style:page-layout-properties");
+
+	mpHandler->endElement("style:page-layout");
+
+	TagOpenElement tmpStyleStyleOpenElement("style:style");
+	tmpStyleStyleOpenElement.addAttribute("style:name", "dp1");
+	tmpStyleStyleOpenElement.addAttribute("style:family", "drawing-page");
+	tmpStyleStyleOpenElement.write(mpHandler);
+
+	TagOpenElement tmpStyleDrawingPagePropertiesOpenElement("style:drawing-page-properties");
+	// tmpStyleDrawingPagePropertiesOpenElement.addAttribute("draw:background-size", "border");
+	tmpStyleDrawingPagePropertiesOpenElement.addAttribute("draw:fill", "none");
+	tmpStyleDrawingPagePropertiesOpenElement.write(mpHandler);
+
+	mpHandler->endElement("style:drawing-page-properties");
+
+	mpHandler->endElement("style:style");
+	
+	mpHandler->endElement("office:automatic-styles");
+
+
+	TagOpenElement("office:master-styles").write(mpHandler);
+
+	TagOpenElement tmpStyleMasterPageOpenElement("style:master-page");
+	tmpStyleMasterPageOpenElement.addAttribute("style:name", "Default");
+	tmpStyleMasterPageOpenElement.addAttribute("style:page-layout-name", "PM0");
+	tmpStyleMasterPageOpenElement.addAttribute("draw:style-name", "dp1");
+	tmpStyleMasterPageOpenElement.write(mpHandler);
+
+	mpHandler->endElement("style:master-page");
+
+	mpHandler->endElement("office:master-styles");
+
+	TagOpenElement("office:body").write(mpHandler);
+
+	TagOpenElement("office:drawing").write(mpHandler);
+
+	TagOpenElement tmpDrawPageOpenElement("draw:page");
+	tmpDrawPageOpenElement.addAttribute("draw:name", "page1");
+	tmpDrawPageOpenElement.addAttribute("draw:style-name", "dp1");
+	tmpDrawPageOpenElement.addAttribute("draw:master-page-name", "Default");
+	tmpDrawPageOpenElement.write(mpHandler);
+
+	for (std::vector<DocumentElement *>::const_iterator bodyIter = mBodyElements.begin();
+		bodyIter != mBodyElements.end(); bodyIter++)
+	{
+		(*bodyIter)->write(mpHandler);
+	}	
+
+	mpHandler->endElement("draw:page");
+	mpHandler->endElement("office:drawing");
+	mpHandler->endElement("office:body");
+	mpHandler->endElement("office:document");
+
+	mpHandler->endDocument();
+}
+
+void OdgExporter::setPen(const libwpg::WPGPen& pen)
+{
+	mxPen = pen;
+}
+
+void OdgExporter::setBrush(const libwpg::WPGBrush& brush)
+{
+	mxBrush = brush;
+}
+
+void OdgExporter::setFillRule(FillRule rule)
+{
+	mxFillRule = rule;
+}
+
+void OdgExporter::startLayer(unsigned int /* id */)
+{
+}
+
+void OdgExporter::endLayer(unsigned int)
+{
+}
+
+void OdgExporter::drawRectangle(const libwpg::WPGRect& rect, double rx, double /* ry */)
+{
+	writeGraphicsStyle();
+	TagOpenElement *pDrawRectElement = new TagOpenElement("draw:rect");
+	WPXString sValue;
+	sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+	pDrawRectElement->addAttribute("draw:style-name", sValue);
+	sValue = doubleToString(rect.x1); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(rect.y1); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(rect.x2-rect.x1); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:width", sValue);
+	sValue = doubleToString(rect.y2-rect.y1); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:height", sValue);
+	sValue = doubleToString(rx); sValue.append("in");
+	// FIXME: what to do when rx != ry ?
+	pDrawRectElement->addAttribute("draw:corner-radius", sValue);
+	mBodyElements.push_back(pDrawRectElement);
+	mBodyElements.push_back(new TagCloseElement("draw:rect"));	
+}
+
+void OdgExporter::drawEllipse(const libwpg::WPGPoint& center, double rx, double ry)
+{
+	writeGraphicsStyle();
+	TagOpenElement *pDrawEllipseElement = new TagOpenElement("draw:ellipse");
+	WPXString sValue;
+	sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+	pDrawEllipseElement->addAttribute("draw:style-name", sValue);
+	sValue = doubleToString(center.x-rx); sValue.append("in");
+	pDrawEllipseElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(center.y-ry); sValue.append("in");
+	pDrawEllipseElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(2 * rx); sValue.append("in");
+	pDrawEllipseElement->addAttribute("svg:width", sValue);
+	sValue = doubleToString(2 * ry); sValue.append("in");
+	pDrawEllipseElement->addAttribute("svg:height", sValue);
+	mBodyElements.push_back(pDrawEllipseElement);
+	mBodyElements.push_back(new TagCloseElement("draw:ellipse"));
+}
+
+void OdgExporter::drawPolygon(const libwpg::WPGPointArray& vertices)
+{
+	if(vertices.count() < 2)
+		return;
+
+	if(vertices.count() == 2)
+	{
+		const libwpg::WPGPoint& p1 = vertices[0];
+		const libwpg::WPGPoint& p2 = vertices[1];
+
+		writeGraphicsStyle();
+		TagOpenElement *pDrawLineElement = new TagOpenElement("draw:line");
+		WPXString sValue;
+		sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+		pDrawLineElement->addAttribute("draw:style-name", sValue);
+		pDrawLineElement->addAttribute("draw:text-style-name", "P1");
+		pDrawLineElement->addAttribute("draw:layer", "layout");
+		sValue = doubleToString(p1.x); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:x1", sValue);
+		sValue = doubleToString(p1.y); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:y1", sValue);
+		sValue = doubleToString(p2.x); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:x2", sValue);
+		sValue = doubleToString(p2.y); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:y2", sValue);
+		mBodyElements.push_back(pDrawLineElement);
+		mBodyElements.push_back(new TagCloseElement("draw:line"));
+	}
+	else
+	{
+		// draw as path
+		libwpg::WPGPath path;
+		path.moveTo(vertices[0]);
+		for(unsigned long ii = 1; ii < vertices.count(); ii++)
+			path.lineTo(vertices[ii]);
+		path.closed = true;
+		drawPath(path);
+	}
+}
+
+void OdgExporter::drawPath(const libwpg::WPGPath& path)
+{
+	if(path.count() == 0)
+		return;
+
+	// try to find the bounding box
+	// this is simple convex hull technique, the bounding box might not be
+	// accurate but that should be enough for this purpose
+	libwpg::WPGPoint p = path.element(0).point;
+	libwpg::WPGPoint q = path.element(0).point;
+	for(unsigned k = 0; k < path.count(); k++)
+	{
+		libwpg::WPGPathElement element = path.element(k);
+		p.x = (p.x > element.point.x) ? element.point.x : p.x; 
+		p.y = (p.y > element.point.y) ? element.point.y : p.y; 
+		q.x = (q.x < element.point.x) ? element.point.x : q.x; 
+		q.y = (q.y < element.point.y) ? element.point.y : q.y; 
+		if(element.type == libwpg::WPGPathElement::CurveToElement)
+		{
+			p.x = (p.x > element.extra1.x) ? element.extra1.x : p.x; 
+			p.y = (p.y > element.extra1.y) ? element.extra1.y : p.y; 
+			q.x = (q.x < element.extra1.x) ? element.extra1.x : q.x; 
+			q.y = (q.y < element.extra1.y) ? element.extra1.y : q.y; 
+			p.x = (p.x > element.extra2.x) ? element.extra2.x : p.x; 
+			p.y = (p.y > element.extra2.y) ? element.extra2.y : p.y; 
+			q.x = (q.x < element.extra2.x) ? element.extra2.x : q.x; 
+			q.y = (q.y < element.extra2.y) ? element.extra2.y : q.y; 
+		}
+	}
+	double vw = q.x - p.x;
+	double vh = q.y - p.y;
+		
+	writeGraphicsStyle();
+
+	TagOpenElement *pDrawPathElement = new TagOpenElement("draw:path");
+	WPXString sValue;
+	sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+	pDrawPathElement->addAttribute("draw:style-name", sValue);
+	pDrawPathElement->addAttribute("draw:text-style-name", "P1");
+	pDrawPathElement->addAttribute("draw:layer", "layout");
+	sValue = doubleToString(p.x); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(p.y); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(vw); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:width", sValue);
+	sValue = doubleToString(vh); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:height", sValue);
+	sValue.sprintf("%i %i %i %i", 0, 0, (unsigned)(vw*2540), (unsigned)(vh*2540));
+	pDrawPathElement->addAttribute("svg:viewBox", sValue);
+
+    sValue.clear();
+	for(unsigned i = 0; i < path.count(); i++)
+	{
+		libwpg::WPGPathElement element = path.element(i);
+		libwpg::WPGPoint point = element.point;
+        WPXString sElement;
+		switch(element.type)
+		{
+			// 2540 is 2.54*1000, 2.54 in = 1 inch
+			case libwpg::WPGPathElement::MoveToElement:
+			    sElement.sprintf("M%i %i", (unsigned)((point.x-p.x)*2540), (unsigned)((point.y-p.y)*2540));
+				break;
+				
+			case libwpg::WPGPathElement::LineToElement:
+			    sElement.sprintf("L%i %i", (unsigned)((point.x-p.x)*2540), (unsigned)((point.y-p.y)*2540));
+				break;
+			
+			case libwpg::WPGPathElement::CurveToElement:
+                sElement.sprintf("C%i %i %i %i %i %i", (unsigned)((element.extra1.x-p.x)*2540),
+                (int)((element.extra1.y-p.y)*2540), (unsigned)((element.extra2.x-p.x)*2540),
+                (int)((element.extra2.y-p.y)*2540), (unsigned)((point.x-p.x)*2540), (unsigned)((point.y-p.y)*2540));
+				break;
+			
+			default:
+				break;
+		}
+		sValue.append(sElement);
+	}
+    if(path.closed)
+		sValue.append(" Z");
+	pDrawPathElement->addAttribute("svg:d", sValue);
+	mBodyElements.push_back(pDrawPathElement);
+	mBodyElements.push_back(new TagCloseElement("draw:path"));
+}
+
+void OdgExporter::drawBitmap(const libwpg::WPGBitmap& bitmap)
+{
+	TagOpenElement *pDrawFrameElement = new TagOpenElement("draw:frame");
+	WPXString sValue;
+	sValue = doubleToString(bitmap.rect.x1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(bitmap.rect.y1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(bitmap.rect.height()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:height", sValue);
+	sValue = doubleToString(bitmap.rect.width()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:width", sValue);
+	mBodyElements.push_back(pDrawFrameElement);
+	
+	mBodyElements.push_back(new TagOpenElement("draw:image"));
+	
+	mBodyElements.push_back(new TagOpenElement("office:binary-data"));
+	
+	libwpg::WPGString base64Binary;
+	bitmap.generateBase64DIB(base64Binary);
+	mBodyElements.push_back(new CharDataElement(base64Binary.cstr()));
+	
+	mBodyElements.push_back(new TagCloseElement("office:binary-data"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:image"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:frame"));
+}
+
+void OdgExporter::drawImageObject(const libwpg::WPGBinaryData& binaryData)
+{
+	if (binaryData.mimeType.length() <= 0)
+		return;
+	TagOpenElement *pDrawFrameElement = new TagOpenElement("draw:frame");
+	WPXString sValue;
+	sValue = doubleToString(binaryData.rect.x1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(binaryData.rect.y1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(binaryData.rect.height()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:height", sValue);
+	sValue = doubleToString(binaryData.rect.width()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:width", sValue);
+	mBodyElements.push_back(pDrawFrameElement);
+	
+	mBodyElements.push_back(new TagOpenElement("draw:image"));
+	
+	mBodyElements.push_back(new TagOpenElement("office:binary-data"));
+	
+	libwpg::WPGString base64Binary = binaryData.getBase64Data();
+	mBodyElements.push_back(new CharDataElement(base64Binary.cstr()));
+	
+	mBodyElements.push_back(new TagCloseElement("office:binary-data"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:image"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:frame"));
+}
+
+void OdgExporter::writeGraphicsStyle()
+{
+	if(!mxPen.solid && (mxPen.dashArray.count() >=2 ) )
+	{
+		// ODG only supports dashes with the same length of spaces inbetween
+		// here we take the first space and assume everything else the same
+		// note that dash length is written in percentage ?????????????????
+		double distance = mxPen.dashArray.at(1);
+		TagOpenElement *pDrawStrokeDashElement = new TagOpenElement("draw:stroke-dash");
+		pDrawStrokeDashElement->addAttribute("draw:style", "rect");
+		WPXString sValue;
+		sValue.sprintf("Dash_%i", miDashIndex++);
+		pDrawStrokeDashElement->addAttribute("draw:name", sValue);
+		sValue = doubleToString(distance); sValue.append("in");
+		pDrawStrokeDashElement->addAttribute("draw:distance", sValue);
+		WPXString sName;
+		// We have to find out how to do this intelligently, since the ODF is allowing only
+		// two pairs draw:dots1 draw:dots1-length and draw:dots2 draw:dots2-length
+		for(unsigned i = 0; i < mxPen.dashArray.count()/2 && i < 2; i++)
+		{
+			sName.sprintf("draw:dots%i", i+1);
+			pDrawStrokeDashElement->addAttribute(sName.cstr(), "1");
+			sName.sprintf("draw:dots%i-length", i+1);
+			sValue = doubleToString(mxPen.dashArray.at(i*2)); sValue.append("in");
+			pDrawStrokeDashElement->addAttribute(sName.cstr(), sValue);
+		}
+		mGraphicsStrokeDashStyles.push_back(pDrawStrokeDashElement);
+		mGraphicsStrokeDashStyles.push_back(new TagCloseElement("draw:stroke-dash"));
+	}
+
+	if(mxBrush.style == libwpg::WPGBrush::Gradient)
+	{
+		TagOpenElement *pDrawGradientElement = new TagOpenElement("draw:gradient");
+		pDrawGradientElement->addAttribute("draw:style", "linear");
+		WPXString sValue;
+		sValue.sprintf("Gradient_%i", miGradientIndex++);
+		pDrawGradientElement->addAttribute("draw:name", sValue);
+
+		// ODG angle unit is 0.1 degree
+		double angle = -mxBrush.gradient.angle();
+		while(angle < 0)
+			angle += 360;
+		while(angle > 360)
+			angle -= 360;
+
+		sValue.sprintf("%i", (unsigned)(angle*10));
+		pDrawGradientElement->addAttribute("draw:angle", sValue);
+
+		libwpg::WPGColor startColor = mxBrush.gradient.stopColor(0);
+		libwpg::WPGColor stopColor = mxBrush.gradient.stopColor(1);
+		sValue.sprintf("#%.2x%.2x%.2x", (startColor.red & 0xff), (startColor.green & 0xff), (startColor.blue & 0xff));
+		pDrawGradientElement->addAttribute("draw:start-color", sValue);
+		sValue.sprintf("#%.2x%.2x%.2x", (stopColor.red & 0xff), (stopColor.green & 0xff), (stopColor.blue & 0xff));
+		pDrawGradientElement->addAttribute("draw:end-color", sValue);
+		pDrawGradientElement->addAttribute("draw:start-intensity", "100%");
+		pDrawGradientElement->addAttribute("draw:end-intensity", "100%");
+		pDrawGradientElement->addAttribute("draw:border", "0%");
+		mGraphicsGradientStyles.push_back(pDrawGradientElement);
+		mGraphicsGradientStyles.push_back(new TagCloseElement("draw:gradient"));
+	}
+
+	TagOpenElement *pStyleStyleElement = new TagOpenElement("style:style");
+	WPXString sValue;
+	sValue.sprintf("gr%i",  miGraphicsStyleIndex);
+	pStyleStyleElement->addAttribute("style:name", sValue);
+	pStyleStyleElement->addAttribute("style:family", "graphic");
+	pStyleStyleElement->addAttribute("style:parent-style-name", "standard");
+	mGraphicsAutomaticStyles.push_back(pStyleStyleElement);
+
+	TagOpenElement *pStyleGraphicsPropertiesElement = new TagOpenElement("style:graphic-properties");
+
+	if(mxPen.width > 0.0)
+	{
+		sValue = doubleToString(mxPen.width); sValue.append("in");
+		pStyleGraphicsPropertiesElement->addAttribute("svg:stroke-width", sValue);
+		sValue.sprintf("#%.2x%.2x%.2x", (mxPen.foreColor.red & 0xff),
+			(mxPen.foreColor.green & 0xff), (mxPen.foreColor.blue & 0xff));
+		pStyleGraphicsPropertiesElement->addAttribute("svg:stroke-color", sValue);
+
+		if(!mxPen.solid)
+		{
+			pStyleGraphicsPropertiesElement->addAttribute("draw:stroke", "dash");
+			sValue.sprintf("Dash_%i", miDashIndex-1);
+			pStyleGraphicsPropertiesElement->addAttribute("draw:stroke-dash", sValue);
+		}
+	}
+	else
+		pStyleGraphicsPropertiesElement->addAttribute("draw:stroke", "none");
+
+	if(mxBrush.style == libwpg::WPGBrush::NoBrush)
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill", "none");
+
+	if(mxBrush.style == libwpg::WPGBrush::Solid)
+	{
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill", "solid");
+		sValue.sprintf("#%.2x%.2x%.2x", (mxBrush.foreColor.red & 0xff),
+			(mxBrush.foreColor.green & 0xff), (mxBrush.foreColor.blue & 0xff));
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill-color", sValue);
+	}
+
+	if(mxBrush.style == libwpg::WPGBrush::Gradient)
+	{
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill", "gradient");
+		sValue.sprintf("Gradient_%i", miGradientIndex-1);
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill-gradient-name", sValue);
+	}
+
+	mGraphicsAutomaticStyles.push_back(pStyleGraphicsPropertiesElement);
+	mGraphicsAutomaticStyles.push_back(new TagCloseElement("style:graphic-properties"));
+
+	mGraphicsAutomaticStyles.push_back(new TagCloseElement("style:style"));
+	miGraphicsStyleIndex++;
+}
+
+WPXString OdgExporter::doubleToString(const double value)
+{
+	WPXString tempString;
+	tempString.sprintf("%.4f", value);
+	std::string decimalPoint(localeconv()->decimal_point);
+	if ((decimalPoint.size() == 0) || (decimalPoint == "."))
+		return tempString;
+	std::string stringValue(tempString.cstr());
+	if (!stringValue.empty())
+	{
+		std::string::size_type pos;
+		while ((pos = stringValue.find(decimalPoint)) != std::string::npos)
+			stringValue.replace(pos,decimalPoint.size(),".");
+	}
+	return WPXString(stringValue.c_str());
+}
--- writerperfect/source/filter/OdgExporter.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect/source/filter/OdgExporter.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -0,0 +1,85 @@
+/* libwpg
+ * Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#ifndef __ODGEXPORTER_HXX__
+#define __ODGEXPORTER_HXX__
+
+#include <iostream>
+#include <sstream>
+#include <string>
+
+#include <libwpd/WPXString.h>
+#include <libwpg/libwpg.h>
+#include "DocumentElement.hxx"
+#include "DocumentHandlerInterface.hxx"
+
+class OdgExporter : public libwpg::WPGPaintInterface {
+public:
+	OdgExporter(DocumentHandlerInterface *pHandler, const bool isFlatXML = false);
+	~OdgExporter();
+
+	void startGraphics(double width, double height);
+	void endGraphics();
+	void startLayer(unsigned int id);
+	void endLayer(unsigned int id);
+
+	void setPen(const libwpg::WPGPen& pen);
+	void setBrush(const libwpg::WPGBrush& brush);
+	void setFillRule(FillRule rule);
+
+	void drawRectangle(const libwpg::WPGRect& rect, double rx, double ry);
+	void drawEllipse(const libwpg::WPGPoint& center, double rx, double ry);
+	void drawPolygon(const libwpg::WPGPointArray& vertices);
+	void drawPath(const libwpg::WPGPath& path);
+	void drawBitmap(const libwpg::WPGBitmap& bitmap);
+	void drawImageObject(const libwpg::WPGBinaryData& binaryData);
+
+private:
+	void writeGraphicsStyle();
+	WPXString doubleToString(const double value);
+	
+	// body elements
+	std::vector <DocumentElement *> mBodyElements;
+
+	// graphics styles
+	std::vector<DocumentElement *> mGraphicsStrokeDashStyles;
+	std::vector<DocumentElement *> mGraphicsGradientStyles;
+	std::vector<DocumentElement *> mGraphicsAutomaticStyles;
+
+	DocumentHandlerInterface *mpHandler;
+
+	libwpg::WPGPen mxPen;
+	libwpg::WPGBrush mxBrush;
+	FillRule mxFillRule;
+	int miGradientIndex;
+	int miDashIndex;
+	int miGraphicsStyleIndex;
+	double mfWidth;
+	double mfHeight;
+
+	const bool mbIsFlatXML;
+};
+
+#endif // __ODGEXPORTER_HXX__
--- writerperfect/source/filter/PageSpan.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/PageSpan.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -103,39 +103,38 @@
          return 0.0f; 
 }
 
-void PageSpan::writePageMaster(const int iNum, DocumentHandler *pHandler) const
+void PageSpan::writePageLayout(const int iNum, DocumentHandlerInterface *pHandler) const
 {
         WPXPropertyList propList;
         
-	WPXString sPageMasterName; 
-        sPageMasterName.sprintf("PM%i", iNum /* +2 */);
-        propList.insert("style:name", sPageMasterName);
-
-	pHandler->startElement("style:page-master", propList);
+	WPXString sPageLayoutName; 
+        sPageLayoutName.sprintf("PM%i", iNum+2);
+        propList.insert("style:name", sPageLayoutName);
+	pHandler->startElement("style:page-layout", propList);
 
 	WPXPropertyList tempPropList = mxPropList;
 	if (!tempPropList["style:writing-mode"])
 		tempPropList.insert("style:writing-mode", WPXString("lr-tb"));
 	if (!tempPropList["style:footnote-max-height"])
-		tempPropList.insert("style:footnote-max-height", WPXString("0inch"));
-        pHandler->startElement("style:properties", tempPropList);
+		tempPropList.insert("style:footnote-max-height", WPXString("0in"));
+        pHandler->startElement("style:page-layout-properties", tempPropList);
 	
 	WPXPropertyList footnoteSepPropList;
-	footnoteSepPropList.insert("style:width", WPXString("0.0071inch"));
-	footnoteSepPropList.insert("style:distance-before-sep", WPXString("0.0398inch"));
-	footnoteSepPropList.insert("style:distance-after-sep", WPXString("0.0398inch"));
+	footnoteSepPropList.insert("style:width", WPXString("0.0071in"));
+	footnoteSepPropList.insert("style:distance-before-sep", WPXString("0.0398in"));
+	footnoteSepPropList.insert("style:distance-after-sep", WPXString("0.0398in"));
 	footnoteSepPropList.insert("style:adjustment", WPXString("left"));
 	footnoteSepPropList.insert("style:rel-width", WPXString("25%"));
 	footnoteSepPropList.insert("style:color", WPXString("#000000"));
 	pHandler->startElement("style:footnote-sep", footnoteSepPropList);
 	
 	pHandler->endElement("style:footnote-sep");
-        pHandler->endElement("style:properties");
-        pHandler->endElement("style:page-master");
+        pHandler->endElement("style:page-layout-properties");
+        pHandler->endElement("style:page-layout");
 }
 
-void PageSpan::writeMasterPages(const int iStartingNum, const int iPageMasterNum, const bool bLastPageSpan, 
-                                DocumentHandler *pHandler) const
+void PageSpan::writeMasterPages(const int iStartingNum, const int iPageLayoutNum, const bool bLastPageSpan, 
+                                DocumentHandlerInterface *pHandler) const
 {
 	int iSpan = 0;
 	(bLastPageSpan) ? iSpan = 1 : iSpan = getSpan();
@@ -143,38 +142,66 @@
 	for (int i=iStartingNum; i<(iStartingNum+iSpan); i++)
 	{
 		TagOpenElement masterPageOpen("style:master-page");
-		WPXString sMasterPageName;
-		sMasterPageName.sprintf("Page Style %i", i);
-		WPXString sPageMasterName;
-		sPageMasterName.sprintf("PM%i", iPageMasterNum /* +2 */);
+		WPXString sMasterPageName, sMasterPageDisplayName;
+		sMasterPageName.sprintf("Page_Style_%i", i);
+		sMasterPageDisplayName.sprintf("Page Style %i", i);
+		WPXString sPageLayoutName;
 		WPXPropertyList propList;
+		sPageLayoutName.sprintf("PM%i", iPageLayoutNum+2);
                 propList.insert("style:name", sMasterPageName);
-		propList.insert("style:page-master-name", sPageMasterName);
+		propList.insert("style:display-name", sMasterPageDisplayName);
+		propList.insert("style:page-layout-name", sPageLayoutName);
 		if (!bLastPageSpan)
 		{
 			WPXString sNextMasterPageName;
-			sNextMasterPageName.sprintf("Page Style %i", (i+1));
+			sNextMasterPageName.sprintf("Page_Style_%i", (i+1));
                         propList.insert("style:next-style-name", sNextMasterPageName);
 		}
                 pHandler->startElement("style:master-page", propList);
 
 		if (mpHeaderContent)
+		{
 			_writeHeaderFooter("style:header", *mpHeaderContent, pHandler);
-		if (mpHeaderLeftContent)
+			pHandler->endElement("style:header");
+			if (mpHeaderLeftContent)
+			{
+				_writeHeaderFooter("style:header-left", *mpHeaderLeftContent, pHandler);
+				pHandler->endElement("style:header-left");
+			}
+		}
+		else if (mpHeaderLeftContent)
+		{
+			TagOpenElement("style:header").write(pHandler);
+			pHandler->endElement("style:header");
 			_writeHeaderFooter("style:header-left", *mpHeaderLeftContent, pHandler);
+			pHandler->endElement("style:header-left");
+		}
+			
 		if (mpFooterContent)
+		{
 			_writeHeaderFooter("style:footer", *mpFooterContent, pHandler);
-		if (mpFooterLeftContent)
+			pHandler->endElement("style:footer");
+			if (mpFooterLeftContent)
+			{
+				_writeHeaderFooter("style:footer-left", *mpFooterLeftContent, pHandler);
+				pHandler->endElement("style:footer-left");
+			}
+		}
+		else if (mpFooterLeftContent)
+		{
+			TagOpenElement("style:footer").write(pHandler);
+			pHandler->endElement("style:footer");
 			_writeHeaderFooter("style:footer-left", *mpFooterLeftContent, pHandler);
+			pHandler->endElement("style:footer-left");
+		}
 
                 pHandler->endElement("style:master-page");
 	}
-
 }
 
 void PageSpan::_writeHeaderFooter(const char *headerFooterTagName,
 				  const std::vector<DocumentElement *> & headerFooterContent,
-				  DocumentHandler *pHandler) const
+				  DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement headerFooterOpen(headerFooterTagName);
 	headerFooterOpen.write(pHandler);
@@ -183,7 +210,4 @@
 	     iter++) {
 		(*iter)->write(pHandler);
 	}
-	TagCloseElement headerFooterClose(headerFooterTagName);
-	headerFooterClose.write(pHandler);
 }
-
--- writerperfect/source/filter/PageSpan.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/PageSpan.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -26,25 +26,20 @@
  */
 #ifndef _PAGESPAN_H
 #define _PAGESPAN_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include <vector>
 
+#include "DocumentHandlerInterface.hxx"
+
 class DocumentElement;
-class DocumentHandler;
 
 class PageSpan
 {
 public:
 	PageSpan(const WPXPropertyList &xPropList);
 	virtual ~PageSpan();
-	void writePageMaster(const int iNum, DocumentHandler *pHandler) const;
-	void writeMasterPages(const int iStartingNum, const int iPageMasterNum, const bool bLastPageSpan, DocumentHandler *pHandler) const;
+	void writePageLayout(const int iNum, DocumentHandlerInterface *pHandler) const;
+	void writeMasterPages(const int iStartingNum, const int iPageLayoutNum, const bool bLastPageSpan, DocumentHandlerInterface *pHandler) const;
 	int getSpan() const;
 	float getMarginLeft() const;
 	float getMarginRight() const;
@@ -56,7 +51,7 @@
 	void setFooterLeftContent(std::vector<DocumentElement *> * pFooterContent) { mpFooterLeftContent = pFooterContent; }
 protected:
 	void _writeHeaderFooter(const char *headerFooterTagName, const std::vector<DocumentElement *> & headerFooterContent,
-				DocumentHandler *pHandler) const;
+				DocumentHandlerInterface *pHandler) const;
 private:
         WPXPropertyList mxPropList;
 	std::vector<DocumentElement *> * mpHeaderContent;
--- writerperfect/source/filter/SectionStyle.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/SectionStyle.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -33,7 +33,7 @@
 
 #ifdef _MSC_VER
 double rint(double x);
-#endif /* _MSC_VER */
+#endif /* _WIN32 */
 
 SectionStyle::SectionStyle(const WPXPropertyList &xPropList, 
                            const WPXPropertyListVector &xColumns, 
@@ -44,7 +44,7 @@
 {
 }
 
-void SectionStyle::write(DocumentHandler *pHandler) const
+void SectionStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
@@ -53,15 +53,15 @@
 
 	// if the number of columns is <= 1, we will never come here. This is only an additional check
 	// style properties
-	pHandler->startElement("style:properties", mPropList);
+	pHandler->startElement("style:section-properties", mPropList);
 
 	// column properties
 	WPXPropertyList columnProps;
 
 	if (mColumns.count() > 1)
 	{		
-                columnProps.insert("fo:column-count", (int)mColumns.count());
-                pHandler->startElement("style:columns", columnProps);
+		columnProps.insert("fo:column-count", (int)mColumns.count());
+ 		pHandler->startElement("style:columns", columnProps);
 	
                 WPXPropertyListVector::Iter i(mColumns);
                 for (i.rewind(); i.next();)
@@ -80,7 +80,7 @@
 	pHandler->endElement("style:columns");
 
 		
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:section-properties");
 
 	pHandler->endElement("style:style");
 }
--- writerperfect/source/filter/SectionStyle.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/SectionStyle.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -21,19 +21,13 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _SECTIONSTYLE_H
 #define _SECTIONSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
 #include <libwpd/WPXPropertyListVector.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
@@ -43,10 +37,10 @@
 {
 public:
 	SectionStyle(const WPXPropertyList &xPropList, const WPXPropertyListVector &xColumns, const char *psName);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 
 private:
-        WPXPropertyList mPropList;
+	WPXPropertyList mPropList;
 	WPXPropertyListVector mColumns;
 };
 #endif
--- writerperfect/source/filter/Style.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/Style.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -21,19 +21,13 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 
 #ifndef _STYLE_H
 #define _STYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include "DocumentElement.hxx"
 
 class TopLevelElementStyle
@@ -54,7 +48,7 @@
 	Style(const WPXString &psName) : msName(psName) {}
 	virtual ~Style() {}
 
-	virtual void write(DocumentHandler * /* pHandler */) const {};
+	virtual void write(DocumentHandlerInterface * /* pHandler */) const {};
 	const WPXString &getName() const { return msName; }
 
  private:
--- writerperfect/source/filter/TableStyle.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/TableStyle.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -27,7 +27,6 @@
  * Corel Corporation or Corel Corporation Limited."
  */
 #include <math.h>
-#include <string.h>
 #include "FilterInternal.hxx"
 #include "TableStyle.hxx"
 #include "DocumentElement.hxx"
@@ -36,13 +35,15 @@
 #include <minmax.h>
 #endif
 
+#include <string.h>
+
 TableCellStyle::TableCellStyle(const WPXPropertyList &xPropList, const char *psName) :
 	Style(psName),
         mPropList(xPropList)
 {
 }
 
-void TableCellStyle::write(DocumentHandler *pHandler) const
+void TableCellStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
@@ -58,9 +59,9 @@
                 if (strlen(i.key()) > 2 && strncmp(i.key(), "fo", 2) == 0)
                         stylePropList.insert(i.key(), i()->clone());
         }
-        stylePropList.insert("fo:padding", "0.0382inch");
-        pHandler->startElement("style:properties", stylePropList);
-	pHandler->endElement("style:properties");
+        stylePropList.insert("fo:padding", "0.0382in");
+        pHandler->startElement("style:table-cell-properties", stylePropList);
+	pHandler->endElement("style:table-cell-properties");
 
 	pHandler->endElement("style:style");	
 }
@@ -71,20 +72,21 @@
 {
 }
 
-void TableRowStyle::write(DocumentHandler *pHandler) const
+void TableRowStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
 	styleOpen.addAttribute("style:family", "table-row");
 	styleOpen.write(pHandler);
 	
-        TagOpenElement stylePropertiesOpen("style:properties");
+        TagOpenElement stylePropertiesOpen("style:table-row-properties");
         if (mPropList["style:min-row-height"])
                 stylePropertiesOpen.addAttribute("style:min-row-height", mPropList["style:min-row-height"]->getStr());
         else if (mPropList["style:row-height"])
                 stylePropertiesOpen.addAttribute("style:row-height", mPropList["style:row-height"]->getStr());
+	stylePropertiesOpen.addAttribute("fo:keep-together", "auto");
         stylePropertiesOpen.write(pHandler);
-        pHandler->endElement("style:properties");
+        pHandler->endElement("style:table-row-properties");
 	
 	pHandler->endElement("style:style");		
 }
@@ -105,10 +107,9 @@
 		delete(*iterTableCellStyles);
 	for (TRSVIter iterTableRowStyles = mTableRowStyles.begin() ; iterTableRowStyles != mTableRowStyles.end(); iterTableRowStyles++)
 		delete(*iterTableRowStyles);
-
 }
 
-void TableStyle::write(DocumentHandler *pHandler) const
+void TableStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
@@ -117,7 +118,7 @@
 		styleOpen.addAttribute("style:master-page-name", getMasterPageName()->cstr());
 	styleOpen.write(pHandler);
 
-	TagOpenElement stylePropertiesOpen("style:properties");
+	TagOpenElement stylePropertiesOpen("style:table-properties");
         if (mPropList["table:align"])
                 stylePropertiesOpen.addAttribute("table:align", mPropList["table:align"]->getStr());
 	if (mPropList["fo:margin-left"])
@@ -130,23 +131,23 @@
 		stylePropertiesOpen.addAttribute("fo:break-before", mPropList["fo:break-before"]->getStr());
 	stylePropertiesOpen.write(pHandler);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:table-properties");
 
 	pHandler->endElement("style:style");
 		
 	int i=1;
-        WPXPropertyListVector::Iter j(mColumns);
+	WPXPropertyListVector::Iter j(mColumns);
 	for (j.rewind(); j.next();)
 	{
-		TagOpenElement styleNestedOpen("style:style");
+		TagOpenElement styleOpen2("style:style");
 		WPXString sColumnName;
 		sColumnName.sprintf("%s.Column%i", getName().cstr(), i);
-		styleNestedOpen.addAttribute("style:name", sColumnName);
-		styleNestedOpen.addAttribute("style:family", "table-column");
-		styleNestedOpen.write(pHandler);
+		styleOpen2.addAttribute("style:name", sColumnName);
+		styleOpen2.addAttribute("style:family", "table-column");
+		styleOpen2.write(pHandler);
 
-                pHandler->startElement("style:properties", j());
-		pHandler->endElement("style:properties");
+		pHandler->startElement("style:table-column-properties", j());
+		pHandler->endElement("style:table-column-properties");
 
 		pHandler->endElement("style:style");
 
--- writerperfect/source/filter/TableStyle.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/TableStyle.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -22,57 +22,53 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _TABLESTYLE_H
 #define _TABLESTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include <vector>
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class DocumentElement;
-class DocumentHandler;
 
 class TableCellStyle : public Style
 {
 public:
+	virtual ~TableCellStyle() {};
 	TableCellStyle(const WPXPropertyList &xPropList, const char *psName);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 private:
-        WPXPropertyList mPropList;
+	WPXPropertyList mPropList;
 };
 
 class TableRowStyle : public Style
 {
 public:
+	virtual ~TableRowStyle() {};
 	TableRowStyle(const WPXPropertyList &propList, const char *psName);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 private:
-        WPXPropertyList mPropList;
+	WPXPropertyList mPropList;
 };
 
 class TableStyle : public Style, public TopLevelElementStyle
 {
 public:
 	TableStyle(const WPXPropertyList &xPropList, const WPXPropertyListVector &columns, const char *psName);
-	~TableStyle();
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~TableStyle();
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	const int getNumColumns() const { return mColumns.count(); }
 	void addTableCellStyle(TableCellStyle *pTableCellStyle) { mTableCellStyles.push_back(pTableCellStyle); }
 	int getNumTableCellStyles() { return mTableCellStyles.size(); }
 	void addTableRowStyle(TableRowStyle *pTableRowStyle) { mTableRowStyles.push_back(pTableRowStyle); }
 	int getNumTableRowStyles() { return mTableRowStyles.size(); }
-private:
-        WPXPropertyList mPropList;
+private:	
+	WPXPropertyList mPropList;
 	WPXPropertyListVector mColumns;
 	std::vector<TableCellStyle *> mTableCellStyles;
 	std::vector<TableRowStyle *> mTableRowStyles;
--- writerperfect/source/filter/TextRunStyle.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/TextRunStyle.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -50,91 +50,95 @@
 	delete mpPropList;
 }
 
-void ParagraphStyle::write(DocumentHandler *pHandler) const
+void ParagraphStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	WRITER_DEBUG_MSG(("Writing a paragraph style..\n"));
 
-        WPXPropertyList propList;
+	WPXPropertyList propList;
 	propList.insert("style:name", msName.cstr());
 	propList.insert("style:family", "paragraph");
 	propList.insert("style:parent-style-name", (*mpPropList)["style:parent-style-name"]->getStr());
 	if ((*mpPropList)["style:master-page-name"])
 		propList.insert("style:master-page-name", (*mpPropList)["style:master-page-name"]->getStr());
-        pHandler->startElement("style:style", propList);
+	pHandler->startElement("style:style", propList);
 
-        propList.clear();
-	WPXPropertyList::Iter k((*mpPropList));
-	for (k.rewind(); k.next(); )
-	{
-                if (strcmp(k.key(), "style:list-style-name") == 0)
-                        propList.insert("style:list-style-name", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-left") == 0)
-			propList.insert("fo:margin-left", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-right") == 0)
-			propList.insert("fo:margin-right", k()->getStr());
-		if (strcmp(k.key(), "fo:text-indent") == 0)
-			propList.insert("fo:text-indent", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-top") == 0)
-			propList.insert("fo:margin-top", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-bottom") == 0)
+	propList.clear();
+	WPXPropertyList::Iter i((*mpPropList));
+	for (i.rewind(); i.next(); )
+	{
+#if 0
+		if (strcmp(i.key(), "style:list-style-name") == 0)
+			propList.insert("style:list-style-name", i()->getStr());
+#endif
+		if (strcmp(i.key(), "fo:margin-left") == 0)
+			propList.insert("fo:margin-left", i()->getStr());
+		if (strcmp(i.key(), "fo:margin-right") == 0)
+			propList.insert("fo:margin-right", i()->getStr());
+		if (strcmp(i.key(), "fo:text-indent") == 0)
+			propList.insert("fo:text-indent", i()->getStr());
+		if (strcmp(i.key(), "fo:margin-top") == 0)
+			propList.insert("fo:margin-top", i()->getStr());
+		if (strcmp(i.key(), "fo:margin-bottom") == 0)
 		{
-			if (k()->getFloat() > 0.0f)
-				propList.insert("fo:margin-bottom", k()->getStr());
+			if (i()->getFloat() > 0.0f)
+				propList.insert("fo:margin-bottom", i()->getStr());
 			else
 				propList.insert("fo:margin-bottom", 0.0f);
 		}
-		if (strcmp(k.key(), "fo:line-height") == 0)
-			propList.insert("fo:line-height", k()->getStr());
-		if (strcmp(k.key(), "fo:break-before") == 0) 
-			propList.insert("fo:break-before", k()->getStr());
-		if (strcmp(k.key(), "fo:text-align") == 0) 
-			propList.insert("fo:text-align", k()->getStr());
-                if (strcmp(k.key(), "fo:text-align-last") == 0)
-                        propList.insert("fo:text-align-last", k()->getStr());
+		if (strcmp(i.key(), "fo:line-height") == 0)
+			propList.insert("fo:line-height", i()->getStr());
+		if (strcmp(i.key(), "fo:break-before") == 0) 
+			propList.insert("fo:break-before", i()->getStr());
+		if (strcmp(i.key(), "fo:text-align") == 0) 
+			propList.insert("fo:text-align", i()->getStr());
+		if (strcmp(i.key(), "fo:text-align-last") == 0)
+			propList.insert("fo:text-align-last", i()->getStr());
 	}
 	
 	propList.insert("style:justify-single-word", "false");
-	pHandler->startElement("style:properties", propList);
+	pHandler->startElement("style:paragraph-properties", propList);
 
-        if (mxTabStops.count() > 0) 
-        {
-                TagOpenElement tabListOpen("style:tab-stops");
-                tabListOpen.write(pHandler);
-                WPXPropertyListVector::Iter i(mxTabStops);
-                for (i.rewind(); i.next();)
-                {
-                        TagOpenElement tabStopOpen("style:tab-stop");
-                        
-                        WPXPropertyList::Iter j(i());
-                        for (j.rewind(); j.next(); )
-                        {
-                                tabStopOpen.addAttribute(j.key(), j()->getStr().cstr());			
-                        }
-                        tabStopOpen.write(pHandler);
-                        pHandler->endElement("style:tab-stop");
-                }
-                pHandler->endElement("style:tab-stops");
-        }
+	if (mxTabStops.count() > 0) 
+	{
+		TagOpenElement tabListOpen("style:tab-stops");
+		tabListOpen.write(pHandler);
+		WPXPropertyListVector::Iter i2(mxTabStops);
+		for (i2.rewind(); i2.next();)
+		{
+			if (i2()["style:position"] && i2()["style:position"]->getFloat() < 0)
+				continue;
+			TagOpenElement tabStopOpen("style:tab-stop");
+			
+			WPXPropertyList::Iter j(i2());
+			for (j.rewind(); j.next(); )
+			{
+				tabStopOpen.addAttribute(j.key(), j()->getStr().cstr());			
+			}
+			tabStopOpen.write(pHandler);
+			pHandler->endElement("style:tab-stop");
+		}
+		pHandler->endElement("style:tab-stops");
+	}
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:paragraph-properties");
 	pHandler->endElement("style:style");
 }
 
 SpanStyle::SpanStyle(const char *psName, const WPXPropertyList &xPropList) :
 	Style(psName),
-        mPropList(xPropList)
+	mPropList(xPropList)
 {
 }
 
-void SpanStyle::write(DocumentHandler *pHandler) const 
+void SpanStyle::write(DocumentHandlerInterface *pHandler) const 
 {
 	WRITER_DEBUG_MSG(("Writing a span style..\n"));
-        WPXPropertyList styleOpenList;    
+	WPXPropertyList styleOpenList;    
 	styleOpenList.insert("style:name", getName());
 	styleOpenList.insert("style:family", "text");
-        pHandler->startElement("style:style", styleOpenList);
+	pHandler->startElement("style:style", styleOpenList);
 
-        WPXPropertyList propList(mPropList);    
+	WPXPropertyList propList(mPropList);    
 
 	if (mPropList["style:font-name"])
 	{
@@ -144,8 +148,13 @@
 
 	if (mPropList["fo:font-size"])
 	{
-		propList.insert("style:font-size-asian", mPropList["fo:font-size"]->getStr());
-		propList.insert("style:font-size-complex", mPropList["fo:font-size"]->getStr());
+		if (mPropList["fo:font-size"]->getFloat() > 0.0f)
+		{
+			propList.insert("style:font-size-asian", mPropList["fo:font-size"]->getStr());
+			propList.insert("style:font-size-complex", mPropList["fo:font-size"]->getStr());
+		}
+		else
+			propList.remove("fo:font-size");
 	}
 	
 	if (mPropList["fo:font-weight"])
@@ -160,8 +169,8 @@
 		propList.insert("style:font-style-complex", mPropList["fo:font-style"]->getStr());
 	}
 
-        pHandler->startElement("style:properties", propList);
+	pHandler->startElement("style:text-properties", propList);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:text-properties");
 	pHandler->endElement("style:style");
 }
--- writerperfect/source/filter/TextRunStyle.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/TextRunStyle.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -29,26 +29,19 @@
 
 #ifndef _TEXTRUNSTYLE_H
 #define _TEXTRUNSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #include "Style.hxx"
 
 class TagOpenElement;
 class DocumentElement;
-class DocumentHandler;
 
 class ParagraphStyle
 {
 public:
 	ParagraphStyle(WPXPropertyList *propList, const WPXPropertyListVector &tabStops, const WPXString &sName);
 	virtual ~ParagraphStyle();
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	WPXString getName() const { return msName; }
 private:
 	WPXPropertyList *mpPropList;
@@ -61,7 +54,7 @@
 {
 public:
 	SpanStyle(const char *psName, const WPXPropertyList &xPropList);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 
 private:
         WPXPropertyList mPropList;
--- writerperfect/source/filter/WriterProperties.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/filter/WriterProperties.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -32,5 +32,4 @@
 #define IMP_DEFAULT_FONT_NAME "Times New Roman"
 #define IMP_DEFAULT_FONT_SIZE 12.0f
 #define IMP_DEFAULT_FONT_PITCH "variable"
-#define IMP_DEFAULT_FONT_COLOR (new RGBSColor(0x00,0x00,0x00,0x64))
 #endif
--- writerperfect/source/stream/WPXSvStream.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/stream/WPXSvStream.cxx	2008-04-09 11:06:19.000000000 +0200
@@ -9,7 +9,7 @@
 using namespace ::com::sun::star::io;
 
 WPXSvInputStream::WPXSvInputStream( Reference< XInputStream > xStream ) :
-		WPSInputStream(),
+		WPXInputStream(),
 		mxChildStorage(),
 		mxChildStream(),
 		mxStream(xStream),
@@ -41,7 +41,7 @@
 {
 }
 
-const uint8_t * WPXSvInputStream::read(size_t numBytes, size_t &numBytesRead)
+const unsigned char * WPXSvInputStream::read(size_t numBytes, size_t &numBytesRead)
 {
 	numBytesRead = 0;
 
@@ -52,7 +52,7 @@
 	if (numBytesRead == 0)
 		return 0;
 
-	return (const uint8_t *)maData.getConstArray();
+	return (const unsigned char *)maData.getConstArray();
 }
 
 long WPXSvInputStream::tell()
@@ -167,8 +167,3 @@
 	else
 		return 0;
 }
-
-WPXInputStream * WPXSvInputStream::getDocumentOLEStream()
-{
-	return getDocumentOLEStream( "PerfectOffice_MAIN" );
-}
--- writerperfect/source/stream/WPXSvStream.h	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/stream/WPXSvStream.h	2008-04-09 11:04:24.000000000 +0200
@@ -12,13 +12,12 @@
 #if defined _MSC_VER
 #pragma warning( push, 1 )
 #endif
-#include <libwps/WPSStream.h>
-#include <libwpd/WPXStream.h>
+#include <libwpd-stream/WPXStream.h>
 #if defined _MSC_VER
 #pragma warning( pop )
 #endif
 
-class WPXSvInputStream : public WPSInputStream
+class WPXSvInputStream : public WPXInputStream
 {
 public:
 	WPXSvInputStream( ::com::sun::star::uno::Reference<
@@ -26,10 +25,9 @@
 	virtual ~WPXSvInputStream();
 
 	virtual bool isOLEStream();
-	virtual WPXInputStream * getDocumentOLEStream();
 	virtual WPXInputStream * getDocumentOLEStream(const char *name);
 
-	virtual const uint8_t *read(size_t numBytes, size_t &numBytesRead);
+	virtual const unsigned char *read(size_t numBytes, size_t &numBytesRead);
 	virtual int seek(long offset, WPX_SEEK_TYPE seekType);
 	virtual long tell();
 	virtual bool atEOS();
--- writerperfect/source/wpdimp/makefile.mk	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpdimp/makefile.mk	2008-04-09 11:04:24.000000000 +0200
@@ -10,6 +10,10 @@
 INCPRE+=$(LIBWPD_CFLAGS)
 .ENDIF
 
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+INCPRE+=$(LIBWPG_CFLAGS)
+.ENDIF
+
 .IF "$(SYSTEM_LIBWPS)" == "YES"
 INCPRE+=$(LIBWPS_CFLAGS)
 .ENDIF
--- writerperfect/source/wpdimp/WordPerfectCollector.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpdimp/WordPerfectCollector.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -35,7 +35,7 @@
 #pragma warning( pop )
 #endif
 
-WordPerfectCollector::WordPerfectCollector(WPSInputStream *pInput, DocumentHandler *pHandler) :
+WordPerfectCollector::WordPerfectCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler) :
 	DocumentCollector(pInput, pHandler)
 {
 }
@@ -44,9 +44,9 @@
 {
 }
 
-bool WordPerfectCollector::parseSourceDocument(WPSInputStream &input)
+bool WordPerfectCollector::parseSourceDocument(WPXInputStream &input)
 {
-        WPDResult result = WPDocument::parse(&input, static_cast<WPXHLListenerImpl *>(this));
+        WPDResult result = WPDocument::parse(&input, static_cast<WPXDocumentInterface *>(this), NULL);
         if (result != WPD_OK)
                 return false;
 
--- writerperfect/source/wpdimp/WordPerfectCollector.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpdimp/WordPerfectCollector.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -30,12 +30,13 @@
 #define _WORDPERFECTCOLLECTOR_HXX
 
 #include "filter/DocumentCollector.hxx"
+#include "filter/DocumentHandlerInterface.hxx"
 
 class WordPerfectCollector : public DocumentCollector
 {
 public:
-	WordPerfectCollector(WPSInputStream *pInput, DocumentHandler *pHandler);
+	WordPerfectCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler);
 	virtual ~WordPerfectCollector();
-	bool parseSourceDocument(WPSInputStream &pInput);
+	bool parseSourceDocument(WPXInputStream &pInput);
 };
 #endif
--- writerperfect/source/wpdimp/WordPerfectImportFilter.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpdimp/WordPerfectImportFilter.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -136,7 +136,7 @@
 	sFileName = OUStringToOString(sURL, RTL_TEXTENCODING_INFO_ASCII);
 
 	// An XML import service: what we push sax messages to..
-	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLImporter" ) );
+	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLOasisImporter" ) );
 	uno::Reference < XDocumentHandler > xInternalHandler( mxMSF->createInstance( sXMLImportService ), UNO_QUERY );
 
 	// The XImporter sets up an empty target document for XDocumentHandler to write to.. 
@@ -221,7 +221,7 @@
 	if (input.atEOS())
         return ::rtl::OUString();
 
-	confidence = WPDocument::isFileFormatSupported(&input, false);
+	confidence = WPDocument::isFileFormatSupported(&input);
 
 	if (confidence == WPD_CONFIDENCE_EXCELLENT)
 		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "writer_WordPerfect_Document" ) );
--- writerperfect/source/wpgimp/makefile.mk	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpgimp/makefile.mk	2008-04-09 11:04:24.000000000 +0200
@@ -12,12 +12,6 @@
 INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwpd
 .ENDIF
 
-.IF "$(SYSTEM_LIBWPS)" == "YES"
-INCPRE+=$(LIBWPS_CFLAGS)
-.ELSE
-INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwps
-.ENDIF
-
 .IF "$(SYSTEM_LIBWPG)" == "YES"
 INCPRE+=$(LIBWPG_CFLAGS)
 .ELSE
@@ -28,7 +22,6 @@
 INCPRE+= -I..
 
 SLOFILES= \
-    $(SLO)$/OdgExporter.obj  \
     $(SLO)$/WPGImportFilter.obj \
 	$(SLO)$/wpgimport_genericfilter.obj		
 
--- writerperfect/source/wpgimp/WPGImportFilter.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpgimp/WPGImportFilter.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -75,7 +75,7 @@
 #endif
 
 #include "filter/DocumentHandler.hxx"
-#include "OdgExporter.hxx"
+#include "filter/OdgExporter.hxx"
 #include "WPGImportFilter.hxx"
 #include "stream/WPXSvStream.h"
 
@@ -148,16 +148,6 @@
 
 	WPXInputStream* input = new WPXSvInputStream( xInputStream );
 
-	if (input->isOLEStream())
-	{
-		WPXInputStream* olestream = input->getDocumentOLEStream();
-		if (olestream)
-		{
-			delete input;
-			input = olestream;
-		}
-	}
-
 	OdgExporter exporter(&xHandler);
 	bool tmpParseResult = libwpg::WPGraphics::parse(input, &exporter);
 	if (input)
@@ -207,16 +197,6 @@
     
 	WPXInputStream* input = new WPXSvInputStream( xInputStream );
 
-	if (input->isOLEStream())
-	{
-		WPXInputStream* olestream = input->getDocumentOLEStream();
-		if (olestream)
-		{
-			delete input;
-			input = olestream;
-		}
-	}
-
 	if (libwpg::WPGraphics::isSupported(input))
 		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "draw_WordPerfect_Graphics" ) );
 
--- writerperfect/source/wpsimp/MSWorksCollector.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpsimp/MSWorksCollector.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -29,7 +29,7 @@
 #include "MSWorksCollector.hxx"
 #include <libwps/WPSDocument.h>
 
-MSWorksCollector::MSWorksCollector(WPSInputStream *pInput, DocumentHandler *pHandler) :
+MSWorksCollector::MSWorksCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler) :
 	DocumentCollector(pInput, pHandler)
 {
 }
@@ -38,9 +38,9 @@
 {
 }
 
-bool MSWorksCollector::parseSourceDocument(WPSInputStream &input)
+bool MSWorksCollector::parseSourceDocument(WPXInputStream &input)
 {
-        WPSResult result = WPSDocument::parse(&input, static_cast<WPXHLListenerImpl *>(this));
+        WPSResult result = WPSDocument::parse(&input, static_cast<WPXDocumentInterface *>(this));
         if (result != WPS_OK)
                 return false;
 
--- writerperfect/source/wpsimp/MSWorksCollector.hxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpsimp/MSWorksCollector.hxx	2008-04-09 11:04:24.000000000 +0200
@@ -30,12 +30,13 @@
 #define _MSWORKSCOLLECTOR_HXX
 
 #include "filter/DocumentCollector.hxx"
+#include "filter/DocumentHandlerInterface.hxx"
 
 class MSWorksCollector : public DocumentCollector
 {
 public:
-	MSWorksCollector(WPSInputStream *pInput, DocumentHandler *pHandler);
+	MSWorksCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler);
 	virtual ~MSWorksCollector();
-	bool parseSourceDocument(WPSInputStream &input);
+	bool parseSourceDocument(WPXInputStream &input);
 };
 #endif
--- writerperfect/source/wpsimp/MSWorksImportFilter.cxx	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/source/wpsimp/MSWorksImportFilter.cxx	2008-04-09 11:04:24.000000000 +0200
@@ -127,7 +127,7 @@
 	sFileName = OUStringToOString(sURL, RTL_TEXTENCODING_INFO_ASCII);
 	
 	// An XML import service: what we push sax messages to..
-	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLImporter" ) );
+	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLOasisImporter" ) );
 	Reference < XDocumentHandler > xInternalHandler( mxMSF->createInstance( sXMLImportService ), UNO_QUERY );
 
 	// The XImporter sets up an empty target document for XDocumentHandler to write to.. 
@@ -212,7 +212,7 @@
 	if (input.atEOS())
         return ::rtl::OUString();
 
-	confidence = WPSDocument::isFileFormatSupported(&input, false);
+	confidence = WPSDocument::isFileFormatSupported(&input);
 
 	if ((confidence == WPS_CONFIDENCE_EXCELLENT) || (confidence == WPS_CONFIDENCE_GOOD))
 		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "writer_MS_Works_Document" ) );
--- writerperfect/util/makefile.mk	2008-04-09 11:04:01.000000000 +0200
+++ writerperfect/util/makefile.mk	2008-04-09 11:04:24.000000000 +0200
@@ -53,7 +53,8 @@
  	$(CPPULIB) \
 	$(SALLIB) \
 	$(XMLOFFLIB) \
-	$(LIBWPD)
+	$(LIBWPD) \
+	$(LIBWPG)
 
 SHL1TARGET = wpft$(DLLPOSTFIX)
 SHL1IMPLIB = i$(SHL1TARGET)
@@ -82,7 +83,8 @@
 	$(SALLIB) \
 	$(XMLOFFLIB) \
 	$(LIBWPS) \
-	$(LIBWPD)
+	$(LIBWPD) \
+	$(LIBWPG)
 
 SHL2TARGET = msworks$(DLLPOSTFIX)
 SHL2IMPLIB = i$(SHL2TARGET)
