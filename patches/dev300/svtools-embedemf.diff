diff -rup svtools-orig-1/source/filter.vcl/wmf/winmtf.cxx svtools/source/filter.vcl/wmf/winmtf.cxx
--- svtools-orig-1/source/filter.vcl/wmf/winmtf.cxx	2009-12-08 18:01:50.000000000 +0100
+++ svtools/source/filter.vcl/wmf/winmtf.cxx	2009-12-08 18:02:32.000000000 +0100
@@ -2293,3 +2293,8 @@ void WinMtfOutput::PassEMFPlus( void* pB
     EMFP_DEBUG(printf ("\t\t\tadd EMF_PLUS comment length %d\n", nLength));
     mpGDIMetaFile->AddAction( new MetaCommentAction( "EMF_PLUS", 0, static_cast<const BYTE*>(pBuffer), nLength ) );
 }
+
+void WinMtfOutput::AddFromGDIMetaFile( GDIMetaFile& rGDIMetaFile )
+{
+   rGDIMetaFile.Play( *mpGDIMetaFile, 0xFFFFFFFF );
+}
diff -rup svtools-orig-1/source/filter.vcl/wmf/winmtf.hxx svtools/source/filter.vcl/wmf/winmtf.hxx
--- svtools-orig-1/source/filter.vcl/wmf/winmtf.hxx	2009-12-08 18:01:50.000000000 +0100
+++ svtools/source/filter.vcl/wmf/winmtf.hxx	2009-12-08 18:02:03.000000000 +0100
@@ -692,6 +692,7 @@ class WinMtfOutput
         void				MoveClipRegion( const Size& rSize );
         void				SetClipPath( const PolyPolygon& rPolyPoly, sal_Int32 nClippingMode, sal_Bool bIsMapped );
         void				UpdateClipRegion();
+        void				AddFromGDIMetaFile( GDIMetaFile& rGDIMetaFile );
 
         void                PassEMFPlus( void* pBuffer, UINT32 nLength );
         void                PassEMFPlusHeaderInfo();
@@ -761,6 +762,18 @@ private:
     UINT16			nUnitsPerInch;
     sal_uInt32		nRecSize;
 
+    // embedded EMF data
+    SvMemoryStream* pEMFStream; 
+
+    // total number of comment records containing EMF data
+    sal_uInt32      nEMFRecCount;
+    
+    // number of EMF records read
+    sal_uInt32      nEMFRec;
+
+    // total size of embedded EMF data
+    sal_uInt32      nEMFSize;
+
     sal_uInt32		nSkipActions;
     sal_uInt32		nCurrentAction;
     sal_uInt32		nUnicodeEscapeAction;
@@ -781,6 +794,8 @@ public:
 
                     WMFReader( SvStream& rStreamWMF, GDIMetaFile& rGDIMetaFile, FilterConfigItem* pConfigItem = NULL )
                         : WinMtf( new WinMtfOutput( rGDIMetaFile ), rStreamWMF, pConfigItem ) {};
+                    
+                    ~WMFReader();
 
     // Liesst aus dem Stream eine WMF-Datei und fuellt das GDIMetaFile
 	void			ReadWMF(WMF_APMFILEHEADER *pAPMHeader=NULL);
diff -rup svtools-orig-1/source/filter.vcl/wmf/winwmf.cxx svtools/source/filter.vcl/wmf/winwmf.cxx
--- svtools-orig-1/source/filter.vcl/wmf/winwmf.cxx	2009-12-08 18:01:50.000000000 +0100
+++ svtools/source/filter.vcl/wmf/winwmf.cxx	2009-12-08 18:07:59.000000000 +0100
@@ -32,6 +32,7 @@
 #include "precompiled_svtools.hxx"
 
 #include "winmtf.hxx"
+#include <vcl/gdimtf.hxx>
 #include <svtools/wmf.hxx>
 #include <rtl/crc.h>
 #include <rtl/tencinfo.h>
@@ -832,81 +833,136 @@ void WMFReader::ReadRecordParams( USHORT
                 pWMF->SetError( SVSTREAM_FILEFORMAT_ERROR );
                 break;
             }
-            if ( nRecSize >= 12 )	// minimal escape lenght
+            if ( nRecSize >= 4 )	// minimal escape lenght
             {
-                sal_uInt16	nMode, nLen, OO;
-                sal_uInt32  Magic, nCheck,nEsc;
+                sal_uInt16	nMode, nLen;
                 *pWMF >> nMode
-                      >> nLen
-                      >> OO
-                      >> Magic
-                      >> nCheck
-                      >> nEsc;
-                if ( ( nMode == W_MFCOMMENT ) && ( nLen >= 14 ) && ( OO == 0x4f4f ) && ( Magic == 0xa2c2a ) )
+                      >> nLen;
+                if ( ( nMode == W_MFCOMMENT ) && ( nLen >= 4 ) )
                 {
-                    sal_uInt32 nEscLen = nLen - 14;
-                    if ( nEscLen <= ( nRecSize * 2 ) )
+                    sal_uInt32 nNewMagic; // we have to read int32 for 
+                    *pWMF >> nNewMagic;   // META_ESCAPE_ENHANCED_METAFILE CommentIdentifier
+                    
+                    if( nNewMagic == 0x2c2a4f4f &&  nLen >= 14 )
                     {
+                        sal_uInt16 nMagic2;
+                        *pWMF >> nMagic2;
+                        if( nMagic2 == 0x0a ) // 2nd half of magic
+                        {                     // continue with private escape  
+                            sal_uInt32 nCheck, nEsc;
+                            *pWMF >> nCheck
+                                  >> nEsc;
+
+                            sal_uInt32 nEscLen = nLen - 14;
+                            if ( nEscLen <= ( nRecSize * 2 ) )
+                            {
 #ifdef OSL_BIGENDIAN
-                        sal_uInt32 nTmp = SWAPLONG( nEsc );
-                        sal_uInt32 nCheckSum = rtl_crc32( 0, &nTmp, 4 );
+                                sal_uInt32 nTmp = SWAPLONG( nEsc );
+                                sal_uInt32 nCheckSum = rtl_crc32( 0, &nTmp, 4 );
 #else
-                        sal_uInt32 nCheckSum = rtl_crc32( 0, &nEsc, 4 );
+                                sal_uInt32 nCheckSum = rtl_crc32( 0, &nEsc, 4 );
 #endif
-                        sal_Int8* pData = NULL;
+                                sal_Int8* pData = NULL;
 
-                        if ( ( static_cast< sal_uInt64 >( nEscLen ) + pWMF->Tell() ) > nMetaRecEndPos )
-                        {
-                            pWMF->SetError( SVSTREAM_FILEFORMAT_ERROR );
-                            break;
-                        }
-                        if ( nEscLen > 0 )
-                        {
-                            pData = new sal_Int8[ nEscLen ];
-                            pWMF->Read( pData, nEscLen );
-                            nCheckSum = rtl_crc32( nCheckSum, pData, nEscLen );
+                                if ( ( static_cast< sal_uInt64 >( nEscLen ) + pWMF->Tell() ) > nMetaRecEndPos )
+                                {
+                                    pWMF->SetError( SVSTREAM_FILEFORMAT_ERROR );
+                                    break;
+                                }
+                                if ( nEscLen > 0 )
+                                {
+                                    pData = new sal_Int8[ nEscLen ];
+                                    pWMF->Read( pData, nEscLen );
+                                    nCheckSum = rtl_crc32( nCheckSum, pData, nEscLen );
+                                }
+                                if ( nCheck == nCheckSum )
+                                {
+                                    switch( nEsc )
+                                    {
+                                        case PRIVATE_ESCAPE_UNICODE :
+                                        {	// we will use text instead of polygons only if we have the correct font
+                                            if ( aVDev.IsFontAvailable( pOut->GetFont().GetName() ) )
+                                            {
+                                                Point  aPt;
+                                                String aString;
+                                                sal_uInt32	i, nStringLen, nDXCount;
+                                                sal_Int32* pDXAry = NULL;
+                                                SvMemoryStream aMemoryStream( nEscLen );
+                                                aMemoryStream.Write( pData, nEscLen );
+                                                aMemoryStream.Seek( STREAM_SEEK_TO_BEGIN );
+                                                aMemoryStream >> aPt.X()
+                                                              >> aPt.Y()
+                                                              >> nStringLen;
+
+                                                if ( ( static_cast< sal_uInt64 >( nStringLen ) * sizeof( sal_Unicode ) ) < ( nEscLen - aMemoryStream.Tell() ) )
+                                                {
+                                                    sal_Unicode* pBuf = aString.AllocBuffer( (xub_StrLen)nStringLen );
+                                                    for ( i = 0; i < nStringLen; i++ )
+                                                        aMemoryStream >> pBuf[ i ];
+                                                    aMemoryStream >> nDXCount;
+                                                    if ( ( static_cast< sal_uInt64 >( nDXCount ) * sizeof( sal_Int32 ) ) >= ( nEscLen - aMemoryStream.Tell() ) )
+                                                        nDXCount = 0;
+                                                    if ( nDXCount )
+                                                        pDXAry = new sal_Int32[ nDXCount ];
+                                                    for  ( i = 0; i < nDXCount; i++ )
+                                                        aMemoryStream >> pDXAry[ i ];
+                                                    aMemoryStream >> nSkipActions;
+                                                    pOut->DrawText( aPt, aString, pDXAry );
+                                                    delete[] pDXAry;
+                                                }
+                                            }
+                                        }
+                                        break;
+                                    }
+                                }
+                                delete[] pData;
+                            }
                         }
-                        if ( nCheck == nCheckSum )
+                    }
+                    else if ( nNewMagic == 0x43464D57 && nLen >= 34 && (((sal_uInt32)nLen) + 10 <= nRecSize * 2 ))
+                    {
+                        sal_uInt32 nComType, nVersion, nFlags, nComRecCount, 
+                                   nCurRecSize, nRemainingSize, nEMFTotalSize;
+                        sal_uInt16 nCheck;
+                        
+                        *pWMF >> nComType >> nVersion >> nCheck >> nFlags
+                              >> nComRecCount >> nCurRecSize 
+                              >> nRemainingSize >> nEMFTotalSize; // the nRemainingSize is not mentioned in MSDN documentation
+                                                                  // but it seems to be required to read in data produced by OLE
+
+                        if( nComType == 0x01 && nVersion == 0x10000 && nComRecCount )
                         {
-                            switch( nEsc )
+                            if( !nEMFRec )
+                            {   // first EMF comment
+                                nEMFRecCount    = nComRecCount;
+                                nEMFSize        = nEMFTotalSize;
+                                pEMFStream = new SvMemoryStream( 0x20000 );
+                            }
+                            else if( nEMFRecCount != nComRecCount ) // add additional checks here
                             {
-                                case PRIVATE_ESCAPE_UNICODE :
-                                {	// we will use text instead of polygons only if we have the correct font
-                                    if ( aVDev.IsFontAvailable( pOut->GetFont().GetName() ) )
-                                    {
-                                        Point  aPt;
-                                        String aString;
-                                        sal_uInt32	i, nStringLen, nDXCount;
-                                        sal_Int32* pDXAry = NULL;
-                                        SvMemoryStream aMemoryStream( nEscLen );
-                                        aMemoryStream.Write( pData, nEscLen );
-                                        aMemoryStream.Seek( STREAM_SEEK_TO_BEGIN );
-                                        aMemoryStream >> aPt.X()
-                                                      >> aPt.Y()
-                                                      >> nStringLen;
-
-                                        if ( ( static_cast< sal_uInt64 >( nStringLen ) * sizeof( sal_Unicode ) ) < ( nEscLen - aMemoryStream.Tell() ) )
-                                        {
-                                            sal_Unicode* pBuf = aString.AllocBuffer( (xub_StrLen)nStringLen );
-                                            for ( i = 0; i < nStringLen; i++ )
-                                                aMemoryStream >> pBuf[ i ];
-                                            aMemoryStream >> nDXCount;
-                                            if ( ( static_cast< sal_uInt64 >( nDXCount ) * sizeof( sal_Int32 ) ) >= ( nEscLen - aMemoryStream.Tell() ) )
-                                                nDXCount = 0;
-                                            if ( nDXCount )
-                                                pDXAry = new sal_Int32[ nDXCount ];
-                                            for  ( i = 0; i < nDXCount; i++ )
-                                                aMemoryStream >> pDXAry[ i ];
-                                            aMemoryStream >> nSkipActions;
-                                            pOut->DrawText( aPt, aString, pDXAry );
-                                            delete[] pDXAry;
-                                        }
-                                    }
-                                }
-                                break;
+                                // total records should be the same as in previous comments
+                                nEMFRecCount = 0xFFFFFFFF;
+                                delete pEMFStream;
+                                pEMFStream = NULL;
+                            }
+                            nEMFRec++;
+
+                            if( pEMFStream && nCurRecSize + 34 > nLen )
+                            {
+                                nEMFRecCount = 0xFFFFFFFF;
+                                delete pEMFStream;
+                                pEMFStream = NULL;
+                            }
+                            
+                            if( pEMFStream )
+                            {
+                                sal_Int8* pBuf = new sal_Int8[ nCurRecSize ];
+                                sal_uInt32 nCount = pWMF->Read( pBuf, nCurRecSize );
+                                if( nCount == nCurRecSize )
+                                    pEMFStream->Write( pBuf, nCount );
+                                delete[] pBuf;
                             }
                         }
-                        delete[] pData;
                     }
                 }
             }
@@ -1032,6 +1088,11 @@ void WMFReader::ReadWMF(WMF_APMFILEHEADE
     nCurrentAction = 0;
     nUnicodeEscapeAction = 0;
 
+    pEMFStream      = NULL;
+    nEMFRecCount    = 0;
+    nEMFRec         = 0;
+    nEMFSize        = 0;
+
     pOut->SetMapMode( MM_ANISOTROPIC );
     pOut->SetWinOrg( Point() );
     pOut->SetWinExt( Size( 1, 1 ) );
@@ -1079,6 +1140,33 @@ void WMFReader::ReadWMF(WMF_APMFILEHEADE
                     ReadRecordParams( nFunction );
                 else
                     nSkipActions--;
+                
+                if( pEMFStream && nEMFRecCount == nEMFRec )
+                {
+                    GDIMetaFile aMeta;
+                    pEMFStream->Seek( 0 );
+                    EnhWMFReader* pEMFReader = new EnhWMFReader ( *pEMFStream, aMeta );
+                    BOOL bRead = pEMFReader->ReadEnhWMF();
+                    delete pEMFReader; // destroy first!!!
+
+                    if( bRead )   
+                    {
+                       pOut->AddFromGDIMetaFile( aMeta );
+                       pOut->SetrclFrame( Rectangle(0, 0, aMeta.GetPrefSize().Width(), aMeta.GetPrefSize().Height() ));
+                       // we have successfully read the embedded EMF data
+                       // no need to process WMF data further
+                       break;
+                    }
+                    else
+                    {
+                        // something went wrong
+                        // continue with WMF, don't try this again
+                        delete pEMFStream;
+                        pEMFStream = NULL;
+                    }
+
+                }
+
                 nPos += nRecSize * 2;
                 if ( nPos <= nEndPos )
                     pWMF->Seek( nPos  );
@@ -1342,3 +1430,9 @@ sal_Bool WMFReader::GetPlaceableBound( R
     return bRet;
 }
 
+WMFReader::~WMFReader()
+{
+    if( pEMFStream )
+        delete pEMFStream;
+}
+
diff -rup svtools-orig-1/source/filter.vcl/wmf/wmfwr.cxx svtools/source/filter.vcl/wmf/wmfwr.cxx
--- svtools-orig-1/source/filter.vcl/wmf/wmfwr.cxx	2009-12-08 18:01:50.000000000 +0100
+++ svtools/source/filter.vcl/wmf/wmfwr.cxx	2009-12-08 18:04:25.000000000 +0100
@@ -33,6 +33,7 @@
 
 #include <vcl/salbtype.hxx>
 #include "wmfwr.hxx"
+#include "emfwr.hxx"
 #include <vcl/fontcvt.hxx>
 #include <rtl/crc.h>
 #include <rtl/tencinfo.h>
@@ -1807,6 +1808,7 @@ BOOL WMFWriter::WriteWMF( const GDIMetaF
 {
     WMFWriterAttrStackMember * pAt;
 
+    bEmbedEMF = TRUE;
     bStatus=TRUE;
     pConvert = 0;
     pVirDev = new VirtualDevice;
@@ -1870,6 +1872,8 @@ BOOL WMFWriter::WriteWMF( const GDIMetaF
     CountActionsAndBitmaps(rMTF);
 
     WriteHeader(rMTF,bPlaceable);
+    if( bEmbedEMF )
+        WriteEmbeddedEMF( rMTF );
     WMFRecord_SetWindowOrg(Point(0,0));
     WMFRecord_SetWindowExt(rMTF.GetPrefSize());
     WMFRecord_SetBkMode( TRUE );
@@ -1948,3 +1952,82 @@ USHORT WMFWriter::CalcSaveTargetMapMode(
 
     return nDivisor;
 }
+
+// ------------------------------------------------------------------------
+
+void WMFWriter::WriteEmbeddedEMF( const GDIMetaFile& rMTF )
+{
+    EMFWriter aEMFWriter;
+    SvMemoryStream aStream;
+    if( aEMFWriter.WriteEMF( rMTF, aStream ) )
+    {
+        aStream.Seek( 0 );
+        sal_Size nTotalSize = aStream.GetSize();
+        if( nTotalSize > SAL_MAX_UINT32 )
+            return;
+        sal_uInt32 nRemainingSize = static_cast< sal_uInt32 >( nTotalSize );
+        sal_uInt32 nRecCounts = ( (nTotalSize - 1) / 0x2000 ) + 1;
+        sal_uInt16 nCheckSum = 0, nWord;
+
+        sal_uInt32 nPos = 0;
+
+        while( nPos + 1 < nTotalSize )
+        {
+            aStream >> nWord;
+            nCheckSum ^= nWord;
+            nPos += 2;
+        }
+
+        nCheckSum = static_cast< sal_uInt16 >( nCheckSum * -1 );
+
+        aStream.Seek( 0 );
+        while( nRemainingSize > 0 )
+        {
+            sal_uInt32 nCurSize;
+            if( nRemainingSize > 0x2000 )
+            {
+                nCurSize = 0x2000;
+                nRemainingSize -= 0x2000;
+            }
+            else
+            {
+                nCurSize = nRemainingSize;
+                nRemainingSize = 0;
+            }
+            WriteEMFRecord( aStream, 
+                            nCurSize, 
+                            nRemainingSize,
+                            nTotalSize,
+                            nRecCounts,
+                            nCheckSum );
+            nCheckSum = 0;
+        }
+    }
+}
+   
+// ------------------------------------------------------------------------
+
+void WMFWriter::WriteEMFRecord( SvStream& rStream, sal_uInt32 nCurSize, sal_uInt32 nRemainingSize,
+                sal_uInt32 nTotalSize, sal_uInt32 nRecCounts, sal_uInt16 nCheckSum )
+{
+   // according to http://msdn.microsoft.com/en-us/library/dd366152%28PROT.13%29.aspx
+   WriteRecordHeader( 0, W_META_ESCAPE ); 
+   *pWMF << (sal_uInt16)W_MFCOMMENT     // same as META_ESCAPE_ENHANCED_METAFILE
+          << (sal_uInt16)( nCurSize + 34 )	// we will always have a 34 byte escape header:
+          << (sal_uInt32) 0x43464D57		// WMFC
+          << (sal_uInt32) 0x00000001		// Comment type
+          << (sal_uInt32) 0x00010000        // version
+          << nCheckSum                      // check sum
+          << (sal_uInt32) 0                 // flags = 0
+          << nRecCounts                     // total number of records
+          << nCurSize                       // size of this record's data
+          << nRemainingSize                 // remaining size of data in following records, missing in MSDN documentation
+          << nTotalSize;                    // total size of EMF stream
+
+   sal_Int8* pBuf = new sal_Int8[ nCurSize ];
+   sal_uInt32 nCount = rStream.Read( pBuf, nCurSize );
+   if( nCount == nCurSize )
+       pWMF->Write( pBuf, nCount );
+   delete[] pBuf; 
+   UpdateRecordHeader();
+}
diff -rup svtools-orig-1/source/filter.vcl/wmf/wmfwr.hxx svtools/source/filter.vcl/wmf/wmfwr.hxx
--- svtools-orig-1/source/filter.vcl/wmf/wmfwr.hxx	2009-12-08 18:01:50.000000000 +0100
+++ svtools/source/filter.vcl/wmf/wmfwr.hxx	2009-12-08 18:02:03.000000000 +0100
@@ -128,6 +128,8 @@ private:
     ULONG nWrittenBitmaps;  // Anzahl der bereits geschriebenen Bitmaps
     ULONG nActBitmapPercent; // Wieviel Prozent die naechste Bitmap schon geschrieben ist.
 
+    BOOL bEmbedEMF; // optionally embedd EMF data into WMF
+
     void MayCallback();
         // Berechnet anhand der obigen 5 Parameter eine Prozentzahl
         // und macht dann ggf. einen Callback. Setzt bStatus auf FALSE wenn User abbrechen
@@ -207,6 +209,13 @@ private:
     void WriteHeader(const GDIMetaFile & rMTF, BOOL bPlaceable);
     void UpdateHeader();
 
+    void WriteEmbeddedEMF( const GDIMetaFile& rMTF );
+    void WriteEMFRecord( SvStream& rStream, sal_uInt32 nCurSize, 
+                            sal_uInt32 nRemainingSize,
+                            sal_uInt32 nTotalSize,
+                            sal_uInt32 nRecCounts,
+                            sal_uInt16 nCheckSum );
+
     USHORT CalcSaveTargetMapMode(MapMode& rMapMode, const Size& rPrefSize);
 
 public:
