OpenGL transitions for the Mac

From: eric b <eric.bachard@free.fr>


---

 boost/prj/d.lst                                    |   19 
 configure.in                                       |   25 
 scp2/source/impress/makefile.mk                    |    4 
 scp2/source/impress/module_impress.scp             |    3 
 scp2/source/impress/module_ogltrans.scp            |    6 
 scp2/source/ooo/file_library_ooo.scp               |    2 
 scp2/source/ooo/makefile.mk                        |    4 
 slideshow/prj/build.lst                            |    4 
 .../source/engine/OGLTrans/OGLTrans_Shaders.cxx    |  143 --
 .../source/engine/OGLTrans/OGLTrans_Shaders.hxx    |   71 -
 .../engine/OGLTrans/OGLTrans_TransitionImpl.cxx    | 1318 ------------------
 .../engine/OGLTrans/OGLTrans_TransitionImpl.hxx    |  509 -------
 .../engine/OGLTrans/OGLTrans_TransitionerImpl.cxx  | 1487 --------------------
 .../engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.h  |   94 +
 .../engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.m  |  236 +++
 .../OGLTrans/mac/OGLTrans_TransitionImpl.hxx       |  501 +++++++
 .../OGLTrans/mac/OGLTrans_TransitionImpl_MACOSX.mm | 1329 ++++++++++++++++++
 .../mac/OGLTrans_TransitionerImpl_MACOSX.mm        | 1137 +++++++++++++++
 .../source/engine/OGLTrans/mac/aquaOpenGLView.h    |   36 
 .../source/engine/OGLTrans/mac/aquaOpenGLView.m    |  195 +++
 slideshow/source/engine/OGLTrans/mac/makefile.mk   |   87 +
 slideshow/source/engine/OGLTrans/makefile.mk       |   84 -
 .../engine/OGLTrans/unx/OGLTrans_Shaders.hxx       |   71 +
 .../engine/OGLTrans/unx/OGLTrans_Shaders_LINUX.cxx |  143 ++
 .../OGLTrans/unx/OGLTrans_TransitionImpl.cxx       | 1318 ++++++++++++++++++
 .../OGLTrans/unx/OGLTrans_TransitionImpl.hxx       |  509 +++++++
 .../unx/OGLTrans_TransitionerImpl_LINUX.cxx        | 1487 ++++++++++++++++++++
 slideshow/source/engine/OGLTrans/unx/makefile.mk   |   76 +
 .../engine/OGLTrans/win/OGLTrans_Shaders.hxx       |   71 +
 .../engine/OGLTrans/win/OGLTrans_Shaders_WNT.cxx   |  143 ++
 .../OGLTrans/win/OGLTrans_TransitionImpl.cxx       | 1321 ++++++++++++++++++
 .../OGLTrans/win/OGLTrans_TransitionImpl.hxx       |  513 +++++++
 .../OGLTrans/win/OGLTrans_TransitionerImpl_WNT.cxx | 1455 ++++++++++++++++++++
 slideshow/source/engine/OGLTrans/win/makefile.mk   |   76 +
 34 files changed, 10851 insertions(+), 3626 deletions(-)
 delete mode 100644 slideshow/source/engine/OGLTrans/OGLTrans_Shaders.cxx
 delete mode 100644 slideshow/source/engine/OGLTrans/OGLTrans_Shaders.hxx
 delete mode 100644 slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
 delete mode 100644 slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
 delete mode 100644 slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.h
 create mode 100644 slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.m
 create mode 100644 slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl.hxx
 create mode 100644 slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl_MACOSX.mm
 create mode 100644 slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionerImpl_MACOSX.mm
 create mode 100644 slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.h
 create mode 100644 slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.m
 create mode 100644 slideshow/source/engine/OGLTrans/mac/makefile.mk
 delete mode 100644 slideshow/source/engine/OGLTrans/makefile.mk
 create mode 100644 slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders.hxx
 create mode 100644 slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders_LINUX.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.hxx
 create mode 100644 slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionerImpl_LINUX.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/unx/makefile.mk
 create mode 100644 slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders.hxx
 create mode 100644 slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders_WNT.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.hxx
 create mode 100644 slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionerImpl_WNT.cxx
 create mode 100644 slideshow/source/engine/OGLTrans/win/makefile.mk


diff --git boost/prj/d.lst boost/prj/d.lst
index fbbb575..e2cb301 100644
--- boost/prj/d.lst
+++ boost/prj/d.lst
@@ -1,4 +1,7 @@
 mkdir: %_DEST%\inc%_EXT%\boost
+mkdir: %_DEST%\inc%_EXT%\boost\algorithm\string
+mkdir: %_DEST%\inc%_EXT%\boost\algorithm\string\detail
+mkdir: %_DEST%\inc%_EXT%\boost\algorithm\string\std
 mkdir: %_DEST%\inc%_EXT%\boost\bind
 mkdir: %_DEST%\inc%_EXT%\boost\concept
 mkdir: %_DEST%\inc%_EXT%\boost\concept\detail
@@ -7,6 +10,9 @@ mkdir: %_DEST%\inc%_EXT%\boost\config\compiler
 mkdir: %_DEST%\inc%_EXT%\boost\config\no_tr1
 mkdir: %_DEST%\inc%_EXT%\boost\config\platform
 mkdir: %_DEST%\inc%_EXT%\boost\config\stdlib
+mkdir: %_DEST%\inc%_EXT%\boost\date_time\gregorian
+mkdir: %_DEST%\inc%_EXT%\boost\date_time\local_time
+mkdir: %_DEST%\inc%_EXT%\boost\date_time\posix_time
 mkdir: %_DEST%\inc%_EXT%\boost\detail
 mkdir: %_DEST%\inc%_EXT%\boost\function
 mkdir: %_DEST%\inc%_EXT%\boost\function\detail
@@ -15,6 +21,7 @@ mkdir: %_DEST%\inc%_EXT%\boost\iterator\detail
 mkdir: %_DEST%\inc%_EXT%\boost\exception
 mkdir: %_DEST%\inc%_EXT%\boost\exception\detail
 mkdir: %_DEST%\inc%_EXT%\boost\function
+mkdir: %_DEST%\inc%_EXT%\boost\io
 mkdir: %_DEST%\inc%_EXT%\boost\mpl
 mkdir: %_DEST%\inc%_EXT%\boost\mpl\aux_
 mkdir: %_DEST%\inc%_EXT%\boost\mpl\aux_\config
@@ -83,6 +90,8 @@ mkdir: %_DEST%\inc%_EXT%\boost\preprocessor\seq\detail
 mkdir: %_DEST%\inc%_EXT%\boost\preprocessor\slot
 mkdir: %_DEST%\inc%_EXT%\boost\preprocessor\slot\detail
 mkdir: %_DEST%\inc%_EXT%\boost\preprocessor\tuple
+mkdir: %_DEST%\inc%_EXT%\boost\range
+mkdir: %_DEST%\inc%_EXT%\boost\range\detail
 mkdir: %_DEST%\inc%_EXT%\boost\spirit
 mkdir: %_DEST%\inc%_EXT%\boost\spirit\actor
 mkdir: %_DEST%\inc%_EXT%\boost\spirit\attribute
@@ -306,8 +315,18 @@ mkdir: %_DEST%\inc%_EXT%\boost\variant\detail
 ..\%__SRC%\inc\boost\utility\* %_DEST%\inc%_EXT%\boost\utility
 ..\%__SRC%\inc\boost\variant\* %_DEST%\inc%_EXT%\boost\variant
 ..\%__SRC%\inc\boost\variant\detail\* %_DEST%\inc%_EXT%\boost\variant\detail
+..\%__SRC%\misc\build\boost_1_39_0\boost\algorithm\string\* %_DEST%\inc%_EXT%\boost\algorithm\string\
+..\%__SRC%\misc\build\boost_1_39_0\boost\algorithm\string\detail\* %_DEST%\inc%_EXT%\boost\algorithm\string\detail
+..\%__SRC%\misc\build\boost_1_39_0\boost\algorithm\string\std\* %_DEST%\inc%_EXT%\boost\algorithm\string\std
 ..\%__SRC%\misc\build\boost_1_39_0\boost\concept\* %_DEST%\inc%_EXT%\boost\concept
 ..\%__SRC%\misc\build\boost_1_39_0\boost\concept\detail\* %_DEST%\inc%_EXT%\boost\concept\detail
+..\%__SRC%\misc\build\boost_1_39_0\boost\date_time\* %_DEST%\inc%_EXT%\boost\date_time\*
+..\%__SRC%\misc\build\boost_1_39_0\boost\date_time\gregorian\* %_DEST%\inc%_EXT%\boost\date_time\gregorian
+..\%__SRC%\misc\build\boost_1_39_0\boost\date_time\local_time\* %_DEST%\inc%_EXT%\boost\date_time\local_time
+..\%__SRC%\misc\build\boost_1_39_0\boost\date_time\posix_time\* %_DEST%\inc%_EXT%\boost\date_time\posix_time
+..\%__SRC%\misc\build\boost_1_39_0\boost\io\* %_DEST%\inc%_EXT%\boost\io
+..\%__SRC%\misc\build\boost_1_39_0\boost\range\* %_DEST%\inc%_EXT%\boost\range
+..\%__SRC%\misc\build\boost_1_39_0\boost\range\detail\* %_DEST%\inc%_EXT%\boost\range\detail
 ..\%__SRC%\misc\build\boost_1_39_0\boost\spirit\home\classic\* %_DEST%\inc%_EXT%\boost\spirit\home\classic\
 ..\%__SRC%\misc\build\boost_1_39_0\boost\spirit\home\classic\attribute\* %_DEST%\inc%_EXT%\boost\spirit\home\classic\attribute
 ..\%__SRC%\misc\build\boost_1_39_0\boost\spirit\home\classic\dynamic\* %_DEST%\inc%_EXT%\boost\spirit\home\classic\dynamic
diff --git configure.in configure.in
index 64db7c3..aa97422 100644
--- configure.in
+++ configure.in
@@ -5907,19 +5907,24 @@ dnl ===================================================================
 AC_MSG_CHECKING([whether to build the OpenGL Transitions component])
 ENABLE_OPENGL=
 
-if test "x$enable_opengl" != "xno" ; then
-   AC_MSG_RESULT([yes])
-   AC_CHECK_HEADER(GL/gl.h, [],
-                   [AC_MSG_ERROR([OpenGL headers not found])], [])
-   AC_CHECK_LIB(GL, main, [],
-     [AC_MSG_ERROR(libGL not installed or functional)], [])
-   AC_CHECK_LIB(GLU, main, [],
-     [AC_MSG_ERROR(libGLU not installed or functional)], [])
+if test "$_os" = "Darwin" ; then
+   # We use frameworks on Mac OS X, no need for detail checks
    ENABLE_OPENGL=TRUE
+   AC_MSG_RESULT([yes])
 else
-   AC_MSG_RESULT([no])
+   if test "x$enable_opengl" != "xno" ; then
+      AC_MSG_RESULT([yes])
+      AC_CHECK_HEADER(GL/gl.h, [],
+        [AC_MSG_ERROR([OpenGL headers not found])], [])
+      AC_CHECK_LIB(GL, main, [],
+        [AC_MSG_ERROR(libGL not installed or functional)], [])
+      AC_CHECK_LIB(GLU, main, [],
+        [AC_MSG_ERROR(libGLU not installed or functional)], [])
+      ENABLE_OPENGL=TRUE
+   else
+      AC_MSG_RESULT([no])
+   fi
 fi
-
 AC_SUBST(ENABLE_OPENGL)
 
 AC_MSG_CHECKING([whether to build the Presentation Minimizer extension])
diff --git scp2/source/impress/makefile.mk scp2/source/impress/makefile.mk
index a2036f5..9b7da6c 100644
--- scp2/source/impress/makefile.mk
+++ scp2/source/impress/makefile.mk
@@ -43,6 +43,10 @@ TARGETTYPE=CUI
 
 SCP_PRODUCT_TYPE=osl
 
+.IF "$(ENABLE_OPENGL)"=="TRUE"
+SCPDEFS+=-DENABLE_OPENGL
+.ENDIF
+
 PARFILES= \
         module_impress.par              \
         file_impress.par 
diff --git scp2/source/impress/module_impress.scp scp2/source/impress/module_impress.scp
index dce65fe..e0e2166 100644
--- scp2/source/impress/module_impress.scp
+++ scp2/source/impress/module_impress.scp
@@ -49,6 +49,9 @@ Module gid_Module_Prg_Impress_Bin
     gid_File_Registry_Spool_Oo_Common_Impress_Xcu,gid_File_Registry_Spool_Oo_Setup_Impress_Xcu,
     gid_File_Oo_Office_Ui_Impresswindowstate_Xcs,gid_File_Oo_Office_Ui_Impresswindowstate_Xcu,
 	gid_File_Lib_Animcore,gid_File_Share_Config_Sofficecfg_Impress_Effects_Xml, gid_File_Share_Config_Sofficecfg_Impress_Transitions_Xml,
+#if defined ENABLE_OPENGL
+    gid_File_Share_Config_Sofficecfg_Impress_Transitions_OGL_Xml,
+#endif
 	gid_File_Oo_Office_Ui_Effects_Xcs, gid_File_Oo_Office_Ui_Effects_Xcu, gid_File_Registry_Spool_Oo_Office_Embedding_Impress_Xcu,
     gid_File_Registry_Spool_Oo_TypeDetection_Impress_Filters_Xcu,gid_File_Registry_Spool_Oo_TypeDetection_Impress_Types_Xcu, gid_File_Tmp_Userinstall_Impress_Inf);
 End
diff --git scp2/source/impress/module_ogltrans.scp scp2/source/impress/module_ogltrans.scp
index 18425e8..1f452a1 100644
--- scp2/source/impress/module_ogltrans.scp
+++ scp2/source/impress/module_ogltrans.scp
@@ -45,7 +45,11 @@ File gid_File_Lib_OpenGLTransitions
     RegistryID = gid_Starregistry_Services_Rdb;
     Dir = SCP2_OOO_BIN_DIR;
   #ifdef UNX
-    Name = STRING(CONCAT2(OGLTrans.uno,UNXSUFFIX));
+    #ifdef QUARTZ
+	Name = STRING(CONCAT2(libOGLTrans.uno,UNXSUFFIX));
+    #else
+	Name = STRING(CONCAT2(OGLTrans.uno,UNXSUFFIX));
+    #endif
   #else
     Name = "OGLTrans.uno.dll";
   #endif
diff --git scp2/source/ooo/file_library_ooo.scp scp2/source/ooo/file_library_ooo.scp
index 2043c1b..de5d1d3 100644
--- scp2/source/ooo/file_library_ooo.scp
+++ scp2/source/ooo/file_library_ooo.scp
@@ -679,7 +679,6 @@ End
 #endif
 #endif
 
-#ifdef MACOSX
 #ifdef QUARTZ
 File gid_File_Lib_Fps_Aqua
     TXT_FILE_BODY;
@@ -706,7 +705,6 @@ File gid_File_Lib_avmediaQuickTime
 	Dir = SCP2_OOO_BIN_DIR;
 End
 #endif
-#endif
 
 #ifdef WNT
 SPECIAL_UNO_COMPONENT_LIB_FILE( gid_File_Lib_Fps_ODMA, fps_odma.uno )
diff --git scp2/source/ooo/makefile.mk scp2/source/ooo/makefile.mk
index f0bfa83..31aaf4b 100644
--- scp2/source/ooo/makefile.mk
+++ scp2/source/ooo/makefile.mk
@@ -45,6 +45,10 @@ TARGETTYPE=CUI
 SCPDEFS+=-D_MSC
 .ENDIF
 
+.IF "$(ENABLE_OPENGL)"=="TRUE"
+SCPDEFS+=-DENABLE_OPENGL
+.ENDIF
+
 .IF "$(ENABLE_CRASHDUMP)"!=""
 SCPDEFS+=-DENABLE_CRASHDUMP
 .ENDIF
diff --git slideshow/prj/build.lst slideshow/prj/build.lst
index 7b51243..8c3ea25 100644
--- slideshow/prj/build.lst
+++ slideshow/prj/build.lst
@@ -4,7 +4,9 @@ pe	slideshow\inc							nmake	-	all	pe_inc NULL
 pe	slideshow\source\engine					nmake	-	all	pe_engine pe_inc NULL
 pe	slideshow\source\engine\slide			nmake	-	all	pe_slide pe_inc NULL
 pe	slideshow\source\engine\shapes			nmake	-	all	pe_shapes pe_inc NULL
-pe  slideshow\source\engine\OGLTrans        nmake   -   u pe_ogltrans pe_inc NULL
+pe	slideshow\source\engine\OGLTrans\unx        nmake   -   u pe_ogltrans_unx pe_inc NULL
+pe	slideshow\source\engine\OGLTrans\win        nmake   -   w pe_ogltrans_win pe_inc NULL
+pe	slideshow\source\engine\OGLTrans\mac        nmake   -   u pe_ogltrans_mac pe_inc NULL
 pe	slideshow\source\engine\transitions		nmake	-	all	pe_transitions pe_inc NULL
 pe	slideshow\source\engine\animationnodes	nmake	-	all	pe_animationnodes pe_inc NULL
 pe	slideshow\source\engine\activities		nmake	-	all	pe_activities pe_inc NULL
diff --git slideshow/source/engine/OGLTrans/OGLTrans_Shaders.cxx slideshow/source/engine/OGLTrans/OGLTrans_Shaders.cxx
deleted file mode 100644
index a144790..0000000
--- slideshow/source/engine/OGLTrans/OGLTrans_Shaders.cxx
+++ /dev/null
@@ -1,143 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: $
- * $Revision: $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include <osl/diagnose.hxx>
-
-#include "OGLTrans_Shaders.hxx"
-
-namespace unx
-{
-#include <GL/glx.h>
-#include <GL/glxext.h>
-}
-
-bool OGLShaders::cbInitialized = false;
-
-#ifdef GL_VERSION_2_0
-
-PFNGLCREATESHADERPROC OGLShaders::glCreateShader = NULL;
-PFNGLSHADERSOURCEPROC OGLShaders::glShaderSource = NULL;
-PFNGLCOMPILESHADERPROC OGLShaders::glCompileShader = NULL;
-PFNGLGETSHADERIVPROC OGLShaders::glGetShaderiv = NULL;
-PFNGLGETSHADERINFOLOGPROC OGLShaders::glGetShaderInfoLog = NULL;
-PFNGLDELETESHADERPROC OGLShaders::glDeleteShader = NULL;
-PFNGLCREATEPROGRAMPROC OGLShaders::glCreateProgram = NULL;
-PFNGLATTACHSHADERPROC OGLShaders::glAttachShader = NULL;
-PFNGLLINKPROGRAMPROC OGLShaders::glLinkProgram = NULL;
-PFNGLGETPROGRAMIVPROC OGLShaders::glGetProgramiv = NULL;
-PFNGLGETPROGRAMINFOLOGPROC OGLShaders::glGetProgramInfoLog = NULL;
-PFNGLUSEPROGRAMPROC OGLShaders::glUseProgram = NULL;
-PFNGLDELETEPROGRAMPROC OGLShaders::glDeleteProgram = NULL;
-PFNGLGETUNIFORMLOCATIONPROC OGLShaders::glGetUniformLocation = NULL;
-PFNGLUNIFORM1IPROC OGLShaders::glUniform1i = NULL;
-PFNGLUNIFORM1FPROC OGLShaders::glUniform1f = NULL;
-#endif
-
-bool OGLShaders::Initialize()
-{
-#ifdef GL_VERSION_2_0
-    if( !cbInitialized ) {
-        glCreateShader = (PFNGLCREATESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glCreateShader" );
-        glShaderSource = (PFNGLSHADERSOURCEPROC) unx::glXGetProcAddress( (unsigned char *) "glShaderSource" );
-        glCompileShader = (PFNGLCOMPILESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glCompileShader" );
-        glGetShaderiv = (PFNGLGETSHADERIVPROC) unx::glXGetProcAddress( (unsigned char *) "glGetShaderiv" );
-        glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) unx::glXGetProcAddress( (unsigned char *) "glGetShaderInfoLog" );
-        glDeleteShader = (PFNGLDELETESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glDeleteShader" );
-        glCreateProgram = (PFNGLCREATEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glCreateProgram" );
-        glAttachShader = (PFNGLATTACHSHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glAttachShader" );
-        glLinkProgram = (PFNGLLINKPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glLinkProgram" );
-        glGetProgramiv = (PFNGLGETPROGRAMIVPROC) unx::glXGetProcAddress( (unsigned char *) "glGetProgramiv" );
-        glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) unx::glXGetProcAddress( (unsigned char *) "glGetProgramInfoLog" );
-        glUseProgram = (PFNGLUSEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glUseProgram" );
-        glDeleteProgram = (PFNGLDELETEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glDeleteProgram" );
-        glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) unx::glXGetProcAddress( (unsigned char *) "glGetUniformLocation" );
-        glUniform1i = (PFNGLUNIFORM1IPROC) unx::glXGetProcAddress( (unsigned char *) "glUniform1i" );
-        glUniform1f = (PFNGLUNIFORM1FPROC) unx::glXGetProcAddress( (unsigned char *) "glUniform1f" );
-        cbInitialized = true;
-    }
-
-    return glCreateShader != NULL;
-#else
-    return false;
-#endif
-}
-
-GLuint OGLShaders::LinkProgram( const char *vertexShader, const char *fragmentShader )
-{
-#ifdef GL_VERSION_2_0
-    if( !Initialize() )
-        return 0;
-
-    GLhandleARB vertexObject, fragmentObject, programObject;
-    GLint vertexCompiled, fragmentCompiled, programLinked;
-    char log[1024];
-
-    vertexObject = glCreateShader( GL_VERTEX_SHADER );
-    fragmentObject = glCreateShader( GL_FRAGMENT_SHADER );
-    OSL_TRACE("checkpoint 1: shaders created (%d) vertex: %d fragment: %d", glGetError() == GL_NO_ERROR, vertexObject, fragmentObject );
-
-
-    glShaderSource( vertexObject, 1, &vertexShader, NULL );
-    glShaderSource( fragmentObject, 1, &fragmentShader, NULL );
-
-    glCompileShader( vertexObject );
-    glGetShaderInfoLog( vertexObject, sizeof( log ), NULL, log );
-    OSL_TRACE("vertex compile log: %s", log);
-    glGetShaderiv( vertexObject, GL_COMPILE_STATUS, &vertexCompiled );
-    glCompileShader( fragmentObject );
-    glGetShaderInfoLog( fragmentObject, sizeof( log ), NULL, log );
-    OSL_TRACE("fragment compile log: %s", log);
-    glGetShaderiv( fragmentObject, GL_COMPILE_STATUS, &fragmentCompiled );
-
-    if( !vertexCompiled || !fragmentCompiled )
-        return 0;
-
-    OSL_TRACE("checkpoint 2: shaders compiled (%d)", glGetError() == GL_NO_ERROR);
-
-    programObject = glCreateProgram();
-    glAttachShader( programObject, vertexObject );
-    glAttachShader( programObject, fragmentObject );
-
-    glLinkProgram( programObject );
-    glGetProgramInfoLog( programObject, sizeof( log ), NULL, log );
-    OSL_TRACE("program link log: %s", log);
-    glGetProgramiv( programObject, GL_LINK_STATUS, &programLinked );
-
-    if( !programLinked )
-        return 0;
-
-    OSL_TRACE("checkpoint 3: program linked (%d)", glGetError() == GL_NO_ERROR);
-
-    return programObject;
-#else
-    return 0;
-#endif
-}
-
diff --git slideshow/source/engine/OGLTrans/OGLTrans_Shaders.hxx slideshow/source/engine/OGLTrans/OGLTrans_Shaders.hxx
deleted file mode 100644
index 049c71f..0000000
--- slideshow/source/engine/OGLTrans/OGLTrans_Shaders.hxx
+++ /dev/null
@@ -1,71 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: $
- * $Revision: $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef INCLUDED_OGLTRANS_SHADERS_HXX_
-#define INCLUDED_OGLTRANS_SHADERS_HXX_
-
-#define GL_GLEXT_PROTOTYPES 1
-#include <GL/gl.h>
-#include <GL/glext.h>
-
-class OGLShaders {
-    static bool Initialize();
-    static bool cbInitialized;
-
-public:    
-
-    static GLuint LinkProgram( const char *vertexShader, const char *fragmentShader );
-
-    /** GL shader functions
-     */
-#ifdef GL_VERSION_2_0
-
-    static PFNGLCREATESHADERPROC glCreateShader;
-    static PFNGLSHADERSOURCEPROC glShaderSource;
-    static PFNGLCOMPILESHADERPROC glCompileShader;
-    static PFNGLGETSHADERIVPROC glGetShaderiv;
-    static PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog;
-    static PFNGLDELETESHADERPROC glDeleteShader;
-
-    static PFNGLCREATEPROGRAMPROC glCreateProgram;
-    static PFNGLATTACHSHADERPROC glAttachShader;
-    static PFNGLLINKPROGRAMPROC glLinkProgram;
-    static PFNGLGETPROGRAMIVPROC glGetProgramiv;
-    static PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog;
-    static PFNGLUSEPROGRAMPROC glUseProgram;
-    static PFNGLDELETEPROGRAMPROC glDeleteProgram;
-
-    static PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;
-    static PFNGLUNIFORM1IPROC glUniform1i;
-    static PFNGLUNIFORM1FPROC glUniform1f;
-#endif
-};
-
-#endif
diff --git slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
deleted file mode 100644
index de63a1b..0000000
--- slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
+++ /dev/null
@@ -1,1318 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: OGLTrans_TransitionImpl.cxx,v $
- * $Revision: 1.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "OGLTrans_TransitionImpl.hxx"
-#include "OGLTrans_Shaders.hxx"
-#include <GL/gl.h>
-#include <math.h>
-
-
-void OGLTransitionImpl::clear()
-{
-    for(unsigned int i( 0 ); i < OverallOperations.size(); ++i)
-        delete OverallOperations[i];
-    OverallOperations.clear();
-    maLeavingSlidePrimitives.clear();
-    maEnteringSlidePrimitives.clear();
-    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
-        delete maSceneObjects[i];
-    maSceneObjects.clear();
-
-    mbReflectSlides = false;
-
-#ifdef GL_VERSION_2_0
-    if( mProgramObject ) {
-        OGLShaders::glDeleteProgram( mProgramObject );
-        mProgramObject = 0;
-    }
-
-    if( mVertexObject ) {
-        OGLShaders::glDeleteShader( mVertexObject );
-        mVertexObject = 0;
-    }
-
-    if( mFragmentObject ) {
-        OGLShaders::glDeleteShader( mFragmentObject );
-        mFragmentObject = 0;
-    }
-#endif
-
-    if( maHelperTexture ) {
-        glDeleteTextures( 1, &maHelperTexture );
-        maHelperTexture = 0;
-    }
-
-    if( mmClearTransition )
-        (this->*mmClearTransition)();
-}
-
-OGLTransitionImpl::~OGLTransitionImpl()
-{
-    clear();
-}
-
-void OGLTransitionImpl::prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex )
-{
-    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
-        maSceneObjects[i]->prepare();
-    }
-
-    if( mmPrepareTransition )
-        (this->*mmPrepareTransition)( glLeavingSlideTex, glEnteringSlideTex );
-}
-
-void OGLTransitionImpl::finish()
-{
-    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
-        maSceneObjects[i]->finish();
-    }
-}
-
-static void blendSlide( double depth )
-{
-    double showHeight = -1 + depth*2;
-    GLfloat reflectionColor[] = {0, 0, 0, 0.25};
-
-    glDisable( GL_DEPTH_TEST );
-    glBegin( GL_QUADS );
-    glColor4fv( reflectionColor );
-    glVertex3f( -1, -1, 0 );
-    glColor4f( 0, 0, 0, 1 );
-    glVertex3f(-1,  showHeight, 0 );
-    glVertex3f( 1,  showHeight, 0 );
-    glColor4fv( reflectionColor );
-    glVertex3f( 1, -1, 0 );
-    glEnd();
-
-    glBegin( GL_QUADS );
-    glColor4f( 0, 0, 0, 1 );
-    glVertex3f( -1, showHeight, 0 );
-    glVertex3f( -1,  1, 0 );
-    glVertex3f(  1,  1, 0 );
-    glVertex3f(  1, showHeight, 0 );
-    glEnd();
-    glEnable( GL_DEPTH_TEST );
-}
-
-static void slideShadow( double nTime, Primitive& primitive, double sw, double sh )
-{
-    double reflectionDepth = 0.3;
-
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    glDisable(GL_LIGHTING);
-
-    glPushMatrix();
-    primitive.applyOperations( nTime, sw, sh );
-    blendSlide( reflectionDepth );
-    glPopMatrix();
-
-    glDisable(GL_BLEND);
-    glEnable(GL_LIGHTING);
-}
-
-void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
-                                 double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
-{
-    double SlideWidthScale, SlideHeightScale;
-
-    SlideWidthScale = SlideWidth/DispWidth;
-    SlideHeightScale = SlideHeight/DispHeight;
-
-    if( mmPrepare ) {
-        clear();
-        (this->*mmPrepare)( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
-    }
-
-    glPushMatrix();
-    displaySlides( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
-    displayScene( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
-    glPopMatrix();
-}
-
-void OGLTransitionImpl::applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale )
-{
-    for(unsigned int i(0); i < OverallOperations.size(); ++i)
-        OverallOperations[i]->interpolate(nTime,SlideWidthScale,SlideHeightScale);
-}
-
-void OGLTransitionImpl::displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives,
-                                      double SlideWidthScale, double SlideHeightScale )
-{
-   //TODO change to foreach
-    glBindTexture(GL_TEXTURE_2D, glSlideTex);
-
-    // display slide reflection
-    // note that depth test is turned off while blending the shadow
-    // so the slides has to be rendered in right order, see rochade as example
-    if( mbReflectSlides ) {
-        double surfaceLevel = -0.04;
-
-        /* reflected slides */
-        glPushMatrix();
-
-        glScaled( 1, -1, 1 );
-        glTranslated( 0, 2 - surfaceLevel, 0 );
-
-        glCullFace(GL_FRONT);
-    for(unsigned int i(0); i < primitives.size(); ++i)
-        primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
-        glCullFace(GL_BACK);
-
-    slideShadow( nTime, primitives[0], SlideWidthScale, SlideHeightScale );
-
-        glPopMatrix();
-    }
-
-    for(unsigned int i(0); i < primitives.size(); ++i)
-        primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
-}
-
-void OGLTransitionImpl::displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
-                                       double SlideWidthScale, double SlideHeightScale )
-{
-    if( mmDisplaySlides )
-        (this->*mmDisplaySlides)( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
-    else {
-        applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
-
-        glEnable(GL_TEXTURE_2D);
-        displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
-        displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    }
-}
-
-void OGLTransitionImpl::displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
-{
-    glEnable(GL_TEXTURE_2D);
-    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
-        maSceneObjects[i]->display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
-}
-
-void Primitive::display(double nTime, double WidthScale, double HeightScale)
-{
-    glPushMatrix();
-
-    applyOperations( nTime, WidthScale, HeightScale );
-
-    glEnableClientState( GL_VERTEX_ARRAY );
-    if(!Normals.empty())
-    {
-        glNormalPointer( GL_DOUBLE , 0 , &Normals[0] );
-        glEnableClientState( GL_NORMAL_ARRAY );
-    }
-    glEnableClientState( GL_TEXTURE_COORD_ARRAY );
-    glTexCoordPointer( 2, GL_DOUBLE, 0, &TexCoords[0] );
-    glVertexPointer( 3, GL_DOUBLE, 0, &Vertices[0] );
-    glDrawArrays( GL_TRIANGLES, 0, Vertices.size() );
-    glPopMatrix();
-}
-
-void Primitive::applyOperations(double nTime, double WidthScale, double HeightScale)
-{
-    for(unsigned int i(0); i < Operations.size(); ++i)
-        Operations[i]->interpolate( nTime ,WidthScale,HeightScale);
-    glScaled(WidthScale,HeightScale,1);
-}
-
-Primitive::~Primitive()
-{
-    for(unsigned int i( 0 ); i < Operations.size(); ++i)
-        delete Operations[i];
-}
-
-
-void SceneObject::display(double nTime, double /* SlideWidth */, double /* SlideHeight */, double DispWidth, double DispHeight )
-{
-    for(unsigned int i(0); i < maPrimitives.size(); ++i) {
-        // fixme: allow various model spaces, now we make it so that
-        // it is regular -1,-1 to 1,1, where the whole display fits in
-        glPushMatrix();
-        if (DispHeight > DispWidth)
-            glScaled(DispHeight/DispWidth, 1, 1);
-        else
-            glScaled(1, DispWidth/DispHeight, 1);
-        maPrimitives[i].display(nTime, 1, 1);
-        glPopMatrix();
-    }
-}
-
-void SceneObject::pushPrimitive(const Primitive &p)
-{
-    maPrimitives.push_back(p);
-}
-
-SceneObject::SceneObject()
-    : maPrimitives()
-{
-}
-
-Iris::Iris()
-    : SceneObject ()
-{
-}
-
-void Iris::display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
-{
-    glBindTexture(GL_TEXTURE_2D, maTexture);
-    SceneObject::display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
-}
-
-void Iris::prepare()
-{
-    static GLubyte img[3] = { 80, 80, 80 };
-    
-    glGenTextures(1, &maTexture);
-    glBindTexture(GL_TEXTURE_2D, maTexture);
-    glTexImage2D(GL_TEXTURE_2D, 0, 3, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, img);
-    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
-    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
-    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
-}
-
-void Iris::finish()
-{
-    glDeleteTextures(1, &maTexture);
-}
-
-void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
-{
-    clear();
-    Primitive Slide;
-    
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,false,0.0,1.0));
-
-    maEnteringSlidePrimitives.push_back(Slide);
-
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,true,0.0,1.0));
-}
-
-void OGLTransitionImpl::makeInsideCubeFaceToLeft()
-{
-    clear();
-    Primitive Slide;
-    
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,false,0.0,1.0));
-
-    maEnteringSlidePrimitives.push_back(Slide);
-    
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,true,0.0,1.0));
-}
-
-void OGLTransitionImpl::makeFallLeaving()
-{
-    clear();
-    Primitive Slide;
-    
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-    maEnteringSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(1,0,0),basegfx::B3DVector(0,-1,0), 90,true,0.0,1.0));
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    mbUseMipMapEntering = false;
-}
-
-void OGLTransitionImpl::makeTurnAround()
-{
-    clear();
-    Primitive Slide;
-
-    mbReflectSlides = true;
-    
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0),-180,false,0.0,1.0));
-    maEnteringSlidePrimitives.push_back(Slide);
-
-    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, -1.5),true, 0, 0.5));
-    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1.5), true, 0.5, 1));
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0),basegfx::B3DVector(0, 0, 0), -180, true, 0.0, 1.0));
-}
-
-void OGLTransitionImpl::makeTurnDown()
-{
-    clear();
-    Primitive Slide;
-    
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 0.0001), false, -1.0, 0.0));
-    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), -90, true, 0.0, 1.0));
-    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), 90, false, -1.0, 0.0));
-    maEnteringSlidePrimitives.push_back(Slide);
-
-    mbUseMipMapLeaving = false;
-}
-
-void OGLTransitionImpl::makeIris()
-{
-    clear();
-    Primitive Slide;
-    
-    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
-    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
-    maEnteringSlidePrimitives.push_back (Slide);
-
-    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0,  0.000001), false, -1, 0));
-    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, -0.000002), false, 0.5, 1));
-    maLeavingSlidePrimitives.push_back (Slide);
-
-
-    Primitive irisPart, part;
-    int i, nSteps = 24, nParts = 7;
-    double lt = 0, t = 1.0/nSteps, cx, cy, lcx, lcy, lx = 1, ly = 0, x, y, cxo, cyo, lcxo, lcyo, of=2.2, f=1.42;
-
-    for (i=1; i<=nSteps; i++) {
-        x = cos ((3*2*M_PI*t)/nParts);
-        y = -sin ((3*2*M_PI*t)/nParts);
-        cx = (f*x + 1)/2;
-        cy = (f*y + 1)/2;
-        lcx = (f*lx + 1)/2;
-        lcy = (f*ly + 1)/2;
-        cxo = (of*x + 1)/2;
-        cyo = (of*y + 1)/2;
-        lcxo = (of*lx + 1)/2;
-        lcyo = (of*ly + 1)/2;
-        irisPart.pushTriangle (basegfx::B2DVector (lcx, lcy),
-                               basegfx::B2DVector (lcxo, lcyo),
-                               basegfx::B2DVector (cx, cy));
-        irisPart.pushTriangle (basegfx::B2DVector (cx, cy),
-                               basegfx::B2DVector (lcxo, lcyo),
-                               basegfx::B2DVector (cxo, cyo));
-        lx = x;
-        ly = y;
-        lt = t;
-        t += 1.0/nSteps;
-    }
-
-    Iris* pIris = new Iris();
-    double angle = 87;
-
-    for (i = 0; i < nParts; i++) {
-        irisPart.Operations.clear ();
-        double rx, ry;
-
-        rx = cos ((2*M_PI*i)/nParts);
-        ry = sin ((2*M_PI*i)/nParts);
-        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0),  angle, true, 0.0, 0.5));
-        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0), -angle, true, 0.5, 1));
-        if (i > 0) {
-            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(rx, ry, 0),  false, -1, 0));
-            irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(0, 0, 0), i*360.0/nParts, false, -1, 0));
-            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(-1, 0, 0),  false, -1, 0));
-        }
-        irisPart.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1), false, -2, 0.0));
-        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(1, .5, 0), basegfx::B3DVector(1, 0, 0), -30, false, -1, 0));
-        pIris->pushPrimitive (irisPart);
-    }
-
-    maSceneObjects.push_back (pIris);
-
-    mbUseMipMapLeaving = mbUseMipMapEntering = false;
-}
-
-void OGLTransitionImpl::displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
-                          double SlideWidthScale, double SlideHeightScale )
-{
-    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
-
-    glEnable(GL_TEXTURE_2D);
-
-    if( nTime > .5) {
-    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    } else {
-    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    }
-}
-
-void OGLTransitionImpl::makeRochade()
-{
-    clear();
-    Primitive Slide;
-    
-    mbReflectSlides = true;
-    mmDisplaySlides = &OGLTransitionImpl::displaySlidesRochade;
-
-    double w, h;
-
-    w = 2.2;
-    h = 10;
-
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-
-    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.25, -0.25, true, 0, 1));
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.clear();
-    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.75, 0.25, true, 0, 1));
-    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, -h), false, -1, 0));
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), 45, false, -1, 0));
-    maEnteringSlidePrimitives.push_back(Slide);
-
-    //     OverallOperations.push_back(new SEllipseTranslate(0.5, 2, 0, 1, true, 0, 1));
-//      push_back(new STranslate(basegfx::B3DVector(0, 0, -2), true, 0, 0.5));
-//      OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 2), true, 0.5, 1));
-}
-
-// TODO(Q3): extract to basegfx
-inline basegfx::B2DVector clamp(const basegfx::B2DVector& v)
-{
-    return basegfx::B2DVector(min(max(v.getX(),-1.0),1.0),
-                              min(max(v.getY(),-1.0),1.0));
-}
-
-// TODO(Q3): extract to basegfx
-inline basegfx::B3DVector clamp(const basegfx::B3DVector& v)
-{
-    return basegfx::B3DVector(min(max(v.getX(),-1.0),1.0),
-                              min(max(v.getY(),-1.0),1.0),
-                              min(max(v.getZ(),-1.0),1.0));
-}
-
-inline double randFromNeg1to1()
-{
-    return ( ( static_cast<double>( rand() ) / static_cast<double>( RAND_MAX ) ) * 2.0 ) - 1.0;
-}
-
-// TODO(Q3): extract to basegfx
-inline basegfx::B3DVector randNormVectorInXYPlane()
-{
-    basegfx::B3DVector toReturn(randFromNeg1to1(),randFromNeg1to1(),0.0);
-    return toReturn/toReturn.getLength();
-}
-
-void OGLTransitionImpl::makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles )
-{
-    clear();
-    double dAngle(2*3.1415926/static_cast<double>( nPointsOnCircles ));
-    if(nCircles < 2 || nPointsOnCircles < 4)
-    {
-        makeNByMTileFlip(1,1);
-        return;
-    }
-    double Radius(1.0/static_cast<double>( nCircles ));
-    double dRadius(Radius);
-    double LastRadius(0.0);
-    double NextRadius(2*Radius);
-
-    /// now we know there is at least two circles
-    /// the first will always be a full circle
-    /// the last will always be the outer shell of the slide with a circle hole
-
-    //add the full circle
-    vector<basegfx::B2DVector> unScaledTexCoords;
-    double TempAngle(0.0);
-    for(unsigned int Point(0); Point < nPointsOnCircles; ++Point)
-    {
-        unScaledTexCoords.push_back( basegfx::B2DVector( cos(TempAngle - 3.1415926/2.0) , sin(TempAngle- 3.1415926/2.0) ) );
-
-        TempAngle += dAngle;
-    }
-    
-    {
-        //double angle(0.0);
-        Primitive EnteringSlide;
-        Primitive LeavingSlide;
-        for(int Point(0); Point + 1 < nPointsOnCircles; ++Point)
-        {
-            EnteringSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
-            LeavingSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5, 0.5) );
-        }
-        EnteringSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius * unScaledTexCoords[ 0 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ nPointsOnCircles - 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
-        LeavingSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-    
-        basegfx::B3DVector axis(randNormVectorInXYPlane());
-        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
-        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
-        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
-    
-        maEnteringSlidePrimitives.push_back(EnteringSlide);
-        maLeavingSlidePrimitives.push_back(LeavingSlide);
-        LastRadius = Radius;
-        Radius = NextRadius;
-        NextRadius += dRadius;
-    }    
-    
-    for(int i(1); i < nCircles - 1; ++i)
-    {
-        Primitive LeavingSlide;
-        Primitive EnteringSlide;
-        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
-        {            
-            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-            
-            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        }
-        
-        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        
-        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        
-        basegfx::B3DVector axis(randNormVectorInXYPlane());
-        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
-        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
-        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
-        
-        maEnteringSlidePrimitives.push_back(EnteringSlide);
-        maLeavingSlidePrimitives.push_back(LeavingSlide);
-        
-        LastRadius = Radius;
-        Radius = NextRadius;
-        NextRadius += dRadius;
-    }
-    {
-        Radius = sqrt(2.0);
-        Primitive LeavingSlide;
-        Primitive EnteringSlide;
-        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
-        {
-            
-            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
-            
-            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
-            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
-        }
-        
-        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
-        
-        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
-        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
-        
-        basegfx::B3DVector axis(randNormVectorInXYPlane());
-        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
-        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
-        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
-        
-        maEnteringSlidePrimitives.push_back(EnteringSlide);
-        maLeavingSlidePrimitives.push_back(LeavingSlide);
-    }
-}
-
-void OGLTransitionImpl::makeHelix( ::sal_uInt16 nRows )
-{
-    clear();
-    double invN(1.0/static_cast<double>(nRows));
-    double iDn = 0.0;
-    double iPDn = invN;
-    for(unsigned int i(0); i < nRows; ++i)
-    {
-        Primitive Tile;
-        
-        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
-            
-        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iPDn ) , basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
-        
-        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , 
-                                                true,min(max(static_cast<double>(i - nRows/2.0)*invN/2.0,0.0),1.0),
-                                                min(max(static_cast<double>(i + nRows/2.0)*invN/2.0,0.0),1.0) ) );
-        
-        maLeavingSlidePrimitives.push_back(Tile);
-        
-        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180 , false,0.0,1.0) );
-        
-        maEnteringSlidePrimitives.push_back(Tile);
-            
-        iDn += invN;
-        iPDn += invN;
-    }
-}
-
-void OGLTransitionImpl::makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m )
-{
-    clear();
-    double invN(1.0/static_cast<double>(n));
-    double invM(1.0/static_cast<double>(m));
-    double iDn = 0.0;
-    double iPDn = invN;
-    for(unsigned int i(0); i < n; ++i)
-    {
-        double jDm = 0.0;
-        double jPDm = invM;
-        for(unsigned int j(0); j < m; ++j)
-        {
-            Primitive Tile;
-
-            Tile.pushTriangle(basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));
-
-            Tile.pushTriangle(basegfx::B2DVector( iPDn , jPDm ) , basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));//bottom left corner of tile            
-
-            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , true, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
-            maLeavingSlidePrimitives.push_back(Tile);
-            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180, false, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
-
-            maEnteringSlidePrimitives.push_back(Tile);
-
-            jDm += invM;
-            jPDm += invM;
-        }
-        iDn += invN;
-        iPDn += invN;
-    }
-}
-
-SRotate::SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
-{
-    nT0 = T0;
-    nT1 = T1;
-    bInterpolate = bInter;
-}
-
-SScale::SScale(const basegfx::B3DVector& Scale,const basegfx::B3DVector& Origin, bool bInter, double T0, double T1):scale(Scale),origin(Origin)
-{
-    nT0 = T0;
-    nT1 = T1;
-    bInterpolate = bInter;
-}
-
-RotateAndScaleDepthByWidth::RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
-{
-    nT0 = T0;
-    nT1 = T1;
-    bInterpolate = bInter;
-}
-
-RotateAndScaleDepthByHeight::RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
-{
-    nT0 = T0;
-    nT1 = T1;
-    bInterpolate = bInter;
-}
-
-
-STranslate::STranslate(const basegfx::B3DVector& Vector, bool bInter, double T0, double T1):vector(Vector)
-{
-    nT0 = T0;
-    nT1 = T1;
-    bInterpolate = bInter;
-}
-
-inline double intervalInter(double t, double T0, double T1)
-{
-    return ( t - T0 ) / ( T1 - T0 );
-}
-
-void STranslate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
-{
-    if(t <= nT0)
-        return;
-    if(!bInterpolate || t > nT1)
-        t = nT1;
-    t = intervalInter(t,nT0,nT1);
-    glTranslated(SlideWidthScale*t*vector.getX(),SlideHeightScale*t*vector.getY(),t*vector.getZ());
-}
-
-void SRotate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
-{
-    if(t <= nT0)
-        return;
-    if(!bInterpolate || t > nT1)
-        t = nT1;
-    t = intervalInter(t,nT0,nT1);
-    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
-    glScaled(SlideWidthScale,SlideHeightScale,1);
-    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
-    glScaled(1/SlideWidthScale,1/SlideHeightScale,1);
-    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
-}
-
-void SScale::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
-{
-    if(t <= nT0)
-        return;
-    if(!bInterpolate || t > nT1)
-        t = nT1;
-    t = intervalInter(t,nT0,nT1);
-    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
-    glScaled((1-t) + t*scale.getX(),(1-t) + t*scale.getY(),(1-t) + t*scale.getZ());
-    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
-}
-
-void RotateAndScaleDepthByWidth::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
-{
-    if(t <= nT0)
-        return;
-    if(!bInterpolate || t > nT1)
-        t = nT1;
-    t = intervalInter(t,nT0,nT1);
-    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideWidthScale*origin.getZ());
-    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
-    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
-}
-
-void RotateAndScaleDepthByHeight::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
-{
-    if(t <= nT0)
-        return;
-    if(!bInterpolate || t > nT1)
-        t = nT1;
-    t = intervalInter(t,nT0,nT1);
-    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideHeightScale*origin.getZ());
-    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
-    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideHeightScale*origin.getZ());
-}
-
-SEllipseTranslate::SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1)
-{
-    nT0 = T0;
-    nT1 = T1;
-    bInterpolate = bInter;
-    width = dWidth;
-    height = dHeight;
-    startPosition = dStartPosition;
-    endPosition = dEndPosition;
-}
-
-void SEllipseTranslate::interpolate(double t,double /* SlideWidthScale */,double /* SlideHeightScale */)
-{
-    if(t <= nT0)
-        return;
-    if(!bInterpolate || t > nT1)
-        t = nT1;
-    t = intervalInter(t,nT0,nT1);
-
-    double a1, a2, x, y;
-    a1 = startPosition*2*M_PI;
-    a2 = (startPosition + t*(endPosition - startPosition))*2*M_PI;
-    x = width*(cos (a2) - cos (a1))/2;
-    y = height*(sin (a2) - sin (a1))/2;
-
-    glTranslated(x, 0, y);
-}
-
-STranslate* STranslate::clone()
-{
-    return new STranslate(*this);
-}
-SRotate* SRotate::clone()
-{
-    return new SRotate(*this);
-}
-
-SScale* SScale::clone()
-{
-    return new SScale(*this);
-}
-
-SEllipseTranslate* SEllipseTranslate::clone()
-{
-    return new SEllipseTranslate(*this);
-}
-
-RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
-{
-    return new RotateAndScaleDepthByWidth(*this);
-}
-
-RotateAndScaleDepthByHeight* RotateAndScaleDepthByHeight::clone()
-{
-    return new RotateAndScaleDepthByHeight(*this);
-}
-
-const Primitive& Primitive::operator=(const Primitive& rvalue)
-{
-    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
-        Operations.push_back(rvalue.Operations[i]->clone());
-    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
-        Vertices.push_back(rvalue.Vertices[i]);
-    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
-        TexCoords.push_back(rvalue.TexCoords[i]);
-    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
-        Normals.push_back(rvalue.Normals[i]);    
-    return *this;   
-}
-    
-Primitive::Primitive(const Primitive& rvalue)
-{
-    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
-        Operations.push_back(rvalue.Operations[i]->clone());
-    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
-        Vertices.push_back(rvalue.Vertices[i]);
-    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
-        TexCoords.push_back(rvalue.TexCoords[i]);
-    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
-        Normals.push_back(rvalue.Normals[i]);
-}
-
-void Primitive::pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2)
-{
-    vector<basegfx::B3DVector> Verts;
-    vector<basegfx::B2DVector> Texs;
-    Verts.reserve(3);
-    Texs.reserve(3);
-
-    Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
-    Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
-    Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
-
-    //figure out if they're facing the correct way, and make them face the correct way.
-    basegfx::B3DVector Normal( basegfx::cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
-    if(Normal.getZ() >= 0.0)//if the normal is facing us
-    {
-        Texs.push_back(SlideLocation0);
-        Texs.push_back(SlideLocation1);
-        Texs.push_back(SlideLocation2);
-    }
-    else // if the normal is facing away from us, make it face us
-    {
-        Texs.push_back(SlideLocation0);
-        Texs.push_back(SlideLocation2);
-        Texs.push_back(SlideLocation1);
-        Verts.clear();
-        Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
-        Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
-        Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
-    }
-
-    Vertices.push_back(Verts[0]);
-    Vertices.push_back(Verts[1]);
-    Vertices.push_back(Verts[2]);
-
-    TexCoords.push_back(Texs[0]);
-    TexCoords.push_back(Texs[1]);
-    TexCoords.push_back(Texs[2]);
-    
-    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
-    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
-    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
-}
-
-void OGLTransitionImpl::makeDiamond()
-{
-    mmPrepare = &OGLTransitionImpl::prepareDiamond;
-    mbUseMipMapLeaving = mbUseMipMapEntering = false;
-}
-
-void OGLTransitionImpl::prepareDiamond( double nTime, double /* SlideWidth */, double /* SlideHeight */, double /* DispWidth */, double /* DispHeight */ )
-{
-    Primitive Slide1, Slide2;
-
-    Slide1.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
-    Slide1.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
-    maEnteringSlidePrimitives.push_back (Slide1);
-
-    
-    if( nTime >= 0.5 ) {
-        double m = 1 - nTime;
-
-        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (m,0), basegfx::B2DVector (0,m));
-        Slide2.pushTriangle (basegfx::B2DVector (nTime,0), basegfx::B2DVector (1,0), basegfx::B2DVector (1,m));
-        Slide2.pushTriangle (basegfx::B2DVector (1,nTime), basegfx::B2DVector (1,1), basegfx::B2DVector (nTime,1));
-        Slide2.pushTriangle (basegfx::B2DVector (0,nTime), basegfx::B2DVector (m,1), basegfx::B2DVector (0,1));
-    } else {
-        double l = 0.5 - nTime;
-        double h = 0.5 + nTime;
-
-        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0.5,l));
-        Slide2.pushTriangle (basegfx::B2DVector (0.5,l), basegfx::B2DVector (1,0), basegfx::B2DVector (h,0.5));
-        Slide2.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (1,1), basegfx::B2DVector (h,0.5));
-        Slide2.pushTriangle (basegfx::B2DVector (h,0.5), basegfx::B2DVector (1,1), basegfx::B2DVector (0.5,h));
-        Slide2.pushTriangle (basegfx::B2DVector (0.5,h), basegfx::B2DVector (1,1), basegfx::B2DVector (0,1));
-        Slide2.pushTriangle (basegfx::B2DVector (l,0.5), basegfx::B2DVector (0.5,h), basegfx::B2DVector (0,1));
-        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (l,0.5), basegfx::B2DVector (0,1));
-        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (0.5,l), basegfx::B2DVector (l,0.5));
-    }
-    Slide2.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, 0.00000001), false, -1, 0));
-    maLeavingSlidePrimitives.push_back (Slide2);
-}
-
-void OGLTransitionImpl::makeVenetianBlinds( bool vertical, int parts )
-{
-    static double t30 = tan( M_PI/6.0 );
-    double n, ln = 0;
-    double p = 1.0/parts;
-
-    for( int i=0; i<parts; i++ ) {
-        Primitive Slide;
-        n = (i + 1)/(double)parts;
-        if( vertical ) {
-            Slide.pushTriangle (basegfx::B2DVector (ln,0), basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1));
-            Slide.pushTriangle (basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1), basegfx::B2DVector (n,1));
-            Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, -t30*p), -120, true, 0.0, 1.0));
-        } else {
-            Slide.pushTriangle (basegfx::B2DVector (0,ln), basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n));
-            Slide.pushTriangle (basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n), basegfx::B2DVector (1,n));
-            Slide.Operations.push_back(new RotateAndScaleDepthByHeight(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, -t30*p), -120, true, 0.0, 1.0));
-        }
-        maLeavingSlidePrimitives.push_back (Slide);
-
-        if( vertical ) {
-            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(2*n - 1, 0, 0), -60, false, -1, 0));
-            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, 0), 180, false, -1, 0));
-        } else {
-            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - 2*n, 0), -60, false, -1, 0));
-            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, 0), 180, false, -1, 0));
-        }
-        maEnteringSlidePrimitives.push_back (Slide);
-        ln = n;
-    }
-}
-
-void OGLTransitionImpl::displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
-{
-    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
-
-    glDisable(GL_DEPTH_TEST);
-
-    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
-
-    glDisable(GL_LIGHTING);
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-    glColor4f( 1, 1, 1, nTime );
-    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    glDisable(GL_BLEND);
-    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-    glEnable(GL_LIGHTING);
-
-    glEnable(GL_DEPTH_TEST);
-}
-
-void OGLTransitionImpl::makeFadeSmoothly()
-{ 
-    Primitive Slide;
-
-    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
-    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
-    maLeavingSlidePrimitives.push_back (Slide);
-    maEnteringSlidePrimitives.push_back (Slide);
-
-    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeSmoothly;
-    mbUseMipMapLeaving = mbUseMipMapEntering = false;
-}
-
-void OGLTransitionImpl::displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
-{
-    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
-
-    glDisable(GL_DEPTH_TEST);
-
-    glDisable(GL_LIGHTING);
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-    if( nTime < 0.5 ) {
-    glColor4f( 1, 1, 1, 1 - nTime*2 );
-    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    } else {
-    glColor4f( 1, 1, 1, (nTime - 0.5)*2 );
-    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
-    }
-    glDisable(GL_BLEND);
-    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-    glEnable(GL_LIGHTING);
-
-    glEnable(GL_DEPTH_TEST);
-}
-
-void OGLTransitionImpl::makeFadeThroughBlack()
-{ 
-    Primitive Slide;
-
-    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
-    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
-    maLeavingSlidePrimitives.push_back (Slide);
-    maEnteringSlidePrimitives.push_back (Slide);
-
-    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeThroughBlack;
-    mbUseMipMapLeaving = mbUseMipMapEntering = false;
-}
-
-static const char* basicVertexShader = "\n\
-varying vec2 v_texturePosition;\n\
-\n\
-void main( void )\n\
-{\n\
-    gl_Position = ftransform();\n\
-    v_texturePosition = gl_MultiTexCoord0.xy;\n\
-}\n\
-";
-
-static const char* staticFragmentShader = "\n\
-uniform sampler2D leavingSlideTexture;\n\
-uniform sampler2D enteringSlideTexture;\n\
-uniform sampler2D permTexture;\n\
-uniform float time;\n\
-varying vec2 v_texturePosition;\n\
-\n\
-float snoise(vec2 P) {\n\
-\n\
-  return texture2D(permTexture, P).r;\n\
-}\n\
-\n\
-\n\
-#define PART 0.5\n\
-#define START 0.4\n\
-#define END 0.9\n\
-\n\
-void main() {\n\
-    float sn = snoise(10.0*v_texturePosition+time*0.07);\n\
-    if( time < PART ) {\n\
-        float sn1 = snoise(vec2(time*15.0, 20.0*v_texturePosition.y));\n\
-        float sn2 = snoise(v_texturePosition);\n\
-        if (sn1 > 1.0 - time*time && sn2 < 2.0*time+0.1)\n\
-            gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
-        else if (time > START )\n\
-            gl_FragColor = ((time-START)/(PART - START))*vec4(sn, sn, sn, 1.0) + (1.0 - (time - START)/(PART - START))*texture2D(leavingSlideTexture, v_texturePosition);\n\
-        else\n\
-            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
-    } else if ( time < PART ) {\n\
-            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
-    } else if ( time > END ) {\n\
-        gl_FragColor = ((1.0 - time)/(1.0 - END))*vec4(sn, sn, sn, 1.0) + ((time - END)/(1.0 - END))*texture2D(enteringSlideTexture, v_texturePosition);\n\
-    } else \n\
-        gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
-}\n\
-";
-
-static const char* dissolveFragmentShader = "\n\
-uniform sampler2D leavingSlideTexture;\n\
-uniform sampler2D enteringSlideTexture;\n\
-uniform sampler2D permTexture;\n\
-uniform float time;\n\
-varying vec2 v_texturePosition;\n\
-\n\
-float snoise(vec2 P) {\n\
-\n\
-  return texture2D(permTexture, P).r;\n\
-}\n\
-\n\
-void main() {\n\
-     float sn = snoise(10.0*v_texturePosition);\n\
-     if( sn < time)\n\
-         gl_FragColor = texture2D(enteringSlideTexture, v_texturePosition);\n\
-     else\n\
-         gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
-}\n\
-";
-
-int permutation256 [256]= {
-215, 100, 200, 204, 233,  50,  85, 196, 
- 71, 141, 122, 160,  93, 131, 243, 234, 
-162, 183,  36, 155,   4,  62,  35, 205, 
- 40, 102,  33,  27, 255,  55, 214, 156, 
- 75, 163, 134, 126, 249,  74, 197, 228, 
- 72,  90, 206, 235,  17,  22,  49, 169, 
-227,  89,  16,   5, 117,  60, 248, 230, 
-217,  68, 138,  96, 194, 170, 136,  10, 
-112, 238, 184, 189, 176,  42, 225, 212, 
- 84,  58, 175, 244, 150, 168, 219, 236, 
-101, 208, 123,  37, 164, 110, 158, 201, 
- 78, 114,  57,  48,  70, 142, 106,  43, 
-232,  26,  32, 252, 239,  98, 191,  94, 
- 59, 149,  39, 187, 203, 190,  19,  13, 
-133,  45,  61, 247,  23,  34,  20,  52, 
-118, 209, 146, 193, 222,  18,   1, 152, 
- 46,  41,  91, 148, 115,  25, 135,  77, 
-254, 147, 224, 161,   9, 213, 223, 250, 
-231, 251, 127, 166,  63, 179,  81, 130, 
-139,  28, 120, 151, 241,  86, 111,   0, 
- 88, 153, 172, 182, 159, 105, 178,  47, 
- 51, 167,  65,  66,  92,  73, 198, 211, 
-245, 195,  31, 220, 140,  76, 221, 186, 
-154, 185,  56,  83,  38, 165, 109,  67, 
-124, 226, 132,  53, 229,  29,  12, 181, 
-121,  24, 207, 199, 177, 113,  30,  80, 
-  3,  97, 188,  79, 216, 173,   8, 145, 
- 87, 128, 180, 237, 240, 137, 125, 104, 
- 15, 242, 119, 246, 103, 143,  95, 144, 
-  2,  44,  69, 157, 192, 174,  14,  54, 
-218,  82,  64, 210,  11,   6, 129,  21, 
-116, 171,  99, 202,   7, 107, 253, 108
-};
-
-void initPermTexture(GLuint *texID)
-{
-  glGenTextures(1, texID);
-  glBindTexture(GL_TEXTURE_2D, *texID);
-
-  static bool initialized = false;
-  static unsigned char permutation2D[256*256*4];
-  if( !initialized ) {
-      int x, y;
-
-      for( y=0; y < 256; y++ )
-          for( x=0; x < 256; x++ )
-              permutation2D[x*4 + y*1024] = permutation256[(y + permutation256[x]) & 0xff];
-
-      initialized = true;
-  }
-
-  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, permutation2D );
-  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-}
-
-void OGLTransitionImpl::preparePermShader()
-{
-#ifdef GL_VERSION_2_0
-    if( mProgramObject ) {
-        OGLShaders::glUseProgram( mProgramObject );
-
-        GLint location = OGLShaders::glGetUniformLocation( mProgramObject, "leavingSlideTexture" );
-        if( location != -1 ) {
-            OGLShaders::glUniform1i( location, 0 );  // texture unit 0
-        }
-
-        glActiveTexture(GL_TEXTURE1);
-        if( !maHelperTexture )
-            initPermTexture( &maHelperTexture );
-        glActiveTexture(GL_TEXTURE0);
-
-        location = OGLShaders::glGetUniformLocation( mProgramObject, "permTexture" );
-        if( location != -1 ) {
-            OGLShaders::glUniform1i( location, 1 );  // texture unit 1
-        }
-
-        location = OGLShaders::glGetUniformLocation( mProgramObject, "enteringSlideTexture" );
-        if( location != -1 ) {
-            OGLShaders::glUniform1i( location, 2 );  // texture unit 2
-        }
-    }
-#endif
-}
-
-void OGLTransitionImpl::prepareStatic( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
-{
-    mProgramObject = OGLShaders::LinkProgram( basicVertexShader, staticFragmentShader );
-
-    preparePermShader();
-}
-
-void OGLTransitionImpl::displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
-                                              double SlideWidthScale, double SlideHeightScale )
-{
-    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
-
-#ifdef GL_VERSION_2_0
-    if( mProgramObject ) {
-        GLint location = OGLShaders::glGetUniformLocation( mProgramObject, "time" );
-        if( location != -1 ) {
-            OGLShaders::glUniform1f( location, nTime );
-        }
-    }
-
-    glActiveTexture( GL_TEXTURE2 );
-    glBindTexture( GL_TEXTURE_2D, glEnteringSlideTex );
-    glActiveTexture( GL_TEXTURE0 );
-#endif
-
-    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
-}
-
-void OGLTransitionImpl::makeStatic()
-{
-    Primitive Slide;
-
-    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
-    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
-    maLeavingSlidePrimitives.push_back (Slide);
-    maEnteringSlidePrimitives.push_back (Slide);
-
-    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
-    mmPrepareTransition = &OGLTransitionImpl::prepareStatic;
-    mbUseMipMapLeaving = mbUseMipMapEntering = false;
-
-    mnRequiredGLVersion = 2.0;
-}
-
-void OGLTransitionImpl::prepareDissolve( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
-{
-    mProgramObject = OGLShaders::LinkProgram( basicVertexShader, dissolveFragmentShader );
-
-    preparePermShader();
-}
-
-void OGLTransitionImpl::makeDissolve()
-{
-    Primitive Slide;
-
-    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
-    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
-    maLeavingSlidePrimitives.push_back (Slide);
-    maEnteringSlidePrimitives.push_back (Slide);
-
-    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
-    mmPrepareTransition = &OGLTransitionImpl::prepareDissolve;
-    mbUseMipMapLeaving = mbUseMipMapEntering = false;
-
-    mnRequiredGLVersion = 2.0;
-}
-
-void OGLTransitionImpl::makeNewsflash()
-{
-    Primitive Slide;
-    
-    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
-    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
-    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),3000,true,0,0.5));
-    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),true,0,0.5));
-    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-10000, 0, 0),false, 0.5, 2));
-    maLeavingSlidePrimitives.push_back(Slide);
-
-    Slide.Operations.clear();
-    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),-3000,true,0.5,1));
-    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-100, 0, 0),false, -1, 1));
-    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(100, 0, 0),false, 0.5, 1));
-    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),false,-1,1));
-    Slide.Operations.push_back(new SScale(basegfx::B3DVector(100,100,100),basegfx::B3DVector(0,0,0),true,0.5,1));
-    maEnteringSlidePrimitives.push_back(Slide);
-
-    OverallOperations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0.2,0.2,0),1080,true,0,1));
-}
-
diff --git slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
deleted file mode 100644
index 2aa0529..0000000
--- slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
+++ /dev/null
@@ -1,509 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: OGLTrans_TransitionImpl.hxx,v $
- * $Revision: 1.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
-#define INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
-
-#include <basegfx/vector/b2dvector.hxx>
-#include <basegfx/vector/b3dvector.hxx>
-
-#include <tools/prewin.h>
-#include <tools/postwin.h>
-
-#if defined( WNT ) 
-#include <tools/prewin.h>
-#include <tools/postwin.h>
-#elif defined( OS2 )
-#elif defined( QUARTZ )
-#elif defined( UNX )
-#endif    	
-
-#include <vector>
-#include <GL/gl.h>
-
-using namespace std;
-
-class Primitive;
-class Operation;
-class SceneObject;
-
-
-/** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
-
-    This class is capable of making itself into many difference transitions. It holds Primitives and Operations on those primitives.
-*/
-class OGLTransitionImpl
-{
-public:
-    OGLTransitionImpl() :
-        mbUseMipMapLeaving( true ),
-        mbUseMipMapEntering( true ),
-        mnRequiredGLVersion( 1.0 ),
-        maLeavingSlidePrimitives(),
-        maEnteringSlidePrimitives(),
-        maSceneObjects(),
-        mbReflectSlides( false ),
-        mVertexObject( 0 ),
-        mFragmentObject( 0 ),
-        mProgramObject( 0 ),
-        maHelperTexture( 0 ),
-        mmPrepare( NULL ),
-        mmPrepareTransition( NULL ),
-        mmClearTransition( NULL ),
-        mmDisplaySlides( NULL )
-    {}
-
-    ~OGLTransitionImpl();
-    
-    void prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
-    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
-    void finish();
-
-    void makeOutsideCubeFaceToLeft();
-    void makeInsideCubeFaceToLeft();
-    void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
-    void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
-    void makeHelix( ::sal_uInt16 nRows );
-    void makeFallLeaving();
-    void makeTurnAround();
-    void makeTurnDown();
-    void makeIris();
-    void makeRochade();
-    void makeVenetianBlinds( bool vertical, int parts );
-    void makeStatic();
-    void makeDissolve();
-    void makeNewsflash();
-
-    /** 2D replacements
-     */
-    void makeDiamond();
-    void makeFadeSmoothly();
-    void makeFadeThroughBlack();
-
-    /** Whether to use mipmaping for slides textures
-     */
-    bool mbUseMipMapLeaving;
-    bool mbUseMipMapEntering;
-
-    /** which GL version does the transition require
-     */
-    float mnRequiredGLVersion;
-
-private:
-    /** clears all the primitives and operations
-    */
-    void clear();
-    
-    /** All the primitives that use the leaving slide texture
-    */
-    vector<Primitive> maLeavingSlidePrimitives;
-    
-    /** All the primitives that use the leaving slide texture
-    */
-    vector<Primitive> maEnteringSlidePrimitives;
-    
-    /** All the surrounding scene objects
-    */
-    vector<SceneObject*> maSceneObjects;
-
-    /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
-    */
-    vector<Operation*> OverallOperations;
-
-    /** Whether to reflect slides, the reflection happens on flat surface beneath the slides.
-     ** Now it only works with slides which keep their rectangular shape together.
-     */
-    bool mbReflectSlides;
-
-    /** GLSL objects, shaders and program
-     */
-    GLuint mVertexObject, mFragmentObject, mProgramObject;
-
-    /** various data */
-    GLuint maHelperTexture;
-
-    /** When this method is not NULL, it is called in display method to prepare the slides, scene, etc.
-     ** We might later replace this by cleaner derived class.
-     */
-    void (OGLTransitionImpl::*mmPrepare)( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
-
-    /** When this method is not NULL, it is called after glx context is ready to let the transition prepare GL related things, like GLSL program.
-     ** We might later replace this by cleaner derived class.
-     */
-    void (OGLTransitionImpl::*mmPrepareTransition)( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
-
-    /** When this method is not NULL, it is called when the transition needs to clear after itself, like delete own textures etc.
-     ** We might later replace this by cleaner derived class.
-     */
-    void (OGLTransitionImpl::*mmClearTransition)();
-
-    /** When this method is not NULL, it is called in display method to display the slides.
-     ** We might later replace this by cleaner derived class.
-     */
-    void (OGLTransitionImpl::*mmDisplaySlides)( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
-
-    void displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
-    void displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives, double SlideWidthScale, double SlideHeightScale );
-    void displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
-    void applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale );
-
-    /** various transitions helper methods
-     */
-    void prepareDiamond( double nTime, double SlideWidth, double SlideHeight,double DispWidth, double DispHeight );
-    void displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
-        void displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
-        void displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
-    void displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
-    void prepareStatic( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
-    void prepareDissolve( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
-    void preparePermShader();
-};
-
-class SceneObject
-{
-public:
-    SceneObject();
-
-    virtual void prepare() {};
-    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
-    virtual void finish() {};
-
-    void pushPrimitive (const Primitive &p);
-
-protected:
-    /** All the surrounding scene primitives
-    */
-    vector<Primitive> maPrimitives;
-};
-
-class Iris : public SceneObject
-{
-public:
-    Iris ();
-
-    virtual void prepare();
-    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
-    virtual void finish();
-
-private:
-
-    GLuint maTexture;
-};
-
-/** This class is a list of Triangles that will share Operations, and could possibly share  
-*/
-class Primitive
-{
-public:
-    Primitive() {}
-    // making copy constructor explicit makes the class un-suitable for use with stl containers
-    Primitive(const Primitive& rvalue);
-    ~Primitive();
-
-    void applyOperations(double nTime, double SlideWidthScale, double SlideHeightScale);
-    void display(double nTime, double SlideWidthScale, double SlideHeightScale);
-    const Primitive& operator=(const Primitive& rvalue);
-    
-    /** PushBack a vertex,normal, and tex coord. Each SlideLocation is where on the slide is mapped to this location ( from (0,0) to (1,1)  ). This will make sure the correct aspect ratio is used, and helps to make slides begin and end at the correct position. (0,0) is the top left of the slide, and (1,1) is the bottom right.
-    
-    @param SlideLocation0
-    Location of first Vertex on slide
-    
-    @param SlideLocation1
-    Location of second Vertex on slide
-    
-    @param SlideLocation2
-    Location of third Vertex on slide
-    
-    */
-    void pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2);
-    
-    /** clear all the vertices, normals, tex coordinates, and normals
-    */
-    void clearTriangles();
-    
-    /** guards against directly changing the vertices
-        
-        @return        
-        the list of vertices
-    */
-    const vector<basegfx::B3DVector>& getVertices() const {return Vertices;}
-    
-    /** guards against directly changing the vertices
-    */
-    const vector<basegfx::B3DVector>& getNormals() const {return Normals;}
-    
-    /** guards against directly changing the vertices
-    
-        @return        
-        the list of Texture Coordinates
-    
-    */
-    const vector<basegfx::B2DVector>& getTexCoords() const {return TexCoords;}
-
-    /** list of Operations to be performed on this primitive.These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
-    
-        @return        
-        the list of Operations
-    
-    */    
-    vector<Operation*> Operations;
-
-private:
-    /** list of vertices
-    */
-    vector<basegfx::B3DVector> Vertices;
-    
-    /** list of Normals
-    */
-    vector<basegfx::B3DVector> Normals;
-    
-    /** list of Texture Coordinates
-    */
-    vector<basegfx::B2DVector> TexCoords;
-};
-
-/** This class is to be derived to make any operation (tranform) you may need in order to construct your transitions
-*/
-class Operation
-{
-public:
-    Operation(){}
-    virtual ~Operation(){}
-    
-    /** Should this operation be interpolated . If TRUE, the transform will smoothly move from making no difference from t = 0.0 to nT0 to being completely transformed from t = nT1 to 1. If FALSE, the transform will be inneffectual from t = 0 to nT0, and completely transformed from t = nT0 to 1. 
-    */
-    bool bInterpolate;
-    
-    /** time to begin the transformation
-    */
-    double nT0;
-    
-    /** time to finish the transformation
-    */
-    double nT1;
-public:
-    /** this is the function that is called to give the Operation to OpenGL.
-        
-        @param t
-        time from t = 0 to t = 1
-        
-        @param SlideWidthScale
-        width of slide divided by width of window
-        
-        @param SlideHeightScale
-        height of slide divided by height of window
-    
-    */
-    virtual void interpolate(double t,double SlideWidthScale,double SlideHeightScale) = 0;
-    
-    /** return a copy of this operation
-    */
-    virtual Operation* clone() = 0;
-};
-
-/** this class is a generic CounterClockWise(CCW) rotation with an axis angle
-*/
-class SRotate: public Operation
-{
-public:
-    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
-    virtual SRotate* clone();
-    
-    /** Constructor
-        
-        @param Axis
-        axis to rotate about
-        
-        @param Origin
-        position that rotation axis runs through
-        
-        @param Angle
-        angle in radians of CCW rotation
-        
-        @param bInter
-        see Operation
-        
-        @param T0
-        transformation starting time
-        
-        @param T1
-        transformation ending time
-    
-    */
-    SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
-    ~SRotate(){}
-private:
-    /** axis to rotate CCW about
-    */
-    basegfx::B3DVector axis;
-    
-    /** position that rotation axis runs through
-    */
-    basegfx::B3DVector origin;
-    
-    /** angle in radians of CCW rotation
-    */
-    double angle;
-};
-
-/** scaling transformation
-*/
-class SScale: public Operation
-{
-public:
-    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
-    SScale* clone();
-    
-    /** Constructor
-        
-        @param Scale
-        amount to scale by 
-        
-        @param Origin
-        position that rotation axis runs through
-        
-        @param bInter
-        see Operation
-        
-        @param T0
-        transformation starting time
-        
-        @param T1
-        transformation ending time
-    
-    */
-    SScale(const basegfx::B3DVector& Scale, const basegfx::B3DVector& Origin,bool bInter, double T0, double T1);
-    ~SScale(){}
-private:
-    basegfx::B3DVector scale;
-    basegfx::B3DVector origin;
-};
-
-/** translation transformation
-*/
-class STranslate: public Operation
-{
-public:
-    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
-    STranslate* clone();
-    
-    /** Constructor
-        
-        @param Vector
-        vector to translate
-        
-        @param bInter
-        see Operation
-        
-        @param T0
-        transformation starting time
-        
-        @param T1
-        transformation ending time
-    
-    */
-    STranslate(const basegfx::B3DVector& Vector,bool bInter, double T0, double T1);
-    ~STranslate(){}
-private:
-    /** vector to translate by
-    */
-    basegfx::B3DVector vector;
-};
-
-/** translation transformation
-*/
-class SEllipseTranslate: public Operation
-{
-public:
-    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
-    SEllipseTranslate* clone();
-    
-    /** Constructor
-        
-        @param Vector
-        vector to translate
-        
-        @param bInter
-        see Operation
-        
-        @param T0
-        transformation starting time
-        
-        @param T1
-        transformation ending time
-    
-    */
-    SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1);
-    ~SEllipseTranslate(){}
-private:
-    /** width and length of the ellipse
-     */
-    double width, height;
-
-    /** start and end position on the ellipse <0,1>
-     */
-    double startPosition;
-    double endPosition;
-};
-
-/** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
-*/
-class RotateAndScaleDepthByWidth: public Operation
-{
-public:
-    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
-    RotateAndScaleDepthByWidth* clone();
-
-    RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
-    ~RotateAndScaleDepthByWidth(){}
-private:
-    basegfx::B3DVector axis;
-    basegfx::B3DVector origin;
-    double angle;
-};
-
-/** Same as SRotate, except the depth is scaled by the width of the slide divided by the height of the window.
-*/
-class RotateAndScaleDepthByHeight: public Operation
-{
-public:
-    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
-    RotateAndScaleDepthByHeight* clone();
-
-    RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
-    ~RotateAndScaleDepthByHeight(){}
-private:
-    basegfx::B3DVector axis;
-    basegfx::B3DVector origin;
-    double angle;
-};
-
-#endif // INCLUDED_SLIDESHOW_TRANSITION_HXX_
-
diff --git slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
deleted file mode 100644
index 01d513c..0000000
--- slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
+++ /dev/null
@@ -1,1487 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: OGLTrans_TransitionerImpl.cxx,v $
- * $Revision: 1.6 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#define GLX_GLXEXT_PROTOTYPES 1
-#include "OGLTrans_TransitionImpl.hxx"
-
-#include <com/sun/star/beans/XFastPropertySet.hpp>
-#include <com/sun/star/rendering/IntegerBitmapLayout.hpp>
-#include <com/sun/star/rendering/ColorComponentTag.hpp>
-#include <com/sun/star/rendering/ColorSpaceType.hpp>
-#include <com/sun/star/animations/TransitionType.hpp>
-#include <com/sun/star/animations/TransitionSubType.hpp>
-#include <com/sun/star/presentation/XTransitionFactory.hpp>
-#include <com/sun/star/presentation/XTransition.hpp>
-#include <com/sun/star/presentation/XSlideShowView.hpp>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/rendering/XIntegerBitmap.hpp>
-#include <com/sun/star/geometry/IntegerSize2D.hpp>
-
-#include <cppuhelper/compbase1.hxx>
-#include <cppuhelper/basemutex.hxx>
-#include <cppuhelper/factory.hxx>
-#include <rtl/ref.hxx>
-
-#include <comphelper/servicedecl.hxx>
-
-#include <canvas/canvastools.hxx>
-#include <tools/gen.hxx>
-#include <vcl/window.hxx>
-#include <vcl/syschild.hxx>
-
-#include <boost/noncopyable.hpp>
-
-#include <GL/gl.h>
-#include <GL/glu.h>
-
-
-#if defined( WNT ) 
-    #include <tools/prewin.h>
-    #include <windows.h>
-    #include <tools/postwin.h>
-    #define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
-    #define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
-#elif defined( OS2 )
-#elif defined( QUARTZ )
-    #include "premac.h"
-    #include <Cocoa/Cocoa.h>
-    #include "postmac.h"
-#elif defined( UNX )
-namespace unx
-{
-#include <X11/keysym.h>
-#include <X11/X.h>
-#include <GL/glx.h>
-#include <GL/glxext.h>
-}
-#endif
-#include <vcl/sysdata.hxx>
-
-#ifdef DEBUG
-#include <boost/date_time/posix_time/posix_time.hpp>
-using namespace ::boost::posix_time;
-
-static ptime t1;
-static ptime t2;
-
-#define DBG(x) x
-#else
-#define DBG(x)
-#endif
-
-using namespace ::com::sun::star;
-using ::com::sun::star::beans::XFastPropertySet;
-using ::com::sun::star::uno::Any;
-using ::com::sun::star::uno::Reference;
-using ::com::sun::star::uno::Sequence;
-using ::com::sun::star::uno::UNO_QUERY;
-using ::com::sun::star::uno::UNO_QUERY_THROW;
-
-namespace
-{
-
-typedef cppu::WeakComponentImplHelper1<presentation::XTransition> OGLTransitionerImplBase;
-
-namespace
-{
-    struct OGLFormat
-    {
-        GLint  nInternalFormat;
-        GLenum eFormat;
-        GLenum eType;
-    };
-
-    /* channel ordering: (0:rgba, 1:bgra, 2:argb, 3:abgr)  
-    */
-    int calcComponentOrderIndex(const uno::Sequence<sal_Int8>& rTags)
-    {
-        using namespace rendering::ColorComponentTag;
-
-        static const sal_Int8 aOrderTable[] =
-        {
-            RGB_RED, RGB_GREEN, RGB_BLUE, ALPHA,
-            RGB_BLUE, RGB_GREEN, RGB_RED, ALPHA,
-            ALPHA, RGB_RED, RGB_GREEN, RGB_BLUE,
-            ALPHA, RGB_BLUE, RGB_GREEN, RGB_RED, 
-        };
-
-        const sal_Int32 nNumComps(rTags.getLength());
-        const sal_Int8* pLine=aOrderTable;
-        for(int i=0; i<4; ++i)
-        {
-            int j=0;
-            while( j<4 && j<nNumComps && pLine[j] == rTags[j] )
-                ++j;
-
-            // all of the line passed, this is a match!
-            if( j==nNumComps )
-                return i;
-
-            pLine+=4;
-        }
-
-        return -1;
-    }
-}
-
-// not thread safe
-static bool errorTriggered;
-int oglErrorHandler( unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/ )
-{
-    errorTriggered = true;
-
-    return 0;
-}
-
-/** This is the Transitioner class for OpenGL 3D transitions in
- * slideshow. At the moment, it's Linux only. This class is implicitly
- * constructed from XTransitionFactory.
-*/
-class OGLTransitionerImpl : private cppu::BaseMutex, private boost::noncopyable, public OGLTransitionerImplBase
-{
-public:
-    explicit OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition);
-    bool initWindowFromSlideShowView( const uno::Reference< presentation::XSlideShowView >& xView );
-    void setSlides( const Reference< rendering::XBitmap >& xLeavingSlide , const uno::Reference< rendering::XBitmap >& xEnteringSlide );
-    static bool initialize( const Reference< presentation::XSlideShowView >& xView );
-
-    // XTransition
-    virtual void SAL_CALL update( double nTime )
-    throw (uno::RuntimeException);
-    virtual void SAL_CALL viewChanged( const Reference< presentation::XSlideShowView >& rView,
-                       const Reference< rendering::XBitmap >& rLeavingBitmap,
-                       const Reference< rendering::XBitmap >& rEnteringBitmap )
-    throw (uno::RuntimeException);
-    
-protected:
-    void disposeContextAndWindow();
-    void disposeTextures();
-
-    // WeakComponentImplHelperBase
-    virtual void SAL_CALL disposing();
-    
-    bool isDisposed() const
-    {
-        return (rBHelper.bDisposed || rBHelper.bInDispose);
-    }
-
-    bool createWindow( Window* pPWindow );
-    void createTexture( unsigned int* texID,
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-            unx::GLXPixmap pixmap,
-            bool usePixmap,
-#endif
-            bool useMipmap,
-            uno::Sequence<sal_Int8>& data,
-            const OGLFormat* pFormat );
-    void prepareEnvironment ();
-    const OGLFormat* chooseFormats();
-
-private:    
-    /** After the window has been created, and the slides have been set, we'll initialize the slides with OpenGL.
-    */
-    void GLInitSlides();
-
-
-    /// Holds the information of our new child window
-    struct GLWindow
-    {
-#if defined( WNT ) 
-    HWND					hWnd;
-    HDC						hDC;
-    HGLRC					hRC;
-#elif defined( OS2 )
-#elif defined( QUARTZ )
-#elif defined( UNX )
-    unx::Display*           dpy;
-    int                     screen;
-    unx::Window             win;
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    unx::GLXFBConfig        fbc;
-#endif
-    unx::XVisualInfo*       vi;
-    unx::GLXContext         ctx;
-#endif
-        unsigned int            bpp;
-        unsigned int            Width;
-        unsigned int            Height;
-        const char*             GLXExtensions;
-    const GLubyte*          GLExtensions;
-
-        bool HasGLXExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, (const GLubyte*) GLXExtensions ); }
-    bool HasGLExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, GLExtensions ); }
-    } GLWin;
-    
-    /** OpenGL handle to the leaving slide's texture
-    */
-    unsigned int GLleavingSlide;
-    /** OpenGL handle to the entering slide's texture
-    */
-    unsigned int GLenteringSlide;
-    
-    /** pointer to our window which we MIGHT create.
-    */
-    class SystemChildWindow* pWindow;
-
-    Reference< presentation::XSlideShowView > mxView;
-    Reference< rendering::XIntegerBitmap > mxLeavingBitmap;
-    Reference< rendering::XIntegerBitmap > mxEnteringBitmap;
-    
-    /** raw bytes of the entering bitmap
-    */
-    uno::Sequence<sal_Int8> EnteringBytes;
-    
-    /** raw bytes of the leaving bitmap
-    */
-    uno::Sequence<sal_Int8> LeavingBytes;
-
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    unx::GLXPixmap LeavingPixmap;
-    unx::GLXPixmap EnteringPixmap;
-#endif
-    bool mbRestoreSync;
-    bool mbUseLeavingPixmap;
-    bool mbUseEnteringPixmap;
-    bool mbFreeLeavingPixmap;
-    bool mbFreeEnteringPixmap;
-    unx::Pixmap maLeavingPixmap;
-    unx::Pixmap maEnteringPixmap;
-    
-    /** the form the raw bytes are in for the bitmaps
-    */
-    rendering::IntegerBitmapLayout SlideBitmapLayout; 
-    
-    /** the size of the slides
-    */    
-    geometry::IntegerSize2D SlideSize;
-    
-    /** Our Transition to be used.
-    */    
-    OGLTransitionImpl* pTransition;
-
-public:
-    /** whether we are running on ATI fglrx with bug related to textures
-     */
-    static bool cbBrokenTexturesATI;
-
-    /** GL version
-     */
-    static float cnGLVersion;
-    float mnGLXVersion;
-
-    /** Whether Mesa is the OpenGL vendor
-     */
-    static bool cbMesa;
-
-    /**
-       whether the display has GLX extension
-     */
-    static bool cbGLXPresent;
-
-    /**
-       whether texture from pixmap extension is available
-    */
-    bool mbTextureFromPixmap;
-
-    /**
-       whether to generate mipmaped textures
-    */
-    bool mbGenerateMipmap;
-
-    /**
-       whether we have visual which can be used for texture_from_pixmap extension
-    */
-    bool mbHasTFPVisual;
-
-#ifdef DEBUG
-    ptime t3;
-    ptime t4;
-    ptime t5;
-    ptime t6;
-    time_duration total_update;
-    int frame_count;
-#endif
-};
-
-// declare the static variables as some gcc versions have problems declaring them automaticaly
-bool OGLTransitionerImpl::cbBrokenTexturesATI;
-float OGLTransitionerImpl::cnGLVersion;
-bool OGLTransitionerImpl::cbMesa;
-bool OGLTransitionerImpl::cbGLXPresent;
-
-bool OGLTransitionerImpl::initialize( const Reference< presentation::XSlideShowView >& xView )
-{
-    // not thread safe
-    static bool initialized = false;
-
-    if( !initialized ) {
-        OGLTransitionerImpl *instance;
-
-        instance = new OGLTransitionerImpl( NULL );
-        if( instance->initWindowFromSlideShowView( xView ) ) {
-
-            const GLubyte* version = glGetString( GL_VERSION );
-            if( version && version[0] ) {
-                cnGLVersion = version[0] - '0';
-                if( version[1] == '.' && version[2] )
-                    cnGLVersion += (version[2] - '0')/10.0;
-            } else
-                cnGLVersion = 1.0;
-            OSL_TRACE("GL version: %s parsed: %f", version, cnGLVersion );
-
-            const GLubyte* vendor = glGetString( GL_VENDOR );
-            cbMesa = ( vendor && strstr( (const char *) vendor, "Mesa" ) );
-            OSL_TRACE("GL vendor: %s identified as Mesa: %d", vendor, cbMesa );
-
-            /* TODO: check for version once the bug in fglrx driver is fixed */
-            cbBrokenTexturesATI = (vendor && strcmp( (const char *) vendor, "ATI Technologies Inc." ) == 0 );
-
-            instance->disposing();
-            cbGLXPresent = true;
-        } else
-            cbGLXPresent = false;
-
-        delete instance;
-        initialized = true;
-    }
-
-    return cbGLXPresent;
-}
-
-bool OGLTransitionerImpl::createWindow( Window* pPWindow )
-{
-    const SystemEnvData* sysData(pPWindow->GetSystemData());
-#if defined( WNT ) 
-    GLWin.hWnd = sysData->hWnd;
-#elif defined( UNX )
-    GLWin.dpy = reinterpret_cast<unx::Display*>(sysData->pDisplay);
-
-    if( unx::glXQueryExtension( GLWin.dpy, NULL, NULL ) == false )
-        return false;
-
-    GLWin.win = sysData->aWindow;
-
-    OSL_TRACE("parent window: %d", GLWin.win);
-
-    unx::XWindowAttributes xattr;
-    unx::XGetWindowAttributes( GLWin.dpy, GLWin.win, &xattr );
-
-    GLWin.screen = XScreenNumberOfScreen( xattr.screen );
-
-    unx::XVisualInfo* vi( NULL );
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    unx::XVisualInfo* visinfo;
-    unx::XVisualInfo* firstVisual( NULL );
-#endif
-    static int attrList3[] =
-        {
-        GLX_RGBA,//only TrueColor or DirectColor
-            //single buffered
-            GLX_RED_SIZE,4,//use the maximum red bits, with a minimum of 4 bits
-            GLX_GREEN_SIZE,4,//use the maximum green bits, with a minimum of 4 bits
-            GLX_BLUE_SIZE,4,//use the maximum blue bits, with a minimum of 4 bits
-            GLX_DEPTH_SIZE,0,//no depth buffer
-            None
-        };
-    static int attrList2[] = 
-    {
-        GLX_RGBA,//only TrueColor or DirectColor
-            /// single buffered
-            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
-            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
-            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
-            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
-            None
-        };
-    static int attrList1[] =
-        {
-        GLX_RGBA,//only TrueColor or DirectColor
-            GLX_DOUBLEBUFFER,/// only double buffer
-            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
-            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
-            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
-            GLX_DEPTH_SIZE,0,/// no depth buffer
-            None
-        };
-    static int attrList0[] =
-        {
-        GLX_RGBA,//only TrueColor or DirectColor
-            GLX_DOUBLEBUFFER,/// only double buffer
-            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
-            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
-            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
-            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
-            None
-       }; 
-    static int* attrTable[] = 
-        {
-            attrList0,
-            attrList1,
-            attrList2,
-            attrList3,
-            NULL
-        };
-    int** pAttributeTable = attrTable;
-    const SystemEnvData* pChildSysData = NULL;
-    delete pWindow;
-    pWindow=NULL;
-
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    unx::GLXFBConfig* fbconfigs = NULL;
-    int nfbconfigs, value, i = 0;
-#endif
-
-    while( *pAttributeTable )
-    {
-        // try to find a visual for the current set of attributes
-        vi = unx::glXChooseVisual( GLWin.dpy,
-                                   GLWin.screen,
-                                   *pAttributeTable );
-
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-      if( vi ) {
-      if( !firstVisual )
-          firstVisual = vi;
-      OSL_TRACE("trying VisualID %08X", vi->visualid);
-          fbconfigs = glXGetFBConfigs (GLWin.dpy, GLWin.screen, &nfbconfigs);
-          for ( ; i < nfbconfigs; i++)
-          {
-              visinfo = glXGetVisualFromFBConfig (GLWin.dpy, fbconfigs[i]);
-              if( !visinfo || visinfo->visualid != vi->visualid )
-                  continue;
-
-              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i], GLX_DRAWABLE_TYPE, &value);
-              if (!(value & GLX_PIXMAP_BIT))
-                  continue;
-
-              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
-                                    GLX_BIND_TO_TEXTURE_TARGETS_EXT,
-                                    &value);
-              if (!(value & GLX_TEXTURE_2D_BIT_EXT))
-                  continue;
-
-              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
-                                    GLX_BIND_TO_TEXTURE_RGB_EXT,
-                                    &value);
-              if (value == FALSE)
-                  continue;
-
-              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
-                                    GLX_BIND_TO_MIPMAP_TEXTURE_EXT,
-                                    &value);
-              if (value == FALSE)
-                  continue;
-
-              /* TODO: handle non Y inverted cases */
-              break;
-          }
-
-          if( i != nfbconfigs || ( firstVisual && pAttributeTable[1] == NULL ) ) {
-          if( i != nfbconfigs ) {
-          vi = glXGetVisualFromFBConfig( GLWin.dpy, fbconfigs[i] );
-          mbHasTFPVisual = true;
-          OSL_TRACE("found visual suitable for texture_from_pixmap");
-          } else {
-          vi = firstVisual;
-          mbHasTFPVisual = false;
-          OSL_TRACE("did not find visual suitable for texture_from_pixmap, using %08X", vi->visualid);
-          }
-#else
-      if( vi ) {
-#endif
-              SystemWindowData winData;
-              winData.nSize = sizeof(winData);
-          OSL_TRACE("using VisualID %08X", vi->visualid);
-              winData.pVisual = (void*)(vi->visual);
-              pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
-              pChildSysData = pWindow->GetSystemData();
-              if( pChildSysData ) {
-                  break;
-              } else {
-                  delete pWindow, pWindow=NULL;
-              }
-          }
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-      }
-#endif
-
-        ++pAttributeTable;
-      }
-#endif
-
-#if defined( WNT ) 
-      const SystemEnvData* pChildSysData = NULL;
-      SystemWindowData winData;
-      winData.nSize = sizeof(winData);
-      pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
-      pChildSysData = pWindow->GetSystemData();
-#endif            
-
-      if( pWindow )
-      {
-      pWindow->SetMouseTransparent( TRUE );
-      pWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
-      pWindow->EnableEraseBackground( FALSE );
-      pWindow->SetControlForeground();
-      pWindow->SetControlBackground();
-      pWindow->EnablePaint(FALSE);
-#if defined( WNT ) 
-        GLWin.hWnd = sysData->hWnd;
-#elif defined( UNX )
-        GLWin.dpy = reinterpret_cast<unx::Display*>(pChildSysData->pDisplay);
-        GLWin.win = pChildSysData->aWindow;
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    if( mbHasTFPVisual )
-        GLWin.fbc = fbconfigs[i];
-#endif
-    GLWin.vi = vi;
-    GLWin.GLXExtensions = unx::glXQueryExtensionsString( GLWin.dpy, GLWin.screen );
-    OSL_TRACE("available GLX extensions: %s", GLWin.GLXExtensions);
-#endif
-
-    return true;
-    }
-
-    return false;
-}
-
-bool OGLTransitionerImpl::initWindowFromSlideShowView( const Reference< presentation::XSlideShowView >& xView )
-{
-    osl::MutexGuard const guard( m_aMutex );
-
-    if (isDisposed())
-        return false;
-
-    mxView.set( xView, UNO_QUERY );
-    if( !mxView.is() )
-    return false;
-
-    /// take the XSlideShowView and extract the parent window from it. see viewmediashape.cxx
-    uno::Reference< rendering::XCanvas > xCanvas(mxView->getCanvas(), uno::UNO_QUERY_THROW);
-    uno::Sequence< uno::Any > aDeviceParams;
-    ::canvas::tools::getDeviceInfo( xCanvas, aDeviceParams );
-
-    ::rtl::OUString aImplName;
-    aDeviceParams[ 0 ] >>= aImplName;
-
-    sal_Int64 aVal = 0;
-    aDeviceParams[1] >>= aVal;
-    if( !createWindow( reinterpret_cast< Window* >( aVal ) ) )
-    return false;
-
-    awt::Rectangle aCanvasArea = mxView->getCanvasArea();
-    pWindow->SetPosSizePixel(aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
-    GLWin.Width = aCanvasArea.Width;
-    GLWin.Height = aCanvasArea.Height;
-    OSL_TRACE("canvas area: %d,%d - %dx%d", aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
-
-#if defined( WNT ) 
-        GLWin.hDC = GetDC(GLWin.hWnd);
-#elif defined( UNX )
-    GLWin.ctx = glXCreateContext(GLWin.dpy,
-                                 GLWin.vi,
-                                 0,
-                                 GL_TRUE);
-    if( GLWin.ctx == NULL ) {
-    OSL_TRACE("unable to create GLX context");
-    return false;
-    }
-#endif
-
-#if defined( WNT ) 
-    PIXELFORMATDESCRIPTOR PixelFormatFront =					// PixelFormat Tells Windows How We Want Things To Be
-    {
-        sizeof(PIXELFORMATDESCRIPTOR),
-        1,								// Version Number
-        PFD_DRAW_TO_WINDOW |
-        PFD_SUPPORT_OPENGL |
-        PFD_DOUBLEBUFFER,
-        PFD_TYPE_RGBA,					// Request An RGBA Format
-        (BYTE)32,						// Select Our Color Depth
-        0, 0, 0, 0, 0, 0,				// Color Bits Ignored
-        0,								// No Alpha Buffer
-        0,								// Shift Bit Ignored
-        0,								// No Accumulation Buffer
-        0, 0, 0, 0,						// Accumulation Bits Ignored
-        64,								// 32 bit Z-BUFFER
-        0,								// 0 bit stencil buffer
-        0,								// No Auxiliary Buffer
-        0,								// now ignored
-        0,								// Reserved
-        0, 0, 0							// Layer Masks Ignored
-    };
-    int WindowPix = ChoosePixelFormat(GLWin.hDC,&PixelFormatFront);
-    SetPixelFormat(GLWin.hDC,WindowPix,&PixelFormatFront);
-    GLWin.hRC  = wglCreateContext(GLWin.hDC);
-    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
-#elif defined( UNX )
-    if( !glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx ) ) {
-        OSL_TRACE("unable to select current GLX context");
-        return false;
-    }
-
-    int glxMinor, glxMajor;
-    mnGLXVersion = 0;
-    if( glXQueryVersion( GLWin.dpy, &glxMajor, &glxMinor ) )
-      mnGLXVersion = glxMajor + 0.1*glxMinor;
-    OSL_TRACE("available GLX version: %f", mnGLXVersion);
-
-    GLWin.GLExtensions = glGetString( GL_EXTENSIONS );
-    OSL_TRACE("available GL  extensions: %s", GLWin.GLExtensions);
-
-    mbTextureFromPixmap = GLWin.HasGLXExtension( "GLX_EXT_texture_from_pixmap" );
-    mbGenerateMipmap = GLWin.HasGLExtension( "GL_SGIS_generate_mipmap" );
-
-    if( GLWin.HasGLXExtension("GLX_SGI_swap_control" ) ) {
-        // enable vsync
-        typedef GLint (*glXSwapIntervalProc)(GLint);
-        glXSwapIntervalProc glXSwapInterval = (glXSwapIntervalProc) unx::glXGetProcAddress( (const GLubyte*) "glXSwapIntervalSGI" );
-        if( glXSwapInterval ) {
-        int (*oldHandler)(unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/);
-
-        // replace error handler temporarily
-        oldHandler = unx::XSetErrorHandler( oglErrorHandler );
-
-        errorTriggered = false;
-
-        glXSwapInterval( 1 );
-
-        // sync so that we possibly get an XError
-        unx::glXWaitGL();
-        XSync(GLWin.dpy, false);
-
-        if( errorTriggered )
-            OSL_TRACE("error when trying to set swap interval, NVIDIA or Mesa bug?");
-        else
-            OSL_TRACE("set swap interval to 1 (enable vsync)");
-
-        // restore the error handler
-        unx::XSetErrorHandler( oldHandler );
-        }
-    }
-#endif
-
-    glEnable(GL_CULL_FACE);
-    glCullFace(GL_BACK);
-    glClearColor (0, 0, 0, 0);
-    glClear(GL_COLOR_BUFFER_BIT);
-#if defined( WNT ) 
-    SwapBuffers(GLWin.hDC);
-#elif defined( UNX )
-    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
-#endif
-   
-    glEnable(GL_LIGHTING);
-    GLfloat light_direction[] = { 0.0 , 0.0 , 1.0 };
-    GLfloat materialDiffuse[] = { 1.0 , 1.0 , 1.0 , 1.0};
-    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, light_direction);
-    glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
-    glEnable(GL_LIGHT0);
-    glEnable(GL_NORMALIZE);
-
-    if( LeavingBytes.hasElements() && EnteringBytes.hasElements())
-       GLInitSlides();//we already have uninitialized slides, let's initialize 
-
-    if( pTransition && pTransition->mnRequiredGLVersion <= cnGLVersion )
-        pTransition->prepare( GLleavingSlide, GLenteringSlide );
-
-    return true;
-}
-
-void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
-                                     const uno::Reference< rendering::XBitmap >& xEnteringSlide )
-{
-    osl::MutexGuard const guard( m_aMutex );
-
-    if (isDisposed())
-        return;
-        
-    mxLeavingBitmap.set( xLeavingSlide , UNO_QUERY_THROW );
-    mxEnteringBitmap.set( xEnteringSlide , UNO_QUERY_THROW );
-    Reference< XFastPropertySet > xLeavingSet( xLeavingSlide , UNO_QUERY );
-    Reference< XFastPropertySet > xEnteringSet( xEnteringSlide , UNO_QUERY );
-
-    geometry::IntegerRectangle2D SlideRect;
-    SlideSize = mxLeavingBitmap->getSize();
-    SlideRect.X1 = 0;
-    SlideRect.X2 = SlideSize.Width;
-    SlideRect.Y1 = 0;
-    SlideRect.Y2 = SlideSize.Height;
-
-    OSL_TRACE("leaving bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
-    SlideSize = mxEnteringBitmap->getSize();
-    OSL_TRACE("entering bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
-
-#ifdef UNX
-    unx::glXWaitGL();
-    XSync(GLWin.dpy, false);
-#endif
-
-#ifdef DEBUG
-    t1 = microsec_clock::local_time();
-#endif
-
-    mbUseLeavingPixmap = false;
-    mbUseEnteringPixmap = false;
-
-#ifdef UNX
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-
-    if( mnGLXVersion >= 1.2999 && mbTextureFromPixmap && xLeavingSet.is() && xEnteringSet.is() && mbHasTFPVisual ) {
-    Sequence< Any > leaveArgs;
-    Sequence< Any > enterArgs;
-    if( (xLeavingSet->getFastPropertyValue( 1 ) >>= leaveArgs) &&
-        (xEnteringSet->getFastPropertyValue( 1 ) >>= enterArgs) ) {
-        OSL_TRACE ("pixmaps available");
-
-        sal_Int32 depth;
-
-        leaveArgs[0] >>= mbFreeLeavingPixmap;
-        enterArgs[0] >>= mbFreeEnteringPixmap;
-        leaveArgs[1] >>= maLeavingPixmap;
-        enterArgs[1] >>= maEnteringPixmap;
-        leaveArgs[2] >>= depth;
-
-        int pixmapAttribs[] = { GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
-                    GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGB_EXT,
-                    GLX_MIPMAP_TEXTURE_EXT, True,
-                    None };
-
-
-        // sync so that we possibly get an pending XError, before we set our handler.
-        // this way we will not miss any error from other code
-        unx::glXWaitGL();
-        XSync(GLWin.dpy, false);
-
-        int (*oldHandler)(unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/);
-
-        // replace error handler temporarily
-        oldHandler = unx::XSetErrorHandler( oglErrorHandler );
-
-        errorTriggered = false;
-        LeavingPixmap = glXCreatePixmap( GLWin.dpy, GLWin.fbc, maLeavingPixmap, pixmapAttribs );
-
-        // sync so that we possibly get an XError
-        unx::glXWaitGL();
-        XSync(GLWin.dpy, false);
-
-        if( !errorTriggered )
-        mbUseLeavingPixmap = true;
-        else {
-        OSL_TRACE("XError triggered");
-        if( mbFreeLeavingPixmap ) {
-            unx::XFreePixmap( GLWin.dpy, maLeavingPixmap );
-            mbFreeLeavingPixmap = false;
-        }
-        errorTriggered = false;
-        }
-          
-        EnteringPixmap = glXCreatePixmap( GLWin.dpy, GLWin.fbc, maEnteringPixmap, pixmapAttribs );
-
-        // sync so that we possibly get an XError
-        unx::glXWaitGL();
-        XSync(GLWin.dpy, false);
-
-        OSL_TRACE("created glx pixmap %p and %p depth: %d", LeavingPixmap, EnteringPixmap, depth);
-        if( !errorTriggered )
-        mbUseEnteringPixmap = true;
-        else {
-        OSL_TRACE("XError triggered");
-        if( mbFreeEnteringPixmap ) {
-            unx::XFreePixmap( GLWin.dpy, maEnteringPixmap );
-            mbFreeEnteringPixmap = false;
-        }
-        }
-
-        // restore the error handler
-        unx::XSetErrorHandler( oldHandler );
-    }
-    }
-
-#endif
-#endif
-    if( !mbUseLeavingPixmap )
-    LeavingBytes = mxLeavingBitmap->getData(SlideBitmapLayout,SlideRect);
-    if( !mbUseEnteringPixmap )
-    EnteringBytes = mxEnteringBitmap->getData(SlideBitmapLayout,SlideRect);
-
-// TODO    
-#ifdef UNX
-    if(GLWin.ctx)//if we have a rendering context, let's init the slides
-#endif
-    GLInitSlides();
-
-    OSL_ENSURE(SlideBitmapLayout.PlaneStride == 0,"only handle no plane stride now");
-
-#ifdef UNX
-    /* flush & sync */
-    unx::glXWaitGL();
-    XSync( GLWin.dpy, false );
-
-    // synchronized X still gives us much smoother play
-    // I suspect some issues in above code in slideshow
-    // synchronize whole transition for now
-    XSynchronize( GLWin.dpy, true );
-    mbRestoreSync = true;
-#endif
-}
-
-void OGLTransitionerImpl::createTexture( unsigned int* texID,
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-                     unx::GLXPixmap pixmap,
-                     bool usePixmap,
-#endif
-                     bool useMipmap,
-                     uno::Sequence<sal_Int8>& data,
-                     const OGLFormat* pFormat )
-{
-    glDeleteTextures( 1, texID );
-    glGenTextures( 1, texID );
-    glBindTexture( GL_TEXTURE_2D, *texID );
-    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
-    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
-
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    unx::PFNGLXBINDTEXIMAGEEXTPROC myglXBindTexImageEXT = (unx::PFNGLXBINDTEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXBindTexImageEXT" );
-
-    if( usePixmap ) {
-      if( mbGenerateMipmap )
-          glTexParameteri( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS, True);
-      myglXBindTexImageEXT (GLWin.dpy, pixmap, GLX_FRONT_LEFT_EXT, NULL);
-      if( mbGenerateMipmap && useMipmap ) {
-          OSL_TRACE("use mipmaps");
-          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
-          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
-      } else {
-          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
-          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
-      }
-    } else {
-#endif
-    if( !pFormat )
-    {
-        // force-convert color to ARGB8888 int color space  
-        uno::Sequence<sal_Int8> tempBytes(
-            SlideBitmapLayout.ColorSpace->convertToIntegerColorSpace(
-                data,
-                canvas::tools::getStdColorSpace()));
-        gluBuild2DMipmaps(GL_TEXTURE_2D, 
-                          4, 
-                          SlideSize.Width, 
-                          SlideSize.Height, 
-                          GL_RGBA, 
-                          GL_UNSIGNED_BYTE,
-                          &tempBytes[0]);
-    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
-
-        //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
-    GLfloat largest_supported_anisotropy;
-    glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy);
-    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy);
-    } else {
-    if( pTransition && !cbBrokenTexturesATI && !useMipmap) {
-        glTexImage2D( GL_TEXTURE_2D, 0, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, 0, pFormat->eFormat, pFormat->eType, &data[0] );
-        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
-        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
-    } else {
-        gluBuild2DMipmaps( GL_TEXTURE_2D, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, pFormat->eFormat, pFormat->eType, &data[0] );
-        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR ); //TRILINEAR FILTERING
-
-        //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
-        GLfloat largest_supported_anisotropy;
-        glGetFloatv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy );
-        glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy );
-    }
-    }
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    }
-#endif
-    OSL_ENSURE(glIsTexture(*texID), "Can't generate Leaving slide textures in OpenGL");
-}
-
-void OGLTransitionerImpl::prepareEnvironment()
-{
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    double EyePos(10.0);
-    double RealF(1.0);
-    double RealN(-1.0);
-    double RealL(-1.0);
-    double RealR(1.0);
-    double RealB(-1.0);
-    double RealT(1.0);
-    double ClipN(EyePos+5.0*RealN);
-    double ClipF(EyePos+15.0*RealF);
-    double ClipL(RealL*8.0);
-    double ClipR(RealR*8.0);
-    double ClipB(RealB*8.0);
-    double ClipT(RealT*8.0);
-    //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
-    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ),
-              1.0 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ),
-              1.0 );
-    glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
-    glTranslated(0,0,-EyePos);
-}
-
-const OGLFormat* OGLTransitionerImpl::chooseFormats()
-{
-    const OGLFormat* pDetectedFormat=NULL;
-    uno::Reference<rendering::XIntegerBitmapColorSpace> xIntColorSpace(
-        SlideBitmapLayout.ColorSpace);
-
-    if( (xIntColorSpace->getType() == rendering::ColorSpaceType::RGB ||
-         xIntColorSpace->getType() == rendering::ColorSpaceType::SRGB) )
-    {
-        /* table for canvas->OGL format mapping. outer index is number
-           of color components (0:3, 1:4), then comes bits per pixel
-           (0:16, 1:24, 2:32), then channel ordering: (0:rgba, 1:bgra,
-           2:argb, 3:abgr)
-         */
-        static const OGLFormat lcl_RGB24[] = 
-        {
-            // 24 bit RGB
-            {3, GL_BGR, GL_UNSIGNED_BYTE},
-            {3, GL_RGB, GL_UNSIGNED_BYTE},
-            {3, GL_BGR, GL_UNSIGNED_BYTE},
-            {3, GL_RGB, GL_UNSIGNED_BYTE}
-        };
-
-#if defined(GL_VERSION_1_2) && defined(GLU_VERSION_1_3)
-        // more format constants available
-        static const OGLFormat lcl_RGB16[] = 
-        {
-            // 16 bit RGB
-            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
-            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},
-            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
-            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5}
-        };
-
-        static const OGLFormat lcl_ARGB16_4[] = 
-        {
-            // 16 bit ARGB
-            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
-            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
-            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4},
-            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4}
-        };
-
-        static const OGLFormat lcl_ARGB16_5[] = 
-        {
-            // 16 bit ARGB
-            {4, GL_RGBA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
-            {4, GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
-            {4, GL_BGRA, GL_UNSIGNED_SHORT_5_5_5_1},
-            {4, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1}
-        };
-
-        static const OGLFormat lcl_ARGB32[] = 
-        {
-            // 32 bit ARGB
-            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV},
-            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV},
-            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8},
-            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8}
-        };
-
-        const uno::Sequence<sal_Int8> aComponentTags(
-            xIntColorSpace->getComponentTags());
-        const uno::Sequence<sal_Int32> aComponentBitcounts(
-            xIntColorSpace->getComponentBitCounts());
-        const sal_Int32 nNumComponents( aComponentBitcounts.getLength() );
-        const sal_Int32 nBitsPerPixel( xIntColorSpace->getBitsPerPixel() );
-
-        // supported component ordering?
-        const int nComponentOrderIndex(
-            calcComponentOrderIndex(aComponentTags));
-        if( nComponentOrderIndex != -1 ) 
-        {
-            switch( nBitsPerPixel )
-            {
-                case 16:
-                    if( nNumComponents == 3 )
-                    {
-                        pDetectedFormat = &lcl_RGB16[nComponentOrderIndex];
-                    }
-                    else if( nNumComponents == 4 )
-                    {
-                        if( aComponentBitcounts[1] == 4 )
-                        {
-                            pDetectedFormat = &lcl_ARGB16_4[nComponentOrderIndex];
-                        }
-                        else if( aComponentBitcounts[1] == 5 )
-                        {
-                            pDetectedFormat = &lcl_ARGB16_5[nComponentOrderIndex];
-                        }
-                    }
-                    break;
-                case 24:
-                    if( nNumComponents == 3 )
-                    {
-                        pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
-                    }
-                    break;
-                case 32:
-                    pDetectedFormat = &lcl_ARGB32[nComponentOrderIndex];
-                    break;
-            }
-        }
-#else
-        const uno::Sequence<sal_Int8> aComponentTags(
-            xIntColorSpace->getComponentTags());
-        const int nComponentOrderIndex(calcComponentOrderIndex(aComponentTags));
-        if( aComponentTags.getLength() == 3 && 
-            nComponentOrderIndex != -1 && 
-            xIntColorSpace->getBitsPerPixel() == 24 )
-        {
-            pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
-        }
-#endif
-    }
-
-    return pDetectedFormat;
-}
-
-void OGLTransitionerImpl::GLInitSlides()
-{
-    osl::MutexGuard const guard( m_aMutex );
-
-    if (isDisposed() || pTransition->mnRequiredGLVersion > cnGLVersion)
-        return;
-
-    prepareEnvironment();
-
-    const OGLFormat* pFormat = NULL;
-    if( !mbUseLeavingPixmap || !mbUseEnteringPixmap )
-    pFormat = chooseFormats();
-
-    createTexture( &GLleavingSlide,
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-           LeavingPixmap,
-           mbUseLeavingPixmap,
-#endif
-           pTransition->mbUseMipMapLeaving,
-           LeavingBytes,
-           pFormat );
-
-    createTexture( &GLenteringSlide,
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-           EnteringPixmap,
-           mbUseEnteringPixmap,
-#endif
-           pTransition->mbUseMipMapEntering,
-           EnteringBytes,
-           pFormat );
-
-#ifdef UNX
-    unx::glXWaitGL();
-    XSync(GLWin.dpy, false);
-#endif
-
-#ifdef DEBUG
-    t2 = microsec_clock::local_time();
-    OSL_TRACE("textures created in: %s", to_simple_string( t2 - t1 ).c_str());
-#endif
-}
-
-void SAL_CALL OGLTransitionerImpl::update( double nTime ) throw (uno::RuntimeException)
-{
-#ifdef DEBUG
-    frame_count ++;
-    t3 = microsec_clock::local_time();
-    if( frame_count == 1 ) {
-    t5 = t3;
-    total_update = seconds (0);
-    }
-#endif
-    osl::MutexGuard const guard( m_aMutex );
-
-    if (isDisposed() || !cbGLXPresent || pTransition->mnRequiredGLVersion > cnGLVersion)
-        return;
-
-#ifdef WNT
-    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
-#endif
-#ifdef UNX
-    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
-#endif
-
-    glEnable(GL_DEPTH_TEST);
-    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-    if(pTransition)
-    pTransition->display( nTime, GLleavingSlide, GLenteringSlide, 
-                              SlideSize.Width, SlideSize.Height,
-                              static_cast<double>(GLWin.Width),
-                              static_cast<double>(GLWin.Height) );
-
-#if defined( WNT ) 
-    SwapBuffers(GLWin.hDC);
-#elif defined( UNX )
-    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
-#endif
-    if( pWindow )
-        pWindow->Show();
-
-#ifdef UNX
-    /* flush & sync */
-    unx::glXWaitGL();
-    XSync( GLWin.dpy, false );
-#endif
-
-#ifdef DEBUG
-    t4 = microsec_clock::local_time();
-
-    OSL_TRACE("update time: %f", nTime);
-    OSL_TRACE("update took: %s", to_simple_string( t4 - t3 ).c_str());
-    total_update += (t4 - t3);
-#endif
-}
-
-void SAL_CALL OGLTransitionerImpl::viewChanged( const Reference< presentation::XSlideShowView >& rView,
-                        const Reference< rendering::XBitmap >& rLeavingBitmap,
-                        const Reference< rendering::XBitmap >& rEnteringBitmap )
-    throw (uno::RuntimeException)
-{
-    OSL_TRACE("transitioner: view changed");
-
-    disposeTextures();
-    disposeContextAndWindow();
-
-    initWindowFromSlideShowView( rView );
-    setSlides( rLeavingBitmap, rEnteringBitmap );
-}
-
-void OGLTransitionerImpl::disposeContextAndWindow()
-{
-#if defined( WNT )
-    if (GLWin.hRC)
-    {
-    wglMakeCurrent( GLWin.hDC, 0 );		// kill Device Context
-    wglDeleteContext( GLWin.hRC );		// Kill Render Context
-    ReleaseDC( GLWin.hWnd, GLWin.hDC );         // Release Window
-    }
-#elif defined( UNX )
-    if(GLWin.ctx)
-    {
-    glXMakeCurrent(GLWin.dpy, None, NULL);
-    if( glGetError() != GL_NO_ERROR ) {
-        OSL_TRACE("glError: %s", (char *)gluErrorString(glGetError()));
-    }
-    glXDestroyContext(GLWin.dpy, GLWin.ctx);
-    GLWin.ctx = NULL;
-    }
-#endif
-    if( pWindow ) {
-    delete pWindow;
-    pWindow = NULL;
-    GLWin.win = 0;
-    }
-}
-
-void OGLTransitionerImpl::disposeTextures()
-{
-#ifdef WNT
-    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
-#endif
-#ifdef UNX
-    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
-#endif
-
-#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
-    unx::PFNGLXRELEASETEXIMAGEEXTPROC myglXReleaseTexImageEXT = (unx::PFNGLXRELEASETEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXReleaseTexImageEXT" );
-    if( mbUseLeavingPixmap ) {
-
-    myglXReleaseTexImageEXT( GLWin.dpy, LeavingPixmap, GLX_FRONT_LEFT_EXT );
-    glXDestroyGLXPixmap( GLWin.dpy, LeavingPixmap );
-    LeavingPixmap = 0;
-    if( mbFreeLeavingPixmap ) {
-        unx::XFreePixmap( GLWin.dpy, maLeavingPixmap );
-        mbFreeLeavingPixmap = false;
-        maLeavingPixmap = 0;
-    }
-    }
-    if( mbUseEnteringPixmap ) {
-    myglXReleaseTexImageEXT( GLWin.dpy, EnteringPixmap, GLX_FRONT_LEFT_EXT );
-    glXDestroyGLXPixmap( GLWin.dpy, EnteringPixmap );
-    EnteringPixmap = 0;
-    if( mbFreeEnteringPixmap ) {
-        unx::XFreePixmap( GLWin.dpy, maEnteringPixmap );
-        mbFreeEnteringPixmap = false;
-        maEnteringPixmap = 0;
-    }
-    }
-#endif
-
-    if( !mbUseLeavingPixmap ) {
-    glDeleteTextures(1,&GLleavingSlide);
-    GLleavingSlide = 0;
-    }
-    if( !mbUseEnteringPixmap ) {
-    glDeleteTextures(1,&GLenteringSlide);
-    GLleavingSlide = 0;
-    }
-
-    mbUseLeavingPixmap = false;
-    mbUseEnteringPixmap = false;
-}
-
-// we are about to be disposed (someone call dispose() on us)
-void OGLTransitionerImpl::disposing()
-{
-    osl::MutexGuard const guard( m_aMutex );
-
-#ifdef DEBUG
-    OSL_TRACE("dispose %p\n", this);
-    if( frame_count ) {
-    t6 = microsec_clock::local_time();
-    time_duration duration = t6 - t5;
-    OSL_TRACE("whole transition (frames: %d) took: %s fps: %f time spent in updates: %s percentage of transition time: %f%%",
-          frame_count, to_simple_string( duration ).c_str(),
-          ((double)frame_count*1000000000.0)/duration.total_nanoseconds(),
-          to_simple_string( total_update ).c_str(),
-          100*(((double)total_update.total_nanoseconds())/((double)duration.total_nanoseconds()))
-        );
-    }
-#endif
-
-    if( pWindow ) {
-
-    disposeTextures();
-
-    if (pTransition)
-        pTransition->finish();
-
-#ifdef UNX
-    if( mbRestoreSync ) {
-        // try to reestablish synchronize state
-        char* sal_synchronize = getenv("SAL_SYNCHRONIZE");
-        XSynchronize( GLWin.dpy, sal_synchronize && *sal_synchronize == '1' );
-    }
-#endif
-
-    disposeContextAndWindow();
-    }
-
-    if (pTransition)
-    delete pTransition;
-
-    mxLeavingBitmap.clear();
-    mxEnteringBitmap.clear();
-    mxView.clear();
-}
-
-OGLTransitionerImpl::OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition) : 
-    OGLTransitionerImplBase(m_aMutex), 
-    GLWin(),
-    GLleavingSlide( 0 ), 
-    GLenteringSlide( 0 ), 
-    pWindow( NULL ), 
-    mxView(),
-    EnteringBytes(),
-    LeavingBytes(),
-    mbRestoreSync( false ),
-    mbUseLeavingPixmap( false ),
-    mbUseEnteringPixmap( false ),
-    SlideBitmapLayout(),
-    SlideSize(),
-    pTransition(pOGLTransition)
-{
-#if defined( WNT )
-    GLWin.hWnd = 0;
-#elif defined( UNX )
-    GLWin.ctx = 0;
-#endif
-
-    DBG(frame_count = 0);
-}
-
-typedef cppu::WeakComponentImplHelper1<presentation::XTransitionFactory> OGLTransitionFactoryImplBase;
-
-class OGLTransitionFactoryImpl : private cppu::BaseMutex, public OGLTransitionFactoryImplBase
-{
-public:
-    explicit OGLTransitionFactoryImpl( const uno::Reference< uno::XComponentContext >& ) :
-        OGLTransitionFactoryImplBase(m_aMutex)
-    {}
-
-    // XTransitionFactory
-    virtual ::sal_Bool SAL_CALL hasTransition( ::sal_Int16 transitionType, ::sal_Int16 transitionSubType ) throw (uno::RuntimeException)
-    {
-        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
-            switch( transitionSubType )
-                {
-                case animations::TransitionSubType::ACROSS:
-                case animations::TransitionSubType::CORNERSOUT:
-                case animations::TransitionSubType::CIRCLE:
-                case animations::TransitionSubType::FANOUTHORIZONTAL:
-                case animations::TransitionSubType::CORNERSIN:  
-                case animations::TransitionSubType::LEFTTORIGHT:
-                case animations::TransitionSubType::TOPTOBOTTOM:
-                case animations::TransitionSubType::TOPRIGHT:
-                case animations::TransitionSubType::TOPLEFT:
-                case animations::TransitionSubType::BOTTOMRIGHT:
-                case animations::TransitionSubType::BOTTOMLEFT:
-                case animations::TransitionSubType::TOPCENTER:
-                case animations::TransitionSubType::RIGHTCENTER:
-                case animations::TransitionSubType::BOTTOMCENTER:
-                    return sal_True;
-
-                default:
-                    return sal_False;
-                }
-        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
-            return sal_True;
-        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
-            return sal_True;
-        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
-            return sal_True;
-        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
-            return sal_True;
-        } else
-            return sal_False;
-    }
-
-    virtual uno::Reference< presentation::XTransition > SAL_CALL createTransition( 
-        ::sal_Int16                                           transitionType, 
-        ::sal_Int16                                           transitionSubType, 
-        const uno::Reference< presentation::XSlideShowView >& view, 
-        const uno::Reference< rendering::XBitmap >&           leavingBitmap, 
-        const uno::Reference< rendering::XBitmap >&           enteringBitmap )
-    throw (uno::RuntimeException)
-    {
-        if( !hasTransition( transitionType, transitionSubType ) )
-            return uno::Reference< presentation::XTransition >();
-
-        bool bGLXPresent = OGLTransitionerImpl::initialize( view );
-
-        if( OGLTransitionerImpl::cbMesa && (
-            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) ||
-            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) ||
-            ( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) ) )
-            return uno::Reference< presentation::XTransition >();
-            
-
-        OGLTransitionImpl* pTransition = NULL;
-
-        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
-            pTransition = new OGLTransitionImpl();
-            switch( transitionSubType )
-                {
-                case animations::TransitionSubType::ACROSS:
-                    pTransition->makeNByMTileFlip(8,6);
-                    break;   
-                case animations::TransitionSubType::CORNERSOUT:
-                    pTransition->makeOutsideCubeFaceToLeft();
-                    break;            
-                case animations::TransitionSubType::CIRCLE:
-                    pTransition->makeRevolvingCircles(8,128);
-                    break;
-                case animations::TransitionSubType::FANOUTHORIZONTAL:
-                    pTransition->makeHelix(20);
-                    break;
-                case animations::TransitionSubType::CORNERSIN:  
-                    pTransition->makeInsideCubeFaceToLeft();
-                    break;
-                case animations::TransitionSubType::LEFTTORIGHT:
-                    pTransition->makeFallLeaving();
-                    break;
-                case animations::TransitionSubType::TOPTOBOTTOM:
-                    pTransition->makeTurnAround();
-                    break;
-                case animations::TransitionSubType::TOPRIGHT:
-                    pTransition->makeTurnDown();
-                    break;
-                case animations::TransitionSubType::TOPLEFT:
-                    pTransition->makeIris();
-                    break;
-                case animations::TransitionSubType::BOTTOMRIGHT:
-                    pTransition->makeRochade();
-                    break;
-                case animations::TransitionSubType::BOTTOMLEFT:
-                    pTransition->makeVenetianBlinds( true, 8 );
-                    break;
-                case animations::TransitionSubType::TOPCENTER:
-                    pTransition->makeVenetianBlinds( false, 6 );
-                    break;
-                case animations::TransitionSubType::RIGHTCENTER:
-                    pTransition->makeStatic();
-                    break;
-                case animations::TransitionSubType::BOTTOMCENTER:
-                    pTransition->makeDissolve();
-                    break;
-                }
-        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
-            pTransition = new OGLTransitionImpl();
-            pTransition->makeFadeSmoothly();
-        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
-            pTransition = new OGLTransitionImpl();
-            pTransition->makeFadeThroughBlack();
-        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
-            pTransition = new OGLTransitionImpl();
-            pTransition->makeDiamond();
-        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
-            pTransition = new OGLTransitionImpl();
-            pTransition->makeNewsflash();
-        }
-
-        rtl::Reference<OGLTransitionerImpl> xRes(
-            new OGLTransitionerImpl(pTransition) );
-        if( bGLXPresent ) {
-            if( !xRes->initWindowFromSlideShowView(view))
-                return uno::Reference< presentation::XTransition >();
-            xRes->setSlides(leavingBitmap,enteringBitmap);
-        }
-
-        return uno::Reference<presentation::XTransition>(xRes.get());
-    }
-};
-
-}
-
-namespace sdecl = comphelper::service_decl;
-#if defined (__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ <= 3)
- sdecl::class_<OGLTransitionFactoryImpl> serviceImpl;
- const sdecl::ServiceDecl OGLTransitionFactoryDecl(
-     serviceImpl,
-#else
- const sdecl::ServiceDecl OGLTransitionFactoryDecl(
-     sdecl::class_<OGLTransitionFactoryImpl>(),
-#endif
-    "com.sun.star.comp.presentation.OGLTransitionFactory",
-    "com.sun.star.presentation.TransitionFactory" );
-
-// The C shared lib entry points
-COMPHELPER_SERVICEDECL_EXPORTS1(OGLTransitionFactoryDecl)
diff --git slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.h slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.h
new file mode 100644
index 0000000..2ec5be5
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.h
@@ -0,0 +1,94 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_OGLTRANS_SHADERS_HXX_
+#define INCLUDED_OGLTRANS_SHADERS_HXX_
+
+/* FIXME : Really needed ? */
+#define GL_GLEXT_PROTOTYPES 1
+
+/* Required Includes */
+#import <Cocoa/Cocoa.h>
+#import <OpenGL/gl.h>
+#import <OpenGL/glext.h>
+#import <OpenGL/glu.h>
+#import <OpenGL/OpenGL.h>
+#import <GLUT/glut.h>
+
+/* Parameter */
+typedef struct _Parameter {
+	float current [4];
+	float min     [4];
+	float max     [4];
+	float delta   [4];
+	
+} Parameter;
+
+/* Macros */
+#define PARAMETER_CURRENT(p)    (p.current)
+#define PARAMETER_ANIMATE(p)    ({ int i; for (i = 0; i < 4; i ++) { \
+											p.current[i] += p.delta[i]; \
+											if ((p.current[i] < p.min[i]) || (p.current[i] > p.max[i])) \
+												p.delta[i] = -p.delta[i]; } } )
+												
+/* OGLShaders base class */
+@interface OGLShaders : NSObject 
+{
+    BOOL initialised;
+    GLhandleARB vertex_shader;
+    GLhandleARB fragment_shader;
+    GLhandleARB program_object;
+    GLUquadric *quadric;
+    BOOL gpuProcessingInit;
+    BOOL gpuProcessing;
+}
+- (id) init;
+- (void) initLazy;
+- (void) dealloc;
+- (NSString *) name;
+- (NSString *) descriptionFilename;
+- (unsigned int) loadVertexShader: (NSString *) vertexString fragmentShader: (NSString *) fragmentString;
+
+ /* if!initialized -> initLazy */
+- (void) renderFrame;
+
+/* Check whether software rasterization or software vertex processing will be used */
+- (BOOL) reflect;
+
+@end
+
+
+// Utility Functions
+
+int NextHighestPowerOf2(int n);
+void CopyFramebufferToTexture(GLuint texture);
+NSBitmapImageRep *LoadImage(NSString *path, int shouldFlipVertical);
+
+#endif
diff --git slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.m slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.m
new file mode 100644
index 0000000..73c76ce
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/OGLTrans_Shaders_MACOSX.m
@@ -0,0 +1,236 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+//#include <osl/diagnose.hxx>
+
+#import "OGLTrans_Shaders_MACOSX.h"
+
+
+@implementation OGLShaders
+
+- (id) init
+{
+  [super init];
+  gpuProcessingInit = NO;
+  return self;
+}
+
+- (void) initLazy
+{
+  /* Subclass should put initialisation code that can be performaned
+     lazily (on first frame render) here */
+  initialised = TRUE;
+  
+  /* Create a GLU quadric, used for rendering certain geometry */
+  quadric = gluNewQuadric();
+  gluQuadricDrawStyle(quadric, GLU_FILL);
+  gluQuadricNormals(quadric, GL_SMOOTH);
+  gluQuadricTexture(quadric, GL_TRUE);
+
+}
+
+- (void) dealloc
+{
+  /* Free the GLU quadric */
+  if (quadric)
+    gluDeleteQuadric(quadric);
+
+  [super dealloc];
+}
+
+- (NSString *) name
+{
+  return @"Unnamed OGLShaders";
+}
+
+- (NSString *) descriptionFilename
+{
+  return NULL;
+}
+
+- (unsigned int) loadVertexShader: (NSString *) vertexString fragmentShader: (NSString *) fragmentString
+{
+  const GLcharARB *vertex_string;
+  const GLcharARB *fragment_string;
+  GLint vertex_compiled;
+  GLint fragment_compiled;
+  GLint linked;
+  
+  /* Delete any existing program object */
+  if (program_object) {
+    glDeleteObjectARB(program_object);
+    program_object = NULL;
+  }
+  
+  /* Load and compile both shaders */
+  if (vertexString) {
+    vertex_shader   = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+    vertex_string   = (GLcharARB *) [vertexString cString];
+    glShaderSourceARB(vertex_shader, 1, &vertex_string, NULL);
+    glCompileShaderARB(vertex_shader);
+    glGetObjectParameterivARB(vertex_shader, GL_OBJECT_COMPILE_STATUS_ARB, &vertex_compiled);
+    /* TODO - Get info log */
+  } else {
+    vertex_shader   = NULL;
+    vertex_compiled = 1;
+  }
+    
+  if (fragmentString) {
+    fragment_shader   = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+    fragment_string   = [fragmentString cString];
+    glShaderSourceARB(fragment_shader, 1, &fragment_string, NULL);
+    glCompileShaderARB(fragment_shader);
+    glGetObjectParameterivARB(fragment_shader, GL_OBJECT_COMPILE_STATUS_ARB, &fragment_compiled);
+    /* TODO - Get info log */
+  } else {
+    fragment_shader   = NULL;
+    fragment_compiled = 1;
+  }
+  
+  /* Ensure both shaders compiled */
+  if (!vertex_compiled || !fragment_compiled) {
+    if (vertex_shader) {
+      glDeleteObjectARB(vertex_shader);
+      vertex_shader   = NULL;
+    }
+    if (fragment_shader) {
+      glDeleteObjectARB(fragment_shader);
+      fragment_shader = NULL;
+    }
+    return 1;
+  }
+    
+  /* Create a program object and link both shaders */
+  program_object = glCreateProgramObjectARB();
+  if (vertex_shader != NULL)
+  {
+    glAttachObjectARB(program_object, vertex_shader);
+    glDeleteObjectARB(vertex_shader);   /* Release */
+  }
+  if (fragment_shader != NULL)
+  {
+    glAttachObjectARB(program_object, fragment_shader);
+    glDeleteObjectARB(fragment_shader); /* Release */
+  }
+  glLinkProgramARB(program_object);
+  glGetObjectParameterivARB(program_object, GL_OBJECT_LINK_STATUS_ARB, &linked);
+  /* TODO - Get info log */
+  
+  if (!linked) {
+    glDeleteObjectARB(program_object);
+    program_object = NULL;
+    return 1;
+  }
+  
+  return 0;
+}
+
+- (void) renderFrame
+{
+  if (!initialised)
+    [self initLazy];
+}
+
+- (BOOL) reflect
+{
+  if(!gpuProcessingInit)
+  {
+    /* Check if this will fall back to software rasterization or
+       software vertex processing and don't reflect if it is. */
+
+    GLint fragmentGPUProcessing, vertexGPUProcessing;
+    gpuProcessingInit = YES;
+
+    glPushAttrib(GL_VIEWPORT_BIT);
+    glViewport(0,0,0,0);
+    glPushMatrix();
+    [self renderFrame];
+    glPopMatrix();
+    CGLGetParameter(CGLGetCurrentContext(), kCGLCPGPUFragmentProcessing, &fragmentGPUProcessing);
+    CGLGetParameter(CGLGetCurrentContext(), kCGLCPGPUVertexProcessing, &vertexGPUProcessing);
+    gpuProcessing = (fragmentGPUProcessing && vertexGPUProcessing) ? YES : NO;
+    glPopAttrib();
+  }
+
+  return gpuProcessing;
+}
+
+@end
+
+
+// Utility Functions
+
+int NextHighestPowerOf2(int n)
+{
+  n--;
+  n |= n >> 1; 
+  n |= n >> 2;
+  n |= n >> 4;
+  n |= n >> 8;
+  n |= n >> 16;
+  n++;
+  return n;
+}
+
+void CopyFramebufferToTexture(GLuint texture)
+{
+  GLint viewport[4];
+  glGetIntegerv(GL_VIEWPORT, viewport);
+  glBindTexture(GL_TEXTURE_2D, texture);
+  glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, viewport[0], viewport[1], NextHighestPowerOf2(viewport[2]), NextHighestPowerOf2(viewport[3]), 0);
+}
+
+NSBitmapImageRep *LoadImage(NSString *path, int shouldFlipVertical)
+{
+  NSBitmapImageRep *bitmapimagerep;
+  NSImage *image;
+  image = [[[NSImage alloc] initWithContentsOfFile: path] autorelease];
+  bitmapimagerep = [[NSBitmapImageRep alloc] initWithData:[image TIFFRepresentation]];
+  
+  if (shouldFlipVertical)
+  {
+    int bytesPerRow, lowRow, highRow;
+    unsigned char *pixelData, *swapRow;
+    
+    bytesPerRow = [bitmapimagerep bytesPerRow];
+    pixelData = [bitmapimagerep bitmapData];
+
+    swapRow = (unsigned char *)malloc(bytesPerRow);
+    for (lowRow = 0, highRow = [bitmapimagerep pixelsHigh]-1; lowRow < highRow; lowRow++, highRow--)
+    {
+      memcpy(swapRow, &pixelData[lowRow*bytesPerRow], bytesPerRow);
+      memcpy(&pixelData[lowRow*bytesPerRow], &pixelData[highRow*bytesPerRow], bytesPerRow);
+      memcpy(&pixelData[highRow*bytesPerRow], swapRow, bytesPerRow);
+    }
+    free(swapRow);
+  }
+
+  return bitmapimagerep;
+}
diff --git slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl.hxx slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl.hxx
new file mode 100644
index 0000000..316f683
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl.hxx
@@ -0,0 +1,501 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionImpl.hxx,v $
+ * $Revision: 1.5.12.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+#define INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+
+#include <basegfx/vector/b2dvector.hxx>
+#include <basegfx/vector/b3dvector.hxx>
+
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+
+#include <OpenGL/gl.h>
+#include <vector>
+
+using namespace std;
+
+class Primitive;
+class Operation;
+class SceneObject;
+
+
+/** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
+
+	This class is capable of making itself into many difference transitions. It holds Primitives and Operations on those primitives.
+*/
+class OGLTransitionImpl
+{
+public:
+    OGLTransitionImpl() :
+        mbUseMipMapLeaving( true ),
+        mbUseMipMapEntering( true ),
+        mnRequiredGLVersion( 1.0 ),
+        maLeavingSlidePrimitives(),
+        maEnteringSlidePrimitives(),
+        maSceneObjects(),
+        mbReflectSlides( false ),
+        mVertexObject( 0 ),
+        mFragmentObject( 0 ),
+        mProgramObject( 0 ),
+        maHelperTexture( 0 ),
+        mmPrepare( NULL ),
+        mmPrepareTransition( NULL ),
+        mmClearTransition( NULL ),
+        mmDisplaySlides( NULL )
+    {}
+
+    ~OGLTransitionImpl();
+    
+    void prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
+    void finish();
+
+    void makeOutsideCubeFaceToLeft();
+    void makeInsideCubeFaceToLeft();
+    void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
+    void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
+    void makeHelix( ::sal_uInt16 nRows );
+    void makeFallLeaving();
+    void makeTurnAround();
+    void makeTurnDown();
+    void makeIris();
+    void makeRochade();
+    void makeVenetianBlinds( bool vertical, int parts );
+    void makeStatic();
+    void makeDissolve();
+    void makeNewsflash();
+
+    /** 2D replacements
+     */
+    void makeDiamond();
+    void makeFadeSmoothly();
+    void makeFadeThroughBlack();
+
+    /** Whether to use mipmaping for slides textures
+     */
+    bool mbUseMipMapLeaving;
+    bool mbUseMipMapEntering;
+
+    /** which GL version does the transition require
+     */
+    float mnRequiredGLVersion;
+
+private:
+    /** clears all the primitives and operations
+	*/
+    void clear();
+    
+    /** All the primitives that use the leaving slide texture
+	*/
+    vector<Primitive> maLeavingSlidePrimitives;
+    
+    /** All the primitives that use the leaving slide texture
+	*/
+    vector<Primitive> maEnteringSlidePrimitives;
+    
+    /** All the surrounding scene objects
+	*/
+    vector<SceneObject*> maSceneObjects;
+
+    /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+	*/
+	vector<Operation*> OverallOperations;
+
+	/** Whether to reflect slides, the reflection happens on flat surface beneath the slides.
+	 ** Now it only works with slides which keep their rectangular shape together.
+	 */
+	bool mbReflectSlides;
+
+	/** GLSL objects, shaders and program
+	 */
+	GLuint mVertexObject, mFragmentObject, mProgramObject;
+
+	/** various data */
+	GLuint maHelperTexture;
+
+	/** When this method is not NULL, it is called in display method to prepare the slides, scene, etc.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmPrepare)( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
+
+	/** When this method is not NULL, it is called after glx context is ready to let the transition prepare GL related things, like GLSL program.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmPrepareTransition)( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+
+	/** When this method is not NULL, it is called when the transition needs to clear after itself, like delete own textures etc.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmClearTransition)();
+
+	/** When this method is not NULL, it is called in display method to display the slides.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmDisplaySlides)( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+
+	void displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+	void displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives, double SlideWidthScale, double SlideHeightScale );
+	void displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+	void applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale );
+
+	/** various transitions helper methods
+	 */
+	void prepareDiamond( double nTime, double SlideWidth, double SlideHeight,double DispWidth, double DispHeight );
+	void displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+        void displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+        void displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+	void displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+	void prepareStatic( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+	void prepareDissolve( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+	void preparePermShader();
+};
+
+class SceneObject
+{
+public:
+    SceneObject();
+
+    virtual void prepare() {};
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish() {};
+
+    void pushPrimitive (const Primitive &p);
+
+protected:
+    /** All the surrounding scene primitives
+	*/
+    vector<Primitive> maPrimitives;
+};
+
+class Iris : public SceneObject
+{
+public:
+    Iris ();
+
+    virtual void prepare();
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish();
+
+private:
+
+    GLuint maTexture;
+};
+
+/** This class is a list of Triangles that will share Operations, and could possibly share  
+*/
+class Primitive
+{
+public:
+    Primitive() {}
+	// making copy constructor explicit makes the class un-suitable for use with stl containers
+    Primitive(const Primitive& rvalue);
+	~Primitive();
+
+    void applyOperations(double nTime, double SlideWidthScale, double SlideHeightScale);
+    void display(double nTime, double SlideWidthScale, double SlideHeightScale);
+    const Primitive& operator=(const Primitive& rvalue);
+    
+    /** PushBack a vertex,normal, and tex coord. Each SlideLocation is where on the slide is mapped to this location ( from (0,0) to (1,1)  ). This will make sure the correct aspect ratio is used, and helps to make slides begin and end at the correct position. (0,0) is the top left of the slide, and (1,1) is the bottom right.
+    
+    @param SlideLocation0
+    Location of first Vertex on slide
+    
+    @param SlideLocation1
+    Location of second Vertex on slide
+    
+    @param SlideLocation2
+    Location of third Vertex on slide
+    
+    */
+    void pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2);
+    
+    /** clear all the vertices, normals, tex coordinates, and normals
+    */
+    void clearTriangles();
+    
+    /** guards against directly changing the vertices
+        
+        @return        
+        the list of vertices
+    */
+    const vector<basegfx::B3DVector>& getVertices() const {return Vertices;}
+    
+    /** guards against directly changing the vertices
+    */
+    const vector<basegfx::B3DVector>& getNormals() const {return Normals;}
+    
+    /** guards against directly changing the vertices
+    
+        @return        
+        the list of Texture Coordinates
+    
+    */
+    const vector<basegfx::B2DVector>& getTexCoords() const {return TexCoords;}
+
+    /** list of Operations to be performed on this primitive.These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+    
+        @return        
+        the list of Operations
+    
+    */    
+    vector<Operation*> Operations;
+
+private:
+    /** list of vertices
+    */
+	vector<basegfx::B3DVector> Vertices;
+	
+	/** list of Normals
+    */
+	vector<basegfx::B3DVector> Normals;
+	
+	/** list of Texture Coordinates
+    */
+	vector<basegfx::B2DVector> TexCoords;
+};
+
+/** This class is to be derived to make any operation (tranform) you may need in order to construct your transitions
+*/
+class Operation
+{
+public:
+	Operation(){}
+	virtual ~Operation(){}
+	
+	/** Should this operation be interpolated . If TRUE, the transform will smoothly move from making no difference from t = 0.0 to nT0 to being completely transformed from t = nT1 to 1. If FALSE, the transform will be inneffectual from t = 0 to nT0, and completely transformed from t = nT0 to 1. 
+	*/
+	bool bInterpolate;
+	
+	/** time to begin the transformation
+	*/
+	double nT0;
+	
+	/** time to finish the transformation
+	*/
+	double nT1;
+public:
+    /** this is the function that is called to give the Operation to OpenGL.
+        
+        @param t
+        time from t = 0 to t = 1
+        
+        @param SlideWidthScale
+        width of slide divided by width of window
+        
+        @param SlideHeightScale
+        height of slide divided by height of window
+    
+    */
+	virtual void interpolate(double t,double SlideWidthScale,double SlideHeightScale) = 0;
+	
+	/** return a copy of this operation
+	*/
+    virtual Operation* clone() = 0;
+};
+
+/** this class is a generic CounterClockWise(CCW) rotation with an axis angle
+*/
+class SRotate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    virtual SRotate* clone();
+	
+	/** Constructor
+	    
+	    @param Axis
+	    axis to rotate about
+	    
+	    @param Origin
+	    position that rotation axis runs through
+	    
+	    @param Angle
+	    angle in radians of CCW rotation
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~SRotate(){}
+private:
+    /** axis to rotate CCW about
+    */
+	basegfx::B3DVector axis;
+	
+	/** position that rotation axis runs through
+	*/
+    basegfx::B3DVector origin;
+    
+    /** angle in radians of CCW rotation
+    */
+	double angle;
+};
+
+/** scaling transformation
+*/
+class SScale: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SScale* clone();
+	
+	/** Constructor
+	    
+        @param Scale
+	    amount to scale by 
+	    
+	    @param Origin
+	    position that rotation axis runs through
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SScale(const basegfx::B3DVector& Scale, const basegfx::B3DVector& Origin,bool bInter, double T0, double T1);
+	~SScale(){}
+private:
+	basegfx::B3DVector scale;
+	basegfx::B3DVector origin;
+};
+
+/** translation transformation
+*/
+class STranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    STranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	STranslate(const basegfx::B3DVector& Vector,bool bInter, double T0, double T1);
+	~STranslate(){}
+private:
+    /** vector to translate by
+    */
+	basegfx::B3DVector vector;
+};
+
+/** translation transformation
+*/
+class SEllipseTranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SEllipseTranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1);
+	~SEllipseTranslate(){}
+private:
+    /** width and length of the ellipse
+     */
+    double width, height;
+
+    /** start and end position on the ellipse <0,1>
+     */
+    double startPosition;
+    double endPosition;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
+*/
+class RotateAndScaleDepthByWidth: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByWidth* clone();
+
+	RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~RotateAndScaleDepthByWidth(){}
+private:
+	basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+	double angle;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the height of the window.
+*/
+class RotateAndScaleDepthByHeight: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByHeight* clone();
+
+	RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~RotateAndScaleDepthByHeight(){}
+private:
+	basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+	double angle;
+};
+
+#endif // INCLUDED_SLIDESHOW_TRANSITION_HXX_
+
diff --git slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl_MACOSX.mm slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl_MACOSX.mm
new file mode 100644
index 0000000..9facac6
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionImpl_MACOSX.mm
@@ -0,0 +1,1329 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionImpl.cxx,v $
+ * $Revision: 1.5.12.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "OGLTrans_TransitionImpl.hxx"
+#include "OGLTrans_Shaders_MACOSX.h"
+#ifdef QUARTZ
+#include <OpenGL/gl.h>
+#else
+#include <GL/gl.h>
+#endif
+#include <math.h>
+
+void OGLTransitionImpl::clear()
+{
+    for(unsigned int i( 0 ); i < OverallOperations.size(); ++i)
+        delete OverallOperations[i];
+    OverallOperations.clear();
+    maLeavingSlidePrimitives.clear();
+    maEnteringSlidePrimitives.clear();
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        delete maSceneObjects[i];
+    maSceneObjects.clear();
+
+    mbReflectSlides = false;
+
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        glDeleteProgram( mProgramObject );
+        mProgramObject = 0;
+    }
+
+    if( mVertexObject ) {
+        glDeleteShader( mVertexObject );
+        mVertexObject = 0;
+    }
+
+    if( mFragmentObject ) {
+        glDeleteShader( mFragmentObject );
+        mFragmentObject = 0;
+    }
+#endif
+
+    if( maHelperTexture ) {
+        glDeleteTextures( 1, &maHelperTexture );
+        maHelperTexture = 0;
+    }
+
+    if( mmClearTransition )
+        (this->*mmClearTransition)();
+}
+
+OGLTransitionImpl::~OGLTransitionImpl()
+{
+    clear();
+}
+
+void OGLTransitionImpl::prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex )
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->prepare();
+    }
+
+    if( mmPrepareTransition )
+        (this->*mmPrepareTransition)( glLeavingSlideTex, glEnteringSlideTex );
+}
+
+void OGLTransitionImpl::finish()
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->finish();
+    }
+}
+
+static void blendSlide( double depth )
+{
+    double showHeight = -1 + depth*2;
+    GLfloat reflectionColor[] = {0, 0, 0, 0.25};
+
+    glDisable( GL_DEPTH_TEST );
+    glBegin( GL_QUADS );
+    glColor4fv( reflectionColor );
+    glVertex3f( -1, -1, 0 );
+    glColor4f( 0, 0, 0, 1 );
+    glVertex3f(-1,  showHeight, 0 );
+    glVertex3f( 1,  showHeight, 0 );
+    glColor4fv( reflectionColor );
+    glVertex3f( 1, -1, 0 );
+    glEnd();
+
+    glBegin( GL_QUADS );
+    glColor4f( 0, 0, 0, 1 );
+    glVertex3f( -1, showHeight, 0 );
+    glVertex3f( -1,  1, 0 );
+    glVertex3f(  1,  1, 0 );
+    glVertex3f(  1, showHeight, 0 );
+    glEnd();
+    glEnable( GL_DEPTH_TEST );
+}
+
+static void slideShadow( double nTime, Primitive& primitive, double sw, double sh )
+{
+    double reflectionDepth = 0.3;
+
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glDisable(GL_LIGHTING);
+
+    glPushMatrix();
+    primitive.applyOperations( nTime, sw, sh );
+    blendSlide( reflectionDepth );
+    glPopMatrix();
+
+    glDisable(GL_BLEND);
+    glEnable(GL_LIGHTING);
+}
+
+void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                 double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    double SlideWidthScale, SlideHeightScale;
+
+    SlideWidthScale = SlideWidth/DispWidth;
+    SlideHeightScale = SlideHeight/DispHeight;
+
+    if( mmPrepare ) {
+        clear();
+        (this->*mmPrepare)( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
+    }
+
+    glPushMatrix();
+    displaySlides( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
+    displayScene( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
+    glPopMatrix();
+}
+
+void OGLTransitionImpl::applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale )
+{
+    for(unsigned int i(0); i < OverallOperations.size(); ++i)
+        OverallOperations[i]->interpolate(nTime,SlideWidthScale,SlideHeightScale);
+}
+
+void OGLTransitionImpl::displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives,
+                                      double SlideWidthScale, double SlideHeightScale )
+{
+   //TODO change to foreach
+    glBindTexture(GL_TEXTURE_2D, glSlideTex);
+
+    // display slide reflection
+    // note that depth test is turned off while blending the shadow
+    // so the slides has to be rendered in right order, see rochade as example
+    if( mbReflectSlides ) {
+        double surfaceLevel = -0.04;
+
+        /* reflected slides */
+        glPushMatrix();
+
+        glScaled( 1, -1, 1 );
+        glTranslated( 0, 2 - surfaceLevel, 0 );
+
+        glCullFace(GL_FRONT);
+	for(unsigned int i(0); i < primitives.size(); ++i)
+	    primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
+        glCullFace(GL_BACK);
+
+	slideShadow( nTime, primitives[0], SlideWidthScale, SlideHeightScale );
+
+        glPopMatrix();
+    }
+
+    for(unsigned int i(0); i < primitives.size(); ++i)
+        primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
+}
+
+void OGLTransitionImpl::displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                       double SlideWidthScale, double SlideHeightScale )
+{
+    if( mmDisplaySlides )
+        (this->*mmDisplaySlides)( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
+    else {
+        applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+        glEnable(GL_TEXTURE_2D);
+        displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+        displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+}
+
+void OGLTransitionImpl::displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glEnable(GL_TEXTURE_2D);
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        maSceneObjects[i]->display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Primitive::display(double nTime, double WidthScale, double HeightScale)
+{
+    glPushMatrix();
+
+    applyOperations( nTime, WidthScale, HeightScale );
+
+    glEnableClientState( GL_VERTEX_ARRAY );
+    if(!Normals.empty())
+    {
+        glNormalPointer( GL_DOUBLE , 0 , &Normals[0] );
+        glEnableClientState( GL_NORMAL_ARRAY );
+    }
+    glEnableClientState( GL_TEXTURE_COORD_ARRAY );
+    glTexCoordPointer( 2, GL_DOUBLE, 0, &TexCoords[0] );
+    glVertexPointer( 3, GL_DOUBLE, 0, &Vertices[0] );
+    glDrawArrays( GL_TRIANGLES, 0, Vertices.size() );
+    glPopMatrix();
+}
+
+void Primitive::applyOperations(double nTime, double WidthScale, double HeightScale)
+{
+    for(unsigned int i(0); i < Operations.size(); ++i)
+        Operations[i]->interpolate( nTime ,WidthScale,HeightScale);
+    glScaled(WidthScale,HeightScale,1);
+}
+
+Primitive::~Primitive()
+{
+    for(unsigned int i( 0 ); i < Operations.size(); ++i)
+        delete Operations[i];
+}
+
+
+void SceneObject::display(double nTime, double /* SlideWidth */, double /* SlideHeight */, double DispWidth, double DispHeight )
+{
+    for(unsigned int i(0); i < maPrimitives.size(); ++i) {
+        // fixme: allow various model spaces, now we make it so that
+        // it is regular -1,-1 to 1,1, where the whole display fits in
+        glPushMatrix();
+        if (DispHeight > DispWidth)
+            glScaled(DispHeight/DispWidth, 1, 1);
+        else
+            glScaled(1, DispWidth/DispHeight, 1);
+        maPrimitives[i].display(nTime, 1, 1);
+        glPopMatrix();
+    }
+}
+
+void SceneObject::pushPrimitive(const Primitive &p)
+{
+    maPrimitives.push_back(p);
+}
+
+SceneObject::SceneObject()
+    : maPrimitives()
+{
+}
+
+Iris::Iris()
+    : SceneObject ()
+{
+}
+
+void Iris::display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    SceneObject::display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Iris::prepare()
+{
+    static GLubyte img[3] = { 80, 80, 80 };
+    
+    glGenTextures(1, &maTexture);
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, 3, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, img);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+}
+
+void Iris::finish()
+{
+    glDeleteTextures(1, &maTexture);
+}
+
+void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeInsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+    
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeFallLeaving()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(1,0,0),basegfx::B3DVector(0,-1,0), 90,true,0.0,1.0));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::makeTurnAround()
+{
+    clear();
+    Primitive Slide;
+
+    mbReflectSlides = true;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0),-180,false,0.0,1.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, -1.5),true, 0, 0.5));
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1.5), true, 0.5, 1));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0),basegfx::B3DVector(0, 0, 0), -180, true, 0.0, 1.0));
+}
+
+void OGLTransitionImpl::makeTurnDown()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 0.0001), false, -1.0, 0.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), -90, true, 0.0, 1.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), 90, false, -1.0, 0.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    mbUseMipMapLeaving = false;
+}
+
+void OGLTransitionImpl::makeIris()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0,  0.000001), false, -1, 0));
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, -0.000002), false, 0.5, 1));
+    maLeavingSlidePrimitives.push_back (Slide);
+
+
+    Primitive irisPart, part;
+    int i, nSteps = 24, nParts = 7;
+    double lt = 0, t = 1.0/nSteps, cx, cy, lcx, lcy, lx = 1, ly = 0, x, y, cxo, cyo, lcxo, lcyo, of=2.2, f=1.42;
+
+    for (i=1; i<=nSteps; i++) {
+        x = cos ((3*2*M_PI*t)/nParts);
+        y = -sin ((3*2*M_PI*t)/nParts);
+        cx = (f*x + 1)/2;
+        cy = (f*y + 1)/2;
+        lcx = (f*lx + 1)/2;
+        lcy = (f*ly + 1)/2;
+        cxo = (of*x + 1)/2;
+        cyo = (of*y + 1)/2;
+        lcxo = (of*lx + 1)/2;
+        lcyo = (of*ly + 1)/2;
+        irisPart.pushTriangle (basegfx::B2DVector (lcx, lcy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cx, cy));
+        irisPart.pushTriangle (basegfx::B2DVector (cx, cy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cxo, cyo));
+        lx = x;
+        ly = y;
+        lt = t;
+        t += 1.0/nSteps;
+    }
+
+    Iris* pIris = new Iris();
+    double angle = 87;
+
+    for (i = 0; i < nParts; i++) {
+        irisPart.Operations.clear ();
+        double rx, ry;
+
+        rx = cos ((2*M_PI*i)/nParts);
+        ry = sin ((2*M_PI*i)/nParts);
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0),  angle, true, 0.0, 0.5));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0), -angle, true, 0.5, 1));
+        if (i > 0) {
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(rx, ry, 0),  false, -1, 0));
+            irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(0, 0, 0), i*360.0/nParts, false, -1, 0));
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(-1, 0, 0),  false, -1, 0));
+        }
+        irisPart.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1), false, -2, 0.0));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(1, .5, 0), basegfx::B3DVector(1, 0, 0), -30, false, -1, 0));
+        pIris->pushPrimitive (irisPart);
+    }
+
+    maSceneObjects.push_back (pIris);
+
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+					      double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glEnable(GL_TEXTURE_2D);
+
+    if( nTime > .5) {
+	displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+	displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    } else {
+	displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+	displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+}
+
+void OGLTransitionImpl::makeRochade()
+{
+    clear();
+    Primitive Slide;
+    
+    mbReflectSlides = true;
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesRochade;
+
+    double w, h;
+
+    w = 2.2;
+    h = 10;
+
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.25, -0.25, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.75, 0.25, true, 0, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, -h), false, -1, 0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), 45, false, -1, 0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    //     OverallOperations.push_back(new SEllipseTranslate(0.5, 2, 0, 1, true, 0, 1));
+//      push_back(new STranslate(basegfx::B3DVector(0, 0, -2), true, 0, 0.5));
+//      OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 2), true, 0.5, 1));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B2DVector clamp(const basegfx::B2DVector& v)
+{
+    return basegfx::B2DVector(min(max(v.getX(),-1.0),1.0),
+                              min(max(v.getY(),-1.0),1.0));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector clamp(const basegfx::B3DVector& v)
+{
+    return basegfx::B3DVector(min(max(v.getX(),-1.0),1.0),
+                              min(max(v.getY(),-1.0),1.0),
+                              min(max(v.getZ(),-1.0),1.0));
+}
+
+inline double randFromNeg1to1()
+{
+    return ( ( static_cast<double>( rand() ) / static_cast<double>( RAND_MAX ) ) * 2.0 ) - 1.0;
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector randNormVectorInXYPlane()
+{
+    basegfx::B3DVector toReturn(randFromNeg1to1(),randFromNeg1to1(),0.0);
+    return toReturn/toReturn.getLength();
+}
+
+void OGLTransitionImpl::makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles )
+{
+    clear();
+    double dAngle(2*3.1415926/static_cast<double>( nPointsOnCircles ));
+    if(nCircles < 2 || nPointsOnCircles < 4)
+    {
+        makeNByMTileFlip(1,1);
+        return;
+    }
+    double Radius(1.0/static_cast<double>( nCircles ));
+    double dRadius(Radius);
+    double LastRadius(0.0);
+    double NextRadius(2*Radius);
+
+    /// now we know there is at least two circles
+    /// the first will always be a full circle
+    /// the last will always be the outer shell of the slide with a circle hole
+
+    //add the full circle
+    vector<basegfx::B2DVector> unScaledTexCoords;
+    double TempAngle(0.0);
+    for(unsigned int Point(0); Point < nPointsOnCircles; ++Point)
+    {
+        unScaledTexCoords.push_back( basegfx::B2DVector( cos(TempAngle - 3.1415926/2.0) , sin(TempAngle- 3.1415926/2.0) ) );
+
+        TempAngle += dAngle;
+    }
+    
+    {
+        //double angle(0.0);
+        Primitive EnteringSlide;
+        Primitive LeavingSlide;
+        for(int Point(0); Point + 1 < nPointsOnCircles; ++Point)
+        {
+            EnteringSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+            LeavingSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5, 0.5) );
+        }
+        EnteringSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius * unScaledTexCoords[ 0 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ nPointsOnCircles - 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+        LeavingSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+    
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+    
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }    
+    
+    for(int i(1); i < nCircles - 1; ++i)
+    {
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {            
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }
+    {
+        Radius = sqrt(2.0);
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {
+            
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+    }
+}
+
+void OGLTransitionImpl::makeHelix( ::sal_uInt16 nRows )
+{
+    clear();
+    double invN(1.0/static_cast<double>(nRows));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < nRows; ++i)
+    {
+        Primitive Tile;
+        
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+            
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iPDn ) , basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , 
+                                                true,min(max(static_cast<double>(i - nRows/2.0)*invN/2.0,0.0),1.0),
+                                                min(max(static_cast<double>(i + nRows/2.0)*invN/2.0,0.0),1.0) ) );
+        
+        maLeavingSlidePrimitives.push_back(Tile);
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180 , false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(Tile);
+            
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+void OGLTransitionImpl::makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m )
+{
+    clear();
+    double invN(1.0/static_cast<double>(n));
+    double invM(1.0/static_cast<double>(m));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < n; ++i)
+    {
+        double jDm = 0.0;
+        double jPDm = invM;
+        for(unsigned int j(0); j < m; ++j)
+        {
+            Primitive Tile;
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jPDm ) , basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));//bottom left corner of tile            
+
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , true, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+            maLeavingSlidePrimitives.push_back(Tile);
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180, false, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+
+            maEnteringSlidePrimitives.push_back(Tile);
+
+            jDm += invM;
+            jPDm += invM;
+        }
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+SRotate::SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+SScale::SScale(const basegfx::B3DVector& Scale,const basegfx::B3DVector& Origin, bool bInter, double T0, double T1):scale(Scale),origin(Origin)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByWidth::RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByHeight::RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+
+STranslate::STranslate(const basegfx::B3DVector& Vector, bool bInter, double T0, double T1):vector(Vector)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+inline double intervalInter(double t, double T0, double T1)
+{
+    return ( t - T0 ) / ( T1 - T0 );
+}
+
+void STranslate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*t*vector.getX(),SlideHeightScale*t*vector.getY(),t*vector.getZ());
+}
+
+void SRotate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled(SlideWidthScale,SlideHeightScale,1);
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glScaled(1/SlideWidthScale,1/SlideHeightScale,1);
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void SScale::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled((1-t) + t*scale.getX(),(1-t) + t*scale.getY(),(1-t) + t*scale.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void RotateAndScaleDepthByWidth::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideWidthScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
+}
+
+void RotateAndScaleDepthByHeight::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideHeightScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideHeightScale*origin.getZ());
+}
+
+SEllipseTranslate::SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+    width = dWidth;
+    height = dHeight;
+    startPosition = dStartPosition;
+    endPosition = dEndPosition;
+}
+
+void SEllipseTranslate::interpolate(double t,double /* SlideWidthScale */,double /* SlideHeightScale */)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+
+    double a1, a2, x, y;
+    a1 = startPosition*2*M_PI;
+    a2 = (startPosition + t*(endPosition - startPosition))*2*M_PI;
+    x = width*(cos (a2) - cos (a1))/2;
+    y = height*(sin (a2) - sin (a1))/2;
+
+    glTranslated(x, 0, y);
+}
+
+STranslate* STranslate::clone()
+{
+    return new STranslate(*this);
+}
+SRotate* SRotate::clone()
+{
+    return new SRotate(*this);
+}
+
+SScale* SScale::clone()
+{
+    return new SScale(*this);
+}
+
+SEllipseTranslate* SEllipseTranslate::clone()
+{
+    return new SEllipseTranslate(*this);
+}
+
+RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
+{
+    return new RotateAndScaleDepthByWidth(*this);
+}
+
+RotateAndScaleDepthByHeight* RotateAndScaleDepthByHeight::clone()
+{
+    return new RotateAndScaleDepthByHeight(*this);
+}
+
+const Primitive& Primitive::operator=(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);    
+    return *this;   
+}
+    
+Primitive::Primitive(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);
+}
+
+void Primitive::pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2)
+{
+    vector<basegfx::B3DVector> Verts;
+    vector<basegfx::B2DVector> Texs;
+    Verts.reserve(3);
+    Texs.reserve(3);
+
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+
+    //figure out if they're facing the correct way, and make them face the correct way.
+    basegfx::B3DVector Normal( basegfx::cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
+    if(Normal.getZ() >= 0.0)//if the normal is facing us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation1);
+        Texs.push_back(SlideLocation2);
+    }
+    else // if the normal is facing away from us, make it face us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation2);
+        Texs.push_back(SlideLocation1);
+        Verts.clear();
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    }
+
+    Vertices.push_back(Verts[0]);
+    Vertices.push_back(Verts[1]);
+    Vertices.push_back(Verts[2]);
+
+    TexCoords.push_back(Texs[0]);
+    TexCoords.push_back(Texs[1]);
+    TexCoords.push_back(Texs[2]);
+    
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+}
+
+void OGLTransitionImpl::makeDiamond()
+{
+    mmPrepare = &OGLTransitionImpl::prepareDiamond;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::prepareDiamond( double nTime, double /* SlideWidth */, double /* SlideHeight */, double /* DispWidth */, double /* DispHeight */ )
+{
+    Primitive Slide1, Slide2;
+
+    Slide1.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide1.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide1);
+
+    
+    if( nTime >= 0.5 ) {
+        double m = 1 - nTime;
+
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (m,0), basegfx::B2DVector (0,m));
+        Slide2.pushTriangle (basegfx::B2DVector (nTime,0), basegfx::B2DVector (1,0), basegfx::B2DVector (1,m));
+        Slide2.pushTriangle (basegfx::B2DVector (1,nTime), basegfx::B2DVector (1,1), basegfx::B2DVector (nTime,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,nTime), basegfx::B2DVector (m,1), basegfx::B2DVector (0,1));
+    } else {
+        double l = 0.5 - nTime;
+        double h = 0.5 + nTime;
+
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0.5,l));
+        Slide2.pushTriangle (basegfx::B2DVector (0.5,l), basegfx::B2DVector (1,0), basegfx::B2DVector (h,0.5));
+        Slide2.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (1,1), basegfx::B2DVector (h,0.5));
+        Slide2.pushTriangle (basegfx::B2DVector (h,0.5), basegfx::B2DVector (1,1), basegfx::B2DVector (0.5,h));
+        Slide2.pushTriangle (basegfx::B2DVector (0.5,h), basegfx::B2DVector (1,1), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (l,0.5), basegfx::B2DVector (0.5,h), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (l,0.5), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (0.5,l), basegfx::B2DVector (l,0.5));
+    }
+    Slide2.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, 0.00000001), false, -1, 0));
+    maLeavingSlidePrimitives.push_back (Slide2);
+}
+
+void OGLTransitionImpl::makeVenetianBlinds( bool vertical, int parts )
+{
+    static double t30 = tan( M_PI/6.0 );
+    double n, ln = 0;
+    double p = 1.0/parts;
+
+    for( int i=0; i<parts; i++ ) {
+        Primitive Slide;
+        n = (i + 1)/(double)parts;
+        if( vertical ) {
+            Slide.pushTriangle (basegfx::B2DVector (ln,0), basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1));
+            Slide.pushTriangle (basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1), basegfx::B2DVector (n,1));
+            Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, -t30*p), -120, true, 0.0, 1.0));
+        } else {
+            Slide.pushTriangle (basegfx::B2DVector (0,ln), basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n));
+            Slide.pushTriangle (basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n), basegfx::B2DVector (1,n));
+            Slide.Operations.push_back(new RotateAndScaleDepthByHeight(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, -t30*p), -120, true, 0.0, 1.0));
+        }
+        maLeavingSlidePrimitives.push_back (Slide);
+
+        if( vertical ) {
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(2*n - 1, 0, 0), -60, false, -1, 0));
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, 0), 180, false, -1, 0));
+        } else {
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - 2*n, 0), -60, false, -1, 0));
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, 0), 180, false, -1, 0));
+        }
+        maEnteringSlidePrimitives.push_back (Slide);
+        ln = n;
+    }
+}
+
+void OGLTransitionImpl::displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_DEPTH_TEST);
+
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_LIGHTING);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glColor4f( 1, 1, 1, nTime );
+    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    glDisable(GL_BLEND);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+    glEnable(GL_LIGHTING);
+
+    glEnable(GL_DEPTH_TEST);
+}
+
+void OGLTransitionImpl::makeFadeSmoothly()
+{ 
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeSmoothly;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_DEPTH_TEST);
+
+    glDisable(GL_LIGHTING);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    if( nTime < 0.5 ) {
+	glColor4f( 1, 1, 1, 1 - nTime*2 );
+	displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    } else {
+	glColor4f( 1, 1, 1, (nTime - 0.5)*2 );
+	displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+    glDisable(GL_BLEND);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+    glEnable(GL_LIGHTING);
+
+    glEnable(GL_DEPTH_TEST);
+}
+
+void OGLTransitionImpl::makeFadeThroughBlack()
+{ 
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeThroughBlack;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+static const char* basicVertexShader = "\n\
+varying vec2 v_texturePosition;\n\
+\n\
+void main( void )\n\
+{\n\
+	gl_Position = ftransform();\n\
+	v_texturePosition = gl_MultiTexCoord0.xy;\n\
+}\n\
+";
+
+static const char* staticFragmentShader = "\n\
+uniform sampler2D leavingSlideTexture;\n\
+uniform sampler2D enteringSlideTexture;\n\
+uniform sampler2D permTexture;\n\
+uniform float time;\n\
+varying vec2 v_texturePosition;\n\
+\n\
+float snoise(vec2 P) {\n\
+\n\
+  return texture2D(permTexture, P).r;\n\
+}\n\
+\n\
+\n\
+#define PART 0.5\n\
+#define START 0.4\n\
+#define END 0.9\n\
+\n\
+void main() {\n\
+    float sn = snoise(10.0*v_texturePosition+time*0.07);\n\
+    if( time < PART ) {\n\
+        float sn1 = snoise(vec2(time*15.0, 20.0*v_texturePosition.y));\n\
+        float sn2 = snoise(v_texturePosition);\n\
+        if (sn1 > 1.0 - time*time && sn2 < 2.0*time+0.1)\n\
+	        gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
+        else if (time > START )\n\
+            gl_FragColor = ((time-START)/(PART - START))*vec4(sn, sn, sn, 1.0) + (1.0 - (time - START)/(PART - START))*texture2D(leavingSlideTexture, v_texturePosition);\n\
+        else\n\
+            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+    } else if ( time < PART ) {\n\
+            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+    } else if ( time > END ) {\n\
+        gl_FragColor = ((1.0 - time)/(1.0 - END))*vec4(sn, sn, sn, 1.0) + ((time - END)/(1.0 - END))*texture2D(enteringSlideTexture, v_texturePosition);\n\
+    } else \n\
+	    gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
+}\n\
+";
+
+static const char* dissolveFragmentShader = "\n\
+uniform sampler2D leavingSlideTexture;\n\
+uniform sampler2D enteringSlideTexture;\n\
+uniform sampler2D permTexture;\n\
+uniform float time;\n\
+varying vec2 v_texturePosition;\n\
+\n\
+float snoise(vec2 P) {\n\
+\n\
+  return texture2D(permTexture, P).r;\n\
+}\n\
+\n\
+void main() {\n\
+     float sn = snoise(10.0*v_texturePosition);\n\
+     if( sn < time)\n\
+         gl_FragColor = texture2D(enteringSlideTexture, v_texturePosition);\n\
+     else\n\
+         gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+}\n\
+";
+
+int permutation256 [256]= {
+215, 100, 200, 204, 233,  50,  85, 196, 
+ 71, 141, 122, 160,  93, 131, 243, 234, 
+162, 183,  36, 155,   4,  62,  35, 205, 
+ 40, 102,  33,  27, 255,  55, 214, 156, 
+ 75, 163, 134, 126, 249,  74, 197, 228, 
+ 72,  90, 206, 235,  17,  22,  49, 169, 
+227,  89,  16,   5, 117,  60, 248, 230, 
+217,  68, 138,  96, 194, 170, 136,  10, 
+112, 238, 184, 189, 176,  42, 225, 212, 
+ 84,  58, 175, 244, 150, 168, 219, 236, 
+101, 208, 123,  37, 164, 110, 158, 201, 
+ 78, 114,  57,  48,  70, 142, 106,  43, 
+232,  26,  32, 252, 239,  98, 191,  94, 
+ 59, 149,  39, 187, 203, 190,  19,  13, 
+133,  45,  61, 247,  23,  34,  20,  52, 
+118, 209, 146, 193, 222,  18,   1, 152, 
+ 46,  41,  91, 148, 115,  25, 135,  77, 
+254, 147, 224, 161,   9, 213, 223, 250, 
+231, 251, 127, 166,  63, 179,  81, 130, 
+139,  28, 120, 151, 241,  86, 111,   0, 
+ 88, 153, 172, 182, 159, 105, 178,  47, 
+ 51, 167,  65,  66,  92,  73, 198, 211, 
+245, 195,  31, 220, 140,  76, 221, 186, 
+154, 185,  56,  83,  38, 165, 109,  67, 
+124, 226, 132,  53, 229,  29,  12, 181, 
+121,  24, 207, 199, 177, 113,  30,  80, 
+  3,  97, 188,  79, 216, 173,   8, 145, 
+ 87, 128, 180, 237, 240, 137, 125, 104, 
+ 15, 242, 119, 246, 103, 143,  95, 144, 
+  2,  44,  69, 157, 192, 174,  14,  54, 
+218,  82,  64, 210,  11,   6, 129,  21, 
+116, 171,  99, 202,   7, 107, 253, 108
+};
+
+void initPermTexture(GLuint *texID)
+{
+  glGenTextures(1, texID);
+  glBindTexture(GL_TEXTURE_2D, *texID);
+
+  static bool initialized = false;
+  static unsigned char permutation2D[256*256*4];
+  if( !initialized ) {
+      int x, y;
+
+      for( y=0; y < 256; y++ )
+          for( x=0; x < 256; x++ )
+              permutation2D[x*4 + y*1024] = permutation256[(y + permutation256[x]) & 0xff];
+
+      initialized = true;
+  }
+
+  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, permutation2D );
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
+}
+
+void OGLTransitionImpl::preparePermShader()
+{
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        glUseProgram( mProgramObject );
+
+        GLint location = glGetUniformLocation( mProgramObject, "leavingSlideTexture" );
+        if( location != -1 ) {
+            glUniform1i( location, 0 );  // texture unit 0
+        }
+
+        glActiveTexture(GL_TEXTURE1);
+        if( !maHelperTexture )
+            initPermTexture( &maHelperTexture );
+        glActiveTexture(GL_TEXTURE0);
+
+        location = glGetUniformLocation( mProgramObject, "permTexture" );
+        if( location != -1 ) {
+            glUniform1i( location, 1 );  // texture unit 1
+        }
+
+        location = glGetUniformLocation( mProgramObject, "enteringSlideTexture" );
+        if( location != -1 ) {
+            glUniform1i( location, 2 );  // texture unit 2
+        }
+    }
+#endif
+}
+
+void OGLTransitionImpl::prepareStatic( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
+{
+    //mProgramObject = LinkProgram( basicVertexShader, staticFragmentShader );
+    NSString * _basicVertexShader = (NSString *) basicVertexShader;
+    NSString * _staticFragmentShader = (NSString *) staticFragmentShader;
+    OGLShaders * anOGLShader = NULL;
+    mProgramObject = [anOGLShader loadVertexShader: _basicVertexShader fragmentShader: _staticFragmentShader];
+
+    preparePermShader();
+}
+
+void OGLTransitionImpl::displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                              double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        GLint location = glGetUniformLocation( mProgramObject, "time" );
+        if( location != -1 ) {
+            glUniform1f( location, nTime );
+        }
+    }
+
+    glActiveTexture( GL_TEXTURE2 );
+    glBindTexture( GL_TEXTURE_2D, glEnteringSlideTex );
+    glActiveTexture( GL_TEXTURE0 );
+#endif
+
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+}
+
+void OGLTransitionImpl::makeStatic()
+{
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
+    mmPrepareTransition = &OGLTransitionImpl::prepareStatic;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+
+    mnRequiredGLVersion = 2.0;
+}
+
+void OGLTransitionImpl::prepareDissolve( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
+{
+    NSString * _basicVertexShader = (NSString *) basicVertexShader;
+    NSString * _dissolveFragmentShader = (NSString *) dissolveFragmentShader;
+//    mProgramObject = loadVertexShader( _basicVertexShader, _dissolveFragmentShader );
+    OGLShaders * anOGLShader = NULL;
+    mProgramObject = [anOGLShader loadVertexShader: _basicVertexShader fragmentShader: _dissolveFragmentShader];
+
+    preparePermShader();
+}
+
+void OGLTransitionImpl::makeDissolve()
+{
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
+    mmPrepareTransition = &OGLTransitionImpl::prepareDissolve;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+
+    mnRequiredGLVersion = 2.0;
+}
+
+void OGLTransitionImpl::makeNewsflash()
+{
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),3000,true,0,0.5));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),true,0,0.5));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-10000, 0, 0),false, 0.5, 2));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),-3000,true,0.5,1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-100, 0, 0),false, -1, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(100, 0, 0),false, 0.5, 1));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),false,-1,1));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(100,100,100),basegfx::B3DVector(0,0,0),true,0.5,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0.2,0.2,0),1080,true,0,1));
+}
+
diff --git slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionerImpl_MACOSX.mm slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionerImpl_MACOSX.mm
new file mode 100644
index 0000000..0a3e82f
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/OGLTrans_TransitionerImpl_MACOSX.mm
@@ -0,0 +1,1137 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionerImpl.cxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#define GLX_GLXEXT_PROTOTYPES 1
+#include "OGLTrans_TransitionImpl.hxx"
+
+#include <com/sun/star/beans/XFastPropertySet.hpp>
+#include <com/sun/star/rendering/IntegerBitmapLayout.hpp>
+#include <com/sun/star/rendering/ColorComponentTag.hpp>
+#include <com/sun/star/rendering/ColorSpaceType.hpp>
+#include <com/sun/star/animations/TransitionType.hpp>
+#include <com/sun/star/animations/TransitionSubType.hpp>
+#include <com/sun/star/presentation/XTransitionFactory.hpp>
+#include <com/sun/star/presentation/XTransition.hpp>
+#include <com/sun/star/presentation/XSlideShowView.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#include <com/sun/star/geometry/IntegerSize2D.hpp>
+
+#include <cppuhelper/compbase1.hxx>
+#include <cppuhelper/basemutex.hxx>
+#include <cppuhelper/factory.hxx>
+#include <rtl/ref.hxx>
+
+#include <comphelper/servicedecl.hxx>
+
+#include <canvas/canvastools.hxx>
+#include <tools/gen.hxx>
+#include <vcl/window.hxx>
+#include <vcl/syschild.hxx>
+#include <vcl/sysdata.hxx>
+
+#include <boost/noncopyable.hpp>
+
+#include <premac.h>
+#include <Foundation/Foundation.h>
+#include <Cocoa/Cocoa.h>
+#include <OpenGL/gl.h>
+#include <OpenGL/glu.h>
+#include <OpenGL/glext.h>
+#include "aquaOpenGLView.h"
+#include <postmac.h>
+
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+
+#ifdef DEBUG
+#include <boost/date_time/posix_time/posix_time.hpp>
+using namespace ::boost::posix_time;
+
+static ptime t1;
+static ptime t2;
+
+#define DBG(x) x
+#else
+#define DBG(x)
+#endif
+
+using namespace ::com::sun::star;
+using ::com::sun::star::beans::XFastPropertySet;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+
+namespace
+{
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransition> OGLTransitionerImplBase;
+
+namespace
+{
+    struct OGLFormat
+    {
+        GLint  nInternalFormat;
+        GLenum eFormat;
+        GLenum eType;
+    };
+
+    /* channel ordering: (0:rgba, 1:bgra, 2:argb, 3:abgr)  
+    */
+    int calcComponentOrderIndex(const uno::Sequence<sal_Int8>& rTags)
+    {
+        using namespace rendering::ColorComponentTag;
+
+        static const sal_Int8 aOrderTable[] =
+        {
+            RGB_RED, RGB_GREEN, RGB_BLUE, ALPHA,
+            RGB_BLUE, RGB_GREEN, RGB_RED, ALPHA,
+            ALPHA, RGB_RED, RGB_GREEN, RGB_BLUE,
+            ALPHA, RGB_BLUE, RGB_GREEN, RGB_RED, 
+        };
+
+        const sal_Int32 nNumComps(rTags.getLength());
+        const sal_Int8* pLine=aOrderTable;
+        for(int i=0; i<4; ++i)
+        {
+            int j=0;
+            while( j<4 && j<nNumComps && pLine[j] == rTags[j] )
+                ++j;
+
+            // all of the line passed, this is a match!
+            if( j==nNumComps )
+                return i;
+
+            pLine+=4;
+        }
+
+        return -1;
+    }
+}
+
+/** This is the Transitioner class for OpenGL 3D transitions in
+ * slideshow. This class is implicitly
+ * constructed from XTransitionFactory.
+*/
+class OGLTransitionerImpl : private cppu::BaseMutex, private boost::noncopyable, public OGLTransitionerImplBase
+{
+public:
+    explicit OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition);
+    bool initWindowFromSlideShowView( const uno::Reference< presentation::XSlideShowView >& xView );
+    void setSlides( const Reference< rendering::XBitmap >& xLeavingSlide , const uno::Reference< rendering::XBitmap >& xEnteringSlide );
+    static bool initialize( const Reference< presentation::XSlideShowView >& xView );
+
+    // XTransition
+    virtual void SAL_CALL update( double nTime )
+	throw (uno::RuntimeException);
+    virtual void SAL_CALL viewChanged( const Reference< presentation::XSlideShowView >& rView,
+				       const Reference< rendering::XBitmap >& rLeavingBitmap,
+				       const Reference< rendering::XBitmap >& rEnteringBitmap )
+	throw (uno::RuntimeException);
+    
+protected:
+    void disposeContextAndWindow();
+    void disposeTextures();
+
+    // WeakComponentImplHelperBase
+    virtual void SAL_CALL disposing();
+    
+    bool isDisposed() const
+    {
+        return (rBHelper.bDisposed || rBHelper.bInDispose);
+    }
+
+//   bool createWindow( Window* pPWindow );
+    void createTexture(GLuint* texID,
+			bool useMipmap,
+			uno::Sequence<sal_Int8>& data,
+			const OGLFormat* pFormat );
+    void prepareEnvironment ();
+    const OGLFormat* chooseFormats();
+
+private:    
+    /** After the window has been created, and the slides have been set, we'll initialize the slides with OpenGL.
+    */
+    void GLInitSlides();
+
+
+    /// Holds the information of our new child window
+    struct GLWindow
+    {
+        AquaOpenGLView*         pAquaOpenGLView; // Custom Cocoa NSOpenGLView
+        NSOpenGLContext*        pOpenGLContext; // our OpenGLContext
+        NSRect                  aInitFrame;
+        NSView*                 apView;
+        NSScreen*               screen;
+        unsigned int			bpp;
+    	unsigned int            Width;
+    	unsigned int            Height;
+        const char*             GLXExtensions;
+        const GLubyte*          GLExtensions;
+
+        bool HasGLXExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, (const GLubyte*) GLXExtensions ); }
+	bool HasGLExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, GLExtensions ); }
+    } GLWin;
+    
+    /** OpenGL handle to the leaving slide's texture
+    */
+#if defined(MAC_OS_X_VERSION_10_5) 
+//|| (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5)
+    unsigned int GLleavingSlide;
+#else /* build target 10.4 */ 
+    unsigned long int GLleavingSlide;
+#endif
+
+    /** OpenGL handle to the entering slide's texture
+    */
+#if defined(MAC_OS_X_VERSION_10_5) 
+//|| (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5)
+    unsigned int GLenteringSlide;
+#else /* build target 10.4 */ 
+    unsigned long int GLenteringSlide;
+#endif 
+    
+    /** pointer to our window which we MIGHT create.
+    */
+    class SystemChildWindow* pWindow;
+
+    Reference< presentation::XSlideShowView > mxView;
+    Reference< rendering::XIntegerBitmap > mxLeavingBitmap;
+    Reference< rendering::XIntegerBitmap > mxEnteringBitmap;
+    
+    /** raw bytes of the entering bitmap
+    */
+    uno::Sequence<sal_Int8> EnteringBytes;
+    
+    /** raw bytes of the leaving bitmap
+    */
+    uno::Sequence<sal_Int8> LeavingBytes;
+    bool mbRestoreSync;
+    bool mbUseLeavingPixmap;
+    bool mbUseEnteringPixmap;
+    bool mbFreeLeavingPixmap;
+    bool mbFreeEnteringPixmap;
+//    unx::Pixmap maLeavingPixmap;
+//    unx::Pixmap maEnteringPixmap;
+    
+    /** the form the raw bytes are in for the bitmaps
+    */
+    rendering::IntegerBitmapLayout SlideBitmapLayout; 
+    
+    /** the size of the slides
+    */    
+    geometry::IntegerSize2D SlideSize;
+    
+    /** Our Transition to be used.
+    */    
+    OGLTransitionImpl* pTransition;
+
+public:
+    /** whether we are running on ATI fglrx with bug related to textures
+     */
+    static bool cbBrokenTexturesATI;
+
+    /** GL version
+     */
+    static float cnGLVersion;
+
+    /** Whether Mesa is the OpenGL vendor
+     */
+     
+    static bool cbMesa;
+
+    /**
+       whether the display has GLX extension
+     */
+    static bool cbGLXPresent;
+
+    /**
+       whether texture from pixmap extension is available
+    */
+    bool mbTextureFromPixmap;
+
+    /**
+       whether to generate mipmaped textures
+    */
+    bool mbGenerateMipmap;
+
+    /**
+       whether we have visual which can be used for texture_from_pixmap extension
+    */
+//    bool mbHasTFPVisual;
+
+#ifdef DEBUG
+    ptime t3;
+    ptime t4;
+    ptime t5;
+    ptime t6;
+    time_duration total_update;
+    int frame_count;
+#endif
+};
+
+// declare the static variables as some gcc versions have problems declaring them automaticaly
+/**/
+bool OGLTransitionerImpl::cbBrokenTexturesATI;
+
+float OGLTransitionerImpl::cnGLVersion;
+/**/
+bool OGLTransitionerImpl::cbMesa;
+
+bool OGLTransitionerImpl::cbGLXPresent;
+
+
+bool OGLTransitionerImpl::initialize( const Reference< presentation::XSlideShowView >& xView )
+{
+    // not thread safe
+
+    // only once. This part is needed for the hardware identification 
+    // [FIXME]: is there a Mac way of doing that ?
+    static bool initialized = false;
+
+    if( !initialized ) {
+        OGLTransitionerImpl *instance;
+
+        instance = new OGLTransitionerImpl( NULL );
+        if( instance->initWindowFromSlideShowView( xView ) ) 
+    
+        {
+            const GLubyte* version = glGetString( GL_VERSION );
+            if( version && version[0] ) {
+                cnGLVersion = version[0] - '0';
+                if( version[1] == '.' && version[2] )
+                    cnGLVersion += (version[2] - '0')/10.0;
+            } else
+                cnGLVersion = 1.0;
+            OSL_TRACE("GL version: %s parsed: %f", version, cnGLVersion );
+
+            const GLubyte* vendor = glGetString( GL_VENDOR );
+            cbMesa = ( vendor && strstr( (const char *) vendor, "Mesa" ) );
+            OSL_TRACE("GL vendor: %s identified as Mesa: %d", vendor, cbMesa );
+
+            /* TODO: check for version once the bug in fglrx driver is fixed */
+            cbBrokenTexturesATI = (vendor && strcmp( (const char *) vendor, "ATI Technologies Inc." ) == 0 );
+
+            instance->disposing();
+            cbGLXPresent = true;
+        } else
+            cbGLXPresent = false;
+
+        delete instance;
+        initialized = true;
+    }
+
+    return cbGLXPresent;
+}
+
+/*bool OGLTransitionerImpl::createWindow( Window* pPWindow )
+{
+    const SystemEnvData* sysData(pPWindow->GetSystemData());
+
+    GLWin.apView = sysData->pView;
+
+	NSOpenGLPixelFormat* fmt = [AquaOpenGLView defaultPixelFormat];
+    Window *pFrameWindow = pPWindow->GetWindow(WINDOW_FRAME);
+	Size aFrameSize( pFrameWindow->GetSizePixel() );
+	Point aScreen( pPWindow->OutputToScreenPixel( Point() ) );
+	GLWin.aInitFrame = (NSRect){ { aScreen.X(), aFrameSize.Height() - GLWin.Height - aScreen.Y() }, { GLWin.Width, GLWin.Height } };
+
+    GLWin.pAquaOpenGLView = [[NSOpenGLView alloc]initWithFrame: GLWin.aInitFrame pixelFormat: fmt];
+	OSL_ENSURE(GLWin.pAquaOpenGLView, "Could not create NSOPenGLView");
+    if( !GLWin.pAquaOpenGLView )
+		return false;
+//
+    GLWin.pOpenGLContext = [GLWin.pAquaOpenGLView openGLContext];
+    [GLWin.pOpenGLContext retain];
+	[GLWin.pAquaOpenGLView setOpenGLContext:GLWin.pOpenGLContext];
+    [sysData->pView addSubview:GLWin.pAquaOpenGLView];
+//
+    if( pWindow )
+    {
+        pWindow->SetMouseTransparent( TRUE );
+        pWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+        pWindow->EnableEraseBackground( FALSE );
+        pWindow->SetControlForeground();
+        pWindow->SetControlBackground();
+        pWindow->EnablePaint(FALSE);
+        pWindow->SetPosSizePixel(pPWindow->GetPosPixel(),pPWindow->GetSizePixel());
+ //       GLWin.dpy = reinterpret_cast<unx::Display*>(pChildSysData->pDisplay);
+//        GLWin.win = pChildSysData->aWindow;
+
+	return true;
+    }
+
+    return false;
+}
+*/
+
+bool OGLTransitionerImpl::initWindowFromSlideShowView( const Reference< presentation::XSlideShowView >& xView )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return false;
+
+    mxView.set( xView, UNO_QUERY );
+    if( !mxView.is() )
+        return false;
+
+    /// take the XSlideShowView and extract the parent window from it. see viewmediashape.cxx
+    uno::Reference< rendering::XCanvas > xCanvas(mxView->getCanvas(), uno::UNO_QUERY_THROW);
+    uno::Sequence< uno::Any > aDeviceParams;
+    ::canvas::tools::getDeviceInfo( xCanvas, aDeviceParams );
+
+    ::rtl::OUString aImplName;
+    aDeviceParams[ 0 ] >>= aImplName;
+
+    sal_Int64 aVal = 0;
+    aDeviceParams[1] >>= aVal;
+	Window* pPWindow = reinterpret_cast< Window* >( aVal );
+	GLWin.Width = pPWindow->GetSizePixel().Width();
+	GLWin.Height = pPWindow->GetSizePixel().Height();
+ 
+    const SystemEnvData* sysData(pPWindow->GetSystemData());
+
+    GLWin.apView = sysData->pView;
+
+	NSOpenGLPixelFormat* fmt = [AquaOpenGLView defaultPixelFormat];
+    Window *pFrameWindow = pPWindow->GetWindow(WINDOW_FRAME);
+	Size aFrameSize( pFrameWindow->GetSizePixel() );
+	Point aScreen( pPWindow->OutputToScreenPixel( Point() ) );
+	GLWin.aInitFrame = (NSRect){ { aScreen.X(), aFrameSize.Height() - GLWin.Height - aScreen.Y() }, { GLWin.Width, GLWin.Height } };
+
+    GLWin.pAquaOpenGLView = [[NSOpenGLView alloc]initWithFrame: GLWin.aInitFrame pixelFormat: fmt];
+	OSL_ENSURE(GLWin.pAquaOpenGLView, "Could not create NSOPenGLView");
+    if( !GLWin.pAquaOpenGLView )
+		return false;
+
+    GLWin.pOpenGLContext = [GLWin.pAquaOpenGLView openGLContext];
+    [GLWin.pOpenGLContext retain];
+	[GLWin.pAquaOpenGLView setOpenGLContext:GLWin.pOpenGLContext];
+
+    if( GLWin.pOpenGLContext == NULL ) {
+	OSL_TRACE("unable to create GLX context");
+	return false;
+    }
+
+    awt::Rectangle aCanvasArea = mxView->getCanvasArea();
+
+    // needed in windowed mode only ?
+    if( (aCanvasArea.X != 0) && (aCanvasArea.Y != 0) )
+        pWindow->SetPosSizePixel(aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
+
+    GLWin.Width = aCanvasArea.Width;
+    GLWin.Height = aCanvasArea.Height;
+    OSL_TRACE("canvas area: %d,%d - %dx%d", aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
+
+    mbTextureFromPixmap = GLWin.HasGLXExtension( "GLX_EXT_texture_from_pixmap" );
+    mbGenerateMipmap = GLWin.HasGLExtension( "GL_SGIS_generate_mipmap" );
+
+    [GLWin.apView addSubview:GLWin.pAquaOpenGLView];
+
+    if( pWindow )
+    {
+        pWindow->SetMouseTransparent( TRUE );
+        pWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+        pWindow->EnableEraseBackground( FALSE );
+        pWindow->SetControlForeground();
+        pWindow->SetControlBackground();
+        pWindow->EnablePaint(FALSE);
+        pWindow->SetPosSizePixel(pPWindow->GetPosPixel(),pPWindow->GetSizePixel());
+
+    }
+
+
+    glShadeModel( GL_SMOOTH );
+    glEnable(GL_CULL_FACE);
+    glCullFace(GL_BACK);
+    glClearColor (0.0f, 0.0f, 0.0f, 0.0f);  // R G B A
+    glClear(GL_COLOR_BUFFER_BIT);
+    glClearDepth( 1.0f );
+    glEnable( GL_DEPTH_TEST );
+    glDepthFunc( GL_LEQUAL );
+    glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+    glEnable(GL_TEXTURE_2D);
+   
+    glEnable(GL_LIGHTING);
+    GLfloat light_direction[] = { 0.0 , 0.0 , 1.0 };
+    GLfloat materialDiffuse[] = { 1.0 , 1.0 , 1.0 , 1.0};
+    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, light_direction);
+    glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
+    glEnable(GL_LIGHT0);
+    glEnable(GL_NORMALIZE);
+
+	[[GLWin.pAquaOpenGLView openGLContext] flushBuffer];
+
+    if( LeavingBytes.hasElements() && EnteringBytes.hasElements())
+       GLInitSlides();//we already have uninitialized slides, let's initialize 
+
+    if( pTransition && pTransition->mnRequiredGLVersion <= cnGLVersion )
+        pTransition->prepare( GLleavingSlide, GLenteringSlide );
+
+    return true;
+}
+
+void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
+                                     const uno::Reference< rendering::XBitmap >& xEnteringSlide )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+        
+    mxLeavingBitmap.set( xLeavingSlide , UNO_QUERY_THROW );
+    mxEnteringBitmap.set( xEnteringSlide , UNO_QUERY_THROW );
+    Reference< XFastPropertySet > xLeavingSet( xLeavingSlide , UNO_QUERY );
+    Reference< XFastPropertySet > xEnteringSet( xEnteringSlide , UNO_QUERY );
+
+    geometry::IntegerRectangle2D SlideRect;
+    SlideSize = mxLeavingBitmap->getSize();
+    SlideRect.X1 = 0;
+    SlideRect.X2 = SlideSize.Width;
+    SlideRect.Y1 = 0;
+    SlideRect.Y2 = SlideSize.Height;
+
+    OSL_TRACE("leaving bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
+    SlideSize = mxEnteringBitmap->getSize();
+    OSL_TRACE("entering bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
+
+#ifdef DEBUG
+    t1 = microsec_clock::local_time();
+#endif
+
+    mbUseLeavingPixmap = false;
+    mbUseEnteringPixmap = false;
+
+    if( !mbUseLeavingPixmap )
+	LeavingBytes = mxLeavingBitmap->getData(SlideBitmapLayout,SlideRect);
+    if( !mbUseEnteringPixmap )
+	EnteringBytes = mxEnteringBitmap->getData(SlideBitmapLayout,SlideRect);
+
+    if(GLWin.pOpenGLContext)//if we have a rendering context, let's init the slides
+        GLInitSlides();
+
+    OSL_ENSURE(SlideBitmapLayout.PlaneStride == 0,"only handle no plane stride now");
+
+    /* flush & sync */
+    mbRestoreSync = true;
+}
+
+void OGLTransitionerImpl::createTexture( GLuint* texID,
+//#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+//					 unx::GLXPixmap pixmap,
+//					 bool usePixmap,
+//#endif
+					 bool useMipmap,
+					 uno::Sequence<sal_Int8>& data,
+					 const OGLFormat* pFormat )
+{
+    glDeleteTextures( 1, texID );
+    glGenTextures( 1, texID );
+    glBindTexture( GL_TEXTURE_2D, *texID );
+    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
+    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
+/*
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::PFNGLXBINDTEXIMAGEEXTPROC myglXBindTexImageEXT = (unx::PFNGLXBINDTEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXBindTexImageEXT" );
+
+    if( usePixmap ) {
+      if( mbGenerateMipmap )
+          glTexParameteri( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS, True);
+      myglXBindTexImageEXT (GLWin.dpy, pixmap, GLX_FRONT_LEFT_EXT, NULL);
+      if( mbGenerateMipmap && useMipmap ) {
+          OSL_TRACE("use mipmaps");
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
+      } else {
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+      }
+    } else {
+#endif
+*/
+    if( !pFormat )
+    {
+        // force-convert color to ARGB8888 int color space  
+        uno::Sequence<sal_Int8> tempBytes(
+            SlideBitmapLayout.ColorSpace->convertToIntegerColorSpace(
+                data,
+                canvas::tools::getStdColorSpace()));
+        gluBuild2DMipmaps(GL_TEXTURE_2D, 
+                          4, 
+                          SlideSize.Width, 
+                          SlideSize.Height, 
+                          GL_RGBA, 
+                          GL_UNSIGNED_BYTE,
+                          &tempBytes[0]);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
+
+    //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+	GLfloat largest_supported_anisotropy;
+	glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy);
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy);
+    } else {
+	if( pTransition && !cbBrokenTexturesATI && !useMipmap) {
+	    glTexImage2D( GL_TEXTURE_2D, 0, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, 0, pFormat->eFormat, pFormat->eType, &data[0] );
+	    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+	    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+	} else {
+	    gluBuild2DMipmaps( GL_TEXTURE_2D, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, pFormat->eFormat, pFormat->eType, &data[0] );
+	    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+	    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR ); //TRILINEAR FILTERING
+
+	    //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+	    GLfloat largest_supported_anisotropy;
+	    glGetFloatv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy );
+	    glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy );
+	}
+    }
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    }
+#endif
+    OSL_ENSURE(glIsTexture(*texID), "Can't generate Leaving slide textures in OpenGL");
+}
+
+void OGLTransitionerImpl::prepareEnvironment()
+{
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    double EyePos(10.0);
+    double RealF(1.0);
+    double RealN(-1.0);
+    double RealL(-1.0);
+    double RealR(1.0);
+    double RealB(-1.0);
+    double RealT(1.0);
+    double ClipN(EyePos+5.0*RealN);
+    double ClipF(EyePos+15.0*RealF);
+    double ClipL(RealL*8.0);
+    double ClipR(RealR*8.0);
+    double ClipB(RealB*8.0);
+    double ClipT(RealT*8.0);
+    //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
+    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ),
+              1.0 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ),
+              1.0 );
+    glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    glTranslated(0,0,-EyePos);
+}
+
+const OGLFormat* OGLTransitionerImpl::chooseFormats()
+{
+    const OGLFormat* pDetectedFormat=NULL;
+    uno::Reference<rendering::XIntegerBitmapColorSpace> xIntColorSpace(
+        SlideBitmapLayout.ColorSpace);
+
+    if( (xIntColorSpace->getType() == rendering::ColorSpaceType::RGB ||
+         xIntColorSpace->getType() == rendering::ColorSpaceType::SRGB) )
+    {
+        /* table for canvas->OGL format mapping. outer index is number
+           of color components (0:3, 1:4), then comes bits per pixel
+           (0:16, 1:24, 2:32), then channel ordering: (0:rgba, 1:bgra,
+           2:argb, 3:abgr)
+         */
+        static const OGLFormat lcl_RGB24[] = 
+        {
+            // 24 bit RGB
+            {3, GL_BGR, GL_UNSIGNED_BYTE},
+            {3, GL_RGB, GL_UNSIGNED_BYTE},
+            {3, GL_BGR, GL_UNSIGNED_BYTE},
+            {3, GL_RGB, GL_UNSIGNED_BYTE}
+        };
+
+#if defined(GL_VERSION_1_2) && defined(GLU_VERSION_1_3)
+        // more format constants available
+        static const OGLFormat lcl_RGB16[] = 
+        {
+            // 16 bit RGB
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5}
+        };
+
+        static const OGLFormat lcl_ARGB16_4[] = 
+        {
+            // 16 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4},
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4}
+        };
+
+        static const OGLFormat lcl_ARGB16_5[] = 
+        {
+            // 16 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_5_5_5_1},
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1}
+        };
+
+        static const OGLFormat lcl_ARGB32[] = 
+        {
+            // 32 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV},
+            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV},
+            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8},
+            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8}
+        };
+
+        const uno::Sequence<sal_Int8> aComponentTags(
+            xIntColorSpace->getComponentTags());
+        const uno::Sequence<sal_Int32> aComponentBitcounts(
+            xIntColorSpace->getComponentBitCounts());
+        const sal_Int32 nNumComponents( aComponentBitcounts.getLength() );
+        const sal_Int32 nBitsPerPixel( xIntColorSpace->getBitsPerPixel() );
+
+        // supported component ordering?
+        const int nComponentOrderIndex(
+            calcComponentOrderIndex(aComponentTags));
+        if( nComponentOrderIndex != -1 ) 
+        {
+            switch( nBitsPerPixel )
+            {
+                case 16:
+                    if( nNumComponents == 3 )
+                    {
+                        pDetectedFormat = &lcl_RGB16[nComponentOrderIndex];
+                    }
+                    else if( nNumComponents == 4 )
+                    {
+                        if( aComponentBitcounts[1] == 4 )
+                        {
+                            pDetectedFormat = &lcl_ARGB16_4[nComponentOrderIndex];
+                        }
+                        else if( aComponentBitcounts[1] == 5 )
+                        {
+                            pDetectedFormat = &lcl_ARGB16_5[nComponentOrderIndex];
+                        }
+                    }
+                    break;
+                case 24:
+                    if( nNumComponents == 3 )
+                    {
+                        pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
+                    }
+                    break;
+                case 32:
+                    pDetectedFormat = &lcl_ARGB32[nComponentOrderIndex];
+                    break;
+            }
+        }
+#else
+        const uno::Sequence<sal_Int8> aComponentTags(
+            xIntColorSpace->getComponentTags());
+        const int nComponentOrderIndex(calcComponentOrderIndex(aComponentTags));
+        if( aComponentTags.getLength() == 3 && 
+            nComponentOrderIndex != -1 && 
+            xIntColorSpace->getBitsPerPixel() == 24 )
+        {
+            pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
+        }
+#endif
+    }
+
+    return pDetectedFormat;
+}
+
+void OGLTransitionerImpl::GLInitSlides()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed() || pTransition->mnRequiredGLVersion > cnGLVersion)
+        return;
+
+    prepareEnvironment();
+
+    const OGLFormat* pFormat = NULL;
+    if( !mbUseLeavingPixmap || !mbUseEnteringPixmap )
+	pFormat = chooseFormats();
+
+    createTexture( &GLleavingSlide,
+		   pTransition->mbUseMipMapLeaving,
+		   LeavingBytes,
+		   pFormat );
+
+    createTexture( &GLenteringSlide,
+
+		   pTransition->mbUseMipMapEntering,
+		   EnteringBytes,
+		   pFormat );
+
+#ifdef DEBUG
+    t2 = microsec_clock::local_time();
+    OSL_TRACE("textures created in: %s", to_simple_string( t2 - t1 ).c_str());
+#endif
+}
+
+void SAL_CALL OGLTransitionerImpl::update( double nTime ) throw (uno::RuntimeException)
+{
+#ifdef DEBUG
+    frame_count ++;
+    t3 = microsec_clock::local_time();
+    if( frame_count == 1 ) {
+	t5 = t3;
+	total_update = seconds (0);
+    }
+#endif
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed() || !cbGLXPresent || pTransition->mnRequiredGLVersion > cnGLVersion)
+        return;
+
+    if(GLWin.pOpenGLContext)
+        [GLWin.pOpenGLContext makeCurrentContext];
+
+    glEnable(GL_DEPTH_TEST);
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+/*
+    if(pTransition)
+	pTransition->display( nTime, GLleavingSlide, GLenteringSlide, 
+                              SlideSize.Width, SlideSize.Height,
+                              static_cast<double>(GLWin.Width),
+                              static_cast<double>(GLWin.Height) );
+*/
+    // works but not mandatory
+#ifdef MAC_OS_X_VERSION_10_5
+    int swapInt = 1;
+#else /* build target 10.4 */ 
+    long swapInt = 1;
+#endif
+    [[GLWin.pAquaOpenGLView openGLContext] setValues:&swapInt forParameter:NSOpenGLCPSwapInterval]; // set to vbl sync
+
+    NSOpenGLContext* context = [GLWin.pAquaOpenGLView openGLContext];
+    [context makeCurrentContext];
+
+    if(pTransition)
+	pTransition->display( nTime, GLleavingSlide, GLenteringSlide, 
+                              SlideSize.Width, SlideSize.Height,
+                              static_cast<double>(GLWin.Width),
+                              static_cast<double>(GLWin.Height) );
+
+
+    [context flushBuffer];
+
+	if( pWindow )
+        pWindow->Show();
+
+#ifdef DEBUG
+    t4 = microsec_clock::local_time();
+
+    OSL_TRACE("update time: %f", nTime);
+    OSL_TRACE("update took: %s", to_simple_string( t4 - t3 ).c_str());
+    total_update += (t4 - t3);
+#endif
+}
+
+void SAL_CALL OGLTransitionerImpl::viewChanged( const Reference< presentation::XSlideShowView >& rView,
+						const Reference< rendering::XBitmap >& rLeavingBitmap,
+						const Reference< rendering::XBitmap >& rEnteringBitmap )
+    throw (uno::RuntimeException)
+{
+    OSL_TRACE("transitioner: view changed");
+
+    disposeTextures();
+    disposeContextAndWindow();
+
+    initWindowFromSlideShowView( rView );
+
+    setSlides( rLeavingBitmap, rEnteringBitmap );
+}
+
+void OGLTransitionerImpl::disposeContextAndWindow()
+{
+ /*
+    if(GLWin.pOpenGLContext)
+        [GLWin.pOpenGLContext makeCurrentContext];
+	if( glGetError() != GL_NO_ERROR )
+    {
+	    OSL_TRACE("glError: %s", (char *)gluErrorString(glGetError()));
+        if(GLWin.pOpenGLContext)
+            [GLWin.pOpenGLContext clearGLContext];
+    }
+*/
+	if(GLWin.pAquaOpenGLView)
+	{
+		[GLWin.pAquaOpenGLView clearGLContext];// currentContext]; //clearCurrentContext];
+		[GLWin.pAquaOpenGLView willRemoveSubview:GLWin.apView];
+		[GLWin.pAquaOpenGLView removeFromSuperview];
+		[GLWin.pAquaOpenGLView release];
+    }
+
+    if( pWindow )
+    {
+        delete pWindow;
+        pWindow = NULL;
+		GLWin.pAquaOpenGLView = nil;
+    }
+}
+
+void OGLTransitionerImpl::disposeTextures()
+{
+    if(GLWin.pOpenGLContext)
+        [GLWin.pOpenGLContext makeCurrentContext];
+
+    if( !mbUseLeavingPixmap )
+    {
+        glDeleteTextures(1,&GLleavingSlide);
+        GLleavingSlide = 0;
+    }
+
+    if( !mbUseEnteringPixmap )
+    {
+        glDeleteTextures(1,&GLenteringSlide);
+        GLleavingSlide = 0;
+    }
+
+    mbUseLeavingPixmap = false;
+    mbUseEnteringPixmap = false;
+}
+
+// we are about to be disposed (someone call dispose() on us)
+void OGLTransitionerImpl::disposing()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+#ifdef DEBUG
+    OSL_TRACE("dispose %p\n", this);
+    if( frame_count ) {
+	t6 = microsec_clock::local_time();
+	time_duration duration = t6 - t5;
+	OSL_TRACE("whole transition (frames: %d) took: %s fps: %f time spent in updates: %s percentage of transition time: %f%%",
+		  frame_count, to_simple_string( duration ).c_str(),
+		  ((double)frame_count*1000000000.0)/duration.total_nanoseconds(),
+		  to_simple_string( total_update ).c_str(),
+		  100*(((double)total_update.total_nanoseconds())/((double)duration.total_nanoseconds()))
+	    );
+    }
+#endif
+
+    if( pWindow )
+    {
+        disposeTextures();
+
+        if (pTransition)
+            pTransition->finish();
+
+        disposeContextAndWindow();
+    }
+
+    if (pTransition)
+	delete pTransition;
+
+    mxLeavingBitmap.clear();
+    mxEnteringBitmap.clear();
+    mxView.clear();
+}
+
+OGLTransitionerImpl::OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition) : 
+    OGLTransitionerImplBase(m_aMutex), 
+    GLWin(),
+    GLleavingSlide( 0 ), 
+    GLenteringSlide( 0 ), 
+    pWindow( NULL ), 
+    mxView(),
+    EnteringBytes(),
+    LeavingBytes(),
+    mbRestoreSync( false ),
+    mbUseLeavingPixmap( false ),
+    mbUseEnteringPixmap( false ),
+    SlideBitmapLayout(),
+    SlideSize(),
+    pTransition(pOGLTransition)
+{
+    GLWin.pAquaOpenGLView = nil;
+    DBG(frame_count = 0);
+}
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransitionFactory> OGLTransitionFactoryImplBase;
+
+class OGLTransitionFactoryImpl : private cppu::BaseMutex, public OGLTransitionFactoryImplBase
+{
+public:
+    explicit OGLTransitionFactoryImpl( const uno::Reference< uno::XComponentContext >& ) :
+        OGLTransitionFactoryImplBase(m_aMutex)
+    {}
+
+    // XTransitionFactory
+    virtual ::sal_Bool SAL_CALL hasTransition( ::sal_Int16 transitionType, ::sal_Int16 transitionSubType ) throw (uno::RuntimeException)
+    {
+        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
+            switch( transitionSubType )
+                {
+                case animations::TransitionSubType::ACROSS:
+                case animations::TransitionSubType::CORNERSOUT:
+                case animations::TransitionSubType::CIRCLE:
+                case animations::TransitionSubType::FANOUTHORIZONTAL:
+                case animations::TransitionSubType::CORNERSIN:  
+                case animations::TransitionSubType::LEFTTORIGHT:
+                case animations::TransitionSubType::TOPTOBOTTOM:
+                case animations::TransitionSubType::TOPRIGHT:
+                case animations::TransitionSubType::TOPLEFT:
+                case animations::TransitionSubType::BOTTOMRIGHT:
+                case animations::TransitionSubType::BOTTOMLEFT:
+                case animations::TransitionSubType::TOPCENTER:
+                case animations::TransitionSubType::RIGHTCENTER:
+                case animations::TransitionSubType::BOTTOMCENTER:
+                    return sal_True;
+
+                default:
+                    return sal_False;
+                }
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
+            return sal_True;
+        } else
+            return sal_False;
+    }
+
+    virtual uno::Reference< presentation::XTransition > SAL_CALL createTransition( 
+        ::sal_Int16                                           transitionType, 
+        ::sal_Int16                                           transitionSubType, 
+        const uno::Reference< presentation::XSlideShowView >& view, 
+        const uno::Reference< rendering::XBitmap >&           leavingBitmap, 
+        const uno::Reference< rendering::XBitmap >&           enteringBitmap )
+	throw (uno::RuntimeException)
+    {
+        if( !hasTransition( transitionType, transitionSubType ) )
+            return uno::Reference< presentation::XTransition >();
+
+        bool bGLXPresent = OGLTransitionerImpl::initialize( view );
+
+        if( 
+            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) ||
+            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) ||
+            ( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) )
+            return uno::Reference< presentation::XTransition >();
+            
+
+        OGLTransitionImpl* pTransition = NULL;
+
+        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
+            pTransition = new OGLTransitionImpl();
+            switch( transitionSubType )
+                {
+                case animations::TransitionSubType::ACROSS:
+                    pTransition->makeNByMTileFlip(8,6);
+                    break;   
+                case animations::TransitionSubType::CORNERSOUT:
+                    pTransition->makeOutsideCubeFaceToLeft();
+                    break;            
+                case animations::TransitionSubType::CIRCLE:
+                    pTransition->makeRevolvingCircles(8,128);
+                    break;
+                case animations::TransitionSubType::FANOUTHORIZONTAL:
+                    pTransition->makeHelix(20);
+                    break;
+                case animations::TransitionSubType::CORNERSIN:  
+                    pTransition->makeInsideCubeFaceToLeft();
+                    break;
+                case animations::TransitionSubType::LEFTTORIGHT:
+                    pTransition->makeFallLeaving();
+                    break;
+                case animations::TransitionSubType::TOPTOBOTTOM:
+                    pTransition->makeTurnAround();
+                    break;
+                case animations::TransitionSubType::TOPRIGHT:
+                    pTransition->makeTurnDown();
+                    break;
+                case animations::TransitionSubType::TOPLEFT:
+                    pTransition->makeIris();
+                    break;
+                case animations::TransitionSubType::BOTTOMRIGHT:
+                    pTransition->makeRochade();
+                    break;
+                case animations::TransitionSubType::BOTTOMLEFT:
+                    pTransition->makeVenetianBlinds( true, 8 );
+                    break;
+                case animations::TransitionSubType::TOPCENTER:
+                    pTransition->makeVenetianBlinds( false, 6 );
+                    break;
+                case animations::TransitionSubType::RIGHTCENTER:
+                    pTransition->makeStatic();
+                    break;
+                case animations::TransitionSubType::BOTTOMCENTER:
+                    pTransition->makeDissolve();
+                    break;
+                }
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeFadeSmoothly();
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeFadeThroughBlack();
+        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeDiamond();
+        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeNewsflash();
+        }
+
+        rtl::Reference<OGLTransitionerImpl> xRes(
+            new OGLTransitionerImpl(pTransition) );
+        if( bGLXPresent ) {
+            if( !xRes->initWindowFromSlideShowView(view))
+                return uno::Reference< presentation::XTransition >();
+            xRes->setSlides(leavingBitmap,enteringBitmap);
+        }
+
+        return uno::Reference<presentation::XTransition>(xRes.get());
+    }
+};
+
+}
+
+namespace sdecl = comphelper::service_decl;
+#if defined (__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ <= 3)
+ sdecl::class_<OGLTransitionFactoryImpl> serviceImpl;
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     serviceImpl,
+#else
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     sdecl::class_<OGLTransitionFactoryImpl>(),
+#endif
+    "com.sun.star.comp.presentation.OGLTransitionFactory",
+    "com.sun.star.presentation.TransitionFactory" );
+
+// The C shared lib entry points
+COMPHELPER_SERVICEDECL_EXPORTS1(OGLTransitionFactoryDecl)
diff --git slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.h slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.h
new file mode 100644
index 0000000..9c43a0e
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.h
@@ -0,0 +1,36 @@
+/*
+ *  aquaOpenGLView.h
+ */
+
+@class NSOpenGLContext, NSOpenGLPixelFormat;
+
+// the most interesting is there : in OGLTrans, we use an NSView* 
+// and subclass the NSView to create an OpenGLView does the trick
+
+@interface AquaOpenGLView : NSView
+{
+  @private
+    NSOpenGLContext*     _openGLContext;
+    NSOpenGLPixelFormat* _pixelFormat;
+}
+
++ (NSOpenGLPixelFormat*)defaultPixelFormat;
+
+- (id)initWithFrame:(NSRect)frameRect pixelFormat:(NSOpenGLPixelFormat*)format;
+- (void)dealloc;
+- (void)setOpenGLContext:(NSOpenGLContext*)context;
+- (NSOpenGLContext*)openGLContext;
+- (void)clearGLContext;
+- (void)prepareOpenGL;
+- (BOOL)isOpaque;
+- (void)drawRect;
+- (void)lockFocus;
+- (void)update;		// moved or resized
+// reshape is not supported, update bounds in drawRect
+- (void) _surfaceNeedsUpdate:(NSNotification*)notification;
+- (void)setPixelFormat:(NSOpenGLPixelFormat*)pixelFormat;
+- (NSOpenGLPixelFormat*)pixelFormat;
+- (void)encodeWithCoder:(NSCoder *)coder;
+- (id)initWithCoder:(NSCoder *)coder;
+
+@end
diff --git slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.m slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.m
new file mode 100644
index 0000000..cb0d563
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/aquaOpenGLView.m
@@ -0,0 +1,195 @@
+/*
+ *  aquaOpenGLView.m
+ */
+
+#include <Cocoa/Cocoa.h>
+#include <OpenGL/OpenGL.h>
+#include <OpenGL/gl.h>
+
+#include "aquaOpenGLView.h"
+
+@implementation AquaOpenGLView
+
++ (NSOpenGLPixelFormat*)defaultPixelFormat
+{
+// first simple implementation (let's see later with more complex )
+    NSOpenGLPixelFormatAttribute attributes [] = 
+    {
+        NSOpenGLPFAWindow,
+        NSOpenGLPFADoubleBuffer,	// double buffered
+        NSOpenGLPFADepthSize, (NSOpenGLPixelFormatAttribute)16, // 16 bit depth buffer
+        (NSOpenGLPixelFormatAttribute)nil
+    };
+    return [[[NSOpenGLPixelFormat alloc] initWithAttributes:attributes] autorelease];
+}
+
+- (id)initWithFrame:(NSRect)frameRect pixelFormat:(NSOpenGLPixelFormat*)format
+{
+    self = [super initWithFrame:frameRect];
+    if (self != nil) {
+        _pixelFormat   = [format retain];
+    }
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_surfaceNeedsUpdate:) name:NSViewGlobalFrameDidChangeNotification object:self];
+    return self;
+}
+
+- (void)dealloc
+{   // get rid of the context and pixel format
+    [[NSNotificationCenter defaultCenter] removeObserver:self name:NSViewGlobalFrameDidChangeNotification object:self];
+    [self clearGLContext];
+    if (_pixelFormat)
+        [_pixelFormat release];
+
+    [super dealloc];
+}
+
+- (void)setOpenGLContext:(NSOpenGLContext*)context
+{
+    [self clearGLContext];
+    _openGLContext = [context retain];
+}
+
+- (NSOpenGLContext*)openGLContext
+{   // create a context the first time through
+     if (_openGLContext == NULL) {
+        _openGLContext = [[NSOpenGLContext alloc] initWithFormat:_pixelFormat != nil ? _pixelFormat : [[self class] defaultPixelFormat] shareContext:nil];
+        [_openGLContext makeCurrentContext];
+		[self prepareOpenGL]; // call to initialize OpenGL state here
+    }
+    return _openGLContext;
+}
+
+- (void)clearGLContext
+{
+    if (_openGLContext != nil) {
+        if ([_openGLContext view] == self) {
+            [_openGLContext clearDrawable];
+        }
+        [_openGLContext release];
+        _openGLContext = nil;
+    }
+}
+
+- (void)prepareOpenGL
+{
+	// for overriding to initialize OpenGL state, occurs after context creation
+#ifdef MAC_OS_X_VERSION_10_4
+    long swapInt = 1;
+#else /* build target 10.5 */ 
+    int swapInt = 1;
+#endif
+
+    [[self openGLContext] setValues:&swapInt forParameter:NSOpenGLCPSwapInterval]; // set to vbl sync
+
+	// init GL stuff here
+    // FIXME: why is there garbage using prepareOpenGL ,
+    // but NOT, wen using the same content,
+    // directly in the OGLTrans instance ?
+    glShadeModel( GL_SMOOTH );
+    glEnable(GL_CULL_FACE);
+    glCullFace(GL_BACK);
+    glClearColor (0.0f, 0.0f, 0.0f, 0.0f);  // R G B A
+    glClear(GL_COLOR_BUFFER_BIT);
+    glClearDepth( 1.0f );
+    glEnable( GL_DEPTH_TEST );
+    glDepthFunc( GL_LEQUAL );
+    glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+    glEnable(GL_TEXTURE_2D);
+
+
+    glEnable(GL_LIGHTING);
+    GLfloat light_direction[] = { 0.0 , 0.0 , 1.0 };
+    GLfloat materialDiffuse[] = { 1.0 , 1.0 , 1.0 , 1.0};
+    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, light_direction);
+    glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
+    glEnable(GL_LIGHT0);
+    glEnable(GL_NORMALIZE);
+
+	[[self openGLContext] flushBuffer];
+}
+
+- (BOOL)isOpaque
+{
+    return YES;
+}
+
+- (void)drawRect
+{
+    // get context. will create if we don't have one yet
+    NSOpenGLContext* context = [self openGLContext];
+    [context makeCurrentContext];
+    //perform drawing here
+    [context flushBuffer];
+}
+
+- (void)lockFocus
+{
+    // get context. will create if we don't have one yet
+    NSOpenGLContext* context = [self openGLContext];
+    
+    // make sure we are ready to draw
+    [super lockFocus];
+
+    // when we are about to draw, make sure we are linked to the view
+    if ([context view] != self) {
+        [context setView:self];
+    }
+
+    // make us the current OpenGL context
+    [context makeCurrentContext];
+}
+
+// no reshape will be called since NSView does not export a specific reshape method
+
+- (void)update
+{
+    if ([_openGLContext view] == self) {
+        [_openGLContext update];
+    }
+}
+
+- (void) _surfaceNeedsUpdate:(NSNotification*)notification
+{
+    [self update];
+}
+
+- (void)setPixelFormat:(NSOpenGLPixelFormat*)pixelFormat
+{
+    [_pixelFormat release];
+    _pixelFormat = [pixelFormat retain];
+}
+
+- (NSOpenGLPixelFormat*)pixelFormat
+{
+    return _pixelFormat;
+}
+
+
+- (void)encodeWithCoder:(NSCoder *)coder 
+{
+
+    [super encodeWithCoder:coder];
+    if (![coder allowsKeyedCoding]) {
+		[coder encodeValuesOfObjCTypes:"@iii", &_pixelFormat];
+    } else {
+		[coder encodeObject:_pixelFormat forKey:@"NSPixelFormat"];
+    }
+}
+
+- (id)initWithCoder:(NSCoder *)coder 
+{
+
+    self = [super initWithCoder:coder];
+
+    if (![coder allowsKeyedCoding]) {
+		[coder decodeValuesOfObjCTypes:"@iii", &_pixelFormat];
+    } else {
+		_pixelFormat = [[coder decodeObjectForKey:@"NSPixelFormat"] retain];
+    }
+    
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_surfaceNeedsUpdate:) name:NSViewGlobalFrameDidChangeNotification object:self];
+    
+    return self;
+}
+
+@end
diff --git slideshow/source/engine/OGLTrans/mac/makefile.mk slideshow/source/engine/OGLTrans/mac/makefile.mk
new file mode 100644
index 0000000..2671f6a
--- /dev/null
+++ slideshow/source/engine/OGLTrans/mac/makefile.mk
@@ -0,0 +1,87 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.5.12.1 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..
+
+.IF "$(ENABLE_OPENGL)" != "TRUE" || "$(OS)" != "MACOSX"
+all:
+	@echo "Building without OpenGL transitions"
+.ENDIF
+
+PRJNAME=slideshow
+TARGET=OGLTrans
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :      settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+# --- Common ----------------------------------------------------------
+
+.IF "$(OS)"=="WNT"
+IMPL_SUBDIR=win
+.ELIF "$(OS)"=="MACOSX"
+IMPL_SUBDIR=mac
+.ELSE
+IMPL_SUBDIR=unx
+.ENDIF
+
+SLOFILES = \
+	$(SLO)$/OGLTrans_Shaders_$(OS).obj \
+	$(SLO)$/OGLTrans_TransitionImpl_$(OS).obj \
+	$(SLO)$/aquaOpenGLView.obj \
+	$(SLO)$/OGLTrans_TransitionerImpl_$(OS).obj
+
+SHL1TARGET=$(TARGET).uno
+
+SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB)
+
+SHL1STDLIBS += \
+	-framework OpenGL \
+	-framework Cocoa \
+	-framework GLUT
+
+CFLAGSCXX+= -x objective-c++ -fobjc-exceptions
+
+
+SHL1IMPLIB=i$(TARGET)
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+SHL1VERSIONMAP=../exports.map
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=../exports.dxp
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
diff --git slideshow/source/engine/OGLTrans/makefile.mk slideshow/source/engine/OGLTrans/makefile.mk
deleted file mode 100644
index 6353b2d..0000000
--- slideshow/source/engine/OGLTrans/makefile.mk
+++ /dev/null
@@ -1,84 +0,0 @@
-#*************************************************************************
-#
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-# 
-# Copyright 2008 by Sun Microsystems, Inc.
-#
-# OpenOffice.org - a multi-platform office productivity suite
-#
-# $RCSfile: makefile.mk,v $
-#
-# $Revision: 1.5 $
-#
-# This file is part of OpenOffice.org.
-#
-# OpenOffice.org is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser General Public License version 3
-# only, as published by the Free Software Foundation.
-#
-# OpenOffice.org is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser General Public License version 3 for more details
-# (a copy is included in the LICENSE file that accompanied this code).
-#
-# You should have received a copy of the GNU Lesser General Public License
-# version 3 along with OpenOffice.org.  If not, see
-# <http://www.openoffice.org/license.html>
-# for a copy of the LGPLv3 License.
-#
-#*************************************************************************
-
-PRJ=..$/..$/..
-
-PRJNAME=slideshow
-TARGET=OGLTrans
-TARGETTYPE=GUI
-ENABLE_EXCEPTIONS=TRUE
-
-# --- Settings -----------------------------------------------------------
-
-.INCLUDE :      settings.mk
-.INCLUDE : $(PRJ)$/util$/makefile.pmk
-
-# --- Nothing to do if we're compiling with --disable-opengl -----------
-.IF "$(ENABLE_OPENGL)" != "TRUE"
-@all:
-    @echo "Building without OpenGL Transitions..."
-.ENDIF
-
-# --- Common ----------------------------------------------------------
-#.IF "$(GUI)"=="UNX"
-
-SLOFILES = \
-        $(SLO)$/OGLTrans_TransitionImpl.obj \
-        $(SLO)$/OGLTrans_Shaders.obj \
-        $(SLO)$/OGLTrans_TransitionerImpl.obj
-
-DLLPRE=
-SHL1TARGET=$(TARGET).uno
-
-.IF "$(GUI)"=="UNX"
-.IF "$(GUIBASE)"=="aqua"
-    SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB)
-    CFLAGSCXX+=$(OBJCXXFLAGS)
-.ELSE
-    SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB) -lGL -lGLU -lX11
-.ENDIF
-.ELSE
-    SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB) opengl32.lib glu32.lib gdi32.lib
-.ENDIF
-SHL1IMPLIB=i$(TARGET)
-SHL1LIBS=$(SLB)$/$(TARGET).lib
-SHL1DEF=$(MISC)$/$(SHL1TARGET).def
-
-SHL1VERSIONMAP=exports.map
-
-DEF1NAME=$(SHL1TARGET)
-DEF1EXPORTFILE=exports.dxp
-
-#.ENDIF
-
-# ==========================================================================
-
-.INCLUDE :	target.mk
diff --git slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders.hxx slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders.hxx
new file mode 100644
index 0000000..049c71f
--- /dev/null
+++ slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders.hxx
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_OGLTRANS_SHADERS_HXX_
+#define INCLUDED_OGLTRANS_SHADERS_HXX_
+
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glext.h>
+
+class OGLShaders {
+    static bool Initialize();
+    static bool cbInitialized;
+
+public:    
+
+    static GLuint LinkProgram( const char *vertexShader, const char *fragmentShader );
+
+    /** GL shader functions
+     */
+#ifdef GL_VERSION_2_0
+
+    static PFNGLCREATESHADERPROC glCreateShader;
+    static PFNGLSHADERSOURCEPROC glShaderSource;
+    static PFNGLCOMPILESHADERPROC glCompileShader;
+    static PFNGLGETSHADERIVPROC glGetShaderiv;
+    static PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog;
+    static PFNGLDELETESHADERPROC glDeleteShader;
+
+    static PFNGLCREATEPROGRAMPROC glCreateProgram;
+    static PFNGLATTACHSHADERPROC glAttachShader;
+    static PFNGLLINKPROGRAMPROC glLinkProgram;
+    static PFNGLGETPROGRAMIVPROC glGetProgramiv;
+    static PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog;
+    static PFNGLUSEPROGRAMPROC glUseProgram;
+    static PFNGLDELETEPROGRAMPROC glDeleteProgram;
+
+    static PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;
+    static PFNGLUNIFORM1IPROC glUniform1i;
+    static PFNGLUNIFORM1FPROC glUniform1f;
+#endif
+};
+
+#endif
diff --git slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders_LINUX.cxx slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders_LINUX.cxx
new file mode 100644
index 0000000..a144790
--- /dev/null
+++ slideshow/source/engine/OGLTrans/unx/OGLTrans_Shaders_LINUX.cxx
@@ -0,0 +1,143 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <osl/diagnose.hxx>
+
+#include "OGLTrans_Shaders.hxx"
+
+namespace unx
+{
+#include <GL/glx.h>
+#include <GL/glxext.h>
+}
+
+bool OGLShaders::cbInitialized = false;
+
+#ifdef GL_VERSION_2_0
+
+PFNGLCREATESHADERPROC OGLShaders::glCreateShader = NULL;
+PFNGLSHADERSOURCEPROC OGLShaders::glShaderSource = NULL;
+PFNGLCOMPILESHADERPROC OGLShaders::glCompileShader = NULL;
+PFNGLGETSHADERIVPROC OGLShaders::glGetShaderiv = NULL;
+PFNGLGETSHADERINFOLOGPROC OGLShaders::glGetShaderInfoLog = NULL;
+PFNGLDELETESHADERPROC OGLShaders::glDeleteShader = NULL;
+PFNGLCREATEPROGRAMPROC OGLShaders::glCreateProgram = NULL;
+PFNGLATTACHSHADERPROC OGLShaders::glAttachShader = NULL;
+PFNGLLINKPROGRAMPROC OGLShaders::glLinkProgram = NULL;
+PFNGLGETPROGRAMIVPROC OGLShaders::glGetProgramiv = NULL;
+PFNGLGETPROGRAMINFOLOGPROC OGLShaders::glGetProgramInfoLog = NULL;
+PFNGLUSEPROGRAMPROC OGLShaders::glUseProgram = NULL;
+PFNGLDELETEPROGRAMPROC OGLShaders::glDeleteProgram = NULL;
+PFNGLGETUNIFORMLOCATIONPROC OGLShaders::glGetUniformLocation = NULL;
+PFNGLUNIFORM1IPROC OGLShaders::glUniform1i = NULL;
+PFNGLUNIFORM1FPROC OGLShaders::glUniform1f = NULL;
+#endif
+
+bool OGLShaders::Initialize()
+{
+#ifdef GL_VERSION_2_0
+    if( !cbInitialized ) {
+        glCreateShader = (PFNGLCREATESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glCreateShader" );
+        glShaderSource = (PFNGLSHADERSOURCEPROC) unx::glXGetProcAddress( (unsigned char *) "glShaderSource" );
+        glCompileShader = (PFNGLCOMPILESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glCompileShader" );
+        glGetShaderiv = (PFNGLGETSHADERIVPROC) unx::glXGetProcAddress( (unsigned char *) "glGetShaderiv" );
+        glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) unx::glXGetProcAddress( (unsigned char *) "glGetShaderInfoLog" );
+        glDeleteShader = (PFNGLDELETESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glDeleteShader" );
+        glCreateProgram = (PFNGLCREATEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glCreateProgram" );
+        glAttachShader = (PFNGLATTACHSHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glAttachShader" );
+        glLinkProgram = (PFNGLLINKPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glLinkProgram" );
+        glGetProgramiv = (PFNGLGETPROGRAMIVPROC) unx::glXGetProcAddress( (unsigned char *) "glGetProgramiv" );
+        glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) unx::glXGetProcAddress( (unsigned char *) "glGetProgramInfoLog" );
+        glUseProgram = (PFNGLUSEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glUseProgram" );
+        glDeleteProgram = (PFNGLDELETEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glDeleteProgram" );
+        glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) unx::glXGetProcAddress( (unsigned char *) "glGetUniformLocation" );
+        glUniform1i = (PFNGLUNIFORM1IPROC) unx::glXGetProcAddress( (unsigned char *) "glUniform1i" );
+        glUniform1f = (PFNGLUNIFORM1FPROC) unx::glXGetProcAddress( (unsigned char *) "glUniform1f" );
+        cbInitialized = true;
+    }
+
+    return glCreateShader != NULL;
+#else
+    return false;
+#endif
+}
+
+GLuint OGLShaders::LinkProgram( const char *vertexShader, const char *fragmentShader )
+{
+#ifdef GL_VERSION_2_0
+    if( !Initialize() )
+        return 0;
+
+    GLhandleARB vertexObject, fragmentObject, programObject;
+    GLint vertexCompiled, fragmentCompiled, programLinked;
+    char log[1024];
+
+    vertexObject = glCreateShader( GL_VERTEX_SHADER );
+    fragmentObject = glCreateShader( GL_FRAGMENT_SHADER );
+    OSL_TRACE("checkpoint 1: shaders created (%d) vertex: %d fragment: %d", glGetError() == GL_NO_ERROR, vertexObject, fragmentObject );
+
+
+    glShaderSource( vertexObject, 1, &vertexShader, NULL );
+    glShaderSource( fragmentObject, 1, &fragmentShader, NULL );
+
+    glCompileShader( vertexObject );
+    glGetShaderInfoLog( vertexObject, sizeof( log ), NULL, log );
+    OSL_TRACE("vertex compile log: %s", log);
+    glGetShaderiv( vertexObject, GL_COMPILE_STATUS, &vertexCompiled );
+    glCompileShader( fragmentObject );
+    glGetShaderInfoLog( fragmentObject, sizeof( log ), NULL, log );
+    OSL_TRACE("fragment compile log: %s", log);
+    glGetShaderiv( fragmentObject, GL_COMPILE_STATUS, &fragmentCompiled );
+
+    if( !vertexCompiled || !fragmentCompiled )
+        return 0;
+
+    OSL_TRACE("checkpoint 2: shaders compiled (%d)", glGetError() == GL_NO_ERROR);
+
+    programObject = glCreateProgram();
+    glAttachShader( programObject, vertexObject );
+    glAttachShader( programObject, fragmentObject );
+
+    glLinkProgram( programObject );
+    glGetProgramInfoLog( programObject, sizeof( log ), NULL, log );
+    OSL_TRACE("program link log: %s", log);
+    glGetProgramiv( programObject, GL_LINK_STATUS, &programLinked );
+
+    if( !programLinked )
+        return 0;
+
+    OSL_TRACE("checkpoint 3: program linked (%d)", glGetError() == GL_NO_ERROR);
+
+    return programObject;
+#else
+    return 0;
+#endif
+}
+
diff --git slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.cxx slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.cxx
new file mode 100644
index 0000000..de63a1b
--- /dev/null
+++ slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.cxx
@@ -0,0 +1,1318 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionImpl.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "OGLTrans_TransitionImpl.hxx"
+#include "OGLTrans_Shaders.hxx"
+#include <GL/gl.h>
+#include <math.h>
+
+
+void OGLTransitionImpl::clear()
+{
+    for(unsigned int i( 0 ); i < OverallOperations.size(); ++i)
+        delete OverallOperations[i];
+    OverallOperations.clear();
+    maLeavingSlidePrimitives.clear();
+    maEnteringSlidePrimitives.clear();
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        delete maSceneObjects[i];
+    maSceneObjects.clear();
+
+    mbReflectSlides = false;
+
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        OGLShaders::glDeleteProgram( mProgramObject );
+        mProgramObject = 0;
+    }
+
+    if( mVertexObject ) {
+        OGLShaders::glDeleteShader( mVertexObject );
+        mVertexObject = 0;
+    }
+
+    if( mFragmentObject ) {
+        OGLShaders::glDeleteShader( mFragmentObject );
+        mFragmentObject = 0;
+    }
+#endif
+
+    if( maHelperTexture ) {
+        glDeleteTextures( 1, &maHelperTexture );
+        maHelperTexture = 0;
+    }
+
+    if( mmClearTransition )
+        (this->*mmClearTransition)();
+}
+
+OGLTransitionImpl::~OGLTransitionImpl()
+{
+    clear();
+}
+
+void OGLTransitionImpl::prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex )
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->prepare();
+    }
+
+    if( mmPrepareTransition )
+        (this->*mmPrepareTransition)( glLeavingSlideTex, glEnteringSlideTex );
+}
+
+void OGLTransitionImpl::finish()
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->finish();
+    }
+}
+
+static void blendSlide( double depth )
+{
+    double showHeight = -1 + depth*2;
+    GLfloat reflectionColor[] = {0, 0, 0, 0.25};
+
+    glDisable( GL_DEPTH_TEST );
+    glBegin( GL_QUADS );
+    glColor4fv( reflectionColor );
+    glVertex3f( -1, -1, 0 );
+    glColor4f( 0, 0, 0, 1 );
+    glVertex3f(-1,  showHeight, 0 );
+    glVertex3f( 1,  showHeight, 0 );
+    glColor4fv( reflectionColor );
+    glVertex3f( 1, -1, 0 );
+    glEnd();
+
+    glBegin( GL_QUADS );
+    glColor4f( 0, 0, 0, 1 );
+    glVertex3f( -1, showHeight, 0 );
+    glVertex3f( -1,  1, 0 );
+    glVertex3f(  1,  1, 0 );
+    glVertex3f(  1, showHeight, 0 );
+    glEnd();
+    glEnable( GL_DEPTH_TEST );
+}
+
+static void slideShadow( double nTime, Primitive& primitive, double sw, double sh )
+{
+    double reflectionDepth = 0.3;
+
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glDisable(GL_LIGHTING);
+
+    glPushMatrix();
+    primitive.applyOperations( nTime, sw, sh );
+    blendSlide( reflectionDepth );
+    glPopMatrix();
+
+    glDisable(GL_BLEND);
+    glEnable(GL_LIGHTING);
+}
+
+void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                 double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    double SlideWidthScale, SlideHeightScale;
+
+    SlideWidthScale = SlideWidth/DispWidth;
+    SlideHeightScale = SlideHeight/DispHeight;
+
+    if( mmPrepare ) {
+        clear();
+        (this->*mmPrepare)( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
+    }
+
+    glPushMatrix();
+    displaySlides( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
+    displayScene( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
+    glPopMatrix();
+}
+
+void OGLTransitionImpl::applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale )
+{
+    for(unsigned int i(0); i < OverallOperations.size(); ++i)
+        OverallOperations[i]->interpolate(nTime,SlideWidthScale,SlideHeightScale);
+}
+
+void OGLTransitionImpl::displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives,
+                                      double SlideWidthScale, double SlideHeightScale )
+{
+   //TODO change to foreach
+    glBindTexture(GL_TEXTURE_2D, glSlideTex);
+
+    // display slide reflection
+    // note that depth test is turned off while blending the shadow
+    // so the slides has to be rendered in right order, see rochade as example
+    if( mbReflectSlides ) {
+        double surfaceLevel = -0.04;
+
+        /* reflected slides */
+        glPushMatrix();
+
+        glScaled( 1, -1, 1 );
+        glTranslated( 0, 2 - surfaceLevel, 0 );
+
+        glCullFace(GL_FRONT);
+    for(unsigned int i(0); i < primitives.size(); ++i)
+        primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
+        glCullFace(GL_BACK);
+
+    slideShadow( nTime, primitives[0], SlideWidthScale, SlideHeightScale );
+
+        glPopMatrix();
+    }
+
+    for(unsigned int i(0); i < primitives.size(); ++i)
+        primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
+}
+
+void OGLTransitionImpl::displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                       double SlideWidthScale, double SlideHeightScale )
+{
+    if( mmDisplaySlides )
+        (this->*mmDisplaySlides)( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
+    else {
+        applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+        glEnable(GL_TEXTURE_2D);
+        displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+        displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+}
+
+void OGLTransitionImpl::displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glEnable(GL_TEXTURE_2D);
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        maSceneObjects[i]->display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Primitive::display(double nTime, double WidthScale, double HeightScale)
+{
+    glPushMatrix();
+
+    applyOperations( nTime, WidthScale, HeightScale );
+
+    glEnableClientState( GL_VERTEX_ARRAY );
+    if(!Normals.empty())
+    {
+        glNormalPointer( GL_DOUBLE , 0 , &Normals[0] );
+        glEnableClientState( GL_NORMAL_ARRAY );
+    }
+    glEnableClientState( GL_TEXTURE_COORD_ARRAY );
+    glTexCoordPointer( 2, GL_DOUBLE, 0, &TexCoords[0] );
+    glVertexPointer( 3, GL_DOUBLE, 0, &Vertices[0] );
+    glDrawArrays( GL_TRIANGLES, 0, Vertices.size() );
+    glPopMatrix();
+}
+
+void Primitive::applyOperations(double nTime, double WidthScale, double HeightScale)
+{
+    for(unsigned int i(0); i < Operations.size(); ++i)
+        Operations[i]->interpolate( nTime ,WidthScale,HeightScale);
+    glScaled(WidthScale,HeightScale,1);
+}
+
+Primitive::~Primitive()
+{
+    for(unsigned int i( 0 ); i < Operations.size(); ++i)
+        delete Operations[i];
+}
+
+
+void SceneObject::display(double nTime, double /* SlideWidth */, double /* SlideHeight */, double DispWidth, double DispHeight )
+{
+    for(unsigned int i(0); i < maPrimitives.size(); ++i) {
+        // fixme: allow various model spaces, now we make it so that
+        // it is regular -1,-1 to 1,1, where the whole display fits in
+        glPushMatrix();
+        if (DispHeight > DispWidth)
+            glScaled(DispHeight/DispWidth, 1, 1);
+        else
+            glScaled(1, DispWidth/DispHeight, 1);
+        maPrimitives[i].display(nTime, 1, 1);
+        glPopMatrix();
+    }
+}
+
+void SceneObject::pushPrimitive(const Primitive &p)
+{
+    maPrimitives.push_back(p);
+}
+
+SceneObject::SceneObject()
+    : maPrimitives()
+{
+}
+
+Iris::Iris()
+    : SceneObject ()
+{
+}
+
+void Iris::display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    SceneObject::display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Iris::prepare()
+{
+    static GLubyte img[3] = { 80, 80, 80 };
+    
+    glGenTextures(1, &maTexture);
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, 3, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, img);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+}
+
+void Iris::finish()
+{
+    glDeleteTextures(1, &maTexture);
+}
+
+void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeInsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+    
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeFallLeaving()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(1,0,0),basegfx::B3DVector(0,-1,0), 90,true,0.0,1.0));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::makeTurnAround()
+{
+    clear();
+    Primitive Slide;
+
+    mbReflectSlides = true;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0),-180,false,0.0,1.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, -1.5),true, 0, 0.5));
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1.5), true, 0.5, 1));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0),basegfx::B3DVector(0, 0, 0), -180, true, 0.0, 1.0));
+}
+
+void OGLTransitionImpl::makeTurnDown()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 0.0001), false, -1.0, 0.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), -90, true, 0.0, 1.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), 90, false, -1.0, 0.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    mbUseMipMapLeaving = false;
+}
+
+void OGLTransitionImpl::makeIris()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0,  0.000001), false, -1, 0));
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, -0.000002), false, 0.5, 1));
+    maLeavingSlidePrimitives.push_back (Slide);
+
+
+    Primitive irisPart, part;
+    int i, nSteps = 24, nParts = 7;
+    double lt = 0, t = 1.0/nSteps, cx, cy, lcx, lcy, lx = 1, ly = 0, x, y, cxo, cyo, lcxo, lcyo, of=2.2, f=1.42;
+
+    for (i=1; i<=nSteps; i++) {
+        x = cos ((3*2*M_PI*t)/nParts);
+        y = -sin ((3*2*M_PI*t)/nParts);
+        cx = (f*x + 1)/2;
+        cy = (f*y + 1)/2;
+        lcx = (f*lx + 1)/2;
+        lcy = (f*ly + 1)/2;
+        cxo = (of*x + 1)/2;
+        cyo = (of*y + 1)/2;
+        lcxo = (of*lx + 1)/2;
+        lcyo = (of*ly + 1)/2;
+        irisPart.pushTriangle (basegfx::B2DVector (lcx, lcy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cx, cy));
+        irisPart.pushTriangle (basegfx::B2DVector (cx, cy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cxo, cyo));
+        lx = x;
+        ly = y;
+        lt = t;
+        t += 1.0/nSteps;
+    }
+
+    Iris* pIris = new Iris();
+    double angle = 87;
+
+    for (i = 0; i < nParts; i++) {
+        irisPart.Operations.clear ();
+        double rx, ry;
+
+        rx = cos ((2*M_PI*i)/nParts);
+        ry = sin ((2*M_PI*i)/nParts);
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0),  angle, true, 0.0, 0.5));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0), -angle, true, 0.5, 1));
+        if (i > 0) {
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(rx, ry, 0),  false, -1, 0));
+            irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(0, 0, 0), i*360.0/nParts, false, -1, 0));
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(-1, 0, 0),  false, -1, 0));
+        }
+        irisPart.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1), false, -2, 0.0));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(1, .5, 0), basegfx::B3DVector(1, 0, 0), -30, false, -1, 0));
+        pIris->pushPrimitive (irisPart);
+    }
+
+    maSceneObjects.push_back (pIris);
+
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                          double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glEnable(GL_TEXTURE_2D);
+
+    if( nTime > .5) {
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    } else {
+    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+}
+
+void OGLTransitionImpl::makeRochade()
+{
+    clear();
+    Primitive Slide;
+    
+    mbReflectSlides = true;
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesRochade;
+
+    double w, h;
+
+    w = 2.2;
+    h = 10;
+
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.25, -0.25, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.75, 0.25, true, 0, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, -h), false, -1, 0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), 45, false, -1, 0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    //     OverallOperations.push_back(new SEllipseTranslate(0.5, 2, 0, 1, true, 0, 1));
+//      push_back(new STranslate(basegfx::B3DVector(0, 0, -2), true, 0, 0.5));
+//      OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 2), true, 0.5, 1));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B2DVector clamp(const basegfx::B2DVector& v)
+{
+    return basegfx::B2DVector(min(max(v.getX(),-1.0),1.0),
+                              min(max(v.getY(),-1.0),1.0));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector clamp(const basegfx::B3DVector& v)
+{
+    return basegfx::B3DVector(min(max(v.getX(),-1.0),1.0),
+                              min(max(v.getY(),-1.0),1.0),
+                              min(max(v.getZ(),-1.0),1.0));
+}
+
+inline double randFromNeg1to1()
+{
+    return ( ( static_cast<double>( rand() ) / static_cast<double>( RAND_MAX ) ) * 2.0 ) - 1.0;
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector randNormVectorInXYPlane()
+{
+    basegfx::B3DVector toReturn(randFromNeg1to1(),randFromNeg1to1(),0.0);
+    return toReturn/toReturn.getLength();
+}
+
+void OGLTransitionImpl::makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles )
+{
+    clear();
+    double dAngle(2*3.1415926/static_cast<double>( nPointsOnCircles ));
+    if(nCircles < 2 || nPointsOnCircles < 4)
+    {
+        makeNByMTileFlip(1,1);
+        return;
+    }
+    double Radius(1.0/static_cast<double>( nCircles ));
+    double dRadius(Radius);
+    double LastRadius(0.0);
+    double NextRadius(2*Radius);
+
+    /// now we know there is at least two circles
+    /// the first will always be a full circle
+    /// the last will always be the outer shell of the slide with a circle hole
+
+    //add the full circle
+    vector<basegfx::B2DVector> unScaledTexCoords;
+    double TempAngle(0.0);
+    for(unsigned int Point(0); Point < nPointsOnCircles; ++Point)
+    {
+        unScaledTexCoords.push_back( basegfx::B2DVector( cos(TempAngle - 3.1415926/2.0) , sin(TempAngle- 3.1415926/2.0) ) );
+
+        TempAngle += dAngle;
+    }
+    
+    {
+        //double angle(0.0);
+        Primitive EnteringSlide;
+        Primitive LeavingSlide;
+        for(int Point(0); Point + 1 < nPointsOnCircles; ++Point)
+        {
+            EnteringSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+            LeavingSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5, 0.5) );
+        }
+        EnteringSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius * unScaledTexCoords[ 0 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ nPointsOnCircles - 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+        LeavingSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+    
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+    
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }    
+    
+    for(int i(1); i < nCircles - 1; ++i)
+    {
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {            
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }
+    {
+        Radius = sqrt(2.0);
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {
+            
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+    }
+}
+
+void OGLTransitionImpl::makeHelix( ::sal_uInt16 nRows )
+{
+    clear();
+    double invN(1.0/static_cast<double>(nRows));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < nRows; ++i)
+    {
+        Primitive Tile;
+        
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+            
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iPDn ) , basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , 
+                                                true,min(max(static_cast<double>(i - nRows/2.0)*invN/2.0,0.0),1.0),
+                                                min(max(static_cast<double>(i + nRows/2.0)*invN/2.0,0.0),1.0) ) );
+        
+        maLeavingSlidePrimitives.push_back(Tile);
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180 , false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(Tile);
+            
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+void OGLTransitionImpl::makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m )
+{
+    clear();
+    double invN(1.0/static_cast<double>(n));
+    double invM(1.0/static_cast<double>(m));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < n; ++i)
+    {
+        double jDm = 0.0;
+        double jPDm = invM;
+        for(unsigned int j(0); j < m; ++j)
+        {
+            Primitive Tile;
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jPDm ) , basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));//bottom left corner of tile            
+
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , true, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+            maLeavingSlidePrimitives.push_back(Tile);
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180, false, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+
+            maEnteringSlidePrimitives.push_back(Tile);
+
+            jDm += invM;
+            jPDm += invM;
+        }
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+SRotate::SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+SScale::SScale(const basegfx::B3DVector& Scale,const basegfx::B3DVector& Origin, bool bInter, double T0, double T1):scale(Scale),origin(Origin)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByWidth::RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByHeight::RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+
+STranslate::STranslate(const basegfx::B3DVector& Vector, bool bInter, double T0, double T1):vector(Vector)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+inline double intervalInter(double t, double T0, double T1)
+{
+    return ( t - T0 ) / ( T1 - T0 );
+}
+
+void STranslate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*t*vector.getX(),SlideHeightScale*t*vector.getY(),t*vector.getZ());
+}
+
+void SRotate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled(SlideWidthScale,SlideHeightScale,1);
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glScaled(1/SlideWidthScale,1/SlideHeightScale,1);
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void SScale::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled((1-t) + t*scale.getX(),(1-t) + t*scale.getY(),(1-t) + t*scale.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void RotateAndScaleDepthByWidth::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideWidthScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
+}
+
+void RotateAndScaleDepthByHeight::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideHeightScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideHeightScale*origin.getZ());
+}
+
+SEllipseTranslate::SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+    width = dWidth;
+    height = dHeight;
+    startPosition = dStartPosition;
+    endPosition = dEndPosition;
+}
+
+void SEllipseTranslate::interpolate(double t,double /* SlideWidthScale */,double /* SlideHeightScale */)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+
+    double a1, a2, x, y;
+    a1 = startPosition*2*M_PI;
+    a2 = (startPosition + t*(endPosition - startPosition))*2*M_PI;
+    x = width*(cos (a2) - cos (a1))/2;
+    y = height*(sin (a2) - sin (a1))/2;
+
+    glTranslated(x, 0, y);
+}
+
+STranslate* STranslate::clone()
+{
+    return new STranslate(*this);
+}
+SRotate* SRotate::clone()
+{
+    return new SRotate(*this);
+}
+
+SScale* SScale::clone()
+{
+    return new SScale(*this);
+}
+
+SEllipseTranslate* SEllipseTranslate::clone()
+{
+    return new SEllipseTranslate(*this);
+}
+
+RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
+{
+    return new RotateAndScaleDepthByWidth(*this);
+}
+
+RotateAndScaleDepthByHeight* RotateAndScaleDepthByHeight::clone()
+{
+    return new RotateAndScaleDepthByHeight(*this);
+}
+
+const Primitive& Primitive::operator=(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);    
+    return *this;   
+}
+    
+Primitive::Primitive(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);
+}
+
+void Primitive::pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2)
+{
+    vector<basegfx::B3DVector> Verts;
+    vector<basegfx::B2DVector> Texs;
+    Verts.reserve(3);
+    Texs.reserve(3);
+
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+
+    //figure out if they're facing the correct way, and make them face the correct way.
+    basegfx::B3DVector Normal( basegfx::cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
+    if(Normal.getZ() >= 0.0)//if the normal is facing us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation1);
+        Texs.push_back(SlideLocation2);
+    }
+    else // if the normal is facing away from us, make it face us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation2);
+        Texs.push_back(SlideLocation1);
+        Verts.clear();
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    }
+
+    Vertices.push_back(Verts[0]);
+    Vertices.push_back(Verts[1]);
+    Vertices.push_back(Verts[2]);
+
+    TexCoords.push_back(Texs[0]);
+    TexCoords.push_back(Texs[1]);
+    TexCoords.push_back(Texs[2]);
+    
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+}
+
+void OGLTransitionImpl::makeDiamond()
+{
+    mmPrepare = &OGLTransitionImpl::prepareDiamond;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::prepareDiamond( double nTime, double /* SlideWidth */, double /* SlideHeight */, double /* DispWidth */, double /* DispHeight */ )
+{
+    Primitive Slide1, Slide2;
+
+    Slide1.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide1.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide1);
+
+    
+    if( nTime >= 0.5 ) {
+        double m = 1 - nTime;
+
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (m,0), basegfx::B2DVector (0,m));
+        Slide2.pushTriangle (basegfx::B2DVector (nTime,0), basegfx::B2DVector (1,0), basegfx::B2DVector (1,m));
+        Slide2.pushTriangle (basegfx::B2DVector (1,nTime), basegfx::B2DVector (1,1), basegfx::B2DVector (nTime,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,nTime), basegfx::B2DVector (m,1), basegfx::B2DVector (0,1));
+    } else {
+        double l = 0.5 - nTime;
+        double h = 0.5 + nTime;
+
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0.5,l));
+        Slide2.pushTriangle (basegfx::B2DVector (0.5,l), basegfx::B2DVector (1,0), basegfx::B2DVector (h,0.5));
+        Slide2.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (1,1), basegfx::B2DVector (h,0.5));
+        Slide2.pushTriangle (basegfx::B2DVector (h,0.5), basegfx::B2DVector (1,1), basegfx::B2DVector (0.5,h));
+        Slide2.pushTriangle (basegfx::B2DVector (0.5,h), basegfx::B2DVector (1,1), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (l,0.5), basegfx::B2DVector (0.5,h), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (l,0.5), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (0.5,l), basegfx::B2DVector (l,0.5));
+    }
+    Slide2.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, 0.00000001), false, -1, 0));
+    maLeavingSlidePrimitives.push_back (Slide2);
+}
+
+void OGLTransitionImpl::makeVenetianBlinds( bool vertical, int parts )
+{
+    static double t30 = tan( M_PI/6.0 );
+    double n, ln = 0;
+    double p = 1.0/parts;
+
+    for( int i=0; i<parts; i++ ) {
+        Primitive Slide;
+        n = (i + 1)/(double)parts;
+        if( vertical ) {
+            Slide.pushTriangle (basegfx::B2DVector (ln,0), basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1));
+            Slide.pushTriangle (basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1), basegfx::B2DVector (n,1));
+            Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, -t30*p), -120, true, 0.0, 1.0));
+        } else {
+            Slide.pushTriangle (basegfx::B2DVector (0,ln), basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n));
+            Slide.pushTriangle (basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n), basegfx::B2DVector (1,n));
+            Slide.Operations.push_back(new RotateAndScaleDepthByHeight(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, -t30*p), -120, true, 0.0, 1.0));
+        }
+        maLeavingSlidePrimitives.push_back (Slide);
+
+        if( vertical ) {
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(2*n - 1, 0, 0), -60, false, -1, 0));
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, 0), 180, false, -1, 0));
+        } else {
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - 2*n, 0), -60, false, -1, 0));
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, 0), 180, false, -1, 0));
+        }
+        maEnteringSlidePrimitives.push_back (Slide);
+        ln = n;
+    }
+}
+
+void OGLTransitionImpl::displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_DEPTH_TEST);
+
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_LIGHTING);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glColor4f( 1, 1, 1, nTime );
+    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    glDisable(GL_BLEND);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+    glEnable(GL_LIGHTING);
+
+    glEnable(GL_DEPTH_TEST);
+}
+
+void OGLTransitionImpl::makeFadeSmoothly()
+{ 
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeSmoothly;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_DEPTH_TEST);
+
+    glDisable(GL_LIGHTING);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    if( nTime < 0.5 ) {
+    glColor4f( 1, 1, 1, 1 - nTime*2 );
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    } else {
+    glColor4f( 1, 1, 1, (nTime - 0.5)*2 );
+    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+    glDisable(GL_BLEND);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+    glEnable(GL_LIGHTING);
+
+    glEnable(GL_DEPTH_TEST);
+}
+
+void OGLTransitionImpl::makeFadeThroughBlack()
+{ 
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeThroughBlack;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+static const char* basicVertexShader = "\n\
+varying vec2 v_texturePosition;\n\
+\n\
+void main( void )\n\
+{\n\
+    gl_Position = ftransform();\n\
+    v_texturePosition = gl_MultiTexCoord0.xy;\n\
+}\n\
+";
+
+static const char* staticFragmentShader = "\n\
+uniform sampler2D leavingSlideTexture;\n\
+uniform sampler2D enteringSlideTexture;\n\
+uniform sampler2D permTexture;\n\
+uniform float time;\n\
+varying vec2 v_texturePosition;\n\
+\n\
+float snoise(vec2 P) {\n\
+\n\
+  return texture2D(permTexture, P).r;\n\
+}\n\
+\n\
+\n\
+#define PART 0.5\n\
+#define START 0.4\n\
+#define END 0.9\n\
+\n\
+void main() {\n\
+    float sn = snoise(10.0*v_texturePosition+time*0.07);\n\
+    if( time < PART ) {\n\
+        float sn1 = snoise(vec2(time*15.0, 20.0*v_texturePosition.y));\n\
+        float sn2 = snoise(v_texturePosition);\n\
+        if (sn1 > 1.0 - time*time && sn2 < 2.0*time+0.1)\n\
+            gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
+        else if (time > START )\n\
+            gl_FragColor = ((time-START)/(PART - START))*vec4(sn, sn, sn, 1.0) + (1.0 - (time - START)/(PART - START))*texture2D(leavingSlideTexture, v_texturePosition);\n\
+        else\n\
+            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+    } else if ( time < PART ) {\n\
+            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+    } else if ( time > END ) {\n\
+        gl_FragColor = ((1.0 - time)/(1.0 - END))*vec4(sn, sn, sn, 1.0) + ((time - END)/(1.0 - END))*texture2D(enteringSlideTexture, v_texturePosition);\n\
+    } else \n\
+        gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
+}\n\
+";
+
+static const char* dissolveFragmentShader = "\n\
+uniform sampler2D leavingSlideTexture;\n\
+uniform sampler2D enteringSlideTexture;\n\
+uniform sampler2D permTexture;\n\
+uniform float time;\n\
+varying vec2 v_texturePosition;\n\
+\n\
+float snoise(vec2 P) {\n\
+\n\
+  return texture2D(permTexture, P).r;\n\
+}\n\
+\n\
+void main() {\n\
+     float sn = snoise(10.0*v_texturePosition);\n\
+     if( sn < time)\n\
+         gl_FragColor = texture2D(enteringSlideTexture, v_texturePosition);\n\
+     else\n\
+         gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+}\n\
+";
+
+int permutation256 [256]= {
+215, 100, 200, 204, 233,  50,  85, 196, 
+ 71, 141, 122, 160,  93, 131, 243, 234, 
+162, 183,  36, 155,   4,  62,  35, 205, 
+ 40, 102,  33,  27, 255,  55, 214, 156, 
+ 75, 163, 134, 126, 249,  74, 197, 228, 
+ 72,  90, 206, 235,  17,  22,  49, 169, 
+227,  89,  16,   5, 117,  60, 248, 230, 
+217,  68, 138,  96, 194, 170, 136,  10, 
+112, 238, 184, 189, 176,  42, 225, 212, 
+ 84,  58, 175, 244, 150, 168, 219, 236, 
+101, 208, 123,  37, 164, 110, 158, 201, 
+ 78, 114,  57,  48,  70, 142, 106,  43, 
+232,  26,  32, 252, 239,  98, 191,  94, 
+ 59, 149,  39, 187, 203, 190,  19,  13, 
+133,  45,  61, 247,  23,  34,  20,  52, 
+118, 209, 146, 193, 222,  18,   1, 152, 
+ 46,  41,  91, 148, 115,  25, 135,  77, 
+254, 147, 224, 161,   9, 213, 223, 250, 
+231, 251, 127, 166,  63, 179,  81, 130, 
+139,  28, 120, 151, 241,  86, 111,   0, 
+ 88, 153, 172, 182, 159, 105, 178,  47, 
+ 51, 167,  65,  66,  92,  73, 198, 211, 
+245, 195,  31, 220, 140,  76, 221, 186, 
+154, 185,  56,  83,  38, 165, 109,  67, 
+124, 226, 132,  53, 229,  29,  12, 181, 
+121,  24, 207, 199, 177, 113,  30,  80, 
+  3,  97, 188,  79, 216, 173,   8, 145, 
+ 87, 128, 180, 237, 240, 137, 125, 104, 
+ 15, 242, 119, 246, 103, 143,  95, 144, 
+  2,  44,  69, 157, 192, 174,  14,  54, 
+218,  82,  64, 210,  11,   6, 129,  21, 
+116, 171,  99, 202,   7, 107, 253, 108
+};
+
+void initPermTexture(GLuint *texID)
+{
+  glGenTextures(1, texID);
+  glBindTexture(GL_TEXTURE_2D, *texID);
+
+  static bool initialized = false;
+  static unsigned char permutation2D[256*256*4];
+  if( !initialized ) {
+      int x, y;
+
+      for( y=0; y < 256; y++ )
+          for( x=0; x < 256; x++ )
+              permutation2D[x*4 + y*1024] = permutation256[(y + permutation256[x]) & 0xff];
+
+      initialized = true;
+  }
+
+  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, permutation2D );
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
+}
+
+void OGLTransitionImpl::preparePermShader()
+{
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        OGLShaders::glUseProgram( mProgramObject );
+
+        GLint location = OGLShaders::glGetUniformLocation( mProgramObject, "leavingSlideTexture" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1i( location, 0 );  // texture unit 0
+        }
+
+        glActiveTexture(GL_TEXTURE1);
+        if( !maHelperTexture )
+            initPermTexture( &maHelperTexture );
+        glActiveTexture(GL_TEXTURE0);
+
+        location = OGLShaders::glGetUniformLocation( mProgramObject, "permTexture" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1i( location, 1 );  // texture unit 1
+        }
+
+        location = OGLShaders::glGetUniformLocation( mProgramObject, "enteringSlideTexture" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1i( location, 2 );  // texture unit 2
+        }
+    }
+#endif
+}
+
+void OGLTransitionImpl::prepareStatic( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
+{
+    mProgramObject = OGLShaders::LinkProgram( basicVertexShader, staticFragmentShader );
+
+    preparePermShader();
+}
+
+void OGLTransitionImpl::displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                              double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        GLint location = OGLShaders::glGetUniformLocation( mProgramObject, "time" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1f( location, nTime );
+        }
+    }
+
+    glActiveTexture( GL_TEXTURE2 );
+    glBindTexture( GL_TEXTURE_2D, glEnteringSlideTex );
+    glActiveTexture( GL_TEXTURE0 );
+#endif
+
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+}
+
+void OGLTransitionImpl::makeStatic()
+{
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
+    mmPrepareTransition = &OGLTransitionImpl::prepareStatic;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+
+    mnRequiredGLVersion = 2.0;
+}
+
+void OGLTransitionImpl::prepareDissolve( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
+{
+    mProgramObject = OGLShaders::LinkProgram( basicVertexShader, dissolveFragmentShader );
+
+    preparePermShader();
+}
+
+void OGLTransitionImpl::makeDissolve()
+{
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
+    mmPrepareTransition = &OGLTransitionImpl::prepareDissolve;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+
+    mnRequiredGLVersion = 2.0;
+}
+
+void OGLTransitionImpl::makeNewsflash()
+{
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),3000,true,0,0.5));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),true,0,0.5));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-10000, 0, 0),false, 0.5, 2));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),-3000,true,0.5,1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-100, 0, 0),false, -1, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(100, 0, 0),false, 0.5, 1));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),false,-1,1));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(100,100,100),basegfx::B3DVector(0,0,0),true,0.5,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0.2,0.2,0),1080,true,0,1));
+}
+
diff --git slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.hxx slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.hxx
new file mode 100644
index 0000000..2aa0529
--- /dev/null
+++ slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionImpl.hxx
@@ -0,0 +1,509 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionImpl.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+#define INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+
+#include <basegfx/vector/b2dvector.hxx>
+#include <basegfx/vector/b3dvector.hxx>
+
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+
+#if defined( WNT ) 
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+#elif defined( OS2 )
+#elif defined( QUARTZ )
+#elif defined( UNX )
+#endif    	
+
+#include <vector>
+#include <GL/gl.h>
+
+using namespace std;
+
+class Primitive;
+class Operation;
+class SceneObject;
+
+
+/** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
+
+    This class is capable of making itself into many difference transitions. It holds Primitives and Operations on those primitives.
+*/
+class OGLTransitionImpl
+{
+public:
+    OGLTransitionImpl() :
+        mbUseMipMapLeaving( true ),
+        mbUseMipMapEntering( true ),
+        mnRequiredGLVersion( 1.0 ),
+        maLeavingSlidePrimitives(),
+        maEnteringSlidePrimitives(),
+        maSceneObjects(),
+        mbReflectSlides( false ),
+        mVertexObject( 0 ),
+        mFragmentObject( 0 ),
+        mProgramObject( 0 ),
+        maHelperTexture( 0 ),
+        mmPrepare( NULL ),
+        mmPrepareTransition( NULL ),
+        mmClearTransition( NULL ),
+        mmDisplaySlides( NULL )
+    {}
+
+    ~OGLTransitionImpl();
+    
+    void prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
+    void finish();
+
+    void makeOutsideCubeFaceToLeft();
+    void makeInsideCubeFaceToLeft();
+    void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
+    void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
+    void makeHelix( ::sal_uInt16 nRows );
+    void makeFallLeaving();
+    void makeTurnAround();
+    void makeTurnDown();
+    void makeIris();
+    void makeRochade();
+    void makeVenetianBlinds( bool vertical, int parts );
+    void makeStatic();
+    void makeDissolve();
+    void makeNewsflash();
+
+    /** 2D replacements
+     */
+    void makeDiamond();
+    void makeFadeSmoothly();
+    void makeFadeThroughBlack();
+
+    /** Whether to use mipmaping for slides textures
+     */
+    bool mbUseMipMapLeaving;
+    bool mbUseMipMapEntering;
+
+    /** which GL version does the transition require
+     */
+    float mnRequiredGLVersion;
+
+private:
+    /** clears all the primitives and operations
+    */
+    void clear();
+    
+    /** All the primitives that use the leaving slide texture
+    */
+    vector<Primitive> maLeavingSlidePrimitives;
+    
+    /** All the primitives that use the leaving slide texture
+    */
+    vector<Primitive> maEnteringSlidePrimitives;
+    
+    /** All the surrounding scene objects
+    */
+    vector<SceneObject*> maSceneObjects;
+
+    /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+    */
+    vector<Operation*> OverallOperations;
+
+    /** Whether to reflect slides, the reflection happens on flat surface beneath the slides.
+     ** Now it only works with slides which keep their rectangular shape together.
+     */
+    bool mbReflectSlides;
+
+    /** GLSL objects, shaders and program
+     */
+    GLuint mVertexObject, mFragmentObject, mProgramObject;
+
+    /** various data */
+    GLuint maHelperTexture;
+
+    /** When this method is not NULL, it is called in display method to prepare the slides, scene, etc.
+     ** We might later replace this by cleaner derived class.
+     */
+    void (OGLTransitionImpl::*mmPrepare)( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
+
+    /** When this method is not NULL, it is called after glx context is ready to let the transition prepare GL related things, like GLSL program.
+     ** We might later replace this by cleaner derived class.
+     */
+    void (OGLTransitionImpl::*mmPrepareTransition)( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+
+    /** When this method is not NULL, it is called when the transition needs to clear after itself, like delete own textures etc.
+     ** We might later replace this by cleaner derived class.
+     */
+    void (OGLTransitionImpl::*mmClearTransition)();
+
+    /** When this method is not NULL, it is called in display method to display the slides.
+     ** We might later replace this by cleaner derived class.
+     */
+    void (OGLTransitionImpl::*mmDisplaySlides)( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+
+    void displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+    void displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives, double SlideWidthScale, double SlideHeightScale );
+    void displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    void applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale );
+
+    /** various transitions helper methods
+     */
+    void prepareDiamond( double nTime, double SlideWidth, double SlideHeight,double DispWidth, double DispHeight );
+    void displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+        void displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+        void displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+    void displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+    void prepareStatic( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+    void prepareDissolve( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+    void preparePermShader();
+};
+
+class SceneObject
+{
+public:
+    SceneObject();
+
+    virtual void prepare() {};
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish() {};
+
+    void pushPrimitive (const Primitive &p);
+
+protected:
+    /** All the surrounding scene primitives
+    */
+    vector<Primitive> maPrimitives;
+};
+
+class Iris : public SceneObject
+{
+public:
+    Iris ();
+
+    virtual void prepare();
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish();
+
+private:
+
+    GLuint maTexture;
+};
+
+/** This class is a list of Triangles that will share Operations, and could possibly share  
+*/
+class Primitive
+{
+public:
+    Primitive() {}
+    // making copy constructor explicit makes the class un-suitable for use with stl containers
+    Primitive(const Primitive& rvalue);
+    ~Primitive();
+
+    void applyOperations(double nTime, double SlideWidthScale, double SlideHeightScale);
+    void display(double nTime, double SlideWidthScale, double SlideHeightScale);
+    const Primitive& operator=(const Primitive& rvalue);
+    
+    /** PushBack a vertex,normal, and tex coord. Each SlideLocation is where on the slide is mapped to this location ( from (0,0) to (1,1)  ). This will make sure the correct aspect ratio is used, and helps to make slides begin and end at the correct position. (0,0) is the top left of the slide, and (1,1) is the bottom right.
+    
+    @param SlideLocation0
+    Location of first Vertex on slide
+    
+    @param SlideLocation1
+    Location of second Vertex on slide
+    
+    @param SlideLocation2
+    Location of third Vertex on slide
+    
+    */
+    void pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2);
+    
+    /** clear all the vertices, normals, tex coordinates, and normals
+    */
+    void clearTriangles();
+    
+    /** guards against directly changing the vertices
+        
+        @return        
+        the list of vertices
+    */
+    const vector<basegfx::B3DVector>& getVertices() const {return Vertices;}
+    
+    /** guards against directly changing the vertices
+    */
+    const vector<basegfx::B3DVector>& getNormals() const {return Normals;}
+    
+    /** guards against directly changing the vertices
+    
+        @return        
+        the list of Texture Coordinates
+    
+    */
+    const vector<basegfx::B2DVector>& getTexCoords() const {return TexCoords;}
+
+    /** list of Operations to be performed on this primitive.These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+    
+        @return        
+        the list of Operations
+    
+    */    
+    vector<Operation*> Operations;
+
+private:
+    /** list of vertices
+    */
+    vector<basegfx::B3DVector> Vertices;
+    
+    /** list of Normals
+    */
+    vector<basegfx::B3DVector> Normals;
+    
+    /** list of Texture Coordinates
+    */
+    vector<basegfx::B2DVector> TexCoords;
+};
+
+/** This class is to be derived to make any operation (tranform) you may need in order to construct your transitions
+*/
+class Operation
+{
+public:
+    Operation(){}
+    virtual ~Operation(){}
+    
+    /** Should this operation be interpolated . If TRUE, the transform will smoothly move from making no difference from t = 0.0 to nT0 to being completely transformed from t = nT1 to 1. If FALSE, the transform will be inneffectual from t = 0 to nT0, and completely transformed from t = nT0 to 1. 
+    */
+    bool bInterpolate;
+    
+    /** time to begin the transformation
+    */
+    double nT0;
+    
+    /** time to finish the transformation
+    */
+    double nT1;
+public:
+    /** this is the function that is called to give the Operation to OpenGL.
+        
+        @param t
+        time from t = 0 to t = 1
+        
+        @param SlideWidthScale
+        width of slide divided by width of window
+        
+        @param SlideHeightScale
+        height of slide divided by height of window
+    
+    */
+    virtual void interpolate(double t,double SlideWidthScale,double SlideHeightScale) = 0;
+    
+    /** return a copy of this operation
+    */
+    virtual Operation* clone() = 0;
+};
+
+/** this class is a generic CounterClockWise(CCW) rotation with an axis angle
+*/
+class SRotate: public Operation
+{
+public:
+    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    virtual SRotate* clone();
+    
+    /** Constructor
+        
+        @param Axis
+        axis to rotate about
+        
+        @param Origin
+        position that rotation axis runs through
+        
+        @param Angle
+        angle in radians of CCW rotation
+        
+        @param bInter
+        see Operation
+        
+        @param T0
+        transformation starting time
+        
+        @param T1
+        transformation ending time
+    
+    */
+    SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+    ~SRotate(){}
+private:
+    /** axis to rotate CCW about
+    */
+    basegfx::B3DVector axis;
+    
+    /** position that rotation axis runs through
+    */
+    basegfx::B3DVector origin;
+    
+    /** angle in radians of CCW rotation
+    */
+    double angle;
+};
+
+/** scaling transformation
+*/
+class SScale: public Operation
+{
+public:
+    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SScale* clone();
+    
+    /** Constructor
+        
+        @param Scale
+        amount to scale by 
+        
+        @param Origin
+        position that rotation axis runs through
+        
+        @param bInter
+        see Operation
+        
+        @param T0
+        transformation starting time
+        
+        @param T1
+        transformation ending time
+    
+    */
+    SScale(const basegfx::B3DVector& Scale, const basegfx::B3DVector& Origin,bool bInter, double T0, double T1);
+    ~SScale(){}
+private:
+    basegfx::B3DVector scale;
+    basegfx::B3DVector origin;
+};
+
+/** translation transformation
+*/
+class STranslate: public Operation
+{
+public:
+    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    STranslate* clone();
+    
+    /** Constructor
+        
+        @param Vector
+        vector to translate
+        
+        @param bInter
+        see Operation
+        
+        @param T0
+        transformation starting time
+        
+        @param T1
+        transformation ending time
+    
+    */
+    STranslate(const basegfx::B3DVector& Vector,bool bInter, double T0, double T1);
+    ~STranslate(){}
+private:
+    /** vector to translate by
+    */
+    basegfx::B3DVector vector;
+};
+
+/** translation transformation
+*/
+class SEllipseTranslate: public Operation
+{
+public:
+    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SEllipseTranslate* clone();
+    
+    /** Constructor
+        
+        @param Vector
+        vector to translate
+        
+        @param bInter
+        see Operation
+        
+        @param T0
+        transformation starting time
+        
+        @param T1
+        transformation ending time
+    
+    */
+    SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1);
+    ~SEllipseTranslate(){}
+private:
+    /** width and length of the ellipse
+     */
+    double width, height;
+
+    /** start and end position on the ellipse <0,1>
+     */
+    double startPosition;
+    double endPosition;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
+*/
+class RotateAndScaleDepthByWidth: public Operation
+{
+public:
+    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByWidth* clone();
+
+    RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+    ~RotateAndScaleDepthByWidth(){}
+private:
+    basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+    double angle;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the height of the window.
+*/
+class RotateAndScaleDepthByHeight: public Operation
+{
+public:
+    void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByHeight* clone();
+
+    RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+    ~RotateAndScaleDepthByHeight(){}
+private:
+    basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+    double angle;
+};
+
+#endif // INCLUDED_SLIDESHOW_TRANSITION_HXX_
+
diff --git slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionerImpl_LINUX.cxx slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionerImpl_LINUX.cxx
new file mode 100644
index 0000000..01d513c
--- /dev/null
+++ slideshow/source/engine/OGLTrans/unx/OGLTrans_TransitionerImpl_LINUX.cxx
@@ -0,0 +1,1487 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionerImpl.cxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#define GLX_GLXEXT_PROTOTYPES 1
+#include "OGLTrans_TransitionImpl.hxx"
+
+#include <com/sun/star/beans/XFastPropertySet.hpp>
+#include <com/sun/star/rendering/IntegerBitmapLayout.hpp>
+#include <com/sun/star/rendering/ColorComponentTag.hpp>
+#include <com/sun/star/rendering/ColorSpaceType.hpp>
+#include <com/sun/star/animations/TransitionType.hpp>
+#include <com/sun/star/animations/TransitionSubType.hpp>
+#include <com/sun/star/presentation/XTransitionFactory.hpp>
+#include <com/sun/star/presentation/XTransition.hpp>
+#include <com/sun/star/presentation/XSlideShowView.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#include <com/sun/star/geometry/IntegerSize2D.hpp>
+
+#include <cppuhelper/compbase1.hxx>
+#include <cppuhelper/basemutex.hxx>
+#include <cppuhelper/factory.hxx>
+#include <rtl/ref.hxx>
+
+#include <comphelper/servicedecl.hxx>
+
+#include <canvas/canvastools.hxx>
+#include <tools/gen.hxx>
+#include <vcl/window.hxx>
+#include <vcl/syschild.hxx>
+
+#include <boost/noncopyable.hpp>
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+
+#if defined( WNT ) 
+    #include <tools/prewin.h>
+    #include <windows.h>
+    #include <tools/postwin.h>
+    #define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
+    #define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+#elif defined( OS2 )
+#elif defined( QUARTZ )
+    #include "premac.h"
+    #include <Cocoa/Cocoa.h>
+    #include "postmac.h"
+#elif defined( UNX )
+namespace unx
+{
+#include <X11/keysym.h>
+#include <X11/X.h>
+#include <GL/glx.h>
+#include <GL/glxext.h>
+}
+#endif
+#include <vcl/sysdata.hxx>
+
+#ifdef DEBUG
+#include <boost/date_time/posix_time/posix_time.hpp>
+using namespace ::boost::posix_time;
+
+static ptime t1;
+static ptime t2;
+
+#define DBG(x) x
+#else
+#define DBG(x)
+#endif
+
+using namespace ::com::sun::star;
+using ::com::sun::star::beans::XFastPropertySet;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+
+namespace
+{
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransition> OGLTransitionerImplBase;
+
+namespace
+{
+    struct OGLFormat
+    {
+        GLint  nInternalFormat;
+        GLenum eFormat;
+        GLenum eType;
+    };
+
+    /* channel ordering: (0:rgba, 1:bgra, 2:argb, 3:abgr)  
+    */
+    int calcComponentOrderIndex(const uno::Sequence<sal_Int8>& rTags)
+    {
+        using namespace rendering::ColorComponentTag;
+
+        static const sal_Int8 aOrderTable[] =
+        {
+            RGB_RED, RGB_GREEN, RGB_BLUE, ALPHA,
+            RGB_BLUE, RGB_GREEN, RGB_RED, ALPHA,
+            ALPHA, RGB_RED, RGB_GREEN, RGB_BLUE,
+            ALPHA, RGB_BLUE, RGB_GREEN, RGB_RED, 
+        };
+
+        const sal_Int32 nNumComps(rTags.getLength());
+        const sal_Int8* pLine=aOrderTable;
+        for(int i=0; i<4; ++i)
+        {
+            int j=0;
+            while( j<4 && j<nNumComps && pLine[j] == rTags[j] )
+                ++j;
+
+            // all of the line passed, this is a match!
+            if( j==nNumComps )
+                return i;
+
+            pLine+=4;
+        }
+
+        return -1;
+    }
+}
+
+// not thread safe
+static bool errorTriggered;
+int oglErrorHandler( unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/ )
+{
+    errorTriggered = true;
+
+    return 0;
+}
+
+/** This is the Transitioner class for OpenGL 3D transitions in
+ * slideshow. At the moment, it's Linux only. This class is implicitly
+ * constructed from XTransitionFactory.
+*/
+class OGLTransitionerImpl : private cppu::BaseMutex, private boost::noncopyable, public OGLTransitionerImplBase
+{
+public:
+    explicit OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition);
+    bool initWindowFromSlideShowView( const uno::Reference< presentation::XSlideShowView >& xView );
+    void setSlides( const Reference< rendering::XBitmap >& xLeavingSlide , const uno::Reference< rendering::XBitmap >& xEnteringSlide );
+    static bool initialize( const Reference< presentation::XSlideShowView >& xView );
+
+    // XTransition
+    virtual void SAL_CALL update( double nTime )
+    throw (uno::RuntimeException);
+    virtual void SAL_CALL viewChanged( const Reference< presentation::XSlideShowView >& rView,
+                       const Reference< rendering::XBitmap >& rLeavingBitmap,
+                       const Reference< rendering::XBitmap >& rEnteringBitmap )
+    throw (uno::RuntimeException);
+    
+protected:
+    void disposeContextAndWindow();
+    void disposeTextures();
+
+    // WeakComponentImplHelperBase
+    virtual void SAL_CALL disposing();
+    
+    bool isDisposed() const
+    {
+        return (rBHelper.bDisposed || rBHelper.bInDispose);
+    }
+
+    bool createWindow( Window* pPWindow );
+    void createTexture( unsigned int* texID,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+            unx::GLXPixmap pixmap,
+            bool usePixmap,
+#endif
+            bool useMipmap,
+            uno::Sequence<sal_Int8>& data,
+            const OGLFormat* pFormat );
+    void prepareEnvironment ();
+    const OGLFormat* chooseFormats();
+
+private:    
+    /** After the window has been created, and the slides have been set, we'll initialize the slides with OpenGL.
+    */
+    void GLInitSlides();
+
+
+    /// Holds the information of our new child window
+    struct GLWindow
+    {
+#if defined( WNT ) 
+    HWND					hWnd;
+    HDC						hDC;
+    HGLRC					hRC;
+#elif defined( OS2 )
+#elif defined( QUARTZ )
+#elif defined( UNX )
+    unx::Display*           dpy;
+    int                     screen;
+    unx::Window             win;
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::GLXFBConfig        fbc;
+#endif
+    unx::XVisualInfo*       vi;
+    unx::GLXContext         ctx;
+#endif
+        unsigned int            bpp;
+        unsigned int            Width;
+        unsigned int            Height;
+        const char*             GLXExtensions;
+    const GLubyte*          GLExtensions;
+
+        bool HasGLXExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, (const GLubyte*) GLXExtensions ); }
+    bool HasGLExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, GLExtensions ); }
+    } GLWin;
+    
+    /** OpenGL handle to the leaving slide's texture
+    */
+    unsigned int GLleavingSlide;
+    /** OpenGL handle to the entering slide's texture
+    */
+    unsigned int GLenteringSlide;
+    
+    /** pointer to our window which we MIGHT create.
+    */
+    class SystemChildWindow* pWindow;
+
+    Reference< presentation::XSlideShowView > mxView;
+    Reference< rendering::XIntegerBitmap > mxLeavingBitmap;
+    Reference< rendering::XIntegerBitmap > mxEnteringBitmap;
+    
+    /** raw bytes of the entering bitmap
+    */
+    uno::Sequence<sal_Int8> EnteringBytes;
+    
+    /** raw bytes of the leaving bitmap
+    */
+    uno::Sequence<sal_Int8> LeavingBytes;
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::GLXPixmap LeavingPixmap;
+    unx::GLXPixmap EnteringPixmap;
+#endif
+    bool mbRestoreSync;
+    bool mbUseLeavingPixmap;
+    bool mbUseEnteringPixmap;
+    bool mbFreeLeavingPixmap;
+    bool mbFreeEnteringPixmap;
+    unx::Pixmap maLeavingPixmap;
+    unx::Pixmap maEnteringPixmap;
+    
+    /** the form the raw bytes are in for the bitmaps
+    */
+    rendering::IntegerBitmapLayout SlideBitmapLayout; 
+    
+    /** the size of the slides
+    */    
+    geometry::IntegerSize2D SlideSize;
+    
+    /** Our Transition to be used.
+    */    
+    OGLTransitionImpl* pTransition;
+
+public:
+    /** whether we are running on ATI fglrx with bug related to textures
+     */
+    static bool cbBrokenTexturesATI;
+
+    /** GL version
+     */
+    static float cnGLVersion;
+    float mnGLXVersion;
+
+    /** Whether Mesa is the OpenGL vendor
+     */
+    static bool cbMesa;
+
+    /**
+       whether the display has GLX extension
+     */
+    static bool cbGLXPresent;
+
+    /**
+       whether texture from pixmap extension is available
+    */
+    bool mbTextureFromPixmap;
+
+    /**
+       whether to generate mipmaped textures
+    */
+    bool mbGenerateMipmap;
+
+    /**
+       whether we have visual which can be used for texture_from_pixmap extension
+    */
+    bool mbHasTFPVisual;
+
+#ifdef DEBUG
+    ptime t3;
+    ptime t4;
+    ptime t5;
+    ptime t6;
+    time_duration total_update;
+    int frame_count;
+#endif
+};
+
+// declare the static variables as some gcc versions have problems declaring them automaticaly
+bool OGLTransitionerImpl::cbBrokenTexturesATI;
+float OGLTransitionerImpl::cnGLVersion;
+bool OGLTransitionerImpl::cbMesa;
+bool OGLTransitionerImpl::cbGLXPresent;
+
+bool OGLTransitionerImpl::initialize( const Reference< presentation::XSlideShowView >& xView )
+{
+    // not thread safe
+    static bool initialized = false;
+
+    if( !initialized ) {
+        OGLTransitionerImpl *instance;
+
+        instance = new OGLTransitionerImpl( NULL );
+        if( instance->initWindowFromSlideShowView( xView ) ) {
+
+            const GLubyte* version = glGetString( GL_VERSION );
+            if( version && version[0] ) {
+                cnGLVersion = version[0] - '0';
+                if( version[1] == '.' && version[2] )
+                    cnGLVersion += (version[2] - '0')/10.0;
+            } else
+                cnGLVersion = 1.0;
+            OSL_TRACE("GL version: %s parsed: %f", version, cnGLVersion );
+
+            const GLubyte* vendor = glGetString( GL_VENDOR );
+            cbMesa = ( vendor && strstr( (const char *) vendor, "Mesa" ) );
+            OSL_TRACE("GL vendor: %s identified as Mesa: %d", vendor, cbMesa );
+
+            /* TODO: check for version once the bug in fglrx driver is fixed */
+            cbBrokenTexturesATI = (vendor && strcmp( (const char *) vendor, "ATI Technologies Inc." ) == 0 );
+
+            instance->disposing();
+            cbGLXPresent = true;
+        } else
+            cbGLXPresent = false;
+
+        delete instance;
+        initialized = true;
+    }
+
+    return cbGLXPresent;
+}
+
+bool OGLTransitionerImpl::createWindow( Window* pPWindow )
+{
+    const SystemEnvData* sysData(pPWindow->GetSystemData());
+#if defined( WNT ) 
+    GLWin.hWnd = sysData->hWnd;
+#elif defined( UNX )
+    GLWin.dpy = reinterpret_cast<unx::Display*>(sysData->pDisplay);
+
+    if( unx::glXQueryExtension( GLWin.dpy, NULL, NULL ) == false )
+        return false;
+
+    GLWin.win = sysData->aWindow;
+
+    OSL_TRACE("parent window: %d", GLWin.win);
+
+    unx::XWindowAttributes xattr;
+    unx::XGetWindowAttributes( GLWin.dpy, GLWin.win, &xattr );
+
+    GLWin.screen = XScreenNumberOfScreen( xattr.screen );
+
+    unx::XVisualInfo* vi( NULL );
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::XVisualInfo* visinfo;
+    unx::XVisualInfo* firstVisual( NULL );
+#endif
+    static int attrList3[] =
+        {
+        GLX_RGBA,//only TrueColor or DirectColor
+            //single buffered
+            GLX_RED_SIZE,4,//use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,//use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,//use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,0,//no depth buffer
+            None
+        };
+    static int attrList2[] = 
+    {
+        GLX_RGBA,//only TrueColor or DirectColor
+            /// single buffered
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+            None
+        };
+    static int attrList1[] =
+        {
+        GLX_RGBA,//only TrueColor or DirectColor
+            GLX_DOUBLEBUFFER,/// only double buffer
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,0,/// no depth buffer
+            None
+        };
+    static int attrList0[] =
+        {
+        GLX_RGBA,//only TrueColor or DirectColor
+            GLX_DOUBLEBUFFER,/// only double buffer
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+            None
+       }; 
+    static int* attrTable[] = 
+        {
+            attrList0,
+            attrList1,
+            attrList2,
+            attrList3,
+            NULL
+        };
+    int** pAttributeTable = attrTable;
+    const SystemEnvData* pChildSysData = NULL;
+    delete pWindow;
+    pWindow=NULL;
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::GLXFBConfig* fbconfigs = NULL;
+    int nfbconfigs, value, i = 0;
+#endif
+
+    while( *pAttributeTable )
+    {
+        // try to find a visual for the current set of attributes
+        vi = unx::glXChooseVisual( GLWin.dpy,
+                                   GLWin.screen,
+                                   *pAttributeTable );
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+      if( vi ) {
+      if( !firstVisual )
+          firstVisual = vi;
+      OSL_TRACE("trying VisualID %08X", vi->visualid);
+          fbconfigs = glXGetFBConfigs (GLWin.dpy, GLWin.screen, &nfbconfigs);
+          for ( ; i < nfbconfigs; i++)
+          {
+              visinfo = glXGetVisualFromFBConfig (GLWin.dpy, fbconfigs[i]);
+              if( !visinfo || visinfo->visualid != vi->visualid )
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i], GLX_DRAWABLE_TYPE, &value);
+              if (!(value & GLX_PIXMAP_BIT))
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
+                                    GLX_BIND_TO_TEXTURE_TARGETS_EXT,
+                                    &value);
+              if (!(value & GLX_TEXTURE_2D_BIT_EXT))
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
+                                    GLX_BIND_TO_TEXTURE_RGB_EXT,
+                                    &value);
+              if (value == FALSE)
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
+                                    GLX_BIND_TO_MIPMAP_TEXTURE_EXT,
+                                    &value);
+              if (value == FALSE)
+                  continue;
+
+              /* TODO: handle non Y inverted cases */
+              break;
+          }
+
+          if( i != nfbconfigs || ( firstVisual && pAttributeTable[1] == NULL ) ) {
+          if( i != nfbconfigs ) {
+          vi = glXGetVisualFromFBConfig( GLWin.dpy, fbconfigs[i] );
+          mbHasTFPVisual = true;
+          OSL_TRACE("found visual suitable for texture_from_pixmap");
+          } else {
+          vi = firstVisual;
+          mbHasTFPVisual = false;
+          OSL_TRACE("did not find visual suitable for texture_from_pixmap, using %08X", vi->visualid);
+          }
+#else
+      if( vi ) {
+#endif
+              SystemWindowData winData;
+              winData.nSize = sizeof(winData);
+          OSL_TRACE("using VisualID %08X", vi->visualid);
+              winData.pVisual = (void*)(vi->visual);
+              pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
+              pChildSysData = pWindow->GetSystemData();
+              if( pChildSysData ) {
+                  break;
+              } else {
+                  delete pWindow, pWindow=NULL;
+              }
+          }
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+      }
+#endif
+
+        ++pAttributeTable;
+      }
+#endif
+
+#if defined( WNT ) 
+      const SystemEnvData* pChildSysData = NULL;
+      SystemWindowData winData;
+      winData.nSize = sizeof(winData);
+      pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
+      pChildSysData = pWindow->GetSystemData();
+#endif            
+
+      if( pWindow )
+      {
+      pWindow->SetMouseTransparent( TRUE );
+      pWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+      pWindow->EnableEraseBackground( FALSE );
+      pWindow->SetControlForeground();
+      pWindow->SetControlBackground();
+      pWindow->EnablePaint(FALSE);
+#if defined( WNT ) 
+        GLWin.hWnd = sysData->hWnd;
+#elif defined( UNX )
+        GLWin.dpy = reinterpret_cast<unx::Display*>(pChildSysData->pDisplay);
+        GLWin.win = pChildSysData->aWindow;
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    if( mbHasTFPVisual )
+        GLWin.fbc = fbconfigs[i];
+#endif
+    GLWin.vi = vi;
+    GLWin.GLXExtensions = unx::glXQueryExtensionsString( GLWin.dpy, GLWin.screen );
+    OSL_TRACE("available GLX extensions: %s", GLWin.GLXExtensions);
+#endif
+
+    return true;
+    }
+
+    return false;
+}
+
+bool OGLTransitionerImpl::initWindowFromSlideShowView( const Reference< presentation::XSlideShowView >& xView )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return false;
+
+    mxView.set( xView, UNO_QUERY );
+    if( !mxView.is() )
+    return false;
+
+    /// take the XSlideShowView and extract the parent window from it. see viewmediashape.cxx
+    uno::Reference< rendering::XCanvas > xCanvas(mxView->getCanvas(), uno::UNO_QUERY_THROW);
+    uno::Sequence< uno::Any > aDeviceParams;
+    ::canvas::tools::getDeviceInfo( xCanvas, aDeviceParams );
+
+    ::rtl::OUString aImplName;
+    aDeviceParams[ 0 ] >>= aImplName;
+
+    sal_Int64 aVal = 0;
+    aDeviceParams[1] >>= aVal;
+    if( !createWindow( reinterpret_cast< Window* >( aVal ) ) )
+    return false;
+
+    awt::Rectangle aCanvasArea = mxView->getCanvasArea();
+    pWindow->SetPosSizePixel(aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
+    GLWin.Width = aCanvasArea.Width;
+    GLWin.Height = aCanvasArea.Height;
+    OSL_TRACE("canvas area: %d,%d - %dx%d", aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
+
+#if defined( WNT ) 
+        GLWin.hDC = GetDC(GLWin.hWnd);
+#elif defined( UNX )
+    GLWin.ctx = glXCreateContext(GLWin.dpy,
+                                 GLWin.vi,
+                                 0,
+                                 GL_TRUE);
+    if( GLWin.ctx == NULL ) {
+    OSL_TRACE("unable to create GLX context");
+    return false;
+    }
+#endif
+
+#if defined( WNT ) 
+    PIXELFORMATDESCRIPTOR PixelFormatFront =					// PixelFormat Tells Windows How We Want Things To Be
+    {
+        sizeof(PIXELFORMATDESCRIPTOR),
+        1,								// Version Number
+        PFD_DRAW_TO_WINDOW |
+        PFD_SUPPORT_OPENGL |
+        PFD_DOUBLEBUFFER,
+        PFD_TYPE_RGBA,					// Request An RGBA Format
+        (BYTE)32,						// Select Our Color Depth
+        0, 0, 0, 0, 0, 0,				// Color Bits Ignored
+        0,								// No Alpha Buffer
+        0,								// Shift Bit Ignored
+        0,								// No Accumulation Buffer
+        0, 0, 0, 0,						// Accumulation Bits Ignored
+        64,								// 32 bit Z-BUFFER
+        0,								// 0 bit stencil buffer
+        0,								// No Auxiliary Buffer
+        0,								// now ignored
+        0,								// Reserved
+        0, 0, 0							// Layer Masks Ignored
+    };
+    int WindowPix = ChoosePixelFormat(GLWin.hDC,&PixelFormatFront);
+    SetPixelFormat(GLWin.hDC,WindowPix,&PixelFormatFront);
+    GLWin.hRC  = wglCreateContext(GLWin.hDC);
+    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
+#elif defined( UNX )
+    if( !glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx ) ) {
+        OSL_TRACE("unable to select current GLX context");
+        return false;
+    }
+
+    int glxMinor, glxMajor;
+    mnGLXVersion = 0;
+    if( glXQueryVersion( GLWin.dpy, &glxMajor, &glxMinor ) )
+      mnGLXVersion = glxMajor + 0.1*glxMinor;
+    OSL_TRACE("available GLX version: %f", mnGLXVersion);
+
+    GLWin.GLExtensions = glGetString( GL_EXTENSIONS );
+    OSL_TRACE("available GL  extensions: %s", GLWin.GLExtensions);
+
+    mbTextureFromPixmap = GLWin.HasGLXExtension( "GLX_EXT_texture_from_pixmap" );
+    mbGenerateMipmap = GLWin.HasGLExtension( "GL_SGIS_generate_mipmap" );
+
+    if( GLWin.HasGLXExtension("GLX_SGI_swap_control" ) ) {
+        // enable vsync
+        typedef GLint (*glXSwapIntervalProc)(GLint);
+        glXSwapIntervalProc glXSwapInterval = (glXSwapIntervalProc) unx::glXGetProcAddress( (const GLubyte*) "glXSwapIntervalSGI" );
+        if( glXSwapInterval ) {
+        int (*oldHandler)(unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/);
+
+        // replace error handler temporarily
+        oldHandler = unx::XSetErrorHandler( oglErrorHandler );
+
+        errorTriggered = false;
+
+        glXSwapInterval( 1 );
+
+        // sync so that we possibly get an XError
+        unx::glXWaitGL();
+        XSync(GLWin.dpy, false);
+
+        if( errorTriggered )
+            OSL_TRACE("error when trying to set swap interval, NVIDIA or Mesa bug?");
+        else
+            OSL_TRACE("set swap interval to 1 (enable vsync)");
+
+        // restore the error handler
+        unx::XSetErrorHandler( oldHandler );
+        }
+    }
+#endif
+
+    glEnable(GL_CULL_FACE);
+    glCullFace(GL_BACK);
+    glClearColor (0, 0, 0, 0);
+    glClear(GL_COLOR_BUFFER_BIT);
+#if defined( WNT ) 
+    SwapBuffers(GLWin.hDC);
+#elif defined( UNX )
+    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
+#endif
+   
+    glEnable(GL_LIGHTING);
+    GLfloat light_direction[] = { 0.0 , 0.0 , 1.0 };
+    GLfloat materialDiffuse[] = { 1.0 , 1.0 , 1.0 , 1.0};
+    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, light_direction);
+    glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
+    glEnable(GL_LIGHT0);
+    glEnable(GL_NORMALIZE);
+
+    if( LeavingBytes.hasElements() && EnteringBytes.hasElements())
+       GLInitSlides();//we already have uninitialized slides, let's initialize 
+
+    if( pTransition && pTransition->mnRequiredGLVersion <= cnGLVersion )
+        pTransition->prepare( GLleavingSlide, GLenteringSlide );
+
+    return true;
+}
+
+void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
+                                     const uno::Reference< rendering::XBitmap >& xEnteringSlide )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+        
+    mxLeavingBitmap.set( xLeavingSlide , UNO_QUERY_THROW );
+    mxEnteringBitmap.set( xEnteringSlide , UNO_QUERY_THROW );
+    Reference< XFastPropertySet > xLeavingSet( xLeavingSlide , UNO_QUERY );
+    Reference< XFastPropertySet > xEnteringSet( xEnteringSlide , UNO_QUERY );
+
+    geometry::IntegerRectangle2D SlideRect;
+    SlideSize = mxLeavingBitmap->getSize();
+    SlideRect.X1 = 0;
+    SlideRect.X2 = SlideSize.Width;
+    SlideRect.Y1 = 0;
+    SlideRect.Y2 = SlideSize.Height;
+
+    OSL_TRACE("leaving bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
+    SlideSize = mxEnteringBitmap->getSize();
+    OSL_TRACE("entering bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
+
+#ifdef UNX
+    unx::glXWaitGL();
+    XSync(GLWin.dpy, false);
+#endif
+
+#ifdef DEBUG
+    t1 = microsec_clock::local_time();
+#endif
+
+    mbUseLeavingPixmap = false;
+    mbUseEnteringPixmap = false;
+
+#ifdef UNX
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+
+    if( mnGLXVersion >= 1.2999 && mbTextureFromPixmap && xLeavingSet.is() && xEnteringSet.is() && mbHasTFPVisual ) {
+    Sequence< Any > leaveArgs;
+    Sequence< Any > enterArgs;
+    if( (xLeavingSet->getFastPropertyValue( 1 ) >>= leaveArgs) &&
+        (xEnteringSet->getFastPropertyValue( 1 ) >>= enterArgs) ) {
+        OSL_TRACE ("pixmaps available");
+
+        sal_Int32 depth;
+
+        leaveArgs[0] >>= mbFreeLeavingPixmap;
+        enterArgs[0] >>= mbFreeEnteringPixmap;
+        leaveArgs[1] >>= maLeavingPixmap;
+        enterArgs[1] >>= maEnteringPixmap;
+        leaveArgs[2] >>= depth;
+
+        int pixmapAttribs[] = { GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
+                    GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGB_EXT,
+                    GLX_MIPMAP_TEXTURE_EXT, True,
+                    None };
+
+
+        // sync so that we possibly get an pending XError, before we set our handler.
+        // this way we will not miss any error from other code
+        unx::glXWaitGL();
+        XSync(GLWin.dpy, false);
+
+        int (*oldHandler)(unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/);
+
+        // replace error handler temporarily
+        oldHandler = unx::XSetErrorHandler( oglErrorHandler );
+
+        errorTriggered = false;
+        LeavingPixmap = glXCreatePixmap( GLWin.dpy, GLWin.fbc, maLeavingPixmap, pixmapAttribs );
+
+        // sync so that we possibly get an XError
+        unx::glXWaitGL();
+        XSync(GLWin.dpy, false);
+
+        if( !errorTriggered )
+        mbUseLeavingPixmap = true;
+        else {
+        OSL_TRACE("XError triggered");
+        if( mbFreeLeavingPixmap ) {
+            unx::XFreePixmap( GLWin.dpy, maLeavingPixmap );
+            mbFreeLeavingPixmap = false;
+        }
+        errorTriggered = false;
+        }
+          
+        EnteringPixmap = glXCreatePixmap( GLWin.dpy, GLWin.fbc, maEnteringPixmap, pixmapAttribs );
+
+        // sync so that we possibly get an XError
+        unx::glXWaitGL();
+        XSync(GLWin.dpy, false);
+
+        OSL_TRACE("created glx pixmap %p and %p depth: %d", LeavingPixmap, EnteringPixmap, depth);
+        if( !errorTriggered )
+        mbUseEnteringPixmap = true;
+        else {
+        OSL_TRACE("XError triggered");
+        if( mbFreeEnteringPixmap ) {
+            unx::XFreePixmap( GLWin.dpy, maEnteringPixmap );
+            mbFreeEnteringPixmap = false;
+        }
+        }
+
+        // restore the error handler
+        unx::XSetErrorHandler( oldHandler );
+    }
+    }
+
+#endif
+#endif
+    if( !mbUseLeavingPixmap )
+    LeavingBytes = mxLeavingBitmap->getData(SlideBitmapLayout,SlideRect);
+    if( !mbUseEnteringPixmap )
+    EnteringBytes = mxEnteringBitmap->getData(SlideBitmapLayout,SlideRect);
+
+// TODO    
+#ifdef UNX
+    if(GLWin.ctx)//if we have a rendering context, let's init the slides
+#endif
+    GLInitSlides();
+
+    OSL_ENSURE(SlideBitmapLayout.PlaneStride == 0,"only handle no plane stride now");
+
+#ifdef UNX
+    /* flush & sync */
+    unx::glXWaitGL();
+    XSync( GLWin.dpy, false );
+
+    // synchronized X still gives us much smoother play
+    // I suspect some issues in above code in slideshow
+    // synchronize whole transition for now
+    XSynchronize( GLWin.dpy, true );
+    mbRestoreSync = true;
+#endif
+}
+
+void OGLTransitionerImpl::createTexture( unsigned int* texID,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+                     unx::GLXPixmap pixmap,
+                     bool usePixmap,
+#endif
+                     bool useMipmap,
+                     uno::Sequence<sal_Int8>& data,
+                     const OGLFormat* pFormat )
+{
+    glDeleteTextures( 1, texID );
+    glGenTextures( 1, texID );
+    glBindTexture( GL_TEXTURE_2D, *texID );
+    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
+    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::PFNGLXBINDTEXIMAGEEXTPROC myglXBindTexImageEXT = (unx::PFNGLXBINDTEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXBindTexImageEXT" );
+
+    if( usePixmap ) {
+      if( mbGenerateMipmap )
+          glTexParameteri( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS, True);
+      myglXBindTexImageEXT (GLWin.dpy, pixmap, GLX_FRONT_LEFT_EXT, NULL);
+      if( mbGenerateMipmap && useMipmap ) {
+          OSL_TRACE("use mipmaps");
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
+      } else {
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+      }
+    } else {
+#endif
+    if( !pFormat )
+    {
+        // force-convert color to ARGB8888 int color space  
+        uno::Sequence<sal_Int8> tempBytes(
+            SlideBitmapLayout.ColorSpace->convertToIntegerColorSpace(
+                data,
+                canvas::tools::getStdColorSpace()));
+        gluBuild2DMipmaps(GL_TEXTURE_2D, 
+                          4, 
+                          SlideSize.Width, 
+                          SlideSize.Height, 
+                          GL_RGBA, 
+                          GL_UNSIGNED_BYTE,
+                          &tempBytes[0]);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
+
+        //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+    GLfloat largest_supported_anisotropy;
+    glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy);
+    } else {
+    if( pTransition && !cbBrokenTexturesATI && !useMipmap) {
+        glTexImage2D( GL_TEXTURE_2D, 0, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, 0, pFormat->eFormat, pFormat->eType, &data[0] );
+        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+    } else {
+        gluBuild2DMipmaps( GL_TEXTURE_2D, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, pFormat->eFormat, pFormat->eType, &data[0] );
+        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR ); //TRILINEAR FILTERING
+
+        //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+        GLfloat largest_supported_anisotropy;
+        glGetFloatv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy );
+        glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy );
+    }
+    }
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    }
+#endif
+    OSL_ENSURE(glIsTexture(*texID), "Can't generate Leaving slide textures in OpenGL");
+}
+
+void OGLTransitionerImpl::prepareEnvironment()
+{
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    double EyePos(10.0);
+    double RealF(1.0);
+    double RealN(-1.0);
+    double RealL(-1.0);
+    double RealR(1.0);
+    double RealB(-1.0);
+    double RealT(1.0);
+    double ClipN(EyePos+5.0*RealN);
+    double ClipF(EyePos+15.0*RealF);
+    double ClipL(RealL*8.0);
+    double ClipR(RealR*8.0);
+    double ClipB(RealB*8.0);
+    double ClipT(RealT*8.0);
+    //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
+    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ),
+              1.0 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ),
+              1.0 );
+    glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    glTranslated(0,0,-EyePos);
+}
+
+const OGLFormat* OGLTransitionerImpl::chooseFormats()
+{
+    const OGLFormat* pDetectedFormat=NULL;
+    uno::Reference<rendering::XIntegerBitmapColorSpace> xIntColorSpace(
+        SlideBitmapLayout.ColorSpace);
+
+    if( (xIntColorSpace->getType() == rendering::ColorSpaceType::RGB ||
+         xIntColorSpace->getType() == rendering::ColorSpaceType::SRGB) )
+    {
+        /* table for canvas->OGL format mapping. outer index is number
+           of color components (0:3, 1:4), then comes bits per pixel
+           (0:16, 1:24, 2:32), then channel ordering: (0:rgba, 1:bgra,
+           2:argb, 3:abgr)
+         */
+        static const OGLFormat lcl_RGB24[] = 
+        {
+            // 24 bit RGB
+            {3, GL_BGR, GL_UNSIGNED_BYTE},
+            {3, GL_RGB, GL_UNSIGNED_BYTE},
+            {3, GL_BGR, GL_UNSIGNED_BYTE},
+            {3, GL_RGB, GL_UNSIGNED_BYTE}
+        };
+
+#if defined(GL_VERSION_1_2) && defined(GLU_VERSION_1_3)
+        // more format constants available
+        static const OGLFormat lcl_RGB16[] = 
+        {
+            // 16 bit RGB
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5}
+        };
+
+        static const OGLFormat lcl_ARGB16_4[] = 
+        {
+            // 16 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4},
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4}
+        };
+
+        static const OGLFormat lcl_ARGB16_5[] = 
+        {
+            // 16 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_5_5_5_1},
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1}
+        };
+
+        static const OGLFormat lcl_ARGB32[] = 
+        {
+            // 32 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV},
+            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV},
+            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8},
+            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8}
+        };
+
+        const uno::Sequence<sal_Int8> aComponentTags(
+            xIntColorSpace->getComponentTags());
+        const uno::Sequence<sal_Int32> aComponentBitcounts(
+            xIntColorSpace->getComponentBitCounts());
+        const sal_Int32 nNumComponents( aComponentBitcounts.getLength() );
+        const sal_Int32 nBitsPerPixel( xIntColorSpace->getBitsPerPixel() );
+
+        // supported component ordering?
+        const int nComponentOrderIndex(
+            calcComponentOrderIndex(aComponentTags));
+        if( nComponentOrderIndex != -1 ) 
+        {
+            switch( nBitsPerPixel )
+            {
+                case 16:
+                    if( nNumComponents == 3 )
+                    {
+                        pDetectedFormat = &lcl_RGB16[nComponentOrderIndex];
+                    }
+                    else if( nNumComponents == 4 )
+                    {
+                        if( aComponentBitcounts[1] == 4 )
+                        {
+                            pDetectedFormat = &lcl_ARGB16_4[nComponentOrderIndex];
+                        }
+                        else if( aComponentBitcounts[1] == 5 )
+                        {
+                            pDetectedFormat = &lcl_ARGB16_5[nComponentOrderIndex];
+                        }
+                    }
+                    break;
+                case 24:
+                    if( nNumComponents == 3 )
+                    {
+                        pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
+                    }
+                    break;
+                case 32:
+                    pDetectedFormat = &lcl_ARGB32[nComponentOrderIndex];
+                    break;
+            }
+        }
+#else
+        const uno::Sequence<sal_Int8> aComponentTags(
+            xIntColorSpace->getComponentTags());
+        const int nComponentOrderIndex(calcComponentOrderIndex(aComponentTags));
+        if( aComponentTags.getLength() == 3 && 
+            nComponentOrderIndex != -1 && 
+            xIntColorSpace->getBitsPerPixel() == 24 )
+        {
+            pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
+        }
+#endif
+    }
+
+    return pDetectedFormat;
+}
+
+void OGLTransitionerImpl::GLInitSlides()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed() || pTransition->mnRequiredGLVersion > cnGLVersion)
+        return;
+
+    prepareEnvironment();
+
+    const OGLFormat* pFormat = NULL;
+    if( !mbUseLeavingPixmap || !mbUseEnteringPixmap )
+    pFormat = chooseFormats();
+
+    createTexture( &GLleavingSlide,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+           LeavingPixmap,
+           mbUseLeavingPixmap,
+#endif
+           pTransition->mbUseMipMapLeaving,
+           LeavingBytes,
+           pFormat );
+
+    createTexture( &GLenteringSlide,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+           EnteringPixmap,
+           mbUseEnteringPixmap,
+#endif
+           pTransition->mbUseMipMapEntering,
+           EnteringBytes,
+           pFormat );
+
+#ifdef UNX
+    unx::glXWaitGL();
+    XSync(GLWin.dpy, false);
+#endif
+
+#ifdef DEBUG
+    t2 = microsec_clock::local_time();
+    OSL_TRACE("textures created in: %s", to_simple_string( t2 - t1 ).c_str());
+#endif
+}
+
+void SAL_CALL OGLTransitionerImpl::update( double nTime ) throw (uno::RuntimeException)
+{
+#ifdef DEBUG
+    frame_count ++;
+    t3 = microsec_clock::local_time();
+    if( frame_count == 1 ) {
+    t5 = t3;
+    total_update = seconds (0);
+    }
+#endif
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed() || !cbGLXPresent || pTransition->mnRequiredGLVersion > cnGLVersion)
+        return;
+
+#ifdef WNT
+    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
+#endif
+#ifdef UNX
+    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
+#endif
+
+    glEnable(GL_DEPTH_TEST);
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+    if(pTransition)
+    pTransition->display( nTime, GLleavingSlide, GLenteringSlide, 
+                              SlideSize.Width, SlideSize.Height,
+                              static_cast<double>(GLWin.Width),
+                              static_cast<double>(GLWin.Height) );
+
+#if defined( WNT ) 
+    SwapBuffers(GLWin.hDC);
+#elif defined( UNX )
+    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
+#endif
+    if( pWindow )
+        pWindow->Show();
+
+#ifdef UNX
+    /* flush & sync */
+    unx::glXWaitGL();
+    XSync( GLWin.dpy, false );
+#endif
+
+#ifdef DEBUG
+    t4 = microsec_clock::local_time();
+
+    OSL_TRACE("update time: %f", nTime);
+    OSL_TRACE("update took: %s", to_simple_string( t4 - t3 ).c_str());
+    total_update += (t4 - t3);
+#endif
+}
+
+void SAL_CALL OGLTransitionerImpl::viewChanged( const Reference< presentation::XSlideShowView >& rView,
+                        const Reference< rendering::XBitmap >& rLeavingBitmap,
+                        const Reference< rendering::XBitmap >& rEnteringBitmap )
+    throw (uno::RuntimeException)
+{
+    OSL_TRACE("transitioner: view changed");
+
+    disposeTextures();
+    disposeContextAndWindow();
+
+    initWindowFromSlideShowView( rView );
+    setSlides( rLeavingBitmap, rEnteringBitmap );
+}
+
+void OGLTransitionerImpl::disposeContextAndWindow()
+{
+#if defined( WNT )
+    if (GLWin.hRC)
+    {
+    wglMakeCurrent( GLWin.hDC, 0 );		// kill Device Context
+    wglDeleteContext( GLWin.hRC );		// Kill Render Context
+    ReleaseDC( GLWin.hWnd, GLWin.hDC );         // Release Window
+    }
+#elif defined( UNX )
+    if(GLWin.ctx)
+    {
+    glXMakeCurrent(GLWin.dpy, None, NULL);
+    if( glGetError() != GL_NO_ERROR ) {
+        OSL_TRACE("glError: %s", (char *)gluErrorString(glGetError()));
+    }
+    glXDestroyContext(GLWin.dpy, GLWin.ctx);
+    GLWin.ctx = NULL;
+    }
+#endif
+    if( pWindow ) {
+    delete pWindow;
+    pWindow = NULL;
+    GLWin.win = 0;
+    }
+}
+
+void OGLTransitionerImpl::disposeTextures()
+{
+#ifdef WNT
+    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
+#endif
+#ifdef UNX
+    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
+#endif
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::PFNGLXRELEASETEXIMAGEEXTPROC myglXReleaseTexImageEXT = (unx::PFNGLXRELEASETEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXReleaseTexImageEXT" );
+    if( mbUseLeavingPixmap ) {
+
+    myglXReleaseTexImageEXT( GLWin.dpy, LeavingPixmap, GLX_FRONT_LEFT_EXT );
+    glXDestroyGLXPixmap( GLWin.dpy, LeavingPixmap );
+    LeavingPixmap = 0;
+    if( mbFreeLeavingPixmap ) {
+        unx::XFreePixmap( GLWin.dpy, maLeavingPixmap );
+        mbFreeLeavingPixmap = false;
+        maLeavingPixmap = 0;
+    }
+    }
+    if( mbUseEnteringPixmap ) {
+    myglXReleaseTexImageEXT( GLWin.dpy, EnteringPixmap, GLX_FRONT_LEFT_EXT );
+    glXDestroyGLXPixmap( GLWin.dpy, EnteringPixmap );
+    EnteringPixmap = 0;
+    if( mbFreeEnteringPixmap ) {
+        unx::XFreePixmap( GLWin.dpy, maEnteringPixmap );
+        mbFreeEnteringPixmap = false;
+        maEnteringPixmap = 0;
+    }
+    }
+#endif
+
+    if( !mbUseLeavingPixmap ) {
+    glDeleteTextures(1,&GLleavingSlide);
+    GLleavingSlide = 0;
+    }
+    if( !mbUseEnteringPixmap ) {
+    glDeleteTextures(1,&GLenteringSlide);
+    GLleavingSlide = 0;
+    }
+
+    mbUseLeavingPixmap = false;
+    mbUseEnteringPixmap = false;
+}
+
+// we are about to be disposed (someone call dispose() on us)
+void OGLTransitionerImpl::disposing()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+#ifdef DEBUG
+    OSL_TRACE("dispose %p\n", this);
+    if( frame_count ) {
+    t6 = microsec_clock::local_time();
+    time_duration duration = t6 - t5;
+    OSL_TRACE("whole transition (frames: %d) took: %s fps: %f time spent in updates: %s percentage of transition time: %f%%",
+          frame_count, to_simple_string( duration ).c_str(),
+          ((double)frame_count*1000000000.0)/duration.total_nanoseconds(),
+          to_simple_string( total_update ).c_str(),
+          100*(((double)total_update.total_nanoseconds())/((double)duration.total_nanoseconds()))
+        );
+    }
+#endif
+
+    if( pWindow ) {
+
+    disposeTextures();
+
+    if (pTransition)
+        pTransition->finish();
+
+#ifdef UNX
+    if( mbRestoreSync ) {
+        // try to reestablish synchronize state
+        char* sal_synchronize = getenv("SAL_SYNCHRONIZE");
+        XSynchronize( GLWin.dpy, sal_synchronize && *sal_synchronize == '1' );
+    }
+#endif
+
+    disposeContextAndWindow();
+    }
+
+    if (pTransition)
+    delete pTransition;
+
+    mxLeavingBitmap.clear();
+    mxEnteringBitmap.clear();
+    mxView.clear();
+}
+
+OGLTransitionerImpl::OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition) : 
+    OGLTransitionerImplBase(m_aMutex), 
+    GLWin(),
+    GLleavingSlide( 0 ), 
+    GLenteringSlide( 0 ), 
+    pWindow( NULL ), 
+    mxView(),
+    EnteringBytes(),
+    LeavingBytes(),
+    mbRestoreSync( false ),
+    mbUseLeavingPixmap( false ),
+    mbUseEnteringPixmap( false ),
+    SlideBitmapLayout(),
+    SlideSize(),
+    pTransition(pOGLTransition)
+{
+#if defined( WNT )
+    GLWin.hWnd = 0;
+#elif defined( UNX )
+    GLWin.ctx = 0;
+#endif
+
+    DBG(frame_count = 0);
+}
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransitionFactory> OGLTransitionFactoryImplBase;
+
+class OGLTransitionFactoryImpl : private cppu::BaseMutex, public OGLTransitionFactoryImplBase
+{
+public:
+    explicit OGLTransitionFactoryImpl( const uno::Reference< uno::XComponentContext >& ) :
+        OGLTransitionFactoryImplBase(m_aMutex)
+    {}
+
+    // XTransitionFactory
+    virtual ::sal_Bool SAL_CALL hasTransition( ::sal_Int16 transitionType, ::sal_Int16 transitionSubType ) throw (uno::RuntimeException)
+    {
+        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
+            switch( transitionSubType )
+                {
+                case animations::TransitionSubType::ACROSS:
+                case animations::TransitionSubType::CORNERSOUT:
+                case animations::TransitionSubType::CIRCLE:
+                case animations::TransitionSubType::FANOUTHORIZONTAL:
+                case animations::TransitionSubType::CORNERSIN:  
+                case animations::TransitionSubType::LEFTTORIGHT:
+                case animations::TransitionSubType::TOPTOBOTTOM:
+                case animations::TransitionSubType::TOPRIGHT:
+                case animations::TransitionSubType::TOPLEFT:
+                case animations::TransitionSubType::BOTTOMRIGHT:
+                case animations::TransitionSubType::BOTTOMLEFT:
+                case animations::TransitionSubType::TOPCENTER:
+                case animations::TransitionSubType::RIGHTCENTER:
+                case animations::TransitionSubType::BOTTOMCENTER:
+                    return sal_True;
+
+                default:
+                    return sal_False;
+                }
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
+            return sal_True;
+        } else
+            return sal_False;
+    }
+
+    virtual uno::Reference< presentation::XTransition > SAL_CALL createTransition( 
+        ::sal_Int16                                           transitionType, 
+        ::sal_Int16                                           transitionSubType, 
+        const uno::Reference< presentation::XSlideShowView >& view, 
+        const uno::Reference< rendering::XBitmap >&           leavingBitmap, 
+        const uno::Reference< rendering::XBitmap >&           enteringBitmap )
+    throw (uno::RuntimeException)
+    {
+        if( !hasTransition( transitionType, transitionSubType ) )
+            return uno::Reference< presentation::XTransition >();
+
+        bool bGLXPresent = OGLTransitionerImpl::initialize( view );
+
+        if( OGLTransitionerImpl::cbMesa && (
+            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) ||
+            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) ||
+            ( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) ) )
+            return uno::Reference< presentation::XTransition >();
+            
+
+        OGLTransitionImpl* pTransition = NULL;
+
+        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
+            pTransition = new OGLTransitionImpl();
+            switch( transitionSubType )
+                {
+                case animations::TransitionSubType::ACROSS:
+                    pTransition->makeNByMTileFlip(8,6);
+                    break;   
+                case animations::TransitionSubType::CORNERSOUT:
+                    pTransition->makeOutsideCubeFaceToLeft();
+                    break;            
+                case animations::TransitionSubType::CIRCLE:
+                    pTransition->makeRevolvingCircles(8,128);
+                    break;
+                case animations::TransitionSubType::FANOUTHORIZONTAL:
+                    pTransition->makeHelix(20);
+                    break;
+                case animations::TransitionSubType::CORNERSIN:  
+                    pTransition->makeInsideCubeFaceToLeft();
+                    break;
+                case animations::TransitionSubType::LEFTTORIGHT:
+                    pTransition->makeFallLeaving();
+                    break;
+                case animations::TransitionSubType::TOPTOBOTTOM:
+                    pTransition->makeTurnAround();
+                    break;
+                case animations::TransitionSubType::TOPRIGHT:
+                    pTransition->makeTurnDown();
+                    break;
+                case animations::TransitionSubType::TOPLEFT:
+                    pTransition->makeIris();
+                    break;
+                case animations::TransitionSubType::BOTTOMRIGHT:
+                    pTransition->makeRochade();
+                    break;
+                case animations::TransitionSubType::BOTTOMLEFT:
+                    pTransition->makeVenetianBlinds( true, 8 );
+                    break;
+                case animations::TransitionSubType::TOPCENTER:
+                    pTransition->makeVenetianBlinds( false, 6 );
+                    break;
+                case animations::TransitionSubType::RIGHTCENTER:
+                    pTransition->makeStatic();
+                    break;
+                case animations::TransitionSubType::BOTTOMCENTER:
+                    pTransition->makeDissolve();
+                    break;
+                }
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeFadeSmoothly();
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeFadeThroughBlack();
+        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeDiamond();
+        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeNewsflash();
+        }
+
+        rtl::Reference<OGLTransitionerImpl> xRes(
+            new OGLTransitionerImpl(pTransition) );
+        if( bGLXPresent ) {
+            if( !xRes->initWindowFromSlideShowView(view))
+                return uno::Reference< presentation::XTransition >();
+            xRes->setSlides(leavingBitmap,enteringBitmap);
+        }
+
+        return uno::Reference<presentation::XTransition>(xRes.get());
+    }
+};
+
+}
+
+namespace sdecl = comphelper::service_decl;
+#if defined (__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ <= 3)
+ sdecl::class_<OGLTransitionFactoryImpl> serviceImpl;
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     serviceImpl,
+#else
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     sdecl::class_<OGLTransitionFactoryImpl>(),
+#endif
+    "com.sun.star.comp.presentation.OGLTransitionFactory",
+    "com.sun.star.presentation.TransitionFactory" );
+
+// The C shared lib entry points
+COMPHELPER_SERVICEDECL_EXPORTS1(OGLTransitionFactoryDecl)
diff --git slideshow/source/engine/OGLTrans/unx/makefile.mk slideshow/source/engine/OGLTrans/unx/makefile.mk
new file mode 100644
index 0000000..6f75967
--- /dev/null
+++ slideshow/source/engine/OGLTrans/unx/makefile.mk
@@ -0,0 +1,76 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.5.12.1 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..
+
+PRJNAME=slideshow
+TARGET=OGLTrans
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :      settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+# --- Nothing to do if we're compiling with --disable-opengl or if nto the right OS  -----------
+.IF "$(ENABLE_OPENGL)" != "TRUE" && "$(GUI)"!="UNX || "$(OS)"=="MACOSX"
+@all:
+	@echo "Building without OpenGL Transitions..."
+.ENDIF
+
+# --- Common ----------------------------------------------------------
+
+SLOFILES = \
+	$(SLO)$/OGLTrans_TransitionImpl_$(OS).obj \
+	$(SLO)$/OGLTrans_Shaders_$(OS).obj \
+	$(SLO)$/OGLTrans_TransitionerImpl_$(OS).obj
+
+SHL1TARGET=$(TARGET).uno
+
+SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB)
+
+SHL1STDLIBS+= \
+	-lGL \
+	-lGLU \
+	-lX11
+
+SHL1IMPLIB=i$(TARGET)
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+SHL1VERSIONMAP=../exports.map
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=../exports.dxp
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
diff --git slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders.hxx slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders.hxx
new file mode 100644
index 0000000..049c71f
--- /dev/null
+++ slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders.hxx
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_OGLTRANS_SHADERS_HXX_
+#define INCLUDED_OGLTRANS_SHADERS_HXX_
+
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glext.h>
+
+class OGLShaders {
+    static bool Initialize();
+    static bool cbInitialized;
+
+public:    
+
+    static GLuint LinkProgram( const char *vertexShader, const char *fragmentShader );
+
+    /** GL shader functions
+     */
+#ifdef GL_VERSION_2_0
+
+    static PFNGLCREATESHADERPROC glCreateShader;
+    static PFNGLSHADERSOURCEPROC glShaderSource;
+    static PFNGLCOMPILESHADERPROC glCompileShader;
+    static PFNGLGETSHADERIVPROC glGetShaderiv;
+    static PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog;
+    static PFNGLDELETESHADERPROC glDeleteShader;
+
+    static PFNGLCREATEPROGRAMPROC glCreateProgram;
+    static PFNGLATTACHSHADERPROC glAttachShader;
+    static PFNGLLINKPROGRAMPROC glLinkProgram;
+    static PFNGLGETPROGRAMIVPROC glGetProgramiv;
+    static PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog;
+    static PFNGLUSEPROGRAMPROC glUseProgram;
+    static PFNGLDELETEPROGRAMPROC glDeleteProgram;
+
+    static PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;
+    static PFNGLUNIFORM1IPROC glUniform1i;
+    static PFNGLUNIFORM1FPROC glUniform1f;
+#endif
+};
+
+#endif
diff --git slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders_WNT.cxx slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders_WNT.cxx
new file mode 100644
index 0000000..a144790
--- /dev/null
+++ slideshow/source/engine/OGLTrans/win/OGLTrans_Shaders_WNT.cxx
@@ -0,0 +1,143 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <osl/diagnose.hxx>
+
+#include "OGLTrans_Shaders.hxx"
+
+namespace unx
+{
+#include <GL/glx.h>
+#include <GL/glxext.h>
+}
+
+bool OGLShaders::cbInitialized = false;
+
+#ifdef GL_VERSION_2_0
+
+PFNGLCREATESHADERPROC OGLShaders::glCreateShader = NULL;
+PFNGLSHADERSOURCEPROC OGLShaders::glShaderSource = NULL;
+PFNGLCOMPILESHADERPROC OGLShaders::glCompileShader = NULL;
+PFNGLGETSHADERIVPROC OGLShaders::glGetShaderiv = NULL;
+PFNGLGETSHADERINFOLOGPROC OGLShaders::glGetShaderInfoLog = NULL;
+PFNGLDELETESHADERPROC OGLShaders::glDeleteShader = NULL;
+PFNGLCREATEPROGRAMPROC OGLShaders::glCreateProgram = NULL;
+PFNGLATTACHSHADERPROC OGLShaders::glAttachShader = NULL;
+PFNGLLINKPROGRAMPROC OGLShaders::glLinkProgram = NULL;
+PFNGLGETPROGRAMIVPROC OGLShaders::glGetProgramiv = NULL;
+PFNGLGETPROGRAMINFOLOGPROC OGLShaders::glGetProgramInfoLog = NULL;
+PFNGLUSEPROGRAMPROC OGLShaders::glUseProgram = NULL;
+PFNGLDELETEPROGRAMPROC OGLShaders::glDeleteProgram = NULL;
+PFNGLGETUNIFORMLOCATIONPROC OGLShaders::glGetUniformLocation = NULL;
+PFNGLUNIFORM1IPROC OGLShaders::glUniform1i = NULL;
+PFNGLUNIFORM1FPROC OGLShaders::glUniform1f = NULL;
+#endif
+
+bool OGLShaders::Initialize()
+{
+#ifdef GL_VERSION_2_0
+    if( !cbInitialized ) {
+        glCreateShader = (PFNGLCREATESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glCreateShader" );
+        glShaderSource = (PFNGLSHADERSOURCEPROC) unx::glXGetProcAddress( (unsigned char *) "glShaderSource" );
+        glCompileShader = (PFNGLCOMPILESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glCompileShader" );
+        glGetShaderiv = (PFNGLGETSHADERIVPROC) unx::glXGetProcAddress( (unsigned char *) "glGetShaderiv" );
+        glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) unx::glXGetProcAddress( (unsigned char *) "glGetShaderInfoLog" );
+        glDeleteShader = (PFNGLDELETESHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glDeleteShader" );
+        glCreateProgram = (PFNGLCREATEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glCreateProgram" );
+        glAttachShader = (PFNGLATTACHSHADERPROC) unx::glXGetProcAddress( (unsigned char *) "glAttachShader" );
+        glLinkProgram = (PFNGLLINKPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glLinkProgram" );
+        glGetProgramiv = (PFNGLGETPROGRAMIVPROC) unx::glXGetProcAddress( (unsigned char *) "glGetProgramiv" );
+        glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) unx::glXGetProcAddress( (unsigned char *) "glGetProgramInfoLog" );
+        glUseProgram = (PFNGLUSEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glUseProgram" );
+        glDeleteProgram = (PFNGLDELETEPROGRAMPROC) unx::glXGetProcAddress( (unsigned char *) "glDeleteProgram" );
+        glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) unx::glXGetProcAddress( (unsigned char *) "glGetUniformLocation" );
+        glUniform1i = (PFNGLUNIFORM1IPROC) unx::glXGetProcAddress( (unsigned char *) "glUniform1i" );
+        glUniform1f = (PFNGLUNIFORM1FPROC) unx::glXGetProcAddress( (unsigned char *) "glUniform1f" );
+        cbInitialized = true;
+    }
+
+    return glCreateShader != NULL;
+#else
+    return false;
+#endif
+}
+
+GLuint OGLShaders::LinkProgram( const char *vertexShader, const char *fragmentShader )
+{
+#ifdef GL_VERSION_2_0
+    if( !Initialize() )
+        return 0;
+
+    GLhandleARB vertexObject, fragmentObject, programObject;
+    GLint vertexCompiled, fragmentCompiled, programLinked;
+    char log[1024];
+
+    vertexObject = glCreateShader( GL_VERTEX_SHADER );
+    fragmentObject = glCreateShader( GL_FRAGMENT_SHADER );
+    OSL_TRACE("checkpoint 1: shaders created (%d) vertex: %d fragment: %d", glGetError() == GL_NO_ERROR, vertexObject, fragmentObject );
+
+
+    glShaderSource( vertexObject, 1, &vertexShader, NULL );
+    glShaderSource( fragmentObject, 1, &fragmentShader, NULL );
+
+    glCompileShader( vertexObject );
+    glGetShaderInfoLog( vertexObject, sizeof( log ), NULL, log );
+    OSL_TRACE("vertex compile log: %s", log);
+    glGetShaderiv( vertexObject, GL_COMPILE_STATUS, &vertexCompiled );
+    glCompileShader( fragmentObject );
+    glGetShaderInfoLog( fragmentObject, sizeof( log ), NULL, log );
+    OSL_TRACE("fragment compile log: %s", log);
+    glGetShaderiv( fragmentObject, GL_COMPILE_STATUS, &fragmentCompiled );
+
+    if( !vertexCompiled || !fragmentCompiled )
+        return 0;
+
+    OSL_TRACE("checkpoint 2: shaders compiled (%d)", glGetError() == GL_NO_ERROR);
+
+    programObject = glCreateProgram();
+    glAttachShader( programObject, vertexObject );
+    glAttachShader( programObject, fragmentObject );
+
+    glLinkProgram( programObject );
+    glGetProgramInfoLog( programObject, sizeof( log ), NULL, log );
+    OSL_TRACE("program link log: %s", log);
+    glGetProgramiv( programObject, GL_LINK_STATUS, &programLinked );
+
+    if( !programLinked )
+        return 0;
+
+    OSL_TRACE("checkpoint 3: program linked (%d)", glGetError() == GL_NO_ERROR);
+
+    return programObject;
+#else
+    return 0;
+#endif
+}
+
diff --git slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.cxx slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.cxx
new file mode 100644
index 0000000..277d7e0
--- /dev/null
+++ slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.cxx
@@ -0,0 +1,1321 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionImpl.cxx,v $
+ * $Revision: 1.5.12.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "OGLTrans_TransitionImpl.hxx"
+#include "OGLTrans_Shaders.hxx"
+#ifdef QUARTZ
+#include <OpenGL/gl.h>
+#else
+#include <GL/gl.h>
+#include <math.h>
+#endif
+
+void OGLTransitionImpl::clear()
+{
+    for(unsigned int i( 0 ); i < OverallOperations.size(); ++i)
+        delete OverallOperations[i];
+    OverallOperations.clear();
+    maLeavingSlidePrimitives.clear();
+    maEnteringSlidePrimitives.clear();
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        delete maSceneObjects[i];
+    maSceneObjects.clear();
+
+    mbReflectSlides = false;
+
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        OGLShaders::glDeleteProgram( mProgramObject );
+        mProgramObject = 0;
+    }
+
+    if( mVertexObject ) {
+        OGLShaders::glDeleteShader( mVertexObject );
+        mVertexObject = 0;
+    }
+
+    if( mFragmentObject ) {
+        OGLShaders::glDeleteShader( mFragmentObject );
+        mFragmentObject = 0;
+    }
+#endif
+
+    if( maHelperTexture ) {
+        glDeleteTextures( 1, &maHelperTexture );
+        maHelperTexture = 0;
+    }
+
+    if( mmClearTransition )
+        (this->*mmClearTransition)();
+}
+
+OGLTransitionImpl::~OGLTransitionImpl()
+{
+    clear();
+}
+
+void OGLTransitionImpl::prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex )
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->prepare();
+    }
+
+    if( mmPrepareTransition )
+        (this->*mmPrepareTransition)( glLeavingSlideTex, glEnteringSlideTex );
+}
+
+void OGLTransitionImpl::finish()
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->finish();
+    }
+}
+
+static void blendSlide( double depth )
+{
+    double showHeight = -1 + depth*2;
+    GLfloat reflectionColor[] = {0, 0, 0, 0.25};
+
+    glDisable( GL_DEPTH_TEST );
+    glBegin( GL_QUADS );
+    glColor4fv( reflectionColor );
+    glVertex3f( -1, -1, 0 );
+    glColor4f( 0, 0, 0, 1 );
+    glVertex3f(-1,  showHeight, 0 );
+    glVertex3f( 1,  showHeight, 0 );
+    glColor4fv( reflectionColor );
+    glVertex3f( 1, -1, 0 );
+    glEnd();
+
+    glBegin( GL_QUADS );
+    glColor4f( 0, 0, 0, 1 );
+    glVertex3f( -1, showHeight, 0 );
+    glVertex3f( -1,  1, 0 );
+    glVertex3f(  1,  1, 0 );
+    glVertex3f(  1, showHeight, 0 );
+    glEnd();
+    glEnable( GL_DEPTH_TEST );
+}
+
+static void slideShadow( double nTime, Primitive& primitive, double sw, double sh )
+{
+    double reflectionDepth = 0.3;
+
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glDisable(GL_LIGHTING);
+
+    glPushMatrix();
+    primitive.applyOperations( nTime, sw, sh );
+    blendSlide( reflectionDepth );
+    glPopMatrix();
+
+    glDisable(GL_BLEND);
+    glEnable(GL_LIGHTING);
+}
+
+void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                 double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    double SlideWidthScale, SlideHeightScale;
+
+    SlideWidthScale = SlideWidth/DispWidth;
+    SlideHeightScale = SlideHeight/DispHeight;
+
+    if( mmPrepare ) {
+        clear();
+        (this->*mmPrepare)( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
+    }
+
+    glPushMatrix();
+    displaySlides( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
+    displayScene( nTime, SlideWidth, SlideHeight, DispWidth, DispHeight );
+    glPopMatrix();
+}
+
+void OGLTransitionImpl::applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale )
+{
+    for(unsigned int i(0); i < OverallOperations.size(); ++i)
+        OverallOperations[i]->interpolate(nTime,SlideWidthScale,SlideHeightScale);
+}
+
+void OGLTransitionImpl::displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives,
+                                      double SlideWidthScale, double SlideHeightScale )
+{
+   //TODO change to foreach
+    glBindTexture(GL_TEXTURE_2D, glSlideTex);
+
+    // display slide reflection
+    // note that depth test is turned off while blending the shadow
+    // so the slides has to be rendered in right order, see rochade as example
+    if( mbReflectSlides ) {
+        double surfaceLevel = -0.04;
+
+        /* reflected slides */
+        glPushMatrix();
+
+        glScaled( 1, -1, 1 );
+        glTranslated( 0, 2 - surfaceLevel, 0 );
+
+        glCullFace(GL_FRONT);
+	for(unsigned int i(0); i < primitives.size(); ++i)
+	    primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
+        glCullFace(GL_BACK);
+
+	slideShadow( nTime, primitives[0], SlideWidthScale, SlideHeightScale );
+
+        glPopMatrix();
+    }
+
+    for(unsigned int i(0); i < primitives.size(); ++i)
+        primitives[i].display(nTime, SlideWidthScale, SlideHeightScale);
+}
+
+void OGLTransitionImpl::displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                       double SlideWidthScale, double SlideHeightScale )
+{
+    if( mmDisplaySlides )
+        (this->*mmDisplaySlides)( nTime, glLeavingSlideTex, glEnteringSlideTex, SlideWidthScale, SlideHeightScale );
+    else {
+        applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+        glEnable(GL_TEXTURE_2D);
+        displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+        displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+}
+
+void OGLTransitionImpl::displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glEnable(GL_TEXTURE_2D);
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        maSceneObjects[i]->display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Primitive::display(double nTime, double WidthScale, double HeightScale)
+{
+    glPushMatrix();
+
+    applyOperations( nTime, WidthScale, HeightScale );
+
+    glEnableClientState( GL_VERTEX_ARRAY );
+    if(!Normals.empty())
+    {
+        glNormalPointer( GL_DOUBLE , 0 , &Normals[0] );
+        glEnableClientState( GL_NORMAL_ARRAY );
+    }
+    glEnableClientState( GL_TEXTURE_COORD_ARRAY );
+    glTexCoordPointer( 2, GL_DOUBLE, 0, &TexCoords[0] );
+    glVertexPointer( 3, GL_DOUBLE, 0, &Vertices[0] );
+    glDrawArrays( GL_TRIANGLES, 0, Vertices.size() );
+    glPopMatrix();
+}
+
+void Primitive::applyOperations(double nTime, double WidthScale, double HeightScale)
+{
+    for(unsigned int i(0); i < Operations.size(); ++i)
+        Operations[i]->interpolate( nTime ,WidthScale,HeightScale);
+    glScaled(WidthScale,HeightScale,1);
+}
+
+Primitive::~Primitive()
+{
+    for(unsigned int i( 0 ); i < Operations.size(); ++i)
+        delete Operations[i];
+}
+
+
+void SceneObject::display(double nTime, double /* SlideWidth */, double /* SlideHeight */, double DispWidth, double DispHeight )
+{
+    for(unsigned int i(0); i < maPrimitives.size(); ++i) {
+        // fixme: allow various model spaces, now we make it so that
+        // it is regular -1,-1 to 1,1, where the whole display fits in
+        glPushMatrix();
+        if (DispHeight > DispWidth)
+            glScaled(DispHeight/DispWidth, 1, 1);
+        else
+            glScaled(1, DispWidth/DispHeight, 1);
+        maPrimitives[i].display(nTime, 1, 1);
+        glPopMatrix();
+    }
+}
+
+void SceneObject::pushPrimitive(const Primitive &p)
+{
+    maPrimitives.push_back(p);
+}
+
+SceneObject::SceneObject()
+    : maPrimitives()
+{
+}
+
+Iris::Iris()
+    : SceneObject ()
+{
+}
+
+void Iris::display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    SceneObject::display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Iris::prepare()
+{
+    static GLubyte img[3] = { 80, 80, 80 };
+    
+    glGenTextures(1, &maTexture);
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, 3, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, img);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+}
+
+void Iris::finish()
+{
+    glDeleteTextures(1, &maTexture);
+}
+
+void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeInsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+    
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeFallLeaving()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(1,0,0),basegfx::B3DVector(0,-1,0), 90,true,0.0,1.0));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::makeTurnAround()
+{
+    clear();
+    Primitive Slide;
+
+    mbReflectSlides = true;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0),-180,false,0.0,1.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, -1.5),true, 0, 0.5));
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1.5), true, 0.5, 1));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0),basegfx::B3DVector(0, 0, 0), -180, true, 0.0, 1.0));
+}
+
+void OGLTransitionImpl::makeTurnDown()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 0.0001), false, -1.0, 0.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), -90, true, 0.0, 1.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), 90, false, -1.0, 0.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    mbUseMipMapLeaving = false;
+}
+
+void OGLTransitionImpl::makeIris()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0,  0.000001), false, -1, 0));
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, -0.000002), false, 0.5, 1));
+    maLeavingSlidePrimitives.push_back (Slide);
+
+
+    Primitive irisPart, part;
+    int i, nSteps = 24, nParts = 7;
+    double lt = 0, t = 1.0/nSteps, cx, cy, lcx, lcy, lx = 1, ly = 0, x, y, cxo, cyo, lcxo, lcyo, of=2.2, f=1.42;
+
+    for (i=1; i<=nSteps; i++) {
+        x = cos ((3*2*M_PI*t)/nParts);
+        y = -sin ((3*2*M_PI*t)/nParts);
+        cx = (f*x + 1)/2;
+        cy = (f*y + 1)/2;
+        lcx = (f*lx + 1)/2;
+        lcy = (f*ly + 1)/2;
+        cxo = (of*x + 1)/2;
+        cyo = (of*y + 1)/2;
+        lcxo = (of*lx + 1)/2;
+        lcyo = (of*ly + 1)/2;
+        irisPart.pushTriangle (basegfx::B2DVector (lcx, lcy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cx, cy));
+        irisPart.pushTriangle (basegfx::B2DVector (cx, cy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cxo, cyo));
+        lx = x;
+        ly = y;
+        lt = t;
+        t += 1.0/nSteps;
+    }
+
+    Iris* pIris = new Iris();
+    double angle = 87;
+
+    for (i = 0; i < nParts; i++) {
+        irisPart.Operations.clear ();
+        double rx, ry;
+
+        rx = cos ((2*M_PI*i)/nParts);
+        ry = sin ((2*M_PI*i)/nParts);
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0),  angle, true, 0.0, 0.5));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0), -angle, true, 0.5, 1));
+        if (i > 0) {
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(rx, ry, 0),  false, -1, 0));
+            irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(0, 0, 0), i*360.0/nParts, false, -1, 0));
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(-1, 0, 0),  false, -1, 0));
+        }
+        irisPart.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1), false, -2, 0.0));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(1, .5, 0), basegfx::B3DVector(1, 0, 0), -30, false, -1, 0));
+        pIris->pushPrimitive (irisPart);
+    }
+
+    maSceneObjects.push_back (pIris);
+
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+					      double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glEnable(GL_TEXTURE_2D);
+
+    if( nTime > .5) {
+	displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+	displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    } else {
+	displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+	displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+}
+
+void OGLTransitionImpl::makeRochade()
+{
+    clear();
+    Primitive Slide;
+    
+    mbReflectSlides = true;
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesRochade;
+
+    double w, h;
+
+    w = 2.2;
+    h = 10;
+
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.25, -0.25, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.75, 0.25, true, 0, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, -h), false, -1, 0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), 45, false, -1, 0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    //     OverallOperations.push_back(new SEllipseTranslate(0.5, 2, 0, 1, true, 0, 1));
+//      push_back(new STranslate(basegfx::B3DVector(0, 0, -2), true, 0, 0.5));
+//      OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 2), true, 0.5, 1));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B2DVector clamp(const basegfx::B2DVector& v)
+{
+    return basegfx::B2DVector(min(max(v.getX(),-1.0),1.0),
+                              min(max(v.getY(),-1.0),1.0));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector clamp(const basegfx::B3DVector& v)
+{
+    return basegfx::B3DVector(min(max(v.getX(),-1.0),1.0),
+                              min(max(v.getY(),-1.0),1.0),
+                              min(max(v.getZ(),-1.0),1.0));
+}
+
+inline double randFromNeg1to1()
+{
+    return ( ( static_cast<double>( rand() ) / static_cast<double>( RAND_MAX ) ) * 2.0 ) - 1.0;
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector randNormVectorInXYPlane()
+{
+    basegfx::B3DVector toReturn(randFromNeg1to1(),randFromNeg1to1(),0.0);
+    return toReturn/toReturn.getLength();
+}
+
+void OGLTransitionImpl::makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles )
+{
+    clear();
+    double dAngle(2*3.1415926/static_cast<double>( nPointsOnCircles ));
+    if(nCircles < 2 || nPointsOnCircles < 4)
+    {
+        makeNByMTileFlip(1,1);
+        return;
+    }
+    double Radius(1.0/static_cast<double>( nCircles ));
+    double dRadius(Radius);
+    double LastRadius(0.0);
+    double NextRadius(2*Radius);
+
+    /// now we know there is at least two circles
+    /// the first will always be a full circle
+    /// the last will always be the outer shell of the slide with a circle hole
+
+    //add the full circle
+    vector<basegfx::B2DVector> unScaledTexCoords;
+    double TempAngle(0.0);
+    for(unsigned int Point(0); Point < nPointsOnCircles; ++Point)
+    {
+        unScaledTexCoords.push_back( basegfx::B2DVector( cos(TempAngle - 3.1415926/2.0) , sin(TempAngle- 3.1415926/2.0) ) );
+
+        TempAngle += dAngle;
+    }
+    
+    {
+        //double angle(0.0);
+        Primitive EnteringSlide;
+        Primitive LeavingSlide;
+        for(int Point(0); Point + 1 < nPointsOnCircles; ++Point)
+        {
+            EnteringSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+            LeavingSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5, 0.5) );
+        }
+        EnteringSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius * unScaledTexCoords[ 0 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ nPointsOnCircles - 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+        LeavingSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+    
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+    
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }    
+    
+    for(int i(1); i < nCircles - 1; ++i)
+    {
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {            
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }
+    {
+        Radius = sqrt(2.0);
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {
+            
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+    }
+}
+
+void OGLTransitionImpl::makeHelix( ::sal_uInt16 nRows )
+{
+    clear();
+    double invN(1.0/static_cast<double>(nRows));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < nRows; ++i)
+    {
+        Primitive Tile;
+        
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+            
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iPDn ) , basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , 
+                                                true,min(max(static_cast<double>(i - nRows/2.0)*invN/2.0,0.0),1.0),
+                                                min(max(static_cast<double>(i + nRows/2.0)*invN/2.0,0.0),1.0) ) );
+        
+        maLeavingSlidePrimitives.push_back(Tile);
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180 , false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(Tile);
+            
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+void OGLTransitionImpl::makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m )
+{
+    clear();
+    double invN(1.0/static_cast<double>(n));
+    double invM(1.0/static_cast<double>(m));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < n; ++i)
+    {
+        double jDm = 0.0;
+        double jPDm = invM;
+        for(unsigned int j(0); j < m; ++j)
+        {
+            Primitive Tile;
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jPDm ) , basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));//bottom left corner of tile            
+
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , true, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+            maLeavingSlidePrimitives.push_back(Tile);
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180, false, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+
+            maEnteringSlidePrimitives.push_back(Tile);
+
+            jDm += invM;
+            jPDm += invM;
+        }
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+SRotate::SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+SScale::SScale(const basegfx::B3DVector& Scale,const basegfx::B3DVector& Origin, bool bInter, double T0, double T1):scale(Scale),origin(Origin)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByWidth::RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByHeight::RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+
+STranslate::STranslate(const basegfx::B3DVector& Vector, bool bInter, double T0, double T1):vector(Vector)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+inline double intervalInter(double t, double T0, double T1)
+{
+    return ( t - T0 ) / ( T1 - T0 );
+}
+
+void STranslate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*t*vector.getX(),SlideHeightScale*t*vector.getY(),t*vector.getZ());
+}
+
+void SRotate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled(SlideWidthScale,SlideHeightScale,1);
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glScaled(1/SlideWidthScale,1/SlideHeightScale,1);
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void SScale::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled((1-t) + t*scale.getX(),(1-t) + t*scale.getY(),(1-t) + t*scale.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void RotateAndScaleDepthByWidth::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideWidthScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
+}
+
+void RotateAndScaleDepthByHeight::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideHeightScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideHeightScale*origin.getZ());
+}
+
+SEllipseTranslate::SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+    width = dWidth;
+    height = dHeight;
+    startPosition = dStartPosition;
+    endPosition = dEndPosition;
+}
+
+void SEllipseTranslate::interpolate(double t,double /* SlideWidthScale */,double /* SlideHeightScale */)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+
+    double a1, a2, x, y;
+    a1 = startPosition*2*M_PI;
+    a2 = (startPosition + t*(endPosition - startPosition))*2*M_PI;
+    x = width*(cos (a2) - cos (a1))/2;
+    y = height*(sin (a2) - sin (a1))/2;
+
+    glTranslated(x, 0, y);
+}
+
+STranslate* STranslate::clone()
+{
+    return new STranslate(*this);
+}
+SRotate* SRotate::clone()
+{
+    return new SRotate(*this);
+}
+
+SScale* SScale::clone()
+{
+    return new SScale(*this);
+}
+
+SEllipseTranslate* SEllipseTranslate::clone()
+{
+    return new SEllipseTranslate(*this);
+}
+
+RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
+{
+    return new RotateAndScaleDepthByWidth(*this);
+}
+
+RotateAndScaleDepthByHeight* RotateAndScaleDepthByHeight::clone()
+{
+    return new RotateAndScaleDepthByHeight(*this);
+}
+
+const Primitive& Primitive::operator=(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);    
+    return *this;   
+}
+    
+Primitive::Primitive(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);
+}
+
+void Primitive::pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2)
+{
+    vector<basegfx::B3DVector> Verts;
+    vector<basegfx::B2DVector> Texs;
+    Verts.reserve(3);
+    Texs.reserve(3);
+
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+
+    //figure out if they're facing the correct way, and make them face the correct way.
+    basegfx::B3DVector Normal( basegfx::cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
+    if(Normal.getZ() >= 0.0)//if the normal is facing us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation1);
+        Texs.push_back(SlideLocation2);
+    }
+    else // if the normal is facing away from us, make it face us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation2);
+        Texs.push_back(SlideLocation1);
+        Verts.clear();
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    }
+
+    Vertices.push_back(Verts[0]);
+    Vertices.push_back(Verts[1]);
+    Vertices.push_back(Verts[2]);
+
+    TexCoords.push_back(Texs[0]);
+    TexCoords.push_back(Texs[1]);
+    TexCoords.push_back(Texs[2]);
+    
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+}
+
+void OGLTransitionImpl::makeDiamond()
+{
+    mmPrepare = &OGLTransitionImpl::prepareDiamond;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::prepareDiamond( double nTime, double /* SlideWidth */, double /* SlideHeight */, double /* DispWidth */, double /* DispHeight */ )
+{
+    Primitive Slide1, Slide2;
+
+    Slide1.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide1.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide1);
+
+    
+    if( nTime >= 0.5 ) {
+        double m = 1 - nTime;
+
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (m,0), basegfx::B2DVector (0,m));
+        Slide2.pushTriangle (basegfx::B2DVector (nTime,0), basegfx::B2DVector (1,0), basegfx::B2DVector (1,m));
+        Slide2.pushTriangle (basegfx::B2DVector (1,nTime), basegfx::B2DVector (1,1), basegfx::B2DVector (nTime,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,nTime), basegfx::B2DVector (m,1), basegfx::B2DVector (0,1));
+    } else {
+        double l = 0.5 - nTime;
+        double h = 0.5 + nTime;
+
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0.5,l));
+        Slide2.pushTriangle (basegfx::B2DVector (0.5,l), basegfx::B2DVector (1,0), basegfx::B2DVector (h,0.5));
+        Slide2.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (1,1), basegfx::B2DVector (h,0.5));
+        Slide2.pushTriangle (basegfx::B2DVector (h,0.5), basegfx::B2DVector (1,1), basegfx::B2DVector (0.5,h));
+        Slide2.pushTriangle (basegfx::B2DVector (0.5,h), basegfx::B2DVector (1,1), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (l,0.5), basegfx::B2DVector (0.5,h), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (l,0.5), basegfx::B2DVector (0,1));
+        Slide2.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (0.5,l), basegfx::B2DVector (l,0.5));
+    }
+    Slide2.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, 0.00000001), false, -1, 0));
+    maLeavingSlidePrimitives.push_back (Slide2);
+}
+
+void OGLTransitionImpl::makeVenetianBlinds( bool vertical, int parts )
+{
+    static double t30 = tan( M_PI/6.0 );
+    double n, ln = 0;
+    double p = 1.0/parts;
+
+    for( int i=0; i<parts; i++ ) {
+        Primitive Slide;
+        n = (i + 1)/(double)parts;
+        if( vertical ) {
+            Slide.pushTriangle (basegfx::B2DVector (ln,0), basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1));
+            Slide.pushTriangle (basegfx::B2DVector (n,0), basegfx::B2DVector (ln,1), basegfx::B2DVector (n,1));
+            Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, -t30*p), -120, true, 0.0, 1.0));
+        } else {
+            Slide.pushTriangle (basegfx::B2DVector (0,ln), basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n));
+            Slide.pushTriangle (basegfx::B2DVector (1,ln), basegfx::B2DVector (0,n), basegfx::B2DVector (1,n));
+            Slide.Operations.push_back(new RotateAndScaleDepthByHeight(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, -t30*p), -120, true, 0.0, 1.0));
+        }
+        maLeavingSlidePrimitives.push_back (Slide);
+
+        if( vertical ) {
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(2*n - 1, 0, 0), -60, false, -1, 0));
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0, 1, 0), basegfx::B3DVector(n + ln - 1, 0, 0), 180, false, -1, 0));
+        } else {
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - 2*n, 0), -60, false, -1, 0));
+            Slide.Operations.push_back(new SRotate(basegfx::B3DVector(1, 0, 0), basegfx::B3DVector(0, 1 - n - ln, 0), 180, false, -1, 0));
+        }
+        maEnteringSlidePrimitives.push_back (Slide);
+        ln = n;
+    }
+}
+
+void OGLTransitionImpl::displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_DEPTH_TEST);
+
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_LIGHTING);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glColor4f( 1, 1, 1, nTime );
+    displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    glDisable(GL_BLEND);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+    glEnable(GL_LIGHTING);
+
+    glEnable(GL_DEPTH_TEST);
+}
+
+void OGLTransitionImpl::makeFadeSmoothly()
+{ 
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeSmoothly;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+void OGLTransitionImpl::displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+    glDisable(GL_DEPTH_TEST);
+
+    glDisable(GL_LIGHTING);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    if( nTime < 0.5 ) {
+	glColor4f( 1, 1, 1, 1 - nTime*2 );
+	displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    } else {
+	glColor4f( 1, 1, 1, (nTime - 0.5)*2 );
+	displaySlide( nTime, glEnteringSlideTex, maEnteringSlidePrimitives, SlideWidthScale, SlideHeightScale );
+    }
+    glDisable(GL_BLEND);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+    glEnable(GL_LIGHTING);
+
+    glEnable(GL_DEPTH_TEST);
+}
+
+void OGLTransitionImpl::makeFadeThroughBlack()
+{ 
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesFadeThroughBlack;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+}
+
+static const char* basicVertexShader = "\n\
+varying vec2 v_texturePosition;\n\
+\n\
+void main( void )\n\
+{\n\
+	gl_Position = ftransform();\n\
+	v_texturePosition = gl_MultiTexCoord0.xy;\n\
+}\n\
+";
+
+static const char* staticFragmentShader = "\n\
+uniform sampler2D leavingSlideTexture;\n\
+uniform sampler2D enteringSlideTexture;\n\
+uniform sampler2D permTexture;\n\
+uniform float time;\n\
+varying vec2 v_texturePosition;\n\
+\n\
+float snoise(vec2 P) {\n\
+\n\
+  return texture2D(permTexture, P).r;\n\
+}\n\
+\n\
+\n\
+#define PART 0.5\n\
+#define START 0.4\n\
+#define END 0.9\n\
+\n\
+void main() {\n\
+    float sn = snoise(10.0*v_texturePosition+time*0.07);\n\
+    if( time < PART ) {\n\
+        float sn1 = snoise(vec2(time*15.0, 20.0*v_texturePosition.y));\n\
+        float sn2 = snoise(v_texturePosition);\n\
+        if (sn1 > 1.0 - time*time && sn2 < 2.0*time+0.1)\n\
+	        gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
+        else if (time > START )\n\
+            gl_FragColor = ((time-START)/(PART - START))*vec4(sn, sn, sn, 1.0) + (1.0 - (time - START)/(PART - START))*texture2D(leavingSlideTexture, v_texturePosition);\n\
+        else\n\
+            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+    } else if ( time < PART ) {\n\
+            gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+    } else if ( time > END ) {\n\
+        gl_FragColor = ((1.0 - time)/(1.0 - END))*vec4(sn, sn, sn, 1.0) + ((time - END)/(1.0 - END))*texture2D(enteringSlideTexture, v_texturePosition);\n\
+    } else \n\
+	    gl_FragColor = vec4(sn, sn, sn, 1.0);\n\
+}\n\
+";
+
+static const char* dissolveFragmentShader = "\n\
+uniform sampler2D leavingSlideTexture;\n\
+uniform sampler2D enteringSlideTexture;\n\
+uniform sampler2D permTexture;\n\
+uniform float time;\n\
+varying vec2 v_texturePosition;\n\
+\n\
+float snoise(vec2 P) {\n\
+\n\
+  return texture2D(permTexture, P).r;\n\
+}\n\
+\n\
+void main() {\n\
+     float sn = snoise(10.0*v_texturePosition);\n\
+     if( sn < time)\n\
+         gl_FragColor = texture2D(enteringSlideTexture, v_texturePosition);\n\
+     else\n\
+         gl_FragColor = texture2D(leavingSlideTexture, v_texturePosition);\n\
+}\n\
+";
+
+int permutation256 [256]= {
+215, 100, 200, 204, 233,  50,  85, 196, 
+ 71, 141, 122, 160,  93, 131, 243, 234, 
+162, 183,  36, 155,   4,  62,  35, 205, 
+ 40, 102,  33,  27, 255,  55, 214, 156, 
+ 75, 163, 134, 126, 249,  74, 197, 228, 
+ 72,  90, 206, 235,  17,  22,  49, 169, 
+227,  89,  16,   5, 117,  60, 248, 230, 
+217,  68, 138,  96, 194, 170, 136,  10, 
+112, 238, 184, 189, 176,  42, 225, 212, 
+ 84,  58, 175, 244, 150, 168, 219, 236, 
+101, 208, 123,  37, 164, 110, 158, 201, 
+ 78, 114,  57,  48,  70, 142, 106,  43, 
+232,  26,  32, 252, 239,  98, 191,  94, 
+ 59, 149,  39, 187, 203, 190,  19,  13, 
+133,  45,  61, 247,  23,  34,  20,  52, 
+118, 209, 146, 193, 222,  18,   1, 152, 
+ 46,  41,  91, 148, 115,  25, 135,  77, 
+254, 147, 224, 161,   9, 213, 223, 250, 
+231, 251, 127, 166,  63, 179,  81, 130, 
+139,  28, 120, 151, 241,  86, 111,   0, 
+ 88, 153, 172, 182, 159, 105, 178,  47, 
+ 51, 167,  65,  66,  92,  73, 198, 211, 
+245, 195,  31, 220, 140,  76, 221, 186, 
+154, 185,  56,  83,  38, 165, 109,  67, 
+124, 226, 132,  53, 229,  29,  12, 181, 
+121,  24, 207, 199, 177, 113,  30,  80, 
+  3,  97, 188,  79, 216, 173,   8, 145, 
+ 87, 128, 180, 237, 240, 137, 125, 104, 
+ 15, 242, 119, 246, 103, 143,  95, 144, 
+  2,  44,  69, 157, 192, 174,  14,  54, 
+218,  82,  64, 210,  11,   6, 129,  21, 
+116, 171,  99, 202,   7, 107, 253, 108
+};
+
+void initPermTexture(GLuint *texID)
+{
+  glGenTextures(1, texID);
+  glBindTexture(GL_TEXTURE_2D, *texID);
+
+  static bool initialized = false;
+  static unsigned char permutation2D[256*256*4];
+  if( !initialized ) {
+      int x, y;
+
+      for( y=0; y < 256; y++ )
+          for( x=0; x < 256; x++ )
+              permutation2D[x*4 + y*1024] = permutation256[(y + permutation256[x]) & 0xff];
+
+      initialized = true;
+  }
+
+  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, permutation2D );
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
+}
+
+void OGLTransitionImpl::preparePermShader()
+{
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        OGLShaders::glUseProgram( mProgramObject );
+
+        GLint location = OGLShaders::glGetUniformLocation( mProgramObject, "leavingSlideTexture" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1i( location, 0 );  // texture unit 0
+        }
+
+        glActiveTexture(GL_TEXTURE1);
+        if( !maHelperTexture )
+            initPermTexture( &maHelperTexture );
+        glActiveTexture(GL_TEXTURE0);
+
+        location = OGLShaders::glGetUniformLocation( mProgramObject, "permTexture" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1i( location, 1 );  // texture unit 1
+        }
+
+        location = OGLShaders::glGetUniformLocation( mProgramObject, "enteringSlideTexture" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1i( location, 2 );  // texture unit 2
+        }
+    }
+#endif
+}
+
+void OGLTransitionImpl::prepareStatic( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
+{
+    mProgramObject = OGLShaders::LinkProgram( basicVertexShader, staticFragmentShader );
+
+    preparePermShader();
+}
+
+void OGLTransitionImpl::displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                              double SlideWidthScale, double SlideHeightScale )
+{
+    applyOverallOperations( nTime, SlideWidthScale, SlideHeightScale );
+
+#ifdef GL_VERSION_2_0
+    if( mProgramObject ) {
+        GLint location = OGLShaders::glGetUniformLocation( mProgramObject, "time" );
+        if( location != -1 ) {
+            OGLShaders::glUniform1f( location, nTime );
+        }
+    }
+
+    glActiveTexture( GL_TEXTURE2 );
+    glBindTexture( GL_TEXTURE_2D, glEnteringSlideTex );
+    glActiveTexture( GL_TEXTURE0 );
+#endif
+
+    displaySlide( nTime, glLeavingSlideTex, maLeavingSlidePrimitives, SlideWidthScale, SlideHeightScale );
+}
+
+void OGLTransitionImpl::makeStatic()
+{
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
+    mmPrepareTransition = &OGLTransitionImpl::prepareStatic;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+
+    mnRequiredGLVersion = 2.0;
+}
+
+void OGLTransitionImpl::prepareDissolve( ::sal_Int32 /* glLeavingSlideTex */, ::sal_Int32 /* glEnteringSlideTex */ )
+{
+    mProgramObject = OGLShaders::LinkProgram( basicVertexShader, dissolveFragmentShader );
+
+    preparePermShader();
+}
+
+void OGLTransitionImpl::makeDissolve()
+{
+    Primitive Slide;
+
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maLeavingSlidePrimitives.push_back (Slide);
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    mmDisplaySlides = &OGLTransitionImpl::displaySlidesShaders;
+    mmPrepareTransition = &OGLTransitionImpl::prepareDissolve;
+    mbUseMipMapLeaving = mbUseMipMapEntering = false;
+
+    mnRequiredGLVersion = 2.0;
+}
+
+void OGLTransitionImpl::makeNewsflash()
+{
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),3000,true,0,0.5));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),true,0,0.5));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-10000, 0, 0),false, 0.5, 2));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0,0,0),-3000,true,0.5,1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(-100, 0, 0),false, -1, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(100, 0, 0),false, 0.5, 1));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(0.01,0.01,0.01),basegfx::B3DVector(0,0,0),false,-1,1));
+    Slide.Operations.push_back(new SScale(basegfx::B3DVector(100,100,100),basegfx::B3DVector(0,0,0),true,0.5,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new SRotate(basegfx::B3DVector(0,0,1),basegfx::B3DVector(0.2,0.2,0),1080,true,0,1));
+}
+
diff --git slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.hxx slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.hxx
new file mode 100644
index 0000000..a8080d5
--- /dev/null
+++ slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionImpl.hxx
@@ -0,0 +1,513 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionImpl.hxx,v $
+ * $Revision: 1.5.12.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+#define INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+
+#include <basegfx/vector/b2dvector.hxx>
+#include <basegfx/vector/b3dvector.hxx>
+
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+
+#if defined( WNT ) 
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+#elif defined( OS2 )
+#elif defined( QUARTZ )
+#include <OpenGL/gl.h>
+#elif defined( UNX ) && !defined( QUARTZ )
+#endif
+
+#include <vector>
+
+#if !defined( QUARTZ )
+#include <GL/gl.h>
+#endif
+
+using namespace std;
+
+class Primitive;
+class Operation;
+class SceneObject;
+
+
+/** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
+
+	This class is capable of making itself into many difference transitions. It holds Primitives and Operations on those primitives.
+*/
+class OGLTransitionImpl
+{
+public:
+    OGLTransitionImpl() :
+        mbUseMipMapLeaving( true ),
+        mbUseMipMapEntering( true ),
+        mnRequiredGLVersion( 1.0 ),
+        maLeavingSlidePrimitives(),
+        maEnteringSlidePrimitives(),
+        maSceneObjects(),
+        mbReflectSlides( false ),
+        mVertexObject( 0 ),
+        mFragmentObject( 0 ),
+        mProgramObject( 0 ),
+        maHelperTexture( 0 ),
+        mmPrepare( NULL ),
+        mmPrepareTransition( NULL ),
+        mmClearTransition( NULL ),
+        mmDisplaySlides( NULL )
+    {}
+
+    ~OGLTransitionImpl();
+    
+    void prepare( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
+    void finish();
+
+    void makeOutsideCubeFaceToLeft();
+    void makeInsideCubeFaceToLeft();
+    void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
+    void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
+    void makeHelix( ::sal_uInt16 nRows );
+    void makeFallLeaving();
+    void makeTurnAround();
+    void makeTurnDown();
+    void makeIris();
+    void makeRochade();
+    void makeVenetianBlinds( bool vertical, int parts );
+    void makeStatic();
+    void makeDissolve();
+    void makeNewsflash();
+
+    /** 2D replacements
+     */
+    void makeDiamond();
+    void makeFadeSmoothly();
+    void makeFadeThroughBlack();
+
+    /** Whether to use mipmaping for slides textures
+     */
+    bool mbUseMipMapLeaving;
+    bool mbUseMipMapEntering;
+
+    /** which GL version does the transition require
+     */
+    float mnRequiredGLVersion;
+
+private:
+    /** clears all the primitives and operations
+	*/
+    void clear();
+    
+    /** All the primitives that use the leaving slide texture
+	*/
+    vector<Primitive> maLeavingSlidePrimitives;
+    
+    /** All the primitives that use the leaving slide texture
+	*/
+    vector<Primitive> maEnteringSlidePrimitives;
+    
+    /** All the surrounding scene objects
+	*/
+    vector<SceneObject*> maSceneObjects;
+
+    /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+	*/
+	vector<Operation*> OverallOperations;
+
+	/** Whether to reflect slides, the reflection happens on flat surface beneath the slides.
+	 ** Now it only works with slides which keep their rectangular shape together.
+	 */
+	bool mbReflectSlides;
+
+	/** GLSL objects, shaders and program
+	 */
+	GLuint mVertexObject, mFragmentObject, mProgramObject;
+
+	/** various data */
+	GLuint maHelperTexture;
+
+	/** When this method is not NULL, it is called in display method to prepare the slides, scene, etc.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmPrepare)( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight );
+
+	/** When this method is not NULL, it is called after glx context is ready to let the transition prepare GL related things, like GLSL program.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmPrepareTransition)( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+
+	/** When this method is not NULL, it is called when the transition needs to clear after itself, like delete own textures etc.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmClearTransition)();
+
+	/** When this method is not NULL, it is called in display method to display the slides.
+	 ** We might later replace this by cleaner derived class.
+	 */
+	void (OGLTransitionImpl::*mmDisplaySlides)( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+
+	void displaySlides( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+	void displaySlide( double nTime, ::sal_Int32 glSlideTex, std::vector<Primitive>& primitives, double SlideWidthScale, double SlideHeightScale );
+	void displayScene( double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+	void applyOverallOperations( double nTime, double SlideWidthScale, double SlideHeightScale );
+
+	/** various transitions helper methods
+	 */
+	void prepareDiamond( double nTime, double SlideWidth, double SlideHeight,double DispWidth, double DispHeight );
+	void displaySlidesFadeSmoothly( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+        void displaySlidesFadeThroughBlack( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+        void displaySlidesRochade( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+	void displaySlidesShaders( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidthScale, double SlideHeightScale );
+	void prepareStatic( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+	void prepareDissolve( ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex );
+	void preparePermShader();
+};
+
+class SceneObject
+{
+public:
+    SceneObject();
+
+    virtual void prepare() {};
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish() {};
+
+    void pushPrimitive (const Primitive &p);
+
+protected:
+    /** All the surrounding scene primitives
+	*/
+    vector<Primitive> maPrimitives;
+};
+
+class Iris : public SceneObject
+{
+public:
+    Iris ();
+
+    virtual void prepare();
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish();
+
+private:
+
+    GLuint maTexture;
+};
+
+/** This class is a list of Triangles that will share Operations, and could possibly share  
+*/
+class Primitive
+{
+public:
+    Primitive() {}
+	// making copy constructor explicit makes the class un-suitable for use with stl containers
+    Primitive(const Primitive& rvalue);
+	~Primitive();
+
+    void applyOperations(double nTime, double SlideWidthScale, double SlideHeightScale);
+    void display(double nTime, double SlideWidthScale, double SlideHeightScale);
+    const Primitive& operator=(const Primitive& rvalue);
+    
+    /** PushBack a vertex,normal, and tex coord. Each SlideLocation is where on the slide is mapped to this location ( from (0,0) to (1,1)  ). This will make sure the correct aspect ratio is used, and helps to make slides begin and end at the correct position. (0,0) is the top left of the slide, and (1,1) is the bottom right.
+    
+    @param SlideLocation0
+    Location of first Vertex on slide
+    
+    @param SlideLocation1
+    Location of second Vertex on slide
+    
+    @param SlideLocation2
+    Location of third Vertex on slide
+    
+    */
+    void pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2);
+    
+    /** clear all the vertices, normals, tex coordinates, and normals
+    */
+    void clearTriangles();
+    
+    /** guards against directly changing the vertices
+        
+        @return        
+        the list of vertices
+    */
+    const vector<basegfx::B3DVector>& getVertices() const {return Vertices;}
+    
+    /** guards against directly changing the vertices
+    */
+    const vector<basegfx::B3DVector>& getNormals() const {return Normals;}
+    
+    /** guards against directly changing the vertices
+    
+        @return        
+        the list of Texture Coordinates
+    
+    */
+    const vector<basegfx::B2DVector>& getTexCoords() const {return TexCoords;}
+
+    /** list of Operations to be performed on this primitive.These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+    
+        @return        
+        the list of Operations
+    
+    */    
+    vector<Operation*> Operations;
+
+private:
+    /** list of vertices
+    */
+	vector<basegfx::B3DVector> Vertices;
+	
+	/** list of Normals
+    */
+	vector<basegfx::B3DVector> Normals;
+	
+	/** list of Texture Coordinates
+    */
+	vector<basegfx::B2DVector> TexCoords;
+};
+
+/** This class is to be derived to make any operation (tranform) you may need in order to construct your transitions
+*/
+class Operation
+{
+public:
+	Operation(){}
+	virtual ~Operation(){}
+	
+	/** Should this operation be interpolated . If TRUE, the transform will smoothly move from making no difference from t = 0.0 to nT0 to being completely transformed from t = nT1 to 1. If FALSE, the transform will be inneffectual from t = 0 to nT0, and completely transformed from t = nT0 to 1. 
+	*/
+	bool bInterpolate;
+	
+	/** time to begin the transformation
+	*/
+	double nT0;
+	
+	/** time to finish the transformation
+	*/
+	double nT1;
+public:
+    /** this is the function that is called to give the Operation to OpenGL.
+        
+        @param t
+        time from t = 0 to t = 1
+        
+        @param SlideWidthScale
+        width of slide divided by width of window
+        
+        @param SlideHeightScale
+        height of slide divided by height of window
+    
+    */
+	virtual void interpolate(double t,double SlideWidthScale,double SlideHeightScale) = 0;
+	
+	/** return a copy of this operation
+	*/
+    virtual Operation* clone() = 0;
+};
+
+/** this class is a generic CounterClockWise(CCW) rotation with an axis angle
+*/
+class SRotate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    virtual SRotate* clone();
+	
+	/** Constructor
+	    
+	    @param Axis
+	    axis to rotate about
+	    
+	    @param Origin
+	    position that rotation axis runs through
+	    
+	    @param Angle
+	    angle in radians of CCW rotation
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~SRotate(){}
+private:
+    /** axis to rotate CCW about
+    */
+	basegfx::B3DVector axis;
+	
+	/** position that rotation axis runs through
+	*/
+    basegfx::B3DVector origin;
+    
+    /** angle in radians of CCW rotation
+    */
+	double angle;
+};
+
+/** scaling transformation
+*/
+class SScale: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SScale* clone();
+	
+	/** Constructor
+	    
+        @param Scale
+	    amount to scale by 
+	    
+	    @param Origin
+	    position that rotation axis runs through
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SScale(const basegfx::B3DVector& Scale, const basegfx::B3DVector& Origin,bool bInter, double T0, double T1);
+	~SScale(){}
+private:
+	basegfx::B3DVector scale;
+	basegfx::B3DVector origin;
+};
+
+/** translation transformation
+*/
+class STranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    STranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	STranslate(const basegfx::B3DVector& Vector,bool bInter, double T0, double T1);
+	~STranslate(){}
+private:
+    /** vector to translate by
+    */
+	basegfx::B3DVector vector;
+};
+
+/** translation transformation
+*/
+class SEllipseTranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SEllipseTranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1);
+	~SEllipseTranslate(){}
+private:
+    /** width and length of the ellipse
+     */
+    double width, height;
+
+    /** start and end position on the ellipse <0,1>
+     */
+    double startPosition;
+    double endPosition;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
+*/
+class RotateAndScaleDepthByWidth: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByWidth* clone();
+
+	RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~RotateAndScaleDepthByWidth(){}
+private:
+	basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+	double angle;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the height of the window.
+*/
+class RotateAndScaleDepthByHeight: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByHeight* clone();
+
+	RotateAndScaleDepthByHeight(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~RotateAndScaleDepthByHeight(){}
+private:
+	basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+	double angle;
+};
+
+#endif // INCLUDED_SLIDESHOW_TRANSITION_HXX_
+
diff --git slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionerImpl_WNT.cxx slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionerImpl_WNT.cxx
new file mode 100644
index 0000000..fc61624
--- /dev/null
+++ slideshow/source/engine/OGLTrans/win/OGLTrans_TransitionerImpl_WNT.cxx
@@ -0,0 +1,1455 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: OGLTrans_TransitionerImpl.cxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#define GLX_GLXEXT_PROTOTYPES 1
+#include "OGLTrans_TransitionImpl.hxx"
+
+#include <com/sun/star/beans/XFastPropertySet.hpp>
+#include <com/sun/star/rendering/IntegerBitmapLayout.hpp>
+#include <com/sun/star/rendering/ColorComponentTag.hpp>
+#include <com/sun/star/rendering/ColorSpaceType.hpp>
+#include <com/sun/star/animations/TransitionType.hpp>
+#include <com/sun/star/animations/TransitionSubType.hpp>
+#include <com/sun/star/presentation/XTransitionFactory.hpp>
+#include <com/sun/star/presentation/XTransition.hpp>
+#include <com/sun/star/presentation/XSlideShowView.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#include <com/sun/star/geometry/IntegerSize2D.hpp>
+
+#include <cppuhelper/compbase1.hxx>
+#include <cppuhelper/basemutex.hxx>
+#include <cppuhelper/factory.hxx>
+#include <rtl/ref.hxx>
+
+#include <comphelper/servicedecl.hxx>
+
+#include <canvas/canvastools.hxx>
+#include <tools/gen.hxx>
+#include <vcl/window.hxx>
+#include <vcl/syschild.hxx>
+#include <vcl/sysdata.hxx>
+
+#include <boost/noncopyable.hpp>
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+
+#ifdef DEBUG
+#include <boost/date_time/posix_time/posix_time.hpp>
+using namespace ::boost::posix_time;
+
+static ptime t1;
+static ptime t2;
+
+#define DBG(x) x
+#else
+#define DBG(x)
+#endif
+
+using namespace ::com::sun::star;
+using ::com::sun::star::beans::XFastPropertySet;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+
+namespace
+{
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransition> OGLTransitionerImplBase;
+
+namespace
+{
+    struct OGLFormat
+    {
+        GLint  nInternalFormat;
+        GLenum eFormat;
+        GLenum eType;
+    };
+
+    /* channel ordering: (0:rgba, 1:bgra, 2:argb, 3:abgr)  
+    */
+    int calcComponentOrderIndex(const uno::Sequence<sal_Int8>& rTags)
+    {
+        using namespace rendering::ColorComponentTag;
+
+        static const sal_Int8 aOrderTable[] =
+        {
+            RGB_RED, RGB_GREEN, RGB_BLUE, ALPHA,
+            RGB_BLUE, RGB_GREEN, RGB_RED, ALPHA,
+            ALPHA, RGB_RED, RGB_GREEN, RGB_BLUE,
+            ALPHA, RGB_BLUE, RGB_GREEN, RGB_RED, 
+        };
+
+        const sal_Int32 nNumComps(rTags.getLength());
+        const sal_Int8* pLine=aOrderTable;
+        for(int i=0; i<4; ++i)
+        {
+            int j=0;
+            while( j<4 && j<nNumComps && pLine[j] == rTags[j] )
+                ++j;
+
+            // all of the line passed, this is a match!
+            if( j==nNumComps )
+                return i;
+
+            pLine+=4;
+        }
+
+        return -1;
+    }
+}
+
+// not thread safe
+static bool errorTriggered;
+int oglErrorHandler( unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/ )
+{
+    errorTriggered = true;
+
+    return 0;
+}
+
+/** This is the Transitioner class for OpenGL 3D transitions in
+ * slideshow. At the moment, it's Linux only. This class is implicitly
+ * constructed from XTransitionFactory.
+*/
+class OGLTransitionerImpl : private cppu::BaseMutex, private boost::noncopyable, public OGLTransitionerImplBase
+{
+public:
+    explicit OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition);
+    bool initWindowFromSlideShowView( const uno::Reference< presentation::XSlideShowView >& xView );
+    void setSlides( const Reference< rendering::XBitmap >& xLeavingSlide , const uno::Reference< rendering::XBitmap >& xEnteringSlide );
+    static bool initialize( const Reference< presentation::XSlideShowView >& xView );
+
+    // XTransition
+    virtual void SAL_CALL update( double nTime )
+	throw (uno::RuntimeException);
+    virtual void SAL_CALL viewChanged( const Reference< presentation::XSlideShowView >& rView,
+				       const Reference< rendering::XBitmap >& rLeavingBitmap,
+				       const Reference< rendering::XBitmap >& rEnteringBitmap )
+	throw (uno::RuntimeException);
+    
+protected:
+    void disposeContextAndWindow();
+    void disposeTextures();
+
+    // WeakComponentImplHelperBase
+    virtual void SAL_CALL disposing();
+    
+    bool isDisposed() const
+    {
+        return (rBHelper.bDisposed || rBHelper.bInDispose);
+    }
+
+    bool createWindow( Window* pPWindow );
+    void createTexture( unsigned int* texID,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+			unx::GLXPixmap pixmap,
+			bool usePixmap,
+#endif
+			bool useMipmap,
+			uno::Sequence<sal_Int8>& data,
+			const OGLFormat* pFormat );
+    void prepareEnvironment ();
+    const OGLFormat* chooseFormats();
+
+private:    
+    /** After the window has been created, and the slides have been set, we'll initialize the slides with OpenGL.
+    */
+    void GLInitSlides();
+
+
+    /// Holds the information of our new child window
+    struct GLWindow
+    {
+	HWND					hWnd;
+	HDC						hDC;
+	HGLRC					hRC;
+    	unsigned int            bpp;
+    	unsigned int            Width;
+    	unsigned int            Height;
+        const char*             GLXExtensions;
+	const GLubyte*          GLExtensions;
+
+        bool HasGLXExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, (const GLubyte*) GLXExtensions ); }
+	bool HasGLExtension( const char* name ) { return gluCheckExtension( (const GLubyte*) name, GLExtensions ); }
+    } GLWin;
+    
+    /** OpenGL handle to the leaving slide's texture
+    */
+    unsigned int GLleavingSlide;
+    /** OpenGL handle to the entering slide's texture
+    */
+    unsigned int GLenteringSlide;
+    
+    /** pointer to our window which we MIGHT create.
+    */
+    class SystemChildWindow* pWindow;
+
+    Reference< presentation::XSlideShowView > mxView;
+    Reference< rendering::XIntegerBitmap > mxLeavingBitmap;
+    Reference< rendering::XIntegerBitmap > mxEnteringBitmap;
+    
+    /** raw bytes of the entering bitmap
+    */
+    uno::Sequence<sal_Int8> EnteringBytes;
+    
+    /** raw bytes of the leaving bitmap
+    */
+    uno::Sequence<sal_Int8> LeavingBytes;
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::GLXPixmap LeavingPixmap;
+    unx::GLXPixmap EnteringPixmap;
+#endif
+    bool mbRestoreSync;
+    bool mbUseLeavingPixmap;
+    bool mbUseEnteringPixmap;
+    bool mbFreeLeavingPixmap;
+    bool mbFreeEnteringPixmap;
+    unx::Pixmap maLeavingPixmap;
+    unx::Pixmap maEnteringPixmap;
+    
+    /** the form the raw bytes are in for the bitmaps
+    */
+    rendering::IntegerBitmapLayout SlideBitmapLayout; 
+    
+    /** the size of the slides
+    */    
+    geometry::IntegerSize2D SlideSize;
+    
+    /** Our Transition to be used.
+    */    
+    OGLTransitionImpl* pTransition;
+
+public:
+    /** whether we are running on ATI fglrx with bug related to textures
+     */
+    static bool cbBrokenTexturesATI;
+
+    /** GL version
+     */
+    static float cnGLVersion;
+    float mnGLXVersion;
+
+    /** Whether Mesa is the OpenGL vendor
+     */
+    static bool cbMesa;
+
+    /**
+       whether the display has GLX extension
+     */
+    static bool cbGLXPresent;
+
+    /**
+       whether texture from pixmap extension is available
+    */
+    bool mbTextureFromPixmap;
+
+    /**
+       whether to generate mipmaped textures
+    */
+    bool mbGenerateMipmap;
+
+    /**
+       whether we have visual which can be used for texture_from_pixmap extension
+    */
+    bool mbHasTFPVisual;
+
+#ifdef DEBUG
+    ptime t3;
+    ptime t4;
+    ptime t5;
+    ptime t6;
+    time_duration total_update;
+    int frame_count;
+#endif
+};
+
+// declare the static variables as some gcc versions have problems declaring them automaticaly
+bool OGLTransitionerImpl::cbBrokenTexturesATI;
+float OGLTransitionerImpl::cnGLVersion;
+bool OGLTransitionerImpl::cbMesa;
+bool OGLTransitionerImpl::cbGLXPresent;
+
+bool OGLTransitionerImpl::initialize( const Reference< presentation::XSlideShowView >& xView )
+{
+    // not thread safe
+    static bool initialized = false;
+
+    if( !initialized ) {
+        OGLTransitionerImpl *instance;
+
+        instance = new OGLTransitionerImpl( NULL );
+        if( instance->initWindowFromSlideShowView( xView ) ) {
+
+            const GLubyte* version = glGetString( GL_VERSION );
+            if( version && version[0] ) {
+                cnGLVersion = version[0] - '0';
+                if( version[1] == '.' && version[2] )
+                    cnGLVersion += (version[2] - '0')/10.0;
+            } else
+                cnGLVersion = 1.0;
+            OSL_TRACE("GL version: %s parsed: %f", version, cnGLVersion );
+
+            const GLubyte* vendor = glGetString( GL_VENDOR );
+            cbMesa = ( vendor && strstr( (const char *) vendor, "Mesa" ) );
+            OSL_TRACE("GL vendor: %s identified as Mesa: %d", vendor, cbMesa );
+
+            /* TODO: check for version once the bug in fglrx driver is fixed */
+            cbBrokenTexturesATI = (vendor && strcmp( (const char *) vendor, "ATI Technologies Inc." ) == 0 );
+
+            instance->disposing();
+            cbGLXPresent = true;
+        } else
+            cbGLXPresent = false;
+
+        delete instance;
+        initialized = true;
+    }
+
+    return cbGLXPresent;
+}
+
+bool OGLTransitionerImpl::createWindow( Window* pPWindow )
+{
+    const SystemEnvData* sysData(pPWindow->GetSystemData());
+#if defined( WNT ) 
+	GLWin.hWnd = sysData->hWnd;
+#elif defined( UNX )
+    GLWin.dpy = reinterpret_cast<unx::Display*>(sysData->pDisplay);
+
+    if( unx::glXQueryExtension( GLWin.dpy, NULL, NULL ) == false )
+        return false;
+
+    GLWin.win = sysData->aWindow;
+
+    OSL_TRACE("parent window: %d", GLWin.win);
+
+    unx::XWindowAttributes xattr;
+    unx::XGetWindowAttributes( GLWin.dpy, GLWin.win, &xattr );
+
+    GLWin.screen = XScreenNumberOfScreen( xattr.screen );
+
+    unx::XVisualInfo* vi( NULL );
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::XVisualInfo* visinfo;
+    unx::XVisualInfo* firstVisual( NULL );
+#endif
+    static int attrList3[] =
+        {
+	    GLX_RGBA,//only TrueColor or DirectColor
+            //single buffered
+            GLX_RED_SIZE,4,//use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,//use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,//use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,0,//no depth buffer
+            None
+        };
+    static int attrList2[] = 
+	{
+	    GLX_RGBA,//only TrueColor or DirectColor
+            /// single buffered
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+            None
+        };
+    static int attrList1[] =
+        {
+	    GLX_RGBA,//only TrueColor or DirectColor
+            GLX_DOUBLEBUFFER,/// only double buffer
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,0,/// no depth buffer
+            None
+        };
+    static int attrList0[] =
+        {
+	    GLX_RGBA,//only TrueColor or DirectColor
+            GLX_DOUBLEBUFFER,/// only double buffer
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+            None
+       }; 
+    static int* attrTable[] = 
+        {
+            attrList0,
+            attrList1,
+            attrList2,
+            attrList3,
+            NULL
+        };
+	int** pAttributeTable = attrTable;
+    const SystemEnvData* pChildSysData = NULL;
+    delete pWindow;
+    pWindow=NULL;
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::GLXFBConfig* fbconfigs = NULL;
+    int nfbconfigs, value, i = 0;
+#endif
+
+    while( *pAttributeTable )
+    {
+        // try to find a visual for the current set of attributes
+        vi = unx::glXChooseVisual( GLWin.dpy,
+                                   GLWin.screen,
+                                   *pAttributeTable );
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+      if( vi ) {
+	  if( !firstVisual )
+	      firstVisual = vi;
+	  OSL_TRACE("trying VisualID %08X", vi->visualid);
+          fbconfigs = glXGetFBConfigs (GLWin.dpy, GLWin.screen, &nfbconfigs);
+          for ( ; i < nfbconfigs; i++)
+          {
+              visinfo = glXGetVisualFromFBConfig (GLWin.dpy, fbconfigs[i]);
+              if( !visinfo || visinfo->visualid != vi->visualid )
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i], GLX_DRAWABLE_TYPE, &value);
+              if (!(value & GLX_PIXMAP_BIT))
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
+                                    GLX_BIND_TO_TEXTURE_TARGETS_EXT,
+                                    &value);
+              if (!(value & GLX_TEXTURE_2D_BIT_EXT))
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
+                                    GLX_BIND_TO_TEXTURE_RGB_EXT,
+                                    &value);
+              if (value == FALSE)
+                  continue;
+
+              glXGetFBConfigAttrib (GLWin.dpy, fbconfigs[i],
+                                    GLX_BIND_TO_MIPMAP_TEXTURE_EXT,
+                                    &value);
+              if (value == FALSE)
+                  continue;
+
+              /* TODO: handle non Y inverted cases */
+              break;
+          }
+
+          if( i != nfbconfigs || ( firstVisual && pAttributeTable[1] == NULL ) ) {
+	      if( i != nfbconfigs ) {
+		  vi = glXGetVisualFromFBConfig( GLWin.dpy, fbconfigs[i] );
+		  mbHasTFPVisual = true;
+		  OSL_TRACE("found visual suitable for texture_from_pixmap");
+	      } else {
+		  vi = firstVisual;
+		  mbHasTFPVisual = false;
+		  OSL_TRACE("did not find visual suitable for texture_from_pixmap, using %08X", vi->visualid);
+	      }
+#else
+	  if( vi ) {
+#endif
+              SystemWindowData winData;
+              winData.nSize = sizeof(winData);
+	      OSL_TRACE("using VisualID %08X", vi->visualid);
+              winData.pVisual = (void*)(vi->visual);
+              pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
+              pChildSysData = pWindow->GetSystemData();
+              if( pChildSysData ) {
+                  break;
+              } else {
+                  delete pWindow, pWindow=NULL;
+              }
+          }
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+      }
+#endif
+
+        ++pAttributeTable;
+      }
+#endif
+
+#if defined( WNT ) 
+      const SystemEnvData* pChildSysData = NULL;
+      SystemWindowData winData;
+      winData.nSize = sizeof(winData);
+      pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
+      pChildSysData = pWindow->GetSystemData();
+#endif            
+
+      if( pWindow )
+      {
+	  pWindow->SetMouseTransparent( TRUE );
+	  pWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+	  pWindow->EnableEraseBackground( FALSE );
+	  pWindow->SetControlForeground();
+	  pWindow->SetControlBackground();
+	  pWindow->EnablePaint(FALSE);
+#if defined( WNT ) 
+		GLWin.hWnd = sysData->hWnd;
+#elif defined( UNX )
+        GLWin.dpy = reinterpret_cast<unx::Display*>(pChildSysData->pDisplay);
+        GLWin.win = pChildSysData->aWindow;
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+	if( mbHasTFPVisual )
+	    GLWin.fbc = fbconfigs[i];
+#endif
+	GLWin.vi = vi;
+	GLWin.GLXExtensions = unx::glXQueryExtensionsString( GLWin.dpy, GLWin.screen );
+	OSL_TRACE("available GLX extensions: %s", GLWin.GLXExtensions);
+#endif
+
+	return true;
+    }
+
+    return false;
+}
+
+bool OGLTransitionerImpl::initWindowFromSlideShowView( const Reference< presentation::XSlideShowView >& xView )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return false;
+
+    mxView.set( xView, UNO_QUERY );
+    if( !mxView.is() )
+	return false;
+
+    /// take the XSlideShowView and extract the parent window from it. see viewmediashape.cxx
+    uno::Reference< rendering::XCanvas > xCanvas(mxView->getCanvas(), uno::UNO_QUERY_THROW);
+    uno::Sequence< uno::Any > aDeviceParams;
+    ::canvas::tools::getDeviceInfo( xCanvas, aDeviceParams );
+
+    ::rtl::OUString aImplName;
+    aDeviceParams[ 0 ] >>= aImplName;
+
+    sal_Int64 aVal = 0;
+    aDeviceParams[1] >>= aVal;
+    if( !createWindow( reinterpret_cast< Window* >( aVal ) ) )
+	return false;
+
+    awt::Rectangle aCanvasArea = mxView->getCanvasArea();
+    pWindow->SetPosSizePixel(aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
+    GLWin.Width = aCanvasArea.Width;
+    GLWin.Height = aCanvasArea.Height;
+    OSL_TRACE("canvas area: %d,%d - %dx%d", aCanvasArea.X, aCanvasArea.Y, aCanvasArea.Width, aCanvasArea.Height);
+
+#if defined( WNT ) 
+		GLWin.hDC = GetDC(GLWin.hWnd);
+#elif defined( UNX )
+    GLWin.ctx = glXCreateContext(GLWin.dpy,
+                                 GLWin.vi,
+                                 0,
+                                 GL_TRUE);
+    if( GLWin.ctx == NULL ) {
+	OSL_TRACE("unable to create GLX context");
+	return false;
+    }
+#endif
+
+#if defined( WNT ) 
+	PIXELFORMATDESCRIPTOR PixelFormatFront =					// PixelFormat Tells Windows How We Want Things To Be
+	{
+		sizeof(PIXELFORMATDESCRIPTOR),
+		1,								// Version Number
+		PFD_DRAW_TO_WINDOW |
+		PFD_SUPPORT_OPENGL |
+		PFD_DOUBLEBUFFER,
+		PFD_TYPE_RGBA,					// Request An RGBA Format
+		(BYTE)32,						// Select Our Color Depth
+		0, 0, 0, 0, 0, 0,				// Color Bits Ignored
+		0,								// No Alpha Buffer
+		0,								// Shift Bit Ignored
+		0,								// No Accumulation Buffer
+		0, 0, 0, 0,						// Accumulation Bits Ignored
+		64,								// 32 bit Z-BUFFER
+		0,								// 0 bit stencil buffer
+		0,								// No Auxiliary Buffer
+		0,								// now ignored
+		0,								// Reserved
+		0, 0, 0							// Layer Masks Ignored
+	};
+	int WindowPix = ChoosePixelFormat(GLWin.hDC,&PixelFormatFront);
+	SetPixelFormat(GLWin.hDC,WindowPix,&PixelFormatFront);
+	GLWin.hRC  = wglCreateContext(GLWin.hDC);
+	wglMakeCurrent(GLWin.hDC,GLWin.hRC);
+#elif defined( UNX )
+	if( !glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx ) ) {
+	    OSL_TRACE("unable to select current GLX context");
+	    return false;
+	}
+
+    int glxMinor, glxMajor;
+    mnGLXVersion = 0;
+    if( glXQueryVersion( GLWin.dpy, &glxMajor, &glxMinor ) )
+      mnGLXVersion = glxMajor + 0.1*glxMinor;
+    OSL_TRACE("available GLX version: %f", mnGLXVersion);
+
+    GLWin.GLExtensions = glGetString( GL_EXTENSIONS );
+    OSL_TRACE("available GL  extensions: %s", GLWin.GLExtensions);
+
+    mbTextureFromPixmap = GLWin.HasGLXExtension( "GLX_EXT_texture_from_pixmap" );
+    mbGenerateMipmap = GLWin.HasGLExtension( "GL_SGIS_generate_mipmap" );
+
+    if( GLWin.HasGLXExtension("GLX_SGI_swap_control" ) ) {
+	    // enable vsync
+	    typedef GLint (*glXSwapIntervalProc)(GLint);
+	    glXSwapIntervalProc glXSwapInterval = (glXSwapIntervalProc) unx::glXGetProcAddress( (const GLubyte*) "glXSwapIntervalSGI" );
+	    if( glXSwapInterval ) {
+		int (*oldHandler)(unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/);
+
+		// replace error handler temporarily
+		oldHandler = unx::XSetErrorHandler( oglErrorHandler );
+
+		errorTriggered = false;
+
+		glXSwapInterval( 1 );
+
+		// sync so that we possibly get an XError
+		unx::glXWaitGL();
+		XSync(GLWin.dpy, false);
+
+		if( errorTriggered )
+		    OSL_TRACE("error when trying to set swap interval, NVIDIA or Mesa bug?");
+		else
+		    OSL_TRACE("set swap interval to 1 (enable vsync)");
+
+		// restore the error handler
+		unx::XSetErrorHandler( oldHandler );
+	    }
+    }
+#endif
+
+    glEnable(GL_CULL_FACE);
+    glCullFace(GL_BACK);
+    glClearColor (0, 0, 0, 0);
+    glClear(GL_COLOR_BUFFER_BIT);
+#if defined( WNT ) 
+	SwapBuffers(GLWin.hDC);
+#elif defined( UNX )
+    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
+#endif
+   
+    glEnable(GL_LIGHTING);
+    GLfloat light_direction[] = { 0.0 , 0.0 , 1.0 };
+    GLfloat materialDiffuse[] = { 1.0 , 1.0 , 1.0 , 1.0};
+    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, light_direction);
+    glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
+    glEnable(GL_LIGHT0);
+    glEnable(GL_NORMALIZE);
+
+    if( LeavingBytes.hasElements() && EnteringBytes.hasElements())
+       GLInitSlides();//we already have uninitialized slides, let's initialize 
+
+    if( pTransition && pTransition->mnRequiredGLVersion <= cnGLVersion )
+        pTransition->prepare( GLleavingSlide, GLenteringSlide );
+
+    return true;
+}
+
+void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
+                                     const uno::Reference< rendering::XBitmap >& xEnteringSlide )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+        
+    mxLeavingBitmap.set( xLeavingSlide , UNO_QUERY_THROW );
+    mxEnteringBitmap.set( xEnteringSlide , UNO_QUERY_THROW );
+    Reference< XFastPropertySet > xLeavingSet( xLeavingSlide , UNO_QUERY );
+    Reference< XFastPropertySet > xEnteringSet( xEnteringSlide , UNO_QUERY );
+
+    geometry::IntegerRectangle2D SlideRect;
+    SlideSize = mxLeavingBitmap->getSize();
+    SlideRect.X1 = 0;
+    SlideRect.X2 = SlideSize.Width;
+    SlideRect.Y1 = 0;
+    SlideRect.Y2 = SlideSize.Height;
+
+    OSL_TRACE("leaving bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
+    SlideSize = mxEnteringBitmap->getSize();
+    OSL_TRACE("entering bitmap area: %dx%d", SlideSize.Width, SlideSize.Height);
+
+#ifdef UNX
+    unx::glXWaitGL();
+    XSync(GLWin.dpy, false);
+#endif
+
+#ifdef DEBUG
+    t1 = microsec_clock::local_time();
+#endif
+
+    mbUseLeavingPixmap = false;
+    mbUseEnteringPixmap = false;
+
+#ifdef UNX
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+
+    if( mnGLXVersion >= 1.2999 && mbTextureFromPixmap && xLeavingSet.is() && xEnteringSet.is() && mbHasTFPVisual ) {
+	Sequence< Any > leaveArgs;
+	Sequence< Any > enterArgs;
+	if( (xLeavingSet->getFastPropertyValue( 1 ) >>= leaveArgs) &&
+	    (xEnteringSet->getFastPropertyValue( 1 ) >>= enterArgs) ) {
+	    OSL_TRACE ("pixmaps available");
+
+	    sal_Int32 depth;
+
+	    leaveArgs[0] >>= mbFreeLeavingPixmap;
+	    enterArgs[0] >>= mbFreeEnteringPixmap;
+	    leaveArgs[1] >>= maLeavingPixmap;
+	    enterArgs[1] >>= maEnteringPixmap;
+	    leaveArgs[2] >>= depth;
+
+	    int pixmapAttribs[] = { GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
+				    GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGB_EXT,
+				    GLX_MIPMAP_TEXTURE_EXT, True,
+				    None };
+
+
+	    // sync so that we possibly get an pending XError, before we set our handler.
+	    // this way we will not miss any error from other code
+	    unx::glXWaitGL();
+	    XSync(GLWin.dpy, false);
+
+	    int (*oldHandler)(unx::Display* /*dpy*/, unx::XErrorEvent* /*evnt*/);
+
+	    // replace error handler temporarily
+	    oldHandler = unx::XSetErrorHandler( oglErrorHandler );
+
+	    errorTriggered = false;
+	    LeavingPixmap = glXCreatePixmap( GLWin.dpy, GLWin.fbc, maLeavingPixmap, pixmapAttribs );
+
+	    // sync so that we possibly get an XError
+	    unx::glXWaitGL();
+	    XSync(GLWin.dpy, false);
+
+	    if( !errorTriggered )
+		mbUseLeavingPixmap = true;
+	    else {
+		OSL_TRACE("XError triggered");
+		if( mbFreeLeavingPixmap ) {
+		    unx::XFreePixmap( GLWin.dpy, maLeavingPixmap );
+		    mbFreeLeavingPixmap = false;
+		}
+		errorTriggered = false;
+	    }
+          
+	    EnteringPixmap = glXCreatePixmap( GLWin.dpy, GLWin.fbc, maEnteringPixmap, pixmapAttribs );
+
+	    // sync so that we possibly get an XError
+	    unx::glXWaitGL();
+	    XSync(GLWin.dpy, false);
+
+	    OSL_TRACE("created glx pixmap %p and %p depth: %d", LeavingPixmap, EnteringPixmap, depth);
+	    if( !errorTriggered )
+		mbUseEnteringPixmap = true;
+	    else {
+		OSL_TRACE("XError triggered");
+		if( mbFreeEnteringPixmap ) {
+		    unx::XFreePixmap( GLWin.dpy, maEnteringPixmap );
+		    mbFreeEnteringPixmap = false;
+		}
+	    }
+
+	    // restore the error handler
+	    unx::XSetErrorHandler( oldHandler );
+	}
+    }
+
+#endif
+#endif
+    if( !mbUseLeavingPixmap )
+	LeavingBytes = mxLeavingBitmap->getData(SlideBitmapLayout,SlideRect);
+    if( !mbUseEnteringPixmap )
+	EnteringBytes = mxEnteringBitmap->getData(SlideBitmapLayout,SlideRect);
+
+// TODO    
+#ifdef UNX
+    if(GLWin.ctx)//if we have a rendering context, let's init the slides
+#endif
+	GLInitSlides();
+
+    OSL_ENSURE(SlideBitmapLayout.PlaneStride == 0,"only handle no plane stride now");
+
+#ifdef UNX
+    /* flush & sync */
+    unx::glXWaitGL();
+    XSync( GLWin.dpy, false );
+
+    // synchronized X still gives us much smoother play
+    // I suspect some issues in above code in slideshow
+    // synchronize whole transition for now
+    XSynchronize( GLWin.dpy, true );
+    mbRestoreSync = true;
+#endif
+}
+
+void OGLTransitionerImpl::createTexture( unsigned int* texID,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+					 unx::GLXPixmap pixmap,
+					 bool usePixmap,
+#endif
+					 bool useMipmap,
+					 uno::Sequence<sal_Int8>& data,
+					 const OGLFormat* pFormat )
+{
+    glDeleteTextures( 1, texID );
+    glGenTextures( 1, texID );
+    glBindTexture( GL_TEXTURE_2D, *texID );
+    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
+    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::PFNGLXBINDTEXIMAGEEXTPROC myglXBindTexImageEXT = (unx::PFNGLXBINDTEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXBindTexImageEXT" );
+
+    if( usePixmap ) {
+      if( mbGenerateMipmap )
+          glTexParameteri( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS, True);
+      myglXBindTexImageEXT (GLWin.dpy, pixmap, GLX_FRONT_LEFT_EXT, NULL);
+      if( mbGenerateMipmap && useMipmap ) {
+          OSL_TRACE("use mipmaps");
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
+      } else {
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+      }
+    } else {
+#endif
+    if( !pFormat )
+    {
+        // force-convert color to ARGB8888 int color space  
+        uno::Sequence<sal_Int8> tempBytes(
+            SlideBitmapLayout.ColorSpace->convertToIntegerColorSpace(
+                data,
+                canvas::tools::getStdColorSpace()));
+        gluBuild2DMipmaps(GL_TEXTURE_2D, 
+                          4, 
+                          SlideSize.Width, 
+                          SlideSize.Height, 
+                          GL_RGBA, 
+                          GL_UNSIGNED_BYTE,
+                          &tempBytes[0]);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR); //TRILINEAR FILTERING
+
+        //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+	GLfloat largest_supported_anisotropy;
+	glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy);
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy);
+    } else {
+	if( pTransition && !cbBrokenTexturesATI && !useMipmap) {
+	    glTexImage2D( GL_TEXTURE_2D, 0, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, 0, pFormat->eFormat, pFormat->eType, &data[0] );
+	    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+	    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+	} else {
+	    gluBuild2DMipmaps( GL_TEXTURE_2D, pFormat->nInternalFormat, SlideSize.Width, SlideSize.Height, pFormat->eFormat, pFormat->eType, &data[0] );
+	    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+	    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR ); //TRILINEAR FILTERING
+
+	    //anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+	    GLfloat largest_supported_anisotropy;
+	    glGetFloatv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy );
+	    glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy );
+	}
+    }
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    }
+#endif
+    OSL_ENSURE(glIsTexture(*texID), "Can't generate Leaving slide textures in OpenGL");
+}
+
+void OGLTransitionerImpl::prepareEnvironment()
+{
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    double EyePos(10.0);
+    double RealF(1.0);
+    double RealN(-1.0);
+    double RealL(-1.0);
+    double RealR(1.0);
+    double RealB(-1.0);
+    double RealT(1.0);
+    double ClipN(EyePos+5.0*RealN);
+    double ClipF(EyePos+15.0*RealF);
+    double ClipL(RealL*8.0);
+    double ClipR(RealR*8.0);
+    double ClipB(RealB*8.0);
+    double ClipT(RealT*8.0);
+    //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
+    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ),
+              1.0 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ),
+              1.0 );
+    glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    glTranslated(0,0,-EyePos);
+}
+
+const OGLFormat* OGLTransitionerImpl::chooseFormats()
+{
+    const OGLFormat* pDetectedFormat=NULL;
+    uno::Reference<rendering::XIntegerBitmapColorSpace> xIntColorSpace(
+        SlideBitmapLayout.ColorSpace);
+
+    if( (xIntColorSpace->getType() == rendering::ColorSpaceType::RGB ||
+         xIntColorSpace->getType() == rendering::ColorSpaceType::SRGB) )
+    {
+        /* table for canvas->OGL format mapping. outer index is number
+           of color components (0:3, 1:4), then comes bits per pixel
+           (0:16, 1:24, 2:32), then channel ordering: (0:rgba, 1:bgra,
+           2:argb, 3:abgr)
+         */
+        static const OGLFormat lcl_RGB24[] = 
+        {
+            // 24 bit RGB
+            {3, GL_BGR, GL_UNSIGNED_BYTE},
+            {3, GL_RGB, GL_UNSIGNED_BYTE},
+            {3, GL_BGR, GL_UNSIGNED_BYTE},
+            {3, GL_RGB, GL_UNSIGNED_BYTE}
+        };
+
+#if defined(GL_VERSION_1_2) && defined(GLU_VERSION_1_3)
+        // more format constants available
+        static const OGLFormat lcl_RGB16[] = 
+        {
+            // 16 bit RGB
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5_REV},
+            {3, GL_RGB, GL_UNSIGNED_SHORT_5_6_5}
+        };
+
+        static const OGLFormat lcl_ARGB16_4[] = 
+        {
+            // 16 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_4_4_4_4},
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4}
+        };
+
+        static const OGLFormat lcl_ARGB16_5[] = 
+        {
+            // 16 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV},
+            {4, GL_BGRA, GL_UNSIGNED_SHORT_5_5_5_1},
+            {4, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1}
+        };
+
+        static const OGLFormat lcl_ARGB32[] = 
+        {
+            // 32 bit ARGB
+            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV},
+            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV},
+            {4, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8},
+            {4, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8}
+        };
+
+        const uno::Sequence<sal_Int8> aComponentTags(
+            xIntColorSpace->getComponentTags());
+        const uno::Sequence<sal_Int32> aComponentBitcounts(
+            xIntColorSpace->getComponentBitCounts());
+        const sal_Int32 nNumComponents( aComponentBitcounts.getLength() );
+        const sal_Int32 nBitsPerPixel( xIntColorSpace->getBitsPerPixel() );
+
+        // supported component ordering?
+        const int nComponentOrderIndex(
+            calcComponentOrderIndex(aComponentTags));
+        if( nComponentOrderIndex != -1 ) 
+        {
+            switch( nBitsPerPixel )
+            {
+                case 16:
+                    if( nNumComponents == 3 )
+                    {
+                        pDetectedFormat = &lcl_RGB16[nComponentOrderIndex];
+                    }
+                    else if( nNumComponents == 4 )
+                    {
+                        if( aComponentBitcounts[1] == 4 )
+                        {
+                            pDetectedFormat = &lcl_ARGB16_4[nComponentOrderIndex];
+                        }
+                        else if( aComponentBitcounts[1] == 5 )
+                        {
+                            pDetectedFormat = &lcl_ARGB16_5[nComponentOrderIndex];
+                        }
+                    }
+                    break;
+                case 24:
+                    if( nNumComponents == 3 )
+                    {
+                        pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
+                    }
+                    break;
+                case 32:
+                    pDetectedFormat = &lcl_ARGB32[nComponentOrderIndex];
+                    break;
+            }
+        }
+#else
+        const uno::Sequence<sal_Int8> aComponentTags(
+            xIntColorSpace->getComponentTags());
+        const int nComponentOrderIndex(calcComponentOrderIndex(aComponentTags));
+        if( aComponentTags.getLength() == 3 && 
+            nComponentOrderIndex != -1 && 
+            xIntColorSpace->getBitsPerPixel() == 24 )
+        {
+            pDetectedFormat = &lcl_RGB24[nComponentOrderIndex];
+        }
+#endif
+    }
+
+    return pDetectedFormat;
+}
+
+void OGLTransitionerImpl::GLInitSlides()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed() || pTransition->mnRequiredGLVersion > cnGLVersion)
+        return;
+
+    prepareEnvironment();
+
+    const OGLFormat* pFormat = NULL;
+    if( !mbUseLeavingPixmap || !mbUseEnteringPixmap )
+	pFormat = chooseFormats();
+
+    createTexture( &GLleavingSlide,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+		   LeavingPixmap,
+		   mbUseLeavingPixmap,
+#endif
+		   pTransition->mbUseMipMapLeaving,
+		   LeavingBytes,
+		   pFormat );
+
+    createTexture( &GLenteringSlide,
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+		   EnteringPixmap,
+		   mbUseEnteringPixmap,
+#endif
+		   pTransition->mbUseMipMapEntering,
+		   EnteringBytes,
+		   pFormat );
+
+#ifdef UNX
+    unx::glXWaitGL();
+    XSync(GLWin.dpy, false);
+#endif
+
+#ifdef DEBUG
+    t2 = microsec_clock::local_time();
+    OSL_TRACE("textures created in: %s", to_simple_string( t2 - t1 ).c_str());
+#endif
+}
+
+void SAL_CALL OGLTransitionerImpl::update( double nTime ) throw (uno::RuntimeException)
+{
+#ifdef DEBUG
+    frame_count ++;
+    t3 = microsec_clock::local_time();
+    if( frame_count == 1 ) {
+	t5 = t3;
+	total_update = seconds (0);
+    }
+#endif
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed() || !cbGLXPresent || pTransition->mnRequiredGLVersion > cnGLVersion)
+        return;
+
+#ifdef WNT
+    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
+#endif
+#ifdef UNX
+    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
+#endif
+
+    glEnable(GL_DEPTH_TEST);
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+    if(pTransition)
+	pTransition->display( nTime, GLleavingSlide, GLenteringSlide, 
+                              SlideSize.Width, SlideSize.Height,
+                              static_cast<double>(GLWin.Width),
+                              static_cast<double>(GLWin.Height) );
+
+#if defined( WNT ) 
+    SwapBuffers(GLWin.hDC);
+#elif defined( UNX )
+    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
+#endif
+    if( pWindow )
+        pWindow->Show();
+
+#ifdef UNX
+    /* flush & sync */
+    unx::glXWaitGL();
+    XSync( GLWin.dpy, false );
+#endif
+
+#ifdef DEBUG
+    t4 = microsec_clock::local_time();
+
+    OSL_TRACE("update time: %f", nTime);
+    OSL_TRACE("update took: %s", to_simple_string( t4 - t3 ).c_str());
+    total_update += (t4 - t3);
+#endif
+}
+
+void SAL_CALL OGLTransitionerImpl::viewChanged( const Reference< presentation::XSlideShowView >& rView,
+						const Reference< rendering::XBitmap >& rLeavingBitmap,
+						const Reference< rendering::XBitmap >& rEnteringBitmap )
+    throw (uno::RuntimeException)
+{
+    OSL_TRACE("transitioner: view changed");
+
+    disposeTextures();
+    disposeContextAndWindow();
+
+    initWindowFromSlideShowView( rView );
+    setSlides( rLeavingBitmap, rEnteringBitmap );
+}
+
+void OGLTransitionerImpl::disposeContextAndWindow()
+{
+#if defined( WNT )
+    if (GLWin.hRC)
+    {
+	wglMakeCurrent( GLWin.hDC, 0 );		// kill Device Context
+	wglDeleteContext( GLWin.hRC );		// Kill Render Context
+	ReleaseDC( GLWin.hWnd, GLWin.hDC );         // Release Window
+    }
+#elif defined( UNX )
+    if(GLWin.ctx)
+    {
+	glXMakeCurrent(GLWin.dpy, None, NULL);
+	if( glGetError() != GL_NO_ERROR ) {
+	    OSL_TRACE("glError: %s", (char *)gluErrorString(glGetError()));
+	}
+	glXDestroyContext(GLWin.dpy, GLWin.ctx);
+	GLWin.ctx = NULL;
+    }
+#endif
+    if( pWindow ) {
+	delete pWindow;
+	pWindow = NULL;
+	GLWin.win = 0;
+    }
+}
+
+void OGLTransitionerImpl::disposeTextures()
+{
+#ifdef WNT
+    wglMakeCurrent(GLWin.hDC,GLWin.hRC);
+#endif
+#ifdef UNX
+    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
+#endif
+
+#if defined( GLX_VERSION_1_3 ) && defined( GLX_EXT_texture_from_pixmap )
+    unx::PFNGLXRELEASETEXIMAGEEXTPROC myglXReleaseTexImageEXT = (unx::PFNGLXRELEASETEXIMAGEEXTPROC) unx::glXGetProcAddress( (const GLubyte*) "glXReleaseTexImageEXT" );
+    if( mbUseLeavingPixmap ) {
+
+	myglXReleaseTexImageEXT( GLWin.dpy, LeavingPixmap, GLX_FRONT_LEFT_EXT );
+	glXDestroyGLXPixmap( GLWin.dpy, LeavingPixmap );
+	LeavingPixmap = 0;
+	if( mbFreeLeavingPixmap ) {
+	    unx::XFreePixmap( GLWin.dpy, maLeavingPixmap );
+	    mbFreeLeavingPixmap = false;
+	    maLeavingPixmap = 0;
+	}
+    }
+    if( mbUseEnteringPixmap ) {
+	myglXReleaseTexImageEXT( GLWin.dpy, EnteringPixmap, GLX_FRONT_LEFT_EXT );
+	glXDestroyGLXPixmap( GLWin.dpy, EnteringPixmap );
+	EnteringPixmap = 0;
+	if( mbFreeEnteringPixmap ) {
+	    unx::XFreePixmap( GLWin.dpy, maEnteringPixmap );
+	    mbFreeEnteringPixmap = false;
+	    maEnteringPixmap = 0;
+	}
+    }
+#endif
+
+    if( !mbUseLeavingPixmap ) {
+	glDeleteTextures(1,&GLleavingSlide);
+	GLleavingSlide = 0;
+    }
+    if( !mbUseEnteringPixmap ) {
+	glDeleteTextures(1,&GLenteringSlide);
+	GLleavingSlide = 0;
+    }
+
+    mbUseLeavingPixmap = false;
+    mbUseEnteringPixmap = false;
+}
+
+// we are about to be disposed (someone call dispose() on us)
+void OGLTransitionerImpl::disposing()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+#ifdef DEBUG
+    OSL_TRACE("dispose %p\n", this);
+    if( frame_count ) {
+	t6 = microsec_clock::local_time();
+	time_duration duration = t6 - t5;
+	OSL_TRACE("whole transition (frames: %d) took: %s fps: %f time spent in updates: %s percentage of transition time: %f%%",
+		  frame_count, to_simple_string( duration ).c_str(),
+		  ((double)frame_count*1000000000.0)/duration.total_nanoseconds(),
+		  to_simple_string( total_update ).c_str(),
+		  100*(((double)total_update.total_nanoseconds())/((double)duration.total_nanoseconds()))
+	    );
+    }
+#endif
+
+    if( pWindow ) {
+
+	disposeTextures();
+
+	if (pTransition)
+	    pTransition->finish();
+
+#ifdef UNX
+	if( mbRestoreSync ) {
+	    // try to reestablish synchronize state
+	    char* sal_synchronize = getenv("SAL_SYNCHRONIZE");
+	    XSynchronize( GLWin.dpy, sal_synchronize && *sal_synchronize == '1' );
+	}
+#endif
+
+	disposeContextAndWindow();
+    }
+
+    if (pTransition)
+	delete pTransition;
+
+    mxLeavingBitmap.clear();
+    mxEnteringBitmap.clear();
+    mxView.clear();
+}
+
+OGLTransitionerImpl::OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition) : 
+    OGLTransitionerImplBase(m_aMutex), 
+    GLWin(),
+    GLleavingSlide( 0 ), 
+    GLenteringSlide( 0 ), 
+    pWindow( NULL ), 
+    mxView(),
+    EnteringBytes(),
+    LeavingBytes(),
+    mbRestoreSync( false ),
+    mbUseLeavingPixmap( false ),
+    mbUseEnteringPixmap( false ),
+    SlideBitmapLayout(),
+    SlideSize(),
+    pTransition(pOGLTransition)
+{
+#if defined( WNT )
+	GLWin.hWnd = 0;
+#elif defined( UNX )
+    GLWin.ctx = 0;
+#endif
+
+    DBG(frame_count = 0);
+}
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransitionFactory> OGLTransitionFactoryImplBase;
+
+class OGLTransitionFactoryImpl : private cppu::BaseMutex, public OGLTransitionFactoryImplBase
+{
+public:
+    explicit OGLTransitionFactoryImpl( const uno::Reference< uno::XComponentContext >& ) :
+        OGLTransitionFactoryImplBase(m_aMutex)
+    {}
+
+    // XTransitionFactory
+    virtual ::sal_Bool SAL_CALL hasTransition( ::sal_Int16 transitionType, ::sal_Int16 transitionSubType ) throw (uno::RuntimeException)
+    {
+        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
+            switch( transitionSubType )
+                {
+                case animations::TransitionSubType::ACROSS:
+                case animations::TransitionSubType::CORNERSOUT:
+                case animations::TransitionSubType::CIRCLE:
+                case animations::TransitionSubType::FANOUTHORIZONTAL:
+                case animations::TransitionSubType::CORNERSIN:  
+                case animations::TransitionSubType::LEFTTORIGHT:
+                case animations::TransitionSubType::TOPTOBOTTOM:
+                case animations::TransitionSubType::TOPRIGHT:
+                case animations::TransitionSubType::TOPLEFT:
+                case animations::TransitionSubType::BOTTOMRIGHT:
+                case animations::TransitionSubType::BOTTOMLEFT:
+                case animations::TransitionSubType::TOPCENTER:
+                case animations::TransitionSubType::RIGHTCENTER:
+                case animations::TransitionSubType::BOTTOMCENTER:
+                    return sal_True;
+
+                default:
+                    return sal_False;
+                }
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
+            return sal_True;
+        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
+            return sal_True;
+        } else
+            return sal_False;
+    }
+
+    virtual uno::Reference< presentation::XTransition > SAL_CALL createTransition( 
+        ::sal_Int16                                           transitionType, 
+        ::sal_Int16                                           transitionSubType, 
+        const uno::Reference< presentation::XSlideShowView >& view, 
+        const uno::Reference< rendering::XBitmap >&           leavingBitmap, 
+        const uno::Reference< rendering::XBitmap >&           enteringBitmap )
+	throw (uno::RuntimeException)
+    {
+        if( !hasTransition( transitionType, transitionSubType ) )
+            return uno::Reference< presentation::XTransition >();
+
+        bool bGLXPresent = OGLTransitionerImpl::initialize( view );
+
+        if( OGLTransitionerImpl::cbMesa && (
+            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) ||
+            ( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) ||
+            ( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) ) )
+            return uno::Reference< presentation::XTransition >();
+            
+
+        OGLTransitionImpl* pTransition = NULL;
+
+        if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
+            pTransition = new OGLTransitionImpl();
+            switch( transitionSubType )
+                {
+                case animations::TransitionSubType::ACROSS:
+                    pTransition->makeNByMTileFlip(8,6);
+                    break;   
+                case animations::TransitionSubType::CORNERSOUT:
+                    pTransition->makeOutsideCubeFaceToLeft();
+                    break;            
+                case animations::TransitionSubType::CIRCLE:
+                    pTransition->makeRevolvingCircles(8,128);
+                    break;
+                case animations::TransitionSubType::FANOUTHORIZONTAL:
+                    pTransition->makeHelix(20);
+                    break;
+                case animations::TransitionSubType::CORNERSIN:  
+                    pTransition->makeInsideCubeFaceToLeft();
+                    break;
+                case animations::TransitionSubType::LEFTTORIGHT:
+                    pTransition->makeFallLeaving();
+                    break;
+                case animations::TransitionSubType::TOPTOBOTTOM:
+                    pTransition->makeTurnAround();
+                    break;
+                case animations::TransitionSubType::TOPRIGHT:
+                    pTransition->makeTurnDown();
+                    break;
+                case animations::TransitionSubType::TOPLEFT:
+                    pTransition->makeIris();
+                    break;
+                case animations::TransitionSubType::BOTTOMRIGHT:
+                    pTransition->makeRochade();
+                    break;
+                case animations::TransitionSubType::BOTTOMLEFT:
+                    pTransition->makeVenetianBlinds( true, 8 );
+                    break;
+                case animations::TransitionSubType::TOPCENTER:
+                    pTransition->makeVenetianBlinds( false, 6 );
+                    break;
+                case animations::TransitionSubType::RIGHTCENTER:
+                    pTransition->makeStatic();
+                    break;
+                case animations::TransitionSubType::BOTTOMCENTER:
+                    pTransition->makeDissolve();
+                    break;
+                }
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::CROSSFADE ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeFadeSmoothly();
+        } else if( transitionType == animations::TransitionType::FADE && transitionSubType == animations::TransitionSubType::FADEOVERCOLOR ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeFadeThroughBlack();
+        } else if( transitionType == animations::TransitionType::IRISWIPE && transitionSubType == animations::TransitionSubType::DIAMOND ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeDiamond();
+        } else if( transitionType == animations::TransitionType::ZOOM && transitionSubType == animations::TransitionSubType::ROTATEIN ) {
+            pTransition = new OGLTransitionImpl();
+            pTransition->makeNewsflash();
+        }
+
+        rtl::Reference<OGLTransitionerImpl> xRes(
+            new OGLTransitionerImpl(pTransition) );
+        if( bGLXPresent ) {
+            if( !xRes->initWindowFromSlideShowView(view))
+                return uno::Reference< presentation::XTransition >();
+            xRes->setSlides(leavingBitmap,enteringBitmap);
+        }
+
+        return uno::Reference<presentation::XTransition>(xRes.get());
+    }
+};
+
+}
+
+namespace sdecl = comphelper::service_decl;
+#if defined (__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ <= 3)
+ sdecl::class_<OGLTransitionFactoryImpl> serviceImpl;
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     serviceImpl,
+#else
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     sdecl::class_<OGLTransitionFactoryImpl>(),
+#endif
+    "com.sun.star.comp.presentation.OGLTransitionFactory",
+    "com.sun.star.presentation.TransitionFactory" );
+
+// The C shared lib entry points
+COMPHELPER_SERVICEDECL_EXPORTS1(OGLTransitionFactoryDecl)
diff --git slideshow/source/engine/OGLTrans/win/makefile.mk slideshow/source/engine/OGLTrans/win/makefile.mk
new file mode 100644
index 0000000..ad97afa
--- /dev/null
+++ slideshow/source/engine/OGLTrans/win/makefile.mk
@@ -0,0 +1,76 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.5.12.1 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..
+
+PRJNAME=slideshow
+TARGET=OGLTrans
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :      settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+# --- Nothing to do if we're compiling with --disable-opengl -----------
+.IF "$(ENABLE_OPENGL)" != "TRUE" || "$(OS)" != "WNT"
+@all:
+	@echo "Building without OpenGL Transitions..."
+.ENDIF
+
+# --- Common ----------------------------------------------------------
+
+SLOFILES = \
+	$(SLO)$/OGLTrans_TransitionImpl_$(OS).obj \
+	$(SLO)$/OGLTrans_Shaders_$(OS).obj \
+	$(SLO)$/OGLTrans_TransitionerImpl_$(OS).obj
+
+SHL1TARGET=$(TARGET).uno
+
+SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB)
+
+SHL1STDLIBS += \
+	opengl32.lib \
+	glu32.lib \
+	gdi32.lib
+
+SHL1IMPLIB=i$(TARGET)
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+SHL1VERSIONMAP=../exports.map
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=../exports.dxp
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
