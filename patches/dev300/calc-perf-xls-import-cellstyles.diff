 sc/inc/attarray.hxx                |    1 +
 sc/inc/column.hxx                  |    2 +
 sc/inc/document.hxx                |    4 +
 sc/inc/table.hxx                   |    2 +
 sc/source/core/data/attarray.cxx   |   15 +++++
 sc/source/core/data/column.cxx     |    4 +
 sc/source/core/data/document.cxx   |    8 +++
 sc/source/core/data/table2.cxx     |    8 +++
 sc/source/filter/excel/xistyle.cxx |  107 +++++++++++++++++++++++++++---------
 sc/source/filter/inc/xistyle.hxx   |   20 +-----
 10 files changed, 129 insertions(+), 42 deletions(-)

diff --git sc/inc/attarray.hxx sc/inc/attarray.hxx
index f3a3361..510b6c5 100644
--- sc/inc/attarray.hxx
+++ sc/inc/attarray.hxx
@@ -133,6 +133,7 @@ public:
     void	ApplyStyleArea( SCROW nStartRow, SCROW nEndRow, ScStyleSheet* pStyle );
     void	ApplyCacheArea( SCROW nStartRow, SCROW nEndRow, SfxItemPoolCache* pCache,
                             ScEditDataArray* pDataArray = NULL );
+    bool    SetAttrEntries(ScAttrEntry* pNewData, SCSIZE nSize);
     void	ApplyLineStyleArea( SCROW nStartRow, SCROW nEndRow,
                                 const SvxBorderLine* pLine, BOOL bColorOnly );
 
diff --git sc/inc/column.hxx sc/inc/column.hxx
index 4e6dbf0..bc4ea23 100644
--- sc/inc/column.hxx
+++ sc/inc/column.hxx
@@ -51,6 +51,7 @@ class SvxBoxItem;
 
 class ScAttrIterator;
 class ScAttrArray;
+struct ScAttrEntry;
 class ScBaseCell;
 class ScDocument;
 class ScEditDataArray;
@@ -324,6 +325,7 @@ public:
     void		ApplyPattern( SCROW nRow, const ScPatternAttr& rPatAttr );
     void		ApplyPatternArea( SCROW nStartRow, SCROW nEndRow, const ScPatternAttr& rPatAttr,
                                   ScEditDataArray* pDataArray = NULL );
+    bool        SetAttrEntries(ScAttrEntry* pData, SCSIZE nSize);
     void		SetPattern( SCROW nRow, const ScPatternAttr& rPatAttr, BOOL bPutToPool = FALSE );
     void		SetPatternArea( SCROW nStartRow, SCROW nEndRow,
                                 const ScPatternAttr& rPatAttr, BOOL bPutToPool = FALSE );
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 4866f4b..bd8fb12 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -83,6 +83,7 @@ class Window;
 class XColorTable;
 class List;
 
+struct ScAttrEntry;
 class ScAutoFormatData;
 class ScBaseCell;
 class ScStringCell;
@@ -1219,6 +1220,9 @@ public:
     SC_DLLPUBLIC void			ApplyPatternAreaTab( SCCOL nStartCol, SCROW nStartRow,
                                             SCCOL nEndCol, SCROW nEndRow, SCTAB nTab,
                                             const ScPatternAttr& rAttr );
+
+    SC_DLLPUBLIC bool SetAttrEntries(SCCOL nCol, SCTAB nTab, ScAttrEntry* pData, SCSIZE nSize);
+
     SC_DLLPUBLIC void			ApplyPatternIfNumberformatIncompatible(
                             const ScRange& rRange, const ScMarkData& rMark,
                             const ScPatternAttr& rPattern, short nNewType );
diff --git sc/inc/table.hxx sc/inc/table.hxx
index 709000e..9a5725e 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -536,6 +536,8 @@ public:
     void		ApplyPattern( SCCOL nCol, SCROW nRow, const ScPatternAttr& rAttr );
     void		ApplyPatternArea( SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol, SCROW nEndRow,
                                   const ScPatternAttr& rAttr, ScEditDataArray* pDataArray = NULL );
+    bool        SetAttrEntries(SCCOL nCol, ScAttrEntry* pData, SCSIZE nSize);
+
     void		SetPattern( const ScAddress& rPos, const ScPatternAttr& rAttr, BOOL bPutToPool = FALSE )
                     {
                         if (ValidColRow(rPos.Col(),rPos.Row()))
diff --git sc/source/core/data/attarray.cxx sc/source/core/data/attarray.cxx
index d5001ad..d0b457f 100644
--- sc/source/core/data/attarray.cxx
+++ sc/source/core/data/attarray.cxx
@@ -836,6 +836,21 @@ void ScAttrArray::ApplyCacheArea( SCROW nStartRow, SCROW nEndRow, SfxItemPoolCac
 #endif
 }
 
+bool ScAttrArray::SetAttrEntries(ScAttrEntry* pNewData, SCSIZE nSize)
+{
+    if (pData)
+    {
+        ScDocumentPool* pDocPool = pDocument->GetPool();
+        for (SCSIZE i=0; i<nCount; i++)
+            pDocPool->Remove(*pData[i].pPattern);
+
+        delete[] pData;
+    }
+
+    pData = pNewData;
+    nCount = nLimit = nSize;
+    return true;
+}
 
 void lcl_MergeDeep( SfxItemSet& rMergeSet, const SfxItemSet& rSource )
 {
diff --git sc/source/core/data/column.cxx sc/source/core/data/column.cxx
index b35d019..99ceb84 100644
--- sc/source/core/data/column.cxx
+++ sc/source/core/data/column.cxx
@@ -482,6 +482,10 @@ void ScColumn::ApplyPatternArea( SCROW nStartRow, SCROW nEndRow, const ScPattern
     pAttrArray->ApplyCacheArea( nStartRow, nEndRow, &aCache, pDataArray );
 }
 
+bool ScColumn::SetAttrEntries(ScAttrEntry* pData, SCSIZE nSize)
+{
+    return pAttrArray->SetAttrEntries(pData, nSize);
+}
 
 void ScColumn::ApplyPatternIfNumberformatIncompatible( const ScRange& rRange,
         const ScPatternAttr& rPattern, short nNewType )
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 1d6048f..44bbc66 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -3886,6 +3886,14 @@ void ScDocument::ApplyPatternAreaTab( SCCOL nStartCol, SCROW nStartRow,
             pTab[nTab]->ApplyPatternArea( nStartCol, nStartRow, nEndCol, nEndRow, rAttr );
 }
 
+bool ScDocument::SetAttrEntries(SCCOL nCol, SCTAB nTab, ScAttrEntry* pData, SCSIZE nSize)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return false;
+
+    return pTab[nTab]->SetAttrEntries(nCol, pData, nSize);
+}
+
 void ScDocument::ApplyPatternIfNumberformatIncompatible( const ScRange& rRange,
         const ScMarkData& rMark, const ScPatternAttr& rPattern, short nNewType )
 {
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index e0a34fa..c003a14 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -1802,6 +1802,14 @@ void ScTable::ApplyPatternArea( SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol,
     }
 }
 
+bool ScTable::SetAttrEntries(SCCOL nCol, ScAttrEntry* pData, SCSIZE nSize)
+{
+    if (!ValidCol(nCol))
+        return false;
+
+    return aCol[nCol].SetAttrEntries(pData, nSize);
+}
+
 void ScTable::ApplyPatternIfNumberformatIncompatible( const ScRange& rRange,
         const ScPatternAttr& rPattern, short nNewType )
 {
diff --git sc/source/filter/excel/xistyle.cxx sc/source/filter/excel/xistyle.cxx
index fdd537a..6e6ee3e 100644
--- sc/source/filter/excel/xistyle.cxx
+++ sc/source/filter/excel/xistyle.cxx
@@ -58,12 +58,18 @@
 #include "stlsheet.hxx"
 #include "cell.hxx"
 #include "globstr.hrc"
+#include "attarray.hxx"
 #include "xltracer.hxx"
 #include "xistream.hxx"
 #include "xicontent.hxx"
 
 #include "root.hxx"
 #include "colrowst.hxx"
+#include "svl/poolcach.hxx"
+
+#include <list>
+
+using ::std::list;
 
 #include <cppuhelper/implbase1.hxx>
 #include <com/sun/star/container/XIndexAccess.hpp>
@@ -1242,26 +1248,60 @@ const ScPatternAttr& XclImpXF::CreatePattern( bool bSkipPoolDefs )
     return *mpPattern;
 }
 
-void XclImpXF::ApplyPattern(
-        SCCOL nScCol1, SCROW nScRow1, SCCOL nScCol2, SCROW nScRow2,
-        SCTAB nScTab, ULONG nForceScNumFmt )
+void XclImpXF::ApplyPatternToAttrList(
+    list<ScAttrEntry>& rAttrs, SCROW nRow1, SCROW nRow2, sal_uInt32 nForceScNumFmt)
 {
     // force creation of cell style and hard formatting, do it here to have mpStyleSheet
-    const ScPatternAttr& rPattern = CreatePattern();
+    const ScPatternAttr& rOrigPat = CreatePattern();
+    ScPatternAttr aNewPat = rOrigPat;
+    const ScPatternAttr* pPat = NULL;
 
     // insert into document
     ScDocument& rDoc = GetDoc();
-    if( IsCellXF() && mpStyleSheet )
-        rDoc.ApplyStyleAreaTab( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, *mpStyleSheet );
-    if( HasUsedFlags() )
-        rDoc.ApplyPatternAreaTab( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, rPattern );
 
-    // #108770# apply special number format
-    if( nForceScNumFmt != NUMBERFORMAT_ENTRY_NOT_FOUND )
+    if (IsCellXF() && mpStyleSheet)
+    {
+        // Style sheet exists.  Create a copy of the original pattern.
+        aNewPat.SetStyleSheet(mpStyleSheet);
+        pPat = &aNewPat;
+    }
+
+    if (HasUsedFlags())
+    {
+        if (!pPat)
+            pPat = &aNewPat;
+
+        SfxItemPoolCache aCache(rDoc.GetPool(), &rOrigPat.GetItemSet());
+        pPat = static_cast<const ScPatternAttr*>(&aCache.ApplyTo(*pPat, true));
+    }
+
+    if (nForceScNumFmt != NUMBERFORMAT_ENTRY_NOT_FOUND)
     {
-        ScPatternAttr aPattern( GetDoc().GetPool() );
-        GetNumFmtBuffer().FillScFmtToItemSet( aPattern.GetItemSet(), nForceScNumFmt );
-        rDoc.ApplyPatternAreaTab( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, aPattern );
+        if (!pPat)
+            pPat = &aNewPat;
+
+        ScPatternAttr aNumPat(GetDoc().GetPool());
+        GetNumFmtBuffer().FillScFmtToItemSet(aNumPat.GetItemSet(), nForceScNumFmt);
+        SfxItemPoolCache aCache(rDoc.GetPool(), &aNumPat.GetItemSet());
+        pPat = static_cast<const ScPatternAttr*>(&aCache.ApplyTo(*pPat, true));
+    }
+
+
+    if (pPat)
+    {
+        if (!rAttrs.empty() && rAttrs.back().nRow + 1 < nRow1)
+        {
+            // Fill this gap with the default pattern.
+            ScAttrEntry aEntry;
+            aEntry.nRow = nRow1 - 1;
+            aEntry.pPattern = rDoc.GetDefPattern();
+            rAttrs.push_back(aEntry);
+        }
+
+        ScAttrEntry aEntry;
+        aEntry.nRow = nRow2;
+        aEntry.pPattern = static_cast<const ScPatternAttr*>(&rDoc.GetPool()->Put(*pPat));
+        rAttrs.push_back(aEntry);
     }
 }
 
@@ -1507,18 +1547,6 @@ ScStyleSheet* XclImpXFBuffer::CreateStyleSheet( sal_uInt16 nXFIndex )
     return (aIt == maStylesByXf.end()) ? 0 : aIt->second->CreateStyleSheet();
 }
 
-void XclImpXFBuffer::ApplyPattern(
-        SCCOL nScCol1, SCROW nScRow1, SCCOL nScCol2, SCROW nScRow2,
-        SCTAB nScTab, const XclImpXFIndex& rXFIndex )
-{
-    if( XclImpXF* pXF = GetXF( rXFIndex.GetXFIndex() ) )
-    {
-        // #108770# set 'Standard' number format for all Boolean cells
-        ULONG nForceScNumFmt = rXFIndex.IsBoolCell() ? GetNumFmtBuffer().GetStdScNumFmt() : NUMBERFORMAT_ENTRY_NOT_FOUND;
-        pXF->ApplyPattern( nScCol1, nScRow1, nScCol2, nScRow2, nScTab, nForceScNumFmt );
-    }
-}
-
 // Buffer for XF indexes in cells =============================================
 
 IMPL_FIXEDMEMPOOL_NEWDEL( XclImpXFRange, 100, 500 )
@@ -1842,8 +1870,35 @@ void XclImpXFRangeBuffer::Finalize()
         {
             XclImpXFRangeColumn& rColumn = **aVIt;
             SCCOL nScCol = static_cast< SCCOL >( aVIt - aVBeg );
+            list<ScAttrEntry> aAttrs;
             for( XclImpXFRange* pStyle = rColumn.First(); pStyle; pStyle = rColumn.Next() )
-                rXFBuffer.ApplyPattern( nScCol, pStyle->mnScRow1, nScCol, pStyle->mnScRow2, nScTab, pStyle->maXFIndex );
+            {
+                const XclImpXFIndex& rXFIndex = pStyle->maXFIndex;
+                XclImpXF* pXF = rXFBuffer.GetXF( rXFIndex.GetXFIndex() );
+                if (!pXF)
+                    continue;
+
+                sal_uInt32 nForceScNumFmt = rXFIndex.IsBoolCell() ?
+                    GetNumFmtBuffer().GetStdScNumFmt() : NUMBERFORMAT_ENTRY_NOT_FOUND;
+
+                pXF->ApplyPatternToAttrList(aAttrs, pStyle->mnScRow1, pStyle->mnScRow2, nForceScNumFmt);
+            }
+
+            if (aAttrs.empty() || aAttrs.back().nRow != MAXROW)
+            {
+                ScAttrEntry aEntry;
+                aEntry.nRow = MAXROW;
+                aEntry.pPattern = rDoc.GetDefPattern();
+                aAttrs.push_back(aEntry);
+            }
+
+            size_t nAttrSize = aAttrs.size();
+            ScAttrEntry* pData = new ScAttrEntry[nAttrSize];
+            list<ScAttrEntry>::const_iterator itr = aAttrs.begin(), itrEnd = aAttrs.end();
+            for (size_t i = 0; itr != itrEnd; ++itr, ++i)
+                pData[i] = *itr;
+
+            rDoc.SetAttrEntries(nScCol, nScTab, pData, static_cast<SCSIZE>(nAttrSize));
         }
     }
 
diff --git sc/source/filter/inc/xistyle.hxx sc/source/filter/inc/xistyle.hxx
index ba3448f..7e5857d 100644
--- sc/source/filter/inc/xistyle.hxx
+++ sc/source/filter/inc/xistyle.hxx
@@ -37,6 +37,7 @@
 #include "xiroot.hxx"
 
 class ScDocumentPool;
+class ScAttrEntry;
 
 /* ============================================================================
 - Buffers for style records (PALETTE, FONT, FORMAT, XF)
@@ -408,14 +409,9 @@ public:
         @return  A read-only reference to the item set stored internally. */
     const ScPatternAttr& CreatePattern( bool bSkipPoolDefs = false );
 
-    /** Inserts all formatting attributes to the specified area in the Calc document.
-        @param nForcedNumFmt  If not set to NUMBERFORMAT_ENTRY_NOT_FOUND, it will overwrite
-        the number format of the XF. */
-    void                ApplyPattern(
-                            SCCOL nScCol1, SCROW nScRow1,
-                            SCCOL nScCol2, SCROW nScRow2,
-                            SCTAB nScTab,
-                            ULONG nForceScNumFmt = NUMBERFORMAT_ENTRY_NOT_FOUND );
+    void                ApplyPatternToAttrList(
+                            ::std::list<ScAttrEntry>& rAttrs, SCROW nRow1, SCROW nRow2,
+                            sal_uInt32 nForceScNumFmt = NUMBERFORMAT_ENTRY_NOT_FOUND);
 
 private:
     void                ReadXF2( XclImpStream& rStrm );
@@ -511,14 +507,6 @@ public:
         @return  The pointer to the cell style sheet, or 0, if there is no style sheet. */
     ScStyleSheet*       CreateStyleSheet( sal_uInt16 nXFIndex );
 
-    /** Inserts formatting attributes from an XF to the specified area in the Calc document.
-        @param nForcedNumFmt  If not set to NUMBERFORMAT_ENTRY_NOT_FOUND, it will overwrite
-        the number format of the XF. */
-    void                ApplyPattern(
-                            SCCOL nScCol1, SCROW nScRow1,
-                            SCCOL nScCol2, SCROW nScRow2,
-                            SCTAB nScTab, const XclImpXFIndex& rXFIndex );
-
 private:
     typedef ScfDelList< XclImpStyle >               XclImpStyleList;
     typedef ::std::map< sal_uInt16, XclImpStyle* >  XclImpStyleMap;
