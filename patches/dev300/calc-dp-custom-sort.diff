diff --git sc/inc/sc.hrc sc/inc/sc.hrc
index 3ecd9ba..32f883a 100644
--- sc/inc/sc.hrc
+++ sc/inc/sc.hrc
@@ -1682,6 +1682,9 @@
 // Language chooser for text import filters.
 #define RID_SCDLG_LANG_CHOOSER           (SC_OOO_BUILD_START + 12)
 
+// Datapilot controls
+#define RID_SC_DPCONTROL                 (SC_OOO_BUILD_START + 13)
+
 #endif
 
 
diff --git sc/source/ui/cctrl/dpcontrol.cxx sc/source/ui/cctrl/dpcontrol.cxx
index e188ab3..7df90ee 100644
--- sc/source/ui/cctrl/dpcontrol.cxx
+++ sc/source/ui/cctrl/dpcontrol.cxx
@@ -38,6 +38,9 @@
 #include "vcl/outdev.hxx"
 #include "vcl/settings.hxx"
 #include "vcl/wintypes.hxx"
+#include "vcl/decoview.hxx"
+
+#define MENU_NOT_SELECTED 999
 
 using ::rtl::OUString;
 using ::rtl::OUStringHash;
@@ -182,6 +185,507 @@ void ScDPFieldButton::drawPopupButton()
 
 // ============================================================================
 
+ScMenuFloatingWindow::MenuItem::MenuItem() :
+    mbEnabled(true),
+    mpAction(static_cast<ScDPFieldPopupWindow::Action*>(NULL)),
+    mpSubMenuWin(static_cast<ScMenuFloatingWindow*>(NULL))
+{
+}
+
+// ----------------------------------------------------------------------------
+
+ScMenuFloatingWindow::SubMenuItem::SubMenuItem(ScMenuFloatingWindow* pParent) :
+    mpSubMenu(NULL),
+    mnMenuPos(MENU_NOT_SELECTED),
+    mpParent(pParent)
+{
+    maTimer.SetTimeoutHdl( LINK(this, ScMenuFloatingWindow::SubMenuItem, TimeoutHdl) );
+    maTimer.SetTimeout(mpParent->GetSettings().GetMouseSettings().GetMenuDelay());
+}
+
+void ScMenuFloatingWindow::SubMenuItem::reset()
+{
+    mpSubMenu = NULL;
+    mnMenuPos = MENU_NOT_SELECTED;
+    maTimer.Stop();
+}
+
+IMPL_LINK( ScMenuFloatingWindow::SubMenuItem, TimeoutHdl, void*, EMPTYARG )
+{
+    mpParent->handleMenuTimeout(this);
+    return 0;
+}
+
+// ----------------------------------------------------------------------------
+
+ScMenuFloatingWindow::ScMenuFloatingWindow(Window* pParent) :
+    FloatingWindow(pParent, (WB_SYSTEMFLOATWIN|WB_SYSTEMWINDOW|WB_NOBORDER)),
+    maOpenTimer(this),
+    maCloseTimer(this),
+    mnSelectedMenu(MENU_NOT_SELECTED),
+    mnClickedMenu(MENU_NOT_SELECTED),
+    mpParentMenu(dynamic_cast<ScMenuFloatingWindow*>(pParent)),
+    mpActiveSubMenu(NULL),
+    mbActionFired(false)
+{
+    // TODO: How do we get the right font to use here ?
+    const sal_uInt16 nPopupFontHeight = 12;
+    const StyleSettings& rStyle = GetSettings().GetStyleSettings();
+    maLabelFont = rStyle.GetLabelFont();
+    maLabelFont.SetHeight(nPopupFontHeight);
+    SetFont(maLabelFont);
+
+    SetPopupModeEndHdl( LINK(this, ScMenuFloatingWindow, EndPopupHdl) );
+}
+
+ScMenuFloatingWindow::~ScMenuFloatingWindow()
+{
+    EndPopupMode();
+}
+
+void ScMenuFloatingWindow::MouseMove(const MouseEvent& rMEvt)
+{
+    const Point& rPos = rMEvt.GetPosPixel();
+    size_t nSelectedMenu = getEnclosingMenuItem(rPos);
+    setSelectedMenuItem(nSelectedMenu);
+
+    Window::MouseMove(rMEvt);
+}
+
+void ScMenuFloatingWindow::MouseButtonDown(const MouseEvent& rMEvt)
+{
+    const Point& rPos = rMEvt.GetPosPixel();
+    mnClickedMenu = getEnclosingMenuItem(rPos);
+    Window::MouseButtonDown(rMEvt);
+}
+
+void ScMenuFloatingWindow::MouseButtonUp(const MouseEvent& rMEvt)
+{
+    executeMenu(mnClickedMenu);
+    mnClickedMenu = MENU_NOT_SELECTED;
+    Window::MouseButtonUp(rMEvt);
+}
+
+void ScMenuFloatingWindow::KeyInput(const KeyEvent& rKEvt)
+{
+    const KeyCode& rKeyCode = rKEvt.GetKeyCode();
+    bool bHandled = true;
+    size_t nSelectedMenu = mnSelectedMenu;
+    size_t nLastMenuPos = maMenuItems.size() - 1;
+    switch (rKeyCode.GetCode())
+    {
+        case KEY_UP:
+            if (nSelectedMenu == MENU_NOT_SELECTED || nSelectedMenu == 0)
+                nSelectedMenu = nLastMenuPos;
+            else
+                --nSelectedMenu;
+            setSelectedMenuItem(nSelectedMenu, false);
+        break;
+        case KEY_DOWN:
+            if (nSelectedMenu == MENU_NOT_SELECTED || nSelectedMenu == nLastMenuPos)
+                nSelectedMenu = 0;
+            else
+                ++nSelectedMenu;
+            setSelectedMenuItem(nSelectedMenu, false);
+        break;
+        case KEY_LEFT:
+            if (mpParentMenu)
+                mpParentMenu->endSubMenu();
+        break;
+        case KEY_RIGHT:
+        {
+            if (mnSelectedMenu >= maMenuItems.size() || mnSelectedMenu == MENU_NOT_SELECTED)
+                break;
+
+            const MenuItem& rMenu = maMenuItems[mnSelectedMenu];
+            if (!rMenu.mbEnabled || !rMenu.mpSubMenuWin)
+                break;
+
+            maOpenTimer.mnMenuPos = mnSelectedMenu;
+            maOpenTimer.mpSubMenu = rMenu.mpSubMenuWin.get();
+            launchSubMenu(true);
+        }
+        break;
+        case KEY_RETURN:
+            if (nSelectedMenu != MENU_NOT_SELECTED)
+                executeMenu(nSelectedMenu);
+        break;
+        default:
+            bHandled = false;
+    }
+
+    if (!bHandled)
+        Window::KeyInput(rKEvt);
+}
+
+void ScMenuFloatingWindow::addMenuItem(const OUString& rText, bool bEnabled, Action* pAction)
+{
+    MenuItem aItem;
+    aItem.maText = rText;
+    aItem.mbEnabled = bEnabled;
+    aItem.mpAction.reset(pAction);
+    maMenuItems.push_back(aItem);
+}
+
+ScMenuFloatingWindow* ScMenuFloatingWindow::addSubMenuItem(const OUString& rText, bool bEnabled)
+{
+    MenuItem aItem;
+    aItem.maText = rText;
+    aItem.mbEnabled = bEnabled;
+    aItem.mpSubMenuWin.reset(new ScFieldSubMenuWindow(this));
+    maMenuItems.push_back(aItem);
+    return aItem.mpSubMenuWin.get();
+}
+
+void ScMenuFloatingWindow::drawMenuItem(size_t nPos)
+{
+    if (nPos >= maMenuItems.size())
+        return;
+
+    Point aPos;
+    Size aSize;
+    getMenuItemPosSize(aPos, aSize, nPos);
+
+    DecorationView aDecoView(this);
+    long nXOffset = 5;
+    long nYOffset = (aSize.Height() - maLabelFont.GetHeight())/2;
+    DrawCtrlText(Point(aPos.X()+nXOffset, aPos.Y() + nYOffset), maMenuItems[nPos].maText, 0, STRING_LEN,
+                 maMenuItems[nPos].mbEnabled ? TEXT_DRAW_MNEMONIC : TEXT_DRAW_DISABLE);
+
+    if (maMenuItems[nPos].mpSubMenuWin)
+    {
+        long nFontHeight = maLabelFont.GetHeight();
+        Point aMarkerPos = aPos;
+        aMarkerPos.Y() += aSize.Height()/2 - nFontHeight/4 + 1;
+        aMarkerPos.X() += aSize.Width() - nFontHeight + nFontHeight/4;
+        Size aMarkerSize(nFontHeight/2, nFontHeight/2);
+        aDecoView.DrawSymbol(Rectangle(aMarkerPos, aMarkerSize),
+                             SYMBOL_SPIN_RIGHT, GetTextColor(), 0);
+    }
+}
+
+void ScMenuFloatingWindow::drawAllMenuItems()
+{
+    size_t n = maMenuItems.size();
+    for (size_t i = 0; i < n; ++i)
+        highlightMenuItem(i, i == mnSelectedMenu);    
+}
+
+const Font& ScMenuFloatingWindow::getLabelFont() const
+{
+    return maLabelFont;
+}
+
+void ScMenuFloatingWindow::executeMenu(size_t nPos)
+{
+    if (nPos >= maMenuItems.size())
+        return;
+
+    if (!maMenuItems[nPos].mpAction)
+        // no action is defined.
+        return;
+
+    maMenuItems[nPos].mpAction->execute();
+    mbActionFired = true;
+    EndPopupMode();
+}
+
+void ScMenuFloatingWindow::setSelectedMenuItem(size_t nPos, bool bSubMenuTimer)
+{
+    if (mnSelectedMenu != nPos)
+    {
+        selectMenuItem(mnSelectedMenu, false, bSubMenuTimer);
+        selectMenuItem(nPos, true, bSubMenuTimer);
+        mnSelectedMenu = nPos;
+    }
+}
+
+size_t ScMenuFloatingWindow::getSelectedMenuItem() const
+{
+    return mnSelectedMenu;
+}
+
+void ScMenuFloatingWindow::handleMenuTimeout(SubMenuItem* pTimer)
+{
+    if (pTimer == &maOpenTimer)
+    {
+        // Close any open submenu immediately.
+        if (maCloseTimer.mpSubMenu)
+        {
+            maCloseTimer.mpSubMenu->EndPopupMode();
+            maCloseTimer.mpSubMenu = NULL;
+            maCloseTimer.maTimer.Stop();
+        }
+
+        launchSubMenu(false);
+    }
+    else if (pTimer == &maCloseTimer)
+    {
+        // end submenu.
+        if (maCloseTimer.mpSubMenu)
+        {
+            maOpenTimer.mpSubMenu = NULL;
+
+            maCloseTimer.mpSubMenu->EndPopupMode();
+            maCloseTimer.mpSubMenu = NULL;
+
+            highlightMenuItem(maOpenTimer.mnMenuPos, false);
+            maOpenTimer.mnMenuPos = MENU_NOT_SELECTED;
+        }
+    }
+}
+
+void ScMenuFloatingWindow::queueLaunchSubMenu(size_t nPos, ScMenuFloatingWindow* pMenu)
+{
+    if (!pMenu)
+        return;
+
+    // Set the submenu on launch queue.
+    if (maOpenTimer.mpSubMenu)
+    {
+        if (maOpenTimer.mpSubMenu == pMenu)
+        {
+            if (pMenu == maCloseTimer.mpSubMenu)
+                maCloseTimer.reset();
+            return;
+        }
+
+        // new submenu is being requested.
+        queueCloseSubMenu();
+    }
+
+    maOpenTimer.mpSubMenu = pMenu;
+    maOpenTimer.mnMenuPos = nPos;
+    maOpenTimer.maTimer.Start();
+}
+
+void ScMenuFloatingWindow::queueCloseSubMenu()
+{
+    if (!maOpenTimer.mpSubMenu)
+        return;
+
+    maCloseTimer.mpSubMenu = maOpenTimer.mpSubMenu;
+    maCloseTimer.mnMenuPos = maOpenTimer.mnMenuPos;
+    maCloseTimer.maTimer.Start();
+}
+
+void ScMenuFloatingWindow::launchSubMenu(bool bSetMenuPos)
+{
+    Point aPos;
+    Size aSize;
+    getMenuItemPosSize(aPos, aSize, maOpenTimer.mnMenuPos);
+    ScMenuFloatingWindow* pSubMenu = maOpenTimer.mpSubMenu;
+
+    if (!pSubMenu)
+        return;
+
+    sal_uInt32 nOldFlags = GetPopupModeFlags();
+    SetPopupModeFlags(nOldFlags | FLOATWIN_POPUPMODE_NOAPPFOCUSCLOSE);
+    pSubMenu->resetMenu(bSetMenuPos);
+    pSubMenu->StartPopupMode(
+        Rectangle(aPos,aSize), (FLOATWIN_POPUPMODE_RIGHT | FLOATWIN_POPUPMODE_GRABFOCUS));
+    pSubMenu->AddPopupModeWindow(this);
+    SetPopupModeFlags(nOldFlags);
+}
+
+void ScMenuFloatingWindow::endSubMenu()
+{
+    if (maOpenTimer.mpSubMenu)
+    {
+        maOpenTimer.mpSubMenu->EndPopupMode();
+        maOpenTimer.mpSubMenu = NULL;
+        highlightMenuItem(maOpenTimer.mnMenuPos, true);
+    }
+}
+
+void ScMenuFloatingWindow::notify(NotificationType eType)
+{
+    switch (eType)
+    {
+        case SUBMENU_FOCUSED:
+            // Cancel any request for ending submenu.
+            maCloseTimer.reset();
+            if (mnSelectedMenu != maOpenTimer.mnMenuPos)
+            {
+                highlightMenuItem(maOpenTimer.mnMenuPos, true);
+                mnSelectedMenu = maOpenTimer.mnMenuPos;
+            }
+        break;
+        default:
+            ;
+    }
+}
+
+void ScMenuFloatingWindow::resetMenu(bool bSetMenuPos)
+{
+    mnSelectedMenu = bSetMenuPos ? 0 : MENU_NOT_SELECTED;
+    resizeToFitMenuItems();
+}
+
+void ScMenuFloatingWindow::resizeToFitMenuItems()
+{
+    if (maMenuItems.empty())
+        return;
+
+    vector<MenuItem>::const_iterator itr = maMenuItems.begin(), itrEnd = maMenuItems.end();
+    long nTextWidth = 0;
+    for (; itr != itrEnd; ++itr)
+        nTextWidth = ::std::max(GetTextWidth(itr->maText), nTextWidth);
+
+    size_t nLastPos = maMenuItems.size()-1;
+    Point aPos;
+    Size aSize;
+    getMenuItemPosSize(aPos, aSize, nLastPos);
+    aPos.X() += nTextWidth + 15;
+    aPos.Y() += aSize.Height() + 5;
+    SetOutputSizePixel(Size(aPos.X(), aPos.Y()));
+}
+
+void ScMenuFloatingWindow::selectMenuItem(size_t nPos, bool bSelected, bool bSubMenuTimer)
+{
+    if (nPos >= maMenuItems.size() || nPos == MENU_NOT_SELECTED)
+    {
+        queueCloseSubMenu();
+        return;
+    }
+
+    if (!maMenuItems[nPos].mbEnabled)
+    {    
+        queueCloseSubMenu();
+        return;
+    }
+
+    highlightMenuItem(nPos, bSelected);
+
+    if (bSelected)
+    {
+        if (mpParentMenu)
+            mpParentMenu->notify(SUBMENU_FOCUSED);
+
+        if (bSubMenuTimer)
+        {
+            if (maMenuItems[nPos].mpSubMenuWin)
+            {
+                ScMenuFloatingWindow* pSubMenu = maMenuItems[nPos].mpSubMenuWin.get();
+                queueLaunchSubMenu(nPos, pSubMenu);
+            }
+            else
+                queueCloseSubMenu();
+        }
+    }
+}
+
+void ScMenuFloatingWindow::highlightMenuItem(size_t nPos, bool bSelected)
+{
+    const StyleSettings& rStyle = GetSettings().GetStyleSettings();
+    Color aBackColor = rStyle.GetMenuColor();
+    SetFillColor(aBackColor);
+    SetLineColor(aBackColor);
+
+    Point aPos;
+    Size aSize;
+    getMenuItemPosSize(aPos, aSize, nPos);
+    Region aRegion(Rectangle(aPos,aSize));
+    bool bNativeDrawn = true;
+    if (IsNativeControlSupported(CTRL_MENU_POPUP, PART_MENU_ITEM))
+    {
+        DrawRect(Rectangle(aPos,aSize));
+        ControlState nState = bSelected ? CTRL_STATE_SELECTED : 0;
+        if (maMenuItems[nPos].mbEnabled)
+            nState |= CTRL_STATE_ENABLED;
+        bNativeDrawn = DrawNativeControl(
+            CTRL_MENU_POPUP, PART_MENU_ITEM, aRegion, nState, ImplControlValue(), OUString());
+    }
+    else
+        bNativeDrawn = false;
+
+    if (!bNativeDrawn)
+    {
+        if (bSelected)
+        {
+            aBackColor = rStyle.GetMenuHighlightColor();
+            SetFillColor(aBackColor);
+            SetLineColor(aBackColor);
+        }
+        DrawRect(Rectangle(aPos,aSize));
+    }
+
+    Color aTextColor = bSelected ? rStyle.GetMenuHighlightTextColor() : rStyle.GetMenuTextColor();
+    SetTextColor(aTextColor);
+    drawMenuItem(nPos);
+}
+
+void ScMenuFloatingWindow::getMenuItemPosSize(Point& rPos, Size& rSize, size_t nPos) const
+{
+    const sal_uInt16 nLeftMargin = 5;
+    const sal_uInt16 nTopMargin = 5;
+    const sal_uInt16 nMenuItemHeight = maLabelFont.GetHeight()*1.8;
+
+    Size aWndSize = GetSizePixel();
+
+    Point aPos1(nLeftMargin, nTopMargin);
+    Size aSize1(aWndSize.Width() - nLeftMargin*2, nMenuItemHeight);
+
+    rPos = aPos1;
+    rPos.Y() += aSize1.Height()*nPos;
+    rSize = aSize1;
+}
+
+size_t ScMenuFloatingWindow::getEnclosingMenuItem(const Point& rPos) const
+{
+    size_t n = maMenuItems.size();
+    for (size_t i = 0; i < n; ++i)
+    {
+        Point aPos;
+        Size aSize;
+        getMenuItemPosSize(aPos, aSize, i);
+        Rectangle aRect(aPos, aSize);
+        if (aRect.IsInside(rPos))
+            return i;
+    }
+    return MENU_NOT_SELECTED;
+}
+
+IMPL_LINK( ScMenuFloatingWindow, EndPopupHdl, void*, EMPTYARG )
+{
+    if (mbActionFired && mpParentMenu)
+        mpParentMenu->EndPopupMode();
+
+    return 0;
+}
+
+// ============================================================================
+
+ScFieldSubMenuWindow::ScFieldSubMenuWindow(Window* pParent) :
+    ScMenuFloatingWindow(pParent)
+{
+    SetOutputSizePixel(Size(160, 200));
+}
+
+ScFieldSubMenuWindow::~ScFieldSubMenuWindow()
+{
+}
+
+void ScFieldSubMenuWindow::Paint(const Rectangle& /*rRect*/)
+{
+    const StyleSettings& rStyle = GetSettings().GetStyleSettings();
+    Color aBackColor = rStyle.GetMenuColor();
+    Color aBorderColor = rStyle.GetShadowColor();
+
+    Size aSize = GetSizePixel();
+
+    // Window background
+    SetFillColor(aBackColor);
+    SetLineColor(aBorderColor);
+    DrawRect(Rectangle(Point(0,0), aSize));
+
+    // Menu items
+    SetTextColor(rStyle.GetMenuTextColor());
+    drawAllMenuItems();
+}
+
+// ============================================================================
+
 ScDPFieldPopupWindow::Member::Member() :
     mbVisible(true)
 {
@@ -190,7 +694,7 @@ ScDPFieldPopupWindow::Member::Member() :
 // ----------------------------------------------------------------------------
 
 ScDPFieldPopupWindow::ScDPFieldPopupWindow(Window* pParent) :
-    FloatingWindow(pParent, (WB_SYSTEMFLOATWIN|WB_SYSTEMWINDOW|WB_NOBORDER)),
+    ScMenuFloatingWindow(pParent),
     maCheck0(this, 0),
     maCheck1(this, 0),
     maCheck2(this, 0),
@@ -201,8 +705,6 @@ ScDPFieldPopupWindow::ScDPFieldPopupWindow(Window* pParent) :
     maCheck7(this, 0),
     maCheck8(this, 0),
     maCheck9(this, 0),
-    maCheck10(this, 0),
-    maCheck11(this, 0),
     maScrollBar(this, WB_VERT),
     maBtnOk(this),
     maBtnCancel(this),
@@ -210,12 +712,13 @@ ScDPFieldPopupWindow::ScDPFieldPopupWindow(Window* pParent) :
     mpOKAction(NULL),
     mnScrollPos(0)
 {
-    SetOutputSizePixel(Size(150, 280));
+    Point aPos;
+    Size aSize;
+    getSectionPosSize(aPos, aSize, WHOLE);
+    SetOutputSizePixel(aSize);
     Size aOutSize = GetOutputSizePixel();
 
-    const StyleSettings& rStyle = GetSettings().GetStyleSettings();
-
-    mpCheckPtr.reserve(12);
+    mpCheckPtr.reserve(10);
     mpCheckPtr.push_back(&maCheck0);
     mpCheckPtr.push_back(&maCheck1);
     mpCheckPtr.push_back(&maCheck2);
@@ -226,33 +729,27 @@ ScDPFieldPopupWindow::ScDPFieldPopupWindow(Window* pParent) :
     mpCheckPtr.push_back(&maCheck7);
     mpCheckPtr.push_back(&maCheck8);
     mpCheckPtr.push_back(&maCheck9);
-    mpCheckPtr.push_back(&maCheck10);
-    mpCheckPtr.push_back(&maCheck11);
     
-    Point aPos;
-    Size aSize;
     getSectionPosSize(aPos, aSize, FIRST_LISTITEM);    
-    Font aMemFont(rStyle.GetLabelFont());
-    aMemFont.SetHeight(11);
     for (vector<CheckBox*>::iterator itr = mpCheckPtr.begin(), itrEnd = mpCheckPtr.end();
           itr != itrEnd; ++itr)
     {
         CheckBox* p = *itr;
         p->SetPosSizePixel(aPos, aSize);
-        p->SetFont(aMemFont);
+        p->SetFont(getLabelFont());
         p->SetClickHdl( LINK(this, ScDPFieldPopupWindow, CheckBoxHdl) );
-        aPos.Y() += 18;
+        aPos.Y() += aSize.Height() + 1;
     }
 
     getSectionPosSize(aPos, aSize, BTN_OK);
     maBtnOk.SetPosSizePixel(aPos, aSize);
-    maBtnOk.SetFont(aMemFont);
+    maBtnOk.SetFont(getLabelFont());
     maBtnOk.SetClickHdl( LINK(this, ScDPFieldPopupWindow, OKButtonHdl) );
     maBtnOk.Show();
 
     getSectionPosSize(aPos, aSize, BTN_CANCEL);
     maBtnCancel.SetPosSizePixel(aPos, aSize);
-    maBtnCancel.SetFont(aMemFont);
+    maBtnCancel.SetFont(getLabelFont());
     maBtnCancel.Show();
 
     getSectionPosSize(aPos, aSize, SCROLL_BAR_V);
@@ -264,6 +761,10 @@ ScDPFieldPopupWindow::ScDPFieldPopupWindow(Window* pParent) :
     maScrollBar.EnableDrag(true);
 }
 
+ScDPFieldPopupWindow::~ScDPFieldPopupWindow()
+{
+}
+
 vector<ScDPFieldPopupWindow::Member>& ScDPFieldPopupWindow::getMembers()
 {
     return maMembers;
@@ -271,61 +772,67 @@ vector<ScDPFieldPopupWindow::Member>& ScDPFieldPopupWindow::getMembers()
 
 void ScDPFieldPopupWindow::getSectionPosSize(Point& rPos, Size& rSize, SectionType eType) const
 {
-    static const long nListBoxMargin = 5;
-    static const long nBottomBtnAreaHeight = 50;
-    static const long nInnerItemMargin = 5;
-    static const long nScrollBarWidth = 17;
-    static const long nBtnWidth = 60;
-    static const long nBtnHeight = 22;
-    static const long nBottomMargin = 10;
-
-    const Size& rWndSize = GetSizePixel();
+    const sal_uInt16 nListBoxMargin = 5;
+    const sal_uInt16 nTopMargin = 5;
+    const sal_uInt16 nMenuHeight = 60;
+    const sal_uInt16 nMenuItemCount = 3;
+    const sal_uInt16 nBottomBtnAreaHeight = 50;
+    const sal_uInt16 nInnerItemMargin = 5;
+    const sal_uInt16 nScrollBarWidth = 17;
+    const sal_uInt16 nBtnWidth = 60;
+    const sal_uInt16 nBtnHeight = getLabelFont().GetHeight()*2;
+    const sal_uInt16 nBottomMargin = 10;
+    const sal_uInt16 nMenuListMargin = 20;
+
+    Size aWndSize = Size(160, 330);
 
     switch (eType)
     {
         case WHOLE:
+        {
             rPos  = Point(0, 0);
-            rSize = rWndSize;
+            rSize = aWndSize;
+        }
         break;
         case LISTBOX_AREA:
         {
-            rPos = Point(nListBoxMargin, nListBoxMargin);
+            rPos = Point(nListBoxMargin, nTopMargin + nMenuHeight + nMenuListMargin);
             rSize = Size(
-                rWndSize.Width() -  nListBoxMargin*2, 
-                rWndSize.Height() - nListBoxMargin - nBottomBtnAreaHeight);
+                aWndSize.Width() - nListBoxMargin*2, 
+                aWndSize.Height() - nTopMargin - nMenuHeight - nMenuListMargin - nBottomBtnAreaHeight);
         }
         break;
         case FIRST_LISTITEM:
         {
             rPos = Point(nListBoxMargin + nInnerItemMargin,
-                         nListBoxMargin + nInnerItemMargin);
+                         nTopMargin + nMenuHeight + nMenuListMargin + nInnerItemMargin);
             rSize = Size(
-                rWndSize.Width() - nListBoxMargin*2 - nInnerItemMargin - nScrollBarWidth - 10,
+                aWndSize.Width() - nListBoxMargin*2 - nInnerItemMargin - nScrollBarWidth - 10,
                 17);
         }
         break;
         case BTN_OK:
         {
-            long x = (rWndSize.Width() - nBtnWidth*2)/3;
-            long y = rWndSize.Height() - nBottomMargin - nBtnHeight;
+            long x = (aWndSize.Width() - nBtnWidth*2)/3;
+            long y = aWndSize.Height() - nBottomMargin - nBtnHeight;
             rPos = Point(x, y);
             rSize = Size(nBtnWidth, nBtnHeight);
         }
         break;
         case BTN_CANCEL:
         {
-            long x = (rWndSize.Width() - nBtnWidth*2)/3*2 + nBtnWidth;
-            long y = rWndSize.Height() - nBottomMargin - nBtnHeight;
+            long x = (aWndSize.Width() - nBtnWidth*2)/3*2 + nBtnWidth;
+            long y = aWndSize.Height() - nBottomMargin - nBtnHeight;
             rPos = Point(x, y);
             rSize = Size(nBtnWidth, nBtnHeight);
         }
         break;
         case SCROLL_BAR_V:
         {
-            long x = rWndSize.Width() - nListBoxMargin - nInnerItemMargin - nScrollBarWidth;
-            long y = nListBoxMargin + nInnerItemMargin;
+            long x = aWndSize.Width() - nListBoxMargin - nInnerItemMargin - nScrollBarWidth;
+            long y = nTopMargin + nMenuHeight + nMenuListMargin + nInnerItemMargin;
             rPos = Point(x, y);
-            long h = rWndSize.Height() - nListBoxMargin - nBottomBtnAreaHeight - nInnerItemMargin*2;
+            long h = aWndSize.Height() - nTopMargin - nMenuHeight - nMenuListMargin - nBottomBtnAreaHeight - nInnerItemMargin*2;
             rSize = Size(nScrollBarWidth, h);
         }
         break;
@@ -377,9 +884,13 @@ IMPL_LINK( ScDPFieldPopupWindow, ScrollHdl, ScrollBar*, EMPTYARG )
     return 0;
 }
 
-ScDPFieldPopupWindow::~ScDPFieldPopupWindow()
+void ScDPFieldPopupWindow::MouseMove(const MouseEvent& rMEvt)
 {
-    EndPopupMode();
+    ScMenuFloatingWindow::MouseMove(rMEvt);
+
+    size_t nSelectedMenu = getSelectedMenuItem();
+    if (nSelectedMenu == MENU_NOT_SELECTED)
+        queueCloseSubMenu();
 }
 
 void ScDPFieldPopupWindow::Paint(const Rectangle& rRect)
@@ -404,6 +915,9 @@ void ScDPFieldPopupWindow::Paint(const Rectangle& rRect)
     SetFillColor(aMemberBackColor);
     getSectionPosSize(aPos, aSize, LISTBOX_AREA);
     DrawRect(Rectangle(aPos,aSize));
+
+    // Menu items
+    drawAllMenuItems();
 }
 
 void ScDPFieldPopupWindow::setMemberSize(size_t n)
@@ -472,7 +986,7 @@ ScDPFieldPopupWindow::ExtendedData* ScDPFieldPopupWindow::getExtendedData()
     return mpExtendedData.get();
 }
 
-void ScDPFieldPopupWindow::setOKAction(OKAction* p)
+void ScDPFieldPopupWindow::setOKAction(Action* p)
 {
     mpOKAction.reset(p);
 }
diff --git sc/source/ui/cctrl/dpcontrol.src sc/source/ui/cctrl/dpcontrol.src
new file mode 100644
index 0000000..6c5fffe
--- /dev/null
+++ sc/source/ui/cctrl/dpcontrol.src
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: globstr.src,v $
+ * $Revision: 1.74.96.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "dpcontrol.hrc"
+
+Resource RID_SC_DPCONTROL
+{
+    String STR_MENU_SORT_ASC
+    {
+        Text [ en-US ] = "Sort Ascending" ;
+    };
+
+    String STR_MENU_SORT_DESC
+    {
+        Text [ en-US ] = "Sort Descending" ;
+    };
+
+    String STR_MENU_SORT_CUSTOM
+    {
+        Text [ en-US ] = "Custom Sort" ;
+    };
+};
diff --git sc/source/ui/cctrl/makefile.mk sc/source/ui/cctrl/makefile.mk
index 8e8add3..70095d8 100644
--- sc/source/ui/cctrl/makefile.mk
+++ sc/source/ui/cctrl/makefile.mk
@@ -45,7 +45,8 @@ LIBTARGET=NO
 # --- Files --------------------------------------------------------
 
 EXCEPTIONSFILES= \
-    $(SLO)$/tbzoomsliderctrl.obj
+    $(SLO)$/tbzoomsliderctrl.obj \
+    $(SLO)$/dpcontrol.obj
 
 SLOFILES =	\
 		$(SLO)$/popmenu.obj		\
@@ -55,6 +56,10 @@ SLOFILES =	\
 		$(SLO)$/editfield.obj	\
 		$(EXCEPTIONSFILES)
 
+SRS1NAME=$(TARGET)
+SRC1FILES = \
+	dpcontrol.src
+
 LIB1TARGET=$(SLB)$/$(TARGET).lib
 LIB1OBJFILES= \
 		$(SLO)$/popmenu.obj		\
@@ -63,6 +68,7 @@ LIB1OBJFILES= \
 		$(SLO)$/dpcontrol.obj	\
 		$(SLO)$/tbzoomsliderctrl.obj
 
+
 # --- Tagets -------------------------------------------------------
 
 .INCLUDE :  target.mk
diff --git sc/source/ui/inc/dbfunc.hxx sc/source/ui/inc/dbfunc.hxx
index d894e48..b494ae6 100644
--- sc/source/ui/inc/dbfunc.hxx
+++ sc/source/ui/inc/dbfunc.hxx
@@ -101,6 +101,7 @@ public:
     void            UngroupDataPilot();
     void            DataPilotInput( const ScAddress& rPos, const String& rString );
 
+    bool            DataPilotSort( const ScAddress& rPos, bool bAscending, sal_uInt16* pUserListId = NULL );
     BOOL            DataPilotMove( const ScRange& rSource, const ScAddress& rDest );
 
     BOOL            HasSelectionForDrillDown( USHORT& rOrientation );
diff --git sc/source/ui/inc/dpcontrol.hrc sc/source/ui/inc/dpcontrol.hrc
new file mode 100644
index 0000000..2ca698d
--- /dev/null
+++ sc/source/ui/inc/dpcontrol.hrc
@@ -0,0 +1,40 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: protectiondlg.hrc,v $
+ * $Revision: 1.1.2.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __DPCONTROL_HRC__
+#define __DPCONTROL_HRC__
+
+#include <sc.hrc>
+
+#define STR_MENU_SORT_ASC       1
+#define STR_MENU_SORT_DESC      2
+#define STR_MENU_SORT_CUSTOM    3
+
+#endif
diff --git sc/source/ui/inc/dpcontrol.hxx sc/source/ui/inc/dpcontrol.hxx
index 6a28354..91a815e 100644
--- sc/source/ui/inc/dpcontrol.hxx
+++ sc/source/ui/inc/dpcontrol.hxx
@@ -36,7 +36,9 @@
 #include "vcl/floatwin.hxx"
 #include "vcl/button.hxx"
 #include "vcl/scrbar.hxx"
+#include "vcl/timer.hxx"
 
+#include <boost/shared_ptr.hpp>
 #include <memory>
 #include <hash_map>
 
@@ -80,43 +82,138 @@ private:
 
 // ============================================================================
 
-/** 
- * This class implements a popup window for field button, for quick access 
- * of hide-item list, and possibly more stuff related to field options. 
- */
-class ScDPFieldPopupWindow : public FloatingWindow
+class ScMenuFloatingWindow : public FloatingWindow
 {
 public:
-    class ButtonEvent
+    /** 
+     * Action to perform when an event takes place.  Create a sub-class of 
+     * this to implement the desired action. 
+     */
+    class Action
     {
     public:
         virtual void execute() = 0;
     };
 
+    explicit ScMenuFloatingWindow(Window* pParent);
+    virtual ~ScMenuFloatingWindow();
+
+    virtual void MouseMove(const MouseEvent& rMEvt);
+    virtual void MouseButtonDown(const MouseEvent& rMEvt);
+    virtual void MouseButtonUp(const MouseEvent& rMEvt);
+    virtual void KeyInput(const KeyEvent& rKEvt);
+
+    void addMenuItem(const ::rtl::OUString& rText, bool bEnabled, Action* pAction);
+    ScMenuFloatingWindow* addSubMenuItem(const ::rtl::OUString& rText, bool bEnabled);
+
+protected:
+    void drawMenuItem(size_t nPos);
+    void drawAllMenuItems();
+    const Font& getLabelFont() const;
+
+    void executeMenu(size_t nPos);
+    void setSelectedMenuItem(size_t nPos, bool bSubMenuTimer = true);
+    size_t getSelectedMenuItem() const;
+    void queueLaunchSubMenu(size_t nPos, ScMenuFloatingWindow* pMenu);
+    void queueCloseSubMenu();
+    void launchSubMenu(bool bSetMenuPos);
+    void endSubMenu();
+
+private:
+    struct SubMenuItem;
+    void handleMenuTimeout(SubMenuItem* pTimer);
+
+    enum NotificationType { SUBMENU_FOCUSED };
+    void notify(NotificationType eType);
+
+    void resetMenu(bool bSetMenuPos);
+    void resizeToFitMenuItems();
+    void selectMenuItem(size_t nPos, bool bSelected, bool bSubMenuTimer);
+    void highlightMenuItem(size_t nPos, bool bSelected);
+
+    void getMenuItemPosSize(Point& rPos, Size& rSize, size_t nPos) const;
+    size_t getEnclosingMenuItem(const Point& rPos) const;
+
+    DECL_LINK( EndPopupHdl, void* );
+
+private:
+    struct MenuItem
+    {
+        ::rtl::OUString maText;
+        bool            mbEnabled;
+
+        ::boost::shared_ptr<Action> mpAction;
+        ::boost::shared_ptr<ScMenuFloatingWindow> mpSubMenuWin;
+
+        MenuItem();
+    };
+
+    ::std::vector<MenuItem>         maMenuItems;
+
+    struct SubMenuItem
+    {
+        Timer                   maTimer;
+        ScMenuFloatingWindow*   mpSubMenu;
+        size_t                  mnMenuPos;
+
+        DECL_LINK( TimeoutHdl, void* );
+
+        SubMenuItem(ScMenuFloatingWindow* pParent);
+        void reset();
+
+    private:
+        ScMenuFloatingWindow* mpParent;
+    };
+    SubMenuItem   maOpenTimer;
+    SubMenuItem   maCloseTimer;
+
+    Font    maLabelFont;
+
+    size_t  mnSelectedMenu;
+    size_t  mnClickedMenu;
+
+    ScMenuFloatingWindow* mpParentMenu;
+    ScMenuFloatingWindow* mpActiveSubMenu;
+
+    bool    mbActionFired;
+};
+
+// ============================================================================
+
+class ScFieldSubMenuWindow : public ScMenuFloatingWindow
+{
+public:
+    explicit ScFieldSubMenuWindow(Window* pParent);
+    virtual ~ScFieldSubMenuWindow();
+
+    virtual void Paint(const Rectangle& rRect);
+};
+
+// ============================================================================
+
+/** 
+ * This class implements a popup window for field button, for quick access 
+ * of hide-item list, and possibly more stuff related to field options. 
+ */
+class ScDPFieldPopupWindow : public ScMenuFloatingWindow
+{
+public:
     /** 
      * Extended data that the client code may need to store.  Create a 
      * sub-class of this and store data there. 
      */ 
     struct ExtendedData {};
 
-    /** 
-     * Action to perform when the OK button is pressed.  Create a sub-class of 
-     * this to implement the desired action.
-     */
-    class OKAction
-    {
-    public:
-        virtual void execute() = 0;
-    };
-
     explicit ScDPFieldPopupWindow(Window* pParent);
     virtual ~ScDPFieldPopupWindow();
 
+    virtual void MouseMove(const MouseEvent& rMEvt);
     virtual void Paint(const Rectangle& rRect);
 
     void setMemberSize(size_t n);
     void addMember(const ::rtl::OUString& rName, bool bVisible);
     void initMembers();
+
     void getResult(::std::hash_map< ::rtl::OUString, bool, ::rtl::OUStringHash>& rResult);
     void close(bool bOK);
 
@@ -132,7 +229,7 @@ public:
      */
     ExtendedData* getExtendedData();
 
-    void setOKAction(OKAction* p);
+    void setOKAction(Action* p);
 
 private:
     struct Member
@@ -173,8 +270,6 @@ private:
     CheckBox maCheck7;
     CheckBox maCheck8;
     CheckBox maCheck9;
-    CheckBox maCheck10;
-    CheckBox maCheck11;
 
     ScrollBar   maScrollBar;
 
@@ -185,9 +280,9 @@ private:
 
     ::std::vector<Member>           maMembers;
     ::std::auto_ptr<ExtendedData>   mpExtendedData;
-    ::std::auto_ptr<OKAction>       mpOKAction;
+    ::std::auto_ptr<Action>         mpOKAction;
 
-    size_t mnScrollPos;
+    size_t  mnScrollPos;
 };
 
 #endif
diff --git sc/source/ui/view/dbfunc3.cxx sc/source/ui/view/dbfunc3.cxx
index d83add1..f58d9b5 100644
--- sc/source/ui/view/dbfunc3.cxx
+++ sc/source/ui/view/dbfunc3.cxx
@@ -81,9 +81,13 @@
 #include "patattr.hxx"
 #include "unonames.hxx"
 #include "cell.hxx"
+#include "userlist.hxx"
 
 #include <hash_set>
+#include <hash_map>
 #include <memory>
+#include <list>
+#include <vector>
 
 using namespace com::sun::star;
 using ::com::sun::star::uno::Any;
@@ -94,8 +98,13 @@ using ::com::sun::star::beans::XPropertySet;
 using ::com::sun::star::container::XNameAccess;
 using ::com::sun::star::sheet::XDimensionsSupplier;
 using ::rtl::OUString;
+using ::rtl::OUStringHash;
 using ::rtl::OUStringBuffer;
 using ::std::auto_ptr;
+using ::std::list;
+using ::std::vector;
+using ::std::hash_map;
+using ::std::hash_set;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -1695,6 +1704,134 @@ void lcl_MoveToEnd( ScDPSaveDimension& rDim, const String& rItemName )
     // puts it to the end of the list even if it was in the list before.
 }
 
+bool ScDBFunc::DataPilotSort( const ScAddress& rPos, bool bAscending, sal_uInt16* pUserListId )
+{
+    ScDocument* pDoc = GetViewData()->GetDocument();
+    ScDPObject* pDPObj = pDoc->GetDPAtCursor(rPos.Col(), rPos.Row(), rPos.Tab());
+    if (!pDPObj)
+        return false;
+
+    // We need to run this to get all members later.
+    pDPObj->BuildAllDimensionMembers();
+
+    USHORT nOrientation;
+    long nDimIndex = pDPObj->GetHeaderDim(rPos, nOrientation);
+    if (nDimIndex < 0)
+        // Invalid dimension index.  Bail out.
+        return false;
+
+    BOOL bDataLayout;
+    ScDPSaveData* pSaveData = pDPObj->GetSaveData();
+    if (!pSaveData)
+        return false;
+
+    ScDPSaveData aNewSaveData(*pSaveData);
+    String aDimName = pDPObj->GetDimName(nDimIndex, bDataLayout);
+    ScDPSaveDimension* pSaveDim = aNewSaveData.GetDimensionByName(aDimName);
+    if (!pSaveDim)
+        return false;
+
+    typedef ScDPSaveDimension::MemberList MemList;
+    const MemList& rDimMembers = pSaveDim->GetMembers();
+    list<OUString> aMembers;
+    hash_set<OUString, ::rtl::OUStringHash> aMemberSet;
+    size_t nMemberCount = 0;
+    for (MemList::const_iterator itr = rDimMembers.begin(), itrEnd = rDimMembers.end();
+          itr != itrEnd; ++itr)
+    {
+        ScDPSaveMember* pMem = *itr;
+        aMembers.push_back(pMem->GetName());
+        aMemberSet.insert(pMem->GetName());
+        ++nMemberCount;
+    }
+
+    // Sort the member list in ascending order.
+    aMembers.sort();
+
+    // Collect and rank those custom sort strings that also exist in the member name list.
+
+    typedef hash_map<OUString, sal_uInt16, OUStringHash> UserSortMap;
+    UserSortMap aSubStrs;
+    sal_uInt16 nSubCount = 0;
+    if (pUserListId)
+    {
+        ScUserList* pUserList = ScGlobal::GetUserList();
+        if (!pUserList)
+            return false;
+    
+        {
+            sal_uInt16 n = pUserList->GetCount();
+            if (!n || *pUserListId >= n)
+                return false;
+        }
+        
+        ScUserListData* pData = static_cast<ScUserListData*>((*pUserList)[*pUserListId]);
+        if (pData)
+        {
+            sal_uInt16 n = pData->GetSubCount();
+            for (sal_uInt16 i = 0; i < n; ++i)
+            {
+                OUString aSub = pData->GetSubStr(i);
+                if (!aMemberSet.count(aSub))
+                    // This string doesn't exist in the member name set.  Don't add this.
+                    continue;
+
+                aSubStrs.insert(UserSortMap::value_type(aSub, nSubCount++));
+            }
+        }
+    }
+
+    // Rank all members.
+
+    vector<OUString> aRankedNames(nMemberCount);
+    sal_uInt16 nCurStrId = 0;
+    for (list<OUString>::const_iterator itr = aMembers.begin(), itrEnd = aMembers.end(); 
+          itr != itrEnd; ++itr)
+    {
+        OUString aName = *itr;
+        sal_uInt16 nRank = 0;
+        UserSortMap::const_iterator itrSub = aSubStrs.find(aName);
+        if (itrSub == aSubStrs.end())
+            nRank = nSubCount + nCurStrId++;
+        else
+            nRank = itrSub->second;
+
+        if (!bAscending)
+            nRank = nMemberCount - nRank - 1;
+
+        aRankedNames[nRank] = aName;
+    }
+
+    // Re-order ScDPSaveMember instances with the new ranks.
+
+    for (vector<OUString>::const_iterator itr = aRankedNames.begin(), itrEnd = aRankedNames.end();
+          itr != itrEnd; ++itr)
+    {
+        const ScDPSaveMember* pOldMem = pSaveDim->GetExistingMemberByName(*itr);
+        if (!pOldMem)
+            // All members are supposed to be present.
+            continue;
+
+        ScDPSaveMember* pNewMem = new ScDPSaveMember(*pOldMem);
+        pSaveDim->AddMember(pNewMem);
+    }
+
+    // Set the sorting mode to manual for now.  We may introduce a new sorting
+    // mode later on.
+
+    sheet::DataPilotFieldSortInfo aSortInfo;
+    aSortInfo.Mode = sheet::DataPilotFieldSortMode::MANUAL;
+    pSaveDim->SetSortInfo(&aSortInfo);
+
+    // Update the datapilot with the newly sorted field members.
+
+    auto_ptr<ScDPObject> pNewObj(new ScDPObject(*pDPObj));
+    pNewObj->SetSaveData(aNewSaveData);
+    ScDBDocFunc aFunc(*GetViewData()->GetDocShell());
+
+    return aFunc.DataPilotUpdate(pDPObj, pNewObj.get(), true, false);
+}
+
 BOOL ScDBFunc::DataPilotMove( const ScRange& rSource, const ScAddress& rDest )
 {
     BOOL bRet = FALSE;
diff --git sc/source/ui/view/gridwin2.cxx sc/source/ui/view/gridwin2.cxx
index 63ce024..72a6606 100644
--- sc/source/ui/view/gridwin2.cxx
+++ sc/source/ui/view/gridwin2.cxx
@@ -56,6 +56,9 @@
 #include "dpshttab.hxx"
 #include "dbdocfun.hxx"
 #include "dpcontrol.hxx"
+#include "dpcontrol.hrc"
+#include "strload.hxx"
+#include "userlist.hxx"
 
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include "scabstdlg.hxx" //CHINA001
@@ -778,7 +781,7 @@ struct DPFieldPopupData : public ScDPFieldPopupWindow::ExtendedData
     long            mnDim;
 };
 
-class DPFieldPopupOKAction : public ScDPFieldPopupWindow::OKAction
+class DPFieldPopupOKAction : public ScMenuFloatingWindow::Action
 {
 public:
     explicit DPFieldPopupOKAction(ScGridWindow* p) : 
@@ -792,6 +795,39 @@ private:
     ScGridWindow* mpGridWindow;
 };
 
+class PopupSortAction : public ScMenuFloatingWindow::Action
+{
+public:
+    enum SortType { ASCENDING, DESCENDING, CUSTOM };
+
+    explicit PopupSortAction(const ScAddress& rPos, SortType eType, sal_uInt16 nUserListIndex, ScTabViewShell* pViewShell) :
+        maPos(rPos), meType(eType), mnUserListIndex(nUserListIndex), mpViewShell(pViewShell) {}
+
+    virtual void execute()
+    {
+        switch (meType)
+        {
+            case ASCENDING:
+                mpViewShell->DataPilotSort(maPos, true);
+            break;
+            case DESCENDING:
+                mpViewShell->DataPilotSort(maPos, false);
+            break;
+            case CUSTOM:
+                mpViewShell->DataPilotSort(maPos, true, &mnUserListIndex);
+            break;
+            default:
+                ;
+        }
+    }
+
+private:
+    ScAddress       maPos;
+    SortType        meType;
+    sal_uInt16      mnUserListIndex;
+    ScTabViewShell* mpViewShell;
+};
+
 }
 
 void ScGridWindow::DPLaunchFieldPopupMenu(
@@ -814,11 +850,48 @@ void ScGridWindow::DPLaunchFieldPopupMenu(
     mpDPFieldPopup.reset(new ScDPFieldPopupWindow(this));
     mpDPFieldPopup->setExtendedData(pDPData.release());
     mpDPFieldPopup->setOKAction(new DPFieldPopupOKAction(this));
-    sal_Int32 n = rLabelData.maMembers.getLength();
-    mpDPFieldPopup->setMemberSize(n);
-    for (sal_Int32 i = 0; i < n; ++i)
-        mpDPFieldPopup->addMember(rLabelData.maMembers[i], rLabelData.maVisible[i]);
-    mpDPFieldPopup->initMembers();
+    {
+        sal_Int32 n = rLabelData.maMembers.getLength();
+        mpDPFieldPopup->setMemberSize(n);
+        for (sal_Int32 i = 0; i < n; ++i)
+            mpDPFieldPopup->addMember(rLabelData.maMembers[i], rLabelData.maVisible[i]);
+        mpDPFieldPopup->initMembers();
+    }
+
+    vector<OUString> aUserSortNames;
+    ScUserList* pUserList = ScGlobal::GetUserList();
+    if (pUserList)
+    {
+        sal_uInt16 n = pUserList->GetCount();
+        aUserSortNames.reserve(n);
+        for (sal_uInt16 i = 0; i < n; ++i)
+        {
+            ScUserListData* pData = static_cast<ScUserListData*>((*pUserList)[i]);
+            aUserSortNames.push_back(pData->GetString());
+        }
+    }
+
+    // Populate the menus.
+    ScTabViewShell* pViewShell = pViewData->GetViewShell();
+    mpDPFieldPopup->addMenuItem(
+        ScRscStrLoader(RID_SC_DPCONTROL, STR_MENU_SORT_ASC).GetString(), true, 
+        new PopupSortAction(rPos, PopupSortAction::ASCENDING, 0, pViewShell));
+    mpDPFieldPopup->addMenuItem(
+        ScRscStrLoader(RID_SC_DPCONTROL, STR_MENU_SORT_DESC).GetString(), true,
+        new PopupSortAction(rPos, PopupSortAction::DESCENDING, 0, pViewShell));
+    ScMenuFloatingWindow* pSubMenu = mpDPFieldPopup->addSubMenuItem(
+        ScRscStrLoader(RID_SC_DPCONTROL, STR_MENU_SORT_CUSTOM).GetString(), !aUserSortNames.empty());
+
+    if (pSubMenu && !aUserSortNames.empty())
+    {
+        size_t n = aUserSortNames.size();
+        for (size_t i = 0; i < n; ++i)
+        {    
+            pSubMenu->addMenuItem(
+                aUserSortNames[i], true, 
+                new PopupSortAction(rPos, PopupSortAction::CUSTOM, i, pViewShell));
+        }
+    }
 
     mpDPFieldPopup->SetPopupModeEndHdl( LINK(this, ScGridWindow, PopupModeEndHdl) );
     Rectangle aCellRect(rSrcPos, rSrcSize);
diff --git sc/util/makefile.mk sc/util/makefile.mk
index 88e0594..bdf4954 100644
--- sc/util/makefile.mk
+++ sc/util/makefile.mk
@@ -58,6 +58,7 @@ RESLIB1LIST=\
 	$(SRS)$/formdlgs.srs \
 	$(SRS)$/pagedlg.srs	\
 	$(SRS)$/navipi.srs	\
+	$(SRS)$/cctrl.srs	\
 	$(SOLARCOMMONRESDIR)$/sfx.srs
 
 RESLIB1NAME=sc
