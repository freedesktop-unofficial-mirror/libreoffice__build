 svx/inc/svx/svdotext.hxx         |    3 ++
 svx/source/editeng/impedit3.cxx  |    7 +++++
 svx/source/msfilter/msdffimp.cxx |   14 ++++++++++-
 svx/source/svdraw/svdedxv.cxx    |   38 +++++++++++++++++++++--------
 svx/source/svdraw/svdotext.cxx   |   50 +++++++++++++++++++++++++++++++++-----
 5 files changed, 93 insertions(+), 19 deletions(-)

diff --git a/svx/inc/svx/svdotext.hxx b/svx/inc/svx/svdotext.hxx
index e90c491..7d1d0ae 100644
--- svx/inc/svx/svdotext.hxx
+++ svx/inc/svx/svdotext.hxx
@@ -244,6 +244,9 @@ protected:
 	// Flag for allowing text animation. Default is sal_true.
 	BOOL						mbTextAnimationAllowed : 1;
 
+    // flag for preventing recursive onEditOutlinerStatusEvent calls
+	BOOL					    mbInDownScale : 1;
+
 	SVX_DLLPRIVATE SdrOutliner& ImpGetDrawOutliner() const;
 
 private:
diff --git a/svx/source/editeng/impedit3.cxx b/svx/source/editeng/impedit3.cxx
index 5639cb5..aa7162c 100644
--- svx/source/editeng/impedit3.cxx
+++ svx/source/editeng/impedit3.cxx
@@ -3978,20 +3978,25 @@ void ImpEditEngine::SetFlatMode( sal_Bool bFlat )
 
 void ImpEditEngine::SetCharStretching( sal_uInt16 nX, sal_uInt16 nY )
 {
+    bool bChanged(false);
 	if ( !IsVertical() )
 	{
+        bChanged = nStretchX!=nX || nStretchY!=nY;
 		nStretchX = nX;
 		nStretchY = nY;
 	}
 	else
 	{
+        bChanged = nStretchX!=nY || nStretchY!=nX;
 		nStretchX = nY;
 		nStretchY = nX;
 	}
 
-	if ( aStatus.DoStretch() )
+	if (bChanged && aStatus.DoStretch())
 	{
 		FormatFullDoc();
+        // (potentially) need everything redrawn
+        aInvalidRec=Rectangle(0,0,1000000,1000000);
 		UpdateViews( GetActiveView() );
 	}
 }
diff --git a/svx/source/msfilter/msdffimp.cxx b/svx/source/msfilter/msdffimp.cxx
index e34d920..d572729 100644
--- svx/source/msfilter/msdffimp.cxx
+++ svx/source/msfilter/msdffimp.cxx
@@ -1921,7 +1921,16 @@ void DffPropertyReader::ApplyCustomShapeTextAttributes( SfxItemSet& rSet ) const
 	rSet.Put( SdrTextLowerDistItem( nTextBottom ) );
 
 	rSet.Put( SdrTextWordWrapItem( (MSO_WrapMode)GetPropertyValue( DFF_Prop_WrapText, mso_wrapSquare ) != mso_wrapNone ? sal_True : sal_False ) );
-	rSet.Put( SdrTextAutoGrowHeightItem( ( GetPropertyValue( DFF_Prop_FitTextToShape ) & 2 ) != 0 ) );
+    if( GetPropertyValue( DFF_Prop_FitTextToShape ) & 2 )
+        rSet.Put( SdrTextAutoGrowHeightItem( TRUE ) );
+    else 
+    {
+        OSL_TRACE( "DFF_Prop_FitTextToShape is %d", GetPropertyValue(DFF_Prop_FitTextToShape) );
+
+        rSet.Put( SdrTextAutoGrowHeightItem( FALSE ) );
+        //if (GetPropertyValue(DFF_Prop_FitTextToShape) & 1)
+        rSet.Put( SdrTextFitToSizeTypeItem(SDRTEXTFIT_ALLLINES) ); // seems PPT unconditionally implies fit-to-shape for presentation text outliner
+    }
 
 //	rSet.Put( SdrTextAutoGrowWidthItem( (MSO_WrapMode)GetPropertyValue( DFF_Prop_WrapText, mso_wrapSquare ) != mso_wrapNone ? sal_False : sal_True ) );
 //	rSet.Put( SdrTextAutoGrowHeightItem( ( GetPropertyValue( DFF_Prop_FitTextToShape ) & 2 ) != 0 ) );
@@ -5587,6 +5596,9 @@ SdrObject* SvxMSDffManager::ProcessObj(SvStream& rSt,
             }
             else
             {
+                if (GetPropertyValue(DFF_Prop_FitTextToShape) & 1)
+                    aSet.Put( SdrTextFitToSizeTypeItem(SDRTEXTFIT_ALLLINES) );
+
                 aSet.Put( SdrTextAutoGrowHeightItem( FALSE ) );
                 aSet.Put( SdrTextAutoGrowWidthItem( FALSE ) );
             }
diff --git a/svx/source/svdraw/svdedxv.cxx b/svx/source/svdraw/svdedxv.cxx
index 40d9ee8..764706b 100644
--- svx/source/svdraw/svdedxv.cxx
+++ svx/source/svdraw/svdedxv.cxx
@@ -218,11 +218,16 @@ void SdrObjEditView::ModelHasChanged()
                     pTextEditOutliner->SetMinAutoPaperSize(aPaperMin1);
                     pTextEditOutliner->SetMaxAutoPaperSize(aPaperMax1);
                     pTextEditOutliner->SetPaperSize(Size(0,0)); // Damit der Outliner neu formatiert
+                    const SdrFitToSizeType eFit = pTextObj->GetFitToSize();
+                    ULONG nStat=pTextEditOutliner->GetControlWord();
                     if (!bContourFrame) {
                         pTextEditOutliner->ClearPolygon();
-                        ULONG nStat=pTextEditOutliner->GetControlWord();
-                        nStat|=EE_CNTRL_AUTOPAGESIZE;
-                        pTextEditOutliner->SetControlWord(nStat);
+                        if( eFit!=SDRTEXTFIT_PROPORTIONAL && 
+                            eFit!=SDRTEXTFIT_ALLLINES ) 
+                        {
+                            nStat|=EE_CNTRL_AUTOPAGESIZE;
+                            pTextEditOutliner->SetControlWord(nStat);
+                        }
                     } else {
                         ULONG nStat=pTextEditOutliner->GetControlWord();
                         nStat&=~EE_CNTRL_AUTOPAGESIZE;
@@ -234,10 +239,17 @@ void SdrObjEditView::ModelHasChanged()
                     for (ULONG nOV=0; nOV<nOutlViewAnz; nOV++) {
                         OutlinerView* pOLV=pTextEditOutliner->GetView(nOV);
                         ULONG nStat0=pOLV->GetControlWord();
-                        ULONG nStat=nStat0;
-                        // AutoViewSize nur wenn nicht KontourFrame.
-                        if (!bContourFrame) nStat|=EV_CNTRL_AUTOSIZE;
-                        else nStat&=~EV_CNTRL_AUTOSIZE;
+                        nStat=nStat0;
+                        // AutoViewSize only when not a ContourFrame, and not when scaling
+                        // down text to shape size anyway
+                        if (!bContourFrame) 
+                        {
+                            nStat|=EV_CNTRL_AUTOSIZE;
+                        }
+                        else
+                        {
+                            nStat&=~EV_CNTRL_AUTOSIZE;
+                        }
                         if (nStat!=nStat0) pOLV->SetControlWord(nStat);
                     }
                     pTextEditOutliner->SetUpdateMode(TRUE);
@@ -318,7 +330,6 @@ void SdrObjEditView::ImpPaintOutlinerView(OutlinerView& rOutlView, const Rectang
 	{
 		const SdrTextObj* pText = PTR_CAST(SdrTextObj,GetTextEditObject());
 		bool bTextFrame(pText && pText->IsTextFrame());
-		bool bFitToSize(0 != (pTextEditOutliner->GetControlWord() & EE_CNTRL_STRETCHING));
 		bool bModifyMerk(pTextEditOutliner->IsModified()); // #43095#
 		Rectangle aBlankRect(rOutlView.GetOutputArea());
 		aBlankRect.Union(aMinTextEditArea);
@@ -333,7 +344,7 @@ void SdrObjEditView::ImpPaintOutlinerView(OutlinerView& rOutlView, const Rectang
 			pTextEditOutliner->ClearModifyFlag(); 
 		}
 
-		if(bTextFrame && !bFitToSize) 
+		if(bTextFrame) 
 		{
 			aPixRect.Left()--;
 			aPixRect.Top()--;
@@ -485,8 +496,13 @@ OutlinerView* SdrObjEditView::ImpMakeOutlinerView(Window* pWin, BOOL /*bNoPaint*
     // Scrollen verbieten
     ULONG nStat=pOutlView->GetControlWord();
     nStat&=~EV_CNTRL_AUTOSCROLL;
-    // AutoViewSize nur wenn nicht KontourFrame.
-    if (!bContourFrame) nStat|=EV_CNTRL_AUTOSIZE;
+    // AutoViewSize only when not a ContourFrame, and not when scaling
+    // down text to shape size anyway
+    const SdrFitToSizeType eFit = pText->GetFitToSize();
+    if (!bContourFrame) 
+    {
+        nStat|=EV_CNTRL_AUTOSIZE;
+    }
     if (bTextFrame) {
         USHORT nPixSiz=aHdl.GetHdlSize()*2+1;
         nStat|=EV_CNTRL_INVONEMORE;
diff --git a/svx/source/svdraw/svdotext.cxx b/svx/source/svdraw/svdotext.cxx
index 65d164b..2c00ec3 100644
--- svx/source/svdraw/svdotext.cxx
+++ svx/source/svdraw/svdotext.cxx
@@ -140,6 +140,7 @@ SdrTextObj::SdrTextObj()
 
 	// #i25616#
 	mbSupportTextIndentingOnLineWidthChange = sal_True;
+    mbInDownScale = sal_False;
 }
 
 SdrTextObj::SdrTextObj(const Rectangle& rNewRect)
@@ -165,6 +166,7 @@ SdrTextObj::SdrTextObj(const Rectangle& rNewRect)
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -195,6 +197,7 @@ SdrTextObj::SdrTextObj(SdrObjKind eNewTextKind)
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -227,6 +230,7 @@ SdrTextObj::SdrTextObj(SdrObjKind eNewTextKind, const Rectangle& rNewRect)
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -261,6 +265,7 @@ SdrTextObj::SdrTextObj(SdrObjKind eNewTextKind, const Rectangle& rNewRect, SvStr
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -876,6 +881,10 @@ void SdrTextObj::TakeTextRect( SdrOutliner& rOutliner, Rectangle& rTextRect, FAS
 			rOutliner.SetMinAutoPaperSize(Size(0, nAnkHgt));
 		}
 	}
+    else if( bFitToSize && !bContourFrame )
+    {
+        rOutliner.SetMinAutoPaperSize(aAnkRect.GetSize());
+    }
 
 	rOutliner.SetPaperSize(aNullSize);
 	if (bContourFrame)
@@ -1057,11 +1066,11 @@ void SdrTextObj::ImpSetCharStretching(SdrOutliner& rOutliner, const Rectangle& r
 	while (nLoopCount<5 && !bNoMoreLoop) {
 		if (nX<0) nX=-nX;
 		if (nX<1) { nX=1; bNoMoreLoop=TRUE; }
-		if (nX>65535) { nX=65535; bNoMoreLoop=TRUE; }
+		if (nX>100) { nX=100; bNoMoreLoop=TRUE; }
 
 		if (nY<0) nY=-nY;
 		if (nY<1) { nY=1; bNoMoreLoop=TRUE; }
-		if (nY>65535) { nY=65535; bNoMoreLoop=TRUE; }
+		if (nY>100) { nY=100; bNoMoreLoop=TRUE; }
 
 		// exception, there is no text yet (horizontal case)
 		if(nIsWdt <= 1)
@@ -1077,7 +1086,7 @@ void SdrTextObj::ImpSetCharStretching(SdrOutliner& rOutliner, const Rectangle& r
 			bNoMoreLoop = TRUE;
 		}
 
-		rOutliner.SetGlobalCharStretching((USHORT)nX,(USHORT)nY);
+		rOutliner.SetGlobalCharStretching((USHORT)std::min(nX,nY),(USHORT)std::min(nX,nY));
 		nLoopCount++;
 		Size aSiz(rOutliner.CalcTextSize());
 		long nXDiff=aSiz.Width()-nWantWdt;
@@ -2414,10 +2423,39 @@ void SdrTextObj::onEditOutlinerStatusEvent( EditStatus* pEditStatus )
 	const bool bGrowY=(nStat & EE_STAT_TEXTHEIGHTCHANGED) !=0;
     if(bTextFrame && (bGrowX || bGrowY))
 	{
-		const bool bAutoGrowHgt= bTextFrame && IsAutoGrowHeight();
-		const bool bAutoGrowWdt= bTextFrame && IsAutoGrowWidth();
+        // auto-shrink text when GetFitToSize() demands it
+        const SdrFitToSizeType eFit = GetFitToSize();
+        if( (bGrowX || bGrowY) &&
+            (eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES) )
+        {
+            const Size aShapeSize = GetLastBoundRect().GetSize();
+            const Size aCurrTextSize = pEdtOutl->CalcTextSize();
+            const double fFactor( 
+                std::min( 
+                    double(aShapeSize.Width())/
+                    (aCurrTextSize.Width()+GetTextLeftDistance()+GetTextRightDistance()),
+                    double(aShapeSize.Height())/
+                    (aCurrTextSize.Height()+GetTextUpperDistance()+GetTextLowerDistance())));
+
+            USHORT nOldStretchX, nOldStretchY;
+            pEdtOutl->GetGlobalCharStretching(nOldStretchX, nOldStretchY);
+
+            // only do the scaling once (we'll get notified again, recursively)
+            if( !mbInDownScale && (fFactor < 1.0 || (fFactor >= 1.0 && nOldStretchX != 100)) )
+            {
+                mbInDownScale = sal_True;
 
-	    if ((bGrowX && bAutoGrowWdt) || (bGrowY && bAutoGrowHgt))
+                nOldStretchX = sal::static_int_cast<USHORT>(nOldStretchX*fFactor);
+                nOldStretchY = sal::static_int_cast<USHORT>(nOldStretchY*fFactor);
+                pEdtOutl->SetGlobalCharStretching(std::min(USHORT(100),nOldStretchX),
+                                                           std::min(USHORT(100),nOldStretchY));
+
+                OSL_TRACE("SdrObjEditView::ImpOutlinerStatusEventHdl: shrink factor is %f, shrink X: %d, shrink Y: %d\n", fFactor, nOldStretchX, nOldStretchY);
+
+                mbInDownScale = sal_False;
+            }
+        }
+        else if ((bGrowX && IsAutoGrowWidth()) || (bGrowY && IsAutoGrowHeight()))
 		{
 			AdjustTextFrameWidthAndHeight();
 		}
