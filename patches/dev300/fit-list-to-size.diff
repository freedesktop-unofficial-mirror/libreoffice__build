 svx/inc/svx/sdtfsitm.hxx         |   26 +++++-----
 svx/inc/svx/svdotext.hxx         |   10 +++-
 svx/source/dialog/textattr.cxx   |    1 
 svx/source/editeng/impedit3.cxx  |    7 ++-
 svx/source/msfilter/msdffimp.cxx |    8 +++
 svx/source/svdraw/svdedxv.cxx    |    4 +-
 svx/source/svdraw/svdotext.cxx   |  100 ++++++++++++++++++++++++++++++--------
 svx/source/svdraw/svdotxat.cxx   |    3 -
 svx/source/svdraw/svdotxed.cxx   |   17 ++++--
 svx/source/svdraw/svdotxtr.cxx   |    9 ---
 svx/source/svdraw/svdtxhdl.cxx   |    3 -
 svx/source/svdraw/svdview.cxx    |    3 -
 12 files changed, 130 insertions(+), 61 deletions(-)

diff --git a/svx/inc/svx/sdtfsitm.hxx b/svx/inc/svx/sdtfsitm.hxx
index 6a583eb..abaf580 100644
--- svx/inc/svx/sdtfsitm.hxx
+++ svx/inc/svx/sdtfsitm.hxx
@@ -34,19 +34,21 @@
 #include <svx/svddef.hxx>
 #include "svx/svxdllapi.h"
 
-enum SdrFitToSizeType {SDRTEXTFIT_NONE,         // - kein FitToSize
-					   SDRTEXTFIT_PROPORTIONAL, // - Alle Buchstaben proportional umgroessern
-					   SDRTEXTFIT_ALLLINES,     // - Zus. jede Zeile separat in der Breite stretchen
-					   SDRTEXTFIT_RESIZEATTR};  // - Bei Rahmenumgroesserung (ausser Autogrow) wird
-												//   die Schriftgroesse umattributiert (hart)
+enum SdrFitToSizeType {
+    SDRTEXTFIT_NONE,         // - no fit-to-size
+    SDRTEXTFIT_PROPORTIONAL, // - resize all glyhs proportionally
+                             //   (might scale anisotrophically)
+    SDRTEXTFIT_ALLLINES,     // - like SDRTEXTFIT_PROPORTIONAL, but
+                             //   scales each line separately
+    SDRTEXTFIT_AUTOFIT};     // - mimics PPT's automatic adaption of
+                             //   font size to text rect - comparable
+                             //   to SDRTEXTFIT_PROPORTIONAL, but
+                             //   scales isotrophically
 
-// Bei SDRTEXTFIT_PROPORTIONAL und SDRTEXTFIT_ALLLINES gibt es kein AutoGrow und
-// keine automatischen Umbrueche.
-// Ist SDRTEXTFIT_RESIZEATTR gesetzt, so wird beim umgroessern des Textrahmens
-// (ausser bei AutoGrow) die Schrift durch harte Attributierung ebenfalls
-// umgegroessert.
-// Bei AutoGrowingWidth gibt es ebenfalls keine automatischen Umbrueche (erst bei
-// TextMaxFrameWidth).
+// No AutoGrow and no automatic line breaks for
+// SDRTEXTFIT_PROPORTIONAL and SDRTEXTFIT_ALLLINES.
+// No automatic line breaks for AutoGrowingWidth as well (only if
+// TextMaxFrameWidth is reached).
 
 //--------------------------------
 // class SdrTextFitToSizeTypeItem
diff --git a/svx/inc/svx/svdotext.hxx b/svx/inc/svx/svdotext.hxx
index e90c491..d1fc9df 100644
--- svx/inc/svx/svdotext.hxx
+++ svx/inc/svx/svdotext.hxx
@@ -244,6 +244,9 @@ protected:
 	// Flag for allowing text animation. Default is sal_true.
 	BOOL						mbTextAnimationAllowed : 1;
 
+    // flag for preventing recursive onEditOutlinerStatusEvent calls
+	BOOL					    mbInDownScale : 1;
+
 	SVX_DLLPRIVATE SdrOutliner& ImpGetDrawOutliner() const;
 
 private:
@@ -257,6 +260,7 @@ private:
                                        Rectangle& 		rAnchorRect, 
                                        Rectangle& 		rPaintRect, 
                                        Fraction& 		aFitXKorreg ) const;
+    void ImpAutoFitText( SdrOutliner& rOutliner ) const;
 	SVX_DLLPRIVATE SdrObject* ImpConvertObj(FASTBOOL bToPoly) const;
 	SVX_DLLPRIVATE void ImpLinkAnmeldung();
 	SVX_DLLPRIVATE void ImpLinkAbmeldung();
@@ -268,7 +272,7 @@ protected:
 	SdrObject* ImpConvertMakeObj(const basegfx::B2DPolyPolygon& rPolyPolygon, sal_Bool bClosed, sal_Bool bBezier, sal_Bool bNoSetAttr = sal_False) const;
 	SdrObject* ImpConvertAddText(SdrObject* pObj, FASTBOOL bBezier) const;
 	void ImpSetTextStyleSheetListeners();
-	void ImpSetCharStretching(SdrOutliner& rOutliner, const Rectangle& rTextRect, const Rectangle& rAnchorRect, Fraction& rFitXKorreg) const;
+    void ImpSetCharStretching(SdrOutliner& rOutliner, const Size& rTextSize, const Size& rShapeSize, Fraction& rFitXKorreg) const;
 	void ImpAddTextToBoundRect();
 	void ImpJustifyRect(Rectangle& rRect) const;
 	void ImpCheckShear();
@@ -331,6 +335,10 @@ public:
 	void NbcResizeTextAttributes(const Fraction& xFact, const Fraction& yFact);
 	FASTBOOL IsTextFrame() const { return bTextFrame; }
 	FASTBOOL IsOutlText() const { return bTextFrame && (eTextKind==OBJ_OUTLINETEXT || eTextKind==OBJ_TITLETEXT); }
+    /// returns true if the PPT autofit of text into shape bounds is enabled. implies IsFitToSize()==false!
+	FASTBOOL IsAutoFit() const;
+    /// returns true if the old feature for fitting shape content should into shape is enabled. implies IsAutoFit()==false!
+	FASTBOOL IsFitToSize() const;
 	SdrObjKind GetTextKind() const { return eTextKind; }
 
 	virtual bool HasText() const;
diff --git a/svx/source/dialog/textattr.cxx b/svx/source/dialog/textattr.cxx
index 4eab4bf..b4b1114 100644
--- svx/source/dialog/textattr.cxx
+++ svx/source/dialog/textattr.cxx
@@ -460,7 +460,6 @@ BOOL SvxTextAttrPage::FillItemSet( SfxItemSet& rAttrs)
             default: ; //prevent warning
 				DBG_ERROR( "svx::SvxTextAttrPage::FillItemSet(), unhandled state!" );
 			case STATE_NOCHECK: eFTS = SDRTEXTFIT_NONE; break;
-			//case STATE_CHECK: eFTS = SDRTEXTFIT_RESIZEATTR; break;
 			case STATE_CHECK: eFTS = SDRTEXTFIT_PROPORTIONAL; break;
 		}
 		rAttrs.Put( SdrTextFitToSizeTypeItem( eFTS ) );
diff --git a/svx/source/editeng/impedit3.cxx b/svx/source/editeng/impedit3.cxx
index 5639cb5..aa7162c 100644
--- svx/source/editeng/impedit3.cxx
+++ svx/source/editeng/impedit3.cxx
@@ -3978,20 +3978,25 @@ void ImpEditEngine::SetFlatMode( sal_Bool bFlat )
 
 void ImpEditEngine::SetCharStretching( sal_uInt16 nX, sal_uInt16 nY )
 {
+    bool bChanged(false);
 	if ( !IsVertical() )
 	{
+        bChanged = nStretchX!=nX || nStretchY!=nY;
 		nStretchX = nX;
 		nStretchY = nY;
 	}
 	else
 	{
+        bChanged = nStretchX!=nY || nStretchY!=nX;
 		nStretchX = nY;
 		nStretchY = nX;
 	}
 
-	if ( aStatus.DoStretch() )
+	if (bChanged && aStatus.DoStretch())
 	{
 		FormatFullDoc();
+        // (potentially) need everything redrawn
+        aInvalidRec=Rectangle(0,0,1000000,1000000);
 		UpdateViews( GetActiveView() );
 	}
 }
diff --git a/svx/source/msfilter/msdffimp.cxx b/svx/source/msfilter/msdffimp.cxx
index e34d920..c36b925 100644
--- svx/source/msfilter/msdffimp.cxx
+++ svx/source/msfilter/msdffimp.cxx
@@ -1921,7 +1921,13 @@ void DffPropertyReader::ApplyCustomShapeTextAttributes( SfxItemSet& rSet ) const
 	rSet.Put( SdrTextLowerDistItem( nTextBottom ) );
 
 	rSet.Put( SdrTextWordWrapItem( (MSO_WrapMode)GetPropertyValue( DFF_Prop_WrapText, mso_wrapSquare ) != mso_wrapNone ? sal_True : sal_False ) );
-	rSet.Put( SdrTextAutoGrowHeightItem( ( GetPropertyValue( DFF_Prop_FitTextToShape ) & 2 ) != 0 ) );
+    if( GetPropertyValue( DFF_Prop_FitTextToShape ) & 2 )
+        rSet.Put( SdrTextAutoGrowHeightItem( TRUE ) );
+    else 
+    {
+        rSet.Put( SdrTextAutoGrowHeightItem( FALSE ) );
+        rSet.Put( SdrTextFitToSizeTypeItem(SDRTEXTFIT_AUTOFIT) ); // seems PPT unconditionally implies auto-fit for presentation text outliner
+    }
 
 //	rSet.Put( SdrTextAutoGrowWidthItem( (MSO_WrapMode)GetPropertyValue( DFF_Prop_WrapText, mso_wrapSquare ) != mso_wrapNone ? sal_False : sal_True ) );
 //	rSet.Put( SdrTextAutoGrowHeightItem( ( GetPropertyValue( DFF_Prop_FitTextToShape ) & 2 ) != 0 ) );
diff --git a/svx/source/svdraw/svdedxv.cxx b/svx/source/svdraw/svdedxv.cxx
index 40d9ee8..d373176 100644
--- svx/source/svdraw/svdedxv.cxx
+++ svx/source/svdraw/svdedxv.cxx
@@ -318,7 +318,7 @@ void SdrObjEditView::ImpPaintOutlinerView(OutlinerView& rOutlView, const Rectang
 	{
 		const SdrTextObj* pText = PTR_CAST(SdrTextObj,GetTextEditObject());
 		bool bTextFrame(pText && pText->IsTextFrame());
-		bool bFitToSize(0 != (pTextEditOutliner->GetControlWord() & EE_CNTRL_STRETCHING));
+		bool bFitToSize(pText && pText->IsFitToSize());
 		bool bModifyMerk(pTextEditOutliner->IsModified()); // #43095#
 		Rectangle aBlankRect(rOutlView.GetOutputArea());
 		aBlankRect.Union(aMinTextEditArea);
@@ -387,7 +387,7 @@ void SdrObjEditView::ImpInvalidateOutlinerView(OutlinerView& rOutlView) const
 	{
 		const SdrTextObj* pText = PTR_CAST(SdrTextObj,GetTextEditObject());
 		bool bTextFrame(pText && pText->IsTextFrame());
-		bool bFitToSize(0 != (pTextEditOutliner->GetControlWord() & EE_CNTRL_STRETCHING));
+		bool bFitToSize(pText && pText->IsFitToSize());
 
 		if(bTextFrame && !bFitToSize) 
 		{
diff --git a/svx/source/svdraw/svdotext.cxx b/svx/source/svdraw/svdotext.cxx
index 65d164b..8b8f1a0 100644
--- svx/source/svdraw/svdotext.cxx
+++ svx/source/svdraw/svdotext.cxx
@@ -140,6 +140,7 @@ SdrTextObj::SdrTextObj()
 
 	// #i25616#
 	mbSupportTextIndentingOnLineWidthChange = sal_True;
+    mbInDownScale = sal_False;
 }
 
 SdrTextObj::SdrTextObj(const Rectangle& rNewRect)
@@ -165,6 +166,7 @@ SdrTextObj::SdrTextObj(const Rectangle& rNewRect)
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -195,6 +197,7 @@ SdrTextObj::SdrTextObj(SdrObjKind eNewTextKind)
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -227,6 +230,7 @@ SdrTextObj::SdrTextObj(SdrObjKind eNewTextKind, const Rectangle& rNewRect)
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -261,6 +265,7 @@ SdrTextObj::SdrTextObj(SdrObjKind eNewTextKind, const Rectangle& rNewRect, SvStr
 
 	// #111096#
 	mbTextAnimationAllowed = sal_True;
+    mbInDownScale = sal_False;
 
 	// #108784#
 	maTextEditOffset = Point(0, 0);
@@ -829,8 +834,7 @@ void SdrTextObj::TakeTextRect( SdrOutliner& rOutliner, Rectangle& rTextRect, FAS
 	SdrTextAniKind      eAniKind=GetTextAniKind();
 	SdrTextAniDirection eAniDirection=GetTextAniDirection();
 
-	SdrFitToSizeType eFit=GetFitToSize();
-	FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+    FASTBOOL bFitToSize(IsFitToSize());
 	FASTBOOL bContourFrame=IsContourTextFrame();
 
 	FASTBOOL bFrame=IsTextFrame();
@@ -988,7 +992,7 @@ OutlinerParaObject* SdrTextObj::GetEditOutlinerParaObject() const
 	return pPara;
 }
 
-void SdrTextObj::ImpSetCharStretching(SdrOutliner& rOutliner, const Rectangle& rTextRect, const Rectangle& rAnchorRect, Fraction& rFitXKorreg) const
+void SdrTextObj::ImpSetCharStretching(SdrOutliner& rOutliner, const Size& rTextSize, const Size& rShapeSize, Fraction& rFitXKorreg) const
 {
 	OutputDevice* pOut = rOutliner.GetRefDevice();
 	BOOL bNoStretching(FALSE);
@@ -1033,12 +1037,12 @@ void SdrTextObj::ImpSetCharStretching(SdrOutliner& rOutliner, const Rectangle& r
 	unsigned nLoopCount=0;
 	FASTBOOL bNoMoreLoop=FALSE;
 	long nXDiff0=0x7FFFFFFF;
-	long nWantWdt=rAnchorRect.Right()-rAnchorRect.Left();
-	long nIsWdt=rTextRect.Right()-rTextRect.Left();
+	long nWantWdt=rShapeSize.Width();
+	long nIsWdt=rTextSize.Width();
 	if (nIsWdt==0) nIsWdt=1;
 
-	long nWantHgt=rAnchorRect.Bottom()-rAnchorRect.Top();
-	long nIsHgt=rTextRect.Bottom()-rTextRect.Top();
+	long nWantHgt=rShapeSize.Height();
+	long nIsHgt=rTextSize.Height();
 	if (nIsHgt==0) nIsHgt=1;
 
 	long nXTolPl=nWantWdt/100; // Toleranz +1%
@@ -1401,8 +1405,7 @@ void SdrTextObj::ImpAddTextToBoundRect()
 				Rectangle aTextRect;
 				Rectangle aAnchorRect;
 				TakeTextRect(rOutliner,aTextRect,TRUE,&aAnchorRect); // EditText ignorieren!
-				SdrFitToSizeType eFit=GetFitToSize();
-				FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+                FASTBOOL bFitToSize(IsFitToSize());
 				if (bFitToSize) aTextRect=aAnchorRect;
 				rOutliner.Clear();
 				if (aGeo.nDrehWink!=0) {
@@ -1431,8 +1434,7 @@ SdrObject* SdrTextObj::CheckHit(const Point& rPnt, USHORT nTol, const SetOfByte*
 
 	INT32 nMyTol=nTol;
 	FASTBOOL bFontwork=IsFontwork();
-	SdrFitToSizeType eFit=GetFitToSize();
-	FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+    FASTBOOL bFitToSize(IsFitToSize());
 	Rectangle aR(aRect);
 	Rectangle aAnchor2(aR);
 	Rectangle aTextRect(aR);
@@ -1665,8 +1667,7 @@ basegfx::B2DPolyPolygon SdrTextObj::TakeContour() const
 		Rectangle aR;
 		TakeTextRect(rOutliner,aR,FALSE,&aAnchor2);
 		rOutliner.Clear();
-		SdrFitToSizeType eFit=GetFitToSize();
-		FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+        FASTBOOL bFitToSize(IsFitToSize());
 		if (bFitToSize) aR=aAnchor2;
 		Polygon aPol(aR);
 		if (aGeo.nDrehWink!=0) RotatePoly(aPol,aR.TopLeft(),aGeo.nSin,aGeo.nCos);
@@ -1783,8 +1784,7 @@ void SdrTextObj::ImpSetupDrawOutlinerForPaint( FASTBOOL 		bContourFrame,
     if (!bContourFrame)
     {
         // FitToSize erstmal nicht mit ContourFrame
-        SdrFitToSizeType eFit=GetFitToSize();
-        if (eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES)
+        if (IsFitToSize() || IsAutoFit())
         {
             ULONG nStat=rOutliner.GetControlWord();
             nStat|=EE_CNTRL_STRETCHING|EE_CNTRL_AUTOPAGESIZE;
@@ -1798,15 +1798,52 @@ void SdrTextObj::ImpSetupDrawOutlinerForPaint( FASTBOOL 		bContourFrame,
     if (!bContourFrame)
     {
         // FitToSize erstmal nicht mit ContourFrame
-        SdrFitToSizeType eFit=GetFitToSize();
-        if (eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES)
+        if (IsFitToSize())
         {
-            ImpSetCharStretching(rOutliner,rTextRect,rAnchorRect,rFitXKorreg);
+            ImpSetCharStretching(rOutliner,rTextRect.GetSize(),rAnchorRect.GetSize(),rFitXKorreg);
             rPaintRect=rAnchorRect;
         }
+        else if (IsAutoFit())
+        {
+            ImpAutoFitText(rOutliner);
+        }
     }
 }
 
+void SdrTextObj::ImpAutoFitText( SdrOutliner& rOutliner ) const
+{
+    // EditEngine formatting is unstable enough for
+    // line-breaking text that we need some more samples
+    USHORT nMinStretchX=65535, nMinStretchY=65535;
+    const Size aShapeSize = GetLastBoundRect().GetSize();
+    for(int i=0; i<3; ++i)
+    {
+        const Size aCurrTextSize = rOutliner.CalcTextSize();
+        const double fFactor( 
+            double(aShapeSize.Height())/
+            (aCurrTextSize.Height()+GetTextUpperDistance()+GetTextLowerDistance()));
+
+        USHORT nCurrStretchX, nCurrStretchY;
+        rOutliner.GetGlobalCharStretching(nCurrStretchX, nCurrStretchY);
+
+        // only do the scaling once (we'll get notified again, recursively)
+        if (fFactor < 1.0 || (fFactor >= 1.0 && nCurrStretchX != 100))
+        {
+            nCurrStretchX = sal::static_int_cast<USHORT>(nCurrStretchX*fFactor);
+            nCurrStretchY = sal::static_int_cast<USHORT>(nCurrStretchY*fFactor);
+            rOutliner.SetGlobalCharStretching(std::min(USHORT(100),nCurrStretchX),
+                                              std::min(USHORT(100),nCurrStretchY));
+            OSL_TRACE("SdrTextObj::onEditOutlinerStatusEvent(): zoom is %d", nCurrStretchX);
+
+            nMinStretchX = std::min(nMinStretchX,nCurrStretchX);
+            nMinStretchY = std::min(nMinStretchY,nCurrStretchY);
+        }
+    }
+
+    rOutliner.SetGlobalCharStretching(std::min(USHORT(100),nMinStretchX),
+                                      std::min(USHORT(100),nMinStretchY));
+}
+
 void SdrTextObj::SetupOutlinerFormatting( SdrOutliner& rOutl, Rectangle& rPaintRect ) const
 {
     ImpInitDrawOutliner( rOutl );
@@ -2397,6 +2434,17 @@ sal_Bool SdrTextObj::IsTextAnimationAllowed() const
 	return mbTextAnimationAllowed;
 }
 
+FASTBOOL SdrTextObj::IsAutoFit() const
+{
+    return GetFitToSize()==SDRTEXTFIT_AUTOFIT;
+}
+
+FASTBOOL SdrTextObj::IsFitToSize() const
+{
+    const SdrFitToSizeType eFit=GetFitToSize();
+    return (eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+}
+
 void SdrTextObj::SetTextAnimationAllowed(sal_Bool bNew)
 {
 	if(mbTextAnimationAllowed != bNew)
@@ -2414,13 +2462,21 @@ void SdrTextObj::onEditOutlinerStatusEvent( EditStatus* pEditStatus )
 	const bool bGrowY=(nStat & EE_STAT_TEXTHEIGHTCHANGED) !=0;
     if(bTextFrame && (bGrowX || bGrowY))
 	{
-		const bool bAutoGrowHgt= bTextFrame && IsAutoGrowHeight();
-		const bool bAutoGrowWdt= bTextFrame && IsAutoGrowWidth();
-
-	    if ((bGrowX && bAutoGrowWdt) || (bGrowY && bAutoGrowHgt))
+	    if ((bGrowX && IsAutoGrowWidth()) || (bGrowY && IsAutoGrowHeight()))
 		{
 			AdjustTextFrameWidthAndHeight();
 		}
+        else if (IsAutoFit() && !mbInDownScale)
+        {
+            OSL_ASSERT(pEdtOutl);
+            mbInDownScale = sal_True;
+
+            // sucks that we cannot disable paints via
+            // pEdtOutl->SetUpdateMode(FALSE) - but EditEngine skips
+            // formatting as well, then.
+            ImpAutoFitText(*pEdtOutl);
+            mbInDownScale = sal_False;
+        }
 	}
 }
 
diff --git a/svx/source/svdraw/svdotxat.cxx b/svx/source/svdraw/svdotxat.cxx
index 4d6ec63..15eb01b 100644
--- svx/source/svdraw/svdotxat.cxx
+++ svx/source/svdraw/svdotxat.cxx
@@ -82,8 +82,7 @@ FASTBOOL SdrTextObj::AdjustTextFrameWidthAndHeight(Rectangle& rR, FASTBOOL bHgt,
 {
 	if (bTextFrame && pModel!=NULL && !rR.IsEmpty())
 	{
-		SdrFitToSizeType eFit=GetFitToSize();
-		FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+        FASTBOOL bFitToSize(IsFitToSize());
 		FASTBOOL bWdtGrow=bWdt && IsAutoGrowWidth();
 		FASTBOOL bHgtGrow=bHgt && IsAutoGrowHeight();
 		SdrTextAniKind eAniKind=GetTextAniKind();
diff --git a/svx/source/svdraw/svdotxed.cxx b/svx/source/svdraw/svdotxed.cxx
index 7838d97..265283b 100644
--- svx/source/svdraw/svdotxed.cxx
+++ svx/source/svdraw/svdotxed.cxx
@@ -75,15 +75,17 @@ sal_Bool SdrTextObj::BegTextEdit(SdrOutliner& rOutl)
 	rOutl.Init( nOutlinerMode );
 	rOutl.SetRefDevice( pModel->GetRefDevice() );
 
-	SdrFitToSizeType eFit=GetFitToSize();
-	FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+    FASTBOOL bFitToSize(IsFitToSize());
 	FASTBOOL bContourFrame=IsContourTextFrame();
 	ImpSetTextEditParams();
 
 	if (!bContourFrame) {
 		ULONG nStat=rOutl.GetControlWord();
 		nStat|=EE_CNTRL_AUTOPAGESIZE;
-		if (bFitToSize) nStat|=EE_CNTRL_STRETCHING; else nStat&=~EE_CNTRL_STRETCHING;
+		if (bFitToSize || IsAutoFit()) 
+            nStat|=EE_CNTRL_STRETCHING; 
+        else 
+            nStat&=~EE_CNTRL_STRETCHING;
 		rOutl.SetControlWord(nStat);
 	}
 
@@ -119,8 +121,12 @@ sal_Bool SdrTextObj::BegTextEdit(SdrOutliner& rOutl)
 		TakeTextRect(rOutl, aTextRect, FALSE, 
 			&aAnchorRect/* #97097# give TRUE here, not FALSE */);
 		Fraction aFitXKorreg(1,1);
-		ImpSetCharStretching(rOutl,aTextRect,aAnchorRect,aFitXKorreg);
+		ImpSetCharStretching(rOutl,aTextRect.GetSize(),aAnchorRect.GetSize(),aFitXKorreg);
 	}
+    else if (IsAutoFit())
+    {
+        ImpAutoFitText(rOutl);
+    }
 
 	if(pOutlinerParaObject)
 	{
@@ -146,8 +152,7 @@ sal_Bool SdrTextObj::BegTextEdit(SdrOutliner& rOutl)
 
 void SdrTextObj::TakeTextEditArea(Size* pPaperMin, Size* pPaperMax, Rectangle* pViewInit, Rectangle* pViewMin) const
 {
-	SdrFitToSizeType eFit=GetFitToSize();
-	FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+    FASTBOOL bFitToSize(IsFitToSize());
 	Size aPaperMin,aPaperMax;
 	Rectangle aViewInit;
 	TakeTextAnchorRect(aViewInit);
diff --git a/svx/source/svdraw/svdotxtr.cxx b/svx/source/svdraw/svdotxtr.cxx
index 7b6d5d5..df448f3 100644
--- svx/source/svdraw/svdotxtr.cxx
+++ svx/source/svdraw/svdotxtr.cxx
@@ -85,9 +85,6 @@ void SdrTextObj::NbcSetSnapRect(const Rectangle& rRect)
 		if (bTextFrame && (pModel==NULL || !pModel->IsPasteResize())) { // #51139#
 			if (nTWdt0!=nTWdt1 && IsAutoGrowWidth() ) NbcSetMinTextFrameWidth(nTWdt1);
 			if (nTHgt0!=nTHgt1 && IsAutoGrowHeight()) NbcSetMinTextFrameHeight(nTHgt1);
-			if (GetFitToSize()==SDRTEXTFIT_RESIZEATTR) {
-				NbcResizeTextAttributes(Fraction(nTWdt1,nTWdt0),Fraction(nTHgt1,nTHgt0));
-			}
 			NbcAdjustTextFrameWidthAndHeight();
 		}
 		ImpCheckShear();
@@ -113,9 +110,6 @@ void SdrTextObj::NbcSetLogicRect(const Rectangle& rRect)
 	if (bTextFrame) {
 		if (nTWdt0!=nTWdt1 && IsAutoGrowWidth() ) NbcSetMinTextFrameWidth(nTWdt1);
 		if (nTHgt0!=nTHgt1 && IsAutoGrowHeight()) NbcSetMinTextFrameHeight(nTHgt1);
-		if (GetFitToSize()==SDRTEXTFIT_RESIZEATTR) {
-			NbcResizeTextAttributes(Fraction(nTWdt1,nTWdt0),Fraction(nTHgt1,nTHgt0));
-		}
 		NbcAdjustTextFrameWidthAndHeight();
 	}
 	SetRectsDirty();
@@ -229,9 +223,6 @@ void SdrTextObj::NbcResize(const Point& rRef, const Fraction& xFact, const Fract
 	if (bTextFrame && (pModel==NULL || !pModel->IsPasteResize())) { // #51139#
 		if (nTWdt0!=nTWdt1 && IsAutoGrowWidth() ) NbcSetMinTextFrameWidth(nTWdt1);
 		if (nTHgt0!=nTHgt1 && IsAutoGrowHeight()) NbcSetMinTextFrameHeight(nTHgt1);
-		if (GetFitToSize()==SDRTEXTFIT_RESIZEATTR) {
-			NbcResizeTextAttributes(Fraction(nTWdt1,nTWdt0),Fraction(nTHgt1,nTHgt0));
-		}
 		NbcAdjustTextFrameWidthAndHeight();
 	}
 	ImpCheckShear();
diff --git a/svx/source/svdraw/svdtxhdl.cxx b/svx/source/svdraw/svdtxhdl.cxx
index 69aeaa4..d1e526f 100644
--- svx/source/svdraw/svdtxhdl.cxx
+++ svx/source/svdraw/svdtxhdl.cxx
@@ -90,8 +90,7 @@ void ImpTextPortionHandler::ConvertToPathObj(SdrObjGroup& rGroup, FASTBOOL bPoly
 
 	Rectangle aAnchorRect;
 	Rectangle aTextRect;
-	SdrFitToSizeType eFit=rTextObj.GetFitToSize();
-	FASTBOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+    FASTBOOL bFitToSize(rTextObj.IsFitToSize());
 	// Bei TakeTextRect wird u.a. auch der Text in
 	// den Outliner gesteckt
 	rTextObj.TakeTextRect(rOutliner,aTextRect,FALSE,&aAnchorRect);
diff --git a/svx/source/svdraw/svdview.cxx b/svx/source/svdraw/svdview.cxx
index f1b2a6d..e353e58 100644
--- svx/source/svdraw/svdview.cxx
+++ svx/source/svdraw/svdview.cxx
@@ -504,8 +504,7 @@ SdrHitKind SdrView::PickAnything(const Point& rLogicPos, SdrViewEvent& rVEvt) co
 				Point aTemporaryTextRelativePosition(aLocalLogicPosition - aTextRect.TopLeft());
 				
 				// FitToSize berueksichtigen
-				SdrFitToSizeType eFit=pTextObj->GetFitToSize();
-				BOOL bFitToSize=(eFit==SDRTEXTFIT_PROPORTIONAL || eFit==SDRTEXTFIT_ALLLINES);
+                BOOL bFitToSize(pTextObj->IsFitToSize());
 				if (bFitToSize) {
 					Fraction aX(aTextRect.GetWidth()-1,aAnchor.GetWidth()-1);
 					Fraction aY(aTextRect.GetHeight()-1,aAnchor.GetHeight()-1);
