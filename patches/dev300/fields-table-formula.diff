diff --git ixion/makefile.mk ixion/makefile.mk
new file mode 100644
index 0000000..c847995
--- /dev/null
+++ ixion/makefile.mk
@@ -0,0 +1,59 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# Copyright 2000, 2010 Oracle and/or its affiliates.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=.
+
+PRJNAME=ixion
+TARGET=ixion
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :	settings.mk
+
+# --- Files --------------------------------------------------------
+
+TARFILE_NAME=ixion-0.2.0
+TARFILE_MD5=0f63ee487fda8f21fafa767b3c447ac9
+#PATCH_FILES=$(TARFILE_NAME).diff
+.IF "$(GUI)" != "UNX"
+BUILD_ACTION=dmake $(MFLAGS) $(CALLMACROS)
+BUILD_DIR=src$/libixion
+.ELSE
+CONFIGURE_DIR=
+CONFIGURE_ACTION=.$/configure
+CONFIGURE_FLAGS=--disable-shared --with-pic
+BUILD_ACTION=$(GNUMAKE)
+BUILD_DIR=$(CONFIGURE_DIR)
+OUT2LIB+=src/libixion/.libs$/libixion*.a
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : set_ext.mk
+.INCLUDE :	target.mk
+.INCLUDE :	tg_ext.mk
+
diff --git ixion/prj/build.lst ixion/prj/build.lst
new file mode 100644
index 0000000..0ac7093
--- /dev/null
+++ ixion/prj/build.lst
@@ -0,0 +1,3 @@
+ix  ixion :	solenv external NULL
+ix	ixion		usr1	-	all	ix_mkout NULL
+ix	ixion		nmake	-	all	ix_ixion	NULL
diff --git ixion/prj/d.lst ixion/prj/d.lst
new file mode 100644
index 0000000..2dbc5aa
--- /dev/null
+++ ixion/prj/d.lst
@@ -0,0 +1,4 @@
+mkdir: %_DEST%\inc%_EXT%\libwpd
+..\%__SRC%\misc\build\ixion*\inc\*.hpp %_DEST%\inc%_EXT%\ixion\
+..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
+..\%__SRC%\slb\*.lib %_DEST%\lib%_EXT%\*.lib
diff --git offapi/com/sun/star/text/XCell2.idl offapi/com/sun/star/text/XCell2.idl
new file mode 100644
index 0000000..a26625d
--- /dev/null
+++ offapi/com/sun/star/text/XCell2.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_text_XCell2_idl__
+#define __com_sun_star_text_XCell2_idl__
+
+#ifndef __com_sun_star_table_XCell_idl__
+#include <com/sun/star/table/XCell.idl>
+#endif
+
+//=============================================================================
+
+module com {  module sun {  module star {  module text {
+
+//=============================================================================
+
+/** provides methods to access the contents of a cell in a text table.
+ */
+interface XCell2: com::sun::star::table::XCell
+{
+    //-------------------------------------------------------------------------
+
+    /** returns true if the cell formula is in the WW format.
+     */
+    boolean isWWFormula();
+
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
diff --git offapi/com/sun/star/text/makefile.mk offapi/com/sun/star/text/makefile.mk
index 4e6d247..67c924b 100644
--- offapi/com/sun/star/text/makefile.mk
+++ offapi/com/sun/star/text/makefile.mk
@@ -203,6 +203,7 @@ IDLFILES=\
       XAutoTextGroup.idl\
       XBookmarkInsertTool.idl\
       XBookmarksSupplier.idl\
+	  XCell2.idl\
       XChapterNumberingSupplier.idl\
       XDefaultNumberingProvider.idl\
       XDependentTextField.idl\
diff --git solenv/inc/libs.mk solenv/inc/libs.mk
index 7e355b2..150c236 100644
--- solenv/inc/libs.mk
+++ solenv/inc/libs.mk
@@ -297,6 +297,17 @@ REDLANDLIB=-lrdf
 .ENDIF
 
 
+.IF "$(GUI)" != "UNX"
+IXIONLIB=-lixionlib
+.ELSE
+IXIONLIB=-lixion-0.2
+.ENDIF
+.IF "$(SYSTEM_BOOST)" == "YES"
+IXIONLIB+= $(BOOST_THREAD_LIBS)
+.ELSE
+IXIONLIB+= -lboost_thread-mt -pthread
+.ENDIF
+
 # #110743#
 # For BinFilters, some libs were added.
 #
@@ -510,6 +510,8 @@
 .ELSE
 REDLANDLIB = librdf.lib
 .ENDIF
+
+IXIONLIB = ixionlib.lib
 
 JVMFWKLIB = ijvmfwk.lib
 
diff --git sw/inc/cellatr.hxx sw/inc/cellatr.hxx
index 7fe6cc5..9a71f8b 100644
--- sw/inc/cellatr.hxx
+++ sw/inc/cellatr.hxx
@@ -56,13 +56,13 @@ public:
     void SetAutoFlag( BOOL bFlag = TRUE )		{ bAuto = bFlag; }
 };
 
-class SwTblBoxFormula : public SfxPoolItem, public SwTableFormula
+class SW_DLLPUBLIC SwTblBoxFormula : public SfxPoolItem, public SwTableFormula
 {
     SwModify* pDefinedIn;	// Modify-Object, in dem die Formel steht
                             // kann nur TablenBoxFormat sein
 
 public:
-    SwTblBoxFormula( const String& rFormula );
+    SwTblBoxFormula( const String& rFormula, bool bWwFormula = false );
 
     // "pure virtual Methoden" vom SfxPoolItem
     virtual int             operator==( const SfxPoolItem& ) const;
diff --git sw/inc/cellfml.hxx sw/inc/cellfml.hxx
index 7579256..7ff70f2 100644
--- sw/inc/cellfml.hxx
+++ sw/inc/cellfml.hxx
@@ -28,6 +28,7 @@
 #ifndef _CELLFML_HXX
 #define _CELLFML_HXX
 
+#include "swdllapi.h"
 #include <tools/string.hxx>
 
 class SwTable;
@@ -62,7 +63,7 @@ public:
 
 
 
-class SwTableFormula
+class SW_DLLPUBLIC SwTableFormula
 {
 typedef void (SwTableFormula:: *FnScanFormel)( const SwTable&, String&,
                                             String&, String*, void* ) const;
@@ -92,13 +92,16 @@ typedef void (SwTableFormula:: *FnScanFormel)( const SwTable&, String&,
                         void* = 0 ) const;
 
     const SwTable* FindTable( SwDoc& rDoc, const String& rNm ) const;
+    
+    bool        bWwFormula;
+    String 		sInputFormula;
+    String 		sSwFormula;            // Internal formula
 
 protected:
     enum NameType { EXTRNL_NAME, INTRNL_NAME, REL_NAME };
 
-    String 		sFormel;			// akt. Formel
     NameType 	eNmType;			// akt. Darstellungs Art
-    bool               bValidValue;            // TRUE: Formel neu berechnen
+    BOOL 		bValidValue;		// TRUE: Formel neu berechnen
 
     // suche den Node, in dem die Formel steht:
     //	TextFeld	-> TextNode,
@@ -106,7 +110,7 @@ protected:
     // !!! MUSS VON JEDER ABLEITUNG UEBERLADEN WERDEN !!!
     virtual const SwNode* GetNodeOfFormula() const = 0;
 
-    SwTableFormula( const String& rFormel );
+    SwTableFormula( const String& rFormel, bool bWwFml = false );
 
     String MakeFormel( SwTblCalcPara& rCalcPara ) const
     {
@@ -122,9 +126,10 @@ public:
     virtual ~SwTableFormula();
     SwTableFormula& operator=( const SwTableFormula& rCpy )
         {
-                                    sFormel = rCpy.sFormel;
+                                    SetFormula( rCpy.GetFormula() );
                                     eNmType = rCpy.eNmType;
                                     bValidValue = rCpy.bValidValue;
+                                    bWwFormula = rCpy.bWwFormula;
                                     return *this;
         }
 
@@ -143,16 +143,13 @@ public:
     NameType GetNameType() const		{ return eNmType; }
 
     // erfrage/setze das Flag, ob der akt. Wert gueltig ist
-    bool               IsValid() const                         { return bValidValue; }
-    inline void        ChgValid( bool bNew )           { bValidValue = bNew; }
+    BOOL 		IsValid() const			{ return bValidValue; }
+    inline void	ChgValid( BOOL bNew )   { bValidValue = bNew; }
 
-    const String& GetFormula() const 		{ return sFormel; }
-    void SetFormula( const String& rNew )
-        {
-            sFormel = rNew;
-            bValidValue = false;
-            eNmType = EXTRNL_NAME;
-        }
+    const String& GetFormula() const { return sInputFormula; }
+    void SetFormula( const String& rNew );
+
+    bool IsWWFormula( ) const { return bWwFormula; }
 
     USHORT GetBoxesOfFormula( const SwTable& rTbl, SwSelBoxes& rBoxes );
     // sind alle Boxen gueltig, auf die sich die Formel bezieht?
diff --git sw/inc/unotbl.hxx sw/inc/unotbl.hxx
index 7aa83d8..acbaeba 100644
--- sw/inc/unotbl.hxx
+++ sw/inc/unotbl.hxx
@@ -35,6 +35,7 @@
 #include <com/sun/star/chart2/data/XLabeledDataSequence.hpp>
 #include <com/sun/star/text/XTextTableCursor.hpp>
 #include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/XCell2.hpp>
 #include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/sheet/XCellRangeData.hpp>
 #include <com/sun/star/table/XAutoFormattable.hpp>
@@ -80,7 +81,7 @@ class SwChartEventListenerContainer : public SwEventListenerContainer
 typedef
 cppu::WeakImplHelper4
 <
-    ::com::sun::star::table::XCell,
+    ::com::sun::star::text::XCell2,
     ::com::sun::star::lang::XServiceInfo,
     ::com::sun::star::beans::XPropertySet,
     ::com::sun::star::container::XEnumerationAccess
@@ -142,7 +143,10 @@ public:
     virtual void SAL_CALL setValue( double nValue ) throw(::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::table::CellContentType SAL_CALL getType(  ) throw(::com::sun::star::uno::RuntimeException);
     virtual sal_Int32 SAL_CALL getError(  ) throw(::com::sun::star::uno::RuntimeException);
-
+    
+    //XCell2
+    virtual sal_Bool SAL_CALL isWWFormula(  ) throw(::com::sun::star::uno::RuntimeException);
+    
     //XText
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextCursor >  SAL_CALL createTextCursor(void) throw( ::com::sun::star::uno::RuntimeException );
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextCursor >  SAL_CALL createTextCursorByRange(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & aTextPosition) throw( ::com::sun::star::uno::RuntimeException );
diff --git sw/prj/build.lst sw/prj/build.lst
index 64894fd..d79986c 100755
--- sw/prj/build.lst
+++ sw/prj/build.lst
@@ -1,4 +1,4 @@
-sw      sw      :    filter l10n connectivity OOo:writerperfect OOo:lotuswordpro vbahelper svx stoc writerfilter NULL
+sw      sw      :    filter l10n connectivity OOo:writerperfect OOo:lotuswordpro vbahelper svx stoc writerfilter ixion NULL
 sw	sw										usr1	-	all	sw_mkout NULL
 sw	sw\inc									nmake		-	all	sw_inc NULL
 sw	sw\uiconfig\layout									nmake	-	all	sw_layout NULL
diff --git sw/source/core/attr/cellatr.cxx sw/source/core/attr/cellatr.cxx
index 7285d15..0ec204d 100644
--- sw/source/core/attr/cellatr.cxx
+++ sw/source/core/attr/cellatr.cxx
@@ -76,9 +76,9 @@ SfxPoolItem* SwTblBoxNumFormat::Clone( SfxItemPool* ) const
 
 
 
-SwTblBoxFormula::SwTblBoxFormula( const String& rFormula )
+SwTblBoxFormula::SwTblBoxFormula( const String& rFormula, bool bWwFml )
     : SfxPoolItem( RES_BOXATR_FORMULA ),
-    SwTableFormula( rFormula ),
+    SwTableFormula( rFormula, bWwFml ),
     pDefinedIn( 0 )
 {
 }
@@ -95,7 +95,7 @@ int SwTblBoxFormula::operator==( const SfxPoolItem& rAttr ) const
 SfxPoolItem* SwTblBoxFormula::Clone( SfxItemPool* ) const
 {
 // auf externe Darstellung umschalten!!
-    SwTblBoxFormula* pNew = new SwTblBoxFormula( GetFormula() );
+    SwTblBoxFormula* pNew = new SwTblBoxFormula( GetFormula(), IsWWFormula() );
     pNew->SwTableFormula::operator=( *this );
     return pNew;
 }
diff --git sw/source/core/fields/cellfml.cxx sw/source/core/fields/cellfml.cxx
index fb98a31..4227bb3 100644
--- sw/source/core/fields/cellfml.cxx
+++ sw/source/core/fields/cellfml.cxx
@@ -51,6 +51,14 @@
 #include <cellatr.hxx>
 #include <ndindex.hxx>
 
+#include <sstream>
+#include <string>
+
+#include <ixion/cell.hpp>
+#include <ixion/formula_functions.hpp>
+#include <ixion/formula_lexer.hpp>
+#include <ixion/formula_parser.hpp>
+
 const sal_Unicode cRelTrenner = ',';
 const sal_Unicode cRelKennung = '';		// CTRL-R
 
@@ -307,11 +315,10 @@ BOOL SwTblCalcPara::CalcWithStackOverflow()
 
 /*  */
 
-SwTableFormula::SwTableFormula( const String& rFormel )
-    : sFormel( rFormel )
+SwTableFormula::SwTableFormula( const String& rFormel, bool bWwFml )
+    : bWwFormula( bWwFml )
 {
-    eNmType = EXTRNL_NAME;
-    bValidValue = false;
+    SetFormula( rFormel );
 }
 
 SwTableFormula::~SwTableFormula()
@@ -555,7 +562,7 @@ void SwTableFormula::PtrToBoxNm( const SwTable* pTbl )
     case EXTRNL_NAME:
         return;
     }
-    sFormel = ScanString( fnFormel, *pTbl, (void*)pNd );
+    sSwFormula = ScanString( fnFormel, *pTbl, (void*)pNd );
     eNmType = EXTRNL_NAME;
 }
 
@@ -580,7 +587,7 @@ void SwTableFormula::BoxNmToPtr( const SwTable* pTbl )
     case INTRNL_NAME:
         return;
     }
-    sFormel = ScanString( fnFormel, *pTbl, (void*)pNd );
+    sSwFormula = ScanString( fnFormel, *pTbl, (void*)pNd );
     eNmType = INTRNL_NAME;
 }
 
@@ -602,11 +609,138 @@ void SwTableFormula::ToRelBoxNm( const SwTable* pTbl )
     case REL_NAME:
         return;
     }
-    sFormel = ScanString( fnFormel, *pTbl, (void*)pNd );
+    sSwFormula = ScanString( fnFormel, *pTbl, (void*)pNd );
     eNmType = REL_NAME;
 }
 
 
+class token_converter : public std::unary_function<ixion::formula_token_base, void>
+{
+public:
+    token_converter(std::ostringstream& os) : m_os(os), m_in_and_or(false) {}
+
+    void operator() (const ixion::formula_token_base& token)
+    {
+        switch (token.get_opcode())
+        {
+            case ixion::fop_unresolved_ref:
+                // Add <> around the name
+                m_os << "<" << token.get_name() << ">";
+                break;
+            case ixion::fop_sep:
+                if ( m_in_and_or )
+                {
+                    m_os << m_pending_func_name;
+                    m_in_and_or = false;
+                    m_pending_func_name = std::string();
+                }
+                else
+                    m_os << "|";
+                break;
+            case ixion::fop_function:
+                {
+                    ixion::formula_function_t func_oc = ixion::formula_functions::get_function_opcode(token);
+                    std::string func_name( ixion::formula_functions::get_function_name(func_oc) );
+
+                    m_in_and_or = false;
+
+                    if ( func_name.compare( "AVERAGE" ) == 0 )
+                    {
+                        m_os << "MEAN";
+                    }
+                    else if ( ( func_name.compare( "AND" ) == 0 ) ||
+                            ( func_name.compare( "OR" ) == 0 ) )
+                    {
+                        //   AND(x, y) -> x AND y
+                        //   OR(x, y)  -> x OR y
+                        m_in_and_or = true;
+                        m_pending_func_name = func_name;
+                    } 
+                    else
+                    {
+                        m_os << func_name;
+                    }
+                }
+                break;
+            case ixion::fop_value:
+                m_os << token.get_value();
+                break;
+            case ixion::fop_plus:
+                m_os << "+";
+                break;
+            case ixion::fop_minus:
+                m_os << "-";
+                break;
+            case ixion::fop_multiply:
+                m_os << "*";
+                break;
+            case ixion::fop_divide:
+                m_os << "/";
+                break;
+            case ixion::fop_open:
+                m_os << "(";
+                break;
+            case ixion::fop_close:
+                m_os << ")";
+                break;
+            default:
+                ;
+        }
+    }
+
+private:
+    std::ostringstream& m_os;
+
+    bool m_in_and_or;
+    std::string m_pending_func_name;
+};
+
+String lcl_ConvertWWFormula( const String& rWWFormula )
+{
+    ixion::mem_str_buf sFormulaBuf;
+    ByteString sAsciiFormula( rWWFormula, RTL_TEXTENCODING_UTF8 );
+    sFormulaBuf.set_start( sAsciiFormula.ToUpperAscii().GetBufferAccess() );
+    for ( int i = 0; i < rWWFormula.Len() - 1; i++ )
+        sFormulaBuf.inc();
+
+    ixion::lexer_tokens_t ltokens;
+
+    // Run the lexer
+    ixion::formula_lexer lexer( sFormulaBuf );
+    lexer.tokenize( );
+    lexer.swap_tokens( ltokens );
+
+    // Run the parser
+    ixion::cell_name_ptr_map_t cell_names;
+
+    ixion::formula_parser parser( ltokens, &cell_names, true );
+    parser.parse();
+
+    ixion::formula_tokens_t ftokens;
+    ftokens.swap( parser.get_tokens() );
+
+    // Convert the tokens to Writer formula string
+    std::ostringstream os;
+    for_each( ftokens.begin(), ftokens.end(), token_converter(os) );
+
+    return String::CreateFromAscii( os.str().c_str() );
+}
+
+void SwTableFormula::SetFormula( const String& rNew )
+{
+    sInputFormula = rNew;
+    sSwFormula = rNew;
+
+    bValidValue = FALSE;
+    eNmType = EXTRNL_NAME;
+    
+    if ( bWwFormula )
+    {
+        // Convert the sInputFormula into a Sw formula and store it in sSwFormula
+        sSwFormula = lcl_ConvertWWFormula( sInputFormula );
+    }
+}
+
 String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
                                     void* pPara ) const
 {
@@ -618,24 +752,24 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
         // benutzen !!
         const SwTable* pTbl = &rTbl;
 
-        nStt = sFormel.Search( '<', nFml );
+        nStt = sSwFormula.Search( '<', nFml );
         if( STRING_NOTFOUND != nStt )
         {
             while( STRING_NOTFOUND != nStt &&
-                ( ' ' == sFormel.GetChar( nStt + 1 ) ||
-                  '=' == sFormel.GetChar( nStt + 1 ) ) )
-                nStt = sFormel.Search( '<', nStt + 1 );
+                ( ' ' == sSwFormula.GetChar( nStt + 1 ) ||
+                  '=' == sSwFormula.GetChar( nStt + 1 ) ) )
+                nStt = sSwFormula.Search( '<', nStt + 1 );
 
             if( STRING_NOTFOUND != nStt )
-                nEnd = sFormel.Search( '>', nStt+1 );
+                nEnd = sSwFormula.Search( '>', nStt+1 );
         }
         if( STRING_NOTFOUND == nStt || STRING_NOTFOUND == nEnd )
         {
             // den Rest setzen und beenden
-            aStr.Insert( sFormel, nFml, sFormel.Len() - nFml );
+            aStr.Insert( sSwFormula, nFml, sSwFormula.Len() - nFml );
             break;
         }
-        aStr.Insert( sFormel, nFml, nStt - nFml );	// Anfang schreiben
+        aStr.Insert( sSwFormula, nFml, nStt - nFml );	// Anfang schreiben
 
         if( fnFormel != NULL )
         {
@@ -644,11 +778,11 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
             // JP 22.02.99: der CAST muss fuer den Linux-Compiler sein
             // JP 28.06.99: rel. BoxName have no preceding tablename!
             if( fnFormel != (FnScanFormel)&SwTableFormula::_SplitMergeBoxNm &&
-                1 < sFormel.Len() && cRelKennung != sFormel.GetChar( 1 ) &&
-                STRING_NOTFOUND != ( nTrenner = sFormel.Search( '.', nStt ))
+                1 < sSwFormula.Len() && cRelKennung != sSwFormula.GetChar( 1 ) &&
+                STRING_NOTFOUND != ( nTrenner = sSwFormula.Search( '.', nStt ))
                 && nTrenner < nEnd )
             {
-                String sTblNm( sFormel.Copy( nStt, nEnd - nStt ));
+                String sTblNm( sSwFormula.Copy( nStt, nEnd - nStt ));
 
                 // falls im Namen schon die Punkte enthalten sind,
                 // treten diese immer paarig auf!!! (A1.1.1 !!)
@@ -677,13 +811,13 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
                 }
             }
 
-            String sBox( sFormel.Copy( nStt, nEnd - nStt + 1 ));
+            String sBox( sSwFormula.Copy( nStt, nEnd - nStt + 1 ));
             // ein Bereich in dieser Klammer ?
-            if( STRING_NOTFOUND != ( nTrenner = sFormel.Search( ':', nStt ))
+            if( STRING_NOTFOUND != ( nTrenner = sSwFormula.Search( ':', nStt ))
                 && nTrenner < nEnd )
             {
                 // ohne die Anfangsklammer
-                String aFirstBox( sFormel.Copy( nStt+1, nTrenner - nStt - 1 ));
+                String aFirstBox( sSwFormula.Copy( nStt+1, nTrenner - nStt - 1 ));
                 (this->*fnFormel)( *pTbl, aStr, sBox, &aFirstBox, pPara );
             }
             else
@@ -692,6 +826,7 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
 
         nFml = nEnd+1;
     } while( TRUE );
+
     return aStr;
 }
 
@@ -1225,7 +1360,7 @@ void SwTableFormula::ToSplitMergeBoxNm( SwTableFmlUpdate& rTblUpd )
     else
         pTbl = rTblUpd.pTbl;
 
-    sFormel = ScanString( &SwTableFormula::_SplitMergeBoxNm, *pTbl, (void*)&rTblUpd );
+    sSwFormula = ScanString( &SwTableFormula::_SplitMergeBoxNm, *pTbl, (void*)&rTblUpd );
     eNmType = INTRNL_NAME;
 }
 
diff --git sw/source/core/fields/makefile.mk sw/source/core/fields/makefile.mk
index 280fff6..f8cd35e 100644
--- sw/source/core/fields/makefile.mk
+++ sw/source/core/fields/makefile.mk
@@ -86,7 +86,8 @@ SLOFILES =	\
 EXCEPTIONSFILES = \
         $(SLO)$/flddropdown.obj \
         $(SLO)$/postithelper.obj \
-        $(SLO)$/docufld.obj 
+        $(SLO)$/docufld.obj \
+        $(SLO)$/cellfml.obj
 
 # --- Tagets -------------------------------------------------------
 
diff --git sw/source/core/unocore/unotbl.cxx sw/source/core/unocore/unotbl.cxx
index 9dd21a4..5abce43 100644
--- sw/source/core/unocore/unotbl.cxx
+++ sw/source/core/unocore/unotbl.cxx
@@ -1063,6 +1063,19 @@ sal_Int32 SwXCell::getError(void) throw( uno::RuntimeException )
     OUString sContent = getString();
     return sContent.equals(ViewShell::GetShellRes()->aCalc_Error);
 }
+
+sal_Bool SwXCell::isWWFormula(  ) throw( uno::RuntimeException )
+{
+    SolarMutexGuard aGuard;
+    sal_Bool sRet = sal_False;
+    if(IsValid())
+    {
+        SwTblBoxFormula aFormula( pBox->GetFrmFmt()->GetTblBoxFormula() );
+        sRet = aFormula.IsWWFormula( );
+    }
+    return sRet;
+}
+
 
 uno::Reference< text::XTextCursor >  SwXCell::createTextCursor(void) throw( uno::RuntimeException )
 {
diff --git sw/source/filter/ww8/wrtw8nds.cxx sw/source/filter/ww8/wrtw8nds.cxx
index 3191b6b..0095089 100644
--- sw/source/filter/ww8/wrtw8nds.cxx
+++ sw/source/filter/ww8/wrtw8nds.cxx
@@ -104,6 +104,7 @@
 #include "ww8par.hxx"
 #include <IMark.hxx>
 #include "ww8attributeoutput.hxx"
+#include "cellatr.hxx"
 
 #include <ndgrf.hxx>
 #include <ndole.hxx>
@@ -1812,6 +1813,22 @@ void MSWordExportBase::OutputTextNode( const SwTxtNode& rNode )
         bool bTxtAtr = aAttrIter.IsTxtAttr( nAktPos );
         nOpenAttrWithRange += aAttrIter.OutAttrWithRange(nAktPos);
 
+        bool bOutTableFormula = false;
+
+        // Check if a formula is defined on the cell
+        if ( pTextNodeInfo.get() != NULL )
+        {
+            const SwTableBox* pBox = pTextNodeInfo.get()->getTableBox( );
+            const SwTblBoxFormula& rFml = pBox->GetFrmFmt()->GetTblBoxFormula();
+            bOutTableFormula = ( rFml.GetFormula().Len( ) > 0 );
+            if ( bOutTableFormula )
+            {
+                String sFormula = String::CreateFromAscii( "=" ).Append( rFml.GetFormula( ) );
+                OutputField( NULL, ww::eEquals, sFormula, WRITEFIELD_START | WRITEFIELD_CMD_START );  
+                OutputField( NULL, ww::eEquals, String(), WRITEFIELD_CMD_END );  
+            }
+        }
+
         xub_StrLen nLen = nNextAttr - nAktPos;
         if ( !bTxtAtr && nLen )
         {
@@ -1925,6 +1942,9 @@ void MSWordExportBase::OutputTextNode( const SwTxtNode& rNode )
             }
             AttrOutput().RunText( aSnippet, eChrSet );
         }
+            
+        if ( bOutTableFormula )
+            OutputField( NULL, ww::eEquals, String(), WRITEFIELD_CLOSE );  
 
         if ( aAttrIter.IsDropCap( nNextAttr ) )
             AttrOutput().FormatDrop( rNode, aAttrIter.GetSwFmtDrop(), nStyle, pTextNodeInfo, pTextNodeInfoInner );
diff --git sw/source/filter/ww8/ww8par.hxx sw/source/filter/ww8/ww8par.hxx
index 6cddc25..f2483b2 100644
--- sw/source/filter/ww8/ww8par.hxx
+++ sw/source/filter/ww8/ww8par.hxx
@@ -1559,6 +1559,7 @@ public:     // eigentlich private, geht aber leider nur public
     eF_ResT Read_F_FileName( WW8FieldDesc*, String& rStr);
     eF_ResT Read_F_Anz( WW8FieldDesc* pF, String& );
     eF_ResT Read_F_CurPage( WW8FieldDesc*, String& );
+    eF_ResT Read_F_Formula( WW8FieldDesc*, String& );
     eF_ResT Read_F_Ref( WW8FieldDesc* pF, String& );
 
     eF_ResT Read_F_Set( WW8FieldDesc*, String& rStr );
diff --git sw/source/filter/ww8/ww8par2.cxx sw/source/filter/ww8/ww8par2.cxx
index 5207ef6..f8ee2a0 100644
--- sw/source/filter/ww8/ww8par2.cxx
+++ sw/source/filter/ww8/ww8par2.cxx
@@ -66,6 +66,7 @@
 #include <fltshell.hxx>         // fuer den Attribut Stack
 #include <fmtanchr.hxx>
 #include <fmtrowsplt.hxx>
+#include <cellatr.hxx>
 // --> OD 2005-01-27 #i33818#
 #include <fmtfollowtextflow.hxx>
 // <--
@@ -80,6 +81,10 @@
 
 #include <iostream>
 
+#if DEBUG
+#include <cstdio>
+#endif
+
 #define MAX_COL 64  // WW6-Beschreibung: 32, WW6-UI: 31 & WW8-UI: 63!
 
 using namespace ::com::sun::star;
@@ -270,6 +275,8 @@ public:
     const String& GetNumRuleName() const;
     void SetNumRuleName( const String& rName );
 
+    void SetCellFormula( SwDoc& rDoc, String& rName, String& rFormat );
+
     sw::util::RedlineStack* getOldRedlineStack(){ return mpOldRedlineStack; }
 };
 
@@ -3460,6 +3467,59 @@ void WW8TabDesc::SetNumRuleName( const String& rName )
     aNumRuleNames[nCol] = rName;
 }
 
+void WW8TabDesc::SetCellFormula( SwDoc& rDoc, String& rFml, String& rFormat )
+{
+    SfxItemSet aBoxSet( rDoc.GetAttrPool(), RES_BOXATR_FORMAT, RES_BOXATR_FORMULA );
+
+    if( rFml.EraseLeadingChars().Len() &&
+            '=' == rFml.GetChar( 0 ) )
+        rFml.Erase( 0, 1 );
+    aBoxSet.Put( SwTblBoxFormula( rFml, true ) );
+    
+    if ( rFormat.Len() > 0 )
+    {
+        SvNumberFormatter* pFormatter = rDoc.GetNumberFormatter();
+        sal_uInt32 nKey = pFormatter->GetEntryKey( rFormat );
+        aBoxSet.Put( SwTblBoxNumFormat( nKey ) );
+    }
+
+    rDoc.SetTblBoxFormulaAttrs( *pTabBox, aBoxSet );
+}
+
+eF_ResT SwWW8ImplReader::Read_F_Formula( WW8FieldDesc*, String& rStr )
+{
+    // Look for the first switch
+    xub_StrLen nPos = rStr.Search( '\\' );
+    String sFml = rStr.Copy( 0, nPos );
+    String sSwitches = rStr.Copy( nPos );
+   
+    // Numeric formatting
+    String sFormat;
+    xub_StrLen nNumSwitchPos = sSwitches.SearchAscii( "\\#", 0 );
+    if ( nNumSwitchPos != STRING_NOTFOUND )
+    {
+        xub_StrLen nStart = nNumSwitchPos + 1;
+        xub_StrLen nEnd = sSwitches.Len() - 1;
+        
+        xub_StrLen nQuotePos = sSwitches.SearchAscii( "\"", nNumSwitchPos );
+        if ( nQuotePos != STRING_NOTFOUND )
+        {
+            nStart = nQuotePos + 1;
+            nEnd = sSwitches.SearchAscii( "\"", nStart + 1 );
+        }
+
+        sFormat = sSwitches.Copy( nStart, nEnd - nStart ).EraseAllChars();
+#if DEBUG
+        fprintf( stderr, "TODO SwWW8ImplReader::Read_F_Formula() - Numeric format: %s\n",
+              ByteString( sFormat, RTL_TEXTENCODING_UTF8 ).GetBufferAccess() );
+#endif
+    }
+    
+    pTableDesc->SetCellFormula( GetDoc(), sFml, sFormat );
+
+    return FLD_OK;
+}
+
 bool SwWW8ImplReader::StartTable(WW8_CP nStartCp)
 {
     // Entering a table so make sure the the FirstPara flag gets set
diff --git sw/source/filter/ww8/ww8par5.cxx sw/source/filter/ww8/ww8par5.cxx
index 950ad48..121ff1b 100644
--- sw/source/filter/ww8/ww8par5.cxx
+++ sw/source/filter/ww8/ww8par5.cxx
@@ -940,7 +940,7 @@ long SwWW8ImplReader::Read_Field(WW8PLCFManResult* pRes)
         &SwWW8ImplReader::Read_F_DateTime,          // 31
         &SwWW8ImplReader::Read_F_DateTime,          // 32
         &SwWW8ImplReader::Read_F_CurPage,           // 33
-        0,
+        &SwWW8ImplReader::Read_F_Formula,           // 34
         0,
         &SwWW8ImplReader::Read_F_IncludeText,       // 36
         &SwWW8ImplReader::Read_F_PgRef,             // 37
diff --git sw/source/filter/xml/xmltble.cxx sw/source/filter/xml/xmltble.cxx
index 857d8db..88ff607 100644
--- sw/source/filter/xml/xmltble.cxx
+++ sw/source/filter/xml/xmltble.cxx
@@ -61,7 +61,6 @@
 #include "xmltexte.hxx"
 #include "xmlexp.hxx"
 
-
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
 using namespace ::com::sun::star;
@@ -71,7 +70,7 @@ using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::container;
 using namespace ::xmloff::token;
-using table::XCell;
+using text::XCell2;
 
 
 class SwXMLTableColumn_Impl : public SwWriteTableCol
@@ -707,7 +706,7 @@ void SwXMLExport::ExportTableLinesAutoStyles( const SwTableLines& rLines,
                                        bTop) )
                     ExportFmt( *pFrmFmt2, XML_TABLE_CELL );
 
-                Reference < XCell > xCell = SwXCell::CreateXCell(
+                Reference < XCell2 > xCell = SwXCell::CreateXCell(
                                                 (SwFrmFmt *)rTblInfo.GetTblFmt(),
                                                   pBox,
                                                  (SwTable *)rTblInfo.GetTable() );
@@ -835,7 +834,7 @@ void SwXMLExport::ExportTableBox( const SwTableBox& rBox,
             // start node -> normal cell
 
             // get cell range for table
-            Reference<XCell> xCell = SwXCell::CreateXCell( (SwFrmFmt *)rTblInfo.GetTblFmt(),
+            Reference<XCell2> xCell = SwXCell::CreateXCell( (SwFrmFmt *)rTblInfo.GetTblFmt(),
                                                             (SwTableBox *)&rBox,
                                                             (SwTable *)rTblInfo.GetTable() );
 
@@ -850,9 +849,13 @@ void SwXMLExport::ExportTableBox( const SwTableBox& rBox,
                 //     (with value and number format)
                 if (sCellFormula.getLength()>0)
                 {
+                    sal_uInt16 nPrefix = XML_NAMESPACE_OOOW;
+                    if ( xCell->isWWFormula() )
+                        nPrefix = XML_NAMESPACE_FIELD;
+
                     OUString sQValue =
                         GetNamespaceMap().GetQNameByKey(
-                                XML_NAMESPACE_OOOW, sCellFormula, sal_False );
+                                nPrefix, sCellFormula, sal_False );
                     // formula
                     AddAttribute(XML_NAMESPACE_TABLE, XML_FORMULA, sQValue );
                 }
diff --git sw/source/filter/xml/xmltbli.cxx sw/source/filter/xml/xmltbli.cxx
index c3beb63..1278fc7 100644
--- sw/source/filter/xml/xmltbli.cxx
+++ sw/source/filter/xml/xmltbli.cxx
@@ -186,6 +186,7 @@ class SwXMLTableCell_Impl
     sal_Bool bHasValue;	// determines whether dValue attribute is valid
     sal_Bool mbCovered;
     sal_Bool mbTextValue;
+    sal_Bool mbWWFormula;
 
 public:
 
@@ -194,7 +195,8 @@ public:
         nRowSpan( nRSpan ),
         nColSpan( nCSpan ),
         bProtected( sal_False ),
-        mbCovered( sal_False )
+        mbCovered( sal_False ),
+        mbWWFormula( sal_False )
         {}
 
     inline void Set( const OUString& rStyleName,
@@ -206,7 +208,8 @@ public:
                      sal_Bool mbCovered = sal_False,
                      double dVal = 0.0,
                      sal_Bool mbTextValue = sal_False,
-                     OUString const& i_rXmlId = OUString());
+                     OUString const& i_rXmlId = OUString(),
+                     sal_Bool bWWFormula = sal_False );
 
     sal_Bool IsUsed() const { return pStartNode!=0 ||
                                      xSubTable.Is() || bProtected;}
@@ -222,6 +225,7 @@ public:
     sal_Bool IsCovered() const { return mbCovered; }
     sal_Bool HasTextValue() const { return mbTextValue; }
     const OUString& GetXmlId() const { return mXmlId; }
+    sal_Bool IsWWFormula() const { return mbWWFormula; }
 
     const SwStartNode *GetStartNode() const { return pStartNode; }
     inline void SetStartNode( const SwStartNode *pSttNd );
@@ -241,7 +245,8 @@ inline void SwXMLTableCell_Impl::Set( const OUString& rStyleName,
                                       sal_Bool bCov,
                                       double dVal,
                                       sal_Bool bTextVal,
-                                      OUString const& i_rXmlId )
+                                      OUString const& i_rXmlId,
+                                      sal_Bool bWWFormula )
 {
     aStyleName = rStyleName;
     nRowSpan = nRSpan;
@@ -253,6 +258,7 @@ inline void SwXMLTableCell_Impl::Set( const OUString& rStyleName,
     mbCovered = bCov;
     mbTextValue = bTextVal;
     bProtected = bProtect;
+    mbWWFormula = bWWFormula;
 
     if (!mbCovered) // ensure uniqueness
     {
@@ -398,6 +404,7 @@ class SwXMLTableCellContext_Impl : public SvXMLImportContext
 {
     OUString aStyleName;
     OUString sFormula;
+    sal_Bool bWWFormula;
     OUString sSaveParaDefault;
     OUString mXmlId;
 
@@ -446,6 +453,7 @@ SwXMLTableCellContext_Impl::SwXMLTableCellContext_Impl(
         SwXMLTableContext *pTable ) :
     SvXMLImportContext( rImport, nPrfx, rLName ),
     sFormula(),
+    bWWFormula( sal_False ),
     xMyTable( pTable ),
     fValue( 0.0 ),
     bHasValue( sal_False ),
@@ -499,7 +507,12 @@ SwXMLTableCellContext_Impl::SwXMLTableCellContext_Impl(
                 OUString sTmp;
                 sal_uInt16 nPrefix2 = GetImport().GetNamespaceMap().
                         _GetKeyByAttrName( rValue, &sTmp, sal_False );
-                sFormula = XML_NAMESPACE_OOOW == nPrefix2 ? sTmp : rValue;
+                bWWFormula = ( nPrefix2 == XML_NAMESPACE_FIELD );
+                if ( ( XML_NAMESPACE_OOOW == nPrefix2 ) ||
+                     ( XML_NAMESPACE_FIELD == nPrefix2 ) )
+                    sFormula = sTmp;
+                else
+                    sFormula = rValue;
             }
             break;
         case XML_TOK_TABLE_VALUE:
@@ -570,7 +583,7 @@ inline void SwXMLTableCellContext_Impl::_InsertContent()
     GetTable()->InsertCell( aStyleName, nRowSpan, nColSpan,
                             GetTable()->InsertTableSection(),
                             mXmlId,
-                            NULL, bProtect, &sFormula, bHasValue, fValue, bHasTextValue );
+                            NULL, bProtect, &sFormula, bHasValue, fValue, bHasTextValue, bWWFormula );
 }
 
 inline void SwXMLTableCellContext_Impl::InsertContent()
@@ -1590,7 +1603,8 @@ void SwXMLTableContext::InsertCell( const OUString& rStyleName,
                                     const OUString* pFormula,
                                     sal_Bool bHasValue,
                                     double fValue,
-                                    sal_Bool bTextValue )
+                                    sal_Bool bTextValue,
+                                    sal_Bool bWWFormula )
 {
     ASSERT( nCurCol < GetColumnCount(),
             "SwXMLTableContext::InsertCell: row is full" );
@@ -1686,7 +1700,7 @@ void SwXMLTableContext::InsertCell( const OUString& rStyleName,
             GetCell( nRowsReq-j, nColsReq-i )
                 ->Set( sStyleName, j, i, pStartNode,
                        pTable, bProtect, pFormula, bHasValue, bCovered, fValue,
-                       bTextValue, i_rXmlId );
+                       bTextValue, i_rXmlId, bWWFormula );
         }
     }
 
@@ -1756,7 +1770,8 @@ void SwXMLTableContext::InsertRepRows( sal_uInt32 nCount )
                             0, pSrcCell->IsProtected(),
                             &pSrcCell->GetFormula(),
                             pSrcCell->HasValue(), pSrcCell->GetValue(),
-                            pSrcCell->HasTextValue() );
+                            pSrcCell->HasTextValue(),
+                            pSrcCell->IsWWFormula() );
             }
         }
         FinishRow();
@@ -2156,7 +2171,7 @@ SwTableBox *SwXMLTableContext::MakeTableBox(
             if (rFormula.getLength() > 0)
             {
                 // formula cell: insert formula if valid
-                SwTblBoxFormula aFormulaItem( rFormula );
+                SwTblBoxFormula aFormulaItem( rFormula, pCell->IsWWFormula() );
                 pBoxFmt2->SetFmtAttr( aFormulaItem );
             }
             else if( !pCell->HasValue() && pCell->HasTextValue() )
diff --git sw/source/filter/xml/xmltbli.hxx sw/source/filter/xml/xmltbli.hxx
index 10858ef..be3d18f 100644
--- sw/source/filter/xml/xmltbli.hxx
+++ sw/source/filter/xml/xmltbli.hxx
@@ -184,7 +184,8 @@ public:
                      const ::rtl::OUString *pFormula=0,
                      sal_Bool bHasValue = sal_False,
                      double fValue = 0.0,
-                     sal_Bool bTextValue = sal_False );
+                     sal_Bool bTextValue = sal_False,
+                     sal_Bool bWWFormula = sal_False );
     void InsertRow( const ::rtl::OUString& rStyleName,
                     const ::rtl::OUString& rDfltCellStyleName,
                     sal_Bool bInHead,
diff --git sw/source/ui/shells/textsh1.cxx sw/source/ui/shells/textsh1.cxx
index 760e4d7..50267b1 100644
--- sw/source/ui/shells/textsh1.cxx
+++ sw/source/ui/shells/textsh1.cxx
@@ -769,8 +769,15 @@ void SwTextShell::Execute(SfxRequest &rReq)
                 {
                     if( rWrtSh.IsCrsrInTbl() )
                     {
+                        // Get the formula item or the default one
                         SfxItemSet aSet( rWrtSh.GetAttrPool(), RES_BOXATR_FORMULA, RES_BOXATR_FORMULA );
-                        aSet.Put( SwTblBoxFormula( sFormula ));
+                        rWrtSh.GetTblBoxFormulaAttrs( aSet );
+                        SwTblBoxFormula& aTblBoxFormula = (SwTblBoxFormula&)aSet.Get( RES_BOXATR_FORMULA );
+                        aTblBoxFormula.SetFormula( sFormula );
+
+                        if ( aSet.GetItemState( RES_BOXATR_FORMULA ) == SFX_ITEM_DEFAULT )
+                            aSet.Put( aTblBoxFormula );
+
                         rWrtSh.SetTblBoxFormulaAttrs( aSet );
                         rWrtSh.UpdateTable();
                     }
diff --git sw/util/makefile.mk sw/util/makefile.mk
index 24ad295..7625b28 100644
--- sw/util/makefile.mk
+++ sw/util/makefile.mk
@@ -120,7 +120,12 @@ SHL1STDLIBS+= \
     $(ICUUCLIB) \
     $(I18NUTILLIB)
 SHL1STDLIBS+= \
-    $(AVMEDIALIB)
+    $(AVMEDIALIB) \
+	$(IXIONLIB)
+.IF "$(GUI)"=="WNT"
+SHL1STDLIBS+= \
+    $(BOOSTTHREADLIB)
+.ENDIF
 
 .IF "$(GUI)"=="WNT"
 SHL1STDLIBS+= $(ADVAPI32LIB)
diff --git a/configure.in b/configure.in
index 30f667a..4dd8d06 100644
--- configure.in
+++ configure.in
@@ -4461,6 +4575,7 @@ if test -n "$with_system_boost" -o -n "$with_system_headers" && \
 	test "$with_system_boost" != "no"; then
    AC_MSG_RESULT([external])
    SYSTEM_BOOST=YES
+   BOOST_REQUIRE([1.36])
    AC_LANG_PUSH([C++])
    AC_CHECK_HEADER(boost/shared_ptr.hpp, [],
        [AC_MSG_ERROR(boost/shared_ptr.hpp not found. install boost)], [])
@@ -4482,6 +4597,11 @@ if test -n "$with_system_boost" -o -n "$with_system_headers" && \
   	AC_MSG_RESULT([yes])
    fi
    CXXFLAGS=$save_CXXFLAGS
+   # hack. supposed to be set by libtool but we don't want libtool here.
+   if test "$_os" = "Darwin"; then libext=dylib; \
+   elif test "$_os" = "WINNT"; then libext=dll; \
+   else libext=so; fi
+   BOOST_THREADS
    AC_LANG_POP([C++])
 else
    AC_MSG_RESULT([internal])
@@ -4489,6 +4609,7 @@ else
    SYSTEM_BOOST=NO
 fi
 AC_SUBST(SYSTEM_BOOST)
+AC_SUBST(BOOST_THREAD_LIBS)
 
 dnl ===================================================================
 dnl Check for system vigra
diff --git a/acinclude.m4 b/acinclude.m4
index 71f0154..5dd4c4c 100644
--- acinclude.m4
+++ acinclude.m4
@@ -136,3 +136,5 @@ AC_DEFUN([PKG_CHECK_MODULES_MACHACK],
    PKG_CHECK_MODULES($1, $3, $4, $5, $6)
  fi
 ])
+
+m4_include([boost.m4])
--- /dev/null	2010-09-28 02:28:57.560060918 +0200
+++ boost.m4	2010-09-23 10:26:01.000000000 +0200
@@ -0,0 +1,1043 @@
+# boost.m4: Locate Boost headers and libraries for autoconf-based projects.
+# Copyright (C) 2007, 2008, 2009  Benoit Sigoure <tsuna@lrde.epita.fr>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Additional permission under section 7 of the GNU General Public
+# License, version 3 ("GPLv3"):
+#
+# If you convey this file as part of a work that contains a
+# configuration script generated by Autoconf, you may do so under
+# terms of your choice.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_define([_BOOST_SERIAL], [m4_translit([
+# serial 12
+], [#
+], [])])
+
+# Original sources can be found at http://github.com/tsuna/boost.m4
+# You can fetch the latest version of the script by doing:
+#   wget http://github.com/tsuna/boost.m4/raw/master/build-aux/boost.m4
+
+# ------ #
+# README #
+# ------ #
+
+# This file provides several macros to use the various Boost libraries.
+# The first macro is BOOST_REQUIRE.  It will simply check if it's possible to
+# find the Boost headers of a given (optional) minimum version and it will
+# define BOOST_CPPFLAGS accordingly.  It will add an option --with-boost to
+# your configure so that users can specify non standard locations.
+# If the user's environment contains BOOST_ROOT and --with-boost was not
+# specified, --with-boost=$BOOST_ROOT is implicitly used.
+# For more README and documentation, go to http://github.com/tsuna/boost.m4
+# Note: THESE MACROS ASSUME THAT YOU USE LIBTOOL.  If you don't, don't worry,
+# simply read the README, it will show you what to do step by step.
+
+m4_pattern_forbid([^_?BOOST_])
+
+
+# _BOOST_SED_CPP(SED-PROGRAM, PROGRAM,
+#                [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+# --------------------------------------------------------
+# Same as AC_EGREP_CPP, but leave the result in conftest.i.
+# PATTERN is *not* overquoted, as in AC_EGREP_CPP.  It could be useful
+# to turn this into a macro which extracts the value of any macro.
+m4_define([_BOOST_SED_CPP],
+[AC_LANG_PREPROC_REQUIRE()dnl
+AC_REQUIRE([AC_PROG_SED])dnl
+AC_LANG_CONFTEST([AC_LANG_SOURCE([[$2]])])
+AS_IF([dnl eval is necessary to expand ac_cpp.
+dnl Ultrix and Pyramid sh refuse to redirect output of eval, so use subshell.
+dnl Beware of Windows end-of-lines, for instance if we are running
+dnl some Windows programs under Wine.  In that case, boost/version.hpp
+dnl is certainly using "\r\n", but the regular Unix shell will only
+dnl strip `\n' with backquotes, not the `\r'.  This results in
+dnl boost_cv_lib_version='1_37\r' for instance, which breaks
+dnl everything else.
+dnl Cannot use 'dnl' after [$4] because a trailing dnl may break AC_CACHE_CHECK
+(eval "$ac_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
+  tr -d '\r' |
+  $SED -n -e "$1" >conftest.i 2>&1],
+  [$3],
+  [$4])
+rm -rf conftest*
+])# AC_EGREP_CPP
+
+
+
+# BOOST_REQUIRE([VERSION], [ACTION-IF-NOT-FOUND])
+# -----------------------------------------------
+# Look for Boost.  If version is given, it must either be a literal of the form
+# "X.Y.Z" where X, Y and Z are integers (the ".Z" part being optional) or a
+# variable "$var".
+# Defines the value BOOST_CPPFLAGS.  This macro only checks for headers with
+# the required version, it does not check for any of the Boost libraries.
+# On # success, defines HAVE_BOOST.  On failure, calls the optional
+# ACTION-IF-NOT-FOUND action if one was supplied.
+# Otherwise aborts with an error message.
+AC_DEFUN([BOOST_REQUIRE],
+[AC_REQUIRE([AC_PROG_CXX])dnl
+AC_REQUIRE([AC_PROG_GREP])dnl
+echo "$as_me: this is boost.m4[]_BOOST_SERIAL" >&AS_MESSAGE_LOG_FD
+boost_save_IFS=$IFS
+boost_version_req=$1
+IFS=.
+set x $boost_version_req 0 0 0
+IFS=$boost_save_IFS
+shift
+boost_version_req=`expr "$[1]" '*' 100000 + "$[2]" '*' 100 + "$[3]"`
+AC_ARG_WITH([boost],
+   [AS_HELP_STRING([--with-boost=DIR],
+                   [prefix of Boost $1 @<:@guess@:>@])])dnl
+AC_ARG_VAR([BOOST_ROOT],[Location of Boost installation])dnl
+# If BOOST_ROOT is set and the user has not provided a value to
+# --with-boost, then treat BOOST_ROOT as if it the user supplied it.
+if test x"$BOOST_ROOT" != x; then
+  if test x"$with_boost" = x; then
+    AC_MSG_NOTICE([Detected BOOST_ROOT; continuing with --with-boost=$BOOST_ROOT])
+    with_boost=$BOOST_ROOT
+  else
+    AC_MSG_NOTICE([Detected BOOST_ROOT=$BOOST_ROOT, but overridden by --with-boost=$with_boost])
+  fi
+fi
+AC_SUBST([DISTCHECK_CONFIGURE_FLAGS],
+         ["$DISTCHECK_CONFIGURE_FLAGS '--with-boost=$with_boost'"])
+boost_save_CPPFLAGS=$CPPFLAGS
+  AC_CACHE_CHECK([for Boost headers version >= $boost_version_req],
+    [boost_cv_inc_path],
+    [boost_cv_inc_path=no
+AC_LANG_PUSH([C++])dnl
+m4_pattern_allow([^BOOST_VERSION$])dnl
+    AC_LANG_CONFTEST([AC_LANG_PROGRAM([[#include <boost/version.hpp>
+#if !defined BOOST_VERSION
+# error BOOST_VERSION is not defined
+#elif BOOST_VERSION < $boost_version_req
+# error Boost headers version < $boost_version_req
+#endif
+]])])
+    # If the user provided a value to --with-boost, use it and only it.
+    case $with_boost in #(
+      ''|yes) set x '' /opt/local/include /usr/local/include /opt/include \
+                 /usr/include C:/Boost/include;; #(
+      *)      set x "$with_boost/include" "$with_boost";;
+    esac
+    shift
+    for boost_dir
+    do
+    # Without --layout=system, Boost (or at least some versions) installs
+    # itself in <prefix>/include/boost-<version>.  This inner loop helps to
+    # find headers in such directories.
+    #
+    # Any ${boost_dir}/boost-x_xx directories are searched in reverse version
+    # order followed by ${boost_dir}.  The final '.' is a sentinel for
+    # searching $boost_dir" itself.  Entries are whitespace separated.
+    #
+    # I didn't indent this loop on purpose (to avoid over-indented code)
+    boost_layout_system_search_list=`cd "$boost_dir" 2>/dev/null \
+        && ls -1 | "${GREP}" '^boost-' | sort -rn -t- -k2 \
+        && echo .`
+    for boost_inc in $boost_layout_system_search_list
+    do
+      if test x"$boost_inc" != x.; then
+        boost_inc="$boost_dir/$boost_inc"
+      else
+        boost_inc="$boost_dir" # Uses sentinel in boost_layout_system_search_list
+      fi
+      if test x"$boost_inc" != x; then
+        # We are going to check whether the version of Boost installed
+        # in $boost_inc is usable by running a compilation that
+        # #includes it.  But if we pass a -I/some/path in which Boost
+        # is not installed, the compiler will just skip this -I and
+        # use other locations (either from CPPFLAGS, or from its list
+        # of system include directories).  As a result we would use
+        # header installed on the machine instead of the /some/path
+        # specified by the user.  So in that precise case (trying
+        # $boost_inc), make sure the version.hpp exists.
+        #
+        # Use test -e as there can be symlinks.
+        test -e "$boost_inc/boost/version.hpp" || continue
+        CPPFLAGS="$CPPFLAGS -I$boost_inc"
+      fi
+      AC_COMPILE_IFELSE([], [boost_cv_inc_path=yes], [boost_cv_version=no])
+      if test x"$boost_cv_inc_path" = xyes; then
+        if test x"$boost_inc" != x; then
+          boost_cv_inc_path=$boost_inc
+        fi
+        break 2
+      fi
+    done
+    done
+AC_LANG_POP([C++])dnl
+    ])
+    case $boost_cv_inc_path in #(
+      no)
+        boost_errmsg="cannot find Boost headers version >= $boost_version_req"
+        m4_if([$2], [],  [AC_MSG_ERROR([$boost_errmsg])],
+                        [AC_MSG_NOTICE([$boost_errmsg])])
+        $2
+        ;;#(
+      yes)
+        BOOST_CPPFLAGS=
+        ;;#(
+      *)
+        AC_SUBST([BOOST_CPPFLAGS], ["-I$boost_cv_inc_path"])
+        ;;
+    esac
+  if test x"$boost_cv_inc_path" != xno; then
+  AC_DEFINE([HAVE_BOOST], [1],
+            [Defined if the requested minimum BOOST version is satisfied])
+  AC_CACHE_CHECK([for Boost's header version],
+    [boost_cv_lib_version],
+    [m4_pattern_allow([^BOOST_LIB_VERSION$])dnl
+     _BOOST_SED_CPP([/^boost-lib-version = /{s///;s/\"//g;p;g;}],
+                    [#include <boost/version.hpp>
+boost-lib-version = BOOST_LIB_VERSION],
+    [boost_cv_lib_version=`cat conftest.i`])])
+    # e.g. "134" for 1_34_1 or "135" for 1_35
+    boost_major_version=`echo "$boost_cv_lib_version" | sed 's/_//;s/_.*//'`
+    case $boost_major_version in #(
+      '' | *[[!0-9]]*)
+        AC_MSG_ERROR([invalid value: boost_major_version=$boost_major_version])
+        ;;
+    esac
+fi
+CPPFLAGS=$boost_save_CPPFLAGS
+])# BOOST_REQUIRE
+
+# BOOST_STATIC()
+# --------------
+# Add the "--enable-static-boost" configure argument. If this argument is given
+# on the command line, static versions of the libraries will be looked up.
+AC_DEFUN([BOOST_STATIC],
+  [AC_ARG_ENABLE([static-boost],
+     [AC_HELP_STRING([--enable-static-boost],
+               [Prefer the static boost libraries over the shared ones [no]])],
+     [enable_static_boost=yes],
+     [enable_static_boost=no])])# BOOST_STATIC
+
+# BOOST_FIND_HEADER([HEADER-NAME], [ACTION-IF-NOT-FOUND], [ACTION-IF-FOUND])
+# --------------------------------------------------------------------------
+# Wrapper around AC_CHECK_HEADER for Boost headers.  Useful to check for
+# some parts of the Boost library which are only made of headers and don't
+# require linking (such as Boost.Foreach).
+#
+# Default ACTION-IF-NOT-FOUND: Fail with a fatal error unless Boost couldn't be
+# found in the first place, in which case by default a notice is issued to the
+# user.  Presumably if we haven't died already it's because it's OK to not have
+# Boost, which is why only a notice is issued instead of a hard error.
+#
+# Default ACTION-IF-FOUND: define the preprocessor symbol HAVE_<HEADER-NAME> in
+# case of success # (where HEADER-NAME is written LIKE_THIS, e.g.,
+# HAVE_BOOST_FOREACH_HPP).
+AC_DEFUN([BOOST_FIND_HEADER],
+[AC_REQUIRE([BOOST_REQUIRE])dnl
+if test x"$boost_cv_inc_path" = xno; then
+  m4_default([$2], [AC_MSG_NOTICE([Boost not available, not searching for $1])])
+else
+AC_LANG_PUSH([C++])dnl
+boost_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+AC_CHECK_HEADER([$1],
+  [m4_default([$3], [AC_DEFINE(AS_TR_CPP([HAVE_$1]), [1],
+                               [Define to 1 if you have <$1>])])],
+  [m4_default([$2], [AC_MSG_ERROR([cannot find $1])])])
+CPPFLAGS=$boost_save_CPPFLAGS
+AC_LANG_POP([C++])dnl
+fi
+])# BOOST_FIND_HEADER
+
+
+# BOOST_FIND_LIB([LIB-NAME], [PREFERRED-RT-OPT], [HEADER-NAME], [CXX-TEST],
+#                [CXX-PROLOGUE])
+# -------------------------------------------------------------------------
+# Look for the Boost library LIB-NAME (e.g., LIB-NAME = `thread', for
+# libboost_thread).  Check that HEADER-NAME works and check that
+# libboost_LIB-NAME can link with the code CXX-TEST.  The optional argument
+# CXX-PROLOGUE can be used to include some C++ code before the `main'
+# function.
+#
+# Invokes BOOST_FIND_HEADER([HEADER-NAME]) (see above).
+#
+# Boost libraries typically come compiled with several flavors (with different
+# runtime options) so PREFERRED-RT-OPT is the preferred suffix.  A suffix is one
+# or more of the following letters: sgdpn (in that order).  s = static
+# runtime, d = debug build, g = debug/diagnostic runtime, p = STLPort build,
+# n = (unsure) STLPort build without iostreams from STLPort (it looks like `n'
+# must always be used along with `p').  Additionally, PREFERRED-RT-OPT can
+# start with `mt-' to indicate that there is a preference for multi-thread
+# builds.  Some sample values for PREFERRED-RT-OPT: (nothing), mt, d, mt-d, gdp
+# ...  If you want to make sure you have a specific version of Boost
+# (eg, >= 1.33) you *must* invoke BOOST_REQUIRE before this macro.
+AC_DEFUN([BOOST_FIND_LIB],
+[AC_REQUIRE([BOOST_REQUIRE])dnl
+AC_REQUIRE([_BOOST_FIND_COMPILER_TAG])dnl
+AC_REQUIRE([BOOST_STATIC])dnl
+AC_REQUIRE([_BOOST_GUESS_WHETHER_TO_USE_MT])dnl
+if test x"$boost_cv_inc_path" = xno; then
+  AC_MSG_NOTICE([Boost not available, not searching for the Boost $1 library])
+else
+dnl The else branch is huge and wasn't intended on purpose.
+AC_LANG_PUSH([C++])dnl
+AS_VAR_PUSHDEF([Boost_lib], [boost_cv_lib_$1])dnl
+AS_VAR_PUSHDEF([Boost_lib_LDFLAGS], [boost_cv_lib_$1_LDFLAGS])dnl
+AS_VAR_PUSHDEF([Boost_lib_LIBS], [boost_cv_lib_$1_LIBS])dnl
+BOOST_FIND_HEADER([$3])
+boost_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+# Now let's try to find the library.  The algorithm is as follows: first look
+# for a given library name according to the user's PREFERRED-RT-OPT.  For each
+# library name, we prefer to use the ones that carry the tag (toolset name).
+# Each library is searched through the various standard paths were Boost is
+# usually installed.  If we can't find the standard variants, we try to
+# enforce -mt (for instance on MacOSX, libboost_threads.dylib doesn't exist
+# but there's -obviously- libboost_threads-mt.dylib).
+AC_CACHE_CHECK([for the Boost $1 library], [Boost_lib],
+  [Boost_lib=no
+  case "$2" in #(
+    mt | mt-) boost_mt=-mt; boost_rtopt=;; #(
+    mt* | mt-*) boost_mt=-mt; boost_rtopt=`expr "X$2" : 'Xmt-*\(.*\)'`;; #(
+    *) boost_mt=; boost_rtopt=$2;;
+  esac
+  if test $enable_static_boost = yes; then
+    boost_rtopt="s$boost_rtopt"
+  fi
+  # Find the proper debug variant depending on what we've been asked to find.
+  case $boost_rtopt in #(
+    *d*) boost_rt_d=$boost_rtopt;; #(
+    *[[sgpn]]*) # Insert the `d' at the right place (in between `sg' and `pn')
+      boost_rt_d=`echo "$boost_rtopt" | sed 's/\(s*g*\)\(p*n*\)/\1\2/'`;; #(
+    *) boost_rt_d='-d';;
+  esac
+  # If the PREFERRED-RT-OPT are not empty, prepend a `-'.
+  test -n "$boost_rtopt" && boost_rtopt="-$boost_rtopt"
+  $boost_guess_use_mt && boost_mt=-mt
+  # Look for the abs path the static archive.
+  # $libext is computed by Libtool but let's make sure it's non empty.
+  test -z "$libext" &&
+    AC_MSG_ERROR([the libext variable is empty, did you invoke Libtool?])
+  boost_save_ac_objext=$ac_objext
+  # Generate the test file.
+  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <$3>
+$5], [$4])])
+dnl Optimization hacks: compiling C++ is slow, especially with Boost.  What
+dnl we're trying to do here is guess the right combination of link flags
+dnl (LIBS / LDFLAGS) to use a given library.  This can take several
+dnl iterations before it succeeds and is thus *very* slow.  So what we do
+dnl instead is that we compile the code first (and thus get an object file,
+dnl typically conftest.o).  Then we try various combinations of link flags
+dnl until we succeed to link conftest.o in an executable.  The problem is
+dnl that the various TRY_LINK / COMPILE_IFELSE macros of Autoconf always
+dnl remove all the temporary files including conftest.o.  So the trick here
+dnl is to temporarily change the value of ac_objext so that conftest.o is
+dnl preserved accross tests.  This is obviously fragile and I will burn in
+dnl hell for not respecting Autoconf's documented interfaces, but in the
+dnl mean time, it optimizes the macro by a factor of 5 to 30.
+dnl Another small optimization: the first argument of AC_COMPILE_IFELSE left
+dnl empty because the test file is generated only once above (before we
+dnl start the for loops).
+  AC_COMPILE_IFELSE([],
+    [ac_objext=do_not_rm_me_plz],
+    [AC_MSG_ERROR([cannot compile a test that uses Boost $1])])
+  ac_objext=$boost_save_ac_objext
+  boost_failed_libs=
+# Don't bother to ident the 6 nested for loops, only the 2 innermost ones
+# matter.
+for boost_tag_ in -$boost_cv_lib_tag ''; do
+for boost_ver_ in -$boost_cv_lib_version ''; do
+for boost_mt_ in $boost_mt -mt ''; do
+for boost_rtopt_ in $boost_rtopt '' -d; do
+  for boost_lib in \
+    boost_$1$boost_tag_$boost_mt_$boost_rtopt_$boost_ver_ \
+    boost_$1$boost_tag_$boost_rtopt_$boost_ver_ \
+    boost_$1$boost_tag_$boost_mt_$boost_ver_ \
+    boost_$1$boost_tag_$boost_ver_
+  do
+    # Avoid testing twice the same lib
+    case $boost_failed_libs in #(
+      *@$boost_lib@*) continue;;
+    esac
+    # If with_boost is empty, we'll search in /lib first, which is not quite
+    # right so instead we'll try to a location based on where the headers are.
+    boost_tmp_lib=$with_boost
+    test x"$with_boost" = x && boost_tmp_lib=${boost_cv_inc_path%/include}
+    for boost_ldpath in "$boost_tmp_lib/lib" '' \
+             /opt/local/lib /usr/local/lib /opt/lib /usr/lib \
+             "$with_boost" C:/Boost/lib /lib /usr/lib64 /lib64
+    do
+      test -e "$boost_ldpath" || continue
+      boost_save_LDFLAGS=$LDFLAGS
+      # Are we looking for a static library?
+      case $boost_ldpath:$boost_rtopt_ in #(
+        *?*:*s*) # Yes (Non empty boost_ldpath + s in rt opt)
+          Boost_lib_LIBS="$boost_ldpath/lib$boost_lib.$libext"
+          test -e "$Boost_lib_LIBS" || continue;; #(
+        *) # No: use -lboost_foo to find the shared library.
+          Boost_lib_LIBS="-l$boost_lib";;
+      esac
+      boost_save_LIBS=$LIBS
+      LIBS="$Boost_lib_LIBS $LIBS"
+      test x"$boost_ldpath" != x && LDFLAGS="$LDFLAGS -L$boost_ldpath"
+dnl First argument of AC_LINK_IFELSE left empty because the test file is
+dnl generated only once above (before we start the for loops).
+      _BOOST_AC_LINK_IFELSE([],
+                            [Boost_lib=yes], [Boost_lib=no])
+      ac_objext=$boost_save_ac_objext
+      LDFLAGS=$boost_save_LDFLAGS
+      LIBS=$boost_save_LIBS
+      if test x"$Boost_lib" = xyes; then
+        Boost_lib_LDFLAGS="-L$boost_ldpath -R$boost_ldpath"
+        break 6
+      else
+        boost_failed_libs="$boost_failed_libs@$boost_lib@"
+      fi
+    done
+  done
+done
+done
+done
+done
+rm -f conftest.$ac_objext
+])
+case $Boost_lib in #(
+  no) _AC_MSG_LOG_CONFTEST
+    AC_MSG_ERROR([cannot not find the flags to link with Boost $1])
+    ;;
+esac
+AC_SUBST(AS_TR_CPP([BOOST_$1_LDFLAGS]), [$Boost_lib_LDFLAGS])
+AC_SUBST(AS_TR_CPP([BOOST_$1_LIBS]), [$Boost_lib_LIBS])
+CPPFLAGS=$boost_save_CPPFLAGS
+AS_VAR_POPDEF([Boost_lib])dnl
+AS_VAR_POPDEF([Boost_lib_LDFLAGS])dnl
+AS_VAR_POPDEF([Boost_lib_LIBS])dnl
+AC_LANG_POP([C++])dnl
+fi
+])# BOOST_FIND_LIB
+
+
+# --------------------------------------- #
+# Checks for the various Boost libraries. #
+# --------------------------------------- #
+
+# List of boost libraries: http://www.boost.org/libs/libraries.htm
+# The page http://beta.boost.org/doc/libs is useful: it gives the first release
+# version of each library (among other things).
+
+# BOOST_ARRAY()
+# -------------
+# Look for Boost.Array
+AC_DEFUN([BOOST_ARRAY],
+[BOOST_FIND_HEADER([boost/array.hpp])])
+
+
+# BOOST_ASIO()
+# ------------
+# Look for Boost.Asio (new in Boost 1.35).
+AC_DEFUN([BOOST_ASIO],
+[AC_REQUIRE([BOOST_SYSTEM])dnl
+BOOST_FIND_HEADER([boost/asio.hpp])])
+
+
+# BOOST_BIND()
+# ------------
+# Look for Boost.Bind
+AC_DEFUN([BOOST_BIND],
+[BOOST_FIND_HEADER([boost/bind.hpp])])
+
+
+# BOOST_CONVERSION()
+# ------------------
+# Look for Boost.Conversion (cast / lexical_cast)
+AC_DEFUN([BOOST_CONVERSION],
+[BOOST_FIND_HEADER([boost/cast.hpp])
+BOOST_FIND_HEADER([boost/lexical_cast.hpp])
+])# BOOST_CONVERSION
+
+
+# BOOST_DATE_TIME([PREFERRED-RT-OPT])
+# -----------------------------------
+# Look for Boost.Date_Time.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_DATE_TIME],
+[BOOST_FIND_LIB([date_time], [$1],
+                [boost/date_time/posix_time/posix_time.hpp],
+                [boost::posix_time::ptime t;])
+])# BOOST_DATE_TIME
+
+
+# BOOST_FILESYSTEM([PREFERRED-RT-OPT])
+# ------------------------------------
+# Look for Boost.Filesystem.  For the documentation of PREFERRED-RT-OPT, see
+# the documentation of BOOST_FIND_LIB above.
+# Do not check for boost/filesystem.hpp because this file was introduced in
+# 1.34.
+AC_DEFUN([BOOST_FILESYSTEM],
+[# Do we have to check for Boost.System?  This link-time dependency was
+# added as of 1.35.0.  If we have a version <1.35, we must not attempt to
+# find Boost.System as it didn't exist by then.
+if test $boost_major_version -ge 135; then
+BOOST_SYSTEM([$1])
+fi # end of the Boost.System check.
+boost_filesystem_save_LIBS=$LIBS
+boost_filesystem_save_LDFLAGS=$LDFLAGS
+m4_pattern_allow([^BOOST_SYSTEM_(LIBS|LDFLAGS)$])dnl
+LIBS="$LIBS $BOOST_SYSTEM_LIBS"
+LDFLAGS="$LDFLAGS $BOOST_SYSTEM_LDFLAGS"
+BOOST_FIND_LIB([filesystem], [$1],
+                [boost/filesystem/path.hpp], [boost::filesystem::path p;])
+LIBS=$boost_filesystem_save_LIBS
+LDFLAGS=$boost_filesystem_save_LDFLAGS
+])# BOOST_FILESYSTEM
+
+
+# BOOST_FOREACH()
+# ---------------
+# Look for Boost.Foreach
+AC_DEFUN([BOOST_FOREACH],
+[BOOST_FIND_HEADER([boost/foreach.hpp])])
+
+
+# BOOST_FORMAT()
+# --------------
+# Look for Boost.Format
+# Note: we can't check for boost/format/format_fwd.hpp because the header isn't
+# standalone.  It can't be compiled because it triggers the following error:
+# boost/format/detail/config_macros.hpp:88: error: 'locale' in namespace 'std'
+#                                                  does not name a type
+AC_DEFUN([BOOST_FORMAT],
+[BOOST_FIND_HEADER([boost/format.hpp])])
+
+
+# BOOST_FUNCTION()
+# ----------------
+# Look for Boost.Function
+AC_DEFUN([BOOST_FUNCTION],
+[BOOST_FIND_HEADER([boost/function.hpp])])
+
+
+# BOOST_GRAPH([PREFERRED-RT-OPT])
+# -------------------------------
+# Look for Boost.Graphs.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_GRAPH],
+[BOOST_FIND_LIB([graph], [$1],
+                [boost/graph/adjacency_list.hpp], [boost::adjacency_list<> g;])
+])# BOOST_GRAPH
+
+
+# BOOST_IOSTREAMS([PREFERRED-RT-OPT])
+# -------------------------------
+# Look for Boost.IOStreams.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_IOSTREAMS],
+[BOOST_FIND_LIB([iostreams], [$1],
+                [boost/iostreams/device/file_descriptor.hpp],
+                [boost::iostreams::file_descriptor fd(0); fd.close();])
+])# BOOST_IOSTREAMS
+
+
+# BOOST_HASH()
+# ------------
+# Look for Boost.Functional/Hash
+AC_DEFUN([BOOST_HASH],
+[BOOST_FIND_HEADER([boost/functional/hash.hpp])])
+
+
+# BOOST_LAMBDA()
+# --------------
+# Look for Boost.Lambda
+AC_DEFUN([BOOST_LAMBDA],
+[BOOST_FIND_HEADER([boost/lambda/lambda.hpp])])
+
+
+# BOOST_MATH()
+# ------------
+# Look for Boost.Math
+# TODO: This library isn't header-only but it comes in multiple different
+# flavors that don't play well with BOOST_FIND_LIB (e.g, libboost_math_c99,
+# libboost_math_c99f, libboost_math_c99l, libboost_math_tr1,
+# libboost_math_tr1f, libboost_math_tr1l).  This macro must be fixed to do the
+# right thing anyway.
+AC_DEFUN([BOOST_MATH],
+[BOOST_FIND_HEADER([boost/math/special_functions.hpp])])
+
+
+# BOOST_MULTIARRAY()
+# ------------------
+# Look for Boost.MultiArray
+AC_DEFUN([BOOST_MULTIARRAY],
+[BOOST_FIND_HEADER([boost/multi_array.hpp])])
+
+
+# BOOST_NUMERIC_CONVERSION()
+# --------------------------
+# Look for Boost.NumericConversion (policy-based numeric conversion)
+AC_DEFUN([BOOST_NUMERIC_CONVERSION],
+[BOOST_FIND_HEADER([boost/numeric/conversion/converter.hpp])
+])# BOOST_NUMERIC_CONVERSION
+
+
+# BOOST_OPTIONAL()
+# ----------------
+# Look for Boost.Optional
+AC_DEFUN([BOOST_OPTIONAL],
+[BOOST_FIND_HEADER([boost/optional.hpp])])
+
+
+# BOOST_PREPROCESSOR()
+# --------------------
+# Look for Boost.Preprocessor
+AC_DEFUN([BOOST_PREPROCESSOR],
+[BOOST_FIND_HEADER([boost/preprocessor/repeat.hpp])])
+
+
+# BOOST_PROGRAM_OPTIONS([PREFERRED-RT-OPT])
+# -----------------------------------------
+# Look for Boost.Program_options.  For the documentation of PREFERRED-RT-OPT, see
+# the documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_PROGRAM_OPTIONS],
+[BOOST_FIND_LIB([program_options], [$1],
+                [boost/program_options.hpp],
+                [boost::program_options::options_description d("test");])
+])# BOOST_PROGRAM_OPTIONS
+
+
+# BOOST_REF()
+# -----------
+# Look for Boost.Ref
+AC_DEFUN([BOOST_REF],
+[BOOST_FIND_HEADER([boost/ref.hpp])])
+
+
+# BOOST_REGEX([PREFERRED-RT-OPT])
+# -------------------------------
+# Look for Boost.Regex.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_REGEX],
+[BOOST_FIND_LIB([regex], [$1],
+                [boost/regex.hpp],
+                [boost::regex exp("*"); boost::regex_match("foo", exp);])
+])# BOOST_REGEX
+
+
+# BOOST_SERIALIZATION([PREFERRED-RT-OPT])
+# ---------------------------------------
+# Look for Boost.Serialization.  For the documentation of PREFERRED-RT-OPT, see
+# the documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_SERIALIZATION],
+[BOOST_FIND_LIB([serialization], [$1],
+                [boost/archive/text_oarchive.hpp],
+                [std::ostream* o = 0; // Cheap way to get an ostream...
+                boost::archive::text_oarchive t(*o);])
+])# BOOST_SIGNALS
+
+
+# BOOST_SIGNALS([PREFERRED-RT-OPT])
+# ---------------------------------
+# Look for Boost.Signals.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_SIGNALS],
+[BOOST_FIND_LIB([signals], [$1],
+                [boost/signal.hpp],
+                [boost::signal<void ()> s;])
+])# BOOST_SIGNALS
+
+
+# BOOST_SMART_PTR()
+# -----------------
+# Look for Boost.SmartPtr
+AC_DEFUN([BOOST_SMART_PTR],
+[BOOST_FIND_HEADER([boost/scoped_ptr.hpp])
+BOOST_FIND_HEADER([boost/shared_ptr.hpp])
+])
+
+
+# BOOST_STATICASSERT()
+# --------------------
+# Look for Boost.StaticAssert
+AC_DEFUN([BOOST_STATICASSERT],
+[BOOST_FIND_HEADER([boost/static_assert.hpp])])
+
+
+# BOOST_STRING_ALGO()
+# -------------------
+# Look for Boost.StringAlgo
+AC_DEFUN([BOOST_STRING_ALGO],
+[BOOST_FIND_HEADER([boost/algorithm/string.hpp])
+])
+
+
+# BOOST_SYSTEM([PREFERRED-RT-OPT])
+# --------------------------------
+# Look for Boost.System.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.  This library was introduced in Boost
+# 1.35.0.
+AC_DEFUN([BOOST_SYSTEM],
+[BOOST_FIND_LIB([system], [$1],
+                [boost/system/error_code.hpp],
+                [boost::system::error_code e; e.clear();])
+])# BOOST_SYSTEM
+
+
+# BOOST_TEST([PREFERRED-RT-OPT])
+# ------------------------------
+# Look for Boost.Test.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_TEST],
+[m4_pattern_allow([^BOOST_CHECK$])dnl
+BOOST_FIND_LIB([unit_test_framework], [$1],
+               [boost/test/unit_test.hpp], [BOOST_CHECK(2 == 2);],
+               [using boost::unit_test::test_suite;
+               test_suite* init_unit_test_suite(int argc, char ** argv)
+               { return NULL; }])
+])# BOOST_TEST
+
+
+# BOOST_THREADS([PREFERRED-RT-OPT])
+# ---------------------------------
+# Look for Boost.Thread.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+# FIXME: Provide an alias "BOOST_THREAD".
+AC_DEFUN([BOOST_THREADS],
+[dnl Having the pthread flag is required at least on GCC3 where
+dnl boost/thread.hpp would complain if we try to compile without
+dnl -pthread on GNU/Linux.
+AC_REQUIRE([_BOOST_PTHREAD_FLAG])dnl
+boost_threads_save_LIBS=$LIBS
+boost_threads_save_CPPFLAGS=$CPPFLAGS
+LIBS="$LIBS $boost_cv_pthread_flag"
+# Yes, we *need* to put the -pthread thing in CPPFLAGS because with GCC3,
+# boost/thread.hpp will trigger a #error if -pthread isn't used:
+#   boost/config/requires_threads.hpp:47:5: #error "Compiler threading support
+#   is not turned on. Please set the correct command line options for
+#   threading: -pthread (Linux), -pthreads (Solaris) or -mthreads (Mingw32)"
+CPPFLAGS="$CPPFLAGS $boost_cv_pthread_flag"
+BOOST_FIND_LIB([thread], [$1],
+                [boost/thread.hpp], [boost::thread t; boost::mutex m;])
+BOOST_THREAD_LIBS="$BOOST_THREAD_LIBS $boost_cv_pthread_flag"
+BOOST_CPPFLAGS="$BOOST_CPPFLAGS $boost_cv_pthread_flag"
+LIBS=$boost_threads_save_LIBS
+CPPFLAGS=$boost_threads_save_CPPFLAGS
+])# BOOST_THREADS
+
+
+# BOOST_TOKENIZER()
+# -----------------
+# Look for Boost.Tokenizer
+AC_DEFUN([BOOST_TOKENIZER],
+[BOOST_FIND_HEADER([boost/tokenizer.hpp])])
+
+
+# BOOST_TRIBOOL()
+# ---------------
+# Look for Boost.Tribool
+AC_DEFUN([BOOST_TRIBOOL],
+[BOOST_FIND_HEADER([boost/logic/tribool_fwd.hpp])
+BOOST_FIND_HEADER([boost/logic/tribool.hpp])
+])
+
+
+# BOOST_TUPLE()
+# -------------
+# Look for Boost.Tuple
+AC_DEFUN([BOOST_TUPLE],
+[BOOST_FIND_HEADER([boost/tuple/tuple.hpp])])
+
+
+# BOOST_TYPETRAITS()
+# --------------------
+# Look for Boost.TypeTraits
+AC_DEFUN([BOOST_TYPETRAITS],
+[BOOST_FIND_HEADER([boost/type_traits.hpp])])
+
+# BOOST_UNORDERED()
+# ---------------
+# Look for Boost.Unordered (unordered_map, unordered_set
+# etc.)
+AC_DEFUN([BOOST_UNORDERED],
+[BOOST_FIND_HEADER([boost/unordered_map.hpp])
+BOOST_FIND_HEADER([boost/unordered_set.hpp])])
+
+# BOOST_UTILITY()
+# ---------------
+# Look for Boost.Utility (noncopyable, result_of, base-from-member idiom,
+# etc.)
+AC_DEFUN([BOOST_UTILITY],
+[BOOST_FIND_HEADER([boost/utility.hpp])])
+
+
+# BOOST_VARIANT()
+# ---------------
+# Look for Boost.Variant.
+AC_DEFUN([BOOST_VARIANT],
+[BOOST_FIND_HEADER([boost/variant/variant_fwd.hpp])
+BOOST_FIND_HEADER([boost/variant.hpp])])
+
+
+# BOOST_WAVE([PREFERRED-RT-OPT])
+# ------------------------------
+# NOTE: If you intend to use Wave/Spirit with thread support, make sure you
+# call BOOST_THREADS first.
+# Look for Boost.Wave.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_WAVE],
+[AC_REQUIRE([BOOST_FILESYSTEM])dnl
+AC_REQUIRE([BOOST_DATE_TIME])dnl
+boost_wave_save_LIBS=$LIBS
+boost_wave_save_LDFLAGS=$LDFLAGS
+m4_pattern_allow([^BOOST_((FILE)?SYSTEM|DATE_TIME|THREAD)_(LIBS|LDFLAGS)$])dnl
+LIBS="$LIBS $BOOST_SYSTEM_LIBS $BOOST_FILESYSTEM_LIBS $BOOST_DATE_TIME_LIBS\
+$BOOST_THREAD_LIBS"
+LDFLAGS="$LDFLAGS $BOOST_SYSTEM_LDFLAGS $BOOST_FILESYSTEM_LDFLAGS\
+$BOOST_DATE_TIME_LDFLAGS $BOOST_THREAD_LDFLAGS"
+BOOST_FIND_LIB([wave], [$1],
+                [boost/wave.hpp],
+                [boost::wave::token_id id; get_token_name(id);])
+LIBS=$boost_wave_save_LIBS
+LDFLAGS=$boost_wave_save_LDFLAGS
+])# BOOST_WAVE
+
+
+# BOOST_XPRESSIVE()
+# -----------------
+# Look for Boost.Xpressive (new since 1.36.0).
+AC_DEFUN([BOOST_XPRESSIVE],
+[BOOST_FIND_HEADER([boost/xpressive/xpressive.hpp])])
+
+
+# ----------------- #
+# Internal helpers. #
+# ----------------- #
+
+
+# _BOOST_PTHREAD_FLAG()
+# ---------------------
+# Internal helper for BOOST_THREADS.  Based on ACX_PTHREAD:
+# http://autoconf-archive.cryp.to/acx_pthread.html
+AC_DEFUN([_BOOST_PTHREAD_FLAG],
+[AC_REQUIRE([AC_PROG_CXX])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_LANG_PUSH([C++])dnl
+AC_CACHE_CHECK([for the flags needed to use pthreads], [boost_cv_pthread_flag],
+[ boost_cv_pthread_flag=
+  # The ordering *is* (sometimes) important.  Some notes on the
+  # individual items follow:
+  # (none): in case threads are in libc; should be tried before -Kthread and
+  #       other compiler flags to prevent continual compiler warnings
+  # -lpthreads: AIX (must check this before -lpthread)
+  # -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
+  # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
+  # -llthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
+  # -pthread: GNU Linux/GCC (kernel threads), BSD/GCC (userland threads)
+  # -pthreads: Solaris/GCC
+  # -mthreads: MinGW32/GCC, Lynx/GCC
+  # -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
+  #      doesn't hurt to check since this sometimes defines pthreads too;
+  #      also defines -D_REENTRANT)
+  #      ... -mt is also the pthreads flag for HP/aCC
+  # -lpthread: GNU Linux, etc.
+  # --thread-safe: KAI C++
+  case $host_os in #(
+    *solaris*)
+      # On Solaris (at least, for some versions), libc contains stubbed
+      # (non-functional) versions of the pthreads routines, so link-based
+      # tests will erroneously succeed.  (We need to link with -pthreads/-mt/
+      # -lpthread.)  (The stubs are missing pthread_cleanup_push, or rather
+      # a function called by this macro, so we could check for that, but
+      # who knows whether they'll stub that too in a future libc.)  So,
+      # we'll just look for -pthreads and -lpthread first:
+      boost_pthread_flags="-pthreads -lpthread -mt -pthread";; #(
+    *)
+      boost_pthread_flags="-lpthreads -Kthread -kthread -llthread -pthread \
+                           -pthreads -mthreads -lpthread --thread-safe -mt";;
+  esac
+  # Generate the test file.
+  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <pthread.h>],
+    [pthread_t th; pthread_join(th, 0);
+    pthread_attr_init(0); pthread_cleanup_push(0, 0);
+    pthread_create(0,0,0,0); pthread_cleanup_pop(0);])])
+  for boost_pthread_flag in '' $boost_pthread_flags; do
+    boost_pthread_ok=false
+dnl Re-use the test file already generated.
+    boost_pthreads__save_LIBS=$LIBS
+    LIBS="$LIBS $boost_pthread_flag"
+    AC_LINK_IFELSE([],
+      [if grep ".*$boost_pthread_flag" conftest.err; then
+         echo "This flag seems to have triggered warnings" >&AS_MESSAGE_LOG_FD
+       else
+         boost_pthread_ok=:; boost_cv_pthread_flag=$boost_pthread_flag
+       fi])
+    LIBS=$boost_pthreads__save_LIBS
+    $boost_pthread_ok && break
+  done
+])
+AC_LANG_POP([C++])dnl
+])# _BOOST_PTHREAD_FLAG
+
+
+# _BOOST_gcc_test(MAJOR, MINOR)
+# -----------------------------
+# Internal helper for _BOOST_FIND_COMPILER_TAG.
+m4_define([_BOOST_gcc_test],
+["defined __GNUC__ && __GNUC__ == $1 && __GNUC_MINOR__ == $2 && !defined __ICC @ gcc$1$2"])dnl
+
+
+# _BOOST_FIND_COMPILER_TAG()
+# --------------------------
+# Internal.  When Boost is installed without --layout=system, each library
+# filename will hold a suffix that encodes the compiler used during the
+# build.  The Boost build system seems to call this a `tag'.
+AC_DEFUN([_BOOST_FIND_COMPILER_TAG],
+[AC_REQUIRE([AC_PROG_CXX])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_CACHE_CHECK([for the toolset name used by Boost for $CXX], [boost_cv_lib_tag],
+[boost_cv_lib_tag=unknown
+if test x$boost_cv_inc_path != xno; then
+  AC_LANG_PUSH([C++])dnl
+  # The following tests are mostly inspired by boost/config/auto_link.hpp
+  # The list is sorted to most recent/common to oldest compiler (in order
+  # to increase the likelihood of finding the right compiler with the
+  # least number of compilation attempt).
+  # Beware that some tests are sensible to the order (for instance, we must
+  # look for MinGW before looking for GCC3).
+  # I used one compilation test per compiler with a #error to recognize
+  # each compiler so that it works even when cross-compiling (let me know
+  # if you know a better approach).
+  # Known missing tags (known from Boost's tools/build/v2/tools/common.jam):
+  #   como, edg, kcc, bck, mp, sw, tru, xlc
+  # I'm not sure about my test for `il' (be careful: Intel's ICC pre-defines
+  # the same defines as GCC's).
+  # TODO: Move the test on GCC 4.4 up once it's released.
+  for i in \
+    _BOOST_gcc_test(4, 3) \
+    _BOOST_gcc_test(4, 2) \
+    _BOOST_gcc_test(4, 1) \
+    _BOOST_gcc_test(4, 0) \
+    "defined __GNUC__ && __GNUC__ == 3 && !defined __ICC \
+     && (defined WIN32 || defined WINNT || defined _WIN32 || defined __WIN32 \
+         || defined __WIN32__ || defined __WINNT || defined __WINNT__) @ mgw" \
+    _BOOST_gcc_test(3, 4) \
+    _BOOST_gcc_test(3, 3) \
+    "defined _MSC_VER && _MSC_VER >= 1500 @ vc90" \
+    "defined _MSC_VER && _MSC_VER == 1400 @ vc80" \
+    _BOOST_gcc_test(3, 2) \
+    "defined _MSC_VER && _MSC_VER == 1310 @ vc71" \
+    _BOOST_gcc_test(3, 1) \
+    _BOOST_gcc_test(3, 0) \
+    "defined __BORLANDC__ @ bcb" \
+    "defined __ICC && (defined __unix || defined __unix__) @ il" \
+    "defined __ICL @ iw" \
+    "defined _MSC_VER && _MSC_VER == 1300 @ vc7" \
+    _BOOST_gcc_test(4, 4) \
+    _BOOST_gcc_test(2, 95) \
+    "defined _MSC_VER && _MSC_VER < 1300 && !defined UNDER_CE @ vc6" \
+    "defined _MSC_VER && _MSC_VER < 1300 && defined UNDER_CE @ evc4"
+  do
+    boost_tag_test=`expr "X$i" : 'X\([[^@]]*\) @ '`
+    boost_tag=`expr "X$i" : 'X[[^@]]* @ \(.*\)'`
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#if $boost_tag_test
+/* OK */
+#else
+# error $boost_tag_test
+#endif
+]])], [boost_cv_lib_tag=$boost_tag; break], [])
+  done
+AC_LANG_POP([C++])dnl
+  case $boost_cv_lib_tag in #(
+    # Some newer (>= 1.35?) versions of Boost seem to only use "gcc" as opposed
+    # to "gcc41" for instance.
+    *-gcc | *'-gcc ') :;; #(  Don't re-add -gcc: it's already in there.
+    gcc*)
+      boost_tag_x=
+      case $host_os in #(
+        darwin*)
+          if test $boost_major_version -ge 136; then
+            # The `x' added in r46793 of Boost.
+            boost_tag_x=x
+          fi;;
+      esac
+      # We can specify multiple tags in this variable because it's used by
+      # BOOST_FIND_LIB that does a `for tag in -$boost_cv_lib_tag' ...
+      boost_cv_lib_tag="$boost_tag_x$boost_cv_lib_tag -${boost_tag_x}gcc"
+      ;; #(
+    unknown)
+      AC_MSG_WARN([[could not figure out which toolset name to use for $CXX]])
+      boost_cv_lib_tag=
+      ;;
+  esac
+fi])dnl end of AC_CACHE_CHECK
+])# _BOOST_FIND_COMPILER_TAG
+
+
+# _BOOST_GUESS_WHETHER_TO_USE_MT()
+# --------------------------------
+# Compile a small test to try to guess whether we should favor MT (Multi
+# Thread) flavors of Boost.  Sets boost_guess_use_mt accordingly.
+AC_DEFUN([_BOOST_GUESS_WHETHER_TO_USE_MT],
+[# Check whether we do better use `mt' even though we weren't ask to.
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#if defined _REENTRANT || defined _MT || defined __MT__
+/* use -mt */
+#else
+# error MT not needed
+#endif
+]])], [boost_guess_use_mt=:], [boost_guess_use_mt=false])
+])
+
+# _BOOST_AC_LINK_IFELSE(PROGRAM, [ACTION-IF-TRUE], [ACTION-IF-FALSE])
+# -------------------------------------------------------------------
+# Fork of _AC_LINK_IFELSE that preserves conftest.o across calls.  Fragile,
+# will break when Autoconf changes its internals.  Requires that you manually
+# rm -f conftest.$ac_objext in between to really different tests, otherwise
+# you will try to link a conftest.o left behind by a previous test.
+# Used to aggressively optimize BOOST_FIND_LIB (see the big comment in this
+# macro).
+#
+# Don't use "break" in the actions, as it would short-circuit some code
+# this macro runs after the actions.
+m4_define([_BOOST_AC_LINK_IFELSE],
+[m4_ifvaln([$1], [AC_LANG_CONFTEST([$1])])dnl
+rm -f conftest$ac_exeext
+boost_save_ac_ext=$ac_ext
+boost_use_source=:
+# If we already have a .o, re-use it.  We change $ac_ext so that $ac_link
+# tries to link the existing object file instead of compiling from source.
+test -f conftest.$ac_objext && ac_ext=$ac_objext && boost_use_source=false &&
+  _AS_ECHO_LOG([re-using the existing conftest.$ac_objext])
+AS_IF([_AC_DO_STDERR($ac_link) && {
+	 test -z "$ac_[]_AC_LANG_ABBREV[]_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_executable_p conftest$ac_exeext
+dnl FIXME: use AS_TEST_X instead when 2.61 is widespread enough.
+       }],
+      [$2],
+      [if $boost_use_source; then
+         _AC_MSG_LOG_CONFTEST
+       fi
+       $3])
+ac_objext=$boost_save_ac_objext
+ac_ext=$boost_save_ac_ext
+dnl Delete also the IPA/IPO (Inter Procedural Analysis/Optimization)
+dnl information created by the PGI compiler (conftest_ipa8_conftest.oo),
+dnl as it would interfere with the next link command.
+rm -f core conftest.err conftest_ipa8_conftest.oo \
+      conftest$ac_exeext m4_ifval([$1], [conftest.$ac_ext])[]dnl
+])# _BOOST_AC_LINK_IFELSE
+
+# Local Variables:
+# mode: autoconf
+# End:
diff --git a/set_soenv.in b/set_soenv.in
index 068389d..f72cb4c 100644
--- set_soenv.in
+++ set_soenv.in
@@ -1913,6 +1913,7 @@ ToFile( "SYSTEM_CURL",       "@SYSTEM_CURL@",      "e" );
 ToFile( "CURL_CFLAGS",       "@CURL_CFLAGS@",      "e" );
 ToFile( "CURL_LIBS",         "@CURL_LIBS@",        "e" );
 ToFile( "SYSTEM_BOOST",      "@SYSTEM_BOOST@",     "e" );
+ToFile( "BOOST_THREAD_LIBS", "@BOOST_THREAD_LIBS@","e" );
 ToFile( "SYSTEM_MDDS",       "@SYSTEM_MDDS@",      "e" );
 ToFile( "SYSTEM_VIGRA",      "@SYSTEM_VIGRA@",     "e" );
 ToFile( "SYSTEM_NEON",       "@SYSTEM_NEON@",      "e" );
