diff --git ixion/ixion-0.2.0.diff ixion/ixion-0.2.0.diff
new file mode 100644
index 0000000..5aa43a6
--- /dev/null
+++ ixion/ixion-0.2.0.diff
@@ -0,0 +1,44 @@
+--- /dev/null
++++ misc/build/ixion-0.2.0/src/libixion/makefile.mk
+@@ -0,0 +1,41 @@
++EXTERNAL_WARNINGS_NOT_ERRORS := TRUE
++
++PRJ=..$/..$/..$/..$/..$/..
++
++PRJNAME=libixion
++TARGET=ixionlib
++ENABLE_EXCEPTIONS=TRUE
++LIBTARGET=NO
++
++.INCLUDE :  settings.mk
++
++CFLAGS+=-I..$/..$/inc -std=c++0x
++
++.IF "$(GUI)"=="WNT"
++CFLAGS+=-GR
++.ENDIF
++.IF "$(COM)"=="GCC"
++CFLAGSCXX+=-frtti
++.ENDIF
++
++SLOFILES= \
++			$(SLO)$/cell.obj \
++			$(SLO)$/cell_queue_manager.obj \
++			$(SLO)$/depends_tracker.obj \
++			$(SLO)$/formula_functions.obj \
++			$(SLO)$/formula_interpreter.obj \
++			$(SLO)$/formula_lexer.obj \
++			$(SLO)$/formula_parser.obj \
++			$(SLO)$/formula_result.obj \
++			$(SLO)$/formula_tokens.obj \
++			$(SLO)$/global.obj \
++			$(SLO)$/lexer_tokens.obj \
++			$(SLO)$/mem_str_buf.obj \
++			$(SLO)$/model_parser.obj \
++			$(SLO)$/sort_input_parser.obj \
++
++LIB1ARCHIV=$(LB)$/libixionlib.a
++LIB1TARGET=$(SLB)$/$(TARGET).lib
++LIB1OBJFILES= $(SLOFILES)
++
++.INCLUDE :  target.mk
diff --git ixion/makefile.mk ixion/makefile.mk
new file mode 100644
index 0000000..c847995
--- /dev/null
+++ ixion/makefile.mk
@@ -0,0 +1,50 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# Copyright 2000, 2010 Oracle and/or its affiliates.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=.
+
+PRJNAME=ixion
+TARGET=ixion
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :	settings.mk
+
+# --- Files --------------------------------------------------------
+
+TARFILE_NAME=ixion-0.2.0
+TARFILE_MD5=0f63ee487fda8f21fafa767b3c447ac9
+#PATCH_FILES=$(TARFILE_NAME).diff
+BUILD_ACTION=dmake $(MFLAGS) $(CALLMACROS)
+BUILD_DIR=src$/libixion
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : set_ext.mk
+.INCLUDE :	target.mk
+.INCLUDE :	tg_ext.mk
+
diff --git ixion/prj/build.lst ixion/prj/build.lst
new file mode 100644
index 0000000..0ac7093
--- /dev/null
+++ ixion/prj/build.lst
@@ -0,0 +1,3 @@
+ix  ixion :	solenv external NULL
+ix	ixion		usr1	-	all	ix_mkout NULL
+ix	ixion		nmake	-	all	ix_ixion	NULL
diff --git ixion/prj/d.lst ixion/prj/d.lst
new file mode 100644
index 0000000..2dbc5aa
--- /dev/null
+++ ixion/prj/d.lst
@@ -0,0 +1,4 @@
+mkdir: %_DEST%\inc%_EXT%\libwpd
+..\%__SRC%\misc\build\ixion*\inc\*.hpp %_DEST%\inc%_EXT%\ixion\
+..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
+..\%__SRC%\slb\*.lib %_DEST%\lib%_EXT%\*.lib
diff --git offapi/com/sun/star/text/XCell2.idl offapi/com/sun/star/text/XCell2.idl
new file mode 100644
index 0000000..a26625d
--- /dev/null
+++ offapi/com/sun/star/text/XCell2.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_text_XCell2_idl__
+#define __com_sun_star_text_XCell2_idl__
+
+#ifndef __com_sun_star_table_XCell_idl__
+#include <com/sun/star/table/XCell.idl>
+#endif
+
+//=============================================================================
+
+module com {  module sun {  module star {  module text {
+
+//=============================================================================
+
+/** provides methods to access the contents of a cell in a text table.
+ */
+interface XCell2: com::sun::star::table::XCell
+{
+    //-------------------------------------------------------------------------
+
+    /** returns true if the cell formula is in the WW format.
+     */
+    boolean isWWFormula();
+
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
diff --git offapi/com/sun/star/text/makefile.mk offapi/com/sun/star/text/makefile.mk
index 4e6d247..67c924b 100644
--- offapi/com/sun/star/text/makefile.mk
+++ offapi/com/sun/star/text/makefile.mk
@@ -203,6 +203,7 @@ IDLFILES=\
       XAutoTextGroup.idl\
       XBookmarkInsertTool.idl\
       XBookmarksSupplier.idl\
+	  XCell2.idl\
       XChapterNumberingSupplier.idl\
       XDefaultNumberingProvider.idl\
       XDependentTextField.idl\
diff --git ooo.lst ooo.lst
index 68105a8..3c5c782 100755
--- ooo.lst
+++ ooo.lst
@@ -75,6 +75,7 @@ http://download.go-oo.org/src
 90401bca927835b6fbae4a707ed187c8-nlpsolver-0.9.tar.bz2
 debc62758716a169df9f62e6ab2bc634-zlib-1.2.3.tar.gz
 e3738abd0d3ce1870dc1fd1f22bba5b1-icu4c-4_2_1-src.tgz
+0f63ee487fda8f21fafa767b3c447ac9-ixion-0.2.0.tar.gz
 http://download.go-oo.org/SRC680
 799fc3b835a79adce8c88a3fee0150c1-libwps-0.1.2.tar.gz
 db556b750bf3eac8481a4cc5e29e5af1-libwpg-0.1.3.tar.gz
diff --git solenv/inc/libs.mk solenv/inc/libs.mk
index 7e355b2..150c236 100644
--- solenv/inc/libs.mk
+++ solenv/inc/libs.mk
@@ -297,6 +297,8 @@ REDLANDLIB=-lrdf
 .ENDIF
 
 
+IXIONLIB=-lixionlib -lboost_thread-mt -pthread
+
 # #110743#
 # For BinFilters, some libs were added.
 #
diff --git sw/inc/cellatr.hxx sw/inc/cellatr.hxx
index 7fe6cc5..9a71f8b 100644
--- sw/inc/cellatr.hxx
+++ sw/inc/cellatr.hxx
@@ -56,13 +56,13 @@ public:
     void SetAutoFlag( BOOL bFlag = TRUE )		{ bAuto = bFlag; }
 };
 
-class SwTblBoxFormula : public SfxPoolItem, public SwTableFormula
+class SW_DLLPUBLIC SwTblBoxFormula : public SfxPoolItem, public SwTableFormula
 {
     SwModify* pDefinedIn;	// Modify-Object, in dem die Formel steht
                             // kann nur TablenBoxFormat sein
 
 public:
-    SwTblBoxFormula( const String& rFormula );
+    SwTblBoxFormula( const String& rFormula, bool bWwFormula = false );
 
     // "pure virtual Methoden" vom SfxPoolItem
     virtual int             operator==( const SfxPoolItem& ) const;
diff --git sw/inc/cellfml.hxx sw/inc/cellfml.hxx
index 7579256..7ff70f2 100644
--- sw/inc/cellfml.hxx
+++ sw/inc/cellfml.hxx
@@ -28,6 +28,7 @@
 #ifndef _CELLFML_HXX
 #define _CELLFML_HXX
 
+#include "swdllapi.h"
 #include <tools/string.hxx>
 
 class SwTable;
@@ -62,7 +63,7 @@ public:
 
 
 
-class SwTableFormula
+class SW_DLLPUBLIC SwTableFormula
 {
 typedef void (SwTableFormula:: *FnScanFormel)( const SwTable&, String&,
                                             String&, String*, void* ) const;
@@ -92,11 +93,14 @@ typedef void (SwTableFormula:: *FnScanFormel)( const SwTable&, String&,
                         void* = 0 ) const;
 
     const SwTable* FindTable( SwDoc& rDoc, const String& rNm ) const;
+    
+    bool        bWwFormula;
+    String 		sInputFormula;
+    String 		sSwFormula;            // Internal formula
 
 protected:
     enum NameType { EXTRNL_NAME, INTRNL_NAME, REL_NAME };
 
-    String 		sFormel;			// akt. Formel
     NameType 	eNmType;			// akt. Darstellungs Art
     BOOL 		bValidValue;		// TRUE: Formel neu berechnen
 
@@ -106,7 +110,7 @@ protected:
     // !!! MUSS VON JEDER ABLEITUNG UEBERLADEN WERDEN !!!
     virtual const SwNode* GetNodeOfFormula() const = 0;
 
-    SwTableFormula( const String& rFormel );
+    SwTableFormula( const String& rFormel, bool bWwFml = false );
 
     String MakeFormel( SwTblCalcPara& rCalcPara ) const
     {
@@ -122,9 +126,10 @@ public:
     virtual ~SwTableFormula();
     SwTableFormula& operator=( const SwTableFormula& rCpy )
         {
-                                    sFormel = rCpy.sFormel;
+                                    SetFormula( rCpy.GetFormula() );
                                     eNmType = rCpy.eNmType;
                                     bValidValue = rCpy.bValidValue;
+                                    bWwFormula = rCpy.bWwFormula;
                                     return *this;
         }
 
@@ -143,16 +148,13 @@ public:
     NameType GetNameType() const		{ return eNmType; }
 
     // erfrage/setze das Flag, ob der akt. Wert gueltig ist
-    BOOL 		IsValid() const				{ return bValidValue; }
-    inline void	ChgValid( BOOL bNew )		{ bValidValue = bNew; }
+    BOOL 		IsValid() const			{ return bValidValue; }
+    inline void	ChgValid( BOOL bNew )   { bValidValue = bNew; }
 
-    const String& GetFormula() const 		{ return sFormel; }
-    void SetFormula( const String& rNew )
-        {
-            sFormel = rNew;
-            bValidValue = FALSE;
-            eNmType = EXTRNL_NAME;
-        }
+    const String& GetFormula() const { return sInputFormula; }
+    void SetFormula( const String& rNew );
+
+    bool IsWWFormula( ) const { return bWwFormula; }
 
     USHORT GetBoxesOfFormula( const SwTable& rTbl, SwSelBoxes& rBoxes );
     // sind alle Boxen gueltig, auf die sich die Formel bezieht?
diff --git sw/inc/unotbl.hxx sw/inc/unotbl.hxx
index 7aa83d8..acbaeba 100644
--- sw/inc/unotbl.hxx
+++ sw/inc/unotbl.hxx
@@ -35,6 +35,7 @@
 #include <com/sun/star/chart2/data/XLabeledDataSequence.hpp>
 #include <com/sun/star/text/XTextTableCursor.hpp>
 #include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/XCell2.hpp>
 #include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/sheet/XCellRangeData.hpp>
 #include <com/sun/star/table/XAutoFormattable.hpp>
@@ -80,7 +81,7 @@ class SwChartEventListenerContainer : public SwEventListenerContainer
 typedef
 cppu::WeakImplHelper4
 <
-    ::com::sun::star::table::XCell,
+    ::com::sun::star::text::XCell2,
     ::com::sun::star::lang::XServiceInfo,
     ::com::sun::star::beans::XPropertySet,
     ::com::sun::star::container::XEnumerationAccess
@@ -142,7 +143,10 @@ public:
     virtual void SAL_CALL setValue( double nValue ) throw(::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::table::CellContentType SAL_CALL getType(  ) throw(::com::sun::star::uno::RuntimeException);
     virtual sal_Int32 SAL_CALL getError(  ) throw(::com::sun::star::uno::RuntimeException);
-
+    
+    //XCell2
+    virtual sal_Bool SAL_CALL isWWFormula(  ) throw(::com::sun::star::uno::RuntimeException);
+    
     //XText
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextCursor >  SAL_CALL createTextCursor(void) throw( ::com::sun::star::uno::RuntimeException );
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextCursor >  SAL_CALL createTextCursorByRange(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & aTextPosition) throw( ::com::sun::star::uno::RuntimeException );
diff --git sw/prj/build.lst sw/prj/build.lst
index 64894fd..d79986c 100755
--- sw/prj/build.lst
+++ sw/prj/build.lst
@@ -1,4 +1,4 @@
-sw      sw      :    filter l10n connectivity OOo:writerperfect OOo:lotuswordpro vbahelper svx stoc writerfilter NULL
+sw      sw      :    filter l10n connectivity OOo:writerperfect OOo:lotuswordpro vbahelper svx stoc writerfilter ixion NULL
 sw	sw										usr1	-	all	sw_mkout NULL
 sw	sw\inc									nmake		-	all	sw_inc NULL
 sw	sw\uiconfig\layout									nmake	-	all	sw_layout NULL
diff --git sw/source/core/attr/cellatr.cxx sw/source/core/attr/cellatr.cxx
index 7285d15..0ec204d 100644
--- sw/source/core/attr/cellatr.cxx
+++ sw/source/core/attr/cellatr.cxx
@@ -76,9 +76,9 @@ SfxPoolItem* SwTblBoxNumFormat::Clone( SfxItemPool* ) const
 
 
 
-SwTblBoxFormula::SwTblBoxFormula( const String& rFormula )
+SwTblBoxFormula::SwTblBoxFormula( const String& rFormula, bool bWwFml )
     : SfxPoolItem( RES_BOXATR_FORMULA ),
-    SwTableFormula( rFormula ),
+    SwTableFormula( rFormula, bWwFml ),
     pDefinedIn( 0 )
 {
 }
@@ -95,7 +95,7 @@ int SwTblBoxFormula::operator==( const SfxPoolItem& rAttr ) const
 SfxPoolItem* SwTblBoxFormula::Clone( SfxItemPool* ) const
 {
 // auf externe Darstellung umschalten!!
-    SwTblBoxFormula* pNew = new SwTblBoxFormula( GetFormula() );
+    SwTblBoxFormula* pNew = new SwTblBoxFormula( GetFormula(), IsWWFormula() );
     pNew->SwTableFormula::operator=( *this );
     return pNew;
 }
diff --git sw/source/core/fields/cellfml.cxx sw/source/core/fields/cellfml.cxx
index fb98a31..4227bb3 100644
--- sw/source/core/fields/cellfml.cxx
+++ sw/source/core/fields/cellfml.cxx
@@ -51,6 +51,14 @@
 #include <cellatr.hxx>
 #include <ndindex.hxx>
 
+#include <sstream>
+#include <string>
+
+#include <ixion/cell.hpp>
+#include <ixion/formula_functions.hpp>
+#include <ixion/formula_lexer.hpp>
+#include <ixion/formula_parser.hpp>
+
 const sal_Unicode cRelTrenner = ',';
 const sal_Unicode cRelKennung = '';		// CTRL-R
 
@@ -307,11 +315,10 @@ BOOL SwTblCalcPara::CalcWithStackOverflow()
 
 /*  */
 
-SwTableFormula::SwTableFormula( const String& rFormel )
-    : sFormel( rFormel )
+SwTableFormula::SwTableFormula( const String& rFormel, bool bWwFml )
+    : bWwFormula( bWwFml )
 {
-    eNmType = EXTRNL_NAME;
-    bValidValue = FALSE;
+    SetFormula( rFormel );
 }
 
 SwTableFormula::~SwTableFormula()
@@ -555,7 +562,7 @@ void SwTableFormula::PtrToBoxNm( const SwTable* pTbl )
     case EXTRNL_NAME:
         return;
     }
-    sFormel = ScanString( fnFormel, *pTbl, (void*)pNd );
+    sSwFormula = ScanString( fnFormel, *pTbl, (void*)pNd );
     eNmType = EXTRNL_NAME;
 }
 
@@ -580,7 +587,7 @@ void SwTableFormula::BoxNmToPtr( const SwTable* pTbl )
     case INTRNL_NAME:
         return;
     }
-    sFormel = ScanString( fnFormel, *pTbl, (void*)pNd );
+    sSwFormula = ScanString( fnFormel, *pTbl, (void*)pNd );
     eNmType = INTRNL_NAME;
 }
 
@@ -602,11 +609,138 @@ void SwTableFormula::ToRelBoxNm( const SwTable* pTbl )
     case REL_NAME:
         return;
     }
-    sFormel = ScanString( fnFormel, *pTbl, (void*)pNd );
+    sSwFormula = ScanString( fnFormel, *pTbl, (void*)pNd );
     eNmType = REL_NAME;
 }
 
 
+class token_converter : public std::unary_function<ixion::formula_token_base, void>
+{
+public:
+    token_converter(std::ostringstream& os) : m_os(os), m_in_and_or(false) {}
+
+    void operator() (const ixion::formula_token_base& token)
+    {
+        switch (token.get_opcode())
+        {
+            case ixion::fop_unresolved_ref:
+                // Add <> around the name
+                m_os << "<" << token.get_name() << ">";
+                break;
+            case ixion::fop_sep:
+                if ( m_in_and_or )
+                {
+                    m_os << m_pending_func_name;
+                    m_in_and_or = false;
+                    m_pending_func_name = std::string();
+                }
+                else
+                    m_os << "|";
+                break;
+            case ixion::fop_function:
+                {
+                    ixion::formula_function_t func_oc = ixion::formula_functions::get_function_opcode(token);
+                    std::string func_name( ixion::formula_functions::get_function_name(func_oc) );
+
+                    m_in_and_or = false;
+
+                    if ( func_name.compare( "AVERAGE" ) == 0 )
+                    {
+                        m_os << "MEAN";
+                    }
+                    else if ( ( func_name.compare( "AND" ) == 0 ) ||
+                            ( func_name.compare( "OR" ) == 0 ) )
+                    {
+                        //   AND(x, y) -> x AND y
+                        //   OR(x, y)  -> x OR y
+                        m_in_and_or = true;
+                        m_pending_func_name = func_name;
+                    } 
+                    else
+                    {
+                        m_os << func_name;
+                    }
+                }
+                break;
+            case ixion::fop_value:
+                m_os << token.get_value();
+                break;
+            case ixion::fop_plus:
+                m_os << "+";
+                break;
+            case ixion::fop_minus:
+                m_os << "-";
+                break;
+            case ixion::fop_multiply:
+                m_os << "*";
+                break;
+            case ixion::fop_divide:
+                m_os << "/";
+                break;
+            case ixion::fop_open:
+                m_os << "(";
+                break;
+            case ixion::fop_close:
+                m_os << ")";
+                break;
+            default:
+                ;
+        }
+    }
+
+private:
+    std::ostringstream& m_os;
+
+    bool m_in_and_or;
+    std::string m_pending_func_name;
+};
+
+String lcl_ConvertWWFormula( const String& rWWFormula )
+{
+    ixion::mem_str_buf sFormulaBuf;
+    ByteString sAsciiFormula( rWWFormula, RTL_TEXTENCODING_UTF8 );
+    sFormulaBuf.set_start( sAsciiFormula.ToUpperAscii().GetBufferAccess() );
+    for ( int i = 0; i < rWWFormula.Len() - 1; i++ )
+        sFormulaBuf.inc();
+
+    ixion::lexer_tokens_t ltokens;
+
+    // Run the lexer
+    ixion::formula_lexer lexer( sFormulaBuf );
+    lexer.tokenize( );
+    lexer.swap_tokens( ltokens );
+
+    // Run the parser
+    ixion::cell_name_ptr_map_t cell_names;
+
+    ixion::formula_parser parser( ltokens, &cell_names, true );
+    parser.parse();
+
+    ixion::formula_tokens_t ftokens;
+    ftokens.swap( parser.get_tokens() );
+
+    // Convert the tokens to Writer formula string
+    std::ostringstream os;
+    for_each( ftokens.begin(), ftokens.end(), token_converter(os) );
+
+    return String::CreateFromAscii( os.str().c_str() );
+}
+
+void SwTableFormula::SetFormula( const String& rNew )
+{
+    sInputFormula = rNew;
+    sSwFormula = rNew;
+
+    bValidValue = FALSE;
+    eNmType = EXTRNL_NAME;
+    
+    if ( bWwFormula )
+    {
+        // Convert the sInputFormula into a Sw formula and store it in sSwFormula
+        sSwFormula = lcl_ConvertWWFormula( sInputFormula );
+    }
+}
+
 String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
                                     void* pPara ) const
 {
@@ -618,24 +752,24 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
         // benutzen !!
         const SwTable* pTbl = &rTbl;
 
-        nStt = sFormel.Search( '<', nFml );
+        nStt = sSwFormula.Search( '<', nFml );
         if( STRING_NOTFOUND != nStt )
         {
             while( STRING_NOTFOUND != nStt &&
-                ( ' ' == sFormel.GetChar( nStt + 1 ) ||
-                  '=' == sFormel.GetChar( nStt + 1 ) ) )
-                nStt = sFormel.Search( '<', nStt + 1 );
+                ( ' ' == sSwFormula.GetChar( nStt + 1 ) ||
+                  '=' == sSwFormula.GetChar( nStt + 1 ) ) )
+                nStt = sSwFormula.Search( '<', nStt + 1 );
 
             if( STRING_NOTFOUND != nStt )
-                nEnd = sFormel.Search( '>', nStt+1 );
+                nEnd = sSwFormula.Search( '>', nStt+1 );
         }
         if( STRING_NOTFOUND == nStt || STRING_NOTFOUND == nEnd )
         {
             // den Rest setzen und beenden
-            aStr.Insert( sFormel, nFml, sFormel.Len() - nFml );
+            aStr.Insert( sSwFormula, nFml, sSwFormula.Len() - nFml );
             break;
         }
-        aStr.Insert( sFormel, nFml, nStt - nFml );	// Anfang schreiben
+        aStr.Insert( sSwFormula, nFml, nStt - nFml );	// Anfang schreiben
 
         if( fnFormel != NULL )
         {
@@ -644,11 +778,11 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
             // JP 22.02.99: der CAST muss fuer den Linux-Compiler sein
             // JP 28.06.99: rel. BoxName have no preceding tablename!
             if( fnFormel != (FnScanFormel)&SwTableFormula::_SplitMergeBoxNm &&
-                1 < sFormel.Len() && cRelKennung != sFormel.GetChar( 1 ) &&
-                STRING_NOTFOUND != ( nTrenner = sFormel.Search( '.', nStt ))
+                1 < sSwFormula.Len() && cRelKennung != sSwFormula.GetChar( 1 ) &&
+                STRING_NOTFOUND != ( nTrenner = sSwFormula.Search( '.', nStt ))
                 && nTrenner < nEnd )
             {
-                String sTblNm( sFormel.Copy( nStt, nEnd - nStt ));
+                String sTblNm( sSwFormula.Copy( nStt, nEnd - nStt ));
 
                 // falls im Namen schon die Punkte enthalten sind,
                 // treten diese immer paarig auf!!! (A1.1.1 !!)
@@ -677,13 +811,13 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
                 }
             }
 
-            String sBox( sFormel.Copy( nStt, nEnd - nStt + 1 ));
+            String sBox( sSwFormula.Copy( nStt, nEnd - nStt + 1 ));
             // ein Bereich in dieser Klammer ?
-            if( STRING_NOTFOUND != ( nTrenner = sFormel.Search( ':', nStt ))
+            if( STRING_NOTFOUND != ( nTrenner = sSwFormula.Search( ':', nStt ))
                 && nTrenner < nEnd )
             {
                 // ohne die Anfangsklammer
-                String aFirstBox( sFormel.Copy( nStt+1, nTrenner - nStt - 1 ));
+                String aFirstBox( sSwFormula.Copy( nStt+1, nTrenner - nStt - 1 ));
                 (this->*fnFormel)( *pTbl, aStr, sBox, &aFirstBox, pPara );
             }
             else
@@ -692,6 +826,7 @@ String SwTableFormula::ScanString( FnScanFormel fnFormel, const SwTable& rTbl,
 
         nFml = nEnd+1;
     } while( TRUE );
+
     return aStr;
 }
 
@@ -1225,7 +1360,7 @@ void SwTableFormula::ToSplitMergeBoxNm( SwTableFmlUpdate& rTblUpd )
     else
         pTbl = rTblUpd.pTbl;
 
-    sFormel = ScanString( &SwTableFormula::_SplitMergeBoxNm, *pTbl, (void*)&rTblUpd );
+    sSwFormula = ScanString( &SwTableFormula::_SplitMergeBoxNm, *pTbl, (void*)&rTblUpd );
     eNmType = INTRNL_NAME;
 }
 
diff --git sw/source/core/fields/makefile.mk sw/source/core/fields/makefile.mk
index 280fff6..f8cd35e 100644
--- sw/source/core/fields/makefile.mk
+++ sw/source/core/fields/makefile.mk
@@ -86,7 +86,8 @@ SLOFILES =	\
 EXCEPTIONSFILES = \
         $(SLO)$/flddropdown.obj \
         $(SLO)$/postithelper.obj \
-        $(SLO)$/docufld.obj 
+        $(SLO)$/docufld.obj \
+        $(SLO)$/cellfml.obj
 
 # --- Tagets -------------------------------------------------------
 
diff --git sw/source/core/unocore/unotbl.cxx sw/source/core/unocore/unotbl.cxx
index 9dd21a4..5abce43 100644
--- sw/source/core/unocore/unotbl.cxx
+++ sw/source/core/unocore/unotbl.cxx
@@ -1063,6 +1063,19 @@ sal_Int32 SwXCell::getError(void) throw( uno::RuntimeException )
     OUString sContent = getString();
     return sContent.equals(ViewShell::GetShellRes()->aCalc_Error);
 }
+
+sal_Bool SwXCell::isWWFormula(  ) throw( uno::RuntimeException )
+{
+    vos::OGuard aGuard(Application::GetSolarMutex());
+    sal_Bool sRet = sal_False;
+    if(IsValid())
+    {
+        SwTblBoxFormula aFormula( pBox->GetFrmFmt()->GetTblBoxFormula() );
+        sRet = aFormula.IsWWFormula( );
+    }
+    return sRet;
+}
+
 /*-- 11.12.98 10:56:28---------------------------------------------------
 
   -----------------------------------------------------------------------*/
diff --git sw/source/filter/ww8/wrtw8nds.cxx sw/source/filter/ww8/wrtw8nds.cxx
index 3191b6b..0095089 100644
--- sw/source/filter/ww8/wrtw8nds.cxx
+++ sw/source/filter/ww8/wrtw8nds.cxx
@@ -104,6 +104,7 @@
 #include "ww8par.hxx"
 #include <IMark.hxx>
 #include "ww8attributeoutput.hxx"
+#include "cellatr.hxx"
 
 #include <ndgrf.hxx>
 #include <ndole.hxx>
@@ -1812,6 +1813,22 @@ void MSWordExportBase::OutputTextNode( const SwTxtNode& rNode )
         bool bTxtAtr = aAttrIter.IsTxtAttr( nAktPos );
         nOpenAttrWithRange += aAttrIter.OutAttrWithRange(nAktPos);
 
+        bool bOutTableFormula = false;
+
+        // Check if a formula is defined on the cell
+        if ( pTextNodeInfo.get() != NULL )
+        {
+            const SwTableBox* pBox = pTextNodeInfo.get()->getTableBox( );
+            const SwTblBoxFormula& rFml = pBox->GetFrmFmt()->GetTblBoxFormula();
+            bOutTableFormula = ( rFml.GetFormula().Len( ) > 0 );
+            if ( bOutTableFormula )
+            {
+                String sFormula = String::CreateFromAscii( "=" ).Append( rFml.GetFormula( ) );
+                OutputField( NULL, ww::eEquals, sFormula, WRITEFIELD_START | WRITEFIELD_CMD_START );  
+                OutputField( NULL, ww::eEquals, String(), WRITEFIELD_CMD_END );  
+            }
+        }
+
         xub_StrLen nLen = nNextAttr - nAktPos;
         if ( !bTxtAtr && nLen )
         {
@@ -1925,6 +1942,9 @@ void MSWordExportBase::OutputTextNode( const SwTxtNode& rNode )
             }
             AttrOutput().RunText( aSnippet, eChrSet );
         }
+            
+        if ( bOutTableFormula )
+            OutputField( NULL, ww::eEquals, String(), WRITEFIELD_CLOSE );  
 
         if ( aAttrIter.IsDropCap( nNextAttr ) )
             AttrOutput().FormatDrop( rNode, aAttrIter.GetSwFmtDrop(), nStyle, pTextNodeInfo, pTextNodeInfoInner );
diff --git sw/source/filter/ww8/ww8par.hxx sw/source/filter/ww8/ww8par.hxx
index 6cddc25..f2483b2 100644
--- sw/source/filter/ww8/ww8par.hxx
+++ sw/source/filter/ww8/ww8par.hxx
@@ -1559,6 +1559,7 @@ public:     // eigentlich private, geht aber leider nur public
     eF_ResT Read_F_FileName( WW8FieldDesc*, String& rStr);
     eF_ResT Read_F_Anz( WW8FieldDesc* pF, String& );
     eF_ResT Read_F_CurPage( WW8FieldDesc*, String& );
+    eF_ResT Read_F_Formula( WW8FieldDesc*, String& );
     eF_ResT Read_F_Ref( WW8FieldDesc* pF, String& );
 
     eF_ResT Read_F_Set( WW8FieldDesc*, String& rStr );
diff --git sw/source/filter/ww8/ww8par2.cxx sw/source/filter/ww8/ww8par2.cxx
index 5207ef6..f8ee2a0 100644
--- sw/source/filter/ww8/ww8par2.cxx
+++ sw/source/filter/ww8/ww8par2.cxx
@@ -66,6 +66,7 @@
 #include <fltshell.hxx>         // fuer den Attribut Stack
 #include <fmtanchr.hxx>
 #include <fmtrowsplt.hxx>
+#include <cellatr.hxx>
 // --> OD 2005-01-27 #i33818#
 #include <fmtfollowtextflow.hxx>
 // <--
@@ -80,6 +81,10 @@
 
 #include <iostream>
 
+#if DEBUG
+#include <cstdio>
+#endif
+
 #define MAX_COL 64  // WW6-Beschreibung: 32, WW6-UI: 31 & WW8-UI: 63!
 
 using namespace ::com::sun::star;
@@ -270,6 +275,8 @@ public:
     const String& GetNumRuleName() const;
     void SetNumRuleName( const String& rName );
 
+    void SetCellFormula( SwDoc& rDoc, String& rName, String& rFormat );
+
     sw::util::RedlineStack* getOldRedlineStack(){ return mpOldRedlineStack; }
 };
 
@@ -3460,6 +3467,59 @@ void WW8TabDesc::SetNumRuleName( const String& rName )
     aNumRuleNames[nCol] = rName;
 }
 
+void WW8TabDesc::SetCellFormula( SwDoc& rDoc, String& rFml, String& rFormat )
+{
+    SfxItemSet aBoxSet( rDoc.GetAttrPool(), RES_BOXATR_FORMAT, RES_BOXATR_FORMULA );
+
+    if( rFml.EraseLeadingChars().Len() &&
+            '=' == rFml.GetChar( 0 ) )
+        rFml.Erase( 0, 1 );
+    aBoxSet.Put( SwTblBoxFormula( rFml, true ) );
+    
+    if ( rFormat.Len() > 0 )
+    {
+        SvNumberFormatter* pFormatter = rDoc.GetNumberFormatter();
+        sal_uInt32 nKey = pFormatter->GetEntryKey( rFormat );
+        aBoxSet.Put( SwTblBoxNumFormat( nKey ) );
+    }
+
+    rDoc.SetTblBoxFormulaAttrs( *pTabBox, aBoxSet );
+}
+
+eF_ResT SwWW8ImplReader::Read_F_Formula( WW8FieldDesc*, String& rStr )
+{
+    // Look for the first switch
+    xub_StrLen nPos = rStr.Search( '\\' );
+    String sFml = rStr.Copy( 0, nPos );
+    String sSwitches = rStr.Copy( nPos );
+   
+    // Numeric formatting
+    String sFormat;
+    xub_StrLen nNumSwitchPos = sSwitches.SearchAscii( "\\#", 0 );
+    if ( nNumSwitchPos != STRING_NOTFOUND )
+    {
+        xub_StrLen nStart = nNumSwitchPos + 1;
+        xub_StrLen nEnd = sSwitches.Len() - 1;
+        
+        xub_StrLen nQuotePos = sSwitches.SearchAscii( "\"", nNumSwitchPos );
+        if ( nQuotePos != STRING_NOTFOUND )
+        {
+            nStart = nQuotePos + 1;
+            nEnd = sSwitches.SearchAscii( "\"", nStart + 1 );
+        }
+
+        sFormat = sSwitches.Copy( nStart, nEnd - nStart ).EraseAllChars();
+#if DEBUG
+        fprintf( stderr, "TODO SwWW8ImplReader::Read_F_Formula() - Numeric format: %s\n",
+              ByteString( sFormat, RTL_TEXTENCODING_UTF8 ).GetBufferAccess() );
+#endif
+    }
+    
+    pTableDesc->SetCellFormula( GetDoc(), sFml, sFormat );
+
+    return FLD_OK;
+}
+
 bool SwWW8ImplReader::StartTable(WW8_CP nStartCp)
 {
     // Entering a table so make sure the the FirstPara flag gets set
diff --git sw/source/filter/ww8/ww8par5.cxx sw/source/filter/ww8/ww8par5.cxx
index 950ad48..121ff1b 100644
--- sw/source/filter/ww8/ww8par5.cxx
+++ sw/source/filter/ww8/ww8par5.cxx
@@ -940,7 +940,7 @@ long SwWW8ImplReader::Read_Field(WW8PLCFManResult* pRes)
         &SwWW8ImplReader::Read_F_DateTime,          // 31
         &SwWW8ImplReader::Read_F_DateTime,          // 32
         &SwWW8ImplReader::Read_F_CurPage,           // 33
-        0,
+        &SwWW8ImplReader::Read_F_Formula,           // 34
         0,
         &SwWW8ImplReader::Read_F_IncludeText,       // 36
         &SwWW8ImplReader::Read_F_PgRef,             // 37
diff --git sw/source/filter/xml/xmltble.cxx sw/source/filter/xml/xmltble.cxx
index 857d8db..88ff607 100644
--- sw/source/filter/xml/xmltble.cxx
+++ sw/source/filter/xml/xmltble.cxx
@@ -61,7 +61,6 @@
 #include "xmltexte.hxx"
 #include "xmlexp.hxx"
 
-
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
 using namespace ::com::sun::star;
@@ -71,7 +70,7 @@ using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::container;
 using namespace ::xmloff::token;
-using table::XCell;
+using text::XCell2;
 
 
 class SwXMLTableColumn_Impl : public SwWriteTableCol
@@ -707,7 +706,7 @@ void SwXMLExport::ExportTableLinesAutoStyles( const SwTableLines& rLines,
                                        bTop) )
                     ExportFmt( *pFrmFmt2, XML_TABLE_CELL );
 
-                Reference < XCell > xCell = SwXCell::CreateXCell(
+                Reference < XCell2 > xCell = SwXCell::CreateXCell(
                                                 (SwFrmFmt *)rTblInfo.GetTblFmt(),
                                                   pBox,
                                                  (SwTable *)rTblInfo.GetTable() );
@@ -835,7 +834,7 @@ void SwXMLExport::ExportTableBox( const SwTableBox& rBox,
             // start node -> normal cell
 
             // get cell range for table
-            Reference<XCell> xCell = SwXCell::CreateXCell( (SwFrmFmt *)rTblInfo.GetTblFmt(),
+            Reference<XCell2> xCell = SwXCell::CreateXCell( (SwFrmFmt *)rTblInfo.GetTblFmt(),
                                                             (SwTableBox *)&rBox,
                                                             (SwTable *)rTblInfo.GetTable() );
 
@@ -850,9 +849,13 @@ void SwXMLExport::ExportTableBox( const SwTableBox& rBox,
                 //     (with value and number format)
                 if (sCellFormula.getLength()>0)
                 {
+                    sal_uInt16 nPrefix = XML_NAMESPACE_OOOW;
+                    if ( xCell->isWWFormula() )
+                        nPrefix = XML_NAMESPACE_FIELD;
+
                     OUString sQValue =
                         GetNamespaceMap().GetQNameByKey(
-                                XML_NAMESPACE_OOOW, sCellFormula, sal_False );
+                                nPrefix, sCellFormula, sal_False );
                     // formula
                     AddAttribute(XML_NAMESPACE_TABLE, XML_FORMULA, sQValue );
                 }
diff --git sw/source/filter/xml/xmltbli.cxx sw/source/filter/xml/xmltbli.cxx
index c3beb63..1278fc7 100644
--- sw/source/filter/xml/xmltbli.cxx
+++ sw/source/filter/xml/xmltbli.cxx
@@ -186,6 +186,7 @@ class SwXMLTableCell_Impl
     sal_Bool bHasValue;	// determines whether dValue attribute is valid
     sal_Bool mbCovered;
     sal_Bool mbTextValue;
+    sal_Bool mbWWFormula;
 
 public:
 
@@ -194,7 +195,8 @@ public:
         nRowSpan( nRSpan ),
         nColSpan( nCSpan ),
         bProtected( sal_False ),
-        mbCovered( sal_False )
+        mbCovered( sal_False ),
+        mbWWFormula( sal_False )
         {}
 
     inline void Set( const OUString& rStyleName,
@@ -206,7 +208,8 @@ public:
                      sal_Bool mbCovered = sal_False,
                      double dVal = 0.0,
                      sal_Bool mbTextValue = sal_False,
-                     OUString const& i_rXmlId = OUString());
+                     OUString const& i_rXmlId = OUString(),
+                     sal_Bool bWWFormula = sal_False );
 
     sal_Bool IsUsed() const { return pStartNode!=0 ||
                                      xSubTable.Is() || bProtected;}
@@ -222,6 +225,7 @@ public:
     sal_Bool IsCovered() const { return mbCovered; }
     sal_Bool HasTextValue() const { return mbTextValue; }
     const OUString& GetXmlId() const { return mXmlId; }
+    sal_Bool IsWWFormula() const { return mbWWFormula; }
 
     const SwStartNode *GetStartNode() const { return pStartNode; }
     inline void SetStartNode( const SwStartNode *pSttNd );
@@ -241,7 +245,8 @@ inline void SwXMLTableCell_Impl::Set( const OUString& rStyleName,
                                       sal_Bool bCov,
                                       double dVal,
                                       sal_Bool bTextVal,
-                                      OUString const& i_rXmlId )
+                                      OUString const& i_rXmlId,
+                                      sal_Bool bWWFormula )
 {
     aStyleName = rStyleName;
     nRowSpan = nRSpan;
@@ -253,6 +258,7 @@ inline void SwXMLTableCell_Impl::Set( const OUString& rStyleName,
     mbCovered = bCov;
     mbTextValue = bTextVal;
     bProtected = bProtect;
+    mbWWFormula = bWWFormula;
 
     if (!mbCovered) // ensure uniqueness
     {
@@ -398,6 +404,7 @@ class SwXMLTableCellContext_Impl : public SvXMLImportContext
 {
     OUString aStyleName;
     OUString sFormula;
+    sal_Bool bWWFormula;
     OUString sSaveParaDefault;
     OUString mXmlId;
 
@@ -446,6 +453,7 @@ SwXMLTableCellContext_Impl::SwXMLTableCellContext_Impl(
         SwXMLTableContext *pTable ) :
     SvXMLImportContext( rImport, nPrfx, rLName ),
     sFormula(),
+    bWWFormula( sal_False ),
     xMyTable( pTable ),
     fValue( 0.0 ),
     bHasValue( sal_False ),
@@ -499,7 +507,12 @@ SwXMLTableCellContext_Impl::SwXMLTableCellContext_Impl(
                 OUString sTmp;
                 sal_uInt16 nPrefix2 = GetImport().GetNamespaceMap().
                         _GetKeyByAttrName( rValue, &sTmp, sal_False );
-                sFormula = XML_NAMESPACE_OOOW == nPrefix2 ? sTmp : rValue;
+                bWWFormula = ( nPrefix2 == XML_NAMESPACE_FIELD );
+                if ( ( XML_NAMESPACE_OOOW == nPrefix2 ) ||
+                     ( XML_NAMESPACE_FIELD == nPrefix2 ) )
+                    sFormula = sTmp;
+                else
+                    sFormula = rValue;
             }
             break;
         case XML_TOK_TABLE_VALUE:
@@ -570,7 +583,7 @@ inline void SwXMLTableCellContext_Impl::_InsertContent()
     GetTable()->InsertCell( aStyleName, nRowSpan, nColSpan,
                             GetTable()->InsertTableSection(),
                             mXmlId,
-                            NULL, bProtect, &sFormula, bHasValue, fValue, bHasTextValue );
+                            NULL, bProtect, &sFormula, bHasValue, fValue, bHasTextValue, bWWFormula );
 }
 
 inline void SwXMLTableCellContext_Impl::InsertContent()
@@ -1590,7 +1603,8 @@ void SwXMLTableContext::InsertCell( const OUString& rStyleName,
                                     const OUString* pFormula,
                                     sal_Bool bHasValue,
                                     double fValue,
-                                    sal_Bool bTextValue )
+                                    sal_Bool bTextValue,
+                                    sal_Bool bWWFormula )
 {
     ASSERT( nCurCol < GetColumnCount(),
             "SwXMLTableContext::InsertCell: row is full" );
@@ -1686,7 +1700,7 @@ void SwXMLTableContext::InsertCell( const OUString& rStyleName,
             GetCell( nRowsReq-j, nColsReq-i )
                 ->Set( sStyleName, j, i, pStartNode,
                        pTable, bProtect, pFormula, bHasValue, bCovered, fValue,
-                       bTextValue, i_rXmlId );
+                       bTextValue, i_rXmlId, bWWFormula );
         }
     }
 
@@ -1756,7 +1770,8 @@ void SwXMLTableContext::InsertRepRows( sal_uInt32 nCount )
                             0, pSrcCell->IsProtected(),
                             &pSrcCell->GetFormula(),
                             pSrcCell->HasValue(), pSrcCell->GetValue(),
-                            pSrcCell->HasTextValue() );
+                            pSrcCell->HasTextValue(),
+                            pSrcCell->IsWWFormula() );
             }
         }
         FinishRow();
@@ -2156,7 +2171,7 @@ SwTableBox *SwXMLTableContext::MakeTableBox(
             if (rFormula.getLength() > 0)
             {
                 // formula cell: insert formula if valid
-                SwTblBoxFormula aFormulaItem( rFormula );
+                SwTblBoxFormula aFormulaItem( rFormula, pCell->IsWWFormula() );
                 pBoxFmt2->SetFmtAttr( aFormulaItem );
             }
             else if( !pCell->HasValue() && pCell->HasTextValue() )
diff --git sw/source/filter/xml/xmltbli.hxx sw/source/filter/xml/xmltbli.hxx
index 10858ef..be3d18f 100644
--- sw/source/filter/xml/xmltbli.hxx
+++ sw/source/filter/xml/xmltbli.hxx
@@ -184,7 +184,8 @@ public:
                      const ::rtl::OUString *pFormula=0,
                      sal_Bool bHasValue = sal_False,
                      double fValue = 0.0,
-                     sal_Bool bTextValue = sal_False );
+                     sal_Bool bTextValue = sal_False,
+                     sal_Bool bWWFormula = sal_False );
     void InsertRow( const ::rtl::OUString& rStyleName,
                     const ::rtl::OUString& rDfltCellStyleName,
                     sal_Bool bInHead,
diff --git sw/source/ui/shells/textsh1.cxx sw/source/ui/shells/textsh1.cxx
index 760e4d7..50267b1 100644
--- sw/source/ui/shells/textsh1.cxx
+++ sw/source/ui/shells/textsh1.cxx
@@ -769,8 +769,15 @@ void SwTextShell::Execute(SfxRequest &rReq)
                 {
                     if( rWrtSh.IsCrsrInTbl() )
                     {
+                        // Get the formula item or the default one
                         SfxItemSet aSet( rWrtSh.GetAttrPool(), RES_BOXATR_FORMULA, RES_BOXATR_FORMULA );
-                        aSet.Put( SwTblBoxFormula( sFormula ));
+                        rWrtSh.GetTblBoxFormulaAttrs( aSet );
+                        SwTblBoxFormula& aTblBoxFormula = (SwTblBoxFormula&)aSet.Get( RES_BOXATR_FORMULA );
+                        aTblBoxFormula.SetFormula( sFormula );
+
+                        if ( aSet.GetItemState( RES_BOXATR_FORMULA ) == SFX_ITEM_DEFAULT )
+                            aSet.Put( aTblBoxFormula );
+
                         rWrtSh.SetTblBoxFormulaAttrs( aSet );
                         rWrtSh.UpdateTable();
                     }
diff --git sw/util/makefile.mk sw/util/makefile.mk
index 24ad295..7625b28 100644
--- sw/util/makefile.mk
+++ sw/util/makefile.mk
@@ -120,7 +120,8 @@ SHL1STDLIBS+= \
     $(ICUUCLIB) \
     $(I18NUTILLIB)
 SHL1STDLIBS+= \
-    $(AVMEDIALIB)
+    $(AVMEDIALIB) \
+	$(IXIONLIB)
 
 .IF "$(GUI)"=="WNT"
 SHL1STDLIBS+= $(ADVAPI32LIB)
