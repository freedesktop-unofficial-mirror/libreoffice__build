diff --git offapi/com/sun/star/style/NumberingType.idl offapi/com/sun/star/style/NumberingType.idl
index 506e5ad..8a408f6 100644
--- offapi/com/sun/star/style/NumberingType.idl
+++ offapi/com/sun/star/style/NumberingType.idl
@@ -121,6 +121,7 @@ published constants NumberingType
 
     //-------------------------------------------------------------------------
     /** Numbering for Chinese lower case number
+        as "一,二,三..."
      */
     const short NUMBER_LOWER_ZH = 15;
 
@@ -136,11 +137,13 @@ published constants NumberingType
 
     //-------------------------------------------------------------------------
     /** Bullet for Chinese Tian Gan
+        as "甲,乙,丙..."
      */
     const short TIAN_GAN_ZH = 18;
 
     //-------------------------------------------------------------------------
     /** Bullet for Chinese Di Zi
+        as "子,丑,寅..."
      */
     const short DI_ZI_ZH = 19;
 
@@ -171,36 +174,43 @@ published constants NumberingType
 
     //-------------------------------------------------------------------------
     /** Numbering for Korean upper case number
+        as "壹,貳,參..."
      */
     const short NUMBER_UPPER_KO = 25;
 
     //-------------------------------------------------------------------------
     /** Numbering for Korean hangul number
+        as "일,이,삼..."
      */
     const short NUMBER_HANGUL_KO = 26;
 
     //-------------------------------------------------------------------------
     /** Bullet for Korean Hangul Jamo
+        as "ㄱ,ㄴ,ㄷ..."
      */
     const short HANGUL_JAMO_KO = 27;
 
     //-------------------------------------------------------------------------
     /** Bullet for Korean Hangul Syllable
+        as "가,나,다..."
      */
     const short HANGUL_SYLLABLE_KO = 28;
 
     //-------------------------------------------------------------------------
     /** Bullet for Korean Hangul Circled Jamo
+        as "㉠,㉡,㉢..."
      */
     const short HANGUL_CIRCLED_JAMO_KO = 29;
 
     //-------------------------------------------------------------------------
     /** Bullet for Korean Hangul Circled Syllable
+        as "㉮,㉯,㉰..."
      */
     const short HANGUL_CIRCLED_SYLLABLE_KO = 30;
 
     //-------------------------------------------------------------------------
     /** Numbering in Arabic alphabet letters
+        as "أ,ب,ت..."
 
         @since OOo 1.1.2
      */
diff --git oox/source/shape/ShapeContextHandler.cxx oox/source/shape/ShapeContextHandler.cxx
index d514781..7790a20 100644
--- oox/source/shape/ShapeContextHandler.cxx
+++ oox/source/shape/ShapeContextHandler.cxx
@@ -31,11 +31,6 @@
 #include "oox/vml/vmlshape.hxx"
 #include "oox/vml/vmlshapecontainer.hxx"
 
-#if DEBUG
-#include <iostream>
-using namespace std;
-#endif
-
 namespace oox { namespace shape {
 
 using namespace ::com::sun::star;
@@ -93,9 +88,6 @@ ShapeContextHandler::getGraphicShapeContext(::sal_Int32 Element )
 uno::Reference<xml::sax::XFastContextHandler>
 ShapeContextHandler::getDrawingShapeContext()
 {
-#if DEBUG
-    clog << "ShapeContextHandler::getDrawingShapeContext" << endl;
-#endif
     if (!mxDrawingFragmentHandler.is())
     {
         mpDrawing.reset( new oox::vml::Drawing( *mxFilterBase, mxDrawPage, oox::vml::VMLDRAWING_WORD ) );
@@ -186,9 +178,6 @@ ShapeContextHandler::createFastChildContext
  const uno::Reference< xml::sax::XFastAttributeList > & Attribs)
     throw (uno::RuntimeException, xml::sax::SAXException)
 {
-#if DEBUG
-    clog << "ShapeContextHandler::createFastChildContext" << endl;
-#endif
     uno::Reference< xml::sax::XFastContextHandler > xResult;
     uno::Reference< xml::sax::XFastContextHandler > xContextHandler(getContextHandler());
 
diff --git sw/inc/unotext.hxx sw/inc/unotext.hxx
index ff95bf6..31024de 100644
--- sw/inc/unotext.hxx
+++ sw/inc/unotext.hxx
@@ -31,6 +31,7 @@
 #include <com/sun/star/lang/XUnoTunnel.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextCopy.hpp>
 #include <com/sun/star/text/XTextRangeCompare.hpp>
 #include <com/sun/star/text/XRelativeTextContentInsert.hpp>
 #include <com/sun/star/text/XRelativeTextContentRemove.hpp>
@@ -62,6 +63,7 @@ class SwXText
     , public ::com::sun::star::lang::XUnoTunnel
     , public ::com::sun::star::beans::XPropertySet
     , public ::com::sun::star::text::XTextAppendAndConvert
+    , public ::com::sun::star::text::XTextCopy
     , public ::com::sun::star::text::XTextRangeCompare
     , public ::com::sun::star::text::XRelativeTextContentInsert
     , public ::com::sun::star::text::XRelativeTextContentRemove
@@ -333,6 +335,11 @@ public:
         throw (::com::sun::star::lang::IllegalArgumentException,
                 ::com::sun::star::uno::RuntimeException);
 
+    // XTextCopy
+    virtual void SAL_CALL copyText( 
+            const ::com::sun::star::uno::Reference< 
+                ::com::sun::star::text::XTextCopy >& xSource )
+        throw (::com::sun::star::uno::RuntimeException);
 };
 
 #endif // SW_UNOTEXT_HXX
diff --git sw/source/core/unocore/unotext.cxx sw/source/core/unocore/unotext.cxx
index 089cba4..2022161 100644
--- sw/source/core/unocore/unotext.cxx
+++ sw/source/core/unocore/unotext.cxx
@@ -76,8 +76,6 @@
 #include <stdlib.h>
 
 #include <iostream>
-
-
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
@@ -277,6 +275,10 @@ SwXText::queryInterface(const uno::Type& rType) throw (uno::RuntimeException)
     {
         aRet <<= uno::Reference< text::XTextContentAppend >(this);
     }
+    else if(rType == text::XTextCopy::static_type())
+    {
+        aRet <<= uno::Reference< text::XTextCopy >( this );
+    }
     return aRet;
 }
 /* -----------------------------15.03.00 17:42--------------------------------
@@ -1860,6 +1862,32 @@ static bool lcl_SimilarPosition( const sal_Int32 nPos1, const sal_Int32 nPos2 )
     return abs( nPos1 - nPos2 ) < COL_POS_FUZZY;
 }
 
+void SwXText::copyText(
+    const uno::Reference< text::XTextCopy >& xSource )
+        throw ( uno::RuntimeException )
+{
+    uno::Reference< lang::XUnoTunnel > xTTunnel( xSource, uno::UNO_QUERY_THROW );
+    SwXText* pText = 0;
+    pText = reinterpret_cast< SwXText* >(
+                   sal::static_int_cast< sal_IntPtr >( xTTunnel->getSomething( SwXText::getUnoTunnelId()) ));
+    
+    uno::Reference< text::XText > xText( xSource, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextCursor > xCursor = xText->createTextCursor( );
+    xCursor->gotoEnd( sal_True );
+    
+    uno::Reference< lang::XUnoTunnel > xTunnel( xCursor, uno::UNO_QUERY_THROW );
+    
+    OTextCursorHelper* pCursor = 0;
+    pCursor = reinterpret_cast< OTextCursorHelper* >(
+                   sal::static_int_cast< sal_IntPtr >( xTunnel->getSomething( OTextCursorHelper::getUnoTunnelId()) ));
+    if ( pCursor )
+    {
+        SwNodeIndex rNdIndex( *GetStartNode( ), 1 );
+        SwPosition rPos( rNdIndex );
+        m_pImpl->m_pDoc->CopyRange( *pCursor->GetPaM( ), rPos, false );
+    }
+}
+
 void SwXText::Impl::ConvertCell(
     const bool bFirstCell,
     const uno::Sequence< uno::Reference< text::XTextRange > > & rCell,
diff --git writerfilter/inc/dmapper/DomainMapper.hxx writerfilter/inc/dmapper/DomainMapper.hxx
index e752a11..8a1c64e 100644
--- writerfilter/inc/dmapper/DomainMapper.hxx
+++ writerfilter/inc/dmapper/DomainMapper.hxx
@@ -62,6 +62,8 @@ namespace dmapper
 
 class PropertyMap;
 class DomainMapper_Impl;
+class ListsManager;
+class StyleSheetTable;
 
 // different context types require different sprm handling (e.g. names)
 enum SprmType
@@ -103,6 +105,7 @@ public:
     virtual void endSectionGroup();
     virtual void startParagraphGroup();
     virtual void endParagraphGroup();
+    virtual void markLastParagraphInSection();
     virtual void startCharacterGroup();
     virtual void endCharacterGroup();
     virtual void startShape( ::com::sun::star::uno::Reference< com::sun::star::drawing::XShape > xShape );
@@ -131,6 +134,8 @@ public:
     ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > GetCurrentTextRange();
 
     ::rtl::OUString getOrCreateCharStyle( PropertyValueVector_t& rCharProperties );
+    boost::shared_ptr< ListsManager > GetListTable( );
+    boost::shared_ptr< StyleSheetTable > GetStyleSheetTable( );
 
 private:
     void handleUnderlineType(const sal_Int32 nIntValue, const ::boost::shared_ptr<PropertyMap> pContext);
diff --git writerfilter/inc/resourcemodel/WW8ResourceModel.hxx writerfilter/inc/resourcemodel/WW8ResourceModel.hxx
index a95e705..95b6262 100644
--- writerfilter/inc/resourcemodel/WW8ResourceModel.hxx
+++ writerfilter/inc/resourcemodel/WW8ResourceModel.hxx
@@ -208,6 +208,8 @@ public:
      */
     virtual void endParagraphGroup() = 0;
 
+    virtual void markLastParagraphInSection( ) { };
+
     /**
        Receives start mark for group with the same character properties.
      */
diff --git writerfilter/source/dmapper/ConversionHelper.cxx writerfilter/source/dmapper/ConversionHelper.cxx
index 350e040..85fc040 100644
--- writerfilter/source/dmapper/ConversionHelper.cxx
+++ writerfilter/source/dmapper/ConversionHelper.cxx
@@ -553,26 +553,104 @@ sal_Int16 ConvertNumberingType(sal_Int32 nNFC)
     switch(nNFC)
     {
         case NS_ooxml::LN_Value_ST_NumberFormat_decimal:
-        case 0: nRet = style::NumberingType::ARABIC;                break;
+        case 0: 
+            nRet = style::NumberingType::ARABIC;                
+            break;
         case NS_ooxml::LN_Value_ST_NumberFormat_upperRoman:
-        case 1: nRet = style::NumberingType::ROMAN_UPPER;           break;
+        case 1: 
+            nRet = style::NumberingType::ROMAN_UPPER;           
+            break;
         case NS_ooxml::LN_Value_ST_NumberFormat_lowerRoman:
-        case 2: nRet = style::NumberingType::ROMAN_LOWER;           break;
-        case 3: nRet = style::NumberingType::CHARS_UPPER_LETTER_N;  break;
-        case 4: nRet = style::NumberingType::CHARS_LOWER_LETTER_N;  break;
-        case 5: nRet = style::NumberingType::ARABIC;                break;//ORDINAL
+        case 2: 
+            nRet = style::NumberingType::ROMAN_LOWER;
+            break;
+        case 3: 
+            nRet = style::NumberingType::CHARS_UPPER_LETTER_N; 
+            break;
+        case 4:
+            nRet = style::NumberingType::CHARS_LOWER_LETTER_N;
+            break;
+        case 5: 
+            nRet = style::NumberingType::ARABIC;
+            break;//ORDINAL
         case NS_ooxml::LN_Value_ST_NumberFormat_bullet:
         case 23:
         case 25:
             nRet = style::NumberingType::CHAR_SPECIAL;
         break;
-        case 255: nRet = style::NumberingType::NUMBER_NONE; break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_none:
+        case 255: 
+            nRet = style::NumberingType::NUMBER_NONE;
+            break;
         case NS_ooxml::LN_Value_ST_NumberFormat_upperLetter:
             nRet = style::NumberingType::CHARS_UPPER_LETTER;
-        break;
+            break;
         case  NS_ooxml::LN_Value_ST_NumberFormat_lowerLetter:
             nRet = style::NumberingType::CHARS_LOWER_LETTER;
-        break;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_iroha:
+            nRet = style::NumberingType::IROHA_HALFWIDTH_JA;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_irohaFullWidth:
+            nRet = style::NumberingType::IROHA_FULLWIDTH_JA;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_aiueo:
+            nRet = style::NumberingType::AIU_HALFWIDTH_JA;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_aiueoFullWidth:
+            nRet = style::NumberingType::AIU_FULLWIDTH_JA;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_hebrew2:
+            nRet = style::NumberingType::CHARS_HEBREW;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_thaiLetters:
+            nRet = style::NumberingType::CHARS_THAI;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_russianLower:
+            nRet = style::NumberingType::CHARS_CYRILLIC_LOWER_LETTER_RU;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_russianUpper:
+            nRet = style::NumberingType::CHARS_CYRILLIC_UPPER_LETTER_RU;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_decimalEnclosedCircleChinese:
+        case NS_ooxml::LN_Value_ST_NumberFormat_ideographEnclosedCircle:
+            nRet = style::NumberingType::CIRCLE_NUMBER;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_ideographTraditional:
+            nRet = style::NumberingType::TIAN_GAN_ZH;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_ideographZodiac:
+            nRet = style::NumberingType::DI_ZI_ZH;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_ganada:
+            nRet = style::NumberingType::HANGUL_SYLLABLE_KO;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_chosung:
+            nRet = style::NumberingType::HANGUL_JAMO_KO;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_koreanDigital:
+        case NS_ooxml::LN_Value_ST_NumberFormat_koreanCounting:
+        case NS_ooxml::LN_Value_ST_NumberFormat_koreanDigital2:
+            nRet = style::NumberingType::NUMBER_HANGUL_KO;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_ideographLegalTraditional:
+            nRet = style::NumberingType::NUMBER_UPPER_ZH_TW;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_arabicAlpha:
+            nRet = style::NumberingType::CHARS_ARABIC;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_hindiVowels:
+            nRet = style::NumberingType::CHARS_NEPALI;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_japaneseLegal:
+            nRet = style::NumberingType::NUMBER_TRADITIONAL_JA;
+            break;
+        case NS_ooxml::LN_Value_ST_NumberFormat_chineseCounting:
+        case NS_ooxml::LN_Value_ST_NumberFormat_japaneseCounting:
+        case NS_ooxml::LN_Value_ST_NumberFormat_taiwaneseCounting:
+        case NS_ooxml::LN_Value_ST_NumberFormat_ideographDigital:
+            nRet = style::NumberingType::NUMBER_LOWER_ZH;
+            break;
         default: nRet = style::NumberingType::ARABIC;
     }
 /*  TODO: Lots of additional values are available - some are supported in the I18 framework
@@ -581,53 +659,27 @@ sal_Int16 ConvertNumberingType(sal_Int32 nNFC)
     NS_ooxml::LN_Value_ST_NumberFormat_ordinalText = 91684;
     NS_ooxml::LN_Value_ST_NumberFormat_hex = 91685;
     NS_ooxml::LN_Value_ST_NumberFormat_chicago = 91686;
-    NS_ooxml::LN_Value_ST_NumberFormat_ideographDigital = 91687;
-    NS_ooxml::LN_Value_ST_NumberFormat_japaneseCounting = 91688;
-    NS_ooxml::LN_Value_ST_NumberFormat_aiueo = 91689;
-    NS_ooxml::LN_Value_ST_NumberFormat_iroha = 91690;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalFullWidth = 91691;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalHalfWidth = 91692;
-    NS_ooxml::LN_Value_ST_NumberFormat_japaneseLegal = 91693;
     NS_ooxml::LN_Value_ST_NumberFormat_japaneseDigitalTenThousand = 91694;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalEnclosedCircle = 91695;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalFullWidth2 = 91696;
-    NS_ooxml::LN_Value_ST_NumberFormat_aiueoFullWidth = 91697;
-    NS_ooxml::LN_Value_ST_NumberFormat_irohaFullWidth = 91698;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalZero = 91699;
-    NS_ooxml::LN_Value_ST_NumberFormat_ganada = 91701;
-    NS_ooxml::LN_Value_ST_NumberFormat_chosung = 91702;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalEnclosedFullstop = 91703;
     NS_ooxml::LN_Value_ST_NumberFormat_decimalEnclosedParen = 91704;
-    NS_ooxml::LN_Value_ST_NumberFormat_decimalEnclosedCircleChinese = 91705;
-    NS_ooxml::LN_Value_ST_NumberFormat_ideographEnclosedCircle = 91706;
-    NS_ooxml::LN_Value_ST_NumberFormat_ideographTraditional = 91707;
-    NS_ooxml::LN_Value_ST_NumberFormat_ideographZodiac = 91708;
     NS_ooxml::LN_Value_ST_NumberFormat_ideographZodiacTraditional = 91709;
-    NS_ooxml::LN_Value_ST_NumberFormat_taiwaneseCounting = 91710;
-    NS_ooxml::LN_Value_ST_NumberFormat_ideographLegalTraditional = 91711;
     NS_ooxml::LN_Value_ST_NumberFormat_taiwaneseCountingThousand = 91712;
     NS_ooxml::LN_Value_ST_NumberFormat_taiwaneseDigital = 91713;
-    NS_ooxml::LN_Value_ST_NumberFormat_chineseCounting = 91714;
     NS_ooxml::LN_Value_ST_NumberFormat_chineseLegalSimplified = 91715;
     NS_ooxml::LN_Value_ST_NumberFormat_chineseCountingThousand = 91716;
-    NS_ooxml::LN_Value_ST_NumberFormat_koreanDigital = 91717;
-    NS_ooxml::LN_Value_ST_NumberFormat_koreanCounting = 91718;
     NS_ooxml::LN_Value_ST_NumberFormat_koreanLegal = 91719;
-    NS_ooxml::LN_Value_ST_NumberFormat_koreanDigital2 = 91720;
     NS_ooxml::LN_Value_ST_NumberFormat_vietnameseCounting = 91721;
-    NS_ooxml::LN_Value_ST_NumberFormat_russianLower = 91722;
-    NS_ooxml::LN_Value_ST_NumberFormat_russianUpper = 91723;
-    NS_ooxml::LN_Value_ST_NumberFormat_none = 91724;
     NS_ooxml::LN_Value_ST_NumberFormat_numberInDash = 91725;
+    NS_ooxml::LN_Value_ST_NumberFormat_arabicAbjad:
     NS_ooxml::LN_Value_ST_NumberFormat_hebrew1 = 91726;
-    NS_ooxml::LN_Value_ST_NumberFormat_hebrew2 = 91727;
-    NS_ooxml::LN_Value_ST_NumberFormat_arabicAlpha = 91728;
-    NS_ooxml::LN_Value_ST_NumberFormat_arabicAbjad = 91729;
-    NS_ooxml::LN_Value_ST_NumberFormat_hindiVowels = 91730;
     NS_ooxml::LN_Value_ST_NumberFormat_hindiConsonants = 91731;
     NS_ooxml::LN_Value_ST_NumberFormat_hindiNumbers = 91732;
     NS_ooxml::LN_Value_ST_NumberFormat_hindiCounting = 91733;
-    NS_ooxml::LN_Value_ST_NumberFormat_thaiLetters = 91734;
     NS_ooxml::LN_Value_ST_NumberFormat_thaiNumbers = 91735;
     NS_ooxml::LN_Value_ST_NumberFormat_thaiCounting = 91736;*/
     return nRet;
diff --git writerfilter/source/dmapper/DomainMapper.cxx writerfilter/source/dmapper/DomainMapper.cxx
index 643f1c5..3d76b7d 100755
--- writerfilter/source/dmapper/DomainMapper.cxx
+++ writerfilter/source/dmapper/DomainMapper.cxx
@@ -29,6 +29,7 @@
 #include <dmapper/DomainMapper.hxx>
 #include <DomainMapper_Impl.hxx>
 #include <ConversionHelper.hxx>
+#include <NumberingManager.hxx>
 #include <ThemeTable.hxx>
 #include <ModelEventListener.hxx>
 #include <MeasureHandler.hxx>
@@ -1630,7 +1631,9 @@ void DomainMapper::attribute(Id nName, Value & val)
         case NS_ooxml::LN_CT_TabStop_val:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             if (sal::static_int_cast<Id>(nIntValue) == NS_ooxml::LN_Value_ST_TabJc_clear)
+            {
                 m_pImpl->m_aCurrentTabStop.bDeleted = true;
+            }
             else
             {
                 m_pImpl->m_aCurrentTabStop.bDeleted = false;
@@ -1757,8 +1760,11 @@ void DomainMapper::attribute(Id nName, Value & val)
         case NS_ooxml::LN_CT_Ind_hanging:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             if (m_pImpl->GetTopContext())
+            {
+                sal_Int32 nValue = ConversionHelper::convertTwipToMM100( nIntValue );
                 m_pImpl->GetTopContext()->Insert(
-                    PROP_PARA_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100(nIntValue ) ));
+                    PROP_PARA_FIRST_LINE_INDENT, true, uno::makeAny( - nValue ));
+            }
             break;
         case NS_ooxml::LN_CT_Ind_firstLine:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
@@ -2253,20 +2259,26 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         /* WRITERFILTERSTATUS: comment:  */
         {
             //convert the ListTable entry to a NumberingRules propery and apply it
-            sal_Int32 nListId = m_pImpl->GetLFOTable()->GetListID( nIntValue );
-            if(nListId >= 0)
+            ListsManager::Pointer pListTable = m_pImpl->GetListTable();
+            ListDef::Pointer pList = pListTable->GetList( nIntValue );
+            if( pList.get( ) )
             {
-                ListTablePtr pListTable = m_pImpl->GetListTable();
                 if( m_pImpl->IsStyleSheetImport() )
                 {
                     //style sheets cannot have a numbering rule attached
                     StyleSheetPropertyMap* pStyleSheetPropertyMap = dynamic_cast< StyleSheetPropertyMap* >( rContext.get() );
-                    pStyleSheetPropertyMap->SetListId( nListId );
+                    pStyleSheetPropertyMap->SetListId( nIntValue );
                 }
                 else
-                    rContext->Insert( PROP_NUMBERING_RULES, true,
-                                  uno::makeAny(pListTable->GetNumberingRules(nListId)));
-                //TODO: Merge overwrittern numbering levels from LFO table
+                {
+                    uno::Any aRules = uno::makeAny( pList->GetNumberingRules( ) );
+                    rContext->Insert( PROP_NUMBERING_RULES, true, aRules );
+                }
+            }
+            else if ( !m_pImpl->IsStyleSheetImport( ) )
+            {
+                rtl::OUString sNone;
+                rContext->Insert( PROP_NUMBERING_STYLE_NAME, true, uno::makeAny( sNone ) );
             }
         }
         break;
@@ -3929,7 +3941,7 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         
         if( pStyleSheetProperties && pStyleSheetProperties->GetListId() >= 0 )
             rContext->Insert( PROP_NUMBERING_STYLE_NAME, true, uno::makeAny( 
-                        m_pImpl->GetListTable( )->GetStyleName( pStyleSheetProperties->GetListId( ) ) ), false);
+                        ListDef::GetStyleName( pStyleSheetProperties->GetListId( ) ) ), false);
         
         if( pStyleSheetProperties && pStyleSheetProperties->GetListLevel() >= 0 )
             rContext->Insert( PROP_NUMBERING_LEVEL, true, uno::makeAny(pStyleSheetProperties->GetListLevel()), false);
@@ -4114,9 +4126,6 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
     /* WRITERFILTERSTATUS: done: 0, planned: 4, spent: 0 */
     case NS_ooxml::LN_object:
     {
-#if DEBUG
-        clog << "DomainMapper: LN_object" << endl;
-#endif
         writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
         if( pProperties.get( ) )
         {
@@ -4156,10 +4165,6 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
     case NS_ooxml::LN_EG_SectPrContents_formProt: //section protection, only form editing is enabled - unsupported
             /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
     break;
-    case NS_ooxml::LN_CT_Lvl_pStyle:
-            /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
-        //TODO: numbering style should apply current numbering level - not yet supported
-    break;
     default:
         {
 #ifdef DEBUG_DOMAINMAPPER
@@ -4250,38 +4255,6 @@ void DomainMapper::startParagraphGroup()
 -----------------------------------------------------------------------*/
 void DomainMapper::endParagraphGroup()
 {
-    //handle unprocessed deferred breaks
-    PropertyMapPtr pParaProperties = m_pImpl->GetTopContextOfType(CONTEXT_PARAGRAPH);
-    if( pParaProperties->hasEmptyPropertyValues() )
-    {
-        PropertyMap::const_iterator aIter = pParaProperties->find(PropertyDefinition( PROP_BREAK_TYPE , false ) );
-        if( aIter != pParaProperties->end() )
-        {
-            style::BreakType eType;
-            aIter->second >>= eType;
-            bool bPage = false;
-            bool bColumn = false;
-            if( eType == style::BreakType_PAGE_BEFORE )
-                bPage = true;
-            else if( eType == style::BreakType_COLUMN_BEFORE )
-                 bColumn = true;
-
-            if( bPage || bColumn )
-            {
-                try
-                {
-                        uno::Reference< beans::XPropertySet > xRangeProperties( m_pImpl->GetTopTextAppend()->getEnd(), uno::UNO_QUERY_THROW );
-                        xRangeProperties->setPropertyValue(
-                            PropertyNameSupplier::GetPropertyNameSupplier().GetName(PROP_BREAK_TYPE),
-                                                    uno::makeAny( bPage ? style::BreakType_PAGE_BEFORE : style::BreakType_COLUMN_BEFORE));
-                }
-                catch( const uno::Exception& )
-                {
-                }
-            }
-        }
-    }
-
     m_pImpl->PopProperties(CONTEXT_PARAGRAPH);
     m_pImpl->getTableManager().endParagraphGroup();
     //frame conversion has to be executed after table conversion
@@ -4291,6 +4264,14 @@ void DomainMapper::endParagraphGroup()
 #endif
 }
 
+void DomainMapper::markLastParagraphInSection( )
+{
+#ifdef DEBUG_DOMAINMAPPER
+    dmapper_logger->element( "markLastParagraphInSection" );
+#endif
+    m_pImpl->SetIsLastParagraphInSection( true );
+}
+
 void DomainMapper::startShape( uno::Reference< drawing::XShape > xShape )
 {
 #ifdef DEBUG_DOMAINMAPPER
@@ -4593,9 +4574,12 @@ void DomainMapper::table(Id name, writerfilter::Reference<Table>::Pointer_t ref)
         }
         break;
     case NS_rtf::LN_LFOTABLE:
-        /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
-
-        ref->resolve( *m_pImpl->GetLFOTable() );
+        {
+            m_pImpl->GetListTable( )->SetLFOImport( true );
+            ref->resolve( *m_pImpl->GetListTable() );
+            m_pImpl->GetListTable( )->CreateNumberingRules( );
+            m_pImpl->GetListTable( )->SetLFOImport( false );
+        }
         break;
     case NS_ooxml::LN_THEMETABLE:
         ref->resolve ( *m_pImpl->GetThemeTable() );
@@ -4622,6 +4606,7 @@ void DomainMapper::substream(Id rName, ::writerfilter::Reference<Stream>::Pointe
     dmapper_logger->startElement("substream");
 #endif
 
+    m_pImpl->appendTableManager( );
     m_pImpl->getTableManager().startLevel();
 
     //->debug
@@ -4691,6 +4676,7 @@ void DomainMapper::substream(Id rName, ::writerfilter::Reference<Stream>::Pointe
     }
 
     m_pImpl->getTableManager().endLevel();
+    m_pImpl->popTableManager( );
 
 #ifdef DEBUG_DOMAINMAPPER
     dmapper_logger->endElement("substream");
@@ -4857,6 +4843,7 @@ com::sun::star::style::TabAlign DomainMapper::getTabAlignFromValue(const sal_Int
     {
     case 0:
     case 4: // bar not supported
+    case 5: // num not supported
         return com::sun::star::style::TabAlign_LEFT;
     case 1:
         return com::sun::star::style::TabAlign_CENTER;
@@ -4864,8 +4851,6 @@ com::sun::star::style::TabAlign DomainMapper::getTabAlignFromValue(const sal_Int
         return com::sun::star::style::TabAlign_RIGHT;
     case 3:
         return com::sun::star::style::TabAlign_DECIMAL;
-    default:
-        return com::sun::star::style::TabAlign_DEFAULT;
     }
     return com::sun::star::style::TabAlign_LEFT;
 }
@@ -4905,10 +4890,6 @@ uno::Reference < lang::XMultiServiceFactory > DomainMapper::GetTextFactory() con
 /*-- 12.11.2007 10:41:01---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void  DomainMapper::AddListIDToLFOTable( sal_Int32 nAbstractNumId )
-{
-    m_pImpl->GetLFOTable()->AddListID( nAbstractNumId );
-}
 /*-- 31.01.2008 18:19:44---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -4926,5 +4907,15 @@ uno::Reference< text::XTextRange > DomainMapper::GetCurrentTextRange()
     return pStyleSheets->getOrCreateCharStyle( rCharProperties );
 }
 
+ListsManager::Pointer DomainMapper::GetListTable( )
+{
+    return m_pImpl->GetListTable( );
+}
+
+StyleSheetTablePtr DomainMapper::GetStyleSheetTable( )
+{
+    return m_pImpl->GetStyleSheetTable( );
+}
+
 } //namespace dmapper
 } //namespace writerfilter
diff --git writerfilter/source/dmapper/DomainMapper_Impl.cxx writerfilter/source/dmapper/DomainMapper_Impl.cxx
index e4eaa6d..7dd49da 100644
--- writerfilter/source/dmapper/DomainMapper_Impl.cxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.cxx
@@ -81,6 +81,7 @@
 #if DEBUG
 #include <stdio.h>
 #include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/style/TabStop.hpp>
 #endif
 
 #include <map>
@@ -402,7 +403,7 @@ DomainMapper_Impl::DomainMapper_Impl(
         m_bIsPageBreakDeferred( false ),
         m_bIsInShape( false ),
         m_bShapeContextAdded( false ),
-        m_TableManager( eDocumentType == DOCUMENT_OOXML ),
+        m_pLastSectionContext( ),
         m_nCurrentTabStopIndex( 0 ),
         m_sCurrentParaStyleId(),
         m_bInStyleSheetImport( false ),
@@ -410,8 +411,11 @@ DomainMapper_Impl::DomainMapper_Impl(
         m_bLineNumberingSet( false ),
         m_bIsInFootnoteProperties( true ),
         m_bIsCustomFtnMark( false ),
-        m_bIsParaChange( false )
+        m_bIsParaChange( false ),
+        m_bParaChanged( false ),
+        m_bIsLastParaInSection( false )
 {
+    appendTableManager( );
     GetBodyText();
     uno::Reference< text::XTextAppend > xBodyTextAppend = uno::Reference< text::XTextAppend >( m_xBodyText, uno::UNO_QUERY );
     m_aTextAppendStack.push(xBodyTextAppend);
@@ -420,13 +424,18 @@ DomainMapper_Impl::DomainMapper_Impl(
     uno::Reference< text::XTextAppendAndConvert > xBodyTextAppendAndConvert( m_xBodyText, uno::UNO_QUERY );
     TableDataHandler_t::Pointer_t pTableHandler
         (new DomainMapperTableHandler(xBodyTextAppendAndConvert, *this));
-    m_TableManager.setHandler(pTableHandler);
+    getTableManager( ).setHandler(pTableHandler);
+
+    getTableManager( ).startLevel();
 }
 /*-- 01.09.2006 10:22:28---------------------------------------------------
 
   -----------------------------------------------------------------------*/
 DomainMapper_Impl::~DomainMapper_Impl()
 {
+    RemoveLastParagraph( );
+    getTableManager( ).endLevel();
+    popTableManager( );
 }
 /*-------------------------------------------------------------------------
 
@@ -480,6 +489,28 @@ void DomainMapper_Impl::SetDocumentSettingsProperty( const ::rtl::OUString& rPro
         }
     }
 }
+
+void DomainMapper_Impl::RemoveLastParagraph( )
+{
+    uno::Reference< text::XTextAppend >  xTextAppend = m_aTextAppendStack.top().xTextAppend;
+    try
+    {
+        uno::Reference< text::XTextCursor > xCursor = xTextAppend->createTextCursor();
+        xCursor->gotoEnd(false);
+        xCursor->goLeft( 1, true );
+        xCursor->setString(::rtl::OUString());
+    }
+    catch( const uno::Exception& rEx)
+    {
+        (void)rEx;
+    }
+}
+
+void DomainMapper_Impl::SetIsLastParagraphInSection( bool bIsLast )
+{
+    m_bIsLastParaInSection = bIsLast;
+}
+
 /*-------------------------------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -530,6 +561,12 @@ void DomainMapper_Impl::PushListProperties(PropertyMapPtr pListProperties)
 void    DomainMapper_Impl::PopProperties(ContextType eId)
 {
     OSL_ENSURE(!m_aPropertyStacks[eId].empty(), "section stack already empty");
+
+    if ( eId == CONTEXT_SECTION )
+    {
+        m_pLastSectionContext = m_aPropertyStacks[eId].top( );
+    }
+
     m_aPropertyStacks[eId].pop();
     m_aContextStack.pop();
     if(!m_aContextStack.empty() && !m_aPropertyStacks[m_aContextStack.top()].empty())
@@ -664,7 +701,7 @@ void DomainMapper_Impl::IncorporateTabStop( const DeletableTabStop &  rTabStop )
   -----------------------------------------------------------------------*/
 uno::Sequence< style::TabStop > DomainMapper_Impl::GetCurrentTabStopAndClear()
 {
-    uno::Sequence< style::TabStop > aRet( m_aCurrentTabStops.size() );
+    uno::Sequence< style::TabStop > aRet( sal_Int32( m_aCurrentTabStops.size() ) );
     style::TabStop* pArray = aRet.getArray();
     ::std::vector<DeletableTabStop>::const_iterator aIt = m_aCurrentTabStops.begin();
     ::std::vector<DeletableTabStop>::const_iterator aEndIt = m_aCurrentTabStops.end();
@@ -717,11 +754,11 @@ uno::Any DomainMapper_Impl::GetPropertyFromStyleSheet(PropertyIds eId)
 /*-------------------------------------------------------------------------
 
   -----------------------------------------------------------------------*/
-ListTablePtr DomainMapper_Impl::GetListTable()
+ListsManager::Pointer DomainMapper_Impl::GetListTable()
 {
     if(!m_pListTable)
         m_pListTable.reset(
-            new ListTable( m_rDMapper, m_xTextFactory ));
+            new ListsManager( m_rDMapper, m_xTextFactory ));
     return m_pListTable;
 }
 
@@ -856,7 +893,7 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
     dmapper_logger->attribute("isIgnor", m_TableManager.isIgnore());
 #endif 
     
-    if(xTextAppend.is() && ! m_TableManager.isIgnore())
+    if(xTextAppend.is() && ! getTableManager( ).isIgnore())
     {
         try
         {
@@ -1060,7 +1097,7 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
                 }
                 uno::Reference< text::XTextRange > xTextRange =
                     xTextAppend->finishParagraph( aProperties );
-                m_TableManager.handle(xTextRange);
+                getTableManager( ).handle(xTextRange);
             
                 // Set the anchor of the objects to the created paragraph
                 while ( m_aAnchoredStack.size( ) > 0 && !m_bIsInShape )
@@ -1086,6 +1123,15 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
                 xCur->goLeft( 1 , true );
                 uno::Reference< text::XTextRange > xParaEnd( xCur, uno::UNO_QUERY );
                 CheckParaRedline( xParaEnd );
+
+                // Remove the last empty section paragraph if needed
+                if ( m_bIsLastParaInSection && !m_bParaChanged )
+                {
+                    RemoveLastParagraph( );
+                    m_bIsLastParaInSection = false;
+                }
+
+                m_bParaChanged = false;
             }
             if( !bKeepLastParagraphProperties )
                 rAppendContext.pLastParagraphProperties = pToBeSavedProperties;
@@ -1132,7 +1178,7 @@ util::DateTime lcl_DateStringToDateTime( const ::rtl::OUString& rDateTime )
 void DomainMapper_Impl::appendTextPortion( const ::rtl::OUString& rString, PropertyMapPtr pPropertyMap )
 {
     uno::Reference< text::XTextAppend >  xTextAppend = m_aTextAppendStack.top().xTextAppend;
-    if(xTextAppend.is() && ! m_TableManager.isIgnore())
+    if(xTextAppend.is() && ! getTableManager( ).isIgnore())
     {
         try
         {
@@ -1140,8 +1186,9 @@ void DomainMapper_Impl::appendTextPortion( const ::rtl::OUString& rString, Prope
                 xTextAppend->appendTextPortion
                 (rString, pPropertyMap->GetPropertyValues());
             CheckRedline( xTextRange );
+            m_bParaChanged = true;
 
-            //m_TableManager.handle(xTextRange);
+            //getTableManager( ).handle(xTextRange);
         }
         catch(const lang::IllegalArgumentException& rEx)
         {
@@ -1165,7 +1212,7 @@ void DomainMapper_Impl::appendTextContent(
 {
     uno::Reference< text::XTextAppendAndConvert >  xTextAppendAndConvert( m_aTextAppendStack.top().xTextAppend, uno::UNO_QUERY );
     OSL_ENSURE( xTextAppendAndConvert.is(), "trying to append a text content without XTextAppendAndConvert" );
-    if(xTextAppendAndConvert.is() && ! m_TableManager.isIgnore())
+    if(xTextAppendAndConvert.is() && ! getTableManager( ).isIgnore())
     {
         try
         {
@@ -1332,18 +1379,7 @@ void DomainMapper_Impl::PopPageHeaderFooter()
 {
     //header and footer always have an empty paragraph at the end
     //this has to be removed
-    uno::Reference< text::XTextAppend >  xTextAppend = m_aTextAppendStack.top().xTextAppend;
-    try
-    {
-        uno::Reference< text::XTextCursor > xCursor = xTextAppend->createTextCursor();
-        xCursor->gotoEnd(false);
-        xCursor->goLeft( 1, true );
-        xCursor->setString(::rtl::OUString());
-    }
-    catch( const uno::Exception& rEx)
-    {
-        (void)rEx;
-    }
+    RemoveLastParagraph( );
     m_aTextAppendStack.pop();
 }
 /*-- 24.05.2007 14:22:28---------------------------------------------------
@@ -1397,9 +1433,6 @@ void DomainMapper_Impl::CreateRedline( uno::Reference< text::XTextRange > xRange
 {
     if ( pRedline.get( ) )
     {
-#if DEBUG
-        clog << "REDLINE: Writing redline: " << pRedline->m_nId << endl;
-#endif
         try
         {
             ::rtl::OUString sType;
@@ -1428,9 +1461,6 @@ void DomainMapper_Impl::CreateRedline( uno::Reference< text::XTextRange > xRange
         }
         catch( const uno::Exception & rEx )
         {
-#if DEBUG
-            clog << "REDLINE: error - " << rtl::OUStringToOString( rEx.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
-#endif
             ( void ) rEx;
             OSL_ENSURE( false, "Exception in makeRedline" );
         }
@@ -1515,9 +1545,6 @@ void DomainMapper_Impl::PopAnnotation()
 
 void DomainMapper_Impl::PushShapeContext( const uno::Reference< drawing::XShape > xShape )
 {
-#if DEBUG
-    clog << "PushShapeContext" << endl;
-#endif
     m_bIsInShape = true;
     try 
     {
@@ -1554,10 +1581,6 @@ void DomainMapper_Impl::PushShapeContext( const uno::Reference< drawing::XShape
   -----------------------------------------------------------------------*/
 void DomainMapper_Impl::PopShapeContext()
 {
-#if DEBUG
-        clog << "PopShapeContext" << endl;
-#endif
-    
     if ( m_bShapeContextAdded )
     {
         m_aTextAppendStack.pop();
@@ -3641,16 +3664,10 @@ void DomainMapper_Impl::AddNewRedline(  )
     pNew->m_nToken = ooxml::OOXML_mod;
     if ( !m_bIsParaChange ) 
     {
-#if DEBUG
-    clog << "REDLINE: Adding a new redline to stack" << endl;
-#endif
         m_aRedlines.push_back( pNew );
     }
     else
     {
-#if DEBUG
-    clog << "REDLINE: Setting a new paragraph redline" << endl;
-#endif
         m_pParaRedline.swap( pNew );
     }
 }
@@ -3709,9 +3726,6 @@ void DomainMapper_Impl::RemoveCurrentRedline( )
 {
     if ( m_aRedlines.size( ) > 0 )
     {
-#if DEBUG
-        clog << "REDLINE: Removing back redline" << endl;
-#endif
         m_aRedlines.pop_back( );
     }
 }
@@ -3720,9 +3734,6 @@ void DomainMapper_Impl::ResetParaRedline( )
 {
     if ( m_pParaRedline.get( ) )
     {
-#if DEBUG
-        clog << "REDLINE: Cleaning the para redline" << endl;
-#endif
         RedlineParamsPtr pEmpty;
         m_pParaRedline.swap( pEmpty );
     }
diff --git writerfilter/source/dmapper/DomainMapper_Impl.hxx writerfilter/source/dmapper/DomainMapper_Impl.hxx
index ef1885c..2b4e517 100755
--- writerfilter/source/dmapper/DomainMapper_Impl.hxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.hxx
@@ -45,8 +45,7 @@
 #include <DomainMapperTableManager.hxx>
 #include <PropertyMap.hxx>
 #include <FontTable.hxx>
-#include <ListTable.hxx>
-#include <LFOTable.hxx>
+#include <NumberingManager.hxx>
 #include <StyleSheetTable.hxx>
 #include <SettingsTable.hxx>
 #include <ThemeTable.hxx>
@@ -296,15 +295,15 @@ private:
     _PageMar                                                                        m_aPageMargins;
 
 
-    DomainMapperTableManager m_TableManager;
+    // TableManagers are stacked: one for each stream to avoid any confusion
+    std::stack< boost::shared_ptr< DomainMapperTableManager > > m_aTableManagers;
 
     //each context needs a stack of currently used attributes
     FIB                     m_aFIB;
     PropertyStack           m_aPropertyStacks[NUMBER_OF_CONTEXTS];
     ContextStack            m_aContextStack;
     FontTablePtr            m_pFontTable;
-    ListTablePtr            m_pListTable;
-    LFOTablePtr             m_pLFOTable;
+    ListsManager::Pointer   m_pListTable;
     StyleSheetTablePtr      m_pStyleSheetTable;
     ThemeTablePtr           m_pThemeTable;
     SettingsTablePtr        m_pSettingsTable;
@@ -312,6 +311,7 @@ private:
 
 
     PropertyMapPtr                  m_pTopContext;
+    PropertyMapPtr           m_pLastSectionContext;
 
     ::std::vector<DeletableTabStop> m_aCurrentTabStops;
     sal_uInt32                      m_nCurrentTabStopIndex;
@@ -333,6 +333,8 @@ private:
     RedlineParamsPtr                m_pParaRedline;
     bool                            m_bIsParaChange;
 
+    bool                            m_bParaChanged;
+    bool                            m_bIsLastParaInSection;
 
     //annotation import
     uno::Reference< beans::XPropertySet >                                      m_xAnnotationField;
@@ -355,6 +357,11 @@ public:
     DomainMapper_Impl();
     virtual ~DomainMapper_Impl();
 
+    SectionPropertyMap* GetLastSectionContext( )
+    {
+        return dynamic_cast< SectionPropertyMap* >( m_pLastSectionContext.get( ) );
+    }
+
     ::com::sun::star::uno::Reference< ::com::sun::star::container::XNameContainer > GetPageStyles();
     ::com::sun::star::uno::Reference< ::com::sun::star::text::XText >               GetBodyText();
     ::com::sun::star::uno::Reference < ::com::sun::star::lang::XMultiServiceFactory > GetTextFactory() const
@@ -380,6 +387,9 @@ public:
     void StartParaChange( );
     void EndParaChange( );
 
+    void RemoveLastParagraph( );
+    void SetIsLastParagraphInSection( bool bIsLast );
+
     void deferBreak( BreakType deferredBreakType );
     bool isBreakDeferred( BreakType deferredBreakType );
     void clearDeferredBreaks();
@@ -421,13 +431,7 @@ public:
             m_pStyleSheetTable.reset(new StyleSheetTable( m_rDMapper, m_xTextDocument ));
         return m_pStyleSheetTable;
     }
-    ListTablePtr GetListTable();
-    LFOTablePtr GetLFOTable()
-    {
-        if(!m_pLFOTable)
-            m_pLFOTable.reset( new LFOTable );
-        return m_pLFOTable;
-    }
+    ListsManager::Pointer GetListTable();
     ThemeTablePtr GetThemeTable()
     {
         if(!m_pThemeTable)
@@ -494,7 +498,24 @@ public:
 
     void AddBookmark( const ::rtl::OUString& rBookmarkName, const ::rtl::OUString& rId );
 
-    DomainMapperTableManager& getTableManager() { return m_TableManager; }
+    DomainMapperTableManager& getTableManager()
+    {
+        boost::shared_ptr< DomainMapperTableManager > pMngr = m_aTableManagers.top();
+        return *pMngr.get( );
+    }
+
+    void appendTableManager( )
+    {
+        boost::shared_ptr< DomainMapperTableManager > pMngr(
+                new DomainMapperTableManager( m_eDocumentType == DOCUMENT_OOXML ) );
+        m_aTableManagers.push( pMngr );
+    }
+
+    void popTableManager( )
+    {
+        if ( m_aTableManagers.size( ) > 0 )
+            m_aTableManagers.pop( );
+    }
 
     void SetLineNumbering( sal_Int32 nLnnMod, sal_Int32 nLnc, sal_Int32 ndxaLnn );
     bool IsLineNumberingSet() const {return m_bLineNumberingSet;}
diff --git writerfilter/source/dmapper/GraphicImport.cxx writerfilter/source/dmapper/GraphicImport.cxx
index e8269c7..41eb96b 100644
--- writerfilter/source/dmapper/GraphicImport.cxx
+++ writerfilter/source/dmapper/GraphicImport.cxx
@@ -1553,7 +1553,7 @@ uno::Reference< text::XTextContent > GraphicImport::createGraphicObject( const b
             }
 
             // setting properties for all types
-            xGraphicObjectProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_ALTERNATIVE_TEXT ),
+            xGraphicObjectProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_TITLE ),
                 uno::makeAny( m_pImpl->sAlternativeText ));
             if( m_pImpl->bPositionProtected )
                 xGraphicObjectProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_POSITION_PROTECTED ), 
diff --git writerfilter/source/dmapper/LFOTable.cxx writerfilter/source/dmapper/LFOTable.cxx
deleted file mode 100644
index c507ab3..0000000
--- writerfilter/source/dmapper/LFOTable.cxx
+++ /dev/null
@@ -1,199 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <LFOTable.hxx>
-#include <doctok/resourceids.hxx>
-#include <vector>
-
-namespace writerfilter {
-namespace dmapper
-{
-using namespace std;
-using namespace writerfilter;
-
-struct LFOLevel
-{
-    sal_Int32           nIStartAt;
-    sal_Int32           nFStartAt;
-    sal_Int32           nFFormatting;
-    ::rtl::OUString     sILevel;
-
-    LFOLevel() :
-        nIStartAt(-1)
-        ,nFStartAt(-1)
-        ,nFFormatting(-1)
-        {}
-};
-typedef ::boost::shared_ptr< LFOLevel > LFOLevelPtr;
-struct LFOEntry
-{
-    sal_Int32               nListId;
-    sal_Int32               nCLFOLevel;
-    vector< LFOLevelPtr >      aLFOLevels; //usually empty
-
-    LFOEntry() :
-        nListId(-1)
-        ,nCLFOLevel(-1)
-        {}
-};
-typedef ::boost::shared_ptr<LFOEntry> LFOEntryPtr;
-
-struct LFOTable_Impl
-{
-    ::std::vector< LFOEntryPtr >    m_aLFOEntries; //properties of each level
-    LFOEntryPtr                     m_pCurrentEntry;
-
-};
-/*-- 27.06.2006 15:13:03---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-LFOTable::LFOTable() :
-    m_pImpl( new LFOTable_Impl )
-{
-}
-/*-- 27.06.2006 15:13:03---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-LFOTable::~LFOTable()
-{
-}
-/*-- 27.06.2006 15:13:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::attribute(Id Name, Value & val)
-{
-    OSL_ENSURE(m_pImpl->m_pCurrentEntry, "no current entry to write to");
-    if(!m_pImpl->m_pCurrentEntry)
-        return;
-
-    int nIntValue = val.getInt();
-    /* WRITERFILTERSTATUS: table: LFOTable_attributedata */
-    switch( Name )
-    {
-//        case NS_rtf::LN_ISTD: break;//index of applied style
-        case NS_rtf::LN_ISTARTAT:
-        case NS_rtf::LN_ILVL:
-        case NS_rtf::LN_FSTARTAT:
-        case NS_rtf::LN_FFORMATTING:
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            if(m_pImpl->m_pCurrentEntry->aLFOLevels.size())
-            {
-                vector< LFOLevelPtr >::reverse_iterator aEndIter = m_pImpl->m_pCurrentEntry->aLFOLevels.rbegin();
-                switch( Name )
-                {
-                    case NS_rtf::LN_ISTARTAT:
-                        /* WRITERFILTERSTATUS:*/
-                        (*aEndIter)->nIStartAt = nIntValue;
-                    break;
-                    case NS_rtf::LN_ILVL:
-                        /* WRITERFILTERSTATUS:*/
-                        (*aEndIter)->sILevel = val.getString();
-                    break;
-                    case NS_rtf::LN_FSTARTAT:
-                        /* WRITERFILTERSTATUS:*/
-                        (*aEndIter)->nFStartAt = nIntValue;
-                    break;
-                    case NS_rtf::LN_FFORMATTING:
-                        /* WRITERFILTERSTATUS:*/
-                        (*aEndIter)->nFFormatting = nIntValue;
-                    break;
-                    default:;
-                }
-            }
-        break;
-        case NS_rtf::LN_LSID:
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nListId = nIntValue;
-        break;
-        case NS_rtf::LN_clfolvl:
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nCLFOLevel = nIntValue;
-        break;
-#if 0
-        case NS_rtf::LN_LFOLevel:
-            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        {
-            writerfilter::Reference<Properties>::Pointer_t pProperties;
-            if(m_pImpl->m_pCurrentEntry && (pProperties = val.getProperties()).get())
-            {
-                LFOLevelPtr pLevel( new LFOLevel );
-                m_pImpl->m_pCurrentEntry->aLFOLevels.push_back(pLevel);
-            }
-        }
-        break;
-#endif
-        default:
-        {
-            OSL_ENSURE( false, "LFOTable::attribute: default statement");
-            //---->debug
-            int nVal = val.getInt();
-            ++nVal;
-            //<----debug
-        }
-    }
-}
-/*-- 27.06.2006 15:13:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::sprm(Sprm& )
-{
-    OSL_ENSURE( false, "Which sprm should be handled here?");
-}
-/*-- 27.06.2006 15:13:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::entry(int, writerfilter::Reference<Properties>::Pointer_t ref)
-{
-    //create a new LFO entry
-    OSL_ENSURE( !m_pImpl->m_pCurrentEntry.get(), "current entry has to be NULL here");
-    m_pImpl->m_pCurrentEntry.reset( new LFOEntry );
-    ref->resolve(*this);
-    //append it to the table
-    m_pImpl->m_aLFOEntries.push_back( m_pImpl->m_pCurrentEntry );
-    m_pImpl->m_pCurrentEntry = LFOEntryPtr();
-}
-/*-- 27.06.2006 15:13:05---------------------------------------------------
-    1 based access to the LFO table
-  -----------------------------------------------------------------------*/
-sal_Int32 LFOTable::GetListID(sal_uInt32 nLFO)
-{
-    sal_Int32 nRet = -1;
-    if( nLFO > 0 && nLFO <= m_pImpl->m_aLFOEntries.size())
-        nRet = m_pImpl->m_aLFOEntries[nLFO - 1]->nListId;
-    return nRet;
-}
-/*-- 12.11.2007 10:31:23---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::AddListID( sal_Int32 nAbstractNumId )
-{
-    LFOEntryPtr pNew( new LFOEntry );
-    pNew->nListId = nAbstractNumId;
-    m_pImpl->m_aLFOEntries.push_back( pNew );
-}
-
-}//namespace dmapper
-}//namespace writerfilter
diff --git writerfilter/source/dmapper/LFOTable.hxx writerfilter/source/dmapper/LFOTable.hxx
deleted file mode 100644
index fa1711f..0000000
--- writerfilter/source/dmapper/LFOTable.hxx
+++ /dev/null
@@ -1,65 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef INCLUDED_LFOTABLE_HXX
-#define INCLUDED_LFOTABLE_HXX
-
-#include <WriterFilterDllApi.hxx>
-#include <resourcemodel/WW8ResourceModel.hxx>
-#include <com/sun/star/lang/XComponent.hpp>
-//#ifndef INCLUDED_DMAPPER_PROPERTYMAP_HXX
-//#include <PropertyMap.hxx>
-//#endif
-//#include <vector>
-
-namespace writerfilter {
-namespace dmapper
-{
-
-struct LFOTable_Impl;
-class WRITERFILTER_DLLPRIVATE LFOTable : public Properties, public Table
-{
-    LFOTable_Impl   *m_pImpl;
-public:
-    LFOTable();
-    virtual ~LFOTable();
-
-    // Properties
-    virtual void attribute(Id Name, Value & val);
-    virtual void sprm(Sprm & sprm);
-
-    // Table
-    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
-
-//    sal_uInt32          size();
-    sal_Int32       GetListID(sal_uInt32 nLFO);
-    //direct access in ooxml import
-    void            AddListID( sal_Int32 nAbstractNumId );
-};
-typedef boost::shared_ptr< LFOTable >          LFOTablePtr;
-}}
-
-#endif //
diff --git writerfilter/source/dmapper/ListTable.cxx writerfilter/source/dmapper/ListTable.cxx
deleted file mode 100644
index 6f057a4..0000000
--- writerfilter/source/dmapper/ListTable.cxx
+++ /dev/null
@@ -1,903 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <ListTable.hxx>
-#include <dmapper/DomainMapper.hxx>
-#include <PropertyIds.hxx>
-#include <doctok/resourceids.hxx>
-#include <doctok/sprmids.hxx>
-#include <ooxml/resourceids.hxx>
-#include <ConversionHelper.hxx>
-#ifndef INCLUDED_WW8_RESOURCE_MODEL_HXX
-#include <resourcemodel/WW8ResourceModel.hxx>
-#endif
-#include <com/sun/star/container/XIndexReplace.hpp>
-#include <com/sun/star/container/XNameContainer.hpp>
-#include <com/sun/star/lang/XMultiServiceFactory.hpp>
-#include <com/sun/star/style/NumberingType.hpp>
-#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
-#include <com/sun/star/text/HoriOrientation.hpp>
-#include <com/sun/star/text/PositionAndSpaceMode.hpp>
-#include <vector>
-
-#define NUMBERING_MAX_LEVELS    10
-namespace writerfilter {
-namespace dmapper
-{
-using namespace com::sun::star;
-/*-- 12.11.2007 11:38:57---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-class WRITERFILTER_DLLPRIVATE Numbering_numHdl : public Properties
-{
-    ListTable&      m_rListTable;
-    sal_Int32       m_nAbstractNumId;
-    ::rtl::OUString m_sNumId;
-public:
-    Numbering_numHdl( ListTable& rListTable ) :
-        m_rListTable( rListTable ),
-        m_nAbstractNumId( -1 )
-        {}
-    virtual ~Numbering_numHdl();
-
-    // Properties
-    virtual void attribute(Id Name, Value & val);
-    virtual void sprm(Sprm & sprm);
-
-    sal_Int32       GetAbstractNumId() const { return m_nAbstractNumId;}
-    sal_Int32       GetNumId() const { return m_sNumId.toInt32(); }
-
-};
-typedef boost::shared_ptr< Numbering_numHdl >          Numbering_numHdlPtr;
-/*-- 12.11.2007 11:42:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-Numbering_numHdl::~Numbering_numHdl()
-{
-}
-/*-- 12.11.2007 11:42:22---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void Numbering_numHdl::attribute(Id nName, Value & rVal)
-{
-    switch( nName )
-    {
-        case NS_ooxml::LN_CT_Num_numId:
-            m_sNumId = rVal.getString();
-        break;
-        case NS_ooxml::LN_CT_NumLvl_ilvl :
-            m_rListTable.setOverwriteLevel(m_nAbstractNumId, rVal.getInt());
-        break;
-        default:;
-    }
-}
-/*-- 12.11.2007 11:42:22---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void Numbering_numHdl::sprm(Sprm & rSprm)
-{
-    sal_uInt32 nSprmId = rSprm.getId();
-    switch( nSprmId )
-    {
-        case NS_ooxml::LN_CT_Num_abstractNumId:
-        {
-            m_nAbstractNumId = rSprm.getValue()->getInt();
-        }
-        break;
-        case NS_ooxml::LN_CT_Num_lvlOverride: 
-        {
-            //contains a list override
-            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-            if(pProperties.get())
-                pProperties->resolve(*this);
-            m_rListTable.resetOverwrite();
-        }
-        case NS_ooxml::LN_CT_NumLvl_lvl:
-            m_rListTable.sprm( rSprm );
-        break;
-        default:;
-    }
-}
-/*-- 26.06.2006 13:14:29---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-class ListPropertyMap : public PropertyMap
-{
-    friend class ListTable;
-
-    sal_Int32                                       nIStartAt;       //LN_ISTARTAT
-    sal_Int32                                       nNFC;            //LN_NFC
-    sal_Int32                                       nJC;             //LN_JC
-    sal_Int32                                       nFLegal;         //LN_FLEGAL
-    sal_Int32                                       nFNoRestart;     //LN_FNORESTART
-    sal_Int32                                       nFPrev;          //LN_FPREV
-    sal_Int32                                       nFPrevSpace;     //LN_FPREVSPACE
-    sal_Int32                                       nFWord6;         //LN_FWORD6
-    ::rtl::OUString                                 sRGBXchNums;     //LN_RGBXCHNUMS
-    sal_Int32                                       nXChFollow;      //LN_IXCHFOLLOW
-    ::rtl::OUString                                 sBulletChar;
-    sal_Int32                                       nTabstop;
-public:
-    ListPropertyMap() :
-        nIStartAt(-1)
-        ,nNFC(-1)
-        ,nJC(-1)
-        ,nFLegal(-1)
-        ,nFNoRestart(-1)
-        ,nFPrev(-1)
-        ,nFPrevSpace(-1)
-        ,nFWord6(-1)
-        ,nXChFollow(-1)
-        ,nTabstop( 0 )
-        {}
-    ~ListPropertyMap(){}
-
-    uno::Sequence< beans::PropertyValue >  GetPropertyValuesList( PropertyValueVector_t& rCharStyleProperties  );
-};
-/*-- 26.06.2006 13:44:57---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-#define MAKE_PROPVAL(NameId, Value) \
-    beans::PropertyValue(aPropNameSupplier.GetName(NameId), 0, uno::makeAny(Value), beans::PropertyState_DIRECT_VALUE )
-
-uno::Sequence< beans::PropertyValue >  ListPropertyMap::GetPropertyValuesList( PropertyValueVector_t& rCharStyleProperties )
-{
-    const sal_Int16 aWWToUnoAdjust[] =
-    {
-        text::HoriOrientation::LEFT,
-        text::HoriOrientation::CENTER,
-        text::HoriOrientation::RIGHT,
-    };
-
-    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-    PropertyValueVector_t aNumberingProperties;
-
-    if( nIStartAt >= 0)
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_START_WITH, (sal_Int16)nIStartAt) );
-
-    sal_Int16 nNumberFormat = ConversionHelper::ConvertNumberingType(nNFC);
-    if( nNFC >= 0)
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_NUMBERING_TYPE, nNumberFormat ));
-
-    if( nJC >= 0 && nJC <= sal::static_int_cast<sal_Int32>(sizeof(aWWToUnoAdjust) / sizeof(sal_Int16)) )
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_ADJUST, aWWToUnoAdjust[nJC]));
-
-    // todo: this is not the bullet char
-    if( nNumberFormat == style::NumberingType::CHAR_SPECIAL && sBulletChar.getLength() )
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_BULLET_CHAR, sBulletChar.copy(0,1)));
-
-    aNumberingProperties.push_back( MAKE_PROPVAL( PROP_LISTTAB_STOP_POSITION, nTabstop ) );
-
-    //TODO: handling of nFLegal?
-    //TODO: nFNoRestart lower levels do not restart when higher levels are incremented, like:
-    //1.
-    //1.1
-    //2.2
-    //2.3
-    //3.4
-    //
-
-    if( nFWord6 > 0) //Word 6 compatibility
-    {
-        if( nFPrev == 1)
-            aNumberingProperties.push_back( MAKE_PROPVAL( PROP_PARENT_NUMBERING, (sal_Int16) NUMBERING_MAX_LEVELS ));
-        //TODO: prefixing space     nFPrevSpace;     - has not been used in WW8 filter
-    }
-
-//    TODO: sRGBXchNums;     array of inherited numbers
-
-//    TODO: nXChFollow; following character 0 - tab, 1 - space, 2 - nothing
-//    if(pProperties)
-//    {
-
-        _PropertyMap::const_iterator aMapIter = /*pProperties->*/begin();
-        _PropertyMap::const_iterator aEndIter = /*pProperties->*/end();
-        for( ; aMapIter != aEndIter; ++aMapIter )
-        {
-            switch( aMapIter->first.eId )
-            {
-                case PROP_ADJUST:
-                case PROP_INDENT_AT:
-                case PROP_FIRST_LINE_INDENT:
-                case PROP_FIRST_LINE_OFFSET:
-                case PROP_LEFT_MARGIN:
-                    aNumberingProperties.push_back(
-                        beans::PropertyValue( aPropNameSupplier.GetName( aMapIter->first.eId ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
-                break;
-                case PROP_CHAR_FONT_NAME:
-                    aNumberingProperties.push_back(
-                        beans::PropertyValue( aPropNameSupplier.GetName( PROP_BULLET_FONT_NAME ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
-                break;
-                default: 
-                {
-                    rCharStyleProperties.push_back(beans::PropertyValue( aPropNameSupplier.GetName( aMapIter->first.eId ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
-                }
-
-            }
-        }
-//    }
-    uno::Sequence< beans::PropertyValue > aRet(aNumberingProperties.size());
-    beans::PropertyValue* pValues = aRet.getArray();
-    PropertyValueVector_t::const_iterator aIt = aNumberingProperties.begin();
-    PropertyValueVector_t::const_iterator aEndIt = aNumberingProperties.end();
-    for(sal_uInt32 nIndex = 0; aIt != aEndIt; ++aIt,++nIndex)
-    {
-        pValues[nIndex] = *aIt;
-    }
-    return aRet;
-}
-typedef boost::shared_ptr<ListPropertyMap> ListPropertyMapPtr;
-
-struct ListEntry
-{
-    sal_Int32                                       nListId;        //LN_LSID
-    sal_Int32                                       nTPLC;          //LN_TPLC
-    ::rtl::OUString                                 sRGISTD;        //LN_RGISTD
-    sal_Int32                                       nSimpleList;    //LN_FSIMPLELIST
-    sal_Int32                                       nRestart;       //LN_FRESTARTHDN
-    sal_Int32                                       nUnsigned;      //LN_UNSIGNED26_2
-    sal_Int32                                       nAbstractNumId;
-
-    ::std::vector< ListPropertyMapPtr >             aLevelProperties; //properties of each level
-
-    ListPropertyMapPtr                              pCurrentProperties;
-    uno::Reference< container::XIndexReplace >      m_xNumRules;
-
-    ListEntry();
-
-};
-typedef boost::shared_ptr<ListEntry> ListEntryPtr;
-/*-- 23.06.2006 13:58:51---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-ListEntry::ListEntry() :
-    nListId(-1)
-    ,nTPLC(-1)
-    ,nSimpleList(-1)
-    ,nRestart(-1)
-    ,nUnsigned(-1)
-    ,nAbstractNumId(-1)
-{
-}
-/*-- 23.06.2006 13:58:51---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-struct ListTable_Impl
-{
-    DomainMapper&                                   m_rDMapper;
-    uno::Reference< lang::XMultiServiceFactory >    m_xFactory;
-
-    std::vector< ListEntryPtr >                     m_aListEntries;
-    ListEntryPtr                                    m_pCurrentEntry;
-
-
-    ListTable_Impl(DomainMapper& rDMapper, uno::Reference< lang::XMultiServiceFactory > xFactory) :
-            m_rDMapper( rDMapper )
-            ,m_xFactory( xFactory )
-            {}
-
-    void    AddLevel();
-};
-/*-- 26.06.2006 14:23:19---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable_Impl::AddLevel()
-{
-    ListPropertyMapPtr pLevel( new ListPropertyMap );
-    m_pCurrentEntry->pCurrentProperties = pLevel;
-    m_pCurrentEntry->aLevelProperties.push_back(pLevel);
-}
-/*-- 23.06.2006 12:04:32---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-ListTable::ListTable(
-        DomainMapper& rDMapper,
-        const uno::Reference< lang::XMultiServiceFactory > xFactory) :
-    m_pImpl( new ListTable_Impl(rDMapper, xFactory) ),
-    m_nOverwriteListId( -1 ),
-    m_nOverwriteLevel( -1 )
-{
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-ListTable::~ListTable()
-{
-    delete m_pImpl;
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::attribute(Id nName, Value & rVal)
-{
-    OSL_ENSURE( m_pImpl->m_pCurrentEntry.get(), "current entry has to be set here");
-    if(!m_pImpl->m_pCurrentEntry.get())
-        return ;
-    int nIntValue = rVal.getInt();
-    /* WRITERFILTERSTATUS: table: ListTable_attributedata */
-    switch(nName)
-    {
-        case NS_rtf::LN_RGBXCHNUMS:
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->sRGBXchNums += rVal.getString();
-        break;
-        case NS_ooxml::LN_CT_LevelText_val:
-        /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-        {    
-            //this strings contains the definition of the level
-            //the level number is marked as %n
-            //these numbers can be mixed randomly toghether with seperators pre- and suffixes
-            //the Writer supports only a number of upper levels to show, separators is always a dot
-            //and each level can have a prefix and a suffix
-            if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-            {
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->sBulletChar = rVal.getString();
-            }
-        }
-        break;
-//        case NS_rtf::LN_ISTD: break;
-        case NS_rtf::LN_ISTARTAT:
-        case NS_rtf::LN_NFC:
-        case NS_rtf::LN_JC:
-        case NS_rtf::LN_FLEGAL:
-        case NS_rtf::LN_FNORESTART:
-        case NS_rtf::LN_FIDENTSAV:
-        case NS_rtf::LN_FCONVERTED:
-        case NS_rtf::LN_FTENTATIVE:
-        case NS_rtf::LN_IXCHFOLLOW:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            ApplyLevelValues( nName, nIntValue);
-        break;
-        case NS_rtf::LN_LSID:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nListId = nIntValue;
-        break;
-        case NS_rtf::LN_TPLC:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nTPLC = nIntValue;
-        break;
-        case NS_rtf::LN_RGISTD:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->sRGISTD += rVal.getString();
-        break;
-        case NS_rtf::LN_FSIMPLELIST:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nSimpleList = nIntValue;
-        break;
-        case NS_rtf::LN_fAutoNum:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nRestart = nIntValue;
-        break;
-        case NS_rtf::LN_fHybrid:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            m_pImpl->m_pCurrentEntry->nUnsigned = nIntValue;
-        break;
-
-        case NS_rtf::LN_LISTLEVEL:
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-        {
-            //add a new level to the level vector and make it the current one
-            m_pImpl->AddLevel();
-
-            writerfilter::Reference<Properties>::Pointer_t pProperties;
-            if((pProperties = rVal.getProperties()).get())
-                pProperties->resolve(*this);
-        }
-        break;
-        case NS_ooxml::LN_CT_AbstractNum_abstractNumId:
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-        {    
-            sal_Int32 nVal = rVal.getString().toInt32();
-            m_pImpl->m_pCurrentEntry->nAbstractNumId = nVal;
-            m_pImpl->m_pCurrentEntry->nListId = nVal;
-        }
-        break;
-        case NS_ooxml::LN_CT_Ind_left:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_INDENT_AT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
-            break;
-        case NS_ooxml::LN_CT_Ind_hanging:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100( nIntValue ) ));
-        break;
-        case NS_ooxml::LN_CT_Ind_firstLine:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_FIRST_LINE_INDENT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
-        break;
-        case NS_ooxml::LN_CT_Lvl_ilvl: //overrides previous level - unsupported
-        case NS_ooxml::LN_CT_Lvl_tplc: //template code - unsupported
-        case NS_ooxml::LN_CT_Lvl_tentative: //marks level as unused in the document - unsupported
-        break;
-        case NS_ooxml::LN_CT_TabStop_pos:
-        {
-            //no paragraph attributes in ListTable char style sheets
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nTabstop = ConversionHelper::convertTwipToMM100( nIntValue );
-        }
-        break;
-        default:
-        {
-#if OSL_DEBUG_LEVEL > 0
-            ::rtl::OString sMessage( "ListTable::attribute() - Id: ");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 10 );
-            sMessage += ::rtl::OString(" / 0x");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 16 );
-            sMessage += ::rtl::OString(" value: ");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 10 );
-            sMessage += ::rtl::OString(" / 0x");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 16 );
-            OSL_ENSURE( false, sMessage.getStr()); //
-#endif
-        }
-    }
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::sprm(Sprm & rSprm)
-{
-    //fill the attributes of the style sheet
-    sal_uInt32 nSprmId = rSprm.getId();
-    if( m_pImpl->m_pCurrentEntry.get() ||
-        nSprmId == NS_ooxml::LN_CT_Numbering_abstractNum || 
-        nSprmId == NS_ooxml::LN_CT_Numbering_num )
-    {
-        sal_Int32 nIntValue = rSprm.getValue()->getInt();
-        /* WRITERFILTERSTATUS: table: ListTable_sprm */
-        switch( nSprmId )
-        {
-            case NS_ooxml::LN_CT_Numbering_abstractNum:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            {
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                {
-                    //create a new list entry
-                    OSL_ENSURE( !m_pImpl->m_pCurrentEntry.get(), "current entry has to be NULL here");
-                    m_pImpl->m_pCurrentEntry.reset( new ListEntry );
-                    pProperties->resolve( *this );
-                    //append it to the table
-                    m_pImpl->m_aListEntries.push_back( m_pImpl->m_pCurrentEntry );
-                    m_pImpl->m_pCurrentEntry = ListEntryPtr();
-                }
-            }
-            break;
-            case NS_ooxml::LN_CT_Numbering_num:
-            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            {
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                {
-                    Numbering_numHdlPtr pNumHdl( new Numbering_numHdl( *this ) );
-                    pProperties->resolve(*pNumHdl);
-                    //todo: is the order of numberings guaranteed?
-                    //sal_Int32       pNumhdl->GetNumId();
-                    m_pImpl->m_rDMapper.AddListIDToLFOTable( pNumHdl->GetAbstractNumId() );
-                }
-            }
-            break;
-            case NS_ooxml::LN_CT_AbstractNum_multiLevelType:
-            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-            break;
-            case NS_rtf::LN_TPLC:
-            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-                m_pImpl->m_pCurrentEntry->nTPLC = nIntValue;
-            break;
-            case NS_ooxml::LN_CT_AbstractNum_lvl:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            {
-                m_pImpl->AddLevel();
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-                }
-            break;
-// not a useful number in ooxml
-//            case NS_rtf::LN_LSID:
-//                m_pImpl->m_pCurrentEntry->nListId = nIntValue;
-//            break;
-            case NS_rtf::LN_RGBXCHNUMS: 
-            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-                break;
-            case NS_rtf::LN_ISTARTAT:
-            case NS_rtf::LN_NFC:
-            case NS_rtf::LN_JC:
-            case NS_rtf::LN_FLEGAL:
-            case NS_rtf::LN_FNORESTART:
-            case NS_rtf::LN_FIDENTSAV:
-            case NS_rtf::LN_FCONVERTED:
-            case NS_rtf::LN_FTENTATIVE:
-            case NS_rtf::LN_IXCHFOLLOW:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-                ApplyLevelValues( nSprmId, nIntValue );
-            break;
-            case NS_ooxml::LN_CT_Lvl_lvlText:
-            case NS_ooxml::LN_CT_Lvl_rPr : //contains LN_EG_RPrBase_rFonts
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            {    
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_NumLvl_lvl:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            {   
-                // overwrite level
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_Lvl_lvlJc:
-            {
-                static sal_Int16 aWWAlignments[ ] = 
-                {
-                    text::HoriOrientation::LEFT,
-                    text::HoriOrientation::CENTER,
-                    text::HoriOrientation::RIGHT
-                };
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert( 
-                    PROP_ADJUST, true, uno::makeAny( aWWAlignments[ nIntValue ] ) );
-                    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-            }
-            break;
-            case NS_ooxml::LN_CT_Lvl_pPr:
-            case NS_ooxml::LN_CT_PPrBase_ind:
-            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            {    
-                //todo: how to handle paragraph properties within numbering levels (except LeftIndent and FirstLineIndent)?
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_PPrBase_tabs:
-            case NS_ooxml::LN_CT_Tabs_tab:
-            {
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_Lvl_suff:
-            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-                //todo: currently unsupported suffix 
-                //can be: "none", "space", "tab"
-            break;
-            case NS_ooxml::LN_EG_RPrBase_rFonts: //contains font properties
-            case NS_ooxml::LN_EG_RPrBase_color:
-            case NS_ooxml::LN_EG_RPrBase_u:
-            case NS_sprm::LN_CHps:    // sprmCHps
-            case NS_ooxml::LN_EG_RPrBase_lang:
-            case NS_ooxml::LN_EG_RPrBase_eastAsianLayout:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-                //no break!
-            default:
-                if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-                {
-                    m_pImpl->m_rDMapper.PushListProperties( m_pImpl->m_pCurrentEntry->pCurrentProperties );
-                    m_pImpl->m_rDMapper.sprm( rSprm );
-                    m_pImpl->m_rDMapper.PopListProperties();
-                }
-        }    
-    }
-}
-/*-- 12.11.2007 09:36:09---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void    ListTable::ApplyLevelValues( sal_Int32 nId, sal_Int32 nIntValue)
-{
-    if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-    switch(nId)
-    {
-        case NS_rtf::LN_ISTARTAT:
-            /* WRITERFILTERSTATUS: */
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->nIStartAt = nIntValue;
-        break;
-        case NS_rtf::LN_NFC:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nNFC = nIntValue;
-        break;
-        case NS_rtf::LN_JC:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nJC = nIntValue;
-        break;
-        case NS_rtf::LN_FLEGAL:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFLegal = nIntValue;
-        break;
-        case NS_rtf::LN_FNORESTART:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFNoRestart = nIntValue;
-        break;
-        case NS_rtf::LN_FIDENTSAV:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFPrev = nIntValue;
-        break;
-        case NS_rtf::LN_FCONVERTED:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFPrevSpace = nIntValue;
-        break;
-#if 0
-        case NS_rtf::LN_FWORD6:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFWord6 = nIntValue;
-        break;
-#endif
-        case NS_rtf::LN_IXCHFOLLOW:
-            /* WRITERFILTERSTATUS: */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nXChFollow = nIntValue;
-        break;
-        default:
-            OSL_ENSURE( false, "this line should never be reached");
-    }
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::entry(int, writerfilter::Reference<Properties>::Pointer_t ref)
-{
-    
-    if( m_pImpl->m_rDMapper.IsOOXMLImport() )
-    {
-        ref->resolve(*this);
-    }
-    else
-    {
-        //create a new list entry
-        OSL_ENSURE( !m_pImpl->m_pCurrentEntry.get(), "current entry has to be NULL here");
-        m_pImpl->m_pCurrentEntry.reset( new ListEntry );
-        ref->resolve(*this);
-        //append it to the table
-        m_pImpl->m_aListEntries.push_back( m_pImpl->m_pCurrentEntry );
-        m_pImpl->m_pCurrentEntry = ListEntryPtr();
-    }
-}
-/*-- 26.06.2006 10:27:55---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-sal_uInt32 ListTable::size() const
-{
-    return m_pImpl->m_aListEntries.size();
-}
-
-rtl::OUString ListTable::GetStyleName( sal_Int32 nListId )
-{
-    rtl::OUString sStyleName( rtl::OUString::createFromAscii( "WWNum" ) );
-    sStyleName += rtl::OUString::valueOf( nListId + 1 );
-
-    return sStyleName;
-}
-
-void ListTable::CreateNumberingRules( )
-{
-    uno::Reference< container::XIndexReplace > xRet;
-    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
-    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
-    
-    uno::Reference< container::XNameContainer > xStyles;
-
-    try
-    {
-        uno::Reference< style::XStyleFamiliesSupplier > xFamilies( m_pImpl->m_xFactory, uno::UNO_QUERY_THROW );
-        uno::Any oFamily = xFamilies->getStyleFamilies( )->getByName( rtl::OUString::createFromAscii( "NumberingStyles" ) );
-
-        oFamily >>= xStyles;
-    }
-    catch ( const uno::Exception )
-    {
-    }
-
-    for(; aIt != aEndIt; ++aIt)
-    {
-        if( !(*aIt)->m_xNumRules.is() && m_pImpl->m_xFactory.is() && xStyles.is( ) )
-        {
-            try
-            {
-                // Create the numbering style
-                uno::Reference< beans::XPropertySet > xStyle (
-                    m_pImpl->m_xFactory->createInstance(
-                        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.NumberingStyle"))),
-                    uno::UNO_QUERY_THROW );
-
-                rtl::OUString sStyleName = GetStyleName( ( *aIt )->nListId );
-#if DEBUG
-                clog << "Creating numbering style: ";
-                clog << rtl::OUStringToOString( sStyleName, RTL_TEXTENCODING_UTF8 ).getStr( );
-                clog << endl;
-#endif
-
-                xStyles->insertByName( sStyleName, makeAny( xStyle ) );
-                
-                uno::Any oStyle = xStyles->getByName( sStyleName );
-                xStyle.set( oStyle, uno::UNO_QUERY_THROW );
-                
-                PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-                uno::Any aRules = xStyle->getPropertyValue( aPropNameSupplier.GetName( PROP_NUMBERING_RULES ) );
-                aRules >>= ( *aIt )->m_xNumRules;
-
-                //now fill the numbering levels appropriately
-                ::std::vector< ListPropertyMapPtr >::const_iterator aIter = (*aIt)->aLevelProperties.begin();
-                ::std::vector< ListPropertyMapPtr >::const_iterator aEnd = (*aIt)->aLevelProperties.end();
-                sal_Int32 nLevel = 0;
-                while(aIter != aEnd)
-                {
-                    PropertyValueVector_t aCharStyleProperties;
-                    uno::Sequence< beans::PropertyValue> aValues = (*aIter)->GetPropertyValuesList(aCharStyleProperties);
-                    if( aCharStyleProperties.size() )
-                    {
-                        //create (or find) a character style containing the character attributes of the symbol
-                        //and apply it to the numbering level
-                        ::rtl::OUString sStyle = m_pImpl->m_rDMapper.getOrCreateCharStyle( aCharStyleProperties );
-                        aValues.realloc( aValues.getLength() + 1);
-                        aValues[aValues.getLength() - 1].Name = aPropNameSupplier.GetName( PROP_CHAR_STYLE_NAME );
-                        aValues[aValues.getLength() - 1].Value <<= sStyle;
-                    }    
-                    //now parse the text to find %n from %1 to %nLevel+1
-                    //everything before the first % and the last %x is prefix and suffix
-                    ::rtl::OUString sLevelText( (*aIter)->sBulletChar );
-                    sal_Int32 nCurrentIndex = 0;
-                    sal_Int32 nFound = sLevelText.indexOf( '%', nCurrentIndex );
-                    if( nFound > 0 )
-                    {
-                        ::rtl::OUString sPrefix = sLevelText.copy( 0, nFound );
-                        aValues.realloc( aValues.getLength() + 1 );
-                        aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_PREFIX, sPrefix);
-                        sLevelText = sLevelText.copy( nFound );
-                    } 
-                    sal_Int32 nMinLevel = nLevel;
-                    //now the text should either be empty or start with %
-                    nFound = 0;
-                    while( nFound >= 0 )
-                    {
-                        if( sLevelText.getLength() > 1 )
-                        {
-                            sal_Unicode cLevel = sLevelText.getStr()[1];
-                            if( cLevel >= '1' && cLevel <= '9' )
-                            {
-                                if( cLevel - '1' < nMinLevel )
-                                    nMinLevel = cLevel - '1';
-                                //remove first char - next char is removed later
-                                sLevelText = sLevelText.copy( 1 );
-                            }
-                        }    
-                        //remove old '%' or number 
-                        sLevelText = sLevelText.copy( 1 );
-                        nCurrentIndex = 0;
-                        nFound = sLevelText.indexOf( '%', nCurrentIndex );
-                        //remove the text before the next %
-                        if(nFound > 0)
-                            sLevelText = sLevelText.copy( nFound -1 );
-                    }
-                    if( nMinLevel < nLevel )
-                    {
-                        aValues.realloc( aValues.getLength() + 1);
-                        aValues[ aValues.getLength() - 1 ] = 
-                            MAKE_PROPVAL(PROP_PARENT_NUMBERING, sal_Int16( nLevel - nMinLevel + 1));
-                    }
-                    aValues.realloc( aValues.getLength() + 1);
-                    aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_SUFFIX, sLevelText);
-
-                    aValues.realloc( aValues.getLength() + 1);
-                    aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL( PROP_POSITION_AND_SPACE_MODE, 
-                            sal_Int16( text::PositionAndSpaceMode::LABEL_ALIGNMENT ) );
-                    
-#if DEBUG
-                clog << endl << "Numbering rule properties - " << nLevel << endl;
-                for ( sal_Int32 i = 0, len = aValues.getLength( ); i < len; i++ )
-                {
-                    beans::PropertyValue aVal = aValues[i];
-                    clog << "    " << rtl::OUStringToOString( aVal.Name, RTL_TEXTENCODING_UTF8 ).getStr( );
-                    clog << ": ";
-                    rtl::OUString sVal;
-                    sal_Int32 nVal;
-                    if ( aVal.Value >>= sVal )
-                    {
-                        clog << rtl::OUStringToOString( sVal, RTL_TEXTENCODING_UTF8 ).getStr( );
-                    }
-                    else if ( aVal.Value >>= nVal )
-                    {
-                        clog << nVal;
-                    }
-                    clog << endl;
-                }
-#endif
-
-                    (*aIt)->m_xNumRules->replaceByIndex(nLevel, uno::makeAny(aValues));
-                    ++aIter;
-                    ++nLevel;
-                }
-            
-                // Create the numbering style for these rules 
-                rtl::OUString sNumRulesName = aPropNameSupplier.GetName( PROP_NUMBERING_RULES );
-                xStyle->setPropertyValue( 
-                        sNumRulesName, 
-                        uno::makeAny( ( *aIt )->m_xNumRules ) );
-            }
-            catch( const uno::Exception& rEx)
-            {
-                (void)rEx;
-                OSL_ENSURE( false, "ListTable::CreateNumberingRules");
-            }
-        }
-    }
-}
-
-/*-- 26.06.2006 10:33:56---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-uno::Reference< container::XIndexReplace > ListTable::GetNumberingRules(sal_Int32 nListId)
-{
-    uno::Reference< container::XIndexReplace > xRet;
-    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
-    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
-    for(; aIt != aEndIt; ++aIt)
-    {
-        if((*aIt)->nListId == nListId)
-        {
-            xRet = (*aIt)->m_xNumRules;
-            break;
-        }
-    }
-    return xRet;
-}
-/*-- 19.11.2007 13:25:32---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::setOverwriteLevel(sal_Int32 nAbstractNumId, sal_Int32 nLevel)
-{
-    m_nOverwriteListId = nAbstractNumId;
-    m_nOverwriteLevel = nLevel;
-    OSL_ENSURE(!m_pImpl->m_pCurrentEntry.get(), "where to put the overwrite level");
-    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
-    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
-    for(; aIt != aEndIt; ++aIt)
-    {
-        if( (*aIt)->nListId == nAbstractNumId )
-        {
-            m_pImpl->m_pCurrentEntry = *aIt;
-            break;
-        }
-    }
-    OSL_ENSURE( m_pImpl->m_pCurrentEntry.get(), "list not found");
-}
-/*-- 19.11.2007 13:25:32---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::resetOverwrite()
-{
-    m_nOverwriteListId =  -1;
-    m_nOverwriteLevel = -1;
-    m_pImpl->m_pCurrentEntry.reset();
-}
-
-}//namespace dmapper
-}//namespace writerfilter
-
diff --git writerfilter/source/dmapper/ListTable.hxx writerfilter/source/dmapper/ListTable.hxx
deleted file mode 100644
index ab247bc..0000000
--- writerfilter/source/dmapper/ListTable.hxx
+++ /dev/null
@@ -1,89 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef INCLUDED_LISTTABLE_HXX
-#define INCLUDED_LISTTABLE_HXX
-
-#include <WriterFilterDllApi.hxx>
-#include <PropertyMap.hxx>
-#include <resourcemodel/WW8ResourceModel.hxx>
-
-namespace com{ namespace sun { namespace star {
-    namespace text{
-        class XTextDocument;
-    }
-    namespace container{
-        class XIndexReplace;
-    }
-    namespace lang{
-        class XMultiServiceFactory;
-    }
-}}}
-
-namespace writerfilter {
-namespace dmapper
-{
-class DomainMapper;
-struct ListTable_Impl;
-class WRITERFILTER_DLLPRIVATE ListTable :
-        public Properties,
-        public Table
-{
-    ListTable_Impl   *m_pImpl;
-    sal_Int32       m_nOverwriteListId;
-    sal_Int32       m_nOverwriteLevel;
-
-    void    ApplyLevelValues( sal_Int32 nId, sal_Int32 nIntValue);
-public:
-    ListTable(
-            DomainMapper& rDMapper,
-            const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > xFactory);
-    virtual ~ListTable();
-
-    // Properties
-    virtual void attribute(Id Name, Value & val);
-    virtual void sprm(Sprm & sprm);
-
-    // Table
-    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
-
-    // BinaryObj
-//    virtual void data(const sal_Int8* buf, size_t len,
-//                      writerfilter::Reference<Properties>::Pointer_t ref);
-
-    sal_uInt32          size() const;
-    rtl::OUString GetStyleName( sal_Int32 nListId );
-    void CreateNumberingRules( );
-    ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexReplace >
-            GetNumberingRules(sal_Int32 nListId);
-
-    void setOverwriteLevel(sal_Int32 nAbstractNumId, sal_Int32 nLevel);
-    void resetOverwrite();
-};
-typedef boost::shared_ptr< ListTable >          ListTablePtr;
-}}
-
-#endif //
diff --git writerfilter/source/dmapper/NumberingManager.cxx writerfilter/source/dmapper/NumberingManager.cxx
new file mode 100644
index 0000000..4505bba
--- /dev/null
+++ writerfilter/source/dmapper/NumberingManager.cxx
@@ -0,0 +1,1017 @@
+#include "ConversionHelper.hxx"
+#include "NumberingManager.hxx"
+#include "StyleSheetTable.hxx"
+#include "PropertyIds.hxx"
+
+#include <doctok/resourceids.hxx>
+#include <doctok/sprmids.hxx>
+#include <ooxml/resourceids.hxx>
+
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/NumberingType.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/PositionAndSpaceMode.hpp>
+#include <com/sun/star/text/XChapterNumberingSupplier.hpp>
+
+#if DEBUG
+#include <stdio.h>
+#endif
+
+using namespace rtl;
+using namespace com::sun::star;
+
+#define MAKE_PROPVAL(NameId, Value) \
+    beans::PropertyValue(aPropNameSupplier.GetName(NameId), 0, uno::makeAny(Value), beans::PropertyState_DIRECT_VALUE )
+
+#define OUSTR_TO_C( x )  OUStringToOString( x, RTL_TEXTENCODING_UTF8 ).getStr( )
+
+#define NUMBERING_MAX_LEVELS    10
+
+
+namespace writerfilter {
+namespace dmapper {
+
+//---------------------------------------------------  Utility functions
+    
+void lcl_printProperties( uno::Sequence< beans::PropertyValue > aProps )
+{
+    sal_Int32 nLen = aProps.getLength( );
+    for ( sal_Int32 i = 0; i < nLen; i++ )
+    {
+        uno::Any aValue = aProps[i].Value;
+        sal_Int32 nValue = 0;
+        OUString sValue;
+
+        if ( !( aValue >>= sValue ) && ( aValue >>= nValue ) )
+            sValue = OUString::valueOf( nValue );
+
+#if DEBUG
+        fprintf( stderr, "Property %s: %s\n", 
+                OUSTR_TO_C( aProps[i].Name ),
+                OUSTR_TO_C( sValue ) );
+#endif
+    }
+}
+
+sal_Int32 lcl_findProperty( uno::Sequence< beans::PropertyValue > aProps, OUString sName )
+{
+    sal_Int32 i = 0;
+    sal_Int32 nLen = aProps.getLength( );
+    sal_Int32 nPos = -1;
+
+    while ( nPos == -1 && i < nLen )
+    {
+        if ( aProps[i].Name.equals( sName ) )
+            nPos = i;
+        else
+            i++;
+    }
+
+    return nPos;
+}
+
+void lcl_mergeProperties( uno::Sequence< beans::PropertyValue >& aSrc,
+        uno::Sequence< beans::PropertyValue >& aDst )
+{
+    for ( sal_Int32 i = 0, nSrcLen = aSrc.getLength( ); i < nSrcLen; i++ )
+    {
+        // Look for the same property in aDst
+        sal_Int32 nPos = lcl_findProperty( aDst, aSrc[i].Name );
+        if ( nPos >= 0 )
+        {
+            // Replace the property value by the one in aSrc
+            aDst[nPos] = aSrc[i];
+        }
+        else
+        {
+            // Simply add the new value
+            aDst.realloc( aDst.getLength( ) + 1 );
+            aDst[ aDst.getLength( ) - 1 ] = aSrc[i];
+        }
+    }
+}
+
+//--------------------------------------------  ListLevel implementation
+void ListLevel::SetValue( Id nId, sal_Int32 nValue )
+{
+    switch( nId )
+    {
+        case NS_rtf::LN_ISTARTAT:
+            m_nIStartAt = nValue;
+        break;
+        case NS_rtf::LN_NFC:
+            m_nNFC = nValue;
+        break;
+        case NS_rtf::LN_JC:
+            m_nJC = nValue;
+        break;
+        case NS_rtf::LN_FLEGAL:
+            m_nFLegal = nValue;
+        break;
+        case NS_rtf::LN_FNORESTART:
+            m_nFNoRestart = nValue;
+        break;
+        case NS_rtf::LN_FIDENTSAV:
+            m_nFPrev = nValue;
+        break;
+        case NS_rtf::LN_FCONVERTED:
+            m_nFPrevSpace = nValue;
+        break;
+#if 0
+        case NS_rtf::LN_FWORD6:
+            m_nFWord6 = nValue;
+        break;
+#endif
+        case NS_rtf::LN_IXCHFOLLOW:
+            m_nXChFollow = nValue;
+  break;
+        case NS_ooxml::LN_CT_TabStop_pos:
+            m_nTabstop = nValue;
+        break;
+        default:
+            OSL_ENSURE( false, "this line should never be reached");
+    }
+}
+
+sal_Int16 ListLevel::GetParentNumbering( OUString sText, sal_Int16 nLevel, 
+        OUString& rPrefix, OUString& rSuffix )
+{
+    sal_Int16 nParentNumbering = nLevel;
+
+    //now parse the text to find %n from %1 to %nLevel+1
+    //everything before the first % and the last %x is prefix and suffix
+    OUString sLevelText( sText );
+    sal_Int32 nCurrentIndex = 0;
+    sal_Int32 nFound = sLevelText.indexOf( '%', nCurrentIndex );
+    if( nFound > 0 )
+    {
+        rPrefix = sLevelText.copy( 0, nFound );
+        sLevelText = sLevelText.copy( nFound );
+    } 
+    sal_Int32 nMinLevel = nLevel;
+    //now the text should either be empty or start with %
+    nFound = sLevelText.getLength( ) > 1 ? 0 : -1;
+    while( nFound >= 0 )
+    {
+        if( sLevelText.getLength() > 1 )
+        {
+            sal_Unicode cLevel = sLevelText.getStr()[1];
+            if( cLevel >= '1' && cLevel <= '9' )
+            {
+                if( cLevel - '1' < nMinLevel )
+                    nMinLevel = cLevel - '1';
+                //remove first char - next char is removed later
+                sLevelText = sLevelText.copy( 1 );
+            }
+        }    
+        //remove old '%' or number 
+        sLevelText = sLevelText.copy( 1 );
+        nCurrentIndex = 0;
+        nFound = sLevelText.indexOf( '%', nCurrentIndex );
+        //remove the text before the next %
+        if(nFound > 0)
+            sLevelText = sLevelText.copy( nFound -1 );
+    }
+    if( nMinLevel < nLevel )
+    {
+        nParentNumbering = sal_Int16( nLevel - nMinLevel + 1);
+    }
+
+    rSuffix = sLevelText;
+
+    return nParentNumbering;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetProperties( )
+{
+    uno::Sequence< beans::PropertyValue > aLevelProps = GetLevelProperties( );
+    if ( m_pParaStyle.get( ) )
+    {
+        // Merge with the paragraph properties
+        uno::Sequence< beans::PropertyValue > aParaProps = GetParaProperties( );
+        lcl_mergeProperties( aParaProps, aLevelProps );
+    }
+    return aLevelProps;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetCharStyleProperties( )
+{
+    PropertyValueVector_t rProperties;
+    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+    _PropertyMap::const_iterator aMapIter = begin();
+    _PropertyMap::const_iterator aEndIter = end();
+    for( ; aMapIter != aEndIter; ++aMapIter )
+    {
+        switch( aMapIter->first.eId )
+        {
+            case PROP_ADJUST:
+            case PROP_INDENT_AT:
+            case PROP_FIRST_LINE_INDENT:
+            case PROP_FIRST_LINE_OFFSET:
+            case PROP_LEFT_MARGIN:
+            case PROP_CHAR_FONT_NAME:
+                // Do nothing: handled in the GetPropertyValues method
+            break;
+            default: 
+            {
+                rProperties.push_back(
+                        beans::PropertyValue( 
+                            aPropNameSupplier.GetName( aMapIter->first.eId ), 0, 
+                            aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
+            }
+        }
+    }
+
+    uno::Sequence< beans::PropertyValue > aRet( rProperties.size() );
+    beans::PropertyValue* pValues = aRet.getArray();
+    PropertyValueVector_t::const_iterator aIt = rProperties.begin();
+    PropertyValueVector_t::const_iterator aEndIt = rProperties.end();
+    for(sal_uInt32 nIndex = 0; aIt != aEndIt; ++aIt,++nIndex)
+    {
+        pValues[nIndex] = *aIt;
+    }
+    return aRet;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetLevelProperties( )
+{
+    const sal_Int16 aWWToUnoAdjust[] =
+    {
+        text::HoriOrientation::LEFT,
+        text::HoriOrientation::CENTER,
+        text::HoriOrientation::RIGHT,
+    };
+
+    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+    PropertyValueVector_t aNumberingProperties;
+
+    if( m_nIStartAt >= 0)
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_START_WITH, (sal_Int16)m_nIStartAt) );
+
+    sal_Int16 nNumberFormat = ConversionHelper::ConvertNumberingType(m_nNFC);
+    if( m_nNFC >= 0)
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_NUMBERING_TYPE, nNumberFormat ));
+
+    if( m_nJC >= 0 && m_nJC <= sal::static_int_cast<sal_Int32>(sizeof(aWWToUnoAdjust) / sizeof(sal_Int16)) )
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_ADJUST, aWWToUnoAdjust[m_nJC]));
+
+    // todo: this is not the bullet char
+    if( nNumberFormat == style::NumberingType::CHAR_SPECIAL && m_sBulletChar.getLength() )
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_BULLET_CHAR, m_sBulletChar.copy(0,1)));
+
+    aNumberingProperties.push_back( MAKE_PROPVAL( PROP_LISTTAB_STOP_POSITION, m_nTabstop ) );
+
+    //TODO: handling of nFLegal?
+    //TODO: nFNoRestart lower levels do not restart when higher levels are incremented, like:
+    //1.
+    //1.1
+    //2.2
+    //2.3
+    //3.4
+    //
+
+    if( m_nFWord6 > 0) //Word 6 compatibility
+    {
+        if( m_nFPrev == 1)
+            aNumberingProperties.push_back( MAKE_PROPVAL( PROP_PARENT_NUMBERING, (sal_Int16) NUMBERING_MAX_LEVELS ));
+        //TODO: prefixing space     nFPrevSpace;     - has not been used in WW8 filter
+    }
+
+//    TODO: sRGBXchNums;     array of inherited numbers
+
+//    TODO: nXChFollow; following character 0 - tab, 1 - space, 2 - nothing
+
+    _PropertyMap::const_iterator aMapIter = begin();
+    _PropertyMap::const_iterator aEndIter = end();
+    for( ; aMapIter != aEndIter; ++aMapIter )
+    {
+        switch( aMapIter->first.eId )
+        {
+            case PROP_ADJUST:
+            case PROP_INDENT_AT:
+            case PROP_FIRST_LINE_INDENT:
+            case PROP_FIRST_LINE_OFFSET:
+            case PROP_LEFT_MARGIN:
+                aNumberingProperties.push_back(
+                    beans::PropertyValue( aPropNameSupplier.GetName( aMapIter->first.eId ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
+            break;
+            case PROP_CHAR_FONT_NAME:
+                aNumberingProperties.push_back(
+                    beans::PropertyValue( aPropNameSupplier.GetName( PROP_BULLET_FONT_NAME ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
+            break;
+            default: 
+            {
+                // Handled in GetCharStyleProperties method
+            }
+
+        }
+    }
+    
+    uno::Sequence< beans::PropertyValue > aRet(aNumberingProperties.size());
+    beans::PropertyValue* pValues = aRet.getArray();
+    PropertyValueVector_t::const_iterator aIt = aNumberingProperties.begin();
+    PropertyValueVector_t::const_iterator aEndIt = aNumberingProperties.end();
+    for(sal_uInt32 nIndex = 0; aIt != aEndIt; ++aIt,++nIndex)
+    {
+        pValues[nIndex] = *aIt;
+    }
+    return aRet;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetParaProperties( )
+{
+    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+    uno::Sequence< beans::PropertyValue > aParaProps = m_pParaStyle->pProperties->GetPropertyValues( );
+    uno::Sequence< beans::PropertyValue > aProps;
+
+    // ParaFirstLineIndent -> FirstLineIndent
+    // ParaLeftMargin -> IndentAt
+
+    OUString sParaIndent = aPropNameSupplier.GetName( 
+            PROP_PARA_FIRST_LINE_INDENT );
+    OUString sFirstLineIndent = aPropNameSupplier.GetName( 
+            PROP_FIRST_LINE_INDENT );
+    OUString sParaLeftMargin = aPropNameSupplier.GetName( 
+            PROP_PARA_LEFT_MARGIN );
+    OUString sIndentAt = aPropNameSupplier.GetName( 
+            PROP_INDENT_AT );
+
+    sal_Int32 nLen = aParaProps.getLength( );
+    for ( sal_Int32 i = 0; i < nLen; i++ )
+    {
+        if ( aParaProps[i].Name.equals( sParaIndent ) )
+        {
+            aProps.realloc( aProps.getLength() + 1 );
+            aProps[aProps.getLength( ) - 1] = aParaProps[i];
+            aProps[aProps.getLength( ) - 1].Name = sFirstLineIndent;
+        }
+        else if ( aParaProps[i].Name.equals( sParaLeftMargin ) )
+        {
+            aProps.realloc( aProps.getLength() + 1 );
+            aProps[aProps.getLength( ) - 1] = aParaProps[i];
+            aProps[aProps.getLength( ) - 1].Name = sIndentAt;
+        }
+        
+    }
+
+    return aProps;
+}
+
+//--------------------------------------- AbstractListDef implementation
+
+AbstractListDef::AbstractListDef( ) :
+    m_nTPLC( -1 )
+    ,m_nSimpleList( -1 )
+    ,m_nRestart( -1 )
+    ,m_nUnsigned( -1 )
+    ,m_nId( -1 )
+{
+}
+
+AbstractListDef::~AbstractListDef( )
+{
+}
+
+void AbstractListDef::SetValue( sal_uInt32 nSprmId, sal_Int32 nValue )
+{
+    switch( nSprmId )
+    {
+        case NS_rtf::LN_TPLC:
+            m_nTPLC = nValue;
+        break;
+        case NS_rtf::LN_FSIMPLELIST:
+            m_nSimpleList = nValue;
+        break;
+        case NS_rtf::LN_fAutoNum:
+            m_nRestart = nValue;
+        break;
+        case NS_rtf::LN_fHybrid:
+            m_nUnsigned = nValue;
+        break;
+        default:
+            OSL_ENSURE( false, "this line should never be reached");
+    }
+}
+
+ListLevel::Pointer AbstractListDef::GetLevel( sal_uInt16 nLvl )
+{ 
+    ListLevel::Pointer pLevel;
+    if ( m_aLevels.size( ) > nLvl )
+        pLevel = m_aLevels[ nLvl ];
+    return pLevel;
+}
+
+void AbstractListDef::AddLevel( )
+{
+    ListLevel::Pointer pLevel( new ListLevel );
+    m_pCurrentLevel = pLevel;
+    m_aLevels.push_back( pLevel );
+}
+
+uno::Sequence< uno::Sequence< beans::PropertyValue > > AbstractListDef::GetPropertyValues( )
+{
+    uno::Sequence< uno::Sequence< beans::PropertyValue > > result( sal_Int32( m_aLevels.size( ) ) );
+    uno::Sequence< beans::PropertyValue >* aResult = result.getArray( );
+
+    int nLevels = m_aLevels.size( );
+    for ( int i = 0; i < nLevels; i++ )
+    {
+        aResult[i] = m_aLevels[i]->GetProperties( );
+    }
+
+    return result;
+}
+
+//----------------------------------------------  ListDef implementation
+
+ListDef::ListDef( ) : AbstractListDef( )
+{
+}
+
+ListDef::~ListDef( )
+{
+}
+
+OUString ListDef::GetStyleName( sal_Int32 nId )
+{
+    OUString sStyleName( OUString::createFromAscii( "WWNum" ) );
+    sStyleName += OUString::valueOf( nId );
+
+    return sStyleName;
+}
+
+uno::Sequence< uno::Sequence< beans::PropertyValue > > ListDef::GetPropertyValues( )
+{
+    // [1] Call the same method on the abstract list
+    uno::Sequence< uno::Sequence< beans::PropertyValue > > aAbstract = m_pAbstractDef->GetPropertyValues( );
+    
+    // [2] Call the upper class method
+    uno::Sequence< uno::Sequence< beans::PropertyValue > > aThis = AbstractListDef::GetPropertyValues( );
+    
+    // Merge the results of [2] in [1]
+    sal_Int32 nThisCount = aThis.getLength( );
+    for ( sal_Int32 i = 0; i < nThisCount; i++ )
+    {
+        uno::Sequence< beans::PropertyValue > level = aThis[i];
+        if ( level.getLength( ) == 0 )
+        {
+            // If the the element contains something, merge it
+            lcl_mergeProperties( level, aAbstract[i] );
+        }
+    }
+
+    return aAbstract;
+}
+
+uno::Reference< container::XNameContainer > lcl_getUnoNumberingStyles( 
+       uno::Reference< lang::XMultiServiceFactory > xFactory )
+{
+    uno::Reference< container::XNameContainer > xStyles;
+
+    try
+    {
+        uno::Reference< style::XStyleFamiliesSupplier > xFamilies( xFactory, uno::UNO_QUERY_THROW );
+        uno::Any oFamily = xFamilies->getStyleFamilies( )->getByName( OUString::createFromAscii( "NumberingStyles" ) );
+
+        oFamily >>= xStyles;
+    }
+    catch ( const uno::Exception )
+    {
+    }
+
+    return xStyles;
+}
+
+void ListDef::CreateNumberingRules( DomainMapper& rDMapper,
+        uno::Reference< lang::XMultiServiceFactory> xFactory )
+{
+    // Get the UNO Numbering styles
+    uno::Reference< container::XNameContainer > xStyles = lcl_getUnoNumberingStyles( xFactory );
+
+    // Do the whole thing
+    if( !m_xNumRules.is() && xFactory.is() && xStyles.is( ) )
+    {
+        try
+        {
+            // Create the numbering style
+            uno::Reference< beans::XPropertySet > xStyle (
+                xFactory->createInstance( 
+                    OUString::createFromAscii("com.sun.star.style.NumberingStyle")),
+                uno::UNO_QUERY_THROW );
+
+            rtl::OUString sStyleName = GetStyleName( GetId( ) );
+
+            xStyles->insertByName( sStyleName, makeAny( xStyle ) );
+            
+            uno::Any oStyle = xStyles->getByName( sStyleName );
+            xStyle.set( oStyle, uno::UNO_QUERY_THROW );
+            
+            PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+            // Get the default OOo Numbering style rules
+            uno::Any aRules = xStyle->getPropertyValue( aPropNameSupplier.GetName( PROP_NUMBERING_RULES ) );
+            aRules >>= m_xNumRules;
+
+            uno::Sequence< uno::Sequence< beans::PropertyValue > > aProps = GetPropertyValues( );
+
+            sal_Int32 nAbstLevels = m_pAbstractDef->Size( );
+            sal_Int16 nLevel = 0;
+            while ( nLevel < nAbstLevels )
+            {
+                ListLevel::Pointer pAbsLevel = m_pAbstractDef->GetLevel( nLevel );
+                ListLevel::Pointer pLevel = GetLevel( nLevel );
+                
+                // Get the merged level properties
+                uno::Sequence< beans::PropertyValue > aLvlProps = aProps[sal_Int32( nLevel )];
+
+                lcl_printProperties( aLvlProps );
+
+                // Get the char style
+                uno::Sequence< beans::PropertyValue > aAbsCharStyleProps = pAbsLevel->GetCharStyleProperties( );
+                uno::Sequence< beans::PropertyValue >& rAbsCharStyleProps = aAbsCharStyleProps;
+                if ( pLevel.get( ) )
+                {
+                    uno::Sequence< beans::PropertyValue > aCharStyleProps = 
+                        pLevel->GetCharStyleProperties( );
+                    uno::Sequence< beans::PropertyValue >& rCharStyleProps = aCharStyleProps;
+                    lcl_mergeProperties( rAbsCharStyleProps, rCharStyleProps );
+                }
+                    
+                if( aAbsCharStyleProps.getLength() )
+                {
+                    // Change the sequence into a vector
+                    PropertyValueVector_t aStyleProps;
+                    for ( sal_Int32 i = 0, nLen = aAbsCharStyleProps.getLength() ; i < nLen; i++ )
+                    {
+                        aStyleProps.push_back( aAbsCharStyleProps[i] );
+                    }
+
+                    //create (or find) a character style containing the character 
+                    // attributes of the symbol and apply it to the numbering level
+                    OUString sStyle = rDMapper.getOrCreateCharStyle( aStyleProps );
+                    aLvlProps.realloc( aLvlProps.getLength() + 1);
+                    aLvlProps[aLvlProps.getLength() - 1].Name = aPropNameSupplier.GetName( PROP_CHAR_STYLE_NAME );
+                    aLvlProps[aLvlProps.getLength() - 1].Value <<= sStyle;
+                }    
+ 
+                // Get the prefix / suffix / Parent numbering 
+                // and add them to the level properties
+                OUString sText = pAbsLevel->GetBulletChar( );
+                if ( pLevel.get( ) )
+                    sText = pLevel->GetBulletChar( );
+
+                OUString sPrefix;
+                OUString sSuffix;
+                OUString& rPrefix = sPrefix;
+                OUString& rSuffix = sSuffix;
+                sal_Int16 nParentNum = ListLevel::GetParentNumbering(
+                       sText, nLevel, rPrefix, rSuffix );
+
+                aLvlProps.realloc( aLvlProps.getLength( ) + 4 );
+                aLvlProps[ aLvlProps.getLength( ) - 4 ] = MAKE_PROPVAL( PROP_PREFIX, rPrefix );
+                aLvlProps[ aLvlProps.getLength( ) - 3 ] = MAKE_PROPVAL( PROP_SUFFIX, rSuffix );
+                aLvlProps[ aLvlProps.getLength( ) - 2 ] = MAKE_PROPVAL( PROP_PARENT_NUMBERING, nParentNum );
+
+                aLvlProps[ aLvlProps.getLength( ) - 1 ] = MAKE_PROPVAL( PROP_POSITION_AND_SPACE_MODE, 
+                            sal_Int16( text::PositionAndSpaceMode::LABEL_ALIGNMENT ) );
+                // Replace the numbering rules for the level
+                m_xNumRules->replaceByIndex( nLevel, uno::makeAny( aLvlProps ) );
+                
+                // Handle the outline level here
+                StyleSheetEntryPtr pParaStyle = pAbsLevel->GetParaStyle( );
+                if ( pParaStyle.get( ) )
+                {
+                    uno::Reference< text::XChapterNumberingSupplier > xOutlines (
+                        xFactory, uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexReplace > xOutlineRules = 
+                        xOutlines->getChapterNumberingRules( );
+
+                    aLvlProps.realloc( aLvlProps.getLength() + 1 );
+                    aLvlProps[aLvlProps.getLength( ) - 1] = MAKE_PROPVAL( PROP_HEADING_STYLE_NAME, pParaStyle->sConvertedStyleName );
+
+                    xOutlineRules->replaceByIndex( nLevel, uno::makeAny( aLvlProps ) );
+                }
+
+                nLevel++;
+            }
+
+            // Create the numbering style for these rules 
+            OUString sNumRulesName = aPropNameSupplier.GetName( PROP_NUMBERING_RULES );
+            xStyle->setPropertyValue( sNumRulesName, uno::makeAny( m_xNumRules ) );
+        }
+        catch( const uno::Exception& rEx)
+        {
+            OSL_ENSURE( false, "ListTable::CreateNumberingRules");
+        }
+    }
+
+}
+
+//-------------------------------------  NumberingManager implementation
+
+
+ListsManager::ListsManager( DomainMapper& rDMapper, 
+        const uno::Reference< lang::XMultiServiceFactory > xFactory ) :
+    m_rDMapper( rDMapper ),
+    m_xFactory( xFactory )
+{
+}
+
+ListsManager::~ListsManager( )
+{
+}
+
+void ListsManager::attribute( Id nName, Value& rVal )
+{
+    OSL_ENSURE( m_pCurrentDefinition.get(), "current entry has to be set here");
+    if(!m_pCurrentDefinition.get())
+        return ;
+    int nIntValue = rVal.getInt();
+
+    ListLevel::Pointer pCurrentLvl = m_pCurrentDefinition->GetCurrentLevel( );
+
+
+    /* WRITERFILTERSTATUS: table: ListTable_attributedata */
+    switch(nName)
+    {
+        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
+        case NS_rtf::LN_RGBXCHNUMS:
+            if(pCurrentLvl.get())
+                pCurrentLvl->AddRGBXchNums( rVal.getString( ) );
+        break;
+        /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
+        case NS_ooxml::LN_CT_LevelText_val:
+        {    
+            //this strings contains the definition of the level
+            //the level number is marked as %n
+            //these numbers can be mixed randomly toghether with seperators pre- and suffixes
+            //the Writer supports only a number of upper levels to show, separators is always a dot
+            //and each level can have a prefix and a suffix
+            if(pCurrentLvl.get())
+                pCurrentLvl->SetBulletChar( rVal.getString() );
+        }
+        break;
+//        case NS_rtf::LN_ISTD: break;
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_ISTARTAT:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_NFC:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_JC:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FLEGAL:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FNORESTART:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FIDENTSAV:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FCONVERTED:
+#if 0
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FWORD6:
+#endif
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_IXCHFOLLOW:
+            if ( pCurrentLvl.get( ) )
+                pCurrentLvl->SetValue( nName, sal_Int32( nIntValue ) );
+        break;
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_RGISTD:
+            m_pCurrentDefinition->AddRGISTD( rVal.getString() );
+        break;
+        case NS_ooxml::LN_CT_Num_numId:
+            m_pCurrentDefinition->SetId( rVal.getString().toInt32( ) );
+        break; 
+        case NS_rtf::LN_LSID:
+            m_pCurrentDefinition->SetId( nIntValue );
+        break;
+        case NS_rtf::LN_TPLC:
+        case NS_rtf::LN_FSIMPLELIST:
+        case NS_rtf::LN_fAutoNum:
+        case NS_rtf::LN_fHybrid:
+            m_pCurrentDefinition->SetValue( nName, nIntValue );
+        break;
+        case NS_ooxml::LN_CT_NumLvl_ilvl:
+        case NS_rtf::LN_LISTLEVEL:
+        {
+            //add a new level to the level vector and make it the current one
+            m_pCurrentDefinition->AddLevel();
+
+            writerfilter::Reference<Properties>::Pointer_t pProperties;
+            if((pProperties = rVal.getProperties()).get())
+                pProperties->resolve(*this);
+        }
+        break;
+        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+        case NS_ooxml::LN_CT_AbstractNum_abstractNumId:
+        {   
+            // This one corresponds to the AbstractNum Id definition
+            // The reference to the abstract num is in the sprm method
+            sal_Int32 nVal = rVal.getString().toInt32();
+            m_pCurrentDefinition->SetId( nVal );
+        }
+        break;
+        case NS_ooxml::LN_CT_Ind_left:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            pCurrentLvl->Insert(
+                PROP_INDENT_AT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
+            break;
+        case NS_ooxml::LN_CT_Ind_hanging:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            pCurrentLvl->Insert(
+                PROP_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100( nIntValue ) ));
+        break;
+        case NS_ooxml::LN_CT_Ind_firstLine:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            pCurrentLvl->Insert(
+                PROP_FIRST_LINE_INDENT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
+        break;
+        case NS_ooxml::LN_CT_Lvl_ilvl: //overrides previous level - unsupported
+        case NS_ooxml::LN_CT_Lvl_tplc: //template code - unsupported
+        case NS_ooxml::LN_CT_Lvl_tentative: //marks level as unused in the document - unsupported
+        break;
+        case NS_ooxml::LN_CT_TabStop_pos:
+        {
+            //no paragraph attributes in ListTable char style sheets
+            if ( pCurrentLvl.get( ) )
+                pCurrentLvl->SetValue( nName, 
+                    ConversionHelper::convertTwipToMM100( nIntValue ) );
+        }
+        break;
+        case NS_ooxml::LN_CT_TabStop_val:
+        {
+            // TODO Do something of that
+        }
+        break;
+        default:
+        {
+#if OSL_DEBUG_LEVEL > 0
+            ::rtl::OString sMessage( "ListTable::attribute() - Id: ");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 10 );
+            sMessage += ::rtl::OString(" / 0x");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 16 );
+            sMessage += ::rtl::OString(" value: ");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 10 );
+            sMessage += ::rtl::OString(" / 0x");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 16 );
+            OSL_ENSURE( false, sMessage.getStr()); //
+#endif
+        }
+    }
+}
+
+void ListsManager::sprm( Sprm& rSprm )
+{
+    //fill the attributes of the style sheet
+    sal_uInt32 nSprmId = rSprm.getId();
+    if( m_pCurrentDefinition.get() ||
+        nSprmId == NS_ooxml::LN_CT_Numbering_abstractNum || 
+        nSprmId == NS_ooxml::LN_CT_Numbering_num )
+    {
+        sal_Int32 nIntValue = rSprm.getValue()->getInt();
+        /* WRITERFILTERSTATUS: table: ListTable_sprm */
+        switch( nSprmId )
+        {
+            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_Numbering_abstractNum:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                {
+                    //create a new Abstract list entry
+                    OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+                    m_pCurrentDefinition.reset( new AbstractListDef );
+                    pProperties->resolve( *this );
+                    //append it to the table
+                    m_aAbstractLists.push_back( m_pCurrentDefinition );
+                    m_pCurrentDefinition = AbstractListDef::Pointer();
+                }
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_Numbering_num:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                {
+                    // Create a new list entry
+                    OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+                    ListDef::Pointer listDef( new ListDef );
+                    m_pCurrentDefinition = listDef;
+                    pProperties->resolve( *this );
+                    //append it to the table
+                    m_aLists.push_back( listDef );
+
+                    m_pCurrentDefinition = AbstractListDef::Pointer();
+                }
+            }
+            break;
+            case NS_ooxml::LN_CT_Num_abstractNumId:
+            {
+                sal_Int32 nAbstractNumId = rSprm.getValue()->getInt();
+                ListDef* pListDef = dynamic_cast< ListDef* >( m_pCurrentDefinition.get( ) );
+                if ( pListDef != NULL )
+                {
+                    // The current def should be a ListDef
+                    pListDef->SetAbstractDefinition(
+                           GetAbstractList( nAbstractNumId ) ); 
+                }
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_AbstractNum_multiLevelType:
+            break;
+            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
+            case NS_rtf::LN_TPLC:
+                m_pCurrentDefinition->SetValue( nSprmId, nIntValue );
+            break;
+            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_AbstractNum_lvl:
+            {
+                m_pCurrentDefinition->AddLevel();
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+                }
+            break;
+            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
+            case NS_rtf::LN_RGBXCHNUMS: break;
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_ISTARTAT:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_NFC:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_JC:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FLEGAL:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FNORESTART:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FIDENTSAV:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FCONVERTED:
+#if 0
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FWORD6:
+#endif
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_IXCHFOLLOW:
+                m_pCurrentDefinition->GetCurrentLevel( )->SetValue( nSprmId, nIntValue );
+            break;
+            case NS_ooxml::LN_CT_Lvl_lvlText:
+            case NS_ooxml::LN_CT_Lvl_rPr : //contains LN_EG_RPrBase_rFonts
+            {    
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_NumLvl_lvl:
+            {   
+                // overwrite level
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_Lvl_lvlJc:
+            {
+                static sal_Int16 aWWAlignments[ ] = 
+                {
+                    text::HoriOrientation::LEFT,
+                    text::HoriOrientation::CENTER,
+                    text::HoriOrientation::RIGHT
+                };
+                m_pCurrentDefinition->GetCurrentLevel( )->Insert( 
+                    PROP_ADJUST, true, uno::makeAny( aWWAlignments[ nIntValue ] ) );
+                    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            }
+            break;
+            case NS_ooxml::LN_CT_Lvl_pPr:
+            case NS_ooxml::LN_CT_PPrBase_ind:
+            {    
+                //todo: how to handle paragraph properties within numbering levels (except LeftIndent and FirstLineIndent)?
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_PPrBase_tabs:
+            case NS_ooxml::LN_CT_Tabs_tab:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_Lvl_suff:
+                //todo: currently unsupported suffix 
+                //can be: "none", "space", "tab"
+            break;
+            case NS_ooxml::LN_CT_Lvl_pStyle:
+            {
+                OUString sStyleName = rSprm.getValue( )->getString( );
+                ListLevel::Pointer pLevel = m_pCurrentDefinition->GetCurrentLevel( );
+                StyleSheetTablePtr pStylesTable = m_rDMapper.GetStyleSheetTable( );
+                const StyleSheetEntryPtr pStyle = pStylesTable->FindStyleSheetByISTD( sStyleName );
+                pLevel->SetParaStyle( pStyle );
+            }
+            break;
+            case NS_ooxml::LN_EG_RPrBase_rFonts: //contains font properties
+            case NS_ooxml::LN_EG_RPrBase_color:
+            case NS_ooxml::LN_EG_RPrBase_u:
+            case NS_sprm::LN_CHps:    // sprmCHps
+            case NS_ooxml::LN_EG_RPrBase_lang:
+            case NS_ooxml::LN_EG_RPrBase_eastAsianLayout:
+                //no break!
+            default:
+                if( m_pCurrentDefinition->GetCurrentLevel( ).get())
+                {
+                    m_rDMapper.PushListProperties( m_pCurrentDefinition->GetCurrentLevel( ) );
+                    m_rDMapper.sprm( rSprm );
+                    m_rDMapper.PopListProperties();
+                }
+        }    
+    }
+}
+
+void ListsManager::entry( int /* pos */, 
+        writerfilter::Reference<Properties>::Pointer_t ref )
+{
+    if( m_rDMapper.IsOOXMLImport() )
+    {
+        ref->resolve(*this);
+    }
+    else
+    {
+        if ( m_bIsLFOImport ) 
+        {
+            // Create ListDef's
+            OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+            ListDef::Pointer pList( new ListDef() );
+            m_pCurrentDefinition = pList;
+            ref->resolve(*this);
+            //append it to the table
+            m_aLists.push_back( pList );
+            m_pCurrentDefinition = AbstractListDef::Pointer();
+        }
+        else
+        {
+            // Create AbstractListDef's
+            OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+            m_pCurrentDefinition.reset( new AbstractListDef( ) );
+            ref->resolve(*this);
+            //append it to the table
+            m_aAbstractLists.push_back( m_pCurrentDefinition );
+            m_pCurrentDefinition = AbstractListDef::Pointer();
+        }
+    }
+}
+
+AbstractListDef::Pointer ListsManager::GetAbstractList( sal_Int32 nId )
+{
+    AbstractListDef::Pointer pAbstractList;
+
+    int nLen = m_aAbstractLists.size( );
+    int i = 0;
+    while ( !pAbstractList.get( ) && i < nLen )
+    {
+        if ( m_aAbstractLists[i]->GetId( ) == nId )
+            pAbstractList = m_aAbstractLists[i];
+        i++;
+    }
+
+    return pAbstractList;
+}
+
+ListDef::Pointer ListsManager::GetList( sal_Int32 nId )
+{
+    ListDef::Pointer pList;
+
+    int nLen = m_aLists.size( );
+    int i = 0;
+    while ( !pList.get( ) && i < nLen )
+    {
+        if ( m_aLists[i]->GetId( ) == nId )
+            pList = m_aLists[i];
+        i++;
+    }
+
+    return pList;
+}
+
+void ListsManager::CreateNumberingRules( )
+{
+    // Loop over the definitions
+    std::vector< ListDef::Pointer >::iterator listIt = m_aLists.begin( );
+    for ( ; listIt != m_aLists.end( ); listIt++ )
+    {
+        (*listIt)->CreateNumberingRules( m_rDMapper, m_xFactory );
+    }
+}
+
+} }
diff --git writerfilter/source/dmapper/NumberingManager.hxx writerfilter/source/dmapper/NumberingManager.hxx
new file mode 100644
index 0000000..d5c6e6d
--- /dev/null
+++ writerfilter/source/dmapper/NumberingManager.hxx
@@ -0,0 +1,226 @@
+#ifndef INCLUDED_NUMBERINGMANAGER_HXX
+#define INCLUDED_NUMBERINGMANAGER_HXX
+
+#include "PropertyMap.hxx"
+
+#include <WriterFilterDllApi.hxx>
+#include <dmapper/DomainMapper.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+
+#include <com/sun/star/container/XIndexReplace.hpp>
+
+namespace writerfilter {
+namespace dmapper {
+
+class DomainMapper;
+struct StyleSheetEntry;
+
+
+/** Class representing the numbering level properties.
+ */
+class ListLevel : public PropertyMap
+{
+    sal_Int32                                     m_nIStartAt;       //LN_ISTARTAT
+    sal_Int32                                     m_nNFC;            //LN_NFC
+    sal_Int32                                     m_nJC;             //LN_JC
+    sal_Int32                                     m_nFLegal;         //LN_FLEGAL
+    sal_Int32                                     m_nFNoRestart;     //LN_FNORESTART
+    sal_Int32                                     m_nFPrev;          //LN_FPREV
+    sal_Int32                                     m_nFPrevSpace;     //LN_FPREVSPACE
+    sal_Int32                                     m_nFWord6;         //LN_FWORD6
+    ::rtl::OUString                               m_sRGBXchNums;     //LN_RGBXCHNUMS
+    sal_Int32                                     m_nXChFollow;      //LN_IXCHFOLLOW
+    ::rtl::OUString                               m_sBulletChar;
+    sal_Int32                                     m_nTabstop;
+    boost::shared_ptr< StyleSheetEntry >          m_pParaStyle;
+
+public:
+
+    typedef boost::shared_ptr< ListLevel > Pointer;
+
+    ListLevel() :
+        m_nIStartAt(-1)
+        ,m_nNFC(-1)
+        ,m_nJC(-1)
+        ,m_nFLegal(-1)
+        ,m_nFNoRestart(-1)
+        ,m_nFPrev(-1)
+        ,m_nFPrevSpace(-1)
+        ,m_nFWord6(-1)
+        ,m_nXChFollow(-1)
+        ,m_nTabstop( 0 )
+        {}
+
+    ~ListLevel( ){ }
+
+    // Setters for the import
+    void SetValue( Id nId, sal_Int32 nValue );
+    void SetBulletChar( rtl::OUString sValue ) { m_sBulletChar = sValue; };
+    void SetParaStyle( boost::shared_ptr< StyleSheetEntry > pStyle ) 
+    { 
+        m_pParaStyle = pStyle; 
+    };
+    void AddRGBXchNums( rtl::OUString sValue ) { m_sRGBXchNums += sValue; };
+
+    // Getters
+    rtl::OUString GetBulletChar( ) { return m_sBulletChar; };
+    boost::shared_ptr< StyleSheetEntry > GetParaStyle( ) { return m_pParaStyle; };
+
+    // UNO mapping functions
+
+    // rPrefix and rSuffix are out parameters
+    static sal_Int16 GetParentNumbering( rtl::OUString sText, sal_Int16 nLevel,
+        rtl::OUString& rPrefix, rtl::OUString& rSuffix );
+    
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >  
+        GetProperties(  );
+    
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue> 
+        GetCharStyleProperties( );
+private:
+
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >  
+        GetLevelProperties(  );
+    
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >  
+        GetParaProperties(  );
+};
+
+class AbstractListDef
+{
+private:
+    sal_Int32                            m_nTPLC;          //LN_TPLC
+    ::rtl::OUString                      m_sRGISTD;        //LN_RGISTD
+    sal_Int32                            m_nSimpleList;    //LN_FSIMPLELIST
+    sal_Int32                            m_nRestart;       //LN_FRESTARTHDN
+    sal_Int32                            m_nUnsigned;      //LN_UNSIGNED26_2
+
+    // The ID member reflects either the abstractNumId or the numId
+    // depending on the use of the class
+    sal_Int32                            m_nId;
+
+    // Properties of each level. This can also reflect the overridden 
+    // levels of a numbering.
+    ::std::vector< ListLevel::Pointer >  m_aLevels;
+
+    // Only used during the numberings import
+    ListLevel::Pointer                         m_pCurrentLevel;
+
+public:
+    typedef boost::shared_ptr< AbstractListDef > Pointer;
+
+    AbstractListDef( );
+    ~AbstractListDef( );
+
+    // Setters using during the import
+    void SetId( sal_Int32 nId ) { m_nId = nId; };
+    void SetValue( sal_uInt32 nSprmId, sal_Int32 nValue );  
+    void AddRGISTD( rtl::OUString sValue ) { m_sRGISTD += sValue; };
+
+    // Accessors
+    sal_Int32             GetId( ) { return m_nId; };
+
+    sal_Int16             Size( ) { return sal_Int16( m_aLevels.size( ) ); };
+    ListLevel::Pointer    GetLevel( sal_uInt16 nLvl );
+    void                  AddLevel( );
+
+    ListLevel::Pointer    GetCurrentLevel( ) { return m_pCurrentLevel; };
+
+    virtual com::sun::star::uno::Sequence< 
+        com::sun::star::uno::Sequence< 
+            com::sun::star::beans::PropertyValue > > GetPropertyValues( );
+};
+
+class ListDef : public AbstractListDef
+{
+private:
+    // Pointer to the abstract numbering
+    AbstractListDef::Pointer             m_pAbstractDef;
+    
+    // Cache for the UNO numbering rules
+    uno::Reference< container::XIndexReplace > m_xNumRules;
+
+public:
+    typedef boost::shared_ptr< ListDef > Pointer;
+
+    ListDef( );
+    ~ListDef( );
+    
+    // Accessors
+    void SetAbstractDefinition( AbstractListDef::Pointer pAbstract ) { m_pAbstractDef = pAbstract; };
+    AbstractListDef::Pointer GetAbstractDefinition( ) { return m_pAbstractDef; };
+    
+    // Mapping functions
+    static rtl::OUString GetStyleName( sal_Int32 nId );
+    
+    com::sun::star::uno::Sequence< 
+        com::sun::star::uno::Sequence< 
+            com::sun::star::beans::PropertyValue > > GetPropertyValues( );
+    
+    void CreateNumberingRules(
+            DomainMapper& rDMapper,
+            com::sun::star::uno::Reference< 
+                com::sun::star::lang::XMultiServiceFactory> xFactory );
+    
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexReplace >
+            GetNumberingRules( ) { return m_xNumRules; };
+
+};
+
+/** This class provides access to the defined numbering styles.
+  */
+class ListsManager : 
+    public Properties,
+    public Table
+{
+private:
+
+    DomainMapper&                                       m_rDMapper;
+    com::sun::star::uno::Reference< 
+        com::sun::star::lang::XMultiServiceFactory >    m_xFactory;
+
+    // The numbering entries
+    std::vector< AbstractListDef::Pointer >             m_aAbstractLists;
+    std::vector< ListDef::Pointer >                     m_aLists;
+
+
+    // These members are used for import only
+    AbstractListDef::Pointer                            m_pCurrentDefinition;
+    bool                                                m_bIsLFOImport;
+
+    AbstractListDef::Pointer    GetAbstractList( sal_Int32 nId );
+
+public:
+
+    ListsManager(
+            DomainMapper& rDMapper,
+            const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > xFactory);
+    virtual ~ListsManager();
+    
+    typedef boost::shared_ptr< ListsManager >  Pointer;
+
+    // Properties
+    virtual void attribute( Id nName, Value & rVal );
+    virtual void sprm(Sprm & sprm);
+
+    // Table
+    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
+
+    // Config methods
+    void SetLFOImport( bool bLFOImport ) { m_bIsLFOImport = bLFOImport; };
+
+    // Numberings accessors
+    AbstractListDef::Pointer GetCurrentDef( ) { return m_pCurrentDefinition; };
+    
+    sal_uInt32              Size() const 
+        { return sal_uInt32( m_aLists.size( ) ); };
+    ListDef::Pointer        GetList( sal_Int32 nId );
+
+    // Mapping methods
+    void CreateNumberingRules( );
+};
+
+} }
+
+#endif
+
diff --git writerfilter/source/dmapper/PropertyIds.cxx writerfilter/source/dmapper/PropertyIds.cxx
index cd83d21..9f884b3 100644
--- writerfilter/source/dmapper/PropertyIds.cxx
+++ writerfilter/source/dmapper/PropertyIds.cxx
@@ -317,9 +317,10 @@ const rtl::OUString& PropertyNameSupplier::GetName( PropertyIds eId ) const
             case PROP_INDENT_AT :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("IndentAt")); break;
             case PROP_FIRST_LINE_INDENT :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent")); break;
             case PROP_NUMBERING_STYLE_NAME  :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("NumberingStyleName")); break;
+            case PROP_OUTLINE_LEVEL  :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("OutlineLevel")); break;
             case PROP_LISTTAB_STOP_POSITION :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition")); break;
             case PROP_POSITION_AND_SPACE_MODE :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PositionAndSpaceMode")); break;
-//            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
+            case PROP_HEADING_STYLE_NAME:    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("HeadingStyleName")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
diff --git writerfilter/source/dmapper/PropertyIds.hxx writerfilter/source/dmapper/PropertyIds.hxx
index fd78381..68fbd24 100644
--- writerfilter/source/dmapper/PropertyIds.hxx
+++ writerfilter/source/dmapper/PropertyIds.hxx
@@ -280,8 +280,10 @@ enum PropertyIds
 /*244*/ ,PROP_INDENT_AT
 /*245*/ ,PROP_FIRST_LINE_INDENT
 /*246*/ ,PROP_NUMBERING_STYLE_NAME
-/*247*/ ,PROP_LISTTAB_STOP_POSITION
-/*248*/ ,PROP_POSITION_AND_SPACE_MODE
+/*247*/ ,PROP_OUTLINE_LEVEL
+/*248*/ ,PROP_LISTTAB_STOP_POSITION
+/*249*/ ,PROP_POSITION_AND_SPACE_MODE
+/*250*/ ,PROP_HEADING_STYLE_NAME
 };
 struct PropertyNameSupplier_Impl;
 class PropertyNameSupplier
diff --git writerfilter/source/dmapper/PropertyMap.cxx writerfilter/source/dmapper/PropertyMap.cxx
index 16b8260..50cd8b3 100644
--- writerfilter/source/dmapper/PropertyMap.cxx
+++ writerfilter/source/dmapper/PropertyMap.cxx
@@ -32,12 +32,15 @@
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/container/XEnumeration.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/style/BreakType.hpp>
 #include <com/sun/star/text/RelOrientation.hpp>
 #include <com/sun/star/text/WritingMode.hpp>
 #include <com/sun/star/text/XTextColumns.hpp>
 #include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextCopy.hpp>
 #include "dmapperLoggers.hxx"
 #include "PropertyMapHelper.hxx"
 
@@ -425,14 +428,18 @@ void SectionPropertyMap::ApplyBorderToPageStyles(
     switch( nValue & 0x07)
     {
         case 0: /*all styles*/
-            xFirst = GetPageStyle( xPageStyles, xTextFactory, false );
-            xSecond = GetPageStyle( xPageStyles, xTextFactory, true );
+            if ( m_sFollowPageStyleName.getLength( ) > 0 )
+                xFirst = GetPageStyle( xPageStyles, xTextFactory, false );
+            if ( m_sFirstPageStyleName.getLength( ) > 0 )
+                xSecond = GetPageStyle( xPageStyles, xTextFactory, true );
         break;
         case 1: /*first page*/
-            xFirst = GetPageStyle( xPageStyles, xTextFactory, true );
+            if ( m_sFirstPageStyleName.getLength( ) > 0 )
+                xFirst = GetPageStyle( xPageStyles, xTextFactory, true );
         break;
         case 2: /*left and right*/
-            xFirst  = GetPageStyle( xPageStyles, xTextFactory, false );
+            if ( m_sFollowPageStyleName.getLength( ) > 0 )
+                xFirst  = GetPageStyle( xPageStyles, xTextFactory, false );
         break;
         case 3: //whole document?
             //todo: how to apply a border to the whole document - find all sections or access all page styles?
@@ -609,6 +616,92 @@ bool SectionPropertyMap::HasFooter(bool bFirstPage) const
   -----------------------------------------------------------------------*/
 #define MIN_HEAD_FOOT_HEIGHT 100 //minimum header/footer height
 
+void SectionPropertyMap::CopyLastHeaderFooter( bool bFirstPage, DomainMapper_Impl& rDM_Impl )
+{
+#if DEBUG
+    clog << "START>>> SectionPropertyMap::CopyLastHeaderFooter()" << endl;
+#endif
+    SectionPropertyMap* pLastContext = rDM_Impl.GetLastSectionContext( );
+    if ( pLastContext )
+    {
+        uno::Reference< beans::XPropertySet > xPrevStyle = pLastContext->GetPageStyle(
+                rDM_Impl.GetPageStyles(),
+                rDM_Impl.GetTextFactory(),
+                bFirstPage );
+        uno::Reference< beans::XPropertySet > xStyle = GetPageStyle(
+                rDM_Impl.GetPageStyles(),
+                rDM_Impl.GetTextFactory(),
+                bFirstPage );
+
+        PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+        try {
+            // Loop over the Header and Footer properties to copy them
+            static PropertyIds aProperties[] =
+            {
+                PROP_HEADER_TEXT,
+                PROP_FOOTER_TEXT,
+            };
+
+            bool bHasPrevHeader = false;
+            bool bHasHeader = false;
+
+            rtl::OUString sHeaderIsOn = rPropNameSupplier.GetName( PROP_HEADER_IS_ON );
+            xPrevStyle->getPropertyValue( sHeaderIsOn ) >>= bHasPrevHeader;
+            xStyle->getPropertyValue( sHeaderIsOn ) >>= bHasHeader;
+            bool bCopyHeader = bHasPrevHeader && !bHasHeader;
+
+            if ( bCopyHeader )
+                xStyle->setPropertyValue( sHeaderIsOn, uno::makeAny( sal_True ) );
+
+            bool bHasPrevFooter = false;
+            bool bHasFooter = false;
+
+            rtl::OUString sFooterIsOn = rPropNameSupplier.GetName( PROP_FOOTER_IS_ON );
+            xPrevStyle->getPropertyValue( sFooterIsOn ) >>= bHasPrevFooter;
+            xStyle->getPropertyValue( sFooterIsOn ) >>= bHasFooter;
+            bool bCopyFooter = bHasPrevFooter && !bHasFooter;
+
+            if ( bCopyFooter )
+                xStyle->setPropertyValue( sFooterIsOn, uno::makeAny( sal_True ) );
+
+            // Copying the text properties
+            for ( int i = 0, nNbProps = 2; i < nNbProps; i++ )
+            {
+                bool bIsHeader = ( i < nNbProps / 2 );
+                PropertyIds aPropId = aProperties[i];
+                rtl::OUString sName = rPropNameSupplier.GetName( aPropId );
+
+                if ( ( bIsHeader && bCopyHeader ) || ( !bIsHeader && bCopyFooter ) )
+                {
+#if DEBUG
+                    clog << "Copying ";
+                    clog << rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
+                    // TODO has to be copied
+                    uno::Reference< text::XTextCopy > xTxt(
+                            xStyle->getPropertyValue( sName ), uno::UNO_QUERY_THROW );
+
+                    uno::Reference< text::XTextCopy > xPrevTxt(
+                            xPrevStyle->getPropertyValue( sName ), uno::UNO_QUERY_THROW );
+
+                    xTxt->copyText( xPrevTxt );
+                }
+            }
+        }
+        catch ( const uno::Exception& e )
+        {
+#if DEBUG
+            clog << "An exception occured in SectionPropertyMap::CopyLastHeaderFooter( ) - ";
+            clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
+        }
+    }
+#if DEBUG
+    clog << "END>>> SectionPropertyMap::CopyLastHeaderFooter()" << endl;
+#endif
+}
+
 void SectionPropertyMap::PrepareHeaderFooterProperties( bool bFirstPage )
 {
     sal_Int32 nTopMargin = m_nTopMargin;
@@ -749,6 +842,7 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
         /*** if headers/footers are available then the top/bottom margins of the
             header/footer are copied to the top/bottom margin of the page
           */
+        CopyLastHeaderFooter( false, rDM_Impl );
         PrepareHeaderFooterProperties( false );
 
         const ::rtl::OUString sTrayIndex = rPropNameSupplier.GetName( PROP_PRINTER_PAPER_TRAY_INDEX );
@@ -821,6 +915,7 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
         //todo: creating a "First Page" style depends on HasTitlePage und _fFacingPage_
         if( m_bTitlePage )
         {
+            CopyLastHeaderFooter( true, rDM_Impl );
             PrepareHeaderFooterProperties( true );
             uno::Reference< beans::XPropertySet > xFirstPageStyle = GetPageStyle(
                                 rDM_Impl.GetPageStyles(), rDM_Impl.GetTextFactory(), true );
@@ -843,28 +938,24 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
                 //now apply this break at the first paragraph of this section
                 uno::Reference< beans::XPropertySet > xRangeProperties;
                 if( m_bIsFirstSection )
-                    xRangeProperties = uno::Reference< beans::XPropertySet >( rDM_Impl.GetBodyText()->getStart(), uno::UNO_QUERY_THROW );
+                {
+                    uno::Reference< container::XEnumerationAccess > xEnumAccess( rDM_Impl.GetBodyText( ), uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XEnumeration >  xEnum = xEnumAccess->createEnumeration( );
+                    xRangeProperties = uno::Reference< beans::XPropertySet >( xEnum->nextElement( ), uno::UNO_QUERY_THROW );
+                }
                 else
                     xRangeProperties = uno::Reference< beans::XPropertySet >( m_xStartingRange, uno::UNO_QUERY_THROW );
             /* break type
             0 - No break 1 - New Colunn 2 - New page 3 - Even page 4 - odd page */
-                if( m_nBreakType == 2 || m_nBreakType == 3)
-                {
-                    xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_BREAK_TYPE),
-                        uno::makeAny( m_nBreakType == 2 ? style::BreakType_COLUMN_AFTER : style::BreakType_PAGE_AFTER  ) );
-                }
-                else
-                {
-                    xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_DESC_NAME ),
-                        uno::makeAny( m_bTitlePage ? m_sFirstPageStyleName : m_sFollowPageStyleName ));
+                xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_DESC_NAME ),
+                    uno::makeAny( m_bTitlePage ? m_sFirstPageStyleName : m_sFollowPageStyleName ));
     //  todo: page breaks with odd/even page numbering are not available - find out current page number to check how to change the number
     //  or add even/odd page break types
-                    if(m_bPageNoRestart || m_nPageNumber >= 0)
-                    {
-                        sal_Int16 nPageNumber = m_nPageNumber >= 0 ? static_cast< sal_Int16 >(m_nPageNumber) : 1;
-                        xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_NUMBER_OFFSET ),
-                            uno::makeAny( nPageNumber ));
-                    }
+                if(m_bPageNoRestart || m_nPageNumber >= 0)
+                {
+                    sal_Int16 nPageNumber = m_nPageNumber >= 0 ? static_cast< sal_Int16 >(m_nPageNumber) : 1;
+                    xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_NUMBER_OFFSET ),
+                        uno::makeAny( nPageNumber ));
                 }
             }
         }
diff --git writerfilter/source/dmapper/PropertyMap.hxx writerfilter/source/dmapper/PropertyMap.hxx
index b3a304a..68a1825 100644
--- writerfilter/source/dmapper/PropertyMap.hxx
+++ writerfilter/source/dmapper/PropertyMap.hxx
@@ -205,6 +205,7 @@ class SectionPropertyMap : public PropertyMap
     void _ApplyProperties( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > xStyle );
     ::com::sun::star::uno::Reference< com::sun::star::text::XTextColumns > ApplyColumnProperties(
             ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > xFollowPageStyle );
+    void CopyLastHeaderFooter( bool bFirstPage, DomainMapper_Impl& rDM_Impl );
     void PrepareHeaderFooterProperties( bool bFirstPage );
     bool HasHeader( bool bFirstPage ) const;
     bool HasFooter( bool bFirstPage ) const;
@@ -281,6 +282,7 @@ public:
 
     void CloseSectionGroup( DomainMapper_Impl& rDM_Impl );
 };
+typedef boost::shared_ptr<SectionPropertyMap> SectionPropertyMapPtr;
 
 /*-- 28.12.2007 08:17:34---------------------------------------------------
 
diff --git writerfilter/source/dmapper/SettingsTable.cxx writerfilter/source/dmapper/SettingsTable.cxx
index 757c05f..07abc8b 100755
--- writerfilter/source/dmapper/SettingsTable.cxx
+++ writerfilter/source/dmapper/SettingsTable.cxx
@@ -28,11 +28,12 @@
  *
  ************************************************************************/
 
+#include <com/sun/star/beans/XPropertySet.hpp>
+
 #include <SettingsTable.hxx>
 #include <doctok/resourceids.hxx>
 #include <ooxml/resourceids.hxx>
 #include <stdio.h>
-#include <ListTable.hxx>
 #include <ConversionHelper.hxx>
 #include <rtl/ustring.hxx>
 
@@ -45,8 +46,6 @@ struct SettingsTable_Impl
     DomainMapper&       m_rDMapper;
     const uno::Reference< lang::XMultiServiceFactory > m_xTextFactory;
             
-    ListTablePtr        m_pListTable;
-            
     ::rtl::OUString     m_sCharacterSpacing;
     ::rtl::OUString     m_sDecimalSymbol;
     ::rtl::OUString     m_sListSeparatorForFields; //2.15.1.56 listSeparator (List Separator for Field Code Evaluation)
@@ -67,14 +66,6 @@ struct SettingsTable_Impl
     , m_doNotIncludeSubdocsInStats(false)
     , m_bRecordChanges(false)
     {}
-            
-    ListTablePtr GetListTable()
-    {
-    if(!m_pListTable)
-        m_pListTable.reset(
-                   new ListTable( m_rDMapper, m_xTextFactory ));
-    return m_pListTable;
-    }
 };
         
 SettingsTable::SettingsTable(DomainMapper& rDMapper, const uno::Reference< lang::XMultiServiceFactory > xTextFactory) :
@@ -151,14 +142,6 @@ void SettingsTable::sprm(Sprm& rSprm)
     }
     break;
     /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-    case NS_ooxml::LN_CT_Numbering_num: // 92613;
-    /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-    case NS_ooxml::LN_CT_Numbering_abstractNum: //  92612;
-    {
-        m_pImpl->GetListTable()->sprm( rSprm );
-    }
-    break;
-    /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
     case NS_ooxml::LN_CT_Settings_stylePaneFormatFilter: // 92493;
     break;
     /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
diff --git writerfilter/source/dmapper/StyleSheetTable.cxx writerfilter/source/dmapper/StyleSheetTable.cxx
index 2026310..549dd15 100644
--- writerfilter/source/dmapper/StyleSheetTable.cxx
+++ writerfilter/source/dmapper/StyleSheetTable.cxx
@@ -26,6 +26,7 @@
  ************************************************************************/
 #include <StyleSheetTable.hxx>
 #include <dmapper/DomainMapper.hxx>
+#include <NumberingManager.hxx>
 #include <ConversionHelper.hxx>
 #include <TblStylePrHandler.hxx>
 #include <BorderHandler.hxx>
@@ -897,30 +898,23 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
                     {
                         // Set the outline levels
                         const StyleSheetPropertyMap* pStyleSheetProperties = dynamic_cast<const StyleSheetPropertyMap*>(pEntry ? pEntry->pProperties.get() : 0);
-                        if ( pStyleSheetProperties && pStyleSheetProperties->GetOutlineLevel( ) >= 0 )
+                        if ( pStyleSheetProperties )
                         {
-                            sal_Int16 nLvl = pStyleSheetProperties->GetOutlineLevel( );
-                            uno::Reference< text::XChapterNumberingSupplier > xOutlines ( m_pImpl->m_xTextDocument,
-                                    uno::UNO_QUERY_THROW );
-                            uno::Reference< container::XIndexReplace > xRules = xOutlines->getChapterNumberingRules( );
-                            uno::Any aLevel = xRules->getByIndex( nLvl );
-                            uno::Sequence< beans::PropertyValue > aLevelProps;
-                            aLevel >>= aLevelProps;
-
-                            sal_Int32 nLen = aLevelProps.getLength( );
-                            sal_Int32 i = 0;
-                            bool bPropFound = false;
-                            rtl::OUString sPropName( rtl::OUString::createFromAscii( "HeadingStyleName" ) );
-                            while ( i < nLen && !bPropFound )
+                            aPropValues.realloc( aPropValues.getLength( ) + 1 );
+
+                            beans::PropertyValue aLvlVal( rPropNameSupplier.GetName( PROP_OUTLINE_LEVEL ), 0,
+                                    uno::makeAny( sal_Int16( pStyleSheetProperties->GetOutlineLevel( ) + 1 ) ),
+                                    beans::PropertyState_DIRECT_VALUE );
+                            aPropValues[ aPropValues.getLength( ) - 1 ] = aLvlVal;
+
+                            if ( pStyleSheetProperties->GetOutlineLevel( ) == 0 )
                             {
-                                if ( aLevelProps[i].Name.equals( sPropName ) )
-                                {
-                                    aLevelProps[i].Value = uno::makeAny( ConvertStyleName( pEntry->sStyleName ) );
-                                    bPropFound = true;
-                                }
-                                i++;
+                                aPropValues.realloc( aPropValues.getLength( ) + 1 );
+                                beans::PropertyValue aStyleVal( rPropNameSupplier.GetName( PROP_NUMBERING_STYLE_NAME ), 0,
+                                        uno::makeAny( rtl::OUString::createFromAscii( "" ) ),
+                                        beans::PropertyState_DIRECT_VALUE );
+                                aPropValues[ aPropValues.getLength( ) - 1 ] = aStyleVal;
                             }
-                            xRules->replaceByIndex( nLvl, uno::makeAny( aLevelProps ) );
                         }
 
                         uno::Reference< beans::XPropertyState >xState( xStyle, uno::UNO_QUERY_THROW );
diff --git writerfilter/source/dmapper/StyleSheetTable.hxx writerfilter/source/dmapper/StyleSheetTable.hxx
index 35ca573..1aa016b 100644
--- writerfilter/source/dmapper/StyleSheetTable.hxx
+++ writerfilter/source/dmapper/StyleSheetTable.hxx
@@ -87,7 +87,7 @@ public:
 typedef boost::shared_ptr<StyleSheetEntry> StyleSheetEntryPtr;
 
 class DomainMapper;
-class WRITERFILTER_DLLPRIVATE StyleSheetTable :
+class StyleSheetTable :
         public Properties,
         public Table
 {
diff --git writerfilter/source/dmapper/makefile.mk writerfilter/source/dmapper/makefile.mk
index dd94415..4b96368 100755
--- writerfilter/source/dmapper/makefile.mk
+++ writerfilter/source/dmapper/makefile.mk
@@ -50,8 +50,7 @@ SLOFILES= \
     $(SLO)$/FontTable.obj \
     $(SLO)$/GraphicHelpers.obj \
     $(SLO)$/GraphicImport.obj \
-    $(SLO)$/LFOTable.obj \
-    $(SLO)$/ListTable.obj \
+    $(SLO)$/NumberingManager.obj  \
     $(SLO)$/MeasureHandler.obj \
     $(SLO)$/ModelEventListener.obj \
     $(SLO)$/OLEHandler.obj \
diff --git writerfilter/source/doctok/WW8DocumentImpl.cxx writerfilter/source/doctok/WW8DocumentImpl.cxx
index 49b4503..5dbf986 100644
--- writerfilter/source/doctok/WW8DocumentImpl.cxx
+++ writerfilter/source/doctok/WW8DocumentImpl.cxx
@@ -1726,18 +1726,8 @@ void WW8DocumentImpl::resolve(Stream & rStream)
         if (pSttbRgtplc.get() != NULL)
             rStream.table(NS_rtf::LN_SttbRgtplc, pSttbRgtplc);
         
-        writerfilter::Reference<Table>::Pointer_t pListTable = getListTable();
-        
-        if (pListTable.get() != NULL)
-            rStream.table(NS_rtf::LN_LISTTABLE, pListTable);
-        
-        writerfilter::Reference<Table>::Pointer_t pLFOTable = getLFOTable();
-        
-        if (pLFOTable.get() != NULL)
-            rStream.table(NS_rtf::LN_LFOTABLE, pLFOTable);
-        
         writerfilter::Reference<Table>::Pointer_t pFontTable = getFontTable();
-        
+         
         if (pFontTable.get() != NULL)
             rStream.table(NS_rtf::LN_FONTTABLE, pFontTable);
   
@@ -1752,6 +1742,16 @@ void WW8DocumentImpl::resolve(Stream & rStream)
         {
             clog << e.getText() << endl;
         }
+        
+        writerfilter::Reference<Table>::Pointer_t pListTable = getListTable();
+        
+        if (pListTable.get() != NULL)
+            rStream.table(NS_rtf::LN_LISTTABLE, pListTable);
+        
+        writerfilter::Reference<Table>::Pointer_t pLFOTable = getLFOTable();
+        
+        if (pLFOTable.get() != NULL)
+            rStream.table(NS_rtf::LN_LFOTABLE, pLFOTable);
     }
 
     WW8DocumentIterator::Pointer_t pIt = begin();
diff --git writerfilter/source/ooxml/OOXMLDocumentImpl.cxx writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
index 8b1adfe..a46496d 100644
--- writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
+++ writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
@@ -47,7 +47,7 @@ using namespace ::std;
 
 OOXMLDocumentImpl::OOXMLDocumentImpl
 (OOXMLStream::Pointer_t pStream)
-: mpStream(pStream), mXNoteType(0)
+: mpStream(pStream), mXNoteType(0), mbIsSubstream( false )
 {
 }
 
@@ -137,6 +137,7 @@ OOXMLDocumentImpl::getSubStream(const rtl::OUString & rId)
     writerfilter::Reference<Stream>::Pointer_t pRet( pTemp = new OOXMLDocumentImpl(pStream) );
     pTemp->setModel(mxModel);
     pTemp->setDrawPage(mxDrawPage);
+    pTemp->setIsSubstream( true );
     return pRet;
 }
 
@@ -320,6 +321,7 @@ void OOXMLDocumentImpl::resolve(Stream & rStream)
         pDocHandler->setStream(&rStream);
         pDocHandler->setDocument(this);
         pDocHandler->setXNoteId(msXNoteId);
+        pDocHandler->setIsSubstream( mbIsSubstream );
         uno::Reference < xml::sax::XFastDocumentHandler > xDocumentHandler
             (pDocHandler);
         uno::Reference < xml::sax::XFastTokenHandler > xTokenHandler
@@ -327,9 +329,9 @@ void OOXMLDocumentImpl::resolve(Stream & rStream)
 
         resolveFastSubStream(rStream, OOXMLStream::SETTINGS);
         resolveFastSubStream(rStream, OOXMLStream::THEME);
-        resolveFastSubStream(rStream, OOXMLStream::NUMBERING);
         resolveFastSubStream(rStream, OOXMLStream::FONTTABLE);
         resolveFastSubStream(rStream, OOXMLStream::STYLES);
+        resolveFastSubStream(rStream, OOXMLStream::NUMBERING);
 
         xParser->setFastDocumentHandler( xDocumentHandler );
         xParser->setTokenHandler( xTokenHandler );
diff --git writerfilter/source/ooxml/OOXMLDocumentImpl.hxx writerfilter/source/ooxml/OOXMLDocumentImpl.hxx
index e661dcf..7374638 100644
--- writerfilter/source/ooxml/OOXMLDocumentImpl.hxx
+++ writerfilter/source/ooxml/OOXMLDocumentImpl.hxx
@@ -51,6 +51,8 @@ class OOXMLDocumentImpl : public OOXMLDocument
     uno::Reference<frame::XModel> mxModel;
     uno::Reference<drawing::XDrawPage> mxDrawPage;
 
+    bool mbIsSubstream;
+
 protected:
     virtual void resolveFastSubStream(Stream & rStream,
                                       OOXMLStream::StreamType_t nType);
@@ -67,6 +69,8 @@ protected:
                    const Id & rType,
                    const rtl::OUString & rNoteId);
 
+    void setIsSubstream( bool bSubstream ) { mbIsSubstream = bSubstream; };
+
 public:
     OOXMLDocumentImpl(OOXMLStream::Pointer_t pStream);
     virtual ~OOXMLDocumentImpl();
diff --git writerfilter/source/ooxml/OOXMLFastContextHandler.cxx writerfilter/source/ooxml/OOXMLFastContextHandler.cxx
index 946c29e..b430e6c 100644
--- writerfilter/source/ooxml/OOXMLFastContextHandler.cxx
+++ writerfilter/source/ooxml/OOXMLFastContextHandler.cxx
@@ -255,10 +255,6 @@ void SAL_CALL OOXMLFastContextHandler::startFastElement
     snprintf(buffer, sizeof(buffer), "%ld: startFastElement", mnInstanceNumber);
     logger("MEMORY", buffer);
 #endif
-
-#if DEBUG
-    clog << "Token: " << fastTokenToId(Element) << endl;
-#endif
     attributes(Attribs);
     lcl_startFastElement(Element, Attribs);
 }
@@ -770,6 +766,7 @@ void OOXMLFastContextHandler::setLastParagraphInSection()
 #endif
 
     mpParserState->setLastParagraphInSection(true);
+    mpStream->markLastParagraphInSection( );
 }
 
 void OOXMLFastContextHandler::newProperty
diff --git writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx
index 07d60f5..0cf7373 100644
--- writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx
+++ writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx
@@ -232,4 +232,9 @@ void OOXMLFastDocumentHandler::setXNoteId(const ::rtl::OUString & rXNoteId)
     msXNoteId = rXNoteId;
 }
 
+void OOXMLFastDocumentHandler::setIsSubstream( bool bSubstream )
+{
+    getContextHandler( )->getParserState( )->setInSectionGroup( bSubstream );
+}
+
 }}
diff --git writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx
index c1f2aa0..cd50a70 100644
--- writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx
+++ writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx
@@ -97,6 +97,8 @@ public:
     
     OOXMLParserState::Pointer_t getParserState() const;
 
+    void setIsSubstream( bool bSubstream );
+
 private:
     OOXMLFastDocumentHandler(OOXMLFastDocumentHandler &); // not defined
     void operator =(OOXMLFastDocumentHandler &); // not defined
diff --git writerfilter/source/ooxml/model.xml writerfilter/source/ooxml/model.xml
index f571a50..15bb57e 100644
--- writerfilter/source/ooxml/model.xml
+++ writerfilter/source/ooxml/model.xml
@@ -22223,18 +22223,13 @@
     <resource xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" name="CT_HdrFtrRef" resource="Properties">
       <attribute name="type" tokenid="ooxml:CT_HdrFtrRef_type"/>
       <attribute name="r:id" tokenid="ooxml:CT_HdrFtrRef_id"/>
-      <action name="end" action="endCharacterGroup"/>
-      <action name="end" action="endParagraphGroup"/>
       <action name="end" action="handleHdrFtr"/>
     </resource>
     <resource name="EG_HdrFtrReferences" resource="Properties">
       <element name="headerReference" tokenid="ooxml:EG_HdrFtrReferences_headerReference"/>
       <element name="footerReference" tokenid="ooxml:EG_HdrFtrReferences_footerReference"/>
     </resource>
-    <resource name="CT_HdrFtr" resource="Stream">
-      <action name="start" action="startSectionGroup"/>
-      <action name="end" action="endSectionGroup"/>
-    </resource>
+    <resource name="CT_HdrFtr" resource="Stream"/>
     <resource name="EG_SectPrContents" resource="Properties">
       <element name="bidi" tokenid="ooxml:EG_SectPrContents_bidi"/>
       <element name="cols" tokenid="ooxml:EG_SectPrContents_cols"/>
