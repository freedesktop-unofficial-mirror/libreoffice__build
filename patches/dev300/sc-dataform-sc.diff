diff --git sc/inc/document.hxx sc/inc/document.hxx
index bae5aea..5b3fb82 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -880,8 +880,10 @@ public:
 							   SCCOL nEndCol,   SCTAB nEndTab,
 							   SCROW nStartRow, SCSIZE nSize,
 							   ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL );
-	void			DeleteRow( const ScRange& rRange,
+	//for dataform
+	SC_DLLPUBLIC    void			DeleteRow( const ScRange& rRange,
 							   ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL );
+							   
 	BOOL			InsertCol( SCROW nStartRow, SCTAB nStartTab,
 							   SCROW nEndRow,   SCTAB nEndTab,
 							   SCCOL nStartCol, SCSIZE nSize, ScDocument* pRefUndoDoc = NULL );
diff --git sc/inc/sc.hrc sc/inc/sc.hrc
index 3bcc4f3..7c62d8d 100644
--- sc/inc/sc.hrc
+++ sc/inc/sc.hrc
@@ -1647,6 +1647,11 @@
 
 #define SC_OOO_BUILD_START          (SC_DIALOGS_END)
 
+// Data Form
+#define SID_DATAFORM_NEW            (SC_OOO_BUILD_START + 1) // message
+#define SID_DATA_FORM               (SC_OOO_BUILD_START + 2) // menu (in Data menu)
+#define RID_SCDLG_DATAFORM          (SC_OOO_BUILD_START + 3) // dialog
+
 
 
 
diff --git sc/inc/scabstdlg.hxx sc/inc/scabstdlg.hxx
index 3403c2d..dfdf0ba 100644
--- sc/inc/scabstdlg.hxx
+++ sc/inc/scabstdlg.hxx
@@ -42,6 +42,8 @@
 #include "global.hxx"
 #include "pivot.hxx"
 
+#include <tabvwsh.hxx>
+
 class ScAsciiOptions;
 class ScAutoFormat;
 class ScAutoFormatData;
@@ -111,6 +113,12 @@ public:
 	virtual DelCellCmd GetDelCellCmd() const = 0;
 };
 
+//for dataform
+class AbstractScDataFormDlg : public VclAbstractDialog  //add for ScDeleteCellDlg
+{
+
+};
+
 class AbstractScDeleteContentsDlg: public VclAbstractDialog  //add for ScDeleteContentsDlg
 {
 public:
@@ -324,6 +332,9 @@ public:
 
 	virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId, BOOL bDisallowCellMove = FALSE ) = 0 ; //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell ) = 0 ; //add for ScDataFormDlg
+
 	virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
 																 USHORT  nCheckDefaults = 0 ) = 0;
 	virtual AbstractScFillSeriesDlg * CreateScFillSeriesDlg( Window*		pParent, //add for ScFillSeriesDlg
diff --git sc/sdi/cellsh.sdi sc/sdi/cellsh.sdi
index 5e99223..baec475 100644
--- sc/sdi/cellsh.sdi
+++ sc/sdi/cellsh.sdi
@@ -60,6 +60,7 @@ interface CellSelection
 	SID_SBA_BRW_INSERT		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_SELECT_DB			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_SORT				[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
+	SID_DATA_FORM			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	FID_FILTER_OK			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_AUTO_FILTER			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_AUTOFILTER_HIDE		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
diff --git sc/sdi/scalc.sdi sc/sdi/scalc.sdi
index 2ff50a0..ecc0921 100644
--- sc/sdi/scalc.sdi
+++ sc/sdi/scalc.sdi
@@ -1601,6 +1601,31 @@ SfxVoidItem DataSort SID_SORT
 ]
 
 //--------------------------------------------------------------------------
+SfxVoidItem DataForm SID_DATA_FORM
+()
+[
+	/* flags: */
+	AutoUpdate = FALSE,
+	Cachable = Cachable,
+	FastCall = FALSE,
+	HasCoreId = FALSE,
+	HasDialog = TRUE,
+	ReadOnlyDoc = TRUE,
+	Toggle = FALSE,
+	Container = FALSE,
+	RecordAbsolute = FALSE,
+	RecordPerSet;
+	Synchron;
+
+	/* config: */
+	AccelConfig = TRUE,
+	MenuConfig = TRUE,
+	StatusBarConfig = FALSE,
+	ToolBoxConfig = FALSE,
+	GroupId = GID_DATA;
+]
+
+//--------------------------------------------------------------------------
 SfxVoidItem DataSubTotals SID_SUBTOTALS
 ()
 [
diff --git sc/source/ui/attrdlg/scdlgfact.cxx sc/source/ui/attrdlg/scdlgfact.cxx
index aeb4786..de9b284 100644
--- sc/source/ui/attrdlg/scdlgfact.cxx
+++ sc/source/ui/attrdlg/scdlgfact.cxx
@@ -76,6 +76,8 @@
 #include "tpstat.hxx" //add for ScDocStatPage
 #include "tpusrlst.hxx" //add for ScTpUserLists
 #include "tpview.hxx" //add for ScTpContentOptions
+//for dataform
+#include "datafdlg.hxx" //add for ScDataFormDlg
 
 // ause
 #include "editutil.hxx"
@@ -88,6 +90,8 @@ IMPL_ABSTDLG_BASE(AbstractScDataPilotDatabaseDlg_Impl); //add for ScDataPilotDat
 IMPL_ABSTDLG_BASE(AbstractScDataPilotSourceTypeDlg_Impl); //add for ScDataPilotSourceTypeDlg
 IMPL_ABSTDLG_BASE(AbstractScDataPilotServiceDlg_Impl); //add for ScDataPilotServiceDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteCellDlg_Impl); //add for ScDeleteCellDlg
+//for dataform
+IMPL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl); //add for ScDataFormDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteContentsDlg_Impl); //add for ScDeleteContentsDlg
 IMPL_ABSTDLG_BASE(AbstractScFillSeriesDlg_Impl); //add for ScFillSeriesDlg
 IMPL_ABSTDLG_BASE(AbstractScGroupDlg_Impl); //add for ScGroupDlg
@@ -761,6 +765,26 @@ AbstractScDeleteCellDlg* ScAbstractDialogFactory_Impl::CreateScDeleteCellDlg( Wi
 
 //add for ScDeleteCellDlg  end
 
+//add for ScDataFormDlg begin
+AbstractScDataFormDlg* ScAbstractDialogFactory_Impl::CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*	pTabViewShell )
+{
+	ScDataFormDlg * pDlg=NULL;
+	switch ( nId )
+	{
+		case RID_SCDLG_DATAFORM :
+			pDlg = new ScDataFormDlg( pParent, pTabViewShell);
+			break;
+		default:
+			break;
+	}
+
+	if ( pDlg )
+		return new AbstractScDataFormDlg_Impl( pDlg );
+	return 0;
+}
+
+//add for ScDataFormDlg  end
+
 //add for ScDeleteContentsDlg begin
 AbstractScDeleteContentsDlg* ScAbstractDialogFactory_Impl::CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
 																 USHORT  nCheckDefaults )
diff --git sc/source/ui/attrdlg/scdlgfact.hxx sc/source/ui/attrdlg/scdlgfact.hxx
index 463898c..526a1ec 100644
--- sc/source/ui/attrdlg/scdlgfact.hxx
+++ sc/source/ui/attrdlg/scdlgfact.hxx
@@ -40,6 +40,7 @@ class ScDataPilotDatabaseDlg;
 class ScDataPilotSourceTypeDlg;
 class ScDataPilotServiceDlg;
 class ScDeleteCellDlg;
+class ScDataFormDlg;
 class ScDeleteContentsDlg;
 class ScFillSeriesDlg;
 class ScGroupDlg;
@@ -163,6 +164,12 @@ class AbstractScDeleteCellDlg_Impl : public AbstractScDeleteCellDlg  //add for S
 	virtual DelCellCmd GetDelCellCmd() const;
 };
 
+//for dataform
+class AbstractScDataFormDlg_Impl : public AbstractScDataFormDlg  //add for ScDataFormDlg
+{
+	DECL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl,ScDataFormDlg);
+};
+
 class AbstractScDeleteContentsDlg_Impl : public AbstractScDeleteContentsDlg  //add for ScDeleteContentsDlg
 {
 	DECL_ABSTDLG_BASE( AbstractScDeleteContentsDlg_Impl,ScDeleteContentsDlg)
@@ -391,6 +398,9 @@ public:
 	virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId,
 															BOOL bDisallowCellMove = FALSE ); //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell); //add for ScDeleteCellDlg
+
 	virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
 																 USHORT  nCheckDefaults = 0 );
 
diff --git sc/source/ui/inc/datafdlg.hrc sc/source/ui/inc/datafdlg.hrc
new file mode 100644
index 0000000..8fa8999
--- /dev/null
+++ sc/source/ui/inc/datafdlg.hrc
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hrc,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:37:12 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "sc.hrc"	// -> RID_SCDLG_DATAFORM
+
+//dataform
+#define BTN_DATAFORM_NEW          1001
+#define BTN_DATAFORM_DELETE       1002
+#define BTN_DATAFORM_RESTORE      1003
+#define BTN_DATAFORM_LAST         1004
+#define BTN_DATAFORM_NEXT         1005
+#define BTN_DATAFORM_CLOSE        1007
+#define WND_DATAFORM_SCROLLBAR    1008
+#define LAB_DATAFORM_RECORDNO     1009
+
+#define FT_DATAFORM_FIXEDTEXT1    2001
+#define ED_DATAFORM_EDIT1         2002
\ No newline at end of file
diff --git sc/source/ui/inc/datafdlg.hxx sc/source/ui/inc/datafdlg.hxx
new file mode 100644
index 0000000..3e6d8e3
--- /dev/null
+++ sc/source/ui/inc/datafdlg.hxx
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:20:35 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DATAFDLG_HXX
+#define SC_DATAFDLG_HXX
+
+
+#ifndef _SV_DIALOG_HXX //autogen
+#include <vcl/dialog.hxx>
+#endif
+
+#ifndef _SV_BUTTON_HXX //autogen
+#include <vcl/imagebtn.hxx>
+#endif
+
+#ifndef _SV_FIXED_HXX //autogen
+#include <vcl/fixed.hxx>
+#endif
+
+
+#include "global.hxx"
+
+#include <tabvwsh.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/dispatch.hxx>
+
+#define MAX_DATAFORM_COLS   256
+#define MAX_DATAFORM_ROWS   32000
+#define CTRL_HEIGHT         22
+#define FIXED_WIDTH         60
+#define EDIT_WIDTH          140 
+#define FIXED_LEFT          12
+#define EDIT_LEFT           78
+#define LINE_HEIGHT         30
+
+//zhangyun
+class ScDataFormDlg : public ModalDialog
+{
+private:
+
+    PushButton      aBtnNew;
+    PushButton      aBtnDelete;
+    PushButton      aBtnRestore;
+    PushButton      aBtnLast;
+    PushButton      aBtnNext;
+    PushButton      aBtnClose;
+    ScrollBar       aSlider;
+    FixedText       aFixedText;
+    //FixedText       aFixedText1;
+    //Edit            aEdit1;
+    
+    ScTabViewShell* pTabViewShell;
+    ScDocument*     pDoc;
+    sal_uInt16      aColLength;
+    SCROW           aCurrentRow;
+    SCCOL           nStartCol;
+    SCCOL           nEndCol;
+    SCROW           nStartRow;
+    SCROW           nEndRow;
+    SCTAB           nTab;
+    BOOL            bNoSelection;
+    
+    FixedText** pFixedTexts;
+    Edit** pEdits;
+
+public:
+    ScDataFormDlg( Window* pParent, ScTabViewShell* pTabViewShell);
+    ~ScDataFormDlg();
+    
+    void FillCtrls(SCROW nCurrentRow);
+private:
+
+    void SetButtonState();
+
+    // Handler:
+    DECL_LINK( Impl_NewHdl,     PushButton*    );
+    DECL_LINK( Impl_LastHdl,    PushButton*    );
+    DECL_LINK( Impl_NextHdl,    PushButton*    );
+    
+    DECL_LINK( Impl_RestoreHdl, PushButton*    );
+    DECL_LINK( Impl_DeleteHdl,  PushButton*    );
+    DECL_LINK( Impl_CloseHdl,   PushButton*    );
+    
+    DECL_LINK( Impl_ScrollHdl,  ScrollBar*    );
+    DECL_LINK( Impl_DataModifyHdl,  Edit*    );
+};
+#endif // SC_DATAFDLG_HXX
+
+
diff --git sc/source/ui/inc/undodat.hxx sc/source/ui/inc/undodat.hxx
index 3b65ba1..3487442 100644
--- sc/source/ui/inc/undodat.hxx
+++ sc/source/ui/inc/undodat.hxx
@@ -530,7 +530,43 @@ private:
 	void				Init();
 };
 
+// amelia
+class ScUndoDataForm: public ScBlockUndo
+{
+public:
+					TYPEINFO();
+					ScUndoDataForm( ScDocShell* pNewDocShell,
+								SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+								SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+								const ScMarkData& rMark,
+								ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+								USHORT nNewFlags,
+								ScRefUndoData* pRefData, void* pFill1, void* pFill2, void* pFill3,
+								BOOL bRedoIsFilled = TRUE
+								 );
+	virtual		~ScUndoDataForm();
+
+	virtual	void	Undo();
+	virtual	void	Redo();
+	virtual void	Repeat(SfxRepeatTarget& rTarget);
+	virtual BOOL	CanRepeat(SfxRepeatTarget& rTarget) const;
+
+	virtual String	GetComment() const;
 
+private:
+	ScMarkData		aMarkData;
+	ScDocument*		pUndoDoc;
+	ScDocument*		pRedoDoc;
+	USHORT			nFlags;
+	ScRefUndoData*		pRefUndoData;
+	ScRefUndoData*		pRefRedoData;
+	ULONG			nStartChangeAction;
+	ULONG			nEndChangeAction;
+	BOOL			bRedoFilled;
+
+	void			DoChange( const BOOL bUndo );
+	void			SetChangeTrack();
+};
 
 
 #endif
diff --git sc/source/ui/inc/viewfunc.hxx sc/source/ui/inc/viewfunc.hxx
index acaea7e..0c1fa9e 100644
--- sc/source/ui/inc/viewfunc.hxx
+++ sc/source/ui/inc/viewfunc.hxx
@@ -328,6 +328,13 @@ public:
 	void			ForgetFormatArea()		{ bFormatValid = FALSE; }
 	BOOL			SelectionEditable( BOOL* pOnlyNotBecauseOfMatrix = NULL );
 
+        // Amelia Wang
+        SC_DLLPUBLIC void                   DataFormPutData( SCROW nCurrentRow ,
+                                                             SCROW nStartRow , SCCOL nStartCol ,
+                                                             SCROW nEndRow , SCCOL nEndCol ,
+                                                             Edit** pEdits ,
+                                                             sal_uInt16 aColLength );
+
 												// interne Hilfsfunktionen
 protected:
 	void			UpdateLineAttrs( SvxBorderLine&		  rLine,
diff --git sc/source/ui/miscdlgs/datafdlg.cxx sc/source/ui/miscdlgs/datafdlg.cxx
new file mode 100644
index 0000000..2249c57
--- /dev/null
+++ sc/source/ui/miscdlgs/datafdlg.cxx
@@ -0,0 +1,422 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.cxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: kz $ $Date: 2006/07/21 14:04:33 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+#undef SC_DLLIMPLEMENTATION
+
+//------------------------------------------------------------------
+
+#include "datafdlg.hxx"
+#include "scresid.hxx"
+#include "datafdlg.hrc"
+#include "viewdata.hxx"
+//#include "document.hxx"
+#include "docsh.hxx"
+#include "refundo.hxx"
+#include "undodat.hxx"
+
+#define HDL(hdl)            LINK( this, ScDataFormDlg, hdl )
+
+//zhangyun
+ScDataFormDlg::ScDataFormDlg( Window* pParent, ScTabViewShell*  pTabViewShellOri) :
+    ModalDialog     ( pParent, ScResId( RID_SCDLG_DATAFORM ) ),
+    //
+    aBtnNew          ( this, ScResId( BTN_DATAFORM_NEW ) ),
+    aBtnDelete          ( this, ScResId( BTN_DATAFORM_DELETE ) ),
+    aBtnRestore          ( this, ScResId( BTN_DATAFORM_RESTORE ) ),
+    aBtnLast          ( this, ScResId( BTN_DATAFORM_LAST ) ),
+    aBtnNext          ( this, ScResId( BTN_DATAFORM_NEXT ) ),
+    aBtnClose          ( this, ScResId( BTN_DATAFORM_CLOSE ) ),
+    aSlider         ( this, ScResId( WND_DATAFORM_SCROLLBAR ) ),
+    aFixedText          ( this, ScResId( LAB_DATAFORM_RECORDNO ) )
+{
+    pTabViewShell = pTabViewShellOri;
+    FreeResource();
+    //read header form current document, and add new controls
+    DBG_ASSERT( pTabViewShell, "pTabViewShell is NULL! :-/" );
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    
+    pDoc = pViewData->GetDocument();
+    if (pDoc)
+    {
+        ScRange aRange;
+        pViewData->GetSimpleArea( aRange );
+        ScAddress aStart = aRange.aStart;
+        ScAddress aEnd = aRange.aEnd;
+        
+        nStartCol = aStart.Col();
+        nEndCol = aEnd.Col();
+        nStartRow   = aStart.Row();
+        nEndRow = aEnd.Row();
+        
+        nTab = pViewData->GetTabNo();
+        //if there is no selection
+        if ((nStartCol == nEndCol) && (nStartRow == nEndRow))
+            bNoSelection = TRUE;
+        
+        if (bNoSelection)
+        {
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                nEndCol++;
+                pDoc->GetString( nEndCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nEndCol--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                if (nStartCol <= 0)
+                    break;
+                nStartCol--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nStartCol++;
+                    break;
+                }
+            }
+            
+            //skip leading hide column
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                int nColWidth = pDoc->GetColWidth( nStartCol, nTab );
+                if (nColWidth)
+                    break;
+                nStartCol++;
+            }
+
+            if (nEndCol < nStartCol)
+                nEndCol = nStartCol;
+                
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                nEndRow++;
+                pDoc->GetString( nStartCol, nEndRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nEndRow--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                if (nStartRow <= 0)
+                    break;
+                nStartRow--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nStartRow++;
+                    break;
+                }
+            }
+
+            if (nEndRow < nStartRow)
+                nEndRow = nStartRow;
+        }
+        
+        aCurrentRow = nStartRow + 1;
+        
+        String  aFieldName;
+
+        int nTop = 12;
+
+        Size    nFixedSize(FIXED_WIDTH, CTRL_HEIGHT );
+        Size    nEditSize(EDIT_WIDTH, CTRL_HEIGHT );
+        
+        //pFtArray = new FixedText(this);
+        aColLength = nEndCol - nStartCol + 1;
+        
+        //new the controls
+        pFixedTexts = new FixedText*[aColLength];
+        pEdits = new Edit*[aColLength];
+        
+        for(sal_uInt16 nIndex = 0; nIndex < aColLength; nIndex++)
+        {
+            pDoc->GetString( nIndex + nStartCol, nStartRow, nTab, aFieldName );
+            int nColWidth = pDoc->GetColWidth( nIndex + nStartCol, nTab );
+            if (nColWidth)
+            {
+                pFixedTexts[nIndex] = new FixedText(this);
+                pEdits[nIndex] = new Edit(this, WB_BORDER);
+        
+                pFixedTexts[nIndex]->SetSizePixel(nFixedSize);
+                pEdits[nIndex]->SetSizePixel(nEditSize);
+                pFixedTexts[nIndex]->SetPosPixel(Point(FIXED_LEFT, nTop));
+                pEdits[nIndex]->SetPosPixel(Point(EDIT_LEFT, nTop));
+                //pFixedTexts[nIndex]->SetText(String::CreateFromAscii("W4W-Filter Nr. "));
+                pFixedTexts[nIndex]->SetText(aFieldName);
+                pFixedTexts[nIndex]->Show();
+                pEdits[nIndex]->Show();
+                
+                nTop += LINE_HEIGHT;
+            }
+            else
+            {
+                pFixedTexts[nIndex] = NULL;
+                pEdits[nIndex] = NULL;
+            }
+        pEdits[nIndex]->SetModifyHdl( HDL(Impl_DataModifyHdl) );
+        }
+        
+        Size nDialogSize = this->GetSizePixel();
+        if (nTop > nDialogSize.Height())
+        {
+            nDialogSize.setHeight(nTop);
+            this->SetSizePixel(nDialogSize);
+        }
+        Size nScrollSize = aSlider.GetSizePixel();
+        nScrollSize.setHeight(nDialogSize.Height()-20);
+        aSlider.SetSizePixel(nScrollSize);
+    }
+    
+    FillCtrls(aCurrentRow);
+    
+    aSlider.SetPageSize( 10 );
+    aSlider.SetVisibleSize( 1 );
+    aSlider.SetLineSize( 1 );
+    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+    aSlider.Show();
+    
+    aBtnNew.SetClickHdl     ( HDL(Impl_NewHdl)    );
+    aBtnLast.SetClickHdl    ( HDL(Impl_LastHdl)    );
+    aBtnNext.SetClickHdl    ( HDL(Impl_NextHdl)    );
+    
+    aBtnRestore.SetClickHdl     ( HDL(Impl_RestoreHdl)    );
+    aBtnDelete.SetClickHdl  ( HDL(Impl_DeleteHdl)    );
+    aBtnClose.SetClickHdl   ( HDL(Impl_CloseHdl)    );
+    
+    aSlider.SetEndScrollHdl( HDL( Impl_ScrollHdl ) );
+
+    SetButtonState();
+
+    //end
+    //FreeResource();
+}
+
+ScDataFormDlg::~ScDataFormDlg()
+{
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+            delete pEdits[i];
+        if (pFixedTexts[i])
+            delete pFixedTexts[i];
+    }
+    if (pEdits)
+        delete pEdits;
+    if (pFixedTexts)
+        delete pFixedTexts;
+}
+
+void ScDataFormDlg::FillCtrls(SCROW /*nCurrentRow*/)
+{
+    //ScViewData*   pViewData = pTabViewShell->GetViewData();
+    
+    //pDoc = pViewData->GetDocument();
+    String  aFieldName;
+    int nRecordNum = nEndRow - nStartRow;
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+        {
+            if (aCurrentRow<=nEndRow)
+            {
+                pDoc->GetString( i + nStartCol, aCurrentRow, nTab, aFieldName );
+                pEdits[i]->SetText(aFieldName);
+            }
+            else
+                pEdits[i]->SetText(String());
+        }
+    }
+    char sRecordStr[256];
+    if (aCurrentRow<=nEndRow)
+        aFixedText.SetText(String::CreateFromAscii(sRecordStr));
+    else
+        aFixedText.SetText(String::CreateFromAscii("New Record"));
+        
+    aSlider.SetThumbPos(aCurrentRow-nStartRow-1);
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DataModifyHdl, Edit*, pEdit)
+{
+    if ( pEdit->IsModified() )
+        aBtnRestore.Enable( TRUE );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NewHdl, PushButton*, EMPTYARG )
+{
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if ( pDoc )
+    {
+        sal_Bool bHasData = sal_False;
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+            if (pEdits[i])
+                if ( pEdits[i]->GetText().Len() != 0 )
+                {
+                    bHasData = sal_True;
+                    break;
+                }
+
+        if ( bHasData )
+        {
+            pTabViewShell->DataFormPutData( aCurrentRow , nStartRow , nStartCol , nEndRow , nEndCol , pEdits , aColLength );
+            aCurrentRow++;
+            if (aCurrentRow >= nEndRow + 2)
+            {
+                    nEndRow ++ ;
+                    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+            }
+            SetButtonState();
+            FillCtrls(aCurrentRow);
+            pDocSh->SetDocumentModified();
+            pDocSh->PostPaintGridAll();
+            }
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_LastHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow > nStartRow +1 )
+            aCurrentRow--;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NextHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow <= nEndRow)
+            aCurrentRow++;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_RestoreHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DeleteHdl, PushButton*, EMPTYARG )
+{   
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if (pDoc)
+    {
+        ScRange aRange(nStartCol, aCurrentRow, nTab, nEndCol, aCurrentRow, nTab);
+        pDoc->DeleteRow(aRange);
+        nEndRow--;
+        
+        SetButtonState();
+        pDocSh->GetUndoManager()->Clear();
+
+        FillCtrls(aCurrentRow);
+        pDocSh->SetDocumentModified();
+        pDocSh->PostPaintGridAll();
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_CloseHdl, PushButton*, EMPTYARG )
+{   
+    EndDialog( );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_ScrollHdl, ScrollBar*, EMPTYARG )
+{   
+    long nOffset = aSlider.GetThumbPos();
+    aCurrentRow = nStartRow + nOffset + 1;
+    SetButtonState();
+    FillCtrls(aCurrentRow);
+    return 0;
+}
+
+void ScDataFormDlg::SetButtonState()
+{
+    if ( aCurrentRow > nEndRow )
+    {
+        aBtnDelete.Enable( FALSE );
+        aBtnLast.Enable( TRUE );
+        aBtnNext.Enable( FALSE );
+    }
+    else
+    {
+        aBtnDelete.Enable( TRUE );
+        aBtnNext.Enable( TRUE );
+    }
+    if ( 1 == aCurrentRow )
+        aBtnLast.Enable( FALSE );
+
+    aBtnRestore.Enable( FALSE );
+    if ( pEdits )
+        pEdits[0]->GrabFocus();
+}
diff --git sc/source/ui/miscdlgs/makefile.mk sc/source/ui/miscdlgs/makefile.mk
index 90f3afe..3569ccf 100644
--- sc/source/ui/miscdlgs/makefile.mk
+++ sc/source/ui/miscdlgs/makefile.mk
@@ -45,6 +45,7 @@ LIBTARGET=no
 # --- Files --------------------------------------------------------
 
 SLOFILES =  \
+	$(SLO)$/datafdlg.obj		\
 	$(SLO)$/delcldlg.obj		\
 	$(SLO)$/inscldlg.obj		\
 	$(SLO)$/delcodlg.obj		\
diff --git sc/source/ui/src/datafdlg.src sc/source/ui/src/datafdlg.src
new file mode 100644
index 0000000..535ec66
--- /dev/null
+++ sc/source/ui/src/datafdlg.src
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.src,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: hr $ $Date: 2005/09/23 15:07:30 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "datafdlg.hrc"
+
+//zhangyun, dataform
+ModalDialog RID_SCDLG_DATAFORM
+{
+    OutputSize = TRUE ;
+    SVLook = TRUE ;
+    Size = MAP_APPFONT ( 191 , 180 ) ;
+    Text [ en-US ] = "Data Form" ;
+    Moveable = TRUE ;
+    Closeable = TRUE ;
+    FixedText LAB_DATAFORM_RECORDNO
+    {
+        Pos = MAP_APPFONT ( 136 , 6 ) ;
+        Size = MAP_APPFONT ( 50 , 12 ) ;
+        Text [ en-US ] = "/" ;
+    };
+    PushButton BTN_DATAFORM_NEW
+    {
+        Pos = MAP_APPFONT ( 135 , 23 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        DefButton = TRUE ;
+        Text [ en-US ] = "New" ;
+    };
+    PushButton BTN_DATAFORM_DELETE
+    {
+        Pos = MAP_APPFONT ( 135 , 40 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Delete" ;
+    };
+    PushButton BTN_DATAFORM_RESTORE
+    {
+        Pos = MAP_APPFONT ( 135 , 57 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Restore" ;
+    };
+    PushButton BTN_DATAFORM_LAST
+    {
+        Pos = MAP_APPFONT ( 135 , 82 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Last Record" ;
+    };
+    PushButton BTN_DATAFORM_NEXT
+    {
+        Pos = MAP_APPFONT ( 135 , 99 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Next Record" ;
+    };
+    PushButton BTN_DATAFORM_CLOSE
+    {
+        Pos = MAP_APPFONT ( 135 , 116 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Close" ;
+    };
+    ScrollBar WND_DATAFORM_SCROLLBAR
+    {
+        Pos = MAP_APPFONT ( 124 , 6 ) ;
+        Size = MAP_APPFONT ( 8 , 135 ) ;
+        HScroll = FALSE ;
+        TabStop = FALSE ;
+    };
+};
+//end
+
+
+
+
diff --git sc/source/ui/src/makefile.mk sc/source/ui/src/makefile.mk
index af0e906..8f33ac9 100644
--- sc/source/ui/src/makefile.mk
+++ sc/source/ui/src/makefile.mk
@@ -57,6 +57,7 @@ SRC1FILES = \
 	dbnamdlg.src \
 	subtdlg.src  \
 	miscdlgs.src \
+	datafdlg.src \
 	autofmt.src  \
 	solvrdlg.src \
     optsolver.src \
diff --git sc/source/ui/undo/undodat.cxx sc/source/ui/undo/undodat.cxx
index 4ea4a0a..9aea0eb 100644
--- sc/source/ui/undo/undodat.cxx
+++ sc/source/ui/undo/undodat.cxx
@@ -58,6 +58,8 @@
 #include "dpobject.hxx"
 #include "attrib.hxx"
 #include "sc.hrc"
+#include "chgtrack.hxx"  // Amelia Wang
+#include "refundo.hxx"  // Amelia Wang
 
 // -----------------------------------------------------------------------
 
@@ -74,6 +74,7 @@ TYPEINIT1(ScUndoRepeatDB,           ScSi
 TYPEINIT1(ScUndoDataPilot,          ScSimpleUndo);
 TYPEINIT1(ScUndoConsolidate,        ScSimpleUndo);
 TYPEINIT1(ScUndoChartData,          ScSimpleUndo);
+TYPEINIT1(ScUndoDataForm,           SfxUndoAction);    // amelia
 
 // -----------------------------------------------------------------------
 
@@ -2182,8 +2185,210 @@ BOOL __EXPORT ScUndoChartData::CanRepeat(SfxRepeatTarget& /* rTarget */) const
 	return FALSE;
 }
 
+// Amelia Wang
+ScUndoDataForm::ScUndoDataForm( ScDocShell* pNewDocShell,
+                                SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+                                SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+                                const ScMarkData& rMark,
+                                ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+                                USHORT nNewFlags,
+                                ScRefUndoData* pRefData,
+                                void* /*pFill1*/, void* /*pFill2*/, void* /*pFill3*/,
+                                BOOL bRedoIsFilled ) :
+        ScBlockUndo( pNewDocShell, ScRange( nStartX, nStartY, nStartZ, nEndX, nEndY, nEndZ ), SC_UNDO_SIMPLE ),
+        aMarkData( rMark ),
+        pUndoDoc( pNewUndoDoc ),
+        pRedoDoc( pNewRedoDoc ),
+        nFlags( nNewFlags ),
+        pRefUndoData( pRefData ),
+        pRefRedoData( NULL ),
+        bRedoFilled( bRedoIsFilled )
+{
+        //      pFill1,pFill2,pFill3 are there so the ctor calls for simple paste (without cutting)
+        //      don't have to be changed and branched for 641.
+        //      They can be removed later.
+
+        if ( !aMarkData.IsMarked() )                            // no cell marked:
+                aMarkData.SetMarkArea( aBlockRange );   //  mark paste block
 
+        if ( pRefUndoData )
+                pRefUndoData->DeleteUnchanged( pDocShell->GetDocument() );
 
+        SetChangeTrack();
+}
 
+ScUndoDataForm::~ScUndoDataForm()
+{
+        delete pUndoDoc;
+        delete pRedoDoc;
+        delete pRefUndoData;
+        delete pRefRedoData;
+}
 
+String ScUndoDataForm::GetComment() const
+{
+        return ScGlobal::GetRscString( STR_UNDO_PASTE ); 
+}
+
+void ScUndoDataForm::SetChangeTrack()
+{
+        ScChangeTrack* pChangeTrack = pDocShell->GetDocument()->GetChangeTrack();
+        if ( pChangeTrack && (nFlags & IDF_CONTENTS) )
+                pChangeTrack->AppendContentRange( aBlockRange, pUndoDoc,
+                        nStartChangeAction, nEndChangeAction, SC_CACM_PASTE );
+        else
+                nStartChangeAction = nEndChangeAction = 0;
+}
+
+
+void ScUndoDataForm::Undo()
+{
+        BeginUndo();
+        DoChange( TRUE );
+        ShowTable( aBlockRange );
+        EndUndo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Redo()
+{
+        BeginRedo();
+        ScDocument* pDoc = pDocShell->GetDocument();
+        EnableDrawAdjust( pDoc, FALSE );                                //! include in ScBlockUndo?
+        DoChange( FALSE );
+        EnableDrawAdjust( pDoc, TRUE );                                 //! include in ScBlockUndo?
+        EndRedo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Repeat(SfxRepeatTarget& /*rTarget*/)
+{
+}
 
+BOOL ScUndoDataForm::CanRepeat(SfxRepeatTarget& rTarget) const
+{
+        return (rTarget.ISA(ScTabViewTarget));
+}
+
+void ScUndoDataForm::DoChange( const BOOL bUndo )
+{
+    ScDocument* pDoc = pDocShell->GetDocument();
+
+    //      RefUndoData for redo is created before first undo
+    //      (with DeleteUnchanged after the DoUndo call)
+    BOOL bCreateRedoData = ( bUndo && pRefUndoData && !pRefRedoData );
+    if ( bCreateRedoData )
+            pRefRedoData = new ScRefUndoData( pDoc );
+
+    ScRefUndoData* pWorkRefData = bUndo ? pRefUndoData : pRefRedoData;
+
+    //      fuer Undo immer alle oder keine Inhalte sichern
+    USHORT nUndoFlags = IDF_NONE;
+    if (nFlags & IDF_CONTENTS)
+            nUndoFlags |= IDF_CONTENTS;
+    if (nFlags & IDF_ATTRIB)
+            nUndoFlags |= IDF_ATTRIB;
+
+    BOOL bPaintAll = FALSE;
+
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
+
+    // marking is in ScBlockUndo...
+    //ScUndoUtil::MarkSimpleBlock( pDocShell, aBlockRange );
+
+    SCTAB nTabCount = pDoc->GetTableCount();
+    if ( bUndo && !bRedoFilled )
+    {
+        if (!pRedoDoc)
+        {
+            BOOL bColInfo = ( aBlockRange.aStart.Row()==0 && aBlockRange.aEnd.Row()==MAXROW );
+            BOOL bRowInfo = ( aBlockRange.aStart.Col()==0 && aBlockRange.aEnd.Col()==MAXCOL );
+
+            pRedoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pRedoDoc->InitUndoSelected( pDoc, aMarkData, bColInfo, bRowInfo );
+        }
+        //  read "redo" data from the document in the first undo
+            //  all sheets - CopyToDocument skips those that don't exist in pRedoDoc
+        ScRange aCopyRange = aBlockRange;
+        aCopyRange.aStart.SetTab(0);
+        aCopyRange.aEnd.SetTab(nTabCount-1);
+        pDoc->CopyToDocument( aCopyRange, 1, FALSE, pRedoDoc );
+        bRedoFilled = TRUE;
+    }
+
+    USHORT nExtFlags = 0;
+    pDocShell->UpdatePaintExt( nExtFlags, aBlockRange );
+
+    for ( sal_uInt16 i=0; i <= ( aBlockRange.aEnd.Col() - aBlockRange.aStart.Col() ); i++ )
+    {
+        String aOldString;
+        pUndoDoc->GetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+        pDoc->SetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+    }
+
+    //ScRange aTabSelectRange = aBlockRange;
+
+    if (pWorkRefData)
+    {
+        pWorkRefData->DoUndo( pDoc, TRUE );             // TRUE = bSetChartRangeLists for SetChartListenerCollection
+        if ( pDoc->RefreshAutoFilter( 0,0, MAXCOL,MAXROW, aBlockRange.aStart.Tab() ) )
+            bPaintAll = TRUE;
+    }
+
+    if ( bCreateRedoData && pRefRedoData )
+            pRefRedoData->DeleteUnchanged( pDoc );
+    
+    if ( bUndo )
+    {
+        ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+        if ( pChangeTrack )
+            pChangeTrack->Undo( nStartChangeAction, nEndChangeAction );
+    }
+    else
+        SetChangeTrack();
+
+    ScRange aDrawRange( aBlockRange );
+    pDoc->ExtendMerge( aDrawRange, TRUE );      // only needed for single sheet (text/rtf etc.)
+    USHORT nPaint = PAINT_GRID;
+    if (bPaintAll)
+    {
+        aDrawRange.aStart.SetCol(0);
+        aDrawRange.aStart.SetRow(0);
+        aDrawRange.aEnd.SetCol(MAXCOL);
+        aDrawRange.aEnd.SetRow(MAXROW);
+        nPaint |= PAINT_TOP | PAINT_LEFT;
+/*A*/   if (pViewShell)
+            pViewShell->AdjustBlockHeight(FALSE);
+    }
+    else
+    {
+        if ( aBlockRange.aStart.Row() == 0 && aBlockRange.aEnd.Row() == MAXROW )        // ganze Spalte
+        {
+            nPaint |= PAINT_TOP;
+            aDrawRange.aEnd.SetCol(MAXCOL);
+        }
+        if ( aBlockRange.aStart.Col() == 0 && aBlockRange.aEnd.Col() == MAXCOL )        // ganze Zeile
+        {
+            nPaint |= PAINT_LEFT;
+            aDrawRange.aEnd.SetRow(MAXROW);
+        }
+/*A*/   if ((pViewShell) && pViewShell->AdjustBlockHeight(FALSE))
+        {
+            aDrawRange.aStart.SetCol(0);
+            aDrawRange.aStart.SetRow(0);
+            aDrawRange.aEnd.SetCol(MAXCOL);
+            aDrawRange.aEnd.SetRow(MAXROW);
+            nPaint |= PAINT_LEFT;
+        }
+        pDocShell->UpdatePaintExt( nExtFlags, aDrawRange );
+    }
+
+    if ( !bUndo )                               //      draw redo after updating row heights
+        RedoSdrUndoAction( pDrawUndo );                 //!     include in ScBlockUndo?
+
+    pDocShell->PostPaint( aDrawRange, nPaint, nExtFlags );
+
+    pDocShell->PostDataChanged();
+    if (pViewShell)
+        pViewShell->CellContentChanged();
+}
diff --git sc/source/ui/view/cellsh2.cxx sc/source/ui/view/cellsh2.cxx
index 7dee7cc..231e71e 100644
--- sc/source/ui/view/cellsh2.cxx
+++ sc/source/ui/view/cellsh2.cxx
@@ -265,6 +265,20 @@ void ScCellShell::ExecuteDB( SfxRequest& rReq )
 			}
 			break;
 
+		case SID_DATA_FORM:
+			{
+				ScAbstractDialogFactory* pFact = ScAbstractDialogFactory::Create();
+	            DBG_ASSERT(pFact, "ScAbstractFactory create fail!");//CHINA001
+
+	            AbstractScDataFormDlg* pDlg = pFact->CreateScDataFormDlg( pTabViewShell->GetDialogParent(),RID_SCDLG_DATAFORM, pTabViewShell);
+	            DBG_ASSERT(pDlg, "Dialog create fail!");//CHINA001
+
+	            pDlg->Execute();
+	            
+				rReq.Done();
+			}
+			break;
+			
 		case SID_SUBTOTALS:
 			{
 				const SfxItemSet* pArgs = rReq.GetArgs();
diff --git sc/source/ui/view/viewfun3.cxx sc/source/ui/view/viewfun3.cxx
index 1cb5400..9c2ef97 100644
--- sc/source/ui/view/viewfun3.cxx
+++ sc/source/ui/view/viewfun3.cxx
@@ -208,6 +208,7 @@
 #include "transobj.hxx"
 #include "drwtrans.hxx"
 #include "docuno.hxx"
+#include "undodat.hxx"   // Amelia Wang
 
 using namespace com::sun::star;
 
@@ -1414,6 +1415,85 @@ BOOL ScViewFunc::LinkBlock( const ScRange& rSource, const ScAddress& rDestPos, B
 	return TRUE;
 }
 
+void ScViewFunc::DataFormPutData( SCROW nCurrentRow ,
+                                  SCROW nStartRow , SCCOL nStartCol ,
+                                  SCROW nEndRow , SCCOL nEndCol ,
+                                  Edit** pEdits ,
+                                  sal_uInt16 aColLength )
+{
+    ScDocument* pDoc = GetViewData()->GetDocument();
+    ScDocShell* pDocSh = GetViewData()->GetDocShell();
+    ScMarkData& rMark = GetViewData()->GetMarkData();
+    ScDocShellModificator aModificator( *pDocSh );
+    SfxUndoManager* pUndoMgr = pDocSh->GetUndoManager();
+    if ( pDoc )
+    {
+        const BOOL bRecord( pDoc->IsUndoEnabled());
+        ScDocument* pUndoDoc = NULL;
+        ScDocument* pRedoDoc = NULL;
+        ScDocument* pRefUndoDoc = NULL;
+        ScRefUndoData* pUndoData = NULL;
+        SCTAB nTab = GetViewData()->GetTabNo();
+        SCTAB nStartTab = nTab;
+        SCTAB nEndTab = nTab;
+        
+        {
+                ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+                if ( pChangeTrack )
+                        pChangeTrack->ResetLastCut();   // kein CutMode mehr
+        }
+        ScRange aUserRange( nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );
+        BOOL bColInfo = ( nStartRow==0 && nEndRow==MAXROW );
+        BOOL bRowInfo = ( nStartCol==0 && nEndCol==MAXCOL );
+        SCCOL nUndoEndCol = nStartCol+aColLength-1;
+        SCROW nUndoEndRow = nCurrentRow;
+        USHORT nUndoFlags = IDF_NONE;
+
+        if ( bRecord )
+        {
+            pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pUndoDoc->InitUndoSelected( pDoc , rMark , bColInfo , bRowInfo );
+            pDoc->CopyToDocument( aUserRange , 1 , FALSE , pUndoDoc );
+        }
+        USHORT nExtFlags = 0;
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nStartRow, nStartTab , nEndCol, nEndRow, nEndTab ); // content before the change
+        //rMark.SetMarkArea( aUserRange );
+        pDoc->BeginDrawUndo();
+        
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+        {
+            if (pEdits[i])
+            {
+                String  aFieldName=pEdits[i]->GetText();
+                pDoc->SetString( nStartCol + i, nCurrentRow, nTab, aFieldName );
+            }
+        }
+        //pDoc->ExtendMergeSel( nStartCol, nStartRow, nEndCol, nEndRow, rMark, TRUE );    // Refresh
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );  // content after the change
+        SfxUndoAction* pUndo = new ScUndoDataForm( pDocSh,
+                                                                nStartCol, nCurrentRow, nStartTab,
+                                                                nUndoEndCol, nUndoEndRow, nEndTab, rMark,
+                                                                pUndoDoc, pRedoDoc, nUndoFlags,
+                                                                pUndoData, NULL, NULL, NULL,
+                                                                FALSE );           // FALSE = Redo data not yet copied
+        pUndoMgr->AddUndoAction( new ScUndoWrapper( pUndo ), TRUE );
+        
+        USHORT nPaint = PAINT_GRID;
+        if (bColInfo)
+        {
+                nPaint |= PAINT_TOP;
+                nUndoEndCol = MAXCOL;                           // nur zum Zeichnen !
+        }
+        if (bRowInfo)
+        {
+                nPaint |= PAINT_LEFT;
+                nUndoEndRow = MAXROW;                           // nur zum Zeichnen !
+        }
 
+        pDocSh->PostPaint( nStartCol, nCurrentRow, nStartTab,
+                                                nUndoEndCol, nUndoEndRow, nEndTab, nPaint, nExtFlags );
+        pDocSh->UpdateOle(GetViewData());
+    }
+}
 
 
diff --git sc/uiconfig/scalc/menubar/menubar.xml sc/uiconfig/scalc/menubar/menubar.xml
index 938f00b..06dfc6f 100644
--- sc/uiconfig/scalc/menubar/menubar.xml
+++ sc/uiconfig/scalc/menubar/menubar.xml
@@ -391,6 +391,7 @@
 					<menu:menuitem menu:id=".uno:DataFilterHideAutoFilter"/>
 				</menu:menupopup>
 			</menu:menu>
+			<menu:menuitem menu:id=".uno:DataForm"/>
 			<menu:menuitem menu:id=".uno:DataSubTotals"/>
 			<menu:menuitem menu:id=".uno:Validation"/>
 			<menu:menuseparator/>
diff --git sc/util/makefile.mk sc/util/makefile.mk
index a051bb8..9d2706a 100644
--- sc/util/makefile.mk
+++ sc/util/makefile.mk
@@ -273,6 +273,7 @@ LIB8OBJFILES = \
 		$(SLO)$/filldlg.obj			\
 		$(SLO)$/delcodlg.obj		\
 		$(SLO)$/delcldlg.obj		\
+		$(SLO)$/datafdlg.obj		\
 		$(SLO)$/dapitype.obj	\
 		$(SLO)$/dapidata.obj	\
 		$(SLO)$/crdlg.obj			\
