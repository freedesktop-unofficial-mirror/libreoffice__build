From ec416334c40c7e0f31b3b0541447c212a1727cf8 Mon Sep 17 00:00:00 2001
From: Jan Nieuwenhuizen <janneke@gnu.org>
Date: Fri, 5 Jun 2009 15:51:45 +0200
Subject: [PATCH] [OOXML]: use 32 bits for xlsx row export.  Fixes 65536 row limit, n#504623.

Also, fix export of Formulas in the last row (off by one bug),
Note content and Hyperlinks below 65536.

A lot of files are touched to add explitic #includes of copied
headers (xladdress.hxx, xlconst.hxx etc).

Original filter/inc headers are touched, only to add an include
guard to ascertain we're not including original versions of
copied headers.

   * Modified     sc/source/filter/inc/xetable.hxx
   * Modified     sc/source/filter/inc/xladdress.hxx
   * Modified     sc/source/filter/inc/xlconst.hxx
   * Modified     sc/source/filter/inc/xlformula.hxx
   * Added        sc/source/filter/inc/xlsx/xetable.hxx
   * Added        sc/source/filter/inc/xlsx/xladdress.hxx
   * Added        sc/source/filter/inc/xlsx/xlconst.hxx
   * Added        sc/source/filter/inc/xlsx/xlformula.hxx
   * Modified     sc/source/filter/xlsx/XclExpChangeTrack.hxx
   * Modified     sc/source/filter/xlsx/excrecds.hxx
   * Modified     sc/source/filter/xlsx/makefile.mk
   * Modified     sc/source/filter/xlsx/xestream.hxx
   * Modified     sc/source/filter/xlsx/xlsx-colrowst.cxx
   * Modified     sc/source/filter/xlsx/xlsx-excdoc.cxx
   * Modified     sc/source/filter/xlsx/xlsx-excel.cxx
   * Modified     sc/source/filter/xlsx/xlsx-excform.cxx
   * Modified     sc/source/filter/xlsx/xlsx-excform8.cxx
   * Modified     sc/source/filter/xlsx/xlsx-excimp8.cxx
   * Modified     sc/source/filter/xlsx/xlsx-exctools.cxx
   * Modified     sc/source/filter/xlsx/xlsx-expop2.cxx
   * Modified     sc/source/filter/xlsx/xlsx-impop.cxx
   * Modified     sc/source/filter/xlsx/xlsx-namebuff.cxx
   * Modified     sc/source/filter/xlsx/xlsx-read.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xcl97esc.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xechart.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xecontent.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xeescher.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xeformula.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xehelper.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xelink.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xename.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xepage.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xepivot.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xerecord.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xeroot.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xestream.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xetable.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xeview.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xichart.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xicontent.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xiescher.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xiformula.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xihelper.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xilink.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xiname.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xipage.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xipivot.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xiroot.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xistream.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xistring.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xistyle.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xiview.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xladdress.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlchart.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlescher.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlformula.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlpage.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlpivot.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlroot.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlstyle.cxx
   * Modified     sc/source/filter/xlsx/xlsx-xlview.cxx
---
 sc/source/filter/inc/xetable.hxx            |    4 +
 sc/source/filter/inc/xladdress.hxx          |    4 +
 sc/source/filter/inc/xlconst.hxx            |    4 +
 sc/source/filter/inc/xlformula.hxx          |    4 +
 sc/source/filter/inc/xlsx/xetable.hxx       | 1092 +++++++++++++++++++++++++++
 sc/source/filter/inc/xlsx/xladdress.hxx     |  200 +++++
 sc/source/filter/inc/xlsx/xlconst.hxx       |  236 ++++++
 sc/source/filter/inc/xlsx/xlformula.hxx     |  477 ++++++++++++
 sc/source/filter/xlsx/XclExpChangeTrack.hxx |    6 +-
 sc/source/filter/xlsx/excrecds.hxx          |    3 +
 sc/source/filter/xlsx/makefile.mk           |    2 +
 sc/source/filter/xlsx/xestream.hxx          |    3 +
 sc/source/filter/xlsx/xlsx-colrowst.cxx     |    3 +-
 sc/source/filter/xlsx/xlsx-excdoc.cxx       |    4 +
 sc/source/filter/xlsx/xlsx-excel.cxx        |    3 +
 sc/source/filter/xlsx/xlsx-excform.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-excform8.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-excimp8.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-exctools.cxx     |    2 +-
 sc/source/filter/xlsx/xlsx-expop2.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-impop.cxx        |    3 +
 sc/source/filter/xlsx/xlsx-namebuff.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-read.cxx         |    3 +
 sc/source/filter/xlsx/xlsx-xcl97esc.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-xechart.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-xecontent.cxx    |    5 +-
 sc/source/filter/xlsx/xlsx-xeescher.cxx     |   12 +-
 sc/source/filter/xlsx/xlsx-xeformula.cxx    |   28 +-
 sc/source/filter/xlsx/xlsx-xehelper.cxx     |    5 +-
 sc/source/filter/xlsx/xlsx-xelink.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xename.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xepage.cxx       |    5 +-
 sc/source/filter/xlsx/xlsx-xepivot.cxx      |    6 +-
 sc/source/filter/xlsx/xlsx-xerecord.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-xeroot.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xestream.cxx     |    4 +-
 sc/source/filter/xlsx/xlsx-xetable.cxx      |   36 +-
 sc/source/filter/xlsx/xlsx-xeview.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xichart.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-xicontent.cxx    |    3 +
 sc/source/filter/xlsx/xlsx-xiescher.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-xiformula.cxx    |    2 +
 sc/source/filter/xlsx/xlsx-xihelper.cxx     |    5 +-
 sc/source/filter/xlsx/xlsx-xilink.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xiname.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xipage.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xipivot.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-xiroot.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xistream.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-xistring.cxx     |    3 +
 sc/source/filter/xlsx/xlsx-xistyle.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-xiview.cxx       |    3 +
 sc/source/filter/xlsx/xlsx-xladdress.cxx    |    2 +-
 sc/source/filter/xlsx/xlsx-xlchart.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-xlescher.cxx     |    2 +-
 sc/source/filter/xlsx/xlsx-xlformula.cxx    |    2 +-
 sc/source/filter/xlsx/xlsx-xlpage.cxx       |    1 +
 sc/source/filter/xlsx/xlsx-xlpivot.cxx      |    3 +
 sc/source/filter/xlsx/xlsx-xlroot.cxx       |    1 +
 sc/source/filter/xlsx/xlsx-xlstyle.cxx      |    1 +
 sc/source/filter/xlsx/xlsx-xlview.cxx       |    1 +
 61 files changed, 2199 insertions(+), 50 deletions(-)
 create mode 100644 sc/source/filter/inc/xlsx/xetable.hxx
 create mode 100644 sc/source/filter/inc/xlsx/xladdress.hxx
 create mode 100644 sc/source/filter/inc/xlsx/xlconst.hxx
 create mode 100644 sc/source/filter/inc/xlsx/xlformula.hxx

diff --git sc/source/filter/inc/xetable.hxx sc/source/filter/inc/xetable.hxx
index 3da59d2..3f5b0ab 100644
--- sc/source/filter/inc/xetable.hxx
+++ sc/source/filter/inc/xetable.hxx
@@ -31,6 +31,10 @@
 #ifndef SC_XETABLE_HXX
 #define SC_XETABLE_HXX
 
+#ifdef XLSX_COPY
+#error XLSX_COPY
+#endif
+
 #include "xltable.hxx"
 
 #include <deque>
diff --git sc/source/filter/inc/xladdress.hxx sc/source/filter/inc/xladdress.hxx
index c4aff69..05f033a 100644
--- sc/source/filter/inc/xladdress.hxx
+++ sc/source/filter/inc/xladdress.hxx
@@ -31,6 +31,10 @@
 #ifndef SC_XLADDRESS_HXX
 #define SC_XLADDRESS_HXX
 
+#ifdef XLSX_COPY
+#error XLSX_COPY
+#endif
+
 #include <vector>
 #include "address.hxx"
 
diff --git sc/source/filter/inc/xlconst.hxx sc/source/filter/inc/xlconst.hxx
index 5cca23d..ff9bc8d 100644
--- sc/source/filter/inc/xlconst.hxx
+++ sc/source/filter/inc/xlconst.hxx
@@ -31,6 +31,10 @@
 #ifndef SC_XLCONST_HXX
 #define SC_XLCONST_HXX
 
+#ifdef XLSX_COPY
+#error XLSX_COPY
+#endif
+
 #include "address.hxx"
 
 // Common =====================================================================
diff --git sc/source/filter/inc/xlformula.hxx sc/source/filter/inc/xlformula.hxx
index f0f54e4..c145f70 100644
--- sc/source/filter/inc/xlformula.hxx
+++ sc/source/filter/inc/xlformula.hxx
@@ -31,6 +31,10 @@
 #ifndef SC_XLFORMULA_HXX
 #define SC_XLFORMULA_HXX
 
+#ifdef XLSX_COPY
+#error XLSX_COPY
+#endif
+
 #include <map>
 #include "address.hxx"
 #include "formula/opcode.hxx"
diff --git sc/source/filter/inc/xlsx/xetable.hxx sc/source/filter/inc/xlsx/xetable.hxx
new file mode 100644
index 0000000..7a30a2f
--- /dev/null
+++ sc/source/filter/inc/xlsx/xetable.hxx
@@ -0,0 +1,1092 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xetable.hxx,v $
+ * $Revision: 1.11 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XETABLE_HXX
+#define SC_XETABLE_HXX
+
+#include "xltable.hxx"
+
+#include <deque>
+#include <tools/mempool.hxx>
+#include "xladdress.hxx"
+#include "xerecord.hxx"
+#include "xestring.hxx"
+#include "xeformula.hxx"
+#include "xestyle.hxx"
+
+/* ============================================================================
+Export of cell tables including row and column description.
+- Managing all used and formatted cells in a sheet.
+- Row and column properties, i.e. width/height, visibility.
+- Find default row formatting and default column formatting.
+- Merged cell ranges.
+============================================================================ */
+
+// ============================================================================
+// Helper records for cell records
+// ============================================================================
+
+/** Represents a STRING record that contains the result of a string formula. */
+class XclExpStringRec : public XclExpRecord
+{
+public:
+    explicit            XclExpStringRec( const XclExpRoot& rRoot, const String& rResult );
+
+private:
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    XclExpStringRef     mxResult;
+};
+
+// Additional records for special formula ranges ==============================
+
+/** Base record for additional range formula records (i.e. ARRAY, SHRFMLA). */
+class XclExpRangeFmlaBase : public XclExpRecord
+{
+public:
+    /** Returns true, if the passed cell position is equal to own base position. */
+    bool IsBasePos( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const;
+
+    /** Derived classes create the token array for a corresponding FORMULA cell record. */
+    virtual XclTokenArrayRef CreateCellTokenArray( const XclExpRoot& rRoot ) const = 0;
+    /** Derived classes return true, if the own formula contains volatile functions. */
+    virtual bool        IsVolatile() const = 0;
+
+protected:
+    /** Constructs the record with a single cell. */
+    explicit            XclExpRangeFmlaBase(
+                            sal_uInt16 nRecId, sal_uInt32 nRecSize, const ScAddress& rScPos );
+    /** Constructs the record with a cell range. */
+    explicit            XclExpRangeFmlaBase(
+                            sal_uInt16 nRecId, sal_uInt32 nRecSize, const ScRange& rScRange );
+
+    /** Extends the cell range to include the passed cell address. */
+    void                Extend( const ScAddress& rScPos );
+
+    /** Writes the range address covered by this record. */
+    void                WriteRangeAddress( XclExpStream& rStrm ) const;
+
+protected:
+    XclRange            maXclRange;     /// Range described by this record.
+    XclAddress          maBaseXclPos;   /// Address of base cell (first FORMULA record).
+};
+
+typedef ScfRef< XclExpRangeFmlaBase > XclExpRangeFmlaRef;
+
+// Array formulas =============================================================
+
+class ScTokenArray;
+
+/** Represents an ARRAY record that contains the token array of a matrix formula.
+
+    An ARRAY record is stored following the first FORMULA record that is part
+    of a matrix formula. All FORMULA records of a matrix formula contain a
+    reference to the ARRAY record, while the ARRAY record contains the formula
+    token array used by all formulas.
+ */
+class XclExpArray : public XclExpRangeFmlaBase
+{
+public:
+    explicit            XclExpArray( XclTokenArrayRef xTokArr, const ScRange& rScRange );
+
+    /** Creates and returns the token array for a corresponding FORMULA cell record. */
+    virtual XclTokenArrayRef CreateCellTokenArray( const XclExpRoot& rRoot ) const;
+    /** Returns true, if the array formula contains volatile functions. */
+    virtual bool        IsVolatile() const;
+
+private:
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    XclTokenArrayRef    mxTokArr;       /// The token array of a matrix formula.
+};
+
+typedef ScfRef< XclExpArray > XclExpArrayRef;
+
+// ----------------------------------------------------------------------------
+
+/** Caches all ARRAY records. */
+class XclExpArrayBuffer : protected XclExpRoot
+{
+public:
+    explicit            XclExpArrayBuffer( const XclExpRoot& rRoot );
+
+    /** Inserts a new ARRAY record into the buffer and returns it. */
+    XclExpArrayRef      CreateArray( const ScTokenArray& rScTokArr, const ScRange& rScRange );
+    /** Tries to find an ARRAY record that corresponds to an ocMatRef token. */
+    XclExpArrayRef      FindArray( const ScTokenArray& rScTokArr ) const;
+
+private:
+    typedef ::std::map< ScAddress, XclExpArrayRef > XclExpArrayMap;
+    XclExpArrayMap      maRecMap;       /// Map containing the ARRAY records.
+};
+
+// Shared formulas ============================================================
+
+/** Represents a SHRFMLA record that contains the token array of a shared formula.
+
+    A SHRFMLA record is stored following the first FORMULA record that is part
+    of a shared formula. All FORMULA records of a shared formula contain a
+    reference to the SHRFMLA record, while the SHRFMLA record contains the
+    formula token array used by all formulas.
+ */
+class XclExpShrfmla : public XclExpRangeFmlaBase
+{
+public:
+    /** Creates a SHRFMLA record that consists of the passed cell address only. */
+    explicit            XclExpShrfmla( XclTokenArrayRef xTokArr, const ScAddress& rScPos );
+
+    /** Extends the cell range to include the passed cell address. */
+    void                ExtendRange( const ScAddress& rScPos );
+
+    /** Creates and returns the token array for a corresponding FORMULA cell record. */
+    virtual XclTokenArrayRef CreateCellTokenArray( const XclExpRoot& rRoot ) const;
+    /** Returns true, if the shared formula contains volatile functions. */
+    virtual bool        IsVolatile() const;
+
+private:
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    XclTokenArrayRef    mxTokArr;       /// The token array of a shared formula.
+    sal_uInt8           mnUsedCount;    /// Number of FORMULA records referring to this record.
+};
+
+typedef ScfRef< XclExpShrfmla > XclExpShrfmlaRef;
+
+// ----------------------------------------------------------------------------
+
+/** Caches all SHRFMLA records and provides functions to update their ranges. */
+class XclExpShrfmlaBuffer : protected XclExpRoot
+{
+public:
+    explicit            XclExpShrfmlaBuffer( const XclExpRoot& rRoot );
+
+    /** Tries to create a new or to update an existing SHRFMLA record.
+        @return  An empty reference, if the passed token array does not contain
+            a shared formula. If the token array is a shared formula, this
+            function updates its cell range to include the passed cell position,
+            if there is a SHRFMLA record for the passed token array; otherwise
+            this function creates and returns a new SHRFMLA record. */
+    XclExpShrfmlaRef    CreateOrExtendShrfmla(
+                            const ScTokenArray& rScTokArr, const ScAddress& rScPos );
+
+private:
+    typedef ::std::map< const ScTokenArray*, XclExpShrfmlaRef > XclExpShrfmlaMap;
+    XclExpShrfmlaMap    maRecMap;       /// Map containing the SHRFMLA records.
+};
+
+// Multiple operations ========================================================
+
+struct XclMultipleOpRefs;
+
+/** Represents a TABLEOP record for a multiple operations range. */
+class XclExpTableop : public XclExpRangeFmlaBase
+{
+public:
+    explicit            XclExpTableop( const ScAddress& rScPos,
+                            const XclMultipleOpRefs& rRefs, sal_uInt8 nScMode );
+
+    /** Returns true, if the cell range has been extended to the passed position.
+        @descr  All references passed in rRefs must fit the ranges passed in the constructor. */
+    bool                TryExtend( const ScAddress& rScPos, const XclMultipleOpRefs& rRefs );
+
+    /** Finalizes the record. Tests on valid cell range and reference addresses. */
+    void                Finalize();
+
+    /** Creates and returns the token array for a corresponding FORMULA cell record. */
+    virtual XclTokenArrayRef CreateCellTokenArray( const XclExpRoot& rRoot ) const;
+    /** Returns true, if the multiple operations range is volatile. */
+    virtual bool        IsVolatile() const;
+    /** Writes the record if it is valid. */
+    virtual void        Save( XclExpStream& rStrm );
+
+private:
+    /** Returns true, if the passed cell position can be appended to this record. */
+    bool IsAppendable( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const;
+
+    /** Writes the contents of the TABLEOP record. */
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    SCTAB               mnScTab;        /// Sheet index of this record.
+    sal_uInt16          mnLastAppXclCol;/// Column index of last appended cell.
+    sal_uInt16          mnColInpXclCol; /// Column index of column input cell.
+    sal_uInt32          mnColInpXclRow; /// Row index of column input cell.
+    sal_uInt16          mnRowInpXclCol; /// Column index of row input cell.
+    sal_uInt32          mnRowInpXclRow; /// Row index of row input cell.
+    sal_uInt8           mnScMode;       /// Type of the multiple operation (Calc constant).
+    bool                mbValid;        /// true = Contains valid references.
+};
+
+typedef ScfRef< XclExpTableop > XclExpTableopRef;
+
+// ----------------------------------------------------------------------------
+
+/** Contains all created TABLEOP records and supports creating or updating them. */
+class XclExpTableopBuffer : protected XclExpRoot
+{
+public:
+    explicit            XclExpTableopBuffer( const XclExpRoot& rRoot );
+
+    /** Tries to update an existing or to create a new TABLEOP record.
+        @return  Reference to the TABLEOP record for this cell (existing or new),
+            or an empty reference, if rScTokArr does not contain a multiple
+            operations formula. */
+    XclExpTableopRef    CreateOrExtendTableop(
+                            const ScTokenArray& rScTokArr, const ScAddress& rScPos );
+
+    /** Finalizes all contained TABLEOP records. */
+    void                Finalize();
+
+private:
+    /** Tries to create a new TABLEOP record, if rRefs contains valid references. */
+    XclExpTableopRef    TryCreate( const ScAddress& rScPos, const XclMultipleOpRefs& rRefs );
+
+private:
+    typedef XclExpRecordList< XclExpTableop > XclExpTableopList;
+    XclExpTableopList   maTableopList;  /// List of all TABLEOP records.
+};
+
+// ============================================================================
+// Cell records
+// ============================================================================
+
+/** The base class of all cell records. */
+class XclExpCellBase : public XclExpRecord
+{
+public:
+    /** Returns the (first) address of the cell(s). */
+    inline const XclAddress& GetXclPos() const { return maXclPos; }
+    /** Returns the (first) Excel column index of the cell(s). */
+    inline sal_uInt16   GetXclCol() const { return maXclPos.mnCol; }
+    /** Returns the Excel row index of the cell. */
+    inline sal_uInt32   GetXclRow() const { return maXclPos.mnRow; }
+
+    /** Derived classes return the column index of the last contained cell. */
+    virtual sal_uInt16  GetLastXclCol() const = 0;
+    /** Derived classes return the XF identifier of the first contained cell. */
+    virtual sal_uInt32  GetFirstXFId() const = 0;
+    /** Derived classes return true, if this record does not contain at least one valid cell. */
+    virtual bool        IsEmpty() const = 0;
+    /** Derived classes return whether the cell contains multi-line text. */
+    virtual bool        IsMultiLineText() const;
+
+    /** Derived classes try to merge the contents of the passed cell to own data. */
+    virtual bool        TryMerge( const XclExpCellBase& rCell );
+    /** Derived classes convert the XF identifier(s) into the Excel XF index(es).
+        @param rXFIndexes  The converted XF index(es) are inserted here. */
+    virtual void        ConvertXFIndexes( const XclExpRoot& rRoot ) = 0;
+    /** Derived classes for blank cells insert the Excel XF index(es) into the passed vector. */
+    virtual void        GetBlankXFIndexes( ScfUInt16Vec& rXFIndexes ) const;
+    /** Derived classes for blank cells remove unused Excel XF index(es). */
+    virtual void        RemoveUnusedBlankCells( const ScfUInt16Vec& rXFIndexes );
+
+protected:
+    explicit            XclExpCellBase(
+                            sal_uInt16 nRecId, sal_Size nContSize, const XclAddress& rXclPos );
+
+    /** Sets this record to a new column position. */
+    inline void         SetXclCol( sal_uInt16 nXclCol ) { maXclPos.mnCol = nXclCol; }
+    /** Sets this record to a new row position. */
+    inline void         SetXclRow( sal_uInt32 nXclRow ) { maXclPos.mnRow = nXclRow; }
+
+private:
+    XclAddress          maXclPos;       /// Address of the cell.
+};
+
+typedef ScfRef< XclExpCellBase > XclExpCellRef;
+
+// Single cell records ========================================================
+
+/** Base class for all cell records not supporting multiple contents. */
+class XclExpSingleCellBase : public XclExpCellBase
+{
+public:
+    /** Returns the last column, which is equal to the first column for single cells. */
+    virtual sal_uInt16  GetLastXclCol() const;
+    /** Return the XF identifier of the cell. */
+    virtual sal_uInt32  GetFirstXFId() const;
+    /** Returns true, if this record does not contain at least one valid cell. */
+    virtual bool        IsEmpty() const;
+    /** Converts the XF identifier into the Excel XF index. */
+    virtual void        ConvertXFIndexes( const XclExpRoot& rRoot );
+    /** Writes cell address, XF index, and calls WriteContents() for each cell. */
+    virtual void        Save( XclExpStream& rStrm );
+
+protected:
+    explicit            XclExpSingleCellBase( sal_uInt16 nRecId, sal_Size nContSize,
+                            const XclAddress& rXclPos, sal_uInt32 nXFId );
+
+    explicit            XclExpSingleCellBase( const XclExpRoot& rRoot,
+                            sal_uInt16 nRecId, sal_Size nContSize, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_Int16 nScript, sal_uInt32 nForcedXFId );
+
+    inline void         SetContSize( sal_Size nContSize ) { mnContSize = nContSize; }
+    inline sal_Size     GetContSize() const { return mnContSize; }
+
+    inline void         SetXFId( sal_uInt32 nXFId ) { maXFId.mnXFId = nXFId; }
+    inline sal_uInt32   GetXFId() const { return maXFId.mnXFId; }
+
+private:
+    /** Writes cell address, XF index, and calls WriteContents() for each cell. */
+    virtual void        WriteBody( XclExpStream& rStrm );
+    /** Derived classes write the contents of the specified cell (without XF index). */
+    virtual void        WriteContents( XclExpStream& rStrm ) = 0;
+
+private:
+    XclExpXFId          maXFId;         /// The XF identifier of the cell formatting.
+    sal_Size            mnContSize;     /// The size of the cell contents.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a NUMBER record that describes a cell with a double value. */
+class XclExpNumberCell : public XclExpSingleCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpNumberCell )
+
+public:
+    explicit            XclExpNumberCell( const XclExpRoot& rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            double fValue );
+
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+private:
+    virtual void        WriteContents( XclExpStream& rStrm );
+
+private:
+    double              mfValue;        /// The cell value.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a BOOLERR record that describes a cell with a Boolean value. */
+class XclExpBooleanCell : public XclExpSingleCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpBooleanCell )
+
+public:
+    explicit            XclExpBooleanCell( const XclExpRoot rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            bool bValue );
+
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+private:
+    virtual void        WriteContents( XclExpStream& rStrm );
+
+private:
+    bool                mbValue;        /// The cell value.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a BOOLERR record that describes a cell with an error code. */
+class XclExpErrorCell : public XclExpSingleCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpErrorCell )
+
+public:
+    explicit            XclExpErrorCell( const XclExpRoot rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            sal_uInt8 nErrCode );
+
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+private:
+    virtual void        WriteContents( XclExpStream& rStrm );
+
+private:
+    sal_uInt8           mnErrCode;      /// The error code.
+};
+
+// ----------------------------------------------------------------------------
+
+class ScStringCell;
+class ScEditCell;
+class XclExpHyperlinkHelper;
+
+/** Represents a text cell record.
+
+    May contain a BIFF2-BIFF7 LABEL record for a simple string, or a BIFF2-BIFF7
+    RSTRING record for a formatted string, or a BIFF8 LABELSST string for any
+    string (simply stores a reference to the Shared String Table).
+ */
+class XclExpLabelCell : public XclExpSingleCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpLabelCell )
+
+public:
+    /** Constructs the record from an unformatted Calc string cell. */
+    explicit            XclExpLabelCell( const XclExpRoot& rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            const ScStringCell& rCell );
+
+    /** Constructs the record from a formatted Calc edit cell. */
+    explicit            XclExpLabelCell( const XclExpRoot& rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            const ScEditCell& rCell, XclExpHyperlinkHelper& rHlinkHelper );
+
+    /** Returns true if the cell contains multi-line text. */
+    virtual bool        IsMultiLineText() const;
+
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+private:
+    /** Initializes the record contents. Called from constructors. */
+    void                Init( const XclExpRoot& rRoot,
+                            const ScPatternAttr* pPattern, XclExpStringRef xText );
+
+    virtual void        WriteContents( XclExpStream& rStrm );
+
+private:
+    XclExpStringRef     mxText;         /// The cell text.
+    sal_uInt32          mnSstIndex;     /// Index into Shared String Table (only used for BIFF8).
+    bool                mbLineBreak;    /// True = cell has automatic linebreaks enabled.
+};
+
+// ----------------------------------------------------------------------------
+
+class ScFormulaCell;
+
+/** Represents a FORMULA record that describes a cell with a formula. */
+class XclExpFormulaCell : public XclExpSingleCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpFormulaCell )
+
+public:
+    explicit            XclExpFormulaCell( const XclExpRoot& rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            const ScFormulaCell& rScFmlaCell,
+                            XclExpArrayBuffer& rArrayBfr,
+                            XclExpShrfmlaBuffer& rShrfmlaBfr,
+                            XclExpTableopBuffer& rTableopBfr );
+
+    /** Writes the FORMULA record and additional records related to the formula. */
+    virtual void        Save( XclExpStream& rStrm );
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+private:
+    virtual void        WriteContents( XclExpStream& rStrm );
+
+private:
+    ScFormulaCell&      mrScFmlaCell;   /// The Calc formula cell.
+    XclTokenArrayRef    mxTokArr;       /// The token array of the formula.
+    XclExpRangeFmlaRef  mxAddRec;       /// Additional record for matrix/shared formulas.
+    XclExpRecordRef     mxStringRec;    /// STRING record for string result.
+};
+
+// Multiple cell records ======================================================
+
+struct XclExpMultiXFId : public XclExpXFId
+{
+    sal_uInt16          mnCount;        /// Number of XF identifiers.
+
+    inline explicit     XclExpMultiXFId( sal_uInt32 nXFId, sal_uInt16 nCount = 1 ) :
+                            XclExpXFId( nXFId ), mnCount( nCount ) {}
+};
+
+// ----------------------------------------------------------------------------
+
+/** Base class for all cell records supporting multiple contents. */
+class XclExpMultiCellBase : public XclExpCellBase
+{
+public:
+    /** Returns the column index of the last cell this record describes. */
+    virtual sal_uInt16  GetLastXclCol() const;
+    /** Return the XF identifier of the first contained cell. */
+    virtual sal_uInt32  GetFirstXFId() const;
+    /** Returns true, if this record does not contain at least one valid cell. */
+    virtual bool        IsEmpty() const;
+
+    /** Convert all XF identifiers into the Excel XF indexes. */
+    virtual void        ConvertXFIndexes( const XclExpRoot& rRoot );
+    /** Writes the record, calls WriteContents() for each contained cell.
+        @descr  May write several records, if unused XF indexes are contained. */
+    virtual void        Save( XclExpStream& rStrm );
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+protected:
+    explicit            XclExpMultiCellBase( sal_uInt16 nRecId, sal_uInt16 nMulRecId,
+                            sal_Size nContSize, const XclAddress& rXclPos );
+
+    /** Sets the size of the remaining contents of one cell (without the XF index). */
+    inline void         SetContSize( sal_Size nContSize ) { mnContSize = nContSize; }
+    /** Returns the size of the remaining contents of one cell (without the XF index). */
+    inline sal_Size     GetContSize() const { return mnContSize; }
+
+    /** Returns the number of cells this record represents. */
+    sal_uInt16          GetCellCount() const;
+
+    /** Appends the passed XF identifier nCount times to the list of XF identifiers. */
+    void                AppendXFId( const XclExpMultiXFId& rXFId );
+    /** Appends the passed cell format nCount times to the list of XF identifiers. */
+    void                AppendXFId( const XclExpRoot& rRoot,
+                            const ScPatternAttr* pPattern, sal_uInt16 nScript,
+                            sal_uInt32 nForcedXFId, sal_uInt16 nCount = 1 );
+
+    /** Tries to merge the XF ID list of the passed cell with the own list. */
+    bool                TryMergeXFIds( const XclExpMultiCellBase& rCell );
+    /** Inserts the Excel XF index(es) into the passed vector. */
+    void                GetXFIndexes( ScfUInt16Vec& rXFIndexes ) const;
+
+    /** Removes unused Excel XF index(es).
+        @param rXFIndexes  Specifies which XF indexes are used. */
+    void                RemoveUnusedXFIndexes( const ScfUInt16Vec& rXFIndexes );
+
+private:
+    /** Derived classes write the remaining contents of the specified cell (without XF index).
+        @param nRelCol  Relative column index (starts with 0 for first cell of this record). */
+    virtual void        WriteContents( XclExpStream& rStrm, sal_uInt16 nRelCol ) = 0;
+    virtual void        WriteXmlContents( XclExpXmlStream& rStrm, const XclAddress& rAddress, sal_uInt32 nXFId, sal_uInt16 nRelCol ) = 0;
+
+private:
+    typedef ::std::deque< XclExpMultiXFId > XclExpMultiXFIdDeq;
+
+    sal_uInt16          mnMulRecId;     /// Record ID for multiple record variant.
+    sal_Size            mnContSize;     /// Data size of contents for one cell
+    XclExpMultiXFIdDeq  maXFIds;        /// The XF identifiers of the cell formatting.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a BLANK or MULBLANK record that describes empty but formatted cells. */
+class XclExpBlankCell : public XclExpMultiCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpBlankCell )
+
+public:
+    explicit            XclExpBlankCell( const XclAddress& rXclPos, const XclExpMultiXFId& rXFId );
+
+    explicit            XclExpBlankCell( const XclExpRoot& rRoot,
+                            const XclAddress& rXclPos, sal_uInt16 nLastXclCol,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId );
+
+    /** Tries to merge the contents of the passed cell to own data. */
+    virtual bool        TryMerge( const XclExpCellBase& rCell );
+    /** Inserts the Excel XF index(es) into the passed vector. */
+    virtual void        GetBlankXFIndexes( ScfUInt16Vec& rXFIndexes ) const;
+    /** Tries to remove unused Excel XF index(es). */
+    virtual void        RemoveUnusedBlankCells( const ScfUInt16Vec& rXFIndexes );
+
+private:
+    /** Writes the remaining contents of the specified cell (without XF index). */
+    virtual void        WriteContents( XclExpStream& rStrm, sal_uInt16 nRelCol );
+    virtual void        WriteXmlContents( XclExpXmlStream& rStrm, const XclAddress& rAddress, sal_uInt32 nXFId, sal_uInt16 nRelCol );
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents an RK or MULRK record that describes cells with a compressed double values. */
+class XclExpRkCell : public XclExpMultiCellBase
+{
+    DECL_FIXEDMEMPOOL_NEWDEL( XclExpRkCell )
+
+public:
+    explicit            XclExpRkCell( const XclExpRoot& rRoot, const XclAddress& rXclPos,
+                            const ScPatternAttr* pPattern, sal_uInt32 nForcedXFId,
+                            sal_Int32 nRkValue );
+
+    /** Tries to merge the contents of the passed cell to own data. */
+    virtual bool        TryMerge( const XclExpCellBase& rCell );
+
+private:
+    /** Writes the remaining contents of the specified cell (without XF index). */
+    virtual void        WriteContents( XclExpStream& rStrm, sal_uInt16 nRelCol );
+    virtual void        WriteXmlContents( XclExpXmlStream& rStrm, const XclAddress& rAddress, sal_uInt32 nXFId, sal_uInt16 nRelCol );
+
+private:
+    ScfInt32Vec         maRkValues;     /// The cell values.
+};
+
+// ============================================================================
+// Rows and Columns
+// ============================================================================
+
+class ScOutlineArray;
+
+/** Base class for buffers containing row or column outline data. */
+class XclExpOutlineBuffer
+{
+public:
+    /** Returns true, if a collapsed group ends at the last processed position. */
+    inline bool         IsCollapsed() const { return mbCurrCollapse; }
+    /** Returns the highest level of an open group at the last processed position. */
+    inline sal_uInt8    GetLevel() const { return ::std::min( mnCurrLevel, EXC_OUTLINE_MAX ); }
+
+protected:
+    /** Constructs the outline buffer.
+        @param bRows  true = Process row ouline array; false = Process column outline array. */
+    explicit            XclExpOutlineBuffer( const XclExpRoot& rRoot, bool bRows );
+
+    /** Updates the current state by processing the settings at the passed Calc position. */
+    void                UpdateColRow( SCCOLROW nScPos );
+
+private:
+    /** Data about an outline level. */
+    struct XclExpLevelInfo
+    {
+        SCCOLROW            mnScEndPos;         /// The end position of a group in a level.
+        bool                mbHidden;           /// true = Group in this level is hidden.
+        inline explicit     XclExpLevelInfo() : mnScEndPos( 0 ), mbHidden( false ) {}
+    };
+    typedef ::std::vector< XclExpLevelInfo > XclExpLevelInfoVec;
+
+    const ScOutlineArray* mpScOLArray;      /// Pointer to Calc outline array.
+    XclExpLevelInfoVec  maLevelInfos;       /// Info for current row and all levels.
+    sal_uInt8           mnCurrLevel;        /// Highest level of an open group for current position.
+    bool                mbCurrCollapse;     /// true = Collapsed group ends at current position.
+};
+
+// ----------------------------------------------------------------------------
+
+/** The outline buffer for column outlines. */
+class XclExpColOutlineBuffer : public XclExpOutlineBuffer
+{
+public:
+    inline explicit     XclExpColOutlineBuffer( const XclExpRoot& rRoot ) :
+                            XclExpOutlineBuffer( rRoot, false ) {}
+
+    /** Updates the current state by processing the settings of the passed Calc column. */
+    inline void         Update( SCCOL nScCol )
+                            { UpdateColRow( static_cast< SCCOLROW >( nScCol ) ); }
+};
+
+// ----------------------------------------------------------------------------
+
+/** The outline buffer for row outlines. */
+class XclExpRowOutlineBuffer : public XclExpOutlineBuffer
+{
+public:
+    inline explicit     XclExpRowOutlineBuffer( const XclExpRoot& rRoot ) :
+                            XclExpOutlineBuffer( rRoot, true ) {}
+
+    /** Updates the current state by processing the settings of the passed Calc row. */
+    inline void         Update( SCROW nScRow )
+                            { UpdateColRow( static_cast< SCCOLROW >( nScRow ) ); }
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a GUTS record containing the level count of row and column outlines. */
+class XclExpGuts : public XclExpRecord
+{
+public:
+    explicit            XclExpGuts( const XclExpRoot& rRoot );
+
+private:
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    sal_uInt16          mnColLevels;    /// Number of visible column outline levels.
+    sal_uInt16          mnColWidth;     /// Width of column outline area (pixels).
+    sal_uInt16          mnRowLevels;    /// Number of visible row outline levels.
+    sal_uInt16          mnRowWidth;     /// Width of row outline area (pixels).
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a DIMENSIONS record containing the used area of a sheet. */
+class XclExpDimensions : public XclExpRecord
+{
+public:
+    explicit            XclExpDimensions( const XclExpRoot& rRoot );
+
+    /** Sets the used area to the record. */
+    void                SetDimensions(
+                            sal_uInt16 nFirstUsedXclCol, sal_uInt32 nFirstUsedXclRow,
+                            sal_uInt16 nFirstFreeXclCol, sal_uInt32 nFirstFreeXclRow );
+
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+private:
+    /** Writes the contents of the DIMENSIONS record. */
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    sal_uInt32          mnFirstUsedXclRow;  /// First used row.
+    sal_uInt32          mnFirstFreeXclRow;  /// First unused row after used area.
+    sal_uInt16          mnFirstUsedXclCol;  /// First used column.
+    sal_uInt16          mnFirstFreeXclCol;  /// First free column after used area.
+};
+
+// ============================================================================
+
+/** Represents the DEFCOLWIDTH record containing the default column width of a sheet.
+
+    Excel stores the default column width in entire character widths of the '0'
+    character using the application default font (i.e. the default width is 10,
+    if the '0' character fits 10 times into a cell in a column with default
+    width.
+
+    The IsDefWidth() function returns true, if the passed width (measured in
+    1/256 of the width of the '0' character) could be converted exactly to the
+    default width. If the passed width is rounded up or down to get the default
+    width, the function returns false.
+ */
+class XclExpDefcolwidth : public XclExpUInt16Record, protected XclExpRoot
+{
+public:
+    explicit            XclExpDefcolwidth( const XclExpRoot& rRoot );
+
+    /** Returns true, if the own default width exactly matches the passed width. */
+    bool                IsDefWidth( sal_uInt16 nXclColWidth ) const;
+
+    /** Sets the passed column width (in 1/256 character width) as default width. */
+    void                SetDefWidth( sal_uInt16 nXclColWidth );
+};
+
+// ----------------------------------------------------------------------------
+
+/** Contains the column settings for a range of columns.
+
+    After construction the record contains a temporary XF identifier returned
+    from the XF buffer. After creating the entire Excel document in memory, the
+    ConvertXFIndexes() function converts it into the real Excel XF index.
+ */
+class XclExpColinfo : public XclExpRecord, protected XclExpRoot
+{
+public:
+    /** Constructs the record with the settings in the Calc document. */
+    explicit            XclExpColinfo( const XclExpRoot& rRoot,
+                            SCCOL nScCol, SCROW nLastScRow,
+                            XclExpColOutlineBuffer& rOutlineBfr );
+
+    /** Converts the XF identifier into the Excel XF index, returns the latter. */
+    sal_uInt16          ConvertXFIndexes();
+
+    /** Tries to merge this record with the passed record.
+        @descr  Possible, if passed record directly follows this record and has equal contents.
+        @return  true = This record is equal to passed record and has been updated. */
+    bool                TryMerge( const XclExpColinfo& rColInfo );
+
+    /** Returns the Excel width of the column(s). */
+    inline sal_uInt16   GetColWidth() const { return mnWidth; }
+    /** Returns the final Excel XF index of the column(s). */
+    inline sal_uInt16   GetXFIndex() const { return maXFId.mnXFIndex; }
+    /** Returns the number of columns represented by this record. */
+    inline sal_uInt16   GetColCount() const { return mnLastXclCol - mnFirstXclCol + 1; }
+
+    /** Returns true, if the column has default format and width. */
+    bool                IsDefault( const XclExpDefcolwidth& rDefColWidth ) const;
+
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+private:
+    /** Writes the contents of this COLINFO record. */
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    XclExpXFId          maXFId;             /// The XF identifier for column default format.
+    sal_uInt16          mnWidth;            /// Excel width of the column.
+    sal_uInt16          mnFlags;            /// Additional column flags.
+    sal_uInt16          mnFirstXclCol;      /// Index to first column.
+    sal_uInt16          mnLastXclCol;       /// Index to last column.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Contains COLINFO records for all columns of a Calc sheet.
+
+    On construction one COLINFO record per column is created. After creating
+    the entire Excel document in memory, the ConvertXFIndexes() function converts
+    all temporary XF identifiers into real Excel XF indexes and merges all equal
+    COLINFO records together.
+ */
+class XclExpColinfoBuffer : public XclExpRecordBase, protected XclExpRoot
+{
+public:
+    explicit            XclExpColinfoBuffer( const XclExpRoot& rRoot );
+
+    /** Initializes the buffer: finds settings and formatting of all columns.
+        @param nLastScRow  Last row used to find default formatting. */
+    void                Initialize( SCROW nLastScRow );
+    /** Converts the XF identifiers into the Excel XF indexes and merges equal columns.
+        @param rXFIndexes  Returns the final XF indexes of all columns. */
+    void                Finalize( ScfUInt16Vec& rXFIndexes );
+
+    /** Writes all COLINFO records of this buffer. */
+    virtual void        Save( XclExpStream& rStrm );
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+private:
+    typedef XclExpRecordList< XclExpColinfo >   XclExpColinfoList;
+    typedef XclExpColinfoList::RecordRefType    XclExpColinfoRef;
+
+    XclExpColinfoList   maColInfos;         /// List of COLINFO records.
+    XclExpDefcolwidth   maDefcolwidth;      /// The DEFCOLWIDTH record.
+    XclExpColOutlineBuffer maOutlineBfr;    /// Buffer for column outline groups.
+};
+
+// ============================================================================
+
+class XclExpRow;
+
+/** Contains all possible default row settings. */
+struct XclExpDefaultRowData
+{
+    sal_uInt16          mnFlags;            /// Default flags for unspecified rows.
+    sal_uInt16          mnHeight;           /// Default height for unspecified rows.
+
+    explicit            XclExpDefaultRowData();
+    explicit            XclExpDefaultRowData( const XclExpRow& rRow );
+
+    /** Returns true, if rows are hidden by default. */
+    inline bool         IsHidden() const { return ::get_flag( mnFlags, EXC_DEFROW_HIDDEN ); }
+    /** Returns true, if the rows have a manually set height by default. */
+    inline bool         IsUnsynced() const { return ::get_flag( mnFlags, EXC_DEFROW_UNSYNCED ); }
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a DEFROWHEIGHT record containing default format for unused rows. */
+class XclExpDefrowheight : public XclExpRecord
+{
+public:
+    explicit            XclExpDefrowheight();
+
+    /** Sets the passed default data as current record contents. */
+    void                SetDefaultData( const XclExpDefaultRowData& rDefData );
+
+private:
+    /** Writes the contents of the record. */
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    XclExpDefaultRowData maDefData;         /// Record data.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Represents a ROW record and additionally contains all cells records of a row.
+
+    This class contains all cell records of a row in a spreadsheet. There are 2
+    cell records in Excel that support storing a range of cells in one record
+    (MULBLANK for multiple blank cells, and MULRK for multiple RK values). The
+    insertion functions try to merge a new inserted cell with existing
+    neighbors, if this is supported by the current type of cell record.
+
+    The Finalize() function converts the XF identifiers of all cell records to
+    the final Excel XF indexes. Then a default
+ */
+class XclExpRow : public XclExpRecord, protected XclExpRoot
+{
+public:
+    /** Constructs the ROW record and converts the Calc row settings.
+        @param bAlwaysEmpty  true = This row will not be filled with blank cells
+            in the Finalize() function. */
+    explicit XclExpRow( const XclExpRoot& rRoot, sal_uInt32 nXclRow,
+                        XclExpRowOutlineBuffer& rOutlineBfr, bool bAlwaysEmpty );
+
+    /** Returns the excel row index of this ROW record. */
+    inline sal_uInt32   GetXclRow() const { return mnXclRow; }
+    /** Returns the height of the row in twips. */
+    inline sal_uInt16   GetHeight() const { return mnHeight; }
+    /** Returns true, if this row does not contain at least one valid cell. */
+    inline bool         IsEmpty() const { return maCellList.IsEmpty(); }
+    /** Returns true, if this row is hidden. */
+    inline bool         IsHidden() const { return ::get_flag( mnFlags, EXC_ROW_HIDDEN ); }
+    /** Returns true, if this row contains a manually set height. */
+    inline bool         IsUnsynced() const { return ::get_flag( mnFlags, EXC_ROW_UNSYNCED ); }
+    /** Returns true, if this row is enabled (will be exported). */
+    inline bool         IsEnabled() const { return mbEnabled; }
+
+    /** Appends the passed cell object to this row. */
+    void                AppendCell( XclExpCellRef xCell, bool bIsMergedBase );
+
+    /** Converts all XF identifiers into the Excel XF indexes. */
+    void                Finalize( const ScfUInt16Vec& rColXFIndexes );
+
+    /** Returns the column index of the first used cell in this row.
+        @descr  This function can only be called after Finalize(). */
+    sal_uInt16          GetFirstUsedXclCol() const;
+    /** Returns the column index of the first unused cell following all used cells in this row.
+        @descr  This function can only be called after Finalize(). */
+    sal_uInt16          GetFirstFreeXclCol() const;
+
+    /** Returns true, if this row may be omitted by using the DEFROWHEIGHT record.
+        @descr  A row may be omitted, if it does not contain any cell or
+        explicit default cell formatting, and is not part of an outline.
+        This function can only be called after Finalize(). */
+    bool                IsDefaultable() const;
+    /** Disables this row, if it is defaultable and has the passed default format.
+        @descr  Disabled rows will not be saved.
+            This function can only be called after Finalize(). */
+    void                DisableIfDefault( const XclExpDefaultRowData& rDefRowData );
+
+    /** Writes all cell records of this row. */
+    void                WriteCellList( XclExpStream& rStrm );
+
+    /** Writes the ROW record if the row is not disabled (see DisableIfDefault() function). */
+    virtual void        Save( XclExpStream& rStrm );
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+private:
+    /** Initializes the record data. Called from constructors. */
+    void                Init( sal_uInt32 nXclRow, XclExpRowOutlineBuffer* pOutlineBfr );
+    /** Inserts a cell at the specified list position, tries to merge with neighbors. */
+    void                InsertCell( XclExpCellRef xCell, size_t nPos, bool bIsMergedBase );
+
+    /** Writes the contents of the ROW record. */
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    typedef XclExpRecordList< XclExpCellBase > XclExpCellList;
+
+    XclExpCellList      maCellList;         /// List of cell records for this row.
+    sal_uInt32          mnXclRow;           /// Excel row index of this row.
+    sal_uInt16          mnHeight;           /// Row height in twips.
+    sal_uInt16          mnFlags;            /// Flags for the ROW record.
+    sal_uInt16          mnXFIndex;          /// Default row formatting.
+    sal_uInt16          mnOutlineLevel;     /// Outline Level (for OOXML)
+    bool                mbAlwaysEmpty;      /// true = Do not add blank cells in Finalize().
+    bool                mbEnabled;          /// true = Write this ROW record.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Collects all rows which contain all cells of a sheet.
+
+    This row buffer automatically creates ROW records when cells are inserted
+    with the AppendCell() function. It is possible to force creation of more
+    ROW records with the CreateRows() function. In both cases, all preceding
+    missing ROW records are inserted too.
+ */
+class XclExpRowBuffer : public XclExpRecordBase, protected XclExpRoot
+{
+public:
+    explicit            XclExpRowBuffer( const XclExpRoot& rRoot );
+
+    /** Appends the passed cell object to the row that the cell specifies. */
+    void                AppendCell( XclExpCellRef xCell, bool bIsMergedBase );
+    /** Forces insertion of all ROW records before the passed row. */
+    void                CreateRows( SCROW nFirstFreeScRow );
+
+    /** Converts all XF identifiers into the Excel XF indexes and calculates default formats.
+        @param rDefRowData  (out-param) The default row format is returned here.
+        @param rColXFIndexes  The column default XF indexes. */
+    void                Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt16Vec& rColXFIndexes );
+
+    /** Writes the DIMENSIONS record, all ROW records and all cell records. */
+    virtual void        Save( XclExpStream& rStrm );
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+    XclExpDimensions*   GetDimensions();
+
+private:
+    /** Returns access to the specified ROW record. Inserts preceding missing ROW records.
+        @param bRowAlwaysEmpty  true = Created rows will not be filled with blank cells
+            in the XclExpRow::Finalize() function. */
+    XclExpRow& GetOrCreateRow( sal_uInt32 nXclRow, bool bRowAlwaysEmpty );
+
+private:
+    typedef XclExpRecordList< XclExpRow >   XclExpRowList;
+    typedef XclExpRowList::RecordRefType    XclExpRowRef;
+
+    XclExpRowList       maRowList;          /// List of all ROW records.
+    XclExpRowOutlineBuffer maOutlineBfr;    /// Buffer for row outline groups.
+    XclExpDimensions    maDimensions;       /// DIMENSIONS record for used area.
+    XclExpRow*          mpLastUsedRow;      /// Last used row for faster access.
+    sal_uInt32          mnLastUsedXclRow;   /// Last used row for faster access.
+};
+
+// ============================================================================
+// Cell Table
+// ============================================================================
+
+class XclExpNote;
+class XclExpMergedcells;
+class XclExpHyperlink;
+class XclExpDval;
+
+/** This class contains the cell contents and more of an entire sheet.
+
+    The cell table includes the settings and default formatting of all columns,
+    the settings and default formatting of all used rows, and the contents of
+    all cells of one sheet in a spreadsheet document.
+
+    The constructor does all the work creating the cell table. It reads the
+    Calc sheet and converts all columns, rows, and cells to Excel record data.
+    Additioanlly, hyperlink records, note records, additional records for
+    formula cells, data validation records, and outline records are created.
+
+    The Finalize() function does even more work. It calculates default column
+    settings and removes column records that are equal to this default. The
+    same happens with rows: A default format is calculated for each row, and
+    all blank cells in this row that have the same format are removed. Then,
+    the most used row settings are calculated, and all empty rows that have the
+    same settings are removed too.
+
+    Records that are not stored inside the cell table area in an Excel file
+    (i.e. DEFROWHEIGHT record, NOTE records, MERGEDCELLS record, HLINK records,
+    DVAL and DV records for data validation) can be accessed with the function
+    CreateRecord(). It returns the reference to the respective record (or
+    record list) which can be inserted into a record list.
+ */
+class XclExpCellTable : public XclExpRecordBase, protected XclExpRoot
+{
+public:
+    explicit            XclExpCellTable( const XclExpRoot& rRoot );
+
+    /** Converts all XF identifiers into the Excel XF indexes and calculates default formats. */
+    void                Finalize();
+
+    /** Returns the reference to an internal record specified by the passed record id.
+        @param nRecId  The record identifier that specifies which record is
+            returned. Possible values are: EXC_ID_DEFROWHEIGHT, EXC_ID_NOTE,
+            EXC_ID_MERGEDCELLS, EXC_ID_HLINK, EXC_ID_DVAL. */
+    XclExpRecordRef     CreateRecord( sal_uInt16 nRecId ) const;
+    /** Saves the entire cell table. */
+    virtual void        Save( XclExpStream& rStrm );
+    virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+private:
+    typedef XclExpRecordList< XclExpNote >      XclExpNoteList;
+    typedef XclExpRecordList< XclExpHyperlink > XclExpHyperlinkList;
+
+    typedef ScfRef< XclExpDefrowheight >        XclExpDefrowhRef;
+    typedef ScfRef< XclExpNoteList >            XclExpNoteListRef;
+    typedef ScfRef< XclExpMergedcells >         XclExpMergedcellsRef;
+    typedef ScfRef< XclExpHyperlinkList >       XclExpHyperlinkRef;
+    typedef ScfRef< XclExpDval >                XclExpDvalRef;
+
+    XclExpColinfoBuffer maColInfoBfr;       /// Buffer for column formatting.
+    XclExpRowBuffer     maRowBfr;           /// Rows and cell records.
+    XclExpArrayBuffer   maArrayBfr;         /// Buffer for ARRAY records.
+    XclExpShrfmlaBuffer maShrfmlaBfr;       /// Buffer for SHRFMLA records.
+    XclExpTableopBuffer maTableopBfr;       /// Buffer for TABLEOP records.
+    XclExpDefrowhRef    mxDefrowheight;     /// DEFROWHEIGHT record for default row format.
+    XclExpRecordRef     mxGuts;             /// GUTS record for outline areas.
+    XclExpNoteListRef   mxNoteList;         /// List of NOTE records.
+    XclExpMergedcellsRef mxMergedcells;     /// MERGEDCELLS record for merged cell ranges.
+    XclExpHyperlinkRef  mxHyperlinkList;    /// List of HLINK records.
+    XclExpDvalRef       mxDval;             /// Data validation with DVAL and DV records.
+};
+
+#endif
+
diff --git sc/source/filter/inc/xlsx/xladdress.hxx sc/source/filter/inc/xlsx/xladdress.hxx
new file mode 100644
index 0000000..79ccc28
--- /dev/null
+++ sc/source/filter/inc/xlsx/xladdress.hxx
@@ -0,0 +1,200 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xladdress.hxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLADDRESS_HXX
+#define SC_XLADDRESS_HXX
+
+#include <vector>
+#include "address.hxx"
+
+class ScRangeList;
+class XclImpStream;
+class XclExpStream;
+
+// ============================================================================
+
+/** A 2D cell address struct with Excel column and row indexes. */
+struct XclAddress
+{
+    sal_uInt16          mnCol;
+    sal_uInt32          mnRow;
+
+    inline explicit     XclAddress( ScAddress::Uninitialized ) {}
+    inline explicit     XclAddress() : mnCol( 0 ), mnRow( 0 ) {}
+    inline explicit     XclAddress( sal_uInt16 nCol, sal_uInt32 nRow ) : mnCol( nCol ), mnRow( nRow ) {}
+
+    inline void         Set( sal_uInt16 nCol, sal_uInt32 nRow ) { mnCol = nCol; mnRow = nRow; }
+
+    void                Read( XclImpStream& rStrm, bool bCol16Bit = true );
+    void                Write( XclExpStream& rStrm, bool bCol16Bit = true ) const;
+};
+
+inline bool operator==( const XclAddress& rL, const XclAddress& rR )
+{
+    return (rL.mnCol == rR.mnCol) && (rL.mnRow == rR.mnRow);
+}
+
+inline bool operator<( const XclAddress& rL, const XclAddress& rR )
+{
+    return (rL.mnCol < rR.mnCol) || ((rL.mnCol == rR.mnCol) && (rL.mnRow < rR.mnRow));
+}
+
+inline XclImpStream& operator>>( XclImpStream& rStrm, XclAddress& rXclPos )
+{
+    rXclPos.Read( rStrm );
+    return rStrm;
+}
+
+inline XclExpStream& operator<<( XclExpStream& rStrm, const XclAddress& rXclPos )
+{
+    rXclPos.Write( rStrm );
+    return rStrm;
+}
+
+// ----------------------------------------------------------------------------
+
+/** A 2D cell range address struct with Excel column and row indexes. */
+struct XclRange
+{
+    XclAddress          maFirst;
+    XclAddress          maLast;
+
+    inline explicit     XclRange( ScAddress::Uninitialized e ) : maFirst( e ), maLast( e ) {}
+    inline explicit     XclRange() {}
+    inline explicit     XclRange( const XclAddress& rPos ) : maFirst( rPos ), maLast( rPos ) {}
+    inline explicit     XclRange( const XclAddress& rFirst, const XclAddress& rLast ) : maFirst( rFirst ), maLast( rLast ) {}
+    inline explicit     XclRange( sal_uInt16 nCol1, sal_uInt32 nRow1, sal_uInt16 nCol2, sal_uInt32 nRow2 ) :
+                            maFirst( nCol1, nRow1 ), maLast( nCol2, nRow2 ) {}
+
+    inline void         Set( const XclAddress& rFirst, const XclAddress& rLast )
+                            { maFirst = rFirst; maLast = rLast; }
+    inline void         Set( sal_uInt16 nCol1, sal_uInt32 nRow1, sal_uInt16 nCol2, sal_uInt32 nRow2 )
+                            { maFirst.Set( nCol1, nRow1 ); maLast.Set( nCol2, nRow2 ); }
+
+    inline sal_uInt16   GetColCount() const { return maLast.mnCol - maFirst.mnCol + 1; }
+    inline sal_uInt32   GetRowCount() const { return maLast.mnRow - maFirst.mnRow + 1; }
+    bool                Contains( const XclAddress& rPos ) const;
+
+    void                Read( XclImpStream& rStrm, bool bCol16Bit = true );
+    void                Write( XclExpStream& rStrm, bool bCol16Bit = true ) const;
+};
+
+inline bool operator==( const XclRange& rL, const XclRange& rR )
+{
+    return (rL.maFirst == rR.maFirst) && (rL.maLast == rR.maLast);
+}
+
+inline bool operator<( const XclRange& rL, const XclRange& rR )
+{
+    return (rL.maFirst < rR.maFirst) || ((rL.maFirst == rR.maFirst) && (rL.maLast < rR.maLast));
+}
+
+inline XclImpStream& operator>>( XclImpStream& rStrm, XclRange& rXclRange )
+{
+    rXclRange.Read( rStrm );
+    return rStrm;
+}
+
+inline XclExpStream& operator<<( XclExpStream& rStrm, const XclRange& rXclRange )
+{
+    rXclRange.Write( rStrm );
+    return rStrm;
+}
+
+// ----------------------------------------------------------------------------
+
+/** A 2D cell range address list with Excel column and row indexes. */
+class XclRangeList : public ::std::vector< XclRange >
+{
+public:
+    inline explicit     XclRangeList() {}
+
+    XclRange            GetEnclosingRange() const;
+
+    void                Read( XclImpStream& rStrm, bool bCol16Bit = true );
+    void                Write( XclExpStream& rStrm, bool bCol16Bit = true ) const;
+    void                WriteSubList( XclExpStream& rStrm,
+                            size_t nBegin, size_t nCount, bool bCol16Bit = true ) const;
+};
+
+inline XclImpStream& operator>>( XclImpStream& rStrm, XclRangeList& rXclRanges )
+{
+    rXclRanges.Read( rStrm );
+    return rStrm;
+}
+
+inline XclExpStream& operator<<( XclExpStream& rStrm, const XclRangeList& rXclRanges )
+{
+    rXclRanges.Write( rStrm );
+    return rStrm;
+}
+
+// ============================================================================
+
+class XclTracer;
+
+/** Base class for import/export address converters. */
+class XclAddressConverterBase
+{
+public:
+    explicit            XclAddressConverterBase( XclTracer& rTracer, const ScAddress& rMaxPos );
+    virtual             ~XclAddressConverterBase();
+
+    /** Returns whether the "some columns have been cut" warning box should be shown. */
+    inline bool         IsColTruncated() const { return mbColTrunc; }
+    /** Returns whether the "some rows have been cut" warning box should be shown. */
+    inline bool         IsRowTruncated() const { return mbRowTrunc; }
+    /** Returns whether the "some sheets have been cut" warning box should be shown. */
+    inline bool         IsTabTruncated() const { return mbTabTrunc; }
+
+    // ------------------------------------------------------------------------
+
+    /** Checks if the passed sheet index is valid.
+        @param nScTab  The sheet index to check.
+        @param bWarn  true = Sets the internal flag that produces a warning box
+            after loading/saving the file, if the sheet index is not valid.
+        @return  true = Sheet index in nScTab is valid. */
+    bool                CheckScTab( SCTAB nScTab, bool bWarn );
+
+    // ------------------------------------------------------------------------
+protected:
+    XclTracer&          mrTracer;       /// Tracer for invalid addresses.
+    ScAddress           maMaxPos;       /// Default maximum position.
+    sal_uInt16          mnMaxCol;       /// Maximum column index, as 16-bit value.
+    sal_uInt32          mnMaxRow;       /// Maximum row index
+    bool                mbColTrunc;     /// Flag for "columns truncated" warning box.
+    bool                mbRowTrunc;     /// Flag for "rows truncated" warning box.
+    bool                mbTabTrunc;     /// Flag for "tables truncated" warning box.
+};
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/inc/xlsx/xlconst.hxx sc/source/filter/inc/xlsx/xlconst.hxx
new file mode 100644
index 0000000..bec17d3
--- /dev/null
+++ sc/source/filter/inc/xlsx/xlconst.hxx
@@ -0,0 +1,236 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlconst.hxx,v $
+ * $Revision: 1.29 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLCONST_HXX
+#define SC_XLCONST_HXX
+
+#include "address.hxx"
+
+// Common =====================================================================
+
+// BIFF versions --------------------------------------------------------------
+
+/** An enumeration for all Excel file format types (BIFF types). */
+enum XclBiff
+{
+    EXC_BIFF2 = 0,              /// MS Excel 2.1
+    EXC_BIFF3,                  /// MS Excel 3.0
+    EXC_BIFF4,                  /// MS Excel 4.0
+    EXC_BIFF5,                  /// MS Excel 5.0, MS Excel 7.0 (95)
+    EXC_BIFF8,                  /// MS Excel 8.0 (97), 9.0 (2000), 10.0 (XP), 11.0 (2003)
+    EXC_BIFF_UNKNOWN            /// Unknown BIFF version.
+};
+
+/** An enumeration for all Excel output format types. */
+enum XclOutput
+{
+    EXC_OUTPUT_BINARY,          /// MS Excel binary .xls
+    EXC_OUTPUT_XML_2007,        /// MS Excel 2007 .xlsx
+};
+
+// Excel sheet dimensions -----------------------------------------------------
+
+const SCCOL EXC_MAXCOL2                     = 255;
+const SCROW EXC_MAXROW2                     = 16383;
+const SCTAB EXC_MAXTAB2                     = 0;
+
+const SCCOL EXC_MAXCOL3                     = EXC_MAXCOL2;
+const SCROW EXC_MAXROW3                     = EXC_MAXROW2;
+const SCTAB EXC_MAXTAB3                     = EXC_MAXTAB2;
+
+const SCCOL EXC_MAXCOL4                     = EXC_MAXCOL3;
+const SCROW EXC_MAXROW4                     = EXC_MAXROW3;
+const SCTAB EXC_MAXTAB4                     = 32767;
+
+const SCCOL EXC_MAXCOL5                     = EXC_MAXCOL4;
+const SCROW EXC_MAXROW5                     = EXC_MAXROW4;
+const SCTAB EXC_MAXTAB5                     = EXC_MAXTAB4;
+
+const SCCOL EXC_MAXCOL8                     = EXC_MAXCOL5;
+const SCROW EXC_MAXROW8                     = MAXROWCOUNT_DEFINE;
+const SCTAB EXC_MAXTAB8                     = EXC_MAXTAB5;
+
+const sal_uInt16 EXC_NOTAB                  = SAL_MAX_UINT16;   /// An invalid Excel sheet index, for common use.
+const SCTAB SCTAB_INVALID                   = SCTAB_MAX;        /// An invalid Calc sheet index, for common use.
+const SCTAB SCTAB_GLOBAL                    = SCTAB_MAX;        /// A Calc sheet index for the workbook globals.
+
+// Storage/stream names -------------------------------------------------------
+
+#define EXC_STORAGE_OLE_LINKED              CREATE_STRING( "LNK" )
+#define EXC_STORAGE_OLE_EMBEDDED            CREATE_STRING( "MBD" )
+#define EXC_STORAGE_VBA_PROJECT             CREATE_STRING( "_VBA_PROJECT_CUR" )
+#define EXC_STORAGE_VBA                     CREATE_STRING( "VBA" )
+
+#define EXC_STREAM_BOOK                     CREATE_STRING( "Book" )
+#define EXC_STREAM_WORKBOOK                 CREATE_STRING( "Workbook" )
+#define EXC_STREAM_CTLS                     CREATE_STRING( "Ctls" )
+
+// Encoded URLs ---------------------------------------------------------------
+
+const sal_Unicode EXC_URLSTART_ENCODED      = '\x01';   /// Encoded URL.
+const sal_Unicode EXC_URLSTART_SELF         = '\x02';   /// Reference to own workbook.
+const sal_Unicode EXC_URLSTART_SELFENCODED  = '\x03';   /// Encoded self reference.
+const sal_Unicode EXC_URLSTART_OWNDOC       = '\x04';   /// Reference to own workbook (BIFF5/BIFF7).
+
+const sal_Unicode EXC_URL_DOSDRIVE          = '\x01';   /// DOS drive letter or UNC server name.
+const sal_Unicode EXC_URL_DRIVEROOT         = '\x02';   /// Root directory of current drive.
+const sal_Unicode EXC_URL_SUBDIR            = '\x03';   /// Directory name delimiter.
+const sal_Unicode EXC_URL_PARENTDIR         = '\x04';   /// Parent directory.
+const sal_Unicode EXC_URL_RAW               = '\x05';   /// Unencoded URL.
+const sal_Unicode EXC_URL_SHEETNAME         = '\x09';   /// Sheet name starts here (BIFF4).
+
+const sal_Unicode EXC_DDE_DELIM             = '\x03';   /// DDE application-topic delimiter
+
+// Error codes ----------------------------------------------------------------
+
+const sal_uInt8 EXC_ERR_NULL                = 0x00;
+const sal_uInt8 EXC_ERR_DIV0                = 0x07;
+const sal_uInt8 EXC_ERR_VALUE               = 0x0F;
+const sal_uInt8 EXC_ERR_REF                 = 0x17;
+const sal_uInt8 EXC_ERR_NAME                = 0x1D;
+const sal_uInt8 EXC_ERR_NUM                 = 0x24;
+const sal_uInt8 EXC_ERR_NA                  = 0x2A;
+
+// Cached values list (EXTERNNAME, ptgArray, ...) -----------------------------
+
+const sal_uInt8 EXC_CACHEDVAL_EMPTY         = 0x00;
+const sal_uInt8 EXC_CACHEDVAL_DOUBLE        = 0x01;
+const sal_uInt8 EXC_CACHEDVAL_STRING        = 0x02;
+const sal_uInt8 EXC_CACHEDVAL_BOOL          = 0x04;
+const sal_uInt8 EXC_CACHEDVAL_ERROR         = 0x10;
+
+// RK values ------------------------------------------------------------------
+
+const sal_Int32 EXC_RK_100FLAG              = 0x00000001;
+const sal_Int32 EXC_RK_INTFLAG              = 0x00000002;
+const sal_Int32 EXC_RK_VALUEMASK            = 0xFFFFFFFC;
+
+const sal_Int32 EXC_RK_DBL                  = 0x00000000;
+const sal_Int32 EXC_RK_DBL100               = EXC_RK_100FLAG;
+const sal_Int32 EXC_RK_INT                  = EXC_RK_INTFLAG;
+const sal_Int32 EXC_RK_INT100               = EXC_RK_100FLAG | EXC_RK_INTFLAG;
+
+// Measures -------------------------------------------------------------------
+
+const sal_Int32 EXC_POINTS_PER_INCH         = 72;
+const sal_Int32 EXC_TWIPS_PER_INCH          = EXC_POINTS_PER_INCH * 20;
+
+const sal_uInt8 EXC_ORIENT_NONE             = 0;        /// Text orientation: not rotated.
+const sal_uInt8 EXC_ORIENT_STACKED          = 1;        /// Text orientation: vertically stacked.
+const sal_uInt8 EXC_ORIENT_90CCW            = 2;        /// Text orientation: 90 deg counterclockwise.
+const sal_uInt8 EXC_ORIENT_90CW             = 3;        /// Text orientation: 90 deg clockwise.
+
+const sal_uInt8 EXC_ROT_NONE                = 0;        /// Text rotation: not rotated.
+const sal_uInt8 EXC_ROT_90CCW               = 90;       /// Text rotation: 90 deg counterclockwise.
+const sal_uInt8 EXC_ROT_90CW                = 180;      /// Text rotation: 90 deg clockwise.
+const sal_uInt8 EXC_ROT_STACKED             = 255;      /// Text rotation: vertically stacked.
+
+// Records (ordered by lowest record ID) ======================================
+
+// (0x0009, 0x0209, 0x0409, 0x0809) BOF ---------------------------------------
+
+const sal_uInt16 EXC_ID2_BOF                = 0x0009;
+const sal_uInt16 EXC_ID3_BOF                = 0x0209;
+const sal_uInt16 EXC_ID4_BOF                = 0x0409;
+const sal_uInt16 EXC_ID5_BOF                = 0x0809;
+
+const sal_uInt16 EXC_BOF_BIFF2              = 0x0200;
+const sal_uInt16 EXC_BOF_BIFF3              = 0x0300;
+const sal_uInt16 EXC_BOF_BIFF4              = 0x0400;
+const sal_uInt16 EXC_BOF_BIFF5              = 0x0500;
+const sal_uInt16 EXC_BOF_BIFF8              = 0x0600;
+
+const sal_uInt16 EXC_BOF_GLOBALS            = 0x0005;   /// BIFF5-BIFF8 workbook globals.
+const sal_uInt16 EXC_BOF_VBMODULE           = 0x0006;   /// BIFF5-BIFF8 Visual BASIC module.
+const sal_uInt16 EXC_BOF_SHEET              = 0x0010;   /// Regular worksheet.
+const sal_uInt16 EXC_BOF_CHART              = 0x0020;   /// Chart sheet.
+const sal_uInt16 EXC_BOF_MACROSHEET         = 0x0040;   /// Macro sheet.
+const sal_uInt16 EXC_BOF_WORKSPACE          = 0x0100;   /// Workspace.
+const sal_uInt16 EXC_BOF_UNKNOWN            = 0xFFFF;   /// Internal use only.
+
+// (0x000A) EOF ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_EOF                 = 0x000A;
+
+// (0x0012) PROTECT -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_PROTECT             = 0x0012;
+
+// (0x0013) PASSWORD ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_PASSWORD            = 0x0013;
+
+// (0x0019) WINDOWPROTECT -----------------------------------------------------
+
+const sal_uInt16 EXC_ID_WINDOWPROTECT       = 0x0019;
+
+// (0x0042) CODEPAGE ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_CODEPAGE            = 0x0042;
+
+// (0x0081) WSBOOL ------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_WSBOOL              = 0x0081;
+
+const sal_uInt16 EXC_WSBOOL_ROWBELOW        = 0x0040;
+const sal_uInt16 EXC_WSBOOL_COLBELOW        = 0x0080;
+const sal_uInt16 EXC_WSBOOL_FITTOPAGE       = 0x0100;
+
+const sal_uInt16 EXC_WSBOOL_DEFAULTFLAGS    = 0x04C1;
+
+// (0x008C) COUNTRY -----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_COUNTRY             = 0x008C;
+
+// (0x009B) FILTERMODE --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_FILTERMODE          = 0x009B;
+
+// (0x009D) AUTOFILTERINFO ----------------------------------------------------
+
+const sal_uInt16 EXC_ID_AUTOFILTERINFO      = 0x009D;
+
+// (0x009E) AUTOFILTER --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_AUTOFILTER          = 0x009E;
+
+// (0x0160) USESELFS ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_USESELFS            = 0x0160;
+
+// (0x01AA,0x01AB) USERSVIEWBEGIN, USERSVIEWEND -------------------------------
+
+const sal_uInt16 EXC_ID_USERSVIEWBEGIN      = 0x01AA;
+const sal_uInt16 EXC_ID_USERSVIEWEND        = 0x01AB;
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/inc/xlsx/xlformula.hxx sc/source/filter/inc/xlsx/xlformula.hxx
new file mode 100644
index 0000000..d8ffa5a
--- /dev/null
+++ sc/source/filter/inc/xlsx/xlformula.hxx
@@ -0,0 +1,477 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlformula.hxx,v $
+ * $Revision: 1.14 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLFORMULA_HXX
+#define SC_XLFORMULA_HXX
+
+#include <map>
+#include "address.hxx"
+#include "formula/opcode.hxx"
+#include "ftools.hxx"
+
+// Constants ==================================================================
+
+const size_t EXC_TOKARR_MAXLEN              = 4096;     /// Maximum size of a token array.
+
+// Token class flags ----------------------------------------------------------
+
+const sal_uInt8 EXC_TOKCLASS_MASK           = 0x60;
+const sal_uInt8 EXC_TOKCLASS_INOP_FLAG      = 0x80;     /// Used in operators (internal flag).
+
+const sal_uInt8 EXC_TOKCLASS_NONE           = 0x00;     /// 00-1F: Base tokens.
+const sal_uInt8 EXC_TOKCLASS_REF            = 0x20;     /// 20-3F: Reference class tokens.
+const sal_uInt8 EXC_TOKCLASS_VAL            = 0x40;     /// 40-5F: Value class tokens.
+const sal_uInt8 EXC_TOKCLASS_ARR            = 0x60;     /// 60-7F: Array class tokens.
+
+const sal_uInt8 EXC_TOKCLASS_ANY_IN_REFOP   = EXC_TOKCLASS_INOP_FLAG | EXC_TOKCLASS_NONE;
+const sal_uInt8 EXC_TOKCLASS_REF_IN_VALOP   = EXC_TOKCLASS_INOP_FLAG | EXC_TOKCLASS_REF;
+const sal_uInt8 EXC_TOKCLASS_VAL_IN_VALOP   = EXC_TOKCLASS_INOP_FLAG | EXC_TOKCLASS_VAL;
+const sal_uInt8 EXC_TOKCLASS_ARR_IN_VALOP   = EXC_TOKCLASS_INOP_FLAG | EXC_TOKCLASS_ARR;
+
+// Base tokens ----------------------------------------------------------------
+
+const sal_uInt8 EXC_TOKID_MASK              = 0x1F;
+
+const sal_uInt8 EXC_TOKID_NONE              = 0x00;     /// Placeholder for invalid token id.
+const sal_uInt8 EXC_TOKID_EXP               = 0x01;     /// Array or shared formula reference.
+const sal_uInt8 EXC_TOKID_TBL               = 0x02;     /// Multiple operation reference.
+const sal_uInt8 EXC_TOKID_ADD               = 0x03;     /// Addition operator.
+const sal_uInt8 EXC_TOKID_SUB               = 0x04;     /// Subtraction operator.
+const sal_uInt8 EXC_TOKID_MUL               = 0x05;     /// Multiplication operator.
+const sal_uInt8 EXC_TOKID_DIV               = 0x06;     /// Division operator.
+const sal_uInt8 EXC_TOKID_POWER             = 0x07;     /// Power operator.
+const sal_uInt8 EXC_TOKID_CONCAT            = 0x08;     /// String concatenation operator.
+const sal_uInt8 EXC_TOKID_LT                = 0x09;     /// Less than operator.
+const sal_uInt8 EXC_TOKID_LE                = 0x0A;     /// Less than or equal operator.
+const sal_uInt8 EXC_TOKID_EQ                = 0x0B;     /// Equal operator.
+const sal_uInt8 EXC_TOKID_GE                = 0x0C;     /// Greater than or equal operator.
+const sal_uInt8 EXC_TOKID_GT                = 0x0D;     /// Greater than operator.
+const sal_uInt8 EXC_TOKID_NE                = 0x0E;     /// Not equal operator.
+const sal_uInt8 EXC_TOKID_ISECT             = 0x0F;     /// Intersection operator.
+const sal_uInt8 EXC_TOKID_LIST              = 0x10;     /// List operator.
+const sal_uInt8 EXC_TOKID_RANGE             = 0x11;     /// Range operator.
+const sal_uInt8 EXC_TOKID_UPLUS             = 0x12;     /// Unary plus.
+const sal_uInt8 EXC_TOKID_UMINUS            = 0x13;     /// Unary minus.
+const sal_uInt8 EXC_TOKID_PERCENT           = 0x14;     /// Percent sign.
+const sal_uInt8 EXC_TOKID_PAREN             = 0x15;     /// Parentheses.
+const sal_uInt8 EXC_TOKID_MISSARG           = 0x16;     /// Missing argument.
+const sal_uInt8 EXC_TOKID_STR               = 0x17;     /// String constant.
+const sal_uInt8 EXC_TOKID_NLR               = 0x18;     /// Natural language reference (NLR).
+const sal_uInt8 EXC_TOKID_ATTR              = 0x19;     /// Special attribute.
+const sal_uInt8 EXC_TOKID_SHEET             = 0x1A;     /// Start of a sheet reference (BIFF2-BIFF4).
+const sal_uInt8 EXC_TOKID_ENDSHEET          = 0x1B;     /// End of a sheet reference (BIFF2-BIFF4).
+const sal_uInt8 EXC_TOKID_ERR               = 0x1C;     /// Error constant.
+const sal_uInt8 EXC_TOKID_BOOL              = 0x1D;     /// Boolean constant.
+const sal_uInt8 EXC_TOKID_INT               = 0x1E;     /// Integer constant.
+const sal_uInt8 EXC_TOKID_NUM               = 0x1F;     /// Floating-point constant.
+
+// Base IDs of classified tokens ----------------------------------------------
+
+const sal_uInt8 EXC_TOKID_ARRAY             = 0x00;     /// Array constant.
+const sal_uInt8 EXC_TOKID_FUNC              = 0x01;     /// Function, fixed number of arguments.
+const sal_uInt8 EXC_TOKID_FUNCVAR           = 0x02;     /// Function, variable number of arguments.
+const sal_uInt8 EXC_TOKID_NAME              = 0x03;     /// Defined name.
+const sal_uInt8 EXC_TOKID_REF               = 0x04;     /// 2D cell reference.
+const sal_uInt8 EXC_TOKID_AREA              = 0x05;     /// 2D area reference.
+const sal_uInt8 EXC_TOKID_MEMAREA           = 0x06;     /// Constant reference subexpression.
+const sal_uInt8 EXC_TOKID_MEMERR            = 0x07;     /// Deleted reference subexpression.
+const sal_uInt8 EXC_TOKID_MEMNOMEM          = 0x08;     /// Constant reference subexpression without result.
+const sal_uInt8 EXC_TOKID_MEMFUNC           = 0x09;     /// Variable reference subexpression.
+const sal_uInt8 EXC_TOKID_REFERR            = 0x0A;     /// Deleted 2D cell reference.
+const sal_uInt8 EXC_TOKID_AREAERR           = 0x0B;     /// Deleted 2D area reference.
+const sal_uInt8 EXC_TOKID_REFN              = 0x0C;     /// Relative 2D cell reference (in names).
+const sal_uInt8 EXC_TOKID_AREAN             = 0x0D;     /// Relative 2D area reference (in names).
+const sal_uInt8 EXC_TOKID_MEMAREAN          = 0x0E;     /// Reference subexpression (in names).
+const sal_uInt8 EXC_TOKID_MEMNOMEMN         = 0x0F;     /// Reference subexpression (in names) without result.
+const sal_uInt8 EXC_TOKID_FUNCCE            = 0x18;
+const sal_uInt8 EXC_TOKID_NAMEX             = 0x19;     /// External reference.
+const sal_uInt8 EXC_TOKID_REF3D             = 0x1A;     /// 3D cell reference.
+const sal_uInt8 EXC_TOKID_AREA3D            = 0x1B;     /// 3D area reference.
+const sal_uInt8 EXC_TOKID_REFERR3D          = 0x1C;     /// Deleted 3D cell reference.
+const sal_uInt8 EXC_TOKID_AREAERR3D         = 0x1D;     /// Deleted 3D area reference
+
+// specific token constants ---------------------------------------------------
+
+const sal_uInt16 EXC_TOK_STR_MAXLEN         = 255;      /// Maximum string length of a tStr token.
+
+const sal_uInt8 EXC_TOK_BOOL_FALSE          = 0;        /// FALSE value of a tBool token.
+const sal_uInt8 EXC_TOK_BOOL_TRUE           = 1;        /// TRUE value of a tBool token.
+
+const sal_uInt8 EXC_TOK_ATTR_VOLATILE       = 0x01;     /// Volatile function.
+const sal_uInt8 EXC_TOK_ATTR_IF             = 0x02;     /// Start of true condition in IF function.
+const sal_uInt8 EXC_TOK_ATTR_CHOOSE         = 0x04;     /// Jump array of CHOOSE function.
+const sal_uInt8 EXC_TOK_ATTR_GOTO           = 0x08;     /// Jump to token.
+const sal_uInt8 EXC_TOK_ATTR_SUM            = 0x10;     /// SUM function with one parameter.
+const sal_uInt8 EXC_TOK_ATTR_ASSIGN         = 0x20;     /// BASIC style assignment.
+const sal_uInt8 EXC_TOK_ATTR_SPACE          = 0x40;     /// Spaces in formula representation.
+
+const sal_uInt8 EXC_TOK_ATTR_SPACE_SP       = 0x00;     /// Spaces before next token.
+const sal_uInt8 EXC_TOK_ATTR_SPACE_BR       = 0x01;     /// Line breaks before next token.
+const sal_uInt8 EXC_TOK_ATTR_SPACE_SP_OPEN  = 0x02;     /// Spaces before opening parenthesis.
+const sal_uInt8 EXC_TOK_ATTR_SPACE_BR_OPEN  = 0x03;     /// Line breaks before opening parenthesis.
+const sal_uInt8 EXC_TOK_ATTR_SPACE_SP_CLOSE = 0x04;     /// Spaces before closing parenthesis.
+const sal_uInt8 EXC_TOK_ATTR_SPACE_BR_CLOSE = 0x05;     /// Line breaks before closing parenthesis.
+const sal_uInt8 EXC_TOK_ATTR_SPACE_SP_PRE   = 0x06;     /// Spaces before formula (BIFF3).
+
+const sal_uInt16 EXC_TOK_FUNCVAR_CMD        = 0x8000;   /// Macro command.
+const sal_uInt16 EXC_TOK_FUNCVAR_INDEXMASK  = 0x7FFF;   /// Mask for function/command index.
+const sal_uInt8 EXC_TOK_FUNCVAR_PROMPT      = 0x80;     /// User prompt for macro commands.
+const sal_uInt8 EXC_TOK_FUNCVAR_COUNTMASK   = 0x7F;     /// Mask for parameter count.
+
+const sal_uInt16 EXC_TOK_REF_COLREL         = 0x4000;   /// True = Column is relative.
+const sal_uInt32 EXC_TOK_REF_ROWREL         = 0x8000;   /// True = Row is relative.
+
+const sal_uInt8 EXC_TOK_NLR_ERR             = 0x01;     /// NLR: Invalid/deleted.
+const sal_uInt8 EXC_TOK_NLR_ROWR            = 0x02;     /// NLR: Row index.
+const sal_uInt8 EXC_TOK_NLR_COLR            = 0x03;     /// NLR: Column index.
+const sal_uInt8 EXC_TOK_NLR_ROWV            = 0x06;     /// NLR: Value in row.
+const sal_uInt8 EXC_TOK_NLR_COLV            = 0x07;     /// NLR: Value in column.
+const sal_uInt8 EXC_TOK_NLR_RANGE           = 0x0A;     /// NLR: Range.
+const sal_uInt8 EXC_TOK_NLR_SRANGE          = 0x0B;     /// Stacked NLR: Range.
+const sal_uInt8 EXC_TOK_NLR_SROWR           = 0x0C;     /// Stacked NLR: Row index.
+const sal_uInt8 EXC_TOK_NLR_SCOLR           = 0x0D;     /// Stacked NLR: Column index.
+const sal_uInt8 EXC_TOK_NLR_SROWV           = 0x0E;     /// Stacked NLR: Value in row.
+const sal_uInt8 EXC_TOK_NLR_SCOLV           = 0x0F;     /// Stacked NLR: Value in column.
+const sal_uInt8 EXC_TOK_NLR_RANGEERR        = 0x10;     /// NLR: Invalid/deleted range.
+const sal_uInt8 EXC_TOK_NLR_SXNAME          = 0x1D;     /// NLR: Pivot table name.
+const sal_uInt16 EXC_TOK_NLR_REL            = 0x8000;   /// True = Natural language ref is relative.
+
+const sal_uInt32 EXC_TOK_NLR_ADDREL         = 0x80000000;   /// NLR relative (in appended data).
+const sal_uInt32 EXC_TOK_NLR_ADDMASK        = 0x3FFFFFFF;   /// Mask for number of appended ranges.
+
+// ----------------------------------------------------------------------------
+
+/** Type of a formula. */
+enum XclFormulaType
+{
+    EXC_FMLATYPE_CELL,          /// Simple cell formula, also used in change tracking.
+    EXC_FMLATYPE_MATRIX,        /// Matrix (array) formula.
+    EXC_FMLATYPE_SHARED,        /// Shared formula.
+    EXC_FMLATYPE_CONDFMT,       /// Conditional format.
+    EXC_FMLATYPE_DATAVAL,       /// Data validation.
+    EXC_FMLATYPE_NAME,          /// Defined name.
+    EXC_FMLATYPE_CHART,         /// Chart source ranges.
+    EXC_FMLATYPE_CONTROL,       /// Spreadsheet links in form controls.
+    EXC_FMLATYPE_WQUERY,        /// Web query source range.
+    EXC_FMLATYPE_LISTVAL        /// List (cell range) validation.
+};
+
+// Function data ==============================================================
+
+const sal_uInt8 EXC_FUNC_MAXPARAM           = 30;       /// Maximum parameter count.
+
+const sal_uInt8 EXC_FUNC_PAR_CALCONLY       = 0xFD;     /// Placeholder for a parameter existing in Calc, but not in Excel.
+const sal_uInt8 EXC_FUNC_PAR_EXCELONLY      = 0xFE;     /// Placeholder for a parameter existing in Excel, but not in Calc.
+const sal_uInt8 EXC_FUNC_PAR_INVALID        = 0xFF;     /// Placeholder for an invalid token class.
+
+const sal_uInt8 EXC_FUNCINFO_CLASSCOUNT     = 5;        /// Number of token class entries.
+
+const sal_uInt8 EXC_FUNCFLAG_VOLATILE       = 0x01;     /// Result is volatile (e.g. NOW() function).
+const sal_uInt8 EXC_FUNCFLAG_IMPORTONLY     = 0x02;     /// Only used in import filter.
+const sal_uInt8 EXC_FUNCFLAG_EXPORTONLY     = 0x04;     /// Only used in export filter.
+
+// selected function IDs
+const sal_uInt16 EXC_FUNCID_IF              = 1;
+const sal_uInt16 EXC_FUNCID_SUM             = 4;
+const sal_uInt16 EXC_FUNCID_AND             = 36;
+const sal_uInt16 EXC_FUNCID_OR              = 37;
+const sal_uInt16 EXC_FUNCID_CHOOSE          = 100;
+const sal_uInt16 EXC_FUNCID_EXTERNCALL      = 255;
+
+/** Represents information for a spreadsheet function for import and export.
+
+    The member mpnParamClass contains an array of token classes for each
+    parameter of the function. The last existing (non-null) value in this array
+    is used for all following parameters used in a function. Additionally to
+    the three actual token classes, this array may contain the special values
+    EXC_FUNC_PAR_CALCONLY, EXC_FUNC_PAR_EXCELONLY, and EXC_FUNC_PAR_INVALID.
+    The former two specify parameters only existing in one of the applications.
+    EXC_FUNC_PAR_INVALID is simply a terminator for the array to prevent that
+    the last token class or special value is repeated for additional parameters.
+ */
+struct XclFunctionInfo
+{
+    OpCode              meOpCode;           /// Calc function opcode.
+    sal_uInt16          mnXclFunc;          /// Excel function index.
+    sal_uInt8           mnMinParamCount;    /// Minimum number of parameters.
+    sal_uInt8           mnMaxParamCount;    /// Maximum number of parameters.
+    sal_uInt8           mnRetClass;         /// Token class of the return value.
+    sal_uInt8           mpnParamClass[ EXC_FUNCINFO_CLASSCOUNT ]; /// Expected token classes of parameters.
+    sal_uInt8           mnFlags;            /// Additional flags.
+    const sal_Char*     mpcMacroName;       /// Function name, if simulated by a macro call (UTF-8).
+
+    /** Returns true, if the function is volatile. */
+    inline bool         IsVolatile() const { return ::get_flag( mnFlags, EXC_FUNCFLAG_VOLATILE ); }
+    /** Returns true, if the function is simulated by a macro call. */
+    inline bool         IsMacroFunc() const { return mpcMacroName != 0; }
+    /** Returns the name of the external function as string. */
+    String              GetMacroFuncName() const;
+};
+
+// ----------------------------------------------------------------------------
+
+class XclRoot;
+
+/** Provides access to function info structs for all available functions. */
+class XclFunctionProvider
+{
+public:
+    explicit            XclFunctionProvider( const XclRoot& rRoot );
+
+    /** Returns the function data for an Excel function index, or 0 on error. */
+    const XclFunctionInfo* GetFuncInfoFromXclFunc( sal_uInt16 nXclFunc ) const;
+    /** Returns the function data for an Excel function simulated by a macro call, or 0 on error. */
+    const XclFunctionInfo* GetFuncInfoFromXclMacroName( const String& rXclMacroName ) const;
+    /** Returns the function data for a Calc opcode, or 0 on error. */
+    const XclFunctionInfo* GetFuncInfoFromOpCode( OpCode eOpCode ) const;
+
+private:
+    void                FillXclFuncMap( const XclFunctionInfo* pBeg, const XclFunctionInfo* pEnd );
+    void                FillScFuncMap( const XclFunctionInfo* pBeg, const XclFunctionInfo* pEnd );
+
+private:
+    typedef ::std::map< sal_uInt16, const XclFunctionInfo* >    XclFuncMap;
+    typedef ::std::map< String, const XclFunctionInfo* >        XclMacroNameMap;
+    typedef ::std::map< OpCode, const XclFunctionInfo* >        ScFuncMap;
+
+    XclFuncMap          maXclFuncMap;       /// Maps Excel function indexes to function data.
+    XclMacroNameMap     maXclMacroNameMap;  /// Maps macro function names to function data.
+    ScFuncMap           maScFuncMap;        /// Maps Calc opcodes to function data.
+};
+
+// Token array ================================================================
+
+class XclImpStream;
+class XclExpStream;
+
+/** Binary representation of an Excel token array. */
+class XclTokenArray
+{
+public:
+    /** Creates an empty token array. */
+    explicit            XclTokenArray( bool bVolatile = false );
+    /** Creates a token array, swaps passed token vector into own data. */
+    explicit            XclTokenArray( ScfUInt8Vec& rTokVec, bool bVolatile = false, 
+                                       ScfUInt8Vec* pExtensionTokens = NULL);
+
+    /** Returns true, if the token array is empty. */
+    inline bool         Empty() const { return maTokVec.empty(); }
+    /** Returns the size of the token array in bytes. */
+    sal_uInt16          GetSize() const;
+    /** Returns read-only access to the byte vector storing token data. */
+    inline const sal_uInt8* GetData() const { return maTokVec.empty() ? 0 : &maTokVec.front(); }
+    /** Returns true, if the formula contains a volatile function. */
+    inline bool         IsVolatile() const { return mbVolatile; }
+
+    /** Reads the size field of the token array. */
+    void                ReadSize( XclImpStream& rStrm );
+    /** Reads the tokens of the token array (without size field). */
+    void                ReadArray( XclImpStream& rStrm );
+    /** Reads size field and the tokens. */
+    void                Read( XclImpStream& rStrm );
+
+    /** Writes the size field of the token array. */
+    void                WriteSize( XclExpStream& rStrm ) const;
+    /** Writes the tokens of the token array (without size field). */
+    void                WriteArray( XclExpStream& rStrm ) const;
+    /** Writes size field and the tokens. */
+    void                Write( XclExpStream& rStrm ) const;
+
+    /** Compares this token array with the passed. */
+    bool                operator==( const XclTokenArray& rTokArr ) const;
+
+private:
+    ScfUInt8Vec         maTokVec;       /// Byte vector containing token data.
+    ScfUInt8Vec         maExtensions;   /// Byte vector of extensions (eg inline arrays)
+    bool                mbVolatile;     /// True = Formula contains volatile function.
+};
+
+typedef ScfRef< XclTokenArray > XclTokenArrayRef;
+
+/** Calls the Read() function at the passed token array. */
+XclImpStream& operator>>( XclImpStream& rStrm, XclTokenArray& rTokArr );
+/** Calls the Read() function at the passed token array. */
+XclImpStream& operator>>( XclImpStream& rStrm, XclTokenArrayRef& rxTokArr );
+/** Calls the Write() function at the passed token array. */
+XclExpStream& operator<<( XclExpStream& rStrm, const XclTokenArray& rTokArr );
+/** Calls the Write() function at the passed token array. */
+XclExpStream& operator<<( XclExpStream& rStrm, const XclTokenArrayRef& rxTokArr );
+
+// ----------------------------------------------------------------------------
+
+namespace formula
+{
+    class FormulaToken;
+}
+class ScTokenArray;
+
+/** Special token array iterator for the Excel filters.
+
+    Iterates over a Calc token array without modifying it (therefore the
+    iterator can be used with constant token arrays).
+
+    Usage: Construct a new iterator object and pass a Calc token array, or use
+    the Init() function to assign another Calc token array. As long as the Is()
+    function returns true, the accessor functions can be used to get the
+    current Calc token.
+ */
+class XclTokenArrayIterator
+{
+public:
+    explicit            XclTokenArrayIterator();
+    explicit            XclTokenArrayIterator( const ScTokenArray& rScTokArr, bool bSkipSpaces );
+    /** Copy constructor that allowa to change the skip-spaces mode. */
+    explicit            XclTokenArrayIterator( const XclTokenArrayIterator& rTokArrIt, bool bSkipSpaces );
+
+    void                Init();
+    void                Init( const ScTokenArray& rScTokArr, bool bSkipSpaces );
+
+    inline bool         Is() const { return mppScToken != 0; }
+    inline bool         operator!() const { return !Is(); }
+    inline const formula::FormulaToken* Get() const { return mppScToken ? *mppScToken : 0; }
+    inline const formula::FormulaToken* operator->() const { return Get(); }
+    inline const formula::FormulaToken& operator*() const { return *Get(); }
+
+    XclTokenArrayIterator& operator++();
+
+private:
+    void                NextRawToken();
+    void                SkipSpaces();
+
+private:
+    const formula::FormulaToken*const* mppScTokenBeg;     /// Pointer to first token pointer of token array.
+    const formula::FormulaToken*const* mppScTokenEnd;     /// Pointer behind last token pointer of token array.
+    const formula::FormulaToken*const* mppScToken;        /// Pointer to current token pointer of token array.
+    bool                mbSkipSpaces;       /// true = Skip whitespace tokens.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Contains all cell references that can be extracted from a multiple operations formula. */
+struct XclMultipleOpRefs
+{
+    ScAddress           maFmlaScPos;        /// Position of the (first) formula cell.
+    ScAddress           maColFirstScPos;
+    ScAddress           maColRelScPos;
+    ScAddress           maRowFirstScPos;
+    ScAddress           maRowRelScPos;
+    bool                mbDblRefMode;       /// true = One formula with row and column values.
+};
+
+// ----------------------------------------------------------------------------
+
+/** A helper with Excel specific token array functions.
+
+    The purpose to not add these functions to ScTokenArray is to prevent code
+    changes in low-level Calc headers and to keep the Excel specific source
+    code in the filter directory. Deriving from ScTokenArray is not viable
+    because that would need expensive copy-constructions of the token arrays.
+ */
+class XclTokenArrayHelper
+{
+public:
+    // token identifiers ------------------------------------------------------
+
+    /** Returns the base token ID of the passed (classified) token ID. */
+    inline static sal_uInt8 GetBaseTokenId( sal_uInt8 nTokenId ) { return nTokenId & EXC_TOKID_MASK; }
+    /** Returns the classified token ID from a base ID and the token class. */
+    inline static sal_uInt8 GetTokenId( sal_uInt8 nBaseId, sal_uInt8 nTokenClass );
+
+    /** Returns the token class of the passed token ID. */
+    inline static sal_uInt8 GetTokenClass( sal_uInt8 nTokenId ) { return nTokenId & EXC_TOKCLASS_MASK; }
+    /** Changes the token class in the passed classified token ID. */
+    inline static void ChangeTokenClass( sal_uInt8& rnTokenId, sal_uInt8 nTokenClass );
+
+    // strings and string lists -----------------------------------------------
+
+    /** Tries to extract a string from the passed token.
+        @param rString  (out-parameter) The string contained in the token.
+        @return  true = Passed token is a string token, rString parameter is valid. */
+    static bool         GetTokenString( String& rString, const formula::FormulaToken& rScToken );
+
+    /** Parses the passed formula and tries to find a single string token, i.e. "abc".
+        @param rString  (out-parameter) The string contained in the formula.
+        @return  true = String token found, rString parameter is valid. */
+    static bool         GetString( String& rString, const ScTokenArray& rScTokArr );
+
+    /** Parses the passed formula and tries to find a string token list, i.e. "abc";"def";"ghi".
+        @descr  Returns the unquoted (!) strings in a single string, separated with the
+        passed character. If a comma is specified, the function will return abc,def,ghi from
+        the example above.
+        @param rStringList  (out-parameter) All strings contained in the formula as list.
+        @param cSep  List separator character.
+        @return  true = String token list found, rString parameter is valid. */
+    static bool         GetStringList( String& rStringList, const ScTokenArray& rScTokArr, sal_Unicode cSep );
+
+    /** Tries to convert a formula that consists of a single string token to a list of strings.
+        @descr  Example: The formula ="abc\ndef\nghi" will be converted to the formula
+        ="abc";"def";"ghi", if the LF character is specified as separator.
+        @param rScTokArr  (in/out-parameter) The token array to modify.
+        @param cStringSep  The separator in the source string.
+        @param bTrimLeadingSpaces  true = remove leading spaces from each token. */
+    static void         ConvertStringToList( ScTokenArray& rScTokArr, sal_Unicode cStringSep, bool bTrimLeadingSpaces );
+
+    // shared formulas --------------------------------------------------------
+
+    /** Tries to extract the definition of a shared formula from the passed token array.
+        @descr  Shared formulas are stored as hidden defined names in Calc. This
+        function looks if the passed token array consists of the reference to
+        such a hidden defined name and returns its definition on success. */
+    static const ScTokenArray* GetSharedFormula( const XclRoot& rRoot, const ScTokenArray& rScTokArr );
+
+    // multiple operations ----------------------------------------------------
+
+    /** Parses the passed formula and tries to extract references of a multiple operation.
+        @descr  Requires that the formula contains a single MULTIPLE.OPERATION function call.
+        Spaces in the formula are silently ignored.
+        @return  true = Multiple operation found, and all references successfully extracted. */
+    static bool         GetMultipleOpRefs( XclMultipleOpRefs& rRefs, const ScTokenArray& rScTokArr );
+};
+
+// ----------------------------------------------------------------------------
+
+inline sal_uInt8 XclTokenArrayHelper::GetTokenId( sal_uInt8 nBaseId, sal_uInt8 nTokenClass )
+{
+    DBG_ASSERT( !::get_flag( nBaseId, static_cast< sal_uInt8 >( ~EXC_TOKID_MASK ) ), "XclTokenArrayHelper::GetTokenId - invalid token ID" );
+    DBG_ASSERT( !::get_flag( nTokenClass, static_cast< sal_uInt8 >( ~EXC_TOKCLASS_MASK ) ), "XclTokenArrayHelper::GetTokenId - invalid token class" );
+    return nBaseId | nTokenClass;
+}
+
+inline void XclTokenArrayHelper::ChangeTokenClass( sal_uInt8& rnTokenId, sal_uInt8 nTokenClass )
+{
+    DBG_ASSERT( !::get_flag( nTokenClass, static_cast< sal_uInt8 >( ~EXC_TOKCLASS_MASK ) ), "XclTokenArrayHelper::ChangeTokenClass - invalid token class" );
+    ::set_flag( rnTokenId, EXC_TOKCLASS_MASK, false );
+    ::set_flag( rnTokenId, nTokenClass );
+}
+
+// ============================================================================
+
+#endif
+
diff --git sc/source/filter/xlsx/XclExpChangeTrack.hxx sc/source/filter/xlsx/XclExpChangeTrack.hxx
index 59ec5db..0c6a0d7 100644
--- sc/source/filter/xlsx/XclExpChangeTrack.hxx
+++ sc/source/filter/xlsx/XclExpChangeTrack.hxx
@@ -426,14 +426,14 @@ public:
 
 inline void XclExpChTrAction::Write2DAddress( XclExpStream& rStrm, const ScAddress& rAddress ) const
 {
-	rStrm	<< (sal_uInt16)	rAddress.Row()
+	rStrm	<< (sal_uInt32)	rAddress.Row()
 			<< (sal_uInt16)	rAddress.Col();
 }
 
 inline void XclExpChTrAction::Write2DRange( XclExpStream& rStrm, const ScRange& rRange ) const
 {
-	rStrm	<< (sal_uInt16)	rRange.aStart.Row()
-			<< (sal_uInt16)	rRange.aEnd.Row()
+	rStrm	<< (sal_uInt32)	rRange.aStart.Row()
+			<< (sal_uInt32)	rRange.aEnd.Row()
 			<< (sal_uInt16)	rRange.aStart.Col()
 			<< (sal_uInt16)	rRange.aEnd.Col();
 }
diff --git sc/source/filter/xlsx/excrecds.hxx sc/source/filter/xlsx/excrecds.hxx
index 57744dc..2752561 100644
--- sc/source/filter/xlsx/excrecds.hxx
+++ sc/source/filter/xlsx/excrecds.hxx
@@ -39,6 +39,9 @@
 
 
 #include <vector>
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "olinetab.hxx"
 #include "filter.hxx"
 #include "rangelst.hxx"
diff --git sc/source/filter/xlsx/makefile.mk sc/source/filter/xlsx/makefile.mk
index 63b9235..b31b352 100644
--- sc/source/filter/xlsx/makefile.mk
+++ sc/source/filter/xlsx/makefile.mk
@@ -46,6 +46,8 @@ PROJECTPCHSOURCE=..\pch\filt_pch
 .INCLUDE :  settings.mk
 .INCLUDE :  sc.mk
 
+CFLAGS+=-DXLSX_COPY
+
 # --- Files --------------------------------------------------------
 
 SLOFILES =	\
diff --git sc/source/filter/xlsx/xestream.hxx sc/source/filter/xlsx/xestream.hxx
index e18fe72..3863e8b 100644
--- sc/source/filter/xlsx/xestream.hxx
+++ sc/source/filter/xlsx/xestream.hxx
@@ -40,6 +40,9 @@
 #include <oox/core/xmlfilterbase.hxx>
 #include <sax/fshelper.hxx>
 
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xlstream.hxx"
 #include "xestring.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-colrowst.cxx sc/source/filter/xlsx/xlsx-colrowst.cxx
index 9c686fe..996303a 100644
--- sc/source/filter/xlsx/xlsx-colrowst.cxx
+++ sc/source/filter/xlsx/xlsx-colrowst.cxx
@@ -31,7 +31,8 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
 
 #include "colrowst.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-excdoc.cxx sc/source/filter/xlsx/xlsx-excdoc.cxx
index 0e213f6..29ab499 100644
--- sc/source/filter/xlsx/xlsx-excdoc.cxx
+++ sc/source/filter/xlsx/xlsx-excdoc.cxx
@@ -31,6 +31,10 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
+#include "xlsx/xetable.hxx"
 
 //------------------------------------------------------------------------
 
diff --git sc/source/filter/xlsx/xlsx-excel.cxx sc/source/filter/xlsx/xlsx-excel.cxx
index d19958d..cbc4a16 100644
--- sc/source/filter/xlsx/xlsx-excel.cxx
+++ sc/source/filter/xlsx/xlsx-excel.cxx
@@ -31,6 +31,9 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include <sfx2/docfile.hxx>
 #include <sfx2/objsh.hxx>
 #include <sfx2/app.hxx>
diff --git sc/source/filter/xlsx/xlsx-excform.cxx sc/source/filter/xlsx/xlsx-excform.cxx
index f30eb80..b6cf22c 100644
--- sc/source/filter/xlsx/xlsx-excform.cxx
+++ sc/source/filter/xlsx/xlsx-excform.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "excform.hxx"
 #include <osl/endian.h>
 
diff --git sc/source/filter/xlsx/xlsx-excform8.cxx sc/source/filter/xlsx/xlsx-excform8.cxx
index c6340a1..24f50b1 100644
--- sc/source/filter/xlsx/xlsx-excform8.cxx
+++ sc/source/filter/xlsx/xlsx-excform8.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "excform.hxx"
 
 #include "cell.hxx"
diff --git sc/source/filter/xlsx/xlsx-excimp8.cxx sc/source/filter/xlsx/xlsx-excimp8.cxx
index 60c2f6d..2995571 100644
--- sc/source/filter/xlsx/xlsx-excimp8.cxx
+++ sc/source/filter/xlsx/xlsx-excimp8.cxx
@@ -31,6 +31,9 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "excimp8.hxx"
 
 
diff --git sc/source/filter/xlsx/xlsx-exctools.cxx sc/source/filter/xlsx/xlsx-exctools.cxx
index 4243edf..365b31a 100644
--- sc/source/filter/xlsx/xlsx-exctools.cxx
+++ sc/source/filter/xlsx/xlsx-exctools.cxx
@@ -390,7 +390,7 @@ void ExcScenario::Apply( const XclImpRoot& rRoot, const BOOL bLast )
 	while( p )
 	{
 		UINT16			nCol = p->nCol;
-		UINT16			nRow = p->nRow;
+		sal_uInt32 nRow = p->nRow;
 		String			aVal = p->GetValue();
 
 		r.ApplyFlagsTab( nCol, nRow, nCol, nRow, nNewTab, SC_MF_SCENARIO );
diff --git sc/source/filter/xlsx/xlsx-expop2.cxx sc/source/filter/xlsx/xlsx-expop2.cxx
index b4763c4..3561bf7 100644
--- sc/source/filter/xlsx/xlsx-expop2.cxx
+++ sc/source/filter/xlsx/xlsx-expop2.cxx
@@ -31,6 +31,9 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 
 //------------------------------------------------------------------------
diff --git sc/source/filter/xlsx/xlsx-impop.cxx sc/source/filter/xlsx/xlsx-impop.cxx
index 666ce76..35fb4fc 100644
--- sc/source/filter/xlsx/xlsx-impop.cxx
+++ sc/source/filter/xlsx/xlsx-impop.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "imp_op.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-namebuff.cxx sc/source/filter/xlsx/xlsx-namebuff.cxx
index 0c42767..eb4e73a 100644
--- sc/source/filter/xlsx/xlsx-namebuff.cxx
+++ sc/source/filter/xlsx/xlsx-namebuff.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "namebuff.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-read.cxx sc/source/filter/xlsx/xlsx-read.cxx
index 6c1e50a..86f108c 100644
--- sc/source/filter/xlsx/xlsx-read.cxx
+++ sc/source/filter/xlsx/xlsx-read.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 
 
diff --git sc/source/filter/xlsx/xlsx-xcl97esc.cxx sc/source/filter/xlsx/xlsx-xcl97esc.cxx
index e4f2344..828a7a1 100644
--- sc/source/filter/xlsx/xlsx-xcl97esc.cxx
+++ sc/source/filter/xlsx/xlsx-xcl97esc.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include <com/sun/star/awt/XControlModel.hpp>
 #include <com/sun/star/embed/XClassifiedObject.hpp>
diff --git sc/source/filter/xlsx/xlsx-xechart.cxx sc/source/filter/xlsx/xlsx-xechart.cxx
index cf3f218..5198737 100644
--- sc/source/filter/xlsx/xlsx-xechart.cxx
+++ sc/source/filter/xlsx/xlsx-xechart.cxx
@@ -31,6 +31,9 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xechart.hxx"
 
 #include <com/sun/star/i18n/XBreakIterator.hpp>
diff --git sc/source/filter/xlsx/xlsx-xecontent.cxx sc/source/filter/xlsx/xlsx-xecontent.cxx
index 9b8986e..3117555 100644
--- sc/source/filter/xlsx/xlsx-xecontent.cxx
+++ sc/source/filter/xlsx/xlsx-xecontent.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xecontent.hxx"
 
 #include <list>
@@ -526,7 +529,7 @@ String XclExpHyperlink::BuildFileName(
 void XclExpHyperlink::WriteBody( XclExpStream& rStrm )
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( maScPos.Col() );
-    sal_uInt16 nXclRow = static_cast< sal_uInt16 >( maScPos.Row() );
+    sal_uInt32 nXclRow = static_cast< sal_uInt32 >( maScPos.Row() );
     rStrm   << nXclRow << nXclRow << nXclCol << nXclCol;
     WriteEmbeddedData( rStrm );
 }
diff --git sc/source/filter/xlsx/xlsx-xeescher.cxx sc/source/filter/xlsx/xlsx-xeescher.cxx
index d3d10ff..43c6f54 100644
--- sc/source/filter/xlsx/xlsx-xeescher.cxx
+++ sc/source/filter/xlsx/xlsx-xeescher.cxx
@@ -948,14 +948,14 @@ void XclExpNote::WriteXml( sal_Int32 nAuthorId, XclExpXmlStream& rStrm )
             FSEND );
     rComments->startElement( XML_text, FSEND );
     // OOXTODO: phoneticPr, rPh, r
-#if 0
-    rComments->startElement( XML_t, FSEND );
-    rComments->writeEscaped( XclXmlUtils::ToOUString( maOrigNoteText ) );
-    rComments->endElement ( XML_t );
-#else
     if( mpNoteContents.is() )
         mpNoteContents->WriteXml( rStrm );
-#endif
+    else
+    {
+        rComments->startElement( XML_t, FSEND );
+        rComments->writeEscaped( XclXmlUtils::ToOUString( maOrigNoteText ) );
+        rComments->endElement ( XML_t );
+    }
     rComments->endElement( XML_text );
     rComments->endElement( XML_comment );
 }
diff --git sc/source/filter/xlsx/xlsx-xeformula.cxx sc/source/filter/xlsx/xlsx-xeformula.cxx
index 956d72a..31af0f9 100644
--- sc/source/filter/xlsx/xlsx-xeformula.cxx
+++ sc/source/filter/xlsx/xlsx-xeformula.cxx
@@ -429,7 +429,7 @@ private:
     const SCsCOL        mnMaxScCol;     /// Maximum column index in Calc itself.
     const SCsROW        mnMaxScRow;     /// Maximum row index in Calc itself.
     const sal_uInt16    mnMaxColMask;   /// Mask to delete invalid bits in column fields.
-    const sal_uInt16    mnMaxRowMask;   /// Mask to delete invalid bits in row fields.
+    const sal_uInt32    mnMaxRowMask;   /// Mask to delete invalid bits in row fields.
     bool                mbRunning;      /// true = compiler already running (for recursive calls).
 };
 
@@ -466,7 +466,7 @@ XclExpFmlaCompImpl::XclExpFmlaCompImpl( const XclExpRoot& rRoot ) :
     mnMaxScCol( static_cast< SCsCOL >( rRoot.GetScMaxPos().Col() ) ),
     mnMaxScRow( static_cast< SCsROW >( rRoot.GetScMaxPos().Row() ) ),
     mnMaxColMask( static_cast< sal_uInt16 >( rRoot.GetXclMaxPos().Col() ) ),
-    mnMaxRowMask( static_cast< sal_uInt16 >( rRoot.GetXclMaxPos().Row() ) ),
+    mnMaxRowMask( static_cast< sal_uInt32 >( rRoot.GetXclMaxPos().Row() ) ),
     mbRunning( false )
 {
     // build the configuration map
@@ -1863,7 +1863,7 @@ void XclExpFmlaCompImpl::ConvertRefData(
             rnScRow = mnMaxAbsRow;
         else if( (rnScRow < 0) || (rnScRow > mnMaxAbsRow) )
             rRefData.SetRowDeleted( TRUE );
-        rXclPos.mnRow = static_cast< sal_uInt16 >( rnScRow ) & mnMaxRowMask;
+        rXclPos.mnRow = static_cast< sal_uInt32 >( rnScRow ) & mnMaxRowMask;
     }
     else
     {
@@ -1874,8 +1874,8 @@ void XclExpFmlaCompImpl::ConvertRefData(
         rXclPos.mnCol = static_cast< sal_uInt16 >( nXclRelCol ) & mnMaxColMask;
 
         // convert row index (2-step-cast ScsROW->sal_Int16->sal_uInt16 to get all bits correctly)
-        sal_Int16 nXclRelRow = static_cast< sal_Int16 >( rRefData.IsRowRel() ? rRefData.nRelRow : rRefData.nRow );
-        rXclPos.mnRow = static_cast< sal_uInt16 >( nXclRelRow ) & mnMaxRowMask;
+        sal_Int32 nXclRelRow = static_cast< sal_Int32 >( rRefData.IsRowRel() ? rRefData.nRelRow : rRefData.nRow );
+        rXclPos.mnRow = static_cast< sal_uInt32 >( nXclRelRow ) & mnMaxRowMask;
     }
 
     // flags for relative column and row
@@ -1887,9 +1887,16 @@ void XclExpFmlaCompImpl::ConvertRefData(
     }
     else
     {
-        sal_uInt16& rnRelField = (meBiff <= EXC_BIFF5) ? rXclPos.mnRow : rXclPos.mnCol;
-        ::set_flag( rnRelField, EXC_TOK_REF_COLREL, rRefData.IsColRel() );
-        ::set_flag( rnRelField, EXC_TOK_REF_ROWREL, rRefData.IsRowRel() );
+        if (meBiff <= EXC_BIFF5)
+        {
+            ::set_flag( rXclPos.mnRow, EXC_TOK_REF_ROWREL, rRefData.IsColRel() );
+            ::set_flag( rXclPos.mnRow, EXC_TOK_REF_ROWREL, rRefData.IsRowRel() );
+        }
+        else
+        {
+            ::set_flag( rXclPos.mnCol, EXC_TOK_REF_COLREL, rRefData.IsColRel() );
+            ::set_flag( rXclPos.mnCol, EXC_TOK_REF_COLREL, rRefData.IsRowRel() );
+        }
     }
 }
 
@@ -2540,7 +2547,10 @@ void XclExpFmlaCompImpl::ProcessMatrix( const XclExpTokenData& rTokData, sal_uIn
 
         AppendOpTokenId( GetTokenId( EXC_TOKID_ARRAY, EXC_TOKCLASS_ARR ), nExpClass, rTokData.mnSpaces );
         Append( static_cast< sal_uInt8 >( (meBiff == EXC_BIFF8) ? (nCols - 1) : nCols ) );
-        Append( static_cast< sal_uInt16 >( (meBiff == EXC_BIFF8) ? (nRows - 1) : nRows ) );
+        if (meBiff == EXC_BIFF8)
+            Append( static_cast< sal_uInt16 > ( nRows - 1 ) );
+        else
+            Append( static_cast< sal_uInt16 > ( nRows - 1 ) );
         Append( static_cast< sal_uInt32 >( 0 ) );
 
         if( !mxInlineArr )
diff --git sc/source/filter/xlsx/xlsx-xehelper.cxx sc/source/filter/xlsx/xlsx-xehelper.cxx
index 7dbe4b8..ca3fc38 100644
--- sc/source/filter/xlsx/xlsx-xehelper.cxx
+++ sc/source/filter/xlsx/xlsx-xehelper.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include <com/sun/star/i18n/XBreakIterator.hpp>
 #include <com/sun/star/i18n/ScriptType.hpp>
 #include <sfx2/objsh.hxx>
@@ -159,7 +162,7 @@ namespace {
 inline void lclFillAddress( XclAddress& rXclPos, SCCOL nScCol, SCROW nScRow )
 {
     rXclPos.mnCol = static_cast< sal_uInt16 >( nScCol );
-    rXclPos.mnRow = static_cast< sal_uInt16 >( nScRow );
+    rXclPos.mnRow = static_cast< sal_uInt32 >( nScRow );
 }
 
 } // namespace
diff --git sc/source/filter/xlsx/xlsx-xelink.cxx sc/source/filter/xlsx/xlsx-xelink.cxx
index 0277877..66dc667 100644
--- sc/source/filter/xlsx/xlsx-xelink.cxx
+++ sc/source/filter/xlsx/xlsx-xelink.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xelink.hxx"
 
 #include <algorithm>
diff --git sc/source/filter/xlsx/xlsx-xename.cxx sc/source/filter/xlsx/xlsx-xename.cxx
index 9bd6ac4..3cf1e7f 100644
--- sc/source/filter/xlsx/xlsx-xename.cxx
+++ sc/source/filter/xlsx/xlsx-xename.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xename.hxx"
 
 #include <map>
diff --git sc/source/filter/xlsx/xlsx-xepage.cxx sc/source/filter/xlsx/xlsx-xepage.cxx
index f99b732..d79e950 100644
--- sc/source/filter/xlsx/xlsx-xepage.cxx
+++ sc/source/filter/xlsx/xlsx-xepage.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "xepage.hxx"
 #include <svtools/itemset.hxx>
@@ -310,7 +313,7 @@ XclExpPageSettings::XclExpPageSettings( const XclExpRoot& rRoot ) :
     set<SCROW> aRowBreaks;
     rDoc.GetAllRowBreaks(aRowBreaks, nScTab, false, true);
 
-    SCROW nMaxRow = numeric_limits<sal_uInt16>::max();
+    SCROW nMaxRow = numeric_limits<sal_uInt32>::max();
     for (set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end(); itr != itrEnd; ++itr)
     {
         SCROW nRow = *itr;
diff --git sc/source/filter/xlsx/xlsx-xepivot.cxx sc/source/filter/xlsx/xlsx-xepivot.cxx
index c19bee2..57409c1 100644
--- sc/source/filter/xlsx/xlsx-xepivot.cxx
+++ sc/source/filter/xlsx/xlsx-xepivot.cxx
@@ -1593,9 +1593,9 @@ void XclExpPivotTable::Finalize()
 
     // update output range (initialized in ctor)
     sal_uInt16& rnXclCol1 = maPTInfo.maOutXclRange.maFirst.mnCol;
-    sal_uInt16& rnXclRow1 = maPTInfo.maOutXclRange.maFirst.mnRow;
+    sal_uInt32& rnXclRow1 = maPTInfo.maOutXclRange.maFirst.mnRow;
     sal_uInt16& rnXclCol2 = maPTInfo.maOutXclRange.maLast.mnCol;
-    sal_uInt16& rnXclRow2 = maPTInfo.maOutXclRange.maLast.mnRow;
+    sal_uInt32& rnXclRow2 = maPTInfo.maOutXclRange.maLast.mnRow;
     // exclude page fields from output range
     rnXclRow1 = rnXclRow1 + maPTInfo.mnPageFields;
     // exclude filter button from output range
@@ -1607,7 +1607,7 @@ void XclExpPivotTable::Finalize()
 
     // data area
     sal_uInt16& rnDataXclCol = maPTInfo.maDataXclPos.mnCol;
-    sal_uInt16& rnDataXclRow = maPTInfo.maDataXclPos.mnRow;
+    sal_uInt32& rnDataXclRow = maPTInfo.maDataXclPos.mnRow;
     rnDataXclCol = rnXclCol1 + maPTInfo.mnRowFields;
     rnDataXclRow = rnXclRow1 + maPTInfo.mnColFields + 1;
     if( maDataFields.empty() )
diff --git sc/source/filter/xlsx/xlsx-xerecord.cxx sc/source/filter/xlsx/xlsx-xerecord.cxx
index 8b927c5..225b030 100644
--- sc/source/filter/xlsx/xlsx-xerecord.cxx
+++ sc/source/filter/xlsx/xlsx-xerecord.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xerecord.hxx"
 #include "xeroot.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-xeroot.cxx sc/source/filter/xlsx/xlsx-xeroot.cxx
index 600a928..0e76f05 100644
--- sc/source/filter/xlsx/xlsx-xeroot.cxx
+++ sc/source/filter/xlsx/xlsx-xeroot.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include <sfx2/docfile.hxx>
 #include <sfx2/sfxsids.hrc>
 #include <svtools/saveopt.hxx>
diff --git sc/source/filter/xlsx/xlsx-xestream.cxx sc/source/filter/xlsx/xlsx-xestream.cxx
index 14bc6b4..0568512 100644
--- sc/source/filter/xlsx/xlsx-xestream.cxx
+++ sc/source/filter/xlsx/xlsx-xestream.cxx
@@ -802,8 +802,8 @@ static ScAddress lcl_ToAddress( const XclAddress& rAddress )
     // For some reason, ScRange::Format() returns omits row numbers if 
     // the row is >= MAXROW or the column is >= MAXCOL, and Excel doesn't 
     // like "A:IV" (i.e. no row numbers).  Prevent this.
-    aAddress.SetRow( std::min<sal_Int32>( rAddress.mnRow, MAXROW-1 ) );
-    aAddress.SetCol( static_cast<sal_Int16>(std::min<sal_Int32>( rAddress.mnCol, MAXCOL-1 )) );
+    aAddress.SetRow( std::min<sal_Int32>( rAddress.mnRow, MAXROW ) );
+    aAddress.SetCol( static_cast<sal_Int16>(std::min<sal_Int32>( rAddress.mnCol, MAXCOL )) );
 
     return aAddress;
 }
diff --git sc/source/filter/xlsx/xlsx-xetable.cxx sc/source/filter/xlsx/xlsx-xetable.cxx
index 92dd71e..bf7af82 100644
--- sc/source/filter/xlsx/xlsx-xetable.cxx
+++ sc/source/filter/xlsx/xlsx-xetable.cxx
@@ -31,7 +31,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 #include "xestream.hxx"
-#include "xetable.hxx"
+#include "xlsx/xetable.hxx"
 
 #include <map>
 #include <com/sun/star/i18n/ScriptType.hpp>
@@ -81,7 +81,7 @@ XclExpRangeFmlaBase::XclExpRangeFmlaBase(
     maXclRange( ScAddress::UNINITIALIZED ),
     maBaseXclPos( ScAddress::UNINITIALIZED )
 {
-    maBaseXclPos.Set( static_cast< sal_uInt16 >( rScPos.Col() ), static_cast< sal_uInt16 >( rScPos.Row() ) );
+    maBaseXclPos.Set( static_cast< sal_uInt16 >( rScPos.Col() ), static_cast< sal_uInt32 >( rScPos.Row() ) );
     maXclRange.maFirst = maXclRange.maLast = maBaseXclPos;
 }
 
@@ -93,13 +93,13 @@ XclExpRangeFmlaBase::XclExpRangeFmlaBase(
 {
     maXclRange.Set(
         static_cast< sal_uInt16 >( rScRange.aStart.Col() ),
-        static_cast< sal_uInt16 >( rScRange.aStart.Row() ),
+        static_cast< sal_uInt32 >( rScRange.aStart.Row() ),
         static_cast< sal_uInt16 >( rScRange.aEnd.Col() ),
-        static_cast< sal_uInt16 >( rScRange.aEnd.Row() ) );
+        static_cast< sal_uInt32 >( rScRange.aEnd.Row() ) );
     maBaseXclPos = maXclRange.maFirst;
 }
 
-bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
+bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const
 {
     return (maBaseXclPos.mnCol == nXclCol) && (maBaseXclPos.mnRow == nXclRow);
 }
@@ -107,7 +107,7 @@ bool XclExpRangeFmlaBase::IsBasePos( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) co
 void XclExpRangeFmlaBase::Extend( const ScAddress& rScPos )
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( rScPos.Col() );
-    sal_uInt16 nXclRow = static_cast< sal_uInt16 >( rScPos.Row() );
+    sal_uInt32 nXclRow = static_cast< sal_uInt32 >( rScPos.Row() );
     maXclRange.maFirst.mnCol = ::std::min( maXclRange.maFirst.mnCol, nXclCol );
     maXclRange.maFirst.mnRow = ::std::min( maXclRange.maFirst.mnRow, nXclRow );
     maXclRange.maLast.mnCol  = ::std::max( maXclRange.maLast.mnCol,  nXclCol );
@@ -252,9 +252,9 @@ XclExpTableop::XclExpTableop( const ScAddress& rScPos,
     XclExpRangeFmlaBase( EXC_ID3_TABLEOP, 16, rScPos ),
     mnLastAppXclCol( static_cast< sal_uInt16 >( rScPos.Col() ) ),
     mnColInpXclCol( static_cast< sal_uInt16 >( rRefs.maColFirstScPos.Col() ) ),
-    mnColInpXclRow( static_cast< sal_uInt16 >( rRefs.maColFirstScPos.Row() ) ),
+    mnColInpXclRow( static_cast< sal_uInt32 >( rRefs.maColFirstScPos.Row() ) ),
     mnRowInpXclCol( static_cast< sal_uInt16 >( rRefs.maRowFirstScPos.Col() ) ),
-    mnRowInpXclRow( static_cast< sal_uInt16 >( rRefs.maRowFirstScPos.Row() ) ),
+    mnRowInpXclRow( static_cast< sal_uInt32 >( rRefs.maRowFirstScPos.Row() ) ),
     mnScMode( nScMode ),
     mbValid( false )
 {
@@ -263,7 +263,7 @@ XclExpTableop::XclExpTableop( const ScAddress& rScPos,
 bool XclExpTableop::TryExtend( const ScAddress& rScPos, const XclMultipleOpRefs& rRefs )
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( rScPos.Col() );
-    sal_uInt16 nXclRow = static_cast< sal_uInt16 >( rScPos.Row() );
+    sal_uInt32 nXclRow = static_cast< sal_uInt32 >( rScPos.Row() );
 
     bool bOk = IsAppendable( nXclCol, nXclRow );
     if( bOk )
@@ -374,7 +374,7 @@ void XclExpTableop::Save( XclExpStream& rStrm )
         XclExpRangeFmlaBase::Save( rStrm );
 }
 
-bool XclExpTableop::IsAppendable( sal_uInt16 nXclCol, sal_uInt16 nXclRow ) const
+bool XclExpTableop::IsAppendable( sal_uInt16 nXclCol, sal_uInt32 nXclRow ) const
 {
     return  ((nXclCol == mnLastAppXclCol + 1) && (nXclRow == maXclRange.maFirst.mnRow)) ||
             ((nXclCol == mnLastAppXclCol + 1) && (nXclCol <= maXclRange.maLast.mnCol) && (nXclRow == maXclRange.maLast.mnRow)) ||
@@ -1747,7 +1747,7 @@ void XclExpDefrowheight::WriteBody( XclExpStream& rStrm )
 
 // ----------------------------------------------------------------------------
 
-XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
+XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt32 nXclRow,
         XclExpRowOutlineBuffer& rOutlineBfr, bool bAlwaysEmpty ) :
     XclExpRecord( EXC_ID3_ROW, 16 ),
     XclExpRoot( rRoot ),
@@ -2061,7 +2061,7 @@ void XclExpRowBuffer::AppendCell( XclExpCellRef xCell, bool bIsMergedBase )
 void XclExpRowBuffer::CreateRows( SCROW nFirstFreeScRow )
 {
     if( nFirstFreeScRow > 0 )
-        GetOrCreateRow( static_cast< sal_uInt16 >( nFirstFreeScRow - 1 ), true );
+        GetOrCreateRow( static_cast< sal_uInt32 >( nFirstFreeScRow - 1 ), true );
 }
 
 void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt16Vec& rColXFIndexes )
@@ -2092,7 +2092,7 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         #i59220# Tolerance of +-128 rows for inserted/removed rows. */
     if( (nDefaultXclRow < 31872) || (nDefaultXclRow > 32128) )
     {
-        sal_uInt16 nLastXclRow = static_cast< sal_uInt16 >( GetMaxPos().Row() );
+        sal_uInt32 nLastXclRow = static_cast< sal_uInt32 >( GetMaxPos().Row() );
         if( nDefaultXclRow <= nLastXclRow )
         {
             // create a dummy ROW record and fill aMaxDefData
@@ -2154,7 +2154,7 @@ void XclExpRowBuffer::Finalize( XclExpDefaultRowData& rDefRowData, const ScfUInt
         // find used row range
         if( xRow->IsEnabled() )
         {
-            sal_uInt16 nXclRow = xRow->GetXclRow();
+            sal_uInt32 nXclRow = xRow->GetXclRow();
             nFirstUsedXclRow = ::std::min< sal_uInt32 >( nFirstUsedXclRow, nXclRow );
             nFirstFreeXclRow = ::std::max< sal_uInt32 >( nFirstFreeXclRow, nXclRow + 1 );
         }
@@ -2177,7 +2177,7 @@ void XclExpRowBuffer::Save( XclExpStream& rStrm )
     // save in blocks of 32 rows, each block contains first all ROWs, then all cells
     size_t nSize = maRowList.GetSize();
     size_t nBlockStart = 0;
-    sal_uInt16 nStartXclRow = (nSize == 0) ? 0 : maRowList.GetRecord( 0 )->GetXclRow();
+    sal_uInt32 nStartXclRow = (nSize == 0) ? 0 : maRowList.GetRecord( 0 )->GetXclRow();
 
     while( nBlockStart < nSize )
     {
@@ -2227,7 +2227,7 @@ XclExpDimensions* XclExpRowBuffer::GetDimensions()
     return &maDimensions;
 }
 
-XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysEmpty )
+XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt32 nXclRow, bool bRowAlwaysEmpty )
 {
     if( !mpLastUsedRow || (mnLastUsedXclRow != nXclRow) )
     {
@@ -2235,7 +2235,7 @@ XclExpRow& XclExpRowBuffer::GetOrCreateRow( sal_uInt16 nXclRow, bool bRowAlwaysE
         // do not use sal_uInt16 for nFirstFreeXclRow, would cause loop in full sheets
         for( size_t nFirstFreeXclRow = maRowList.GetSize(); nFirstFreeXclRow <= nXclRow; ++nFirstFreeXclRow )
             maRowList.AppendNewRecord( new XclExpRow(
-                GetRoot(), static_cast< sal_uInt16 >( nFirstFreeXclRow ), maOutlineBfr, bRowAlwaysEmpty ) );
+                GetRoot(), static_cast< sal_uInt32 >( nFirstFreeXclRow ), maOutlineBfr, bRowAlwaysEmpty ) );
 
         mpLastUsedRow = maRowList.GetRecord( nXclRow ).get();
         mnLastUsedXclRow = nXclRow;
@@ -2320,7 +2320,7 @@ XclExpCellTable::XclExpCellTable( const XclExpRoot& rRoot ) :
         SCCOL nLastScCol = aIt.GetEndCol();
         ScAddress aScPos( nScCol, nScRow, nScTab );
 
-        XclAddress aXclPos( static_cast< sal_uInt16 >( nScCol ), static_cast< sal_uInt16 >( nScRow ) );
+        XclAddress aXclPos( static_cast< sal_uInt16 >( nScCol ), static_cast< sal_uInt32 >( nScRow ) );
         sal_uInt16 nLastXclCol = static_cast< sal_uInt16 >( nLastScCol );
 
         const ScBaseCell* pScCell = aIt.GetCell();
diff --git sc/source/filter/xlsx/xlsx-xeview.cxx sc/source/filter/xlsx/xlsx-xeview.cxx
index d15634b..4cf8efb 100644
--- sc/source/filter/xlsx/xlsx-xeview.cxx
+++ sc/source/filter/xlsx/xlsx-xeview.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xeview.hxx"
 #include "document.hxx"
 #include "scextopt.hxx"
diff --git sc/source/filter/xlsx/xlsx-xichart.cxx sc/source/filter/xlsx/xlsx-xichart.cxx
index 77d9eae..fb19b0c 100644
--- sc/source/filter/xlsx/xlsx-xichart.cxx
+++ sc/source/filter/xlsx/xlsx-xichart.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "xichart.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-xicontent.cxx sc/source/filter/xlsx/xlsx-xicontent.cxx
index abc5d02..a6f1dad 100644
--- sc/source/filter/xlsx/xlsx-xicontent.cxx
+++ sc/source/filter/xlsx/xlsx-xicontent.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xicontent.hxx"
 #include <sfx2/objsh.hxx>
 #include <sfx2/docfile.hxx>
diff --git sc/source/filter/xlsx/xlsx-xiescher.cxx sc/source/filter/xlsx/xlsx-xiescher.cxx
index b1ea638..3751674 100644
--- sc/source/filter/xlsx/xlsx-xiescher.cxx
+++ sc/source/filter/xlsx/xlsx-xiescher.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "xiescher.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-xiformula.cxx sc/source/filter/xlsx/xlsx-xiformula.cxx
index 240358e..5ae34f1 100644
--- sc/source/filter/xlsx/xlsx-xiformula.cxx
+++ sc/source/filter/xlsx/xlsx-xiformula.cxx
@@ -29,6 +29,8 @@
  ************************************************************************/
 
 #include "precompiled_sc.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xiformula.hxx"
 #include "rangelst.hxx"
 #include "xistream.hxx"
diff --git sc/source/filter/xlsx/xlsx-xihelper.cxx sc/source/filter/xlsx/xlsx-xihelper.cxx
index 0e44ba6..d2fd000 100644
--- sc/source/filter/xlsx/xlsx-xihelper.cxx
+++ sc/source/filter/xlsx/xlsx-xihelper.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xihelper.hxx"
 #include <svtools/itemset.hxx>
 #include <svx/editobj.hxx>
@@ -126,7 +129,7 @@ bool XclImpAddressConverter::ConvertRange( ScRange& rScRange,
 
         // check & correct end position
         sal_uInt16 nXclCol2 = rXclRange.maLast.mnCol;
-        sal_uInt16 nXclRow2 = rXclRange.maLast.mnRow;
+        sal_uInt32 nXclRow2 = rXclRange.maLast.mnRow;
         if( !CheckAddress( rXclRange.maLast, bWarn ) )
         {
             nXclCol2 = ::std::min( nXclCol2, mnMaxCol );
diff --git sc/source/filter/xlsx/xlsx-xilink.cxx sc/source/filter/xlsx/xlsx-xilink.cxx
index 2c24263..3f9cb2a 100644
--- sc/source/filter/xlsx/xlsx-xilink.cxx
+++ sc/source/filter/xlsx/xlsx-xilink.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xilink.hxx"
 #include "document.hxx"
 #include "cell.hxx"
diff --git sc/source/filter/xlsx/xlsx-xiname.cxx sc/source/filter/xlsx/xlsx-xiname.cxx
index 72f4701..84e8098 100644
--- sc/source/filter/xlsx/xlsx-xiname.cxx
+++ sc/source/filter/xlsx/xlsx-xiname.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xiname.hxx"
 #include "rangenam.hxx"
 #include "xistream.hxx"
diff --git sc/source/filter/xlsx/xlsx-xipage.cxx sc/source/filter/xlsx/xlsx-xipage.cxx
index cb1aba2..d1ab698 100644
--- sc/source/filter/xlsx/xlsx-xipage.cxx
+++ sc/source/filter/xlsx/xlsx-xipage.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xipage.hxx"
 #include <svtools/itemset.hxx>
 #include <vcl/graph.hxx>
diff --git sc/source/filter/xlsx/xlsx-xipivot.cxx sc/source/filter/xlsx/xlsx-xipivot.cxx
index fd85060..23ac48a 100644
--- sc/source/filter/xlsx/xlsx-xipivot.cxx
+++ sc/source/filter/xlsx/xlsx-xipivot.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "xipivot.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-xiroot.cxx sc/source/filter/xlsx/xlsx-xiroot.cxx
index 55ba4bd..63985cb 100644
--- sc/source/filter/xlsx/xlsx-xiroot.cxx
+++ sc/source/filter/xlsx/xlsx-xiroot.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xiroot.hxx"
 #include "addincol.hxx"
 #include "xltracer.hxx"
diff --git sc/source/filter/xlsx/xlsx-xistream.cxx sc/source/filter/xlsx/xlsx-xistream.cxx
index 7b19660..89a9302 100644
--- sc/source/filter/xlsx/xlsx-xistream.cxx
+++ sc/source/filter/xlsx/xlsx-xistream.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 // ============================================================================
 #include "xistream.hxx"
diff --git sc/source/filter/xlsx/xlsx-xistring.cxx sc/source/filter/xlsx/xlsx-xistring.cxx
index 5e785ca..b67db15 100644
--- sc/source/filter/xlsx/xlsx-xistring.cxx
+++ sc/source/filter/xlsx/xlsx-xistring.cxx
@@ -29,6 +29,9 @@
  ************************************************************************/
 
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xistring.hxx"
 #include "xlstyle.hxx"
 #include "xistream.hxx"
diff --git sc/source/filter/xlsx/xlsx-xistyle.cxx sc/source/filter/xlsx/xlsx-xistyle.cxx
index d81bcc5..d63cbf8 100644
--- sc/source/filter/xlsx/xlsx-xistyle.cxx
+++ sc/source/filter/xlsx/xlsx-xistyle.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xistyle.hxx"
 #include <sfx2/printer.hxx>
 #include <sfx2/objsh.hxx>
diff --git sc/source/filter/xlsx/xlsx-xiview.cxx sc/source/filter/xlsx/xlsx-xiview.cxx
index ce76483..39a8678 100644
--- sc/source/filter/xlsx/xlsx-xiview.cxx
+++ sc/source/filter/xlsx/xlsx-xiview.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "xiview.hxx"
 #include "document.hxx"
 #include "scextopt.hxx"
diff --git sc/source/filter/xlsx/xlsx-xladdress.cxx sc/source/filter/xlsx/xlsx-xladdress.cxx
index 290a7dc..5455d2c 100644
--- sc/source/filter/xlsx/xlsx-xladdress.cxx
+++ sc/source/filter/xlsx/xlsx-xladdress.cxx
@@ -30,7 +30,7 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
-#include "xladdress.hxx"
+#include "xlsx/xladdress.hxx"
 #include "xestream.hxx"
 #include "xltracer.hxx"
 #include "xistream.hxx"
diff --git sc/source/filter/xlsx/xlsx-xlchart.cxx sc/source/filter/xlsx/xlsx-xlchart.cxx
index 76253fc..50d4095 100644
--- sc/source/filter/xlsx/xlsx-xlchart.cxx
+++ sc/source/filter/xlsx/xlsx-xlchart.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 
 #include "xlchart.hxx"
 
diff --git sc/source/filter/xlsx/xlsx-xlescher.cxx sc/source/filter/xlsx/xlsx-xlescher.cxx
index a2a64b8..841eeb7 100644
--- sc/source/filter/xlsx/xlsx-xlescher.cxx
+++ sc/source/filter/xlsx/xlsx-xlescher.cxx
@@ -137,7 +137,7 @@ void lclGetColFromX(
 /** Calculates an object row position from a drawing layer Y position (in twips). */
 void lclGetRowFromY(
         ScDocument& rDoc, SCTAB nScTab,
-        sal_uInt16& rnXclRow, sal_uInt16& rnOffset, sal_uInt16 nXclStartRow,
+        sal_uInt32& rnXclRow, sal_uInt16& rnOffset, sal_uInt32 nXclStartRow,
         long& rnStartH, long nY, double fScale )
 {
     // rnStartH in conjunction with nXclStartRow is used as buffer for previously calculated height
diff --git sc/source/filter/xlsx/xlsx-xlformula.cxx sc/source/filter/xlsx/xlsx-xlformula.cxx
index 94b3951..c55c02a 100644
--- sc/source/filter/xlsx/xlsx-xlformula.cxx
+++ sc/source/filter/xlsx/xlsx-xlformula.cxx
@@ -31,7 +31,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 #include "xestream.hxx"
-#include "xlformula.hxx"
+#include "xlsx/xlformula.hxx"
 #include "compiler.hxx"
 #include "rangenam.hxx"
 #include "xlroot.hxx"
diff --git sc/source/filter/xlsx/xlsx-xlpage.cxx sc/source/filter/xlsx/xlsx-xlpage.cxx
index e9a8142..66920a6 100644
--- sc/source/filter/xlsx/xlsx-xlpage.cxx
+++ sc/source/filter/xlsx/xlsx-xlpage.cxx
@@ -30,6 +30,7 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xlconst.hxx"
 #include "xlpage.hxx"
 #include <sfx2/printer.hxx>
 #include <svx/svxenum.hxx>
diff --git sc/source/filter/xlsx/xlsx-xlpivot.cxx sc/source/filter/xlsx/xlsx-xlpivot.cxx
index c915903..9568c09 100644
--- sc/source/filter/xlsx/xlsx-xlpivot.cxx
+++ sc/source/filter/xlsx/xlsx-xlpivot.cxx
@@ -30,6 +30,9 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
+#include "xlsx/xlconst.hxx"
+#include "xlsx/xlformula.hxx"
 #include "dpgroup.hxx"
 #include "dpsave.hxx"
 #include "xestream.hxx"
diff --git sc/source/filter/xlsx/xlsx-xlroot.cxx sc/source/filter/xlsx/xlsx-xlroot.cxx
index 8f5ddad..4f218e4 100644
--- sc/source/filter/xlsx/xlsx-xlroot.cxx
+++ sc/source/filter/xlsx/xlsx-xlroot.cxx
@@ -30,6 +30,7 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xlconst.hxx"
 #include "xlroot.hxx"
 #include <com/sun/star/i18n/ScriptType.hpp>
 #include <vcl/svapp.hxx>
diff --git sc/source/filter/xlsx/xlsx-xlstyle.cxx sc/source/filter/xlsx/xlsx-xlstyle.cxx
index bd56de2..cb3ba62 100644
--- sc/source/filter/xlsx/xlsx-xlstyle.cxx
+++ sc/source/filter/xlsx/xlsx-xlstyle.cxx
@@ -31,6 +31,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include "xlsx/xlconst.hxx"
 #include "xlstyle.hxx"
 #include <com/sun/star/awt/FontFamily.hpp>
 #include <com/sun/star/awt/FontSlant.hpp>
diff --git sc/source/filter/xlsx/xlsx-xlview.cxx sc/source/filter/xlsx/xlsx-xlview.cxx
index 8580d7a..78d07ed 100644
--- sc/source/filter/xlsx/xlsx-xlview.cxx
+++ sc/source/filter/xlsx/xlsx-xlview.cxx
@@ -30,6 +30,7 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
+#include "xlsx/xladdress.hxx"
 #include "xlview.hxx"
 #include "ftools.hxx"
 
-- 
1.6.0.rc1.49.g98a8

