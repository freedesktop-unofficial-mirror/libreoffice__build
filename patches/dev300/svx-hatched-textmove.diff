--- svx/inc/svx/svdhdl.hxx	6 Jul 2007 13:17:50 -0000	1.3
+++ svx/inc/svx/svdhdl.hxx	19 May 2008 00:23:59 -0000
@@ -442,6 +442,19 @@ public:
 };
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////
+
+class ImpTextframeHdl: public SdrHdl
+{
+    const Rectangle maRect;
+
+	// create marker for this kind
+	virtual void CreateB2dIAObject();
+
+public:
+	explicit ImpTextframeHdl(const Rectangle& rRect);
+};
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ svx/inc/svx/sdr/overlay/overlayhatchrect.hxx	19 May 2008 00:23:59 -0000
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: overlaybitmap.hxx,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: ihi $ $Date: 2006/11/14 13:06:40 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SDR_OVERLAY_OVERLAYHATCHRECT_HXX
+#define _SDR_OVERLAY_OVERLAYHATCHRECT_HXX
+
+#include <svx/sdr/overlay/overlayobject.hxx>
+#include <vcl/hatch.hxx>
+#include <tools/gen.hxx>
+
+//////////////////////////////////////////////////////////////////////////////
+
+class PolyPolygon;
+
+namespace sdr
+{
+	namespace overlay
+	{
+		class OverlayHatchRect : public OverlayObjectWithBasePosition
+		{
+            // the actual hatching to use
+            const Hatch            maHatch;
+            const sal_Int32        mnWidthPixel;
+            const sal_Int32        mnRotAngle;
+			basegfx::B2DPoint		maSecondPosition;
+
+            PolyPolygon getGeometry(OutputDevice& rOutputDevice);
+
+			// Draw geometry
+			virtual void drawGeometry(OutputDevice& rOutputDevice);
+
+			// Create the BaseRange. This method needs to calculate maBaseRange.
+			virtual void createBaseRange(OutputDevice& rOutputDevice);
+
+		public:
+			OverlayHatchRect(
+				const basegfx::B2DPoint& rBasePos,
+				const Hatch& rHatch,
+                sal_Int32 nRotAngle,
+                sal_Int32 nWidthPixel );
+
+			const basegfx::B2DPoint& getSecondPosition() const { return maSecondPosition; }
+            void setSecondPosition(const basegfx::B2DPoint&);
+
+			// Zoom has changed. If the objects logical size
+			// depends on the MapMode of the used OutputDevice, use this call
+			// to invalidate the range in logical coordinates.
+			virtual void zoomHasChanged();
+		};
+	} // end of namespace overlay
+} // end of namespace sdr
+
+//////////////////////////////////////////////////////////////////////////////
+
+#endif //_SDR_OVERLAY_OVERLAYHATCHRECT_HXX
+
+// eof
--- svx/source/sdr/overlay/makefile.mk	17 Nov 2006 16:15:37 -0000	1.3
+++ svx/source/sdr/overlay/makefile.mk	19 May 2008 00:24:10 -0000
@@ -58,6 +58,7 @@ SLOFILES=\
 		$(SLO)$/overlaytriangle.obj				\
 		$(SLO)$/overlaycrosshair.obj			\
 		$(SLO)$/overlayhelpline.obj				\
+		$(SLO)$/overlayhatchrect.obj			\
 		$(SLO)$/overlayrollingrectangle.obj		\
 		$(SLO)$/overlaypolypolygon.obj			\
 		$(SLO)$/overlaysdrobject.obj
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ svx/source/sdr/overlay/overlayhatchrect.cxx	19 May 2008 00:24:10 -0000
@@ -0,0 +1,142 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: overlaybitmap.cxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author: obo $ $Date: 2007/07/18 10:54:23 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svx.hxx"
+
+#include <svx/sdr/overlay/overlayhatchrect.hxx>
+#include <vcl/hatch.hxx>
+#include <vcl/outdev.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
+
+//////////////////////////////////////////////////////////////////////////////
+
+namespace sdr
+{
+	namespace overlay
+	{
+        PolyPolygon OverlayHatchRect::getGeometry(OutputDevice& rOutputDevice)
+        {
+			const basegfx::B2DPoint aDiscreteTopLeft(rOutputDevice.GetViewTransformation() * getBasePosition());
+			const basegfx::B2DPoint aDiscreteBottomRight(rOutputDevice.GetViewTransformation() * getSecondPosition());
+
+			const Rectangle aPixRect((sal_Int32)floor(aDiscreteTopLeft.getX()), 
+                                     (sal_Int32)floor(aDiscreteTopLeft.getY()),
+                                     (sal_Int32)floor(aDiscreteBottomRight.getX()), 
+                                     (sal_Int32)floor(aDiscreteBottomRight.getY()));
+            
+			Rectangle aInnerRect(aPixRect);
+			aInnerRect.Left()+=mnWidthPixel;
+			aInnerRect.Top()+=mnWidthPixel;
+			aInnerRect.Right()-=mnWidthPixel;
+			aInnerRect.Bottom()-=mnWidthPixel;			
+
+			Rectangle aOuterPix(aPixRect);
+			aOuterPix.Left()-=mnWidthPixel;
+			aOuterPix.Top()-=mnWidthPixel;
+			aOuterPix.Right()+=mnWidthPixel;
+			aOuterPix.Bottom()+=mnWidthPixel;
+
+			PolyPolygon aPolyPoly( 2 );
+			aPolyPoly.Insert( aOuterPix );
+			aPolyPoly.Insert( aInnerRect );
+            aPolyPoly.Rotate(aPixRect.TopLeft(), mnRotAngle/10);
+
+            return aPolyPoly;
+        }
+
+		void OverlayHatchRect::drawGeometry(OutputDevice& rOutputDevice)
+		{
+			const PolyPolygon aPoly( getGeometry(rOutputDevice) );
+
+			const bool bMapModeWasEnabled(rOutputDevice.IsMapModeEnabled());
+			rOutputDevice.EnableMapMode(false);
+
+			rOutputDevice.DrawHatch( aPoly, maHatch );
+
+			// restore MapMode
+			rOutputDevice.EnableMapMode(bMapModeWasEnabled);
+		}
+
+		void OverlayHatchRect::createBaseRange(OutputDevice& rOutputDevice)
+		{
+			// reset range and expand it
+			maBaseRange.reset();
+
+            const Rectangle aBounds(getGeometry(rOutputDevice).GetBoundRect());
+
+            maBaseRange = basegfx::B2DRange(
+                aBounds.Left(),
+                aBounds.Top(),
+                aBounds.Right(),
+                aBounds.Bottom());
+			maBaseRange.transform(rOutputDevice.GetInverseViewTransformation());
+		}
+
+        OverlayHatchRect::OverlayHatchRect(
+				const basegfx::B2DPoint& rBasePos,
+				const Hatch& rHatch,
+                sal_Int32 nRotAngle,
+                sal_Int32 nWidthPixel) :
+            OverlayObjectWithBasePosition(rBasePos, Color(COL_TRANSPARENT)),
+            maHatch(rHatch),
+            mnWidthPixel(nWidthPixel),
+            mnRotAngle(nRotAngle),
+            maSecondPosition()
+		{
+		}
+
+		void OverlayHatchRect::setSecondPosition(const basegfx::B2DPoint& rNew)
+		{
+			if(rNew != maSecondPosition)
+			{
+				// remember new value
+				maSecondPosition = rNew;
+
+				// register change (after change)
+				objectChange();
+			}
+		}
+
+		void OverlayHatchRect::zoomHasChanged()
+		{
+			// reset validity of range in logical coor to force recalculation
+			mbIsChanged = sal_True;
+		}
+	} // end of namespace overlay
+} // end of namespace sdr
+
+//////////////////////////////////////////////////////////////////////////////
+// eof
--- svx/source/svdraw/svdhdl.cxx.orig	2008-04-11 04:58:52.000000000 +0200
+++ svx/source/svdraw/svdhdl.cxx	2008-05-19 23:14:30.000000000 +0200
@@ -66,6 +66,7 @@
 #include <svx/sdr/overlay/overlaybitmap.hxx>
 #include <svx/sdr/overlay/overlaylinestriped.hxx>
 #include <svx/sdr/overlay/overlaytriangle.hxx>
+#include <svx/sdr/overlay/overlayhatchrect.hxx>
 #include <svx/sdrpagewindow.hxx>
 #include <sdrpaintwindow.hxx>
 #include <vcl/svapp.hxx>
@@ -815,50 +816,49 @@
 Pointer SdrHdl::GetPointer() const
 {
     PointerStyle ePtr=POINTER_MOVE;
-    BOOL bSize=eKind>=HDL_UPLFT && eKind<=HDL_LWRGT;
-    // Fuer Resize von gedrehten Rechtecken die Mauszeiger etwas mitdrehen
-    if (bSize && nDrehWink!=0) 
-	{
-        long nHdlWink=0;
+    const BOOL bSize=eKind>=HDL_UPLFT && eKind<=HDL_LWRGT;
+    const BOOL bRot=pHdlList!=NULL && pHdlList->IsRotateShear();
+    const BOOL bDis=pHdlList!=NULL && pHdlList->IsDistortShear();
+    if (bSize && pHdlList!=NULL && (bRot || bDis)) {
         switch (eKind) {
-            case HDL_UPLFT: nHdlWink=13500; break;
-            case HDL_UPPER: nHdlWink=9000;  break;
-            case HDL_UPRGT: nHdlWink=4500;  break;
-            case HDL_LEFT : nHdlWink=0;     break;
-            case HDL_RIGHT: nHdlWink=0;     break;
-            case HDL_LWLFT: nHdlWink=4500;  break;
-            case HDL_LOWER: nHdlWink=9000;  break;
-            case HDL_LWRGT: nHdlWink=13500; break;
+            case HDL_UPLFT: case HDL_UPRGT:
+            case HDL_LWLFT: case HDL_LWRGT: ePtr=bRot ? POINTER_ROTATE : POINTER_REFHAND; break;
+            case HDL_LEFT : case HDL_RIGHT: ePtr=POINTER_VSHEAR; break;
+            case HDL_UPPER: case HDL_LOWER: ePtr=POINTER_HSHEAR; break;
             default:
                 break;
         }
-        nHdlWink+=nDrehWink+2249; // und etwas drauf (zum runden)
-        while (nHdlWink<0) nHdlWink+=18000;
-        while (nHdlWink>=18000) nHdlWink-=18000;
-        nHdlWink/=4500;
-        switch ((BYTE)nHdlWink) 
-		{
-            case 0: ePtr=POINTER_ESIZE;    break;
-            case 1: ePtr=POINTER_NESIZE; break;
-            case 2: ePtr=POINTER_SSIZE;    break;
-            case 3: ePtr=POINTER_SESIZE; break;
-        } // switch
-    }
-    if (ePtr==POINTER_MOVE) 
-	{
-        BOOL bRot=pHdlList!=NULL && pHdlList->IsRotateShear();
-        BOOL bDis=pHdlList!=NULL && pHdlList->IsDistortShear();
-        if (bSize && pHdlList!=NULL && (bRot || bDis)) 
-		{
+    } else {
+        // Fuer Resize von gedrehten Rechtecken die Mauszeiger etwas mitdrehen
+        if (bSize && nDrehWink!=0) {
+            long nHdlWink=0;
             switch (eKind) 
 			{
-                case HDL_UPLFT: case HDL_UPRGT:
-                case HDL_LWLFT: case HDL_LWRGT: ePtr=bRot ? POINTER_ROTATE : POINTER_REFHAND; break;
-                case HDL_LEFT : case HDL_RIGHT: ePtr=POINTER_VSHEAR; break;
-                case HDL_UPPER: case HDL_LOWER: ePtr=POINTER_HSHEAR; break;
+                case HDL_LWRGT: nHdlWink=31500; break;
+                case HDL_LOWER: nHdlWink=27000; break;
+                case HDL_LWLFT: nHdlWink=22500; break;
+                case HDL_LEFT : nHdlWink=18000; break;
+                case HDL_UPLFT: nHdlWink=13500; break;
+                case HDL_UPPER: nHdlWink=9000;  break;
+                case HDL_UPRGT: nHdlWink=4500;  break;
+                case HDL_RIGHT: nHdlWink=0;     break;
                 default:
                     break;
             }
+            nHdlWink+=nDrehWink+2249; // und etwas drauf (zum runden)
+            while (nHdlWink<0) nHdlWink+=36000;
+            while (nHdlWink>=36000) nHdlWink-=36000;
+            nHdlWink/=4500;
+            switch ((BYTE)nHdlWink) {
+                case 0: ePtr=POINTER_ESIZE;  break;
+                case 1: ePtr=POINTER_NESIZE; break;
+                case 2: ePtr=POINTER_NSIZE;  break;
+                case 3: ePtr=POINTER_NWSIZE; break;
+                case 4: ePtr=POINTER_WSIZE;  break;
+                case 5: ePtr=POINTER_SWSIZE; break;
+                case 6: ePtr=POINTER_SSIZE;  break;
+                case 7: ePtr=POINTER_SESIZE; break;
+            } // switch
         } 
 		else 
 		{
@@ -1641,6 +1645,66 @@
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 
+ImpTextframeHdl::ImpTextframeHdl(const Rectangle& rRect) : 
+    SdrHdl(rRect.TopLeft(),HDL_MOVE),
+    maRect(rRect)
+{
+}
+
+void ImpTextframeHdl::CreateB2dIAObject()
+{
+	// first throw away old one
+	GetRidOfIAObject();
+
+	if(pHdlList)
+	{
+		SdrMarkView* pView = pHdlList->GetView();
+
+		if(pView && !pView->areMarkHandlesHidden())
+		{
+			SdrPageView* pPageView = pView->GetSdrPageView();
+
+			if(pPageView)
+			{
+				for(sal_uInt32 b(0L); b < pPageView->PageWindowCount(); b++)
+				{
+					const SdrPageWindow& rPageWindow = *pPageView->GetPageWindow(b);
+
+					if(rPageWindow.GetPaintWindow().OutputToWindow())
+					{
+						if(rPageWindow.GetOverlayManager())
+						{
+                            const basegfx::B2DPoint aTopLeft(maRect.Left(), maRect.Top());
+                            const basegfx::B2DPoint aBottomRight(maRect.Right(), maRect.Bottom());
+
+                            svtools::ColorConfig aColorConfig;
+                            Color aHatchCol( aColorConfig.GetColorValue( svtools::FONTCOLOR ).nColor );
+
+                            ::sdr::overlay::OverlayHatchRect* pNewOverlayObject = 
+                                  new ::sdr::overlay::OverlayHatchRect(
+                                      aTopLeft,
+                                      Hatch(HATCH_SINGLE, aHatchCol, 3, 450),
+                                      nDrehWink,
+                                      4 );
+                            pNewOverlayObject->setHittable(false);
+                            pNewOverlayObject->setSecondPosition(aBottomRight);
+
+                            // OVERLAYMANAGER
+                            if(pNewOverlayObject)
+                            {
+                                rPageWindow.GetOverlayManager()->add(*pNewOverlayObject);
+                                maOverlayGroup.append(*pNewOverlayObject);
+                            }
+                        }
+                    }
+                }
+            }
+		}
+	}
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
 class ImpSdrHdlListSorter: public ContainerSorter {
 public:
     ImpSdrHdlListSorter(Container& rNewCont): ContainerSorter(rNewCont) {}
--- svx/source/svdraw/svdmrkv.cxx.orig	2008-05-19 16:16:36.000000000 +0200
+++ svx/source/svdraw/svdmrkv.cxx	2008-05-19 23:16:25.000000000 +0200
@@ -709,10 +709,15 @@
 	{
 		ULONG nMarkAnz=GetMarkedObjectCount();
 		BOOL bStdDrag=eDragMode==SDRDRAG_MOVE;
-		
+		BOOL bSingleTextObjMark=FALSE;
+
 		if (nMarkAnz==1) 
 		{
 			pMarkedObj=GetMarkedObjectByIndex(0);
+            bSingleTextObjMark = 
+                pMarkedObj && 
+                pMarkedObj->ISA(SdrTextObj) &&
+                static_cast<SdrTextObj*>(pMarkedObj)->IsTextFrame();
 		}
 		
 		BOOL bFrmHdl=ImpIsFrameHandles();
@@ -745,8 +750,20 @@
 			
 			if(!aRect.IsEmpty() && !bHideHandlesWhenInTextEdit) 
 			{ // sonst nix gefunden
-
-				if( eDragMode==SDRDRAG_CROP )
+                if( bSingleTextObjMark )
+                {
+                    const ULONG nSiz0=aHdl.GetHdlCount();
+                    pMarkedObj->AddToHdlList(aHdl);
+                    const ULONG nSiz1=aHdl.GetHdlCount();
+                    for (ULONG i=nSiz0; i<nSiz1; i++) 
+                    {
+                        SdrHdl* pHdl=aHdl.GetHdl(i);
+                        pHdl->SetObj(pMarkedObj);
+                        pHdl->SetPageView(pMarkedPV);
+                        pHdl->SetObjHdlNum(USHORT(i-nSiz0));
+                    }
+                }
+                else if( eDragMode==SDRDRAG_CROP )
 				{
 					aHdl.AddHdl(new SdrCropHdl(aRect.TopLeft()     ,HDL_UPLFT));
 					aHdl.AddHdl(new SdrCropHdl(aRect.TopCenter()   ,HDL_UPPER));
@@ -791,9 +808,9 @@
 				const SdrMark* pM=GetSdrMarkByIndex(nMarkNum);
 				SdrObject* pObj=pM->GetMarkedSdrObj();
 				SdrPageView* pPV=pM->GetPageView();
-				ULONG nSiz0=aHdl.GetHdlCount();
+				const ULONG nSiz0=aHdl.GetHdlCount();
 				pObj->AddToHdlList(aHdl);
-				ULONG nSiz1=aHdl.GetHdlCount();
+				const ULONG nSiz1=aHdl.GetHdlCount();
 				bool bPoly=pObj->IsPolyObj();
 				const SdrUShortCont* pMrkPnts=pM->GetMarkedPoints();
 				for (ULONG i=nSiz0; i<nSiz1; i++) 

--- svx/source/svdraw/svdorect.cxx	26 Nov 2007 14:56:13 -0000	1.29
+++ svx/source/svdraw/svdorect.cxx	19 May 2008 00:24:14 -0000
@@ -595,25 +595,35 @@ SdrHdl* SdrRectObj::GetHdl(sal_uInt32 nH
 	SdrHdl* pH=NULL;
 	Point aPnt;
 	SdrHdlKind eKind=HDL_MOVE;
-	switch (nHdlNum) {
-		case 0: {
-			long a=GetEckenradius();
-			long b=Max(aRect.GetWidth(),aRect.GetHeight())/2; // Wird aufgerundet, da GetWidth() eins draufaddiert
-			if (a>b) a=b;
-			if (a<0) a=0;
-			aPnt=aRect.TopLeft();
-			aPnt.X()+=a;
-			eKind=HDL_CIRC;
-		} break; // Eckenradius
-		case 1: aPnt=aRect.TopLeft();      eKind=HDL_UPLFT; break; // Oben links
-		case 2: aPnt=aRect.TopCenter();    eKind=HDL_UPPER; break; // Oben
-		case 3: aPnt=aRect.TopRight();     eKind=HDL_UPRGT; break; // Oben rechts
-		case 4: aPnt=aRect.LeftCenter();   eKind=HDL_LEFT ; break; // Links
-		case 5: aPnt=aRect.RightCenter();  eKind=HDL_RIGHT; break; // Rechts
-		case 6: aPnt=aRect.BottomLeft();   eKind=HDL_LWLFT; break; // Unten links
-		case 7: aPnt=aRect.BottomCenter(); eKind=HDL_LOWER; break; // Unten
-		case 8: aPnt=aRect.BottomRight();  eKind=HDL_LWRGT; break; // Unten rechts
-	}
+    if( IsTextFrame() && !nHdlNum )
+    {
+        pH=new ImpTextframeHdl(aRect);
+		pH->SetObj((SdrObject*)this);
+		pH->SetDrehWink(aGeo.nDrehWink);
+        return pH;
+    }
+    else
+    {
+        switch (nHdlNum) {
+            case 0: {
+                long a=GetEckenradius();
+                long b=Max(aRect.GetWidth(),aRect.GetHeight())/2; // Wird aufgerundet, da GetWidth() eins draufaddiert
+                if (a>b) a=b;
+                if (a<0) a=0;
+                aPnt=aRect.TopLeft();
+                aPnt.X()+=a;
+                eKind=HDL_CIRC;
+            } break; // Eckenradius
+            case 1: aPnt=aRect.TopLeft();      eKind=HDL_UPLFT; break; // Oben links
+            case 2: aPnt=aRect.TopCenter();    eKind=HDL_UPPER; break; // Oben
+            case 3: aPnt=aRect.TopRight();     eKind=HDL_UPRGT; break; // Oben rechts
+            case 4: aPnt=aRect.LeftCenter();   eKind=HDL_LEFT ; break; // Links
+            case 5: aPnt=aRect.RightCenter();  eKind=HDL_RIGHT; break; // Rechts
+            case 6: aPnt=aRect.BottomLeft();   eKind=HDL_LWLFT; break; // Unten links
+            case 7: aPnt=aRect.BottomCenter(); eKind=HDL_LOWER; break; // Unten
+            case 8: aPnt=aRect.BottomRight();  eKind=HDL_LWRGT; break; // Unten rechts
+        }
+    }
 	if (aGeo.nShearWink!=0) ShearPoint(aPnt,aRect.TopLeft(),aGeo.nTan);
 	if (aGeo.nDrehWink!=0) RotatePoint(aPnt,aRect.TopLeft(),aGeo.nSin,aGeo.nCos);
 	if (eKind!=HDL_MOVE) {
--- svx/source/svdraw/svdview.cxx	27 Jun 2007 19:13:08 -0000	1.23
+++ svx/source/svdraw/svdview.cxx	19 May 2008 00:24:14 -0000
@@ -520,7 +520,9 @@ SdrHitKind SdrView::PickAnything(const P
 
 		if(pOut)
 		{
-			nTolerance = pOut->PixelToLogic(Size(2, 0)).Width();
+            // special-casing text object, as it's otherwise hard to
+            // grab&move with mouse
+			nTolerance = pOut->PixelToLogic(Size(5, 0)).Width();
 		}
 
 		if(	(aLocalLogicPosition.X() >= aBoundRect.Left() - nTolerance && aLocalLogicPosition.X() <= aBoundRect.Left() + nTolerance)
