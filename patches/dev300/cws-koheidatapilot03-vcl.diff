diff --git vcl/inc/vcl/popupmenuwindow.hxx vcl/inc/vcl/popupmenuwindow.hxx
new file mode 100644
index 0000000..ef31da0
--- /dev/null
+++ vcl/inc/vcl/popupmenuwindow.hxx
@@ -0,0 +1,50 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: floatwin.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __POPUPMENUWINDOW_HXX__
+#define __POPUPMENUWINDOW_HXX__
+
+#include "vcl/floatwin.hxx"
+
+class VCL_DLLPUBLIC PopupMenuFloatingWindow : public FloatingWindow
+{
+private:
+    struct ImplData;
+    ImplData* mpImplData;
+public:
+    PopupMenuFloatingWindow( Window* pParent, WinBits nStyle = (WB_SYSTEMFLOATWIN|WB_SYSTEMWINDOW|WB_NOBORDER) );
+    ~PopupMenuFloatingWindow();
+
+    sal_uInt16      GetMenuStackLevel() const;
+    void            SetMenuStackLevel( sal_uInt16 nLevel );
+    bool            IsPopupMenu() const;
+};
+
+#endif
diff --git vcl/inc/vcl/vclevent.hxx vcl/inc/vcl/vclevent.hxx
index 71b895f..b73a660 100644
--- vcl/inc/vcl/vclevent.hxx
+++ vcl/inc/vcl/vclevent.hxx
@@ -35,11 +35,19 @@
 #include <tools/rtti.hxx>
 #include <vcl/dllapi.h>
 
+#include <com/sun/star/uno/Reference.hxx>
+
 #include <list>
 
 class Window;
 class Menu;
 
+namespace com { namespace sun { namespace star {
+    namespace accessibility {
+        class XAccessible;
+    }
+}}}
+
 #define VCLEVENT_OBJECT_DYING                  1
 
 // VclWindowEvent:
@@ -240,6 +248,17 @@ public:
     USHORT GetItemPos() const { return mnPos; }
 };
 
+class VCL_DLLPUBLIC VclAccessibleEvent: public VclSimpleEvent
+{
+public:
+    VclAccessibleEvent( ULONG n, const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible >& rxAccessible );
+    virtual ~VclAccessibleEvent();
+    ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > GetAccessible() const;
+
+private:
+    ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > mxAccessible;
+};
+
 class VCL_DLLPUBLIC VclEventListeners : public std::list<Link>
 {
 public:
diff --git vcl/inc/vcl/window.h vcl/inc/vcl/window.h
index b81aed8..0e25330 100644
--- vcl/inc/vcl/window.h
+++ vcl/inc/vcl/window.h
@@ -358,7 +358,8 @@ public:
                         mbToolbarFloatingWindow:1,
                         mbCallHandlersDuringInputDisabled:1,
                         mbDisableAccessibleLabelForRelation:1,
-                        mbDisableAccessibleLabeledByRelation:1;
+                        mbDisableAccessibleLabeledByRelation:1,
+                        mbFakeFocusSet:1;
 
     ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > mxDNDListenerContainer;
 };
diff --git vcl/inc/vcl/window.hxx vcl/inc/vcl/window.hxx
index 1917158..540906c 100644
--- vcl/inc/vcl/window.hxx
+++ vcl/inc/vcl/window.hxx
@@ -583,7 +583,7 @@ protected:
 
             void        ImplCallEventListeners( ULONG nEvent, void* pData = NULL );
             void        CallEventListeners( ULONG nEvent, void* pData = NULL );
-
+            void        FireVclEvent( VclSimpleEvent* pEvent );
 
     // FIXME: this is a hack to workaround missing layout functionality
     SAL_DLLPRIVATE void ImplAdjustNWFSizes();
@@ -900,6 +900,13 @@ public:
     USHORT              GetGetFocusFlags() const;
     void				GrabFocusToDocument();
 
+    /** 
+     * Set this when you need to act as if the window has focus even if it 
+     * doesn't.  This is necessary for implementing tab stops inside floating
+     * windows, but floating windows don't get focus from the system.
+     */
+    void                SetFakeFocus( bool bFocus );
+
     BOOL                IsCompoundControl() const;
     BOOL                HasCompoundControlFocus() const;
 
diff --git vcl/prj/d.lst vcl/prj/d.lst
index 9836281..5a1bf2f 100644
--- vcl/prj/d.lst
+++ vcl/prj/d.lst
@@ -82,6 +82,7 @@ mkdir: %_DEST%\inc%_EXT%\vcl
 ..\inc\vcl\octree.hxx %_DEST%\inc%_EXT%\vcl\octree.hxx
 ..\inc\vcl\outdev.hxx %_DEST%\inc%_EXT%\vcl\outdev.hxx
 ..\inc\vcl\pointr.hxx %_DEST%\inc%_EXT%\vcl\pointr.hxx
+..\inc\vcl\popupmenuwindow.hxx %_DEST%\inc%_EXT%\vcl\popupmenuwindow.hxx
 ..\inc\vcl\print.hxx %_DEST%\inc%_EXT%\vcl\print.hxx
 ..\inc\vcl\prndlg.hxx %_DEST%\inc%_EXT%\vcl\prndlg.hxx
 ..\inc\vcl\prntypes.hxx %_DEST%\inc%_EXT%\vcl\prntypes.hxx
diff --git vcl/source/app/vclevent.cxx vcl/source/app/vclevent.cxx
index 75ef1ea..abdb3ec 100644
--- vcl/source/app/vclevent.cxx
+++ vcl/source/app/vclevent.cxx
@@ -34,10 +34,30 @@
 #include "vcl/vclevent.hxx"
 #include "vcl/svdata.hxx"
 
+#include <com/sun/star/accessibility/XAccessible.hpp>
+
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::accessibility::XAccessible;
+
 TYPEINIT0(VclSimpleEvent);
 TYPEINIT1(VclWindowEvent, VclSimpleEvent);
 TYPEINIT1(VclMenuEvent, VclSimpleEvent);
 
+VclAccessibleEvent::VclAccessibleEvent( ULONG n, const Reference<XAccessible>& rxAccessible ) :
+    VclSimpleEvent(n),
+    mxAccessible(rxAccessible)
+{
+}
+
+VclAccessibleEvent::~VclAccessibleEvent()
+{
+}
+
+Reference<XAccessible> VclAccessibleEvent::GetAccessible() const
+{
+    return mxAccessible;
+}
+
 void VclEventListeners::Call( VclSimpleEvent* pEvent ) const
 {
     // Copy the list, because this can be destroyed when calling a Link...
diff --git vcl/source/window/makefile.mk vcl/source/window/makefile.mk
index cdd4aef..75e9107 100644
--- vcl/source/window/makefile.mk
+++ vcl/source/window/makefile.mk
@@ -69,6 +69,7 @@ SLOFILES= \
             $(SLO)$/mnemonic.obj	\
             $(SLO)$/mnemonicengine.obj  \
             $(SLO)$/msgbox.obj		\
+			$(SLO)$/popupmenuwindow.obj		\
             $(SLO)$/scrwnd.obj		\
             $(SLO)$/seleng.obj		\
             $(SLO)$/split.obj		\
diff --git vcl/source/window/popupmenuwindow.cxx vcl/source/window/popupmenuwindow.cxx
new file mode 100644
index 0000000..869f52b
--- /dev/null
+++ vcl/source/window/popupmenuwindow.cxx
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: floatwin.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_vcl.hxx"
+
+#include "vcl/popupmenuwindow.hxx"
+
+#include <limits>
+
+struct PopupMenuFloatingWindow::ImplData
+{
+    sal_uInt16      mnMenuStackLevel;  // Store the stack level of a popup menu.  0 = top-level menu.
+
+    ImplData();
+    ~ImplData();
+};
+
+PopupMenuFloatingWindow::ImplData::ImplData() :
+    mnMenuStackLevel( ::std::numeric_limits<sal_uInt16>::max() )
+{
+}
+
+PopupMenuFloatingWindow::ImplData::~ImplData()
+{
+}
+
+// ============================================================================
+
+PopupMenuFloatingWindow::PopupMenuFloatingWindow( Window* pParent, WinBits nStyle ) :
+    FloatingWindow(pParent, nStyle),
+    mpImplData(new ImplData)
+{
+}
+
+PopupMenuFloatingWindow::~PopupMenuFloatingWindow()
+{
+    delete mpImplData;
+}
+
+sal_uInt16 PopupMenuFloatingWindow::GetMenuStackLevel() const
+{
+    return mpImplData->mnMenuStackLevel;
+}
+
+void PopupMenuFloatingWindow::SetMenuStackLevel( sal_uInt16 nLevel )
+{
+    mpImplData->mnMenuStackLevel = nLevel;
+}
+
+bool PopupMenuFloatingWindow::IsPopupMenu() const
+{
+    return mpImplData->mnMenuStackLevel != ::std::numeric_limits<sal_uInt16>::max();
+}
+
diff --git vcl/source/window/window.cxx vcl/source/window/window.cxx
index 3b18e4d..b9a81a3 100644
--- vcl/source/window/window.cxx
+++ vcl/source/window/window.cxx
@@ -698,6 +698,7 @@ void Window::ImplInitWindowData( WindowType nType )
     mpWindowImpl->mbCallHandlersDuringInputDisabled = FALSE; // TRUE: call event handlers even if input is disabled
     mpWindowImpl->mbDisableAccessibleLabelForRelation = FALSE; // TRUE: do not set LabelFor relation on accessible objects
     mpWindowImpl->mbDisableAccessibleLabeledByRelation = FALSE; // TRUE: do not set LabeledBy relation on accessible objects
+    mpWindowImpl->mbFakeFocusSet = FALSE; // TRUE: pretend as if the window has focus.
 
     mbEnableRTL         = Application::GetSettings().GetLayoutRTL();         // TRUE: this outdev will be mirrored if RTL window layout (UI mirroring) is globally active
 }
@@ -3911,6 +3912,20 @@ void Window::ImplCallFocusChangeActivate( Window* pNewOverlapWindow,
     }
 }
 
+static bool IsWindowFocused(const WindowImpl& rWinImpl)
+{
+    if (rWinImpl.mpSysObj)
+        return true;
+
+    if (rWinImpl.mpFrameData->mbHasFocus)
+        return true;
+
+    if (rWinImpl.mbFakeFocusSet)
+        return true;
+
+    return false;
+}
+
 // -----------------------------------------------------------------------
 void Window::ImplGrabFocus( USHORT nFlags )
 {
@@ -3982,9 +3997,7 @@ void Window::ImplGrabFocus( USHORT nFlags )
         pFrame = pFrame->mpWindowImpl->mpFrameData->mpNextFrame;
     }
 
-    BOOL bHasFocus = TRUE;
-        if ( !mpWindowImpl->mpSysObj && !mpWindowImpl->mpFrameData->mbHasFocus )
-            bHasFocus = FALSE;
+    bool bHasFocus = IsWindowFocused(*mpWindowImpl);
 
     BOOL bMustNotGrabFocus = FALSE;
     // #100242#, check parent hierarchy if some floater prohibits grab focus
@@ -5377,6 +5390,11 @@ void Window::CallEventListeners( ULONG nEvent, void* pData )
     }
 }
 
+void Window::FireVclEvent( VclSimpleEvent* pEvent )
+{
+    ImplGetSVData()->mpApp->ImplCallEventListeners(pEvent);
+}
+
 // -----------------------------------------------------------------------
 
 void Window::AddEventListener( const Link& rEventListener )
@@ -7752,6 +7770,11 @@ void Window::GrabFocusToDocument()
     }
 }
 
+void Window::SetFakeFocus( bool bFocus )
+{
+    ImplGetWindowImpl()->mbFakeFocusSet = bFocus;
+}
+
 // -----------------------------------------------------------------------
 
 BOOL Window::HasChildPathFocus( BOOL bSystemWindow ) const
diff --git vcl/unx/gtk/a11y/atkutil.cxx vcl/unx/gtk/a11y/atkutil.cxx
index 5206c8c..be6f95e 100644
--- vcl/unx/gtk/a11y/atkutil.cxx
+++ vcl/unx/gtk/a11y/atkutil.cxx
@@ -659,7 +659,16 @@ long WindowEventHandler(void *, ::VclSimpleEvent const * pEvent)
             static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
  */
     case VCLEVENT_MENU_HIGHLIGHT:
-        handle_menu_highlighted(static_cast< ::VclMenuEvent const * >(pEvent));
+        if (const VclMenuEvent* pMenuEvent = dynamic_cast<const VclMenuEvent*>(pEvent))
+        {
+            handle_menu_highlighted(pMenuEvent);
+        }
+        else if (const VclAccessibleEvent* pAccEvent = dynamic_cast<const VclAccessibleEvent*>(pEvent))
+        {
+            uno::Reference< accessibility::XAccessible > xAccessible = pAccEvent->GetAccessible();
+            if (xAccessible.is())
+                atk_wrapper_focus_tracker_notify_when_idle(xAccessible);
+        }
         break;
 
     case VCLEVENT_TOOLBOX_HIGHLIGHT:
diff --git vcl/unx/gtk/a11y/atkwindow.cxx vcl/unx/gtk/a11y/atkwindow.cxx
index e98a809..23ba24c 100644
--- vcl/unx/gtk/a11y/atkwindow.cxx
+++ vcl/unx/gtk/a11y/atkwindow.cxx
@@ -33,6 +33,7 @@
  
 #include <plugins/gtk/gtkframe.hxx>
 #include <vcl/window.hxx>
+#include "vcl/popupmenuwindow.hxx"
 
 #include "atkwindow.hxx"
 #include "atkwrapper.hxx"
@@ -108,6 +109,17 @@ init_from_window( AtkObject *accessible, Window *pWindow )
                     pChild->SetAccessibleRole( AccessibleRole::LABEL );
                     accessible->name = g_strdup( rtl::OUStringToOString( pChild->GetText(), RTL_TEXTENCODING_UTF8 ).getStr() );
                 }
+                else if ( pWindow->GetType() == WINDOW_BORDERWINDOW && pChild->GetType() == WINDOW_FLOATINGWINDOW )
+                {
+                    PopupMenuFloatingWindow* p = dynamic_cast<PopupMenuFloatingWindow*>(pChild);
+                    if (p && p->IsPopupMenu() && p->GetMenuStackLevel() == 0)
+                    {
+                        // This is a top-level menu popup.  Register it.
+                        role = ATK_ROLE_POPUP_MENU;
+                        pChild->SetAccessibleRole( AccessibleRole::POPUP_MENU );
+                        accessible->name = g_strdup( rtl::OUStringToOString( pChild->GetText(), RTL_TEXTENCODING_UTF8 ).getStr() );
+                    }
+                }
             }
             break;
         }
@@ -136,6 +148,23 @@ ooo_window_wrapper_real_focus_gtk (GtkWidget *, GdkEventFocus *)
                                           
 /*****************************************************************************/
 
+static bool
+isChildPopupMenu(Window* pWindow)
+{
+    Window* pChild = pWindow->GetAccessibleChildWindow(0);
+    if (!pChild)
+        return false;
+
+    if (WINDOW_FLOATINGWINDOW != pChild->GetType())
+        return false;
+
+    PopupMenuFloatingWindow* p = dynamic_cast<PopupMenuFloatingWindow*>(pChild);
+    if (!p)
+        return false;
+
+    return p->IsPopupMenu();
+}
+
 static void
 ooo_window_wrapper_real_initialize(AtkObject *obj, gpointer data)
 {
@@ -157,8 +186,16 @@ ooo_window_wrapper_real_initialize(AtkObject *obj, gpointer data)
              */
             if( WINDOW_BORDERWINDOW == pWindow->GetType() )
             {
-                ooo_wrapper_registry_add( xAccessible, obj );
-                g_object_set_data( G_OBJECT(obj), "ooo:atk-wrapper-key", xAccessible.get() );
+                if ( isChildPopupMenu(pWindow) )
+                {
+                    AtkObject *child = atk_object_wrapper_new( xAccessible, obj );
+                    ooo_wrapper_registry_add( xAccessible, child );
+                }
+                else
+                {
+                    ooo_wrapper_registry_add( xAccessible, obj );
+                    g_object_set_data( G_OBJECT(obj), "ooo:atk-wrapper-key", xAccessible.get() );
+                }
             }
             else
             {
diff --git vcl/unx/gtk/a11y/atkwrapper.cxx vcl/unx/gtk/a11y/atkwrapper.cxx
index 67ec595..cec4a29 100644
--- vcl/unx/gtk/a11y/atkwrapper.cxx
+++ vcl/unx/gtk/a11y/atkwrapper.cxx
@@ -515,6 +515,60 @@ wrapper_ref_relation_set( AtkObject *atk_obj )
 
 /*****************************************************************************/
 
+#if 0
+struct {
+    sal_Int16       value;
+    const sal_Char* name;
+} aStateTypeTable[] = {
+    { accessibility::AccessibleStateType::INVALID, "INVALID" }, 
+    { accessibility::AccessibleStateType::ACTIVE, "ACTIVE" }, 
+    { accessibility::AccessibleStateType::ARMED, "ARMED" }, 
+    { accessibility::AccessibleStateType::BUSY, "BUSY" }, 
+    { accessibility::AccessibleStateType::CHECKED, "CHECKED" }, 
+    { accessibility::AccessibleStateType::DEFUNC, "DEFUNC" }, 
+    { accessibility::AccessibleStateType::EDITABLE, "EDITABLE" }, 
+    { accessibility::AccessibleStateType::ENABLED, "ENABLED" }, 
+    { accessibility::AccessibleStateType::EXPANDABLE, "EXPANDABLE" }, 
+    { accessibility::AccessibleStateType::EXPANDED, "EXPANDED" }, 
+    { accessibility::AccessibleStateType::FOCUSABLE, "FOCUSABLE" }, 
+    { accessibility::AccessibleStateType::FOCUSED, "FOCUSED" }, 
+    { accessibility::AccessibleStateType::HORIZONTAL, "HORIZONTAL" }, 
+    { accessibility::AccessibleStateType::ICONIFIED, "ICONIFIED" }, 
+    { accessibility::AccessibleStateType::INDETERMINATE, "INDETERMINATE" }, 
+    { accessibility::AccessibleStateType::MANAGES_DESCENDANTS, "MANAGES_DESCENDANTS" }, 
+    { accessibility::AccessibleStateType::MODAL, "MODAL" }, 
+    { accessibility::AccessibleStateType::MULTI_LINE, "MULTI_LINE" }, 
+    { accessibility::AccessibleStateType::MULTI_SELECTABLE, "MULTI_SELECTABLE" }, 
+    { accessibility::AccessibleStateType::OPAQUE, "OPAQUE" }, 
+    { accessibility::AccessibleStateType::PRESSED, "PRESSED" }, 
+    { accessibility::AccessibleStateType::RESIZABLE, "RESIZABLE" }, 
+    { accessibility::AccessibleStateType::SELECTABLE, "SELECTABLE" }, 
+    { accessibility::AccessibleStateType::SELECTED, "SELECTED" }, 
+    { accessibility::AccessibleStateType::SENSITIVE, "SENSITIVE" }, 
+    { accessibility::AccessibleStateType::SHOWING, "SHOWING" }, 
+    { accessibility::AccessibleStateType::SINGLE_LINE, "SINGLE_LINE" }, 
+    { accessibility::AccessibleStateType::STALE, "STALE" }, 
+    { accessibility::AccessibleStateType::TRANSIENT, "TRANSIENT" }, 
+    { accessibility::AccessibleStateType::VERTICAL, "VERTICAL" }, 
+    { accessibility::AccessibleStateType::VISIBLE, "VISIBLE" }
+};
+
+static void printStates(const uno::Sequence<sal_Int16>& rStates)
+{
+    sal_Int32 n = rStates.getLength();
+    size_t nTypes = sizeof(aStateTypeTable)/sizeof(aStateTypeTable[0]);
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        for (size_t j = 0; j < nTypes; ++j)
+        {
+            if (aStateTypeTable[j].value == rStates[i])
+                printf("%s ", aStateTypeTable[j].name);
+        }
+    }
+    printf("\n");
+}
+#endif
+
 static AtkStateSet *
 wrapper_ref_state_set( AtkObject *atk_obj )
 {
