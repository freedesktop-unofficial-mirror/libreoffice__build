diff --git sc/source/core/data/column.cxx sc/source/core/data/column.cxx
index b455d90..76ecf13 100644
--- sc/source/core/data/column.cxx
+++ sc/source/core/data/column.cxx
@@ -854,6 +854,10 @@ void lclTakeBroadcaster( ScBaseCell*& rpCell, SvtBroadcaster* pBC )
 
 void ScColumn::SwapRow(SCROW nRow1, SCROW nRow2)
 {
+    // TODO: We probably don't need to broadcast value changes here since 
+    // deleting and inserting cells do it.
+    bool bBroadcast = false;  
+
     /*  Simple swap of cell pointers does not work if broadcasters exist (crash
         if cell broadcasts directly or indirectly to itself). While swapping
         the cells, broadcasters have to remain at old positions! */
@@ -912,10 +916,13 @@ void ScColumn::SwapRow(SCROW nRow1, SCROW nRow2)
             pCell1->TakeBroadcaster( pBC2 );
             pCell2->TakeBroadcaster( pBC1 );
 
-            ScHint aHint1( SC_HINT_DATACHANGED, aPos1, pCell2 );
-			pDocument->Broadcast( aHint1 );
-            ScHint aHint2( SC_HINT_DATACHANGED, aPos2, pCell1 );
-			pDocument->Broadcast( aHint2 );
+            if (bBroadcast)
+            {
+                ScHint aHint1( SC_HINT_DATACHANGED, aPos1, pCell2 );
+                pDocument->Broadcast( aHint1 );
+                ScHint aHint2( SC_HINT_DATACHANGED, aPos2, pCell1 );
+                pDocument->Broadcast( aHint2 );
+            }
         }
         else
         {
@@ -936,7 +943,8 @@ void ScColumn::SwapRow(SCROW nRow1, SCROW nRow2)
 
             // insert ColEntry at new position
             Insert( nRow2, pCell1 );
-			pDocument->Broadcast( ScHint( SC_HINT_DATACHANGED, aPos1, pDummyCell ) );
+            if (bBroadcast)
+                pDocument->Broadcast( ScHint( SC_HINT_DATACHANGED, aPos1, pDummyCell ) );
         }
 
         return;
@@ -1021,10 +1029,13 @@ void ScColumn::SwapRow(SCROW nRow1, SCROW nRow2)
     //	#64122# Bei Formeln hinterher nochmal broadcasten, damit die Formel nicht in irgendwelchen
     //	FormulaTrack-Listen landet, ohne die Broadcaster beruecksichtigt zu haben
     //	(erst hier, wenn beide Zellen eingefuegt sind)
-	if ( pBC1 && pFmlaCell2 )
-		pDocument->Broadcast( ScHint( SC_HINT_DATACHANGED, aPos1, pNew1 ) );
-	if ( pBC2 && pFmlaCell1 )
-		pDocument->Broadcast( ScHint( SC_HINT_DATACHANGED, aPos2, pNew2 ) );
+    if (bBroadcast)
+    {
+        if ( pBC1 && pFmlaCell2 )
+            pDocument->Broadcast( ScHint( SC_HINT_DATACHANGED, aPos1, pNew1 ) );
+        if ( pBC2 && pFmlaCell1 )
+            pDocument->Broadcast( ScHint( SC_HINT_DATACHANGED, aPos2, pNew2 ) );
+    }
 }
 
 
diff --git sc/source/core/data/table3.cxx sc/source/core/data/table3.cxx
index c9f4a00..724ae58 100644
--- sc/source/core/data/table3.cxx
+++ sc/source/core/data/table3.cxx
@@ -348,17 +348,14 @@ void ScTable::SortReorder( ScSortInfoArray* pArray, ScProgress& rProgress )
 {
     BOOL bByRow = aSortParam.bByRow;
     SCSIZE nCount = pArray->GetCount();
+    SCCOLROW nStart = pArray->GetStart();
     ScSortInfo** ppInfo = pArray->GetFirstArray();
-    // hngngn.. Win16 legacy? Table has ULONG count but can only be initialized using USHORT :-/
-    // FIXME: use std::vector instead, would be better anyway (type safe)
-    USHORT nArghl = (nCount > USHRT_MAX ? USHRT_MAX : static_cast<USHORT>(nCount));
-	Table aTable( nArghl );
+    ::std::vector<ScSortInfo*> aTable(nCount);
     SCSIZE nPos;
     for ( nPos = 0; nPos < nCount; nPos++ )
-	{
-		aTable.Insert( ppInfo[nPos]->nOrg, (void*) ppInfo[nPos] );
-	}
-    SCCOLROW nDest = pArray->GetStart();
+        aTable[ppInfo[nPos]->nOrg - nStart] = ppInfo[nPos];
+
+    SCCOLROW nDest = nStart;
     for ( nPos = 0; nPos < nCount; nPos++, nDest++ )
     {
         SCCOLROW nOrg = ppInfo[nPos]->nOrg;
@@ -371,9 +368,9 @@ void ScTable::SortReorder( ScSortInfoArray* pArray, ScProgress& rProgress )
             // neue Position des weggeswapten eintragen
             ScSortInfo* p = ppInfo[nPos];
             p->nOrg = nDest;
-			p = (ScSortInfo*) aTable.Replace( nDest, (void*) p );
+            ::std::swap(p, aTable[nDest-nStart]);
             p->nOrg = nOrg;
-			p = (ScSortInfo*) aTable.Replace( nOrg, (void*) p );
+            ::std::swap(p, aTable[nOrg-nStart]);
             DBG_ASSERT( p == ppInfo[nPos], "SortReorder: nOrg MisMatch" );
         }
         rProgress.SetStateOnPercent( nPos );
