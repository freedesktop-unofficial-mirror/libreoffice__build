Fix iterator handli≈ã for drawPolygon

From: Thorsten Behrens <tbehrens@novell.com>


---

 vcl/unx/source/gdi/salgdi.cxx |   21 +++++++++++++++++++--
 1 files changed, 19 insertions(+), 2 deletions(-)


diff --git vcl/unx/source/gdi/salgdi.cxx vcl/unx/source/gdi/salgdi.cxx
index ae281ab..0b02ad0 100644
--- vcl/unx/source/gdi/salgdi.cxx
+++ vcl/unx/source/gdi/salgdi.cxx
@@ -1427,14 +1427,17 @@ bool X11SalGraphics::drawPolyPolygon( const ::basegfx::B2DPolyPolygon& rOrigPoly
         // unless it splits another trapezoid that is still active
         bool bSplit = false;
         ActiveTrapSet::iterator aActiveTrapsIt = aActiveTraps.begin();
-        for(; aActiveTrapsIt != aActiveTraps.end(); ++aActiveTrapsIt )
+        while(aActiveTrapsIt != aActiveTraps.end())
         {
             XTrapezoid& rLeftTrap = aTrapVector[ *aActiveTrapsIt ];
 
             // skip until first overlap candidate
             // TODO: use stl::*er_bound() instead
             if( IsLeftOf( aTrapezoid.left, rLeftTrap.left) )
+            {
+                ++aActiveTrapsIt;
                 continue;
+            }
 
             // in the ActiveTrapSet there are still trapezoids where
             // a vertical overlap with new trapezoids is no longer possible
@@ -1445,15 +1448,26 @@ bool X11SalGraphics::drawPolyPolygon( const ::basegfx::B2DPolyPolygon& rOrigPoly
             {
                 ActiveTrapSet::iterator it = aActiveTrapsIt;
                 if( aActiveTrapsIt != aActiveTraps.begin() )
+                {
                     --aActiveTrapsIt;
-                aActiveTraps.erase( it );
+                    aActiveTraps.erase( it );
+                    ++aActiveTrapsIt;
+                }
+                else
+                {
+                    aActiveTraps.erase( it );
+                    aActiveTrapsIt = aActiveTraps.begin();
+                }
                 continue;
             }
 
             // check if there is horizontal overlap
             // aTrapezoid.left==rLeftTrap.right is allowed though
             if( !IsLeftOf( aTrapezoid.left, rLeftTrap.right ) )
+            {
+                ++aActiveTrapsIt;
                 continue;
+            }
 
             // prepare to split the old trapezoid and keep its upper part
             // find the old trapezoids entry in the VerticalTrapSet and remove it
