From 15dd78359bc974ec3e0d53db46fbbe62ad50b055 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 17:07:45 +0200
Subject: [PATCH 683/768] calc-perf-import-dbf-sc.diff

---
 sc/inc/column.hxx                  |   13 ++++-
 sc/inc/dbdocutl.hxx                |   12 ++++-
 sc/inc/dociter.hxx                 |   39 ++++++++++++++
 sc/inc/docparam.hxx                |   47 +++++++++++++++++
 sc/inc/document.hxx                |    5 ++-
 sc/inc/table.hxx                   |    3 +-
 sc/source/core/data/column.cxx     |   14 +++++-
 sc/source/core/data/column2.cxx    |   50 ++++++++++++++-----
 sc/source/core/data/column3.cxx    |    2 +-
 sc/source/core/data/dbdocutl.cxx   |   18 +++++--
 sc/source/core/data/dociter.cxx    |   97 ++++++++++++++++++++++++++++++++++++
 sc/source/core/data/docparam.cxx   |   39 ++++++++++++++
 sc/source/core/data/document.cxx   |   10 ++--
 sc/source/core/data/makefile.mk    |    2 +
 sc/source/core/data/table1.cxx     |    4 +-
 sc/source/ui/docshell/dbdocimp.cxx |    3 +-
 sc/source/ui/docshell/docsh.cxx    |   46 +++++++++++++-----
 sc/source/ui/docshell/docsh8.cxx   |   30 ++++++++++-
 sc/source/ui/docshell/impex.cxx    |    4 +-
 sc/source/ui/inc/docsh.hxx         |    4 +-
 20 files changed, 392 insertions(+), 50 deletions(-)
 create mode 100644 sc/inc/docparam.hxx
 create mode 100644 sc/source/core/data/docparam.cxx

diff --git sc/inc/column.hxx sc/inc/column.hxx
index 9ef97ac..f170952 100644
--- sc/inc/column.hxx
+++ sc/inc/column.hxx
@@ -68,6 +68,7 @@ struct ScLineFlags;
 struct ScMergePatternState;
 class ScFlatBoolRowSegments;
 struct ScSetStringParam;
+struct ScColWidthParam;
 
 #define COLUMN_DELTA	4
 
@@ -122,8 +123,16 @@ friend class ScHorizontalCellIterator;
 friend class ScHorizontalAttrIterator;
 
 public:
-static BOOL bDoubleAlloc;			// fuer Import: Groesse beim Allozieren verdoppeln
+    static bool bDoubleAlloc;			// fuer Import: Groesse beim Allozieren verdoppeln
 
+    class DoubleAllocSwitch
+    {
+    public:
+        DoubleAllocSwitch(bool bNewVal = true);
+        ~DoubleAllocSwitch();
+    private:
+        bool mbOldVal;
+    };
 public:
                 ScColumn();
                 ~ScColumn();
@@ -361,7 +370,7 @@ public:
                                     const Fraction& rZoomX, const Fraction& rZoomY,
                                     BOOL bFormula, USHORT nOldWidth,
                                     const ScMarkData* pMarkData,
-                                    BOOL bSimpleTextImport );
+                                    const ScColWidthParam* pParam );
     void		GetOptimalHeight( SCROW nStartRow, SCROW nEndRow, USHORT* pHeight,
                                     OutputDevice* pDev,
                                     double nPPTX, double nPPTY,
diff --git sc/inc/dbdocutl.hxx sc/inc/dbdocutl.hxx
index 2ee1e37..8803622 100644
--- sc/inc/dbdocutl.hxx
+++ sc/inc/dbdocutl.hxx
@@ -42,10 +42,20 @@ namespace com { namespace sun { namespace star { namespace sdbc {
 class ScDatabaseDocUtil
 {
 public:
+    /**
+     * Detailed information on single string value.
+     */
+    struct StrData
+    {
+        bool        mbSimpleText;
+        sal_uInt32  mnStrLength;
+
+        StrData();
+    };
     static void PutData( ScDocument* pDoc, SCCOL nCol, SCROW nRow, SCTAB nTab,
                         const ::com::sun::star::uno::Reference<
                             ::com::sun::star::sdbc::XRow>& xRow, long nRowPos,
-                        long nType, BOOL bCurrency, BOOL* pSimpleFlag = NULL );
+                        long nType, BOOL bCurrency, StrData* pStrData = NULL );
 };
 
 #endif
diff --git sc/inc/dociter.hxx sc/inc/dociter.hxx
index 749e674..ce1ee02 100644
--- sc/inc/dociter.hxx
+++ sc/inc/dociter.hxx
@@ -35,8 +35,10 @@
 #include "queryparam.hxx"
 
 #include <memory>
 
 #include <set>
+#include <vector>
+#include <boost/shared_ptr.hpp>
 
 class ScDocument;
 class ScBaseCell;
@@ -42,6 +44,7 @@ class ScPatternAttr;
 class ScAttrArray;
 class ScAttrIterator;
 class ScRange;
+class ScFlatBoolRowSegments;
 
 class ScDocumentIterator				// alle nichtleeren Zellen durchgehen
 {
@@ -514,7 +517,43 @@ public:
     ::std::set<SCROW>::const_iterator maItr;
     ::std::set<SCROW>::const_iterator maEnd;
 };
 
+// ============================================================================
+
+class ScDocRowHeightUpdater
+{
+public:
+    struct TabRanges
+    {
+        SCTAB mnTab;
+        ::boost::shared_ptr<ScFlatBoolRowSegments> mpRanges;
+
+        TabRanges();
+        TabRanges(SCTAB nTab);
+    };
+
+    /**
+     * Passing a NULL pointer to pTabRangesArray forces the heights of all
+     * rows in all tables to be updated.
+     */
+    explicit ScDocRowHeightUpdater(
+        ScDocument& rDoc, OutputDevice* pOutDev, double fPPTX, double fPPTY,
+        const ::std::vector<TabRanges>* pTabRangesArray = NULL);
+
+    void update();
+
+private:
+    void updateAll();
+
+private:
+    ScDocument& mrDoc;
+    OutputDevice* mpOutDev;
+    double mfPPTX;
+    double mfPPTY;
+    const ::std::vector<TabRanges>* mpTabRangesArray;
+};
+
+
 #endif
 
 
diff --git sc/inc/docparam.hxx sc/inc/docparam.hxx
new file mode 100644
index 0000000..e273c01
--- /dev/null
+++ sc/inc/docparam.hxx
@@ -0,0 +1,47 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_DOCPARAM_HXX
+#define SC_DOCPARAM_HXX
+
+#include "address.hxx"
+
+// Let's put here misc structures that get passed to ScDocument's methods.
+
+struct ScColWidthParam
+{
+    SCROW       mnMaxTextRow;
+    sal_uInt32  mnMaxTextLen;
+    bool        mbSimpleText;
+
+    ScColWidthParam();
+};
+
+#endif
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 72b790c..5d33fb3 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -146,7 +146,9 @@ class ScFormulaParserPool;
 struct ScClipParam;        
 struct ScClipRangeNameData;
 class ScRowBreakIterator;
 struct ScSetStringParam;
+class ScDocRowHeightUpdater;
+struct ScColWidthParam;
 
 namespace com { namespace sun { namespace star {
     namespace lang {
@@ -246,6 +248,7 @@ friend class ScHorizontalAttrIterator;
 friend class ScDocAttrIterator;
 friend class ScAttrRectIterator;
 friend class ScDocShell;
+friend class ScDocRowHeightUpdater;
 
 private:
     ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > xServiceManager;
@@ -1293,7 +1296,7 @@ public:
                                         const Fraction& rZoomX, const Fraction& rZoomY,
                                         BOOL bFormula,
                                         const ScMarkData* pMarkData = NULL,
-                                        BOOL bSimpleTextImport = FALSE );
+                                        const ScColWidthParam* pParam = NULL );
     SC_DLLPUBLIC BOOL			SetOptimalHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab, USHORT nExtra,
                                         OutputDevice* pDev,
                                         double nPPTX, double nPPTY,
diff --git sc/inc/table.hxx sc/inc/table.hxx
index a901eab..ebe4ce1 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -85,7 +85,8 @@ struct ScSetStringParam;
 class ScFlatUInt16RowSegments;
 class ScFlatBoolRowSegments;
 class ScFlatBoolColSegments;
 struct ScSetStringParam;
+struct ScColWidthParam;
 
 class ScTable
 {
@@ -590,7 +591,7 @@ public:
                                     double nPPTX, double nPPTY,
                                     const Fraction& rZoomX, const Fraction& rZoomY,
                                     BOOL bFormula, const ScMarkData* pMarkData,
-                                    BOOL bSimpleTextImport );
+                                    const ScColWidthParam* pParam );
     BOOL		SetOptimalHeight( SCROW nStartRow, SCROW nEndRow, USHORT nExtra,
                                     OutputDevice* pDev,
                                     double nPPTX, double nPPTY,
diff --git sc/source/core/data/column.cxx sc/source/core/data/column.cxx
index 115a24b..402600d 100644
--- sc/source/core/data/column.cxx
+++ sc/source/core/data/column.cxx
@@ -67,8 +67,20 @@ inline BOOL IsAmbiguousScriptNonZero( BYTE nScript )
              nScript != 0 );
 }
 
-// -----------------------------------------------------------------------------------------
+// ----------------------------------------------------------------------------
 
+ScColumn::DoubleAllocSwitch::DoubleAllocSwitch(bool bNewVal) :
+    mbOldVal(ScColumn::bDoubleAlloc)
+{
+    ScColumn::bDoubleAlloc = bNewVal;
+}
+
+ScColumn::DoubleAllocSwitch::~DoubleAllocSwitch()
+{
+    ScColumn::bDoubleAlloc = mbOldVal;
+}
+
+// ----------------------------------------------------------------------------
 
 ScColumn::ScColumn() :
     nCol( 0 ),
diff --git sc/source/core/data/column2.cxx sc/source/core/data/column2.cxx
index 926e621..40554a7 100644
--- sc/source/core/data/column2.cxx
+++ sc/source/core/data/column2.cxx
@@ -67,6 +67,7 @@
 #include "dbcolect.hxx"
 #include "fillinfo.hxx"
 #include "segmenttree.hxx"
+#include "docparam.hxx"
 
 #include <math.h>
 
@@ -638,10 +639,10 @@ long ScColumn::GetSimpleTextNeededSize( SCSIZE nIndex, OutputDevice* pDev,
 }
 
 USHORT ScColumn::GetOptimalColWidth( OutputDevice* pDev, double nPPTX, double nPPTY,
-                                        const Fraction& rZoomX, const Fraction& rZoomY,
-                                        BOOL bFormula, USHORT nOldWidth,
-                                        const ScMarkData* pMarkData,
-                                        BOOL bSimpleTextImport )
+                                     const Fraction& rZoomX, const Fraction& rZoomY,
+                                     BOOL bFormula, USHORT nOldWidth,
+                                     const ScMarkData* pMarkData,
+                                     const ScColWidthParam* pParam )
 {
     if (nCount == 0)
         return nOldWidth;
@@ -651,7 +652,7 @@ USHORT ScColumn::GetOptimalColWidth( OutputDevice* pDev, double nPPTX, double nP
 
     SCSIZE nIndex;
     ScMarkedDataIter aDataIter(this, pMarkData, TRUE);
-    if ( bSimpleTextImport )
+    if ( pParam && pParam->mbSimpleText )
     {	// alles eins bis auf NumberFormate
         const ScPatternAttr* pPattern = GetPattern( 0 );
         Font aFont;
@@ -662,19 +663,44 @@ USHORT ScColumn::GetOptimalColWidth( OutputDevice* pDev, double nPPTX, double nP
         long nMargin = (long) ( pMargin->GetLeftMargin() * nPPTX ) +
                         (long) ( pMargin->GetRightMargin() * nPPTX );
 
-        while (aDataIter.Next( nIndex ))
+        // Try to find the row that has the longest string, and measure the width of that string.
+        SvNumberFormatter* pFormatter = pDocument->GetFormatTable();
+        ULONG nFormat = pPattern->GetNumberFormat( pFormatter );
+        String aLongStr;
+        Color* pColor;
+        if (pParam->mnMaxTextRow >= 0)
         {
-            USHORT nThis = (USHORT) (GetSimpleTextNeededSize( nIndex, pDev,
-                TRUE ) + nMargin);
-            if (nThis)
+            ScBaseCell* pCell = GetCell(pParam->mnMaxTextRow);
+            ScCellFormat::GetString(
+                pCell, nFormat, aLongStr, &pColor, *pFormatter, TRUE, FALSE, ftCheck );
+        }
+        else
+        {
+            xub_StrLen nLongLen = 0;
+            while (aDataIter.Next(nIndex))
             {
-                if (nThis>nWidth || !bFound)
+                if (nIndex >= nCount)
+                    // Out-of-bound reached.  No need to keep going.
+                    break;
+
+                ScBaseCell* pCell = pItems[nIndex].pCell;
+                String aValStr;
+                ScCellFormat::GetString(
+                    pCell, nFormat, aValStr, &pColor, *pFormatter, TRUE, FALSE, ftCheck );
+
+                if (aValStr.Len() > nLongLen)
                 {
-                    nWidth = nThis;
-                    bFound = TRUE;
+                    nLongLen = aValStr.Len();
+                    aLongStr = aValStr;
                 }
             }
         }
+
+        if (aLongStr.Len())
+        {
+            nWidth = pDev->GetTextWidth(aLongStr) + static_cast<USHORT>(nMargin);
+            bFound = true;
+        }
     }
     else
     {
diff --git sc/source/core/data/column3.cxx sc/source/core/data/column3.cxx
index 1ac52d3..1ec3586 100644
--- sc/source/core/data/column3.cxx
+++ sc/source/core/data/column3.cxx
@@ -65,7 +65,7 @@ extern const ScFormulaCell* pLastFormulaTreeTop;	// in cellform.cxx
 using namespace formula;
 // STATIC DATA -----------------------------------------------------------
 
-BOOL ScColumn::bDoubleAlloc = FALSE;	// fuer Import: Groesse beim Allozieren verdoppeln
+bool ScColumn::bDoubleAlloc = FALSE;    // fuer Import: Groesse beim Allozieren verdoppeln
 
 
 void ScColumn::Insert( SCROW nRow, ScBaseCell* pNewCell )
diff --git sc/source/core/data/dbdocutl.cxx sc/source/core/data/dbdocutl.cxx
index 233bc4e..6430e19 100644
--- sc/source/core/data/dbdocutl.cxx
+++ sc/source/core/data/dbdocutl.cxx
@@ -46,12 +46,19 @@ using namespace ::com::sun::star;
 
 #define D_TIMEFACTOR              86400.0
 
-// -----------------------------------------------------------------------
+// ----------------------------------------------------------------------------
+
+ScDatabaseDocUtil::StrData::StrData() :
+    mbSimpleText(true), mnStrLength(0)
+{
+}
+
+// ----------------------------------------------------------------------------
 
 // static
 void ScDatabaseDocUtil::PutData( ScDocument* pDoc, SCCOL nCol, SCROW nRow, SCTAB nTab,
                                 const uno::Reference<sdbc::XRow>& xRow, long nRowPos,
-                                long nType, BOOL bCurrency, BOOL* pSimpleFlag )
+                                long nType, BOOL bCurrency, StrData* pStrData )
 {
     String aString;
     double nVal = 0.0;
@@ -185,8 +192,11 @@ void ScDatabaseDocUtil::PutData( ScDocument* pDoc, SCCOL nCol, SCROW nRow, SCTAB
         if (aString.Len())
         {
             pCell = ScBaseCell::CreateTextCell( aString, pDoc );
-            if ( pSimpleFlag && pCell->GetCellType() == CELLTYPE_EDIT )
-                *pSimpleFlag = FALSE;
+            if (pStrData)
+            {
+                pStrData->mbSimpleText = pCell->GetCellType() != CELLTYPE_EDIT;
+                pStrData->mnStrLength = aString.Len();
+            }
         }
         else
             pCell = NULL;
diff --git sc/source/core/data/dociter.cxx sc/source/core/data/dociter.cxx
index c03eb91..5bca66e 100644
--- sc/source/core/data/dociter.cxx
+++ sc/source/core/data/dociter.cxx
@@ -43,6 +43,10 @@
 #include "patattr.hxx"
 #include "docoptio.hxx"
 #include "cellform.hxx"
+#include "segmenttree.hxx"
+#include "progress.hxx"
+#include "globstr.hrc"
+#include "tools/fract.hxx"
 
 #include <vector>
 
@@ -2147,3 +2151,96 @@ const ScPatternAttr* ScAttrRectIterator::GetNext( SCCOL& rCol1, SCCOL& rCol2,
     return NULL;		// is nix mehr
 }
 
+// ============================================================================
+
+ScDocRowHeightUpdater::TabRanges::TabRanges() :
+    mnTab(0), mpRanges(new ScFlatBoolRowSegments)
+{
+}
+
+ScDocRowHeightUpdater::TabRanges::TabRanges(SCTAB nTab) :
+    mnTab(nTab), mpRanges(new ScFlatBoolRowSegments)
+{
+}
+
+ScDocRowHeightUpdater::ScDocRowHeightUpdater(ScDocument& rDoc, OutputDevice* pOutDev, double fPPTX, double fPPTY, const vector<TabRanges>* pTabRangesArray) :
+    mrDoc(rDoc), mpOutDev(pOutDev), mfPPTX(fPPTX), mfPPTY(fPPTY), mpTabRangesArray(pTabRangesArray)
+{
+}
+
+void ScDocRowHeightUpdater::update()
+{
+    if (!mpTabRangesArray || mpTabRangesArray->empty())
+    {
+        // No ranges defined.  Update all rows in all tables.
+        updateAll();
+        return;
+    }
+
+    sal_uInt32 nCellCount = 0;
+    vector<TabRanges>::const_iterator itr = mpTabRangesArray->begin(), itrEnd = mpTabRangesArray->end();
+    for (; itr != itrEnd; ++itr)
+    {
+        ScFlatBoolRowSegments::RangeData aData;
+        ScFlatBoolRowSegments::RangeIterator aRangeItr(*itr->mpRanges);
+        for (bool bFound = aRangeItr.getFirst(aData); bFound; bFound = aRangeItr.getNext(aData))
+        {
+            if (!aData.mbValue)
+                continue;
+
+            nCellCount += aData.mnRow2 - aData.mnRow1 + 1;
+        }
+    }
+
+    ScProgress aProgress(mrDoc.GetDocumentShell(), ScGlobal::GetRscString(STR_PROGRESS_HEIGHTING), nCellCount);
+
+    Fraction aZoom(1, 1);
+    itr = mpTabRangesArray->begin();
+    sal_uInt32 nProgressStart = 0;
+    for (; itr != itrEnd; ++itr)
+    {
+        SCTAB nTab = itr->mnTab;
+        if (!ValidTab(nTab) || !mrDoc.pTab[nTab])
+            continue;
+
+        ScFlatBoolRowSegments::RangeData aData;
+        ScFlatBoolRowSegments::RangeIterator aRangeItr(*itr->mpRanges);
+        for (bool bFound = aRangeItr.getFirst(aData); bFound; bFound = aRangeItr.getNext(aData))
+        {
+            if (!aData.mbValue)
+                continue;
+
+            mrDoc.pTab[nTab]->SetOptimalHeight(
+                aData.mnRow1, aData.mnRow2, 0, mpOutDev, mfPPTX, mfPPTY, aZoom, aZoom, false, &aProgress, nProgressStart);
+
+            nProgressStart += aData.mnRow2 - aData.mnRow1 + 1;
+        }
+    }
+}
+
+void ScDocRowHeightUpdater::updateAll()
+{
+    sal_uInt32 nCellCount = 0;
+    for (SCTAB nTab = 0; nTab <= MAXTAB; ++nTab)
+    {
+        if (!ValidTab(nTab) || !mrDoc.pTab[nTab])
+            continue;
+
+        nCellCount += mrDoc.pTab[nTab]->GetWeightedCount();
+    }
+
+    ScProgress aProgress(mrDoc.GetDocumentShell(), ScGlobal::GetRscString(STR_PROGRESS_HEIGHTING), nCellCount);
+
+    Fraction aZoom(1, 1);
+    ULONG nProgressStart = 0;
+    for (SCTAB nTab = 0; nTab <= MAXTAB; ++nTab)
+    {
+        if (!ValidTab(nTab) || !mrDoc.pTab[nTab])
+            continue;
+
+        mrDoc.pTab[nTab]->SetOptimalHeight(
+            0, MAXROW, 0, mpOutDev, mfPPTX, mfPPTY, aZoom, aZoom, false, &aProgress, nProgressStart);
+
+        nProgressStart += mrDoc.pTab[nTab]->GetWeightedCount();
+    }
+}
diff --git sc/source/core/data/docparam.cxx sc/source/core/data/docparam.cxx
new file mode 100644
index 0000000..bb2e073
--- /dev/null
+++ sc/source/core/data/docparam.cxx
@@ -0,0 +1,39 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+// INCLUDE ---------------------------------------------------------------
+
+#include "docparam.hxx"
+
+ScColWidthParam::ScColWidthParam() :
+    mnMaxTextRow(-1), mnMaxTextLen(0), mbSimpleText(true) {}
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 99b79f2..daba564 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -3255,14 +3255,14 @@ ULONG ScDocument::GetRowOffset( SCROW nRow, SCTAB nTab ) const
 
 
 USHORT ScDocument::GetOptimalColWidth( SCCOL nCol, SCTAB nTab, OutputDevice* pDev,
-                                        double nPPTX, double nPPTY,
-                                        const Fraction& rZoomX, const Fraction& rZoomY,
-                                        BOOL bFormula, const ScMarkData* pMarkData,
-                                        BOOL bSimpleTextImport )
+                                       double nPPTX, double nPPTY,
+                                       const Fraction& rZoomX, const Fraction& rZoomY,
+                                       BOOL bFormula, const ScMarkData* pMarkData,
+                                       const ScColWidthParam* pParam )
 {
     if ( ValidTab(nTab) && pTab[nTab] )
         return pTab[nTab]->GetOptimalColWidth( nCol, pDev, nPPTX, nPPTY,
-            rZoomX, rZoomY, bFormula, pMarkData, bSimpleTextImport );
+            rZoomX, rZoomY, bFormula, pMarkData, pParam );
     DBG_ERROR("Falsche Tabellennummer");
     return 0;
 }
diff --git sc/source/core/data/makefile.mk sc/source/core/data/makefile.mk
index 2174d1d..1d8bff0 100755
--- sc/source/core/data/makefile.mk
+++ sc/source/core/data/makefile.mk
@@ -70,6 +70,7 @@ SLOFILES =  \
     $(SLO)$/documen8.obj \
     $(SLO)$/documen9.obj \
     $(SLO)$/document.obj \
+    $(SLO)$/docparam.obj \
         $(SLO)$/dpcachetable.obj \
         $(SLO)$/dpdimsave.obj \
     $(SLO)$/dpglobal.obj \
@@ -120,6 +121,7 @@ EXCEPTIONSFILES= \
     $(SLO)$/clipparam.obj \
     $(SLO)$/column.obj \
     $(SLO)$/column3.obj \
+    $(SLO)$/dociter.obj \
     $(SLO)$/documen2.obj \
     $(SLO)$/document.obj \
     $(SLO)$/dpdimsave.obj \
diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
index e6428eb..510d650 100644
--- sc/source/core/data/table1.cxx
+++ sc/source/core/data/table1.cxx
@@ -305,10 +305,10 @@ USHORT ScTable::GetOptimalColWidth( SCCOL nCol, OutputDevice* pDev,
                                     double nPPTX, double nPPTY,
                                     const Fraction& rZoomX, const Fraction& rZoomY,
                                     BOOL bFormula, const ScMarkData* pMarkData,
-                                    BOOL bSimpleTextImport )
+                                    const ScColWidthParam* pParam )
 {
     return aCol[nCol].GetOptimalColWidth( pDev, nPPTX, nPPTY, rZoomX, rZoomY,
-        bFormula, STD_COL_WIDTH - STD_EXTRA_WIDTH, pMarkData, bSimpleTextImport );
+        bFormula, STD_COL_WIDTH - STD_EXTRA_WIDTH, pMarkData, pParam );
 }
 
 long ScTable::GetNeededSize( SCCOL nCol, SCROW nRow,
diff --git sc/source/ui/docshell/dbdocimp.cxx sc/source/ui/docshell/dbdocimp.cxx
index 60abe62..a446e17 100644
--- sc/source/ui/docshell/dbdocimp.cxx
+++ sc/source/ui/docshell/dbdocimp.cxx
@@ -268,7 +268,7 @@ BOOL ScDBDocFunc::DoImport( SCTAB nTab, const ScImportParam& rParam,
     // ImportDoc - also used for Redo
     ScDocument* pImportDoc = new ScDocument( SCDOCMODE_UNDO );
     pImportDoc->InitUndo( pDoc, nTab, nTab );
-    ScColumn::bDoubleAlloc = TRUE;
+    ScColumn::DoubleAllocSwitch aAllocSwitch(true);
 
     //
     //	get data from database into import document
@@ -460,7 +460,6 @@ BOOL ScDBDocFunc::DoImport( SCTAB nTab, const ScImportParam& rParam,
         DBG_ERROR("Unexpected exception in database");
     }
 
-    ScColumn::bDoubleAlloc = FALSE;
     pImportDoc->DoColResize( nTab, rParam.nCol1,nEndCol, 0 );
 
     //
diff --git sc/source/ui/docshell/docsh.cxx sc/source/ui/docshell/docsh.cxx
index b244432..098ac6a 100644
--- sc/source/ui/docshell/docsh.cxx
+++ sc/source/ui/docshell/docsh.cxx
@@ -117,17 +117,25 @@
 #include "optsolver.hxx"
 #include "sheetdata.hxx"
 #include "tabprotection.hxx"
+#include "docparam.hxx"
 
 #include "docsh.hxx"
 #include "docshimp.hxx"
+#include "sizedev.hxx"
 #include <rtl/logfile.hxx>
 
 #include <comphelper/processfactory.hxx>
 #include <basic/sbstar.hxx>
 #include <basic/basmgr.hxx>
+
+#include <vector>
+#include <boost/shared_ptr.hpp>
+
 using namespace com::sun::star;
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
+using ::boost::shared_ptr;
+using ::std::vector;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -883,12 +891,13 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
     // ob nach dem Import optimale Spaltenbreiten gesetzt werden sollen
     BOOL bSetColWidths = FALSE;
     BOOL bSetSimpleTextColWidths = FALSE;
-    BOOL bSimpleColWidth[MAXCOLCOUNT];
-    memset( bSimpleColWidth, 1, (MAXCOLCOUNT) * sizeof(BOOL) );
+    ScColWidthParam aColWidthParam[MAXCOLCOUNT];
     ScRange aColWidthRange;
     // ob nach dem Import optimale Zeilenhoehen gesetzt werden sollen
     BOOL bSetRowHeights = FALSE;
 
+    vector<ScDocRowHeightUpdater::TabRanges> aRecalcRowRangesArray;
+
     aConvFilterName.Erase(); //@ #BugId 54198
 
     //	Alle Filter brauchen die komplette Datei am Stueck (nicht asynchron),
@@ -1087,8 +1096,10 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
                 sItStr = ScGlobal::GetCharsetString( RTL_TEXTENCODING_IBM_850 );
             }
 
+            ScDocRowHeightUpdater::TabRanges aRecalcRanges(0);
             ULONG eError = DBaseImport( rMedium.GetPhysicalName(),
-                    ScGlobal::GetCharsetValue(sItStr), bSimpleColWidth );
+                    ScGlobal::GetCharsetValue(sItStr), aColWidthParam, *aRecalcRanges.mpRanges );
+            aRecalcRowRangesArray.push_back(aRecalcRanges);
 
             if (eError != eERR_OK)
             {
@@ -1102,12 +1113,6 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
             aColWidthRange.aStart.SetRow( 1 );	// Spaltenheader nicht
             bSetColWidths = TRUE;
             bSetSimpleTextColWidths = TRUE;
-            // Memo-Felder fuehren zu einem bSimpleColWidth[nCol]==FALSE
-            for ( SCCOL nCol=0; nCol <= MAXCOL && !bSetRowHeights; nCol++ )
-            {
-                if ( !bSimpleColWidth[nCol] )
-                    bSetRowHeights = TRUE;
-            }
         }
         else if (aFltName.EqualsAscii(pFilterDif))
         {
@@ -1321,9 +1326,12 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
             {
                 for ( SCCOL nCol=0; nCol <= nEndCol; nCol++ )
                 {
+                    if (!bSetSimpleTextColWidths)
+                        aColWidthParam[nCol].mbSimpleText = false;
+
                     USHORT nWidth = aDocument.GetOptimalColWidth(
                         nCol, nTab, &aVirtDev, nPPTX, nPPTY, aZoom, aZoom, FALSE, &aMark,
-                        (bSetSimpleTextColWidths && bSimpleColWidth[nCol]) );
+                        &aColWidthParam[nCol] );
                     aDocument.SetColWidth( nCol, nTab,
                         nWidth + (USHORT)ScGlobal::nLastColWidthExtra );
                 }
@@ -1335,11 +1343,25 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 //					nPPTX, nPPTY, aZoom, aZoom, FALSE );
 //			}
         }
-        if ( bSetRowHeights )
-            UpdateAllRowHeights();		// with vdev or printer, depending on configuration
+
+        if (bSetRowHeights)
+        {
+            // Update all rows in all tables.
+            ScSizeDeviceProvider aProv(this);
+            ScDocRowHeightUpdater aUpdater(aDocument, aProv.GetDevice(), aProv.GetPPTX(), aProv.GetPPTY(), NULL);
+            aUpdater.update();
+        }
+        else if (!aRecalcRowRangesArray.empty())
+        {
+            // Update only specified row ranges for better performance.
+            ScSizeDeviceProvider aProv(this);
+            ScDocRowHeightUpdater aUpdater(aDocument, aProv.GetDevice(), aProv.GetPPTX(), aProv.GetPPTY(), &aRecalcRowRangesArray);
+            aUpdater.update();
+        }
     }
     FinishedLoading( SFX_LOADED_MAINDOCUMENT | SFX_LOADED_IMAGES );
 
+
     // #73762# invalidate eventually temporary table areas
     if ( bRet )
         aDocument.InvalidateTableArea();
diff --git sc/source/ui/docshell/docsh8.cxx sc/source/ui/docshell/docsh8.cxx
index 2d7fd46..2262d2e 100644
--- sc/source/ui/docshell/docsh8.cxx
+++ sc/source/ui/docshell/docsh8.cxx
@@ -83,6 +83,8 @@
 #include "patattr.hxx"
 #include "scitems.hxx"
 #include "docpool.hxx"
+#include "segmenttree.hxx"
+#include "docparam.hxx"
 
 #include <vector>
 
@@ -99,6 +101,7 @@ using ::std::vector;
 #define SC_DBPROP_ACTIVECONNECTION	"ActiveConnection"
 #define SC_DBPROP_COMMAND			"Command"
 #define SC_DBPROP_COMMANDTYPE		"CommandType"
+#define SC_DBPROP_PROPCHANGE_NOTIFY "PropertyChangeNotificationEnabled"
 
 #define SC_DBPROP_NAME				"Name"
 #define SC_DBPROP_TYPE				"Type"
@@ -302,8 +305,10 @@ static void lcl_setScalesToColumns(ScDocument& rDoc, const vector<long>& rScales
 }
 
 ULONG ScDocShell::DBaseImport( const String& rFullFileName, CharSet eCharSet,
-                                BOOL bSimpleColWidth[MAXCOLCOUNT] )
+                               ScColWidthParam aColWidthParam[MAXCOLCOUNT], ScFlatBoolRowSegments& rRowHeightsRecalc )
 {
+    ScColumn::DoubleAllocSwitch aAllocSwitch(true);
+
     ULONG nErr = eERR_OK;
     long i;
 
@@ -349,6 +354,10 @@ ULONG ScDocShell::DBaseImport( const String& rFullFileName, CharSet eCharSet,
         xRowProp->setPropertyValue(
                     rtl::OUString::createFromAscii(SC_DBPROP_COMMAND), aAny );
 
+        aAny <<= sal_False;
+        xRowProp->setPropertyValue(
+                    rtl::OUString::createFromAscii(SC_DBPROP_PROPCHANGE_NOTIFY), aAny );
+
         xRowSet->execute();
 
         long nColCount = 0;
@@ -426,16 +435,33 @@ ULONG ScDocShell::DBaseImport( const String& rFullFileName, CharSet eCharSet,
         BOOL bEnd = FALSE;
         while ( !bEnd && xRowSet->next() )
         {
+            bool bSimpleRow = true;
             if ( nRow <= MAXROW )
             {
                 SCCOL nCol = 0;
                 for (i=0; i<nColCount; i++)
                 {
+                    ScDatabaseDocUtil::StrData aStrData;
                     ScDatabaseDocUtil::PutData( &aDocument, nCol, nRow, 0,
                                                 xRow, i+1, pTypeArr[i], FALSE,
-                                                &bSimpleColWidth[nCol] );
+                                                &aStrData );
+
+                    if (aStrData.mnStrLength > aColWidthParam[nCol].mnMaxTextLen)
+                    {
+                        aColWidthParam[nCol].mnMaxTextLen = aStrData.mnStrLength;
+                        aColWidthParam[nCol].mnMaxTextRow = nRow;
+                    }
+
+                    if (!aStrData.mbSimpleText)
+                    {
+                        bSimpleRow = false;
+                        aColWidthParam[nCol].mbSimpleText = false;
+                    }
+
                     ++nCol;
                 }
+                if (!bSimpleRow)
+                    rRowHeightsRecalc.setTrue(nRow, nRow);
                 ++nRow;
             }
             else		// past the end of the spreadsheet
diff --git sc/source/ui/docshell/impex.cxx sc/source/ui/docshell/impex.cxx
index cb3bd87..1c59e9c 100644
--- sc/source/ui/docshell/impex.cxx
+++ sc/source/ui/docshell/impex.cxx
@@ -1191,8 +1191,7 @@ BOOL ScImportExport::ExtText2Doc( SvStream& rStrm )
     if ( rStrm.GetStreamCharSet() == RTL_TEXTENCODING_UNICODE )
         rStrm.StartReadingUnicodeText();
 
-    BOOL bOld = ScColumn::bDoubleAlloc;
-    ScColumn::bDoubleAlloc = TRUE;
+    ScColumn::DoubleAllocSwitch aAllocSwitch(true);
 
     SCCOL nStartCol = aRange.aStart.Col();
     SCCOL nEndCol = aRange.aEnd.Col();
@@ -1393,7 +1392,6 @@ BOOL ScImportExport::ExtText2Doc( SvStream& rStrm )
         bDetermineRange = !bDetermineRange;     // toggle
     } while (!bDetermineRange);
 
-    ScColumn::bDoubleAlloc = bOld;
     pDoc->DoColResize( nTab, nStartCol, nEndCol, 0 );
 
     delete pEnglishTransliteration;
diff --git sc/source/ui/inc/docsh.hxx sc/source/ui/inc/docsh.hxx
index 8f62ca0..f2bc127 100644
--- sc/source/ui/inc/docsh.hxx
+++ sc/source/ui/inc/docsh.hxx
@@ -68,6 +68,8 @@ class ScImportOptions;
 class ScDocShellModificator;
 class ScOptSolverSave;
 class ScSheetSaveData;
+class ScFlatBoolRowSegments;
+struct ScColWidthParam;
 
 namespace sfx2 { class FileDialogHelper; }
 struct DocShell_Impl;
@@ -148,7 +150,7 @@ class SC_DLLPUBLIC ScDocShell: public SfxObjectShell, public SfxListener
     SC_DLLPRIVATE SCTAB			GetSaveTab();
 
     SC_DLLPRIVATE ULONG			DBaseImport( const String& rFullFileName, CharSet eCharSet,
-                                 BOOL bSimpleColWidth[MAXCOLCOUNT] );
+                                             ScColWidthParam aColWidthParam[MAXCOLCOUNT], ScFlatBoolRowSegments& rRowHeightsRecalc );
     SC_DLLPRIVATE ULONG			DBaseExport( const String& rFullFileName, CharSet eCharSet,
                                  BOOL& bHasMemo );
 
-- 
1.7.0.1

