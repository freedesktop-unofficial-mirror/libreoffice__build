--- svx/inc/svx/msdffimp.hxx	2009-09-14 14:34:39.000000000 +0200
+++ svx/inc/svx/msdffimp.hxx	2009-09-14 15:30:39.000000000 +0200
@@ -170,6 +170,8 @@
 
 struct SVX_DLLPUBLIC SvxMSDffImportRec
 {
+	static const int RELTO_DEFAULT = 2;
+
 	SdrObject*	pObj;
 	Polygon*	pWrapPolygon;
 	char*		pClientAnchorBuffer;
@@ -177,9 +179,9 @@
 	char*		pClientDataBuffer;
 	UINT32		nClientDataLen;
 	UINT32		nXAlign;
-    UINT32		nXRelTo;
+	UINT32		*pXRelTo;
 	UINT32		nYAlign;
-    UINT32		nYRelTo;
+	UINT32	 	*pYRelTo;
 	UINT32		nLayoutInTableCell;
     UINT32      nFlags;
 	long		nTextRotationAngle;
@@ -216,6 +218,8 @@
 	{   return nShapeId == rEntry.nShapeId; }
 	BOOL operator<( const SvxMSDffImportRec& rEntry ) const
 	{   return nShapeId < rEntry.nShapeId;  }
+private:
+	SvxMSDffImportRec &operator=(const SvxMSDffImportRec&);
 };
 typedef SvxMSDffImportRec* MSDffImportRec_Ptr;
 
--- svx/source/msfilter/msdffimp.cxx	2009-09-14 14:35:58.000000000 +0200
+++ svx/source/msfilter/msdffimp.cxx	2009-09-14 15:05:37.000000000 +0200
@@ -5438,9 +5438,19 @@
 				switch( nPID )
 				{
 					case 0x038F: pImpRec->nXAlign = nUDData; break;
-					case 0x0390: pImpRec->nXRelTo = nUDData; break;
+					case 0x0390:
+						if (pImpRec->pXRelTo)
+							delete pImpRec->pXRelTo;
+						pImpRec->pXRelTo = new UINT32;
+						*(pImpRec->pXRelTo) = nUDData;
+						break;
 					case 0x0391: pImpRec->nYAlign = nUDData; break;
-					case 0x0392: pImpRec->nYRelTo = nUDData; break;
+					case 0x0392:
+						if (pImpRec->pYRelTo)
+							delete pImpRec->pYRelTo;
+						pImpRec->pYRelTo = new UINT32;
+						*(pImpRec->pYRelTo) = nUDData;
+						break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
 				}
 				if ( rSt.GetError() != 0 )
@@ -7857,9 +7867,9 @@
       pClientDataBuffer( 0 ),
       nClientDataLen(    0 ),
       nXAlign( 0 ),	// position n cm from left
-      nXRelTo( 2 ), //   relative to column
+      pXRelTo( NULL ), //   relative to column
       nYAlign( 0 ), // position n cm below
-      nYRelTo( 2 ), //   relative to paragraph
+      pYRelTo( NULL ), //   relative to paragraph
       nLayoutInTableCell( 0 ), // element is laid out in table cell
       nTextRotationAngle( 0 ),
       nDxTextLeft( 144 ),
@@ -7894,9 +7904,9 @@
 SvxMSDffImportRec::SvxMSDffImportRec(const SvxMSDffImportRec& rCopy)
     : pObj(	rCopy.pObj ),
       nXAlign( rCopy.nXAlign ),
-      nXRelTo( rCopy.nXRelTo ),
+      pXRelTo( NULL ),
       nYAlign( rCopy.nYAlign ),
-      nYRelTo( rCopy.nYRelTo ),
+      pYRelTo( NULL ),
       nLayoutInTableCell( rCopy.nLayoutInTableCell ),
       nTextRotationAngle( rCopy.nTextRotationAngle ),
       nDxTextLeft( rCopy.nDxTextLeft	),
@@ -7916,6 +7926,16 @@
       nShapeId( rCopy.nShapeId ),
       eShapeType( rCopy.eShapeType )
 {
+    if (rCopy.pXRelTo)
+    {
+       pXRelTo = new UINT32;
+       *pXRelTo = *(rCopy.pXRelTo);
+    }
+    if (rCopy.pYRelTo)
+    {
+       pYRelTo = new UINT32;
+       *pYRelTo = *(rCopy.pYRelTo);
+    }
     eLineStyle       = rCopy.eLineStyle; // GPF-Bug #66227#
     bDrawHell        = rCopy.bDrawHell;
     bHidden          = rCopy.bHidden;
@@ -7962,6 +7982,10 @@
         delete[] pClientDataBuffer;
     if (pWrapPolygon)
         delete pWrapPolygon;
+    if (pXRelTo)
+        delete pXRelTo;
+    if (pYRelTo)
+        delete pYRelTo;
 }
 
 /* vi:set tabstop=4 shiftwidth=4 expandtab: */
--- sw/source/filter/docx/docx-ww8graf.cxx	2009-09-14 14:37:33.000000000 +0200
+++ sw/source/filter/docx/docx-ww8graf.cxx	2009-09-14 15:43:08.000000000 +0200
@@ -1958,11 +1958,17 @@
 void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxLRSpaceItem &rLR)
 {
+    UINT32 nXRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pXRelTo )
+    {
+        nXRelTo = *(rRecord.pXRelTo);
+    }
+
     // Left adjustments - if horizontally aligned to left of
     // margin or column then remove the left wrapping
     if (rRecord.nXAlign == 1)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetLeft((USHORT)0);
     }
 
@@ -1970,18 +1976,18 @@
     // margin or column then remove the right wrapping
     if (rRecord.nXAlign == 3)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetRight((USHORT)0);
     }
 
     //Inside margin, remove left wrapping
-    if ((rRecord.nXAlign == 4) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((USHORT)0);
     }
 
     //Outside margin, remove left wrapping
-    if ((rRecord.nXAlign == 5) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((USHORT)0);
     }
@@ -1991,11 +1997,17 @@
 void SwWW8ImplReader::AdjustULWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxULSpaceItem &rUL)
 {
+    UINT32 nYRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pYRelTo )
+    {
+        nYRelTo = *(rRecord.pYRelTo);
+    }
+    
     // Top adjustment - remove upper wrapping if aligned to page
     // printable area or to page
     if (rRecord.nYAlign == 1)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetUpper((USHORT)0);
     }
 
@@ -2003,12 +2015,12 @@
     // printable area or to page
     if (rRecord.nYAlign == 3)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetLower((USHORT)0);
     }
 
     //Remove top margin if aligned vertically inside margin
-    if ((rRecord.nYAlign == 4) && (rRecord.nYRelTo == 0))
+    if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((USHORT)0);
 
     /*
@@ -2251,17 +2263,23 @@
 
     SvxMSDffImportRec aRecordFromFSPA;
     if (!pRecord)
-    {
         pRecord = &aRecordFromFSPA;
-        pRecord->nXRelTo = pFSPA->nbx;
-        pRecord->nYRelTo = pFSPA->nby;
+    if (!(pRecord->pXRelTo) && pFSPA)
+    {
+    	pRecord->pXRelTo = new UINT32;
+	*(pRecord->pXRelTo) = pFSPA->nbx;
+    }
+    if (!(pRecord->pYRelTo) && pFSPA)
+    {
+        pRecord->pYRelTo = new UINT32;
+	*(pRecord->pYRelTo) = pFSPA->nby;
     }
 
     // nXAlign - abs. Position, Left,  Centered,  Right,  Inside, Outside
     // nYAlign - abs. Position, Top,   Centered,  Bottom, Inside, Outside
 
-    // nXRelTo - Page printable area, Page,  Column,    Character
-    // nYRelTo - Page printable area, Page,  Paragraph, Line
+    // *pXRelTo - Page printable area, Page,  Column,    Character
+    // *pYRelTo - Page printable area, Page,  Paragraph, Line
 
     const UINT32 nCntXAlign = 6;
     const UINT32 nCntYAlign = 6;
@@ -2283,19 +2301,19 @@
         // is a hint that these values aren't set by the escher import - see
         // method <SwMSDffManager::ProcessObj(..)>. Then, check if for each
         // values, if it differs from the one in the FSPA.
-        if ( pRecord->nXRelTo == 2 && pRecord->nYRelTo == 2 )
+        if ( *(pRecord->pXRelTo) == 2 && *(pRecord->pYRelTo) == 2 )
         {
             // if <nYRelTo> differs from <FSPA.nby> overwrite <nYRelTo>
-            if ( pFSPA->nby != pRecord->nYRelTo )
+            if ( pFSPA->nby != *(pRecord->pYRelTo) )
             {
-                pRecord->nYRelTo = pFSPA->nby;
+                *(pRecord->pYRelTo) = pFSPA->nby;
             }
         }
         // <--
 	}
 
-    UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
-    UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
+    UINT32 nXRelTo = nCntRelTo > *(pRecord->pXRelTo) ? *(pRecord->pXRelTo) : 1;
+    UINT32 nYRelTo = nCntRelTo > *(pRecord->pYRelTo) ? *(pRecord->pYRelTo) : 1;
 
     // --> OD 2005-03-03 #i43718#
     RndStdIds eAnchor = IsInlineEscherHack() ? FLY_IN_CNTNT : FLY_AUTO_CNTNT;
--- sw/source/filter/docx/docx-ww8par.cxx	2009-09-14 14:37:33.000000000 +0200
+++ sw/source/filter/docx/docx-ww8par.cxx	2009-09-14 15:47:46.000000000 +0200
@@ -320,9 +320,19 @@
 				switch( nPID )
 				{
 					case 0x038F: pImpRec->nXAlign = nUDData; break;
-					case 0x0390: pImpRec->nXRelTo = nUDData; break;
+					case 0x0390:
+						if (pImpRec->pXRelTo)
+							delete pImpRec->pXRelTo;
+						pImpRec->pXRelTo = new UINT32;
+						*(pImpRec->pXRelTo) = nUDData;
+						break;
 					case 0x0391: pImpRec->nYAlign = nUDData; break;
-					case 0x0392: pImpRec->nYRelTo = nUDData; break;
+					case 0x0392:
+						if (pImpRec->pYRelTo)
+							delete pImpRec->pYRelTo;
+						pImpRec->pYRelTo = new UINT32;
+						*(pImpRec->pYRelTo) = nUDData;
+						break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
 				}
 				if ( rSt.GetError() != 0 )
--- sw/source/filter/ww8/ww8graf.cxx	2009-09-14 14:37:32.000000000 +0200
+++ sw/source/filter/ww8/ww8graf.cxx	2009-09-14 15:59:53.000000000 +0200
@@ -1958,11 +1958,17 @@
 void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxLRSpaceItem &rLR)
 {
+    UINT32 nXRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pXRelTo )
+    {
+        nXRelTo = *(rRecord.pXRelTo);
+    }
+
     // Left adjustments - if horizontally aligned to left of
     // margin or column then remove the left wrapping
     if (rRecord.nXAlign == 1)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetLeft((USHORT)0);
     }
 
@@ -1970,18 +1976,18 @@
     // margin or column then remove the right wrapping
     if (rRecord.nXAlign == 3)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetRight((USHORT)0);
     }
 
     //Inside margin, remove left wrapping
-    if ((rRecord.nXAlign == 4) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((USHORT)0);
     }
 
     //Outside margin, remove left wrapping
-    if ((rRecord.nXAlign == 5) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((USHORT)0);
     }
@@ -1991,11 +1997,17 @@
 void SwWW8ImplReader::AdjustULWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxULSpaceItem &rUL)
 {
+    UINT32 nYRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pYRelTo )
+    {
+        nYRelTo = *(rRecord.pYRelTo);
+    }
+
     // Top adjustment - remove upper wrapping if aligned to page
     // printable area or to page
     if (rRecord.nYAlign == 1)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetUpper((USHORT)0);
     }
 
@@ -2003,12 +2015,12 @@
     // printable area or to page
     if (rRecord.nYAlign == 3)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetLower((USHORT)0);
     }
 
     //Remove top margin if aligned vertically inside margin
-    if ((rRecord.nYAlign == 4) && (rRecord.nYRelTo == 0))
+    if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((USHORT)0);
 
     /*
@@ -2251,10 +2263,16 @@
 
     SvxMSDffImportRec aRecordFromFSPA;
     if (!pRecord)
-    {
         pRecord = &aRecordFromFSPA;
-        pRecord->nXRelTo = pFSPA->nbx;
-        pRecord->nYRelTo = pFSPA->nby;
+    if (!(pRecord->pXRelTo) && pFSPA)
+    {
+    	pRecord->pXRelTo = new UINT32;
+	*(pRecord->pXRelTo) = pFSPA->nbx;
+    }
+    if (!(pRecord->pYRelTo) && pFSPA)
+    {
+        pRecord->pYRelTo = new UINT32;
+	*(pRecord->pYRelTo) = pFSPA->nby;
     }
 
     // nXAlign - abs. Position, Left,  Centered,  Right,  Inside, Outside
@@ -2283,19 +2301,19 @@
         // is a hint that these values aren't set by the escher import - see
         // method <SwMSDffManager::ProcessObj(..)>. Then, check if for each
         // values, if it differs from the one in the FSPA.
-        if ( pRecord->nXRelTo == 2 && pRecord->nYRelTo == 2 )
+        if ( *(pRecord->pXRelTo) == 2 && *(pRecord->pYRelTo) == 2 )
         {
             // if <nYRelTo> differs from <FSPA.nby> overwrite <nYRelTo>
-            if ( pFSPA->nby != pRecord->nYRelTo )
+            if ( pFSPA->nby != *(pRecord->pYRelTo) )
             {
-                pRecord->nYRelTo = pFSPA->nby;
+                *(pRecord->pYRelTo) = pFSPA->nby;
             }
         }
         // <--
 	}
 
-    UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
-    UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
+    UINT32 nXRelTo = nCntRelTo > *(pRecord->pXRelTo) ? *(pRecord->pXRelTo) : 1;
+    UINT32 nYRelTo = nCntRelTo > *(pRecord->pYRelTo) ? *(pRecord->pYRelTo) : 1;
 
     // --> OD 2005-03-03 #i43718#
     RndStdIds eAnchor = IsInlineEscherHack() ? FLY_IN_CNTNT : FLY_AUTO_CNTNT;
--- sw/source/filter/ww8/ww8par.cxx	2009-09-14 14:37:32.000000000 +0200
+++ sw/source/filter/ww8/ww8par.cxx	2009-09-14 16:04:31.000000000 +0200
@@ -471,9 +471,19 @@
 				switch( nPID )
 				{
 					case 0x038F: pImpRec->nXAlign = nUDData; break;
-					case 0x0390: pImpRec->nXRelTo = nUDData; break;
+					case 0x0390:
+						if (pImpRec->pXRelTo)
+							delete pImpRec->pXRelTo;
+						pImpRec->pXRelTo = new UINT32;
+						*(pImpRec->pXRelTo) = nUDData;
+						break;
 					case 0x0391: pImpRec->nYAlign = nUDData; break;
-					case 0x0392: pImpRec->nYRelTo = nUDData; break;
+					case 0x0392:
+						if (pImpRec->pYRelTo)
+							delete pImpRec->pYRelTo;
+						pImpRec->pYRelTo = new UINT32;
+						*(pImpRec->pYRelTo) = nUDData;
+						break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
 				}
 				if ( rSt.GetError() != 0 )
