--- svx/inc/svx/msdffimp.hxx	2009-08-26 16:20:59.296875000 +0200
+++ svx/inc/svx/msdffimp.hxx	2009-08-26 16:26:13.703125000 +0200
@@ -50,6 +50,8 @@
 
 #include <sot/storage.hxx>
 
+#include <boost/optional.hpp>
+
 class Graphic;
 class SvStream;
 class SdrObject;
@@ -170,6 +172,8 @@ struct MSDffTxId
 
 struct SVX_DLLPUBLIC SvxMSDffImportRec
 {
+	static const int RELTO_DEFAULT = 2;
+
 	SdrObject*	pObj;
 	Polygon*	pWrapPolygon;
 	char*		pClientAnchorBuffer;
@@ -177,9 +181,9 @@ struct SVX_DLLPUBLIC SvxMSDffImportRec
 	char*		pClientDataBuffer;
 	UINT32		nClientDataLen;
 	UINT32		nXAlign;
-    UINT32		nXRelTo;
+    boost::optional< UINT32 >		nXRelTo;
 	UINT32		nYAlign;
-    UINT32		nYRelTo;
+    boost::optional< UINT32	>    	nYRelTo;
 	UINT32		nLayoutInTableCell;
     UINT32      nFlags;
 	long		nTextRotationAngle;
--- svx/source/msfilter/msdffimp.cxx	2009-08-26 16:21:11.265625000 +0200
+++ svx/source/msfilter/msdffimp.cxx	2009-08-26 16:28:45.265625000 +0200
@@ -5438,9 +5438,9 @@ SdrObject* SvxMSDffManager::ProcessObj(S
 				switch( nPID )
 				{
 					case 0x038F: pImpRec->nXAlign = nUDData; break;
-					case 0x0390: pImpRec->nXRelTo = nUDData; break;
+					case 0x0390: pImpRec->nXRelTo.reset(nUDData); break;
 					case 0x0391: pImpRec->nYAlign = nUDData; break;
-					case 0x0392: pImpRec->nYRelTo = nUDData; break;
+					case 0x0392: pImpRec->nYRelTo.reset(nUDData); break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
 				}
 				if ( rSt.GetError() != 0 )
@@ -7857,9 +7857,9 @@ SvxMSDffImportRec::SvxMSDffImportRec()
       pClientDataBuffer( 0 ),
       nClientDataLen(    0 ),
       nXAlign( 0 ),	// position n cm from left
-      nXRelTo( 2 ), //   relative to column
+//      nXRelTo( 2 ), //   relative to column
       nYAlign( 0 ), // position n cm below
-      nYRelTo( 2 ), //   relative to paragraph
+//      nYRelTo( 2 ), //   relative to paragraph
       nLayoutInTableCell( 0 ), // element is laid out in table cell
       nTextRotationAngle( 0 ),
       nDxTextLeft( 144 ),
--- sw/source/filter/docx/docx-ww8graf.cxx	2009-08-26 16:16:37.187500000 +0200
+++ sw/source/filter/docx/docx-ww8graf.cxx	2009-08-26 22:31:35.109375000 +0200
@@ -1958,11 +1958,17 @@ void SwWW8ImplReader::MatchSdrItemsIntoF
 void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxLRSpaceItem &rLR)
 {
+    UINT32 nXRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( !!rRecord.nXRelTo )
+    {
+        nXRelTo = *rRecord.nXRelTo.get( );
+    }
+
     // Left adjustments - if horizontally aligned to left of
     // margin or column then remove the left wrapping
     if (rRecord.nXAlign == 1)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetLeft((USHORT)0);
     }
 
@@ -1970,18 +1976,18 @@ void SwWW8ImplReader::AdjustLRWrapForWor
     // margin or column then remove the right wrapping
     if (rRecord.nXAlign == 3)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetRight((USHORT)0);
     }
 
     //Inside margin, remove left wrapping
-    if ((rRecord.nXAlign == 4) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((USHORT)0);
     }
 
     //Outside margin, remove left wrapping
-    if ((rRecord.nXAlign == 5) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((USHORT)0);
     }
@@ -1991,11 +1997,17 @@ void SwWW8ImplReader::AdjustLRWrapForWor
 void SwWW8ImplReader::AdjustULWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxULSpaceItem &rUL)
 {
+    UINT32 nYRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( !!rRecord.nYRelTo )
+    {
+        nYRelTo = *rRecord.nYRelTo.get( );
+    }
+    
     // Top adjustment - remove upper wrapping if aligned to page
     // printable area or to page
     if (rRecord.nYAlign == 1)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetUpper((USHORT)0);
     }
 
@@ -2003,12 +2015,12 @@ void SwWW8ImplReader::AdjustULWrapForWor
     // printable area or to page
     if (rRecord.nYAlign == 3)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetLower((USHORT)0);
     }
 
     //Remove top margin if aligned vertically inside margin
-    if ((rRecord.nYAlign == 4) && (rRecord.nYRelTo == 0))
+    if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((USHORT)0);
 
     /*
@@ -2251,11 +2263,11 @@ RndStdIds SwWW8ImplReader::ProcessEscher
 
     SvxMSDffImportRec aRecordFromFSPA;
     if (!pRecord)
-    {
         pRecord = &aRecordFromFSPA;
-        pRecord->nXRelTo = pFSPA->nbx;
-        pRecord->nYRelTo = pFSPA->nby;
-    }
+    if (!pRecord->nXRelTo && pFSPA)
+        pRecord->nXRelTo.reset(pFSPA->nbx);
+    if (!pRecord->nYRelTo && pFSPA)
+        pRecord->nYRelTo.reset(pFSPA->nby);
 
     // nXAlign - abs. Position, Left,  Centered,  Right,  Inside, Outside
     // nYAlign - abs. Position, Top,   Centered,  Bottom, Inside, Outside
@@ -2283,19 +2295,19 @@ RndStdIds SwWW8ImplReader::ProcessEscher
         // is a hint that these values aren't set by the escher import - see
         // method <SwMSDffManager::ProcessObj(..)>. Then, check if for each
         // values, if it differs from the one in the FSPA.
-        if ( pRecord->nXRelTo == 2 && pRecord->nYRelTo == 2 )
+        if ( *pRecord->nXRelTo.get( ) == 2 && *pRecord->nYRelTo.get( ) == 2 )
         {
             // if <nYRelTo> differs from <FSPA.nby> overwrite <nYRelTo>
-            if ( pFSPA->nby != pRecord->nYRelTo )
+            if ( pFSPA->nby != *pRecord->nYRelTo.get( ) )
             {
-                pRecord->nYRelTo = pFSPA->nby;
+                pRecord->nYRelTo.reset(pFSPA->nby);
             }
         }
         // <--
 	}
 
-    UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
-    UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
+    UINT32 nXRelTo = nCntRelTo > *pRecord->nXRelTo.get( ) ? *pRecord->nXRelTo.get( ) : 1;
+    UINT32 nYRelTo = nCntRelTo > *pRecord->nYRelTo.get( ) ? *pRecord->nYRelTo.get( ) : 1;
 
     // --> OD 2005-03-03 #i43718#
     RndStdIds eAnchor = IsInlineEscherHack() ? FLY_IN_CNTNT : FLY_AUTO_CNTNT;
--- sw/source/filter/docx/docx-ww8par.cxx	2009-08-26 16:16:37.203125000 +0200
+++ sw/source/filter/docx/docx-ww8par.cxx	2009-08-26 16:51:32.640625000 +0200
@@ -320,9 +320,9 @@ SdrObject* SwMSDffManager::ProcessObj(Sv
 				switch( nPID )
 				{
 					case 0x038F: pImpRec->nXAlign = nUDData; break;
-					case 0x0390: pImpRec->nXRelTo = nUDData; break;
+					case 0x0390: pImpRec->nXRelTo.reset(nUDData); break;
 					case 0x0391: pImpRec->nYAlign = nUDData; break;
-					case 0x0392: pImpRec->nYRelTo = nUDData; break;
+					case 0x0392: pImpRec->nYRelTo.reset(nUDData); break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
 				}
 				if ( rSt.GetError() != 0 )
--- sw/source/filter/ww8/ww8graf.cxx	2009-08-26 16:16:37.921875000 +0200
+++ sw/source/filter/ww8/ww8graf.cxx	2009-08-26 22:32:01.453125000 +0200
@@ -1958,11 +1958,17 @@ void SwWW8ImplReader::MatchSdrItemsIntoF
 void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxLRSpaceItem &rLR)
 {
+    UINT32 nXRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( !!rRecord.nXRelTo )
+    {
+        nXRelTo = *rRecord.nXRelTo.get( );
+    }
+
     // Left adjustments - if horizontally aligned to left of
     // margin or column then remove the left wrapping
     if (rRecord.nXAlign == 1)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetLeft((USHORT)0);
     }
 
@@ -1970,18 +1976,18 @@ void SwWW8ImplReader::AdjustLRWrapForWor
     // margin or column then remove the right wrapping
     if (rRecord.nXAlign == 3)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetRight((USHORT)0);
     }
 
     //Inside margin, remove left wrapping
-    if ((rRecord.nXAlign == 4) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((USHORT)0);
     }
 
     //Outside margin, remove left wrapping
-    if ((rRecord.nXAlign == 5) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((USHORT)0);
     }
@@ -1991,11 +1997,17 @@ void SwWW8ImplReader::AdjustLRWrapForWor
 void SwWW8ImplReader::AdjustULWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxULSpaceItem &rUL)
 {
+    UINT32 nYRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( !!rRecord.nYRelTo )
+    {
+        nYRelTo = *rRecord.nYRelTo.get( );
+    }
+
     // Top adjustment - remove upper wrapping if aligned to page
     // printable area or to page
     if (rRecord.nYAlign == 1)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetUpper((USHORT)0);
     }
 
@@ -2003,12 +2015,12 @@ void SwWW8ImplReader::AdjustULWrapForWor
     // printable area or to page
     if (rRecord.nYAlign == 3)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetLower((USHORT)0);
     }
 
     //Remove top margin if aligned vertically inside margin
-    if ((rRecord.nYAlign == 4) && (rRecord.nYRelTo == 0))
+    if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((USHORT)0);
 
     /*
@@ -2251,11 +2263,11 @@ RndStdIds SwWW8ImplReader::ProcessEscher
 
     SvxMSDffImportRec aRecordFromFSPA;
     if (!pRecord)
-    {
         pRecord = &aRecordFromFSPA;
-        pRecord->nXRelTo = pFSPA->nbx;
-        pRecord->nYRelTo = pFSPA->nby;
-    }
+    if (!pRecord->nXRelTo && pFSPA)
+        pRecord->nXRelTo.reset(pFSPA->nbx);
+    if (!pRecord->nYRelTo && pFSPA)
+        pRecord->nYRelTo.reset(pFSPA->nby);
 
     // nXAlign - abs. Position, Left,  Centered,  Right,  Inside, Outside
     // nYAlign - abs. Position, Top,   Centered,  Bottom, Inside, Outside
@@ -2283,19 +2295,19 @@ RndStdIds SwWW8ImplReader::ProcessEscher
         // is a hint that these values aren't set by the escher import - see
         // method <SwMSDffManager::ProcessObj(..)>. Then, check if for each
         // values, if it differs from the one in the FSPA.
-        if ( pRecord->nXRelTo == 2 && pRecord->nYRelTo == 2 )
+        if ( *pRecord->nXRelTo.get( ) == 2 && *pRecord->nYRelTo.get( ) == 2 )
         {
             // if <nYRelTo> differs from <FSPA.nby> overwrite <nYRelTo>
-            if ( pFSPA->nby != pRecord->nYRelTo )
+            if ( pFSPA->nby != *pRecord->nYRelTo.get( ) )
             {
-                pRecord->nYRelTo = pFSPA->nby;
+                pRecord->nYRelTo.reset(pFSPA->nby);
             }
         }
         // <--
 	}
 
-    UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
-    UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
+    UINT32 nXRelTo = nCntRelTo > *pRecord->nXRelTo.get( ) ? *pRecord->nXRelTo.get( ) : 1;
+    UINT32 nYRelTo = nCntRelTo > *pRecord->nYRelTo.get( ) ? *pRecord->nYRelTo.get( ) : 1;
 
     // --> OD 2005-03-03 #i43718#
     RndStdIds eAnchor = IsInlineEscherHack() ? FLY_IN_CNTNT : FLY_AUTO_CNTNT;
Only in sw/source/filter/ww8: ww8graf.cxx
--- sw/source/filter/ww8/ww8par.cxx	2009-08-26 16:16:37.937500000 +0200
+++ sw/source/filter/ww8/ww8par.cxx	2009-08-26 16:43:09.906250000 +0200
@@ -471,9 +471,9 @@ SdrObject* SwMSDffManager::ProcessObj(Sv
 				switch( nPID )
 				{
 					case 0x038F: pImpRec->nXAlign = nUDData; break;
-					case 0x0390: pImpRec->nXRelTo = nUDData; break;
+					case 0x0390: pImpRec->nXRelTo.reset(nUDData); break;
 					case 0x0391: pImpRec->nYAlign = nUDData; break;
-					case 0x0392: pImpRec->nYRelTo = nUDData; break;
+					case 0x0392: pImpRec->nYRelTo.reset(nUDData); break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
 				}
 				if ( rSt.GetError() != 0 )
