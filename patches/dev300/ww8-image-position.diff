From beb64cffcfbc9003b5fad5688c098ad8a6a17ef9 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 17:07:21 +0200
Subject: [PATCH 759/878] ww8-image-position.diff

---
 svx/inc/svx/msdffimp.hxx         |    8 ++++-
 svx/source/msfilter/msdffimp.cxx |   36 +++++++++++++++++++++++----
 sw/source/filter/ww8/ww8graf.cxx |   48 ++++++++++++++++++++++++++------------
 sw/source/filter/ww8/ww8par.cxx  |   14 +++++++++-
 4 files changed, 81 insertions(+), 25 deletions(-)

diff --git a/svx/inc/svx/msdffimp.hxx b/svx/inc/svx/msdffimp.hxx
index 4b6c085..694eb3d 100644
--- a/svx/inc/svx/msdffimp.hxx
+++ b/svx/inc/svx/msdffimp.hxx
@@ -166,6 +166,8 @@ struct MSDffTxId
 
 struct SVX_DLLPUBLIC SvxMSDffImportRec
 {
+    static const int RELTO_DEFAULT = 2;
+
     SdrObject*	pObj;
     Polygon*	pWrapPolygon;
     char*		pClientAnchorBuffer;
@@ -173,9 +175,9 @@ struct SVX_DLLPUBLIC SvxMSDffImportRec
     char*		pClientDataBuffer;
     UINT32		nClientDataLen;
     UINT32		nXAlign;
-    UINT32		nXRelTo;
+    UINT32		*pXRelTo;
     UINT32		nYAlign;
-    UINT32		nYRelTo;
+    UINT32	 	*pYRelTo;
     UINT32		nLayoutInTableCell;
     UINT32      nFlags;
     long		nTextRotationAngle;
@@ -212,6 +214,8 @@ struct SVX_DLLPUBLIC SvxMSDffImportRec
     {   return nShapeId == rEntry.nShapeId; }
     BOOL operator<( const SvxMSDffImportRec& rEntry ) const
     {   return nShapeId < rEntry.nShapeId;  }
+private:
+    SvxMSDffImportRec &operator=(const SvxMSDffImportRec&);
 };
 typedef SvxMSDffImportRec* MSDffImportRec_Ptr;
 
diff --git a/svx/source/msfilter/msdffimp.cxx b/svx/source/msfilter/msdffimp.cxx
index 7ad2a4b..5d83564 100644
--- a/svx/source/msfilter/msdffimp.cxx
+++ b/svx/source/msfilter/msdffimp.cxx
@@ -5651,9 +5651,19 @@ SdrObject* SvxMSDffManager::ProcessObj(SvStream& rSt,
                 switch( nPID )
                 {
                     case 0x038F: pImpRec->nXAlign = nUDData; break;
-                    case 0x0390: pImpRec->nXRelTo = nUDData; break;
+                    case 0x0390:
+                        if (pImpRec->pXRelTo)
+                            delete pImpRec->pXRelTo;
+                        pImpRec->pXRelTo = new UINT32;
+                        *(pImpRec->pXRelTo) = nUDData;
+                        break;
                     case 0x0391: pImpRec->nYAlign = nUDData; break;
-                    case 0x0392: pImpRec->nYRelTo = nUDData; break;
+                    case 0x0392:
+                        if (pImpRec->pYRelTo)
+                            delete pImpRec->pYRelTo;
+                        pImpRec->pYRelTo = new UINT32;
+                        *(pImpRec->pYRelTo) = nUDData;
+                        break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
                 }
                 if ( rSt.GetError() != 0 )
@@ -8072,9 +8082,9 @@ SvxMSDffImportRec::SvxMSDffImportRec()
       pClientDataBuffer( 0 ),
       nClientDataLen(    0 ),
       nXAlign( 0 ),	// position n cm from left
-      nXRelTo( 2 ), //   relative to column
+      pXRelTo( NULL ), //   relative to column
       nYAlign( 0 ), // position n cm below
-      nYRelTo( 2 ), //   relative to paragraph
+      pYRelTo( NULL ), //   relative to paragraph
       nLayoutInTableCell( 0 ), // element is laid out in table cell
       nTextRotationAngle( 0 ),
       nDxTextLeft( 144 ),
@@ -8109,9 +8119,9 @@ SvxMSDffImportRec::SvxMSDffImportRec()
 SvxMSDffImportRec::SvxMSDffImportRec(const SvxMSDffImportRec& rCopy)
     : pObj(	rCopy.pObj ),
       nXAlign( rCopy.nXAlign ),
-      nXRelTo( rCopy.nXRelTo ),
+      pXRelTo( NULL ),
       nYAlign( rCopy.nYAlign ),
-      nYRelTo( rCopy.nYRelTo ),
+      pYRelTo( NULL ),
       nLayoutInTableCell( rCopy.nLayoutInTableCell ),
       nTextRotationAngle( rCopy.nTextRotationAngle ),
       nDxTextLeft( rCopy.nDxTextLeft	),
@@ -8131,6 +8141,16 @@ SvxMSDffImportRec::SvxMSDffImportRec(const SvxMSDffImportRec& rCopy)
       nShapeId( rCopy.nShapeId ),
       eShapeType( rCopy.eShapeType )
 {
+    if (rCopy.pXRelTo)
+    {
+       pXRelTo = new UINT32;
+       *pXRelTo = *(rCopy.pXRelTo);
+    }
+    if (rCopy.pYRelTo)
+    {
+       pYRelTo = new UINT32;
+       *pYRelTo = *(rCopy.pYRelTo);
+    }
     eLineStyle       = rCopy.eLineStyle; // GPF-Bug #66227#
     bDrawHell        = rCopy.bDrawHell;
     bHidden          = rCopy.bHidden;
@@ -8177,6 +8197,10 @@ SvxMSDffImportRec::~SvxMSDffImportRec()
         delete[] pClientDataBuffer;
     if (pWrapPolygon)
         delete pWrapPolygon;
+    if (pXRelTo)
+        delete pXRelTo;
+    if (pYRelTo)
+        delete pYRelTo;
 }
 
 /* vi:set tabstop=4 shiftwidth=4 expandtab: */
diff --git a/sw/source/filter/ww8/ww8graf.cxx b/sw/source/filter/ww8/ww8graf.cxx
index e6905d9..93c7061 100644
--- a/sw/source/filter/ww8/ww8graf.cxx
+++ b/sw/source/filter/ww8/ww8graf.cxx
@@ -1957,11 +1957,17 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
 void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxLRSpaceItem &rLR)
 {
+    UINT32 nXRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pXRelTo )
+    {
+        nXRelTo = *(rRecord.pXRelTo);
+    }
+
     // Left adjustments - if horizontally aligned to left of
     // margin or column then remove the left wrapping
     if (rRecord.nXAlign == 1)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetLeft((USHORT)0);
     }
 
@@ -1969,18 +1975,18 @@ void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     // margin or column then remove the right wrapping
     if (rRecord.nXAlign == 3)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetRight((USHORT)0);
     }
 
     //Inside margin, remove left wrapping
-    if ((rRecord.nXAlign == 4) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((USHORT)0);
     }
 
     //Outside margin, remove left wrapping
-    if ((rRecord.nXAlign == 5) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((USHORT)0);
     }
@@ -1990,11 +1996,17 @@ void SwWW8ImplReader::AdjustLRWrapForWordMargins(
 void SwWW8ImplReader::AdjustULWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxULSpaceItem &rUL)
 {
+    UINT32 nYRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pYRelTo )
+    {
+        nYRelTo = *(rRecord.pYRelTo);
+    }
+
     // Top adjustment - remove upper wrapping if aligned to page
     // printable area or to page
     if (rRecord.nYAlign == 1)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetUpper((USHORT)0);
     }
 
@@ -2002,12 +2014,12 @@ void SwWW8ImplReader::AdjustULWrapForWordMargins(
     // printable area or to page
     if (rRecord.nYAlign == 3)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetLower((USHORT)0);
     }
 
     //Remove top margin if aligned vertically inside margin
-    if ((rRecord.nYAlign == 4) && (rRecord.nYRelTo == 0))
+    if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((USHORT)0);
 
     /*
@@ -2250,10 +2262,16 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
 
     SvxMSDffImportRec aRecordFromFSPA;
     if (!pRecord)
-    {
         pRecord = &aRecordFromFSPA;
-        pRecord->nXRelTo = pFSPA->nbx;
-        pRecord->nYRelTo = pFSPA->nby;
+    if (!(pRecord->pXRelTo) && pFSPA)
+    {
+        pRecord->pXRelTo = new UINT32;
+    *(pRecord->pXRelTo) = pFSPA->nbx;
+    }
+    if (!(pRecord->pYRelTo) && pFSPA)
+    {
+        pRecord->pYRelTo = new UINT32;
+    *(pRecord->pYRelTo) = pFSPA->nby;
     }
 
     // nXAlign - abs. Position, Left,  Centered,  Right,  Inside, Outside
@@ -2282,19 +2300,19 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
         // is a hint that these values aren't set by the escher import - see
         // method <SwMSDffManager::ProcessObj(..)>. Then, check if for each
         // values, if it differs from the one in the FSPA.
-        if ( pRecord->nXRelTo == 2 && pRecord->nYRelTo == 2 )
+        if ( *(pRecord->pXRelTo) == 2 && *(pRecord->pYRelTo) == 2 )
         {
             // if <nYRelTo> differs from <FSPA.nby> overwrite <nYRelTo>
-            if ( pFSPA->nby != pRecord->nYRelTo )
+            if ( pFSPA->nby != *(pRecord->pYRelTo) )
             {
-                pRecord->nYRelTo = pFSPA->nby;
+                *(pRecord->pYRelTo) = pFSPA->nby;
             }
         }
         // <--
     }
 
-    UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
-    UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
+    UINT32 nXRelTo = nCntRelTo > *(pRecord->pXRelTo) ? *(pRecord->pXRelTo) : 1;
+    UINT32 nYRelTo = nCntRelTo > *(pRecord->pYRelTo) ? *(pRecord->pYRelTo) : 1;
 
     // --> OD 2005-03-03 #i43718#
     RndStdIds eAnchor = IsInlineEscherHack() ? FLY_IN_CNTNT : FLY_AUTO_CNTNT;
diff --git a/sw/source/filter/ww8/ww8par.cxx b/sw/source/filter/ww8/ww8par.cxx
index 9eb6810..d1d46d5 100644
--- a/sw/source/filter/ww8/ww8par.cxx
+++ b/sw/source/filter/ww8/ww8par.cxx
@@ -407,9 +407,19 @@ SdrObject* SwMSDffManager::ProcessObj(SvStream& rSt,
                 switch( nPID )
                 {
                     case 0x038F: pImpRec->nXAlign = nUDData; break;
-                    case 0x0390: pImpRec->nXRelTo = nUDData; break;
+                    case 0x0390:
+                        if (pImpRec->pXRelTo)
+                            delete pImpRec->pXRelTo;
+                        pImpRec->pXRelTo = new UINT32;
+                        *(pImpRec->pXRelTo) = nUDData;
+                        break;
                     case 0x0391: pImpRec->nYAlign = nUDData; break;
-                    case 0x0392: pImpRec->nYRelTo = nUDData; break;
+                    case 0x0392:
+                        if (pImpRec->pYRelTo)
+                            delete pImpRec->pYRelTo;
+                        pImpRec->pYRelTo = new UINT32;
+                        *(pImpRec->pYRelTo) = nUDData;
+                        break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
                 }
                 if ( rSt.GetError() != 0 )
-- 
1.7.0.1

