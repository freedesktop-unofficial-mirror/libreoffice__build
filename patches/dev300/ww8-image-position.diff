---
 filter/inc/filter/msfilter/msdffimp.hxx |    8 ++++-
 filter/source/msfilter/msdffimp.cxx     |   36 +++++++++++++++++++----
 sw/source/filter/ww8/ww8graf.cxx        |   48 +++++++++++++++++++++---------
 sw/source/filter/ww8/ww8par.cxx         |   14 ++++++++-
 4 files changed, 81 insertions(+), 25 deletions(-)

diff --git filter/inc/filter/msfilter/msdffimp.hxx filter/inc/filter/msfilter/msdffimp.hxx
index 68c4b22..67571fb 100644
--- filter/inc/filter/msfilter/msdffimp.hxx
+++ filter/inc/filter/msfilter/msdffimp.hxx
@@ -257,6 +257,8 @@ struct MSDffTxId
 
 struct MSFILTER_DLLPUBLIC SvxMSDffImportRec
 {
+    static const int RELTO_DEFAULT = 2;
+
     SdrObject*	pObj;
     Polygon*	pWrapPolygon;
     char*		pClientAnchorBuffer;
@@ -264,9 +266,9 @@ struct MSFILTER_DLLPUBLIC SvxMSDffImportRec
     char*		pClientDataBuffer;
     UINT32		nClientDataLen;
     UINT32		nXAlign;
-    UINT32		nXRelTo;
+    UINT32		*pXRelTo;
     UINT32		nYAlign;
-    UINT32		nYRelTo;
+    UINT32	 	*pYRelTo;
     UINT32		nLayoutInTableCell;
     UINT32      nFlags;
     long		nTextRotationAngle;
@@ -303,6 +305,8 @@ struct MSFILTER_DLLPUBLIC SvxMSDffImportRec
     {   return nShapeId == rEntry.nShapeId; }
     BOOL operator<( const SvxMSDffImportRec& rEntry ) const
     {   return nShapeId < rEntry.nShapeId;  }
+private:
+    SvxMSDffImportRec &operator=(const SvxMSDffImportRec&);
 };
 typedef SvxMSDffImportRec* MSDffImportRec_Ptr;
 
diff --git filter/source/msfilter/msdffimp.cxx filter/source/msfilter/msdffimp.cxx
index c9fece2..48309b1 100644
--- filter/source/msfilter/msdffimp.cxx
+++ filter/source/msfilter/msdffimp.cxx
@@ -5608,9 +5608,19 @@ SdrObject* SvxMSDffManager::ProcessObj(SvStream& rSt,
                 switch( nPID )
                 {
                     case 0x038F: pImpRec->nXAlign = nUDData; break;
-                    case 0x0390: pImpRec->nXRelTo = nUDData; break;
+                    case 0x0390:
+                        if (pImpRec->pXRelTo)
+                            delete pImpRec->pXRelTo;
+                        pImpRec->pXRelTo = new UINT32;
+                        *(pImpRec->pXRelTo) = nUDData;
+                        break;
                     case 0x0391: pImpRec->nYAlign = nUDData; break;
-                    case 0x0392: pImpRec->nYRelTo = nUDData; break;
+                    case 0x0392:
+                        if (pImpRec->pYRelTo)
+                            delete pImpRec->pYRelTo;
+                        pImpRec->pYRelTo = new UINT32;
+                        *(pImpRec->pYRelTo) = nUDData;
+                        break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
                 }
                 if ( rSt.GetError() != 0 )
@@ -8029,9 +8039,9 @@ SvxMSDffImportRec::SvxMSDffImportRec()
       pClientDataBuffer( 0 ),
       nClientDataLen(    0 ),
       nXAlign( 0 ),	// position n cm from left
-      nXRelTo( 2 ), //   relative to column
+      pXRelTo( NULL ), //   relative to column
       nYAlign( 0 ), // position n cm below
-      nYRelTo( 2 ), //   relative to paragraph
+      pYRelTo( NULL ), //   relative to paragraph
       nLayoutInTableCell( 0 ), // element is laid out in table cell
       nTextRotationAngle( 0 ),
       nDxTextLeft( 144 ),
@@ -8066,9 +8076,9 @@ SvxMSDffImportRec::SvxMSDffImportRec()
 SvxMSDffImportRec::SvxMSDffImportRec(const SvxMSDffImportRec& rCopy)
     : pObj(	rCopy.pObj ),
       nXAlign( rCopy.nXAlign ),
-      nXRelTo( rCopy.nXRelTo ),
+      pXRelTo( NULL ),
       nYAlign( rCopy.nYAlign ),
-      nYRelTo( rCopy.nYRelTo ),
+      pYRelTo( NULL ),
       nLayoutInTableCell( rCopy.nLayoutInTableCell ),
       nTextRotationAngle( rCopy.nTextRotationAngle ),
       nDxTextLeft( rCopy.nDxTextLeft	),
@@ -8088,6 +8098,16 @@ SvxMSDffImportRec::SvxMSDffImportRec(const SvxMSDffImportRec& rCopy)
       nShapeId( rCopy.nShapeId ),
       eShapeType( rCopy.eShapeType )
 {
+    if (rCopy.pXRelTo)
+    {
+       pXRelTo = new UINT32;
+       *pXRelTo = *(rCopy.pXRelTo);
+    }
+    if (rCopy.pYRelTo)
+    {
+       pYRelTo = new UINT32;
+       *pYRelTo = *(rCopy.pYRelTo);
+    }
     eLineStyle       = rCopy.eLineStyle; // GPF-Bug #66227#
     bDrawHell        = rCopy.bDrawHell;
     bHidden          = rCopy.bHidden;
@@ -8134,6 +8154,10 @@ SvxMSDffImportRec::~SvxMSDffImportRec()
         delete[] pClientDataBuffer;
     if (pWrapPolygon)
         delete pWrapPolygon;
+    if (pXRelTo)
+        delete pXRelTo;
+    if (pYRelTo)
+        delete pYRelTo;
 }
 
 void SvxMSDffManager::insertShapeId( sal_Int32 nShapeId, SdrObject* pShape )
diff --git sw/source/filter/ww8/ww8graf.cxx sw/source/filter/ww8/ww8graf.cxx
index 6a70ac1..648f558 100644
--- sw/source/filter/ww8/ww8graf.cxx
+++ sw/source/filter/ww8/ww8graf.cxx
@@ -1954,11 +1954,17 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
 void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxLRSpaceItem &rLR)
 {
+    UINT32 nXRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pXRelTo )
+    {
+        nXRelTo = *(rRecord.pXRelTo);
+    }
+
     // Left adjustments - if horizontally aligned to left of
     // margin or column then remove the left wrapping
     if (rRecord.nXAlign == 1)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetLeft((USHORT)0);
     }
 
@@ -1966,18 +1972,18 @@ void SwWW8ImplReader::AdjustLRWrapForWordMargins(
     // margin or column then remove the right wrapping
     if (rRecord.nXAlign == 3)
     {
-        if ((rRecord.nXRelTo == 0) || (rRecord.nXRelTo == 2))
+        if ((nXRelTo == 0) || (nXRelTo == 2))
             rLR.SetRight((USHORT)0);
     }
 
     //Inside margin, remove left wrapping
-    if ((rRecord.nXAlign == 4) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((USHORT)0);
     }
 
     //Outside margin, remove left wrapping
-    if ((rRecord.nXAlign == 5) && (rRecord.nXRelTo == 0))
+    if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((USHORT)0);
     }
@@ -1987,11 +1993,17 @@ void SwWW8ImplReader::AdjustLRWrapForWordMargins(
 void SwWW8ImplReader::AdjustULWrapForWordMargins(
     const SvxMSDffImportRec &rRecord, SvxULSpaceItem &rUL)
 {
+    UINT32 nYRelTo = SvxMSDffImportRec::RELTO_DEFAULT;
+    if ( rRecord.pYRelTo )
+    {
+        nYRelTo = *(rRecord.pYRelTo);
+    }
+
     // Top adjustment - remove upper wrapping if aligned to page
     // printable area or to page
     if (rRecord.nYAlign == 1)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetUpper((USHORT)0);
     }
 
@@ -1999,12 +2011,12 @@ void SwWW8ImplReader::AdjustULWrapForWordMargins(
     // printable area or to page
     if (rRecord.nYAlign == 3)
     {
-        if ((rRecord.nYRelTo == 0) || (rRecord.nYRelTo == 1))
+        if ((nYRelTo == 0) || (nYRelTo == 1))
             rUL.SetLower((USHORT)0);
     }
 
     //Remove top margin if aligned vertically inside margin
-    if ((rRecord.nYAlign == 4) && (rRecord.nYRelTo == 0))
+    if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((USHORT)0);
 
     /*
@@ -2247,10 +2259,16 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
 
     SvxMSDffImportRec aRecordFromFSPA;
     if (!pRecord)
-    {
         pRecord = &aRecordFromFSPA;
-        pRecord->nXRelTo = pFSPA->nbx;
-        pRecord->nYRelTo = pFSPA->nby;
+    if (!(pRecord->pXRelTo) && pFSPA)
+    {
+        pRecord->pXRelTo = new UINT32;
+    *(pRecord->pXRelTo) = pFSPA->nbx;
+    }
+    if (!(pRecord->pYRelTo) && pFSPA)
+    {
+        pRecord->pYRelTo = new UINT32;
+    *(pRecord->pYRelTo) = pFSPA->nby;
     }
 
     // nXAlign - abs. Position, Left,  Centered,  Right,  Inside, Outside
@@ -2279,19 +2297,19 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
         // is a hint that these values aren't set by the escher import - see
         // method <SwMSDffManager::ProcessObj(..)>. Then, check if for each
         // values, if it differs from the one in the FSPA.
-        if ( pRecord->nXRelTo == 2 && pRecord->nYRelTo == 2 )
+        if ( *(pRecord->pXRelTo) == 2 && *(pRecord->pYRelTo) == 2 )
         {
             // if <nYRelTo> differs from <FSPA.nby> overwrite <nYRelTo>
-            if ( pFSPA->nby != pRecord->nYRelTo )
+            if ( pFSPA->nby != *(pRecord->pYRelTo) )
             {
-                pRecord->nYRelTo = pFSPA->nby;
+                *(pRecord->pYRelTo) = pFSPA->nby;
             }
         }
         // <--
     }
 
-    UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
-    UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
+    UINT32 nXRelTo = nCntRelTo > *(pRecord->pXRelTo) ? *(pRecord->pXRelTo) : 1;
+    UINT32 nYRelTo = nCntRelTo > *(pRecord->pYRelTo) ? *(pRecord->pYRelTo) : 1;
 
     // --> OD 2005-03-03 #i43718#
     RndStdIds eAnchor = IsInlineEscherHack() ? FLY_AS_CHAR : FLY_AT_CHAR;
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index a5292dd..74810c3 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -317,9 +317,19 @@ SdrObject* SwMSDffManager::ProcessObj(SvStream& rSt,
                 switch( nPID )
                 {
                     case 0x038F: pImpRec->nXAlign = nUDData; break;
-                    case 0x0390: pImpRec->nXRelTo = nUDData; break;
+                    case 0x0390:
+                        if (pImpRec->pXRelTo)
+                            delete pImpRec->pXRelTo;
+                        pImpRec->pXRelTo = new UINT32;
+                        *(pImpRec->pXRelTo) = nUDData;
+                        break;
                     case 0x0391: pImpRec->nYAlign = nUDData; break;
-                    case 0x0392: pImpRec->nYRelTo = nUDData; break;
+                    case 0x0392:
+                        if (pImpRec->pYRelTo)
+                            delete pImpRec->pYRelTo;
+                        pImpRec->pYRelTo = new UINT32;
+                        *(pImpRec->pYRelTo) = nUDData;
+                        break;
                     case 0x03BF: pImpRec->nLayoutInTableCell = nUDData; break;
                 }
                 if ( rSt.GetError() != 0 )
-- 
1.7.0.1

