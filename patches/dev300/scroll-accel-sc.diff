From af18db394d403aa3a1630780f674b82fe3a31a9c Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:57:16 +0200
Subject: [PATCH 253/878] scroll-accel-sc.diff

---
 sc/source/ui/inc/select.hxx  |    3 +
 sc/source/ui/view/select.cxx |  102 ++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 101 insertions(+), 4 deletions(-)

diff --git a/sc/source/ui/inc/select.hxx b/sc/source/ui/inc/select.hxx
index fe49153..2b8e0f6 100644
--- a/sc/source/ui/inc/select.hxx
+++ b/sc/source/ui/inc/select.hxx
@@ -65,6 +65,9 @@ private:
 
     ScSplitPos		GetWhich();
 
+    ULONG           CalcUpdateInterval( const Size& rWinSize, const Point& rEffPos,
+                                        bool bLeftScroll, bool bTopScroll, bool bRightScroll, bool bBottomScroll );
+
 public:
                     ScViewFunctionSet( ScViewData* pNewViewData );
 
diff --git a/sc/source/ui/view/select.cxx b/sc/source/ui/view/select.cxx
index 41ca42c..dc458e7 100644
--- a/sc/source/ui/view/select.cxx
+++ b/sc/source/ui/view/select.cxx
@@ -34,6 +34,7 @@
 
 #include <tools/urlobj.hxx>
 #include <vcl/sound.hxx>
+#include <vcl/svapp.hxx>
 #include <sfx2/docfile.hxx>
 
 #include "select.hxx"
@@ -46,6 +47,8 @@
 #include "docsh.hxx"
 #include "tabprotection.hxx"
 
+#define SC_SELENG_REFMODE_UPDATE_INTERVAL_MIN 65
+
 extern USHORT nScFillModeMouseModifier;				// global.cxx
 
 using namespace com::sun::star;
@@ -78,6 +81,83 @@ ScSplitPos ScViewFunctionSet::GetWhich()
         return pViewData->GetActivePart();
 }
 
+ULONG ScViewFunctionSet::CalcUpdateInterval( const Size& rWinSize, const Point& rEffPos,
+                                             bool bLeftScroll, bool bTopScroll, bool bRightScroll, bool bBottomScroll )
+{
+    ULONG nUpdateInterval = SELENG_AUTOREPEAT_INTERVAL_MAX;
+    Window* pWin = pEngine->GetWindow();
+    Rectangle aScrRect = pWin->GetDesktopRectPixel();
+    Point aRootPos = pWin->OutputToAbsoluteScreenPixel(Point(0,0));
+    if (bRightScroll)
+    {
+        double nWinRight = rWinSize.getWidth() + aRootPos.getX();
+        double nMarginRight = aScrRect.GetWidth() - nWinRight;
+        double nHOffset = rEffPos.X() - rWinSize.Width();
+        double nHAccelRate = nHOffset / nMarginRight;
+
+        if (nHAccelRate > 1.0)
+            nHAccelRate = 1.0;
+
+        nUpdateInterval = static_cast<ULONG>(SELENG_AUTOREPEAT_INTERVAL_MAX*(1.0 - nHAccelRate));
+    }
+
+    if (bLeftScroll)
+    {
+        double nMarginLeft = aRootPos.getX();
+        double nHOffset = -rEffPos.X();
+        double nHAccelRate = nHOffset / nMarginLeft;
+
+        if (nHAccelRate > 1.0)
+            nHAccelRate = 1.0;
+
+        ULONG nTmp = static_cast<ULONG>(SELENG_AUTOREPEAT_INTERVAL_MAX*(1.0 - nHAccelRate));
+        if (nUpdateInterval > nTmp)
+            nUpdateInterval = nTmp;
+    }
+
+    if (bBottomScroll)
+    {
+        double nWinBottom = rWinSize.getHeight() + aRootPos.getY();
+        double nMarginBottom = aScrRect.GetHeight() - nWinBottom;
+        double nVOffset = rEffPos.Y() - rWinSize.Height();
+        double nVAccelRate = nVOffset / nMarginBottom;
+
+        if (nVAccelRate > 1.0)
+            nVAccelRate = 1.0;
+
+        ULONG nTmp = static_cast<ULONG>(SELENG_AUTOREPEAT_INTERVAL_MAX*(1.0 - nVAccelRate));
+        if (nUpdateInterval > nTmp)
+            nUpdateInterval = nTmp;
+    }
+
+    if (bTopScroll)
+    {
+        double nMarginTop = aRootPos.getY();
+        double nVOffset = -rEffPos.Y();
+        double nVAccelRate = nVOffset / nMarginTop;
+
+        if (nVAccelRate > 1.0)
+            nVAccelRate = 1.0;
+
+        ULONG nTmp = static_cast<ULONG>(SELENG_AUTOREPEAT_INTERVAL_MAX*(1.0 - nVAccelRate));
+        if (nUpdateInterval > nTmp)
+            nUpdateInterval = nTmp;
+    }
+
+#ifdef WNT
+    ScTabViewShell* pViewShell = pViewData->GetViewShell();
+    bool bRefMode = pViewShell && pViewShell->IsRefInputMode();
+    if (bRefMode && nUpdateInterval < SC_SELENG_REFMODE_UPDATE_INTERVAL_MIN)
+        // Lower the update interval during ref mode, because re-draw can be
+        // expensive on Windows.  Making this interval too small would queue up
+        // the scroll/paint requests which would cause semi-infinite
+        // scrolls even after the mouse cursor is released.  We don't have
+        // this problem on Linux.
+        nUpdateInterval = SC_SELENG_REFMODE_UPDATE_INTERVAL_MIN;
+#endif
+    return nUpdateInterval;
+}
+
 void ScViewFunctionSet::SetSelectionEngine( ScViewSelectionEngine* pSelEngine )
 {
     pEngine = pSelEngine;
@@ -256,10 +336,11 @@ BOOL __EXPORT ScViewFunctionSet::SetCursorAtPoint( const Point& rPointPixel, BOO
     //	Scrolling
 
     Size aWinSize = pEngine->GetWindow()->GetOutputSizePixel();
-    BOOL bRightScroll  = ( aEffPos.X() >= aWinSize.Width() );
-    BOOL bBottomScroll = ( aEffPos.Y() >= aWinSize.Height() );
-    BOOL bNegScroll    = ( aEffPos.X() < 0 || aEffPos.Y() < 0 );
-    BOOL bScroll = bRightScroll || bBottomScroll || bNegScroll;
+    bool bRightScroll  = ( aEffPos.X() >= aWinSize.Width() );
+    bool bLeftScroll  = ( aEffPos.X() < 0 );
+    bool bBottomScroll = ( aEffPos.Y() >= aWinSize.Height() );
+    bool bTopScroll = ( aEffPos.Y() < 0 );
+    bool bScroll = bRightScroll || bBottomScroll || bLeftScroll || bTopScroll;
 
     SCsCOL	nPosX;
     SCsROW	nPosY;
@@ -312,6 +393,19 @@ BOOL __EXPORT ScViewFunctionSet::SetCursorAtPoint( const Point& rPointPixel, BOO
             }
     }
 
+    if (bScroll)
+    {
+        // Adjust update interval based on how far the mouse pointer is from the edge.
+        ULONG nUpdateInterval = CalcUpdateInterval(
+            aWinSize, aEffPos, bLeftScroll, bTopScroll, bRightScroll, bBottomScroll);
+        pEngine->SetUpdateInterval(nUpdateInterval);
+    }
+    else
+    {
+        // Don't forget to reset the interval when not scrolling!
+        pEngine->SetUpdateInterval(SELENG_AUTOREPEAT_INTERVAL);
+    }
+
     pViewData->ResetOldCursor();
     return SetCursorAtCell( nPosX, nPosY, bScroll );
 }
-- 
1.7.0.1

