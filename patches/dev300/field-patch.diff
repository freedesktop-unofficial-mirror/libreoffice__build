diff --git offapi/com/sun/star/text/XFormField.idl offapi/com/sun/star/text/XFormField.idl
index 3ef65fa..755fafa 100644
--- offapi/com/sun/star/text/XFormField.idl
+++ offapi/com/sun/star/text/XFormField.idl
@@ -9,14 +9,13 @@
  
  interface XFormField: com::sun::star::uno::XInterface
  {
- 	short getType();
- 	short getRes();
- 	string getDescription( ); 	
- 
- 	void setType([in] short fieldType );
- 	void setRes([in] short res );
- 	void setDescription([in] string description );
- 
+     string getFieldType();
+     void setFieldType([in] string fieldType);     
+
+     short getParamCount();
+     string getParamName([in] short i);
+     string getParamValue([in] short i);
+     void addParam([in] string name, [in] string value, [in] boolean replaceExisting);
  };
  
  }; }; }; }; 
diff --git svtools/source/config/fltrcfg.cxx svtools/source/config/fltrcfg.cxx
index be0c379..243eea1 100644
--- svtools/source/config/fltrcfg.cxx
+++ svtools/source/config/fltrcfg.cxx
@@ -312,7 +312,7 @@ const Sequence<OUString>& SvtFilterOptions::GetPropertyNames()
 			"Export/EnablePowerPointPreview",	//	8
 			"Export/EnableExcelPreview",		//	9
 			"Export/EnableWordPreview",			// 10
-            "Import/ImportWWFieldsAsEnhancedFields" // 11
+			"Import/ImportWWFieldsAsEnhancedFields" // 11
 		};
 		OUString* pNames = aNames.getArray();
 		for(int i = 0; i < nCount; i++)
@@ -525,8 +525,7 @@ void SvtFilterOptions::SetWriter2WinWord( BOOL bFlag )
 
 BOOL SvtFilterOptions::IsUseEnhancedFields() const
 {
-    return false; // disable for now;
-//	return pImp->IsFlag( FILTERCFG_USE_ENHANCED_FIELDS );
+    return pImp->IsFlag( FILTERCFG_USE_ENHANCED_FIELDS );
 }
 
 void SvtFilterOptions::SetUseEnhancedFields( BOOL bFlag )
diff --git sw/inc/bookmrk.hxx sw/inc/bookmrk.hxx
index 6f1c5ae..89499c2 100644
--- sw/inc/bookmrk.hxx
+++ sw/inc/bookmrk.hxx
@@ -54,6 +54,7 @@ struct SwPosition;	// fwd Decl. wg. UI
 
 class SwBookmark : public SwModify
 {
+    friend class SwDoc;
 	SwPosition *pPos1, *pPos2;	// wird im CTOR gesetzt, im DTOR geloescht
                                 // pPos1 is always != 0, pPos2 may be 0
 	SwServerObjectRef refObj;	// falls DataServer -> Pointer gesetzt
@@ -81,6 +82,9 @@ public:
 	// Beim Loeschen von Text werden Bookmarks mitgeloescht!
 	virtual ~SwBookmark();
 
+	const SwPosition& GetPos() const { return *pPos1; }
+	const SwPosition* GetOtherPos() const { return pPos2; }
+
     // --> OD 2007-10-10 #i81002#
     // made virtual and thus no longer inline
     virtual const SwPosition& GetBookmarkPos() const;
@@ -101,6 +105,8 @@ public:
 	BOOL IsEqualPos( const SwBookmark &rBM ) const;
 
 	BOOL IsFormFieldMark() const 	{ return IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT == eMarkType || IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT == eMarkType; }
+    BOOL IsTabbedFormFieldMark() const;
+
     BOOL IsBookMark() const 	{ return IDocumentBookmarkAccess::BOOKMARK == eMarkType || IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT == eMarkType || IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT == eMarkType; }
 //    // --> OD 2007-10-17 #TESTING#
 //    BOOL IsBookMark() const
@@ -153,55 +159,37 @@ public:
             
 class SW_DLLPUBLIC SwFieldBookmark : public SwBookmark
 {
+public:
+    typedef  std::pair< ::rtl::OUString, ::rtl::OUString > ParamPair_t;
 private:
-	int fftype; // Type: 0 = Text, 1 = Check Box, 2 = List
-	int ffres;
-    bool ffprot;
-	bool ffsize; // 0 = Auto, 1=Exact (see ffhps)
-	int fftypetxt; // Type of text field: 0 = Regular text, 1 = Number, 2 = Date, 3 = Current date, 4 = Current time, 5 = Calculation
-	bool ffrecalc; 
-	int ffmaxlen; // Number of characters for text field. Zero means unlimited.
-	int ffhps; // Check box size (half-point sizes).
-
-	String ffname;
-	String ffhelptext;
+    ::rtl::OUString m_type;
+    std::vector<ParamPair_t> m_params;
 
 public:
     SwFieldBookmark(const SwPosition& aPos,
 	       const KeyCode& rCode,
 	       const String& rName, const String& rShortName,
-		   IDocumentBookmarkAccess::BookmarkType eMark);
-
-	void SetFieldType(int fftype);
-	int GetFieldType();
-
-	void SetChecked(bool checked);
-	bool IsChecked();
-
-	void SetFFName(String aNewName) {
-		this->ffname=aNewName;
-	}
-
-	String GetFFName()
-	{
-		return ffname;
-	}
-
-	int GetFFRes() {
-		return ffres;
-	}
-
-	void SetFFRes(int nNew) {
-		this->ffres=nNew;
-	}
-
-	void SetFFHelpText(String newffhelptext) {
-		this->ffhelptext=newffhelptext;
-	}
-
-	String GetFFHelpText() {
-		return ffhelptext;
-	}
+		    IDocumentBookmarkAccess::BookmarkType eMark);
+
+    virtual ~SwFieldBookmark();
+    
+    void setTypeName(const ::rtl::OUString &typeName);
+    void invalidate();
+    SwPosition getSelectionStart();
+    SwPosition getSelectionEnd();
+
+    // field specific stuff
+    bool isTabbed() const;
+
+    // generic methods
+    bool isType(const char *type) const;
+    rtl::OUString getTypeName();
+    void addParam(::rtl::OUString paramName, ::rtl::OUString paramValue, bool replaceExisting=true);
+    void addParam(const char* paramName, int value);
+    int getNumOfParams();
+    ParamPair_t getParam(int pos);
+    ParamPair_t getParam(const char *name, const char *defaultValue=NULL);
+    void addParams(std::vector<ParamPair_t> &params);
 };
             
 class SwUNOMark: public SwBookmark
diff --git sw/inc/crsrsh.hxx sw/inc/crsrsh.hxx
index 5711e92..6455596 100644
--- sw/inc/crsrsh.hxx
+++ sw/inc/crsrsh.hxx
@@ -112,7 +112,8 @@ struct SwContentAtPos
         SW_REFMARK          = 0x0100,
         SW_NUMLABEL         = 0x0200, // #i23726#
         SW_CONTENT_CHECK    = 0x0400, // --> FME 2005-05-13 #i43742# <--
-        SW_SMARTTAG         = 0x0800
+        SW_SMARTTAG         = 0x0800,
+	SW_FORMCTRL         = 0x1000
 #ifndef PRODUCT
 		,SW_CURR_ATTRS 		= 0x4000		// nur zum Debuggen
 		,SW_TABLEBOXVALUE	= 0x8000		// nur zum Debuggen
@@ -124,6 +125,7 @@ struct SwContentAtPos
 		const SfxPoolItem* pAttr;
 		const SwRedline* pRedl;
         SwCntntNode * pNode; // #i23726#
+	        const SwFieldBookmark* pFldBookmark;
 	} aFnd;
 
     int nDist; // #i23726#
diff --git sw/inc/doc.hxx sw/inc/doc.hxx
index f8cd224..25de567 100644
--- sw/inc/doc.hxx
+++ sw/inc/doc.hxx
@@ -786,6 +786,14 @@ public:
     virtual void makeUniqueBookmarkName( /*[in/out]*/String& rName );
     virtual sal_uInt16 getBookmarkCount( /*[in]*/ bool bBkmrk ) const;
     virtual SwBookmark& getBookmark( /*[in]*/sal_uInt16 nPos, /*[in]*/bool bBkmrk );
+
+    SwFieldBookmark *makeFieldBookmark(/*[in]*/const SwPaM& rPaM, 
+				       /*[in]*/ const String& rName, 
+				       /*[in]*/ const rtl::OUString &rType);
+    SwFieldBookmark *makeNoTextFieldBookmark(/*[in]*/const SwPaM& rPaM, 
+					     /*[in]*/ const String& rName, 
+					     /*[in]*/ const rtl::OUString &rType);
+
     virtual String getCrossRefBookmarkName(
             /*[in]*/const SwTxtNode& rTxtNode,
             /*[in]*/const CrossReferenceBookmarkSubType nCrossRefType ) const;
diff --git sw/inc/ecmaflds.hxx sw/inc/ecmaflds.hxx
new file mode 100644
index 0000000..23276b1
--- /dev/null
+++ sw/inc/ecmaflds.hxx
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: $
+ * $Revision: $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+/* and also:
+ * Author: Florian Reuter <freuter@novell.com>
+ * Copyright 2008 by Novell, Inc.
+*/
+#ifndef _ECMAFLDS_HXX
+#define _ECMAFLDS_HXX
+
+
+#define ECMA_FORMTEXT "ecma.office-open-xml.field.FORMTEXT"
+#define ECMA_FORMTEXT_NAME "name"
+#define ECMA_FORMTEXT_HELPTEXT "helpText"
+#define ECMA_FORMTEXT_STATUSTEXT "statusText"
+#define ECMA_FORMTEXT_DEFAULT "default"
+#define ECMA_FORMTEXT_FORMAT "format"
+#define ECMA_FORMTEXT_MAXLENGTH "maxLength"
+#define ECMA_FORMTEXT_TYPE "type"
+
+#define ECMA_FORMCHECKBOX "ecma.office-open-xml.field.FORMCHECKBOX"
+#define ECMA_FORMCHECKBOX_NAME "name"
+#define ECMA_FORMCHECKBOX_HELPTEXT "helpText"
+#define ECMA_FORMCHECKBOX_STATUSTEXT "statusText"
+#define ECMA_FORMCHECKBOX_CHECKED "checked"
+#define ECMA_FORMCHECKBOX_DEFAULT "default"
+#define ECMA_FORMCHECKBOX_SIZE "size"
+#define ECMA_FORMCHECKBOX_SIZEAUTO "sizeAuto"
+
+
+#define ECMA_FORMDROPDOWN "ecma.office-open-xml.field.FORMDROPDOWN"
+#define ECMA_FORMDROPDOWN_DEFAULT "default"
+#define ECMA_FORMDROPDOWN_LISTENTRY "listEntry"
+#define ECMA_FORMDROPDOWN_RESULT "result"
+
+#define ECMA_TOC "ecma.office-open-xml.field.TOC"
+
+#define ECMA_HYPERLINK "ecma.office-open-xml.field.HYPERLINK"
+
+#define ECMA_PAGEREF "ecma.office-open-xml.field.PAGEREF"
+
+#endif /*  _ECMAFLDS_HXX */
diff --git sw/inc/editsh.hxx sw/inc/editsh.hxx
index 27649d4..e292e4d 100644
--- sw/inc/editsh.hxx
+++ sw/inc/editsh.hxx
@@ -415,6 +415,9 @@ public:
 	const SwTOXType* 	GetTOXType(TOXTypes eTyp, USHORT nId) const;
 	void			 	InsertTOXType(const SwTOXType& rTyp);
 
+        // new field stuff
+        BOOL	UpdateField(SwFieldBookmark &fieldBM);
+
 	//AutoMark file
 	const String&	GetTOIAutoMarkURL() const;
 	void			SetTOIAutoMarkURL(const String& rSet);
diff --git sw/inc/hintids.hxx sw/inc/hintids.hxx
index 6834eb2..45c0675 100644
--- sw/inc/hintids.hxx
+++ sw/inc/hintids.hxx
@@ -44,12 +44,8 @@
 #define CH_TXT_ATR_FIELDEND ((sal_Unicode)0x05)
 #define CH_TXT_ATR_SUBST_FIELDSTART ("[")
 #define CH_TXT_ATR_SUBST_FIELDEND ("]")
-//#define CH_TXT_ATR_FORMELEMENT ((sal_Unicode)'#')
 #define CH_TXT_ATR_FORMELEMENT ((sal_Unicode)0x06)
-/*
-#define FIELD_BOOKMARK_PREFIX "__"
-#define FIELD_FORM_BOOKMARK_PREFIX "__FORM"
-*/
+
 /*
  * Hier kommen erst mal die enums fuer die Hints
  */
diff --git sw/inc/pam.hxx sw/inc/pam.hxx
index 1aee1ac..bce0297 100644
--- sw/inc/pam.hxx
+++ sw/inc/pam.hxx
@@ -262,6 +262,7 @@ public:
 	DECL_FIXEDMEMPOOL_NEWDEL(SwPaM);
 
     String GetTxt() const;
+    void Invalidate();
 };
 
 
diff --git sw/inc/unoobj.hxx sw/inc/unoobj.hxx
index ed924c1..5c8829d 100644
--- sw/inc/unoobj.hxx
+++ sw/inc/unoobj.hxx
@@ -648,6 +648,7 @@ public:
 	SwXFieldmark(bool isReplacementObject, SwBookmark* pBkm = 0, SwDoc* pDoc = 0);
 
 	virtual void attachToRange(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & xTextRange)throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+/*
 	virtual ::rtl::OUString SAL_CALL getDescription(void)  throw( ::com::sun::star::uno::RuntimeException );
     virtual ::sal_Int16 SAL_CALL getType(  ) throw (::com::sun::star::uno::RuntimeException);
     virtual ::sal_Int16 SAL_CALL getRes(  ) throw (::com::sun::star::uno::RuntimeException);
@@ -655,7 +656,15 @@ public:
     virtual void SAL_CALL setType( ::sal_Int16 fieldType ) throw (::com::sun::star::uno::RuntimeException);
     virtual void SAL_CALL setRes( ::sal_Int16 res ) throw (::com::sun::star::uno::RuntimeException);
     virtual void SAL_CALL setDescription( const ::rtl::OUString& description ) throw (::com::sun::star::uno::RuntimeException);
+*/
 
+    virtual ::rtl::OUString SAL_CALL getFieldType(void)  throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL setFieldType( const ::rtl::OUString& description ) throw (::com::sun::star::uno::RuntimeException);
+    
+    virtual ::sal_Int16 SAL_CALL getParamCount(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getParamName(::sal_Int16 i)  throw( ::com::sun::star::uno::RuntimeException );
+    virtual ::rtl::OUString SAL_CALL getParamValue(::sal_Int16 i)  throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL addParam( const ::rtl::OUString& name, const ::rtl::OUString& value, ::sal_Bool replaceExisting ) throw (::com::sun::star::uno::RuntimeException);
 //    virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( ::com::sun::star::uno::Type const & rType ) throw (::com::sun::star::uno::RuntimeException);
 
 };
diff --git sw/source/core/crsr/crstrvl.cxx sw/source/core/crsr/crstrvl.cxx
index 0429ba3..a5618e7 100644
--- sw/source/core/crsr/crstrvl.cxx
+++ sw/source/core/crsr/crstrvl.cxx
@@ -1175,6 +1175,16 @@ BOOL SwCrsrShell::GetContentAtPos( const Point& rPt,
 					}
 				}
 
+		if( !bRet && SwContentAtPos::SW_FORMCTRL & rCntntAtPos.eCntntAtPos )
+		{
+		    SwFieldBookmark* pFldBookmark=GetDoc()->getFormFieldBookmarkFor( aPos) ;
+		    if( bCrsrFoundExact && pTxtNd && pFldBookmark) {
+			rCntntAtPos.eCntntAtPos = SwContentAtPos::SW_FORMCTRL;
+			rCntntAtPos.aFnd.pFldBookmark = pFldBookmark;
+			bRet=TRUE;
+		    }
+		}
+
 				if( !bRet && SwContentAtPos::SW_FTN & rCntntAtPos.eCntntAtPos )
 				{
 					if( aTmpState.bFtnNoInfo )
diff --git sw/source/core/crsr/pam.cxx sw/source/core/crsr/pam.cxx
index 15cf4d9..7d67f22 100644
--- sw/source/core/crsr/pam.cxx
+++ sw/source/core/crsr/pam.cxx
@@ -56,6 +56,7 @@
 #include <ndtxt.hxx> // #111827#
 
 #include <bookmrk.hxx>
+#include <hints.hxx>
 
 // fuer den dummen ?MSC-? Compiler
 inline xub_StrLen GetSttOrEnd( BOOL bCondition, const SwCntntNode& rNd )
@@ -768,16 +769,29 @@ BOOL SwPaM::HasReadonlySel( bool bFormView ) const
 		}
 	}
 // TODO: Form Protection when Enhanced Fields are enabled
-//	if( !bRet )
-//    {
-//	    const SwDoc *pDoc=GetDoc();
-//	    SwBookmark *pA = ( pDoc && pPoint ? pDoc->getFieldBookmarkFor( *pPoint ) : NULL );
-//	    SwBookmark *pB = ( pDoc && pMark ? pDoc->getFieldBookmarkFor( *pMark ) : pA );
-//	    bRet = ( pA != pB );
-//	    bool bProtectForm = pDoc->get( IDocumentSettingAccess::PROTECT_FORM );
-//	    if( bProtectForm )
-//            bRet |= ( pA==NULL || pB==NULL );
-//	}
+	if (!bRet) {
+	    const SwDoc *pDoc=GetDoc();
+	    SwBookmark *pA=(pDoc&&pPoint?pDoc->getFieldBookmarkFor(*pPoint):NULL);
+	    /* debugging stuff, will remove later
+	    if (pA) {
+		rtl::OUString s(pA->GetName());
+		rtl::OString aOString = ::rtl::OUStringToOString (s, RTL_TEXTENCODING_UTF8);
+		printf("IN BOOKMARK(A): %s\n", aOString.getStr());
+	    }
+	    */
+	    SwBookmark *pB=(pDoc&&pMark?pDoc->getFieldBookmarkFor(*pMark):pA);
+            /* debugging stuff, will remove later
+	    if (pB) {
+		rtl::OUString s(pB->GetName());
+		rtl::OString aOString = ::rtl::OUStringToOString (s, RTL_TEXTENCODING_UTF8);
+		printf("IN BOOKMARK(B): %s\n", aOString.getStr());
+	    }
+	    */
+	    bRet = (pA!=pB);
+	    bool bProtectForm=pDoc->get(IDocumentSettingAccess::PROTECT_FORM );
+	    if (bProtectForm)
+		bRet|=(pA==NULL || pB==NULL);
+	}
 	return bRet;
 }
 
@@ -1155,6 +1169,18 @@ BOOL SwPaM::Overlap(const SwPaM & a, const SwPaM & b)
     return !(*b.End() <= *a.Start() || *a.End() <= *b.End());
 }
 
+void SwPaM::Invalidate()
+{
+    const SwNode *_pNd=this->GetNode();
+    const SwTxtNode *_pTxtNd=(_pNd!=NULL?_pNd->GetTxtNode():NULL);
+    if (_pTxtNd!=NULL) {
+	//pretent we've added a char to force layout to recalc the portion...
+	SwInsChr aHint(_pTxtNd->GetIndex());
+	SwModify *_pModify=(SwModify*)_pTxtNd;
+	_pModify->Modify( 0, &aHint);
+    }
+}
+
 BOOL SwPaM::LessThan(const SwPaM & a, const SwPaM & b)
 {
     return (*a.Start() < *b.Start()) || (*a.Start() == *b.Start() && *a.End() < *b.End()); 
diff --git sw/source/core/doc/docbm.cxx sw/source/core/doc/docbm.cxx
index 59dd2a6..4545785 100644
--- sw/source/core/doc/docbm.cxx
+++ sw/source/core/doc/docbm.cxx
@@ -63,6 +63,7 @@
 // --> OD 2007-10-23 #i81002#
 #include <ndtxt.hxx>
 // <--
+#include "ecmaflds.hxx"
 
 SV_IMPL_OP_PTRARR_SORT(SwBookmarks, SwBookmarkPtr)
 
@@ -88,6 +89,23 @@ SV_IMPL_OP_PTRARR_SORT(SwBookmarks, SwBookmarkPtr)
         } while((_pStartShell=(ViewShell*)_pStartShell->GetNext())!= pEShell ); \
 	}
 
+static void lcl_docbm_FixPosition( SwPosition& rPos )
+{
+    // make sure the position has 1) the proper node, and 2) a proper index
+    SwTxtNode* pTxtNode = rPos.nNode.GetNode().GetTxtNode();
+
+    if( rPos.nContent.GetIndex() > ( pTxtNode == NULL ? 0 : pTxtNode->Len() ) )
+    {
+        DBG_ERROR( "illegal position" );
+        xub_StrLen nLen = rPos.nContent.GetIndex();
+        if( pTxtNode == NULL )
+            nLen = 0;
+        else if( nLen >= pTxtNode->Len() )
+            nLen = pTxtNode->Len();
+        rPos.nContent.Assign( pTxtNode, nLen );
+    }
+}
+
 
 /** IDocumentBookmarkAccess ssc
 */
@@ -96,28 +114,27 @@ const SwBookmarks& SwDoc::getBookmarks() const
     return *pBookmarkTbl;
 }
 
+
 SwBookmark* SwDoc::makeBookmark( /*[in]*/const SwPaM& rPaM, /*[in]*/const KeyCode& rCode,
                                  /*[in]*/ const String& rName, /*[in]*/const String& rShortName,
                                  /*[in]*/IDocumentBookmarkAccess::BookmarkType eMark )
 {
     SwBookmark *pBM( 0 );
-    if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark /* rName.CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */)
-    {
-        pBM = new SwFieldBookmark(*rPaM.GetPoint(), rCode, rName, rShortName, eMark);
-        if( rPaM.HasMark() )
-            pBM->SetOtherBookmarkPos( rPaM.GetMark() );
-        else
-            pBM->SetOtherBookmarkPos( &pBM->GetBookmarkPos() );
-
-        // TODO: lcl_FixPosition( *pBM->pPos1 ); 
-        // TODO: lcl_FixPosition( *pBM->pPos2 );
-        if( *pBM->GetOtherBookmarkPos() < pBM->GetBookmarkPos() )
-        {
-            SwPosition _pos( pBM->GetBookmarkPos() );
-            pBM->SetBookmarkPos( pBM->GetOtherBookmarkPos() );
-            pBM->SetOtherBookmarkPos( &_pos );
-        }
-        //ASSERT(*pBM->pPos1<=*pBM->pPos2, "");
+    if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark) {
+	pBM = new SwFieldBookmark(*rPaM.GetPoint(), rCode, rName, rShortName, eMark);
+	if( rPaM.HasMark() )
+	    pBM->pPos2 = new SwPosition( *rPaM.GetMark() );
+	else
+	    pBM->pPos2 = new SwPosition( *pBM->pPos1 );
+	
+	lcl_docbm_FixPosition( *pBM->pPos1 );
+	lcl_docbm_FixPosition( *pBM->pPos2 );
+	if (*pBM->pPos2<*pBM->pPos1) {
+	    SwPosition *_pos=pBM->pPos1;
+	    pBM->pPos1=pBM->pPos2;
+	    pBM->pPos2=_pos;
+	}
+	ASSERT(*PBM->pPos1<=*pBM->pPos2, "");
     }
     else if( MARK == eMark )
     {
@@ -146,7 +163,7 @@ SwBookmark* SwDoc::makeBookmark( /*[in]*/const SwPaM& rPaM, /*[in]*/const KeyCod
 //    }
 //    // <--
     else if( BOOKMARK == eMark || DDE_BOOKMARK == eMark)
-    {
+	{
         // --> OD 2007-09-26 #i81002#
         pBM = new SwBookmark( rPaM, rCode, rName, rShortName);
         if ( eMark == DDE_BOOKMARK )
@@ -154,7 +171,7 @@ SwBookmark* SwDoc::makeBookmark( /*[in]*/const SwPaM& rPaM, /*[in]*/const KeyCod
             pBM->SetType( eMark );
         }
         // <--
-    }
+	}
     // --> OD 2007-10-17 #i81002#
     else if ( eMark == CROSSREF_BOOKMARK )
     {
@@ -176,53 +193,56 @@ SwBookmark* SwDoc::makeBookmark( /*[in]*/const SwPaM& rPaM, /*[in]*/const KeyCod
                     "<SwDoc::makeBookmark(..)> - creation of cross-reference bookmark with invalid PaM" );
         }
     }
-    else
-    {
+    // <--
+	else
+	{
         // --> OD 2007-09-26 #i81002#
         pBM = new SwUNOMark( rPaM, rCode, rName, rShortName);
         // <--
-    }
+	}
 
     // --> OD 2007-10-18 #i81002#
     if ( pBM )
     {
-        if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */) 
-        {
-            StartUndo(UNDO_UI_REPLACE, NULL);
-            //ASSERT(*PBM->pPos1<=*pBM->pPos2, "Bookmark positions not normalized!!!!");
-            const SwTxtNode* pStartTxtNode=this->GetNodes()[pBM->GetBookmarkPos().nNode]->GetTxtNode();
-            const SwTxtNode* pEndTxtNode=this->GetNodes()[pBM->GetOtherBookmarkPos()->nNode]->GetTxtNode();
-            sal_Unicode ch_start=pStartTxtNode->GetTxt().GetChar(pBM->GetBookmarkPos().nContent.GetIndex());
-            sal_Unicode ch_end=pEndTxtNode->GetTxt().GetChar(pBM->GetOtherBookmarkPos()->nContent.GetIndex()-1);
-            bool form=(IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT==eMark);  /*(pBM->GetName().CompareToAscii(FIELD_FORM_BOOKMARK_PREFIX, strlen(FIELD_FORM_BOOKMARK_PREFIX))==0);*/
-            if (form) 
-            {
-                if (ch_start!=CH_TXT_ATR_FORMELEMENT)
-                {
-                    const SwPaM rRg(pBM->GetBookmarkPos());
-                    Insert(rRg, CH_TXT_ATR_FORMELEMENT);
-                    SwPosition aTmp( pBM->GetBookmarkPos() );
-                    aTmp.nContent--;
-                    pBM->SetBookmarkPos( &aTmp );
-                }
-            }
-            else
-            {
-                if (ch_start!=CH_TXT_ATR_FIELDSTART)
-                {
-                    const SwPaM rRg(pBM->GetBookmarkPos());
-                    Insert(rRg, CH_TXT_ATR_FIELDSTART);
-                    SwPosition aTmp( pBM->GetBookmarkPos() );
-                    aTmp.nContent--;
-                    pBM->SetBookmarkPos( &aTmp );
-                }
-                if (ch_end!=CH_TXT_ATR_FIELDEND)
-                {
-                    const SwPaM rRg(*pBM->GetOtherBookmarkPos());
-                    Insert(rRg, CH_TXT_ATR_FIELDEND);
-                }
-            }
-        } 
+ 	if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark ) {
+ 	    StartUndo(UNDO_UI_REPLACE, NULL);
+ 	    ASSERT(*PBM->pPos1<=*pBM->pPos2, "Bookmark positions not normalized!!!!");
+ 	    const SwTxtNode* pStartTxtNode=this->GetNodes()[pBM->GetPos().nNode]->GetTxtNode();
+ 	    const SwTxtNode* pEndTxtNode=this->GetNodes()[pBM->GetOtherPos()->nNode]->GetTxtNode();
+ 	    xub_StrLen ch_start_pos=pBM->GetPos().nContent.GetIndex();
+ 	    xub_StrLen ch_end_pos=pBM->GetOtherPos()->nContent.GetIndex();
+ 	    if (ch_end_pos==0 || ch_end_pos<=ch_start_pos) {
+ 		ch_end_pos=ch_start_pos;
+ 	    } else {
+ 		ch_end_pos--;
+ 	    }
+ 	    sal_Unicode ch_start=pStartTxtNode->GetTxt().GetChar(ch_start_pos);
+ 	    sal_Unicode ch_end=pEndTxtNode->GetTxt().GetChar(ch_end_pos);
+ 	    bool form=(IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT==eMark);
+ 	    if (form) {
+ 		if (1 || ch_start!=CH_TXT_ATR_FORMELEMENT) {
+		    const SwPaM rRg(*pBM->pPos1);
+ 		    Insert(rRg, CH_TXT_ATR_FORMELEMENT);
+ 		    pBM->pPos1->nContent--;
+ 		}
+ 	    } else {
+ 		if (1 || ch_start!=CH_TXT_ATR_FIELDSTART) {
+		    const SwPaM rRg(*pBM->pPos1);
+ 		    Insert(rRg, CH_TXT_ATR_FIELDSTART);
+ 		    pBM->pPos1->nContent--;
+ 		}
+ 		if (1 ||  ch_end!=CH_TXT_ATR_FIELDEND) {
+		    const SwPaM rRg(*pBM->pPos2);
+ 		    Insert(rRg, CH_TXT_ATR_FIELDEND);
+ 		}
+ 	    }
+ 	} else {
+ 	    // fix bookmark positions if they are invalid
+ 	    lcl_docbm_FixPosition( *pBM->pPos1 );
+ 	    if( pBM->pPos2 != NULL )
+ 		lcl_docbm_FixPosition( *pBM->pPos2 );
+ 	}
+	
         if ( !pBookmarkTbl->Insert( pBM ) )
             delete pBM, pBM = 0;
         else
@@ -241,12 +261,38 @@ SwBookmark* SwDoc::makeBookmark( /*[in]*/const SwPaM& rPaM, /*[in]*/const KeyCod
                     SetModified();
             }
         }
-        if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0*/)
-            EndUndo(UNDO_UI_REPLACE, NULL);
+	if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark ) {
+	    EndUndo(UNDO_UI_REPLACE, NULL);
+	}
     }
     return pBM;
 }
 
+
+SwFieldBookmark *SwDoc::makeFieldBookmark(/*[in]*/const SwPaM& rPaM, 
+				       /*[in]*/ const String& rName, 
+				       /*[in]*/ const rtl::OUString &rType)
+{
+    SwFieldBookmark *pFieldmark=(SwFieldBookmark*)makeBookmark(rPaM, KeyCode(), rName, String(), IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT);    
+    pFieldmark->setTypeName(rType);
+    if (1) {
+	rtl::OString aName8 = ::rtl::OUStringToOString (rName, RTL_TEXTENCODING_UTF8);
+	rtl::OString aType8 = ::rtl::OUStringToOString (rType, RTL_TEXTENCODING_UTF8);
+	/* printf("makeFieldBookmark(\"%s\", \"%s\")\n", aName8.getStr(), aType8.getStr()); */
+    }
+    return pFieldmark;
+}
+
+SwFieldBookmark *SwDoc::makeNoTextFieldBookmark(/*[in]*/const SwPaM& rPaM, 
+				       /*[in]*/ const String& rName, 
+				       /*[in]*/ const rtl::OUString &rType)
+{
+    SwFieldBookmark *pFieldmark=(SwFieldBookmark*)makeBookmark(rPaM, KeyCode(), rName, String(), IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT);    
+    pFieldmark->setTypeName(rType);
+    return pFieldmark;
+}
+
+
 SwBookmark* SwDoc::getFieldBookmarkFor(const SwPosition &pos) const
 {
     //@TODO make impl recursive
@@ -255,7 +301,7 @@ SwBookmark* SwDoc::getFieldBookmarkFor(const SwPosition &pos) const
     {
         SwBookmark *pBM=(*pBookmarkTbl)[static_cast<USHORT>(nCount)];
         if (pBM->GetOtherBookmarkPos()!=NULL 
-            && FORM_FIELDMARK_TEXT==pBM->GetType() /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */
+            && FORM_FIELDMARK_TEXT==pBM->GetType()
             && pBM->GetBookmarkPos()<pos 
             && pos < *(pBM->GetOtherBookmarkPos()))
             return pBM;
@@ -286,7 +332,7 @@ SwBookmark* SwDoc::getNextFieldBookmarkFor(const SwPosition &pos) const
     SwBookmark *pBM=NULL;
     while(i<nCount
         && ((pBM=(*pBookmarkTbl)[i])==NULL
-        || !pBM->IsFormFieldMark() /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0 */
+        || !pBM->IsTabbedFormFieldMark() 
         || pos >= pBM->GetBookmarkPos() ))
         i++;
 
@@ -296,7 +342,7 @@ SwBookmark* SwDoc::getNextFieldBookmarkFor(const SwPosition &pos) const
     {
         i=0;
         while(i<nCount
-            && ((pBM=(*pBookmarkTbl)[i])==NULL || !pBM->IsFormFieldMark() /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0*/ ))
+            && ((pBM=(*pBookmarkTbl)[i])==NULL || !pBM->IsTabbedFormFieldMark() ))
             i++;
         return (i<nCount?pBM:NULL);
     }
@@ -309,7 +355,7 @@ SwBookmark* SwDoc::getPrevFieldBookmarkFor(const SwPosition &pos) const
     SwBookmark *pBM=NULL;
     while(i>=0
         && ((pBM=(*pBookmarkTbl)[static_cast<USHORT>(i)])==NULL
-        || !pBM->IsFormFieldMark() /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0*/
+        || !pBM->IsTabbedFormFieldMark()
         || pBM->GetOtherBookmarkPos()==NULL
         || pos <= *pBM->GetOtherBookmarkPos()))
         i--;
@@ -320,7 +366,7 @@ SwBookmark* SwDoc::getPrevFieldBookmarkFor(const SwPosition &pos) const
     {
         i=nCount-1; 
         while(i>=0
-            && ((pBM=(*pBookmarkTbl)[static_cast<USHORT>(i)])==NULL ||  !pBM->IsFormFieldMark() /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0*/ ))
+            && ((pBM=(*pBookmarkTbl)[static_cast<USHORT>(i)])==NULL ||  !pBM->IsTabbedFormFieldMark() ))
             i--;
         return (i>=0?pBM:NULL);
     }
@@ -1299,45 +1345,6 @@ void _RestoreCntntIdx( SwDoc* pDoc, SvULongs& rSaveArr,
 	}
 }
 
-SwFieldBookmark::SwFieldBookmark(const SwPosition& aPos,
-		const KeyCode& rCode,
-		const String& rName, const String& rShortName,
-		IDocumentBookmarkAccess::BookmarkType eMark)
-    : SwBookmark(aPos, rCode, rName, rShortName),
-		fftype(0), // Type: 0 = Text, 1 = Check Box, 2 = List
-		ffres(0),
-		ffprot(0),
-		ffsize(0), // 0 = Auto, 1=Exact (see ffhps)
-		fftypetxt(0), // Type of text field: 0 = Regular text, 1 = Number, 2 = Date, 3 = Current date, 4 = Current time, 5 = Calculation
-		ffrecalc(0), 
-		ffmaxlen(0), // Number of characters for text field. Zero means unlimited.
-		ffhps(24) // Check box size (half-point sizes).
-{
-	eMarkType = eMark;
-}
-
-void SwFieldBookmark::SetChecked(bool checked)
-{
-	ASSERT(fftype==1, "This method is for checkboxes only...");
-	ffres=(checked?1:0);
-}
-
-bool SwFieldBookmark::IsChecked()
-{
-	ASSERT(fftype==1, "This method is for checkboxes only...");
-	return ffres!=0;
-}
-
-void SwFieldBookmark::SetFieldType(int newfftype)
-{
-	this->fftype=newfftype;
-}
-
-int SwFieldBookmark::GetFieldType()
-{
-	return fftype;
-}
-
 void _RestoreCntntIdx( SvULongs& rSaveArr, const SwNode& rNd,
 						xub_StrLen nLen, xub_StrLen nChkLen )
 {
@@ -1581,3 +1588,118 @@ namespace bookmarkfunc
     }
 }
 // <--
+
+
+
+SwFieldBookmark::SwFieldBookmark(const SwPosition& aPos,
+				 const KeyCode& rCode,
+				 const String& rName, const String& rShortName,
+				 IDocumentBookmarkAccess::BookmarkType eMark)
+    : SwBookmark(aPos, rCode, rName, rShortName)
+{
+    eMarkType = eMark;
+}
+
+SwFieldBookmark::~SwFieldBookmark()
+{
+
+}
+
+void SwFieldBookmark::invalidate() 
+{
+    SwPaM aPaM(this->GetPos(), *this->GetOtherPos());
+    aPaM.Invalidate();
+}
+
+SwPosition SwFieldBookmark::getSelectionStart() 
+{
+    SwPosition aPos=GetPos();
+    aPos.nContent++;
+    return aPos;
+}
+
+SwPosition SwFieldBookmark::getSelectionEnd()
+{
+    SwPosition aPos=*GetOtherPos();
+    aPos.nContent--;
+    return aPos;
+}
+
+
+void SwFieldBookmark::setTypeName(const ::rtl::OUString &typeName)
+{
+    m_type=typeName;
+}
+
+BOOL SwBookmark::IsTabbedFormFieldMark() const
+{
+    return IsFormFieldMark() && ((const SwFieldBookmark*)this)->isTabbed();
+}
+
+bool SwFieldBookmark::isTabbed() const
+{
+    return isType(ECMA_FORMTEXT) || isType(ECMA_FORMCHECKBOX)  || isType(ECMA_FORMDROPDOWN);
+}
+
+bool SwFieldBookmark::isType(const char *type) const
+{
+    return m_type.compareToAscii(type)==0;
+}
+
+rtl::OUString SwFieldBookmark::getTypeName() {
+    return m_type;
+}
+
+void SwFieldBookmark::addParam(::rtl::OUString paramName, ::rtl::OUString paramValue, bool replaceExisting) 
+{
+    if (replaceExisting) {
+	bool replaced=false;
+	const int len=m_params.size();
+	for(int i=0;i<len;i++) {
+	    if (m_params[i].first.compareTo(paramName)==0) {
+		m_params[i]=ParamPair_t(paramName, paramValue);
+		replaced=true;
+	    }
+	}
+	if (!replaced) {
+	    m_params.push_back(ParamPair_t(paramName, paramValue));
+	}
+    } else {
+	m_params.push_back(ParamPair_t(paramName, paramValue));
+    }
+}
+
+void SwFieldBookmark::addParam(const char* paramName, int value)
+{
+    rtl::OUString sName=rtl::OUString::createFromAscii(paramName);
+    rtl::OUString sValue=::rtl::OUString::valueOf((sal_Int32)value);
+    addParam(sName, sValue);
+}
+
+void SwFieldBookmark::addParams(std::vector<ParamPair_t> &params)
+{
+    for(std::vector<ParamPair_t>::iterator i=params.begin();i!=params.end();i++) {
+	m_params.push_back(*i);
+    }
+}
+
+int SwFieldBookmark::getNumOfParams() 
+{
+    return m_params.size();
+}
+
+SwFieldBookmark::ParamPair_t SwFieldBookmark::getParam(int pos)
+{
+    return m_params[pos];
+}
+
+SwFieldBookmark::ParamPair_t SwFieldBookmark::getParam(const char *name, const char *defaultValue) 
+{
+    for(std::vector<ParamPair_t>::iterator i=m_params.begin();i!=m_params.end();i++) {
+	if (i->first.compareToAscii(name)==0) {
+	    return *i;
+	}
+    }
+    return ParamPair_t(rtl::OUString(), (defaultValue? ::rtl::OUString::createFromAscii(defaultValue)  : ::rtl::OUString()));
+}
+
diff --git sw/source/core/edit/edtox.cxx sw/source/core/edit/edtox.cxx
index 8cb1e7c..efd7bca 100644
--- sw/source/core/edit/edtox.cxx
+++ sw/source/core/edit/edtox.cxx
@@ -60,6 +60,9 @@
 #ifndef _STATSTR_HRC
 #include <statstr.hrc>
 #endif
+#include <bookmrk.hxx>
+#include <ecmaflds.hxx>
+ 
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::i18n;
@@ -232,6 +235,19 @@ BOOL SwEditShell::UpdateTableOf( const SwTOXBase& rTOX, const SfxItemSet* pSet )
 	return bRet;
 }
 
+BOOL SwEditShell::UpdateField(SwFieldBookmark &fieldBM) 
+{
+//    SwDocShell* pDocSh = pDoc->GetDocShell();
+    //@TODO implement me...; add undo etc...
+    if (pDoc && fieldBM.GetOtherBookmarkPos()!=NULL) {
+	SwPaM aPaM(fieldBM.getSelectionStart(), fieldBM.getSelectionEnd());
+	pDoc->Delete(aPaM);
+        pDoc->Insert(aPaM, String::CreateFromAscii("Implement me ;-)"), false);
+    }
+    return TRUE;
+}
+
+
 /*--------------------------------------------------------------------
 	 Beschreibung: Aktuelles Verzeichnis vor oder in dem der Cursor
 								   steht
diff --git sw/source/core/text/inftxt.cxx sw/source/core/text/inftxt.cxx
index 4899f73..af9d8d1 100644
--- sw/source/core/text/inftxt.cxx
+++ sw/source/core/text/inftxt.cxx
@@ -1146,13 +1146,15 @@ void SwTxtPaintInfo::DrawCheckBox( const SwFieldFormPortion &rPor, bool checked)
     SwRect aIntersect;
     CalcRect( rPor, &aIntersect, 0 );
     if ( aIntersect.HasArea() ) {
-	if (OnWin()) {
-	    OutputDevice* pOutDev = (OutputDevice*)GetOut();
-	    pOutDev->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );
-	    pOutDev->SetLineColor( Color(220, 233, 245));
-	    pOutDev->SetFillColor( Color(220, 233, 245));
-	    pOutDev->DrawRect( aIntersect.SVRect() );
-	    pOutDev->Pop();
+	if (OnWin() && SwViewOption::IsFieldShadings() && !GetOpt().IsPagePreview()) {
+	    OutputDevice* pOut_ = (OutputDevice*)GetOut();
+	    pOut_->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );
+	    pOut_->SetFillColor( SwViewOption::GetFieldShadingsColor() );
+	    pOut_->SetLineColor();
+//	    pOut_->SetLineColor( Color(220, 233, 245));
+//	    pOut_->SetFillColor( Color(220, 233, 245));
+	    pOut_->DrawRect( aIntersect.SVRect() );
+	    pOut_->Pop();
 	}
 	const int delta=10;
 	Rectangle r(aIntersect.Left()+delta, aIntersect.Top()+delta, aIntersect.Right()-delta, aIntersect.Bottom()-delta);
@@ -1204,31 +1206,30 @@ void SwTxtPaintInfo::_DrawBackBrush( const SwLinePortion &rPor ) const
     {
         SwRect aIntersect;
         CalcRect( rPor, &aIntersect, 0 );
-        SwTxtNode *pNd = pFrm->GetTxtNode();
-        SwBookmark *pBM=NULL;   
-        if ( aIntersect.HasArea() )
-        {
-            if (pNd)
-            {
-                const SwDoc *doc=pNd->GetDoc();
-                if (doc!=NULL)
-                {
-                    SwIndex aIndex( pNd, GetIdx() );
-                    SwPosition aPosition(*pNd, aIndex);
-                    pBM=doc->getFieldBookmarkFor(aPosition);
-                }
-            }
-            bool bIsStartMark=(1==GetLen() && CH_TXT_ATR_FIELDSTART==GetTxt().GetChar(GetIdx()));
-            if (OnWin() && (pBM!=NULL || bIsStartMark))
-            {
-                OutputDevice* pOutDev = (OutputDevice*)GetOut();
-                pOutDev->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );
-                pOutDev->SetLineColor( Color(220, 233, 245));
-                pOutDev->SetFillColor( Color(220, 233, 245));
-                pOutDev->DrawRect( aIntersect.SVRect() );
-                pOutDev->Pop();
-            }
-        }
+	SwTxtNode *pNd = pFrm->GetTxtNode();
+	SwBookmark *pBM=NULL;	
+	if ( aIntersect.HasArea() )
+	{
+	    if (pNd) {
+		const SwDoc *doc=pNd->GetDoc();
+		if (doc!=NULL) {
+		    SwIndex aIndex( pNd, GetIdx() );
+		    SwPosition aPosition(*pNd, aIndex);
+		    pBM=doc->getFieldBookmarkFor(aPosition);
+		}
+	    }
+	    bool bIsStartMark=(1==GetLen() && CH_TXT_ATR_FIELDSTART==GetTxt().GetChar(GetIdx()));
+	    if (OnWin() && (pBM!=NULL || bIsStartMark) && SwViewOption::IsFieldShadings() && !GetOpt().IsPagePreview()) {
+		OutputDevice* pOut_ = (OutputDevice*)GetOut();
+		pOut_->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );
+		pOut_->SetFillColor( SwViewOption::GetFieldShadingsColor() );
+		pOut_->SetLineColor();
+//		pOut_->SetLineColor( Color(220, 233, 245));
+//		pOut_->SetFillColor( Color(220, 233, 245));
+		pOut_->DrawRect( aIntersect.SVRect() );
+		pOut_->Pop();
+	    }
+	}
     }
     if( !pFnt->GetBackColor() ) return;
 
diff --git sw/source/core/text/portxt.cxx sw/source/core/text/portxt.cxx
index d18ea63..bb05bd9 100644
--- sw/source/core/text/portxt.cxx
+++ sw/source/core/text/portxt.cxx
@@ -55,6 +55,7 @@
 #include <bookmrk.hxx>
 #include <pam.hxx>
 #include <doc.hxx>
+#include <ecmaflds.hxx>
 
 #if OSL_DEBUG_LEVEL > 1
 const sal_Char *GetLangName( const MSHORT nLang );
@@ -781,36 +782,72 @@ sal_Bool SwFieldMarkPortion::Format( SwTxtFormatInfo & )
     return ret;
 }
 
+namespace ecma {
+  static int getCurrentListIndex(SwFieldBookmark *pBM, ::rtl::OUString *currentText=NULL) {
+    int currentIndex=pBM->getParam(ECMA_FORMDROPDOWN_RESULT, "0").second.toInt32();
+    int idx=0;	
+    for(int i=0;i<pBM->getNumOfParams();i++) {
+      SwFieldBookmark::ParamPair_t p=pBM->getParam(i);
+      if (p.first.compareToAscii(ECMA_FORMDROPDOWN_LISTENTRY)==0) {
+	if (idx==currentIndex) {
+	  if (currentText!=NULL) *currentText=p.second;
+	  break;
+	} else
+	  idx++;
+      }			       
+    }	
+    return idx;
+  }
+} /* ecma */
 
 void SwFieldFormPortion::Paint( const SwTxtPaintInfo &rInf ) const
 {
-//	SwTxtPortion::Paint(rInf);
     SwTxtNode *pNd=const_cast<SwTxtNode*>(rInf.GetTxtFrm()->GetTxtNode());
     const SwDoc *doc=pNd->GetDoc();
     SwIndex aIndex( pNd, rInf.GetIdx() );
     SwPosition aPosition(*pNd, aIndex);
     SwFieldBookmark *pBM=doc->getFormFieldBookmarkFor(aPosition);
     ASSERT(pBM!=NULL, "Where is my form field bookmark???");
-    bool checked=(pBM!=NULL?pBM->IsChecked():false);
-    rInf.DrawCheckBox( *this , checked);
-//    const XubString aTxt = XubString::CreateFromAscii("[ ]");
-//    rInf.DrawText( aTxt, *this, 0, aTxt.Len(), false );
+    if (pBM!=NULL) {
+      if (pBM->isType(ECMA_FORMCHECKBOX)==1) { // a checkbox...	    
+	bool checked=pBM->getParam(ECMA_FORMCHECKBOX_CHECKED).second.compareToAscii("on")==0;
+	rInf.DrawCheckBox( *this , checked);
+      } else if (pBM->isType(ECMA_FORMDROPDOWN)) { // a list...
+	rtl::OUString aTxt;
+	int index=ecma::getCurrentListIndex(pBM, &aTxt);
+	rInf.DrawViewOpt( *this, POR_FLD );
+	rInf.DrawText( aTxt, *this, 0, aTxt.getLength(), false );	  
+      } else {
+	assert(0); // unknown type...
+      }
+    }
 }
 
 sal_Bool SwFieldFormPortion::Format( SwTxtFormatInfo &rInf )
 {
     sal_Bool ret=0;
-//	ret=SwTxtPortion::Format(rInf);
-
+    SwTxtNode *pNd=const_cast<SwTxtNode*>(rInf.GetTxtFrm()->GetTxtNode());
+    const SwDoc *doc=pNd->GetDoc();
+    SwIndex aIndex( pNd, rInf.GetIdx() );
+    SwPosition aPosition(*pNd, aIndex);
+    SwFieldBookmark *pBM=doc->getFormFieldBookmarkFor(aPosition);
+    ASSERT(pBM!=NULL, "Where is my form field bookmark???");
+    if (pBM!=NULL) {
+      if (pBM->isType(ECMA_FORMCHECKBOX)) {
 	Width(rInf.GetTxtHeight());
 	Height(rInf.GetTxtHeight());
 	SetAscent(rInf.GetAscent());
-	//int h=rInf.GetTxtHeight();
-
-/*
-	Height(100);
-	SetAscent(100);
-*/
+      } else if (pBM->isType(ECMA_FORMDROPDOWN)) {
+	::rtl::OUString aTxt;
+	ecma::getCurrentListIndex(pBM, &aTxt);
+	SwPosSize aPosSize=rInf.GetTxtSize(aTxt);
+	Width(aPosSize.Width());
+	Height(aPosSize.Height());
+	SetAscent(rInf.GetAscent());
+      } else {
+	assert(0); // unknown type...
+      }      
+    }
     return ret;
 }
 
diff --git sw/source/core/unocore/unobkm.cxx sw/source/core/unocore/unobkm.cxx
index 26f40ec..755e6f8 100644
--- sw/source/core/unocore/unobkm.cxx
+++ sw/source/core/unocore/unobkm.cxx
@@ -7,7 +7,7 @@
  * OpenOffice.org - a multi-platform office productivity suite
  *
  * $RCSfile: unobkm.cxx,v $
- * $Revision: 1.17 $
+ * $Revision: 1.16 $
  *
  * This file is part of OpenOffice.org.
  *
@@ -134,14 +134,15 @@ void SwXBookmark::attachToRangeEx(const uno::Reference< text::XTextRange > & xTe
 				 m_aName =  C2S("Bookmark");
             // --> OD 2007-10-23 #i81002#
             // determine bookmark type due to its proposed name
-            if( eMark == IDocumentBookmarkAccess::BOOKMARK &&
-                pDoc->isCrossRefBookmarkName( m_aName ) )
-                eMark = IDocumentBookmarkAccess::CROSSREF_BOOKMARK;
+            IDocumentBookmarkAccess::BookmarkType eBkmkType =
+                                    pDoc->isCrossRefBookmarkName( m_aName )
+                                    ? IDocumentBookmarkAccess::CROSSREF_BOOKMARK
+                                    : eMark;
             // <--
             if( USHRT_MAX != pDoc->findBookmark(m_aName) )
                 pDoc->makeUniqueBookmarkName( m_aName );
 			KeyCode aCode;
-            pBkm = pDoc->makeBookmark( aPam, aCode, m_aName, aEmptyStr, eMark);
+            pBkm = pDoc->makeBookmark( aPam, aCode, m_aName, aEmptyStr, eBkmkType);
             // --> OD 2007-10-23 #i81002#
             // Check, if bookmark has been created.
             // E.g., the creation of a cross-reference bookmark is suppress,
@@ -164,109 +165,87 @@ void SwXBookmark::attachToRangeEx(const uno::Reference< text::XTextRange > & xTe
 }
 
 void SwXBookmark::attachToRange(const uno::Reference< text::XTextRange > & xTextRange)
-    throw( lang::IllegalArgumentException, uno::RuntimeException )
+										throw( lang::IllegalArgumentException, uno::RuntimeException )
 {
 	attachToRangeEx(xTextRange, IDocumentBookmarkAccess::BOOKMARK);
 }
 
-SwXFieldmark::SwXFieldmark(bool _isReplacementObject, SwBookmark* pBkm, SwDoc* pDc)
-    : SwXFieldmark_BASE(pBkm, pDc)
-    , isReplacementObject(_isReplacementObject)
-{ }
-
-
-void SwXFieldmark::attachToRange(const uno::Reference< text::XTextRange > & xTextRange)
-    throw( lang::IllegalArgumentException, uno::RuntimeException )
+SwXFieldmark::SwXFieldmark(bool _isReplacementObject, SwBookmark* pBkm, SwDoc* pDc) : SwXFieldmark_BASE(pBkm, pDc),
+isReplacementObject(_isReplacementObject)
 {
-    attachToRangeEx(xTextRange, (isReplacementObject?IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT:IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT));
 }
 
-::rtl::OUString SwXFieldmark::getDescription(void) throw( ::com::sun::star::uno::RuntimeException )
+::rtl::OUString SwXFieldmark::getFieldType(void)  throw( ::com::sun::star::uno::RuntimeException )
 {
     vos::OGuard aGuard(Application::GetSolarMutex());
     SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
-    OUString sRet;
     if(pBkm)
-        sRet = pBkm->GetFFHelpText();
-    /* //@TODO implement...
-    else if(bIsDescriptor)
-        sRet = m_aName;
-        */
+	return pBkm->getTypeName();
     else
         throw uno::RuntimeException();
-    return sRet;
 }
 
-::sal_Int16 SAL_CALL SwXFieldmark::getType(  ) throw (::com::sun::star::uno::RuntimeException)
+void SwXFieldmark::setFieldType( const ::rtl::OUString& fieldType ) throw (::com::sun::star::uno::RuntimeException)
 {
     vos::OGuard aGuard(Application::GetSolarMutex());
     SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
-    ::sal_Int16 sRet;
-    if(pBkm)
-        sRet = static_cast<sal_Int16>(pBkm->GetFieldType());
-    /* //@TODO implement...
-    else if(bIsDescriptor)
-        sRet = m_aName;
-        */
+    if (pBkm)
+        pBkm->setTypeName(fieldType);
     else
-        throw uno::RuntimeException();
-    return sRet;
+        throw uno::RuntimeException();    
 }
 
-::sal_Int16 SAL_CALL SwXFieldmark::getRes(  ) throw (::com::sun::star::uno::RuntimeException)
+::sal_Int16 SwXFieldmark::getParamCount(  ) throw (::com::sun::star::uno::RuntimeException)
 {
     vos::OGuard aGuard(Application::GetSolarMutex());
     SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
-    ::sal_Int16 sRet;
     if(pBkm)
-        sRet = static_cast<sal_Int16>(pBkm->GetFFRes());
-    /* //@TODO implement...
-    else if(bIsDescriptor)
-        sRet = m_aName;
-        */
+	return pBkm->getNumOfParams();
     else
         throw uno::RuntimeException();
-    return sRet;
 }
 
-
-void SAL_CALL SwXFieldmark::setType( ::sal_Int16 fieldType ) throw (::com::sun::star::uno::RuntimeException)
+::rtl::OUString SwXFieldmark::getParamName(::sal_Int16 i)  throw( ::com::sun::star::uno::RuntimeException )
 {
     vos::OGuard aGuard(Application::GetSolarMutex());
     SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
-    if (pBkm)
-        pBkm->SetFieldType(fieldType);
+    if(pBkm)
+	return pBkm->getParam(i).first;
     else
         throw uno::RuntimeException();
 }
 
-void SAL_CALL SwXFieldmark::setRes( ::sal_Int16 res ) throw (::com::sun::star::uno::RuntimeException)
+::rtl::OUString SwXFieldmark::getParamValue(::sal_Int16 i)  throw( ::com::sun::star::uno::RuntimeException )
 {
     vos::OGuard aGuard(Application::GetSolarMutex());
     SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
-    if (pBkm)
-        pBkm->SetFFRes(res);
+    if(pBkm)
+	return pBkm->getParam(i).second;
     else
         throw uno::RuntimeException();
 }
 
-void SAL_CALL SwXFieldmark::setDescription( const ::rtl::OUString& description ) throw (::com::sun::star::uno::RuntimeException)
+void SwXFieldmark::addParam( const ::rtl::OUString& name, const ::rtl::OUString& value, ::sal_Bool replaceExisting ) throw (::com::sun::star::uno::RuntimeException)
 {
     vos::OGuard aGuard(Application::GetSolarMutex());
     SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
     if (pBkm)
-        pBkm->SetFFHelpText(description);
+        pBkm->addParam(name, value, replaceExisting);
     else
-        throw uno::RuntimeException();
+        throw uno::RuntimeException();    
 }
 
-
+void SwXFieldmark::attachToRange(const uno::Reference< text::XTextRange > & xTextRange)
+										throw( lang::IllegalArgumentException, uno::RuntimeException )
+{
+	attachToRangeEx(xTextRange, (isReplacementObject?IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT:IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT));
+}
 
 /*
 
 ::com::sun::star::uno::Any SAL_CALL SwXFieldmark::queryInterface( ::com::sun::star::uno::Type const & rType ) throw (::com::sun::star::uno::RuntimeException)
 {
-        return SwXBookmark::queryInterface(rType);
+		return SwXBookmark::queryInterface(rType);
 }
 */
 
diff --git sw/source/core/unocore/unoportenum.cxx sw/source/core/unocore/unoportenum.cxx
index fc11495..c4160ba 100644
--- sw/source/core/unocore/unoportenum.cxx
+++ sw/source/core/unocore/unoportenum.cxx
@@ -653,15 +653,7 @@ void lcl_FillBookmarkArray(SwDoc& rDoc,SwUnoCrsr& rUnoCrsr, SwXBookmarkPortion_I
         for( sal_uInt16 n = 0; n < nArrLen; ++n )
         {
             SwBookmark* pMark = rMarks.GetObject( n );
-            /*
-            if (pMark!=NULL && pMark->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0) {
-                continue;
-            }
 
-            if (pMark!=NULL && pMark->GetName().CompareToAscii(FIELD_FORM_BOOKMARK_PREFIX, strlen(FIELD_FORM_BOOKMARK_PREFIX))==0) {
-                continue;
-            }
-            */
             if (pMark!=NULL && pMark->IsFormFieldMark())
             {
                 continue;
diff --git sw/source/filter/ww8/wrtw8nds.cxx sw/source/filter/ww8/wrtw8nds.cxx
index ab8ff01..a8f5157 100644
--- sw/source/filter/ww8/wrtw8nds.cxx
+++ sw/source/filter/ww8/wrtw8nds.cxx
@@ -112,6 +112,45 @@ using namespace sw::util;
 using namespace sw::types;
 using namespace nsFieldFlags;
 
+
+static String lcl_getFieldCode(SwFieldBookmark* pFieldmark) {
+    ASSERT(pFieldmark!=NULL, "where is my fieldmark???");
+    if (pFieldmark->isType(ECMA_FORMTEXT)) {
+	return String::CreateFromAscii(" FORMTEXT ");
+    } else if (pFieldmark->isType(ECMA_FORMDROPDOWN)) {
+	return String::CreateFromAscii(" FORMDROPDOWN ");
+    } else if (pFieldmark->isType(ECMA_FORMCHECKBOX)) {
+	return String::CreateFromAscii(" FORMCHECKBOX ");
+    } else if (pFieldmark->isType(ECMA_TOC)) {
+	return String::CreateFromAscii(" TOC ");
+    } else if (pFieldmark->isType(ECMA_HYPERLINK)) {
+	return String::CreateFromAscii(" HYPERLINK ");
+    } else if (pFieldmark->isType(ECMA_PAGEREF)) {
+	return String::CreateFromAscii(" PAGEREF ");
+    } else {
+	return pFieldmark->getTypeName();
+    }
+}
+
+ww::eField lcl_getFieldId(SwFieldBookmark* pFieldmark) {
+    ASSERT(pFieldmark!=NULL, "where is my fieldmark???");
+    if (pFieldmark->isType(ECMA_FORMTEXT)) {
+	return ww::eFORMTEXT;
+    } else if (pFieldmark->isType(ECMA_FORMDROPDOWN)) {
+	return ww::eFORMDROPDOWN;
+    } else if (pFieldmark->isType(ECMA_FORMCHECKBOX)) {
+	return ww::eFORMCHECKBOX;
+    } else if (pFieldmark->isType(ECMA_TOC)) {
+	return ww::eTOC;
+    } else if (pFieldmark->isType(ECMA_HYPERLINK)) {
+	return ww::eHYPERLINK;
+    } else if (pFieldmark->isType(ECMA_PAGEREF)) {
+	return ww::ePAGEREF;
+    } else {
+	return ww::eUNKNOWN;
+    }    
+}
+
 /*  */
 
 WW8_AttrIter::WW8_AttrIter(SwWW8Writer& rWr)
@@ -288,19 +327,17 @@ xub_StrLen WW8_SwAttrIter::SearchNext( xub_StrLen nStartPos )
 {
     xub_StrLen nPos;
     xub_StrLen nMinPos = STRING_MAXLEN;
+    xub_StrLen i=0;
+
 	const String aTxt = rNd.GetTxt();
 	xub_StrLen pos = aTxt.Search(CH_TXT_ATR_FIELDSTART, nStartPos);
-	if( pos==STRING_NOTFOUND )
-    {
-		pos = aTxt.Search(CH_TXT_ATR_FIELDEND, nStartPos);
-        if( pos==STRING_NOTFOUND )
-            pos = aTxt.Search(CH_TXT_ATR_FORMELEMENT, nStartPos);
-    }
-	if( pos!=STRING_NOTFOUND )
+	if (pos==STRING_NOTFOUND) 
+		pos=aTxt.Search(CH_TXT_ATR_FIELDEND, nStartPos);
+	if (pos==STRING_NOTFOUND) 
+		pos=aTxt.Search(CH_TXT_ATR_FORMELEMENT, nStartPos);
+	if (pos!=STRING_NOTFOUND)  
 		nMinPos=pos;
 
-    xub_StrLen i=0;
-
     // first the redline, then the attributes
     if( pCurRedline )
     {
@@ -1558,36 +1595,49 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, SwCntntNode& rNode )
 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
 
 				if (pFieldmark!=NULL) {
-					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 1);
+				  if (pFieldmark->isType(ECMA_FORMTEXT)) {
+				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
+				  }
+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), lcl_getFieldCode(pFieldmark), WRITEFIELD_START | WRITEFIELD_CMD_START);	
+				  if (pFieldmark->isType(ECMA_FORMTEXT)) {
+				    rWW8Wrt.WriteFormData( *pFieldmark );
+				  }
+				  if (pFieldmark->isType(ECMA_HYPERLINK)) {
+					rWW8Wrt.WriteHyperlinkData( *pFieldmark );
+				  }
+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CMD_END);
 				}
-				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String::CreateFromAscii(" FORMTEXT "), WRITEFIELD_START | WRITEFIELD_CMD_START);
-				if (pFieldmark!=NULL) {
-					rWW8Wrt.WriteFormData( *pFieldmark );
-				}
-				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String(), WRITEFIELD_CMD_END);
 			} else if (ch==CH_TXT_ATR_FIELDEND) {
 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
 				SwFieldBookmark* pFieldmark=(SwFieldBookmark*)rWW8Wrt.pDoc->getFieldBookmarkFor( aPosition );
 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
-				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String(), WRITEFIELD_CLOSE);
 				if (pFieldmark!=NULL) {
-					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CLOSE);
+				  if (pFieldmark->isType(ECMA_FORMTEXT)) {
+				    
+				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
+				  }
 				}
 			} else if (ch==CH_TXT_ATR_FORMELEMENT) {
 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
 				SwFieldBookmark* pFieldmark=rWW8Wrt.pDoc->getFormFieldBookmarkFor( aPosition );
 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
 				if (pFieldmark!=NULL) {
-					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 1);
-				}
-				rWW8Wrt.OutField(NULL, ww::eFORMCHECKBOX, String::CreateFromAscii(" FORMCHECKBOX "), WRITEFIELD_START | WRITEFIELD_CMD_START);
-				if (pFieldmark!=NULL) {
-
-					rWW8Wrt.WriteFormData( *pFieldmark );
-				}
-				rWW8Wrt.OutField(NULL, ww::eFORMCHECKBOX, String(), WRITEFIELD_CMD_END | WRITEFIELD_CLOSE);
-				if (pFieldmark!=NULL) {
-					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
+				  /* printf("export FROMELEMENT: pFieldmark->isType(ECMA_FORMDROPDOWN)=%i, pFieldmark->isType(ECMA_FORMCHECKBOX)=%i\n", pFieldmark->isType(ECMA_FORMDROPDOWN), pFieldmark->isType(ECMA_FORMCHECKBOX)); */
+				  if (pFieldmark->isType(ECMA_FORMDROPDOWN) || pFieldmark->isType(ECMA_FORMCHECKBOX)) {
+				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
+
+				  }
+				  /* printf("lcl_getFieldId(pFieldmark)=%i\n",lcl_getFieldId(pFieldmark)); */
+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), lcl_getFieldCode(pFieldmark), WRITEFIELD_START | WRITEFIELD_CMD_START);
+				  if (pFieldmark->isType(ECMA_FORMCHECKBOX) || pFieldmark->isType(ECMA_FORMDROPDOWN)) {
+				    rWW8Wrt.WriteFormData( *pFieldmark );
+
+				  }
+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CMD_END | WRITEFIELD_CLOSE);
+				  if (pFieldmark->isType(ECMA_FORMDROPDOWN) || pFieldmark->isType(ECMA_FORMCHECKBOX)) {				    
+				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
+				  }
 				}
 			}
 			nLen-=static_cast<USHORT>(ofs);
diff --git sw/source/filter/ww8/wrtww8.cxx sw/source/filter/ww8/wrtww8.cxx
index ca1d344..0d99564 100644
--- sw/source/filter/ww8/wrtww8.cxx
+++ sw/source/filter/ww8/wrtww8.cxx
@@ -101,6 +101,7 @@
 #include "writerwordglue.hxx"
 
 #include <IDocumentBookmarkAccess.hxx>
+#include <ecmaflds.hxx>
 
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
@@ -2303,7 +2304,7 @@ void SwWW8Writer::OutWW8TableBackgrounds
 
 void SwWW8Writer::WriteText()
 {
-#ifdef DEBUG
+#ifndef NDEBUG
     ::std::clog << "<WriteText>" << ::std::endl;
     ::std::clog << dbg_out(pCurPam->GetDoc()->GetNodes()) << ::std::endl;
 #endif
@@ -3183,8 +3184,19 @@ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
 	ASSERT(bWrtWW8, "No 95 export yet");
 	if (!bWrtWW8) return;
 
-	int type=rFieldmark.GetFieldType();
-	const String ffname=rFieldmark.GetFFName();
+	ASSERT(rFieldmark.isType(ECMA_FORMTEXT) || rFieldmark.isType(ECMA_FORMDROPDOWN) || rFieldmark.isType(ECMA_FORMCHECKBOX), "Unknown field type!!!");
+	if (!(rFieldmark.isType(ECMA_FORMTEXT) || rFieldmark.isType(ECMA_FORMDROPDOWN) || rFieldmark.isType(ECMA_FORMCHECKBOX)))
+	    return;
+
+	/* printf("write form data\n"); */
+
+	int type=0;
+	if (rFieldmark.isType(ECMA_FORMCHECKBOX))
+	    type=1;
+	if (rFieldmark.isType(ECMA_FORMDROPDOWN))
+	    type=2;
+	
+	const String ffname=rFieldmark.getParam("name").second;
 
 	ULONG nDataStt = pDataStrm->Tell();
     pChpPlc->AppendFkpEntry( Strm().Tell() );
@@ -3206,13 +3218,29 @@ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
 	sal_uInt8 aFldHeader[] = 
 	{
 		0xFF, 0xFF, 0xFF, 0xFF, // Unicode Marker...
-		0, 0, 0, 0//, 0, 0, 0, 0
+		0, 0, 0, 0, 0, 0 //, 0, 0
 	};
 
 	aFldHeader[4] |= (type & 0x03);
-	int ffres=rFieldmark.GetFFRes();
+	int ffres=0;
+	if (type==1) { // checkbox
+	    ffres=rFieldmark.getParam(ECMA_FORMCHECKBOX_CHECKED).second.compareToAscii("on")==0;
+	} else if (type==2) { // drop down
+	    ffres=rFieldmark.getParam(ECMA_FORMDROPDOWN_RESULT, "0").second.toInt32();
+	}
+
 	aFldHeader[4] |= ((ffres<<2) & 0x7C);
 
+
+	std::vector< ::rtl::OUString > aListItems;
+	if (type==2) {
+	    aFldHeader[5] |= 0x80; // ffhaslistbox
+	    for(int i=0;i<rFieldmark.getNumOfParams();i++) {
+		if (rFieldmark.getParam(i).first.compareToAscii(ECMA_FORMDROPDOWN_LISTENTRY)==0)
+		    aListItems.push_back(rFieldmark.getParam(i).second);
+	    }
+	}
+
 	const String ffdeftext;
 	const String ffformat;
 	const String ffhelptext;
@@ -3220,6 +3248,7 @@ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
 	const String ffentrymcr;
 	const String ffexitmcr;
 
+
     const sal_uInt8 aFldData[] =
     {
         0,0,0,0,        // len of struct
@@ -3239,6 +3268,15 @@ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
 		+2*ffstattext.Len()+4
 		+2*ffentrymcr.Len()+4
 		+2*ffexitmcr.Len()+4;
+	if (type==2) {
+	    slen+=2; // for 0xFF, 0xFF
+	    slen+=4; // for num of list items
+	    const int items=aListItems.size();
+	    for(int i=0;i<items;i++) {
+		String item=aListItems[i];
+		slen+=2*item.Len()+2;
+	    }
+	}
 #ifdef OSL_BIGENDIAN
 	slen=SWAPLONG(slen);
 #endif // OSL_BIGENDIAN
@@ -3249,14 +3287,14 @@ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
 
 	len=sizeof(aFldHeader);
 	assert(len==8);
-    pDataStrm->Write( aFldHeader, len);
+	pDataStrm->Write( aFldHeader, len);
 
-    WriteString_xstz( *pDataStrm, ffname, true); // Form field name
+	WriteString_xstz( *pDataStrm, ffname, true); // Form field name
 
 	if (type==0) {
-		WriteString_xstz( *pDataStrm, ffdeftext, true);
+	    WriteString_xstz( *pDataStrm, ffdeftext, true);
 	} else {
-		pDataStrm->WriteNumber((sal_uInt16)0);
+	    *pDataStrm<<(sal_uInt16)0;
 	}	
 	WriteString_xstz( *pDataStrm, ffformat, true);
 	WriteString_xstz( *pDataStrm, ffhelptext, true);
@@ -3264,13 +3302,23 @@ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
 	WriteString_xstz( *pDataStrm, ffentrymcr, true);
 	WriteString_xstz( *pDataStrm, ffexitmcr, true);
 	if (type==2) {
-		// 0xFF, 0xFF
-		// sal_uInt32 number of strings
-		// (sal_uInt16 len; sal_uInt16 unicode char[len])*num of strings
+	  *pDataStrm<<(sal_uInt16)0xFFFF;
+	  const int items=aListItems.size();
+	  *pDataStrm<<(sal_uInt32)items;
+	  for(int i=0;i<items;i++) {
+	    String item=aListItems[i];
+	    WriteString_xstz( *pDataStrm, item, false);
+	  }
 	}
 
 }
 
+void SwWW8Writer::WriteHyperlinkData(SwFieldBookmark &rFieldmark)
+{
+    //@TODO implement me !!!
+}
+
+
 void SwWW8Writer::OutWW8_TableNodeInfoInner(ww8::WW8TableNodeInfoInner::Pointer_t pNodeInfoInner)
 {
     SVBT16 nStyle;
diff --git sw/source/filter/ww8/wrtww8.hxx sw/source/filter/ww8/wrtww8.hxx
index d11049f..757126c 100644
--- sw/source/filter/ww8/wrtww8.hxx
+++ sw/source/filter/ww8/wrtww8.hxx
@@ -733,7 +733,8 @@ public:
     void CollectOutlineBookmarks(const SwDoc &rDoc);
     void AddBookmark(String sBkmkName);
 
-	void WriteFormData(SwFieldBookmark &rFieldmark);
+    void WriteFormData(SwFieldBookmark &rFieldmark);
+    void WriteHyperlinkData(SwFieldBookmark &rFieldmark);
     WW8_WrPlcFld* CurrentFieldPlc() const;
 private:
     //No copying
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index 385de9b..68be371 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -1685,7 +1685,6 @@ WW8ReaderSave::WW8ReaderSave(SwWW8ImplReader* pRdr ,WW8_CP nStartCp) :
     maOldApos.push_back(false);
     maOldApos.swap(pRdr->maApos);
     maOldFieldStack.swap(pRdr->maFieldStack);
-	maFieldCtxStack.swap(pRdr->maNewFieldCtxStack);
 }
 
 void WW8ReaderSave::Restore( SwWW8ImplReader* pRdr )
@@ -1732,7 +1731,6 @@ void WW8ReaderSave::Restore( SwWW8ImplReader* pRdr )
         pRdr->pPlcxMan->RestoreAllPLCFx(maPLCFxSave);
     pRdr->maApos.swap(maOldApos);
     pRdr->maFieldStack.swap(maOldFieldStack);
-	pRdr->maNewFieldCtxStack.swap(maFieldCtxStack);
 }
 
 void SwWW8ImplReader::Read_HdFtFtnText( const SwNodeIndex* pSttIdx,
@@ -2750,22 +2748,6 @@ bool SwWW8ImplReader::ReadChar(long nPosCp, long nCpOfs)
         case 0x15:
             if( !bSpec )        // Juristenparagraph
                 cInsert = '\xa7';
-			else { //0x15 is special --> so it's our field end mark...; hmmm what about field marks not handled by us??, maybe a problem with nested fields; probably an area of bugs... [well release quick and release often....]
-				if (!maNewFieldCtxStack.empty() && pPaM!=NULL && pPaM->GetPoint()!=NULL) {
-					WW8NewFieldCtx *pFieldCtx=maNewFieldCtxStack.back();
-					maNewFieldCtxStack.pop_back();
-					SwPosition aEndPos = *pPaM->GetPoint();
-					SwPaM aFldPam( pFieldCtx->GetPtNode(), pFieldCtx->GetPtCntnt(), aEndPos.nNode, aEndPos.nContent.GetIndex());
-					SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeBookmark(aFldPam, KeyCode(), pFieldCtx->GetBookmarkName(), String(), IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT);
-					ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
-					if (pFieldmark!=NULL) {
-						pFieldmark->SetFieldType(0); // 0==Text
-						// set field data here...
-						pFieldCtx->SetCurrentFieldParamsTo(*pFieldmark);
-					}
-					delete pFieldCtx;
-				}
-			}
             break;
         case 0x9:
             cInsert = '\x9';    // Tab
@@ -3580,7 +3562,14 @@ void wwSectionManager::InsertSegments()
 
         bool bInsertSection = (aIter != aStart) ? (aIter->IsContinous() &&  bThisAndPreviousAreCompatible): false;
         bool bInsertPageDesc = !bInsertSection;
-        bool bProtected = !bUseEnhFields && SectionIsProtected(*aIter); // do we really  need this ?? I guess I have a different logic in editshell which disales this...
+        bool bProtected = SectionIsProtected(*aIter); // do we really  need this ?? I guess I have a different logic in editshell which disales this...
+	if (bUseEnhFields && mrReader.pWDop->fProtEnabled && aIter->IsNotProtected()) {
+	    // here we have the special case that the whole document is protected, with the execption of this section.
+	    // I want to address this when I do the section rework, so for the moment we disable the overall protection then...
+	    mrReader.rDoc.set(IDocumentSettingAccess::PROTECT_FORM, false );
+	}
+
+
         if (bInsertPageDesc)
         {
             /*
diff --git sw/source/filter/ww8/ww8par.hxx sw/source/filter/ww8/ww8par.hxx
index 840dfdf..d8a789d 100644
--- sw/source/filter/ww8/ww8par.hxx
+++ sw/source/filter/ww8/ww8par.hxx
@@ -61,6 +61,8 @@
 #include "ww8scan.hxx"  // WW8Fib
 #include "ww8glsy.hxx"
 #include "../inc/msfilter.hxx"
+#include <ecmaflds.hxx>
+#include <bookmrk.hxx>
 
 class SwDoc;
 class SwPaM;
@@ -362,6 +364,8 @@ namespace sw
             Position(const SwPosition &rPos);
             Position(const Position &rPos);
             operator SwPosition() const;
+	    SwNodeIndex GetPtNode() { return maPtNode; };
+	    xub_StrLen GetPtCntnt() { return mnPtCntnt; };        
         };
     }
 }
@@ -369,40 +373,31 @@ namespace sw
 class FieldEntry
 {
 public:
-    sw::hack::Position maStartPos;
-    sal_uInt16 mnFieldId;
-    FieldEntry(SwPosition &rPos, sal_uInt16 nFieldId) throw();
-    FieldEntry(const FieldEntry &rOther) throw();
-    FieldEntry &operator=(const FieldEntry &rOther) throw();
-    void Swap(FieldEntry &rOther) throw();
-};
+	typedef ::std::vector<SwFieldBookmark::ParamPair_t> Params_t;
 
-class WW8NewFieldCtx
-{
 private:
-	SwNodeIndex maPtNode;
-    xub_StrLen mnPtCntnt;
 	::rtl::OUString sBookmarkName;
 	::rtl::OUString sBookmarkType;
-	typedef ::std::pair< ::rtl::OUString, ::rtl::OUString> Param_t;
-	typedef ::std::vector< Param_t > Params_t;
 	Params_t maParams;
-  SwPaM * mpPaM;
-
 public:
-	WW8NewFieldCtx(SwPosition &aStartPos, ::rtl::OUString sBookmarkName, ::rtl::OUString sBookmarkType);
-	~WW8NewFieldCtx();
+    sw::hack::Position maStartPos;
+    sal_uInt16 mnFieldId;
+    FieldEntry(SwPosition &rPos, sal_uInt16 nFieldId) throw();
+    FieldEntry(const FieldEntry &rOther) throw();
+    FieldEntry &operator=(const FieldEntry &rOther) throw();
+    void Swap(FieldEntry &rOther) throw();
 
-	SwNodeIndex GetPtNode() { return maPtNode; };
-	xub_StrLen GetPtCntnt() { return mnPtCntnt; };
-	::rtl::OUString GetBookmarkName();
-	::rtl::OUString GetBookmarkType();
-	void AddParam(::rtl::OUString name, ::rtl::OUString value);
-	void SetCurrentFieldParamsTo(SwFieldBookmark &rFieldBookmark);
+    SwNodeIndex GetPtNode() { return maStartPos.GetPtNode(); };
+    xub_StrLen GetPtCntnt() { return maStartPos.GetPtCntnt(); };
 
+    ::rtl::OUString GetBookmarkName();
+    ::rtl::OUString GetBookmarkType();
+    void SetBookmarkName(::rtl::OUString bookmarkName);
+    void SetBookmarkType(::rtl::OUString bookmarkType);
+    void AddParam(::rtl::OUString name, ::rtl::OUString value);
+    Params_t &getParams();
 };
 
-
 //-----------------------------------------
 //    Mini-Merker fuer einige Flags
 //-----------------------------------------
@@ -435,7 +430,6 @@ private:
     bool mbWasParaEnd;
     bool mbHasBorder;
     bool mbFirstPara;
-	std::deque<WW8NewFieldCtx *> maFieldCtxStack;
 public:
     WW8ReaderSave(SwWW8ImplReader* pRdr, WW8_CP nStart=-1);
     void Restore(SwWW8ImplReader* pRdr);
@@ -890,9 +884,6 @@ private:
     std::deque<FieldEntry> maFieldStack;
     typedef std::deque<FieldEntry>::const_iterator mycFieldIter;
 
-	typedef std::deque<WW8NewFieldCtx *> WW8NewFieldCtxStack_t;
-	WW8NewFieldCtxStack_t maNewFieldCtxStack;
-
     /*
     A stack of open footnotes. Should only be one in it at any time.
     */
diff --git sw/source/filter/ww8/ww8par3.cxx sw/source/filter/ww8/ww8par3.cxx
index a83e3cb..7ce8b98 100644
--- sw/source/filter/ww8/ww8par3.cxx
+++ sw/source/filter/ww8/ww8par3.cxx
@@ -96,6 +96,7 @@
 
 #include <bookmrk.hxx>
 #include <svtools/fltrcfg.hxx>
+#include <ecmaflds.hxx>
 
 #include <stdio.h>
 
@@ -103,49 +104,6 @@ using namespace com::sun::star;
 using namespace sw::util;
 using namespace sw::types;
 
-WW8NewFieldCtx::WW8NewFieldCtx(SwPosition &aStartPos, ::rtl::OUString _sBookmarkName, ::rtl::OUString _sBookmarkType)
-: maPtNode(aStartPos.nNode), mnPtCntnt(aStartPos.nContent.GetIndex()),
-  sBookmarkName(_sBookmarkName),
-  sBookmarkType(_sBookmarkType), mpPaM(NULL)
-{
-}
-
-
-WW8NewFieldCtx::~WW8NewFieldCtx()
-{
-	if (mpPaM) delete mpPaM;
-}
-
-::rtl::OUString WW8NewFieldCtx::GetBookmarkName()
-{
-	return sBookmarkName;
-}
-
-::rtl::OUString WW8NewFieldCtx::GetBookmarkType()
-{
-	return sBookmarkType;
-}
-
-void WW8NewFieldCtx::AddParam(::rtl::OUString name, ::rtl::OUString value)
-{
-	maParams.push_back( Param_t(name, value) );
-}
-
-void WW8NewFieldCtx::SetCurrentFieldParamsTo(SwFieldBookmark &rFieldBookmark)
-{
-	for(Params_t::iterator i=maParams.begin();i!=maParams.end();i++) {
-		::rtl::OUString aName=i->first;
-		::rtl::OUString aValue=i->second;
-		if (aName.compareToAscii("Description")==0) {
-			rFieldBookmark.SetFFHelpText(aValue);
-		} else if (aName.compareToAscii("Name")==0) {
-			rFieldBookmark.SetFFName(aValue);
-		} else if (aName.compareToAscii("Result")==0) {
-			rFieldBookmark.SetFFRes( aValue.toInt32() );
-		}
-	}
-}
-
 //-----------------------------------------
 //            UNO-Controls
 //-----------------------------------------
@@ -222,10 +180,10 @@ eF_ResT SwWW8ImplReader::Read_F_FormTextBox( WW8FieldDesc* pF, String& rStr )
 
 
 	if (aBookmarkName.Len()>0) {
-		WW8NewFieldCtx *pFieldCtx=new WW8NewFieldCtx(*pPaM->GetPoint(), aBookmarkName, ::rtl::OUString::createFromAscii("ecma.office-open-xml.field.FORMTEXT"));
-		maNewFieldCtxStack.push_back(pFieldCtx);
-		pFieldCtx->AddParam(::rtl::OUString::createFromAscii("Description"), aFormula.sToolTip);
-		pFieldCtx->AddParam(::rtl::OUString::createFromAscii("Name"), aFormula.sTitle);
+	    maFieldStack.back().SetBookmarkName(aBookmarkName);
+	    maFieldStack.back().SetBookmarkType(::rtl::OUString::createFromAscii(ECMA_FORMTEXT));
+	    maFieldStack.back().AddParam(::rtl::OUString::createFromAscii("Description"), aFormula.sToolTip);
+	    maFieldStack.back().AddParam(::rtl::OUString::createFromAscii("Name"), aFormula.sTitle);
 	}
 	return FLD_TEXT;
     }
@@ -269,15 +227,14 @@ eF_ResT SwWW8ImplReader::Read_F_FormCheckBox( WW8FieldDesc* pF, String& rStr )
 	}
 
 	if (aBookmarkName.Len()>0) {
-		SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeBookmark(*pPaM, KeyCode(), aBookmarkName, String(), IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT);
-		ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
-		if (pFieldmark!=NULL) {
-			pFieldmark->SetFieldType(1); // 0==Checkbox
-			pFieldmark->SetFFName(aFormula.sTitle);
-			pFieldmark->SetFFHelpText(aFormula.sToolTip);
-			pFieldmark->SetChecked(aFormula.nChecked!=0);
-			// set field data here...
-		}
+	    SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeNoTextFieldBookmark(*pPaM, aBookmarkName, rtl::OUString::createFromAscii(ECMA_FORMCHECKBOX));
+	    ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
+	    if (pFieldmark!=NULL) {
+		pFieldmark->addParam(rtl::OUString::createFromAscii(ECMA_FORMCHECKBOX_NAME), aFormula.sTitle);
+		pFieldmark->addParam(rtl::OUString::createFromAscii(ECMA_FORMCHECKBOX_HELPTEXT), aFormula.sToolTip);
+		pFieldmark->addParam(rtl::OUString::createFromAscii(ECMA_FORMCHECKBOX_CHECKED), ::rtl::OUString::createFromAscii(aFormula.nChecked!=0?"on":"off"));
+		// set field data here...
+	    }
 	}
 	return FLD_OK;
     }
@@ -290,24 +247,70 @@ eF_ResT SwWW8ImplReader::Read_F_FormListBox( WW8FieldDesc* pF, String& rStr)
     if (0x01 == rStr.GetChar(writer_cast<xub_StrLen>(pF->nLCode-1)))
         ImportFormulaControl(aFormula,pF->nSCode+pF->nLCode-1, WW8_CT_DROPDOWN);
 
-    SwDropDownField aFld(
-        (SwDropDownFieldType*)rDoc.GetSysFldType(RES_DROPDOWN));
+    const SvtFilterOptions* pOpt = SvtFilterOptions::Get();
+    sal_Bool bUseEnhFields=(pOpt && pOpt->IsUseEnhancedFields());
 
-    aFld.SetName(aFormula.sTitle);
-    aFld.SetHelp(aFormula.sHelp);
-    aFld.SetToolTip(aFormula.sToolTip);
+    if (!bUseEnhFields) {
+	SwDropDownField aFld(
+	    (SwDropDownFieldType*)rDoc.GetSysFldType(RES_DROPDOWN));
 
-    if (!aFormula.maListEntries.empty())
-    {
-        aFld.SetItems(aFormula.maListEntries);
-        int nIndex = aFormula.fDropdownIndex  < aFormula.maListEntries.size()
-            ? aFormula.fDropdownIndex : 0;
-        aFld.SetSelectedItem(aFormula.maListEntries[nIndex]);
-    }
+	aFld.SetName(aFormula.sTitle);
+	aFld.SetHelp(aFormula.sHelp);
+	aFld.SetToolTip(aFormula.sToolTip);
+	
+	if (!aFormula.maListEntries.empty())
+	{
+	    aFld.SetItems(aFormula.maListEntries);
+	    int nIndex = aFormula.fDropdownIndex  < aFormula.maListEntries.size()
+		? aFormula.fDropdownIndex : 0;
+	    aFld.SetSelectedItem(aFormula.maListEntries[nIndex]);
+	}
+	
+	rDoc.Insert(*pPaM, SwFmtFld(aFld), 0);
+	return FLD_OK;
+    } else {
+	//@TODO fix: copy pasting here!!!!!!!!!!!!!!
+	//REVIEW: don't let this throught.... sometime I forget to get rid of my proof of concept stuff. Please kindly remind me!!!!!
+
+	String aBookmarkName;
+	WW8PLCFx_Book* pB = pPlcxMan->GetBook();
+	if (pB!=NULL) {
+		WW8_CP currentCP=pF->nSCode;
+		WW8_CP currentLen=pF->nLen;
+
+		USHORT bkmFindIdx;
+		String aBookmarkFind=pB->GetBookmark(currentCP-1, currentCP+currentLen-1, bkmFindIdx);
+
+		if (aBookmarkFind.Len()>0) { 
+			pB->SetStatus(bkmFindIdx, BOOK_FIELD); // mark as consumed by field
+			if (aBookmarkFind.Len()>0) {
+				aBookmarkName=aBookmarkFind;
+			}
+		}
+	}
 
-    rDoc.Insert(*pPaM, SwFmtFld(aFld), 0);
+	if (pB!=NULL && aBookmarkName.Len()==0) {
+		aBookmarkName=pB->GetUniqueBookmarkName(aFormula.sTitle);
+	}
+
+	if (aBookmarkName.Len()>0) {
+	    SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeNoTextFieldBookmark(*pPaM, aBookmarkName, ::rtl::OUString::createFromAscii(ECMA_FORMDROPDOWN));
+	    ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
+	    if (pFieldmark!=NULL) {
+		rtl::OUString sListEntry=rtl::OUString::createFromAscii(ECMA_FORMDROPDOWN_LISTENTRY);
+		std::vector<String>::iterator it=aFormula.maListEntries.begin();
+		for(;it!=aFormula.maListEntries.end();it++) {
+		    pFieldmark->addParam(sListEntry, *it, false);
+		}
+		int nIndex = aFormula.fDropdownIndex  < aFormula.maListEntries.size() ? aFormula.fDropdownIndex : 0;
+		pFieldmark->addParam(ECMA_FORMDROPDOWN_RESULT, nIndex);
+		// set field data here...
+	    }
+	}
+
+	return FLD_OK;
+    }
 
-    return FLD_OK;
 }
 
 void SwWW8ImplReader::DeleteFormImpl()
@@ -2124,11 +2127,18 @@ bool SwWW8ImplReader::ImportFormulaControl(WW8FormulaControl &aFormula,
 
     if((aPic.lcb > 0x3A) && !pDataStream->GetError() )
     {
-        pDataStream->Seek( nPicLocFc + aPic.cbHeader );
+#if 0 // some debug fun; remove this later...
 		int len=aPic.lcb-aPic.cbHeader;
 		char *pBuf=(char*)malloc(len);
 		pDataStream->Read( pBuf, len);
+	static int _h=0;
+	char fname[255];
+	sprintf(fname, "data%03i.data", _h++);
+	FILE *out=fopen(fname, "wb");
+	fwrite(pBuf, len, 1, out);
+	fclose(out);
         pDataStream->Seek( nPicLocFc + aPic.cbHeader );
+#endif
         aFormula.FormulaRead(nWhich,pDataStream);
         bRet = true;
     }
diff --git sw/source/filter/ww8/ww8par5.cxx sw/source/filter/ww8/ww8par5.cxx
index 423e566..d878125 100644
--- sw/source/filter/ww8/ww8par5.cxx
+++ sw/source/filter/ww8/ww8par5.cxx
@@ -96,9 +96,12 @@
 #include "ww8par2.hxx"
 #include "writerhelper.hxx"
 #include "fields.hxx"
+#include <svtools/fltrcfg.hxx>
 
 #include <algorithm> // #i24377#
 
+#define WW_NATIVE_TOC 0
+
 #define MAX_FIELDLEN 64000
 
 #define WW8_TOX_LEVEL_DELIM     ':'
@@ -329,9 +332,11 @@ long SwWW8ImplReader::Read_Book(WW8PLCFManResult*)
 
     //"_Toc*" and "_Hlt*" are unnecessary
     const String* pName = pB->GetName();
+#if !defined(WW_NATIVE_TOC)
     if(    !pName || pName->EqualsIgnoreCaseAscii( "_Toc", 0, 4 )
         || pName->EqualsIgnoreCaseAscii( "_Hlt", 0, 4 ) )
         return 0;
+#endif 
 
     //JP 16.11.98: ToUpper darf auf keinen Fall gemacht werden, weil der
     //Bookmark- name ein Hyperlink-Ziel sein kann!
@@ -673,6 +678,9 @@ sal_uInt16 SwWW8ImplReader::End_Field()
     if (!pF || !pF->EndPosIsFieldEnd())
         return nRet;
 
+    const SvtFilterOptions* pOpt = SvtFilterOptions::Get();
+    sal_Bool bUseEnhFields=(pOpt && pOpt->IsUseEnhancedFields());
+
     ASSERT(!maFieldStack.empty(), "Empty field stack\n");
     if (!maFieldStack.empty())
     {
@@ -684,9 +692,38 @@ sal_uInt16 SwWW8ImplReader::End_Field()
         nRet = maFieldStack.back().mnFieldId;
         switch (nRet)
         {
+	    case 70:
+		if (bUseEnhFields && pPaM!=NULL && pPaM->GetPoint()!=NULL) {
+		    SwPosition aEndPos = *pPaM->GetPoint();
+		    SwPaM aFldPam( maFieldStack.back().GetPtNode(), maFieldStack.back().GetPtCntnt(), aEndPos.nNode, aEndPos.nContent.GetIndex());
+		    SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeFieldBookmark(aFldPam, maFieldStack.back().GetBookmarkName(), ::rtl::OUString::createFromAscii(ECMA_FORMTEXT));
+		    ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
+		    if (pFieldmark!=NULL) {
+			pFieldmark->addParams(maFieldStack.back().getParams());
+		    }
+		}
+		break;
+#if defined(WW_NATIVE_TOC)
+	    case 8: // TOX_INDEX
+	    case 13: // TOX_CONTENT
+	    case 88: // HYPERLINK
+	    case 37: // REF
+		if (pPaM!=NULL && pPaM->GetPoint()!=NULL) {
+		    
+		    SwPosition aEndPos = *pPaM->GetPoint();
+		    SwPaM aFldPam( maFieldStack.back().GetPtNode(), maFieldStack.back().GetPtCntnt(), aEndPos.nNode, aEndPos.nContent.GetIndex());
+		    SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeFieldBookmark(aFldPam, maFieldStack.back().GetBookmarkName(), maFieldStack.back().GetBookmarkType());
+		    ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
+		    if (pFieldmark!=NULL) {
+			pFieldmark->addParams(maFieldStack.back().getParams());
+		    }
+		}
+		break;	  
+#else     
             case 88:
                 pCtrlStck->SetAttr(*pPaM->GetPoint(),RES_TXTATR_INETFMT);
             break;
+#endif
             case 36:
             case 68:
                 //Move outside the section associated with this type of field
@@ -704,6 +741,10 @@ bool AcceptableNestedField(sal_uInt16 nFieldCode)
 {
     switch (nFieldCode)
     {
+#if defined(WW_NATIVE_TOC)
+	case 8:  // allow recursive field in TOC...
+	case 13: // allow recursive field in TOC...
+#endif
         case 36:
         case 68:
         case 79:
@@ -742,6 +783,36 @@ FieldEntry &FieldEntry::operator=(const FieldEntry &rOther) throw()
     return *this;
 }
 
+::rtl::OUString FieldEntry::GetBookmarkName()
+{
+	return sBookmarkName;
+}
+
+::rtl::OUString FieldEntry::GetBookmarkType()
+{
+	return sBookmarkType;
+}
+
+void FieldEntry::SetBookmarkName(::rtl::OUString bookmarkName) 
+{
+    sBookmarkName=bookmarkName;
+}
+
+void FieldEntry::SetBookmarkType(::rtl::OUString bookmarkType)
+{
+    sBookmarkType=bookmarkType;
+}
+
+void FieldEntry::AddParam(::rtl::OUString name, ::rtl::OUString value)
+{
+    maParams.push_back( SwFieldBookmark::ParamPair_t(name, value) );
+}
+
+FieldEntry::Params_t &FieldEntry::getParams() {
+    return maParams;
+}
+
+
 // Read_Field liest ein Feld ein oder, wenn es nicht gelesen werden kann,
 // wird 0 zurueckgegeben, so dass das Feld vom Aufrufer textuell gelesen wird.
 // Returnwert: Gesamtlaenge des Feldes ( zum UEberlesen )
@@ -2066,6 +2137,17 @@ eF_ResT SwWW8ImplReader::Read_F_PgRef( WW8FieldDesc*, String& rStr )
 
     String sName(GetMappedBookmark(sOrigName));
 
+#if defined(WW_NATIVE_TOC)
+    if (1) {
+	::rtl::OUString aBookmarkName=::rtl::OUString::createFromAscii("_REF");
+	maFieldStack.back().SetBookmarkName(aBookmarkName);
+	maFieldStack.back().SetBookmarkType(::rtl::OUString::createFromAscii(ECMA_PAGEREF));
+	maFieldStack.back().AddParam(rtl::OUString(), sName);
+	return FLD_TEXT;
+    }
+#endif
+
+
     SwGetRefField aFld(
         (SwGetRefFieldType*)rDoc.GetSysFldType( RES_GETREFFLD ), sName,
         REF_BOOKMARK, 0, REF_PAGE );
@@ -2729,6 +2811,16 @@ bool wwSectionManager::WillHavePageDescHere(SwNodeIndex aIdx) const
 
 eF_ResT SwWW8ImplReader::Read_F_Tox( WW8FieldDesc* pF, String& rStr )
 {
+#if defined(WW_NATIVE_TOC)
+    if (1) {
+	::rtl::OUString aBookmarkName=::rtl::OUString::createFromAscii("_TOC");
+	maFieldStack.back().SetBookmarkName(aBookmarkName);
+	maFieldStack.back().SetBookmarkType(::rtl::OUString::createFromAscii(ECMA_TOC));
+//     maFieldStack.back().AddParam(::rtl::OUString::createFromAscii("Description"), aFormula.sToolTip);
+	return FLD_TEXT;
+    }
+#endif
+
     if (pF->nLRes < 3)
         return FLD_TEXT;      // ignore (#i25440#)
 
@@ -3246,6 +3338,16 @@ eF_ResT SwWW8ImplReader::Read_F_Shape(WW8FieldDesc* /*pF*/, String& /*rStr*/)
 
 eF_ResT SwWW8ImplReader::Read_F_Hyperlink( WW8FieldDesc* /*pF*/, String& rStr )
 {
+#if defined(WW_NATIVE_TOC)
+    if (1) {
+	::rtl::OUString aBookmarkName=::rtl::OUString::createFromAscii("_HYPERLINK");
+	maFieldStack.back().SetBookmarkName(aBookmarkName);
+	maFieldStack.back().SetBookmarkType(::rtl::OUString::createFromAscii(ECMA_HYPERLINK));
+//     maFieldStack.back().AddParam(::rtl::OUString::createFromAscii("Description"), aFormula.sToolTip);
+	return FLD_TEXT;
+    }
+#endif
+
     String sURL, sTarget, sMark;
     bool bDataImport = false;
     //HYPERLINk "filename" [switches]
diff --git sw/source/ui/docvw/edtwin.cxx sw/source/ui/docvw/edtwin.cxx
index f1a5502..2a2b289 100644
--- sw/source/ui/docvw/edtwin.cxx
+++ sw/source/ui/docvw/edtwin.cxx
@@ -152,6 +152,7 @@
 
 #include <bookmrk.hxx>
 #include <doc.hxx>
+#include <ecmaflds.hxx>
 
 #include "PostItMgr.hxx"
 #include "postit.hxx"
@@ -2238,21 +2239,31 @@ KEYINPUT_CHECKTABLE_INSDEL:
 		    SwFieldBookmark *fieldBM=rSh.IsInFormFieldBookmark(); //$flr refactor!!!
    		    ASSERT(fieldBM!=NULL, "Where is my FieldBookmark??");
 		    if (fieldBM!=NULL) {
-			fieldBM->SetChecked(!fieldBM->IsChecked());
-			SwDocShell* pDocSh = rView.GetDocShell();
-			SwDoc *pDoc=pDocSh->GetDoc();
-			ASSERT(fieldBM->GetOtherBookmarkPos()!=NULL, "where is the otherpos?");
-			if (fieldBM->GetOtherBookmarkPos()!=NULL) {
-			    SwPaM aPaM(fieldBM->GetBookmarkPos(), *fieldBM->GetOtherBookmarkPos());
-			    if (0) {
-				rSh.StartAllAction();  //$flr TODO: understand why this not works
-				pDoc->SetModified(aPaM);
-				rSh.EndAllAction();
-			    } else {
-				rSh.CalcLayout(); // workaround
+			if (fieldBM->isType(ECMA_FORMCHECKBOX)) {
+			    bool isChecked=fieldBM->getParam(ECMA_FORMCHECKBOX_CHECKED).second.compareToAscii("on")==0;
+			    /* printf("checked-before=%i\n", isChecked); */
+			    isChecked=!isChecked; // swap it...
+			    /* printf("checked-after=%i\n", isChecked); */
+			    fieldBM->addParam(rtl::OUString::createFromAscii(ECMA_FORMCHECKBOX_CHECKED), rtl::OUString::createFromAscii(isChecked?"on":"off"));
+			    /* printf("checked-after-add=%i\n", fieldBM->getParam(ECMA_FORMCHECKBOX_CHECKED).second.compareToAscii("on")==0); */
+			    fieldBM->invalidate();
+			}
+			if (fieldBM->isType(ECMA_FORMDROPDOWN)) {
+			    int currentIndex=fieldBM->getParam(ECMA_FORMDROPDOWN_RESULT, "0").second.toInt32();
+			    int entries=0;
+			    for(int i=0;i<fieldBM->getNumOfParams();i++) {
+				SwFieldBookmark::ParamPair_t p=fieldBM->getParam(i);
+				if (p.first.compareToAscii(ECMA_FORMDROPDOWN_LISTENTRY)==0)
+				    entries++;
+			    }
+			    currentIndex++;
+			    if (currentIndex>=entries) {
+				currentIndex=0;
 			    }
+			    fieldBM->addParam(ECMA_FORMDROPDOWN_RESULT, currentIndex);
+			    fieldBM->invalidate();
+			    rSh.InvalidateWindows(rView.GetVisArea());
 			}
-			
 		    }
 //		    rSh.Overwrite(String('X'));
 		    eKeyState = KS_Ende;
@@ -4192,7 +4203,7 @@ void SwEditWin::MouseButtonUp(const MouseEvent& rMEvt)
 
                         SwContentAtPos aCntntAtPos( SwContentAtPos::SW_CLICKFIELD |
 													SwContentAtPos::SW_INETATTR |
-                                                    SwContentAtPos::SW_SMARTTAG );
+                                                    SwContentAtPos::SW_SMARTTAG  | SwContentAtPos::SW_FORMCTRL);
 
 						if( rSh.GetContentAtPos( aDocPt, aCntntAtPos, TRUE ) )
 						{
@@ -4213,7 +4224,29 @@ void SwEditWin::MouseButtonUp(const MouseEvent& rMEvt)
                                     if ( bExecSmarttags && SwSmartTagMgr::Get().IsSmartTagsEnabled() )
                                         rView.ExecSmartTagPopup( aDocPt );
                             }
-							else // if ( SwContentAtPos::SW_INETATTR == aCntntAtPos.eCntntAtPos )
+                            else if ( SwContentAtPos::SW_FORMCTRL == aCntntAtPos.eCntntAtPos )
+                            {
+				ASSERT( aCntntAtPos.aFnd.pFldBookmark!=NULL, "where is my field ptr???");
+				if ( aCntntAtPos.aFnd.pFldBookmark!=NULL) {
+				    SwFieldBookmark *fieldBM=const_cast<SwFieldBookmark *>(aCntntAtPos.aFnd.pFldBookmark);
+				    SwDocShell* pDocSh = rView.GetDocShell();
+				    SwDoc *pDoc=pDocSh->GetDoc();
+				    if (fieldBM->isType(ECMA_FORMCHECKBOX)) {
+					bool isChecked=fieldBM->getParam(ECMA_FORMCHECKBOX_CHECKED).second.compareToAscii("on")==0;
+					isChecked=!isChecked; // swap it...
+					fieldBM->addParam(rtl::OUString::createFromAscii(ECMA_FORMCHECKBOX_CHECKED), rtl::OUString::createFromAscii(isChecked?"on":"off"));
+					fieldBM->invalidate();
+					rSh.InvalidateWindows(rView.GetVisArea());
+				    } else if (fieldBM->isType(ECMA_FORMDROPDOWN)) {
+					rView.ExecFieldPopup( aDocPt, fieldBM );
+					fieldBM->invalidate();
+					rSh.InvalidateWindows(rView.GetVisArea());
+				    } else {
+					// unknown type..
+				    }
+				}
+			    }
+			    else // if ( SwContentAtPos::SW_INETATTR == aCntntAtPos.eCntntAtPos )
 							{
                                 if ( bExecHyperlinks )
                                     rSh.ClickToINetAttr( *(SwFmtINetFmt*)aCntntAtPos.aFnd.pAttr, nFilter );
diff --git sw/source/ui/inc/view.hxx sw/source/ui/inc/view.hxx
index 8a64224..dc4eaef 100644
--- sw/source/ui/inc/view.hxx
+++ sw/source/ui/inc/view.hxx
@@ -94,6 +94,7 @@ struct SwConversionArgs;
 class Graphic;
 class GraphicFilter;
 class SwPostItMgr;
+class SwFieldBookmark;
 
 namespace com{ namespace sun { namespace star {
 	namespace view{ class XSelectionSupplier; }
@@ -465,7 +466,7 @@ public:
 
 	DECL_LINK( SpellError, LanguageType * );
 	BOOL 			ExecSpellPopup( const Point& rPt );
-
+    BOOL            ExecFieldPopup( const Point& rPt, SwFieldBookmark *fieldBM );
     // SMARTTAGS
     BOOL            ExecSmartTagPopup( const Point& rPt );
 
diff --git sw/source/ui/inc/wrtsh.hxx sw/source/ui/inc/wrtsh.hxx
index 0115b26..de13eb9 100644
--- sw/source/ui/inc/wrtsh.hxx
+++ sw/source/ui/inc/wrtsh.hxx
@@ -319,6 +319,9 @@ typedef BOOL (SwWrtShell:: *FNSimpleMove)();
 	void	InsertTableOf(const SwTOXBase& rTOX, const SfxItemSet* pSet = 0);
 	BOOL	UpdateTableOf(const SwTOXBase& rTOX, const SfxItemSet* pSet = 0);
 
+        //  new fields
+	BOOL	UpdateField(SwFieldBookmark &fieldBM);
+
 	// Numerierung und Bullets
     /**
        Turns on numbering or bullets.
diff --git sw/source/ui/uiview/viewling.cxx sw/source/ui/uiview/viewling.cxx
index 8c30848..319b1e0 100644
--- sw/source/ui/uiview/viewling.cxx
+++ sw/source/ui/uiview/viewling.cxx
@@ -114,6 +114,8 @@
 #include <svx/dialogs.hrc>
 
 #include <unomid.h>
+#include <bookmrk.hxx>
+#include <ecmaflds.hxx>
 
 #include <memory>
 
@@ -931,3 +933,138 @@ sal_Bool SwView::ExecSmartTagPopup( const Point& rPt )
     return bRet;
 }
 
+
+
+class SwFieldPopup : public PopupMenu
+{
+public:
+    SwFieldPopup()  {
+	InsertItem(1, ::rtl::OUString::createFromAscii("Hello"));
+    }
+};
+
+class SwFieldListBox : public ListBox
+{
+public:
+    SwFieldListBox(Window* pParent) : ListBox(pParent /*, WB_DROPDOWN*/) {
+    }
+
+    void *GetImplWin() {
+	return NULL; //FIXME!!!
+//	return mpImplWin;
+    }
+
+protected:
+    virtual void LoseFocus() {
+//	printf("ListBox: lose focus!!\n");
+	ListBox::LoseFocus();
+    }    
+
+    virtual void Select() {
+//	printf("SELECT!!! IsTravelSelect=%i\n", IsTravelSelect());
+	ListBox::Select();
+    }
+};
+
+class SwFieldDialog : public Dialog
+{
+private:
+    SwFieldListBox aListBox;
+    Edit aText;
+    int selection;
+
+    DECL_LINK( MyListBoxHandler, ListBox * );
+
+public:
+    SwFieldDialog(Window* parent, SwFieldBookmark *fieldBM) : Dialog(parent, WB_BORDER | WB_SYSTEMWINDOW | WB_NOSHADOW ), aListBox(this), aText(this, WB_RIGHT | WB_READONLY), selection(-1) {
+
+	assert(fieldBM!=NULL);
+	if (fieldBM!=NULL) {
+	    int items=fieldBM->getNumOfParams();	    
+	    for(int i=0;i<items;i++) {
+		SwFieldBookmark::ParamPair_t p=fieldBM->getParam(i);
+		if (p.first.compareToAscii(ECMA_FORMDROPDOWN_LISTENTRY)==0) {
+		    aListBox.InsertEntry(p.second);
+		}
+	    }
+	}
+	Size lbSize=aListBox.GetOptimalSize(WINDOWSIZE_PREFERRED);
+	lbSize.Width()+=50;
+	lbSize.Height()+=20;
+	aListBox.SetSizePixel(lbSize);
+	aListBox.SetSelectHdl( LINK( this, SwFieldDialog, MyListBoxHandler ) );
+	aListBox.Show();
+	aText.SetText(rtl::OUString::createFromAscii("Cancel"));
+	Size tSize=aText.GetOptimalSize(WINDOWSIZE_PREFERRED);
+	aText.SetSizePixel(Size(lbSize.Width(), tSize.Height()));
+	aText.SetPosPixel(Point(0, lbSize.Height()));     	
+	aText.Show();
+	SetSizePixel(Size(lbSize.Width(), lbSize.Height()+tSize.Height()));	
+//	SetSizePixel(Size(200, 200));
+    }
+
+    int getSelection() {
+	return selection;
+    }
+protected:
+    /*
+    virtual void LoseFocus() {
+	printf("lose focus!!\n");
+	Dialog::LoseFocus();
+	printf("close:\n");
+	EndDialog(8);
+    }
+    */
+
+    virtual long PreNotify( NotifyEvent& rNEvt ) {
+	if (rNEvt.GetType() == EVENT_LOSEFOCUS && aListBox.GetImplWin()==rNEvt.GetWindow()) {
+	    EndDialog(8);
+	    return 1;	   
+	}
+	if (rNEvt.GetType() == EVENT_KEYINPUT) {
+//	    printf("PreNotify::KEYINPUT\n");
+	}
+	return Dialog::PreNotify(rNEvt);
+    }
+};
+
+IMPL_LINK( SwFieldDialog, MyListBoxHandler, ListBox *, pBox )
+{
+//    printf("### DROP DOWN SELECT... IsTravelSelect=%i\n", pBox->IsTravelSelect());
+    if (pBox->IsTravelSelect()) {
+	return 0;
+    } else {
+	this->selection=pBox->GetSelectEntryPos();
+	EndDialog(9); //@TODO have meaningfull returns...
+	return 1;
+    }
+}
+
+
+BOOL SwView::ExecFieldPopup( const Point& rPt, SwFieldBookmark *fieldBM )
+{
+    sal_Bool bRet = sal_False;
+    const sal_Bool bOldViewLock = pWrtShell->IsViewLocked();
+    pWrtShell->LockView( sal_True );
+    pWrtShell->Push();
+
+    {
+	bRet=sal_True;
+	const Point aPixPos = GetEditWin().LogicToPixel( rPt );
+
+	SwFieldDialog aFldDlg(pEditWin, fieldBM);
+	aFldDlg.SetPosPixel(pEditWin->OutputToScreenPixel(aPixPos));
+
+	short ret=aFldDlg.Execute();
+	int selection=aFldDlg.getSelection();
+	if (selection>=0) {
+	    fieldBM->addParam(ECMA_FORMDROPDOWN_RESULT, selection);
+	}
+    }
+
+    pWrtShell->Pop( sal_False );
+    pWrtShell->LockView( bOldViewLock );
+
+    return bRet;
+}
+
diff --git sw/source/ui/wrtsh/wrtsh1.cxx sw/source/ui/wrtsh/wrtsh1.cxx
index c49dd4b..efc2e7a 100644
--- sw/source/ui/wrtsh/wrtsh1.cxx
+++ sw/source/ui/wrtsh/wrtsh1.cxx
@@ -1727,6 +1727,12 @@ SwWrtShell::SwWrtShell( SwWrtShell& rSh, Window *_pWin, SwView &rShell )
 
 	SetSfxViewShell( (SfxViewShell *)&rShell );
 	SetFlyMacroLnk( LINK(this, SwWrtShell, ExecFlyMac) );
+
+	// place the cursor on the first field...
+	SwBookmark *pBM=NULL;
+	if (IsFormProtected() && (pBM=GetNextFieldBookmark())!=NULL) {
+	    GotoFieldBookmark(pBM);
+	}
 }
 
 
diff --git sw/source/ui/wrtsh/wrtsh2.cxx sw/source/ui/wrtsh/wrtsh2.cxx
index 8b21ccd..10b7603 100644
--- sw/source/ui/wrtsh/wrtsh2.cxx
+++ sw/source/ui/wrtsh/wrtsh2.cxx
@@ -248,6 +248,13 @@ BOOL SwWrtShell::UpdateTableOf(const SwTOXBase& rTOX, const SfxItemSet* pSet)
     return bResult;
 }
 
+BOOL SwWrtShell::UpdateField(SwFieldBookmark &fieldBM)
+{
+    return SwEditShell::UpdateField(fieldBM);
+}
+
+
+
 	// ein Klick aus das angegebene Feld. Der Cursor steht auf diesem.
 	// Fuehre die vor definierten Aktionen aus.
 
diff --git xmloff/source/text/XMLTextMarkImportContext.cxx xmloff/source/text/XMLTextMarkImportContext.cxx
index 2dece10..21bd4cc 100644
--- xmloff/source/text/XMLTextMarkImportContext.cxx
+++ xmloff/source/text/XMLTextMarkImportContext.cxx
@@ -50,6 +50,7 @@
 
 #include <com/sun/star/text/XFormField.hpp>
 
+#include <../../../sw/inc/ecmaflds.hxx>  // HACKYYYYYYYYY
 
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
@@ -136,6 +137,33 @@ static SvXMLEnumMapEntry __READONLY_DATA lcl_aMarkTypeMap[] =
 	{ XML_TOKEN_INVALID,    		0 },
 };
 
+
+static const char *lcl_getFormFieldmarkName(rtl::OUString &name) 
+{
+    static const char sCheckbox[]=ECMA_FORMCHECKBOX;
+    static const char sFormDropDown[]=ECMA_FORMDROPDOWN;
+    if (name.compareToAscii("msoffice.field.FORMCHECKBOX")==0)
+	return sCheckbox;
+    else if (name.compareToAscii(ECMA_FORMCHECKBOX)==0)
+	return sCheckbox;
+    if (name.compareToAscii(ECMA_FORMDROPDOWN)==0)
+	return sFormDropDown;
+    else
+	return NULL;
+}
+
+static rtl::OUString lcl_getFieldmarkName(rtl::OUString &name) 
+{
+    static const char sFormtext[]=ECMA_FORMTEXT;
+    if (name.compareToAscii("msoffice.field.FORMTEXT")==0)
+	return rtl::OUString::createFromAscii(sFormtext);
+    else if (name.compareToAscii(ECMA_FORMTEXT)==0)
+	return rtl::OUString::createFromAscii(sFormtext);
+    else
+	return name;
+}
+
+
 void XMLTextMarkImportContext::StartElement(
 	const Reference<XAttributeList> & xAttrList)
 {
@@ -187,7 +215,8 @@ void XMLTextMarkImportContext::EndElement()
 				case TypeFieldmark:
 				case TypeBookmark:
 					{
-						bool bImportAsField=((lcl_MarkType)nTmp==TypeFieldmark && sFieldName.compareToAscii("msoffice.field.FORMCHECKBOX")==0); // for now only import FORMCHECKBOX boxes
+					        const char *formFieldmarkName=lcl_getFormFieldmarkName(sFieldName);
+						bool bImportAsField=((lcl_MarkType)nTmp==TypeFieldmark && formFieldmarkName!=NULL); //@TODO handle abbreviation cases..
 						// export point bookmark
 						Reference<XInterface> xIfc=CreateAndInsertMark(GetImport(),
 										(bImportAsField?sAPI_formfieldmark:sAPI_bookmark),
@@ -198,10 +227,8 @@ void XMLTextMarkImportContext::EndElement()
 							if (xIfc.is() && bImportAsField) {
 								// setup fieldmark...
 								Reference< ::com::sun::star::text::XFormField> xFormField(xIfc, UNO_QUERY);
-								xFormField->setType(1); // Checkbox...
+								xFormField->setFieldType(rtl::OUString::createFromAscii(formFieldmarkName)); 
 								if (xFormField.is() && rHelper.hasCurrentFieldCtx()) {
-//									xFormField->setDescription(::rtl::OUString::createFromAscii("HELLO CHECKBOX"));
-//									xFormField->setRes(1); 
 									rHelper.setCurrentFieldParamsTo(xFormField);
 								}
 							}
@@ -248,10 +275,6 @@ void XMLTextMarkImportContext::EndElement()
 								xInsertionCursor, UNO_QUERY);
 
 							bool bImportAsField=((lcl_MarkType)nTmp==TypeFieldmarkEnd && rHelper.hasCurrentFieldCtx());
-							if (bImportAsField) {
-								::rtl::OUString currentFieldType=rHelper.getCurrentFieldType();
-								bImportAsField=currentFieldType.compareToAscii("msoffice.field.FORMTEXT")==0; // for now only import FORMTEXT boxes
-							}
 
 							// insert reference
 							Reference<XInterface> xIfc=CreateAndInsertMark(GetImport(),
@@ -264,10 +287,12 @@ void XMLTextMarkImportContext::EndElement()
 								if (xIfc.is() && bImportAsField) {
 									// setup fieldmark...
 									Reference< ::com::sun::star::text::XFormField> xFormField(xIfc, UNO_QUERY);
-									xFormField->setType(0); // Text
 									if (xFormField.is() && rHelper.hasCurrentFieldCtx()) {
-										rHelper.setCurrentFieldParamsTo(xFormField);
-//									xFormField->setDescription(::rtl::OUString::createFromAscii("HELLO"));
+									    rtl::OUString givenTypeName=rHelper.getCurrentFieldType();
+									    rtl::OUString fieldmarkTypeName=lcl_getFieldmarkName(givenTypeName);
+									    
+									    xFormField->setFieldType(fieldmarkTypeName); 
+									    rHelper.setCurrentFieldParamsTo(xFormField);
 									}
 								}
 								rHelper.popFieldCtx();
diff --git xmloff/source/text/txtimp.cxx xmloff/source/text/txtimp.cxx
index b7f7b23..2112e57 100644
--- xmloff/source/text/txtimp.cxx
+++ xmloff/source/text/txtimp.cxx
@@ -2272,14 +2272,10 @@ void XMLTextImportHelper::setCurrentFieldParamsTo(::com::sun::star::uno::Referen
 	if (!aFieldStack.empty() && xFormField.is()) {
 		field_params_t &params=aFieldStack.top().second;
 		for (field_params_t::iterator i=params.begin();i!=params.end();i++) {
-			rtl::OUString name=i->first;
-			rtl::OUString value=i->second;
-			if (name.compareToAscii("Description")==0){
-				xFormField->setDescription(value);
-			} else if (name.compareToAscii("Result")==0){
-				xFormField->setRes((sal_Int16)value.toInt32());
-			}
-
+		    rtl::OString aOString1 = ::rtl::OUStringToOString (i->first, RTL_TEXTENCODING_UTF8);
+		    rtl::OString aOString2 = ::rtl::OUStringToOString (i->second, RTL_TEXTENCODING_UTF8);
+		    /* printf("param[\"%s\"]=\"%s\"\n", aOString1.getStr(), aOString2.getStr()); */
+		    xFormField->addParam(i->first, i->second, false);
 		}
 	}
 }
diff --git xmloff/source/text/txtparae.cxx xmloff/source/text/txtparae.cxx
index 7e75658..d5454fc 100644
--- xmloff/source/text/txtparae.cxx
+++ xmloff/source/text/txtparae.cxx
@@ -2321,14 +2321,16 @@ void XMLTextParagraphExport::exportTextRangeEnumeration(
 				}
 				Reference< ::com::sun::star::text::XFormField > xFormField(xPropSet->getPropertyValue(sBookmark), UNO_QUERY);
 				if (xFormField.is()) {
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_TYPE, ::rtl::OUString::createFromAscii("msoffice.field.FORMTEXT"));
+					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_TYPE, xFormField->getFieldType());
 				}
 				GetExport().StartElement(XML_NAMESPACE_FIELD, XML_FIELDMARK_START, sal_False);
 				if (xFormField.is()) {
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_NAME, ::rtl::OUString::createFromAscii("Description"));
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_VALUE, xFormField->getDescription());
+				    for(sal_Int16 i=0;i<xFormField->getParamCount();i++) {
+					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_NAME, xFormField->getParamName(i));
+					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_VALUE, xFormField->getParamValue(i));
 					GetExport().StartElement(XML_NAMESPACE_FIELD, XML_PARAM, sal_False);
 					GetExport().EndElement(XML_NAMESPACE_FIELD, XML_PARAM, sal_False);
+				    }
 				}
 				GetExport().EndElement(XML_NAMESPACE_FIELD, XML_FIELDMARK_START, sal_False);
 			}
@@ -2345,27 +2347,16 @@ void XMLTextParagraphExport::exportTextRangeEnumeration(
 				}
 				Reference< ::com::sun::star::text::XFormField > xFormField(xPropSet->getPropertyValue(sBookmark), UNO_QUERY);
 				if (xFormField.is()) {
-					sal_Int16 fftype=xFormField->getType();
-					switch (fftype) {
-						case 1:
-							GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_TYPE, ::rtl::OUString::createFromAscii("msoffice.field.FORMCHECKBOX"));
-						break;
-						default:
-							DBG_ASSERT(false, "hey ---- add your export stuff here!!");
-						break;
-					}
+				    GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_TYPE, xFormField->getFieldType());
 				}
 				GetExport().StartElement(XML_NAMESPACE_FIELD, XML_FIELDMARK, sal_False);
 				if (xFormField.is()) {
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_NAME, ::rtl::OUString::createFromAscii("Description"));
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_VALUE, xFormField->getDescription());
-					GetExport().StartElement(XML_NAMESPACE_FIELD, XML_PARAM, sal_False);
-					GetExport().EndElement(XML_NAMESPACE_FIELD, XML_PARAM, sal_False);
-
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_NAME, ::rtl::OUString::createFromAscii("Result"));
-					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_VALUE, ::rtl::OUString::valueOf((sal_Int32 )xFormField->getRes()));
+				    for(sal_Int16 i=0;i<xFormField->getParamCount();i++) {
+					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_NAME, xFormField->getParamName(i));
+					GetExport().AddAttribute(XML_NAMESPACE_FIELD, XML_VALUE, xFormField->getParamValue(i));
 					GetExport().StartElement(XML_NAMESPACE_FIELD, XML_PARAM, sal_False);
 					GetExport().EndElement(XML_NAMESPACE_FIELD, XML_PARAM, sal_False);
+				    }
 				}
 				GetExport().EndElement(XML_NAMESPACE_FIELD, XML_FIELDMARK, sal_False);
 			}
