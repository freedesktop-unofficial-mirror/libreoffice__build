From 99e3e3231eb9cbb693f886a2860f4e2b783d4471 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 17:07:50 +0200
Subject: [PATCH 784/878] calc-perf-xls-import-cellstyles-fix2.diff

---
 sc/source/filter/excel/excimp8.cxx   |    1 +
 sc/source/filter/excel/read.cxx      |    5 +-
 sc/source/filter/excel/xicontent.cxx |  245 ++++++++++++++++++---------------
 sc/source/filter/excel/xiroot.cxx    |    7 +
 sc/source/filter/inc/xicontent.hxx   |   25 +++-
 sc/source/filter/inc/xiroot.hxx      |    5 +
 6 files changed, 171 insertions(+), 117 deletions(-)

diff --git a/sc/source/filter/excel/excimp8.cxx b/sc/source/filter/excel/excimp8.cxx
index cc5b111..b3a6c62 100644
--- a/sc/source/filter/excel/excimp8.cxx
+++ b/sc/source/filter/excel/excimp8.cxx
@@ -321,6 +321,7 @@ void ImportExcel8::EndSheet( void )
 {
     ImportExcel::EndSheet();
     GetCondFormatManager().Apply();
+    GetValidationManager().Apply();
 }
 
 
diff --git a/sc/source/filter/excel/read.cxx b/sc/source/filter/excel/read.cxx
index 2bb95bd..fa6fa39 100644
--- a/sc/source/filter/excel/read.cxx
+++ b/sc/source/filter/excel/read.cxx
@@ -800,6 +800,7 @@ FltError ImportExcel8::Read( void )
     XclImpLinkManager&      rLinkMgr        = GetLinkManager();
     XclImpObjectManager&    rObjMgr         = GetObjectManager();
     XclImpCondFormatManager& rCondFmtMgr    = GetCondFormatManager();
+    XclImpValidationManager& rValidMgr      = GetValidationManager();
     XclImpPivotTableManager& rPTableMgr     = GetPivotTableManager();
     XclImpWebQueryBuffer&   rWQBfr          = GetWebQueryBuffer();
 
@@ -1201,8 +1202,8 @@ FltError ImportExcel8::Read( void )
                     case EXC_ID_CONDFMT:        rCondFmtMgr.ReadCondfmt( maStrm );      break;
                     case EXC_ID_CF:             rCondFmtMgr.ReadCF( maStrm );           break;
 
-                    case EXC_ID_DVAL:           XclImpValidation::ReadDval( maStrm );   break;
-                    case EXC_ID_DV:             XclImpValidation::ReadDV( maStrm );     break;
+                    case EXC_ID_DVAL:           rValidMgr.ReadDval( maStrm );           break;
+                    case EXC_ID_DV:             rValidMgr.ReadDV( maStrm );             break;
 
                     case EXC_ID_QSI:            rWQBfr.ReadQsi( maStrm );               break;
                     case EXC_ID_WQSTRING:       rWQBfr.ReadWqstring( maStrm );          break;
diff --git a/sc/source/filter/excel/xicontent.cxx b/sc/source/filter/excel/xicontent.cxx
index 840d7c0..738f675 100644
--- a/sc/source/filter/excel/xicontent.cxx
+++ b/sc/source/filter/excel/xicontent.cxx
@@ -699,7 +699,15 @@ void XclImpCondFormatManager::Apply()
 
 // Data Validation ============================================================
 
-void XclImpValidation::ReadDval( XclImpStream& rStrm )
+XclImpValidationManager::DVItem::DVItem( const ScRangeList& rRanges, const ScValidationData& rValidData ) :
+    maRanges(rRanges), maValidData(rValidData) {}
+
+XclImpValidationManager::XclImpValidationManager( const XclImpRoot& rRoot ) :
+    XclImpRoot( rRoot )
+{
+}
+
+void XclImpValidationManager::ReadDval( XclImpStream& rStrm )
 {
     const XclImpRoot& rRoot = rStrm.GetRoot();
     DBG_ASSERT_BIFF( rRoot.GetBiff() == EXC_BIFF8 );
@@ -714,7 +722,7 @@ void XclImpValidation::ReadDval( XclImpStream& rStrm )
     }
 }
 
-void XclImpValidation::ReadDV( XclImpStream& rStrm )
+void XclImpValidationManager::ReadDV( XclImpStream& rStrm )
 {
     const XclImpRoot& rRoot = rStrm.GetRoot();
     DBG_ASSERT_BIFF( rRoot.GetBiff() == EXC_BIFF8 );
@@ -738,130 +746,145 @@ void XclImpValidation::ReadDV( XclImpStream& rStrm )
     rStrm.SetNulSubstChar();    // back to default
 
     // formula(s)
-    if( rStrm.GetRecLeft() > 8 )
+    if ( rStrm.GetRecLeft() <= 8 )
+        // Not enough bytes left in the record.  Bail out.
+        return;
+
+    sal_uInt16 nLen;
+
+    // first formula
+    // string list is single tStr token with NUL separators -> replace them with LF
+    rStrm.SetNulSubstChar( '\n' );
+    ::std::auto_ptr< ScTokenArray > xTokArr1;
+    rStrm >> nLen;
+    rStrm.Ignore( 2 );
+    if( nLen > 0 )
     {
-        sal_uInt16 nLen;
+        const ScTokenArray* pTokArr = 0;
+        rFmlaConv.Reset();
+        rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
+        // formula converter owns pTokArr -> create a copy of the token array
+        if( pTokArr )
+            xTokArr1.reset( pTokArr->Clone() );
+    }
+    rStrm.SetNulSubstChar();    // back to default
 
-        // first formula
-        // string list is single tStr token with NUL separators -> replace them with LF
-        rStrm.SetNulSubstChar( '\n' );
-        ::std::auto_ptr< ScTokenArray > xTokArr1;
-        rStrm >> nLen;
-        rStrm.Ignore( 2 );
-        if( nLen > 0 )
-        {
-            const ScTokenArray* pTokArr = 0;
-            rFmlaConv.Reset();
-            rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
-            // formula converter owns pTokArr -> create a copy of the token array
-            if( pTokArr )
-                xTokArr1.reset( pTokArr->Clone() );
-        }
-        rStrm.SetNulSubstChar();    // back to default
+    // second formula
+    ::std::auto_ptr< ScTokenArray > xTokArr2;
+    rStrm >> nLen;
+    rStrm.Ignore( 2 );
+    if( nLen > 0 )
+    {
+        const ScTokenArray* pTokArr = 0;
+        rFmlaConv.Reset();
+        rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
+        // formula converter owns pTokArr -> create a copy of the token array
+        if( pTokArr )
+            xTokArr2.reset( pTokArr->Clone() );
+    }
 
-        // second formula
-        ::std::auto_ptr< ScTokenArray > xTokArr2;
-        rStrm >> nLen;
-        rStrm.Ignore( 2 );
-        if( nLen > 0 )
-        {
-            const ScTokenArray* pTokArr = 0;
-            rFmlaConv.Reset();
-            rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
-            // formula converter owns pTokArr -> create a copy of the token array
-            if( pTokArr )
-                xTokArr2.reset( pTokArr->Clone() );
-        }
+    // read all cell ranges
+    XclRangeList aXclRanges;
+    rStrm >> aXclRanges;
 
-        // read all cell ranges
-        XclRangeList aXclRanges;
-        rStrm >> aXclRanges;
+    // convert to Calc range list
+    ScRangeList aScRanges;
+    rRoot.GetAddressConverter().ConvertRangeList( aScRanges, aXclRanges, nScTab, true );
 
-        // convert to Calc range list
-        ScRangeList aScRanges;
-        rRoot.GetAddressConverter().ConvertRangeList( aScRanges, aXclRanges, nScTab, true );
+    // only continue if there are valid ranges
+    if ( !aScRanges.Count() )
+        return;
 
-        // only continue if there are valid ranges
-        if( aScRanges.Count() )
-        {
-            bool bIsValid = true;   // valid settings in flags field
+    bool bIsValid = true;   // valid settings in flags field
 
-            ScValidationMode eValMode = SC_VALID_ANY;
-            switch( nFlags & EXC_DV_MODE_MASK )
-            {
-                case EXC_DV_MODE_ANY:       eValMode = SC_VALID_ANY;        break;
-                case EXC_DV_MODE_WHOLE:     eValMode = SC_VALID_WHOLE;      break;
-                case EXC_DV_MODE_DECIMAL:   eValMode = SC_VALID_DECIMAL;    break;
-                case EXC_DV_MODE_LIST:      eValMode = SC_VALID_LIST;       break;
-                case EXC_DV_MODE_DATE:      eValMode = SC_VALID_DATE;       break;
-                case EXC_DV_MODE_TIME:      eValMode = SC_VALID_TIME;       break;
-                case EXC_DV_MODE_TEXTLEN:   eValMode = SC_VALID_TEXTLEN;    break;
-                case EXC_DV_MODE_CUSTOM:    eValMode = SC_VALID_CUSTOM;     break;
-                default:                    bIsValid = false;
-            }
-            rRoot.GetTracer().TraceDVType(eValMode == SC_VALID_CUSTOM);
+    ScValidationMode eValMode = SC_VALID_ANY;
+    switch( nFlags & EXC_DV_MODE_MASK )
+    {
+        case EXC_DV_MODE_ANY:       eValMode = SC_VALID_ANY;        break;
+        case EXC_DV_MODE_WHOLE:     eValMode = SC_VALID_WHOLE;      break;
+        case EXC_DV_MODE_DECIMAL:   eValMode = SC_VALID_DECIMAL;    break;
+        case EXC_DV_MODE_LIST:      eValMode = SC_VALID_LIST;       break;
+        case EXC_DV_MODE_DATE:      eValMode = SC_VALID_DATE;       break;
+        case EXC_DV_MODE_TIME:      eValMode = SC_VALID_TIME;       break;
+        case EXC_DV_MODE_TEXTLEN:   eValMode = SC_VALID_TEXTLEN;    break;
+        case EXC_DV_MODE_CUSTOM:    eValMode = SC_VALID_CUSTOM;     break;
+        default:                    bIsValid = false;
+    }
+    rRoot.GetTracer().TraceDVType(eValMode == SC_VALID_CUSTOM);
 
-            ScConditionMode eCondMode = SC_COND_BETWEEN;
-            switch( nFlags & EXC_DV_COND_MASK )
-            {
-                case EXC_DV_COND_BETWEEN:   eCondMode = SC_COND_BETWEEN;    break;
-                case EXC_DV_COND_NOTBETWEEN:eCondMode = SC_COND_NOTBETWEEN; break;
-                case EXC_DV_COND_EQUAL:     eCondMode = SC_COND_EQUAL;      break;
-                case EXC_DV_COND_NOTEQUAL:  eCondMode = SC_COND_NOTEQUAL;   break;
-                case EXC_DV_COND_GREATER:   eCondMode = SC_COND_GREATER;    break;
-                case EXC_DV_COND_LESS:      eCondMode = SC_COND_LESS;       break;
-                case EXC_DV_COND_EQGREATER: eCondMode = SC_COND_EQGREATER;  break;
-                case EXC_DV_COND_EQLESS:    eCondMode = SC_COND_EQLESS;     break;
-                default:                    bIsValid = false;
-            }
+    ScConditionMode eCondMode = SC_COND_BETWEEN;
+    switch( nFlags & EXC_DV_COND_MASK )
+    {
+        case EXC_DV_COND_BETWEEN:   eCondMode = SC_COND_BETWEEN;    break;
+        case EXC_DV_COND_NOTBETWEEN:eCondMode = SC_COND_NOTBETWEEN; break;
+        case EXC_DV_COND_EQUAL:     eCondMode = SC_COND_EQUAL;      break;
+        case EXC_DV_COND_NOTEQUAL:  eCondMode = SC_COND_NOTEQUAL;   break;
+        case EXC_DV_COND_GREATER:   eCondMode = SC_COND_GREATER;    break;
+        case EXC_DV_COND_LESS:      eCondMode = SC_COND_LESS;       break;
+        case EXC_DV_COND_EQGREATER: eCondMode = SC_COND_EQGREATER;  break;
+        case EXC_DV_COND_EQLESS:    eCondMode = SC_COND_EQLESS;     break;
+        default:                    bIsValid = false;
+    }
 
-            if( bIsValid )
-            {
-                // first range for base address for relative references
-                const ScRange& rScRange = *aScRanges.GetObject( 0 );    // aScRanges is not empty
+    if ( !bIsValid )
+        // No valid validation found.  Bail out.
+        return;
 
-                // process string list of a list validity (convert to list of string tokens)
-                if( xTokArr1.get() && (eValMode == SC_VALID_LIST) && ::get_flag( nFlags, EXC_DV_STRINGLIST ) )
-                    XclTokenArrayHelper::ConvertStringToList( *xTokArr1, '\n', true );
 
-                ScValidationData aValidData( eValMode, eCondMode, xTokArr1.get(), xTokArr2.get(), &rDoc, rScRange.aStart );
+    // first range for base address for relative references
+    const ScRange& rScRange = *aScRanges.GetObject( 0 );    // aScRanges is not empty
 
-                aValidData.SetIgnoreBlank( ::get_flag( nFlags, EXC_DV_IGNOREBLANK ) );
-                aValidData.SetListType( ::get_flagvalue( nFlags, EXC_DV_SUPPRESSDROPDOWN, ValidListType::INVISIBLE, ValidListType::UNSORTED ) );
+    // process string list of a list validity (convert to list of string tokens)
+    if( xTokArr1.get() && (eValMode == SC_VALID_LIST) && ::get_flag( nFlags, EXC_DV_STRINGLIST ) )
+        XclTokenArrayHelper::ConvertStringToList( *xTokArr1, '\n', true );
 
-                // *** prompt box ***
-                if( aPromptTitle.Len() || aPromptMessage.Len() )
-                {
-                    // set any text stored in the record
-                    aValidData.SetInput( aPromptTitle, aPromptMessage );
-                    if( !::get_flag( nFlags, EXC_DV_SHOWPROMPT ) )
-                        aValidData.ResetInput();
-                }
+    maDVItems.push_back(
+        new DVItem(aScRanges, ScValidationData(eValMode, eCondMode, xTokArr1.get(), xTokArr2.get(), &rDoc, rScRange.aStart)));
+    DVItem& rItem = maDVItems.back();
 
-                // *** error box ***
-                ScValidErrorStyle eErrStyle = SC_VALERR_STOP;
-                switch( nFlags & EXC_DV_ERROR_MASK )
-                {
-                    case EXC_DV_ERROR_WARNING:  eErrStyle = SC_VALERR_WARNING;  break;
-                    case EXC_DV_ERROR_INFO:     eErrStyle = SC_VALERR_INFO;     break;
-                }
-                // set texts and error style
-                aValidData.SetError( aErrorTitle, aErrorMessage, eErrStyle );
-                if( !::get_flag( nFlags, EXC_DV_SHOWERROR ) )
-                    aValidData.ResetError();
-
-                // set the handle ID
-                ULONG nHandle = rDoc.AddValidationEntry( aValidData );
-                ScPatternAttr aPattern( rDoc.GetPool() );
-                aPattern.GetItemSet().Put( SfxUInt32Item( ATTR_VALIDDATA, nHandle ) );
-
-                // apply all ranges
-                for( const ScRange* pScRange = aScRanges.First(); pScRange; pScRange = aScRanges.Next() )
-                    rDoc.ApplyPatternAreaTab( pScRange->aStart.Col(), pScRange->aStart.Row(),
-                        pScRange->aEnd.Col(), pScRange->aEnd.Row(), nScTab, aPattern );
-            }
-        }
+    rItem.maValidData.SetIgnoreBlank( ::get_flag( nFlags, EXC_DV_IGNOREBLANK ) );
+    rItem.maValidData.SetListType( ::get_flagvalue( nFlags, EXC_DV_SUPPRESSDROPDOWN, ValidListType::INVISIBLE, ValidListType::UNSORTED ) );
+
+    // *** prompt box ***
+    if( aPromptTitle.Len() || aPromptMessage.Len() )
+    {
+        // set any text stored in the record
+        rItem.maValidData.SetInput( aPromptTitle, aPromptMessage );
+        if( !::get_flag( nFlags, EXC_DV_SHOWPROMPT ) )
+            rItem.maValidData.ResetInput();
+    }
+
+    // *** error box ***
+    ScValidErrorStyle eErrStyle = SC_VALERR_STOP;
+    switch( nFlags & EXC_DV_ERROR_MASK )
+    {
+        case EXC_DV_ERROR_WARNING:  eErrStyle = SC_VALERR_WARNING;  break;
+        case EXC_DV_ERROR_INFO:     eErrStyle = SC_VALERR_INFO;     break;
+    }
+    // set texts and error style
+    rItem.maValidData.SetError( aErrorTitle, aErrorMessage, eErrStyle );
+    if( !::get_flag( nFlags, EXC_DV_SHOWERROR ) )
+        rItem.maValidData.ResetError();
+}
+
+void XclImpValidationManager::Apply()
+{
+    ScDocument& rDoc = GetRoot().GetDoc();
+    DVItemList::iterator itr = maDVItems.begin(), itrEnd = maDVItems.end();
+    for (; itr != itrEnd; ++itr)
+    {
+        DVItem& rItem = *itr;
+        // set the handle ID
+        ULONG nHandle = rDoc.AddValidationEntry( rItem.maValidData );
+        ScPatternAttr aPattern( rDoc.GetPool() );
+        aPattern.GetItemSet().Put( SfxUInt32Item( ATTR_VALIDDATA, nHandle ) );
+
+        // apply all ranges
+        for( const ScRange* pScRange = rItem.maRanges.First(); pScRange; pScRange = rItem.maRanges.Next() )
+            rDoc.ApplyPatternAreaTab( pScRange->aStart.Col(), pScRange->aStart.Row(),
+                pScRange->aEnd.Col(), pScRange->aEnd.Row(), pScRange->aStart.Tab(), aPattern );
     }
+    maDVItems.clear();
 }
 
 // Web queries ================================================================
diff --git a/sc/source/filter/excel/xiroot.cxx b/sc/source/filter/excel/xiroot.cxx
index 7b03d56..e31aa96 100644
--- a/sc/source/filter/excel/xiroot.cxx
+++ b/sc/source/filter/excel/xiroot.cxx
@@ -79,6 +79,7 @@ XclImpRoot::XclImpRoot( XclImpRootData& rImpRootData ) :
         mrImpData.mxLinkMgr.reset( new XclImpLinkManager( GetRoot() ) );
         mrImpData.mxSst.reset( new XclImpSst( GetRoot() ) );
         mrImpData.mxCondFmtMgr.reset( new XclImpCondFormatManager( GetRoot() ) );
+        mrImpData.mxValidMgr.reset( new XclImpValidationManager( GetRoot() ) );
         // TODO still in old RootData (deleted by RootData)
         GetOldRoot().pAutoFilterBuffer = new XclImpAutoFilterBuffer;
         mrImpData.mxWebQueryBfr.reset( new XclImpWebQueryBuffer( GetRoot() ) );
@@ -212,6 +213,12 @@ XclImpCondFormatManager& XclImpRoot::GetCondFormatManager() const
     return *mrImpData.mxCondFmtMgr;
 }
 
+XclImpValidationManager& XclImpRoot::GetValidationManager() const
+{
+    DBG_ASSERT( mrImpData.mxValidMgr.is(), "XclImpRoot::GetValidationManager - invalid call, wrong BIFF" );
+    return *mrImpData.mxValidMgr;
+}
+
 XclImpAutoFilterBuffer& XclImpRoot::GetFilterManager() const
 {
     // TODO still in old RootData
diff --git a/sc/source/filter/inc/xicontent.hxx b/sc/source/filter/inc/xicontent.hxx
index 810c435..ea5777e 100644
--- a/sc/source/filter/inc/xicontent.hxx
+++ b/sc/source/filter/inc/xicontent.hxx
@@ -33,8 +33,10 @@
 #include "xlcontent.hxx"
 #include "xistring.hxx"
 #include "xiroot.hxx"
+#include "validat.hxx"
 
 #include <map>
+#include <boost/ptr_container/ptr_vector.hpp>
 
 /* ============================================================================
 Classes to import the big Excel document contents (related to several cells or
@@ -162,14 +164,29 @@ private:
 
 // Data Validation ============================================================
 
-/** Provides importing validation data and inserting it into a document. */
-class XclImpValidation : ScfNoInstance
+/** Imports validation data. */
+class XclImpValidationManager : protected XclImpRoot
 {
 public:
+    explicit            XclImpValidationManager( const XclImpRoot& rRoot );
+
     /** Reads a DVAL record and sets marks the dropdown arrow control to be ignored. */
-    static void         ReadDval( XclImpStream& rStrm );
+    void                ReadDval( XclImpStream& rStrm );
     /** Reads a DV record and inserts validation data into the document. */
-    static void         ReadDV( XclImpStream& rStrm );
+    void                ReadDV( XclImpStream& rStrm );
+
+    void                Apply();
+private:
+    struct DVItem
+    {
+        ScRangeList         maRanges;
+        ScValidationData    maValidData;
+
+        explicit DVItem ( const ScRangeList& rRanges, const ScValidationData& rValidData );
+    };
+    typedef ::boost::ptr_vector<DVItem> DVItemList;
+
+    DVItemList maDVItems;
 };
 
 // Web queries ================================================================
diff --git a/sc/source/filter/inc/xiroot.hxx b/sc/source/filter/inc/xiroot.hxx
index 3881ada..c500661 100644
--- a/sc/source/filter/inc/xiroot.hxx
+++ b/sc/source/filter/inc/xiroot.hxx
@@ -52,6 +52,7 @@ class XclImpNameManager;
 class XclImpLinkManager;
 class XclImpObjectManager;
 class XclImpCondFormatManager;
+class XclImpValidationManager;
 class XclImpAutoFilterBuffer;
 class XclImpWebQueryBuffer;
 class XclImpPivotTableManager;
@@ -81,6 +82,7 @@ struct XclImpRootData : public XclRootData
     typedef ScfRef< XclImpLinkManager >         XclImpLinkMgrRef;
     typedef ScfRef< XclImpObjectManager >       XclImpObjectMgrRef;
     typedef ScfRef< XclImpCondFormatManager >   XclImpCondFmtMgrRef;
+    typedef ScfRef< XclImpValidationManager >   XclImpValidationMgrRef;
     typedef ScfRef< XclImpWebQueryBuffer >      XclImpWebQueryBfrRef;
     typedef ScfRef< XclImpPivotTableManager >   XclImpPTableMgrRef;
     typedef ScfRef< XclImpPageSettings >        XclImpPageSettRef;
@@ -105,6 +107,7 @@ struct XclImpRootData : public XclRootData
 
     XclImpObjectMgrRef  mxObjMgr;           /// All drawing objects.
     XclImpCondFmtMgrRef mxCondFmtMgr;       /// Conditional formattings.
+    XclImpValidationMgrRef mxValidMgr;      /// Data validation
     XclImpWebQueryBfrRef mxWebQueryBfr;     /// All web queries.
     XclImpPTableMgrRef  mxPTableMgr;        /// All pivot tables and pivot caches.
 
@@ -178,6 +181,8 @@ public:
     XclImpObjectManager& GetObjectManager() const;
     /** Returns the conditional formattings manager. */
     XclImpCondFormatManager& GetCondFormatManager() const;
+
+    XclImpValidationManager& GetValidationManager() const;
     /** Returns the filter manager. */
     XclImpAutoFilterBuffer& GetFilterManager() const;
     /** Returns the web query buffer. */
-- 
1.7.0.1

