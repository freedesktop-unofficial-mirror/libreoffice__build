diff --git writerfilter/inc/dmapper/DomainMapper.hxx writerfilter/inc/dmapper/DomainMapper.hxx
index 3f2ad51..cbf314a 100644
--- writerfilter/inc/dmapper/DomainMapper.hxx
+++ writerfilter/inc/dmapper/DomainMapper.hxx
@@ -66,7 +66,8 @@ using namespace std;
 
 class PropertyMap;
 class DomainMapper_Impl;
-class ListTable;
+class ListsManager;
+class StyleSheetTable;
 
 // different context types require different sprm handling (e.g. names)
 enum SprmType
@@ -137,7 +138,8 @@ public:
     ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > GetCurrentTextRange();
 
     ::rtl::OUString getOrCreateCharStyle( PropertyValueVector_t& rCharProperties );
-    boost::shared_ptr< ListTable > GetListTable( );
+    boost::shared_ptr< ListsManager > GetListTable( );
+    boost::shared_ptr< StyleSheetTable > GetStyleSheetTable( );
 
 private:
     void handleUnderlineType(const sal_Int32 nIntValue, const ::boost::shared_ptr<PropertyMap> pContext);
diff --git writerfilter/source/dmapper/DomainMapper.cxx writerfilter/source/dmapper/DomainMapper.cxx
index 4115846..dadd45e 100644
--- writerfilter/source/dmapper/DomainMapper.cxx
+++ writerfilter/source/dmapper/DomainMapper.cxx
@@ -33,7 +33,7 @@
 #include <dmapper/DomainMapper.hxx>
 #include <DomainMapper_Impl.hxx>
 #include <ConversionHelper.hxx>
-#include <ListTable.hxx>
+#include <NumberingManager.hxx>
 #include <ThemeTable.hxx>
 #include <ModelEventListener.hxx>
 #include <MeasureHandler.hxx>
@@ -1651,7 +1651,9 @@ void DomainMapper::attribute(Id nName, Value & val)
         case NS_ooxml::LN_CT_TabStop_val:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             if (sal::static_int_cast<Id>(nIntValue) == NS_ooxml::LN_Value_ST_TabJc_clear)
+            {
                 m_pImpl->m_aCurrentTabStop.bDeleted = true;
+            }
             else
             {
                 m_pImpl->m_aCurrentTabStop.bDeleted = false;
@@ -1778,8 +1780,11 @@ void DomainMapper::attribute(Id nName, Value & val)
         case NS_ooxml::LN_CT_Ind_hanging:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             if (m_pImpl->GetTopContext())
+            {
+                sal_Int32 nValue = ConversionHelper::convertTwipToMM100( nIntValue );
                 m_pImpl->GetTopContext()->Insert(
-                    PROP_PARA_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100(nIntValue ) ));
+                    PROP_PARA_FIRST_LINE_INDENT, true, uno::makeAny( - nValue ));
+            }
             break;
         case NS_ooxml::LN_CT_Ind_firstLine:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
@@ -2268,20 +2273,26 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         /* WRITERFILTERSTATUS: comment:  */
         {
             //convert the ListTable entry to a NumberingRules propery and apply it
-            sal_Int32 nListId = m_pImpl->GetLFOTable()->GetListID( nIntValue );
-            if(nListId >= 0)
+            ListsManager::Pointer pListTable = m_pImpl->GetListTable();
+            ListDef::Pointer pList = pListTable->GetList( nIntValue );
+            if( pList.get( ) )
             {
-                ListTablePtr pListTable = m_pImpl->GetListTable();
                 if( m_pImpl->IsStyleSheetImport() )
                 {
                     //style sheets cannot have a numbering rule attached
                     StyleSheetPropertyMap* pStyleSheetPropertyMap = dynamic_cast< StyleSheetPropertyMap* >( rContext.get() );
-                    pStyleSheetPropertyMap->SetListId( nListId );
+                    pStyleSheetPropertyMap->SetListId( nIntValue );
                 }
                 else
-                    rContext->Insert( PROP_NUMBERING_RULES, true,
-                                  uno::makeAny(pListTable->GetNumberingRules(nListId)));
-                //TODO: Merge overwrittern numbering levels from LFO table
+                {
+                    uno::Any aRules = uno::makeAny( pList->GetNumberingRules( ) );
+                    rContext->Insert( PROP_NUMBERING_RULES, true, aRules );
+                }
+            }
+            else if ( !m_pImpl->IsStyleSheetImport( ) )
+            {
+                rtl::OUString sNone;
+                rContext->Insert( PROP_NUMBERING_STYLE_NAME, true, uno::makeAny( sNone ) );
             }
         }
         break;
@@ -3915,7 +3926,7 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         
         if( pStyleSheetProperties && pStyleSheetProperties->GetListId() >= 0 )
             rContext->Insert( PROP_NUMBERING_STYLE_NAME, true, uno::makeAny( 
-                        m_pImpl->GetListTable( )->GetStyleName( pStyleSheetProperties->GetListId( ) ) ), false);
+                        ListDef::GetStyleName( pStyleSheetProperties->GetListId( ) ) ), false);
         
         if( pStyleSheetProperties && pStyleSheetProperties->GetListLevel() >= 0 )
             rContext->Insert( PROP_NUMBERING_LEVEL, true, uno::makeAny(pStyleSheetProperties->GetListLevel()), false);
@@ -4136,9 +4147,6 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
     break;
     case NS_ooxml::LN_EG_SectPrContents_formProt: //section protection, only form editing is enabled - unsupported
     break;
-    case NS_ooxml::LN_CT_Lvl_pStyle:
-        //TODO: numbering style should apply current numbering level - not yet supported
-    break;
     default:
         {
 #if OSL_DEBUG_LEVEL > 0
@@ -4528,9 +4536,12 @@ void DomainMapper::table(Id name, writerfilter::Reference<Table>::Pointer_t ref)
         }
         break;
     case NS_rtf::LN_LFOTABLE:
-        /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
-
-        ref->resolve( *m_pImpl->GetLFOTable() );
+        {
+            m_pImpl->GetListTable( )->SetLFOImport( true );
+            ref->resolve( *m_pImpl->GetListTable() );
+            m_pImpl->GetListTable( )->CreateNumberingRules( );
+            m_pImpl->GetListTable( )->SetLFOImport( false );
+        }
         break;
     case NS_ooxml::LN_THEMETABLE:
         ref->resolve ( *m_pImpl->GetThemeTable() );
@@ -4793,6 +4804,7 @@ com::sun::star::style::TabAlign DomainMapper::getTabAlignFromValue(const sal_Int
     {
     case 0:
     case 4: // bar not supported
+    case 5: // num not supported
         return com::sun::star::style::TabAlign_LEFT;
     case 1:
         return com::sun::star::style::TabAlign_CENTER;
@@ -4800,8 +4812,6 @@ com::sun::star::style::TabAlign DomainMapper::getTabAlignFromValue(const sal_Int
         return com::sun::star::style::TabAlign_RIGHT;
     case 3:
         return com::sun::star::style::TabAlign_DECIMAL;
-    default:
-        return com::sun::star::style::TabAlign_DEFAULT;
     }
     return com::sun::star::style::TabAlign_LEFT;
 }
@@ -4841,10 +4851,6 @@ uno::Reference < lang::XMultiServiceFactory > DomainMapper::GetTextFactory() con
 /*-- 12.11.2007 10:41:01---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void  DomainMapper::AddListIDToLFOTable( sal_Int32 nAbstractNumId )
-{
-    m_pImpl->GetLFOTable()->AddListID( nAbstractNumId );
-}
 /*-- 31.01.2008 18:19:44---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -4862,10 +4868,15 @@ uno::Reference< text::XTextRange > DomainMapper::GetCurrentTextRange()
     return pStyleSheets->getOrCreateCharStyle( rCharProperties );
 }
 
-ListTablePtr DomainMapper::GetListTable( )
+ListsManager::Pointer DomainMapper::GetListTable( )
 {
     return m_pImpl->GetListTable( );
 }
 
+StyleSheetTablePtr DomainMapper::GetStyleSheetTable( )
+{
+    return m_pImpl->GetStyleSheetTable( );
+}
+
 } //namespace dmapper
 } //namespace writerfilter
diff --git writerfilter/source/dmapper/DomainMapper_Impl.cxx writerfilter/source/dmapper/DomainMapper_Impl.cxx
index f460109..586b002 100644
--- writerfilter/source/dmapper/DomainMapper_Impl.cxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.cxx
@@ -82,6 +82,7 @@
 
 #if DEBUG
 #include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/style/TabStop.hpp>
 #endif
 
 #include <map>
@@ -704,7 +705,7 @@ void DomainMapper_Impl::IncorporateTabStop( const DeletableTabStop &  rTabStop )
   -----------------------------------------------------------------------*/
 uno::Sequence< style::TabStop > DomainMapper_Impl::GetCurrentTabStopAndClear()
 {
-    uno::Sequence< style::TabStop > aRet( m_aCurrentTabStops.size() );
+    uno::Sequence< style::TabStop > aRet( sal_Int32( m_aCurrentTabStops.size() ) );
     style::TabStop* pArray = aRet.getArray();
     ::std::vector<DeletableTabStop>::const_iterator aIt = m_aCurrentTabStops.begin();
     ::std::vector<DeletableTabStop>::const_iterator aEndIt = m_aCurrentTabStops.end();
@@ -757,11 +758,11 @@ uno::Any DomainMapper_Impl::GetPropertyFromStyleSheet(PropertyIds eId)
 /*-------------------------------------------------------------------------
 
   -----------------------------------------------------------------------*/
-ListTablePtr DomainMapper_Impl::GetListTable()
+ListsManager::Pointer DomainMapper_Impl::GetListTable()
 {
     if(!m_pListTable)
         m_pListTable.reset(
-            new ListTable( m_rDMapper, m_xTextFactory ));
+            new ListsManager( m_rDMapper, m_xTextFactory ));
     return m_pListTable;
 }
 
@@ -1092,6 +1093,18 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
                     aProperties[nLength].Value <<= aDrop;
                     aProperties[nLength].Name = rPropNameSupplier.GetName(PROP_DROP_CAP_FORMAT);
                 }
+#if DEBUG
+                sal_Int32 nLen = aProperties.getLength();
+                for ( sal_Int32 i = 0; i < nLen; i++ )
+                {
+                    uno::Any aValue = aProperties[i].Value;
+                    uno::Sequence< style::TabStop > aTabs;
+                    if ( aValue >>= aTabs )
+                    {
+                        fprintf( stderr, "Found tab stops\n" );
+                    }
+                }
+#endif
                 uno::Reference< text::XTextRange > xTextRange =
                     xTextAppend->finishParagraph( aProperties );
                 getTableManager( ).handle(xTextRange);
diff --git writerfilter/source/dmapper/DomainMapper_Impl.hxx writerfilter/source/dmapper/DomainMapper_Impl.hxx
index 5f33e30..8dbfa4e 100644
--- writerfilter/source/dmapper/DomainMapper_Impl.hxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.hxx
@@ -48,8 +48,7 @@
 #include <DomainMapperTableManager.hxx>
 #include <PropertyMap.hxx>
 #include <FontTable.hxx>
-#include <ListTable.hxx>
-#include <LFOTable.hxx>
+#include <NumberingManager.hxx>
 #include <StyleSheetTable.hxx>
 #include <ThemeTable.hxx>
 #include <SettingsTable.hxx>
@@ -306,8 +305,7 @@ private:
     PropertyStack           m_aPropertyStacks[NUMBER_OF_CONTEXTS];
     ContextStack            m_aContextStack;
     FontTablePtr            m_pFontTable;
-    ListTablePtr            m_pListTable;
-    LFOTablePtr             m_pLFOTable;
+    ListsManager::Pointer   m_pListTable;
     StyleSheetTablePtr      m_pStyleSheetTable;
     ThemeTablePtr           m_pThemeTable;
     GraphicImportPtr        m_pGraphicImport;
@@ -434,13 +432,7 @@ public:
             m_pStyleSheetTable.reset(new StyleSheetTable( m_rDMapper, m_xTextDocument ));
         return m_pStyleSheetTable;
     }
-    ListTablePtr GetListTable();
-    LFOTablePtr GetLFOTable()
-    {
-        if(!m_pLFOTable)
-            m_pLFOTable.reset( new LFOTable );
-        return m_pLFOTable;
-    }
+    ListsManager::Pointer GetListTable();
     ThemeTablePtr GetThemeTable()
     {
         if(!m_pThemeTable)
diff --git writerfilter/source/dmapper/LFOTable.cxx writerfilter/source/dmapper/LFOTable.cxx
deleted file mode 100644
index 8008f2a..0000000
--- writerfilter/source/dmapper/LFOTable.cxx
+++ /dev/null
@@ -1,609 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: LFOTable.cxx,v $
- * $Revision: 1.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <LFOTable.hxx>
-#include <doctok/resourceids.hxx>
-#include <vector>
-
-namespace writerfilter {
-namespace dmapper
-{
-using namespace std;
-using namespace writerfilter;
-
-struct LFOLevel
-{
-    sal_Int32           nIStartAt;
-    sal_Int32           nFStartAt;
-    sal_Int32           nFFormatting;
-    ::rtl::OUString     sILevel;
-
-    LFOLevel() :
-        nIStartAt(-1)
-        ,nFStartAt(-1)
-        ,nFFormatting(-1)
-        {}
-};
-typedef ::boost::shared_ptr< LFOLevel > LFOLevelPtr;
-struct LFOEntry
-{
-    sal_Int32               nListId;
-    sal_Int32               nCLFOLevel;
-    vector< LFOLevelPtr >      aLFOLevels; //usually empty
-
-    LFOEntry() :
-        nListId(-1)
-        ,nCLFOLevel(-1)
-        {}
-};
-typedef ::boost::shared_ptr<LFOEntry> LFOEntryPtr;
-
-struct LFOTable_Impl
-{
-    ::std::vector< LFOEntryPtr >    m_aLFOEntries; //properties of each level
-    LFOEntryPtr                     m_pCurrentEntry;
-
-};
-/*-- 27.06.2006 15:13:03---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-LFOTable::LFOTable() :
-    m_pImpl( new LFOTable_Impl )
-{
-}
-/*-- 27.06.2006 15:13:03---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-LFOTable::~LFOTable()
-{
-}
-/*-- 27.06.2006 15:13:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::attribute(Id Name, Value & val)
-{
-    OSL_ENSURE(m_pImpl->m_pCurrentEntry, "no current entry to write to");
-    if(!m_pImpl->m_pCurrentEntry)
-        return;
-
-    int nIntValue = val.getInt();
-    /* WRITERFILTERSTATUS: table: LFOTable_attributedata */
-    switch( Name )
-    {
-//        case NS_rtf::LN_ISTD: break;//index of applied style
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_ISTARTAT:
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_ILVL:
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_FSTARTAT:
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_FFORMATTING:
-            if(m_pImpl->m_pCurrentEntry->aLFOLevels.size())
-            {
-                vector< LFOLevelPtr >::reverse_iterator aEndIter = m_pImpl->m_pCurrentEntry->aLFOLevels.rbegin();
-                switch( Name )
-                {
-                    case NS_rtf::LN_ISTARTAT:
-                        (*aEndIter)->nIStartAt = nIntValue;
-                    break;
-                    case NS_rtf::LN_ILVL:
-                        (*aEndIter)->sILevel = val.getString();
-                    break;
-                    case NS_rtf::LN_FSTARTAT:
-                        (*aEndIter)->nFStartAt = nIntValue;
-                    break;
-                    case NS_rtf::LN_FFORMATTING:
-                        (*aEndIter)->nFFormatting = nIntValue;
-                    break;
-                    default:;
-                }
-            }
-        break;
-//        case NS_rtf::LN_NFC: break;
-//        case NS_rtf::LN_JC: break;
-//        case NS_rtf::LN_FLEGAL: break;
-//        case NS_rtf::LN_FNORESTART: break;
-//        case NS_rtf::LN_FPREV: break;
-//        case NS_rtf::LN_FPREVSPACE: break;
-//        case NS_rtf::LN_FWORD6: break;
-//        case NS_rtf::LN_UNUSED5_7: break;
-//        case NS_rtf::LN_RGBXCHNUMS: break;
-//        case NS_rtf::LN_IXCHFOLLOW: break;
-//        case NS_rtf::LN_DXASPACE: break;
-//        case NS_rtf::LN_DXAINDENT: break;
-//        case NS_rtf::LN_CBGRPPRLCHPX: break;
-//        case NS_rtf::LN_CBGRPPRLPAPX: break;
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_LSID:
-            m_pImpl->m_pCurrentEntry->nListId = nIntValue;
-        break;
-//        case NS_rtf::LN_TPLC: break;
-//        case NS_rtf::LN_RGISTD: break;
-//        case NS_rtf::LN_FSIMPLELIST: break;
-//        case NS_rtf::LN_FRESTARTHDN: break;
-//        case NS_rtf::LN_UNSIGNED26_2: break;
-//        case NS_rtf::LN_UNSIGNED4_6: break;
-        /* WRITERFILTERSTATUS: done: 1, planned: 0, spent: 0 */
-        case NS_rtf::LN_UNUSED4:
-        /* WRITERFILTERSTATUS: done: 1, planned: 0, spent: 0 */
-        case NS_rtf::LN_UNUSED8:
-            // as the names state they are unused
-        break;
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_CLFOLVL:
-            m_pImpl->m_pCurrentEntry->nCLFOLevel = nIntValue;
-        break;
-//        case NS_rtf::LN_CBFFNM1: break;
-//        case NS_rtf::LN_PRQ: break;
-//        case NS_rtf::LN_FTRUETYPE: break;
-//        case NS_rtf::LN_UNUSED1_3: break;
-//        case NS_rtf::LN_FF: break;
-//        case NS_rtf::LN_UNUSED1_7: break;
-//        case NS_rtf::LN_WWEIGHT: break;
-//        case NS_rtf::LN_CHS: break;
-//        case NS_rtf::LN_IXCHSZALT: break;
-//        case NS_rtf::LN_PANOSE: break;
-//        case NS_rtf::LN_FS: break;
-//        case NS_rtf::LN_STI: break;
-//        case NS_rtf::LN_FSCRATCH: break;
-//        case NS_rtf::LN_FINVALHEIGHT: break;
-//        case NS_rtf::LN_FHASUPE: break;
-//        case NS_rtf::LN_FMASSCOPY: break;
-//        case NS_rtf::LN_SGC: break;
-//        case NS_rtf::LN_ISTDBASE: break;
-//        case NS_rtf::LN_CUPX: break;
-//        case NS_rtf::LN_ISTDNEXT: break;
-//        case NS_rtf::LN_BCHUPE: break;
-//        case NS_rtf::LN_FAUTOREDEF: break;
-//        case NS_rtf::LN_FHIDDEN: break;
-//        case NS_rtf::LN_UNUSED8_3: break;
-//        case NS_rtf::LN_CSTD: break;
-//        case NS_rtf::LN_CBSTDBASEINFILE: break;
-//        case NS_rtf::LN_FSTDSTYLENAMESWRITTEN: break;
-//        case NS_rtf::LN_UNUSED4_2: break;
-//        case NS_rtf::LN_STIMAXWHENSAVED: break;
-//        case NS_rtf::LN_ISTDMAXFIXEDWHENSAVED: break;
-//        case NS_rtf::LN_NVERBUILTINNAMESWHENSAVED: break;
-//        case NS_rtf::LN_RGFTCSTANDARDCHPSTSH: break;
-//        case NS_rtf::LN_WIDENT: break;
-//        case NS_rtf::LN_NFIB: break;
-//        case NS_rtf::LN_NPRODUCT: break;
-//        case NS_rtf::LN_LID: break;
-//        case NS_rtf::LN_PNNEXT: break;
-//        case NS_rtf::LN_FDOT: break;
-//        case NS_rtf::LN_FGLSY: break;
-//        case NS_rtf::LN_FCOMPLEX: break;
-//        case NS_rtf::LN_FHASPIC: break;
-//        case NS_rtf::LN_CQUICKSAVES: break;
-//        case NS_rtf::LN_FENCRYPTED: break;
-//        case NS_rtf::LN_FWHICHTBLSTM: break;
-//        case NS_rtf::LN_FREADONLYRECOMMENDED: break;
-//        case NS_rtf::LN_FWRITERESERVATION: break;
-//        case NS_rtf::LN_FEXTCHAR: break;
-//        case NS_rtf::LN_FLOADOVERRIDE: break;
-//        case NS_rtf::LN_FFAREAST: break;
-//        case NS_rtf::LN_FCRYPTO: break;
-//        case NS_rtf::LN_NFIBBACK: break;
-//        case NS_rtf::LN_LKEY: break;
-//        case NS_rtf::LN_ENVR: break;
-//        case NS_rtf::LN_FMAC: break;
-//        case NS_rtf::LN_FEMPTYSPECIAL: break;
-//        case NS_rtf::LN_FLOADOVERRIDEPAGE: break;
-//        case NS_rtf::LN_FFUTURESAVEDUNDO: break;
-//        case NS_rtf::LN_FWORD97SAVED: break;
-//        case NS_rtf::LN_FSPARE0: break;
-//        case NS_rtf::LN_CHSTABLES: break;
-//        case NS_rtf::LN_FCMIN: break;
-//        case NS_rtf::LN_FCMAC: break;
-//        case NS_rtf::LN_CSW: break;
-//        case NS_rtf::LN_WMAGICCREATED: break;
-//        case NS_rtf::LN_WMAGICREVISED: break;
-//        case NS_rtf::LN_WMAGICCREATEDPRIVATE: break;
-//        case NS_rtf::LN_WMAGICREVISEDPRIVATE: break;
-//        case NS_rtf::LN_PNFBPCHPFIRST_W6: break;
-//        case NS_rtf::LN_PNCHPFIRST_W6: break;
-//        case NS_rtf::LN_CPNBTECHP_W6: break;
-//        case NS_rtf::LN_PNFBPPAPFIRST_W6: break;
-//        case NS_rtf::LN_PNPAPFIRST_W6: break;
-//        case NS_rtf::LN_CPNBTEPAP_W6: break;
-//        case NS_rtf::LN_PNFBPLVCFIRST_W6: break;
-//        case NS_rtf::LN_PNLVCFIRST_W6: break;
-//        case NS_rtf::LN_CPNBTELVC_W6: break;
-//        case NS_rtf::LN_LIDFE: break;
-//        case NS_rtf::LN_CLW: break;
-//        case NS_rtf::LN_CBMAC: break;
-//        case NS_rtf::LN_LPRODUCTCREATED: break;
-//        case NS_rtf::LN_LPRODUCTREVISED: break;
-//        case NS_rtf::LN_CCPTEXT: break;
-//        case NS_rtf::LN_CCPFTN: break;
-//        case NS_rtf::LN_CCPHDD: break;
-//        case NS_rtf::LN_CCPMCR: break;
-//        case NS_rtf::LN_CCPATN: break;
-//        case NS_rtf::LN_CCPEDN: break;
-//        case NS_rtf::LN_CCPTXBX: break;
-//        case NS_rtf::LN_CCPHDRTXBX: break;
-//        case NS_rtf::LN_PNFBPCHPFIRST: break;
-//        case NS_rtf::LN_PNCHPFIRST: break;
-//        case NS_rtf::LN_CPNBTECHP: break;
-//        case NS_rtf::LN_PNFBPPAPFIRST: break;
-//        case NS_rtf::LN_PNPAPFIRST: break;
-//        case NS_rtf::LN_CPNBTEPAP: break;
-//        case NS_rtf::LN_PNFBPLVCFIRST: break;
-//        case NS_rtf::LN_PNLVCFIRST: break;
-//        case NS_rtf::LN_CPNBTELVC: break;
-//        case NS_rtf::LN_FCISLANDFIRST: break;
-//        case NS_rtf::LN_FCISLANDLIM: break;
-//        case NS_rtf::LN_CFCLCB: break;
-//        case NS_rtf::LN_FCSTSHFORIG: break;
-//        case NS_rtf::LN_LCBSTSHFORIG: break;
-//        case NS_rtf::LN_FCSTSHF: break;
-//        case NS_rtf::LN_LCBSTSHF: break;
-//        case NS_rtf::LN_FCPLCFFNDREF: break;
-//        case NS_rtf::LN_LCBPLCFFNDREF: break;
-//        case NS_rtf::LN_FCPLCFFNDTXT: break;
-//        case NS_rtf::LN_LCBPLCFFNDTXT: break;
-//        case NS_rtf::LN_FCPLCFANDREF: break;
-//        case NS_rtf::LN_LCBPLCFANDREF: break;
-//        case NS_rtf::LN_FCPLCFANDTXT: break;
-//        case NS_rtf::LN_LCBPLCFANDTXT: break;
-//        case NS_rtf::LN_FCPLCFSED: break;
-//        case NS_rtf::LN_LCBPLCFSED: break;
-//        case NS_rtf::LN_FCPLCFPAD: break;
-//        case NS_rtf::LN_LCBPLCFPAD: break;
-//        case NS_rtf::LN_FCPLCFPHE: break;
-//        case NS_rtf::LN_LCBPLCFPHE: break;
-//        case NS_rtf::LN_FCSTTBFGLSY: break;
-//        case NS_rtf::LN_LCBSTTBFGLSY: break;
-//        case NS_rtf::LN_FCPLCFGLSY: break;
-//        case NS_rtf::LN_LCBPLCFGLSY: break;
-//        case NS_rtf::LN_FCPLCFHDD: break;
-//        case NS_rtf::LN_LCBPLCFHDD: break;
-//        case NS_rtf::LN_FCPLCFBTECHPX: break;
-//        case NS_rtf::LN_LCBPLCFBTECHPX: break;
-//        case NS_rtf::LN_FCPLCFBTEPAPX: break;
-//        case NS_rtf::LN_LCBPLCFBTEPAPX: break;
-//        case NS_rtf::LN_FCPLCFSEA: break;
-//        case NS_rtf::LN_LCBPLCFSEA: break;
-//        case NS_rtf::LN_FCSTTBFFFN: break;
-//        case NS_rtf::LN_LCBSTTBFFFN: break;
-//        case NS_rtf::LN_FCPLCFFLDMOM: break;
-//        case NS_rtf::LN_LCBPLCFFLDMOM: break;
-//        case NS_rtf::LN_FCPLCFFLDHDR: break;
-//        case NS_rtf::LN_LCBPLCFFLDHDR: break;
-//        case NS_rtf::LN_FCPLCFFLDFTN: break;
-//        case NS_rtf::LN_LCBPLCFFLDFTN: break;
-//        case NS_rtf::LN_FCPLCFFLDATN: break;
-//        case NS_rtf::LN_LCBPLCFFLDATN: break;
-//        case NS_rtf::LN_FCPLCFFLDMCR: break;
-//        case NS_rtf::LN_LCBPLCFFLDMCR: break;
-//        case NS_rtf::LN_FCSTTBFBKMK: break;
-//        case NS_rtf::LN_LCBSTTBFBKMK: break;
-//        case NS_rtf::LN_FCPLCFBKF: break;
-//        case NS_rtf::LN_LCBPLCFBKF: break;
-//        case NS_rtf::LN_FCPLCFBKL: break;
-//        case NS_rtf::LN_LCBPLCFBKL: break;
-//        case NS_rtf::LN_FCCMDS: break;
-//        case NS_rtf::LN_LCBCMDS: break;
-//        case NS_rtf::LN_FCPLCMCR: break;
-//        case NS_rtf::LN_LCBPLCMCR: break;
-//        case NS_rtf::LN_FCSTTBFMCR: break;
-//        case NS_rtf::LN_LCBSTTBFMCR: break;
-//        case NS_rtf::LN_FCPRDRVR: break;
-//        case NS_rtf::LN_LCBPRDRVR: break;
-//        case NS_rtf::LN_FCPRENVPORT: break;
-//        case NS_rtf::LN_LCBPRENVPORT: break;
-//        case NS_rtf::LN_FCPRENVLAND: break;
-//        case NS_rtf::LN_LCBPRENVLAND: break;
-//        case NS_rtf::LN_FCWSS: break;
-//        case NS_rtf::LN_LCBWSS: break;
-//        case NS_rtf::LN_FCDOP: break;
-//        case NS_rtf::LN_LCBDOP: break;
-//        case NS_rtf::LN_FCSTTBFASSOC: break;
-//        case NS_rtf::LN_LCBSTTBFASSOC: break;
-//        case NS_rtf::LN_FCCLX: break;
-//        case NS_rtf::LN_LCBCLX: break;
-//        case NS_rtf::LN_FCPLCFPGDFTN: break;
-//        case NS_rtf::LN_LCBPLCFPGDFTN: break;
-//        case NS_rtf::LN_FCAUTOSAVESOURCE: break;
-//        case NS_rtf::LN_LCBAUTOSAVESOURCE: break;
-//        case NS_rtf::LN_FCGRPXSTATNOWNERS: break;
-//        case NS_rtf::LN_LCBGRPXSTATNOWNERS: break;
-//        case NS_rtf::LN_FCSTTBFATNBKMK: break;
-//        case NS_rtf::LN_LCBSTTBFATNBKMK: break;
-//        case NS_rtf::LN_FCPLCDOAMOM: break;
-//        case NS_rtf::LN_LCBPLCDOAMOM: break;
-//        case NS_rtf::LN_FCPLCDOAHDR: break;
-//        case NS_rtf::LN_LCBPLCDOAHDR: break;
-//        case NS_rtf::LN_FCPLCSPAMOM: break;
-//        case NS_rtf::LN_LCBPLCSPAMOM: break;
-//        case NS_rtf::LN_FCPLCSPAHDR: break;
-//        case NS_rtf::LN_LCBPLCSPAHDR: break;
-//        case NS_rtf::LN_FCPLCFATNBKF: break;
-//        case NS_rtf::LN_LCBPLCFATNBKF: break;
-//        case NS_rtf::LN_FCPLCFATNBKL: break;
-//        case NS_rtf::LN_LCBPLCFATNBKL: break;
-//        case NS_rtf::LN_FCPMS: break;
-//        case NS_rtf::LN_LCBPMS: break;
-//        case NS_rtf::LN_FCFORMFLDSTTBF: break;
-//        case NS_rtf::LN_LCBFORMFLDSTTBF: break;
-//        case NS_rtf::LN_FCPLCFENDREF: break;
-//        case NS_rtf::LN_LCBPLCFENDREF: break;
-//        case NS_rtf::LN_FCPLCFENDTXT: break;
-//        case NS_rtf::LN_LCBPLCFENDTXT: break;
-//        case NS_rtf::LN_FCPLCFFLDEDN: break;
-//        case NS_rtf::LN_LCBPLCFFLDEDN: break;
-//        case NS_rtf::LN_FCPLCFPGDEDN: break;
-//        case NS_rtf::LN_LCBPLCFPGDEDN: break;
-//        case NS_rtf::LN_FCDGGINFO: break;
-//        case NS_rtf::LN_LCBDGGINFO: break;
-//        case NS_rtf::LN_FCSTTBFRMARK: break;
-//        case NS_rtf::LN_LCBSTTBFRMARK: break;
-//        case NS_rtf::LN_FCSTTBFCAPTION: break;
-//        case NS_rtf::LN_LCBSTTBFCAPTION: break;
-//        case NS_rtf::LN_FCSTTBFAUTOCAPTION: break;
-//        case NS_rtf::LN_LCBSTTBFAUTOCAPTION: break;
-//        case NS_rtf::LN_FCPLCFWKB: break;
-//        case NS_rtf::LN_LCBPLCFWKB: break;
-//        case NS_rtf::LN_FCPLCFSPL: break;
-//        case NS_rtf::LN_LCBPLCFSPL: break;
-//        case NS_rtf::LN_FCPLCFTXBXTXT: break;
-//        case NS_rtf::LN_LCBPLCFTXBXTXT: break;
-//        case NS_rtf::LN_FCPLCFFLDTXBX: break;
-//        case NS_rtf::LN_LCBPLCFFLDTXBX: break;
-//        case NS_rtf::LN_FCPLCFHDRTXBXTXT: break;
-//        case NS_rtf::LN_LCBPLCFHDRTXBXTXT: break;
-//        case NS_rtf::LN_FCPLCFFLDHDRTXBX: break;
-//        case NS_rtf::LN_LCBPLCFFLDHDRTXBX: break;
-//        case NS_rtf::LN_FCSTWUSER: break;
-//        case NS_rtf::LN_LCBSTWUSER: break;
-//        case NS_rtf::LN_FCSTTBTTMBD: break;
-//        case NS_rtf::LN_LCBSTTBTTMBD: break;
-//        case NS_rtf::LN_FCUNUSED: break;
-//        case NS_rtf::LN_LCBUNUSED: break;
-//        case NS_rtf::LN_FCPGDMOTHER: break;
-//        case NS_rtf::LN_LCBPGDMOTHER: break;
-//        case NS_rtf::LN_FCBKDMOTHER: break;
-//        case NS_rtf::LN_LCBBKDMOTHER: break;
-//        case NS_rtf::LN_FCPGDFTN: break;
-//        case NS_rtf::LN_LCBPGDFTN: break;
-//        case NS_rtf::LN_FCBKDFTN: break;
-//        case NS_rtf::LN_LCBBKDFTN: break;
-//        case NS_rtf::LN_FCPGDEDN: break;
-//        case NS_rtf::LN_LCBPGDEDN: break;
-//        case NS_rtf::LN_FCBKDEDN: break;
-//        case NS_rtf::LN_LCBBKDEDN: break;
-//        case NS_rtf::LN_FCSTTBFINTLFLD: break;
-//        case NS_rtf::LN_LCBSTTBFINTLFLD: break;
-//        case NS_rtf::LN_FCROUTESLIP: break;
-//        case NS_rtf::LN_LCBROUTESLIP: break;
-//        case NS_rtf::LN_FCSTTBSAVEDBY: break;
-//        case NS_rtf::LN_LCBSTTBSAVEDBY: break;
-//        case NS_rtf::LN_FCSTTBFNM: break;
-//        case NS_rtf::LN_LCBSTTBFNM: break;
-//        case NS_rtf::LN_FCPLCFLST: break;
-//        case NS_rtf::LN_LCBPLCFLST: break;
-//        case NS_rtf::LN_FCPLFLFO: break;
-//        case NS_rtf::LN_LCBPLFLFO: break;
-//        case NS_rtf::LN_FCPLCFTXBXBKD: break;
-//        case NS_rtf::LN_LCBPLCFTXBXBKD: break;
-//        case NS_rtf::LN_FCPLCFTXBXHDRBKD: break;
-//        case NS_rtf::LN_LCBPLCFTXBXHDRBKD: break;
-//        case NS_rtf::LN_FCDOCUNDO: break;
-//        case NS_rtf::LN_LCBDOCUNDO: break;
-//        case NS_rtf::LN_FCRGBUSE: break;
-//        case NS_rtf::LN_LCBRGBUSE: break;
-//        case NS_rtf::LN_FCUSP: break;
-//        case NS_rtf::LN_LCBUSP: break;
-//        case NS_rtf::LN_FCUSKF: break;
-//        case NS_rtf::LN_LCBUSKF: break;
-//        case NS_rtf::LN_FCPLCUPCRGBUSE: break;
-//        case NS_rtf::LN_LCBPLCUPCRGBUSE: break;
-//        case NS_rtf::LN_FCPLCUPCUSP: break;
-//        case NS_rtf::LN_LCBPLCUPCUSP: break;
-//        case NS_rtf::LN_FCSTTBGLSYSTYLE: break;
-//        case NS_rtf::LN_LCBSTTBGLSYSTYLE: break;
-//        case NS_rtf::LN_FCPLGOSL: break;
-//        case NS_rtf::LN_LCBPLGOSL: break;
-//        case NS_rtf::LN_FCPLCOCX: break;
-//        case NS_rtf::LN_LCBPLCOCX: break;
-//        case NS_rtf::LN_FCPLCFBTELVC: break;
-//        case NS_rtf::LN_LCBPLCFBTELVC: break;
-//        case NS_rtf::LN_DWLOWDATETIME: break;
-//        case NS_rtf::LN_DWHIGHDATETIME: break;
-//        case NS_rtf::LN_FCPLCFLVC: break;
-//        case NS_rtf::LN_LCBPLCFLVC: break;
-//        case NS_rtf::LN_FCPLCASUMY: break;
-//        case NS_rtf::LN_LCBPLCASUMY: break;
-//        case NS_rtf::LN_FCPLCFGRAM: break;
-//        case NS_rtf::LN_LCBPLCFGRAM: break;
-//        case NS_rtf::LN_FCSTTBLISTNAMES: break;
-//        case NS_rtf::LN_LCBSTTBLISTNAMES: break;
-//        case NS_rtf::LN_FCSTTBFUSSR: break;
-//        case NS_rtf::LN_LCBSTTBFUSSR: break;
-//        case NS_rtf::LN_FN: break;
-//        case NS_rtf::LN_FCSEPX: break;
-//        case NS_rtf::LN_FNMPR: break;
-//        case NS_rtf::LN_FCMPR: break;
-//        case NS_rtf::LN_ICOFORE: break;
-//        case NS_rtf::LN_ICOBACK: break;
-//        case NS_rtf::LN_IPAT: break;
-//        case NS_rtf::LN_SHDFORECOLOR: break;
-//        case NS_rtf::LN_SHDBACKCOLOR: break;
-//        case NS_rtf::LN_SHDPATTERN: break;
-//        case NS_rtf::LN_DPTLINEWIDTH: break;
-//        case NS_rtf::LN_BRCTYPE: break;
-//        case NS_rtf::LN_ICO: break;
-//        case NS_rtf::LN_DPTSPACE: break;
-//        case NS_rtf::LN_FSHADOW: break;
-//        case NS_rtf::LN_FFRAME: break;
-//        case NS_rtf::LN_UNUSED2_15: break;
-//        case NS_rtf::LN_FFIRSTMERGED: break;
-//        case NS_rtf::LN_FMERGED: break;
-//        case NS_rtf::LN_FVERTICAL: break;
-//        case NS_rtf::LN_FBACKWARD: break;
-//        case NS_rtf::LN_FROTATEFONT: break;
-//        case NS_rtf::LN_FVERTMERGE: break;
-//        case NS_rtf::LN_FVERTRESTART: break;
-//        case NS_rtf::LN_VERTALIGN: break;
-//        case NS_rtf::LN_FUNUSED: break;
-//        case NS_rtf::LN_WUNUSED: break;
-//        case NS_rtf::LN_BRCTOP: break;
-//        case NS_rtf::LN_BRCLEFT: break;
-//        case NS_rtf::LN_BRCBOTTOM: break;
-//        case NS_rtf::LN_BRCRIGHT: break;
-//        case NS_rtf::LN_IBKL: break;
-//        case NS_rtf::LN_ITCFIRST: break;
-//        case NS_rtf::LN_FPUB: break;
-//        case NS_rtf::LN_ITCLIM: break;
-//        case NS_rtf::LN_FCOL: break;
-//        case NS_rtf::LN_LINECOLOR: break;
-//        case NS_rtf::LN_LINEWIDTH: break;
-//        case NS_rtf::LN_LINETYPE: break;
-//        case NS_rtf::LN_MM: break;
-//        case NS_rtf::LN_XEXT: break;
-//        case NS_rtf::LN_YEXT: break;
-//        case NS_rtf::LN_HMF: break;
-//        case NS_rtf::LN_LCB: break;
-//        case NS_rtf::LN_CBHEADER: break;
-//        case NS_rtf::LN_MFP: break;
-//        case NS_rtf::LN_BM_RCWINMF: break;
-//        case NS_rtf::LN_DXAGOAL: break;
-//        case NS_rtf::LN_DYAGOAL: break;
-//        case NS_rtf::LN_MX: break;
-//        case NS_rtf::LN_MY: break;
-//        case NS_rtf::LN_DXACROPLEFT: break;
-//        case NS_rtf::LN_DYACROPTOP: break;
-//        case NS_rtf::LN_DXACROPRIGHT: break;
-//        case NS_rtf::LN_DYACROPBOTTOM: break;
-//        case NS_rtf::LN_BRCL: break;
-//        case NS_rtf::LN_FFRAMEEMPTY: break;
-//        case NS_rtf::LN_FBITMAP: break;
-//        case NS_rtf::LN_FDRAWHATCH: break;
-//        case NS_rtf::LN_FERROR: break;
-//        case NS_rtf::LN_BPP: break;
-//        case NS_rtf::LN_DXAORIGIN: break;
-//        case NS_rtf::LN_DYAORIGIN: break;
-//        case NS_rtf::LN_CPROPS: break;
-//        case NS_rtf::LN_LINEPROPSTOP: break;
-//        case NS_rtf::LN_LINEPROPSLEFT: break;
-//        case NS_rtf::LN_LINEPROPSBOTTOM: break;
-//        case NS_rtf::LN_LINEPROPSRIGHT: break;
-//        case NS_rtf::LN_LINEPROPSHORIZONTAL: break;
-//        case NS_rtf::LN_LINEPROPSVERTICAL: break;
-//        case NS_rtf::LN_headerr: break;
-//        case NS_rtf::LN_footerr: break;
-//        case NS_rtf::LN_endnote: break;
-//        case NS_rtf::LN_BOOKMARKNAME: break;
-
-//        case NS_rtf::LN_LISTLEVEL: break;
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_LFO:
-        {
-            writerfilter::Reference<Properties>::Pointer_t pProperties;
-            if(m_pImpl->m_pCurrentEntry && (pProperties = val.getProperties()).get())
-            {
-                LFOLevelPtr pLevel( new LFOLevel );
-                m_pImpl->m_pCurrentEntry->aLFOLevels.push_back(pLevel);
-            }
-        }
-        break;
-//        case NS_rtf::LN_F: break;
-//        case NS_rtf::LN_ALTFONTNAME: break;
-//        case NS_rtf::LN_XSZFFN: break;
-//        case NS_rtf::LN_XSTZNAME: break;
-//        case NS_rtf::LN_XSTZNAME1: break;
-//        case NS_rtf::LN_UPXSTART: break;
-//        case NS_rtf::LN_UPX: break;
-//        case NS_rtf::LN_sed: break;
-//        case NS_rtf::LN_picf: break;
-//        case NS_rtf::LN_rgbrc: break;
-//        case NS_rtf::LN_shd: break;
-//        case NS_rtf::LN_cellShd: break;
-//        case NS_rtf::LN_cellTopColor: break;
-//        case NS_rtf::LN_cellLeftColor: break;
-//        case NS_rtf::LN_cellBottomColor: break;
-//        case NS_rtf::LN_cellRightColor: break;
-        
-//        case NS_rtf::LN_LISTTABLE: break;
-//        case NS_rtf::LN_LFOTABLE: break;
-//        case NS_rtf::LN_FONTTABLE: break;
-//        case NS_rtf::LN_STYLESHEET: break;
-        default:
-        {
-            OSL_ENSURE( false, "LFOTable::attribute: default statement");
-            //---->debug
-            int nVal = val.getInt();
-            ++nVal;
-            //<----debug
-        }
-    }
-}
-/*-- 27.06.2006 15:13:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::sprm(Sprm& )
-{
-    OSL_ENSURE( false, "Which sprm should be handled here?");
-}
-/*-- 27.06.2006 15:13:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::entry(int, writerfilter::Reference<Properties>::Pointer_t ref)
-{
-    //create a new LFO entry
-    OSL_ENSURE( !m_pImpl->m_pCurrentEntry.get(), "current entry has to be NULL here");
-    m_pImpl->m_pCurrentEntry.reset( new LFOEntry );
-    ref->resolve(*this);
-    //append it to the table
-    m_pImpl->m_aLFOEntries.push_back( m_pImpl->m_pCurrentEntry );
-    m_pImpl->m_pCurrentEntry = LFOEntryPtr();
-}
-/*-- 27.06.2006 15:13:05---------------------------------------------------
-    1 based access to the LFO table
-  -----------------------------------------------------------------------*/
-sal_Int32 LFOTable::GetListID(sal_uInt32 nLFO)
-{
-    sal_Int32 nRet = -1;
-    if( nLFO > 0 && nLFO <= m_pImpl->m_aLFOEntries.size())
-        nRet = m_pImpl->m_aLFOEntries[nLFO - 1]->nListId;
-    return nRet;
-}
-/*-- 12.11.2007 10:31:23---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void LFOTable::AddListID( sal_Int32 nAbstractNumId )
-{
-    LFOEntryPtr pNew( new LFOEntry );
-    pNew->nListId = nAbstractNumId;
-    m_pImpl->m_aLFOEntries.push_back( pNew );
-}
-
-}//namespace dmapper
-}//namespace writerfilter
diff --git writerfilter/source/dmapper/LFOTable.hxx writerfilter/source/dmapper/LFOTable.hxx
deleted file mode 100644
index 856f033..0000000
--- writerfilter/source/dmapper/LFOTable.hxx
+++ /dev/null
@@ -1,68 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: LFOTable.hxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef INCLUDED_LFOTABLE_HXX
-#define INCLUDED_LFOTABLE_HXX
-
-#include <WriterFilterDllApi.hxx>
-#include <resourcemodel/WW8ResourceModel.hxx>
-#include <com/sun/star/lang/XComponent.hpp>
-//#ifndef INCLUDED_DMAPPER_PROPERTYMAP_HXX
-//#include <PropertyMap.hxx>
-//#endif
-//#include <vector>
-
-namespace writerfilter {
-namespace dmapper
-{
-
-struct LFOTable_Impl;
-class WRITERFILTER_DLLPRIVATE LFOTable : public Properties, public Table
-{
-    LFOTable_Impl   *m_pImpl;
-public:
-    LFOTable();
-    virtual ~LFOTable();
-
-    // Properties
-    virtual void attribute(Id Name, Value & val);
-    virtual void sprm(Sprm & sprm);
-
-    // Table
-    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
-
-//    sal_uInt32          size();
-    sal_Int32       GetListID(sal_uInt32 nLFO);
-    //direct access in ooxml import
-    void            AddListID( sal_Int32 nAbstractNumId );
-};
-typedef boost::shared_ptr< LFOTable >          LFOTablePtr;
-}}
-
-#endif //
diff --git writerfilter/source/dmapper/ListTable.cxx writerfilter/source/dmapper/ListTable.cxx
deleted file mode 100644
index 3cee1f8..0000000
--- writerfilter/source/dmapper/ListTable.cxx
+++ /dev/null
@@ -1,1303 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: ListTable.cxx,v $
- * $Revision: 1.8 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <ListTable.hxx>
-#include <dmapper/DomainMapper.hxx>
-#include <PropertyIds.hxx>
-#include <doctok/resourceids.hxx>
-#include <doctok/sprmids.hxx>
-#include <ooxml/resourceids.hxx>
-#include <ConversionHelper.hxx>
-#ifndef INCLUDED_WW8_RESOURCE_MODEL_HXX
-#include <resourcemodel/WW8ResourceModel.hxx>
-#endif
-#include <com/sun/star/container/XIndexReplace.hpp>
-#include <com/sun/star/container/XNameContainer.hpp>
-#include <com/sun/star/lang/XMultiServiceFactory.hpp>
-#include <com/sun/star/style/NumberingType.hpp>
-#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
-#include <com/sun/star/text/HoriOrientation.hpp>
-#include <com/sun/star/text/PositionAndSpaceMode.hpp>
-#include <vector>
-
-#define NUMBERING_MAX_LEVELS    10
-namespace writerfilter {
-namespace dmapper
-{
-using namespace com::sun::star;
-/*-- 12.11.2007 11:38:57---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-class WRITERFILTER_DLLPRIVATE Numbering_numHdl : public Properties
-{
-    ListTable&      m_rListTable;
-    sal_Int32       m_nAbstractNumId;
-    ::rtl::OUString m_sNumId;
-public:
-    Numbering_numHdl( ListTable& rListTable ) :
-        m_rListTable( rListTable ),
-        m_nAbstractNumId( -1 )
-        {}
-    virtual ~Numbering_numHdl();
-
-    // Properties
-    virtual void attribute(Id Name, Value & val);
-    virtual void sprm(Sprm & sprm);
-
-    sal_Int32       GetAbstractNumId() const { return m_nAbstractNumId;}
-    sal_Int32       GetNumId() const { return m_sNumId.toInt32(); }
-
-};
-typedef boost::shared_ptr< Numbering_numHdl >          Numbering_numHdlPtr;
-/*-- 12.11.2007 11:42:04---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-Numbering_numHdl::~Numbering_numHdl()
-{
-}
-/*-- 12.11.2007 11:42:22---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void Numbering_numHdl::attribute(Id nName, Value & rVal)
-{
-    switch( nName )
-    {
-        case NS_ooxml::LN_CT_Num_numId:
-            m_sNumId = rVal.getString();
-        break;
-        case NS_ooxml::LN_CT_NumLvl_ilvl :
-            m_rListTable.setOverwriteLevel(m_nAbstractNumId, rVal.getInt());
-        break;
-        default:;
-    }
-}
-/*-- 12.11.2007 11:42:22---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void Numbering_numHdl::sprm(Sprm & rSprm)
-{
-    sal_uInt32 nSprmId = rSprm.getId();
-    switch( nSprmId )
-    {
-        case NS_ooxml::LN_CT_Num_abstractNumId:
-        {
-            m_nAbstractNumId = rSprm.getValue()->getInt();
-        }
-        break;
-        case NS_ooxml::LN_CT_Num_lvlOverride: 
-        {
-            //contains a list override
-            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-            if(pProperties.get())
-                pProperties->resolve(*this);
-            m_rListTable.resetOverwrite();
-        }
-        case NS_ooxml::LN_CT_NumLvl_lvl:
-            m_rListTable.sprm( rSprm );
-        break;
-        default:;
-    }
-}
-/*-- 26.06.2006 13:14:29---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-class ListPropertyMap : public PropertyMap
-{
-    friend class ListTable;
-
-    sal_Int32                                       nIStartAt;       //LN_ISTARTAT
-    sal_Int32                                       nNFC;            //LN_NFC
-    sal_Int32                                       nJC;             //LN_JC
-    sal_Int32                                       nFLegal;         //LN_FLEGAL
-    sal_Int32                                       nFNoRestart;     //LN_FNORESTART
-    sal_Int32                                       nFPrev;          //LN_FPREV
-    sal_Int32                                       nFPrevSpace;     //LN_FPREVSPACE
-    sal_Int32                                       nFWord6;         //LN_FWORD6
-    ::rtl::OUString                                 sRGBXchNums;     //LN_RGBXCHNUMS
-    sal_Int32                                       nXChFollow;      //LN_IXCHFOLLOW
-    ::rtl::OUString                                 sBulletChar;
-    sal_Int32                                       nTabstop;
-public:
-    ListPropertyMap() :
-        nIStartAt(-1)
-        ,nNFC(-1)
-        ,nJC(-1)
-        ,nFLegal(-1)
-        ,nFNoRestart(-1)
-        ,nFPrev(-1)
-        ,nFPrevSpace(-1)
-        ,nFWord6(-1)
-        ,nXChFollow(-1)
-        ,nTabstop( 0 )
-        {}
-    ~ListPropertyMap(){}
-
-    uno::Sequence< beans::PropertyValue >  GetPropertyValuesList( PropertyValueVector_t& rCharStyleProperties  );
-};
-/*-- 26.06.2006 13:44:57---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-#define MAKE_PROPVAL(NameId, Value) \
-    beans::PropertyValue(aPropNameSupplier.GetName(NameId), 0, uno::makeAny(Value), beans::PropertyState_DIRECT_VALUE )
-
-uno::Sequence< beans::PropertyValue >  ListPropertyMap::GetPropertyValuesList( PropertyValueVector_t& rCharStyleProperties )
-{
-    const sal_Int16 aWWToUnoAdjust[] =
-    {
-        text::HoriOrientation::LEFT,
-        text::HoriOrientation::CENTER,
-        text::HoriOrientation::RIGHT,
-    };
-
-    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-    PropertyValueVector_t aNumberingProperties;
-
-    if( nIStartAt >= 0)
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_START_WITH, (sal_Int16)nIStartAt) );
-
-    sal_Int16 nNumberFormat = ConversionHelper::ConvertNumberingType(nNFC);
-    if( nNFC >= 0)
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_NUMBERING_TYPE, nNumberFormat ));
-
-    if( nJC >= 0 && nJC <= sal::static_int_cast<sal_Int32>(sizeof(aWWToUnoAdjust) / sizeof(sal_Int16)) )
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_ADJUST, aWWToUnoAdjust[nJC]));
-
-    // todo: this is not the bullet char
-    if( nNumberFormat == style::NumberingType::CHAR_SPECIAL && sBulletChar.getLength() )
-        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_BULLET_CHAR, sBulletChar.copy(0,1)));
-
-    aNumberingProperties.push_back( MAKE_PROPVAL( PROP_LISTTAB_STOP_POSITION, nTabstop ) );
-
-    //TODO: handling of nFLegal?
-    //TODO: nFNoRestart lower levels do not restart when higher levels are incremented, like:
-    //1.
-    //1.1
-    //2.2
-    //2.3
-    //3.4
-    //
-
-    if( nFWord6 > 0) //Word 6 compatibility
-    {
-        if( nFPrev == 1)
-            aNumberingProperties.push_back( MAKE_PROPVAL( PROP_PARENT_NUMBERING, (sal_Int16) NUMBERING_MAX_LEVELS ));
-        //TODO: prefixing space     nFPrevSpace;     - has not been used in WW8 filter
-    }
-
-//    TODO: sRGBXchNums;     array of inherited numbers
-
-//    TODO: nXChFollow; following character 0 - tab, 1 - space, 2 - nothing
-//    if(pProperties)
-//    {
-
-        _PropertyMap::const_iterator aMapIter = /*pProperties->*/begin();
-        _PropertyMap::const_iterator aEndIter = /*pProperties->*/end();
-        for( ; aMapIter != aEndIter; ++aMapIter )
-        {
-            switch( aMapIter->first.eId )
-            {
-                case PROP_ADJUST:
-                case PROP_INDENT_AT:
-                case PROP_FIRST_LINE_INDENT:
-                case PROP_FIRST_LINE_OFFSET:
-                case PROP_LEFT_MARGIN:
-                    aNumberingProperties.push_back(
-                        beans::PropertyValue( aPropNameSupplier.GetName( aMapIter->first.eId ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
-                break;
-                case PROP_CHAR_FONT_NAME:
-                    aNumberingProperties.push_back(
-                        beans::PropertyValue( aPropNameSupplier.GetName( PROP_BULLET_FONT_NAME ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
-                break;
-                default: 
-                {
-                    rCharStyleProperties.push_back(beans::PropertyValue( aPropNameSupplier.GetName( aMapIter->first.eId ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
-                }
-
-            }
-        }
-//    }
-    uno::Sequence< beans::PropertyValue > aRet(aNumberingProperties.size());
-    beans::PropertyValue* pValues = aRet.getArray();
-    PropertyValueVector_t::const_iterator aIt = aNumberingProperties.begin();
-    PropertyValueVector_t::const_iterator aEndIt = aNumberingProperties.end();
-    for(sal_uInt32 nIndex = 0; aIt != aEndIt; ++aIt,++nIndex)
-    {
-        pValues[nIndex] = *aIt;
-    }
-    return aRet;
-}
-typedef boost::shared_ptr<ListPropertyMap> ListPropertyMapPtr;
-
-struct ListEntry
-{
-    sal_Int32                                       nListId;        //LN_LSID
-    sal_Int32                                       nTPLC;          //LN_TPLC
-    ::rtl::OUString                                 sRGISTD;        //LN_RGISTD
-    sal_Int32                                       nSimpleList;    //LN_FSIMPLELIST
-    sal_Int32                                       nRestart;       //LN_FRESTARTHDN
-    sal_Int32                                       nUnsigned;      //LN_UNSIGNED26_2
-    sal_Int32                                       nAbstractNumId;
-
-    ::std::vector< ListPropertyMapPtr >             aLevelProperties; //properties of each level
-
-    ListPropertyMapPtr                              pCurrentProperties;
-    uno::Reference< container::XIndexReplace >      m_xNumRules;
-
-    ListEntry();
-
-};
-typedef boost::shared_ptr<ListEntry> ListEntryPtr;
-/*-- 23.06.2006 13:58:51---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-ListEntry::ListEntry() :
-    nListId(-1)
-    ,nTPLC(-1)
-    ,nSimpleList(-1)
-    ,nRestart(-1)
-    ,nUnsigned(-1)
-    ,nAbstractNumId(-1)
-{
-}
-/*-- 23.06.2006 13:58:51---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-struct ListTable_Impl
-{
-    DomainMapper&                                   m_rDMapper;
-    uno::Reference< lang::XMultiServiceFactory >    m_xFactory;
-
-    std::vector< ListEntryPtr >                     m_aListEntries;
-    ListEntryPtr                                    m_pCurrentEntry;
-
-
-    ListTable_Impl(DomainMapper& rDMapper, uno::Reference< lang::XMultiServiceFactory > xFactory) :
-            m_rDMapper( rDMapper )
-            ,m_xFactory( xFactory )
-            {}
-
-    void    AddLevel();
-};
-/*-- 26.06.2006 14:23:19---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable_Impl::AddLevel()
-{
-    ListPropertyMapPtr pLevel( new ListPropertyMap );
-    m_pCurrentEntry->pCurrentProperties = pLevel;
-    m_pCurrentEntry->aLevelProperties.push_back(pLevel);
-}
-/*-- 23.06.2006 12:04:32---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-ListTable::ListTable(
-        DomainMapper& rDMapper,
-        const uno::Reference< lang::XMultiServiceFactory > xFactory) :
-    m_pImpl( new ListTable_Impl(rDMapper, xFactory) ),
-    m_nOverwriteListId( -1 ),
-    m_nOverwriteLevel( -1 )
-{
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-ListTable::~ListTable()
-{
-    delete m_pImpl;
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::attribute(Id nName, Value & rVal)
-{
-    OSL_ENSURE( m_pImpl->m_pCurrentEntry.get(), "current entry has to be set here");
-    if(!m_pImpl->m_pCurrentEntry.get())
-        return ;
-    int nIntValue = rVal.getInt();
-    /* WRITERFILTERSTATUS: table: ListTable_attributedata */
-    switch(nName)
-    {
-        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-        case NS_rtf::LN_RGBXCHNUMS:
-            if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->sRGBXchNums += rVal.getString();
-        break;
-        /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-        case NS_ooxml::LN_CT_LevelText_val:
-        {    
-            //this strings contains the definition of the level
-            //the level number is marked as %n
-            //these numbers can be mixed randomly toghether with seperators pre- and suffixes
-            //the Writer supports only a number of upper levels to show, separators is always a dot
-            //and each level can have a prefix and a suffix
-            if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-            {
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->sBulletChar = rVal.getString();
-            }
-        }
-        break;
-//        case NS_rtf::LN_ISTD: break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_ISTARTAT:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_NFC:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_JC:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FLEGAL:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FNORESTART:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FPREV:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FPREVSPACE:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FWORD6:
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_IXCHFOLLOW:
-            ApplyLevelValues( nName, nIntValue);
-        break;
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-        case NS_rtf::LN_UNUSED5_7:
-            //unused
-        break;
-//        case NS_rtf::LN_DXASPACE: break;
-//        case NS_rtf::LN_DXAINDENT: break;
-//        case NS_rtf::LN_CBGRPPRLCHPX: break;
-//        case NS_rtf::LN_CBGRPPRLPAPX: break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_LSID:
-            m_pImpl->m_pCurrentEntry->nListId = nIntValue;
-        break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_TPLC:
-            m_pImpl->m_pCurrentEntry->nTPLC = nIntValue;
-        break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_RGISTD:
-            m_pImpl->m_pCurrentEntry->sRGISTD += rVal.getString();
-        break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FSIMPLELIST:
-            m_pImpl->m_pCurrentEntry->nSimpleList = nIntValue;
-        break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_FRESTARTHDN:
-            m_pImpl->m_pCurrentEntry->nRestart = nIntValue;
-        break;
-        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-        case NS_rtf::LN_UNSIGNED26_2:
-            m_pImpl->m_pCurrentEntry->nUnsigned = nIntValue;
-        break;
-//        case NS_rtf::LN_ILVL: break;
-//        case NS_rtf::LN_FSTARTAT: break;
-//        case NS_rtf::LN_FFORMATTING: break;
-//        case NS_rtf::LN_UNSIGNED4_6: break;
-//        case NS_rtf::LN_UNUSED4: break;
-//        case NS_rtf::LN_UNUSED8: break;
-//        case NS_rtf::LN_CLFOLVL: break;
-//        case NS_rtf::LN_CBFFNM1: break;
-//        case NS_rtf::LN_PRQ: break;
-//        case NS_rtf::LN_FTRUETYPE: break;
-//        case NS_rtf::LN_UNUSED1_3: break;
-//        case NS_rtf::LN_FF: break;
-//        case NS_rtf::LN_UNUSED1_7: break;
-//        case NS_rtf::LN_WWEIGHT: break;
-//        case NS_rtf::LN_CHS: break;
-//        case NS_rtf::LN_IXCHSZALT: break;
-//        case NS_rtf::LN_PANOSE: break;
-//        case NS_rtf::LN_FS: break;
-//        case NS_rtf::LN_STI: break;
-//        case NS_rtf::LN_FSCRATCH: break;
-//        case NS_rtf::LN_FINVALHEIGHT: break;
-//        case NS_rtf::LN_FHASUPE: break;
-//        case NS_rtf::LN_FMASSCOPY: break;
-//        case NS_rtf::LN_SGC: break;
-//        case NS_rtf::LN_ISTDBASE: break;
-//        case NS_rtf::LN_CUPX: break;
-//        case NS_rtf::LN_ISTDNEXT: break;
-//        case NS_rtf::LN_BCHUPE: break;
-//        case NS_rtf::LN_FAUTOREDEF: break;
-//        case NS_rtf::LN_FHIDDEN: break;
-//        case NS_rtf::LN_UNUSED8_3: break;
-//        case NS_rtf::LN_CSTD: break;
-//        case NS_rtf::LN_CBSTDBASEINFILE: break;
-//        case NS_rtf::LN_FSTDSTYLENAMESWRITTEN: break;
-//        case NS_rtf::LN_UNUSED4_2: break;
-//        case NS_rtf::LN_STIMAXWHENSAVED: break;
-//        case NS_rtf::LN_ISTDMAXFIXEDWHENSAVED: break;
-//        case NS_rtf::LN_NVERBUILTINNAMESWHENSAVED: break;
-//        case NS_rtf::LN_RGFTCSTANDARDCHPSTSH: break;
-//        case NS_rtf::LN_WIDENT: break;
-//        case NS_rtf::LN_NFIB: break;
-//        case NS_rtf::LN_NPRODUCT: break;
-//        case NS_rtf::LN_LID: break;
-//        case NS_rtf::LN_PNNEXT: break;
-//        case NS_rtf::LN_FDOT: break;
-//        case NS_rtf::LN_FGLSY: break;
-//        case NS_rtf::LN_FCOMPLEX: break;
-//        case NS_rtf::LN_FHASPIC: break;
-//        case NS_rtf::LN_CQUICKSAVES: break;
-//        case NS_rtf::LN_FENCRYPTED: break;
-//        case NS_rtf::LN_FWHICHTBLSTM: break;
-//        case NS_rtf::LN_FREADONLYRECOMMENDED: break;
-//        case NS_rtf::LN_FWRITERESERVATION: break;
-//        case NS_rtf::LN_FEXTCHAR: break;
-//        case NS_rtf::LN_FLOADOVERRIDE: break;
-//        case NS_rtf::LN_FFAREAST: break;
-//        case NS_rtf::LN_FCRYPTO: break;
-//        case NS_rtf::LN_NFIBBACK: break;
-//        case NS_rtf::LN_LKEY: break;
-//        case NS_rtf::LN_ENVR: break;
-//        case NS_rtf::LN_FMAC: break;
-//        case NS_rtf::LN_FEMPTYSPECIAL: break;
-//        case NS_rtf::LN_FLOADOVERRIDEPAGE: break;
-//        case NS_rtf::LN_FFUTURESAVEDUNDO: break;
-//        case NS_rtf::LN_FWORD97SAVED: break;
-//        case NS_rtf::LN_FSPARE0: break;
-//        case NS_rtf::LN_CHSTABLES: break;
-//        case NS_rtf::LN_FCMIN: break;
-//        case NS_rtf::LN_FCMAC: break;
-//        case NS_rtf::LN_CSW: break;
-//        case NS_rtf::LN_WMAGICCREATED: break;
-//        case NS_rtf::LN_WMAGICREVISED: break;
-//        case NS_rtf::LN_WMAGICCREATEDPRIVATE: break;
-//        case NS_rtf::LN_WMAGICREVISEDPRIVATE: break;
-//        case NS_rtf::LN_PNFBPCHPFIRST_W6: break;
-//        case NS_rtf::LN_PNCHPFIRST_W6: break;
-//        case NS_rtf::LN_CPNBTECHP_W6: break;
-//        case NS_rtf::LN_PNFBPPAPFIRST_W6: break;
-//        case NS_rtf::LN_PNPAPFIRST_W6: break;
-//        case NS_rtf::LN_CPNBTEPAP_W6: break;
-//        case NS_rtf::LN_PNFBPLVCFIRST_W6: break;
-//        case NS_rtf::LN_PNLVCFIRST_W6: break;
-//        case NS_rtf::LN_CPNBTELVC_W6: break;
-//        case NS_rtf::LN_LIDFE: break;
-//        case NS_rtf::LN_CLW: break;
-//        case NS_rtf::LN_CBMAC: break;
-//        case NS_rtf::LN_LPRODUCTCREATED: break;
-//        case NS_rtf::LN_LPRODUCTREVISED: break;
-//        case NS_rtf::LN_CCPTEXT: break;
-//        case NS_rtf::LN_CCPFTN: break;
-//        case NS_rtf::LN_CCPHDD: break;
-//        case NS_rtf::LN_CCPMCR: break;
-//        case NS_rtf::LN_CCPATN: break;
-//        case NS_rtf::LN_CCPEDN: break;
-//        case NS_rtf::LN_CCPTXBX: break;
-//        case NS_rtf::LN_CCPHDRTXBX: break;
-//        case NS_rtf::LN_PNFBPCHPFIRST: break;
-//        case NS_rtf::LN_PNCHPFIRST: break;
-//        case NS_rtf::LN_CPNBTECHP: break;
-//        case NS_rtf::LN_PNFBPPAPFIRST: break;
-//        case NS_rtf::LN_PNPAPFIRST: break;
-//        case NS_rtf::LN_CPNBTEPAP: break;
-//        case NS_rtf::LN_PNFBPLVCFIRST: break;
-//        case NS_rtf::LN_PNLVCFIRST: break;
-//        case NS_rtf::LN_CPNBTELVC: break;
-//        case NS_rtf::LN_FCISLANDFIRST: break;
-//        case NS_rtf::LN_FCISLANDLIM: break;
-//        case NS_rtf::LN_CFCLCB: break;
-//        case NS_rtf::LN_FCSTSHFORIG: break;
-//        case NS_rtf::LN_LCBSTSHFORIG: break;
-//        case NS_rtf::LN_FCSTSHF: break;
-//        case NS_rtf::LN_LCBSTSHF: break;
-//        case NS_rtf::LN_FCPLCFFNDREF: break;
-//        case NS_rtf::LN_LCBPLCFFNDREF: break;
-//        case NS_rtf::LN_FCPLCFFNDTXT: break;
-//        case NS_rtf::LN_LCBPLCFFNDTXT: break;
-//        case NS_rtf::LN_FCPLCFANDREF: break;
-//        case NS_rtf::LN_LCBPLCFANDREF: break;
-//        case NS_rtf::LN_FCPLCFANDTXT: break;
-//        case NS_rtf::LN_LCBPLCFANDTXT: break;
-//        case NS_rtf::LN_FCPLCFSED: break;
-//        case NS_rtf::LN_LCBPLCFSED: break;
-//        case NS_rtf::LN_FCPLCFPAD: break;
-//        case NS_rtf::LN_LCBPLCFPAD: break;
-//        case NS_rtf::LN_FCPLCFPHE: break;
-//        case NS_rtf::LN_LCBPLCFPHE: break;
-//        case NS_rtf::LN_FCSTTBFGLSY: break;
-//        case NS_rtf::LN_LCBSTTBFGLSY: break;
-//        case NS_rtf::LN_FCPLCFGLSY: break;
-//        case NS_rtf::LN_LCBPLCFGLSY: break;
-//        case NS_rtf::LN_FCPLCFHDD: break;
-//        case NS_rtf::LN_LCBPLCFHDD: break;
-//        case NS_rtf::LN_FCPLCFBTECHPX: break;
-//        case NS_rtf::LN_LCBPLCFBTECHPX: break;
-//        case NS_rtf::LN_FCPLCFBTEPAPX: break;
-//        case NS_rtf::LN_LCBPLCFBTEPAPX: break;
-//        case NS_rtf::LN_FCPLCFSEA: break;
-//        case NS_rtf::LN_LCBPLCFSEA: break;
-//        case NS_rtf::LN_FCSTTBFFFN: break;
-//        case NS_rtf::LN_LCBSTTBFFFN: break;
-//        case NS_rtf::LN_FCPLCFFLDMOM: break;
-//        case NS_rtf::LN_LCBPLCFFLDMOM: break;
-//        case NS_rtf::LN_FCPLCFFLDHDR: break;
-//        case NS_rtf::LN_LCBPLCFFLDHDR: break;
-//        case NS_rtf::LN_FCPLCFFLDFTN: break;
-//        case NS_rtf::LN_LCBPLCFFLDFTN: break;
-//        case NS_rtf::LN_FCPLCFFLDATN: break;
-//        case NS_rtf::LN_LCBPLCFFLDATN: break;
-//        case NS_rtf::LN_FCPLCFFLDMCR: break;
-//        case NS_rtf::LN_LCBPLCFFLDMCR: break;
-//        case NS_rtf::LN_FCSTTBFBKMK: break;
-//        case NS_rtf::LN_LCBSTTBFBKMK: break;
-//        case NS_rtf::LN_FCPLCFBKF: break;
-//        case NS_rtf::LN_LCBPLCFBKF: break;
-//        case NS_rtf::LN_FCPLCFBKL: break;
-//        case NS_rtf::LN_LCBPLCFBKL: break;
-//        case NS_rtf::LN_FCCMDS: break;
-//        case NS_rtf::LN_LCBCMDS: break;
-//        case NS_rtf::LN_FCPLCMCR: break;
-//        case NS_rtf::LN_LCBPLCMCR: break;
-//        case NS_rtf::LN_FCSTTBFMCR: break;
-//        case NS_rtf::LN_LCBSTTBFMCR: break;
-//        case NS_rtf::LN_FCPRDRVR: break;
-//        case NS_rtf::LN_LCBPRDRVR: break;
-//        case NS_rtf::LN_FCPRENVPORT: break;
-//        case NS_rtf::LN_LCBPRENVPORT: break;
-//        case NS_rtf::LN_FCPRENVLAND: break;
-//        case NS_rtf::LN_LCBPRENVLAND: break;
-//        case NS_rtf::LN_FCWSS: break;
-//        case NS_rtf::LN_LCBWSS: break;
-//        case NS_rtf::LN_FCDOP: break;
-//        case NS_rtf::LN_LCBDOP: break;
-//        case NS_rtf::LN_FCSTTBFASSOC: break;
-//        case NS_rtf::LN_LCBSTTBFASSOC: break;
-//        case NS_rtf::LN_FCCLX: break;
-//        case NS_rtf::LN_LCBCLX: break;
-//        case NS_rtf::LN_FCPLCFPGDFTN: break;
-//        case NS_rtf::LN_LCBPLCFPGDFTN: break;
-//        case NS_rtf::LN_FCAUTOSAVESOURCE: break;
-//        case NS_rtf::LN_LCBAUTOSAVESOURCE: break;
-//        case NS_rtf::LN_FCGRPXSTATNOWNERS: break;
-//        case NS_rtf::LN_LCBGRPXSTATNOWNERS: break;
-//        case NS_rtf::LN_FCSTTBFATNBKMK: break;
-//        case NS_rtf::LN_LCBSTTBFATNBKMK: break;
-//        case NS_rtf::LN_FCPLCDOAMOM: break;
-//        case NS_rtf::LN_LCBPLCDOAMOM: break;
-//        case NS_rtf::LN_FCPLCDOAHDR: break;
-//        case NS_rtf::LN_LCBPLCDOAHDR: break;
-//        case NS_rtf::LN_FCPLCSPAMOM: break;
-//        case NS_rtf::LN_LCBPLCSPAMOM: break;
-//        case NS_rtf::LN_FCPLCSPAHDR: break;
-//        case NS_rtf::LN_LCBPLCSPAHDR: break;
-//        case NS_rtf::LN_FCPLCFATNBKF: break;
-//        case NS_rtf::LN_LCBPLCFATNBKF: break;
-//        case NS_rtf::LN_FCPLCFATNBKL: break;
-//        case NS_rtf::LN_LCBPLCFATNBKL: break;
-//        case NS_rtf::LN_FCPMS: break;
-//        case NS_rtf::LN_LCBPMS: break;
-//        case NS_rtf::LN_FCFORMFLDSTTBF: break;
-//        case NS_rtf::LN_LCBFORMFLDSTTBF: break;
-//        case NS_rtf::LN_FCPLCFENDREF: break;
-//        case NS_rtf::LN_LCBPLCFENDREF: break;
-//        case NS_rtf::LN_FCPLCFENDTXT: break;
-//        case NS_rtf::LN_LCBPLCFENDTXT: break;
-//        case NS_rtf::LN_FCPLCFFLDEDN: break;
-//        case NS_rtf::LN_LCBPLCFFLDEDN: break;
-//        case NS_rtf::LN_FCPLCFPGDEDN: break;
-//        case NS_rtf::LN_LCBPLCFPGDEDN: break;
-//        case NS_rtf::LN_FCDGGINFO: break;
-//        case NS_rtf::LN_LCBDGGINFO: break;
-//        case NS_rtf::LN_FCSTTBFRMARK: break;
-//        case NS_rtf::LN_LCBSTTBFRMARK: break;
-//        case NS_rtf::LN_FCSTTBFCAPTION: break;
-//        case NS_rtf::LN_LCBSTTBFCAPTION: break;
-//        case NS_rtf::LN_FCSTTBFAUTOCAPTION: break;
-//        case NS_rtf::LN_LCBSTTBFAUTOCAPTION: break;
-//        case NS_rtf::LN_FCPLCFWKB: break;
-//        case NS_rtf::LN_LCBPLCFWKB: break;
-//        case NS_rtf::LN_FCPLCFSPL: break;
-//        case NS_rtf::LN_LCBPLCFSPL: break;
-//        case NS_rtf::LN_FCPLCFTXBXTXT: break;
-//        case NS_rtf::LN_LCBPLCFTXBXTXT: break;
-//        case NS_rtf::LN_FCPLCFFLDTXBX: break;
-//        case NS_rtf::LN_LCBPLCFFLDTXBX: break;
-//        case NS_rtf::LN_FCPLCFHDRTXBXTXT: break;
-//        case NS_rtf::LN_LCBPLCFHDRTXBXTXT: break;
-//        case NS_rtf::LN_FCPLCFFLDHDRTXBX: break;
-//        case NS_rtf::LN_LCBPLCFFLDHDRTXBX: break;
-//        case NS_rtf::LN_FCSTWUSER: break;
-//        case NS_rtf::LN_LCBSTWUSER: break;
-//        case NS_rtf::LN_FCSTTBTTMBD: break;
-//        case NS_rtf::LN_LCBSTTBTTMBD: break;
-//        case NS_rtf::LN_FCUNUSED: break;
-//        case NS_rtf::LN_LCBUNUSED: break;
-//        case NS_rtf::LN_FCPGDMOTHER: break;
-//        case NS_rtf::LN_LCBPGDMOTHER: break;
-//        case NS_rtf::LN_FCBKDMOTHER: break;
-//        case NS_rtf::LN_LCBBKDMOTHER: break;
-//        case NS_rtf::LN_FCPGDFTN: break;
-//        case NS_rtf::LN_LCBPGDFTN: break;
-//        case NS_rtf::LN_FCBKDFTN: break;
-//        case NS_rtf::LN_LCBBKDFTN: break;
-//        case NS_rtf::LN_FCPGDEDN: break;
-//        case NS_rtf::LN_LCBPGDEDN: break;
-//        case NS_rtf::LN_FCBKDEDN: break;
-//        case NS_rtf::LN_LCBBKDEDN: break;
-//        case NS_rtf::LN_FCSTTBFINTLFLD: break;
-//        case NS_rtf::LN_LCBSTTBFINTLFLD: break;
-//        case NS_rtf::LN_FCROUTESLIP: break;
-//        case NS_rtf::LN_LCBROUTESLIP: break;
-//        case NS_rtf::LN_FCSTTBSAVEDBY: break;
-//        case NS_rtf::LN_LCBSTTBSAVEDBY: break;
-//        case NS_rtf::LN_FCSTTBFNM: break;
-//        case NS_rtf::LN_LCBSTTBFNM: break;
-//        case NS_rtf::LN_FCPLCFLST: break;
-//        case NS_rtf::LN_LCBPLCFLST: break;
-//        case NS_rtf::LN_FCPLFLFO: break;
-//        case NS_rtf::LN_LCBPLFLFO: break;
-//        case NS_rtf::LN_FCPLCFTXBXBKD: break;
-//        case NS_rtf::LN_LCBPLCFTXBXBKD: break;
-//        case NS_rtf::LN_FCPLCFTXBXHDRBKD: break;
-//        case NS_rtf::LN_LCBPLCFTXBXHDRBKD: break;
-//        case NS_rtf::LN_FCDOCUNDO: break;
-//        case NS_rtf::LN_LCBDOCUNDO: break;
-//        case NS_rtf::LN_FCRGBUSE: break;
-//        case NS_rtf::LN_LCBRGBUSE: break;
-//        case NS_rtf::LN_FCUSP: break;
-//        case NS_rtf::LN_LCBUSP: break;
-//        case NS_rtf::LN_FCUSKF: break;
-//        case NS_rtf::LN_LCBUSKF: break;
-//        case NS_rtf::LN_FCPLCUPCRGBUSE: break;
-//        case NS_rtf::LN_LCBPLCUPCRGBUSE: break;
-//        case NS_rtf::LN_FCPLCUPCUSP: break;
-//        case NS_rtf::LN_LCBPLCUPCUSP: break;
-//        case NS_rtf::LN_FCSTTBGLSYSTYLE: break;
-//        case NS_rtf::LN_LCBSTTBGLSYSTYLE: break;
-//        case NS_rtf::LN_FCPLGOSL: break;
-//        case NS_rtf::LN_LCBPLGOSL: break;
-//        case NS_rtf::LN_FCPLCOCX: break;
-//        case NS_rtf::LN_LCBPLCOCX: break;
-//        case NS_rtf::LN_FCPLCFBTELVC: break;
-//        case NS_rtf::LN_LCBPLCFBTELVC: break;
-//        case NS_rtf::LN_DWLOWDATETIME: break;
-//        case NS_rtf::LN_DWHIGHDATETIME: break;
-//        case NS_rtf::LN_FCPLCFLVC: break;
-//        case NS_rtf::LN_LCBPLCFLVC: break;
-//        case NS_rtf::LN_FCPLCASUMY: break;
-//        case NS_rtf::LN_LCBPLCASUMY: break;
-//        case NS_rtf::LN_FCPLCFGRAM: break;
-//        case NS_rtf::LN_LCBPLCFGRAM: break;
-//        case NS_rtf::LN_FCSTTBLISTNAMES: break;
-//        case NS_rtf::LN_LCBSTTBLISTNAMES: break;
-//        case NS_rtf::LN_FCSTTBFUSSR: break;
-//        case NS_rtf::LN_LCBSTTBFUSSR: break;
-//        case NS_rtf::LN_FN: break;
-//        case NS_rtf::LN_FCSEPX: break;
-//        case NS_rtf::LN_FNMPR: break;
-//        case NS_rtf::LN_FCMPR: break;
-//        case NS_rtf::LN_ICOFORE: break;
-//        case NS_rtf::LN_ICOBACK: break;
-//        case NS_rtf::LN_IPAT: break;
-//        case NS_rtf::LN_SHDFORECOLOR: break;
-//        case NS_rtf::LN_SHDBACKCOLOR: break;
-//        case NS_rtf::LN_SHDPATTERN: break;
-//        case NS_rtf::LN_DPTLINEWIDTH: break;
-//        case NS_rtf::LN_BRCTYPE: break;
-//        case NS_rtf::LN_ICO: break;
-//        case NS_rtf::LN_DPTSPACE: break;
-//        case NS_rtf::LN_FSHADOW: break;
-//        case NS_rtf::LN_FFRAME: break;
-//        case NS_rtf::LN_UNUSED2_15: break;
-//        case NS_rtf::LN_FFIRSTMERGED: break;
-//        case NS_rtf::LN_FMERGED: break;
-//        case NS_rtf::LN_FVERTICAL: break;
-//        case NS_rtf::LN_FBACKWARD: break;
-//        case NS_rtf::LN_FROTATEFONT: break;
-//        case NS_rtf::LN_FVERTMERGE: break;
-//        case NS_rtf::LN_FVERTRESTART: break;
-//        case NS_rtf::LN_VERTALIGN: break;
-//        case NS_rtf::LN_FUNUSED: break;
-//        case NS_rtf::LN_WUNUSED: break;
-//        case NS_rtf::LN_BRCTOP: break;
-//        case NS_rtf::LN_BRCLEFT: break;
-//        case NS_rtf::LN_BRCBOTTOM: break;
-//        case NS_rtf::LN_BRCRIGHT: break;
-//        case NS_rtf::LN_IBKL: break;
-//        case NS_rtf::LN_ITCFIRST: break;
-//        case NS_rtf::LN_FPUB: break;
-//        case NS_rtf::LN_ITCLIM: break;
-//        case NS_rtf::LN_FCOL: break;
-//        case NS_rtf::LN_LINECOLOR: break;
-//        case NS_rtf::LN_LINEWIDTH: break;
-//        case NS_rtf::LN_LINETYPE: break;
-//        case NS_rtf::LN_MM: break;
-//        case NS_rtf::LN_XEXT: break;
-//        case NS_rtf::LN_YEXT: break;
-//        case NS_rtf::LN_HMF: break;
-//        case NS_rtf::LN_LCB: break;
-//        case NS_rtf::LN_CBHEADER: break;
-//        case NS_rtf::LN_MFP: break;
-//        case NS_rtf::LN_BM_RCWINMF: break;
-//        case NS_rtf::LN_DXAGOAL: break;
-//        case NS_rtf::LN_DYAGOAL: break;
-//        case NS_rtf::LN_MX: break;
-//        case NS_rtf::LN_MY: break;
-//        case NS_rtf::LN_DXACROPLEFT: break;
-//        case NS_rtf::LN_DYACROPTOP: break;
-//        case NS_rtf::LN_DXACROPRIGHT: break;
-//        case NS_rtf::LN_DYACROPBOTTOM: break;
-//        case NS_rtf::LN_BRCL: break;
-//        case NS_rtf::LN_FFRAMEEMPTY: break;
-//        case NS_rtf::LN_FBITMAP: break;
-//        case NS_rtf::LN_FDRAWHATCH: break;
-//        case NS_rtf::LN_FERROR: break;
-//        case NS_rtf::LN_BPP: break;
-//        case NS_rtf::LN_DXAORIGIN: break;
-//        case NS_rtf::LN_DYAORIGIN: break;
-//        case NS_rtf::LN_CPROPS: break;
-//        case NS_rtf::LN_LINEPROPSTOP: break;
-//        case NS_rtf::LN_LINEPROPSLEFT: break;
-//        case NS_rtf::LN_LINEPROPSBOTTOM: break;
-//        case NS_rtf::LN_LINEPROPSRIGHT: break;
-//        case NS_rtf::LN_LINEPROPSHORIZONTAL: break;
-//        case NS_rtf::LN_LINEPROPSVERTICAL: break;
-//        case NS_rtf::LN_headerr: break;
-//        case NS_rtf::LN_footerr: break;
-//        case NS_rtf::LN_endnote: break;
-//        case NS_rtf::LN_BOOKMARKNAME: break;
-
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-        case NS_rtf::LN_LISTLEVEL:
-        {
-            //add a new level to the level vector and make it the current one
-            m_pImpl->AddLevel();
-
-            writerfilter::Reference<Properties>::Pointer_t pProperties;
-            if((pProperties = rVal.getProperties()).get())
-                pProperties->resolve(*this);
-        }
-        break;
-//        case NS_rtf::LN_LFO: break;
-//        case NS_rtf::LN_F: break;
-//        case NS_rtf::LN_ALTFONTNAME: break;
-//        case NS_rtf::LN_XSZFFN: break;
-//        case NS_rtf::LN_XSTZNAME: break;
-//        case NS_rtf::LN_XSTZNAME1: break;
-//        case NS_rtf::LN_UPXSTART: break;
-//        case NS_rtf::LN_UPX: break;
-//        case NS_rtf::LN_sed: break;
-//        case NS_rtf::LN_picf: break;
-//        case NS_rtf::LN_rgbrc: break;
-//        case NS_rtf::LN_shd: break;
-//        case NS_rtf::LN_cellShd: break;
-//        case NS_rtf::LN_cellTopColor: break;
-//        case NS_rtf::LN_cellLeftColor: break;
-//        case NS_rtf::LN_cellBottomColor: break;
-//        case NS_rtf::LN_cellRightColor: break;
-
-//        case NS_rtf::LN_LISTTABLE: break;
-//        case NS_rtf::LN_LFOTABLE: break;
-//        case NS_rtf::LN_FONTTABLE: break;
-//        case NS_rtf::LN_STYLESHEET: break;
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-        case NS_ooxml::LN_CT_AbstractNum_abstractNumId:
-        {    
-            sal_Int32 nVal = rVal.getString().toInt32();
-            m_pImpl->m_pCurrentEntry->nAbstractNumId = nVal;
-            m_pImpl->m_pCurrentEntry->nListId = nVal;
-        }
-        break;
-        case NS_ooxml::LN_CT_Ind_left:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_INDENT_AT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
-            break;
-        case NS_ooxml::LN_CT_Ind_hanging:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100( nIntValue ) ));
-        break;
-        case NS_ooxml::LN_CT_Ind_firstLine:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_FIRST_LINE_INDENT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
-        break;
-        case NS_ooxml::LN_CT_Lvl_ilvl: //overrides previous level - unsupported
-        case NS_ooxml::LN_CT_Lvl_tplc: //template code - unsupported
-        case NS_ooxml::LN_CT_Lvl_tentative: //marks level as unused in the document - unsupported
-        break;
-        case NS_ooxml::LN_CT_TabStop_pos:
-        {
-            //no paragraph attributes in ListTable char style sheets
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nTabstop = ConversionHelper::convertTwipToMM100( nIntValue );
-        }
-        break;
-        default:
-        {
-#if OSL_DEBUG_LEVEL > 0
-            ::rtl::OString sMessage( "ListTable::attribute() - Id: ");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 10 );
-            sMessage += ::rtl::OString(" / 0x");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 16 );
-            sMessage += ::rtl::OString(" value: ");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 10 );
-            sMessage += ::rtl::OString(" / 0x");
-            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 16 );
-            OSL_ENSURE( false, sMessage.getStr()); //
-#endif
-        }
-    }
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::sprm(Sprm & rSprm)
-{
-    //fill the attributes of the style sheet
-    sal_uInt32 nSprmId = rSprm.getId();
-    if( m_pImpl->m_pCurrentEntry.get() ||
-        nSprmId == NS_ooxml::LN_CT_Numbering_abstractNum || 
-        nSprmId == NS_ooxml::LN_CT_Numbering_num )
-    {
-        sal_Int32 nIntValue = rSprm.getValue()->getInt();
-        /* WRITERFILTERSTATUS: table: ListTable_sprm */
-        switch( nSprmId )
-        {
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            case NS_ooxml::LN_CT_Numbering_abstractNum:
-            {
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                {
-                    //create a new list entry
-                    OSL_ENSURE( !m_pImpl->m_pCurrentEntry.get(), "current entry has to be NULL here");
-                    m_pImpl->m_pCurrentEntry.reset( new ListEntry );
-                    pProperties->resolve( *this );
-                    //append it to the table
-                    m_pImpl->m_aListEntries.push_back( m_pImpl->m_pCurrentEntry );
-                    m_pImpl->m_pCurrentEntry = ListEntryPtr();
-                }
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            case NS_ooxml::LN_CT_Numbering_num:
-            {
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                {
-                    Numbering_numHdlPtr pNumHdl( new Numbering_numHdl( *this ) );
-                    pProperties->resolve(*pNumHdl);
-                    //todo: is the order of numberings guaranteed?
-                    //sal_Int32       pNumhdl->GetNumId();
-                    m_pImpl->m_rDMapper.AddListIDToLFOTable( pNumHdl->GetAbstractNumId() );
-                }
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-            case NS_ooxml::LN_CT_AbstractNum_multiLevelType:
-            break;
-            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
-            case NS_rtf::LN_TPLC:
-                m_pImpl->m_pCurrentEntry->nTPLC = nIntValue;
-            break;
-            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-            case NS_ooxml::LN_CT_AbstractNum_lvl:
-            {
-                m_pImpl->AddLevel();
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-                }
-            break;
-// not a useful number in ooxml
-//            case NS_rtf::LN_LSID:
-//                m_pImpl->m_pCurrentEntry->nListId = nIntValue;
-//            break;
-            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-            case NS_rtf::LN_RGBXCHNUMS: break;
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_ISTARTAT:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_NFC:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_JC:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_FLEGAL:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_FNORESTART:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_FPREV:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_FPREVSPACE:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_FWORD6:
-            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
-            case NS_rtf::LN_IXCHFOLLOW:
-                ApplyLevelValues( nSprmId, nIntValue );
-            break;
-            case NS_ooxml::LN_CT_Lvl_lvlText:
-            case NS_ooxml::LN_CT_Lvl_rPr : //contains LN_EG_RPrBase_rFonts
-            {    
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_NumLvl_lvl:
-            {   
-                // overwrite level
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_Lvl_lvlJc:
-            {
-                static sal_Int16 aWWAlignments[ ] = 
-                {
-                    text::HoriOrientation::LEFT,
-                    text::HoriOrientation::CENTER,
-                    text::HoriOrientation::RIGHT
-                };
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert( 
-                    PROP_ADJUST, true, uno::makeAny( aWWAlignments[ nIntValue ] ) );
-                    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-            }
-            break;
-            case NS_ooxml::LN_CT_Lvl_pPr:
-            case NS_ooxml::LN_CT_PPrBase_ind:
-            {    
-                //todo: how to handle paragraph properties within numbering levels (except LeftIndent and FirstLineIndent)?
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_PPrBase_tabs:
-            case NS_ooxml::LN_CT_Tabs_tab:
-            {
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if(pProperties.get())
-                    pProperties->resolve(*this);
-            }
-            break;
-            case NS_ooxml::LN_CT_Lvl_suff:
-                //todo: currently unsupported suffix 
-                //can be: "none", "space", "tab"
-            break;
-            case NS_ooxml::LN_EG_RPrBase_rFonts: //contains font properties
-            case NS_ooxml::LN_EG_RPrBase_color:
-            case NS_ooxml::LN_EG_RPrBase_u:
-            case NS_sprm::LN_CHps:    // sprmCHps
-            case NS_ooxml::LN_EG_RPrBase_lang:
-            case NS_ooxml::LN_EG_RPrBase_eastAsianLayout:
-                //no break!
-            default:
-                if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-                {
-                    m_pImpl->m_rDMapper.PushListProperties( m_pImpl->m_pCurrentEntry->pCurrentProperties );
-                    m_pImpl->m_rDMapper.sprm( rSprm );
-                    m_pImpl->m_rDMapper.PopListProperties();
-                }
-        }    
-    }
-}
-/*-- 12.11.2007 09:36:09---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void    ListTable::ApplyLevelValues( sal_Int32 nId, sal_Int32 nIntValue)
-{
-    if(m_pImpl->m_pCurrentEntry->pCurrentProperties.get())
-    switch(nId)
-    {
-        case NS_rtf::LN_ISTARTAT:
-                m_pImpl->m_pCurrentEntry->pCurrentProperties->nIStartAt = nIntValue;
-        break;
-        case NS_rtf::LN_NFC:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nNFC = nIntValue;
-        break;
-        case NS_rtf::LN_JC:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nJC = nIntValue;
-        break;
-        case NS_rtf::LN_FLEGAL:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFLegal = nIntValue;
-        break;
-        case NS_rtf::LN_FNORESTART:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFNoRestart = nIntValue;
-        break;
-        case NS_rtf::LN_FPREV:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFPrev = nIntValue;
-        break;
-        case NS_rtf::LN_FPREVSPACE:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFPrevSpace = nIntValue;
-        break;
-        case NS_rtf::LN_FWORD6:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nFWord6 = nIntValue;
-        break;
-        case NS_rtf::LN_IXCHFOLLOW:
-            m_pImpl->m_pCurrentEntry->pCurrentProperties->nXChFollow = nIntValue;
-        break;
-        default:
-            OSL_ENSURE( false, "this line should never be reached");
-    }
-}
-/*-- 23.06.2006 12:04:33---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::entry(int, writerfilter::Reference<Properties>::Pointer_t ref)
-{
-    
-    if( m_pImpl->m_rDMapper.IsOOXMLImport() )
-    {
-        ref->resolve(*this);
-    }
-    else
-    {
-        //create a new list entry
-        OSL_ENSURE( !m_pImpl->m_pCurrentEntry.get(), "current entry has to be NULL here");
-        m_pImpl->m_pCurrentEntry.reset( new ListEntry );
-        ref->resolve(*this);
-        //append it to the table
-        m_pImpl->m_aListEntries.push_back( m_pImpl->m_pCurrentEntry );
-        m_pImpl->m_pCurrentEntry = ListEntryPtr();
-    }
-}
-/*-- 26.06.2006 10:27:55---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-sal_uInt32 ListTable::size() const
-{
-    return m_pImpl->m_aListEntries.size();
-}
-
-rtl::OUString ListTable::GetStyleName( sal_Int32 nListId )
-{
-    rtl::OUString sStyleName( rtl::OUString::createFromAscii( "WWNum" ) );
-    sStyleName += rtl::OUString::valueOf( nListId + 1 );
-
-    return sStyleName;
-}
-
-void ListTable::CreateNumberingRules( )
-{
-    uno::Reference< container::XIndexReplace > xRet;
-    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
-    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
-    
-    uno::Reference< container::XNameContainer > xStyles;
-
-    try
-    {
-        uno::Reference< style::XStyleFamiliesSupplier > xFamilies( m_pImpl->m_xFactory, uno::UNO_QUERY_THROW );
-        uno::Any oFamily = xFamilies->getStyleFamilies( )->getByName( rtl::OUString::createFromAscii( "NumberingStyles" ) );
-
-        oFamily >>= xStyles;
-    }
-    catch ( const uno::Exception )
-    {
-    }
-
-    for(; aIt != aEndIt; ++aIt)
-    {
-        if( !(*aIt)->m_xNumRules.is() && m_pImpl->m_xFactory.is() && xStyles.is( ) )
-        {
-            try
-            {
-                // Create the numbering style
-                uno::Reference< beans::XPropertySet > xStyle (
-                    m_pImpl->m_xFactory->createInstance(
-                        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.NumberingStyle"))),
-                    uno::UNO_QUERY_THROW );
-
-                rtl::OUString sStyleName = GetStyleName( ( *aIt )->nListId );
-#if DEBUG
-                clog << "Creating numbering style: ";
-                clog << rtl::OUStringToOString( sStyleName, RTL_TEXTENCODING_UTF8 ).getStr( );
-                clog << endl;
-#endif
-
-                xStyles->insertByName( sStyleName, makeAny( xStyle ) );
-                
-                uno::Any oStyle = xStyles->getByName( sStyleName );
-                xStyle.set( oStyle, uno::UNO_QUERY_THROW );
-                
-                PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-                uno::Any aRules = xStyle->getPropertyValue( aPropNameSupplier.GetName( PROP_NUMBERING_RULES ) );
-                aRules >>= ( *aIt )->m_xNumRules;
-
-                //now fill the numbering levels appropriately
-                ::std::vector< ListPropertyMapPtr >::const_iterator aIter = (*aIt)->aLevelProperties.begin();
-                ::std::vector< ListPropertyMapPtr >::const_iterator aEnd = (*aIt)->aLevelProperties.end();
-                sal_Int32 nLevel = 0;
-                while(aIter != aEnd)
-                {
-                    PropertyValueVector_t aCharStyleProperties;
-                    uno::Sequence< beans::PropertyValue> aValues = (*aIter)->GetPropertyValuesList(aCharStyleProperties);
-                    if( aCharStyleProperties.size() )
-                    {
-                        //create (or find) a character style containing the character attributes of the symbol
-                        //and apply it to the numbering level
-                        ::rtl::OUString sStyle = m_pImpl->m_rDMapper.getOrCreateCharStyle( aCharStyleProperties );
-                        aValues.realloc( aValues.getLength() + 1);
-                        aValues[aValues.getLength() - 1].Name = aPropNameSupplier.GetName( PROP_CHAR_STYLE_NAME );
-                        aValues[aValues.getLength() - 1].Value <<= sStyle;
-                    }    
-                    //now parse the text to find %n from %1 to %nLevel+1
-                    //everything before the first % and the last %x is prefix and suffix
-                    ::rtl::OUString sLevelText( (*aIter)->sBulletChar );
-                    sal_Int32 nCurrentIndex = 0;
-                    sal_Int32 nFound = sLevelText.indexOf( '%', nCurrentIndex );
-                    if( nFound > 0 )
-                    {
-                        ::rtl::OUString sPrefix = sLevelText.copy( 0, nFound );
-                        aValues.realloc( aValues.getLength() + 1 );
-                        aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_PREFIX, sPrefix);
-                        sLevelText = sLevelText.copy( nFound );
-                    } 
-                    sal_Int32 nMinLevel = nLevel;
-                    //now the text should either be empty or start with %
-                    nFound = 0;
-                    while( nFound >= 0 )
-                    {
-                        if( sLevelText.getLength() > 1 )
-                        {
-                            sal_Unicode cLevel = sLevelText.getStr()[1];
-                            if( cLevel >= '1' && cLevel <= '9' )
-                            {
-                                if( cLevel - '1' < nMinLevel )
-                                    nMinLevel = cLevel - '1';
-                                //remove first char - next char is removed later
-                                sLevelText = sLevelText.copy( 1 );
-                            }
-                        }    
-                        //remove old '%' or number 
-                        sLevelText = sLevelText.copy( 1 );
-                        nCurrentIndex = 0;
-                        nFound = sLevelText.indexOf( '%', nCurrentIndex );
-                        //remove the text before the next %
-                        if(nFound > 0)
-                            sLevelText = sLevelText.copy( nFound -1 );
-                    }
-                    if( nMinLevel < nLevel )
-                    {
-                        aValues.realloc( aValues.getLength() + 1);
-                        aValues[ aValues.getLength() - 1 ] = 
-                            MAKE_PROPVAL(PROP_PARENT_NUMBERING, sal_Int16( nLevel - nMinLevel + 1));
-                    }
-                    aValues.realloc( aValues.getLength() + 1);
-                    aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_SUFFIX, sLevelText);
-
-                    aValues.realloc( aValues.getLength() + 1);
-                    aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL( PROP_POSITION_AND_SPACE_MODE, 
-                            sal_Int16( text::PositionAndSpaceMode::LABEL_ALIGNMENT ) );
-                    
-#if DEBUG
-                clog << endl << "Numbering rule properties - " << nLevel << endl;
-                for ( sal_Int32 i = 0, len = aValues.getLength( ); i < len; i++ )
-                {
-                    beans::PropertyValue aVal = aValues[i];
-                    clog << "    " << rtl::OUStringToOString( aVal.Name, RTL_TEXTENCODING_UTF8 ).getStr( );
-                    clog << ": ";
-                    rtl::OUString sVal;
-                    sal_Int32 nVal;
-                    if ( aVal.Value >>= sVal )
-                    {
-                        clog << rtl::OUStringToOString( sVal, RTL_TEXTENCODING_UTF8 ).getStr( );
-                    }
-                    else if ( aVal.Value >>= nVal )
-                    {
-                        clog << nVal;
-                    }
-                    clog << endl;
-                }
-#endif
-
-                    (*aIt)->m_xNumRules->replaceByIndex(nLevel, uno::makeAny(aValues));
-                    ++aIter;
-                    ++nLevel;
-                }
-            
-                // Create the numbering style for these rules 
-                rtl::OUString sNumRulesName = aPropNameSupplier.GetName( PROP_NUMBERING_RULES );
-                xStyle->setPropertyValue( 
-                        sNumRulesName, 
-                        uno::makeAny( ( *aIt )->m_xNumRules ) );
-            }
-            catch( const uno::Exception& rEx)
-            {
-                (void)rEx;
-                OSL_ENSURE( false, "ListTable::CreateNumberingRules");
-            }
-        }
-    }
-}
-
-/*-- 26.06.2006 10:33:56---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-uno::Reference< container::XIndexReplace > ListTable::GetNumberingRules(sal_Int32 nListId)
-{
-    uno::Reference< container::XIndexReplace > xRet;
-    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
-    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
-    for(; aIt != aEndIt; ++aIt)
-    {
-        if((*aIt)->nListId == nListId)
-        {
-            xRet = (*aIt)->m_xNumRules;
-            break;
-        }
-    }
-    return xRet;
-}
-/*-- 19.11.2007 13:25:32---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::setOverwriteLevel(sal_Int32 nAbstractNumId, sal_Int32 nLevel)
-{
-    m_nOverwriteListId = nAbstractNumId;
-    m_nOverwriteLevel = nLevel;
-    OSL_ENSURE(!m_pImpl->m_pCurrentEntry.get(), "where to put the overwrite level");
-    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
-    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
-    for(; aIt != aEndIt; ++aIt)
-    {
-        if( (*aIt)->nListId == nAbstractNumId )
-        {
-            m_pImpl->m_pCurrentEntry = *aIt;
-            break;
-        }
-    }
-    OSL_ENSURE( m_pImpl->m_pCurrentEntry.get(), "list not found");
-}
-/*-- 19.11.2007 13:25:32---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void ListTable::resetOverwrite()
-{
-    m_nOverwriteListId =  -1;
-    m_nOverwriteLevel = -1;
-    m_pImpl->m_pCurrentEntry.reset();
-}
-
-}//namespace dmapper
-}//namespace writerfilter
-
diff --git writerfilter/source/dmapper/ListTable.hxx writerfilter/source/dmapper/ListTable.hxx
deleted file mode 100644
index 65cc216..0000000
--- writerfilter/source/dmapper/ListTable.hxx
+++ /dev/null
@@ -1,92 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: ListTable.hxx,v $
- * $Revision: 1.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef INCLUDED_LISTTABLE_HXX
-#define INCLUDED_LISTTABLE_HXX
-
-#include <WriterFilterDllApi.hxx>
-#include <PropertyMap.hxx>
-#include <resourcemodel/WW8ResourceModel.hxx>
-
-namespace com{ namespace sun { namespace star {
-    namespace text{
-        class XTextDocument;
-    }
-    namespace container{
-        class XIndexReplace;
-    }
-    namespace lang{
-        class XMultiServiceFactory;
-    }
-}}}
-
-namespace writerfilter {
-namespace dmapper
-{
-class DomainMapper;
-struct ListTable_Impl;
-class WRITERFILTER_DLLPRIVATE ListTable :
-        public Properties,
-        public Table
-{
-    ListTable_Impl   *m_pImpl;
-    sal_Int32       m_nOverwriteListId;
-    sal_Int32       m_nOverwriteLevel;
-
-    void    ApplyLevelValues( sal_Int32 nId, sal_Int32 nIntValue);
-public:
-    ListTable(
-            DomainMapper& rDMapper,
-            const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > xFactory);
-    virtual ~ListTable();
-
-    // Properties
-    virtual void attribute(Id Name, Value & val);
-    virtual void sprm(Sprm & sprm);
-
-    // Table
-    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
-
-    // BinaryObj
-//    virtual void data(const sal_Int8* buf, size_t len,
-//                      writerfilter::Reference<Properties>::Pointer_t ref);
-
-    sal_uInt32          size() const;
-    rtl::OUString GetStyleName( sal_Int32 nListId );
-    void CreateNumberingRules( );
-    ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexReplace >
-            GetNumberingRules(sal_Int32 nListId);
-
-    void setOverwriteLevel(sal_Int32 nAbstractNumId, sal_Int32 nLevel);
-    void resetOverwrite();
-};
-typedef boost::shared_ptr< ListTable >          ListTablePtr;
-}}
-
-#endif //
diff --git writerfilter/source/dmapper/NumberingManager.cxx writerfilter/source/dmapper/NumberingManager.cxx
new file mode 100644
index 0000000..65788d0
--- /dev/null
+++ writerfilter/source/dmapper/NumberingManager.cxx
@@ -0,0 +1,995 @@
+#include "ConversionHelper.hxx"
+#include "NumberingManager.hxx"
+#include "StyleSheetTable.hxx"
+#include "PropertyIds.hxx"
+
+#include <doctok/resourceids.hxx>
+#include <doctok/sprmids.hxx>
+#include <ooxml/resourceids.hxx>
+
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/NumberingType.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/PositionAndSpaceMode.hpp>
+#include <com/sun/star/text/XChapterNumberingSupplier.hpp>
+
+using namespace rtl;
+using namespace com::sun::star;
+
+#define MAKE_PROPVAL(NameId, Value) \
+    beans::PropertyValue(aPropNameSupplier.GetName(NameId), 0, uno::makeAny(Value), beans::PropertyState_DIRECT_VALUE )
+
+#define OUSTR_TO_C( x )  OUStringToOString( x, RTL_TEXTENCODING_UTF8 ).getStr( )
+
+#define NUMBERING_MAX_LEVELS    10
+
+
+namespace writerfilter {
+namespace dmapper {
+
+//---------------------------------------------------  Utility functions
+    
+void lcl_printProperties( uno::Sequence< beans::PropertyValue > aProps )
+{
+    sal_Int32 nLen = aProps.getLength( );
+    for ( sal_Int32 i = 0; i < nLen; i++ )
+    {
+        uno::Any aValue = aProps[i].Value;
+        sal_Int32 nValue;
+        OUString sValue;
+
+        if ( !( aValue >>= sValue ) && ( aValue >>= nValue ) )
+            sValue = OUString::valueOf( nValue );
+
+        fprintf( stderr, "Property %s: %s\n", 
+                OUSTR_TO_C( aProps[i].Name ),
+                OUSTR_TO_C( sValue ) );
+    }
+}
+
+sal_Int32 lcl_findProperty( uno::Sequence< beans::PropertyValue > aProps, OUString sName )
+{
+    sal_Int32 i = 0;
+    sal_Int32 nLen = aProps.getLength( );
+    sal_Int32 nPos = -1;
+
+    while ( nPos == -1 && i < nLen )
+    {
+        if ( aProps[i].Name.equals( sName ) )
+            nPos = i;
+        else
+            i++;
+    }
+
+    return nPos;
+}
+
+void lcl_mergeProperties( uno::Sequence< beans::PropertyValue >& aSrc,
+        uno::Sequence< beans::PropertyValue >& aDst )
+{
+    for ( sal_Int32 i = 0, nSrcLen = aSrc.getLength( ); i < nSrcLen; i++ )
+    {
+        // Look for the same property in aDst
+        sal_Int32 nPos = lcl_findProperty( aDst, aSrc[i].Name );
+        if ( nPos >= 0 )
+        {
+            // Replace the property value by the one in aSrc
+            aDst[nPos] = aSrc[i];
+        }
+        else
+        {
+            // Simply add the new value
+            aDst.realloc( aDst.getLength( ) + 1 );
+            aDst[ aDst.getLength( ) - 1 ] = aSrc[i];
+        }
+    }
+}
+
+//--------------------------------------------  ListLevel implementation
+void ListLevel::SetValue( Id nId, sal_Int32 nValue )
+{
+    switch( nId )
+    {
+        case NS_rtf::LN_ISTARTAT:
+            m_nIStartAt = nValue;
+        break;
+        case NS_rtf::LN_NFC:
+            m_nNFC = nValue;
+        break;
+        case NS_rtf::LN_JC:
+            m_nJC = nValue;
+        break;
+        case NS_rtf::LN_FLEGAL:
+            m_nFLegal = nValue;
+        break;
+        case NS_rtf::LN_FNORESTART:
+            m_nFNoRestart = nValue;
+        break;
+        case NS_rtf::LN_FPREV:
+            m_nFPrev = nValue;
+        break;
+        case NS_rtf::LN_FPREVSPACE:
+            m_nFPrevSpace = nValue;
+        break;
+        case NS_rtf::LN_FWORD6:
+            m_nFWord6 = nValue;
+        break;
+        case NS_rtf::LN_IXCHFOLLOW:
+            m_nXChFollow = nValue;
+        break;
+        case NS_ooxml::LN_CT_TabStop_pos:
+            m_nTabstop = nValue;
+        break;
+        default:
+            OSL_ENSURE( false, "this line should never be reached");
+    }
+}
+
+sal_Int16 ListLevel::GetParentNumbering( OUString sText, sal_Int16 nLevel, 
+        OUString& rPrefix, OUString& rSuffix )
+{
+    sal_Int16 nParentNumbering = nLevel;
+
+    //now parse the text to find %n from %1 to %nLevel+1
+    //everything before the first % and the last %x is prefix and suffix
+    OUString sLevelText( sText );
+    sal_Int32 nCurrentIndex = 0;
+    sal_Int32 nFound = sLevelText.indexOf( '%', nCurrentIndex );
+    if( nFound > 0 )
+    {
+        rPrefix = sLevelText.copy( 0, nFound );
+        sLevelText = sLevelText.copy( nFound );
+    } 
+    sal_Int32 nMinLevel = nLevel;
+    //now the text should either be empty or start with %
+    nFound = 0;
+    while( nFound >= 0 )
+    {
+        if( sLevelText.getLength() > 1 )
+        {
+            sal_Unicode cLevel = sLevelText.getStr()[1];
+            if( cLevel >= '1' && cLevel <= '9' )
+            {
+                if( cLevel - '1' < nMinLevel )
+                    nMinLevel = cLevel - '1';
+                //remove first char - next char is removed later
+                sLevelText = sLevelText.copy( 1 );
+            }
+        }    
+        //remove old '%' or number 
+        sLevelText = sLevelText.copy( 1 );
+        nCurrentIndex = 0;
+        nFound = sLevelText.indexOf( '%', nCurrentIndex );
+        //remove the text before the next %
+        if(nFound > 0)
+            sLevelText = sLevelText.copy( nFound -1 );
+    }
+    if( nMinLevel < nLevel )
+    {
+        nParentNumbering = sal_Int16( nLevel - nMinLevel + 1);
+    }
+
+    rSuffix = sLevelText;
+
+    return nParentNumbering;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetProperties( )
+{
+    uno::Sequence< beans::PropertyValue > aLevelProps = GetLevelProperties( );
+    if ( m_pParaStyle.get( ) )
+    {
+        // Merge with the paragraph properties
+        uno::Sequence< beans::PropertyValue > aParaProps = GetParaProperties( );
+        lcl_mergeProperties( aParaProps, aLevelProps );
+    }
+    return aLevelProps;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetCharStyleProperties( )
+{
+    PropertyValueVector_t rProperties;
+    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+    _PropertyMap::const_iterator aMapIter = begin();
+    _PropertyMap::const_iterator aEndIter = end();
+    for( ; aMapIter != aEndIter; ++aMapIter )
+    {
+        switch( aMapIter->first.eId )
+        {
+            case PROP_ADJUST:
+            case PROP_INDENT_AT:
+            case PROP_FIRST_LINE_INDENT:
+            case PROP_FIRST_LINE_OFFSET:
+            case PROP_LEFT_MARGIN:
+            case PROP_CHAR_FONT_NAME:
+                // Do nothing: handled in the GetPropertyValues method
+            break;
+            default: 
+            {
+                rProperties.push_back(
+                        beans::PropertyValue( 
+                            aPropNameSupplier.GetName( aMapIter->first.eId ), 0, 
+                            aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
+            }
+        }
+    }
+
+    uno::Sequence< beans::PropertyValue > aRet( rProperties.size() );
+    beans::PropertyValue* pValues = aRet.getArray();
+    PropertyValueVector_t::const_iterator aIt = rProperties.begin();
+    PropertyValueVector_t::const_iterator aEndIt = rProperties.end();
+    for(sal_uInt32 nIndex = 0; aIt != aEndIt; ++aIt,++nIndex)
+    {
+        pValues[nIndex] = *aIt;
+    }
+    return aRet;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetLevelProperties( )
+{
+    const sal_Int16 aWWToUnoAdjust[] =
+    {
+        text::HoriOrientation::LEFT,
+        text::HoriOrientation::CENTER,
+        text::HoriOrientation::RIGHT,
+    };
+
+    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+    PropertyValueVector_t aNumberingProperties;
+
+    if( m_nIStartAt >= 0)
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_START_WITH, (sal_Int16)m_nIStartAt) );
+
+    sal_Int16 nNumberFormat = ConversionHelper::ConvertNumberingType(m_nNFC);
+    if( m_nNFC >= 0)
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_NUMBERING_TYPE, nNumberFormat ));
+
+    if( m_nJC >= 0 && m_nJC <= sal::static_int_cast<sal_Int32>(sizeof(aWWToUnoAdjust) / sizeof(sal_Int16)) )
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_ADJUST, aWWToUnoAdjust[m_nJC]));
+
+    // todo: this is not the bullet char
+    if( nNumberFormat == style::NumberingType::CHAR_SPECIAL && m_sBulletChar.getLength() )
+        aNumberingProperties.push_back( MAKE_PROPVAL(PROP_BULLET_CHAR, m_sBulletChar.copy(0,1)));
+
+    aNumberingProperties.push_back( MAKE_PROPVAL( PROP_LISTTAB_STOP_POSITION, m_nTabstop ) );
+
+    //TODO: handling of nFLegal?
+    //TODO: nFNoRestart lower levels do not restart when higher levels are incremented, like:
+    //1.
+    //1.1
+    //2.2
+    //2.3
+    //3.4
+    //
+
+    if( m_nFWord6 > 0) //Word 6 compatibility
+    {
+        if( m_nFPrev == 1)
+            aNumberingProperties.push_back( MAKE_PROPVAL( PROP_PARENT_NUMBERING, (sal_Int16) NUMBERING_MAX_LEVELS ));
+        //TODO: prefixing space     nFPrevSpace;     - has not been used in WW8 filter
+    }
+
+//    TODO: sRGBXchNums;     array of inherited numbers
+
+//    TODO: nXChFollow; following character 0 - tab, 1 - space, 2 - nothing
+
+    _PropertyMap::const_iterator aMapIter = begin();
+    _PropertyMap::const_iterator aEndIter = end();
+    for( ; aMapIter != aEndIter; ++aMapIter )
+    {
+        switch( aMapIter->first.eId )
+        {
+            case PROP_ADJUST:
+            case PROP_INDENT_AT:
+            case PROP_FIRST_LINE_INDENT:
+            case PROP_FIRST_LINE_OFFSET:
+            case PROP_LEFT_MARGIN:
+                aNumberingProperties.push_back(
+                    beans::PropertyValue( aPropNameSupplier.GetName( aMapIter->first.eId ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
+            break;
+            case PROP_CHAR_FONT_NAME:
+                aNumberingProperties.push_back(
+                    beans::PropertyValue( aPropNameSupplier.GetName( PROP_BULLET_FONT_NAME ), 0, aMapIter->second, beans::PropertyState_DIRECT_VALUE ));
+            break;
+            default: 
+            {
+                // Handled in GetCharStyleProperties method
+            }
+
+        }
+    }
+    
+    uno::Sequence< beans::PropertyValue > aRet(aNumberingProperties.size());
+    beans::PropertyValue* pValues = aRet.getArray();
+    PropertyValueVector_t::const_iterator aIt = aNumberingProperties.begin();
+    PropertyValueVector_t::const_iterator aEndIt = aNumberingProperties.end();
+    for(sal_uInt32 nIndex = 0; aIt != aEndIt; ++aIt,++nIndex)
+    {
+        pValues[nIndex] = *aIt;
+    }
+    return aRet;
+}
+
+uno::Sequence< beans::PropertyValue > ListLevel::GetParaProperties( )
+{
+    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+    uno::Sequence< beans::PropertyValue > aParaProps = m_pParaStyle->pProperties->GetPropertyValues( );
+    uno::Sequence< beans::PropertyValue > aProps;
+
+    // ParaFirstLineIndent -> FirstLineIndent
+    // ParaLeftMargin -> IndentAt
+
+    OUString sParaIndent = aPropNameSupplier.GetName( 
+            PROP_PARA_FIRST_LINE_INDENT );
+    OUString sFirstLineIndent = aPropNameSupplier.GetName( 
+            PROP_FIRST_LINE_INDENT );
+    OUString sParaLeftMargin = aPropNameSupplier.GetName( 
+            PROP_PARA_LEFT_MARGIN );
+    OUString sIndentAt = aPropNameSupplier.GetName( 
+            PROP_INDENT_AT );
+
+    sal_Int32 nLen = aParaProps.getLength( );
+    for ( sal_Int32 i = 0; i < nLen; i++ )
+    {
+        if ( aParaProps[i].Name.equals( sParaIndent ) )
+        {
+            aProps.realloc( aProps.getLength() + 1 );
+            aProps[aProps.getLength( ) - 1] = aParaProps[i];
+            aProps[aProps.getLength( ) - 1].Name = sFirstLineIndent;
+        }
+        else if ( aParaProps[i].Name.equals( sParaLeftMargin ) )
+        {
+            aProps.realloc( aProps.getLength() + 1 );
+            aProps[aProps.getLength( ) - 1] = aParaProps[i];
+            aProps[aProps.getLength( ) - 1].Name = sIndentAt;
+        }
+        
+    }
+
+    return aProps;
+}
+
+//--------------------------------------- AbstractListDef implementation
+
+AbstractListDef::AbstractListDef( ) :
+    m_nTPLC( -1 )
+    ,m_nSimpleList( -1 )
+    ,m_nRestart( -1 )
+    ,m_nUnsigned( -1 )
+    ,m_nId( -1 )
+{
+}
+
+AbstractListDef::~AbstractListDef( )
+{
+}
+
+void AbstractListDef::SetValue( sal_uInt32 nSprmId, sal_Int32 nValue )
+{
+    switch( nSprmId )
+    {
+        case NS_rtf::LN_TPLC:
+            m_nTPLC = nValue;
+        break;
+        case NS_rtf::LN_FSIMPLELIST:
+            m_nSimpleList = nValue;
+        break;
+        case NS_rtf::LN_FRESTARTHDN:
+            m_nRestart = nValue;
+        break;
+        case NS_rtf::LN_UNSIGNED26_2:
+            m_nUnsigned = nValue;
+        break;
+        default:
+            OSL_ENSURE( false, "this line should never be reached");
+    }
+}
+
+ListLevel::Pointer AbstractListDef::GetLevel( sal_uInt16 nLvl )
+{ 
+    ListLevel::Pointer pLevel;
+    if ( m_aLevels.size( ) > nLvl )
+        pLevel = m_aLevels[ nLvl ];
+    return pLevel;
+}
+
+void AbstractListDef::AddLevel( )
+{
+    ListLevel::Pointer pLevel( new ListLevel );
+    m_pCurrentLevel = pLevel;
+    m_aLevels.push_back( pLevel );
+}
+
+uno::Sequence< uno::Sequence< beans::PropertyValue > > AbstractListDef::GetPropertyValues( )
+{
+    uno::Sequence< uno::Sequence< beans::PropertyValue > > result( sal_Int32( m_aLevels.size( ) ) );
+    uno::Sequence< beans::PropertyValue >* aResult = result.getArray( );
+
+    int nLevels = m_aLevels.size( );
+    for ( int i = 0; i < nLevels; i++ )
+    {
+        aResult[i] = m_aLevels[i]->GetProperties( );
+    }
+
+    return result;
+}
+
+//----------------------------------------------  ListDef implementation
+
+ListDef::ListDef( ) : AbstractListDef( )
+{
+}
+
+ListDef::~ListDef( )
+{
+}
+
+OUString ListDef::GetStyleName( sal_Int32 nId )
+{
+    OUString sStyleName( OUString::createFromAscii( "WWNum" ) );
+    sStyleName += OUString::valueOf( nId );
+
+    return sStyleName;
+}
+
+uno::Sequence< uno::Sequence< beans::PropertyValue > > ListDef::GetPropertyValues( )
+{
+    // [1] Call the same method on the abstract list
+    uno::Sequence< uno::Sequence< beans::PropertyValue > > aAbstract = m_pAbstractDef->GetPropertyValues( );
+    
+    // [2] Call the upper class method
+    uno::Sequence< uno::Sequence< beans::PropertyValue > > aThis = AbstractListDef::GetPropertyValues( );
+    
+    // Merge the results of [2] in [1]
+    sal_Int32 nThisCount = aThis.getLength( );
+    for ( sal_Int32 i = 0; i < nThisCount; i++ )
+    {
+        uno::Sequence< beans::PropertyValue > level = aThis[i];
+        if ( level.getLength( ) == 0 )
+        {
+            // If the the element contains something, merge it
+            lcl_mergeProperties( level, aAbstract[i] );
+        }
+    }
+
+    return aAbstract;
+}
+
+uno::Reference< container::XNameContainer > lcl_getUnoNumberingStyles( 
+       uno::Reference< lang::XMultiServiceFactory > xFactory )
+{
+    uno::Reference< container::XNameContainer > xStyles;
+
+    try
+    {
+        uno::Reference< style::XStyleFamiliesSupplier > xFamilies( xFactory, uno::UNO_QUERY_THROW );
+        uno::Any oFamily = xFamilies->getStyleFamilies( )->getByName( OUString::createFromAscii( "NumberingStyles" ) );
+
+        oFamily >>= xStyles;
+    }
+    catch ( const uno::Exception )
+    {
+    }
+
+    return xStyles;
+}
+
+void ListDef::CreateNumberingRules( DomainMapper& rDMapper,
+        uno::Reference< lang::XMultiServiceFactory> xFactory )
+{
+    // Get the UNO Numbering styles
+    uno::Reference< container::XNameContainer > xStyles = lcl_getUnoNumberingStyles( xFactory );
+
+    // Do the whole thing
+    if( !m_xNumRules.is() && xFactory.is() && xStyles.is( ) )
+    {
+        try
+        {
+            // Create the numbering style
+            uno::Reference< beans::XPropertySet > xStyle (
+                xFactory->createInstance( 
+                    OUString::createFromAscii("com.sun.star.style.NumberingStyle")),
+                uno::UNO_QUERY_THROW );
+
+            rtl::OUString sStyleName = GetStyleName( GetId( ) );
+#if DEBUG
+            fprintf( stderr, "Creating numbering style: %s\n", OUSTR_TO_C( sStyleName ) );
+#endif
+
+            xStyles->insertByName( sStyleName, makeAny( xStyle ) );
+            
+            uno::Any oStyle = xStyles->getByName( sStyleName );
+            xStyle.set( oStyle, uno::UNO_QUERY_THROW );
+            
+            PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+            // Get the default OOo Numbering style rules
+            uno::Any aRules = xStyle->getPropertyValue( aPropNameSupplier.GetName( PROP_NUMBERING_RULES ) );
+            aRules >>= m_xNumRules;
+
+            uno::Sequence< uno::Sequence< beans::PropertyValue > > aProps = GetPropertyValues( );
+
+            sal_Int32 nAbstLevels = m_pAbstractDef->Size( );
+            sal_Int16 nLevel = 0;
+            while ( nLevel < nAbstLevels )
+            {
+                ListLevel::Pointer pAbsLevel = m_pAbstractDef->GetLevel( nLevel );
+                ListLevel::Pointer pLevel = GetLevel( nLevel );
+                
+                // Get the merged level properties
+                uno::Sequence< beans::PropertyValue > aLvlProps = aProps[sal_Int32( nLevel )];
+
+                // Get the char style
+                uno::Sequence< beans::PropertyValue > aAbsCharStyleProps = pAbsLevel->GetCharStyleProperties( );
+                uno::Sequence< beans::PropertyValue >& rAbsCharStyleProps = aAbsCharStyleProps;
+                if ( pLevel.get( ) )
+                {
+                    uno::Sequence< beans::PropertyValue > aCharStyleProps = 
+                        pLevel->GetCharStyleProperties( );
+                    uno::Sequence< beans::PropertyValue >& rCharStyleProps = aCharStyleProps;
+                    lcl_mergeProperties( rAbsCharStyleProps, rCharStyleProps );
+                }
+                    
+                if( aAbsCharStyleProps.getLength() )
+                {
+                    // Change the sequence into a vector
+                    PropertyValueVector_t aStyleProps;
+                    for ( sal_Int32 i = 0, nLen = aAbsCharStyleProps.getLength() ; i < nLen; i++ )
+                    {
+                        aStyleProps.push_back( aAbsCharStyleProps[i] );
+                    }
+
+                    //create (or find) a character style containing the character 
+                    // attributes of the symbol and apply it to the numbering level
+                    OUString sStyle = rDMapper.getOrCreateCharStyle( aStyleProps );
+                    aLvlProps.realloc( aLvlProps.getLength() + 1);
+                    aLvlProps[aLvlProps.getLength() - 1].Name = aPropNameSupplier.GetName( PROP_CHAR_STYLE_NAME );
+                    aLvlProps[aLvlProps.getLength() - 1].Value <<= sStyle;
+                }    
+ 
+                // Get the prefix / suffix / Parent numbering 
+                // and add them to the level properties
+                OUString sText = pAbsLevel->GetBulletChar( );
+                if ( pLevel.get( ) )
+                    sText = pLevel->GetBulletChar( );
+
+                OUString sPrefix;
+                OUString sSuffix;
+                OUString& rPrefix = sPrefix;
+                OUString& rSuffix = sSuffix;
+                sal_Int16 nParentNum = ListLevel::GetParentNumbering(
+                       sText, nLevel, rPrefix, rSuffix );
+
+                aLvlProps.realloc( aLvlProps.getLength( ) + 4 );
+                aLvlProps[ aLvlProps.getLength( ) - 4 ] = MAKE_PROPVAL( PROP_PREFIX, rPrefix );
+                aLvlProps[ aLvlProps.getLength( ) - 3 ] = MAKE_PROPVAL( PROP_SUFFIX, rSuffix );
+                aLvlProps[ aLvlProps.getLength( ) - 2 ] = MAKE_PROPVAL( PROP_PARENT_NUMBERING, nParentNum );
+
+                aLvlProps[ aLvlProps.getLength( ) - 1 ] = MAKE_PROPVAL( PROP_POSITION_AND_SPACE_MODE, 
+                            sal_Int16( text::PositionAndSpaceMode::LABEL_ALIGNMENT ) );
+                // Replace the numbering rules for the level
+                m_xNumRules->replaceByIndex( nLevel, uno::makeAny( aLvlProps ) );
+                
+                // Handle the outline level here
+                StyleSheetEntryPtr pParaStyle = pAbsLevel->GetParaStyle( );
+                if ( pParaStyle.get( ) )
+                {
+                    uno::Reference< text::XChapterNumberingSupplier > xOutlines (
+                        xFactory, uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexReplace > xOutlineRules = 
+                        xOutlines->getChapterNumberingRules( );
+
+                    aLvlProps.realloc( aLvlProps.getLength() + 1 );
+                    aLvlProps[aLvlProps.getLength( ) - 1] = MAKE_PROPVAL( PROP_HEADING_STYLE_NAME, pParaStyle->sConvertedStyleName );
+
+                    xOutlineRules->replaceByIndex( nLevel, uno::makeAny( aLvlProps ) );
+                }
+
+                nLevel++;
+            }
+
+            // Create the numbering style for these rules 
+            OUString sNumRulesName = aPropNameSupplier.GetName( PROP_NUMBERING_RULES );
+            xStyle->setPropertyValue( sNumRulesName, uno::makeAny( m_xNumRules ) );
+        }
+        catch( const uno::Exception& rEx)
+        {
+            OSL_ENSURE( false, "ListTable::CreateNumberingRules");
+        }
+    }
+
+}
+
+//-------------------------------------  NumberingManager implementation
+
+
+ListsManager::ListsManager( DomainMapper& rDMapper, 
+        const uno::Reference< lang::XMultiServiceFactory > xFactory ) :
+    m_rDMapper( rDMapper ),
+    m_xFactory( xFactory )
+{
+}
+
+ListsManager::~ListsManager( )
+{
+}
+
+void ListsManager::attribute( Id nName, Value& rVal )
+{
+    OSL_ENSURE( m_pCurrentDefinition.get(), "current entry has to be set here");
+    if(!m_pCurrentDefinition.get())
+        return ;
+    int nIntValue = rVal.getInt();
+
+    ListLevel::Pointer pCurrentLvl = m_pCurrentDefinition->GetCurrentLevel( );
+
+
+    /* WRITERFILTERSTATUS: table: ListTable_attributedata */
+    switch(nName)
+    {
+        /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
+        case NS_rtf::LN_RGBXCHNUMS:
+            if(pCurrentLvl.get())
+                pCurrentLvl->AddRGBXchNums( rVal.getString( ) );
+        break;
+        /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
+        case NS_ooxml::LN_CT_LevelText_val:
+        {    
+            //this strings contains the definition of the level
+            //the level number is marked as %n
+            //these numbers can be mixed randomly toghether with seperators pre- and suffixes
+            //the Writer supports only a number of upper levels to show, separators is always a dot
+            //and each level can have a prefix and a suffix
+            if(pCurrentLvl.get())
+                pCurrentLvl->SetBulletChar( rVal.getString() );
+        }
+        break;
+//        case NS_rtf::LN_ISTD: break;
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_ISTARTAT:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_NFC:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_JC:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FLEGAL:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FNORESTART:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FPREV:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FPREVSPACE:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_FWORD6:
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_IXCHFOLLOW:
+            if ( pCurrentLvl.get( ) )
+                pCurrentLvl->SetValue( nName, sal_Int32( nIntValue ) );
+        break;
+        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+        case NS_rtf::LN_UNUSED5_7:
+            //unused
+        break;
+        /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+        case NS_rtf::LN_RGISTD:
+            m_pCurrentDefinition->AddRGISTD( rVal.getString() );
+        break;
+        case NS_ooxml::LN_CT_Num_numId:
+            m_pCurrentDefinition->SetId( rVal.getString().toInt32( ) );
+        break; 
+        case NS_rtf::LN_LSID:
+            m_pCurrentDefinition->SetId( nIntValue );
+        break;
+        case NS_rtf::LN_TPLC:
+        case NS_rtf::LN_FSIMPLELIST:
+        case NS_rtf::LN_FRESTARTHDN:
+        case NS_rtf::LN_UNSIGNED26_2:
+            m_pCurrentDefinition->SetValue( nName, nIntValue );
+        break;
+        case NS_ooxml::LN_CT_NumLvl_ilvl:
+        case NS_rtf::LN_LISTLEVEL:
+        {
+            //add a new level to the level vector and make it the current one
+            m_pCurrentDefinition->AddLevel();
+
+            writerfilter::Reference<Properties>::Pointer_t pProperties;
+            if((pProperties = rVal.getProperties()).get())
+                pProperties->resolve(*this);
+        }
+        break;
+        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+        case NS_ooxml::LN_CT_AbstractNum_abstractNumId:
+        {   
+            // This one corresponds to the AbstractNum Id definition
+            // The reference to the abstract num is in the sprm method
+            sal_Int32 nVal = rVal.getString().toInt32();
+            m_pCurrentDefinition->SetId( nVal );
+        }
+        break;
+        case NS_ooxml::LN_CT_Ind_left:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            pCurrentLvl->Insert(
+                PROP_INDENT_AT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
+            break;
+        case NS_ooxml::LN_CT_Ind_hanging:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            pCurrentLvl->Insert(
+                PROP_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100( nIntValue ) ));
+        break;
+        case NS_ooxml::LN_CT_Ind_firstLine:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            pCurrentLvl->Insert(
+                PROP_FIRST_LINE_INDENT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
+        break;
+        case NS_ooxml::LN_CT_Lvl_ilvl: //overrides previous level - unsupported
+        case NS_ooxml::LN_CT_Lvl_tplc: //template code - unsupported
+        case NS_ooxml::LN_CT_Lvl_tentative: //marks level as unused in the document - unsupported
+        break;
+        case NS_ooxml::LN_CT_TabStop_pos:
+        {
+            //no paragraph attributes in ListTable char style sheets
+            if ( pCurrentLvl.get( ) )
+                pCurrentLvl->SetValue( nName, 
+                    ConversionHelper::convertTwipToMM100( nIntValue ) );
+        }
+        break;
+        case NS_ooxml::LN_CT_TabStop_val:
+        {
+            // TODO Do something of that
+        }
+        break;
+        default:
+        {
+#if OSL_DEBUG_LEVEL > 0
+            ::rtl::OString sMessage( "ListTable::attribute() - Id: ");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 10 );
+            sMessage += ::rtl::OString(" / 0x");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nName ), 16 );
+            sMessage += ::rtl::OString(" value: ");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 10 );
+            sMessage += ::rtl::OString(" / 0x");
+            sMessage += ::rtl::OString::valueOf( sal_Int32( nIntValue ), 16 );
+            OSL_ENSURE( false, sMessage.getStr()); //
+#endif
+        }
+    }
+}
+
+void ListsManager::sprm( Sprm& rSprm )
+{
+    //fill the attributes of the style sheet
+    sal_uInt32 nSprmId = rSprm.getId();
+    if( m_pCurrentDefinition.get() ||
+        nSprmId == NS_ooxml::LN_CT_Numbering_abstractNum || 
+        nSprmId == NS_ooxml::LN_CT_Numbering_num )
+    {
+        sal_Int32 nIntValue = rSprm.getValue()->getInt();
+        /* WRITERFILTERSTATUS: table: ListTable_sprm */
+        switch( nSprmId )
+        {
+            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_Numbering_abstractNum:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                {
+                    //create a new Abstract list entry
+                    OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+                    m_pCurrentDefinition.reset( new AbstractListDef );
+                    pProperties->resolve( *this );
+                    //append it to the table
+                    m_aAbstractLists.push_back( m_pCurrentDefinition );
+                    m_pCurrentDefinition = AbstractListDef::Pointer();
+                }
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_Numbering_num:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                {
+                    // Create a new list entry
+                    OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+                    ListDef::Pointer listDef( new ListDef );
+                    m_pCurrentDefinition = listDef;
+                    pProperties->resolve( *this );
+                    //append it to the table
+                    m_aLists.push_back( listDef );
+
+                    m_pCurrentDefinition = AbstractListDef::Pointer();
+                }
+            }
+            break;
+            case NS_ooxml::LN_CT_Num_abstractNumId:
+            {
+                sal_Int32 nAbstractNumId = rSprm.getValue()->getInt();
+                ListDef* pListDef = dynamic_cast< ListDef* >( m_pCurrentDefinition.get( ) );
+                if ( pListDef != NULL )
+                {
+                    // The current def should be a ListDef
+                    pListDef->SetAbstractDefinition( 
+                        m_aAbstractLists[ nAbstractNumId ] ); 
+                }
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_AbstractNum_multiLevelType:
+            break;
+            /* WRITERFILTERSTATUS: done: 50, planned: 0, spent: 0 */
+            case NS_rtf::LN_TPLC:
+                m_pCurrentDefinition->SetValue( nSprmId, nIntValue );
+            break;
+            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+            case NS_ooxml::LN_CT_AbstractNum_lvl:
+            {
+                m_pCurrentDefinition->AddLevel();
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+                }
+            break;
+            /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
+            case NS_rtf::LN_RGBXCHNUMS: break;
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_ISTARTAT:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_NFC:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_JC:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FLEGAL:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FNORESTART:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FPREV:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FPREVSPACE:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_FWORD6:
+            /* WRITERFILTERSTATUS: done: 75, planned: 0, spent: 0 */
+            case NS_rtf::LN_IXCHFOLLOW:
+                m_pCurrentDefinition->GetCurrentLevel( )->SetValue( nSprmId, nIntValue );
+            break;
+            case NS_ooxml::LN_CT_Lvl_lvlText:
+            case NS_ooxml::LN_CT_Lvl_rPr : //contains LN_EG_RPrBase_rFonts
+            {    
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_NumLvl_lvl:
+            {   
+                // overwrite level
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_Lvl_lvlJc:
+            {
+                static sal_Int16 aWWAlignments[ ] = 
+                {
+                    text::HoriOrientation::LEFT,
+                    text::HoriOrientation::CENTER,
+                    text::HoriOrientation::RIGHT
+                };
+                m_pCurrentDefinition->GetCurrentLevel( )->Insert( 
+                    PROP_ADJUST, true, uno::makeAny( aWWAlignments[ nIntValue ] ) );
+                    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            }
+            break;
+            case NS_ooxml::LN_CT_Lvl_pPr:
+            case NS_ooxml::LN_CT_PPrBase_ind:
+            {    
+                //todo: how to handle paragraph properties within numbering levels (except LeftIndent and FirstLineIndent)?
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_PPrBase_tabs:
+            case NS_ooxml::LN_CT_Tabs_tab:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
+            break;
+            case NS_ooxml::LN_CT_Lvl_suff:
+                //todo: currently unsupported suffix 
+                //can be: "none", "space", "tab"
+            break;
+            case NS_ooxml::LN_CT_Lvl_pStyle:
+            {
+                OUString sStyleName = rSprm.getValue( )->getString( );
+                ListLevel::Pointer pLevel = m_pCurrentDefinition->GetCurrentLevel( );
+                StyleSheetTablePtr pStylesTable = m_rDMapper.GetStyleSheetTable( );
+                const StyleSheetEntryPtr pStyle = pStylesTable->FindStyleSheetByISTD( sStyleName );
+                pLevel->SetParaStyle( pStyle );
+            }
+            break;
+            case NS_ooxml::LN_EG_RPrBase_rFonts: //contains font properties
+            case NS_ooxml::LN_EG_RPrBase_color:
+            case NS_ooxml::LN_EG_RPrBase_u:
+            case NS_sprm::LN_CHps:    // sprmCHps
+            case NS_ooxml::LN_EG_RPrBase_lang:
+            case NS_ooxml::LN_EG_RPrBase_eastAsianLayout:
+                //no break!
+            default:
+                if( m_pCurrentDefinition->GetCurrentLevel( ).get())
+                {
+                    m_rDMapper.PushListProperties( m_pCurrentDefinition->GetCurrentLevel( ) );
+                    m_rDMapper.sprm( rSprm );
+                    m_rDMapper.PopListProperties();
+                }
+        }    
+    }
+}
+
+void ListsManager::entry( int /* pos */, 
+        writerfilter::Reference<Properties>::Pointer_t ref )
+{
+    if( m_rDMapper.IsOOXMLImport() )
+    {
+        ref->resolve(*this);
+    }
+    else
+    {
+        if ( m_bIsLFOImport ) 
+        {
+            // Create ListDef's
+            OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+            ListDef::Pointer pList( new ListDef() );
+            m_pCurrentDefinition = pList;
+            ref->resolve(*this);
+            //append it to the table
+            m_aLists.push_back( pList );
+            m_pCurrentDefinition = AbstractListDef::Pointer();
+        }
+        else
+        {
+            // Create AbstractListDef's
+            OSL_ENSURE( !m_pCurrentDefinition.get(), "current entry has to be NULL here");
+            m_pCurrentDefinition.reset( new AbstractListDef( ) );
+            ref->resolve(*this);
+            //append it to the table
+            m_aAbstractLists.push_back( m_pCurrentDefinition );
+            m_pCurrentDefinition = AbstractListDef::Pointer();
+        }
+    }
+}
+
+
+ListDef::Pointer ListsManager::GetList( sal_Int32 nId )
+{
+    ListDef::Pointer pList;
+
+    int nLen = m_aLists.size( );
+    int i = 0;
+    while ( !pList.get( ) && i < nLen )
+    {
+        if ( m_aLists[i]->GetId( ) == nId )
+            pList = m_aLists[i];
+        i++;
+    }
+
+    return pList;
+}
+
+void ListsManager::CreateNumberingRules( )
+{
+    // Loop over the definitions
+    std::vector< ListDef::Pointer >::iterator listIt = m_aLists.begin( );
+    for ( ; listIt != m_aLists.end( ); listIt++ )
+    {
+        (*listIt)->CreateNumberingRules( m_rDMapper, m_xFactory );
+    }
+}
+
+} }
diff --git writerfilter/source/dmapper/NumberingManager.hxx writerfilter/source/dmapper/NumberingManager.hxx
new file mode 100644
index 0000000..0f93c27
--- /dev/null
+++ writerfilter/source/dmapper/NumberingManager.hxx
@@ -0,0 +1,224 @@
+#ifndef INCLUDED_NUMBERINGMANAGER_HXX
+#define INCLUDED_NUMBERINGMANAGER_HXX
+
+#include "PropertyMap.hxx"
+
+#include <WriterFilterDllApi.hxx>
+#include <dmapper/DomainMapper.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+
+#include <com/sun/star/container/XIndexReplace.hpp>
+
+namespace writerfilter {
+namespace dmapper {
+
+class DomainMapper;
+struct StyleSheetEntry;
+
+
+/** Class representing the numbering level properties.
+ */
+class ListLevel : public PropertyMap
+{
+    sal_Int32                                     m_nIStartAt;       //LN_ISTARTAT
+    sal_Int32                                     m_nNFC;            //LN_NFC
+    sal_Int32                                     m_nJC;             //LN_JC
+    sal_Int32                                     m_nFLegal;         //LN_FLEGAL
+    sal_Int32                                     m_nFNoRestart;     //LN_FNORESTART
+    sal_Int32                                     m_nFPrev;          //LN_FPREV
+    sal_Int32                                     m_nFPrevSpace;     //LN_FPREVSPACE
+    sal_Int32                                     m_nFWord6;         //LN_FWORD6
+    ::rtl::OUString                               m_sRGBXchNums;     //LN_RGBXCHNUMS
+    sal_Int32                                     m_nXChFollow;      //LN_IXCHFOLLOW
+    ::rtl::OUString                               m_sBulletChar;
+    sal_Int32                                     m_nTabstop;
+    boost::shared_ptr< StyleSheetEntry >          m_pParaStyle;
+
+public:
+
+    typedef boost::shared_ptr< ListLevel > Pointer;
+
+    ListLevel() :
+        m_nIStartAt(-1)
+        ,m_nNFC(-1)
+        ,m_nJC(-1)
+        ,m_nFLegal(-1)
+        ,m_nFNoRestart(-1)
+        ,m_nFPrev(-1)
+        ,m_nFPrevSpace(-1)
+        ,m_nFWord6(-1)
+        ,m_nXChFollow(-1)
+        ,m_nTabstop( 0 )
+        {}
+
+    ~ListLevel( ){ }
+
+    // Setters for the import
+    void SetValue( Id nId, sal_Int32 nValue );
+    void SetBulletChar( rtl::OUString sValue ) { m_sBulletChar = sValue; };
+    void SetParaStyle( boost::shared_ptr< StyleSheetEntry > pStyle ) 
+    { 
+        m_pParaStyle = pStyle; 
+    };
+    void AddRGBXchNums( rtl::OUString sValue ) { m_sRGBXchNums += sValue; };
+
+    // Getters
+    rtl::OUString GetBulletChar( ) { return m_sBulletChar; };
+    boost::shared_ptr< StyleSheetEntry > GetParaStyle( ) { return m_pParaStyle; };
+
+    // UNO mapping functions
+
+    // rPrefix and rSuffix are out parameters
+    static sal_Int16 GetParentNumbering( rtl::OUString sText, sal_Int16 nLevel,
+        rtl::OUString& rPrefix, rtl::OUString& rSuffix );
+    
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >  
+        GetProperties(  );
+    
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue> 
+        GetCharStyleProperties( );
+private:
+
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >  
+        GetLevelProperties(  );
+    
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >  
+        GetParaProperties(  );
+};
+
+class AbstractListDef
+{
+private:
+    sal_Int32                            m_nTPLC;          //LN_TPLC
+    ::rtl::OUString                      m_sRGISTD;        //LN_RGISTD
+    sal_Int32                            m_nSimpleList;    //LN_FSIMPLELIST
+    sal_Int32                            m_nRestart;       //LN_FRESTARTHDN
+    sal_Int32                            m_nUnsigned;      //LN_UNSIGNED26_2
+
+    // The ID member reflects either the abstractNumId or the numId
+    // depending on the use of the class
+    sal_Int32                            m_nId;
+
+    // Properties of each level. This can also reflect the overridden 
+    // levels of a numbering.
+    ::std::vector< ListLevel::Pointer >  m_aLevels;
+
+    // Only used during the numberings import
+    ListLevel::Pointer                         m_pCurrentLevel;
+
+public:
+    typedef boost::shared_ptr< AbstractListDef > Pointer;
+
+    AbstractListDef( );
+    ~AbstractListDef( );
+
+    // Setters using during the import
+    void SetId( sal_Int32 nId ) { m_nId = nId; };
+    void SetValue( sal_uInt32 nSprmId, sal_Int32 nValue );  
+    void AddRGISTD( rtl::OUString sValue ) { m_sRGISTD += sValue; };
+
+    // Accessors
+    sal_Int32             GetId( ) { return m_nId; };
+
+    sal_Int16             Size( ) { return sal_Int16( m_aLevels.size( ) ); };
+    ListLevel::Pointer    GetLevel( sal_uInt16 nLvl );
+    void                  AddLevel( );
+
+    ListLevel::Pointer    GetCurrentLevel( ) { return m_pCurrentLevel; };
+
+    virtual com::sun::star::uno::Sequence< 
+        com::sun::star::uno::Sequence< 
+            com::sun::star::beans::PropertyValue > > GetPropertyValues( );
+};
+
+class ListDef : public AbstractListDef
+{
+private:
+    // Pointer to the abstract numbering
+    AbstractListDef::Pointer             m_pAbstractDef;
+    
+    // Cache for the UNO numbering rules
+    uno::Reference< container::XIndexReplace > m_xNumRules;
+
+public:
+    typedef boost::shared_ptr< ListDef > Pointer;
+
+    ListDef( );
+    ~ListDef( );
+    
+    // Accessors
+    void SetAbstractDefinition( AbstractListDef::Pointer pAbstract ) { m_pAbstractDef = pAbstract; };
+    AbstractListDef::Pointer GetAbstractDefinition( ) { return m_pAbstractDef; };
+    
+    // Mapping functions
+    static rtl::OUString GetStyleName( sal_Int32 nId );
+    
+    com::sun::star::uno::Sequence< 
+        com::sun::star::uno::Sequence< 
+            com::sun::star::beans::PropertyValue > > GetPropertyValues( );
+    
+    void CreateNumberingRules(
+            DomainMapper& rDMapper,
+            com::sun::star::uno::Reference< 
+                com::sun::star::lang::XMultiServiceFactory> xFactory );
+    
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexReplace >
+            GetNumberingRules( ) { return m_xNumRules; };
+
+};
+
+/** This class provides access to the defined numbering styles.
+  */
+class WRITERFILTER_DLLPRIVATE ListsManager : 
+    public Properties,
+    public Table
+{
+private:
+
+    DomainMapper&                                       m_rDMapper;
+    com::sun::star::uno::Reference< 
+        com::sun::star::lang::XMultiServiceFactory >    m_xFactory;
+
+    // The numbering entries
+    std::vector< AbstractListDef::Pointer >             m_aAbstractLists;
+    std::vector< ListDef::Pointer >                     m_aLists;
+
+
+    // These members are used for import only
+    AbstractListDef::Pointer                            m_pCurrentDefinition;
+    bool                                                m_bIsLFOImport;
+
+public:
+
+    ListsManager(
+            DomainMapper& rDMapper,
+            const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > xFactory);
+    virtual ~ListsManager();
+    
+    typedef boost::shared_ptr< ListsManager >  Pointer;
+
+    // Properties
+    virtual void attribute( Id nName, Value & rVal );
+    virtual void sprm(Sprm & sprm);
+
+    // Table
+    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
+
+    // Config methods
+    void SetLFOImport( bool bLFOImport ) { m_bIsLFOImport = bLFOImport; };
+
+    // Numberings accessors
+    AbstractListDef::Pointer GetCurrentDef( ) { return m_pCurrentDefinition; };
+    
+    sal_uInt32              Size() const 
+        { return sal_uInt32( m_aLists.size( ) ); };
+    ListDef::Pointer        GetList( sal_Int32 nId );
+
+    // Mapping methods
+    void CreateNumberingRules( );
+};
+
+} }
+
+#endif
+
diff --git writerfilter/source/dmapper/PropertyIds.cxx writerfilter/source/dmapper/PropertyIds.cxx
index 9e54c06..74c6f5d 100644
--- writerfilter/source/dmapper/PropertyIds.cxx
+++ writerfilter/source/dmapper/PropertyIds.cxx
@@ -322,7 +322,7 @@ const rtl::OUString& PropertyNameSupplier::GetName( PropertyIds eId ) const
             case PROP_OUTLINE_LEVEL  :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("OutlineLevel")); break;
             case PROP_LISTTAB_STOP_POSITION :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition")); break;
             case PROP_POSITION_AND_SPACE_MODE :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PositionAndSpaceMode")); break;
-//            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
+            case PROP_HEADING_STYLE_NAME:    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("HeadingStyleName")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
diff --git writerfilter/source/dmapper/PropertyIds.hxx writerfilter/source/dmapper/PropertyIds.hxx
index b46e502..f0c52ba 100644
--- writerfilter/source/dmapper/PropertyIds.hxx
+++ writerfilter/source/dmapper/PropertyIds.hxx
@@ -285,6 +285,7 @@ enum PropertyIds
 /*246*/ ,PROP_OUTLINE_LEVEL
 /*247*/ ,PROP_LISTTAB_STOP_POSITION
 /*248*/ ,PROP_POSITION_AND_SPACE_MODE
+/*249*/ ,PROP_HEADING_STYLE_NAME
 };
 struct PropertyNameSupplier_Impl;
 class PropertyNameSupplier
diff --git writerfilter/source/dmapper/StyleSheetTable.cxx writerfilter/source/dmapper/StyleSheetTable.cxx
index 2d200c4..69a551b 100644
--- writerfilter/source/dmapper/StyleSheetTable.cxx
+++ writerfilter/source/dmapper/StyleSheetTable.cxx
@@ -29,7 +29,7 @@
  ************************************************************************/
 #include <StyleSheetTable.hxx>
 #include <dmapper/DomainMapper.hxx>
-#include <ListTable.hxx>
+#include <NumberingManager.hxx>
 #include <ConversionHelper.hxx>
 #include <TblStylePrHandler.hxx>
 #include <BorderHandler.hxx>
@@ -1235,44 +1235,6 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
                             }
                         }
 
-                        if ( pStyleSheetProperties && pStyleSheetProperties->GetOutlineLevel( ) >= 0 )
-                        {
-                            ListTablePtr pListTable = m_pImpl->m_rDMapper.GetListTable( );
-                            sal_Int32 nNumId = pStyleSheetProperties->GetListId( );
-                            uno::Reference< container::XIndexReplace> xStyleRules = pListTable->GetNumberingRules( nNumId );
-                            sal_Int16 nLvl = pStyleSheetProperties->GetOutlineLevel( );
-                            uno::Reference< text::XChapterNumberingSupplier > xOutlines ( m_pImpl->m_xTextDocument,
-                                    uno::UNO_QUERY_THROW );
-
-                            uno::Reference< container::XIndexReplace > xRules = xOutlines->getChapterNumberingRules( );
-                            if ( xStyleRules.is( ) )
-                            {
-                                for ( sal_Int32 i = 0, nCount = xStyleRules->getCount( ); i < nCount; i++ )
-                                {
-                                    xRules->replaceByIndex( i, xStyleRules->getByIndex( i ) );
-                                }
-                            }
-
-                            uno::Any aLevel = xRules->getByIndex( nLvl );
-                            uno::Sequence< beans::PropertyValue > aLevelProps;
-                            aLevel >>= aLevelProps;
-
-                            sal_Int32 nLen = aLevelProps.getLength( );
-                            sal_Int32 i = 0;
-                            bool bPropFound = false;
-                            rtl::OUString sPropName( rtl::OUString::createFromAscii( "HeadingStyleName" ) );
-                            while ( i < nLen && !bPropFound )
-                            {
-                                if ( aLevelProps[i].Name.equals( sPropName ) )
-                                {
-                                    aLevelProps[i].Value = uno::makeAny( ConvertStyleName( pEntry->sStyleName ) );
-                                    bPropFound = true;
-                                }
-                                i++;
-                            }
-                            xRules->replaceByIndex( nLvl, uno::makeAny( aLevelProps ) );
-                        }
-
                         uno::Reference< beans::XPropertyState >xState( xStyle, uno::UNO_QUERY_THROW );
                         if( sConvertedStyleName.equalsAscii( "Contents Heading" ) ||
                             sConvertedStyleName.equalsAscii( "User Index Heading" ) ||
diff --git writerfilter/source/dmapper/makefile.mk writerfilter/source/dmapper/makefile.mk
index 5f42164..7a040d1 100644
--- writerfilter/source/dmapper/makefile.mk
+++ writerfilter/source/dmapper/makefile.mk
@@ -56,8 +56,7 @@ SLOFILES=           $(SLO)$/BorderHandler.obj \
                     $(SLO)$/DomainMapperTableManager.obj \
                     $(SLO)$/FontTable.obj   \
                     $(SLO)$/GraphicImport.obj  \
-                    $(SLO)$/LFOTable.obj    \
-                    $(SLO)$/ListTable.obj  \
+                    $(SLO)$/NumberingManager.obj  \
                     $(SLO)$/MeasureHandler.obj \
                     $(SLO)$/PropertyMap.obj  \
                     $(SLO)$/PropertyIds.obj  \
diff --git writerfilter/source/doctok/WW8DocumentImpl.cxx writerfilter/source/doctok/WW8DocumentImpl.cxx
index 87e08e5..3bdca2d 100644
--- writerfilter/source/doctok/WW8DocumentImpl.cxx
+++ writerfilter/source/doctok/WW8DocumentImpl.cxx
@@ -1688,19 +1688,8 @@ void WW8DocumentImpl::resolve(Stream & rStream)
         }
 #endif
    
-        
-        writerfilter::Reference<Table>::Pointer_t pListTable = getListTable();
-        
-        if (pListTable.get() != NULL)
-            rStream.table(NS_rtf::LN_LISTTABLE, pListTable);
-        
-        writerfilter::Reference<Table>::Pointer_t pLFOTable = getLFOTable();
-        
-        if (pLFOTable.get() != NULL)
-            rStream.table(NS_rtf::LN_LFOTABLE, pLFOTable);
-        
         writerfilter::Reference<Table>::Pointer_t pFontTable = getFontTable();
-        
+         
         if (pFontTable.get() != NULL)
             rStream.table(NS_rtf::LN_FONTTABLE, pFontTable);
   
@@ -1715,6 +1704,16 @@ void WW8DocumentImpl::resolve(Stream & rStream)
         {
             clog << e.getText() << endl;
         }
+        
+        writerfilter::Reference<Table>::Pointer_t pListTable = getListTable();
+        
+        if (pListTable.get() != NULL)
+            rStream.table(NS_rtf::LN_LISTTABLE, pListTable);
+        
+        writerfilter::Reference<Table>::Pointer_t pLFOTable = getLFOTable();
+        
+        if (pLFOTable.get() != NULL)
+            rStream.table(NS_rtf::LN_LFOTABLE, pLFOTable);
     }
 
     WW8DocumentIterator::Pointer_t pIt = begin();
diff --git writerfilter/source/ooxml/OOXMLDocumentImpl.cxx writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
index df80785..4ae36eb 100644
--- writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
+++ writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
@@ -326,9 +326,9 @@ void OOXMLDocumentImpl::resolve(Stream & rStream)
 
         resolveFastSubStream(rStream, OOXMLStream::SETTINGS);
         resolveFastSubStream(rStream, OOXMLStream::THEME);
-        resolveFastSubStream(rStream, OOXMLStream::NUMBERING);
         resolveFastSubStream(rStream, OOXMLStream::FONTTABLE);
         resolveFastSubStream(rStream, OOXMLStream::STYLES);
+        resolveFastSubStream(rStream, OOXMLStream::NUMBERING);
 
         xParser->setFastDocumentHandler( xDocumentHandler );
         xParser->setTokenHandler( xTokenHandler );
