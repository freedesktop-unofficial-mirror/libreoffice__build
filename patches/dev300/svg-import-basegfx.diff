--- basegfx/inc/basegfx/polygon/b2dpolypolygontools.hxx	24 Apr 2008 15:04:45 -0000	1.18
+++ basegfx/inc/basegfx/polygon/b2dpolypolygontools.hxx	6 May 2008 11:01:43 -0000
@@ -111,19 +111,37 @@ namespace basegfx
         /** Read poly-polygon from SVG.
 
         	This function imports a poly-polygon from an SVG-D
-        	statement. Currently, elliptical arc elements are not yet
+        	attribute. Currently, elliptical arc elements are not yet
         	supported (and ignored during parsing).
 
             @param o_rPolyPoly
             The output poly-polygon
 
-            @param rSvgDStatement
-            A valid SVG-D statement
+            @param rSvgDAttribute
+            A valid SVG-D attribute string
 
             @return true, if the string was successfully parsed
          */
-        bool importFromSvgD( B2DPolyPolygon& o_rPolyPoly,
-                             const ::rtl::OUString& 	rSvgDStatement );
+        bool importFromSvgD( B2DPolyPolygon&        o_rPolyPoly,
+                             const ::rtl::OUString& rSvgDAttribute );
+
+        /** Read poly-polygon from SVG.
+
+        	This function imports a poly-polygon from an SVG points
+        	attribute (a plain list of coordinate pairs).
+
+            @param o_rPoly
+            The output polygon. Note that svg:points can only define a
+            single polygon
+
+            @param rSvgPointsAttribute
+            A valid SVG points attribute string
+
+            @return true, if the string was successfully parsed
+         */
+        bool importFromSvgPoints( B2DPolygon&            o_rPoly,
+                                  const ::rtl::OUString& rSvgPointsAttribute );
+
 
 		// create 3d PolyPolygon from given 2d PolyPolygon. The given fZCoordinate is used to expand the
 		// third coordinate.

--- basegfx/source/polygon/b2dsvgpolypolygon.cxx	24 Apr 2008 15:07:05 -0000	1.9
+++ basegfx/source/polygon/b2dsvgpolypolygon.cxx	6 May 2008 11:01:43 -0000
@@ -33,7 +33,9 @@
 
 #include <basegfx/polygon/b2dpolygontools.hxx>
 #include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
 #include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
 #include <rtl/ustring.hxx>
 #include <rtl/math.hxx>
 
@@ -65,7 +67,7 @@ namespace basegfx
                 }
             }
 
-            bool lcl_isOnNumberChar(const ::rtl::OUString& rStr, const sal_Int32 nPos, bool bSignAllowed = true)
+            inline bool lcl_isOnNumberChar(const ::rtl::OUString& rStr, const sal_Int32 nPos, bool bSignAllowed = true)
             {
                 const sal_Unicode aChar(rStr[nPos]);
 
@@ -142,6 +144,37 @@ namespace basegfx
                 return true;
             }
 
+            bool lcl_importNumberAndSpaces(sal_Int32&                o_nRetval,
+                                           sal_Int32& 				io_rPos, 
+                                           const ::rtl::OUString& 	rStr, 
+                                           const sal_Int32 		nLen)
+            {
+                sal_Unicode aChar( rStr[io_rPos] );
+                ::rtl::OUStringBuffer sNumberString;
+
+                if(sal_Unicode('+') == aChar || sal_Unicode('-') == aChar)
+                {
+                    sNumberString.append(rStr[io_rPos]);
+                    aChar = rStr[++io_rPos];
+                }
+
+                while(sal_Unicode('0') <= aChar && sal_Unicode('9') >= aChar)
+                {
+                    sNumberString.append(rStr[io_rPos]);
+                    aChar = rStr[++io_rPos];
+                }
+
+                if(sNumberString.getLength())
+                {
+                    o_nRetval = sNumberString.makeStringAndClear().toInt32();
+                    lcl_skipSpacesAndCommas(io_rPos, rStr, nLen);
+
+                    return true;
+                }
+
+                return false;
+            }
+
             void lcl_skipNumber(sal_Int32& 				io_rPos, 
                                 const ::rtl::OUString& 	rStr, 
                                 const sal_Int32 		nLen)
@@ -621,24 +654,169 @@ namespace basegfx
                         break;
                     }
 
-                    // #100617# not yet supported: elliptical arc
-                    case 'A' :
-                        // FALLTHROUGH intended
                     case 'a' :
                     {
-                        OSL_ENSURE(false, "importFromSvgD(): non-interpreted tags in svg:d element (elliptical arc)!");
+                        bRelative = true;
+                        // FALLTHROUGH intended
+                    }
+                    case 'A' :
+                    {
                         nPos++;
                         lcl_skipSpaces(nPos, rSvgDStatement, nLen);
 
                         while(nPos < nLen && lcl_isOnNumberChar(rSvgDStatement, nPos))
                         {
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipNumberAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipNumberAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
+                            double nX, nY;
+                            double fRX, fRY, fPhi;
+                            sal_Int32 bLargeArcFlag, bSweepFlag;
+
+                            if(!lcl_importDoubleAndSpaces(fRX, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(fRY, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(fPhi, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importNumberAndSpaces(bLargeArcFlag, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importNumberAndSpaces(bSweepFlag, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(nX, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(nY, nPos, rSvgDStatement, nLen)) return false;
+
+                            if(bRelative)
+                            {
+                                nX += nLastX;
+                                nY += nLastY;
+                            }
+
+							const B2DPoint aPrevPoint(aCurrPoly.getB2DPoint(aCurrPoly.count() - 1));
+
+                            if( nX == nLastX && nY == nLastY )
+                                continue; // start==end -> skip according to SVG spec
+
+                            if( fRX == 0.0 || fRY == 0.0 )
+                            {
+                                // straight line segment according to SVG spec
+                                aCurrPoly.append(B2DPoint(nX, nY));
+                            }
+                            else
+                            {
+                                // normalize according to SVG spec
+                                fRX=fabs(fRX); fRY=fabs(fRY);
+                                
+                                // from the SVG spec, appendix F.6.4
+
+                                // |x1'|   |cos phi   sin phi|  |(x1 - x2)/2|
+                                // |y1'| = |-sin phi  cos phi|  |(y1 - y2)/2|
+                                const B2DPoint p1(nLastX, nLastY);
+                                const B2DPoint p2(nX, nY);
+                                B2DHomMatrix aRotate; aRotate.rotate(-fPhi*M_PI/180);
+                                
+                                const B2DPoint p1_prime( aRotate * B2DPoint(((p1-p2)/2.0)) );
+
+                                //           ______________________________________       rx y1'
+                                // |cx'|  + /  rx^2 ry^2 - rx^2 y1'^2 - ry^2 x1^2           ry
+                                // |cy'| =-/       rx^2y1'^2 + ry^2 x1'^2               - ry x1' 
+                                //                                                          rx
+                                // chose + if f_A != f_S
+                                // chose - if f_A  = f_S
+                                B2DPoint aCenter_prime;
+                                const double fRadicant(
+                                    (fRX*fRX*fRY*fRY - fRX*fRX*p1_prime.getY()*p1_prime.getY() - fRY*fRY*p1_prime.getX()*p1_prime.getX())/
+                                    (fRX*fRX*p1_prime.getY()*p1_prime.getY() + fRY*fRY*p1_prime.getX()*p1_prime.getX()));
+                                if( fRadicant < 0.0 )
+                                {
+                                    // no solution - according to SVG
+                                    // spec, scale up ellipse
+                                    // uniformly such that it passes
+                                    // through end points (denominator
+                                    // of radicant solved for fRY,
+                                    // with s=fRX/fRY)
+                                    const double fRatio(fRX/fRY);
+                                    const double fRadicant2(
+                                        p1_prime.getY()*p1_prime.getY() - 
+                                        p1_prime.getX()*p1_prime.getX()/(fRatio*fRatio));
+                                    if( fRadicant2 < 0.0 )
+                                    {
+                                        // only trivial solution, one
+                                        // of the axes 0 -> straight
+                                        // line segment according to
+                                        // SVG spec
+                                        aCurrPoly.append(B2DPoint(nX, nY));
+                                        continue;
+                                    }
+                                    
+                                    fRY=sqrt(fRadicant2);
+                                    fRX=fRatio*fRY;
+
+                                    // keep center_prime forced to (0,0)
+                                }
+                                else
+                                {
+                                    const double fFactor(
+                                        (bLargeArcFlag==bSweepFlag) ? -1.0 : 1.0 *
+                                        sqrt((fRX*fRX*fRY*fRY - fRX*fRX*p1_prime.getY()*p1_prime.getY() - fRY*fRY*p1_prime.getX()*p1_prime.getX())/
+                                             (fRX*fRX*p1_prime.getY()*p1_prime.getY() + fRY*fRY*p1_prime.getX()*p1_prime.getX())));
+
+                                    // actually calculate center_prime
+                                    aCenter_prime = B2DPoint(
+                                        fFactor*fRX*p1_prime.getY()/fRY,
+                                        -fFactor*fRY*p1_prime.getX()/fRX);
+                                }
+
+                                // |cx|   | cos phi  -sin phi |  | cx' |    (x1+x2)/2
+                                // |cy| = | sin phi   cos phi |  | cy' | +  (y1+y2)/2 
+                                aRotate.identity(); aRotate.rotate(fPhi*M_PI/180);
+                                const B2DPoint aCenter( aRotate * aCenter_prime + 
+                                                        (p1+p2)/2.0);
+                                
+                                //              +           u - v 
+                                // angle(u,v) =  arccos( ------------ )     (take the sign of (ux vy - uy vx))
+                                //              -        ||u|| ||v||
+
+                                //                  1    | (x1' - cx')/rx |
+                                // theta1 = angle((   ), |                | )
+                                //                  0    | (y1' - cy')/ry |
+                                const B2DPoint aRadii(fRX,fRY);
+                                double fTheta1( 
+                                    B2DVector(1.0,0.0).angle(
+                                        (p1_prime-aCenter_prime)/aRadii));
+
+                                //                 |1|    |  (-x1' - cx')/rx |
+                                // theta2 = angle( | | ,  |                  | )
+                                //                 |0|    |  (-y1' - cy')/ry |
+                                double fTheta2( 
+                                    B2DVector(1.0,0.0).angle(
+                                        (-p1_prime-aCenter_prime)/aRadii));
+
+                                // map both angles to [0,2pi)
+                                fTheta1 = fmod(2*M_PI+fTheta1,2*M_PI);
+                                fTheta2 = fmod(2*M_PI+fTheta2,2*M_PI);
+
+                                // make sure the large arc is taken
+                                // (since
+                                // createPolygonFromEllipseSegment()
+                                // normalizes to e.g. cw arc)
+                                const bool bFlipSegment( (bLargeArcFlag!=0) == 
+                                    (fmod(fTheta2+2*M_PI-fTheta1,
+                                          2*M_PI)<M_PI) );
+                                if( bFlipSegment )
+                                    std::swap(fTheta1,fTheta2);
+
+                                // finally, create bezier polygon from this
+                                B2DPolygon aSegment(
+                                    tools::createPolygonFromEllipseSegment( 
+                                        aCenter,
+                                        fRX,fRY,
+                                        fTheta1, fTheta2 ));
+
+                                // createPolygonFromEllipseSegment()
+                                // always creates arcs that are
+                                // positively oriented - flip polygon
+                                // if we swapped angles above
+                                if( bFlipSegment )
+                                    aSegment.flip();
+                                aCurrPoly.append(aSegment);
+                            }
+
+                            // set last position
+                            nLastX = nX;
+                            nLastY = nY;
                         }
                         break;
                     }
@@ -667,6 +845,32 @@ namespace basegfx
             return true;
         }
 
+        bool importFromSvgPoints( B2DPolygon&            o_rPoly,
+                                  const ::rtl::OUString& rSvgPointsAttribute )
+        {
+            o_rPoly.clear();
+            const sal_Int32 nLen(rSvgPointsAttribute.getLength());
+            sal_Int32 nPos(0);
+            double nX, nY;
+
+            // skip initial whitespace
+            lcl_skipSpaces(nPos, rSvgPointsAttribute, nLen);
+
+            while(nPos < nLen)
+            {
+                if(!lcl_importDoubleAndSpaces(nX, nPos, rSvgPointsAttribute, nLen)) return false;
+                if(!lcl_importDoubleAndSpaces(nY, nPos, rSvgPointsAttribute, nLen)) return false;
+                
+                // add point        
+                o_rPoly.append(B2DPoint(nX, nY));
+
+                // skip to next number, or finish
+                lcl_skipSpaces(nPos, rSvgPointsAttribute, nLen);
+            }
+
+            return true;
+        }
+
         ::rtl::OUString exportToSvgD(
 			const B2DPolyPolygon& rPolyPolygon,
 			bool bUseRelativeCoordinates, 

--- basegfx/test/basegfx2d.cxx	24 Apr 2008 15:08:36 -0000	1.12
+++ basegfx/test/basegfx2d.cxx	6 May 2008 11:01:43 -0000
@@ -484,6 +484,14 @@ public:
         
         CPPUNIT_ASSERT_MESSAGE("exporting to circle does not produce the expected number of coordinates", 
                                nCount==18);
+
+        const B2DPolygon aRect( 
+            tools::createPolygonFromRect( B2DRange(0.0,0.0,4000.0,4000.0) ));
+        aExport = tools::exportToSvgD( B2DPolyPolygon(aRect), false, false);
+
+		const char* sExportStringRect = "M0 0H4000V4000H0Z";
+		CPPUNIT_ASSERT_MESSAGE("exporting to rectangle svg-d string", 
+                               !aExport.compareToAscii(sExportStringRect));
     }
 
     // Change the following lines only, if you add, remove or rename 
