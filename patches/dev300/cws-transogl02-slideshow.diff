--- slideshow/source/engine/slideshowimpl.cxx	9 Nov 2007 10:16:38 -0000	1.6
+++ slideshow/source/engine/slideshowimpl.cxx	16 Jan 2008 10:56:20 -0000	1.6.4.3
@@ -1448,10 +1448,16 @@ sal_Bool SlideShowImpl::update( double &
         // hold timer, while processing the queues (ensures
         // same time for all activities and events)
         {
-            comphelper::ScopeGuard const scopeGuard(
+            comphelper::ScopeGuard scopeGuard(
                 boost::bind( &canvas::tools::ElapsedTime::releaseTimer,
                              boost::cref(mpPresTimer) ) );
+
+            // no need to hold timer for only one active animation -
+            // it's only meant to keep multiple ones in sync
+            if( maActivitiesQueue.size() > 1 ) 
             mpPresTimer->holdTimer();
+            else
+                scopeGuard.dismiss(); // we're not holding the timer
                     
             // process queues
             maEventQueue.process();
cvs diff: Diffing slideshow/source/engine/OGLTrans
--- slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx	9 Nov 2007 10:17:00 -0000	1.2
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx	14 Jan 2008 20:43:28 -0000	1.2.4.3
@@ -42,6 +42,9 @@ void OGLTransitionImpl::clear()
     OverallOperations.clear();
     maLeavingSlidePrimitives.clear();
     maEnteringSlidePrimitives.clear();
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        delete maSceneObjects[i];
+    maSceneObjects.clear();
 }
 
 OGLTransitionImpl::~OGLTransitionImpl()
@@ -49,8 +52,28 @@ OGLTransitionImpl::~OGLTransitionImpl()
     clear();
 }
 
-void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex , double SlideWidthScale, double SlideHeightScale)
+void OGLTransitionImpl::prepare()
 {
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->prepare();
+    }
+}
+
+void OGLTransitionImpl::finish()
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->finish();
+    }
+}
+
+void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                 double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    double SlideWidthScale, SlideHeightScale;
+
+    SlideWidthScale = SlideWidth/DispWidth;
+    SlideHeightScale = SlideHeight/DispHeight;
+
     glPushMatrix();
     glEnable(GL_TEXTURE_2D);
     //TODO change to foreach
@@ -62,16 +85,20 @@ void OGLTransitionImpl::display( double 
     glBindTexture(GL_TEXTURE_2D, glEnteringSlideTex);
     for(unsigned int i(0); i < maEnteringSlidePrimitives.size(); ++i)
         maEnteringSlidePrimitives[i].display(nTime,SlideWidthScale,SlideHeightScale);
+
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        maSceneObjects[i]->display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+    
+
     glPopMatrix();
 }
 
-void Primitive::display(double nTime, double SlideWidthScale, double SlideHeightScale)
+void Primitive::display(double nTime, double WidthScale, double HeightScale)
 {
     glPushMatrix();
-    glEnable(GL_TEXTURE_2D);
     for(unsigned int i(0); i < Operations.size(); ++i)
-        Operations[i]->interpolate( nTime ,SlideWidthScale,SlideHeightScale);
-    glScaled(SlideWidthScale,SlideHeightScale,1);
+        Operations[i]->interpolate( nTime ,WidthScale,HeightScale);
+    glScaled(WidthScale,HeightScale,1);
     
     glEnableClientState( GL_VERTEX_ARRAY );
     if(!Normals.empty())
@@ -92,6 +119,60 @@ Primitive::~Primitive()
         delete Operations[i];
 }
 
+void SceneObject::display(double nTime, double /* SlideWidth */, double /* SlideHeight */, double DispWidth, double DispHeight )
+{
+    for(unsigned int i(0); i < maPrimitives.size(); ++i) {
+        // fixme: allow various model spaces, now we make it so that
+        // it is regular -1,-1 to 1,1, where the whole display fits in
+        glPushMatrix();
+        if (DispHeight > DispWidth)
+            glScaled(DispHeight/DispWidth, 1, 1);
+        else
+            glScaled(1, DispWidth/DispHeight, 1);
+        maPrimitives[i].display(nTime, 1, 1);
+        glPopMatrix();
+    }
+}
+
+void SceneObject::pushPrimitive(const Primitive &p)
+{
+    maPrimitives.push_back(p);
+}
+
+SceneObject::SceneObject()
+    : maPrimitives()
+{
+}
+
+Iris::Iris()
+    : SceneObject ()
+{
+}
+
+void Iris::display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    SceneObject::display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Iris::prepare()
+{
+    static GLubyte img[3] = { 80, 80, 80 };
+    
+    glGenTextures(1, &maTexture);
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, 3, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, img);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+}
+
+void Iris::finish()
+{
+    glDeleteTextures(1, &maTexture);
+}
+
 void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
 {
     clear();
@@ -102,11 +183,11 @@ void OGLTransitionImpl::makeOutsideCubeF
 
     maLeavingSlidePrimitives.push_back(Slide);
 
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,false,0.0,1.0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,false,0.0,1.0));
 
     maEnteringSlidePrimitives.push_back(Slide);
 
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,true,0.0,1.0));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,true,0.0,1.0));
 }
 
 void OGLTransitionImpl::makeInsideCubeFaceToLeft()
@@ -119,11 +200,150 @@ void OGLTransitionImpl::makeInsideCubeFa
 
     maLeavingSlidePrimitives.push_back(Slide);
 
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,false,0.0,1.0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+    
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeFallLeaving()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(1,0,0),basegfx::B3DVector(0,-1,0), 90,true,0.0,1.0));
+    maLeavingSlidePrimitives.push_back(Slide);
+}
+
+void OGLTransitionImpl::makeTurnAround()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
 
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0),-180,false,0.0,1.0));
     maEnteringSlidePrimitives.push_back(Slide);
     
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,true,0.0,1.0));
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, -1.5),true, 0, 0.5));
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1.5), true, 0.5, 1));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0),basegfx::B3DVector(0, 0, 0), -180, true, 0.0, 1.0));
+}
+
+void OGLTransitionImpl::makeTurnDown()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 0.0001), false, -1.0, 0.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), -90, true, 0.0, 1.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), 90, false, -1.0, 0.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+}
+
+void OGLTransitionImpl::makeIris()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, 0.0001), false, -1, 0));
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, -0.0002), false, 0.5, 1));
+    maLeavingSlidePrimitives.push_back (Slide);
+
+
+    Primitive irisPart, part;
+    int i, nSteps = 24, nParts = 7;
+    double lt = 0, t = 1.0/nSteps, cx, cy, lcx, lcy, lx = 1, ly = 0, x, y, cxo, cyo, lcxo, lcyo, of=2.2, f=1.42;
+
+    for (i=1; i<=nSteps; i++) {
+        x = cos ((3*2*M_PI*t)/nParts);
+        y = -sin ((3*2*M_PI*t)/nParts);
+        cx = (f*x + 1)/2;
+        cy = (f*y + 1)/2;
+        lcx = (f*lx + 1)/2;
+        lcy = (f*ly + 1)/2;
+        cxo = (of*x + 1)/2;
+        cyo = (of*y + 1)/2;
+        lcxo = (of*lx + 1)/2;
+        lcyo = (of*ly + 1)/2;
+        irisPart.pushTriangle (basegfx::B2DVector (lcx, lcy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cx, cy));
+        irisPart.pushTriangle (basegfx::B2DVector (cx, cy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cxo, cyo));
+        lx = x;
+        ly = y;
+        lt = t;
+        t += 1.0/nSteps;
+    }
+
+    Iris* pIris = new Iris();
+    double angle = 87;
+
+    for (i = 0; i < nParts; i++) {
+        irisPart.Operations.clear ();
+        double rx, ry;
+
+        rx = cos ((2*M_PI*i)/nParts);
+        ry = sin ((2*M_PI*i)/nParts);
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0),  angle, true, 0.0, 0.5));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0), -angle, true, 0.5, 1));
+        if (i > 0) {
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(rx, ry, 0),  false, -1, 0));
+            irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(0, 0, 0), i*360.0/nParts, false, -1, 0));
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(-1, 0, 0),  false, -1, 0));
+        }
+        irisPart.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1), false, -2, 0.0));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(1, .5, 0), basegfx::B3DVector(1, 0, 0), -30, false, -1, 0));
+        pIris->pushPrimitive (irisPart);
+    }
+
+    maSceneObjects.push_back (pIris);
+}
+
+void OGLTransitionImpl::makeRochade()
+{
+    clear();
+    Primitive Slide;
+    
+    double w, h;
+
+    w = 2.2;
+    h = 5;
+
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.25, -0.25, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.75, 0.25, true, 0, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, -h), false, -1, 0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), 45, false, -1, 0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    //     OverallOperations.push_back(new SEllipseTranslate(0.5, 2, 0, 1, true, 0, 1));
+//      push_back(new STranslate(basegfx::B3DVector(0, 0, -2), true, 0, 0.5));
+//      OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 2), true, 0.5, 1));
 }
 
 // TODO(Q3): extract to basegfx
@@ -237,7 +457,7 @@ void OGLTransitionImpl::makeRevolvingCir
         NextRadius += dRadius;
     }
     {
-        Radius = sqrt(2);
+        Radius = sqrt(2.0);
         Primitive LeavingSlide;
         Primitive EnteringSlide;
         for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
@@ -408,6 +628,34 @@ void RotateAndScaleDepthByWidth::interpo
     glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
 }
 
+SEllipseTranslate::SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+    width = dWidth;
+    height = dHeight;
+    startPosition = dStartPosition;
+    endPosition = dEndPosition;
+}
+
+void SEllipseTranslate::interpolate(double t,double /* SlideWidthScale */,double /* SlideHeightScale */)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+
+    double a1, a2, x, y;
+    a1 = startPosition*2*M_PI;
+    a2 = (startPosition + t*(endPosition - startPosition))*2*M_PI;
+    x = width*(cos (a2) - cos (a1))/2;
+    y = height*(sin (a2) - sin (a1))/2;
+
+    glTranslated(x, 0, y);
+}
+
 STranslate* STranslate::clone()
 {
     return new STranslate(*this);
@@ -422,6 +670,11 @@ SScale* SScale::clone()
     return new SScale(*this);
 }
 
+SEllipseTranslate* SEllipseTranslate::clone()
+{
+    return new SEllipseTranslate(*this);
+}
+
 RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
 {
     return new RotateAndScaleDepthByWidth(*this);
@@ -464,7 +717,7 @@ void Primitive::pushTriangle(const baseg
     Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
 
     //figure out if they're facing the correct way, and make them face the correct way.
-    basegfx::B3DVector Normal( cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
+    basegfx::B3DVector Normal( basegfx::cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
     if(Normal.getZ() >= 0.0)//if the normal is facing us
     {
         Texs.push_back(SlideLocation0);
--- slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx	9 Nov 2007 10:17:11 -0000	1.2
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx	15 Jan 2008 10:07:34 -0000	1.2.4.3
@@ -32,16 +32,18 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-#ifndef INCLUDED_SLIDESHOW_TRANSITION_HXX_
-#define INCLUDED_SLIDESHOW_TRANSITION_HXX_
+#ifndef INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
+#define INCLUDED_OGLTRANS_TRANSITIONIMPL_HXX_
 
 #include <basegfx/vector/b2dvector.hxx>
 #include <basegfx/vector/b3dvector.hxx>
 
 #include <vector>
+#include <GL/gl.h>
 
 class Primitive;
 class Operation;
+class SceneObject;
 
 /** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
 
@@ -52,17 +54,26 @@ class OGLTransitionImpl
 public:
     OGLTransitionImpl() :
         maLeavingSlidePrimitives(),
-        maEnteringSlidePrimitives()
+        maEnteringSlidePrimitives(),
+        maSceneObjects()
     {}
 
     ~OGLTransitionImpl();
     
-    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex , double SlideWidthScale, double SlideHeightScale);
+    void prepare();
+    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    void finish();
+
     void makeOutsideCubeFaceToLeft();
     void makeInsideCubeFaceToLeft();
     void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
     void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
     void makeHelix( ::sal_uInt16 nRows );
+    void makeFallLeaving();
+    void makeTurnAround();
+    void makeTurnDown();
+    void makeIris();
+    void makeRochade();
 
 private:
     /** clears all the primitives and operations
@@ -77,18 +88,54 @@ private:
 	*/
     std::vector<Primitive> maEnteringSlidePrimitives;
     
+    /** All the surrounding scene objects
+	*/
+    std::vector<SceneObject*> maSceneObjects;
+
     /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
 	*/
 	std::vector<Operation*> OverallOperations;
 };
 
+class SceneObject
+{
+public:
+    SceneObject();
+
+    virtual void prepare() {};
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish() {};
+
+    void pushPrimitive (const Primitive &p);
+
+protected:
+    /** All the surrounding scene primitives
+	*/
+    std::vector<Primitive> maPrimitives;
+};
+
+class Iris : public SceneObject
+{
+public:
+    Iris ();
+
+    virtual void prepare();
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish();
+
+private:
+
+    GLuint maTexture;
+};
+
 /** This class is a list of Triangles that will share Operations, and could possibly share  
 */
 class Primitive
 {
 public:
     Primitive() {}
-    explicit Primitive(const Primitive& rvalue);
+	// making copy constructor explicit makes the class un-suitable for use with stl containers
+    Primitive(const Primitive& rvalue);
 	~Primitive();
 
     void display(double nTime, double SlideWidthScale, double SlideHeightScale);
@@ -301,6 +348,42 @@ private:
 	basegfx::B3DVector vector;
 };
 
+/** translation transformation
+*/
+class SEllipseTranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SEllipseTranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1);
+	~SEllipseTranslate(){}
+private:
+    /** width and length of the ellipse
+     */
+    double width, height;
+
+    /** start and end position on the ellipse <0,1>
+     */
+    double startPosition;
+    double endPosition;
+};
+
 /** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
 */
 class RotateAndScaleDepthByWidth: public Operation
--- slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx	12 Dec 2007 13:26:16 -0000	1.3
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx	17 Dec 2007 19:54:16 -0000	1.2.4.4
@@ -236,9 +236,7 @@ void OGLTransitionerImpl::initWindowFrom
             SystemWindowData winData;
             winData.nSize = sizeof(winData);
             winData.pVisual = (void*)(vi->visual);
-            pWindow=new SystemChildWindow(pPWindow,
-                                          0,
-                                          &winData);
+            pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
             pChildSysData = pWindow->GetSystemData();
             if( pChildSysData )
             {
@@ -275,10 +273,9 @@ void OGLTransitionerImpl::initWindowFrom
                                  GL_TRUE);
 
     glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
-
-    OSL_ENSURE( glXIsDirect(GLWin.dpy, GLWin.ctx) , "Can't Directly Render to the Screen, perhaps 3D transitions aren't for you." );
     glEnable(GL_CULL_FACE);
     glCullFace(GL_BACK);
+    glClearColor (0, 0, 0, 0);
     glClear(GL_COLOR_BUFFER_BIT);
     unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
     
@@ -290,8 +287,11 @@ void OGLTransitionerImpl::initWindowFrom
     glEnable(GL_LIGHT0);
     glEnable(GL_NORMALIZE);
         
-    if( EnteringBytes.hasElements() && EnteringBytes.hasElements())
+    if( LeavingBytes.hasElements() && EnteringBytes.hasElements())
        GLInitSlides();//we already have uninitialized slides, let's initialize 
+
+    if (pTransition)
+        pTransition->prepare ();
 }
 
 void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
@@ -333,20 +333,22 @@ void OGLTransitionerImpl::GLInitSlides()
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     double EyePos(10.0);
-    double RealF(-1.0);
-    double RealN(1.0);
+    double RealF(1.0);
+    double RealN(-1.0);
     double RealL(-1.0);
     double RealR(1.0);
     double RealB(-1.0);
     double RealT(1.0);
-    double ClipN(EyePos+2.0*RealN);
-    double ClipF(EyePos+2.0*RealF);
+    double ClipN(EyePos+5.0*RealN);
+    double ClipF(EyePos+15.0*RealF);
     double ClipL(RealL*8.0);
     double ClipR(RealR*8.0);
     double ClipB(RealB*8.0);
     double ClipT(RealT*8.0);
     //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
-    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ), 1 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ) , 1.0 );
+    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ),
+              1.0 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ),
+              1.0 );
 	glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
@@ -449,11 +451,12 @@ void SAL_CALL OGLTransitionerImpl::updat
         
     glEnable(GL_DEPTH_TEST);
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-	//glLoadIdentity();
+
 	if(pTransition)
 	    pTransition->display( nTime , GLleavingSlide , GLenteringSlide , 
-                              SlideSize.Width/static_cast<double>(GLWin.Width),
-                              SlideSize.Height/static_cast<double>(GLWin.Height) );
+                              SlideSize.Width, SlideSize.Height,
+                              static_cast<double>(GLWin.Width),
+                              static_cast<double>(GLWin.Height) );
 	unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
 	if( pWindow )
         pWindow->Show();
@@ -465,6 +468,10 @@ void OGLTransitionerImpl::disposing()
     osl::MutexGuard const guard( m_aMutex );
     glDeleteTextures(1,&GLleavingSlide);
     glDeleteTextures(1,&GLenteringSlide);
+
+    if (pTransition)
+        pTransition->finish();
+
     if(GLWin.ctx)
 	{
 	    OSL_ENSURE( glXMakeCurrent(GLWin.dpy, None, NULL) , "Error releasing glX context" );
@@ -512,6 +519,11 @@ public:
             case animations::TransitionSubType::CIRCLE:
             case animations::TransitionSubType::FANOUTHORIZONTAL:
             case animations::TransitionSubType::CORNERSIN:  
+            case animations::TransitionSubType::LEFTTORIGHT:
+            case animations::TransitionSubType::TOPTOBOTTOM:
+            case animations::TransitionSubType::TOPRIGHT:
+            case animations::TransitionSubType::TOPLEFT:
+            case animations::TransitionSubType::BOTTOMRIGHT:
                 return sal_True;
 
             default:
@@ -548,6 +560,21 @@ public:
             case animations::TransitionSubType::CORNERSIN :  
                 pTransition->makeInsideCubeFaceToLeft();
                 break;
+            case animations::TransitionSubType::LEFTTORIGHT:
+                pTransition->makeFallLeaving();
+                break;
+            case animations::TransitionSubType::TOPTOBOTTOM:
+                pTransition->makeTurnAround();
+                break;
+            case animations::TransitionSubType::TOPRIGHT:
+                pTransition->makeTurnDown();
+                break;
+            case animations::TransitionSubType::TOPLEFT:
+                pTransition->makeIris();
+                break;
+            case animations::TransitionSubType::BOTTOMRIGHT:
+                pTransition->makeRochade();
+                break;
             default:
                 return uno::Reference< presentation::XTransition >();
         }
--- slideshow/source/inc/activitiesqueue.hxx	17 Jul 2007 15:01:06 -0000	1.8
+++ slideshow/source/inc/activitiesqueue.hxx	16 Jan 2008 10:22:09 -0000	1.8.32.2
@@ -102,6 +102,13 @@ namespace slideshow
             ::boost::shared_ptr< ::canvas::tools::ElapsedTime > const &
             getTimer() const { return mpTimer; }
             
+            /** returns number of all activities, waiting, reinserted and dequeued
+             */
+            std::size_t size() const
+            { 
+                return maCurrentActivitiesWaiting.size() + maCurrentActivitiesReinsert.size() + maDequeuedActivities.size();
+            }
+            
         private:
             ::boost::shared_ptr< ::canvas::tools::ElapsedTime > mpTimer;
             
