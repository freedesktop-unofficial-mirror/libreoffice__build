Index: basic/inc/basic/sbmeth.hxx
===================================================================
RCS file: /cvs/script/basic/inc/basic/sbmeth.hxx,v
retrieving revision 1.3
retrieving revision 1.2.80.3
diff -u -p -b -w -B -r1.3 -r1.2.80.3
--- basic/inc/basic/sbmeth.hxx	11 Apr 2008 11:22:05 -0000	1.3
+++ basic/inc/basic/sbmeth.hxx	7 May 2008 07:10:04 -0000	1.2.80.3
@@ -55,6 +54,7 @@ class SbMethod : public SbxMethod
 	USHORT	  nLine1, nLine2;
 	UINT32	  nStart;
 	BOOL	  bInvalid;
+	SbxArrayRef refStatics;
 	SbMethod( const String&, SbxDataType, SbModule* );
 	SbMethod( const SbMethod& );
 	virtual BOOL LoadData( SvStream&, USHORT );
@@ -67,6 +67,7 @@ public:
 	virtual SbxInfo* GetInfo();
 	SbxArray* GetLocals();
 	SbxArray* GetStatics();
+	void      ClearStatics();
 	SbModule* GetModule() 				 { return pMod; 	   }
 	UINT32	  GetId() const				 { return nStart;	   }
 	USHORT    GetDebugFlags()			 { return nDebugFlags; }
Index: basic/source/classes/sbxmod.cxx
===================================================================
RCS file: /cvs/script/basic/source/classes/sbxmod.cxx,v
retrieving revision 1.42
retrieving revision 1.41.34.3
diff -u -p -b -w -B -r1.42 -r1.41.34.3
--- basic/source/classes/sbxmod.cxx	11 Apr 2008 11:48:19 -0000	1.42
+++ basic/source/classes/sbxmod.cxx	7 May 2008 07:11:30 -0000	1.41.34.3
@@ -1926,6 +1926,7 @@ SbMethod::SbMethod( const String& r, Sbx
 	nDebugFlags  =
 	nLine1		 =
 	nLine2		 = 0;
+	refStatics = new SbxArray;
 	// AB: 2.7.1996: HACK wegen 'Referenz kann nicht gesichert werden'
 	SetFlag( SBX_NO_MODIFY );
 }
@@ -1939,6 +1940,7 @@ SbMethod::SbMethod( const SbMethod& r )
 	nDebugFlags  = r.nDebugFlags;
 	nLine1		 = r.nLine1;
 	nLine2		 = r.nLine2;
+        refStatics = r.refStatics; 
 	SetFlag( SBX_NO_MODIFY );
 }
 
@@ -1954,10 +1956,14 @@ SbxArray* SbMethod::GetLocals()
 		return NULL;
 }
 
+void SbMethod::ClearStatics()
+{
+	refStatics = new SbxArray;
+	
+}
 SbxArray* SbMethod::GetStatics()
 {
-	DBG_ERROR( "SbMethod::GetStatics() invalid, AB fragen" )
-	return NULL;
+	return refStatics;
 }
 
 BOOL SbMethod::LoadData( SvStream& rStrm, USHORT nVer )
Index: basic/source/comp/dim.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/dim.cxx,v
retrieving revision 1.29
retrieving revision 1.28.40.6
diff -u -p -b -w -B -r1.29 -r1.28.40.6
--- basic/source/comp/dim.cxx	11 Apr 2008 11:49:15 -0000	1.29
+++ basic/source/comp/dim.cxx	7 May 2008 07:10:48 -0000	1.28.40.6
@@ -181,7 +181,7 @@ void SbiParser::TypeDecl( SbiSymDef& rDe
 
 void SbiParser::Dim()
 {
-	DefVar( _DIM, FALSE );
+	DefVar( _DIM, ( pProc && bVBASupportOn ) ? pProc->IsStatic() : FALSE );
 }
 
 void SbiParser::DefVar( SbiOpcode eOp, BOOL bStatic )
@@ -267,7 +267,7 @@ void SbiParser::DefVar( SbiOpcode eOp, B
 
 	// AB 9.7.97, #40689, Statics -> Modul-Initialisierung, in Sub ueberspringen
 	UINT32 nEndOfStaticLbl = 0;
-	if( bStatic )
+	if( !bVBASupportOn && bStatic )
 	{
 		nEndOfStaticLbl = aGen.Gen( _JUMP, 0 );
 		aGen.Statement();	// bei static hier nachholen
@@ -335,13 +335,11 @@ void SbiParser::DefVar( SbiOpcode eOp, B
                                 goto global;
 				case SbPUBLIC:	eOp2 = bPersistantGlobal ? _PUBLIC_P : _PUBLIC;
 								// AB 9.7.97, #40689, kein eigener Opcode mehr
-								/*
-								if( bStatic )
+								if( bVBASupportOn && bStatic )
 								{
 									eOp2 = _STATIC;
 									break;
 								}
-								*/
 				global:			aGen.BackChain( nGblChain );
 								nGblChain = 0;
 								bGblDefs = bNewGblDefs = TRUE;
@@ -472,14 +470,14 @@ void SbiParser::DefVar( SbiOpcode eOp, B
 		// d.h. pPool muss immer am Schleifen-Ende zurueckgesetzt werden.
 		// auch bei break
 		pPool = pOldPool;
-		continue;		// MyBreak überspingen
+		continue;		// MyBreak Ã¼berspingen
 	MyBreak:
 		pPool = pOldPool;
 		break;
 	}
 
 	// AB 9.7.97, #40689, Sprung ueber Statics-Deklaration abschliessen
-	if( bStatic )
+	if( !bVBASupportOn && bStatic )
 	{
 		// globalen Chain pflegen
 		nGblChain = aGen.Gen( _JUMP, 0 );
@@ -496,7 +494,7 @@ void SbiParser::DefVar( SbiOpcode eOp, B
 
 void SbiParser::ReDim()
 {
-	DefVar( _REDIM, FALSE );
+	DefVar( _REDIM, (  pProc && bVBASupportOn ) ? pProc->IsStatic() : FALSE );
 }
 
 // ERASE array, ...
@@ -995,16 +993,20 @@ void SbiParser::DefProc( BOOL bStatic, B
 	// Prozedur.
 	aPublics.SetProcId( pProc->GetId() );
 	pProc->GetParams().SetParent( &aPublics );
-	if( !bStatic )
+	if( bStatic )
 	{
-		// Normalfall: Lokale Variable->Parameter->Globale Variable
-		pProc->GetLocals().SetParent( &pProc->GetParams() );
-		pPool = &pProc->GetLocals();
+		if ( bVBASupportOn )
+			pProc->SetStatic( TRUE );
+		else
+			Error( SbERR_NOT_IMPLEMENTED ); // STATIC SUB ...
 	}
 	else
 	{
-		Error( SbERR_NOT_IMPLEMENTED ); // STATIC SUB ...
+		pProc->SetStatic( FALSE );
 	}
+	// Normalfall: Lokale Variable->Parameter->Globale Variable
+	pProc->GetLocals().SetParent( &pProc->GetParams() );
+	pPool = &pProc->GetLocals();
 
 	pProc->Define();
 	OpenBlock( eExit );
Index: basic/source/comp/exprgen.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprgen.cxx,v
retrieving revision 1.17
retrieving revision 1.16.132.2
diff -u -p -b -w -B -r1.17 -r1.16.132.2
--- basic/source/comp/exprgen.cxx	11 Apr 2008 11:49:35 -0000	1.17
+++ basic/source/comp/exprgen.cxx	7 May 2008 07:10:52 -0000	1.16.132.2
@@ -127,9 +127,17 @@ void SbiExprNode::Gen( RecursiveMode eRe
                     (aVar.pDef->IsGlobal() ? _FIND_G : _FIND);
 		}
 
-		if( eOp == _FIND && pGen->GetParser()->bClassModule )
-			eOp = _FIND_CM;
+		if( eOp == _FIND )
+		{
 
+			SbiProcDef* pProc = aVar.pDef->GetProcDef();
+			if ( pGen->GetParser()->bClassModule )
+				eOp = _FIND_CM;
+			else if ( aVar.pDef->IsStatic() || pProc && pProc->IsStatic() )
+			{
+				eOp = _FIND_STATIC;
+			}
+		}
 		for( SbiExprNode* p = this; p; p = p->aVar.pNext )
 		{
 			if( p == this && pWithParent_ != NULL )
Index: basic/source/comp/exprtree.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprtree.cxx,v
retrieving revision 1.22
retrieving revision 1.19.64.3
diff -u -p -b -w -B -r1.22 -r1.19.64.3
--- basic/source/comp/exprtree.cxx	11 Apr 2008 11:50:24 -0000	1.22
+++ basic/source/comp/exprtree.cxx	7 May 2008 07:10:36 -0000	1.19.64.3
@@ -273,6 +273,11 @@ SbiExprNode* SbiExpression::Term()
 		if( bObj )
 			eType = SbxOBJECT;
 		pDef = AddSym( eTok, *pParser->pPool, eCurExpr, aSym, eType, pPar );
+		// Looks like this is a local ( but undefined variable )
+		// if it is in a static procedure then make this Symbol
+		// static
+		if ( !bObj && pParser->pProc && pParser->pProc->IsStatic() )
+		    pDef->SetStatic();
 	}
 	else
 	{
Index: basic/source/comp/sbcomp.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/sbcomp.cxx,v
retrieving revision 1.15
retrieving revision 1.14.64.2
diff -u -p -b -w -B -r1.15 -r1.14.64.2
--- basic/source/comp/sbcomp.cxx	11 Apr 2008 11:52:01 -0000	1.15
+++ basic/source/comp/sbcomp.cxx	7 May 2008 07:10:39 -0000	1.14.64.2
@@ -134,6 +134,13 @@ BOOL SbModule::Compile()
 	if( bRet )
 	{
 		pBasic->ClearAllModuleVars();
+		// clear all method statics
+		for( USHORT i = 0; i < pMethods->Count(); i++ )
+		{
+			SbMethod* p = PTR_CAST(SbMethod,pMethods->Get( i ) );
+			if( p )
+				p->ClearStatics();
+		}
 
 		// #i31510 Init other libs only if Basic isn't running
 		if( pINST == NULL )
Index: basic/source/comp/symtbl.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/symtbl.cxx,v
retrieving revision 1.19
retrieving revision 1.18.126.2
diff -u -p -b -w -B -r1.19 -r1.18.126.2
--- basic/source/comp/symtbl.cxx	11 Apr 2008 11:52:40 -0000	1.19
+++ basic/source/comp/symtbl.cxx	7 May 2008 07:10:43 -0000	1.18.126.2
@@ -423,6 +423,7 @@ SbiProcDef::SbiProcDef( SbiParser* pPars
 	mePropMode = PROPERTY_MODE_NONE;
 	bPublic = TRUE;
 	bCdecl	= FALSE;
+	bStatic = FALSE;
 	// Fuer Returnwerte ist das erste Element der Parameterliste
 	// immer mit dem Namen und dem Typ der Proc definiert
 	aParams.AddSym( aName );
Index: basic/source/inc/opcodes.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/opcodes.hxx,v
retrieving revision 1.13
retrieving revision 1.12.40.2
diff -u -p -b -w -B -r1.13 -r1.12.40.2
--- basic/source/inc/opcodes.hxx	11 Apr 2008 11:56:38 -0000	1.13
+++ basic/source/inc/opcodes.hxx	7 May 2008 07:10:08 -0000	1.12.40.2
@@ -162,6 +162,8 @@ enum SbiOpcode {
     _DCREATE_REDIMP,	// Objekt-Array redimensionieren (+StringId+StringID)
 	_FIND_CM,        	// Search inside a class module (CM) to enable global search in time
 	_PUBLIC_P, 			//  Module global Variable (persisted between calls)(+StringID+Typ)
+	_FIND_STATIC,        	//  local static var lookup (+StringID+Typ) 
+
 	SbOP2_END
 
 };
Index: basic/source/inc/runtime.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/runtime.hxx,v
retrieving revision 1.36
retrieving revision 1.35.40.4
diff -u -p -b -w -B -r1.36 -r1.35.40.4
--- basic/source/inc/runtime.hxx	11 Apr 2008 11:57:39 -0000	1.36
+++ basic/source/inc/runtime.hxx	7 May 2008 07:10:16 -0000	1.35.40.4
@@ -373,7 +373,7 @@ class SbiRuntime
 	}
 
 	SbxVariable* FindElement
-	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError, BOOL );
+	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError, BOOL bLocal, BOOL bStatic = FALSE );
 	void SetupArgs( SbxVariable*, UINT32 );
 	SbxVariable* CheckArray( SbxVariable* );
 
@@ -445,16 +445,19 @@ class SbiRuntime
 	// Alle Opcodes mit zwei Operanden
 	void StepRTL( UINT32, UINT32 ),		StepPUBLIC( UINT32, UINT32 ),	StepPUBLIC_P( UINT32, UINT32 );		
 	void StepPUBLIC_Impl( UINT32, UINT32, bool bUsedForClassModule );
+	void StepFIND_Impl( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError, BOOL bLocal, BOOL bStatic = FALSE );
 	void StepFIND( UINT32, UINT32 ),    StepELEM( UINT32, UINT32 );
 	void StepGLOBAL( UINT32, UINT32 ),  StepLOCAL( UINT32, UINT32 );
 	void StepPARAM( UINT32, UINT32), 	StepCREATE( UINT32, UINT32 );
 	void StepCALL( UINT32, UINT32 ),    StepCALLC( UINT32, UINT32 );
 	void StepCASEIS( UINT32, UINT32 ),  StepSTMNT( UINT32, UINT32 );
+	SbxVariable* StepSTATIC_Impl( String& aName, SbxDataType& t );
 	void StepOPEN( UINT32, UINT32 ),	StepSTATIC( UINT32, UINT32 );
 	void StepTCREATE(UINT32,UINT32),	StepDCREATE(UINT32,UINT32);
 	void StepGLOBAL_P( UINT32, UINT32 ),StepFIND_G( UINT32, UINT32 );
 	void StepDCREATE_REDIMP(UINT32,UINT32), StepDCREATE_IMPL(UINT32,UINT32);
 	void StepFIND_CM( UINT32, UINT32 );
+	void StepFIND_STATIC( UINT32, UINT32 );
 public:
 	void          SetVBAEnabled( bool bEnabled ) { bVBAEnabled = bEnabled; };            
 	USHORT		GetImageFlag( USHORT n ) const;
@@ -541,5 +544,6 @@ inline String getFullPathUNC( const Stri
     return getFullPath( aRelPath );
 }
 void implStepRenameOSL( const String& aSource, const String& aDest );
+bool IsBaseIndexOne();
 
 #endif
Index: basic/source/inc/symtbl.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/symtbl.hxx,v
retrieving revision 1.12
retrieving revision 1.11.64.2
diff -u -p -b -w -B -r1.12 -r1.11.64.2
--- basic/source/inc/symtbl.hxx	11 Apr 2008 12:00:13 -0000	1.12
+++ basic/source/inc/symtbl.hxx	7 May 2008 07:10:12 -0000	1.11.64.2
@@ -194,6 +194,7 @@ class SbiProcDef : public SbiSymDef {	//
 	BOOL   bCdecl  : 1;				// TRUE: CDECL angegeben
 	BOOL   bPublic : 1;				// TRUE: proc ist PUBLIC
 	BOOL   mbProcDecl : 1;			// TRUE: instanciated by SbiParser::ProcDecl
+	BOOL   bStatic : 1;				// TRUE:
 public:
 	SbiProcDef( SbiParser*, const String&, BOOL bProcDecl=false );
 	virtual ~SbiProcDef();
@@ -206,6 +207,8 @@ public:
 	String& GetAlias() 		  		{ return aAlias;   }
 	void SetPublic( BOOL b )		{ bPublic = b;	   }
 	BOOL IsPublic() const			{ return bPublic;  }
+	void SetStatic( BOOL b )		{ bStatic = b;	   }
+	BOOL IsStatic() const			{ return bStatic;  }
 	void SetCdecl( BOOL b = TRUE) 	{ bCdecl = b;      }
 	BOOL IsCdecl() const			{ return bCdecl;   }
 	BOOL IsUsedForProcDecl() const	{ return mbProcDecl; }
Index: basic/source/runtime/methods.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/methods.cxx,v
retrieving revision 1.79
retrieving revision 1.77.34.15
diff -u -p -b -w -B -r1.79 -r1.77.34.15
--- basic/source/runtime/methods.cxx	11 Apr 2008 12:03:12 -0000	1.79
+++ basic/source/runtime/methods.cxx	12 May 2008 03:35:52 -0000	1.77.34.15
@@ -54,8 +54,13 @@
 
 #include "runtime.hxx"
 #include "sbunoobj.hxx"
-#ifdef _OLD_FILE_IMPL
+#ifdef WNT
+#include <tools/prewin.h>
+#include "winbase.h"
+#include <tools/postwin.h>
+#ifndef _FSYS_HXX //autogen
 #include <tools/fsys.hxx>
+#endif
 #else
 #include <osl/file.hxx>
 #endif
@@ -1319,6 +1324,87 @@ RTLFUNC(Oct)
 	}
 }
 
+// Replace(expression, find, replace[, start[, count[, compare]]]) 
+
+RTLFUNC(Replace)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	ULONG nArgCount = rPar.Count()-1;
+	if ( nArgCount < 3 || nArgCount > 6 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		String aExpStr = rPar.Get(1)->GetString();
+		String aFindStr = rPar.Get(2)->GetString();
+		String aReplaceStr = rPar.Get(3)->GetString();
+
+		INT32 lStartPos = 1;
+		if ( nArgCount >= 4 )
+		{
+			if( rPar.Get(4)->GetType() != SbxEMPTY )
+				lStartPos = rPar.Get(4)->GetLong();
+			if( lStartPos < 1  || lStartPos > 0xffff )
+			{
+				StarBASIC::Error( SbERR_BAD_ARGUMENT );
+				lStartPos = 1;
+			}
+		}
+
+		INT32 lCount = -1;
+		if( nArgCount >=5 )
+		{
+			if( rPar.Get(5)->GetType() != SbxEMPTY )
+				lCount = rPar.Get(5)->GetLong();
+			if( lCount < -1 || lCount > 0xffff )
+			{
+				StarBASIC::Error( SbERR_BAD_ARGUMENT );
+				lCount = -1;	
+			}
+		}
+
+		SbiInstance* pInst = pINST;
+		int bTextMode;
+		bool bCompatibility = ( pInst && pInst->IsCompatibility() );
+		if( bCompatibility )
+		{
+			SbiRuntime* pRT = pInst ? pInst->pRun : NULL;
+			bTextMode = pRT ? pRT->GetImageFlag( SBIMG_COMPARETEXT ) : FALSE;
+		}
+		else
+		{
+			bTextMode = 1;
+		}
+		if ( nArgCount == 6 )
+			bTextMode = rPar.Get(6)->GetInteger();
+
+		USHORT nStrLen = aExpStr.Len();
+
+		if( lStartPos <= nStrLen )
+		{
+			String aSrcStr( aExpStr );
+			if( bTextMode )
+			{
+					aSrcStr.ToUpperAscii();
+					aFindStr.ToUpperAscii();
+			}
+			
+			USHORT nPos = aSrcStr.Search( aFindStr, static_cast<USHORT>( lStartPos - 1 ) );
+			USHORT nCounts = 0;
+			USHORT nReplaceLength = aReplaceStr.Len() ? aReplaceStr.Len():1;
+			while( nPos != STRING_NOTFOUND && (lCount == -1 || lCount > nCounts) )
+			{
+				aExpStr.Replace( nPos, aFindStr.Len(), aReplaceStr );
+				nPos = nPos + nReplaceLength;
+				nPos = aSrcStr.Search( aFindStr, nPos );
+				nCounts++;
+			}
+		}
+		rPar.Get(0)->PutString( aExpStr.Copy( static_cast<USHORT>(lStartPos - 1) )  );
+	}
+}
+
 RTLFUNC(Right)
 {
     (void)pBasic;
@@ -2802,6 +2888,32 @@ RTLFUNC(GetAttr)
 	{
 		INT16 nFlags = 0;
 
+		// In Windows, We want to use Windows API to get the file attributes
+		// for VBA interoperability.
+	#if defined( WNT )
+		if( SbiRuntime::isVBAEnabled() )
+		{
+			DirEntry aEntry( rPar.Get(1)->GetString() );
+			aEntry.ToAbs();
+
+			// #57064 Bei virtuellen URLs den Real-Path extrahieren
+			ByteString aByteStrFullPath( aEntry.GetFull(), gsl_getSystemTextEncoding() );
+			DWORD nRealFlags = GetFileAttributes (aByteStrFullPath.GetBuffer());
+			if (nRealFlags != 0xffffffff)
+			{
+				if (nRealFlags == FILE_ATTRIBUTE_NORMAL)
+					nRealFlags = 0;
+				nFlags = (INT16) (nRealFlags);
+			}
+			else
+				StarBASIC::Error( SbERR_FILE_NOT_FOUND );
+
+			rPar.Get(0)->PutInteger( nFlags );
+
+			return;
+		}
+	#endif	
+		
 		// <-- UCB
 		if( hasUno() )
 		{
@@ -2839,51 +2951,6 @@ RTLFUNC(GetAttr)
 		else
 		// --> UCB
 		{
-#ifdef _OLD_FILE_IMPL
-			DirEntry aEntry( rPar.Get(1)->GetString() );
-			aEntry.ToAbs();
-			BOOL bUseFileStat = FALSE;
-
-			// #57064 Bei virtuellen URLs den Real-Path extrahieren
-			String aFile = aEntry.GetFull();
-			ByteString aByteStrFullPath( aEntry.GetFull(), gsl_getSystemTextEncoding() );
-	#if defined( WIN )
-			int nErr = _dos_getfileattr( aByteStrFullPath.GetBuffer(),(unsigned *) &nFlags );
-			if ( nErr )
-				StarBASIC::Error( SbERR_FILE_NOT_FOUND );
-	#elif defined( WNT )
-			DWORD nRealFlags = GetFileAttributes (aByteStrFullPath.GetBuffer());
-			if (nRealFlags != 0xffffffff)
-			{
-				if (nRealFlags == FILE_ATTRIBUTE_NORMAL)
-					nRealFlags = 0;
-				nFlags = (INT16) (nRealFlags);
-			}
-			else
-				StarBASIC::Error( SbERR_FILE_NOT_FOUND );
-	#elif defined( OS2 )
-			FILESTATUS3 aFileStatus;
-			APIRET rc = DosQueryPathInfo(aByteStrFullPath.GetBuffer(),1,
-										 &aFileStatus,sizeof(FILESTATUS3));
-			if (!rc)
-				nFlags = (INT16) aFileStatus.attrFile;
-			else
-				StarBASIC::Error( SbERR_FILE_NOT_FOUND );
-	#else
-			bUseFileStat = TRUE;
-	#endif
-			if( bUseFileStat )
-			{
-				if( FileStat::GetReadOnlyFlag( aEntry ) )
-					nFlags |= 0x0001; // ATTR_READONLY
-				FileStat aStat( aEntry );
-				DirEntryKind eKind = aStat.GetKind();
-				if( eKind & FSYS_KIND_DIR )
-					nFlags |= 0x0010; // ATTR_DIRECTORY
-				if( aEntry.GetFlag() & FSYS_FLAG_VOLUME )
-					nFlags |= 0x0008; // ATTR_VOLUME
-			}
-#else
 			DirectoryItem aItem;
 			FileBase::RC nRet = DirectoryItem::get( getFullPathUNC( rPar.Get(1)->GetString() ), aItem );
 			FileStatus aFileStatus( FileStatusMask_Attributes | FileStatusMask_Type );
@@ -2897,8 +2964,6 @@ RTLFUNC(GetAttr)
 				nFlags |= 0x0001; // ATTR_READONLY
 			if( bDirectory )
 				nFlags |= 0x0010; // ATTR_DIRECTORY
-
-#endif
 		}
 		rPar.Get(0)->PutInteger( nFlags );
 	}
@@ -3832,20 +3897,134 @@ RTLFUNC(QBColor)
 	rPar.Get(0)->PutLong( nRGB );
 }
 
-
+// StrConv(string, conversion, LCID)
 RTLFUNC(StrConv)
 {
     (void)pBasic;
     (void)bWrite;
-    (void)rPar;
     
-	DBG_ASSERT(0,"StrConv:Not implemented");
-//	if ( rPar.Count() != 3 )
-//	{
+	ULONG nArgCount = rPar.Count()-1;
+	if( nArgCount < 2 || nArgCount > 3 )
+	{
 		StarBASIC::Error( SbERR_BAD_ARGUMENT );
-//		return;
-//	}
+		return;	
+	}
+
+	String aOldStr = rPar.Get(1)->GetString(); 
+	INT32 nConversion = rPar.Get(2)->GetLong();
+	
+	USHORT nLanguage = LANGUAGE_SYSTEM;
+	if( nArgCount == 3 )
+	{
+		// LCID not supported now	
+		//nLanguage = rPar.Get(3)->GetInteger();
+	}
+
+	USHORT nOldLen = aOldStr.Len();
+	if( nOldLen == 0 )
+	{
+		// null string,return 
+		rPar.Get(0)->PutString(aOldStr);
+		return;
+	}
+
+	INT32 nType = 0;
+	if ( (nConversion & 0x03) == 3 ) //  vbProperCase
+	{
+		CharClass& rCharClass = GetCharClass();
+		aOldStr = rCharClass.toTitle( aOldStr.ToLowerAscii(), 0, nOldLen );
+	}
+	else if ( (nConversion & 0x01) == 1 ) // vbUpperCase
+		nType |= ::com::sun::star::i18n::TransliterationModules_LOWERCASE_UPPERCASE;
+	else if ( (nConversion & 0x02) == 2 ) // vbLowerCase
+		nType |= ::com::sun::star::i18n::TransliterationModules_UPPERCASE_LOWERCASE;
+	
+	if ( (nConversion & 0x04) == 4 ) // vbWide
+		nType |= ::com::sun::star::i18n::TransliterationModules_HALFWIDTH_FULLWIDTH;
+	else if ( (nConversion & 0x08) == 8 ) // vbNarrow
+		nType |= ::com::sun::star::i18n::TransliterationModules_FULLWIDTH_HALFWIDTH;
+
+	if ( (nConversion & 0x10) == 16) // vbKatakana
+		nType |= ::com::sun::star::i18n::TransliterationModules_HIRAGANA_KATAKANA;
+	else if ( (nConversion & 0x20) == 32 ) // vbHiragana
+		nType |= ::com::sun::star::i18n::TransliterationModules_KATAKANA_HIRAGANA;
+
+	String aNewStr( aOldStr );
+	if( nType != 0 )
+	{
+		Reference< XMultiServiceFactory > xSMgr = getProcessServiceFactory();
+    	::utl::TransliterationWrapper aTransliterationWrapper( xSMgr,nType );
+		com::sun::star::uno::Sequence<sal_Int32> aOffsets;
+		aTransliterationWrapper.loadModuleIfNeeded( nLanguage );
+		aNewStr = aTransliterationWrapper.transliterate( aOldStr, nLanguage, 0, nOldLen, &aOffsets );
+	}
+
+	if ( (nConversion & 0x40) == 64 ) // vbUnicode
+	{
+		// convert the string to byte string, preserving unicode (2 bytes per character)
+		USHORT nSize = aNewStr.Len()*2;
+		const sal_Unicode* pSrc = aNewStr.GetBuffer();
+		sal_Char* pChar = new sal_Char[nSize+1];
+		for( USHORT i=0; i < nSize; i++ )
+		{
+			pChar[i] = static_cast< sal_Char >( i%2 ? ((*pSrc) >> 8) & 0xff : (*pSrc) & 0xff );
+			if( i%2 )
+				pSrc++;	
+		}
+		pChar[nSize] = '\0';
+		OString aOStr(pChar);	
+		
+		// there is no concept about default codepage in unix. so it is incorrectly in unix 
+		OUString aOUStr = OStringToOUString(aOStr, osl_getThreadTextEncoding());
+		aNewStr = String(aOUStr);
+		rPar.Get(0)->PutString( aNewStr );
+		return;
+	}
+	else if ( (nConversion & 0x80) == 128 ) // vbFromUnicode
+	{
+		OUString aOUStr(aNewStr);
+		// there is no concept about default codepage in unix. so it is incorrectly in unix 
+		OString aOStr = OUStringToOString(aNewStr,osl_getThreadTextEncoding());
+		const sal_Char* pChar = aOStr.getStr();
+		USHORT nArraySize = static_cast< USHORT >( aOStr.getLength() );
+		SbxDimArray* pArray = new SbxDimArray(SbxBYTE);
+		bool bIncIndex = (IsBaseIndexOne() && SbiRuntime::isVBAEnabled() );
+		if(nArraySize)
+		{
+			if( bIncIndex )
+				pArray->AddDim( 1, nArraySize );
+			else
+				pArray->AddDim( 0, nArraySize-1 );	
 }
+		else
+		{
+			pArray->unoAddDim( 0, -1 );	
+		}
+
+		for( USHORT	i=0; i< nArraySize; i++)
+		{
+			SbxVariable* pNew = new SbxVariable( SbxBYTE );
+			pNew->PutByte(*pChar);
+			pChar++;
+			pNew->SetFlag( SBX_WRITE );
+			short index = i;
+			if( bIncIndex )
+				++index;
+			pArray->Put( pNew, &index );	
+		}
+
+		SbxVariableRef refVar = rPar.Get(0);
+		USHORT nFlags = refVar->GetFlags();
+		refVar->ResetFlag( SBX_FIXED );
+		refVar->PutObject( pArray );
+		refVar->SetFlags( nFlags );
+	    refVar->SetParameters( NULL );
+   		return;	   
+	}
+
+	rPar.Get(0)->PutString(aNewStr);
+}
+
 
 RTLFUNC(Beep)
 {
@@ -4230,3 +4409,82 @@ RTLFUNC(FileExists)
 		StarBASIC::Error( SbERR_BAD_ARGUMENT );
 }
 
+RTLFUNC(Partition)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 5 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	INT32 nNumber = rPar.Get(1)->GetLong();
+	INT32 nStart = rPar.Get(2)->GetLong();
+	INT32 nStop = rPar.Get(3)->GetLong();
+	INT32 nInterval = rPar.Get(4)->GetLong();
+	
+	if( nStart < 0 || nStop <= nStart || nInterval < 1 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	// the Partition function inserts leading spaces before lowervalue and uppervalue
+    // so that they both have the same number of characters as the string
+    // representation of the value (Stop + 1). This ensures that if you use the output
+    // of the Partition function with several values of Number, the resulting text 
+	// will be handled properly during any subsequent sort operation.
+
+	// calculate the  maximun number of characters before lowervalue and uppervalue
+	OUString aBeforeStart = OUString::valueOf( nStart - 1 );
+	OUString aAfterStop = OUString::valueOf( nStop + 1 );
+	INT32 nLen1 = aBeforeStart.getLength();
+	INT32 nLen2 = aAfterStop.getLength();
+	INT32 nLen = nLen1 >= nLen2 ? nLen1:nLen2;
+
+	OUStringBuffer aRetStr( nLen * 2 + 1);
+	OUString aLowerValue;
+	OUString aUpperValue;	
+	if( nNumber < nStart )
+	{
+		aUpperValue = aBeforeStart;
+	}
+	else if( nNumber > nStop )
+	{
+		aLowerValue = aAfterStop;
+	}
+	else
+	{
+		INT32 nLowerValue = nNumber;
+		INT32 nUpperValue = nLowerValue;
+		if( nInterval > 1 )
+		{
+			nLowerValue = ((( nNumber - nStart ) / nInterval ) * nInterval ) + nStart;
+			nUpperValue = nLowerValue + nInterval - 1;
+		}
+		
+		aLowerValue = OUString::valueOf( nLowerValue );
+		aUpperValue = OUString::valueOf( nUpperValue );
+	}
+
+	nLen1 = aLowerValue.getLength();
+	nLen2 = aUpperValue.getLength();
+
+	if( nLen > nLen1 )
+	{
+		// appending the leading spaces for the lowervalue
+		for ( INT32 i= (nLen - nLen1) ; i > 0; --i )
+			aRetStr.appendAscii(" ");
+	}
+	aRetStr.append( aLowerValue ).appendAscii(":");
+	if( nLen > nLen2 )
+	{
+		// appending the leading spaces for the uppervalue
+		for ( INT32 i= (nLen - nLen2) ; i > 0; --i )
+			aRetStr.appendAscii(" ");
+	}
+	aRetStr.append( aUpperValue );
+	rPar.Get(0)->PutString( String(aRetStr.makeStringAndClear()) );
+}
Index: basic/source/runtime/rtlproto.hxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/rtlproto.hxx,v
retrieving revision 1.18
retrieving revision 1.17.64.5
diff -u -p -b -w -B -r1.18 -r1.17.64.5
--- basic/source/runtime/rtlproto.hxx	11 Apr 2008 12:04:28 -0000	1.18
+++ basic/source/runtime/rtlproto.hxx	7 May 2008 07:11:00 -0000	1.17.64.5
@@ -184,6 +184,7 @@ extern RTLFUNC(Log);
 extern RTLFUNC(LTrim);
 extern RTLFUNC(Mid);
 extern RTLFUNC(Oct);
+extern RTLFUNC(Replace);
 extern RTLFUNC(Right);
 extern RTLFUNC(RTrim);
 extern RTLFUNC(RTL);
@@ -342,6 +343,7 @@ extern RTLFUNC(CDateFromIso);
 extern RTLFUNC(CompatibilityMode);
 extern RTLFUNC(CDec);
 
+extern RTLFUNC(Partition); // Fong
 
 extern double Now_Impl();
 extern void Wait_Impl( bool bDurationBased, SbxArray& rPar );
Index: basic/source/runtime/runtime.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/runtime.cxx,v
retrieving revision 1.37
retrieving revision 1.36.40.3
diff -u -p -b -w -B -r1.37 -r1.36.40.3
--- basic/source/runtime/runtime.cxx	11 Apr 2008 12:04:49 -0000	1.37
+++ basic/source/runtime/runtime.cxx	7 May 2008 07:11:18 -0000	1.36.40.3
@@ -194,6 +194,7 @@ SbiRuntime::pStep2 SbiRuntime::aStep2[] 
 	&SbiRuntime::StepDCREATE_REDIMP, // Objekt-Array redimensionieren (+StringID+StringID)
 	&SbiRuntime::StepFIND_CM,    // Search inside a class module (CM) to enable global search in time
 	&SbiRuntime::StepPUBLIC_P,    // Search inside a class module (CM) to enable global search in time
+	&SbiRuntime::StepFIND_STATIC,    // Search inside a class module (CM) to enable global search in time
 };
 
 
Index: basic/source/runtime/stdobj.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/stdobj.cxx,v
retrieving revision 1.26
retrieving revision 1.25.54.5
diff -u -p -b -w -B -r1.26 -r1.25.54.5
--- basic/source/runtime/stdobj.cxx	11 Apr 2008 12:05:08 -0000	1.26
+++ basic/source/runtime/stdobj.cxx	7 May 2008 07:11:24 -0000	1.25.54.5
@@ -418,6 +418,11 @@ static Methods aMethods[] = {
 { "Oct",            SbxSTRING,    1 | _FUNCTION, RTLNAME(Oct),0             },
   { "number",       SbxLONG, 0,NULL,0 },
 
+{ "Partition",      SbxSTRING,    4 | _FUNCTION, RTLNAME(Partition),0       },
+  { "number",   	SbxLONG, 	0,NULL,0 },
+  { "start",     	SbxLONG, 	0,NULL,0 },
+  { "stop",  	    SbxLONG, 	0,NULL,0 },
+  { "interval",     SbxLONG, 	0,NULL,0 },
 { "Pi",				SbxDOUBLE,		  _CPROP,    RTLNAME(PI),0		      	},
 { "Put",            SbxNULL,   3 | _FUNCTION, RTLNAME(Put),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
@@ -438,6 +443,13 @@ static Methods aMethods[] = {
   { "Red",       	SbxINTEGER, 0,NULL,0 },
   { "Green",       	SbxINTEGER, 0,NULL,0 },
   { "Blue",       	SbxINTEGER, 0,NULL,0 },
+{ "Replace",        SbxSTRING,    6 | _FUNCTION, RTLNAME(Replace),0         },
+  { "Expression",   SbxSTRING, 0,NULL,0 },
+  { "Find",     	SbxSTRING, 0,NULL,0 },
+  { "Replace",      SbxSTRING, 0,NULL,0 },
+  { "Start",        SbxINTEGER, 	_OPT, NULL,0 },
+  { "Count",        SbxINTEGER,		_OPT, NULL,0 },
+  { "Compare",      SbxINTEGER,		_OPT, NULL,0 },
 { "Right",          SbxSTRING,    2 | _FUNCTION, RTLNAME(Right),0           },
   { "String",       SbxSTRING, 0,NULL,0 },
   { "Count",        SbxLONG, 0,NULL,0 },
@@ -491,9 +503,10 @@ static Methods aMethods[] = {
   { "String1",      SbxSTRING, 0,NULL,0 },
   { "String2",      SbxSTRING, 0,NULL,0 },
   { "Compare",      SbxINTEGER,       _OPT, NULL,0 },
-{ "StrConv",        SbxSTRING,   2 | _FUNCTION, RTLNAME(StrConv),0          },
+{ "StrConv",        SbxOBJECT,   3 | _FUNCTION, RTLNAME(StrConv),0          },
   { "String",       SbxSTRING, 0,NULL,0 },
   { "Conversion",   SbxSTRING, 0,NULL,0 },
+  { "LCID",			SbxINTEGER, _OPT,NULL,0 },
 { "String",         SbxSTRING,    2 | _FUNCTION, RTLNAME(String),0          },
   { "Count",        SbxLONG, 0,NULL,0 },
   { "Filler",       SbxVARIANT, 0,NULL,0 },
Index: basic/source/runtime/step0.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step0.cxx,v
retrieving revision 1.30
retrieving revision 1.29.40.2
diff -u -p -b -w -B -r1.30 -r1.29.40.2
--- basic/source/runtime/step0.cxx	11 Apr 2008 12:05:46 -0000	1.30
+++ basic/source/runtime/step0.cxx	7 May 2008 07:10:56 -0000	1.29.40.2
@@ -313,8 +313,10 @@ void SbiRuntime::StepIS()
 	SbxVariableRef refVar2 = PopVar();
 	BOOL bRes = BOOL(
 		refVar1->GetType() == SbxOBJECT
-	 && refVar2->GetType() == SbxOBJECT
-	 && refVar1->GetObject() == refVar2->GetObject() );
+	 && refVar2->GetType() == SbxOBJECT );
+	if ( bVBAEnabled  && !bRes )
+		Error( SbERR_INVALID_USAGE_OBJECT );
+	bRes = ( bRes && refVar1->GetObject() == refVar2->GetObject() );
 	SbxVariable* pRes = new SbxVariable;
 	pRes->PutBool( bRes );
 	PushVar( pRes );
Index: basic/source/runtime/step2.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step2.cxx,v
retrieving revision 1.33
retrieving revision 1.32.40.4
diff -u -p -b -w -B -r1.33 -r1.32.40.4
--- basic/source/runtime/step2.cxx	11 Apr 2008 12:06:21 -0000	1.33
+++ basic/source/runtime/step2.cxx	7 May 2008 07:11:05 -0000	1.32.40.4
@@ -112,7 +112,7 @@ SbxVariable* VBAFind( const String& rNam
 // 0x8000 - Argv ist belegt
 
 SbxVariable* SbiRuntime::FindElement
-	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal )
+	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
 	bool bIsVBAInterOp = SbiRuntime::isVBAEnabled(); 
 	if( bIsVBAInterOp )
@@ -149,9 +149,17 @@ SbxVariable* SbiRuntime::FindElement
 			nOp1 = nOp1 | 0x8000; // indicate params are present
 			aName = String::CreateFromAscii("Evaluate");
 		}
-
 		if( bLocal )
+		{
+			if ( bStatic )
+			{	
+				if ( pMeth )
+					pElem = pMeth->GetStatics()->Find( aName, SbxCLASS_DONTCARE );
+			}
+
+			if ( !pElem )
 			pElem = refLocals->Find( aName, SbxCLASS_DONTCARE );
+		}
 		if( !pElem )
 		{
 			// Die RTL brauchen wir nicht mehr zu durchsuchen!
@@ -251,6 +259,10 @@ SbxVariable* SbiRuntime::FindElement
 				}
 				else
 				{
+					if ( bStatic )
+						pElem = StepSTATIC_Impl( aName, t );
+					if ( !pElem )
+					{
 					// Sonst Variable neu anlegen
 					pElem = new SbxVariable( t );
 					if( t != SbxVARIANT )
@@ -260,6 +272,7 @@ SbxVariable* SbiRuntime::FindElement
 				}
 			}
 		}
+		}
 		// #39108 Args koennen schon geloescht sein!
 		if( !bFatalError )
 			SetupArgs( pElem, nOp1 );
@@ -641,29 +654,39 @@ void SbiRuntime::StepRTL( UINT32 nOp1, U
 	PushVar( FindElement( rBasic.pRtl, nOp1, nOp2, SbERR_PROC_UNDEFINED, FALSE ) );
 }
 
+void
+SbiRuntime::StepFIND_Impl( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
+{
+	if( !refLocals )
+		refLocals = new SbxArray;
+	PushVar( FindElement( pObj, nOp1, nOp2, nNotFound, bLocal, bStatic ) );
+}
 // Laden einer lokalen/globalen Variablen (+StringID+Typ)
 
 void SbiRuntime::StepFIND( UINT32 nOp1, UINT32 nOp2 )
 {
-	if( !refLocals )
-		refLocals = new SbxArray;
-	PushVar( FindElement( pMod, nOp1, nOp2, SbERR_PROC_UNDEFINED, TRUE ) );
+	StepFIND_Impl( pMod, nOp1, nOp2, SbERR_PROC_UNDEFINED, TRUE );
 }
 
 // Search inside a class module (CM) to enable global search in time
 void SbiRuntime::StepFIND_CM( UINT32 nOp1, UINT32 nOp2 )
 {
-	if( !refLocals )
-		refLocals = new SbxArray;
 
 	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pMod);
 	if( pClassModuleObject )
 		pMod->SetFlag( SBX_GBLSEARCH );
-	PushVar( FindElement( pMod, nOp1, nOp2, SbERR_PROC_UNDEFINED, TRUE ) );
+
+	StepFIND_Impl( pMod, nOp1, nOp2, SbERR_PROC_UNDEFINED, TRUE );
+
 	if( pClassModuleObject )
 		pMod->ResetFlag( SBX_GBLSEARCH );
 }
 
+void SbiRuntime::StepFIND_STATIC( UINT32 nOp1, UINT32 nOp2 )
+{
+	StepFIND_Impl( pMod, nOp1, nOp2, SbERR_PROC_UNDEFINED, TRUE, TRUE );
+}
+
 // Laden eines Objekt-Elements (+StringID+Typ)
 // Das Objekt liegt auf TOS
 
@@ -1213,19 +1236,27 @@ void SbiRuntime::StepFIND_G( UINT32 nOp1
 }
 
 
+SbxVariable* SbiRuntime::StepSTATIC_Impl( String& aName, SbxDataType& t )
+{
+    SbxVariable* p = NULL;
+    if ( pMeth )
+    {
+        SbxArray* pStatics = pMeth->GetStatics();
+        if( pStatics && ( pStatics->Find( aName, SbxCLASS_DONTCARE ) == NULL ) )
+        {
+            p = new SbxVariable( t );
+            if( t != SbxVARIANT )
+                p->SetFlag( SBX_FIXED );
+            p->SetName( aName );
+            pStatics->Put( p, pStatics->Count() );
+        }
+    }
+    return p;
+}
 // Einrichten einer statischen Variablen (+StringID+Typ)
-
 void SbiRuntime::StepSTATIC( UINT32 nOp1, UINT32 nOp2 )
 {
-    (void)nOp1;
-    (void)nOp2;
-	/* AB #40689, wird nicht mehr verwendet
-	String aName( pImg->GetString( nOp1 ) );
+    String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
 	SbxDataType t = (SbxDataType) nOp2;
-	SbxVariable* p = new SbxVariable( t );
-	p->SetName( aName );
-	pInst -> GetStatics()->Put( p, pInst->GetStatics()->Count() );
-	*/
+    StepSTATIC_Impl( aName, t );
 }
-
-
Index: basic/source/sbx/sbxconv.hxx
===================================================================
RCS file: /cvs/script/basic/source/sbx/sbxconv.hxx,v
retrieving revision 1.5
retrieving revision 1.4.132.2
diff -u -p -b -w -B -r1.5 -r1.4.132.2
--- basic/source/sbx/sbxconv.hxx	11 Apr 2008 12:11:33 -0000	1.5
+++ basic/source/sbx/sbxconv.hxx	7 May 2008 07:10:32 -0000	1.4.132.2
@@ -33,6 +33,8 @@
 
 #include "sbxdec.hxx"
 
+class SbxArray;
+
 // SBXSCAN.CXX
 extern void ImpCvtNum( double nNum, short nPrec, String& rRes, BOOL bCoreString=FALSE );
 extern SbxError ImpScan
@@ -145,4 +147,8 @@ void    ImpPutULong( SbxValues*, UINT32 
 enum SbxBOOL ImpGetBool( const SbxValues* );
 void    ImpPutBool( SbxValues*, INT16 );
 
+// ByteArry <--> String
+SbxArray* StringToByteArray(const String& rStr);
+String ByteArrayToString(SbxArray* pArr);
+
 #endif
Index: basic/source/sbx/sbxscan.cxx
===================================================================
RCS file: /cvs/script/basic/source/sbx/sbxscan.cxx,v
retrieving revision 1.13
retrieving revision 1.12.18.2
diff -u -p -b -w -B -r1.13 -r1.12.18.2
--- basic/source/sbx/sbxscan.cxx	11 Apr 2008 12:19:34 -0000	1.13
+++ basic/source/sbx/sbxscan.cxx	7 May 2008 07:10:28 -0000	1.12.18.2
@@ -650,14 +650,94 @@ public:
 };
 
 
+enum VbaFormatType
+{
+    VBA_FORMAT_TYPE_OFFSET, // standard number format
+    VBA_FORMAT_TYPE_USERDEFINED, // user defined number format
+    VBA_FORMAT_TYPE_NULL
+};
+
+struct VbaFormatInfo
+{
+    VbaFormatType meType; 
+    const char* mpVbaFormat; // Format string in vba
+    NfIndexTableOffset meOffset; // SvNumberFormatter format index, if meType = VBA_FORMAT_TYPE_OFFSET
+    const char* mpOOoFormat; // if meType = VBA_FORMAT_TYPE_USERDEFINED
+};
+
+#define VBA_FORMAT_OFFSET( pcUtf8, eOffset ) \
+    { VBA_FORMAT_TYPE_OFFSET, pcUtf8, eOffset, 0 }
+
+#define VBA_FORMAT_USERDEFINED( pcUtf8, pcDefinedUtf8 ) \
+    { VBA_FORMAT_TYPE_USERDEFINED, pcUtf8, NF_NUMBER_STANDARD, pcDefinedUtf8 }
+
+static VbaFormatInfo pFormatInfoTable[] = 
+{
+    VBA_FORMAT_OFFSET( "Long Date", NF_DATE_SYSTEM_LONG ),
+    VBA_FORMAT_USERDEFINED( "Medium Date", "DD-MMM-YY" ),
+    VBA_FORMAT_OFFSET( "Short Date", NF_DATE_SYSTEM_SHORT ),
+    VBA_FORMAT_USERDEFINED( "Long Time", "H:MM:SS AM/PM" ), 
+    VBA_FORMAT_OFFSET( "Medium Time", NF_TIME_HHMMAMPM ),
+    VBA_FORMAT_OFFSET( "Short Time", NF_TIME_HHMM ),
+    VBA_FORMAT_OFFSET( "ddddd", NF_DATE_SYSTEM_SHORT ),
+    VBA_FORMAT_OFFSET( "dddddd", NF_DATE_SYSTEM_LONG ),
+    VBA_FORMAT_USERDEFINED( "ttttt", "H:MM:SS AM/PM" ),
+    VBA_FORMAT_OFFSET( "ww", NF_DATE_WW ),
+    { VBA_FORMAT_TYPE_NULL, 0, NF_INDEX_TABLE_ENTRIES, 0 }
+};
+
+VbaFormatInfo* getFormatInfo( const String& rFmt )
+{
+    VbaFormatInfo* pInfo = NULL;
+    INT16 i = 0;
+    while( (pInfo = pFormatInfoTable + i )->mpVbaFormat != NULL )
+    {
+        if( rFmt.EqualsIgnoreCaseAscii( pInfo->mpVbaFormat ) )
+            break;
+        i++;    
+    }
+    return pInfo;
+}
+
+#define VBAFORMAT_GENERALDATE       "General Date"
+#define VBAFORMAT_C                 "c"
+#define VBAFORMAT_N                 "n"
+#define VBAFORMAT_NN                "nn"
+#define VBAFORMAT_W                 "w"
+#define VBAFORMAT_Y                 "y"
+#define VBAFORMAT_LOWERCASE  		"<"
+#define VBAFORMAT_UPPERCASE  		">"
+
+// From methods1.cxx
+INT16 implGetWeekDay( double aDate, bool bFirstDayParam = false, INT16 nFirstDay = 0 );
+// from methods.cxx
+INT16 implGetMinute( double dDate );
+INT16 implGetDateYear( double aDate );
+BOOL implDateSerial( INT16 nYear, INT16 nMonth, INT16 nDay, double& rdRet );
+
 void SbxValue::Format( XubString& rRes, const XubString* pFmt ) const
 {
 	short nComma = 0;
 	double d = 0;
 
-	// Check for date format
+	// pflin, It is better to use SvNumberFormatter to handle the date/time/number format.
+	// the SvNumberFormatter output is mostly compatible with 
+	// VBA output besides the OOo-basic output
 	if( pFmt && !SbxBasicFormater::isBasicFormat( *pFmt ) )
 	{
+		String aStr = GetString();
+
+		if( pFmt->EqualsIgnoreCaseAscii( VBAFORMAT_LOWERCASE ) )
+		{
+			rRes = aStr.ToLowerAscii();
+			return;
+		}
+		if( pFmt->EqualsIgnoreCaseAscii( VBAFORMAT_UPPERCASE ) )
+		{
+			rRes = aStr.ToUpperAscii();
+			return;
+		}
+
 		LanguageType eLangType = GetpApp()->GetSettings().GetLanguage();
 		com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > 
 			xFactory = comphelper::getProcessServiceFactory();
@@ -666,22 +746,92 @@ void SbxValue::Format( XubString& rRes, 
 		sal_uInt32 nIndex;
 		xub_StrLen nCheckPos = 0;
 		short nType;
+		double nNumber;
+		Color* pCol;
 
+	    BOOL bSuccess = aFormatter.IsNumberFormat( aStr, nIndex, nNumber );
+
+    	// number format, use SvNumberFormatter to handle it. 
+	    if( bSuccess )
+    	{
 		String aFmtStr = *pFmt;
-		aFormatter.PutandConvertEntry( aFmtStr,
-			nCheckPos,
-			nType,
-			nIndex,
-			LANGUAGE_ENGLISH,
-			eLangType );
-
-		if( nType == NUMBERFORMAT_DATE ||
-			nType == NUMBERFORMAT_TIME ||
-			nType == NUMBERFORMAT_DATETIME )
-		{
-			double dt = GetDate();
-			Color* pColor;
-			aFormatter.GetOutputString( dt, nIndex, rRes, &pColor );
+	        VbaFormatInfo* pInfo = getFormatInfo( aFmtStr );
+    	    if( pInfo && pInfo->meType != VBA_FORMAT_TYPE_NULL )
+       		{
+            	if( pInfo->meType == VBA_FORMAT_TYPE_OFFSET )
+	            {
+    	            nIndex = aFormatter.GetFormatIndex( pInfo->meOffset, eLangType );
+            	}
+        	    else
+           		{
+                	aFmtStr.AssignAscii( pInfo->mpOOoFormat );
+	                aFormatter.PutandConvertEntry( aFmtStr, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH, eLangType );
+    	        }
+	    	    aFormatter.GetOutputString( nNumber, nIndex, rRes, &pCol );
+	        }
+    	    else if( aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_GENERALDATE )
+        	        || aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_C )) 
+	        {
+            	if( nNumber <=-1.0 || nNumber >= 1.0 )
+        	    {
+    	            // short date 
+            	    nIndex = aFormatter.GetFormatIndex( NF_DATE_SYSTEM_SHORT, eLangType );
+	           		aFormatter.GetOutputString( nNumber, nIndex, rRes, &pCol );
+                
+	                // long time
+    	            if( floor( nNumber ) != nNumber )
+        	        {
+                		aFmtStr.AssignAscii( "H:MM:SS AM/PM" );
+		                aFormatter.PutandConvertEntry( aFmtStr, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH, eLangType );
+                	    String aTime;
+		                aFormatter.GetOutputString( nNumber, nIndex, aTime, &pCol );
+    	                rRes.AppendAscii(" ");
+            	        rRes += aTime;
+        	        }
+            	}
+	            else
+    	        {
+        	        // long time only
+                	aFmtStr.AssignAscii( "H:MM:SS AM/PM" );
+		            aFormatter.PutandConvertEntry( aFmtStr, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH, eLangType );
+	            	aFormatter.GetOutputString( nNumber, nIndex, rRes, &pCol );
+	            }
+    	    }
+        	else if( aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_N )
+            	    || aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_NN )) 
+	        {
+    	        INT32 nMin = implGetMinute( nNumber );
+        	    if( nMin < 10 && aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_NN ) )
+            	{
+                	// Minute in two digits
+	                 sal_Unicode* p = rRes.AllocBuffer( 2 );
+    	             *p++ = '0';
+        	         *p = sal_Unicode( '0' + nMin );
+            	}
+	            else
+    	        {
+        	        rRes = String::CreateFromInt32( nMin );
+            	}
+	        }
+    	    else if( aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_W ))
+        	{
+	            INT32 nWeekDay = implGetWeekDay( nNumber );
+    	        rRes = String::CreateFromInt32( nWeekDay );
+        	}
+	        else if( aFmtStr.EqualsIgnoreCaseAscii( VBAFORMAT_Y ))
+    	    {
+				INT16 nYear = implGetDateYear( nNumber );
+				double dBaseDate;
+				implDateSerial( nYear, 1, 1, dBaseDate );
+				INT32 nYear32 = 1 + INT32( nNumber - dBaseDate );
+            	rRes = String::CreateFromInt32( nYear32 );
+	        }
+    	    else
+        	{
+	            aFormatter.PutandConvertEntry( aFmtStr, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH, eLangType );
+		        aFormatter.GetOutputString( nNumber, nIndex, rRes, &pCol );
+        	}
+
 			return;
 		}
 	}
Index: basic/source/sbx/sbxstr.cxx
===================================================================
RCS file: /cvs/script/basic/source/sbx/sbxstr.cxx,v
retrieving revision 1.8
retrieving revision 1.7.20.4
diff -u -p -b -w -B -r1.8 -r1.7.20.4
--- basic/source/sbx/sbxstr.cxx	11 Apr 2008 12:20:13 -0000	1.8
+++ basic/source/sbx/sbxstr.cxx	7 May 2008 07:10:20 -0000	1.7.20.4
@@ -34,7 +34,10 @@
 #include <basic/sbx.hxx>
 #include "sbxconv.hxx"
 #include "sbxres.hxx"
-
+#include "runtime.hxx"
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
+#endif
 // AB 29.10.99 Unicode
 #ifndef _USE_NO_NAMESPACE
 using namespace rtl;
@@ -94,6 +97,14 @@ XubString ImpGetString( const SbxValues*
 			SbxValue* pVal = PTR_CAST(SbxValue,p->pObj);
 			if( pVal )
 				aRes = pVal->GetString();
+			else if( p->pObj && p->pObj->IsFixed()
+					&& (p->pObj->GetType() & (SbxARRAY | SbxBYTE )) )
+			{
+				// convert byte array to string
+				SbxArray* pArr = PTR_CAST(SbxArray, p->pObj);
+				if( pArr )
+					aRes = ByteArrayToString( pArr );
+			}
 			else
 				SbxBase::SetError( SbxERR_NO_OBJECT );
 			break;
@@ -249,3 +260,65 @@ void ImpPutString( SbxValues* p, const X
 	delete pTmp;
 }
 
+// Convert string to an array of bytes, preserving unicode (2bytes per character)
+SbxArray* StringToByteArray(const String& rStr)
+{
+	USHORT nArraySize = rStr.Len() * 2;
+	const sal_Unicode* pSrc = rStr.GetBuffer();
+	SbxDimArray* pArray = new SbxDimArray(SbxBYTE);
+	bool bIncIndex = ( IsBaseIndexOne() && SbiRuntime::isVBAEnabled() );
+	if( nArraySize )
+	{
+		if( bIncIndex )
+			pArray->AddDim( 1, nArraySize );
+		else
+			pArray->AddDim( 0, nArraySize-1 );
+	}
+	else
+	{
+		pArray->unoAddDim( 0, -1 );
+	}
+
+	for( USHORT	i=0; i< nArraySize; i++)
+	{
+		SbxVariable* pNew = new SbxVariable( SbxBYTE );
+		BYTE aByte = static_cast< BYTE >( i%2 ? ((*pSrc) >> 8) & 0xff : (*pSrc) & 0xff );
+		pNew->PutByte( aByte );
+		pNew->SetFlag( SBX_WRITE );
+		pArray->Put( pNew, i );	
+		if( i%2 )
+			pSrc++;
+	}
+	return pArray;
+}	
+
+// Convert an array of bytes to string (2bytes per character)
+String ByteArrayToString(SbxArray* pArr)
+{
+	USHORT nCount = pArr->Count();
+	OUStringBuffer aStrBuf;
+	sal_Unicode aChar = 0;
+	for( USHORT i = 0 ; i < nCount ; i++ )
+	{
+		sal_Unicode aTempChar = pArr->Get(i)->GetByte();
+		if( i%2 )
+		{
+			aChar = (aTempChar << 8 ) | aChar;
+			aStrBuf.append(aChar);
+			aChar = 0;
+		}
+		else
+		{
+			aChar = aTempChar;	
+		}
+	}
+	
+	if( nCount%2 )
+	{
+		aStrBuf.append(aChar);
+	}
+
+	String aStr(aStrBuf.makeStringAndClear());
+	
+	return aStr;
+}
Index: basic/source/sbx/sbxvalue.cxx
===================================================================
RCS file: /cvs/script/basic/source/sbx/sbxvalue.cxx,v
retrieving revision 1.12
retrieving revision 1.10.40.5
diff -u -p -b -w -B -r1.12 -r1.10.40.5
--- basic/source/sbx/sbxvalue.cxx	11 Apr 2008 12:21:27 -0000	1.12
+++ basic/source/sbx/sbxvalue.cxx	7 May 2008 07:10:24 -0000	1.10.40.5
@@ -307,6 +307,30 @@ SbxValue& SbxValue::operator=( const Sbx
 			SetError( SbxERR_PROP_READONLY );
 		else
 		{
+			// string -> byte array
+			if( IsFixed() && (aData.eType == SbxOBJECT)
+				&& aData.pObj && ( aData.pObj->GetType() & (SbxARRAY | SbxBYTE) )		   	
+				&& (r.aData.eType == SbxSTRING) )
+			{
+				String aStr = r.GetString();
+				SbxArray* pArr = StringToByteArray(aStr);
+				PutObject(pArr);
+				return *this;
+			}
+			// byte array -> string
+			if( r.IsFixed() && (r.aData.eType == SbxOBJECT)
+				&& r.aData.pObj && ( r.aData.pObj->GetType() & (SbxARRAY | SbxBYTE) )
+				&& (aData.eType == SbxSTRING) )
+			{
+				SbxBase* pObj = r.GetObject();
+				SbxArray* pArr = PTR_CAST(SbxArray, pObj);
+				if( pArr )
+				{
+					String aStr = ByteArrayToString( pArr );
+					PutString(aStr);
+					return *this;
+				}
+			}
 			// Den Inhalt der Variablen auslesen
 			SbxValues aNew;
 			if( IsFixed() )
@@ -1434,8 +1458,10 @@ BOOL SbxValue::Compare( SbxOperator eOp,
 		ResetError();
 	if( !CanRead() || !rOp.CanRead() )
 		SetError( SbxERR_PROP_WRITEONLY );
-	else if( GetType() == SbxNULL && rOp.GetType() == SbxNULL )
+	else if( GetType() == SbxNULL && rOp.GetType() == SbxNULL && !bVBAInterop )
+    {
 		bRes = TRUE;
+    }
 	else if( GetType() == SbxEMPTY && rOp.GetType() == SbxEMPTY )
 		bRes = TRUE;
 	// Sonderregel 1: Ist ein Operand Null, ist das Ergebnis FALSE
