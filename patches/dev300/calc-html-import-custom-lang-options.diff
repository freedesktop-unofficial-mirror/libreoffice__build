diff --git sc/inc/column.hxx sc/inc/column.hxx
index 61286b6..0f9586e 100644
--- sc/inc/column.hxx
+++ sc/inc/column.hxx
@@ -244,7 +244,8 @@ public:
 				//	TRUE = Zahlformat gesetzt
 	BOOL		SetString( SCROW nRow, SCTAB nTab, const String& rString,
 						   formula::FormulaGrammar::AddressConvention conv = formula::FormulaGrammar::CONV_OOO,
-                           SvNumberFormatter* pFormatter = NULL );
+                           SvNumberFormatter* pFormatter = NULL,
+                           bool bDetectNumberFormat = true );
 	void		SetValue( SCROW nRow, const double& rVal);
 	void		SetError( SCROW nRow, const USHORT nError);
 
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 7765273..b31f9d6 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -737,7 +737,9 @@ public:
 	SC_DLLPUBLIC void			PutCell(SCCOL nCol, SCROW nRow, SCTAB nTab, ScBaseCell* pCell,
 							ULONG nFormatIndex, BOOL bForceTab = FALSE);
 					//	return TRUE = Zahlformat gesetzt
-    SC_DLLPUBLIC BOOL           SetString( SCCOL nCol, SCROW nRow, SCTAB nTab, const String& rString, SvNumberFormatter* pFormatter = NULL );
+    SC_DLLPUBLIC BOOL           SetString(
+        SCCOL nCol, SCROW nRow, SCTAB nTab, const String& rString, 
+        SvNumberFormatter* pFormatter = NULL, bool bDetectNumberFormat = true );
     SC_DLLPUBLIC void           SetValue( SCCOL nCol, SCROW nRow, SCTAB nTab, const double& rVal );
 	void 			SetError( SCCOL nCol, SCROW nRow, SCTAB nTab, const USHORT nError);
 
diff --git sc/inc/filter.hxx sc/inc/filter.hxx
index 275f787..793cce1 100644
--- sc/inc/filter.hxx
+++ sc/inc/filter.hxx
@@ -111,7 +111,7 @@ class ScFormatFilterPlugin {
 				 const CharSet eSrc = RTL_TEXTENCODING_DONTKNOW, UINT32 nDifOption = SC_DIFOPT_EXCEL ) = 0;
     virtual FltError ScImportRTF( SvStream&, const String& rBaseURL, ScDocument*, ScRange& rRange ) = 0;
     virtual FltError ScImportHTML( SvStream&, const String& rBaseURL, ScDocument*, ScRange& rRange, double nOutputFactor = 1.0, 
-                                   BOOL bCalcWidthHeight = TRUE, SvNumberFormatter* pFormatter = NULL ) = 0;
+                                   BOOL bCalcWidthHeight = TRUE, SvNumberFormatter* pFormatter = NULL, bool bConvertDate = true ) = 0;
 
     // various import helpers
     virtual ScEEAbsImport *CreateRTFImport( ScDocument* pDoc, const ScRange& rRange ) = 0;
diff --git sc/inc/scabstdlg.hxx sc/inc/scabstdlg.hxx
index 2c7f1e0..843eb70 100644
--- sc/inc/scabstdlg.hxx
+++ sc/inc/scabstdlg.hxx
@@ -309,6 +309,7 @@ class AbstractScLangChooserDlg : public VclAbstractDialog //add for ScLangChoose
 {
 public:
     virtual LanguageType GetLanguageType() const = 0;
+    virtual bool IsDateConversionSet() const = 0;
 };
 
 //-------Scabstract fractory ---------------------------
diff --git sc/inc/stringutil.hxx sc/inc/stringutil.hxx
new file mode 100644
index 0000000..4ca8629
--- /dev/null
+++ sc/inc/stringutil.hxx
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: table.hxx,v $
+ * $Revision: 1.35 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_STRINGUTIL_HXX
+#define SC_STRINGUTIL_HXX
+
+#include "rtl/ustring.hxx"
+
+class ScStringUtil
+{
+public:
+    /** 
+     * Check if a given string is a simple decimal number (e.g. 12.345). We 
+     * don't do any elaborate parsing here; we only check for the simplest 
+     * case of decimal number format. 
+     *
+     * @param rStr string to parse
+     * @param dsep decimal separator
+     * @param gsep group separator (aka thousands separator)
+     * @param rVal value of successfully parsed number
+     * 
+     * @return true if the string is a valid number, false otherwise.
+     */
+    static bool parseSimpleNumber(
+        const ::rtl::OUString& rStr, sal_Unicode dsep, sal_Unicode gsep, double& rVal);
+};
+
+
+#endif
diff --git sc/inc/table.hxx sc/inc/table.hxx
index a088fe5..5c099c1 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -256,7 +256,8 @@ public:
 	void		PutCell( SCCOL nCol, SCROW nRow, ScBaseCell* pCell );
 	void		PutCell(SCCOL nCol, SCROW nRow, ULONG nFormatIndex, ScBaseCell* pCell);
 				//	TRUE = Zahlformat gesetzt
-	BOOL		SetString( SCCOL nCol, SCROW nRow, SCTAB nTab, const String& rString, SvNumberFormatter* pFormatter = NULL );
+	BOOL		SetString( SCCOL nCol, SCROW nRow, SCTAB nTab, const String& rString, 
+                           SvNumberFormatter* pFormatter = NULL, bool bDetectNumberFormat = true );
 	void		SetValue( SCCOL nCol, SCROW nRow, const double& rVal );
 	void 		SetError( SCCOL nCol, SCROW nRow, USHORT nError);
 
diff --git sc/source/core/data/column3.cxx sc/source/core/data/column3.cxx
index a751418..40f6370 100644
--- sc/source/core/data/column3.cxx
+++ sc/source/core/data/column3.cxx
@@ -54,6 +54,13 @@
 #include "markdata.hxx"
 #include "detfunc.hxx"			// fuer Notizen bei DeleteRange
 #include "postit.hxx"
+#include "stringutil.hxx"
+
+#include <com/sun/star/i18n/LocaleDataItem.hpp>
+
+using ::com::sun::star::i18n::LocaleDataItem;
+using ::rtl::OUString;
+using ::rtl::OUStringBuffer;
 
 // Err527 Workaround
 extern const ScFormulaCell* pLastFormulaTreeTop;	// in cellform.cxx
@@ -1219,7 +1226,7 @@ void ScColumn::StartListeningInArea( SCROW nRow1, SCROW nRow2 )
 //	TRUE = Zahlformat gesetzt
 BOOL ScColumn::SetString( SCROW nRow, SCTAB nTabP, const String& rString,
                           formula::FormulaGrammar::AddressConvention eConv,
-                          SvNumberFormatter* pFormatter )
+                          SvNumberFormatter* pFormatter, bool bDetectNumberFormat )
 {
 	BOOL bNumFmtSet = FALSE;
 	if (VALIDROW(nRow))
@@ -1299,48 +1306,80 @@ BOOL ScColumn::SetString( SCROW nRow, SCTAB nTabP, const String& rString,
 					if ( !bIsText )
 						nIndex = nOldIndex = pFormatter->GetStandardIndex();
 				}
-				if ( !bIsText &&
-						pFormatter->IsNumberFormat(rString, nIndex, nVal) )
-				{												// Zahl
-					pNewCell = new ScValueCell( nVal );
-					if ( nIndex != nOldIndex)
-					{
-                        // #i22345# New behavior: Apply the detected number format only if
-                        // the old one was the default number, date, time or boolean format.
-                        // Exception: If the new format is boolean, always apply it.
 
-                        BOOL bOverwrite = FALSE;
-                        const SvNumberformat* pOldFormat = pFormatter->GetEntry( nOldIndex );
-                        if ( pOldFormat )
+                do
+                {
+                    if (bIsText)
+                        break;
+
+                    if (bDetectNumberFormat)
+                    {
+                        if (!pFormatter->IsNumberFormat(rString, nIndex, nVal))
+                            break;
+
+                        pNewCell = new ScValueCell( nVal );
+                        if ( nIndex != nOldIndex)
                         {
-                            short nOldType = pOldFormat->GetType() & ~NUMBERFORMAT_DEFINED;
-                            if ( nOldType == NUMBERFORMAT_NUMBER || nOldType == NUMBERFORMAT_DATE ||
-                                 nOldType == NUMBERFORMAT_TIME || nOldType == NUMBERFORMAT_LOGICAL )
+                            // #i22345# New behavior: Apply the detected number format only if
+                            // the old one was the default number, date, time or boolean format.
+                            // Exception: If the new format is boolean, always apply it.
+
+                            BOOL bOverwrite = FALSE;
+                            const SvNumberformat* pOldFormat = pFormatter->GetEntry( nOldIndex );
+                            if ( pOldFormat )
                             {
-                                if ( nOldIndex == pFormatter->GetStandardFormat(
-                                                    nOldType, pOldFormat->GetLanguage() ) )
+                                short nOldType = pOldFormat->GetType() & ~NUMBERFORMAT_DEFINED;
+                                if ( nOldType == NUMBERFORMAT_NUMBER || nOldType == NUMBERFORMAT_DATE ||
+                                     nOldType == NUMBERFORMAT_TIME || nOldType == NUMBERFORMAT_LOGICAL )
                                 {
-                                    bOverwrite = TRUE;      // default of these types can be overwritten
+                                    if ( nOldIndex == pFormatter->GetStandardFormat(
+                                                        nOldType, pOldFormat->GetLanguage() ) )
+                                    {
+                                        bOverwrite = TRUE;      // default of these types can be overwritten
+                                    }
                                 }
                             }
-                        }
-                        if ( !bOverwrite && pFormatter->GetType( nIndex ) == NUMBERFORMAT_LOGICAL )
-                        {
-                            bOverwrite = TRUE;              // overwrite anything if boolean was detected
-                        }
+                            if ( !bOverwrite && pFormatter->GetType( nIndex ) == NUMBERFORMAT_LOGICAL )
+                            {
+                                bOverwrite = TRUE;              // overwrite anything if boolean was detected
+                            }
 
-                        if ( bOverwrite )
-                        {
-                            ApplyAttr( nRow, SfxUInt32Item( ATTR_VALUE_FORMAT,
-                                (UINT32) nIndex) );
-                            bNumFmtSet = TRUE;
+                            if ( bOverwrite )
+                            {
+                                ApplyAttr( nRow, SfxUInt32Item( ATTR_VALUE_FORMAT,
+                                    (UINT32) nIndex) );
+                                bNumFmtSet = TRUE;
+                            }
                         }
-					}
-				}
-				else											// Text
-					pNewCell = new ScStringCell( rString );
-			}
-		}
+                    }
+                    else
+                    {
+                        // Only check if the string is a regular number.
+                        const LocaleDataWrapper* pLocale = pFormatter->GetLocaleData();
+                        if (!pLocale)
+                            break;
+                        
+                        LocaleDataItem aLocaleItem = pLocale->getLocaleItem();
+                        const OUString& rDecSep = aLocaleItem.decimalSeparator;
+                        const OUString& rGroupSep = aLocaleItem.thousandSeparator;
+                        if (rDecSep.getLength() != 1 || rGroupSep.getLength() != 1)
+                            break;
+
+                        sal_Unicode dsep = rDecSep.getStr()[0];
+                        sal_Unicode gsep = rGroupSep.getStr()[0];
+
+                        if (!ScStringUtil::parseSimpleNumber(rString, dsep, gsep, nVal))
+                            break;
+
+                        pNewCell = new ScValueCell(nVal);
+                    }
+                }
+                while (false);
+
+                if (!pNewCell)
+                    pNewCell = new ScStringCell(rString);
+            }
+        }
 
 		if ( bIsLoading && (!nCount || nRow > pItems[nCount-1].nRow) )
 		{	// Search einsparen und ohne Umweg ueber Insert, Listener aufbauen
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 676883e..a3b7e49 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -2451,10 +2451,11 @@ void ScDocument::PutCell( const ScAddress& rPos, ScBaseCell* pCell, BOOL bForceT
 }
 
 
-BOOL ScDocument::SetString( SCCOL nCol, SCROW nRow, SCTAB nTab, const String& rString, SvNumberFormatter* pFormatter )
+BOOL ScDocument::SetString( SCCOL nCol, SCROW nRow, SCTAB nTab, const String& rString, 
+                            SvNumberFormatter* pFormatter, bool bDetectNumberFormat )
 {
 	if ( ValidTab(nTab) && pTab[nTab] )
-		return pTab[nTab]->SetString( nCol, nRow, nTab, rString, pFormatter );
+		return pTab[nTab]->SetString( nCol, nRow, nTab, rString, pFormatter, bDetectNumberFormat );
 	else
 		return FALSE;
 }
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index 768eb27..da392bc 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -842,10 +842,12 @@ void ScTable::PutCell( const ScAddress& rPos, ULONG nFormatIndex, ScBaseCell* pC
 }
 
 
-BOOL ScTable::SetString( SCCOL nCol, SCROW nRow, SCTAB nTabP, const String& rString, SvNumberFormatter* pFormatter )
+BOOL ScTable::SetString( SCCOL nCol, SCROW nRow, SCTAB nTabP, const String& rString, 
+                         SvNumberFormatter* pFormatter, bool bDetectNumberFormat )
 {
 	if (ValidColRow(nCol,nRow))
-        return aCol[nCol].SetString( nRow, nTabP, rString, pDocument->GetAddressConvention(), pFormatter );
+        return aCol[nCol].SetString( 
+            nRow, nTabP, rString, pDocument->GetAddressConvention(), pFormatter, bDetectNumberFormat );
 	else
 		return FALSE;
 }
diff --git sc/source/core/tool/makefile.mk sc/source/core/tool/makefile.mk
index 1bf94ea..b54c041 100644
--- sc/source/core/tool/makefile.mk
+++ sc/source/core/tool/makefile.mk
@@ -107,6 +107,7 @@ SLOFILES =  \
 		$(SLO)$/refupdat.obj \
 		$(SLO)$/scmatrix.obj \
 		$(SLO)$/sctictac.obj \
+		$(SLO)$/stringutil.obj \
 		$(SLO)$/subtotal.obj \
 		$(SLO)$/token.obj \
 		$(SLO)$/unitconv.obj \
@@ -130,6 +131,7 @@ EXCEPTIONSFILES= \
 		$(SLO)$/lookupcache.obj \
         $(SLO)$/prnsave.obj \
 		$(SLO)$/reftokenhelper.obj \
+		$(SLO)$/stringutil.obj \
 		$(SLO)$/token.obj
 
 # [kh] POWERPC compiler problem
diff --git sc/source/core/tool/stringutil.cxx sc/source/core/tool/stringutil.cxx
new file mode 100644
index 0000000..eaf756e
--- /dev/null
+++ sc/source/core/tool/stringutil.cxx
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: table.hxx,v $
+ * $Revision: 1.35 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+// System - Includes -----------------------------------------------------
+
+#include "stringutil.hxx"
+#include "rtl/ustrbuf.hxx"
+
+using ::rtl::OUString;
+using ::rtl::OUStringBuffer;
+
+bool ScStringUtil::parseSimpleNumber(
+    const OUString& rStr, sal_Unicode dsep, sal_Unicode gsep, double& rVal)
+{
+    OUStringBuffer aBuf;
+    sal_Int32 n = rStr.getLength();
+    const sal_Unicode* p = rStr.getStr();
+    sal_Int32 nPosDSep = -1, nPosGSep = -1;
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        sal_Unicode c = p[i];
+        if (sal_Unicode('0') <= c && c <= sal_Unicode('9'))
+        {
+            // this is a digit.
+            aBuf.append(c);
+        }
+        else if (c == dsep)
+        {
+            // this is a decimal separator.
+
+            if (nPosDSep >= 0)
+                // a second decimal separator -> not a valid number.
+                return false;
+            if (nPosGSep >= 0 && i - nPosGSep != 4)
+                // the number has a group separator and the decimal sep is not
+                // positioned correctly.
+                return false;
+
+            nPosDSep = i;
+            aBuf.append(c);
+        }
+        else if (c == gsep)
+        {
+            // this is a group (thousand) separator.
+            if (i == 0)
+                return false;
+
+            if (nPosGSep >= 0 && i - nPosGSep != 4)
+            {    
+                // this group separator is not positioned correctly relative
+                // to the last group separator.
+                return false;
+            }
+
+            nPosGSep = i;
+        }
+        else if (c == sal_Unicode('-') || c == sal_Unicode('+'))
+        {
+            // A sign must be the first character if it's given.
+            if (i == 0)
+                aBuf.append(c);
+            else
+                return false;
+        }
+        else
+            return false;
+    }
+
+    rVal = aBuf.makeStringAndClear().toDouble();
+    return true;
+}
diff --git sc/source/filter/html/htmlimp.cxx sc/source/filter/html/htmlimp.cxx
index 3f982b8..8fbd9aa 100644
--- sc/source/filter/html/htmlimp.cxx
+++ sc/source/filter/html/htmlimp.cxx
@@ -63,13 +63,14 @@
 //------------------------------------------------------------------------
 
 FltError ScFormatFilterPluginImpl::ScImportHTML( SvStream &rStream, const String& rBaseURL, ScDocument *pDoc,
-		ScRange& rRange, double nOutputFactor, BOOL bCalcWidthHeight, SvNumberFormatter* pFormatter )
+		ScRange& rRange, double nOutputFactor, BOOL bCalcWidthHeight, SvNumberFormatter* pFormatter,
+        bool bConvertDate )
 {
     ScHTMLImport aImp( pDoc, rBaseURL, rRange, bCalcWidthHeight );
     FltError nErr = (FltError) aImp.Read( rStream, rBaseURL );
 	ScRange aR = aImp.GetRange();
 	rRange.aEnd = aR.aEnd;
-	aImp.WriteToDocument( TRUE, nOutputFactor, pFormatter );
+	aImp.WriteToDocument( TRUE, nOutputFactor, pFormatter, bConvertDate );
 	return nErr;
 }
 
@@ -137,9 +138,10 @@ void ScHTMLImport::InsertRangeName( ScDocument* pDoc, const String& rName, const
 		delete pRangeData;
 }
 
-void ScHTMLImport::WriteToDocument( BOOL bSizeColsRows, double nOutputFactor, SvNumberFormatter* pFormatter )
+void ScHTMLImport::WriteToDocument( 
+    BOOL bSizeColsRows, double nOutputFactor, SvNumberFormatter* pFormatter, bool bConvertDate )
 {
-	ScEEImport::WriteToDocument( bSizeColsRows, nOutputFactor, pFormatter );
+	ScEEImport::WriteToDocument( bSizeColsRows, nOutputFactor, pFormatter, bConvertDate );
 
     const ScHTMLParser* pParser = GetParser();
     const ScHTMLTable* pGlobTable = pParser->GetGlobalTable();
diff --git sc/source/filter/inc/eeimport.hxx sc/source/filter/inc/eeimport.hxx
index 9be2583..32d7d0a 100644
--- sc/source/filter/inc/eeimport.hxx
+++ sc/source/filter/inc/eeimport.hxx
@@ -64,7 +64,8 @@ public:
     virtual ScRange  GetRange() { return maRange; }
     virtual void     WriteToDocument( BOOL bSizeColsRows = FALSE,
                                       double nOutputFactor = 1.0,
-                                      SvNumberFormatter* pFormatter = NULL );
+                                      SvNumberFormatter* pFormatter = NULL,
+                                      bool bConvertDate = true );
 };
 
 #endif
diff --git sc/source/filter/inc/htmlimp.hxx sc/source/filter/inc/htmlimp.hxx
index 387edee..aafe91b 100644
--- sc/source/filter/inc/htmlimp.hxx
+++ sc/source/filter/inc/htmlimp.hxx
@@ -45,7 +45,8 @@ public:
     virtual ~ScHTMLImport();
     const ScHTMLParser* GetParser() const { return (ScHTMLParser*)mpParser; }
 
-	virtual void		WriteToDocument( BOOL bSizeColsRows = FALSE, double nOutputFactor = 1.0, SvNumberFormatter* pFormatter = NULL );
+	virtual void		WriteToDocument( BOOL bSizeColsRows = FALSE, double nOutputFactor = 1.0, 
+                                         SvNumberFormatter* pFormatter = NULL, bool bConvertDate = true );
 
 	static String		GetHTMLRangeNameList( ScDocument* pDoc, const String& rOrigName );
 };
diff --git sc/source/filter/rtf/eeimpars.cxx sc/source/filter/rtf/eeimpars.cxx
index df5a98b..e4b28a7 100644
--- sc/source/filter/rtf/eeimpars.cxx
+++ sc/source/filter/rtf/eeimpars.cxx
@@ -129,7 +129,7 @@ ULONG ScEEImport::Read( SvStream& rStream, const String& rBaseURL )
 }
 
 
-void ScEEImport::WriteToDocument( BOOL bSizeColsRows, double nOutputFactor, SvNumberFormatter* pFormatter )
+void ScEEImport::WriteToDocument( BOOL bSizeColsRows, double nOutputFactor, SvNumberFormatter* pFormatter, bool bConvertDate )
 {
     ScProgress* pProgress = new ScProgress( mpDoc->GetDocumentShell(),
         ScGlobal::GetRscString( STR_LOAD_DOC ), mpParser->Count() );
@@ -381,7 +381,7 @@ void ScEEImport::WriteToDocument( BOOL bSizeColsRows, double nOutputFactor, SvNu
                     if (bNumbersEnglishUS && !bEnUsRecognized)
                         mpDoc->PutCell( nCol, nRow, nTab, new ScStringCell( aStr));
                     else
-                        mpDoc->SetString( nCol, nRow, nTab, aStr, pFormatter );
+                        mpDoc->SetString( nCol, nRow, nTab, aStr, pFormatter, bConvertDate );
 				}
 			}
 			else
diff --git sc/source/ui/attrdlg/scdlgfact.cxx sc/source/ui/attrdlg/scdlgfact.cxx
index ac23eb4..f42e8fc 100644
--- sc/source/ui/attrdlg/scdlgfact.cxx
+++ sc/source/ui/attrdlg/scdlgfact.cxx
@@ -639,6 +639,12 @@ LanguageType AbstractScLangChooserDlg_Impl::GetLanguageType() const
 {
     return pDlg->getLanguageType();
 }
+
+bool AbstractScLangChooserDlg_Impl::IsDateConversionSet() const
+{
+    return pDlg->isDateConversionSet();
+}
+
 //add for AbstractScLangChooserDlg_Impl end
 
 // =========================Factories  for createdialog ===================
diff --git sc/source/ui/attrdlg/scdlgfact.hxx sc/source/ui/attrdlg/scdlgfact.hxx
index 4468686..07255ff 100644
--- sc/source/ui/attrdlg/scdlgfact.hxx
+++ sc/source/ui/attrdlg/scdlgfact.hxx
@@ -361,6 +361,7 @@ class AbstractScLangChooserDlg_Impl : public AbstractScLangChooserDlg
 {
     DECL_ABSTDLG_BASE( AbstractScLangChooserDlg_Impl, ScLangChooserDlg)
     virtual LanguageType GetLanguageType() const;
+    virtual bool IsDateConversionSet() const;
 };
 
 //add for ScAttrDlg , ScHFEditDlg, ScStyleDlg, ScSubTotalDlg, ScCharDlg, ScParagraphDlg, ScValidationDlg, ScSortDlg
diff --git sc/source/ui/dbgui/langchooser.cxx sc/source/ui/dbgui/langchooser.cxx
index 59a7259..d5fd72b 100644
--- sc/source/ui/dbgui/langchooser.cxx
+++ sc/source/ui/dbgui/langchooser.cxx
@@ -52,7 +52,9 @@ ScLangChooserDlg::ScLangChooserDlg(Window* pParent) :
     maFlChooseLang(this, ScResId(FL_CHOOSE_LANG)),
     maRbAutomatic(this, ScResId(RB_AUTOMATIC)), 
     maRbCustom(this, ScResId(RB_CUSTOM)),
-    maLbCustomLang(this, ScResId(LB_CUSTOM_LANG))
+    maLbCustomLang(this, ScResId(LB_CUSTOM_LANG)),
+    maFlOption(this, ScResId(FL_OPTION)),
+    maBtnConvertDate(this, ScResId(BTN_CONVERT_DATE))
 {
     init();
 }
@@ -74,6 +76,11 @@ LanguageType ScLangChooserDlg::getLanguageType() const
     return maLbCustomLang.GetSelectLanguage();
 }
 
+bool ScLangChooserDlg::isDateConversionSet() const
+{
+    return maBtnConvertDate.IsChecked();
+}
+
 void ScLangChooserDlg::init()
 {
     Link aLink = LINK( this, ScLangChooserDlg, OKHdl );
diff --git sc/source/ui/dbgui/langchooser.src sc/source/ui/dbgui/langchooser.src
index ace6782..1e121de 100644
--- sc/source/ui/dbgui/langchooser.src
+++ sc/source/ui/dbgui/langchooser.src
@@ -33,7 +33,7 @@
 ModalDialog RID_SCDLG_LANG_CHOOSER
 {
     Text [ en-US ] = "Select Language" ;
-    Size = MAP_APPFONT ( 190 , 70 ) ;
+    Size = MAP_APPFONT ( 190 , 101 ) ;
     Moveable = TRUE ;
     Closeable = TRUE ;
     OutputSize = TRUE ;
@@ -91,5 +91,22 @@ ModalDialog RID_SCDLG_LANG_CHOOSER
         DropDown = TRUE ;
         Sort = TRUE ;
     };
+
+    FixedLine FL_OPTION
+    {
+	Pos = MAP_APPFONT( 6, 70 );
+	Size = MAP_APPFONT( 125, 14 );
+
+	Text [ en-US ] = "Options" ;
+    };
+
+    CheckBox BTN_CONVERT_DATE
+    {
+    	Pos = MAP_APPFONT( 12, 86 );
+	Size = MAP_APPFONT( 125, 10 );
+	TabStop = TRUE ;
+
+	Text [ en-US ] = "Detect special numbers (such as dates)." ;
+    };
 };
 
diff --git sc/source/ui/docshell/docsh.cxx sc/source/ui/docshell/docsh.cxx
index 9caaf5f..695dc81 100644
--- sc/source/ui/docshell/docsh.cxx
+++ sc/source/ui/docshell/docsh.cxx
@@ -137,6 +137,8 @@ using namespace com::sun::star;
 using namespace com::sun::star::document::VbaEventId;
 
 using namespace com::sun::star;
+using ::rtl::OUString;
+using ::rtl::OUStringBuffer;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -898,6 +900,34 @@ BOOL __EXPORT ScDocShell::LoadFrom( SfxMedium& rMedium )
 	return bRet;
 }
 
+static void lcl_parseHtmlFilterOption(const OUString& rOption, LanguageType& rLang, bool& rDateConvert)
+{
+    OUStringBuffer aBuf;
+    OUString aTokens[2];
+    sal_Int32 n = rOption.getLength();
+    const sal_Unicode* p = rOption.getStr();
+    sal_Int32 nTokenId = 0;
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        const sal_Unicode c = p[i];
+        if (c == sal_Unicode(' '))
+        {
+            if (aBuf.getLength())
+                aTokens[nTokenId++] = aBuf.makeStringAndClear();
+        }
+        else
+            aBuf.append(c);
+
+        if (nTokenId >= 2)
+            break;
+    }
+
+    if (aBuf.getLength())
+        aTokens[nTokenId] = aBuf.makeStringAndClear();
+
+    rLang = static_cast<LanguageType>(aTokens[0].toInt32());
+    rDateConvert = static_cast<bool>(aTokens[1].toInt32());
+}
 
 BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 {
@@ -1273,13 +1303,14 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 				if (pInStream)
 				{
                     LanguageType eLang = LANGUAGE_SYSTEM;
+                    bool bDateConvert = false;
                     SfxItemSet*	 pSet = rMedium.GetItemSet();
                     const SfxPoolItem* pItem;
                     if ( pSet && SFX_ITEM_SET ==
                          pSet->GetItemState( SID_FILE_FILTEROPTIONS, TRUE, &pItem ) )
                     {
                         String aFilterOption = (static_cast<const SfxStringItem*>(pItem))->GetValue();
-                        eLang = static_cast<LanguageType>(aFilterOption.ToInt32());
+                        lcl_parseHtmlFilterOption(aFilterOption, eLang, bDateConvert);
                     }
 
 					pInStream->Seek( 0 );
@@ -1288,7 +1319,7 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 					CalcOutputFactor();
                     SvNumberFormatter aNumFormatter(aDocument.GetServiceManager(), eLang);
                     eError = ScFormatFilter::Get().ScImportHTML( *pInStream, rMedium.GetBaseURL(), &aDocument, aRange,
-											GetOutputFactor(), !bWebQuery, &aNumFormatter );
+											GetOutputFactor(), !bWebQuery, &aNumFormatter, bDateConvert );
 					if (eError != eERR_OK)
 					{
 						if (!GetError())
diff --git sc/source/ui/inc/langchooser.hrc sc/source/ui/inc/langchooser.hrc
index fb0be37..eb981c1 100644
--- sc/source/ui/inc/langchooser.hrc
+++ sc/source/ui/inc/langchooser.hrc
@@ -38,4 +38,5 @@
 #define RB_AUTOMATIC             5
 #define RB_CUSTOM                6
 #define LB_CUSTOM_LANG           7
-
+#define FL_OPTION                8
+#define BTN_CONVERT_DATE         9
diff --git sc/source/ui/inc/langchooser.hxx sc/source/ui/inc/langchooser.hxx
index 7c63973..7106ab2 100644
--- sc/source/ui/inc/langchooser.hxx
+++ sc/source/ui/inc/langchooser.hxx
@@ -46,6 +46,7 @@ public:
     virtual short Execute();
 
     LanguageType getLanguageType() const;
+    bool isDateConversionSet() const;
 
 private:
     void init();
@@ -62,7 +63,9 @@ private:
 
     SvxLanguageBox  maLbCustomLang;
 
-    String          maString;
+    FixedLine       maFlOption;
+
+    CheckBox        maBtnConvertDate;
 
     DECL_LINK( OKHdl, OKButton* );
 
diff --git sc/source/ui/unoobj/filtuno.cxx sc/source/ui/unoobj/filtuno.cxx
index 99c1045..b119cda 100644
--- sc/source/ui/unoobj/filtuno.cxx
+++ sc/source/ui/unoobj/filtuno.cxx
@@ -56,6 +56,7 @@
 #include <memory>
 
 using namespace ::com::sun::star;
+using ::rtl::OUStringBuffer;
 
 //------------------------------------------------------------------------
 
@@ -193,7 +194,12 @@ sal_Int16 SAL_CALL ScFilterOptionsObj::execute() throw(uno::RuntimeException)
         if (pDlg->Execute() == RET_OK)
         {
             LanguageType eLang = pDlg->GetLanguageType();
-            aFilterOptions = String::CreateFromInt32(static_cast<sal_Int32>(eLang));
+            OUStringBuffer aBuf;
+
+            aBuf.append(String::CreateFromInt32(static_cast<sal_Int32>(eLang)));
+            aBuf.append(sal_Unicode(' '));
+            aBuf.append(pDlg->IsDateConversionSet() ? sal_Unicode('1') : sal_Unicode('0'));
+            aFilterOptions = aBuf.makeStringAndClear();
             nRet = ui::dialogs::ExecutableDialogResults::OK;
         }
     }
