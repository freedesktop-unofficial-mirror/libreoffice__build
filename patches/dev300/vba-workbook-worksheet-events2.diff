--- sc/source/ui/inc/docsh.hxx.bak	2008-04-07 16:25:30.000000000 +0800
+++ sc/source/ui/inc/docsh.hxx	2008-04-07 16:27:16.000000000 +0800
@@ -200,6 +200,7 @@ public:
     using SfxShell::Activate;           // with BOOL bMDI
     using SfxShell::Deactivate;         // with BOOL bMDI
     using SfxObjectShell::Print;        // print styles
+    virtual sal_Bool            processVbaEvents( USHORT nStatus, USHORT nSlotId );
 
 	virtual void    Activate();
 	virtual void    Deactivate();
--- sc/source/ui/docshell/docsh.cxx.bak	2008-04-07 16:25:30.000000000 +0800
+++ sc/source/ui/docshell/docsh.cxx	2008-04-10 15:19:30.000000000 +0800
@@ -32,7 +32,8 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
+#define BEFORE 0
+#define AFTER 1
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 // System - Includes -----------------------------------------------------
@@ -146,22 +147,25 @@
 #include "docsh.hxx"
 #include "docshimp.hxx"
 
+#include "uiitems.hxx"
+
 #ifndef _RTL_LOGFILE_HXX_
 #include <rtl/logfile.hxx>
 #endif
 
 #include <comphelper/processfactory.hxx>
 
-#include <basic/basmgr.hxx>
-#include <basic/sbmod.hxx>
-#include <basic/sbmeth.hxx>
-#include <basic/sbx.hxx>
-#include "scextopt.hxx"
 using namespace com::sun::star;
 
 // STATIC DATA -----------------------------------------------------------
 
 //	Stream-Namen im Storage
+bool processDocMacro( ScDocShell* pShell );
+bool processDocBeforeCloseMacro( ScDocShell* pShell );
+bool processDocBeforeSaveMacro( ScDocShell* pShell, bool bSaveAsUI );
+bool processDocBeforePrintMacro( ScDocShell* pShell );
+void processScTablesHint( ScDocShell* pShell, const ScTablesHint& rHint );
+void processSfxEventHint( ScDocShell* pShell, const SfxEventHint& rHint );
 
 const sal_Char __FAR_DATA ScDocShell::pStarCalcDoc[] = STRING_SCSTREAM;		// "StarCalcDocument"
 const sal_Char __FAR_DATA ScDocShell::pStyleName[] = "SfxStyleSheets";
@@ -199,205 +203,6 @@ static const sal_Char __FAR_DATA pFilter
 #define ScDocShell
 #include "scslots.hxx"
 
-const static String sLibrary( RTL_CONSTASCII_USTRINGPARAM("Standard"));
-const static String sModule( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook"));
-
-const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
-const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.");
-const static rtl::OUString sUrlPart2 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
-
- rtl::OUString getWorkbookModuleName( ScDocShell* pShell )
-{
-	rtl::OUString sCodeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
-	if ( pShell )
-	{
-		if ( ScExtDocOptions* pExtDocOpts = pShell->GetDocument()->GetExtDocOptions() )
-		{
-			if ( pExtDocOpts->GetDocSettings().maGlobCodeName.Len() > 0 ) 
-				sCodeName = pExtDocOpts->GetDocSettings().maGlobCodeName;
-		}
-	}
-	return sCodeName;
-}	
-// Treat the args as possible inouts ( convertion at bottom of method )
-bool executeWorkBookMacro( ScDocShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet )
-{
-	// until ObjectModules ( and persisting of codenames ) is supported, if this is a
-	// document saved from XL then we won't be able to determine the codename for the Workbook
-	// Module, so... we have no choice but to search all modules for the moment, thus the macro
-	// passed in should be the fully specified name. 	
-	//rtl::OUString sCodeName = getWorkbookModuleName( pShell );
-	//rtl::OUString sUrl = sUrlPart1.concat( sCodeName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sMacroName ).concat( sUrlPart2 );
-	rtl::OUString sUrl = sUrlPart0.concat( sMacroName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sUrlPart2 ) ;
-	uno::Sequence< sal_Int16 > aOutArgsIndex;
-	uno::Sequence< uno::Any > aOutArgs;
-	ErrCode nErr = pShell->CallXScript( sUrl,  aArgs, aRet,
-			aOutArgsIndex, aOutArgs, false );
-
-	// Script Executed?
-	if ( nErr != ERRCODE_NONE )
-		return false;
-
-	sal_Int32 nLen = aOutArgs.getLength();
-	// convert any out params to seem like they were inouts
-	if ( nLen )
-	{
-		for ( sal_Int32 index=0; index < nLen; ++index )
-		{
-			sal_Int32 nOutIndex = aOutArgsIndex[ index ];
-			aArgs[ nOutIndex ] = aOutArgs[ nOutIndex ];
-		}
-
-	}
-	return true;
-}
-String docMacroExists( ScDocShell* pShell, 
-const String& sMod, const String& sMacro )
-{
-	String sFullName;	
-	// would use the script provider to see if the macro exists but
-	// called at this stage tdoc content handler stuff is not set up
-	// so it fails
-
-	BasicManager* pBasicMgr = pShell-> GetBasicManager();
-	if ( pBasicMgr )
-	{
-		StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
-		if ( !pBasic )
-		{
-			USHORT nId = pBasicMgr->GetLibId( sLibrary );
-			pBasicMgr->LoadLib( nId );
-			pBasic = pBasicMgr->GetLib( sLibrary );
-		}
-		if ( pBasic )
-		{
-			if ( sMod.Len() ) // we wish to find the macro is a specific module
-			{
-				SbModule* pModule = pBasic->FindModule( sMod );
-				if ( pModule )
-				{
-					SbxArray* pMethods = pModule->GetMethods();
-					if ( pMethods )
-					{
-						SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
-						if ( pMethod )
-						{
-							sFullName = sMacro;
-							sFullName.Insert( '.', 0 ).Insert( sMod, 0 ).Insert( '.', 0 ).Insert( sLibrary, 0 );
-						}
-					}
-				}
-			}
-			else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
-			{
-					if( SbModule* pModule = pMethod->GetModule() )
-					{
-						sFullName = sMacro;
-						sFullName.Insert( '.', 0 ).Insert( pModule->GetName(), 0).Insert( '.', 0 ).Insert( sLibrary, 0 );
-					}
-			}		
-				
-		}
-	}
-	return sFullName;
-}
-
-bool processDocBeforeCloseMacro( ScDocShell* pShell )
-{
-	
-	uno::Any aRet;
-	uno::Sequence< uno::Any > aArgs( 1 );
-	bool bCancel = sal_False;
-	aArgs[ 0 ] <<= bCancel;
-	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforeClose") );
-	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
-	if ( sFullClose.Len() > 0 )
-	{ 
-		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
-			return false;
-	}
-	aArgs[ 0 ] >>= bCancel;
-	return bCancel;
-}
-
-bool addOpenDocEvent( const uno::Reference< container::XNameReplace >& xEvts, const rtl::OUString& sOpenMacro )
-{
-	bool result = false;
-	const rtl::OUString sUrl = sUrlPart0.concat( sOpenMacro ).concat( sUrlPart2 );
-	const static rtl::OUString sEvtType( RTL_CONSTASCII_USTRINGPARAM("EventType") );
-	const static rtl::OUString sScript( RTL_CONSTASCII_USTRINGPARAM("Script") );
-	const static rtl::OUString sEvt( RTL_CONSTASCII_USTRINGPARAM("OnLoad") );
-	if ( xEvts.is() )
-	{
-		uno::Sequence< beans::PropertyValue > aEvents;
-		xEvts->getByName( sEvt ) >>= aEvents;
-		uno::Sequence< beans::PropertyValue > aOpenEvt( 2 );
-		aOpenEvt[ 0 ].Name = sEvtType;
-		aOpenEvt[ 0 ].Value = uno::makeAny(sScript);
-		aOpenEvt[ 1 ].Name = sScript;
-		aOpenEvt[ 1 ].Value = uno::makeAny(sUrl);
-		sal_Int32 nPos = aEvents.getLength();
-
-		sal_Int32 nNewSize = aEvents.getLength() + aOpenEvt.getLength();
-		if ( nNewSize > aEvents.getLength() )
-			aEvents.realloc( nNewSize );
-
-		for ( sal_Int32 nIndex = nPos, nCpyIndex = 0; nIndex<nNewSize; nIndex++, nCpyIndex++ )
-			aEvents[ nIndex ] = aOpenEvt[ nCpyIndex ];	
-			
-		uno::Any aParam = uno::makeAny( aEvents );
-
-		xEvts->replaceByName( sEvt, aParam ); 
-		result = true;
-	}
-	return result;
-}
-
-bool processDocOpenMacro( ScDocShell* pShell )
-{
-	bool result = false;
-	// no point adding a handler for unless it exists
-	// probably worth just doing this on import of xl document
-	
-		
-	// Urk due to async nature, re-enterency and other horrors of the load
-	// process, its seems the most sensible thing is to hook into the 
-	// document event broadcaster
-	const static rtl::OUString sOpenMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Open") );
-	const static rtl::OUString sAuto_OpenMacro( RTL_CONSTASCII_USTRINGPARAM("auto_open") );
-
-	uno::Reference< document::XEventsSupplier > xEvtSupplier( pShell->GetModel(), uno::UNO_QUERY );
-	String sNull;
-
-	if ( xEvtSupplier.is() )
-	{
-		uno::Reference< container::XNameReplace > xEvts( xEvtSupplier->getEvents(), uno::UNO_QUERY );
-		// until ObjectModules ( and persisting of codename )  are supported if this is a
-		// document saved from XL then we won't be able to determine the codename for the Workbook
-		// Module, so... we have no choice but to search all modules for the moment 	
-		//rtl::OUString workbookModule = getWorkbookModuleName( pShell );
-		rtl::OUString workbookModule; // no name means all modules will be searched
-		String sFullOpen = docMacroExists( pShell, workbookModule, sOpenMacro );
-		if ( sFullOpen.Len() > 0 )
-		{
-				if ( !addOpenDocEvent( xEvts, sFullOpen ) )
-					return false;
-		}
-	// deep sigh, you can only specify one event binding not multiple ones, thats crap
-/*
-		String sFullAuto = docMacroExists( pShell, workbookModule, sAuto_OpenMacro );
-		if ( sFullAuto.Len() > 0 )
-		{
-				if ( !addOpenDocEvent( xEvts, sFullAuto ) )
-					return false;
-		}
-*/
-		result = true;
-
-	}
-	return result;
-}
-
 
 SFX_IMPL_INTERFACE(ScDocShell,SfxObjectShell, ScResId(SCSTR_DOCSHELL))
 {
@@ -940,12 +745,41 @@ BOOL __EXPORT ScDocShell::Load( SfxMediu
 	bIsEmpty = FALSE;
 
 	// Handler for open workbook event
-	processDocOpenMacro( this );
+	processDocMacro( this );
 
 	FinishedLoading( SFX_LOADED_MAINDOCUMENT | SFX_LOADED_IMAGES );
 	return bRet;
 }
 
+// For Vba Event
+// status, 0 before, 1 done...
+sal_Bool __EXPORT ScDocShell::processVbaEvents( USHORT nStatus, USHORT nSlotId )
+{
+    USHORT nId = nSlotId;
+    switch( nId )
+    {
+        case SID_SAVEDOC:
+        {
+            if( nStatus == BEFORE )
+                return processDocBeforeSaveMacro( this, false );
+            break;
+        }
+        case SID_SAVEASDOC:
+        {
+            if( nStatus == BEFORE )
+                return processDocBeforeSaveMacro( this, true );
+            break;
+        }
+        case SID_PRINTDOC:
+        case SID_PRINTDOCDIRECT:
+        {
+            if( nStatus == BEFORE )
+                return processDocBeforePrintMacro( this );
+            break;
+        }
+    }
+    return sal_False;
+}
 
 void __EXPORT ScDocShell::Notify( SfxBroadcaster&, const SfxHint& rHint )
 {
@@ -981,6 +815,10 @@ void __EXPORT ScDocShell::Notify( SfxBro
 			pAutoStyleList = new ScAutoStyleList(this);
 		pAutoStyleList->AddInitial( aRange, aName1, nTimeout, aName2 );
 	}
+    else if (rHint.ISA(ScTablesHint) )
+    {
+        processScTablesHint( this, (ScTablesHint&)rHint );
+    }
     else if ( rHint.ISA( SfxEventHint ) )
     {
         ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
@@ -1152,6 +990,13 @@ void __EXPORT ScDocShell::Notify( SfxBro
                     }
                 }
                 break;
+            case SFX_EVENT_ACTIVATEDOC:
+            case SFX_EVENT_DEACTIVATEDOC:
+            case SFX_EVENT_CLOSEDOC :
+            case SFX_EVENT_CLOSEVIEW :
+            case SFX_EVENT_OPENDOC:
+                processSfxEventHint( this, (SfxEventHint&)rHint );
+                break;
             default:
                 {
                 }
@@ -1648,7 +1493,7 @@ BOOL __EXPORT ScDocShell::ConvertFrom( S
 	}
 
 	// Handler for open workbook event
-	processDocOpenMacro( this );
+    processDocMacro( this );
 
 	FinishedLoading( SFX_LOADED_MAINDOCUMENT | SFX_LOADED_IMAGES );
 
--- sc/source/ui/unoobj/viewuno.cxx.bak	2008-04-07 17:28:12.000000000 +0800
+++ sc/source/ui/unoobj/viewuno.cxx	2008-04-07 17:35:38.000000000 +0800
@@ -85,79 +85,9 @@
 #ifndef SC_ACCESSIBILITYHINTS_HXX
 #include "AccessibilityHints.hxx"
 #endif
-#include "scextopt.hxx"
-#include <comphelper/processfactory.hxx>
 using namespace com::sun::star;
-String docMacroExists( ScDocShell* pShell, 
-const String& sMod, const String& sMacro );
-bool executeWorkBookMacro( ScDocShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet );
 
-uno::Any createWorkSheet( ScDocShell* pShell, SCTAB nTab )
-{
-	uno::Any aRet;
-	try
-	{
-		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
-		uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
-		// Eventually we will be able to pull the Workbook/Worksheet objects
-		// directly from basic and register them as listeners
-
-		// create Workbook
-		uno::Sequence< uno::Any > aArgs(2);
-		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
-		aArgs[1] = uno::Any( pShell->GetModel() );
-		uno::Reference< uno::XInterface > xWorkbook( xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs, xCtx ), uno::UNO_QUERY );
-
-		// create WorkSheet
-		String sSheetName;
-		pShell->GetDocument()->GetName( nTab, sSheetName );
-		aArgs = uno::Sequence< uno::Any >(3);
-		aArgs[ 0 ] <<= xWorkbook;
-		aArgs[ 1 ] <<= pShell->GetModel();
-		aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
-		aRet <<= xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs, xCtx );
-	}
-	catch( uno::Exception& e )
-	{
-	}
-	return aRet;
-}
-
-uno::Any createRange( const uno::Any& aRange )
-{
-	uno::Any aRet;
-	try
-	{
-		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
-		uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
-		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
-		if (  xRanges.is() || xRange.is() )
-		{
-			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
-			uno::Sequence< uno::Any > aArgs(2);
-			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
-			if ( xRanges.is() )
-			{
-				aArgs[1] <<= xRanges;
-			}
-			else if ( xRange.is() )
-			{
-				aArgs[1] <<= xRange;
-			}
-			else
-			{
-				throw uno::RuntimeException(); // 
-			}
-			aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Range") ), aArgs, xCtx  );	
-		}
-	}
-	catch( uno::Exception& e ) 
-	{
-	}
-	return aRet;
-}
+sal_Bool processSelectionChangeMacro( ScDocShell* pShell, SCTAB nTab, const uno::Any& rRange );
 //------------------------------------------------------------------------
 
 //!	Clipping-Markierungen
@@ -1762,13 +1692,7 @@ void SAL_CALL ScTabViewObj::removeSelect
 		}
 	}
 }
-bool fireSelectionChangeScript( ScDocShell* pShell, const String& sMacro, uno::Sequence< uno::Any >& aArgs ) 
-{
-	if ( sMacro.Len() == 0 )
-		return false;
-	uno::Any aRet;
-    return executeWorkBookMacro( pShell, sMacro, aArgs, aRet );
-}
+
 void ScTabViewObj::SelectionChanged()
 {
 	ScTabViewShell* pViewSh = GetViewShell();
@@ -1777,28 +1701,7 @@ void ScTabViewObj::SelectionChanged()
 		ScViewData* pViewData = pViewSh->GetViewData();
 		if ( pViewData )
 		{
-			ScExtDocOptions* pExtOptions = pViewData->GetDocument()->GetExtDocOptions();
-			String sSheetModuleName;
-			pViewData->GetDocument()->GetName( pViewData->GetTabNo(), sSheetModuleName);
-			// Use code name if that exists
-			if ( pExtOptions )
-				sSheetModuleName = pExtOptions->GetCodeName( pViewData->GetTabNo() );
-			
-			String sSheetSelectionScript( RTL_CONSTASCII_USTRINGPARAM("Worksheet_SelectionChange") );
-			String sWorkBookSheetSelectionScript( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetSelectionChange") );
-			String sMacro = docMacroExists( pViewData->GetDocShell(), sSheetModuleName, sSheetSelectionScript );
-			uno::Any aRet;
-			uno::Sequence< uno::Any > aArgs(1);
-			uno::Any aRange = createRange( getSelection() );
-			aArgs[0] = aRange;
-			// Worksheet_SelectionChanged
-			fireSelectionChangeScript( pViewData->GetDocShell(), sMacro, aArgs );
-			aArgs = uno::Sequence< uno::Any >(2);
-			aArgs[0] = createWorkSheet( pViewData->GetDocShell(), pViewData->GetTabNo() );
-			aArgs[1] = aRange;
-			sMacro = docMacroExists( pViewData->GetDocShell(), String(), sWorkBookSheetSelectionScript );
-			// Workbook_SheetSelectionChanged
-			fireSelectionChangeScript( pViewData->GetDocShell(), sMacro, aArgs );
+            processSelectionChangeMacro( pViewData->GetDocShell(), pViewData->GetTabNo(), getSelection() );
 		}
 	}
 
--- sfx2/inc/sfx2/objsh.hxx.bak	2008-04-07 16:25:30.000000000 +0800
+++ sfx2/inc/sfx2/objsh.hxx	2008-04-07 16:27:16.000000000 +0800
@@ -315,6 +315,9 @@ public:
     sal_Bool                    Stamp_GetPrintCancelState() const;
 
     using SotObject::GetInterface;
+    // status, 0 before, 1 done...
+    virtual sal_Bool            processVbaEvents( USHORT nStatus, USHORT nSlotId )
+                                { (void)nSlotId; (void)nStatus; return sal_False; }
 
     // Document-Shell Iterator
 	static SfxObjectShell*		GetFirst( const TypeId* pType = 0,
--- sfx2/source/doc/objserv.cxx.orig	2008-04-03 16:06:37.000000000 +0800
+++ sfx2/source/doc/objserv.cxx	2008-04-07 16:27:16.000000000 +0800
@@ -33,6 +33,8 @@
  *
  ************************************************************************/
 
+#define BEFORE 0
+#define AFTER 1
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sfx2.hxx"
 
@@ -596,6 +598,14 @@ void SfxObjectShell::ExecFile_Impl(SfxRe
 		case SID_SAVEASDOC:
 		case SID_SAVEDOC:
 		{
+            if( nId == SID_SAVEDOC || nId == SID_SAVEASDOC )
+            {
+                if( processVbaEvents( BEFORE, nId ) )
+                {
+                    rReq.SetReturnValue( SfxBoolItem( 0, sal_True ) );
+                    return;
+                }
+            }
 			//!! detaillierte Auswertung eines Fehlercodes
 			SfxObjectShellRef xLock( this );
 
--- sfx2/source/view/viewprn.cxx.orig	2008-03-06 00:56:43.000000000 +0800
+++ sfx2/source/view/viewprn.cxx	2008-04-07 16:27:16.000000000 +0800
@@ -33,6 +33,7 @@
  *
  ************************************************************************/
 
+#define BEFORE 0
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sfx2.hxx"
 
@@ -426,6 +427,14 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 		case SID_SETUPPRINTER:
 	    case SID_PRINTER_NAME :
 		{
+            if( nId == SID_PRINTDOC )
+            {
+                if( GetObjectShell() && GetObjectShell()->processVbaEvents( BEFORE, nId ) )
+                {
+                    rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                    return;
+                }
+            }
 	        // quiet mode (AppEvent, API call)
 			SFX_REQUEST_ARG(rReq, pSilentItem, SfxBoolItem, SID_SILENT, FALSE);
 			bSilent = pSilentItem && pSilentItem->GetValue();
@@ -735,6 +744,11 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 	        if ( SID_PRINTDOCDIRECT == nId )
 	        {
 				SfxObjectShell* pDoc = GetObjectShell();
+                if( pDoc->processVbaEvents( BEFORE, nId ) )
+                {
+                    rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                    return;
+                }
 				bool bDetectHidden = ( !bSilent && pDoc );
 				if ( bDetectHidden && pDoc->QueryHiddenInformation( WhenPrinting, NULL ) != RET_YES )
 					return;
--- sc/source/ui/docshell/makefile.mk.bak	2008-04-07 17:10:11.000000000 +0800
+++ sc/source/ui/docshell/makefile.mk	2008-04-07 17:14:08.000000000 +0800
@@ -97,10 +97,12 @@ SLOFILES =  \
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
+        $(SLO)$/vbaevents.obj \
         $(SLO)$/editable.obj
 
 
 EXCEPTIONSFILES= \
+        $(SLO)$/vbaevents.obj \
         $(SLO)$/docsh.obj \
         $(SLO)$/docsh3.obj	\
         $(SLO)$/docsh4.obj \
@@ -134,6 +136,7 @@ LIB1OBJFILES =  \
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
+        $(SLO)$/vbaevents.obj \
         $(SLO)$/editable.obj
 
 # --- Tagets -------------------------------------------------------
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ sc/source/ui/docshell/vbaevents.cxx	2008-04-10 18:27:01.000000000 +0800
@@ -0,0 +1,750 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaevents.cxx,v $
+ *
+ *  $Revision: 11999 $
+ *
+ *  last change: $Author: noelpwer $ $Date: 2008-03-25 23:20:35 +0800 (二, 25  3月 2008) $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <cppuhelper/implbase1.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbx.hxx>
+#include <sfx2/evntconf.hxx>
+#include <sfx2/event.hxx>
+#include <sfx2/sfx.hrc>
+#include <toolkit/unohlp.hxx>
+
+#include <comphelper/processfactory.hxx>
+#ifndef _COM_SUN_STAR_SHEET_XSHEETCELLRANGECONTAINER_HPP_
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#endif
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#ifndef _COM_SUN_STAR_SHEET_XCELLRANGEREFERRER_HPP_
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#endif
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include <com/sun/star/awt/WindowEvent.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include "docsh.hxx"
+#include "uiitems.hxx"
+#include "scextopt.hxx"
+using namespace com::sun::star;
+
+const static String sLibrary( RTL_CONSTASCII_USTRINGPARAM("Standard"));
+const static String sModule( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook"));
+
+const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.");
+const static rtl::OUString sUrlPart2 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
+
+void processWindowMacro( ScDocShell* pShell, uno::Any aElement, String sFuncName );
+uno::Any getVbaWindow( ScDocShell* pShell );
+
+typedef ::cppu::WeakImplHelper1< awt::XWindowListener > WindowListener_BASE;
+class VbaWindowListener : public WindowListener_BASE
+{
+    ScDocShell* m_pShell;
+    uno::Reference< frame::XModel > m_xModel;
+    sal_Bool m_bPrepare;
+protected :
+    uno::Reference< awt::XWindow > GetContainerWindow();
+    sal_Bool IsMouseReleased();
+    DECL_LINK( fireResizeMacro, Timer* );
+    void processWindowResizeMacro();
+public :
+    VbaWindowListener( ScDocShell* pShell );
+    void startWindowLinstener();
+    void stopWindowLinstener();
+    // XWindowListener
+    virtual void SAL_CALL windowResized( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowMoved( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowShown( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowHidden( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+VbaWindowListener::VbaWindowListener( ScDocShell* pShell ) : m_pShell( pShell )
+{
+    m_xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
+    m_bPrepare = sal_False;
+    //m_pTimer = 0;
+}
+uno::Reference< awt::XWindow > 
+VbaWindowListener::GetContainerWindow() 
+{
+    try
+    {
+        if( m_xModel.is() )
+        {
+            uno::Reference< frame::XModel > xModel( m_xModel, uno::UNO_QUERY_THROW );
+            uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+            uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY_THROW );
+            uno::Reference< awt::XWindow > xWindow( xFrame->getContainerWindow(), uno::UNO_QUERY_THROW );
+            return xWindow;
+        }
+    }
+	catch( uno::Exception& e )
+    {
+    }
+    return uno::Reference< awt::XWindow >();
+}
+sal_Bool
+VbaWindowListener::IsMouseReleased()
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow )
+    {
+        Window::PointerState aPointerState = pWindow->GetPointerState();
+        if( !aPointerState.mnState & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
+            return sal_True; 
+    }
+    return sal_False;
+}
+void
+VbaWindowListener::startWindowLinstener()
+{
+    uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY_THROW );
+    xWindow->addWindowListener( this );
+}
+void
+VbaWindowListener::stopWindowLinstener()
+{
+    uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY_THROW );
+    xWindow->removeWindowListener( this );
+}
+void
+VbaWindowListener::processWindowResizeMacro()
+{
+    const static String sWindowResize( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowResize") );
+    if( m_xModel.is() )
+        processWindowMacro( m_pShell, getVbaWindow( m_pShell ), sWindowResize );
+}
+IMPL_LINK( VbaWindowListener, fireResizeMacro, Timer*, pTimer )
+{
+    if( m_bPrepare && pTimer )
+    {
+        if( IsMouseReleased() )
+        {
+            pTimer->Stop();
+            delete pTimer;
+            pTimer = 0;
+            m_bPrepare = sal_False;
+            OSL_TRACE("\tfiredMacroAtHere");
+            processWindowResizeMacro();
+        }
+    }
+    return 0;
+}
+void SAL_CALL
+VbaWindowListener::windowResized(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && !m_bPrepare )
+    {
+        m_bPrepare = sal_True;
+        AutoTimer* pTimer = new AutoTimer();
+        pTimer->SetTimeoutHdl( LINK( this, VbaWindowListener, fireResizeMacro ) );
+        pTimer->Start();
+        OSL_TRACE("\tVbaWindowListener::windowResized");
+    }
+}
+void SAL_CALL
+VbaWindowListener::windowMoved(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowMoved");
+}
+void SAL_CALL
+VbaWindowListener::windowShown(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowShown");
+}
+void SAL_CALL
+VbaWindowListener::windowHidden(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowHidden");
+}
+void SAL_CALL
+VbaWindowListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    m_pShell = 0;
+    m_xModel->dispose();
+    OSL_TRACE("\tVbaWindowListener::disposing");
+}
+
+ rtl::OUString getWorkbookModuleName( ScDocShell* pShell )
+{
+	rtl::OUString sCodeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+	if ( pShell )
+	{
+		if ( ScExtDocOptions* pExtDocOpts = pShell->GetDocument()->GetExtDocOptions() )
+		{
+			if ( pExtDocOpts->GetDocSettings().maGlobCodeName.Len() > 0 ) 
+				sCodeName = pExtDocOpts->GetDocSettings().maGlobCodeName;
+		}
+	}
+	return sCodeName;
+}	
+// Treat the args as possible inouts ( convertion at bottom of method )
+bool executeWorkBookMacro( ScDocShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet )
+{
+	// until ObjectModules ( and persisting of codenames ) is supported, if this is a
+	// document saved from XL then we won't be able to determine the codename for the Workbook
+	// Module, so... we have no choice but to search all modules for the moment, thus the macro
+	// passed in should be the fully specified name. 	
+	//rtl::OUString sCodeName = getWorkbookModuleName( pShell );
+	//rtl::OUString sUrl = sUrlPart1.concat( sCodeName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sMacroName ).concat( sUrlPart2 );
+	rtl::OUString sUrl = sUrlPart0.concat( sMacroName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sUrlPart2 ) ;
+	uno::Sequence< sal_Int16 > aOutArgsIndex;
+	uno::Sequence< uno::Any > aOutArgs;
+	ErrCode nErr = pShell->CallXScript( sUrl,  aArgs, aRet,
+			aOutArgsIndex, aOutArgs, false );
+
+	// Script Executed?
+	if ( nErr != ERRCODE_NONE )
+		return false;
+
+	sal_Int32 nLen = aOutArgs.getLength();
+	// convert any out params to seem like they were inouts
+	if ( nLen )
+	{
+		for ( sal_Int32 index=0; index < nLen; ++index )
+		{
+			sal_Int32 nOutIndex = aOutArgsIndex[ index ];
+			aArgs[ nOutIndex ] = aOutArgs[ index ];
+		}
+
+	}
+	return true;
+}
+String docMacroExists( ScDocShell* pShell, 
+const String& sMod, const String& sMacro )
+{
+	String sFullName;	
+	// would use the script provider to see if the macro exists but
+	// called at this stage tdoc content handler stuff is not set up
+	// so it fails
+
+	BasicManager* pBasicMgr = pShell-> GetBasicManager();
+	if ( pBasicMgr )
+	{
+		StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
+		if ( !pBasic )
+		{
+			USHORT nId = pBasicMgr->GetLibId( sLibrary );
+			pBasicMgr->LoadLib( nId );
+			pBasic = pBasicMgr->GetLib( sLibrary );
+		}
+		if ( pBasic )
+		{
+			if ( sMod.Len() ) // we wish to find the macro is a specific module
+			{
+				SbModule* pModule = pBasic->FindModule( sMod );
+				if ( pModule )
+				{
+					SbxArray* pMethods = pModule->GetMethods();
+					if ( pMethods )
+					{
+						SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
+						if ( pMethod )
+						{
+							sFullName = sMacro;
+							sFullName.Insert( '.', 0 ).Insert( sMod, 0 ).Insert( '.', 0 ).Insert( sLibrary, 0 );
+						}
+					}
+				}
+			}
+			else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
+			{
+					if( SbModule* pModule = pMethod->GetModule() )
+					{
+						sFullName = sMacro;
+						sFullName.Insert( '.', 0 ).Insert( pModule->GetName(), 0).Insert( '.', 0 ).Insert( sLibrary, 0 );
+					}
+			}		
+				
+		}
+	}
+	return sFullName;
+}
+
+bool processDocBeforeCloseMacro( ScDocShell* pShell )
+{
+	
+	uno::Any aRet;
+	uno::Sequence< uno::Any > aArgs( 1 );
+	bool bCancel = sal_False;
+	aArgs[ 0 ] <<= bCancel;
+	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforeClose") );
+	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
+	if ( sFullClose.Len() > 0 )
+	{ 
+		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
+			return false;
+	}
+	aArgs[ 0 ] >>= bCancel;
+	return bCancel;
+}
+
+bool processDocBeforePrintMacro( ScDocShell* pShell )
+{
+	
+	uno::Any aRet;
+	uno::Sequence< uno::Any > aArgs( 1 );
+	bool bCancel = sal_False;
+	aArgs[ 0 ] <<= bCancel;
+	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforePrint") );
+	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
+	if ( sFullClose.Len() > 0 )
+	{ 
+		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
+			return false;
+	}
+	aArgs[ 0 ] >>= bCancel;
+	return bCancel;
+}
+
+void processDocNewSheetMacro( ScDocShell* pShell, uno::Any aElement )
+{
+    uno::Any aRet;
+    if( aElement.hasValue() )
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = aElement;
+        const static String sNewSheet( RTL_CONSTASCII_USTRINGPARAM("Workbook_NewSheet") );
+        String sFullClose = docMacroExists( pShell, String(), sNewSheet );
+        if ( sFullClose.Len() > 0 )
+        {
+            executeWorkBookMacro( pShell, sFullClose, aArgs, aRet );
+        }
+    }
+}
+
+uno::Any createWorkSheet( ScDocShell* pShell, SCTAB nTab )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		// Eventually we will be able to pull the Workbook/Worksheet objects
+		// directly from basic and register them as listeners
+
+		// create Workbook
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+		aArgs[1] = uno::Any( pShell->GetModel() );
+		uno::Reference< uno::XInterface > xWorkbook( xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs, xCtx ), uno::UNO_QUERY );
+
+		// create WorkSheet
+		String sSheetName;
+		pShell->GetDocument()->GetName( nTab, sSheetName );
+		aArgs = uno::Sequence< uno::Any >(3);
+		aArgs[ 0 ] <<= xWorkbook;
+		aArgs[ 1 ] <<= pShell->GetModel();
+		aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
+		aRet <<= xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs, xCtx );
+	}
+	catch( uno::Exception& e )
+	{
+	}
+	return aRet;
+}
+
+
+void processScTablesHint( ScDocShell* pShell, const ScTablesHint& rHint )
+{
+    if( pShell )
+    {
+        USHORT nId = rHint.GetId();
+        SCTAB  nTab = rHint.GetTab1();
+        if( nId == SC_TAB_INSERTED )
+        {
+            processDocNewSheetMacro( pShell, createWorkSheet( pShell, nTab ) );
+        }
+    }
+}
+
+void processWindowMacro( ScDocShell* pShell, uno::Any aElement, String sFuncName )
+{
+    uno::Any aRet;
+    if( aElement.hasValue() && ( sFuncName.Len() > 0 ) )
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = aElement;
+        String sMacro = docMacroExists( pShell, String(), sFuncName );
+        if ( sMacro.Len() > 0 )
+        {
+            executeWorkBookMacro( pShell, sMacro, aArgs, aRet );
+        }
+    }
+}
+uno::Any getVbaWindow( ScDocShell* pShell )
+{
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+        uno::Sequence< uno::Any > aWindowArgs(2);
+        aWindowArgs[0] = uno::Any( uno::Reference< uno::XInterface > () );
+        aWindowArgs[1] = uno::Any( xModel );
+        uno::Reference< uno::XInterface > xWindow( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Window" ) ), aWindowArgs ), uno::UNO_QUERY );
+        if( xWindow.is() )
+            return uno::makeAny( xWindow );
+    }
+	catch( uno::Exception& e )
+	{
+	}
+    return uno::Any();
+}
+
+bool addDocEvent( ScDocShell* pShell, const rtl::OUString& sEvt, const rtl::OUString& sOpenMacro )
+{
+	bool result = false;
+	const rtl::OUString sUrl = sUrlPart0.concat( sOpenMacro ).concat( sUrlPart2 );
+	const static rtl::OUString sEvtType( RTL_CONSTASCII_USTRINGPARAM("EventType") );
+	const static rtl::OUString sScript( RTL_CONSTASCII_USTRINGPARAM("Script") );
+	uno::Reference< document::XEventsSupplier > xEvtSupplier( pShell->GetModel(), uno::UNO_QUERY );
+
+	if ( xEvtSupplier.is() )
+    {
+		uno::Reference< container::XNameReplace > xEvts( xEvtSupplier->getEvents(), uno::UNO_QUERY );
+	    if ( xEvts.is() )
+	    {
+            if( xEvts->hasByName( sEvt ) )
+            {
+                if( !xEvts->getByName( sEvt ).hasValue() )
+                {
+                    uno::Sequence< beans::PropertyValue > aEvt( 2 );
+                    aEvt[ 0 ].Name = sEvtType;
+                    aEvt[ 0 ].Value = uno::makeAny(sScript);
+                    aEvt[ 1 ].Name = sScript;
+                    aEvt[ 1 ].Value = uno::makeAny(sUrl);
+
+		            uno::Any aParam = uno::makeAny( aEvt );
+                    xEvts->replaceByName( sEvt, aParam );
+		            result = true;
+                }
+            }
+	    }
+    }
+	return result;
+}
+
+
+bool processDocActivateMacro( ScDocShell* pShell )
+{
+    bool result = true;
+    const static rtl::OUString sAtctivateMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Activate") );
+    const static rtl::OUString sOnFocusEvt( RTL_CONSTASCII_USTRINGPARAM("OnFocus") );
+    rtl::OUString sWorkbookModule;
+    String sFullOnFocus = docMacroExists( pShell, sWorkbookModule, sAtctivateMacro );
+    if( sFullOnFocus.Len() > 0 )
+    {
+        if( !addDocEvent( pShell, sOnFocusEvt, sFullOnFocus ) )
+            return false;
+    }
+    return result;
+}
+
+bool processDocDeactivateMacro( ScDocShell* pShell )
+{
+    bool result = true;
+    const static rtl::OUString sDeatctivateMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Deactivate") );
+    const static rtl::OUString sOnFocusEvt( RTL_CONSTASCII_USTRINGPARAM("OnUnfocus") );
+    rtl::OUString sWorkbookModule;
+    String sFullUnOnfocus = docMacroExists( pShell, sWorkbookModule, sDeatctivateMacro );
+    if( sFullUnOnfocus.Len() > 0 )
+    {
+        if( !addDocEvent( pShell, sOnFocusEvt, sFullUnOnfocus ) )
+            return false;
+    }
+    return result;
+}
+
+void processDocDeactivateMacroRun( ScDocShell* pShell )
+{
+    uno::Any aRet;
+    uno::Sequence< uno::Any > aArgs;
+    const static String sDeactivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_Deactivate") );
+    String sDeactivateMacro = docMacroExists( pShell, String(), sDeactivate );
+    if ( sDeactivateMacro.Len() > 0 )
+    {
+        executeWorkBookMacro( pShell, sDeactivateMacro, aArgs, aRet );
+    }
+}
+
+void processSfxEventHint( ScDocShell* pShell, const SfxEventHint& rHint )
+{
+    ULONG nEventId = rHint.GetEventId();
+    const static String sWindowActivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowActivate") );
+    const static String sWindowDeactivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowDeactivate") );
+    switch( nEventId )
+    {
+        case SFX_EVENT_ACTIVATEDOC :
+            processWindowMacro( pShell, getVbaWindow( pShell ), sWindowActivate );
+            break;
+        case SFX_EVENT_DEACTIVATEDOC :
+            // it will be called when close the doc. but will not launch the macro.
+            processWindowMacro( pShell, getVbaWindow( pShell ), sWindowDeactivate );
+            break;
+        case SFX_EVENT_CLOSEDOC :
+            // the macro will not be called at this time, because of the doc has died.
+            //processDocDeactivateMacroRun( pShell );
+            break;
+        case SFX_EVENT_CLOSEVIEW :
+            processWindowMacro( pShell, getVbaWindow( pShell ), sWindowDeactivate );
+            // does Doc be closed surely?
+            processDocDeactivateMacroRun( pShell );
+            break;
+        case SFX_EVENT_OPENDOC :
+        {
+            VbaWindowListener* pListener = new VbaWindowListener( pShell );
+            pListener->startWindowLinstener();
+            break;
+        }
+        default:
+            break;
+    }
+}
+
+bool processDocBeforeSaveMacro( ScDocShell* pShell, bool bSaveAsUI )
+{
+	
+	uno::Any aRet;
+	uno::Sequence< uno::Any > aArgs( 2 );
+	bool bCancel = sal_False;
+    aArgs[ 0 ] <<= bSaveAsUI;
+	aArgs[ 1 ] <<= bCancel;
+	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforeSave") );
+	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
+	if ( sFullClose.Len() > 0 )
+	{ 
+		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
+			return false;
+	}
+	aArgs[ 1 ] >>= bCancel;
+	return bCancel;
+}
+
+bool processDocOpenMacro( ScDocShell* pShell )
+{
+	bool result = true;
+	// no point adding a handler for unless it exists
+	// probably worth just doing this on import of xl document
+	
+		
+	// Urk due to async nature, re-enterency and other horrors of the load
+	// process, its seems the most sensible thing is to hook into the 
+	// document event broadcaster
+	const static rtl::OUString sOpenMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Open") );
+	const static rtl::OUString sAuto_OpenMacro( RTL_CONSTASCII_USTRINGPARAM("auto_open") );
+    const static rtl::OUString sOnLoadEvt( RTL_CONSTASCII_USTRINGPARAM("OnLoad") );
+
+	// until ObjectModules ( and persisting of codename )  are supported if this is a
+	// document saved from XL then we won't be able to determine the codename for the Workbook
+	// Module, so... we have no choice but to search all modules for the moment 	
+	//rtl::OUString workbookModule = getWorkbookModuleName( pShell );
+	rtl::OUString workbookModule; // no name means all modules will be searched
+	String sFullOpen = docMacroExists( pShell, workbookModule, sOpenMacro );
+	if ( sFullOpen.Len() > 0 )
+	{
+			if ( !addDocEvent( pShell, sOnLoadEvt, sFullOpen ) )
+				return false;
+	}
+	// deep sigh, you can only specify one event binding not multiple ones, thats crap
+/*
+		String sFullAuto = docMacroExists( pShell, workbookModule, sAuto_OpenMacro );
+		if ( sFullAuto.Len() > 0 )
+		{
+				if ( !addOpenDocEvent( xEvts, sFullAuto ) )
+					return false;
+		}
+*/
+
+	return result;
+}
+bool processDocMacro( ScDocShell* pShell )
+{
+    bool result = true;
+    if ( !processDocOpenMacro( pShell ) )
+        result = false;
+    if( !processDocActivateMacro( pShell ) )
+        result = false;
+    if( !processDocDeactivateMacro( pShell ) )
+        result = false;
+
+    return result;
+}
+
+uno::Any createRange( const uno::Any& aRange )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
+		uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		if (  xRanges.is() || xRange.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			if ( xRanges.is() )
+			{
+				aArgs[1] <<= xRanges;
+			}
+			else if ( xRange.is() )
+			{
+				aArgs[1] <<= xRange;
+			}
+			else
+			{
+				throw uno::RuntimeException(); // 
+			}
+			aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Range") ), aArgs, xCtx  );	
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+String getSheetModuleName( ScDocShell* pShell, SCTAB nTab )
+{
+	ScExtDocOptions* pExtOptions = pShell->GetDocument()->GetExtDocOptions();
+	String aCodeName;
+	pShell->GetDocument()->GetName( nTab, aCodeName);
+	// Use code name if that exists
+	if ( pExtOptions )
+		aCodeName = pExtOptions->GetCodeName( nTab );
+	return aCodeName;	
+}
+
+sal_Bool executeSheetMacro( ScDocShell* pShell, SCTAB nTab, String& rMacroName, uno::Sequence< uno::Any >& rArgs )
+{
+	String aModuleName = getSheetModuleName( pShell, nTab );
+	String aMacro = docMacroExists( pShell, aModuleName, rMacroName );
+	if( aMacro.Len() == 0 )
+		return sal_False;
+	
+	uno::Any aRet;
+	return executeWorkBookMacro( pShell, aMacro, rArgs, aRet );
+}
+
+sal_Bool processSheetActivateMacro( ScDocShell* pShell, SCTAB nTab )
+{
+	static String aMacroName( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Activate") );
+	uno::Sequence< uno::Any > aArgs;
+	return executeSheetMacro( pShell, nTab, aMacroName, aArgs );
+}
+
+sal_Bool processSheetDeactivateMacro( ScDocShell* pShell, SCTAB nTab )
+{
+	static String aMacroName( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Deactivate") );
+	uno::Sequence< uno::Any > aArgs;
+	return executeSheetMacro( pShell, nTab, aMacroName, aArgs );
+}
+
+sal_Bool processSheetCalculateMacro( ScDocShell* pShell, SCTAB nTab )
+{
+	static String aMacroName( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Calculate") );
+	uno::Sequence< uno::Any > aArgs;
+	return executeSheetMacro( pShell, nTab, aMacroName, aArgs );
+}
+
+sal_Bool processSheetChangeMacro( ScDocShell* pShell, SCTAB nTab, const uno::Any& rRange )
+{
+	static String aMacroName( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Change") );
+	uno::Sequence< uno::Any > aArgs(1);
+	uno::Any aRange = createRange( rRange );
+	aArgs[0] = aRange;
+	return executeSheetMacro( pShell, nTab, aMacroName, aArgs );
+}
+
+sal_Bool processSheetBeforeDoubleClickMacro( ScDocShell* pShell, SCTAB nTab, const uno::Any& rRange )
+{
+	sal_Bool result = sal_False;
+	static String aMacroName( RTL_CONSTASCII_USTRINGPARAM("Worksheet_BeforeDoubleClick") );
+	uno::Sequence< uno::Any > aArgs(2);
+	uno::Any aRange = createRange( rRange );
+	aArgs[0] = aRange;
+	aArgs[1] <<= sal_False;
+	executeSheetMacro( pShell, nTab, aMacroName, aArgs );
+	aArgs[1] >>= result;
+	return result;
+}
+
+sal_Bool processSheetBeforeRightClickMacro( ScDocShell* pShell, SCTAB nTab, const uno::Any& rRange )
+{
+	sal_Bool result = sal_False;
+	static String aMacroName( RTL_CONSTASCII_USTRINGPARAM("Worksheet_BeforeRightClick") );
+	uno::Sequence< uno::Any > aArgs(2);
+	uno::Any aRange = createRange( rRange );
+	aArgs[0] = aRange;
+	aArgs[1] <<= sal_False;
+	executeSheetMacro( pShell, nTab, aMacroName, aArgs );
+	aArgs[1] >>= result;
+	return result;
+}
+
+sal_Bool processSelectionChangeMacro( ScDocShell* pShell, SCTAB nTab, const uno::Any& rRange )
+{
+	sal_Bool result = sal_False;
+	String aSheetSelectionScript( RTL_CONSTASCII_USTRINGPARAM("Worksheet_SelectionChange") );
+	String aWorkBookSheetSelectionScript( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetSelectionChange") );
+	
+	uno::Sequence< uno::Any > aArgs(1);
+	uno::Any aRange = createRange( rRange );
+	aArgs[0] = aRange;
+	//Worksheet_SelectionChanged
+	result = executeSheetMacro( pShell, nTab, aSheetSelectionScript, aArgs );
+
+	//Workbook_SheetSelectionChange
+	aArgs = uno::Sequence< uno::Any >(2);
+	aArgs[0] = createWorkSheet( pShell, nTab );
+	aArgs[1] = aRange;
+	String aMacro = docMacroExists( pShell, String(), aWorkBookSheetSelectionScript );
+	if( aMacro.Len() > 0 )
+	{
+		uno::Any aRet;
+		result = executeWorkBookMacro( pShell, aMacro, aArgs, aRet );
+	}
+
+	return result;
+}
