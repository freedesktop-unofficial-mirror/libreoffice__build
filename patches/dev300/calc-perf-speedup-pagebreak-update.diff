diff --git sc/inc/document.hxx sc/inc/document.hxx
index b9f3ee3..7158086 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -1228,7 +1228,6 @@ public:
     SC_DLLPUBLIC USHORT			GetRowHeight( SCROW nRow, SCTAB nTab ) const;
     SC_DLLPUBLIC ULONG			GetRowHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab ) const;
     ULONG			GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab, double fScale ) const;
-    SC_DLLPUBLIC const ScSummableCompressedArray< SCROW, USHORT> & GetRowHeightArray( SCTAB nTab ) const;
     SC_DLLPUBLIC ULONG			GetColOffset( SCCOL nCol, SCTAB nTab ) const;
     SC_DLLPUBLIC ULONG			GetRowOffset( SCROW nRow, SCTAB nTab ) const;
 
@@ -1248,9 +1247,6 @@ public:
                         SCTAB nTab, double fScale ) const;
     SC_DLLPUBLIC inline USHORT	FastGetRowHeight( SCROW nRow, SCTAB nTab ) const;
     inline SCROW	FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const;
-                    /** No check for flags whether row is hidden, height value
-                        is returned unconditionally. */
-    inline USHORT   FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const;
 
     SCROW			GetHiddenRowCount( SCROW nRow, SCTAB nTab ) const;
 
@@ -1838,11 +1834,6 @@ inline SCROW ScDocument::FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const
 {
     return pTab[nTab]->GetRowForHeight(nHeight);
 }
-
-inline USHORT ScDocument::FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const
-{
-    return pTab[nTab]->pRowHeight->GetValue(nRow);
-}
  
 #endif
 
diff --git sc/inc/table.hxx sc/inc/table.hxx
index cf638b2..6547ee6 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -85,6 +85,7 @@ struct ScFunctionData;
 struct ScLineFlags;
 class CollatorWrapper;
 struct ScSetStringParam;
+class ScFlatUInt16RowSegments;
 class ScFlatBoolRowSegments;
 class ScFlatBoolColSegments;
 
@@ -124,7 +125,7 @@ private:
     ::std::auto_ptr<ScTableProtection> pTabProtection;
 
     USHORT*			pColWidth;
-    ScSummableCompressedArray< SCROW, USHORT>*  pRowHeight;
+    ::boost::shared_ptr<ScFlatUInt16RowSegments> mpRowHeights;
 
     BYTE*			pColFlags;
     ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
@@ -605,7 +606,7 @@ public:
     void		SetManualHeight( SCROW nStartRow, SCROW nEndRow, BOOL bManual );
 
 	USHORT		GetColWidth( SCCOL nCol );
-    SC_DLLPUBLIC USHORT GetRowHeight( SCROW nRow );
+    SC_DLLPUBLIC USHORT GetRowHeight( SCROW nRow, SCROW* pStartRow = NULL, SCROW* pEndRow = NULL );
 	ULONG		GetRowHeight( SCROW nStartRow, SCROW nEndRow );
 	ULONG		GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale );
 	ULONG		GetColOffset( SCCOL nCol );
@@ -652,8 +653,6 @@ public:
 
     const ScBitMaskCompressedArray< SCROW, BYTE> * GetRowFlagsArray() const
                     { return pRowFlags; }
-    const ScSummableCompressedArray< SCROW, USHORT> * GetRowHeightArray() const
-                    { return pRowHeight; }
 
     BOOL		UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, BOOL bShow );
     BOOL		UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, BOOL bShow );
@@ -668,6 +667,19 @@ public:
     bool        HasColPageBreak(SCCOL nCol) const;
     bool        HasRowManualBreak(SCROW nRow) const;
     bool        HasColManualBreak(SCCOL nCol) const;
+
+    /** 
+     * Get the row position of the next manual break that occurs at or below 
+     * specified row.  When no more manual breaks are present at or below 
+     * the specified row, -1 is returned. 
+     *  
+     * @param nRow row at which the search begins. 
+     *  
+     * @return SCROW next row position with manual page break, or -1 if no 
+     *         more manual breaks are present.
+     */
+    SCROW       GetNextManualBreak(SCROW nRow) const;
+
     void        RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow);
     void        RemoveRowBreak(SCROW nRow, bool bPage, bool bManual);
     void        RemoveColBreak(SCCOL nCol, bool bPage, bool bManual);
@@ -685,6 +697,7 @@ public:
     void        SetColHidden(SCCOL nStartCol, SCCOL nEndCol, bool bHidden);
     void        CopyColHidden(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol);
     void        CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow);
+    void        CopyRowHeight(ScTable& rSrcTable, SCROW nStartRow, SCROW nEndRow, SCROW nSrcOffset);
     SCROW       FirstVisibleRow(SCROW nStartRow, SCROW nEndRow);
     SCROW       LastVisibleRow(SCROW nStartRow, SCROW nEndRow);
     SCROW       CountVisibleRows(SCROW nStartRow, SCROW nEndRow);
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 083c5c4..daacd45 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -3194,28 +3194,6 @@ ULONG ScDocument::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow,
 }
 
 
-const ScSummableCompressedArray< SCROW, USHORT> & ScDocument::GetRowHeightArray(
-        SCTAB nTab ) const
-{
-    const ScSummableCompressedArray< SCROW, USHORT> * pHeight;
-    if ( ValidTab(nTab) && pTab[nTab] )
-        pHeight = pTab[nTab]->GetRowHeightArray();
-    else
-    {
-        DBG_ERROR("wrong sheet number");
-        pHeight = 0;
-    }
-    if (!pHeight)
-    {
-        DBG_ERROR("no row heights at sheet");
-        static ScSummableCompressedArray< SCROW, USHORT> aDummy( MAXROW,
-                ScGlobal::nStdRowHeight);
-        pHeight = &aDummy;
-    }
-    return *pHeight;
-}
-
-
 SCROW ScDocument::GetHiddenRowCount( SCROW nRow, SCTAB nTab ) const
 {
     if ( ValidTab(nTab) && pTab[nTab] )
@@ -3695,7 +3673,7 @@ SCCOL ScDocument::GetNextDifferentChangedCol( SCTAB nTab, SCCOL nStart) const
 
 SCROW ScDocument::GetNextDifferentChangedRow( SCTAB nTab, SCROW nStart, bool bCareManualSize) const
 {
-    if ( ValidTab(nTab) && pTab[nTab] && pTab[nTab]->GetRowFlagsArray() && pTab[nTab]->GetRowHeightArray() )
+    if ( ValidTab(nTab) && pTab[nTab] && pTab[nTab]->GetRowFlagsArray() && pTab[nTab]->mpRowHeights )
     {
         BYTE nStartFlags = pTab[nTab]->GetRowFlags(nStart);
         USHORT nStartHeight = pTab[nTab]->GetOriginalHeight(nStart);
@@ -3705,7 +3683,7 @@ SCROW ScDocument::GetNextDifferentChangedRow( SCTAB nTab, SCROW nStart, bool bCa
             SCROW nFlagsEndRow;
             SCROW nHeightEndRow;
             BYTE nFlags = pTab[nTab]->GetRowFlagsArray()->GetValue( nRow, nIndex, nFlagsEndRow );
-            USHORT nHeight = pTab[nTab]->GetRowHeightArray()->GetValue( nRow, nIndex, nHeightEndRow );
+            USHORT nHeight = pTab[nTab]->GetRowHeight(nRow, NULL, &nHeightEndRow);
             if (((nStartFlags & CR_MANUALBREAK) != (nFlags & CR_MANUALBREAK)) ||
                 ((nStartFlags & CR_MANUALSIZE) != (nFlags & CR_MANUALSIZE)) ||
                 (bCareManualSize && (nStartFlags & CR_MANUALSIZE) && (nStartHeight != nHeight)) ||
diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
index 421e904..0134411 100644
--- sc/source/core/data/table1.cxx
+++ sc/source/core/data/table1.cxx
@@ -136,7 +136,7 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
     nRepeatStartY( SCROW_REPEAT_NONE ),
     pTabProtection( NULL ),
     pColWidth( NULL ),
-    pRowHeight( NULL ),
+    mpRowHeights( static_cast<ScFlatUInt16RowSegments*>(NULL) ),
     pColFlags( NULL ),
     pRowFlags( NULL ),
     mpHiddenCols(new ScFlatBoolColSegments),
@@ -179,7 +179,7 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 
     if (bRowInfo)
     {
-        pRowHeight = new ScSummableCompressedArray< SCROW, USHORT>( MAXROW, ScGlobal::nStdRowHeight);
+        mpRowHeights.reset(new ScFlatUInt16RowSegments(ScGlobal::nStdRowHeight));
         pRowFlags  = new ScBitMaskCompressedArray< SCROW, BYTE>( MAXROW, 0);
     }
 
@@ -221,7 +221,6 @@ ScTable::~ScTable()
 
     delete[] pColWidth;
     delete[] pColFlags;
-    delete pRowHeight;
     delete pRowFlags;
     delete pOutlineTable;
     delete pSearchParam;
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index 789de6d..56c7f49 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -121,15 +121,16 @@ void ScTable::InsertRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
     InitializeNoteCaptions();
     if (nStartCol==0 && nEndCol==MAXCOL)
     {
-        if (pRowHeight && pRowFlags)
+        if (mpRowHeights && pRowFlags)
         {
-            pRowHeight->Insert( nStartRow, nSize);
+            mpRowHeights->insertSegment(nStartRow, nSize, false);
             BYTE nNewFlags = pRowFlags->Insert( nStartRow, nSize);
             // only copy manual size flag, clear all others
             if (nNewFlags && (nNewFlags != CR_MANUALSIZE))
                 pRowFlags->SetValue( nStartRow, nStartRow + nSize - 1,
                         nNewFlags & CR_MANUALSIZE);
         }
+
         if (pOutlineTable)
             pOutlineTable->InsertRow( nStartRow, nSize );
 
@@ -153,11 +154,12 @@ void ScTable::DeleteRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
     InitializeNoteCaptions();
     if (nStartCol==0 && nEndCol==MAXCOL)
     {
-        if (pRowHeight && pRowFlags)
-        {
-            pRowHeight->Remove( nStartRow, nSize);
+        if (pRowFlags)
             pRowFlags->Remove( nStartRow, nSize);
-        }
+
+        if (mpRowHeights)
+            mpRowHeights->removeSegment(nStartRow, nStartRow+nSize);
+
         if (pOutlineTable)
             if (pOutlineTable->DeleteRow( nStartRow, nSize ))
                 if (pUndoOutline)
@@ -376,10 +378,10 @@ void ScTable::CopyToClip(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
         pTable->CopyColHidden(*this, 0, nCol2);
         pTable->CopyColFiltered(*this, 0, nCol2);
 
-        if (pRowFlags && pTable->pRowFlags && pRowHeight && pTable->pRowHeight)
+        if (pRowFlags && pTable->pRowFlags && mpRowHeights && pTable->mpRowHeights)
         {
             pTable->pRowFlags->CopyFromAnded( *pRowFlags, 0, nRow2, CR_MANUALSIZE);
-            pTable->pRowHeight->CopyFrom( *pRowHeight, 0, nRow2);
+            pTable->CopyRowHeight(*this, 0, nRow2, 0);
         }
 
         pTable->CopyRowHidden(*this, 0, nRow2);
@@ -424,10 +426,10 @@ void ScTable::CopyFromClip(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                 for (i=nCol1; i<=nCol2; i++)
                     pColWidth[i] = pTable->pColWidth[i-nDx];
 
-            if (nCol1==0 && nCol2==MAXCOL && pRowHeight && pTable->pRowHeight &&
+            if (nCol1==0 && nCol2==MAXCOL && mpRowHeights && pTable->mpRowHeights &&
                                              pRowFlags && pTable->pRowFlags)
             {
-                pRowHeight->CopyFrom( *pTable->pRowHeight, nRow1, nRow2, -nDy);
+                CopyRowHeight(*pTable, nRow1, nRow2, -nDy);
                 // Must copy CR_MANUALSIZE bit too, otherwise pRowHeight doesn't make sense
                 for (SCROW j=nRow1; j<=nRow2; j++)
                 {
@@ -666,7 +668,7 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
             bool bFlagChange = false;
 
             BOOL bWidth  = (nRow1==0 && nRow2==MAXROW && pColWidth && pDestTab->pColWidth);
-            BOOL bHeight = (nCol1==0 && nCol2==MAXCOL && pRowHeight && pDestTab->pRowHeight);
+            BOOL bHeight = (nCol1==0 && nCol2==MAXCOL && mpRowHeights && pDestTab->mpRowHeights);
 
             if (bWidth||bHeight)
             {
@@ -691,12 +693,12 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
 
                 if (bHeight)
                 {
-					bool bChange = pDestTab->pRowHeight->SumValues(nRow1, nRow2) != pRowHeight->SumValues(nRow1, nRow2);
+                    bool bChange = pDestTab->GetRowHeight(nRow1, nRow2) != GetRowHeight(nRow1, nRow2);
 
 					if (bChange)
                         bFlagChange = true;
 
-                    pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
+                    pDestTab->CopyRowHeight(*this, nRow1, nRow2, 0);
                     pDestTab->pRowFlags->CopyFrom(*pRowFlags, nRow1, nRow2);
 
                     // Hidden flags.
@@ -759,7 +761,7 @@ void ScTable::UndoToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
     if (ValidColRow(nCol1, nRow1) && ValidColRow(nCol2, nRow2))
     {
         BOOL bWidth  = (nRow1==0 && nRow2==MAXROW && pColWidth && pDestTab->pColWidth);
-        BOOL bHeight = (nCol1==0 && nCol2==MAXCOL && pRowHeight && pDestTab->pRowHeight);
+        BOOL bHeight = (nCol1==0 && nCol2==MAXCOL && mpRowHeights && pDestTab->mpRowHeights);
 
         if (bWidth||bHeight)
             IncRecalcLevel();
@@ -779,7 +781,8 @@ void ScTable::UndoToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                 for (SCCOL i=nCol1; i<=nCol2; i++)
                     pDestTab->pColWidth[i] = pColWidth[i];
             if (bHeight)
-                pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
+                pDestTab->CopyRowHeight(*this, nRow1, nRow2, 0);
+
             DecRecalcLevel();
         }
 	}
@@ -1389,7 +1392,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
                         // reicht die gedrehte Zelle bis in den sichtbaren Bereich?
 
                         SCCOL nTouchedCol = nCol;
-                        long nWidth = (long) ( pRowHeight->GetValue(nRow) * nFactor );
+                        long nWidth = static_cast<long>(mpRowHeights->getValue(nRow) * nFactor);
                         DBG_ASSERT(nWidth <= 0, "Richtung falsch");
                         while ( nWidth < 0 && nTouchedCol > 0 )
                         {
@@ -1417,7 +1420,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
 
 void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 )
 {
-    if ( !pColWidth || !pRowHeight || !pColFlags || !pRowFlags )
+    if ( !pColWidth || !mpRowHeights || !pColFlags || !pRowFlags )
     {
         DBG_ERROR( "Spalten-/Zeileninfo fehlt" );
         return;
@@ -2059,7 +2062,7 @@ void ScTable::SetColWidth( SCCOL nCol, USHORT nNewWidth )
 
 void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
 {
-    if (VALIDROW(nRow) && pRowHeight)
+    if (VALIDROW(nRow) && mpRowHeights)
     {
         if (!nNewHeight)
         {
@@ -2067,7 +2070,7 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
             nNewHeight = ScGlobal::nStdRowHeight;
         }
 
-        USHORT nOldHeight = pRowHeight->GetValue(nRow);
+        sal_uInt16 nOldHeight = mpRowHeights->getValue(nRow);
         if ( nNewHeight != nOldHeight )
         {
             IncRecalcLevel();
@@ -2075,7 +2078,7 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
             ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
             if (pDrawLayer)
                 pDrawLayer->HeightChanged( nTab, nRow, ((long) nNewHeight) - (long) nOldHeight );
-            pRowHeight->SetValue( nRow, nNewHeight);
+            mpRowHeights->setValue(nRow, nRow, nNewHeight);
             DecRecalcLevel();
 
             InvalidatePageBreaks();
@@ -2088,12 +2091,45 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
     }
 }
 
+namespace {
+
+/** 
+ * Check if the new pixel size is different from the old size between 
+ * specified ranges. 
+ */
+bool lcl_pixelSizeChanged(
+    ScFlatUInt16RowSegments& rRowHeights, SCROW nStartRow, SCROW nEndRow, 
+    sal_uInt16 nNewHeight, double nPPTY)
+{
+    long nNewPix = static_cast<long>(nNewHeight * nPPTY);
+
+    ScFlatUInt16RowSegments::ForwardIterator aFwdIter(rRowHeights);
+    for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
+    {
+        sal_uInt16 nHeight;
+        if (!aFwdIter.getValue(nRow, nHeight))
+            break;
+
+        if (nHeight != nNewHeight)
+        {    
+            bool bChanged = (nNewPix != static_cast<long>(nHeight * nPPTY));
+            if (bChanged)
+                return true;
+        }
+
+        // Skip ahead to the last position of the current range.
+        nRow = aFwdIter.getLastPos();
+    }
+    return false;
+}
+
+}
 
 BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeight,
                                     double /* nPPTX */, double nPPTY )
 {
     BOOL bChanged = FALSE;
-    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
+    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && mpRowHeights)
     {
         IncRecalcLevel();
         InitializeNoteCaptions();
@@ -2103,8 +2139,6 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
             nNewHeight = ScGlobal::nStdRowHeight;
         }
 
-        long nNewPix = (long) ( nNewHeight * nPPTY );
-
         BOOL bSingle = FALSE;   // TRUE = process every row for its own
         ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
         if (pDrawLayer)
@@ -2113,24 +2147,17 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
 
         if (bSingle)
         {
-            size_t nIndex;
-            SCROW nRegionEndRow;
-            USHORT nOldHeight = pRowHeight->GetValue( nStartRow, nIndex, nRegionEndRow);
-            if (nNewHeight == nOldHeight && nEndRow <= nRegionEndRow)
+            ScFlatUInt16RowSegments::RangeData aData;
+            mpRowHeights->getRangeData(nStartRow, aData);
+            if (nNewHeight == aData.mnValue && nEndRow <= aData.mnRow2)
                 bSingle = FALSE;    // no difference in this range
         }
         if (bSingle)
         {
             if (nEndRow-nStartRow < 20)
             {
-                // Whether new pixel size will differ from old pixel size in any row.
-                ScCompressedArrayIterator< SCROW, USHORT> aIter( *pRowHeight,
-                        nStartRow, nEndRow);
-                do
-                {
-                    if (*aIter != nNewHeight)
-                        bChanged = (nNewPix != (long) (*aIter * nPPTY));
-                } while (!bChanged && aIter.NextRange());
+                if (!bChanged)
+                    bChanged = lcl_pixelSizeChanged(*mpRowHeights, nStartRow, nEndRow, nNewHeight, nPPTY);
 
                 /*  #i94028# #i94991# If drawing objects are involved, each row
                     has to be changed for its own, because each call to
@@ -2143,12 +2170,12 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
                     for( SCROW nRow = nStartRow; nRow <= nEndRow ; ++nRow )
                     {
                         pDrawLayer->HeightChanged( nTab, nRow,
-                             ((long) nNewHeight) - ((long) pRowHeight->GetValue( nRow )));
-                        pRowHeight->SetValue( nRow, nNewHeight );
+                             static_cast<long>(nNewHeight) - static_cast<long>(mpRowHeights->getValue(nRow)));
+                        mpRowHeights->setValue(nRow, nRow, nNewHeight);
                     }
                 }
                 else
-                    pRowHeight->SetValue( nStartRow, nEndRow, nNewHeight);
+                    mpRowHeights->setValue(nStartRow, nEndRow, nNewHeight);
             }
             else
             {
@@ -2162,22 +2189,19 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
         {
             if (pDrawLayer)
             {
-                unsigned long nOldHeights = pRowHeight->SumValues( nStartRow, nEndRow);
+                unsigned long nOldHeights = GetRowHeight(nStartRow, nEndRow);
                 // FIXME: should we test for overflows?
                 long nHeightDif = (long) (unsigned long) nNewHeight *
                     (nEndRow - nStartRow + 1) - nOldHeights;
                 pDrawLayer->HeightChanged( nTab, nEndRow, nHeightDif );
             }
-            // Whether new pixel size will differ from old pixel size in any row.
-            ScCompressedArrayIterator< SCROW, USHORT> aIter( *pRowHeight,
-                    nStartRow, nEndRow);
-            do
-            {
-                if (*aIter != nNewHeight)
-                    bChanged = (nNewPix != (long) (*aIter * nPPTY));
-            } while (!bChanged && aIter.NextRange());
-            pRowHeight->SetValue( nStartRow, nEndRow, nNewHeight);
+
+            if (!bChanged)
+                bChanged = lcl_pixelSizeChanged(*mpRowHeights, nStartRow, nEndRow, nNewHeight, nPPTY);
+
+            mpRowHeights->setValue(nStartRow, nEndRow, nNewHeight);
         }
+
         DecRecalcLevel();
 
         if (bChanged)
@@ -2283,16 +2307,27 @@ USHORT ScTable::GetCommonWidth( SCCOL nEndCol )
 }
 
 
-USHORT ScTable::GetRowHeight( SCROW nRow )
+USHORT ScTable::GetRowHeight( SCROW nRow, SCROW* pStartRow, SCROW* pEndRow )
 {
     DBG_ASSERT(VALIDROW(nRow),"Falsche Zeilennummer");
 
-	if (VALIDROW(nRow) && pRowHeight)
+    if (VALIDROW(nRow) && mpRowHeights)
     {
         if (RowHidden(nRow))
             return 0;
         else
-            return pRowHeight->GetValue(nRow);
+        {
+            ScFlatUInt16RowSegments::RangeData aData;
+            if (!mpRowHeights->getRangeData(nRow, aData))
+                // TODO: What should we return in case the search fails?
+                return 0;
+
+            if (pStartRow)
+                *pStartRow = aData.mnRow1;
+            if (pEndRow)
+                *pEndRow = aData.mnRow2;
+            return aData.mnValue;
+        }
     }
     else
         return (USHORT) ScGlobal::nStdRowHeight;
@@ -2303,7 +2338,7 @@ ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow )
 {
     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
 
-	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
+    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && mpRowHeights)
     {
         ULONG nHeight = 0;
         SCROW nRow = nStartRow;
@@ -2314,7 +2349,7 @@ ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow )
             {
                 if (nLastRow > nEndRow)
                     nLastRow = nEndRow;
-                nHeight += pRowFlags->SumCoupledArrayForCondition(nRow, nLastRow, 0, 0, *pRowHeight);
+                nHeight += mpRowHeights->getSumValue(nRow, nLastRow);
             }
             nRow = nLastRow + 1;
         }
@@ -2329,7 +2364,7 @@ ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale
 {
     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
 
-	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
+    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && mpRowHeights)
     {
         ULONG nHeight = 0;
         SCROW nRow = nStartRow;
@@ -2340,8 +2375,8 @@ ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale
             {
                 if (nLastRow > nEndRow)
                     nLastRow = nEndRow;
-                nHeight += pRowFlags->SumScaledCoupledArrayForCondition(
-                    nRow, nLastRow, 0, 0, *pRowHeight, fScale);
+                sal_uInt32 nThisHeight = mpRowHeights->getSumValue(nRow, nLastRow);
+                nHeight += nThisHeight * fScale;
             }
             nRow = nLastRow + 1;
         }
@@ -2356,8 +2391,8 @@ USHORT ScTable::GetOriginalHeight( SCROW nRow ) const		// non-0 even if hidden
 {
     DBG_ASSERT(VALIDROW(nRow),"wrong row number");
 
-    if (VALIDROW(nRow) && pRowHeight)
-        return pRowHeight->GetValue(nRow);
+    if (VALIDROW(nRow) && mpRowHeights)
+        return mpRowHeights->getValue(nRow);
     else
         return (USHORT) ScGlobal::nStdRowHeight;
 }
@@ -2429,9 +2464,11 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
             if (pDrawLayer)
             {
                 if (bShow)
-                    pDrawLayer->HeightChanged( nTab, nRow, (long) pRowHeight->GetValue(nRow) );
+                    pDrawLayer->HeightChanged(
+                        nTab, nRow, static_cast<long>(mpRowHeights->getValue(nRow)));
                 else
-                    pDrawLayer->HeightChanged( nTab, nRow, -(long) pRowHeight->GetValue(nRow) );
+                    pDrawLayer->HeightChanged(
+                        nTab, nRow, -static_cast<long>(mpRowHeights->getValue(nRow)));
             }
 
             SetRowHidden(nRow, nRow, !bShow);
@@ -2468,9 +2505,11 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
             if (pDrawLayer)
             {
                 if (bShow)
-                    pDrawLayer->HeightChanged( nTab, nRow, (long) pRowHeight->GetValue(nRow) );
+                    pDrawLayer->HeightChanged(
+                        nTab, nRow, static_cast<long>(mpRowHeights->getValue(nRow)));
                 else
-                    pDrawLayer->HeightChanged( nTab, nRow, -(long) pRowHeight->GetValue(nRow) );
+                    pDrawLayer->HeightChanged(
+                        nTab, nRow, -static_cast<long>(mpRowHeights->getValue(nRow)));
             }
         }
 
@@ -2519,7 +2558,7 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
             if (pDrawLayer)
             {
-                long nHeight = (long) pRowHeight->SumValues( nStartRow, nEndRow);
+                long nHeight = static_cast<long>(mpRowHeights->getSumValue(nStartRow, nEndRow));
                 if (bShow)
                     pDrawLayer->HeightChanged( nTab, nStartRow, nHeight );
                 else
@@ -2569,7 +2608,7 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
             if (pDrawLayer)
             {
-                long nHeight = (long) pRowHeight->SumValues( nStartRow, nEndRow);
+                long nHeight = static_cast<long>(mpRowHeights->getSumValue(nStartRow, nEndRow));
                 if (bShow)
                     pDrawLayer->HeightChanged( nTab, nStartRow, nHeight );
                 else
@@ -2681,7 +2720,10 @@ SCROW ScTable::GetLastChangedRow() const
     if (!ValidRow(nLastFlags))
         nLastFlags = 0;
 
-    SCROW nLastHeight = pRowHeight->GetLastUnequalAccess( 0, ScGlobal::nStdRowHeight);
+    // Find the last row position where the height is NOT the standard row
+    // height.
+    // KOHEI: Test this to make sure it does what it's supposed to.
+    SCROW nLastHeight = mpRowHeights->findLastNotOf(ScGlobal::nStdRowHeight);
     if (!ValidRow(nLastHeight))
         nLastHeight = 0;
 
@@ -2979,7 +3021,7 @@ void ScTable::SetDrawPageSize(bool bResetStreamValid)
 ULONG ScTable::GetRowOffset( SCROW nRow )
 {
     ULONG n = 0;
-    if ( pRowFlags && pRowHeight )
+    if ( mpHiddenRows && mpRowHeights )
     {
         if (nRow == 0)
             return 0;
@@ -3015,7 +3057,7 @@ SCROW ScTable::GetRowForHeight(ULONG nHeight)
             continue;
         }
 
-        sal_uInt32 nNew = pRowHeight->GetValue(nRow);
+        sal_uInt32 nNew = mpRowHeights->getValue(nRow);
         nSum += nNew;
         if (nSum > nHeight)
         {
diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
index 9c124bc..5eea2b0 100644
--- sc/source/core/data/table5.cxx
+++ sc/source/core/data/table5.cxx
@@ -203,15 +203,31 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     BOOL bRepeatRow = ( nRepeatStartY != SCROW_REPEAT_NONE );
     BOOL bRowFound = FALSE;
     long nSizeY = 0;
-    ScFlatBoolRowSegments::ForwardIterator aIter(*mpHiddenRows);
+    ScFlatBoolRowSegments::ForwardIterator aIterHidden(*mpHiddenRows);
+    ScFlatUInt16RowSegments::ForwardIterator aIterHeights(*mpRowHeights);
+    SCROW nNextManualBreak = GetNextManualBreak(nStartRow); // -1 => no more manual breaks
     for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
     {
         BOOL bStartOfPage = FALSE;
         bool bThisRowHidden = false;
-        aIter.getValue(nY, bThisRowHidden);
-        long nThisY = bThisRowHidden ? 0 : pRowHeight->GetValue(nY);
+        aIterHidden.getValue(nY, bThisRowHidden);
+        long nThisY = 0;
+        if (!bThisRowHidden)
+        {
+            sal_uInt16 nTmp;    
+            aIterHeights.getValue(nY, nTmp);
+            nThisY = static_cast<long>(nTmp);
+        }
+
+        bool bManualBreak = false;
+        if (nNextManualBreak >= 0)
+        {
+            bManualBreak = (nY == nNextManualBreak);
+            if (nY >= nNextManualBreak)
+                // Query the next menual break position.
+                nNextManualBreak = GetNextManualBreak(nY+1);
+        }
 
-        bool bManualBreak = HasRowManualBreak(nY);
 		if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
         {
             SetRowBreak(nY, true, false);
@@ -237,6 +253,38 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
             bRowFound = TRUE;
         }
 
+        if (bThisRowHidden)
+        {
+            // Hidden row range.  Skip them unless there is a manual break.
+            SCROW nLastCommon = aIterHidden.getLastPos();
+            if (nNextManualBreak >= 0)
+                nLastCommon = ::std::min(nLastCommon, nNextManualBreak-1);
+            nY = nLastCommon;
+        }
+        else
+        {
+            // Visible row range.
+
+            SCROW nLastHidden = aIterHidden.getLastPos();
+            SCROW nLastHeight = aIterHeights.getLastPos();
+            SCROW nLastCommon = ::std::min(nLastHidden, nLastHeight);
+            if (nNextManualBreak >= 0)
+                nLastCommon = ::std::min(nLastCommon, nNextManualBreak-1);
+    
+            if (nLastCommon > nY)
+            {
+                long nMaxMultiple = static_cast<long>(nLastCommon - nY);
+                long nMultiple = (nPageSizeY - nSizeY) / nThisY;
+                if (nMultiple > nMaxMultiple)
+                    nMultiple = nMaxMultiple;
+                if (nMultiple > 1)
+                {
+                    nSizeY += nThisY * (nMultiple - 1);
+                    nY += nMultiple - 1;
+                }
+            }
+        }
+
         nSizeY += nThisY;
     }
 
@@ -328,6 +376,12 @@ bool ScTable::HasColManualBreak(SCCOL nCol) const
     return (maColManualBreaks.count(nCol) > 0);
 }
 
+SCROW ScTable::GetNextManualBreak(SCROW nRow) const
+{
+    set<SCROW>::const_iterator itr = maRowManualBreaks.lower_bound(nRow);
+    return itr == maRowManualBreaks.end() ? -1 : *itr;
+}
+
 void ScTable::RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow)
 {
     using namespace std;
@@ -565,6 +619,25 @@ void ScTable::CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow)
     }
 }
 
+void ScTable::CopyRowHeight(ScTable& rSrcTable, SCROW nStartRow, SCROW nEndRow, SCROW nSrcOffset)
+{
+    SCROW nRow = nStartRow;
+    ScFlatUInt16RowSegments::RangeData aSrcData;
+    while (nRow <= nEndRow)
+    {
+        if (!rSrcTable.mpRowHeights->getRangeData(nRow + nSrcOffset, aSrcData))
+            // Something is wrong !
+            return;
+
+        SCROW nLastRow = aSrcData.mnRow2 - nSrcOffset;
+        if (nLastRow > nEndRow)
+            nLastRow = nEndRow;
+
+        mpRowHeights->setValue(nRow, nLastRow, aSrcData.mnValue);
+        nRow = nLastRow + 1;
+    }
+}
+
 SCROW ScTable::FirstVisibleRow(SCROW nStartRow, SCROW nEndRow)
 {
     SCROW nRow = nStartRow;
@@ -647,7 +720,7 @@ sal_uInt32 ScTable::GetTotalRowHeight(SCROW nStartRow, SCROW nEndRow)
 
         if (!aData.mbValue)
             // visible row range.
-            nHeight += pRowHeight->SumValues(nRow, aData.mnRow2);
+            nHeight += mpRowHeights->getSumValue(nRow, aData.mnRow2);
 
         nRow = aData.mnRow2 + 1;
     }
diff --git sc/source/ui/view/prevloc.cxx sc/source/ui/view/prevloc.cxx
index fb65955..65c7f73 100644
--- sc/source/ui/view/prevloc.cxx
+++ sc/source/ui/view/prevloc.cxx
@@ -692,7 +692,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
                 if (pDoc->RowHidden(nRow, nTab))
                     continue;
 
-                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
+                USHORT nDocH = pDoc->GetOriginalHeight( nRow, nTab );
                 long nNextY = nPosY + (long) (nDocH * nScaleY);
 
                 long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
@@ -713,7 +713,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
                 if (pDoc->RowHidden(nRow, nTab))
                     continue;
 
-                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
+                USHORT nDocH = pDoc->GetOriginalHeight( nRow, nTab );
                 long nNextY = nPosY + (long) (nDocH * nScaleY);
 
                 long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
