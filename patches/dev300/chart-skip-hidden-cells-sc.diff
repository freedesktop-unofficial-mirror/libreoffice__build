diff --git sc/inc/chart2uno.hxx sc/inc/chart2uno.hxx
index aa13bef..5a7769b 100644
--- sc/inc/chart2uno.hxx
+++ sc/inc/chart2uno.hxx
@@ -33,6 +33,7 @@
 
 #include "cellsuno.hxx"     // for XModifyListenerArr_Impl / ScLinkListener
 #include "rangelst.hxx"
+#include "chartlis.hxx"
 #include <svtools/lstner.hxx>
 #include <com/sun/star/chart2/data/XDataProvider.hpp>
 #include <com/sun/star/chart2/data/XRangeXMLConversion.hpp>
@@ -59,6 +60,8 @@
 
 #include <map>
 #include <list>
+#include <vector>
+#include <memory>
 
 class ScDocument;
 
@@ -379,6 +382,10 @@ public:
 // 	static ScChart2DataSequence* getImplementation( const com::sun::star::uno::Reference<
 // 									com::sun::star::uno::XInterface> xObj );
 
+private:
+    void markRangeDirty(const ScRange& rRange) const;
+    void setDataChangedHint(bool b);
+
     // Implementation --------------------------------------------------------
 
     ScRangeListRef GetRangeList() { return m_xRanges; }
@@ -386,8 +393,38 @@ public:
     void    RefChanged();
     DECL_LINK( ValueListenerHdl, SfxHint* );
 
+    /** 
+     * Build an internal data array and other information such as hidden 
+     * values. 
+     */
+    void BuildDataArray();
+
 private:
 
+    // data array
+    struct Item
+    {
+        double              mfValue;
+        ::rtl::OUString     maString;
+        bool                mbIsValue;
+        Item();
+    };
+
+    class HiddenRangeListener : public ScChartHiddenRangeListener
+    {
+    public:
+        HiddenRangeListener(ScChart2DataSequence& rParent);
+        virtual ~HiddenRangeListener();
+
+        virtual void notify();
+
+    private:
+        ScChart2DataSequence& mrParent;
+    };
+
+    ::std::list<Item>           m_aDataArray;
+    ::com::sun::star::uno::Sequence<sal_Int32>  m_aHiddenValues;
+
     // properties
     ::com::sun::star::chart2::data::DataSequenceRole  m_aRole;
     sal_Bool                    m_bHidden;
@@ -398,6 +435,7 @@ private:
     com::sun::star::uno::Reference < com::sun::star::chart2::data::XDataProvider > m_xDataProvider;
 	SfxItemPropertySet		    m_aPropSet;
 
+    ::std::auto_ptr<HiddenRangeListener> m_pHiddenListener;
     ScLinkListener*             m_pValueListener;
     sal_Bool                    m_bGotDataChangedHint;
     XModifyListenerArr_Impl     m_aValueListeners;
diff --git sc/inc/chartlis.hxx sc/inc/chartlis.hxx
index 0069085..60e77ce 100644
--- sc/inc/chartlis.hxx
+++ sc/inc/chartlis.hxx
@@ -37,6 +37,8 @@
 #include "collect.hxx"
 #include "rangelst.hxx"
 
+#include <list>
+
 class ScDocument;
 class ScChartUnoData;
 #include <com/sun/star/chart/XChartData.hpp>
@@ -97,9 +99,31 @@ public:
 						{ return !operator==( r ); }
 };
 
+// ============================================================================
+
+class ScChartHiddenRangeListener
+{
+public:
+    ScChartHiddenRangeListener();
+    virtual ~ScChartHiddenRangeListener();
+    virtual void notify() = 0;
+};
+
+// ============================================================================
+
 class ScChartListenerCollection : public StrCollection
 {
+public:
+    struct RangeListenerItem
+    {
+        ScRange                     maRange;
+        ScChartHiddenRangeListener* mpListener;
+        explicit RangeListenerItem(const ScRange& rRange, ScChartHiddenRangeListener* p);
+    };
+
 private:
+    ::std::list<RangeListenerItem> maHiddenListeners;
+
 	Timer			aTimer;
 	ScDocument*		pDoc;
 
@@ -139,6 +163,24 @@ public:
     void            UpdateChartsContainingTab( SCTAB nTab );
 
 	BOOL			operator==( const ScChartListenerCollection& );
+
+    /** 
+     * Start listening on hide/show change within specified cell range.  A 
+     * single listener may listen on multiple ranges when the caller passes 
+     * the same pointer multiple times with different ranges. 
+     *  
+     * Note that the caller is responsible for managing the life-cycle of the 
+     * listener instance. 
+     */
+    void            StartListeningHiddenRange( const ScRange& rRange, 
+                                               ScChartHiddenRangeListener* pListener );
+
+    /** 
+     * Remove all ranges associated with passed listener instance from the 
+     * list of hidden range listeners.  This does not delete the passed 
+     * listener instance. 
+     */
+    void            EndListeningHiddenRange( ScChartHiddenRangeListener* pListener );
 };
 
 
diff --git sc/inc/unonames.hxx sc/inc/unonames.hxx
index ad84ca3..18c858b 100644
--- sc/inc/unonames.hxx
+++ sc/inc/unonames.hxx
@@ -610,6 +610,7 @@
 // Chart2
 #define SC_UNONAME_ISHIDDEN         "IsHidden"
 #define SC_UNONAME_ROLE             "Role"
+#define SC_UNONAME_HIDDENVALUES     "HiddenValues"
 
 // Solver
 #define SC_UNONAME_TIMEOUT          "Timeout"
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index 2ed8dbc..9bcc2b7 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -2196,7 +2196,7 @@ void ScTable::ShowCol(SCCOL nCol, BOOL bShow)
 				SetDrawPageSize();
 
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( nCol, 0, nTab, nCol, MAXROW, nTab ));
 		}
 	}
@@ -2233,7 +2233,7 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
 				SetDrawPageSize();
 
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
 		}
 	}
@@ -2274,7 +2274,7 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
 		if (bWasVis != bShow)
 		{
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
 
 			if (pOutlineTable)
@@ -2322,7 +2322,7 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 		if ( bChanged )
 		{
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
 		}
 
@@ -2374,7 +2374,7 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 		if ( bChanged )
 		{
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
 		}
 
diff --git sc/source/core/tool/chartlis.cxx sc/source/core/tool/chartlis.cxx
index 4d6b1b3..0196c9e 100644
--- sc/source/core/tool/chartlis.cxx
+++ sc/source/core/tool/chartlis.cxx
@@ -40,7 +40,7 @@
 #include "document.hxx"
 
 using namespace com::sun::star;
-
+using ::std::list;
 
 //2do: DocOption TimeOut?
 //#define SC_CHARTTIMEOUT 1000		// eine Sekunde keine Aenderung/KeyEvent
@@ -265,9 +265,24 @@ BOOL ScChartListener::operator==( const ScChartListener& r )
 		;
 }
 
+// ============================================================================
+
+ScChartHiddenRangeListener::ScChartHiddenRangeListener()
+{
+}
+
+ScChartHiddenRangeListener::~ScChartHiddenRangeListener()
+{
+    // empty d'tor
+}
 
 // === ScChartListenerCollection ======================================
 
+ScChartListenerCollection::RangeListenerItem::RangeListenerItem(const ScRange& rRange, ScChartHiddenRangeListener* p) :
+    maRange(rRange), mpListener(p)
+{
+}
+
 ScChartListenerCollection::ScChartListenerCollection( ScDocument* pDocP ) :
 	StrCollection( 4, 4, FALSE ),
 	pDoc( pDocP )
@@ -454,6 +469,14 @@ void ScChartListenerCollection::SetRangeDirty( const ScRange& rRange )
 	}
 	if ( bDirty )
 		StartTimer();
+
+    // New hidden range listener implementation
+    for (list<RangeListenerItem>::iterator itr = maHiddenListeners.begin(), itrEnd = maHiddenListeners.end();
+          itr != itrEnd; ++itr)
+    {
+        if (itr->maRange.Intersects(rRange))
+            itr->mpListener->notify();
+    }
 }
 
 
@@ -493,6 +516,34 @@ BOOL ScChartListenerCollection::operator==( const ScChartListenerCollection& r )
 	return TRUE;
 }
 
+void ScChartListenerCollection::StartListeningHiddenRange( const ScRange& rRange, ScChartHiddenRangeListener* pListener )
+{
+    RangeListenerItem aItem(rRange, pListener);
+    maHiddenListeners.push_back(aItem);
+}
 
+namespace {
 
+struct MatchListener : public ::std::unary_function<
+        ScChartListenerCollection::RangeListenerItem, bool>
+{
+    MatchListener(const ScChartHiddenRangeListener* pMatch) :
+        mpMatch(pMatch)
+    {
+    }
+
+    bool operator() (const ScChartListenerCollection::RangeListenerItem& rItem) const
+    {
+        return mpMatch == rItem.mpListener;
+    }
+
+private:
+    const ScChartHiddenRangeListener* mpMatch;
+};
+
+}
+void ScChartListenerCollection::EndListeningHiddenRange( ScChartHiddenRangeListener* pListener )
+{
+    maHiddenListeners.remove_if(MatchListener(pListener));
+}
 
diff --git sc/source/filter/excel/xechart.cxx sc/source/filter/excel/xechart.cxx
index f04d57a..7fff80d 100644
--- sc/source/filter/excel/xechart.cxx
+++ sc/source/filter/excel/xechart.cxx
@@ -2659,7 +2659,7 @@ XclExpChChart::XclExpChChart( const XclExpRoot& rRoot,
     maRect.mnWidth = static_cast< sal_Int32 >( aPtSize.Width() << 16 );
     maRect.mnHeight = static_cast< sal_Int32 >( aPtSize.Height() << 16 );
 
-    // global chart properties
+    // global chart properties (default values)
     ::set_flag( maProps.mnFlags, EXC_CHPROPS_MANSERIES );
     ::set_flag( maProps.mnFlags, EXC_CHPROPS_SHOWVISCELLS, false );
     maProps.mnEmptyMode = EXC_CHPROPS_EMPTY_SKIP;
@@ -2670,6 +2670,18 @@ XclExpChChart::XclExpChChart( const XclExpRoot& rRoot,
 
     if( xChartDoc.is() )
     {
+        Reference< XDiagram > xDiagram = xChartDoc->getFirstDiagram();
+
+        // global chart properties (only 'include hidden cells' attribute for now)
+        Reference< XPropertySet > xPropSet( xDiagram, UNO_QUERY );
+        if (xPropSet.is())
+        {
+            Any any = xPropSet->getPropertyValue( OUString::createFromAscii("IncludeHiddenCells") );
+            sal_Bool b = sal_True;
+            any >>= b;
+            ::set_flag( maProps.mnFlags,  EXC_CHPROPS_SHOWVISCELLS, !b );
+        }
+
         // initialize API conversion (remembers xChartDoc internally)
         InitConversion( xChartDoc );
 
@@ -2685,7 +2697,6 @@ XclExpChChart::XclExpChChart( const XclExpRoot& rRoot,
                                   aSubTitle.Len() ? &aSubTitle : NULL );
 
         // diagrams (axes sets)
-        Reference< XDiagram > xDiagram = xChartDoc->getFirstDiagram();
         sal_uInt16 nFreeGroupIdx = mxPrimAxesSet->Convert( xDiagram, 0 );
         if( !mxPrimAxesSet->Is3dChart() )
             mxSecnAxesSet->Convert( xDiagram, nFreeGroupIdx );
diff --git sc/source/filter/excel/xichart.cxx sc/source/filter/excel/xichart.cxx
index 46cb411..441f699 100644
--- sc/source/filter/excel/xichart.cxx
+++ sc/source/filter/excel/xichart.cxx
@@ -3227,7 +3227,7 @@ void XclImpChChart::ReadSubRecord( XclImpStream& rStrm )
             ReadChSeries( rStrm );
         break;
         case EXC_ID_CHPROPERTIES:
-            rStrm >> maProps.mnFlags >> maProps.mnEmptyMode;
+            ReadChProperties( rStrm );
         break;
         case EXC_ID_CHDEFAULTTEXT:
             ReadChDefaultText( rStrm );
@@ -3329,6 +3329,16 @@ void XclImpChChart::Convert( Reference< XChartDocument > xChartDoc, ScfProgressB
     if( xDiagram.is() && mxLegend.is() )
         xDiagram->setLegend( mxLegend->CreateLegend() );
 
+    // properties
+    Reference< XPropertySet > xPropSet(xDiagram, UNO_QUERY);
+    if (xPropSet.is())
+    {
+        bool bShowVisCells = (maProps.mnFlags & EXC_CHPROPS_SHOWVISCELLS);
+        Any any;
+        any <<= static_cast<sal_Bool>(!bShowVisCells);
+        xPropSet->setPropertyValue(OUString::createFromAscii("IncludeHiddenCells"), any);
+    }
+
     // unlock the model
     FinishConversion( rProgress );
 }
@@ -3341,6 +3351,11 @@ void XclImpChChart::ReadChSeries( XclImpStream& rStrm )
     maSeries.push_back( xSeries );
 }
 
+void XclImpChChart::ReadChProperties( XclImpStream& rStrm )
+{
+    rStrm >> maProps.mnFlags >> maProps.mnEmptyMode;
+}
+
 void XclImpChChart::ReadChAxesSet( XclImpStream& rStrm )
 {
     XclImpChAxesSetRef xAxesSet( new XclImpChAxesSet( GetChRoot(), EXC_CHAXESSET_NONE ) );
diff --git sc/source/filter/inc/xichart.hxx sc/source/filter/inc/xichart.hxx
index ada3f4e..2e79767 100644
--- sc/source/filter/inc/xichart.hxx
+++ sc/source/filter/inc/xichart.hxx
@@ -1337,6 +1337,8 @@ public:
 private:
     /** Reads a CHSERIES group (data series source and formatting). */
     void                ReadChSeries( XclImpStream& rStrm );
+    /** Reads a CHPROPERTIES record. */
+    void                ReadChProperties( XclImpStream& rStrm );
     /** Reads a CHAXESSET group (primary/secondary axes set). */
     void                ReadChAxesSet( XclImpStream& rStrm );
     /** Reads a CHTEXT group (chart title and series/point captions). */
diff --git sc/source/ui/unoobj/chart2uno.cxx sc/source/ui/unoobj/chart2uno.cxx
index 28223a8..0d561fd 100644
--- sc/source/ui/unoobj/chart2uno.cxx
+++ sc/source/ui/unoobj/chart2uno.cxx
@@ -43,6 +43,7 @@
 #include "rangeutl.hxx"
 #include "hints.hxx"
 #include "unoreflist.hxx"
+#include "chartlis.hxx"
 
 #include <sfx2/objsh.hxx>
 
@@ -1319,6 +1320,26 @@ void SAL_CALL ScChart2LabeledDataSequence::removeModifyListener( const uno::Refe
 
 // DataSequence ==============================================================
 
+ScChart2DataSequence::Item::Item() :
+    mfValue(0.0), mbIsValue(false)
+{
+    ::rtl::math::setNan(&mfValue);
+}
+
+ScChart2DataSequence::HiddenRangeListener::HiddenRangeListener(ScChart2DataSequence& rParent) :
+    mrParent(rParent)
+{
+}
+
+ScChart2DataSequence::HiddenRangeListener::~HiddenRangeListener()
+{
+}
+
+void ScChart2DataSequence::HiddenRangeListener::notify()
+{
+    mrParent.setDataChangedHint(true);
+}
+
 ScChart2DataSequence::ScChart2DataSequence( ScDocument* pDoc,
         const uno::Reference < chart2::data::XDataProvider >& xDP,
         const ScRangeListRef& rRangeList)
@@ -1328,6 +1348,7 @@ ScChart2DataSequence::ScChart2DataSequence( ScDocument* pDoc,
     , m_pDocument( pDoc)
     , m_xDataProvider( xDP)
 	, m_aPropSet(lcl_GetDataSequencePropertyMap())
+    , m_pHiddenListener(NULL)
     , m_pValueListener( NULL )
     , m_bGotDataChangedHint( FALSE )
 {
@@ -1353,7 +1374,15 @@ ScChart2DataSequence::ScChart2DataSequence( ScDocument* pDoc,
 ScChart2DataSequence::~ScChart2DataSequence()
 {
     if ( m_pDocument )
+    {
         m_pDocument->RemoveUnoObject( *this);
+        if (m_pHiddenListener.get())
+        {
+            ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+            if (pCLC)
+                pCLC->EndListeningHiddenRange(m_pHiddenListener.get());
+        }
+    }
 
     delete m_pValueListener;
 }
@@ -1361,7 +1390,10 @@ ScChart2DataSequence::~ScChart2DataSequence()
 
 void ScChart2DataSequence::RefChanged()
 {
-    if( m_pValueListener && m_aValueListeners.Count() != 0 )
+    if (m_aValueListeners.Count() == 0)
+        return;
+
+    if( m_pValueListener )
     {
         m_pValueListener->EndListeningAll();
 
@@ -1372,8 +1404,93 @@ void ScChart2DataSequence::RefChanged()
                 m_pDocument->StartListeningArea( *m_xRanges->GetObject(i), m_pValueListener );
         }
     }
+
+    if (m_pHiddenListener.get() && m_pDocument)
+    {
+        ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+        if (pCLC)
+        {
+            pCLC->EndListeningHiddenRange(m_pHiddenListener.get());
+            ULONG nCount = m_xRanges->Count();
+            for (ULONG i = 0; i < nCount; ++i)
+                pCLC->StartListeningHiddenRange(*m_xRanges->GetObject(i), m_pHiddenListener.get());
+        }
+    }
 }
 
+void ScChart2DataSequence::BuildDataArray()
+{
+    if (!m_aDataArray.empty())
+        return;
+
+    ::std::list<sal_Int32> aHiddenValues;
+    sal_Int32 nDataCount = 0;
+    sal_Int32 nHiddenValueCount = 0;
+
+    for (ScRangePtr p = m_xRanges->First(); p; p = m_xRanges->Next())
+    {
+        for (SCTAB nTab = p->aStart.Tab(); nTab <= p->aEnd.Tab(); ++nTab)
+        {
+            for (SCCOL nCol = p->aStart.Col(); nCol <= p->aEnd.Col(); ++nCol)
+            {
+                for (SCROW nRow = p->aStart.Row(); nRow <= p->aEnd.Row(); ++nRow)
+                {
+                    m_aDataArray.push_back(Item());
+                    Item& rItem = m_aDataArray.back();
+                    ++nDataCount;
+                    USHORT nWidth = m_pDocument->GetColWidth(nCol, nTab);
+                    USHORT nHeight = m_pDocument->GetRowHeight(nRow, nTab);
+                    if (!nWidth || !nHeight)
+                    {
+                        // hidden cell
+                        ++nHiddenValueCount;
+                        aHiddenValues.push_back(nDataCount-1);
+                    }
+
+                    ScAddress aAdr(nCol, nRow, nTab);
+                    ScBaseCell* pCell = m_pDocument->GetCell(aAdr);
+                    if (!pCell)
+                        continue;
+
+                    if (pCell->HasStringData())
+                        rItem.maString = pCell->GetStringData();
+                    else
+                    {
+                        String aStr;
+                        m_pDocument->GetString(nCol, nRow, nTab, aStr);
+                        rItem.maString = aStr;
+                    }
+
+                    switch (pCell->GetCellType())
+                    {
+                        case CELLTYPE_VALUE:
+                            rItem.mfValue = static_cast< ScValueCell*>(pCell)->GetValue();
+                            rItem.mbIsValue = true;
+                        break;
+                        case CELLTYPE_FORMULA:
+                        {
+                            ScFormulaCell* pFCell = static_cast<ScFormulaCell*>(pCell);
+                            USHORT nErr = pFCell->GetErrCode();
+                            if (nErr)
+                                break;
+
+                            if (pFCell->HasValueData())
+                                rItem.mfValue = pFCell->GetValue();
+                                rItem.mbIsValue = true;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // convert the hidden cell list to sequence.
+    m_aHiddenValues.realloc(nHiddenValueCount);
+    sal_Int32* pArr = m_aHiddenValues.getArray();
+    ::std::list<sal_Int32>::const_iterator itr = aHiddenValues.begin(), itrEnd = aHiddenValues.end();
+    for (;itr != itrEnd; ++itr, ++pArr)
+        *pArr = *itr;
+}
 
 void ScChart2DataSequence::Notify( SfxBroadcaster& /*rBC*/, const SfxHint& rHint)
 {
@@ -1389,7 +1500,8 @@ void ScChart2DataSequence::Notify( SfxBroadcaster& /*rBC*/, const SfxHint& rHint
             // delayed broadcast as in ScCellRangesBase
 
             if ( m_bGotDataChangedHint && m_pDocument )
-            {
+            {        
+                m_aDataArray.clear();
                 lang::EventObject aEvent;
                 aEvent.Source.set((cppu::OWeakObject*)this);
 
@@ -1452,7 +1564,7 @@ IMPL_LINK( ScChart2DataSequence, ValueListenerHdl, SfxHint*, pHint )
         //  in the range are notified. So only a flag is set that is checked when
         //  SFX_HINT_DATACHANGED is received.
 
-        m_bGotDataChangedHint = TRUE;
+        setDataChangedHint(true);
     }
     return 0;
 }
@@ -1465,72 +1577,19 @@ uno::Sequence< uno::Any> SAL_CALL ScChart2DataSequence::getData()
     if ( !m_pDocument)
         throw uno::RuntimeException();
 
-    const ScDocument* pDoc = m_pDocument;
-    sal_Int32 nCount = 0;
-    ScRangePtr p;
-    for ( p = m_xRanges->First(); p; p = m_xRanges->Next())
+    BuildDataArray();
+    sal_Int32 nCount = m_aDataArray.size();
+    uno::Sequence<uno::Any> aSeq(nCount);
+    uno::Any* pArr = aSeq.getArray();
+    ::std::list<Item>::const_iterator itr = m_aDataArray.begin(), itrEnd = m_aDataArray.end();
+    for (; itr != itrEnd; ++itr, ++pArr)
     {
-        nCount += sal_Int32(p->aEnd.Col() - p->aStart.Col() + 1) *
-            (p->aEnd.Row() - p->aStart.Row() + 1) * (p->aEnd.Tab() -
-                                                     p->aStart.Tab() + 1);
+        if (itr->mbIsValue)
+            *pArr <<= itr->mfValue;
+        else
+            *pArr <<= itr->maString;
     }
-    uno::Sequence< uno::Any> aSeq( nCount);
-    uno::Any * pArr = aSeq.getArray();
-    nCount = 0;
-    for ( p = m_xRanges->First(); p; p = m_xRanges->Next())
-    {
-        // TODO: use DocIter?
-        ScAddress aAdr( p->aStart);
-        for ( SCTAB nTab = p->aStart.Tab(); nTab <= p->aEnd.Tab(); ++nTab)
-        {
-            aAdr.SetTab( nTab);
-            for ( SCCOL nCol = p->aStart.Col(); nCol <= p->aEnd.Col(); ++nCol)
-            {
-                aAdr.SetCol( nCol);
-                for ( SCROW nRow = p->aStart.Row(); nRow <= p->aEnd.Row();
-                        ++nRow)
-                {
-                    aAdr.SetRow( nRow);
-                    ScBaseCell* pCell = pDoc->GetCell( aAdr);
-                    if ( pCell)
-                    {
-                        switch ( pCell->GetCellType())
-                        {
-                            case CELLTYPE_VALUE:
-                                pArr[nCount] <<= static_cast< ScValueCell*>(
-                                        pCell)->GetValue();
-                            break;
-                            case CELLTYPE_FORMULA:
-                            {
-                                ScFormulaCell* pFCell = static_cast<
-                                    ScFormulaCell*>( pCell);
-                                USHORT nErr = pFCell->GetErrCode();
-                                if  ( !nErr)
-                                {
-                                    if ( pFCell->HasValueData())
-                                        pArr[nCount] <<= pFCell->GetValue();
-                                    else
-                                    {
-                                        String aStr;
-                                        pFCell->GetString( aStr);
-                                        pArr[nCount] <<= ::rtl::OUString(
-                                                aStr);
-                                    }
-                                }
-                            }
-                            default:
-                            {
-                                if ( pCell->HasStringData())
-                                    pArr[nCount] <<= ::rtl::OUString(pCell->GetStringData());
 
-                            }
-                        }
-                    }
-                    ++nCount;
-                }
-            }
-        }
-    }
     return aSeq;
 }
 
@@ -1543,67 +1602,18 @@ uno::Sequence< double > SAL_CALL ScChart2DataSequence::getNumericalData()
     if ( !m_pDocument)
         throw uno::RuntimeException();
 
+    BuildDataArray();
+
     double fNAN;
-    ::rtl::math::setNan( & fNAN );
+    ::rtl::math::setNan(&fNAN);
 
-    const ScDocument* pDoc = m_pDocument;
-    sal_Int32 nCount = 0;
-    ScRangePtr p;
-    for ( p = m_xRanges->First(); p; p = m_xRanges->Next())
-    {
-        nCount += sal_Int32(p->aEnd.Col() - p->aStart.Col() + 1) *
-            (p->aEnd.Row() - p->aStart.Row() + 1) * (p->aEnd.Tab() -
-                                                     p->aStart.Tab() + 1);
-    }
-    uno::Sequence< double > aSeq( nCount);
+    sal_Int32 nCount = m_aDataArray.size();
+    uno::Sequence<double> aSeq(nCount);
     double* pArr = aSeq.getArray();
-    nCount = 0;
-    for ( p = m_xRanges->First(); p; p = m_xRanges->Next())
-    {
-        // TODO: use DocIter?
-        ScAddress aAdr( p->aStart);
-        for ( SCTAB nTab = p->aStart.Tab(); nTab <= p->aEnd.Tab(); ++nTab)
-        {
-            aAdr.SetTab( nTab);
-            for ( SCCOL nCol = p->aStart.Col(); nCol <= p->aEnd.Col(); ++nCol)
-            {
-                aAdr.SetCol( nCol);
-                for ( SCROW nRow = p->aStart.Row(); nRow <= p->aEnd.Row();
-                        ++nRow)
-                {
-                    pArr[nCount] = fNAN;
+    ::std::list<Item>::const_iterator itr = m_aDataArray.begin(), itrEnd = m_aDataArray.end();
+    for (; itr != itrEnd; ++itr, ++pArr)
+        *pArr = itr->mbIsValue ? itr->mfValue : fNAN;
 
-                    aAdr.SetRow( nRow);
-                    ScBaseCell* pCell = pDoc->GetCell( aAdr);
-                    if ( pCell)
-                    {
-                        switch ( pCell->GetCellType())
-                        {
-                            case CELLTYPE_VALUE:
-                                pArr[nCount] = static_cast< ScValueCell*>(
-                                        pCell)->GetValue();
-                            break;
-                            case CELLTYPE_FORMULA:
-                            {
-                                ScFormulaCell* pFCell = static_cast<
-                                    ScFormulaCell*>( pCell);
-                                USHORT nErr = pFCell->GetErrCode();
-                                if  ( !nErr)
-                                {
-                                    if ( pFCell->HasValueData())
-                                        pArr[nCount] = pFCell->GetValue();
-                                }
-                            }
-                            default:
-                                // nothing
-                                break;
-                        }
-                    }
-                    ++nCount;
-                }
-            }
-        }
-    }
     return aSeq;
 }
 
@@ -1615,49 +1625,15 @@ uno::Sequence< rtl::OUString > SAL_CALL ScChart2DataSequence::getTextualData(  )
     if ( !m_pDocument)
         throw uno::RuntimeException();
 
-    sal_Int32 nCount = 0;
-    ScRangePtr p;
-    for ( p = m_xRanges->First(); p; p = m_xRanges->Next())
-    {
-        nCount += sal_Int32(p->aEnd.Col() - p->aStart.Col() + 1) *
-            (p->aEnd.Row() - p->aStart.Row() + 1) * (p->aEnd.Tab() -
-                                                     p->aStart.Tab() + 1);
-    }
-    uno::Sequence< rtl::OUString > aSeq( nCount);
+    BuildDataArray();
+
+    sal_Int32 nCount = m_aDataArray.size();
+    uno::Sequence<rtl::OUString> aSeq(nCount);
     rtl::OUString* pArr = aSeq.getArray();
-    nCount = 0;
-	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( lcl_GetSpreadSheetDocument( m_pDocument ));
-	if ( xSpreadDoc.is() )
-	{
-		uno::Reference<container::XIndexAccess> xIndex( xSpreadDoc->getSheets(), uno::UNO_QUERY );
-		if ( xIndex.is() )
-		{
-            uno::Reference< table::XCellRange > xSheet;
-            for ( p = m_xRanges->First(); p; p = m_xRanges->Next())
-            {
-                // TODO: use DocIter?
-                table::CellAddress aStart, aEnd;
-                ScUnoConversion::FillApiAddress( aStart, p->aStart );
-                ScUnoConversion::FillApiAddress( aEnd, p->aEnd );
-                for ( sal_Int16 nSheet = aStart.Sheet; nSheet <= aEnd.Sheet; ++nSheet)
-                {
-                    xSheet.set(xIndex->getByIndex(nSheet), uno::UNO_QUERY);
-                    for ( sal_Int32 nCol = aStart.Column; nCol <= aEnd.Column; ++nCol)
-                    {
-                        for ( sal_Int32 nRow = aStart.Row; nRow <= aEnd.Row; ++nRow)
-                        {
-                            uno::Reference< text::XText > xText(xSheet->getCellByPosition(nCol, nRow), uno::UNO_QUERY);
-                            if (xText.is())
-                            {
-                                pArr[nCount] = xText->getString();
-                                ++nCount;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
+    ::std::list<Item>::const_iterator itr = m_aDataArray.begin(), itrEnd = m_aDataArray.end();
+    for (; itr != itrEnd; ++itr, ++pArr)
+        *pArr = itr->maString;
+
     return aSeq;
 }
 
@@ -1882,11 +1858,22 @@ void SAL_CALL ScChart2DataSequence::addModifyListener( const uno::Reference< uti
 		if (!m_pValueListener)
 			m_pValueListener = new ScLinkListener( LINK( this, ScChart2DataSequence, ValueListenerHdl ) );
 
+        if (!m_pHiddenListener.get())
+            m_pHiddenListener.reset(new HiddenRangeListener(*this));
+
         if( m_pDocument )
         {
             ULONG nCount = m_xRanges->Count();
             for (ULONG i=0; i<nCount; i++)
-                m_pDocument->StartListeningArea( *m_xRanges->GetObject(i), m_pValueListener );
+            {
+                ScRange aRange = *m_xRanges->GetObject(i);    
+                m_pDocument->StartListeningArea( aRange, m_pValueListener );
+                ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+                if (pCLC)
+                    pCLC->StartListeningHiddenRange(aRange, m_pHiddenListener.get());
+
+                markRangeDirty(aRange);
+            }
         }
 
 		acquire();	// don't lose this object (one ref for all listeners)
@@ -1918,6 +1905,13 @@ void SAL_CALL ScChart2DataSequence::removeModifyListener( const uno::Reference<
 				if (m_pValueListener)
 					m_pValueListener->EndListeningAll();
 
+                if (m_pHiddenListener.get() && m_pDocument)
+                {
+                    ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+                    if (pCLC)
+                        pCLC->EndListeningHiddenRange(m_pHiddenListener.get());
+                }
+
 				release();		// release the ref for the listeners
 			}
 
@@ -1973,6 +1967,13 @@ uno::Any SAL_CALL ScChart2DataSequence::getPropertyValue(
         aRet <<= m_aRole;
     else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ISHIDDEN)))
         aRet <<= m_bHidden;
+    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM(SC_UNONAME_HIDDENVALUES)))
+    {
+        // This property is read-only thus cannot be set externally via 
+        // setPropertyValue(...).
+        BuildDataArray();
+        aRet <<= m_aHiddenValues;
+    }
     else
         throw beans::UnknownPropertyException();
     // TODO: support optional properties
@@ -2027,6 +2028,42 @@ void SAL_CALL ScChart2DataSequence::removeVetoableChangeListener(
     OSL_ENSURE( false, "Not yet implemented" );
 }
 
+void ScChart2DataSequence::markRangeDirty(const ScRange& rRange) const
+{
+    if (!m_pDocument)
+        return;
+
+    const ScAddress &s = rRange.aStart, &e = rRange.aEnd;
+    SCTAB nTab1 = s.Tab(), nTab2 = e.Tab();
+    SCCOL nCol1 = s.Col(), nCol2 = e.Col();
+    SCROW nRow1 = s.Row(), nRow2 = e.Row();
+    for (SCTAB nTab = nTab1; nTab <= nTab2; ++nTab)
+    {
+        for (SCCOL nCol = nCol1; nCol <= nCol2; ++nCol)
+        {
+            for (SCROW nRow = nRow1; nRow <= nRow2; ++nRow)
+            {
+                ScAddress aAddr(nCol, nRow, nTab);
+                ScBaseCell* pBaseCell = m_pDocument->GetCell(aAddr);
+                if (!pBaseCell || pBaseCell->GetCellType() != CELLTYPE_FORMULA)
+                    continue;
+
+                ScFormulaCell* pFCell = static_cast<ScFormulaCell*>(pBaseCell);
+                ScTokenArray* pArray = pFCell->GetCode();
+                if (!pArray)
+                    continue;
+
+                pFCell->SetDirty();
+            }
+        }
+    }
+}
+
+void ScChart2DataSequence::setDataChangedHint(bool b)
+{
+    m_bGotDataChangedHint = b;
+}
+
 // XUnoTunnel
 
 // sal_Int64 SAL_CALL ScChart2DataSequence::getSomething(
