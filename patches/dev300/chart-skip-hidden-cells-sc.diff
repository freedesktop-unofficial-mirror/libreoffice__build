diff --git sc/inc/chart2uno.hxx sc/inc/chart2uno.hxx
index 964428e..f6ae3fd 100644
--- sc/inc/chart2uno.hxx
+++ sc/inc/chart2uno.hxx
@@ -35,6 +35,7 @@
 #include "rangelst.hxx"
 #include "externalrefmgr.hxx"
 #include "token.hxx"
+#include "chartlis.hxx"
 
 #include <svtools/lstner.hxx>
 #include <com/sun/star/chart/ChartDataRowSource.hpp>
@@ -54,7 +55,6 @@
 // #include <com/sun/star/lang/XUnoTunnel.hpp>
 // #endif
 #include <cppuhelper/implbase2.hxx>
-#include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
 #include <cppuhelper/implbase6.hxx>
 #include <cppuhelper/implbase7.hxx>
@@ -74,9 +74,10 @@ class ScDocument;
 // DataProvider ==============================================================
 
 class ScChart2DataProvider : public
-                ::cppu::WeakImplHelper3<
+                ::cppu::WeakImplHelper4<
                     ::com::sun::star::chart2::data::XDataProvider,
                     ::com::sun::star::chart2::data::XRangeXMLConversion,
+                    ::com::sun::star::beans::XPropertySet,
                     ::com::sun::star::lang::XServiceInfo>,
                 SfxListener
 {
@@ -125,6 +126,59 @@ public:
     virtual ::rtl::OUString SAL_CALL convertRangeFromXML( const ::rtl::OUString& sXMLRange )
         throw ( ::com::sun::star::uno::RuntimeException, ::com::sun::star::lang::IllegalArgumentException );
 
+    // XPropertySet ----------------------------------------------------------
+
+    virtual ::com::sun::star::uno::Reference<
+        ::com::sun::star::beans::XPropertySetInfo> SAL_CALL
+        getPropertySetInfo() throw( ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL setPropertyValue(
+            const ::rtl::OUString& rPropertyName,
+            const ::com::sun::star::uno::Any& rValue)
+        throw( ::com::sun::star::beans::UnknownPropertyException,
+                ::com::sun::star::beans::PropertyVetoException,
+                ::com::sun::star::lang::IllegalArgumentException,
+                ::com::sun::star::lang::WrappedTargetException,
+                ::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::uno::Any SAL_CALL getPropertyValue(
+            const ::rtl::OUString& rPropertyName)
+        throw( ::com::sun::star::beans::UnknownPropertyException,
+                ::com::sun::star::lang::WrappedTargetException,
+                ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL addPropertyChangeListener(
+            const ::rtl::OUString& rPropertyName,
+            const ::com::sun::star::uno::Reference<
+            ::com::sun::star::beans::XPropertyChangeListener>& xListener)
+        throw( ::com::sun::star::beans::UnknownPropertyException,
+                ::com::sun::star::lang::WrappedTargetException,
+                ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL removePropertyChangeListener(
+            const ::rtl::OUString& rPropertyName,
+            const ::com::sun::star::uno::Reference<
+            ::com::sun::star::beans::XPropertyChangeListener>& rListener)
+        throw( ::com::sun::star::beans::UnknownPropertyException,
+                ::com::sun::star::lang::WrappedTargetException,
+                ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL addVetoableChangeListener(
+            const ::rtl::OUString& rPropertyName,
+            const ::com::sun::star::uno::Reference<
+            ::com::sun::star::beans::XVetoableChangeListener>& rListener)
+        throw( ::com::sun::star::beans::UnknownPropertyException,
+                ::com::sun::star::lang::WrappedTargetException,
+                ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL removeVetoableChangeListener(
+            const ::rtl::OUString& rPropertyName,
+            const ::com::sun::star::uno::Reference<
+            ::com::sun::star::beans::XVetoableChangeListener>& rListener)
+        throw( ::com::sun::star::beans::UnknownPropertyException,
+                ::com::sun::star::lang::WrappedTargetException,
+                ::com::sun::star::uno::RuntimeException);
+
     // XServiceInfo ----------------------------------------------------------
 
     virtual ::rtl::OUString SAL_CALL getImplementationName() throw(
@@ -158,6 +212,8 @@ private:
 private:
 
     ScDocument*                 m_pDocument;
+    SfxItemPropertySet          m_aPropSet;
+    sal_Bool                    m_bIncludeHiddenCells;
 };
 
 
@@ -287,7 +343,7 @@ class ScChart2DataSequence : public
 public:
     explicit ScChart2DataSequence( ScDocument* pDoc,
             const com::sun::star::uno::Reference< com::sun::star::chart2::data::XDataProvider >& xDP,
-            ::std::vector<ScSharedTokenRef>* pTokens);
+            ::std::vector<ScSharedTokenRef>* pTokens, bool bIncludeHiddenCells );
 
     virtual ~ScChart2DataSequence();
     virtual void Notify( SfxBroadcaster& rBC, const SfxHint& rHint );
@@ -404,6 +460,9 @@ public:
 // 	static ScChart2DataSequence* getImplementation( const com::sun::star::uno::Reference<
 // 									com::sun::star::uno::XInterface> xObj );
 
+private:
+    void setDataChangedHint(bool b);
+
     // Implementation --------------------------------------------------------
 
     void    RefChanged();
@@ -461,12 +520,24 @@ private:
         Item();
     };
 
+    class HiddenRangeListener : public ScChartHiddenRangeListener
+    {
+    public:
+        HiddenRangeListener(ScChart2DataSequence& rParent);
+        virtual ~HiddenRangeListener();
+
+        virtual void notify();
+
+    private:
+        ScChart2DataSequence& mrParent;
+    };
+
     ::std::list<Item>           m_aDataArray;
     ::com::sun::star::uno::Sequence<sal_Int32>  m_aHiddenValues;
 
     // properties
     ::com::sun::star::chart2::data::DataSequenceRole  m_aRole;
-    sal_Bool                    m_bHidden;
+    sal_Bool                    m_bIncludeHiddenCells;
 
     // internals
     typedef ::std::auto_ptr< ::std::vector<ScSharedTokenRef> >  TokenListPtr;
@@ -481,6 +552,7 @@ private:
     com::sun::star::uno::Reference < com::sun::star::chart2::data::XDataProvider > m_xDataProvider;
 	SfxItemPropertySet		    m_aPropSet;
 
+    ::std::auto_ptr<HiddenRangeListener> m_pHiddenListener;
     ScLinkListener*             m_pValueListener;
     XModifyListenerArr_Impl     m_aValueListeners;
 
@@ -625,7 +697,7 @@ private:
 
     // properties
     ::com::sun::star::chart2::data::DataSequenceRole  m_aRole;
-    sal_Bool                    m_bHidden;
+    sal_Bool                    m_bIncludeHiddenCells;
     // internals
     ScRangeListRef              m_xRanges;
     ScDocument*                 m_pDocument;
diff --git sc/inc/chartlis.hxx sc/inc/chartlis.hxx
index e6f2d63..1bc4f6f 100644
--- sc/inc/chartlis.hxx
+++ sc/inc/chartlis.hxx
@@ -41,6 +41,7 @@
 
 #include <memory>
 #include <vector>
+#include <list>
 #include <hash_set>
 
 class ScDocument;
@@ -131,9 +132,31 @@ public:
 						{ return !operator==( r ); }
 };
 
+// ============================================================================
+
+class ScChartHiddenRangeListener
+{
+public:
+    ScChartHiddenRangeListener();
+    virtual ~ScChartHiddenRangeListener();
+    virtual void notify() = 0;
+};
+
+// ============================================================================
+
 class ScChartListenerCollection : public ScStrCollection
 {
+public:
+    struct RangeListenerItem
+    {
+        ScRange                     maRange;
+        ScChartHiddenRangeListener* mpListener;
+        explicit RangeListenerItem(const ScRange& rRange, ScChartHiddenRangeListener* p);
+    };
+
 private:
+    ::std::list<RangeListenerItem> maHiddenListeners;
+
 	Timer			aTimer;
 	ScDocument*		pDoc;
 
@@ -173,6 +196,24 @@ public:
     void            UpdateChartsContainingTab( SCTAB nTab );
 
 	BOOL			operator==( const ScChartListenerCollection& );
+
+    /** 
+     * Start listening on hide/show change within specified cell range.  A 
+     * single listener may listen on multiple ranges when the caller passes 
+     * the same pointer multiple times with different ranges. 
+     *  
+     * Note that the caller is responsible for managing the life-cycle of the 
+     * listener instance. 
+     */
+    void            StartListeningHiddenRange( const ScRange& rRange, 
+                                               ScChartHiddenRangeListener* pListener );
+
+    /** 
+     * Remove all ranges associated with passed listener instance from the 
+     * list of hidden range listeners.  This does not delete the passed 
+     * listener instance. 
+     */
+    void            EndListeningHiddenRange( ScChartHiddenRangeListener* pListener );
 };
 
 
diff --git sc/inc/unonames.hxx sc/inc/unonames.hxx
index 504ff00..be9e07b 100644
--- sc/inc/unonames.hxx
+++ sc/inc/unonames.hxx
@@ -610,8 +610,9 @@
 #define SC_UNO_COMPILEFAP           "CompileFAP"
 
 // Chart2
-#define SC_UNONAME_ISHIDDEN         "IsHidden"
-#define SC_UNONAME_ROLE             "Role"
+#define SC_UNONAME_ROLE                 "Role"
+#define SC_UNONAME_HIDDENVALUES         "HiddenValues"
+#define SC_UNONAME_INCLUDEHIDDENCELLS   "IncludeHiddenCells"
 #define SC_UNONAME_HIDDENVALUES     "HiddenValues"
 
 // Solver
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index 9aef9cc..388a2e2 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -633,8 +633,6 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
 		{
 			//	Charts muessen beim Ein-/Ausblenden angepasst werden
 			ScChartListenerCollection* pCharts = pDestTab->pDocument->GetChartListenerCollection();
-			if ( pCharts && !pCharts->GetCount() )
-				pCharts = NULL;
 
 			if (nRow1==0 && nRow2==MAXROW && pColWidth && pDestTab->pColWidth)
 				for (SCCOL i=nCol1; i<=nCol2; i++)
@@ -2237,7 +2235,7 @@ void ScTable::ShowCol(SCCOL nCol, BOOL bShow)
 				SetDrawPageSize();
 
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( nCol, 0, nTab, nCol, MAXROW, nTab ));
 		}
 	}
@@ -2274,7 +2272,7 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
 				SetDrawPageSize();
 
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
 		}
 	}
@@ -2315,7 +2313,7 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
 		if (bWasVis != bShow)
 		{
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
 
 			if (pOutlineTable)
@@ -2363,7 +2361,7 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 		if ( bChanged )
 		{
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
 		}
 
@@ -2415,7 +2413,7 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 		if ( bChanged )
 		{
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
-			if ( pCharts && pCharts->GetCount() )
+			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
 		}
 
diff --git sc/source/core/tool/chartlis.cxx sc/source/core/tool/chartlis.cxx
index 8d3436a..e09b082 100644
--- sc/source/core/tool/chartlis.cxx
+++ sc/source/core/tool/chartlis.cxx
@@ -42,6 +42,7 @@
 
 using namespace com::sun::star;
 using ::std::vector;
+using ::std::list;
 using ::std::hash_set;
 using ::std::auto_ptr;
 using ::std::unary_function;
@@ -454,9 +455,24 @@ BOOL ScChartListener::operator==( const ScChartListener& r )
     return *mpTokens == *r.mpTokens;
 }
 
+// ============================================================================
+
+ScChartHiddenRangeListener::ScChartHiddenRangeListener()
+{
+}
+
+ScChartHiddenRangeListener::~ScChartHiddenRangeListener()
+{
+    // empty d'tor
+}
 
 // === ScChartListenerCollection ======================================
 
+ScChartListenerCollection::RangeListenerItem::RangeListenerItem(const ScRange& rRange, ScChartHiddenRangeListener* p) :
+    maRange(rRange), mpListener(p)
+{
+}
+
 ScChartListenerCollection::ScChartListenerCollection( ScDocument* pDocP ) :
 	ScStrCollection( 4, 4, FALSE ),
 	pDoc( pDocP )
@@ -643,6 +659,14 @@ void ScChartListenerCollection::SetRangeDirty( const ScRange& rRange )
 	}
 	if ( bDirty )
 		StartTimer();
+
+    // New hidden range listener implementation
+    for (list<RangeListenerItem>::iterator itr = maHiddenListeners.begin(), itrEnd = maHiddenListeners.end();
+          itr != itrEnd; ++itr)
+    {
+        if (itr->maRange.Intersects(rRange))
+            itr->mpListener->notify();
+    }
 }
 
 
@@ -682,6 +706,34 @@ BOOL ScChartListenerCollection::operator==( const ScChartListenerCollection& r )
 	return TRUE;
 }
 
+void ScChartListenerCollection::StartListeningHiddenRange( const ScRange& rRange, ScChartHiddenRangeListener* pListener )
+{
+    RangeListenerItem aItem(rRange, pListener);
+    maHiddenListeners.push_back(aItem);
+}
+
+namespace {
+
+struct MatchListener : public ::std::unary_function<
+        ScChartListenerCollection::RangeListenerItem, bool>
+{
+    MatchListener(const ScChartHiddenRangeListener* pMatch) :
+        mpMatch(pMatch)
+    {
+    }
+
+    bool operator() (const ScChartListenerCollection::RangeListenerItem& rItem) const
+    {
+        return mpMatch == rItem.mpListener;
+    }
 
+private:
+    const ScChartHiddenRangeListener* mpMatch;
+};
 
+}
+void ScChartListenerCollection::EndListeningHiddenRange( ScChartHiddenRangeListener* pListener )
+{
+    maHiddenListeners.remove_if(MatchListener(pListener));
+}
 
diff --git sc/source/core/tool/chartpos.cxx sc/source/core/tool/chartpos.cxx
index 5f46ab3..a5ca8c3 100644
--- sc/source/core/tool/chartpos.cxx
+++ sc/source/core/tool/chartpos.cxx
@@ -307,27 +307,18 @@ void ScChartPositioner::CheckColRowHeaders()
 	if ( aRangeListRef->Count() == 1 )
 	{
 		aRangeListRef->First()->GetVars( nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 );
-		// Beschriftungen auch nach hidden Cols/Rows finden
-		while ( nCol1 <= nCol2 && (pDocument->GetColFlags(
-				nCol1, nTab1) & CR_HIDDEN) != 0 )
-			nCol1++;
-		while ( nRow1 <= nRow2 && (pDocument->GetRowFlags(
-				nRow1, nTab1) & CR_HIDDEN) != 0 )
-			nRow1++;
 		if ( nCol1 > nCol2 || nRow1 > nRow2 )
 			bColStrings = bRowStrings = FALSE;
 		else
 		{
 			for (iCol=nCol1; iCol<=nCol2 && bColStrings; iCol++)
 			{
-				if ( iCol==nCol1 || (pDocument->GetColFlags( iCol, nTab1) & CR_HIDDEN) == 0 )
-					if (pDocument->HasValueData( iCol, nRow1, nTab1 ))
+				if (pDocument->HasValueData( iCol, nRow1, nTab1 ))
 						bColStrings = FALSE;
 			}
 			for (iRow=nRow1; iRow<=nRow2 && bRowStrings; iRow++)
 			{
-				if ( iRow==nRow1 || (pDocument->GetRowFlags( iRow, nTab1) & CR_HIDDEN) == 0 )
-					if (pDocument->HasValueData( nCol1, iRow, nTab1 ))
+				if (pDocument->HasValueData( nCol1, iRow, nTab1 ))
 						bRowStrings = FALSE;
 			}
 		}
@@ -341,43 +332,22 @@ void ScChartPositioner::CheckColRowHeaders()
 		{
 			pR->GetVars( nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 );
 			BOOL bTopRow = (nRow1 == nStartRow);
-			BOOL bHidOk;
 			if ( bRowStrings && (bVert || nCol1 == nStartCol) )
 			{	// NONE oder ROWS: RowStrings in jeder Selektion moeglich
 				// COLS oder BOTH: nur aus der ersten Spalte
-				while ( nCol1 <= nCol2 && (pDocument->GetColFlags(
-						nCol1, nTab1) & CR_HIDDEN) != 0 )
-					nCol1++;
-				while ( nRow1 <= nRow2 && (pDocument->GetRowFlags(
-						nRow1, nTab1) & CR_HIDDEN) != 0 )
-					nRow1++;
 				if ( nCol1 <= nCol2 )
 					for (iRow=nRow1; iRow<=nRow2 && bRowStrings; iRow++)
 					{
-						if ( iRow==nRow1 || (pDocument->GetRowFlags( iRow, nTab1) & CR_HIDDEN) == 0 )
-							if (pDocument->HasValueData( nCol1, iRow, nTab1 ))
+						if (pDocument->HasValueData( nCol1, iRow, nTab1 ))
 								bRowStrings = FALSE;
 					}
-				bHidOk = TRUE;
 			}
-			else
-				bHidOk = FALSE;
 			if ( bColStrings && bTopRow )
 			{	// ColStrings nur aus der ersten Zeile
-				if ( !bHidOk )
-				{
-					while ( nCol1 <= nCol2 && (pDocument->GetColFlags(
-							nCol1, nTab1) & CR_HIDDEN) != 0 )
-						nCol1++;
-					while ( nRow1 <= nRow2 && (pDocument->GetRowFlags(
-							nRow1, nTab1) & CR_HIDDEN) != 0 )
-						nRow1++;
-				}
 				if ( nRow1 <= nRow2 )
 					for (iCol=nCol1; iCol<=nCol2 && bColStrings; iCol++)
 					{
-						if ( iCol==nCol1 || (pDocument->GetColFlags( iCol, nTab1) & CR_HIDDEN) == 0 )
-							if (pDocument->HasValueData( iCol, nRow1, nTab1 ))
+						if (pDocument->HasValueData( iCol, nRow1, nTab1 ))
 								bColStrings = FALSE;
 					}
 			}
@@ -439,40 +409,34 @@ void ScChartPositioner::CreatePositionMap()
                     static_cast<ULONG>(nCol1));
 			for ( nCol = nCol1; nCol <= nCol2; ++nCol, ++nInsCol )
 			{
-				if ( (pDocument->GetColFlags( nCol, nTab) & CR_HIDDEN) == 0 )
-				{
-					if ( bNoGlue || eGlue == SC_CHARTGLUE_ROWS )
-					{	// meistens gleiche Cols
-						if ( (pCol = (Table*) pCols->Get( nInsCol ))==NULL )
-						{
-							pCols->Insert( nInsCol, pNewRowTable );
-							pCol = pNewRowTable;
-							pNewRowTable = new Table;
-						}
+				if ( bNoGlue || eGlue == SC_CHARTGLUE_ROWS )
+				{	// meistens gleiche Cols
+					if ( (pCol = (Table*) pCols->Get( nInsCol ))==NULL )
+					{
+						pCols->Insert( nInsCol, pNewRowTable );
+						pCol = pNewRowTable;
+						pNewRowTable = new Table;
 					}
-					else
-					{	// meistens neue Cols
-						if ( pCols->Insert( nInsCol, pNewRowTable ) )
-						{
-							pCol = pNewRowTable;
-							pNewRowTable = new Table;
-						}
-						else
-							pCol = (Table*) pCols->Get( nInsCol );
+				}
+				else
+				{	// meistens neue Cols
+					if ( pCols->Insert( nInsCol, pNewRowTable ) )
+					{
+						pCol = pNewRowTable;
+						pNewRowTable = new Table;
 					}
-					// bei anderer Tabelle wurde bereits neuer ColKey erzeugt,
-					// die Zeilen muessen fuer's Dummy fuellen gleich sein!
-					ULONG nInsRow = (bNoGlue ? nNoGlueRow : nRow1);
-					for ( nRow = nRow1; nRow <= nRow2; nRow++, nInsRow++ )
+					else
+						pCol = (Table*) pCols->Get( nInsCol );
+				}
+				// bei anderer Tabelle wurde bereits neuer ColKey erzeugt,
+				// die Zeilen muessen fuer's Dummy fuellen gleich sein!
+				ULONG nInsRow = (bNoGlue ? nNoGlueRow : nRow1);
+				for ( nRow = nRow1; nRow <= nRow2; nRow++, nInsRow++ )
+				{
+					if ( pCol->Insert( nInsRow, pNewAddress ) )
 					{
-						if ( (pDocument->GetRowFlags( nRow, nTab) & CR_HIDDEN) == 0 )
-						{
-							if ( pCol->Insert( nInsRow, pNewAddress ) )
-							{
-								pNewAddress->Set( nCol, nRow, nTab );
-								pNewAddress = new ScAddress;
-							}
-						}
+						pNewAddress->Set( nCol, nRow, nTab );
+						pNewAddress = new ScAddress;
 					}
 				}
 			}
diff --git sc/source/filter/excel/xechart.cxx sc/source/filter/excel/xechart.cxx
index 211aed3..89fed49 100644
--- sc/source/filter/excel/xechart.cxx
+++ sc/source/filter/excel/xechart.cxx
@@ -2739,7 +2739,7 @@ XclExpChChart::XclExpChChart( const XclExpRoot& rRoot,
     maRect.mnWidth = static_cast< sal_Int32 >( aPtSize.Width() << 16 );
     maRect.mnHeight = static_cast< sal_Int32 >( aPtSize.Height() << 16 );
 
-    // global chart properties
+    // global chart properties (default values)
     ::set_flag( maProps.mnFlags, EXC_CHPROPS_MANSERIES );
     ::set_flag( maProps.mnFlags, EXC_CHPROPS_SHOWVISCELLS, false );
     maProps.mnEmptyMode = EXC_CHPROPS_EMPTY_SKIP;
@@ -2750,6 +2750,13 @@ XclExpChChart::XclExpChChart( const XclExpRoot& rRoot,
 
     if( xChartDoc.is() )
     {
+        Reference< XDiagram > xDiagram = xChartDoc->getFirstDiagram();
+
+        // global chart properties (only 'include hidden cells' attribute for now)
+        ScfPropertySet aDiagramProp( xDiagram );
+        bool bIncludeHidden = aDiagramProp.GetBoolProperty( EXC_CHPROP_INCLUDEHIDDENCELLS );
+        ::set_flag( maProps.mnFlags,  EXC_CHPROPS_SHOWVISCELLS, !bIncludeHidden );
+
         // initialize API conversion (remembers xChartDoc internally)
         InitConversion( xChartDoc );
 
@@ -2762,7 +2769,6 @@ XclExpChChart::XclExpChChart( const XclExpRoot& rRoot,
         mxTitle = lclCreateTitle( GetChRoot(), xTitled, EXC_CHOBJLINK_TITLE );
 
         // diagrams (axes sets)
-        Reference< XDiagram > xDiagram = xChartDoc->getFirstDiagram();
         sal_uInt16 nFreeGroupIdx = mxPrimAxesSet->Convert( xDiagram, 0 );
         if( !mxPrimAxesSet->Is3dChart() )
             mxSecnAxesSet->Convert( xDiagram, nFreeGroupIdx );
diff --git sc/source/filter/excel/xichart.cxx sc/source/filter/excel/xichart.cxx
index 8364ccf..6d9bb9f 100644
--- sc/source/filter/excel/xichart.cxx
+++ sc/source/filter/excel/xichart.cxx
@@ -40,6 +40,7 @@
 #include <com/sun/star/drawing/ProjectionMode.hpp>
 #include <com/sun/star/drawing/ShadeMode.hpp>
 #include <com/sun/star/chart/ChartAxisPosition.hpp>
+#include <com/sun/star/chart/XChartDocument.hpp>
 #include <com/sun/star/chart2/XChartDocument.hpp>
 #include <com/sun/star/chart2/XDiagram.hpp>
 #include <com/sun/star/chart2/XCoordinateSystemContainer.hpp>
@@ -3306,7 +3307,7 @@ void XclImpChChart::ReadSubRecord( XclImpStream& rStrm )
             ReadChSeries( rStrm );
         break;
         case EXC_ID_CHPROPERTIES:
-            rStrm >> maProps.mnFlags >> maProps.mnEmptyMode;
+            ReadChProperties( rStrm );
         break;
         case EXC_ID_CHDEFAULTTEXT:
             ReadChDefaultText( rStrm );
@@ -3410,6 +3411,15 @@ void XclImpChChart::Convert( Reference< XChartDocument > xChartDoc, ScfProgressB
     if( xDiagram.is() && mxLegend.is() )
         xDiagram->setLegend( mxLegend->CreateLegend() );
 
+    // set the IncludeHiddenCells property via the old API as only this ensures that the data provider and al created sequences get this flag correctly
+    Reference< com::sun::star::chart::XChartDocument > xStandardApiChartDoc( xChartDoc, UNO_QUERY );
+    if( xStandardApiChartDoc.is() )
+    {
+        ScfPropertySet aDiagramProp( xStandardApiChartDoc->getDiagram() );
+        bool bShowVisCells = (maProps.mnFlags & EXC_CHPROPS_SHOWVISCELLS);
+        aDiagramProp.SetBoolProperty( EXC_CHPROP_INCLUDEHIDDENCELLS, !bShowVisCells  );
+    }
+
     // unlock the model
     FinishConversion( rProgress );
 }
@@ -3422,6 +3432,11 @@ void XclImpChChart::ReadChSeries( XclImpStream& rStrm )
     maSeries.push_back( xSeries );
 }
 
+void XclImpChChart::ReadChProperties( XclImpStream& rStrm )
+{
+    rStrm >> maProps.mnFlags >> maProps.mnEmptyMode;
+}
+
 void XclImpChChart::ReadChAxesSet( XclImpStream& rStrm )
 {
     XclImpChAxesSetRef xAxesSet( new XclImpChAxesSet( GetChRoot(), EXC_CHAXESSET_NONE ) );
diff --git sc/source/filter/inc/xichart.hxx sc/source/filter/inc/xichart.hxx
index 0ec9ca4..479f9e1 100644
--- sc/source/filter/inc/xichart.hxx
+++ sc/source/filter/inc/xichart.hxx
@@ -1347,6 +1347,8 @@ public:
 private:
     /** Reads a CHSERIES group (data series source and formatting). */
     void                ReadChSeries( XclImpStream& rStrm );
+    /** Reads a CHPROPERTIES record. */
+    void                ReadChProperties( XclImpStream& rStrm );
     /** Reads a CHAXESSET group (primary/secondary axes set). */
     void                ReadChAxesSet( XclImpStream& rStrm );
     /** Reads a CHTEXT group (chart title and series/point captions). */
diff --git sc/source/filter/inc/xlchart.hxx sc/source/filter/inc/xlchart.hxx
index b6ac422..c588154 100644
--- sc/source/filter/inc/xlchart.hxx
+++ sc/source/filter/inc/xlchart.hxx
@@ -97,6 +97,7 @@ namespace com { namespace sun { namespace star {
 #define EXC_CHPROP_FILLSTYLE                CREATE_OUSTRING( "FillStyle" )
 #define EXC_CHPROP_GAPWIDTHSEQ              CREATE_OUSTRING( "GapwidthSequence" )
 #define EXC_CHPROP_GEOMETRY3D               CREATE_OUSTRING( "Geometry3D" )
+#define EXC_CHPROP_INCLUDEHIDDENCELLS       CREATE_OUSTRING( "IncludeHiddenCells" )
 #define EXC_CHPROP_JAPANESE                 CREATE_OUSTRING( "Japanese" )
 #define EXC_CHPROP_LABEL                    CREATE_OUSTRING( "Label" )
 #define EXC_CHPROP_LABELPLACEMENT           CREATE_OUSTRING( "LabelPlacement" )
diff --git sc/source/ui/unoobj/chart2uno.cxx sc/source/ui/unoobj/chart2uno.cxx
index a042db1..5086a07 100644
--- sc/source/ui/unoobj/chart2uno.cxx
+++ sc/source/ui/unoobj/chart2uno.cxx
@@ -45,6 +45,7 @@
 #include "unoreflist.hxx"
 #include "compiler.hxx"
 #include "reftokenhelper.hxx"
+#include "chartlis.hxx"
 
 #include <sfx2/objsh.hxx>
 #include <tools/table.hxx>
@@ -89,12 +90,23 @@ using ::boost::shared_ptr;
 
 namespace
 {
+const SfxItemPropertyMap* lcl_GetDataProviderPropertyMap()
+{
+    static SfxItemPropertyMap aDataProviderPropertyMap_Impl[] =
+    {
+        {MAP_CHAR_LEN(SC_UNONAME_INCLUDEHIDDENCELLS), 0,		&getBooleanCppuType(),					0, 0 },
+        {0,0,0,0,0,0}
+    };
+    return aDataProviderPropertyMap_Impl;
+}
+
 const SfxItemPropertyMap* lcl_GetDataSequencePropertyMap()
 {
 	static SfxItemPropertyMap aDataSequencePropertyMap_Impl[] =
 	{
-		{MAP_CHAR_LEN(SC_UNONAME_ISHIDDEN), 0,		&getBooleanCppuType(),					0, 0 },
+		{MAP_CHAR_LEN(SC_UNONAME_HIDDENVALUES), 0, &getCppuType((uno::Sequence<sal_Int32>*)0 ),					0, 0 },
 		{MAP_CHAR_LEN(SC_UNONAME_ROLE), 0, &getCppuType((::com::sun::star::chart2::data::DataSequenceRole*)0),					0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_INCLUDEHIDDENCELLS), 0,		&getBooleanCppuType(),					0, 0 },
 		{0,0,0,0,0,0}
 	};
 	return aDataSequencePropertyMap_Impl;
@@ -656,9 +668,6 @@ void Chart2Positioner::createPositionMap()
                 (bNoGlue ? 0 : static_cast<sal_uInt32>(nCol1));
             for (SCCOL nCol = nCol1; nCol <= nCol2; ++nCol, ++nInsCol)
             {
-                if ((mpDoc->GetColFlags(nCol, nTab) & CR_HIDDEN) != 0)
-                    continue;
-
                 if (bNoGlue || meGlue == GLUETYPE_ROWS)
                 {
                     pCol = static_cast<Table*>(pCols->Get(nInsCol));
@@ -683,9 +692,6 @@ void Chart2Positioner::createPositionMap()
                 sal_uInt32 nInsRow = static_cast<sal_uInt32>(bNoGlue ? nNoGlueRow : nRow1);
                 for (SCROW nRow = nRow1; nRow <= nRow2; ++nRow, ++nInsRow)
                 {
-                    if ((mpDoc->GetRowFlags(nRow, nTab) & CR_HIDDEN) != 0)
-                        continue;
-
                     ScSingleRefData aCellData;
                     aCellData.InitFlags();
                     aCellData.SetFlag3D(true);
@@ -966,6 +972,8 @@ void lcl_convertTokenToString(OUString& rStr, const ScSharedTokenRef& rToken, Sc
 
 ScChart2DataProvider::ScChart2DataProvider( ScDocument* pDoc )
     : m_pDocument( pDoc)
+    , m_aPropSet(lcl_GetDataProviderPropertyMap())
+    , m_bIncludeHiddenCells( sal_True)
 {
     if ( m_pDocument )
         m_pDocument->AddUnoObject( *this);
@@ -1498,7 +1506,7 @@ ScChart2DataProvider::createDataSource(
             {
                 auto_ptr< vector<ScSharedTokenRef> > pTokens(new vector<ScSharedTokenRef>);
                 pTokens->push_back(pLabelToken);
-                Reference < chart2::data::XDataSequence > xLabelSeq(new ScChart2DataSequence(m_pDocument, this, pTokens.release()));
+                Reference < chart2::data::XDataSequence > xLabelSeq(new ScChart2DataSequence(m_pDocument, this, pTokens.release(), m_bIncludeHiddenCells));
                 Reference< beans::XPropertySet > xLabelProps(xLabelSeq, uno::UNO_QUERY);
                 if (xLabelProps.is())
                     xLabelProps->setPropertyValue(
@@ -1511,7 +1519,7 @@ ScChart2DataProvider::createDataSource(
         }
         auto_ptr< vector<ScSharedTokenRef> > pTokens(new vector<ScSharedTokenRef>);
         pTokens->swap(aRefTokens2);
-        uno::Reference< chart2::data::XDataSequence > xSeq( new ScChart2DataSequence( m_pDocument, this, pTokens.release()) );
+        uno::Reference< chart2::data::XDataSequence > xSeq( new ScChart2DataSequence( m_pDocument, this, pTokens.release(), m_bIncludeHiddenCells) );
         pHeader->setValues(xSeq);
     }
     if (pHeader)
@@ -1569,7 +1577,7 @@ ScChart2DataProvider::createDataSource(
                 auto_ptr< vector<ScSharedTokenRef> > pTokens(new vector<ScSharedTokenRef>);
                 pTokens->reserve(1);
                 pTokens->push_back(pHeaderCell);
-                xLabelSeq.set(new ScChart2DataSequence(m_pDocument, this, pTokens.release()));
+                xLabelSeq.set(new ScChart2DataSequence(m_pDocument, this, pTokens.release(), m_bIncludeHiddenCells));
                 uno::Reference< beans::XPropertySet > xLabelProps(xLabelSeq, uno::UNO_QUERY);
                 if (xLabelProps.is())
                     xLabelProps->setPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_ROLE)), uno::makeAny(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("label"))));
@@ -1586,7 +1594,7 @@ ScChart2DataProvider::createDataSource(
 
         // FIXME: if there are no labels the column or row name should be taken
 
-        uno::Reference < chart2::data::XDataSequence > xSeq(new ScChart2DataSequence(m_pDocument, this, pRanges.release()));
+        uno::Reference < chart2::data::XDataSequence > xSeq(new ScChart2DataSequence(m_pDocument, this, pRanges.release(), m_bIncludeHiddenCells));
 
         pLabeled->setValues(xSeq);
         pLabeled->setLabel(xLabelSeq);
@@ -2195,7 +2203,7 @@ uno::Reference< chart2::data::XDataSequence > SAL_CALL
     // ScChart2DataSequence manages the life cycle of pRefTokens.
     vector<ScSharedTokenRef>* pRefTokens = new vector<ScSharedTokenRef>();
     pRefTokens->swap(aRefTokens);
-    xResult.set(new ScChart2DataSequence(m_pDocument, this, pRefTokens));
+    xResult.set(new ScChart2DataSequence(m_pDocument, this, pRefTokens, m_bIncludeHiddenCells));
 
     return xResult;
 }
@@ -2373,6 +2381,88 @@ private:
 
 }
 
+// DataProvider XPropertySet -------------------------------------------------
+
+uno::Reference< beans::XPropertySetInfo> SAL_CALL
+ScChart2DataProvider::getPropertySetInfo() throw( uno::RuntimeException)
+{
+	ScUnoGuard aGuard;
+	static uno::Reference<beans::XPropertySetInfo> aRef =
+		new SfxItemPropertySetInfo( m_aPropSet.getPropertyMap() );
+	return aRef;
+}
+
+
+void SAL_CALL ScChart2DataProvider::setPropertyValue(
+        const ::rtl::OUString& rPropertyName, const uno::Any& rValue)
+            throw( beans::UnknownPropertyException,
+                    beans::PropertyVetoException,
+                    lang::IllegalArgumentException,
+                    lang::WrappedTargetException, uno::RuntimeException)
+{
+    if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS)))
+    {
+        if ( !(rValue >>= m_bIncludeHiddenCells))
+            throw lang::IllegalArgumentException();
+    }
+    else
+        throw beans::UnknownPropertyException();
+}
+
+
+uno::Any SAL_CALL ScChart2DataProvider::getPropertyValue(
+        const ::rtl::OUString& rPropertyName)
+            throw( beans::UnknownPropertyException,
+                    lang::WrappedTargetException, uno::RuntimeException)
+{
+    uno::Any aRet;
+    if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS)))
+        aRet <<= m_bIncludeHiddenCells;
+    else
+        throw beans::UnknownPropertyException();
+    return aRet;
+}
+
+
+void SAL_CALL ScChart2DataProvider::addPropertyChangeListener(
+        const ::rtl::OUString& /*rPropertyName*/,
+        const uno::Reference< beans::XPropertyChangeListener>& /*xListener*/)
+            throw( beans::UnknownPropertyException,
+                    lang::WrappedTargetException, uno::RuntimeException)
+{
+    OSL_ENSURE( false, "Not yet implemented" );
+}
+
+
+void SAL_CALL ScChart2DataProvider::removePropertyChangeListener(
+        const ::rtl::OUString& /*rPropertyName*/,
+        const uno::Reference< beans::XPropertyChangeListener>& /*rListener*/)
+            throw( beans::UnknownPropertyException,
+                    lang::WrappedTargetException, uno::RuntimeException)
+{
+    OSL_ENSURE( false, "Not yet implemented" );
+}
+
+
+void SAL_CALL ScChart2DataProvider::addVetoableChangeListener(
+        const ::rtl::OUString& /*rPropertyName*/,
+        const uno::Reference< beans::XVetoableChangeListener>& /*rListener*/)
+            throw( beans::UnknownPropertyException,
+                    lang::WrappedTargetException, uno::RuntimeException)
+{
+    OSL_ENSURE( false, "Not yet implemented" );
+}
+
+
+void SAL_CALL ScChart2DataProvider::removeVetoableChangeListener(
+        const ::rtl::OUString& /*rPropertyName*/,
+        const uno::Reference< beans::XVetoableChangeListener>& /*rListener*/ )
+            throw( beans::UnknownPropertyException,
+                    lang::WrappedTargetException, uno::RuntimeException)
+{
+    OSL_ENSURE( false, "Not yet implemented" );
+}
+
 void ScChart2DataProvider::detectRangesFromDataSource(vector<ScSharedTokenRef>& rRefTokens,
                                                       chart::ChartDataRowSource& rRowSource,
                                                       bool& rRowSourceDetected,
@@ -2658,10 +2748,25 @@ ScChart2DataSequence::Item::Item() :
     ::rtl::math::setNan(&mfValue);
 }
 
+ScChart2DataSequence::HiddenRangeListener::HiddenRangeListener(ScChart2DataSequence& rParent) :
+    mrParent(rParent)
+{
+}
+
+ScChart2DataSequence::HiddenRangeListener::~HiddenRangeListener()
+{
+}
+
+void ScChart2DataSequence::HiddenRangeListener::notify()
+{
+    mrParent.setDataChangedHint(true);
+}
+
 ScChart2DataSequence::ScChart2DataSequence( ScDocument* pDoc,
         const uno::Reference < chart2::data::XDataProvider >& xDP, 
-        vector<ScSharedTokenRef>* pTokens)
-    : m_bHidden( sal_False)
+        vector<ScSharedTokenRef>* pTokens,
+        bool bIncludeHiddenCells )
+    : m_bIncludeHiddenCells( bIncludeHiddenCells)
     , m_nObjectId( 0 )
     , m_pDocument( pDoc)
     , m_pTokens(pTokens)
@@ -2669,6 +2774,7 @@ ScChart2DataSequence::ScChart2DataSequence( ScDocument* pDoc,
     , m_pExtRefListener(NULL)
     , m_xDataProvider( xDP)
     , m_aPropSet(lcl_GetDataSequencePropertyMap())
+    , m_pHiddenListener(NULL)
     , m_pValueListener( NULL )
     , m_bGotDataChangedHint(false)
     , m_bExtDataRebuildQueued(false)
@@ -2698,6 +2804,12 @@ ScChart2DataSequence::~ScChart2DataSequence()
     if ( m_pDocument )
     {
         m_pDocument->RemoveUnoObject( *this);
+        if (m_pHiddenListener.get())
+        {
+            ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+            if (pCLC)
+                pCLC->EndListeningHiddenRange(m_pHiddenListener.get());
+        }
         StopListeningToAllExternalRefs();
     }
 
@@ -2712,6 +2824,14 @@ void ScChart2DataSequence::RefChanged()
 
         if( m_pDocument )
         {
+            ScChartListenerCollection* pCLC = NULL;
+            if (m_pHiddenListener.get())
+            {
+                pCLC = m_pDocument->GetChartListenerCollection();
+                if (pCLC)
+                    pCLC->EndListeningHiddenRange(m_pHiddenListener.get());
+            }
+
             vector<ScSharedTokenRef>::const_iterator itr = m_pTokens->begin(), itrEnd = m_pTokens->end();
             for (; itr != itrEnd; ++itr)
             {
@@ -2720,6 +2840,8 @@ void ScChart2DataSequence::RefChanged()
                     continue;
 
                 m_pDocument->StartListeningArea(aRange, m_pValueListener);
+                if (pCLC)
+                    pCLC->StartListeningHiddenRange(aRange, m_pHiddenListener.get());
             }
         }
     }
@@ -2763,17 +2885,21 @@ void ScChart2DataSequence::BuildDataCache()
                 {
                     for (SCROW nRow = aRange.aStart.Row(); nRow <= aRange.aEnd.Row(); ++nRow)
                     {
-                        m_aDataArray.push_back(Item());
-                        Item& rItem = m_aDataArray.back();
-                        ++nDataCount;
-                        USHORT nWidth = m_pDocument->GetColWidth(nCol, nTab);
-                        USHORT nHeight = m_pDocument->GetRowHeight(nRow, nTab);
-                        if (!nWidth || !nHeight)
+                        bool bColHidden = (m_pDocument->GetColFlags(nCol, nTab) & CR_HIDDEN);
+                        bool bRowHidden = (m_pDocument->GetRowFlags(nRow, nTab) & CR_HIDDEN);
+                        if (bColHidden || bRowHidden)
                         {
                             // hidden cell
                             ++nHiddenValueCount;
                             aHiddenValues.push_back(nDataCount-1);
+
+                            if( !m_bIncludeHiddenCells )
+                                continue;
                         }
+
+                        m_aDataArray.push_back(Item());
+                        Item& rItem = m_aDataArray.back();
+                        ++nDataCount;
     
                         ScAddress aAdr(nCol, nRow, nTab);
                         ScBaseCell* pCell = m_pDocument->GetCell(aAdr);
@@ -2811,8 +2811,10 @@ void ScChart2DataSequence::BuildDataCache()
                                     break;
     
                                 if (pFCell->HasValueData())
+                                {
                                     rItem.mfValue = pFCell->GetValue();
                                     rItem.mbIsValue = true;
+                                }
                             }
                             break;
 #if DBG_UTIL
@@ -2985,7 +3111,6 @@ void ScChart2DataSequence::CopyData(const ScChart2DataSequence& r)
 
     m_aHiddenValues = r.m_aHiddenValues;
     m_aRole = r.m_aRole;
-    m_bHidden = r.m_bHidden;
 
     if (r.m_pRangeIndices.get())
         m_pRangeIndices.reset(new vector<sal_uInt32>(*r.m_pRangeIndices));
@@ -3122,7 +3248,7 @@ IMPL_LINK( ScChart2DataSequence, ValueListenerHdl, SfxHint*, pHint )
         //  in the range are notified. So only a flag is set that is checked when
         //  SFX_HINT_DATACHANGED is received.
 
-        m_bGotDataChangedHint = true;
+        setDataChangedHint(true);
     }
     return 0;
 }
@@ -3511,7 +3637,7 @@ uno::Reference< util::XCloneable > SAL_CALL ScChart2DataSequence::createClone()
         }
     }
 
-    auto_ptr<ScChart2DataSequence> p(new ScChart2DataSequence(m_pDocument, m_xDataProvider, pTokensNew.release()));
+    auto_ptr<ScChart2DataSequence> p(new ScChart2DataSequence(m_pDocument, m_xDataProvider, pTokensNew.release(), m_bIncludeHiddenCells));
     p->CopyData(*this);
     Reference< util::XCloneable > xClone(p.release());
 
@@ -3539,11 +3665,23 @@ void SAL_CALL ScChart2DataSequence::addModifyListener( const uno::Reference< uti
 		if (!m_pValueListener)
 			m_pValueListener = new ScLinkListener( LINK( this, ScChart2DataSequence, ValueListenerHdl ) );
 
+        if (!m_pHiddenListener.get())
+            m_pHiddenListener.reset(new HiddenRangeListener(*this));
+
         if( m_pDocument )
         {
-            ULONG nCount = aRanges.Count();
-            for (ULONG i=0; i<nCount; i++)
-                m_pDocument->StartListeningArea( *aRanges.GetObject(i), m_pValueListener );
+            ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+            vector<ScSharedTokenRef>::const_iterator itr = m_pTokens->begin(), itrEnd = m_pTokens->end();
+            for (; itr != itrEnd; ++itr)
+            {
+                ScRange aRange;
+                if (!ScRefTokenHelper::getRangeFromToken(aRange, *itr))
+                    continue;
+
+                m_pDocument->StartListeningArea( aRange, m_pValueListener );
+                if (pCLC)
+                    pCLC->StartListeningHiddenRange(aRange, m_pHiddenListener.get());
+            }
         }
 
 		acquire();	// don't lose this object (one ref for all listeners)
@@ -3574,6 +3712,13 @@ void SAL_CALL ScChart2DataSequence::removeModifyListener( const uno::Reference<
 				if (m_pValueListener)
 					m_pValueListener->EndListeningAll();
 
+                if (m_pHiddenListener.get() && m_pDocument)
+                {
+                    ScChartListenerCollection* pCLC = m_pDocument->GetChartListenerCollection();
+                    if (pCLC)
+                        pCLC->EndListeningHiddenRange(m_pHiddenListener.get());
+                }
+
 				release();		// release the ref for the listeners
 			}
 
@@ -3608,10 +3753,13 @@ void SAL_CALL ScChart2DataSequence::setPropertyValue(
         if ( !(rValue >>= m_aRole))
             throw lang::IllegalArgumentException();
     }
-    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ISHIDDEN)))
+    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS)))
     {
-        if ( !(rValue >>= m_bHidden))
+        sal_Bool bOldValue = m_bIncludeHiddenCells;
+        if ( !(rValue >>= m_bIncludeHiddenCells))
             throw lang::IllegalArgumentException();
+        if( bOldValue != m_bIncludeHiddenCells )
+            m_aDataArray.clear();//data array is dirty now
     }
     else
         throw beans::UnknownPropertyException();
@@ -3627,8 +3775,8 @@ uno::Any SAL_CALL ScChart2DataSequence::getPropertyValue(
     uno::Any aRet;
     if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ROLE)))
         aRet <<= m_aRole;
-    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ISHIDDEN)))
-        aRet <<= m_bHidden;
+    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS)))
+        aRet <<= m_bIncludeHiddenCells;
     else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM(SC_UNONAME_HIDDENVALUES)))
     {
         // This property is read-only thus cannot be set externally via 
@@ -3690,6 +3838,11 @@ void SAL_CALL ScChart2DataSequence::removeVetoableChangeListener(
     OSL_ENSURE( false, "Not yet implemented" );
 }
 
+void ScChart2DataSequence::setDataChangedHint(bool b)
+{
+    m_bGotDataChangedHint = b;
+}
+
 // XUnoTunnel
 
 // sal_Int64 SAL_CALL ScChart2DataSequence::getSomething(
@@ -3738,7 +3891,7 @@ ScChart2EmptyDataSequence::ScChart2EmptyDataSequence( ScDocument* pDoc,
         const uno::Reference < chart2::data::XDataProvider >& xDP,
         const ScRangeListRef& rRangeList,
         sal_Bool bColumn)
-    : m_bHidden( sal_False)
+    : m_bIncludeHiddenCells( sal_True)
     , m_xRanges( rRangeList)
     , m_pDocument( pDoc)
     , m_xDataProvider( xDP)
@@ -3882,8 +4035,8 @@ uno::Reference< util::XCloneable > SAL_CALL ScChart2EmptyDataSequence::createClo
         {
             xProp->setPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_ROLE )),
                                      uno::makeAny( m_aRole ));
-            xProp->setPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_ISHIDDEN )),
-                                     uno::makeAny( m_bHidden ));
+            xProp->setPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS )),
+                                     uno::makeAny( m_bIncludeHiddenCells ));
         }
         return xClone;
     }
@@ -3928,9 +4081,9 @@ void SAL_CALL ScChart2EmptyDataSequence::setPropertyValue(
         if ( !(rValue >>= m_aRole))
             throw lang::IllegalArgumentException();
     }
-    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ISHIDDEN)))
+    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS)))
     {
-        if ( !(rValue >>= m_bHidden))
+        if ( !(rValue >>= m_bIncludeHiddenCells))
             throw lang::IllegalArgumentException();
     }
     else
@@ -3947,8 +4100,8 @@ uno::Any SAL_CALL ScChart2EmptyDataSequence::getPropertyValue(
     uno::Any aRet;
     if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ROLE)))
         aRet <<= m_aRole;
-    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_ISHIDDEN)))
-        aRet <<= m_bHidden;
+    else if ( rPropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( SC_UNONAME_INCLUDEHIDDENCELLS)))
+        aRet <<= m_bIncludeHiddenCells;
     else
         throw beans::UnknownPropertyException();
     // TODO: support optional properties
