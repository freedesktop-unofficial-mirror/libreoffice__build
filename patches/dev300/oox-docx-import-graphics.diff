diff --git oox/inc/oox/core/namespaces.hxx oox/inc/oox/core/namespaces.hxx
deleted file mode 100644
index ccc7d37..0000000
--- oox/inc/oox/core/namespaces.hxx
+++ /dev/null
@@ -1,88 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: namespaces.hxx,v $
- * $Revision: 1.5.4.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef OOX_CORE_NAMESPACES_HXX
-#define OOX_CORE_NAMESPACES_HXX
-
-#include <sal/types.h>
-
-namespace oox {
-
-// ============================================================================
-
-// relations, XML
-const sal_Int32 NMSP_XML                    = 1 << 16;
-const sal_Int32 NMSP_PACKAGE_RELATIONSHIPS  = 2 << 16;
-const sal_Int32 NMSP_RELATIONSHIPS          = 3 << 16;
-const sal_Int32 NMSP_CONTENT_TYPES          = 4 << 16;
-// office global
-const sal_Int32 NMSP_ACTIVATION             = 12 << 16;
-// DrawingML
-const sal_Int32 NMSP_DRAWINGML              = 21 << 16;
-const sal_Int32 NMSP_DIAGRAM                = 22 << 16;
-const sal_Int32 NMSP_CHART                  = 23 << 16;
-// VML
-const sal_Int32 NMSP_VML                    = 31 << 16;
-const sal_Int32 NMSP_OFFICE                 = 32 << 16;
-const sal_Int32 NMSP_VML_DOC                = 33 << 16; // Word VML
-const sal_Int32 NMSP_VML_XLS                = 34 << 16; // Excel VML
-const sal_Int32 NMSP_VML_PPT                = 35 << 16; // PowerPoint VML
-const sal_Int32 NMSP_AX                     = 36 << 16; // ActiveX (for OCX form controls)
-// SpreadsheetML
-const sal_Int32 NMSP_XLS                    = 41 << 16;
-const sal_Int32 NMSP_XDR                    = 42 << 16; // SpreadsheetDrawingML
-const sal_Int32 NMSP_XM                     = 43 << 16; // Macro sheet
-// PresentationML
-const sal_Int32 NMSP_PPT                    = 51 << 16;
-// Document properties
-const sal_Int32 NMSP_COREPR                 = 61 << 16;
-const sal_Int32 NMSP_DC                     = 62 << 16;
-const sal_Int32 NMSP_DCTERMS                = 63 << 16;
-const sal_Int32 NMSP_EXTPR                  = 64 << 16;
-const sal_Int32 NMSP_CUSTPR                 = 65 << 16;
-const sal_Int32 NMSP_VT                     = 66 << 16;
-
-// ----------------------------------------------------------------------------
-
-const sal_Int32 TOKEN_MASK                  = SAL_MAX_UINT16;
-const sal_Int32 NMSP_MASK                   = SAL_MAX_INT16 << 16;
-
-/** Returns the token identifier of the passed element without namespace. */
-inline sal_Int32 getToken( sal_Int32 nElement ) { return nElement & TOKEN_MASK; }
-
-/** Returns the namespace of the passed element without token identifier. */
-inline sal_Int32 getNamespace( sal_Int32 nElement ) { return nElement & NMSP_MASK; }
-
-// ============================================================================
-
-} // namespace oox
-
-#endif // OOX_CORE_NAMESPACES_HXX
-
diff --git oox/inc/oox/vml/shape.hxx oox/inc/oox/vml/shape.hxx
index 986685c..3e273ac 100644
--- oox/inc/oox/vml/shape.hxx
+++ oox/inc/oox/vml/shape.hxx
@@ -71,9 +71,17 @@ class Shape
 	sal_Int32		mnCoordWidth;
 	sal_Int32		mnCoordHeight;
 	sal_Int32		mnStroked;
+    sal_Int32       mnZOrder;
+    bool            mbContainsText;
 
-	::boost::optional< sal_Int32 >		moFilled;
-	::boost::optional< rtl::OUString >	moFillColor;
+    ::boost::optional< sal_Bool >       moFilled;
+	::boost::optional< sal_Int32 >      moFillType;
+	::boost::optional< sal_Int32 >	    moFillColor;
+    ::boost::optional< rtl::OUString >  moFillImageUrl;
+    sal_Int32                           meFillImageMode;
+
+    ::boost::optional< sal_Int32 >      moStrokeColor;
+    ::boost::optional< sal_Int32 >      moStrokeWeight;
 
 	rtl::OUString	msGraphicURL;
 	rtl::OUString	msImageTitle;
@@ -95,12 +103,19 @@ class Shape
 		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
 			const ::com::sun::star::awt::Rectangle* pShapeRect );
 
+    void updateShape( );
+
 	private :
 
 	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
 		createAndInsert( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Shape& rShape,
 			const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes, 
 				const ::com::sun::star::awt::Rectangle* pShapeRect );
+		
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
+        createAndInsertFrame( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Shape& rShape,
+			const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes, 
+				const ::com::sun::star::awt::Rectangle* pShapeRect );
 
 	void addChilds( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Drawing& rDrawing,
 		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
diff --git oox/prj/d.lst oox/prj/d.lst
index 54fc7f7..dab22be 100644
--- oox/prj/d.lst
+++ oox/prj/d.lst
@@ -16,6 +16,7 @@ mkdir: %_DEST%\inc%_EXT%\oox\drawingml\table
 
 ..\inc\oox\dllapi.h %_DEST%\inc%_EXT%\oox\dllapi.h
 ..\source\token\tokens.txt %_DEST%\inc%_EXT%\oox\token.txt
+..\source\token\namespaces.txt %_DEST%\inc%_EXT%\oox\namespaces.txt
 ..\inc\oox\core\filterbase.hxx %_DEST%\inc%_EXT%\oox\core\filterbase.hxx
 ..\inc\oox\core\relations.hxx %_DEST%\inc%_EXT%\oox\core\relations.hxx
 ..\%__SRC%\inc\tokens.hxx %_DEST%\inc%_EXT%\oox\core\tokens.hxx
diff --git oox/source/shape/ShapeContextHandler.cxx oox/source/shape/ShapeContextHandler.cxx
index fd72690..a0a1569 100644
--- oox/source/shape/ShapeContextHandler.cxx
+++ oox/source/shape/ShapeContextHandler.cxx
@@ -31,6 +31,11 @@
 #include "ShapeContextHandler.hxx"
 #include "oox/vml/drawingfragmenthandler.hxx"
 
+#if DEBUG
+#include <iostream>
+using namespace std;
+#endif
+
 namespace oox { namespace shape {
 
 using namespace ::com::sun::star;
@@ -75,6 +80,9 @@ ShapeContextHandler::getGraphicShapeContext()
 uno::Reference<xml::sax::XFastContextHandler> 
 ShapeContextHandler::getDrawingShapeContext()
 {
+#if DEBUG
+    clog << "ShapeContextHandler::getDrawingShapeContext" << endl;
+#endif
     if (!mxDrawingFragmentHandler.is())
     {
         mpDrawing.reset( new oox::vml::Drawing() );
@@ -158,6 +166,9 @@ ShapeContextHandler::createFastChildContext
  const uno::Reference< xml::sax::XFastAttributeList > & Attribs)
     throw (uno::RuntimeException, xml::sax::SAXException)
 {
+#if DEBUG
+    clog << "ShapeContextHandler::createFastChildContext" << endl;
+#endif
     uno::Reference< xml::sax::XFastContextHandler > xResult;
     uno::Reference< xml::sax::XFastContextHandler > xContextHandler;
 
diff --git oox/source/token/gennamespaces.pl oox/source/token/gennamespaces.pl
new file mode 100644
index 0000000..8c2ede6
--- /dev/null
+++ oox/source/token/gennamespaces.pl
@@ -0,0 +1,50 @@
+$ARGV0 = shift @ARGV;
+$ARGV1 = shift @ARGV;
+
+open ( NAMESPACES, $ARGV0 ) || die "can't open namespaces file: $!";
+
+
+open ( HXX, ">$ARGV1" ) or die "can't open namespaces.hxx file: $!";
+
+print ( HXX "#ifndef OOX_NAMESPACES_HXX\n" );
+print ( HXX "#define OOX_NAMESPACES_HXX\n\n" );
+print ( HXX "#include <sal/types.h>\n\n" );
+print ( HXX "namespace oox {\n\n" );
+
+$group = 0;
+$i = 1;
+while ( <NAMESPACES> )
+{
+    chomp( $_ );
+    $_ =~ s/\s*//g;
+    if ( $_ =~ m/^$/ )
+    {
+        # Start a new group
+        print ( HXX "\n" );
+        $i = 0;
+        $group++;
+    } 
+    elsif ( $_ =~ m/^[^#]/ )
+    {
+        # Neither an empty line nor a comment
+        $_ =~ /^[a-zA-Z0-9-_]+$/ or die "Invalid namespace token $_";
+        $id = "NMSP_$_";
+        $id =~ s/-/_/g;
+        $no = $group*10 + $i;
+        print ( HXX "const sal_Int32 $id = $no << 16;\n" );
+        ++$i;
+    }
+}
+close ( NAMESPACES );
+
+print ( HXX "\nconst sal_Int32 TOKEN_MASK                  = SAL_MAX_UINT16;\n" );
+print ( HXX "const sal_Int32 NMSP_MASK                   = SAL_MAX_INT16 << 16;\n" );
+
+print ( HXX "/** Returns the token identifier of the passed element without namespace. */\n" );
+print ( HXX "inline sal_Int32 getToken( sal_Int32 nElement ) { return nElement & TOKEN_MASK; }\n\n" );
+
+print ( HXX "/** Returns the namespace of the passed element without token identifier. */\n" );
+print ( HXX "inline sal_Int32 getNamespace( sal_Int32 nElement ) { return nElement & NMSP_MASK; }\n\n" );
+
+print ( HXX "} // namespace oox\n\n" );
+print ( HXX "#endif // OOX_NAMESPACES_HXX\n" );
diff --git oox/source/token/makefile.mk oox/source/token/makefile.mk
index bd1a4e3..4174830 100644
--- oox/source/token/makefile.mk
+++ oox/source/token/makefile.mk
@@ -50,14 +50,24 @@ SLOFILES =	\
 
 .INCLUDE :  target.mk
 
-$(MISC)$/tokens.gperf $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx : 
+$(MISC)$/tokens.gperf $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx $(INCCOM)$/oox$/core$/namespaces.hxx : 
 	@@noop $(assign do_phony:=.PHONY)
 
 $(MISC)$/do_tokens $(do_phony) : tokens.txt gentoken.pl $(MISC)$/tokens.gperf $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx
-		$(PERL) gentoken.pl tokens.txt $(INCCOM)$/tokens.hxx $(INCCOM)$/tokenwords.inc $(MISC)$/tokens.gperf && $(TOUCH) $@
+	$(PERL) gentoken.pl tokens.txt $(INCCOM)$/tokens.hxx $(INCCOM)$/tokenwords.inc $(MISC)$/tokens.gperf && $(TOUCH) $@
+
+$(INCCOM)$/oox:
+	$(MKDIR) $(INCCOM)$/oox
+
+$(INCCOM)$/oox$/core: $(INCCOM)$/oox
+	$(MKDIR) $(INCCOM)$/oox$/core
+
+$(MISC)$/do_namespaces $(do_phony) : namespaces.txt gennamespaces.pl
+	$(MKDIRHIER) $(INCCOM)$/oox$/core
+	$(PERL) gennamespaces.pl namespaces.txt $(INCCOM)$/oox$/core$/namespaces.hxx && $(TOUCH) $@
 
 $(INCCOM)$/tokens.inc : $(MISC)$/tokens.gperf $(MISC)$/do_tokens
 		gperf --compare-strncmp $(MISC)$/tokens.gperf | $(SED) -e "s/(char\*)0/(char\*)0, 0/g" | $(GREP) -v "^#line" >$(INCCOM)$/tokens.inc
 
-$(SLO)$/tokenmap.obj : $(INCCOM)$/tokens.inc $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx $(MISC)$/do_tokens
+$(SLO)$/tokenmap.obj : $(INCCOM)$/tokens.inc $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx $(INCCOM)$/oox$/core$/namespaces.hxx $(MISC)$/do_tokens $(MISC)$/do_namespaces
 
diff --git oox/source/token/namespaces.txt oox/source/token/namespaces.txt
new file mode 100644
index 0000000..63ca76e
--- /dev/null
+++ oox/source/token/namespaces.txt
@@ -0,0 +1,48 @@
+# Relations, XML
+XML
+PACKAGE_RELATIONSHIPS
+RELATIONSHIPS
+CONTENT_TYPES
+
+# Office global
+THEME
+ACTIVATION
+MATH
+
+#DrawingML
+DRAWINGML
+PICTURE
+DIAGRAM
+CHART
+DOC_DRAWINGML
+
+# VML
+VML
+OFFICE
+VML_DOC
+VML_XLS
+VML_PPT
+AX
+
+#SpreadsheetML
+XLS
+XDR
+XM
+
+#PresentationML
+PPT
+
+#WordprocessingML
+DOC
+SML
+
+# Document properties
+COREPR
+DC
+DCTERMS
+EXTPR
+CUSTPR
+VT
+
+# Other elements: used by writerfilter
+SPRM
diff --git oox/source/vml/vmldrawingfragmenthandler.cxx oox/source/vml/vmldrawingfragmenthandler.cxx
index c094f57..31929f7 100644
--- oox/source/vml/vmldrawingfragmenthandler.cxx
+++ oox/source/vml/vmldrawingfragmenthandler.cxx
@@ -36,11 +36,19 @@
 #include "oox/core/contexthandler.hxx"
 #include <com/sun/star/beans/XMultiPropertySet.hpp>
 #include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/drawing/BitmapMode.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
 #include <com/sun/star/drawing/PointSequence.hpp>
 #include <com/sun/star/drawing/PointSequenceSequence.hpp>
 #include "oox/core/namespaces.hxx"
 #include "tokens.hxx"
 
+#if DEBUG
+#include <iostream>
+using namespace std;
+#endif
+
+
 using ::rtl::OUString;
 using namespace ::com::sun::star;
 using namespace ::oox::core;
@@ -50,6 +58,74 @@ using namespace ::com::sun::star::container;
 
 namespace oox { namespace vml {
 
+static sal_Int32 getColor( const rtl::OUString& rColor )
+{
+    sal_Int32 nId = 0;
+    rtl::OUString sValue ( rColor.getToken( 0, ' ', nId ) );
+    
+    static const rtl::OUString aColorNames[] =
+    {
+        rtl::OUString::createFromAscii( "Black" ),
+        rtl::OUString::createFromAscii( "Silver" ),
+        rtl::OUString::createFromAscii( "Gray" ),
+        rtl::OUString::createFromAscii( "White" ),
+        rtl::OUString::createFromAscii( "Maroon" ),
+        rtl::OUString::createFromAscii( "Red" ),
+        rtl::OUString::createFromAscii( "Purple" ),
+        rtl::OUString::createFromAscii( "Fuchsia" ),
+        rtl::OUString::createFromAscii( "Green" ),
+        rtl::OUString::createFromAscii( "Lime" ),
+        rtl::OUString::createFromAscii( "Olive" ),
+        rtl::OUString::createFromAscii( "Yellow" ),
+        rtl::OUString::createFromAscii( "Navy" ),
+        rtl::OUString::createFromAscii( "Blue" ),
+        rtl::OUString::createFromAscii( "Teal" ),
+        rtl::OUString::createFromAscii( "Aqua" )
+    };
+
+    static const rtl::OUString aColorValues[] =
+    {
+        rtl::OUString::createFromAscii( "000000" ),
+        rtl::OUString::createFromAscii( "C0C0C0" ),
+        rtl::OUString::createFromAscii( "808080" ),
+        rtl::OUString::createFromAscii( "FFFFFF" ),
+        rtl::OUString::createFromAscii( "800000" ),
+        rtl::OUString::createFromAscii( "FF0000" ),
+        rtl::OUString::createFromAscii( "800080" ),
+        rtl::OUString::createFromAscii( "FF00FF" ),
+        rtl::OUString::createFromAscii( "008000" ),
+        rtl::OUString::createFromAscii( "00FF00" ),
+        rtl::OUString::createFromAscii( "808000" ),
+        rtl::OUString::createFromAscii( "FFFF00" ),
+        rtl::OUString::createFromAscii( "000080" ),
+        rtl::OUString::createFromAscii( "0000FF" ),
+        rtl::OUString::createFromAscii( "008080" ),
+        rtl::OUString::createFromAscii( "00FFFF" )
+    };
+
+    rtl::OUString sHexValue;
+    if ( sValue.compareToAscii( "#", 1 ) == 0 )
+    {
+        // Removes the # of the hexa value if needed
+        sHexValue = sValue.copy( 1 );
+    }
+    else
+    {
+        // Convert the color name into an hexa value
+        int i = 0;
+        while ( sHexValue.getLength( ) == 0 && i < 16 )
+        {
+            if ( sValue.equalsIgnoreAsciiCase( aColorNames[i] ) )
+            {
+                sHexValue = aColorValues[i];
+            }
+            i++;
+        }
+    }
+
+    return sHexValue.toInt32( sal_Int16( 16 ) );
+}
+
 static sal_Int32 getMeasure( const rtl::OUString& rVal )
 {
 	double fVal = rVal.toDouble();
@@ -67,6 +143,30 @@ static sal_Int32 getMeasure( const rtl::OUString& rVal )
 	return static_cast< sal_Int32 >( fVal );
 }
 
+static OUString getRelId( const Reference< XFastAttributeList >& xAttribs )
+{
+    static const sal_Int32 aTokens[] = 
+    {
+        NMSP_RELATIONSHIPS | XML_id,
+        NMSP_OFFICE | XML_relid,
+        NMSP_RELATIONSHIPS | XML_href
+    };
+
+    // Look for the relation id
+    OUString sId;
+
+    int i = 0;
+    while ( ( i < 3 ) && ( sId.getLength( ) == 0 ) )
+    {
+        OUString sValue( xAttribs->getOptionalValue( aTokens[i] ) );
+        if ( sValue.getLength( ) > 0 )
+            sId = sValue;
+        i++;
+    }
+
+    return sId;
+}
+
 // AG_CoreAttributes
 static void ApplyCoreAttributes( const Reference< XFastAttributeList >& xAttribs, Shape& rShape )
 {
@@ -95,6 +195,7 @@ static void ApplyCoreAttributes( const Reference< XFastAttributeList >& xAttribs
 					static const ::rtl::OUString sHeight( RTL_CONSTASCII_USTRINGPARAM( "height" ) );
 					static const ::rtl::OUString sMarginLeft( RTL_CONSTASCII_USTRINGPARAM( "margin-left" ) );
 					static const ::rtl::OUString sMarginTop( RTL_CONSTASCII_USTRINGPARAM( "margin-top" ) );
+					static const ::rtl::OUString sZIndex( RTL_CONSTASCII_USTRINGPARAM( "z-index" ) );
 					if ( aName == sPosition )
 						rShape.msPosition = aVal;
 					else if ( aName == sLeft )
@@ -109,6 +210,8 @@ static void ApplyCoreAttributes( const Reference< XFastAttributeList >& xAttribs
 						rShape.maPosition.X = getMeasure( aVal );
 					else if ( aName == sMarginTop )
 						rShape.maPosition.Y = getMeasure( aVal );
+                    else if ( aName == sZIndex )
+                        rShape.mnZOrder = aVal.toInt32( );
 				}
 			}
         }
@@ -146,8 +249,21 @@ static void ApplyShapeAttributes( const Reference< XFastAttributeList >& xAttrib
 	rShape.mnStroked = xAttribs->getOptionalValueToken( XML_stroked, 0 );
 	if ( xAttribs->hasAttribute( XML_filled ) )
 		rShape.moFilled = ::boost::optional< sal_Bool >( aAttributeList.getBool( XML_filled, sal_False ) );
+
 	if ( xAttribs->hasAttribute( XML_fillcolor ) )
-		rShape.moFillColor = ::boost::optional< rtl::OUString >( xAttribs->getOptionalValue( XML_fillcolor ) );
+		rShape.moFillColor = ::boost::optional< sal_Int32 >( getColor( xAttribs->getOptionalValue( XML_fillcolor ) ) );
+    else
+        rShape.moFillColor = ::boost::optional< sal_Int32 >( 0xffffff );
+
+    if ( xAttribs->hasAttribute( XML_strokecolor ) )
+        rShape.moStrokeColor = ::boost::optional< sal_Int32 >( getColor( xAttribs->getOptionalValue( XML_strokecolor ) ) );
+    else
+        rShape.moStrokeColor = ::boost::optional< sal_Int32 >( 0 );
+    
+    if ( xAttribs->hasAttribute( XML_strokeweight ) )
+        rShape.moStrokeWeight = ::boost::optional< sal_Int32 >( getMeasure( xAttribs->getOptionalValue( XML_strokeweight ) ) );
+    else
+        rShape.moStrokeColor = ::boost::optional< sal_Int32 >( getMeasure( OUString::createFromAscii( "1pt" ) ) );
 }
 
 //--------------------------------------------------------------------------------------------------------------
@@ -159,7 +275,7 @@ public:
 		sal_Int32 aElement, const Reference< XFastAttributeList >& xAttribs, Shape& rShape );
     virtual Reference< XFastContextHandler > SAL_CALL createFastChildContext( sal_Int32 Element,
 		const Reference< XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, RuntimeException);
-private:
+protected:
 	Shape& mrShape;
 };
 
@@ -179,11 +295,22 @@ Reference< XFastContextHandler > BasicShapeContext::createFastChildContext( sal_
 	{
 		case NMSP_VML|XML_imagedata:
 			{
-                OUString aRelId( xAttribs->getOptionalValue( NMSP_OFFICE|XML_relid ) );
-                mrShape.msGraphicURL = getFragmentPathFromRelId( aRelId );
+                // A picture in a custom shape isn't shown
+                if ( mrShape.msServiceName.equalsAscii( "com.sun.star.drawing.CustomShape" ) )
+                    mrShape.msServiceName = OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" );
+
+                OUString aRelId( getRelId( xAttribs ) );
+                OUString sUrl( getFragmentPathFromRelId( aRelId ) );
+                mrShape.moFillImageUrl = ::boost::optional< OUString >( sUrl );
+                mrShape.moFillType = ::boost::optional< sal_Int32 > ( drawing::FillStyle_BITMAP );
 				mrShape.msImageTitle = xAttribs->getOptionalValue( NMSP_OFFICE|XML_title );
 			}
 			break;
+        case NMSP_VML|XML_textbox:
+            {
+                mrShape.mbContainsText = true;
+            }
+            break;
 		default:
 			break;
 	}
@@ -315,6 +442,7 @@ public:
 		sal_Int32 aElement, const Reference< XFastAttributeList >& xAttribs, Shape& rShape );
     virtual Reference< XFastContextHandler > SAL_CALL createFastChildContext( sal_Int32 Element,
 		const Reference< XFastAttributeList >& Attribs ) throw (SAXException, RuntimeException);
+    void ApplyFillAttributes( const Reference< XFastAttributeList >& xAttribs );
 };
 
 ShapeContext::ShapeContext( ContextHandler& rParent,
@@ -330,17 +458,68 @@ Reference< XFastContextHandler > ShapeContext::createFastChildContext( sal_Int32
 	throw (SAXException, RuntimeException)
 {
 	Reference< XFastContextHandler > xRet;
-//	switch( aElementToken )
-//	{
-//		default:
+	switch( aElementToken )
+	{
+        case NMSP_VML|XML_fill:
+            {
+                ApplyFillAttributes( xAttribs );
+            }
+            break;
+		default:
 			xRet = BasicShapeContext::createFastChildContext( aElementToken, xAttribs );
-//		break;
-//	}
+		break;
+	}
 	if( !xRet.is() )
 		xRet.set( this );
 	return xRet;
 }
 
+void ShapeContext::ApplyFillAttributes( const Reference< XFastAttributeList >& xAttribs )
+{
+    // Fill type
+    if ( xAttribs->hasAttribute( XML_type ) )
+    {
+       OUString sType = xAttribs->getValue( XML_type );
+
+       if ( sType.equalsIgnoreAsciiCaseAscii( "frame" ) ||
+         sType.equalsIgnoreAsciiCaseAscii( "tile" ) )
+       {
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_BITMAP );
+           mrShape.moFilled = ::boost::optional< sal_Bool >( sal_True );
+
+           // TODO Its a picture
+           if ( sType.equalsIgnoreAsciiCaseAscii( "frame" ) )
+               mrShape.meFillImageMode = com::sun::star::drawing::BitmapMode_STRETCH;
+           else
+               mrShape.meFillImageMode = com::sun::star::drawing::BitmapMode_REPEAT;
+           
+           if ( xAttribs->hasAttribute( NMSP_RELATIONSHIPS|XML_id ) )
+           {
+               OUString aRelId( getRelId( xAttribs ) );
+               OUString sUrl = getFragmentPathFromRelId( aRelId );
+               mrShape.moFillImageUrl = ::boost::optional< OUString >( sUrl );
+           }
+       }
+       else if ( sType.equalsIgnoreAsciiCaseAscii( "gradient" ) || 
+               sType.equalsIgnoreAsciiCaseAscii( "grandientradial" ) )
+       {
+           // TODO Its a gradient
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_GRADIENT );
+       }
+       else if ( sType.equalsIgnoreAsciiCaseAscii( "solid" ) )
+       {
+           // TODO Its a solid
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_SOLID );
+       }
+       else if ( sType.equalsIgnoreAsciiCaseAscii( "pattern" ) )
+       {
+           // TODO Its a Hatch
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_HATCH );
+       }
+    }
+}
+
+
 //--------------------------------------------------------------------------------------------------------------
 
 class GroupShapeContext : public BasicShapeContext
@@ -364,9 +543,9 @@ GroupShapeContext::GroupShapeContext( ContextHandler& rParent,
 {
 	AttributeList aAttributeList( xAttribs );
 	if ( xAttribs->hasAttribute( XML_filled ) )
-		rShape.moFilled = ::boost::optional< sal_Bool >( aAttributeList.getBool( XML_filled, sal_False ) );	
+		rShape.moFilled = aAttributeList.getBool( XML_filled, sal_False );	
 	if ( xAttribs->hasAttribute( XML_fillcolor ) )
-		rShape.moFillColor = ::boost::optional< rtl::OUString >( xAttribs->getOptionalValue( XML_fillcolor ) );
+		rShape.moFillColor = ::boost::optional< sal_Int32 >( getColor( xAttribs->getOptionalValue( XML_fillcolor ) ) );
 	ApplyCoreAttributes( xAttribs, rShape );
 }
 Reference< XFastContextHandler > GroupShapeContext::createFastChildContext( sal_Int32 aElementToken, const Reference< XFastAttributeList >& xAttribs )
@@ -396,6 +575,10 @@ DrawingFragmentHandler::~DrawingFragmentHandler()
 		std::vector< ShapePtr >& rShapes, std::vector< ShapePtr >& rShapeTypes )
 		throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException )
 {
+#if DEBUG
+    clog << "DrawingFragmentHandler::StaticCreateContext" << endl;
+#endif
+
 	static const ::rtl::OUString sCustomShape( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.CustomShape" ) );
 
 	Reference< XFastContextHandler > xRet;
@@ -501,6 +684,9 @@ DrawingFragmentHandler::~DrawingFragmentHandler()
 Reference< XFastContextHandler > DrawingFragmentHandler::createFastChildContext( sal_Int32 aElementToken, const Reference< XFastAttributeList >& xAttribs )
 	throw (SAXException, RuntimeException)
 {
+#if DEBUG
+    clog << "DrawingFragmentHandler::createFastChildContext" << endl;
+#endif
 	return aElementToken == XML_xml
 		? getFastContextHandler()
 		: StaticCreateContext( *this, aElementToken, xAttribs, mrShapes, mrShapeTypes );
diff --git oox/source/vml/vmlshape.cxx oox/source/vml/vmlshape.cxx
index d990b8b..87ca640 100644
--- oox/source/vml/vmlshape.cxx
+++ oox/source/vml/vmlshape.cxx
@@ -31,11 +31,26 @@
 #include <rtl/ustring.hxx>
 #include "oox/vml/shape.hxx"
 #include "oox/core/xmlfilterbase.hxx"
+#include <com/sun/star/awt/XBitmap.hpp>
 #include <com/sun/star/drawing/XEnhancedCustomShapeDefaulter.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/beans/PropertyValues.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/VertOrientation.hpp>
+#include <com/sun/star/text/RelOrientation.hpp>
+#include <com/sun/star/text/SizeType.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextFrame.hpp>
+
+#if DEBUG
+#include <iostream>
+using namespace std;
+#endif
 
+using rtl::OUString;
 using namespace com::sun::star;
 
 namespace oox { namespace vml {
@@ -45,7 +60,11 @@ Shape::Shape( const rtl::OUString& rServiceName )
 , mnCoordWidth( 0 )
 , mnCoordHeight( 0 )
 , mnStroked( 0 )
+, mnZOrder( 0 )
+, mbContainsText( false )
 {
+    // By default all the shapes are filled
+    moFilled = ::boost::optional< sal_Bool > ( sal_True );
 }
 Shape::~Shape()
 {
@@ -65,16 +84,26 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 		mnCoordHeight = rSource.mnCoordHeight;
 	if ( rSource.mnStroked )
 		mnStroked = rSource.mnStroked;
-	if ( rSource.moFilled )
-		moFilled = rSource.moFilled;
+    if ( rSource.moFilled )
+        moFilled = rSource.moFilled;
+    if ( rSource.moFillType )
+		moFillType = rSource.moFillType;
+    if ( rSource.moFillImageUrl )
+        moFillImageUrl = rSource.moFillImageUrl;
 	if ( rSource.moFillColor )
 		moFillColor = rSource.moFillColor;
 	if ( rSource.maPath.Name.getLength() )
 		maPath = rSource.maPath;
 	if ( rSource.msPosition.getLength() )
 		msPosition = rSource.msPosition;
+    if ( rSource.moStrokeColor )
+        moStrokeColor = rSource.moStrokeColor;
+    if ( rSource.moStrokeWeight )
+        moStrokeWeight = rSource.moStrokeWeight;
 	maPosition = rSource.maPosition;
 	maSize = rSource.maSize;
+    meFillImageMode = rSource.meFillImageMode;
+    mbContainsText = rSource.mbContainsText;
 }
 
 ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > Shape::createAndInsert(
@@ -83,13 +112,15 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 			const awt::Rectangle* pShapeRect )
 {
 	uno::Reference< drawing::XShape > xShape;
+            
 	if ( rShape.msServiceName )
 	{
 		try
 		{
 			uno::Reference< lang::XMultiServiceFactory > xServiceFact( rFilterBase.getModel(), uno::UNO_QUERY_THROW );
 			xShape.set( xServiceFact->createInstance( rShape.msServiceName ), uno::UNO_QUERY_THROW );
-			rxShapes->add( xShape );
+    		rxShapes->add( xShape );
+
 			awt::Point aPosition;
 			awt::Size aSize;
 			if ( pShapeRect )
@@ -111,13 +142,54 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 			{
 				if ( maPath.Name.getLength() )
 					xPropSet->setPropertyValue( maPath.Name, maPath.Value );
+                if ( !moFilled )
+                    moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_NONE );
 
 				::rtl::OUString sFillStyle( rtl::OUString::createFromAscii( "FillStyle" ) );
-				if ( moFilled )
-					xPropSet->setPropertyValue( sFillStyle, uno::Any( *moFilled ? drawing::FillStyle_SOLID : drawing::FillStyle_NONE ) );
+				xPropSet->setPropertyValue( sFillStyle, uno::Any( *moFillType ) );
+
+                if ( moFillImageUrl )
+                {
+                    // load the bitmap
+                    uno::Reference< io::XInputStream > xInputStream( rFilterBase.openInputStream( *moFillImageUrl ), uno::UNO_QUERY_THROW );
+
+		        	// load the fill bitmap into an XGraphic with the GraphicProvider
+                    static const rtl::OUString sGraphicProvider = rtl::OUString::createFromAscii( "com.sun.star.graphic.GraphicProvider" );
+                    uno::Reference< graphic::XGraphicProvider > xGraphicProvider( 
+                            rFilterBase.getGlobalFactory()->createInstance( sGraphicProvider ), uno::UNO_QUERY_THROW );
+
+                    static const rtl::OUString sInputStream = rtl::OUString::createFromAscii( "InputStream" );
+                    beans::PropertyValues aMediaProperties(1);
+		        	aMediaProperties[0].Name = sInputStream;
+        			aMediaProperties[0].Value <<= xInputStream;
+
+                    uno::Reference< awt::XBitmap > xBitmap( xGraphicProvider->queryGraphic( aMediaProperties ), 
+                            uno::UNO_QUERY_THROW );
+                    xPropSet->setPropertyValue( rtl::OUString::createFromAscii( "FillBitmap" ), uno::Any( xBitmap ) );
+
+                    // Set the bitmap fill size/repeat properties
+                    xPropSet->setPropertyValue( rtl::OUString::createFromAscii( "FillBitmapMode" ), uno::Any( meFillImageMode ) );
+                }
+
+                ::rtl::OUString sFillColor( rtl::OUString::createFromAscii( "FillColor" ) );
+                if ( moFillColor )
+                    xPropSet->setPropertyValue( sFillColor, uno::Any( *moFillColor ) );
+                
+                ::rtl::OUString sLineColor( rtl::OUString::createFromAscii( "LineColor" ) );
+                if ( moStrokeColor )
+                    xPropSet->setPropertyValue( sLineColor, uno::Any( *moStrokeColor ) );
+                
+                ::rtl::OUString sLineWidth( rtl::OUString::createFromAscii( "LineWidth" ) );
+                if ( moStrokeWeight )
+                    xPropSet->setPropertyValue( sLineWidth, uno::Any( *moStrokeWeight ) );
 			}
-			catch ( uno::Exception& )
+			catch ( uno::Exception& e )
 			{
+#if DEBUG
+                clog << "Exception when setting shape properties: ";
+                clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( );
+                clog << endl;
+#endif
 			}
 			::rtl::OUString rServiceName( rtl::OUString::createFromAscii( "com.sun.star.drawing.CustomShape" ) );
 			if ( rShape.msShapeType.getLength() && ( msServiceName == rServiceName ) )
@@ -128,13 +200,88 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 			}
 			mxShape = xShape;
 		}
-		catch( uno::Exception& )
+		catch( uno::Exception& e )
 		{
+#if DEBUG
+            clog << "Exception thrown when creating shape: ";
+            clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
 		}
 	}
 	return xShape;
 }
 
+::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > Shape::createAndInsertFrame( 
+	const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Shape& rShape,
+		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
+			const awt::Rectangle* pShapeRect )
+{
+	uno::Reference< drawing::XShape > xShape;
+    static const OUString sFrameService( OUString::createFromAscii( "com.sun.star.text.TextFrame" ) );
+
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xServiceFact( rFilterBase.getModel(), uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextFrame > xFrame ( xServiceFact->createInstance( sFrameService ), uno::UNO_QUERY_THROW );
+        xShape.set( xFrame, uno::UNO_QUERY_THROW );
+  
+        // Set all the properties to the frame
+	    awt::Point aPosition;
+    	awt::Size aSize;
+	    if ( pShapeRect )
+		{
+			aPosition.X = pShapeRect->X;
+			aPosition.Y = pShapeRect->Y;
+			aSize.Width = pShapeRect->Width;
+			aSize.Height = pShapeRect->Height;
+		}
+		else
+		{
+			aPosition = maPosition;
+			aSize = maSize;
+		}
+		
+        uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+
+        // The size
+        xProps->setPropertyValue( OUString::createFromAscii( "SizeType" ), uno::Any( text::SizeType::FIX ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "FrameIsAutomaticHeight" ), uno::Any( sal_False ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "Height" ), uno::Any( aSize.Height ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "Width" ), uno::Any( aSize.Width ) );
+
+        // The position
+        xProps->setPropertyValue( OUString::createFromAscii( "HoriOrientPosition" ), uno::Any( aPosition.X ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "HoriOrientRelation" ), 
+                uno::Any( text::RelOrientation::FRAME ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "HoriOrient" ), 
+                uno::Any( text::HoriOrientation::NONE ) );
+
+        xProps->setPropertyValue( OUString::createFromAscii( "VertOrientPosition" ), uno::Any( aPosition.Y ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "VertOrientRelation" ), 
+                uno::Any( text::RelOrientation::FRAME ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "VertOrient" ), 
+                uno::Any( text::VertOrientation::NONE ) );
+
+
+        // Anchor the frame into the document
+        uno::Reference< text::XTextDocument > xDoc( rFilterBase.getModel( ), uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextContent > xCtnt( xShape, uno::UNO_QUERY_THROW );
+        xCtnt->attach( xDoc->getText( )->getStart( ) );
+			
+        mxShape = xShape;
+    }
+    catch ( uno::Exception& e )
+    {
+#if DEBUG
+        clog << "Exception during TextFrame creation: ";
+        clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( );
+        clog << endl;
+#endif
+    }
+
+    return xShape;
+}
+
 void Shape::addChilds( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Drawing& rDrawing,
 		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
 			const awt::Rectangle& rClientRect )
@@ -210,7 +357,14 @@ void Shape::addShape( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox
 	aShape.applyAttributes( *this );
 
 	// creating XShape
-	uno::Reference< drawing::XShape > xShape( createAndInsert( rFilterBase, aShape, rxShapes, pShapeRect ) );
+    static const OUString sRectService( OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" ) );
+    bool bIsRectangle = msServiceName.equals( sRectService );
+
+    uno::Reference< drawing::XShape > xShape;
+    if ( mbContainsText && bIsRectangle )
+        xShape.set( createAndInsertFrame( rFilterBase, aShape, rxShapes, pShapeRect ) );
+    else
+    	xShape.set( createAndInsert( rFilterBase, aShape, rxShapes, pShapeRect ) );
 
 	// creating GroupShape if possible
 	uno::Reference< drawing::XShapes > xShapes( xShape, uno::UNO_QUERY );
@@ -230,4 +384,9 @@ void Shape::addShape( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox
 	}
 }
 
+void Shape::updateShape( )
+{
+    // TODO Apply the shape attributes to the already added shape
+}
+
 } }
