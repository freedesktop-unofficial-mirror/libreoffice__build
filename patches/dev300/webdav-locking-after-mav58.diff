--- neon/neon.patch
+++ neon/neon.patch
@@ -307,7 +307,7 @@
 +#define NEON_VERSION "0.29.3"
 +
 +/* Define to enable debugging */
-+/* #undef NE_DEBUGGING */
++#define NE_DEBUGGING
 +
 +/* Define to be printf format string for off64_t */
 +#define NE_FMT_OFF64_T "lld"
--- ucb/source/ucp/webdav/NeonSession.cxx
+++ ucb/source/ucp/webdav/NeonSession.cxx
@@ -693,17 +693,17 @@
             // #122205# - libxml2 needs to be initialized once if used by
             // multithreaded programs like OOo.
             xmlInitParser();
-#if 0
+#if OSL_DEBUG_LEVEL > 0
             // for more debug flags see ne_utils.h; NE_DEBUGGING must be defined
             // while compiling neon in order to actually activate neon debug
             // output.
             ne_debug_init( stderr, NE_DBG_FLUSH
                            | NE_DBG_HTTP
                            // | NE_DBG_HTTPBODY
                            // | NE_DBG_HTTPAUTH
                            // | NE_DBG_XML
                            // | NE_DBG_XMLPARSE
-                           // | NE_DBG_LOCKS
+                           | NE_DBG_LOCKS
                          );
 #endif
             m_bGlobalsInited = true;
@@ -1489,6 +1489,16 @@
 
     if ( theRetVal == NE_OK )
     {
+        // If the server tells us it actually is using a timeout
+        // slightly smaller than what we asked for, just
+        // ask for the same timeout again next time.
+        // Also, never let the timeout we ask for be really small.
+        if ( theLock->timeout < rLock.Timeout &&
+             rLock.Timeout - theLock->timeout < 10 )
+            theLock->timeout = (long) rLock.Timeout;
+        else if ( theLock->timeout < 10 )
+            theLock->timeout = 10;
+
         m_aNeonLockStore.addLock( theLock,
                                   this,
                                   lastChanceToSendRefreshRequest(
@@ -1539,10 +1539,18 @@
     TimeValue startCall;
     osl_getSystemTime( &startCall );
 
+    long old_timeout = theLock->timeout;
+
     int theRetVal = ne_lock_refresh( m_pHttpSession, theLock );
 
     if ( theRetVal == NE_OK )
     {
+        if ( theLock->timeout < old_timeout &&
+             old_timeout - theLock->timeout < 10 )
+            theLock->timeout = old_timeout;
+        else if ( theLock->timeout < 10 )
+            theLock->timeout = 10;
+
         m_aNeonLockStore.updateLock( theLock,
                                      lastChanceToSendRefreshRequest(
                                          startCall, theLock->timeout ) );
@@ -1589,8 +1589,16 @@
     TimeValue startCall;
     osl_getSystemTime( &startCall );
 
+    long old_timeout = pLock->timeout;
+
     if ( ne_lock_refresh( m_pHttpSession, pLock ) == NE_OK )
     {
+        if ( pLock->timeout < old_timeout &&
+             old_timeout - pLock->timeout < 10 )
+            pLock->timeout = old_timeout;
+        else if ( pLock->timeout < 10 )
+            pLock->timeout = 10;
+
         rlastChanceToSendRefreshRequest
             = lastChanceToSendRefreshRequest( startCall, pLock->timeout );
 
