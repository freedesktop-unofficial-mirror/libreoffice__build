diff --git sc/source/ui/inc/gridwin.hxx sc/source/ui/inc/gridwin.hxx
index 3ab93fd..29cd088 100644
--- sc/source/ui/inc/gridwin.hxx
+++ sc/source/ui/inc/gridwin.hxx
@@ -345,7 +345,7 @@ private:
 
     void			PasteSelection( const Point& rPosPixel );
 
-    void			SelectForContextMenu( const Point& rPosPixel );
+    void			SelectForContextMenu( const Point& rPosPixel, SCsCOL nCellX, SCsROW nCellY );
 
     void            GetSelectionRects( ::std::vector< Rectangle >& rPixelRects );
     struct RectangleConverter {
diff --git sc/source/ui/inc/hdrcont.hxx sc/source/ui/inc/hdrcont.hxx
index 20cc822..497140f 100644
--- sc/source/ui/inc/hdrcont.hxx
+++ sc/source/ui/inc/hdrcont.hxx
@@ -80,7 +80,7 @@ private:
 
     long			GetScrPos( SCCOLROW nEntryNo );
     SCCOLROW		GetMousePos( const MouseEvent& rMEvt, BOOL& rBorder );
-
+    bool            IsSelectionAllowed(SCCOLROW nPos) const;
     void			ShowDragHelp();
 
     void			DoPaint( SCCOLROW nStart, SCCOLROW nEnd );
diff --git sc/source/ui/view/gridwin.cxx sc/source/ui/view/gridwin.cxx
index adb2f20..1079b9d 100644
--- sc/source/ui/view/gridwin.cxx
+++ sc/source/ui/view/gridwin.cxx
@@ -2753,9 +2753,32 @@ void __EXPORT ScGridWindow::Command( const CommandEvent& rCEvt )
 
         if ( bMouse )
         {
+            SCsCOL nCellX = -1;
+            SCsROW nCellY = -1;
+            pViewData->GetPosFromPixel(aPosPixel.X(), aPosPixel.Y(), eWhich, nCellX, nCellY);
+            ScDocument* pDoc = pViewData->GetDocument();
+            SCTAB nTab = pViewData->GetTabNo();
+            const ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+            bool bSelectAllowed = true;
+            if ( pProtect && pProtect->isProtected() )
+            {
+                // This sheet is protected.  Check if a context menu is allowed on this cell.
+                bool bCellProtected = pDoc->HasAttrib(nCellX, nCellY, nTab, nCellX, nCellY, nTab, HASATTR_PROTECTED);
+                bool bSelProtected   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+                bool bSelUnprotected = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+                if (bCellProtected)
+                    bSelectAllowed = bSelProtected;
+                else
+                    bSelectAllowed = bSelUnprotected;
+            }
+            if (!bSelectAllowed)
+                // Selecting this cell is not allowed, neither is context menu.
+                return;
+
             //	#i18735# First select the item under the mouse pointer.
             //	This can change the selection, and the view state (edit mode, etc).
-            SelectForContextMenu( aPosPixel );
+            SelectForContextMenu( aPosPixel, nCellX, nCellY );
         }
 
         BOOL bDone = FALSE;
@@ -2850,15 +2873,12 @@ void __EXPORT ScGridWindow::Command( const CommandEvent& rCEvt )
     }
 }
 
-void ScGridWindow::SelectForContextMenu( const Point& rPosPixel )
+void ScGridWindow::SelectForContextMenu( const Point& rPosPixel, SCsCOL nCellX, SCsROW nCellY )
 {
     //  #i18735# if the click was outside of the current selection,
     //  the cursor is moved or an object at the click position selected.
     //  (see SwEditWin::SelectMenuPosition in Writer)
 
-    SCsCOL nCellX;
-    SCsROW nCellY;
-    pViewData->GetPosFromPixel( rPosPixel.X(), rPosPixel.Y(), eWhich, nCellX, nCellY );
     ScTabView* pView = pViewData->GetView();
     ScDrawView* pDrawView = pView->GetScDrawView();
 
diff --git sc/source/ui/view/hdrcont.cxx sc/source/ui/view/hdrcont.cxx
index 89e871c..5cfe8f8 100644
--- sc/source/ui/view/hdrcont.cxx
+++ sc/source/ui/view/hdrcont.cxx
@@ -47,6 +47,7 @@
 #include "scmod.hxx"		// Optionen
 #include "inputopt.hxx"		// Optionen
 #include "gridmerg.hxx"
+#include "document.hxx"
 
 // -----------------------------------------------------------------------
 
@@ -655,6 +656,39 @@ SCCOLROW ScHeaderControl::GetMousePos( const MouseEvent& rMEvt, BOOL& rBorder )
     return nHitNo;
 }
 
+bool ScHeaderControl::IsSelectionAllowed(SCCOLROW nPos) const
+{
+    ScTabViewShell* pViewSh = dynamic_cast<ScTabViewShell*>(SfxViewShell::Current());
+    if (!pViewSh)
+        return false;
+
+    ScViewData* pViewData = pViewSh->GetViewData();
+    USHORT nTab = pViewData->GetTabNo();
+    ScDocument* pDoc = pViewData->GetDocument();
+    const ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+    bool bSelectAllowed = true;
+    if ( pProtect && pProtect->isProtected() )
+    {
+        // This sheet is protected.  Check if a context menu is allowed on this cell.
+        bool bCellsProtected = false;
+        if (bVertical)
+            // row header
+            bCellsProtected = pDoc->HasAttrib(0, nPos, nTab, MAXCOL, nPos, nTab, HASATTR_PROTECTED);
+        else
+            // column header
+            bCellsProtected = pDoc->HasAttrib(nPos, 0, nTab, nPos, MAXROW, nTab, HASATTR_PROTECTED);
+
+        bool bSelProtected   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+        bool bSelUnprotected = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+        if (bCellsProtected)
+            bSelectAllowed = bSelProtected;
+        else
+            bSelectAllowed = bSelUnprotected;
+    }
+    return bSelectAllowed;
+}
+
 void __EXPORT ScHeaderControl::MouseButtonDown( const MouseEvent& rMEvt )
 {
     if (IsDisabled())
@@ -665,6 +699,8 @@ void __EXPORT ScHeaderControl::MouseButtonDown( const MouseEvent& rMEvt )
 
     BOOL bFound;
     SCCOLROW nHitNo = GetMousePos( rMEvt, bFound );
+    if (!IsSelectionAllowed(nHitNo))
+        return;
 
     if ( bFound && rMEvt.IsLeft() && ResizeAllowed() )
     {
@@ -848,8 +884,11 @@ void __EXPORT ScHeaderControl::Command( const CommandEvent& rCEvt )
                 MouseEvent aMEvt( rCEvt.GetMousePosPixel() );
                 BOOL bBorder;
                 SCCOLROW nPos = GetMousePos( aMEvt, bBorder );
-                USHORT nTab = pViewData->GetTabNo();
+                if (!IsSelectionAllowed(nPos))
+                    // Selecting this cell is not allowed, neither is context menu.
+                    return;
 
+                SCTAB nTab = pViewData->GetTabNo();
                 ScRange aNewRange;
                 if ( bVertical )
                     aNewRange = ScRange( 0, sal::static_int_cast<SCROW>(nPos), nTab,
