diff --git a/offapi/org/openoffice/DocumentBuilder.idl b/offapi/org/openoffice/DocumentBuilder.idl
new file mode 100644
index 0000000..36ebc14
--- /dev/null
+++ offapi/org/openoffice/DocumentBuilder.idl
@@ -0,0 +1,40 @@
+#ifndef org_openoffice_DocumentBuilder_idl
+#define org_openoffice_DocumentBuilder_idl
+
+/* builder factory: Positon... */
+
+module org { module openoffice { 
+
+      interface DocumentBuilder {
+	/*
+	void setFontWeight();
+	void getFontWeight();
+
+	void appendText();
+	void appendAPO();
+	void startRun();
+	void endRun();
+
+	void appendParagraph();
+
+	void startTable();
+	void endTable();
+	void startRow();
+	void endRow();
+	void startCell();
+	void endCell();
+	
+	void startField();
+	void endField();
+
+	void startBookmark();
+	void endBookmark();
+
+	void startSection();
+	void endSection();
+	*/
+      };
+
+}; };
+
+#endif
diff --git a/offapi/org/openoffice/DocumentBuilderSupplier.idl b/offapi/org/openoffice/DocumentBuilderSupplier.idl
new file mode 100644
index 0000000..0af3886
--- /dev/null
+++ offapi/org/openoffice/DocumentBuilderSupplier.idl
@@ -0,0 +1,19 @@
+#ifndef org_openoffice_DocumentBuilderSupplier_idl
+#define org_openoffice_DocumentBuilderSupplier_idl
+
+#include <com/sun/star/uno/XInterface.idl>
+#include <org/openoffice/DocumentBuilder.idl>
+#include <org/openoffice/DocumentProvider.idl>
+
+module org { module openoffice { 
+
+      interface DocumentBuilderSupplier {
+
+	org::openoffice::DocumentBuilder createDocumentBuilder();
+	org::openoffice::DocumentProvider createDocumentProvider();
+
+      };
+
+}; };
+
+#endif 
diff --git a/offapi/org/openoffice/DocumentProvider.idl b/offapi/org/openoffice/DocumentProvider.idl
new file mode 100644
index 0000000..70ed037
--- /dev/null
+++ offapi/org/openoffice/DocumentProvider.idl
@@ -0,0 +1,48 @@
+#ifndef org_openoffice_DocumentProvider_idl
+#define org_openoffice_DocumentProvider_idl
+
+#include <com/sun/star/uno/XInterface.idl>
+
+module org { module openoffice { 
+
+    interface DocumentProvider {
+
+      void moveToMainContent();      
+      boolean hasNode();
+      boolean isTxtNode();
+      boolean isTableNode();
+      void consume();
+      long getNodeIndex();
+
+      void getSectionPr([in]long idx, [out]sequence< long > dxaColumns);
+
+      long getColumns();
+      long getColumn([in] long i);
+      long getRows();
+      
+      DocumentProvider openCell([in] long row, [in] long column);
+      long getRowSpan([in] long row, [in] long column);
+      long getColSpan([in] long row, [in] long column);
+
+      string getTxt();
+      long getTxtLen();
+      long getTxtOfs();
+      long loadPortion([in] long ofs);
+
+      boolean checkFlys([inout] long ofsStart, [inout] long ofsEnd,
+			[inout] long flyStart, [inout] long flyEnd);
+      DocumentProvider openFly([in] long fly);
+      boolean getFlyPositionRelativeToPage([in] long fly,
+					   [out]long x, 
+					   [out]long y, 
+					   [out]long w,
+					   [out]long h);
+
+      byte getFontWeight();
+      
+    };
+
+}; };
+
+
+#endif 
diff --git a/offapi/org/openoffice/makefile.mk b/offapi/org/openoffice/makefile.mk
new file mode 100644
index 0000000..343da37
--- /dev/null
+++ offapi/org/openoffice/makefile.mk
@@ -0,0 +1,22 @@
+PRJ=..$/..
+
+PRJNAME=offapi
+
+TARGET=ooapi
+PACKAGE=org$/openoffice
+
+# --- Settings -----------------------------------------------------
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# ------------------------------------------------------------------------
+
+IDLFILES=\
+    DocumentBuilder.idl\
+    DocumentProvider.idl\
+    DocumentBuilderSupplier.idl
+
+
+# ------------------------------------------------------------------
+
+.INCLUDE :  target.mk
+.INCLUDE :  $(PRJ)$/util$/target.pmk
diff --git a/offapi/prj/build.lst b/offapi/prj/build.lst
index 37c4880..01e8df1 100644
--- offapi/prj/build.lst
+++ offapi/prj/build.lst
@@ -103,4 +103,5 @@ oa	offapi\com\sun\star\geometry		    nmake	-	all	oa_geometry NULL
 oa	offapi\com\sun\star\rendering	        nmake	-	all oa_rendering oa_geometry NULL
 oa	offapi\com\sun\star\rdf	                nmake	-	all oa_rdf  oa_datatransfer oa_text NULL
 oa	offapi\drafts\com\sun\star\form         nmake	-	all	oa_drafts_form NULL
-oa  offapi\util                             nmake   -   all oa_util oa_auth oa_awt oa_awttree oa_chart oa_chart2 oa_chart2_data oa_config oa_configbootstrap oa_configbackend oa_configbackend_xml oa_datatrans_clip oa_datatrans_dnd oa_datatransfer oa_docu oa_draw oa_draw_framework oa_embed oa_fcomp oa_finsp oa_fcontr oa_fieldmaster oa_form oa_xforms oa_formula oa_frame oa_i18n oa_inst oa_ldap oa_ling2 oa_logging oa_mail oa_media oa_mozilla oa_packages oa_manifest oa_zippackage oa_plug oa_pres oa_animations oa_putil oa_resrc oa_sax oa_xml_input oa_scan oa_sdb oa_sdbtools oa_sdbapp oa_sdbc oa_sdbcx oa_setup oa_sheet oa_style oa_svg oa_sync oa_sync2 oa_system oa_table oa_task oa_text oa_textfield oa_docinfo oa_ucb oa_view oa_xml oa_xml_dom oa_xml_xpath oa_xml_views oa_xml_events oa_image oa_xsd oa_inspection oa_ui oa_ui_dialogs oa_accessibility oa_form_binding oa_form_validation oa_form_submission oa_fruntime oa_geometry oa_rendering oa_sfprovider oa_sfbrowse oa_drafts_form oa_deployment oa_deploymenttest oa_deployment_ui oa_frame_status oa_gallery oa_graphic oa_security oa_crypto_sax oa_crypto oa_csax oa_wrapper oa_script oa_smarttags oa_report oa_reportins oa_reportmeta oa_rdf oa_oooimprovement NULL
+oa	offapi\org\openoffice			nmake	-	all	oa_ooapi NULL
+oa  offapi\util                             nmake   -   all oa_util oa_auth oa_awt oa_awttree oa_chart oa_chart2 oa_chart2_data oa_config oa_configbootstrap oa_configbackend oa_configbackend_xml oa_datatrans_clip oa_datatrans_dnd oa_datatransfer oa_docu oa_draw oa_draw_framework oa_embed oa_fcomp oa_finsp oa_fcontr oa_fieldmaster oa_form oa_xforms oa_formula oa_frame oa_i18n oa_inst oa_ldap oa_ling2 oa_logging oa_mail oa_media oa_mozilla oa_packages oa_manifest oa_zippackage oa_plug oa_pres oa_animations oa_putil oa_resrc oa_sax oa_xml_input oa_scan oa_sdb oa_sdbtools oa_sdbapp oa_sdbc oa_sdbcx oa_setup oa_sheet oa_style oa_svg oa_sync oa_sync2 oa_system oa_table oa_task oa_text oa_textfield oa_docinfo oa_ucb oa_view oa_xml oa_xml_dom oa_xml_xpath oa_xml_views oa_xml_events oa_image oa_xsd oa_inspection oa_ui oa_ui_dialogs oa_accessibility oa_form_binding oa_form_validation oa_form_submission oa_fruntime oa_geometry oa_rendering oa_sfprovider oa_sfbrowse oa_drafts_form oa_deployment oa_deploymenttest oa_deployment_ui oa_frame_status oa_gallery oa_graphic oa_security oa_crypto_sax oa_crypto oa_csax oa_wrapper oa_script oa_smarttags oa_report oa_reportins oa_reportmeta oa_rdf oa_oooimprovement oa_ooapi NULL
diff --git a/offapi/prj/d.lst b/offapi/prj/d.lst
index e8982a5..a3a6d7b 100644
--- offapi/prj/d.lst
+++ offapi/prj/d.lst
@@ -112,6 +112,7 @@ mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\form
+mkdir: %COMMON_DEST%\idl%_EXT%\org\openoffice
 
 
 ..\%__SRC%\ucr\offapi.db %_DEST%\bin%_EXT%\offapi.rdb
@@ -224,3 +225,4 @@ mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\form
 ..\com\sun\star\xsd\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\xsd
 
 ..\drafts\com\sun\star\form\*.idl %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\form
+..\org\openoffice\*.idl %COMMON_DEST%\idl%_EXT%\org\openoffice
\ No newline at end of file
diff --git a/offapi/util/makefile.mk b/offapi/util/makefile.mk
index b671bcc..e0edfa0 100644
--- offapi/util/makefile.mk
+++ offapi/util/makefile.mk
@@ -143,7 +143,8 @@ UNOIDLDBFILES= \
     $(UCR)$/cssreport.db \
     $(UCR)$/cssrptins.db \
     $(UCR)$/cssrptmeta.db \
-    $(UCR)$/cssrdf.db
+    $(UCR)$/cssrdf.db \
+    $(UCR)$/ooapi.db
 
 
 REFERENCE_RDB=$(PRJ)$/type_reference$/types.rdb
diff --git a/offuh/prj/d.lst b/offuh/prj/d.lst
index fab4ddf..bc2f14b 100644
--- offuh/prj/d.lst
+++ offuh/prj/d.lst
@@ -130,6 +130,7 @@ mkdir: %_DEST%\inc%_EXT%\offuh\com\sun\star\xml\csax
 mkdir: %_DEST%\inc%_EXT%\offuh\com\sun\star\xml\wrapper
 #i20156 - end
 mkdir: %_DEST%\inc%_EXT%\offuh\com\sun\star\rdf
+mkdir: %_DEST%\inc%_EXT%\offuh\org\openoffice
 
 ..\%__SRC%\inc\offuh\com\sun\star\auth\*.hdl %_DEST%\inc%_EXT%\offuh\com\sun\star\auth\*.hdl
 ..\%__SRC%\inc\offuh\com\sun\star\auth\*.hpp %_DEST%\inc%_EXT%\offuh\com\sun\star\auth\*.hpp
@@ -372,3 +373,5 @@ mkdir: %_DEST%\inc%_EXT%\offuh\com\sun\star\rdf
 ..\%__SRC%\inc\offuh\com\sun\star\rdf\*.hpp %_DEST%\inc%_EXT%\offuh\com\sun\star\rdf\*.hpp
 ..\%__SRC%\inc\offuh\com\sun\star\rdf\*.hdl %_DEST%\inc%_EXT%\offuh\com\sun\star\rdf\*.hdl
 
+..\%__SRC%\inc\offuh\org\openoffice\*.hpp %_DEST%\inc%_EXT%\offuh\org\openoffice\*.hpp
+..\%__SRC%\inc\offuh\org\openoffice\*.hdl %_DEST%\inc%_EXT%\offuh\org\openoffice\*.hdl
diff --git a/sw/inc/ooapi.hxx b/sw/inc/ooapi.hxx
new file mode 100644
index 0000000..a79bafc
--- /dev/null
+++ sw/inc/ooapi.hxx
@@ -0,0 +1,109 @@
+#ifndef _OOAPI_HXX
+#define _OOAPI_HXX
+
+#include <tools/solar.h>
+#include <org/openoffice/DocumentBuilder.hpp>
+#include <org/openoffice/DocumentProvider.hpp>
+#include <cppuhelper/implbase1.hxx>
+
+class SwDocShell;
+class SwDoc;
+class SwNodeIndex;
+class SwPosition;
+class SwAttrIter;
+class SwScriptInfo;
+class SfxItemSet;
+class SwTable;
+class SwTableLine;
+class SwPosFlyFrms;
+class SwTableBox;
+
+class SwDocumentBuilder : public ::cppu::WeakImplHelper1< ::org::openoffice::DocumentBuilder > {
+
+private:
+  SwDocShell* m_pShell;
+  SwDoc *m_pDoc;
+public:
+  SwDocumentBuilder(SwDocShell* pShell);
+  virtual ~SwDocumentBuilder();
+
+};
+
+class SwDocumentProvider : public ::cppu::WeakImplHelper1< ::org::openoffice::DocumentProvider > {
+private:
+  static const int MAXCELLX=65;
+
+private:
+  SwDocShell* m_pShell;
+  SwDoc *m_pDoc;
+  SwPosFlyFrms *m_pFlyFrms;
+
+  SwNodeIndex *m_pNodeIndex; // current node index
+  SwNodeIndex *m_pEndIndex;  // final index...
+  SwPosition *m_pPos;        // !=NULL when in a content node
+  sal_Int32 m_pFlyStart;           // index into m_pFlyFrms for the current
+  sal_Int32 m_pFlyEnd;             // node...
+
+  
+  SwAttrIter *m_pAttrItr;     // !=NULL when in a SwTxtNode
+  SwScriptInfo *m_pScriptInfo; // !=NULL when we have an SwAttrItr
+  SfxItemSet *m_pItemSet;   
+
+  int m_tableGridX[MAXCELLX];
+  int m_nTableGridX;
+
+  SwTableBox *m_pCachedBox; // !=NULL then all the members below are valid
+  SwTableBox *m_pCachedStartOfRowSpan;
+  int m_nChachedBoxRow;
+  int m_nChachedBoxCol;
+  int m_nChachedRowCellx[MAXCELLX];
+  int m_nChachedRowCells;
+  int m_nChachedBoxCellx;
+
+private:
+  void ensure(sal_Bool exp) throw (::com::sun::star::uno::RuntimeException);
+  void moveTo(SwNodeIndex *startIdx, SwNodeIndex *endIdx);
+  void update(xub_StrLen parOfs=0);
+  int calcCellXForRow(SwTable *pTable, SwTableLine *pRow, int *cellx);
+  int calcGridForTable(SwTable *pTable, int *cellx);
+  sal_Bool getFlys( sal_Int32& start, sal_Int32& end );
+  sal_Int32 getFlyAnchorTxtOfs( sal_Int32 fly );
+  void ensureCellCache(int row, int col);
+
+
+public:
+  SwDocumentProvider(SwDocShell* pShell, SwDocumentProvider *pParent=NULL);
+  virtual ~SwDocumentProvider();
+
+  virtual void SAL_CALL moveToMainContent(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Bool SAL_CALL hasNode(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Bool SAL_CALL isTxtNode(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Bool SAL_CALL isTableNode(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual void SAL_CALL consume(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getNodeIndex(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual void SAL_CALL getSectionPr( ::sal_Int32 idx, ::com::sun::star::uno::Sequence< ::sal_Int32 >& dxaColumns ) throw (::com::sun::star::uno::RuntimeException);
+
+  virtual ::sal_Int32 SAL_CALL getColumns(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getColumn( ::sal_Int32 i ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getRows(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getRowSpan( ::sal_Int32 row, ::sal_Int32 column ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getColSpan( ::sal_Int32 row, ::sal_Int32 column ) throw (::com::sun::star::uno::RuntimeException);
+
+  virtual ::com::sun::star::uno::Reference< ::org::openoffice::DocumentProvider > SAL_CALL openCell( ::sal_Int32 row, ::sal_Int32 column ) throw (::com::sun::star::uno::RuntimeException) ;
+  
+  virtual ::com::sun::star::uno::Reference< ::org::openoffice::DocumentProvider > SAL_CALL openFly( ::sal_Int32 fly ) throw (::com::sun::star::uno::RuntimeException) ;
+  virtual ::sal_Bool SAL_CALL getFlyPositionRelativeToPage( ::sal_Int32 fly, ::sal_Int32& x, ::sal_Int32& y, ::sal_Int32& w, ::sal_Int32& h ) throw (::com::sun::star::uno::RuntimeException);
+  
+  virtual ::rtl::OUString SAL_CALL getTxt(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getTxtLen(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL getTxtOfs(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int32 SAL_CALL loadPortion( ::sal_Int32 ofs ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Bool SAL_CALL checkFlys( ::sal_Int32& ofsStart, ::sal_Int32& ofsEnd, ::sal_Int32& flyStart, ::sal_Int32& flyEnd ) throw (::com::sun::star::uno::RuntimeException);
+
+  virtual ::sal_Int8 SAL_CALL getFontWeight(  ) throw (::com::sun::star::uno::RuntimeException);
+  virtual ::sal_Int8 SAL_CALL getBreakType(  ) throw (::com::sun::star::uno::RuntimeException);
+};
+
+
+
+#endif /*  _OOAPI_HXX */
diff --git a/sw/inc/unotxdoc.hxx b/sw/inc/unotxdoc.hxx
index 7016cf0..119dcd9 100644
--- sw/inc/unotxdoc.hxx
+++ sw/inc/unotxdoc.hxx
@@ -71,6 +71,7 @@
 #ifndef _COM_SUN_STAR_DOCUMENT_XDOCUMENTLANGUAGES_HPP
 #include <com/sun/star/document/XDocumentLanguages.hpp>
 #endif
+#include <org/openoffice/DocumentBuilderSupplier.hpp>
 #include <svtools/itemprop.hxx>
 #include <svx/fmdmod.hxx>
 #include <svx/UnoForbiddenCharsTable.hxx>
@@ -79,22 +80,22 @@
 #include <cppuhelper/implbase4.hxx>	// helper for implementations
 #include <RefreshListenerContainer.hxx>
 
-#define __IFC31 Ifc1, Ifc2, Ifc3, Ifc4, Ifc5, Ifc6, Ifc7, Ifc8, Ifc9, Ifc10, Ifc11, Ifc12, Ifc13, Ifc14, Ifc15, Ifc16, \
-Ifc17, Ifc18, Ifc19, Ifc20, Ifc21, Ifc22, Ifc23, Ifc24, Ifc25, Ifc26, Ifc27, Ifc28, Ifc29, Ifc30, Ifc31
+#define __IFC32 Ifc1, Ifc2, Ifc3, Ifc4, Ifc5, Ifc6, Ifc7, Ifc8, Ifc9, Ifc10, Ifc11, Ifc12, Ifc13, Ifc14, Ifc15, Ifc16, \
+Ifc17, Ifc18, Ifc19, Ifc20, Ifc21, Ifc22, Ifc23, Ifc24, Ifc25, Ifc26, Ifc27, Ifc28, Ifc29, Ifc30, Ifc31, Ifc32
 
-#define __CLASS_IFC31 class Ifc1, class Ifc2, class Ifc3, class Ifc4, class Ifc5, class Ifc6, class Ifc7, \
+#define __CLASS_IFC32 class Ifc1, class Ifc2, class Ifc3, class Ifc4, class Ifc5, class Ifc6, class Ifc7, \
 class Ifc8, class Ifc9, class Ifc10, class Ifc11, class Ifc12, class Ifc13, class Ifc14, class Ifc15, class Ifc16, \
 class Ifc17, class Ifc18, class Ifc19, class Ifc20, class Ifc21, class Ifc22, class Ifc23, class Ifc24,\
-class Ifc25, class Ifc26, class Ifc27, class Ifc28, class Ifc29, class Ifc30, class Ifc31
+class Ifc25, class Ifc26, class Ifc27, class Ifc28, class Ifc29, class Ifc30, class Ifc31, class Ifc32
 
-#define __PUBLIC_IFC31 public Ifc1, public Ifc2, public Ifc3, public Ifc4, public Ifc5, public Ifc6, public Ifc7, public Ifc8, public Ifc9, public Ifc10, public Ifc11, public Ifc12, \
+#define __PUBLIC_IFC32 public Ifc1, public Ifc2, public Ifc3, public Ifc4, public Ifc5, public Ifc6, public Ifc7, public Ifc8, public Ifc9, public Ifc10, public Ifc11, public Ifc12, \
 public Ifc13, public Ifc14, public Ifc15, public Ifc16, public Ifc17, public Ifc18, \
 public Ifc19, public Ifc20, public Ifc21, public Ifc22, public Ifc23, public Ifc24, \
 public Ifc25, public Ifc26, public Ifc27, public Ifc28, public Ifc29, public Ifc30, \
-public Ifc31
+public Ifc31, public Ifc32
 #include <cppuhelper/implbase_ex.hxx>
 #include <cppuhelper/implbase_ex_pre.hxx>
-#define __IFC_EX_TYPE_INIT31( class_cast ) \
+#define __IFC_EX_TYPE_INIT32( class_cast ) \
     __IFC_EX_TYPE_INIT( class_cast, 1 ), __IFC_EX_TYPE_INIT( class_cast, 2 ), \
     __IFC_EX_TYPE_INIT( class_cast, 3 ), __IFC_EX_TYPE_INIT( class_cast, 4 ), \
     __IFC_EX_TYPE_INIT( class_cast, 5 ), __IFC_EX_TYPE_INIT( class_cast, 6 ), \
@@ -110,10 +111,10 @@ public Ifc31
     __IFC_EX_TYPE_INIT( class_cast, 25 ), __IFC_EX_TYPE_INIT( class_cast, 26 ), \
     __IFC_EX_TYPE_INIT( class_cast, 27 ), __IFC_EX_TYPE_INIT( class_cast, 28 ), \
     __IFC_EX_TYPE_INIT( class_cast, 29 ), __IFC_EX_TYPE_INIT( class_cast, 30 ), \
-    __IFC_EX_TYPE_INIT( class_cast, 31)
+    __IFC_EX_TYPE_INIT( class_cast, 31 ), __IFC_EX_TYPE_INIT( class_cast, 32 )
 #include <cppuhelper/implbase_ex_post.hxx>
 
-__DEF_IMPLHELPER_EX( 31 )
+__DEF_IMPLHELPER_EX( 32 )
 
 class SwDoc;
 class SwDocShell;
@@ -132,7 +133,7 @@ SV_DECL_PTRARR(ActionContextArr, UnoActionContextPtr, 4, 4)
  ******************************************************************************/
 
 
-typedef cppu::WeakImplHelper31
+typedef cppu::WeakImplHelper32
 <
     ::com::sun::star::text::XTextDocument,
     ::com::sun::star::text::XLineNumberingProperties,
@@ -164,7 +165,8 @@ typedef cppu::WeakImplHelper31
     ::com::sun::star::view::XRenderable,
     ::com::sun::star::xforms::XFormsSupplier,
     ::com::sun::star::text::XFlatParagraphIteratorProvider,
-    ::com::sun::star::document::XDocumentLanguages
+    ::com::sun::star::document::XDocumentLanguages,
+    ::org::openoffice::DocumentBuilderSupplier
 >
 SwXTextDocumentBaseClass;
 
@@ -402,6 +404,10 @@ public:
     // ::com::sun::star::text::XFlatParagraphIteratorProvider:
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XFlatParagraphIterator > SAL_CALL getFlatParagraphIterator(::sal_Int32 nTextMarkupType, sal_Bool bAutomatic ) throw (::com::sun::star::uno::RuntimeException);
 
+    // ::org:openoffice::DocumentBuilderSupplier
+    virtual ::com::sun::star::uno::Reference< ::org::openoffice::DocumentBuilder > SAL_CALL createDocumentBuilder(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::org::openoffice::DocumentProvider > SAL_CALL createDocumentProvider(  ) throw (::com::sun::star::uno::RuntimeException);
+
     //
     void						Invalidate();
     void						Reactivate(SwDocShell* pNewDocShell);
diff --git a/sw/prj/build.lst b/sw/prj/build.lst
index 0b5f70b..883335a 100644
--- sw/prj/build.lst
+++ sw/prj/build.lst
@@ -58,6 +58,7 @@ sw	sw\source\core\txtnode					nmake	-	all	sw_txtnd sw_inc NULL
 sw	sw\source\core\undo						nmake	-	all	sw_undo sw_inc NULL
 sw	sw\source\core\view						nmake	-	all	sw_view sw_inc NULL
 sw	sw\source\core\unocore					nmake	-	all	sw_uco sw_inc NULL
+sw	sw\source\core\ooapi					nmake	-	all	sw_ooapi sw_inc NULL
 sw      sw\source\core\objectpositioning                                nmake   -       all     sw_objpos sw_inc NULL
 sw  sw\source\core\access                   nmake   -   all sw_acc sw_inc NULL
 sw  sw\source\core\SwNumberTree             nmake   -   all sw_NumberTree sw_inc NULL
diff --git a/sw/source/core/makefile.mk b/sw/source/core/makefile.mk
index d9ea110..4db3fc7 100644
--- sw/source/core/makefile.mk
+++ sw/source/core/makefile.mk
@@ -69,6 +69,7 @@ SUBLIBS2= \
 SUBLIBS3= \
         $(SLB)$/docnode.lib \
                 $(SLB)$/unocore.lib \
+		$(SLB)$/ooapi.lib \
                 $(SLB)$/objectpositioning.lib \
                 $(SLB)$/SwNumberTree.lib \
                 $(SLB)$/tablecore.lib
diff --git a/sw/source/core/ooapi/SwDocumentBuilder.cxx b/sw/source/core/ooapi/SwDocumentBuilder.cxx
new file mode 100644
index 0000000..9b728a6
--- /dev/null
+++ sw/source/core/ooapi/SwDocumentBuilder.cxx
@@ -0,0 +1,25 @@
+#include <ooapi.hxx>
+#include <wdocsh.hxx>
+#include <doc.hxx>
+#include <pam.hxx>
+#include <swtable.hxx>
+#include <swtblfmt.hxx>
+#include <poolfmt.hxx>
+
+
+#include <stdio.h>
+
+SwDocumentBuilder::SwDocumentBuilder(SwDocShell* pShell) 
+  : m_pShell(pShell), m_pDoc(pShell!=NULL?pShell->GetDoc():NULL) {
+  printf("DOCUMENT BUILDER!!!!\n");
+
+  SwNodeIndex nNode( m_pDoc->GetNodes().GetEndOfContent(), -1 );
+  SwPaM aPaM( nNode );
+  SwNodeIndex aIndex(*aPaM.GetNode());
+  m_pDoc->Insert(aPaM, String::CreateFromAscii("HELLO"), false);
+
+}
+
+SwDocumentBuilder::~SwDocumentBuilder() {
+
+}
diff --git a/sw/source/core/ooapi/SwDocumentProvider.cxx b/sw/source/core/ooapi/SwDocumentProvider.cxx
new file mode 100644
index 0000000..1938a0c
--- /dev/null
+++ sw/source/core/ooapi/SwDocumentProvider.cxx
@@ -0,0 +1,554 @@
+#include <ooapi.hxx>
+#include <wdocsh.hxx>
+#include <doc.hxx>
+#include <pam.hxx>
+#include <swtable.hxx>
+#include <swtblfmt.hxx>
+#include <poolfmt.hxx>
+#include <ndhints.hxx>
+#include <ndtxt.hxx>
+#include <txatbase.hxx>
+#include <fmtautofmt.hxx>
+#include <hintids.hxx>
+#include <../text/itratr.hxx>
+#include <svx/wghtitem.hxx>
+#include <fmtfsize.hxx>
+#include <svx/lrspitem.hxx>
+#include <frmatr.hxx>
+#include <flypos.hxx>
+#include <fmtanchr.hxx>
+#include <section.hxx>
+#include <fmtclds.hxx>
+#include <pagedesc.hxx>
+#include <fmtcntnt.hxx>
+
+#include <stdio.h>
+
+int cmp_SwPosFlyFrm(const void *a, const void *b) {
+  const SwPosFlyFrm *pFly1=*((const SwPosFlyFrm **)a);
+  const SwPosFlyFrm *pFly2=*((const SwPosFlyFrm **)b);
+  int idx1=pFly1->GetNdIndex().GetIndex();
+  int idx2=pFly2->GetNdIndex().GetIndex();
+  if (idx1==idx2) {
+    const SwFrmFmt &rFlyFmt1=pFly1->GetFmt();
+    const SwFrmFmt &rFlyFmt2=pFly2->GetFmt();
+    const SwFmtAnchor &rFlyAnchor1=rFlyFmt1.GetAnchor();
+    const SwFmtAnchor &rFlyAnchor2=rFlyFmt2.GetAnchor();
+    const SwPosition *pFlyAnchorPos1=rFlyAnchor1.GetCntntAnchor();
+    const SwPosition *pFlyAnchorPos2=rFlyAnchor2.GetCntntAnchor();
+    int ofs1=(pFlyAnchorPos1!=NULL?(int)pFlyAnchorPos1->nContent.GetIndex():0);
+    int ofs2=(pFlyAnchorPos2!=NULL?(int)pFlyAnchorPos2->nContent.GetIndex():0);
+    if (ofs1==ofs2) {
+      return (int)(pFly1-pFly2);
+    } else {
+      return ofs1-ofs2;
+    }
+  } else {
+    return idx1-idx2;
+  }
+}
+
+SwDocumentProvider::SwDocumentProvider(SwDocShell* pShell, 
+				       SwDocumentProvider *pParent) 
+  : m_pShell(pShell), m_pDoc(pShell!=NULL?pShell->GetDoc():NULL),
+    m_pFlyFrms(NULL),
+    m_pNodeIndex(NULL), m_pEndIndex(NULL), m_pPos(NULL), 
+    m_pFlyStart(0), m_pFlyEnd(0),
+    m_pAttrItr(NULL), m_pScriptInfo(NULL), m_pItemSet(NULL), 
+    m_nTableGridX(0),
+    m_pCachedBox(NULL), m_nChachedBoxRow(0), m_nChachedBoxCol(0), m_nChachedRowCells(0) {
+  if (m_pDoc){ 
+    m_pItemSet=new SfxItemSet(m_pDoc->GetAttrPool(), TRUE);
+    m_pFlyFrms=new SwPosFlyFrms();
+    m_pDoc->GetAllFlyFmts(*m_pFlyFrms, NULL, sal_True);
+    const SwPosFlyFrm * const *pData=m_pFlyFrms->GetData();
+    qsort((void*)pData, 
+	  m_pFlyFrms->Count(), 
+	  sizeof(const SwPosFlyFrm *), 
+	  cmp_SwPosFlyFrm);
+    for(int i=0;i<(int)m_pFlyFrms->Count();i++) {
+      const SwPosFlyFrm *pFlyFrm=(*m_pFlyFrms)[i];
+      const SwFrmFmt &rFlyFmt=pFlyFrm->GetFmt();
+      SwRect aLayRect(rFlyFmt.FindLayoutRect());
+      const SwFmtAnchor &rFlyAnchor=rFlyFmt.GetAnchor();
+      const SwPosition *pFlyAnchorPos=rFlyAnchor.GetCntntAnchor();
+      SwRect aPageRect( pFlyFrm->GetNdIndex().GetNode().GetCntntNode()->FindPageFrmRect());
+      printf("#%i: %i %i[%i (%li, %li, %li, %li)(%li, %li, %li, %li)]:%p\n", i, (int)pFlyFrm->GetNdIndex().GetIndex(), 
+	     (pFlyAnchorPos!=NULL?(int)pFlyAnchorPos->nContent.GetIndex():-1),
+	     aLayRect.IsEmpty(), 
+	     aLayRect.Left(), aLayRect.Top(), aLayRect.Width(), aLayRect.Height(),
+	     aPageRect.Left(), aPageRect.Top(), aPageRect.Width(), aPageRect.Height(),
+	     pFlyFrm);
+    }    
+  }
+}
+
+SwDocumentProvider::~SwDocumentProvider() {
+  if (m_pNodeIndex!=NULL) {
+    delete m_pNodeIndex;
+  }
+  if (m_pEndIndex!=NULL) {
+    delete m_pEndIndex;
+  }
+  if (m_pPos!=NULL) {
+    delete m_pPos;
+  }
+  if (m_pAttrItr!=NULL) {
+    delete m_pAttrItr;
+  }
+  if (m_pScriptInfo!=NULL) {
+    delete m_pScriptInfo;
+  }
+  if (m_pItemSet!=NULL) {
+    delete m_pItemSet;
+  }
+  if (m_pFlyFrms!=NULL) {
+    delete m_pFlyFrms;
+  }
+}
+
+void SwDocumentProvider::ensure(sal_Bool exp) throw (::com::sun::star::uno::RuntimeException) {
+ 
+}
+
+int SwDocumentProvider::calcCellXForRow(SwTable *pTable, SwTableLine *pRow, int *cellx) {
+  int c=-1;
+  const SwFrmFmt *pTableFmt = pTable->GetFrmFmt();
+  cellx[0]=pTable->GetFrmFmt()->GetLRSpace().GetLeft();
+  for(c=0;c<pRow->GetTabBoxes().Count() && c<MAXCELLX;c++) {
+    SwTableBox *pBox=pRow->GetTabBoxes()[c];
+    int rowSpan=(int)pBox->getRowSpan();
+    const SwFrmFmt* pBoxFmt = pBox->GetFrmFmt();
+    //    Point aPt;
+    SwRect aBoxRect( pBoxFmt->FindLayoutRect( false /*,&aPt*/ ));
+    cellx[c+1]=cellx[c]+aBoxRect.Width();
+  }
+  return c+1;
+}
+
+int SwDocumentProvider::calcGridForTable(SwTable *pTable, int *cellx_) {
+    int gridx[2][MAXCELLX];
+    int ngridx[2] = {0 ,0 };
+    int ga=0;
+    int gn=1;
+    printf("pTable=%p\n", pTable);
+    printf("nRows=%i\n", (int)pTable->GetTabLines().Count());
+    for(int r=0;r<pTable->GetTabLines().Count();r++) {
+      SwTableLine *pRow=pTable->GetTabLines()[r];
+      int cellx[MAXCELLX];
+      int ncellx=calcCellXForRow(pTable, pRow, cellx);
+      ngridx[gn]=0;
+      int i=0;
+      int j=0;
+
+      printf("ngridx[ga]=%i\n", ngridx[ga]);
+      for(int k=0;k<ngridx[ga];k++) {
+	printf("<%i> ", gridx[ga][k]);
+      }
+      printf("\n");
+      for(int k=0;k<ncellx;k++) {
+	printf("%i ", cellx[k]);
+      }
+      printf("\n");
+
+
+      while(i<ncellx && j<ngridx[ga] && ngridx[gn]<MAXCELLX) {
+	if (cellx[i]==gridx[ga][j]) {
+	  gridx[gn][ngridx[gn]++]=cellx[i];
+	  i++; j++;
+	} else if (cellx[i]<gridx[ga][j]) {
+	  gridx[gn][ngridx[gn]++]=cellx[i];
+	  i++;
+	} else {
+	  gridx[gn][ngridx[gn]++]=gridx[ga][j];
+	  j++;
+	}
+      }
+      for(;i<ncellx  && ngridx[gn]<MAXCELLX;i++) {
+	  gridx[gn][ngridx[gn]++]=cellx[i];
+      }
+      for(;j<ngridx[ga] && ngridx[gn]<MAXCELLX;j++) {
+	  gridx[gn][ngridx[gn]++]=gridx[ga][j];
+      }
+      for(int k=0;k<ngridx[gn];k++) {
+	printf("<%i> ", gridx[gn][k]);
+      }
+      printf("\n");
+
+      { int dummy=gn; gn=ga; ga=dummy; }
+    }
+    printf("ngridx[ga]=%i\n", ngridx[ga]);
+    for(int i=0;i<ngridx[ga];i++) {
+      cellx_[i]=gridx[ga][i];
+      printf("[%i] ", gridx[ga][i]);
+    }
+    printf("\n");
+    return ngridx[ga];
+}
+
+
+
+void SwDocumentProvider::update(xub_StrLen parOfs) {
+  if (m_pAttrItr!=NULL) { delete m_pAttrItr; m_pAttrItr=NULL; }
+  if (m_pScriptInfo!=NULL) { delete m_pScriptInfo; m_pScriptInfo=NULL; }
+  if (m_pPos!=NULL) { delete m_pPos; m_pPos=NULL; }
+  m_pFlyStart=m_pFlyEnd=0;
+  m_pCachedBox=NULL;  m_nChachedBoxRow=m_nChachedBoxCol=0; m_nChachedRowCells=0;
+
+  if (m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().GetCntntNode()!=NULL) {
+    m_pPos=new SwPosition(*m_pNodeIndex->GetNode().GetCntntNode(), SwIndex(m_pNodeIndex->GetNode().GetCntntNode(), parOfs));
+  }
+  
+  if (m_pPos!=NULL && m_pPos->nNode.GetNode().IsTxtNode()) {    
+    SwTxtNode *pTxtNode= m_pPos->nNode.GetNode().GetTxtNode();
+    m_pScriptInfo=new SwScriptInfo();
+    m_pAttrItr=new SwAttrIter(*pTxtNode, *m_pScriptInfo);    
+    getFlys(m_pFlyStart, m_pFlyEnd);
+  }
+
+  m_nTableGridX=0;
+  if (m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().IsTableNode()) {
+    SwTable *pTable=&m_pNodeIndex->GetNode().GetTableNode()->GetTable();
+    m_nTableGridX=calcGridForTable(pTable, m_tableGridX);
+  }
+}
+
+void SAL_CALL SwDocumentProvider::moveToMainContent(  ) throw (::com::sun::star::uno::RuntimeException) {
+  moveTo(new SwNodeIndex( m_pDoc->GetNodes().GetEndOfExtras(), 2 ),
+	 new SwNodeIndex( m_pDoc->GetNodes().GetEndOfContent()));
+}
+
+void SwDocumentProvider::moveTo(SwNodeIndex *startIdx, SwNodeIndex *endIdx) {
+  if (m_pNodeIndex!=NULL) delete m_pNodeIndex;
+  if (m_pEndIndex!=NULL) delete m_pEndIndex;
+  m_pNodeIndex=startIdx;
+  m_pEndIndex=endIdx;
+  update();
+}
+
+::rtl::OUString SAL_CALL SwDocumentProvider::getTxt(  ) throw (::com::sun::star::uno::RuntimeException) {
+  ::rtl::OUString ret;
+  if (m_pPos!=NULL && m_pPos->nNode.GetNode().IsTxtNode()) {
+    ret=m_pPos->nNode.GetNode().GetTxtNode()->GetTxt();
+  }
+  return ret;
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getTxtLen(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return (m_pPos!=NULL && m_pPos->nNode.GetNode().IsTxtNode()
+	  ? m_pPos->nNode.GetNode().GetTxtNode()->Len()
+	  : 0);
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getTxtOfs(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return 0; //@TODO return ofs from pos..
+}
+
+::sal_Bool SAL_CALL SwDocumentProvider::checkFlys( ::sal_Int32& ofsStart, ::sal_Int32& ofsEnd, ::sal_Int32& flyStart, ::sal_Int32& flyEnd ) throw (::com::sun::star::uno::RuntimeException) {
+  printf("ofsStart=%i ofsEnd=%i\n", (int)ofsStart, (int)ofsEnd);
+  ::sal_Bool ret=sal_False;
+  flyStart=std::max(flyStart, m_pFlyStart);
+  flyEnd=flyStart;
+  if (m_pFlyStart<m_pFlyEnd) {
+    sal_Int32 flyOfs=ofsEnd;
+    while(flyStart<m_pFlyEnd && (flyOfs=getFlyAnchorTxtOfs(flyStart))<ofsStart) flyStart++;
+    if (flyStart<m_pFlyEnd && flyOfs==ofsStart && flyOfs<ofsEnd) {
+      // we have flys in the range      
+      flyEnd=flyStart+1;
+      while(flyEnd<m_pFlyEnd && (flyOfs=getFlyAnchorTxtOfs(flyEnd))==ofsStart) flyEnd++;
+      if (flyEnd<m_pFlyEnd)
+	ofsEnd=std::min(ofsEnd, flyOfs);
+      ret=sal_True;
+    } else if (flyStart<m_pFlyEnd && flyOfs>ofsStart && flyOfs<ofsEnd){
+      ofsEnd=flyOfs;
+      flyEnd=flyStart;
+    }
+  }
+  printf("ofsStart=%i ofsEnd=%i\n", (int)ofsStart, (int)ofsEnd);
+  return ret;
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::loadPortion( ::sal_Int32 ofs ) throw (::com::sun::star::uno::RuntimeException) {
+  if (m_pPos!=NULL 
+      && m_pPos->nNode.GetNode().IsTxtNode() 
+      && m_pAttrItr!=NULL) {    
+    SwTxtNode *pTxtNode= m_pPos->nNode.GetNode().GetTxtNode();
+    const String &_txt=pTxtNode->GetTxt();
+    const sal_Unicode* _txtBuf=_txt.GetBuffer();
+    xub_StrLen txtLen=pTxtNode->Len();
+    m_pAttrItr->Seek(ofs);
+    xub_StrLen nextOfs=m_pAttrItr->GetNextAttr();
+    if (nextOfs>txtLen) nextOfs=txtLen;
+    { // looks for a special char
+      int _ofs=ofs;
+      while(_ofs<nextOfs && _txtBuf[_ofs]>=32) _ofs++;
+      if (_ofs==ofs && _ofs<nextOfs) _ofs++;
+      nextOfs=_ofs;
+    }
+    if (m_pItemSet!=NULL) {
+      m_pItemSet->ClearItem(0); // all
+      pTxtNode->GetAttr(*m_pItemSet, ofs, nextOfs);
+    }
+    return nextOfs;
+  } else {
+    return -1; 
+  }
+}
+
+::sal_Int8 SAL_CALL SwDocumentProvider::getFontWeight(  ) throw (::com::sun::star::uno::RuntimeException) {
+  ::sal_Int8 ret=0;
+  const SvxWeightItem * pWeight=(SvxWeightItem*)(m_pItemSet!=NULL?m_pItemSet->GetItem(RES_CHRATR_WEIGHT, FALSE):NULL);
+  if (pWeight!=NULL) {
+    switch(pWeight->GetWeight()) {
+    case WEIGHT_DONTKNOW: ret=0; break;
+    default: ret=100; break;
+    }
+  }
+  return ret;
+}
+
+
+::sal_Bool SAL_CALL SwDocumentProvider::hasNode(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return m_pNodeIndex!=NULL && m_pEndIndex!=NULL
+    && *m_pNodeIndex<*m_pEndIndex;
+}
+
+::sal_Bool SAL_CALL SwDocumentProvider::isTxtNode(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().IsTxtNode();
+}
+
+::sal_Bool SAL_CALL SwDocumentProvider::isTableNode(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().IsTableNode();
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getNodeIndex(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return m_pNodeIndex!=NULL?m_pNodeIndex->GetIndex():-1;
+}
+
+
+void SAL_CALL SwDocumentProvider::consume(  ) throw (::com::sun::star::uno::RuntimeException) {
+  if (m_pNodeIndex!=NULL && m_pEndIndex!=NULL && *m_pNodeIndex<*m_pEndIndex) {
+    if (m_pNodeIndex->GetNode().IsTableNode()) {
+      SwTableNode *pTableNode=m_pNodeIndex->GetNode().GetTableNode();
+      *m_pNodeIndex=*pTableNode->EndOfSectionNode();
+      (*m_pNodeIndex)++;
+    } else {
+      (*m_pNodeIndex)++; // consume node
+    }
+  }  
+  while(m_pNodeIndex!=NULL && m_pEndIndex!=NULL && // skip section and endnodes
+	*m_pNodeIndex<*m_pEndIndex && 
+	(m_pNodeIndex->GetNode().IsSectionNode() || 
+	 m_pNodeIndex->GetNode().IsEndNode())) {
+    (*m_pNodeIndex)++;
+  }
+  
+  update();
+}
+
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getColumns(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return m_nTableGridX-1;
+}
+
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getColumn( ::sal_Int32 i ) throw (::com::sun::star::uno::RuntimeException) {
+  return 0;
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getRows(  ) throw (::com::sun::star::uno::RuntimeException) {
+ if (m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().IsTableNode()) {
+   SwTable *pTable=&m_pNodeIndex->GetNode().GetTableNode()->GetTable();
+   return pTable->GetTabLines().Count();
+ } else {
+   return 0;
+ }
+}
+
+void SwDocumentProvider::ensureCellCache(int row, int col) {
+  if (m_pCachedBox!=NULL && m_nChachedBoxRow==row && m_nChachedBoxCol==col) {
+    // cache hit
+  } else {
+    if (m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().IsTableNode()) {
+      SwTable *pTable=&m_pNodeIndex->GetNode().GetTableNode()->GetTable();
+      const SwFrmFmt *pTableFmt = (pTable!=NULL?pTable->GetFrmFmt():NULL);
+      if (pTable!=NULL && pTableFmt!=NULL && row>=0 && row<pTable->GetTabLines().Count() && col>0 && col<m_nTableGridX) {
+	SwTableLine *pRow=pTable->GetTabLines()[row];
+	if (pRow!=NULL) {    
+	  if (m_pCachedBox!=NULL && row==m_nChachedBoxRow) {
+	    // cache hit
+	  } else {
+	    m_nChachedRowCells=calcCellXForRow(pTable, pRow, m_nChachedRowCellx);
+	  }
+	  ensure(m_nChachedRowCells<=m_nTableGridX);
+	  int c=1;
+	  while(c<m_nChachedRowCells && m_nChachedRowCellx[c-1]<m_tableGridX[col-1]) c++;	  
+	  ensure(c>0 && c<m_nChachedRowCells); // is has to be in the grid!
+
+	  m_nChachedBoxCellx=c;
+	  m_nChachedBoxRow=row;
+	  m_nChachedBoxCol=col;
+	  m_pCachedBox=pRow->GetTabBoxes()[m_nChachedBoxCellx-1];
+	  m_pCachedStartOfRowSpan=&m_pCachedBox->FindStartOfRowSpan(*pTable);
+	}
+      }
+    }
+  }
+}
+
+::com::sun::star::uno::Reference< ::org::openoffice::DocumentProvider > SAL_CALL SwDocumentProvider::openCell( ::sal_Int32 row, ::sal_Int32 column ) throw (::com::sun::star::uno::RuntimeException) {
+  SwDocumentProvider *ret=NULL;
+  ensureCellCache(row, column+1); // +1 because cellx[0] is the left indent
+  if (m_pCachedBox!=NULL 
+      && m_pCachedBox==m_pCachedStartOfRowSpan // make sure this is not a covered cell
+      && m_nChachedRowCellx[m_nChachedBoxCellx-1]==m_tableGridX[column]) {
+    const SwStartNode *pCellStart=m_pCachedBox->GetSttNd();
+    const SwEndNode *pCellEnd=pCellStart->EndOfSectionNode();
+    ret=new SwDocumentProvider(m_pShell, this);
+    ret->moveTo(new SwNodeIndex(*pCellStart, 1), 
+		new SwNodeIndex(*pCellEnd));
+  }
+  return ret;
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getRowSpan( ::sal_Int32 row, ::sal_Int32 column ) throw (::com::sun::star::uno::RuntimeException) {
+  ensureCellCache(row, column+1);
+  if (m_pCachedBox!=NULL) {
+    return m_pCachedBox->getRowSpan();
+  } else {
+    return 0;
+  }
+}
+
+::sal_Int32 SAL_CALL SwDocumentProvider::getColSpan( ::sal_Int32 row, ::sal_Int32 column ) throw (::com::sun::star::uno::RuntimeException) {
+  ensureCellCache(row, column+1);
+  if (m_pCachedBox!=NULL) {
+    int span=1;
+    while(column+span<m_nTableGridX 
+	  && m_tableGridX[column+span]<m_nChachedRowCellx[m_nChachedBoxCellx]) 
+      span++;
+    return span;
+  } else {
+    return 0;
+  }
+}
+
+
+
+::sal_Bool SwDocumentProvider::getFlys( ::sal_Int32& start, ::sal_Int32& end ) {
+  start=m_pFlyFrms->Count();
+  end=m_pFlyFrms->Count();
+  if (m_pNodeIndex!=NULL && m_pNodeIndex->GetNode().IsCntntNode()) {
+    //@TODO!!! the m_pFlyFrms is sorted by the index, so a binary search
+    //         is the way to go here....
+    for(int i=0;i<m_pFlyFrms->Count();i++) {
+      const SwPosFlyFrm *pFlyFrm=(*m_pFlyFrms)[i];
+      if (pFlyFrm->GetNdIndex()==*m_pNodeIndex) {
+	start=i; break;
+      }      
+    }
+    if (start<m_pFlyFrms->Count()) {
+      end=start;
+      do {
+	end++;
+      } while(end<m_pFlyFrms->Count() && (*m_pFlyFrms)[end]->GetNdIndex()==*m_pNodeIndex);
+    }
+  } 
+  return start<end;
+}
+
+::com::sun::star::uno::Reference< ::org::openoffice::DocumentProvider > SAL_CALL SwDocumentProvider::openFly( ::sal_Int32 fly ) throw (::com::sun::star::uno::RuntimeException) {
+  SwDocumentProvider *ret=NULL;
+  const SwPosFlyFrm *pFlyFrm=(m_pFlyFrms!=NULL && fly>=0 && fly<m_pFlyFrms->Count()?(*m_pFlyFrms)[fly]:NULL);
+  if (pFlyFrm!=NULL) {
+    const SwFrmFmt &rFlyFmt=pFlyFrm->GetFmt();
+    const SwFmtCntnt &rCntnt = rFlyFmt.GetCntnt();
+    const SwNodeIndex *pStartIdx=rCntnt.GetCntntIdx();
+    if (pStartIdx!=NULL && pStartIdx->GetNode().IsStartNode()) {
+      const SwEndNode *pEndNode=pStartIdx->GetNode().GetStartNode()->EndOfSectionNode();
+      ret=new SwDocumentProvider(m_pShell, this);
+      ret->moveTo(new SwNodeIndex(*pStartIdx, 1), 
+      		  new SwNodeIndex(*pEndNode));
+    }
+  };
+
+  return ret;
+}
+
+::sal_Int32 SwDocumentProvider::getFlyAnchorTxtOfs( ::sal_Int32 fly ) {
+  ::sal_Int32 ret=-1;
+  const SwPosFlyFrm *pFlyFrm=(m_pFlyFrms!=NULL && fly>=0 && fly<m_pFlyFrms->Count()?(*m_pFlyFrms)[fly]:NULL);
+  if (pFlyFrm!=NULL) {
+    const SwFrmFmt &rFlyFmt=pFlyFrm->GetFmt();
+    const SwFmtAnchor &rFlyAnchor=rFlyFmt.GetAnchor();
+    const SwPosition *pFlyAnchorPos=rFlyAnchor.GetCntntAnchor();
+    ret=(pFlyAnchorPos!=NULL?pFlyAnchorPos->nContent.GetIndex():0);
+  };
+  return ret;
+}
+
+::sal_Bool SAL_CALL SwDocumentProvider::getFlyPositionRelativeToPage( ::sal_Int32 fly, ::sal_Int32& x, ::sal_Int32& y, ::sal_Int32& w, ::sal_Int32& h ) throw (::com::sun::star::uno::RuntimeException) {
+  ::sal_Bool ret=false;
+  const SwPosFlyFrm *pFlyFrm=(m_pFlyFrms!=NULL && fly>=0 && fly<m_pFlyFrms->Count()?(*m_pFlyFrms)[fly]:NULL);
+  if (pFlyFrm!=NULL) {
+    const SwFrmFmt &rFlyFmt=pFlyFrm->GetFmt();
+    SwRect aLayRect(rFlyFmt.FindLayoutRect());
+    SwRect aPageRect( pFlyFrm->GetNdIndex().GetNode().GetCntntNode()->FindPageFrmRect());
+    ret=!aLayRect.IsEmpty() && !aPageRect.IsEmpty();
+    if (ret) {
+      x=aLayRect.Left()-aPageRect.Left();
+      y=aLayRect.Top()-aPageRect.Top();
+      w=aLayRect.Width();
+      h=aLayRect.Height();
+    } else {
+      x=0; //@TODO: what if no layout is present???
+      y=0;
+      w=0;
+      h=0;
+    }
+  }  
+  return ret;
+}
+
+
+void SAL_CALL SwDocumentProvider::getSectionPr( ::sal_Int32 idx, ::com::sun::star::uno::Sequence< ::sal_Int32 >& dxaColumns ) throw (::com::sun::star::uno::RuntimeException) {
+  const SwFmtCol *pFmtCol=NULL;  
+  const SwFrmFmt *pPageFmt=NULL;
+  if (m_pDoc!=NULL && idx>=0) {
+    SwNodeIndex aNodeIndex(m_pDoc->GetNodes(), ULONG(idx));
+    const SwPageDesc *pPageDesc=SwPageDesc::GetPageDescOfNode(aNodeIndex.GetNode());
+    if (pPageDesc!=NULL) {
+      //@TODO figure out whether left page is used...
+      pPageFmt=&pPageDesc->GetMaster();
+      if (pPageFmt->GetCol().GetNumCols()>1) {
+	pFmtCol=&pPageFmt->GetCol();
+      }
+    }
+    if (pFmtCol==NULL) {
+      SwSection* pSection=NULL;
+      SwSectionNode *pSectionNode=NULL;
+      SwSectionNode *pTmpNode=aNodeIndex.GetNode().FindSectionNode();
+      SwSection* pTmp=(pTmpNode!=NULL&&pTmpNode->IsSectionNode()?&pTmpNode->GetSection():NULL);;
+      while(pTmp!=NULL) {
+	printf("%p \n", pTmp);
+	if(pTmp->GetFmt()->GetCol().GetNumCols()>1) {
+	  pFmtCol=&pTmp->GetFmt()->GetCol();	  
+	  pTmp=pTmp->GetParent();
+	}
+      }
+    }
+  }
+  if (pFmtCol!=NULL) {
+    printf("pFmtCol->GetWishWidth=%i\n", pFmtCol->GetWishWidth());
+    dxaColumns.realloc(pFmtCol->GetNumCols());
+    for (int i=0;i<dxaColumns.getLength();i++) {
+      dxaColumns[i]=pFmtCol->GetColumns()[i]->GetWishWidth();
+    }
+  } else {
+    //error...
+  }
+}
+
+::sal_Int8 SAL_CALL SwDocumentProvider::getBreakType(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return 0; //@TODO check for section breaks...
+}
diff --git a/sw/source/core/ooapi/makefile.mk b/sw/source/core/ooapi/makefile.mk
new file mode 100644
index 0000000..ddaff82
--- /dev/null
+++ sw/source/core/ooapi/makefile.mk
@@ -0,0 +1,27 @@
+PRJ=..$/..$/..
+
+PRJNAME=sw
+TARGET=ooapi
+
+# --- Settings -----------------------------------------------------
+#ENABLE_EXCEPTIONS=TRUE
+
+.INCLUDE :	$(PRJ)$/inc$/swpre.mk
+.INCLUDE :	settings.mk
+.INCLUDE :	$(PRJ)$/inc$/sw.mk
+
+CDEFS+=-I..$/text
+
+# --- Files --------------------------------------------------------
+EXCEPTIONSFILES=	\
+SRS1NAME=$(TARGET)
+SRC1FILES =
+SLOFILES =	\
+    $(SLO)$/SwDocumentBuilder.obj \
+    $(SLO)$/SwDocumentProvider.obj
+
+# --- Targets -------------------------------------------------------
+
+
+.INCLUDE :	target.mk
+
diff --git a/sw/source/ui/uno/unotxdoc.cxx b/sw/source/ui/uno/unotxdoc.cxx
index 7caf0a7..b5f3c4a 100644
--- sw/source/ui/uno/unotxdoc.cxx
+++ sw/source/ui/uno/unotxdoc.cxx
@@ -116,6 +116,7 @@
 #include <EnhancedPDFExportHelper.hxx>
 // <--
 #include <numrule.hxx>
+#include <ooapi.hxx>
 
 ///////////////////////////Modified on Jun. 14th//////////////////////////
 ///////////////////////for getDocumentLanguages///////////////////////////
@@ -2878,6 +2879,17 @@ uno::Reference< text::XFlatParagraphIterator > SAL_CALL SwXTextDocument::getFlat
     return new SwXFlatParagraphIterator( *pDocShell->GetDoc(), nTextMarkupType, bAutomatic );
 }
 
+/* --------------------------------------------------------------------------
+
+ ---------------------------------------------------------------------------*/
+uno::Reference< ::org::openoffice::DocumentBuilder > SAL_CALL SwXTextDocument::createDocumentBuilder(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return new SwDocumentBuilder(pDocShell);
+}
+
+uno::Reference< ::org::openoffice::DocumentProvider > SAL_CALL SwXTextDocument::createDocumentProvider(  ) throw (::com::sun::star::uno::RuntimeException) {
+  return new SwDocumentProvider(pDocShell);
+}
+
 /* -----------------------------20.06.00 09:54--------------------------------
 
  ---------------------------------------------------------------------------*/
