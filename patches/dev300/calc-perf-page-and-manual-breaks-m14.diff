--- sc/inc/document.hxx.old	2010-03-03 16:59:15.000000000 +0100
+++ sc/inc/document.hxx	2010-03-03 16:59:18.000000000 +0100
@@ -47,6 +47,7 @@
 
 #include <memory>
 #include <map>
+#include <set>
 
 class KeyEvent;
 class OutputDevice;
@@ -154,6 +155,9 @@ namespace com { namespace sun { namespac
     namespace embed {
         class XEmbeddedObject;
     }
+    namespace sheet {
+        struct TablePageBreakData;
+    }
 } } }
 
 #include <svtools/zforlist.hxx>
@@ -1290,6 +1294,24 @@ public:
     SC_DLLPUBLIC const ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArray( SCTAB nTab ) const;
     SC_DLLPUBLIC       ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArrayModifiable( SCTAB nTab );
 
+    SC_DLLPUBLIC void           GetAllRowBreaks(::std::set<SCROW>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const;
+    SC_DLLPUBLIC void           GetAllColBreaks(::std::set<SCCOL>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const;
+    SC_DLLPUBLIC ScBreakType    HasRowBreak(SCROW nRow, SCTAB nTab) const;
+    SC_DLLPUBLIC ScBreakType    HasColBreak(SCCOL nCol, SCTAB nTab) const;
+    SC_DLLPUBLIC void           SetRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual);
+    SC_DLLPUBLIC void           SetColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual);
+    void                        RemoveRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual);
+    void                        RemoveColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual);
+    ::com::sun::star::uno::Sequence<
+        ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData(SCTAB nTab) const;
+
+    /** 
+     * Write all column row flags to table's flag data, because not all column 
+     * row attributes are stored in the flag data members.  This is necessary 
+     * for ods export. 
+     */
+    void                        SyncColRowFlags();
+
                     /// @return  the index of the last row with any set flags (auto-pagebreak is ignored).
     SC_DLLPUBLIC SCROW			GetLastFlaggedRow( SCTAB nTab ) const;
 
@@ -1329,6 +1351,7 @@ public:
     Size			GetPageSize( SCTAB nTab ) const;
     void			SetPageSize( SCTAB nTab, const Size& rSize );
     void			SetRepeatArea( SCTAB nTab, SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCROW nEndRow );
+    void            InvalidatePageBreaks(SCTAB nTab);
     void			UpdatePageBreaks( SCTAB nTab, const ScRange* pUserArea = NULL );
     void			RemoveManualBreaks( SCTAB nTab );
     BOOL			HasManualBreaks( SCTAB nTab ) const;
--- sc/inc/global.hxx.old	2010-03-03 16:59:11.000000000 +0100
+++ sc/inc/global.hxx	2010-03-03 16:59:18.000000000 +0100
@@ -206,13 +206,16 @@ const SCSIZE PIVOT_MAXPAGEFIELD = 10;
                                     // FILTERED und MANUALSIZE nur fuer Zeilen moeglich
 const BYTE   CR_HIDDEN      = 1;
 //const BYTE CR_MARKED      = 2;
-const BYTE   CR_PAGEBREAK   = 4;
+//const BYTE CR_PAGEBREAK   = 4;
 const BYTE   CR_MANUALBREAK = 8;
 const BYTE   CR_FILTERED    = 16;
 const BYTE   CR_MANUALSIZE  = 32;
+const BYTE   CR_ALL         = (CR_HIDDEN | CR_MANUALBREAK | CR_FILTERED | CR_MANUALSIZE);
 
-//	was davon kommt in die Datei:
-#define CR_SAVEMASK		( ~CR_PAGEBREAK )
+typedef BYTE ScBreakType;
+const ScBreakType BREAK_NONE   = 0;
+const ScBreakType BREAK_PAGE   = 1;
+const ScBreakType BREAK_MANUAL = 2;
 
 // Insert-/Delete-Flags
 const USHORT IDF_NONE       = 0x0000;
--- sc/inc/table.hxx.old	2010-03-03 16:59:17.000000000 +0100
+++ sc/inc/table.hxx	2010-03-03 16:59:18.000000000 +0100
@@ -42,12 +42,19 @@
 #include "compressedarray.hxx"
 
 #include <memory>
+#include <set>
 
 namespace utl {
     class SearchParam;
     class TextSearch;
 }
 
+namespace com { namespace sun { namespace star {
+    namespace sheet {
+        struct TablePageBreakData;
+    }
+} } }
+
 class SfxItemSet;
 class SfxStyleSheetBase;
 class SvxBoxInfoItem;
@@ -119,6 +126,11 @@ private:
     BYTE*			pColFlags;
     ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
 
+    ::std::set<SCROW>                      maRowPageBreaks;
+    ::std::set<SCROW>                      maRowManualBreaks;
+    ::std::set<SCCOL>                      maColPageBreaks;
+    ::std::set<SCCOL>                      maColManualBreaks;
+
     ScOutlineTable*	pOutlineTable;
 
     SCCOL			nTableAreaX;
@@ -158,6 +170,7 @@ private:
     Color			aScenarioColor;
     USHORT			nScenarioFlags;
     BOOL			bActiveScenario;
+    bool            mbPageBreaksValid;
 
 friend class ScDocument;					// fuer FillInfo
 friend class ScDocumentIterator;
@@ -363,7 +376,8 @@ public:
 
     void		CopyUpdated( const ScTable* pPosTab, ScTable* pDestTab ) const;
 
-    void		InvalidateTableArea()						{ bTableAreaValid = FALSE; }
+    void        InvalidateTableArea();
+    void        InvalidatePageBreaks();
 
     BOOL		GetCellArea( SCCOL& rEndCol, SCROW& rEndRow ) const;			// FALSE = leer
     BOOL		GetTableArea( SCCOL& rEndCol, SCROW& rEndRow ) const;
@@ -633,6 +647,21 @@ public:
     void		RemoveManualBreaks();
     BOOL		HasManualBreaks() const;
 
+    void        GetAllRowBreaks(::std::set<SCROW>& rBreaks, bool bPage, bool bManual) const;
+    void        GetAllColBreaks(::std::set<SCCOL>& rBreaks, bool bPage, bool bManual) const;
+    bool        HasRowPageBreak(SCROW nRow) const;
+    bool        HasColPageBreak(SCCOL nCol) const;
+    bool        HasRowManualBreak(SCROW nRow) const;
+    bool        HasColManualBreak(SCCOL nCol) const;
+    void        RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow);
+    void        RemoveRowBreak(SCROW nRow, bool bPage, bool bManual);
+    void        RemoveColBreak(SCCOL nCol, bool bPage, bool bManual);
+    void        SetRowBreak(SCROW nRow, bool bPage, bool bManual);
+    void        SetColBreak(SCCOL nCol, bool bPage, bool bManual);
+    ::com::sun::star::uno::Sequence<
+        ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData() const;
+    void        SyncColRowFlags();
+
     void		StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
     void		ExtendHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
 
--- sc/source/core/data/document.cxx.old	2010-03-03 16:59:15.000000000 +0100
+++ sc/source/core/data/document.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -54,6 +54,7 @@
 #include <tools/tenccvt.hxx>
 
 #include <com/sun/star/text/WritingMode2.hpp>
+#include <com/sun/star/sheet/TablePageBreakData.hpp>
 
 #include "document.hxx"
 #include "table.hxx"
@@ -98,6 +99,9 @@
 #include <map>
 
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::sheet::TablePageBreakData;
+using ::std::set;
 
 struct ScDefaultAttr
 {
@@ -3390,6 +3394,102 @@ const ScBitMaskCompressedArray< SCROW, B
     return *pFlags;
 }
 
+void ScDocument::GetAllRowBreaks(set<SCROW>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->GetAllRowBreaks(rBreaks, bPage, bManual);
+}
+
+void ScDocument::GetAllColBreaks(set<SCCOL>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->GetAllColBreaks(rBreaks, bPage, bManual);
+}
+
+ScBreakType ScDocument::HasRowBreak(SCROW nRow, SCTAB nTab) const
+{
+    ScBreakType nType = BREAK_NONE;
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return nType;
+
+    if (pTab[nTab]->HasRowPageBreak(nRow))
+        nType |= BREAK_PAGE;
+
+    if (pTab[nTab]->HasRowManualBreak(nRow))
+        nType |= BREAK_MANUAL;
+
+    return nType;
+}
+
+ScBreakType ScDocument::HasColBreak(SCCOL nCol, SCTAB nTab) const
+{
+    ScBreakType nType = BREAK_NONE;
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return nType;
+
+    if (pTab[nTab]->HasColPageBreak(nCol))
+        nType |= BREAK_PAGE;
+
+    if (pTab[nTab]->HasColManualBreak(nCol))
+        nType |= BREAK_MANUAL;
+
+    return nType;
+}
+
+void ScDocument::SetRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return;
+
+    pTab[nTab]->SetRowBreak(nRow, bPage, bManual);
+}
+
+void ScDocument::SetColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return;
+
+    pTab[nTab]->SetColBreak(nCol, bPage, bManual);
+}
+
+void ScDocument::RemoveRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return;
+
+    pTab[nTab]->RemoveRowBreak(nRow, bPage, bManual);
+}
+
+void ScDocument::RemoveColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return;
+
+    pTab[nTab]->RemoveColBreak(nCol, bPage, bManual);
+}
+
+Sequence<TablePageBreakData> ScDocument::GetRowBreakData(SCTAB nTab) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return Sequence<TablePageBreakData>();
+
+    return pTab[nTab]->GetRowBreakData();
+}
+
+void ScDocument::SyncColRowFlags()
+{
+    for (SCTAB i = 0; i <= nMaxTableNumber; ++i)
+    {
+        if (!ValidTab(i) || !pTab[i])
+            continue;
+
+        pTab[i]->SyncColRowFlags();
+    }
+}
 
 SCROW ScDocument::GetLastFlaggedRow( SCTAB nTab ) const
 {
@@ -4775,6 +4875,11 @@ void ScDocument::SetRepeatArea( SCTAB nT
         pTab[nTab]->SetRepeatArea( nStartCol, nEndCol, nStartRow, nEndRow );
 }
 
+void ScDocument::InvalidatePageBreaks(SCTAB nTab)
+{
+    if (ValidTab(nTab) && pTab[nTab])
+        pTab[nTab]->InvalidatePageBreaks();
+}
 
 void ScDocument::UpdatePageBreaks( SCTAB nTab, const ScRange* pUserArea )
 {
--- sc/source/core/data/table1.cxx.old	2010-03-03 16:59:11.000000000 +0100
+++ sc/source/core/data/table1.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -156,7 +156,8 @@ ScTable::ScTable( ScDocument* pDoc, SCTA
     pScenarioRanges( NULL ),
     aScenarioColor( COL_LIGHTGRAY ),
     nScenarioFlags( 0 ),
-    bActiveScenario( FALSE )
+	bActiveScenario( FALSE ),
+    mbPageBreaksValid(false)
 {
 
     if (bColInfo)
--- sc/source/core/data/table2.cxx.old	2010-03-03 16:59:18.000000000 +0100
+++ sc/source/core/data/table2.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -138,6 +138,8 @@ void ScTable::InsertRow( SCCOL nStartCol
         aCol[j].InsertRow( nStartRow, nSize );
     if( !--nRecalcLvl )
         SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -166,6 +168,8 @@ void ScTable::DeleteRow( SCCOL nStartCol
     }
     if( !--nRecalcLvl )
         SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -233,6 +237,8 @@ void ScTable::InsertCol( SCCOL nStartCol
     }
     if( !--nRecalcLvl )
         SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -276,6 +282,8 @@ void ScTable::DeleteCol( SCCOL nStartCol
     }
     if( !--nRecalcLvl )
         SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -652,29 +660,39 @@ void ScTable::CopyToTable(SCCOL nCol1, S
                 if (bWidth)
                     for (SCCOL i=nCol1; i<=nCol2; i++)
                     {
-                        BOOL bChange = pCharts &&
-                            ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+						bool bHiddenChange = ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+						bool bChange = bHiddenChange || (pDestTab->pColWidth[i] != pColWidth[i]);
                         pDestTab->pColWidth[i] = pColWidth[i];
                         pDestTab->pColFlags[i] = pColFlags[i];
                         //!	Aenderungen zusammenfassen?
-                        if (bChange)
+						if (bHiddenChange && pCharts) 
                             pCharts->SetRangeDirty(ScRange( i, 0, nTab, i, MAXROW, nTab ));
+
+						if (bChange)
+							pDestTab->InvalidatePageBreaks();
                     }
 
                 if (bHeight)
                 {
+					bool bChange = pDestTab->pRowHeight->SumValues(nRow1, nRow2) != pRowHeight->SumValues(nRow1, nRow2);
+
+					if (bChange)
+						pDestTab->InvalidatePageBreaks();
+
                     pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
                     for (SCROW i=nRow1; i<=nRow2; i++)
                     {
                         // TODO: might need some performance improvement, block
                         // operations instead of single GetValue()/SetValue() calls.
                         BYTE nThisRowFlags = pRowFlags->GetValue(i);
-                        BOOL bChange = pCharts &&
-                            ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
+						bool bHiddenChange = ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
                         pDestTab->pRowFlags->SetValue( i, nThisRowFlags );
                         //!	Aenderungen zusammenfassen?
-                        if (bChange)
+						if (bHiddenChange && pCharts)
                             pCharts->SetRangeDirty(ScRange( 0, i, nTab, MAXCOL, i, nTab ));
+
+						if (bHiddenChange)
+							pDestTab->InvalidatePageBreaks();
                     }
                 }
                 pDestTab->DecRecalcLevel();
@@ -726,6 +744,16 @@ void ScTable::CopyUpdated( const ScTable
         aCol[i].CopyUpdated( pPosTab->aCol[i], pDestTab->aCol[i] );
 }
 
+void ScTable::InvalidateTableArea()
+{
+    bTableAreaValid = FALSE;
+}
+
+void ScTable::InvalidatePageBreaks()
+{
+    mbPageBreaksValid = false;
+}
+
 void ScTable::CopyScenarioTo( ScTable* pDestTab ) const
 {
     DBG_ASSERT( bScenario, "bScenario == FALSE" );
@@ -1969,6 +1997,8 @@ void ScTable::SetColWidth( SCCOL nCol, U
             pColWidth[nCol] = nNewWidth;
             if( !--nRecalcLvl )
                 SetDrawPageSize();
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -1999,6 +2029,8 @@ void ScTable::SetRowHeight( SCROW nRow,
             pRowHeight->SetValue( nRow, nNewHeight);
             if( !--nRecalcLvl )
                 SetDrawPageSize();
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -2099,6 +2131,9 @@ BOOL ScTable::SetRowHeightRange( SCROW n
         }
         if( !--nRecalcLvl )
             SetDrawPageSize();
+
+        if (bChanged)
+            InvalidatePageBreaks();
     }
     else
     {
@@ -2340,6 +2375,8 @@ void ScTable::ShowRow(SCROW nRow, BOOL b
             ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
             if ( pCharts )
                 pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -2385,6 +2422,8 @@ void ScTable::DBShowRow(SCROW nRow, BOOL
 
             if (pOutlineTable)
                 UpdateOutlineRow( nRow, nRow, bShow );
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -2484,6 +2523,8 @@ void ScTable::ShowRows(SCROW nRow1, SCRO
             ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
             if ( pCharts )
                 pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
+
+            InvalidatePageBreaks();
         }
 
         nStartRow = nEndRow + 1;
@@ -2559,7 +2600,7 @@ SCROW ScTable::GetLastFlaggedRow() const
     if ( !pRowFlags )
         return 0;
 
-    SCROW nLastFound = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    SCROW nLastFound = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(CR_ALL) );
     return ValidRow(nLastFound) ? nLastFound : 0;
 }
 
@@ -2571,7 +2612,7 @@ SCCOL ScTable::GetLastChangedCol() const
 
     SCCOL nLastFound = 0;
     for (SCCOL nCol = 1; nCol <= MAXCOL; nCol++)
-        if ((pColFlags[nCol] & ~CR_PAGEBREAK) || (pColWidth[nCol] != STD_COL_WIDTH))
+        if ((pColFlags[nCol] & CR_ALL) || (pColWidth[nCol] != STD_COL_WIDTH))
             nLastFound = nCol;
 
     return nLastFound;
@@ -2583,7 +2624,7 @@ SCROW ScTable::GetLastChangedRow() const
     if ( !pRowFlags )
         return 0;
 
-    SCROW nLastFlags = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    SCROW nLastFlags = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(CR_ALL) );
     if (!ValidRow(nLastFlags))
         nLastFlags = 0;
 
--- sc/source/core/data/table3.cxx.old	2010-03-03 16:59:17.000000000 +0100
+++ sc/source/core/data/table3.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -771,7 +771,7 @@ void ScTable::RemoveSubTotals( ScSubTota
             if ( pCell->GetCellType() == CELLTYPE_FORMULA )
                 if (((ScFormulaCell*)pCell)->IsSubTotal())
                 {
-                    SetRowFlags(nRow+1,GetRowFlags(nRow+1)&(~CR_MANUALBREAK));
+                    RemoveRowBreak(nRow+1, false, true);
                     pDocument->DeleteRow( 0,nTab, MAXCOL,nTab, nRow, 1 );
                     --nEndRow;
                     aIter = ScColumnIterator( &aCol[nCol],nRow,nEndRow );
@@ -939,9 +939,7 @@ BOOL ScTable::DoSubTotals( ScSubTotalPar
                     bBlockVis = FALSE;
                     if ( rParam.bPagebreak && nRow < MAXROW &&
                             aRowEntry.nSubStartRow != nStartRow && nLevel == 0)
-                        SetRowFlags( aRowEntry.nSubStartRow,
-                                GetRowFlags(aRowEntry.nSubStartRow) |
-                                CR_MANUALBREAK);
+                        SetRowBreak(aRowEntry.nSubStartRow, false, true);
 
                     if (bSpaceLeft)
                     {
--- sc/source/core/data/table5.cxx.old	2010-03-03 16:59:12.000000000 +0100
+++ sc/source/core/data/table5.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -53,8 +53,13 @@
 #include "brdcst.hxx"
 #include "tabprotection.hxx"
 #include "globstr.hrc"
+#include <com/sun/star/sheet/TablePageBreakData.hpp>
+
+#include <algorithm>
 
 using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::sheet::TablePageBreakData;
+using ::std::set;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -68,6 +73,9 @@ void ScTable::UpdatePageBreaks( const Sc
     if ( !pUserArea && !bPageSizeValid )
         return;
 
+    if (mbPageBreaksValid)
+        return;
+
     SfxStyleSheetBase* pStyle = pDocument->GetStyleSheetPool()->
                                     Find( aPageStyle, SFX_STYLE_FAMILY_PAGE );
     if ( !pStyle )
@@ -79,7 +87,6 @@ void ScTable::UpdatePageBreaks( const Sc
     const SfxPoolItem* pItem;
 
     SCCOL nX;
-    SCROW nY;
     SCCOL nStartCol = 0;
     SCROW nStartRow = 0;
     SCCOL nEndCol = MAXCOL;
@@ -99,8 +106,9 @@ void ScTable::UpdatePageBreaks( const Sc
             //	bei mehreren Bereichen nichts anzeigen:
 
             for (nX=0; nX<MAXCOL; nX++)
-                pColFlags[nX] &= ~CR_PAGEBREAK;
-            pRowFlags->AndValue( 0, MAXROW-1, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+                RemoveColBreak(nX, true, false);
+
+            RemoveRowPageBreaks(0, MAXROW-1);
 
             return;
         }
@@ -144,13 +152,13 @@ void ScTable::UpdatePageBreaks( const Sc
         //	Anfang: Breaks loeschen
 
     for (nX=0; nX<nStartCol; nX++)
-        pColFlags[nX] &= ~CR_PAGEBREAK;
-    pRowFlags->AndValue( 0, nStartRow-1, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+        RemoveColBreak(nX, true, false);
+    RemoveRowPageBreaks(0, nStartRow-1);
 
     if (nStartCol > 0)
-        pColFlags[nStartCol] |= CR_PAGEBREAK;			//! AREABREAK
+        SetColBreak(nStartCol, true, false);  // AREABREAK
     if (nStartRow > 0)
-        pRowFlags->OrValue( nStartRow, CR_PAGEBREAK);			//! AREABREAK
+        SetRowBreak(nStartRow, true, false);  // AREABREAK
 
         //	Mittelteil: Breaks verteilen
 
@@ -161,14 +169,15 @@ void ScTable::UpdatePageBreaks( const Sc
     {
         BOOL bStartOfPage = FALSE;
         long nThisX = ( pColFlags[nX] & CR_HIDDEN ) ? 0 : pColWidth[nX];
-        if ( (nSizeX+nThisX > nPageSizeX) || ((pColFlags[nX] & CR_MANUALBREAK) && !bSkipBreaks) )
+        bool bManualBreak = HasColManualBreak(nX);
+        if ( (nSizeX+nThisX > nPageSizeX) || (bManualBreak && !bSkipBreaks) )
         {
-            pColFlags[nX] |= CR_PAGEBREAK;
+            SetColBreak(nX, true, false);
             nSizeX = 0;
             bStartOfPage = TRUE;
         }
         else if (nX != nStartCol)
-            pColFlags[nX] &= ~CR_PAGEBREAK;
+            RemoveColBreak(nX, true, false);
         else
             bStartOfPage = TRUE;
 
@@ -178,7 +187,7 @@ void ScTable::UpdatePageBreaks( const Sc
             for (SCCOL i=nRepeatStartX; i<=nRepeatEndX; i++)
                 nPageSizeX -= ( pColFlags[i] & CR_HIDDEN ) ? 0 : pColWidth[i];
             while (nX<=nRepeatEndX)
-                pColFlags[++nX] &= ~CR_PAGEBREAK;
+                RemoveColBreak(++nX, true, false);
             bColFound = TRUE;
         }
 
@@ -186,23 +195,21 @@ void ScTable::UpdatePageBreaks( const Sc
     }
 
     // Remove all page breaks in range.
-    pRowFlags->AndValue( nStartRow+1, nEndRow, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    RemoveRowPageBreaks(nStartRow+1, nEndRow);
+
     // And set new page breaks.
     BOOL bRepeatRow = ( nRepeatStartY != SCROW_REPEAT_NONE );
     BOOL bRowFound = FALSE;
     long nSizeY = 0;
-    ScCompressedArrayIterator< SCROW, BYTE> aFlagsIter( *pRowFlags, nStartRow, nEndRow);
-    ScCompressedArrayIterator< SCROW, USHORT> aHeightIter( *pRowHeight, nStartRow, nEndRow);
-    for ( ; aFlagsIter; ++aFlagsIter, ++aHeightIter)
+    for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
     {
-        nY = aFlagsIter.GetPos();
         BOOL bStartOfPage = FALSE;
-        BYTE nFlags = *aFlagsIter;
-        long nThisY = (nFlags & CR_HIDDEN) ? 0 : *aHeightIter;
-        if ( (nSizeY+nThisY > nPageSizeY) || ((nFlags & CR_MANUALBREAK) && !bSkipBreaks) )
+        BYTE nFlags = pRowFlags->GetValue(nY);
+        long nThisY = (nFlags & CR_HIDDEN) ? 0 : pRowHeight->GetValue(nY);
+        bool bManualBreak = HasRowManualBreak(nY);
+		if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
         {
-            pRowFlags->SetValue( nY, nFlags | CR_PAGEBREAK);
-            aFlagsIter.Resync( nY);
+            SetRowBreak(nY, true, false);
             nSizeY = 0;
             bStartOfPage = TRUE;
         }
@@ -222,12 +229,7 @@ void ScTable::UpdatePageBreaks( const Sc
 #endif
             nPageSizeY -= nHeights;
             if (nY <= nRepeatEndY)
-            {
-                pRowFlags->AndValue( nY, nRepeatEndY, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
-                nY = nRepeatEndY + 1;
-                aFlagsIter.Resync( nY);
-                aHeightIter.Resync( nY);
-            }
+                RemoveRowPageBreaks(nY, nRepeatEndY);
             bRowFound = TRUE;
         }
 
@@ -238,26 +240,24 @@ void ScTable::UpdatePageBreaks( const Sc
 
     if (nEndCol < MAXCOL)
     {
-        pColFlags[nEndCol+1] |= CR_PAGEBREAK;			//! AREABREAK
+        SetColBreak(nEndCol+1, true, false);  // AREABREAK
         for (nX=nEndCol+2; nX<=MAXCOL; nX++)
-            pColFlags[nX] &= ~CR_PAGEBREAK;
+            RemoveColBreak(nX, true, false);
     }
     if (nEndRow < MAXROW)
     {
-        pRowFlags->OrValue( nEndRow+1, CR_PAGEBREAK);			//! AREABREAK
+        SetRowBreak(nEndRow+1, true, false);  // AREABREAK
         if (nEndRow+2 <= MAXROW)
-            pRowFlags->AndValue( nEndRow+2, MAXROW, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+            RemoveRowPageBreaks(nEndRow+2, MAXROW);
     }
+    mbPageBreaksValid = true;
 }
 
 void ScTable::RemoveManualBreaks()
 {
-    if (pColFlags)
-        for (SCCOL nCol = 0; nCol <= MAXCOL; nCol++)
-            pColFlags[nCol] &= ~CR_MANUALBREAK;
-
-    if (pRowFlags)
-        pRowFlags->AndValue( 0, MAXROW, sal::static_int_cast<BYTE>(~CR_MANUALBREAK) );
+    maRowManualBreaks.clear();
+    maColManualBreaks.clear();
+    InvalidatePageBreaks();
 
     if (IsStreamValid())
         SetStreamValid(FALSE);
@@ -265,22 +265,192 @@ void ScTable::RemoveManualBreaks()
 
 BOOL ScTable::HasManualBreaks() const
 {
-    if (pColFlags)
-        for (SCCOL nCol = 0; nCol <= MAXCOL; nCol++)
-            if ( pColFlags[nCol] & CR_MANUALBREAK )
-                return TRUE;
-
-    if (pRowFlags)
-        if (ValidRow( pRowFlags->GetLastAnyBitAccess( 0, CR_MANUALBREAK)))
-            return TRUE;
+    return !maRowManualBreaks.empty() || !maColManualBreaks.empty();
+}
+
+void ScTable::GetAllRowBreaks(set<SCROW>& rBreaks, bool bPage, bool bManual) const
+{
+    if (bPage)
+        rBreaks = maRowPageBreaks;
+
+    if (bManual)
+    {
+        using namespace std;    
+        copy(maRowManualBreaks.begin(), maRowManualBreaks.end(), inserter(rBreaks, rBreaks.begin()));
+    }
+}
+
+void ScTable::GetAllColBreaks(set<SCCOL>& rBreaks, bool bPage, bool bManual) const
+{
+    if (bPage)
+        rBreaks = maColPageBreaks;
+
+    if (bManual)
+    {
+        using namespace std;
+        copy(maColManualBreaks.begin(), maColManualBreaks.end(), inserter(rBreaks, rBreaks.begin()));
+    }
+}
+
+bool ScTable::HasRowPageBreak(SCROW nRow) const
+{
+    if (!ValidRow(nRow))
+        return false;
+
+    return maRowPageBreaks.count(nRow) > 0;
+}
+
+bool ScTable::HasColPageBreak(SCCOL nCol) const
+{
+    if (!ValidCol(nCol))
+        return false;
+
+    return maColPageBreaks.count(nCol) > 0;
+}
+
+bool ScTable::HasRowManualBreak(SCROW nRow) const
+{
+    if (!ValidRow(nRow))
+        return false;
+
+    return maRowManualBreaks.count(nRow) > 0;
+}
+
+bool ScTable::HasColManualBreak(SCCOL nCol) const
+{
+    if (!ValidCol(nCol))
+        return false;
+
+    return (maColManualBreaks.count(nCol) > 0);
+}
+
+void ScTable::RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow)
+{
+    using namespace std;
+
+    if (!ValidRow(nStartRow) || !ValidRow(nEndRow))
+        return;
+
+    set<SCROW>::iterator low  = maRowPageBreaks.lower_bound(nStartRow);
+    set<SCROW>::iterator high = maRowPageBreaks.upper_bound(nEndRow);
+    maRowPageBreaks.erase(low, high);
+}
+
+void ScTable::RemoveRowBreak(SCROW nRow, bool bPage, bool bManual)
+{
+    if (!ValidRow(nRow))
+        return;
+
+    if (bPage)
+        maRowPageBreaks.erase(nRow);
+
+    if (bManual)
+    {    
+        maRowManualBreaks.erase(nRow);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::RemoveColBreak(SCCOL nCol, bool bPage, bool bManual)
+{
+    if (!ValidCol(nCol))
+        return;
+
+    if (bPage)
+        maColPageBreaks.erase(nCol);
 
-    return FALSE;
+    if (bManual)
+    {    
+        maColManualBreaks.erase(nCol);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::SetRowBreak(SCROW nRow, bool bPage, bool bManual)
+{
+    if (!ValidRow(nRow))
+        return;
+
+    if (bPage)
+        maRowPageBreaks.insert(nRow);
+
+    if (bManual)
+    {    
+        maRowManualBreaks.insert(nRow);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::SetColBreak(SCCOL nCol, bool bPage, bool bManual)
+{
+    if (!ValidCol(nCol))
+        return;
+
+    if (bPage)
+        maColPageBreaks.insert(nCol);
+
+    if (bManual)
+    {    
+        maColManualBreaks.insert(nCol);
+        InvalidatePageBreaks();
+    }
+}
+
+Sequence<TablePageBreakData> ScTable::GetRowBreakData() const
+{
+    using ::std::copy;
+    using ::std::inserter;
+
+    set<SCROW> aRowBreaks = maRowPageBreaks;
+    copy(maRowManualBreaks.begin(), maRowManualBreaks.end(), inserter(aRowBreaks, aRowBreaks.begin()));
+
+    set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end();
+    Sequence<TablePageBreakData> aSeq(aRowBreaks.size());
+
+    for (sal_Int32 i = 0; itr != itrEnd; ++itr, ++i)
+    {
+        SCROW nRow = *itr;
+        TablePageBreakData aData;
+        aData.Position = nRow;
+        aData.ManualBreak = HasRowManualBreak(nRow);
+        aSeq[i] = aData;
+    }
+
+    return aSeq;
+}
+
+void ScTable::SyncColRowFlags()
+{
+    using ::sal::static_int_cast;
+
+    // For now, we only need to sync the manual breaks.
+
+    pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~CR_MANUALBREAK));
+    for (SCCOL i = 0; i <= MAXCOL; ++i)
+        pColFlags[i] &= static_int_cast<BYTE>(~CR_MANUALBREAK);
+
+    if (!maRowManualBreaks.empty())
+    {
+        for (set<SCROW>::const_iterator itr = maRowManualBreaks.begin(), itrEnd = maRowManualBreaks.end();
+              itr != itrEnd; ++itr)
+            pRowFlags->OrValue(*itr, static_int_cast<BYTE>(CR_MANUALBREAK));
+    }
+
+    if (!maColManualBreaks.empty())
+    {
+        for (set<SCCOL>::const_iterator itr = maColManualBreaks.begin(), itrEnd = maColManualBreaks.end();
+              itr != itrEnd; ++itr)
+            pColFlags[*itr] |= CR_MANUALBREAK;
+    }
 }
 
 void ScTable::SetPageSize( const Size& rSize )
 {
     if ( rSize.Width() != 0 && rSize.Height() != 0 )
     {
+        if (aPageSizeTwips != rSize)
+            InvalidatePageBreaks();
+
         bPageSizeValid = TRUE;
         aPageSizeTwips = rSize;
     }
--- sc/source/filter/excel/xepage.cxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/excel/xepage.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -48,9 +48,14 @@
 #include "xehelper.hxx"
 #include "xeescher.hxx"
 
+#include <set>
+#include <limits>
+
 #include <oox/core/tokens.hxx>
 
 using ::rtl::OString;
+using ::std::set;
+using ::std::numeric_limits;
 
 // Page settings records ======================================================
 
@@ -302,17 +307,23 @@ XclExpPageSettings::XclExpPageSettings(
 
     // *** page breaks ***
 
-    ScCompressedArrayIterator< SCROW, BYTE> aIter( rDoc.GetRowFlagsArray( nScTab), 1, GetMaxPos().Row());
-    do
+    set<SCROW> aRowBreaks;
+    rDoc.GetAllRowBreaks(aRowBreaks, nScTab, false, true);
+
+    SCROW nMaxRow = numeric_limits<sal_uInt16>::max();
+    for (set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end(); itr != itrEnd; ++itr)
     {
-        if (*aIter & CR_MANUALBREAK)
-            for (SCROW j=aIter.GetRangeStart(); j<=aIter.GetRangeEnd(); ++j)
-                maData.maHorPageBreaks.push_back( static_cast< sal_uInt16 >( j ) );
-    } while (aIter.NextRange());
-
-    for( SCCOL nScCol = 1, nScMaxCol = GetMaxPos().Col(); nScCol <= nScMaxCol; ++nScCol )
-        if( rDoc.GetColFlags( nScCol, nScTab ) & CR_MANUALBREAK )
-            maData.maVerPageBreaks.push_back( static_cast< sal_uInt16 >( nScCol ) );
+        SCROW nRow = *itr;
+        if (nRow > nMaxRow)
+            break;
+        
+        maData.maHorPageBreaks.push_back(nRow);
+    }
+
+    set<SCCOL> aColBreaks;
+    rDoc.GetAllColBreaks(aColBreaks, nScTab, false, true);
+    for (set<SCCOL>::const_iterator itr = aColBreaks.begin(), itrEnd = aColBreaks.end(); itr != itrEnd; ++itr)
+        maData.maVerPageBreaks.push_back(*itr);
 }
 
 static void lcl_WriteHeaderFooter( XclExpXmlStream& rStrm )
--- sc/source/filter/excel/xipage.cxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/excel/xipage.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -378,14 +378,14 @@ void XclImpPageSettings::Finalize()
     {
         SCROW nScRow = static_cast< SCROW >( *aIt );
         if( nScRow <= MAXROW )
-            rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetRowBreak(nScRow, nScTab, false, true);
     }
 
     for( aIt = maData.maVerPageBreaks.begin(), aEnd = maData.maVerPageBreaks.end(); aIt != aEnd; ++aIt )
     {
         SCCOL nScCol = static_cast< SCCOL >( *aIt );
         if( nScCol <= MAXCOL )
-            rDoc.SetColFlags( nScCol, nScTab, rDoc.GetColFlags( nScCol, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetColBreak(nScCol, nScTab, false, true);
     }
 }
 
--- sc/source/filter/starcalc/scflt.cxx.old	2009-10-08 16:17:08.000000000 +0200
+++ sc/source/filter/starcalc/scflt.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -1552,13 +1552,15 @@ void Sc10Import::LoadTables()
             if (DataValue != 0)
             {
                 BYTE nFlags = 0;
-                if ((DataValue & crfSoftBreak) == crfSoftBreak)
-                    nFlags |= CR_PAGEBREAK;
-                if ((DataValue & crfHardBreak) == crfHardBreak)
-                    nFlags |= CR_MANUALBREAK;
+				bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
+				bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
                 if ((DataValue & crfHidden) == crfHidden)
                     nFlags |= CR_HIDDEN;
-                for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++) pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+				for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++) 
+                {    
+                    pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetColBreak(k, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
+                }
             }
             DataStart = DataEnd + 1;
         }
@@ -1602,13 +1604,15 @@ void Sc10Import::LoadTables()
             if (DataValue != 0)
             {
                 BYTE nFlags = 0;
-                if ((DataValue & crfSoftBreak) == crfSoftBreak)
-                    nFlags |= CR_PAGEBREAK;
-                if ((DataValue & crfHardBreak) == crfHardBreak)
-                    nFlags |= CR_MANUALBREAK;
+				bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
+				bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
                 if ((DataValue & crfHidden) == crfHidden)
                     nFlags |= CR_HIDDEN;
-                for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++) pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++) 
+                {    
+                    pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetRowBreak(l, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
+                }
             }
             DataStart = DataEnd + 1;
         }
--- sc/source/filter/xml/xmlexprt.cxx.old	2010-03-03 16:59:17.000000000 +0100
+++ sc/source/filter/xml/xmlexprt.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -2559,6 +2559,7 @@ void ScXMLExport::_ExportAutoStyles()
                             {
                                 if (pDoc)
                                 {
+                                    pDoc->SyncColRowFlags();
                                     uno::Reference<table::XTableColumns> xTableColumns(xColumnRowRange->getColumns());
                                     if (xTableColumns.is())
                                     {
--- sc/source/ui/docshell/dbdocfun.cxx.old	2010-03-03 16:59:09.000000000 +0100
+++ sc/source/ui/docshell/dbdocfun.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -939,7 +939,10 @@ BOOL ScDBDocFunc::Query( SCTAB nTab, con
     }
 
     if (!bCopy)
+    {
+        pDoc->InvalidatePageBreaks(nTab);    
         pDoc->UpdatePageBreaks( nTab );
+    }
 
     // #i23299# because of Subtotal functions, the whole rows must be set dirty
     ScRange aDirtyRange( 0 , aLocalParam.nRow1, nDestTab,
--- sc/source/ui/docshell/docfunc.cxx.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/source/ui/docshell/docfunc.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -3212,20 +3212,22 @@ BOOL ScDocFunc::InsertPageBreak( BOOL bC
     if (nPos == 0)
         return FALSE;					// erste Spalte / Zeile
 
-    BYTE nFlags = bColumn ? pDoc->GetColFlags( static_cast<SCCOL>(nPos), nTab )
-        : pDoc->GetRowFlags( static_cast<SCROW>(nPos), nTab );
-    if (nFlags & CR_MANUALBREAK)
-        return TRUE;					// Umbruch schon gesetzt
+    ScBreakType nBreak = bColumn ? 
+        pDoc->HasColBreak(static_cast<SCCOL>(nPos), nTab) : 
+        pDoc->HasRowBreak(static_cast<SCROW>(nPos), nTab);
+    if (nBreak & BREAK_MANUAL)
+        return true;
 
     if (bRecord)
         rDocShell.GetUndoManager()->AddUndoAction(
             new ScUndoPageBreak( &rDocShell, rPos.Col(), rPos.Row(), nTab, bColumn, TRUE ) );
 
-    nFlags |= CR_MANUALBREAK;
     if (bColumn)
-        pDoc->SetColFlags( static_cast<SCCOL>(nPos), nTab, nFlags );
+        pDoc->SetColBreak(static_cast<SCCOL>(nPos), nTab, false, true);
     else
-        pDoc->SetRowFlags( static_cast<SCROW>(nPos), nTab, nFlags );
+        pDoc->SetRowBreak(static_cast<SCROW>(nPos), nTab, false, true);
+
+    pDoc->InvalidatePageBreaks(nTab);
     pDoc->UpdatePageBreaks( nTab );
 
     if (pDoc->IsStreamValid(nTab))
@@ -3271,20 +3273,25 @@ BOOL ScDocFunc::RemovePageBreak( BOOL bC
 
     SCCOLROW nPos = bColumn ? static_cast<SCCOLROW>(rPos.Col()) :
         static_cast<SCCOLROW>(rPos.Row());
-    BYTE nFlags = bColumn ? pDoc->GetColFlags( static_cast<SCCOL>(nPos), nTab )
-        : pDoc->GetRowFlags( static_cast<SCROW>(nPos), nTab );
-    if ((nFlags & CR_MANUALBREAK)==0)
-        return FALSE;							// kein Umbruch gesetzt
+
+    ScBreakType nBreak;
+    if (bColumn)
+        nBreak = pDoc->HasColBreak(static_cast<SCCOL>(nPos), nTab);
+    else
+        nBreak = pDoc->HasRowBreak(static_cast<SCROW>(nPos), nTab);
+    if ((nBreak & BREAK_MANUAL) == 0)
+        // There is no manual break.
+        return false;
 
     if (bRecord)
         rDocShell.GetUndoManager()->AddUndoAction(
             new ScUndoPageBreak( &rDocShell, rPos.Col(), rPos.Row(), nTab, bColumn, FALSE ) );
 
-    nFlags &= ~CR_MANUALBREAK;
     if (bColumn)
-        pDoc->SetColFlags( static_cast<SCCOL>(nPos), nTab, nFlags );
+        pDoc->RemoveColBreak(static_cast<SCCOL>(nPos), nTab, false, true);
     else
-        pDoc->SetRowFlags( static_cast<SCROW>(nPos), nTab, nFlags );
+        pDoc->RemoveRowBreak(static_cast<SCROW>(nPos), nTab, false, true);
+
     pDoc->UpdatePageBreaks( nTab );
 
     if (pDoc->IsStreamValid(nTab))
--- sc/source/ui/docshell/olinefun.cxx.old	2009-11-20 11:38:03.000000000 +0100
+++ sc/source/ui/docshell/olinefun.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -704,6 +704,7 @@ BOOL ScOutlineDocFunc::ShowOutline( SCTA
 
     pArray->SetVisibleBelow( nLevel, nEntry, TRUE, TRUE );
 
+    pDoc->InvalidatePageBreaks(nTab);
     pDoc->UpdatePageBreaks( nTab );
 
     if (bPaint)
@@ -769,6 +770,7 @@ BOOL ScOutlineDocFunc::HideOutline( SCTA
 
     pArray->SetVisibleBelow( nLevel, nEntry, FALSE );
 
+    pDoc->InvalidatePageBreaks(nTab);
     pDoc->UpdatePageBreaks( nTab );
 
     if (bPaint)
--- sc/source/ui/undo/undocell.cxx.old	2010-03-03 16:59:11.000000000 +0100
+++ sc/source/ui/undo/undocell.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -587,6 +587,8 @@ void ScUndoPageBreak::DoChange( BOOL bIn
             pViewShell->InsertPageBreak(bColumn, FALSE);
         else
             pViewShell->DeletePageBreak(bColumn, FALSE);
+
+        pDocShell->GetDocument()->InvalidatePageBreaks(nTab);
     }
 }
 
--- sc/source/ui/undo/undodat.cxx.old	2010-03-03 16:44:01.000000000 +0100
+++ sc/source/ui/undo/undodat.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -1029,7 +1029,10 @@ void __EXPORT ScUndoQuery::Undo()
         pDoc->SetDBCollection( new ScDBCollection( *pUndoDB ), TRUE );
 
     if (!bCopy)
+    {
+        pDoc->InvalidatePageBreaks(nTab);    
         pDoc->UpdatePageBreaks( nTab );
+    }
 
     ScRange aDirtyRange( 0 , aQueryParam.nRow1, nTab,
         MAXCOL, aQueryParam.nRow2, nTab );
--- sc/source/ui/unoobj/cellsuno.cxx.old	2010-03-03 16:59:13.000000000 +0100
+++ sc/source/ui/unoobj/cellsuno.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -7056,7 +7056,7 @@ uno::Sequence<sheet::TablePageBreakData>
         SCCOL nCount = 0;
         SCCOL nCol;
         for (nCol=0; nCol<=MAXCOL; nCol++)
-            if (pDoc->GetColFlags( nCol, nTab ) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+            if (pDoc->HasColBreak(nCol, nTab))
                 ++nCount;
 
         sheet::TablePageBreakData aData;
@@ -7065,11 +7065,11 @@ uno::Sequence<sheet::TablePageBreakData>
         USHORT nPos = 0;
         for (nCol=0; nCol<=MAXCOL; nCol++)
         {
-            BYTE nFlags = pDoc->GetColFlags( nCol, nTab );
-            if (nFlags & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            if (nBreak)
             {
                 aData.Position	  = nCol;
-                aData.ManualBreak = ( nFlags & CR_MANUALBREAK ) != 0;
+                aData.ManualBreak = (nBreak & BREAK_MANUAL);
                 pAry[nPos] = aData;
                 ++nPos;
             }
@@ -7098,33 +7098,7 @@ uno::Sequence<sheet::TablePageBreakData>
             ScPrintFunc aPrintFunc( pDocSh, pDocSh->GetPrinter(), nTab );
             aPrintFunc.UpdatePages();
         }
-
-        SCROW nCount = pDoc->GetRowFlagsArray( nTab).CountForAnyBitCondition(
-                0, MAXROW, (CR_PAGEBREAK | CR_MANUALBREAK));
-
-        uno::Sequence<sheet::TablePageBreakData> aSeq(nCount);
-        if (nCount)
-        {
-            sheet::TablePageBreakData aData;
-            sheet::TablePageBreakData* pAry = aSeq.getArray();
-            size_t nPos = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray( nTab), 0, MAXROW);
-            do
-            {
-                BYTE nFlags = *aIter;
-                if (nFlags & ( CR_PAGEBREAK | CR_MANUALBREAK ))
-                {
-                    for (SCROW nRow = aIter.GetRangeStart(); nRow <= aIter.GetRangeEnd(); ++nRow)
-                    {
-                        aData.Position	  = nRow;
-                        aData.ManualBreak = ( nFlags & CR_MANUALBREAK ) != 0;
-                        pAry[nPos] = aData;
-                        ++nPos;
-                    }
-                }
-            } while (aIter.NextRange());
-        }
-        return aSeq;
+        return pDoc->GetRowBreakData(nTab);
     }
     return uno::Sequence<sheet::TablePageBreakData>(0);
 }
@@ -8893,13 +8867,13 @@ void ScTableColumnObj::GetOnePropertyVal
         }
         else if ( pEntry->nWID == SC_WID_UNO_NEWPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetColFlags( nCol, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
         }
         else if ( pEntry->nWID == SC_WID_UNO_MANPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetColFlags( nCol, nTab ) & (CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            ScUnoHelpFunctions::SetBoolInAny(rAny, (nBreak & BREAK_MANUAL));
         }
         else
             ScCellRangeObj::GetOnePropertyValue(pEntry, rAny);
@@ -9057,13 +9031,13 @@ void ScTableRowObj::GetOnePropertyValue(
         }
         else if ( pEntry->nWID == SC_WID_UNO_NEWPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nRow, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasRowBreak(nRow, nTab);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
         }
         else if ( pEntry->nWID == SC_WID_UNO_MANPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nRow, nTab ) & (CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = (pDoc->HasRowBreak(nRow, nTab) & BREAK_MANUAL);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
         }
         else
             ScCellRangeObj::GetOnePropertyValue(pEntry, rAny);
--- sc/source/ui/unoobj/docuno.cxx.old	2009-12-03 13:50:47.000000000 +0100
+++ sc/source/ui/unoobj/docuno.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -2666,13 +2666,13 @@ uno::Any SAL_CALL ScTableColumnsObj::get
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetColFlags( nStartCol, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasColBreak(nStartCol, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, nBreak );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_MANPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetColFlags( nStartCol, nTab ) & (CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasColBreak(nStartCol, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, (nBreak & BREAK_MANUAL) );
     }
 
     return aAny;
@@ -2929,13 +2929,13 @@ uno::Any SAL_CALL ScTableRowsObj::getPro
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nStartRow, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasRowBreak(nStartRow, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, nBreak );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_MANPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nStartRow, nTab ) & (CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasRowBreak(nStartRow, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, (nBreak & BREAK_MANUAL) );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLBACK ) || aNameString.EqualsAscii( SC_UNONAME_CELLTRAN ) )
     {
--- sc/source/ui/vba/vbarange.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/vba/vbarange.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -3712,16 +3712,16 @@ ScVbaRange::getPageBreak() throw (uno::R
         {
             ScDocument* pDoc =  getDocumentFromRange( mxRange );
             
-            BYTE nFlag = 0;
+            ScBreakType nBreak = BREAK_NONE;
             if ( !bColumn )
-                nFlag = pDoc -> GetRowFlags(thisAddress.StartRow, thisAddress.Sheet);
+                nBreak = pDoc->HasRowBreak(thisAddress.StartRow, thisAddress.Sheet);
             else
-                nFlag = pDoc -> GetColFlags(static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.Sheet);
+                nBreak = pDoc->HasColBreak(thisAddress.StartColumn, thisAddress.Sheet);
                 
-            if ( nFlag & CR_PAGEBREAK)
+            if (nBreak & BREAK_PAGE)
                 nPageBreak = excel::XlPageBreak::xlPageBreakAutomatic;
                 
-            if ( nFlag & CR_MANUALBREAK)
+            if (nBreak & BREAK_MANUAL)
                 nPageBreak = excel::XlPageBreak::xlPageBreakManual;
         }		
     }
--- sc/source/ui/view/cellsh.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/view/cellsh.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -717,22 +717,22 @@ void ScCellShell::GetState(SfxItemSet &r
                 break;
 
             case FID_INS_ROWBRK:
-                if ( nPosY==0 || (pDoc->GetRowFlags(nPosY,nTab) & CR_MANUALBREAK) )
+                if ( nPosY==0 || (pDoc->HasRowBreak(nPosY, nTab) & BREAK_MANUAL) )
                     rSet.DisableItem( nWhich );
                 break;
 
             case FID_INS_COLBRK:
-                if ( nPosX==0 || (pDoc->GetColFlags(nPosX,nTab) & CR_MANUALBREAK) )
+                if ( nPosX==0 || (pDoc->HasColBreak(nPosX, nTab) & BREAK_MANUAL) )
                     rSet.DisableItem( nWhich );
                 break;
 
             case FID_DEL_ROWBRK:
-                if ( nPosY==0 || (pDoc->GetRowFlags(nPosY,nTab) & CR_MANUALBREAK)==0 )
+                if ( nPosY==0 || (pDoc->HasRowBreak(nPosY, nTab) & BREAK_MANUAL) == 0 )
                     rSet.DisableItem( nWhich );
                 break;
 
             case FID_DEL_COLBRK:
-                if ( nPosX==0 || (pDoc->GetColFlags(nPosX,nTab) & CR_MANUALBREAK)==0 )
+                if ( nPosX==0 || (pDoc->HasColBreak(nPosX, nTab) & BREAK_MANUAL) == 0 )
                     rSet.DisableItem( nWhich );
                 break;
 
--- sc/source/ui/view/gridwin2.cxx.old	2010-03-03 16:44:01.000000000 +0100
+++ sc/source/ui/view/gridwin2.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -936,7 +936,7 @@ void ScGridWindow::PagebreakMove( const
                 BOOL bGrow = !bHide && nNew > nPagebreakBreak;
                 if ( bColumn )
                 {
-                    if ( pDoc->GetColFlags( static_cast<SCCOL>(nPagebreakBreak), nTab ) & CR_MANUALBREAK )
+                    if (pDoc->HasColBreak(static_cast<SCCOL>(nPagebreakBreak), nTab) & BREAK_MANUAL)
                     {
                         ScAddress aOldAddr( static_cast<SCCOL>(nPagebreakBreak), nPosY, nTab );
                         pViewFunc->DeletePageBreak( TRUE, TRUE, &aOldAddr, FALSE );
@@ -949,8 +949,8 @@ void ScGridWindow::PagebreakMove( const
                     if ( bGrow )
                     {
                         //	vorigen Break auf hart, und Skalierung aendern
-                        if ( static_cast<SCCOL>(nPagebreakPrev) > aPagebreakSource.aStart.Col() &&
-                                !(pDoc->GetColFlags( static_cast<SCCOL>(nPagebreakPrev), nTab ) & CR_MANUALBREAK) )
+                        bool bManualBreak = (pDoc->HasColBreak(static_cast<SCCOL>(nPagebreakPrev), nTab) & BREAK_MANUAL);
+                        if ( static_cast<SCCOL>(nPagebreakPrev) > aPagebreakSource.aStart.Col() && !bManualBreak )
                         {
                             ScAddress aPrev( static_cast<SCCOL>(nPagebreakPrev), nPosY, nTab );
                             pViewFunc->InsertPageBreak( TRUE, TRUE, &aPrev, FALSE );
@@ -963,7 +963,7 @@ void ScGridWindow::PagebreakMove( const
                 }
                 else
                 {
-                    if ( pDoc->GetRowFlags( nPagebreakBreak, nTab ) & CR_MANUALBREAK )
+                    if (pDoc->HasRowBreak(nPagebreakBreak, nTab) & BREAK_MANUAL)
                     {
                         ScAddress aOldAddr( nPosX, nPagebreakBreak, nTab );
                         pViewFunc->DeletePageBreak( FALSE, TRUE, &aOldAddr, FALSE );
@@ -976,8 +976,8 @@ void ScGridWindow::PagebreakMove( const
                     if ( bGrow )
                     {
                         //	vorigen Break auf hart, und Skalierung aendern
-                        if ( nPagebreakPrev > aPagebreakSource.aStart.Row() &&
-                                !(pDoc->GetRowFlags( nPagebreakPrev, nTab ) & CR_MANUALBREAK) )
+                        bool bManualBreak = (pDoc->HasRowBreak(nPagebreakPrev, nTab) & BREAK_MANUAL);
+                        if ( nPagebreakPrev > aPagebreakSource.aStart.Row() && !bManualBreak )
                         {
                             ScAddress aPrev( nPosX, nPagebreakPrev, nTab );
                             pViewFunc->InsertPageBreak( FALSE, TRUE, &aPrev, FALSE );
--- sc/source/ui/view/gridwin4.cxx.old	2010-03-03 16:59:12.000000000 +0100
+++ sc/source/ui/view/gridwin4.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -1091,7 +1091,7 @@ void ScGridWindow::DrawPagePreview( SCCO
                     if ( nBreak >= nX1 && nBreak <= nX2+1 )
                     {
                         //! hidden suchen
-                        if ( pDoc->GetColFlags( nBreak, nTab ) & CR_MANUALBREAK )
+                        if (pDoc->HasColBreak(nBreak, nTab) & BREAK_MANUAL)
                             pContentDev->SetFillColor( aManual );
                         else
                             pContentDev->SetFillColor( aAutomatic );
@@ -1110,7 +1110,7 @@ void ScGridWindow::DrawPagePreview( SCCO
                     if ( nBreak >= nY1 && nBreak <= nY2+1 )
                     {
                         //! hidden suchen
-                        if ( pDoc->GetRowFlags( nBreak, nTab ) & CR_MANUALBREAK )
+                        if (pDoc->HasRowBreak(nBreak, nTab) & BREAK_MANUAL)
                             pContentDev->SetFillColor( aManual );
                         else
                             pContentDev->SetFillColor( aAutomatic );
--- sc/source/ui/view/output.cxx.old	2010-03-03 16:59:12.000000000 +0100
+++ sc/source/ui/view/output.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -325,8 +325,9 @@ void ScOutputData::DrawGrid( BOOL bGrid,
     long nPosX;
     long nPosY;
     SCSIZE nArrY;
-    BYTE nOldFlags = 0;
-    BYTE nFlags;
+    ScBreakType nBreak    = BREAK_NONE;
+    ScBreakType nBreakOld = BREAK_NONE;
+
     BOOL bSingle;
     Color aPageColor;
     Color aManualColor;
@@ -381,27 +382,27 @@ void ScOutputData::DrawGrid( BOOL bGrid,
             if ( bPage )
             {
                 //	Seitenumbrueche auch in ausgeblendeten suchen
-                nFlags = 0;
                 SCCOL nCol = nXplus1;
                 while (nCol <= MAXCOL)
                 {
                     BYTE nDocFl = pDoc->GetColFlags( nCol, nTab );
-                    nFlags = nDocFl & ( CR_PAGEBREAK | CR_MANUALBREAK );
-                    if ( nFlags || !(nDocFl & CR_HIDDEN) )
+                    nBreak = pDoc->HasColBreak(nCol, nTab);
+
+                    if ( nBreak || !(nDocFl & CR_HIDDEN) )
                         break;
                     ++nCol;
                 }
 
-                if (nFlags != nOldFlags)
+                if (nBreak != nBreakOld)
                 {
                     aGrid.Flush();
-                    pDev->SetLineColor( (nFlags & CR_MANUALBREAK) ? aManualColor :
-                                     (nFlags) ? aPageColor : aGridColor );
-                    nOldFlags = nFlags;
+                    pDev->SetLineColor( (nBreak & BREAK_MANUAL) ? aManualColor :
+                                        nBreak ? aPageColor : aGridColor );
+                    nBreakOld = nBreak;
                 }
             }
 
-            BOOL bDraw = bGrid || nOldFlags;	// einfaches Gitter nur wenn eingestellt
+			BOOL bDraw = bGrid || nBreakOld;	// einfaches Gitter nur wenn eingestellt
 
             //!	Mit dieser Abfrage wird zuviel weggelassen, wenn ein automatischer
             //!	Umbruch mitten in den Wiederholungsspalten liegt.
@@ -412,7 +413,7 @@ void ScOutputData::DrawGrid( BOOL bGrid,
             {
                 if ( nX == MAXCOL )
                     bDraw = FALSE;
-                else if (pDoc->GetColFlags(nXplus1,nTab) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+                else if (pDoc->HasColBreak(nXplus1, nTab))
                     bDraw = FALSE;
             }
 #endif
@@ -503,28 +504,24 @@ void ScOutputData::DrawGrid( BOOL bGrid,
         {
             if ( bPage )
             {
-                //	Seitenumbrueche auch in ausgeblendeten suchen
-                nFlags = 0;
-                ScCompressedArrayIterator< SCROW, BYTE > aIter(
-                        pDoc->GetRowFlagsArray( nTab), nYplus1, MAXROW);
-                do
-                {
-                    BYTE nDocFl = *aIter;
-                    nFlags = nDocFl & ( CR_PAGEBREAK | CR_MANUALBREAK );
-                    if ( nFlags || !(nDocFl & CR_HIDDEN) )
+                for (SCROW i = nYplus1; i <= MAXROW; ++i)
+                {
+                    nBreak = pDoc->HasRowBreak(i, nTab);
+                    bool bHidden = (pDoc->GetRowFlags(i, nTab) & CR_HIDDEN);
+                    if (nBreak || !bHidden)
                         break;
-                } while (aIter.NextRange());
+                }
 
-                if (nFlags != nOldFlags)
+                if (nBreakOld != nBreak)
                 {
                     aGrid.Flush();
-                    pDev->SetLineColor( (nFlags & CR_MANUALBREAK) ? aManualColor :
-                                     (nFlags) ? aPageColor : aGridColor );
-                    nOldFlags = nFlags;
+					pDev->SetLineColor( (nBreak & BREAK_MANUAL) ? aManualColor :
+                                        (nBreak) ? aPageColor : aGridColor );
+                    nBreakOld = nBreak;
                 }
             }
 
-            BOOL bDraw = bGrid || nOldFlags;	// einfaches Gitter nur wenn eingestellt
+			BOOL bDraw = bGrid || nBreakOld;	// einfaches Gitter nur wenn eingestellt
 
             //!	Mit dieser Abfrage wird zuviel weggelassen, wenn ein automatischer
             //!	Umbruch mitten in den Wiederholungszeilen liegt.
@@ -535,7 +532,7 @@ void ScOutputData::DrawGrid( BOOL bGrid,
             {
                 if ( nY == MAXROW )
                     bDraw = FALSE;
-                else if (pDoc->GetRowFlags(nYplus1,nTab) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+                else if (pDoc->HasRowBreak(nYplus1, nTab))
                     bDraw = FALSE;
             }
 #endif
--- sc/source/ui/view/printfun.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/view/printfun.cxx	2010-03-03 16:59:18.000000000 +0100
@@ -2875,30 +2875,84 @@ void ScPrintFunc::CalcZoom( USHORT nRang
     if (aTableParam.bScalePageNum)
     {
         nZoom = 100;
-        BOOL bFound = FALSE;
         USHORT nPagesToFit = aTableParam.nScalePageNum;
-        while (!bFound)
+
+        sal_uInt16 nLastFitZoom = 0, nLastNonFitZoom = 0;
+        while (true)
         {
+            if (nZoom <= ZOOM_MIN)
+                break;
+
             CalcPages();
-            if ( nPagesX * nPagesY <= nPagesToFit || nZoom <= ZOOM_MIN )
-                bFound = TRUE;
+            bool bFitsPage = (nPagesX * nPagesY <= nPagesToFit);
+
+            if (bFitsPage)
+            {
+                if (nZoom == 100)
+                    // If it fits at 100 %, it's good enough for me.
+                    break;
+                
+                nLastFitZoom = nZoom;
+                nZoom = (nLastNonFitZoom + nZoom) / 2;
+
+                if (nLastFitZoom == nZoom)
+                    // It converged.  Use this zoom level.
+                    break;
+            }
             else
-                --nZoom;
+            {
+                if (nZoom - nLastFitZoom <= 1)
+                {
+                    nZoom = nLastFitZoom;
+                    CalcPages();
+                    break;
+                }
+
+                nLastNonFitZoom = nZoom;
+                nZoom = (nLastFitZoom + nZoom) / 2;
+            }
         }
     }
     else if (aTableParam.bScaleTo)
     {
         nZoom = 100;
-        BOOL bFound = FALSE;
         USHORT nW = aTableParam.nScaleWidth;
         USHORT nH = aTableParam.nScaleHeight;
-        while (!bFound)
+
+        sal_uInt16 nLastFitZoom = 0, nLastNonFitZoom = 0;
+        while (true)
         {
+            if (nZoom <= ZOOM_MIN)
+                break;
+
             CalcPages();
-            if ( ((!nW || (nPagesX <= nW)) && (!nH || (nPagesY <= nH))) || (nZoom <= ZOOM_MIN) )
-                bFound = TRUE;
+            bool bFitsPage = ((!nW || (nPagesX <= nW)) && (!nH || (nPagesY <= nH)));
+
+            if (bFitsPage)
+            {
+                if (nZoom == 100)
+                    // If it fits at 100 %, it's good enough for me.
+                    break;
+                
+                nLastFitZoom = nZoom;
+                nZoom = (nLastNonFitZoom + nZoom) / 2;
+
+                if (nLastFitZoom == nZoom)
+                    // It converged.  Use this zoom level.
+                    break;
+            }
             else
-                --nZoom;
+            {
+                if (nZoom - nLastFitZoom <= 1)
+                {
+                    nZoom = nLastFitZoom;
+                    CalcPages();
+                    break;
+                }
+
+                nLastNonFitZoom = nZoom;
+                nZoom = (nLastFitZoom + nZoom) / 2;
+            }
         }
     }
     else if (aTableParam.bScaleAll)
@@ -3022,7 +3076,8 @@ void ScPrintFunc::CalcPages()				// bere
     for (SCCOL i=nStartCol; i<=nEndCol; i++)
     {
         BYTE nFlags = pDoc->GetColFlags(i,nPrintTab);
-        if ( i>nStartCol && bVisCol && (nFlags & CR_PAGEBREAK) )
+        bool bPageBreak = (pDoc->HasColBreak(i, nPrintTab) & BREAK_PAGE);
+        if ( i>nStartCol && bVisCol && bPageBreak )
         {
             pPageEndX[nPagesX] = i-1;
             ++nPagesX;
@@ -3047,7 +3102,8 @@ void ScPrintFunc::CalcPages()				// bere
         SCROW nRangeEnd = aIter.GetRangeEnd();
         for (SCROW j=aIter.GetRangeStart(); j<=nRangeEnd; ++j)
         {
-            if ( j>nStartRow && bVisRow && (nFlags & CR_PAGEBREAK) )
+            bool bPageBreak = (pDoc->HasRowBreak(j, nPrintTab) & BREAK_PAGE);
+            if ( j>nStartRow && bVisRow && bPageBreak )
             {
                 pPageEndY[nTotalY] = j-1;
                 ++nTotalY;
