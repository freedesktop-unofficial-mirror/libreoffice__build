From 6629fce90b7cedffc1b2e917f9c843373b78487d Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:56:55 +0200
Subject: [PATCH 234/878] calc-perf-lazy-overlay-objects.diff

---
 sc/source/ui/inc/gridwin.hxx   |   20 +++++++++++++
 sc/source/ui/view/gridwin.cxx  |   59 +++++++++++++++++++++++-----------------
 sc/source/ui/view/gridwin4.cxx |    6 ++++
 3 files changed, 60 insertions(+), 25 deletions(-)

diff --git a/sc/source/ui/inc/gridwin.hxx b/sc/source/ui/inc/gridwin.hxx
index f339fa0..749ce71 100644
--- a/sc/source/ui/inc/gridwin.hxx
+++ b/sc/source/ui/inc/gridwin.hxx
@@ -39,6 +39,7 @@
 
 #include <vector>
 #include <memory>
+#include <boost/shared_ptr.hpp>
 
 // ---------------------------------------------------------------------------
 
@@ -113,6 +114,25 @@ private:
     ::sdr::overlay::OverlayObjectList*              mpOOHeader;
     ::sdr::overlay::OverlayObjectList*              mpOOShrink;
 
+    ::boost::shared_ptr<Rectangle> mpAutoFillRect;
+
+    /**
+     * Stores current visible column and row ranges, used to avoid expensive
+     * operations on objects that are outside visible area.
+     */
+    struct VisibleRange
+    {
+        SCCOL mnCol1;
+        SCCOL mnCol2;
+        SCROW mnRow1;
+        SCROW mnRow2;
+
+        VisibleRange();
+
+        bool isInside(SCCOL nCol, SCROW nRow) const;
+    };
+    VisibleRange maVisibleRange;
+
 private:
     ScViewData*				pViewData;
     ScSplitPos				eWhich;
diff --git a/sc/source/ui/view/gridwin.cxx b/sc/source/ui/view/gridwin.cxx
index 8418994..9993ae6 100644
--- a/sc/source/ui/view/gridwin.cxx
+++ b/sc/source/ui/view/gridwin.cxx
@@ -158,7 +158,19 @@ extern USHORT nScFillModeMouseModifier;				// global.cxx
 
 #define SC_FILTERLISTBOX_LINES	12
 
-//==================================================================
+// ============================================================================
+
+ScGridWindow::VisibleRange::VisibleRange() :
+    mnCol1(0), mnCol2(MAXCOL), mnRow1(0), mnRow2(MAXROW)
+{
+}
+
+bool ScGridWindow::VisibleRange::isInside(SCCOL nCol, SCROW nRow) const
+{
+    return mnCol1 <= nCol && nCol <= mnCol2 && mnRow1 <= nRow && nRow <= mnRow2;
+}
+
+// ============================================================================
 
 class ScFilterListBox : public ListBox
 {
@@ -372,6 +384,7 @@ ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhic
             mpOODragRect( NULL ),
             mpOOHeader( NULL ),
             mpOOShrink( NULL ),
+            mpAutoFillRect(static_cast<Rectangle*>(NULL)),
             pViewData( pData ),
             eWhich( eWhichPos ),
             pNoteMarker( NULL ),
@@ -1356,30 +1369,17 @@ BOOL ScGridWindow::TestMouse( const MouseEvent& rMEvt, BOOL bAction )
         ScRange aMarkRange;
         if (pViewData->GetSimpleArea( aMarkRange ) == SC_MARK_SIMPLE)
         {
-            if ( aMarkRange.aStart.Tab() == pViewData->GetTabNo() )
+            if (aMarkRange.aStart.Tab() == pViewData->GetTabNo() && mpAutoFillRect)
             {
-                //	Block-Ende wie in DrawAutoFillMark
-                SCCOL nX = aMarkRange.aEnd.Col();
-                SCROW nY = aMarkRange.aEnd.Row();
-
-                Point aFillPos = pViewData->GetScrPos( nX, nY, eWhich, TRUE );
-                long nSizeXPix;
-                long nSizeYPix;
-                pViewData->GetMergeSizePixel( nX, nY, nSizeXPix, nSizeYPix );
-                aFillPos.X() += nSizeXPix * nLayoutSign;
-                aFillPos.Y() += nSizeYPix;
-                if ( bLayoutRTL )
-                    aFillPos.X() -= 1;
-
                 Point aMousePos = rMEvt.GetPosPixel();
-                //	Abfrage hier passend zu DrawAutoFillMark
-                //	(ein Pixel mehr als markiert)
-                if ( aMousePos.X() >= aFillPos.X()-3 && aMousePos.X() <= aFillPos.X()+4 &&
-                     aMousePos.Y() >= aFillPos.Y()-3 && aMousePos.Y() <= aFillPos.Y()+4 )
+                if (mpAutoFillRect->IsInside(aMousePos))
                 {
-                    SetPointer( Pointer( POINTER_CROSS ) );		//! dickeres Kreuz ?
+                    SetPointer( Pointer( POINTER_CROSS ) );     //! dickeres Kreuz ?
                     if (bAction)
                     {
+                        SCCOL nX = aMarkRange.aEnd.Col();
+                        SCROW nY = aMarkRange.aEnd.Row();
+
                         if ( lcl_IsEditableMatrix( pViewData->GetDocument(), aMarkRange ) )
                             pViewData->SetDragMode(
                                 aMarkRange.aStart.Col(), aMarkRange.aStart.Row(), nX, nY, SC_FILL_MATRIX );
@@ -5277,6 +5277,9 @@ void ScGridWindow::UpdateCursorOverlay()
     SCCOL nX = pViewData->GetCurX();
     SCROW nY = pViewData->GetCurY();
 
+    if (!maVisibleRange.isInside(nX, nY))
+        return;
+
     //  don't show the cursor in overlapped cells
 
     ScDocument* pDoc = pViewData->GetDocument();
@@ -5447,6 +5450,7 @@ void ScGridWindow::UpdateSelectionOverlay()
 void ScGridWindow::DeleteAutoFillOverlay()
 {
     DELETEZ( mpOOAutoFill );
+    mpAutoFillRect.reset();
 }
 
 void ScGridWindow::UpdateAutoFillOverlay()
@@ -5467,6 +5471,11 @@ void ScGridWindow::UpdateAutoFillOverlay()
     {
         SCCOL nX = aAutoMarkPos.Col();
         SCROW nY = aAutoMarkPos.Row();
+
+        if (!maVisibleRange.isInside(nX, nY))
+            // Autofill mark is not visible.  Bail out.
+            return;
+
         SCTAB nTab = pViewData->GetTabNo();
         ScDocument* pDoc = pViewData->GetDocument();
         BOOL bLayoutRTL = pDoc->IsLayoutRTL( nTab );
@@ -5482,7 +5491,7 @@ void ScGridWindow::UpdateAutoFillOverlay()
 
         aFillPos.Y() += nSizeYPix;
         aFillPos.Y() -= 2;
-        Rectangle aFillRect( aFillPos, Size(6,6) );
+        mpAutoFillRect.reset(new Rectangle(aFillPos, Size(6, 6)));
     
         // #i70788# get the OverlayManager safely
         ::sdr::overlay::OverlayManager* pOverlayManager = getOverlayManager();
@@ -5495,7 +5504,7 @@ void ScGridWindow::UpdateAutoFillOverlay()
                 aHandleColor = SC_MOD()->GetColorConfig().GetColorValue(svtools::CALCPAGEBREAKAUTOMATIC).nColor;
             std::vector< basegfx::B2DRange > aRanges;
             const basegfx::B2DHomMatrix aTransform(GetInverseViewTransformation());
-            basegfx::B2DRange aRB(aFillRect.Left(), aFillRect.Top(), aFillRect.Right() + 1, aFillRect.Bottom() + 1);
+            basegfx::B2DRange aRB(mpAutoFillRect->Left(), mpAutoFillRect->Top(), mpAutoFillRect->Right() + 1, mpAutoFillRect->Bottom() + 1);
             
             aRB.transform(aTransform);
             aRanges.push_back(aRB);
@@ -5510,10 +5519,10 @@ void ScGridWindow::UpdateAutoFillOverlay()
             mpOOAutoFill = new ::sdr::overlay::OverlayObjectList;
             mpOOAutoFill->append(*pOverlay);
         }
-    }
 
-    if ( aOldMode != aDrawMode )
-        SetMapMode( aOldMode );
+        if ( aOldMode != aDrawMode )
+            SetMapMode( aOldMode );
+    }
 }
 
 void ScGridWindow::DeleteDragRectOverlay()
diff --git a/sc/source/ui/view/gridwin4.cxx b/sc/source/ui/view/gridwin4.cxx
index d6f78e0..466a4fb 100644
--- a/sc/source/ui/view/gridwin4.cxx
+++ b/sc/source/ui/view/gridwin4.cxx
@@ -449,6 +449,12 @@ void ScGridWindow::Draw( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2, ScUpdateMod
     SCROW nYBottom = nPosY + pViewData->VisibleCellsY(eVWhich);
     if (nYBottom > MAXROW) nYBottom = MAXROW;
 
+    // Store the current visible range.
+    maVisibleRange.mnCol1 = nPosX;
+    maVisibleRange.mnCol2 = nXRight;
+    maVisibleRange.mnRow1 = nPosY;
+    maVisibleRange.mnRow2 = nYBottom;
+
     if (nX1 > nXRight || nY1 > nYBottom)
         return;											// unsichtbar
     if (nX2 > nXRight) nX2 = nXRight;
-- 
1.7.0.1

