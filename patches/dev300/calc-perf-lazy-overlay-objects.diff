diff --git sc/source/ui/inc/gridwin.hxx sc/source/ui/inc/gridwin.hxx
index aae0353..7b9bac5 100644
--- sc/source/ui/inc/gridwin.hxx
+++ sc/source/ui/inc/gridwin.hxx
@@ -42,6 +42,7 @@
 
 #include <vector>
 #include <memory>
+#include <boost/shared_ptr.hpp>
 
 // ---------------------------------------------------------------------------
 
@@ -115,6 +116,25 @@ private:
     ::sdr::overlay::OverlayObjectList*              mpOOHeader;
     ::sdr::overlay::OverlayObjectList*              mpOOShrink;
 
+    ::boost::shared_ptr<Rectangle> mpAutoFillRect;
+
+    /** 
+     * Stores current visible column and row ranges, used to avoid expensive 
+     * operations on objects that are outside visible area. 
+     */
+    struct VisibleRange
+    {
+        SCCOL mnCol1;
+        SCCOL mnCol2;
+        SCROW mnRow1;
+        SCROW mnRow2;
+
+        VisibleRange();
+
+        bool isInside(SCCOL nCol, SCROW nRow) const;
+    };
+    VisibleRange maVisibleRange;
+
 private:
     ScViewData*				pViewData;
     ScSplitPos				eWhich;
diff --git sc/source/ui/view/gridwin.cxx sc/source/ui/view/gridwin.cxx
index e591f86..9754ccd 100644
--- sc/source/ui/view/gridwin.cxx
+++ sc/source/ui/view/gridwin.cxx
@@ -159,7 +159,19 @@ extern USHORT nScFillModeMouseModifier;				// global.cxx
 
 #define SC_FILTERLISTBOX_LINES	12
 
-//==================================================================
+// ============================================================================
+
+ScGridWindow::VisibleRange::VisibleRange() :
+    mnCol1(0), mnCol2(MAXCOL), mnRow1(0), mnRow2(MAXROW)
+{
+}
+
+bool ScGridWindow::VisibleRange::isInside(SCCOL nCol, SCROW nRow) const
+{
+    return mnCol1 <= nCol && nCol <= mnCol2 && mnRow1 <= nRow && nRow <= mnRow2;
+}
+
+// ============================================================================
 
 class ScFilterListBox : public ListBox
 {
@@ -372,6 +384,7 @@ ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhic
             mpOODragRect( NULL ),
             mpOOHeader( NULL ),
             mpOOShrink( NULL ),
+            mpAutoFillRect(static_cast<Rectangle*>(NULL)),
             pViewData( pData ),
             eWhich( eWhichPos ),
             pNoteMarker( NULL ),
@@ -1352,30 +1365,17 @@ BOOL ScGridWindow::TestMouse( const MouseEvent& rMEvt, BOOL bAction )
         ScRange aMarkRange;
         if (pViewData->GetSimpleArea( aMarkRange ) == SC_MARK_SIMPLE)
         {
-            if ( aMarkRange.aStart.Tab() == pViewData->GetTabNo() )
+            if (aMarkRange.aStart.Tab() == pViewData->GetTabNo() && mpAutoFillRect)
             {
-                //	Block-Ende wie in DrawAutoFillMark
-                SCCOL nX = aMarkRange.aEnd.Col();
-                SCROW nY = aMarkRange.aEnd.Row();
-
-                Point aFillPos = pViewData->GetScrPos( nX, nY, eWhich, TRUE );
-                long nSizeXPix;
-                long nSizeYPix;
-                pViewData->GetMergeSizePixel( nX, nY, nSizeXPix, nSizeYPix );
-                aFillPos.X() += nSizeXPix * nLayoutSign;
-                aFillPos.Y() += nSizeYPix;
-                if ( bLayoutRTL )
-                    aFillPos.X() -= 1;
-
                 Point aMousePos = rMEvt.GetPosPixel();
-                //	Abfrage hier passend zu DrawAutoFillMark
-                //	(ein Pixel mehr als markiert)
-                if ( aMousePos.X() >= aFillPos.X()-3 && aMousePos.X() <= aFillPos.X()+4 &&
-                     aMousePos.Y() >= aFillPos.Y()-3 && aMousePos.Y() <= aFillPos.Y()+4 )
+                if (mpAutoFillRect->IsInside(aMousePos))
                 {
-                    SetPointer( Pointer( POINTER_CROSS ) );		//! dickeres Kreuz ?
+                    SetPointer( Pointer( POINTER_CROSS ) );     //! dickeres Kreuz ?
                     if (bAction)
                     {
+                        SCCOL nX = aMarkRange.aEnd.Col();
+                        SCROW nY = aMarkRange.aEnd.Row();
+
                         if ( lcl_IsEditableMatrix( pViewData->GetDocument(), aMarkRange ) )
                             pViewData->SetDragMode(
                                 aMarkRange.aStart.Col(), aMarkRange.aStart.Row(), nX, nY, SC_FILL_MATRIX );
@@ -5189,6 +5189,9 @@ void ScGridWindow::UpdateCursorOverlay()
     SCCOL nX = pViewData->GetCurX();
     SCROW nY = pViewData->GetCurY();
 
+    if (!maVisibleRange.isInside(nX, nY))
+        return;
+
     //  don't show the cursor in overlapped cells
 
     ScDocument* pDoc = pViewData->GetDocument();
@@ -5359,6 +5362,7 @@ void ScGridWindow::UpdateSelectionOverlay()
 void ScGridWindow::DeleteAutoFillOverlay()
 {
     DELETEZ( mpOOAutoFill );
+    mpAutoFillRect.reset();
 }
 
 void ScGridWindow::UpdateAutoFillOverlay()
@@ -5379,6 +5383,11 @@ void ScGridWindow::UpdateAutoFillOverlay()
     {
         SCCOL nX = aAutoMarkPos.Col();
         SCROW nY = aAutoMarkPos.Row();
+
+        if (!maVisibleRange.isInside(nX, nY))
+            // Autofill mark is not visible.  Bail out.
+            return;
+
         SCTAB nTab = pViewData->GetTabNo();
         ScDocument* pDoc = pViewData->GetDocument();
         BOOL bLayoutRTL = pDoc->IsLayoutRTL( nTab );
@@ -5394,7 +5403,7 @@ void ScGridWindow::UpdateAutoFillOverlay()
 
         aFillPos.Y() += nSizeYPix;
         aFillPos.Y() -= 2;
-        Rectangle aFillRect( aFillPos, Size(6,6) );
+        mpAutoFillRect.reset(new Rectangle(aFillPos, Size(6, 6)));
     
         // #i70788# get the OverlayManager safely
         ::sdr::overlay::OverlayManager* pOverlayManager = getOverlayManager();
@@ -5407,7 +5416,7 @@ void ScGridWindow::UpdateAutoFillOverlay()
                 aHandleColor = SC_MOD()->GetColorConfig().GetColorValue(svtools::CALCPAGEBREAKAUTOMATIC).nColor;
             std::vector< basegfx::B2DRange > aRanges;
             const basegfx::B2DHomMatrix aTransform(GetInverseViewTransformation());
-            basegfx::B2DRange aRB(aFillRect.Left(), aFillRect.Top(), aFillRect.Right() + 1, aFillRect.Bottom() + 1);
+            basegfx::B2DRange aRB(mpAutoFillRect->Left(), mpAutoFillRect->Top(), mpAutoFillRect->Right() + 1, mpAutoFillRect->Bottom() + 1);
             
             aRB.transform(aTransform);
             aRanges.push_back(aRB);
@@ -5422,10 +5431,10 @@ void ScGridWindow::UpdateAutoFillOverlay()
             mpOOAutoFill = new ::sdr::overlay::OverlayObjectList;
             mpOOAutoFill->append(*pOverlay);
         }
-    }
 
-    if ( aOldMode != aDrawMode )
-        SetMapMode( aOldMode );
+        if ( aOldMode != aDrawMode )
+            SetMapMode( aOldMode );
+    }
 }
 
 void ScGridWindow::DeleteDragRectOverlay()
diff --git sc/source/ui/view/gridwin4.cxx sc/source/ui/view/gridwin4.cxx
index 23edc22..8e456d2 100644
--- sc/source/ui/view/gridwin4.cxx
+++ sc/source/ui/view/gridwin4.cxx
@@ -451,6 +451,12 @@ void ScGridWindow::Draw( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2, ScUpdateMod
     SCROW nYBottom = nPosY + pViewData->VisibleCellsY(eVWhich);
     if (nYBottom > MAXROW) nYBottom = MAXROW;
 
+    // Store the current visible range.
+    maVisibleRange.mnCol1 = nPosX;
+    maVisibleRange.mnCol2 = nXRight;
+    maVisibleRange.mnRow1 = nPosY;
+    maVisibleRange.mnRow2 = nYBottom;
+
     if (nX1 > nXRight || nY1 > nYBottom)
         return;											// unsichtbar
     if (nX2 > nXRight) nX2 = nXRight;
