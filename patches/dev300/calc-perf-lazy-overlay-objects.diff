diff --git sc/source/ui/inc/gridwin.hxx sc/source/ui/inc/gridwin.hxx
index 30b563b..cc58475 100644
--- sc/source/ui/inc/gridwin.hxx
+++ sc/source/ui/inc/gridwin.hxx
@@ -40,6 +40,7 @@
 
 #include <vector>
 #include <memory>
+#include <boost/shared_ptr.hpp>
 
 // ---------------------------------------------------------------------------
 
@@ -152,9 +153,28 @@ private:
     ::sdr::overlay::OverlayObjectList*              mpOOHeader;
     ::sdr::overlay::OverlayObjectList*              mpOOShrink;
 
+    ::boost::shared_ptr<Rectangle> mpAutoFillRect;
+
+    /** 
+     * Stores current visible column and row ranges, used to avoid expensive 
+     * operations on objects that are outside visible area. 
+     */
+    struct VisibleRange
+    {
+        SCCOL mnCol1;
+        SCCOL mnCol2;
+        SCROW mnRow1;
+        SCROW mnRow2;
+
+        VisibleRange();
+
+        bool isInside(SCCOL nCol, SCROW nRow) const;
+    };
+    VisibleRange maVisibleRange;
+
 private:
-	ScViewData*				pViewData;
-	ScSplitPos				eWhich;
+    ScViewData*				pViewData;
+    ScSplitPos				eWhich;
 	ScHSplitPos				eHWhich;
 	ScVSplitPos				eVWhich;
 
diff --git sc/source/ui/view/gridwin.cxx sc/source/ui/view/gridwin.cxx
index f0aab2d..d77f055 100644
--- sc/source/ui/view/gridwin.cxx
+++ sc/source/ui/view/gridwin.cxx
@@ -389,7 +389,19 @@ sal_Bool lcl_GetHyperlinkCell(ScDocument* pDoc, SCCOL& rPosX, SCROW& rPosY, SCTA
 	return bFound;
 }
 
-//==================================================================
+// ============================================================================
+
+ScGridWindow::VisibleRange::VisibleRange() :
+    mnCol1(0), mnCol2(MAXCOL), mnRow1(0), mnRow2(MAXROW)
+{
+}
+
+bool ScGridWindow::VisibleRange::isInside(SCCOL nCol, SCROW nRow) const
+{
+    return mnCol1 <= nCol && nCol <= mnCol2 && mnRow1 <= nRow && nRow <= mnRow2;
+}
+
+// ============================================================================
 
 //	WB_DIALOGCONTROL noetig fuer UNO-Controls
 ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhichPos )
@@ -403,9 +415,10 @@ ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhic
             mpOODragRect( NULL ),
             mpOOHeader( NULL ),
             mpOOShrink( NULL ),
-			pViewData( pData ),
-			eWhich( eWhichPos ),
-			pNoteMarker( NULL ),
+            mpAutoFillRect(static_cast<Rectangle*>(NULL)),
+            pViewData( pData ),
+            eWhich( eWhichPos ),
+            pNoteMarker( NULL ),
 			pFilterBox( NULL ),
 			pFilterFloat( NULL ),
             mpDPFieldPopup(NULL),
@@ -1298,36 +1311,23 @@ BOOL ScGridWindow::TestMouse( const MouseEvent& rMEvt, BOOL bAction )
 
 		//	Auto-Fill
 
-		ScRange aMarkRange;
-		if (pViewData->GetSimpleArea( aMarkRange ) == SC_MARK_SIMPLE)
-		{
-			if ( aMarkRange.aStart.Tab() == pViewData->GetTabNo() )
-			{
-				//	Block-Ende wie in DrawAutoFillMark
-				SCCOL nX = aMarkRange.aEnd.Col();
-				SCROW nY = aMarkRange.aEnd.Row();
-
-				Point aFillPos = pViewData->GetScrPos( nX, nY, eWhich, TRUE );
-				long nSizeXPix;
-				long nSizeYPix;
-				pViewData->GetMergeSizePixel( nX, nY, nSizeXPix, nSizeYPix );
-				aFillPos.X() += nSizeXPix * nLayoutSign;
-				aFillPos.Y() += nSizeYPix;
-				if ( bLayoutRTL )
-					aFillPos.X() -= 1;
+        ScRange aMarkRange;
+        if (pViewData->GetSimpleArea( aMarkRange ) == SC_MARK_SIMPLE)
+        {
+            if (aMarkRange.aStart.Tab() == pViewData->GetTabNo() && mpAutoFillRect)
+            {
+                Point aMousePos = rMEvt.GetPosPixel();
+                if (mpAutoFillRect->IsInside(aMousePos))
+                {
+                    SetPointer( Pointer( POINTER_CROSS ) );     //! dickeres Kreuz ?
+                    if (bAction)
+                    {
+                        SCCOL nX = aMarkRange.aEnd.Col();
+                        SCROW nY = aMarkRange.aEnd.Row();
 
-				Point aMousePos = rMEvt.GetPosPixel();
-				//	Abfrage hier passend zu DrawAutoFillMark
-				//	(ein Pixel mehr als markiert)
-				if ( aMousePos.X() >= aFillPos.X()-3 && aMousePos.X() <= aFillPos.X()+4 &&
-					 aMousePos.Y() >= aFillPos.Y()-3 && aMousePos.Y() <= aFillPos.Y()+4 )
-				{
-					SetPointer( Pointer( POINTER_CROSS ) );		//! dickeres Kreuz ?
-					if (bAction)
-					{
-						if ( lcl_IsEditableMatrix( pViewData->GetDocument(), aMarkRange ) )
-							pViewData->SetDragMode(
-								aMarkRange.aStart.Col(), aMarkRange.aStart.Row(), nX, nY, SC_FILL_MATRIX );
+                        if ( lcl_IsEditableMatrix( pViewData->GetDocument(), aMarkRange ) )
+                            pViewData->SetDragMode(
+                                aMarkRange.aStart.Col(), aMarkRange.aStart.Row(), nX, nY, SC_FILL_MATRIX );
 						else
 							pViewData->SetFillMode(
 								aMarkRange.aStart.Col(), aMarkRange.aStart.Row(), nX, nY );
@@ -5273,6 +5273,9 @@ void ScGridWindow::UpdateCursorOverlay()
     SCCOL nX = pViewData->GetCurX();
     SCROW nY = pViewData->GetCurY();
 
+    if (!maVisibleRange.isInside(nX, nY))
+        return;
+
     //  don't show the cursor in overlapped cells
 
     ScDocument* pDoc = pViewData->GetDocument();
@@ -5443,6 +5446,7 @@ void ScGridWindow::UpdateSelectionOverlay()
 void ScGridWindow::DeleteAutoFillOverlay()
 {
     DELETEZ( mpOOAutoFill );
+    mpAutoFillRect.reset();
 }
 
 void ScGridWindow::UpdateAutoFillOverlay()
@@ -5463,6 +5467,11 @@ void ScGridWindow::UpdateAutoFillOverlay()
     {
         SCCOL nX = aAutoMarkPos.Col();
         SCROW nY = aAutoMarkPos.Row();
+
+        if (!maVisibleRange.isInside(nX, nY))
+            // Autofill mark is not visible.  Bail out.
+            return;
+
         SCTAB nTab = pViewData->GetTabNo();
         ScDocument* pDoc = pViewData->GetDocument();
         BOOL bLayoutRTL = pDoc->IsLayoutRTL( nTab );
@@ -5478,7 +5487,7 @@ void ScGridWindow::UpdateAutoFillOverlay()
 
         aFillPos.Y() += nSizeYPix;
         aFillPos.Y() -= 2;
-        Rectangle aFillRect( aFillPos, Size(6,6) );
+        mpAutoFillRect.reset(new Rectangle(aFillPos, Size(6, 6)));
 
         //
         //  convert into logic units
@@ -5486,7 +5495,7 @@ void ScGridWindow::UpdateAutoFillOverlay()
 
         sdr::overlay::OverlayObjectCell::RangeVector aRanges;
 
-        Rectangle aLogic( PixelToLogic( aFillRect, aDrawMode ) );
+        Rectangle aLogic( PixelToLogic( *mpAutoFillRect, aDrawMode ) );
 
         const basegfx::B2DPoint aTopLeft(aLogic.Left(), aLogic.Top());
         const basegfx::B2DPoint aBottomRight(aLogic.Right(), aLogic.Bottom());
@@ -5507,13 +5516,13 @@ void ScGridWindow::UpdateAutoFillOverlay()
                 new sdr::overlay::OverlayObjectCell( eType, aHandleColor, aRanges );
 
 		    pOverlayManager->add(*pOverlay);
-			mpOOAutoFill = new ::sdr::overlay::OverlayObjectList;
-			mpOOAutoFill->append(*pOverlay);
-		}
-    }
+            mpOOAutoFill = new ::sdr::overlay::OverlayObjectList;
+            mpOOAutoFill->append(*pOverlay);
+        }
 
-    if ( aOldMode != aDrawMode )
-        SetMapMode( aOldMode );
+        if ( aOldMode != aDrawMode )
+            SetMapMode( aOldMode );
+    }
 }
 
 void ScGridWindow::DeleteDragRectOverlay()
diff --git sc/source/ui/view/gridwin4.cxx sc/source/ui/view/gridwin4.cxx
index 2e88791..f49bcb3 100644
--- sc/source/ui/view/gridwin4.cxx
+++ sc/source/ui/view/gridwin4.cxx
@@ -448,12 +448,18 @@ void ScGridWindow::Draw( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2, ScUpdateMod
 
 	SCCOL nXRight = nPosX + pViewData->VisibleCellsX(eHWhich);
 	if (nXRight > MAXCOL) nXRight = MAXCOL;
-	SCROW nYBottom = nPosY + pViewData->VisibleCellsY(eVWhich);
-	if (nYBottom > MAXROW) nYBottom = MAXROW;
-
-	if (nX1 > nXRight || nY1 > nYBottom)
-		return;											// unsichtbar
-	if (nX2 > nXRight) nX2 = nXRight;
+    SCROW nYBottom = nPosY + pViewData->VisibleCellsY(eVWhich);
+    if (nYBottom > MAXROW) nYBottom = MAXROW;
+
+    // Store the current visible range.
+    maVisibleRange.mnCol1 = nPosX;
+    maVisibleRange.mnCol2 = nXRight;
+    maVisibleRange.mnRow1 = nPosY;
+    maVisibleRange.mnRow2 = nYBottom;
+
+    if (nX1 > nXRight || nY1 > nYBottom)
+        return;											// unsichtbar
+    if (nX2 > nXRight) nX2 = nXRight;
 	if (nY2 > nYBottom) nY2 = nYBottom;
 
 	if ( eMode != SC_UPDATE_MARKS )
