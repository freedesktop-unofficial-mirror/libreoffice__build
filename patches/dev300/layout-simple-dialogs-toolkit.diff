diff --git a/toolkit/doc/layout/TODO b/toolkit/doc/layout/TODO
index abd717c..31ec597 100644
--- toolkit/doc/layout/TODO
+++ toolkit/doc/layout/TODO
@@ -4,6 +4,11 @@
 ** Move everything & development into new layout-dialogs CWS
 
 ** cleanups
+*** Add XRadioButton2 and layout::VCLXRadioButton with
+    {get,set}RadioGroup.  Remove import.cxx RadioGroups::RadioGroup,
+    VCLXRadioButton::getFirstActionListener () and [actionListener
+    juggling in] layout::RadioButton_impl::SetClickHdl() and
+    EnableRadioCheck() layout::RadioButton_impl::Check.
 *** layout/import.hxx: what's this generator stuff?
 #if 0
 // generator
@@ -87,7 +92,6 @@ but keep using yes/no on Windows, eg?
 *** remove -DTEST_LAYOUT=1 from util/makefile.mk?
 
 ** fixes
-*** mpRadioGroup HACK --> use radiogroup property
 *** missing properties
 	'title' -> 'Set Zoom'
 Missing prop Title
@@ -102,14 +106,18 @@ fHorAlign = fVerAlign = 0.5; --> float const [CENTER?] = 0.5;
 
 ** include full translations
 *** zoom
-grep zoom.src svx/source/dialog/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "janneke\\vc\\layout-cws\\toolkit\\workben\\layout\\zoom.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/FL_\(ZOOM\)_label/FL_\1_text/' -e 's/\t_label/\tRID_SVXDLG_ZOOM_title/'
-**** done, except for View Layout update: no strings in localize.sdf yet,
-     must redo.
+grep zoom.src svx/source/dialog/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "janneke\\vc\\layout-cws\\toolkit\\workben\\layout\\zoom.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SVXDLG_ZOOM_title/' 
 *** wordcount
 grep wordcountdialog.src sw/source/ui/dialog/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "janneke\\vc\\layout-cws\\toolkit\\workben\\layout\\workben.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/FL_\([A-Z]*\)_label/FL_\1_text/' -e 's/\t_label/\tDLG_WORDCOUNT_title/'s
 *** sortdlg
 grep sortdlg.src ../../../sc/source/ui/src/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "janneke\\vc\\layout-cws\\toolkit\\workben\\layout\\sort-options.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SCDLG_SORT_title/' | grep -E '	(nl|de|en-US)	' > localize-str.sdf
-
+grep sortdlg.src sc/source/ui/src/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "sc\\uiconfig\\layout\\sort-options.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SCDLG_SORT_title/' > sc/uiconfig/layout/localize-sort-options.sdf
+*** insert-sheet
+grep instbdlg.src sc/source/ui/miscdlgs/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "sc\\uiconfig\\layout\\insert-sheet.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SCDLG_INSERT_TABLE_title/' > sc/uiconfig/layout/localize-insert-sheet.sdf
+*** move-copy-sheet
+grep -E 'miscdlgs.src.*(FT_DEST|FT_INSERT|STR_NEWDOC|RID_SCDLG_MOVETAB|BTN_COPY)' sc/source/ui/src/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "sc\\uiconfig\\layout\\move-copy-sheet.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SCDLG_MOVETAB_title/' > sc/uiconfig/layout/localize-move-copy-sheet.sdf
+*** find-and-replace
+grep srchdlg.src svx/source/dialog/localize.sdf | awk -F'\t' '{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "svx\\uiconfig\\layout\\find-and-replace.xml", $3, "layout", $6 "_label", "", "", $8, "0", $10, $11, $12, "", $14, $15}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SVXDLG_SEARCH_title/' > svx/uiconfig/layout/localize-find-and-replace.sdf
 
 * i18n
     + forget java property files nonsense
diff --git a/toolkit/inc/layout/layout-post.hxx b/toolkit/inc/layout/layout-post.hxx
index 54ed610..e97fa99 100644
--- toolkit/inc/layout/layout-post.hxx
+++ toolkit/inc/layout/layout-post.hxx
@@ -34,6 +34,10 @@
 
 #if ENABLE_LAYOUT
 
+/* Allow re-inclusion for cxx file. */
+#undef _LAYOUT_PRE_HXX
+
+
 #undef AdvancedButton
 #undef ApplyButton
 #undef Box
@@ -45,6 +49,7 @@
 #undef Control
 #undef Dialog
 #undef Edit
+#undef ErrorBox
 #undef FixedImage
 #undef FixedInfo
 #undef FixedLine
@@ -52,11 +57,15 @@
 #undef HBox
 #undef HelpButton
 #undef IgnoreButton
+#undef InfoBox
 #undef ListBox
+#undef MessBox
+#undef MessageBox
 #undef MetricField
 #undef MetricFormatter
 #undef MoreButton
 #undef MultiLineEdit
+#undef MultiListBox
 #undef NoButton
 #undef NumericField
 #undef NumericFormatter
@@ -64,36 +73,32 @@
 #undef Plugin
 #undef ProgressBar
 #undef PushButton
+#undef QueryBox
 #undef RadioButton
 #undef ResetButton
 #undef RetryButton
+#undef SfxTabPage
+#undef SfxTabDialog
 #undef SpinField
-#undef Table
+#undef TabDialog
+#undef TabControl
 #undef TabPage
+#undef Table
 #undef VBox
+#undef WarningBox
 #undef YesButton
 
 #undef ModalDialog
 #undef ModelessDialog
+#undef ScExpandedFixedText
+#undef SfxDialog
 #undef SfxModalDialog
-#undef SfxTabPage
+#undef SfxModelessDialog
 
 #undef SvxLanguageBox
 
 #undef Window
 
-
-#undef SVX_RES
-#define SVX_RES(i)        ResId(i,DIALOG_MGR())
-
-#undef SvtResId
-
-#undef SW_RES
-#define SW_RES(i)               ResId(i,SWDIALOG_MGR())
-
-/* Allow re-inclusion for cxx file. */
-#undef _LAYOUT_PRE_HXX
-
 #endif /* ENABLE_LAYOUT */
 
 #endif /* _LAYOUT_POST_HXX */
diff --git a/toolkit/inc/layout/layout-pre.hxx b/toolkit/inc/layout/layout-pre.hxx
index fbbc1df..e43f048 100644
--- toolkit/inc/layout/layout-pre.hxx
+++ toolkit/inc/layout/layout-pre.hxx
@@ -34,15 +34,8 @@
 
 #if ENABLE_LAYOUT
 
-//#if !LAYOUT
-//#define LAYOUT 1
-//#endif
-//#define LAYOUT_NS layout
-
-// TWBN, but find that SfxModalDialog and FixedLine are already defined, eg compiling
-// dlgfact.cxx
-//typedef layout::Dialog SfxModalDialog;
-//typedef layout::FixedLine FixedLine;
+///* Allow re-inclusion for next hxx file. */
+#undef _LAYOUT_POST_HXX
 
 #define AdvancedButton layout::AdvancedButton
 #define ApplyButton layout::ApplyButton
@@ -55,6 +48,7 @@
 #define Control layout::Control
 #define Dialog layout::Dialog
 #define Edit layout::Edit
+#define ErrorBox layout::ErrorBox
 #define FixedImage layout::FixedImage
 #define FixedInfo layout::FixedInfo
 #define FixedLine layout::FixedLine
@@ -62,11 +56,16 @@
 #define HBox layout::HBox
 #define HelpButton layout::HelpButton
 #define IgnoreButton layout::IgnoreButton
+#define InfoBox layout::InfoBox
+#define LocalizedString layout::LocalizedString
 #define ListBox layout::ListBox
+#define MessBox layout::MessBox
+#define MessageBox layout::MessageBox
 #define MetricField layout::MetricField
 #define MetricFormatter layout::MetricFormatter
 #define MoreButton layout::MoreButton
 #define MultiLineEdit layout::MultiLineEdit
+#define MultiListBox layout::MultiListBox
 #define NoButton layout::NoButton
 #define NumericField layout::NumericField
 #define NumericFormatter layout::NumericFormatter
@@ -74,64 +73,36 @@
 #define Plugin layout::Plugin
 #define ProgressBar layout::ProgressBar
 #define PushButton layout::PushButton
+#define QueryBox layout::QueryBox
 #define RadioButton layout::RadioButton
 #define ResetButton layout::ResetButton
 #define RetryButton layout::RetryButton
+#define SfxTabDialog layout::SfxTabDialog
+#define SfxTabPage layout::SfxTabPage
 #define SpinField layout::SpinField
-#define Table layout::Table
+#define TabControl layout::TabControl
 #define TabPage layout::TabPage
+#define Table layout::Table
 #define VBox layout::VBox
+#define WarningBox layout::WarningBox
 #define YesButton layout::YesButton
 
 #define ModalDialog Dialog
 #define ModelessDialog Dialog
+#define ScExpandedFixedText FixedText
+#define SfxDialog Dialog
 #define SfxModalDialog Dialog
-#define SfxTabPage TabPage
+#define SfxModelessDialog Dialog
+#define TabDialog Dialog
 
 #define SvxLanguageBox ListBox
 
 #define Window ::Window
 
-#define LAYOUT_DIALOG_PARENT\
-    VCLXWindow::GetImplementation( uno::Reference <awt::XWindow> ( GetPeer(), uno::UNO_QUERY ) )->GetWindow()
-
-#undef SVX_RES
-#define SVX_RES(x) #x
-#undef SvtResId
-#define SvtResId(x) #x
-#undef SW_RES
-#define SW_RES(x) #x
-
-/* Hmm.  These hacks make zoom.cxx, wordcountdialog.cxx, ... diffs
- * smaller but 'tis not really scalable. */
-#ifdef _LAYOUT_POST_HXX
-
-#ifdef _SVX_RECOVER_CXX
-#undef SfxModalDialog
-// 3rd parameter must match ID in <modaldialog> "RID_SVXDLG_RECOVER", localize.sdf
-#define SfxModalDialog( pParent, SVX_RES_RID ) Dialog( pParent, "recover.xml", "RID_SVXDLG_RECOVER" )
-#endif /* _SVX_RECOVER_CXX */
-
-#ifdef SW_WORDCOUNTDIALOG_HXX
-#undef SfxModalDialog
-// 3rd parameter must match ID in <modaldialog> "DLG_WORDCOUNT", localize.sdf
-#define SfxModalDialog( pParent, SW_RES_RID ) Dialog( pParent, "wordcount.xml", "DLG_WORDCOUNT" )
-#define SW_WORDCOUNTDIALOG_HRC
-#endif /* SW_WORDCOUNTDIALOG_HXX */
-
-#ifdef _SVX_ZOOM_CXX
-#undef SfxModalDialog
-// 3rd parameter must match ID in <modaldialog> "RID_SVXDLG_ZOOM", localize.sdf
-#define SfxModalDialog( pParent, SVX_RES_RID ) Dialog( pParent, "zoom.xml", "RID_SVXDLG_ZOOM" )
-#define _SVX_ZOOM_HRC
-#endif /* _SVX_ZOOM_CXX */
-
-#endif /* _LAYOUT_POST_HXX */
-
-#else /* !ENABLE_LAYOUT */
+#else
 
-#define LAYOUT_PRE_POST 1
+#define LocalizedString String
 
-#endif /* !ENABLE_LAYOUT */
+#endif /* ENABLE_LAYOUT */
 
 #endif /* _LAYOUT_PRE_HXX */
diff --git a/toolkit/inc/layout/layout.hxx b/toolkit/inc/layout/layout.hxx
index 62b7ffa..1c596ec 100644
--- toolkit/inc/layout/layout.hxx
+++ toolkit/inc/layout/layout.hxx
@@ -32,28 +32,46 @@
 #ifndef _LAYOUT_HXX
 #define _LAYOUT_HXX
 
-#include <com/sun/star/uno/XInterface.hpp>
 #include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <com/sun/star/uno/XInterface.hpp>
 #include <com/sun/star/util/Color.hpp>
 #include <i18npool/lang.h>
+#include <toolkit/dllapi.h>
 #include <tools/gen.hxx>
 #include <tools/link.hxx>
 #include <tools/string.hxx>
-
-// FIXME: eventually wrap FieldUnit
+#include <vcl/combobox.h>
 #include <vcl/fldunit.hxx>
-// FIXME: eventually wrap this too ...
+#include <vcl/lstbox.h>
+#include <vcl/smartid.hxx>
 #include <vcl/wintypes.hxx>
 
-#include <toolkit/dllapi.h>
-
+class Button;
+class ComboBox;
 class Control;
+class Dialog;
 class Image;
-class SfxPoolItem;
-class SfxItemSet;
+class ListBox;
+class MapMode;
+class MultiListBox;
+class NotifyEvent;
+class Pointer;
+class PushButton;
+class RadioButton;
+class ResId;
+class SfxChildWinInfo;
+class TabControl;
+class TabPage;
+class VCLXRadioButton;
 class VCLXWindow;
 class Window;
-class TabPage;
+
+namespace layoutimpl
+{
+class VCLXTabControl;
+}
+
+class VCLXTabControl;
 
 namespace com { namespace sun { namespace star { namespace awt { class XWindow; } } } }
 
@@ -70,7 +88,7 @@ class TOOLKIT_DLLPUBLIC Context
 public:
     Context( char const* pPath );
     virtual ~Context();
-    PeerHandle GetPeerHandle( char const* pId, sal_uInt32 nId = 0 ) const;
+    PeerHandle GetPeerHandle( char const* id, sal_uInt32 nId = 0 ) const;
     void setToplevel( PeerHandle xToplevel );
     PeerHandle getToplevel();
     PeerHandle getRoot();
@@ -83,46 +101,88 @@ public:
             par( pImpl ) {} \
         char const* GetUnoName() const; \
     public: \
-        t( Context *pCtx, char const* pId, sal_uInt32 nId = 0 ); \
-        t( Window *pParent, WinBits nStyle = defaultWinBit )
+        t( Context *context, char const* id, sal_uInt32 nId = 0 ); \
+        t( Window *parent, WinBits nStyle = defaultWinBit ); \
+        t (Window *parent, ResId const &res)
 #define DECL_GET_IMPL(t) \
         inline t##Impl &getImpl() const
 
+#define DECL_GET_WINDOW( cls ) ::cls* Get##cls() const
+#define IMPL_GET_WINDOW( cls ) ::cls* cls::Get##cls() const { return reinterpret_cast< ::cls*>( GetWindow() ); }
+
+#define DECL_GET_VCLXWINDOW( cls ) ::VCLX##cls* GetVCLX##cls() const
+#define IMPL_GET_VCLXWINDOW( cls ) ::VCLX##cls* cls::Get##VCLX##cls() const { return reinterpret_cast< ::VCLX##cls*>( GetVCLXWindow() ); }
+
+#define DECL_GET_LAYOUT_VCLXWINDOW( cls ) ::layoutimpl::VCLX##cls* GetVCLX##cls() const
+#define IMPL_GET_LAYOUT_VCLXWINDOW( cls ) ::layoutimpl::VCLX##cls* cls::Get##VCLX##cls() const { return reinterpret_cast< ::layoutimpl::VCLX##cls*>( GetVCLXWindow() ); }
+
 // follows the VCL inheritance hierarchy ...
 
 class WindowImpl;
 class TOOLKIT_DLLPUBLIC Window
 {
 protected:
+    friend class WindowImpl;
     WindowImpl *mpImpl;
-    static PeerHandle CreatePeer( Window *pParent, WinBits nStyle,
+    static PeerHandle CreatePeer( Window *parent, WinBits nStyle,
                                   char const* pName);
+
+    virtual void setRes (ResId const& res);
+
 public:
     DECL_GET_IMPL( Window );
     explicit Window( WindowImpl *pImpl );
     virtual ~Window();
 
-    PeerHandle GetPeer();
+    PeerHandle GetPeer() const;
     Context *getContext();
 
     void Enable( bool bEnable = true );
     inline void Disable() { Enable( false ); }
-    void Show( BOOL bVisible = TRUE );
-    inline void Hide() { Show( FALSE ); }
+    void Show( bool bVisible = true );
+    inline void Hide() { Show( false ); }
     void GrabFocus();
     void FreeResource() {}
 
-    void SetParent( Window *pParent );
-    void SetParent( ::Window *pParent );
+    void SetParent( ::Window *parent );
+    virtual void ParentSet (Window *window);
+    void SetParent( Window *parent );
 
-    css::uno::Reference<css::awt::XWindow> GetRef();
-    VCLXWindow* GetVCLXWindow();
-    ::Window* GetWindow();
-    ::Window* GetParent();
+    css::uno::Reference<css::awt::XWindow> GetRef() const;
+    VCLXWindow* GetVCLXWindow() const;
+    ::Window* GetWindow() const;
+    ::Window* GetParent() const;
 
+    void SetPointer( Pointer const& pointer );
+    Pointer const& GetPointer() const;
     WinBits GetStyle();
-    void SetStyle( WinBits nStyle );
-    void SetUpdateMode( bool /*bUpdate*/ ) { }
+    void SetText( rtl::OUString const& str );
+    String GetText() const;
+    void SetStyle( WinBits style );
+    void SetUpdateMode( bool mode );
+    void SetHelpId( sal_uIntPtr id );
+    sal_uIntPtr GetHelpId() const;
+    void SetSmartHelpId( SmartId const&, SmartIdUpdateMode mode=SMART_SET_SMART );
+    SmartId GetSmartHelpId() const;
+    void EnterWait ();
+    void LeaveWait ();
+    bool IsWait () const;
+    //void Enable (bool enable=true, bool child=true);
+    //void Disable (bool child=true);
+    bool IsEnabled () const;
+    void EnableInput (bool enable=true, bool child=true);
+    bool IsInputEnabled () const;
+
+    bool IsVisible () const;
+    bool HasChildPathFocus (bool systemWindow=false) const;
+    void SetPosPixel (Point const&);
+    Point GetPosPixel () const;
+    void SetSizePixel (Size const&);
+    Size GetSizePixel () const;
+    sal_Int32 GetCtrlTextWidth (rtl::OUString const& str) const;
+    sal_Int32 GetTextHeight () const;
+
+    Size LogicToPixel( Size const& size, MapMode const& mapMode=(MapMode const&)*(MapMode*)0 ) const;
 };
 
 class ControlImpl;
@@ -130,8 +190,13 @@ class TOOLKIT_DLLPUBLIC Control : public Window
 {
     DECL_GET_IMPL( Control );
     DECL_CONSTRUCTORS( Control, Window, 0 );
+
 public:
-// void SetText( String const& rStr ); - can't do this here ...
+    ~Control ();
+    void SetGetFocusHdl (Link const& link);
+    Link& GetGetFocusHdl ();
+    void SetLoseFocusHdl (Link const& link);
+    Link& GetLoseFocusHdl ();
 };
 
 class FixedLineImpl;
@@ -139,6 +204,7 @@ class TOOLKIT_DLLPUBLIC FixedLine : public Control
 {
     DECL_GET_IMPL( FixedLine );
     DECL_CONSTRUCTORS( FixedLine, Control, WB_HORZ );
+
 public:
     bool IsEnabled();
 };
@@ -148,8 +214,10 @@ class TOOLKIT_DLLPUBLIC FixedText : public Control
 {
     DECL_GET_IMPL( FixedText );
     DECL_CONSTRUCTORS( FixedText, Control, 0 );
+
 public:
-    void SetText( String const& rStr );
+    ~FixedText ();
+    void SetText( rtl::OUString const& rStr );
 };
 
 class FixedImageImpl;
@@ -183,13 +251,18 @@ class TOOLKIT_DLLPUBLIC Button : public Control
 {
     DECL_GET_IMPL( Button );
     DECL_CONSTRUCTORS( Button, Control, 0 );
+    DECL_GET_WINDOW (Button);
+
 public:
-    void SetText( String const& rStr );
-    BOOL SetModeImage( const Image& rImage );
+    ~Button ();
+    static String GetStandardText (sal_uInt16 button_type);
+    void SetText( rtl::OUString const& rStr );
+    bool SetModeImage( const Image& rImage );
     void SetImageAlign( ImageAlign eAlign );
 
     void SetClickHdl( Link const& rLink );
     virtual void Click() /* pure virtual? */;
+    Link& GetClickHdl ();
 };
 
 class PushButtonImpl;
@@ -197,9 +270,12 @@ class TOOLKIT_DLLPUBLIC PushButton : public Button
 {
     DECL_GET_IMPL( PushButton );
     DECL_CONSTRUCTORS( PushButton, Button, 0 );
+    DECL_GET_WINDOW (PushButton);
+
 public:
-    void Check( BOOL bCheck = TRUE );
-    BOOL IsChecked() const;
+    ~PushButton ();
+    void Check( bool bCheck=true );
+    bool IsChecked() const;
 
     void Toggle();
     void SetToggleHdl( Link const& rLink );
@@ -252,6 +328,12 @@ class TOOLKIT_DLLPUBLIC AdvancedButton : public PushButton
     void AddSimple( Window* w );
     void RemoveAdvanced( Window* w );
     void RemoveSimple( Window* w );
+
+    void SetAdvancedText (rtl::OUString const& text);
+    void SetSimpleText (rtl::OUString const& text);
+    rtl::OUString GetAdvancedText () const;
+    rtl::OUString GetSimpleText () const;
+    void SetDelta (int);
 };
 
 class MoreButtonImpl;
@@ -261,6 +343,11 @@ class TOOLKIT_DLLPUBLIC MoreButton : public AdvancedButton
     DECL_GET_IMPL( MoreButton );
     void AddWindow( Window* w );
     void RemoveWindow( Window* w );
+
+    void SetMoreText (rtl::OUString const& text);
+    void SetLessText (rtl::OUString const& text);
+    rtl::OUString GetMoreText () const;
+    rtl::OUString GetLessText () const;
 };
 
 class RadioButtonImpl;
@@ -268,9 +355,12 @@ class TOOLKIT_DLLPUBLIC RadioButton : public Button
 {
     DECL_GET_IMPL( RadioButton );
     DECL_CONSTRUCTORS( RadioButton, Button, 0 );
+    DECL_GET_WINDOW( RadioButton );
+    DECL_GET_VCLXWINDOW( RadioButton );
 public:
-    void Check( BOOL bCheck = TRUE );
-    BOOL IsChecked() const;
+    ~RadioButton ();
+    void Check( bool bCheck=true );
+    bool IsChecked() const;
 
     void Toggle();
     void SetToggleHdl( Link const& rLink );
@@ -281,9 +371,11 @@ class TOOLKIT_DLLPUBLIC CheckBox : public Button
 {
     DECL_GET_IMPL( CheckBox );
     DECL_CONSTRUCTORS( CheckBox, Button, 0 );
+
 public:
-    void Check( BOOL bCheck = TRUE );
-    BOOL IsChecked() const;
+    ~CheckBox ();
+    void Check( bool bCheck=true );
+    bool IsChecked() const;
 
     void Toggle();
     void SetToggleHdl( Link const& rLink );
@@ -294,9 +386,11 @@ class TOOLKIT_DLLPUBLIC Edit : public Control
 {
     DECL_GET_IMPL( Edit );
     DECL_CONSTRUCTORS( Edit, Control, WB_BORDER );
+
 public:
-    void SetText( XubString const& rStr ) const;
-    XubString GetText() const;
+    ~Edit ();
+    void SetText( rtl::OUString const& rStr ) const;
+    String GetText() const;
     void SetModifyHdl( Link const& rLink );
     void SetSelection( Selection const& rSelection );
 };
@@ -320,8 +414,7 @@ class TOOLKIT_DLLPUBLIC FormatterBase
 {
 protected:
     FormatterBaseImpl *mpFormatImpl;
-    FormatterBase( FormatterBaseImpl *pFormatImpl )
-        : mpFormatImpl( pFormatImpl ) {}
+    FormatterBase( FormatterBaseImpl *pFormatImpl );
 };
 
 class NumericFormatterImpl;
@@ -346,8 +439,8 @@ class TOOLKIT_DLLPUBLIC NumericField : public SpinField, public NumericFormatter
 {
     DECL_GET_IMPL( NumericField );
 public:
-    NumericField( Context *pCtx, char const* pId, sal_uInt32 nId = 0 );
-    NumericField( Window *pParent, WinBits nStyle );
+    NumericField( Context *context, char const* id, sal_uInt32 nId=0 );
+    NumericField( Window *parent, WinBits nStyle );
 };
 
 class MetricFormatterImpl;
@@ -358,12 +451,12 @@ class TOOLKIT_DLLPUBLIC MetricFormatter : public FormatterBase
     explicit MetricFormatter( FormatterBaseImpl *pImpl );
     MetricFormatterImpl &getFormatImpl() const;
 public:
-    void SetMin( sal_Int64 nNewMin, FieldUnit nUnit = FUNIT_NONE );
-    void SetMax( sal_Int64 nNewMax, FieldUnit nUnit = FUNIT_NONE );
-    void SetFirst( sal_Int64 nNewFirst, FieldUnit nUnit = FUNIT_NONE );
-    void SetLast( sal_Int64 nNewLast, FieldUnit nUnit = FUNIT_NONE );
-    void SetValue( sal_Int64 nNewValue, FieldUnit nUnit = FUNIT_NONE );
-    sal_Int64 GetValue( FieldUnit nUnit = FUNIT_NONE ) const;
+    void SetMin( sal_Int64 nNewMin, FieldUnit nUnit=FUNIT_NONE );
+    void SetMax( sal_Int64 nNewMax, FieldUnit nUnit=FUNIT_NONE );
+    void SetFirst( sal_Int64 nNewFirst, FieldUnit nUnit=FUNIT_NONE );
+    void SetLast( sal_Int64 nNewLast, FieldUnit nUnit=FUNIT_NONE );
+    void SetValue( sal_Int64 nNewValue, FieldUnit nUnit=FUNIT_NONE );
+    sal_Int64 GetValue( FieldUnit nUnit=FUNIT_NONE ) const;
 
     void SetSpinSize( sal_Int64 nNewSize );
 };
@@ -373,124 +466,209 @@ class TOOLKIT_DLLPUBLIC MetricField : public SpinField, public MetricFormatter
 {
     DECL_GET_IMPL( MetricField );
 public:
-    MetricField( Context *pCtx, char const* pId, sal_uInt32 nId = 0 );
-    MetricField( Window *pParent, WinBits nStyle );
+    MetricField( Context *context, char const* id, sal_uInt32 nId=0 );
+    MetricField( Window *parent, WinBits nStyle );
 };
 
-#define COMBOBOX_APPEND            ((USHORT)0xFFFF)
-#define COMBOBOX_ENTRY_NOTFOUND    ((USHORT)0xFFFF)
 class ComboBoxImpl;
 class TOOLKIT_DLLPUBLIC ComboBox : public Edit
 {
     DECL_GET_IMPL( ComboBox );
+    DECL_GET_WINDOW (ComboBox );
     DECL_CONSTRUCTORS( ComboBox, Edit, 0 );
 
 public:
-    USHORT InsertEntry( XubString const& rStr, USHORT nPos = COMBOBOX_APPEND );
-    void RemoveEntry( XubString const& rStr );
-    void RemoveEntry( USHORT nPos );
+    ~ComboBox ();
+    sal_uInt16 InsertEntry( rtl::OUString const& rStr, sal_uInt16 nPos=COMBOBOX_APPEND );
+    void RemoveEntry( rtl::OUString const& rStr );
+    void RemoveEntry( sal_uInt16 nPos );
     void Clear();
 
-    USHORT GetEntryPos( XubString const& rStr ) const;
-    XubString GetEntry( USHORT nPos ) const;
-    USHORT GetEntryCount() const;
+    sal_uInt16 GetEntryPos( rtl::OUString const& rStr ) const;
+    String GetEntry( sal_uInt16 nPos ) const;
+    sal_uInt16 GetEntryCount() const;
 
     void SetClickHdl( Link const& rLink );
     void SetSelectHdl( Link const& rLink );
+    void EnableAutocomplete (bool enable, bool matchCase=false );
 };
 
-#define LISTBOX_APPEND               ((USHORT)0xFFFF)
-#define LISTBOX_ENTRY_NOTFOUND       ((USHORT)0xFFFF)
 class ListBoxImpl;
 class TOOLKIT_DLLPUBLIC ListBox : public Control
 {
     DECL_GET_IMPL( ListBox );
     DECL_CONSTRUCTORS( ListBox, Control, WB_BORDER );
+    DECL_GET_WINDOW (ListBox);
+
 public:
-    USHORT InsertEntry( XubString const& rStr, USHORT nPos = LISTBOX_APPEND );
+    ~ListBox ();
+    sal_uInt16 InsertEntry( rtl::OUString const& rStr, sal_uInt16 nPos=LISTBOX_APPEND );
 
-    void RemoveEntry( XubString const& rStr );
-    void RemoveEntry( USHORT nPos );
+    void RemoveEntry( rtl::OUString const& rStr );
+    void RemoveEntry( sal_uInt16 nPos );
     void Clear();
 
-    USHORT GetEntryPos( XubString const& rStr ) const;
-    XubString GetEntry( USHORT nPos ) const;
-    USHORT GetEntryCount() const;
+    sal_uInt16 GetEntryPos( rtl::OUString const& rStr ) const;
+    String GetEntry( sal_uInt16 nPos ) const;
+    sal_uInt16 GetEntryCount() const;
 
-    void SelectEntry( XubString const& rStr, BOOL bSelect = TRUE );
-    void SelectEntryPos( USHORT nPos, BOOL bSelect = TRUE );
+    void SelectEntry( rtl::OUString const& rStr, bool bSelect=true );
+    void SelectEntryPos( sal_uInt16 nPos, bool bSelect=true );
 
-    USHORT GetSelectEntryCount() const;
-    XubString GetSelectEntry( USHORT nSelIndex = 0 ) const;
-    USHORT GetSelectEntryPos( USHORT nSelIndex = 0 ) const;
+    sal_uInt16 GetSelectEntryCount() const;
+    String GetSelectEntry( sal_uInt16 nSelIndex=0 ) const;
+    sal_uInt16 GetSelectEntryPos( sal_uInt16 nSelIndex=0 ) const;
 
     void SetSelectHdl( Link const& rLink );
     void SetClickHdl( Link const& rLink );
 
-    void SetEntryData( USHORT/*nPos*/, void*/*pNewData*/) { }
-    void* GetEntryData( USHORT/*nPos*/) const { return 0; } 
+    void SetEntryData (sal_uInt16 pos, void* data);
+    void* GetEntryData (sal_uInt16 pos) const;
 
     // SvxLanguageBox
-    void SetLanguageList( INT16/*nLangList*/, bool/*bHasLangNone*/, bool /*bLangNoneIsLangAll*/= false, bool /*bCheckSpellAvail*/= false ) { }
+    void SetLanguageList (sal_Int16 list, bool hasLangNone, bool langNoneIsLangAll=false, bool checkSpellAvailable=false);
+
+    sal_uInt16 InsertLanguage (LanguageType const type, sal_uInt16 pos=LISTBOX_APPEND);
+    sal_uInt16 InsertLanguage (LanguageType const type, bool checkEntry, sal_uInt16 pos=LISTBOX_APPEND);
+    void RemoveLanguage (LanguageType const type);
+    void SelectLanguage (LanguageType const type, bool select=true);
+    LanguageType GetSelectLanguage () const;
+    bool IsLanguageSelected( LanguageType const type) const;
+};
 
-    USHORT InsertLanguage( const LanguageType/*eLangType*/, USHORT/*nPos*/= LISTBOX_APPEND ) { return 0; }
-    USHORT InsertLanguage( const LanguageType/*eLangType*/, bool/*bCheckEntry*/, USHORT /*nPos*/= LISTBOX_APPEND ) { return 0; }
-    void RemoveLanguage( const LanguageType/*eLangType*/) { }
-    void SelectLanguage( const LanguageType/*eLangType*/, bool/*bSelect*/= true) { }
-    LanguageType GetSelectLanguage() const { return 0; }
-    bool IsLanguageSelected( const LanguageType/*eLangType*/) const { return true; }
+class MultiListBoxImpl;
+class TOOLKIT_DLLPUBLIC MultiListBox : public ListBox
+{
+    DECL_GET_IMPL( MultiListBox );
+    DECL_CONSTRUCTORS( MultiListBox, ListBox, 0 );
+    DECL_GET_WINDOW( MultiListBox );
 };
 
 class DialogImpl;
 class TOOLKIT_DLLPUBLIC Dialog : public Context, public Window
 {
-    DECL_GET_IMPL( Dialog );
+    DECL_GET_WINDOW (Dialog);
+
 public:
-    Dialog( Window *pOptParent, char const* pXMLPath, char const* pId, sal_uInt32 nId = 0 );
-    Dialog( ::Window *pOptParent, char const* pXMLPath, char const* pId, sal_uInt32 nId = 0 );
-    short Execute();
-    void EndDialog( long nResult = 0 );
-    void SetText( String const& rStr );
+    DECL_GET_IMPL (Dialog);
+    Dialog( Window *parent, char const* xml_file, char const* id, sal_uInt32 nId=0 );
+    Dialog( ::Window *parent, char const* xml_file, char const* id, sal_uInt32 nId=0 );
+    ~Dialog ();
+    virtual short Execute();
+    void EndDialog( long nResult=0 );
+    void SetText( rtl::OUString const& rStr );
+    void SetTitle (rtl::OUString const& rStr );
+    bool Close ();
+    long Notify (NotifyEvent & event);
+
+    // Sxf*Dialog
+    bool bConstruct;
+	void Initialize (SfxChildWinInfo*);
+};
+
+#define DECL_MESSAGE_BOX_CTORS(Name)\
+    public:\
+    Name##Box (::Window *parent, char const* message,\
+               char const* yes=0, char const* no=0, sal_uIntPtr help_id=0,\
+               char const* xml_file="message-box.xml", char const* id="message-box");\
+    Name##Box (::Window *parent, rtl::OUString const& message,\
+               rtl::OUString yes=String (),\
+               rtl::OUString no=String (),\
+               sal_uIntPtr help_id=0,\
+               char const* xml_file="message-box.xml", char const* id="message-box");\
+    Name##Box (::Window *parent, WinBits, char const* message,\
+               char const* yes=0, char const* no=0, sal_uIntPtr help_id=0,\
+               char const* xml_file="message-box.xml", char const* id="message-box");\
+    Name##Box (::Window *parent, WinBits, rtl::OUString const& message,\
+               rtl::OUString yes=String (),\
+               rtl::OUString no=String (),\
+               sal_uIntPtr help_id=0,\
+               char const* xml_file="message-box.xml", char const* id="message-box")\
+
+class TOOLKIT_DLLPUBLIC MessageBox : public Dialog
+{
+    DECL_MESSAGE_BOX_CTORS(Message);
+
+protected:
+    FixedImage imageError;
+    FixedImage imageInfo;
+    FixedImage imageQuery;
+    FixedImage imageWarning;
+    FixedText messageText;
+    CancelButton cancelButton;
+    HelpButton helpButton;
+    IgnoreButton ignoreButton;
+    NoButton noButton;
+    RetryButton retryButton;
+    YesButton yesButton;
+
+    void bits_init (WinBits bits, rtl::OUString const& message,
+                    rtl::OUString yes, rtl::OUString, sal_uIntPtr help_id);
+    void init (rtl::OUString const& message,
+               rtl::OUString const& yes, rtl::OUString const& no, sal_uIntPtr help_id);
+    void init (char const* message, char const* yes, char const* no, sal_uIntPtr help_id);
+};
+
+#define CLASS_MESSAGE_BOX(Name)\
+    class TOOLKIT_DLLPUBLIC Name##Box : public MessageBox\
+    {\
+        DECL_MESSAGE_BOX_CTORS (Name);\
+    }
+
+//CLASS_MESSAGE_BOX (Mess);
+typedef MessageBox MessBox;
+CLASS_MESSAGE_BOX (Error);
+CLASS_MESSAGE_BOX (Info);
+CLASS_MESSAGE_BOX (Query);
+CLASS_MESSAGE_BOX (Warning);
+
+#undef CLASS_MESSAGE_BOX
+
+#ifndef TAB_APPEND
+#define TAB_APPEND -1
+#endif /* !TAB_APPEND */
+
+class TabControlImpl;
+class TOOLKIT_DLLPUBLIC TabControl : public Control
+{
+    DECL_GET_IMPL (TabControl);
+    DECL_CONSTRUCTORS (TabControl, Control, 0);
+    DECL_GET_WINDOW (TabControl);
+    DECL_GET_LAYOUT_VCLXWINDOW (TabControl);
+
+public:
+    ~TabControl ();
+    void InsertPage (sal_uInt16 id, rtl::OUString const& title, sal_uInt16 pos=TAB_APPEND);
+    void RemovePage (sal_uInt16 id);
+    sal_uInt16 GetPageCount () const;
+    sal_uInt16 GetPageId (sal_uInt16 pos) const;
+    sal_uInt16 GetPagePos (sal_uInt16 id) const;
+    void SetCurPageId (sal_uInt16 id);
+    sal_uInt16 GetCurPageId () const;
+    void SetTabPage (sal_uInt16 id, ::TabPage* page);
+    ::TabPage* GetTabPage (sal_uInt16 id) const;
+    void SetActivatePageHdl (Link const& link);
+    Link& GetActivatePageHdl () const;
+    void SetDeactivatePageHdl (Link const& link);
+    Link& GetDeactivatePageHdl () const;
+    void SetTabPageSizePixel (Size const& size);
+    Size GetTabPageSizePixel () const;
 };
 
-#define DECL_GET_WINDOW( cls ) ::cls* Get##cls()
-#define IMPL_GET_WINDOW( cls ) ::cls* cls::Get##cls() { return reinterpret_cast< ::cls*>( GetWindow() ); }
 class TabPageImpl;
 class TOOLKIT_DLLPUBLIC TabPage : public Context, public Window
 {
     DECL_GET_IMPL( TabPage );
 public:
     static ::Window* global_parent;
+    static TabControl* global_tabcontrol;
     
-    TabPage( Window *pOptParent, char const* pXMLPath, char const* pId, sal_uInt32 nId = 0, SfxItemSet const* set = 0 );
-    TabPage( ::Window *pOptParent, char const* pXMLPath, char const* pId, sal_uInt32 nId = 0, SfxItemSet const* set = 0 );
+    TabPage( Window *parent, char const* xml_file, char const* id, sal_uInt32 nId=0 );
+    TabPage( ::Window *parent, char const* xml_file, char const* id, sal_uInt32 nId=0 );
     ~TabPage();
-    //DECL_GET_WINDOW( TabPage );
-    ::TabPage* GetTabPage();
+    DECL_GET_WINDOW( TabPage );
     virtual void ActivatePage();
     virtual void DeactivatePage();
-#if 0
-};
-
-//FIXME: move to sfx2 or svtools layout.hxx
-class TOOLKIT_DLLPUBLIC SfxTabPage : public TabPage
-{
-public:
-    SfxTabPage( Window *pOptParent, char const* pXMLPath, char const* pId, sal_uInt32 nId = 0, SfxItemSet const* set = 0 );
-    SfxTabPage( ::Window *pOptParent, char const* pXMLPath, char const* pId, sal_uInt32 nId = 0, SfxItemSet const* set = 0 );
-#endif
-    // SfxTabPage...
-    enum PageAction { KEEP_PAGE, LEAVE_PAGE, REFRESH_SET };
-
-    bool bHasExchangeSupport;
-    bool HasExchangeSupport() { return bHasExchangeSupport; }
-    SfxItemSet const* pSet;
-    SfxItemSet const& GetItemSet() const { return *pSet; }
-    virtual void Reset( SfxItemSet const& r );
-    void SetExchangeSupport( bool exchangeSupport = true ) { bHasExchangeSupport = exchangeSupport; }
-    //static const SfxPoolItem* GetItem( const SfxItemSet& rSet, USHORT nSlot );
-	virtual void ActivatePage( SfxItemSet const& ) { }
-	virtual int DeactivatePage( SfxItemSet* ) { return LEAVE_PAGE; }
 };
 
 class ProgressBarImpl;
@@ -516,7 +694,7 @@ protected:
     css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
     Container( rtl::OUString const& rName, sal_Int32 nBorder );
 public:
-    Container( Context const* pCtx, char const* pId );
+    Container( Context const* context, char const* id );
 
     void Add( Window *pWindow );
     void Add( Container *pContainer );
@@ -540,11 +718,11 @@ class TOOLKIT_DLLPUBLIC Table : public Container
 protected:
     Table( sal_Int32 nBorder, sal_Int32 nColumns );
 public:
-    Table( Context const* pCtx, char const* pId );
+    Table( Context const* context, char const* id );
     void Add( Window *pWindow, bool bXExpand, bool bYExpand,
-              sal_Int32 nXSpan = 1, sal_Int32 nYSpan = 1 );
+              sal_Int32 nXSpan=1, sal_Int32 nYSpan=1 );
     void Add( Container *pContainer, bool bXExpand, bool bYExpand,
-              sal_Int32 nXSpan = 1, sal_Int32 nYSpan = 1 );
+              sal_Int32 nXSpan=1, sal_Int32 nYSpan=1 );
 
 private:
     void setProps( css::uno::Reference< css::awt::XLayoutConstrains > xChild,
@@ -556,7 +734,7 @@ class TOOLKIT_DLLPUBLIC Box : public Container
 protected:
     Box( rtl::OUString const& rName, sal_Int32 nBorder, bool bHomogeneous );
 public:
-    Box( Context const* pCtx, char const* pId );
+    Box( Context const* context, char const* id );
     void Add( Window *pWindow, bool bExpand, bool bFill, sal_Int32 nPadding);
     void Add( Container *pContainer, bool bExpand, bool bFill, sal_Int32 nPadding);
 
@@ -568,13 +746,13 @@ private:
 class TOOLKIT_DLLPUBLIC HBox : public Box
 {
 public:
-    HBox( Context const* pCtx, char const* pId );
+    HBox( Context const* context, char const* id );
     HBox( sal_Int32 nBorder, bool bHomogeneous );
 };
 class TOOLKIT_DLLPUBLIC VBox : public Box
 {
 public:
-    VBox( Context const* pCtx, char const* pId );
+    VBox( Context const* context, char const* id );
     VBox( sal_Int32 nBorder, bool bHomogeneous );
 };
 
@@ -585,21 +763,50 @@ class TOOLKIT_DLLPUBLIC Plugin : public Control
     //DECL_CONSTRUCTORS( Plugin, Control, 0 );
 public:
     ::Control *mpPlugin;
-    Plugin( Context *pCtx, char const* pId, ::Control *plugin );
+    Plugin( Context *context, char const* id, ::Control *plugin );
 };
 
 class LocalizedStringImpl;
 class TOOLKIT_DLLPUBLIC LocalizedString : public Window
 {
     DECL_GET_IMPL( LocalizedString );
+
 public:
-    LocalizedString( Context *pCtx, char const* pId );
+    LocalizedString( Context *context, char const* id );
 
-    String operator =( String const& );
-    operator String();
-//    operator String const&() const;
+    rtl::OUString operator= (rtl::OUString const&);
+    rtl::OUString operator+= (sal_Unicode );
+    rtl::OUString operator+= (rtl::OUString const&);
+
+    operator rtl::OUString();
+    String getString ();
+    rtl::OUString getOUString ();
+    rtl::OUString GetToken (sal_uInt32 i, sal_Char c);
+};
+
+class InPlugImpl;
+class TOOLKIT_DLLPUBLIC InPlug : public Context, public Window
+{
+    DECL_GET_IMPL (InPlug);
+
+public:
+    InPlug ( Window *parent, char const* xml_file, char const* id, sal_uInt32 nId=0);
+    InPlug ( ::Window *parent, char const* xml_file, char const* id, sal_uInt32 nId=0);
+
+    void ParentSet (Window *window);
 };
 
 } // end namespace layout
 
+#if ENABLE_LAYOUT
+#define LAYOUT_NS layout::
+#define LAYOUT_DIALOG_PARENT\
+    VCLXWindow::GetImplementation( uno::Reference <awt::XWindow> ( GetPeer(), uno::UNO_QUERY ) )->GetWindow()
+#define LAYOUT_THIS_WINDOW( this ) this->GetWindow ()
+#else /* !ENABLE_LAYOUT */
+#define LAYOUT_NS
+#define LAYOUT_DIALOG_PARENT this
+#define LAYOUT_THIS_WINDOW( this ) this
+#endif /* !ENABLE_LAYOUT */
+
 #endif /* _LAYOUT_HXX */
diff --git a/toolkit/inc/layout/layoutcore.hxx b/toolkit/inc/layout/layoutcore.hxx
deleted file mode 100644
index 34d4b01..0000000
--- toolkit/inc/layout/layoutcore.hxx
+++ /dev/null
@@ -1,80 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef _LAYOUT_CORE_HXX_
-#define _LAYOUT_CORE_HXX_
-
-#include <com/sun/star/awt/XToolkit.hpp>
-#include <com/sun/star/graphic/XGraphic.hpp>
-#include <com/sun/star/awt/XLayoutContainer.hpp>
-#include <com/sun/star/awt/XLayoutConstrains.hpp>
-
-#include <layout/layout.hxx>
-
-namespace layoutimpl
-{
-
-namespace css = layout::css;
-
-css::uno::Reference< css::awt::XLayoutContainer >
-createContainer( const rtl::OUString &rName );
-
-css::uno::Reference< css::awt::XLayoutConstrains >
-createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-              css::uno::Reference< css::uno::XInterface > xParent,
-              const rtl::OUString &rName, long nProps );
-
-css::uno::Reference< css::awt::XLayoutConstrains >
-createInternalWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-                      css::uno::Reference< css::uno::XInterface > xParent,
-                      const rtl::OUString &rName, long nProps );
-
-css::uno::Reference< css::graphic::XGraphic > loadGraphic( const char *pName );
-
-// Helpers - unfortunately VCLXWindows don't implement XPropertySet
-// but containers do - these helpers help us to hide this
-namespace prophlp
-{
-// can we set properties on this handle ?
-bool TOOLKIT_DLLPUBLIC canHandleProps( const css::uno::Reference< css::uno::XInterface > &xRef );
-// if so which properties ?
-css::uno::Reference< css::beans::XPropertySetInfo > TOOLKIT_DLLPUBLIC queryPropertyInfo(
-    const css::uno::Reference< css::uno::XInterface > &xRef );
-// set / get ...
-void TOOLKIT_DLLPUBLIC setProperty( const css::uno::Reference< css::uno::XInterface > &xRef,
-                  const rtl::OUString &rName,
-                  css::uno::Any aValue );
-css::uno::Any TOOLKIT_DLLPUBLIC getProperty( const css::uno::Reference< css::uno::XInterface > &xRef,
-                           const rtl::OUString &rName );
-} // namespace prophlp
-} // namespace layoutimpl
-
-#endif // _LAYOUT_CORE_HXX_
diff --git a/toolkit/inc/toolkit/awt/vclxwindows.hxx b/toolkit/inc/toolkit/awt/vclxwindows.hxx
index 4c250ba..27a803c 100644
--- toolkit/inc/toolkit/awt/vclxwindows.hxx
+++ toolkit/inc/toolkit/awt/vclxwindows.hxx
@@ -181,6 +181,7 @@ protected:
 
 public:
 					VCLXButton();
+    ~VCLXButton();
 
 	// ::com::sun::star::lang::XComponent
     void SAL_CALL dispose(  ) throw(::com::sun::star::uno::RuntimeException);
@@ -346,6 +347,8 @@ public:
 
     static void     ImplGetPropertyIds( std::list< sal_uInt16 > &aIds );
     virtual void    GetPropertyIds( std::list< sal_uInt16 > &aIds ) { return ImplGetPropertyIds( aIds ); }
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > getFirstActionListener ();
 };
 
 //	----------------------------------------------------
@@ -764,6 +767,7 @@ protected:
 
 public:
 						VCLXComboBox();
+    ~VCLXComboBox();
 
 	// ::com::sun::star::uno::XInterface
     ::com::sun::star::uno::Any					SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
diff --git a/toolkit/prj/build.lst b/toolkit/prj/build.lst
index 8b7ac22..7fa0efa 100644
--- toolkit/prj/build.lst
+++ toolkit/prj/build.lst
@@ -2,10 +2,11 @@ ti	toolkit	:	vcl NULL
 ti	toolkit									usr1	-	all	ti_mkout NULL
 ti	toolkit\prj								get		-	all	ti_prj NULL
 ti	toolkit\inc								nmake	-	all	ti_inc NULL
+ti	toolkit\uiconfig\layout									nmake	-	all	ti_uiconfig_layout NULL
 ti	toolkit\source\helper					nmake	-	all	ti_helper  ti_inc NULL
 ti	toolkit\source\awt						nmake	-	all	ti_awt  ti_inc NULL
 ti	toolkit\source\controls					nmake	-	all	ti_controls  ti_inc NULL
 ti	toolkit\source\controls\tree			nmake	-	all	ti_tree  NULL
-ti	toolkit\source\layout    nmake	-	all	ti_layout NULL
-ti	toolkit\source\vclcompat nmake	-	all	ti_vclcompat NULL
-ti	toolkit\util							nmake	-	all	ti_util ti_awt ti_controls ti_layout ti_helper ti_tree ti_vclcompat NULL
+ti	toolkit\source\layout\core			nmake	-	all	ti_layout_core  NULL
+ti	toolkit\source\layout\vcl			nmake	-	all	ti_layout_vcl  NULL
+ti	toolkit\util							nmake	-	all	ti_util ti_awt ti_controls ti_layout_core ti_helper ti_tree ti_layout_vcl NULL
diff --git a/toolkit/prj/d.lst b/toolkit/prj/d.lst
index 88ee9c8..93c048a 100644
--- toolkit/prj/d.lst
+++ toolkit/prj/d.lst
@@ -22,7 +22,9 @@ mkdir: %_DEST%\inc%_EXT%\toolkit\controls
 ..\inc\toolkit\awt\vclxdevice.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxdevice.hxx
 ..\inc\toolkit\awt\vclxfont.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxfont.hxx
 ..\inc\toolkit\awt\vclxtopwindow.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxtopwindow.hxx
+..\inc\toolkit\awt\vclxtoolkit.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxtoolkit.hxx
 ..\inc\toolkit\awt\vclxwindow.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxwindow.hxx
+..\source\awt\vclxdialog.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxdialog.hxx
 ..\inc\toolkit\awt\vclxwindows.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxwindows.hxx
 ..\inc\toolkit\awt\vclxmenu.hxx %_DEST%\inc%_EXT%\toolkit\awt\vclxmenu.hxx
 
@@ -52,3 +54,9 @@ mkdir: %_DEST%\inc%_EXT%\layout
 ..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
 
 ..\inc\layout\*.hxx %_DEST%\inc%_EXT%\layout\*.hxx
+mkdir: %_DEST%\inc%_EXT%\layout\core
+..\source\layout\core\*.hxx  %_DEST%\inc%_EXT%\layout\core\*.hxx
+mkdir: %_DEST%\inc%_EXT%\layout\vcl
+..\source\layout\vcl\*.hxx  %_DEST%\inc%_EXT%\layout\vcl\*.hxx
+
+..\%__SRC%\bin\*-layout.zip %_DEST%\pck%_EXT%\*.*
diff --git a/toolkit/source/awt/forward.hxx b/toolkit/source/awt/forward.hxx
index c3f5f24..7dc9278 100644
--- toolkit/source/awt/forward.hxx
+++ toolkit/source/awt/forward.hxx
@@ -67,4 +67,11 @@
         return aReturn; \
     }
 
+#if defined (_MSC_VER) && (_MSC_VER <= 1310)
+// Windows .Net2003 build fix
+#define W3K_EXPLICIT_CAST(x) static_cast <XWindow2*> (&x)
+#else // !(defined (_MSC_VER) && (_MSC_VER <= 1310))
+#define W3K_EXPLICIT_CAST(x) x
+#endif // !(defined (_MSC_VER) && (_MSC_VER <= 1310))
+
 #endif /*AWT_FORWARD_HXX*/
diff --git a/toolkit/source/awt/makefile.mk b/toolkit/source/awt/makefile.mk
index 8a851c5..033264a 100644
--- toolkit/source/awt/makefile.mk
+++ toolkit/source/awt/makefile.mk
@@ -43,9 +43,6 @@ ENABLE_EXCEPTIONS=TRUE
 
 # --- Files --------------------------------------------------------
 
-# FIXME: This is bad, hmkay
-CFLAGS+= -I$(PRJ)/source
-
 .IF "$(GUIBASE)"=="aqua"
 OBJCXXFLAGS=-x objective-c++ -fobjc-exceptions
 CFLAGSCXX+=$(OBJCXXFLAGS)
diff --git a/toolkit/source/awt/vclxbutton.cxx b/toolkit/source/awt/vclxbutton.cxx
index 1740dca..83ff928 100644
--- toolkit/source/awt/vclxbutton.cxx
+++ toolkit/source/awt/vclxbutton.cxx
@@ -31,7 +31,7 @@
 
 #include "vclxbutton.hxx"
 
-#include <layout/layoutcore.hxx>
+#include <layout/core/helper.hxx>
 #include <com/sun/star/awt/ImagePosition.hpp>
 #include <vcl/button.hxx>
 
diff --git a/toolkit/source/awt/vclxdialog.cxx b/toolkit/source/awt/vclxdialog.cxx
index 98de970..76e3993 100644
--- toolkit/source/awt/vclxdialog.cxx
+++ toolkit/source/awt/vclxdialog.cxx
@@ -109,7 +109,7 @@ void SAL_CALL VCLXDialog::dispose() throw(::com::sun::star::uno::RuntimeExceptio
         ::vos::OGuard aGuard( GetMutex() );
 
         ::com::sun::star::lang::EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
 //            maTabListeners.disposeAndClear( aDisposeEvent );
     }
 
@@ -211,6 +211,15 @@ void VCLXDialog::setTitle( const ::rtl::OUString& Title ) throw(::com::sun::star
         pWindow->SetText( Title );
 }
 
+void VCLXDialog::setHelpId( sal_Int32 id ) throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Window* pWindow = GetWindow();
+    if ( pWindow )
+        pWindow->SetHelpId( id );
+}
+
 ::rtl::OUString VCLXDialog::getTitle() throw(::com::sun::star::uno::RuntimeException)
 {
     ::vos::OGuard aGuard( GetMutex() );
diff --git a/toolkit/source/awt/vclxdialog.hxx b/toolkit/source/awt/vclxdialog.hxx
index 7f45718..e63f459 100644
--- toolkit/source/awt/vclxdialog.hxx
+++ toolkit/source/awt/vclxdialog.hxx
@@ -36,7 +36,7 @@
 #include <com/sun/star/awt/XSystemDependentWindowPeer.hpp>
 #include <com/sun/star/awt/XTopWindow.hpp>
 #include <comphelper/uno3.hxx>
-#include <layout/bin.hxx>
+#include <layout/core/bin.hxx>
 #include <toolkit/awt/vclxtopwindow.hxx>
 
 namespace layoutimpl
@@ -44,10 +44,10 @@ namespace layoutimpl
 
 typedef ::cppu::ImplHelper1 < ::com::sun::star::awt::XDialog2 > VCLXDialog_Base;
 
-class VCLXDialog :public VCLXWindow
-                 ,public VCLXTopWindow_Base
-                 ,public VCLXDialog_Base
-                 ,public Bin
+class TOOLKIT_DLLPUBLIC VCLXDialog : public VCLXWindow
+                                   , public VCLXTopWindow_Base
+                                   , public VCLXDialog_Base
+                                   , public Bin
 {
 private:
     bool bRealized, bResizeSafeguard;
@@ -102,6 +102,7 @@ public:
 
     // ::com::sun::star::awt::XDialog2
     void SAL_CALL endDialog( sal_Int32 nResult ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setHelpId( sal_Int32 id ) throw(::com::sun::star::uno::RuntimeException);
 
 };
 
diff --git a/toolkit/source/awt/vclxfixedline.cxx b/toolkit/source/awt/vclxfixedline.cxx
index 10c631d..68385ed 100644
--- toolkit/source/awt/vclxfixedline.cxx
+++ toolkit/source/awt/vclxfixedline.cxx
@@ -69,7 +69,7 @@ void SAL_CALL VCLXFixedLine::dispose( ) throw(RuntimeException)
         ::vos::OGuard aGuard( GetMutex() );
 
         EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
     }
 
     VCLXWindow::dispose();
diff --git a/toolkit/source/awt/vclxplugin.cxx b/toolkit/source/awt/vclxplugin.cxx
index f17552a..8145174 100644
--- toolkit/source/awt/vclxplugin.cxx
+++ toolkit/source/awt/vclxplugin.cxx
@@ -40,6 +40,8 @@
 #include <toolkit/helper/property.hxx>
 #include <vcl/ctrl.hxx>
 
+#include "forward.hxx"
+
 namespace layoutimpl
 {
 
@@ -63,7 +65,7 @@ void SAL_CALL VCLXPlugin::dispose() throw(uno::RuntimeException)
         ::vos::OGuard aGuard( GetMutex() );
         
         lang::EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
     }
     
     VCLXWindow::dispose();
diff --git a/toolkit/source/awt/vclxscroller.cxx b/toolkit/source/awt/vclxscroller.cxx
index 9e5674e..b532161 100644
--- toolkit/source/awt/vclxscroller.cxx
+++ toolkit/source/awt/vclxscroller.cxx
@@ -75,7 +75,7 @@ void SAL_CALL VCLXScroller::dispose( ) throw(RuntimeException)
         ::vos::OGuard aGuard( GetMutex() );
 
         EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
 //            maTabListeners.disposeAndClear( aDisposeEvent );
     }
 
diff --git a/toolkit/source/awt/vclxscroller.hxx b/toolkit/source/awt/vclxscroller.hxx
index 3f5c199..b2169a0 100644
--- toolkit/source/awt/vclxscroller.hxx
+++ toolkit/source/awt/vclxscroller.hxx
@@ -33,7 +33,7 @@
 #define LAYOUT_AWT_VCLXSCROLLER_HXX
 
 #include <comphelper/uno3.hxx>
-#include <layout/bin.hxx>
+#include <layout/core/bin.hxx>
 #include <toolkit/awt/vclxwindow.hxx>
 
 class ScrollBar;
diff --git a/toolkit/source/awt/vclxsplitter.cxx b/toolkit/source/awt/vclxsplitter.cxx
index f2efbb3..5530e46 100644
--- toolkit/source/awt/vclxsplitter.cxx
+++ toolkit/source/awt/vclxsplitter.cxx
@@ -113,7 +113,7 @@ void SAL_CALL VCLXSplitter::dispose( ) throw(RuntimeException)
         ::vos::OGuard aGuard( GetMutex() );
 
         EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
 //            maTabListeners.disposeAndClear( aDisposeEvent );
     }
 
diff --git a/toolkit/source/awt/vclxsplitter.hxx b/toolkit/source/awt/vclxsplitter.hxx
index 6fd186d..21a1b04 100644
--- toolkit/source/awt/vclxsplitter.hxx
+++ toolkit/source/awt/vclxsplitter.hxx
@@ -35,7 +35,7 @@
 #include <com/sun/star/awt/MaxChildrenException.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <comphelper/uno3.hxx>
-#include <layout/box-base.hxx>
+#include <layout/core/box-base.hxx>
 #include <toolkit/awt/vclxwindow.hxx>
 
 class Splitter;
diff --git a/toolkit/source/awt/vclxtabcontrol.cxx b/toolkit/source/awt/vclxtabcontrol.cxx
index 9ef31ca..782b3a8 100644
--- toolkit/source/awt/vclxtabcontrol.cxx
+++ toolkit/source/awt/vclxtabcontrol.cxx
@@ -43,16 +43,14 @@
 namespace layoutimpl
 {
 
-using namespace ::com::sun::star::uno;
-using namespace ::com::sun::star::awt;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star;
 
 VCLXTabControl::ChildProps::ChildProps( VCLXTabControl::ChildData *pData )
-    {
-        addProp( RTL_CONSTASCII_USTRINGPARAM( "Title" ),
-                 ::getCppuType( static_cast< const rtl::OUString* >( NULL ) ),
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Title" ),
+             ::getCppuType( static_cast< const rtl::OUString* >( NULL ) ),
              &(pData->maTitle) );
 }
 
@@ -66,7 +64,7 @@ VCLXTabControl::ChildData*
 VCLXTabControl::createChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
 {
     return new ChildData( xChild );
-    }
+}
 
 VCLXTabControl::ChildProps*
 VCLXTabControl::createChildProps( Box_Base::ChildData *pData )
@@ -76,12 +74,19 @@ VCLXTabControl::createChildProps( Box_Base::ChildData *pData )
 
 DBG_NAME( VCLXTabControl );
 
+#if !defined (__GNUC__)
+#define __PRETTY_FUNCTION__ __FUNCTION__
+#endif /* !__GNUC__ */
+
 VCLXTabControl::VCLXTabControl()
-: VCLXWindow()
-    , VCLXTabControl_Base()
+  : VCLXWindow()
+  , VCLXTabControl_Base()
   , Box_Base()
-  , mnNextTabId( 1 )
+  , mTabId (1)
+  , bRealized (false)
 {
+    OSL_TRACE ("\n********%s:%x", __PRETTY_FUNCTION__, this);
+
     DBG_CTOR( VCLXTabControl, NULL );
 }
 
@@ -94,13 +99,13 @@ IMPLEMENT_2_FORWARD_XINTERFACE2( VCLXTabControl, VCLXWindow, Container, VCLXTabC
 
 IMPLEMENT_FORWARD_XTYPEPROVIDER2( VCLXTabControl, VCLXWindow, VCLXTabControl_Base );
 
-void SAL_CALL VCLXTabControl::dispose( ) throw(RuntimeException)
+void SAL_CALL VCLXTabControl::dispose( ) throw(uno::RuntimeException)
 {
     {
         ::vos::OGuard aGuard( GetMutex() );
 
         EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
 //            maTabListeners.disposeAndClear( aDisposeEvent );
     }
 
@@ -108,38 +113,38 @@ void SAL_CALL VCLXTabControl::dispose( ) throw(RuntimeException)
 }
 
 #if 0
-void SAL_CALL VCLXTabControl::addTabListener( const Reference< XTabListener >& listener ) throw (RuntimeException)
+void SAL_CALL VCLXTabControl::addTabListener( const Reference< XTabListener >& listener ) throw (uno::RuntimeException)
 {
 if ( listener.is() )
 maTabListeners.addInterface( listener );
 }
 
-void SAL_CALL VCLXTabControl::removeTabListener( const Reference< XTabListener >& listener ) throw (RuntimeException)
+void SAL_CALL VCLXTabControl::removeTabListener( const Reference< XTabListener >& listener ) throw (uno::RuntimeException)
 {
 if ( listener.is() )
 maTabListeners.removeInterface( listener );
 }
 #endif
 
-TabControl *VCLXTabControl::getTabControl() const throw (RuntimeException)
+TabControl *VCLXTabControl::getTabControl() const throw (uno::RuntimeException)
 {
     TabControl *pTabControl = static_cast< TabControl* >( GetWindow() );
     if ( pTabControl )
         return pTabControl;
-    throw RuntimeException();
+    throw uno::RuntimeException();
 }
 
-sal_Int32 SAL_CALL VCLXTabControl::insertTab() throw (RuntimeException)
+sal_Int32 SAL_CALL VCLXTabControl::insertTab() throw (uno::RuntimeException)
 {
     TabControl *pTabControl = getTabControl();
-    USHORT id = sal::static_int_cast< USHORT >( mnNextTabId++ );
+    USHORT id = sal::static_int_cast< USHORT >( mTabId++ );
     rtl::OUString title (RTL_CONSTASCII_USTRINGPARAM( "" ) );
     pTabControl->InsertPage( id, title.getStr(), TAB_APPEND );
     pTabControl->SetTabPage( id, new TabPage( pTabControl ) );
     return id;
 }
 
-void SAL_CALL VCLXTabControl::removeTab( sal_Int32 ID ) throw (RuntimeException, IndexOutOfBoundsException)
+void SAL_CALL VCLXTabControl::removeTab( sal_Int32 ID ) throw (uno::RuntimeException, IndexOutOfBoundsException)
 {
     TabControl *pTabControl = getTabControl();
     if ( pTabControl->GetTabPage( sal::static_int_cast< USHORT >( ID ) ) == NULL )
@@ -147,7 +152,7 @@ void SAL_CALL VCLXTabControl::removeTab( sal_Int32 ID ) throw (RuntimeException,
     pTabControl->RemovePage( sal::static_int_cast< USHORT >( ID ) );
 }
 
-void SAL_CALL VCLXTabControl::activateTab( sal_Int32 ID ) throw (RuntimeException, IndexOutOfBoundsException)
+void SAL_CALL VCLXTabControl::activateTab( sal_Int32 ID ) throw (uno::RuntimeException, IndexOutOfBoundsException)
 {
     TabControl *pTabControl = getTabControl();
     if ( pTabControl->GetTabPage( sal::static_int_cast< USHORT >( ID ) ) == NULL )
@@ -155,15 +160,15 @@ void SAL_CALL VCLXTabControl::activateTab( sal_Int32 ID ) throw (RuntimeExceptio
     pTabControl->SelectTabPage( sal::static_int_cast< USHORT >( ID ) );
 }
 
-sal_Int32 SAL_CALL VCLXTabControl::getActiveTabID() throw (RuntimeException)
+sal_Int32 SAL_CALL VCLXTabControl::getActiveTabID() throw (uno::RuntimeException)
 {
     return getTabControl()->GetCurPageId( );
 }
 
-void SAL_CALL VCLXTabControl::addTabListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTabListener >& xListener ) throw (::com::sun::star::uno::RuntimeException)
+void SAL_CALL VCLXTabControl::addTabListener( const uno::Reference< awt::XTabListener >& xListener ) throw (uno::RuntimeException)
 {
-    for ( std::list< ::com::sun::star::uno::Reference
-              < ::com::sun::star::awt::XTabListener > >::const_iterator it
+    for ( std::list< uno::Reference
+              < awt::XTabListener > >::const_iterator it
               = mxTabListeners.begin(); it != mxTabListeners.end(); it++ )
     {
         if ( *it == xListener )
@@ -173,10 +178,10 @@ void SAL_CALL VCLXTabControl::addTabListener( const ::com::sun::star::uno::Refer
     mxTabListeners.push_back( xListener );
 }
 
-void SAL_CALL VCLXTabControl::removeTabListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTabListener >& xListener ) throw (::com::sun::star::uno::RuntimeException)
+void SAL_CALL VCLXTabControl::removeTabListener( const uno::Reference< awt::XTabListener >& xListener ) throw (uno::RuntimeException)
 {
-    for ( std::list< ::com::sun::star::uno::Reference
-              < ::com::sun::star::awt::XTabListener > >::iterator it
+    for ( std::list< uno::Reference
+              < awt::XTabListener > >::iterator it
               = mxTabListeners.begin(); it != mxTabListeners.end(); it++ )
     {
         if ( *it == xListener )
@@ -187,7 +192,7 @@ void SAL_CALL VCLXTabControl::removeTabListener( const ::com::sun::star::uno::Re
     }
 }
 
-void SAL_CALL VCLXTabControl::setTabProps( sal_Int32 ID, const Sequence< NamedValue >& Properties ) throw (RuntimeException, IndexOutOfBoundsException)
+void SAL_CALL VCLXTabControl::setTabProps( sal_Int32 ID, const uno::Sequence< NamedValue >& Properties ) throw (uno::RuntimeException, IndexOutOfBoundsException)
 {
     TabControl *pTabControl = getTabControl();
     if ( pTabControl->GetTabPage( sal::static_int_cast< USHORT >( ID ) ) == NULL )
@@ -196,7 +201,7 @@ void SAL_CALL VCLXTabControl::setTabProps( sal_Int32 ID, const Sequence< NamedVa
     for( int i = 0; i < Properties.getLength(); i++ )
     {
         const rtl::OUString &name = Properties[i].Name;
-        const Any &value = Properties[i].Value;
+        const uno::Any &value = Properties[i].Value;
 
         if ( name  == rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Title" ) ) )
         {
@@ -206,8 +211,8 @@ void SAL_CALL VCLXTabControl::setTabProps( sal_Int32 ID, const Sequence< NamedVa
     }
 }
 
-Sequence< NamedValue > SAL_CALL VCLXTabControl::getTabProps( sal_Int32 ID )
-    throw (IndexOutOfBoundsException, RuntimeException)
+uno::Sequence< NamedValue > SAL_CALL VCLXTabControl::getTabProps( sal_Int32 ID )
+    throw (IndexOutOfBoundsException, uno::RuntimeException)
 {
     TabControl *pTabControl = getTabControl();
     if ( pTabControl->GetTabPage( sal::static_int_cast< USHORT >( ID ) ) == NULL )
@@ -216,11 +221,11 @@ Sequence< NamedValue > SAL_CALL VCLXTabControl::getTabProps( sal_Int32 ID )
 #define ADD_PROP( seq, i, name, val ) {                                \
         NamedValue value;                                                  \
         value.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( name ) ); \
-        value.Value = makeAny( val );                                      \
+        value.Value = uno::makeAny( val );                                      \
         seq[i] = value;                                                    \
     }
 
-    Sequence< NamedValue > props( 2 );
+    uno::Sequence< NamedValue > props( 2 );
     ADD_PROP( props, 0, "Title", rtl::OUString( pTabControl->GetPageText( sal::static_int_cast< USHORT >( ID ) ) ) );
     ADD_PROP( props, 1, "Position", pTabControl->GetPagePos( sal::static_int_cast< USHORT >( ID ) ) );
 #undef ADD_PROP
@@ -228,7 +233,7 @@ Sequence< NamedValue > SAL_CALL VCLXTabControl::getTabProps( sal_Int32 ID )
 }
 
 // TODO: draw tab border here
-void SAL_CALL VCLXTabControl::draw( sal_Int32 nX, sal_Int32 nY ) throw(::com::sun::star::uno::RuntimeException)
+void SAL_CALL VCLXTabControl::draw( sal_Int32 nX, sal_Int32 nY ) throw(uno::RuntimeException)
 {
     ::vos::OGuard aGuard( GetMutex() );
 
@@ -249,16 +254,25 @@ void SAL_CALL VCLXTabControl::draw( sal_Int32 nX, sal_Int32 nY ) throw(::com::su
     VCLXWindow::draw( nX, nY );
 }
 
+void VCLXTabControl::AddChild (uno::Reference< awt::XLayoutConstrains > const& xChild)
+
+{
+    OSL_TRACE ("%s: children: %d", __PRETTY_FUNCTION__, maChildren.size ());
+    mIdMap[ xChild ] = mTabId++;
+    Box_Base::AddChild( xChild );
+    OSL_TRACE ("%s: children: %d", __PRETTY_FUNCTION__, maChildren.size ());
+}
+
 void SAL_CALL VCLXTabControl::addChild(
-    const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains > &xChild )
-    throw (::com::sun::star::uno::RuntimeException, ::com::sun::star::awt::MaxChildrenException)
+    const uno::Reference< awt::XLayoutConstrains > &xChild )
+    throw (uno::RuntimeException, awt::MaxChildrenException)
 {
     mIdMap[ xChild ] = insertTab();
     Box_Base::addChild( xChild );
-    }
+}
 
-void SAL_CALL VCLXTabControl::removeChild( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains > &xChild )
-    throw (::com::sun::star::uno::RuntimeException)
+void SAL_CALL VCLXTabControl::removeChild( const uno::Reference< awt::XLayoutConstrains > &xChild )
+    throw (uno::RuntimeException)
 {
     removeTab( mIdMap[xChild] );
     mIdMap[ xChild ] = -1;
@@ -284,22 +298,87 @@ static void setChildrenVisible( uno::Reference < awt::XLayoutConstrains > xChild
     }
 }
 
-void SAL_CALL VCLXTabControl::allocateArea(
-    const ::com::sun::star::awt::Rectangle &rArea )
-    throw (::com::sun::star::uno::RuntimeException)
+void SAL_CALL VCLXTabControl::allocateArea (awt::Rectangle const &area)
+    throw (uno::RuntimeException)
 {
-    maAllocation = rArea;
+    OSL_TRACE ("\n%s", __PRETTY_FUNCTION__);
+    maAllocation = area;
 
     TabControl *pTabControl = getTabControl();
 
-// FIXME: this is wrong. We just want to set tab controls pos/size for the tabs menu,
-// otherwise, it gets events that should go to children (I guess we could solve this
-// by making the tabcontrol as the actual XWindow parent of its children, when importing...)
-// Not sure about TabPage drawing... That doesn't work on gtk+; just ignoring that.
-// LATER: Nah, the proper fix is to get the XWindow hierarchy straight.
-
-    setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height, PosSize::POSSIZE );
+// FIXME: this is wrong. We just want to set tab controls pos/size for
+// the tabs menu, otherwise, it gets events that should go to children
+// (I guess we could solve this by making the tabcontrol as the actual
+// XWindow parent of its children, when importing...)  Not sure about
+// TabPage drawing... That doesn't work on gtk+; just ignoring that.
+// LATER: Nah, the proper fix is to get the XWindow hierarchy
+// straight.
 
+#if 0
+    setPosSize( area.X, area.Y, area.Width, area.Height, awt::PosSize::POSSIZE );
+#else
+    awt::Size currentSize = getSize();
+    awt::Size requestedSize (area.Width, area.Height);
+//    requestedSize.Height = getHeightForWidth( area.Width );
+
+    awt::Size minimumSize = getMinimumSize();
+    if (requestedSize.Width < minimumSize.Width)
+        requestedSize.Width = minimumSize.Width;
+    if (requestedSize.Height < minimumSize.Height)
+        requestedSize.Height = minimumSize.Height;
+
+    Size pageSize = static_cast<TabControl*> (GetWindow ())->GetTabPageSizePixel ();
+    awt::Size pageBasedSize (0, 0);
+    pageBasedSize.Width = pageSize.Width ();
+    pageBasedSize.Height = pageSize.Height ();
+
+    const int wc = 0;
+    const int hc = 20;
+    static int pwc = 0;
+    static int phc = 40;
+    
+    if (requestedSize.Width < pageBasedSize.Width)
+        requestedSize.Width = pageBasedSize.Width + wc;
+    if (requestedSize.Height < pageBasedSize.Height)
+        requestedSize.Height = pageBasedSize.Height + hc;
+
+    Size windowSize = GetWindow()->GetSizePixel();
+    Window *parent = GetWindow()->GetParent();
+    Size parentSize = parent->GetSizePixel();
+
+#ifdef GCC_MAJOR
+    OSL_TRACE ("\n%s", __PRETTY_FUNCTION__);
+#endif /* GCC_MAJOR */
+    OSL_TRACE ("%s: cursize: %d ,%d", __FUNCTION__, currentSize.Width, currentSize.Height );
+    OSL_TRACE ("%s: area: %d, %d", __FUNCTION__, area.Width, area.Height );
+    OSL_TRACE ("%s: minimum: %d, %d", __FUNCTION__, minimumSize.Width, minimumSize.Height );
+    OSL_TRACE ("%s: requestedSize: %d, %d", __FUNCTION__, requestedSize.Width, requestedSize.Height );
+    OSL_TRACE ("%s: pageBasedSize: %d, %d", __FUNCTION__, pageBasedSize.Width, pageBasedSize.Height );
+
+    //OSL_TRACE ("%s: parent: %d, %d", __FUNCTION__, parentSize.Width(), parentSize.Height() );
+    //OSL_TRACE ("%s: window: %d, %d", __FUNCTION__, windowSize.Width(), windowSize.Height() );
+
+    //bRealized = false;
+    if (!bRealized)
+    {
+        setPosSize( area.X, area.Y, requestedSize.Width, requestedSize.Height, awt::PosSize::POSSIZE );
+        bRealized = true;
+    }
+    else
+    {
+        if ( requestedSize.Width > currentSize.Width + 10)
+            setPosSize( 0, 0, requestedSize.Width, 0, awt::PosSize::WIDTH );
+        if ( requestedSize.Height > currentSize.Height + 10)
+            setPosSize( 0, 0, 0, requestedSize.Height, awt::PosSize::HEIGHT );
+    }
+#endif
+    
+    if (pageBasedSize.Width > parentSize.Width ()
+        || pageBasedSize.Height > parentSize.Height ())
+        //parent->SetSizePixel ( Size (pageBasedSize.Width, pageBasedSize.Height));
+        //parent->SetSizePixel ( Size (pageBasedSize.Width + pwc, pageBasedSize.Height + phc));
+        parent->SetSizePixel ( Size (requestedSize.Width + pwc, requestedSize.Height + phc));
+    
     // FIXME: we can save cycles by setting visibility more sensibly. Having
     // it here does makes it easier when changing tabs (just needs a recalc())
     unsigned i = 0;
@@ -307,8 +386,8 @@ void SAL_CALL VCLXTabControl::allocateArea(
               = maChildren.begin(); it != maChildren.end(); it++, i++ )
     {
         ChildData *child = static_cast<VCLXTabControl::ChildData*> ( *it );
-        ::com::sun::star::uno::Reference
-              < ::com::sun::star::awt::XLayoutConstrains > xChild( child->mxChild );
+        uno::Reference
+              < awt::XLayoutConstrains > xChild( child->mxChild );
         if ( xChild.is() )
         {
             uno::Reference< awt::XWindow > xWin( xChild, uno::UNO_QUERY );
@@ -340,15 +419,15 @@ void SAL_CALL VCLXTabControl::allocateArea(
     }
 }
 
-::com::sun::star::awt::Size SAL_CALL VCLXTabControl::getMinimumSize()
-    throw(::com::sun::star::uno::RuntimeException)
+awt::Size SAL_CALL VCLXTabControl::getMinimumSize()
+    throw(uno::RuntimeException)
 {
-    awt::Size size = VCLXWindow::getMinimumSize();
+    awt::Size requestedSize = VCLXWindow::getMinimumSize();
     awt::Size childrenSize( 0, 0 );
 
     TabControl* pTabControl = static_cast< TabControl* >( GetWindow() );
     if ( !pTabControl )
-        return size;
+        return requestedSize;
 
     // calculate size to accomodate all children
     unsigned i = 0;
@@ -367,10 +446,17 @@ void SAL_CALL VCLXTabControl::allocateArea(
         }
     }
 
-    size.Width += childrenSize.Width;
-    size.Height += childrenSize.Height + 20;
-    maRequisition = size;
-    return size;
+#ifdef GCC_MAJOR
+    OSL_TRACE ("\n%s", __PRETTY_FUNCTION__);
+#endif /* GCC_MAJOR */
+    OSL_TRACE ("%s: children: %d", __FUNCTION__, i);
+    OSL_TRACE ("%s: childrenSize: %d, %d", __FUNCTION__, childrenSize.Width, childrenSize.Height );
+
+    requestedSize.Width += childrenSize.Width;
+    requestedSize.Height += childrenSize.Height + 20;
+
+    maRequisition = requestedSize;
+    return requestedSize;
 }
 
 void VCLXTabControl::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent )
@@ -391,12 +477,12 @@ void VCLXTabControl::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent
         case VCLEVENT_TABPAGE_PAGETEXTCHANGED:
         {
             ULONG page = (ULONG) _rVclWindowEvent.GetData();
-            for ( std::list< ::com::sun::star::uno::Reference
-                      < ::com::sun::star::awt::XTabListener > >::iterator it
+            for ( std::list< uno::Reference
+                      < awt::XTabListener > >::iterator it
                       = mxTabListeners.begin(); it != mxTabListeners.end(); it++)
             {
-                ::com::sun::star::uno::Reference
-                    < ::com::sun::star::awt::XTabListener > listener = *it;
+                uno::Reference
+                    < awt::XTabListener > listener = *it;
 
                 switch ( _rVclWindowEvent.GetId() )
                 {
@@ -414,7 +500,7 @@ void VCLXTabControl::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent
                         listener->removed( page );
                         break;
                     case VCLEVENT_TABPAGE_REMOVEDALL:
-                        for( int i = 1; i < mnNextTabId; i++)
+                        for ( int i = 1; i < mTabId; i++)
                         {
                             if ( pTabControl->GetTabPage( sal::static_int_cast< USHORT >( i ) ) )
                                 listener->removed( i );
@@ -434,12 +520,12 @@ void VCLXTabControl::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent
     }
 }
 
-void SAL_CALL VCLXTabControl::setProperty( const ::rtl::OUString& PropertyName, const Any &Value ) throw(RuntimeException)
+void SAL_CALL VCLXTabControl::setProperty( const ::rtl::OUString& PropertyName, const uno::Any &Value ) throw(uno::RuntimeException)
 {
-                VCLXWindow::setProperty( PropertyName, Value );
-        }
+    VCLXWindow::setProperty( PropertyName, Value );
+}
 
-Any SAL_CALL VCLXTabControl::getProperty( const ::rtl::OUString& PropertyName ) throw(RuntimeException)
+uno::Any SAL_CALL VCLXTabControl::getProperty( const ::rtl::OUString& PropertyName ) throw(uno::RuntimeException)
 {
     return VCLXWindow::getProperty( PropertyName );
 }
diff --git a/toolkit/source/awt/vclxtabcontrol.hxx b/toolkit/source/awt/vclxtabcontrol.hxx
index 432e464..e066968 100644
--- toolkit/source/awt/vclxtabcontrol.hxx
+++ toolkit/source/awt/vclxtabcontrol.hxx
@@ -34,7 +34,7 @@
 
 #include <com/sun/star/awt/XSimpleTabController.hpp>
 #include <comphelper/uno3.hxx>
-#include <layout/box-base.hxx>
+#include <layout/core/box-base.hxx>
 #include <map>
 #include <toolkit/awt/vclxwindow.hxx>
 
@@ -50,9 +50,14 @@ class VCLXTabControl :public VCLXWindow
                      ,public VCLXTabControl_Base
                      ,public Box_Base
 {
+    int mTabId;
+    bool bRealized;
+
 public:
     VCLXTabControl();
 
+    void AddChild (css::uno::Reference <css::awt::XLayoutConstrains> const &);
+
 protected:
     ~VCLXTabControl( );
 
@@ -65,7 +70,7 @@ protected:
     // XComponent
     void SAL_CALL dispose( ) throw(::com::sun::star::uno::RuntimeException);
 
-    virtual void SAL_CALL draw( sal_Int32 nX, sal_Int32 nY ) throw        (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL draw( sal_Int32 nX, sal_Int32 nY ) throw (::com::sun::star::uno::RuntimeException);
 
     // XSimpleTabController
     virtual ::sal_Int32 SAL_CALL insertTab() throw (::com::sun::star::uno::RuntimeException);
@@ -108,10 +113,6 @@ protected:
     // VCLXWindow
     void ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent );
 
-
-    // Each tab page needs an unique id.
-    int mnNextTabId;
-
 public:
     // Maps page ids to child references
     struct ChildData : public Box_Base::ChildData
diff --git a/toolkit/source/awt/vclxtabpage.cxx b/toolkit/source/awt/vclxtabpage.cxx
index 4a1c127..1abad26 100644
--- toolkit/source/awt/vclxtabpage.cxx
+++ toolkit/source/awt/vclxtabpage.cxx
@@ -41,6 +41,10 @@
 #include <vcl/tabpage.hxx>
 #include <vcl/tabctrl.hxx>
 
+#if !defined (__GNUC__)
+#define __PRETTY_FUNCTION__ __FUNCTION__
+#endif /* !__GNUC__ */
+
 namespace layoutimpl
 {
 
@@ -72,7 +76,7 @@ void SAL_CALL VCLXTabPage::dispose() throw(uno::RuntimeException)
         ::vos::OGuard aGuard( GetMutex() );
         
         lang::EventObject aDisposeEvent;
-        aDisposeEvent.Source = *this;
+        aDisposeEvent.Source = W3K_EXPLICIT_CAST (*this);
     }
     
     VCLXWindow::dispose();
@@ -81,44 +85,58 @@ void SAL_CALL VCLXTabPage::dispose() throw(uno::RuntimeException)
 void SAL_CALL VCLXTabPage::allocateArea( awt::Rectangle const& area )
     throw (uno::RuntimeException)
 {
-    awt::Size curSize = getSize();
-    awt::Size reqSize = getMinimumSize();
-    reqSize.Height = getHeightForWidth( area.Width );
+    awt::Size currentSize = getSize();
+    awt::Size requestedSize = getMinimumSize();
+    requestedSize.Height = getHeightForWidth( area.Width );
 
-    if ( curSize.Width > 0 && curSize.Height > 0
-         && reqSize.Width > curSize.Width )
-        reqSize.Width = curSize.Width;
-    if ( curSize.Width > 0 && curSize.Height > 0
-         && reqSize.Height > curSize.Height )
-        reqSize.Height = curSize.Height;
+    if ( currentSize.Width > 0 && currentSize.Height > 0
+         && requestedSize.Width > currentSize.Width )
+        requestedSize.Width = currentSize.Width;
+    if ( currentSize.Width > 0 && currentSize.Height > 0
+         && requestedSize.Height > currentSize.Height )
+        requestedSize.Height = currentSize.Height;
 
     // FIXME: missing destructor?
     if ( !GetWindow() )
         return;
 
-    Size window = GetWindow()->GetSizePixel();
-    Size parent = GetWindow()->GetParent()->GetSizePixel();
+    Size windowSize = GetWindow()->GetSizePixel();
+    Window *parent = GetWindow()->GetParent();
+    Size parentSize = parent->GetSizePixel();
 
     Point pos = GetWindow()->GetPosPixel();
+    OSL_TRACE ("\n%s", __PRETTY_FUNCTION__);
     OSL_TRACE ("%s: curpos: %d ,%d", __FUNCTION__, pos.X(), pos.Y() );
 
-    OSL_TRACE ("%s: cursize: %d ,%d", __FUNCTION__, curSize.Width, curSize.Height );
+    OSL_TRACE ("%s: cursize: %d ,%d", __FUNCTION__, currentSize.Width, currentSize.Height );
     OSL_TRACE ("%s: area: %d, %d", __FUNCTION__, area.Width, area.Height );
-    OSL_TRACE ("%s: reqSize: %d, %d", __FUNCTION__, reqSize.Width, reqSize.Height );
-    OSL_TRACE ("%s: parent: %d, %d", __FUNCTION__, parent.Width(), parent.Height() );
-    OSL_TRACE ("%s: window: %d, %d", __FUNCTION__, window.Width(), window.Height() );
+    OSL_TRACE ("%s: requestedSize: %d, %d", __FUNCTION__, requestedSize.Width, requestedSize.Height );
+    OSL_TRACE ("%s: parent: %d, %d", __FUNCTION__, parentSize.Width(), parentSize.Height() );
+    OSL_TRACE ("%s: window: %d, %d", __FUNCTION__, windowSize.Width(), windowSize.Height() );
+
+#if 0
+    if (requestedSize.Width > parentSize.Width ()
+        || requestedSize.Height > parentSize.Height ())
+    {
+        OSL_TRACE ("%s: ***setting parent: %d, %d", __FUNCTION__, requestedSize.Width, requestedSize.Height );
+        parent->SetSizePixel ( Size (requestedSize.Width, requestedSize.Height) );
+
+        if (Window *grand_parent = parent->GetParent ())
+            grand_parent->SetSizePixel ( Size (requestedSize.Width, requestedSize.Height) );
+    }
+#endif
 
     if ( !bRealized )
     {
-        setPosSize( 0, 0, reqSize.Width, reqSize.Height, awt::PosSize::SIZE );
+        setPosSize( area.X, area.Y, requestedSize.Width, requestedSize.Height, awt::PosSize::SIZE );
         bRealized = true;
     }
     else
     {
-        if ( reqSize.Width > curSize.Width )
-            setPosSize( 0, 0, reqSize.Width, 0, awt::PosSize::WIDTH );
-        if ( reqSize.Height > curSize.Height )
-            setPosSize( 0, 0, 0, reqSize.Height, awt::PosSize::HEIGHT );
+        if ( requestedSize.Width > currentSize.Width + 10)
+            setPosSize( 0, 0, requestedSize.Width, 0, awt::PosSize::WIDTH );
+        if ( requestedSize.Height > currentSize.Height + 10)
+            setPosSize( 0, 0, 0, requestedSize.Height, awt::PosSize::HEIGHT );
     }
 
     awt::Size newSize = getSize();
diff --git a/toolkit/source/awt/vclxtabpage.hxx b/toolkit/source/awt/vclxtabpage.hxx
index d6e3032..795e693 100644
--- toolkit/source/awt/vclxtabpage.hxx
+++ toolkit/source/awt/vclxtabpage.hxx
@@ -37,7 +37,7 @@
 #define LAYOUT_AWT_VCLXTABPAGE_HXX
 
 #include <toolkit/awt/vclxwindow.hxx>
-#include <layout/bin.hxx>
+#include <layout/core/bin.hxx>
 #include <comphelper/uno3.hxx>
 
 namespace layoutimpl
@@ -49,6 +49,7 @@ class VCLXTabPage : public VCLXWindow
                   , public Bin
 {
     bool bRealized;
+
 public:
     VCLXTabPage( Window *p );
 
diff --git a/toolkit/source/awt/vclxwindow.cxx b/toolkit/source/awt/vclxwindow.cxx
index 2f31115..1bb9fd8 100644
--- toolkit/source/awt/vclxwindow.cxx
+++ toolkit/source/awt/vclxwindow.cxx
@@ -1135,6 +1135,10 @@ void VCLXWindow::dispose(  ) throw(::com::sun::star::uno::RuntimeException)
 		aObj.Source = static_cast< ::cppu::OWeakObject* >( this );
 
 		maEventListeners.disposeAndClear( aObj );
+#if 0 // ENABLE_LAYOUT
+        /* FIXME: see layout::~ComboBox () */
+        if (!dynamic_cast<VCLXComboBox*> (this))
+#endif /* 0 ENABLE_LAYOUT */
 		maFocusListeners.disposeAndClear( aObj );
 		maWindowListeners.disposeAndClear( aObj );
 		maKeyListeners.disposeAndClear( aObj );
diff --git a/toolkit/source/awt/vclxwindows.cxx b/toolkit/source/awt/vclxwindows.cxx
index ec4c268..72d470e 100644
--- toolkit/source/awt/vclxwindows.cxx
+++ toolkit/source/awt/vclxwindows.cxx
@@ -413,6 +413,11 @@ VCLXButton::VCLXButton()
 {
 }
 
+VCLXButton::~VCLXButton()
+{
+    OSL_TRACE ("%s", __FUNCTION__);
+}
+
 ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext > VCLXButton::CreateAccessibleContext()
 {
     return getAccessibleFactory().createAccessibleContext( this );
@@ -1336,6 +1341,13 @@ void VCLXRadioButton::ImplClickedOrToggled( BOOL bToggled )
 	}
 }
 
+::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > VCLXRadioButton::getFirstActionListener ()
+{
+    if (!maItemListeners.getLength ())
+        return ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > ();
+    return maActionListeners.getElements()[0];
+}
+
 //	----------------------------------------------------
 //	class VCLXSpinField
 //	----------------------------------------------------
@@ -2148,6 +2160,7 @@ VCLXDialog::VCLXDialog()
 
 VCLXDialog::~VCLXDialog()
 {
+    OSL_TRACE ("%s", __FUNCTION__);
 }
 
 // ::com::sun::star::uno::XInterface
@@ -3703,6 +3716,11 @@ VCLXComboBox::VCLXComboBox()
 {
 }
 
+VCLXComboBox::~VCLXComboBox()
+{
+    OSL_TRACE ("%s", __FUNCTION__);
+}
+
 // ::com::sun::star::uno::XInterface
 ::com::sun::star::uno::Any VCLXComboBox::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
 {
diff --git a/toolkit/source/layout/bin.cxx b/toolkit/source/layout/bin.cxx
deleted file mode 100644
index 62ea068..0000000
--- toolkit/source/layout/bin.cxx
+++ /dev/null
@@ -1,190 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "bin.hxx"
-
-#include <sal/macros.h>
-
-namespace layoutimpl
-{
-
-using namespace css;
-
-/* Bin */
-
-Bin::Bin() : Container()
-{
-}
-
-void SAL_CALL
-Bin::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw (uno::RuntimeException, awt::MaxChildrenException)
-{
-    if ( mxChild.is() )
-        throw awt::MaxChildrenException();
-    if ( xChild.is() )
-    {
-        mxChild = xChild;
-        setChildParent( xChild );
-        queueResize();
-    }
-}
-
-void SAL_CALL
-Bin::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw (uno::RuntimeException)
-{
-    if ( xChild == mxChild )
-    {
-        mxChild = uno::Reference< awt::XLayoutConstrains >();
-        unsetChildParent( xChild );
-        queueResize();
-    }
-}
-
-uno::Sequence< uno::Reference< awt::XLayoutConstrains > > SAL_CALL
-Bin::getChildren()
-    throw (uno::RuntimeException)
-{
-    return getSingleChild (mxChild);
-}
-
-void SAL_CALL
-Bin::allocateArea( const awt::Rectangle &rArea )
-    throw (uno::RuntimeException)
-{
-    maAllocation = rArea;
-    if ( mxChild.is() )
-        allocateChildAt( mxChild, rArea );
-}
-
-awt::Size SAL_CALL
-Bin::getMinimumSize()
-    throw(uno::RuntimeException)
-{
-    if ( mxChild.is() )
-        return maRequisition = maChildRequisition = mxChild->getMinimumSize();
-    return maRequisition = awt::Size( 0, 0 );
-}
-
-uno::Reference< beans::XPropertySet > SAL_CALL
-Bin::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& )
-    throw (uno::RuntimeException)
-{
-    return uno::Reference< beans::XPropertySet >();
-}
-
-sal_Bool SAL_CALL
-Bin::hasHeightForWidth()
-    throw(uno::RuntimeException)
-{
-    uno::Reference< awt::XLayoutContainer > xChildCont( mxChild, uno::UNO_QUERY );
-    if ( xChildCont.is() )
-        return xChildCont->hasHeightForWidth();
-    return false;
-}
-
-sal_Int32 SAL_CALL
-Bin::getHeightForWidth( sal_Int32 nWidth )
-    throw(uno::RuntimeException)
-{
-    uno::Reference< awt::XLayoutContainer > xChildCont( mxChild, uno::UNO_QUERY );
-    if ( xChildCont.is() )
-        return xChildCont->getHeightForWidth( nWidth );
-    return maRequisition.Height;
-}
-
-/* Align */
-
-Align::Align() : Bin()
-{
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Halign" ),
-             ::getCppuType( static_cast< const float* >( NULL ) ),
-             &fHorAlign );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Valign" ),
-             ::getCppuType( static_cast< const float* >( NULL ) ),
-             &fVerAlign );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Hfill" ),
-             ::getCppuType( static_cast< const float* >( NULL ) ),
-             &fHorFill );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Vfill" ),
-             ::getCppuType( static_cast< const float* >( NULL ) ),
-             &fVerFill );
-
-    fHorAlign = fVerAlign = 0.5;
-    fHorFill = fVerFill = 0;
-}
-
-void SAL_CALL
-Align::allocateArea( const awt::Rectangle &rArea )
-    throw (uno::RuntimeException)
-{
-    maAllocation = rArea;
-    if ( !mxChild.is() )
-        return;
-
-    awt::Rectangle aChildArea;
-    aChildArea.Width = SAL_MIN( rArea.Width, maChildRequisition.Width );
-    aChildArea.Width += (sal_Int32) SAL_MAX(
-        0, (rArea.Width - maChildRequisition.Width) * fHorFill );
-    aChildArea.Height = SAL_MIN( rArea.Height, maChildRequisition.Height );
-    aChildArea.Height += (sal_Int32) SAL_MAX(
-        0, (rArea.Height - maChildRequisition.Height) * fVerFill );
-
-    aChildArea.X = rArea.X + (sal_Int32)( (rArea.Width - aChildArea.Width) * fHorAlign );
-    aChildArea.Y = rArea.Y + (sal_Int32)( (rArea.Height - aChildArea.Height) * fVerAlign );
-
-    allocateChildAt( mxChild, aChildArea );
-}
-
-/* MinSize */
-
-MinSize::MinSize() : Bin()
-{
-    mnMinWidth = mnMinHeight = 0;
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "MinWidth" ),
-             ::getCppuType( static_cast< const long* >( NULL ) ),
-             &mnMinWidth );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "MinHeight" ),
-             ::getCppuType( static_cast< const long* >( NULL ) ),
-             &mnMinHeight );
-}
-
-awt::Size SAL_CALL MinSize::getMinimumSize()
-    throw(uno::RuntimeException)
-{
-    Bin::getMinimumSize();
-    maRequisition.Width = SAL_MAX( maRequisition.Width, mnMinWidth );
-    maRequisition.Height = SAL_MAX( maRequisition.Height, mnMinHeight );
-    return maRequisition;
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/bin.hxx b/toolkit/source/layout/bin.hxx
deleted file mode 100644
index e79df59..0000000
--- toolkit/source/layout/bin.hxx
+++ /dev/null
@@ -1,120 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-/* A few simple binary containers */
-
-#ifndef CORE_BIN_HXX
-#define CORE_BIN_HXX
-
-#include "container.hxx"
-
-namespace layoutimpl
-{
-
-class Bin : public Container
-{
-protected:
-    // Child
-    css::awt::Size maChildRequisition;
-    css::uno::Reference< css::awt::XLayoutConstrains > mxChild;
-
-public:
-    Bin();
-    virtual ~Bin() {}
-
-    // css::awt::XLayoutContainer
-    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
-    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException);
-
-    virtual css::uno::Sequence< css::uno::Reference
-                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
-        throw (css::uno::RuntimeException);
-
-    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException);
-
-    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
-        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException);
-
-    virtual sal_Bool SAL_CALL hasHeightForWidth()
-        throw(css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
-        throw(css::uno::RuntimeException);
-
-    // css::awt::XLayoutConstrains
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException);
-
-    PROPHELPER_SET_INFO
-};
-
-// Align gives control over child position on the allocated space.
-class Align : public Bin
-{
-    friend class AlignChildProps;
-protected:
-    // properties
-    float fHorAlign, fVerAlign;
-    float fHorFill, fVerFill;
-
-public:
-    Align();
-
-    // css::awt::XLayoutContainer
-    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException);
-
-    PROPHELPER_SET_INFO
-};
-
-// Makes child request its or a specified size, whatever is larger.
-class MinSize : public Bin
-{
-protected:
-    // properties
-    long mnMinWidth, mnMinHeight;
-
-public:
-    MinSize();
-
-    // css::awt::XLayoutContainer
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException);
-
-    PROPHELPER_SET_INFO
-};
-
-} //  namespace layoutimpl
-
-#endif /*CORE_BIN_HXX*/
diff --git a/toolkit/source/layout/box-base.cxx b/toolkit/source/layout/box-base.cxx
deleted file mode 100644
index aad69f7..0000000
--- toolkit/source/layout/box-base.cxx
+++ /dev/null
@@ -1,170 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "box.hxx"
-
-#include <tools/debug.hxx>
-#include <sal/macros.h>
-
-#include <com/sun/star/awt/XWindow2.hpp>
-
-// fixed point precision for distributing error
-#define FIXED_PT 16
-
-namespace layoutimpl
-{
-
-using namespace css;
-
-Box_Base::ChildData::ChildData( uno::Reference< awt::XLayoutConstrains > const& xChild )
-    : mxChild( xChild )
-    , mxProps()
-    , maRequisition()
-{
-}
-
-static bool isVisible( uno::Reference< awt::XLayoutConstrains > xWidget )
-{
-    if ( !xWidget.is() )
-    {
-        DBG_ERROR( "FIXME: invalid child !" );
-        return true;
-    }
-
-    uno::Reference< awt::XWindow2 > xWindow( xWidget, uno::UNO_QUERY );
-    if ( xWindow.is() && !xWindow->isVisible() )
-        return false;
-
-    uno::Reference< awt::XLayoutContainer > xContainer( xWidget, uno::UNO_QUERY );
-    if ( xContainer.is() )
-    {
-        uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aChildren
-            = xContainer->getChildren();
-
-        // FIXME: <flow> workaround: empty visible containers always visible:
-        if ( !aChildren.getLength() )
-            return true;
-
-        for ( int i = 0; i < aChildren.getLength(); i++ )
-            if ( isVisible( aChildren[i] ) )
-                return true;
-        return false; // this would kill flow without workaround above
-    }
-
-    return true;
-}
-    
-bool Box_Base::ChildData::isVisible()
-{
-    // FIXME: call the 'isVisible' method on it ?
-    return layoutimpl::isVisible( mxChild );
-}
-
-void SAL_CALL
-Box_Base::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw (uno::RuntimeException, awt::MaxChildrenException)
-{
-    if ( xChild.is() )
-    {
-        ChildData *pData = createChild( xChild );
-        maChildren.push_back( pData );
-        setChildParent( xChild );
-        queueResize();
-    }
-}
-
-Box_Base::ChildData*
-Box_Base::removeChildData( std::list< ChildData* > lst, css::uno::Reference< css::awt::XLayoutConstrains > const& xChild )
-{
-    for ( std::list< ChildData* >::iterator it = lst.begin();
-          it != lst.end(); it++ )
-    {
-        if ( (*it)->mxChild == xChild )
-        {
-            lst.erase( it );
-            return *it;
-        }
-    }
-    return 0;
-}
-
-void SAL_CALL
-Box_Base::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw (uno::RuntimeException)
-{
-    if ( ChildData* p = removeChildData( maChildren, xChild ) )
-    {
-        delete p;
-        unsetChildParent( xChild );
-        queueResize();
-    }
-    else
-    {
-        DBG_ERROR( "Box_Base: removeChild: no such child" );
-    }
-}
-
-uno::Sequence< uno::Reference < awt::XLayoutConstrains > > SAL_CALL
-Box_Base::getChildren()
-    throw (uno::RuntimeException)
-{
-    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
-    unsigned int index = 0;
-    for ( std::list< ChildData* >::iterator it = maChildren.begin();
-          it != maChildren.end(); it++, index++ )
-        children[index] = ( *it )->mxChild;
-
-    return children;
-}
-
-uno::Reference< beans::XPropertySet > SAL_CALL
-Box_Base::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw (uno::RuntimeException)
-{
-    
-    for ( std::list< ChildData * >::iterator it = maChildren.begin();
-          it != maChildren.end(); it++)
-    {
-        if ( ( *it )->mxChild == xChild )
-        {
-            if ( !( *it )->mxProps.is() )
-            {
-                PropHelper *pProps = createChildProps( *it );
-                pProps->setChangeListener( this );
-                ( *it )->mxProps = pProps;
-            }
-            return (*it)->mxProps;
-        }
-    }
-    return uno::Reference< beans::XPropertySet >();
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/box-base.hxx b/toolkit/source/layout/box-base.hxx
deleted file mode 100644
index 44e0434..0000000
--- toolkit/source/layout/box-base.hxx
+++ /dev/null
@@ -1,90 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_BOX_BASE_HXX
-#define CORE_BOX_BASE_HXX
-
-#include "container.hxx"
-
-#include <list>
-
-namespace layoutimpl
-{
-
-class Box_Base : public Container
-{
-public:
-    // Children properties
-    struct ChildData
-    {
-        css::uno::Reference< css::awt::XLayoutConstrains > mxChild;
-        css::uno::Reference< css::beans::XPropertySet > mxProps;
-        css::awt::Size maRequisition;
-        virtual bool isVisible();
-        
-        ChildData( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
-        virtual ~ChildData() { };
-    };
-
-    struct ChildProps: public PropHelper
-    {
-        //ChildProps( ChildProps* );
-        PROPHELPER_SET_INFO
-    };
-
-protected:
-    std::list< ChildData* > maChildren;
-
-
-    virtual ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) = 0;
-    virtual ChildProps *createChildProps( ChildData* pData ) = 0;
-    
-    ChildData *removeChildData( std::list< ChildData *>, css::uno::Reference< css::awt::XLayoutConstrains > const& Child );
-    
-public:
-    // css::awt::XLayoutContainer
-    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
-    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException);
-
-    virtual css::uno::Sequence< css::uno::Reference
-                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
-        throw (css::uno::RuntimeException);
-    
-    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
-        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException);
-};
-
-} //  namespace layoutimpl
-
-#endif /* CORE_BOX_BASE HXX */
diff --git a/toolkit/source/layout/box.cxx b/toolkit/source/layout/box.cxx
deleted file mode 100644
index 6acc8c8..0000000
--- toolkit/source/layout/box.cxx
+++ /dev/null
@@ -1,285 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "box.hxx"
-
-#include <tools/debug.hxx>
-#include <sal/macros.h>
-
-// fixed point precision for distributing error
-#define FIXED_PT 16
-
-namespace layoutimpl
-{
-
-using namespace css;
-
-Box::ChildProps::ChildProps( Box::ChildData *pData )
-{
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Expand" ),
-             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
-             &(pData->mbExpand) );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Fill" ),
-             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
-             &(pData->mbFill) );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Padding" ),
-             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &(pData->mnPadding) );
-}
-
-Box::ChildData::ChildData( uno::Reference< awt::XLayoutConstrains > const& xChild )
-    : Box_Base::ChildData( xChild )
-    , mnPadding( 0 )
-    , mbExpand( true )
-    , mbFill( true )
-{
-}
-
-Box::ChildData*
-Box::createChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
-    {
-    return new ChildData( xChild );
-    }
-
-Box::ChildProps*
-Box::createChildProps( Box_Base::ChildData *pData )
-{
-    return new ChildProps( static_cast<Box::ChildData*> ( pData ) );
-}
-
-Box::Box( bool horizontal )
-    : Box_Base()
-    , mnSpacing( 0 )
-    , mbHomogeneous( false )
-    , mbHorizontal( horizontal )
-{
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ),
-             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
-             &mbHomogeneous );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Spacing" ),
-             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &mnSpacing );
-    mbHasFlowChildren = false;
-}
-
-awt::Size
-Box::calculateSize( long nWidth )
-{
-    int nVisibleChildren = 0;
-    // primary vs secundary axis (instead of a X and Y)
-    int nPrimSize = 0;
-    int nSecSize = 0;
-    int nFlowMinWidth = 0;  // in case the box only has flow children
-
-    mbHasFlowChildren = false;
-
-    for ( std::list<Box_Base::ChildData *>::const_iterator it
-              = maChildren.begin(); it != maChildren.end(); it++ )
-    {
-        ChildData *child = static_cast<Box::ChildData*> ( *it );
-        if ( !child->isVisible() )
-            continue;
-
-        uno::Reference< awt::XLayoutContainer > xChildCont( child->mxChild, uno::UNO_QUERY );
-        bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
-
-        awt::Size aChildSize = child->maRequisition = child->mxChild->getMinimumSize();
-
-        if ( !mbHorizontal /*vertical*/ && bFlow )
-        {
-            if ( nFlowMinWidth == 0 || nFlowMinWidth > aChildSize.Width )
-                nFlowMinWidth = aChildSize.Width;
-            mbHasFlowChildren = true;
-        }
-        else
-        {
-            int size = primDim( aChildSize ) + child->mnPadding * 2;
-            if ( mbHomogeneous )
-                nPrimSize = SAL_MAX( nPrimSize, size );
-            else
-                nPrimSize += size;
-
-            nSecSize = SAL_MAX( nSecSize, secDim( aChildSize ) );
-        }
-        nVisibleChildren++;
-    }
-
-    if ( nVisibleChildren )
-    {
-        if ( mbHomogeneous )
-            nPrimSize *= nVisibleChildren;
-        nPrimSize += (nVisibleChildren - 1) * mnSpacing;
-    }
-
-    if ( mbHasFlowChildren )
-    {
-        if ( nWidth == 0 )
-            nWidth = nSecSize ? nSecSize : nFlowMinWidth;
-        for ( std::list<Box_Base::ChildData *>::const_iterator it
-                  = maChildren.begin(); it != maChildren.end(); it++ )
-        {
-            ChildData *child = static_cast<Box::ChildData*> ( *it );
-            if ( !child->isVisible() )
-                continue;
-
-            uno::Reference< awt::XLayoutContainer > xChildCont( child->mxChild, uno::UNO_QUERY );
-            bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
-
-            if ( bFlow )
-                nPrimSize += xChildCont->getHeightForWidth( nWidth );
-        }
-    }
-
-    nPrimSize += mnBorderWidth * 2;
-    nSecSize += mnBorderWidth * 2;
-    return awt::Size( mbHorizontal ? nPrimSize : nSecSize,
-                      mbHorizontal ? nSecSize : nPrimSize );
-}
-
-awt::Size SAL_CALL
-Box::getMinimumSize() throw(uno::RuntimeException)
-{
-    maRequisition = calculateSize();
-    return maRequisition;
-}
-
-sal_Bool SAL_CALL
-Box::hasHeightForWidth()
-    throw(uno::RuntimeException)
-{
-    return mbHasFlowChildren;
-}
-
-sal_Int32 SAL_CALL
-Box::getHeightForWidth( sal_Int32 nWidth )
-    throw(uno::RuntimeException)
-{
-    if ( hasHeightForWidth() )
-        return calculateSize( nWidth ).Height;
-    return maRequisition.Height;
-}
-
-void SAL_CALL
-Box::allocateArea( const awt::Rectangle &newArea )
-    throw (uno::RuntimeException)
-{
-    maAllocation = newArea;
-    int nVisibleChildren = 0, nExpandChildren = 0;
-
-    for ( std::list<Box_Base::ChildData *>::const_iterator it
-              = maChildren.begin(); it != maChildren.end(); it++ )
-    {
-        ChildData *child = static_cast<Box::ChildData*> ( *it );
-        if ( child->isVisible() )
-        {
-            nVisibleChildren++;
-            if ( child->mbExpand )
-                nExpandChildren++;
-        }
-    }
-    if ( !nVisibleChildren )
-        return;
-
-    // split rectangle for dimension helpers
-    awt::Point newPoint( newArea.X, newArea.Y );
-    awt::Size newSize( newArea.Width, newArea.Height );
-
-    int nExtraSpace;
-    if ( mbHomogeneous )
-        nExtraSpace = ( ( primDim( newSize ) - mnBorderWidth * 2 -
-                          ( nVisibleChildren - 1 ) * mnSpacing )) / nVisibleChildren;
-    else if ( nExpandChildren )
-    {
-        int reqSize = primDim( maRequisition );
-        if ( !mbHorizontal && hasHeightForWidth() )
-            reqSize = getHeightForWidth( newArea.Width );
-        nExtraSpace = ( primDim( newSize ) - reqSize ) / nExpandChildren;
-    }
-    else
-        nExtraSpace = 0;
-
-    int nChildPrimPoint, nChildSecPoint, nChildPrimSize, nChildSecSize;
-
-    int nStartPoint = primDim( newPoint ) + mnBorderWidth;
-    int nBoxSecSize = SAL_MAX( 1, secDim( newSize ) - mnBorderWidth * 2 );
-
-    for ( std::list<Box_Base::ChildData *>::const_iterator it
-              = maChildren.begin(); it != maChildren.end(); it++ )
-    {
-        ChildData *child = static_cast<Box::ChildData*> ( *it );
-        if ( !child->isVisible() )
-            continue;
-
-        awt::Point aChildPos;
-        int nBoxPrimSize;  // of the available box space
-
-        if ( mbHomogeneous )
-            nBoxPrimSize = nExtraSpace;
-        else
-        {
-            uno::Reference< awt::XLayoutContainer > xChildCont( child->mxChild, uno::UNO_QUERY );
-            bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
-            if ( !mbHorizontal && bFlow )
-                nBoxPrimSize = xChildCont->getHeightForWidth( newArea.Width );
-            else
-                nBoxPrimSize = primDim( child->maRequisition );
-            nBoxPrimSize += child->mnPadding;
-            if ( child->mbExpand )
-                nBoxPrimSize += nExtraSpace;
-        }
-
-        nChildPrimPoint = nStartPoint + child->mnPadding;
-        nChildSecPoint = secDim( newPoint ) + mnBorderWidth;
-
-        nChildSecSize = nBoxSecSize;
-        if ( child->mbFill )
-            nChildPrimSize = SAL_MAX( 1, nBoxPrimSize - child->mnPadding);
-        else
-        {
-            nChildPrimSize = primDim( child->maRequisition );
-            nChildPrimPoint += (nBoxPrimSize - nChildPrimSize) / 2;
-
-            nChildSecPoint += (nBoxSecSize - nChildSecSize) / 2;
-        }
-
-        awt::Rectangle area;
-        area.X = mbHorizontal ? nChildPrimPoint : nChildSecPoint;
-        area.Y = mbHorizontal ? nChildSecPoint : nChildPrimPoint;
-        area.Width = mbHorizontal ? nChildPrimSize : nChildSecSize;
-        area.Height = mbHorizontal ? nChildSecSize : nChildPrimSize;
-
-        allocateChildAt( child->mxChild, area );
-
-        nStartPoint += nBoxPrimSize + mnSpacing + child->mnPadding;
-    }
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/box.hxx b/toolkit/source/layout/box.hxx
deleted file mode 100644
index e49886d..0000000
--- toolkit/source/layout/box.hxx
+++ /dev/null
@@ -1,108 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_BOX_HXX
-#define CORE_BOX_HXX
-
-#include "box-base.hxx"
-
-#include <com/sun/star/awt/Point.hpp>
-
-namespace layoutimpl
-{
-
-class Box : public Box_Base
-{
-protected:
-    // Box properties (i.e. affect all children)
-    sal_Int32 mnSpacing;
-    sal_Bool mbHomogeneous;
-    sal_Bool mbHorizontal;  // false for Vertical
-    bool mbHasFlowChildren;
-
-public:
-    // Children properties
-    struct ChildData : public Box_Base::ChildData
-    {
-        sal_Int32 mnPadding;
-        sal_Bool mbExpand;
-        sal_Bool mbFill;
-        ChildData( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
-    };
-
-    struct ChildProps : public Box_Base::ChildProps
-    {
-        ChildProps( ChildData *pData );
-    };
-
-protected:
-    ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
-    ChildProps *createChildProps( Box_Base::ChildData* pData );
-
-public:
-    Box( bool horizontal );
-
-    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException);
-
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL hasHeightForWidth()
-        throw(css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
-        throw(css::uno::RuntimeException);
-
-    // helper: mix of getMinimumSize() and getHeightForWidth()
-    css::awt::Size calculateSize( long nWidth = 0 );
-
-    PROPHELPER_SET_INFO
-
-private:
-    /* Helpers to deal with the joint Box directions. */
-    inline int primDim (const css::awt::Size &size)
-    { if (mbHorizontal) return size.Width; else return size.Height; }
-    inline int secDim (const css::awt::Size &size)
-    { if (mbHorizontal) return size.Height; else return size.Width; }
-    inline int primDim (const css::awt::Point &point)
-    { if (mbHorizontal) return point.X; else return point.Y; }
-    inline int secDim (const css::awt::Point &point)
-    { if (mbHorizontal) return point.Y; else return point.X; }
-};
-
-struct VBox : public Box
-{ VBox() : Box (false) {} };
-
-struct HBox : public Box
-{ HBox() : Box (true) {} };
-
-} //  namespace layoutimpl
-
-#endif /*CORE_BOX_HXX*/
diff --git a/toolkit/source/layout/byteseq.cxx b/toolkit/source/layout/byteseq.cxx
deleted file mode 100644
index 7a61ad2..0000000
--- toolkit/source/layout/byteseq.cxx
+++ /dev/null
@@ -1,79 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: byteseq.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include <com/sun/star/io/XInputStream.hpp>
-#include <osl/file.hxx>
-#include <comphelper/oslfile2streamwrap.hxx>
-
-using osl::File;
-using osl::FileBase;
-using namespace ::com::sun::star;
-
-namespace layoutimpl
-{
-
-uno::Reference< io::XInputStream > getFileAsStream( const rtl::OUString &rName )
-{
-    rtl::OUString sFileURL;
-    if( FileBase::E_None != FileBase::getFileURLFromSystemPath( rName, sFileURL ) )
-        sFileURL = rName; // maybe it already was a file url
-
-    File * blobFile = new File(sFileURL);
-    File::RC errorCode = blobFile->open(OpenFlag_Read);
-
-    uno::Reference<io::XInputStream> xResult;
-    switch (errorCode)
-    {
-    case osl::File::E_None: // got it
-        xResult.set( new comphelper::OSLInputStreamWrapper(blobFile,true) );
-        break;
-
-    case osl::File::E_NOENT: // no file => no stream
-        delete blobFile;
-        break;
-
-    default:
-        delete blobFile;
-/*            {
-            rtl::OUStringBuffer sMsg;
-            sMsg.appendAscii("Cannot open output file \"");
-            sMsg.append(aURL);
-            sMsg.appendAscii("\" : ");
-            sMsg.append(configmgr::FileHelper::createOSLErrorString(errorCode));
-
-            throw io::IOException(sMsg.makeStringAndClear(),NULL);
-        }   
-*/
-    }
-
-    return xResult;
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/container.cxx b/toolkit/source/layout/container.cxx
deleted file mode 100644
index c9b4513..0000000
--- toolkit/source/layout/container.cxx
+++ /dev/null
@@ -1,167 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "container.hxx"
-
-#include <com/sun/star/awt/XWindow.hpp>
-#include <com/sun/star/awt/PosSize.hpp>
-#include <tools/debug.hxx>
-
-namespace layoutimpl {
-
-using namespace css;
-
-Container::Container()
-    : Container_Base()
-    , PropHelper()
-    , mnBorderWidth( 0 )
-{
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Border" ),
-             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &mnBorderWidth );
-    setChangeListener( this );
-}
-
-uno::Any
-Container::queryInterface( const uno::Type & rType ) throw (uno::RuntimeException)
-{
-    uno::Any aRet = Container_Base::queryInterface( rType );
-    return aRet.hasValue() ? aRet : PropHelper::queryInterface( rType );
-}
-
-void
-Container::allocateChildAt( const uno::Reference< awt::XLayoutConstrains > &xChild,
-                            const awt::Rectangle &rArea )
-    throw( uno::RuntimeException )
-{
-    uno::Reference< awt::XLayoutContainer > xCont( xChild, uno::UNO_QUERY );
-    if ( xCont.is() )
-        xCont->allocateArea( rArea );
-    else
-    {
-        uno::Reference< awt::XWindow > xWindow( xChild, uno::UNO_QUERY );
-        if ( xWindow.is() )
-            xWindow->setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height,
-                                 awt::PosSize::POSSIZE );
-        else
-        {
-            DBG_ERROR( "Error: non-sizeable child" );
-        }
-    }
-}
-
-uno::Sequence< uno::Reference< awt::XLayoutConstrains > >
-Container::getSingleChild ( uno::Reference< awt::XLayoutConstrains >const &xChildOrNil )
-{
-    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aSeq( ( xChildOrNil.is() ? 1 : 0 ) );
-    if ( xChildOrNil.is() )
-        aSeq[0] = xChildOrNil;
-    return aSeq;
-}
-
-void
-Container::queueResize()
-{
-    if ( mxLayoutUnit.is() )
-        mxLayoutUnit->queueResize( uno::Reference< awt::XLayoutContainer >( this ) );
-}
-
-void
-Container::setChildParent( const uno::Reference< awt::XLayoutConstrains >& xChild )
-{
-    uno::Reference< awt::XLayoutContainer > xContChild( xChild, uno::UNO_QUERY );
-    if ( xContChild.is() )
-    {
-        xContChild->setParent( uno::Reference< awt::XLayoutContainer >( this ) );
-#if 0
-        assert( !mxLayoutUnit.is() );
-        xContChild->setLayoutUnit( mxLayoutUnit );
-#endif
-    }
-}
-
-void
-Container::unsetChildParent( const uno::Reference< awt::XLayoutConstrains >& xChild )
-{
-    uno::Reference< awt::XLayoutContainer > xContChild( xChild, uno::UNO_QUERY );
-    if ( xContChild.is() )
-    {
-        xContChild->setParent( uno::Reference< awt::XLayoutContainer >() );
-#if 0
-        xContChild->setLayoutUnit( uno::Reference< awt::XLayoutUnit >() );
-#endif
-    }
-}
-
-#if 0
-std::string
-Container::getLabel()  // debug label
-{
-    std::string depth;
-    uno::Reference< awt::XLayoutContainer > xContainer( this );
-    while ( xContainer.is() )
-    {
-        int node = 0;  // child nb
-        uno::Reference< awt::XLayoutContainer > xParent = xContainer->getContainerParent();
-        if ( xParent.is() )
-        {
-
-            uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aChildren;
-            aChildren = xParent->getChildren();
-            for ( node = 0; node < aChildren.getLength(); node++ )
-                if ( aChildren[ node ] == xContainer )
-                    break;
-        }
-
-        char str[ 8 ];
-        snprintf( str, 8, "%d", node );
-        if ( depth.empty() )
-            depth = std::string( str );
-        else
-            depth = std::string( str ) + ":" + depth;
-
-        xContainer = xParent;
-    }
-
-    return std::string( getName() ) + " (" + depth + ")";
-}
-#endif
-
-void Container::propertiesChanged()
-{
-    // cl: why this assertion? This is also called to set properties at the top level widget which has no parent!?
-    // DBG_ASSERT( mxParent.is(), "Properties listener: error container doesn't have parent" );
-    
-    if ( mxLayoutUnit.is() && mxParent.is() )
-        mxLayoutUnit->queueResize( mxParent );
-}
-
-}
diff --git a/toolkit/source/layout/container.hxx b/toolkit/source/layout/container.hxx
deleted file mode 100644
index c578827..0000000
--- toolkit/source/layout/container.hxx
+++ /dev/null
@@ -1,140 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_CONTAINER_HXX
-#define CORE_CONTAINER_HXX
-
-#include "helper.hxx"
-
-#include <cppuhelper/implbase2.hxx>
-#include <com/sun/star/awt/MaxChildrenException.hpp>
-
-namespace layoutimpl
-{
-namespace css = ::com::sun::star;
-
-typedef ::cppu::WeakImplHelper2< css::awt::XLayoutContainer,
-                                 css::awt::XLayoutConstrains > Container_Base;
-
-class Container : public Container_Base, public PropHelper, public PropHelper::Listener
-{
-    friend class ChildProps;
-protected:
-    // Widget properties
-    css::uno::Reference< css::awt::XLayoutContainer > mxParent;
-    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
-    css::awt::Size maRequisition;
-    css::awt::Rectangle maAllocation;
-
-    // Container properties
-    sal_Int32 mnBorderWidth;
-
-    // Utilities
-    void allocateChildAt( const css::uno::Reference< css::awt::XLayoutConstrains > &xChild,
-                          const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException);
-    static css::uno::Sequence< css::uno::Reference< css::awt::XLayoutConstrains > >
-    getSingleChild (const css::uno::Reference< css::awt::XLayoutConstrains > &xChildOrNil);
-    void setChildParent( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild );
-    void unsetChildParent( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild );
-
-    void queueResize();
-    void forceRecalc() { allocateArea( maAllocation ); }
-
-public:
-    Container();
-    virtual ~Container() {}
-
-    // XInterface
-    virtual void SAL_CALL acquire() throw() { PropHelper::acquire(); }
-    virtual void SAL_CALL release() throw() { PropHelper::release(); }
-    virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
-
-    // css::awt::XLayoutContainer
-    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException, css::awt::MaxChildrenException) = 0;
-    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException) = 0;
-
-    virtual css::uno::Sequence< css::uno::Reference
-                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
-        throw (css::uno::RuntimeException) = 0;
-
-    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
-        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException) = 0;
-
-    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException) = 0;
-
-    void SAL_CALL setLayoutUnit( const css::uno::Reference< css::awt::XLayoutUnit > &xUnit )
-        throw(css::uno::RuntimeException)
-    { mxLayoutUnit = xUnit; }
-    css::uno::Reference< css::awt::XLayoutUnit > SAL_CALL getLayoutUnit()
-        throw(css::uno::RuntimeException)
-    { return mxLayoutUnit; }
-
-    css::awt::Size SAL_CALL getRequestedSize() throw(css::uno::RuntimeException)
-    { return maRequisition; }
-    com::sun::star::awt::Rectangle SAL_CALL getAllocatedArea() throw(css::uno::RuntimeException)
-    { return maAllocation; }
-
-    virtual sal_Bool SAL_CALL hasHeightForWidth()
-        throw(css::uno::RuntimeException) = 0;
-    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
-        throw(css::uno::RuntimeException) = 0;
-
-    // css::awt::XLayoutContainer: css::container::XChild
-    css::uno::Reference< css::uno::XInterface > SAL_CALL getParent()
-        throw (css::uno::RuntimeException)
-    { return mxParent; }
-    void SAL_CALL setParent( const css::uno::Reference< css::uno::XInterface > &xParent )
-        throw (css::uno::RuntimeException)
-    { mxParent = css::uno::Reference< css::awt::XLayoutContainer >( xParent, css::uno::UNO_QUERY ); }
-
-    // css::awt::XLayoutConstrains
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException) = 0;
-    // (not properly implemented in toolkit, ignore it.)
-    css::awt::Size SAL_CALL getPreferredSize()
-        throw(css::uno::RuntimeException) { return getMinimumSize(); } // TODO: use this for flow?
-    css::awt::Size SAL_CALL calcAdjustedSize( const css::awt::Size& rNewSize )
-        throw(css::uno::RuntimeException) { return rNewSize; }
-
-PROPHELPER_SET_INFO
-
-protected:
-    void propertiesChanged();
-};
-
-} //  namespace layoutimpl
-
-#endif /*CORE_CONTAINER_HXX*/
diff --git a/toolkit/source/layout/core/bin.cxx b/toolkit/source/layout/core/bin.cxx
new file mode 100644
index 0000000..62ea068
--- /dev/null
+++ toolkit/source/layout/core/bin.cxx
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "bin.hxx"
+
+#include <sal/macros.h>
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+/* Bin */
+
+Bin::Bin() : Container()
+{
+}
+
+void SAL_CALL
+Bin::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException, awt::MaxChildrenException)
+{
+    if ( mxChild.is() )
+        throw awt::MaxChildrenException();
+    if ( xChild.is() )
+    {
+        mxChild = xChild;
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+void SAL_CALL
+Bin::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    if ( xChild == mxChild )
+    {
+        mxChild = uno::Reference< awt::XLayoutConstrains >();
+        unsetChildParent( xChild );
+        queueResize();
+    }
+}
+
+uno::Sequence< uno::Reference< awt::XLayoutConstrains > > SAL_CALL
+Bin::getChildren()
+    throw (uno::RuntimeException)
+{
+    return getSingleChild (mxChild);
+}
+
+void SAL_CALL
+Bin::allocateArea( const awt::Rectangle &rArea )
+    throw (uno::RuntimeException)
+{
+    maAllocation = rArea;
+    if ( mxChild.is() )
+        allocateChildAt( mxChild, rArea );
+}
+
+awt::Size SAL_CALL
+Bin::getMinimumSize()
+    throw(uno::RuntimeException)
+{
+    if ( mxChild.is() )
+        return maRequisition = maChildRequisition = mxChild->getMinimumSize();
+    return maRequisition = awt::Size( 0, 0 );
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Bin::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& )
+    throw (uno::RuntimeException)
+{
+    return uno::Reference< beans::XPropertySet >();
+}
+
+sal_Bool SAL_CALL
+Bin::hasHeightForWidth()
+    throw(uno::RuntimeException)
+{
+    uno::Reference< awt::XLayoutContainer > xChildCont( mxChild, uno::UNO_QUERY );
+    if ( xChildCont.is() )
+        return xChildCont->hasHeightForWidth();
+    return false;
+}
+
+sal_Int32 SAL_CALL
+Bin::getHeightForWidth( sal_Int32 nWidth )
+    throw(uno::RuntimeException)
+{
+    uno::Reference< awt::XLayoutContainer > xChildCont( mxChild, uno::UNO_QUERY );
+    if ( xChildCont.is() )
+        return xChildCont->getHeightForWidth( nWidth );
+    return maRequisition.Height;
+}
+
+/* Align */
+
+Align::Align() : Bin()
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Halign" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fHorAlign );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Valign" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fVerAlign );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Hfill" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fHorFill );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Vfill" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fVerFill );
+
+    fHorAlign = fVerAlign = 0.5;
+    fHorFill = fVerFill = 0;
+}
+
+void SAL_CALL
+Align::allocateArea( const awt::Rectangle &rArea )
+    throw (uno::RuntimeException)
+{
+    maAllocation = rArea;
+    if ( !mxChild.is() )
+        return;
+
+    awt::Rectangle aChildArea;
+    aChildArea.Width = SAL_MIN( rArea.Width, maChildRequisition.Width );
+    aChildArea.Width += (sal_Int32) SAL_MAX(
+        0, (rArea.Width - maChildRequisition.Width) * fHorFill );
+    aChildArea.Height = SAL_MIN( rArea.Height, maChildRequisition.Height );
+    aChildArea.Height += (sal_Int32) SAL_MAX(
+        0, (rArea.Height - maChildRequisition.Height) * fVerFill );
+
+    aChildArea.X = rArea.X + (sal_Int32)( (rArea.Width - aChildArea.Width) * fHorAlign );
+    aChildArea.Y = rArea.Y + (sal_Int32)( (rArea.Height - aChildArea.Height) * fVerAlign );
+
+    allocateChildAt( mxChild, aChildArea );
+}
+
+/* MinSize */
+
+MinSize::MinSize() : Bin()
+{
+    mnMinWidth = mnMinHeight = 0;
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "MinWidth" ),
+             ::getCppuType( static_cast< const long* >( NULL ) ),
+             &mnMinWidth );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "MinHeight" ),
+             ::getCppuType( static_cast< const long* >( NULL ) ),
+             &mnMinHeight );
+}
+
+awt::Size SAL_CALL MinSize::getMinimumSize()
+    throw(uno::RuntimeException)
+{
+    Bin::getMinimumSize();
+    maRequisition.Width = SAL_MAX( maRequisition.Width, mnMinWidth );
+    maRequisition.Height = SAL_MAX( maRequisition.Height, mnMinHeight );
+    return maRequisition;
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/bin.hxx b/toolkit/source/layout/core/bin.hxx
new file mode 100644
index 0000000..c23c371
--- /dev/null
+++ toolkit/source/layout/core/bin.hxx
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+/* A few simple binary containers */
+
+#ifndef LAYOUT_CORE_BIN_HXX
+#define LAYOUT_CORE_BIN_HXX
+
+#include <layout/core/container.hxx>
+
+namespace layoutimpl
+{
+
+class Bin : public Container
+{
+protected:
+    // Child
+    css::awt::Size maChildRequisition;
+    css::uno::Reference< css::awt::XLayoutConstrains > mxChild;
+
+public:
+    Bin();
+    virtual ~Bin() {}
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException);
+
+    // css::awt::XLayoutConstrains
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+
+    PROPHELPER_SET_INFO
+};
+
+// Align gives control over child position on the allocated space.
+class Align : public Bin
+{
+    friend class AlignChildProps;
+protected:
+    // properties
+    float fHorAlign, fVerAlign;
+    float fHorFill, fVerFill;
+
+public:
+    Align();
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    PROPHELPER_SET_INFO
+};
+
+// Makes child request its or a specified size, whatever is larger.
+class MinSize : public Bin
+{
+protected:
+    // properties
+    long mnMinWidth, mnMinHeight;
+
+public:
+    MinSize();
+
+    // css::awt::XLayoutContainer
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+
+    PROPHELPER_SET_INFO
+};
+
+} //  namespace layoutimpl
+
+#endif /* LAYOUT_CORE_BIN_HXX */
diff --git a/toolkit/source/layout/core/box-base.cxx b/toolkit/source/layout/core/box-base.cxx
new file mode 100644
index 0000000..f0b7a42
--- /dev/null
+++ toolkit/source/layout/core/box-base.cxx
@@ -0,0 +1,176 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "box.hxx"
+
+#include <tools/debug.hxx>
+#include <sal/macros.h>
+
+#include <com/sun/star/awt/XWindow2.hpp>
+
+// fixed point precision for distributing error
+#define FIXED_PT 16
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+Box_Base::ChildData::ChildData( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    : mxChild( xChild )
+    , mxProps()
+    , maRequisition()
+{
+}
+
+static bool isVisible( uno::Reference< awt::XLayoutConstrains > xWidget )
+{
+    if ( !xWidget.is() )
+    {
+        DBG_ERROR( "FIXME: invalid child !" );
+        return true;
+    }
+
+    uno::Reference< awt::XWindow2 > xWindow( xWidget, uno::UNO_QUERY );
+    if ( xWindow.is() && !xWindow->isVisible() )
+        return false;
+
+    uno::Reference< awt::XLayoutContainer > xContainer( xWidget, uno::UNO_QUERY );
+    if ( xContainer.is() )
+    {
+        uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aChildren
+            = xContainer->getChildren();
+
+        // FIXME: <flow> workaround: empty visible containers always visible:
+        if ( !aChildren.getLength() )
+            return true;
+
+        for ( int i = 0; i < aChildren.getLength(); i++ )
+            if ( isVisible( aChildren[i] ) )
+                return true;
+        return false; // this would kill flow without workaround above
+    }
+
+    return true;
+}
+    
+bool Box_Base::ChildData::isVisible()
+{
+    // FIXME: call the 'isVisible' method on it ?
+    return layoutimpl::isVisible( mxChild );
+}
+
+void
+Box_Base::AddChild (uno::Reference <awt::XLayoutConstrains> const& xChild)
+{
+    ChildData *pData = createChild (xChild);
+    maChildren.push_back (pData);
+    queueResize ();
+}
+
+void SAL_CALL
+Box_Base::addChild (uno::Reference <awt::XLayoutConstrains> const& xChild)
+    throw (uno::RuntimeException, awt::MaxChildrenException)
+{
+    if (xChild.is ())
+    {
+        AddChild (xChild);
+        setChildParent (xChild);
+    }
+}
+
+Box_Base::ChildData*
+Box_Base::removeChildData( std::list< ChildData* > lst, css::uno::Reference< css::awt::XLayoutConstrains > const& xChild )
+{
+    for ( std::list< ChildData* >::iterator it = lst.begin();
+          it != lst.end(); it++ )
+    {
+        if ( (*it)->mxChild == xChild )
+        {
+            lst.erase( it );
+            return *it;
+        }
+    }
+    return 0;
+}
+
+void SAL_CALL
+Box_Base::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    if ( ChildData* p = removeChildData( maChildren, xChild ) )
+    {
+        delete p;
+        unsetChildParent( xChild );
+        queueResize();
+    }
+    else
+    {
+        DBG_ERROR( "Box_Base: removeChild: no such child" );
+    }
+}
+
+uno::Sequence< uno::Reference < awt::XLayoutConstrains > > SAL_CALL
+Box_Base::getChildren()
+    throw (uno::RuntimeException)
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
+    unsigned int index = 0;
+    for ( std::list< ChildData* >::iterator it = maChildren.begin();
+          it != maChildren.end(); it++, index++ )
+        children[index] = ( *it )->mxChild;
+
+    return children;
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Box_Base::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    
+    for ( std::list< ChildData * >::iterator it = maChildren.begin();
+          it != maChildren.end(); it++)
+    {
+        if ( ( *it )->mxChild == xChild )
+        {
+            if ( !( *it )->mxProps.is() )
+            {
+                PropHelper *pProps = createChildProps( *it );
+                pProps->setChangeListener( this );
+                ( *it )->mxProps = pProps;
+            }
+            return (*it)->mxProps;
+        }
+    }
+    return uno::Reference< beans::XPropertySet >();
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/box-base.hxx b/toolkit/source/layout/core/box-base.hxx
new file mode 100644
index 0000000..4fa7e53
--- /dev/null
+++ toolkit/source/layout/core/box-base.hxx
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_BOX_BASE_HXX
+#define LAYOUT_CORE_BOX_BASE_HXX
+
+#include <layout/core/container.hxx>
+
+#include <list>
+
+namespace layoutimpl
+{
+
+class Box_Base : public Container
+{
+public:
+    // Children properties
+    struct ChildData
+    {
+        css::uno::Reference< css::awt::XLayoutConstrains > mxChild;
+        css::uno::Reference< css::beans::XPropertySet > mxProps;
+        css::awt::Size maRequisition;
+        virtual bool isVisible();
+        
+        ChildData( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
+        virtual ~ChildData() { };
+    };
+
+    struct ChildProps: public PropHelper
+    {
+        //ChildProps( ChildProps* );
+        PROPHELPER_SET_INFO
+    };
+
+protected:
+    std::list< ChildData* > maChildren;
+
+
+    virtual ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) = 0;
+    virtual ChildProps *createChildProps( ChildData* pData ) = 0;
+    
+    ChildData *removeChildData( std::list< ChildData *>, css::uno::Reference< css::awt::XLayoutConstrains > const& Child );
+    
+public:
+    void AddChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child);
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child)
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+    
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+};
+
+} //  namespace layoutimpl
+
+#endif /* LAYOUT_CORE_BOX_BASE HXX */
diff --git a/toolkit/source/layout/core/box.cxx b/toolkit/source/layout/core/box.cxx
new file mode 100644
index 0000000..6acc8c8
--- /dev/null
+++ toolkit/source/layout/core/box.cxx
@@ -0,0 +1,285 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "box.hxx"
+
+#include <tools/debug.hxx>
+#include <sal/macros.h>
+
+// fixed point precision for distributing error
+#define FIXED_PT 16
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+Box::ChildProps::ChildProps( Box::ChildData *pData )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Expand" ),
+             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &(pData->mbExpand) );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Fill" ),
+             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &(pData->mbFill) );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Padding" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &(pData->mnPadding) );
+}
+
+Box::ChildData::ChildData( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    : Box_Base::ChildData( xChild )
+    , mnPadding( 0 )
+    , mbExpand( true )
+    , mbFill( true )
+{
+}
+
+Box::ChildData*
+Box::createChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    {
+    return new ChildData( xChild );
+    }
+
+Box::ChildProps*
+Box::createChildProps( Box_Base::ChildData *pData )
+{
+    return new ChildProps( static_cast<Box::ChildData*> ( pData ) );
+}
+
+Box::Box( bool horizontal )
+    : Box_Base()
+    , mnSpacing( 0 )
+    , mbHomogeneous( false )
+    , mbHorizontal( horizontal )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ),
+             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &mbHomogeneous );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Spacing" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnSpacing );
+    mbHasFlowChildren = false;
+}
+
+awt::Size
+Box::calculateSize( long nWidth )
+{
+    int nVisibleChildren = 0;
+    // primary vs secundary axis (instead of a X and Y)
+    int nPrimSize = 0;
+    int nSecSize = 0;
+    int nFlowMinWidth = 0;  // in case the box only has flow children
+
+    mbHasFlowChildren = false;
+
+    for ( std::list<Box_Base::ChildData *>::const_iterator it
+              = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = static_cast<Box::ChildData*> ( *it );
+        if ( !child->isVisible() )
+            continue;
+
+        uno::Reference< awt::XLayoutContainer > xChildCont( child->mxChild, uno::UNO_QUERY );
+        bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
+
+        awt::Size aChildSize = child->maRequisition = child->mxChild->getMinimumSize();
+
+        if ( !mbHorizontal /*vertical*/ && bFlow )
+        {
+            if ( nFlowMinWidth == 0 || nFlowMinWidth > aChildSize.Width )
+                nFlowMinWidth = aChildSize.Width;
+            mbHasFlowChildren = true;
+        }
+        else
+        {
+            int size = primDim( aChildSize ) + child->mnPadding * 2;
+            if ( mbHomogeneous )
+                nPrimSize = SAL_MAX( nPrimSize, size );
+            else
+                nPrimSize += size;
+
+            nSecSize = SAL_MAX( nSecSize, secDim( aChildSize ) );
+        }
+        nVisibleChildren++;
+    }
+
+    if ( nVisibleChildren )
+    {
+        if ( mbHomogeneous )
+            nPrimSize *= nVisibleChildren;
+        nPrimSize += (nVisibleChildren - 1) * mnSpacing;
+    }
+
+    if ( mbHasFlowChildren )
+    {
+        if ( nWidth == 0 )
+            nWidth = nSecSize ? nSecSize : nFlowMinWidth;
+        for ( std::list<Box_Base::ChildData *>::const_iterator it
+                  = maChildren.begin(); it != maChildren.end(); it++ )
+        {
+            ChildData *child = static_cast<Box::ChildData*> ( *it );
+            if ( !child->isVisible() )
+                continue;
+
+            uno::Reference< awt::XLayoutContainer > xChildCont( child->mxChild, uno::UNO_QUERY );
+            bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
+
+            if ( bFlow )
+                nPrimSize += xChildCont->getHeightForWidth( nWidth );
+        }
+    }
+
+    nPrimSize += mnBorderWidth * 2;
+    nSecSize += mnBorderWidth * 2;
+    return awt::Size( mbHorizontal ? nPrimSize : nSecSize,
+                      mbHorizontal ? nSecSize : nPrimSize );
+}
+
+awt::Size SAL_CALL
+Box::getMinimumSize() throw(uno::RuntimeException)
+{
+    maRequisition = calculateSize();
+    return maRequisition;
+}
+
+sal_Bool SAL_CALL
+Box::hasHeightForWidth()
+    throw(uno::RuntimeException)
+{
+    return mbHasFlowChildren;
+}
+
+sal_Int32 SAL_CALL
+Box::getHeightForWidth( sal_Int32 nWidth )
+    throw(uno::RuntimeException)
+{
+    if ( hasHeightForWidth() )
+        return calculateSize( nWidth ).Height;
+    return maRequisition.Height;
+}
+
+void SAL_CALL
+Box::allocateArea( const awt::Rectangle &newArea )
+    throw (uno::RuntimeException)
+{
+    maAllocation = newArea;
+    int nVisibleChildren = 0, nExpandChildren = 0;
+
+    for ( std::list<Box_Base::ChildData *>::const_iterator it
+              = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = static_cast<Box::ChildData*> ( *it );
+        if ( child->isVisible() )
+        {
+            nVisibleChildren++;
+            if ( child->mbExpand )
+                nExpandChildren++;
+        }
+    }
+    if ( !nVisibleChildren )
+        return;
+
+    // split rectangle for dimension helpers
+    awt::Point newPoint( newArea.X, newArea.Y );
+    awt::Size newSize( newArea.Width, newArea.Height );
+
+    int nExtraSpace;
+    if ( mbHomogeneous )
+        nExtraSpace = ( ( primDim( newSize ) - mnBorderWidth * 2 -
+                          ( nVisibleChildren - 1 ) * mnSpacing )) / nVisibleChildren;
+    else if ( nExpandChildren )
+    {
+        int reqSize = primDim( maRequisition );
+        if ( !mbHorizontal && hasHeightForWidth() )
+            reqSize = getHeightForWidth( newArea.Width );
+        nExtraSpace = ( primDim( newSize ) - reqSize ) / nExpandChildren;
+    }
+    else
+        nExtraSpace = 0;
+
+    int nChildPrimPoint, nChildSecPoint, nChildPrimSize, nChildSecSize;
+
+    int nStartPoint = primDim( newPoint ) + mnBorderWidth;
+    int nBoxSecSize = SAL_MAX( 1, secDim( newSize ) - mnBorderWidth * 2 );
+
+    for ( std::list<Box_Base::ChildData *>::const_iterator it
+              = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = static_cast<Box::ChildData*> ( *it );
+        if ( !child->isVisible() )
+            continue;
+
+        awt::Point aChildPos;
+        int nBoxPrimSize;  // of the available box space
+
+        if ( mbHomogeneous )
+            nBoxPrimSize = nExtraSpace;
+        else
+        {
+            uno::Reference< awt::XLayoutContainer > xChildCont( child->mxChild, uno::UNO_QUERY );
+            bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
+            if ( !mbHorizontal && bFlow )
+                nBoxPrimSize = xChildCont->getHeightForWidth( newArea.Width );
+            else
+                nBoxPrimSize = primDim( child->maRequisition );
+            nBoxPrimSize += child->mnPadding;
+            if ( child->mbExpand )
+                nBoxPrimSize += nExtraSpace;
+        }
+
+        nChildPrimPoint = nStartPoint + child->mnPadding;
+        nChildSecPoint = secDim( newPoint ) + mnBorderWidth;
+
+        nChildSecSize = nBoxSecSize;
+        if ( child->mbFill )
+            nChildPrimSize = SAL_MAX( 1, nBoxPrimSize - child->mnPadding);
+        else
+        {
+            nChildPrimSize = primDim( child->maRequisition );
+            nChildPrimPoint += (nBoxPrimSize - nChildPrimSize) / 2;
+
+            nChildSecPoint += (nBoxSecSize - nChildSecSize) / 2;
+        }
+
+        awt::Rectangle area;
+        area.X = mbHorizontal ? nChildPrimPoint : nChildSecPoint;
+        area.Y = mbHorizontal ? nChildSecPoint : nChildPrimPoint;
+        area.Width = mbHorizontal ? nChildPrimSize : nChildSecSize;
+        area.Height = mbHorizontal ? nChildSecSize : nChildPrimSize;
+
+        allocateChildAt( child->mxChild, area );
+
+        nStartPoint += nBoxPrimSize + mnSpacing + child->mnPadding;
+    }
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/box.hxx b/toolkit/source/layout/core/box.hxx
new file mode 100644
index 0000000..98190ca
--- /dev/null
+++ toolkit/source/layout/core/box.hxx
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_BOX_HXX
+#define LAYOUT_CORE_BOX_HXX
+
+#include <layout/core/box-base.hxx>
+
+#include <com/sun/star/awt/Point.hpp>
+
+namespace layoutimpl
+{
+
+class Box : public Box_Base
+{
+protected:
+    // Box properties (i.e. affect all children)
+    sal_Int32 mnSpacing;
+    sal_Bool mbHomogeneous;
+    sal_Bool mbHorizontal;  // false for Vertical
+    bool mbHasFlowChildren;
+
+public:
+    // Children properties
+    struct ChildData : public Box_Base::ChildData
+    {
+        sal_Int32 mnPadding;
+        sal_Bool mbExpand;
+        sal_Bool mbFill;
+        ChildData( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
+    };
+
+    struct ChildProps : public Box_Base::ChildProps
+    {
+        ChildProps( ChildData *pData );
+    };
+
+protected:
+    ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
+    ChildProps *createChildProps( Box_Base::ChildData* pData );
+
+public:
+    Box( bool horizontal );
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException);
+
+    // helper: mix of getMinimumSize() and getHeightForWidth()
+    css::awt::Size calculateSize( long nWidth = 0 );
+
+    PROPHELPER_SET_INFO
+
+private:
+    /* Helpers to deal with the joint Box directions. */
+    inline int primDim (const css::awt::Size &size)
+    { if (mbHorizontal) return size.Width; else return size.Height; }
+    inline int secDim (const css::awt::Size &size)
+    { if (mbHorizontal) return size.Height; else return size.Width; }
+    inline int primDim (const css::awt::Point &point)
+    { if (mbHorizontal) return point.X; else return point.Y; }
+    inline int secDim (const css::awt::Point &point)
+    { if (mbHorizontal) return point.Y; else return point.X; }
+};
+
+struct VBox : public Box
+{ VBox() : Box (false) {} };
+
+struct HBox : public Box
+{ HBox() : Box (true) {} };
+
+} //  namespace layoutimpl
+
+#endif /* LAYOUT_CORE_BOX_HXX */
diff --git a/toolkit/source/layout/core/byteseq.cxx b/toolkit/source/layout/core/byteseq.cxx
new file mode 100644
index 0000000..7a61ad2
--- /dev/null
+++ toolkit/source/layout/core/byteseq.cxx
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: byteseq.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <com/sun/star/io/XInputStream.hpp>
+#include <osl/file.hxx>
+#include <comphelper/oslfile2streamwrap.hxx>
+
+using osl::File;
+using osl::FileBase;
+using namespace ::com::sun::star;
+
+namespace layoutimpl
+{
+
+uno::Reference< io::XInputStream > getFileAsStream( const rtl::OUString &rName )
+{
+    rtl::OUString sFileURL;
+    if( FileBase::E_None != FileBase::getFileURLFromSystemPath( rName, sFileURL ) )
+        sFileURL = rName; // maybe it already was a file url
+
+    File * blobFile = new File(sFileURL);
+    File::RC errorCode = blobFile->open(OpenFlag_Read);
+
+    uno::Reference<io::XInputStream> xResult;
+    switch (errorCode)
+    {
+    case osl::File::E_None: // got it
+        xResult.set( new comphelper::OSLInputStreamWrapper(blobFile,true) );
+        break;
+
+    case osl::File::E_NOENT: // no file => no stream
+        delete blobFile;
+        break;
+
+    default:
+        delete blobFile;
+/*            {
+            rtl::OUStringBuffer sMsg;
+            sMsg.appendAscii("Cannot open output file \"");
+            sMsg.append(aURL);
+            sMsg.appendAscii("\" : ");
+            sMsg.append(configmgr::FileHelper::createOSLErrorString(errorCode));
+
+            throw io::IOException(sMsg.makeStringAndClear(),NULL);
+        }   
+*/
+    }
+
+    return xResult;
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/container.cxx b/toolkit/source/layout/core/container.cxx
new file mode 100644
index 0000000..c9b4513
--- /dev/null
+++ toolkit/source/layout/core/container.cxx
@@ -0,0 +1,167 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "container.hxx"
+
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/PosSize.hpp>
+#include <tools/debug.hxx>
+
+namespace layoutimpl {
+
+using namespace css;
+
+Container::Container()
+    : Container_Base()
+    , PropHelper()
+    , mnBorderWidth( 0 )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Border" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnBorderWidth );
+    setChangeListener( this );
+}
+
+uno::Any
+Container::queryInterface( const uno::Type & rType ) throw (uno::RuntimeException)
+{
+    uno::Any aRet = Container_Base::queryInterface( rType );
+    return aRet.hasValue() ? aRet : PropHelper::queryInterface( rType );
+}
+
+void
+Container::allocateChildAt( const uno::Reference< awt::XLayoutConstrains > &xChild,
+                            const awt::Rectangle &rArea )
+    throw( uno::RuntimeException )
+{
+    uno::Reference< awt::XLayoutContainer > xCont( xChild, uno::UNO_QUERY );
+    if ( xCont.is() )
+        xCont->allocateArea( rArea );
+    else
+    {
+        uno::Reference< awt::XWindow > xWindow( xChild, uno::UNO_QUERY );
+        if ( xWindow.is() )
+            xWindow->setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height,
+                                 awt::PosSize::POSSIZE );
+        else
+        {
+            DBG_ERROR( "Error: non-sizeable child" );
+        }
+    }
+}
+
+uno::Sequence< uno::Reference< awt::XLayoutConstrains > >
+Container::getSingleChild ( uno::Reference< awt::XLayoutConstrains >const &xChildOrNil )
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aSeq( ( xChildOrNil.is() ? 1 : 0 ) );
+    if ( xChildOrNil.is() )
+        aSeq[0] = xChildOrNil;
+    return aSeq;
+}
+
+void
+Container::queueResize()
+{
+    if ( mxLayoutUnit.is() )
+        mxLayoutUnit->queueResize( uno::Reference< awt::XLayoutContainer >( this ) );
+}
+
+void
+Container::setChildParent( const uno::Reference< awt::XLayoutConstrains >& xChild )
+{
+    uno::Reference< awt::XLayoutContainer > xContChild( xChild, uno::UNO_QUERY );
+    if ( xContChild.is() )
+    {
+        xContChild->setParent( uno::Reference< awt::XLayoutContainer >( this ) );
+#if 0
+        assert( !mxLayoutUnit.is() );
+        xContChild->setLayoutUnit( mxLayoutUnit );
+#endif
+    }
+}
+
+void
+Container::unsetChildParent( const uno::Reference< awt::XLayoutConstrains >& xChild )
+{
+    uno::Reference< awt::XLayoutContainer > xContChild( xChild, uno::UNO_QUERY );
+    if ( xContChild.is() )
+    {
+        xContChild->setParent( uno::Reference< awt::XLayoutContainer >() );
+#if 0
+        xContChild->setLayoutUnit( uno::Reference< awt::XLayoutUnit >() );
+#endif
+    }
+}
+
+#if 0
+std::string
+Container::getLabel()  // debug label
+{
+    std::string depth;
+    uno::Reference< awt::XLayoutContainer > xContainer( this );
+    while ( xContainer.is() )
+    {
+        int node = 0;  // child nb
+        uno::Reference< awt::XLayoutContainer > xParent = xContainer->getContainerParent();
+        if ( xParent.is() )
+        {
+
+            uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aChildren;
+            aChildren = xParent->getChildren();
+            for ( node = 0; node < aChildren.getLength(); node++ )
+                if ( aChildren[ node ] == xContainer )
+                    break;
+        }
+
+        char str[ 8 ];
+        snprintf( str, 8, "%d", node );
+        if ( depth.empty() )
+            depth = std::string( str );
+        else
+            depth = std::string( str ) + ":" + depth;
+
+        xContainer = xParent;
+    }
+
+    return std::string( getName() ) + " (" + depth + ")";
+}
+#endif
+
+void Container::propertiesChanged()
+{
+    // cl: why this assertion? This is also called to set properties at the top level widget which has no parent!?
+    // DBG_ASSERT( mxParent.is(), "Properties listener: error container doesn't have parent" );
+    
+    if ( mxLayoutUnit.is() && mxParent.is() )
+        mxLayoutUnit->queueResize( mxParent );
+}
+
+}
diff --git a/toolkit/source/layout/core/container.hxx b/toolkit/source/layout/core/container.hxx
new file mode 100644
index 0000000..5cac33d
--- /dev/null
+++ toolkit/source/layout/core/container.hxx
@@ -0,0 +1,140 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_CONTAINER_HXX
+#define LAYOUT_CORE_CONTAINER_HXX
+
+#include <layout/core/helper.hxx>
+
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/awt/MaxChildrenException.hpp>
+
+namespace layoutimpl
+{
+namespace css = ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper2< css::awt::XLayoutContainer,
+                                 css::awt::XLayoutConstrains > Container_Base;
+
+class Container : public Container_Base, public PropHelper, public PropHelper::Listener
+{
+    friend class ChildProps;
+protected:
+    // Widget properties
+    css::uno::Reference< css::awt::XLayoutContainer > mxParent;
+    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
+    css::awt::Size maRequisition;
+    css::awt::Rectangle maAllocation;
+
+    // Container properties
+    sal_Int32 mnBorderWidth;
+
+    // Utilities
+    void allocateChildAt( const css::uno::Reference< css::awt::XLayoutConstrains > &xChild,
+                          const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+    static css::uno::Sequence< css::uno::Reference< css::awt::XLayoutConstrains > >
+    getSingleChild (const css::uno::Reference< css::awt::XLayoutConstrains > &xChildOrNil);
+    void setChildParent( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild );
+    void unsetChildParent( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild );
+
+    void queueResize();
+    void forceRecalc() { allocateArea( maAllocation ); }
+
+public:
+    Container();
+    virtual ~Container() {}
+
+    // XInterface
+    virtual void SAL_CALL acquire() throw() { PropHelper::acquire(); }
+    virtual void SAL_CALL release() throw() { PropHelper::release(); }
+    virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException) = 0;
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException) = 0;
+
+    virtual css::uno::Sequence< css::uno::Reference
+                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException) = 0;
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException) = 0;
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException) = 0;
+
+    void SAL_CALL setLayoutUnit( const css::uno::Reference< css::awt::XLayoutUnit > &xUnit )
+        throw(css::uno::RuntimeException)
+    { mxLayoutUnit = xUnit; }
+    css::uno::Reference< css::awt::XLayoutUnit > SAL_CALL getLayoutUnit()
+        throw(css::uno::RuntimeException)
+    { return mxLayoutUnit; }
+
+    css::awt::Size SAL_CALL getRequestedSize() throw(css::uno::RuntimeException)
+    { return maRequisition; }
+    com::sun::star::awt::Rectangle SAL_CALL getAllocatedArea() throw(css::uno::RuntimeException)
+    { return maAllocation; }
+
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException) = 0;
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException) = 0;
+
+    // css::awt::XLayoutContainer: css::container::XChild
+    css::uno::Reference< css::uno::XInterface > SAL_CALL getParent()
+        throw (css::uno::RuntimeException)
+    { return mxParent; }
+    void SAL_CALL setParent( const css::uno::Reference< css::uno::XInterface > &xParent )
+        throw (css::uno::RuntimeException)
+    { mxParent = css::uno::Reference< css::awt::XLayoutContainer >( xParent, css::uno::UNO_QUERY ); }
+
+    // css::awt::XLayoutConstrains
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException) = 0;
+    // (not properly implemented in toolkit, ignore it.)
+    css::awt::Size SAL_CALL getPreferredSize()
+        throw(css::uno::RuntimeException) { return getMinimumSize(); } // TODO: use this for flow?
+    css::awt::Size SAL_CALL calcAdjustedSize( const css::awt::Size& rNewSize )
+        throw(css::uno::RuntimeException) { return rNewSize; }
+
+PROPHELPER_SET_INFO
+
+protected:
+    void propertiesChanged();
+};
+
+} //  namespace layoutimpl
+
+#endif /* LAYOUT_CORE_CONTAINER_HXX */
diff --git a/toolkit/source/layout/core/dialogbuttonhbox.cxx b/toolkit/source/layout/core/dialogbuttonhbox.cxx
new file mode 100644
index 0000000..67a7ec0
--- /dev/null
+++ toolkit/source/layout/core/dialogbuttonhbox.cxx
@@ -0,0 +1,294 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <awt/vclxbutton.hxx>
+#include <tools/debug.hxx>
+#include <toolkit/awt/vclxwindows.hxx>
+#include <vcl/button.hxx>
+
+#include "dialogbuttonhbox.hxx"
+#include "flow.hxx"
+#include "proplist.hxx"
+
+#if TEST_LAYOUT && !defined( DBG_UTIL )
+#include <cstdio>
+#undef DBG_ERROR
+#define DBG_ERROR printf
+#undef DBG_ERROR1
+#define DBG_ERROR1 printf
+#undef DBG_ERROR2
+#define DBG_ERROR2 printf
+#endif /* TEST_LAYOUT && !DBG_UTIL */
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+//FIXME: how to set platform-dependant variables?
+DialogButtonHBox::Ordering const DialogButtonHBox::DEFAULT_ORDERING =
+#if defined( MACOSX )
+    DialogButtonHBox::MACOS;
+#elif defined( SAL_W32 )
+DialogButtonHBox::WINDOWS;
+#elif defined( ENABLE_KDE )
+DialogButtonHBox::KDE;
+#else /* !MACOSX && !SAL_W32 && !ENABLE_KDE */
+DialogButtonHBox::GNOME;
+#endif /* !MACOSX && !SAL_W32 && !ENABLE_KDE */
+
+DialogButtonHBox::DialogButtonHBox()
+    : HBox()
+    , mnOrdering( DEFAULT_ORDERING )
+    , mFlow()
+    , mpAction( 0 )
+    , mpAffirmative( 0 )
+    , mpAlternate( 0 )
+    , mpApply( 0 )
+    , mpCancel( 0 )
+    , mpFlow( createChild( uno::Reference< awt::XLayoutConstrains > ( &mFlow ) ) )
+    , mpHelp( 0 )
+    , mpReset( 0 )
+{
+    mbHomogeneous = true;
+}
+
+void
+DialogButtonHBox::setOrdering( rtl::OUString const& ordering )
+{
+    if ( ordering.equalsIgnoreAsciiCaseAscii( "GNOME" ) )
+        mnOrdering = GNOME;
+    else if ( ordering.equalsIgnoreAsciiCaseAscii( "KDE" ) )
+        mnOrdering = KDE;
+    else if ( ordering.equalsIgnoreAsciiCaseAscii( "MacOS" ) )
+        mnOrdering = MACOS;
+    else if ( ordering.equalsIgnoreAsciiCaseAscii( "Windows" ) )
+        mnOrdering = WINDOWS;
+    else
+    {
+        DBG_ERROR1( "DialogButtonHBox: no such ordering: %s", OUSTRING_CSTR( ordering ) );
+    }
+}
+
+void
+DialogButtonHBox::addChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    throw ( uno::RuntimeException, awt::MaxChildrenException )
+{
+    if ( !xChild.is() )
+        return;
+
+    ChildData *p = createChild( xChild );
+
+#define IS_BUTTON(t) dynamic_cast<VCLX##t##Button *>( xChild.get () )
+
+    /* Sort Retry as Action */
+    if ( !mpAction && IS_BUTTON( Retry ) )
+        mpAction = p;
+    else if ( !mpAffirmative && IS_BUTTON( OK ) )
+        mpAffirmative = p;
+    else if ( !mpAffirmative && IS_BUTTON( Yes ) )
+        mpAffirmative = p;
+    else if ( !mpAlternate && IS_BUTTON( No ) )
+        mpAlternate = p;
+    /* Sort Ignore as Alternate */
+    else if ( !mpAlternate && IS_BUTTON( Ignore ) )
+        mpAlternate = p;
+    else if ( !mpApply && IS_BUTTON( Apply ) )
+        mpApply = p;
+    else if ( !mpCancel && IS_BUTTON( Cancel ) )
+        mpCancel = p;
+    /* Let the user overwrite Flow */
+    else if ( /* !mpFlow && */ dynamic_cast<Flow *>( xChild.get () ) )
+        mpFlow = p;
+    else if ( !mpHelp && IS_BUTTON( Help ) )
+        mpHelp = p;
+    else if ( !mpReset && IS_BUTTON( Reset ) )
+        mpReset = p;
+    else
+        maOther.push_back( p );
+    orderChildren();
+    setChildParent( xChild );
+    queueResize();
+}
+
+void
+DialogButtonHBox::orderChildren()
+{
+    if ( mnOrdering == WINDOWS )
+        windowsOrdering();
+    else if ( mnOrdering == MACOS )
+        macosOrdering();
+    else if ( mnOrdering == KDE )
+        kdeOrdering();
+    else if ( 1 || mnOrdering == GNOME )
+        gnomeOrdering();
+}
+
+void SAL_CALL
+DialogButtonHBox::removeChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    throw ( uno::RuntimeException)
+{
+    if ( !xChild.is ())
+        return;
+
+    Box_Base::ChildData *p = 0;
+
+    if ( mpAction && mpAction->mxChild == xChild )
+        p = mpAction;
+    else if ( mpAffirmative && mpAffirmative->mxChild == xChild )
+        p = mpAffirmative;
+    else if ( mpAlternate && mpAlternate->mxChild == xChild )
+        p = mpAlternate;
+    else if ( mpApply && mpApply->mxChild == xChild )
+        p = mpApply;
+    else if ( mpCancel && mpCancel->mxChild == xChild )
+        p = mpCancel;
+    else if ( mpFlow && mpFlow->mxChild == xChild )
+        p = mpFlow;
+    else if ( mpReset && mpReset->mxChild == xChild )
+        p = mpReset;
+    else if ( mpHelp && mpHelp->mxChild == xChild )
+        p = mpHelp;
+    else
+        p = removeChildData( maOther, xChild );
+
+    if ( p )
+    {
+        delete p;
+        unsetChildParent( xChild );
+        orderChildren();
+        queueResize();
+    }
+    else
+    {
+        DBG_ERROR( "DialogButtonHBox: removeChild: no such child" );
+    }
+}
+
+void
+DialogButtonHBox::gnomeOrdering()
+{
+    std::list< Box_Base::ChildData * > ordered;
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpFlow && ( mpHelp || mpReset ) )
+        ordered.push_back( mpFlow );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    maChildren = ordered;
+}
+
+void
+DialogButtonHBox::kdeOrdering()
+{
+    std::list< Box_Base::ChildData * > ordered;
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpFlow && ( mpHelp || mpReset ) )
+        ordered.push_back( mpFlow );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    maChildren = ordered;
+}
+
+void
+DialogButtonHBox::macosOrdering()
+{
+    std::list< Box_Base::ChildData * > ordered;
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpFlow ) // Always flow? && ( maOther.size () || mpHelp || mpReset || mpAction ) )
+        ordered.push_back( mpFlow );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpFlow && mpAlternate )
+        ordered.push_back( mpFlow );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    maChildren = ordered;
+}
+
+void
+DialogButtonHBox::windowsOrdering()
+{
+    std::list< Box_Base::ChildData * > ordered;
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpReset && mpFlow )
+        ordered.push_back( mpFlow );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    maChildren = ordered;
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/dialogbuttonhbox.hxx b/toolkit/source/layout/core/dialogbuttonhbox.hxx
new file mode 100644
index 0000000..8159fa4
--- /dev/null
+++ toolkit/source/layout/core/dialogbuttonhbox.hxx
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_DIALOGBUTTONHBOX_HXX
+#define LAYOUT_CORE_DIALOGBUTTONHBOX_HXX
+
+#include <layout/core/box.hxx>
+#include <layout/core/flow.hxx>
+
+namespace layoutimpl
+{
+
+class DialogButtonHBox : public HBox
+{
+public:
+    DialogButtonHBox();
+
+    void setOrdering( rtl::OUString const& ordering );
+    void SAL_CALL addChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) throw ( css::uno::RuntimeException, css::awt::MaxChildrenException );
+    void SAL_CALL removeChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) throw ( css::uno::RuntimeException );
+
+private:
+    enum Ordering { PLATFORM, GNOME, KDE, MACOS, WINDOWS };
+
+    void orderChildren();
+    void gnomeOrdering();
+    void kdeOrdering();
+    void macosOrdering();
+    void windowsOrdering();
+
+    static Ordering const DEFAULT_ORDERING;
+    Ordering mnOrdering;
+    Flow mFlow;
+
+    ChildData *mpAction; /* [..]?, [Retry?] */
+    ChildData *mpAffirmative; /* OK, Yes, Save */
+    ChildData *mpAlternate; /* NO, [Ignore?], Don't save, Quit without saving */
+    ChildData *mpApply; /* Deprecated? */
+    ChildData *mpCancel; /* Cancel, Close */
+    ChildData *mpFlow;
+    ChildData *mpHelp;
+    ChildData *mpReset;
+
+    std::list< Box_Base::ChildData *> maOther;
+};
+
+} // namespace layoutimpl
+
+#endif /* LAYOUT_CORE_DIALOGBUTTONHBOX_HXX */
diff --git a/toolkit/source/layout/core/factory.cxx b/toolkit/source/layout/core/factory.cxx
new file mode 100644
index 0000000..e687ca8
--- /dev/null
+++ toolkit/source/layout/core/factory.cxx
@@ -0,0 +1,154 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "factory.hxx"
+
+#include <com/sun/star/registry/XRegistryKey.hpp>
+#include <com/sun/star/registry/InvalidRegistryException.hpp>
+#include <cppuhelper/factory.hxx>
+
+#include "root.hxx"
+
+using namespace ::com::sun::star;
+using namespace layoutimpl;
+
+void * SAL_CALL comp_Layout_component_getFactory( const char * pImplName, void * pServiceManager, void * /*registryKey*/ )
+    {
+        void * pRet = 0;
+
+        ::rtl::OUString aImplName( ::rtl::OUString::createFromAscii( pImplName ) );
+        uno::Reference< lang::XSingleServiceFactory > xFactory;
+
+        if ( pServiceManager && aImplName.equals( LayoutFactory::impl_staticGetImplementationName() ) )
+            xFactory = ::cppu::createOneInstanceFactory( reinterpret_cast< lang::XMultiServiceFactory*>( pServiceManager ),
+                                                         LayoutFactory::impl_staticGetImplementationName(),
+                                                         LayoutFactory::impl_staticCreateSelfInstance,
+                                                         LayoutFactory::impl_staticGetSupportedServiceNames() );
+        if ( xFactory.is() )
+        {
+            xFactory->acquire();
+            pRet = xFactory.get();
+        }
+
+        return pRet;
+    }
+
+sal_Bool SAL_CALL comp_Layout_component_writeInfo( void * /*serviceManager*/, void * pRegistryKey )
+    {
+        if ( pRegistryKey )
+        {
+            try
+            {
+                uno::Reference< registry::XRegistryKey > xKey( reinterpret_cast< registry::XRegistryKey* >( pRegistryKey ) );
+                uno::Reference< registry::XRegistryKey >  xNewKey;
+
+                xNewKey = xKey->createKey( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("/") ) +
+                                           LayoutFactory::impl_staticGetImplementationName() +
+                                           ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "/UNO/SERVICES") )  );
+
+                const uno::Sequence< ::rtl::OUString > aServices = LayoutFactory::impl_staticGetSupportedServiceNames();
+                for ( sal_Int32 i = 0; i < aServices.getLength(); i++ )
+                    xNewKey->createKey( aServices.getConstArray()[i] );
+
+                return sal_True;
+            }
+            catch (registry::InvalidRegistryException &)
+        {
+            OSL_ENSURE( sal_False, "### InvalidRegistryException!" );
+        }
+        }
+        return sal_False;
+    }
+
+// Component registration
+::rtl::OUString SAL_CALL LayoutFactory::impl_staticGetImplementationName()
+{
+    return ::rtl::OUString::createFromAscii( "com.sun.star.comp.awt.Layout" );
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL LayoutFactory::impl_staticGetSupportedServiceNames()
+{
+    uno::Sequence< ::rtl::OUString > aRet(2);
+    aRet[0] = ::rtl::OUString::createFromAscii("com.sun.star.awt.Layout");
+    aRet[1] = ::rtl::OUString::createFromAscii("com.sun.star.comp.awt.Layout");
+    return aRet;
+}
+
+uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::impl_staticCreateSelfInstance(
+    const uno::Reference< lang::XMultiServiceFactory >& xServiceManager )
+{
+    return uno::Reference< uno::XInterface >( *new LayoutFactory( xServiceManager ) );
+}
+
+// XServiceInfo
+::rtl::OUString SAL_CALL LayoutFactory::getImplementationName()
+    throw ( uno::RuntimeException )
+{
+    return impl_staticGetImplementationName();
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL LayoutFactory::getSupportedServiceNames()
+    throw ( uno::RuntimeException )
+{
+    return impl_staticGetSupportedServiceNames();
+}
+
+sal_Bool SAL_CALL LayoutFactory::supportsService( const ::rtl::OUString& ServiceName )
+    throw ( uno::RuntimeException )
+{
+    uno::Sequence< ::rtl::OUString > aSeq = impl_staticGetSupportedServiceNames();
+    for ( sal_Int32 i = 0; i < aSeq.getLength(); i++ )
+        if ( ServiceName.compareTo( aSeq[i] ) == 0 )
+            return sal_True;
+    
+    return sal_False;
+}
+
+// XSingleServiceFactory
+uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::createInstance()
+    throw ( uno::Exception,
+            uno::RuntimeException )
+{
+    return uno::Reference< uno::XInterface >(
+        static_cast< OWeakObject* >( new LayoutRoot( m_xFactory ) ),
+        uno::UNO_QUERY );
+}
+
+uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::createInstanceWithArguments(
+    const uno::Sequence< uno::Any >& aArguments )
+    throw ( uno::Exception,
+            uno::RuntimeException )
+{
+    uno::Reference< uno::XInterface > layout = createInstance();
+    uno::Reference< lang::XInitialization > xInit( layout, uno::UNO_QUERY );
+    xInit->initialize( aArguments );
+    return layout;
+}
diff --git a/toolkit/source/layout/core/factory.hxx b/toolkit/source/layout/core/factory.hxx
new file mode 100644
index 0000000..a7ac307
--- /dev/null
+++ toolkit/source/layout/core/factory.hxx
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_FACTORY_HXX
+#define LAYOUT_CORE_FACTORY_HXX
+
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <cppuhelper/implbase2.hxx>
+#include <toolkit/dllapi.h>
+
+namespace layoutimpl
+{
+class Layout;
+}
+
+class TOOLKIT_DLLPUBLIC LayoutFactory : public ::cppu::WeakImplHelper2< ::com::sun::star::lang::XSingleServiceFactory,
+                                                      ::com::sun::star::lang::XServiceInfo >
+{
+    ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_xFactory;
+
+public:
+    LayoutFactory( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xFactory )
+        : m_xFactory( xFactory )
+    {
+        OSL_ENSURE( xFactory.is(), "No service manager is provided!\n" );
+    }
+
+    static ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL
+    impl_staticGetSupportedServiceNames();
+
+    static ::rtl::OUString SAL_CALL impl_staticGetImplementationName();
+
+    static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL
+    impl_staticCreateSelfInstance(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceManager );
+
+
+    // XSingleServiceFactory
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL createInstance() throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL createInstanceWithArguments( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments ) throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
+
+    // XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName() throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames() throw (::com::sun::star::uno::RuntimeException);
+
+};
+
+#endif /* LAYOUT_CORE_FACTORY_HXX */
diff --git a/toolkit/source/layout/core/flow.cxx b/toolkit/source/layout/core/flow.cxx
new file mode 100644
index 0000000..4bfd1b9
--- /dev/null
+++ toolkit/source/layout/core/flow.cxx
@@ -0,0 +1,207 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "flow.hxx"
+
+#include <sal/macros.h>
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+bool Flow::ChildData::isVisible()
+{
+    return xChild.is();
+}
+
+Flow::Flow()
+    : Container()
+    , mnSpacing( 0 )
+    , mbHomogeneous( false )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ),
+             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &mbHomogeneous );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Spacing" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnSpacing );
+}
+
+void SAL_CALL
+Flow::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException, css::awt::MaxChildrenException)
+{
+    if ( xChild.is() )
+    {
+        ChildData *pData = new ChildData();
+        pData->xChild = xChild;
+        maChildren.push_back( pData );
+
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+void SAL_CALL
+Flow::removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild )
+    throw (css::uno::RuntimeException)
+{
+    for ( std::list< ChildData * >::iterator it = maChildren.begin();
+          it != maChildren.end(); it++ )
+    {
+        if ( (*it)->xChild == xChild )
+        {
+            delete *it;
+            maChildren.erase( it );
+
+            unsetChildParent( xChild );
+            queueResize();
+            break;
+        }
+    }
+}
+
+css::uno::Sequence< css::uno::Reference < css::awt::XLayoutConstrains > > SAL_CALL
+Flow::getChildren()
+    throw (css::uno::RuntimeException)
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
+    unsigned int i = 0;
+    for ( std::list< ChildData * >::iterator it = maChildren.begin();
+          it != maChildren.end(); it++, i++ )
+        children[i] = (*it)->xChild;
+
+    return children;
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Flow::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& /*xChild*/ )
+    throw (uno::RuntimeException)
+{
+    return uno::Reference< beans::XPropertySet >();
+}
+
+css::awt::Size
+Flow::calculateSize( long nMaxWidth )
+{
+    long nNeedHeight = 0;
+
+    std::list<ChildData *>::const_iterator it;
+    mnEachWidth = 0;
+    // first pass, for homogeneous property
+    for (it = maChildren.begin(); it != maChildren.end(); it++)
+    {
+        if ( !(*it)->isVisible() )
+            continue;
+        (*it)->aRequisition = (*it)->xChild->getMinimumSize();
+        if ( mbHomogeneous )
+            mnEachWidth = SAL_MAX( mnEachWidth, (*it)->aRequisition.Width );
+    }
+
+    long nRowWidth = 0, nRowHeight = 0;
+    for (it = maChildren.begin(); it != maChildren.end(); it++)
+    {
+        if ( !(*it)->isVisible() )
+            continue;
+
+        awt::Size aChildSize = (*it)->aRequisition;
+        if ( mbHomogeneous )
+            aChildSize.Width = mnEachWidth;
+
+        if ( nMaxWidth && nRowWidth > 0 && nRowWidth + aChildSize.Width > nMaxWidth )
+        {
+            nRowWidth = 0;
+            nNeedHeight += nRowHeight;
+            nRowHeight = 0;
+        }
+        nRowHeight = SAL_MAX( nRowHeight, aChildSize.Height );
+        nRowWidth += aChildSize.Width;
+    }
+    nNeedHeight += nRowHeight;
+
+    return awt::Size( nRowWidth, nNeedHeight );
+}
+
+awt::Size SAL_CALL
+Flow::getMinimumSize() throw(uno::RuntimeException)
+{
+    return maRequisition = calculateSize( 0 );
+}
+
+sal_Bool SAL_CALL
+Flow::hasHeightForWidth()
+    throw(css::uno::RuntimeException)
+{
+    return true;
+}
+
+sal_Int32 SAL_CALL
+Flow::getHeightForWidth( sal_Int32 nWidth )
+    throw(css::uno::RuntimeException)
+{
+    return calculateSize( nWidth ).Height;
+}
+
+void SAL_CALL
+Flow::allocateArea( const css::awt::Rectangle &rArea )
+    throw (css::uno::RuntimeException)
+{
+    maAllocation = rArea;
+
+    std::list<ChildData *>::const_iterator it;
+    long nX = 0, nY = 0, nRowHeight = 0;
+    for (it = maChildren.begin(); it != maChildren.end(); it++)
+    {
+        ChildData *child = *it;
+        if ( !child->isVisible() )
+            continue;
+
+        awt::Size aChildSize( child->aRequisition );
+        if ( mbHomogeneous )
+            aChildSize.Width = mnEachWidth;
+
+        if ( nX > 0 && nX + aChildSize.Width > rArea.Width )
+        {
+            nX = 0;
+            nY += nRowHeight;
+            nRowHeight = 0;
+        }
+        nRowHeight = SAL_MAX( nRowHeight, aChildSize.Height );
+
+        allocateChildAt( child->xChild,
+                         awt::Rectangle( rArea.X + nX, rArea.Y + nY, aChildSize.Width, aChildSize.Height ) );
+
+        nX += aChildSize.Width;
+    }
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/flow.hxx b/toolkit/source/layout/core/flow.hxx
new file mode 100644
index 0000000..d550947
--- /dev/null
+++ toolkit/source/layout/core/flow.hxx
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_FLOW_HXX
+#define LAYOUT_CORE_FLOW_HXX
+
+#include <layout/core/container.hxx>
+
+#include <list>
+
+namespace layoutimpl
+{
+
+class Flow : public Container
+{
+protected:
+    // Box properties (i.e. affect all children)
+    sal_Int32 mnSpacing;
+    sal_Bool mbHomogeneous;
+
+public:
+    // Children properties
+    struct ChildData
+    {
+        css::awt::Size aRequisition;
+        css::uno::Reference< css::awt::XLayoutConstrains > xChild;
+        css::uno::Reference< css::beans::XPropertySet >    xProps;
+        bool isVisible();
+    };
+
+protected:
+    std::list< ChildData * > maChildren;
+    long mnEachWidth;  // on homogeneous, the width of every child
+
+public:
+    Flow();
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException);
+
+PROPHELPER_SET_INFO
+
+private:
+    // shared between getMinimumSize() and getHeightForWidth()
+    css::awt::Size calculateSize( long nMaxWidth );
+};
+
+} //  namespace layoutimpl
+
+#endif /* LAYOUT_FLOW_CORE_HXX */
diff --git a/toolkit/source/layout/core/helper.cxx b/toolkit/source/layout/core/helper.cxx
new file mode 100644
index 0000000..7516454
--- /dev/null
+++ toolkit/source/layout/core/helper.cxx
@@ -0,0 +1,662 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "helper.hxx"
+
+#include <assert.h>
+#include <list>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <tools/debug.hxx>
+
+#include "proplist.hxx"
+
+#if TEST_LAYOUT && !defined( DBG_UTIL )
+#include <cstdio>
+#undef DBG_ERROR
+#define DBG_ERROR printf
+#undef DBG_ERROR1
+#define DBG_ERROR1 printf
+#undef DBG_ERROR2
+#define DBG_ERROR2 printf
+#endif /* TEST_LAYOUT && !DBG_UTIL */
+
+namespace layoutimpl
+{
+using namespace com::sun::star;
+using rtl::OUString;
+
+uno::Reference< awt::XWindowPeer >
+getParent( uno::Reference< uno::XInterface > xRef )
+{
+    do
+    {
+        uno::Reference< awt::XWindowPeer > xPeer( xRef, uno::UNO_QUERY );
+        if ( xPeer.is() )
+            return xPeer;
+
+        uno::Reference< awt::XLayoutContainer > xCont( xRef, uno::UNO_QUERY );
+        if ( xCont.is() )
+            xRef = xCont->getParent();
+    }
+    while ( xRef.is() );
+
+    return uno::Reference< awt::XWindowPeer >();
+}
+
+#if 0
+static uno::Reference< awt::XWindowPeer >
+getToplevel( uno::Reference< uno::XInterface > xRef )
+{
+    uno::Reference< awt::XWindowPeer > xTop, i;
+    while ( ( i = uno::Reference< awt::XWindowPeer >( xRef, uno::UNO_QUERY ) ).is() )
+    {
+        xTop = i;
+
+        uno::Reference< awt::XLayoutContainer > xCont( xRef, uno::UNO_QUERY );
+        if ( xCont.is() )
+            xRef = xCont->getParent();
+        else
+            xRef = uno::Reference< awt::XWindowPeer >();
+    }
+
+    return xTop;
+}
+#endif
+
+}
+
+#include "bin.hxx"
+#include "box.hxx"
+#include "dialogbuttonhbox.hxx"
+#include "flow.hxx"
+#include "localized-string.hxx"
+#include "table.hxx"
+
+namespace layoutimpl
+{
+
+oslModule WidgetFactory::mSfx2Library = 0;
+WindowCreator WidgetFactory::mSfx2CreateWidget = 0;
+
+uno::Reference <awt::XLayoutContainer> WidgetFactory::createContainer (OUString const& name)
+{
+    uno::Reference< awt::XLayoutContainer > xPeer;
+
+    if ( name.equalsAscii( "hbox" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new HBox() );
+    else if ( name.equalsAscii( "vbox" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new VBox() );
+    else if ( name.equalsAscii( "table" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Table() );
+    else if ( name.equalsAscii( "flow" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Flow() );
+    else if ( name.equalsAscii( "bin" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Bin() );
+    else if ( name.equalsAscii( "min-size" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new MinSize() );
+    else if ( name.equalsAscii( "align" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Align() );
+    else if ( name.equalsAscii( "dialogbuttonhbox" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new DialogButtonHBox() );
+
+    return xPeer;
+}
+
+uno::Reference <awt::XLayoutConstrains> WidgetFactory::toolkitCreateWidget (uno::Reference <awt::XToolkit> xToolkit, uno::Reference <uno::XInterface> xParent, OUString const& name, long properties)
+{
+    uno::Reference< awt::XLayoutConstrains > xPeer;
+    bool bToplevel = !xParent.is();
+
+    // UNO Control Widget
+    awt::WindowDescriptor desc;
+    if ( bToplevel )
+        desc.Type = awt::WindowClass_TOP;
+    else
+    {
+        desc.Type = awt::WindowClass_SIMPLE;
+
+#if 0
+        // top container -- a wrapper for framewindow -- is de-coupled
+        // from awt::XWindowPeer. So, getParent() fails at it.
+        uno::Reference< awt::XWindowPeer > xWinParent = getParent( xParent );
+#else
+        uno::Reference< awt::XWindowPeer > xWinParent( xParent, uno::UNO_QUERY );
+#endif
+        assert( xParent.is() );
+        assert( xWinParent.is() );
+        /*
+          With the new three layer instarr/rpath feature, when
+          prepending toolkit/unxlngx6.pro/lib or $SOLARVER/lib to
+          LD_LIBRARY_PATH, VCLXWindow::GetImplementation returns 0x0
+          vclxtoolkit::ImplCreateWindow failing to create any widget;
+          although it succeeds here.
+
+          While developing, one now must copy libtlx.so to
+          $OOO_INSTALL_PREFIX/openoffice.org/basis3.0/program/libtklx.so
+          each time.
+        */
+		VCLXWindow* parentComponent = VCLXWindow::GetImplementation( xWinParent );
+        if ( !parentComponent )
+            throw uno::RuntimeException(
+                OUString::createFromAscii( "parent has no implementation" ),
+                uno::Reference< uno::XInterface >() );
+        desc.Parent = xWinParent;
+    }
+
+    desc.ParentIndex = 0;
+    // debugging help ...
+    desc.Bounds.X = 0;
+    desc.Bounds.Y = 0;
+    desc.Bounds.Width = 300;
+    desc.Bounds.Height = 200;
+
+    desc.WindowAttributes = properties;
+    desc.WindowServiceName = name;
+
+    uno::Reference< awt::XWindowPeer > xWinPeer;
+    try
+    {
+        OSL_TRACE("Asking toolkit: %s", OUSTRING_CSTR( desc.WindowServiceName ) );
+        xWinPeer = xToolkit->createWindow( desc );
+        if ( !xWinPeer.is() )
+            throw uno::RuntimeException(
+                OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot create peer" ) ),
+                uno::Reference< uno::XInterface >() );
+        xPeer = uno::Reference< awt::XLayoutConstrains >( xWinPeer, uno::UNO_QUERY );
+    }
+    catch( uno::Exception & )
+    {
+        DBG_ERROR1( "Warning: %s is not a recognized type\n", OUSTRING_CSTR( name ) );
+        return uno::Reference< awt::XLayoutConstrains >();
+    }
+
+#if 0 // This shadows the show="false" property and seems otherwise
+      // unnecessary
+
+    // default to visible, let then people change it on properties
+    if ( ! bToplevel )
+    {
+        uno::Reference< awt::XWindow> xWindow( xPeer, uno::UNO_QUERY );
+        if ( xWindow.is() )
+            xWindow->setVisible( true );
+    }
+#endif
+
+    return xPeer;
+}
+
+uno::Reference< awt::XLayoutConstrains >
+WidgetFactory::createWidget (uno::Reference< awt::XToolkit > xToolkit, uno::Reference< uno::XInterface > xParent, OUString const& name, long properties)
+{
+    uno::Reference< awt::XLayoutConstrains > xPeer;
+
+    xPeer = uno::Reference <awt::XLayoutConstrains> (createContainer (name), uno::UNO_QUERY);
+    if ( xPeer.is() )
+        return xPeer;
+
+    xPeer = implCreateWidget (xParent, name, properties);
+    if (xPeer.is ())
+        return xPeer;
+
+#define FIXED_INFO 1
+#if FIXED_INFO
+    OUString tName = name;
+    // FIXME
+    if ( name.equalsAscii( "fixedinfo" ) )
+        tName = OUString::createFromAscii( "fixedtext" );
+    xPeer = toolkitCreateWidget (xToolkit, xParent, tName, properties);
+#else
+    xPeer = toolkitCreateWidget (xToolkit, xParent, name, properties);
+#endif
+
+    return xPeer;
+}
+
+PropHelper::PropHelper() : LockHelper()
+                         , cppu::OPropertySetHelper( maBrdcstHelper )
+                         , pHelper( NULL )
+{
+}
+
+void
+PropHelper::addProp (const char *pName, sal_Int32 nNameLen, rtl_TextEncoding e,
+                     uno::Type aType, void *pPtr)
+{
+    // this sucks rocks for effiency ...
+    PropDetails aDetails;
+    aDetails.aName = rtl::OUString::intern( pName, nNameLen, e );
+    aDetails.aType = aType;
+    aDetails.pValue = pPtr;
+    maDetails.push_back( aDetails );
+}
+
+cppu::IPropertyArrayHelper & SAL_CALL
+PropHelper::getInfoHelper()
+{
+    if ( ! pHelper )
+    {
+        uno::Sequence< beans::Property > aProps( maDetails.size() );
+        for ( unsigned int i = 0; i < maDetails.size(); i++)
+        {
+            aProps[i].Name = maDetails[i].aName;
+            aProps[i].Type = maDetails[i].aType;
+            aProps[i].Handle = i;
+            aProps[i].Attributes = 0;
+        }
+        pHelper = new cppu::OPropertyArrayHelper( aProps, false /* fixme: faster ? */ );
+
+    }
+    return *pHelper;
+}
+
+sal_Bool SAL_CALL
+PropHelper::convertFastPropertyValue(
+    uno::Any & rConvertedValue,
+    uno::Any & rOldValue,
+    sal_Int32 nHandle,
+    const uno::Any& rValue )
+    throw (lang::IllegalArgumentException)
+{
+    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
+
+    // FIXME: no Any::getValue ...
+    getFastPropertyValue( rOldValue, nHandle );
+    if ( rOldValue != rValue )
+    {
+        rConvertedValue = rValue;
+        return sal_True; // changed
+    }
+    else
+    {
+        rConvertedValue.clear();
+        rOldValue.clear();
+    }
+    return sal_False;
+}
+
+
+void SAL_CALL
+PropHelper::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle,
+                                              const uno::Any& rValue )
+    throw (uno::Exception)
+{
+    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
+
+    const PropDetails &rInfo = maDetails[ nHandle ];
+
+    uno_type_assignData( rInfo.pValue, rInfo.aType.getTypeLibType(),
+                         rValue.pData, rValue.pType,
+                         0, 0, 0 );
+
+    if ( mpListener )
+        mpListener->propertiesChanged();
+}
+
+void SAL_CALL
+PropHelper::getFastPropertyValue( uno::Any& rValue,
+                                  sal_Int32 nHandle ) const
+{
+    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
+    const PropDetails &rInfo = maDetails[ nHandle ];
+#if 0
+    switch ( rInfo.aType.getTypeClass() )
+    {
+#define MAP(classtype,ctype)                        \
+        case uno::TypeClass_##classtype:       \
+            rValue <<= *(ctype *)(rInfo.pValue);    \
+        break
+        MAP( DOUBLE, double );
+        MAP( SHORT, sal_Int16 );
+        MAP( LONG,  sal_Int32 );
+        MAP( UNSIGNED_SHORT, sal_uInt16 );
+        MAP( UNSIGNED_LONG, sal_uInt32 );
+        MAP( STRING, ::rtl::OUString );
+        default:
+            DBG_ERROR( "ERROR: unknown type to map!" );
+            break;
+    }
+#undef MAP
+#endif
+    rValue.setValue( rInfo.pValue, rInfo.aType );
+}
+
+::com::sun::star::uno::Any
+PropHelper::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
+{
+    return OPropertySetHelper::queryInterface( rType );
+}
+
+} // namespace layoutimpl
+
+#include <awt/vclxbutton.hxx>
+#include <awt/vclxdialog.hxx>
+#include <awt/vclxfixedline.hxx>
+#include <awt/vclxplugin.hxx>
+#include <awt/vclxscroller.hxx>
+#include <awt/vclxsplitter.hxx>
+#include <awt/vclxtabcontrol.hxx>
+#include <awt/vclxtabpage.hxx>
+#include <toolkit/awt/vclxtoolkit.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <vcl/button.hxx>
+#include <vcl/dialog.hxx>
+#include <vcl/fixed.hxx>
+#include <vcl/tabctrl.hxx>
+#include <vcl/tabpage.hxx>
+#include <vcl/unohelp.hxx>
+
+#include <layout/layout.hxx>
+#include <toolkit/awt/vclxwindows.hxx>
+#include <vcl/lstbox.hxx>
+#include <vcl.hxx>
+
+#include <typeinfo>
+
+namespace layoutimpl
+{
+
+uno::Reference <awt::XLayoutConstrains> WidgetFactory::implCreateWidget (uno::Reference <uno::XInterface> xParent, OUString name, long attributes)
+{
+    Window* parent = 0;
+
+    if (VCLXWindow* parentComponent = VCLXWindow::GetImplementation (xParent))
+        parent = parentComponent->GetWindow ();
+
+    VCLXWindow* component = 0;
+    Window* window = 0; //sfx2CreateWindow (&component, parent, name, attributes);
+    if (!window)
+        window = layoutCreateWindow (&component, parent, name, attributes);
+
+    uno::Reference <awt::XLayoutConstrains> reference;
+    if (window)
+    {
+        window->SetCreatedWithToolkit( sal_True );
+        if ( component )
+            component->SetCreatedWithToolkit( true );
+        reference = component;
+        window->SetComponentInterface( component );
+        if ( attributes & awt::WindowAttribute::SHOW )
+            window->Show();
+    }
+
+    return reference;
+}
+
+extern "C" { static void SAL_CALL thisModule() {} }
+
+Window* WidgetFactory::sfx2CreateWindow (VCLXWindow** component, Window* parent, OUString const& name, long& attributes)
+{
+    OSL_TRACE("Asking sfx2: %s", OUSTRING_CSTR (name));
+
+	if (!mSfx2Library)
+	{
+		OUString libraryName = ::vcl::unohelper::CreateLibraryName ("sfx", TRUE);
+        mSfx2Library = osl_loadModuleRelative (&thisModule, libraryName.pData, SAL_LOADMODULE_DEFAULT);
+        if (mSfx2Library)
+        {
+            OUString functionName (RTL_CONSTASCII_USTRINGPARAM ("CreateWindow"));
+            mSfx2CreateWidget = (WindowCreator) osl_getFunctionSymbol (mSfx2Library, functionName.pData);
+        }
+    }
+
+	if (mSfx2CreateWidget)
+		return mSfx2CreateWidget (component, name, parent, attributes);
+
+    return 0;
+}
+
+Window* WidgetFactory::layoutCreateWindow (VCLXWindow** component, Window *parent, OUString const& name, long& attributes)
+{
+    Window* window = 0;
+    
+    if (0)
+    {
+        ;
+    }
+    if ( name.equalsAscii( "dialog" ) )
+    {
+        if ( parent == NULL )
+            parent = DIALOG_NO_PARENT;
+        window = new Dialog( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXDialog();
+
+        attributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( name.equalsAscii( "modaldialog" ) )
+    {
+        if ( parent == NULL )
+            parent = DIALOG_NO_PARENT;
+        window = new ModalDialog( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXDialog();
+
+        attributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( name.equalsAscii( "modelessdialog" ) )
+    {
+        if ( parent == NULL )
+            parent = DIALOG_NO_PARENT;
+        window = new ModelessDialog (parent, ImplGetWinBits (attributes, 0));
+        *component = new layoutimpl::VCLXDialog();
+
+        attributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( name.equalsAscii( "sfxdialog" ) )
+    {
+        if ( parent == NULL )
+            parent = DIALOG_NO_PARENT;
+        window = new ClosingDialog (parent, ImplGetWinBits (attributes, 0));
+        *component = new layoutimpl::VCLXDialog();
+
+        attributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( name.equalsAscii( "sfxmodaldialog" ) )
+    {
+        if ( parent == NULL )
+            parent = DIALOG_NO_PARENT;
+        window = new ClosingModalDialog( parent,
+                                         ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXDialog();
+
+        attributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( name.equalsAscii( "sfxmodelessdialog" ) )
+    {
+        if ( parent == NULL )
+            parent = DIALOG_NO_PARENT;
+        window = new ClosingModelessDialog (parent, ImplGetWinBits (attributes, 0));
+        *component = new layoutimpl::VCLXDialog();
+
+        attributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( name.equalsAscii( "tabcontrol" ) )
+    {
+        window = new TabControl( parent, ImplGetWinBits( attributes, WINDOW_TABCONTROL ) );
+        *component = new layoutimpl::VCLXTabControl();
+    }
+    else if ( name.equalsAscii( "scroller" ) )
+    {
+        // used FixedImage because I just want some empty non-intrusive widget
+        window = new FixedImage( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXScroller();
+    }
+    else if ( name.equalsAscii( "hsplitter" ) || name.equalsAscii( "vsplitter" ) )
+    {
+        window = new FixedImage( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXSplitter( name.equalsAscii( "hsplitter" ) );
+    }
+    else if ( name.equalsAscii( "hfixedline" ) || name.equalsAscii( "vfixedline" ) )
+    {
+        WinBits nStyle = ImplGetWinBits( attributes, 0 );
+        nStyle ^= WB_HORZ;
+        if ( name.equalsAscii( "hfixedline" ) )
+            nStyle |= WB_HORZ;
+        else
+            nStyle |= WB_VERT;
+        window = new FixedLine( parent, nStyle );
+        *component = new layoutimpl::VCLXFixedLine();
+    }
+    else if ( name.equalsAscii( "okbutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXOKButton( window );
+        window->SetType (WINDOW_OKBUTTON);
+    }
+    else if ( name.equalsAscii( "cancelbutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXCancelButton( window );
+        window->SetType (WINDOW_CANCELBUTTON);
+    }
+    else if ( name.equalsAscii( "yesbutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXYesButton( window );
+        window->SetType (WINDOW_OKBUTTON);
+    }
+    else if ( name.equalsAscii( "nobutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        window->SetType (WINDOW_CANCELBUTTON);
+        *component = new layoutimpl::VCLXNoButton( window );
+    }
+    else if ( name.equalsAscii( "retrybutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXRetryButton( window );
+    }
+    else if ( name.equalsAscii( "ignorebutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXIgnoreButton( window );
+    }
+    else if ( name.equalsAscii( "resetbutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXResetButton( window );
+    }
+    else if ( name.equalsAscii( "applybutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXApplyButton( window );
+    }
+    else if ( name.equalsAscii( "helpbutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXHelpButton( window );
+        window->SetType (WINDOW_HELPBUTTON);
+    }
+    else if ( name.equalsAscii( "morebutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXMoreButton( window );
+        window->SetType (WINDOW_MOREBUTTON);
+    }
+    else if ( name.equalsAscii( "advancedbutton" ) )
+    {
+        window = new PushButton( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::VCLXAdvancedButton( window );
+    }
+    else if ( name.equalsAscii( "plugin" ) )
+    {
+        window = new Control( parent, ImplGetWinBits( attributes, 0 ) );
+        OSL_TRACE( "%s: parent=%p (%s)\n", __FUNCTION__, parent, typeid( *parent ).name() );
+        *component = new layoutimpl::VCLXPlugin( window, ImplGetWinBits( attributes, 0 ) );
+    }
+    else if ( name.equalsAscii( "tabpage" ) )
+    {
+#if 0
+        if ( !parent )
+            parent = layout::TabPage::global_parent;
+#else
+        if (layout::TabPage::global_parent)
+            parent = layout::TabPage::global_parent;
+        layout::TabPage::global_parent = 0;
+#endif        
+        //window = new TabPage( parent, ImplGetWinBits( attributes, 0 ) );
+        attributes ^= awt::WindowAttribute::SHOW;
+        WinBits nStyle = ImplGetWinBits( attributes, 0 );
+        nStyle |= WB_HIDE;
+        //nStyle |= WB_NODIALOGCONTROL;
+        //nStyle |= WB_DIALOGCONTROL;
+        //nStyle = 2147483714L;
+        OSL_TRACE( "in bits=%lu", nStyle );
+        window = new TabPage( parent, nStyle );
+        *component = new VCLXTabPage( window );
+    }
+    else if ( name.equalsAscii( "string" ) )
+    {
+        // FIXME: move <string>s.text to simple map<string> in root?
+        attributes &= ~awt::WindowAttribute::SHOW;
+        window = new Window( parent, ImplGetWinBits( attributes, 0 ) );
+        *component = new layoutimpl::LocalizedString();
+    }
+#if 0 // parent paranoia
+    else if ( name.equalsAscii( "listbox" ) )
+    {
+        attributes |= awt::VclWindowPeerAttribute::DROPDOWN;
+        WinBits nStyle = ImplGetWinBits( attributes, 0 );
+        nStyle |= WB_DROPDOWN;
+        window = new ListBox( parent, nStyle );
+        *component = new VCLXListBox ();
+    }
+#endif
+    return window;
+}
+
+} // namespace layoutimpl
+
+// Avoid polluting the rest of the code with vcl linkage pieces ...
+
+#include <vcl/imagerepository.hxx>
+#include <vcl/bitmapex.hxx>
+#include <vcl/graph.hxx>
+
+namespace layoutimpl
+{
+
+uno::Reference< graphic::XGraphic > loadGraphic( const char *pName )
+{
+    BitmapEx aBmp;
+
+    OUString aStr( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US );
+    if ( aStr.compareToAscii( ".uno:" ) == 0 )
+        aStr = aStr.copy( 5 ).toAsciiLowerCase();
+
+    if ( !vcl::ImageRepository::loadImage( OUString::createFromAscii( pName ), aBmp, true ) )
+        return uno::Reference< graphic::XGraphic >();
+
+    return Graphic( aBmp ).GetXGraphic();
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/helper.hxx b/toolkit/source/layout/core/helper.hxx
new file mode 100644
index 0000000..806efd0
--- /dev/null
+++ toolkit/source/layout/core/helper.hxx
@@ -0,0 +1,163 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_HELPER_HXX
+#define LAYOUT_CORE_HELPER_HXX
+
+#include <toolkit/dllapi.h>
+#include <vector>
+
+#include <com/sun/star/awt/XLayoutConstrains.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/xml/input/XRoot.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/propshlp.hxx>
+#include <osl/module.h>
+#include <rtl/ustring.hxx>
+
+class Window;
+class VCLXWindow;
+extern "C"
+{
+	typedef Window* (SAL_CALL *WindowCreator) (VCLXWindow** component, rtl::OUString const& name, Window* parent, long& attributes);
+}
+
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+
+/* ChildProps -- a helper to set child properties for the XLayoutContainer interface. */
+
+class LockHelper
+{
+public:
+    osl::Mutex               maGuard;
+    cppu::OBroadcastHelper maBrdcstHelper;
+    LockHelper() : maBrdcstHelper( maGuard )
+    {
+    }
+};
+
+class PropHelper : public LockHelper
+                 , public cppu::OPropertySetHelper
+                 , public cppu::OWeakObject
+{
+    cppu::OPropertyArrayHelper *pHelper;
+
+    struct PropDetails
+    {
+        rtl::OUString  aName;
+        css::uno::Type aType;
+        void          *pValue;
+    };
+    std::vector< PropDetails > maDetails;
+
+protected:
+    void addProp( char const *pName, sal_Int32 nNameLen, rtl_TextEncoding e,
+                  css::uno::Type aType, void *pPtr );
+
+public:
+    PropHelper();
+
+    // com::sun::star::uno::XInterface
+    void SAL_CALL acquire() throw() { OWeakObject::acquire(); }
+    void SAL_CALL release() throw() { OWeakObject::release(); }
+    ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
+
+    // cppu::OPropertySetHelper
+    virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
+    virtual sal_Bool SAL_CALL convertFastPropertyValue( css::uno::Any &,
+                                                        css::uno::Any &, sal_Int32 nHandle, const css::uno::Any & )
+        throw(css::lang::IllegalArgumentException);
+    virtual void SAL_CALL setFastPropertyValue_NoBroadcast( sal_Int32 nHandle,
+                                                            const css::uno::Any& rValue ) throw (css::uno::Exception);
+    using OPropertySetHelper::getFastPropertyValue;
+    virtual void SAL_CALL getFastPropertyValue( css::uno::Any& rValue,
+                                                sal_Int32 nHandle ) const;
+
+    // you -must- use this macro in sub-classes that define new properties.
+    // NB. 'static' ...
+    // com::sun::star::beans::XMultiPropertySet
+#define PROPHELPER_SET_INFO \
+    css::uno::Reference< css::beans::XPropertySetInfo > SAL_CALL \
+    getPropertySetInfo() throw(css::uno::RuntimeException) \
+    { \
+        static css::uno::Reference< css::beans::XPropertySetInfo > xInfo( \
+            createPropertySetInfo( getInfoHelper() ) ); \
+        return xInfo; \
+    }
+    PROPHELPER_SET_INFO
+
+    struct Listener
+    {
+        virtual void propertiesChanged() = 0;
+    };
+    void setChangeListener( Listener *pListener )
+    {
+        mpListener = pListener;
+    }
+
+protected:
+    Listener *mpListener;
+};
+
+css::uno::Any anyFromString (const rtl::OUString &value, const css::uno::Type &type);
+
+// The native widgets wrapper hierarchy may not reflect that of the layout
+// hierarchy as some containers don't have an associated native widget.
+// Use this function to get the native parent of the given peer.
+css::uno::Reference< css::awt::XWindowPeer >
+getParent( css::uno::Reference< css::uno::XInterface > xPeer );
+
+class TOOLKIT_DLLPUBLIC WidgetFactory
+{
+public:
+	static oslModule mSfx2Library;
+	static WindowCreator mSfx2CreateWidget;
+
+    // Should use UNO services in due course
+    static css::uno::Reference <css::awt::XLayoutConstrains> toolkitCreateWidget (css::uno::Reference <css::awt::XToolkit> xToolkit, css::uno::Reference <css::uno::XInterface> xParent, rtl::OUString const& name, long properties);
+    static css::uno::Reference< css::awt::XLayoutConstrains > createWidget( css::uno::Reference <css::awt::XToolkit > xToolkit, css::uno::Reference< css::uno::XInterface > xParent, rtl::OUString const &name, long properties);
+    static css::uno::Reference <css::awt::XLayoutContainer> createContainer (rtl::OUString const& name);
+    static css::uno::Reference <css::awt::XLayoutConstrains> implCreateWidget (css::uno::Reference <css::uno::XInterface> xParent, rtl::OUString name, long attributes);
+    static Window* sfx2CreateWindow (VCLXWindow** component, Window* parent, rtl::OUString const& name, long& attributes);
+    static Window* layoutCreateWindow (VCLXWindow** component, Window *parent, rtl::OUString const& name, long& attributes);
+};
+
+
+css::uno::Reference< css::graphic::XGraphic > loadGraphic( const char *pName );
+
+} // end namespace layoutimpl
+
+#endif /* LAYOUT_CORE_HELPER_HXX */
diff --git a/toolkit/source/layout/core/import.cxx b/toolkit/source/layout/core/import.cxx
new file mode 100644
index 0000000..64ffb33
--- /dev/null
+++ toolkit/source/layout/core/import.cxx
@@ -0,0 +1,340 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "import.hxx"
+
+#include <com/sun/star/awt/XButton.hpp>
+#include <com/sun/star/awt/XDialog2.hpp>
+#include <vcl/image.hxx>
+#include <tools/debug.hxx>
+#include <layout/layout.hxx>
+
+#include "root.hxx"
+#include "helper.hxx"
+#include "dialogbuttonhbox.hxx"
+
+
+#define XMLNS_LAYOUT_URI    "http://openoffice.org/2007/layout"
+#define XMLNS_CONTAINER_URI "http://openoffice.org/2007/layout/container"
+
+namespace layoutimpl
+{
+using namespace css;
+
+using ::rtl::OUString;
+
+ElementBase::~ElementBase()
+SAL_THROW( () )
+{
+    //delete mpImport;
+    //mpImport = 0;
+}
+
+//** parser
+WidgetElement::WidgetElement ( sal_Int32 nUid, const OUString &rName,
+                               uno::Reference <xml::input::XAttributes> const &attributes,
+                               ElementBase *pParent,
+                               ImportContext *pImport)
+SAL_THROW (())
+: ElementBase( nUid, rName, attributes, pParent, pImport )
+{
+    OUString name = rName.toAsciiLowerCase();
+
+    PropList aProps;
+    propsFromAttributes( attributes, aProps, pImport->XMLNS_LAYOUT_UID );
+
+    OUString aId;
+    findAndRemove( "id", aProps, aId );
+    OUString aLang;
+    findAndRemove( "xml-lang", aProps, aLang );
+
+    {
+//DEBUG
+        uno::Reference< awt::XLayoutConstrains > xParent;
+        if ( pParent )
+            xParent = ((WidgetElement *) pParent)->mpWidget->getPeer();
+
+
+        mpWidget = pImport->mrRoot.create( aId, name,
+                                           getAttributeProps( aProps ), uno::Reference< awt::XLayoutContainer >( xParent, uno::UNO_QUERY ) );
+
+    }
+
+    // TODO: handle with non-existing widgets
+
+    mpWidget->setProperties( aProps );
+
+    uno::Reference< awt::XDialog2 > xDialog( mpWidget->getPeer(), uno::UNO_QUERY );
+    if ( xDialog.is() )
+    {
+        OUString aTitle;
+        if ( findAndRemove( "title", aProps, aTitle ) )
+        {
+            OSL_TRACE("Setting title: %s", OUSTRING_CSTR( aTitle ) );
+            xDialog->setTitle( aTitle );
+        }
+        OUString aHelpId;
+        if ( findAndRemove( "help-id", aProps, aHelpId ) )
+        {
+            OSL_TRACE("Setting help-id: %s", OUSTRING_CSTR( aHelpId ) );
+            xDialog->setHelpId( aHelpId.toInt32 () );
+        }
+    } // DEBUG:
+    else if ( pParent == NULL )
+    {
+        DBG_ERROR( "Fatal error: top node isn't a dialog" );
+    }
+
+#if 0
+    // Hack moved to proplist.cxx
+    OUString aGraphic;
+    if ( findAndRemove( "graphic", aProps, aGraphic ) )
+        //if ( layout::FixedImage *i = dynamic_cast<layout::FixedImage *> ( mpWidget->getPeer().get() ) )
+        // FIXME: huh? XImageProducer::complete( XImageConsumer )
+        //i->setImage( Image( loadGraphic( OUSTRING_CSTR( aGraphic ) ) ) );
+        mpWidget->setProperty( OUString::createFromAscii( "graphic" ),
+                               loadGraphic( OUSTRING_CSTR( aGraphic ) ) );
+#endif
+
+    OUString aOrdering;
+    if ( findAndRemove( "ordering", aProps, aOrdering ) )
+        if ( DialogButtonHBox *b = dynamic_cast<DialogButtonHBox *> ( mpWidget->getPeer().get() ) )
+            b->setOrdering ( aOrdering );
+
+    bool bSetRadioGroup;
+    OUString aRadioGroup;
+    bSetRadioGroup = findAndRemove( "radiogroup", aProps, aRadioGroup );
+
+    mpWidget->setProperties( aProps );
+
+    // we need to add radio buttons to the group after their properties are
+    // set, so we can check if they should be the one selected by default or not.
+    // And the state changed event isn't fired when changing properties.
+
+    uno::Reference< awt::XRadioButton > xRadio( mpWidget->getPeer(), uno::UNO_QUERY );
+    if ( xRadio.is() )
+    {
+        if (!bSetRadioGroup)
+            aRadioGroup = OUString::createFromAscii ("default");
+        pImport->mxRadioGroups.addItem( aRadioGroup, xRadio );
+    }
+}
+
+WidgetElement::~WidgetElement()
+{
+    //delete mpWidget;
+    //mpWidget = 0;
+}
+
+uno::Reference <xml::input::XElement>
+WidgetElement::startChildElement ( sal_Int32 nUid, OUString const &name,
+                                   uno::Reference <xml::input::XAttributes> const &attributes )
+    throw( xml::sax::SAXException, uno::RuntimeException )
+{
+    // Adding a child to the widget
+    WidgetElement *pChild = new WidgetElement ( nUid, name, attributes, this, mpImport );
+
+    if ( !mpWidget->addChild( pChild->mpWidget ) )
+    {
+        DBG_ERROR2( "ERROR: cannot add %s to container %s, container full", OUSTRING_CSTR( name ), OUSTRING_CSTR( getLocalName() ) );
+        throw xml::sax::SAXException();
+    }
+
+    PropList aProps;
+    propsFromAttributes( attributes, aProps, mpImport->XMLNS_CONTAINER_UID );
+    mpWidget->setChildProperties( pChild->mpWidget, aProps );
+
+    return pChild;
+}
+
+// Support Ivo Hinkelmann's move label/text/title attribute to CONTENT
+// transex3 hack.
+void SAL_CALL
+WidgetElement::characters( OUString const& rChars )
+    throw (xml::sax::SAXException, uno::RuntimeException)
+{
+    if ( mpWidget && rChars.trim().getLength() )
+    {
+        uno::Reference< awt::XDialog2 > xDialog( mpWidget->getPeer(), uno::UNO_QUERY );
+        uno::Reference< awt::XButton > xButton( mpWidget->getPeer(), uno::UNO_QUERY );
+        if ( xDialog.is() )
+            xDialog->setTitle( rChars );
+        else if ( xButton.is() )
+            mpWidget->setProperty( OUString::createFromAscii( "label" ), rChars );
+        else
+            mpWidget->setProperty( OUString::createFromAscii( "text" ), rChars );
+    }
+}
+// ---- ElementBase ----
+
+ElementBase::ElementBase( sal_Int32 nUid, OUString const & rLocalName,
+                          uno::Reference< xml::input::XAttributes > const & xAttributes,
+                          ElementBase* pParent,
+                          ImportContext* pImport )
+SAL_THROW(())
+: mpImport( pImport )
+    , mpParent( pParent )
+    , mnUid( nUid )
+    , maLocalName( rLocalName )
+    , mxAttributes( xAttributes )
+{
+}
+
+// ---- ImportContext ----
+
+void ImportContext::startDocument(
+    uno::Reference< xml::input::XNamespaceMapping > const & xNamespaceMapping )
+    throw (xml::sax::SAXException, uno::RuntimeException)
+{
+    XMLNS_LAYOUT_UID = xNamespaceMapping->getUidByUri(
+        OUString( RTL_CONSTASCII_USTRINGPARAM( XMLNS_LAYOUT_URI ) ) );
+    XMLNS_CONTAINER_UID = xNamespaceMapping->getUidByUri(
+        OUString( RTL_CONSTASCII_USTRINGPARAM( XMLNS_CONTAINER_URI ) ) );
+}
+
+ToplevelElement::ToplevelElement (OUString const &rName,
+                                  uno::Reference <xml::input::XAttributes> const &xAttributes,
+                                  ImportContext *pImport)
+SAL_THROW(())
+: WidgetElement( 0, rName, xAttributes, NULL, pImport )
+{
+}
+
+ToplevelElement::~ToplevelElement()
+{
+}
+
+uno::Reference< xml::input::XElement > ImportContext::startRootElement(
+    sal_Int32 nUid, OUString const & rLocalName,
+    uno::Reference< xml::input::XAttributes > const & xAttributes )
+    throw (xml::sax::SAXException, uno::RuntimeException)
+{
+    if ( XMLNS_LAYOUT_UID != nUid )
+        throw xml::sax::SAXException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "invalid namespace!" ) ),
+            uno::Reference< uno::XInterface >(), uno::Any() );
+        return new ToplevelElement( rLocalName, xAttributes, this );
+}
+
+RadioGroups::RadioGroups()
+{
+}
+
+void RadioGroups::addItem( rtl::OUString id, uno::Reference< awt::XRadioButton > xRadio )
+    throw (uno::RuntimeException)
+{
+    if ( ! xRadio.is() )
+        throw uno::RuntimeException();
+    
+    uno::Reference< RadioGroup > group;
+    RadioGroupsMap::iterator it = mxRadioGroups.find( id );
+    if ( it == mxRadioGroups.end() )
+    {
+        group = uno::Reference< RadioGroup > ( new RadioGroup() );
+        mxRadioGroups [id] = group;
+    }
+    else
+        group = it->second;
+    group->addItem( xRadio );
+}
+
+RadioGroups::RadioGroup::RadioGroup()
+{
+}
+
+void RadioGroups::RadioGroup::addItem( uno::Reference< awt::XRadioButton > xRadio )
+{
+    if ( ! mxSelectedRadio.is() )
+    {
+        xRadio->setState( true );
+        mxSelectedRadio = xRadio;
+    }
+    else if ( xRadio->getState() )
+    {
+#if 1
+        xRadio->setState( false );
+#else // huh, why select last added?
+      mxSelectedRadio->setState( false );
+      mxSelectedRadio = xRadio;
+#endif
+    }
+
+    // TOO late: actionPerformed is called before itemStateChanged.
+    // If client code (wrongly?) uses actionPerformed, it will see
+    // the previous RadioButtons' state.
+    xRadio->addItemListener( this );
+
+    uno::Reference< awt::XButton > xButton = uno::Reference< awt::XButton > ( xRadio, uno::UNO_QUERY );
+    xButton->addActionListener( this );
+
+    mxRadios.push_back (xRadio);
+}
+
+void RadioGroups::RadioGroup::handleSelected ()
+    throw (uno::RuntimeException)
+{
+    for ( RadioButtonsList::iterator it = mxRadios.begin();
+          it != mxRadios.end(); it++ )
+        if ( *it != mxSelectedRadio && (*it)->getState() )
+        {
+            mxSelectedRadio->setState( false );
+            mxSelectedRadio = *it;
+            break;
+        }
+}
+
+// awt::XItemListener
+void RadioGroups::RadioGroup::itemStateChanged( const awt::ItemEvent& e )
+    throw (uno::RuntimeException)
+{
+    // TOO late: actionPerformed is called before itemStateChanged.
+    // If client code (wrongly?) uses actionPerformed, it will see
+    // the previous RadioButtons' state.
+
+    // Need this for initialization, though.
+    if ( e.Selected )
+        handleSelected ();
+}
+
+// awt::XActionListener
+void RadioGroups::RadioGroup::actionPerformed( const awt::ActionEvent& )
+    throw (uno::RuntimeException)
+{
+    handleSelected ();
+}
+
+// lang::XEventListener
+void SAL_CALL RadioGroups::RadioGroup::disposing( const lang::EventObject& )
+    throw (uno::RuntimeException)
+{
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/import.hxx b/toolkit/source/layout/core/import.hxx
new file mode 100644
index 0000000..7968f32
--- /dev/null
+++ toolkit/source/layout/core/import.hxx
@@ -0,0 +1,263 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_IMPORT_HXX
+#define LAYOUT_CORE_IMPORT_HXX
+
+#include <map>
+#include <list>
+#define _BACKWARD_BACKWARD_WARNING_H 1
+#include <hash_map>
+
+
+#include <com/sun/star/xml/input/XRoot.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/awt/XButton.hpp>
+#include <com/sun/star/awt/XRadioButton.hpp>
+
+namespace layoutimpl
+{
+class LayoutRoot;
+class LayoutWidget;
+namespace css = ::com::sun::star;
+
+class RadioGroups
+{
+public:
+    RadioGroups();
+
+    void addItem( rtl::OUString id, css::uno::Reference< css::awt::XRadioButton > xRadio )
+        throw (css::uno::RuntimeException);
+
+private:
+    class RadioGroup : public ::cppu::WeakImplHelper1< css::awt::XItemListener >
+        , public ::cppu::WeakImplHelper1< css::awt::XActionListener >
+    {
+    public:
+        RadioGroup();
+        void addItem( css::uno::Reference< css::awt::XRadioButton > xRadio );
+
+    private:
+        typedef std::list< css::uno::Reference< css::awt::XRadioButton > > RadioButtonsList;
+        RadioButtonsList mxRadios;
+        css::uno::Reference< css::awt::XRadioButton > mxSelectedRadio;
+
+        void handleSelected ()
+            throw (css::uno::RuntimeException);
+
+        // awt::XItemListener
+        void SAL_CALL itemStateChanged( const css::awt::ItemEvent& e )
+            throw (css::uno::RuntimeException);
+
+        // awt::XActionListener
+        void SAL_CALL actionPerformed( const css::awt::ActionEvent& e )
+            throw (css::uno::RuntimeException);
+
+        // lang::XEventListener
+        void SAL_CALL disposing( const css::lang::EventObject& )
+            throw (css::uno::RuntimeException);
+    };
+
+    // each RadioGroup will stay alive after RadioGroups die with the ImportContext
+    // because they are referenced by every XRadioButton through the listener
+    typedef std::map< rtl::OUString, css::uno::Reference< RadioGroup > > RadioGroupsMap;
+    RadioGroupsMap mxRadioGroups;
+};
+
+#if 0
+// generator
+class Widget
+{
+public:
+    Widget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+            css::uno::Reference< css::awt::XWindow > xToplevel,
+            rtl::OUString unoName, long attrbs );
+    virtual ~Widget();
+
+    virtual void setProperties( const PropList &rProps );
+
+    virtual bool addChild( Widget *pChild );
+    virtual void setChildProperties( Widget *pChild, const PropList &rProps );
+
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getPeer()
+    { return mxWidget; }
+
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getContainer()
+    { return mxContainer; }
+
+protected:
+    css::uno::Reference< css::awt::XLayoutConstrains > mxWidget;
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+};
+
+class Root
+{
+public:
+    Root( css::uno::Reference< css::awt::XToolkit > xToolkit )
+        : mxToolkit( xToolkit ) {}
+    ~Root();
+
+    virtual Widget *create( rtl::OUString id, const rtl::OUString unoName, long attrbs );
+
+    css::uno::Reference< css::awt::XLayoutConstrains > getById( rtl::OUString id );
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getToplevel();
+
+protected:
+    css::uno::Reference< css::awt::XToolkit > mxToolkit;
+    Widget *mpToplevel;
+
+    typedef std::hash_map< rtl::OUString, css::uno::Reference< css::awt::XLayoutConstrains >,
+                           rtl::OUStringHash > ItemHash;
+    ItemHash maItems;
+};
+#endif
+
+// parser
+class ImportContext : public ::cppu::WeakImplHelper1< css::xml::input::XRoot >
+{
+public:
+    sal_Int32 XMLNS_LAYOUT_UID, XMLNS_CONTAINER_UID;
+    LayoutRoot &mrRoot; // switch to XNameContainer ref ?
+    RadioGroups mxRadioGroups;
+
+    inline ImportContext( LayoutRoot &rRoot ) SAL_THROW( () )
+        : mrRoot( rRoot ) {}
+    virtual ~ImportContext() {}
+
+    // XRoot
+    virtual void SAL_CALL startDocument(
+        css::uno::Reference< css::xml::input::XNamespaceMapping >
+        const & xNamespaceMapping )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endDocument()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL processingInstruction(
+        ::rtl::OUString const & /* rTarget */, ::rtl::OUString const & /* rData */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL setDocumentLocator(
+        css::uno::Reference< css::xml::sax::XLocator > const & /* xLocator */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startRootElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes > const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+};
+
+class ElementBase : public ::cppu::WeakImplHelper1< css::xml::input::XElement >
+{
+protected:
+    ImportContext *mpImport;
+/* TODO: check if all this memebers are needed. */
+    ElementBase   *mpParent;
+    sal_Int32      mnUid;
+
+    ::rtl::OUString maLocalName;
+    css::uno::Reference< css::xml::input::XAttributes > mxAttributes;
+public:
+    ElementBase(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, ImportContext * pImport )
+    SAL_THROW( () );
+    virtual ~ElementBase() SAL_THROW(());
+
+    // XElement
+    virtual css::uno::Reference<css::xml::input::XElement> SAL_CALL getParent()
+        throw (css::uno::RuntimeException)
+    { return static_cast< css::xml::input::XElement * >( mpParent ); }
+    virtual ::rtl::OUString SAL_CALL getLocalName() throw (css::uno::RuntimeException)
+    { return maLocalName; }
+    virtual sal_Int32 SAL_CALL getUid() throw (css::uno::RuntimeException)
+    { return mnUid; }
+    virtual css::uno::Reference< css::xml::input::XAttributes >
+    SAL_CALL getAttributes() throw (css::uno::RuntimeException)
+    { return mxAttributes; }
+
+    virtual void SAL_CALL ignorableWhitespace(
+        ::rtl::OUString const & /* rWhitespaces */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL characters( ::rtl::OUString const & /* rChars */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL processingInstruction(
+        ::rtl::OUString const & /* Target */, ::rtl::OUString const & /* Data */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes > const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException) = 0;
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+};
+
+class WidgetElement : public ElementBase
+{
+protected:
+    LayoutWidget *mpWidget;
+
+public:
+    WidgetElement( sal_Int32 nUid, rtl::OUString const &name,
+                   css::uno::Reference< css::xml::input::XAttributes > const &attributes,
+                   ElementBase *parent, ImportContext *import ) SAL_THROW (());
+
+    ~WidgetElement();
+
+
+    virtual css::uno::Reference< css::xml::input::XElement> SAL_CALL
+    startChildElement (sal_Int32 id, rtl::OUString const &name,
+                       css::uno::Reference< css::xml::input::XAttributes > const &attributes)
+        throw( css::xml::sax::SAXException, css::uno::RuntimeException );
+    virtual void SAL_CALL characters( ::rtl::OUString const & /* rChars */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+};
+
+class ToplevelElement : public WidgetElement
+{
+public:
+    ToplevelElement( rtl::OUString const &name,
+                     css::uno::Reference< css::xml::input::XAttributes > const &attributes,
+                     ImportContext *import ) SAL_THROW (());
+    ~ToplevelElement();
+};
+
+
+} // namespace layoutimpl
+
+#endif /* LAYOUT_CORE_IMPORT_HXX */
diff --git a/toolkit/source/layout/core/localized-string.cxx b/toolkit/source/layout/core/localized-string.cxx
new file mode 100644
index 0000000..9bc9df3
--- /dev/null
+++ toolkit/source/layout/core/localized-string.cxx
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 51 Franklin Street, 5th Floor, Boston,
+ *    MA  02110-1301  USA
+ *
+ ************************************************************************/
+
+#include "localized-string.hxx"
+
+#include <toolkit/helper/property.hxx>
+#include <vcl/window.hxx>
+
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+using namespace css;
+using rtl::OUString;
+
+LocalizedString::LocalizedString()
+    : VCLXWindow()
+{
+}
+
+void LocalizedString::ImplGetPropertyIds( std::list< sal_uInt16 > &ids )
+{
+    PushPropertyIds( ids, BASEPROPERTY_TEXT, 0);
+    VCLXWindow::ImplGetPropertyIds( ids );
+}
+
+// XInterface
+uno::Any LocalizedString::queryInterface( uno::Type const& rType )
+    throw(uno::RuntimeException)
+{
+    uno::Any aRet = ::cppu::queryInterface( rType,
+                                            SAL_STATIC_CAST( awt::XFixedText*, this ) );
+    return (aRet.hasValue() ? aRet : VCLXWindow::queryInterface( rType ));
+}
+
+void LocalizedString::setText( OUString const& s )
+    throw(uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( Window *w = GetWindow() )
+        return w->SetText( s );
+}
+
+OUString LocalizedString::getText()
+    throw(uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( Window *w = GetWindow() )
+        return w->GetText();
+    return OUString();
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/localized-string.hxx b/toolkit/source/layout/core/localized-string.hxx
new file mode 100644
index 0000000..fc5fc85
--- /dev/null
+++ toolkit/source/layout/core/localized-string.hxx
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 51 Franklin Street, 5th Floor, Boston,
+ *    MA  02110-1301  USA
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_LOCALIZED_STRING_HXX
+#define LAYOUT_CORE_LOCALIZED_STRING_HXX
+
+#include <com/sun/star/awt/XFixedText.hpp>
+#include <toolkit/awt/vclxwindow.hxx>
+
+namespace layoutimpl
+{
+namespace css = ::com::sun::star;
+
+// FIXME: misuse XFixedText interface for simple string
+class LocalizedString :	public css::awt::XFixedText
+                      , public VCLXWindow
+{
+public:
+    LocalizedString();
+
+	// css::uno::XInterface
+    css::uno::Any SAL_CALL queryInterface( css::uno::Type const& rType )
+        throw(css::uno::RuntimeException);
+    void SAL_CALL acquire() throw() { OWeakObject::acquire(); }
+    void SAL_CALL release() throw() { OWeakObject::release(); }
+
+    // css::awt::XFixedText
+    void SAL_CALL setText( ::rtl::OUString const& s )
+        throw(css::uno::RuntimeException);
+    ::rtl::OUString SAL_CALL getText()
+        throw(css::uno::RuntimeException);
+    void SAL_CALL setAlignment( sal_Int16 )
+        throw(css::uno::RuntimeException) { } 
+    sal_Int16 SAL_CALL getAlignment()
+        throw(css::uno::RuntimeException) { return 0; }
+
+    // css::awt::XLayoutConstrains
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException) { return css::awt::Size( 0, 0 ); }
+    css::awt::Size SAL_CALL getPreferredSize()
+        throw(css::uno::RuntimeException) { return getMinimumSize(); }
+    css::awt::Size SAL_CALL calcAdjustedSize( css::awt::Size const& size )
+        throw(css::uno::RuntimeException) { return size; }
+
+    static void ImplGetPropertyIds( std::list< sal_uInt16 > &ids );
+    virtual void GetPropertyIds( std::list< sal_uInt16 > &ids )
+    { return ImplGetPropertyIds( ids ); }
+};
+
+} // namespace layoutimpl
+
+#endif /* LAYOUT_CORE_LOCALIZED_STRING_HXX */
diff --git a/toolkit/source/layout/core/makefile.mk b/toolkit/source/layout/core/makefile.mk
new file mode 100644
index 0000000..f6bd950
--- /dev/null
+++ toolkit/source/layout/core/makefile.mk
@@ -0,0 +1,70 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=../../..
+PRJNAME=toolkit
+TARGET=layout-core
+ENABLE_EXCEPTIONS=true
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE : settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(CCNUMVER)" >= "000400030000" && "$(CCNUMVER)" < "000400040000"
+CFLAGS+= -O1
+.ENDIF
+
+SLOFILES= \
+	$(SLO)$/bin.obj \
+	$(SLO)$/box-base.obj \
+	$(SLO)$/box.obj \
+	$(SLO)$/byteseq.obj \
+	$(SLO)$/container.obj \
+	$(SLO)$/dialogbuttonhbox.obj \
+	$(SLO)$/factory.obj \
+	$(SLO)$/flow.obj \
+	$(SLO)$/helper.obj \
+	$(SLO)$/import.obj \
+	$(SLO)$/localized-string.obj \
+	$(SLO)$/proplist.obj \
+	$(SLO)$/root.obj \
+	$(SLO)$/table.obj \
+	$(SLO)$/timer.obj \
+	$(SLO)$/translate.obj\
+	$(SLO)$/vcl.obj\
+#
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : target.mk
diff --git a/toolkit/source/layout/core/precompiled_xmlscript.hxx b/toolkit/source/layout/core/precompiled_xmlscript.hxx
new file mode 100644
index 0000000..60cd73d
--- /dev/null
+++ toolkit/source/layout/core/precompiled_xmlscript.hxx
@@ -0,0 +1,39 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+/*
+  xmlscript/source/xml_helper/xml_byteseq.cxx compile helper.
+
+  Avoid introducing a toolkit dependency on xmlscript.
+
+  It would be nice to modify xml_byteseq.cxx making it friendlier
+  to include.
+*/
diff --git a/toolkit/source/layout/core/proplist.cxx b/toolkit/source/layout/core/proplist.cxx
new file mode 100644
index 0000000..857bb51
--- /dev/null
+++ toolkit/source/layout/core/proplist.cxx
@@ -0,0 +1,459 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "proplist.hxx"
+
+#include <rtl/ustrbuf.hxx>
+#include <toolkit/dllapi.h>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <tools/debug.hxx>
+
+#include "helper.hxx"
+
+#if TEST_LAYOUT && !defined( DBG_UTIL )
+#include <cstdio>
+#undef DBG_ERROR
+#define DBG_ERROR printf
+#undef DBG_ERROR1
+#define DBG_ERROR1 printf
+#undef DBG_ERROR2
+#define DBG_ERROR2 printf
+#endif /* TEST_LAYOUT && !DBG_UTIL */
+
+namespace layoutimpl
+{
+
+using namespace com::sun::star;
+using rtl::OString;
+using rtl::OUString;
+using rtl::OUStringBuffer;
+
+namespace prophlp
+{
+
+bool TOOLKIT_DLLPUBLIC
+canHandleProps( const uno::Reference< uno::XInterface > &xPeer )
+{
+    uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+    if ( xPropSet.is() )
+        return true;
+    uno::Reference< beans::XPropertySetInfo > xInfo( xPeer, uno::UNO_QUERY );
+    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
+    return xInfo.is() && xVclPeer.is();
+}
+
+uno::Reference< beans::XPropertySetInfo > TOOLKIT_DLLPUBLIC
+queryPropertyInfo(
+    const uno::Reference< uno::XInterface > &xPeer )
+{
+    uno::Reference< beans::XPropertySetInfo > xInfo( xPeer, uno::UNO_QUERY );
+    if ( !xInfo.is() )
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+        if ( xPropSet.is() )
+            xInfo = xPropSet->getPropertySetInfo();
+    }
+    return xInfo;
+}
+
+void TOOLKIT_DLLPUBLIC
+setProperty( const uno::Reference< uno::XInterface > &xPeer,
+                  const OUString &rName, uno::Any aValue )
+{
+    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
+    if ( xVclPeer.is() )
+        xVclPeer->setProperty( rName, aValue );
+    else
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+        xPropSet->setPropertyValue( rName, aValue );
+    }
+}
+
+uno::Any TOOLKIT_DLLPUBLIC
+getProperty( const uno::Reference< uno::XInterface > &xPeer,
+                      const OUString &rName )
+{
+    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
+    if ( xVclPeer.is() )
+        return xVclPeer->getProperty( rName );
+
+    uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+    return xPropSet->getPropertyValue( rName );
+}
+
+} // namespace prophlp
+
+
+/* Given a string and a type, it converts the string to the type, and returns
+   it encapsulated in Any. */
+uno::Any anyFromString( OUString const& value, uno::Type const& type )
+{
+    sal_Int16 radix = 10;
+    OUString intval = value;
+    if ( value.getLength() > 2 && value[0] == '0' && value[1] == 'x' )
+        intval = value.copy( 2 ), radix = 16;
+    else if ( value.getLength() > 1 && value[0] == '#' )
+        intval = value.copy( 1 ), radix = 16;
+    switch ( type.getTypeClass() )
+    {
+        case uno::TypeClass_CHAR:
+            return uno::makeAny( value.toChar() );
+        case uno::TypeClass_BOOLEAN:
+            if ( value == OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) ) )
+                return uno::makeAny( true );
+            else if ( value == OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) ) )
+                return uno::makeAny( false );
+            break;  // ends switch, throws exception
+        case uno::TypeClass_BYTE:
+            return uno::makeAny( ( sal_uInt8 ) intval.toInt32( radix ) );
+        case uno::TypeClass_SHORT:
+            return uno::makeAny( ( sal_Int16 ) intval.toInt32( radix ) );
+        case uno::TypeClass_UNSIGNED_SHORT:
+            return uno::makeAny( ( sal_uInt16 ) intval.toInt32( radix ) );
+        case uno::TypeClass_ENUM:
+            return uno::makeAny( ( sal_Int16 ) intval.toInt32( radix ) );
+        case uno::TypeClass_LONG:
+            return uno::makeAny( ( sal_Int32 ) intval.toInt32( radix ) );
+        case uno::TypeClass_UNSIGNED_LONG:
+            return uno::makeAny( ( sal_uInt32 ) intval.toInt32( radix ) );
+        case uno::TypeClass_HYPER:
+            return uno::makeAny( ( sal_Int64 ) intval.toInt64( radix ) );
+        case uno::TypeClass_UNSIGNED_HYPER:
+            return uno::makeAny( ( sal_uInt16 ) intval.toInt64( radix ) );
+        case uno::TypeClass_FLOAT:
+            return uno::makeAny( value.toFloat() );
+        case uno::TypeClass_DOUBLE:
+            return uno::makeAny( value.toDouble() );
+        case uno::TypeClass_STRING:
+            return uno::makeAny( value );
+        case uno::TypeClass_CONSTANT:
+            return uno::makeAny( intval.toInt32( radix ) );
+        case uno::TypeClass_INTERFACE:
+            return uno::makeAny( loadGraphic( OUSTRING_CSTR( value ) ) );
+        case uno::TypeClass_SEQUENCE:
+        {
+            sal_Int32 i = 0;
+            bool escaped = false, first = true;
+            OUString item, token;
+            std::list< OUString > values;
+            do
+            {
+                token = value.getToken( 0, ':', i );
+
+                if ( !token.getLength() && !escaped )
+                {
+                    escaped = true;
+                    item += OUString( ':' );
+                }
+                else if ( escaped )
+                {
+                    escaped = false;
+                    item += token;
+                }
+                else
+                {
+                    if ( !first )
+                        values.push_back( item );
+                    item = token;
+                }
+                first = false;
+            }
+            while ( i >= 0 );
+            if ( item.getLength() )
+                values.push_back( item );
+
+            uno::Sequence< OUString > seq( values.size() );
+            i = 0;
+            for ( std::list< OUString >::const_iterator it = values.begin();
+                  it != values.end(); it++, i++ )
+                seq[ i ] = *it;
+
+            return uno::makeAny( seq );
+        }
+
+        default:
+            DBG_ERROR1( "ERROR: unknown property type of value: `%s'\n", OUSTRING_CSTR( value ) );
+            break;
+    }
+    throw uno::RuntimeException();
+}
+
+/* Converts the XML naming scheme to UNO's, for legacy compatibility
+   (so, ergo, "one-two-three-four" -> "OneTwoThreeFour"). */
+static OUString toUnoNaming ( OUString const &string )
+{
+    OUStringBuffer buffer( string.getLength() );
+    sal_Unicode *str = string.pData->buffer;
+    bool capitalize = true;
+
+    for ( int i = 0; i < string.getLength(); i++ )
+    {
+        if ( i == 0 && str[0] == '_' )
+            /* Skip translate-me prefix.  */
+            continue;
+        if ( str[i] == '-' )
+            capitalize = true;
+        else
+        {
+            if ( capitalize && str[i] >= 'a' && str[i] <= 'z' )
+                buffer.append( (sal_Unicode ) ( str[i] - 'a' + 'A' ) );
+            else
+                buffer.append( (sal_Unicode ) str[i] );
+            capitalize = false;
+        }
+    }
+
+    return buffer.makeStringAndClear();
+}
+
+/*
+ * convert incoming XML style property names, to AWT style property names.
+ * convert the values based on introspection information.
+ * apply to either an XPropertySet or an XPropertySetInfo | XVclWindowPeer
+ * aggregate.
+ */
+void
+setProperties( uno::Reference< uno::XInterface > const& xPeer,
+               PropList const& rProps )
+{
+    if ( !prophlp::canHandleProps( xPeer ) )
+    {
+        DBG_ERROR( "Error: setProperties - bad handle ignoring props:\n" );
+        for ( PropList::const_iterator it = rProps.begin(); it != rProps.end();
+              it++ )
+        {
+            DBG_ERROR2( "%s=%s\n", OUSTRING_CSTR( it->first ), OUSTRING_CSTR( it->second ) );
+        }
+        return;
+    }
+
+    for ( PropList::const_iterator it = rProps.begin(); it != rProps.end();
+          it++ )
+        setProperty( xPeer, it->first, it->second );
+}
+
+void
+setProperty( uno::Reference< uno::XInterface > const& xPeer,
+             OUString const& attr, OUString const& value )
+{
+    OUString unoAttr = toUnoNaming( attr );
+
+    OSL_TRACE( "setting %s=%s", OUSTRING_CSTR( attr ), OUSTRING_CSTR( value ) );
+    // get a Property object
+    beans::Property prop;
+    try
+    {
+        uno::Reference< beans::XPropertySetInfo > xInfo
+            = prophlp::queryPropertyInfo( xPeer );
+        prop = xInfo->getPropertyByName( unoAttr );
+    }
+    catch( beans::UnknownPropertyException & )
+    {
+        DBG_ERROR1( "Warning: unknown attribute: `%s'\n", OUSTRING_CSTR( unoAttr ) );
+        return;
+    }
+
+    if ( prop.Name.getLength() <= 0 )
+    {
+        DBG_ERROR1( "Warning: missing prop: `%s'\n", OUSTRING_CSTR( unoAttr ) );
+        return;
+    }
+
+    // encapsulates value in an uno::Any
+    uno::Any any;
+    try
+    {
+        any = anyFromString( value, prop.Type );
+    }
+    catch( uno::RuntimeException & )
+    {
+        DBG_ERROR5( "Warning: %s( %s )( %s ) attribute is of type %s( rejected: %s )\n", OUSTRING_CSTR( unoAttr ), OUSTRING_CSTR( value ), OUSTRING_CSTR( prop.Name ),  OUSTRING_CSTR( prop.Type.getTypeName() ), OUSTRING_CSTR( value ) );
+        return;
+    }
+
+    // sets value on property
+    try
+    {
+        prophlp::setProperty( xPeer, unoAttr, any );
+    }
+    catch( ... )
+    {
+        DBG_ERROR2( "Warning: cannot set attribute %s to %s \n", OUSTRING_CSTR( unoAttr ), OUSTRING_CSTR( value ) );
+    }
+}
+
+
+
+
+struct AttributesMap
+{
+    const char *name;
+    long value;
+    bool windowAttr;
+};
+static const AttributesMap attribsMap[] =
+{
+    { "autohscroll",  awt::VclWindowPeerAttribute::AUTOHSCROLL,  false },
+    { "autovscroll",  awt::VclWindowPeerAttribute::AUTOVSCROLL,  false },
+    { "center",       awt::VclWindowPeerAttribute::CENTER,       false },
+    { "clipchildren", awt::VclWindowPeerAttribute::CLIPCHILDREN, false },
+    { "closeable",    awt::WindowAttribute::CLOSEABLE,           true },
+    { "defbutton",    awt::VclWindowPeerAttribute::DEFBUTTON,    false },
+    { "dropdown",     awt::VclWindowPeerAttribute::DROPDOWN,     false },
+    { "fullsize",     awt::WindowAttribute::FULLSIZE,            true  }, //FIXME?
+    { "group",        awt::VclWindowPeerAttribute::GROUP,        false },
+    { "has_border",   awt::WindowAttribute::BORDER,              true },
+    { "hscroll",      awt::VclWindowPeerAttribute::HSCROLL,      false },
+    { "left",         awt::VclWindowPeerAttribute::LEFT,         false },
+    { "moveable",     awt::WindowAttribute::MOVEABLE,            true },
+    { "noborder",     awt::VclWindowPeerAttribute::NOBORDER,     false },
+    { "nolabel",      awt::VclWindowPeerAttribute::NOLABEL,      false },
+    { "optimumsize",  awt::WindowAttribute::OPTIMUMSIZE,         false },
+    { "readonly",     awt::VclWindowPeerAttribute::READONLY,     false },
+    { "right",        awt::VclWindowPeerAttribute::RIGHT,        false },
+    { "show",         awt::WindowAttribute::SHOW,                true },
+    { "sizeable",     awt::WindowAttribute::SIZEABLE,            true },
+    { "sort",         awt::VclWindowPeerAttribute::SORT,         false },
+    { "spin",         awt::VclWindowPeerAttribute::SPIN,         false },
+    { "vscroll",      awt::VclWindowPeerAttribute::VSCROLL,      false },
+
+    // cutting on OK, YES_NO_CANCEL and related obsite attributes...
+};
+static const int attribsMapLen = sizeof( attribsMap ) / sizeof( AttributesMap );
+
+#if 0
+long getAttribute( const OUString &rName, bool bTopWindow )
+{
+
+    int min = 0, max = attribsMapLen - 1, mid, cmp;
+    do
+    {
+        mid = min +( max - min )/2;
+        cmp = rName.compareToAscii( attribsMap[ mid ].name );
+        if ( cmp > 0 )
+            min = mid+1;
+        else if ( cmp < 0 )
+            max = mid-1;
+        else
+        {
+            if ( bTopWindow || attribsMap[ mid ].value )
+                return attribsMap[ mid ].windowAttr;
+            return 0;
+        }
+    }
+    while ( min <= max );
+    return 0;
+}
+#endif
+
+void propsFromAttributes( const uno::Reference<xml::input::XAttributes> & xAttributes,
+                          PropList &rProps, sal_Int32 nNamespace )
+{
+    sal_Int32 nAttrs = xAttributes->getLength();
+    for ( sal_Int32 i = 0; i < nAttrs; i++ )
+    {
+        if ( nNamespace != xAttributes->getUidByIndex( i ) )
+            continue;
+
+        std::pair< OUString, OUString > aElem
+            ( xAttributes->getLocalNameByIndex( i ),
+              xAttributes->getValueByIndex( i ) );
+
+        if ( aElem.first.getLength() > 0 ) // namespace bits ..
+            rProps.push_back( aElem );
+    }
+}
+
+bool
+findAndRemove( const char *pAttr, PropList &rProps, OUString &rValue )
+{
+    PropList::iterator it;
+    OUString aName = OUString::createFromAscii( pAttr );
+
+    for ( it = rProps.begin(); it != rProps.end(); it++ )
+    {
+        if ( it->first.equalsIgnoreAsciiCase( aName )
+             || it->first.equalsIgnoreAsciiCase( OUString::createFromAscii ("_") + aName ) )
+        {
+            rValue = it->second;
+            rProps.erase( it );
+            return true;
+        }
+    }
+    rValue = OUString();
+    return false;
+}
+
+long
+getAttributeProps( PropList &rProps )
+{
+    long nAttrs = 0;
+    OUString aValue;
+
+    OUString trueStr( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
+
+    if ( findAndRemove( "show", rProps, aValue ) &&
+         aValue.equalsIgnoreAsciiCase(
+             OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) ) ) )
+        ;
+    else
+        nAttrs |= awt::WindowAttribute::SHOW;
+
+    for ( int i = 0; i < attribsMapLen; i++ )
+    {
+        if ( findAndRemove( attribsMap[i].name, rProps, aValue ) )
+        {
+            if ( aValue.equalsIgnoreAsciiCase( trueStr ) )
+                nAttrs |= attribsMap[i].value;
+        }
+    }
+
+    if ( findAndRemove( "align", rProps, aValue ) )
+    {
+        sal_Int32 nVal = aValue.toInt32();
+
+        if ( nVal == 0 /* PROPERTY_ALIGN_LEFT */ )
+            nAttrs |= awt::VclWindowPeerAttribute::LEFT;
+        else if ( nVal == 1 /* PROPERTY_ALIGN_CENTER */ )
+            nAttrs |= awt::VclWindowPeerAttribute::CENTER;
+        else if ( nVal == 2 )
+            nAttrs |= awt::VclWindowPeerAttribute::RIGHT;
+    }
+
+    return nAttrs;
+}
+
+}
+
diff --git a/toolkit/source/layout/core/proplist.hxx b/toolkit/source/layout/core/proplist.hxx
new file mode 100644
index 0000000..6512ce5
--- /dev/null
+++ toolkit/source/layout/core/proplist.hxx
@@ -0,0 +1,95 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_PROPLIST_HXX
+#define LAYOUT_CORE_PROPLIST_HXX
+
+#include <com/sun/star/beans/XPropertySetInfo.hpp>
+#include <com/sun/star/xml/input/XAttributes.hpp>
+#include <list>
+#include <rtl/ustring.hxx>
+#include <toolkit/dllapi.h>
+\
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+
+typedef std::list< std::pair< rtl::OUString, rtl::OUString > > PropList;
+
+void propsFromAttributes( const css::uno::Reference<css::xml::input::XAttributes> & xAttributes,
+                          PropList &rProps, sal_Int32 nNamespace );
+
+void setProperties( css::uno::Reference< css::uno::XInterface > const& xPeer,
+                    PropList const& rProps);
+
+void setProperty( css::uno::Reference< css::uno::XInterface > const& xPeer,
+                  rtl::OUString const& attr, rtl::OUString const& value );
+
+long getAttributeProps( PropList &rProps );
+bool findAndRemove( const char *pAttr, PropList &rProps, rtl::OUString &rValue);
+
+// Helpers - unfortunately VCLXWindows don't implement XPropertySet
+// but containers do - these helpers help us to hide this
+namespace prophlp
+{
+
+// can we set properties on this handle ?
+bool TOOLKIT_DLLPUBLIC canHandleProps( const css::uno::Reference< css::uno::XInterface > &xRef );
+// if so which properties ?
+css::uno::Reference< css::beans::XPropertySetInfo > TOOLKIT_DLLPUBLIC queryPropertyInfo(
+    const css::uno::Reference< css::uno::XInterface > &xRef );
+// set / get ...
+void TOOLKIT_DLLPUBLIC setProperty( const css::uno::Reference< css::uno::XInterface > &xRef,
+                  const rtl::OUString &rName,
+                  css::uno::Any aValue );
+css::uno::Any TOOLKIT_DLLPUBLIC getProperty( const css::uno::Reference< css::uno::XInterface > &xRef,
+                           const rtl::OUString &rName );
+} // namespace prophlp
+
+} // namespace layoutimpl
+
+
+#if !OUSTRING_CSTR_PARANOIA
+#define OUSTRING_CSTR( str ) \
+    rtl::OUStringToOString( str, RTL_TEXTENCODING_ASCII_US ).getStr()
+#else
+
+inline char const* OUSTRING_CSTR( rtl::OUString const& str )
+{
+    rtl::OString *leak
+        = new rtl::OString (rtl::OUStringToOString (str, RTL_TEXTENCODING_ASCII_US));
+    return leak->getStr();
+}
+
+#endif
+
+#endif /* LAYOUT_CORE_PROPLIST_HXX */
diff --git a/toolkit/source/layout/core/root.cxx b/toolkit/source/layout/core/root.cxx
new file mode 100644
index 0000000..bb264f3
--- /dev/null
+++ toolkit/source/layout/core/root.cxx
@@ -0,0 +1,414 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "root.hxx"
+
+#include <cassert>
+#include <cstdio>
+
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/awt/XMessageBox.hpp>
+#include <com/sun/star/awt/MessageBoxButtons.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/awt/XMessageBoxFactory.hpp>
+#include <com/sun/star/xml/sax/SAXParseException.hpp>
+#include <com/sun/star/xml/sax/XParser.hpp>
+
+#include "helper.hxx"
+#include "import.hxx"
+#include "timer.hxx"
+#include "translate.hxx"
+
+namespace layoutimpl
+{
+
+using namespace css;
+using ::rtl::OUString;
+
+LayoutRoot::LayoutRoot( const uno::Reference< lang::XMultiServiceFactory >& xFactory )
+    : mbDisposed( sal_False )
+    , mxFactory( xFactory )
+    , mpListeners( NULL )
+    , mpToplevel( NULL )
+{
+    if ( !xFactory.is() )
+        throw uno::RuntimeException();
+    mxLayoutUnit = uno::Reference< awt::XLayoutUnit >( new LayoutUnit() );
+}
+
+LayoutRoot::~LayoutRoot()
+{
+// TODO: we want to delete the top level LayoutWidget...
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( !mbDisposed )
+    {
+        try
+        {
+            m_refCount++; // inhibit multiple destruction
+            dispose();
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+}
+
+void ShowMessageBox( uno::Reference< lang::XMultiServiceFactory > const& xFactory, uno::Reference< awt::XToolkit > xToolkit, OUString const& aTitle, OUString const& aMessage )
+{
+    uno::Reference< uno::XInterface > iDesktop = xFactory->createInstance
+        ( OUString::createFromAscii( "com.sun.star.frame.Desktop" ) );
+    uno::Reference< frame::XDesktop > xDesktop ( iDesktop, uno::UNO_QUERY );
+    uno::Reference< frame::XFrame > xFrame ( xDesktop->getCurrentFrame() );
+    uno::Reference< awt::XWindow > xContainerWindow( xFrame->getContainerWindow() );
+    uno::Reference< awt::XWindowPeer > xWindowPeer( xContainerWindow, uno::UNO_QUERY_THROW );
+    uno::Reference< awt::XMessageBoxFactory > xMessageBoxFactory( xToolkit, uno::UNO_QUERY );
+
+    awt::Rectangle aRectangle;
+    uno::Reference< awt::XMessageBox > xMessageBox
+        = xMessageBoxFactory->createMessageBox
+        ( xWindowPeer, aRectangle, OUString::createFromAscii( "errorbox" ),
+          awt::MessageBoxButtons::BUTTONS_OK, aTitle, aMessage );
+
+    if ( xMessageBox.is() )
+        xMessageBox->execute();
+    //FIXME: exceptions not caught and printed at top level??
+    //else
+    //printf( "%s\n", OUSTRING_CSTR( aMessage ) );
+}
+
+void LayoutRoot::error( OUString const& message )
+{
+    printf( "%s\n", OUSTRING_CSTR( message ) );
+    ShowMessageBox( mxFactory, mxToolkit,
+                    OUString::createFromAscii( "Fatal error" ),
+                    message );
+    throw uno::RuntimeException( message, uno::Reference< uno::XInterface >() );
+}
+
+// XInitialization
+void SAL_CALL LayoutRoot::initialize( const uno::Sequence< uno::Any >& aArguments )
+    throw ( uno::Exception,
+            uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed )
+        throw lang::DisposedException();
+
+    if ( mxContainer.is() ) // only 1 init ...
+        throw uno::Exception();
+
+    if ( !aArguments.getLength() )
+        throw lang::IllegalArgumentException();
+
+    OSL_ENSURE( aArguments.getLength() == 1, "Wrong arg count\n" );
+
+    OUString aXMLName;
+    if ( !( aArguments[0] >>= aXMLName ) )
+        throw lang::IllegalArgumentException();
+
+    uno::Reference< xml::sax::XParser > xParser
+        ( mxFactory->createInstance(
+            OUString::createFromAscii( "com.sun.star.xml.sax.Parser" ) ),
+          uno::UNO_QUERY );
+    OSL_ASSERT( xParser.is() );
+    if (! xParser.is())
+    {
+        throw uno::RuntimeException(
+            OUString::createFromAscii( "cannot create sax-parser component" ),
+            uno::Reference< uno::XInterface >() );
+    }
+
+    // FIXME: quite possibly we want to pass this in ...
+    uno::Reference< awt::XToolkit > xToolkit;
+
+    mxToolkit = uno::Reference< awt::XToolkit >(
+        mxFactory->createInstance(
+            OUString::createFromAscii( "com.sun.star.awt.Toolkit" ) ),
+        uno::UNO_QUERY );
+
+    if ( !mxToolkit.is() )
+        throw uno::RuntimeException(
+            OUString::createFromAscii( "failed to create toolkit!" ),
+            uno::Reference< uno::XInterface >() );
+
+    OUString aXMLFile = readRightTranslation( aXMLName );
+    uno::Reference< io::XInputStream > xStream = getFileAsStream( aXMLFile );
+    if (! xStream.is() )
+        error( OUString::createFromAscii( "Installation problem: cannot find XML file:" ) + aXMLName );
+
+    // error handler, entity resolver omitted
+
+    ImportContext *pCtx = new ImportContext( *this );
+
+    uno::Reference< xml::input::XRoot > xRoot( pCtx );
+    uno::Sequence < uno::Any > aArgs( 1 );
+    aArgs[0] <<= xRoot;
+    uno::Reference< xml::sax::XDocumentHandler > xDocHandler
+        (mxFactory->createInstanceWithArguments
+         ( OUString::createFromAscii( "com.sun.star.xml.input.SaxDocumentHandler" ),
+          aArgs ), uno::UNO_QUERY );
+
+    if (! xDocHandler.is() )
+        error( OUString::createFromAscii( "cannot find SAx handler for document type of:") + aXMLName );
+        
+    xParser->setDocumentHandler( xDocHandler );
+
+    xml::sax::InputSource source;
+    source.aInputStream = xStream;
+    source.sSystemId = OUString::createFromAscii( "virtual file" );
+
+    try
+    {
+        xParser->parseStream( source );
+    }
+    catch ( xml::sax::SAXParseException& e )
+    {
+        OUString c = OUString::createFromAscii( ":" );
+        error( aXMLName
+               + c + OUString::valueOf( e.LineNumber )
+               + c + OUString::valueOf( e.ColumnNumber )
+               + c + OUString::createFromAscii( "Sax parse error" ) );
+    }
+}
+
+// XLayoutContainer
+uno::Reference< awt::XLayoutContainer > LayoutRoot::getLayoutContainer() throw (uno::RuntimeException)
+{
+    return uno::Reference< awt::XLayoutContainer >();
+}
+
+// local helper ...
+void LayoutRoot::addItem( const OUString &rName,
+                          const uno::Reference< awt::XLayoutConstrains > &xRef )
+{
+    maItems[ rName ] = xRef;
+}
+
+// XNameAccess
+uno::Any SAL_CALL LayoutRoot::getByName( const OUString &rName )
+    throw ( container::NoSuchElementException,
+            lang::WrappedTargetException,
+            uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( mbDisposed )
+        throw lang::DisposedException();
+
+    uno::Reference< awt::XLayoutConstrains > xItem;
+    ItemHash::iterator i = maItems.find( rName );
+    if ( i != maItems.end() )
+        xItem = i->second;
+    return uno::makeAny( xItem );
+}
+
+sal_Bool SAL_CALL LayoutRoot::hasByName( const OUString &rName )
+    throw (uno::RuntimeException)
+{
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    ItemHash::iterator i = maItems.find( rName );
+    return i != maItems.end();
+}
+
+uno::Sequence< OUString > SAL_CALL LayoutRoot::getElementNames()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    uno::Sequence< OUString > aNames( maItems.size() );
+    sal_Int32 nPos = 0;
+
+    for ( ItemHash::const_iterator it = maItems.begin();
+          it != maItems.end(); it++ )
+        aNames[ nPos++ ] = it->first;
+
+    return aNames;
+}
+
+uno::Type SAL_CALL LayoutRoot::getElementType()
+    throw ( uno::RuntimeException )
+{
+    return getCppuType( ( const uno::Reference< awt::XLayoutConstrains >* )NULL );
+}
+
+sal_Bool SAL_CALL LayoutRoot::hasElements()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    return maItems.size() > 0;
+}
+
+// XComponent
+void SAL_CALL LayoutRoot::dispose()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    if ( mpListeners )
+    {
+
+        lang::EventObject aSource( static_cast< ::cppu::OWeakObject* >(this) );
+        mpListeners->disposeAndClear( aSource );
+        delete mpListeners;
+        mpListeners = NULL;
+    }
+
+    maItems.clear();
+    mbDisposed = sal_True;
+}
+
+void SAL_CALL LayoutRoot::addEventListener( const uno::Reference< lang::XEventListener >& xListener )
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    if ( !mpListeners )
+        mpListeners = new ::cppu::OInterfaceContainerHelper( maMutex );
+    mpListeners->addInterface( xListener );
+}
+
+void SAL_CALL LayoutRoot::removeEventListener( const uno::Reference< lang::XEventListener >& xListener )
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    if ( mpListeners )
+        mpListeners->removeInterface( xListener );
+}
+
+// builder
+
+LayoutWidget *LayoutRoot::create( OUString id, const OUString unoName, long attrbs,uno::Reference< awt::XLayoutContainer > xParent )
+{
+    LayoutWidget *pWidget = new LayoutWidget( mxToolkit, xParent, unoName, attrbs );
+    if ( !mpToplevel )
+    {
+        mpToplevel = pWidget;
+        mxWindow = uno::Reference< awt::XWindow >( pWidget->getPeer(), uno::UNO_QUERY );
+        mxContainer = pWidget->mxContainer;
+    }
+    if ( pWidget->mxContainer.is() )
+        pWidget->mxContainer->setLayoutUnit( mxLayoutUnit );
+    if ( id.getLength() )
+        maItems[ id ] = pWidget->getPeer();
+    return pWidget;
+}
+
+#if 0
+uno::Reference< awt::XLayoutConstrains > LayoutRoot::getToplevel()
+{
+    if ( mpToplevel )
+        return mpToplevel->getPeer();
+    return uno::Reference< awt::XLayoutConstrains > ();
+}
+
+uno::Reference< awt::XLayoutConstrains > LayoutRoot::getById( OUString id )
+{
+    uno::Reference< awt::XLayoutConstrains > rRef = 0;
+    ItemHash::iterator it = maItems.find( id );
+    if ( it != maItems.end() )
+        rRef = it->second;
+    return rRef;
+}
+#endif
+
+LayoutWidget::LayoutWidget( uno::Reference< awt::XToolkit > xToolkit,
+                            uno::Reference< awt::XLayoutContainer > xParent,
+                            OUString unoName, long attrbs )
+{
+    while ( xParent.is() && !uno::Reference< awt::XWindow >( xParent, uno::UNO_QUERY ).is() )
+    {
+        uno::Reference< awt::XLayoutContainer > xContainer( xParent, uno::UNO_QUERY );
+        assert( xContainer.is() );
+        xParent = uno::Reference< awt::XLayoutContainer >( xContainer->getParent(), uno::UNO_QUERY );
+    }
+
+    mxWidget = WidgetFactory::createWidget( xToolkit, xParent, unoName, attrbs );
+    assert( mxWidget.is() );
+    mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
+}
+
+LayoutWidget::~LayoutWidget()
+{
+    /* should we dispose of the references...? */
+    // at least of its children... Or should root?
+}
+
+bool LayoutWidget::addChild( LayoutWidget *pChild )
+{
+    if ( !mxContainer.is() )
+        return false;
+
+    try
+    {
+        mxContainer->addChild( pChild->mxWidget );
+    }
+    catch( awt::MaxChildrenException ex )
+    {
+        return false;
+    }
+    return true;
+}
+
+void LayoutWidget::setProperties( PropList const& rProps )
+{
+    ::layoutimpl::setProperties( mxWidget, rProps );
+}
+
+void LayoutWidget::setProperty( OUString const& attr, OUString const& value )
+{
+    ::layoutimpl::setProperty( mxWidget, attr, value );
+}
+
+void LayoutWidget::setChildProperties( LayoutWidget *pChild,
+                                       PropList const& rProps )
+{
+    uno::Reference< beans::XPropertySet > xChildPeer;
+    xChildPeer = mxContainer->getChildProperties( pChild->mxWidget );
+
+    if ( xChildPeer.is() )
+        ::layoutimpl::setProperties( xChildPeer, rProps );
+}
+
+} // namespace layoutimpl
+
diff --git a/toolkit/source/layout/core/root.hxx b/toolkit/source/layout/core/root.hxx
new file mode 100644
index 0000000..0dc36cf
--- /dev/null
+++ toolkit/source/layout/core/root.hxx
@@ -0,0 +1,160 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_ROOT_HXX
+#define LAYOUT_CORE_ROOT_HXX
+
+#define _BACKWARD_BACKWARD_WARNING_H 1
+#include <hash_map>
+
+#include <com/sun/star/awt/XLayoutRoot.hpp>
+#include <com/sun/star/awt/XToolkit.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <cppuhelper/implbase3.hxx>
+#include <cppuhelper/interfacecontainer.h>
+#include <toolkit/dllapi.h>
+
+#include <layout/core/proplist.hxx>
+
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+
+css::uno::Reference< css::io::XInputStream > getFileAsStream( const rtl::OUString &rName );
+
+/* Interface generation code -- to hook to a parser. */
+
+/*
+  TODO: (ricardo) I think we should cut on LayoutRoot, stripping out its widget
+  proxy interface (just make it return the root widget). Would even make it easier
+  if there was interest to support multiple toplevel widgets in the same file.
+
+  We also need to make sure the code gets diposed well... There is no need to keep
+  these objects around after initialization...
+*/
+
+
+class LayoutWidget;
+
+class TOOLKIT_DLLPUBLIC LayoutRoot : public ::cppu::WeakImplHelper3<
+    css::awt::XLayoutRoot,
+    css::lang::XInitialization,
+    css::lang::XComponent>
+{
+protected:
+    ::osl::Mutex maMutex;
+
+    typedef std::hash_map< rtl::OUString,
+                           css::uno::Reference< css::awt::XLayoutConstrains >,
+                           ::rtl::OUStringHash > ItemHash;
+    ItemHash maItems;
+
+    sal_Bool mbDisposed;
+    css::uno::Reference< css::lang::XMultiServiceFactory > mxFactory;
+    ::cppu::OInterfaceContainerHelper *mpListeners;
+
+    css::uno::Reference< css::awt::XWindow >          mxWindow;
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+
+    css::uno::Reference< css::awt::XToolkit > mxToolkit;
+    LayoutWidget *mpToplevel;
+    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
+
+    void error( rtl::OUString const& message );
+
+public:
+    LayoutRoot( const css::uno::Reference< css::lang::XMultiServiceFactory >& xFactory );
+    virtual ~LayoutRoot();
+
+    void addItem( const rtl::OUString &rName,
+                  const css::uno::Reference< css::awt::XLayoutConstrains > &xRef );
+
+    void setWindow(    css::uno::Reference< css::awt::XLayoutConstrains > xPeer )
+    {
+        mxWindow = css::uno::Reference< css::awt::XWindow >( xPeer, css::uno::UNO_QUERY );
+    }
+
+    // get XLayoutContainer
+    virtual css::uno::Reference< css::awt::XLayoutContainer > SAL_CALL getLayoutContainer() throw (css::uno::RuntimeException);
+
+    // XInitialization
+    virtual void SAL_CALL initialize( const css::uno::Sequence< css::uno::Any >& aArguments ) throw (css::uno::Exception, css::uno::RuntimeException);
+
+    // XNameAccess
+    virtual css::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException);
+    virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames() throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
+
+    // XComponent
+    virtual void SAL_CALL dispose() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addEventListener( const css::uno::Reference< css::lang::XEventListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeEventListener( const css::uno::Reference< css::lang::XEventListener >& aListener ) throw (css::uno::RuntimeException);
+
+    // generator
+    virtual LayoutWidget *create( rtl::OUString id, const rtl::OUString unoName, long attrbs, css::uno::Reference< css::awt::XLayoutContainer > xParent );
+};
+
+class TOOLKIT_DLLPUBLIC LayoutWidget
+{
+    friend class LayoutRoot;
+
+public:
+    LayoutWidget() {}
+    LayoutWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+                  css::uno::Reference< css::awt::XLayoutContainer > xToplevel,
+                  rtl::OUString unoName, long attrbs );
+    virtual ~LayoutWidget();
+
+    virtual void setProperties( const PropList &rProps );
+    virtual void setProperty( rtl::OUString const& attr, rtl::OUString const& value );
+
+    virtual bool addChild( LayoutWidget *pChild );
+    virtual void setChildProperties( LayoutWidget *pChild, const PropList &rProps );
+
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getPeer()
+    { return mxWidget; }
+    inline css::uno::Reference< css::awt::XLayoutContainer > getContainer()
+    { return mxContainer; }
+
+protected:
+    css::uno::Reference< css::awt::XLayoutConstrains > mxWidget;
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+};
+
+} // namespace layoutimpl
+
+#endif /* LAYOUT_CORE_ROOT_HXX */
diff --git a/toolkit/source/layout/core/table.cxx b/toolkit/source/layout/core/table.cxx
new file mode 100644
index 0000000..87c15e2
--- /dev/null
+++ toolkit/source/layout/core/table.cxx
@@ -0,0 +1,315 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <table.hxx>
+
+#include <sal/macros.h>
+#include <osl/mutex.hxx>
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/interfacecontainer.h>
+#include <com/sun/star/awt/PosSize.hpp>
+#include <tools/debug.hxx>
+
+// fixed point precision for distributing error
+#define FIXED_PT 16
+
+namespace layoutimpl
+{
+
+using namespace com::sun::star;
+
+Table::ChildProps::ChildProps( Table::ChildData *pData )
+    {
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "XExpand" ),
+                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &( pData->mbExpand[ 0 ] ) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "YExpand" ),
+                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &( pData->mbExpand[ 1 ] ) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "ColSpan" ),
+                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &( pData->mnColSpan ) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "RowSpan" ),
+                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &( pData->mnRowSpan ) );
+    }
+
+bool Table::ChildData::isVisible()
+{
+    return Box_Base::ChildData::isVisible()
+        && ( mnColSpan > 0 ) && ( mnRowSpan > 0 );
+}
+
+Table::Table()
+    : Box_Base()
+    , mnColsLen( 1 )// another default value could be 0xffff for infinite columns( = 1 row )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Columns" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnColsLen );
+}
+
+Table::ChildData::ChildData( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    : Box_Base::ChildData( xChild )
+//    , mbExpand( { 0, 1 } )
+    , mnColSpan( 1 )
+    , mnRowSpan( 1 )
+    , mnLeftCol( 0 )
+    , mnRightCol( 0 )
+    , mnTopRow( 0 )
+    , mnBottomRow( 0 )
+    {
+    mbExpand[ 0 ] = 0;
+    mbExpand[ 1 ] = 1;
+}
+
+Table::ChildData*
+Table::createChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+        {
+    return new ChildData( xChild );
+}
+
+Table::ChildProps*
+Table::createChildProps( Box_Base::ChildData *pData )
+{
+    return new ChildProps( static_cast<Table::ChildData*> ( pData ) );
+}
+
+void SAL_CALL
+Table::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw( uno::RuntimeException, awt::MaxChildrenException )
+        {
+    if ( xChild.is() )
+            {
+        Box_Base::addChild( xChild );
+        // cause of flicker
+        allocateChildAt( xChild, awt::Rectangle( 0,0,0,0 ) );
+    }
+}
+
+awt::Size SAL_CALL
+Table::getMinimumSize() throw( uno::RuntimeException )
+{
+    int nRowsLen = 0;
+
+    // 1. layout the table -- adjust to cope with row-spans...
+    {
+        // temporary 1D representation of the table
+        std::vector< ChildData *> aTable;
+
+        int col = 0;
+        int row = 0;
+        for ( std::list<Box_Base::ChildData *>::iterator it
+                  = maChildren.begin(); it != maChildren.end(); it++ )
+        {
+            ChildData *child = static_cast<Table::ChildData*> ( *it );
+            if ( !child->isVisible() )
+                continue;
+
+            while ( col + SAL_MIN( child->mnColSpan, mnColsLen ) > mnColsLen )
+            {
+                col = 0;
+                row++;
+
+                unsigned int i = col +( row*mnColsLen );
+                while ( aTable.size() > i && !aTable[ i ] )
+                    i++;
+
+                col = i % mnColsLen;
+                row = i / mnColsLen;
+            }
+
+            child->mnLeftCol = col;
+            child->mnRightCol = SAL_MIN( col + child->mnColSpan, mnColsLen );
+            child->mnTopRow = row;
+            child->mnBottomRow = row + child->mnRowSpan;
+
+            col += child->mnColSpan;
+
+            unsigned int start = child->mnLeftCol +( child->mnTopRow*mnColsLen );
+            unsigned int end =( child->mnRightCol-1 ) +( ( child->mnBottomRow-1 )*mnColsLen );
+            if ( aTable.size() < end+1 )
+                aTable.resize( end+1, NULL );
+            for ( unsigned int i = start; i < end; i++ )
+                aTable[ i ] = child;
+
+            nRowsLen = SAL_MAX( nRowsLen, child->mnBottomRow );
+        }
+    }
+
+    // 2. calculate columns/rows sizes
+    for ( int g = 0; g < 2; g++ )
+    {
+        std::vector< GroupData > &aGroup = g == 0 ? maCols : maRows;
+
+        aGroup.clear();
+        aGroup.resize( g == 0 ? mnColsLen : nRowsLen );
+
+        // 2.1 base sizes on one-column/row children
+        for ( std::list<Box_Base::ChildData *>::iterator it
+                  = maChildren.begin(); it != maChildren.end(); it++ )
+        {
+            ChildData *child = static_cast<Table::ChildData*> ( *it );
+            if ( !child->isVisible() )
+                continue;
+            const int nFirstAttach = g == 0 ? child->mnLeftCol : child->mnTopRow;
+            const int nLastAttach  = g == 0 ? child->mnRightCol : child->mnBottomRow;
+
+            if ( nFirstAttach == nLastAttach-1 )
+            {
+                child->maRequisition = child->mxChild->getMinimumSize();
+                int attach = nFirstAttach;
+                int child_size = g == 0 ? child->maRequisition.Width
+                    : child->maRequisition.Height;
+                aGroup[ attach ].mnSize = SAL_MAX( aGroup[ attach ].mnSize,
+                                                   child_size );
+                if ( child->mbExpand[ g ] )
+                    aGroup[ attach ].mbExpand = true;
+            }
+        }
+
+        // 2.2 make sure multiple-columns/rows children fit
+        for ( std::list<Box_Base::ChildData *>::iterator it
+                  = maChildren.begin(); it != maChildren.end(); it++ )
+        {
+            ChildData *child = static_cast<Table::ChildData*> ( *it );
+            if ( !child->isVisible() )
+                continue;
+            const int nFirstAttach = g == 0 ? child->mnLeftCol : child->mnTopRow;
+            const int nLastAttach  = g == 0 ? child->mnRightCol : child->mnBottomRow;
+
+            if ( nFirstAttach != nLastAttach-1 )
+            {
+                child->maRequisition = child->mxChild->getMinimumSize();
+                int size = 0;
+                int expandables = 0;
+                for ( int i = nFirstAttach; i < nLastAttach; i++ )
+                {
+                    size += aGroup[ i ].mnSize;
+                    if ( aGroup[ i ].mbExpand )
+                        expandables++;
+                }
+
+                int child_size = g == 0 ? child->maRequisition.Width
+                    : child->maRequisition.Height;
+                int extra = child_size - size;
+                if ( extra > 0 )
+                {
+                    if ( expandables )
+                        extra /= expandables;
+                    else
+                        extra /= nLastAttach - nFirstAttach;
+
+                    for ( int i = nFirstAttach; i < nLastAttach; i++ )
+                        if ( expandables == 0 || aGroup[ i ].mbExpand )
+                            aGroup[ i ].mnSize += extra;
+                }
+            }
+        }
+    }
+
+    // 3. Sum everything up
+    mnColExpandables =( mnRowExpandables = 0 );
+    maRequisition.Width =( maRequisition.Height = 0 );
+    for ( std::vector<GroupData>::iterator it = maCols.begin();
+         it != maCols.end(); it++ )
+    {
+        maRequisition.Width += it->mnSize;
+        if ( it->mbExpand )
+            mnColExpandables++;
+    }
+    for ( std::vector<GroupData>::iterator it = maRows.begin();
+         it != maRows.end(); it++ )
+    {
+        maRequisition.Height += it->mnSize;
+        if ( it->mbExpand )
+            mnRowExpandables++;
+    }
+
+    return maRequisition;
+}
+
+void SAL_CALL
+Table::allocateArea( const awt::Rectangle &rArea )
+    throw( uno::RuntimeException )
+{
+    maAllocation = rArea;
+    if ( maCols.size() == 0 || maRows.size() == 0 )
+        return;
+
+    int nExtraSize[ 2 ] = { SAL_MAX( rArea.Width - maRequisition.Width, 0 ),
+                            SAL_MAX( rArea.Height - maRequisition.Height, 0 ) };
+    // split it
+    nExtraSize[ 0 ] /= mnColExpandables ? mnColExpandables : mnColsLen;
+    nExtraSize[ 1 ] /= mnRowExpandables ? mnRowExpandables : maRows.size();
+
+    for ( std::list<Box_Base::ChildData *>::const_iterator it
+              = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = static_cast<Table::ChildData*> ( *it );
+        if ( !child->isVisible() )
+            continue;
+
+        awt::Rectangle rChildArea( rArea.X, rArea.Y, 0, 0 );
+
+        for ( int g = 0; g < 2; g++ )
+        {
+            std::vector< GroupData > &aGroup = g == 0 ? maCols : maRows;
+            const int nFirstAttach = g == 0 ? child->mnLeftCol : child->mnTopRow;
+            const int nLastAttach  = g == 0 ? child->mnRightCol : child->mnBottomRow;
+
+            for ( int i = 0; i < nFirstAttach; i++ )
+            {
+                int gSize = aGroup[ i ].mnSize;
+                if ( aGroup[ i ].mbExpand )
+                    gSize += nExtraSize[ g ];
+                if ( g == 0 )
+                    rChildArea.X += gSize;
+                else
+                    rChildArea.Y += gSize;
+            }
+            for ( int i = nFirstAttach; i < nLastAttach; i++ )
+            {
+                int gSize = aGroup[ i ].mnSize;
+                if ( aGroup[ i ].mbExpand )
+                    gSize += nExtraSize[ g ];
+                if ( g == 0 )
+                    rChildArea.Width  += gSize;
+                else
+                    rChildArea.Height += gSize;
+            }
+        }
+
+        allocateChildAt( child->mxChild, rChildArea );
+    }
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/table.hxx b/toolkit/source/layout/core/table.hxx
new file mode 100644
index 0000000..dac2aaa
--- /dev/null
+++ toolkit/source/layout/core/table.hxx
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_TABLE_HXX
+#define LAYOUT_CORE_TABLE_HXX
+
+#include <layout/core/box-base.hxx>
+
+namespace layoutimpl
+{
+
+class Table : public Box_Base
+{
+public:
+    // Children properties
+    struct ChildData : public Box_Base::ChildData
+    {
+        sal_Bool mbExpand[ 2 ];
+        sal_Int32 mnColSpan;
+        sal_Int32 mnRowSpan;
+        int mnLeftCol;
+        int mnRightCol;
+        int mnTopRow;
+        int mnBottomRow;
+
+        ChildData( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
+        bool isVisible();
+    };
+
+    struct ChildProps : public Box_Base::ChildProps
+    {
+        ChildProps( ChildData *pData );
+    };
+
+protected:
+
+    // a group of children; either a column or a row
+    struct GroupData
+    {
+        sal_Bool mbExpand;
+        int mnSize;  // request size (width or height)
+        GroupData() : mbExpand( false ), mnSize( 0 ) {}
+    };
+
+    // Table properties
+    sal_Int32 mnColsLen;
+    std::vector< GroupData > maCols;
+    std::vector< GroupData > maRows;
+    int mnColExpandables, mnRowExpandables;
+
+    ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
+    ChildProps *createChildProps( Box_Base::ChildData* pData );
+
+public:
+    Table();
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+
+    // unimplemented:
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException)
+    { return false; }
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 /*nWidth*/ )
+    throw(css::uno::RuntimeException)
+    { return maRequisition.Height; }
+
+    PROPHELPER_SET_INFO
+};
+
+} //  namespace layoutimpl
+
+#endif /* LAYOUT_CORE_TABLE_HXX */
diff --git a/toolkit/source/layout/core/timer.cxx b/toolkit/source/layout/core/timer.cxx
new file mode 100644
index 0000000..26874a0
--- /dev/null
+++ toolkit/source/layout/core/timer.cxx
@@ -0,0 +1,152 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "timer.hxx"
+
+#include <vector>
+#include <list>
+#include <vcl/timer.hxx>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+
+namespace layoutimpl
+{
+using namespace ::com::sun::star;
+
+class AllocateTimer : public Timer
+{
+    typedef std::list< uno::Reference< awt::XLayoutContainer > > ContainerList;
+    ContainerList mxContainers;
+    uno::Reference< awt::XLayoutContainer > mxLastAdded;
+
+public:
+    AllocateTimer()
+    {
+        // timer set to 0 -- just process it as soon as it gets idle
+        SetTimeout( 0 );
+    }
+
+    static inline bool isParentOf( uno::Reference< awt::XLayoutContainer > xParent,
+                                   uno::Reference< awt::XLayoutContainer > xWidget )
+    {
+        while ( xWidget.is() )
+        {
+            if ( xWidget == xParent )
+                return true;
+            xWidget = uno::Reference< awt::XLayoutContainer >( xWidget->getParent(), uno::UNO_QUERY );
+        }
+        return false;
+    }
+
+    static inline void eraseChildren( ContainerList::iterator &it, ContainerList &list )
+    {
+        ContainerList::iterator jt = list.begin();
+        while ( jt != list.end() )
+        {
+            if ( it != jt && isParentOf( *it, *jt ) )
+                jt = list.erase( jt );
+            else
+                jt++;
+        }
+    }
+
+    static inline bool isContainerDamaged( uno::Reference< awt::XLayoutContainer > xContainer )
+    {
+        uno::Reference< awt::XLayoutConstrains > xConstrains( xContainer, uno::UNO_QUERY );
+        awt::Size lastReq( xContainer->getRequestedSize() );
+        awt::Size curReq( xConstrains->getMinimumSize() );
+        return lastReq.Width != curReq.Width || lastReq.Height != curReq.Height;
+    }
+
+    void add( const uno::Reference< awt::XLayoutContainer > &xContainer )
+    {
+        // small optimization
+        if ( mxLastAdded == xContainer )
+            return;
+        mxLastAdded = xContainer;
+
+        mxContainers.push_back( xContainer );
+    }
+
+    virtual void Timeout()
+    {
+        mxLastAdded = uno::Reference< awt::XLayoutContainer >();
+
+        // 1. remove duplications and children
+        for ( ContainerList::iterator it = mxContainers.begin();
+             it != mxContainers.end(); it++ )
+            eraseChildren( it, mxContainers );
+
+        // 2. check damage extent
+        for ( ContainerList::iterator it = mxContainers.begin();
+             it != mxContainers.end(); it++ )
+        {
+            uno::Reference< awt::XLayoutContainer > xContainer = *it;
+            while ( xContainer->getParent().is() && isContainerDamaged( xContainer ) )
+            {
+                xContainer = uno::Reference< awt::XLayoutContainer >(
+                    xContainer->getParent(), uno::UNO_QUERY );
+            }
+
+            if ( *it != xContainer )
+            {
+                // 2.2 replace it with parent
+                *it = xContainer;
+
+                // 2.3 remove children of new parent
+                eraseChildren( it, mxContainers );
+            }
+        }
+
+        // 3. force re-calculations
+        for ( ContainerList::iterator it = mxContainers.begin();
+             it != mxContainers.end(); it++ )
+            (*it)->allocateArea( (*it)->getAllocatedArea() );
+    }
+};
+
+static void AddResizeTimeout( const uno::Reference< awt::XLayoutContainer > &xCont )
+{
+    static AllocateTimer timer;
+    timer.add( xCont );
+    timer.Start();
+}
+
+LayoutUnit::LayoutUnit() : LayoutUnit_Base()
+{
+}
+
+void SAL_CALL LayoutUnit::queueResize( const uno::Reference< awt::XLayoutContainer > &xContainer )
+    throw( uno::RuntimeException )
+{
+    AddResizeTimeout( xContainer );
+}
+
+}
diff --git a/toolkit/source/layout/core/timer.hxx b/toolkit/source/layout/core/timer.hxx
new file mode 100644
index 0000000..5ab8e3d
--- /dev/null
+++ toolkit/source/layout/core/timer.hxx
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_TIMER_HXX
+#define LAYOUT_CORE_TIMER_HXX
+
+#include <com/sun/star/awt/XLayoutUnit.hpp>
+#include <cppuhelper/implbase1.hxx>
+
+namespace layoutimpl
+{
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::awt::XLayoutUnit > LayoutUnit_Base;
+
+class LayoutUnit : public LayoutUnit_Base
+{
+public:
+    LayoutUnit();
+    void SAL_CALL queueResize( const com::sun::star::uno::Reference< com::sun::star::awt::XLayoutContainer > &xContainer )
+        throw( com::sun::star::uno::RuntimeException );
+};
+
+}
+
+#endif /* LAYOUT_CORE_TIMER_HXX */
diff --git a/toolkit/source/layout/core/translate.cxx b/toolkit/source/layout/core/translate.cxx
new file mode 100644
index 0000000..d0fc9f7
--- /dev/null
+++ toolkit/source/layout/core/translate.cxx
@@ -0,0 +1,134 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "translate.hxx"
+
+#include <list>
+#if TEST_LAYOUT
+#include <cstdio>
+#include "tools/getprocessworkingdir.hxx"
+#endif
+
+#include <unotools/bootstrap.hxx>
+#include <unotools/localfilehelper.hxx>
+#include <unotools/ucbhelper.hxx>
+#include <vcl/svapp.hxx>
+
+#include "proplist.hxx"
+
+namespace layoutimpl
+{
+namespace css = ::com::sun::star;
+using namespace css;
+using ::rtl::OUString;
+using ::utl::LocalFileHelper;
+using ::utl::UCBContentHelper;
+using ::utl::Bootstrap;
+
+static std::list<OUString>
+getLocaleSubdirList( lang::Locale const& rLocale )
+{
+    std::list<OUString> aSubdirs;
+    aSubdirs.push_front( OUString::createFromAscii( "." ) );
+    aSubdirs.push_front( OUString::createFromAscii( "en_US" ) );
+    if ( rLocale.Language.getLength() )
+        aSubdirs.push_front( rLocale.Language );
+    if ( rLocale.Country.getLength() )
+    {
+        OUString aLocaleCountry = rLocale.Language
+            + OUString::createFromAscii( "_" )
+            + rLocale.Country;
+        aSubdirs.push_front( aLocaleCountry );
+        if ( rLocale.Variant.getLength() )
+            aSubdirs.push_front( aLocaleCountry
+                                 + OUString::createFromAscii( "." )
+                                 + rLocale.Variant );
+    }
+    return aSubdirs;
+}
+
+static bool
+fileExists( String const& aFile )
+{
+    String aUrl;
+    LocalFileHelper::ConvertPhysicalNameToURL( aFile, aUrl );
+    return UCBContentHelper::Exists( aUrl );
+}
+
+static OUString
+getFirstExisting( OUString const& aDir, std::list<OUString> const& aSubDirs,
+                  OUString const& aXMLName )
+{
+    static OUString const aSlash = OUString::createFromAscii( "/" );
+    String aResult;
+    for ( std::list<OUString>::const_iterator i = aSubDirs.begin();
+          i != aSubDirs.end(); i++ )
+    {
+        String aFile = aDir + aSlash + *i + aSlash + aXMLName;
+        OSL_TRACE( "testing: %s", OUSTRING_CSTR( aFile ) );
+        if ( fileExists( aFile ) )
+            return aFile;
+    }
+    return OUString();
+}
+
+/*  FIXME: IWBN to share code with impimagetree.cxx, also for reading
+  from zip files.  */
+OUString
+readRightTranslation( OUString const& aXMLName )
+{
+    String aXMLFile;
+    std::list<OUString> aSubdirs
+        = getLocaleSubdirList( Application::GetSettings().GetUILocale() );
+#if TEST_LAYOUT // read from cwd first
+    OUString aCurrentWorkingUrl;
+    tools::getProcessWorkingDir( &aCurrentWorkingUrl );
+    String aCurrentWorkingDir;
+    LocalFileHelper::ConvertURLToPhysicalName( aCurrentWorkingUrl, aCurrentWorkingDir );
+    aXMLFile = getFirstExisting( aCurrentWorkingDir, aSubdirs, aXMLName );
+    if ( aXMLFile.Len() )
+        ;
+    else
+#endif /* TEST_LAYOUT */
+    {
+        OUString aShareUrl;
+        Bootstrap::locateSharedData( aShareUrl );
+        OUString aXMLUrl = aShareUrl + OUString::createFromAscii( "/layout" );
+        String aXMLDir;
+        LocalFileHelper::ConvertURLToPhysicalName( aXMLUrl, aXMLDir );
+        aXMLFile = getFirstExisting( aXMLDir, aSubdirs, aXMLName );
+    }
+
+    OSL_TRACE( "FOUND:%s", OUSTRING_CSTR ( OUString (aXMLFile) ) );
+    return aXMLFile;
+}
+
+} // namespace layoutimpl
diff --git a/toolkit/source/layout/core/translate.hxx b/toolkit/source/layout/core/translate.hxx
new file mode 100644
index 0000000..b14cded
--- /dev/null
+++ toolkit/source/layout/core/translate.hxx
@@ -0,0 +1,44 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_TRANSLATE_HXX
+#define LAYOUT_CORE_TRANSLATE_HXX
+
+namespace rtl {
+class OUString;
+} // namespace rtl
+
+namespace layoutimpl
+{
+::rtl::OUString readRightTranslation( ::rtl::OUString const& aXMLName );
+} // namespace layoutimpl
+
+#endif /* LAYOUT_CORE_TRANSLATE_HXX */
diff --git a/toolkit/source/layout/core/vcl.cxx b/toolkit/source/layout/core/vcl.cxx
new file mode 100644
index 0000000..41d3ae8
--- /dev/null
+++ toolkit/source/layout/core/vcl.cxx
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <vcl.hxx>
+
+#include <sal/types.h>
+#include <vcl/button.hxx>
+
+static PushButton* get_button (Dialog const* dialog, sal_uInt32 type)
+{
+    Window* child = dialog->GetWindow (WINDOW_FIRSTCHILD);
+    while (child)
+    {
+        if (child->GetType () == type)
+            return static_cast <PushButton*> (child);
+        child = child->GetWindow (WINDOW_NEXT);
+    }
+
+    return 0;
+}
+
+#define IMPLEMENT_CLOSING_DIALOG(cls)\
+    Closing##cls::Closing##cls (Window* parent, WinBits bits)\
+    : cls (parent, bits)\
+        , mClosing (false)\
+    {\
+    }\
+    BOOL Closing##cls::Close ()\
+    {\
+        if (mClosing)\
+            EndDialog (false);\
+        else if (PushButton *cancel = get_button (this, WINDOW_CANCELBUTTON))\
+            cancel->Click ();\
+        else if (PushButton *ok = get_button (this, WINDOW_OKBUTTON))\
+            ok->Click ();\
+        mClosing = true;\
+        return false;\
+    }
+
+IMPLEMENT_CLOSING_DIALOG (Dialog);
+IMPLEMENT_CLOSING_DIALOG (ModelessDialog);
+IMPLEMENT_CLOSING_DIALOG (ModalDialog);
diff --git a/toolkit/source/layout/core/vcl.hxx b/toolkit/source/layout/core/vcl.hxx
new file mode 100644
index 0000000..a155e68
--- /dev/null
+++ toolkit/source/layout/core/vcl.hxx
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_CORE_VCL_HXX
+#define LAYOUT_CORE_VCL_HXX
+
+#include <vcl/dialog.hxx>
+
+#define DECLARE_CLOSING_DIALOG(cls)\
+    class Closing##cls : public cls\
+    {\
+    public:\
+        bool mClosing;\
+        Closing##cls (Window* parent, WinBits bits);\
+        virtual BOOL Close ();\
+    }
+
+DECLARE_CLOSING_DIALOG (Dialog);
+DECLARE_CLOSING_DIALOG (ModalDialog);
+DECLARE_CLOSING_DIALOG (ModelessDialog);
+
+#undef DECLARE_CLOSING_DIALOG
+
+#endif /* LAYOUT_CORE_VCL_HXX */
diff --git a/toolkit/source/layout/dialogbuttonhbox.cxx b/toolkit/source/layout/dialogbuttonhbox.cxx
deleted file mode 100644
index 67a7ec0..0000000
--- toolkit/source/layout/dialogbuttonhbox.cxx
+++ /dev/null
@@ -1,294 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include <awt/vclxbutton.hxx>
-#include <tools/debug.hxx>
-#include <toolkit/awt/vclxwindows.hxx>
-#include <vcl/button.hxx>
-
-#include "dialogbuttonhbox.hxx"
-#include "flow.hxx"
-#include "proplist.hxx"
-
-#if TEST_LAYOUT && !defined( DBG_UTIL )
-#include <cstdio>
-#undef DBG_ERROR
-#define DBG_ERROR printf
-#undef DBG_ERROR1
-#define DBG_ERROR1 printf
-#undef DBG_ERROR2
-#define DBG_ERROR2 printf
-#endif /* TEST_LAYOUT && !DBG_UTIL */
-
-namespace layoutimpl
-{
-
-using namespace css;
-
-//FIXME: how to set platform-dependant variables?
-DialogButtonHBox::Ordering const DialogButtonHBox::DEFAULT_ORDERING =
-#if defined( MACOSX )
-    DialogButtonHBox::MACOS;
-#elif defined( SAL_W32 )
-DialogButtonHBox::WINDOWS;
-#elif defined( ENABLE_KDE )
-DialogButtonHBox::KDE;
-#else /* !MACOSX && !SAL_W32 && !ENABLE_KDE */
-DialogButtonHBox::GNOME;
-#endif /* !MACOSX && !SAL_W32 && !ENABLE_KDE */
-
-DialogButtonHBox::DialogButtonHBox()
-    : HBox()
-    , mnOrdering( DEFAULT_ORDERING )
-    , mFlow()
-    , mpAction( 0 )
-    , mpAffirmative( 0 )
-    , mpAlternate( 0 )
-    , mpApply( 0 )
-    , mpCancel( 0 )
-    , mpFlow( createChild( uno::Reference< awt::XLayoutConstrains > ( &mFlow ) ) )
-    , mpHelp( 0 )
-    , mpReset( 0 )
-{
-    mbHomogeneous = true;
-}
-
-void
-DialogButtonHBox::setOrdering( rtl::OUString const& ordering )
-{
-    if ( ordering.equalsIgnoreAsciiCaseAscii( "GNOME" ) )
-        mnOrdering = GNOME;
-    else if ( ordering.equalsIgnoreAsciiCaseAscii( "KDE" ) )
-        mnOrdering = KDE;
-    else if ( ordering.equalsIgnoreAsciiCaseAscii( "MacOS" ) )
-        mnOrdering = MACOS;
-    else if ( ordering.equalsIgnoreAsciiCaseAscii( "Windows" ) )
-        mnOrdering = WINDOWS;
-    else
-    {
-        DBG_ERROR1( "DialogButtonHBox: no such ordering: %s", OUSTRING_CSTR( ordering ) );
-    }
-}
-
-void
-DialogButtonHBox::addChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
-    throw ( uno::RuntimeException, awt::MaxChildrenException )
-{
-    if ( !xChild.is() )
-        return;
-
-    ChildData *p = createChild( xChild );
-
-#define IS_BUTTON(t) dynamic_cast<VCLX##t##Button *>( xChild.get () )
-
-    /* Sort Retry as Action */
-    if ( !mpAction && IS_BUTTON( Retry ) )
-        mpAction = p;
-    else if ( !mpAffirmative && IS_BUTTON( OK ) )
-        mpAffirmative = p;
-    else if ( !mpAffirmative && IS_BUTTON( Yes ) )
-        mpAffirmative = p;
-    else if ( !mpAlternate && IS_BUTTON( No ) )
-        mpAlternate = p;
-    /* Sort Ignore as Alternate */
-    else if ( !mpAlternate && IS_BUTTON( Ignore ) )
-        mpAlternate = p;
-    else if ( !mpApply && IS_BUTTON( Apply ) )
-        mpApply = p;
-    else if ( !mpCancel && IS_BUTTON( Cancel ) )
-        mpCancel = p;
-    /* Let the user overwrite Flow */
-    else if ( /* !mpFlow && */ dynamic_cast<Flow *>( xChild.get () ) )
-        mpFlow = p;
-    else if ( !mpHelp && IS_BUTTON( Help ) )
-        mpHelp = p;
-    else if ( !mpReset && IS_BUTTON( Reset ) )
-        mpReset = p;
-    else
-        maOther.push_back( p );
-    orderChildren();
-    setChildParent( xChild );
-    queueResize();
-}
-
-void
-DialogButtonHBox::orderChildren()
-{
-    if ( mnOrdering == WINDOWS )
-        windowsOrdering();
-    else if ( mnOrdering == MACOS )
-        macosOrdering();
-    else if ( mnOrdering == KDE )
-        kdeOrdering();
-    else if ( 1 || mnOrdering == GNOME )
-        gnomeOrdering();
-}
-
-void SAL_CALL
-DialogButtonHBox::removeChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
-    throw ( uno::RuntimeException)
-{
-    if ( !xChild.is ())
-        return;
-
-    Box_Base::ChildData *p = 0;
-
-    if ( mpAction && mpAction->mxChild == xChild )
-        p = mpAction;
-    else if ( mpAffirmative && mpAffirmative->mxChild == xChild )
-        p = mpAffirmative;
-    else if ( mpAlternate && mpAlternate->mxChild == xChild )
-        p = mpAlternate;
-    else if ( mpApply && mpApply->mxChild == xChild )
-        p = mpApply;
-    else if ( mpCancel && mpCancel->mxChild == xChild )
-        p = mpCancel;
-    else if ( mpFlow && mpFlow->mxChild == xChild )
-        p = mpFlow;
-    else if ( mpReset && mpReset->mxChild == xChild )
-        p = mpReset;
-    else if ( mpHelp && mpHelp->mxChild == xChild )
-        p = mpHelp;
-    else
-        p = removeChildData( maOther, xChild );
-
-    if ( p )
-    {
-        delete p;
-        unsetChildParent( xChild );
-        orderChildren();
-        queueResize();
-    }
-    else
-    {
-        DBG_ERROR( "DialogButtonHBox: removeChild: no such child" );
-    }
-}
-
-void
-DialogButtonHBox::gnomeOrdering()
-{
-    std::list< Box_Base::ChildData * > ordered;
-    if ( mpHelp )
-        ordered.push_back( mpHelp );
-    if ( mpReset )
-        ordered.push_back( mpReset );
-    if ( mpFlow && ( mpHelp || mpReset ) )
-        ordered.push_back( mpFlow );
-    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
-    if ( mpAction )
-        ordered.push_back( mpAction );
-    if ( mpApply )
-        ordered.push_back( mpApply );
-    if ( mpAlternate )
-        ordered.push_back( mpAlternate );
-    if ( mpCancel )
-        ordered.push_back( mpCancel );
-    if ( mpAffirmative )
-        ordered.push_back( mpAffirmative );
-    maChildren = ordered;
-}
-
-void
-DialogButtonHBox::kdeOrdering()
-{
-    std::list< Box_Base::ChildData * > ordered;
-    if ( mpHelp )
-        ordered.push_back( mpHelp );
-    if ( mpReset )
-        ordered.push_back( mpReset );
-    if ( mpFlow && ( mpHelp || mpReset ) )
-        ordered.push_back( mpFlow );
-    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
-    if ( mpAction )
-        ordered.push_back( mpAction );
-    if ( mpAffirmative )
-        ordered.push_back( mpAffirmative );
-    if ( mpApply )
-        ordered.push_back( mpApply );
-    if ( mpAlternate )
-        ordered.push_back( mpAlternate );
-    if ( mpCancel )
-        ordered.push_back( mpCancel );
-    maChildren = ordered;
-}
-
-void
-DialogButtonHBox::macosOrdering()
-{
-    std::list< Box_Base::ChildData * > ordered;
-    if ( mpHelp )
-        ordered.push_back( mpHelp );
-    if ( mpReset )
-        ordered.push_back( mpReset );
-    if ( mpApply )
-        ordered.push_back( mpApply );
-    if ( mpAction )
-        ordered.push_back( mpAction );
-    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
-    if ( mpFlow ) // Always flow? && ( maOther.size () || mpHelp || mpReset || mpAction ) )
-        ordered.push_back( mpFlow );
-    if ( mpAlternate )
-        ordered.push_back( mpAlternate );
-    if ( mpFlow && mpAlternate )
-        ordered.push_back( mpFlow );
-    if ( mpCancel )
-        ordered.push_back( mpCancel );
-    if ( mpAffirmative )
-        ordered.push_back( mpAffirmative );
-    maChildren = ordered;
-}
-
-void
-DialogButtonHBox::windowsOrdering()
-{
-    std::list< Box_Base::ChildData * > ordered;
-    if ( mpReset )
-        ordered.push_back( mpReset );
-    if ( mpReset && mpFlow )
-        ordered.push_back( mpFlow );
-    if ( mpAffirmative )
-        ordered.push_back( mpAffirmative );
-    if ( mpAlternate )
-        ordered.push_back( mpAlternate );
-    if ( mpAction )
-        ordered.push_back( mpAction );
-    if ( mpCancel )
-        ordered.push_back( mpCancel );
-    if ( mpApply )
-        ordered.push_back( mpApply );
-    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
-    if ( mpHelp )
-        ordered.push_back( mpHelp );
-    maChildren = ordered;
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/dialogbuttonhbox.hxx b/toolkit/source/layout/dialogbuttonhbox.hxx
deleted file mode 100644
index 4f2b74c..0000000
--- toolkit/source/layout/dialogbuttonhbox.hxx
+++ /dev/null
@@ -1,77 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_DIALOGBUTTONHBOX_HXX
-#define CORE_DIALOGBUTTONHBOX_HXX
-
-#include "box.hxx"
-#include "flow.hxx"
-
-namespace layoutimpl
-{
-
-class DialogButtonHBox : public HBox
-{
-public:
-    DialogButtonHBox();
-
-    void setOrdering( rtl::OUString const& ordering );
-    void SAL_CALL addChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) throw ( css::uno::RuntimeException, css::awt::MaxChildrenException );
-    void SAL_CALL removeChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) throw ( css::uno::RuntimeException );
-
-private:
-    enum Ordering { PLATFORM, GNOME, KDE, MACOS, WINDOWS };
-
-    void orderChildren();
-    void gnomeOrdering();
-    void kdeOrdering();
-    void macosOrdering();
-    void windowsOrdering();
-
-    static Ordering const DEFAULT_ORDERING;
-    Ordering mnOrdering;
-    Flow mFlow;
-
-    ChildData *mpAction; /* [..]?, [Retry?] */
-    ChildData *mpAffirmative; /* OK, Yes, Save */
-    ChildData *mpAlternate; /* NO, [Ignore?], Don't save, Quit without saving */
-    ChildData *mpApply; /* Deprecated? */
-    ChildData *mpCancel; /* Cancel, Close */
-    ChildData *mpFlow;
-    ChildData *mpHelp;
-    ChildData *mpReset;
-
-    std::list< Box_Base::ChildData *> maOther;
-};
-
-} // namespace layoutimpl
-
-#endif /* CORE_DIALOGBUTTONHBOX_HXX */
diff --git a/toolkit/source/layout/factory.cxx b/toolkit/source/layout/factory.cxx
deleted file mode 100644
index e687ca8..0000000
--- toolkit/source/layout/factory.cxx
+++ /dev/null
@@ -1,154 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "factory.hxx"
-
-#include <com/sun/star/registry/XRegistryKey.hpp>
-#include <com/sun/star/registry/InvalidRegistryException.hpp>
-#include <cppuhelper/factory.hxx>
-
-#include "root.hxx"
-
-using namespace ::com::sun::star;
-using namespace layoutimpl;
-
-void * SAL_CALL comp_Layout_component_getFactory( const char * pImplName, void * pServiceManager, void * /*registryKey*/ )
-    {
-        void * pRet = 0;
-
-        ::rtl::OUString aImplName( ::rtl::OUString::createFromAscii( pImplName ) );
-        uno::Reference< lang::XSingleServiceFactory > xFactory;
-
-        if ( pServiceManager && aImplName.equals( LayoutFactory::impl_staticGetImplementationName() ) )
-            xFactory = ::cppu::createOneInstanceFactory( reinterpret_cast< lang::XMultiServiceFactory*>( pServiceManager ),
-                                                         LayoutFactory::impl_staticGetImplementationName(),
-                                                         LayoutFactory::impl_staticCreateSelfInstance,
-                                                         LayoutFactory::impl_staticGetSupportedServiceNames() );
-        if ( xFactory.is() )
-        {
-            xFactory->acquire();
-            pRet = xFactory.get();
-        }
-
-        return pRet;
-    }
-
-sal_Bool SAL_CALL comp_Layout_component_writeInfo( void * /*serviceManager*/, void * pRegistryKey )
-    {
-        if ( pRegistryKey )
-        {
-            try
-            {
-                uno::Reference< registry::XRegistryKey > xKey( reinterpret_cast< registry::XRegistryKey* >( pRegistryKey ) );
-                uno::Reference< registry::XRegistryKey >  xNewKey;
-
-                xNewKey = xKey->createKey( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("/") ) +
-                                           LayoutFactory::impl_staticGetImplementationName() +
-                                           ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "/UNO/SERVICES") )  );
-
-                const uno::Sequence< ::rtl::OUString > aServices = LayoutFactory::impl_staticGetSupportedServiceNames();
-                for ( sal_Int32 i = 0; i < aServices.getLength(); i++ )
-                    xNewKey->createKey( aServices.getConstArray()[i] );
-
-                return sal_True;
-            }
-            catch (registry::InvalidRegistryException &)
-        {
-            OSL_ENSURE( sal_False, "### InvalidRegistryException!" );
-        }
-        }
-        return sal_False;
-    }
-
-// Component registration
-::rtl::OUString SAL_CALL LayoutFactory::impl_staticGetImplementationName()
-{
-    return ::rtl::OUString::createFromAscii( "com.sun.star.comp.awt.Layout" );
-}
-
-uno::Sequence< ::rtl::OUString > SAL_CALL LayoutFactory::impl_staticGetSupportedServiceNames()
-{
-    uno::Sequence< ::rtl::OUString > aRet(2);
-    aRet[0] = ::rtl::OUString::createFromAscii("com.sun.star.awt.Layout");
-    aRet[1] = ::rtl::OUString::createFromAscii("com.sun.star.comp.awt.Layout");
-    return aRet;
-}
-
-uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::impl_staticCreateSelfInstance(
-    const uno::Reference< lang::XMultiServiceFactory >& xServiceManager )
-{
-    return uno::Reference< uno::XInterface >( *new LayoutFactory( xServiceManager ) );
-}
-
-// XServiceInfo
-::rtl::OUString SAL_CALL LayoutFactory::getImplementationName()
-    throw ( uno::RuntimeException )
-{
-    return impl_staticGetImplementationName();
-}
-
-uno::Sequence< ::rtl::OUString > SAL_CALL LayoutFactory::getSupportedServiceNames()
-    throw ( uno::RuntimeException )
-{
-    return impl_staticGetSupportedServiceNames();
-}
-
-sal_Bool SAL_CALL LayoutFactory::supportsService( const ::rtl::OUString& ServiceName )
-    throw ( uno::RuntimeException )
-{
-    uno::Sequence< ::rtl::OUString > aSeq = impl_staticGetSupportedServiceNames();
-    for ( sal_Int32 i = 0; i < aSeq.getLength(); i++ )
-        if ( ServiceName.compareTo( aSeq[i] ) == 0 )
-            return sal_True;
-    
-    return sal_False;
-}
-
-// XSingleServiceFactory
-uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::createInstance()
-    throw ( uno::Exception,
-            uno::RuntimeException )
-{
-    return uno::Reference< uno::XInterface >(
-        static_cast< OWeakObject* >( new LayoutRoot( m_xFactory ) ),
-        uno::UNO_QUERY );
-}
-
-uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::createInstanceWithArguments(
-    const uno::Sequence< uno::Any >& aArguments )
-    throw ( uno::Exception,
-            uno::RuntimeException )
-{
-    uno::Reference< uno::XInterface > layout = createInstance();
-    uno::Reference< lang::XInitialization > xInit( layout, uno::UNO_QUERY );
-    xInit->initialize( aArguments );
-    return layout;
-}
diff --git a/toolkit/source/layout/factory.hxx b/toolkit/source/layout/factory.hxx
deleted file mode 100644
index 472f1e8..0000000
--- toolkit/source/layout/factory.hxx
+++ /dev/null
@@ -1,78 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef FACTORY_HXX_
-#define FACTORY_HXX_
-
-#include <com/sun/star/lang/XSingleServiceFactory.hpp>
-#include <com/sun/star/lang/XServiceInfo.hpp>
-#include <cppuhelper/implbase2.hxx>
-#include <toolkit/dllapi.h>
-
-namespace layoutimpl
-{
-class Layout;
-}
-
-class TOOLKIT_DLLPUBLIC LayoutFactory : public ::cppu::WeakImplHelper2< ::com::sun::star::lang::XSingleServiceFactory,
-                                                      ::com::sun::star::lang::XServiceInfo >
-{
-    ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_xFactory;
-
-public:
-    LayoutFactory( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xFactory )
-        : m_xFactory( xFactory )
-    {
-        OSL_ENSURE( xFactory.is(), "No service manager is provided!\n" );
-    }
-
-    static ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL
-    impl_staticGetSupportedServiceNames();
-
-    static ::rtl::OUString SAL_CALL impl_staticGetImplementationName();
-
-    static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL
-    impl_staticCreateSelfInstance(
-        const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceManager );
-
-
-    // XSingleServiceFactory
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL createInstance() throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
-    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL createInstanceWithArguments( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments ) throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
-
-    // XServiceInfo
-    virtual ::rtl::OUString SAL_CALL getImplementationName() throw (::com::sun::star::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException);
-    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames() throw (::com::sun::star::uno::RuntimeException);
-
-};
-
-#endif /* FACTORY_HXX */
diff --git a/toolkit/source/layout/flow.cxx b/toolkit/source/layout/flow.cxx
deleted file mode 100644
index 4bfd1b9..0000000
--- toolkit/source/layout/flow.cxx
+++ /dev/null
@@ -1,207 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "flow.hxx"
-
-#include <sal/macros.h>
-
-namespace layoutimpl
-{
-
-using namespace css;
-
-bool Flow::ChildData::isVisible()
-{
-    return xChild.is();
-}
-
-Flow::Flow()
-    : Container()
-    , mnSpacing( 0 )
-    , mbHomogeneous( false )
-{
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ),
-             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
-             &mbHomogeneous );
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Spacing" ),
-             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &mnSpacing );
-}
-
-void SAL_CALL
-Flow::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw (uno::RuntimeException, css::awt::MaxChildrenException)
-{
-    if ( xChild.is() )
-    {
-        ChildData *pData = new ChildData();
-        pData->xChild = xChild;
-        maChildren.push_back( pData );
-
-        setChildParent( xChild );
-        queueResize();
-    }
-}
-
-void SAL_CALL
-Flow::removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild )
-    throw (css::uno::RuntimeException)
-{
-    for ( std::list< ChildData * >::iterator it = maChildren.begin();
-          it != maChildren.end(); it++ )
-    {
-        if ( (*it)->xChild == xChild )
-        {
-            delete *it;
-            maChildren.erase( it );
-
-            unsetChildParent( xChild );
-            queueResize();
-            break;
-        }
-    }
-}
-
-css::uno::Sequence< css::uno::Reference < css::awt::XLayoutConstrains > > SAL_CALL
-Flow::getChildren()
-    throw (css::uno::RuntimeException)
-{
-    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
-    unsigned int i = 0;
-    for ( std::list< ChildData * >::iterator it = maChildren.begin();
-          it != maChildren.end(); it++, i++ )
-        children[i] = (*it)->xChild;
-
-    return children;
-}
-
-uno::Reference< beans::XPropertySet > SAL_CALL
-Flow::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& /*xChild*/ )
-    throw (uno::RuntimeException)
-{
-    return uno::Reference< beans::XPropertySet >();
-}
-
-css::awt::Size
-Flow::calculateSize( long nMaxWidth )
-{
-    long nNeedHeight = 0;
-
-    std::list<ChildData *>::const_iterator it;
-    mnEachWidth = 0;
-    // first pass, for homogeneous property
-    for (it = maChildren.begin(); it != maChildren.end(); it++)
-    {
-        if ( !(*it)->isVisible() )
-            continue;
-        (*it)->aRequisition = (*it)->xChild->getMinimumSize();
-        if ( mbHomogeneous )
-            mnEachWidth = SAL_MAX( mnEachWidth, (*it)->aRequisition.Width );
-    }
-
-    long nRowWidth = 0, nRowHeight = 0;
-    for (it = maChildren.begin(); it != maChildren.end(); it++)
-    {
-        if ( !(*it)->isVisible() )
-            continue;
-
-        awt::Size aChildSize = (*it)->aRequisition;
-        if ( mbHomogeneous )
-            aChildSize.Width = mnEachWidth;
-
-        if ( nMaxWidth && nRowWidth > 0 && nRowWidth + aChildSize.Width > nMaxWidth )
-        {
-            nRowWidth = 0;
-            nNeedHeight += nRowHeight;
-            nRowHeight = 0;
-        }
-        nRowHeight = SAL_MAX( nRowHeight, aChildSize.Height );
-        nRowWidth += aChildSize.Width;
-    }
-    nNeedHeight += nRowHeight;
-
-    return awt::Size( nRowWidth, nNeedHeight );
-}
-
-awt::Size SAL_CALL
-Flow::getMinimumSize() throw(uno::RuntimeException)
-{
-    return maRequisition = calculateSize( 0 );
-}
-
-sal_Bool SAL_CALL
-Flow::hasHeightForWidth()
-    throw(css::uno::RuntimeException)
-{
-    return true;
-}
-
-sal_Int32 SAL_CALL
-Flow::getHeightForWidth( sal_Int32 nWidth )
-    throw(css::uno::RuntimeException)
-{
-    return calculateSize( nWidth ).Height;
-}
-
-void SAL_CALL
-Flow::allocateArea( const css::awt::Rectangle &rArea )
-    throw (css::uno::RuntimeException)
-{
-    maAllocation = rArea;
-
-    std::list<ChildData *>::const_iterator it;
-    long nX = 0, nY = 0, nRowHeight = 0;
-    for (it = maChildren.begin(); it != maChildren.end(); it++)
-    {
-        ChildData *child = *it;
-        if ( !child->isVisible() )
-            continue;
-
-        awt::Size aChildSize( child->aRequisition );
-        if ( mbHomogeneous )
-            aChildSize.Width = mnEachWidth;
-
-        if ( nX > 0 && nX + aChildSize.Width > rArea.Width )
-        {
-            nX = 0;
-            nY += nRowHeight;
-            nRowHeight = 0;
-        }
-        nRowHeight = SAL_MAX( nRowHeight, aChildSize.Height );
-
-        allocateChildAt( child->xChild,
-                         awt::Rectangle( rArea.X + nX, rArea.Y + nY, aChildSize.Width, aChildSize.Height ) );
-
-        nX += aChildSize.Width;
-    }
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/flow.hxx b/toolkit/source/layout/flow.hxx
deleted file mode 100644
index 07a4d21..0000000
--- toolkit/source/layout/flow.hxx
+++ /dev/null
@@ -1,99 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_FLOW_HXX
-#define CORE_FLOW_HXX
-
-#include "container.hxx"
-
-#include <list>
-
-namespace layoutimpl
-{
-
-class Flow : public Container
-{
-protected:
-    // Box properties (i.e. affect all children)
-    sal_Int32 mnSpacing;
-    sal_Bool mbHomogeneous;
-
-public:
-    // Children properties
-    struct ChildData
-    {
-        css::awt::Size aRequisition;
-        css::uno::Reference< css::awt::XLayoutConstrains > xChild;
-        css::uno::Reference< css::beans::XPropertySet >    xProps;
-        bool isVisible();
-    };
-
-protected:
-    std::list< ChildData * > maChildren;
-    long mnEachWidth;  // on homogeneous, the width of every child
-
-public:
-    Flow();
-
-    // css::awt::XLayoutContainer
-    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
-    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException);
-
-    virtual css::uno::Sequence< css::uno::Reference
-                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
-        throw (css::uno::RuntimeException);
-
-    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
-        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException);
-
-    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException);
-
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL hasHeightForWidth()
-        throw(css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
-        throw(css::uno::RuntimeException);
-
-PROPHELPER_SET_INFO
-
-private:
-    // shared between getMinimumSize() and getHeightForWidth()
-    css::awt::Size calculateSize( long nMaxWidth );
-};
-
-} //  namespace layoutimpl
-
-#endif /*FLOW_CORE_HXX*/
diff --git a/toolkit/source/layout/helper.cxx b/toolkit/source/layout/helper.cxx
deleted file mode 100644
index 1e96643..0000000
--- toolkit/source/layout/helper.cxx
+++ /dev/null
@@ -1,573 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "helper.hxx"
-
-#include <assert.h>
-#include <list>
-#include <com/sun/star/awt/WindowAttribute.hpp>
-#include <com/sun/star/awt/XWindow.hpp>
-#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
-#include <toolkit/awt/vclxwindow.hxx>
-#include <tools/debug.hxx>
-
-#include "proplist.hxx"
-#include "layout/layoutcore.hxx"
-
-#if TEST_LAYOUT && !defined( DBG_UTIL )
-#include <cstdio>
-#undef DBG_ERROR
-#define DBG_ERROR printf
-#undef DBG_ERROR1
-#define DBG_ERROR1 printf
-#undef DBG_ERROR2
-#define DBG_ERROR2 printf
-#endif /* TEST_LAYOUT && !DBG_UTIL */
-
-namespace layoutimpl
-{
-using namespace com::sun::star;
-using rtl::OUString;
-
-uno::Reference< awt::XWindowPeer >
-getParent( uno::Reference< uno::XInterface > xRef )
-{
-    do
-    {
-        uno::Reference< awt::XWindowPeer > xPeer( xRef, uno::UNO_QUERY );
-        if ( xPeer.is() )
-            return xPeer;
-
-        uno::Reference< awt::XLayoutContainer > xCont( xRef, uno::UNO_QUERY );
-        if ( xCont.is() )
-            xRef = xCont->getParent();
-    }
-    while ( xRef.is() );
-
-    return uno::Reference< awt::XWindowPeer >();
-}
-
-#if 0
-static uno::Reference< awt::XWindowPeer >
-getToplevel( uno::Reference< uno::XInterface > xRef )
-{
-    uno::Reference< awt::XWindowPeer > xTop, i;
-    while ( ( i = uno::Reference< awt::XWindowPeer >( xRef, uno::UNO_QUERY ) ).is() )
-    {
-        xTop = i;
-
-        uno::Reference< awt::XLayoutContainer > xCont( xRef, uno::UNO_QUERY );
-        if ( xCont.is() )
-            xRef = xCont->getParent();
-        else
-            xRef = uno::Reference< awt::XWindowPeer >();
-    }
-
-    return xTop;
-}
-#endif
-
-}
-
-#include "bin.hxx"
-#include "box.hxx"
-#include "dialogbuttonhbox.hxx"
-#include "flow.hxx"
-#include "localized-string.hxx"
-#include "table.hxx"
-
-namespace layoutimpl
-{
-
-static uno::Reference< awt::XLayoutConstrains > ImplCreateWindow(
-    uno::Reference< uno::XInterface > xParent,
-    OUString aName, long WindowAttributes );
-
-uno::Reference< awt::XLayoutContainer >
-createContainer( const OUString &rName )
-{
-    uno::Reference< awt::XLayoutContainer > xPeer;
-
-    if ( rName.equalsAscii( "hbox" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new HBox() );
-    else if ( rName.equalsAscii( "vbox" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new VBox() );
-    else if ( rName.equalsAscii( "table" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new Table() );
-    else if ( rName.equalsAscii( "flow" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new Flow() );
-    else if ( rName.equalsAscii( "bin" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new Bin() );
-    else if ( rName.equalsAscii( "min-size" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new MinSize() );
-    else if ( rName.equalsAscii( "align" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new Align() );
-    else if ( rName.equalsAscii( "dialogbuttonhbox" ) )
-        xPeer = uno::Reference< awt::XLayoutContainer >( new DialogButtonHBox() );
-
-    return xPeer;
-}
-
-static uno::Reference< awt::XLayoutConstrains >
-createToolkitWidget( uno::Reference< awt::XToolkit > xToolkit,
-                     uno::Reference< uno::XInterface > xParent,
-                     const OUString &rName, long nProps )
-{
-    uno::Reference< awt::XLayoutConstrains > xPeer;
-    bool bToplevel = !xParent.is();
-
-    // UNO Control Widget
-    awt::WindowDescriptor desc;
-    if ( bToplevel )
-        desc.Type = awt::WindowClass_TOP;
-    else
-    {
-        desc.Type = awt::WindowClass_SIMPLE;
-
-#if 0
-        // top container -- a wrapper for framewindow -- is de-coupled
-        // from awt::XWindowPeer. So, getParent() fails at it.
-        uno::Reference< awt::XWindowPeer > xWinParent = getParent( xParent );
-#else
-        uno::Reference< awt::XWindowPeer > xWinParent( xParent, uno::UNO_QUERY );
-#endif
-        assert( xParent.is() );
-        assert( xWinParent.is() );
-        /*
-          With the new three layer instarr/rpath feature, when
-          prepending toolkit/unxlngx6.pro/lib or $SOLARVER/lib to
-          LD_LIBRARY_PATH, VCLXWindow::GetImplementation returns 0x0
-          vclxtoolkit::ImplCreateWindow failing to create any widget;
-          although it succeeds here.
-
-          While developing, one now must copy libtlx.so to
-          $OOO_INSTALL_PREFIX/openoffice.org/basis3.0/program/libtklx.so
-          each time.
-        */
-		VCLXWindow* pParentComponent = VCLXWindow::GetImplementation( xWinParent );
-        if ( !pParentComponent )
-            throw uno::RuntimeException(
-                OUString::createFromAscii( "parent has no implementation" ),
-                uno::Reference< uno::XInterface >() );
-        desc.Parent = xWinParent;
-    }
-
-    desc.ParentIndex = 0;
-    // debugging help ...
-    desc.Bounds.X = 0;
-    desc.Bounds.Y = 0;
-    desc.Bounds.Width = 300;
-    desc.Bounds.Height = 200;
-
-    desc.WindowAttributes = nProps;
-    desc.WindowServiceName = rName;
-
-    uno::Reference< awt::XWindowPeer > xWinPeer;
-    try
-    {
-        OSL_TRACE("Asking toolkit: %s", OUSTRING_CSTR( desc.WindowServiceName ) );
-        xWinPeer = xToolkit->createWindow( desc );
-        if ( !xWinPeer.is() )
-            throw uno::RuntimeException(
-                OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot create peer" ) ),
-                uno::Reference< uno::XInterface >() );
-        xPeer = uno::Reference< awt::XLayoutConstrains >( xWinPeer, uno::UNO_QUERY );
-    }
-    catch( uno::Exception & )
-    {
-        DBG_ERROR1( "Warning: %s is not a recognized type\n", OUSTRING_CSTR( rName ) );
-        return uno::Reference< awt::XLayoutConstrains >();
-    }
-
-    // default to visible, let then people change it on properties
-    if ( ! bToplevel )
-    {
-        uno::Reference< awt::XWindow> xWindow( xPeer, uno::UNO_QUERY );
-        if ( xWindow.is() )
-            xWindow->setVisible( true );
-    }
-    return xPeer;
-}
-
-uno::Reference< awt::XLayoutConstrains >
-createWidget( uno::Reference< awt::XToolkit > xToolkit,
-              uno::Reference< uno::XInterface > xParent,
-              const OUString &rName, long nProps )
-{
-    uno::Reference< awt::XLayoutConstrains > xPeer;
-
-    xPeer = uno::Reference< awt::XLayoutConstrains >(
-        createContainer( rName ), uno::UNO_QUERY );
-    if ( xPeer.is() )
-        return xPeer;
-
-    xPeer = ImplCreateWindow( xParent, rName, nProps );
-    if ( xPeer.is() )
-        return xPeer;
-
-#if FIXED_INFO
-    OUString tName = rName;
-    // FIXME
-    if ( rName.equalsAscii( "fixedinfo" ) )
-        tName = OUString::createFromAscii( "fixedtext" );
-    xPeer = createToolkitWidget( xToolkit, xParent, tName, nProps );
-#else
-    xPeer = createToolkitWidget( xToolkit, xParent, rName, nProps );
-#endif
-
-    return xPeer;
-}
-
-PropHelper::PropHelper() : LockHelper()
-                         , cppu::OPropertySetHelper( maBrdcstHelper )
-                         , pHelper( NULL )
-{
-}
-
-void
-PropHelper::addProp (const char *pName, sal_Int32 nNameLen, rtl_TextEncoding e,
-                     uno::Type aType, void *pPtr)
-{
-    // this sucks rocks for effiency ...
-    PropDetails aDetails;
-    aDetails.aName = rtl::OUString::intern( pName, nNameLen, e );
-    aDetails.aType = aType;
-    aDetails.pValue = pPtr;
-    maDetails.push_back( aDetails );
-}
-
-cppu::IPropertyArrayHelper & SAL_CALL
-PropHelper::getInfoHelper()
-{
-    if ( ! pHelper )
-    {
-        uno::Sequence< beans::Property > aProps( maDetails.size() );
-        for ( unsigned int i = 0; i < maDetails.size(); i++)
-        {
-            aProps[i].Name = maDetails[i].aName;
-            aProps[i].Type = maDetails[i].aType;
-            aProps[i].Handle = i;
-            aProps[i].Attributes = 0;
-        }
-        pHelper = new cppu::OPropertyArrayHelper( aProps, false /* fixme: faster ? */ );
-
-    }
-    return *pHelper;
-}
-
-sal_Bool SAL_CALL
-PropHelper::convertFastPropertyValue(
-    uno::Any & rConvertedValue,
-    uno::Any & rOldValue,
-    sal_Int32 nHandle,
-    const uno::Any& rValue )
-    throw (lang::IllegalArgumentException)
-{
-    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
-
-    // FIXME: no Any::getValue ...
-    getFastPropertyValue( rOldValue, nHandle );
-    if ( rOldValue != rValue )
-    {
-        rConvertedValue = rValue;
-        return sal_True; // changed
-    }
-    else
-    {
-        rConvertedValue.clear();
-        rOldValue.clear();
-    }
-    return sal_False;
-}
-
-
-void SAL_CALL
-PropHelper::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle,
-                                              const uno::Any& rValue )
-    throw (uno::Exception)
-{
-    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
-
-    const PropDetails &rInfo = maDetails[ nHandle ];
-
-    uno_type_assignData( rInfo.pValue, rInfo.aType.getTypeLibType(),
-                         rValue.pData, rValue.pType,
-                         0, 0, 0 );
-
-    if ( mpListener )
-        mpListener->propertiesChanged();
-}
-
-void SAL_CALL
-PropHelper::getFastPropertyValue( uno::Any& rValue,
-                                  sal_Int32 nHandle ) const
-{
-    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
-    const PropDetails &rInfo = maDetails[ nHandle ];
-#if 0
-    switch ( rInfo.aType.getTypeClass() )
-    {
-#define MAP(classtype,ctype)                        \
-        case uno::TypeClass_##classtype:       \
-            rValue <<= *(ctype *)(rInfo.pValue);    \
-        break
-        MAP( DOUBLE, double );
-        MAP( SHORT, sal_Int16 );
-        MAP( LONG,  sal_Int32 );
-        MAP( UNSIGNED_SHORT, sal_uInt16 );
-        MAP( UNSIGNED_LONG, sal_uInt32 );
-        MAP( STRING, ::rtl::OUString );
-        default:
-            DBG_ERROR( "ERROR: unknown type to map!" );
-            break;
-    }
-#undef MAP
-#endif
-    rValue.setValue( rInfo.pValue, rInfo.aType );
-}
-
-::com::sun::star::uno::Any
-PropHelper::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
-{
-    return OPropertySetHelper::queryInterface( rType );
-}
-
-} // namespace layoutimpl
-
-#include <awt/vclxbutton.hxx>
-#include <awt/vclxdialog.hxx>
-#include <awt/vclxfixedline.hxx>
-#include <awt/vclxplugin.hxx>
-#include <awt/vclxscroller.hxx>
-#include <awt/vclxsplitter.hxx>
-#include <awt/vclxtabcontrol.hxx>
-#include <awt/vclxtabpage.hxx>
-#include <toolkit/awt/vclxtoolkit.hxx>
-#include <toolkit/awt/vclxwindow.hxx>
-#include <vcl/button.hxx>
-#include <vcl/dialog.hxx>
-#include <vcl/fixed.hxx>
-#include <vcl/tabctrl.hxx>
-#include <vcl/tabpage.hxx>
-
-#include <typeinfo>
-
-namespace layoutimpl
-{
-
-TOOLKIT_DLLPUBLIC Window* global_parent;
-
-uno::Reference< awt::XLayoutConstrains > ImplCreateWindow(
-    uno::Reference< uno::XInterface > xParent,
-    OUString aName, long WindowAttributes )
-{
-    VCLXWindow *pNewComp = NULL;
-    Window     *pNewWindow = NULL;
-    Window     *pParent = NULL;
-    uno::Reference< awt::XLayoutConstrains > xRef;
-
-    VCLXWindow* pParentComponent = VCLXWindow::GetImplementation( xParent );
-    if ( pParentComponent )
-        pParent = pParentComponent->GetWindow();
-
-    if ( aName.equalsAscii( "dialog" ) )
-    {
-        if ( pParent == NULL )
-            pParent = DIALOG_NO_PARENT;
-        pNewWindow = new Dialog( pParent,
-                                 ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXDialog();
-
-        WindowAttributes ^= awt::WindowAttribute::SHOW;
-    }
-    else if ( aName.equalsAscii( "modaldialog" ) )
-    {
-        if ( pParent == NULL )
-            pParent = DIALOG_NO_PARENT;
-        pNewWindow = new ModalDialog( pParent,
-                                      ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXDialog();
-
-        WindowAttributes ^= awt::WindowAttribute::SHOW;
-    }
-    else if ( aName.equalsAscii( "tabcontrol" ) )
-    {
-        pNewWindow = new TabControl( pParent,
-                                     ImplGetWinBits( WindowAttributes, WINDOW_TABCONTROL ) );
-        pNewComp = new layoutimpl::VCLXTabControl();
-    }
-    else if ( aName.equalsAscii( "scroller" ) )
-    {
-        // used FixedImage because I just want some empty non-intrusive widget
-        pNewWindow = new FixedImage( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXScroller();
-    }
-    else if ( aName.equalsAscii( "hsplitter" ) || aName.equalsAscii( "vsplitter" ) )
-    {
-        pNewWindow = new FixedImage( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXSplitter( aName.equalsAscii( "hsplitter" ) );
-    }
-    else if ( aName.equalsAscii( "hfixedline" ) || aName.equalsAscii( "vfixedline" ) )
-    {
-        WinBits nStyle = ImplGetWinBits( WindowAttributes, 0 );
-        nStyle ^= WB_HORZ;
-        if ( aName.equalsAscii( "hfixedline" ) )
-            nStyle |= WB_HORZ;
-        else
-            nStyle |= WB_VERT;
-        pNewWindow = new FixedLine( pParent, nStyle );
-        pNewComp = new layoutimpl::VCLXFixedLine();
-    }
-    else if ( aName.equalsAscii( "okbutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXOKButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "cancelbutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXCancelButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "yesbutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXYesButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "nobutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXNoButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "retrybutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXRetryButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "ignorebutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXIgnoreButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "resetbutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXResetButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "applybutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXApplyButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "helpbutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXHelpButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "morebutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXMoreButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "advancedbutton" ) )
-    {
-        pNewWindow = new PushButton( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::VCLXAdvancedButton( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "plugin" ) )
-    {
-        pNewWindow = new Control( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        OSL_TRACE( "%s: parent=%p (%s)\n", __FUNCTION__, pParent, typeid( *pParent ).name() );
-        pNewComp = new layoutimpl::VCLXPlugin( pNewWindow, ImplGetWinBits( WindowAttributes, 0 ) );
-    }
-    else if ( aName.equalsAscii( "tabpage" ) )
-    {
-        if ( !pParent )
-            pParent = layout::TabPage::global_parent;
-
-        //pNewWindow = new TabPage( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        WindowAttributes ^= awt::WindowAttribute::SHOW;
-        WinBits nStyle = ImplGetWinBits( WindowAttributes, 0 );
-        nStyle |= WB_HIDE;
-        //nStyle |= WB_NODIALOGCONTROL;
-        //nStyle |= WB_DIALOGCONTROL;
-        //nStyle = 2147483714L;
-        OSL_TRACE( "in bits=%lu", nStyle );
-        pNewWindow = new TabPage( pParent, nStyle );
-        pNewComp = new VCLXTabPage( pNewWindow );
-    }
-    else if ( aName.equalsAscii( "string" ) )
-    {
-        // FIXME: move <string>s.text to simple map<string> in root?
-        WindowAttributes &= ~awt::WindowAttribute::SHOW;
-        pNewWindow = new Window( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
-        pNewComp = new layoutimpl::LocalizedString();
-    }
-
-    if ( !pNewWindow )
-        return xRef;
-
-    pNewWindow->SetCreatedWithToolkit( sal_True );
-    if ( pNewComp )
-        pNewComp->SetCreatedWithToolkit( TRUE );
-    xRef = pNewComp;
-    pNewWindow->SetComponentInterface( pNewComp );
-    if ( WindowAttributes & awt::WindowAttribute::SHOW )
-        pNewWindow->Show();
-
-    return xRef;
-}
-
-} // namespace layoutimpl
-
-// Avoid polluting the rest of the code with vcl linkage pieces ...
-
-#include <vcl/imagerepository.hxx>
-#include <vcl/bitmapex.hxx>
-#include <vcl/graph.hxx>
-
-namespace layoutimpl
-{
-
-uno::Reference< graphic::XGraphic > loadGraphic( const char *pName )
-{
-    BitmapEx aBmp;
-
-    OUString aStr( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US );
-    if ( aStr.compareToAscii( ".uno:" ) == 0 )
-        aStr = aStr.copy( 5 ).toAsciiLowerCase();
-
-    if ( !vcl::ImageRepository::loadImage( OUString::createFromAscii( pName ), aBmp, true ) )
-        return uno::Reference< graphic::XGraphic >();
-
-    return Graphic( aBmp ).GetXGraphic();
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/helper.hxx b/toolkit/source/layout/helper.hxx
deleted file mode 100644
index 8c50a80..0000000
--- toolkit/source/layout/helper.hxx
+++ /dev/null
@@ -1,155 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef HELPER_HXX
-#define HELPER_HXX
-
-#include <toolkit/dllapi.h>
-#include <vector>
-
-#include <com/sun/star/awt/XLayoutConstrains.hpp>
-#include <com/sun/star/awt/XLayoutContainer.hpp>
-#include <com/sun/star/awt/XVclWindowPeer.hpp>
-#include <com/sun/star/xml/input/XRoot.hpp>
-#include <cppuhelper/implbase1.hxx>
-#include <cppuhelper/propshlp.hxx>
-#include <rtl/ustring.hxx>
-
-namespace layoutimpl
-{
-
-namespace css = ::com::sun::star;
-
-/* ChildProps -- a helper to set child properties for the XLayoutContainer interface. */
-
-class LockHelper
-{
-public:
-    osl::Mutex               maGuard;
-    cppu::OBroadcastHelper maBrdcstHelper;
-    LockHelper() : maBrdcstHelper( maGuard )
-    {
-    }
-};
-
-class PropHelper : public LockHelper
-                 , public cppu::OPropertySetHelper
-                 , public cppu::OWeakObject
-{
-    cppu::OPropertyArrayHelper *pHelper;
-
-    struct PropDetails
-    {
-        rtl::OUString  aName;
-        css::uno::Type aType;
-        void          *pValue;
-    };
-    std::vector< PropDetails > maDetails;
-
-protected:
-    void addProp( char const *pName, sal_Int32 nNameLen, rtl_TextEncoding e,
-                  css::uno::Type aType, void *pPtr );
-
-public:
-    PropHelper();
-
-    // com::sun::star::uno::XInterface
-    void SAL_CALL acquire() throw() { OWeakObject::acquire(); }
-    void SAL_CALL release() throw() { OWeakObject::release(); }
-    ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
-
-    // cppu::OPropertySetHelper
-    virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
-    virtual sal_Bool SAL_CALL convertFastPropertyValue( css::uno::Any &,
-                                                        css::uno::Any &, sal_Int32 nHandle, const css::uno::Any & )
-        throw(css::lang::IllegalArgumentException);
-    virtual void SAL_CALL setFastPropertyValue_NoBroadcast( sal_Int32 nHandle,
-                                                            const css::uno::Any& rValue ) throw (css::uno::Exception);
-    using OPropertySetHelper::getFastPropertyValue;
-    virtual void SAL_CALL getFastPropertyValue( css::uno::Any& rValue,
-                                                sal_Int32 nHandle ) const;
-
-    // you -must- use this macro in sub-classes that define new properties.
-    // NB. 'static' ...
-    // com::sun::star::beans::XMultiPropertySet
-#define PROPHELPER_SET_INFO \
-    css::uno::Reference< css::beans::XPropertySetInfo > SAL_CALL \
-    getPropertySetInfo() throw(css::uno::RuntimeException) \
-    { \
-        static css::uno::Reference< css::beans::XPropertySetInfo > xInfo( \
-            createPropertySetInfo( getInfoHelper() ) ); \
-        return xInfo; \
-    }
-    PROPHELPER_SET_INFO
-
-    struct Listener
-    {
-        virtual void propertiesChanged() = 0;
-    };
-    void setChangeListener( Listener *pListener )
-    {
-        mpListener = pListener;
-    }
-
-protected:
-    Listener *mpListener;
-};
-
-css::uno::Any anyFromString (const rtl::OUString &value, const css::uno::Type &type);
-
-// The native widgets wrapper hierarchy may not reflect that of the layout
-// hierarchy as some containers don't have an associated native widget.
-// Use this function to get the native parent of the given peer.
-css::uno::Reference< css::awt::XWindowPeer >
-getParent( css::uno::Reference< css::uno::XInterface > xPeer );
-
-
-struct WidgetFactory
-{
-    virtual css::uno::Reference< css::awt::XLayoutConstrains >
-    createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-                  css::uno::Reference< css::uno::XInterface > xParent,
-                  const rtl::OUString &rName, long nProps );
-};
-
-// A local factory method - should use UNO services in due course
-css::uno::Reference< css::awt::XLayoutConstrains > TOOLKIT_DLLPUBLIC
-createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-              css::uno::Reference< css::uno::XInterface > xParent,
-              const rtl::OUString &rName, long nProps );
-
-// Factory for containers (not visible ones)
-css::uno::Reference< css::awt::XLayoutContainer >
-createContainer( const rtl::OUString &rName );
-
-} // namespace layoutimpl
-
-#endif /* HELPER_HXX */
diff --git a/toolkit/source/layout/import.cxx b/toolkit/source/layout/import.cxx
deleted file mode 100644
index 47857e6..0000000
--- toolkit/source/layout/import.cxx
+++ /dev/null
@@ -1,249 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "import.hxx"
-
-#include <com/sun/star/awt/XButton.hpp>
-#include <com/sun/star/awt/XDialog2.hpp>
-#include <vcl/image.hxx>
-#include <tools/debug.hxx>
-
-#include "root.hxx"
-#include "helper.hxx"
-#include "dialogbuttonhbox.hxx"
-
-// Hmm...
-#include "layout/layout.hxx"
-#include "layout/layoutcore.hxx"
-
-#define XMLNS_LAYOUT_URI    "http://openoffice.org/2007/layout"
-#define XMLNS_CONTAINER_URI "http://openoffice.org/2007/layout/container"
-
-namespace layoutimpl
-{
-using namespace css;
-
-using ::rtl::OUString;
-
-ElementBase::~ElementBase()
-SAL_THROW( () )
-{
-    //delete mpImport;
-    //mpImport = 0;
-}
-
-//** parser
-WidgetElement::WidgetElement ( sal_Int32 nUid, const OUString &rName,
-                               uno::Reference <xml::input::XAttributes> const &attributes,
-                               ElementBase *pParent,
-                               ImportContext *pImport)
-SAL_THROW (())
-: ElementBase( nUid, rName, attributes, pParent, pImport )
-{
-    OUString name = rName.toAsciiLowerCase();
-
-    PropList aProps;
-    propsFromAttributes( attributes, aProps, pImport->XMLNS_LAYOUT_UID );
-
-    OUString aId;
-    findAndRemove( "id", aProps, aId );
-    OUString aLang;
-    findAndRemove( "xml-lang", aProps, aLang );
-
-    {
-//DEBUG
-        uno::Reference< awt::XLayoutConstrains > xParent;
-        if ( pParent )
-            xParent = ((WidgetElement *) pParent)->mpWidget->getPeer();
-
-
-        mpWidget = pImport->mrRoot.create( aId, name,
-                                           getAttributeProps( aProps ), uno::Reference< awt::XLayoutContainer >( xParent, uno::UNO_QUERY ) );
-
-    }
-
-    // TODO: handle with non-existing widgets
-
-    mpWidget->setProperties( aProps );
-
-    uno::Reference< awt::XDialog2 > xDialog( mpWidget->getPeer(), uno::UNO_QUERY );
-    if ( xDialog.is() )
-    {
-        OUString aTitle;
-        if ( findAndRemove( "title", aProps, aTitle ) )
-            xDialog->setTitle( aTitle );
-    } // DEBUG:
-    else if ( pParent == NULL )
-    {
-        DBG_ERROR( "Fatal error: top node isn't a dialog" );
-    }
-
-#if 0
-    // Hack moved to proplist.cxx
-    OUString aGraphic;
-    if ( findAndRemove( "graphic", aProps, aGraphic ) )
-        //if ( layout::FixedImage *i = dynamic_cast<layout::FixedImage *> ( mpWidget->getPeer().get() ) )
-        // FIXME: huh? XImageProducer::complete( XImageConsumer )
-        //i->setImage( Image( loadGraphic( OUSTRING_CSTR( aGraphic ) ) ) );
-        mpWidget->setProperty( OUString::createFromAscii( "graphic" ),
-                               loadGraphic( OUSTRING_CSTR( aGraphic ) ) );
-#endif
-
-    OUString aOrdering;
-    if ( findAndRemove( "ordering", aProps, aOrdering ) )
-        if ( DialogButtonHBox *b = dynamic_cast<DialogButtonHBox *> ( mpWidget->getPeer().get() ) )
-            b->setOrdering ( aOrdering );
-
-#ifdef IMPORT_RADIOGROUP
-    bool bSetRadioGroup, bSetTitle;
-    OUString aRadioGroup, aTitle;
-    bSetRadioGroup = findAndRemove( "radiogroup", aProps, aRadioGroup );
-    bSetTitle = findAndRemove( "title", aProps, aTitle );
-
-    setProperties( mxPeer, aProps );
-
-    // we need to add radio buttons to the group after their properties are
-    // set, so we can check if they should be the one selected by default or not.
-    // And the state changed event isn't fired when changing properties.
-    if ( bSetRadioGroup )
-    {
-        static int i = 0;
-        i++;
-        uno::Reference< awt::XRadioButton > xRadio( mxPeer, uno::UNO_QUERY );
-        if ( xRadio.is() )
-            pImport->mxRadioGroups.addItem( aRadioGroup, xRadio );
-    }
-    if ( bSetTitle )
-    {
-        uno::Reference< awt::XDialog2 > xDialog( mxPeer, uno::UNO_QUERY );
-        if ( xDialog.is() )
-            xDialog->setTitle( aTitle );
-    }
-#endif
-}
-
-WidgetElement::~WidgetElement()
-{
-    //delete mpWidget;
-    //mpWidget = 0;
-}
-
-uno::Reference <xml::input::XElement>
-WidgetElement::startChildElement ( sal_Int32 nUid, OUString const &name,
-                                   uno::Reference <xml::input::XAttributes> const &attributes )
-    throw( xml::sax::SAXException, uno::RuntimeException )
-{
-    // Adding a child to the widget
-    WidgetElement *pChild = new WidgetElement ( nUid, name, attributes, this, mpImport );
-
-    if ( !mpWidget->addChild( pChild->mpWidget ) )
-    {
-        DBG_ERROR2( "ERROR: cannot add %s to container %s, container full", OUSTRING_CSTR( name ), OUSTRING_CSTR( getLocalName() ) );
-        throw xml::sax::SAXException();
-    }
-
-    PropList aProps;
-    propsFromAttributes( attributes, aProps, mpImport->XMLNS_CONTAINER_UID );
-    mpWidget->setChildProperties( pChild->mpWidget, aProps );
-
-    return pChild;
-}
-
-// Support Ivo Hinkelmann's move label/text/title attribute to CONTENT
-// transex3 hack.
-void SAL_CALL
-WidgetElement::characters( OUString const& rChars )
-    throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-{
-    if ( mpWidget && rChars.trim().getLength() )
-    {
-        uno::Reference< awt::XDialog2 > xDialog( mpWidget->getPeer(), uno::UNO_QUERY );
-        uno::Reference< awt::XButton > xButton( mpWidget->getPeer(), uno::UNO_QUERY );
-        if ( xDialog.is() )
-            xDialog->setTitle( rChars );
-        else if ( xButton.is() )
-            mpWidget->setProperty( OUString::createFromAscii( "label" ), rChars );
-        else
-            mpWidget->setProperty( OUString::createFromAscii( "text" ), rChars );
-    }
-}
-// ---- ElementBase ----
-
-ElementBase::ElementBase( sal_Int32 nUid, OUString const & rLocalName,
-                          uno::Reference< xml::input::XAttributes > const & xAttributes,
-                          ElementBase* pParent,
-                          ImportContext* pImport )
-SAL_THROW(())
-: mpImport( pImport )
-    , mpParent( pParent )
-    , mnUid( nUid )
-    , maLocalName( rLocalName )
-    , mxAttributes( xAttributes )
-{
-}
-
-// ---- ImportContext ----
-
-void ImportContext::startDocument(
-    uno::Reference< xml::input::XNamespaceMapping > const & xNamespaceMapping )
-    throw (xml::sax::SAXException, uno::RuntimeException)
-{
-    XMLNS_LAYOUT_UID = xNamespaceMapping->getUidByUri(
-        OUString( RTL_CONSTASCII_USTRINGPARAM( XMLNS_LAYOUT_URI ) ) );
-    XMLNS_CONTAINER_UID = xNamespaceMapping->getUidByUri(
-        OUString( RTL_CONSTASCII_USTRINGPARAM( XMLNS_CONTAINER_URI ) ) );
-}
-
-ToplevelElement::ToplevelElement (OUString const &rName,
-                                  uno::Reference <xml::input::XAttributes> const &xAttributes,
-                                  ImportContext *pImport)
-SAL_THROW(())
-: WidgetElement( 0, rName, xAttributes, NULL, pImport )
-{
-}
-
-ToplevelElement::~ToplevelElement()
-{
-}
-
-uno::Reference< xml::input::XElement > ImportContext::startRootElement(
-    sal_Int32 nUid, OUString const & rLocalName,
-    uno::Reference< xml::input::XAttributes > const & xAttributes )
-    throw (xml::sax::SAXException, uno::RuntimeException)
-{
-    if ( XMLNS_LAYOUT_UID != nUid )
-        throw xml::sax::SAXException(
-            OUString( RTL_CONSTASCII_USTRINGPARAM( "invalid namespace!" ) ),
-            uno::Reference< uno::XInterface >(), uno::Any() );
-        return new ToplevelElement( rLocalName, xAttributes, this );
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/import.hxx b/toolkit/source/layout/import.hxx
deleted file mode 100644
index e6d7e51..0000000
--- toolkit/source/layout/import.hxx
+++ /dev/null
@@ -1,316 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef IMPORT_HXX
-#define IMPORT_HXX
-
-#include <map>
-#include <list>
-#define _BACKWARD_BACKWARD_WARNING_H 1
-#include <hash_map>
-
-#include <com/sun/star/xml/input/XRoot.hpp>
-#include <cppuhelper/implbase1.hxx>
-
-namespace layoutimpl
-{
-class LayoutRoot;
-class LayoutWidget;
-namespace css = ::com::sun::star;
-
-/* blocks under IMPORT_RADIOGROUP are marked for deletion.
-   The use of it is to synchronize radio buttons into groups.
-   But toolkit doesn't fire toggle events when toggled from the code.
-   Another approach is to implement our own XRadioButton from our
-   internal toolkit. We could have some singleton where they would
-   register... We would need to add another attribute...
-*/
-
-#ifdef IMPORT_RADIOGROUP
-#include <com/sun/star/awt/XRadioButton.hpp>
-class RadioGroups
-{
-public:
-    RadioGroups()
-    {
-    }
-
-    void addItem( rtl::OUString id, css::uno::Reference< css::awt::XRadioButton > xRadio )
-        throw (css::uno::RuntimeException)
-    {
-        if ( ! xRadio.is() )
-            throw css::uno::RuntimeException();
-
-        css::uno::Reference< RadioGroup > group;
-        RadioGroupsMap::iterator it = mxRadioGroups.find( id );
-        if ( it == mxRadioGroups.end() )
-        {
-            group = css::uno::Reference< RadioGroup > ( new RadioGroup() );
-            mxRadioGroups [id] = group;
-        }
-        else
-            group = it->second;
-        group->addItem( xRadio );
-    }
-
-private:
-    class RadioGroup : public ::cppu::WeakImplHelper1< css::awt::XItemListener >
-    {
-    public:
-        RadioGroup()
-        {
-        }
-
-        void addItem( css::uno::Reference< css::awt::XRadioButton > xRadio )
-        {
-            if ( ! mxSelectedRadio.is() )
-            {
-                xRadio->setState( true );
-                mxSelectedRadio = xRadio;
-            }
-            else if ( xRadio->getState() )
-            {
-                mxSelectedRadio->setState( false );
-                mxSelectedRadio = xRadio;
-            }
-
-            xRadio->addItemListener( this );
-            mxRadios.push_back (xRadio);
-        }
-
-    private:
-        typedef std::list< css::uno::Reference< css::awt::XRadioButton > > RadioButtonsList;
-        RadioButtonsList mxRadios;
-        css::uno::Reference< css::awt::XRadioButton > mxSelectedRadio;
-
-        // awt::XItemListener
-        void itemStateChanged( const com::sun::star::awt::ItemEvent& e)
-            throw (css::uno::RuntimeException)
-        {
-            if ( e.Selected )
-            {
-                mxSelectedRadio->setState( false );
-                // the only radio button selected would be the one that fired the event
-                for ( RadioButtonsList::iterator it = mxRadios.begin();
-                      it != mxRadios.end(); it++ )
-                    if ( (*it)->getState() )
-                    {
-                        mxSelectedRadio = *it;
-                        break;
-                    }
-            }
-        }
-
-        // lang::XEventListener
-        void SAL_CALL disposing( const css::lang::EventObject& )
-            throw (css::uno::RuntimeException)
-        {
-        }
-    };
-
-    // each RadioGroup will stay alive after RadioGroups die with the ImportContext
-    // because they are referenced by every XRadioButton through the listener
-    typedef std::map< rtl::OUString, css::uno::Reference< RadioGroup > > RadioGroupsMap;
-    RadioGroupsMap mxRadioGroups;
-};
-#endif
-
-#if 0
-// generator
-class Widget
-{
-public:
-    Widget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-            css::uno::Reference< css::awt::XWindow > xToplevel,
-            rtl::OUString unoName, long attrbs );
-    virtual ~Widget();
-
-    virtual void setProperties( const PropList &rProps );
-
-    virtual bool addChild( Widget *pChild );
-    virtual void setChildProperties( Widget *pChild, const PropList &rProps );
-
-    inline css::uno::Reference< css::awt::XLayoutConstrains > getPeer()
-    { return mxWidget; }
-
-    inline css::uno::Reference< css::awt::XLayoutConstrains > getContainer()
-    { return mxContainer; }
-
-protected:
-    css::uno::Reference< css::awt::XLayoutConstrains > mxWidget;
-    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
-};
-
-class Root
-{
-public:
-    Root( css::uno::Reference< css::awt::XToolkit > xToolkit )
-        : mxToolkit( xToolkit ) {}
-    ~Root();
-
-    virtual Widget *create( rtl::OUString id, const rtl::OUString unoName, long attrbs );
-
-    css::uno::Reference< css::awt::XLayoutConstrains > getById( rtl::OUString id );
-    inline css::uno::Reference< css::awt::XLayoutConstrains > getToplevel();
-
-protected:
-    css::uno::Reference< css::awt::XToolkit > mxToolkit;
-    Widget *mpToplevel;
-
-    typedef std::hash_map< rtl::OUString, css::uno::Reference< css::awt::XLayoutConstrains >,
-                           rtl::OUStringHash > ItemHash;
-    ItemHash maItems;
-};
-#endif
-
-// parser
-class ImportContext : public ::cppu::WeakImplHelper1< css::xml::input::XRoot >
-{
-public:
-    sal_Int32 XMLNS_LAYOUT_UID, XMLNS_CONTAINER_UID;
-    LayoutRoot &mrRoot; // switch to XNameContainer ref ?
-#ifdef IMPORT_RADIOGROUP
-    RadioGroups mxRadioGroups;
-#endif
-
-    inline ImportContext( LayoutRoot &rRoot ) SAL_THROW( () )
-        : mrRoot( rRoot ) {}
-    virtual ~ImportContext() {}
-
-    // XRoot
-    virtual void SAL_CALL startDocument(
-        css::uno::Reference< css::xml::input::XNamespaceMapping >
-        const & xNamespaceMapping )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
-    virtual void SAL_CALL endDocument()
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-    virtual void SAL_CALL processingInstruction(
-        ::rtl::OUString const & /* rTarget */, ::rtl::OUString const & /* rData */ )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-    virtual void SAL_CALL setDocumentLocator(
-        css::uno::Reference< css::xml::sax::XLocator > const & /* xLocator */ )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-    virtual css::uno::Reference< css::xml::input::XElement >
-    SAL_CALL startRootElement(
-        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
-        css::uno::Reference<css::xml::input::XAttributes > const & xAttributes )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
-};
-
-class ElementBase : public ::cppu::WeakImplHelper1< css::xml::input::XElement >
-{
-protected:
-    ImportContext *mpImport;
-/* TODO: check if all this memebers are needed. */
-    ElementBase   *mpParent;
-    sal_Int32      mnUid;
-
-    ::rtl::OUString maLocalName;
-    css::uno::Reference< css::xml::input::XAttributes > mxAttributes;
-public:
-    ElementBase(
-        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
-        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
-        ElementBase * pParent, ImportContext * pImport )
-    SAL_THROW( () );
-    virtual ~ElementBase() SAL_THROW(());
-
-    // XElement
-    virtual css::uno::Reference<css::xml::input::XElement> SAL_CALL getParent()
-        throw (css::uno::RuntimeException)
-    { return static_cast< css::xml::input::XElement * >( mpParent ); }
-    virtual ::rtl::OUString SAL_CALL getLocalName() throw (css::uno::RuntimeException)
-    { return maLocalName; }
-    virtual sal_Int32 SAL_CALL getUid() throw (css::uno::RuntimeException)
-    { return mnUid; }
-    virtual css::uno::Reference< css::xml::input::XAttributes >
-    SAL_CALL getAttributes() throw (css::uno::RuntimeException)
-    { return mxAttributes; }
-
-    virtual void SAL_CALL ignorableWhitespace(
-        ::rtl::OUString const & /* rWhitespaces */ )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-    virtual void SAL_CALL characters( ::rtl::OUString const & /* rChars */ )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-    virtual void SAL_CALL processingInstruction(
-        ::rtl::OUString const & /* Target */, ::rtl::OUString const & /* Data */ )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-
-    virtual css::uno::Reference< css::xml::input::XElement >
-    SAL_CALL startChildElement(
-        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
-        css::uno::Reference<css::xml::input::XAttributes > const & xAttributes )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException) = 0;
-    virtual void SAL_CALL endElement()
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
-    { /* ignore */ }
-};
-
-class WidgetElement : public ElementBase
-{
-protected:
-    LayoutWidget *mpWidget;
-
-public:
-    WidgetElement( sal_Int32 nUid, rtl::OUString const &name,
-                   css::uno::Reference< css::xml::input::XAttributes > const &attributes,
-                   ElementBase *parent, ImportContext *import ) SAL_THROW (());
-
-    ~WidgetElement();
-
-
-    virtual css::uno::Reference< css::xml::input::XElement> SAL_CALL
-    startChildElement (sal_Int32 id, rtl::OUString const &name,
-                       css::uno::Reference< css::xml::input::XAttributes > const &attributes)
-        throw( css::xml::sax::SAXException, css::uno::RuntimeException );
-    virtual void SAL_CALL characters( ::rtl::OUString const & /* rChars */ )
-        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
-};
-
-class ToplevelElement : public WidgetElement
-{
-public:
-    ToplevelElement( rtl::OUString const &name,
-                     css::uno::Reference< css::xml::input::XAttributes > const &attributes,
-                     ImportContext *import ) SAL_THROW (());
-    ~ToplevelElement();
-};
-
-
-} // namespace layoutimpl
-
-#endif /* IMPORT_HXX */
diff --git a/toolkit/source/layout/localized-string.cxx b/toolkit/source/layout/localized-string.cxx
deleted file mode 100644
index 9bc9df3..0000000
--- toolkit/source/layout/localized-string.cxx
+++ /dev/null
@@ -1,87 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 51 Franklin Street, 5th Floor, Boston,
- *    MA  02110-1301  USA
- *
- ************************************************************************/
-
-#include "localized-string.hxx"
-
-#include <toolkit/helper/property.hxx>
-#include <vcl/window.hxx>
-
-namespace layoutimpl
-{
-
-namespace css = ::com::sun::star;
-using namespace css;
-using rtl::OUString;
-
-LocalizedString::LocalizedString()
-    : VCLXWindow()
-{
-}
-
-void LocalizedString::ImplGetPropertyIds( std::list< sal_uInt16 > &ids )
-{
-    PushPropertyIds( ids, BASEPROPERTY_TEXT, 0);
-    VCLXWindow::ImplGetPropertyIds( ids );
-}
-
-// XInterface
-uno::Any LocalizedString::queryInterface( uno::Type const& rType )
-    throw(uno::RuntimeException)
-{
-    uno::Any aRet = ::cppu::queryInterface( rType,
-                                            SAL_STATIC_CAST( awt::XFixedText*, this ) );
-    return (aRet.hasValue() ? aRet : VCLXWindow::queryInterface( rType ));
-}
-
-void LocalizedString::setText( OUString const& s )
-    throw(uno::RuntimeException)
-{
-    ::vos::OGuard aGuard( GetMutex() );
-
-    if ( Window *w = GetWindow() )
-        return w->SetText( s );
-}
-
-OUString LocalizedString::getText()
-    throw(uno::RuntimeException)
-{
-    ::vos::OGuard aGuard( GetMutex() );
-
-    if ( Window *w = GetWindow() )
-        return w->GetText();
-    return OUString();
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/localized-string.hxx b/toolkit/source/layout/localized-string.hxx
deleted file mode 100644
index bbb3896..0000000
--- toolkit/source/layout/localized-string.hxx
+++ /dev/null
@@ -1,84 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 51 Franklin Street, 5th Floor, Boston,
- *    MA  02110-1301  USA
- *
- ************************************************************************/
-
-#ifndef CORE_LOCALIZED_STRING_HXX
-#define CORE_LOCALIZED_STRING_HXX
-
-#include <com/sun/star/awt/XFixedText.hpp>
-#include <toolkit/awt/vclxwindow.hxx>
-
-namespace layoutimpl
-{
-namespace css = ::com::sun::star;
-
-// FIXME: misuse XFixedText interface for simple string
-class LocalizedString :	public css::awt::XFixedText
-                      , public VCLXWindow
-{
-public:
-    LocalizedString();
-
-	// css::uno::XInterface
-    css::uno::Any SAL_CALL queryInterface( css::uno::Type const& rType )
-        throw(css::uno::RuntimeException);
-    void SAL_CALL acquire() throw() { OWeakObject::acquire(); }
-    void SAL_CALL release() throw() { OWeakObject::release(); }
-
-    // css::awt::XFixedText
-    void SAL_CALL setText( ::rtl::OUString const& s )
-        throw(css::uno::RuntimeException);
-    ::rtl::OUString SAL_CALL getText()
-        throw(css::uno::RuntimeException);
-    void SAL_CALL setAlignment( sal_Int16 )
-        throw(css::uno::RuntimeException) { } 
-    sal_Int16 SAL_CALL getAlignment()
-        throw(css::uno::RuntimeException) { return 0; }
-
-    // css::awt::XLayoutConstrains
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException) { return css::awt::Size( 0, 0 ); }
-    css::awt::Size SAL_CALL getPreferredSize()
-        throw(css::uno::RuntimeException) { return getMinimumSize(); }
-    css::awt::Size SAL_CALL calcAdjustedSize( css::awt::Size const& size )
-        throw(css::uno::RuntimeException) { return size; }
-
-    static void ImplGetPropertyIds( std::list< sal_uInt16 > &ids );
-    virtual void GetPropertyIds( std::list< sal_uInt16 > &ids )
-    { return ImplGetPropertyIds( ids ); }
-};
-
-} // namespace layoutimpl
-
-#endif /* CORE_LOCALIZED_STRING_HXX */
diff --git a/toolkit/source/layout/makefile.mk b/toolkit/source/layout/makefile.mk
deleted file mode 100644
index 3bf6cd9..0000000
--- toolkit/source/layout/makefile.mk
+++ /dev/null
@@ -1,67 +0,0 @@
-#*************************************************************************
-#
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-# 
-# Copyright 2008 by Sun Microsystems, Inc.
-#
-# OpenOffice.org - a multi-platform office productivity suite
-#
-# $RCSfile$
-#
-# $Revision$
-#
-# This file is part of OpenOffice.org.
-#
-# OpenOffice.org is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser General Public License version 3
-# only, as published by the Free Software Foundation.
-#
-# OpenOffice.org is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser General Public License version 3 for more details
-# (a copy is included in the LICENSE file that accompanied this code).
-#
-# You should have received a copy of the GNU Lesser General Public License
-# version 3 along with OpenOffice.org.  If not, see
-# <http://www.openoffice.org/license.html>
-# for a copy of the LGPLv3 License.
-#
-#*************************************************************************
-
-PRJ=..$/..
-PRJNAME=toolkit
-TARGET=layoutcore
-ENABLE_EXCEPTIONS=true
-
-# --- Settings -----------------------------------------------------
-
-.INCLUDE : settings.mk
-.INCLUDE : $(PRJ)$/util$/makefile.pmk
-
-# --- Files --------------------------------------------------------
-
-# FIXME: This is bad, hmkay
-CFLAGS+= -I$(PRJ)/source
-
-SLOFILES= \
-	$(SLO)$/bin.obj \
-	$(SLO)$/box-base.obj \
-	$(SLO)$/box.obj \
-	$(SLO)$/byteseq.obj \
-	$(SLO)$/container.obj \
-	$(SLO)$/dialogbuttonhbox.obj \
-	$(SLO)$/factory.obj \
-	$(SLO)$/flow.obj \
-	$(SLO)$/helper.obj \
-	$(SLO)$/import.obj \
-	$(SLO)$/localized-string.obj \
-	$(SLO)$/proplist.obj \
-	$(SLO)$/root.obj \
-	$(SLO)$/table.obj \
-	$(SLO)$/timer.obj \
-	$(SLO)$/translate.obj
-
-# --- Targets ------------------------------------------------------
-
-.INCLUDE : target.mk
diff --git a/toolkit/source/layout/precompiled_xmlscript.hxx b/toolkit/source/layout/precompiled_xmlscript.hxx
deleted file mode 100644
index 60cd73d..0000000
--- toolkit/source/layout/precompiled_xmlscript.hxx
+++ /dev/null
@@ -1,39 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-/*
-  xmlscript/source/xml_helper/xml_byteseq.cxx compile helper.
-
-  Avoid introducing a toolkit dependency on xmlscript.
-
-  It would be nice to modify xml_byteseq.cxx making it friendlier
-  to include.
-*/
diff --git a/toolkit/source/layout/proplist.cxx b/toolkit/source/layout/proplist.cxx
deleted file mode 100644
index c16d979..0000000
--- toolkit/source/layout/proplist.cxx
+++ /dev/null
@@ -1,458 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "proplist.hxx"
-
-#include <rtl/ustrbuf.hxx>
-#include <toolkit/dllapi.h>
-#include <com/sun/star/awt/WindowAttribute.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/awt/XVclWindowPeer.hpp>
-#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
-#include <tools/debug.hxx>
-
-#include "layout/layoutcore.hxx"
-
-#if TEST_LAYOUT && !defined( DBG_UTIL )
-#include <cstdio>
-#undef DBG_ERROR
-#define DBG_ERROR printf
-#undef DBG_ERROR1
-#define DBG_ERROR1 printf
-#undef DBG_ERROR2
-#define DBG_ERROR2 printf
-#endif /* TEST_LAYOUT && !DBG_UTIL */
-
-namespace layoutimpl
-{
-
-using namespace com::sun::star;
-using rtl::OString;
-using rtl::OUString;
-using rtl::OUStringBuffer;
-
-namespace prophlp
-{
-
-bool TOOLKIT_DLLPUBLIC
-canHandleProps( const uno::Reference< uno::XInterface > &xPeer )
-{
-    uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
-    if ( xPropSet.is() )
-        return true;
-    uno::Reference< beans::XPropertySetInfo > xInfo( xPeer, uno::UNO_QUERY );
-    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
-    return xInfo.is() && xVclPeer.is();
-}
-
-uno::Reference< beans::XPropertySetInfo > TOOLKIT_DLLPUBLIC
-queryPropertyInfo(
-    const uno::Reference< uno::XInterface > &xPeer )
-{
-    uno::Reference< beans::XPropertySetInfo > xInfo( xPeer, uno::UNO_QUERY );
-    if ( !xInfo.is() )
-    {
-        uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
-        if ( xPropSet.is() )
-            xInfo = xPropSet->getPropertySetInfo();
-    }
-    return xInfo;
-}
-
-void TOOLKIT_DLLPUBLIC
-setProperty( const uno::Reference< uno::XInterface > &xPeer,
-                  const OUString &rName, uno::Any aValue )
-{
-    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
-    if ( xVclPeer.is() )
-        xVclPeer->setProperty( rName, aValue );
-    else
-    {
-        uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
-        xPropSet->setPropertyValue( rName, aValue );
-    }
-}
-
-uno::Any TOOLKIT_DLLPUBLIC
-getProperty( const uno::Reference< uno::XInterface > &xPeer,
-                      const OUString &rName )
-{
-    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
-    if ( xVclPeer.is() )
-        return xVclPeer->getProperty( rName );
-
-    uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
-    return xPropSet->getPropertyValue( rName );
-}
-
-} // namespace prophlp
-
-
-/* Given a string and a type, it converts the string to the type, and returns
-   it encapsulated in Any. */
-uno::Any anyFromString( OUString const& value, uno::Type const& type )
-{
-    sal_Int16 radix = 10;
-    OUString intval = value;
-    if ( value.getLength() > 2 && value[0] == '0' && value[1] == 'x' )
-        intval = value.copy( 2 ), radix = 16;
-    else if ( value.getLength() > 1 && value[0] == '#' )
-        intval = value.copy( 1 ), radix = 16;
-    switch ( type.getTypeClass() )
-    {
-        case uno::TypeClass_CHAR:
-            return uno::makeAny( value.toChar() );
-        case uno::TypeClass_BOOLEAN:
-            if ( value == OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) ) )
-                return uno::makeAny( true );
-            else if ( value == OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) ) )
-                return uno::makeAny( false );
-            break;  // ends switch, throws exception
-        case uno::TypeClass_BYTE:
-            return uno::makeAny( ( sal_uInt8 ) intval.toInt32( radix ) );
-        case uno::TypeClass_SHORT:
-            return uno::makeAny( ( sal_Int16 ) intval.toInt32( radix ) );
-        case uno::TypeClass_UNSIGNED_SHORT:
-            return uno::makeAny( ( sal_uInt16 ) intval.toInt32( radix ) );
-        case uno::TypeClass_ENUM:
-            return uno::makeAny( ( sal_Int16 ) intval.toInt32( radix ) );
-        case uno::TypeClass_LONG:
-            return uno::makeAny( ( sal_Int32 ) intval.toInt32( radix ) );
-        case uno::TypeClass_UNSIGNED_LONG:
-            return uno::makeAny( ( sal_uInt32 ) intval.toInt32( radix ) );
-        case uno::TypeClass_HYPER:
-            return uno::makeAny( ( sal_Int64 ) intval.toInt64( radix ) );
-        case uno::TypeClass_UNSIGNED_HYPER:
-            return uno::makeAny( ( sal_uInt16 ) intval.toInt64( radix ) );
-        case uno::TypeClass_FLOAT:
-            return uno::makeAny( value.toFloat() );
-        case uno::TypeClass_DOUBLE:
-            return uno::makeAny( value.toDouble() );
-        case uno::TypeClass_STRING:
-            return uno::makeAny( value );
-        case uno::TypeClass_CONSTANT:
-            return uno::makeAny( intval.toInt32( radix ) );
-        case uno::TypeClass_INTERFACE:
-            return uno::makeAny( loadGraphic( OUSTRING_CSTR( value ) ) );
-        case uno::TypeClass_SEQUENCE:
-        {
-            sal_Int32 i = 0;
-            bool escaped = false, first = true;
-            OUString item, token;
-            std::list< OUString > values;
-            do
-            {
-                token = value.getToken( 0, ':', i );
-
-                if ( !token.getLength() && !escaped )
-                {
-                    escaped = true;
-                    item += OUString( ':' );
-                }
-                else if ( escaped )
-                {
-                    escaped = false;
-                    item += token;
-                }
-                else
-                {
-                    if ( !first )
-                        values.push_back( item );
-                    item = token;
-                }
-                first = false;
-            }
-            while ( i >= 0 );
-            if ( item.getLength() )
-                values.push_back( item );
-
-            uno::Sequence< OUString > seq( values.size() );
-            i = 0;
-            for ( std::list< OUString >::const_iterator it = values.begin();
-                  it != values.end(); it++, i++ )
-                seq[ i ] = *it;
-
-            return uno::makeAny( seq );
-        }
-
-        default:
-            DBG_ERROR1( "ERROR: unknown property type of value: `%s'\n", OUSTRING_CSTR( value ) );
-            break;
-    }
-    throw uno::RuntimeException();
-}
-
-/* Converts the XML naming scheme to UNO's, for legacy compatibility
-   (so, ergo, "one-two-three-four" -> "OneTwoThreeFour"). */
-static OUString toUnoNaming ( OUString const &string )
-{
-    OUStringBuffer buffer( string.getLength() );
-    sal_Unicode *str = string.pData->buffer;
-    bool capitalize = true;
-
-    for ( int i = 0; i < string.getLength(); i++ )
-    {
-        if ( i == 0 && str[0] == '_' )
-            /* Skip translate-me prefix.  */
-            continue;
-        if ( str[i] == '-' )
-            capitalize = true;
-        else
-        {
-            if ( capitalize && str[i] >= 'a' && str[i] <= 'z' )
-                buffer.append( (sal_Unicode ) ( str[i] - 'a' + 'A' ) );
-            else
-                buffer.append( (sal_Unicode ) str[i] );
-            capitalize = false;
-        }
-    }
-
-    return buffer.makeStringAndClear();
-}
-
-/*
- * convert incoming XML style property names, to AWT style property names.
- * convert the values based on introspection information.
- * apply to either an XPropertySet or an XPropertySetInfo | XVclWindowPeer
- * aggregate.
- */
-void
-setProperties( uno::Reference< uno::XInterface > const& xPeer,
-               PropList const& rProps )
-{
-    if ( !prophlp::canHandleProps( xPeer ) )
-    {
-        DBG_ERROR( "Error: setProperties - bad handle ignoring props:\n" );
-        for ( PropList::const_iterator it = rProps.begin(); it != rProps.end();
-              it++ )
-        {
-            DBG_ERROR2( "%s=%s\n", OUSTRING_CSTR( it->first ), OUSTRING_CSTR( it->second ) );
-        }
-        return;
-    }
-
-    for ( PropList::const_iterator it = rProps.begin(); it != rProps.end();
-          it++ )
-        setProperty( xPeer, it->first, it->second );
-}
-
-void
-setProperty( uno::Reference< uno::XInterface > const& xPeer,
-             OUString const& attr, OUString const& value )
-{
-    OUString unoAttr = toUnoNaming( attr );
-
-    OSL_TRACE( "setting %s=%s", OUSTRING_CSTR( attr ), OUSTRING_CSTR( value ) );
-    // get a Property object
-    beans::Property prop;
-    try
-    {
-        uno::Reference< beans::XPropertySetInfo > xInfo
-            = prophlp::queryPropertyInfo( xPeer );
-        prop = xInfo->getPropertyByName( unoAttr );
-    }
-    catch( beans::UnknownPropertyException & )
-    {
-        DBG_ERROR1( "Warning: unknown attribute: `%s'\n", OUSTRING_CSTR( unoAttr ) );
-        return;
-    }
-
-    if ( prop.Name.getLength() <= 0 )
-    {
-        DBG_ERROR1( "Warning: missing prop: `%s'\n", OUSTRING_CSTR( unoAttr ) );
-        return;
-    }
-
-    // encapsulates value in an uno::Any
-    uno::Any any;
-    try
-    {
-        any = anyFromString( value, prop.Type );
-    }
-    catch( uno::RuntimeException & )
-    {
-        DBG_ERROR5( "Warning: %s( %s )( %s ) attribute is of type %s( rejected: %s )\n", OUSTRING_CSTR( unoAttr ), OUSTRING_CSTR( value ), OUSTRING_CSTR( prop.Name ),  OUSTRING_CSTR( prop.Type.getTypeName() ), OUSTRING_CSTR( value ) );
-        return;
-    }
-
-    // sets value on property
-    try
-    {
-        prophlp::setProperty( xPeer, unoAttr, any );
-    }
-    catch( ... )
-    {
-        DBG_ERROR2( "Warning: cannot set attribute %s to %s \n", OUSTRING_CSTR( unoAttr ), OUSTRING_CSTR( value ) );
-    }
-}
-
-
-
-
-struct AttributesMap
-{
-    const char *name;
-    long value;
-    bool windowAttr;
-};
-static const AttributesMap attribsMap[] =
-{
-    { "autohscroll",  awt::VclWindowPeerAttribute::AUTOHSCROLL,  false },
-    { "autovscroll",  awt::VclWindowPeerAttribute::AUTOVSCROLL,  false },
-    { "center",       awt::VclWindowPeerAttribute::CENTER,       false },
-    { "clipchildren", awt::VclWindowPeerAttribute::CLIPCHILDREN, false },
-    { "closeable",    awt::WindowAttribute::CLOSEABLE,           true },
-    { "defbutton",    awt::VclWindowPeerAttribute::DEFBUTTON,    false },
-    { "dropdown",     awt::VclWindowPeerAttribute::DROPDOWN,     false },
-    { "fullsize",     awt::WindowAttribute::FULLSIZE,            true  }, //FIXME?
-    { "group",        awt::VclWindowPeerAttribute::GROUP,        false },
-    { "has_border",   awt::WindowAttribute::BORDER,              true },
-    { "hscroll",      awt::VclWindowPeerAttribute::HSCROLL,      false },
-    { "left",         awt::VclWindowPeerAttribute::LEFT,         false },
-    { "moveable",     awt::WindowAttribute::MOVEABLE,            true },
-    { "noborder",     awt::VclWindowPeerAttribute::NOBORDER,     false },
-    { "nolabel",      awt::VclWindowPeerAttribute::NOLABEL,      false },
-    { "optimumsize",  awt::WindowAttribute::OPTIMUMSIZE,         false },
-    { "readonly",     awt::VclWindowPeerAttribute::READONLY,     false },
-    { "right",        awt::VclWindowPeerAttribute::RIGHT,        false },
-    { "show",         awt::WindowAttribute::SHOW,                true },
-    { "sizeable",     awt::WindowAttribute::SIZEABLE,            true },
-    { "sort",         awt::VclWindowPeerAttribute::SORT,         false },
-    { "spin",         awt::VclWindowPeerAttribute::SPIN,         false },
-    { "vscroll",      awt::VclWindowPeerAttribute::VSCROLL,      false },
-
-    // cutting on OK, YES_NO_CANCEL and related obsite attributes...
-};
-static const int attribsMapLen = sizeof( attribsMap ) / sizeof( AttributesMap );
-
-#if 0
-long getAttribute( const OUString &rName, bool bTopWindow )
-{
-
-    int min = 0, max = attribsMapLen - 1, mid, cmp;
-    do
-    {
-        mid = min +( max - min )/2;
-        cmp = rName.compareToAscii( attribsMap[ mid ].name );
-        if ( cmp > 0 )
-            min = mid+1;
-        else if ( cmp < 0 )
-            max = mid-1;
-        else
-        {
-            if ( bTopWindow || attribsMap[ mid ].value )
-                return attribsMap[ mid ].windowAttr;
-            return 0;
-        }
-    }
-    while ( min <= max );
-    return 0;
-}
-#endif
-
-void propsFromAttributes( const uno::Reference<xml::input::XAttributes> & xAttributes,
-                          PropList &rProps, sal_Int32 nNamespace )
-{
-    sal_Int32 nAttrs = xAttributes->getLength();
-    for ( sal_Int32 i = 0; i < nAttrs; i++ )
-    {
-        if ( nNamespace != xAttributes->getUidByIndex( i ) )
-            continue;
-
-        std::pair< OUString, OUString > aElem
-            ( xAttributes->getLocalNameByIndex( i ),
-              xAttributes->getValueByIndex( i ) );
-
-        if ( aElem.first.getLength() > 0 ) // namespace bits ..
-            rProps.push_back( aElem );
-    }
-}
-
-bool
-findAndRemove( const char *pAttr, PropList &rProps, OUString &rValue )
-{
-    PropList::iterator it;
-    OUString aName = OUString::createFromAscii( pAttr );
-
-    for ( it = rProps.begin(); it != rProps.end(); it++ )
-    {
-        if ( it->first.equalsIgnoreAsciiCase( aName ) )
-        {
-            rValue = it->second;
-            rProps.erase( it );
-            return true;
-        }
-    }
-    rValue = OUString();
-    return false;
-}
-
-long
-getAttributeProps( PropList &rProps )
-{
-    long nAttrs = 0;
-    OUString aValue;
-
-    OUString trueStr( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
-
-    if ( findAndRemove( "show", rProps, aValue ) &&
-         aValue.equalsIgnoreAsciiCase(
-             OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) ) ) )
-        ;
-    else
-        nAttrs |= awt::WindowAttribute::SHOW;
-
-    for ( int i = 0; i < attribsMapLen; i++ )
-    {
-        if ( findAndRemove( attribsMap[i].name, rProps, aValue ) )
-        {
-            if ( aValue.equalsIgnoreAsciiCase( trueStr ) )
-                nAttrs |= attribsMap[i].value;
-        }
-    }
-
-    if ( findAndRemove( "align", rProps, aValue ) )
-    {
-        sal_Int32 nVal = aValue.toInt32();
-
-        if ( nVal == 0 /* PROPERTY_ALIGN_LEFT */ )
-            nAttrs |= awt::VclWindowPeerAttribute::LEFT;
-        else if ( nVal == 1 /* PROPERTY_ALIGN_CENTER */ )
-            nAttrs |= awt::VclWindowPeerAttribute::CENTER;
-        else if ( nVal == 2 )
-            nAttrs |= awt::VclWindowPeerAttribute::RIGHT;
-    }
-
-    return nAttrs;
-}
-
-}
-
diff --git a/toolkit/source/layout/proplist.hxx b/toolkit/source/layout/proplist.hxx
deleted file mode 100644
index 123de61..0000000
--- toolkit/source/layout/proplist.hxx
+++ /dev/null
@@ -1,75 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_PROPLIST_HXX
-#define CORE_PROPLIST_HXX
-
-#include <list>
-#include <com/sun/star/xml/input/XAttributes.hpp>
-
-#include <rtl/ustring.hxx>
-
-namespace layoutimpl
-{
-
-namespace css = ::com::sun::star;
-
-typedef std::list< std::pair< rtl::OUString, rtl::OUString > > PropList;
-
-void propsFromAttributes( const css::uno::Reference<css::xml::input::XAttributes> & xAttributes,
-                          PropList &rProps, sal_Int32 nNamespace );
-
-void setProperties( css::uno::Reference< css::uno::XInterface > const& xPeer,
-                    PropList const& rProps);
-
-void setProperty( css::uno::Reference< css::uno::XInterface > const& xPeer,
-                  rtl::OUString const& attr, rtl::OUString const& value );
-
-long getAttributeProps( PropList &rProps );
-bool findAndRemove( const char *pAttr, PropList &rProps, rtl::OUString &rValue);
-
-}
-
-#if !OUSTRING_CSTR_PARANOIA
-#define OUSTRING_CSTR( str ) \
-    rtl::OUStringToOString( str, RTL_TEXTENCODING_ASCII_US ).getStr()
-#else
-
-inline char const* OUSTRING_CSTR( rtl::OUString const& str )
-{
-    rtl::OString *leak
-        = new rtl::OString (rtl::OUStringToOString (str, RTL_TEXTENCODING_ASCII_US));
-    return leak->getStr();
-}
-
-#endif
-
-#endif // CORE_PROPLIST_HXX
diff --git a/toolkit/source/layout/root.cxx b/toolkit/source/layout/root.cxx
deleted file mode 100644
index a50f42d..0000000
--- toolkit/source/layout/root.cxx
+++ /dev/null
@@ -1,414 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "root.hxx"
-
-#include <cassert>
-#include <cstdio>
-
-#include <com/sun/star/awt/WindowAttribute.hpp>
-#include <com/sun/star/awt/XMessageBox.hpp>
-#include <com/sun/star/awt/MessageBoxButtons.hpp>
-#include <com/sun/star/frame/XDesktop.hpp>
-#include <com/sun/star/awt/XMessageBoxFactory.hpp>
-#include <com/sun/star/xml/sax/SAXParseException.hpp>
-#include <com/sun/star/xml/sax/XParser.hpp>
-
-#include "helper.hxx"
-#include "import.hxx"
-#include "timer.hxx"
-#include "translate.hxx"
-
-namespace layoutimpl
-{
-
-using namespace css;
-using ::rtl::OUString;
-
-LayoutRoot::LayoutRoot( const uno::Reference< lang::XMultiServiceFactory >& xFactory )
-    : mbDisposed( sal_False )
-    , mxFactory( xFactory )
-    , mpListeners( NULL )
-    , mpToplevel( NULL )
-{
-    if ( !xFactory.is() )
-        throw uno::RuntimeException();
-    mxLayoutUnit = uno::Reference< awt::XLayoutUnit >( new LayoutUnit() );
-}
-
-LayoutRoot::~LayoutRoot()
-{
-// TODO: we want to delete the top level LayoutWidget...
-    ::osl::MutexGuard aGuard( maMutex );
-    if ( !mbDisposed )
-    {
-        try
-        {
-            m_refCount++; // inhibit multiple destruction
-            dispose();
-        }
-        catch( uno::Exception& )
-        {
-        }
-    }
-}
-
-void ShowMessageBox( uno::Reference< lang::XMultiServiceFactory > const& xFactory, uno::Reference< awt::XToolkit > xToolkit, OUString const& aTitle, OUString const& aMessage )
-{
-    uno::Reference< uno::XInterface > iDesktop = xFactory->createInstance
-        ( OUString::createFromAscii( "com.sun.star.frame.Desktop" ) );
-    uno::Reference< frame::XDesktop > xDesktop ( iDesktop, uno::UNO_QUERY );
-    uno::Reference< frame::XFrame > xFrame ( xDesktop->getCurrentFrame() );
-    uno::Reference< awt::XWindow > xContainerWindow( xFrame->getContainerWindow() );
-    uno::Reference< awt::XWindowPeer > xWindowPeer( xContainerWindow, uno::UNO_QUERY_THROW );
-    uno::Reference< awt::XMessageBoxFactory > xMessageBoxFactory( xToolkit, uno::UNO_QUERY );
-
-    awt::Rectangle aRectangle;
-    uno::Reference< awt::XMessageBox > xMessageBox
-        = xMessageBoxFactory->createMessageBox
-        ( xWindowPeer, aRectangle, OUString::createFromAscii( "errorbox" ),
-          awt::MessageBoxButtons::BUTTONS_OK, aTitle, aMessage );
-
-    if ( xMessageBox.is() )
-        xMessageBox->execute();
-    //FIXME: exceptions not caught and printed at top level??
-    //else
-    //printf( "%s\n", OUSTRING_CSTR( aMessage ) );
-}
-
-void LayoutRoot::error( OUString const& message )
-{
-    printf( "%s\n", OUSTRING_CSTR( message ) );
-    ShowMessageBox( mxFactory, mxToolkit,
-                    OUString::createFromAscii( "Fatal error" ),
-                    message );
-    throw uno::RuntimeException( message, uno::Reference< uno::XInterface >() );
-}
-
-// XInitialization
-void SAL_CALL LayoutRoot::initialize( const uno::Sequence< uno::Any >& aArguments )
-    throw ( uno::Exception,
-            uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-
-    if ( mbDisposed )
-        throw lang::DisposedException();
-
-    if ( mxContainer.is() ) // only 1 init ...
-        throw uno::Exception();
-
-    if ( !aArguments.getLength() )
-        throw lang::IllegalArgumentException();
-
-    OSL_ENSURE( aArguments.getLength() == 1, "Wrong arg count\n" );
-
-    OUString aXMLName;
-    if ( !( aArguments[0] >>= aXMLName ) )
-        throw lang::IllegalArgumentException();
-
-    uno::Reference< xml::sax::XParser > xParser
-        ( mxFactory->createInstance(
-            OUString::createFromAscii( "com.sun.star.xml.sax.Parser" ) ),
-          uno::UNO_QUERY );
-    OSL_ASSERT( xParser.is() );
-    if (! xParser.is())
-    {
-        throw uno::RuntimeException(
-            OUString::createFromAscii( "cannot create sax-parser component" ),
-            uno::Reference< uno::XInterface >() );
-    }
-
-    // FIXME: quite possibly we want to pass this in ...
-    uno::Reference< awt::XToolkit > xToolkit;
-
-    mxToolkit = uno::Reference< awt::XToolkit >(
-        mxFactory->createInstance(
-            OUString::createFromAscii( "com.sun.star.awt.Toolkit" ) ),
-        uno::UNO_QUERY );
-
-    if ( !mxToolkit.is() )
-        throw uno::RuntimeException(
-            OUString::createFromAscii( "failed to create toolkit!" ),
-            uno::Reference< uno::XInterface >() );
-
-    OUString aXMLFile = readRightTranslation( aXMLName );
-    uno::Reference< io::XInputStream > xStream = getFileAsStream( aXMLFile );
-    if (! xStream.is() )
-        error( OUString::createFromAscii( "Installation problem: cannot find XML file:" ) + aXMLName );
-
-    // error handler, entity resolver omitted
-
-    ImportContext *pCtx = new ImportContext( *this );
-
-    uno::Reference< xml::input::XRoot > xRoot( pCtx );
-    uno::Sequence < uno::Any > aArgs( 1 );
-    aArgs[0] <<= xRoot;
-    uno::Reference< xml::sax::XDocumentHandler > xDocHandler
-        (mxFactory->createInstanceWithArguments
-         ( OUString::createFromAscii( "com.sun.star.xml.input.SaxDocumentHandler" ),
-          aArgs ), uno::UNO_QUERY );
-
-    if (! xDocHandler.is() )
-        error( OUString::createFromAscii( "cannot find SAx handler for document type of:") + aXMLName );
-        
-    xParser->setDocumentHandler( xDocHandler );
-
-    xml::sax::InputSource source;
-    source.aInputStream = xStream;
-    source.sSystemId = OUString::createFromAscii( "virtual file" );
-
-    try
-    {
-        xParser->parseStream( source );
-    }
-    catch ( xml::sax::SAXParseException& e )
-    {
-        OUString c = OUString::createFromAscii( ":" );
-        error( aXMLName
-               + c + OUString::valueOf( e.LineNumber )
-               + c + OUString::valueOf( e.ColumnNumber )
-               + c + OUString::createFromAscii( "Sax parse error" ) );
-    }
-}
-
-// XLayoutContainer
-uno::Reference< awt::XLayoutContainer > LayoutRoot::getLayoutContainer() throw (uno::RuntimeException)
-{
-    return uno::Reference< awt::XLayoutContainer >();
-}
-
-// local helper ...
-void LayoutRoot::addItem( const OUString &rName,
-                          const uno::Reference< awt::XLayoutConstrains > &xRef )
-{
-    maItems[ rName ] = xRef;
-}
-
-// XNameAccess
-uno::Any SAL_CALL LayoutRoot::getByName( const OUString &rName )
-    throw ( container::NoSuchElementException,
-            lang::WrappedTargetException,
-            uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-    if ( mbDisposed )
-        throw lang::DisposedException();
-
-    uno::Reference< awt::XLayoutConstrains > xItem;
-    ItemHash::iterator i = maItems.find( rName );
-    if ( i != maItems.end() )
-        xItem = i->second;
-    return uno::makeAny( xItem );
-}
-
-sal_Bool SAL_CALL LayoutRoot::hasByName( const OUString &rName )
-    throw (uno::RuntimeException)
-{
-    ::osl::MutexGuard aGuard( maMutex );
-    if ( mbDisposed ) throw lang::DisposedException();
-
-    ItemHash::iterator i = maItems.find( rName );
-    return i != maItems.end();
-}
-
-uno::Sequence< OUString > SAL_CALL LayoutRoot::getElementNames()
-    throw ( uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-    if ( mbDisposed ) throw lang::DisposedException();
-
-    uno::Sequence< OUString > aNames( maItems.size() );
-    sal_Int32 nPos = 0;
-
-    for ( ItemHash::const_iterator it = maItems.begin();
-          it != maItems.end(); it++ )
-        aNames[ nPos++ ] = it->first;
-
-    return aNames;
-}
-
-uno::Type SAL_CALL LayoutRoot::getElementType()
-    throw ( uno::RuntimeException )
-{
-    return getCppuType( ( const uno::Reference< awt::XLayoutConstrains >* )NULL );
-}
-
-sal_Bool SAL_CALL LayoutRoot::hasElements()
-    throw ( uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-
-    if ( mbDisposed ) throw lang::DisposedException();
-
-    return maItems.size() > 0;
-}
-
-// XComponent
-void SAL_CALL LayoutRoot::dispose()
-    throw ( uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-
-    if ( mbDisposed ) throw lang::DisposedException();
-
-    if ( mpListeners )
-    {
-
-        lang::EventObject aSource( static_cast< ::cppu::OWeakObject* >(this) );
-        mpListeners->disposeAndClear( aSource );
-        delete mpListeners;
-        mpListeners = NULL;
-    }
-
-    maItems.clear();
-    mbDisposed = sal_True;
-}
-
-void SAL_CALL LayoutRoot::addEventListener( const uno::Reference< lang::XEventListener >& xListener )
-    throw ( uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-
-    if ( mbDisposed ) throw lang::DisposedException();
-
-    if ( !mpListeners )
-        mpListeners = new ::cppu::OInterfaceContainerHelper( maMutex );
-    mpListeners->addInterface( xListener );
-}
-
-void SAL_CALL LayoutRoot::removeEventListener( const uno::Reference< lang::XEventListener >& xListener )
-    throw ( uno::RuntimeException )
-{
-    ::osl::MutexGuard aGuard( maMutex );
-
-    if ( mbDisposed ) throw lang::DisposedException();
-
-    if ( mpListeners )
-        mpListeners->removeInterface( xListener );
-}
-
-// builder
-
-LayoutWidget *LayoutRoot::create( OUString id, const OUString unoName, long attrbs,uno::Reference< awt::XLayoutContainer > xParent )
-{
-    LayoutWidget *pWidget = new LayoutWidget( mxToolkit, xParent, unoName, attrbs );
-    if ( !mpToplevel )
-    {
-        mpToplevel = pWidget;
-        mxWindow = uno::Reference< awt::XWindow >( pWidget->getPeer(), uno::UNO_QUERY );
-        mxContainer = pWidget->mxContainer;
-    }
-    if ( pWidget->mxContainer.is() )
-        pWidget->mxContainer->setLayoutUnit( mxLayoutUnit );
-    if ( id.getLength() )
-        maItems[ id ] = pWidget->getPeer();
-    return pWidget;
-}
-
-#if 0
-uno::Reference< awt::XLayoutConstrains > LayoutRoot::getToplevel()
-{
-    if ( mpToplevel )
-        return mpToplevel->getPeer();
-    return uno::Reference< awt::XLayoutConstrains > ();
-}
-
-uno::Reference< awt::XLayoutConstrains > LayoutRoot::getById( OUString id )
-{
-    uno::Reference< awt::XLayoutConstrains > rRef = 0;
-    ItemHash::iterator it = maItems.find( id );
-    if ( it != maItems.end() )
-        rRef = it->second;
-    return rRef;
-}
-#endif
-
-LayoutWidget::LayoutWidget( uno::Reference< awt::XToolkit > xToolkit,
-                            uno::Reference< awt::XLayoutContainer > xParent,
-                            OUString unoName, long attrbs )
-{
-    while ( xParent.is() && !uno::Reference< awt::XWindow >( xParent, uno::UNO_QUERY ).is() )
-    {
-        uno::Reference< awt::XLayoutContainer > xContainer( xParent, uno::UNO_QUERY );
-        assert( xContainer.is() );
-        xParent = uno::Reference< awt::XLayoutContainer >( xContainer->getParent(), uno::UNO_QUERY );
-    }
-
-    mxWidget = createWidget( xToolkit, xParent, unoName, attrbs );
-    assert( mxWidget.is() );
-    mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
-}
-
-LayoutWidget::~LayoutWidget()
-{
-    /* should we dispose of the references...? */
-    // at least of its children... Or should root?
-}
-
-bool LayoutWidget::addChild( LayoutWidget *pChild )
-{
-    if ( !mxContainer.is() )
-        return false;
-
-    try
-    {
-        mxContainer->addChild( pChild->mxWidget );
-    }
-    catch( awt::MaxChildrenException ex )
-    {
-        return false;
-    }
-    return true;
-}
-
-void LayoutWidget::setProperties( PropList const& rProps )
-{
-    ::layoutimpl::setProperties( mxWidget, rProps );
-}
-
-void LayoutWidget::setProperty( OUString const& attr, OUString const& value )
-{
-    ::layoutimpl::setProperty( mxWidget, attr, value );
-}
-
-void LayoutWidget::setChildProperties( LayoutWidget *pChild,
-                                       PropList const& rProps )
-{
-    uno::Reference< beans::XPropertySet > xChildPeer;
-    xChildPeer = mxContainer->getChildProperties( pChild->mxWidget );
-
-    if ( xChildPeer.is() )
-        ::layoutimpl::setProperties( xChildPeer, rProps );
-}
-
-} // namespace layoutimpl
-
diff --git a/toolkit/source/layout/root.hxx b/toolkit/source/layout/root.hxx
deleted file mode 100644
index f2ebcc0..0000000
--- toolkit/source/layout/root.hxx
+++ /dev/null
@@ -1,160 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_ROOT_HXX
-#define CORE_ROOT_HXX
-
-#define _BACKWARD_BACKWARD_WARNING_H 1
-#include <hash_map>
-
-#include <com/sun/star/awt/XLayoutRoot.hpp>
-#include <com/sun/star/awt/XToolkit.hpp>
-#include <com/sun/star/awt/XWindow.hpp>
-#include <com/sun/star/io/XInputStream.hpp>
-#include <com/sun/star/lang/XComponent.hpp>
-#include <com/sun/star/lang/XInitialization.hpp>
-#include <cppuhelper/implbase3.hxx>
-#include <cppuhelper/interfacecontainer.h>
-#include <toolkit/dllapi.h>
-
-#include "proplist.hxx"
-
-namespace layoutimpl
-{
-
-namespace css = ::com::sun::star;
-
-css::uno::Reference< css::io::XInputStream > getFileAsStream( const rtl::OUString &rName );
-
-/* Interface generation code -- to hook to a parser. */
-
-/*
-  TODO: (ricardo) I think we should cut on LayoutRoot, stripping out its widget
-  proxy interface (just make it return the root widget). Would even make it easier
-  if there was interest to support multiple toplevel widgets in the same file.
-
-  We also need to make sure the code gets diposed well... There is no need to keep
-  these objects around after initialization...
-*/
-
-
-class LayoutWidget;
-
-class TOOLKIT_DLLPUBLIC LayoutRoot : public ::cppu::WeakImplHelper3<
-    css::awt::XLayoutRoot,
-    css::lang::XInitialization,
-    css::lang::XComponent>
-{
-protected:
-    ::osl::Mutex maMutex;
-
-    typedef std::hash_map< rtl::OUString,
-                           css::uno::Reference< css::awt::XLayoutConstrains >,
-                           ::rtl::OUStringHash > ItemHash;
-    ItemHash maItems;
-
-    sal_Bool mbDisposed;
-    css::uno::Reference< css::lang::XMultiServiceFactory > mxFactory;
-    ::cppu::OInterfaceContainerHelper *mpListeners;
-
-    css::uno::Reference< css::awt::XWindow >          mxWindow;
-    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
-
-    css::uno::Reference< css::awt::XToolkit > mxToolkit;
-    LayoutWidget *mpToplevel;
-    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
-
-    void error( rtl::OUString const& message );
-
-public:
-    LayoutRoot( const css::uno::Reference< css::lang::XMultiServiceFactory >& xFactory );
-    virtual ~LayoutRoot();
-
-    void addItem( const rtl::OUString &rName,
-                  const css::uno::Reference< css::awt::XLayoutConstrains > &xRef );
-
-    void setWindow(    css::uno::Reference< css::awt::XLayoutConstrains > xPeer )
-    {
-        mxWindow = css::uno::Reference< css::awt::XWindow >( xPeer, css::uno::UNO_QUERY );
-    }
-
-    // get XLayoutContainer
-    virtual css::uno::Reference< css::awt::XLayoutContainer > SAL_CALL getLayoutContainer() throw (css::uno::RuntimeException);
-
-    // XInitialization
-    virtual void SAL_CALL initialize( const css::uno::Sequence< css::uno::Any >& aArguments ) throw (css::uno::Exception, css::uno::RuntimeException);
-
-    // XNameAccess
-    virtual css::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException);
-    virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames() throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
-
-    // XComponent
-    virtual void SAL_CALL dispose() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL addEventListener( const css::uno::Reference< css::lang::XEventListener >& xListener ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL removeEventListener( const css::uno::Reference< css::lang::XEventListener >& aListener ) throw (css::uno::RuntimeException);
-
-    // generator
-    virtual LayoutWidget *create( rtl::OUString id, const rtl::OUString unoName, long attrbs, css::uno::Reference< css::awt::XLayoutContainer > xParent );
-};
-
-class TOOLKIT_DLLPUBLIC LayoutWidget
-{
-    friend class LayoutRoot;
-
-public:
-    LayoutWidget() {}
-    LayoutWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-                  css::uno::Reference< css::awt::XLayoutContainer > xToplevel,
-                  rtl::OUString unoName, long attrbs );
-    virtual ~LayoutWidget();
-
-    virtual void setProperties( const PropList &rProps );
-    virtual void setProperty( rtl::OUString const& attr, rtl::OUString const& value );
-
-    virtual bool addChild( LayoutWidget *pChild );
-    virtual void setChildProperties( LayoutWidget *pChild, const PropList &rProps );
-
-    inline css::uno::Reference< css::awt::XLayoutConstrains > getPeer()
-    { return mxWidget; }
-    inline css::uno::Reference< css::awt::XLayoutContainer > getContainer()
-    { return mxContainer; }
-
-protected:
-    css::uno::Reference< css::awt::XLayoutConstrains > mxWidget;
-    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
-};
-
-} // namespace layoutimpl
-
-#endif // CORE_ROOT_HXX
diff --git a/toolkit/source/layout/table.cxx b/toolkit/source/layout/table.cxx
deleted file mode 100644
index 87c15e2..0000000
--- toolkit/source/layout/table.cxx
+++ /dev/null
@@ -1,315 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include <table.hxx>
-
-#include <sal/macros.h>
-#include <osl/mutex.hxx>
-#include <cppuhelper/propshlp.hxx>
-#include <cppuhelper/interfacecontainer.h>
-#include <com/sun/star/awt/PosSize.hpp>
-#include <tools/debug.hxx>
-
-// fixed point precision for distributing error
-#define FIXED_PT 16
-
-namespace layoutimpl
-{
-
-using namespace com::sun::star;
-
-Table::ChildProps::ChildProps( Table::ChildData *pData )
-    {
-        addProp( RTL_CONSTASCII_USTRINGPARAM( "XExpand" ),
-                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
-             &( pData->mbExpand[ 0 ] ) );
-        addProp( RTL_CONSTASCII_USTRINGPARAM( "YExpand" ),
-                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
-             &( pData->mbExpand[ 1 ] ) );
-        addProp( RTL_CONSTASCII_USTRINGPARAM( "ColSpan" ),
-                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &( pData->mnColSpan ) );
-        addProp( RTL_CONSTASCII_USTRINGPARAM( "RowSpan" ),
-                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &( pData->mnRowSpan ) );
-    }
-
-bool Table::ChildData::isVisible()
-{
-    return Box_Base::ChildData::isVisible()
-        && ( mnColSpan > 0 ) && ( mnRowSpan > 0 );
-}
-
-Table::Table()
-    : Box_Base()
-    , mnColsLen( 1 )// another default value could be 0xffff for infinite columns( = 1 row )
-{
-    addProp( RTL_CONSTASCII_USTRINGPARAM( "Columns" ),
-             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
-             &mnColsLen );
-}
-
-Table::ChildData::ChildData( uno::Reference< awt::XLayoutConstrains > const& xChild )
-    : Box_Base::ChildData( xChild )
-//    , mbExpand( { 0, 1 } )
-    , mnColSpan( 1 )
-    , mnRowSpan( 1 )
-    , mnLeftCol( 0 )
-    , mnRightCol( 0 )
-    , mnTopRow( 0 )
-    , mnBottomRow( 0 )
-    {
-    mbExpand[ 0 ] = 0;
-    mbExpand[ 1 ] = 1;
-}
-
-Table::ChildData*
-Table::createChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
-        {
-    return new ChildData( xChild );
-}
-
-Table::ChildProps*
-Table::createChildProps( Box_Base::ChildData *pData )
-{
-    return new ChildProps( static_cast<Table::ChildData*> ( pData ) );
-}
-
-void SAL_CALL
-Table::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
-    throw( uno::RuntimeException, awt::MaxChildrenException )
-        {
-    if ( xChild.is() )
-            {
-        Box_Base::addChild( xChild );
-        // cause of flicker
-        allocateChildAt( xChild, awt::Rectangle( 0,0,0,0 ) );
-    }
-}
-
-awt::Size SAL_CALL
-Table::getMinimumSize() throw( uno::RuntimeException )
-{
-    int nRowsLen = 0;
-
-    // 1. layout the table -- adjust to cope with row-spans...
-    {
-        // temporary 1D representation of the table
-        std::vector< ChildData *> aTable;
-
-        int col = 0;
-        int row = 0;
-        for ( std::list<Box_Base::ChildData *>::iterator it
-                  = maChildren.begin(); it != maChildren.end(); it++ )
-        {
-            ChildData *child = static_cast<Table::ChildData*> ( *it );
-            if ( !child->isVisible() )
-                continue;
-
-            while ( col + SAL_MIN( child->mnColSpan, mnColsLen ) > mnColsLen )
-            {
-                col = 0;
-                row++;
-
-                unsigned int i = col +( row*mnColsLen );
-                while ( aTable.size() > i && !aTable[ i ] )
-                    i++;
-
-                col = i % mnColsLen;
-                row = i / mnColsLen;
-            }
-
-            child->mnLeftCol = col;
-            child->mnRightCol = SAL_MIN( col + child->mnColSpan, mnColsLen );
-            child->mnTopRow = row;
-            child->mnBottomRow = row + child->mnRowSpan;
-
-            col += child->mnColSpan;
-
-            unsigned int start = child->mnLeftCol +( child->mnTopRow*mnColsLen );
-            unsigned int end =( child->mnRightCol-1 ) +( ( child->mnBottomRow-1 )*mnColsLen );
-            if ( aTable.size() < end+1 )
-                aTable.resize( end+1, NULL );
-            for ( unsigned int i = start; i < end; i++ )
-                aTable[ i ] = child;
-
-            nRowsLen = SAL_MAX( nRowsLen, child->mnBottomRow );
-        }
-    }
-
-    // 2. calculate columns/rows sizes
-    for ( int g = 0; g < 2; g++ )
-    {
-        std::vector< GroupData > &aGroup = g == 0 ? maCols : maRows;
-
-        aGroup.clear();
-        aGroup.resize( g == 0 ? mnColsLen : nRowsLen );
-
-        // 2.1 base sizes on one-column/row children
-        for ( std::list<Box_Base::ChildData *>::iterator it
-                  = maChildren.begin(); it != maChildren.end(); it++ )
-        {
-            ChildData *child = static_cast<Table::ChildData*> ( *it );
-            if ( !child->isVisible() )
-                continue;
-            const int nFirstAttach = g == 0 ? child->mnLeftCol : child->mnTopRow;
-            const int nLastAttach  = g == 0 ? child->mnRightCol : child->mnBottomRow;
-
-            if ( nFirstAttach == nLastAttach-1 )
-            {
-                child->maRequisition = child->mxChild->getMinimumSize();
-                int attach = nFirstAttach;
-                int child_size = g == 0 ? child->maRequisition.Width
-                    : child->maRequisition.Height;
-                aGroup[ attach ].mnSize = SAL_MAX( aGroup[ attach ].mnSize,
-                                                   child_size );
-                if ( child->mbExpand[ g ] )
-                    aGroup[ attach ].mbExpand = true;
-            }
-        }
-
-        // 2.2 make sure multiple-columns/rows children fit
-        for ( std::list<Box_Base::ChildData *>::iterator it
-                  = maChildren.begin(); it != maChildren.end(); it++ )
-        {
-            ChildData *child = static_cast<Table::ChildData*> ( *it );
-            if ( !child->isVisible() )
-                continue;
-            const int nFirstAttach = g == 0 ? child->mnLeftCol : child->mnTopRow;
-            const int nLastAttach  = g == 0 ? child->mnRightCol : child->mnBottomRow;
-
-            if ( nFirstAttach != nLastAttach-1 )
-            {
-                child->maRequisition = child->mxChild->getMinimumSize();
-                int size = 0;
-                int expandables = 0;
-                for ( int i = nFirstAttach; i < nLastAttach; i++ )
-                {
-                    size += aGroup[ i ].mnSize;
-                    if ( aGroup[ i ].mbExpand )
-                        expandables++;
-                }
-
-                int child_size = g == 0 ? child->maRequisition.Width
-                    : child->maRequisition.Height;
-                int extra = child_size - size;
-                if ( extra > 0 )
-                {
-                    if ( expandables )
-                        extra /= expandables;
-                    else
-                        extra /= nLastAttach - nFirstAttach;
-
-                    for ( int i = nFirstAttach; i < nLastAttach; i++ )
-                        if ( expandables == 0 || aGroup[ i ].mbExpand )
-                            aGroup[ i ].mnSize += extra;
-                }
-            }
-        }
-    }
-
-    // 3. Sum everything up
-    mnColExpandables =( mnRowExpandables = 0 );
-    maRequisition.Width =( maRequisition.Height = 0 );
-    for ( std::vector<GroupData>::iterator it = maCols.begin();
-         it != maCols.end(); it++ )
-    {
-        maRequisition.Width += it->mnSize;
-        if ( it->mbExpand )
-            mnColExpandables++;
-    }
-    for ( std::vector<GroupData>::iterator it = maRows.begin();
-         it != maRows.end(); it++ )
-    {
-        maRequisition.Height += it->mnSize;
-        if ( it->mbExpand )
-            mnRowExpandables++;
-    }
-
-    return maRequisition;
-}
-
-void SAL_CALL
-Table::allocateArea( const awt::Rectangle &rArea )
-    throw( uno::RuntimeException )
-{
-    maAllocation = rArea;
-    if ( maCols.size() == 0 || maRows.size() == 0 )
-        return;
-
-    int nExtraSize[ 2 ] = { SAL_MAX( rArea.Width - maRequisition.Width, 0 ),
-                            SAL_MAX( rArea.Height - maRequisition.Height, 0 ) };
-    // split it
-    nExtraSize[ 0 ] /= mnColExpandables ? mnColExpandables : mnColsLen;
-    nExtraSize[ 1 ] /= mnRowExpandables ? mnRowExpandables : maRows.size();
-
-    for ( std::list<Box_Base::ChildData *>::const_iterator it
-              = maChildren.begin(); it != maChildren.end(); it++ )
-    {
-        ChildData *child = static_cast<Table::ChildData*> ( *it );
-        if ( !child->isVisible() )
-            continue;
-
-        awt::Rectangle rChildArea( rArea.X, rArea.Y, 0, 0 );
-
-        for ( int g = 0; g < 2; g++ )
-        {
-            std::vector< GroupData > &aGroup = g == 0 ? maCols : maRows;
-            const int nFirstAttach = g == 0 ? child->mnLeftCol : child->mnTopRow;
-            const int nLastAttach  = g == 0 ? child->mnRightCol : child->mnBottomRow;
-
-            for ( int i = 0; i < nFirstAttach; i++ )
-            {
-                int gSize = aGroup[ i ].mnSize;
-                if ( aGroup[ i ].mbExpand )
-                    gSize += nExtraSize[ g ];
-                if ( g == 0 )
-                    rChildArea.X += gSize;
-                else
-                    rChildArea.Y += gSize;
-            }
-            for ( int i = nFirstAttach; i < nLastAttach; i++ )
-            {
-                int gSize = aGroup[ i ].mnSize;
-                if ( aGroup[ i ].mbExpand )
-                    gSize += nExtraSize[ g ];
-                if ( g == 0 )
-                    rChildArea.Width  += gSize;
-                else
-                    rChildArea.Height += gSize;
-            }
-        }
-
-        allocateChildAt( child->mxChild, rChildArea );
-    }
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/table.hxx b/toolkit/source/layout/table.hxx
deleted file mode 100644
index cee1bf3..0000000
--- toolkit/source/layout/table.hxx
+++ /dev/null
@@ -1,108 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef TABLE_HXX
-#define TABLE_HXX
-
-#include "box-base.hxx"
-
-namespace layoutimpl
-{
-
-class Table : public Box_Base
-{
-public:
-    // Children properties
-    struct ChildData : public Box_Base::ChildData
-    {
-        sal_Bool mbExpand[ 2 ];
-        sal_Int32 mnColSpan;
-        sal_Int32 mnRowSpan;
-        int mnLeftCol;
-        int mnRightCol;
-        int mnTopRow;
-        int mnBottomRow;
-
-        ChildData( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
-        bool isVisible();
-    };
-
-    struct ChildProps : public Box_Base::ChildProps
-    {
-        ChildProps( ChildData *pData );
-    };
-
-protected:
-
-    // a group of children; either a column or a row
-    struct GroupData
-    {
-        sal_Bool mbExpand;
-        int mnSize;  // request size (width or height)
-        GroupData() : mbExpand( false ), mnSize( 0 ) {}
-    };
-
-    // Table properties
-    sal_Int32 mnColsLen;
-    std::vector< GroupData > maCols;
-    std::vector< GroupData > maRows;
-    int mnColExpandables, mnRowExpandables;
-
-    ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
-    ChildProps *createChildProps( Box_Base::ChildData* pData );
-
-public:
-    Table();
-
-    // css::awt::XLayoutContainer
-    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
-        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
-
-    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
-        throw (css::uno::RuntimeException);
-
-    virtual css::awt::Size SAL_CALL getMinimumSize()
-        throw(css::uno::RuntimeException);
-
-    // unimplemented:
-    virtual sal_Bool SAL_CALL hasHeightForWidth()
-        throw(css::uno::RuntimeException)
-    { return false; }
-    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 /*nWidth*/ )
-    throw(css::uno::RuntimeException)
-    { return maRequisition.Height; }
-
-    PROPHELPER_SET_INFO
-};
-
-} //  namespace layoutimpl
-
-#endif /*TABLE_HXX*/
diff --git a/toolkit/source/layout/timer.cxx b/toolkit/source/layout/timer.cxx
deleted file mode 100644
index 26874a0..0000000
--- toolkit/source/layout/timer.cxx
+++ /dev/null
@@ -1,152 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "timer.hxx"
-
-#include <vector>
-#include <list>
-#include <vcl/timer.hxx>
-#include <com/sun/star/awt/XLayoutContainer.hpp>
-
-namespace layoutimpl
-{
-using namespace ::com::sun::star;
-
-class AllocateTimer : public Timer
-{
-    typedef std::list< uno::Reference< awt::XLayoutContainer > > ContainerList;
-    ContainerList mxContainers;
-    uno::Reference< awt::XLayoutContainer > mxLastAdded;
-
-public:
-    AllocateTimer()
-    {
-        // timer set to 0 -- just process it as soon as it gets idle
-        SetTimeout( 0 );
-    }
-
-    static inline bool isParentOf( uno::Reference< awt::XLayoutContainer > xParent,
-                                   uno::Reference< awt::XLayoutContainer > xWidget )
-    {
-        while ( xWidget.is() )
-        {
-            if ( xWidget == xParent )
-                return true;
-            xWidget = uno::Reference< awt::XLayoutContainer >( xWidget->getParent(), uno::UNO_QUERY );
-        }
-        return false;
-    }
-
-    static inline void eraseChildren( ContainerList::iterator &it, ContainerList &list )
-    {
-        ContainerList::iterator jt = list.begin();
-        while ( jt != list.end() )
-        {
-            if ( it != jt && isParentOf( *it, *jt ) )
-                jt = list.erase( jt );
-            else
-                jt++;
-        }
-    }
-
-    static inline bool isContainerDamaged( uno::Reference< awt::XLayoutContainer > xContainer )
-    {
-        uno::Reference< awt::XLayoutConstrains > xConstrains( xContainer, uno::UNO_QUERY );
-        awt::Size lastReq( xContainer->getRequestedSize() );
-        awt::Size curReq( xConstrains->getMinimumSize() );
-        return lastReq.Width != curReq.Width || lastReq.Height != curReq.Height;
-    }
-
-    void add( const uno::Reference< awt::XLayoutContainer > &xContainer )
-    {
-        // small optimization
-        if ( mxLastAdded == xContainer )
-            return;
-        mxLastAdded = xContainer;
-
-        mxContainers.push_back( xContainer );
-    }
-
-    virtual void Timeout()
-    {
-        mxLastAdded = uno::Reference< awt::XLayoutContainer >();
-
-        // 1. remove duplications and children
-        for ( ContainerList::iterator it = mxContainers.begin();
-             it != mxContainers.end(); it++ )
-            eraseChildren( it, mxContainers );
-
-        // 2. check damage extent
-        for ( ContainerList::iterator it = mxContainers.begin();
-             it != mxContainers.end(); it++ )
-        {
-            uno::Reference< awt::XLayoutContainer > xContainer = *it;
-            while ( xContainer->getParent().is() && isContainerDamaged( xContainer ) )
-            {
-                xContainer = uno::Reference< awt::XLayoutContainer >(
-                    xContainer->getParent(), uno::UNO_QUERY );
-            }
-
-            if ( *it != xContainer )
-            {
-                // 2.2 replace it with parent
-                *it = xContainer;
-
-                // 2.3 remove children of new parent
-                eraseChildren( it, mxContainers );
-            }
-        }
-
-        // 3. force re-calculations
-        for ( ContainerList::iterator it = mxContainers.begin();
-             it != mxContainers.end(); it++ )
-            (*it)->allocateArea( (*it)->getAllocatedArea() );
-    }
-};
-
-static void AddResizeTimeout( const uno::Reference< awt::XLayoutContainer > &xCont )
-{
-    static AllocateTimer timer;
-    timer.add( xCont );
-    timer.Start();
-}
-
-LayoutUnit::LayoutUnit() : LayoutUnit_Base()
-{
-}
-
-void SAL_CALL LayoutUnit::queueResize( const uno::Reference< awt::XLayoutContainer > &xContainer )
-    throw( uno::RuntimeException )
-{
-    AddResizeTimeout( xContainer );
-}
-
-}
diff --git a/toolkit/source/layout/timer.hxx b/toolkit/source/layout/timer.hxx
deleted file mode 100644
index d17f111..0000000
--- toolkit/source/layout/timer.hxx
+++ /dev/null
@@ -1,53 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_TIMER_HXX
-#define CORE_TIMER_HXX
-
-#include <com/sun/star/awt/XLayoutUnit.hpp>
-#include <cppuhelper/implbase1.hxx>
-
-namespace layoutimpl
-{
-
-typedef ::cppu::WeakImplHelper1< com::sun::star::awt::XLayoutUnit > LayoutUnit_Base;
-
-class LayoutUnit : public LayoutUnit_Base
-{
-public:
-    LayoutUnit();
-    void SAL_CALL queueResize( const com::sun::star::uno::Reference< com::sun::star::awt::XLayoutContainer > &xContainer )
-        throw( com::sun::star::uno::RuntimeException );
-};
-
-}
-
-#endif /*CORE_TIMER_HXX*/
diff --git a/toolkit/source/layout/translate.cxx b/toolkit/source/layout/translate.cxx
deleted file mode 100644
index d0fc9f7..0000000
--- toolkit/source/layout/translate.cxx
+++ /dev/null
@@ -1,134 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "translate.hxx"
-
-#include <list>
-#if TEST_LAYOUT
-#include <cstdio>
-#include "tools/getprocessworkingdir.hxx"
-#endif
-
-#include <unotools/bootstrap.hxx>
-#include <unotools/localfilehelper.hxx>
-#include <unotools/ucbhelper.hxx>
-#include <vcl/svapp.hxx>
-
-#include "proplist.hxx"
-
-namespace layoutimpl
-{
-namespace css = ::com::sun::star;
-using namespace css;
-using ::rtl::OUString;
-using ::utl::LocalFileHelper;
-using ::utl::UCBContentHelper;
-using ::utl::Bootstrap;
-
-static std::list<OUString>
-getLocaleSubdirList( lang::Locale const& rLocale )
-{
-    std::list<OUString> aSubdirs;
-    aSubdirs.push_front( OUString::createFromAscii( "." ) );
-    aSubdirs.push_front( OUString::createFromAscii( "en_US" ) );
-    if ( rLocale.Language.getLength() )
-        aSubdirs.push_front( rLocale.Language );
-    if ( rLocale.Country.getLength() )
-    {
-        OUString aLocaleCountry = rLocale.Language
-            + OUString::createFromAscii( "_" )
-            + rLocale.Country;
-        aSubdirs.push_front( aLocaleCountry );
-        if ( rLocale.Variant.getLength() )
-            aSubdirs.push_front( aLocaleCountry
-                                 + OUString::createFromAscii( "." )
-                                 + rLocale.Variant );
-    }
-    return aSubdirs;
-}
-
-static bool
-fileExists( String const& aFile )
-{
-    String aUrl;
-    LocalFileHelper::ConvertPhysicalNameToURL( aFile, aUrl );
-    return UCBContentHelper::Exists( aUrl );
-}
-
-static OUString
-getFirstExisting( OUString const& aDir, std::list<OUString> const& aSubDirs,
-                  OUString const& aXMLName )
-{
-    static OUString const aSlash = OUString::createFromAscii( "/" );
-    String aResult;
-    for ( std::list<OUString>::const_iterator i = aSubDirs.begin();
-          i != aSubDirs.end(); i++ )
-    {
-        String aFile = aDir + aSlash + *i + aSlash + aXMLName;
-        OSL_TRACE( "testing: %s", OUSTRING_CSTR( aFile ) );
-        if ( fileExists( aFile ) )
-            return aFile;
-    }
-    return OUString();
-}
-
-/*  FIXME: IWBN to share code with impimagetree.cxx, also for reading
-  from zip files.  */
-OUString
-readRightTranslation( OUString const& aXMLName )
-{
-    String aXMLFile;
-    std::list<OUString> aSubdirs
-        = getLocaleSubdirList( Application::GetSettings().GetUILocale() );
-#if TEST_LAYOUT // read from cwd first
-    OUString aCurrentWorkingUrl;
-    tools::getProcessWorkingDir( &aCurrentWorkingUrl );
-    String aCurrentWorkingDir;
-    LocalFileHelper::ConvertURLToPhysicalName( aCurrentWorkingUrl, aCurrentWorkingDir );
-    aXMLFile = getFirstExisting( aCurrentWorkingDir, aSubdirs, aXMLName );
-    if ( aXMLFile.Len() )
-        ;
-    else
-#endif /* TEST_LAYOUT */
-    {
-        OUString aShareUrl;
-        Bootstrap::locateSharedData( aShareUrl );
-        OUString aXMLUrl = aShareUrl + OUString::createFromAscii( "/layout" );
-        String aXMLDir;
-        LocalFileHelper::ConvertURLToPhysicalName( aXMLUrl, aXMLDir );
-        aXMLFile = getFirstExisting( aXMLDir, aSubdirs, aXMLName );
-    }
-
-    OSL_TRACE( "FOUND:%s", OUSTRING_CSTR ( OUString (aXMLFile) ) );
-    return aXMLFile;
-}
-
-} // namespace layoutimpl
diff --git a/toolkit/source/layout/translate.hxx b/toolkit/source/layout/translate.hxx
deleted file mode 100644
index 9e2e5d6..0000000
--- toolkit/source/layout/translate.hxx
+++ /dev/null
@@ -1,44 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef CORE_TRANSLATE_HXX
-#define CORE_TRANSLATE_HXX
-
-namespace rtl {
-class OUString;
-} // namespace rtl
-
-namespace layoutimpl
-{
-::rtl::OUString readRightTranslation( ::rtl::OUString const& aXMLName );
-} // namespace layoutimpl
-
-#endif /* CORE_TRANSLATE_HXX */
diff --git a/toolkit/source/layout/vcl/makefile.mk b/toolkit/source/layout/vcl/makefile.mk
new file mode 100644
index 0000000..9334df8
--- /dev/null
+++ toolkit/source/layout/vcl/makefile.mk
@@ -0,0 +1,56 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=../../..
+PRJNAME=toolkit
+TARGET=layout-vcl
+ENABLE_EXCEPTIONS=true
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE : settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+.IF "$(COMNAME)" == "gcc3"
+CFLAGS+=-Wall -fno-default-inline
+.ENDIF
+
+# --- Files --------------------------------------------------------
+
+SLOFILES= \
+	$(SLO)$/wrapper.obj \
+	$(SLO)$/wbutton.obj \
+	$(SLO)$/wcontainer.obj \
+	$(SLO)$/wfield.obj
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : target.mk
diff --git a/toolkit/source/layout/vcl/wbutton.cxx b/toolkit/source/layout/vcl/wbutton.cxx
new file mode 100644
index 0000000..3b0e14b
--- /dev/null
+++ toolkit/source/layout/vcl/wbutton.cxx
@@ -0,0 +1,675 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "wrapper.hxx"
+
+#include <com/sun/star/awt/PosSize.hpp>
+#include <com/sun/star/awt/XActionListener.hpp>
+#include <com/sun/star/awt/XButton.hpp>
+#include <com/sun/star/awt/XCheckBox.hpp>
+#include <com/sun/star/awt/XRadioButton.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <toolkit/awt/vclxwindows.hxx>
+#include <toolkit/helper/convert.hxx>
+#include <vcl/button.hxx>
+#include <vcl/event.hxx>
+#include <vcl/msgbox.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/window.hxx>
+
+#include <list>
+
+#include <layout/core/helper.hxx>
+
+using namespace ::com::sun::star;
+
+using rtl::OUString;
+
+namespace layout
+{
+
+class ImageImpl
+{
+  public:
+    uno::Reference< graphic::XGraphic > mxGraphic;
+    ImageImpl( const char *pName )
+        : mxGraphic( layoutimpl::loadGraphic( pName ) )
+    {
+        if ( !mxGraphic.is() )
+        {
+            DBG_ERROR1( "ERROR: failed to load image: `%s'\n", pName );
+        }
+    }
+};
+
+Image::Image( const char *pName )
+    : pImpl( new ImageImpl( pName ) )
+{
+}
+
+Image::~Image()
+{
+    delete pImpl;
+}
+
+class ButtonImpl : public ControlImpl
+                 , public ::cppu::WeakImplHelper1< awt::XActionListener >
+{
+    Link maClickHdl;
+
+public:
+    uno::Reference< awt::XButton > mxButton;
+    ButtonImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ControlImpl( context, peer, window )
+        , mxButton( peer, uno::UNO_QUERY )
+    {
+        /* We have default action when clicked, always listen. */
+        mxButton->addActionListener( this );
+    }
+
+    ~ButtonImpl()
+    {
+    }
+
+    virtual void Click() { /* make me pure virtual? */ };
+
+    Link& GetClickHdl ()
+    {
+        return maClickHdl;
+    }
+
+    virtual void SetClickHdl( Link const& link )
+    {
+        maClickHdl = link;
+    }
+
+    void SAL_CALL disposing( lang::EventObject const& e )
+        throw (uno::RuntimeException)
+    {
+        mxButton->removeActionListener( this );
+        ControlImpl::disposing (e);
+        mxButton.clear ();
+    }
+
+    virtual void SAL_CALL actionPerformed( const awt::ActionEvent& )
+        throw (uno::RuntimeException)
+    {
+        if ( !maClickHdl )
+            Click();
+        else
+            maClickHdl.Call( static_cast<Window *>( mpWindow ) );
+    }
+
+    bool SetModeImage( uno::Reference< graphic::XGraphic > xGraph )
+    {
+        setProperty( "Graphic", uno::Any( xGraph ) );
+        return true;
+    }
+};
+
+Button::~Button ()
+{
+}
+
+String Button::GetStandardText (sal_uInt16 button_type)
+{
+    return ::Button::GetStandardText (button_type);
+}
+
+void Button::SetText( OUString const& rStr )
+{
+    if ( !getImpl().mxButton.is() )
+        return;
+    getImpl().mxButton->setLabel( rStr );
+}
+
+void Button::SetClickHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxButton.is ())
+        getImpl().SetClickHdl( link );
+}
+
+Link& Button::GetClickHdl ()
+{
+    return getImpl().GetClickHdl ();
+}
+
+bool Button::SetModeImage( const Image& rImage )
+{
+    return getImpl().SetModeImage( rImage.getImpl().mxGraphic );
+}
+
+void Button::SetImageAlign( ImageAlign eAlign )
+{
+    getImpl().setProperty( "ImageAlign", uno::Any( (sal_Int16) eAlign ) );
+}
+
+void Button::Click()
+{
+}
+
+IMPL_GET_IMPL( Button );
+IMPL_CONSTRUCTORS( Button, Control, "button" );
+IMPL_GET_WINDOW (Button);
+
+class PushButtonImpl : public ButtonImpl
+                 , public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maToggleHdl;
+public:
+    PushButtonImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ButtonImpl( context, peer, window )
+    {
+    }
+
+    void SetToggleHdl( const Link& link )
+    {
+        // XButton doesn't have an explicit event for Toggle. Anyway, it is a
+        // superset of the clicks: all clicks, and explicit toggles
+        if (!link && !!maToggleHdl)
+            mxButton->removeActionListener( this );
+        else if (!!link && !maToggleHdl)
+            mxButton->addActionListener( this );
+        maToggleHdl = link;
+    }
+    void SAL_CALL disposing( lang::EventObject const& e )
+        throw (uno::RuntimeException)
+    {
+        ButtonImpl::disposing (e);
+    }
+    virtual void SAL_CALL actionPerformed( awt::ActionEvent const& e )
+        throw (uno::RuntimeException)
+    {
+        ButtonImpl::actionPerformed( e );
+        fireToggle();
+    }
+    virtual void SAL_CALL itemStateChanged( const awt::ItemEvent& )
+        throw (uno::RuntimeException)
+    {
+        maToggleHdl.Call( static_cast<Window *>( mpWindow ) );
+    }
+    void fireToggle()
+    {
+        maToggleHdl.Call(  static_cast<Window *>( mpWindow ) );
+    }
+
+};
+
+PushButton::~PushButton ()
+{
+    SetToggleHdl (Link ());
+}
+
+void PushButton::Check( bool bCheck )
+{
+    getImpl().setProperty( "State", uno::Any( (sal_Int16) !!bCheck ) );
+    // XButton doesn't have explicit toggle event
+    getImpl().fireToggle();
+}
+
+bool PushButton::IsChecked() const
+{
+    return !!( getImpl().getProperty( "State" ).get< sal_Int16 >() );
+}
+
+void PushButton::Toggle()
+{
+    Check( true );
+}
+
+void PushButton::SetToggleHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxButton.is ())
+        getImpl().SetToggleHdl( link );
+}
+
+IMPL_GET_IMPL( PushButton );
+IMPL_CONSTRUCTORS( PushButton, Button, "pushbutton" );
+IMPL_GET_WINDOW (PushButton);
+
+class RadioButtonImpl : public ButtonImpl
+                      , public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maToggleHdl;
+public:
+    uno::Reference< awt::XRadioButton > mxRadioButton;
+    RadioButtonImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ButtonImpl( context, peer, window )
+        , mxRadioButton( peer, uno::UNO_QUERY )
+    {
+    }
+
+    void Check( bool bCheck )
+    {
+        if ( !mxRadioButton.is() )
+            return;
+
+#if 1
+        // Have setState fire item event for
+        // RadioGroups::RadioGroup::itemStateChanged ()
+        ::RadioButton *r = static_cast<RadioButton*>(mpWindow)->GetRadioButton ();
+        bool state = r->IsRadioCheckEnabled ();
+        r->EnableRadioCheck();
+        mxRadioButton->setState( !!bCheck );
+        r->EnableRadioCheck (state);
+#else
+        mxRadioButton->setState( !!bCheck );
+#endif
+        fireToggle();
+    }
+
+    bool IsChecked()
+    {
+        if ( !mxRadioButton.is() )
+            return false;
+        return mxRadioButton->getState();
+    }
+
+    void SetToggleHdl( const Link& link )
+    {
+        if (!link && !!maToggleHdl)
+            mxRadioButton->removeItemListener( this );
+        else if (!!link && !maToggleHdl)
+            mxRadioButton->addItemListener( this );
+        maToggleHdl = link;
+    }
+
+    inline void fireToggle()
+    {
+        maToggleHdl.Call(  static_cast<Window *>( mpWindow ) );
+    }
+
+    virtual void SetClickHdl( const Link& link )
+    {
+        // Keep RadioGroups::RadioGroup's actionListener at HEAD
+        // of list.  This way, it can handle RadioGroup's button
+        // states before all other callbacks and make sure the
+        // client code has the right state.
+
+        // IWBN to add an XRadioButton2 and layout::VCLXRadioButton
+        // with {get,set}RadioGroup() (and a "radiogroup" property
+        // even) and handle the grouping here in RadioButtonImpl.
+        uno::Reference< uno::XInterface > x = static_cast<VCLXRadioButton*> (mpWindow->GetVCLXWindow ())->getFirstActionListener ();
+        uno::Reference< awt::XActionListener > a = uno::Reference< awt::XActionListener> (x ,uno::UNO_QUERY );
+        mxButton->removeActionListener (a);
+        ButtonImpl::SetClickHdl (link);
+        mxButton->addActionListener (a);
+    }
+
+    void SAL_CALL disposing( lang::EventObject const& e )
+        throw (uno::RuntimeException)
+    {
+        ButtonImpl::disposing (e);
+    }
+
+    virtual void SAL_CALL itemStateChanged( const awt::ItemEvent& )
+        throw (uno::RuntimeException)
+    {
+        maToggleHdl.Call( static_cast<Window *>( mpWindow ) );
+    }
+};
+
+RadioButton::~RadioButton ()
+{
+    SetToggleHdl (Link ());
+}
+
+void RadioButton::Check( bool bCheck )
+{
+    getImpl().Check( bCheck );
+}
+
+bool RadioButton::IsChecked() const
+{
+    return getImpl().IsChecked();
+}
+
+void RadioButton::SetToggleHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxRadioButton.is ())
+        getImpl().SetToggleHdl( link );
+}
+
+IMPL_GET_IMPL( RadioButton );
+IMPL_GET_WINDOW( RadioButton );
+IMPL_GET_VCLXWINDOW( RadioButton );
+IMPL_CONSTRUCTORS( RadioButton, Button, "radiobutton" );
+
+class CheckBoxImpl : public ButtonImpl
+                 , public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maToggleHdl;
+  public:
+    uno::Reference< awt::XCheckBox > mxCheckBox;
+    CheckBoxImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ButtonImpl( context, peer, window )
+        , mxCheckBox( peer, uno::UNO_QUERY )
+    {
+    }
+
+    void SetToggleHdl( const Link& link )
+    {
+        if (!link && !!maToggleHdl)
+            mxCheckBox->removeItemListener( this );
+        else if (!!link && !maToggleHdl)
+            mxCheckBox->addItemListener( this );
+        maToggleHdl = link;
+    }
+    void SAL_CALL disposing( lang::EventObject const& e )
+        throw (uno::RuntimeException)
+    {
+        ButtonImpl::disposing (e);
+    }
+    virtual void SAL_CALL itemStateChanged( const awt::ItemEvent& )
+        throw (uno::RuntimeException)
+    {
+        maToggleHdl.Call( static_cast<Window *>( mpWindow ) );
+    }
+};
+
+CheckBox::~CheckBox ()
+{
+    SetToggleHdl (Link ());
+}
+
+void CheckBox::Check( bool bCheck )
+{
+    if ( !getImpl().mxCheckBox.is() )
+        return;
+    getImpl().mxCheckBox->setState( !!bCheck );
+}
+
+bool CheckBox::IsChecked() const
+{
+    if ( !getImpl().mxCheckBox.is() )
+        return false;
+    return getImpl().mxCheckBox->getState() != 0;
+}
+
+void CheckBox::SetToggleHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxCheckBox.is ())
+        getImpl().SetToggleHdl( link );
+}
+
+IMPL_GET_IMPL( CheckBox );
+IMPL_CONSTRUCTORS( CheckBox, Button, "checkbox" );
+
+#define BUTTON_IMPL(t, parent, response) \
+    class t##Impl : public parent##Impl \
+    { \
+    public: \
+        t##Impl( Context *context, PeerHandle const& peer, Window *window ) \
+            : parent##Impl( context, peer, window ) \
+        { \
+        } \
+        void Click() \
+        { \
+            if (Dialog *d = static_cast<Dialog *> (mpCtx)) \
+                d->EndDialog( response ); \
+        } \
+    }
+
+/* Common button types currently unavailable in OOo: */
+/* mpReset */
+/* mpApply */
+/* mpAction */
+#define RET_RESET 6
+#define RET_APPLY 7
+#define BUTTONID_RESET RET_RESET
+#define BUTTONID_APPLY RET_APPLY
+
+BUTTON_IMPL( OKButton, PushButton, BUTTONID_OK );
+BUTTON_IMPL( CancelButton, PushButton, BUTTONID_CANCEL );
+BUTTON_IMPL( YesButton, PushButton, BUTTONID_YES );
+BUTTON_IMPL( NoButton, PushButton, BUTTONID_NO );
+BUTTON_IMPL( RetryButton, PushButton, BUTTONID_RETRY );
+BUTTON_IMPL( IgnoreButton, PushButton, BUTTONID_IGNORE );
+BUTTON_IMPL( ResetButton, PushButton, BUTTONID_RESET );
+BUTTON_IMPL( ApplyButton, PushButton, BUTTONID_APPLY ); /* Deprecated? */
+BUTTON_IMPL( HelpButton, PushButton, BUTTONID_HELP );
+
+IMPL_CONSTRUCTORS( OKButton, PushButton, "okbutton" );
+IMPL_CONSTRUCTORS( CancelButton, PushButton, "cancelbutton" );
+IMPL_CONSTRUCTORS( YesButton, PushButton, "yesbutton" );
+IMPL_CONSTRUCTORS( NoButton, PushButton, "nobutton" );
+IMPL_CONSTRUCTORS( RetryButton, PushButton, "retrybutton" );
+IMPL_CONSTRUCTORS( IgnoreButton, PushButton, "ignorebutton" );
+IMPL_CONSTRUCTORS( ResetButton, PushButton, "resetbutton" );
+IMPL_CONSTRUCTORS( ApplyButton, PushButton, "applybutton" );  /* Deprecated? */
+IMPL_CONSTRUCTORS( HelpButton, PushButton, "helpbutton" );
+
+class AdvancedButtonImpl : public PushButtonImpl
+{
+protected:
+    bool bAdvancedMode;
+    std::list< Window*> maAdvanced;
+    std::list< Window*> maSimple;
+
+public:
+    rtl::OUString mAdvancedLabel;
+    rtl::OUString mSimpleLabel;
+
+protected:
+    Window* Remove( std::list< Window*> lst, Window* w )
+    {
+        for ( std::list< Window*>::iterator it = maAdvanced.begin();
+              it != maAdvanced.end(); it++ )
+            if ( *it == w )
+            {
+                lst.erase( it );
+                return *it;
+            }
+        return 0;
+    }
+    
+public:
+    AdvancedButtonImpl( Context *context, PeerHandle const& peer, Window *window )
+        : PushButtonImpl( context, peer, window )
+        , bAdvancedMode( false )
+          // TODO: i18n
+          // Button::GetStandardText( BUTTON_ADVANCED );
+          // Button::GetStandardText( BUTTON_SIMPLE );
+        , mAdvancedLabel( rtl::OUString::createFromAscii( "Advanced..." ) )
+        , mSimpleLabel( rtl::OUString::createFromAscii( "Simple..." ) )
+    {
+    }
+    void Click()
+    {
+        bAdvancedMode = !bAdvancedMode;
+        if ( bAdvancedMode )
+            advancedMode();
+        else
+            simpleMode();
+    }
+    void setAlign ()
+    {
+        ::PushButton *b = static_cast<PushButton*> (mpWindow)->GetPushButton ();
+        b->SetSymbolAlign (SYMBOLALIGN_RIGHT);
+        b->SetSmallSymbol ();
+        //mpWindow->SetStyle (mpWindow->GetStyle() | WB_CENTER);
+    }
+    void advancedMode()
+    {
+        ::PushButton *b = static_cast<PushButton*> (mpWindow)->GetPushButton ();
+        b->SetSymbol (SYMBOL_PAGEUP);
+        setAlign ();
+        if (mSimpleLabel.getLength ())
+            b->SetText (mSimpleLabel);
+        for ( std::list< Window*>::iterator it = maAdvanced.begin();
+              it != maAdvanced.end(); it++ )
+            ( *it )->Show();
+        for ( std::list< Window*>::iterator it = maSimple.begin();
+              it != maSimple.end(); it++ )
+            ( *it )->Hide();
+
+        redraw ();
+    }
+    void simpleMode()
+    {
+        //mxButton->setLabel( mSimpleLabel );
+        ::PushButton *b = static_cast<PushButton*> (mpWindow)->GetPushButton ();
+        b->SetSymbol (SYMBOL_PAGEDOWN);
+        if (mAdvancedLabel.getLength ())
+            b->SetText (mAdvancedLabel);
+        setAlign ();
+        for ( std::list< Window*>::iterator it = maAdvanced.begin();
+              it != maAdvanced.end(); it++ )
+            ( *it )->Hide();
+        for ( std::list< Window*>::iterator it = maSimple.begin();
+              it != maSimple.end(); it++ )
+            ( *it )->Show();
+
+        redraw (true);
+    }
+    void AddAdvanced( Window* w )
+    {
+        maAdvanced.push_back( w );
+        if ( !bAdvancedMode )
+            w->Hide();
+    }
+    void AddSimple( Window* w )
+    {
+        maSimple.push_back( w );
+        if ( bAdvancedMode )
+            w->Hide();
+    }
+    void RemoveAdvanced( Window* w )
+    {
+        Remove( maAdvanced, w );
+    }
+    void RemoveSimple( Window* w )
+    {
+        Remove( maSimple, w );
+    }
+};
+
+void AdvancedButton::AddAdvanced( Window* w )
+{
+    getImpl().AddAdvanced( w );
+}
+
+void AdvancedButton::AddSimple( Window* w )
+{
+    getImpl().AddSimple( w );
+}
+
+void AdvancedButton::RemoveAdvanced( Window* w )
+{
+    getImpl().RemoveAdvanced( w );
+}
+
+void AdvancedButton::RemoveSimple( Window* w )
+{
+    getImpl().RemoveSimple( w );
+}
+
+void AdvancedButton::SetAdvancedText (rtl::OUString const& text)
+{
+    if (text.getLength ())
+        getImpl ().mAdvancedLabel = text;
+}
+
+void AdvancedButton::SetSimpleText (rtl::OUString const& text)
+{
+    if (text.getLength ())
+        getImpl ().mSimpleLabel = text;
+}
+
+rtl::OUString AdvancedButton::GetAdvancedText () const
+{
+    return getImpl ().mAdvancedLabel;
+}
+
+rtl::OUString AdvancedButton::GetSimpleText () const
+{
+    return getImpl ().mSimpleLabel;
+}
+
+void AdvancedButton::SetDelta (int)
+{
+}
+
+IMPL_CONSTRUCTORS_BODY( AdvancedButton, PushButton, "advancedbutton", getImpl().simpleMode () );
+IMPL_GET_IMPL( AdvancedButton );
+
+
+class MoreButtonImpl : public AdvancedButtonImpl
+{
+public:
+    MoreButtonImpl( Context *context, PeerHandle const& peer, Window *window )
+        : AdvancedButtonImpl( context, peer, window)
+    {
+        mSimpleLabel = Button::GetStandardText( BUTTON_MORE );
+        mAdvancedLabel = Button::GetStandardText( BUTTON_LESS );
+    }
+    void AddWindow( Window* w ) { AddAdvanced( w ); }
+    void RemoveWindow( Window* w ) { RemoveAdvanced( w ); }
+};
+
+// TODO
+//BUTTON_IMPL( MoreButton, PushButton, 0 );
+IMPL_CONSTRUCTORS_BODY( MoreButton, AdvancedButton, "morebutton", getImpl().simpleMode () );
+IMPL_GET_IMPL( MoreButton );
+
+void MoreButton::AddWindow( Window* w )
+{
+    getImpl().AddWindow( w );
+}
+
+void MoreButton::RemoveWindow( Window* w )
+{
+    getImpl().RemoveWindow( w );
+}
+
+void MoreButton::SetMoreText (rtl::OUString const& text)
+{
+    SetAdvancedText (text);
+}
+
+void MoreButton::SetLessText (rtl::OUString const& text)
+{
+    SetSimpleText (text);
+}
+
+rtl::OUString MoreButton::GetMoreText () const
+{
+    return GetAdvancedText ();
+}
+
+rtl::OUString MoreButton::GetLessText () const
+{
+    return GetSimpleText ();
+}
+
+} // namespace layout
diff --git a/toolkit/source/layout/vcl/wcontainer.cxx b/toolkit/source/layout/vcl/wcontainer.cxx
new file mode 100644
index 0000000..092e1b0
--- /dev/null
+++ toolkit/source/layout/vcl/wcontainer.cxx
@@ -0,0 +1,270 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "wrapper.hxx"
+
+#include <com/sun/star/awt/XLayoutRoot.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <comphelper/processfactory.hxx>
+#include <layout/core/helper.hxx>
+#include <tools/debug.hxx>
+
+using namespace ::com::sun::star;
+
+namespace layout
+{
+
+Container::Container( Context const* context, char const* pId )
+    : mxContainer( context->GetPeerHandle( pId ), uno::UNO_QUERY )
+{
+    if ( !mxContainer.is() )
+    {
+        DBG_ERROR1( "Error: failed to associate container with '%s'", pId );
+    }
+}
+
+Container::Container( rtl::OUString const& rName, sal_Int32 nBorder )
+{
+    mxContainer = layoutimpl::WidgetFactory::createContainer( rName );
+
+    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Border" ) ),
+                              uno::Any( nBorder ) );
+}
+
+void Container::Add( Window *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->GetPeer(), uno::UNO_QUERY );
+        mxContainer->addChild( xChild );
+    }
+}
+
+void Container::Add( Container *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->getImpl(), uno::UNO_QUERY );
+        mxContainer->addChild( xChild );
+    }
+}
+
+void Container::Remove( Window *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->GetPeer(), uno::UNO_QUERY );
+        mxContainer->removeChild( xChild );
+    }
+}
+
+void Container::Remove( Container *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->getImpl(), uno::UNO_QUERY );
+        mxContainer->removeChild( xChild );
+    }
+}
+
+void Container::Clear()
+{
+    css::uno::Sequence< css::uno::Reference < css::awt::XLayoutConstrains > > children;
+    children = mxContainer->getChildren();
+    for (int i = 0; i < children.getLength(); i++)
+        mxContainer->removeChild( children[i] );
+}
+
+void Container::ShowAll( bool bShow )
+{
+    struct inner
+    {
+        static void setChildrenVisible( uno::Reference < awt::XLayoutContainer > xCont,
+                                        bool bVisible )  /* auxiliary */
+        {
+            if ( xCont.is() )
+            {
+                uno::Sequence< uno::Reference < awt::XLayoutConstrains > > aChildren;
+                aChildren = xCont->getChildren();
+                for (int i = 0; i < aChildren.getLength(); i++)
+                {
+                    uno::Reference < awt::XLayoutConstrains > xChild( aChildren[ i ] );
+
+                    uno::Reference< awt::XWindow > xWin( xChild, uno::UNO_QUERY);
+                    if ( xWin.is() )
+                        xWin->setVisible( bVisible );
+
+                    uno::Reference < awt::XLayoutContainer > xChildCont(
+                        xChild, uno::UNO_QUERY );
+                    setChildrenVisible( xChildCont, bVisible );
+                }
+            }
+        }
+    };
+
+    inner::setChildrenVisible( mxContainer, bShow );
+}
+
+void Container::Show()
+{
+    ShowAll( true );
+}
+
+void Container::Hide()
+{
+    ShowAll( false );
+}
+
+Table::Table( sal_Int32 nBorder, sal_Int32 nColumns )
+    : Container( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "table" ) ), nBorder )
+{
+    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Columns" ) ),
+                              uno::Any( nColumns ) );
+}
+
+void Table::Add( Window *window, bool bXExpand, bool bYExpand,
+                 sal_Int32 nXSpan, sal_Int32 nYSpan )
+{
+    if ( !window )
+        return;
+    WindowImpl &rImpl = window->getImpl();
+    uno::Reference< awt::XLayoutConstrains > xChild( rImpl.mxWindow,
+                                                     uno::UNO_QUERY );
+    mxContainer->addChild( xChild );
+    setProps( xChild, bXExpand, bYExpand, nXSpan, nYSpan );
+}
+
+void Table::Add( Container *pContainer, bool bXExpand, bool bYExpand,
+                 sal_Int32 nXSpan, sal_Int32 nYSpan )
+{
+    if ( !pContainer )
+        return;
+    uno::Reference< awt::XLayoutConstrains > xChild( pContainer->getImpl(),
+                                                     uno::UNO_QUERY );
+    mxContainer->addChild( xChild );
+    setProps( xChild, bXExpand, bYExpand, nXSpan, nYSpan );
+}
+
+void Table::setProps( uno::Reference< awt::XLayoutConstrains > xChild,
+                      bool bXExpand, bool bYExpand, sal_Int32 nXSpan, sal_Int32 nYSpan )
+{
+    uno::Reference< beans::XPropertySet > xProps
+        ( mxContainer->getChildProperties( xChild ), uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "XExpand" ) ),
+                              uno::Any( bXExpand ) );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "YExpand" ) ),
+                              uno::Any( bYExpand ) );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "ColSpan" ) ),
+                              uno::Any( nXSpan ) );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "RowSpan" ) ),
+                              uno::Any( nYSpan ) );
+}
+
+Box::Box( rtl::OUString const& rName, sal_Int32 nBorder, bool bHomogeneous )
+    : Container( rName, nBorder )
+{
+    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ) ),
+                              uno::Any( bHomogeneous ) );
+}
+
+void Box::Add( Window *window, bool bExpand, bool bFill, sal_Int32 nPadding)
+{
+    if ( !window )
+        return;
+    WindowImpl &rImpl = window->getImpl();
+    uno::Reference< awt::XLayoutConstrains > xChild( rImpl.mxWindow,
+                                                     uno::UNO_QUERY );
+
+    mxContainer->addChild( xChild );
+    setProps( xChild, bExpand, bFill, nPadding );
+}
+
+void Box::Add( Container *pContainer, bool bExpand, bool bFill, sal_Int32 nPadding)
+{
+    if ( !pContainer )
+        return;
+
+    uno::Reference< awt::XLayoutConstrains > xChild( pContainer->getImpl(),
+                                                     uno::UNO_QUERY );
+    mxContainer->addChild( xChild );
+    setProps( xChild, bExpand, bFill, nPadding );
+}
+
+void Box::setProps( uno::Reference< awt::XLayoutConstrains > xChild,
+                    bool bExpand, bool bFill, sal_Int32 nPadding )
+{
+    uno::Reference< beans::XPropertySet > xProps
+        ( mxContainer->getChildProperties( xChild ), uno::UNO_QUERY_THROW );
+
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "Expand" ) ),
+                              uno::Any( bExpand ) );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Fill" ) ),
+                              uno::Any( bFill ) );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Padding" ) ),
+                              uno::Any( nPadding ) );
+}
+
+Table::Table( Context const* context, char const* pId )
+    : Container( context, pId )
+{
+}
+
+Box::Box( Context const* context, char const* pId )
+    : Container( context, pId )
+{
+}
+
+HBox::HBox( sal_Int32 nBorder, bool bHomogeneous )
+    : Box( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "hbox" ) ),
+           nBorder, bHomogeneous )
+{
+}
+
+HBox::HBox( Context const* context, char const* pId )
+    : Box( context, pId )
+{
+}
+
+VBox::VBox( sal_Int32 nBorder, bool bHomogeneous )
+    : Box( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "vbox" ) ),
+           nBorder, bHomogeneous )
+{
+}
+
+VBox::VBox( Context const* context, char const* pId )
+    : Box( context, pId )
+{
+}
+
+} // namespace layout
diff --git a/toolkit/source/layout/vcl/wfield.cxx b/toolkit/source/layout/vcl/wfield.cxx
new file mode 100644
index 0000000..d9e2443
--- /dev/null
+++ toolkit/source/layout/vcl/wfield.cxx
@@ -0,0 +1,762 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "wrapper.hxx"
+
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/awt/XMetricField.hpp>
+#include <com/sun/star/awt/XNumericField.hpp>
+#include <com/sun/star/awt/XTextComponent.hpp>
+#include <com/sun/star/awt/XListBox.hpp>
+#include <com/sun/star/awt/XComboBox.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/awt/XActionListener.hpp>
+#include <com/sun/star/awt/XItemListener.hpp>
+#include <vcl/combobox.hxx>
+#include <vcl/lstbox.hxx>
+
+#include <toolkit/awt/vclxwindows.hxx>
+
+using namespace ::com::sun::star;
+using rtl::OUString;
+
+namespace layout
+{
+
+class EditImpl : public ControlImpl
+               , public ::cppu::WeakImplHelper1< awt::XTextListener >
+{
+public:
+    Link maModifyHdl;
+
+    uno::Reference< awt::XTextComponent > mxEdit;
+    EditImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ControlImpl( context, peer, window )
+        , mxEdit( peer, uno::UNO_QUERY )
+    {
+    }
+
+    ~EditImpl ();
+
+    virtual void SAL_CALL disposing( lang::EventObject const& e )
+        throw (css::uno::RuntimeException);
+
+    virtual void SetModifyHdl( Link const& link );
+
+    void SAL_CALL textChanged( const css::awt::TextEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        maModifyHdl.Call( mpWindow );
+    }
+};
+
+EditImpl::~EditImpl ()
+{
+}
+
+void SAL_CALL EditImpl::disposing( lang::EventObject const& e )
+    throw (css::uno::RuntimeException)
+{
+    ControlImpl::disposing (e);
+    mxEdit.clear ();
+}
+
+void EditImpl::SetModifyHdl( Link const& link )
+{
+    if (!link && !!maModifyHdl)
+        mxEdit->removeTextListener( this );
+    else if (!!link && !maModifyHdl)
+        mxEdit->addTextListener( this );
+    maModifyHdl = link;
+}
+
+Edit::~Edit ()
+{
+    SetModifyHdl (Link ());
+}
+
+void Edit::SetSelection( Selection const& rSelection )
+{
+    if ( !getImpl().mxEdit.is() )
+        return;
+    getImpl().mxEdit->setSelection( awt::Selection( rSelection.Min(), rSelection.Max() ) );
+}
+
+void Edit::SetText( OUString const& rStr ) const
+{
+    if ( !getImpl().mxEdit.is() )
+        return;
+    getImpl().mxEdit->setText( rStr );
+}
+
+String Edit::GetText() const
+{
+    if ( !getImpl().mxEdit.is() )
+        return OUString();
+    return OUString( getImpl().mxEdit->getText());
+}
+
+void Edit::SetModifyHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxEdit.is ())
+        getImpl().SetModifyHdl( link );
+}
+
+IMPL_CONSTRUCTORS( Edit, Control, "edit" );
+IMPL_GET_IMPL( Edit );
+
+// Window/Control/Edit/MultiLineEdit
+class MultiLineEditImpl : public EditImpl
+{
+public:
+    MultiLineEditImpl( Context *context, const PeerHandle &peer, Window *window )
+        : EditImpl( context, peer, window )
+    {
+    }
+};
+
+IMPL_CONSTRUCTORS( MultiLineEdit, Edit, "multilineedit" );
+IMPL_GET_IMPL( MultiLineEdit );
+
+// Window/Control/Edit/SpinField
+class SpinFieldImpl : public EditImpl
+{
+  public:
+    SpinFieldImpl( Context *context, const PeerHandle &peer, Window *window )
+        : EditImpl( context, peer, window )
+    {
+    }
+};
+
+IMPL_CONSTRUCTORS( SpinField, Edit, "spinfield" );
+
+// Window/Control/Edit/SpinField/NumericField
+class NumericFieldImpl : public SpinFieldImpl
+{
+  public:
+    NumericFieldImpl( Context *context, const PeerHandle &peer, Window *window )
+        : SpinFieldImpl( context, peer, window )
+    {
+    }
+};
+
+// Window/Control/Edit/SpinField/MetricField
+class MetricFieldImpl : public SpinFieldImpl
+{
+  public:
+    MetricFieldImpl( Context *context, const PeerHandle &peer, Window *window )
+        : SpinFieldImpl( context, peer, window )
+    {
+    }
+};
+
+IMPL_GET_IMPL( SpinField );
+IMPL_GET_IMPL( NumericField );
+IMPL_GET_IMPL( MetricField );
+
+// FormatterBase
+class FormatterBaseImpl
+{
+  protected:
+    PeerHandle mpeer;
+  public:
+    explicit FormatterBaseImpl( const PeerHandle &peer )
+        : mpeer( peer )
+    {
+    };
+};
+
+FormatterBase::FormatterBase( FormatterBaseImpl *pFormatImpl )
+    : mpFormatImpl( pFormatImpl )
+{
+}
+
+class NumericFormatterImpl : public FormatterBaseImpl
+{
+  public:
+    uno::Reference< awt::XNumericField > mxField;
+    explicit NumericFormatterImpl( const PeerHandle &peer )
+        : FormatterBaseImpl( peer )
+        , mxField( peer, uno::UNO_QUERY )
+    {
+    }
+
+    // FIXME: burn that CPU ! cut/paste from vclxwindows.cxx
+    double valueToDouble( sal_Int64 nValue )
+    {
+        sal_Int16 nDigits = mxField->getDecimalDigits();
+        double n = (double)nValue;
+        for ( sal_uInt16 d = 0; d < nDigits; d++ )
+            n /= 10;
+        return n;
+    } // FIXME: burn that CPU ! cut/paste from vclxwindows.cxx
+    sal_Int64 doubleToValue( double nValue )
+    {
+        sal_Int16 nDigits = mxField->getDecimalDigits();
+        double n = nValue;
+        for ( sal_uInt16 d = 0; d < nDigits; d++ )
+            n *= 10;
+        return (sal_Int64) n;
+    }
+};
+
+class MetricFormatterImpl : public FormatterBaseImpl
+{
+  public:
+    uno::Reference< awt::XMetricField > mxField;
+    explicit MetricFormatterImpl( const PeerHandle &peer )
+        : FormatterBaseImpl( peer )
+        , mxField( peer, uno::UNO_QUERY )
+    {
+    }
+};
+
+// NumericFormatter
+
+NumericFormatter::NumericFormatter( FormatterBaseImpl *pImpl )
+    : FormatterBase( pImpl )
+{
+}
+
+NumericFormatterImpl& NumericFormatter::getFormatImpl() const
+{
+    return *( static_cast<NumericFormatterImpl *>( mpFormatImpl ) );
+}
+
+#define SET_IMPL(vclmethod, idlmethod) \
+    void NumericFormatter::vclmethod( sal_Int64 nValue ) \
+    { \
+        if ( !getFormatImpl().mxField.is() ) \
+            return; \
+        getFormatImpl().mxField->idlmethod( getFormatImpl().valueToDouble( nValue ) ); \
+    }
+
+SET_IMPL( SetMin, setMin )
+SET_IMPL( SetMax, setMax )
+SET_IMPL( SetLast, setLast )
+SET_IMPL( SetFirst, setFirst )
+SET_IMPL( SetValue, setValue )
+SET_IMPL( SetSpinSize, setSpinSize )
+
+sal_Int64 NumericFormatter::GetValue() const
+{
+    if ( !getFormatImpl().mxField.is() )
+        return 0;
+    return getFormatImpl().doubleToValue( getFormatImpl().mxField->getValue() );
+}
+
+#undef SET_IMPL
+
+IMPL_CONSTRUCTORS_2( NumericField, SpinField, NumericFormatter, "numericfield" );
+
+// MetricFormatter
+
+MetricFormatter::MetricFormatter( FormatterBaseImpl *pImpl )
+    : FormatterBase( pImpl )
+{
+}
+MetricFormatterImpl& MetricFormatter::getFormatImpl() const
+{    return *( static_cast<MetricFormatterImpl *>( mpFormatImpl ) );   }
+
+#define MetricUnitVclToUno(a) ((sal_uInt16)(a))
+
+#define SET_IMPL(vclmethod, idlmethod) \
+    void MetricFormatter::vclmethod( sal_Int64 nValue, FieldUnit nUnit ) \
+    { \
+        if ( !getFormatImpl().mxField.is() ) \
+            return; \
+        getFormatImpl().mxField->idlmethod( nValue, MetricUnitVclToUno( nUnit ) ); \
+    }
+
+SET_IMPL( SetMin, setMin )
+SET_IMPL( SetMax, setMax )
+SET_IMPL( SetLast, setLast )
+SET_IMPL( SetFirst, setFirst )
+SET_IMPL( SetValue, setValue )
+
+#undef SET_IMPL
+
+void MetricFormatter::SetSpinSize( sal_Int64 nValue )
+{
+    if ( !getFormatImpl().mxField.is() )
+        return;
+    getFormatImpl().mxField->setSpinSize( nValue );
+}
+
+sal_Int64 MetricFormatter::GetValue( FieldUnit nUnit ) const
+{
+    if ( !getFormatImpl().mxField.is() )
+        return 0;
+    return getFormatImpl().mxField->getValue( MetricUnitVclToUno( nUnit ) );
+}
+
+IMPL_CONSTRUCTORS_2( MetricField, SpinField, MetricFormatter, "metricfield" );
+
+// Window/Control/Edit/ComboBox
+class ComboBoxImpl : public EditImpl
+                   , public ::cppu::WeakImplHelper1< awt::XActionListener >
+                   , public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+public:
+    uno::Reference< awt::XComboBox > mxComboBox;
+
+    Link maClickHdl;
+    Link maSelectHdl;
+
+    Window *parent;
+    
+    ComboBoxImpl( Context *context, const PeerHandle &peer, Window *window )
+        : EditImpl( context, peer, window )
+        , mxComboBox( peer, uno::UNO_QUERY )
+    {
+    }
+
+    ~ComboBoxImpl ();
+
+    sal_uInt16 InsertEntry( OUString const& rStr, sal_uInt16 nPos )
+    {
+        if ( nPos == COMBOBOX_APPEND )
+            nPos = GetEntryCount();
+        mxComboBox->addItem( rtl::OUString( rStr ), nPos );
+        return nPos;
+    }
+
+    void RemoveEntry( sal_uInt16 nPos )
+    {
+        mxComboBox->removeItems( nPos, 1 );
+    }
+
+    sal_uInt16 GetEntryPos( const OUString& rStr ) const
+    {
+        uno::Sequence< rtl::OUString> aItems( mxComboBox->getItems() );
+        rtl::OUString rKey( rStr );
+        for (unsigned int i = 0; aItems.getLength(); i++)
+        {
+            if ( aItems[ i ] == rKey )
+                return sal::static_int_cast< sal_uInt16 >( i );
+        }
+        return COMBOBOX_ENTRY_NOTFOUND;
+    }
+
+    OUString GetEntry( sal_uInt16 nPos ) const
+    {
+        return OUString( mxComboBox->getItem( nPos ) );
+    }
+
+    sal_uInt16 GetEntryCount() const
+    {
+        return mxComboBox->getItemCount();
+    }
+
+    void SetClickHdl( Link const& link )
+    {
+        if (!link && !!maClickHdl)
+            mxComboBox->removeActionListener( this );
+        else if (!!link && !maClickHdl)
+            mxComboBox->addActionListener( this );
+        maClickHdl = link;
+    }
+
+    void SetSelectHdl( Link const& link )
+    {
+        if (!link && !!maSelectHdl)
+            mxComboBox->removeItemListener( this );
+        else if (!!link && !maSelectHdl)
+            mxComboBox->addItemListener( this );
+        maSelectHdl = link;
+    }
+
+    virtual void SAL_CALL disposing( lang::EventObject const& e )
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        ComboBox* pComboBox = static_cast<ComboBox*>( mpWindow );
+        if ( !pComboBox )
+            return;
+        maClickHdl.Call( pComboBox );
+    }
+
+    virtual void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        ComboBox* pComboBox = static_cast<ComboBox*>( mpWindow );
+        if ( !pComboBox )
+            return;
+        maSelectHdl.Call( pComboBox );
+    }
+};
+
+ComboBox::~ComboBox ()
+{
+    OSL_TRACE ("%s: deleting ComboBox for window: %p", __FUNCTION__, GetWindow ());
+}
+
+ComboBoxImpl::~ComboBoxImpl ()
+{
+    OSL_TRACE ("%s: deleting ComboBoxImpl for window: %p", __FUNCTION__, mpWindow ? mpWindow->GetWindow () : 0);
+    OSL_TRACE ("%s: deleting ComboBoxImpl for listener: %p", __FUNCTION__, static_cast<XFocusListener*> (this));
+}
+
+void ComboBoxImpl::disposing( lang::EventObject const& e )
+    throw (css::uno::RuntimeException)
+{
+    EditImpl::disposing (e);
+    mxComboBox.clear ();
+}
+
+sal_uInt16 ComboBox::InsertEntry( const OUString &rStr, sal_uInt16 nPos )
+{
+    return getImpl().InsertEntry( rStr, nPos );
+}
+
+void ComboBox::RemoveEntry( const OUString& rStr )
+{
+    getImpl().RemoveEntry( GetEntryPos( rStr ) );
+}
+
+void ComboBox::RemoveEntry( sal_uInt16 nPos )
+{
+    getImpl().RemoveEntry( nPos );
+}
+
+void ComboBox::Clear()
+{
+    uno::Sequence< rtl::OUString> aNoItems;
+    getImpl().setProperty( "StringItemList", uno::Any( aNoItems ) );
+}
+
+sal_uInt16 ComboBox::GetEntryPos( const OUString& rStr ) const
+{
+    return getImpl().GetEntryPos( rStr );
+}
+
+String ComboBox::GetEntry( sal_uInt16 nPos ) const
+{
+    rtl::OUString rItem = getImpl().mxComboBox->getItem( nPos );
+    return OUString( rItem );
+}
+
+sal_uInt16 ComboBox::GetEntryCount() const
+{
+    return getImpl().GetEntryCount();
+}
+
+void ComboBox::SetClickHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxComboBox.is ())
+        getImpl().SetClickHdl( link );
+}
+
+void ComboBox::SetSelectHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxComboBox.is ())
+        getImpl().SetSelectHdl( link );
+}
+
+void ComboBox::EnableAutocomplete (bool enable, bool matchCase)
+{
+    GetComboBox ()->EnableAutocomplete (enable, matchCase);
+}
+
+IMPL_CONSTRUCTORS_BODY( ComboBox, Edit, "combobox", getImpl().parent = parent; );
+IMPL_GET_WINDOW (ComboBox);
+/// IMPL_GET_IMPL( ComboBox );
+
+static ComboBoxImpl& null_combobox_impl = (ComboBoxImpl&)*(ComboBoxImpl*)0;
+
+ComboBoxImpl &ComboBox::getImpl () const
+{
+    if (ComboBoxImpl* c = static_cast<ComboBoxImpl *>(mpImpl))
+        return *c;
+    return null_combobox_impl;
+}
+
+
+// Window/Control/ListBox
+class ListBoxImpl : public ControlImpl
+                  , public ::cppu::WeakImplHelper1< awt::XActionListener >
+                  , public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maClickHdl;
+    Link maSelectHdl;
+public:
+    uno::Reference< awt::XListBox > mxListBox;
+    ListBoxImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ControlImpl( context, peer, window ),
+        mxListBox( peer, uno::UNO_QUERY )
+    {
+        SelectEntryPos( 0, true );
+    }
+
+    sal_uInt16 InsertEntry(const OUString& rStr, sal_uInt16 nPos)
+    {
+        if ( nPos == LISTBOX_APPEND )
+            nPos = mxListBox->getItemCount();
+        mxListBox->addItem( rtl::OUString( rStr ), nPos );
+        return nPos;
+    }
+
+    void RemoveEntry( sal_uInt16 nPos )
+    {
+        mxListBox->removeItems( nPos, 1 );
+    }
+
+    sal_uInt16 RemoveEntry(const OUString& rStr, sal_uInt16 nPos)
+    {
+        if ( nPos == LISTBOX_APPEND )
+            nPos = mxListBox->getItemCount();
+        mxListBox->addItem( rtl::OUString( rStr ), nPos );
+        return nPos;
+    }
+
+    sal_uInt16 GetEntryPos( const OUString& rStr ) const
+    {
+        uno::Sequence< rtl::OUString> aItems( mxListBox->getItems() );
+        rtl::OUString rKey( rStr );
+        for (unsigned int i = 0; aItems.getLength(); i++)
+        {
+            if ( aItems[ i ] == rKey )
+                return sal::static_int_cast< sal_uInt16 >( i );
+        }
+        return LISTBOX_ENTRY_NOTFOUND;
+    }
+
+    OUString GetEntry( sal_uInt16 nPos ) const
+    {
+        return mxListBox->getItem( nPos );
+    }
+
+    sal_uInt16 GetEntryCount() const
+    {
+        return mxListBox->getItemCount();
+    }
+
+    void SelectEntryPos( sal_uInt16 nPos, bool bSelect )
+    {
+        mxListBox->selectItemPos( nPos, bSelect );
+    }
+
+    sal_uInt16 GetSelectEntryCount() const
+    {
+        return sal::static_int_cast< sal_uInt16 >( mxListBox->getSelectedItems().getLength() );
+    }
+
+    sal_uInt16 GetSelectEntryPos( sal_uInt16 nSelIndex ) const
+    {
+        sal_uInt16 nSelected = 0;
+        if ( mxListBox->isMutipleMode() )
+        {
+            uno::Sequence< short > aItems( mxListBox->getSelectedItemsPos() );
+            if ( nSelIndex < aItems.getLength() )
+                nSelected = aItems[ nSelIndex ];
+        }
+        else
+            nSelected = mxListBox->getSelectedItemPos();
+        return nSelected;
+    }
+
+    void SetClickHdl( Link const& link )
+    {
+        if (!link && !!maClickHdl)
+            mxListBox->removeActionListener( this );
+        else if (!!link && !maClickHdl)
+            mxListBox->addActionListener( this );
+        maClickHdl = link;
+    }
+
+    void SetSelectHdl( Link const& link )
+    {
+        if (!link && !!maSelectHdl)
+            mxListBox->removeItemListener( this );
+        else if (!!link && !maSelectHdl)
+            mxListBox->addItemListener( this );
+        maSelectHdl = link;
+    }
+
+    virtual void SAL_CALL disposing( lang::EventObject const& e )
+        throw (css::uno::RuntimeException)
+    {
+        ControlImpl::disposing (e);
+        mxListBox.clear ();
+    }
+
+    void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        maClickHdl.Call( mpWindow );
+    }
+
+    void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        ListBox* pListBox = static_cast<ListBox*>( mpWindow );
+        if ( !pListBox )
+            return;
+        maSelectHdl.Call( pListBox );
+    }
+};
+
+ListBox::~ListBox ()
+{
+}
+
+sal_uInt16 ListBox::InsertEntry(const OUString& rStr, sal_uInt16 nPos)
+{
+    return getImpl().InsertEntry(rStr, nPos);
+}
+
+void ListBox::RemoveEntry( sal_uInt16 nPos )
+{
+    return getImpl().RemoveEntry( nPos );
+}
+
+void ListBox::RemoveEntry( const OUString& rStr )
+{
+    return getImpl().RemoveEntry( GetEntryPos( rStr ) );
+}
+
+void ListBox::Clear()
+{
+    uno::Sequence< rtl::OUString> aNoItems;
+    getImpl().setProperty( "StringItemList", uno::Any( aNoItems ) );
+}
+
+sal_uInt16 ListBox::GetEntryPos( const OUString& rStr ) const
+{
+    return getImpl().GetEntryPos( rStr );
+}
+
+String ListBox::GetEntry( sal_uInt16 nPos ) const
+{
+    return getImpl().GetEntry( nPos );
+}
+
+sal_uInt16 ListBox::GetEntryCount() const
+{
+    return getImpl().GetEntryCount();
+}
+
+void ListBox::SelectEntryPos( sal_uInt16 nPos, bool bSelect )
+{
+    getImpl().SelectEntryPos( nPos, bSelect );
+}
+
+void ListBox::SelectEntry( const OUString& rStr, bool bSelect )
+{
+    SelectEntryPos( GetEntryPos( rStr ), bSelect );
+}
+
+sal_uInt16 ListBox::GetSelectEntryCount() const
+{
+    return getImpl().GetSelectEntryCount();
+}
+
+sal_uInt16 ListBox::GetSelectEntryPos( sal_uInt16 nSelIndex ) const
+{
+    return getImpl().GetSelectEntryPos( nSelIndex );
+}
+
+String ListBox::GetSelectEntry( sal_uInt16 nSelIndex ) const
+{
+    return GetEntry( GetSelectEntryPos( nSelIndex ) );
+}
+
+void ListBox::SetSelectHdl( const Link& link )
+{
+    getImpl().SetSelectHdl( link );
+}
+
+void ListBox::SetClickHdl( const Link& link )
+{
+    if (&getImpl () && getImpl().mxListBox.is ())
+        getImpl().SetClickHdl( link );
+}
+
+
+void ListBox::SetEntryData( sal_uInt16 pos, void* data)
+{
+    GetListBox ()->SetEntryData (pos, data);
+}
+
+void* ListBox::GetEntryData( sal_uInt16 pos) const
+{
+    return GetListBox ()->GetEntryData (pos);
+} 
+
+// SvxLanguageBox
+void ListBox::SetLanguageList( sal_Int16/*list*/, bool/*hasLangNone*/, bool /*langNoneIsLangAll*/, bool /*checkSpellAvail*/)
+{
+}
+
+sal_uInt16 ListBox::InsertLanguage( const LanguageType/*type*/, sal_uInt16/*pos*/)
+{
+    return 0;
+}
+sal_uInt16 ListBox::InsertLanguage( const LanguageType/*type*/, bool/*checkEntry*/, sal_uInt16 /*pos*/)
+{
+    return 0;
+}
+void ListBox::RemoveLanguage( const LanguageType/*type*/)
+{
+}
+void ListBox::SelectLanguage( const LanguageType/*type*/, bool/*select*/)
+{
+}
+LanguageType ListBox::GetSelectLanguage() const
+{
+    return 0;
+}
+bool ListBox::IsLanguageSelected( const LanguageType/*type*/) const
+{
+    return true;
+}
+
+IMPL_CONSTRUCTORS ( ListBox, Control, "listbox" );
+IMPL_GET_IMPL( ListBox );
+IMPL_GET_WINDOW (ListBox);
+
+// Window/Control/List/MultiListBox
+class MultiListBoxImpl : public ListBoxImpl
+{
+public:
+    MultiListBoxImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ListBoxImpl( context, peer, window )
+    {
+    }
+};
+
+IMPL_CONSTRUCTORS_BODY( MultiListBox, ListBox, "multilistbox", GetMultiListBox()->EnableMultiSelection( true ); );
+IMPL_GET_IMPL( MultiListBox );
+IMPL_GET_WINDOW( MultiListBox );
+
+} // namespace layout
diff --git a/toolkit/source/layout/vcl/wrapper.cxx b/toolkit/source/layout/vcl/wrapper.cxx
new file mode 100644
index 0000000..e3361e6
--- /dev/null
+++ toolkit/source/layout/vcl/wrapper.cxx
@@ -0,0 +1,1586 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <tools/rc.h>
+//#define RESOURCE_PUBLISH_PROTECTED 1
+#if RESOURCE_PUBLISH_PROTECTED
+// ugh, override non-helpful proctection
+#define protected public
+#endif /* RESOURCE_PUBLISH_PROTECTED */
+#include <tools/rc.hxx>
+#undef protected
+
+
+#include "wrapper.hxx"
+
+#include <awt/vclxplugin.hxx>
+#include <awt/vclxtabcontrol.hxx>
+#include <com/sun/star/awt/PosSize.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/awt/XDialog2.hpp>
+#include <com/sun/star/awt/XProgressBar.hpp>
+#include <com/sun/star/awt/XSimpleTabController.hpp>
+#include <com/sun/star/awt/XTabListener.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <comphelper/processfactory.hxx>
+#include <layout/core/factory.hxx>
+#include <layout/core/localized-string.hxx>
+#include <layout/core/root.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <vcl/ctrl.hxx>
+#include <vcl/dialog.hxx>
+#include <vcl/image.hxx>
+#include <vcl/tabctrl.hxx>
+#include <vcl/tabpage.hxx>
+#include <vcl/window.hxx>
+
+using namespace ::com::sun::star;
+using rtl::OUString;
+
+namespace layout
+{
+
+// Context bits ...
+class ContextImpl
+{
+    uno::Reference< awt::XLayoutRoot > mxRoot;
+    uno::Reference< container::XNameAccess > mxNameAccess;
+    PeerHandle mxTopLevel;
+
+public:
+    ContextImpl( char const *pPath )
+    {
+        uno::Sequence< uno::Any > aParams( 1 );
+        aParams[0] <<= OUString( pPath, strlen( pPath ), RTL_TEXTENCODING_UTF8 );
+
+        uno::Reference< lang::XSingleServiceFactory > xFactory(
+            comphelper::createProcessComponent(
+                OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
+            uno::UNO_QUERY );
+        if ( !xFactory.is() )
+        {
+            throw uno::RuntimeException(
+                OUString( RTL_CONSTASCII_USTRINGPARAM( "Layout engine not installed" ) ),
+                uno::Reference< uno::XInterface >() );
+        }
+        mxRoot = uno::Reference< awt::XLayoutRoot >(
+            xFactory->createInstanceWithArguments( aParams ),
+            uno::UNO_QUERY );
+
+        mxNameAccess = uno::Reference< container::XNameAccess >( mxRoot, uno::UNO_QUERY );
+    }
+
+    ~ContextImpl()
+    {
+    }
+
+    PeerHandle getByName( const OUString &rName )
+    {
+        uno::Any val = mxNameAccess->getByName( rName );
+        PeerHandle xRet;
+        val >>= xRet;
+        return xRet;
+    }
+    PeerHandle getTopLevel()
+    {
+        return mxTopLevel;
+    }
+    void setTopLevel( PeerHandle xToplevel )
+    {
+        mxTopLevel = xToplevel;
+    }
+    PeerHandle getRoot()
+    {
+        return mxRoot;
+    }
+};
+
+Context::Context( const char *pPath )
+    : pImpl( new ContextImpl( pPath ) )
+{
+}
+Context::~Context()
+{
+    delete pImpl;
+    pImpl = NULL;
+}
+
+void Context::setToplevel( PeerHandle xToplevel )
+{
+    pImpl->setTopLevel( xToplevel );
+}
+
+PeerHandle Context::getToplevel()
+{
+    return pImpl->getTopLevel();
+}
+PeerHandle Context::getRoot()
+{
+    return pImpl->getRoot();
+}
+
+PeerHandle Context::GetPeerHandle( const char *id, sal_uInt32 nId ) const
+{
+    PeerHandle xHandle;
+    xHandle = pImpl->getByName( OUString( id, strlen( id ), RTL_TEXTENCODING_UTF8 ) );
+    if ( !xHandle.is() )
+    {
+        DBG_ERROR1( "Failed to fetch widget '%s'", id );
+    }
+
+    if ( nId != 0 )
+    {
+        rtl::OString aStr = rtl::OString::valueOf( (sal_Int32) nId );
+        xHandle = GetPeerHandle( aStr, 0 );
+    }
+    return xHandle;
+}
+
+WindowImpl::WindowImpl (Context *context, const PeerHandle &peer, Window *window)
+    : mpWindow (window)
+    , mpCtx (context)
+    , mxWindow (peer, uno::UNO_QUERY)
+    , mxVclPeer (peer, uno::UNO_QUERY)
+    , mvclWindow (0)
+    , bFirstTimeVisible (true)
+{
+}
+
+WindowImpl::~WindowImpl ()
+{
+    if (mpWindow)
+        mpWindow->mpImpl = 0;
+    if (mvclWindow)
+    {
+        VCLXWindow *v = mvclWindow->GetWindowPeer ();
+        v->SetWindow (0);
+        mvclWindow->SetComponentInterface (uno::Reference <awt::XWindowPeer> ());
+        mvclWindow->SetWindowPeer (uno::Reference <awt::XWindowPeer> (), 0);
+        delete mvclWindow;
+        mvclWindow = 0;
+    }
+}
+
+void WindowImpl::wrapperGone ()
+{
+    mvclWindow = 0;
+    mpWindow->mpImpl = 0;
+    mpWindow = 0;
+    mpCtx = 0;
+    if ( mxWindow.is() )
+    {
+        uno::Reference< lang::XComponent > xComp( mxWindow, uno::UNO_QUERY );
+        mxWindow.clear ();
+        if ( xComp.is() )
+            xComp->dispose();
+    }
+}
+
+void SAL_CALL WindowImpl::disposing (lang::EventObject const&)
+    throw (uno::RuntimeException)
+{
+    if (mxWindow.is ())
+        mxWindow.clear ();
+}
+
+uno::Any WindowImpl::getProperty (char const* name)
+{
+    if ( !this || !mxVclPeer.is() )
+        return css::uno::Any();
+    return mxVclPeer->getProperty
+        ( rtl::OUString( name, strlen( name ), RTL_TEXTENCODING_ASCII_US ) );
+}
+
+void WindowImpl::setProperty (char const *name, uno::Any any)
+{
+    if ( !this || !mxVclPeer.is() )
+        return;
+    mxVclPeer->setProperty
+        ( rtl::OUString( name, strlen( name ), RTL_TEXTENCODING_ASCII_US ), any );
+}
+
+void WindowImpl::redraw (bool resize)
+{
+    uno::Reference <awt::XWindow> ref (mxWindow, uno::UNO_QUERY);
+    ::Window* window = VCLXWindow::GetImplementation (ref)->GetWindow ();
+    ::Window* parent = window->GetParent();
+    ::Rectangle r = Rectangle (parent->GetPosPixel (),
+                               parent->GetSizePixel ());
+    parent->Invalidate (r, INVALIDATE_CHILDREN | INVALIDATE_NOCHILDREN );
+    if (resize)
+        parent->SetPosSizePixel (0, 0, 1, 1, awt::PosSize::SIZE);
+    else
+        parent->SetPosSizePixel (0, 0, r.nRight - r.nLeft, r.nBottom - r.nTop,
+                                 awt::PosSize::SIZE);
+}
+
+Window::Window( WindowImpl *pImpl )
+    : mpImpl( pImpl )
+{
+    mpImpl->mvclWindow = GetVCLXWindow () ? GetWindow () : 0;
+}
+
+Window::~Window()
+{
+    /* likely to be an UNO object - with floating references */
+    if (mpImpl)
+        mpImpl->wrapperGone ();
+    mpImpl = 0;
+}
+
+///IMPL_GET_IMPL( Control );
+
+static ControlImpl& null_control_impl = (ControlImpl&)*(ControlImpl*)0;
+
+ControlImpl &Control::getImpl () const
+{
+    if (ControlImpl* c = static_cast<ControlImpl *>(mpImpl))
+        return *c;
+    return null_control_impl;
+}
+
+Control::~Control ()
+{
+    SetGetFocusHdl (Link ());
+    SetLoseFocusHdl (Link ());
+}
+
+void Window::setRes (ResId const& res)
+{
+#if RESOURCE_PUBLISH_PROTECTED
+    // Resources are shut-off from use.  Is that really necessary?
+    Resource &r = *GetWindow ();
+    r.GetRes (res);
+#else /* !RESOURCE_PUBLISH_PROTECTED */
+    //We *must* derive.  Is this also really necessary?
+    //Resource r (res);
+
+    // ugh, I wonder which solution is cleaner...
+    class Resource_open_up : public Resource
+    {
+    public:
+        Resource_open_up (ResId const& r)
+            : Resource (r)
+        {
+        }
+        static sal_Int32 GetLongRes (void *p)
+        {
+            return Resource::GetLongRes (p);
+        }
+        void* GetClassRes ()
+        {
+            return Resource::GetClassRes ();
+        }
+        sal_Int32 ReadLongRes ()
+        {
+            return Resource::ReadLongRes ();
+        }
+        UniString ReadStringRes ()
+        {
+            return Resource::ReadStringRes ();
+        }
+    };
+
+    Resource_open_up r (res);
+#endif /* !RESOURCE_PUBLISH_PROTECTED */
+    if (sal_uInt32 help_id = (sal_uInt32)r.GetLongRes (static_cast<char *> (r.GetClassRes ()) + 12))
+        SetHelpId (help_id);
+    sal_uInt32 mask = r.ReadLongRes ();
+    if ( mask & WINDOW_TEXT )
+        SetText( r.ReadStringRes ());
+}
+
+void Window::SetParent( ::Window *parent )
+{
+    uno::Reference <awt::XWindow> ref( GetPeer(), uno::UNO_QUERY );
+    if (VCLXWindow *vcl = VCLXWindow::GetImplementation( ref ))
+        if (::Window *window = vcl->GetWindow())
+            window->SetParent( parent );
+}
+
+void Window::SetParent( Window *parent )
+{
+    /* Let's hear it for C++: poor man's dynamic binding.  */
+    parent->ParentSet (this);
+}
+
+void Window::ParentSet (Window *window)
+{
+    window->SetParent (GetWindow ());
+}
+
+Context *Window::getContext()
+{
+    return this && mpImpl ? mpImpl->mpCtx : NULL;
+}
+
+PeerHandle Window::GetPeer() const
+{
+    if ( !mpImpl )
+        return PeerHandle();
+    return mpImpl->mxWindow;
+}
+
+uno::Reference<awt::XWindow> Window::GetRef() const
+{
+    return uno::Reference <awt::XWindow> ( GetPeer(), uno::UNO_QUERY );
+}
+
+VCLXWindow* Window::GetVCLXWindow() const
+{
+    return VCLXWindow::GetImplementation( GetRef() );
+}
+
+::Window* Window::GetWindow() const
+{
+    return GetVCLXWindow()->GetWindow();
+}
+
+::Window* Window::GetParent() const
+{
+    return GetWindow()->GetParent();
+}
+
+void Window::SetHelpId( sal_uIntPtr id )
+{
+    GetWindow()->SetHelpId( id );
+}
+
+sal_uIntPtr Window::GetHelpId() const
+{
+    return GetWindow()->GetHelpId();
+}
+
+void Window::SetSmartHelpId( SmartId const& id, SmartIdUpdateMode mode )
+{
+    GetWindow()->SetSmartHelpId( id, mode );
+}
+
+SmartId Window::GetSmartHelpId() const
+{
+    return GetWindow()->GetSmartHelpId();
+}
+
+void Window::EnterWait ()
+{
+    GetWindow()->EnterWait ();
+}
+void Window::LeaveWait ()
+{
+    GetWindow()->LeaveWait ();
+}
+bool Window::IsWait () const
+{
+    return GetWindow()->IsWait ();
+}
+
+bool Window::IsVisible () const
+{
+    if (GetWindow ())
+        return GetWindow()->IsVisible ();
+    return false;
+}
+
+bool Window::HasChildPathFocus (bool systemWindow) const
+{
+    return GetWindow()->HasChildPathFocus (systemWindow);
+}
+
+void Window::SetPosPixel (Point const&)
+{
+}
+
+Point Window::GetPosPixel () const
+{
+    return Point ();
+}
+
+void Window::SetSizePixel (Size const&)
+{
+}
+
+Size Window::GetSizePixel () const
+{
+    return Size ();
+}
+
+// void Window::Enable (bool enable, bool child);
+// {
+//     GetWindow ()->Enable (enable, child);
+// }
+
+// void Window::Disable (bool child)
+// {
+//     GetWindow ()->Disable (child);
+// }
+
+bool Window::IsEnabled () const
+{
+    return GetWindow ()->IsEnabled ();
+//     if (getImpl().mxWindow.is ())
+//         return getImpl ().mxWindow->isEnabled ();
+//     return false;
+}
+
+void Window::EnableInput (bool enable, bool child)
+{
+    GetWindow ()->EnableInput (enable, child);
+}
+
+bool Window::IsInputEnabled () const
+{
+    return GetWindow ()->IsInputEnabled ();
+}
+
+struct ToolkitVclPropsMap
+{
+    WinBits vclStyle;
+    long initAttr;
+    const char *propName;
+
+    // the value to give the prop to enable/disable it -- not the most brilliant
+    // type declaration and storage, but does the work... properties are
+    // either a boolean or a short since they are either a directly wrappers for
+    // a WinBit, or aggregates related (like Align for WB_LEFT, _RIGHT and _CENTER).
+    bool isBoolean;
+    short enableProp, disableProp;
+};
+
+#define TYPE_BOOL  true
+#define TYPE_SHORT false
+#define NOTYPE     0
+static const ToolkitVclPropsMap toolkitVclPropsMap[] =
+{
+    { WB_BORDER,    awt::WindowAttribute::BORDER,    "Border", TYPE_SHORT, 1, 0 },
+    { WB_NOBORDER,    awt::VclWindowPeerAttribute::NOBORDER,    "Border", TYPE_SHORT, 0, 1 },
+    { WB_SIZEABLE,    awt::WindowAttribute::SIZEABLE,    NULL, NOTYPE, 0, 0 },
+    { WB_MOVEABLE,    awt::WindowAttribute::MOVEABLE,    NULL, NOTYPE, 0, 0 },
+    { WB_CLOSEABLE,    awt::WindowAttribute::CLOSEABLE,    NULL, NOTYPE, 0, 0 },
+
+    { WB_HSCROLL,    awt::VclWindowPeerAttribute::HSCROLL,    NULL, NOTYPE, 0, 0 },
+    { WB_VSCROLL,    awt::VclWindowPeerAttribute::VSCROLL,    NULL, NOTYPE, 0, 0 },
+    { WB_LEFT,    awt::VclWindowPeerAttribute::LEFT,    "Align", TYPE_SHORT, 0, 0 },
+    { WB_CENTER,    awt::VclWindowPeerAttribute::CENTER,    "Align", TYPE_SHORT, 1, 0 },
+    { WB_RIGHT,    awt::VclWindowPeerAttribute::RIGHT,    "Align", TYPE_SHORT, 2, 0 },
+    { WB_SPIN,    awt::VclWindowPeerAttribute::SPIN,    NULL, NOTYPE, 0, 0 },
+    { WB_SORT,    awt::VclWindowPeerAttribute::SORT,    NULL, NOTYPE, 0, 0 },
+    { WB_DROPDOWN,    awt::VclWindowPeerAttribute::DROPDOWN,    "Dropdown",    TYPE_BOOL, 1, 0 },
+    { WB_DEFBUTTON,    awt::VclWindowPeerAttribute::DEFBUTTON,    "DefaultButton", TYPE_BOOL, 1, 0 },
+    { WB_READONLY,    awt::VclWindowPeerAttribute::READONLY,    NULL, NOTYPE, 0, 0 },
+    { WB_CLIPCHILDREN,    awt::VclWindowPeerAttribute::CLIPCHILDREN,    NULL, NOTYPE, 0, 0 },
+    { WB_GROUP,    awt::VclWindowPeerAttribute::GROUP,    NULL, NOTYPE, 0, 0 },
+
+    { WB_OK,    awt::VclWindowPeerAttribute::OK,    NULL, NOTYPE, 0, 0 },
+    { WB_OK_CANCEL,    awt::VclWindowPeerAttribute::OK_CANCEL,    NULL, NOTYPE, 0, 0 },
+    { WB_YES_NO,    awt::VclWindowPeerAttribute::YES_NO,    NULL, NOTYPE, 0, 0 },
+    { WB_YES_NO_CANCEL,    awt::VclWindowPeerAttribute::YES_NO_CANCEL,    NULL, NOTYPE, 1, 0 },
+    { WB_RETRY_CANCEL,    awt::VclWindowPeerAttribute::RETRY_CANCEL,    NULL, NOTYPE, 1, 0 },
+    { WB_DEF_OK,    awt::VclWindowPeerAttribute::DEF_OK,    NULL, NOTYPE, 0, 0 },
+    { WB_DEF_CANCEL,    awt::VclWindowPeerAttribute::DEF_CANCEL,    NULL, NOTYPE, 1, 0 },
+    { WB_DEF_RETRY,    awt::VclWindowPeerAttribute::DEF_RETRY,    NULL, NOTYPE, 0, 0 },
+    { WB_DEF_YES,    awt::VclWindowPeerAttribute::DEF_YES,    NULL, NOTYPE, 0, 0 },
+    { WB_DEF_NO,    awt::VclWindowPeerAttribute::DEF_NO,    NULL, NOTYPE, 0, 0 },
+
+    { WB_AUTOHSCROLL, awt::VclWindowPeerAttribute::AUTOHSCROLL, "AutoHScroll", TYPE_BOOL, 1, 0 },
+    { WB_AUTOVSCROLL, awt::VclWindowPeerAttribute::AUTOVSCROLL, "AutoVScroll",    TYPE_BOOL, 1, 0 },
+
+    { WB_WORDBREAK,    0,    "MultiLine", TYPE_BOOL, 1, 0 },
+    { WB_NOPOINTERFOCUS,    0,    "FocusOnClick", TYPE_BOOL, 1, 0 },
+    { WB_TOGGLE,    0,    "Toggle", TYPE_BOOL, 1, 0 },
+    { WB_REPEAT,    0,    "Repeat", TYPE_BOOL, 1, 0 },
+    { WB_NOHIDESELECTION,    0,    "HideInactiveSelection", TYPE_BOOL, 1, 0 },
+};
+#undef TYPE_BOOL
+#undef TYPE_SHORT
+#undef NOTYPE
+
+static const int toolkitVclPropsMapLen =
+    sizeof( toolkitVclPropsMap ) / sizeof( ToolkitVclPropsMap );
+
+void Window::SetStyle( WinBits nStyle )
+{
+    uno::Reference< awt::XVclWindowPeer > xPeer = mpImpl->mxVclPeer;
+    for (int i = 0; i < toolkitVclPropsMapLen; i++)
+    {
+        if ( toolkitVclPropsMap[ i ].propName )
+        {
+            short nValue;
+            if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
+                nValue = toolkitVclPropsMap[ i ].enableProp;
+            else
+                nValue = toolkitVclPropsMap[ i ].disableProp;
+            uno::Any aValue;
+            if ( toolkitVclPropsMap[ i ].isBoolean )
+                aValue = uno::makeAny( (bool) nValue );
+            else
+                aValue = uno::makeAny( (short) nValue );
+            mpImpl->setProperty( toolkitVclPropsMap[ i ].propName, aValue );
+        }
+    }
+}
+
+WinBits Window::GetStyle()
+{
+    uno::Reference< awt::XVclWindowPeer > xPeer = mpImpl->mxVclPeer;
+    WinBits ret = 0;
+    for (int i = 0; i < toolkitVclPropsMapLen; i++)
+    {
+        if ( toolkitVclPropsMap[ i ].propName )
+        {
+            short nValue = 0;
+            if ( toolkitVclPropsMap[ i ].isBoolean )
+            {
+                bool bValue = false;
+                mpImpl->getProperty( toolkitVclPropsMap[ i ].propName ) >>= bValue;
+                nValue = bValue ? 1 : 0;
+            }
+            else
+                mpImpl->getProperty( toolkitVclPropsMap[ i ].propName ) >>= nValue;
+            if ( nValue == toolkitVclPropsMap[ i ].enableProp )
+                ret |= toolkitVclPropsMap[i].vclStyle;
+        }
+    }
+    return ret;
+}
+
+/* Unpleasant way to get an xToolkit pointer ... */
+uno::Reference< awt::XToolkit > getToolkit()
+{
+    static uno::Reference< awt::XToolkit > xToolkit;
+    if (!xToolkit.is())
+    {
+        // Urgh ...
+        xToolkit = uno::Reference< awt::XToolkit >(
+            ::comphelper::getProcessServiceFactory()->createInstance(
+                OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.Toolkit" ) ) ),
+            uno::UNO_QUERY );
+        if ( !xToolkit.is() )
+            throw uno::RuntimeException(
+                OUString( RTL_CONSTASCII_USTRINGPARAM( "failed to create toolkit!") ),
+                uno::Reference< uno::XInterface >() );
+    }
+    return xToolkit;
+}
+
+PeerHandle Window::CreatePeer( Window *parent, WinBits nStyle, const char *pName)
+{
+    long nWinAttrbs = 0;
+    for (int i = 0; i < toolkitVclPropsMapLen; i++)
+        if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
+            nWinAttrbs |= toolkitVclPropsMap[ i ].initAttr;
+
+    return layoutimpl::WidgetFactory::createWidget (getToolkit(), parent->GetPeer(), OUString::createFromAscii( pName ), nWinAttrbs);
+}
+
+void Window::Enable( bool bEnable )
+{
+    if ( !getImpl().mxWindow.is() )
+        return;
+    getImpl().mxWindow->setEnable( bEnable );
+}
+
+void Window::Show( bool bVisible )
+{
+    if ( !getImpl().mxWindow.is() )
+        return;
+    getImpl().mxWindow->setVisible( bVisible );
+    if (GetParent() && bVisible && getImpl().bFirstTimeVisible)
+    {
+        getImpl().redraw ();
+        getImpl().bFirstTimeVisible = false;
+    }
+}
+
+void Window::GrabFocus()
+{
+    if ( !getImpl().mxWindow.is() )
+        return;
+    getImpl().mxWindow->setFocus();
+}
+
+void Window::SetUpdateMode(bool mode)
+{
+    GetWindow()->SetUpdateMode( mode );
+}
+
+void Window::SetPointer( Pointer const& pointer )
+{
+    GetWindow()->SetPointer( pointer );
+}
+
+Pointer const& Window::GetPointer() const
+{
+    return GetWindow()->GetPointer();
+}
+
+void Window::SetText( OUString const& str )
+{
+    GetWindow()->SetText( str );
+}
+
+String Window::GetText() const
+{
+    return GetWindow()->GetText();
+}
+
+sal_Int32 Window::GetCtrlTextWidth (OUString const&) const
+{
+    return 0;
+}
+
+sal_Int32 Window::GetTextHeight () const
+{
+    return 0;
+}
+
+Size Window::LogicToPixel( Size const& size, MapMode const&) const
+{
+    return size;
+}
+
+ControlImpl::ControlImpl (Context *context, const PeerHandle &peer, Window *window)
+    : WindowImpl( context, peer, window )
+{
+}
+
+ControlImpl::~ControlImpl ()
+{
+    if ((!!mGetFocusHdl || !!mLoseFocusHdl) && mxWindow.is ())
+        /* Disposing will be done @ VCLXWindow::dispose () maFocusListeners.disposeAndClear()
+           don't do it twice */
+        mxWindow.clear ();
+}
+
+void ControlImpl::SetGetFocusHdl (Link const& link)
+{
+    if (!mLoseFocusHdl || !link)
+        UpdateListening (link);
+    mGetFocusHdl = link;
+}
+
+Link& ControlImpl::GetGetFocusHdl ()
+{
+    return mGetFocusHdl;
+}
+
+void ControlImpl::SetLoseFocusHdl (Link const& link)
+{
+    if (!mGetFocusHdl || !link)
+        UpdateListening (link);
+    mLoseFocusHdl = link;
+}
+
+Link& ControlImpl::GetLoseFocusHdl ()
+{
+    return mGetFocusHdl;
+}
+
+void ControlImpl::UpdateListening (Link const& link)
+{
+    if (!link && (!!mGetFocusHdl || !!mLoseFocusHdl)
+        && (!mGetFocusHdl || !mLoseFocusHdl))
+        mxWindow->removeFocusListener (this);
+    else if (!!link && !mGetFocusHdl && !mLoseFocusHdl)
+        mxWindow->addFocusListener (this);
+}
+
+void SAL_CALL ControlImpl::disposing (lang::EventObject const&)
+    throw (uno::RuntimeException)
+{
+///    mxWindow.clear ();
+}
+
+void SAL_CALL ControlImpl::focusGained (awt::FocusEvent const&)
+    throw (uno::RuntimeException)
+{
+    mGetFocusHdl.Call (mpWindow);
+}
+
+void SAL_CALL ControlImpl::focusLost (awt::FocusEvent const&)
+    throw (uno::RuntimeException)
+{
+    mLoseFocusHdl.Call (mpWindow);
+}
+
+Link& Control::GetGetFocusHdl ()
+{
+    return getImpl ().GetGetFocusHdl ();
+}
+
+void Control::SetGetFocusHdl (Link const& link)
+{
+    if (&getImpl () && getImpl().mxWindow.is ())
+        getImpl ().SetGetFocusHdl (link);
+}
+
+Link& Control::GetLoseFocusHdl ()
+{
+    return getImpl ().GetLoseFocusHdl ();
+}
+
+void Control::SetLoseFocusHdl (Link const& link)
+{
+    if (&getImpl () && getImpl().mxWindow.is ())
+        getImpl ().SetLoseFocusHdl (link);
+}
+
+class DialogImpl : public WindowImpl
+{
+public:
+    uno::Reference< awt::XDialog2 > mxDialog;
+    DialogImpl( Context *context, PeerHandle const &peer, Window *window );
+};
+
+DialogImpl::DialogImpl( Context *context, const PeerHandle &peer, Window *window )
+    : WindowImpl( context, peer, window )
+    , mxDialog( peer, uno::UNO_QUERY )
+{
+}
+
+Dialog::Dialog( Window *parent, const char *xml_file, const char *id, sal_uInt32 nId )
+    : Context( xml_file )
+    , Window( new DialogImpl( this, Context::GetPeerHandle( id, nId ), this ) )
+    , bConstruct (true)
+{
+    if ( parent )
+        SetParent( parent );
+}
+
+Dialog::Dialog( ::Window *parent, const char *xml_file, const char *id, sal_uInt32 nId )
+    : Context( xml_file )
+    , Window( new DialogImpl( this, Context::GetPeerHandle( id, nId ), this ) )
+{
+    if ( parent )
+        SetParent( parent );
+}
+
+Dialog::~Dialog ()
+{
+}
+
+IMPL_GET_WINDOW (Dialog);
+IMPL_GET_IMPL (Dialog);
+
+#define MX_DIALOG if (getImpl ().mxDialog.is ()) getImpl ().mxDialog
+#define RETURN_MX_DIALOG if (getImpl ().mxDialog.is ()) return getImpl ().mxDialog
+
+short Dialog::Execute()
+{
+    RETURN_MX_DIALOG->execute ();
+    return -1;
+}
+
+void Dialog::EndDialog( long result )
+{
+    MX_DIALOG->endDialog (result);
+}
+
+void Dialog::SetText( OUString const& str )
+{
+    SetTitle (str);
+}
+
+void Dialog::SetTitle( OUString const& str )
+{
+    MX_DIALOG->setTitle (str);
+}
+
+bool Dialog::Close ()
+{
+    EndDialog (false);
+    return true;
+}
+
+long Dialog::Notify (NotifyEvent& event)
+{
+    return GetDialog ()->Notify (event);
+}
+
+void Dialog::Initialize (SfxChildWinInfo*)
+{
+}
+
+#define MESSAGE_BOX_MEMBER_INIT\
+    Dialog (parent, xml_file, id)\
+        , imageError (this, "FI_ERROR")\
+        , imageInfo (this, "FI_INFO")\
+        , imageQuery (this, "FI_QUERY")\
+        , imageWarning (this, "FI_WARNING")\
+        , messageText (this, "FT_MESSAGE")\
+        , cancelButton (this, "BTN_CANCEL")\
+        , helpButton (this, "BTN_HELP")\
+        , ignoreButton (this, "BTN_IGNORE")\
+        , noButton (this, "BTN_NO")\
+        , retryButton (this, "BTN_RETRY")\
+        , yesButton (this, "BTN_YES")
+
+MessageBox::MessageBox (::Window *parent, char const* message,
+                        char const* yes, char const* no, sal_uIntPtr help_id,
+                        char const* xml_file, char const* id)
+    : MESSAGE_BOX_MEMBER_INIT
+{
+    ignoreButton.Hide ();
+    retryButton.Hide ();
+    init (message, yes, no, help_id);
+}
+
+MessageBox::MessageBox (::Window *parent, OUString const& message,
+                        OUString yes, OUString no, sal_uIntPtr help_id,
+                        char const* xml_file, char const* id)
+    : MESSAGE_BOX_MEMBER_INIT
+{
+    ignoreButton.Hide ();
+    retryButton.Hide ();
+    init (message, yes, no, help_id);
+}
+
+#if !defined (__GNUC__)
+#define __PRETTY_FUNCTION__ __FUNCTION__
+#endif /* !__GNUC__ */
+
+MessageBox::MessageBox (::Window *parent, WinBits bits, char const* message,
+                        char const* yes, char const* no, sal_uIntPtr help_id,
+                        char const* xml_file, char const* id)
+    : MESSAGE_BOX_MEMBER_INIT
+{
+    // HIG suggests using verbs instead of yes/no/retry etc.
+    // This constructor provides client-code compatibility: Client code should be fixed.
+    OSL_TRACE ("%s: warning, deprecated vcl/Messbox compatibility", __PRETTY_FUNCTION__);
+    bits_init (bits, OUString::createFromAscii (message), OUString::createFromAscii (yes), OUString::createFromAscii (no), help_id);
+}
+
+MessageBox::MessageBox (::Window *parent, WinBits bits, OUString const& message,
+                        OUString yes, OUString no, sal_uIntPtr help_id,
+                        char const* xml_file, char const* id)
+    : MESSAGE_BOX_MEMBER_INIT
+{
+    // HIG suggests using verbs instead of yes/no/retry etc.
+    // This constructor provides client-code compatibility: Client code should be fixed.
+    OSL_TRACE ("%s: warning, deprecated vcl/Messbox compatibility", __PRETTY_FUNCTION__);
+    bits_init (bits, message, yes, no, help_id);
+}
+
+void MessageBox::bits_init (WinBits bits, OUString const& message,
+                            OUString yes, OUString no, sal_uIntPtr help_id)
+{
+	if ( bits & ( WB_OK_CANCEL | WB_OK ))
+        yes = Button::GetStandardText ( BUTTON_OK );
+	if ( bits & (WB_YES_NO | WB_YES_NO_CANCEL ))
+	{
+        yes = Button::GetStandardText ( BUTTON_YES );
+        no =  Button::GetStandardText ( BUTTON_NO );
+	}
+    if (! (bits & (WB_RETRY_CANCEL | WB_YES_NO_CANCEL | WB_ABORT_RETRY_IGNORE )))
+        cancelButton.Hide ();
+    if (! (bits & (WB_RETRY_CANCEL | WB_ABORT_RETRY_IGNORE)))
+        retryButton.Hide ();
+    if ( bits & WB_ABORT_RETRY_IGNORE )
+        cancelButton.SetText ( Button::GetStandardText (BUTTON_ABORT));
+    else
+        ignoreButton.Hide ();
+	if ( !(bits & ( WB_OK | WB_OK_CANCEL | WB_YES_NO | WB_YES_NO_CANCEL)))
+        yesButton.Hide ();
+	if ( !(bits & ( WB_YES_NO | WB_YES_NO_CANCEL)))
+        noButton.Hide ();
+
+    init (message, yes, no, help_id);
+}
+
+void MessageBox::init (char const* message, char const* yes, char const* no, sal_uIntPtr help_id)
+{
+    init ( OUString::createFromAscii (message), OUString::createFromAscii (yes), OUString::createFromAscii (no), help_id);
+}
+
+void MessageBox::init (OUString const& message, OUString const& yes, OUString const& no, sal_uIntPtr help_id)
+{
+    imageError.Hide ();
+    imageInfo.Hide ();
+    imageQuery.Hide ();
+    imageWarning.Hide ();
+    if (message.getLength ())
+        messageText.SetText (message);
+    if (yes.getLength ())
+    {
+        yesButton.SetText (yes);
+        if (yes != OUString (Button::GetStandardText (BUTTON_OK))
+            && yes != OUString (Button::GetStandardText (BUTTON_YES)))
+            SetTitle (yes);
+        if (no.getLength ())
+            noButton.SetText (no);
+        else
+            noButton.Hide ();
+    }
+    if (help_id)
+        SetHelpId (help_id);
+    else
+        helpButton.Hide ();
+}
+
+#undef MESSAGE_BOX_IMPL
+#define MESSAGE_BOX_IMPL(Name)\
+    Name##Box::Name##Box (::Window *parent, char const* message,\
+                          char const* yes, char const* no, sal_uIntPtr help_id,\
+                          char const* xml_file, char const* id)\
+    : MessageBox (parent, message, yes, no, help_id, xml_file, id)\
+    {\
+        image##Name.Show ();\
+    }\
+    Name##Box::Name##Box (::Window *parent, OUString const& message,\
+                          OUString yes, OUString no, sal_uIntPtr help_id,\
+                          char const* xml_file, char const* id)\
+    : MessageBox (parent, message, yes, no, help_id, xml_file, id)\
+    {\
+        image##Name.Show ();\
+    }\
+    Name##Box::Name##Box (::Window *parent, WinBits bits, char const* message,\
+                          char const* yes, char const* no, sal_uIntPtr help_id,\
+                          char const* xml_file, char const* id)\
+    : MessageBox (parent, bits, message, yes, no, help_id, xml_file, id)\
+    {\
+        image##Name.Show ();\
+    }\
+    Name##Box::Name##Box (::Window *parent, WinBits bits, OUString const& message,\
+                          OUString yes, OUString no, sal_uIntPtr help_id,\
+                          char const* xml_file, char const* id)\
+    : MessageBox (parent, bits, message, yes, no, help_id, xml_file, id)\
+    {\
+        image##Name.Show ();\
+    }
+
+MESSAGE_BOX_IMPL (Error);
+MESSAGE_BOX_IMPL (Info);
+MESSAGE_BOX_IMPL (Query);
+MESSAGE_BOX_IMPL (Warning);
+
+class TabControlImpl
+    : public ControlImpl
+    , public ::cppu::WeakImplHelper1 <awt::XTabListener>
+{
+    Link mActivatePageHdl;
+    Link mDeactivatePageHdl;
+
+public:
+    uno::Reference <awt::XSimpleTabController> mxTabControl;
+    TabControlImpl (Context *context, const PeerHandle &peer, Window *window)
+        : ControlImpl (context, peer, window)
+        ,  mxTabControl (peer, uno::UNO_QUERY)
+    {
+    }
+
+    virtual void SAL_CALL disposing (lang::EventObject const& e)
+        throw (uno::RuntimeException)
+    {
+        ControlImpl::disposing (e);
+        mxTabControl.clear ();
+    }
+
+    Link& GetActivatePageHdl ()
+    {
+        return mActivatePageHdl;
+    }
+
+    void SetActivatePageHdl (Link const& link)
+    {
+        if (!mDeactivatePageHdl || !link)
+            UpdateListening (link);
+        mActivatePageHdl = link;
+    }
+
+    Link& GetDeactivatePageHdl ()
+    {
+        return mDeactivatePageHdl;
+    }
+
+    void SetDeactivatePageHdl (Link const& link)
+    {
+        if (!mActivatePageHdl || !link)
+            UpdateListening (link);
+        mDeactivatePageHdl = link;
+    }
+
+    void UpdateListening (Link const& link)
+    {
+        if (!link && (!!mActivatePageHdl || !!mDeactivatePageHdl))
+            mxTabControl->removeTabListener (this);
+        else if (!!link && !mActivatePageHdl && !mDeactivatePageHdl)
+            mxTabControl->addTabListener (this);
+    }
+
+    void SAL_CALL activated (sal_Int32)
+        throw (uno::RuntimeException)
+    {
+        mActivatePageHdl.Call (mpWindow);
+    }
+
+    void SAL_CALL deactivated (sal_Int32)
+        throw (uno::RuntimeException)
+    {
+        mDeactivatePageHdl.Call (mpWindow);
+    }
+
+    void SAL_CALL inserted (sal_Int32)
+        throw (uno::RuntimeException)
+    {
+    }
+
+    void SAL_CALL removed (sal_Int32)
+        throw (uno::RuntimeException)
+    {
+    }
+
+    void SAL_CALL changed (sal_Int32, uno::Sequence <beans::NamedValue> const&)
+        throw (uno::RuntimeException)
+    {
+    }
+};
+
+IMPL_GET_WINDOW (TabControl);
+IMPL_GET_LAYOUT_VCLXWINDOW (TabControl);
+
+#define MX_TABCONTROL if (getImpl ().mxTabControl.is ()) getImpl ().mxTabControl
+#define RETURN_MX_TABCONTROL if (getImpl ().mxTabControl.is ()) return getImpl ().mxTabControl
+
+TabControl::~TabControl ()
+{
+    SetActivatePageHdl (Link ());
+    SetDeactivatePageHdl (Link ());
+}
+
+void TabControl::InsertPage (sal_uInt16 id, OUString const& title, sal_uInt16 pos)
+{
+    (void) pos;
+//    GetTabControl ()->InsertPage (id, title, pos);
+//    GetTabControl ()->SetTabPage (id, new ::TabPage (GetTabControl ()));
+
+    MX_TABCONTROL->insertTab ();
+    SetCurPageId (id);
+
+#if 1 // colour me loc productive -- NOT
+#define ADD_PROP( seq, i, name, val )\
+    { \
+        beans::NamedValue value; \
+        value.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( name ) ); \
+        value.Value = uno::makeAny( val ); \
+        seq[i] = value; \
+    }
+
+    uno::Sequence< beans::NamedValue > seq (1);
+    ADD_PROP ( seq, 0, "Title", OUString (title) );
+    MX_TABCONTROL->setTabProps (id, seq);
+#else
+    GetTabPage (id)->SetText (title);
+#endif
+
+#if 0
+    /// This so seems the right solution, but it makes the buttons of the
+    /// tabdialog move up
+    
+    ::TabPage *page = GetTabPage (id);
+    if (Window *w = dynamic_cast <Window*> (page))
+    {
+        w->SetParent (this);
+        //GetVCLXTabControl ()->Box_Base::addChild (uno::Reference <awt::XLayoutConstrains> (w->GetPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->Box_Base::AddChild (uno::Reference <awt::XLayoutConstrains> (w->GetPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->AddChild (w);
+        //GetVCLXTabControl ()->AddChild (uno::Reference <awt::XLayoutConstrains> (w->GetPeer (), uno::UNO_QUERY));
+        //uno::Reference <uno::XInterface> x (page->GetWindowPeer());
+        //GetVCLXTabControl ()->AddChild (uno::Reference <awt::XLayoutConstrains> (page->::Window::GetWindowPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->AddChild (uno::Reference <awt::XLayoutConstrains> (page->GetComponentInterface (), uno::UNO_QUERY));
+    }
+    getImpl ().redraw ();
+#endif
+}
+void TabControl::RemovePage (sal_uInt16 id)
+{
+    GetTabControl ()->RemovePage (id);
+}
+sal_uInt16 TabControl::GetPageCount () const
+{
+    return GetTabControl ()->GetPageCount ();
+}
+sal_uInt16 TabControl::GetPageId (sal_uInt16 pos) const
+{
+    return GetTabControl ()->GetPageId (pos);
+}
+sal_uInt16 TabControl::GetPagePos (sal_uInt16 id) const
+{
+    getImpl ().redraw ();
+    return GetTabControl ()->GetPagePos (id);
+}
+void TabControl::SetCurPageId (sal_uInt16 id)
+{
+    getImpl ().redraw ();
+    GetTabControl ()->SetCurPageId (id);
+}
+sal_uInt16 TabControl::GetCurPageId () const
+{
+    return GetTabControl ()->GetCurPageId ();
+}
+void TabControl::SetTabPage (sal_uInt16 id, ::TabPage* page)
+{
+    GetTabControl ()->SetTabPage (id, page);
+
+#if 0
+    /// This so seems the right solution, but it makes the buttons of the
+    /// tabdialog move up
+    if (Window *w = dynamic_cast <Window*> (page))
+    {
+        w->SetParent (this);
+        //GetVCLXTabControl ()->Box_Base::addChild (uno::Reference <awt::XLayoutConstrains> (w->GetPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->Box_Base::AddChild (uno::Reference <awt::XLayoutConstrains> (w->GetPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->AddChild (w);
+        //GetVCLXTabControl ()->AddChild (uno::Reference <awt::XLayoutConstrains> (w->GetPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->AddChild (uno::Reference <awt::XLayoutConstrains> (page->GetWindowPeer (), uno::UNO_QUERY));
+        //GetVCLXTabControl ()->AddChild (uno::Reference <awt::XLayoutConstrains> (page->GetComponentInterface (), uno::UNO_QUERY));
+    }
+#endif
+    getImpl ().redraw ();
+}
+::TabPage* TabControl::GetTabPage (sal_uInt16 id) const
+{
+    return GetTabControl ()->GetTabPage (id);
+}
+void TabControl::SetActivatePageHdl (Link const& link)
+{
+    if (&getImpl () && getImpl().mxTabControl.is ())
+        getImpl ().SetActivatePageHdl (link);
+}
+Link& TabControl::GetActivatePageHdl () const
+{
+    return getImpl ().GetActivatePageHdl ();
+}
+void TabControl::SetDeactivatePageHdl (Link const& link)
+{
+    if (&getImpl () && getImpl().mxTabControl.is ())
+        getImpl ().SetDeactivatePageHdl (link);
+}
+Link& TabControl::GetDeactivatePageHdl () const
+{
+    return getImpl ().GetDeactivatePageHdl ();
+}
+void TabControl::SetTabPageSizePixel (Size const& size)
+{
+    GetTabControl ()->SetTabPageSizePixel (size);
+//    GetParent()->SetSizePixel (size);
+//    GetWindow()->SetSizePixel (size);
+    //GetVCLXTabControl->SetTabSize (size);
+}
+Size TabControl::GetTabPageSizePixel () const
+{
+#if 0
+    //return GetTabControl ()->GetTabPageSizePixel ();
+    static size_t const tab_page_first_index = 1;
+    for (size_t i = 0; i < GetPageCount (); i++)
+    {
+        ::TabPage *p = GetTabPage (i + tab_page_first_index);
+        //if (dynamic_cast<Windowt*> (p))
+        if (i) // URG
+            return p->GetOptimalSize (WINDOWSIZE_MINIMUM);
+    }
+#endif
+    return GetTabControl ()->GetTabPageSizePixel ();
+}
+
+IMPL_CONSTRUCTORS (TabControl, Control, "tabcontrol");
+IMPL_GET_IMPL (TabControl);
+
+class TabPageImpl : public WindowImpl
+{
+public:
+    uno::Reference< awt::XWindow > mxTabPage;
+    TabPageImpl( Context *context, const PeerHandle &peer, Window *window )
+        : WindowImpl( context, peer, window )
+        , mxTabPage( peer, uno::UNO_QUERY )
+    {
+    }
+};
+
+::Window* TabPage::global_parent = 0;
+TabControl* TabPage::global_tabcontrol = 0;
+
+IMPL_GET_IMPL( TabPage );
+
+TabPage::TabPage( Window *parent, const char *xml_file, const char *id, sal_uInt32 nId)
+    : Context( xml_file )
+    , Window( new TabPageImpl( this, Context::GetPeerHandle( id, nId ), this ) )
+{
+    if ( parent )
+        SetParent( parent );
+}
+
+TabPage::TabPage( ::Window *parent, const char *xml_file, const char *id, sal_uInt32 nId)
+    : Context( xml_file )
+    , Window( new TabPageImpl( this, Context::GetPeerHandle( id, nId ), this ) )
+{
+    if ( parent )
+        SetParent( parent );
+}
+
+TabPage::~TabPage()
+{
+    delete GetTabPage();
+}
+
+IMPL_GET_WINDOW( TabPage );
+
+void TabPage::ActivatePage()
+{
+}
+
+void TabPage::DeactivatePage()
+{
+}
+
+class FixedLineImpl : public ControlImpl
+{
+public:
+    FixedLineImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ControlImpl( context, peer, window )
+    {
+    }
+};
+
+IMPL_CONSTRUCTORS( FixedLine, Control, "hfixedline" );
+IMPL_GET_IMPL( FixedLine );
+
+bool FixedLine::IsEnabled()
+{
+    //FIXME
+    return true;
+}
+
+class FixedTextImpl : public ControlImpl
+{
+public:
+    uno::Reference< awt::XFixedText > mxFixedText;
+    FixedTextImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ControlImpl( context, peer, window )
+        , mxFixedText( peer, uno::UNO_QUERY )
+    {
+    }
+
+    ~FixedTextImpl ();
+
+    virtual void SAL_CALL disposing( lang::EventObject const& e )
+        throw (uno::RuntimeException);
+};
+
+FixedTextImpl::~FixedTextImpl ()
+{
+}
+
+void SAL_CALL FixedTextImpl::disposing( lang::EventObject const& e )
+    throw (uno::RuntimeException)
+{
+    ControlImpl::disposing (e);
+    mxFixedText.clear ();
+}
+
+FixedText::~FixedText ()
+{
+}
+
+IMPL_CONSTRUCTORS( FixedText, Control, "fixedtext" );
+IMPL_GET_IMPL( FixedText );
+
+void FixedText::SetText( OUString const& rStr )
+{
+    if ( !getImpl().mxFixedText.is() )
+        return;
+    getImpl().mxFixedText->setText( rStr );
+}
+
+class FixedInfoImpl : public FixedTextImpl
+{
+public:
+    FixedInfoImpl( Context *context, const PeerHandle &peer, Window *window )
+        : FixedTextImpl( context, peer, window )
+    {
+    }
+};
+
+IMPL_CONSTRUCTORS( FixedInfo, FixedText, "fixedinfo" );
+IMPL_GET_IMPL( FixedInfo );
+
+class ProgressBarImpl : public ControlImpl
+{
+public:
+    uno::Reference< awt::XProgressBar > mxProgressBar;
+    ProgressBarImpl( Context *context, const PeerHandle &peer, Window *window )
+        : ControlImpl( context, peer, window )
+        , mxProgressBar( peer, uno::UNO_QUERY )
+    {
+    }
+
+    virtual void SAL_CALL disposing( lang::EventObject const& e )
+        throw (uno::RuntimeException)
+    {
+        ControlImpl::disposing (e);
+        mxProgressBar.clear ();
+    }
+};
+
+
+class FixedImageImpl: public ControlImpl
+{
+public:
+    uno::Reference< graphic::XGraphic > mxGraphic;
+    FixedImageImpl( Context *context, const PeerHandle &peer, Window *window)
+//                    const char *pName )
+        : ControlImpl( context, peer, window )
+          //, mxGraphic( layoutimpl::loadGraphic( pName ) )
+        , mxGraphic( peer, uno::UNO_QUERY )
+    {
+        if ( !mxGraphic.is() )
+        {
+            DBG_ERROR( "ERROR: failed to load image: `%s'" /*, pName*/ );
+        }
+#if 0
+        else
+            getImpl().mxGraphic->...();
+#endif
+    }
+};
+
+IMPL_CONSTRUCTORS( FixedImage, Control, "fixedimage" );
+IMPL_GET_IMPL( FixedImage )
+
+void FixedImage::setImage( ::Image const& i )
+{
+    (void) i;
+    if ( !getImpl().mxGraphic.is() )
+        return;
+    //FIXME: hack moved to proplist
+    //getImpl().mxGraphic =
+}
+
+#if 0
+
+FixedImage::FixedImage( const char *pName )
+    : pImpl( new FixedImageImpl( pName ) )
+{
+}
+
+FixedImage::~FixedImage()
+{
+    delete pImpl;
+}
+
+#endif
+
+
+IMPL_CONSTRUCTORS( ProgressBar, Control, "ProgressBar" );
+IMPL_GET_IMPL( ProgressBar );
+
+void ProgressBar::SetForegroundColor( util::Color color )
+{
+    if ( !getImpl().mxProgressBar.is() )
+        return;
+    getImpl().mxProgressBar->setForegroundColor( color );
+}
+
+void ProgressBar::SetBackgroundColor( util::Color color )
+{
+    if ( !getImpl().mxProgressBar.is() )
+        return;
+    getImpl().mxProgressBar->setBackgroundColor( color );
+}
+
+void ProgressBar::SetValue( sal_Int32 i )
+{
+    if ( !getImpl().mxProgressBar.is() )
+        return;
+    getImpl().mxProgressBar->setValue( i );
+}
+
+void ProgressBar::SetRange( sal_Int32 min, sal_Int32 max )
+{
+    if ( !getImpl().mxProgressBar.is() )
+        return;
+    getImpl().mxProgressBar->setRange( min, max );
+}
+
+sal_Int32 ProgressBar::GetValue()
+{
+    if ( !getImpl().mxProgressBar.is() )
+        return 0;
+    return getImpl().mxProgressBar->getValue();
+}
+
+class PluginImpl: public ControlImpl
+{
+public:
+    ::Control *mpPlugin;
+
+    PluginImpl( Context *context, const PeerHandle &peer, Window *window, :: Control *plugin )
+        : ControlImpl( context, peer, window )
+        , mpPlugin( plugin )
+    {
+        uno::Reference <awt::XWindow> ref( mxWindow, uno::UNO_QUERY );
+        layoutimpl::VCLXPlugin *vcl
+            = static_cast<layoutimpl::VCLXPlugin*>( VCLXWindow::GetImplementation( ref ) );
+        ::Window *parent = vcl->mpWindow->GetParent();
+        vcl->SetWindow( plugin );
+        vcl->SetPlugin( mpPlugin );
+        plugin->SetParent( parent );
+        plugin->SetStyle( vcl->mStyle );
+        plugin->SetCreatedWithToolkit( true );
+        plugin->SetComponentInterface( vcl );
+        plugin->Show();
+    }
+};
+
+Plugin::Plugin( Context *context, char const *id, ::Control *plugin )
+    : Control( new PluginImpl( context, context->GetPeerHandle( id, 0 ), this, plugin ) )
+    , mpPlugin( plugin )
+{
+}
+
+IMPL_GET_IMPL( Plugin );
+
+class LocalizedStringImpl : public WindowImpl
+{
+public:
+    layoutimpl::LocalizedString *mpString;
+    LocalizedStringImpl( Context *context, const PeerHandle &peer, Window *window )
+        : WindowImpl( context, peer, window )
+        , mpString( static_cast<layoutimpl::LocalizedString*>( VCLXWindow::GetImplementation( uno::Reference <awt::XWindow> ( mxWindow, uno::UNO_QUERY ) ) ) )
+    {
+    }
+    OUString getText()
+    {
+        if ( mpString )
+            return mpString->getText();
+        return OUString();
+    }
+    void setText( OUString const& s )
+    {
+        if ( mpString )
+            mpString->setText( s );
+    }
+};
+
+IMPL_GET_IMPL( LocalizedString );
+
+LocalizedString::LocalizedString( Context *context, char const* id )
+    : Window( new LocalizedStringImpl( context, context->GetPeerHandle( id, 0 ), this ) )
+{
+}
+
+String LocalizedString::getString ()
+{
+    return getImpl ().getText ();
+}
+
+OUString LocalizedString::getOUString ()
+{
+    return getImpl ().getText ();
+}
+
+LocalizedString::operator OUString ()
+{
+    return getOUString ();
+}
+
+OUString LocalizedString::GetToken (sal_uInt32 i, sal_Char c)
+{
+    return getString ().GetToken (i, c);
+}
+
+OUString LocalizedString::operator= (OUString const& s)
+{
+    getImpl().setText( s );
+    return getImpl().getText();
+}
+
+OUString LocalizedString::operator+= (OUString const& b)
+{
+    OUString a = getImpl ().getText ();
+    a += b;
+    getImpl ().setText (a);
+    return getImpl ().getText ();
+}
+
+OUString LocalizedString::operator+= (sal_Unicode const b)
+{
+    String a = getImpl ().getText ();
+    a += b;
+    getImpl ().setText (a);
+    return getImpl ().getText ();
+}
+
+class InPlugImpl : public WindowImpl
+{
+public:
+    InPlugImpl (Context *context, const PeerHandle &peer, Window *window)
+        : WindowImpl (context, peer, window)
+    {
+    }
+};
+
+IMPL_GET_IMPL (InPlug);
+
+static char const *FIXME_set_parent (::Window *parent, char const *xml_file)
+{
+    layout::TabPage::global_parent = parent;
+    return xml_file;
+}
+
+InPlug::InPlug (Window *parent, char const* xml_file, char const* id, sal_uInt32 nId)
+    : Context (FIXME_set_parent (parent ? parent->GetWindow () : 0, xml_file))
+    , layout::Window (new InPlugImpl (this, Context::GetPeerHandle (id, nId), this))
+{
+    if (parent)
+        SetParent (parent);
+    if (::Window *w = dynamic_cast< ::Window* > (this))
+        w->SetComponentInterface (GetVCLXWindow ());
+}
+
+InPlug::InPlug (::Window *parent, char const* xml_file, char const* id, sal_uInt32 nId)
+    : Context (FIXME_set_parent (parent, xml_file))
+    , layout::Window (new InPlugImpl (this, Context::GetPeerHandle (id, nId), this))
+{
+    if (parent)
+        layout::Window::SetParent (parent);
+    if (::Window *w = dynamic_cast< ::Window* > (this))
+        w->SetComponentInterface (GetVCLXWindow ());
+}
+
+void InPlug::ParentSet (Window *window)
+{
+    window->SetParent (dynamic_cast< ::Window* > (this));
+
+    /// FIXME: for standalone run of layout::SfxTabDialog
+    SetParent (window->GetParent ());
+}
+
+} // namespace layout
diff --git a/toolkit/source/layout/vcl/wrapper.hxx b/toolkit/source/layout/vcl/wrapper.hxx
new file mode 100644
index 0000000..dcf8fdb
--- /dev/null
+++ toolkit/source/layout/vcl/wrapper.hxx
@@ -0,0 +1,142 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef LAYOUT_VCL_WRAPPER_HXX
+#define LAYOUT_VCL_WRAPPER_HXX
+
+#include <layout/layout.hxx>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/awt/XDialog2.hpp>
+#include <com/sun/star/awt/XFocusListener.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <cppuhelper/implbase1.hxx>
+
+#include <cstring>
+
+namespace layout
+{
+
+namespace css = com::sun::star;
+
+class WindowImpl
+{
+public:
+    Window *mpWindow;
+    Context *mpCtx;
+    css::uno::Reference< css::awt::XWindow > mxWindow;
+    css::uno::Reference< css::awt::XVclWindowPeer > mxVclPeer;
+    ::Window *mvclWindow;
+    bool bFirstTimeVisible;
+
+    WindowImpl (Context *context, PeerHandle const &peer, Window *window);
+    virtual ~WindowImpl ();
+
+    void wrapperGone();
+    css::uno::Any getProperty (char const *name);
+    void setProperty (char const *name, css::uno::Any any);
+    void redraw (bool resize=false);
+
+    // XFocusListener
+    virtual void SAL_CALL disposing (css::lang::EventObject const&) throw (css::uno::RuntimeException);
+};
+
+class ControlImpl : public WindowImpl
+                  , public ::cppu::WeakImplHelper1 <css::awt::XFocusListener>
+{
+public:
+    Link mGetFocusHdl;
+    Link mLoseFocusHdl;
+
+    ControlImpl( Context *context, PeerHandle const& peer, Window *window );
+    ~ControlImpl ();
+
+    virtual void SetGetFocusHdl (Link const& link);
+    Link& GetGetFocusHdl ();
+    virtual void SetLoseFocusHdl (Link const& link);
+    Link& GetLoseFocusHdl ();
+    virtual void UpdateListening (Link const& link);
+
+    // XFocusListener
+    virtual void SAL_CALL disposing (css::lang::EventObject const&) throw (css::uno::RuntimeException);
+    void SAL_CALL focusGained (css::awt::FocusEvent const& e) throw (css::uno::RuntimeException);
+    void SAL_CALL focusLost (css::awt::FocusEvent const& e) throw (css::uno::RuntimeException);
+};
+
+inline WindowImpl &Window::getImpl() const{ return *(static_cast< WindowImpl * >( mpImpl )); }
+
+// Helpers for defining boiler-plate constructors ...
+// Could in-line in top-level but not with safe static_casts.
+#define IMPL_GET_IMPL(t) \
+    inline t##Impl &t::getImpl() const \
+    { \
+        return *(static_cast<t##Impl *>(mpImpl)); \
+    }
+#define IMPL_CONSTRUCTORS_BODY(t,par,unoName,body) \
+    t::t( Context *context, const char *pId, sal_uInt32 nId ) \
+        : par( new t##Impl( context, context->GetPeerHandle( pId, nId ), this ) ) \
+    { \
+        Window *parent = dynamic_cast<Window*> (context);\
+        body;\
+        if (parent)\
+            SetParent (parent);\
+    } \
+    t::t( Window *parent, WinBits bits) \
+        : par( new t##Impl( parent->getContext(), Window::CreatePeer( parent, bits, unoName ), this ) ) \
+    { \
+        body;\
+        if ( parent )\
+            SetParent (parent);\
+    } \
+    t::t( Window *parent, ResId const& res) \
+        : par( new t##Impl( parent->getContext(), Window::CreatePeer( parent, 0, unoName ), this ) ) \
+    { \
+        body;\
+        setRes (res);\
+        if (parent)\
+            SetParent (parent);\
+    }
+#define IMPL_CONSTRUCTORS(t,par,unoName) IMPL_CONSTRUCTORS_BODY(t, par, unoName, )
+#define IMPL_CONSTRUCTORS_2(t,win_par,other_par,unoName) \
+    t::t( Context *context, const char *pId, sal_uInt32 nId ) \
+        : win_par( new t##Impl( context, context->GetPeerHandle( pId, nId ), this ) ) \
+        , other_par( new other_par##Impl( Window::GetPeer() ) ) \
+    { \
+    } \
+    t::t( Window *parent, WinBits bits) \
+        : win_par( new t##Impl( parent->getContext(), Window::CreatePeer( parent, bits, unoName ), this ) ) \
+        , other_par( new other_par##Impl( Window::GetPeer() ) ) \
+    { \
+    }
+
+} // namespace layout
+
+#endif /* LAYOUT_VCL_WRAPPER_HXX */
diff --git a/toolkit/source/vclcompat/makefile.mk b/toolkit/source/vclcompat/makefile.mk
deleted file mode 100644
index 26b414e..0000000
--- toolkit/source/vclcompat/makefile.mk
+++ /dev/null
@@ -1,55 +0,0 @@
-#*************************************************************************
-#
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-# 
-# Copyright 2008 by Sun Microsystems, Inc.
-#
-# OpenOffice.org - a multi-platform office productivity suite
-#
-# $RCSfile$
-#
-# $Revision$
-#
-# This file is part of OpenOffice.org.
-#
-# OpenOffice.org is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser General Public License version 3
-# only, as published by the Free Software Foundation.
-#
-# OpenOffice.org is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser General Public License version 3 for more details
-# (a copy is included in the LICENSE file that accompanied this code).
-#
-# You should have received a copy of the GNU Lesser General Public License
-# version 3 along with OpenOffice.org.  If not, see
-# <http://www.openoffice.org/license.html>
-# for a copy of the LGPLv3 License.
-#
-#*************************************************************************
-
-PRJ=..$/..
-PRJNAME=toolkit
-TARGET=vclcompat
-ENABLE_EXCEPTIONS=true
-
-# --- Settings -----------------------------------------------------
-
-.INCLUDE : settings.mk
-.INCLUDE : $(PRJ)$/util$/makefile.pmk
-
-# --- Files --------------------------------------------------------
-
-# FIXME: This is bad, hmkay
-CFLAGS+= -I$(PRJ)/source
-
-SLOFILES= \
-	$(SLO)$/wrapper.obj \
-	$(SLO)$/wbutton.obj \
-	$(SLO)$/wcontainer.obj \
-	$(SLO)$/wfield.obj
-
-# --- Targets ------------------------------------------------------
-
-.INCLUDE : target.mk
diff --git a/toolkit/source/vclcompat/wbutton.cxx b/toolkit/source/vclcompat/wbutton.cxx
deleted file mode 100644
index 5617f4f..0000000
--- toolkit/source/vclcompat/wbutton.cxx
+++ /dev/null
@@ -1,582 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "wrapper.hxx"
-
-#include <com/sun/star/awt/PosSize.hpp>
-#include <com/sun/star/awt/XActionListener.hpp>
-#include <com/sun/star/awt/XButton.hpp>
-#include <com/sun/star/awt/XCheckBox.hpp>
-#include <com/sun/star/awt/XRadioButton.hpp>
-#include <com/sun/star/graphic/XGraphic.hpp>
-#include <cppuhelper/implbase1.hxx>
-#include <toolkit/awt/vclxwindow.hxx>
-#include <toolkit/helper/convert.hxx>
-#include <vcl/button.hxx>
-#include <vcl/event.hxx>
-#include <vcl/msgbox.hxx>
-#include <vcl/svapp.hxx>
-#include <vcl/window.hxx>
-
-#include <list>
-
-#include "layout/layoutcore.hxx"
-
-using namespace ::com::sun::star;
-
-namespace layout
-{
-
-class ImageImpl
-{
-  public:
-    css::uno::Reference< css::graphic::XGraphic > mxGraphic;
-    ImageImpl( const char *pName )
-        : mxGraphic( layoutimpl::loadGraphic( pName ) )
-    {
-        if ( !mxGraphic.is() )
-        {
-            DBG_ERROR1( "ERROR: failed to load image: `%s'\n", pName );
-        }
-    }
-};
-
-Image::Image( const char *pName )
-    : pImpl( new ImageImpl( pName ) )
-{
-}
-
-Image::~Image()
-{
-    delete pImpl;
-}
-
-class ButtonImpl : public ControlImpl
-                 , public ::cppu::WeakImplHelper1< awt::XActionListener >
-                 , public ::cppu::WeakImplHelper1< awt::XItemListener >
-{
-    Link maClickHdl;
-  protected:
-    // we add toggle hooks here to cut on code
-    Link maToggleHdl;
-  public:
-    uno::Reference< awt::XButton > mxButton;
-    ButtonImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ControlImpl( pCtx, xPeer, pWindow )
-        , mxButton( xPeer, uno::UNO_QUERY )
-    {
-        mxButton->addActionListener( this );
-    }
-
-    ~ButtonImpl()
-    {
-    }
-
-    virtual void Click() { /* make me pure virtual? */ };
-
-    void SetClickHdl( const Link& rLink )
-    {
-        maClickHdl = rLink;
-        if ( !rLink )
-            mxButton->removeActionListener( this );
-        else
-            mxButton->addActionListener( this );
-    }
-
-    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
-        throw (css::uno::RuntimeException)
-    { mxButton.clear(); }
-
-    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        if ( !maClickHdl )
-            Click();
-        else
-            maClickHdl.Call( static_cast<Window *>( mpWindow ) );
-    }
-
-    virtual  // HACK: doesn't need to be virtual... remove in future...
-    void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        maToggleHdl.Call( static_cast<Window *>( mpWindow ) );
-    }
-
-    BOOL SetModeImage( css::uno::Reference< css::graphic::XGraphic > xGraph )
-    {
-        setProperty( "Graphic", uno::Any( xGraph ) );
-        return true;
-    }
-};
-
-void Button::SetText( String const& rStr )
-{
-    if ( !getImpl().mxButton.is() )
-        return;
-    getImpl().mxButton->setLabel( rStr );
-}
-
-void Button::SetClickHdl( const Link& rLink )
-{
-    getImpl().SetClickHdl( rLink );
-}
-
-BOOL Button::SetModeImage( const Image& rImage )
-{
-    return getImpl().SetModeImage( rImage.getImpl().mxGraphic );
-}
-
-void Button::SetImageAlign( ImageAlign eAlign )
-{
-    getImpl().setProperty( "ImageAlign", uno::Any( (sal_Int16) eAlign ) );
-}
-
-void Button::Click()
-{
-}
-
-IMPL_GET_IMPL( Button );
-IMPL_CONSTRUCTORS( Button, Control, "button" );
-
-class PushButtonImpl : public ButtonImpl
-{
-  public:
-    PushButtonImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ButtonImpl( pCtx, xPeer, pWindow ) {}
-
-    void SetToggleHdl( const Link& rLink )
-    {
-        // XButton doesn't have an explicit event for Toggle. Anyway, it is a
-        // superset of the clicks: all clicks, and explicit toggles
-        maToggleHdl = rLink;
-        if ( !rLink )
-            mxButton->removeActionListener( this );
-        else
-            mxButton->addActionListener( this );
-    }
-
-    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& rEvent )
-        throw (css::uno::RuntimeException)
-    {
-        ButtonImpl::actionPerformed( rEvent );
-        fireToggle();
-    }
-
-    inline void fireToggle()
-    {
-        maToggleHdl.Call(  static_cast<Window *>( mpWindow ) );
-    }
-};
-
-void PushButton::Check( BOOL bCheck )
-{
-    getImpl().setProperty( "State", uno::Any( (sal_Int16) !!bCheck ) );
-    // XButton doesn't have explicit toggle event
-    getImpl().fireToggle();
-}
-
-BOOL PushButton::IsChecked() const
-{
-    return !!( getImpl().getProperty( "State" ).get< sal_Int16 >() );
-}
-
-void PushButton::Toggle()
-{
-    Check( true );
-}
-
-void PushButton::SetToggleHdl( const Link& rLink )
-{
-    getImpl().SetToggleHdl( rLink );
-}
-
-IMPL_GET_IMPL( PushButton );
-IMPL_CONSTRUCTORS( PushButton, Button, "pushbutton" );
-
- // HACK: put every radio button into a group :/
-static std::list< RadioButtonImpl*> mpRadioGroup;
-
-class RadioButtonImpl : public ButtonImpl
-{
-public:
-    uno::Reference< awt::XRadioButton > mxRadioButton;
-    RadioButtonImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ButtonImpl( pCtx, xPeer, pWindow )
-        , mxRadioButton( xPeer, uno::UNO_QUERY )
-    {
-        // TEMP:
-        mpRadioGroup.push_back( this );
-        mxRadioButton->addItemListener( this );
-    }
-
-    ~RadioButtonImpl()
-    {
-        //mxRadioButton->removeItemListener( this );
-        mpRadioGroup.pop_front();
-    }
-
-    void Check( BOOL bCheck )
-    {
-        if ( !mxRadioButton.is() )
-            return;
-        mxRadioButton->setState( !!bCheck );
-        fireToggle();
-
-        if ( bCheck )
-            unsetOthersGroup( this );
-    }
-
-    BOOL IsChecked()
-    {
-        if ( !mxRadioButton.is() )
-            return FALSE;
-        return mxRadioButton->getState();
-    }
-
-    static void unsetOthersGroup( RadioButtonImpl* current )
-    {
-        // set all others to false
-        for ( std::list< RadioButtonImpl*>::iterator i = mpRadioGroup.begin();
-              i != mpRadioGroup.end(); i++ )
-            {
-            if ( *i != current )
-                ( *i )->Check( false );
-        }
-    }
-
-    void SetToggleHdl( const Link& rLink )
-    {
-        maToggleHdl = rLink;
-#if 0
-        if ( !rLink )
-            mxRadioButton->removeItemListener( this );
-        else
-            mxRadioButton->addItemListener( this );
-#endif
-    }
-
-    inline void fireToggle()
-    {
-        maToggleHdl.Call(  static_cast<Window *>( mpWindow ) );
-    }
-
-//HACK: temp
-    virtual void SAL_CALL itemStateChanged( const css::awt::ItemEvent& rEvent )
-        throw (css::uno::RuntimeException)
-    {
-        if ( !!maToggleHdl )
-        ButtonImpl::itemStateChanged( rEvent );
-
-        if ( IsChecked() )
-            unsetOthersGroup( this );
-    }
-};
-
-void RadioButton::Check( BOOL bCheck )
-{
-    getImpl().Check( bCheck );
-}
-
-BOOL RadioButton::IsChecked() const
-{
-    return getImpl().IsChecked();
-}
-
-void RadioButton::SetToggleHdl( const Link& rLink )
-{
-    getImpl().SetToggleHdl( rLink );
-}
-
-IMPL_GET_IMPL( RadioButton );
-#if 1
-IMPL_CONSTRUCTORS( RadioButton, Button, "radiobutton" );
-#else //debugging aid
-RadioButton::RadioButton( Context *pCtx, const char *pId, sal_uInt32 nId )
-    : Button( new RadioButtonImpl( pCtx, pCtx->GetPeerHandle( pId, nId ), this ) )
-{
-    printf( "%s: name=%s\n", __PRETTY_FUNCTION__, pId );
-}
-
-RadioButton::RadioButton( Window *pParent, WinBits nBits )
-    : Button( new RadioButtonImpl( pParent->getContext(), Window::CreatePeer( pParent, nBits, "radiobutton" ), this ) )
-{
-}
-#endif
-
-class CheckBoxImpl : public ButtonImpl
-{
-  public:
-    uno::Reference< awt::XCheckBox > mxCheckBox;
-    CheckBoxImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ButtonImpl( pCtx, xPeer, pWindow )
-        , mxCheckBox( xPeer, uno::UNO_QUERY ) {}
-
-    void SetToggleHdl( const Link& rLink )
-    {
-        maToggleHdl = rLink;
-        if ( !rLink )
-            mxCheckBox->removeItemListener( this );
-        else
-            mxCheckBox->addItemListener( this );
-    }
-};
-
-void CheckBox::Check( BOOL bCheck )
-{
-    if ( !getImpl().mxCheckBox.is() )
-        return;
-    getImpl().mxCheckBox->setState( !!bCheck );
-}
-
-BOOL CheckBox::IsChecked() const
-{
-    if ( !getImpl().mxCheckBox.is() )
-        return FALSE;
-    return getImpl().mxCheckBox->getState() != 0;
-}
-
-void CheckBox::SetToggleHdl( const Link& rLink )
-{
-    getImpl().SetToggleHdl( rLink );
-}
-
-IMPL_GET_IMPL( CheckBox );
-IMPL_CONSTRUCTORS( CheckBox, Button, "checkbox" );
-
-#define BUTTON_IMPL(t, parent, response) \
-    class t##Impl : public parent##Impl \
-    { \
-    public: \
-        t##Impl( Context *pCtx, PeerHandle const& xPeer, Window *pWindow ) \
-            : parent##Impl( pCtx, xPeer, pWindow ) \
-        { \
-        } \
-        void Click() \
-        { \
-            Dialog *d = static_cast<Dialog *>( mpCtx ); \
-            d->EndDialog( response ); \
-        } \
-    }
-
-/* Common button types currently unavailable in OOo: */
-/* mpReset */
-/* mpApply */
-/* mpAction */
-#define RET_RESET 6
-#define RET_APPLY 7
-#define BUTTONID_RESET RET_RESET
-#define BUTTONID_APPLY RET_APPLY
-
-BUTTON_IMPL( OKButton, PushButton, BUTTONID_OK );
-BUTTON_IMPL( CancelButton, PushButton, BUTTONID_CANCEL );
-BUTTON_IMPL( YesButton, PushButton, BUTTONID_YES );
-BUTTON_IMPL( NoButton, PushButton, BUTTONID_NO );
-BUTTON_IMPL( RetryButton, PushButton, BUTTONID_RETRY );
-BUTTON_IMPL( IgnoreButton, PushButton, BUTTONID_IGNORE );
-BUTTON_IMPL( ResetButton, PushButton, BUTTONID_RESET );
-BUTTON_IMPL( ApplyButton, PushButton, BUTTONID_APPLY ); /* Deprecated? */
-BUTTON_IMPL( HelpButton, PushButton, BUTTONID_HELP );
-
-IMPL_CONSTRUCTORS( OKButton, PushButton, "okbutton" );
-IMPL_CONSTRUCTORS( CancelButton, PushButton, "cancelbutton" );
-IMPL_CONSTRUCTORS( YesButton, PushButton, "yesbutton" );
-IMPL_CONSTRUCTORS( NoButton, PushButton, "nobutton" );
-IMPL_CONSTRUCTORS( RetryButton, PushButton, "retrybutton" );
-IMPL_CONSTRUCTORS( IgnoreButton, PushButton, "ignorebutton" );
-IMPL_CONSTRUCTORS( ResetButton, PushButton, "resetbutton" );
-IMPL_CONSTRUCTORS( ApplyButton, PushButton, "applybutton" );  /* Deprecated? */
-IMPL_CONSTRUCTORS( HelpButton, PushButton, "helpbutton" );
-
-class AdvancedButtonImpl : public PushButtonImpl
-{
-protected:
-    bool bAdvancedMode;
-    std::list< Window*> maAdvanced;
-    std::list< Window*> maSimple;
-    rtl::OUString mSimpleLabel;
-    rtl::OUString mAdvancedLabel;
-
-    Window* Remove( std::list< Window*> lst, Window* w )
-{
-        for ( std::list< Window*>::iterator it = maAdvanced.begin();
-              it != maAdvanced.end(); it++ )
-            if ( *it == w )
-    {
-                lst.erase( it );
-                return *it;
-            }
-        return 0;
-    }
-    void redraw()
-    {
-        uno::Reference <awt::XWindow> ref( mxWindow, uno::UNO_QUERY );
-        ::Window* window = VCLXWindow::GetImplementation( ref )->GetWindow();
-        ::Window* parent = window->GetParent();
-
-        ::Rectangle r = Rectangle( parent->GetPosPixel(),
-                                   parent->GetSizePixel() );
-
-        parent->Invalidate( r, INVALIDATE_CHILDREN | INVALIDATE_NOCHILDREN );
-        parent->SetPosSizePixel( 0, 0, r.nRight - r.nLeft, r.nBottom - r.nTop,
-                                 awt::PosSize::SIZE );
-    }
-
-public:
-    AdvancedButtonImpl( Context *pCtx, PeerHandle const& xPeer, Window *pWindow )
-        : PushButtonImpl( pCtx, xPeer, pWindow )
-        , bAdvancedMode( false )
-          // TODO: i18n
-          // Button::GetStandardText( BUTTON_ADVANCED );
-          // Button::GetStandardText( BUTTON_SIMPLE );
-        , mSimpleLabel( rtl::OUString::createFromAscii( "Advanced..." ) )
-        , mAdvancedLabel( rtl::OUString::createFromAscii( "Simple..." ) )
-{
-}
-    void Click()
-    {
-        bAdvancedMode = !bAdvancedMode;
-        if ( bAdvancedMode )
-            advancedMode();
-        else
-            simpleMode();
-    }
-    void advancedMode()
-    {
-        // TODO: set symbol/image?
-        // SYMBOL_PAGEUP, SYMBOL_PAGEDOWN
-#if 0
-        // How to set images from here?
-        // XImageConsumer looks like a disaster
-        // Should move all this switching functionality to VCLXAdvancedButton?
-        /biek/home/janneke/vc/layout-cws/default_images/res/commandimagelist/
-            sc_arrowshapes_down.png
-            sch_flowchartshapes.flowchart-extract.png
-            sch_flowchartshapes.flowchart-merge.png
-#endif        
-        mxButton->setLabel( mAdvancedLabel );
-        for ( std::list< Window*>::iterator it = maAdvanced.begin();
-              it != maAdvanced.end(); it++ )
-            ( *it )->Show();
-        for ( std::list< Window*>::iterator it = maSimple.begin();
-              it != maSimple.end(); it++ )
-            ( *it )->Hide();
-
-        redraw();
-    }
-
-    void simpleMode()
-{
-        mxButton->setLabel( mSimpleLabel );
-        for ( std::list< Window*>::iterator it = maAdvanced.begin();
-              it != maAdvanced.end(); it++ )
-            ( *it )->Hide();
-        for ( std::list< Window*>::iterator it = maSimple.begin();
-              it != maSimple.end(); it++ )
-            ( *it )->Show();
-
-        redraw();
-    }
-    void AddAdvanced( Window* w )
-    {
-        maAdvanced.push_back( w );
-        if ( !bAdvancedMode )
-            w->Hide();
-    }
-    void AddSimple( Window* w )
-    {
-        maSimple.push_back( w );
-        if ( bAdvancedMode )
-            w->Hide();
-    }
-    void RemoveAdvanced( Window* w )
-    {
-        Remove( maAdvanced, w );
-    }
-    void RemoveSimple( Window* w )
-    {
-        Remove( maSimple, w );
-    }
-};
-
-void AdvancedButton::AddAdvanced( Window* w )
-{
-    getImpl().AddAdvanced( w );
-}
-
-void AdvancedButton::AddSimple( Window* w )
-{
-    getImpl().AddSimple( w );
-}
-
-void AdvancedButton::RemoveAdvanced( Window* w )
-{
-    getImpl().RemoveAdvanced( w );
-}
-
-void AdvancedButton::RemoveSimple( Window* w )
-{
-    getImpl().RemoveSimple( w );
-}
-
-IMPL_CONSTRUCTORS( AdvancedButton, PushButton, "advancedbutton" );
-IMPL_GET_IMPL( AdvancedButton );
-
-
-class MoreButtonImpl : public AdvancedButtonImpl
-{
-public:
-    MoreButtonImpl( Context *pCtx, PeerHandle const& xPeer, Window *pWindow )
-        : AdvancedButtonImpl( pCtx, xPeer, pWindow)
-    {
-        mAdvancedLabel = ::Button::GetStandardText( BUTTON_LESS );
-        mSimpleLabel = ::Button::GetStandardText( BUTTON_MORE );
-    }
-    void AddWindow( Window* w ) { AddAdvanced( w ); }
-    void RemoveWindow( Window* w ) { RemoveAdvanced( w ); }
-};
-
-// TODO
-//BUTTON_IMPL( MoreButton, PushButton, 0 );
-IMPL_CONSTRUCTORS( MoreButton, AdvancedButton, "morebutton" );
-IMPL_GET_IMPL( MoreButton );
-
-void MoreButton::AddWindow( Window* w )
-{
-    getImpl().AddWindow( w );
-}
-
-void MoreButton::RemoveWindow( Window* w )
-{
-    getImpl().RemoveWindow( w );
-}
-
-} // namespace layout
diff --git a/toolkit/source/vclcompat/wcontainer.cxx b/toolkit/source/vclcompat/wcontainer.cxx
deleted file mode 100644
index ba49195..0000000
--- toolkit/source/vclcompat/wcontainer.cxx
+++ /dev/null
@@ -1,272 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "wrapper.hxx"
-
-#include "layout/layoutcore.hxx"
-#include <com/sun/star/awt/XLayoutRoot.hpp>
-#include <com/sun/star/awt/XLayoutContainer.hpp>
-
-#include <comphelper/processfactory.hxx>
-
-#include <tools/debug.hxx>
-
-using namespace ::com::sun::star;
-
-namespace layout
-{
-
-Container::Container( Context const* pCtx, char const* pId )
-    : mxContainer( pCtx->GetPeerHandle( pId ), uno::UNO_QUERY )
-{
-    if ( !mxContainer.is() )
-    {
-        DBG_ERROR1( "Error: failed to associate container with '%s'", pId );
-    }
-}
-
-Container::Container( rtl::OUString const& rName, sal_Int32 nBorder )
-{
-    mxContainer = layoutimpl::createContainer( rName );
-
-    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
-    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Border" ) ),
-                              uno::Any( nBorder ) );
-}
-
-void Container::Add( Window *pChild )
-{
-    if ( pChild )
-    {
-        uno::Reference< awt::XLayoutConstrains > xChild( pChild->GetPeer(), uno::UNO_QUERY );
-        mxContainer->addChild( xChild );
-    }
-}
-
-void Container::Add( Container *pChild )
-{
-    if ( pChild )
-    {
-        uno::Reference< awt::XLayoutConstrains > xChild( pChild->getImpl(), uno::UNO_QUERY );
-        mxContainer->addChild( xChild );
-    }
-}
-
-void Container::Remove( Window *pChild )
-{
-    if ( pChild )
-    {
-        uno::Reference< awt::XLayoutConstrains > xChild( pChild->GetPeer(), uno::UNO_QUERY );
-        mxContainer->removeChild( xChild );
-    }
-}
-
-void Container::Remove( Container *pChild )
-{
-    if ( pChild )
-    {
-        uno::Reference< awt::XLayoutConstrains > xChild( pChild->getImpl(), uno::UNO_QUERY );
-        mxContainer->removeChild( xChild );
-    }
-}
-
-void Container::Clear()
-{
-    css::uno::Sequence< css::uno::Reference < css::awt::XLayoutConstrains > > children;
-    children = mxContainer->getChildren();
-    for( int i = 0; i < children.getLength(); i++ )
-        mxContainer->removeChild( children[ i ] );
-}
-
-void Container::ShowAll( bool bShow )
-{
-    struct inner
-    {
-        static void setChildrenVisible( uno::Reference < awt::XLayoutContainer > xCont,
-                                        bool bVisible )  /* auxiliary */
-        {
-            if ( xCont.is() )
-            {
-                uno::Sequence< uno::Reference < awt::XLayoutConstrains > > aChildren;
-                aChildren = xCont->getChildren();
-                for( int i = 0; i < aChildren.getLength(); i++ )
-                {
-                    uno::Reference < awt::XLayoutConstrains > xChild( aChildren[ i ] );
-
-                    uno::Reference< awt::XWindow > xWin( xChild, uno::UNO_QUERY);
-                    if ( xWin.is() )
-                        xWin->setVisible( bVisible );
-
-                    uno::Reference < awt::XLayoutContainer > xChildCont(
-                        xChild, uno::UNO_QUERY );
-                    setChildrenVisible( xChildCont, bVisible );
-                }
-            }
-        }
-    };
-
-    inner::setChildrenVisible( mxContainer, bShow );
-}
-
-void Container::Show()
-{
-    ShowAll( true );
-}
-
-void Container::Hide()
-{
-    ShowAll( false );
-}
-
-Table::Table( sal_Int32 nBorder, sal_Int32 nColumns )
-    : Container( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "table" ) ), nBorder )
-{
-    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
-    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Columns" ) ),
-                              uno::Any( nColumns ) );
-}
-
-void Table::Add( Window *pWindow, bool bXExpand, bool bYExpand,
-                 sal_Int32 nXSpan, sal_Int32 nYSpan )
-{
-    if ( !pWindow )
-        return;
-    WindowImpl &rImpl = pWindow->getImpl();
-    uno::Reference< awt::XLayoutConstrains > xChild( rImpl.mxWindow,
-                                                     uno::UNO_QUERY );
-    mxContainer->addChild( xChild );
-    setProps( xChild, bXExpand, bYExpand, nXSpan, nYSpan );
-}
-
-void Table::Add( Container *pContainer, bool bXExpand, bool bYExpand,
-                 sal_Int32 nXSpan, sal_Int32 nYSpan )
-{
-    if ( !pContainer )
-        return;
-    uno::Reference< awt::XLayoutConstrains > xChild( pContainer->getImpl(),
-                                                     uno::UNO_QUERY );
-    mxContainer->addChild( xChild );
-    setProps( xChild, bXExpand, bYExpand, nXSpan, nYSpan );
-}
-
-void Table::setProps( uno::Reference< awt::XLayoutConstrains > xChild,
-                      bool bXExpand, bool bYExpand, sal_Int32 nXSpan, sal_Int32 nYSpan )
-{
-    uno::Reference< beans::XPropertySet > xProps
-        ( mxContainer->getChildProperties( xChild ), uno::UNO_QUERY_THROW );
-    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "XExpand" ) ),
-                              uno::Any( bXExpand ) );
-    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "YExpand" ) ),
-                              uno::Any( bYExpand ) );
-    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "ColSpan" ) ),
-                              uno::Any( nXSpan ) );
-    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "RowSpan" ) ),
-                              uno::Any( nYSpan ) );
-}
-
-Box::Box( rtl::OUString const& rName, sal_Int32 nBorder, bool bHomogeneous )
-    : Container( rName, nBorder )
-{
-    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
-    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ) ),
-                              uno::Any( bHomogeneous ) );
-}
-
-void Box::Add( Window *pWindow, bool bExpand, bool bFill, sal_Int32 nPadding)
-{
-    if ( !pWindow )
-        return;
-    WindowImpl &rImpl = pWindow->getImpl();
-    uno::Reference< awt::XLayoutConstrains > xChild( rImpl.mxWindow,
-                                                     uno::UNO_QUERY );
-
-    mxContainer->addChild( xChild );
-    setProps( xChild, bExpand, bFill, nPadding );
-}
-
-void Box::Add( Container *pContainer, bool bExpand, bool bFill, sal_Int32 nPadding)
-{
-    if ( !pContainer )
-        return;
-
-    uno::Reference< awt::XLayoutConstrains > xChild( pContainer->getImpl(),
-                                                     uno::UNO_QUERY );
-    mxContainer->addChild( xChild );
-    setProps( xChild, bExpand, bFill, nPadding );
-}
-
-void Box::setProps( uno::Reference< awt::XLayoutConstrains > xChild,
-                    bool bExpand, bool bFill, sal_Int32 nPadding )
-{
-    uno::Reference< beans::XPropertySet > xProps
-        ( mxContainer->getChildProperties( xChild ), uno::UNO_QUERY_THROW );
-
-    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "Expand" ) ),
-                              uno::Any( bExpand ) );
-    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Fill" ) ),
-                              uno::Any( bFill ) );
-    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Padding" ) ),
-                              uno::Any( nPadding ) );
-}
-
-Table::Table( Context const* pCtx, char const* pId )
-    : Container( pCtx, pId )
-{
-}
-
-Box::Box( Context const* pCtx, char const* pId )
-    : Container( pCtx, pId )
-{
-}
-
-HBox::HBox( sal_Int32 nBorder, bool bHomogeneous )
-    : Box( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "hbox" ) ),
-           nBorder, bHomogeneous )
-{
-}
-
-HBox::HBox( Context const* pCtx, char const* pId )
-    : Box( pCtx, pId )
-{
-}
-
-VBox::VBox( sal_Int32 nBorder, bool bHomogeneous )
-    : Box( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "vbox" ) ),
-           nBorder, bHomogeneous )
-{
-}
-
-VBox::VBox( Context const* pCtx, char const* pId )
-    : Box( pCtx, pId )
-{
-}
-
-} // namespace layout
diff --git a/toolkit/source/vclcompat/wfield.cxx b/toolkit/source/vclcompat/wfield.cxx
deleted file mode 100644
index 015cf63..0000000
--- toolkit/source/vclcompat/wfield.cxx
+++ /dev/null
@@ -1,635 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "wrapper.hxx"
-
-#include <comphelper/processfactory.hxx>
-#include <com/sun/star/awt/XMetricField.hpp>
-#include <com/sun/star/awt/XCurrencyField.hpp>
-#include <com/sun/star/awt/XTextComponent.hpp>
-#include <com/sun/star/awt/XListBox.hpp>
-#include <com/sun/star/awt/XComboBox.hpp>
-#include <cppuhelper/implbase1.hxx>
-#include <com/sun/star/awt/XActionListener.hpp>
-#include <com/sun/star/awt/XItemListener.hpp>
-
-using namespace ::com::sun::star;
-
-namespace layout
-{
-
-class EditImpl : public ControlImpl,
-                 public ::cppu::WeakImplHelper1< awt::XTextListener >
-{
-    Link maModifyHdl;
-  public:
-    uno::Reference< awt::XTextComponent > mxEdit;
-    EditImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ControlImpl( pCtx, xPeer, pWindow )
-        ,  mxEdit( xPeer, uno::UNO_QUERY )
-    {
-    }
-
-    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
-        throw (css::uno::RuntimeException)
-    {
-        SetModifyHdl( Link() );
-        mxEdit.clear();
-    }
-
-    void SetModifyHdl( const Link& rLink )
-    {
-        if ( !mxEdit.is() )
-            return;
-        maModifyHdl = rLink;
-        if ( !rLink )
-            mxEdit->removeTextListener( this );
-        else
-            mxEdit->addTextListener( this );
-    }
-
-    void SAL_CALL textChanged( const css::awt::TextEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        maModifyHdl.Call( mpWindow );
-    }
-};
-
-void Edit::SetSelection( Selection const& rSelection )
-{
-    if ( !getImpl().mxEdit.is() )
-        return;
-    getImpl().mxEdit->setSelection( awt::Selection( rSelection.Min(), rSelection.Max() ) );
-}
-
-void Edit::SetText( XubString const& rStr ) const
-{
-    if ( !getImpl().mxEdit.is() )
-        return;
-    getImpl().mxEdit->setText( rStr );
-}
-
-XubString Edit::GetText() const
-{
-    if ( !getImpl().mxEdit.is() )
-        return XubString();
-    return XubString( getImpl().mxEdit->getText());
-}
-
-void Edit::SetModifyHdl( const Link& rLink )
-{
-    getImpl().SetModifyHdl( rLink );
-}
-
-IMPL_CONSTRUCTORS( Edit, Control, "edit" );
-IMPL_GET_IMPL( Edit );
-
-// Window/Control/Edit/MultiLineEdit
-class MultiLineEditImpl : public EditImpl
-{
-public:
-    MultiLineEditImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : EditImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-IMPL_CONSTRUCTORS( MultiLineEdit, Edit, "multilineedit" );
-IMPL_GET_IMPL( MultiLineEdit );
-
-// Window/Control/Edit/SpinField
-class SpinFieldImpl : public EditImpl
-{
-  public:
-    SpinFieldImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : EditImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-IMPL_CONSTRUCTORS( SpinField, Edit, "spinfield" );
-
-// Window/Control/Edit/SpinField/NumericField
-class NumericFieldImpl : public SpinFieldImpl
-{
-  public:
-    NumericFieldImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : SpinFieldImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-// Window/Control/Edit/SpinField/MetricField
-class MetricFieldImpl : public SpinFieldImpl
-{
-  public:
-    MetricFieldImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : SpinFieldImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-IMPL_GET_IMPL( SpinField );
-IMPL_GET_IMPL( NumericField );
-IMPL_GET_IMPL( MetricField );
-
-// FormatterBase
-class FormatterBaseImpl
-{
-  protected:
-    PeerHandle mxPeer;
-  public:
-    explicit FormatterBaseImpl( const PeerHandle &xPeer )
-        : mxPeer( xPeer )
-    {
-    };
-};
-
-class NumericFormatterImpl : public FormatterBaseImpl
-{
-  public:
-    uno::Reference< awt::XCurrencyField > mxField;
-    explicit NumericFormatterImpl( const PeerHandle &xPeer )
-        : FormatterBaseImpl( xPeer )
-        , mxField( xPeer, uno::UNO_QUERY )
-    {
-    }
-
-    // FIXME: burn that CPU ! cut/paste from vclxwindows.cxx
-    double valueToDouble( sal_Int64 nValue )
-    {
-        sal_Int16 nDigits = mxField->getDecimalDigits();
-        double n = (double)nValue;
-        for ( sal_uInt16 d = 0; d < nDigits; d++ )
-            n /= 10;
-        return n;
-    } // FIXME: burn that CPU ! cut/paste from vclxwindows.cxx
-    sal_Int64 doubleToValue( double nValue )
-    {
-        sal_Int16 nDigits = mxField->getDecimalDigits();
-        double n = nValue;
-        for ( sal_uInt16 d = 0; d < nDigits; d++ )
-            n *= 10;
-        return (sal_Int64) n;
-    }
-};
-
-class MetricFormatterImpl : public FormatterBaseImpl
-{
-  public:
-    uno::Reference< awt::XMetricField > mxField;
-    explicit MetricFormatterImpl( const PeerHandle &xPeer )
-        : FormatterBaseImpl( xPeer )
-        , mxField( xPeer, uno::UNO_QUERY )
-    {
-    }
-};
-
-// NumericFormatter
-
-NumericFormatter::NumericFormatter( FormatterBaseImpl *pImpl )
-    : FormatterBase( pImpl )
-{
-}
-
-NumericFormatterImpl& NumericFormatter::getFormatImpl() const
-{
-    return *( static_cast<NumericFormatterImpl *>( mpFormatImpl ) );
-}
-
-#define SET_IMPL(vclmethod, idlmethod) \
-    void NumericFormatter::vclmethod( sal_Int64 nValue ) \
-    { \
-        if ( !getFormatImpl().mxField.is() ) \
-            return; \
-        getFormatImpl().mxField->idlmethod( getFormatImpl().valueToDouble( nValue ) ); \
-    }
-
-SET_IMPL( SetMin, setMin )
-SET_IMPL( SetMax, setMax )
-SET_IMPL( SetLast, setLast )
-SET_IMPL( SetFirst, setFirst )
-SET_IMPL( SetValue, setValue )
-SET_IMPL( SetSpinSize, setSpinSize )
-
-sal_Int64 NumericFormatter::GetValue() const
-{
-    if ( !getFormatImpl().mxField.is() )
-        return 0;
-    return getFormatImpl().doubleToValue( getFormatImpl().mxField->getValue() );
-}
-
-#undef SET_IMPL
-
-IMPL_CONSTRUCTORS_2( NumericField, SpinField, NumericFormatter, "numericfield" );
-
-// MetricFormatter
-
-MetricFormatter::MetricFormatter( FormatterBaseImpl *pImpl )
-    : FormatterBase( pImpl )
-{
-}
-MetricFormatterImpl& MetricFormatter::getFormatImpl() const
-{    return *( static_cast<MetricFormatterImpl *>( mpFormatImpl ) );   }
-
-#define MetricUnitVclToUno(a) ((sal_uInt16)(a))
-
-#define SET_IMPL(vclmethod, idlmethod) \
-    void MetricFormatter::vclmethod( sal_Int64 nValue, FieldUnit nUnit ) \
-    { \
-        if ( !getFormatImpl().mxField.is() ) \
-            return; \
-        getFormatImpl().mxField->idlmethod( nValue, MetricUnitVclToUno( nUnit ) ); \
-    }
-
-SET_IMPL( SetMin, setMin )
-SET_IMPL( SetMax, setMax )
-SET_IMPL( SetLast, setLast )
-SET_IMPL( SetFirst, setFirst )
-SET_IMPL( SetValue, setValue )
-
-#undef SET_IMPL
-
-void MetricFormatter::SetSpinSize( sal_Int64 nValue )
-{
-    if ( !getFormatImpl().mxField.is() )
-        return;
-    getFormatImpl().mxField->setSpinSize( nValue );
-}
-
-sal_Int64 MetricFormatter::GetValue( FieldUnit nUnit ) const
-{
-    if ( !getFormatImpl().mxField.is() )
-        return 0;
-    return getFormatImpl().mxField->getValue( MetricUnitVclToUno( nUnit ) );
-}
-
-IMPL_CONSTRUCTORS_2( MetricField, SpinField, MetricFormatter, "metricfield" );
-
-// Window/Control/Edit/ComboBox
-class ComboBoxImpl : public EditImpl,
-                     public ::cppu::WeakImplHelper1< awt::XActionListener >,
-                     public ::cppu::WeakImplHelper1< awt::XItemListener >
-{
-    Link maClickHdl, maSelectHdl;
-public:
-    uno::Reference< awt::XComboBox > mxComboBox;
-    ComboBoxImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : EditImpl( pCtx, xPeer, pWindow ),
-        mxComboBox( xPeer, uno::UNO_QUERY )
-    {
-    }
-
-    USHORT InsertEntry( XubString const& rStr, USHORT nPos )
-    {
-        if ( nPos == COMBOBOX_APPEND )
-            nPos = GetEntryCount();
-        mxComboBox->addItem( rtl::OUString( rStr ), nPos );
-        return nPos;
-    }
-
-    void RemoveEntry( USHORT nPos )
-    {
-        mxComboBox->removeItems( nPos, 1 );
-    }
-
-    USHORT GetEntryPos( const XubString& rStr ) const
-    {
-        uno::Sequence< rtl::OUString> aItems( mxComboBox->getItems() );
-        rtl::OUString rKey( rStr );
-        for( unsigned int i = 0; aItems.getLength(); i++ )
-        {
-            if ( aItems[ i ] == rKey )
-                return sal::static_int_cast< USHORT >( i );
-        }
-        return COMBOBOX_ENTRY_NOTFOUND;
-    }
-
-    XubString GetEntry( USHORT nPos ) const
-    {
-        return XubString( mxComboBox->getItem( nPos ) );
-    }
-
-    USHORT GetEntryCount() const
-    {
-        return mxComboBox->getItemCount();
-    }
-
-    void SetClickHdl( const Link& rLink )
-    {
-        maClickHdl = rLink;
-        if ( !rLink )
-            mxComboBox->removeActionListener( this );
-        else
-            mxComboBox->addActionListener( this );
-    }
-
-    void SetSelectHdl( const Link& rLink )
-    {
-        maSelectHdl = rLink;
-        if ( !rLink )
-            mxComboBox->removeItemListener( this );
-        else
-            mxComboBox->addItemListener( this );
-    }
-
-    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
-        throw (css::uno::RuntimeException)
-    {
-        mxComboBox.clear();
-    }
-
-    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        ComboBox* pComboBox = static_cast<ComboBox*>( mpWindow );
-        if ( !pComboBox )
-            return;
-        maClickHdl.Call( pComboBox );
-    }
-
-    virtual void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        ComboBox* pComboBox = static_cast<ComboBox*>( mpWindow );
-        if ( !pComboBox )
-            return;
-        maSelectHdl.Call( pComboBox );
-    }
-};
-
-USHORT ComboBox::InsertEntry( const XubString &rStr, USHORT nPos )
-{
-    return getImpl().InsertEntry( rStr, nPos );
-}
-
-void ComboBox::RemoveEntry( const XubString& rStr )
-{
-    getImpl().RemoveEntry( GetEntryPos( rStr ) );
-}
-
-void ComboBox::RemoveEntry( USHORT nPos )
-{
-    getImpl().RemoveEntry( nPos );
-}
-
-void ComboBox::Clear()
-{
-    uno::Sequence< rtl::OUString> aNoItems;
-    getImpl().setProperty( "StringItemList", uno::Any( aNoItems ) );
-}
-
-USHORT ComboBox::GetEntryPos( const XubString& rStr ) const
-{
-    return getImpl().GetEntryPos( rStr );
-}
-
-XubString ComboBox::GetEntry( USHORT nPos ) const
-{
-    rtl::OUString rItem = getImpl().mxComboBox->getItem( nPos );
-    return XubString( rItem );
-}
-
-USHORT ComboBox::GetEntryCount() const
-{
-    return getImpl().GetEntryCount();
-}
-
-void ComboBox::SetClickHdl( const Link& rLink )
-{
-    getImpl().SetClickHdl( rLink );
-}
-
-void ComboBox::SetSelectHdl( const Link& rLink )
-{
-    getImpl().SetSelectHdl( rLink );
-}
-
-IMPL_CONSTRUCTORS( ComboBox, Edit, "combobox" );
-IMPL_GET_IMPL( ComboBox );
-
-// Window/Control/ListBox
-class ListBoxImpl : public ControlImpl,
-                    public ::cppu::WeakImplHelper1< awt::XActionListener >,
-                    public ::cppu::WeakImplHelper1< awt::XItemListener >
-{
-    Link maClickHdl, maSelectHdl;
-public:
-    uno::Reference< awt::XListBox > mxListBox;
-    ListBoxImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ControlImpl( pCtx, xPeer, pWindow ),
-        mxListBox( xPeer, uno::UNO_QUERY )
-    {
-        SelectEntryPos( 0, true );
-    }
-
-    USHORT InsertEntry(const XubString& rStr, USHORT nPos)
-    {
-        if ( nPos == LISTBOX_APPEND )
-            nPos = mxListBox->getItemCount();
-        mxListBox->addItem( rtl::OUString( rStr ), nPos );
-        return nPos;
-    }
-
-    void RemoveEntry( USHORT nPos )
-    {
-        mxListBox->removeItems( nPos, 1 );
-    }
-
-    USHORT RemoveEntry(const XubString& rStr, USHORT nPos)
-    {
-        if ( nPos == LISTBOX_APPEND )
-            nPos = mxListBox->getItemCount();
-        mxListBox->addItem( rtl::OUString( rStr ), nPos );
-        return nPos;
-    }
-
-    USHORT GetEntryPos( const XubString& rStr ) const
-    {
-        uno::Sequence< rtl::OUString> aItems( mxListBox->getItems() );
-        rtl::OUString rKey( rStr );
-        for( unsigned int i = 0; aItems.getLength(); i++ )
-        {
-            if ( aItems[ i ] == rKey )
-                return sal::static_int_cast< USHORT >( i );
-        }
-        return LISTBOX_ENTRY_NOTFOUND;
-    }
-
-    XubString GetEntry( USHORT nPos ) const
-    {
-        return mxListBox->getItem( nPos );
-    }
-
-    USHORT GetEntryCount() const
-    {
-        return mxListBox->getItemCount();
-    }
-
-    void SelectEntryPos( USHORT nPos, BOOL bSelect )
-    {
-        mxListBox->selectItemPos( nPos, bSelect );
-    }
-
-    USHORT GetSelectEntryCount() const
-    {
-        return sal::static_int_cast< USHORT >( mxListBox->getSelectedItems().getLength() );
-    }
-
-    USHORT GetSelectEntryPos( USHORT nSelIndex ) const
-    {
-        USHORT nSelected = 0;
-        if ( mxListBox->isMutipleMode() )
-        {
-            uno::Sequence< short > aItems( mxListBox->getSelectedItemsPos() );
-            if ( nSelIndex < aItems.getLength() )
-                nSelected = aItems[ nSelIndex ];
-        }
-        else
-            nSelected = mxListBox->getSelectedItemPos();
-        return nSelected;
-    }
-
-    void SetClickHdl( const Link& rLink )
-    {
-        maClickHdl = rLink;
-        if ( !rLink )
-            mxListBox->removeActionListener( this );
-        else
-            mxListBox->addActionListener( this );
-    }
-
-    void SetSelectHdl( const Link& rLink )
-    {
-        maSelectHdl = rLink;
-        if ( !rLink )
-            mxListBox->removeItemListener( this );
-        else
-            mxListBox->addItemListener( this );
-    }
-
-    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
-        throw (css::uno::RuntimeException)
-    {
-        mxListBox.clear();
-    }
-
-    void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        maClickHdl.Call( mpWindow );
-    }
-
-    void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
-        throw (css::uno::RuntimeException)
-    {
-        ListBox* pListBox = static_cast<ListBox*>( mpWindow );
-        if ( !pListBox )
-            return;
-        maSelectHdl.Call( pListBox );
-    }
-};
-
-USHORT ListBox::InsertEntry(const XubString& rStr, USHORT nPos)
-{
-    return getImpl().InsertEntry(rStr, nPos);
-}
-
-void ListBox::RemoveEntry( USHORT nPos )
-{
-    return getImpl().RemoveEntry( nPos );
-}
-
-void ListBox::RemoveEntry( const XubString& rStr )
-{
-    return getImpl().RemoveEntry( GetEntryPos( rStr ) );
-}
-
-void ListBox::Clear()
-{
-    uno::Sequence< rtl::OUString> aNoItems;
-    getImpl().setProperty( "StringItemList", uno::Any( aNoItems ) );
-}
-
-USHORT ListBox::GetEntryPos( const XubString& rStr ) const
-{
-    return getImpl().GetEntryPos( rStr );
-}
-
-XubString ListBox::GetEntry( USHORT nPos ) const
-{
-    return getImpl().GetEntry( nPos );
-}
-
-USHORT ListBox::GetEntryCount() const
-{
-    return getImpl().GetEntryCount();
-}
-
-void ListBox::SelectEntryPos( USHORT nPos, BOOL bSelect )
-{
-    getImpl().SelectEntryPos( nPos, bSelect );
-}
-
-void ListBox::SelectEntry( const XubString& rStr, BOOL bSelect )
-{
-    SelectEntryPos( GetEntryPos( rStr ), bSelect );
-}
-
-USHORT ListBox::GetSelectEntryCount() const
-{
-    return getImpl().GetSelectEntryCount();
-}
-
-USHORT ListBox::GetSelectEntryPos( USHORT nSelIndex ) const
-{
-    return getImpl().GetSelectEntryPos( nSelIndex );
-}
-
-XubString ListBox::GetSelectEntry( USHORT nSelIndex ) const
-{
-    return GetEntry( GetSelectEntryPos( nSelIndex ) );
-}
-
-void ListBox::SetSelectHdl( const Link& rLink )
-{
-    getImpl().SetSelectHdl( rLink );
-}
-
-void ListBox::SetClickHdl( const Link& rLink )
-{
-    getImpl().SetClickHdl( rLink );
-}
-
-IMPL_CONSTRUCTORS( ListBox, Control, "listbox" );
-IMPL_GET_IMPL( ListBox );
-
-} // namespace layout
diff --git a/toolkit/source/vclcompat/wrapper.cxx b/toolkit/source/vclcompat/wrapper.cxx
deleted file mode 100644
index 38db3f4..0000000
--- toolkit/source/vclcompat/wrapper.cxx
+++ /dev/null
@@ -1,763 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "wrapper.hxx"
-
-#include <awt/vclxplugin.hxx>
-#include <com/sun/star/awt/PosSize.hpp>
-#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
-#include <com/sun/star/awt/WindowAttribute.hpp>
-#include <com/sun/star/awt/XDialog2.hpp>
-#include <com/sun/star/awt/XProgressBar.hpp>
-#include <com/sun/star/graphic/XGraphic.hpp>
-#include <comphelper/processfactory.hxx>
-#include <cstdio>
-#include <layout/factory.hxx>
-#include <layout/layoutcore.hxx>
-#include <layout/root.hxx>
-#include <layout/localized-string.hxx>
-#include <toolkit/awt/vclxwindow.hxx>
-#include <vcl/ctrl.hxx>
-#include <vcl/image.hxx>
-#include <vcl/tabpage.hxx>
-#include <vcl/window.hxx>
-
- 
-#if 0
-/* FIXME: move to sfx2 or svtools/layout.hxx */
-#include <svtools/itempool.hxx>
-#include <svtools/itemset.hxx>
-#include <svtools/poolitem.hxx>
-#endif
- 
-using namespace ::com::sun::star;
-using rtl::OUString;
-
-namespace layout
-{
-
-// Context bits ...
-class ContextImpl
-{
-    uno::Reference< awt::XLayoutRoot > mxRoot;
-    uno::Reference< container::XNameAccess > mxNameAccess;
-    PeerHandle mxTopLevel;
-
-public:
-    ContextImpl( char const *pPath )
-    {
-        uno::Sequence< uno::Any > aParams( 1 );
-        aParams[0] <<= OUString( pPath, strlen( pPath ), RTL_TEXTENCODING_UTF8 );
-
-        uno::Reference< lang::XSingleServiceFactory > xFactory(
-            comphelper::createProcessComponent(
-                OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
-            uno::UNO_QUERY );
-        if ( !xFactory.is() )
-        {
-            throw uno::RuntimeException(
-                OUString( RTL_CONSTASCII_USTRINGPARAM( "Layout engine not installed" ) ),
-                uno::Reference< uno::XInterface >() );
-        }
-        mxRoot = uno::Reference< awt::XLayoutRoot >(
-            xFactory->createInstanceWithArguments( aParams ),
-            uno::UNO_QUERY );
-
-        mxNameAccess = uno::Reference< container::XNameAccess >( mxRoot, uno::UNO_QUERY );
-    }
-
-    ~ContextImpl()
-    {
-    }
-
-    PeerHandle getByName( const OUString &rName )
-    {
-        uno::Any val = mxNameAccess->getByName( rName );
-        PeerHandle xRet;
-        val >>= xRet;
-        return xRet;
-    }
-    PeerHandle getTopLevel()                 { return mxTopLevel; }
-    void setTopLevel( PeerHandle xToplevel ) { mxTopLevel = xToplevel; }
-    PeerHandle getRoot()                     { return mxRoot; }
-};
-
-Context::Context( const char *pPath )
-    : pImpl( new ContextImpl( pPath ) )
-{
-}
-Context::~Context()
-{
-    delete pImpl;
-    pImpl = NULL;
-}
-
-void Context::setToplevel( PeerHandle xToplevel )
-{
-    pImpl->setTopLevel( xToplevel );
-}
-
-PeerHandle Context::getToplevel()
-{
-    return pImpl->getTopLevel();
-}
-PeerHandle Context::getRoot()
-{
-     return pImpl->getRoot();
-}
-
-PeerHandle Context::GetPeerHandle( const char *pId, sal_uInt32 nId ) const
-{
-    PeerHandle xHandle;
-    xHandle = pImpl->getByName( OUString( pId, strlen( pId ), RTL_TEXTENCODING_UTF8 ) );
-    if ( !xHandle.is() )
-    {
-        DBG_ERROR1( "Failed to fetch widget '%s'", pId );
-    }
-
-    if ( nId != 0 )
-    {
-        rtl::OString aStr = rtl::OString::valueOf( (sal_Int32) nId );
-        xHandle = GetPeerHandle( aStr, 0 );
-    }
-    return xHandle;
-}
-
-IMPL_GET_IMPL( Control );
-
-Window::Window( WindowImpl *pImpl )
-    : mpImpl( pImpl )
-{
-}
-
-Window::~Window()
-{
-    /* likely to be an UNO object - with floating references */
-    mpImpl->wrapperGone();
-    mpImpl = NULL;
-}
-
-void Window::SetParent( ::Window *pParent )
-{
-    uno::Reference <awt::XWindow> ref( GetPeer(), uno::UNO_QUERY );
-    ::Window *window = VCLXWindow::GetImplementation( ref )->GetWindow();
-    window->SetParent( pParent );
-}
-
-void Window::SetParent( Window *pParent )
-{
-    uno::Reference <awt::XWindow> parentRef( pParent->GetPeer(), uno::UNO_QUERY );
-    ::Window *parentWindow = VCLXWindow::GetImplementation( parentRef )->GetWindow();
-    SetParent( parentWindow );
-}
-
-Context *Window::getContext()
-{
-    return this && mpImpl ? mpImpl->mpCtx : NULL;
-}
-
-PeerHandle Window::GetPeer()
-{
-    if ( !mpImpl )
-        return PeerHandle();
-    return mpImpl->mxWindow;
-}
-
-uno::Reference<awt::XWindow> Window::GetRef()
-{
-    return uno::Reference <awt::XWindow> ( GetPeer(), uno::UNO_QUERY );
-}
-
-VCLXWindow* Window::GetVCLXWindow()
-{
-    return VCLXWindow::GetImplementation( GetRef() );
-}
-
-::Window* Window::GetWindow()
-{
-    return GetVCLXWindow()->GetWindow();
-}
-
-::Window* Window::GetParent()
-{
-    return GetWindow()->GetParent();
-}
-
-struct ToolkitVclPropsMap
-{
-    WinBits vclStyle;
-    long initAttr;
-    const char *propName;
-
-    // the value to give the prop to enable/disable it -- not the most brilliant
-    // type declaration and storage, but does the work... properties are
-    // either a boolean or a short since they are either a directly wrappers for
-    // a WinBit, or aggregates related (like Align for WB_LEFT, _RIGHT and _CENTER).
-    bool isBoolean;
-    short enableProp, disableProp;
-};
-
-#define TYPE_BOOL  true
-#define TYPE_SHORT false
-#define NOTYPE     0
-static const ToolkitVclPropsMap toolkitVclPropsMap[] =
-{
-    { WB_BORDER,    awt::WindowAttribute::BORDER,    "Border", TYPE_SHORT, 1, 0 },
-    { WB_NOBORDER,    awt::VclWindowPeerAttribute::NOBORDER,    "Border", TYPE_SHORT, 0, 1 },
-    { WB_SIZEABLE,    awt::WindowAttribute::SIZEABLE,    NULL, NOTYPE, 0, 0 },
-    { WB_MOVEABLE,    awt::WindowAttribute::MOVEABLE,    NULL, NOTYPE, 0, 0 },
-    { WB_CLOSEABLE,    awt::WindowAttribute::CLOSEABLE,    NULL, NOTYPE, 0, 0 },
-
-    { WB_HSCROLL,    awt::VclWindowPeerAttribute::HSCROLL,    NULL, NOTYPE, 0, 0 },
-    { WB_VSCROLL,    awt::VclWindowPeerAttribute::VSCROLL,    NULL, NOTYPE, 0, 0 },
-    { WB_LEFT,    awt::VclWindowPeerAttribute::LEFT,    "Align", TYPE_SHORT, 0, 0 },
-    { WB_CENTER,    awt::VclWindowPeerAttribute::CENTER,    "Align", TYPE_SHORT, 1, 0 },
-    { WB_RIGHT,    awt::VclWindowPeerAttribute::RIGHT,    "Align", TYPE_SHORT, 2, 0 },
-    { WB_SPIN,    awt::VclWindowPeerAttribute::SPIN,    NULL, NOTYPE, 0, 0 },
-    { WB_SORT,    awt::VclWindowPeerAttribute::SORT,    NULL, NOTYPE, 0, 0 },
-    { WB_DROPDOWN,    awt::VclWindowPeerAttribute::DROPDOWN,    "Dropdown",    TYPE_BOOL, 1, 0 },
-    { WB_DEFBUTTON,    awt::VclWindowPeerAttribute::DEFBUTTON,    "DefaultButton", TYPE_BOOL, 1, 0 },
-    { WB_READONLY,    awt::VclWindowPeerAttribute::READONLY,    NULL, NOTYPE, 0, 0 },
-    { WB_CLIPCHILDREN,    awt::VclWindowPeerAttribute::CLIPCHILDREN,    NULL, NOTYPE, 0, 0 },
-    { WB_GROUP,    awt::VclWindowPeerAttribute::GROUP,    NULL, NOTYPE, 0, 0 },
-
-    { WB_OK,    awt::VclWindowPeerAttribute::OK,    NULL, NOTYPE, 0, 0 },
-    { WB_OK_CANCEL,    awt::VclWindowPeerAttribute::OK_CANCEL,    NULL, NOTYPE, 0, 0 },
-    { WB_YES_NO,    awt::VclWindowPeerAttribute::YES_NO,    NULL, NOTYPE, 0, 0 },
-    { WB_YES_NO_CANCEL,    awt::VclWindowPeerAttribute::YES_NO_CANCEL,    NULL, NOTYPE, 1, 0 },
-    { WB_RETRY_CANCEL,    awt::VclWindowPeerAttribute::RETRY_CANCEL,    NULL, NOTYPE, 1, 0 },
-    { WB_DEF_OK,    awt::VclWindowPeerAttribute::DEF_OK,    NULL, NOTYPE, 0, 0 },
-    { WB_DEF_CANCEL,    awt::VclWindowPeerAttribute::DEF_CANCEL,    NULL, NOTYPE, 1, 0 },
-    { WB_DEF_RETRY,    awt::VclWindowPeerAttribute::DEF_RETRY,    NULL, NOTYPE, 0, 0 },
-    { WB_DEF_YES,    awt::VclWindowPeerAttribute::DEF_YES,    NULL, NOTYPE, 0, 0 },
-    { WB_DEF_NO,    awt::VclWindowPeerAttribute::DEF_NO,    NULL, NOTYPE, 0, 0 },
-
-    { WB_AUTOHSCROLL, awt::VclWindowPeerAttribute::AUTOHSCROLL, "AutoHScroll", TYPE_BOOL, 1, 0 },
-    { WB_AUTOVSCROLL, awt::VclWindowPeerAttribute::AUTOVSCROLL, "AutoVScroll",    TYPE_BOOL, 1, 0 },
-
-    { WB_WORDBREAK,    0,    "MultiLine", TYPE_BOOL, 1, 0 },
-    { WB_NOPOINTERFOCUS,    0,    "FocusOnClick", TYPE_BOOL, 1, 0 },
-    { WB_TOGGLE,    0,    "Toggle", TYPE_BOOL, 1, 0 },
-    { WB_REPEAT,    0,    "Repeat", TYPE_BOOL, 1, 0 },
-    { WB_NOHIDESELECTION,    0,    "HideInactiveSelection", TYPE_BOOL, 1, 0 },
-};
-#undef TYPE_BOOL
-#undef TYPE_SHORT
-#undef NOTYPE
-
-static const int toolkitVclPropsMapLen =
-    sizeof( toolkitVclPropsMap ) / sizeof( ToolkitVclPropsMap );
-
-void Window::SetStyle( WinBits nStyle )
-{
-    uno::Reference< awt::XVclWindowPeer > xPeer = mpImpl->mxVclPeer;
-    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
-    {
-        if ( toolkitVclPropsMap[ i ].propName )
-        {
-            short nValue;
-            if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
-                nValue = toolkitVclPropsMap[ i ].enableProp;
-            else
-                nValue = toolkitVclPropsMap[ i ].disableProp;
-            uno::Any aValue;
-            if ( toolkitVclPropsMap[ i ].isBoolean )
-                aValue = uno::makeAny( (bool) nValue );
-            else
-                aValue = uno::makeAny( (short) nValue );
-            mpImpl->setProperty( toolkitVclPropsMap[ i ].propName, aValue );
-        }
-    }
-}
-
-WinBits Window::GetStyle()
-{
-    uno::Reference< awt::XVclWindowPeer > xPeer = mpImpl->mxVclPeer;
-    WinBits ret = 0;
-    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
-    {
-        if ( toolkitVclPropsMap[ i ].propName )
-        {
-            short nValue = 0;
-            if ( toolkitVclPropsMap[ i ].isBoolean )
-            {
-                bool bValue = false;
-                mpImpl->getProperty( toolkitVclPropsMap[ i ].propName ) >>= bValue;
-                nValue = bValue ? 1 : 0;
-            }
-            else
-                mpImpl->getProperty( toolkitVclPropsMap[ i ].propName ) >>= nValue;
-            if ( nValue == toolkitVclPropsMap[ i ].enableProp )
-                ret |= toolkitVclPropsMap[i].vclStyle;
-        }
-    }
-    return ret;
-}
-
-/* Unpleasant way to get an xToolkit pointer ... */
-uno::Reference< awt::XToolkit > getToolkit()
-{
-    static uno::Reference< awt::XToolkit > xToolkit;
-    if (!xToolkit.is())
-    {
-        // Urgh ...
-        xToolkit = uno::Reference< awt::XToolkit >(
-            ::comphelper::getProcessServiceFactory()->createInstance(
-                OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.Toolkit" ) ) ),
-            uno::UNO_QUERY );
-        if ( !xToolkit.is() )
-            throw uno::RuntimeException(
-                OUString( RTL_CONSTASCII_USTRINGPARAM( "failed to create toolkit!") ),
-                uno::Reference< uno::XInterface >() );
-    }
-    return xToolkit;
-}
-
-PeerHandle Window::CreatePeer( Window *pParent, WinBits nStyle, const char *pName)
-{
-
-    long nWinAttrbs = 0;
-    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
-        if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
-            nWinAttrbs |= toolkitVclPropsMap[ i ].initAttr;
-
-    return layoutimpl::createWidget( getToolkit(), pParent->GetPeer(),
-                                     OUString::createFromAscii( pName ), nWinAttrbs );
-}
-
-void Window::Enable( bool bEnable )
-{
-    if ( !getImpl().mxWindow.is() )
-        return;
-    getImpl().mxWindow->setEnable( bEnable );
-}
-
-void Window::Show( BOOL bVisible )
-{
-    if ( !getImpl().mxWindow.is() )
-        return;
-    getImpl().mxWindow->setVisible( bVisible );
-}
-
-void Window::GrabFocus()
-{
-    if ( !getImpl().mxWindow.is() )
-        return;
-    getImpl().mxWindow->setFocus();
-}
-
-class DialogImpl : public WindowImpl
-{
-public:
-    uno::Reference< awt::XDialog2 > mxDialog;
-    DialogImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : WindowImpl( pCtx, xPeer, pWindow )
-        , mxDialog( xPeer, uno::UNO_QUERY )
-    {
-    }
-};
-
-IMPL_GET_IMPL( Dialog )
-
-Dialog::Dialog( Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId )
-    : Context( pXMLPath )
-    , Window( new DialogImpl( this, Context::GetPeerHandle( pId, nId ), this ) )
-{
-    if ( pParent )
-        SetParent( pParent );
-}
-
-Dialog::Dialog( ::Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId )
-    : Context( pXMLPath )
-    , Window( new DialogImpl( this, Context::GetPeerHandle( pId, nId ), this ) )
-{
-    if ( pParent )
-        SetParent( pParent );
-}
-
-short Dialog::Execute()
-{
-    if ( !getImpl().mxDialog.is() )
-        return -1;
-    return getImpl().mxDialog->execute();
-}
-
-void Dialog::EndDialog( long nResult )
-{
-    if ( !getImpl().mxDialog.is() )
-        return;
-    getImpl().mxDialog->endDialog( nResult );
-}
-
-void Dialog::SetText( String const& rStr )
-{
-    if ( !getImpl().mxDialog.is() )
-        return;
-    getImpl().mxDialog->setTitle( rStr );
-}
-
-class TabPageImpl : public WindowImpl
-{
-public:
-    uno::Reference< awt::XWindow > mxTabPage;
-    TabPageImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : WindowImpl( pCtx, xPeer, pWindow )
-        , mxTabPage( xPeer, uno::UNO_QUERY )
-    {
-    }
-};
-
-::Window* TabPage::global_parent = 0;
-
-IMPL_GET_IMPL( TabPage )
-
-TabPage::TabPage( Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId, SfxItemSet const* set )
-    : Context( pXMLPath )
-    , Window( new TabPageImpl( this, Context::GetPeerHandle( pId, nId ), this ) )
-    , bHasExchangeSupport( false )
-    , pSet( set )
-{
-    if ( pParent )
-        SetParent( pParent );
-}
-
-TabPage::TabPage( ::Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId, SfxItemSet const* set )
-    : Context( pXMLPath )
-    , Window( new TabPageImpl( this, Context::GetPeerHandle( pId, nId ), this ) )
-    , bHasExchangeSupport( false )
-    , pSet( set )
-{
-    if ( pParent )
-        SetParent( pParent );
-}
-
-TabPage::~TabPage()
-{
-    delete GetTabPage();
-}
-
-IMPL_GET_WINDOW( TabPage );
-
-void TabPage::ActivatePage()
-{
-}
-
-void TabPage::DeactivatePage()
-{
-}
-
-#if 0
-SfxTabPage::SfxTabPage( Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId, SfxItemSet const* set )
-    : TabPage( pParent, pXMLPath, pId, nId )
-    , bHasExchangeSupport( false )
-    , pSet( set )
-{
-}
-
-SfxTabPage::SfxTabPage( ::Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId, SfxItemSet const* set )
-    : TabPage( pParent, pXMLPath, pId, nId )
-{
-}
-
-/* FIXME: static method, full c&p from sfx2/source/dialog/tabdlg.cxx */
-//const SfxPoolItem* TabPage::GetItem( const SfxItemSet& rSet, USHORT nSlot )
-const SfxPoolItem* SfxTabPage::GetItem( const SfxItemSet& rSet, USHORT nSlot )
-
-{
-	const SfxItemPool* pPool = rSet.GetPool();
-	USHORT nWh = pPool->GetWhich( nSlot );
-	const SfxPoolItem* pItem = 0;
-#ifdef DEBUG
-	SfxItemState eState;
-    eState =
-#endif
-			rSet.GetItemState( nWh, TRUE, &pItem );  // -Wall required??
-
-	if ( !pItem && nWh != nSlot )
-		pItem = &pPool->GetDefaultItem( nWh );
-	return pItem;
-}
-#else 
-
-#define SfxTabPage TabPage
-
-#endif
-
-void SfxTabPage::Reset( SfxItemSet const& )
-{
-}
-
-class FixedLineImpl : public ControlImpl
-{
-public:
-    FixedLineImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ControlImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-IMPL_CONSTRUCTORS( FixedLine, Control, "hfixedline" );
-IMPL_GET_IMPL( FixedLine )
-
-bool FixedLine::IsEnabled()
-{
-    //FIXME
-    return true;
-}
-
-class FixedTextImpl : public ControlImpl
-{
-public:
-    uno::Reference< awt::XFixedText > mxFixedText;
-    FixedTextImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ControlImpl( pCtx, xPeer, pWindow )
-        , mxFixedText( xPeer, uno::UNO_QUERY )
-    {
-    }
-
-    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
-        throw (css::uno::RuntimeException)
-    {
-        mxFixedText.clear();
-    }
-};
-
-IMPL_CONSTRUCTORS( FixedText, Control, "fixedtext" );
-IMPL_GET_IMPL( FixedText )
-
-void FixedText::SetText( String const& rStr )
-{
-    if ( !getImpl().mxFixedText.is() )
-        return;
-    getImpl().mxFixedText->setText( rStr );
-}
-
-class FixedInfoImpl : public FixedTextImpl
-{
-public:
-    FixedInfoImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : FixedTextImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-IMPL_CONSTRUCTORS( FixedInfo, FixedText, "fixedinfo" );
-IMPL_GET_IMPL( FixedInfo );
-
-class ProgressBarImpl : public ControlImpl
-{
-public:
-    uno::Reference< awt::XProgressBar > mxProgressBar;
-    ProgressBarImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : ControlImpl( pCtx, xPeer, pWindow )
-        , mxProgressBar( xPeer, uno::UNO_QUERY )
-    {
-    }
-
-    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
-        throw (css::uno::RuntimeException)
-    {
-        mxProgressBar.clear();
-    }
-};
-
-
-class FixedImageImpl: public ControlImpl
-{
-public:
-    uno::Reference< graphic::XGraphic > mxGraphic;
-    FixedImageImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow)
-//                    const char *pName )
-        : ControlImpl( pCtx, xPeer, pWindow )
-          //, mxGraphic( layoutimpl::loadGraphic( pName ) )
-        , mxGraphic( xPeer, uno::UNO_QUERY )
-    {
-        if ( !mxGraphic.is() )
-        {
-            DBG_ERROR( "ERROR: failed to load image: `%s'" /*, pName*/ );
-        }
-#if 0
-        else
-            getImpl().mxGraphic->...();
-#endif
-    }
-};
-
-IMPL_CONSTRUCTORS( FixedImage, Control, "fixedimage" );
-IMPL_GET_IMPL( FixedImage )
-
-void FixedImage::setImage( ::Image const& i )
-{
-    (void) i;
-    if ( !getImpl().mxGraphic.is() )
-        return;
-    //FIXME: hack moved to proplist
-    //getImpl().mxGraphic = 
-}
-
-#if 0
-
-    FixedImage::FixedImage( const char *pName )
-    : pImpl( new FixedImageImpl( pName ) )
-{
-}
-
-FixedImage::~FixedImage()
-{
-    delete pImpl;
-}
-
-#endif
-
-    
-IMPL_CONSTRUCTORS( ProgressBar, Control, "ProgressBar" );
-#if 0
-ProgressBar::ProgressBar( Context *pCtx, const char *pId, sal_uInt32 nId )
-    : Control( new ProgressBarImpl( pCtx, pCtx->GetPeerHandle( pId, nId ), this ) )
-{
-}
-ProgressBar::ProgressBar( Window *pParent, WinBits nBits)
-//    : Control( new ProgressBarImpl( pParent->getContext(), Window::CreatePeer( pParent, nBits, "ProgressBar" ), this ) )
-    : Control( new ProgressBarImpl( pParent->getContext(), Window::CreatePeer( pParent, nBits, "progressbar" ), this ) )
-{
-}
-#endif
-
-IMPL_GET_IMPL( ProgressBar );
-
-
-void ProgressBar::SetForegroundColor( css::util::Color color )
-{
-    if ( !getImpl().mxProgressBar.is() )
-        return;
-    getImpl().mxProgressBar->setForegroundColor( color );
-}
-
-void ProgressBar::SetBackgroundColor( css::util::Color color )
-{
-    if ( !getImpl().mxProgressBar.is() )
-        return;
-    getImpl().mxProgressBar->setBackgroundColor( color );
-}
-
-void ProgressBar::SetValue( sal_Int32 i )
-{
-    if ( !getImpl().mxProgressBar.is() )
-        return;
-    getImpl().mxProgressBar->setValue( i );
-}
-
-void ProgressBar::SetRange( sal_Int32 min, sal_Int32 max )
-{
-    if ( !getImpl().mxProgressBar.is() )
-        return;
-    getImpl().mxProgressBar->setRange( min, max );
-}
-
-sal_Int32 ProgressBar::GetValue()
-{
-    if ( !getImpl().mxProgressBar.is() )
-        return 0;
-    return getImpl().mxProgressBar->getValue();
-}
-
-class PluginImpl: public ControlImpl
-{
-public:
-    ::Control *mpPlugin;
-
-    PluginImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow, :: Control *plugin )
-        : ControlImpl( pCtx, xPeer, pWindow )
-        , mpPlugin( plugin )
-    {
-        uno::Reference <awt::XWindow> ref( mxWindow, uno::UNO_QUERY );
-        layoutimpl::VCLXPlugin *vcl
-            = static_cast<layoutimpl::VCLXPlugin*>( VCLXWindow::GetImplementation( ref ) );
-        ::Window *parent = vcl->mpWindow->GetParent();
-        vcl->SetWindow( plugin );
-        vcl->SetPlugin( mpPlugin );
-        plugin->SetParent( parent );
-        plugin->SetStyle( vcl->mStyle );
-        plugin->SetCreatedWithToolkit( TRUE );
-        plugin->SetComponentInterface( vcl );
-        plugin->Show();
-    }
-};
-
-Plugin::Plugin( Context *pCtx, char const *pId, ::Control *plugin )
-    : Control( new PluginImpl( pCtx, pCtx->GetPeerHandle( pId, 0 ), this, plugin ) )
-    , mpPlugin( plugin )
-{
-}
-
-IMPL_GET_IMPL( Plugin );
-
-class LocalizedStringImpl : public WindowImpl
-{
-public:
-    layoutimpl::LocalizedString *mpString;
-    LocalizedStringImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : WindowImpl( pCtx, xPeer, pWindow )
-        , mpString( static_cast<layoutimpl::LocalizedString*>( VCLXWindow::GetImplementation( uno::Reference <awt::XWindow> ( mxWindow, uno::UNO_QUERY ) ) ) )
-    {
-    }
-    OUString getText()
-    {
-        if ( mpString )
-            return mpString->getText();
-        return OUString();
-    }
-    void setText( OUString const& s )
-    {
-        if ( mpString )
-            mpString->setText( s );
-    }
-};
-
-IMPL_GET_IMPL( LocalizedString );
-
-LocalizedString::LocalizedString( Context *pCtx, char const* pId )
-    : Window( new LocalizedStringImpl( pCtx, pCtx->GetPeerHandle( pId, 0 ), this ) )
-{
-}
-
-LocalizedString::operator String ()
-{
-    return getImpl().getText();
-}
-
-String LocalizedString::operator= (String const& s)
-{
-    getImpl().setText( s );
-    return getImpl().getText();
-}
-
-} // namespace layout
diff --git a/toolkit/source/vclcompat/wrapper.hxx b/toolkit/source/vclcompat/wrapper.hxx
deleted file mode 100644
index 25dbd90..0000000
--- toolkit/source/vclcompat/wrapper.hxx
+++ /dev/null
@@ -1,138 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- *
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef WRAPPER_HXX
-#define WRAPPER_HXX
-
-#include <layout/layout.hxx>
-#include <com/sun/star/uno/Reference.hxx>
-#include <com/sun/star/awt/XWindow.hpp>
-#include <com/sun/star/awt/XVclWindowPeer.hpp>
-
-#include <cstring>
-
-namespace layout
-{
-
-namespace css = com::sun::star;
-
-class WindowImpl
-{
-  public:
-    Window *mpWindow;
-    Context *mpCtx;
-    css::uno::Reference< css::awt::XWindow > mxWindow;
-    css::uno::Reference< css::awt::XVclWindowPeer > mxVclPeer;
-
-    WindowImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : mpWindow( pWindow )
-        , mpCtx( pCtx )
-        , mxWindow( xPeer, css::uno::UNO_QUERY )
-        , mxVclPeer( xPeer, css::uno::UNO_QUERY )
-    {
-    }
-
-    virtual ~WindowImpl()
-    {
-    }
-
-    void wrapperGone()
-    {
-        mpWindow = NULL;
-        mpCtx = NULL;
-        if ( mxWindow.is() )
-        {
-            css::uno::Reference< css::lang::XComponent > xComp( mxWindow, css::uno::UNO_QUERY );
-            mxWindow.clear();
-            if ( xComp.is() )
-                xComp->dispose();
-        }
-    }
-
-    css::uno::Any getProperty( const char *pName )
-    {
-        if ( !this || !mxVclPeer.is() )
-            return css::uno::Any();
-        return mxVclPeer->getProperty
-            ( rtl::OUString( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US ) );
-    }
-    void setProperty( const char *pName, css::uno::Any aAny )
-    {
-        if ( !this || !mxVclPeer.is() )
-            return;
-        mxVclPeer->setProperty
-            ( rtl::OUString( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US ), aAny );
-    }
-};
-
-class ControlImpl : public WindowImpl
-{
-  public:
-    ControlImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
-        : WindowImpl( pCtx, xPeer, pWindow )
-    {
-    }
-};
-
-inline WindowImpl &Window::getImpl() const
-{ return *(static_cast< WindowImpl * >( mpImpl )); }
-
-// Helpers for defining boiler-plate constructors ...
-// Could in-line in top-level but not with safe static_casts.
-#define IMPL_GET_IMPL(t) \
-    inline t##Impl &t::getImpl() const \
-    { \
-        return *(static_cast<t##Impl *>(mpImpl)); \
-    }
-#define IMPL_CONSTRUCTORS(t,par,unoName) \
-    t::t( Context *pCtx, const char *pId, sal_uInt32 nId ) \
-        : par( new t##Impl( pCtx, pCtx->GetPeerHandle( pId, nId ), this ) ) \
-    { \
-    } \
-    t::t( Window *pParent, WinBits nBits) \
-        : par( new t##Impl( pParent->getContext(), Window::CreatePeer( pParent, nBits, unoName ), this ) ) \
-    { \
-    }
-#define IMPL_CONSTRUCTORS_2(t,win_par,other_par,unoName) \
-    t::t( Context *pCtx, const char *pId, sal_uInt32 nId ) \
-        : win_par( new t##Impl( pCtx, pCtx->GetPeerHandle( pId, nId ), this ) ) \
-        , other_par( new other_par##Impl( Window::GetPeer() ) ) \
-    { \
-    } \
-    t::t( Window *pParent, WinBits nBits) \
-        : win_par( new t##Impl( pParent->getContext(), Window::CreatePeer( pParent, nBits, unoName ), this ) ) \
-        , other_par( new other_par##Impl( Window::GetPeer() ) ) \
-    { \
-    }
-
-} // namespace layout
-
-#endif // WRAPPER_HXX
diff --git a/toolkit/src2xml/source/boxer.py b/toolkit/src2xml/source/boxer.py
index c697ec8..1b716d7 100644
--- toolkit/src2xml/source/boxer.py
+++ toolkit/src2xml/source/boxer.py
@@ -9,11 +9,11 @@ class DlgLayoutBuilder(object):
 
     def addWidget (self, elem):
         x, y = int(elem.getAttr('x')), int(elem.getAttr('y'))
-        if self.rows.has_key(y):
-            self.rows[y][x] = elem
-        else:
-            self.rows[y] = {}
-            self.rows[y][x] = elem
+        self.rows[y] = self.rows.get (y, {})
+        while self.rows[y].has_key(x):
+            y += 1
+            self.rows[y] = self.rows.get (y, {})
+        self.rows[y][x] = elem
 
     def build (self):
         root = Element('vbox')
@@ -53,6 +53,8 @@ class Boxer(object):
 
         newnode = Element(dlgnode.name)
         newnode.clone(dlgnode)
+        if dlgnode.name == 'string':
+            return newnode
         newnode.setAttr("xmlns", "http://openoffice.org/2007/layout")
         newnode.setAttr("xmlns:cnt", "http://openoffice.org/2007/layout/container")
         mx = DlgLayoutBuilder(newnode)
diff --git a/toolkit/src2xml/source/src2xml.py b/toolkit/src2xml/source/src2xml.py
index fdcc0fb..128cfa1 100644
--- toolkit/src2xml/source/src2xml.py
+++ toolkit/src2xml/source/src2xml.py
@@ -127,7 +127,6 @@ def convert (file_name, options):
     lexer.includeDirs = options.include_path
     lexer.stopOnHeader = options.stopOnHeader
     lexer.debugMacro = options.debug_macro
-#     lexer.debug = True
     if options.debug_lexer:
         lexer.debug = True
         lexer.tokenize()
@@ -145,8 +144,8 @@ def convert (file_name, options):
     if options.debug_parser:
         parser.debug = True
         root = parser.parse()
-        print root.dump()
-        return
+        s = root.dump()
+        return s
 
     # Parse the tokens.
     root = parser.parse()
@@ -174,9 +173,11 @@ def post_process (s):
     """Make output directly usable by layout module."""
     s = re.sub ('(</?)([a-z]+)-([a-z]+)-([a-z]+)', r'\1\2\3\4', s)
     s = re.sub ('(</?)([a-z]+)-([a-z]+)', r'\1\2\3', s)
-    s = re.sub ('(<(checkbox|radiobutton|(fixed(info|text)))[^>]*) text=', r'\1 label=', s)
+    s = re.sub ('(<(checkbox|(cancel|help|ignore|ok|push|more|no|radio|reset|retry|yes)button|(fixed(info|text)))[^>]*) text=', r'\1 label=', s)
     s = re.sub (' (height|width|x|y)="[0-9]*"', '', s)
     s = re.sub (' (label|text|title)="', r' _\1="', s)
+    s = re.sub ('&([^m][^p]*[^;]*)', r'&amp;\1', s)
+    s = re.sub (' hide="(TRUE|true|1)"', ' show="false"', s)
 
     s = s.replace ('<modaldialog', '<modaldialog sizeable="true"')
     s = s.replace (' rid=', ' id=')
diff --git a/toolkit/uiconfig/layout/delzip b/toolkit/uiconfig/layout/delzip
new file mode 100644
index 0000000..7b4d68d
--- /dev/null
+++ toolkit/uiconfig/layout/delzip
@@ -0,0 +1 @@
+empty
\ No newline at end of file
diff --git a/toolkit/uiconfig/layout/makefile.mk b/toolkit/uiconfig/layout/makefile.mk
new file mode 100644
index 0000000..07a99a1
--- /dev/null
+++ toolkit/uiconfig/layout/makefile.mk
@@ -0,0 +1,62 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 51 Franklin Street, 5th Floor, Boston,
+#     MA  02110-1301  USA
+#
+#*************************************************************************
+
+PRJ=../..
+PRJNAME=toolkit
+TARGET=layout
+
+.INCLUDE : settings.mk
+
+.IF "$(ENABLE_LAYOUT)" == "TRUE"
+
+all: ALLTAR
+
+XML_FILES=\
+  message-box.xml\
+  tab-dialog.xml\
+
+#
+
+.INCLUDE : layout.mk
+
+.ELSE # ENABLE_LAYOUT != TRUE
+all .PHONY:
+.ENDIF # ENABLE_LAYOUT != TRUE
+
+.INCLUDE :  target.mk
+
+localize.sdf:
+	echo '#empty' | cat - > $@
+	rm -f *-$@
diff --git a/toolkit/uiconfig/layout/message-box.xml b/toolkit/uiconfig/layout/message-box.xml
new file mode 100644
index 0000000..6a64be1
--- /dev/null
+++ toolkit/uiconfig/layout/message-box.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This is a template.  i18n translation is not performed in-place;
+     i18n translated xml files are generated from this template by
+     transex3/layout/tralay.  !-->
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="message-box" _title="" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true" closeable="true">
+    <vbox border="5" spacing="5">
+	<hbox border="5" spacing="20">
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_ERROR" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-error.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_INFO" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-info.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_QUERY" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-query.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_WARNING" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-warning.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedtext id="FT_MESSAGE" _label="FT-LABEL" cnt:v-align="0.5" cnt:v-fill="0" />
+	    </align>
+	    <flow/>
+	</hbox>
+	<dialogbuttonhbox border="0" spacing="5">
+	    <flow/>
+	    <!-- deprecoted vcl/MsgBox compatibility !-->
+	    <retrybutton id="BTN_RETRY" />
+	    <ignorebutton id="BTN_IGNORE" />
+
+	    <yesbutton id="BTN_YES"/>
+	    <cancelbutton id="BTN_CANCEL"/>
+	    <helpbutton id="BTN_HELP"/>
+	    <nobutton id="BTN_NO" xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/toolkit/uiconfig/layout/tab-dialog.xml b/toolkit/uiconfig/layout/tab-dialog.xml
new file mode 100644
index 0000000..1d631e9
--- /dev/null
+++ toolkit/uiconfig/layout/tab-dialog.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+	xmlns:cnt="http://openoffice.org/2007/layout/container"
+	_title="layout::TabDialog" optimumsize="true"
+	id="tab-dialog"
+	has_border="true" sizeable="true" moveable="true">
+    <vbox spacing="5" border="5">
+	<tabcontrol id="ID_TABCONTROL"/>
+	<dialogbuttonhbox border="5" spacing="5" cnt:expand="false">
+	    <flow/>
+	    <okbutton id="BTN_OK" show="false"/>
+	    <pushbutton id="BTN_USER" _label="&lt;User&gt;" show="false"/>
+	    <cancelbutton id="BTN_CANCEL" show="false"/>
+	    <helpbutton id="BTN_HELP" show="false"/>
+	    <resetbutton id="BTN_RESET" show="false"/>
+	    <pushbutton id="BTN_BASEFMT" _label="&lt;Base Format&gt;" show="false"/>
+	</dialogbuttonhbox>
+    </vbox>
+</dialog>
diff --git a/toolkit/util/makefile.mk b/toolkit/util/makefile.mk
index 6bb43c4..6657ec8 100644
--- toolkit/util/makefile.mk
+++ toolkit/util/makefile.mk
@@ -54,8 +54,8 @@ LIB1FILES=	$(SLB)$/awt.lib \
 			$(SLB)$/tree.lib \
 			$(SLB)$/controls.lib \
 			$(SLB)$/helper.lib\
-			$(SLB)$/layoutcore.lib \
-			$(SLB)$/vclcompat.lib
+			$(SLB)$/layout-core.lib \
+			$(SLB)$/layout-vcl.lib
 
 SHL1TARGET= tk$(DLLPOSTFIX)
 SHL1IMPLIB= itk
diff --git a/toolkit/util/makefile.pmk b/toolkit/util/makefile.pmk
index f88a240..961a7ca 100644
--- toolkit/util/makefile.pmk
+++ toolkit/util/makefile.pmk
@@ -37,11 +37,8 @@ CFLAGS += -fvisibility=hidden
 CFLAGS += -xldscope=hidden
 .ENDIF
 
-# FIXME: sprinkle some TOOLKIT_DLLPUBLIC
+CFLAGS+=-I$(PRJ)/source
 
-CFLAGS+=-I$(PRJ)/inc/layout
 .IF "$(ENABLE_LAYOUT)" == "TRUE"
-CFLAGS+=-DENABLE_LAYOUT=1 -DTEST_LAYOUT=1
-.ELSE
-CFLAGS+=-DENABLE_LAYOUT=0
+CFLAGS+=-DTEST_LAYOUT=1
 .ENDIF # ENABLE_LAYOUT == TRUE
diff --git a/toolkit/workben/layout/.gitignore b/toolkit/workben/layout/.gitignore
index 9b72951..142ba57 100644
--- toolkit/workben/layout/.gitignore
+++ toolkit/workben/layout/.gitignore
@@ -1,3 +1,4 @@
 /de
 /en-US
 /nl
+/ja
\ No newline at end of file
diff --git a/toolkit/workben/layout/TEST b/toolkit/workben/layout/TEST
new file mode 100755
index 0000000..d6a20cb
--- /dev/null
+++ toolkit/workben/layout/TEST
@@ -0,0 +1,3 @@
+export OOO_INSTALL_PREFIX=$(cd ../../../../.. && pwd)/ooo-svn
+test -d $OOO_INSTALL_PREFIX/openoffice.org3 && export OOO_PREFIX_BRAND=$OOO_INSTALL_PREFIX/openoffice.org3 || export OOO_PREFIX_BRAND=$OOO_INSTALL_PREFIX
+LD_LIBRARY_PATH=$OOO_PREFIX_BRAND/basis-link/program:$OOO_PREFIX_BRAND/basis-link/ure-link/lib ../../unxlngx6.pro/bin/test "$@"
diff --git a/toolkit/workben/layout/editor.cxx b/toolkit/workben/layout/editor.cxx
index 402c9e8..b5e5d76 100644
--- toolkit/workben/layout/editor.cxx
+++ toolkit/workben/layout/editor.cxx
@@ -57,10 +57,9 @@ using rtl::OUString;
 // FIXME:
 //#define FILEDLG
 
-// somewhat of a hack unfortunately ...
-#include "layout/layoutcore.hxx"
-#include "root.hxx"
-#include "helper.hxx"
+#include <layout/core/helper.hxx>
+#include <layout/core/root.hxx>
+#include <layout/core/helper.hxx>
 
 // TODO: automatically generated
 struct WidgetSpec {
@@ -86,19 +85,6 @@ static const WidgetSpec WIDGETS_SPECS[] = {
 };
 const int WIDGETS_SPECS_LEN = sizeof (WIDGETS_SPECS) / sizeof (WidgetSpec);
 
-// TEMP: from helper
-namespace layoutimpl {
-
-    typedef std::list< std::pair< rtl::OUString, rtl::OUString > > PropList;
-
-    css::uno::Reference< css::awt::XLayoutConstrains >
-        createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
-                      css::uno::Reference< css::uno::XInterface > xParent,
-                      const rtl::OUString &rName, long nProps, bool bToplevel );
-
-    uno::Any anyFromString (const rtl::OUString &value, const uno::Type &type);
-}
-
 using namespace layout;
 using namespace layoutimpl;
 namespace css = ::com::sun::star;
@@ -128,9 +114,9 @@ static rtl::OUString anyToString (uno::Any value)
                 bool val = value.get<sal_Bool>();
                 return rtl::OUString( val ? "1" : "0", 1, RTL_TEXTENCODING_ASCII_US );
 /*                if ( val )
-                    return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
-                else
-                    return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) );*/
+                  return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
+                  else
+                  return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) );*/
             }
             default:
                 break;
@@ -147,8 +133,9 @@ static inline double anyToDecimal (uno::Any value)
 
 /* XLayoutContainer/XLayoutConstrains are a bit of a hasle to work with.
    Let's wrap them. */
-class Widget : public layoutimpl::LayoutWidget {
-friend class EditorRoot;
+class Widget : public layoutimpl::LayoutWidget
+{
+    friend class EditorRoot;
 
     Widget *mpParent;
     std::vector< Widget *> maChildren;
@@ -165,7 +152,7 @@ public:
 
     // to be used to wrap the root
     Widget( uno::Reference< awt::XLayoutConstrains > xImport, const char *label )
-    : mpParent( 0 ), mbForeign( true )
+        : mpParent( 0 ), mbForeign( true )
     {
         mxWidget = xImport;
         mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
@@ -189,20 +176,20 @@ public:
     Widget( rtl::OUString id, uno::Reference< awt::XToolkit > xToolkit,
             uno::Reference< awt::XLayoutContainer > xParent,
             rtl::OUString unoName, long nAttrbs )
-    : mpParent( 0 ), mbForeign( false ), mrId( id ),
-      mnOriAttrbs( nAttrbs )
-    {
-    while ( xParent.is() && !uno::Reference< awt::XWindow >( xParent, uno::UNO_QUERY ).is() )
+        : mpParent( 0 ), mbForeign( false ), mrId( id ),
+          mnOriAttrbs( nAttrbs )
     {
-        uno::Reference< awt::XLayoutContainer > xContainer( xParent, uno::UNO_QUERY );
-        assert( xContainer.is() );
-        xParent = uno::Reference< awt::XLayoutContainer >( xContainer->getParent(), uno::UNO_QUERY );
-    }
-
-        mxWidget = layoutimpl::createWidget( xToolkit, xParent, unoName, nAttrbs );
+        while ( xParent.is() && !uno::Reference< awt::XWindow >( xParent, uno::UNO_QUERY ).is() )
+        {
+            uno::Reference< awt::XLayoutContainer > xContainer( xParent, uno::UNO_QUERY );
+            assert( xContainer.is() );
+            xParent = uno::Reference< awt::XLayoutContainer >( xContainer->getParent(), uno::UNO_QUERY );
+        }
+        
+        mxWidget = WidgetFactory::createWidget( xToolkit, xParent, unoName, nAttrbs );
         assert( mxWidget.is() );
         mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
-
+        
         mrLabel = mrUnoName = unoName;
         // try to get a nicer label for the widget
         for ( int i = 0; i < WIDGETS_SPECS_LEN; i++ )
@@ -212,21 +199,21 @@ public:
                 mrLabel = rtl::OUString( label, strlen( label ), RTL_TEXTENCODING_UTF8  );
                 break;
             }
-
+        
         // set default Text property
         // TODO: disable editing of text fields, check boxes selected, etc...
 #if 0
         uno::Reference< awt::XVclWindowPeer> xVclPeer( mxWidget, uno::UNO_QUERY )
-        if ( xVclPeer.is() ) // XVclWindowPeer ignores missing / incorrect properties 
+            if ( xVclPeer.is() ) // XVclWindowPeer ignores missing / incorrect properties 
 
 //FIXME: it looks odd on widgets like NumericField seeing text which is deleted
 // when you interact with it... We can avoid it for those widgets, by doing a getProp
 // of "Text" and check if it is empty or not.
-
-            xVclPeer->setProperty( rtl::OUString::createFromAscii( "Text" ),
-                uno::makeAny( rtl::OUString::createFromAscii( "new widget" ) ) );
+            
+                xVclPeer->setProperty( rtl::OUString::createFromAscii( "Text" ),
+                                       uno::makeAny( rtl::OUString::createFromAscii( "new widget" ) ) );
 #endif
-
+        
         // store original properties
         {
             PropertyIterator it( this, WINDOW_PROPERTY );
@@ -236,19 +223,19 @@ public:
                 rtl::OUString name( prop.Name );
                 rtl::OUString value( getProperty( name, WINDOW_PROPERTY ) );
 #if DEBUG_PRINT
-fprintf(stderr, "original property: %s = %s\n", OUSTRING_CSTR(name), OUSTRING_CSTR(value));
+                fprintf(stderr, "original property: %s = %s\n", OUSTRING_CSTR(name), OUSTRING_CSTR(value));
 #endif
                 std::pair< rtl::OUString, rtl::OUString > pair( name, value );
                 maOriProps.push_back( pair );
             }
         }
-
+        
     }
-
+    
     ~Widget()
     {
         for ( std::vector< Widget *>::const_iterator it = maChildren.begin();
-             it != maChildren.end(); it++ )
+              it != maChildren.end(); it++ )
             delete *it;
         if ( !mbForeign )
         {
@@ -394,18 +381,18 @@ fprintf(stderr, "original property: %s = %s\n", OUSTRING_CSTR(name), OUSTRING_CS
         std::vector< Widget *> aChildChildren = pChild->maChildren;
 
         for ( std::vector< Widget *>::const_iterator it = aChildChildren.begin();
-             it != aChildChildren.end(); it++ )
+              it != aChildChildren.end(); it++ )
             pChild->removeChild( *it );
 
         for ( std::vector< Widget *>::const_iterator it = aChildChildren.begin();
-             it != aChildChildren.end(); it++ )
+              it != aChildChildren.end(); it++ )
             if ( !addChild( *it ) )
             {    // failure
                 for ( std::vector< Widget *>::const_iterator jt = aChildChildren.begin();
-                     jt != it; jt++ )
+                      jt != it; jt++ )
                     removeChild( *jt );
                 for ( std::vector< Widget *>::const_iterator jt = aChildChildren.begin();
-                     jt != aChildChildren.end(); jt++ )
+                      jt != aChildChildren.end(); jt++ )
                     pChild->addChild( *jt );
                 return false;
             }
@@ -425,7 +412,7 @@ fprintf(stderr, "original property: %s = %s\n", OUSTRING_CSTR(name), OUSTRING_CS
     {
         int i = 0;
         for ( std::vector< Widget *>::const_iterator it = maChildren.begin();
-             it != maChildren.end(); it++, i++ )
+              it != maChildren.end(); it++, i++ )
             if ( *it == pChild )
                 break;
         return i;
@@ -466,7 +453,7 @@ fprintf(stderr, "original property: %s = %s\n", OUSTRING_CSTR(name), OUSTRING_CS
             if ( it->first.equalsIgnoreAsciiCase( propName ) )
                 return it->second;
 #if DEBUG_PRINT
-fprintf(stderr, "Serious error: property '%s' not found\n", OUSTRING_CSTR(propName));
+        fprintf(stderr, "Serious error: property '%s' not found\n", OUSTRING_CSTR(propName));
 #endif
         return rtl::OUString();
     }
@@ -499,7 +486,7 @@ fprintf(stderr, "Serious error: property '%s' not found\n", OUSTRING_CSTR(propNa
             case CONTAINER_PROPERTY:
                 if ( mpParent )
                     rValue = anyToString( layoutimpl::prophlp::getProperty(
-                        mpParent->mxContainer->getChildProperties( mxWidget ), rPropName ) );
+                                              mpParent->mxContainer->getChildProperties( mxWidget ), rPropName ) );
                 break;
             case WINBITS_PROPERTY:
                 // TODO
@@ -515,7 +502,7 @@ fprintf(stderr, "Serious error: property '%s' not found\n", OUSTRING_CSTR(propNa
         rtl::OUString newValue = getProperty( propName, rKind );
         bool isTouched = oriValue != newValue;
 #if DEBUG_PRINT
-fprintf(stderr, "is property '%s' touched? %s  (%s vs %s)\n", OUSTRING_CSTR(propName), isTouched ? "yes" : "no", OUSTRING_CSTR(oriValue), OUSTRING_CSTR(newValue));
+        fprintf(stderr, "is property '%s' touched? %s  (%s vs %s)\n", OUSTRING_CSTR(propName), isTouched ? "yes" : "no", OUSTRING_CSTR(oriValue), OUSTRING_CSTR(newValue));
 #endif
         return isTouched;
     }
@@ -546,7 +533,7 @@ fprintf(stderr, "is property '%s' touched? %s  (%s vs %s)\n", OUSTRING_CSTR(prop
         int nPropIt;
 
         PropertyIterator( Widget *pWidget, PropertyKind rKind )
-        : mrKind( rKind ), nPropIt( 0 )
+            : mrKind( rKind ), nPropIt( 0 )
         {
             switch ( rKind )
             {
@@ -588,10 +575,10 @@ fprintf(stderr, "is property '%s' touched? %s  (%s vs %s)\n", OUSTRING_CSTR(prop
         beans::Property next()
         {
 /*            rtl::OUString propName, propValue;
-            propName = maProps[ nPropIt ];
-            propValue = getProperty( propName, mrKind, false);
-            nPropIt++;
-            return std::pair< rtl::OUString, rtl::OUString > propPair( propName, propValue );*/
+              propName = maProps[ nPropIt ];
+              propValue = getProperty( propName, mrKind, false);
+              nPropIt++;
+              return std::pair< rtl::OUString, rtl::OUString > propPair( propName, propValue );*/
             return maProps[ nPropIt++ ];
         }
     };
@@ -603,13 +590,13 @@ class EditorRoot : public layoutimpl::LayoutRoot {
 public:
     EditorRoot( const uno::Reference< lang::XMultiServiceFactory >& xFactory,
                 Widget *pParent )
-    : layoutimpl::LayoutRoot( xFactory ), mpParent( pParent )
+        : layoutimpl::LayoutRoot( xFactory ), mpParent( pParent )
     {
     }
 
     // generation
     virtual layoutimpl::LayoutWidget *create( rtl::OUString id, const rtl::OUString unoName,
-        long attrbs, uno::Reference< awt::XLayoutContainer > xParent )
+                                              long attrbs, uno::Reference< awt::XLayoutContainer > xParent )
     {
         if ( unoName.compareToAscii( "dialog" ) == 0 )
             return mpParent;
@@ -629,126 +616,126 @@ public:
 /* Working with the layout in 1D, as if it was a flat list. */
 namespace FlatLayout
 {
-    Widget *next( Widget *pWidget )
-    {
-        Widget *pNext;
-        pNext = pWidget->down();
-        if ( pNext ) return pNext;
-        pNext = pWidget->next();
-        if ( pNext ) return pNext;
-        for ( Widget *pUp = pWidget->up(); pUp != NULL; pUp = pUp->up() )
-            if ( (pNext = pUp->next()) != NULL )
-                return pNext;
-        return NULL;
-    }
+Widget *next( Widget *pWidget )
+{
+    Widget *pNext;
+    pNext = pWidget->down();
+    if ( pNext ) return pNext;
+    pNext = pWidget->next();
+    if ( pNext ) return pNext;
+    for ( Widget *pUp = pWidget->up(); pUp != NULL; pUp = pUp->up() )
+        if ( (pNext = pUp->next()) != NULL )
+            return pNext;
+    return NULL;
+}
 
 /*
-    Widget *prev( Widget *pWidget )
-    {
-        Widget *pPrev;
-        pPrev = pWidget->prev();
-        if ( !pPrev )
-            return pWidget->up();
-
-        Widget *pBottom = pPrev->down();
-        if ( pBottom )
-        {
-            while ( pBottom->down() || pBottom->next() )
-            {
-                for ( Widget *pNext = pBottom->next(); pNext; pNext = pNext->next() )
-                    pBottom = pNext;
-                Widget *pDown = pBottom->down();
-                if ( pDown )
-                    pBottom = pDown;
-            }
-            return pBottom;
-        }
-        return pPrev;
-    }
+  Widget *prev( Widget *pWidget )
+  {
+  Widget *pPrev;
+  pPrev = pWidget->prev();
+  if ( !pPrev )
+  return pWidget->up();
+
+  Widget *pBottom = pPrev->down();
+  if ( pBottom )
+  {
+  while ( pBottom->down() || pBottom->next() )
+  {
+  for ( Widget *pNext = pBottom->next(); pNext; pNext = pNext->next() )
+  pBottom = pNext;
+  Widget *pDown = pBottom->down();
+  if ( pDown )
+  pBottom = pDown;
+  }
+  return pBottom;
+  }
+  return pPrev;
+  }
 */
 
-    bool moveWidget( Widget *pWidget, bool up /*or down*/ )
-    {
-        // Keep child parent&pos for in case of failure
-        Widget *pOriContainer = pWidget->up();
-        unsigned int oriChildPos = pOriContainer->getChildPos( pWidget );
-
-        // Get parent&sibling before removing it, since relations get cut
-        Widget *pSibling = up ? pWidget->prev() : pWidget->next();
-        Widget *pContainer = pWidget->up();
-        if ( !pContainer )
-            return false;
+bool moveWidget( Widget *pWidget, bool up /*or down*/ )
+{
+    // Keep child parent&pos for in case of failure
+    Widget *pOriContainer = pWidget->up();
+    unsigned int oriChildPos = pOriContainer->getChildPos( pWidget );
+
+    // Get parent&sibling before removing it, since relations get cut
+    Widget *pSibling = up ? pWidget->prev() : pWidget->next();
+    Widget *pContainer = pWidget->up();
+    if ( !pContainer )
+        return false;
 
-        // try to swap with parent or child
-        // We need to allow for this at least for the root node...
-        if ( !pSibling )
+    // try to swap with parent or child
+    // We need to allow for this at least for the root node...
+    if ( !pSibling )
+    {
+        if ( up )
+        {
+            if ( pContainer->swapWithChild( pWidget ) )
+                return true;
+        }
+        else
         {
-            if ( up )
-            {
-                if ( pContainer->swapWithChild( pWidget ) )
-                    return true;
-            }
-            else
-            {
 // TODO: this is a nice feature, but we probably want to do it explicitely...
 #if 0
-                if ( pWidget->down() && pWidget->swapWithChild( pWidget->down() ) )
-                    return true;
+            if ( pWidget->down() && pWidget->swapWithChild( pWidget->down() ) )
+                return true;
 #endif
-            }
         }
+    }
 
-        pContainer->removeChild( pWidget );
+    pContainer->removeChild( pWidget );
 
-        // if has up sibling -- append to it, else swap with it
-        if ( pSibling )
-        {
-            if ( pSibling->addChild( pWidget, up ? 0xffff : 0 ) )
-                return true;
-
-            unsigned int childPos = pContainer->getChildPos( pSibling );
-            if ( pContainer->addChild( pWidget, childPos + (up ? 0 : 1) ) )
-                return true;  // should always be succesful
-        }
-        // go through parents -- try to get prepended to them
-        else
-        {
-            for ( ; pContainer && pContainer->up(); pContainer = pContainer->up() )
-            {
-                unsigned int childPos = pContainer->up()->getChildPos( pContainer );
-                if ( pContainer->up()->addChild( pWidget, childPos + (up ? 0 : 1) ) )
-                    return true;
-            }
-        }
+    // if has up sibling -- append to it, else swap with it
+    if ( pSibling )
+    {
+        if ( pSibling->addChild( pWidget, up ? 0xffff : 0 ) )
+            return true;
 
-        // failed -- try to get it to its old position
-        if ( !pOriContainer->addChild( pWidget, oriChildPos ) )
+        unsigned int childPos = pContainer->getChildPos( pSibling );
+        if ( pContainer->addChild( pWidget, childPos + (up ? 0 : 1) ) )
+            return true;  // should always be succesful
+    }
+    // go through parents -- try to get prepended to them
+    else
+    {
+        for ( ; pContainer && pContainer->up(); pContainer = pContainer->up() )
         {
-            // a parent should never reject a child back. but if it ever
-            // happens, just kill it, we don't run an orphanate here ;P
-            delete pWidget;
-            return true;
+            unsigned int childPos = pContainer->up()->getChildPos( pContainer );
+            if ( pContainer->up()->addChild( pWidget, childPos + (up ? 0 : 1) ) )
+                return true;
         }
-        return false;
     }
 
-    // NOTE: root is considered to be number -1
-    Widget *get( Widget *pRoot, int nb )
+    // failed -- try to get it to its old position
+    if ( !pOriContainer->addChild( pWidget, oriChildPos ) )
     {
-        Widget *it;
-        for ( it = pRoot; it != NULL && nb >= 0; it = next( it ) )
-            nb--;
-        return it;
+        // a parent should never reject a child back. but if it ever
+        // happens, just kill it, we don't run an orphanate here ;P
+        delete pWidget;
+        return true;
     }
+    return false;
+}
 
-    int get( Widget *pRoot, Widget *pWidget )
-    {
-        int nRet = -1;
-        Widget *it;
-        for ( it = pRoot; it != NULL && it != pWidget; it = next( it ) )
-            nRet++;
-        return nRet;
-    }
+// NOTE: root is considered to be number -1
+Widget *get( Widget *pRoot, int nb )
+{
+    Widget *it;
+    for ( it = pRoot; it != NULL && nb >= 0; it = next( it ) )
+        nb--;
+    return it;
+}
+
+int get( Widget *pRoot, Widget *pWidget )
+{
+    int nRet = -1;
+    Widget *it;
+    for ( it = pRoot; it != NULL && it != pWidget; it = next( it ) )
+        nRet++;
+    return nRet;
+}
 }
 
 //** PropertiesList widget
@@ -766,7 +753,7 @@ class PropertiesList : public layout::Table
             DECL_LINK( FlagToggledHdl, layout::CheckBox* );
 
             AnyWidget( Widget *pWidget, rtl::OUString aPropName, Widget::PropertyKind aPropKind )
-            : mpWidget( pWidget ), maPropName( aPropName ), maPropKind( aPropKind )
+                : mpWidget( pWidget ), maPropName( aPropName ), maPropKind( aPropKind )
             {
                 mpFlag = 0;
                 mbBlockFlagCallback = false;
@@ -786,15 +773,15 @@ class PropertiesList : public layout::Table
                 checkProperty();
             }
 
-void checkProperty()
-{
+            void checkProperty()
+            {
                 bool flag = mpWidget->isPropertyTouched( maPropName, maPropKind );
 
                 if ( mpFlag && mpFlag->IsChecked() != (BOOL)flag )
                 {
                     CheckFlag( flag, true );
                 }
-}
+            }
 
             void CheckFlag( bool bValue, bool bBlockCallback )
             {
@@ -844,7 +831,7 @@ void checkProperty()
 
             AnyEdit( Widget *pWidget, rtl::OUString aPropName,
                      Widget::PropertyKind aPropKind, layout::Window *pWinParent )
-            : AnyWidget( pWidget, aPropName, aPropKind ), layout::HBox( 0, false ), mpWinParent( pWinParent )
+                : AnyWidget( pWidget, aPropName, aPropKind ), layout::HBox( 0, false ), mpWinParent( pWinParent )
             {
                 mpEdit = NULL;
                 mpExpand = new layout::PushButton( pWinParent, WB_TOGGLE );
@@ -872,7 +859,7 @@ void checkProperty()
                 if ( mpEdit )
                 {
                     text = mpEdit->GetText();
-printf("Remove mpEdit and expand\n");
+                    printf("Remove mpEdit and expand\n");
                     Remove( mpEdit );
                     Remove( mpExpand );
                     delete mpEdit;
@@ -966,7 +953,7 @@ printf("Remove mpEdit and expand\n");
         {
             AnyInteger( Widget *pWidget, rtl::OUString aPropName,
                         Widget::PropertyKind aPropKind, Window *pWinParent )
-            : AnyWidget( pWidget, aPropName, aPropKind ), NumericField( pWinParent, WB_SPIN|WB_BORDER )
+                : AnyWidget( pWidget, aPropName, aPropKind ), NumericField( pWinParent, WB_SPIN|WB_BORDER )
             {
                 load();
                 SetModifyHdl( LINK( this, AnyInteger, ApplyPropertyHdl ) );
@@ -985,7 +972,7 @@ printf("Remove mpEdit and expand\n");
             virtual void store()
             {
 #if DEBUG_PRINT
-fprintf(stderr, "store number: %ld\n", rtl::OUString( GetText() ).toInt64());
+                fprintf(stderr, "store number: %ld\n", rtl::OUString( GetText() ).toInt64());
 #endif
                 save( uno::makeAny( rtl::OUString( GetText() ).toInt64() ) );
             }
@@ -995,7 +982,7 @@ fprintf(stderr, "store number: %ld\n", rtl::OUString( GetText() ).toInt64());
         {
             AnyFloat( Widget *pWidget, rtl::OUString aPropName,
                       Widget::PropertyKind aPropKind, Window *pWinParent )
-            : AnyInteger( pWidget, aPropName, aPropKind, pWinParent )
+                : AnyInteger( pWidget, aPropName, aPropKind, pWinParent )
             {}
 
             virtual void store()
@@ -1008,7 +995,7 @@ fprintf(stderr, "store number: %ld\n", rtl::OUString( GetText() ).toInt64());
         {
             AnyCheckBox( Widget *pWidget, rtl::OUString aPropName,
                          Widget::PropertyKind aPropKind, layout::Window *pWinParent )
-            : AnyWidget( pWidget, aPropName, aPropKind ), layout::CheckBox( pWinParent )
+                : AnyWidget( pWidget, aPropName, aPropKind ), layout::CheckBox( pWinParent )
             {
                 // adding some whitespaces to make the hit area larger
 //                SetText( String::CreateFromAscii( "" ) );
@@ -1029,7 +1016,7 @@ fprintf(stderr, "store number: %ld\n", rtl::OUString( GetText() ).toInt64());
             virtual void load()
             {
 #if DEBUG_PRINT
-fprintf(stderr, "loading boolean value\n");
+                fprintf(stderr, "loading boolean value\n");
 #endif
                 Check( getValue().toInt64() != 0 );
                 setLabel();
@@ -1052,7 +1039,7 @@ fprintf(stderr, "loading boolean value\n");
         {
             AnyListBox( Widget *pWidget, rtl::OUString aPropName,
                         Widget::PropertyKind aPropKind, Window *pWinParent )
-            : AnyWidget( pWidget, aPropName, aPropKind ), layout::ListBox( pWinParent, WB_DROPDOWN )
+                : AnyWidget( pWidget, aPropName, aPropKind ), layout::ListBox( pWinParent, WB_DROPDOWN )
             {
                 SetSelectHdl( LINK( this, AnyWidget, ApplyPropertyHdl ) );
             }
@@ -1076,7 +1063,7 @@ fprintf(stderr, "loading boolean value\n");
         {
             AnyAlign( Widget *pWidget, rtl::OUString aPropName,
                       Widget::PropertyKind aPropKind, Window *pWinParent )
-            : AnyListBox( pWidget, aPropName, aPropKind, pWinParent )
+                : AnyListBox( pWidget, aPropName, aPropKind, pWinParent )
             {
                 InsertEntry( XubString::CreateFromAscii( "Left" ) );
                 InsertEntry( XubString::CreateFromAscii( "Center" ) );
@@ -1092,7 +1079,7 @@ fprintf(stderr, "loading boolean value\n");
         {
             AnyComboBox( Widget *pWidget, rtl::OUString aPropName,
                          Widget::PropertyKind aPropKind, Window *pWinParent )
-            : AnyWidget( pWidget, aPropName, aPropKind ), layout::ComboBox( pWinParent, WB_DROPDOWN )
+                : AnyWidget( pWidget, aPropName, aPropKind ), layout::ComboBox( pWinParent, WB_DROPDOWN )
             {
                 SetModifyHdl( LINK( this, AnyComboBox, ApplyPropertyHdl ) );
             }
@@ -1116,7 +1103,7 @@ fprintf(stderr, "loading boolean value\n");
         {
             AnyFontStyle( Widget *pWidget, rtl::OUString aPropName,
                           Widget::PropertyKind aPropKind, Window *pWinParent )
-            : AnyComboBox( pWidget, aPropName, aPropKind, pWinParent )
+                : AnyComboBox( pWidget, aPropName, aPropKind, pWinParent )
             {
                 InsertEntry( XubString::CreateFromAscii( "Bold" ) );
                 InsertEntry( XubString::CreateFromAscii( "Italic" ) );
@@ -1130,71 +1117,71 @@ fprintf(stderr, "loading boolean value\n");
         layout::CheckBox *mpFlag;
         AnyWidget *mpValue;
 
-        public:
-            PropertyEntry( layout::Window *pWinParent, AnyWidget *pAnyWidget )
+    public:
+        PropertyEntry( layout::Window *pWinParent, AnyWidget *pAnyWidget )
+        {
+            mpLabel = new layout::FixedText( pWinParent );
             {
-                mpLabel = new layout::FixedText( pWinParent );
-                {
-                    // append ':' to aPropName
-                    rtl::OUStringBuffer buf( pAnyWidget->maPropName );
-                    buf.append( sal_Unicode (':') );
-                    mpLabel->SetText( buf.makeStringAndClear() );
-                }
-                mpValue = pAnyWidget;
-                mpFlag = new layout::CheckBox( pWinParent );
-                mpFlag->SetToggleHdl( LINK( mpValue, AnyWidget, FlagToggledHdl ) );
-                mpValue->mpFlag = mpFlag;
+                // append ':' to aPropName
+                rtl::OUStringBuffer buf( pAnyWidget->maPropName );
+                buf.append( sal_Unicode (':') );
+                mpLabel->SetText( buf.makeStringAndClear() );
             }
+            mpValue = pAnyWidget;
+            mpFlag = new layout::CheckBox( pWinParent );
+            mpFlag->SetToggleHdl( LINK( mpValue, AnyWidget, FlagToggledHdl ) );
+            mpValue->mpFlag = mpFlag;
+        }
 
-            ~PropertyEntry()
-            {
+        ~PropertyEntry()
+        {
 #if DEBUG_PRINT
             fprintf(stderr, "REMOVING label, flag and value\n");
 #endif
-                delete mpLabel;
-                delete mpFlag;
-                delete mpValue;
-            }
+            delete mpLabel;
+            delete mpFlag;
+            delete mpValue;
+        }
 
-            // Use this factory rather than the constructor -- check for NULL
-            static PropertyEntry *construct( Widget *pWidget, rtl::OUString aPropName,
-                                             Widget::PropertyKind aPropKind, sal_uInt16 nType,
-                                             layout::Window *pWinParent )
-            {
-                AnyWidget *pAnyWidget;
-                switch (nType) {
-                    case uno::TypeClass_STRING:
-                        if ( aPropName.compareToAscii( "FontStyleName" ) == 0 )
-                        {
-                            pAnyWidget = new AnyFontStyle( pWidget, aPropName, aPropKind, pWinParent );
-                            break;
-                        }
-                        pAnyWidget = new AnyEdit( pWidget, aPropName, aPropKind, pWinParent );
-                        break;
-                    case uno::TypeClass_SHORT:
-                        if ( aPropName.compareToAscii( "Align" ) == 0 )
-                        {
-                            pAnyWidget = new AnyAlign( pWidget, aPropName, aPropKind, pWinParent );
-                            break;
-                        }
-                        // otherwise, treat as any other number...
-                    case uno::TypeClass_LONG:
-                    case uno::TypeClass_UNSIGNED_LONG:
-                        pAnyWidget = new AnyInteger( pWidget, aPropName, aPropKind, pWinParent );
-                        break;
-                    case uno::TypeClass_FLOAT:
-                    case uno::TypeClass_DOUBLE:
-                        pAnyWidget = new AnyFloat( pWidget, aPropName, aPropKind, pWinParent );
+        // Use this factory rather than the constructor -- check for NULL
+        static PropertyEntry *construct( Widget *pWidget, rtl::OUString aPropName,
+                                         Widget::PropertyKind aPropKind, sal_uInt16 nType,
+                                         layout::Window *pWinParent )
+        {
+            AnyWidget *pAnyWidget;
+            switch (nType) {
+                case uno::TypeClass_STRING:
+                    if ( aPropName.compareToAscii( "FontStyleName" ) == 0 )
+                    {
+                        pAnyWidget = new AnyFontStyle( pWidget, aPropName, aPropKind, pWinParent );
                         break;
-                    case uno::TypeClass_BOOLEAN:
-                        pAnyWidget = new AnyCheckBox( pWidget, aPropName, aPropKind, pWinParent );
+                    }
+                    pAnyWidget = new AnyEdit( pWidget, aPropName, aPropKind, pWinParent );
+                    break;
+                case uno::TypeClass_SHORT:
+                    if ( aPropName.compareToAscii( "Align" ) == 0 )
+                    {
+                        pAnyWidget = new AnyAlign( pWidget, aPropName, aPropKind, pWinParent );
                         break;
-                    default:
-                        return NULL;
-                }
-                return new PropertyEntry( pWinParent, pAnyWidget );
+                    }
+                    // otherwise, treat as any other number...
+                case uno::TypeClass_LONG:
+                case uno::TypeClass_UNSIGNED_LONG:
+                    pAnyWidget = new AnyInteger( pWidget, aPropName, aPropKind, pWinParent );
+                    break;
+                case uno::TypeClass_FLOAT:
+                case uno::TypeClass_DOUBLE:
+                    pAnyWidget = new AnyFloat( pWidget, aPropName, aPropKind, pWinParent );
+                    break;
+                case uno::TypeClass_BOOLEAN:
+                    pAnyWidget = new AnyCheckBox( pWidget, aPropName, aPropKind, pWinParent );
+                    break;
+                default:
+                    return NULL;
             }
-        };
+            return new PropertyEntry( pWinParent, pAnyWidget );
+        }
+    };
 
     layout::Window *mpParentWindow;
 
@@ -1241,12 +1228,12 @@ fprintf(stderr, "loading boolean value\n");
                 return true;
         } while ( min <= max );
         return false;
-   }
+    }
 
 public:
     PropertiesList( layout::Dialog *dialog )
-    : layout::Table( dialog, "properties-box" )
-    , mpParentWindow( dialog ), mpSeparator( 0 )
+        : layout::Table( dialog, "properties-box" )
+        , mpParentWindow( dialog ), mpSeparator( 0 )
     {
     }
 
@@ -1308,7 +1295,7 @@ public:
         Container::Clear();        
 
         for ( std::list< PropertyEntry* >::iterator it = maPropertiesList.begin();
-             it != maPropertiesList.end(); it++)
+              it != maPropertiesList.end(); it++)
             delete *it;
         maPropertiesList.clear();
 
@@ -1327,22 +1314,22 @@ IMPL_LINK( PropertiesList::PropertyEntry::AnyWidget, ApplyPropertyHdl, layout::W
 IMPL_LINK( PropertiesList::PropertyEntry::AnyWidget, FlagToggledHdl, layout::CheckBox *, pCheck )
 {
 #if DEBUG_PRINT
-fprintf(stderr, "Property flag pressed -- is: %d\n", pCheck->IsChecked());
+    fprintf(stderr, "Property flag pressed -- is: %d\n", pCheck->IsChecked());
 #endif
     if ( !mbBlockFlagCallback )
     {
         bool checked = pCheck->IsChecked();
         if ( !checked )  // revert
-{
+        {
 #if DEBUG_PRINT
-fprintf(stderr, "revert\n");
+            fprintf(stderr, "revert\n");
 #endif
             load();
-}
+        }
         else
         {
 #if DEBUG_PRINT
-fprintf(stderr, "user can't dirty the flag!\n");
+            fprintf(stderr, "user can't dirty the flag!\n");
 #endif
             // User can't flag the property as dirty
             // Actually, we may want to allow the designer to force a property to be stored.
@@ -1351,8 +1338,8 @@ fprintf(stderr, "user can't dirty the flag!\n");
         }
     }
 #if DEBUG_PRINT
-else
-fprintf(stderr, "Property flag pressed -- BLOCKED\n");
+    else
+        fprintf(stderr, "Property flag pressed -- BLOCKED\n");
 #endif
     return 0;
 }
@@ -1368,14 +1355,14 @@ IMPL_LINK( PropertiesList::PropertyEntry::AnyEdit, ExpandEditHdl, layout::PushBu
 class SortListBox
 {        // For a manual sort ListBox; asks for a ListBox and Up/Down/Remove
          // buttons to wrap
-DECL_LINK( ItemSelectedHdl, layout::ListBox* );
-DECL_LINK( UpPressedHdl, layout::Button* );
-DECL_LINK( DownPressedHdl, layout::Button* );
-DECL_LINK( RemovePressedHdl, layout::Button* );
-layout::PushButton *mpUpButton, *mpDownButton, *mpRemoveButton;
+    DECL_LINK( ItemSelectedHdl, layout::ListBox* );
+    DECL_LINK( UpPressedHdl, layout::Button* );
+    DECL_LINK( DownPressedHdl, layout::Button* );
+    DECL_LINK( RemovePressedHdl, layout::Button* );
+    layout::PushButton *mpUpButton, *mpDownButton, *mpRemoveButton;
 
 protected:
-layout::ListBox *mpListBox;
+    layout::ListBox *mpListBox;
 
     virtual void upPressed( USHORT nPos )
     {
@@ -1421,8 +1408,8 @@ layout::ListBox *mpListBox;
 public:
     SortListBox( layout::ListBox *pListBox, layout::PushButton *pUpButton, layout::PushButton *pDownButton,
                  layout::PushButton *pRemoveButton )
-    : mpUpButton( pUpButton), mpDownButton( pDownButton), mpRemoveButton( pRemoveButton ),
-      mpListBox( pListBox )
+        : mpUpButton( pUpButton), mpDownButton( pDownButton), mpRemoveButton( pRemoveButton ),
+          mpListBox( pListBox )
     {
         mpListBox->SetSelectHdl( LINK( this, SortListBox, ItemSelectedHdl ) );
 
@@ -1447,12 +1434,12 @@ public:
 };
 
 SortListBox::~SortListBox()
-    {
-        delete mpListBox;
-        delete mpUpButton;
-        delete mpDownButton;
-        delete mpRemoveButton;
-    }
+{
+    delete mpListBox;
+    delete mpUpButton;
+    delete mpDownButton;
+    delete mpRemoveButton;
+}
 
 IMPL_LINK( SortListBox, UpPressedHdl, layout::Button *, pBtn )
 {
@@ -1506,10 +1493,10 @@ public:
     Widget *mpRootWidget;
 
     LayoutTree( layout::Dialog *dialog )
-    : SortListBox( new layout::ListBox( dialog, "layout-tree" ),
-                   new layout::PushButton( dialog, "layout-up-button" ),
-                   new layout::PushButton( dialog, "layout-down-button" ),
-                   new layout::PushButton( dialog, "layout-remove-button" ) )
+        : SortListBox( new layout::ListBox( dialog, "layout-tree" ),
+                       new layout::PushButton( dialog, "layout-up-button" ),
+                       new layout::PushButton( dialog, "layout-down-button" ),
+                       new layout::PushButton( dialog, "layout-remove-button" ) )
     {
         layout::PeerHandle handle = dialog->GetPeerHandle( "preview-box" );
         uno::Reference< awt::XLayoutConstrains > xWidget( handle, uno::UNO_QUERY );
@@ -1572,23 +1559,23 @@ public:
 
     // print in XML format...
 
-static rtl::OUString toXMLNaming (const rtl::OUString &string)
-{
-    rtl::OUStringBuffer buffer (string.getLength());
-    sal_Unicode *str = string.pData->buffer;
-    for (int i = 0; i < string.getLength(); i++) {
-        if ( str[i] >= 'A' && str[i] <= 'Z' )
-        {
-            if ( i > 0 )
-                buffer.append ((sal_Unicode) '-');
-            buffer.append ((sal_Unicode) (str[i] - 'A' + 'a'));
+    static rtl::OUString toXMLNaming (const rtl::OUString &string)
+    {
+        rtl::OUStringBuffer buffer (string.getLength());
+        sal_Unicode *str = string.pData->buffer;
+        for (int i = 0; i < string.getLength(); i++) {
+            if ( str[i] >= 'A' && str[i] <= 'Z' )
+            {
+                if ( i > 0 )
+                    buffer.append ((sal_Unicode) '-');
+                buffer.append ((sal_Unicode) (str[i] - 'A' + 'a'));
+            }
+            else
+                buffer.append ((sal_Unicode) str[i]);
         }
-        else
-            buffer.append ((sal_Unicode) str[i]);
-    }
 
-    return buffer.makeStringAndClear();
-}
+        return buffer.makeStringAndClear();
+    }
 
     void print()
     {
@@ -1607,7 +1594,7 @@ static rtl::OUString toXMLNaming (const rtl::OUString &string)
             for ( int kind = 0; kind < 2; kind++ )
             {
                 Widget::PropertyKind wKind = kind == 0 ? Widget::WINDOW_PROPERTY
-                                                          : Widget::CONTAINER_PROPERTY;
+                    : Widget::CONTAINER_PROPERTY;
                 Widget::PropertyIterator it( i, wKind );
                 while ( it.hasNext() )
                 {
@@ -1619,16 +1606,16 @@ static rtl::OUString toXMLNaming (const rtl::OUString &string)
                     if ( prop.Type.getTypeClass() == uno::TypeClass_BOOLEAN )
                     {
                         if ( value.compareToAscii( "0" ) )
-                             value = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("false") );
+                            value = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("false") );
                         else
-                             value = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("true") );
+                            value = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("true") );
                     }
 
                     if ( value.getLength() > 0 )
                         printf("%s%s=\"%s\" ",
-                            kind == 0 ? "" : "cnt:",
-                            OUSTRING_CSTR( toXMLNaming( prop.Name ) ), OUSTRING_CSTR( value )
-                        );
+                               kind == 0 ? "" : "cnt:",
+                               OUSTRING_CSTR( toXMLNaming( prop.Name ) ), OUSTRING_CSTR( value )
+                            );
 
                 }
             }
@@ -1709,7 +1696,7 @@ class EditorImpl : public LayoutTree::Listener
 public:
 
     EditorImpl( layout::Dialog *dialog,
-        // we should probable open this channel (or whatever its called) ourselves
+                // we should probable open this channel (or whatever its called) ourselves
                 uno::Reference< lang::XMultiServiceFactory > xMSF );
     virtual ~EditorImpl();
 
@@ -1720,12 +1707,12 @@ EditorImpl::EditorImpl( layout::Dialog *dialog,
                         uno::Reference< lang::XMultiServiceFactory > xFactory )
     : mxFactory( xFactory )
     , mxToplevel( dialog->GetPeerHandle( "dialog" ), uno::UNO_QUERY )
-    // FIXME: any of these should work
-    //dialog->getContext()->getRoot(), uno::UNO_QUERY )
-    // dialog->GetPeer(), uno::UNO_QUERY )
+      // FIXME: any of these should work
+      //dialog->getContext()->getRoot(), uno::UNO_QUERY )
+      // dialog->GetPeer(), uno::UNO_QUERY )
 {
 #if DEBUG_PRINT
-fprintf (stderr, "EditorImpl()\n");
+    fprintf (stderr, "EditorImpl()\n");
 #endif
     // framework
     mxToolkit = uno::Reference< awt::XToolkit >(
@@ -1736,7 +1723,7 @@ fprintf (stderr, "EditorImpl()\n");
 
     // custom widgets
 #if DEBUG_PRINT
-fprintf (stderr, "custom widgets\n");
+    fprintf (stderr, "custom widgets\n");
 #endif
     mpPropertiesList = new PropertiesList( dialog );
 
@@ -1744,7 +1731,7 @@ fprintf (stderr, "custom widgets\n");
     mpLayoutTree->setListener( this );
 
 /*    if ( xImport.is() )
-    mpLayoutTree->getWidget( -1 )->addChild( new Widget( xImport, "import" ) );*/
+      mpLayoutTree->getWidget( -1 )->addChild( new Widget( xImport, "import" ) );*/
 
     // create buttons
     layout::Container aWidgets( dialog, "create-widget" );
@@ -1769,15 +1756,15 @@ fprintf (stderr, "custom widgets\n");
     }
 
 #ifdef FILEDLG
-fprintf(stderr,"creating file dialog\n");
+    fprintf(stderr,"creating file dialog\n");
     pImportDialog = new FileDialog( NULL/*(layout::Window *) dialog*/, 0 );
-fprintf(stderr,"connecting it\n");
+    fprintf(stderr,"connecting it\n");
     pImportDialog->SetFileSelectHdl( LINK( this, EditorImpl, ImportDialogHdl ) );
-fprintf(stderr,"done file dialog\n");
+    fprintf(stderr,"done file dialog\n");
 #endif
 
 /*    pImportButton = new layout::PushButton( dialog, "import-button" );
-    pImportButton->SetClickHdl( LINK( this, EditorImpl, ImportButtonHdl ) );*/
+      pImportButton->SetClickHdl( LINK( this, EditorImpl, ImportButtonHdl ) );*/
     pExportButton = new layout::PushButton( dialog, "export-button" );
     pExportButton->SetClickHdl( LINK( this, EditorImpl, ExportButtonHdl ) );
 }
@@ -1787,7 +1774,7 @@ EditorImpl::~EditorImpl()
     delete mpPropertiesList;
     delete mpLayoutTree;
     for ( std::list< layout::PushButton * >::const_iterator i = maCreateButtons.begin();
-         i != maCreateButtons.end(); i++)
+          i != maCreateButtons.end(); i++)
         delete *i;
     delete pImportButton;
     delete pExportButton;
@@ -1798,14 +1785,14 @@ EditorImpl::~EditorImpl()
 
 void EditorImpl::loadFile( const rtl::OUString &aTestFile )
 {
-fprintf( stderr, "TEST: layout instance\n" );
+    fprintf( stderr, "TEST: layout instance\n" );
     uno::Reference< awt::XLayoutRoot > xRoot
         ( new EditorRoot( mxFactory, mpLayoutTree->mpRootWidget ) );
 
 /*
-mxMSF->createInstance
-                ( ::rtl::OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
-          uno::UNO_QUERY );
+  mxMSF->createInstance
+  ( ::rtl::OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
+  uno::UNO_QUERY );
 */
     if ( !xRoot.is() )
     {
@@ -1815,7 +1802,7 @@ mxMSF->createInstance
     }
 
 #if DEBUG_PRINT
-fprintf( stderr, "TEST: initing root\n" );
+    fprintf( stderr, "TEST: initing root\n" );
 #endif
 
     uno::Reference< lang::XInitialization > xInit( xRoot, uno::UNO_QUERY );
@@ -1827,16 +1814,16 @@ fprintf( stderr, "TEST: initing root\n" );
     }
 
 #if DEBUG_PRINT
-fprintf( stderr, "TEST: running parser\n" );
+    fprintf( stderr, "TEST: running parser\n" );
 #endif
     uno::Sequence< uno::Any > aParams( 1 );
     aParams[0] <<= aTestFile;
 #if DEBUG_PRINT
-fprintf( stderr, "TEST: do it\n" );
+    fprintf( stderr, "TEST: do it\n" );
 #endif
     xInit->initialize( aParams );
 #if DEBUG_PRINT
-fprintf( stderr, "TEST: file loaded\n" );
+    fprintf( stderr, "TEST: file loaded\n" );
 #endif
 
     mpLayoutTree->rebuild();
@@ -1867,13 +1854,13 @@ void EditorImpl::widgetSelected( Widget *pWidget )
     if ( !pWidget || pWidget->isContainer() )
     {
         for ( std::list< layout::PushButton *>::const_iterator it = maCreateButtons.begin();
-             it != maCreateButtons.end(); it++)
+              it != maCreateButtons.end(); it++)
             (*it)->Enable();
     }
     else
     {
         for ( std::list< layout::PushButton *>::const_iterator it = maCreateButtons.begin();
-             it != maCreateButtons.end(); it++)
+              it != maCreateButtons.end(); it++)
             (*it)->Disable();
     }
 
@@ -1884,7 +1871,7 @@ IMPL_LINK( EditorImpl, CreateWidgetHdl, layout::Button *, pBtn )
 {
     int i = 0;
     for ( std::list< layout::PushButton *>::const_iterator it = maCreateButtons.begin();
-         it != maCreateButtons.end(); it++, i++ )
+          it != maCreateButtons.end(); it++, i++ )
     {
         if ( pBtn == *it )
             break;
@@ -1898,7 +1885,7 @@ IMPL_LINK( EditorImpl, ImportButtonHdl, layout::PushButton *, pBtn )
 {
     (void) pBtn;
 #if DEBUG_PRINT
-fprintf(stderr, "IMPORT!\n");
+    fprintf(stderr, "IMPORT!\n");
 #endif
 #ifdef FILEDLG
     pImportDialog->Execute();
@@ -1914,7 +1901,7 @@ IMPL_LINK( EditorImpl, ImportDialogHdl, FileDialog *, pDialog )
 //fprintf(stderr, "Executing import dialog!\n");
 
 #if DEBUG_PRINT
-fprintf(stderr, "got import file: %s\n",rtl::OUStringToOString( path, RTL_TEXTENCODING_ASCII_US ).getStr() );
+    fprintf(stderr, "got import file: %s\n",rtl::OUStringToOString( path, RTL_TEXTENCODING_ASCII_US ).getStr() );
 #endif
 
     return 0;
diff --git a/toolkit/workben/layout/insert-sheet.xml b/toolkit/workben/layout/insert-sheet.xml
new file mode 100644
index 0000000..0ce5843
--- /dev/null
+++ toolkit/workben/layout/insert-sheet.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This is a template.  i18n translation is not performed in-place;
+     i18n translated XML files are generated from this template by
+     transex3/layout/tralay.  !-->
+
+<modaldialog sizeable="true" closeable="true" moveable="true" output-size="true" id="RID_SCDLG_INSERT_TABLE" sv-look="true" _title="Insert Sheet" xmlns="http://openoffice.org/2007/layout" xmlns:cnt="http://openoffice.org/2007/layout/container">
+    <vbox spacing="5" border="5">
+        <fixedline id="FL_POSITION" _text="Position"/>
+	<hbox>
+	    <vbox cnt:padding="13" spacing="5">
+		<radiobutton radiogroup="insert-sheet-position" id="RB_BEFORE" tabstop="true" _label="B~efore current sheet"/>
+		<radiobutton radiogroup="insert-sheet-position" id="RB_BEHIND" tabstop="true" _label="~After current sheet"/>
+	    </vbox>
+	</hbox>
+        <fixedline id="FL_TABLE" _text="Sheet"/>
+	<hbox>
+	    <vbox cnt:padding="13" spacing="5">
+		<radiobutton radiogroup="insert-sheet-source" id="RB_NEW" _label="~New sheet"/>
+		<hbox>
+		    <vbox cnt:padding="13" spacing="5" cnt:fill="false" cnt:expand="false">
+			<fixedtext id="FT_COUNT" _label="N~o. of sheets"/>
+			<fixedtext id="FT_NAME" _label="Na~me"/>
+		    </vbox>
+		    <vbox>
+			<hbox>
+			    <numericfield has_border="true" maximum="256" minimum="1" repeat="true" id="NF_COUNT" spin="true" spin-size="1" tabstop="true" value="1" cnt:fill="true" cnt:expand="false"/>
+			</hbox>
+			<edit has_border="true" id="ED_TABNAME"  cnt:fill="true" cnt:expand="true"/>
+		    </vbox>
+		</hbox>
+	    </vbox>
+	</hbox>
+	<hbox>
+	    <vbox cnt:padding="13" spacing="5">
+		<radiobutton radiogroup="insert-sheet-source" id="RB_FROMFILE" _label="~From file"/>
+		<hbox>
+		    <vbox cnt:padding="13" spacing="5">
+			<hbox>
+			    <multilistbox auto-hscroll="true" has_border="true" id="LB_TABLES" simple-mode="true" string-item-list=" : : : : " cnt:fill="true" cnt:expand="true"/>
+			    <vbox cnt:fill="false" cnt:expand="false" spacing="5">
+				<pushbutton id="BTN_BROWSE" _label="~Browse..." cnt:expand="false"/>
+			    <checkbox id="CB_LINK" _label="Lin~k" cnt:expand="false"/>
+			    <flow/>
+			    </vbox>
+			</hbox>
+			<fixedtext id="FT_PATH" label="FT-PATH"/>
+		    </vbox>
+		</hbox>
+	    </vbox>
+	</hbox>
+	<dialogbuttonhbox border="5" spacing="5">
+            <okbutton default="true" id="BTN_OK"/>
+            <cancelbutton id="BTN_CANCEL"/>
+            <helpbutton id="BTN_HELP"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/toolkit/workben/layout/makefile.mk b/toolkit/workben/layout/makefile.mk
index e82e1c9..be09324 100644
--- toolkit/workben/layout/makefile.mk
+++ toolkit/workben/layout/makefile.mk
@@ -40,15 +40,11 @@ ENABLE_EXCEPTIONS=TRUE
 
 .IF "$(ENABLE_LAYOUT)" == "TRUE"
 
-CFLAGS += -I$(PRJ)/source/layout
-
 # Allow zoom and wordcount to be built without depending on svx,sv,sfx2
-CFLAGS += -I../$(PRJ)/svx/inc -I../$(PRJ)/svtools/inc -I../$(PRJ)/sfx2/inc -I../$(PRJ)/sc/inc -I../$(PRJ)/sc/source/ui/inc
+CFLAGS += -I../$(PRJ)/svx/inc -I../$(PRJ)/svtools/inc -I../$(PRJ)/sfx2/inc -I../$(PRJ)/sc/inc -I../$(PRJ)/sc/source/ui/inc -I../$(PRJ)/sw/inc
 
 .INCLUDE : $(PRJ)$/util$/makefile.pmk
 
-CFLAGS += -DENABLE_LAYOUT=1 -DTEST_LAYOUT=1
-
 .IF "$(COMNAME)" == "gcc3"
 CFLAGS+=-Wall -Wno-non-virtual-dtor
 .ENDIF
@@ -92,15 +88,20 @@ default: ALLTAR
 .INCLUDE : target.mk
 
 XML_FILES=\
+	insert-sheet.xml\
+	message-box.xml\
+	move-copy-sheet.xml\
 	recover.xml\
 	sort-options.xml\
+	string-input.xml\
+	tab-dialog.xml\
 	wordcount.xml\
 	zoom.xml\
 
 TRALAY=tralay
 XML_LANGS=$(alllangiso)
 
-ALLTAR: $(BIN)/testrc $(svtools) $(foreach,i,$(XML_FILES) en-US/$i)
+ALLTAR: localize.sdf $(BIN)/testrc $(svtools) $(foreach,i,$(XML_FILES) en-US/$i)
 
 $(XML_LANGS:f:t"/%.xml ")/%.xml: %.xml
 	$(TRALAY) -m localize.sdf -o . -l $(XML_LANGS:f:t" -l ") $<
@@ -119,12 +120,16 @@ $(svtools):
 	ln -sf ..$/$(PRJ)$/svtools$/inc $(INCCOM)$/svtools
 
 dist .PHONY :
+	cp -pv message-box.xml $(PRJ)/uiconfig/layout
+	cp -pv tab-dialog.xml $(PRJ)/uiconfig/layout
 	$(SHELL) ./un-test.sh zoom.cxx > ../$(PRJ)/svx/source/dialog/zoom.cxx
 	$(SHELL) ./un-test.sh zoom.hxx > ../$(PRJ)/svx/source/dialog/zoom.hxx
 	touch ../$(PRJ)/svx/source/dialog/dlgfact.cxx
+	cp -pv zoom.xml ../$(PRJ)/svx/uiconfig/layout
 	$(SHELL) ./un-test.sh wordcountdialog.cxx > ../$(PRJ)/sw/source/ui/dialog/wordcountdialog.cxx
 	$(SHELL) ./un-test.sh wordcountdialog.hxx > ../$(PRJ)/sw/source/ui/inc/wordcountdialog.hxx
 	touch ../$(PRJ)/sw/source/ui/dialog/swdlgfact.cxx
+	cp -pv wordcount.xml ../$(PRJ)/sw/uiconfig/layout
 	# FIXME: broken setup
 	ln -sf ../inc/wordcountdialog.hxx ../$(PRJ)/sw/source/ui/dialog/wordcountdialog.hxx 
 	$(SHELL) ./un-test.sh tpsort.cxx > ../$(PRJ)/sc/source/ui/dbgui/tpsort.cxx
@@ -133,6 +138,17 @@ dist .PHONY :
 	$(SHELL) ./un-test.sh sortdlg.hxx > ../$(PRJ)/sc/source/ui/inc/sortdlg.hxx
 	touch ../$(PRJ)/sc/source/ui/attrdlg/scdlgfact.cxx
 	touch ../$(PRJ)/sc/source/ui/view/cellsh2.cxx
+	cp -pv insert-sheet.xml ../$(PRJ)/sc/uiconfig/layout
+	cp -pv move-copy-sheet.xml ../$(PRJ)/sc/uiconfig/layout
+	cp -pv sort-options.xml ../$(PRJ)/sc/uiconfig/layout
+	cp -pv string-input.xml ../$(PRJ)/sc/uiconfig/layout
+
+localize.sdf: $(PRJ)/../svx/source/dialog/localize.sdf $(PRJ)/../sw/source/ui/dialog/localize.sdf $(PRJ)/../sc/source/ui/src/localize.sdf
+	grep sortdlg.src $(PRJ)/../sc/source/ui/src/localize.sdf | awk -F'\t' '{{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "sc\\uiconfig\\layout\\sort-options.xml", $$3, "layout", $$6 "_label", "", "", $$8, "0", $$10, $$11, $$12, "", $$14, $$15}}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SCDLG_SORT_title/' > sort-options-$@
+	grep wordcountdialog.src $(PRJ)/../sw/source/ui/dialog/localize.sdf | awk -F'\t' '{{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "sw\\uiconfig\\layout\\wordcount.xml", $$3, "layout", $$6 "_label", "", "", $$8, "0", $$10, $$11, $$12, "", $$14, $$15}}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tDLG_WORDCOUNT_title/' > wordcount-$@
+	grep zoom.src $(PRJ)/source/dialog/localize.sdf | awk -F'\t' '{{printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "layout", "svx\\uiconfig\\layout\\zoom.xml", $$3, "layout", $$6 "_label", "", "", $$8, "0", $$10, $$11, $$12, "", $$14, $$15}}' | sed -e 's/\(\(FL\|STR\)_[^\t]*\)_label/\1_text/' -e 's/\t_label/\tRID_SVXDLG_ZOOM_title/' > zoom-$@
+	echo '#empty' | cat - sort-options-$@ wordcount-$@ zoom-$@ > $@
+	rm -f *-$@
 
 .ELSE # ENABLE_LAYOUT != TRUE
 all .PHONY:
diff --git a/toolkit/workben/layout/message-box.xml b/toolkit/workben/layout/message-box.xml
new file mode 100644
index 0000000..6a64be1
--- /dev/null
+++ toolkit/workben/layout/message-box.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This is a template.  i18n translation is not performed in-place;
+     i18n translated xml files are generated from this template by
+     transex3/layout/tralay.  !-->
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="message-box" _title="" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true" closeable="true">
+    <vbox border="5" spacing="5">
+	<hbox border="5" spacing="20">
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_ERROR" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-error.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_INFO" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-info.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_QUERY" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-query.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedimage id="FI_WARNING" cnt:expand="false" cnt:v-align="0.5" cnt:v-fill="0" graphic="res/commandimagelist/msgbox-warning.png" />
+	    </align>
+	    <align cnt:expand="false" cnt:fill="true">
+		<fixedtext id="FT_MESSAGE" _label="FT-LABEL" cnt:v-align="0.5" cnt:v-fill="0" />
+	    </align>
+	    <flow/>
+	</hbox>
+	<dialogbuttonhbox border="0" spacing="5">
+	    <flow/>
+	    <!-- deprecoted vcl/MsgBox compatibility !-->
+	    <retrybutton id="BTN_RETRY" />
+	    <ignorebutton id="BTN_IGNORE" />
+
+	    <yesbutton id="BTN_YES"/>
+	    <cancelbutton id="BTN_CANCEL"/>
+	    <helpbutton id="BTN_HELP"/>
+	    <nobutton id="BTN_NO" xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/toolkit/workben/layout/move-copy-sheet.xml b/toolkit/workben/layout/move-copy-sheet.xml
new file mode 100644
index 0000000..79720df
--- /dev/null
+++ toolkit/workben/layout/move-copy-sheet.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This is a template.  i18n translation is not performed in-place;
+     i18n translated XML files are generated from this template by
+     transex3/layout/tralay.  !-->
+
+<modaldialog sizeable="true" closeable="true" help-id="FID_TAB_MOVE" moveable="true" output-size="true" id="RID_SCDLG_MOVETAB" sv-look="true" _title="Move/Copy Sheet" xmlns="http://openoffice.org/2007/layout" xmlns:cnt="http://openoffice.org/2007/layout/container">
+    <vbox spacing="5" border="5">
+	<string id="STR_NEWDOC" _text="- new document -"/>
+        <fixedtext id="FT_DEST" _label="To ~document"/>
+        <listbox has_border="true" dropdown="true" id="LB_DEST" tabstop="true"/>
+        <fixedtext id="FT_INSERT" _label="~Insert before"/>
+        <listbox has_border="true" id="LB_INSERT" tabstop="true" string-item-list=" : : : : " />
+        <checkbox id="BTN_COPY" tabstop="true" _label="~Copy"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+            <cancelbutton id="BTN_CANCEL" tabstop="true"/>
+            <helpbutton id="BTN_HELP" tabstop="true"/>
+            <okbutton default="true" id="BTN_OK" tabstop="true"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/toolkit/workben/layout/recover.cxx b/toolkit/workben/layout/recover.cxx
index 706ee21..a0cc56b 100644
--- toolkit/workben/layout/recover.cxx
+++ toolkit/workben/layout/recover.cxx
@@ -55,6 +55,13 @@ using namespace com::sun::star;
 
 #include <layout/layout-pre.hxx>
 
+#if ENABLE_LAYOUT
+#undef SVX_RES
+#define SVX_RES(x) #x
+#undef SfxModalDialog
+#define SfxModalDialog( parent, id ) Dialog( parent, "recover.xml", id )
+#endif /* ENABLE_LAYOUT */
+
 #if TEST_LAYOUT
 SvxRecoverDialog::SvxRecoverDialog( Window* pParent )
 #else /* !TEST_LAYOUT */
diff --git a/toolkit/workben/layout/recover.hxx b/toolkit/workben/layout/recover.hxx
index 5471011..56e6330 100644
--- toolkit/workben/layout/recover.hxx
+++ toolkit/workben/layout/recover.hxx
@@ -35,7 +35,7 @@
 #include <vcl/button.hxx>
 #include <vcl/field.hxx>
 #include <vcl/fixed.hxx>
-#include <box.hxx>
+#include <layout/core/box.hxx>
 #include <layout/layout-pre.hxx>
 
 class SvxRecoverDialog : public SfxModalDialog
diff --git a/toolkit/workben/layout/sort-options.xml b/toolkit/workben/layout/sort-options.xml
index e2e01f0..43144c1 100644
--- toolkit/workben/layout/sort-options.xml
+++ toolkit/workben/layout/sort-options.xml
@@ -33,8 +33,8 @@
 		<listbox has_border="true" dropdown="true" id="LB_ALGORITHM" tabstop="true"/>
             </hbox>
             <fixedline id="FL_DIRECTION" _text="Direction"/>
-            <radiobutton id="BTN_TOP_DOWN" tabstop="true" _label="~Top to bottom (sort rows)"/>
-            <radiobutton id="BTN_LEFT_RIGHT" tabstop="true" _label="L~eft to right (sort columns)"/>
+            <radiobutton id="BTN_TOP_DOWN" radiogroup="sort-options" tabstop="true" _label="~Top to bottom (sort rows)"/>
+            <radiobutton id="BTN_LEFT_RIGHT" radiogroup="sort-options" tabstop="true" _label="L~eft to right (sort columns)"/>
 	</vbox>
     </vbox>
 </tabpage>
diff --git a/toolkit/workben/layout/sortdlg.cxx b/toolkit/workben/layout/sortdlg.cxx
index e7731ef..3a6a243 100644
--- toolkit/workben/layout/sortdlg.cxx
+++ toolkit/workben/layout/sortdlg.cxx
@@ -42,8 +42,9 @@
 #include "scresid.hxx"
 #include "sortdlg.hrc"
 
-
-//==================================================================
+#ifndef LAYOUT_SFX_TABDIALOG_BROKEN
+#include <layout/layout-pre.hxx>
+#endif
 
 ScSortDlg::ScSortDlg( Window*			pParent,
 					  const SfxItemSet* pArgSet ) :
@@ -54,8 +55,15 @@ ScSortDlg::ScSortDlg( Window*			pParent,
 		bIsByRows	( FALSE )
 
 {
+#ifdef LAYOUT_SFX_TABDIALOG_BROKEN
 	AddTabPage( TP_FIELDS,	ScTabPageSortFields::Create,  0 );
 	AddTabPage( TP_OPTIONS,	ScTabPageSortOptions::Create, 0 );
+#else
+    String fields = rtl::OUString::createFromAscii ("fields");
+	AddTabPage( TP_FIELDS, fields, ScTabPageSortFields::Create, 0, FALSE, TAB_APPEND);
+    String options = rtl::OUString::createFromAscii ("options");
+	AddTabPage( TP_OPTIONS,	options, ScTabPageSortOptions::Create, 0, FALSE, TAB_APPEND);
+#endif    
 	FreeResource();
 }
 
diff --git a/toolkit/workben/layout/sortdlg.hxx b/toolkit/workben/layout/sortdlg.hxx
index d2ea7ed..a950d97 100644
--- toolkit/workben/layout/sortdlg.hxx
+++ toolkit/workben/layout/sortdlg.hxx
@@ -33,10 +33,14 @@
 
 #include <sfx2/tabdlg.hxx>
 
-#ifndef _SFX_HXX
-#endif
+#if !TEST_LAYOUT
+#define LAYOUT_SFX_TABDIALOG_BROKEN 1
+#endif /* !TEST_LAYOUT */
 
-//==================================================================
+#ifndef LAYOUT_SFX_TABDIALOG_BROKEN
+#include <sfx2/layout.hxx>
+#include <layout/layout-pre.hxx>
+#endif
 
 class ScSortDlg : public SfxTabDialog
 {
@@ -61,7 +65,8 @@ inline void ScSortDlg::SetByRows ( BOOL bByRows  )	{ bIsByRows = bByRows; }
 inline BOOL ScSortDlg::GetHeaders() const 			{ return bIsHeaders; }
 inline BOOL ScSortDlg::GetByRows () const 			{ return bIsByRows; }
 
+#ifndef LAYOUT_SFX_TABDIALOG_BROKEN
+#include <layout/layout-post.hxx>
+#endif
 
 #endif // SC_SORTDLG_HXX
-
-
diff --git a/toolkit/workben/layout/string-input.xml b/toolkit/workben/layout/string-input.xml
new file mode 100644
index 0000000..0a59899
--- /dev/null
+++ toolkit/workben/layout/string-input.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This is a template.  i18n translation is not performed in-place;
+     i18n translated XML files are generated from this template by
+     transex3/layout/tralay.  !-->
+
+<modaldialog sizeable="true" closeable="false" moveable="true" output-size="true" id="RID_SCDLG_STRINPUT" sv-look="true" xmlns="http://openoffice.org/2007/layout" xmlns:cnt="http://openoffice.org/2007/layout/container" title="Insert String">
+    <vbox spacing="5" border="5">
+        <fixedtext id="FT_LABEL" label="FT-LABEL"/>
+        <edit has_border="true" id="ED_INPUT" tabstop="true"/>
+	<dialogbuttonhbox border="5" spacing="5">
+            <okbutton default="true" id="BTN_OK" tabstop="true"/>
+            <cancelbutton id="BTN_CANCEL" tabstop="true"/>
+            <helpbutton id="BTN_HELP" tabstop="true"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/toolkit/workben/layout/tab-dialog.xml b/toolkit/workben/layout/tab-dialog.xml
new file mode 100644
index 0000000..1d631e9
--- /dev/null
+++ toolkit/workben/layout/tab-dialog.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+	xmlns:cnt="http://openoffice.org/2007/layout/container"
+	_title="layout::TabDialog" optimumsize="true"
+	id="tab-dialog"
+	has_border="true" sizeable="true" moveable="true">
+    <vbox spacing="5" border="5">
+	<tabcontrol id="ID_TABCONTROL"/>
+	<dialogbuttonhbox border="5" spacing="5" cnt:expand="false">
+	    <flow/>
+	    <okbutton id="BTN_OK" show="false"/>
+	    <pushbutton id="BTN_USER" _label="&lt;User&gt;" show="false"/>
+	    <cancelbutton id="BTN_CANCEL" show="false"/>
+	    <helpbutton id="BTN_HELP" show="false"/>
+	    <resetbutton id="BTN_RESET" show="false"/>
+	    <pushbutton id="BTN_BASEFMT" _label="&lt;Base Format&gt;" show="false"/>
+	</dialogbuttonhbox>
+    </vbox>
+</dialog>
diff --git a/toolkit/workben/layout/tabcontrol.xml b/toolkit/workben/layout/tabcontrol.xml
index 6a423f5..b11973b 100644
--- toolkit/workben/layout/tabcontrol.xml
+++ toolkit/workben/layout/tabcontrol.xml
@@ -1,18 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <dialog xmlns="http://openoffice.org/2007/layout"
-        xmlns:cnt="http://openoffice.org/2007/layout/container"
-        title="TabControl Test" optimumsize="true"
-        has_border="true" sizeable="true" moveable="true">
-	<vbox>
-		<tabcontrol>
-			<pushbutton label="Child 1" cnt:title="Page 1" />
-			<edit has_border="true" text="Child 2" cnt:title="Page 2" />
-			<vbox cnt:title="Page 3">
-				<pushbutton label="Child 3"/>
-				<edit has_border="true" text="Child 4" />
-			</vbox>
-		</tabcontrol>
-		<okbutton cnt:expand="false" />
-	</vbox>
+	xmlns:cnt="http://openoffice.org/2007/layout/container"
+	title="TabControl Test" optimumsize="true"
+	has_border="true" sizeable="true" moveable="true">
+    <vbox>
+	<tabcontrol>
+	    <pushbutton label="Child 1" cnt:title="Page 1" />
+	    <edit has_border="true" text="Child 2" cnt:title="Page 2" />
+	    <vbox cnt:title="Page 3">
+		<pushbutton label="Child 3"/>
+		<edit has_border="true" text="Child 4" />
+	    </vbox>
+	</tabcontrol>
+	<okbutton cnt:expand="false" />
+    </vbox>
 </dialog>
diff --git a/toolkit/workben/layout/test.cxx b/toolkit/workben/layout/test.cxx
index 159cbc9..86a0b1c 100644
--- toolkit/workben/layout/test.cxx
+++ toolkit/workben/layout/test.cxx
@@ -237,19 +237,21 @@ void LayoutTest::RunEditor()
     editor.Execute();
 }
 
-void RunDialog( Dialog& dialog )
+short RunDialog( Dialog& dialog )
 {
     dialog.Show();
-    dialog.Execute();
-    fprintf( stderr, "Done: dialog execute exited\n" );
+    short result = dialog.Execute();
+    fprintf( stderr, "Done: dialog execute exited:%d\n", result);
+    return result;
 }
 
 #undef Dialog
-void RunDialog( ::Dialog& dialog )
+short RunDialog( ::Dialog& dialog )
 {
     dialog.Show();
-    dialog.Execute();
-    fprintf( stderr, "Done: dialog execute exited\n" );
+    short result = dialog.Execute();
+    fprintf( stderr, "Done: dialog execute exited:%d\n", result);
+    return result;
 }
 
 #if SORT_DLG
@@ -270,6 +272,19 @@ void TestDialog( OUString const& name )
         PluginDialog plugin ( 0 );
         RunDialog( plugin );
     }
+    else if ( name.equalsAscii( "query" ) )
+    {
+        QueryBox query ( 0, "Do you want to do?", "do");
+        RunDialog( query );
+    }
+    else if ( name.equalsAscii( "query-compat" ) )
+    {
+        QueryBox query ( 0,
+                         WinBits( WB_YES_NO | WB_DEF_YES ),
+//                         WinBits( WB_ABORT_RETRY_IGNORE ),
+                         OUString::createFromAscii ("Do you want to do?"));
+        RunDialog( query );
+    }
     else if ( name.equalsAscii( "recover" ) )
     {
         SvxRecoverDialog recover ( 0 );
@@ -279,7 +294,7 @@ void TestDialog( OUString const& name )
     else if ( name.equalsAscii( "sort" ) )
     {
         LoadSC();
-        ScSortDlg sort ( 0, 0 );
+        ScSortDlg sort (0, 0);
         RunDialog( sort );
     }
 #endif /* SORT_DLG */
diff --git a/toolkit/workben/layout/tpsort.cxx b/toolkit/workben/layout/tpsort.cxx
index 9468c5d..6770232 100644
--- toolkit/workben/layout/tpsort.cxx
+++ toolkit/workben/layout/tpsort.cxx
@@ -7,7 +7,7 @@
  * OpenOffice.org - a multi-platform office productivity suite
  *
  * $RCSfile: tpsort.cxx,v $
- * $Revision: 1.13 $
+ * $Revision: 1.14 $
  *
  * This file is part of OpenOffice.org.
  *
@@ -554,7 +554,7 @@ IMPL_LINK( ScTabPageSortFields, SelectHdl, ListBox *, pLb )
 #undef ScResId
 #define ScResId(x) #x
 #undef SfxTabPage
-#define SfxTabPage( parent, id, args ) TabPage( parent, "sort-options.xml", id, 0, &args )
+#define SfxTabPage( parent, id, args ) SfxTabPage( parent, "sort-options.xml", id, &args )
 #endif /* ENABLE_LAYOUT */
 
 ScTabPageSortOptions::ScTabPageSortOptions( Window* 			pParent,
@@ -584,6 +584,7 @@ ScTabPageSortOptions::ScTabPageSortOptions( Window* 			pParent,
 //		aFtArea 		( this, ScResId( FT_AREA ) ),
 		//
 #if ENABLE_LAYOUT
+#undef this
 #undef ScResId
 #define ScResId(x) this, #x
 #endif /* ENABLE_LAYOUT */
@@ -748,7 +749,6 @@ USHORT* __EXPORT ScTabPageSortOptions::GetRanges()
 
 #if ENABLE_LAYOUT
 #undef SfxTabPage
-#define SfxTabPage TabPage
 #endif /* ENABLE_LAYOUT */
 SfxTabPage* __EXPORT ScTabPageSortOptions::Create(
 											Window*				pParent,
diff --git a/toolkit/workben/layout/tpsort.hxx b/toolkit/workben/layout/tpsort.hxx
index ed6bdc8..ccf5db0 100644
--- toolkit/workben/layout/tpsort.hxx
+++ toolkit/workben/layout/tpsort.hxx
@@ -132,7 +132,7 @@ class ScRangeData;
 class CollatorRessource;
 class CollatorWrapper;
 
-#include <layout/layout.hxx>
+#include <sfx2/layout.hxx>
 #include <layout/layout-pre.hxx>
 
 class ScTabPageSortOptions : public SfxTabPage
@@ -142,12 +142,10 @@ public:
 									  const SfxItemSet&	 rArgSet );
 				~ScTabPageSortOptions();
 
-#if !ENABLE_LAYOUT
+#undef SfxTabPage
+#define SfxTabPage ::SfxTabPage
 	static	SfxTabPage*	Create		( Window*				pParent,
 									  const SfxItemSet& 	rArgSet );
-#else /* ENABLE_LAYOUT */
-    static TabPage*	Create ( Window* parent, SfxItemSet const& set );
-#endif /* ENABLE_LAYOUT */
 	static	USHORT*		GetRanges	();
 	virtual	BOOL		FillItemSet	( SfxItemSet& rArgSet );
 	virtual	void		Reset		( const SfxItemSet& rArgSet );
@@ -185,13 +183,9 @@ private:
 
 //     FixedText           aFtAreaLabel;
 //  FixedInfo           aFtArea;
-#if ENABLE_LAYOUT
-#define String layout::LocalizedString
-#endif /* ENABLE_LAYOUT */
-    String              aStrRowLabel;
-    String              aStrColLabel;
-    String              aStrUndefined;
-#undef String
+    LocalizedString aStrRowLabel;
+    LocalizedString aStrColLabel;
+    LocalizedString aStrUndefined;
     String              aStrNoName;
     String              aStrAreaLabel;
 
diff --git a/toolkit/workben/layout/uno.hxx b/toolkit/workben/layout/uno.hxx
index ba49389..8e0630e 100644
--- toolkit/workben/layout/uno.hxx
+++ toolkit/workben/layout/uno.hxx
@@ -37,8 +37,8 @@
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 
-#include "root.hxx"
-#include "factory.hxx"
+#include <layout/core/root.hxx>
+#include <layout/core/factory.hxx>
 
 #if LAYOUT_WEAK
 #include <cppuhelper/implbase1.hxx>
diff --git a/toolkit/workben/layout/wordcount.xml b/toolkit/workben/layout/wordcount.xml
index ae33571..e922294 100644
--- toolkit/workben/layout/wordcount.xml
+++ toolkit/workben/layout/wordcount.xml
@@ -7,7 +7,7 @@
              xmlns:cnt="http://openoffice.org/2007/layout/container"
              help-id="HID_DLG_WORDCOUNT"
              id="DLG_WORDCOUNT"
-             sizeable="true" moveable="true" optimumsize="true"
+             sizeable="true" moveable="true" optimumsize="true" closeable="true"
              has_border="true" sv-look="true" _title="Word Count">
     <vbox border="5" spacing="5">
         <fixedline id="FL_CURRENT" _text="Current selection"/>
@@ -26,7 +26,7 @@
 	    </vbox>
 	</hbox>
 	<!-- if we could do cnt:cnt:padding="-13" here, we would not have to close
-	     and reope the hbox/vbox thing !-->
+	     and reopen the hbox/vbox thing !-->
         <fixedline id="FL_DOC" _text="Whole document"/>
 	<hbox>
 	    <vbox cnt:padding="13" spacing="5">
diff --git a/toolkit/workben/layout/wordcountdialog.cxx b/toolkit/workben/layout/wordcountdialog.cxx
index 64f1836..1eebbe5 100644
--- toolkit/workben/layout/wordcountdialog.cxx
+++ toolkit/workben/layout/wordcountdialog.cxx
@@ -7,7 +7,7 @@
  * OpenOffice.org - a multi-platform office productivity suite
  *
  * $RCSfile: wordcountdialog.cxx,v $
- * $Revision: 1.3 $
+ * $Revision: 1.10 $
  *
  * This file is part of OpenOffice.org.
  *
@@ -47,6 +47,15 @@
 #include <wordcountdialog.hrc>
 #endif /* !TEST_LAYOUT */
 
+#if ENABLE_LAYOUT
+#undef SW_RES
+#define SW_RES(x) #x
+#undef SfxModalDialog
+#define SfxModalDialog( parent, id ) Dialog( parent, "wordcount.xml", id )
+#define SW_WORDCOUNTDIALOG_HRC
+#include <helpid.h>
+#endif /* ENABLE_LAYOUT */
+
 /*-- 06.04.2004 16:05:55---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -73,6 +82,9 @@ SwWordCountDialog::SwWordCountDialog(Window* pParent) :
 #pragma warning (default : 4355)
 #endif
 {
+#if ENABLE_LAYOUT
+    SetHelpId (HID_DLG_WORDCOUNT);
+#endif /* ENABLE_LAYOUT */
     FreeResource();
 }
 /*-- 06.04.2004 16:05:56---------------------------------------------------
diff --git a/toolkit/workben/layout/wordcountdialog.hxx b/toolkit/workben/layout/wordcountdialog.hxx
index 62e97bb..b0674e2 100644
--- toolkit/workben/layout/wordcountdialog.hxx
+++ toolkit/workben/layout/wordcountdialog.hxx
@@ -7,7 +7,7 @@
  * OpenOffice.org - a multi-platform office productivity suite
  *
  * $RCSfile: wordcountdialog.hxx,v $
- * $Revision: 1.3 $
+ * $Revision: 1.5 $
  *
  * This file is part of OpenOffice.org.
  *
diff --git a/toolkit/workben/layout/zoom.cxx b/toolkit/workben/layout/zoom.cxx
index 3185c96..6d7ade8 100644
--- toolkit/workben/layout/zoom.cxx
+++ toolkit/workben/layout/zoom.cxx
@@ -7,7 +7,7 @@
  * OpenOffice.org - a multi-platform office productivity suite
  *
  * $RCSfile: zoom.cxx,v $
- * $Revision: 1.3 $
+ * $Revision: 1.12 $
  *
  * This file is part of OpenOffice.org.
  *
@@ -51,7 +51,9 @@
 #define _SVX_ZOOM_CXX
 
 #include <svx/dialogs.hrc>
+#if !TEST_LAYOUT
 #include "zoom.hrc"
+#endif /* !TEST_LAYOUT */
 
 #include "zoom.hxx"
 #if TEST_LAYOUT
@@ -112,6 +114,13 @@ struct SvxViewLayoutItem : public LAYOUT_SfxPoolItem
 
 #include <layout/layout-pre.hxx>
 
+#if ENABLE_LAYOUT
+#undef SVX_RES
+#define SVX_RES(x) #x
+#undef SfxModalDialog
+#define SfxModalDialog( parent, id ) Dialog( parent, "zoom.xml", id )
+#endif /* ENABLE_LAYOUT */
+
 // static ----------------------------------------------------------------
 
 static USHORT pRanges[] =
@@ -282,6 +291,9 @@ SvxZoomDialog::SvxZoomDialog( Window* pParent, const SfxItemSet& rCoreSet ) :
 	bModified	( FALSE )
 
 {
+#if ENABLE_LAYOUT
+    SetHelpId (SID_ATTR_ZOOM);
+#endif /* ENABLE_LAYOUT */
 	Link aLink = LINK( this, SvxZoomDialog, UserHdl );
     a100Btn.SetClickHdl( aLink );
     aOptimalBtn.SetClickHdl( aLink );
diff --git a/toolkit/workben/layout/zoom.hxx b/toolkit/workben/layout/zoom.hxx
index 7dc09dc..461cd5a 100644
--- toolkit/workben/layout/zoom.hxx
+++ toolkit/workben/layout/zoom.hxx
@@ -7,7 +7,7 @@
  * OpenOffice.org - a multi-platform office productivity suite
  *
  * $RCSfile: zoom.hxx,v $
- * $Revision: 1.3 $
+ * $Revision: 1.6 $
  *
  * This file is part of OpenOffice.org.
  *
diff --git a/toolkit/workben/layout/zoom.xml b/toolkit/workben/layout/zoom.xml
index 5ad8fcf..5938643 100644
--- toolkit/workben/layout/zoom.xml
+++ toolkit/workben/layout/zoom.xml
@@ -7,34 +7,34 @@
              xmlns:cnt="http://openoffice.org/2007/layout/container"
              id="RID_SVXDLG_ZOOM" _title="Zoom &amp; View Layout" optimumsize="true"
 	     help-id="SID_ATTR_ZOOM"
-             has_border="true" sizeable="true" moveable="true">
+             has_border="true" sizeable="true" moveable="true" closeable="true">
     <vbox spacing="5" border="5">
 	<hbox spacing="0" border="0">
 	    <vbox spacing="5" border="5">
-	<fixedline id="FL_ZOOM" _text="Zoom factor" cnt:expand="true"/>
-		<radiobutton radiogroup="zoom" id="BTN_OPTIMAL"   _label="Optimal"/>
-	<radiobutton radiogroup="zoom" id="BTN_WHOLE_PAGE" _label="Whole Page"/>
-	<radiobutton radiogroup="zoom" id="BTN_PAGE_WIDTH" _label="Page Width"/>
-	<radiobutton radiogroup="zoom" id="BTN_100"   _label="100 %"/>
-	<hbox cnt:expand="false" cnt:fill="true">
-	    <align cnt:expand="false" cnt:fill="true">
-		<radiobutton cnt:v-align="0.5" cnt:v-fill="0" radiogroup="zoom" id="BTN_USER" _label="Variable"/>
-	    </align>
-	    <flow cnt:padding="10" cnt:expand="false"/>
-	    <metricfield id="ED_USER" value-step="1"
-			 repeat="true" has_border="true" spin="true"
-			 _text="100%" unit="11" custom-unit-text="%"
-			 right="true"
-			 cnt:expand="false"/>
-	</hbox>
+		<fixedline id="FL_ZOOM" _text="Zoom factor" cnt:expand="true"/>
+		<radiobutton radiogroup="zoom-factor" id="BTN_OPTIMAL"   _label="Optimal"/>
+		<radiobutton radiogroup="zoom-factor" id="BTN_WHOLE_PAGE" _label="Whole Page"/>
+		<radiobutton radiogroup="zoom-factor" id="BTN_PAGE_WIDTH" _label="Page Width"/>
+		<radiobutton radiogroup="zoom-factor" id="BTN_100"   _label="100 %"/>
+		<hbox cnt:expand="false" cnt:fill="true">
+		    <align cnt:expand="false" cnt:fill="true">
+			<radiobutton cnt:v-align="0.5" cnt:v-fill="0" radiogroup="zoom-factor" id="BTN_USER" _label="Variable"/>
+		    </align>
+		    <flow cnt:padding="10" cnt:expand="false"/>
+		    <metricfield id="ED_USER" value-step="1"
+				 repeat="true" has_border="true" spin="true"
+				 _text="100%" unit="11" custom-unit-text="%"
+				 right="true"
+				 cnt:expand="false"/>
+		</hbox>
 	    </vbox>
 	    <vbox spacing="5" border="5">
 		<fixedline id="FL_VIEWLAYOUT" _text="View layout" cnt:expand="true"/>
-		<radiobutton radiogroup="zoom" id="BTN_AUTOMATIC" _label="~Automatic"/>
-		<radiobutton radiogroup="zoom" id="BTN_SINGLE"    _label="~Single page"/>
+		<radiobutton radiogroup="zoom-layout" id="BTN_AUTOMATIC" _label="~Automatic"/>
+		<radiobutton radiogroup="zoom-layout" id="BTN_SINGLE"    _label="~Single page"/>
 		<hbox cnt:expand="false" cnt:fill="true">
 		    <align cnt:expand="false" cnt:fill="true">
-			<radiobutton cnt:v-align="0.5" cnt:v-fill="0" radiogroup="zoom" id="BTN_COLUMNS" _label="~Columns"/>
+			<radiobutton cnt:v-align="0.5" cnt:v-fill="0" radiogroup="zoom-layout" id="BTN_COLUMNS" _label="~Columns"/>
 		    </align>
 		    <flow cnt:padding="10" cnt:expand="false"/>
 		    <metricfield id="ED_COLUMNS" value-step="1"
