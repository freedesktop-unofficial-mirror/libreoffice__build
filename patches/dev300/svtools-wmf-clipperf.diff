Much improved clip performance for certain worst-case wmfs

From: Thorsten Behrens <tbehrens@novell.com>


---

 svtools/source/filter.vcl/wmf/winmtf.cxx |  178 ++++++++++++------------------
 svtools/source/filter.vcl/wmf/winmtf.hxx |   54 +++++----
 svtools/util/makefile.mk                 |    1 
 3 files changed, 97 insertions(+), 136 deletions(-)


diff --git svtools/source/filter.vcl/wmf/winmtf.cxx svtools/source/filter.vcl/wmf/winmtf.cxx
index ded2b0a..30f4ac3 100644
--- svtools/source/filter.vcl/wmf/winmtf.cxx
+++ svtools/source/filter.vcl/wmf/winmtf.cxx
@@ -33,8 +33,11 @@
 
 
 #include "winmtf.hxx"
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/polygon/b2dpolypolygontools.hxx>
 #include <vcl/metaact.hxx>
 #include <vcl/graphictools.hxx>
+#include <vcl/canvastools.hxx>
 #include <vcl/metric.hxx>
 #include <rtl/tencinfo.h>
 
@@ -45,99 +48,56 @@
 
 #define WIN_MTF_MAX_POLYPOLYCOUNT	16
 
-void WinMtfClipPath::ImpUpdateType()
+void WinMtfClipPath::intersectClipRect( const Rectangle& rRect )
 {
-    if ( !aPolyPoly.Count() )
-        eType = EMPTY;
-    else if ( aPolyPoly.IsRect() )
-        eType = RECTANGLE;
-    else
-        eType = COMPLEX;
-
-    bNeedsUpdate = sal_True;
-}
-
-void WinMtfClipPath::IntersectClipRect( const Rectangle& rRect )
-{
-    if ( !aPolyPoly.Count() )
-        aPolyPoly = Polygon( rRect );
-    else if ( aPolyPoly.Count() < WIN_MTF_MAX_POLYPOLYCOUNT )
-    {
-        Polygon aPolygon( rRect );
-        PolyPolygon aIntersection;
-        PolyPolygon aPolyPolyRect( aPolygon );
-        aPolyPoly.GetIntersection( aPolyPolyRect, aIntersection );
-        aPolyPoly = aIntersection;
-    }
-    ImpUpdateType();
+    maClip.intersectRange(
+        vcl::unotools::b2DRectangleFromRectangle(rRect));
 }
 
-void WinMtfClipPath::ExcludeClipRect( const Rectangle& rRect )
+void WinMtfClipPath::excludeClipRect( const Rectangle& rRect )
 {
-    if ( aPolyPoly.Count() && ( aPolyPoly.Count() < WIN_MTF_MAX_POLYPOLYCOUNT ) )
-    {
-        Polygon aPolygon( rRect );
-        PolyPolygon aPolyPolyRect( aPolygon );
-        PolyPolygon aDifference;
-        aPolyPoly.GetDifference( aPolyPolyRect, aDifference );
-        aPolyPoly = aDifference;
-    }
-    ImpUpdateType();
+    maClip.subtractRange(
+        vcl::unotools::b2DRectangleFromRectangle(rRect));
 }
 
-void WinMtfClipPath::SetClipPath( const PolyPolygon& rPolyPolygon, sal_Int32 nClippingMode )
+void WinMtfClipPath::setClipPath( const PolyPolygon& rPolyPolygon, sal_Int32 nClippingMode )
 {
-    if ( !rPolyPolygon.Count() )
-        aPolyPoly = rPolyPolygon;
-    else if ( rPolyPolygon.Count() < WIN_MTF_MAX_POLYPOLYCOUNT )
+    const basegfx::B2DPolyPolygon& rB2DPoly=rPolyPolygon.getB2DPolyPolygon();
+    switch ( nClippingMode )
     {
-        PolyPolygon aNewClipPath;
-
-        // #115345# Watch out for empty aPolyPoly here - conceptually,
-        // an empty clip path is a rectangle of infinite size, but it
-        // is represented by an empty aPolyPoly. When intersecting
-        // rPolyPolygon with this _empty_ aPolyPoly, set algebra
-        // guarantees wrong results.
-        switch ( nClippingMode )
-        {
-            case RGN_OR :
-                // #115345# clip stays empty, when ORing an arbitrary
-                // rPolyPolygon. Thus, we can save us the unnecessary
-                // clipper call.
-                if( aPolyPoly.Count() )
-                    aPolyPoly.GetUnion( rPolyPolygon, aNewClipPath );
+        case RGN_OR :
+            maClip.unionPolyPolygon(rB2DPoly);
             break;
-            case RGN_XOR :
-                // TODO:
-                // #115345# Cannot handle this case, for the time being
-                aPolyPoly.GetXOR( rPolyPolygon, aNewClipPath );
+        case RGN_XOR :
+            maClip.xorPolyPolygon(rB2DPoly);
             break;
-            case RGN_DIFF :
-                // TODO:
-                // #115345# Cannot handle this case, for the time being
-                aPolyPoly.GetDifference( rPolyPolygon, aNewClipPath );
+        case RGN_DIFF :
+            maClip.subtractPolyPolygon(rB2DPoly);
             break;
-            case RGN_AND :
-                // #115345# Clip becomes rPolyPolygon, when ANDing
-                // with an arbitrary rPolyPolygon
-                if( aPolyPoly.Count() )
-                    aPolyPoly.GetIntersection( rPolyPolygon, aNewClipPath );
-                else
-                    aNewClipPath = rPolyPolygon;
+        case RGN_AND :
+            maClip.intersectPolyPolygon(rB2DPoly);
             break;
-            case RGN_COPY :
-                aNewClipPath = rPolyPolygon;
+        case RGN_COPY :
+            maClip = basegfx::tools::B2DClipState(rB2DPoly);
             break;
-        }
-        aPolyPoly = aNewClipPath;
     }
-    ImpUpdateType();
 }
 
-void WinMtfClipPath::MoveClipRegion( const Size& rSize )
+void WinMtfClipPath::moveClipRegion( const Size& rSize )
+{
+    // what a weird concept. emulate, don't want this in B2DClipState
+    // API
+    basegfx::B2DPolyPolygon aCurrClip=maClip.getClipPoly();
+    basegfx::B2DHomMatrix aTranslate;
+    aTranslate.translate(rSize.Width(), rSize.Height());
+
+    aCurrClip.transform(aTranslate);
+    maClip = basegfx::tools::B2DClipState( aCurrClip );
+}
+
+basegfx::B2DPolyPolygon WinMtfClipPath::getClipPath() const
 {
-    aPolyPoly.Move( rSize.Width(), rSize.Height() );
-    bNeedsUpdate = sal_True;
+    return maClip.getClipPoly();
 }
 
 // ------------------------------------------------------------------------
@@ -904,31 +864,35 @@ void WinMtfOutput::DeleteObject( sal_Int32 nIndex )
 
 void WinMtfOutput::IntersectClipRect( const Rectangle& rRect )
 {
-    aClipPath.IntersectClipRect( ImplMap( rRect ) );
+    mbClipNeedsUpdate=true;
+    aClipPath.intersectClipRect( ImplMap( rRect ) );
 }
 
 //-----------------------------------------------------------------------------------
 
 void WinMtfOutput::ExcludeClipRect( const Rectangle& rRect )
 {
-    aClipPath.ExcludeClipRect( ImplMap( rRect ) );
+    mbClipNeedsUpdate=true;
+    aClipPath.excludeClipRect( ImplMap( rRect ) );
 }
 
 //-----------------------------------------------------------------------------------
 
 void WinMtfOutput::MoveClipRegion( const Size& rSize )
 {
-    aClipPath.MoveClipRegion( ImplMap( rSize ) );
+    mbClipNeedsUpdate=true;
+    aClipPath.moveClipRegion( ImplMap( rSize ) );
 }
 
 void WinMtfOutput::SetClipPath( const PolyPolygon& rPolyPolygon, sal_Int32 nClippingMode, sal_Bool bIsMapped )
 {
+    mbClipNeedsUpdate=true;
     if ( bIsMapped )
-        aClipPath.SetClipPath( rPolyPolygon, nClippingMode );
+        aClipPath.setClipPath( rPolyPolygon, nClippingMode );
     else
     {
         PolyPolygon aPP( rPolyPolygon );
-        aClipPath.SetClipPath( ImplMap( aPP ), nClippingMode );
+        aClipPath.setClipPath( ImplMap( aPP ), nClippingMode );
     }
 }
 
@@ -950,6 +914,8 @@ WinMtfOutput::WinMtfOutput( GDIMetaFile& rGDIMetaFile ) :
     maActPos			( Point() ),
     mbNopMode			( sal_False ),
     mbFillStyleSelected	( sal_False ),
+    mbClipNeedsUpdate   ( true ),
+    mbComplexClip       ( false ),
     mnGfxMode			( GM_COMPATIBLE ),
     mnMapMode           ( MM_TEXT ),
     mnUnitsPerInch ( 96 ),
@@ -1002,31 +968,25 @@ WinMtfOutput::~WinMtfOutput()
 
 void WinMtfOutput::UpdateClipRegion()
 {
-    if ( aClipPath.bNeedsUpdate )
+    if ( mbClipNeedsUpdate )
     {
-        aClipPath.bNeedsUpdate = sal_False;
+        mbClipNeedsUpdate = false;
+        mbComplexClip = false;
 
         mpGDIMetaFile->AddAction( new MetaPopAction() );                    // taking the orignal clipregion
         mpGDIMetaFile->AddAction( new MetaPushAction( PUSH_CLIPREGION ) );  // 
 
-        switch ( aClipPath.GetType() )
+        // skip for 'no clipping at all' case
+        if( !aClipPath.isEmpty() )
         {
-            case RECTANGLE :
-            case COMPLEX :
-            {
-//				we will not generate a RegionClipRegion Action, because this action
-//				cannot be saved to the wmf format - saving to wmf always happens
-//				if the placeholder graphic for ole objects is generated. (SJ)
-
-//				Region aClipRegion( aClipPath.GetClipPath() );
-//				mpGDIMetaFile->AddAction( new MetaISectRegionClipRegionAction( aClipRegion ) );
-
-                Rectangle aClipRect( aClipPath.GetClipPath().GetBoundRect() );
-                mpGDIMetaFile->AddAction( new MetaISectRectClipRegionAction( aClipRect ) );
-            }
-            break;
-            case EMPTY:
-            break;  // -Wall not handled.
+            const basegfx::B2DPolyPolygon& rClipPoly( aClipPath.getClipPath() );
+            mpGDIMetaFile->AddAction( 
+                new MetaISectRectClipRegionAction( 
+                    vcl::unotools::rectangleFromB2DRectangle(
+                        rClipPoly.getB2DRange())));
+
+            mbComplexClip = rClipPoly.count() > 1 
+                || !basegfx::tools::isRectangle(rClipPoly);
         }
     }
 }
@@ -1205,12 +1165,12 @@ void WinMtfOutput::DrawRect( const Rectangle& rRect, BOOL bEdge )
     UpdateClipRegion();
     UpdateFillStyle();
 
-    if ( aClipPath.GetType() == COMPLEX )
+    if ( mbComplexClip )
     {
         Polygon aPoly( ImplMap( rRect ) );
         PolyPolygon aPolyPolyRect( aPoly );
         PolyPolygon aDest;
-        aClipPath.GetClipPath().GetIntersection( aPolyPolyRect, aDest );
+        PolyPolygon(aClipPath.getClipPath()).GetIntersection( aPolyPolyRect, aDest );
         ImplDrawClippedPolyPolygon( aDest );
     }
     else
@@ -1365,11 +1325,11 @@ void WinMtfOutput::DrawPolygon( Polygon& rPolygon, sal_Bool bRecordPath )
     {
         UpdateFillStyle();
 
-        if ( aClipPath.GetType() == COMPLEX )
+        if ( mbComplexClip )
         {
             PolyPolygon aPolyPoly( rPolygon );
             PolyPolygon aDest;
-            aClipPath.GetClipPath().GetIntersection( aPolyPoly, aDest );
+            PolyPolygon(aClipPath.getClipPath()).GetIntersection( aPolyPoly, aDest );
             ImplDrawClippedPolyPolygon( aDest );
         }
         else
@@ -1441,10 +1401,10 @@ void WinMtfOutput::DrawPolyPolygon( PolyPolygon& rPolyPolygon, sal_Bool bRecordP
     {
         UpdateFillStyle();
 
-        if ( aClipPath.GetType() == COMPLEX )
+        if ( mbComplexClip )
         {
             PolyPolygon aDest;
-            aClipPath.GetClipPath().GetIntersection( rPolyPolygon, aDest );	
+            PolyPolygon(aClipPath.getClipPath()).GetIntersection( rPolyPolygon, aDest );	
             ImplDrawClippedPolyPolygon( aDest );
         }
         else
@@ -1679,7 +1639,7 @@ void WinMtfOutput::DrawText( Point& rPosition, String& rText, sal_Int32* pDXArry
 void WinMtfOutput::ImplDrawBitmap( const Point& rPos, const Size& rSize, const BitmapEx rBitmap )
 {
     BitmapEx aBmpEx( rBitmap );
-    if ( aClipPath.GetType() == COMPLEX )
+    if ( mbComplexClip )
     {
         VirtualDevice aVDev;
         MapMode aMapMode( MAP_100TH_MM );
@@ -1694,7 +1654,7 @@ void WinMtfOutput::ImplDrawBitmap( const Point& rPos, const Size& rSize, const B
         aVDev.SetMapMode( aMapMode );
         aVDev.SetOutputSizePixel( aSizePixel );
         aVDev.SetFillColor( Color( COL_BLACK ) );
-        const PolyPolygon aClip( aClipPath.GetClipPath() );
+        const PolyPolygon aClip( aClipPath.getClipPath() );
         aVDev.DrawPolyPolygon( aClip );
         const Point aEmptyPoint;
 
@@ -2251,7 +2211,7 @@ void WinMtfOutput::Pop()
         if ( ! ( aClipPath == pSave->aClipPath ) )
         {
             aClipPath = pSave->aClipPath;
-            aClipPath.bNeedsUpdate = sal_True;
+            mbClipNeedsUpdate = true;
         }
         if ( meLatestRasterOp != meRasterOp )
             mpGDIMetaFile->AddAction( new MetaRasterOpAction( meRasterOp ) );
diff --git svtools/util/makefile.mk svtools/util/makefile.mk
index 80596d2..e95c557 100644
--- svtools/util/makefile.mk
+++ svtools/util/makefile.mk
@@ -140,6 +140,7 @@ SHL1STDLIBS+= \
         $(VCLLIB)			\
         $(SVLLIB)			\
         $(SOTLIB)			\
+        $(BASEGFXLIB)		\
         $(UNOTOOLSLIB)		\
         $(TOOLSLIB)			\
         $(I18NISOLANGLIB)   \
--- svtools/source/filter.vcl/wmf/winmtf.hxx.orig	2010-03-10 11:15:14.000000000 +0100
+++ svtools/source/filter.vcl/wmf/winmtf.hxx	2010-03-10 11:16:27.000000000 +0100
@@ -48,6 +48,7 @@
 #include <vcl/graph.hxx>
 #include <vcl/virdev.hxx>
 #include <tools/poly.hxx>
+#include <basegfx/tools/b2dclipstate.hxx>
 #include <vcl/font.hxx>
 #include <vcl/bmpacc.hxx>
 #include <vcl/lineinfo.hxx>
@@ -312,34 +313,26 @@
 void WinMtfAssertHandler( const sal_Char*, sal_uInt32 nFlags = WIN_MTF_ASSERT_MIFE );
 #endif 
 
-enum WinMtfClipPathType{ EMPTY, RECTANGLE, COMPLEX };
-
 class WinMtfClipPath
 {
-        PolyPolygon			aPolyPoly;
-        WinMtfClipPathType	eType;
-
-        void		ImpUpdateType();
-
-    public :
-
-        sal_Bool	bNeedsUpdate;
-
-                    WinMtfClipPath(): eType(EMPTY), bNeedsUpdate( sal_False ){};
+    basegfx::tools::B2DClipState maClip;
 
-        void		SetClipPath( const PolyPolygon& rPolyPolygon, sal_Int32 nClippingMode );
-        void		IntersectClipRect( const Rectangle& rRect );
-        void		ExcludeClipRect( const Rectangle& rRect );
-        void		MoveClipRegion( const Size& rSize );
+public :
+    WinMtfClipPath(): maClip() {};
 
-        WinMtfClipPathType GetType() const { return eType; };
-        const PolyPolygon& GetClipPath() const { return aPolyPoly; };
+    void		setClipPath( const PolyPolygon& rPolyPolygon, sal_Int32 nClippingMode );
+    void		intersectClipRect( const Rectangle& rRect );
+    void		excludeClipRect( const Rectangle& rRect );
+    void		moveClipRegion( const Size& rSize );
 
-        sal_Bool operator==( const WinMtfClipPath& rPath )
-        {
-            return  ( rPath.eType == eType ) &&
-                    ( rPath.aPolyPoly == aPolyPoly );
-        };
+    bool isEmpty() const { return maClip.isCleared(); }
+    
+    basegfx::B2DPolyPolygon getClipPath() const;
+    
+    bool operator==( const WinMtfClipPath& rPath ) const
+    {
+        return maClip == rPath.maClip;
+    };
 };
 
 class WinMtfPathObj : public PolyPolygon
@@ -585,6 +578,8 @@
         sal_uInt32          mnRop;
         sal_Bool            mbNopMode;
         sal_Bool			mbFillStyleSelected;
+        sal_Bool            mbClipNeedsUpdate;
+        sal_Bool            mbComplexClip;
 
         std::vector< SaveStructPtr > vSaveStack;
 
