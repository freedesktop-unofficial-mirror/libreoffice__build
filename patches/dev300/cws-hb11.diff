cvs [diff aborted]: connect to localhost(127.0.0.1):2401 failed: Connection refused
Fatal error, aborting.
rene: no such user
Index: sw/inc/pam.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/pam.hxx,v
retrieving revision 1.19
retrieving revision 1.19.172.1
diff -u -p -u -p -b -w -B -r1.19 -r1.19.172.1
--- sw/inc/pam.hxx	10 Apr 2008 11:29:10 -0000	1.19
+++ sw/inc/pam.hxx	19 Sep 2008 10:58:39 -0000	1.19.172.1
@@ -251,6 +251,8 @@ public:
     BOOL ContainsPosition(const SwPosition & rPos) 
     { return *Start() <= rPos && rPos <= *End(); }
 
+    static BOOL Overlap(const SwPaM & a, const SwPaM & b);
+
 	DECL_FIXEDMEMPOOL_NEWDEL(SwPaM);
 
     String GetTxt() const;
Index: sw/source/core/crsr/pam.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/crsr/pam.cxx,v
retrieving revision 1.23
retrieving revision 1.23.12.1
diff -u -p -u -p -b -w -B -r1.23 -r1.23.12.1
--- sw/source/core/crsr/pam.cxx	8 Sep 2008 07:50:44 -0000	1.23
+++ sw/source/core/crsr/pam.cxx	19 Sep 2008 10:58:40 -0000	1.23.12.1
@@ -1149,3 +1149,8 @@ String SwPaM::GetTxt() const
 
     return aResult;
 }
+
+BOOL SwPaM::Overlap(const SwPaM & a, const SwPaM & b) 
+{
+    return !(*b.End() <= *a.Start() || *a.End() <= *b.End());
+}
Index: sw/source/core/doc/dbgoutsw.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/dbgoutsw.cxx,v
retrieving revision 1.27
retrieving revision 1.27.18.1
diff -u -p -u -p -b -w -B -r1.27 -r1.27.18.1
--- sw/source/core/doc/dbgoutsw.cxx	11 Jul 2008 14:13:26 -0000	1.27
+++ sw/source/core/doc/dbgoutsw.cxx	17 Sep 2008 16:04:52 -0000	1.27.18.1
@@ -540,51 +540,53 @@ String lcl_dbg_out(const SwNode & rNode)
 {
     String aTmpStr;
 
-    aTmpStr += String("[ Idx: ", RTL_TEXTENCODING_ASCII_US);
+    aTmpStr += String("<node ", RTL_TEXTENCODING_ASCII_US);
+    aTmpStr += String("index =\"", RTL_TEXTENCODING_ASCII_US);
     aTmpStr += String::CreateFromInt32(rNode.GetIndex());
+    aTmpStr += String("\"", RTL_TEXTENCODING_ASCII_US);
 
 #ifndef PRODUCT
-    aTmpStr += String("(", RTL_TEXTENCODING_ASCII_US);
+    aTmpStr += String(" serial=\"", RTL_TEXTENCODING_ASCII_US);
     aTmpStr += String::CreateFromInt32(rNode.GetSerial());
-    aTmpStr += String(")", RTL_TEXTENCODING_ASCII_US);
+    aTmpStr += String("\"", RTL_TEXTENCODING_ASCII_US);
 #endif
 
-    aTmpStr += String(" ", RTL_TEXTENCODING_ASCII_US);
+    aTmpStr += String(" pointer=\"", RTL_TEXTENCODING_ASCII_US);
 
     char aBuffer[128];
     sprintf(aBuffer, "%p", &rNode);
     aTmpStr += String(aBuffer, RTL_TEXTENCODING_ASCII_US);
 
+    aTmpStr += String(">", RTL_TEXTENCODING_ASCII_US);
+
     const SwTxtNode * pTxtNode = rNode.GetTxtNode();
 
-    if (rNode.IsStartNode())
-        aTmpStr += String(" Start", RTL_TEXTENCODING_ASCII_US);
-    else if (rNode.IsEndNode())
-        aTmpStr += String(" End", RTL_TEXTENCODING_ASCII_US);
-    else if (rNode.IsTxtNode())
+    if (rNode.IsTxtNode())
     {
         const SfxItemSet * pAttrSet = pTxtNode->GetpSwAttrSet();
 
-        aTmpStr += String(" Txt ", RTL_TEXTENCODING_ASCII_US);
+        aTmpStr += String("<txt>", RTL_TEXTENCODING_ASCII_US);
         aTmpStr += pTxtNode->GetTxt().Copy(0, 10);
 
         if (rNode.IsTableNode())
-            aTmpStr += String(" Tbl", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<tbl/>", RTL_TEXTENCODING_ASCII_US);
 
-        aTmpStr += String(" olvl:", RTL_TEXTENCODING_ASCII_US);
+        aTmpStr += String("<outlinelevel>", RTL_TEXTENCODING_ASCII_US);
         aTmpStr += String::CreateFromInt32(pTxtNode->GetOutlineLevel());
+        aTmpStr += String("</outlinelevel>", RTL_TEXTENCODING_ASCII_US);
 
 		const SwNumRule * pNumRule = pTxtNode->GetNumRule();
 
 		if (pNumRule != NULL)
 		{
-			aTmpStr += String(" Num: ", RTL_TEXTENCODING_ASCII_US);
+			aTmpStr += String("<number>", RTL_TEXTENCODING_ASCII_US);
             if ( pTxtNode->GetNum() )
             {
                 aTmpStr += lcl_dbg_out(*(pTxtNode->GetNum()));
             }
+			aTmpStr += String("</number>", RTL_TEXTENCODING_ASCII_US);
 
-            aTmpStr += String(" Rule: ", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<rule>", RTL_TEXTENCODING_ASCII_US);
             aTmpStr += pNumRule->GetName();
 
             const SfxPoolItem * pItem = NULL;
@@ -600,26 +602,28 @@ String lcl_dbg_out(const SwNode & rNode)
             }
 
             const SwNumFmt * pNumFmt = NULL;
+            aTmpStr += String("</rule>", RTL_TEXTENCODING_ASCII_US);
 
             if (pTxtNode->GetActualListLevel() > 0)
                 pNumFmt = pNumRule->GetNumFmt( static_cast< USHORT >(pTxtNode->GetActualListLevel()) );
 
             if (pNumFmt)
             {
-                aTmpStr += String(" NumFmt: ", RTL_TEXTENCODING_ASCII_US);
+                aTmpStr += String("<numformat>", RTL_TEXTENCODING_ASCII_US);
                 aTmpStr +=
                     lcl_dbg_out_NumType(pNumFmt->GetNumberingType());
+                aTmpStr += String("</numformat>", RTL_TEXTENCODING_ASCII_US);
             }
 		}
 
         if (pTxtNode->IsCountedInList())
-            aTmpStr += String(" counted", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<counted/>", RTL_TEXTENCODING_ASCII_US);
 
         SwFmtColl * pColl = pTxtNode->GetFmtColl();
 
         if (pColl)
         {
-            aTmpStr += String(" Coll: ", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<coll>", RTL_TEXTENCODING_ASCII_US);
             aTmpStr += pColl->GetName();
 
             aTmpStr += String("(", RTL_TEXTENCODING_ASCII_US);
@@ -637,27 +641,31 @@ String lcl_dbg_out(const SwNode & rNode)
                 aTmpStr += sNumruleName;
             }
             aTmpStr += String(")", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<coll>", RTL_TEXTENCODING_ASCII_US);
         }
 
         SwFmtColl * pCColl = pTxtNode->GetCondFmtColl();
 
         if (pCColl)
         {
-            aTmpStr += String(" CCOll: ", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<ccoll>", RTL_TEXTENCODING_ASCII_US);
             aTmpStr += pCColl->GetName();
+            aTmpStr += String("</ccoll>", RTL_TEXTENCODING_ASCII_US);
         }
 
-        aTmpStr += String(", Frms: ", RTL_TEXTENCODING_ASCII_US);
+        aTmpStr += String("<frms>", RTL_TEXTENCODING_ASCII_US);
         aTmpStr += lcl_AnchoredFrames(rNode);
+        aTmpStr += String("</frms>", RTL_TEXTENCODING_ASCII_US);
 
         if (bDbgOutPrintAttrSet)
         {
-            aTmpStr += String(" Attrs: ", RTL_TEXTENCODING_ASCII_US);
+            aTmpStr += String("<attrs>", RTL_TEXTENCODING_ASCII_US);
             aTmpStr += lcl_dbg_out(pTxtNode->GetSwAttrSet());
+            aTmpStr += String("</attrs>", RTL_TEXTENCODING_ASCII_US);
         }
     }
 
-    aTmpStr += String(" ]", RTL_TEXTENCODING_ASCII_US);
+    aTmpStr += String("</node>", RTL_TEXTENCODING_ASCII_US);
 
     return aTmpStr;
 }
@@ -705,15 +713,23 @@ BOOL lcl_dbg_add_node(const SwNodePtr & 
 
 String lcl_dbg_out(SwNodes & rNodes)
 {
-    String aStr("[\n", RTL_TEXTENCODING_ASCII_US);
+    String aStr("<nodes>", RTL_TEXTENCODING_ASCII_US);
 
     for (ULONG i = 0; i < rNodes.Count(); i++)
     {
-        aStr += lcl_dbg_out(*rNodes[i]);
+        SwNode * pNode = rNodes[i];
+        
+        if (pNode->IsEndNode())
+            aStr += String("</nodes>\n", RTL_TEXTENCODING_ASCII_US);
+            
+        aStr += lcl_dbg_out(*pNode);
         aStr += String("\n", RTL_TEXTENCODING_ASCII_US);
+        
+        if (pNode->IsStartNode())
+            aStr += String("<nodes>", RTL_TEXTENCODING_ASCII_US);
     }
 
-    aStr += String("]\n", RTL_TEXTENCODING_ASCII_US);
+    aStr += String("</nodes>\n", RTL_TEXTENCODING_ASCII_US);
 
     return aStr;
 }
Index: sw/source/filter/ww8/WW8TableInfo.cxx
===================================================================
RCS file: sw/source/filter/ww8/WW8TableInfo.cxx
diff -N sw/source/filter/ww8/WW8TableInfo.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sw/source/filter/ww8/WW8TableInfo.cxx	24 Sep 2008 09:44:15 -0000	1.1.2.4
@@ -0,0 +1,303 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include <iostream> 
+#include "WW8TableInfo.hxx"
+#include "swtable.hxx"
+#include "pam.hxx"
+#include "ndtxt.hxx"
+
+namespace ww8 
+{
+// WW8TableTextNodeInfo
+
+WW8TableTextNodeInfo::WW8TableTextNodeInfo(const SwTxtNode * pTxtNode, 
+                                           const SwTableBox * pTableBox,
+                                           const SwTable * pTable)
+    :mnDepth(0), mbEndOfLine(false), mbEndOfCell(false), 
+    mpTxtNode(pTxtNode), mpTableBox(pTableBox), mpTable(pTable)
+{
+}
+
+WW8TableTextNodeInfo::~WW8TableTextNodeInfo()
+{
+}
+
+::std::string WW8TableTextNodeInfo::toString() const
+{
+    ::std::string sResult = "<tableTextNodeInfo depth=\"";
+    static char buffer[256];
+    snprintf(buffer, sizeof(buffer), "%" SAL_PRIxUINT32, mnDepth);
+    sResult += buffer;
+    sResult += "\" endOfLine=\"";
+    sResult += mbEndOfLine ? "yes" : "no";
+    sResult += "\" endOfCell=\"";
+    sResult += mbEndOfCell ? "yes" : "no";
+    sResult += "\">";
+    
+    ByteString aStr(mpTxtNode->GetTxt(), RTL_TEXTENCODING_ASCII_US);
+    sResult += aStr.GetBuffer();
+    
+    sResult +="</tableTextNodeInfo>";
+    
+    return sResult;
+}
+
+void WW8TableTextNodeInfo::setDepth(sal_uInt32 nDepth)
+{
+    mnDepth = nDepth;
+}
+
+void WW8TableTextNodeInfo::setEndOfLine(bool bEndOfLine)
+{
+    mbEndOfLine = bEndOfLine;
+}
+
+void WW8TableTextNodeInfo::setEndOfCell(bool bEndOfCell)
+{
+    mbEndOfCell = bEndOfCell;
+}
+
+void WW8TableTextNodeInfo::setTableBox(const SwTableBox * pTableBox)
+{
+    mpTableBox = pTableBox;
+}
+
+void WW8TableTextNodeInfo::setTable(const SwTable * pTable)
+{
+    mpTable = pTable;
+}
+
+void WW8TableTextNodeInfo::setCell(sal_uInt32 nCell)
+{
+    mnCell = nCell;
+}
+
+void WW8TableTextNodeInfo::setRow(sal_uInt32 nRow)
+{
+    mnRow = nRow;
+}
+
+sal_uInt32 WW8TableTextNodeInfo::getDepth() const
+{
+    return mnDepth;
+}
+
+const SwTxtNode * WW8TableTextNodeInfo::getTextNode() const
+{
+    return mpTxtNode;
+}
+
+const SwTableBox * WW8TableTextNodeInfo::getTableBox() const
+{
+    return mpTableBox;
+}
+
+const SwTable * WW8TableTextNodeInfo::getTable() const
+{
+    return mpTable;
+}
+
+bool WW8TableTextNodeInfo::isEndOfLine() const
+{
+    return mbEndOfLine;
+}
+
+bool WW8TableTextNodeInfo::isEndOfCell() const
+{
+    return mbEndOfCell;
+}
+
+sal_uInt32 WW8TableTextNodeInfo::getCell() const
+{
+    return mnCell;
+}
+    
+sal_uInt32 WW8TableTextNodeInfo::getRow() const
+{
+    return mnRow;
+}
+    
+    
+// WW8TableInfo
+
+WW8TableInfo::WW8TableInfo()
+{
+}
+
+WW8TableInfo::~WW8TableInfo()
+{
+}
+
+void WW8TableInfo::processSwTable(const SwTable * pTable)
+{
+#ifdef DEBUG 
+    ::std::clog << "<processSwTable>" << ::std::endl;
+#endif
+
+    const SwTableLines & rLines = pTable->GetTabLines();
+    
+    for (USHORT n = 0; n < rLines.Count(); n++)
+    {
+        const SwTableLine * pLine = rLines[n];
+        
+        processTableLine(pTable, pLine, n, 1);
+    }
+    
+#ifdef DEBUG
+    ::std::clog << "</processSwTable>" << ::std::endl;
+#endif
+}
+
+void WW8TableInfo::processTableLine(const SwTable * pTable, 
+                                    const SwTableLine * pTableLine, 
+                                    sal_uInt32 nRow,
+                                    sal_uInt32 nDepth)
+{
+#ifdef DEBUG
+    ::std::clog << "<processTableLine row=\"" << nRow << "\" depth=\"" 
+    << nDepth << "\">" << ::std::endl;
+#endif
+
+    const SwTableBoxes & rBoxes = pTableLine->GetTabBoxes();
+    
+    WW8TableTextNodeInfo::Pointer_t pTextNodeInfo;
+    
+    for (USHORT n = 0; n < rBoxes.Count(); n++)
+    {
+        const SwTableBox * pBox = rBoxes[n];
+        
+        pTextNodeInfo = processTableBox(pTable, pBox, nRow, n, nDepth);
+    } 
+    
+    if (pTextNodeInfo.get() != NULL)
+        pTextNodeInfo->setEndOfLine(true);
+        
+#ifdef DEBUG
+    ::std::clog << "</processTableLine>" << ::std::endl;
+#endif
+} 
+
+WW8TableTextNodeInfo::Pointer_t 
+WW8TableInfo::processTableBox(const SwTable * pTable, 
+                              const SwTableBox * pBox, 
+                              sal_uInt32 nRow,
+                              sal_uInt32 nCell,
+                              sal_uInt32 nDepth)
+{
+#ifdef DEBUG
+    ::std::clog << "<processTableBox row=\"" << nRow << "\" cell=\"" << nCell
+    << "\" depth=\"" << nDepth << "\">" << ::std::endl;
+#endif
+
+    WW8TableTextNodeInfo::Pointer_t pTextNodeInfo;
+    const SwTableLines & rLines = pBox->GetTabLines();
+
+    if (rLines.Count() > 0)
+    {
+        
+        for (sal_uInt32 n = 0; n < rLines.Count(); n++)
+        {
+            const SwTableLine * pLine = rLines[n];
+            
+            processTableLine(pTable, pLine, n, nDepth + 1);
+        }
+    }
+    else
+    {        
+        const SwStartNode * pSttNd = pBox->GetSttNd();
+        SwPaM aPaM(*pSttNd, 0);
+        
+        bool bDone = false;
+        do
+        {
+            SwNode & rNode = aPaM.GetPoint()->nNode.GetNode();
+            
+            if (rNode.IsEndNode())
+            {
+                SwEndNode * pEndNode = dynamic_cast<SwEndNode *> (&rNode);
+                SwStartNode * pTmpSttNd = pEndNode->StartOfSectionNode();
+                
+                if (pTmpSttNd == pSttNd)
+                    bDone = true;
+            }
+            
+            if (! bDone)
+            {
+                if (rNode.IsTxtNode())
+                {           
+                    SwTxtNode * pTxtNode = dynamic_cast<SwTxtNode *>(&rNode);
+                    pTextNodeInfo = getTableTextNodeInfo(pTxtNode);
+                    
+                    if (pTextNodeInfo.get() == NULL)
+                    {
+                        pTextNodeInfo = WW8TableTextNodeInfo::Pointer_t
+                        (new WW8TableTextNodeInfo(pTxtNode, pBox, pTable));
+                        mMap.insert(Map_t::value_type(pTxtNode, pTextNodeInfo));
+                    }
+                    else
+                    {
+                        pTextNodeInfo->setTable(pTable);
+                        pTextNodeInfo->setTableBox(pBox);
+                    }
+                    
+                    pTextNodeInfo->setDepth(nDepth + pTextNodeInfo->getDepth());
+                    pTextNodeInfo->setCell(nCell);
+                    pTextNodeInfo->setRow(nRow);
+                }
+                
+                aPaM.GetPoint()->nNode++;
+            }
+        }
+        while (!bDone);
+        
+        if (pTextNodeInfo.get() != NULL)
+            pTextNodeInfo->setEndOfCell(true);
+    }       
+#ifdef DEBUG
+    ::std::clog << "</processTableBox>" << ::std::endl;
+#endif
+        
+    return pTextNodeInfo;        
+}
+
+WW8TableTextNodeInfo::Pointer_t WW8TableInfo::getTableTextNodeInfo
+(const SwTxtNode * pNode)
+{
+    WW8TableTextNodeInfo::Pointer_t pResult;
+    Map_t::iterator aIt = mMap.find(pNode);
+    
+    if (aIt != mMap.end())
+        pResult = (*aIt).second;
+    
+    return pResult;
+}
+
+}
Index: sw/source/filter/ww8/WW8TableInfo.hxx
===================================================================
RCS file: sw/source/filter/ww8/WW8TableInfo.hxx
diff -N sw/source/filter/ww8/WW8TableInfo.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sw/source/filter/ww8/WW8TableInfo.hxx	27 Aug 2008 12:25:58 -0000	1.1.2.3
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+ 
+#ifndef WW8_TABLE_INFO_HXX
+#define WW8_TABLE_INFO_HXX
+#include <hash_map>
+#include <string>
+#include <boost/shared_ptr.hpp>
+#include <sal/types.h>
+
+class SwTable;
+class SwTableLine;
+class SwTableBox;
+class SwTxtNode;
+class SwWW8Writer;
+
+namespace ww8
+{
+using namespace ::std;
+ 
+class WW8TableTextNodeInfo
+{
+    sal_uInt32 mnDepth;
+    sal_uInt32 mnCell;
+    sal_uInt32 mnRow;
+    bool mbEndOfLine;
+    bool mbEndOfCell;
+    const SwTxtNode * mpTxtNode;
+    const SwTableBox * mpTableBox;
+    const SwTable * mpTable;    
+    
+ public:
+    typedef boost::shared_ptr<WW8TableTextNodeInfo> Pointer_t;
+    
+    WW8TableTextNodeInfo(const SwTxtNode * pTxtNode, 
+                         const SwTableBox * pTableBox, 
+                         const SwTable * pTable);
+    virtual ~WW8TableTextNodeInfo();
+    
+    void setDepth(sal_uInt32 nDepth);
+    void setEndOfLine(bool bEndOfLine);
+    void setEndOfCell(bool bEndOfCell);
+    void setTableBox(const SwTableBox *pTableBox);
+    void setTable(const SwTable * pTable);
+    void setCell(sal_uInt32 nCell);
+    void setRow(sal_uInt32 nRow);
+    
+    sal_uInt32 getDepth() const;
+    const SwTxtNode * getTextNode() const;
+    const SwTableBox * getTableBox() const;
+    const SwTable * getTable() const;
+    bool isEndOfLine() const;
+    bool isEndOfCell() const;
+    sal_uInt32 getCell() const;
+    sal_uInt32 getRow() const;
+    
+    ::std::string toString() const;
+};
+ 
+struct hashTxtNode
+{
+    size_t operator()(const SwTxtNode * pNode) const 
+    { return reinterpret_cast<size_t>(pNode); }
+};
+    
+class WW8TableInfo
+{
+    typedef hash_map<const SwTxtNode *, WW8TableTextNodeInfo::Pointer_t, hashTxtNode > Map_t;
+    Map_t mMap;
+
+    void processTableLine(const SwTable * pTable, 
+                          const SwTableLine * pTableLine,
+                          sal_uInt32 nRow, 
+                          sal_uInt32 nDepth);
+
+    WW8TableTextNodeInfo::Pointer_t 
+    processTableBox(const SwTable * pTable,
+                    const SwTableBox * pTableBox,
+                    sal_uInt32 nRow,
+                    sal_uInt32 nCell, 
+                    sal_uInt32 nDepth);
+    
+public: 
+    typedef boost::shared_ptr<WW8TableInfo> Pointer_t;
+
+    WW8TableInfo();
+    virtual ~WW8TableInfo();
+    
+    void processSwTable(const SwTable * pTable);
+    WW8TableTextNodeInfo::Pointer_t getTableTextNodeInfo(const SwTxtNode * pNode);
+};
+ 
+}
+#endif // WW8_TABLE_INFO_HXX
Index: sw/source/filter/ww8/makefile.mk
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/makefile.mk,v
retrieving revision 1.23
retrieving revision 1.22.172.2
diff -u -p -u -p -b -w -B -r1.23 -r1.22.172.2
--- sw/source/filter/ww8/makefile.mk	4 Sep 2008 09:34:18 -0000	1.23
+++ sw/source/filter/ww8/makefile.mk	12 Sep 2008 08:55:32 -0000	1.22.172.2
@@ -67,6 +67,7 @@ EXCEPTIONSFILES = \
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/ww8scan.obj \
+        $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/WW8FFData.obj
 
 
@@ -93,6 +94,7 @@ SLOFILES =	\
 		$(SLO)$/ww8scan.obj \
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
+        $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/WW8FFData.obj
 
 
Index: sw/source/filter/ww8/wrtw8esh.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtw8esh.cxx,v
retrieving revision 1.105
retrieving revision 1.105.10.1
diff -u -p -u -p -b -w -B -r1.105 -r1.105.10.1
--- sw/source/filter/ww8/wrtw8esh.cxx	4 Sep 2008 09:34:23 -0000	1.105
+++ sw/source/filter/ww8/wrtw8esh.cxx	15 Sep 2008 13:24:38 -0000	1.105.10.1
@@ -223,23 +223,23 @@ void SwWW8Writer::DoComboBox(const rtl::
     OutField(0, ww::eFORMDROPDOWN, FieldString(ww::eFORMDROPDOWN),
              WRITEFIELD_CLOSE);
     
-    ::sw::WW8FFData * pFFData = new ::sw::WW8FFData();
+    ::sw::WW8FFData aFFData;
     
-    pFFData->setType(2); 
-    pFFData->setName(rName);
-    pFFData->setHelp(rHelp);
-    pFFData->setStatus(rToolTip);
+    aFFData.setType(2); 
+    aFFData.setName(rName);
+    aFFData.setHelp(rHelp);
+    aFFData.setStatus(rToolTip);
     
     sal_uInt32 nListItems = rListItems.getLength();
     
     for (sal_uInt32 i = 0; i < nListItems; i++)
     {
         if (i < 0x20 && rSelected == rListItems[i])
-            pFFData->setResult(::sal::static_int_cast<sal_uInt8>(i));
-        pFFData->addListboxEntry(rListItems[i]);
+            aFFData.setResult(::sal::static_int_cast<sal_uInt8>(i));
+        aFFData.addListboxEntry(rListItems[i]);
     }
         
-    pFFData->Write(pDataStrm);    
+    aFFData.Write(pDataStrm);    
 
 }
 
@@ -268,10 +268,10 @@ void SwWW8Writer::DoCheckBox(uno::Refere
     pChpPlc->AppendFkpEntry(Strm().Tell(),
                 sizeof( aArr1 ), aArr1 );
                 
-    ::sw::WW8FFData * pFFData = new ::sw::WW8FFData();
+    ::sw::WW8FFData aFFData;
     
-    pFFData->setType(1);
-    pFFData->setCheckboxHeight(0x14);
+    aFFData.setType(1);
+    aFFData.setCheckboxHeight(0x14);
     
     sal_Int16 nTemp = 0;
     xPropSet->getPropertyValue(C2U("DefaultState")) >>= nTemp;
@@ -285,10 +285,10 @@ void SwWW8Writer::DoCheckBox(uno::Refere
         switch (nIsChecked)
         {
             case false:
-                pFFData->setResult(0);
+                aFFData.setResult(0);
                 break;
             case true:
-                pFFData->setResult(1);
+                aFFData.setResult(1);
                 break;
             default:
                 ASSERT(!this, "how did that happen");
@@ -300,23 +300,23 @@ void SwWW8Writer::DoCheckBox(uno::Refere
     if (xPropSetInfo->hasPropertyByName(sName))
     {
         xPropSet->getPropertyValue(sName) >>= aStr;
-        pFFData->setName(aStr);
+        aFFData.setName(aStr);
     }
 
     static ::rtl::OUString sHelpText(C2U("HelpText"));
     if (xPropSetInfo->hasPropertyByName(sHelpText))
     {
         xPropSet->getPropertyValue(sHelpText) >>= aStr;
-        pFFData->setHelp(aStr);
+        aFFData.setHelp(aStr);
     }
     static ::rtl::OUString sHelpF1Text(C2U("HelpF1Text"));
     if (xPropSetInfo->hasPropertyByName(sHelpF1Text))
     {
         xPropSet->getPropertyValue(sHelpF1Text) >>= aStr;
-        pFFData->setStatus(aStr);
+        aFFData.setStatus(aStr);
     }
 
-    pFFData->Write(pDataStrm);
+    aFFData.Write(pDataStrm);
 
     OutField(0, ww::eFORMCHECKBOX, aEmptyStr, WRITEFIELD_CLOSE);
 }
@@ -343,13 +343,13 @@ void SwWW8Writer::DoFormText(const SwInp
     pChpPlc->AppendFkpEntry(Strm().Tell(),
                 sizeof( aArr1 ), aArr1 );
 
-    ::sw::WW8FFData * pFFData = new ::sw::WW8FFData();
+    ::sw::WW8FFData aFFData;
     
-    pFFData->setType(0);
-    pFFData->setName(pFld->GetPar2());
-    pFFData->setHelp(pFld->GetHelp());
-    pFFData->setStatus(pFld->GetToolTip());
-    pFFData->Write(pDataStrm);
+    aFFData.setType(0);
+    aFFData.setName(pFld->GetPar2());
+    aFFData.setHelp(pFld->GetHelp());
+    aFFData.setStatus(pFld->GetToolTip());
+    aFFData.Write(pDataStrm);
 
     OutField(0, ww::eFORMTEXT, aEmptyStr, WRITEFIELD_CMD_END);
 
Index: sw/source/filter/ww8/wrtw8nds.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtw8nds.cxx,v
retrieving revision 1.110
retrieving revision 1.109.40.7
diff -u -p -u -p -b -w -B -r1.110 -r1.109.40.7
--- sw/source/filter/ww8/wrtw8nds.cxx	4 Sep 2008 10:24:31 -0000	1.110
+++ sw/source/filter/ww8/wrtw8nds.cxx	12 Sep 2008 08:55:22 -0000	1.109.40.7
@@ -38,6 +38,7 @@
 #include <utility>
 #include <algorithm>
 #include <functional>
+#include <iostream>
 #include <hintids.hxx>
 #include <tools/urlobj.hxx>
 #include <svx/boxitem.hxx>
@@ -941,8 +942,22 @@ void WW8_AttrIter::StartURL(const String
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
         };
 
+        // save the links to files as relative
+        sURL = URIHelper::simpleNormalizedMakeRelative( rWrt.GetBaseURL(), sURL );
+        if ( sURL.EqualsAscii( "/", 0, 1 ) )
         sURL = aURL.PathToFileName();
 
+        // special case for the absolute windows names
+        // (convert '/c:/foo/bar.doc' into 'c:\foo\bar.doc')
+        sal_Unicode aDrive = ( sURL.Len() > 1 )? sURL.GetChar( 1 ): 0;
+        if ( sURL.EqualsAscii( "/", 0, 1 ) &&
+             ( ( aDrive >= 'A' && aDrive <= 'Z' ) || ( aDrive >= 'a' && aDrive <= 'z' ) ) &&
+             sURL.EqualsAscii( ":", 2, 1 ) )
+        {
+            sURL.Erase( 0, 1 );
+            sURL.SearchAndReplaceAll( '/', '\\' );
+        }
+
         rWrt.pDataStrm->Write( MAGIC_C, sizeof(MAGIC_C) );
         SwWW8Writer::WriteLong( *rWrt.pDataStrm, sURL.Len()+1 );
         SwWW8Writer::WriteString8( *rWrt.pDataStrm, sURL, true,
@@ -1437,6 +1452,10 @@ SwTxtFmtColl& lcl_getFormatCollection( W
 
 Writer& OutWW8_SwTxtNode( Writer& rWrt, SwCntntNode& rNode )
 {
+#ifdef DEBUG
+    ::std::clog << "<OutWW8_SwTxtNode>" << ::std::endl;
+#endif
+
     SwWW8Writer& rWW8Wrt = (SwWW8Writer&)rWrt;
     SwTxtNode* pNd = &((SwTxtNode&)rNode);
 
@@ -1494,6 +1513,9 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, 
 
     String aStr( pNd->GetTxt() );
 
+    ww8::WW8TableTextNodeInfo::Pointer_t pTextNodeInfo = 
+    rWW8Wrt.mpTableInfo->getTableTextNodeInfo(pNd);
+        
     xub_StrLen nAktPos = 0;
     xub_StrLen nEnd = aStr.Len();
     bool bUnicode = rWW8Wrt.bWrtWW8, bRedlineAtEnd = false;
@@ -1625,7 +1647,16 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, 
                 }
             }
 
-            rWW8Wrt.WriteCR();
+            rWW8Wrt.WriteCR(pTextNodeInfo);
+
+			if (pTextNodeInfo.get() != NULL)
+    		{ 
+#ifdef DEBUG            
+        		::std::clog << pTextNodeInfo->toString() << ::std::endl;
+#endif
+
+        		rWW8Wrt.OutWW8TableInfoCell(pTextNodeInfo);        
+    		}
 
             rWW8Wrt.pPapPlc->AppendFkpEntry( rWrt.Strm().Tell(), pO->Count(),
                 pO->GetData() );
@@ -1691,7 +1722,7 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, 
                         rWW8Wrt.pop_charpropstart();
                         rWW8Wrt.EndTOX(*pTOXSect);
                     }
-                    rWW8Wrt.WriteCR();              // CR danach
+                    rWW8Wrt.WriteCR(pTextNodeInfo);              // CR danach
                 }
             }
         }
@@ -1734,7 +1765,7 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, 
                     rWW8Wrt.EndTOX( *pTOXSect );
                 }
 
-                rWW8Wrt.WriteCR();              // CR danach
+                rWW8Wrt.WriteCR(pTextNodeInfo);              // CR danach
 
                 if( bRedlineAtEnd )
                 {
@@ -1761,14 +1792,13 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, 
     if (rWW8Wrt.mpParentFrame && !rWW8Wrt.bIsInTable)    // Fly-Attrs
         rWW8Wrt.Out_SwFmt(rWW8Wrt.mpParentFrame->GetFrmFmt(), false, false, true);
 
-    if( rWW8Wrt.bOutTable )
-    {                                               // Tab-Attr
-        // sprmPFInTable
-        if( rWW8Wrt.bWrtWW8 )
-            SwWW8Writer::InsUInt16( *pO, 0x2416 );
-        else
-            pO->Insert( 24, pO->Count() );
-        pO->Insert( 1, pO->Count() );
+    if (pTextNodeInfo.get() != NULL)
+    { 
+#ifdef DEBUG
+        ::std::clog << pTextNodeInfo->toString() << ::std::endl;
+#endif
+
+        rWW8Wrt.OutWW8TableInfoCell(pTextNodeInfo);        
     }
 
     if( !bFlyInTable )
@@ -2051,6 +2081,25 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, 
     rWW8Wrt.pPapPlc->AppendFkpEntry( rWrt.Strm().Tell(), pO->Count(),
         pO->GetData() );
     pO->Remove( 0, pO->Count() );                       // leeren
+    
+    if (pTextNodeInfo.get() != NULL)
+    {         
+        if (pTextNodeInfo->isEndOfLine())
+        {
+            rWW8Wrt.WriteRowEnd(pTextNodeInfo->getDepth());
+            
+            pO->Insert( (BYTE*)&nSty, 2, pO->Count() );     // Style #
+            rWW8Wrt.OutWW8TableInfoRow(pTextNodeInfo);
+            rWW8Wrt.pPapPlc->AppendFkpEntry( rWrt.Strm().Tell(), pO->Count(),
+                                            pO->GetData() );
+            pO->Remove( 0, pO->Count() );                       // leeren
+        }
+    }
+
+#ifdef DEBUG
+    ::std::clog << "</OutWW8_SwTxtNode>" << ::std::endl;
+#endif
+
     return rWrt;
 }
 
@@ -2178,523 +2227,6 @@ bool RowContainsProblematicGraphic(const
 //       Tabellen
 //---------------------------------------------------------------------------
 
-Writer& OutWW8_SwTblNode( Writer& rWrt, SwTableNode & rNode )
-{
-    SwWW8Writer & rWW8Wrt = (SwWW8Writer&)rWrt;
-    SwTable& rTbl = rNode.GetTable();
-    const bool bNewTableModel = rTbl.IsNewModel();
-
-    const SwFrmFmt *pFmt = rTbl.GetFrmFmt();
-    ASSERT(pFmt,"Impossible");
-    if (!pFmt)
-        return rWrt;
-    rWW8Wrt.Out_SfxBreakItems(&(pFmt->GetAttrSet()), rNode);
-
-    /*
-    ALWAYS relative when text::HoriOrientation::NONE (nPageSize + ( nPageSize / 10 )) < nTblSz,
-    in that case the cell width's and table width's are not real. The table
-    width is maxed and cells relative, so we need the frame (generally page)
-    width that the table is in to work out the true widths.
-    */
-    const SwFmtFrmSize &rSize = pFmt->GetFrmSize();
-    int nWidthPercent = rSize.GetWidthPercent();
-    bool bManualAligned = pFmt->GetHoriOrient().GetHoriOrient() == text::HoriOrientation::NONE;
-    if ( (pFmt->GetHoriOrient().GetHoriOrient() == text::HoriOrientation::FULL) || bManualAligned )
-        nWidthPercent = 100;
-    bool bRelBoxSize = nWidthPercent != 0;
-    unsigned long nTblSz = static_cast<unsigned long>(rSize.GetWidth());
-    if (nTblSz > USHRT_MAX/2 && !bRelBoxSize)
-    {
-        ASSERT(bRelBoxSize, "huge table width but not relative, suspicious");
-        bRelBoxSize = true;
-    }
-
-    unsigned long nPageSize = nTblSz;
-    if (bRelBoxSize)
-    {
-        Point aPt;
-        SwRect aRect(pFmt->FindLayoutRect(false, &aPt));
-        if (aRect.IsEmpty())
-        {
-            // dann besorge mal die Seitenbreite ohne Raender !!
-            const SwFrmFmt* pParentFmt =
-                rWW8Wrt.mpParentFrame ?
-                &(rWW8Wrt.mpParentFrame->GetFrmFmt()) :
-                const_cast<const SwDoc *>(rWrt.pDoc)->GetPageDesc(0).GetPageFmtOfNode(rNode, false);
-            aRect = pParentFmt->FindLayoutRect(true);
-            if (0 == (nPageSize = aRect.Width()))
-            {
-                const SvxLRSpaceItem& rLR = pParentFmt->GetLRSpace();
-                nPageSize = pParentFmt->GetFrmSize().GetWidth() - rLR.GetLeft()
-                    - rLR.GetRight();
-            }
-        }
-        else
-        {
-            nPageSize = aRect.Width();
-            if(bManualAligned)
-            {
-                // #i37571# For manually aligned tables
-                const SvxLRSpaceItem &rLR = pFmt->GetLRSpace();
-                nPageSize -= (rLR.GetLeft() + rLR.GetRight());
-            }
-
-        }
-
-        ASSERT(nWidthPercent, "Impossible");
-        if (nWidthPercent)
-        {
-            nPageSize *= nWidthPercent;
-            nPageSize /= 100;
-        }
-    }
-
-    WW8Bytes aAt( 128, 128 );   // Attribute fuer's Tabellen-Zeilenende
-    SwTwips nTblOffset = 0;
-    USHORT nStdAtLen = rWW8Wrt.StartTableFromFrmFmt(aAt, pFmt, nTblOffset);
-    static const BYTE aNullBytes[] = { 0, 0, 0, 0 };
-
-    SwWriteTable* pTableWrt;
-    const SwHTMLTableLayout *pLayout = rTbl.GetHTMLTableLayout();
-    if( pLayout && pLayout->IsExportable() )
-        pTableWrt = new SwWriteTable( pLayout );
-    else
-    {
-        pTableWrt = new SwWriteTable( rTbl.GetTabLines(), nPageSize,
-            (USHORT)nTblSz, false);
-    }
-
-    const SwFrmFmt *pDefaultFmt = 0;
-    // WW6 / 8 can not have more then 31 / 63 cells
-    const BYTE nMaxCols = rWW8Wrt.bWrtWW8 ? 63 : 31;
-    // rCols are the array of all cols of the table
-    const SwWriteTableCols& rCols = pTableWrt->GetCols();
-    USHORT nColCnt = rCols.Count();
-    SwWriteTableCellPtr* pBoxArr = new SwWriteTableCellPtr[ nColCnt ];
-    USHORT* pRowSpans = new USHORT[ nColCnt ];
-    memset( pBoxArr, 0, sizeof( pBoxArr[0] ) * nColCnt );
-    memset( pRowSpans, 0, sizeof( pRowSpans[0] ) * nColCnt );
-    const SwWriteTableRows& rRows = pTableWrt->GetRows();
-    for( USHORT nLine = 0; nLine < rRows.Count(); ++nLine )
-    {
-        USHORT nBox, nRealBox;
-
-        const SwWriteTableRow *pRow = rRows[ nLine ];
-        const SwWriteTableCells& rCells = pRow->GetCells();
-
-        bool bFixRowHeight = false;
-        USHORT nRealColCnt = 0;
-        USHORT nTotal = rCells.Count();
-        ASSERT(nTotal <= rCols.Count(),
-            "oh oh!,row has more cells than table is wide!");
-        if (nTotal > rCols.Count())
-            nTotal = rCols.Count();
-        for( nColCnt = 0, nBox = 0; nBox < nTotal; ++nColCnt )
-        {
-            ASSERT( nColCnt < rCols.Count(), "Leaving table" );
-
-            SwWriteTableCell* pCell = rCells[nBox];
-            const bool bProcessCoveredCell = bNewTableModel && 0 == pCell->GetRowSpan();
-
-            if( !pRowSpans[ nColCnt ] || bProcessCoveredCell )
-            {
-                // set new BoxPtr
-                nBox++;
-                pBoxArr[ nColCnt ] = pCell;
-                if ( !bProcessCoveredCell )
-                    pRowSpans[ nColCnt ] = pCell->GetRowSpan();
-                for( USHORT nCellSpan = pCell->GetColSpan(), nCS = 1;
-                        nCS < nCellSpan; ++nCS, ++nColCnt )
-                {
-                    ASSERT( nColCnt+1 < rCols.Count(), "More colspan than columns" );
-                    if( nColCnt+1 < rCols.Count() ) // robust against wrong colspans
-                    {
-                        pBoxArr[ nColCnt+1 ] = pBoxArr[ nColCnt ];
-                        pRowSpans[ nColCnt+1 ] = pRowSpans[ nColCnt ];
-                    }
-                }
-                ++nRealColCnt;
-            }
-            else if( !nColCnt || pBoxArr[ nColCnt-1 ] != pBoxArr[ nColCnt ] )
-                ++nRealColCnt;
-
-            if( 1 != pRowSpans[ nColCnt ] && !bNewTableModel )
-                bFixRowHeight = true;
-        }
-
-        for( ; nColCnt < rCols.Count() && pRowSpans[ nColCnt ]; ++nColCnt )
-        {
-            if( !nColCnt || pBoxArr[ nColCnt-1 ] != pBoxArr[ nColCnt ] )
-                ++nRealColCnt;
-            bFixRowHeight = true;
-        }
-        nColCnt = rCols.Count(); // A wrong cellspan-value could cause a nColCnt > rCols.Count()
-
-        if (!bFixRowHeight)
-        {
-            bFixRowHeight = RowContainsProblematicGraphic(pBoxArr, nColCnt,
-                rWW8Wrt);
-        }
-
-        //Winword column export limited to 31/63 cells
-        sal_uInt8 nWWColMax = nRealColCnt > nMaxCols ?
-            nMaxCols : msword_cast<sal_uInt8>(nRealColCnt);
-
-        // Check if this is a repeated row - sprmTTableHeader
-        if( rTbl.GetRowsToRepeat() > nLine)
-        {
-            if( rWW8Wrt.bWrtWW8 )
-                SwWW8Writer::InsUInt16( aAt, 0x3404 );
-            else
-                aAt.Insert( 186, aAt.Count() );
-            aAt.Insert( 1, aAt.Count() );
-        }
-
-        const SwTableLine* pLine = pBoxArr[0]->GetBox()->GetUpper();
-        const SwFrmFmt *pLineFmt = pLine ? pLine->GetFrmFmt() : 0;
-
-        // Zeilenhoehe ausgeben   sprmTDyaRowHeight
-        long nHeight = 0;
-        if( bFixRowHeight )
-        {
-            nHeight = -pRow->GetPos();      //neg. => abs. height!
-            if( nLine )
-                nHeight += rRows[ nLine - 1 ]->GetPos();
-        }
-        else
-        {
-            const SwFmtFrmSize& rLSz = pLineFmt->GetFrmSize();
-            if( ATT_VAR_SIZE != rLSz.GetHeightSizeType() && rLSz.GetHeight() )
-                nHeight = ATT_MIN_SIZE == rLSz.GetHeightSizeType()
-                                                ? rLSz.GetHeight()
-                                                : -rLSz.GetHeight();
-        }
-        if (nHeight)
-        {
-            if( rWW8Wrt.bWrtWW8 )
-                SwWW8Writer::InsUInt16( aAt, 0x9407 );
-            else
-                aAt.Insert( 189, aAt.Count() );
-            SwWW8Writer::InsUInt16( aAt, (USHORT)nHeight );
-        }
-
-        /*
-        By default the row can be split in word, and now in writer we have a
-        feature equivalent to this, Word stores 1 for fCantSplit if the row
-        cannot be split, we set true if we can split it. An example is #i4569#
-        */
-        const SwFmtRowSplit& rSplittable = pLineFmt->GetRowSplit();
-        BYTE nCantSplit = (!rSplittable.GetValue()) ? 1 : 0;
-        if (rWW8Wrt.bWrtWW8)
-        {
-            SwWW8Writer::InsUInt16(aAt, 0x3403);
-			aAt.Insert(nCantSplit, aAt.Count());
-            SwWW8Writer::InsUInt16(aAt, 0x3466); // also write fCantSplit90
-        }
-        else
-		{
-            aAt.Insert(185, aAt.Count());
-		}
-		aAt.Insert(nCantSplit, aAt.Count());
-
-
-        if (rWW8Wrt.bWrtWW8)
-        {
-            if (rWW8Wrt.TrueFrameDirection(*pFmt) == FRMDIR_HORI_RIGHT_TOP)
-            {
-                SwWW8Writer::InsUInt16(aAt, 0x560B);
-                SwWW8Writer::InsUInt16(aAt, 1);
-            }
-        }
-
-        // Inhalt der Boxen ausgeben
-        for( nBox = 0, nRealBox = 0; nBox < nColCnt; ++nBox )
-        {
-            if( nBox && pBoxArr[ nBox-1 ] == pBoxArr[ nBox ] )
-                continue;
-
-            if (pBoxArr[nBox] && pBoxArr[nBox]->GetRowSpan() == pRowSpans[nBox])
-            {
-                // new Box
-                const SwStartNode* pSttNd = pBoxArr[nBox]->GetBox()->GetSttNd();
-                WW8SaveData aSaveData( rWW8Wrt, pSttNd->GetIndex()+1,
-                                        pSttNd->EndOfSectionIndex() );
-                rWW8Wrt.bOutTable = true;
-                rWW8Wrt.bIsInTable= true;
-                rWW8Wrt.WriteText();
-            }
-            else
-            {
-                rWW8Wrt.bOutTable = true;
-                rWW8Wrt.WriteStringAsPara( aEmptyStr );
-                rWW8Wrt.bOutTable = false;
-            }
-
-            if( nWWColMax < nRealColCnt )
-            {
-                if( nRealBox+1 < nWWColMax || nRealBox+1 == nRealColCnt )
-                    rWW8Wrt.WriteCellEnd(); // SpaltenEnde
-            }
-            else if( nRealBox < nWWColMax )
-                    rWW8Wrt.WriteCellEnd(); // SpaltenEnde
-            ++nRealBox;
-        }
-
-        // das wars mit der Line
-        rWW8Wrt.WriteRowEnd();  // TabellenZeilen-Ende
-
-        if( rWW8Wrt.bWrtWW8 )
-        {
-            // SprmTDefTable
-            // 0+1 - OpCode, 2+3 - Laenge = Cells * (sizeof TC + uint16)
-            // 4 - Cells (max 32!)
-            SwWW8Writer::InsUInt16( aAt, 0xD608 );
-            SwWW8Writer::InsUInt16( aAt, 2 + ( nWWColMax + 1 ) * 2 +
-                                                ( nWWColMax * 20 ));
-            aAt.Insert( nWWColMax, aAt.Count() );               //
-        }
-        else
-        {
-            // SprmTDefTable
-            // 0 - OpCode, 1,2 - Laenge = Cells * (sizeof TC + uint16)
-            // 3 - Cells (max 32!)
-            aAt.Insert( 190, aAt.Count() );
-            SwWW8Writer::InsUInt16( aAt, nWWColMax * 12 + 4 );  // Sprm-Laenge
-            aAt.Insert( nWWColMax, aAt.Count() );               //
-        }
-
-        SwTwips nSz = 0, nCalc;
-        SwWW8Writer::InsUInt16( aAt, (USHORT)nTblOffset );
-
-        for (nBox = 0, nRealBox = 0; nRealBox < nWWColMax; ++nBox)
-        {
-            if( (nBox > 0 && pBoxArr[ nBox-1 ] == pBoxArr[ nBox ])
-                || pBoxArr[nBox] == NULL)
-                continue;
-
-            const SwFrmFmt* pBoxFmt = pBoxArr[ nBox ]->GetBox()->GetFrmFmt();
-            const SwFmtFrmSize& rLSz = pBoxFmt->GetFrmSize();
-            nSz += rLSz.GetWidth();
-            nCalc = nSz;
-            if( bRelBoxSize )
-            {
-                nCalc *= nPageSize;
-                nCalc /= nTblSz;
-            }
-            SwWW8Writer::InsUInt16( aAt, (USHORT)(nTblOffset + nCalc ));
-            ++nRealBox;
-        }
-
-        for (nBox = 0, nRealBox = 0; nRealBox < nWWColMax; ++nBox)
-        {
-            if( nBox && pBoxArr[ nBox-1 ] == pBoxArr[ nBox ] )
-                continue;
-            // rgf, erstmal alles 0 - WW8: 4, sonst 2 Byte
-            // write vertikal alignment
-            const SwFrmFmt& rFmt = *pBoxArr[ nBox ]->GetBox()->GetFrmFmt();
-            if( rWW8Wrt.bWrtWW8 )
-            {
-                USHORT nFlags = pBoxArr[ nBox ]->GetRowSpan();
-                if( 1 < nFlags || ( bNewTableModel && 0 == nFlags ) )
-                {
-                    if( nFlags == pRowSpans[ nBox ] )
-                        nFlags = 0x60;      // start a new vert. merge
-                    else
-                        nFlags = 0x20;      // continue a vert. merge
-                }
-                else
-                    nFlags = 0;             // no vert. merge
-
-                switch (rFmt.GetVertOrient().GetVertOrient())
-                {
-                    case text::VertOrientation::CENTER:
-                        nFlags |= 0x080;
-                        break;
-                    case text::VertOrientation::BOTTOM:
-                        nFlags |= 0x100;
-                        break;
-                    default:
-                        break;
-                }
-                SwWW8Writer::InsUInt16( aAt, nFlags );
-            }
-            ++nRealBox;
-            aAt.Insert( aNullBytes, 2, aAt.Count() );   // dummy
-            rWW8Wrt.Out_SwFmtTableBox( aAt, rFmt.GetBox() ); // 8/16 Byte
-        }
-
-        //Cell widths and heights
-        if (rWW8Wrt.bWrtWW8)
-        {
-            if (!pDefaultFmt && nWWColMax)
-                pDefaultFmt = pBoxArr[ 0 ]->GetBox()->GetFrmFmt();
-
-            static USHORT __READONLY_DATA aBorders[] =
-            {
-                BOX_LINE_TOP, BOX_LINE_LEFT,
-                BOX_LINE_BOTTOM, BOX_LINE_RIGHT
-            };
-            const USHORT* pBrd = aBorders;
-
-            //Export non default border spacing
-            for( nBox = 0, nRealBox = 0; nRealBox < nWWColMax; ++nBox)
-            {
-                if( nBox && pBoxArr[ nBox-1 ] == pBoxArr[ nBox ] )
-                    continue;
-                const SwFrmFmt& rFmt = *pBoxArr[ nBox ]->GetBox()->GetFrmFmt();
-
-                pBrd = aBorders;
-                for( int i = 0; i < 4; ++i, ++pBrd)
-                {
-                    USHORT nDist = rFmt.GetBox().GetDistance(*pBrd);
-                    if (pDefaultFmt->GetBox().GetDistance(*pBrd) != nDist)
-                    {
-                        SwWW8Writer::InsUInt16(aAt, 0xD632);
-                        aAt.Insert( BYTE(6), aAt.Count() );
-                        aAt.Insert( BYTE(nRealBox), aAt.Count() );
-                        aAt.Insert( BYTE(3), aAt.Count() );
-                        aAt.Insert( BYTE(1 << i), aAt.Count() );
-                        aAt.Insert( BYTE(3), aAt.Count() );
-                        SwWW8Writer::InsUInt16(aAt, nDist);
-                    }
-                }
-                ++nRealBox;
-            }
-
-            //Export any vertical direction cells
-            for (nBox = 0, nRealBox = 0; nRealBox < nWWColMax; ++nBox)
-            {
-                if( nBox && pBoxArr[nBox-1] == pBoxArr[nBox])
-                    continue;
-                const SwFrmFmt& rFmt = *pBoxArr[ nBox ]->GetBox()->GetFrmFmt();
-                //a bit lazy, could calculate range of cells with equal
-                //direction to optimize size of exported document
-                if (FRMDIR_VERT_TOP_RIGHT == rWW8Wrt.TrueFrameDirection(rFmt))
-                {
-                    SwWW8Writer::InsUInt16(aAt, 0x7629);
-                    aAt.Insert(BYTE(nBox), aAt.Count());        //start range
-                    aAt.Insert(BYTE(nBox + 1), aAt.Count());    //end range
-                    SwWW8Writer::InsUInt16(aAt, 5); //Equals vertical writing
-                }
-                ++nRealBox;
-            }
-
-            //Set Default, just taken from the first cell of the first
-            //row
-            pBrd = aBorders;
-            for( int i = 0; i < 4; ++i, ++pBrd)
-            {
-                SwWW8Writer::InsUInt16(aAt, 0xD634);
-                aAt.Insert( BYTE(6), aAt.Count() );
-                aAt.Insert( BYTE(0), aAt.Count() );
-                aAt.Insert( BYTE(1), aAt.Count() );
-                aAt.Insert( BYTE(1 << i), aAt.Count() );
-                aAt.Insert( BYTE(3), aAt.Count() );
-
-                SwWW8Writer::InsUInt16(aAt,
-                    pDefaultFmt->GetBox().GetDistance(*pBrd));
-            }
-        }
-
-        // Background
-        USHORT nBackg;
-        if( pRow->GetBackground() )
-            // over all boxes!
-            nBackg = nWWColMax;
-        else
-        {
-            nBackg = 0;
-            for( nBox = 0, nRealBox = 0; nRealBox < nWWColMax; ++nBox )
-            {
-                if( nBox && pBoxArr[ nBox-1 ] == pBoxArr[ nBox ] )
-                    continue;
-
-                SwWriteTableCell* pCell = pBoxArr[ nBox ];
-                if( pCell->GetBackground() ||
-                    SFX_ITEM_ON == pCell->GetBox()->GetFrmFmt()->
-                    GetItemState( RES_BACKGROUND, false) )
-                    nBackg = nRealBox + 1;
-                ++nRealBox;
-            }
-        }
-
-        if( nBackg )
-        {
-            // TableShade, 0(+1) - OpCode, 1(2) - Count * sizeof( SHD ),
-            // 2..(3..) - SHD
-            if( rWW8Wrt.bWrtWW8 )
-                SwWW8Writer::InsUInt16( aAt, 0xD609 );
-            else
-                aAt.Insert( (BYTE)191, aAt.Count() );
-            aAt.Insert( (BYTE)(nBackg * 2), aAt.Count() );  // Len
-
-            Color *pColors = new Color[nBackg];
-
-            const SfxPoolItem* pI;
-            for( nBox = 0, nRealBox = 0; nRealBox < nBackg; ++nBox )
-            {
-                if( nBox && pBoxArr[ nBox-1 ] == pBoxArr[ nBox ] )
-                    continue;
-
-                SwWriteTableCell* pCell = pBoxArr[ nBox ];
-                if( SFX_ITEM_ON == pCell->GetBox()->GetFrmFmt()->
-                    GetAttrSet().GetItemState( RES_BACKGROUND, false, &pI )
-                    || 0 != ( pI = pCell->GetBackground() )
-                    || 0 != ( pI = pRow->GetBackground() ) )
-                {
-                    pColors[nRealBox] = ((const SvxBrushItem*)pI)->GetColor();
-                }
-                else
-                    pColors[nRealBox] = COL_AUTO;
-                ++nRealBox;
-            }
-
-            for(USHORT nI = 0; nI < nBackg; ++nI)
-            {
-                WW8_SHD aShd;
-                rWW8Wrt.TransBrush(pColors[nI], aShd);
-                SwWW8Writer::InsUInt16(aAt, aShd.GetValue());
-            }
-
-            if( rWW8Wrt.bWrtWW8 )
-            {
-                SwWW8Writer::InsUInt16( aAt, 0xD612 );
-                aAt.Insert( (BYTE)(nBackg * 10), aAt.Count() ); // Len
-                for(USHORT nI = 0; nI < nBackg; ++nI)
-                {
-                    SwWW8Writer::InsUInt32(aAt, 0xFF000000);
-                    sal_uInt32 nBgColor = pColors[nI].GetColor();
-                    if (nBgColor == COL_AUTO)
-                        nBgColor = 0xFF000000;
-                    else
-                        nBgColor = wwUtility::RGBToBGR(nBgColor);
-                    SwWW8Writer::InsUInt32(aAt, nBgColor);
-                    SwWW8Writer::InsUInt16(aAt, 0x0000);
-                }
-            }
-
-            delete[] pColors;
-        }
-
-        rWW8Wrt.pPapPlc->AppendFkpEntry( rWrt.Strm().Tell(),
-                                   aAt.Count(), aAt.GetData() );
-        if( aAt.Count() > nStdAtLen )
-            aAt.Remove( nStdAtLen, aAt.Count() - nStdAtLen );
-
-        for( nBox = 0; nBox < nColCnt; ++nBox )
-            --pRowSpans[ nBox ];
-    }
-
-    delete pTableWrt;
-    delete[] pBoxArr;
-    delete[] pRowSpans;
-
-    // Pam hinter die Tabelle verschieben
-    rWW8Wrt.pCurPam->GetPoint()->nNode = *rNode.EndOfSectionNode();
-
-    return rWrt;
-}
-
 bool SwWW8Writer::NoPageBreakSection(const SfxItemSet* pSet)
 {
     bool bRet = false;
Index: sw/source/filter/ww8/wrtww8.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtww8.cxx,v
retrieving revision 1.93
retrieving revision 1.91.98.7
diff -u -p -u -p -b -w -B -r1.93 -r1.91.98.7
--- sw/source/filter/ww8/wrtww8.cxx	4 Sep 2008 10:24:46 -0000	1.93
+++ sw/source/filter/ww8/wrtww8.cxx	19 Sep 2008 15:02:54 -0000	1.91.98.7
@@ -31,6 +31,9 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sw.hxx"
 /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil -*- */
+
+#include <iostream>
+
 #include <com/sun/star/embed/ElementModes.hpp>
 #include <com/sun/star/embed/XStorage.hpp>
 #include <unotools/ucbstreamhelper.hxx>
@@ -61,11 +64,16 @@
 #include <svx/langitem.hxx>
 #include <svx/msoleexp.hxx>
 #include <svx/msocximex.hxx>
+#include <svx/lrspitem.hxx>
+#include <svx/boxitem.hxx>
+#include <svx/brshitem.hxx>
 #include <swtypes.hxx>
 #include <swrect.hxx>
 #include <txatbase.hxx>
 #include <fmtcntnt.hxx>
 #include <fmtpdsc.hxx>
+#include <fmtrowsplt.hxx>
+#include <frmatr.hxx>
 #include <doc.hxx>
 #include <docary.hxx>
 #include <pam.hxx>
@@ -95,6 +103,7 @@
 #include <statstr.hrc>          // ResId fuer Statusleiste
 #endif
 #include <fmtline.hxx>
+#include <fmtfsize.hxx>
 #include <comphelper/extract.hxx>
 #include "writerhelper.hxx"
 #include "writerwordglue.hxx"
@@ -676,8 +685,8 @@ bool WW8_WrMagicTable::Write(SwWW8Writer
         return false;
     ULONG nFcStart = rWrt.pTableStrm->Tell();
     WW8_WrPlc1::Write( *rWrt.pTableStrm );
-    rWrt.pFib->fcMagicTable = nFcStart;
-    rWrt.pFib->lcbMagicTable = rWrt.pTableStrm->Tell() - nFcStart;
+    rWrt.pFib->fcPlcfTch = nFcStart;
+    rWrt.pFib->lcbPlcfTch = rWrt.pTableStrm->Tell() - nFcStart;
     return true;
 }
 
@@ -1655,6 +1664,10 @@ void SwWW8Writer::OutSwString(const Stri
     xub_StrLen nLen, bool bUnicode, rtl_TextEncoding eChrSet)
 
 {
+#ifdef DEBUG
+    ::std::clog << "<OutSwString>" << ::std::endl;
+#endif
+
     if( nLen )
     {
         if ( bUnicode != pPiece->IsUnicode() )
@@ -1663,21 +1676,41 @@ void SwWW8Writer::OutSwString(const Stri
         if( nStt || nLen != rStr.Len() )
         {
             String sOut( rStr.Copy( nStt, nLen ) );
+            
+#ifdef DEBUG
+            ::std::clog << ::rtl::OUStringToOString(sOut, RTL_TEXTENCODING_ASCII_US).getStr() << ::std::endl;
+#endif
+
             if (bUnicode)
                 SwWW8Writer::WriteString16(Strm(), sOut, false);
             else
                 SwWW8Writer::WriteString8(Strm(), sOut, false, eChrSet);
         }
-        else if (bUnicode)
+        else 
+        {
+#ifdef DEBUG
+            ::std::clog << ::rtl::OUStringToOString(rStr, RTL_TEXTENCODING_ASCII_US).getStr() << ::std::endl;
+#endif
+
+            if (bUnicode)
             SwWW8Writer::WriteString16(Strm(), rStr, false);
         else
             SwWW8Writer::WriteString8(Strm(), rStr, false, eChrSet);
     }
 }
 
-void SwWW8Writer::WriteCR()
+#ifdef DEBUG
+    ::std::clog << "</OutSwString>" << ::std::endl;    
+#endif
+}
+
+void SwWW8Writer::WriteCR(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
 {
+    if (pTableTextNodeInfo.get() != NULL && pTableTextNodeInfo->getDepth() == 1 && pTableTextNodeInfo->isEndOfCell())
+        WriteChar('\007');
+    else
     WriteChar( '\015' );
+        
     pPiece->SetParaBreak();
 }
 
@@ -1759,9 +1792,497 @@ WW8SaveData::~WW8SaveData()
     rWrt.pFlyOffset = pOldFlyOffset;
 }
 
+void SwWW8Writer::OutWW8TableInfoCell
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    sal_uInt32 nDepth = pTableTextNodeInfo->getDepth();
+
+    if (nDepth > 0)
+    {    
+        /* Cell */        
+        InsUInt16(0x2416);
+        pO->Insert((BYTE)0x1, pO->Count());
+        InsUInt16(0x6649);
+        InsUInt32(nDepth);
+        
+        if (nDepth > 1)
+        {
+            InsUInt16(0x244b);
+            pO->Insert((BYTE)0x1, pO->Count());
+        }            
+    }
+}
+
+void SwWW8Writer::OutWW8TableInfoRow
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    sal_uInt32 nDepth = pTableTextNodeInfo->getDepth();
+    
+    if (nDepth > 0)
+    {
+        
+        /* Row */
+        if (pTableTextNodeInfo->isEndOfLine())
+        {
+            InsUInt16(0x2416);
+            pO->Insert((BYTE)0x1, pO->Count());
+            
+            if (nDepth == 1)
+            {
+                InsUInt16(0x2417);
+                pO->Insert((BYTE)0x1, pO->Count());
+            }
+            
+            InsUInt16(0x6649);
+            InsUInt32(nDepth);
+            
+            if (nDepth > 1)
+            {
+                InsUInt16(0x244b);
+                pO->Insert((BYTE)0x1, pO->Count());
+                InsUInt16(0x244c);
+                pO->Insert((BYTE)0x1, pO->Count());
+            }            
+            
+            OutWW8TableDefinition(pTableTextNodeInfo);
+            OutWW8TableHeight(pTableTextNodeInfo);  
+            OutWW8TableBackgrounds(pTableTextNodeInfo);
+            OutWW8TableDefaultBorders(pTableTextNodeInfo); 
+            OutWW8TableCanSplit(pTableTextNodeInfo);         
+            OutWW8TableBidi(pTableTextNodeInfo);
+            OutWW8TableVerticalCell(pTableTextNodeInfo);
+        }
+    }
+}
+
+static sal_uInt16 lcl_TCFlags(const SwTableBox * pBox)
+{
+    sal_uInt16 nFlags = 0;
+    
+    long nRowSpan = pBox->getRowSpan();
+    
+    if (nRowSpan != 0)
+    {
+        nFlags |= (1 << 5);
+        
+        if (nRowSpan > 0)
+            nFlags |= (1 << 6);
+    }
+    
+    const SwFrmFmt * pFmt = pBox->GetFrmFmt();
+    switch (pFmt->GetVertOrient().GetVertOrient())
+    {
+        case text::VertOrientation::CENTER:
+            nFlags |= (1 << 7);
+            break;
+        case text::VertOrientation::BOTTOM:
+            nFlags |= (2 << 7);
+            break;
+        default:
+            break;            
+    }
+    
+    return nFlags;
+}
+
+void SwWW8Writer::OutWW8TableVerticalCell
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTableBox * pTabBox = pTableTextNodeInfo->getTableBox();
+    const SwTableLine * pTabLine = pTabBox->GetUpper();    
+    const SwTableBoxes & rTblBoxes = pTabLine->GetTabBoxes();
+    
+    sal_uInt8 nBoxes = rTblBoxes.Count();
+    for (sal_uInt8 n = 0; n < nBoxes; n++)
+    {
+        const SwTableBox * pTabBox1 = rTblBoxes[n];
+        const SwFrmFmt * pFrmFmt = pTabBox1->GetFrmFmt();
+        
+        if (FRMDIR_VERT_TOP_RIGHT == TrueFrameDirection(*pFrmFmt))
+        {
+            InsUInt16(0x7629);
+            pO->Insert(BYTE(n), pO->Count());        //start range
+            pO->Insert(BYTE(n + 1), pO->Count());    //end range
+            InsUInt16(5); //Equals vertical writing
+        }        
+    }
+}
+
+void SwWW8Writer::OutWW8TableCanSplit
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTableBox * pTabBox = pTableTextNodeInfo->getTableBox();
+    const SwTableLine * pTabLine = pTabBox->GetUpper();    
+    const SwFrmFmt * pLineFmt = pTabLine->GetFrmFmt();
+
+    /*
+     By default the row can be split in word, and now in writer we have a
+     feature equivalent to this, Word stores 1 for fCantSplit if the row
+     cannot be split, we set true if we can split it. An example is #i4569#
+     */
+     
+    const SwFmtRowSplit& rSplittable = pLineFmt->GetRowSplit();
+    BYTE nCantSplit = (!rSplittable.GetValue()) ? 1 : 0;
+    if (bWrtWW8)
+    {
+        InsUInt16(0x3403);
+        pO->Insert(nCantSplit, pO->Count());
+        InsUInt16(0x3466); // also write fCantSplit90
+    }
+    else
+    {
+        pO->Insert(185, pO->Count());
+    }
+    pO->Insert(nCantSplit, pO->Count());
+}
+
+void SwWW8Writer::OutWW8TableBidi
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTable * pTable = pTableTextNodeInfo->getTable();
+    const SwFrmFmt * pFrmFmt = pTable->GetFrmFmt();
+    
+    if (bWrtWW8)
+    {
+        if (TrueFrameDirection(*pFrmFmt) == FRMDIR_HORI_RIGHT_TOP)
+        {
+            InsUInt16(0x560B);
+            InsUInt16(1);
+        }
+    }
+}
+
+void SwWW8Writer::OutWW8TableHeight
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTableBox * pTabBox = pTableTextNodeInfo->getTableBox();
+    const SwTableLine * pTabLine = pTabBox->GetUpper();    
+    const SwFrmFmt * pLineFmt = pTabLine->GetFrmFmt();
+
+#if 0    
+    const SwTable * pTable = pTableTextNodeInfo->getTable();
+    bool bNewTableModel = pTable->IsNewModel();
+    bool bFixRowHeight = false;
+    const SwTableBoxes & rTabBoxes = pTabLine->GetTabBoxes();
+    if (! bNewModel)
+    {
+        sal_uInt32 nBoxes = rTabBoxes.Count();
+        
+        for (sal_uInt32 n = 0; n < nBoxes; n++)
+        {
+            SwTableBox * pBox1 = rTabBoxes[n];
+            if (pBox1->getRowspan() != 1)
+            {
+                bFixRowHeight = true;
+                break;
+            }
+        }
+    }
+#endif
+
+    // Zeilenhoehe ausgeben   sprmTDyaRowHeight
+    long nHeight = 0;
+    const SwFmtFrmSize& rLSz = pLineFmt->GetFrmSize();
+    if( ATT_VAR_SIZE != rLSz.GetHeightSizeType() && rLSz.GetHeight() )
+    {
+        if (ATT_MIN_SIZE == rLSz.GetHeightSizeType())
+            nHeight = rLSz.GetHeight();
+        else
+            nHeight = -rLSz.GetHeight();
+    }
+
+    if (nHeight)
+    {
+        if( bWrtWW8 )
+            InsUInt16( 0x9407 );
+        else
+            pO->Insert( 189, pO->Count() );
+        InsUInt16( (USHORT)nHeight );
+    }
+    
+}
+
+void SwWW8Writer::OutWW8TableDefinition
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTableBox * pTabBox = pTableTextNodeInfo->getTableBox();
+    const SwTableLine * pTabLine = pTabBox->GetUpper();
+    const SwTableBoxes & rTabBoxes = pTabLine->GetTabBoxes();
+    const SwTxtNode * pTxtNd = pTableTextNodeInfo->getTextNode();
+    const SwTable * pTable = pTableTextNodeInfo->getTable();
+    
+    if( pTable->GetRowsToRepeat() > pTableTextNodeInfo->getRow())
+    {
+        if( bWrtWW8 )
+            InsUInt16( 0x3404 );
+        else
+            pO->Insert(186, pO->Count());
+        pO->Insert( 1, pO->Count() );
+    }
+
+    // number of cell written
+    sal_uInt32 nBoxes = rTabBoxes.Count();
+    if (nBoxes > 32)
+        nBoxes = 32;
+        
+    // sprm header
+    InsUInt16(0xd608);
+    sal_uInt16 nSprmSize = 2 + (nBoxes + 1) * 2 + nBoxes * 20;
+    InsUInt16(nSprmSize); // length
+
+    // number of boxes
+    pO->Insert(static_cast<BYTE>(nBoxes), pO->Count());
+        
+
+    /* cellxs */       
+    /*
+     ALWAYS relative when text::HoriOrientation::NONE (nPageSize + ( nPageSize / 10 )) < nTblSz,
+     in that case the cell width's and table width's are not real. The table
+     width is maxed and cells relative, so we need the frame (generally page)
+     width that the table is in to work out the true widths.
+     */
+    //const bool bNewTableModel = pTbl->IsNewModel();
+    const SwFrmFmt *pFmt = pTable->GetFrmFmt();
+    ASSERT(pFmt,"Impossible");
+    if (!pFmt)
+        return;
+
+    const SwFmtHoriOrient &rHori = pFmt->GetHoriOrient();
+    const SwFmtVertOrient &rVert = pFmt->GetVertOrient();
+    
+    sal_uInt16 nTblOffset = 0;
+    
+    if (
+        (text::RelOrientation::PRINT_AREA == rHori.GetRelationOrient() ||
+         text::RelOrientation::FRAME == rHori.GetRelationOrient())
+        &&
+        (text::RelOrientation::PRINT_AREA == rVert.GetRelationOrient() ||
+         text::RelOrientation::FRAME == rVert.GetRelationOrient())
+        )
+    {
+        sal_Int16 eHOri = rHori.GetHoriOrient();
+        switch (eHOri)
+        {
+            case text::HoriOrientation::CENTER:
+            case text::HoriOrientation::RIGHT:
+                if( bWrtWW8 )
+                    InsUInt16(0x5400 );
+                else
+                    pO->Insert(182, pO->Count());
+                InsUInt16(text::HoriOrientation::RIGHT == eHOri ? 2 : 1);
+                break;
+                default:
+                
+                nTblOffset = rHori.GetPos();
+                const SvxLRSpaceItem& rLRSp = pFmt->GetLRSpace();
+                nTblOffset += rLRSp.GetLeft();
+                break;
+        }
+    }
+    
+    const SwFmtFrmSize &rSize = pFmt->GetFrmSize();
+    int nWidthPercent = rSize.GetWidthPercent();
+    bool bManualAligned = pFmt->GetHoriOrient().GetHoriOrient() == text::HoriOrientation::NONE;
+    if ( (pFmt->GetHoriOrient().GetHoriOrient() == text::HoriOrientation::FULL) || bManualAligned )
+        nWidthPercent = 100;
+    bool bRelBoxSize = nWidthPercent != 0;
+    unsigned long nTblSz = static_cast<unsigned long>(rSize.GetWidth());
+    if (nTblSz > USHRT_MAX/2 && !bRelBoxSize)
+    {
+        ASSERT(bRelBoxSize, "huge table width but not relative, suspicious");
+        bRelBoxSize = true;
+    }
+    
+    unsigned long nPageSize = nTblSz;
+    if (bRelBoxSize)
+    {
+        Point aPt;
+        SwRect aRect(pFmt->FindLayoutRect(false, &aPt));
+        if (aRect.IsEmpty())
+        {
+            // dann besorge mal die Seitenbreite ohne Raender !!
+            const SwFrmFmt* pParentFmt =
+            mpParentFrame ?
+            &(mpParentFrame->GetFrmFmt()) :
+            const_cast<const SwDoc *>(pDoc)->GetPageDesc(0).GetPageFmtOfNode(*pTxtNd, false);
+            aRect = pParentFmt->FindLayoutRect(true);
+            if (0 == (nPageSize = aRect.Width()))
+            {
+                const SvxLRSpaceItem& rLR = pParentFmt->GetLRSpace();
+                nPageSize = pParentFmt->GetFrmSize().GetWidth() - rLR.GetLeft()
+                - rLR.GetRight();
+            }
+        }
+        else
+        {
+            nPageSize = aRect.Width();
+            if(bManualAligned)
+            {
+                // #i37571# For manually aligned tables
+                const SvxLRSpaceItem &rLR = pFmt->GetLRSpace();
+                nPageSize -= (rLR.GetLeft() + rLR.GetRight());
+            }
+            
+        }
+        
+        ASSERT(nWidthPercent, "Impossible");
+        if (nWidthPercent)
+        {
+            nPageSize *= nWidthPercent;
+            nPageSize /= 100;
+        }
+    }
+
+    SwTwips nSz = 0;
+    sal_uInt32 n = 0;
+    InsUInt16(nTblOffset); 
+    
+    for (n = 0; n < nBoxes; n++)
+    {
+        const SwFrmFmt* pBoxFmt = rTabBoxes[ n ]->GetFrmFmt();
+        const SwFmtFrmSize& rLSz = pBoxFmt->GetFrmSize();
+        nSz += rLSz.GetWidth();
+        SwTwips nCalc = nSz;
+        if (bRelBoxSize)
+            nCalc = (nCalc * nPageSize) / nTblSz;
+        
+        InsUInt16(static_cast<USHORT>(nCalc));        
+    }    
+    
+    /* TCs */
+    for (n = 0; n < nBoxes; n++)
+    {
+#ifdef DEBUG
+        sal_uInt16 npOCount = pO->Count();
+#endif
+        
+        SwTableBox * pTabBox1 = rTabBoxes[n];
+        const SwFrmFmt & rBoxFmt = *(pTabBox1->GetFrmFmt());
+        if( bWrtWW8 )
+        {
+            sal_uInt16 nFlags = lcl_TCFlags(pTabBox1);            
+            InsUInt16( nFlags );
+        }
+        
+        static BYTE aNullBytes[] = { 0x0, 0x0 };
+        
+        pO->Insert( aNullBytes, 2, pO->Count() );   // dummy
+        Out_SwFmtTableBox( *pO, rBoxFmt.GetBox() ); // 8/16 Byte
+        
+#ifdef DEBUG
+        ::std::clog << "<tclength>" << pO->Count() - npOCount << "</tclength>"
+        << ::std::endl;
+#endif
+    }
+}
+
+void SwWW8Writer::OutWW8TableDefaultBorders
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTableBox * pTabBox = pTableTextNodeInfo->getTableBox();
+    const SwFrmFmt * pFrmFmt = pTabBox->GetFrmFmt();
+
+    //Set Default, just taken from the first cell of the first
+    //row
+    static USHORT aBorders[] =
+    {
+        BOX_LINE_TOP, BOX_LINE_LEFT,
+        BOX_LINE_BOTTOM, BOX_LINE_RIGHT
+    };
+    
+    for( int i = 0; i < 4; ++i)
+    {
+        SwWW8Writer::InsUInt16(*pO, 0xD634);
+        pO->Insert( BYTE(6), pO->Count() );
+        pO->Insert( BYTE(0), pO->Count() );
+        pO->Insert( BYTE(1), pO->Count() );
+        pO->Insert( BYTE(1 << i), pO->Count() );
+        pO->Insert( BYTE(3), pO->Count() );
+        
+        SwWW8Writer::InsUInt16(*pO,
+                               pFrmFmt->GetBox().GetDistance(aBorders[i]));
+    }
+        
+}
+
+void SwWW8Writer::OutWW8TableBackgrounds
+(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo)
+{
+    const SwTableBox * pTabBox = pTableTextNodeInfo->getTableBox();
+    const SwTableLine * pTabLine = pTabBox->GetUpper();
+    const SwTableBoxes & rTabBoxes = pTabLine->GetTabBoxes();
+
+    sal_uInt8 nBoxes = rTabBoxes.Count();
+    if( bWrtWW8 )
+        InsUInt16( 0xD609 );
+    else
+        pO->Insert( (BYTE)191, pO->Count() );
+    pO->Insert( (BYTE)(nBoxes * 2), pO->Count() );  // Len
+    
+    for (sal_uInt8 n = 0; n < nBoxes; n++)
+    {
+        const SwTableBox * pBox1 = rTabBoxes[n];
+        const SwFrmFmt * pFrmFmt = pBox1->GetFrmFmt();
+        const SfxPoolItem * pI = NULL;
+        Color aColor;
+        
+        if (SFX_ITEM_ON == pFrmFmt->GetAttrSet().GetItemState(RES_BACKGROUND, 
+                                                              false, &pI))
+        {
+            aColor = dynamic_cast<const SvxBrushItem *>(pI)->GetColor(); 
+        }
+        else
+            aColor = COL_AUTO;
+
+        WW8_SHD aShd;
+        TransBrush(aColor, aShd);
+        InsUInt16(aShd.GetValue());
+    }
+
+    if (bWrtWW8)
+    {
+        sal_uInt8 nBoxes0 = rTabBoxes.Count();
+        if (nBoxes0 > 21)
+            nBoxes0 = 21;
+        
+        InsUInt16(0xd612);
+        pO->Insert(static_cast<BYTE>(nBoxes0 * 10), pO->Count());
+        
+        for (sal_uInt8 n = 0; n < nBoxes0; n++)
+        {
+            const SwTableBox * pBox1 = rTabBoxes[n];
+            const SwFrmFmt * pFrmFmt = pBox1->GetFrmFmt();
+            const SfxPoolItem * pI = NULL;
+            Color aColor;
+        
+            if (SFX_ITEM_ON == pFrmFmt->GetAttrSet().GetItemState(RES_BACKGROUND, 
+                                                                  false, &pI))
+            {
+                aColor = dynamic_cast<const SvxBrushItem *>(pI)->GetColor(); 
+            }
+            else
+                aColor = COL_AUTO;
+            
+            WW8SHDLong aSHD;
+            aSHD.setCvFore(0xFF000000);
+            
+            sal_uInt32 nBgColor = aColor.GetColor();
+            if (nBgColor == COL_AUTO)
+                aSHD.setCvBack(0xFF000000);
+            else
+                aSHD.setCvBack(wwUtility::RGBToBGR(nBgColor));
+
+            aSHD.Write(*this);
+        } 
+    }
+}
 
 void SwWW8Writer::WriteText()
 {
+#ifdef DEBUG
+    ::std::clog << "<WriteText>" << ::std::endl;
+#endif
+
     while( pCurPam->GetPoint()->nNode < pCurPam->GetMark()->nNode ||
             (pCurPam->GetPoint()->nNode == pCurPam->GetMark()->nNode &&
             pCurPam->GetPoint()->nContent.GetIndex() <= pCurPam->GetMark()->nContent.GetIndex()) )
@@ -1789,8 +2310,10 @@ void SwWW8Writer::WriteText()
             pCurPam->GetPoint()->nContent.Assign( pCNd, 0 );
             Out( aWW8NodeFnTab, *pCNd, *this );
         }
-        else if( pNd->IsTableNode() && !bIsInTable )
-            OutWW8_SwTblNode( *this, *(SwTableNode*)pNd );
+        else if( pNd->IsTableNode() )
+        {
+            mpTableInfo->processSwTable(&(dynamic_cast<SwTableNode *>(pNd)->GetTable()));
+        }
         else if( pNd->IsSectionNode() && TXT_MAINTEXT == nTxtTyp )
             OutWW8_SwSectionNode( *this, *pNd->GetSectionNode() );
         else if( TXT_MAINTEXT == nTxtTyp && pNd->IsEndNode() &&
@@ -1833,12 +2356,22 @@ void SwWW8Writer::WriteText()
         ULONG nPos = pCurPam->GetPoint()->nNode++;  // Bewegen
         ::SetProgressState( nPos, pCurPam->GetDoc()->GetDocShell() );   // Wie weit ?
     }
+    
+#ifdef DEBUG
+    ::std::clog << "</WriteText>" << ::std::endl;
+#endif
 }
 
 void SwWW8Writer::WriteMainText()
 {
+#ifdef DEBUG
+    ::std::clog << "<WriteMainText>" << ::std::endl;
+#endif
+
     pFib->fcMin = Strm().Tell();
 
+    pCurPam->GetPoint()->nNode = pDoc->GetNodes().GetEndOfContent().StartOfSectionNode()->GetIndex();
+
     WriteText();
 
     if( 0 == Strm().Tell() - pFib->fcMin )  // kein Text ?
@@ -1855,6 +2388,10 @@ void SwWW8Writer::WriteMainText()
     const SwTxtNode* pLastNd = pCurPam->GetMark()->nNode.GetNode().GetTxtNode();
     if( pLastNd )
         nLastFmtId = GetId( (SwTxtFmtColl&)pLastNd->GetAnyFmtColl() );
+
+#ifdef DEBUG
+    ::std::clog << "</WriteMainText>" << ::std::endl;
+#endif
 }
 
 void SwWW8Writer::WriteFkpPlcUsw()
@@ -2481,7 +3018,8 @@ ULONG SwWW8Writer::WriteMedium( SfxMediu
 
 SwWW8Writer::SwWW8Writer(const String& rFltName, const String& rBaseURL)
     : aMainStg(sMainStream), pISet(0), pUsedNumTbl(0), mpTopNodeOfHdFtPage(0),
-    pBmpPal(0), pKeyMap(0), pOLEExp(0), pOCXExp(0), pOleMap(0), nUniqueList(0),
+    pBmpPal(0), pKeyMap(0), pOLEExp(0), pOCXExp(0), pOleMap(0), 
+    mpTableInfo(new ww8::WW8TableInfo()), nUniqueList(0),
     mnHdFtIndex(0), pAktPageDesc(0), pPapPlc(0), pChpPlc(0), pChpIter(0), pO(0),
     bHasHdr(false), bHasFtr(false)
 {
@@ -2602,6 +3140,13 @@ void SwWW8Writer::RestoreMacroCmds()
     }
 }
 
+void WW8SHDLong::Write(SwWW8Writer & rWriter)
+{
+    rWriter.InsUInt32(m_cvFore);
+    rWriter.InsUInt32(m_cvBack);
+    rWriter.InsUInt16(m_ipat);
+}
+
 void SwWW8Writer::RestoreMacroCmds()
 {
     pFib->fcCmds = pTableStrm->Tell();
Index: sw/source/filter/ww8/wrtww8.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtww8.hxx,v
retrieving revision 1.78
retrieving revision 1.76.172.4
diff -u -p -u -p -b -w -B -r1.78 -r1.76.172.4
--- sw/source/filter/ww8/wrtww8.hxx	4 Sep 2008 10:25:01 -0000	1.78
+++ sw/source/filter/ww8/wrtww8.hxx	12 Sep 2008 08:55:29 -0000	1.76.172.4
@@ -127,6 +127,8 @@ class SvStorageRef;
 struct WW8_PdAttrDesc;
 class SvxBrushItem;
 
+#include "WW8TableInfo.hxx"
+
 #define GRF_MAGIC_1 0x12    // 3 magic Bytes fuer PicLocFc-Attribute
 #define GRF_MAGIC_2 0x34
 #define GRF_MAGIC_3 0x56
@@ -393,6 +395,7 @@ friend Writer& OutWW8_SwTxtNode( Writer&
     SvxMSExportOLEObjects* pOLEExp;
     SwMSConvertControls* pOCXExp;
     WW8OleMaps* pOleMap;
+    ww8::WW8TableInfo::Pointer_t mpTableInfo;
 
     USHORT nCharFmtStart;
     USHORT nFmtCollStart;
@@ -553,6 +556,15 @@ public:
     void OutFlyFrm(const sw::Frame& rFmt);
     void AppendFlyInFlys(const sw::Frame& rFrmFmt, const Point& rNdTopLeft);
     void WriteSdrTextObj(const SdrObject& rObj, BYTE nTyp);
+    void OutWW8TableInfoCell(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableInfoRow(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableDefinition(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableDefaultBorders(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableBackgrounds(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableHeight(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableCanSplit(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableBidi(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
+    void OutWW8TableVerticalCell(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo);
 
     UINT32 GetSdrOrdNum( const SwFrmFmt& rFmt ) const;
     void CreateEscher();
@@ -579,10 +591,10 @@ public:
     void WriteAsStringTable(const ::std::vector<String>&, INT32& rfcSttbf,
         INT32& rlcbSttbf, USHORT nExtraLen = 0);
     void WriteText();
-    void WriteCR();
+    void WriteCR(ww8::WW8TableTextNodeInfo::Pointer_t pTableTextNodeInfo = ww8::WW8TableTextNodeInfo::Pointer_t());
     void WriteChar( sal_Unicode c );
     void WriteCellEnd();
-    void WriteRowEnd();
+    void WriteRowEnd(sal_uInt32 nDepth = 1);
     USHORT StartTableFromFrmFmt(WW8Bytes &rAt, const SwFrmFmt *pFmt,
         SwTwips &rPageSize);
 
@@ -1004,7 +1016,6 @@ public:
 Writer& OutWW8_SwGrfNode( Writer& rWrt, SwCntntNode& rNode );
 Writer& OutWW8_SwOleNode( Writer& rWrt, SwCntntNode& rNode );
 Writer& OutWW8_SwSectionNode(Writer& rWrt, SwSectionNode& rSectionNode );
-Writer& OutWW8_SwTblNode( Writer& rWrt, SwTableNode & rNode );
 
 Writer& OutWW8_SwFmtHoriOrient( Writer& rWrt, const SfxPoolItem& rHt );
 Writer& OutWW8_SwFmtVertOrient( Writer& rWrt, const SfxPoolItem& rHt );
@@ -1013,6 +1024,23 @@ sal_Int16 GetWordFirstLineOffset(const S
 //A bit of a bag on the side for now
 String FieldString(ww::eField eIndex);
 String BookmarkToWord(const String &rBookmark);
+
+class WW8SHDLong
+{
+    sal_uInt32 m_cvFore;
+    sal_uInt32 m_cvBack;
+    sal_uInt16 m_ipat;
+    
+public:
+    WW8SHDLong() : m_cvFore(0), m_cvBack(0), m_ipat(0) {}
+    virtual ~WW8SHDLong() {}
+    
+    void Write(SwWW8Writer & rWriter);
+    void setCvFore(sal_uInt32 cvFore) { m_cvFore = cvFore; }
+    void setCvBack(sal_uInt32 cvBack) { m_cvBack = cvBack; }
+    void setIPat(sal_uInt16 ipat) { m_ipat = ipat; }
+};
+
 #endif  //  _WRTWW8_HXX
 
 /* vi:set tabstop=4 shiftwidth=4 expandtab: */
Index: sw/source/filter/ww8/ww8atr.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8atr.cxx,v
retrieving revision 1.113
retrieving revision 1.113.40.3
diff -u -p -u -p -b -w -B -r1.113 -r1.113.40.3
--- sw/source/filter/ww8/ww8atr.cxx	8 Jul 2008 08:30:16 -0000	1.113
+++ sw/source/filter/ww8/ww8atr.cxx	25 Aug 2008 15:32:49 -0000	1.113.40.3
@@ -3436,13 +3436,17 @@ void SwWW8Writer::WriteCellEnd()
         pMagicTable->Append(Fc2Cp(nOffset),0x122);
 }
 
-void SwWW8Writer::WriteRowEnd()
+void SwWW8Writer::WriteRowEnd(sal_uInt32 nDepth)
 {
+    if (nDepth == 1)
     WriteChar( (BYTE)0x07 );
+    else if (nDepth > 1)
+        WriteChar( (BYTE)0x0d );
+    
     //Technically in a word document this is a different value for a row ends
     //that are not row ends directly after a cell with a graphic. But it
     //doesn't seem to make a difference
-    pMagicTable->Append(Fc2Cp(Strm().Tell()),0x1B6);
+    //pMagicTable->Append(Fc2Cp(Strm().Tell()),0x1B6);
 }
 
 static Writer& OutWW8_SwFmtPageDesc(Writer& rWrt, const SfxPoolItem& rHt)
Index: sw/source/filter/ww8/ww8par.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par.cxx,v
retrieving revision 1.199
retrieving revision 1.199.12.5
diff -u -p -u -p -b -w -B -r1.199 -r1.199.12.5
--- sw/source/filter/ww8/ww8par.cxx	4 Sep 2008 10:25:19 -0000	1.199
+++ sw/source/filter/ww8/ww8par.cxx	24 Sep 2008 08:54:40 -0000	1.199.12.5
@@ -2228,6 +2228,9 @@ bool SwWW8ImplReader::ProcessSpecial(boo
     }
     if (bStartTab)
     {
+        WW8PLCFxSave1 aSave;
+        pPlcxMan->GetPap()->Save( aSave );
+
         if (bAnl)                           // Nummerierung ueber Zellengrenzen
             StopAllAnl();                   // fuehrt zu Absturz -> keine Anls
                                             // in Tabellen
@@ -2243,6 +2246,7 @@ bool SwWW8ImplReader::ProcessSpecial(boo
         // nach StartTable ist ein ReSync noetig ( eigentlich nur, falls die
         // Tabelle ueber eine FKP-Grenze geht
         rbReSync = true;
+        pPlcxMan->GetPap()->Restore( aSave );
     }
     return bTableRowEnd;
 }
@@ -2535,7 +2539,10 @@ bool SwWW8ImplReader::AddTextToParagraph
                 rDoc.Insert (*pPaM, rAddString, true);
             }
         }
+
+        bReadTable = false;        
     }
+    
     return true;
 }
 
@@ -2757,7 +2764,15 @@ bool SwWW8ImplReader::ReadChar(long nPos
                         bRet = false;
                     }
                 }
+                else if (bWasTabCellEnd)
+                {
+                    TabCellEnd();
+                    bRet = false;
+                }
             }
+            
+            bWasTabCellEnd = false;
+
             break;              // line end
         case 0x5:               // Annotation reference
         case 0x13:
@@ -3194,7 +3209,8 @@ SwWW8ImplReader::SwWW8ImplReader(BYTE nV
     mbNewDoc(bNewDoc),
 	nDropCap(0),
     nIdctHint(0),
-	bBidi(false)
+	bBidi(false),
+    bReadTable(false)
 {
     pStrm->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
     nWantedVersion = nVersionPara;
@@ -3225,7 +3241,7 @@ SwWW8ImplReader::SwWW8ImplReader(BYTE nV
     nInTable=0;
     bReadNoTbl = bPgSecBreak = bSpec = bObj = bTxbxFlySection
                = bHasBorder = bSymbol = bIgnoreText
-               = bWasTabRowEnd = false;
+               = bWasTabRowEnd = bWasTabCellEnd = false;
     bShdTxtCol = bCharShdTxtCol = bAnl = bHdFtFtnEdn = bFtnEdn
                = bIsHeader = bIsFooter = bIsUnicode = bCpxStyle = bStyNormal =
                  bWWBugNormal  = false;
Index: sw/source/filter/ww8/ww8par.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par.hxx,v
retrieving revision 1.159
retrieving revision 1.159.12.2
diff -u -p -u -p -b -w -B -r1.159 -r1.159.12.2
--- sw/source/filter/ww8/ww8par.hxx	4 Sep 2008 10:25:34 -0000	1.159
+++ sw/source/filter/ww8/ww8par.hxx	17 Sep 2008 16:12:01 -0000	1.159.12.2
@@ -1050,6 +1050,7 @@ private:
     bool bIgnoreText;       // z.B. fuer FieldVanish
     int  nInTable;          // wird gerade eine Tabelle eingelesen
     bool bWasTabRowEnd;     // Tabelle : Row End Mark
+    bool bWasTabCellEnd;    // table: Cell End Mark
 
     bool bShdTxtCol;        // Textfarbe indirekt gesetzt ( Hintergrund sw )
     bool bCharShdTxtCol;    // Textfarbe indirekt gesetzt ( Zeichenhintergrund sw )
@@ -1096,6 +1097,8 @@ private:
 
     int nIdctHint;
 	bool bBidi;
+    bool bReadTable;
+    boost::shared_ptr<SwPaM> mpTableEndPaM;
 
 //---------------------------------------------
 
@@ -1496,6 +1499,7 @@ public:     // eigentlich private, geht 
 
 
     void Read_TabRowEnd(        USHORT, const BYTE* pData, short nLen );
+    void Read_TabCellEnd(        USHORT, const BYTE* pData, short nLen );
     static bool ParseTabPos(WW8_TablePos *aTabPos, WW8PLCFx_Cp_FKP* pPap);
     void Read_Shade(            USHORT, const BYTE* pData, short nLen );
     void Read_ANLevelNo(        USHORT, const BYTE* pData, short nLen );
Index: sw/source/filter/ww8/ww8par2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par2.cxx,v
retrieving revision 1.146
retrieving revision 1.146.2.4
diff -u -p -u -p -b -w -B -r1.146 -r1.146.2.4
--- sw/source/filter/ww8/ww8par2.cxx	19 Aug 2008 10:49:19 -0000	1.146
+++ sw/source/filter/ww8/ww8par2.cxx	19 Sep 2008 10:58:40 -0000	1.146.2.4
@@ -2528,6 +2527,7 @@ void WW8TabDesc::UseSwTable()
     aDup.Insert(*pIo->pPaM->GetPoint());
 
     pIo->bWasTabRowEnd = false;
+    pIo->bWasTabCellEnd = false;
 }
 
 void WW8TabDesc::MergeCells()
@@ -2710,6 +2710,7 @@ void WW8TabDesc::FinishSwTable()
     aDup.Insert(*pIo->pPaM->GetPoint());
 
     pIo->bWasTabRowEnd = false;
+    pIo->bWasTabCellEnd = false;
 
     pIo->maInsertedTables.InsertTable(*pTblNd, *pIo->pPaM);
 
@@ -3440,24 +3441,24 @@ bool SwWW8ImplReader::StartTable(WW8_CP 
                 "how could we be in a local apo and have no apo");
         }
 
-        if ( !maTableStack.empty() && !InEqualApo(nNewInTable) )
-        {
-            pTableDesc->pParentPos = new SwPosition(*pPaM->GetPoint());
-            SfxItemSet aItemSet(rDoc.GetAttrPool(),
-                RES_FRMATR_BEGIN, RES_FRMATR_END-1);
-            // --> OD 2005-01-26 #i33818# - anchor the Writer fly frame for
-            // the nested table at-character.
-            // --> OD 2005-03-21 #i45301#
-            SwFmtAnchor aAnchor( eAnchor );
-            aAnchor.SetAnchor( pTableDesc->pParentPos );
-            aItemSet.Put( aAnchor );
-            pTableDesc->pFlyFmt = rDoc.MakeFlySection( eAnchor,
-                pTableDesc->pParentPos, &aItemSet);
-            ASSERT( pTableDesc->pFlyFmt->GetAnchor().GetAnchorId() == eAnchor,
-                    "Not the anchor type requested!" );
-            // <--
-            MoveInsideFly(pTableDesc->pFlyFmt);
-        }
+//         if ( !maTableStack.empty() && !InEqualApo(nNewInTable) )
+//         {
+//             pTableDesc->pParentPos = new SwPosition(*pPaM->GetPoint());
+//             SfxItemSet aItemSet(rDoc.GetAttrPool(),
+//                 RES_FRMATR_BEGIN, RES_FRMATR_END-1);
+//             // --> OD 2005-01-26 #i33818# - anchor the Writer fly frame for
+//             // the nested table at-character.
+//             // --> OD 2005-03-21 #i45301#
+//             SwFmtAnchor aAnchor( eAnchor );
+//             aAnchor.SetAnchor( pTableDesc->pParentPos );
+//             aItemSet.Put( aAnchor );
+//             pTableDesc->pFlyFmt = rDoc.MakeFlySection( eAnchor,
+//                 pTableDesc->pParentPos, &aItemSet);
+//             ASSERT( pTableDesc->pFlyFmt->GetAnchor().GetAnchorId() == eAnchor,
+//                     "Not the anchor type requested!" );
+//             // <--
+//             MoveInsideFly(pTableDesc->pFlyFmt);
+//         }
         pTableDesc->CreateSwTable();
         if (pTableDesc->pFlyFmt)
         {
@@ -3510,8 +3511,23 @@ bool SwWW8ImplReader::StartTable(WW8_CP 
 void SwWW8ImplReader::TabCellEnd()
 {
     if (nInTable && pTableDesc)
+    {
         pTableDesc->TableCellEnd();
+
+        if (bReadTable && ! SwPaM::Overlap(*pPaM, *mpTableEndPaM))
+        {
+            rDoc.DelFullPara(*mpTableEndPaM);
+        }    
+    }
+    
     bFirstPara = true;    // We have come to the end of a cell so FirstPara flag
+    bReadTable = false;
+}
+
+void SwWW8ImplReader::Read_TabCellEnd( USHORT, const BYTE* pData, short nLen)
+{
+    if( ( nLen > 0 ) && ( *pData == 1 ) )
+        bWasTabCellEnd = true;
 }
 
 void SwWW8ImplReader::Read_TabRowEnd( USHORT, const BYTE* pData, short nLen )   // Sprm25
@@ -3557,6 +3573,9 @@ void SwWW8ImplReader::StopTable()
         maTracer.EnterEnvironment(sw::log::eTable, rtl::OUString::valueOf(
             static_cast<sal_Int32>(maTableStack.size())));
     }
+    
+    bReadTable = true;
+    mpTableEndPaM.reset(new SwPaM(*pPaM));
 }
 
 // GetTableLeft() wird fuer absatzgebundene Grafikobjekte in Tabellen
Index: sw/source/filter/ww8/ww8par5.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par5.cxx,v
retrieving revision 1.111
retrieving revision 1.110.40.4
diff -u -p -u -p -b -w -B -r1.111 -r1.110.40.4
--- sw/source/filter/ww8/ww8par5.cxx	4 Sep 2008 10:26:05 -0000	1.111
+++ sw/source/filter/ww8/ww8par5.cxx	12 Sep 2008 08:55:35 -0000	1.110.40.4
@@ -428,6 +428,7 @@ void SwWW8ImplReader::ConvertFFileName( 
 {
     rName = rOrg;
     rName.SearchAndReplaceAllAscii( "\\\\", String( '\\' ));
+    rName.SearchAndReplaceAllAscii( "%20", String( ' ' ));
 
     // ggfs. anhaengende Anfuehrungszeichen entfernen
     if( rName.Len() &&  '"' == rName.GetChar( rName.Len()-1 ))
Index: sw/source/filter/ww8/ww8par6.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par6.cxx,v
retrieving revision 1.188
retrieving revision 1.188.8.1
diff -u -p -u -p -b -w -B -r1.188 -r1.188.8.1
--- sw/source/filter/ww8/ww8par6.cxx	16 Jul 2008 20:11:56 -0000	1.188
+++ sw/source/filter/ww8/ww8par6.cxx	17 Sep 2008 12:54:40 -0000	1.188.8.1
@@ -6037,7 +6037,7 @@ const wwSprmDispatcher *GetWW8SprmDispat
         {0x9410, 0},                                 //undocumented
         {0x703A, 0},                                 //undocumented
         {0x303B, 0},                                 //undocumented
-        {0x244B, 0},                                 //undocumented, must be
+        {0x244B, &SwWW8ImplReader::Read_TabCellEnd}, //undocumented, must be
                                                      //subtable "sprmPFInTable"
         {0x244C, &SwWW8ImplReader::Read_TabRowEnd},  //undocumented, must be
                                                      // subtable "sprmPFTtp"
Index: sw/source/filter/ww8/ww8scan.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.cxx,v
retrieving revision 1.142
retrieving revision 1.142.12.1
diff -u -p -u -p -b -w -B -r1.142 -r1.142.12.1
--- sw/source/filter/ww8/ww8scan.cxx	4 Sep 2008 10:26:25 -0000	1.142
+++ sw/source/filter/ww8/ww8scan.cxx	15 Sep 2008 13:24:39 -0000	1.142.12.1
@@ -1778,10 +1778,10 @@ WW8ScannerBase::WW8ScannerBase( SvStream
                     pWwFib->fcPlcfHdrtxbxBkd, pWwFib->lcbPlcfHdrtxbxBkd, 0);
             }
             // Sub table cp positions
-            if (pWwFib->fcMagicTable && pWwFib->lcbMagicTable)
+            if (pWwFib->fcPlcfTch && pWwFib->lcbPlcfTch)
             {
                 pMagicTables = new WW8PLCFspecial( pTblSt,
-                    pWwFib->fcMagicTable, pWwFib->lcbMagicTable, 4);
+                    pWwFib->fcPlcfTch, pWwFib->lcbPlcfTch, 4);
             }
             // Sub document cp positions
             if (pWwFib->fcPlcfwkb && pWwFib->lcbPlcfwkb)
@@ -5534,8 +5534,8 @@ WW8Fib::WW8Fib(SvStream& rSt, BYTE nWant
             rSt >> fcSttbListNames;
             rSt >> lcbSttbListNames;
             rSt.Seek( 0x382 );          // MagicTables
-            rSt >> fcMagicTable;
-            rSt >> lcbMagicTable;
+            rSt >> fcPlcfTch;
+            rSt >> lcbPlcfTch;
             if( 0 != rSt.GetError() )
                 nFibError = ERR_SWG_READ_ERROR;
 
@@ -5569,7 +5569,7 @@ WW8Fib::WW8Fib(BYTE nVer)
     {
         fcMin = 0x400;
         wIdent = 0xa5ec;
-        nFib = 0xc2;
+        nFib = 0x0101;
         nFibBack = 0xbf;
         nProduct = 0x204D;
 
@@ -5889,8 +5889,8 @@ bool WW8Fib::Write(SvStream& rStrm)
         Set_UInt32( pData, lcbSttbListNames );
 
         pData += 0x382 - 0x37A;
-        Set_UInt32( pData, fcMagicTable );
-        Set_UInt32( pData, lcbMagicTable );
+        Set_UInt32( pData, fcPlcfTch );
+        Set_UInt32( pData, lcbPlcfTch );
 
         pData += 0x3FA - 0x38A;
         Set_UInt16( pData, (UINT16)0x0002);
Index: sw/source/filter/ww8/ww8scan.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.hxx,v
retrieving revision 1.85
retrieving revision 1.85.12.1
diff -u -p -u -p -b -w -B -r1.85 -r1.85.12.1
--- sw/source/filter/ww8/ww8scan.hxx	4 Sep 2008 10:26:39 -0000	1.85
+++ sw/source/filter/ww8/ww8scan.hxx	15 Sep 2008 13:24:39 -0000	1.85.12.1
@@ -1403,8 +1403,8 @@ public:
     WW8_FC fcSttbListNames;// 0x0372 PLCF for Listname Table
     INT32 lcbSttbListNames;// 0x0376
 
-    WW8_FC fcMagicTable;
-    INT32 lcbMagicTable;
+    WW8_FC fcPlcfTch;
+    INT32 lcbPlcfTch;
     /*
         General-Varaiblen, die fuer Ver67 und Ver8 verwendet werden,
         obwohl sie in der jeweiligen DATEI verschiedene Groesse haben:
