Index: sfx2/source/doc/docfile.cxx
===================================================================
RCS file: /cvs/framework/sfx2/source/doc/docfile.cxx,v
retrieving revision 1.203.2.3.4.4
retrieving revision 1.203.2.3
diff -u -p -u -p -b -w -B -r1.203.2.3.4.4 -r1.203.2.3
--- sfx2/source/doc/docfile.cxx	12 Dec 2008 11:51:11 -0000	1.203.2.3.4.4
+++ sfx2/source/doc/docfile.cxx	18 Nov 2008 08:50:26 -0000	1.203.2.3
@@ -692,8 +692,6 @@ sal_Bool SfxMedium::Commit()
         Transfer_Impl();
 	}
 
-    // remove truncation mode from the flags
-    nStorOpenMode &= ( ~STREAM_TRUNC );
     return GetError() == SVSTREAM_OK;
 }
 
@@ -892,10 +890,105 @@ uno::Reference < embed::XStorage > SfxMe
 
     DBG_ASSERT( !pOutStream, "OutStream in a readonly Medium?!" );
 
-    // TODO/LATER: The current solution is to store the document temporary and then copy it to the target location;
-    // in future it should be stored directly and then copied to the temporary location, since in this case no
-    // file attributes have to be preserved and system copying mechanics could be used instead of streaming.
+    // medium based on OutputStream: must work with TempFile
+    if( aLogicName.CompareToAscii( "private:stream", 14 ) == COMPARE_EQUAL
+	  || !::utl::LocalFileHelper::IsLocalFile( aLogicName ) )
     CreateTempFileNoCopy();
+	// if Medium already contains a stream - TODO/LATER: store stream/outputstream in ImplData, not in Medium
+	else if ( GetItemSet()->GetItemState( SID_STREAM ) < SFX_ITEM_SET )
+	{
+		// check whether the backup should be created
+		StorageBackup_Impl();
+
+		if ( GetError() )
+			return uno::Reference< embed::XStorage >();
+
+        ::rtl::OUString aOutputURL = GetOutputStorageURL_Impl();
+
+        SFX_ITEMSET_ARG( GetItemSet(), pOverWrite, SfxBoolItem, SID_OVERWRITE, sal_False );
+        SFX_ITEMSET_ARG( GetItemSet(), pRename, SfxBoolItem, SID_RENAME, sal_False );
+        sal_Bool bRename = pRename ? pRename->GetValue() : FALSE;
+        sal_Bool bOverWrite = pOverWrite ? pOverWrite->GetValue() : !bRename;
+
+        // the target file must be truncated before a storage based on it is created
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xFactory = ::comphelper::getProcessServiceFactory();
+            uno::Reference< ::com::sun::star::ucb::XSimpleFileAccess > xSimpleFileAccess(
+                    xFactory->createInstance( ::rtl::OUString::createFromAscii("com.sun.star.ucb.SimpleFileAccess") ),
+                    uno::UNO_QUERY_THROW );
+
+            uno::Reference< ucb::XCommandEnvironment > xDummyEnv;
+            ::ucbhelper::Content aContent = ::ucbhelper::Content( aOutputURL, xDummyEnv );
+
+            uno::Reference< io::XStream > xStream;
+            sal_Bool bDeleteOnFailure = sal_False;
+
+            try
+            {
+                xStream = aContent.openWriteableStreamNoLock();
+
+                if ( !bOverWrite )
+                {
+                    // the stream should not exist, it should not be possible to open it
+                    if ( xStream->getOutputStream().is() )
+                        xStream->getOutputStream()->closeOutput();
+                    if ( xStream->getInputStream().is() )
+                        xStream->getInputStream()->closeInput();
+
+                    xStream = uno::Reference< io::XStream >();
+                    SetError( ERRCODE_IO_GENERAL );
+                }
+            }
+            catch ( ucb::InteractiveIOException const & e )
+            {
+                if ( e.Code == ucb::IOErrorCode_NOT_EXISTING )
+                {
+                    // Create file...
+                    SvMemoryStream aStream(0,0);
+                    uno::Reference< io::XInputStream > xInput( new ::utl::OInputStreamWrapper( aStream ) );
+                    ucb::InsertCommandArgument aInsertArg;
+                    aInsertArg.Data = xInput;
+                    aInsertArg.ReplaceExisting = sal_False;
+                    aContent.executeCommand( rtl::OUString::createFromAscii( "insert" ), uno::makeAny( aInsertArg ) );
+
+                    // Try to open one more time
+                    xStream = aContent.openWriteableStreamNoLock();
+                    bDeleteOnFailure = sal_True;
+                }
+                else
+                    throw;
+            }
+
+            if ( xStream.is() )
+            {
+                if ( BasedOnOriginalFile_Impl() )
+                {
+                    // the storage will be based on original file, the wrapper should be used
+                    xStream = new OPostponedTruncationFileStream( aOutputURL, xFactory, xSimpleFileAccess, xStream, bDeleteOnFailure );
+                }
+                else
+                {
+                    // the storage will be based on the temporary file, the stream can be truncated directly
+                    uno::Reference< io::XOutputStream > xOutStream = xStream->getOutputStream();
+                    uno::Reference< io::XTruncate > xTruncate( xOutStream, uno::UNO_QUERY );
+                    if ( !xTruncate.is() )
+                        throw uno::RuntimeException();
+
+                    xTruncate->truncate();
+                    xOutStream->flush();
+                }
+
+                pImp->xStream = xStream;
+                GetItemSet()->Put( SfxUsrAnyItem( SID_STREAM, makeAny( xStream ) ) );
+            }
+        }
+        catch( uno::Exception& )
+        {
+            // TODO/LATER: try to use the temporary file in case the target content can not be opened, it might happen in case of some FS, the copy functionality might work in this case
+            SetError( ERRCODE_IO_GENERAL );
+        }
+    }
 
     return GetStorage();
 }
