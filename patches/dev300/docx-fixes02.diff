Misc docx fixes

From: CÃ©dric Bosdonnat <cedricbosdo@openoffice.org>


---

 sax/source/tools/fastserializer.cxx          |   45 +++
 sax/source/tools/fastserializer.hxx          |    7 
 sw/source/filter/ww8/attributeoutputbase.hxx |    5 
 sw/source/filter/ww8/docxattributeoutput.cxx |  404 +++++++++++++++++++++++---
 sw/source/filter/ww8/docxattributeoutput.hxx |    8 -
 sw/source/filter/ww8/makefile.mk             |    1 
 sw/source/filter/ww8/wrtw8nds.cxx            |   88 +-----
 sw/source/filter/ww8/wrtw8sty.cxx            |   15 +
 sw/source/filter/ww8/wrtww8.hxx              |   69 ++++
 sw/source/filter/ww8/ww8atr.cxx              |   25 --
 sw/source/filter/ww8/ww8attributeoutput.hxx  |    5 
 11 files changed, 525 insertions(+), 147 deletions(-)


diff --git sax/source/tools/fastserializer.cxx sax/source/tools/fastserializer.cxx
index b270d15..95c1621 100644
--- sax/source/tools/fastserializer.cxx
+++ sax/source/tools/fastserializer.cxx
@@ -34,6 +34,10 @@
 
 #include <string.h>
 
+#if DEBUG
+#include <cstdio>
+#endif
+
 using ::rtl::OString;
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
@@ -321,6 +325,28 @@ namespace sax_fastparser {
         maMarkStack.push( ForMerge() );
     }
 
+#if DEBUG
+    void FastSaxSerializer::printMarkStack( )
+    {
+        ::std::stack< ForMerge > aCopy( maMarkStack );
+        int nSize = aCopy.size();
+        int i = 0;
+        while ( !aCopy.empty() )
+        {
+            fprintf( stderr, "%d\n", nSize - i );
+
+            ForMerge aMarks = aCopy.top( );
+            aMarks.print();
+
+
+            fprintf( stderr, "\n" );
+
+            aCopy.pop( );
+            i++;
+        }
+    }
+#endif
+
     void FastSaxSerializer::mergeTopMarks( sax_fastparser::MergeMarksEnum eMergeType )
     {
         if ( maMarkStack.empty() )
@@ -360,6 +386,25 @@ namespace sax_fastparser {
         return maData;
     }
 
+#if DEBUG
+    void FastSaxSerializer::ForMerge::print( )
+    {
+        fprintf( stderr, "Data: " );
+        for ( sal_Int32 i=0, len=maData.getLength(); i < len; i++ )
+        {
+            fprintf( stderr, "%c", maData[i] );
+        }
+
+        fprintf( stderr, "\nPostponed: " );
+        for ( sal_Int32 i=0, len=maPostponed.getLength(); i < len; i++ )
+        {
+            fprintf( stderr, "%c", maPostponed[i] );
+        }
+
+        fprintf( stderr, "\n" );
+    }
+#endif
+
     void FastSaxSerializer::ForMerge::prepend( const Int8Sequence &rWhat )
     {
         merge( maData, rWhat, false );
diff --git sax/source/tools/fastserializer.hxx sax/source/tools/fastserializer.hxx
index 94cf7c4..f07094d 100644
--- sax/source/tools/fastserializer.hxx
+++ sax/source/tools/fastserializer.hxx
@@ -134,6 +134,9 @@ private:
         ForMerge() : maData(), maPostponed() {}
 
         Int8Sequence& getData();
+#if DEBUG
+        void print();
+#endif
 
         void prepend( const Int8Sequence &rWhat );
         void append( const Int8Sequence &rWhat );
@@ -143,6 +146,10 @@ private:
         static void merge( Int8Sequence &rTop, const Int8Sequence &rMerge, bool bAppend );
     };
 
+#if DEBUG
+        void printMarkStack( );
+#endif
+
     ::std::stack< ForMerge > maMarkStack;
 
     void writeFastAttributeList( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastAttributeList >& Attribs );
diff --git sw/source/filter/ww8/attributeoutputbase.hxx sw/source/filter/ww8/attributeoutputbase.hxx
index c005746..1ec45f6 100644
--- sw/source/filter/ww8/attributeoutputbase.hxx
+++ sw/source/filter/ww8/attributeoutputbase.hxx
@@ -176,7 +176,7 @@ public:
     virtual void RawText( const String& rText, bool bForceUnicode, rtl_TextEncoding eCharSet ) = 0;
 
     /// Output ruby start.
-    virtual void StartRuby( const SwTxtNode& rNode, const SwFmtRuby& rRuby ) = 0;
+    virtual void StartRuby( const SwTxtNode& rNode, xub_StrLen nPos, const SwFmtRuby& rRuby ) = 0;
 
     /// Output ruby end.
     virtual void EndRuby() = 0;
@@ -245,7 +245,8 @@ public:
 
     /// Start of a style in the styles table.
     virtual void StartStyle( const String& rName, bool bPapFmt,
-            USHORT nBase, USHORT nNext, USHORT nWwId, USHORT nId ) = 0;
+            USHORT nBase, USHORT nNext, USHORT nWwId, USHORT nId, 
+            bool bAutoUpdate ) = 0;
 
     /// End of a style in the styles table.
     virtual void EndStyle() = 0;
diff --git sw/source/filter/ww8/docxattributeoutput.cxx sw/source/filter/ww8/docxattributeoutput.cxx
index ce74da7..cc4dfca 100644
--- sw/source/filter/ww8/docxattributeoutput.cxx
+++ sw/source/filter/ww8/docxattributeoutput.cxx
@@ -31,6 +31,13 @@
 #include "writerwordglue.hxx"
 #include "wrtww8.hxx"
 #include "ww8par.hxx"
+#include "fmtcntnt.hxx"
+#include "fmtsrnd.hxx"
+#include "fchrfmt.hxx"
+#include "tgrditem.hxx"
+#include "fmtruby.hxx"
+#include "charfmt.hxx"
+#include "breakit.hxx"
 
 #include <oox/core/tokens.hxx>
 #include <oox/export/drawingml.hxx>
@@ -213,6 +220,25 @@ void DocxAttributeOutput::EndParagraph( ww8::WW8TableNodeInfoInner::Pointer_t pT
     FinishTableRowCell( pTextNodeInfoInner );
 
     m_bParagraphOpened = false;
+
+    // Write the anchored frame if any
+    if ( m_pParentFrame )
+    {
+        const SwFrmFmt& rFrmFmt = m_pParentFrame->GetFrmFmt( );
+        const SwNodeIndex* pNodeIndex = rFrmFmt.GetCntnt().GetCntntIdx();
+
+        ULONG nStt = pNodeIndex ? pNodeIndex->GetIndex()+1                  : 0;
+        ULONG nEnd = pNodeIndex ? pNodeIndex->GetNode().EndOfSectionIndex() : 0;
+
+        m_rExport.SaveData( nStt, nEnd );
+
+        m_rExport.mpParentFrame = m_pParentFrame;
+        m_pParentFrame = NULL;
+
+        m_rExport.WriteText( );
+        
+        m_rExport.RestoreData();
+    }
 }
 
 void DocxAttributeOutput::FinishTableRowCell( ww8::WW8TableNodeInfoInner::Pointer_t pInner, bool bForceEmptyParagraph )
@@ -292,6 +318,14 @@ void DocxAttributeOutput::InitCollectedParagraphProperties()
 
 void DocxAttributeOutput::WriteCollectedParagraphProperties()
 {
+    if ( m_pFlyAttrList )
+    {
+        XFastAttributeListRef xAttrList( m_pFlyAttrList );
+        m_pFlyAttrList = NULL;
+
+        m_pSerializer->singleElementNS( XML_w, XML_framePr, xAttrList );
+    }
+
     if ( m_pSpacingAttrList )
     {
         XFastAttributeListRef xAttrList( m_pSpacingAttrList );
@@ -755,11 +789,69 @@ void DocxAttributeOutput::RawText( const String& /*rText*/, bool /*bForceUnicode
 #endif
 }
 
-void DocxAttributeOutput::StartRuby( const SwTxtNode& /*rNode*/, const SwFmtRuby& /*rRuby*/ )
+void DocxAttributeOutput::StartRuby( const SwTxtNode& rNode, xub_StrLen nPos, const SwFmtRuby& rRuby )
 {
 #if OSL_DEBUG_LEVEL > 0
     fprintf( stderr, "TODO DocxAttributeOutput::StartRuby( const SwTxtNode& rNode, const SwFmtRuby& rRuby )\n" );
 #endif
+    m_pSerializer->startElementNS( XML_w, XML_ruby, FSEND );
+    m_pSerializer->startElementNS( XML_w, XML_rubyPr, FSEND );
+    // hps
+    // hpsBaseText
+    // hpsRaise
+    // lid
+    lang::Locale aLocale( SwBreakIt::Get()->GetLocale( 
+                rNode.GetLang( nPos ) ) );
+    OUString sLang( aLocale.Language );
+    if ( aLocale.Country.getLength( ) > 0 )
+        sLang += OUString::createFromAscii( "-" ) + OUString( aLocale.Country );
+    m_pSerializer->singleElementNS( XML_w, XML_lid,
+            FSNS( XML_w, XML_val ), 
+            OUStringToOString( sLang, RTL_TEXTENCODING_UTF8 ).getStr( ), FSEND );
+
+
+    OString sAlign ( "center" );
+    switch ( rRuby.GetAdjustment( ) )
+    {
+        case 0:
+            sAlign = OString( "left" );
+            break;
+        case 1:
+            // Defaults to center
+            break;
+        case 2:
+            sAlign = OString( "right" );
+            break;
+        case 3:
+            sAlign = OString( "distributeLetter" );
+            break;
+        case 4:
+            sAlign = OString( "distributeSpace" );
+            break;
+        default:
+            break;
+    }
+    m_pSerializer->singleElementNS( XML_w, XML_rubyAlign, 
+            FSNS( XML_w, XML_val ), sAlign.getStr(), FSEND );
+    m_pSerializer->endElementNS( XML_w, XML_rubyPr );
+
+    m_pSerializer->startElementNS( XML_w, XML_rt, FSEND );
+    StartRun( NULL );
+    StartRunProperties( );
+    SwAttrIter aAttrIt( m_rExport, rNode );
+    aAttrIt.OutAttr( nPos, true );
+    USHORT nStyle = m_rExport.GetId( *rRuby.GetTxtRuby()->GetCharFmt() );
+    OString aStyleId( "style" );
+    aStyleId += OString::valueOf( sal_Int32( nStyle ) );
+    m_pSerializer->singleElementNS( XML_w, XML_rStyle,
+            FSNS( XML_w, XML_val ), aStyleId.getStr(), FSEND );
+    EndRunProperties( NULL );
+    RunText( rRuby.GetText( ) );
+    EndRun( );
+    m_pSerializer->endElementNS( XML_w, XML_rt );
+   
+    m_pSerializer->startElementNS( XML_w, XML_rubyBase, FSEND );
+    StartRun( NULL );
 }
 
 void DocxAttributeOutput::EndRuby()
@@ -767,6 +859,9 @@ void DocxAttributeOutput::EndRuby()
 #if OSL_DEBUG_LEVEL > 0
     fprintf( stderr, "TODO DocxAttributeOutput::EndRuby()\n" );
 #endif
+    EndRun( );
+    m_pSerializer->endElementNS( XML_w, XML_rubyBase );
+    m_pSerializer->endElementNS( XML_w, XML_ruby );
 }
 
 bool DocxAttributeOutput::AnalyzeURL( const String& rUrl, const String& rTarget, String* pLinkURL, String* pMark )
@@ -1810,6 +1905,12 @@ void DocxAttributeOutput::OutputFlyFrame_Impl( const sw::Frame &rFrame, const Po
                     WriteOLE2Obj( pSdrObj, rFrame.GetLayoutSize() );
             }
             break;
+        case sw::Frame::eTxtBox:
+            {
+                // The frame output is postponed at the end of the anchor paragraph
+                m_pParentFrame = &rFrame;
+            }
+            break;
         default:
 #if OSL_DEBUG_LEVEL > 0
             fprintf( stderr, "TODO DocxAttributeOutput::OutputFlyFrame_Impl( const sw::Frame& rFrame, const Point& rNdTopLeft ) - frame type '%s'\n",
@@ -1824,7 +1925,7 @@ void DocxAttributeOutput::OutputFlyFrame_Impl( const sw::Frame &rFrame, const Po
 }
 
 void DocxAttributeOutput::StartStyle( const String& rName, bool bPapFmt,
-        USHORT nBase, USHORT nNext, USHORT /*nWwId*/, USHORT nId )
+        USHORT nBase, USHORT nNext, USHORT /*nWwId*/, USHORT nId, bool bAutoUpdate )
 {
     OString aStyle( "style" );
 
@@ -1847,6 +1948,9 @@ void DocxAttributeOutput::StartStyle( const String& rName, bool bPapFmt,
     m_pSerializer->singleElementNS( XML_w, XML_next,
             FSNS( XML_w, XML_val ), ( aStyle + OString::valueOf( sal_Int32( nNext ) ) ).getStr(),
             FSEND );
+
+    if ( bAutoUpdate )
+        m_pSerializer->singleElementNS( XML_w, XML_autoRedefine, FSEND );
 }
 
 void DocxAttributeOutput::EndStyle()
@@ -2364,11 +2468,43 @@ void DocxAttributeOutput::CharCrossedOut( const SvxCrossedOutItem& rCrossedOut )
     }
 }
 
-void DocxAttributeOutput::CharEscapement( const SvxEscapementItem& /*rEscapement*/ )
-{
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::CharEscapement()\n" );
-#endif
+void DocxAttributeOutput::CharEscapement( const SvxEscapementItem& rEscapement )
+{ 
+    OString sIss;
+    short nEsc = rEscapement.GetEsc(), nProp = rEscapement.GetProp();
+    if ( !nEsc )
+    {
+        sIss = OString( "baseline" );
+        nEsc = 0;
+        nProp = 100;
+    }
+    else if ( DFLT_ESC_PROP == nProp )
+    {
+        if ( DFLT_ESC_SUB == nEsc || DFLT_ESC_AUTO_SUB == nEsc )
+            sIss = OString( "subscript" );
+        else if ( DFLT_ESC_SUPER == nEsc || DFLT_ESC_AUTO_SUPER == nEsc )
+            sIss = OString( "superscript" );
+    }
+    
+    if ( sIss.getLength( ) > 0 )
+        m_pSerializer->singleElementNS( XML_w, XML_vertAlign, 
+           FSNS( XML_w, XML_val ), sIss.getStr(), FSEND );
+
+    if ( sIss.getLength() == 0 || sIss.match( OString( "baseline" ) ) )
+    {
+        long nHeight = ((SvxFontHeightItem&)m_rExport.GetItem(
+                                    RES_CHRATR_FONTSIZE )).GetHeight();
+        OString sPos = OString::valueOf( ( nHeight * nEsc + 500 ) / 1000 );
+        m_pSerializer->singleElementNS( XML_w, XML_position,
+                FSNS( XML_w, XML_val ), sPos.getStr( ), FSEND );
+
+        if( 100 != nProp || sIss.match( OString( "baseline" ) ) )
+        {
+            OString sSize = OString::valueOf( ( nHeight * nProp + 500 ) / 1000 );
+                m_pSerializer->singleElementNS( XML_w, XML_sz,
+                    FSNS( XML_w, XML_val ), sSize.getStr( ), FSEND );
+        }
+    }
 }
 
 void DocxAttributeOutput::CharFont( const SvxFontItem& rFont)
@@ -2400,7 +2536,7 @@ void DocxAttributeOutput::CharFontSize( const SvxFontHeightItem& rFontSize)
 void DocxAttributeOutput::CharKerning( const SvxKerningItem& rKerning )
 {
     OString aKerning = OString::valueOf( ( sal_Int32 ) rKerning.GetValue() );
-    m_pSerializer->singleElementNS( XML_w, XML_kern, FSNS(XML_w, XML_val), aKerning.getStr(), FSEND );
+    m_pSerializer->singleElementNS( XML_w, XML_spacing, FSNS(XML_w, XML_val), aKerning.getStr(), FSEND );
 }
 
 void DocxAttributeOutput::CharLanguage( const SvxLanguageItem& rLanguage )
@@ -2653,11 +2789,12 @@ void DocxAttributeOutput::TextINetFormat( const SwFmtINetFmt& rLink )
     m_pSerializer->singleElementNS( XML_w, XML_rStyle, FSNS( XML_w, XML_val ), aStyleId.getStr(), FSEND );
 }
 
-void DocxAttributeOutput::TextCharFormat( const SwFmtCharFmt& )
+void DocxAttributeOutput::TextCharFormat( const SwFmtCharFmt& rCharFmt )
 {
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::TextCharFormat()\n" );
-#endif
+    OString aStyleId( "style" );
+    aStyleId += OString::valueOf( sal_Int32( m_rExport.GetId( *rCharFmt.GetCharFmt() ) ) );
+
+    m_pSerializer->singleElementNS( XML_w, XML_rStyle, FSNS( XML_w, XML_val ), aStyleId.getStr(), FSEND );
 }
 
 void DocxAttributeOutput::RefField( const SwField&  rFld, const String& rRef )
@@ -3071,9 +3208,22 @@ void DocxAttributeOutput::FormatFrameSize( const SwFmtFrmSize& rSize )
 {
     if ( m_rExport.bOutFlyFrmAttrs )
     {
- #if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatFrameSize() - Fly frames\n" );
- #endif
+        if ( !m_pFlyAttrList )
+            m_pFlyAttrList = m_pSerializer->createAttrList( );
+      
+        if ( rSize.GetWidth() && rSize.GetWidthSizeType() == ATT_FIX_SIZE )
+        {
+            m_pFlyAttrList->add( FSNS( XML_w, XML_w ), OString::valueOf( rSize.GetWidth( ) ) );
+        }
+
+        if ( rSize.GetHeight() )
+        {
+            OString sRule( "exact" );
+            if ( rSize.GetHeightSizeType() == ATT_MIN_SIZE )
+                sRule = OString( "atLeast" );
+            m_pFlyAttrList->add( FSNS( XML_w, XML_hRule ), sRule );
+            m_pFlyAttrList->add( FSNS( XML_w, XML_h ), OString::valueOf( rSize.GetHeight( ) ) );
+        }
     }
     else if ( m_rExport.bOutPageDescs ) 
     {
@@ -3103,9 +3253,12 @@ void DocxAttributeOutput::FormatLRSpace( const SvxLRSpaceItem& rLRSpace )
 {
     if ( m_rExport.bOutFlyFrmAttrs )
     {
-#if OSL_DEBUG_LEVEL > 0
-        fprintf( stderr, "DocxAttributeOutput::FormatLRSpace() - Fly frames\n" );
-#endif
+        if ( !m_pFlyAttrList )
+            m_pFlyAttrList = m_pSerializer->createAttrList();
+
+        m_pFlyAttrList->add( FSNS( XML_w, XML_hSpace ), 
+                OString::valueOf( 
+                    sal_Int32( ( rLRSpace.GetLeft() + rLRSpace.GetRight() ) / 2 ) ) );
     }
     else if ( m_rExport.bOutPageDescs ) 
     {
@@ -3146,11 +3299,17 @@ void DocxAttributeOutput::FormatLRSpace( const SvxLRSpaceItem& rLRSpace )
 
 void DocxAttributeOutput::FormatULSpace( const SvxULSpaceItem& rULSpace )
 {
-    if (!m_pSpacingAttrList)
+    if ( !m_pSpacingAttrList && !m_rExport.bOutFlyFrmAttrs )
         m_pSpacingAttrList = m_pSerializer->createAttrList();
 
     if ( m_rExport.bOutFlyFrmAttrs )
     {
+        if ( !m_pFlyAttrList )
+            m_pFlyAttrList = m_pSerializer->createAttrList();
+
+        m_pFlyAttrList->add( FSNS( XML_w, XML_vSpace ), 
+                OString::valueOf( 
+                    sal_Int32( ( rULSpace.GetLower() + rULSpace.GetUpper() ) / 2 ) ) );
     } 
     else if (m_rExport.bOutPageDescs )
     {
@@ -3192,32 +3351,150 @@ void DocxAttributeOutput::FormatULSpace( const SvxULSpaceItem& rULSpace )
     }
 }
 
-void DocxAttributeOutput::FormatSurround( const SwFmtSurround& )
+void DocxAttributeOutput::FormatSurround( const SwFmtSurround& rSurround )
 {
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatSurround()\n" );
-#endif
+    if ( m_rExport.bOutFlyFrmAttrs )
+    {
+        if ( !m_pFlyAttrList )
+            m_pFlyAttrList = m_pSerializer->createAttrList();
+
+        OString sWrap( "auto" );
+        switch ( rSurround.GetSurround( ) )
+        {
+            case SURROUND_NONE:
+                sWrap = OString( "none" );
+                break;
+            case SURROUND_THROUGHT:
+                sWrap = OString( "through" );
+                break;
+            case SURROUND_IDEAL:
+            case SURROUND_PARALLEL:
+            case SURROUND_LEFT:
+            case SURROUND_RIGHT:
+            default:
+                sWrap = OString( "around" );
+        }
+
+        m_pFlyAttrList->add( FSNS( XML_w, XML_wrap ), sWrap );
+    }
 }
 
-void DocxAttributeOutput::FormatVertOrientation( const SwFmtVertOrient& )
+void DocxAttributeOutput::FormatVertOrientation( const SwFmtVertOrient& rFlyVert )
 {
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatVertOrientation()\n" );
-#endif
+    if ( m_rExport.bOutFlyFrmAttrs )
+    {
+        if ( !m_pFlyAttrList )
+            m_pFlyAttrList = m_pSerializer->createAttrList();
+        
+        OString sAlign;
+        switch( rFlyVert.GetVertOrient() )
+        {
+            case text::VertOrientation::NONE:
+                break;
+            case text::VertOrientation::CENTER:
+            case text::VertOrientation::LINE_CENTER:
+                sAlign = OString( "center" );
+                break;
+            case text::VertOrientation::BOTTOM:
+            case text::VertOrientation::LINE_BOTTOM:
+                sAlign = OString( "bottom" );
+                break;
+            case text::VertOrientation::TOP:
+            case text::VertOrientation::LINE_TOP:
+            default:
+                sAlign = OString( "top" );
+                break;
+        }
+
+        if ( sAlign.getLength() > 0 )
+            m_pFlyAttrList->add( FSNS( XML_w, XML_yAlign ), sAlign );
+        else
+            m_pFlyAttrList->add( FSNS( XML_w, XML_y ), 
+                OString::valueOf( sal_Int32( rFlyVert.GetPos() ) ) );
+        
+        OString sVAnchor( "page" );
+        switch ( rFlyVert.GetRelationOrient( ) )
+        {
+            case text::RelOrientation::CHAR:
+            case text::RelOrientation::PRINT_AREA:
+            case text::RelOrientation::TEXT_LINE:
+                sVAnchor = OString( "column" );
+                break;
+            case text::RelOrientation::FRAME:
+            case text::RelOrientation::PAGE_LEFT:
+            case text::RelOrientation::PAGE_RIGHT:
+            case text::RelOrientation::FRAME_LEFT:
+            case text::RelOrientation::FRAME_RIGHT:
+                sVAnchor = OString( "margin" );
+                break;
+            case text::RelOrientation::PAGE_FRAME:
+            case text::RelOrientation::PAGE_PRINT_AREA:
+            default:
+                break;
+        }
+
+        m_pFlyAttrList->add( FSNS( XML_w, XML_vAnchor ), sVAnchor );
+    }
 }
 
-void DocxAttributeOutput::FormatHorizOrientation( const SwFmtHoriOrient& )
+void DocxAttributeOutput::FormatHorizOrientation( const SwFmtHoriOrient& rFlyHori )
 {
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatHorizOrientation()\n" );
-#endif
+    if ( m_rExport.bOutFlyFrmAttrs )
+    {
+        if ( !m_pFlyAttrList )
+            m_pFlyAttrList = m_pSerializer->createAttrList();
+        
+        OString sAlign;
+        switch( rFlyHori.GetHoriOrient() )
+        {
+            case text::HoriOrientation::NONE:
+                break;
+            case text::HoriOrientation::LEFT:
+                sAlign = OString( rFlyHori.IsPosToggle( ) ? "inside" : "left" );
+                break;
+            case text::HoriOrientation::RIGHT:
+                sAlign = OString( rFlyHori.IsPosToggle( ) ? "outside" : "right" );
+                break;
+            case text::HoriOrientation::CENTER:
+            case text::HoriOrientation::FULL: // FULL only for tables
+            default:
+                sAlign = OString( "center" );
+                break;
+        }
+
+        if ( sAlign.getLength() > 0 )
+            m_pFlyAttrList->add( FSNS( XML_w, XML_xAlign ), sAlign );
+        else 
+            m_pFlyAttrList->add( FSNS( XML_w, XML_x ), 
+                OString::valueOf( sal_Int32( rFlyHori.GetPos() ) ) );
+
+        OString sHAnchor( "page" );
+        switch ( rFlyHori.GetRelationOrient( ) )
+        {
+            case text::RelOrientation::CHAR:
+            case text::RelOrientation::PRINT_AREA:
+                sHAnchor = OString( "text" );
+                break;
+            case text::RelOrientation::FRAME:
+            case text::RelOrientation::PAGE_LEFT:
+            case text::RelOrientation::PAGE_RIGHT:
+            case text::RelOrientation::FRAME_LEFT:
+            case text::RelOrientation::FRAME_RIGHT:
+                sHAnchor = OString( "margin" );
+                break;
+            case text::RelOrientation::PAGE_FRAME:
+            case text::RelOrientation::PAGE_PRINT_AREA:
+            default:
+                break;
+        }
+
+        m_pFlyAttrList->add( FSNS( XML_w, XML_hAnchor ), sHAnchor );
+    }
 }
 
 void DocxAttributeOutput::FormatAnchor( const SwFmtAnchor& )
 {
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatAnchor()\n" );
-#endif
+    // Fly frames: anchors here aren't matching the anchors in docx
 }
 
 void DocxAttributeOutput::FormatBackground( const SvxBrushItem& rBrush )
@@ -3229,10 +3506,6 @@ void DocxAttributeOutput::FormatBackground( const SvxBrushItem& rBrush )
                 FSNS( XML_w, XML_fill ), sColor.getStr( ),
                 FSEND );
     }
-
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatBackground()\n" );
-#endif
 }
 
 void DocxAttributeOutput::FormatBox( const SvxBoxItem& rBox )
@@ -3315,11 +3588,52 @@ void DocxAttributeOutput::FormatKeep( const SvxFmtKeepItem& )
     m_pSerializer->singleElementNS( XML_w, XML_keepNext, FSEND );
 }
 
-void DocxAttributeOutput::FormatTextGrid( const SwTextGridItem& )
+void DocxAttributeOutput::FormatTextGrid( const SwTextGridItem& rGrid )
 {
-#if OSL_DEBUG_LEVEL > 0
-    fprintf( stderr, "TODO DocxAttributeOutput::FormatTextGrid()\n" );
-#endif
+    FastAttributeList *pGridAttrList = m_pSerializer->createAttrList();
+
+    OString sGridType;
+    switch ( rGrid.GetGridType( ) )
+    {
+        default:
+        case GRID_NONE:
+            sGridType = OString( "default" );
+            break;
+        case GRID_LINES_ONLY:
+            sGridType = OString( "lines" );
+            break;
+        case GRID_LINES_CHARS:
+            if ( rGrid.IsSnapToChars( ) )
+                sGridType = OString( "snapToChars" );
+            else
+                sGridType = OString( "linesAndChars" );
+            break;
+    }
+    pGridAttrList->add( FSNS( XML_w, XML_type ), sGridType.getStr( ) );
+        
+    UINT16 nHeight = rGrid.GetBaseHeight() + rGrid.GetRubyHeight();
+    pGridAttrList->add( FSNS( XML_w, XML_linePitch ), 
+            OString::valueOf( sal_Int32( nHeight ) ).getStr( ) );
+        
+    MSWordStyles * pStyles = m_rExport.pStyles;
+    SwFmt * pSwFmt = pStyles->GetSwFmt();
+
+    sal_uInt32 nPageCharSize = 0;
+
+    if (pSwFmt != NULL)
+    {
+        nPageCharSize = ItemGet<SvxFontHeightItem>
+        (*pSwFmt, RES_CHRATR_FONTSIZE).GetHeight();
+    }
+
+    sal_uInt16 nPitch = rGrid.IsSquaredMode() ? rGrid.GetBaseHeight() : 
+        rGrid.GetBaseWidth( );
+    INT32 nCharSpace = ( nPitch - nPageCharSize ) * 4096 / 20;
+
+    pGridAttrList->add( FSNS( XML_w, XML_charSpace ),
+            OString::valueOf( sal_Int32( nCharSpace ) ).getStr( ) );
+
+    m_pSerializer->singleElementNS( XML_w, XML_docGrid, pGridAttrList );
 }
 
 void DocxAttributeOutput::FormatLineNumbering( const SwFmtLineNumber& rNumbering )
@@ -3377,6 +3691,7 @@ DocxAttributeOutput::DocxAttributeOutput( DocxExport &rExport, FSHelperPtr pSeri
       m_pCharLangAttrList( NULL ),
       m_pSpacingAttrList( NULL ),
       m_pHyperlinkAttrList( NULL ),
+      m_pFlyAttrList( NULL ),
       m_pFootnotesList( new ::docx::FootnotesList() ),
       m_pEndnotesList( new ::docx::FootnotesList() ),
       m_pSectionInfo( NULL ),
@@ -3389,7 +3704,8 @@ DocxAttributeOutput::DocxAttributeOutput( DocxExport &rExport, FSHelperPtr pSeri
       m_bTableCellOpen( false ),
       m_nTableDepth( 0 ),
       m_bParagraphOpened( false ),
-      m_nColBreakStatus( COLBRK_NONE )
+      m_nColBreakStatus( COLBRK_NONE ),
+      m_pParentFrame( NULL )
 {
 }
 
@@ -3400,11 +3716,13 @@ DocxAttributeOutput::~DocxAttributeOutput()
     delete m_pCharLangAttrList, m_pCharLangAttrList = NULL;
     delete m_pSpacingAttrList, m_pSpacingAttrList = NULL;
     delete m_pHyperlinkAttrList, m_pHyperlinkAttrList = NULL;
+    delete m_pFlyAttrList, m_pFlyAttrList = NULL;
 
     delete m_pFootnotesList, m_pFootnotesList = NULL;
     delete m_pEndnotesList, m_pEndnotesList = NULL;
 
     delete m_pTableWrt, m_pTableWrt = NULL;
+    m_pParentFrame = NULL;
 }
 
 MSWordExportBase& DocxAttributeOutput::GetExport()
diff --git sw/source/filter/ww8/docxattributeoutput.hxx sw/source/filter/ww8/docxattributeoutput.hxx
index 64d8217..3f2b143 100644
--- sw/source/filter/ww8/docxattributeoutput.hxx
+++ sw/source/filter/ww8/docxattributeoutput.hxx
@@ -103,7 +103,7 @@ public:
     virtual void RawText( const String& rText, bool bForceUnicode, rtl_TextEncoding eCharSet );
 
     /// Output ruby start.
-    virtual void StartRuby( const SwTxtNode& rNode, const SwFmtRuby& rRuby );
+    virtual void StartRuby( const SwTxtNode& rNode, xub_StrLen nPos, const SwFmtRuby& rRuby );
 
     /// Output ruby end.
     virtual void EndRuby();
@@ -174,7 +174,8 @@ public:
 
     /// Start of a style in the styles table.
     virtual void StartStyle( const String& rName, bool bPapFmt,
-            USHORT nBase, USHORT nNext, USHORT nWwId, USHORT nId );
+            USHORT nBase, USHORT nNext, USHORT nWwId, USHORT nId,
+            bool bAutoUpdate );
 
     /// End of a style in the styles table.
     virtual void EndStyle();
@@ -541,6 +542,7 @@ private:
     ::sax_fastparser::FastAttributeList *m_pCharLangAttrList;
     ::sax_fastparser::FastAttributeList *m_pSpacingAttrList;
     ::sax_fastparser::FastAttributeList *m_pHyperlinkAttrList;
+    ::sax_fastparser::FastAttributeList *m_pFlyAttrList;
 
     ::docx::FootnotesList *m_pFootnotesList;
     ::docx::FootnotesList *m_pEndnotesList;
@@ -583,6 +585,8 @@ private:
     // beginning of the next paragraph
     DocxColBreakStatus m_nColBreakStatus;
 
+    const sw::Frame *m_pParentFrame;
+
 public:
     DocxAttributeOutput( DocxExport &rExport, ::sax_fastparser::FSHelperPtr pSerializer, oox::drawingml::DrawingML* pDrawingML );
 
diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index c682fea..6aa8213 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -58,6 +58,7 @@ EXCEPTIONSFILES = \
         $(SLO)$/wrtw8num.obj \
         $(SLO)$/wrtw8sty.obj \
         $(SLO)$/wrtww8.obj \
+        $(SLO)$/docxattributeoutput.obj \
         $(SLO)$/docxexportfilter.obj \
         $(SLO)$/ww8atr.obj \
         $(SLO)$/ww8par.obj \
diff --git sw/source/filter/ww8/wrtw8nds.cxx sw/source/filter/ww8/wrtw8nds.cxx
index d0a5094..d2c16ff 100644
--- sw/source/filter/ww8/wrtw8nds.cxx
+++ sw/source/filter/ww8/wrtw8nds.cxx
@@ -166,76 +166,6 @@ MSWordAttrIter::~MSWordAttrIter()
     m_rExport.pChpIter = pOld;
 }
 
-// Die Klasse SwAttrIter ist eine Hilfe zum Aufbauen der Fkp.chpx.
-// Dabei werden nur Zeichen-Attribute beachtet; Absatz-Attribute brauchen
-// diese Behandlung nicht.
-// Die Absatz- und Textattribute des Writers kommen rein, und es wird
-// mit Where() die naechste Position geliefert, an der sich die Attribute
-// aendern. IsTxtAtr() sagt, ob sich an der mit Where() gelieferten Position
-// ein Attribut ohne Ende und mit \xff im Text befindet.
-// Mit OutAttr() werden die Attribute an der angegebenen SwPos
-// ausgegeben.
-
-class SwAttrIter : public MSWordAttrIter
-{
-private:
-    const SwTxtNode& rNd;
-
-    CharRuns maCharRuns;
-    cCharRunIter maCharRunIter;
-
-    rtl_TextEncoding meChrSet;
-    sal_uInt16 mnScript;
-    bool mbCharIsRTL;
-
-    const SwRedline* pCurRedline;
-    xub_StrLen nAktSwPos;
-    USHORT nCurRedlinePos;
-
-    bool mbParaIsRTL;
-
-    const SwFmtDrop &mrSwFmtDrop;
-
-    sw::Frames maFlyFrms;     // #i2916#
-    sw::FrameIter maFlyIter;
-
-    xub_StrLen SearchNext( xub_StrLen nStartPos );
-    void FieldVanish( const String& rTxt );
-
-    void OutSwFmtRefMark(const SwFmtRefMark& rAttr, bool bStart);
-
-    void IterToCurrent();
-
-    //No copying
-    SwAttrIter(const SwAttrIter&);
-    SwAttrIter& operator=(const SwAttrIter&);
-public:
-    SwAttrIter( MSWordExportBase& rWr, const SwTxtNode& rNd );
-
-    bool IsTxtAttr( xub_StrLen nSwPos );
-    bool IsRedlineAtEnd( xub_StrLen nPos ) const;
-    bool IsDropCap( int nSwPos );
-    bool RequiresImplicitBookmark();
-
-    void NextPos() { nAktSwPos = SearchNext( nAktSwPos + 1 ); }
-
-    void OutAttr( xub_StrLen nSwPos );
-    virtual const SfxPoolItem* HasTextItem( USHORT nWhich ) const;
-    virtual const SfxPoolItem& GetItem( USHORT nWhich ) const;
-    int OutAttrWithRange(xub_StrLen nPos);
-    const SwRedlineData* GetRedline( xub_StrLen nPos );
-    void OutFlys(xub_StrLen nSwPos);
-
-    xub_StrLen WhereNext() const    { return nAktSwPos; }
-    sal_uInt16 GetScript() const { return mnScript; }
-    bool IsCharRTL() const { return mbCharIsRTL; }
-    bool IsParaRTL() const { return mbParaIsRTL; }
-    rtl_TextEncoding GetCharSet() const { return meChrSet; }
-    String GetSnippet(const String &rStr, xub_StrLen nAktPos,
-        xub_StrLen nLen) const;
-    const SwFmtDrop& GetSwFmtDrop() const { return mrSwFmtDrop; }
-};
-
 class sortswflys :
     public std::binary_function<const sw::Frame&, const sw::Frame&, bool>
 {
@@ -454,7 +384,14 @@ xub_StrLen SwAttrIter::SearchNext( xub_StrLen nStartPos )
     return nMinPos;
 }
 
-void SwAttrIter::OutAttr( xub_StrLen nSwPos )
+bool lcl_isFontsizeItem( const SfxPoolItem& rItem )
+{
+    return ( rItem.Which( ) == RES_CHRATR_FONTSIZE ||
+            rItem.Which( ) == RES_CHRATR_CJK_FONTSIZE ||
+            rItem.Which( ) == RES_CHRATR_CTL_FONTSIZE );
+}
+
+void SwAttrIter::OutAttr( xub_StrLen nSwPos, bool bRuby )
 {
     m_rExport.AttrOutput().RTLAndCJKState( IsCharRTL(), GetScript() );
 
@@ -542,7 +479,10 @@ void SwAttrIter::OutAttr( xub_StrLen nSwPos )
 
     sw::cPoolItemIter aEnd = aRangeItems.end();
     for ( sw::cPoolItemIter aI = aRangeItems.begin(); aI != aEnd; ++aI )
-        aExportItems[aI->first] = aI->second;
+    {
+        if ( !bRuby || !lcl_isFontsizeItem( *aI->second ) )
+            aExportItems[aI->first] = aI->second;
+    }
 
     if ( !aExportItems.empty() )
     {
@@ -695,7 +635,7 @@ const SfxPoolItem& SwAttrIter::GetItem(USHORT nWhich) const
     return pRet ? *pRet : rNd.SwCntntNode::GetAttr(nWhich);
 }
 
-void WW8AttributeOutput::StartRuby( const SwTxtNode& rNode, const SwFmtRuby& rRuby )
+void WW8AttributeOutput::StartRuby( const SwTxtNode& rNode, xub_StrLen /*nPos*/, const SwFmtRuby& rRuby )
 {
     String aStr( FieldString( ww::eEQ ) );
     aStr.APPEND_CONST_ASC( "\\* jc" );
@@ -1224,7 +1164,7 @@ int SwAttrIter::OutAttrWithRange(xub_StrLen nPos)
                 case RES_TXTATR_CJK_RUBY:
                     if ( nPos == *pHt->GetStart() )
                     {
-                        m_rExport.AttrOutput().StartRuby( rNd, *static_cast< const SwFmtRuby* >( pItem ) );
+                        m_rExport.AttrOutput().StartRuby( rNd, nPos, *static_cast< const SwFmtRuby* >( pItem ) );
                         ++nRet;
                     }
                     if ( 0 != ( pEnd = pHt->GetEnd() ) && nPos == *pEnd )
diff --git sw/source/filter/ww8/wrtw8sty.cxx sw/source/filter/ww8/wrtw8sty.cxx
index cd5b8f3..2279184 100644
--- sw/source/filter/ww8/wrtw8sty.cxx
+++ sw/source/filter/ww8/wrtw8sty.cxx
@@ -298,7 +298,7 @@ void WW8AttributeOutput::EndStyle()
 }
 
 void WW8AttributeOutput::StartStyle( const String& rName, bool bPapFmt, USHORT nWwBase,
-    USHORT nWwNext, USHORT nWwId, USHORT /*nId*/ )
+    USHORT nWwNext, USHORT nWwId, USHORT /*nId*/, bool bAutoUpdate )
 {
     BYTE aWW8_STD[ sizeof( WW8_STD ) ];
     BYTE* pData = aWW8_STD;
@@ -320,12 +320,12 @@ void WW8AttributeOutput::StartStyle( const String& rName, bool bPapFmt, USHORT n
 
     if( m_rWW8Export.bWrtWW8 )
     {
+        nBit16 = bAutoUpdate ? 1 : 0;  // fAutoRedef : 1
+        Set_UInt16( pData, nBit16 );
         //-------- jetzt neu:
         // ab Ver8 gibts zwei Felder mehr:
-        //UINT16    fAutoRedef : 1;    /* auto redefine style when appropriate */
         //UINT16    fHidden : 1;       /* hidden from UI? */
         //UINT16    : 14;              /* unused bits */
-        pData += sizeof( UINT16 );
     }
 
 
@@ -522,8 +522,13 @@ void MSWordStyles::OutputStyle( SwFmt* pFmt, USHORT nPos )
         
         GetStyleData( pFmt, bFmtColl, nBase, nWwNext );
 
-        m_rExport.AttrOutput().StartStyle( pFmt->GetName(), bFmtColl,
-                nBase, nWwNext, GetWWId( *pFmt ), nPos );
+        String aName = pFmt->GetName();
+        if ( aName.EqualsAscii( "Default" ) )
+            aName = String::CreateFromAscii( "Normal" );
+
+        m_rExport.AttrOutput().StartStyle( aName, bFmtColl,
+                nBase, nWwNext, GetWWId( *pFmt ), nPos, 
+                pFmt->IsAutoUpdateFmt() );
         
         if ( bFmtColl )
             WriteProperties( pFmt, true, nPos, nBase==0xfff );           // UPX.papx
diff --git sw/source/filter/ww8/wrtww8.hxx sw/source/filter/ww8/wrtww8.hxx
index 8e9ba8c..fe2e7f0 100644
--- sw/source/filter/ww8/wrtww8.hxx
+++ sw/source/filter/ww8/wrtww8.hxx
@@ -1329,6 +1329,75 @@ public:
     virtual const SfxPoolItem& GetItem( USHORT nWhich ) const = 0;
 };
 
+// Die Klasse SwAttrIter ist eine Hilfe zum Aufbauen der Fkp.chpx.
+// Dabei werden nur Zeichen-Attribute beachtet; Absatz-Attribute brauchen
+// diese Behandlung nicht.
+// Die Absatz- und Textattribute des Writers kommen rein, und es wird
+// mit Where() die naechste Position geliefert, an der sich die Attribute
+// aendern. IsTxtAtr() sagt, ob sich an der mit Where() gelieferten Position
+// ein Attribut ohne Ende und mit \xff im Text befindet.
+// Mit OutAttr() werden die Attribute an der angegebenen SwPos
+// ausgegeben.
+class SwAttrIter : public MSWordAttrIter
+{
+private:
+    const SwTxtNode& rNd;
+
+    sw::util::CharRuns maCharRuns;
+    sw::util::cCharRunIter maCharRunIter;
+
+    rtl_TextEncoding meChrSet;
+    sal_uInt16 mnScript;
+    bool mbCharIsRTL;
+
+    const SwRedline* pCurRedline;
+    xub_StrLen nAktSwPos;
+    USHORT nCurRedlinePos;
+
+    bool mbParaIsRTL;
+
+    const SwFmtDrop &mrSwFmtDrop;
+
+    sw::Frames maFlyFrms;     // #i2916#
+    sw::FrameIter maFlyIter;
+
+    xub_StrLen SearchNext( xub_StrLen nStartPos );
+    void FieldVanish( const String& rTxt );
+
+    void OutSwFmtRefMark(const SwFmtRefMark& rAttr, bool bStart);
+
+    void IterToCurrent();
+
+    //No copying
+    SwAttrIter(const SwAttrIter&);
+    SwAttrIter& operator=(const SwAttrIter&);
+public:
+    SwAttrIter( MSWordExportBase& rWr, const SwTxtNode& rNd );
+
+    bool IsTxtAttr( xub_StrLen nSwPos );
+    bool IsRedlineAtEnd( xub_StrLen nPos ) const;
+    bool IsDropCap( int nSwPos );
+    bool RequiresImplicitBookmark();
+
+    void NextPos() { nAktSwPos = SearchNext( nAktSwPos + 1 ); }
+
+    void OutAttr( xub_StrLen nSwPos, bool bRuby = false );
+    virtual const SfxPoolItem* HasTextItem( USHORT nWhich ) const;
+    virtual const SfxPoolItem& GetItem( USHORT nWhich ) const;
+    int OutAttrWithRange(xub_StrLen nPos);
+    const SwRedlineData* GetRedline( xub_StrLen nPos );
+    void OutFlys(xub_StrLen nSwPos);
+
+    xub_StrLen WhereNext() const    { return nAktSwPos; }
+    sal_uInt16 GetScript() const { return mnScript; }
+    bool IsCharRTL() const { return mbCharIsRTL; }
+    bool IsParaRTL() const { return mbParaIsRTL; }
+    rtl_TextEncoding GetCharSet() const { return meChrSet; }
+    String GetSnippet(const String &rStr, xub_StrLen nAktPos,
+        xub_StrLen nLen) const;
+    const SwFmtDrop& GetSwFmtDrop() const { return mrSwFmtDrop; }
+};
+
 /// Class to collect and output the styles table.
 class MSWordStyles
 {
diff --git sw/source/filter/ww8/ww8atr.cxx sw/source/filter/ww8/ww8atr.cxx
index 6c321e9..58cf073 100644
--- sw/source/filter/ww8/ww8atr.cxx
+++ sw/source/filter/ww8/ww8atr.cxx
@@ -3758,25 +3758,12 @@ void WW8AttributeOutput::FormatTextGrid( const SwTextGridItem& rGrid )
         if (pSwFmt != NULL)
         {
             nPageCharSize = ItemGet<SvxFontHeightItem>
-            (*pSwFmt, RES_CHRATR_CJK_FONTSIZE).GetHeight();
+            (*pSwFmt, RES_CHRATR_FONTSIZE).GetHeight();
         }
+        sal_uInt16 nPitch = rGrid.IsSquaredMode() ? rGrid.GetBaseHeight() : 
+            rGrid.GetBaseWidth( );
+        INT32 nCharSpace = ( nPitch - nPageCharSize ) * 4096 / 20;
 
-        INT32 nCharWidth = rGrid.GetBaseWidth() - nPageCharSize;
-        INT32 nFraction = 0;
-        nFraction = nCharWidth % 20;
-        if ( nCharWidth < 0 )
-            nFraction = 20 + nFraction;
-        nFraction = ( nFraction * 0xFFF ) / 20;
-        nFraction = ( nFraction & 0x00000FFF );
-
-        INT32 nMain = 0;
-        nMain = nCharWidth / 20;
-        if ( nCharWidth < 0 )
-            nMain -= 1;
-        nMain = nMain * 0x1000;
-        nMain = ( nMain & 0xFFFFF000 );
-
-        UINT32 nCharSpace = nFraction + nMain;
         m_rWW8Export.InsUInt16( NS_sprm::LN_SDxtCharSpace );
         m_rWW8Export.InsUInt32( nCharSpace );
     }
@@ -4067,7 +4054,7 @@ void WW8AttributeOutput::FormatAnchor( const SwFmtAnchor& rAnchor )
         switch ( rAnchor.GetAnchorId() )
         {
             case FLY_PAGE:
-                // Vert: Page | Horz: Page
+                // Horz: Page | Vert: Page
                 nP |= (1 << 4) | (2 << 6);
                 break;
             // Im Fall eine Flys als Zeichen: Absatz-gebunden setzen!!!
@@ -4075,7 +4062,7 @@ void WW8AttributeOutput::FormatAnchor( const SwFmtAnchor& rAnchor )
             case FLY_AUTO_CNTNT:
             case FLY_AT_CNTNT:
             case FLY_IN_CNTNT:
-                // Vert: Page | Horz: Page
+                // Horz: Text | Vert: Column
                 nP |= (2 << 4) | (0 << 6);
                 break;
             default:
diff --git sw/source/filter/ww8/ww8attributeoutput.hxx sw/source/filter/ww8/ww8attributeoutput.hxx
index a54de86..48dc1b4 100644
--- sw/source/filter/ww8/ww8attributeoutput.hxx
+++ sw/source/filter/ww8/ww8attributeoutput.hxx
@@ -75,7 +75,7 @@ public:
     virtual void RawText( const String& rText, bool bForceUnicode, rtl_TextEncoding eCharSet );
 
     /// Output ruby start.
-    virtual void StartRuby( const SwTxtNode& rNode, const SwFmtRuby& rRuby );
+    virtual void StartRuby( const SwTxtNode& rNode, xub_StrLen nPos, const SwFmtRuby& rRuby );
 
     /// Output ruby end.
     virtual void EndRuby();
@@ -138,7 +138,8 @@ public:
 
     /// Start of a style in the styles table.
     virtual void StartStyle( const String& rName, bool bPapFmt,
-            USHORT nBase, USHORT nNext, USHORT nWwIdi, USHORT nId );
+            USHORT nBase, USHORT nNext, USHORT nWwIdi, USHORT nId,
+            bool bAutoUpdate );
 
     /// End of a style in the styles table.
     virtual void EndStyle();
