diff --git sc/inc/cell.hxx sc/inc/cell.hxx
index 3f99c56..0bef331 100644
--- sc/inc/cell.hxx
+++ sc/inc/cell.hxx
@@ -647,6 +647,9 @@ public:
 	inline BOOL		IsHyperLinkCell() const { return pCode && pCode->IsHyperLink(); }
 	EditTextObject*		CreateURLObject() ;
     void            GetURLResult( String& rURL, String& rCellText );
+
+    /** Determines whether or not the result string contains more than one paragraph */
+    bool            IsMultilineResult();
 };
 
 //			Iterator fuer Referenzen in einer Formelzelle
diff --git sc/inc/editutil.hxx sc/inc/editutil.hxx
index 4cb209f..79ef1ad 100644
--- sc/inc/editutil.hxx
+++ sc/inc/editutil.hxx
@@ -63,8 +63,13 @@ class ScEditUtil
 
 public:
 	static String ModifyDelimiters( const String& rOld );
+
+    /// Retrieves string with paragraphs delimited by spaces
 	static String GetSpaceDelimitedString( const EditEngine& rEngine );
 
+    /// Retrieves string with paragraphs delimited by new lines ('\n').
+    static String GetMultilineString( const EditEngine& rEngine );
+
 public:
 				ScEditUtil( ScDocument* pDocument, SCCOL nX, SCROW nY, SCTAB nZ,
 							const Point& rScrPosPixel,
diff --git sc/inc/formularesult.hxx sc/inc/formularesult.hxx
index 8c70f43..5865f60 100644
--- sc/inc/formularesult.hxx
+++ sc/inc/formularesult.hxx
@@ -38,6 +38,11 @@
     and memory consumption. */
 class ScFormulaResult
 {
+    typedef unsigned char Multiline;
+    static const Multiline MULTILINE_UNKNOWN = 0;
+    static const Multiline MULTILINE_FALSE   = 1;
+    static const Multiline MULTILINE_TRUE    = 2;
+
     union
     {
         double          mfValue;    // double result direct for performance and memory consumption
@@ -47,6 +52,7 @@ class ScFormulaResult
     bool                mbToken :1; // whether content of union is a token
     bool                mbEmpty :1; // empty cell result
     bool                mbEmptyDisplayedAsString :1;    // only if mbEmpty
+    Multiline           meMultiline :2; // result is multiline
 
     /** Reset mnError, mbEmpty and mbEmptyDisplayedAsString to their defaults
         prior to assigning other types */
@@ -69,12 +75,14 @@ public:
                                 /** Effectively type svUnknown. */
                                 ScFormulaResult()
                                     : mpToken(NULL), mnError(0), mbToken(true),
-                                    mbEmpty(false), mbEmptyDisplayedAsString(false) {}
+                                    mbEmpty(false), mbEmptyDisplayedAsString(false),
+                                    meMultiline(MULTILINE_UNKNOWN) {}
 
                                 ScFormulaResult( const ScFormulaResult & r )
                                     : mnError( r.mnError), mbToken( r.mbToken),
                                     mbEmpty( r.mbEmpty),
-                                    mbEmptyDisplayedAsString( r.mbEmptyDisplayedAsString)
+                                    mbEmptyDisplayedAsString( r.mbEmptyDisplayedAsString),
+                                    meMultiline( r.meMultiline)
                                 {
                                     if (mbToken)
                                     {
@@ -99,7 +107,8 @@ public:
     /** Same comments as for SetToken() apply! */
     explicit                    ScFormulaResult( const formula::FormulaToken* p )
                                     : mnError(0), mbToken(false),
-                                    mbEmpty(false), mbEmptyDisplayedAsString(false)
+                                    mbEmpty(false), mbEmptyDisplayedAsString(false),
+                                    meMultiline(MULTILINE_UNKNOWN)
                                 {
                                     SetToken( p);
                                 }
@@ -153,6 +162,10 @@ public:
         details instead. */
     inline  bool                IsValue() const;
 
+    /** Determines whether or not the result is a string containing more than 
+        one paragraph */
+    inline  bool                IsMultiline();
+
     /** Get error code if set or GetCellResultType() is formula::svError or svUnknown,
         else 0. */
     inline  USHORT              GetResultError() const;
@@ -211,6 +224,7 @@ inline void ScFormulaResult::ResetToDefaults()
     mnError = 0;
     mbEmpty = false;
     mbEmptyDisplayedAsString = false;
+    meMultiline = MULTILINE_UNKNOWN;
 }
 
 
@@ -232,10 +246,12 @@ inline void ScFormulaResult::ResolveToken( const formula::FormulaToken * p )
                 mbToken = false;
                 // set in case mnError is 0 now, which shouldn't happen but ...
                 mfValue = 0.0;
+                meMultiline = MULTILINE_FALSE;
                 break;
             case formula::svEmptyCell:
                 mbEmpty = true;
                 mbEmptyDisplayedAsString = static_cast<const ScEmptyCellToken*>(p)->IsDisplayedAsString();
+                meMultiline = MULTILINE_FALSE;
                 p->DecRef();
                 mbToken = false;
                 break;
@@ -243,6 +259,7 @@ inline void ScFormulaResult::ResolveToken( const formula::FormulaToken * p )
                 mfValue = p->GetDouble();
                 p->DecRef();
                 mbToken = false;
+                meMultiline = MULTILINE_FALSE;
                 break;
             default:
                 mpToken = p;
@@ -270,6 +287,7 @@ inline void ScFormulaResult::Assign( const ScFormulaResult & r )
         mbToken = false;
         mbEmpty = true;
         mbEmptyDisplayedAsString = r.mbEmptyDisplayedAsString;
+        meMultiline = r.meMultiline;
     }
     else if (r.mbToken)
     {
@@ -352,6 +370,7 @@ inline void ScFormulaResult::SetDouble( double f )
             mpToken->DecRef();
         mfValue = f;
         mbToken = false;
+        meMultiline = MULTILINE_FALSE;
     }
 }
 
@@ -405,6 +424,20 @@ inline bool ScFormulaResult::IsValue() const
 }
 
 
+inline bool ScFormulaResult::IsMultiline()
+{
+    if (meMultiline == MULTILINE_UNKNOWN)
+    {
+        const String& rStr = GetString();
+        if (rStr.Len() && rStr.Search( _LF ) != STRING_NOTFOUND)
+            meMultiline = MULTILINE_TRUE;
+        else
+            meMultiline = MULTILINE_FALSE;
+    }
+    return meMultiline == MULTILINE_TRUE;
+}
+
+
 inline USHORT ScFormulaResult::GetResultError() const
 {
     if (mnError)
@@ -537,6 +570,7 @@ inline void ScFormulaResult::SetHybridDouble( double f )
     {
         mfValue = f;
         mbToken = false;
+        meMultiline = MULTILINE_FALSE;
     }
 }
 
diff --git sc/source/core/data/cell.cxx sc/source/core/data/cell.cxx
index 232a2ae..f26401e 100644
--- sc/source/core/data/cell.cxx
+++ sc/source/core/data/cell.cxx
@@ -1938,6 +1938,13 @@ void ScFormulaCell::GetURLResult( String& rURL, String& rCellText )
     }
 }
 
+bool ScFormulaCell::IsMultilineResult()
+{
+    if (!IsValue())
+        return aResult.IsMultiline();
+    return false;
+}
+
 EditTextObject* ScFormulaCell::CreateURLObject()
 {
     String aCellText;
diff --git sc/source/core/data/cell2.cxx sc/source/core/data/cell2.cxx
index 5014e6b..4c38b39 100644
--- sc/source/core/data/cell2.cxx
+++ sc/source/core/data/cell2.cxx
@@ -131,7 +131,7 @@ void ScEditCell::GetString( String& rString ) const
         // auch Text von URL-Feldern, Doc-Engine ist eine ScFieldEditEngine
         EditEngine& rEngine = pDoc->GetEditEngine();
         rEngine.SetText( *pData );
-        rString = ScEditUtil::GetSpaceDelimitedString(rEngine);     // space between paragraphs
+        rString = ScEditUtil::GetMultilineString(rEngine); // string with line separators between paragraphs
         // kurze Strings fuer Formeln merken
         if ( rString.Len() < MAXSTRLEN )
             ((ScEditCell*)this)->pString = new String( rString );   //! non-const
diff --git sc/source/core/data/column.cxx sc/source/core/data/column.cxx
index 48bad18..9e03b31 100644
--- sc/source/core/data/column.cxx
+++ sc/source/core/data/column.cxx
@@ -2174,8 +2174,10 @@ BOOL ScColumn::HasEditCells(SCROW nStartRow, SCROW nEndRow, SCROW& rFirst) const
 	while ( (nIndex < nCount) ? ((nRow=pItems[nIndex].nRow) <= nEndRow) : FALSE )
 	{
 		ScBaseCell* pCell = pItems[nIndex].pCell;
-		if ( pCell->GetCellType() == CELLTYPE_EDIT ||
-			 IsAmbiguousScriptNonZero( pDocument->GetScriptType(nCol, nRow, nTab, pCell) ) )
+        CellType eCellType = pCell->GetCellType();
+		if ( eCellType == CELLTYPE_EDIT ||
+			 IsAmbiguousScriptNonZero( pDocument->GetScriptType(nCol, nRow, nTab, pCell) ) ||
+             ((eCellType == CELLTYPE_FORMULA) && ((ScFormulaCell*)pCell)->IsMultilineResult()) )
 		{
 			rFirst = nRow;
 			return TRUE;
diff --git sc/source/core/data/column2.cxx sc/source/core/data/column2.cxx
index 9e129e2..cc8e369 100644
--- sc/source/core/data/column2.cxx
+++ sc/source/core/data/column2.cxx
@@ -319,9 +319,12 @@ long ScColumn::GetNeededSize( SCROW nRow, OutputDevice* pDev,
 		}
 
 		BOOL bAddMargin = TRUE;
-		BOOL bEditEngine = ( pCell->GetCellType() == CELLTYPE_EDIT ||
+        CellType eCellType = pCell->GetCellType();
+
+		BOOL bEditEngine = ( eCellType == CELLTYPE_EDIT ||
 								eOrient == SVX_ORIENTATION_STACKED ||
-								IsAmbiguousScript( nScript ) );
+								IsAmbiguousScript( nScript ) ||
+                                ((eCellType == CELLTYPE_FORMULA) && ((ScFormulaCell*)pCell)->IsMultilineResult()) );
 
 		if (!bEditEngine)									// direkte Ausgabe
 		{
diff --git sc/source/core/data/column3.cxx sc/source/core/data/column3.cxx
index 621c19f..ba6a42f 100644
--- sc/source/core/data/column3.cxx
+++ sc/source/core/data/column3.cxx
@@ -854,7 +854,16 @@ ScBaseCell* ScColumn::CloneCell(SCSIZE nIndex, USHORT nFlags, ScDocument& rDestD
                     rForm.GetString( aString );
                     // #33224# do not clone empty string
                     if (aString.Len() > 0)
-                        pNew = new ScStringCell( aString );
+                    {
+                        if ( rForm.IsMultilineResult() )
+                        {
+                            pNew = new ScEditCell(aString, &rDestDoc);
+                        }
+                        else
+                        {
+                            pNew = new ScStringCell(aString);
+                        }
+                    }
                 }
             }
         break;
diff --git sc/source/core/tool/editutil.cxx sc/source/core/tool/editutil.cxx
index 5c771a1..8199a21 100644
--- sc/source/core/tool/editutil.cxx
+++ sc/source/core/tool/editutil.cxx
@@ -84,19 +84,29 @@ String ScEditUtil::ModifyDelimiters( const String& rOld )
 	return aRet;
 }
 
-String ScEditUtil::GetSpaceDelimitedString( const EditEngine& rEngine )
+static String lcl_GetDelimitedString( const EditEngine& rEngine, const sal_Char c )
 {
 	String aRet;
 	USHORT nParCount = rEngine.GetParagraphCount();
 	for (USHORT nPar=0; nPar<nParCount; nPar++)
 	{
 		if (nPar > 0)
-			aRet += ' ';
+			aRet += c;
 		aRet += rEngine.GetText( nPar );
 	}
 	return aRet;
 }
 
+String ScEditUtil::GetSpaceDelimitedString( const EditEngine& rEngine )
+{
+    return lcl_GetDelimitedString(rEngine, ' ');
+}
+
+String ScEditUtil::GetMultilineString( const EditEngine& rEngine )
+{
+    return lcl_GetDelimitedString(rEngine, '\n');
+}
+
 //------------------------------------------------------------------------
 
 Rectangle ScEditUtil::GetEditArea( const ScPatternAttr* pPattern, BOOL bForceToTop )
diff --git sc/source/filter/dif/difimp.cxx sc/source/filter/dif/difimp.cxx
index 99651ea..9e4a65c 100644
--- sc/source/filter/dif/difimp.cxx
+++ sc/source/filter/dif/difimp.cxx
@@ -338,7 +338,7 @@ TOPIC DifParser::GetNextTopic( void )
 
 	while( eS != S_END )
 	{
-		if( !rIn.ReadUniOrByteStringLine( aLine ) )
+		if( !ReadNextLine( aLine ) )
 		{
 			eS = S_END;
 			eRet = T_END;
@@ -406,10 +406,10 @@ TOPIC DifParser::GetNextTopic( void )
 				break;
 			case S_UNKNOWN:
 				// 2 Zeilen ueberlesen
-				rIn.ReadUniOrByteStringLine( aLine );
+				ReadNextLine( aLine );
 			case S_ERROR_L2:				// Fehler in Line 2 aufgetreten
 				// eine Zeile ueberlesen
-				rIn.ReadUniOrByteStringLine( aLine );
+				ReadNextLine( aLine );
 				eS = S_END;
 				break;
 			default:
@@ -421,7 +421,7 @@ TOPIC DifParser::GetNextTopic( void )
 }
 
 
-void lcl_DeEscapeQuotesDif( String& rString )
+static void lcl_DeEscapeQuotesDif( String& rString )
 {
 	//	Special handling for DIF import: Escaped (duplicated) quotes are resolved.
 	//	Single quote characters are left in place because older versions didn't
@@ -437,25 +437,107 @@ void lcl_DeEscapeQuotesDif( String& rString )
 	}
 }
 
+// Determine if passed in string is numeric data and set fVal/nNumFormat if so
+DATASET DifParser::GetNumberDataset( const sal_Unicode* pPossibleNumericData )
+{
+    DATASET eRet = D_SYNT_ERROR;
+    if( bPlain )
+    {
+        if( ScanFloatVal( pPossibleNumericData ) )
+            eRet = D_NUMERIC;
+        else
+            eRet = D_SYNT_ERROR;
+    }
+    else
+    {   // ...und zur Strafe mit'm Numberformatter...
+        DBG_ASSERT( pNumFormatter, "-DifParser::GetNextDataset(): No Formatter, more fun!" );
+        String aTestVal( pPossibleNumericData );
+        sal_uInt32 nFormat = 0;
+        double fTmpVal;
+        if( pNumFormatter->IsNumberFormat( aTestVal, nFormat, fTmpVal ) )
+        {
+            fVal = fTmpVal;
+            nNumFormat = nFormat;
+            eRet = D_NUMERIC;
+        }
+        else
+            eRet = D_SYNT_ERROR;
+    }
+    return eRet;
+}
+
+bool DifParser::ReadNextLine( String& rStr )
+{
+    if( aLookAheadLine.Len() == 0 )
+    {
+        return rIn.ReadUniOrByteStringLine( rStr );
+    }
+    else
+    {
+        rStr = aLookAheadLine;
+        aLookAheadLine.Erase();
+        return true;
+    }
+}
+
+// Look ahead in the stream to determine if the next line is the first line of 
+// a valid data record structure
+bool DifParser::LookAhead()
+{
+    const sal_Unicode* pAktBuffer;
+    bool bValidStructure = false;
+
+    DBG_ASSERT( aLookAheadLine.Len() == 0, "*DifParser::LookAhead(): LookAhead called twice in a row" );
+    rIn.ReadUniOrByteStringLine( aLookAheadLine );
+
+    pAktBuffer = aLookAheadLine.GetBuffer();
+
+    switch( *pAktBuffer )
+    {
+        case '-':                   // Special Datatype
+            pAktBuffer++;
+
+            if( Is1_0( pAktBuffer ) )
+            {
+                bValidStructure = true;
+            }
+            break;
+        case '0':                   // Numeric Data
+            pAktBuffer++;
+            if( *pAktBuffer == ',' )
+            {
+                pAktBuffer++;
+                bValidStructure = ( GetNumberDataset(pAktBuffer) != D_SYNT_ERROR );
+            }
+            break;
+        case '1':                   // String Data
+            if( Is1_0( aLookAheadLine.GetBuffer() ) )
+            {
+                bValidStructure = true;
+            }
+            break;
+    }
+    return bValidStructure;
+}
 
 DATASET	DifParser::GetNextDataset( void )
 {
 	DATASET				eRet = D_UNKNOWN;
 	String			    aLine;
-	const sal_Unicode*		pAkt;
+	const sal_Unicode*		pAktBuffer;
 
-	rIn.ReadUniOrByteStringLine( aLine );
+	ReadNextLine( aLine );
 
-	pAkt = aLine.GetBuffer();
+	pAktBuffer = aLine.GetBuffer();
 
-	switch( *pAkt )
+	switch( *pAktBuffer )
 	{
 		case '-':					// Special Datatype
-			pAkt++;
+			pAktBuffer++;
 
-			if( Is1_0( pAkt ) )
+			if( Is1_0( pAktBuffer ) )
 			{
-				rIn.ReadUniOrByteStringLine( aLine );
+				ReadNextLine( aLine );
 				if( IsBOT( aLine.GetBuffer() ) )
 					eRet = D_BOT;
 				else if( IsEOD( aLine.GetBuffer() ) )
@@ -463,37 +545,16 @@ DATASET	DifParser::GetNextDataset( void )
 			}
 			break;
 		case '0':					// Numeric Data
-			pAkt++;					// Wert in fVal, 2. Zeile in aData
-			if( *pAkt == ',' )
+			pAktBuffer++;			// Wert in fVal, 2. Zeile in aData
+			if( *pAktBuffer == ',' )
 			{
-				pAkt++;
-				if( bPlain )
-				{
-					if( ScanFloatVal( pAkt ) )
-						eRet = D_NUMERIC;
-					else
-						eRet = D_SYNT_ERROR;
-				}
-				else
-				{	// ...und zur Strafe mit'm Numberformatter...
-					DBG_ASSERT( pNumFormatter, "-DifParser::GetNextDataset(): No Formatter, more fun!" );
-					String			aTestVal( pAkt );
-					sal_uInt32		nFormat = 0;
-					double			fTmpVal;
-					if( pNumFormatter->IsNumberFormat( aTestVal, nFormat, fTmpVal ) )
-					{
-						fVal = fTmpVal;
-						nNumFormat = nFormat;
-						eRet = D_NUMERIC;
-					}
-					else
-						eRet = D_SYNT_ERROR;
-				}
-                rIn.ReadUniOrByteStringLine( aData );
+				pAktBuffer++;
+                eRet = GetNumberDataset(pAktBuffer);
+                ReadNextLine( aData );
                 if ( eRet == D_SYNT_ERROR )
                 {   // for broken records write "#ERR: data" to cell
                     String aTmp( RTL_CONSTASCII_USTRINGPARAM( "#ERR: " ));
-                    aTmp += pAkt;
+                    aTmp += pAktBuffer;
                     aTmp.AppendAscii( " (" );
                     aTmp += aData;
                     aTmp += sal_Unicode(')');
@@ -505,18 +566,62 @@ DATASET	DifParser::GetNextDataset( void )
 		case '1':					// String Data
 			if( Is1_0( aLine.GetBuffer() ) )
 			{
-				rIn.ReadUniOrByteStringLine( aLine );
-				DBG_ASSERT( aLine.Len() >= 2,
-					"*DifParser::GetNextTopic(): Text ist zu kurz (mind. \"\")!" );
-				aData = aLine.Copy( 1, aLine.Len() - 2 );
-				lcl_DeEscapeQuotesDif( aData );
-				eRet = D_STRING;
+				ReadNextLine( aLine );
+                xub_StrLen nLineLength = aLine.Len();
+                const sal_Unicode* pLine = aLine.GetBuffer();
+
+                if( nLineLength >= 1 && *pLine == '"' )
+                {
+                    // Quotes are not always escaped (duplicated), see lcl_DeEscapeQuotesDif
+                    // A look ahead into the next line is needed in order to deal with 
+                    // multiline strings containing quotes
+                    if( LookAhead() )
+                    {
+                        // Single line string
+                        if( nLineLength >= 2 && pLine[nLineLength - 1] == '"' )
+                        {
+                            aData = aLine.Copy( 1, nLineLength - 2 );
+                            lcl_DeEscapeQuotesDif( aData );
+                            eRet = D_STRING;
+                        }
+                    }
+                    else
+                    {
+                        // Multiline string
+                        aData = aLine.Copy( 1 );
+                        bool bContinue = true;
+                        while ( bContinue )
+                        {
+                            aData.Append( '\n' );
+                            bContinue = !rIn.IsEof() && ReadNextLine( aLine );
+                            if( bContinue )
+                            {
+                                nLineLength = aLine.Len();
+                                if( nLineLength >= 1 )
+                                {
+                                    pLine = aLine.GetBuffer();
+                                    bContinue = !LookAhead();
+                                    if( bContinue )
+                                    {
+                                        aData.Append( aLine );
+                                    }
+                                    else if( pLine[nLineLength - 1] == '"' )
+                                    {
+                                        aData.Append( pLine, nLineLength - 1 );
+                                        lcl_DeEscapeQuotesDif( aData );
+                                        eRet = D_STRING;
+                                    }
+                                }
+                            }
+                        };
+                    }
+                }
 			}
 			break;
 	}
 
 	if( eRet == D_UNKNOWN )
-		rIn.ReadUniOrByteStringLine( aLine );
+		ReadNextLine( aLine );
 
 	if( rIn.IsEof() )
 		eRet = D_EOD;
diff --git sc/source/filter/excel/xestyle.cxx sc/source/filter/excel/xestyle.cxx
index 71abe16..de32a64 100644
--- sc/source/filter/excel/xestyle.cxx
+++ sc/source/filter/excel/xestyle.cxx
@@ -2320,9 +2320,9 @@ sal_uInt32 XclExpXFBuffer::InsertWithFont( const ScPatternAttr* pPattern, sal_In
     return InsertCellXF( pPattern, nScript, NUMBERFORMAT_ENTRY_NOT_FOUND, nForceXclFont, bForceLineBreak );
 }
 
-sal_uInt32 XclExpXFBuffer::InsertWithNumFmt( const ScPatternAttr* pPattern, sal_Int16 nScript, ULONG nForceScNumFmt )
+sal_uInt32 XclExpXFBuffer::InsertWithNumFmt( const ScPatternAttr* pPattern, sal_Int16 nScript, ULONG nForceScNumFmt, bool bForceLineBreak )
 {
-    return InsertCellXF( pPattern, nScript, nForceScNumFmt, EXC_FONT_NOTFOUND, false );
+    return InsertCellXF( pPattern, nScript, nForceScNumFmt, EXC_FONT_NOTFOUND, bForceLineBreak );
 }
 
 sal_uInt32 XclExpXFBuffer::InsertStyle( const SfxStyleSheetBase* pStyleSheet )
diff --git sc/source/filter/excel/xetable.cxx sc/source/filter/excel/xetable.cxx
index 1c7c945..8d27d2d 100644
--- sc/source/filter/excel/xetable.cxx
+++ sc/source/filter/excel/xetable.cxx
@@ -839,13 +839,15 @@ XclExpFormulaCell::XclExpFormulaCell(
 
         // #i41420# find script type according to result type (always latin for numeric results)
         sal_Int16 nScript = ApiScriptType::LATIN;
+        bool bForceLineBreak = false;
         if( nFormatType == NUMBERFORMAT_TEXT )
         {
             String aResult;
             mrScFmlaCell.GetString( aResult );
+            bForceLineBreak = mrScFmlaCell.IsMultilineResult();
             nScript = XclExpStringHelper::GetLeadingScriptType( rRoot, aResult );
         }
-        SetXFId( rRoot.GetXFBuffer().InsertWithNumFmt( pPattern, nScript, nAltScNumFmt ) );
+        SetXFId( rRoot.GetXFBuffer().InsertWithNumFmt( pPattern, nScript, nAltScNumFmt, bForceLineBreak ) );
     }
 
     // *** Convert the formula token array *** --------------------------------
diff --git sc/source/filter/html/htmlexp.cxx sc/source/filter/html/htmlexp.cxx
index 20fbd39..75f1515 100644
--- sc/source/filter/html/htmlexp.cxx
+++ sc/source/filter/html/htmlexp.cxx
@@ -1154,9 +1154,31 @@ void ScHTMLExport::WriteCell( SCCOL nCol, SCROW nRow, SCTAB nTab )
 	if ( !bFieldText )
 	{
 		if ( !aStrOut.Len() )
+        {
 			TAG_ON( sHTML_linebreak );		// #42573# keine komplett leere Zelle
+        }
 		else
-			OUT_STR( aStrOut );
+        {
+            xub_StrLen nPos = aStrOut.Search( _LF );
+            if ( nPos == STRING_NOTFOUND )
+            {
+                OUT_STR( aStrOut );
+            }
+            else
+            {
+                xub_StrLen nStartPos = 0;
+                do
+                {
+                    String aSingleLine( aStrOut, nStartPos, nPos - nStartPos );
+                    OUT_STR( aSingleLine );
+                    TAG_ON( sHTML_linebreak );
+                    nStartPos = nPos + 1;
+                } 
+                while( ( nPos = aStrOut.Search( _LF, nStartPos ) ) != STRING_NOTFOUND );
+                String aSingleLine( aStrOut, nStartPos, aStrOut.Len() - nStartPos );
+                OUT_STR( aSingleLine );
+            }
+        }
 	}
     if ( pGraphEntry )
 		WriteGraphEntry( pGraphEntry );
@@ -1194,7 +1216,7 @@ BOOL ScHTMLExport::WriteFieldText( const ScEditCell* pCell )
 		for ( USHORT nPar=0; nPar < nParas; nPar++ )
 		{
 			if ( nPar > 0 )
-				rStrm << ' ';		// blank between paragraphs
+                TAG_ON( sHTML_linebreak );
 			SvUShorts aPortions;
 			rEngine.GetPortions( nPar, aPortions );
 			USHORT nCnt = aPortions.Count();
diff --git sc/source/filter/inc/dif.hxx sc/source/filter/inc/dif.hxx
index 602a356..3e9d3bc 100644
--- sc/source/filter/inc/dif.hxx
+++ sc/source/filter/inc/dif.hxx
@@ -82,7 +82,11 @@ private:
 	SvNumberFormatter*	pNumFormatter;
 	SvStream&			rIn;
 	BOOL				bPlain;
+    String              aLookAheadLine;
 
+    bool                ReadNextLine( String& rStr );
+    bool                LookAhead();
+    DATASET             GetNumberDataset( const sal_Unicode* pPossibleNumericData );
 	static inline BOOL	IsBOT( const sal_Unicode* pRef );
 	static inline BOOL	IsEOD( const sal_Unicode* pRef );
 	static inline BOOL	Is1_0( const sal_Unicode* pRef );
diff --git sc/source/filter/inc/xestyle.hxx sc/source/filter/inc/xestyle.hxx
index f3b3c4f..9508c8b 100644
--- sc/source/filter/inc/xestyle.hxx
+++ sc/source/filter/inc/xestyle.hxx
@@ -644,10 +644,13 @@ public:
         @param nXFFlags  Additional flags allowing to control the creation of an XF.
         @param nForceScNumFmt  The number format to be exported, e.g. formula
             result type. This format will always overwrite the cell's number format.
+        @param bForceLineBreak  true = Set line break flag unconditionally.
+            This is required for cells that contain multi-line text.
         @return  A unique XF record ID. */
     sal_uInt32          InsertWithNumFmt(
                             const ScPatternAttr* pPattern, sal_Int16 nScript,
-                            ULONG nForceScNumFmt );
+                            ULONG nForceScNumFmt,
+                            bool bForceLineBreak );
     /** Inserts the passed cell style. Creates a style XF record and a STYLE record.
         @return  A unique XF record ID. */
     sal_uInt32          InsertStyle( const SfxStyleSheetBase* pStyleSheet );
diff --git sc/source/filter/qpro/qpro.cxx sc/source/filter/qpro/qpro.cxx
index 3d5ea26..9bac593 100644
--- sc/source/filter/qpro/qpro.cxx
+++ sc/source/filter/qpro/qpro.cxx
@@ -71,7 +71,7 @@ FltError ScQProReader::readSheet( SCTAB nTab, ScDocument* pDoc, ScQProStyle *pSt
                 readString( aLabel, getLength() - 7 );
                 nStyle = nStyle >> 3;
                 pStyle->SetFormat( pDoc, nCol, nRow, nTab, nStyle );
-                pDoc->PutCell( nCol, nRow, nTab, new ScStringCell( aLabel ), (BOOL) TRUE );
+                pDoc->PutCell( nCol, nRow, nTab, ScBaseCell::CreateTextCell( aLabel, pDoc ), (BOOL) TRUE );
                 }
                 break;
 
diff --git sc/source/filter/xml/XMLExportIterator.cxx sc/source/filter/xml/XMLExportIterator.cxx
index 768c926..29a2e2c 100644
--- sc/source/filter/xml/XMLExportIterator.cxx
+++ sc/source/filter/xml/XMLExportIterator.cxx
@@ -568,6 +568,7 @@ ScMyCell::ScMyCell() :
 	aShapeList(),
 	aDetectiveObjVec(),
     nValidationIndex(-1),
+    pBaseCell(NULL),
 	bIsAutoStyle( sal_False ),
 	bHasShape( sal_False ),
 	bIsMergedBase( sal_False ),
diff --git sc/source/filter/xml/XMLExportIterator.hxx sc/source/filter/xml/XMLExportIterator.hxx
index a55f746..9d1834c 100644
--- sc/source/filter/xml/XMLExportIterator.hxx
+++ sc/source/filter/xml/XMLExportIterator.hxx
@@ -48,6 +48,7 @@ class	ScHorizontalCellIterator;
 struct	ScMyCell;
 class	ScXMLExport;
 class	ScFormatRangeStyles;
+class   ScBaseCell;
 
 //==============================================================================
 
@@ -313,6 +314,8 @@ struct ScMyCell
 	sal_Int32					nNumberFormat;
 	com::sun::star::table::CellContentType	nType;
 
+    ScBaseCell*                 pBaseCell;
+
 	sal_Bool					bIsAutoStyle;
 
 	sal_Bool					bHasShape;
diff --git sc/source/filter/xml/xmlexprt.cxx sc/source/filter/xml/xmlexprt.cxx
index 0a03262..97916e2 100644
--- sc/source/filter/xml/xmlexprt.cxx
+++ sc/source/filter/xml/xmlexprt.cxx
@@ -2452,7 +2452,8 @@ void ScXMLExport::WriteCell (ScMyCell& aCell)
 
 	if (!bIsEmpty)
 	{
-		if ((aCell.nType == table::CellContentType_TEXT) && IsEditCell(aCell))
+        if ((aCell.nType == table::CellContentType_TEXT && IsEditCell(aCell)) || 
+            (aCell.nType == table::CellContentType_FORMULA && IsMultiLineFormulaCell(aCell)))
 		{
             bEditCell = sal_True;
             uno::Reference<text::XText> xText(xCurrentTableCellRange->getCellByPosition(aCell.aCellAddress.Column, aCell.aCellAddress.Row), uno::UNO_QUERY);
@@ -2901,12 +2902,15 @@ sal_Bool ScXMLExport::IsCellTypeEqual (const ScMyCell& aCell1, const ScMyCell& a
 	return (aCell1.nType == aCell2.nType);
 }
 
-sal_Bool ScXMLExport::IsEditCell(const com::sun::star::table::CellAddress& aAddress) const
+sal_Bool ScXMLExport::IsEditCell(const com::sun::star::table::CellAddress& aAddress, ScMyCell* pMyCell) const
 {
 	ScAddress aCoreAddress(static_cast<SCCOL>(aAddress.Column),
 						static_cast<SCROW>(aAddress.Row),
 						static_cast<SCTAB>(aAddress.Sheet));
 	ScBaseCell* pBaseCell = GetDocument() ? GetDocument()->GetCell(aCoreAddress) : NULL;
+    if (pMyCell)
+        pMyCell->pBaseCell = pBaseCell;
+
 	if (pBaseCell)
 		return (pBaseCell->GetCellType() == CELLTYPE_EDIT);
 	return sal_False;
@@ -2926,12 +2930,36 @@ sal_Bool ScXMLExport::IsEditCell(ScMyCell& rCell) const
 		return rCell.bIsEditCell;
 	else
 	{
-		rCell.bIsEditCell = IsEditCell(rCell.aCellAddress);
+        rCell.bIsEditCell = IsEditCell(rCell.aCellAddress, &rCell);
 		rCell.bKnowWhetherIsEditCell = sal_True;
 		return rCell.bIsEditCell;
 	}
 }
 
+sal_Bool ScXMLExport::IsMultiLineFormulaCell(ScMyCell& rCell)
+{
+    if (rCell.pBaseCell)
+    {
+        if (rCell.pBaseCell->GetCellType() != CELLTYPE_FORMULA)
+            return false;
+
+        return static_cast<ScFormulaCell*>(rCell.pBaseCell)->IsMultilineResult();
+    }
+
+    ScAddress aAddr(static_cast<SCCOL>(rCell.aCellAddress.Column), 
+                    static_cast<SCROW>(rCell.aCellAddress.Row),
+                    static_cast<SCTAB>(rCell.aCellAddress.Sheet));
+    ScBaseCell* pBaseCell = pDoc ? pDoc->GetCell(aAddr) : NULL;
+    if (!pBaseCell)
+        return false;
+
+    rCell.pBaseCell = pBaseCell;
+    if (rCell.pBaseCell->GetCellType() != CELLTYPE_FORMULA)
+        return false;
+
+    return static_cast<ScFormulaCell*>(rCell.pBaseCell)->IsMultilineResult();
+}
+
 //UNUSED2008-05  sal_Bool ScXMLExport::IsAnnotationEqual(const uno::Reference<table::XCell>& /* xCell1 */,
 //UNUSED2008-05                                          const uno::Reference<table::XCell>& /* xCell2 */)
 //UNUSED2008-05  {
diff --git sc/source/filter/xml/xmlexprt.hxx sc/source/filter/xml/xmlexprt.hxx
index 7f99237..d98151c 100644
--- sc/source/filter/xml/xmlexprt.hxx
+++ sc/source/filter/xml/xmlexprt.hxx
@@ -62,6 +62,7 @@ class XMLNumberFormatAttributesExportHelper;
 class ScChartListener;
 class SfxItemPool;
 class ScAddress;
+class ScBaseCell;
 
 typedef std::vector< com::sun::star::uno::Reference < com::sun::star::drawing::XShapes > > ScMyXShapesVec;
 
@@ -193,9 +194,10 @@ class ScXMLExport : public SvXMLExport
 	void SetRepeatAttribute (const sal_Int32 nEqualCellCount);
 
 	sal_Bool IsCellTypeEqual (const ScMyCell& aCell1, const ScMyCell& aCell2) const;
-	sal_Bool IsEditCell(const com::sun::star::table::CellAddress& aAddress) const;
+	sal_Bool IsEditCell(const com::sun::star::table::CellAddress& aAddress, ScMyCell* pMyCell = NULL) const;
 //UNUSED2008-05  sal_Bool IsEditCell(const com::sun::star::uno::Reference <com::sun::star::table::XCell>& xCell) const;
 	sal_Bool IsEditCell(ScMyCell& rCell) const;
+    sal_Bool IsMultiLineFormulaCell(ScMyCell& rCell);
 //UNUSED2008-05  sal_Bool IsAnnotationEqual(const com::sun::star::uno::Reference<com::sun::star::table::XCell>& xCell1,
 //UNUSED2008-05                             const com::sun::star::uno::Reference<com::sun::star::table::XCell>& xCell2);
 	sal_Bool IsCellEqual (ScMyCell& aCell1, ScMyCell& aCell2);
diff --git sc/source/ui/app/transobj.cxx sc/source/ui/app/transobj.cxx
index 69fd72a..1620f95 100644
--- sc/source/ui/app/transobj.cxx
+++ sc/source/ui/app/transobj.cxx
@@ -312,6 +312,8 @@ sal_Bool ScTransferObj::GetData( const datatransfer::DataFlavor& rFlavor )
 			BOOL bIncludeFiltered = pDoc->IsCutMode() || bUsedForLink;
 
 			ScImportExport aObj( pDoc, aBlock );
+            if ( bUsedForLink )
+                aObj.SetExportTextOptions( ScExportTextOptions( ScExportTextOptions::ToSpace, ' ', false ) );
 			aObj.SetFormulas( pDoc->GetViewOptions().GetOption( VOPT_FORMULAS ) );
 			aObj.SetIncludeFiltered( bIncludeFiltered );
 
@@ -816,7 +818,10 @@ void ScTransferObj::StripRefs( ScDocument* pDoc,
 				{
 					String aStr;
 					pFCell->GetString(aStr);
-					pNew = new ScStringCell( aStr );
+                    if ( pFCell->IsMultilineResult() )
+                        pNew = new ScEditCell( aStr, pDestDoc );
+                    else
+                        pNew = new ScStringCell( aStr );
 				}
 				pDestDoc->PutCell( nCol,nRow,nDestTab, pNew );
 
diff --git sc/source/ui/docshell/docsh.cxx sc/source/ui/docshell/docsh.cxx
index 8526d08..ec2bc6d 100644
--- sc/source/ui/docshell/docsh.cxx
+++ sc/source/ui/docshell/docsh.cxx
@@ -1179,6 +1179,7 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 			}
 			bSetColWidths = TRUE;
 			bSetSimpleTextColWidths = TRUE;
+			bSetRowHeights = TRUE;
 		}
 		else if (aFltName.EqualsAscii(pFilterSylk))
 		{
@@ -1206,6 +1207,7 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 				SetError(eError);
 			bSetColWidths = TRUE;
 			bSetSimpleTextColWidths = TRUE;
+			bSetRowHeights = TRUE;
 		}
 		else if (aFltName.EqualsAscii(pFilterQPro6))
         {
diff --git sc/source/ui/docshell/docsh4.cxx sc/source/ui/docshell/docsh4.cxx
index 78269ba..8921396 100644
--- sc/source/ui/docshell/docsh4.cxx
+++ sc/source/ui/docshell/docsh4.cxx
@@ -2406,10 +2406,12 @@ long __EXPORT ScDocShell::DdeGetData( const String& rItem,
 		if( aDdeTextFmt.EqualsAscii( "CSV" ) ||
 			aDdeTextFmt.EqualsAscii( "FCSV" ) )
 			aObj.SetSeparator( ',' );
+        aObj.SetExportTextOptions( ScExportTextOptions( ScExportTextOptions::ToSpace, NULL, false ) );
 		return aObj.ExportData( rMimeType, rValue ) ? 1 : 0;
 	}
 
 	ScImportExport aObj( &aDocument, rItem );
+    aObj.SetExportTextOptions( ScExportTextOptions( ScExportTextOptions::ToSpace, NULL, false ) );
 	if( aObj.IsRef() )
 		return aObj.ExportData( rMimeType, rValue ) ? 1 : 0;
 	return 0;
diff --git sc/source/ui/docshell/impex.cxx sc/source/ui/docshell/impex.cxx
index c1bc6bb..cc51d67 100644
--- sc/source/ui/docshell/impex.cxx
+++ sc/source/ui/docshell/impex.cxx
@@ -93,6 +93,12 @@ class StarBASIC;
 
 //========================================================================
 
+namespace
+{
+    const String SYLK_LF = String::CreateFromAscii("\x1b :");
+    const String SEMICOLON = String::CreateFromAscii(";");
+    const String DOUBLE_SEMICOLON = String::CreateFromAscii(";;");
+}
 
 // Gesamtdokument ohne Undo
 
@@ -102,7 +108,7 @@ ScImportExport::ScImportExport( ScDocument* p )
       nSizeLimit( 0 ), cSep( '\t' ), cStr( '"' ), 
       bFormulas( FALSE ), bIncludeFiltered( TRUE ),
       bAll( TRUE ), bSingle( TRUE ), bUndo( FALSE ),
-      bOverflow( FALSE ), mbApi( true )
+      bOverflow( FALSE ), mbApi( true ), mExportTextOptions()
 {
 	pUndoDoc = NULL;
 	pExtOptions = NULL;
@@ -117,7 +123,7 @@ ScImportExport::ScImportExport( ScDocument* p, const ScAddress& rPt )
       nSizeLimit( 0 ), cSep( '\t' ), cStr( '"' ), 
       bFormulas( FALSE ), bIncludeFiltered( TRUE ),
       bAll( FALSE ), bSingle( TRUE ), bUndo( BOOL( pDocSh != NULL ) ),
-      bOverflow( FALSE ), mbApi( true )
+      bOverflow( FALSE ), mbApi( true ), mExportTextOptions()
 {
 	pUndoDoc = NULL;
 	pExtOptions = NULL;
@@ -133,7 +139,7 @@ ScImportExport::ScImportExport( ScDocument* p, const ScRange& r )
       nSizeLimit( 0 ), cSep( '\t' ), cStr( '"' ),
       bFormulas( FALSE ), bIncludeFiltered( TRUE ),
       bAll( FALSE ), bSingle( FALSE ), bUndo( BOOL( pDocSh != NULL ) ),
-      bOverflow( FALSE ), mbApi( true )
+      bOverflow( FALSE ), mbApi( true ), mExportTextOptions()
 {
 	pUndoDoc = NULL;
 	pExtOptions = NULL;
@@ -150,7 +156,7 @@ ScImportExport::ScImportExport( ScDocument* p, const String& rPos )
       nSizeLimit( 0 ), cSep( '\t' ), cStr( '"' ),
       bFormulas( FALSE ), bIncludeFiltered( TRUE ),
       bAll( FALSE ), bSingle( TRUE ), bUndo( BOOL( pDocSh != NULL ) ),
-      bOverflow( FALSE ), mbApi( true )
+      bOverflow( FALSE ), mbApi( true ), mExportTextOptions()
 {
 	pUndoDoc = NULL;
 	pExtOptions = NULL;
@@ -575,6 +581,7 @@ void ScImportExport::WriteUnicodeOrByteString( SvStream& rStrm, const String& rS
 }
 
 
+// This function could be replaced by endlub()
 // static
 void ScImportExport::WriteUnicodeOrByteEndl( SvStream& rStrm )
 {
@@ -605,7 +612,7 @@ enum DoubledQuoteMode
 	DQM_SEPARATE	// end one string and begin next
 };
 
-const sal_Unicode* lcl_ScanString( const sal_Unicode* p, String& rString,
+static const sal_Unicode* lcl_ScanString( const sal_Unicode* p, String& rString,
 			sal_Unicode cStr, DoubledQuoteMode eMode )
 {
 	p++;	//! jump over opening quote
@@ -653,8 +660,26 @@ const sal_Unicode* lcl_ScanString( const sal_Unicode* p, String& rString,
 	return p;
 }
 
+static const sal_Unicode* lcl_ScanSylkString( const sal_Unicode* p, String& rString )
+{
+    const sal_Unicode* pStartQuote = p;
+    const sal_Unicode* pEndQuote = 0;
+    while( *(++p) )
+    {
+        if( *p == '"' )
+            pEndQuote = p;
+    }
+    if( pEndQuote )
+    {
+        p = pEndQuote;
+        rString.Append( pStartQuote + 1, sal::static_int_cast<xub_StrLen>( pEndQuote - pStartQuote - 1 ) );
+        rString.SearchAndReplaceAll( DOUBLE_SEMICOLON, ';' );
+        rString.SearchAndReplaceAll( SYLK_LF, _LF );
+    }
+    return p;
+}
 
-void lcl_WriteString( SvStream& rStrm, String& rString, sal_Unicode cStr )
+static void lcl_DoubleEscapeChar( String& rString, sal_Unicode cStr )
 {
 	xub_StrLen n = 0;
 	while( ( n = rString.Search( cStr, n ) ) != STRING_NOTFOUND )
@@ -662,6 +687,11 @@ void lcl_WriteString( SvStream& rStrm, String& rString, sal_Unicode cStr )
 		rString.Insert( cStr, n );
 		n += 2;
 	}
+}
+
+static void lcl_WriteString( SvStream& rStrm, String& rString, sal_Unicode cStr )
+{
+    lcl_DoubleEscapeChar( rString, cStr );
 
 	rString.Insert( cStr, 0 );
 	rString.Append( cStr );
@@ -1285,6 +1315,7 @@ BOOL ScImportExport::Doc2Text( SvStream& rStrm )
 	SCCOL nEndCol = aRange.aEnd.Col();
 	SCROW nEndRow = aRange.aEnd.Row();
 	String aCell;
+    bool bConvertLF = (GetSystemLineEnd() != LINEEND_LF);
 
 	for (nRow = nStartRow; nRow <= nEndRow; nRow++)
 	{
@@ -1308,11 +1339,24 @@ BOOL ScImportExport::Doc2Text( SvStream& rStrm )
 						}
 						else
 						{
-							pDoc->GetString( nCol, nRow, aRange.aStart.Tab(), aCell );
-							if( aCell.Search( cSep ) != STRING_NOTFOUND )
-								lcl_WriteString( rStrm, aCell, cStr );
-							else
-								lcl_WriteSimpleString( rStrm, aCell );
+                            pDoc->GetString( nCol, nRow, aRange.aStart.Tab(), aCell );
+
+                            bool bMultiLineText = ( aCell.Search( _LF ) != STRING_NOTFOUND );
+                            if( bMultiLineText )
+                            {
+                                if( mExportTextOptions.meNewlineConversion == ScExportTextOptions::ToSpace )
+                                    aCell.SearchAndReplaceAll( _LF, ' ' );
+                                else if ( mExportTextOptions.meNewlineConversion == ScExportTextOptions::ToSystem && bConvertLF )
+                                    aCell.ConvertLineEnd();
+                            }
+
+                            if( mExportTextOptions.mcSeparatorConvertTo && cSep )
+                                aCell.SearchAndReplaceAll( cSep, mExportTextOptions.mcSeparatorConvertTo );
+
+                            if( mExportTextOptions.mbAddQuotes && ( aCell.Search( cSep ) != STRING_NOTFOUND ) )
+                                lcl_WriteString( rStrm, aCell, cStr );
+                            else
+                                lcl_WriteSimpleString( rStrm, aCell );
 						}
 					}
 					break;
@@ -1328,10 +1372,23 @@ BOOL ScImportExport::Doc2Text( SvStream& rStrm )
 					default:
 					{
 						pDoc->GetString( nCol, nRow, aRange.aStart.Tab(), aCell );
-						if( aCell.Search( cSep ) != STRING_NOTFOUND )
-							lcl_WriteString( rStrm, aCell, cStr );
-						else
-							lcl_WriteSimpleString( rStrm, aCell );
+
+                        bool bMultiLineText = ( aCell.Search( _LF ) != STRING_NOTFOUND );
+                        if( bMultiLineText )
+                        {
+                            if( mExportTextOptions.meNewlineConversion == ScExportTextOptions::ToSpace )
+                                aCell.SearchAndReplaceAll( _LF, ' ' );
+                            else if ( mExportTextOptions.meNewlineConversion == ScExportTextOptions::ToSystem && bConvertLF )
+                                aCell.ConvertLineEnd();
+                        }
+
+                        if( mExportTextOptions.mcSeparatorConvertTo && cSep )
+                            aCell.SearchAndReplaceAll( cSep, mExportTextOptions.mcSeparatorConvertTo );
+
+                        if( mExportTextOptions.mbAddQuotes && ( aCell.Search( cSep ) != STRING_NOTFOUND ) )
+                            lcl_WriteString( rStrm, aCell, cStr );
+                        else
+                            lcl_WriteSimpleString( rStrm, aCell );
 					}
 				}
 				if( nCol < nEndCol )
@@ -1430,8 +1487,8 @@ BOOL ScImportExport::Sylk2Doc( SvStream& rStrm )
                             if( *p == '"' )
                             {
                                 bText = TRUE;
-                                aText = '\'';       // force string cell
-                                p = lcl_ScanString( p, aText, '"', DQM_ESCAPE );
+                                aText.Erase();
+                                p = lcl_ScanSylkString( p, aText );
                             }
                             else
                                 bText = FALSE;
@@ -1441,7 +1498,9 @@ BOOL ScImportExport::Sylk2Doc( SvStream& rStrm )
                             if ( !(*q == ';' && *(q+1) == 'I') )
                             {   // don't ignore value
                                 if( bText )
-                                    pDoc->SetString( nCol, nRow, aRange.aStart.Tab(), aText );
+                                {
+                                    pDoc->PutCell( nCol, nRow, aRange.aStart.Tab(), ScBaseCell::CreateTextCell( aText, pDoc ), (BOOL) TRUE );
+                                }
                                 else
                                 {
                                     double fVal = rtl_math_uStringToDouble( p,
@@ -1473,7 +1532,9 @@ BOOL ScImportExport::Sylk2Doc( SvStream& rStrm )
 								break;
                             aText = '=';
 							if( *p == '"' )
-                                p = lcl_ScanString( p, aText, '"', DQM_ESCAPE );
+                            {
+                                p = lcl_ScanSylkString( p, aText );
+                            }
 							else
 							{
                                 const sal_Unicode* q = p;
@@ -1667,14 +1728,19 @@ BOOL ScImportExport::Doc2Sylk( SvStream& rStrm )
 				case CELLTYPE_EDIT:
 				hasstring:
 					pDoc->GetString( nCol, nRow, aRange.aStart.Tab(), aCellStr );
+                    aCellStr.SearchAndReplaceAll( _LF, SYLK_LF );
 
 					aBufStr.AssignAscii(RTL_CONSTASCII_STRINGPARAM( "C;X" ));
 					aBufStr += String::CreateFromInt32( c );
 					aBufStr.AppendAscii(RTL_CONSTASCII_STRINGPARAM( ";Y" ));
 					aBufStr += String::CreateFromInt32( r );
 					aBufStr.AppendAscii(RTL_CONSTASCII_STRINGPARAM( ";K" ));
+                    aBufStr.AppendAscii(RTL_CONSTASCII_STRINGPARAM( "\"" ));
 					lcl_WriteSimpleString( rStrm, aBufStr );
-					lcl_WriteString( rStrm, aCellStr, '"' );
+                    lcl_DoubleEscapeChar( aCellStr, ';' );
+					lcl_WriteSimpleString( rStrm, aCellStr );
+					aBufStr.AssignAscii(RTL_CONSTASCII_STRINGPARAM( "\"" ));
+                    lcl_WriteSimpleString( rStrm, aBufStr );
 
 				checkformula:
 					if( bForm )
diff --git sc/source/ui/docshell/servobj.cxx sc/source/ui/docshell/servobj.cxx
index 51e2ec6..1d07f29 100644
--- sc/source/ui/docshell/servobj.cxx
+++ sc/source/ui/docshell/servobj.cxx
@@ -200,10 +200,12 @@ BOOL __EXPORT ScServerObject::GetData(
 		if( aDdeTextFmt.EqualsAscii( "CSV" ) ||
 			aDdeTextFmt.EqualsAscii( "FCSV" ) )
 			aObj.SetSeparator( ',' );
+        aObj.SetExportTextOptions( ScExportTextOptions( ScExportTextOptions::ToSpace, ' ', false ) );
 		return aObj.ExportData( rMimeType, rData ) ? 1 : 0;
 	}
 
 	ScImportExport aObj( pDoc, aRange );
+    aObj.SetExportTextOptions( ScExportTextOptions( ScExportTextOptions::ToSpace, ' ', false ) );
 	if( aObj.IsRef() )
 		return aObj.ExportData( rMimeType, rData ) ? 1 : 0;
 	return 0;
diff --git sc/source/ui/inc/impex.hxx sc/source/ui/inc/impex.hxx
index aaddeeb..d2fe3a3 100644
--- sc/source/ui/inc/impex.hxx
+++ sc/source/ui/inc/impex.hxx
@@ -42,6 +42,17 @@ class SvStream;
 class SfxMedium;
 class ScAsciiOptions;
 
+struct ScExportTextOptions
+{
+    enum NewlineConversion { ToSystem, ToSpace, None };
+    ScExportTextOptions( NewlineConversion eNewlineConversion = ToSystem, sal_Unicode cSeparatorConvertTo = NULL, bool bAddQuotes = false ) : 
+        meNewlineConversion( eNewlineConversion ), mcSeparatorConvertTo( cSeparatorConvertTo ), mbAddQuotes( bAddQuotes ) {}
+
+    NewlineConversion meNewlineConversion;
+    sal_Unicode mcSeparatorConvertTo;   // Convert separator to this character
+    bool mbAddQuotes;
+};
+
 class ScImportExport
 {
 	ScDocShell* pDocSh;
@@ -60,6 +71,7 @@ class ScImportExport
 	BOOL		bUndo;					// Mit Undo?
 	BOOL		bOverflow;				// zuviele Zeilen/Spalten
     bool        mbApi;
+    ScExportTextOptions mExportTextOptions;
 
 	ScAsciiOptions*	pExtOptions;		// erweiterte Optionen
 
@@ -138,6 +150,8 @@ public:
 
     bool IsApi() const { return mbApi; }
     void SetApi( bool bApi ) { mbApi = bApi; }
+    const ScExportTextOptions& GetExportTextOptions() { return mExportTextOptions; }
+    void SetExportTextOptions( const ScExportTextOptions& options ) { mExportTextOptions = options; }
 };
 
 
diff --git sc/source/ui/view/cellsh2.cxx sc/source/ui/view/cellsh2.cxx
index 3e17451..365a2c7 100644
--- sc/source/ui/view/cellsh2.cxx
+++ sc/source/ui/view/cellsh2.cxx
@@ -1064,6 +1064,7 @@ void ScCellShell::ExecuteDB( SfxRequest& rReq )
                     DBG_ASSERT( pDoc, "ScCellShell::ExecuteDB: SID_TEXT_TO_COLUMNS - pDoc is null!" );
 
                     ScImportExport aExport( pDoc, aRange );
+                    aExport.SetExportTextOptions( ScExportTextOptions( ScExportTextOptions::None, NULL, false ) );
 
                     // #i87703# text to columns fails with tab separator
                     aExport.SetDelimiter( static_cast< sal_Unicode >( 0 ) );
diff --git sc/source/ui/view/output2.cxx sc/source/ui/view/output2.cxx
index cb1aff9..d01a843 100644
--- sc/source/ui/view/output2.cxx
+++ sc/source/ui/view/output2.cxx
@@ -1358,11 +1358,13 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
 				}
 				if (bDoCell && !bNeedEdit)
 				{
-					if ( pCell->GetCellType() == CELLTYPE_FORMULA )
+					BOOL bFormulaCell = (pCell->GetCellType() == CELLTYPE_FORMULA);
+					if ( bFormulaCell )
 						lcl_CreateInterpretProgress( bProgress, pDoc, (ScFormulaCell*)pCell );
 					if ( aVars.SetText(pCell) )
 						pOldPattern = NULL;
-                    bNeedEdit = aVars.HasEditCharacters();
+                    bNeedEdit = aVars.HasEditCharacters() ||
+                        (bFormulaCell && ((ScFormulaCell*)pCell)->IsMultilineResult());
                 }
                 if (bDoCell && !bNeedEdit)
                 {
