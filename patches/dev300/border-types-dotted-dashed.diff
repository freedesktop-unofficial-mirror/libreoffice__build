diff --git cui/source/tabpages/border.cxx cui/source/tabpages/border.cxx
index 48aac82..e1ac8fc 100644
--- cui/source/tabpages/border.cxx
+++ cui/source/tabpages/border.cxx
@@ -565,9 +565,10 @@ void SvxBorderTabPage::Reset( const SfxItemSet& rSet )
     {
         // Do all visible lines show the same line widths?
         USHORT nPrim, nDist, nSecn;
-        bool bWidthEq = aFrameSel.GetVisibleWidth( nPrim, nDist, nSecn );
+        SvxBorderStyle nStyle;
+        bool bWidthEq = aFrameSel.GetVisibleWidth( nPrim, nDist, nSecn, nStyle );
         if( bWidthEq )
-            aLbLineStyle.SelectEntry( nPrim * 100, nSecn * 100, nDist * 100 );
+            aLbLineStyle.SelectEntry( nPrim * 100, nSecn * 100, nDist * 100, nStyle );
         else
             aLbLineStyle.SelectEntryPos( 1 );
 
@@ -932,13 +933,31 @@ IMPL_LINK( SvxBorderTabPage, SelColHdl_Impl, ListBox *, pLb )
 
 // -----------------------------------------------------------------------
 
+SvxBorderStyle lcl_getBorderStyle( USHORT nStyle )
+{
+    SvxBorderStyle nResult = SOLID;
+    switch ( nStyle )
+    {
+        case STYLE_DOTTED:
+            nResult = DOTTED;
+            break;
+        case STYLE_DASHED:
+            nResult = DASHED;
+            break;
+        default:
+            nResult = SOLID;
+    }
+    return nResult;
+}
+
 IMPL_LINK( SvxBorderTabPage, SelStyleHdl_Impl, ListBox *, pLb )
 {
     if ( pLb == &aLbLineStyle )
         aFrameSel.SetStyleToSelection(
             static_cast< USHORT >( aLbLineStyle.GetSelectEntryLine1() / 100 ),
             static_cast< USHORT >( aLbLineStyle.GetSelectEntryDistance() / 100 ),
-            static_cast< USHORT >( aLbLineStyle.GetSelectEntryLine2() / 100 ) );
+            static_cast< USHORT >( aLbLineStyle.GetSelectEntryLine2() / 100 ),
+            lcl_getBorderStyle( aLbLineStyle.GetSelectEntryStyle() ) );
 
     return 0;
 }
@@ -1102,6 +1121,8 @@ void SvxBorderTabPage::FillLineListBox_Impl()
 
     aLbLineStyle.InsertEntry( LINE_WIDTH0 );
     aLbLineStyle.InsertEntry( LINE_WIDTH5 );
+    aLbLineStyle.InsertEntry( LINE_WIDTH5, 0, 0, STYLE_DOTTED );
+    aLbLineStyle.InsertEntry( LINE_WIDTH5, 0, 0, STYLE_DASHED );
     aLbLineStyle.InsertEntry( LINE_WIDTH1 );
     aLbLineStyle.InsertEntry( LINE_WIDTH2 );
     aLbLineStyle.InsertEntry( LINE_WIDTH3 );
diff --git drawinglayer/inc/drawinglayer/primitive2d/borderlineprimitive2d.hxx drawinglayer/inc/drawinglayer/primitive2d/borderlineprimitive2d.hxx
index 07a1f8b..8a13430 100644
--- drawinglayer/inc/drawinglayer/primitive2d/borderlineprimitive2d.hxx
+++ drawinglayer/inc/drawinglayer/primitive2d/borderlineprimitive2d.hxx
@@ -66,6 +66,7 @@ namespace drawinglayer
 
             /// the line color
             basegfx::BColor									maRGBColor;
+            short                                           mnStyle;
 
             /// bitfield
             /// flags to influence inside/outside creation
@@ -131,7 +132,8 @@ namespace drawinglayer
                 double fExtendOuterEnd,
                 bool bCreateInside,
                 bool bCreateOutside,
-                const basegfx::BColor& rRGBColor);
+                const basegfx::BColor& rRGBColor,
+                const short nStyle );
 
             /// data read access
             const basegfx::B2DPoint& getStart() const { return maStart; }
@@ -145,7 +147,8 @@ namespace drawinglayer
             double getExtendOuterEnd() const { return mfExtendOuterEnd; }
             bool getCreateInside() const { return mbCreateInside; }
             bool getCreateOutside() const { return mbCreateOutside; }
-            const basegfx::BColor& getRGBColor() const { return maRGBColor; }
+            const basegfx::BColor& getRGBColor () const { return maRGBColor; }
+            short getStyle () const { return mnStyle; }
 
             /// compare operator
             virtual bool operator==(const BasePrimitive2D& rPrimitive) const;
diff --git drawinglayer/source/primitive2d/borderlineprimitive2d.cxx drawinglayer/source/primitive2d/borderlineprimitive2d.cxx
index 088f9bb..5dafced 100644
--- drawinglayer/source/primitive2d/borderlineprimitive2d.cxx
+++ drawinglayer/source/primitive2d/borderlineprimitive2d.cxx
@@ -33,6 +33,7 @@
 #include <basegfx/polygon/b2dpolygon.hxx>
 #include <drawinglayer/primitive2d/polygonprimitive2d.hxx>
 #include <drawinglayer/primitive2d/polypolygonprimitive2d.hxx>
+#include <svtools/borderhelper.hxx>
 #include <numeric>
 
 //////////////////////////////////////////////////////////////////////////////
@@ -157,14 +158,29 @@ namespace drawinglayer
                             // create filled polygon primitive
                             const basegfx::B2DVector aLineWidthOffset((getCorrectedLeftWidth() * 0.5) * aPerpendicular);
                             
-                            aPolygon.append(aTmpStart + aLineWidthOffset);
-                            aPolygon.append(aTmpEnd + aLineWidthOffset);
-                            aPolygon.append(aTmpEnd - aLineWidthOffset);
-                            aPolygon.append(aTmpStart - aLineWidthOffset);
-                            aPolygon.setClosed(true);
+                            aPolygon.append( aTmpStart );
+                            aPolygon.append( aTmpEnd );
+
+                            basegfx::B2DPolyPolygon aDashed = svtools::ApplyLineDashing(
+                                   aPolygon, getStyle(), MAP_100TH_MM );
+                            for (sal_uInt32 i = 0; i < aDashed.count(); i++ )
+                            {
+                                basegfx::B2DPolygon aDash = aDashed.getB2DPolygon( i );
+                                basegfx::B2DPoint aDashStart = aDash.getB2DPoint( 0 );
+                                basegfx::B2DPoint aDashEnd = aDash.getB2DPoint( aDash.count() - 1 );
+
+                                basegfx::B2DPolygon aDashPolygon;
+                                aDashPolygon.append( aDashStart + aLineWidthOffset );
+                                aDashPolygon.append( aDashEnd + aLineWidthOffset );
+                                aDashPolygon.append( aDashEnd - aLineWidthOffset );
+                                aDashPolygon.append( aDashStart - aLineWidthOffset );
+                                aDashPolygon.setClosed( true );
+
+                                aDashed.setB2DPolygon( i, aDashPolygon );
+                            }
 
                             xRetval[0] = Primitive2DReference(new PolyPolygonColorPrimitive2D(
-                                basegfx::B2DPolyPolygon(aPolygon), getRGBColor()));
+                                    basegfx::B2DPolyPolygon( aDashed ), getRGBColor()));
                         }
                     }
                 }
@@ -185,7 +201,8 @@ namespace drawinglayer
             double fExtendOuterEnd,
             bool bCreateInside,
             bool bCreateOutside,
-            const basegfx::BColor& rRGBColor)
+            const basegfx::BColor& rRGBColor,
+            const short nStyle)
         :	BufferedDecompositionPrimitive2D(),
             maStart(rStart),
             maEnd(rEnd),
@@ -197,6 +214,7 @@ namespace drawinglayer
             mfExtendOuterStart(fExtendOuterStart),
             mfExtendOuterEnd(fExtendOuterEnd),
             maRGBColor(rRGBColor),
+            mnStyle(nStyle),
             mbCreateInside(bCreateInside),
             mbCreateOutside(bCreateOutside)
         {
@@ -219,7 +237,8 @@ namespace drawinglayer
                     && getExtendOuterEnd() == rCompare.getExtendOuterEnd()
                     && getCreateInside() == rCompare.getCreateInside()
                     && getCreateOutside() == rCompare.getCreateOutside()
-                    && getRGBColor() == rCompare.getRGBColor());
+                    && getRGBColor() == rCompare.getRGBColor()
+                    && getStyle() == rCompare.getStyle());
             }
 
             return false;
diff --git editeng/inc/editeng/borderline.hxx editeng/inc/editeng/borderline.hxx
index 78d173b..88458fa 100644
--- editeng/inc/editeng/borderline.hxx
+++ editeng/inc/editeng/borderline.hxx
@@ -90,6 +90,13 @@
 
 // ============================================================================
 
+enum SvxBorderStyle
+{
+    SOLID,
+    DOTTED,
+    DASHED
+};
+
 class EDITENG_DLLPUBLIC SvxBorderLine
 {
 protected:
@@ -97,9 +104,11 @@ protected:
     USHORT nOutWidth;
     USHORT nInWidth;
     USHORT nDistance;
+    SvxBorderStyle   m_nStyle;
 
 public:
-    SvxBorderLine( const Color *pCol = 0, USHORT nOut = 0, USHORT nIn = 0, USHORT nDist = 0 );
+    SvxBorderLine( const Color *pCol = 0, USHORT nOut = 0, USHORT nIn = 0, USHORT nDist = 0,
+           SvxBorderStyle nStyle = SOLID );
     SvxBorderLine( const SvxBorderLine& r );
 
     SvxBorderLine& operator=( const SvxBorderLine& r );
@@ -109,10 +118,13 @@ public:
     USHORT 			GetInWidth() const { return nInWidth; }
     USHORT 			GetDistance() const { return nDistance; }
 
+    SvxBorderStyle  GetStyle() const { return m_nStyle; }
+
     void 			SetColor( const Color &rColor ) { aColor = rColor; }
     void			SetOutWidth( USHORT nNew ) { nOutWidth = nNew; }
     void			SetInWidth( USHORT nNew ) { nInWidth = nNew;  }
     void			SetDistance( USHORT nNew ) { nDistance = nNew; }
+    void            SetStyle( SvxBorderStyle nNew ) { m_nStyle = nNew; }
     void			ScaleMetrics( long nMult, long nDiv );
 
     BOOL			operator==( const SvxBorderLine &rCmp ) const;
diff --git editeng/inc/editeng/boxitem.hxx editeng/inc/editeng/boxitem.hxx
index d85f7c2..03671cd 100644
--- editeng/inc/editeng/boxitem.hxx
+++ editeng/inc/editeng/boxitem.hxx
@@ -30,7 +30,7 @@
 #include <svl/poolitem.hxx>
 #include <editeng/borderline.hxx>
 #include <editeng/editengdllapi.h>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 
 namespace rtl { class OUString; }
 
@@ -106,7 +106,7 @@ public:
         //JP 09.06.99: bIgnoreLine = TRUE -> Distance auch returnen, wenn
         //							keine Line gesetzt ist
     USHORT 	CalcLineSpace( USHORT nLine, BOOL bIgnoreLine = FALSE ) const;
-    static com::sun::star::table::BorderLine SvxLineToLine( const SvxBorderLine* pLine, sal_Bool bConvert );
+    static com::sun::star::table::BorderLine2 SvxLineToLine( const SvxBorderLine* pLine, sal_Bool bConvert );
     static sal_Bool LineToSvxLine(const ::com::sun::star::table::BorderLine& rLine, SvxBorderLine& rSvxLine, sal_Bool bConvert);
 };
 
diff --git editeng/inc/editeng/memberids.hrc editeng/inc/editeng/memberids.hrc
index e9cb0b5..0a4ac48 100644
--- editeng/inc/editeng/memberids.hrc
+++ editeng/inc/editeng/memberids.hrc
@@ -41,6 +41,8 @@
 #define MID_OUTER_WIDTH         0x41
 #define MID_INNER_WIDTH         0x35
 #define MID_LINESPACE           0x3b
+#define MID_LINE_STYLE          0x90
+
 
 //NameOrIndex
 #define MID_NAME				16
diff --git editeng/source/items/frmitems.cxx editeng/source/items/frmitems.cxx
index 00a7cfb..b335b0a 100644
--- editeng/source/items/frmitems.cxx
+++ editeng/source/items/frmitems.cxx
@@ -40,6 +40,7 @@
 #include <com/sun/star/table/TableOrientation.hpp>
 #include <com/sun/star/util/SortField.hpp>
 #include <com/sun/star/util/SortFieldType.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/table/CellOrientation.hpp>
 #include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/style/PageStyleLayout.hpp>
@@ -1565,10 +1566,12 @@ void SvxShadowItem::SetEnumValue( sal_uInt16 nVal )
 
 // class SvxBorderLine  --------------------------------------------------
 
-SvxBorderLine::SvxBorderLine( const Color *pCol, sal_uInt16 nOut, sal_uInt16 nIn, sal_uInt16 nDist )
+SvxBorderLine::SvxBorderLine( const Color *pCol, sal_uInt16 nOut, sal_uInt16 nIn, sal_uInt16 nDist,
+       SvxBorderStyle nStyle )
 : nOutWidth( nOut )
 , nInWidth ( nIn )
 , nDistance( nDist )
+, m_nStyle( nStyle )
 {
     if ( pCol )
         aColor = *pCol;
@@ -1589,6 +1592,7 @@ SvxBorderLine& SvxBorderLine::operator=( const SvxBorderLine& r )
     nOutWidth = r.nOutWidth;
     nInWidth = r.nInWidth;
     nDistance = r.nDistance;
+    m_nStyle = r.m_nStyle;
     return *this;
 }
 
@@ -1608,7 +1612,8 @@ sal_Bool SvxBorderLine::operator==( const SvxBorderLine& rCmp ) const
     return ( ( aColor    == rCmp.GetColor() ) 	 &&
              ( nInWidth  == rCmp.GetInWidth() )  &&
              ( nOutWidth == rCmp.GetOutWidth() ) &&
-             ( nDistance == rCmp.GetDistance() ) );
+             ( nDistance == rCmp.GetDistance() ) &&
+             ( m_nStyle == rCmp.GetStyle() ) );
 }
 
 // -----------------------------------------------------------------------
@@ -1825,15 +1830,16 @@ int SvxBoxItem::operator==( const SfxPoolItem& rAttr ) const
 }
 
 // -----------------------------------------------------------------------
-table::BorderLine SvxBoxItem::SvxLineToLine(const SvxBorderLine* pLine, sal_Bool bConvert)
+table::BorderLine2 SvxBoxItem::SvxLineToLine(const SvxBorderLine* pLine, sal_Bool bConvert)
 {
-    table::BorderLine aLine;
+    table::BorderLine2 aLine;
     if(pLine)
     {
         aLine.Color			 = pLine->GetColor().GetColor() ;
         aLine.InnerLineWidth = sal_uInt16( bConvert ? TWIP_TO_MM100_UNSIGNED(pLine->GetInWidth() ): pLine->GetInWidth() );
         aLine.OuterLineWidth = sal_uInt16( bConvert ? TWIP_TO_MM100_UNSIGNED(pLine->GetOutWidth()): pLine->GetOutWidth() );
         aLine.LineDistance   = sal_uInt16( bConvert ? TWIP_TO_MM100_UNSIGNED(pLine->GetDistance()): pLine->GetDistance() );
+        aLine.LineStyle      = pLine->GetStyle( );
     }
     else
         aLine.Color			 = aLine.InnerLineWidth = aLine.OuterLineWidth = aLine.LineDistance	 = 0;
@@ -1843,7 +1849,7 @@ table::BorderLine SvxBoxItem::SvxLineToLine(const SvxBorderLine* pLine, sal_Bool
 bool SvxBoxItem::QueryValue( uno::Any& rVal, BYTE nMemberId  ) const
 {
     sal_Bool bConvert = 0!=(nMemberId&CONVERT_TWIPS);
-    table::BorderLine aRetLine;
+    table::BorderLine2 aRetLine;
     sal_uInt16 nDist = 0;
     sal_Bool bDistMember = sal_False;
     nMemberId &= ~CONVERT_TWIPS;
@@ -2780,7 +2786,7 @@ void SvxBoxInfoItem::ResetFlags()
 bool SvxBoxInfoItem::QueryValue( uno::Any& rVal, BYTE nMemberId  ) const
 {
     sal_Bool bConvert = 0!=(nMemberId&CONVERT_TWIPS);
-    table::BorderLine aRetLine;
+    table::BorderLine2 aRetLine;
     sal_Int16 nVal=0;
     sal_Bool bIntMember = sal_False;
     nMemberId &= ~CONVERT_TWIPS;
@@ -3321,6 +3327,7 @@ sal_Bool SvxLineItem::PutValue( const uno::Any& rVal, BYTE nMemId )
             case MID_OUTER_WIDTH:   pLine->SetOutWidth((USHORT)nVal);   break;
             case MID_INNER_WIDTH:   pLine->SetInWidth((USHORT)nVal);   break;
             case MID_DISTANCE:      pLine->SetDistance((USHORT)nVal);   break;
+            case MID_LINE_STYLE:    pLine->SetStyle((SvxBorderStyle)nVal); break;
             default:
                 DBG_ERROR( "Wrong MemberId" );
                 return sal_False;
diff --git editeng/source/rtf/rtfitem.cxx editeng/source/rtf/rtfitem.cxx
index ce2adc3..4334b0f 100644
--- editeng/source/rtf/rtfitem.cxx
+++ editeng/source/rtf/rtfitem.cxx
@@ -1627,10 +1627,15 @@ case RTF_BRDRBAR:			break;
             }
             goto SETBORDERLINE;
 
-        case RTF_BRDRS:
         case RTF_BRDRDOT:
-        case RTF_BRDRHAIR:
+            aBrd.SetStyle( DOTTED );
+            break;
         case RTF_BRDRDASH:
+            aBrd.SetStyle( DASHED );
+            break;
+        case RTF_BRDRS:
+        case RTF_BRDRHAIR:
+            aBrd.SetStyle( SOLID );
 SETBORDERLINE:
             SetBorderLine( nBorderTyp, aAttr, aBrd );
             break;
diff --git filter/inc/filter/msfilter/msdffimp.hxx filter/inc/filter/msfilter/msdffimp.hxx
index 67571fb..9d2026e 100644
--- filter/inc/filter/msfilter/msdffimp.hxx
+++ filter/inc/filter/msfilter/msdffimp.hxx
@@ -289,6 +289,7 @@ struct MSFILTER_DLLPUBLIC SvxMSDffImportRec
     ULONG		nShapeId;
     MSO_SPT		eShapeType;
     MSO_LineStyle eLineStyle;	// Umrandungs-Arten
+    MSO_LineDashing eLineDashing;
     BOOL		bDrawHell		:1;
     BOOL		bHidden			:1;
     BOOL		bReplaceByFly	:1;
diff --git filter/source/msfilter/msdffimp.cxx filter/source/msfilter/msdffimp.cxx
index 77cb47e..2193be2 100644
--- filter/source/msfilter/msdffimp.cxx
+++ filter/source/msfilter/msdffimp.cxx
@@ -6021,6 +6021,10 @@ SdrObject* SvxMSDffManager::ProcessObj(SvStream& rSt,
                             : (MSO_LineStyle)USHRT_MAX;
         pTextImpRec->eLineStyle = pImpRec->eLineStyle;
 
+        pImpRec->eLineDashing = (MSO_LineDashing)GetPropertyValue(
+                DFF_Prop_lineDashing, mso_lineSolid );
+        pTextImpRec->eLineDashing = pImpRec->eLineDashing;
+
         if( pImpRec->nShapeId )
         {
             // Import-Record-Liste ergaenzen
@@ -8060,6 +8064,7 @@ SvxMSDffImportRec::SvxMSDffImportRec()
       eShapeType( mso_sptNil )
 {
       eLineStyle      = mso_lineSimple; // GPF-Bug #66227#
+      eLineDashing    = mso_lineSolid;
       bDrawHell       = FALSE;
       bHidden         = FALSE;
       bReplaceByFly   = FALSE;
@@ -8107,6 +8112,7 @@ SvxMSDffImportRec::SvxMSDffImportRec(const SvxMSDffImportRec& rCopy)
        *pYRelTo = *(rCopy.pYRelTo);
     }
     eLineStyle       = rCopy.eLineStyle; // GPF-Bug #66227#
+    eLineDashing     = rCopy.eLineDashing;
     bDrawHell        = rCopy.bDrawHell;
     bHidden          = rCopy.bHidden;
     bReplaceByFly    = rCopy.bReplaceByFly;
diff --git filter/source/xslt/export/uof/odf2uof_spreadsheet.xsl filter/source/xslt/export/uof/odf2uof_spreadsheet.xsl
index 1507305..78a37f9 100644
--- filter/source/xslt/export/uof/odf2uof_spreadsheet.xsl
+++ filter/source/xslt/export/uof/odf2uof_spreadsheet.xsl
@@ -4262,7 +4262,7 @@
 				<xsl:element name="uof:左">
 					<xsl:attribute name="uof:locID">u0057</xsl:attribute>
 					<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-					<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+                    <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 					<xsl:if test="$border!='none'">
 						<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),$uofUnit)"/></xsl:attribute>
 						<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
@@ -4274,7 +4274,7 @@
 				<xsl:element name="uof:上">
 					<xsl:attribute name="uof:locID">u0058</xsl:attribute>
 					<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-					<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+                    <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 					<xsl:if test="$border!='none'">
 						<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),$uofUnit)"/></xsl:attribute>
 						<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
@@ -4286,7 +4286,7 @@
 				<xsl:element name="uof:右">
 					<xsl:attribute name="uof:locID">u0059</xsl:attribute>
 					<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-					<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+                    <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 					<xsl:if test="$border!='none'">
 						<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),$uofUnit)"/></xsl:attribute>
 						<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
@@ -4298,7 +4298,7 @@
 				<xsl:element name="uof:下">
 					<xsl:attribute name="uof:locID">u0060</xsl:attribute>
 					<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-					<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+                    <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 					<xsl:if test="$border!='none'">
 						<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),$uofUnit)"/></xsl:attribute>
 						<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
diff --git filter/source/xslt/export/uof/odf2uof_text.xsl filter/source/xslt/export/uof/odf2uof_text.xsl
index cea93c8..04596c4 100644
--- filter/source/xslt/export/uof/odf2uof_text.xsl
+++ filter/source/xslt/export/uof/odf2uof_text.xsl
@@ -3248,7 +3248,7 @@
 		<xsl:element name="uof:左">
 			<xsl:attribute name="uof:locID">u0057</xsl:attribute>
 			<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-			<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+            <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 			<xsl:if test="$border!='none'">
 				<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),substring($ooUnit,1,2))"/></xsl:attribute>
 				<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
@@ -3266,7 +3266,7 @@
 		<xsl:element name="uof:上">
 			<xsl:attribute name="uof:locID">u0058</xsl:attribute>
 			<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-			<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+            <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 			<xsl:if test="$border!='none'">
 				<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),substring($ooUnit,1,2))"/></xsl:attribute>
 				<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
@@ -3284,7 +3284,7 @@
 		<xsl:element name="uof:右">
 			<xsl:attribute name="uof:locID">u0059</xsl:attribute>
 			<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-			<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+            <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 			<xsl:if test="$border!='none'">
 				<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),substring($ooUnit,1,2))"/></xsl:attribute>
 				<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
@@ -3302,7 +3302,7 @@
 		<xsl:element name="uof:下">
 			<xsl:attribute name="uof:locID">u0060</xsl:attribute>
 			<xsl:attribute name="uof:attrList">类型 宽度 边距 颜色 阴影</xsl:attribute>
-			<xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
+            <xsl:attribute name="uof:类型"><xsl:choose><xsl:when test="$border!='none'"><xsl:choose><xsl:when test="substring-before(substring-after($border,' '),' ')='solid'">single</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='double'">double</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dashed'">dash</xsl:when><xsl:when test="substring-before(substring-after($border,' '),' ')='dotted'">dotted</xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise>none</xsl:otherwise></xsl:choose></xsl:attribute>
 			<xsl:if test="$border!='none'">
 				<xsl:attribute name="uof:宽度"><xsl:value-of select="substring-before(substring-before($border,' '),substring($ooUnit,1,2))"/></xsl:attribute>
 				<xsl:attribute name="uof:颜色"><xsl:value-of select="substring-after(substring-after($border,' '),' ')"/></xsl:attribute>
diff --git offapi/com/sun/star/table/BorderLine.idl offapi/com/sun/star/table/BorderLine.idl
index 96d1a68..0ecd6da 100644
--- offapi/com/sun/star/table/BorderLine.idl
+++ offapi/com/sun/star/table/BorderLine.idl
@@ -71,7 +71,6 @@ published struct BorderLine
         double line (in 1/100 mm).
      */
     short LineDistance;
-
 };
 
 //=============================================================================
diff --git offapi/com/sun/star/table/BorderLine2.idl offapi/com/sun/star/table/BorderLine2.idl
new file mode 100644
index 0000000..4627305
--- /dev/null
+++ offapi/com/sun/star/table/BorderLine2.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: BorderLine.idl,v $
+ * $Revision: 1.8 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_table_BorderLine2_idl__
+#define __com_sun_star_table_BorderLine2_idl__
+
+
+#include <com/sun/star/table/BorderLine.idl>
+#include <com/sun/star/table/BorderLineStyle.idl>
+
+//=============================================================================
+
+module com {  module sun {  module star {  module table {
+
+//=============================================================================
+
+struct BorderLine2 : BorderLine
+{
+    /** Style of the border. @see BorderLineStyle
+     */
+    short LineStyle;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git offapi/com/sun/star/table/BorderLineStyle.idl offapi/com/sun/star/table/BorderLineStyle.idl
new file mode 100644
index 0000000..1914373
--- /dev/null
+++ offapi/com/sun/star/table/BorderLineStyle.idl
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: TableSortFieldType.idl,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_table_BorderLineStyle_idl__
+#define __com_sun_star_table_BorderLineStyle_idl__
+
+
+//=============================================================================
+
+module com {  module sun {  module star {  module table {
+
+//=============================================================================
+
+constants BorderLineStyle
+{
+    //-------------------------------------------------------------------------
+    /** Solid border line.
+     */
+    const short SOLID = 0;
+
+    //-------------------------------------------------------------------------
+    /** Dotted border line.
+     */
+    const short DOTTED = 1;
+
+    //-------------------------------------------------------------------------
+    /** Dashed border line.
+     */
+    const short DASHED = 2;
+
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git offapi/com/sun/star/table/makefile.mk offapi/com/sun/star/table/makefile.mk
index 605a7a9..9b7e185 100644
--- offapi/com/sun/star/table/makefile.mk
+++ offapi/com/sun/star/table/makefile.mk
@@ -41,6 +41,8 @@ IDLFILES=\
     AccessibleCellView.idl      \
     AccessibleTableView.idl	\
     BorderLine.idl\
+    BorderLine2.idl\
+    BorderLineStyle.idl\
     Cell.idl\
     CellAddress.idl\
     CellContentType.idl\
diff --git oox/inc/oox/helper/helper.hxx oox/inc/oox/helper/helper.hxx
index 67a5f16..4206cf9 100644
--- oox/inc/oox/helper/helper.hxx
+++ oox/inc/oox/helper/helper.hxx
@@ -97,6 +97,10 @@ const sal_Int32 API_RGB_TRANSPARENT         = -1;       /// Transparent color fo
 const sal_Int32 API_RGB_BLACK               = 0x000000;  /// Black color for API calls.
 const sal_Int32 API_RGB_WHITE               = 0xFFFFFF;  /// White color for API calls.
 
+const sal_Int16 API_LINE_SOLID              = 0;
+const sal_Int16 API_LINE_DOTTED             = 1;
+const sal_Int16 API_LINE_DASHED             = 2;
+
 const sal_Int16 API_LINE_NONE               = 0;
 const sal_Int16 API_LINE_HAIR               = 2;
 const sal_Int16 API_LINE_THIN               = 35;
diff --git oox/inc/oox/xls/stylesbuffer.hxx oox/inc/oox/xls/stylesbuffer.hxx
index 3a5efc7..ea134c5 100644
--- oox/inc/oox/xls/stylesbuffer.hxx
+++ oox/inc/oox/xls/stylesbuffer.hxx
@@ -33,7 +33,7 @@
 #include <com/sun/star/table/CellHoriJustify.hpp>
 #include <com/sun/star/table/CellOrientation.hpp>
 #include <com/sun/star/table/CellVertJustify.hpp>
-#include <com/sun/star/table/TableBorder.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include "oox/helper/containerhelper.hxx"
 #include "oox/helper/graphichelper.hxx"
 #include "oox/drawingml/color.hxx"
@@ -517,10 +517,12 @@ struct BorderModel
 /** Contains API attributes of a complete cell border. */
 struct ApiBorderData
 {
-    typedef ::com::sun::star::table::TableBorder    ApiTableBorder;
-    typedef ::com::sun::star::table::BorderLine     ApiBorderLine;
+    typedef ::com::sun::star::table::BorderLine2     ApiBorderLine;
 
-    ApiTableBorder      maBorder;           /// Left/right/top/bottom line format.
+    ApiBorderLine       maLeft;             /// Left line format
+    ApiBorderLine       maRight;            /// Right line format
+    ApiBorderLine       maTop;              /// Top line format
+    ApiBorderLine       maBottom;           /// Bottom line format
     ApiBorderLine       maTLtoBR;           /// Diagonal top-left to bottom-right line format.
     ApiBorderLine       maBLtoTR;           /// Diagonal bottom-left to top-right line format.
     bool                mbBorderUsed;       /// True = left/right/top/bottom line format used.
@@ -583,7 +585,7 @@ private:
 
     /** Converts border line data to an API struct, returns true, if the line is marked as used. */
     bool                convertBorderLine(
-                            ::com::sun::star::table::BorderLine& rBorderLine,
+                            ::com::sun::star::table::BorderLine2& rBorderLine,
                             const BorderLineModel& rModel );
 
 private:
diff --git oox/source/drawingml/table/tablecell.cxx oox/source/drawingml/table/tablecell.cxx
index bb3287c..6decf3a 100644
--- oox/source/drawingml/table/tablecell.cxx
+++ oox/source/drawingml/table/tablecell.cxx
@@ -37,7 +37,7 @@
 #include <com/sun/star/beans/XMultiPropertySet.hpp>
 #include <com/sun/star/table/XTable.hpp>
 #include <com/sun/star/table/XMergeableCellRange.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/drawing/LineStyle.hpp>
 #include <com/sun/star/drawing/TextVerticalAdjust.hpp>
 #include <com/sun/star/drawing/TextHorizontalAdjust.hpp>
@@ -48,7 +48,7 @@ using namespace ::oox::core;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
-using ::com::sun::star::table::BorderLine;
+using ::com::sun::star::table::BorderLine2;
 using ::com::sun::star::drawing::LineStyle;
 
 namespace oox { namespace drawingml { namespace table {
@@ -76,7 +76,7 @@ void applyLineAttributes( const ::oox::core::XmlFilterBase& rFilterBase,
         Reference< XPropertySet >& rxPropSet, oox::drawingml::LineProperties& rLineProperties,
         sal_Int32 nPropId )
 {
-    BorderLine aBorderLine( 0, 0, 0, 0 );
+    BorderLine2 aBorderLine( 0, 0, 0, 0, API_LINE_SOLID );
     if( rLineProperties.maLineFill.moFillType.differsFrom( XML_noFill ) )
     {
         Color aColor = rLineProperties.maLineFill.getBestSolidColor();
diff --git oox/source/drawingml/table/tableproperties.cxx oox/source/drawingml/table/tableproperties.cxx
index 5c0af81..9357c9f 100644
--- oox/source/drawingml/table/tableproperties.cxx
+++ oox/source/drawingml/table/tableproperties.cxx
@@ -32,7 +32,7 @@
 #include <com/sun/star/beans/XMultiPropertySet.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/table/XMergeableCellRange.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include "oox/core/namespaces.hxx"
 #include "oox/core/xmlfilterbase.hxx"
 #include "oox/helper/propertyset.hxx"
diff --git oox/source/drawingml/table/tablerow.cxx oox/source/drawingml/table/tablerow.cxx
index af53830..0184a7e 100644
--- oox/source/drawingml/table/tablerow.cxx
+++ oox/source/drawingml/table/tablerow.cxx
@@ -34,7 +34,7 @@
 #include "oox/helper/propertyset.hxx"
 #include <com/sun/star/table/XTable.hpp>
 #include <com/sun/star/table/XMergeableCellRange.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 
 using rtl::OUString;
 using namespace ::oox::core;
diff --git oox/source/xls/stylesbuffer.cxx oox/source/xls/stylesbuffer.cxx
index f9e78c0..d623524 100644
--- oox/source/xls/stylesbuffer.cxx
+++ oox/source/xls/stylesbuffer.cxx
@@ -43,6 +43,7 @@
 #include <com/sun/star/text/XText.hpp>
 #include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/CellJustifyMethod.hpp>
+#include <com/sun/star/table/TableBorder.hpp>
 #include <rtl/tencinfo.h>
 #include <rtl/ustrbuf.hxx>
 #include "properties.hxx"
@@ -71,6 +72,7 @@ using ::com::sun::star::awt::FontDescriptor;
 using ::com::sun::star::awt::XDevice;
 using ::com::sun::star::awt::XFont2;
 using ::com::sun::star::table::BorderLine;
+using ::com::sun::star::table::BorderLine2;
 using ::com::sun::star::table::TableBorder;
 using ::com::sun::star::text::XText;
 using ::com::sun::star::style::XStyle;
@@ -1504,6 +1506,15 @@ void Protection::writeToPropertyMap( PropertyMap& rPropMap ) const
 
 // ============================================================================
 
+namespace {
+
+bool lcl_isBorder(const ::com::sun::star::table::BorderLine& rBorder)
+{
+    return (rBorder.InnerLineWidth > 0) || (rBorder.OuterLineWidth > 0);
+}
+
+}
+
 BorderLineModel::BorderLineModel( bool bDxf ) :
     mnStyle( XML_none ),
     mbUsed( !bDxf )
@@ -1551,10 +1562,10 @@ ApiBorderData::ApiBorderData() :
 bool ApiBorderData::hasAnyOuterBorder() const
 {
     return
-        (maBorder.IsTopLineValid    && (maBorder.TopLine.OuterLineWidth > 0)) ||
-        (maBorder.IsBottomLineValid && (maBorder.BottomLine.OuterLineWidth > 0)) ||
-        (maBorder.IsLeftLineValid   && (maBorder.LeftLine.OuterLineWidth > 0)) ||
-        (maBorder.IsRightLineValid  && (maBorder.RightLine.OuterLineWidth > 0));
+        ( ( lcl_isBorder( maTop ) &&  maTop.OuterLineWidth > 0 ) ) ||
+        ( ( lcl_isBorder( maBottom ) && maBottom.OuterLineWidth > 0 ) ) ||
+        ( ( lcl_isBorder( maLeft ) && maLeft.OuterLineWidth > 0 ) ) ||
+        ( ( lcl_isBorder( maRight ) && maRight.OuterLineWidth > 0 ) );
 }
 
 namespace {
@@ -1592,7 +1603,10 @@ bool operator==( const TableBorder& rLeft, const TableBorder& rRight )
 bool operator==( const ApiBorderData& rLeft, const ApiBorderData& rRight )
 {
     return
-        (rLeft.maBorder     == rRight.maBorder) &&
+        (rLeft.maLeft       == rRight.maLeft)   &&
+        (rLeft.maRight      == rRight.maRight)  &&
+        (rLeft.maTop        == rRight.maTop)    &&
+        (rLeft.maBottom     == rRight.maBottom) &&
         (rLeft.maTLtoBR     == rRight.maTLtoBR) &&
         (rLeft.maBLtoTR     == rRight.maBLtoTR) &&
         (rLeft.mbBorderUsed == rRight.mbBorderUsed) &&
@@ -1616,7 +1630,7 @@ inline sal_Int32 lclGetBorderLineWidth( const BorderLine& rBorderLine )
     return rBorderLine.OuterLineWidth + rBorderLine.LineDistance + rBorderLine.InnerLineWidth;
 }
 
-const BorderLine* lclGetThickerLine( const BorderLine& rBorderLine1, sal_Bool bValid1, const BorderLine& rBorderLine2, sal_Bool bValid2 )
+const BorderLine2* lclGetThickerLine( const BorderLine2& rBorderLine1, sal_Bool bValid1, const BorderLine2& rBorderLine2, sal_Bool bValid2 )
 {
     if( bValid1 && bValid2 )
         return (lclGetBorderLineWidth( rBorderLine1 ) < lclGetBorderLineWidth( rBorderLine2 )) ? &rBorderLine2 : &rBorderLine1;
@@ -1754,21 +1768,10 @@ void Border::finalizeImport()
     maApiData.mbBorderUsed = maModel.maLeft.mbUsed || maModel.maRight.mbUsed || maModel.maTop.mbUsed || maModel.maBottom.mbUsed;
     maApiData.mbDiagUsed   = maModel.maDiagonal.mbUsed;
 
-    maApiData.maBorder.IsLeftLineValid   = convertBorderLine( maApiData.maBorder.LeftLine,   maModel.maLeft );
-    maApiData.maBorder.IsRightLineValid  = convertBorderLine( maApiData.maBorder.RightLine,  maModel.maRight );
-    maApiData.maBorder.IsTopLineValid    = convertBorderLine( maApiData.maBorder.TopLine,    maModel.maTop );
-    maApiData.maBorder.IsBottomLineValid = convertBorderLine( maApiData.maBorder.BottomLine, maModel.maBottom );
-
-    if( !mbDxf )
-    {
-        maApiData.maBorder.IsVerticalLineValid = maApiData.maBorder.IsLeftLineValid || maApiData.maBorder.IsRightLineValid;
-        if( const BorderLine* pVertLine = lclGetThickerLine( maApiData.maBorder.LeftLine, maApiData.maBorder.IsLeftLineValid, maApiData.maBorder.RightLine, maApiData.maBorder.IsRightLineValid ) )
-            maApiData.maBorder.VerticalLine = *pVertLine;
-
-        maApiData.maBorder.IsHorizontalLineValid = maApiData.maBorder.IsTopLineValid || maApiData.maBorder.IsBottomLineValid;
-        if( const BorderLine* pHorLine = lclGetThickerLine( maApiData.maBorder.TopLine, maApiData.maBorder.IsTopLineValid, maApiData.maBorder.BottomLine, maApiData.maBorder.IsBottomLineValid ) )
-            maApiData.maBorder.HorizontalLine = *pHorLine;
-    }
+    convertBorderLine( maApiData.maLeft,   maModel.maLeft );
+    convertBorderLine( maApiData.maRight,  maModel.maRight );
+    convertBorderLine( maApiData.maTop,    maModel.maTop );
+    convertBorderLine( maApiData.maBottom, maModel.maBottom );
 
     if( maModel.mbDiagTLtoBR )
         convertBorderLine( maApiData.maTLtoBR, maModel.maDiagonal );
@@ -1779,7 +1782,12 @@ void Border::finalizeImport()
 void Border::writeToPropertyMap( PropertyMap& rPropMap ) const
 {
     if( maApiData.mbBorderUsed )
-        rPropMap[ PROP_TableBorder ] <<= maApiData.maBorder;
+    {
+        rPropMap[ PROP_LeftBorder ]   <<= maApiData.maLeft;
+        rPropMap[ PROP_RightBorder ]  <<= maApiData.maRight;
+        rPropMap[ PROP_TopBorder ]    <<= maApiData.maTop;
+        rPropMap[ PROP_BottomBorder ] <<= maApiData.maBottom;
+    }
     if( maApiData.mbDiagUsed )
     {
         rPropMap[ PROP_DiagonalTLBR ] <<= maApiData.maTLtoBR;
@@ -1787,29 +1795,18 @@ void Border::writeToPropertyMap( PropertyMap& rPropMap ) const
     }
 }
 
-namespace {
-
-bool lcl_isBorder(const ::com::sun::star::table::BorderLine& rBorder)
-{
-    return (rBorder.InnerLineWidth > 0) || (rBorder.OuterLineWidth > 0);
-}
-
-}
-
 bool Border::hasBorder() const
 {
-    const ApiBorderData::ApiTableBorder& rTabBorder = maApiData.maBorder;
-
-    if (rTabBorder.IsBottomLineValid && lcl_isBorder(rTabBorder.BottomLine))
+    if (lcl_isBorder(maApiData.maBottom))
         return true;
 
-    if (rTabBorder.IsTopLineValid && lcl_isBorder(rTabBorder.TopLine))
+    if (lcl_isBorder(maApiData.maTop))
         return true;
 
-    if (rTabBorder.IsLeftLineValid && lcl_isBorder(rTabBorder.LeftLine))
+    if (lcl_isBorder(maApiData.maLeft))
         return true;
 
-    if (rTabBorder.IsRightLineValid && lcl_isBorder(rTabBorder.RightLine))
+    if (lcl_isBorder(maApiData.maRight))
         return true;
 
     return false;
@@ -1828,15 +1825,25 @@ BorderLineModel* Border::getBorderLine( sal_Int32 nElement )
     return 0;
 }
 
-bool Border::convertBorderLine( BorderLine& rBorderLine, const BorderLineModel& rModel )
+bool Border::convertBorderLine( BorderLine2& rBorderLine, const BorderLineModel& rModel )
 {
     rBorderLine.Color = rModel.maColor.getColor( getBaseFilter().getGraphicHelper(), API_RGB_BLACK );
     switch( rModel.mnStyle )
     {
         case XML_dashDot:           lclSetBorderLineWidth( rBorderLine, API_LINE_THIN );    break;
         case XML_dashDotDot:        lclSetBorderLineWidth( rBorderLine, API_LINE_THIN );    break;
-        case XML_dashed:            lclSetBorderLineWidth( rBorderLine, API_LINE_THIN );    break;
-        case XML_dotted:            lclSetBorderLineWidth( rBorderLine, API_LINE_THIN );    break;
+        case XML_dashed:
+        {
+                                    lclSetBorderLineWidth( rBorderLine, API_LINE_THIN );
+                                    rBorderLine.LineStyle = API_LINE_DASHED;
+                                    break;
+        }
+        case XML_dotted:
+        {
+                                    lclSetBorderLineWidth( rBorderLine, API_LINE_THIN );
+                                    rBorderLine.LineStyle = API_LINE_DOTTED;
+                                    break;
+        }
         case XML_double:            lclSetBorderLineWidth( rBorderLine, API_LINE_THIN, API_LINE_THIN, API_LINE_THIN ); break;
         case XML_hair:              lclSetBorderLineWidth( rBorderLine, API_LINE_HAIR );    break;
         case XML_medium:            lclSetBorderLineWidth( rBorderLine, API_LINE_MEDIUM );  break;
diff --git sc/source/filter/excel/xestyle.cxx sc/source/filter/excel/xestyle.cxx
index e4b2260..8e498a5 100644
--- sc/source/filter/excel/xestyle.cxx
+++ sc/source/filter/excel/xestyle.cxx
@@ -1570,9 +1570,26 @@ void lclGetBorderLine(
         else if( nOuterWidth > DEF_LINE_WIDTH_2 )
             rnXclLine = EXC_LINE_THICK;
         else if( nOuterWidth > DEF_LINE_WIDTH_1 )
+        {
             rnXclLine = EXC_LINE_MEDIUM;
+            if ( pLine->GetStyle( ) == DASHED )
+                rnXclLine = EXC_LINE_MEDIUMDASHED;
+        }
         else if( nOuterWidth > DEF_LINE_WIDTH_0 )
+        {
             rnXclLine = EXC_LINE_THIN;
+            switch ( pLine->GetStyle( ) )
+            {
+                case DASHED:
+                    rnXclLine = EXC_LINE_DASHED;
+                    break;
+                case DOTTED:
+                    rnXclLine = EXC_LINE_DOTTED;
+                    break;
+                default:
+                    break;
+            }
+        }
         else if( nOuterWidth > 0 )
             rnXclLine = EXC_LINE_HAIR;
         else
@@ -1738,6 +1755,9 @@ static const char* ToLineStyle( sal_uInt8 nLineStyle )
         case EXC_LINE_THICK:    return "thick";
         case EXC_LINE_DOUBLE:   return "double";
         case EXC_LINE_HAIR:     return "hair";
+        case EXC_LINE_DOTTED:     return "dotted";
+        case EXC_LINE_DASHED:     return "dashed";
+        case EXC_LINE_MEDIUMDASHED:     return "mediumdashed";
     }
     return "*unknown*";
 }
diff --git sc/source/filter/excel/xistyle.cxx sc/source/filter/excel/xistyle.cxx
index 09553ca..c7cc3fb 100644
--- sc/source/filter/excel/xistyle.cxx
+++ sc/source/filter/excel/xistyle.cxx
@@ -882,23 +882,23 @@ namespace {
 /** Converts the passed line style to a SvxBorderLine, or returns false, if style is "no line". */
 bool lclConvertBorderLine( SvxBorderLine& rLine, const XclImpPalette& rPalette, sal_uInt8 nXclLine, sal_uInt16 nXclColor )
 {
-    static const sal_uInt16 ppnLineParam[][ 3 ] =
+    static const sal_uInt16 ppnLineParam[][ 4 ] =
     {
-        //  outer width,        inner width,        distance
-        {   0,                  0,                  0 },                // 0 = none
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // 1 = thin
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // 2 = medium
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // 3 = dashed
-        {   DEF_LINE_WIDTH_0,   0,                  0 },                // 4 = dotted
-        {   DEF_LINE_WIDTH_3,   0,                  0 },                // 5 = thick
-        {   DEF_LINE_WIDTH_1,   DEF_LINE_WIDTH_1,   DEF_LINE_WIDTH_1 }, // 6 = double
-        {   DEF_LINE_WIDTH_0,   0,                  0 },                // 7 = hair
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // 8 = med dash
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // 9 = thin dashdot
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // A = med dashdot
-        {   DEF_LINE_WIDTH_1,   0,                  0 },                // B = thin dashdotdot
-        {   DEF_LINE_WIDTH_2,   0,                  0 },                // C = med dashdotdot
-        {   DEF_LINE_WIDTH_2,   0,                  0 }                 // D = med slant dashdot
+        //  outer width,        inner width,        distance    type
+        {   0,                  0,                  0,          SOLID },                // 0 = none
+        {   DEF_LINE_WIDTH_1,   0,                  0,          SOLID },                // 1 = thin
+        {   DEF_LINE_WIDTH_2,   0,                  0,          SOLID },                // 2 = medium
+        {   DEF_LINE_WIDTH_1,   0,                  0,          DASHED },               // 3 = dashed
+        {   DEF_LINE_WIDTH_1,   0,                  0,          DOTTED },               // 4 = dotted
+        {   DEF_LINE_WIDTH_3,   0,                  0,          SOLID },                // 5 = thick
+        {   DEF_LINE_WIDTH_1,   DEF_LINE_WIDTH_1,   DEF_LINE_WIDTH_1 },                 // 6 = double
+        {   DEF_LINE_WIDTH_0,   0,                  0,          SOLID },                // 7 = hair
+        {   DEF_LINE_WIDTH_2,   0,                  0,          DASHED },               // 8 = med dash
+        {   DEF_LINE_WIDTH_1,   0,                  0,          SOLID },                // 9 = thin dashdot
+        {   DEF_LINE_WIDTH_2,   0,                  0,          SOLID },                // A = med dashdot
+        {   DEF_LINE_WIDTH_1,   0,                  0,          SOLID },                // B = thin dashdotdot
+        {   DEF_LINE_WIDTH_2,   0,                  0,          SOLID },                // C = med dashdotdot
+        {   DEF_LINE_WIDTH_2,   0,                  0,          SOLID }                 // D = med slant dashdot
     };
 
     if( nXclLine == EXC_LINE_NONE )
@@ -910,6 +910,7 @@ bool lclConvertBorderLine( SvxBorderLine& rLine, const XclImpPalette& rPalette,
     rLine.SetOutWidth( ppnLineParam[ nXclLine ][ 0 ] );
     rLine.SetInWidth(  ppnLineParam[ nXclLine ][ 1 ] );
     rLine.SetDistance( ppnLineParam[ nXclLine ][ 2 ] );
+    rLine.SetStyle( (SvxBorderStyle)ppnLineParam[ nXclLine ][ 3 ] );
     return true;
 }
 
diff --git sc/source/filter/html/htmlexp.cxx sc/source/filter/html/htmlexp.cxx
index 1dbea16..9889f74 100644
--- sc/source/filter/html/htmlexp.cxx
+++ sc/source/filter/html/htmlexp.cxx
@@ -528,7 +528,14 @@ void ScHTMLExport::BorderToStyle( ByteString& rOut, const char* pBorderName,
         // thickness
         int nWidth = pLine->GetOutWidth();
         int nPxWidth = ( nWidth > 0 )? std::max( int( nWidth / TWIPS_PER_PIXEL ), 1 ): 0;
-        (rOut += ByteString::CreateFromInt32( nPxWidth )) += "px solid #";
+        (rOut += ByteString::CreateFromInt32( nPxWidth )) += "px ";
+        switch ( pLine->GetStyle() )
+        {
+            case DOTTED:    rOut += "dotted"; break;
+            case DASHED:    rOut += "dashed"; break;
+            default:        rOut += "solid";
+        }
+        rOut += " #";
 
         // color
         char hex[7];
diff --git sc/source/filter/inc/xlstyle.hxx sc/source/filter/inc/xlstyle.hxx
index 6216165..0b98a8c 100644
--- sc/source/filter/inc/xlstyle.hxx
+++ sc/source/filter/inc/xlstyle.hxx
@@ -48,9 +48,12 @@ class XclRoot;
 const sal_uInt8 EXC_LINE_NONE               = 0x00;
 const sal_uInt8 EXC_LINE_THIN               = 0x01;
 const sal_uInt8 EXC_LINE_MEDIUM             = 0x02;
+const sal_uInt8 EXC_LINE_DASHED             = 0x03;
+const sal_uInt8 EXC_LINE_DOTTED             = 0x04;
 const sal_uInt8 EXC_LINE_THICK              = 0x05;
 const sal_uInt8 EXC_LINE_DOUBLE             = 0x06;
 const sal_uInt8 EXC_LINE_HAIR               = 0x07;
+const sal_uInt8 EXC_LINE_MEDIUMDASHED       = 0x08;
 
 // Background patterns --------------------------------------------------------
 
diff --git sc/source/filter/xml/xmlstyle.cxx sc/source/filter/xml/xmlstyle.cxx
index e8aee25..c4f552c 100644
--- sc/source/filter/xml/xmlstyle.cxx
+++ sc/source/filter/xml/xmlstyle.cxx
@@ -54,6 +54,7 @@
 #include <com/sun/star/table/CellHoriJustify.hpp>
 #include <com/sun/star/table/CellJustifyMethod.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/sheet/XSheetConditionalEntries.hpp>
 #include <com/sun/star/sheet/XSheetConditionalEntry.hpp>
 #include <com/sun/star/sheet/XSheetCondition.hpp>
@@ -323,7 +324,7 @@ void ScXMLCellExportPropertyMapper::ContextFilter(
     {
         if( pBorder_Left && pBorder_Right && pBorder_Top && pBorder_Bottom )
         {
-            table::BorderLine aLeft, aRight, aTop, aBottom;
+            table::BorderLine2 aLeft, aRight, aTop, aBottom;
 
             pBorder_Left->maValue >>= aLeft;
             pBorder_Right->maValue >>= aRight;
@@ -334,7 +335,9 @@ void ScXMLCellExportPropertyMapper::ContextFilter(
                 aLeft.Color == aTop.Color && aLeft.InnerLineWidth == aTop.InnerLineWidth &&
                 aLeft.OuterLineWidth == aTop.OuterLineWidth && aLeft.LineDistance == aTop.LineDistance &&
                 aLeft.Color == aBottom.Color && aLeft.InnerLineWidth == aBottom.InnerLineWidth &&
-                aLeft.OuterLineWidth == aBottom.OuterLineWidth && aLeft.LineDistance == aBottom.LineDistance )
+                aLeft.OuterLineWidth == aBottom.OuterLineWidth && aLeft.LineDistance == aBottom.LineDistance &&
+                aLeft.LineStyle == aRight.LineStyle && aLeft.LineStyle == aTop.LineStyle && 
+                aLeft.LineStyle == aBottom.LineStyle )
             {
                 pBorder_Left->mnIndex = -1;
                 pBorder_Left->maValue.clear();
@@ -361,7 +364,7 @@ void ScXMLCellExportPropertyMapper::ContextFilter(
     {
         if( pLeftBorderWidthState && pRightBorderWidthState && pTopBorderWidthState && pBottomBorderWidthState )
         {
-            table::BorderLine aLeft, aRight, aTop, aBottom;
+            table::BorderLine2 aLeft, aRight, aTop, aBottom;
 
             pLeftBorderWidthState->maValue >>= aLeft;
             pRightBorderWidthState->maValue >>= aRight;
diff --git sc/source/filter/xml/xmlstyli.cxx sc/source/filter/xml/xmlstyli.cxx
index 2e9a668..8e4ba9a 100644
--- sc/source/filter/xml/xmlstyli.cxx
+++ sc/source/filter/xml/xmlstyli.cxx
@@ -40,7 +40,7 @@
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/sheet/XSheetConditionalEntries.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <comphelper/extract.hxx>
 #include <xmloff/xmlprcon.hxx>
 #include <xmloff/xmluconv.hxx>
@@ -167,15 +167,16 @@ void ScXMLCellImportPropertyMapper::finished(::std::vector< XMLPropertyState >&
             pBorderWidths[i]->mnIndex = -1;
         if( pBorders[i] )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pBorders[i]->maValue >>= aBorderLine;
              if( pBorderWidths[i] )
             {
-                table::BorderLine aBorderLineWidth;
+                table::BorderLine2 aBorderLineWidth;
                 pBorderWidths[i]->maValue >>= aBorderLineWidth;
                 aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
                 aBorderLine.InnerLineWidth = aBorderLineWidth.InnerLineWidth;
                 aBorderLine.LineDistance = aBorderLineWidth.LineDistance;
+                aBorderLine.LineStyle = aBorderLineWidth.LineStyle;
                 pBorders[i]->maValue <<= aBorderLine;
             }
         }
@@ -184,9 +185,9 @@ void ScXMLCellImportPropertyMapper::finished(::std::vector< XMLPropertyState >&
     {
         if( pDiagBorders[i] && ( pDiagBorderWidths[i] || pOldDiagBorderWidths[i] ) )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pDiagBorders[i]->maValue >>= aBorderLine;
-            table::BorderLine aBorderLineWidth;
+            table::BorderLine2 aBorderLineWidth;
             if (pDiagBorderWidths[i])
                 pDiagBorderWidths[i]->maValue >>= aBorderLineWidth;     // prefer new attribute
             else
@@ -194,6 +195,7 @@ void ScXMLCellImportPropertyMapper::finished(::std::vector< XMLPropertyState >&
             aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
             aBorderLine.InnerLineWidth = aBorderLineWidth.InnerLineWidth;
             aBorderLine.LineDistance = aBorderLineWidth.LineDistance;
+            aBorderLine.LineStyle = aBorderLineWidth.LineStyle;
             pDiagBorders[i]->maValue <<= aBorderLine;
             if (pDiagBorderWidths[i])
                 pDiagBorderWidths[i]->mnIndex = -1;
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index 4a0cc63..e38c9ac 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -60,6 +60,7 @@
 #include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/ShadowFormat.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/sheet/CellFlags.hpp>
 #include <com/sun/star/sheet/FormulaResult.hpp>
 #include <com/sun/star/beans/PropertyAttribute.hpp>
@@ -161,7 +162,7 @@ const SfxItemPropertySet* lcl_GetCellsPropertySet()
     {
         {MAP_CHAR_LEN(SC_UNONAME_ABSNAME),	SC_WID_UNO_ABSNAME,	&getCppuType((rtl::OUString*)0),		0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ASIANVERT),ATTR_VERTICAL_ASIAN,&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLBACK),	ATTR_BACKGROUND,	&getCppuType((sal_Int32*)0),			0, MID_BACK_COLOR },
         {MAP_CHAR_LEN(SC_UNONAME_CELLPRO),	ATTR_PROTECTION,	&getCppuType((util::CellProtection*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLSTYL),	SC_WID_UNO_CELLSTYL,&getCppuType((rtl::OUString*)0),		0, 0 },
@@ -212,13 +213,13 @@ const SfxItemPropertySet* lcl_GetCellsPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_CONDFMT),	SC_WID_UNO_CONDFMT,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDLOC),	SC_WID_UNO_CONDLOC,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDXML),	SC_WID_UNO_CONDXML,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_NUMFMT),	ATTR_VALUE_FORMAT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_NUMRULES),	SC_WID_UNO_NUMRULES,&getCppuType((const uno::Reference<container::XIndexReplace>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLORI),  ATTR_STACKED,       &getCppuType((table::CellOrientation*)0), 0, 0 },
@@ -233,13 +234,13 @@ const SfxItemPropertySet* lcl_GetCellsPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PLMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_L_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PRMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_R_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, TOP_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
@@ -262,7 +263,7 @@ const SfxItemPropertySet* lcl_GetRangePropertySet()
     {
         {MAP_CHAR_LEN(SC_UNONAME_ABSNAME),	SC_WID_UNO_ABSNAME,	&getCppuType((rtl::OUString*)0),		0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ASIANVERT),ATTR_VERTICAL_ASIAN,&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLBACK),	ATTR_BACKGROUND,	&getCppuType((sal_Int32*)0),			0, MID_BACK_COLOR },
         {MAP_CHAR_LEN(SC_UNONAME_CELLPRO),	ATTR_PROTECTION,	&getCppuType((util::CellProtection*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLSTYL),	SC_WID_UNO_CELLSTYL,&getCppuType((rtl::OUString*)0),		0, 0 },
@@ -313,13 +314,13 @@ const SfxItemPropertySet* lcl_GetRangePropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_CONDFMT),	SC_WID_UNO_CONDFMT,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDLOC),	SC_WID_UNO_CONDLOC,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDXML),	SC_WID_UNO_CONDXML,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0),	0, MID_HORJUST_HORJUST },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_NUMFMT),	ATTR_VALUE_FORMAT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_NUMRULES),	SC_WID_UNO_NUMRULES,&getCppuType((const uno::Reference<container::XIndexReplace>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLORI),  ATTR_STACKED,       &getCppuType((table::CellOrientation*)0), 0, 0 },
@@ -335,14 +336,14 @@ const SfxItemPropertySet* lcl_GetRangePropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PRMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_R_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, TOP_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
@@ -365,7 +366,7 @@ const SfxItemPropertySet* lcl_GetCellPropertySet()
     {
         {MAP_CHAR_LEN(SC_UNONAME_ABSNAME),	SC_WID_UNO_ABSNAME,	&getCppuType((rtl::OUString*)0),		0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ASIANVERT),ATTR_VERTICAL_ASIAN,&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLBACK),	ATTR_BACKGROUND,	&getCppuType((sal_Int32*)0),			0, MID_BACK_COLOR },
         {MAP_CHAR_LEN(SC_UNONAME_CELLPRO),	ATTR_PROTECTION,	&getCppuType((util::CellProtection*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLSTYL),	SC_WID_UNO_CELLSTYL,&getCppuType((rtl::OUString*)0),		0, 0 },
@@ -416,15 +417,15 @@ const SfxItemPropertySet* lcl_GetCellPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_CONDFMT),	SC_WID_UNO_CONDFMT,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDLOC),	SC_WID_UNO_CONDLOC,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDXML),	SC_WID_UNO_CONDXML,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_FORMLOC),	SC_WID_UNO_FORMLOC,	&getCppuType((rtl::OUString*)0),		0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_FORMRT),	SC_WID_UNO_FORMRT,	&getCppuType((table::CellContentType*)0), 0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_NUMFMT),	ATTR_VALUE_FORMAT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_NUMRULES),	SC_WID_UNO_NUMRULES,&getCppuType((const uno::Reference<container::XIndexReplace>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLORI),  ATTR_STACKED,       &getCppuType((table::CellOrientation*)0), 0, 0 },
@@ -440,14 +441,14 @@ const SfxItemPropertySet* lcl_GetCellPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PRMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_R_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, TOP_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
@@ -470,7 +471,7 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
     {
         {MAP_CHAR_LEN(SC_UNONAME_ABSNAME),	SC_WID_UNO_ABSNAME,	&getCppuType((rtl::OUString*)0),		0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ASIANVERT),ATTR_VERTICAL_ASIAN,&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLBACK),	ATTR_BACKGROUND,	&getCppuType((sal_Int32*)0),			0, MID_BACK_COLOR },
         {MAP_CHAR_LEN(SC_UNONAME_CELLPRO),	ATTR_PROTECTION,	&getCppuType((util::CellProtection*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLSTYL),	SC_WID_UNO_CELLSTYL,&getCppuType((rtl::OUString*)0),		0, 0 },
@@ -521,8 +522,8 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_CONDFMT),	SC_WID_UNO_CONDFMT,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDLOC),	SC_WID_UNO_CONDLOC,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDXML),	SC_WID_UNO_CONDXML,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
@@ -531,7 +532,7 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_NEWPAGE),	SC_WID_UNO_NEWPAGE,	&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLVIS),	SC_WID_UNO_CELLVIS,	&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_NUMFMT),	ATTR_VALUE_FORMAT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_NUMRULES),	SC_WID_UNO_NUMRULES,&getCppuType((const uno::Reference<container::XIndexReplace>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_OWIDTH),	SC_WID_UNO_OWIDTH,	&getBooleanCppuType(),					0, 0 },
@@ -548,14 +549,14 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PRMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_R_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, TOP_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
@@ -576,7 +577,7 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
     {
         {MAP_CHAR_LEN(SC_UNONAME_ABSNAME),	SC_WID_UNO_ABSNAME,	&getCppuType((rtl::OUString*)0),		0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ASIANVERT),ATTR_VERTICAL_ASIAN,&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLBACK),	ATTR_BACKGROUND,	&getCppuType((sal_Int32*)0),			0, MID_BACK_COLOR },
         {MAP_CHAR_LEN(SC_UNONAME_CELLPRO),	ATTR_PROTECTION,	&getCppuType((util::CellProtection*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLSTYL),	SC_WID_UNO_CELLSTYL,&getCppuType((rtl::OUString*)0),		0, 0 },
@@ -627,8 +628,8 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_CONDFMT),	SC_WID_UNO_CONDFMT,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDLOC),	SC_WID_UNO_CONDLOC,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CONDXML),	SC_WID_UNO_CONDXML,	&getCppuType((uno::Reference<sheet::XSheetConditionalEntries>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHGT),	SC_WID_UNO_CELLHGT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
@@ -638,7 +639,7 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_NEWPAGE),	SC_WID_UNO_NEWPAGE,	&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLVIS),	SC_WID_UNO_CELLVIS,	&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_NUMFMT),	ATTR_VALUE_FORMAT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_NUMRULES),	SC_WID_UNO_NUMRULES,&getCppuType((const uno::Reference<container::XIndexReplace>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_OHEIGHT),	SC_WID_UNO_OHEIGHT,	&getBooleanCppuType(),					0, 0 },
@@ -655,14 +656,14 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PRMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_R_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, TOP_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
@@ -684,7 +685,7 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_ASIANVERT),ATTR_VERTICAL_ASIAN,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_AUTOPRINT),SC_WID_UNO_AUTOPRINT,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_BORDCOL),  SC_WID_UNO_BORDCOL, &getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_BOTTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, BOTTOM_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLBACK),	ATTR_BACKGROUND,	&getCppuType((sal_Int32*)0),			0, MID_BACK_COLOR },
         {MAP_CHAR_LEN(SC_UNONAME_CELLPRO),	ATTR_PROTECTION,	&getCppuType((util::CellProtection*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLSTYL),	SC_WID_UNO_CELLSTYL,&getCppuType((rtl::OUString*)0),		0, 0 },
@@ -738,15 +739,15 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_COPYBACK),	SC_WID_UNO_COPYBACK,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_COPYFORM),	SC_WID_UNO_COPYFORM,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_COPYSTYL),	SC_WID_UNO_COPYSTYL,&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
-        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine2*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ISACTIVE),	SC_WID_UNO_ISACTIVE,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLVIS),	SC_WID_UNO_CELLVIS,	&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNO_LINKDISPBIT),	SC_WID_UNO_LINKDISPBIT,&getCppuType((uno::Reference<awt::XBitmap>*)0), 0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNO_LINKDISPNAME),	SC_WID_UNO_LINKDISPNAME,&getCppuType((rtl::OUString*)0),	0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_NUMFMT),	ATTR_VALUE_FORMAT,	&getCppuType((sal_Int32*)0),			0, 0 },
@@ -767,7 +768,7 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_PRINTBORD),SC_WID_UNO_PRINTBORD,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_PROTECT),  SC_WID_UNO_PROTECT,	&getBooleanCppuType(),					0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
@@ -776,7 +777,7 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_TABLAYOUT),SC_WID_UNO_TABLAYOUT,&getCppuType((sal_Int16*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, TOP_BORDER | CONVERT_TWIPS },
+        {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine2*)0), 0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
diff --git sc/source/ui/view/formatsh.cxx sc/source/ui/view/formatsh.cxx
index 3d1b430..dbe2cb2 100644
--- sc/source/ui/view/formatsh.cxx
+++ sc/source/ui/view/formatsh.cxx
@@ -1538,6 +1538,7 @@ void ScFormatShell::ExecuteAttr( SfxRequest& rReq )
                             pDefLine->SetOutWidth( pLine->GetOutWidth() );
                             pDefLine->SetInWidth ( pLine->GetInWidth() );
                             pDefLine->SetDistance( pLine->GetDistance() );
+                            pDefLine->SetStyle( pLine->GetStyle( ) );
                             pTabViewShell->SetSelectionFrameLines( pDefLine, FALSE );
                         }
                         else
diff --git sc/source/ui/view/viewfun2.cxx sc/source/ui/view/viewfun2.cxx
index 0b19e69..c4fb470 100644
--- sc/source/ui/view/viewfun2.cxx
+++ sc/source/ui/view/viewfun2.cxx
@@ -3019,6 +3019,7 @@ void ScViewFunc::UpdateLineAttrs( SvxBorderLine&	   rLine,
             rLine.SetOutWidth	( pDestLine->GetOutWidth() );
             rLine.SetInWidth	( pDestLine->GetInWidth() );
             rLine.SetDistance	( pDestLine->GetDistance() );
+            rLine.SetStyle	    ( pDestLine->GetStyle() );
         }
         else
         {
@@ -3026,6 +3027,7 @@ void ScViewFunc::UpdateLineAttrs( SvxBorderLine&	   rLine,
             rLine.SetOutWidth	( pSrcLine->GetOutWidth() );
             rLine.SetInWidth	( pSrcLine->GetInWidth() );
             rLine.SetDistance	( pSrcLine->GetDistance() );
+            rLine.SetStyle   	( pSrcLine->GetStyle() );
         }
     }
 }
diff --git svtools/inc/borderhelper.hxx svtools/inc/borderhelper.hxx
new file mode 100644
index 0000000..6e9864a
--- /dev/null
+++ svtools/inc/borderhelper.hxx
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: ctrlbox.hxx,v $
+ * $Revision: 1.15 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _BORDERHELPER_HXX
+#define _BORDERHELPER_HXX
+
+#include "svtools/svtdllapi.h"
+
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/polygon/b2dpolygon.hxx>
+#include <vcl/outdev.hxx>
+
+namespace svtools
+{
+    SVT_DLLPUBLIC basegfx::B2DPolyPolygon ApplyLineDashing( const basegfx::B2DPolygon& rPolygon,
+            USHORT nDashing, MapUnit eUnit );
+
+    SVT_DLLPUBLIC void DrawLine( OutputDevice& rDev, const Point& rBeg,
+            const Point& rEnd, sal_uInt32 nWidth, USHORT nDashing );
+}
+
+#endif
diff --git svtools/inc/ctrlbox.hxx svtools/inc/ctrlbox.hxx
index c53e36a..76baa23 100644
--- svtools/inc/ctrlbox.hxx
+++ svtools/inc/ctrlbox.hxx
@@ -54,6 +54,10 @@ class ImpColorList;
 class ImpLineList;
 class FontList;
 
+#define STYLE_SOLID     ( ( USHORT ) 0 )
+#define STYLE_DOTTED    ( ( USHORT ) 1 )
+#define STYLE_DASHED    ( ( USHORT ) 2 )
+
 /*************************************************************************
 
 Beschreibung
@@ -255,7 +259,8 @@ class SVT_DLLPUBLIC LineListBox : public ListBox
     FieldUnit		eUnit;
     FieldUnit		eSourceUnit;
 
-    SVT_DLLPRIVATE void			ImpGetLine( long nLine1, long nLine2, long nDistance, Bitmap& rBmp, XubString& rStr );
+    SVT_DLLPRIVATE void			ImpGetLine( long nLine1, long nLine2, long nDistance,
+                                    USHORT nStyle, Bitmap& rBmp, XubString& rStr );
     using Window::ImplInit;
     SVT_DLLPRIVATE void			ImplInit();
     void			UpdateLineColors( void );
@@ -270,24 +275,30 @@ public:
 
     using ListBox::InsertEntry;
     virtual USHORT	InsertEntry( const XubString& rStr, USHORT nPos = LISTBOX_APPEND );
-    virtual USHORT	InsertEntry( long nLine1, long nLine2 = 0, long nDistance = 0, USHORT nPos = LISTBOX_APPEND );
+    virtual USHORT	InsertEntry( long nLine1, long nLine2 = 0, long nDistance = 0,
+                                USHORT nStyle = STYLE_SOLID, USHORT nPos = LISTBOX_APPEND );
     using ListBox::RemoveEntry;
     virtual void	RemoveEntry( USHORT nPos );
     virtual void	Clear();
 
     using ListBox::GetEntryPos;
-    USHORT			GetEntryPos( long nLine1, long nLine2 = 0, long nDistance = 0 ) const;
+    USHORT			GetEntryPos( long nLine1, long nLine2 = 0, long nDistance = 0,
+                                 USHORT nStyle = STYLE_SOLID ) const;
     long			GetEntryLine1( USHORT nPos ) const;
     long			GetEntryLine2( USHORT nPos ) const;
     long			GetEntryDistance( USHORT nPos ) const;
+    USHORT          GetEntryStyle( USHORT nPos ) const;
 
     inline void		SelectEntry( const XubString& rStr, BOOL bSelect = TRUE ) { ListBox::SelectEntry( rStr, bSelect ); }
-    void			SelectEntry( long nLine1, long nLine2 = 0, long nDistance = 0, BOOL bSelect = TRUE );
+    void			SelectEntry( long nLine1, long nLine2 = 0, long nDistance = 0,
+                                 USHORT nStyle = STYLE_SOLID, BOOL bSelect = TRUE );
     long			GetSelectEntryLine1( USHORT nSelIndex = 0 ) const;
     long			GetSelectEntryLine2( USHORT nSelIndex = 0 ) const;
     long			GetSelectEntryDistance( USHORT nSelIndex = 0 ) const;
+    USHORT  		GetSelectEntryStyle( USHORT nSelIndex = 0 ) const;
     inline BOOL		IsEntrySelected( const XubString& rStr ) const { return ListBox::IsEntrySelected( rStr ); }
-    BOOL			IsEntrySelected( long nLine1, long nLine2 = 0, long nDistance = 0 ) const;
+    BOOL			IsEntrySelected( long nLine1, long nLine2 = 0, long nDistance = 0,
+                                     USHORT nStyle1 = STYLE_SOLID ) const;
 
     inline void		SetUnit( FieldUnit eNewUnit ) { eUnit = eNewUnit; }
     inline FieldUnit	GetUnit() const { return eUnit; }
@@ -305,9 +316,9 @@ private:
     void*			GetEntryData( USHORT nPos ) const;
 };
 
-inline void LineListBox::SelectEntry( long nLine1, long nLine2, long nDistance, BOOL bSelect )
+inline void LineListBox::SelectEntry( long nLine1, long nLine2, long nDistance, USHORT nStyle, BOOL bSelect )
 {
-    USHORT nPos = GetEntryPos( nLine1, nLine2, nDistance );
+    USHORT nPos = GetEntryPos( nLine1, nLine2, nDistance, nStyle );
     if ( nPos != LISTBOX_ENTRY_NOTFOUND )
         ListBox::SelectEntryPos( nPos, bSelect );
 }
@@ -339,9 +350,19 @@ inline long LineListBox::GetSelectEntryDistance( USHORT nSelIndex ) const
         return 0;
 }
 
-inline BOOL LineListBox::IsEntrySelected( long nLine1, long nLine2, long nDistance ) const
+inline USHORT LineListBox::GetSelectEntryStyle( USHORT nSelIndex ) const
+{
+    USHORT nStyle = STYLE_SOLID;
+    USHORT nPos = GetSelectEntryPos( nSelIndex );
+    if ( nPos != LISTBOX_ENTRY_NOTFOUND )
+        nStyle = GetEntryStyle( nPos );
+
+    return nStyle;
+}
+
+inline BOOL LineListBox::IsEntrySelected( long nLine1, long nLine2, long nDistance, USHORT nStyle ) const
 {
-    USHORT nPos = GetEntryPos( nLine1, nLine2, nDistance );
+    USHORT nPos = GetEntryPos( nLine1, nLine2, nDistance, nStyle );
     if ( nPos != LISTBOX_ENTRY_NOTFOUND )
         return IsEntryPosSelected( nPos );
     else
diff --git svtools/inc/rtfkeywd.hxx svtools/inc/rtfkeywd.hxx
index 7fd5f41..a8a4490 100644
--- svtools/inc/rtfkeywd.hxx
+++ svtools/inc/rtfkeywd.hxx
@@ -70,6 +70,8 @@
 #define OOO_STRING_SVTOOLS_RTF_BRDRCF "\\brdrcf"
 #define OOO_STRING_SVTOOLS_RTF_BRDRDB "\\brdrdb"
 #define OOO_STRING_SVTOOLS_RTF_BRDRDOT "\\brdrdot"
+#define OOO_STRING_SVTOOLS_RTF_BRDRDASH "\\brdrdash"
+#define OOO_STRING_SVTOOLS_RTF_BRDRDASHSM "\\brdrdashsm"
 #define OOO_STRING_SVTOOLS_RTF_BRDRHAIR "\\brdrhair"
 #define OOO_STRING_SVTOOLS_RTF_BRDRL "\\brdrl"
 #define OOO_STRING_SVTOOLS_RTF_BRDRR "\\brdrr"
diff --git svtools/source/control/ctrlbox.cxx svtools/source/control/ctrlbox.cxx
index d66ee9b..e4fe718 100755
--- svtools/source/control/ctrlbox.cxx
+++ svtools/source/control/ctrlbox.cxx
@@ -43,8 +43,11 @@
 #include <svtools/svtools.hrc>
 #include <ctrlbox.hxx>
 #include <ctrltool.hxx>
+#include <borderhelper.hxx>
 
 #include <vcl/i18nhelp.hxx>
+#include <basegfx/polygon/b2dpolygon.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
 
 #define IMGTEXTSPACE    2
 #define EXTRAFONTSIZE   5
@@ -252,6 +255,7 @@ struct ImpLineListData
     long    nLine1;
     long    nLine2;
     long    nDistance;
+    USHORT  nStyle;
 };
 
 DECLARE_LIST( ImpLineList, ImpLineListData* )
@@ -265,8 +269,107 @@ inline const Color& LineListBox::GetPaintColor( void ) const
 
 // -----------------------------------------------------------------------
 
+
+inline void lclDrawPolygon( OutputDevice& rDev, const basegfx::B2DPolygon& rPolygon, long nWidth, USHORT nDashing )
+{
+    USHORT nOldAA = rDev.GetAntialiasing();
+    rDev.SetAntialiasing( nOldAA & !ANTIALIASING_ENABLE_B2DDRAW );
+
+    Color aOldColor = rDev.GetFillColor( );
+    rDev.SetFillColor( rDev.GetLineColor( ) );
+
+    basegfx::B2DPolyPolygon aPolygons = svtools::ApplyLineDashing( rPolygon, nDashing, rDev.GetMapMode().GetMapUnit() );
+    for ( sal_uInt32 i = 0; i < aPolygons.count( ); i++ )
+    {
+        basegfx::B2DPolygon aDash = aPolygons.getB2DPolygon( i );
+        basegfx::B2DPoint aStart = aDash.getB2DPoint( 0 );
+        basegfx::B2DPoint aEnd = aDash.getB2DPoint( aDash.count() - 1 );
+
+        basegfx::B2DVector aVector( aEnd - aStart );
+        aVector.normalize( );
+        const basegfx::B2DVector aPerpendicular(basegfx::getPerpendicular(aVector));
+
+        const basegfx::B2DVector aWidthOffset( nWidth / 2 * aPerpendicular);
+        basegfx::B2DPolygon aDashPolygon;
+        aDashPolygon.append( aStart + aWidthOffset );
+        aDashPolygon.append( aEnd + aWidthOffset );
+        aDashPolygon.append( aEnd - aWidthOffset );
+        aDashPolygon.append( aStart - aWidthOffset );
+        aDashPolygon.setClosed( true );
+
+        rDev.DrawPolygon( aDashPolygon );
+    }
+
+    rDev.SetFillColor( aOldColor );
+    rDev.SetAntialiasing( nOldAA );
+}
+
+namespace svtools
+{
+    basegfx::B2DPolyPolygon ApplyLineDashing( const basegfx::B2DPolygon& rPolygon, USHORT nDashing, MapUnit eUnit )
+    {
+        ::std::vector < double >aPattern;
+        switch ( nDashing )
+        {
+            case STYLE_DOTTED:
+                if ( eUnit == MAP_TWIP )
+                {
+                    aPattern.push_back( 30.0 );
+                    aPattern.push_back( 110.0 );
+                }
+                else if ( eUnit == MAP_100TH_MM )
+                {
+                    aPattern.push_back( 50 );
+                    aPattern.push_back( 200 );
+                }
+                else if ( eUnit == MAP_PIXEL )
+                {
+                    aPattern.push_back( 1.0 );
+                    aPattern.push_back( 3.0 );
+                }
+                break;
+            case STYLE_DASHED:
+                if ( eUnit == MAP_TWIP )
+                {
+                    aPattern.push_back( 110 );
+                    aPattern.push_back( 110 );
+                }
+                else if ( eUnit == MAP_100TH_MM )
+                {
+                    aPattern.push_back( 200 );
+                    aPattern.push_back( 200 );
+                }
+                else if ( eUnit == MAP_PIXEL )
+                {
+                    aPattern.push_back( 10 );
+                    aPattern.push_back( 20 );
+                }
+                break;
+            default:
+                break;
+        }
+
+        basegfx::B2DPolyPolygon aPolygons;
+        if ( ! aPattern.empty() )
+            basegfx::tools::applyLineDashing( rPolygon, aPattern, &aPolygons );
+        else
+            aPolygons.append( rPolygon );
+
+        return aPolygons;
+    }
+
+    void DrawLine( OutputDevice& rDev, const Point& rP1, const Point& rP2,
+        sal_uInt32 nWidth, USHORT nDashing )
+    {
+        basegfx::B2DPolygon aPolygon;
+        aPolygon.append( basegfx::B2DPoint( rP1.X(), rP1.Y() ) );
+        aPolygon.append( basegfx::B2DPoint( rP2.X(), rP2.Y() ) );
+        lclDrawPolygon( rDev, aPolygon, nWidth, nDashing );
+    }
+}
+
 void LineListBox::ImpGetLine( long nLine1, long nLine2, long nDistance,
-                            Bitmap& rBmp, XubString& rStr )
+                            USHORT nStyle, Bitmap& rBmp, XubString& rStr )
 {
     Size aSize = GetOutputSizePixel();
     aSize.Width() -= 20;
@@ -293,8 +396,8 @@ void LineListBox::ImpGetLine( long nLine1, long nLine2, long nDistance,
     // Linien malen
     aSize = aVirDev.PixelToLogic( aSize );
     long nPix = aVirDev.PixelToLogic( Size( 0, 1 ) ).Height();
-    long n1 = nLine1 / 100;
-    long n2 = nLine2 / 100;
+    sal_uInt32 n1 = nLine1 / 100;
+    sal_uInt32 n2 = nLine2 / 100;
     long nDist  = nDistance / 100;
     n1 += nPix-1;
     n1 -= n1%nPix;
@@ -317,13 +420,18 @@ void LineListBox::ImpGetLine( long nLine1, long nLine2, long nDistance,
         aVirDev.SetFillColor( GetSettings().GetStyleSettings().GetFieldColor() );
         aVirDev.DrawRect( Rectangle( Point(), aSize ) );
 
-        aVirDev.SetFillColor( GetPaintColor() );
-        aVirDev.DrawRect( Rectangle( 0, 0, aSize.Width(), n1-nPix ) );
+        Color oldColor = aVirDev.GetLineColor( );
+        aVirDev.SetLineColor( GetPaintColor( ) );
+
+        double y1 = n1 / 2;
+        svtools::DrawLine( aVirDev, Point( 0, y1 ), Point( aSize.Width( ), y1 ), n1, nStyle );
+
         if ( n2 )
         {
-            aVirDev.DrawRect( Rectangle( 0, n1+nDist,
-                                         aSize.Width(), n1+nDist+n2-nPix ) );
+            double y2 =  n1 + nDist + n2 / 2;
+            svtools::DrawLine( aVirDev, Point( 0, y2 ), Point( aSize.Width(), y2 ), n2, STYLE_SOLID );
         }
+        aVirDev.SetLineColor( oldColor );
         rBmp = aVirDev.GetBitmap( Point(), Size( aSize.Width(), n1+nDist+n2 ) );
     }
     // Twips nach Unit
@@ -414,11 +522,11 @@ USHORT LineListBox::InsertEntry( const XubString& rStr, USHORT nPos )
 // -----------------------------------------------------------------------
 
 USHORT LineListBox::InsertEntry( long nLine1, long nLine2, long nDistance,
-                                USHORT nPos )
+                                USHORT nStyle, USHORT nPos )
 {
     XubString   aStr;
     Bitmap      aBmp;
-    ImpGetLine( nLine1, nLine2, nDistance, aBmp, aStr );
+    ImpGetLine( nLine1, nLine2, nDistance, nStyle, aBmp, aStr );
     nPos = ListBox::InsertEntry( aStr, aBmp, nPos );
     if ( nPos != LISTBOX_ERROR )
     {
@@ -426,6 +534,7 @@ USHORT LineListBox::InsertEntry( long nLine1, long nLine2, long nDistance,
         pData->nLine1    = nLine1;
         pData->nLine2    = nLine2;
         pData->nDistance = nDistance;
+        pData->nStyle    = nStyle;
         pLineList->Insert( pData, nPos );
     }
 
@@ -463,7 +572,7 @@ void LineListBox::Clear()
 // -----------------------------------------------------------------------
 
 USHORT LineListBox::GetEntryPos( long nLine1, long nLine2,
-                                long nDistance ) const
+                                long nDistance, USHORT nStyle ) const
 {
     ULONG n = 0;
     ULONG nCount = pLineList->Count();
@@ -474,7 +583,8 @@ USHORT LineListBox::GetEntryPos( long nLine1, long nLine2,
         {
             if ( (pData->nLine1    == nLine1) &&
                 (pData->nLine2    == nLine2) &&
-                (pData->nDistance == nDistance) )
+                (pData->nDistance == nDistance) &&
+                (pData->nStyle == nStyle) )
             return (USHORT)n;
         }
 
@@ -519,6 +629,18 @@ long LineListBox::GetEntryDistance( USHORT nPos ) const
 
 // -----------------------------------------------------------------------
 
+USHORT LineListBox::GetEntryStyle( USHORT nPos ) const
+{
+    USHORT nStyle = STYLE_SOLID;
+    ImpLineListData* pData = pLineList->GetObject( nPos );
+    if ( pData )
+        nStyle = pData->nStyle;
+
+    return nStyle;
+}
+
+// -----------------------------------------------------------------------
+
 void LineListBox::UpdateLineColors( void )
 {
     if( UpdatePaintLineColor() )
@@ -541,7 +663,8 @@ void LineListBox::UpdateLineColors( void )
             {
                 // exchange listbox data
                 ListBox::RemoveEntry( USHORT( n ) );
-                ImpGetLine( pData->nLine1, pData->nLine2, pData->nDistance, aBmp, aStr );
+                ImpGetLine( pData->nLine1, pData->nLine2, pData->nDistance,
+                        pData->nStyle, aBmp, aStr );
                 ListBox::InsertEntry( aStr, aBmp, USHORT( n ) );
             }
         }
diff --git svtools/util/makefile.mk svtools/util/makefile.mk
index f9c14a5..1eb74c9 100644
--- svtools/util/makefile.mk
+++ svtools/util/makefile.mk
@@ -123,7 +123,8 @@ SHL1STDLIBS+= \
         $(VOSLIB)			\
         $(SALLIB)			\
         $(ICUUCLIB)		\
-        $(JVMFWKLIB)
+        $(JVMFWKLIB) \
+        $(BASEGFXLIB)
 
 .IF "$(OS)"=="MACOSX"
 # static libraries go at end
diff --git svx/inc/svx/framelink.hxx svx/inc/svx/framelink.hxx
index 660fd17..747b6eb 100644
--- svx/inc/svx/framelink.hxx
+++ svx/inc/svx/framelink.hxx
@@ -33,9 +33,10 @@
 #include <tools/gen.hxx>
 #include <tools/color.hxx>
 #include "svx/svxdllapi.h"
+#include <vcl/outdev.hxx>
+#include <editeng/borderline.hxx>
 
 class OutputDevice;
-class SvxBorderLine;
 
 namespace svx {
 namespace frame {
@@ -112,20 +113,20 @@ class SVX_DLLPUBLIC Style
 {
 public:
     /** Constructs an invisible frame style. */
-    inline explicit     Style() : meRefMode( REFMODE_CENTERED ), mnPrim( 0 ), mnDist( 0 ), mnSecn( 0 ), mbDotted( false ) {}
+    inline explicit     Style() : meRefMode( REFMODE_CENTERED ), mnPrim( 0 ), mnDist( 0 ), mnSecn( 0 ), mnDashing( SOLID ) {}
     /** Constructs a frame style with passed line widths. */
     inline explicit     Style( sal_uInt16 nP, sal_uInt16 nD, sal_uInt16 nS ) :
-                            meRefMode( REFMODE_CENTERED ), mbDotted( false )
+                            meRefMode( REFMODE_CENTERED ), mnDashing( SOLID )
                             { Set( nP, nD, nS ); }
     /** Constructs a frame style with passed color and line widths. */
-    inline explicit     Style( const Color& rColor, sal_uInt16 nP, sal_uInt16 nD, sal_uInt16 nS ) :
-                            meRefMode( REFMODE_CENTERED ), mbDotted( false )
+    inline explicit     Style( const Color& rColor, sal_uInt16 nP, sal_uInt16 nD, sal_uInt16 nS, SvxBorderStyle nDashing = SOLID ) :
+                            meRefMode( REFMODE_CENTERED ), mnDashing( nDashing )
                             { Set( rColor, nP, nD, nS ); }
     /** Constructs a frame style from the passed SvxBorderLine struct. */
-    inline explicit     Style( const SvxBorderLine& rBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16, bool /*bUseDots*/ = false ) :
+    inline explicit     Style( const SvxBorderLine& rBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16 ) :
                             meRefMode( REFMODE_CENTERED ) { Set( rBorder, fScale, nMaxWidth ); }
     /** Constructs a frame style from the passed SvxBorderLine struct. Clears the style, if pBorder is 0. */
-    inline explicit     Style( const SvxBorderLine* pBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16, bool /*bUseDots*/ = false ) :
+    inline explicit     Style( const SvxBorderLine* pBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16 ) :
                             meRefMode( REFMODE_CENTERED ) { Set( pBorder, fScale, nMaxWidth ); }
 
     inline RefMode      GetRefMode() const { return meRefMode; }
@@ -133,7 +134,7 @@ public:
     inline sal_uInt16   Prim() const { return mnPrim; }
     inline sal_uInt16   Dist() const { return mnDist; }
     inline sal_uInt16   Secn() const { return mnSecn; }
-    inline bool         Dotted() const { return mbDotted; }
+    inline SvxBorderStyle Dashing() const { return mnDashing; }
 
     /** Returns the total width of this frame style. */
     inline sal_uInt16   GetWidth() const { return mnPrim + mnDist + mnSecn; }
@@ -146,16 +147,16 @@ public:
     /** Sets the frame style to the passed line widths. */
     void                Set( const Color& rColor, sal_uInt16 nP, sal_uInt16 nD, sal_uInt16 nS );
     /** Sets the frame style to the passed SvxBorderLine struct. */
-    void                Set( const SvxBorderLine& rBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16, bool /*bUseDots*/ = false );
+    void                Set( const SvxBorderLine& rBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16 );
     /** Sets the frame style to the passed SvxBorderLine struct. Clears the style, if pBorder is 0. */
-    void                Set( const SvxBorderLine* pBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16, bool /*bUseDots*/ = false );
+    void                Set( const SvxBorderLine* pBorder, double fScale = 1.0, sal_uInt16 nMaxWidth = SAL_MAX_UINT16 );
 
     /** Sets a new reference point handling mode, does not modify other settings. */
     inline void         SetRefMode( RefMode eRefMode ) { meRefMode = eRefMode; }
     /** Sets a new color, does not modify other settings. */
     inline void         SetColor( const Color& rColor ) { maColor = rColor; }
     /** Sets whether to use dotted style for single hair lines. */
-    inline void         SetDotted( bool bDotted ) { mbDotted = bDotted; }
+    inline void         SetDashing( SvxBorderStyle nDashing ) { mnDashing = nDashing; }
 
     /** Scales the style by the specified scaling factor. Ensures that visible lines keep visible. */
     Style&              ScaleSelf( double fScale, sal_uInt16 nMaxWidth = SAL_MAX_UINT16 );
@@ -173,7 +174,7 @@ private:
     sal_uInt16          mnPrim;     /// Width of primary (single, left, or top) line.
     sal_uInt16          mnDist;     /// Distance between primary and secondary line.
     sal_uInt16          mnSecn;     /// Width of secondary (right or bottom) line.
-    bool                mbDotted;   /// true = Draw dotted lines; false = Draw solid lines.
+    SvxBorderStyle      mnDashing;
 };
 
 bool operator==( const Style& rL, const Style& rR );
diff --git svx/inc/svx/frmsel.hxx svx/inc/svx/frmsel.hxx
index 22100d3..2706640 100644
--- svx/inc/svx/frmsel.hxx
+++ svx/inc/svx/frmsel.hxx
@@ -32,6 +32,7 @@
 #include <tools/color.hxx>
 #include <vcl/ctrl.hxx>
 #include <vcl/bitmap.hxx>
+#include <editeng/borderline.hxx>
 #include <svx/framebordertype.hxx>
 #include "svx/svxdllapi.h"
 
@@ -128,7 +129,8 @@ public:
     /** Returns true, if all visible frame borders have equal widths.
         @descr  Ignores hidden and "don't care" frame borders. On success,
         returns the widths in the passed parameters. */
-    bool                GetVisibleWidth( USHORT& rnPrim, USHORT& rnDist, USHORT& rnSec ) const;
+    bool                GetVisibleWidth( USHORT& rnPrim, USHORT& rnDist, USHORT& rnSec,
+                                         SvxBorderStyle& rnStyle ) const;
     /** Returns true, if all visible frame borders have equal color.
         @descr  Ignores hidden and "don't care" frame borders. On success,
         returns the color in the passed parameter. */
@@ -159,7 +161,8 @@ public:
     void                SelectAllVisibleBorders( bool bSelect = true );
 
     /** Sets the passed line widths to all selected frame borders (in twips). */
-    void                SetStyleToSelection( USHORT nPrim, USHORT nDist, USHORT nSec );
+    void                SetStyleToSelection( USHORT nPrim, USHORT nDist, USHORT nSec,
+                                             SvxBorderStyle nStyle );
     /** Sets the passed color to all selected frame borders. */
     void                SetColorToSelection( const Color& rColor );
 
diff --git svx/source/dialog/framelink.cxx svx/source/dialog/framelink.cxx
index 06fc478..13c7a4f 100644
--- svx/source/dialog/framelink.cxx
+++ svx/source/dialog/framelink.cxx
@@ -32,6 +32,7 @@
 #include <math.h>
 #include <vcl/outdev.hxx>
 #include <editeng/borderline.hxx>
+#include <svtools/borderhelper.hxx>
 
 // ----------------------------------------------------------------------------
 
@@ -48,6 +49,9 @@
 
 #if SVX_FRAME_USE_LINEINFO
 #include <vcl/lineinfo.hxx>
+#else
+#include <basegfx/polygon/b2dpolygon.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
 #endif
 
 namespace svx {
@@ -755,7 +759,7 @@ inline Polygon lclCreatePolygon( const PointVec& rPoints )
 Polygon lclCreatePolygon( const Point& rP1, const Point& rP2, const Point& rP3, const Point& rP4 )
 {
     PointVec aPoints;
-    aPoints.reserve( 4 );
+    aPoints.reserve( 2 );
     aPoints.push_back( rP1 );
     aPoints.push_back( rP2 );
     aPoints.push_back( rP3 );
@@ -776,12 +780,6 @@ Polygon lclCreatePolygon( const Point& rP1, const Point& rP2, const Point& rP3,
     return lclCreatePolygon( aPoints );
 }
 
-/** Returns a polygon constructed from the two passed line positions. */
-inline Polygon lclCreatePolygon( const LinePoints& rPoints1, const LinePoints& rPoints2 )
-{
-    return lclCreatePolygon( rPoints1.maBeg, rPoints1.maEnd, rPoints2.maEnd, rPoints2.maBeg );
-}
-
 /** Sets the color of the passed frame style to the output device.
 
     Sets the line color and fill color in the output device.
@@ -803,73 +801,6 @@ void lclSetColorToOutDev( OutputDevice& rDev, const Style& rStyle, const Color*
 }
 
 // ----------------------------------------------------------------------------
-// Generic drawing functions.
-
-/** Draws a thin (1 pixel wide) line, optionally dotted, into the passed output device. */
-void lclDrawThinLine( OutputDevice& rDev, const Point& rBeg, const Point& rEnd, bool bDotted )
-{
-#if SVX_FRAME_USE_LINEINFO
-    if( bDotted && (rBeg != rEnd) )
-    {
-// using LineInfo for dotted lines looks ugly and does not work well for diagonal lines
-        LineInfo aLineInfo( LINE_DASH, 1 );
-        aLineInfo.SetDotCount( 1 );
-        aLineInfo.SetDotLen( 1 );
-        aLineInfo.SetDistance( 3 );
-        rDev.DrawLine( rBeg, rEnd, aLineInfo );
-    }
-#else
-    Point aBeg( rDev.LogicToPixel( rBeg ) );
-    Point aEnd( rDev.LogicToPixel( rEnd ) );
-    if( bDotted && (aBeg != aEnd) )
-    {
-        bool bHor = Abs( aEnd.X() - aBeg.X() ) > Abs( aEnd.Y() - aBeg.Y() );
-        const Point& rBegPos( bHor ? ((aBeg.X() < aEnd.X()) ? aBeg : aEnd) : ((aBeg.Y() < aEnd.Y()) ? aBeg : aEnd ) );
-        const Point& rEndPos( (rBegPos == aBeg) ? aEnd : aBeg );
-
-        long nAlongBeg = bHor ? rBegPos.X() : rBegPos.Y();
-        long nAcrssBeg = bHor ? rBegPos.Y() : rBegPos.X();
-        long nAlongSize = (bHor ? rEndPos.X() : rEndPos.Y()) - nAlongBeg;
-        long nAcrssSize = (bHor ? rEndPos.Y() : rEndPos.X()) - nAcrssBeg;
-        double fGradient = static_cast< double >( nAcrssSize ) / nAlongSize;
-
-        PointVec aPoints;
-        aPoints.reserve( (nAlongSize + 1) / 2 );
-        for( long nAlongIdx = 0; nAlongIdx <= nAlongSize; nAlongIdx += 2 )
-        {
-            long nAl = nAlongBeg + nAlongIdx;
-            long nAc = nAcrssBeg + lclD2L( fGradient * nAlongIdx );
-            aPoints.push_back( Point( bHor ? nAl : nAc, bHor ? nAc : nAl ) );
-        }
-
-        rDev.Push( PUSH_MAPMODE );
-        rDev.SetMapMode( MAP_PIXEL );
-        rDev.DrawPixel( lclCreatePolygon( aPoints ) );
-        rDev.Pop(); // map mode
-    }
-#endif
-    else
-        rDev.DrawLine( rBeg, rEnd );
-}
-
-/** Draws a thin (1 pixel wide) line, optionally dotted, into the passed output device. */
-inline void lclDrawThinLine( OutputDevice& rDev, const LinePoints& rPoints, bool bDotted )
-{
-    lclDrawThinLine( rDev, rPoints.maBeg, rPoints.maEnd, bDotted );
-}
-
-/** Draws a polygon with four points into the passed output device. */
-inline void lclDrawPolygon( OutputDevice& rDev, const Point& rP1, const Point& rP2, const Point& rP3, const Point& rP4 )
-{
-    rDev.DrawPolygon( lclCreatePolygon( rP1, rP2, rP3, rP4 ) );
-}
-
-/** Draws a polygon specified by two borders into the passed output device. */
-inline void lclDrawPolygon( OutputDevice& rDev, const LinePoints& rPoints1, const LinePoints& rPoints2 )
-{
-    rDev.DrawPolygon( lclCreatePolygon( rPoints1, rPoints2 ) );
-}
-
 // ============================================================================
 // Drawing of horizontal frame borders.
 
@@ -882,16 +813,18 @@ void lclDrawHorLine(
         OutputDevice& rDev,
         const Point& rLPos, const LineEndResult& rLRes,
         const Point& rRPos, const LineEndResult& rRRes,
-        long nTOffs, long nBOffs, bool bDotted )
+        long nTOffs, long nBOffs, SvxBorderStyle nDashing )
 {
     LinePoints aTPoints( rLPos + lclToMapUnit( rLRes.mnOffs1, nTOffs ), rRPos + lclToMapUnit( rRRes.mnOffs1, nTOffs ) );
-    if( nTOffs == nBOffs )
-        lclDrawThinLine( rDev, aTPoints, bDotted );
-    else
-    {
-        LinePoints aBPoints( rLPos + lclToMapUnit( rLRes.mnOffs2, nBOffs ), rRPos + lclToMapUnit( rRRes.mnOffs2, nBOffs ) );
-        lclDrawPolygon( rDev, aTPoints, aBPoints );
-    }
+    LinePoints aBPoints( rLPos + lclToMapUnit( rLRes.mnOffs2, nBOffs ), rRPos + lclToMapUnit( rRRes.mnOffs2, nBOffs ) );
+
+    sal_uInt32 nWidth = lclToMapUnit( abs( nTOffs ) ) + lclToMapUnit( abs( nBOffs ) );
+    if ( ( nTOffs >= 0 && nBOffs >= 0 ) || ( nTOffs <= 0 && nBOffs <= 0 ) )
+        nWidth = abs( lclToMapUnit( nTOffs ) - lclToMapUnit( nBOffs ) ) + 1;
+    Point rLMid = ( aTPoints.maBeg + aBPoints.maBeg ) / 2;
+    Point rRMid = ( aTPoints.maEnd + aBPoints.maEnd ) / 2;
+
+    ::svtools::DrawLine( rDev, rLMid, rRMid, nWidth, nDashing );
 }
 
 /** Draws a horizontal frame border into the passed output device.
@@ -917,10 +850,10 @@ void lclDrawHorFrameBorder(
     {
         lclSetColorToOutDev( rDev, rBorder, pForceColor );
         lclDrawHorLine( rDev, rLPos, rResult.maBeg.maPrim, rRPos, rResult.maEnd.maPrim,
-            lclGetBeg( rBorder ), lclGetPrimEnd( rBorder ), rBorder.Dotted() );
+            lclGetBeg( rBorder ), lclGetPrimEnd( rBorder ), rBorder.Dashing() );
         if( rBorder.Secn() )
             lclDrawHorLine( rDev, rLPos, rResult.maBeg.maSecn, rRPos, rResult.maEnd.maSecn,
-                lclGetSecnBeg( rBorder ), lclGetEnd( rBorder ), rBorder.Dotted() );
+                lclGetSecnBeg( rBorder ), lclGetEnd( rBorder ), rBorder.Dashing() );
         rDev.Pop(); // colors
     }
 }
@@ -937,16 +870,18 @@ void lclDrawVerLine(
         OutputDevice& rDev,
         const Point& rTPos, const LineEndResult& rTRes,
         const Point& rBPos, const LineEndResult& rBRes,
-        long nLOffs, long nROffs, bool bDotted )
+        long nLOffs, long nROffs, SvxBorderStyle nDashing )
 {
     LinePoints aLPoints( rTPos + lclToMapUnit( nLOffs, rTRes.mnOffs1 ), rBPos + lclToMapUnit( nLOffs, rBRes.mnOffs1 ) );
-    if( nLOffs == nROffs )
-        lclDrawThinLine( rDev, aLPoints, bDotted );
-    else
-    {
-        LinePoints aRPoints( rTPos + lclToMapUnit( nROffs, rTRes.mnOffs2 ), rBPos + lclToMapUnit( nROffs, rBRes.mnOffs2 ) );
-        lclDrawPolygon( rDev, aLPoints, aRPoints );
-    }
+    LinePoints aRPoints( rTPos + lclToMapUnit( nROffs, rTRes.mnOffs2 ), rBPos + lclToMapUnit( nROffs, rBRes.mnOffs2 ) );
+
+    sal_uInt32 nWidth = lclToMapUnit( abs( nLOffs ) ) + lclToMapUnit( abs( nROffs ) );
+    if ( ( nLOffs >= 0 && nROffs >= 0 ) || ( nLOffs <= 0 && nROffs <= 0 ) )
+        nWidth = abs( lclToMapUnit( nLOffs ) - lclToMapUnit( nROffs ) ) + 1;
+    Point rTMid = ( aLPoints.maBeg + aRPoints.maBeg ) / 2;
+    Point rBMid = ( aLPoints.maEnd + aRPoints.maEnd ) / 2;
+
+    ::svtools::DrawLine( rDev, rTMid, rBMid, nWidth, nDashing );
 }
 
 /** Draws a vertical frame border into the passed output device.
@@ -972,10 +907,10 @@ void lclDrawVerFrameBorder(
     {
         lclSetColorToOutDev( rDev, rBorder, pForceColor );
         lclDrawVerLine( rDev, rTPos, rResult.maBeg.maPrim, rBPos, rResult.maEnd.maPrim,
-            lclGetBeg( rBorder ), lclGetPrimEnd( rBorder ), rBorder.Dotted() );
+            lclGetBeg( rBorder ), lclGetPrimEnd( rBorder ), rBorder.Dashing() );
         if( rBorder.Secn() )
             lclDrawVerLine( rDev, rTPos, rResult.maBeg.maSecn, rBPos, rResult.maEnd.maSecn,
-                lclGetSecnBeg( rBorder ), lclGetEnd( rBorder ), rBorder.Dotted() );
+                lclGetSecnBeg( rBorder ), lclGetEnd( rBorder ), rBorder.Dashing() );
         rDev.Pop(); // colors
     }
 }
@@ -1108,14 +1043,19 @@ void lclPushCrossingClipRegion( OutputDevice& rDev, const Rectangle& rRect, bool
  */
 void lclDrawDiagLine(
         OutputDevice& rDev, const Rectangle& rRect, bool bTLBR,
-        const DiagLineResult& rResult, long nDiagOffs1, long nDiagOffs2, bool bDotted )
+        const DiagLineResult& rResult, long nDiagOffs1, long nDiagOffs2, SvxBorderStyle nDashing )
 {
     lclPushDiagClipRect( rDev, rRect, rResult );
     LinePoints aLPoints( lclGetDiagLineEnds( rRect, bTLBR, nDiagOffs1 ) );
-    if( nDiagOffs1 == nDiagOffs2 )
-        lclDrawThinLine( rDev, aLPoints, bDotted );
-    else
-        lclDrawPolygon( rDev, aLPoints, lclGetDiagLineEnds( rRect, bTLBR, nDiagOffs2 ) );
+    LinePoints aL2Points( lclGetDiagLineEnds( rRect, bTLBR, nDiagOffs2 ) );
+    Point aSMid( ( aLPoints.maBeg + aL2Points.maBeg ) / 2 );
+    Point aEMid( ( aLPoints.maEnd + aL2Points.maEnd ) / 2 );
+
+    sal_uInt32 nWidth = lclToMapUnit( abs( nDiagOffs1 ) ) + lclToMapUnit( abs( nDiagOffs2 ) );
+    if ( ( nDiagOffs1 <= 0 && nDiagOffs2 <= 0 ) || ( nDiagOffs1 >=0 && nDiagOffs2 >=0 ) )
+        nWidth = lclToMapUnit( abs( nDiagOffs1 - nDiagOffs2 ) );
+
+    svtools::DrawLine( rDev, aSMid, aEMid, nWidth, nDashing );
     rDev.Pop(); // clipping region
 }
 
@@ -1147,9 +1087,9 @@ void lclDrawDiagFrameBorder(
         lclPushCrossingClipRegion( rDev, rRect, bTLBR, rCrossStyle );
 
     lclSetColorToOutDev( rDev, rBorder, pForceColor );
-    lclDrawDiagLine( rDev, rRect, bTLBR, rResult.maPrim, lclGetBeg( rBorder ), lclGetPrimEnd( rBorder ), rBorder.Dotted() );
+    lclDrawDiagLine( rDev, rRect, bTLBR, rResult.maPrim, lclGetBeg( rBorder ), lclGetPrimEnd( rBorder ), rBorder.Dashing() );
     if( rBorder.Secn() )
-        lclDrawDiagLine( rDev, rRect, bTLBR, rResult.maSecn, lclGetSecnBeg( rBorder ), lclGetEnd( rBorder ), rBorder.Dotted() );
+        lclDrawDiagLine( rDev, rRect, bTLBR, rResult.maSecn, lclGetSecnBeg( rBorder ), lclGetEnd( rBorder ), rBorder.Dashing() );
     rDev.Pop(); // colors
 
     if( bClip )
@@ -1226,7 +1166,7 @@ void Style::Set( const Color& rColor, sal_uInt16 nP, sal_uInt16 nD, sal_uInt16 n
     Set( nP, nD, nS );
 }
 
-void Style::Set( const SvxBorderLine& rBorder, double fScale, sal_uInt16 nMaxWidth, bool bUseDots )
+void Style::Set( const SvxBorderLine& rBorder, double fScale, sal_uInt16 nMaxWidth )
 {
     maColor = rBorder.GetColor();
 
@@ -1237,12 +1177,12 @@ void Style::Set( const SvxBorderLine& rBorder, double fScale, sal_uInt16 nMaxWid
     if( !nSecn )    // no or single frame border
     {
         Set( SCALEVALUE( nPrim ), 0, 0 );
-        mbDotted = bUseDots && (0 < nPrim) && (nPrim < 10);
+        mnDashing = rBorder.GetStyle();
     }
     else
     {
         Set( SCALEVALUE( nPrim ), SCALEVALUE( nDist ), SCALEVALUE( nSecn ) );
-        mbDotted = false;
+        mnDashing = SOLID;
         // Enlarge the style if distance is too small due to rounding losses.
         sal_uInt16 nPixWidth = SCALEVALUE( nPrim + nDist + nSecn );
         if( nPixWidth > GetWidth() )
@@ -1275,14 +1215,14 @@ void Style::Set( const SvxBorderLine& rBorder, double fScale, sal_uInt16 nMaxWid
     }
 }
 
-void Style::Set( const SvxBorderLine* pBorder, double fScale, sal_uInt16 nMaxWidth, bool bUseDots )
+void Style::Set( const SvxBorderLine* pBorder, double fScale, sal_uInt16 nMaxWidth )
 {
     if( pBorder )
-        Set( *pBorder, fScale, nMaxWidth, bUseDots );
+        Set( *pBorder, fScale, nMaxWidth );
     else
     {
         Clear();
-        mbDotted = false;
+        mnDashing = SOLID;
     }
 }
 
@@ -1314,7 +1254,8 @@ Style Style::Mirror() const
 bool operator==( const Style& rL, const Style& rR )
 {
     return (rL.Prim() == rR.Prim()) && (rL.Dist() == rR.Dist()) && (rL.Secn() == rR.Secn()) &&
-        (rL.GetColor() == rR.GetColor()) && (rL.GetRefMode() == rR.GetRefMode()) && (rL.Dotted() == rR.Dotted());
+        (rL.GetColor() == rR.GetColor()) && (rL.GetRefMode() == rR.GetRefMode()) &&
+        (rL.Dashing() == rR.Dashing());
 }
 
 bool operator<( const Style& rL, const Style& rR )
@@ -1331,7 +1272,7 @@ bool operator<( const Style& rL, const Style& rR )
     if( (rL.Secn() && rR.Secn()) && (rL.Dist() != rR.Dist()) ) return rL.Dist() > rR.Dist();
 
     // both lines single and 1 unit thick, only one is dotted -> rL<rR, if rL is dotted
-    if( (nLW == 1) && (rL.Dotted() != rR.Dotted()) ) return rL.Dotted();
+    if( (nLW == 1) && (rL.Dashing() != rR.Dashing()) ) return rL.Dashing();
 
     // seem to be equal
     return false;
@@ -1498,10 +1439,10 @@ void DrawVerFrameBorderSlanted( OutputDevice& rDev,
 
             lclSetColorToOutDev( rDev, aScaled, pForceColor );
             lclDrawVerLine( rDev, rTPos, aRes, rBPos, aRes,
-                lclGetBeg( aScaled ), lclGetPrimEnd( aScaled ), aScaled.Dotted() );
+                lclGetBeg( aScaled ), lclGetPrimEnd( aScaled ), aScaled.Dashing() );
             if( aScaled.Secn() )
                 lclDrawVerLine( rDev, rTPos, aRes, rBPos, aRes,
-                    lclGetSecnBeg( aScaled ), lclGetEnd( aScaled ), aScaled.Dotted() );
+                    lclGetSecnBeg( aScaled ), lclGetEnd( aScaled ), aScaled.Dashing() );
             rDev.Pop(); // colors
         }
     }
diff --git svx/source/dialog/frmsel.cxx svx/source/dialog/frmsel.cxx
index b562e12..046c416 100644
--- svx/source/dialog/frmsel.cxx
+++ svx/source/dialog/frmsel.cxx
@@ -157,7 +157,7 @@ void FrameBorder::SetCoreStyle( const SvxBorderLine* pStyle )
         maCoreStyle = SvxBorderLine();
 
     // from twips to points
-    maUIStyle.Set( maCoreStyle, 0.05, FRAMESEL_GEOM_WIDTH, true );
+    maUIStyle.Set( maCoreStyle, 0.05, FRAMESEL_GEOM_WIDTH );
     meState = maUIStyle.Prim() ? FRAMESTATE_SHOW : FRAMESTATE_HIDE;
 }
 
@@ -637,11 +637,31 @@ void FrameSelectorImpl::DrawAllFrameBorders()
     // Copy all frame border styles to the helper array
     maArray.SetColumnStyleLeft( 0, maLeft.GetUIStyle() );
     if( mbVer ) maArray.SetColumnStyleLeft( 1, maVer.GetUIStyle() );
-    maArray.SetColumnStyleRight( mbVer ? 1 : 0, maRight.GetUIStyle() );
+
+    // Invert the style for the right line
+    const frame::Style rRightStyle = maRight.GetUIStyle( );
+    frame::Style rInvertedRight( rRightStyle.GetColor(),
+            rRightStyle.Secn(), rRightStyle.Dist(), rRightStyle.Prim( ),
+            rRightStyle.Dashing( ) );
+    maArray.SetColumnStyleRight( mbVer ? 1 : 0, rInvertedRight );
 
     maArray.SetRowStyleTop( 0, maTop.GetUIStyle() );
-    if( mbHor ) maArray.SetRowStyleTop( 1, maHor.GetUIStyle() );
-    maArray.SetRowStyleBottom( mbHor ? 1 : 0, maBottom.GetUIStyle() );
+    if( mbHor )
+    {
+        // Invert the style for the hor line to match the real borders
+        const frame::Style rHorStyle = maHor.GetUIStyle();
+        frame::Style rInvertedHor( rHorStyle.GetColor(),
+            rHorStyle.Secn(), rHorStyle.Dist(), rHorStyle.Prim( ),
+            rHorStyle.Dashing() );
+        maArray.SetRowStyleTop( 1, rInvertedHor );
+    }
+
+    // Invert the style for the bottom line
+    const frame::Style rBottomStyle = maBottom.GetUIStyle( );
+    frame::Style rInvertedBottom( rBottomStyle.GetColor(),
+            rBottomStyle.Secn(), rBottomStyle.Dist(), rBottomStyle.Prim( ),
+            rBottomStyle.Dashing() );
+    maArray.SetRowStyleBottom( mbHor ? 1 : 0, rInvertedBottom );
 
     for( size_t nCol = 0; nCol < maArray.GetColCount(); ++nCol )
         for( size_t nRow = 0; nRow < maArray.GetRowCount(); ++nRow )
@@ -862,7 +882,8 @@ void FrameSelector::HideAllBorders()
         mxImpl->SetBorderState( **aIt, FRAMESTATE_HIDE );
 }
 
-bool FrameSelector::GetVisibleWidth( USHORT& rnPrim, USHORT& rnDist, USHORT& rnSecn ) const
+bool FrameSelector::GetVisibleWidth( USHORT& rnPrim, USHORT& rnDist, USHORT& rnSecn,
+                        SvxBorderStyle& rnStyle ) const
 {
     VisFrameBorderCIter aIt( mxImpl->maEnabBorders );
     if( !aIt.Is() )
@@ -874,13 +895,15 @@ bool FrameSelector::GetVisibleWidth( USHORT& rnPrim, USHORT& rnDist, USHORT& rnS
         bFound =
             (rStyle.GetOutWidth() == (*aIt)->GetCoreStyle().GetOutWidth()) &&
             (rStyle.GetDistance() == (*aIt)->GetCoreStyle().GetDistance()) &&
-            (rStyle.GetInWidth()  == (*aIt)->GetCoreStyle().GetInWidth());
+            (rStyle.GetInWidth()  == (*aIt)->GetCoreStyle().GetInWidth()) &&
+            (rStyle.GetStyle() == (*aIt)->GetCoreStyle().GetStyle());
 
     if( bFound )
     {
         rnPrim = rStyle.GetOutWidth();
         rnDist = rStyle.GetDistance();
         rnSecn = rStyle.GetInWidth();
+        rnStyle = rStyle.GetStyle();
     }
     return bFound;
 }
@@ -941,11 +964,13 @@ void FrameSelector::SelectAllVisibleBorders( bool bSelect )
         mxImpl->SelectBorder( **aIt, bSelect );
 }
 
-void FrameSelector::SetStyleToSelection( USHORT nPrim, USHORT nDist, USHORT nSecn )
+void FrameSelector::SetStyleToSelection( USHORT nPrim, USHORT nDist, USHORT nSecn,
+        SvxBorderStyle nStyle )
 {
     mxImpl->maCurrStyle.SetOutWidth( nPrim );
     mxImpl->maCurrStyle.SetDistance( nDist );
     mxImpl->maCurrStyle.SetInWidth( nSecn );
+    mxImpl->maCurrStyle.SetStyle( nStyle );
     for( SelFrameBorderIter aIt( mxImpl->maEnabBorders ); aIt.Is(); ++aIt )
         mxImpl->SetBorderState( **aIt, FRAMESTATE_SHOW );
 }
diff --git svx/source/table/cell.cxx svx/source/table/cell.cxx
index e8ea7c7..8530961 100644
--- svx/source/table/cell.cxx
+++ svx/source/table/cell.cxx
@@ -32,6 +32,7 @@
 #include <com/sun/star/style/XStyle.hpp>
 #include <com/sun/star/text/WritingMode.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 
 #include <cppuhelper/typeprovider.hxx>
 #include <svl/style.hxx>
diff --git svx/source/table/viewcontactoftableobj.cxx svx/source/table/viewcontactoftableobj.cxx
index 5f0af00..482d1ef 100644
--- svx/source/table/viewcontactoftableobj.cxx
+++ svx/source/table/viewcontactoftableobj.cxx
@@ -332,7 +332,8 @@ namespace drawinglayer
                         fExtendOE * fTwipsToMM,
                         true,
                         getLeftIsOutside(),
-                        getLeftLine().GetColor().getBColor()));
+                        getLeftLine().GetColor().getBColor(),
+                        getLeftLine().GetStyle()));
                 }
             }
 
@@ -374,7 +375,8 @@ namespace drawinglayer
                         fExtendOE * fTwipsToMM,
                         true,
                         getBottomIsOutside(),
-                        getBottomLine().GetColor().getBColor()));
+                        getBottomLine().GetColor().getBColor(),
+                        getBottomLine().GetStyle()));
                 }
             }
 
@@ -416,7 +418,8 @@ namespace drawinglayer
                         fExtendIE * fTwipsToMM,
                         getRightIsOutside(),
                         true,
-                        getRightLine().GetColor().getBColor()));
+                        getRightLine().GetColor().getBColor(),
+                        getRightLine().GetStyle()));
                 }
             }
 
@@ -458,7 +461,8 @@ namespace drawinglayer
                         fExtendIE * fTwipsToMM,
                         getTopIsOutside(),
                         true,
-                        getTopLine().GetColor().getBColor()));
+                        getTopLine().GetColor().getBColor(),
+                        getTopLine().GetStyle()));
                 }
             }
 
diff --git svx/source/tbxctrls/tbcontrl.cxx svx/source/tbxctrls/tbcontrl.cxx
index db1c542..66eabd0 100644
--- svx/source/tbxctrls/tbcontrl.cxx
+++ svx/source/tbxctrls/tbcontrl.cxx
@@ -41,6 +41,7 @@
 #include <svtools/ctrlbox.hxx>
 #include <svl/style.hxx>
 #include <svtools/ctrltool.hxx>
+#include <svtools/borderhelper.hxx>
 #include <svl/stritem.hxx>
 #include <unotools/pathoptions.hxx>
 #include <sfx2/tplpitem.hxx>
@@ -88,6 +89,7 @@
 #include "colorwindow.hxx"
 #include <memory>
 
+#include <svx/framelink.hxx>
 #include <svx/tbxcolorupdate.hxx>
 #include <editeng/eerdll.hxx>
 #include <editeng/editrids.hrc>
@@ -1522,6 +1524,21 @@ void SvxLineWindow_Impl::MakeLineBitmap( USHORT nNo, Bitmap& rBmp, const Size& r
             aVirDev.DrawRect( aRect );
             nLineWidth = (USHORT) (DEF_DOUBLE_LINE6_OUT+DEF_DOUBLE_LINE6_IN+DEF_DOUBLE_LINE6_DIST)/20;
             break;
+        case 17: // Dotted line
+            aRect.Top() 	= 6;
+            aRect.Bottom()	= 6;
+            aVirDev.SetLineColor( rLineCol );
+            aVirDev.SetFillColor();
+            svtools::DrawLine( aVirDev, aRect.LeftCenter(), aRect.RightCenter(), 1, DOTTED );
+            break;
+
+        case 18: // Dashed line
+            aRect.Top() 	= 6;
+            aRect.Bottom()	= 6;
+            aVirDev.SetLineColor( rLineCol );
+            aVirDev.SetFillColor();
+            svtools::DrawLine( aVirDev, aRect.LeftCenter(), aRect.RightCenter(), 1, DASHED );
+            break;
 
         default:
             break;
@@ -1542,6 +1559,7 @@ IMPL_LINK( SvxLineWindow_Impl, SelectHdl, void *, EMPTYARG )
     USHORT			n1 = 0,
                     n2 = 0,
                     n3 = 0;
+    SvxBorderStyle  nStyle = SOLID;
     BOOL			bSetLine = TRUE;
 
     switch ( aLineSet.GetSelectItemId() )
@@ -1585,6 +1603,14 @@ IMPL_LINK( SvxLineWindow_Impl, SelectHdl, void *, EMPTYARG )
         case 16: n1 = DEF_DOUBLE_LINE6_OUT;
                  n2 = DEF_DOUBLE_LINE6_IN;
                  n3 = DEF_DOUBLE_LINE6_DIST;	 break;
+        case 17:
+                 n1 = DEF_LINE_WIDTH_5;
+                 nStyle = DOTTED;
+                 break;
+        case 18:
+                 n1 = DEF_LINE_WIDTH_5;
+                 nStyle = DASHED;
+                 break;
         case  0:
         default:
             bSetLine = FALSE;
@@ -1592,7 +1618,7 @@ IMPL_LINK( SvxLineWindow_Impl, SelectHdl, void *, EMPTYARG )
     }
     if ( bSetLine )
     {
-        SvxBorderLine aTmp( NULL, n1, n2, n3 );
+        SvxBorderLine aTmp( NULL, n1, n2, n3, nStyle );
         aLineItem.SetLine( &aTmp );
     }
     else
@@ -1676,7 +1702,7 @@ void SvxLineWindow_Impl::CreateBitmaps( void )
     ::Color					aBackCol( rStyleSettings.GetWindowColor() );
     aLineSet.Clear();
 
-    for( USHORT i = 1 ; i < 17 ; ++i )
+    for( USHORT i = 1 ; i < 19 ; ++i )
     {
         MakeLineBitmap( i, aBmp, aBmpSize, aStr, aLineCol, aBackCol );
         aLineSet.InsertItem( i, aBmp, aStr );
diff --git sw/source/core/inc/frame.hxx sw/source/core/inc/frame.hxx
index ca1deea..6006795 100644
--- sw/source/core/inc/frame.hxx
+++ sw/source/core/inc/frame.hxx
@@ -27,6 +27,7 @@
 #ifndef _FRAME_HXX
 #define _FRAME_HXX
 #include <svl/svarray.hxx>
+#include <editeng/borderline.hxx>
 #include "swtypes.hxx"	// fuer SwTwips
 #include "swrect.hxx"
 #include "calbck.hxx"	// fuer SwClient
@@ -522,7 +523,7 @@ public:
                           const BOOL bLowerMode = FALSE,
                           const BOOL bLowerBorder = FALSE ) const;
     void PaintBorderLine( const SwRect&, const SwRect&, const SwPageFrm*,
-                          const Color *pColor ) const;
+                          const Color *pColor, const SvxBorderStyle = SOLID ) const;
 
     //Retouche, nicht im Bereich des uebergebenen Rect!
     void Retouche( const SwPageFrm *pPage, const SwRect &rRect ) const;
diff --git sw/source/core/layout/paintfrm.cxx sw/source/core/layout/paintfrm.cxx
index 7a432fd..c042a95 100644
--- sw/source/core/layout/paintfrm.cxx
+++ sw/source/core/layout/paintfrm.cxx
@@ -119,6 +119,9 @@
 #define COL_NOTES_SIDEPANE_SCROLLAREA		RGB_COLORDATA(230,230,220)
 #include <vcl/svapp.hxx>
 
+#include <svtools/borderhelper.hxx>
+
+
 using namespace ::com::sun::star;
 
 #define GETOBJSHELL()		((SfxObjectShell*)rSh.GetDoc()->GetDocShell())
@@ -160,15 +163,17 @@ using namespace ::com::sun::star;
 class SwLineRect : public SwRect
 {
     const Color	   *pColor;
+    SvxBorderStyle  nStyle;
     const SwTabFrm *pTab;
           BYTE		nSubColor;  //Hilfslinien einfaerben
           BOOL		bPainted;	//schon gepaintet?
           BYTE		nLock;		//Um die Linien zum Hell-Layer abzugrenzen.
 public:
-    SwLineRect( const SwRect &rRect, const Color *pCol,
+    SwLineRect( const SwRect &rRect, const Color *pCol, const SvxBorderStyle nStyle,
                 const SwTabFrm *pT , const BYTE nSCol );
 
     const Color			*GetColor() const { return pColor;}
+    SvxBorderStyle       GetStyle() const { return nStyle; }
     const SwTabFrm		*GetTab()	const { return pTab;  }
     void  SetPainted()					  { bPainted = TRUE; }
     void  Lock( BOOL bLock )			  { if ( bLock )
@@ -190,7 +195,7 @@ class SwLineRects : public SwLRects
     USHORT nLastCount;	//unuetze Durchlaeufe im PaintLines verhindern.
 public:
     SwLineRects() : nLastCount( 0 ) {}
-    void AddLineRect( const SwRect& rRect,	const Color *pColor,
+    void AddLineRect( const SwRect& rRect,	const Color *pColor, const SvxBorderStyle nStyle,
                       const SwTabFrm *pTab, const BYTE nSCol );
     void ConnectEdges( OutputDevice *pOut );
     void PaintLines  ( OutputDevice *pOut );
@@ -421,10 +426,11 @@ SwSavePaintStatics::~SwSavePaintStatics()
 SV_IMPL_VARARR( SwLRects, SwLineRect );
 
 
-SwLineRect::SwLineRect( const SwRect &rRect, const Color *pCol,
+SwLineRect::SwLineRect( const SwRect &rRect, const Color *pCol, const SvxBorderStyle nStyl,
                         const SwTabFrm *pT, const BYTE nSCol ) :
     SwRect( rRect ),
     pColor( pCol ),
+    nStyle( nStyl ),
     pTab( pT ),
     nSubColor( nSCol ),
     bPainted( FALSE ),
@@ -469,7 +475,7 @@ BOOL SwLineRect::MakeUnion( const SwRect &rRect )
     return FALSE;
 }
 
-void SwLineRects::AddLineRect( const SwRect &rRect, const Color *pCol,
+void SwLineRects::AddLineRect( const SwRect &rRect, const Color *pCol, const SvxBorderStyle nStyle,
                                const SwTabFrm *pTab, const BYTE nSCol )
 {
     //Rueckwaerts durch, weil Linien die zusammengefasst werden koennen i.d.R.
@@ -488,7 +494,7 @@ void SwLineRects::AddLineRect( const SwRect &rRect, const Color *pCol,
                 return;
         }
     }
-    Insert( SwLineRect( rRect, pCol, pTab, nSCol ), Count() );
+    Insert( SwLineRect( rRect, pCol, nStyle, pTab, nSCol ), Count() );
 }
 
 void SwLineRects::ConnectEdges( OutputDevice *pOut )
@@ -595,7 +601,7 @@ void SwLineRects::ConnectEdges( OutputDevice *pOut )
                             if ( !rL1.IsInside( aIns ) )
                                 continue;
                             const USHORT nTmpFree = Free();
-                            Insert( SwLineRect( aIns, rL1.GetColor(),
+                            Insert( SwLineRect( aIns, rL1.GetColor(), SOLID,
                                         rL1.GetTab(), SUBCOL_TAB ), Count() );
                             if ( !nTmpFree )
                             {
@@ -636,7 +642,7 @@ void SwLineRects::ConnectEdges( OutputDevice *pOut )
                             if ( !rL1.IsInside( aIns ) )
                                 continue;
                             const USHORT nTmpFree = Free();
-                            Insert( SwLineRect( aIns, rL1.GetColor(),
+                            Insert( SwLineRect( aIns, rL1.GetColor(), SOLID,
                                         rL1.GetTab(), SUBCOL_TAB ), Count() );
                             if ( !nTmpFree )
                             {
@@ -666,7 +672,7 @@ inline void SwSubsRects::Ins( const SwRect &rRect, const BYTE nSCol )
     //Linien die kuerzer als die breiteste Linienbreite sind werden
     //nicht aufgenommen.
     if ( rRect.Height() > DEF_LINE_WIDTH_4 || rRect.Width() > DEF_LINE_WIDTH_4 )
-        Insert( SwLineRect( rRect, 0, 0, nSCol ), Count());
+        Insert( SwLineRect( rRect, 0, SOLID, 0, nSCol ), Count());
 }
 
 void SwSubsRects::RemoveSuperfluousSubsidiaryLines( const SwLineRects &rRects )
@@ -722,7 +728,7 @@ void SwSubsRects::RemoveSuperfluousSubsidiaryLines( const SwLineRects &rRects )
                         {
                             SwRect aNewSubsRect( aSubsLineRect );
                             aNewSubsRect.Bottom( nTmp );
-                            Insert( SwLineRect( aNewSubsRect, 0, 0,
+                            Insert( SwLineRect( aNewSubsRect, 0, aSubsLineRect.GetStyle(), 0,
                                                 aSubsLineRect.GetSubColor() ), Count());
                         }
                         nTmp = rLine.Bottom()+nPixelSzH+1;
@@ -730,7 +736,7 @@ void SwSubsRects::RemoveSuperfluousSubsidiaryLines( const SwLineRects &rRects )
                         {
                             SwRect aNewSubsRect( aSubsLineRect );
                             aNewSubsRect.Top( nTmp );
-                            Insert( SwLineRect( aNewSubsRect, 0, 0,
+                            Insert( SwLineRect( aNewSubsRect, 0, aSubsLineRect.GetStyle(), 0,
                                                 aSubsLineRect.GetSubColor() ), Count());
                         }
                         Remove( i, 1 );
@@ -748,7 +754,7 @@ void SwSubsRects::RemoveSuperfluousSubsidiaryLines( const SwLineRects &rRects )
                         {
                             SwRect aNewSubsRect( aSubsLineRect );
                             aNewSubsRect.Right( nTmp );
-                            Insert( SwLineRect( aNewSubsRect, 0, 0,
+                            Insert( SwLineRect( aNewSubsRect, 0, aSubsLineRect.GetStyle(), 0,
                                                 aSubsLineRect.GetSubColor() ), Count());
                         }
                         nTmp = rLine.Right()+nPixelSzW+1;
@@ -756,7 +762,7 @@ void SwSubsRects::RemoveSuperfluousSubsidiaryLines( const SwLineRects &rRects )
                         {
                             SwRect aNewSubsRect( aSubsLineRect );
                             aNewSubsRect.Left( nTmp );
-                            Insert( SwLineRect( aNewSubsRect, 0, 0,
+                            Insert( SwLineRect( aNewSubsRect, 0, aSubsLineRect.GetStyle(), 0,
                                                 aSubsLineRect.GetSubColor() ), Count());
                         }
                         Remove( i, 1 );
@@ -775,6 +781,44 @@ void SwLineRects::LockLines( BOOL bLock )
         operator[](i).Lock( bLock );
 }
 
+void lcl_DrawDashedRect( OutputDevice * pOut, SwLineRect & rLRect )
+{
+    double nHalfLWidth = rLRect.Height(  );
+    if ( nHalfLWidth > 1 )
+    {
+        nHalfLWidth = nHalfLWidth / 2;
+    }
+    else
+    {
+        nHalfLWidth = 1;
+    }
+
+    long startX = rLRect.Left(  );
+    long startY = rLRect.Top(  ) + nHalfLWidth;
+    long endX = rLRect.Left(  ) + rLRect.Width(  );
+    long endY = rLRect.Top(  ) + nHalfLWidth;
+
+    if ( rLRect.Height(  ) > rLRect.Width(  ) )
+    {
+        nHalfLWidth = rLRect.Width(  );
+        if ( nHalfLWidth > 1 )
+        {
+            nHalfLWidth = nHalfLWidth / 2;
+        }
+        else
+        {
+            nHalfLWidth = 1;
+        }
+        startX = rLRect.Left(  ) + nHalfLWidth;
+        startY = rLRect.Top(  );
+        endX = rLRect.Left(  ) + nHalfLWidth;
+        endY = rLRect.Top(  ) + rLRect.Height(  );
+    }
+
+    svtools::DrawLine( *pOut, Point( startX, startY ), Point( endX, endY ),
+            sal_uInt32( nHalfLWidth * 2 ), rLRect.GetStyle( ) );
+}
+
 void SwLineRects::PaintLines( OutputDevice *pOut )
 {
     //Painten der Umrandungen. Leider muessen wir zweimal durch.
@@ -788,6 +832,7 @@ void SwLineRects::PaintLines( OutputDevice *pOut )
 
         // OD 2004-04-23 #116347#
         pOut->Push( PUSH_FILLCOLOR|PUSH_LINECOLOR );
+        pOut->SetFillColor();
         pOut->SetLineColor();
         ConnectEdges( pOut );
         const Color *pLast = 0;
@@ -846,11 +891,12 @@ void SwLineRects::PaintLines( OutputDevice *pOut )
                         Application::GetSettings().GetStyleSettings().GetHighContrastMode() )
                         pOut->SetDrawMode( 0 );
 
-                    pOut->SetFillColor( *pLast );
+                    pOut->SetLineColor( *pLast );
                     pOut->SetDrawMode( nOldDrawMode );
                 }
+
                 if( !rLRect.IsEmpty() )
-                    pOut->DrawRect( rLRect.SVRect() );
+                    lcl_DrawDashedRect( pOut, rLRect );
                 rLRect.SetPainted();
             }
             else
@@ -884,7 +930,7 @@ void SwLineRects::PaintLines( OutputDevice *pOut )
                     pOut->SetDrawMode( nOldDrawMode );
                 }
                 if( !rLRect.IsEmpty() )
-                    pOut->DrawRect( rLRect.SVRect() );
+                    lcl_DrawDashedRect( pOut, rLRect );
                 rLRect.SetPainted();
             }
         nLastCount = nMinCount;
@@ -3992,7 +4038,8 @@ void SwFrm::PaintShadow( const SwRect& rRect, SwRect& rOutRect,
 void SwFrm::PaintBorderLine( const SwRect& rRect,
                              const SwRect& rOutRect,
                              const SwPageFrm *pPage,
-                             const Color *pColor ) const
+                             const Color *pColor,
+                             const SvxBorderStyle nStyle ) const
 {
     if ( !rOutRect.IsOver( rRect ) )
         return;
@@ -4015,10 +4062,10 @@ void SwFrm::PaintBorderLine( const SwRect& rRect,
         SwRegionRects aRegion( aOut, 4, 1 );
         ::lcl_SubtractFlys( this, pPage, aOut, aRegion );
         for ( USHORT i = 0; i < aRegion.Count(); ++i )
-            pLines->AddLineRect( aRegion[i], pColor, pTab, nSubCol );
+            pLines->AddLineRect( aRegion[i], pColor, nStyle, pTab, nSubCol );
     }
     else
-        pLines->AddLineRect( aOut, pColor, pTab, nSubCol );
+        pLines->AddLineRect( aOut, pColor, nStyle, pTab, nSubCol );
 }
 
 /*************************************************************************
@@ -4309,7 +4356,8 @@ void lcl_PaintLeftRightLine( const sal_Bool         _bLeft,
                 (aPaintRect.*_rRectFn->fnAddRight)( 1 );
             }
         }
-        _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pLeftRightBorder->GetColor() );
+        _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pLeftRightBorder->GetColor(),
+                pLeftRightBorder->GetStyle( ) );
     }
 
     if ( pLeftRightBorder->GetInWidth() )
@@ -4349,7 +4397,8 @@ void lcl_PaintLeftRightLine( const sal_Bool         _bLeft,
                     (aPaintRect.*_rRectFn->fnAddRight)( 1 );
                 }
             }
-            _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pLeftRightBorder->GetColor() );
+            _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pLeftRightBorder->GetColor(),
+                   SOLID );
         }
     }
 }
@@ -4413,7 +4462,8 @@ void lcl_PaintTopBottomLine( const sal_Bool         _bTop,
                 (aPaintRect.*_rRectFn->fnAddBottom)( 1 );
             }
         }
-        _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pTopBottomBorder->GetColor() );
+        _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pTopBottomBorder->GetColor(),
+               pTopBottomBorder->GetStyle( ) );
     }
 
     if ( pTopBottomBorder->GetInWidth() )
@@ -4452,7 +4502,8 @@ void lcl_PaintTopBottomLine( const sal_Bool         _bTop,
                     (aPaintRect.*_rRectFn->fnAddBottom)( 1 );
                 }
             }
-            _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pTopBottomBorder->GetColor() );
+            _rFrm.PaintBorderLine( _rRect, aPaintRect, &_rPage, &pTopBottomBorder->GetColor(),
+                   SOLID );
         }
     }
 }
@@ -4932,7 +4983,7 @@ void SwLayoutFrm::PaintColLines( const SwRect &rRect, const SwFmtCol &rFmtCol,
         (aLineRect.*fnRect->fnSetPosX)
             ( (pCol->Frm().*fnGetX)() - nPenHalf );
         if ( aRect.IsOver( aLineRect ) )
-            PaintBorderLine( aRect, aLineRect , pPage, &rFmtCol.GetLineColor());
+            PaintBorderLine( aRect, aLineRect , pPage, &rFmtCol.GetLineColor() );
         pCol = pCol->GetNext();
     }
 }
@@ -6080,7 +6131,7 @@ void MA_FASTCALL lcl_RefreshLine( const SwLayoutFrm *pLay,
             SwRect aRect( aP1, aP2 );
             // OD 18.11.2002 #99672# - use parameter <_pSubsLines> instead of
             // global variable <pSubsLines>.
-            _pSubsLines->AddLineRect( aRect, 0, 0, nSubColor );
+            _pSubsLines->AddLineRect( aRect, 0, SOLID, 0, nSubColor );
         }
         aP1 = aP2;
         aP1.*pDirPt += 1;
@@ -6219,13 +6270,13 @@ void SwLayoutFrm::PaintSubsidiaryLines( const SwPageFrm *pPage,
             if ( aOriginal.Left() == aOut.Left() )
             {
                 const SwRect aRect( aOut.Pos(), aLB );
-                pUsedSubsLines->AddLineRect( aRect, 0, 0, nSubColor );
+                pUsedSubsLines->AddLineRect( aRect, 0, SOLID, 0, nSubColor );
             }
             // OD 14.11.2002 #104821# - in vertical layout set page/column break at right
             if ( aOriginal.Right() == nRight )
             {
                 const SwRect aRect( aRT, aRB );
-                pUsedSubsLines->AddLineRect( aRect, 0, 0,
+                pUsedSubsLines->AddLineRect( aRect, 0, SOLID, 0,
                         (bBreak && bVert) ? SUBCOL_BREAK : nSubColor );
             }
         }
@@ -6236,13 +6287,13 @@ void SwLayoutFrm::PaintSubsidiaryLines( const SwPageFrm *pPage,
             {
                 // OD 14.11.2002 #104821# - in horizontal layout set page/column break at top
                 const SwRect aRect( aOut.Pos(), aRT );
-                pUsedSubsLines->AddLineRect( aRect, 0, 0,
+                pUsedSubsLines->AddLineRect( aRect, 0, SOLID, 0,
                         (bBreak && !bVert) ? SUBCOL_BREAK : nSubColor );
             }
             if ( aOriginal.Bottom() == nBottom )
             {
                 const SwRect aRect( aLB, aRB );
-                pUsedSubsLines->AddLineRect( aRect, 0, 0, nSubColor );
+                pUsedSubsLines->AddLineRect( aRect, 0, SOLID, 0, nSubColor );
             }
         }
     }
diff --git sw/source/filter/html/css1atr.cxx sw/source/filter/html/css1atr.cxx
index c584f5c..5258186 100644
--- sw/source/filter/html/css1atr.cxx
+++ sw/source/filter/html/css1atr.cxx
@@ -176,7 +176,6 @@ static Writer& OutCSS1_SvxULSpace_SvxLRSpace( Writer& rWrt,
 static Writer& OutCSS1_SvxBrush( Writer& rWrt, const SfxPoolItem& rHt,
                                  USHORT nMode, const String *pGrfName );
 static Writer& OutCSS1_SvxBrush( Writer& rWrt, const SfxPoolItem& rHt );
-static Writer& OutCSS1_SvxBox( Writer& rWrt, const SfxPoolItem& rHt );
 static Writer& OutCSS1_SwFmtFrmSize( Writer& rWrt, const SfxPoolItem& rHt,
                                      USHORT nMode );
 static Writer& OutCSS1_SvxFmtBreak_SwFmtPDesc_SvxFmtKeep( Writer& rWrt,
@@ -3600,8 +3599,24 @@ static void OutCSS1_SvxBorderLine( SwHTMLWriter& rHTMLWrt,
     }
 
     // Linien-Stil: solid oder double
-    ((sOut += ' ')
-        += (bDouble ? sCSS1_PV_double : sCSS1_PV_solid)) += ' ';
+    sOut += ' ';
+    if ( bDouble )
+        sOut += sCSS1_PV_double;
+    else
+    {
+        switch ( pLine->GetStyle( ) )
+        {
+            case DOTTED:
+                sOut += sCSS1_PV_dotted;
+                break;
+            case DASHED:
+                sOut += sCSS1_PV_dashed;
+                break;
+            default:
+                sOut += sCSS1_PV_solid;
+        }
+    }
+    sOut += ' ';
 
     // und noch die Farbe
     GetCSS1Color( pLine->GetColor(), sOut );
@@ -3609,14 +3624,14 @@ static void OutCSS1_SvxBorderLine( SwHTMLWriter& rHTMLWrt,
     rHTMLWrt.OutCSS1_PropertyAscii( pProperty, sOut );
 }
 
-static Writer& OutCSS1_SvxBox( Writer& rWrt, const SfxPoolItem& rHt )
+Writer& OutCSS1_SvxBox( Writer& rWrt, const SfxPoolItem& rHt )
 {
     SwHTMLWriter& rHTMLWrt = (SwHTMLWriter&)rWrt;
 
     // Das Zeichen-Attribut wird nicht ausgegeben, wenn gerade
     // Optionen ausgegeben werden
-    if( !rHTMLWrt.IsHTMLMode(HTMLMODE_PARA_BORDER))
-        return rWrt;
+//    if( !rHTMLWrt.IsHTMLMode(HTMLMODE_PARA_BORDER))
+//        return rWrt;
 
     const SvxBoxItem& rBoxItem = (const SvxBoxItem&)rHt;
     const SvxBorderLine *pTop = rBoxItem.GetTop();
diff --git sw/source/filter/html/htmltabw.cxx sw/source/filter/html/htmltabw.cxx
index f7b577c..8ee73ca 100644
--- sw/source/filter/html/htmltabw.cxx
+++ sw/source/filter/html/htmltabw.cxx
@@ -437,6 +437,11 @@ void SwHTMLWrtTable::OutTableCell( SwHTMLWriter& rWrt,
             OutCSS1_TableBGStyleOpt( rWrt, *pBrushItem );
     }
 
+    ((sOut += ' ') += OOO_STRING_SVTOOLS_HTML_style ) += "=\"";
+    rWrt.Strm() << sOut.GetBuffer( );
+    OutCSS1_SvxBox( rWrt, pBox->GetFrmFmt()->GetBox() );
+    sOut = '"';
+
     sal_uInt32 nNumFmt = 0;
     double nValue = 0.0;
     sal_Bool bNumFmt = sal_False, bValue = sal_False;
@@ -705,19 +710,6 @@ void SwHTMLWrtTable::Write( SwHTMLWriter& rWrt, sal_Int16 eAlign,
     // Anderenfalls enthaelt nBorder naemlich nur die Breite der Umrandung,
     // die genutzt wird, wenn gar kein sheet::Border angegeben ist.
     sal_Bool bHasAnyBorders = nFrameMask || bColsHaveBorder || bRowsHaveBorder;
-    if( bCollectBorderWidth || nBorder==0 || bHasAnyBorders )
-        (((sOut += ' ' ) += OOO_STRING_SVTOOLS_HTML_O_border ) += '=')
-            += ByteString::CreateFromInt32( rWrt.ToPixel( nBorder ) );
-
-    // BORDERCOLOR ausgeben
-
-    if( (sal_uInt32)-1 != nBorderColor && rWrt.bCfgOutStyles && bHasAnyBorders )
-    {
-        ((sOut += ' ' ) += OOO_STRING_SVTOOLS_HTML_O_bordercolor ) += '=';
-        rWrt.Strm() << sOut.GetBuffer();
-        HTMLOutFuncs::Out_Color( rWrt.Strm(), nBorderColor, rWrt.eDestEnc );
-        sOut.Erase();
-    }
 
     // CELLPADDING ausgeben: Stammt aus Layout oder ist berechnet
     (((sOut += ' ' ) += OOO_STRING_SVTOOLS_HTML_O_cellpadding ) += '=')
diff --git sw/source/filter/html/svxcss1.cxx sw/source/filter/html/svxcss1.cxx
index f1bda7d..72c70b6 100644
--- sw/source/filter/html/svxcss1.cxx
+++ sw/source/filter/html/svxcss1.cxx
@@ -185,13 +185,13 @@ static CSS1PropertyEnum __READONLY_DATA aBorderWidthTable[] =
     { 0,					0	}
 };
 
-enum CSS1BorderStyle { CSS1_BS_NONE, CSS1_BS_SINGLE, CSS1_BS_DOUBLE };
+enum CSS1BorderStyle { CSS1_BS_NONE, CSS1_BS_SINGLE, CSS1_BS_DOUBLE, CSS1_BS_DOTTED, CSS1_BS_DASHED };
 
 static CSS1PropertyEnum __READONLY_DATA aBorderStyleTable[] =
 {
     { sCSS1_PV_none,		CSS1_BS_NONE		},
-    { sCSS1_PV_dotted, 		CSS1_BS_SINGLE		},
-    { sCSS1_PV_dashed, 		CSS1_BS_SINGLE		},
+    { sCSS1_PV_dotted, 		CSS1_BS_DOTTED		},
+    { sCSS1_PV_dashed, 		CSS1_BS_DASHED		},
     { sCSS1_PV_solid, 		CSS1_BS_SINGLE		},
     { sCSS1_PV_double, 		CSS1_BS_DOUBLE		},
     { sCSS1_PV_groove, 		CSS1_BS_SINGLE		},
@@ -369,6 +369,12 @@ void SvxCSS1BorderInfo::SetBorderLine( USHORT nLine, SvxBoxItem &rBoxItem ) cons
 
     // Linien-Stil doppelt oder einfach?
     BOOL bDouble = eStyle == CSS1_BS_DOUBLE;
+    if ( eStyle == CSS1_BS_DOTTED )
+        aBorderLine.SetStyle( DOTTED );
+    else if ( eStyle == CSS1_BS_DASHED )
+        aBorderLine.SetStyle( DASHED );
+    else
+        aBorderLine.SetStyle( SOLID );
 
     // benannte Breite umrechnenen, wenn keine absolute gegeben ist
     if( nAbsWidth==USHRT_MAX )
diff --git sw/source/filter/html/wrthtml.hxx sw/source/filter/html/wrthtml.hxx
index c422bab..a9b5e13 100644
--- sw/source/filter/html/wrthtml.hxx
+++ sw/source/filter/html/wrthtml.hxx
@@ -598,6 +598,7 @@ Writer& OutHTML_NumBulListStart( SwHTMLWriter& rWrt,
 Writer& OutHTML_NumBulListEnd( SwHTMLWriter& rWrt,
                                const SwHTMLNumRuleInfo& rNextInfo );
 
+Writer& OutCSS1_SvxBox( Writer& rWrt, const SfxPoolItem& rHt );
 
 #endif	//  _WRTHTML_HXX
 
diff --git sw/source/filter/rtf/rtfatr.cxx sw/source/filter/rtf/rtfatr.cxx
index c73d4a4..348586f 100644
--- sw/source/filter/rtf/rtfatr.cxx
+++ sw/source/filter/rtf/rtfatr.cxx
@@ -1720,12 +1720,31 @@ static void OutTBLBorderLine(SwRTFWriter& rWrt, const SvxBorderLine* pLine,
     }
     else
     {
-        // einfache Linie
-        if( DEF_LINE_WIDTH_1 >= pLine->GetOutWidth() )
-            (( sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRS ) += OOO_STRING_SVTOOLS_RTF_BRDRW ) +=
+        if ( DEF_LINE_WIDTH_0 == pLine->GetOutWidth( ) )
+            // Hairline
+            sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRHAIR;
+        else if( 255 >= pLine->GetOutWidth() )
+        {
+            // Simple width simple
+            sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRS;
+            switch ( pLine->GetStyle( ) )
+            {
+                case DOTTED:
+                    sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRDOT;
+                    break;
+                case DASHED:
+                    sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRDASH;
+                    break;
+                case SOLID:
+                default:
+                    break;
+            }
+            ( sLineStr += OOO_STRING_SVTOOLS_RTF_BRDRW ) +=
                         ByteString::CreateFromInt32( pLine->GetOutWidth() );
+        }
         else
-            (( sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRTH ) += OOO_STRING_SVTOOLS_RTF_BRDRW ) +=
+            // Shouldn't happen with the OOo default width values
+            (( sLineStr = OOO_STRING_SVTOOLS_RTF_BRDRTH ) += sLineStr += OOO_STRING_SVTOOLS_RTF_BRDRW ) +=
                         ByteString::CreateFromInt32( pLine->GetOutWidth() / 2 );
     }
 
diff --git sw/source/filter/rtf/swparrtf.cxx sw/source/filter/rtf/swparrtf.cxx
index 196ac04..39ce5ab 100644
--- sw/source/filter/rtf/swparrtf.cxx
+++ sw/source/filter/rtf/swparrtf.cxx
@@ -2454,7 +2454,11 @@ void SwRTFParser::SetBorderLine(SvxBoxItem& rBox, sal_uInt16 nLine)
             break;
 
         case RTF_BRDRDOT:           // SO does not have dashed or dotted lines
+            nIdx = 6;
+            break;
         case RTF_BRDRDASH:
+            nIdx = 7;
+            break;
         case RTF_BRDRDASHSM:
         case RTF_BRDRDASHD:
         case RTF_BRDRDASHDD:
diff --git sw/source/filter/rtf/wrtrtf.cxx sw/source/filter/rtf/wrtrtf.cxx
index 31c77c5..9d9be87 100644
--- sw/source/filter/rtf/wrtrtf.cxx
+++ sw/source/filter/rtf/wrtrtf.cxx
@@ -1461,7 +1461,20 @@ void SwRTFWriter::OutRTFBorder(const SvxBorderLine* aLine, const USHORT nSpace )
     int nWidth = aLine->GetOutWidth();
 
     if(nDistance == 0)	// Single Line
-        Strm() << OOO_STRING_SVTOOLS_RTF_BRDRS;
+    {
+        switch ( aLine->GetStyle( ) )
+        {
+            case DOTTED:
+                Strm() << OOO_STRING_SVTOOLS_RTF_BRDRDOT;
+                break;
+            case DASHED:
+                Strm() << OOO_STRING_SVTOOLS_RTF_BRDRDASH;
+                break;
+            case SOLID:
+            default:
+                Strm() << OOO_STRING_SVTOOLS_RTF_BRDRS;
+        }
+    }
     else				// Double Line
     {
         if(nOutWidth == nInWidth)
diff --git sw/source/filter/ww1/w1sprm.cxx sw/source/filter/ww1/w1sprm.cxx
index a26fc29..488ca0b 100644
--- sw/source/filter/ww1/w1sprm.cxx
+++ sw/source/filter/ww1/w1sprm.cxx
@@ -208,6 +208,7 @@ STOP1(Ww1SingleSprmPPageBreakBefore, RES_BREAK)
 SvxBorderLine* Ww1SingleSprmPBrc::SetBorder(SvxBorderLine* pLine, W1_BRC10* pBrc)
 {
     USHORT nCode;
+    SvxBorderStyle eStyle = SOLID;
     if(pBrc->dxpLine2WidthGet() == 0)
     {
         switch(pBrc->dxpLine1WidthGet())
@@ -219,9 +220,18 @@ SvxBorderLine* Ww1SingleSprmPBrc::SetBorder(SvxBorderLine* pLine, W1_BRC10* pBrc
         case 3: nCode = DEF_LINE_WIDTH_2; break;
         case 4: nCode = DEF_LINE_WIDTH_3; break;
         case 5: nCode = DEF_LINE_WIDTH_4; break;
+        case 6:
+                nCode = DEF_LINE_WIDTH_5;
+                eStyle = DOTTED;
+                break;
+        case 7:
+                nCode = DEF_LINE_WIDTH_5;
+                eStyle = DASHED;
+                break;
         }
         pLine->SetOutWidth(nCode);
         pLine->SetInWidth(0);
+        pLine->SetStyle( eStyle );
     }
     else
     {
diff --git sw/source/filter/ww8/docxattributeoutput.cxx sw/source/filter/ww8/docxattributeoutput.cxx
index 09d56cb..a47f600 100644
--- sw/source/filter/ww8/docxattributeoutput.cxx
+++ sw/source/filter/ww8/docxattributeoutput.cxx
@@ -1138,6 +1138,20 @@ static void impl_borderLine( FSHelperPtr pSerializer, sal_Int32 elementToken, co
             pVal = ( sal_Char* )"thickThinMediumGap";
         }
     }
+    else
+    {
+        switch ( pBorderLine->GetStyle( ) )
+        {
+            case DOTTED:
+                pVal = ( sal_Char* )"dotted";
+                break;
+            case DASHED:
+                pVal = ( sal_Char* )"dashed";
+                break;
+            default:
+                break;
+        }
+    }
 
     pAttr->add( FSNS( XML_w, XML_val ), OString( pVal ) );
 
diff --git sw/source/filter/ww8/wrtw8esh.cxx sw/source/filter/ww8/wrtw8esh.cxx
index 8c1dad3..dfc44d4 100644
--- sw/source/filter/ww8/wrtw8esh.cxx
+++ sw/source/filter/ww8/wrtw8esh.cxx
@@ -1703,6 +1703,21 @@ INT32 SwBasicEscherEx::WriteFlyFrameAttr(const SwFrmFmt& rFmt,
                     rPropOpt.AddOpt( ESCHER_Prop_lineStyle, eStyle );
                     rPropOpt.AddOpt( ESCHER_Prop_lineWidth,
                         DrawModelToEmu( nLineWidth ));
+
+                    MSO_LineDashing eDashing = mso_lineSolid;
+                    switch ( pLine->GetStyle( ) )
+                    {
+                        case  DASHED:
+                            eDashing = mso_lineDashGEL;
+                            break;
+                        case DOTTED:
+                            eDashing = mso_lineDotGEL;
+                            break;
+                        case SOLID:
+                        default:
+                            break;
+                    }
+                    rPropOpt.AddOpt( ESCHER_Prop_lineDashing, eDashing );
                     rPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x8000E );
 
                     //Use import logic to determine how much of border will go
diff --git sw/source/filter/ww8/ww8atr.cxx sw/source/filter/ww8/ww8atr.cxx
index 96cc093..63c39e2 100644
--- sw/source/filter/ww8/ww8atr.cxx
+++ sw/source/filter/ww8/ww8atr.cxx
@@ -4142,7 +4142,23 @@ WW8_BRC WW8Export::TranslateBorderLine(const SvxBorderLine& rLine,
         else if( bThick )
             brcType = 2;
         else
+        {
+
             brcType = 1;
+            if ( bWrtWW8 )
+            {
+                switch ( rLine.GetStyle( ) )
+                {
+                    case DOTTED:
+                        brcType = 6;
+                        break;
+                    case DASHED:
+                        brcType = 7;
+                    default:
+                        break;
+                }
+            }
+        }
 
         // BRC.dxpLineWidth
         if( bThick )
@@ -4161,6 +4177,10 @@ WW8_BRC WW8Export::TranslateBorderLine(const SvxBorderLine& rLine,
             nWidth = ( nWidth + 7 ) / 15;
             if( nWidth > 5 )
                 nWidth = 5;
+            if ( DOTTED == rLine.GetStyle( ) )
+                nWidth = 6;
+            else if ( DASHED == rLine.GetStyle( ) )
+                nWidth = 7;
         }
 
         if( 0 == nWidth )                       // ganz duenne Linie
diff --git sw/source/filter/ww8/ww8graf.cxx sw/source/filter/ww8/ww8graf.cxx
index 648f558..cf4b903 100644
--- sw/source/filter/ww8/ww8graf.cxx
+++ sw/source/filter/ww8/ww8graf.cxx
@@ -1132,6 +1132,7 @@ SwFrmFmt* SwWW8ImplReader::InsertTxbxText(SdrTextObj* pTextObj,
                         MatchSdrItemsIntoFlySet( pTextObj,
                                                  aFlySet,
                                                  pRecord->eLineStyle,
+                                                 pRecord->eLineDashing,
                                                  pRecord->eShapeType,
                                                  aInnerDist );
 
@@ -1477,23 +1478,25 @@ const WW8_BordersSO &WW8_BordersSO::Get0x01LineMatch(eBorderCode eCode)
     // Deklarationen gemaess BOXITEM.HXX
     static const WW8_BordersSO aLineTabVer8[] =
     {
-/* 0*/  { DEF_LINE_WIDTH_0, 0, 0 },
-/* 1*/  { DEF_LINE_WIDTH_1, 0, 0 },
-/* 2*/  { DEF_LINE_WIDTH_2, 0, 0 },
-/* 3*/  { DEF_LINE_WIDTH_3, 0, 0 },
-/* 4*/  { DEF_LINE_WIDTH_4, 0, 0 },
-/* 5*/  { DEF_LINE_WIDTH_5, 0, 0 },
-/* 6*/  { DEF_DOUBLE_LINE0_OUT, DEF_DOUBLE_LINE0_IN, DEF_DOUBLE_LINE0_DIST },
-/* 7*/  { DEF_DOUBLE_LINE1_OUT, DEF_DOUBLE_LINE1_IN, DEF_DOUBLE_LINE1_DIST },
-/* 8*/  { DEF_DOUBLE_LINE2_OUT, DEF_DOUBLE_LINE2_IN, DEF_DOUBLE_LINE2_DIST },
-/* 9*/  { DEF_DOUBLE_LINE3_OUT, DEF_DOUBLE_LINE3_IN, DEF_DOUBLE_LINE3_DIST },
-/*10*/  { DEF_DOUBLE_LINE4_OUT, DEF_DOUBLE_LINE4_IN, DEF_DOUBLE_LINE4_DIST },
-/*11*/  { DEF_DOUBLE_LINE5_OUT, DEF_DOUBLE_LINE5_IN, DEF_DOUBLE_LINE5_DIST },
-/*12*/  { DEF_DOUBLE_LINE6_OUT, DEF_DOUBLE_LINE6_IN, DEF_DOUBLE_LINE6_DIST },
-/*13*/  { DEF_DOUBLE_LINE7_OUT, DEF_DOUBLE_LINE7_IN, DEF_DOUBLE_LINE7_DIST },
-/*14*/  { DEF_DOUBLE_LINE8_OUT, DEF_DOUBLE_LINE8_IN, DEF_DOUBLE_LINE8_DIST },
-/*15*/  { DEF_DOUBLE_LINE9_OUT, DEF_DOUBLE_LINE9_IN, DEF_DOUBLE_LINE9_DIST },
-/*16*/  { DEF_DOUBLE_LINE10_OUT,DEF_DOUBLE_LINE10_IN,DEF_DOUBLE_LINE10_DIST}
+/* 0*/  { DEF_LINE_WIDTH_0, 0, 0, SOLID },
+/* 1*/  { DEF_LINE_WIDTH_1, 0, 0, SOLID },
+/* 2*/  { DEF_LINE_WIDTH_2, 0, 0, SOLID },
+/* 3*/  { DEF_LINE_WIDTH_3, 0, 0, SOLID },
+/* 4*/  { DEF_LINE_WIDTH_4, 0, 0, SOLID },
+/* 5*/  { DEF_LINE_WIDTH_5, 0, 0, SOLID },
+/* 6*/  { DEF_DOUBLE_LINE0_OUT, DEF_DOUBLE_LINE0_IN, DEF_DOUBLE_LINE0_DIST, SOLID },
+/* 7*/  { DEF_DOUBLE_LINE1_OUT, DEF_DOUBLE_LINE1_IN, DEF_DOUBLE_LINE1_DIST, SOLID },
+/* 8*/  { DEF_DOUBLE_LINE2_OUT, DEF_DOUBLE_LINE2_IN, DEF_DOUBLE_LINE2_DIST, SOLID },
+/* 9*/  { DEF_DOUBLE_LINE3_OUT, DEF_DOUBLE_LINE3_IN, DEF_DOUBLE_LINE3_DIST, SOLID },
+/*10*/  { DEF_DOUBLE_LINE4_OUT, DEF_DOUBLE_LINE4_IN, DEF_DOUBLE_LINE4_DIST, SOLID },
+/*11*/  { DEF_DOUBLE_LINE5_OUT, DEF_DOUBLE_LINE5_IN, DEF_DOUBLE_LINE5_DIST, SOLID },
+/*12*/  { DEF_DOUBLE_LINE6_OUT, DEF_DOUBLE_LINE6_IN, DEF_DOUBLE_LINE6_DIST, SOLID },
+/*13*/  { DEF_DOUBLE_LINE7_OUT, DEF_DOUBLE_LINE7_IN, DEF_DOUBLE_LINE7_DIST, SOLID },
+/*14*/  { DEF_DOUBLE_LINE8_OUT, DEF_DOUBLE_LINE8_IN, DEF_DOUBLE_LINE8_DIST, SOLID },
+/*15*/  { DEF_DOUBLE_LINE9_OUT, DEF_DOUBLE_LINE9_IN, DEF_DOUBLE_LINE9_DIST, SOLID },
+/*16*/  { DEF_DOUBLE_LINE10_OUT,DEF_DOUBLE_LINE10_IN,DEF_DOUBLE_LINE10_DIST, SOLID},
+/*17*/  { DEF_LINE_WIDTH_5, 0, 0, DASHED },
+/*18*/  { DEF_LINE_WIDTH_5, 0, 0, DOTTED }
     };
     size_t nPos = static_cast<size_t>(eCode);
     ASSERT(nPos < sizeof(aLineTabVer8), "Impossible");
@@ -1562,7 +1565,7 @@ INT32 SwMSDffManager::GetEscherLineMatch(MSO_LineStyle eStyle,
 //words positioning of borders around floating objects is that of a
 //disturbed mind.
 INT32 SwWW8ImplReader::MatchSdrBoxIntoFlyBoxItem(const Color& rLineColor,
-    MSO_LineStyle eLineStyle, MSO_SPT eShapeType, INT32 &rLineThick,
+    MSO_LineStyle eLineStyle, MSO_LineDashing eDashing, MSO_SPT eShapeType, INT32 &rLineThick,
     SvxBoxItem& rBox )
 {
     INT32 nOutsideThick = 0;
@@ -1657,6 +1660,18 @@ INT32 SwWW8ImplReader::MatchSdrBoxIntoFlyBoxItem(const Color& rLineColor,
         break;
     }
 
+    switch( eDashing )
+    {
+        case mso_lineDashGEL:
+            nIdx = WW8_BordersSO::dashed;
+            break;
+        case mso_lineDotGEL:
+            nIdx = WW8_BordersSO::dotted;
+            break;
+        default:
+            break;
+    }
+
     if (WW8_BordersSO::none != nIdx)
     {
         SvxBorderLine aLine;
@@ -1667,6 +1682,7 @@ INT32 SwWW8ImplReader::MatchSdrBoxIntoFlyBoxItem(const Color& rLineColor,
         aLine.SetOutWidth(rBorders.mnOut);
         aLine.SetInWidth (rBorders.mnIn);
         aLine.SetDistance(rBorders.mnDist);
+        aLine.SetStyle( rBorders.mnType );
 
         for(USHORT nLine = 0; nLine < 4; ++nLine)
             rBox.SetLine(new SvxBorderLine( aLine ), nLine);
@@ -1678,7 +1694,7 @@ INT32 SwWW8ImplReader::MatchSdrBoxIntoFlyBoxItem(const Color& rLineColor,
 #define WW8ITEMVALUE(ItemSet,Id,Cast)  ((const Cast&)(ItemSet).Get(Id)).GetValue()
 
 void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
-    SfxItemSet& rFlySet, MSO_LineStyle eLineStyle, MSO_SPT eShapeType,
+    SfxItemSet& rFlySet, MSO_LineStyle eLineStyle, MSO_LineDashing eDashing, MSO_SPT eShapeType,
     Rectangle& rInnerDist )
 {
 /*
@@ -1740,7 +1756,7 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
             nLineThick = 15; // WW-default: 0.75 pt
 
         nOutside = MatchSdrBoxIntoFlyBoxItem(aLineColor, eLineStyle,
-            eShapeType, nLineThick, aBox);
+            eDashing, eShapeType, nLineThick, aBox);
     }
 
     rInnerDist.Left()+=nLineThick;
@@ -3008,7 +3024,7 @@ SwFlyFrmFmt* SwWW8ImplReader::ConvertDrawTextToFly(SdrObject* &rpObject,
         rFlySet.Put(aFrmSize);
 
         MatchSdrItemsIntoFlySet( rpObject, rFlySet, pRecord->eLineStyle,
-            pRecord->eShapeType, aInnerDist );
+            pRecord->eLineDashing, pRecord->eShapeType, aInnerDist );
 
 
         SdrTextObj *pSdrTextObj = PTR_CAST(SdrTextObj, rpObject);
@@ -3133,7 +3149,7 @@ SwFlyFrmFmt* SwWW8ImplReader::ImportReplaceableDrawables( SdrObject* &rpObject,
         Rectangle aInnerDist(0, 0, 0, 0);
 
         MatchSdrItemsIntoFlySet(rpObject, rFlySet, pRecord->eLineStyle,
-            pRecord->eShapeType, aInnerDist);
+            pRecord->eLineDashing, pRecord->eShapeType, aInnerDist);
 
         MatchEscherMirrorIntoFlySet(*pRecord, aGrSet);
     }
diff --git sw/source/filter/ww8/ww8graf2.cxx sw/source/filter/ww8/ww8graf2.cxx
index 0c7f6a9..098a840 100644
--- sw/source/filter/ww8/ww8graf2.cxx
+++ sw/source/filter/ww8/ww8graf2.cxx
@@ -633,8 +633,8 @@ SwFrmFmt* SwWW8ImplReader::ImportGraf(SdrTextObj* pTextObj,
                         pRecord->nDyTextBottom  );
 
                     MatchSdrItemsIntoFlySet( pObject, aAttrSet,
-                        pRecord->eLineStyle, pRecord->eShapeType,
-                        aInnerDist );
+                        pRecord->eLineStyle, pRecord->eLineDashing,
+                        pRecord->eShapeType, aInnerDist );
 
                     //Groesse aus der WinWord PIC-Struktur als
                     //Grafik-Groesse nehmen
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index fcdb260..160efad 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -900,6 +900,8 @@ SdrObject* SwMSDffManager::ProcessObj(SvStream& rSt,
                                                     DFF_Prop_lineStyle,
                                                     mso_lineSimple )
                               : (MSO_LineStyle)USHRT_MAX;
+        pImpRec->eLineDashing = (MSO_LineDashing)GetPropertyValue(
+                                        DFF_Prop_lineDashing, mso_lineSolid );
 
         pImpRec->nFlags = rObjData.nSpFlags;
 
@@ -3558,7 +3560,7 @@ void wwSectionManager::SetSegmentToPageDesc(const wwSection &rSection,
             {
                 SfxItemSet aSet(rFmt.GetAttrSet());
                 mrReader.MatchSdrItemsIntoFlySet(pObject, aSet, mso_lineSimple,
-                                                 mso_sptRectangle, aRect);
+                                                 mso_lineSolid, mso_sptRectangle, aRect);
                 rFmt.SetFmtAttr(aSet.Get(RES_BACKGROUND));
             }
         }
diff --git sw/source/filter/ww8/ww8par.hxx sw/source/filter/ww8/ww8par.hxx
index 7ed6d70..52a7113 100644
--- sw/source/filter/ww8/ww8par.hxx
+++ sw/source/filter/ww8/ww8par.hxx
@@ -1201,10 +1201,10 @@ private:
     void SetPageBorder(SwFrmFmt &rFmt, const wwSection &rSection) const;
 
     INT32 MatchSdrBoxIntoFlyBoxItem( const Color& rLineColor,
-        MSO_LineStyle eLineStyle, MSO_SPT eShapeType, INT32 &rLineWidth,
+        MSO_LineStyle eLineStyle, MSO_LineDashing eDashing, MSO_SPT eShapeType, INT32 &rLineWidth,
         SvxBoxItem& rBox );
     void MatchSdrItemsIntoFlySet( SdrObject*    pSdrObj, SfxItemSet &aFlySet,
-        MSO_LineStyle eLineStyle, MSO_SPT eShapeType, Rectangle &rInnerDist );
+        MSO_LineStyle eLineStyle, MSO_LineDashing eDashing, MSO_SPT eShapeType, Rectangle &rInnerDist );
     void AdjustLRWrapForWordMargins(const SvxMSDffImportRec &rRecord,
         SvxLRSpaceItem &rLR);
     void AdjustULWrapForWordMargins(const SvxMSDffImportRec &rRecord,
diff --git sw/source/filter/ww8/ww8par6.cxx sw/source/filter/ww8/ww8par6.cxx
index 9d0f9b0..90ff9ce 100644
--- sw/source/filter/ww8/ww8par6.cxx
+++ sw/source/filter/ww8/ww8par6.cxx
@@ -1325,13 +1325,17 @@ void GetLineIndex(SvxBoxItem &rBox, short nLineThickness, short nSpace, BYTE nCo
     // object size
     switch (nIdx)
     {
+        case  6:
+            eCodeIdx = WW8_BordersSO::dotted;
+            break;
+        case  7:
+            eCodeIdx = WW8_BordersSO::dashed;
+            break;
         // First the single lines
         case  1:
         case  2:
         case  5:
         // and the unsupported special cases which we map to a single line
-        case  6:
-        case  7:
         case  8:
         case  9:
         case 22:
@@ -1456,6 +1460,7 @@ void GetLineIndex(SvxBoxItem &rBox, short nLineThickness, short nSpace, BYTE nCo
     aLine.SetOutWidth(rBorders.mnOut);
     aLine.SetInWidth(rBorders.mnIn);
     aLine.SetDistance(rBorders.mnDist);
+    aLine.SetStyle( rBorders.mnType );
 
     //No AUTO for borders as yet, so if AUTO, use BLACK
     if (nCol == 0)
@@ -1574,7 +1579,7 @@ bool SwWW8ImplReader::SetShadow(SvxShadowItem& rShadow, const short *pSizeArray,
     const WW8_BRC *pbrc) const
 {
     bool bRet = (
-                ( bVer67 ? (pbrc[WW8_RIGHT].aBits1[ 1 ] & 0x20 )
+                ( bVer67 ? (pbrc[WW8_RIGHT].aBits1[ 0 ] & 0x20 )
                          : (pbrc[WW8_RIGHT].aBits2[ 1 ] & 0x20 ) )
                 && (pSizeArray && pSizeArray[WW8_RIGHT])
                 );
diff --git sw/source/filter/ww8/ww8scan.cxx sw/source/filter/ww8/ww8scan.cxx
index c5d1a17..969f7c6 100644
--- sw/source/filter/ww8/ww8scan.cxx
+++ sw/source/filter/ww8/ww8scan.cxx
@@ -1286,8 +1286,8 @@ short WW8_BRC::DetermineBorderProperties(bool bVer67, short *pSpace,
         //Dashed/Dotted unsets double/thick
         if (nMSTotalWidth > 5)
         {
+            nIdx = nMSTotalWidth;
             nMSTotalWidth=1;
-            nIdx = 1;
         }
         nMSTotalWidth = nMSTotalWidth * nIdx * 15;
     }
diff --git sw/source/filter/ww8/ww8struc.hxx sw/source/filter/ww8/ww8struc.hxx
index 4073322..99a416f 100644
--- sw/source/filter/ww8/ww8struc.hxx
+++ sw/source/filter/ww8/ww8struc.hxx
@@ -34,6 +34,8 @@
 #include <tools/string.hxx>
 #include <sal/config.h>
 
+#include <editeng/borderline.hxx>
+
 #if defined  OSL_BIGENDIAN || SAL_TYPES_ALIGNMENT4 > 2 || defined UNX
 #   define __WW8_NEEDS_COPY
 #endif
@@ -289,12 +291,14 @@ public:
     USHORT mnOut;
     USHORT mnIn;
     USHORT mnDist;
+    SvxBorderStyle mnType;
 public:
     enum eBorderCode
     {
         single0, single1, single2, single3, single4, single5,
         double0, double1, double2, double3, double4, double5, double6,
         double7, double8, double9, double10,
+        dashed, dotted,
         none
     };
     static const WW8_BordersSO &Get0x01LineMatch(eBorderCode nIdx);
diff --git sw/source/filter/xml/xmlexpit.cxx sw/source/filter/xml/xmlexpit.cxx
index e0a73ca..71baa3c 100644
--- sw/source/filter/xml/xmlexpit.cxx
+++ sw/source/filter/xml/xmlexpit.cxx
@@ -695,8 +695,18 @@ sal_Bool SvXMLExportItemMapper::QueryXMLValue(
                             nWidth += pLine->GetInWidth();
                         }
 
-                        enum XMLTokenEnum eStyle =
-                            (0 == nDistance) ? XML_SOLID : XML_DOUBLE;
+                        enum XMLTokenEnum eStyle = XML_SOLID;
+                        switch ( pLine->GetStyle( ) )
+                        {
+                            case DOTTED:
+                               eStyle = XML_DOTTED;
+                               break;
+                            case DASHED:
+                               eStyle = XML_DASHED;
+                               break;
+                            default:
+                            eStyle = (0 == nDistance) ? XML_SOLID : XML_DOUBLE;
+                        }
 
                         rUnitConverter.convertMeasure( aOut, nWidth );
                         aOut.append( sal_Unicode( ' ' ) );
diff --git sw/source/filter/xml/xmlithlp.cxx sw/source/filter/xml/xmlithlp.cxx
index c7009c4..5294806 100644
--- sw/source/filter/xml/xmlithlp.cxx
+++ sw/source/filter/xml/xmlithlp.cxx
@@ -55,6 +55,8 @@ using namespace ::com::sun::star;
 #define SVX_XML_BORDER_STYLE_NONE 0
 #define SVX_XML_BORDER_STYLE_SOLID 1
 #define SVX_XML_BORDER_STYLE_DOUBLE 2
+#define SVX_XML_BORDER_STYLE_DOTTED 3
+#define SVX_XML_BORDER_STYLE_DASHED 4
 
 #define SVX_XML_BORDER_WIDTH_THIN 0
 #define SVX_XML_BORDER_WIDTH_MIDDLE 1
@@ -67,8 +69,8 @@ const struct SvXMLEnumMapEntry psXML_BorderStyles[] =
     { XML_HIDDEN,     SVX_XML_BORDER_STYLE_NONE },
     { XML_SOLID,      SVX_XML_BORDER_STYLE_SOLID },
     { XML_DOUBLE,     SVX_XML_BORDER_STYLE_DOUBLE },
-    { XML_DOTTED,     SVX_XML_BORDER_STYLE_SOLID },
-    { XML_DASHED,     SVX_XML_BORDER_STYLE_SOLID },
+    { XML_DOTTED,     SVX_XML_BORDER_STYLE_DOTTED },
+    { XML_DASHED,     SVX_XML_BORDER_STYLE_DASHED },
     { XML_GROOVE,     SVX_XML_BORDER_STYLE_SOLID },
     { XML_RIDGE,      SVX_XML_BORDER_STYLE_SOLID },
     { XML_INSET,      SVX_XML_BORDER_STYLE_SOLID },
@@ -179,6 +181,23 @@ sal_Bool lcl_frmitems_parseXMLBorder( const OUString& rValue,
     return rHasStyle || rHasWidth || rHasColor;
 }
 
+void lcl_frmitems_setXMLBorderStyle( SvxBorderLine& rLine, sal_uInt16 nStyle )
+{
+    SvxBorderStyle eStyle = SOLID;
+    switch ( nStyle )
+    {
+        case SVX_XML_BORDER_STYLE_DOTTED:
+            eStyle = DOTTED;
+            break;
+        case SVX_XML_BORDER_STYLE_DASHED:
+            eStyle = DASHED;
+            break;
+        default:
+            eStyle = SOLID;
+    }
+    rLine.SetStyle( eStyle );
+}
+
 void lcl_frmitems_setXMLBorderWidth( SvxBorderLine& rLine,
                                      sal_uInt16 nOutWidth, sal_uInt16 nInWidth,
                                      sal_uInt16 nDistance )
@@ -266,7 +285,6 @@ sal_Bool lcl_frmitems_setXMLBorder( SvxBorderLine*& rpLine,
            rpLine->SetOutWidth( aWidths[nNWidth+1] );
            rpLine->SetInWidth( aWidths[nNWidth+2] );
            rpLine->SetDistance( aWidths[nNWidth+3] );
-
        }
        else
        {
@@ -276,6 +294,7 @@ sal_Bool lcl_frmitems_setXMLBorder( SvxBorderLine*& rpLine,
 
            lcl_frmitems_setXMLBorderWidth( *rpLine, nWidth, bDouble );
        }
+       lcl_frmitems_setXMLBorderStyle( *rpLine, nStyle );
    }
 
     // set color
diff --git writerfilter/source/dmapper/BorderHandler.cxx writerfilter/source/dmapper/BorderHandler.cxx
index 9e034fe..497b918 100644
--- writerfilter/source/dmapper/BorderHandler.cxx
+++ writerfilter/source/dmapper/BorderHandler.cxx
@@ -29,7 +29,7 @@
 #include <resourcemodel/QNameToString.hxx>
 #include <doctok/resourceids.hxx>
 #include <ConversionHelper.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <ooxml/resourceids.hxx>
 #include <dmapperLoggers.hxx>
 
@@ -190,9 +190,9 @@ PropertyMapPtr  BorderHandler::getProperties()
 /*-- 14.11.2007 12:42:52---------------------------------------------------
     used only in OOXML import
   -----------------------------------------------------------------------*/
-table::BorderLine BorderHandler::getBorderLine()
+table::BorderLine2 BorderHandler::getBorderLine()
 {
-    table::BorderLine aBorderLine;
+    table::BorderLine2 aBorderLine;
     ConversionHelper::MakeBorderLine( m_nLineWidth, m_nLineType, m_nLineColor, aBorderLine, m_bOOXML );
     return aBorderLine;
 }
diff --git writerfilter/source/dmapper/BorderHandler.hxx writerfilter/source/dmapper/BorderHandler.hxx
index 6502361..343fd41 100644
--- writerfilter/source/dmapper/BorderHandler.hxx
+++ writerfilter/source/dmapper/BorderHandler.hxx
@@ -30,7 +30,7 @@
 #include <WriterFilterDllApi.hxx>
 #include <resourcemodel/WW8ResourceModel.hxx>
 #include <boost/shared_ptr.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 
 namespace writerfilter {
 namespace dmapper
@@ -61,7 +61,7 @@ private:
     bool            m_bOOXML;
 
     bool                                        m_aFilledLines[BORDER_COUNT];
-    ::com::sun::star::table::BorderLine         m_aBorderLines[BORDER_COUNT];
+    ::com::sun::star::table::BorderLine2        m_aBorderLines[BORDER_COUNT];
 
 public:
     BorderHandler( bool bOOXML );
@@ -72,7 +72,7 @@ public:
     virtual void sprm(Sprm & sprm);
 
     ::boost::shared_ptr<PropertyMap>            getProperties();
-    ::com::sun::star::table::BorderLine         getBorderLine();
+    ::com::sun::star::table::BorderLine2        getBorderLine();
     sal_Int32                                   getLineDistance() const { return m_nLineDistance;}
 };
 typedef boost::shared_ptr< BorderHandler >          BorderHandlerPtr;
diff --git writerfilter/source/dmapper/CellColorHandler.hxx writerfilter/source/dmapper/CellColorHandler.hxx
index ebbf4ac..9ee25eb 100644
--- writerfilter/source/dmapper/CellColorHandler.hxx
+++ writerfilter/source/dmapper/CellColorHandler.hxx
@@ -30,8 +30,6 @@
 #include <WriterFilterDllApi.hxx>
 #include <resourcemodel/WW8ResourceModel.hxx>
 #include <boost/shared_ptr.hpp>
-//#include <com/sun/star/table/TableBorder.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
 
 namespace writerfilter {
 namespace dmapper
diff --git writerfilter/source/dmapper/ConversionHelper.cxx writerfilter/source/dmapper/ConversionHelper.cxx
index 85fc040..e101fd2 100644
--- writerfilter/source/dmapper/ConversionHelper.cxx
+++ writerfilter/source/dmapper/ConversionHelper.cxx
@@ -25,7 +25,7 @@
  *
  ************************************************************************/
 #include <ConversionHelper.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/lang/Locale.hpp>
 #include <com/sun/star/text/HoriOrientation.hpp>
 #include <com/sun/star/style/NumberingType.hpp>
@@ -41,6 +41,10 @@ namespace writerfilter {
 namespace dmapper{
 namespace ConversionHelper{
 
+const sal_Int16  API_LINE_SOLID    = 0;
+const sal_Int16  API_LINE_DOTTED   = 1;
+const sal_Int16  API_LINE_DASHED   = 2;
+
 #define TWIP_TO_MM100(TWIP)     ((TWIP) >= 0 ? (((TWIP)*127L+36L)/72L) : (((TWIP)*127L-36L)/72L))
 
 //line definitions in 1/100 mm
@@ -95,7 +99,7 @@ namespace ConversionHelper{
 #define DOUBLE_LINE10_IN    LINE_WIDTH_0
 #define DOUBLE_LINE10_DIST  LINE_WIDTH_2
 
-sal_Int32 MakeBorderLine( sal_Int32 nSprmValue, table::BorderLine& rToFill )
+sal_Int32 MakeBorderLine( sal_Int32 nSprmValue, table::BorderLine2& rToFill )
 {
     //TODO: Lines are always solid
     //Border
@@ -120,7 +124,7 @@ sal_Int32 MakeBorderLine( sal_Int32 nSprmValue, table::BorderLine& rToFill )
 }
 void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
                                             sal_Int32 nLineColor,
-                                            table::BorderLine& rToFill, bool bIsOOXML )
+                                            table::BorderLine2& rToFill, bool bIsOOXML )
 {
     static const sal_Int32 aBorderDefColor[] =
     {
@@ -141,7 +145,7 @@ void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
         single0, single1, single2, single3, single4, single5,
         double0, double1, double2, double3, double4, double5, double6,
         double7, double8, double9, double10,
-        none
+        none, dashed, dotted
     } eCodeIdx = none;
 
     // Map to our border types, we should use of one equal line
@@ -154,9 +158,14 @@ void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
         case  1: break;
         case  2:
         case  5:
-        // and the unsupported special cases which we map to a single line
+        // Dotted and dashed lines
         case  6:
+                 eCodeIdx = dotted;
+                 break;
         case  7:
+                 eCodeIdx = dashed;
+                 break;
+        // and the unsupported special cases which we map to a single line
         case  8:
         case  9:
         case 22:
@@ -284,29 +293,32 @@ void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
         sal_Int16 nOut;
         sal_Int16 nIn;
         sal_Int16 nDist;
+        sal_Int16 eStyle;
     };
 
 
     static const BorderDefinition aLineTab[] =
     {
-        /* 0*/  { LINE_WIDTH_0, 0, 0 },
-        /* 1*/  { LINE_WIDTH_1, 0, 0 },
-        /* 2*/  { LINE_WIDTH_2, 0, 0 },
-        /* 3*/  { LINE_WIDTH_3, 0, 0 },
-        /* 4*/  { LINE_WIDTH_4, 0, 0 },
-        /* 5*/  { LINE_WIDTH_5, 0, 0 },
-        /* 6*/  { DOUBLE_LINE0_OUT, DOUBLE_LINE0_IN, DOUBLE_LINE0_DIST },
-        /* 7*/  { DOUBLE_LINE1_OUT, DOUBLE_LINE1_IN, DOUBLE_LINE1_DIST },
-        /* 8*/  { DOUBLE_LINE2_OUT, DOUBLE_LINE2_IN, DOUBLE_LINE2_DIST },
-        /* 9*/  { DOUBLE_LINE3_OUT, DOUBLE_LINE3_IN, DOUBLE_LINE3_DIST },
-        /*10*/  { DOUBLE_LINE4_OUT, DOUBLE_LINE4_IN, DOUBLE_LINE4_DIST },
-        /*11*/  { DOUBLE_LINE5_OUT, DOUBLE_LINE5_IN, DOUBLE_LINE5_DIST },
-        /*12*/  { DOUBLE_LINE6_OUT, DOUBLE_LINE6_IN, DOUBLE_LINE6_DIST },
-        /*13*/  { DOUBLE_LINE7_OUT, DOUBLE_LINE7_IN, DOUBLE_LINE7_DIST },
-        /*14*/  { DOUBLE_LINE8_OUT, DOUBLE_LINE8_IN, DOUBLE_LINE8_DIST },
-        /*15*/  { DOUBLE_LINE9_OUT, DOUBLE_LINE9_IN, DOUBLE_LINE9_DIST },
-        /*16*/  { DOUBLE_LINE10_OUT,DOUBLE_LINE10_IN,DOUBLE_LINE10_DIST},
-        /*17*/  { 0, 0, 0 }
+        /* 0*/  { LINE_WIDTH_0, 0, 0, API_LINE_SOLID },
+        /* 1*/  { LINE_WIDTH_1, 0, 0, API_LINE_SOLID },
+        /* 2*/  { LINE_WIDTH_2, 0, 0, API_LINE_SOLID },
+        /* 3*/  { LINE_WIDTH_3, 0, 0, API_LINE_SOLID },
+        /* 4*/  { LINE_WIDTH_4, 0, 0, API_LINE_SOLID },
+        /* 5*/  { LINE_WIDTH_5, 0, 0, API_LINE_SOLID },
+        /* 6*/  { DOUBLE_LINE0_OUT, DOUBLE_LINE0_IN, DOUBLE_LINE0_DIST, API_LINE_SOLID },
+        /* 7*/  { DOUBLE_LINE1_OUT, DOUBLE_LINE1_IN, DOUBLE_LINE1_DIST, API_LINE_SOLID },
+        /* 8*/  { DOUBLE_LINE2_OUT, DOUBLE_LINE2_IN, DOUBLE_LINE2_DIST, API_LINE_SOLID },
+        /* 9*/  { DOUBLE_LINE3_OUT, DOUBLE_LINE3_IN, DOUBLE_LINE3_DIST, API_LINE_SOLID },
+        /*10*/  { DOUBLE_LINE4_OUT, DOUBLE_LINE4_IN, DOUBLE_LINE4_DIST, API_LINE_SOLID },
+        /*11*/  { DOUBLE_LINE5_OUT, DOUBLE_LINE5_IN, DOUBLE_LINE5_DIST, API_LINE_SOLID },
+        /*12*/  { DOUBLE_LINE6_OUT, DOUBLE_LINE6_IN, DOUBLE_LINE6_DIST, API_LINE_SOLID },
+        /*13*/  { DOUBLE_LINE7_OUT, DOUBLE_LINE7_IN, DOUBLE_LINE7_DIST, API_LINE_SOLID },
+        /*14*/  { DOUBLE_LINE8_OUT, DOUBLE_LINE8_IN, DOUBLE_LINE8_DIST, API_LINE_SOLID },
+        /*15*/  { DOUBLE_LINE9_OUT, DOUBLE_LINE9_IN, DOUBLE_LINE9_DIST, API_LINE_SOLID },
+        /*16*/  { DOUBLE_LINE10_OUT,DOUBLE_LINE10_IN,DOUBLE_LINE10_DIST, API_LINE_SOLID},
+        /*17*/  { 0, 0, 0, API_LINE_SOLID },
+        /*18*/  { LINE_WIDTH_5, 0, 0, API_LINE_DASHED },
+        /*19*/  { LINE_WIDTH_5, 0, 0, API_LINE_DOTTED }
     };
 
     rToFill.Color = nLineColor;
@@ -315,13 +327,14 @@ void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
         rToFill.InnerLineWidth = 0;
         rToFill.OuterLineWidth = sal_Int16(nLineThickness);
         rToFill.LineDistance = 0;
-
+        rToFill.LineStyle = API_LINE_SOLID;
     }
     else
     {
         rToFill.InnerLineWidth = aLineTab[eCodeIdx].nIn;
         rToFill.OuterLineWidth = aLineTab[eCodeIdx].nOut;
         rToFill.LineDistance = aLineTab[eCodeIdx].nDist;
+        rToFill.LineStyle = aLineTab[eCodeIdx].eStyle;
     }
 }
 
diff --git writerfilter/source/dmapper/ConversionHelper.hxx writerfilter/source/dmapper/ConversionHelper.hxx
index d635a6e..e1747e8 100644
--- writerfilter/source/dmapper/ConversionHelper.hxx
+++ writerfilter/source/dmapper/ConversionHelper.hxx
@@ -30,12 +30,13 @@
 #include <sal/types.h>
 #include <rtl/ustring.hxx>
 #include <com/sun/star/util/DateTime.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 namespace com{ namespace sun{ namespace star{
     namespace lang{
         struct Locale;
     }
     namespace table{
-        struct BorderLine;
+        struct BorderLine2;
 }}}}
 
 namespace writerfilter {
@@ -43,10 +44,10 @@ namespace dmapper{
 namespace ConversionHelper{
 
     // create a border line and return the distance value
-    sal_Int32 MakeBorderLine( sal_Int32 nSprmValue, ::com::sun::star::table::BorderLine& rToFill );
+    sal_Int32 MakeBorderLine( sal_Int32 nSprmValue, ::com::sun::star::table::BorderLine2& rToFill );
     void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
                               sal_Int32 nLineColor,
-                              ::com::sun::star::table::BorderLine& rToFill, bool bIsOOXML );
+                              ::com::sun::star::table::BorderLine2& rToFill, bool bIsOOXML );
     //convert the number format string form MS format to SO format
     ::rtl::OUString ConvertMSFormatStringToSO(
             const ::rtl::OUString& rFormat, ::com::sun::star::lang::Locale& rLocale, bool bHijri);
diff --git writerfilter/source/dmapper/DomainMapper.cxx writerfilter/source/dmapper/DomainMapper.cxx
index 18bd3c9..14143a5 100644
--- writerfilter/source/dmapper/DomainMapper.cxx
+++ writerfilter/source/dmapper/DomainMapper.cxx
@@ -1,4 +1,4 @@
-/*************************************************************************
+#/*************************************************************************
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  * 
@@ -66,7 +66,7 @@
 #include <com/sun/star/style/CaseMap.hpp>
 #include <com/sun/star/style/LineSpacing.hpp>
 #include <com/sun/star/style/LineSpacingMode.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/TextGridMode.hpp>
 #include <com/sun/star/text/XDocumentIndexesSupplier.hpp>
 #include <com/sun/star/text/WritingMode.hpp>
@@ -1276,7 +1276,7 @@ void DomainMapper::attribute(Id nName, Value & val)
         case NS_rtf::LN_BRCRIGHT:
             /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             sal_Int32 nLineDistance = ConversionHelper::MakeBorderLine( nIntValue, aBorderLine );
             (void)nLineDistance;
             PropertyIds eBorderId = PROP_LEFT_BORDER;
@@ -2531,7 +2531,7 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
             }
             else
             {
-                table::BorderLine aBorderLine;
+                table::BorderLine2 aBorderLine;
                 sal_Int32 nLineDistance = ConversionHelper::MakeBorderLine( nIntValue, aBorderLine );
                 PropertyIds eBorderId = PROP_LEFT_BORDER;
                 PropertyIds eBorderDistId = PROP_LEFT_BORDER_DISTANCE  ;
@@ -3538,7 +3538,7 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
     case NS_sprm::LN_SBrcRight:  // sprmSBrcRight
         /* WRITERFILTERSTATUS: Sectiondone: 100, planned: 0.5, spent: 0 */
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             sal_Int32 nLineDistance = ConversionHelper::MakeBorderLine( nIntValue, aBorderLine );
             OSL_ENSURE(pSectionContext, "SectionContext unavailable!");
             if(pSectionContext)
diff --git writerfilter/source/dmapper/DomainMapperTableHandler.cxx writerfilter/source/dmapper/DomainMapperTableHandler.cxx
index 3da51d9..801693c 100644
--- writerfilter/source/dmapper/DomainMapperTableHandler.cxx
+++ writerfilter/source/dmapper/DomainMapperTableHandler.cxx
@@ -29,6 +29,7 @@
 #include <StyleSheetTable.hxx>
 #include <com/sun/star/table/TableBorderDistances.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/HoriOrientation.hpp>
 #include <dmapperLoggers.hxx>
 
@@ -65,7 +66,7 @@ static void  lcl_printProperties( PropertyMapPtr pProps )
             rtl::OString aOStr(aOUStr.getStr(), aOUStr.getLength(),  RTL_TEXTENCODING_ASCII_US );
             clog << aOStr.getStr();
 
-            table::BorderLine aLine;
+            table::BorderLine2 aLine;
             sal_Int32 nColor; 
             if ( aMapIter->second >>= aLine )
             {
diff --git writerfilter/source/dmapper/DomainMapper_Impl.cxx writerfilter/source/dmapper/DomainMapper_Impl.cxx
index 48fb1f5..4771786 100644
--- writerfilter/source/dmapper/DomainMapper_Impl.cxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.cxx
@@ -40,7 +40,7 @@
 #include <com/sun/star/style/LineNumberPosition.hpp>
 #include <com/sun/star/style/NumberingType.hpp>
 #include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/ChapterFormat.hpp>
 #include <com/sun/star/text/FilenameDisplayFormat.hpp>
 #include <com/sun/star/text/UserDataPart.hpp>
@@ -574,7 +574,7 @@ void lcl_MoveBorderPropertiesToFrame(uno::Sequence<beans::PropertyValue>& rFrame
             pFrameProperties[nStart].Name = sPropertyName;
             pFrameProperties[nStart].Value = xTextRangeProperties->getPropertyValue(sPropertyName);
             if( nProperty < 4 )
-                xTextRangeProperties->setPropertyValue( sPropertyName, uno::makeAny(table::BorderLine()));
+                xTextRangeProperties->setPropertyValue( sPropertyName, uno::makeAny(table::BorderLine2()));
             ++nStart;
         }
         rFrameProperties.realloc(nStart);
diff --git writerfilter/source/dmapper/GraphicImport.cxx writerfilter/source/dmapper/GraphicImport.cxx
index 41eb96b..7af95bf 100644
--- writerfilter/source/dmapper/GraphicImport.cxx
+++ writerfilter/source/dmapper/GraphicImport.cxx
@@ -43,7 +43,7 @@
 #include <com/sun/star/graphic/XGraphicProvider.hpp>
 #include <com/sun/star/graphic/XGraphic.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/GraphicCrop.hpp>
 #include <com/sun/star/text/XTextContent.hpp>
 #include <com/sun/star/text/TextContentAnchorType.hpp>
@@ -1532,7 +1532,7 @@ uno::Reference< text::XTextContent > GraphicImport::createGraphicObject( const b
             xGraphicObject = uno::Reference< text::XTextContent >( xGraphicObjectProperties, uno::UNO_QUERY_THROW );
 
             //shapes have only one border, PICF might have four
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             for( sal_Int32 nBorder = 0; nBorder < 4; ++nBorder )
             {
                 if( m_pImpl->eGraphicImportType == IMPORT_AS_GRAPHIC || !nBorder )
diff --git writerfilter/source/dmapper/PageBordersHandler.hxx writerfilter/source/dmapper/PageBordersHandler.hxx
index 88d8370..196c8b8 100644
--- writerfilter/source/dmapper/PageBordersHandler.hxx
+++ writerfilter/source/dmapper/PageBordersHandler.hxx
@@ -8,7 +8,7 @@
 #include <resourcemodel/WW8ResourceModel.hxx>
 #include <boost/shared_ptr.hpp>
 
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 
 #include <vector>
 
@@ -19,7 +19,7 @@ namespace dmapper {
 class _PgBorder
 {
 public:
-    com::sun::star::table::BorderLine m_rLine;
+    com::sun::star::table::BorderLine2 m_rLine;
     sal_Int32   m_nDistance;
     BorderPosition m_ePos;
 
diff --git writerfilter/source/dmapper/PropertyMap.cxx writerfilter/source/dmapper/PropertyMap.cxx
index 447cb6c..d9ff407 100644
--- writerfilter/source/dmapper/PropertyMap.cxx
+++ writerfilter/source/dmapper/PropertyMap.cxx
@@ -31,7 +31,7 @@
 #include <i18npool/paper.hxx>
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/container/XEnumeration.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
@@ -407,10 +407,10 @@ uno::Reference< beans::XPropertySet > SectionPropertyMap::GetPageStyle(
 /*-- 28.07.2006 10:56:26---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SectionPropertyMap::SetBorder( BorderPosition ePos, sal_Int32 nLineDistance, const table::BorderLine& rBorderLine )
+void SectionPropertyMap::SetBorder( BorderPosition ePos, sal_Int32 nLineDistance, const table::BorderLine2& rBorderLine )
 {
     delete m_pBorderLines[ePos];
-    m_pBorderLines[ePos] = new table::BorderLine( rBorderLine );
+    m_pBorderLines[ePos] = new table::BorderLine2( rBorderLine );
     m_nBorderDistances[ePos] = nLineDistance;
 }
 /*-- 28.07.2006 10:56:27---------------------------------------------------
diff --git writerfilter/source/dmapper/PropertyMap.hxx writerfilter/source/dmapper/PropertyMap.hxx
index f06cced..1a34b6b 100644
--- writerfilter/source/dmapper/PropertyMap.hxx
+++ writerfilter/source/dmapper/PropertyMap.hxx
@@ -60,7 +60,7 @@ namespace com{namespace sun{namespace star{
         class XFootnote;
     }
     namespace table{
-        struct BorderLine;
+        struct BorderLine2;
     }
 }}}
 
@@ -162,7 +162,7 @@ class SectionPropertyMap : public PropertyMap
     ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >   m_aFirstPageStyle;
     ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >   m_aFollowPageStyle;
 
-    ::com::sun::star::table::BorderLine*    m_pBorderLines[4];
+    ::com::sun::star::table::BorderLine2*   m_pBorderLines[4];
     sal_Int32                               m_nBorderDistances[4];
     sal_Int32                               m_nBorderParams;
 
@@ -238,7 +238,7 @@ public:
             const ::com::sun::star::uno::Reference < ::com::sun::star::lang::XMultiServiceFactory >& xTextFactory,
             bool bFirst );
 
-    void SetBorder( BorderPosition ePos, sal_Int32 nLineDistance, const ::com::sun::star::table::BorderLine& rBorderLine );
+    void SetBorder( BorderPosition ePos, sal_Int32 nLineDistance, const ::com::sun::star::table::BorderLine2& rBorderLine );
     void SetBorderParams( sal_Int32 nSet ) { m_nBorderParams = nSet; }
 
     void SetColumnCount( sal_Int16 nCount ) { m_nColumnCount = nCount; }
diff --git writerfilter/source/dmapper/TDefTableHandler.cxx writerfilter/source/dmapper/TDefTableHandler.cxx
index 1df312c..51af738 100644
--- writerfilter/source/dmapper/TDefTableHandler.cxx
+++ writerfilter/source/dmapper/TDefTableHandler.cxx
@@ -29,7 +29,7 @@
 #include <ConversionHelper.hxx>
 #include <ooxml/resourceids.hxx>
 #include <doctok/resourceids.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/TableColumnSeparator.hpp>
 #include <com/sun/star/text/VertOrientation.hpp>
 
@@ -170,7 +170,7 @@ void TDefTableHandler::localResolve(Id rName, writerfilter::Reference<Properties
     {
         m_nLineWidth = m_nLineType = m_nLineColor = m_nLineDistance = 0;
         pProperties->resolve( *this );
-        table::BorderLine aBorderLine;
+        table::BorderLine2 aBorderLine;
         ConversionHelper::MakeBorderLine( m_nLineWidth,   m_nLineType, m_nLineColor,  
                                                                         aBorderLine, m_bOOXML );
                 
diff --git writerfilter/source/dmapper/TDefTableHandler.hxx writerfilter/source/dmapper/TDefTableHandler.hxx
index 3857418..aa4a2a1 100644
--- writerfilter/source/dmapper/TDefTableHandler.hxx
+++ writerfilter/source/dmapper/TDefTableHandler.hxx
@@ -30,10 +30,9 @@
 #include <WriterFilterDllApi.hxx>
 #include <resourcemodel/WW8ResourceModel.hxx>
 #include <boost/shared_ptr.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
 #include <vector>
 namespace com{ namespace sun{ namespace star{namespace table {
-    struct BorderLine;
+    struct BorderLine2;
 }}}}
 
 namespace writerfilter {
@@ -49,14 +48,14 @@ private:
     ::std::vector<sal_Int32>                                m_aCellBorderPositions;
     ::std::vector<sal_Int32>                                m_aCellVertAlign;
     
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aLeftBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aRightBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aTopBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aBottomBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aInsideHBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aInsideVBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aTl2brBorderLines;
-    ::std::vector< ::com::sun::star::table::BorderLine >    m_aTr2blBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aLeftBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aRightBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aTopBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aBottomBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aInsideHBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aInsideVBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aTl2brBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine2 >    m_aTr2blBorderLines;
 
     //values of the current border
     sal_Int32                                           m_nLineWidth;
diff --git xmloff/source/style/PageMasterExportPropMapper.cxx xmloff/source/style/PageMasterExportPropMapper.cxx
index 781e46b..a23fe1b 100644
--- xmloff/source/style/PageMasterExportPropMapper.cxx
+++ xmloff/source/style/PageMasterExportPropMapper.cxx
@@ -30,7 +30,7 @@
 #include "PageMasterExportPropMapper.hxx"
 #include <xmloff/xmltoken.hxx>
 #include <comphelper/types.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <xmloff/PageMasterStyleMap.hxx>
 #include <tools/debug.hxx>
 #include <rtl/ustrbuf.hxx>
@@ -54,10 +54,11 @@ inline sal_Bool lcl_HasSameLineWidth( const table::BorderLine& rLine1, const tab
             (rLine1.LineDistance == rLine2.LineDistance);
 }
 
-inline sal_Bool operator==( const table::BorderLine& rLine1, const table::BorderLine& rLine2 )
+inline sal_Bool operator==( const table::BorderLine2& rLine1, const table::BorderLine2& rLine2 )
 {
     return	(rLine1.Color == rLine2.Color) &&
-            lcl_HasSameLineWidth( rLine1, rLine2 );
+            lcl_HasSameLineWidth( rLine1, rLine2 ) &&
+            ( rLine1.LineStyle == rLine2.LineStyle );
 }
 
 inline void lcl_RemoveState( XMLPropertyState* pState )
@@ -133,7 +134,7 @@ void XMLPropertyStateBuffer::ContextFilter( ::std::vector< XMLPropertyState >& )
     {
         if( pPMBorderTop && pPMBorderBottom && pPMBorderLeft && pPMBorderRight )
         {
-            table::BorderLine aLineTop, aLineBottom, aLineLeft, aLineRight;
+            table::BorderLine2 aLineTop, aLineBottom, aLineLeft, aLineRight;
 
             pPMBorderTop->maValue >>= aLineTop;
             pPMBorderBottom->maValue >>= aLineBottom;
@@ -158,7 +159,7 @@ void XMLPropertyStateBuffer::ContextFilter( ::std::vector< XMLPropertyState >& )
     {
         if( pPMBorderWidthTop && pPMBorderWidthBottom && pPMBorderWidthLeft && pPMBorderWidthRight )
         {
-            table::BorderLine aLineTop, aLineBottom, aLineLeft, aLineRight;
+            table::BorderLine2 aLineTop, aLineBottom, aLineLeft, aLineRight;
 
             pPMBorderWidthTop->maValue >>= aLineTop;
             pPMBorderWidthBottom->maValue >>= aLineBottom;
diff --git xmloff/source/style/PageMasterImportPropMapper.cxx xmloff/source/style/PageMasterImportPropMapper.cxx
index 76eab35..61a5736 100644
--- xmloff/source/style/PageMasterImportPropMapper.cxx
+++ xmloff/source/style/PageMasterImportPropMapper.cxx
@@ -37,7 +37,7 @@
 #include "PageMasterPropMapper.hxx"
 #include <xmloff/PageMasterStyleMap.hxx>
 #include <xmloff/maptype.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <xmloff/xmlimp.hxx>
 
@@ -208,11 +208,11 @@ void PageMasterImportPropertyMapper::finished(::std::vector< XMLPropertyState >&
             pBorderWidths[i]->mnIndex = -1;
         if( pBorders[i] )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pBorders[i]->maValue >>= aBorderLine;
              if( pBorderWidths[i] )
             {
-                table::BorderLine aBorderLineWidth;
+                table::BorderLine2 aBorderLineWidth;
                 pBorderWidths[i]->maValue >>= aBorderLineWidth;
                 aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
                 aBorderLine.InnerLineWidth = aBorderLineWidth.InnerLineWidth;
@@ -230,11 +230,11 @@ void PageMasterImportPropertyMapper::finished(::std::vector< XMLPropertyState >&
             pHeaderBorderWidths[i]->mnIndex = -1;
         if( pHeaderBorders[i] )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pHeaderBorders[i]->maValue >>= aBorderLine;
              if( pHeaderBorderWidths[i] )
             {
-                table::BorderLine aBorderLineWidth;
+                table::BorderLine2 aBorderLineWidth;
                 pHeaderBorderWidths[i]->maValue >>= aBorderLineWidth;
                 aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
                 aBorderLine.InnerLineWidth = aBorderLineWidth.InnerLineWidth;
@@ -252,11 +252,11 @@ void PageMasterImportPropertyMapper::finished(::std::vector< XMLPropertyState >&
             pFooterBorderWidths[i]->mnIndex = -1;
         if( pFooterBorders[i] )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pFooterBorders[i]->maValue >>= aBorderLine;
              if( pFooterBorderWidths[i] )
             {
-                table::BorderLine aBorderLineWidth;
+                table::BorderLine2 aBorderLineWidth;
                 pFooterBorderWidths[i]->maValue >>= aBorderLineWidth;
                 aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
                 aBorderLine.InnerLineWidth = aBorderLineWidth.InnerLineWidth;
diff --git xmloff/source/style/bordrhdl.cxx xmloff/source/style/bordrhdl.cxx
index df58f82..decb450 100644
--- xmloff/source/style/bordrhdl.cxx
+++ xmloff/source/style/bordrhdl.cxx
@@ -34,7 +34,7 @@
 #include <xmloff/xmluconv.hxx>
 #include <rtl/ustrbuf.hxx>
 #include <com/sun/star/uno/Any.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
@@ -42,6 +42,10 @@ using ::rtl::OUStringBuffer;
 using namespace ::com::sun::star;
 using namespace ::xmloff::token;
 
+const sal_Int16 API_LINE_SOLID   = 0;
+const sal_Int16 API_LINE_DOTTED  = 1;
+const sal_Int16 API_LINE_DASHED  = 2;
+
 // copied from svx/boxitem.hxx
 #define DEF_LINE_WIDTH_0        1
 #define DEF_LINE_WIDTH_1        35
@@ -101,6 +105,8 @@ using namespace ::xmloff::token;
 #define SVX_XML_BORDER_STYLE_NONE 0
 #define SVX_XML_BORDER_STYLE_SOLID 1
 #define SVX_XML_BORDER_STYLE_DOUBLE 2
+#define SVX_XML_BORDER_STYLE_DASHED 3
+#define SVX_XML_BORDER_STYLE_DOTTED 4
 
 #define SVX_XML_BORDER_WIDTH_THIN 0
 #define SVX_XML_BORDER_WIDTH_MIDDLE 1
@@ -112,8 +118,8 @@ SvXMLEnumMapEntry pXML_BorderStyles[] =
     { XML_HIDDEN, 				SVX_XML_BORDER_STYLE_NONE	},
     { XML_SOLID, 				SVX_XML_BORDER_STYLE_SOLID	},
     { XML_DOUBLE,				SVX_XML_BORDER_STYLE_DOUBLE	},
-    { XML_DOTTED, 				SVX_XML_BORDER_STYLE_SOLID  },
-    { XML_DASHED, 				SVX_XML_BORDER_STYLE_SOLID	},
+    { XML_DOTTED, 				SVX_XML_BORDER_STYLE_DOTTED },
+    { XML_DASHED, 				SVX_XML_BORDER_STYLE_DASHED	},
     { XML_GROOVE, 				SVX_XML_BORDER_STYLE_SOLID	},
     { XML_RIDGE,  				SVX_XML_BORDER_STYLE_SOLID  },
     { XML_INSET,  				SVX_XML_BORDER_STYLE_SOLID  },
@@ -171,6 +177,23 @@ static sal_uInt16 __READONLY_DATA aDBorderWidths[] =
     DBORDER_ENTRY( 5 )
 };
 
+void lcl_frmitems_setXMLBorderStyle( table::BorderLine2 & rBorderLine, sal_uInt16 nStyle )
+{
+    sal_Int16 eStyle = API_LINE_SOLID;
+    switch ( nStyle )
+    {
+        case SVX_XML_BORDER_STYLE_DOTTED:
+            eStyle = API_LINE_DOTTED;
+            break;
+        case SVX_XML_BORDER_STYLE_DASHED:
+            eStyle = API_LINE_DASHED;
+            break;
+        default:
+            break;
+    }
+    rBorderLine.LineStyle = eStyle;
+}
+
 void lcl_frmitems_setXMLBorderWidth( table::BorderLine &rBorderLine,
                                      sal_uInt16 nWidth, sal_Bool bDouble )
 {
@@ -273,7 +296,7 @@ sal_Bool XMLBorderWidthHdl::importXML( const OUString& rStrImpValue, uno::Any& r
     sal_uInt16 nWidth = i < nSize ? 0 : nOutWidth + nInWidth + nDistance;
 #endif
 
-    table::BorderLine aBorderLine;
+    table::BorderLine2 aBorderLine;
     if(!(rValue >>= aBorderLine))
         aBorderLine.Color = 0;
 
@@ -289,7 +312,7 @@ sal_Bool XMLBorderWidthHdl::exportXML( OUString& rStrExpValue, const uno::Any& r
 { 
     OUStringBuffer aOut;
 
-    table::BorderLine aBorderLine;
+    table::BorderLine2 aBorderLine;
     if(!(rValue >>= aBorderLine))
         return sal_False;
 
@@ -368,7 +391,7 @@ sal_Bool XMLBorderHdl::importXML( const OUString& rStrImpValue, uno::Any& rValue
     if( !bHasStyle || (SVX_XML_BORDER_STYLE_NONE != nStyle && !bHasWidth) )
         return sal_False;
 
-    table::BorderLine aBorderLine;
+    table::BorderLine2 aBorderLine;
     if(!(rValue >>= aBorderLine))
     {
         aBorderLine.Color = 0;
@@ -400,11 +423,13 @@ sal_Bool XMLBorderHdl::importXML( const OUString& rStrImpValue, uno::Any& rValue
         else
         {
             lcl_frmitems_setXMLBorderWidth( aBorderLine, nWidth, bDouble );
+            lcl_frmitems_setXMLBorderStyle( aBorderLine, nStyle );
         }
     }
     else
     {
         lcl_frmitems_setXMLBorderWidth( aBorderLine, 0, bDouble );
+        lcl_frmitems_setXMLBorderStyle( aBorderLine, nStyle );
     }
 
     // set color
@@ -419,7 +444,7 @@ sal_Bool XMLBorderHdl::exportXML( OUString& rStrExpValue, const uno::Any& rValue
 { 
     OUStringBuffer aOut;
 
-    table::BorderLine aBorderLine;
+    table::BorderLine2 aBorderLine;
     if(!(rValue >>= aBorderLine))
         return sal_False;
 
@@ -441,7 +466,20 @@ sal_Bool XMLBorderHdl::exportXML( OUString& rStrExpValue, const uno::Any& rValue
 
         aOut.append( sal_Unicode( ' ' ) );
 
-        aOut.append( GetXMLToken((0 == nDistance) ? XML_SOLID : XML_DOUBLE) );
+        XMLTokenEnum eStyleToken = XML_SOLID;
+        switch ( aBorderLine.LineStyle )
+        {
+            case API_LINE_DASHED:
+                eStyleToken = XML_DASHED;
+                break;
+            case API_LINE_DOTTED:
+                eStyleToken = XML_DOTTED;
+                break;
+            case API_LINE_SOLID:
+            default:
+                eStyleToken = XML_SOLID;
+        }
+        aOut.append( GetXMLToken((0 == nDistance) ? eStyleToken : XML_DOUBLE) );
 
         aOut.append( sal_Unicode( ' ' ) );
 
diff --git xmloff/source/text/txtexppr.cxx xmloff/source/text/txtexppr.cxx
index 17f3ccf..099eb32 100644
--- xmloff/source/text/txtexppr.cxx
+++ xmloff/source/text/txtexppr.cxx
@@ -29,7 +29,7 @@
 #include "precompiled_xmloff.hxx"
 #include <tools/debug.hxx>
 #include <xmloff/txtprmap.hxx>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/SizeType.hpp>
 #include <com/sun/star/text/WrapTextMode.hpp>
 #include <com/sun/star/text/TextContentAnchorType.hpp>
@@ -700,7 +700,7 @@ void XMLTextExportPropertySetMapper::ContextFilter(
     {
         if( pLeftBorderWidthState && pRightBorderWidthState && pTopBorderWidthState && pBottomBorderWidthState )
         {
-            table::BorderLine aLeft, aRight, aTop, aBottom;
+            table::BorderLine2 aLeft, aRight, aTop, aBottom;
 
             pLeftBorderWidthState->maValue >>= aLeft;
             pRightBorderWidthState->maValue >>= aRight;
@@ -708,10 +708,13 @@ void XMLTextExportPropertySetMapper::ContextFilter(
             pBottomBorderWidthState->maValue >>= aBottom;
             if( aLeft.Color == aRight.Color && aLeft.InnerLineWidth == aRight.InnerLineWidth &&
                 aLeft.OuterLineWidth == aRight.OuterLineWidth && aLeft.LineDistance == aRight.LineDistance &&
+                aLeft.LineStyle == aRight.LineStyle &&
                 aLeft.Color == aTop.Color && aLeft.InnerLineWidth == aTop.InnerLineWidth &&
                 aLeft.OuterLineWidth == aTop.OuterLineWidth && aLeft.LineDistance == aTop.LineDistance &&
+                aLeft.LineStyle == aTop.LineStyle &&
                 aLeft.Color == aBottom.Color && aLeft.InnerLineWidth == aBottom.InnerLineWidth &&
-                aLeft.OuterLineWidth == aBottom.OuterLineWidth && aLeft.LineDistance == aBottom.LineDistance )
+                aLeft.OuterLineWidth == aBottom.OuterLineWidth && aLeft.LineDistance == aBottom.LineDistance &&
+                aLeft.LineStyle == aBottom.LineStyle )
             {
                 pLeftBorderWidthState->mnIndex = -1;
                 pLeftBorderWidthState->maValue.clear();
@@ -773,7 +776,7 @@ void XMLTextExportPropertySetMapper::ContextFilter(
     {
         if( pLeftBorderState && pRightBorderState && pTopBorderState && pBottomBorderState )
         {
-            table::BorderLine aLeft, aRight, aTop, aBottom;
+            table::BorderLine2 aLeft, aRight, aTop, aBottom;
 
             pLeftBorderState->maValue >>= aLeft;
             pRightBorderState->maValue >>= aRight;
@@ -781,10 +784,13 @@ void XMLTextExportPropertySetMapper::ContextFilter(
             pBottomBorderState->maValue >>= aBottom;
             if( aLeft.Color == aRight.Color && aLeft.InnerLineWidth == aRight.InnerLineWidth &&
                 aLeft.OuterLineWidth == aRight.OuterLineWidth && aLeft.LineDistance == aRight.LineDistance &&
+                aLeft.LineStyle == aRight.LineStyle &&
                 aLeft.Color == aTop.Color && aLeft.InnerLineWidth == aTop.InnerLineWidth &&
                 aLeft.OuterLineWidth == aTop.OuterLineWidth && aLeft.LineDistance == aTop.LineDistance &&
+                aLeft.LineStyle == aTop.LineStyle  &&
                 aLeft.Color == aBottom.Color && aLeft.InnerLineWidth == aBottom.InnerLineWidth &&
-                aLeft.OuterLineWidth == aBottom.OuterLineWidth && aLeft.LineDistance == aBottom.LineDistance )
+                aLeft.OuterLineWidth == aBottom.OuterLineWidth && aLeft.LineDistance == aBottom.LineDistance &&
+                aLeft.LineStyle == aBottom.LineStyle )
             {
                 pLeftBorderState->mnIndex = -1;
                 pLeftBorderState->maValue.clear();
diff --git xmloff/source/text/txtimppr.cxx xmloff/source/text/txtimppr.cxx
index b6045f5..963cc96 100644
--- xmloff/source/text/txtimppr.cxx
+++ xmloff/source/text/txtimppr.cxx
@@ -30,7 +30,7 @@
 #include <tools/debug.hxx>
 #include <com/sun/star/awt/FontFamily.hpp>
 #include <com/sun/star/awt/FontPitch.hpp>
-#include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/table/BorderLine2.hpp>
 #include <com/sun/star/text/VertOrientation.hpp>
 #include <com/sun/star/text/SizeType.hpp>
 #include <tools/string.hxx>
@@ -438,12 +438,12 @@ void XMLTextImportPropertyMapper::finished(
         sal_Bool bHasBorder = sal_False;
         if( pBorders[i] )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pBorders[i]->maValue >>= aBorderLine;
 
              if( pBorderWidths[i] )
             {
-                table::BorderLine aBorderLineWidth;
+                table::BorderLine2 aBorderLineWidth;
                 pBorderWidths[i]->maValue >>= aBorderLineWidth;
                 aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
                 aBorderLine.InnerLineWidth = aBorderLineWidth.InnerLineWidth;
@@ -492,10 +492,10 @@ void XMLTextImportPropertyMapper::finished(
 #else
         if( pBorders[i] && pBorderWidths[i] )
         {
-            table::BorderLine aBorderLine;
+            table::BorderLine2 aBorderLine;
             pBorders[i]->maValue >>= aBorderLine;
 
-            table::BorderLine aBorderLineWidth;
+            table::BorderLine2 aBorderLineWidth;
             pBorderWidths[i]->maValue >>= aBorderLineWidth;
 
             aBorderLine.OuterLineWidth = aBorderLineWidth.OuterLineWidth;
