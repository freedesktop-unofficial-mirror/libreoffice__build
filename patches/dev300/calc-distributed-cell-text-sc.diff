From 73b2b6bac6d388d1ed160fcf92d472f0e139a780 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 17:07:59 +0200
Subject: [PATCH 696/768] calc-distributed-cell-text-sc.diff

---
 sc/inc/scitems.hxx                 |  138 +++++-----
 sc/inc/unonames.hxx                |    2 +
 sc/source/core/data/docpool.cxx    |    4 +
 sc/source/filter/excel/xestyle.cxx |   26 ++-
 sc/source/filter/excel/xistyle.cxx |    2 +
 sc/source/filter/excel/xlstyle.cxx |   12 +-
 sc/source/filter/inc/xlstyle.hxx   |    4 +
 sc/source/filter/xml/xmlstyle.cxx  |  145 ++++++++--
 sc/source/filter/xml/xmlstyle.hxx  |   37 ++-
 sc/source/ui/unoobj/afmtuno.cxx    |    8 +-
 sc/source/ui/unoobj/cellsuno.cxx   |   38 ++-
 sc/source/ui/unoobj/styleuno.cxx   |    8 +-
 sc/source/ui/vba/vbaformat.cxx     |   22 +-
 sc/source/ui/view/output2.cxx      |  539 +++++++++++++++++++++++-------------
 14 files changed, 660 insertions(+), 325 deletions(-)

diff --git sc/inc/scitems.hxx sc/inc/scitems.hxx
index dbdb5d3..2da2bf1 100644
--- sc/inc/scitems.hxx
+++ sc/inc/scitems.hxx
@@ -93,75 +93,77 @@
 #define ATTR_HANGPUNCTUATION	127
 #define ATTR_FORBIDDEN_RULES	128
 #define	ATTR_HOR_JUSTIFY		129
-#define ATTR_INDENT				130
-#define	ATTR_VER_JUSTIFY		131
-#define ATTR_STACKED            132
-#define ATTR_ROTATE_VALUE		133
-#define ATTR_ROTATE_MODE		134
-#define ATTR_VERTICAL_ASIAN		135
-#define ATTR_WRITINGDIR			136
-#define ATTR_LINEBREAK			137
-#define ATTR_SHRINKTOFIT        138
-#define ATTR_BORDER_TLBR        139
-#define ATTR_BORDER_BLTR        140
-#define ATTR_MARGIN             141
-#define ATTR_MERGE              142
-#define ATTR_MERGE_FLAG         143
-#define ATTR_VALUE_FORMAT       144
-#define ATTR_LANGUAGE_FORMAT    145
-#define ATTR_BACKGROUND         146
-#define ATTR_PROTECTION         147
-#define ATTR_BORDER             148
-#define ATTR_BORDER_INNER       149     // innen, wg. Vorlagen-EditDialog
-#define ATTR_SHADOW             150
-#define ATTR_VALIDDATA          151
-#define ATTR_CONDITIONAL        152
-
-#define ATTR_PATTERN_END        152     // Ende Zellattribut-Pattern
-
-#define ATTR_PATTERN            153
+#define ATTR_HOR_JUSTIFY_METHOD 130
+#define ATTR_INDENT				131
+#define	ATTR_VER_JUSTIFY		132
+#define ATTR_VER_JUSTIFY_METHOD 133
+#define ATTR_STACKED            134
+#define ATTR_ROTATE_VALUE		135
+#define ATTR_ROTATE_MODE		136
+#define ATTR_VERTICAL_ASIAN		137
+#define ATTR_WRITINGDIR			138
+#define ATTR_LINEBREAK			139
+#define ATTR_SHRINKTOFIT        140
+#define ATTR_BORDER_TLBR        141
+#define ATTR_BORDER_BLTR        142
+#define ATTR_MARGIN             143
+#define ATTR_MERGE              144
+#define ATTR_MERGE_FLAG         145
+#define ATTR_VALUE_FORMAT       146
+#define ATTR_LANGUAGE_FORMAT    147
+#define ATTR_BACKGROUND         148
+#define ATTR_PROTECTION         149
+#define ATTR_BORDER             150
+#define ATTR_BORDER_INNER       151     // innen, wg. Vorlagen-EditDialog
+#define ATTR_SHADOW             152
+#define ATTR_VALIDDATA          153
+#define ATTR_CONDITIONAL        154
+
+#define ATTR_PATTERN_END        154     // Ende Zellattribut-Pattern
+
+#define ATTR_PATTERN            155
                                         // Seitenattribute
-#define ATTR_LRSPACE            154     // Editor: PageDesc-TabPage
-#define ATTR_ULSPACE            155
-#define ATTR_PAGE               156
-#define ATTR_PAGE_PAPERTRAY     157
-#define ATTR_PAGE_PAPERBIN      158
-#define ATTR_PAGE_SIZE          159
-#define ATTR_PAGE_MAXSIZE       160
-#define ATTR_PAGE_HORCENTER     161
-#define ATTR_PAGE_VERCENTER     162
-
-#define ATTR_PAGE_ON            163     // Editor: Header/Footer-Page
-#define ATTR_PAGE_DYNAMIC       164
-#define ATTR_PAGE_SHARED        165
-
-#define ATTR_PAGE_NOTES         166     // Editor: Tabelle
-#define ATTR_PAGE_GRID          167
-#define ATTR_PAGE_HEADERS       168
-#define ATTR_PAGE_CHARTS        169
-#define ATTR_PAGE_OBJECTS       170
-#define ATTR_PAGE_DRAWINGS      171
-#define ATTR_PAGE_TOPDOWN       172
-#define ATTR_PAGE_SCALE         173
-#define ATTR_PAGE_SCALETOPAGES  174
-#define ATTR_PAGE_FIRSTPAGENO   175
-
-#define ATTR_PAGE_PRINTAREA     176     // Editor: Druckbereiche
-#define ATTR_PAGE_REPEATROW     177
-#define ATTR_PAGE_REPEATCOL     178
-#define ATTR_PAGE_PRINTTABLES   179
-
-#define ATTR_PAGE_HEADERLEFT    180     // Inhalte der Kopf-/
-#define ATTR_PAGE_FOOTERLEFT    181     // Fusszeilen (links)
-#define ATTR_PAGE_HEADERRIGHT   182     // Inhalte der Kopf-/
-#define ATTR_PAGE_FOOTERRIGHT   183     // Fusszeilen (rechts)
-#define ATTR_PAGE_HEADERSET     184     // die Sets dazu...
-#define ATTR_PAGE_FOOTERSET     185
-
-#define ATTR_PAGE_FORMULAS      186
-#define ATTR_PAGE_NULLVALS      187
-
-#define ATTR_PAGE_SCALETO       188     // #i8868# scale printout to with/height
+#define ATTR_LRSPACE            156     // Editor: PageDesc-TabPage
+#define ATTR_ULSPACE            157
+#define ATTR_PAGE               158
+#define ATTR_PAGE_PAPERTRAY     159
+#define ATTR_PAGE_PAPERBIN      160
+#define ATTR_PAGE_SIZE          161
+#define ATTR_PAGE_MAXSIZE       162
+#define ATTR_PAGE_HORCENTER     163
+#define ATTR_PAGE_VERCENTER     164
+
+#define ATTR_PAGE_ON            165     // Editor: Header/Footer-Page
+#define ATTR_PAGE_DYNAMIC       166
+#define ATTR_PAGE_SHARED        167
+
+#define ATTR_PAGE_NOTES         168     // Editor: Tabelle
+#define ATTR_PAGE_GRID          169
+#define ATTR_PAGE_HEADERS       170
+#define ATTR_PAGE_CHARTS        171
+#define ATTR_PAGE_OBJECTS       172
+#define ATTR_PAGE_DRAWINGS      173
+#define ATTR_PAGE_TOPDOWN       174
+#define ATTR_PAGE_SCALE         175
+#define ATTR_PAGE_SCALETOPAGES  176
+#define ATTR_PAGE_FIRSTPAGENO   177
+
+#define ATTR_PAGE_PRINTAREA     178     // Editor: Druckbereiche
+#define ATTR_PAGE_REPEATROW     179
+#define ATTR_PAGE_REPEATCOL     180
+#define ATTR_PAGE_PRINTTABLES   181
+
+#define ATTR_PAGE_HEADERLEFT    182     // Inhalte der Kopf-/
+#define ATTR_PAGE_FOOTERLEFT    183     // Fusszeilen (links)
+#define ATTR_PAGE_HEADERRIGHT   184     // Inhalte der Kopf-/
+#define ATTR_PAGE_FOOTERRIGHT   185     // Fusszeilen (rechts)
+#define ATTR_PAGE_HEADERSET     186     // die Sets dazu...
+#define ATTR_PAGE_FOOTERSET     187
+
+#define ATTR_PAGE_FORMULAS      188
+#define ATTR_PAGE_NULLVALS      189
+
+#define ATTR_PAGE_SCALETO       190     // #i8868# scale printout to with/height
 
 #define ATTR_ENDINDEX           ATTR_PAGE_SCALETO        // Ende Pool-Range
 
diff --git sc/inc/unonames.hxx sc/inc/unonames.hxx
index 06fca63..8ba7114 100644
--- sc/inc/unonames.hxx
+++ sc/inc/unonames.hxx
@@ -106,6 +106,8 @@
 #define SC_UNONAME_CELLPRO			"CellProtection"
 #define SC_UNONAME_CELLHJUS			"HoriJustify"
 #define SC_UNONAME_CELLVJUS			"VertJustify"
+#define SC_UNONAME_CELLHJUS_METHOD  "HoriJustifyMethod"
+#define SC_UNONAME_CELLVJUS_METHOD  "VertJustifyMethod"
 #define SC_UNONAME_CELLORI			"Orientation"
 #define SC_UNONAME_NUMFMT			"NumberFormat"
 #define SC_UNONAME_SHADOW			"ShadowFormat"
diff --git sc/source/core/data/docpool.cxx sc/source/core/data/docpool.cxx
index 04741fc..30bf0e9 100644
--- sc/source/core/data/docpool.cxx
+++ sc/source/core/data/docpool.cxx
@@ -127,8 +127,10 @@ static SfxItemInfo __READONLY_DATA  aItemInfos[] =
     { 0,							SFX_ITEM_POOLABLE },	// ATTR_HANGPUNCTUATION		from 614d
     { SID_ATTR_PARA_FORBIDDEN_RULES,SFX_ITEM_POOLABLE },	// ATTR_FORBIDDEN_RULES		from 614d
     { SID_ATTR_ALIGN_HOR_JUSTIFY,	SFX_ITEM_POOLABLE },	// ATTR_HOR_JUSTIFY
+    { SID_ATTR_ALIGN_HOR_JUSTIFY_METHOD, SFX_ITEM_POOLABLE }, // ATTR_HOR_JUSTIFY_METHOD
     { SID_ATTR_ALIGN_INDENT,		SFX_ITEM_POOLABLE },	// ATTR_INDENT			ab 350
     { SID_ATTR_ALIGN_VER_JUSTIFY,	SFX_ITEM_POOLABLE },	// ATTR_VER_JUSTIFY
+    { SID_ATTR_ALIGN_VER_JUSTIFY_METHOD, SFX_ITEM_POOLABLE }, // ATTR_VER_JUSTIFY_METHOD
     { SID_ATTR_ALIGN_STACKED,       SFX_ITEM_POOLABLE },    // ATTR_STACKED         from 680/dr14 (replaces ATTR_ORIENTATION)
     { SID_ATTR_ALIGN_DEGREES,		SFX_ITEM_POOLABLE },	// ATTR_ROTATE_VALUE	ab 367
     { SID_ATTR_ALIGN_LOCKPOS,		SFX_ITEM_POOLABLE },	// ATTR_ROTATE_MODE		ab 367
@@ -260,8 +262,10 @@ ScDocumentPool::ScDocumentPool( SfxItemPool* pSecPool, BOOL bLoadRefCounts )
     ppPoolDefaults[ ATTR_HANGPUNCTUATION - ATTR_STARTINDEX ] = new SvxHangingPunctuationItem( sal_False, ATTR_HANGPUNCTUATION);
     ppPoolDefaults[ ATTR_FORBIDDEN_RULES - ATTR_STARTINDEX ] = new SvxForbiddenRuleItem( sal_False, ATTR_FORBIDDEN_RULES);
     ppPoolDefaults[ ATTR_HOR_JUSTIFY     - ATTR_STARTINDEX ] = new SvxHorJustifyItem( SVX_HOR_JUSTIFY_STANDARD, ATTR_HOR_JUSTIFY);
+    ppPoolDefaults[ ATTR_HOR_JUSTIFY_METHOD - ATTR_STARTINDEX ] = new SvxJustifyMethodItem( SVX_JUSTIFY_METHOD_AUTO, ATTR_HOR_JUSTIFY_METHOD);
     ppPoolDefaults[	ATTR_INDENT			 - ATTR_STARTINDEX ] = new SfxUInt16Item( ATTR_INDENT, 0 );
     ppPoolDefaults[ ATTR_VER_JUSTIFY     - ATTR_STARTINDEX ] = new SvxVerJustifyItem( SVX_VER_JUSTIFY_STANDARD, ATTR_VER_JUSTIFY);
+    ppPoolDefaults[ ATTR_VER_JUSTIFY_METHOD - ATTR_STARTINDEX ] = new SvxJustifyMethodItem( SVX_JUSTIFY_METHOD_AUTO, ATTR_VER_JUSTIFY_METHOD);
     ppPoolDefaults[ ATTR_STACKED         - ATTR_STARTINDEX ] = new SfxBoolItem( ATTR_STACKED, FALSE );
     ppPoolDefaults[	ATTR_ROTATE_VALUE	 - ATTR_STARTINDEX ] = new SfxInt32Item( ATTR_ROTATE_VALUE, 0 );
     ppPoolDefaults[	ATTR_ROTATE_MODE	 - ATTR_STARTINDEX ] = new SvxRotateModeItem( SVX_ROTATE_MODE_BOTTOM, ATTR_ROTATE_MODE );
diff --git sc/source/filter/excel/xestyle.cxx sc/source/filter/excel/xestyle.cxx
index 3800c2f..68d1cf9 100644
--- sc/source/filter/excel/xestyle.cxx
+++ sc/source/filter/excel/xestyle.cxx
@@ -1379,6 +1379,8 @@ bool XclExpCellAlign::FillFromItemSet(
         const SfxItemSet& rItemSet, bool bForceLineBreak, XclBiff eBiff, bool bStyle )
 {
     bool bUsed = false;
+    SvxCellHorJustify eHorAlign = GETITEMVALUE( rItemSet, SvxHorJustifyItem, ATTR_HOR_JUSTIFY, SvxCellHorJustify );
+    SvxCellVerJustify eVerAlign = GETITEMVALUE( rItemSet, SvxVerJustifyItem, ATTR_VER_JUSTIFY, SvxCellVerJustify );
 
     switch( eBiff )
     {
@@ -1405,7 +1407,7 @@ bool XclExpCellAlign::FillFromItemSet(
         case EXC_BIFF4: // attributes new in BIFF4
         {
             // vertical alignment
-            SetScVerAlign( GETITEMVALUE( rItemSet, SvxVerJustifyItem, ATTR_VER_JUSTIFY, SvxCellVerJustify ) );
+            SetScVerAlign( eVerAlign );
             bUsed |= ScfTools::CheckItem( rItemSet, ATTR_VER_JUSTIFY, bStyle );
 
             // stacked/rotation
@@ -1435,7 +1437,7 @@ bool XclExpCellAlign::FillFromItemSet(
         case EXC_BIFF2: // attributes new in BIFF2
         {
             // horizontal alignment
-            SetScHorAlign( GETITEMVALUE( rItemSet, SvxHorJustifyItem, ATTR_HOR_JUSTIFY, SvxCellHorJustify ) );
+            SetScHorAlign( eHorAlign );
             bUsed |= ScfTools::CheckItem( rItemSet, ATTR_HOR_JUSTIFY, bStyle );
         }
 
@@ -1443,6 +1445,26 @@ bool XclExpCellAlign::FillFromItemSet(
         default:    DBG_ERROR_BIFF();
     }
 
+    if (eBiff == EXC_BIFF8)
+    {
+        // Adjust for distributed alignments.
+        if (eHorAlign == SVX_HOR_JUSTIFY_BLOCK)
+        {
+            SvxCellJustifyMethod eHorJustMethod = GETITEMVALUE(
+                rItemSet, SvxJustifyMethodItem, ATTR_HOR_JUSTIFY_METHOD, SvxCellJustifyMethod);
+            if (eHorJustMethod == SVX_JUSTIFY_METHOD_DISTRIBUTE)
+                mnHorAlign = EXC_XF_HOR_DISTRIB;
+        }
+
+        if (eVerAlign == SVX_VER_JUSTIFY_BLOCK)
+        {
+            SvxCellJustifyMethod eVerJustMethod = GETITEMVALUE(
+                rItemSet, SvxJustifyMethodItem, ATTR_VER_JUSTIFY_METHOD, SvxCellJustifyMethod);
+            if (eVerJustMethod == SVX_JUSTIFY_METHOD_DISTRIBUTE)
+                mnVerAlign = EXC_XF_VER_DISTRIB;
+        }
+    }
+
     return bUsed;
 }
 
diff --git sc/source/filter/excel/xistyle.cxx sc/source/filter/excel/xistyle.cxx
index 6279033..7a87f01 100644
--- sc/source/filter/excel/xistyle.cxx
+++ sc/source/filter/excel/xistyle.cxx
@@ -688,6 +688,7 @@ void XclImpCellAlign::FillToItemSet( SfxItemSet& rItemSet, const XclImpFont* pFo
 {
     // horizontal alignment
     ScfTools::PutItem( rItemSet, SvxHorJustifyItem( GetScHorAlign(), ATTR_HOR_JUSTIFY ), bSkipPoolDefs );
+    ScfTools::PutItem( rItemSet, SvxJustifyMethodItem( GetScHorJustifyMethod(), ATTR_HOR_JUSTIFY_METHOD ), bSkipPoolDefs );
 
     // text wrap (#i74508# always if vertical alignment is justified or distributed)
     bool bLineBreak = mbLineBreak || (mnVerAlign == EXC_XF_VER_JUSTIFY) || (mnVerAlign == EXC_XF_VER_DISTRIB);
@@ -695,6 +696,7 @@ void XclImpCellAlign::FillToItemSet( SfxItemSet& rItemSet, const XclImpFont* pFo
 
     // vertical alignment
     ScfTools::PutItem( rItemSet, SvxVerJustifyItem( GetScVerAlign(), ATTR_VER_JUSTIFY ), bSkipPoolDefs );
+    ScfTools::PutItem( rItemSet, SvxJustifyMethodItem( GetScVerJustifyMethod(), ATTR_VER_JUSTIFY_METHOD ), bSkipPoolDefs );
 
     // indent
     sal_uInt16 nScIndent = mnIndent * 200; // 1 Excel unit == 10 pt == 200 twips
diff --git sc/source/filter/excel/xlstyle.cxx sc/source/filter/excel/xlstyle.cxx
index b820d39..e32e351 100644
--- sc/source/filter/excel/xlstyle.cxx
+++ sc/source/filter/excel/xlstyle.cxx
@@ -1608,6 +1608,11 @@ SvxCellHorJustify XclCellAlign::GetScHorAlign() const
     return eHorJust;
 }
 
+SvxCellJustifyMethod XclCellAlign::GetScHorJustifyMethod() const
+{
+    return (mnHorAlign == EXC_XF_HOR_DISTRIB) ? SVX_JUSTIFY_METHOD_DISTRIBUTE : SVX_JUSTIFY_METHOD_AUTO;
+}
+
 SvxCellVerJustify XclCellAlign::GetScVerAlign() const
 {
     SvxCellVerJustify eVerJust = SVX_VER_JUSTIFY_STANDARD;
@@ -1617,12 +1622,17 @@ SvxCellVerJustify XclCellAlign::GetScVerAlign() const
         case EXC_XF_VER_CENTER:     eVerJust = SVX_VER_JUSTIFY_CENTER;      break;
         case EXC_XF_VER_BOTTOM:     eVerJust = SVX_VER_JUSTIFY_STANDARD;    break;
         case EXC_XF_VER_JUSTIFY:
-        case EXC_XF_VER_DISTRIB:    eVerJust = SVX_VER_JUSTIFY_TOP;         break;
+        case EXC_XF_VER_DISTRIB:    eVerJust = SVX_VER_JUSTIFY_BLOCK;       break;
         default:    DBG_ERRORFILE( "XclCellAlign::GetScVerAlign - unknown vertical alignment" );
     }
     return eVerJust;
 }
 
+SvxCellJustifyMethod XclCellAlign::GetScVerJustifyMethod() const
+{
+    return (mnVerAlign == EXC_XF_VER_DISTRIB) ? SVX_JUSTIFY_METHOD_DISTRIBUTE : SVX_JUSTIFY_METHOD_AUTO;
+}
+
 SvxFrameDirection XclCellAlign::GetScFrameDir() const
 {
     SvxFrameDirection eFrameDir = FRMDIR_ENVIRONMENT;
diff --git sc/source/filter/inc/xlstyle.hxx sc/source/filter/inc/xlstyle.hxx
index b7d0857..6216165 100644
--- sc/source/filter/inc/xlstyle.hxx
+++ sc/source/filter/inc/xlstyle.hxx
@@ -521,8 +521,12 @@ struct XclCellAlign
 
     /** Returns the Calc horizontal alignment. */
     SvxCellHorJustify   GetScHorAlign() const;
+    /** Returns horizontal justification method as Calc's attribute. */
+    SvxCellJustifyMethod GetScHorJustifyMethod() const;
     /** Returns the Calc vertical alignment. */
     SvxCellVerJustify   GetScVerAlign() const;
+    /** Returns vertical justification method as Calc's attribute. */
+    SvxCellJustifyMethod GetScVerJustifyMethod() const;
     /** Returns the Calc frame direction. */
     SvxFrameDirection   GetScFrameDir() const;
 
diff --git sc/source/filter/xml/xmlstyle.cxx sc/source/filter/xml/xmlstyle.cxx
index 2967a27..c3397b6 100644
--- sc/source/filter/xml/xmlstyle.cxx
+++ sc/source/filter/xml/xmlstyle.cxx
@@ -35,6 +35,7 @@
 
 #include "XMLConverter.hxx"
 #include "rangeutl.hxx"
+#include "unonames.hxx"
 
 #include <xmloff/xmlnmspe.hxx>
 #include <xmloff/xmluconv.hxx>
@@ -49,8 +50,9 @@
 #include <tools/debug.hxx>
 #include <com/sun/star/util/CellProtection.hpp>
 #include <com/sun/star/table/CellOrientation.hpp>
-#include <com/sun/star/table/CellVertJustify.hpp>
+#include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/CellHoriJustify.hpp>
+#include <com/sun/star/table/CellJustifyMethod.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
 #include <com/sun/star/sheet/XSheetConditionalEntries.hpp>
 #include <com/sun/star/sheet/XSheetConditionalEntry.hpp>
@@ -86,6 +89,7 @@ const XMLPropertyMapEntry aXMLScCellStylesProperties[] =
     MAP( "HoriJustify", XML_NAMESPACE_FO, XML_TEXT_ALIGN, XML_TYPE_PROP_PARAGRAPH|XML_SC_TYPE_HORIJUSTIFY|MID_FLAG_MERGE_PROPERTY, 0 ),
     MAP( "HoriJustify", XML_NAMESPACE_STYLE, XML_TEXT_ALIGN_SOURCE, XML_TYPE_PROP_TABLE_CELL|XML_SC_TYPE_HORIJUSTIFYSOURCE|MID_FLAG_MERGE_PROPERTY, 0 ),
     MAP( "HoriJustify", XML_NAMESPACE_STYLE, XML_REPEAT_CONTENT, XML_TYPE_PROP_TABLE_CELL|XML_SC_TYPE_HORIJUSTIFYREPEAT|MID_FLAG_MERGE_PROPERTY, 0 ),
+    MAP( SC_UNONAME_CELLHJUS_METHOD, XML_NAMESPACE_CSS3TEXT, XML_TEXT_JUSTIFY, XML_TYPE_PROP_PARAGRAPH|XML_SC_TYPE_HORIJUSTIFY_METHOD, 0 ),
     MAP( "IsCellBackgroundTransparent", XML_NAMESPACE_FO, XML_BACKGROUND_COLOR, XML_TYPE_PROP_TABLE_CELL|XML_TYPE_ISTRANSPARENT|MID_FLAG_MULTI_PROPERTY|MID_FLAG_MERGE_ATTRIBUTE, 0 ),
     MAP( "IsTextWrapped", XML_NAMESPACE_FO, XML_WRAP_OPTION, XML_TYPE_PROP_TABLE_CELL|XML_SC_ISTEXTWRAPPED, 0 ),
     MAP( "LeftBorder", XML_NAMESPACE_FO, XML_BORDER, XML_TYPE_PROP_TABLE_CELL|XML_TYPE_BORDER, CTF_SC_ALLBORDER ),
@@ -113,7 +117,9 @@ const XMLPropertyMapEntry aXMLScCellStylesProperties[] =
     MAP( "UserDefinedAttributes", XML_NAMESPACE_TEXT, XML_XMLNS, XML_TYPE_PROP_TABLE_CELL|XML_TYPE_ATTRIBUTE_CONTAINER | MID_FLAG_SPECIAL_ITEM, 0 ),
     MAP( "ValidationXML", XML_NAMESPACE_TABLE, XML_CONTENT_VALIDATION, XML_TYPE_PROP_TABLE_CELL|XML_TYPE_BUILDIN_CMP_ONLY, CTF_SC_VALIDATION ),
     MAP( "VertJustify", XML_NAMESPACE_STYLE, XML_VERTICAL_ALIGN, XML_TYPE_PROP_TABLE_CELL|XML_SC_TYPE_VERTJUSTIFY, 0),
+    MAP( SC_UNONAME_CELLVJUS_METHOD, XML_NAMESPACE_STYLE, XML_VERTICAL_JUSTIFY, XML_TYPE_PROP_TABLE_CELL|XML_SC_TYPE_VERTJUSTIFY_METHOD, 0 ),
 //    MAP( "WritingMode", XML_NAMESPACE_STYLE, XML_WRITING_MODE, XML_TYPE_PROP_PARAGRAPH|XML_TYPE_TEXT_WRITING_MODE_WITH_DEFAULT, 0 ),
+
     MAP_END()
 };
 
@@ -859,6 +865,12 @@ const XMLPropertyHandler* XMLScPropHdlFactory::GetPropertyHandler( sal_Int32 nTy
                 pHdl = new XmlScPropHdl_PrintContent;
             }
             break;
+            case XML_SC_TYPE_HORIJUSTIFY_METHOD:
+            case XML_SC_TYPE_VERTJUSTIFY_METHOD:
+            {
+                pHdl = new XmlScPropHdl_JustifyMethod;
+            }
+            break;
             case XML_SC_TYPE_HORIJUSTIFY :
             {
                 pHdl = new XmlScPropHdl_HoriJustify;
@@ -1132,6 +1144,81 @@ sal_Bool XmlScPropHdl_PrintContent::exportXML(
     return bRetval;
 }
 
+
+XmlScPropHdl_JustifyMethod::~XmlScPropHdl_JustifyMethod()
+{
+}
+
+bool XmlScPropHdl_JustifyMethod::equals(
+    const ::com::sun::star::uno::Any& r1,
+    const ::com::sun::star::uno::Any& r2 ) const
+{
+    sal_Int32 nVal1, nVal2;
+
+    if((r1 >>= nVal1) && (r2 >>= nVal2))
+        return (nVal1 == nVal2);
+    return sal_False;
+}
+
+sal_Bool XmlScPropHdl_JustifyMethod::importXML(
+    const ::rtl::OUString& rStrImpValue,
+    ::com::sun::star::uno::Any& rValue,
+    const SvXMLUnitConverter& /* rUnitConverter */ ) const
+{
+    bool bRetval = false;
+
+    sal_Int32 nValue = table::CellJustifyMethod::AUTO;
+    if (IsXMLToken(rStrImpValue, XML_AUTO))
+    {
+        nValue = table::CellJustifyMethod::AUTO;
+        rValue <<= nValue;
+        bRetval = true;
+    }
+    else if (IsXMLToken(rStrImpValue, XML_DISTRIBUTE))
+    {
+        nValue = table::CellJustifyMethod::DISTRIBUTE;
+        rValue <<= nValue;
+        bRetval = true;
+    }
+    else
+        bRetval = true;
+
+    return bRetval;
+}
+
+sal_Bool XmlScPropHdl_JustifyMethod::exportXML(
+    ::rtl::OUString& rStrExpValue,
+    const ::com::sun::star::uno::Any& rValue,
+    const SvXMLUnitConverter& /* rUnitConverter */ ) const
+{
+    sal_Int32 nVal;
+    bool bRetval = false;
+
+    if (rValue >>= nVal)
+    {
+        switch (nVal)
+        {
+            case table::CellJustifyMethod::AUTO:
+            {
+                rStrExpValue = GetXMLToken(XML_AUTO);
+                bRetval = true;
+            }
+            break;
+            case table::CellJustifyMethod::DISTRIBUTE:
+            {
+                rStrExpValue = GetXMLToken(XML_DISTRIBUTE);
+                bRetval = true;
+            }
+            break;
+            default:
+            {
+                // added to avoid warnings
+            }
+        }
+    }
+    return bRetval;
+}
+
 XmlScPropHdl_HoriJustify::~XmlScPropHdl_HoriJustify()
 {
 }
@@ -1487,7 +1574,7 @@ bool XmlScPropHdl_RotateReference::equals(
     const ::com::sun::star::uno::Any& r1,
     const ::com::sun::star::uno::Any& r2 ) const
 {
-    table::CellVertJustify aReference1, aReference2;
+    sal_Int32 aReference1, aReference2;
 
     if((r1 >>= aReference1) && (r2 >>= aReference2))
         return (aReference1 == aReference2);
@@ -1501,28 +1588,28 @@ sal_Bool XmlScPropHdl_RotateReference::importXML(
 {
     sal_Bool bRetval(sal_False);
 
-    table::CellVertJustify nValue;
+    sal_Int32 nValue;
     if (IsXMLToken(rStrImpValue, XML_NONE))
     {
-        nValue = table::CellVertJustify_STANDARD;
+        nValue = table::CellVertJustify2::STANDARD;
         rValue <<= nValue;
         bRetval = sal_True;
     }
     else if (IsXMLToken(rStrImpValue, XML_BOTTOM))
     {
-        nValue = table::CellVertJustify_BOTTOM;
+        nValue = table::CellVertJustify2::BOTTOM;
         rValue <<= nValue;
         bRetval = sal_True;
     }
     else if (IsXMLToken(rStrImpValue, XML_TOP))
     {
-        nValue = table::CellVertJustify_TOP;
+        nValue = table::CellVertJustify2::TOP;
         rValue <<= nValue;
         bRetval = sal_True;
     }
     else if (IsXMLToken(rStrImpValue, XML_CENTER))
     {
-        nValue = table::CellVertJustify_CENTER;
+        nValue = table::CellVertJustify2::CENTER;
         rValue <<= nValue;
         bRetval = sal_True;
     }
@@ -1535,32 +1622,32 @@ sal_Bool XmlScPropHdl_RotateReference::exportXML(
     const ::com::sun::star::uno::Any& rValue,
     const SvXMLUnitConverter& /* rUnitConverter */ ) const
 {
-    table::CellVertJustify nVal;
+    sal_Int32 nVal;
     sal_Bool bRetval(sal_False);
 
     if(rValue >>= nVal)
     {
         switch (nVal)
         {
-            case table::CellVertJustify_BOTTOM :
+            case table::CellVertJustify2::BOTTOM :
             {
                 rStrExpValue = GetXMLToken(XML_BOTTOM);
                 bRetval = sal_True;
             }
             break;
-            case table::CellVertJustify_CENTER :
+            case table::CellVertJustify2::CENTER :
             {
                 rStrExpValue = GetXMLToken(XML_CENTER);
                 bRetval = sal_True;
             }
             break;
-            case table::CellVertJustify_STANDARD :
+            case table::CellVertJustify2::STANDARD :
             {
                 rStrExpValue = GetXMLToken(XML_NONE);
                 bRetval = sal_True;
             }
             break;
-            case table::CellVertJustify_TOP :
+            case table::CellVertJustify2::TOP :
             {
                 rStrExpValue = GetXMLToken(XML_TOP);
                 bRetval = sal_True;
@@ -1584,7 +1671,7 @@ bool XmlScPropHdl_VertJustify::equals(
     const ::com::sun::star::uno::Any& r1,
     const ::com::sun::star::uno::Any& r2 ) const
 {
-    table::CellVertJustify aReference1, aReference2;
+    sal_Int32 aReference1, aReference2;
 
     if((r1 >>= aReference1) && (r2 >>= aReference2))
         return (aReference1 == aReference2);
@@ -1598,28 +1685,34 @@ sal_Bool XmlScPropHdl_VertJustify::importXML(
 {
     sal_Bool bRetval(sal_False);
 
-    table::CellVertJustify nValue;
+    sal_Int32 nValue;
     if (IsXMLToken(rStrImpValue, XML_AUTOMATIC))
     {
-        nValue = table::CellVertJustify_STANDARD;
+        nValue = table::CellVertJustify2::STANDARD;
         rValue <<= nValue;
         bRetval = sal_True;
     }
     else if (IsXMLToken(rStrImpValue, XML_BOTTOM))
     {
-        nValue = table::CellVertJustify_BOTTOM;
+        nValue = table::CellVertJustify2::BOTTOM;
         rValue <<= nValue;
         bRetval = sal_True;
     }
     else if (IsXMLToken(rStrImpValue, XML_TOP))
     {
-        nValue = table::CellVertJustify_TOP;
+        nValue = table::CellVertJustify2::TOP;
         rValue <<= nValue;
         bRetval = sal_True;
     }
     else if (IsXMLToken(rStrImpValue, XML_MIDDLE))
     {
-        nValue = table::CellVertJustify_CENTER;
+        nValue = table::CellVertJustify2::CENTER;
+        rValue <<= nValue;
+        bRetval = sal_True;
+    }
+    else if (IsXMLToken(rStrImpValue, XML_JUSTIFY))
+    {
+        nValue = table::CellVertJustify2::BLOCK;
         rValue <<= nValue;
         bRetval = sal_True;
     }
@@ -1632,37 +1725,43 @@ sal_Bool XmlScPropHdl_VertJustify::exportXML(
     const ::com::sun::star::uno::Any& rValue,
     const SvXMLUnitConverter& /* rUnitConverter */ ) const
 {
-    table::CellVertJustify nVal;
+    sal_Int32 nVal;
     sal_Bool bRetval(sal_False);
 
     if(rValue >>= nVal)
     {
         switch (nVal)
         {
-            case table::CellVertJustify_BOTTOM :
+            case table::CellVertJustify2::BOTTOM :
             {
                 rStrExpValue = GetXMLToken(XML_BOTTOM);
                 bRetval = sal_True;
             }
             break;
-            case table::CellVertJustify_CENTER :
+            case table::CellVertJustify2::CENTER :
             {
                 rStrExpValue = GetXMLToken(XML_MIDDLE);
                 bRetval = sal_True;
             }
             break;
-            case table::CellVertJustify_STANDARD :
+            case table::CellVertJustify2::STANDARD :
             {
                 rStrExpValue = GetXMLToken(XML_AUTOMATIC);
                 bRetval = sal_True;
             }
             break;
-            case table::CellVertJustify_TOP :
+            case table::CellVertJustify2::TOP :
             {
                 rStrExpValue = GetXMLToken(XML_TOP);
                 bRetval = sal_True;
             }
             break;
+            case table::CellVertJustify2::BLOCK :
+            {
+                rStrExpValue = GetXMLToken(XML_JUSTIFY);
+                bRetval = sal_True;
+            }
+            break;
             default:
             {
                 // added to avoid warnings
diff --git sc/source/filter/xml/xmlstyle.hxx sc/source/filter/xml/xmlstyle.hxx
index fa3513a..4f972f8 100644
--- sc/source/filter/xml/xmlstyle.hxx
+++ sc/source/filter/xml/xmlstyle.hxx
@@ -48,19 +48,21 @@ extern const XMLPropertyMapEntry aXMLScTableStylesImportProperties[];
 #define	XML_SC_TYPE_CELLPROTECTION					(XML_SC_TYPES_START +  1)
 #define	XML_SC_TYPE_PRINTCONTENT					(XML_SC_TYPES_START +  2)
 #define XML_SC_TYPE_HORIJUSTIFY						(XML_SC_TYPES_START +  3)
-#define XML_SC_TYPE_HORIJUSTIFYSOURCE				(XML_SC_TYPES_START +  4)
-#define XML_SC_TYPE_HORIJUSTIFYREPEAT               (XML_SC_TYPES_START +  5)
-#define XML_SC_TYPE_ORIENTATION						(XML_SC_TYPES_START +  6)
-#define XML_SC_TYPE_ROTATEANGLE						(XML_SC_TYPES_START +  7)
-#define XML_SC_TYPE_ROTATEREFERENCE					(XML_SC_TYPES_START +  8)
-#define XML_SC_TYPE_BORDERLEFT						(XML_SC_TYPES_START +  9)
-#define XML_SC_TYPE_BORDERRIGHT						(XML_SC_TYPES_START + 10)
-#define XML_SC_TYPE_BORDERTOP						(XML_SC_TYPES_START + 11)
-#define XML_SC_TYPE_BORDERBOTTOM					(XML_SC_TYPES_START + 12)
-#define XML_SC_TYPE_VERTJUSTIFY						(XML_SC_TYPES_START + 13)
-#define XML_SC_ISTEXTWRAPPED						(XML_SC_TYPES_START + 14)
-#define XML_SC_TYPE_EQUAL							(XML_SC_TYPES_START + 15)
-#define XML_SC_TYPE_VERTICAL						(XML_SC_TYPES_START + 16)
+#define XML_SC_TYPE_HORIJUSTIFY_METHOD              (XML_SC_TYPES_START +  4)
+#define XML_SC_TYPE_HORIJUSTIFYSOURCE               (XML_SC_TYPES_START +  5)
+#define XML_SC_TYPE_HORIJUSTIFYREPEAT               (XML_SC_TYPES_START +  6)
+#define XML_SC_TYPE_ORIENTATION                     (XML_SC_TYPES_START +  7)
+#define XML_SC_TYPE_ROTATEANGLE                     (XML_SC_TYPES_START +  8)
+#define XML_SC_TYPE_ROTATEREFERENCE                 (XML_SC_TYPES_START +  9)
+#define XML_SC_TYPE_BORDERLEFT                      (XML_SC_TYPES_START + 10)
+#define XML_SC_TYPE_BORDERRIGHT                     (XML_SC_TYPES_START + 11)
+#define XML_SC_TYPE_BORDERTOP                       (XML_SC_TYPES_START + 12)
+#define XML_SC_TYPE_BORDERBOTTOM                    (XML_SC_TYPES_START + 13)
+#define XML_SC_TYPE_VERTJUSTIFY                     (XML_SC_TYPES_START + 14)
+#define XML_SC_TYPE_VERTJUSTIFY_METHOD              (XML_SC_TYPES_START + 15)
+#define XML_SC_ISTEXTWRAPPED                        (XML_SC_TYPES_START + 16)
+#define XML_SC_TYPE_EQUAL                           (XML_SC_TYPES_START + 17)
+#define XML_SC_TYPE_VERTICAL                        (XML_SC_TYPES_START + 18)
 
 #define CTF_SC_HORIJUSTIFY							(XML_SC_CTF_START +  1)
 #define CTF_SC_HORIJUSTIFY_SOURCE					(XML_SC_CTF_START +  2)
@@ -245,6 +247,15 @@ public:
     virtual sal_Bool exportXML( ::rtl::OUString& rStrExpValue, const ::com::sun::star::uno::Any& rValue, const SvXMLUnitConverter& rUnitConverter ) const;
 };
 
+class XmlScPropHdl_JustifyMethod : public XMLPropertyHandler
+{
+public:
+    virtual ~XmlScPropHdl_JustifyMethod();
+    virtual bool equals( const ::com::sun::star::uno::Any& r1, const ::com::sun::star::uno::Any& r2 ) const;
+    virtual sal_Bool importXML( const ::rtl::OUString& rStrImpValue, ::com::sun::star::uno::Any& rValue, const SvXMLUnitConverter& rUnitConverter ) const;
+    virtual sal_Bool exportXML( ::rtl::OUString& rStrExpValue, const ::com::sun::star::uno::Any& rValue, const SvXMLUnitConverter& rUnitConverter ) const;
+};
+
 class XmlScPropHdl_HoriJustify : public XMLPropertyHandler
 {
 public:
diff --git sc/source/ui/unoobj/afmtuno.cxx sc/source/ui/unoobj/afmtuno.cxx
index 0a174c0..0e440f0 100644
--- sc/source/ui/unoobj/afmtuno.cxx
+++ sc/source/ui/unoobj/afmtuno.cxx
@@ -39,7 +39,7 @@
 #include "unowids.hxx"
 #include <rtl/uuid.h>
 #include <com/sun/star/table/BorderLine.hpp>
-#include <com/sun/star/table/CellVertJustify.hpp>
+#include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/ShadowLocation.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
 #include <com/sun/star/table/ShadowFormat.hpp>
@@ -139,6 +139,7 @@ const SfxItemPropertyMapEntry* lcl_GetAutoFieldMap()
         {MAP_CHAR_LEN(SC_UNO_CJK_CWEIGHT),  ATTR_CJK_FONT_WEIGHT,   &::getCppuType((float*)0),                  0, MID_WEIGHT },
         {MAP_CHAR_LEN(SC_UNO_CTL_CWEIGHT),  ATTR_CTL_FONT_WEIGHT,   &::getCppuType((float*)0),                  0, MID_WEIGHT },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS), ATTR_HOR_JUSTIFY,       &::getCppuType((const table::CellHoriJustify*)0),   0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN), ATTR_BACKGROUND,        &::getBooleanCppuType(),                    0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),     ATTR_LINEBREAK,         &::getBooleanCppuType(),                    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLORI),  ATTR_STACKED,           &::getCppuType((const table::CellOrientation*)0),   0, 0 },
@@ -147,8 +148,9 @@ const SfxItemPropertyMapEntry* lcl_GetAutoFieldMap()
         {MAP_CHAR_LEN(SC_UNONAME_PRMARGIN), ATTR_MARGIN,            &::getCppuType((const sal_Int32*)0),        0, MID_MARGIN_R_MARGIN  | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN), ATTR_MARGIN,            &::getCppuType((const sal_Int32*)0),        0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),   ATTR_ROTATE_VALUE,      &::getCppuType((const sal_Int32*)0),        0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),   ATTR_ROTATE_MODE,       &::getCppuType((const table::CellVertJustify*)0),   0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS), ATTR_VER_JUSTIFY,       &::getCppuType((const table::CellVertJustify*)0),   0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),   ATTR_ROTATE_MODE,       &::getCppuType((const sal_Int32*)0),   0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS), ATTR_VER_JUSTIFY,       &::getCppuType((const sal_Int32*)0),   0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {0,0,0,0,0,0}
     };
     return aAutoFieldMap_Impl;
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index 21b7c0c..c0b0d43 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -56,7 +56,7 @@
 #include <com/sun/star/util/CellProtection.hpp>
 #include <com/sun/star/table/CellHoriJustify.hpp>
 #include <com/sun/star/table/CellOrientation.hpp>
-#include <com/sun/star/table/CellVertJustify.hpp>
+#include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/ShadowFormat.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
 #include <com/sun/star/sheet/CellFlags.hpp>
@@ -213,6 +213,7 @@ const SfxItemPropertySet* lcl_GetCellsPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
@@ -232,7 +233,7 @@ const SfxItemPropertySet* lcl_GetCellsPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&getCppuType((sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&getCppuType((table::TableBorder*)0),	0, 0 | CONVERT_TWIPS },
@@ -241,7 +242,8 @@ const SfxItemPropertySet* lcl_GetCellsPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIXML),	SC_WID_UNO_VALIXML,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((sal_Int32*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {0,0,0,0,0,0}
     };
@@ -312,6 +314,7 @@ const SfxItemPropertySet* lcl_GetRangePropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0),	0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
@@ -332,7 +335,7 @@ const SfxItemPropertySet* lcl_GetRangePropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
@@ -342,7 +345,8 @@ const SfxItemPropertySet* lcl_GetRangePropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIXML),	SC_WID_UNO_VALIXML,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((sal_Int32*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {0,0,0,0,0,0}
     };
@@ -415,6 +419,7 @@ const SfxItemPropertySet* lcl_GetCellPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_FORMLOC),	SC_WID_UNO_FORMLOC,	&getCppuType((rtl::OUString*)0),		0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_FORMRT),	SC_WID_UNO_FORMRT,	&getCppuType((table::CellContentType*)0), 0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, LEFT_BORDER | CONVERT_TWIPS },
@@ -435,7 +440,7 @@ const SfxItemPropertySet* lcl_GetCellPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
@@ -445,7 +450,8 @@ const SfxItemPropertySet* lcl_GetCellPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIXML),	SC_WID_UNO_VALIXML,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((sal_Int32*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {0,0,0,0,0,0}
     };
@@ -516,6 +522,7 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
 //		{MAP_CHAR_LEN(SC_UNONAME_CELLFILT),	SC_WID_UNO_CELLFILT,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_MANPAGE),	SC_WID_UNO_MANPAGE,	&getBooleanCppuType(),					0, 0 },
@@ -541,7 +548,7 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
@@ -551,7 +558,8 @@ const SfxItemPropertySet* lcl_GetColumnPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIXML),	SC_WID_UNO_VALIXML,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((sal_Int32*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLWID),	SC_WID_UNO_CELLWID,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {0,0,0,0,0,0}
@@ -621,6 +629,7 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHGT),	SC_WID_UNO_CELLHGT,	&getCppuType((sal_Int32*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_CELLFILT),	SC_WID_UNO_CELLFILT,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_MANPAGE),	SC_WID_UNO_MANPAGE,	&getBooleanCppuType(),					0, 0 },
@@ -646,7 +655,7 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_POS),		SC_WID_UNO_POS,		&getCppuType((awt::Point*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),			    0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SIZE),		SC_WID_UNO_SIZE,	&getCppuType((awt::Size*)0),			0 | beans::PropertyAttribute::READONLY, 0 },
@@ -656,7 +665,8 @@ const SfxItemPropertySet* lcl_GetRowPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIXML),	SC_WID_UNO_VALIXML,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((sal_Int32*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {0,0,0,0,0,0}
     };
@@ -729,6 +739,7 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_BLTR), ATTR_BORDER_BLTR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&getCppuType((table::CellHoriJustify*)0), 0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_ISACTIVE),	SC_WID_UNO_ISACTIVE,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&getBooleanCppuType(),					0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&getBooleanCppuType(),					0, 0 },
@@ -756,7 +767,7 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_PROTECT),  SC_WID_UNO_PROTECT,	&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0), 0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&getCppuType((sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&getCppuType((table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHOWBORD), SC_WID_UNO_SHOWBORD,&getBooleanCppuType(),					0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),               0, 0 },
@@ -768,8 +779,9 @@ const SfxItemPropertySet* lcl_GetSheetPropertySet()
         {MAP_CHAR_LEN(SC_UNONAME_VALIDAT),	SC_WID_UNO_VALIDAT,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALILOC),	SC_WID_UNO_VALILOC,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VALIXML),	SC_WID_UNO_VALIXML,	&getCppuType((uno::Reference<beans::XPropertySet>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((table::CellVertJustify*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&getCppuType((sal_Int32*)0), 0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TABCOLOR), SC_WID_UNO_TABCOLOR, &getCppuType((sal_Int32*)0), 0, 0 },
         {0,0,0,0,0,0}
     };
diff --git sc/source/ui/unoobj/styleuno.cxx sc/source/ui/unoobj/styleuno.cxx
index 3ddccdb..f62f17c 100644
--- sc/source/ui/unoobj/styleuno.cxx
+++ sc/source/ui/unoobj/styleuno.cxx
@@ -50,7 +50,7 @@
 #include <rtl/uuid.h>
 
 #include <com/sun/star/table/BorderLine.hpp>
-#include <com/sun/star/table/CellVertJustify.hpp>
+#include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/TableBorder.hpp>
 #include <com/sun/star/table/ShadowFormat.hpp>
 #include <com/sun/star/table/CellHoriJustify.hpp>
@@ -135,6 +135,7 @@ const SfxItemPropertySet* lcl_GetCellStyleSet()
         {MAP_CHAR_LEN(SC_UNONAME_DIAGONAL_TLBR), ATTR_BORDER_TLBR, &::getCppuType((const table::BorderLine*)0), 0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_DISPNAME),	SC_WID_UNO_DISPNAME,&::getCppuType((rtl::OUString*)0),	beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS),	ATTR_HOR_JUSTIFY,	&::getCppuType((const table::CellHoriJustify*)0),	0, MID_HORJUST_HORJUST },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLHJUS_METHOD), ATTR_HOR_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_CELLTRAN),	ATTR_BACKGROUND,	&::getBooleanCppuType(),			0, MID_GRAPHIC_TRANSPARENT },
         {MAP_CHAR_LEN(SC_UNONAME_WRAP),		ATTR_LINEBREAK,		&::getBooleanCppuType(),			0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_LEFTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0),		0, LEFT_BORDER | CONVERT_TWIPS },
@@ -154,13 +155,14 @@ const SfxItemPropertySet* lcl_GetCellStyleSet()
         {MAP_CHAR_LEN(SC_UNONAME_PTMARGIN),	ATTR_MARGIN,		&::getCppuType((const sal_Int32*)0),			0, MID_MARGIN_UP_MARGIN | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_RIGHTBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0),		0, RIGHT_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_ROTANG),	ATTR_ROTATE_VALUE,	&::getCppuType((const sal_Int32*)0),			0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&::getCppuType((const table::CellVertJustify*)0),	0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_ROTREF),	ATTR_ROTATE_MODE,	&::getCppuType((const sal_Int32*)0),	0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_SHADOW),	ATTR_SHADOW,		&::getCppuType((const table::ShadowFormat*)0),	0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_SHRINK_TO_FIT), ATTR_SHRINKTOFIT, &getBooleanCppuType(),               0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_TBLBORD),	SC_WID_UNO_TBLBORD,	&::getCppuType((const table::TableBorder*)0),		0, 0 | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_TOPBORDER),ATTR_BORDER,		&::getCppuType((const table::BorderLine*)0),		0, TOP_BORDER | CONVERT_TWIPS },
         {MAP_CHAR_LEN(SC_UNONAME_USERDEF),	ATTR_USERDEF,		&getCppuType((uno::Reference<container::XNameContainer>*)0), 0, 0 },
-        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&::getCppuType((const table::CellVertJustify*)0),	0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS),	ATTR_VER_JUSTIFY,	&::getCppuType((const sal_Int32*)0),	0, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_CELLVJUS_METHOD), ATTR_VER_JUSTIFY_METHOD, &::getCppuType((const sal_Int32*)0),   0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_WRITING),	ATTR_WRITINGDIR,	&getCppuType((sal_Int16*)0),			0, 0 },
         {0,0,0,0,0,0}
     };
diff --git sc/source/ui/vba/vbaformat.cxx sc/source/ui/vba/vbaformat.cxx
index f9b54a0..ebf2169 100644
--- sc/source/ui/vba/vbaformat.cxx
+++ sc/source/ui/vba/vbaformat.cxx
@@ -31,7 +31,7 @@
 #include <ooo/vba/excel/XlOrientation.hpp>
 #include <ooo/vba/excel/Constants.hpp>
 #include <ooo/vba/excel/XRange.hpp>
-#include <com/sun/star/table/CellVertJustify.hpp>
+#include <com/sun/star/table/CellVertJustify2.hpp>
 #include <com/sun/star/table/CellHoriJustify.hpp>
 #include <com/sun/star/table/CellOrientation.hpp>
 #include <com/sun/star/table/XCellRange.hpp>
@@ -82,21 +82,21 @@ ScVbaFormat<Ifc1>::setVerticalAlignment( const uno::Any& _oAlignment)   throw (s
         switch (nAlignment) 
         {
             case excel::XlVAlign::xlVAlignBottom :
-                aVal =  uno::makeAny( table::CellVertJustify_BOTTOM );
+                aVal =  uno::makeAny( table::CellVertJustify2::BOTTOM );
                 break;
             case excel::XlVAlign::xlVAlignCenter :
-                aVal = uno::makeAny( table::CellVertJustify_CENTER );
+                aVal = uno::makeAny( table::CellVertJustify2::CENTER );
                 break;
             case excel::XlVAlign::xlVAlignDistributed:
             case excel::XlVAlign::xlVAlignJustify:
-                aVal = uno::makeAny( table::CellVertJustify_STANDARD );
+                aVal = uno::makeAny( table::CellVertJustify2::STANDARD );
                 break;
     
             case excel::XlVAlign::xlVAlignTop:
-                aVal = uno::makeAny( table::CellVertJustify_TOP);
+                aVal = uno::makeAny( table::CellVertJustify2::TOP);
                 break;
             default:
-                aVal = uno::makeAny( table::CellVertJustify_STANDARD ); 
+                aVal = uno::makeAny( table::CellVertJustify2::STANDARD );
                 break;
         }
         mxPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_CELLVJUS ) ), aVal );
@@ -116,20 +116,20 @@ ScVbaFormat<Ifc1>::getVerticalAlignment(  ) throw (script::BasicErrorException,
     {
         if (!isAmbiguous( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_CELLVJUS ) ) ) )
         {
-            table::CellVertJustify aAPIAlignment;
+            sal_Int32 aAPIAlignment;
             mxPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_CELLVJUS ) ) ) >>= aAPIAlignment;
             switch( aAPIAlignment )
             {
-                case table::CellVertJustify_BOTTOM:
+                case table::CellVertJustify2::BOTTOM:
                     aResult = uno::makeAny( excel::XlVAlign::xlVAlignBottom );
                     break;
-                case table::CellVertJustify_CENTER:
+                case table::CellVertJustify2::CENTER:
                     aResult = uno::makeAny( excel::XlVAlign::xlVAlignCenter );
                     break;
-                case table::CellVertJustify_STANDARD:
+                case table::CellVertJustify2::STANDARD:
                     aResult = uno::makeAny( excel::XlVAlign::xlVAlignBottom );
                     break;
-                case table::CellVertJustify_TOP:
+                case table::CellVertJustify2::TOP:
                     aResult = uno::makeAny( excel::XlVAlign::xlVAlignTop );
                     break;
                 default:
diff --git sc/source/ui/view/output2.cxx sc/source/ui/view/output2.cxx
index 6707e6c..1594fc4 100644
--- sc/source/ui/view/output2.cxx
+++ sc/source/ui/view/output2.cxx
@@ -104,6 +104,8 @@ class ScDrawStringsVars
     SvxCellOrientation	eAttrOrient;
     SvxCellHorJustify	eAttrHorJust;
     SvxCellVerJustify	eAttrVerJust;
+    SvxCellJustifyMethod eAttrHorJustMethod;
+    SvxCellJustifyMethod eAttrVerJustMethod;
     const SvxMarginItem* pMargin;
     USHORT				nIndent;
     BOOL				bRotated;
@@ -145,6 +147,8 @@ public:
     SvxCellOrientation		GetOrient() const		{ return eAttrOrient; }
     SvxCellHorJustify		GetHorJust() const		{ return eAttrHorJust; }
     SvxCellVerJustify		GetVerJust() const		{ return eAttrVerJust; }
+    SvxCellJustifyMethod    GetHorJustMethod() const { return eAttrHorJustMethod; }
+    SvxCellJustifyMethod    GetVerJustMethod() const { return eAttrVerJustMethod; }
     const SvxMarginItem*	GetMargin() const		{ return pMargin; }
 
     USHORT	GetLeftTotal() const		{ return pMargin->GetLeftMargin() + nIndent; }
@@ -186,6 +190,8 @@ ScDrawStringsVars::ScDrawStringsVars(ScOutputData* pData, BOOL bPTL) :
     eAttrOrient	( SVX_ORIENTATION_STANDARD ),
     eAttrHorJust( SVX_HOR_JUSTIFY_STANDARD ),
     eAttrVerJust( SVX_VER_JUSTIFY_BOTTOM ),
+    eAttrHorJustMethod( SVX_JUSTIFY_METHOD_AUTO ),
+    eAttrVerJustMethod( SVX_JUSTIFY_METHOD_AUTO ),
     pMargin		( NULL ),
     nIndent		( 0 ),
     bRotated	( FALSE ),
@@ -256,6 +262,22 @@ void ScDrawStringsVars::SetShrinkScale( long nScale, BYTE nScript )
     SetAutoText( aString );     // same text again, to get text size
 }
 
+namespace {
+
+template<typename _ItemType, typename _EnumType>
+_EnumType lcl_GetValue(const ScPatternAttr& rPattern, USHORT nWhich, const SfxItemSet* pCondSet)
+{
+    const _ItemType& rItem = static_cast<const _ItemType&>(rPattern.GetItem(nWhich, pCondSet));
+    return static_cast<_EnumType>(rItem.GetValue());
+}
+
+bool lcl_GetBoolValue(const ScPatternAttr& rPattern, USHORT nWhich, const SfxItemSet* pCondSet)
+{
+    return lcl_GetValue<SfxBoolItem, bool>(rPattern, nWhich, pCondSet);
+}
+
+}
+
 void ScDrawStringsVars::SetPattern( const ScPatternAttr* pNew, const SfxItemSet* pSet,
                                     ScBaseCell* pCell, BYTE nScript )
 {
@@ -305,6 +327,11 @@ void ScDrawStringsVars::SetPattern( const ScPatternAttr* pNew, const SfxItemSet*
     if ( eAttrVerJust == SVX_VER_JUSTIFY_STANDARD )
         eAttrVerJust = SVX_VER_JUSTIFY_BOTTOM;
 
+    // justification method
+
+    eAttrHorJustMethod = lcl_GetValue<SvxJustifyMethodItem, SvxCellJustifyMethod>(*pPattern, ATTR_HOR_JUSTIFY_METHOD, pCondSet);
+    eAttrVerJustMethod = lcl_GetValue<SvxJustifyMethodItem, SvxCellJustifyMethod>(*pPattern, ATTR_VER_JUSTIFY_METHOD, pCondSet);
+
     //	line break
 
     bLineBreak = ((const SfxBoolItem&)pPattern->GetItem( ATTR_LINEBREAK, pCondSet )).GetValue();
@@ -946,8 +973,12 @@ inline BOOL StringDiffer( const ScPatternAttr*& rpOldPattern, const ScPatternAtt
         return TRUE;
     else if ( &rpNewPattern->GetItem( ATTR_HOR_JUSTIFY ) != &rpOldPattern->GetItem( ATTR_HOR_JUSTIFY ) )
         return TRUE;
+    else if ( &rpNewPattern->GetItem( ATTR_HOR_JUSTIFY_METHOD ) != &rpOldPattern->GetItem( ATTR_HOR_JUSTIFY_METHOD ) )
+        return TRUE;
     else if ( &rpNewPattern->GetItem( ATTR_VER_JUSTIFY ) != &rpOldPattern->GetItem( ATTR_VER_JUSTIFY ) )
         return TRUE;
+    else if ( &rpNewPattern->GetItem( ATTR_VER_JUSTIFY_METHOD ) != &rpOldPattern->GetItem( ATTR_VER_JUSTIFY_METHOD ) )
+        return TRUE;
     else if ( &rpNewPattern->GetItem( ATTR_STACKED ) != &rpOldPattern->GetItem( ATTR_STACKED ) )
         return TRUE;
     else if ( &rpNewPattern->GetItem( ATTR_LINEBREAK ) != &rpOldPattern->GetItem( ATTR_LINEBREAK ) )
@@ -1632,6 +1663,12 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                             bNeedEdit = ( nHeight > aAreaParam.maClipRect.GetHeight() );
                         }
                     }
+                    if (!bNeedEdit)
+                    {
+                        bNeedEdit =
+                            aVars.GetHorJust() == SVX_HOR_JUSTIFY_BLOCK &&
+                            aVars.GetHorJustMethod() == SVX_JUSTIFY_METHOD_DISTRIBUTE;
+                    }
                 }
                 if (bNeedEdit)
                 {
@@ -1724,6 +1761,7 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                         switch (aVars.GetVerJust())
                         {
                             case SVX_VER_JUSTIFY_TOP:
+                            case SVX_VER_JUSTIFY_BLOCK:
                                 {
                                     long nTop = (long)( aVars.GetMargin()->GetTopMargin() * nPPTY );
                                     nJustPosY += nTop;
@@ -2070,6 +2108,253 @@ void ScOutputData::ShrinkEditEngine( EditEngine& rEngine, const Rectangle& rAlig
     }
 }
 
+namespace {
+
+class EditAlignmentParam
+{
+public:
+    SvxCellHorJustify       meHorJust;
+    SvxCellVerJustify       meVerJust;
+    SvxCellJustifyMethod    meHorJustMethod;
+    SvxCellJustifyMethod    meVerJustMethod;
+    SvxCellOrientation      meOrient;
+    bool                    mbBreak;
+    bool                    mbCellIsValue;
+    bool                    mbAsianVertical;
+
+    explicit EditAlignmentParam(const ScPatternAttr* pPattern, const SfxItemSet* pCondSet, bool bCellIsValue);
+
+    void calcMargins(long& rTop, long& rLeft, long& rBottom, long& rRight, double nPPTX, double nPPTY) const;
+    void calcPaperSize(Size& rPaperSize, const Rectangle& rAlignRect, double nPPTX, double nPPTY) const;
+    void getEngineSize(ScFieldEditEngine* pEngine, long& rWidth, long& rHeight) const;
+    long getEngineWidth(ScFieldEditEngine* pEngine) const;
+    bool hasLineBreak() const;
+
+    /**
+     * When the text is vertically oriented, the text is either rotated 90
+     * degrees to the right or 90 degrees to the left.   Note that this is
+     * different from being vertically stacked.
+     */
+    bool isVerticallyOriented() const;
+
+    void setAlignmentItems(ScFieldEditEngine* pEngine);
+    bool adjustHorAlignment(ScFieldEditEngine* pEngine);
+
+private:
+    const ScPatternAttr*    mpPattern;
+    const SfxItemSet*       mpCondSet;
+};
+
+EditAlignmentParam::EditAlignmentParam(const ScPatternAttr* pPattern, const SfxItemSet* pCondSet, bool bCellIsValue) :
+    meHorJust( lcl_GetValue<SvxHorJustifyItem, SvxCellHorJustify>(*pPattern, ATTR_HOR_JUSTIFY, pCondSet) ),
+    meVerJust( lcl_GetValue<SvxVerJustifyItem, SvxCellVerJustify>(*pPattern, ATTR_VER_JUSTIFY, pCondSet) ),
+    meHorJustMethod( lcl_GetValue<SvxJustifyMethodItem, SvxCellJustifyMethod>(*pPattern, ATTR_HOR_JUSTIFY_METHOD, pCondSet) ),
+    meVerJustMethod( lcl_GetValue<SvxJustifyMethodItem, SvxCellJustifyMethod>(*pPattern, ATTR_VER_JUSTIFY_METHOD, pCondSet) ),
+    meOrient( pPattern->GetCellOrientation(pCondSet) ),
+    mbBreak( (meHorJust == SVX_HOR_JUSTIFY_BLOCK) || lcl_GetBoolValue(*pPattern, ATTR_LINEBREAK, pCondSet) ),
+    mbCellIsValue(bCellIsValue),
+    mpPattern(pPattern),
+    mpCondSet(pCondSet)
+{}
+
+void EditAlignmentParam::calcMargins(long& rTopM, long& rLeftM, long& rBottomM, long& rRightM, double nPPTX, double nPPTY) const
+{
+    const SvxMarginItem& rMargin =
+        static_cast<const SvxMarginItem&>(mpPattern->GetItem(ATTR_MARGIN, mpCondSet));
+
+    USHORT nIndent = 0;
+    if (meHorJust == SVX_HOR_JUSTIFY_LEFT)
+        nIndent = lcl_GetValue<SfxUInt16Item, USHORT>(*mpPattern, ATTR_INDENT, mpCondSet);
+
+    rLeftM   = static_cast<long>(((rMargin.GetLeftMargin() + nIndent) * nPPTX));
+    rTopM    = static_cast<long>((rMargin.GetTopMargin() * nPPTY));
+    rRightM  = static_cast<long>((rMargin.GetRightMargin() * nPPTX));
+    rBottomM = static_cast<long>((rMargin.GetBottomMargin() * nPPTY));
+}
+
+void EditAlignmentParam::calcPaperSize(
+    Size& rPaperSize, const Rectangle& rAlignRect, double nPPTX, double nPPTY) const
+{
+    long nTopM, nLeftM, nBottomM, nRightM;
+    calcMargins(nTopM, nLeftM, nBottomM, nRightM, nPPTX, nPPTY);
+
+    if (isVerticallyOriented())
+    {
+        rPaperSize.Width() = rAlignRect.GetHeight() - nTopM - nBottomM;
+        rPaperSize.Height() = rAlignRect.GetWidth() - nLeftM - nRightM;
+    }
+    else
+    {
+        rPaperSize.Width() = rAlignRect.GetWidth() - nLeftM - nRightM;
+        rPaperSize.Height() = rAlignRect.GetHeight() - nTopM - nBottomM;
+    }
+
+    if (mbAsianVertical && mbBreak)
+    {
+        //	add some extra height (default margin value) for safety
+        //	as long as GetEditArea isn't used below
+        long nExtraHeight = static_cast<long>(20*nPPTY);
+        rPaperSize.Height() = rAlignRect.GetHeight() - nTopM - nBottomM + nExtraHeight;
+    }
+}
+
+void EditAlignmentParam::getEngineSize(ScFieldEditEngine* pEngine, long& rWidth, long& rHeight) const
+{
+    long nEngineWidth = 0;
+    if (!mbBreak || meOrient == SVX_ORIENTATION_STACKED || mbAsianVertical)
+        nEngineWidth = static_cast<long>(pEngine->CalcTextWidth());
+
+    long nEngineHeight = pEngine->GetTextHeight();
+
+    if (isVerticallyOriented())
+    {
+        long nTemp = nEngineWidth;
+        nEngineWidth = nEngineHeight;
+        nEngineHeight = nTemp;
+    }
+
+    if (meOrient == SVX_ORIENTATION_STACKED)
+        nEngineWidth = nEngineWidth * 11 / 10;
+
+    rWidth = nEngineWidth;
+    rHeight = nEngineHeight;
+}
+
+long EditAlignmentParam::getEngineWidth(ScFieldEditEngine* pEngine) const
+{
+    if (mbBreak && meOrient != SVX_ORIENTATION_STACKED && !mbAsianVertical)
+        return 0;
+    else
+        return static_cast<long>(pEngine->CalcTextWidth());
+}
+
+bool EditAlignmentParam::hasLineBreak() const
+{
+    return (mbBreak || (meOrient == SVX_ORIENTATION_STACKED) || mbAsianVertical);
+}
+
+bool EditAlignmentParam::isVerticallyOriented() const
+{
+    return (meOrient == SVX_ORIENTATION_TOPBOTTOM || meOrient == SVX_ORIENTATION_BOTTOMTOP);
+}
+
+void EditAlignmentParam::setAlignmentItems(ScFieldEditEngine* pEngine)
+{
+    if (isVerticallyOriented() || mbAsianVertical)
+    {
+        SvxAdjust eSvxAdjust = SVX_ADJUST_LEFT;
+        switch (meVerJust)
+        {
+            case SVX_VER_JUSTIFY_TOP:
+                eSvxAdjust = (meOrient == SVX_ORIENTATION_TOPBOTTOM || mbAsianVertical) ?
+                            SVX_ADJUST_LEFT : SVX_ADJUST_RIGHT;
+                break;
+            case SVX_VER_JUSTIFY_CENTER:
+                eSvxAdjust = SVX_ADJUST_CENTER;
+                break;
+            case SVX_VER_JUSTIFY_BOTTOM:
+            case SVX_VER_JUSTIFY_STANDARD:
+                eSvxAdjust = (meOrient == SVX_ORIENTATION_TOPBOTTOM || mbAsianVertical) ?
+                            SVX_ADJUST_RIGHT : SVX_ADJUST_LEFT;
+                break;
+            case SVX_VER_JUSTIFY_BLOCK:
+                eSvxAdjust = SVX_ADJUST_BLOCK;
+                break;
+        }
+
+        pEngine->SetDefaultItem( SvxAdjustItem(eSvxAdjust, EE_PARA_JUST) );
+        pEngine->SetDefaultItem( SvxJustifyMethodItem(meVerJustMethod, EE_PARA_JUST_METHOD) );
+
+        if (meHorJust == SVX_HOR_JUSTIFY_BLOCK)
+            pEngine->SetDefaultItem( SvxVerJustifyItem(SVX_VER_JUSTIFY_BLOCK, EE_PARA_VER_JUST) );
+    }
+    else
+    {
+        //	horizontal alignment now may depend on cell content
+        //	(for values with number formats with mixed script types)
+        //	-> always set adjustment
+
+        SvxAdjust eSvxAdjust = SVX_ADJUST_LEFT;
+        if (meOrient == SVX_ORIENTATION_STACKED)
+            eSvxAdjust = SVX_ADJUST_CENTER;
+        else if (mbBreak)
+        {
+            if (meOrient == SVX_ORIENTATION_STANDARD)
+                switch (meHorJust)
+                {
+                    case SVX_HOR_JUSTIFY_STANDARD:
+                        eSvxAdjust = mbCellIsValue ? SVX_ADJUST_RIGHT : SVX_ADJUST_LEFT;
+                        break;
+                    case SVX_HOR_JUSTIFY_LEFT:
+                    case SVX_HOR_JUSTIFY_REPEAT:			// nicht implementiert
+                        eSvxAdjust = SVX_ADJUST_LEFT;
+                        break;
+                    case SVX_HOR_JUSTIFY_RIGHT:
+                        eSvxAdjust = SVX_ADJUST_RIGHT;
+                        break;
+                    case SVX_HOR_JUSTIFY_CENTER:
+                        eSvxAdjust = SVX_ADJUST_CENTER;
+                        break;
+                    case SVX_HOR_JUSTIFY_BLOCK:
+                        eSvxAdjust = SVX_ADJUST_BLOCK;
+                        break;
+                }
+            else
+                switch (meVerJust)
+                {
+                    case SVX_VER_JUSTIFY_TOP:
+                        eSvxAdjust = SVX_ADJUST_RIGHT;
+                        break;
+                    case SVX_VER_JUSTIFY_CENTER:
+                        eSvxAdjust = SVX_ADJUST_CENTER;
+                        break;
+                    case SVX_VER_JUSTIFY_BOTTOM:
+                    case SVX_VER_JUSTIFY_STANDARD:
+                        eSvxAdjust = SVX_ADJUST_LEFT;
+                        break;
+                    case SVX_VER_JUSTIFY_BLOCK:
+                        eSvxAdjust = SVX_ADJUST_BLOCK;
+                        break;
+                }
+        }
+
+        pEngine->SetDefaultItem( SvxAdjustItem(eSvxAdjust, EE_PARA_JUST) );
+
+        if (mbAsianVertical)
+        {
+            pEngine->SetDefaultItem( SvxJustifyMethodItem(meVerJustMethod, EE_PARA_JUST_METHOD) );
+            if (meHorJust == SVX_HOR_JUSTIFY_BLOCK)
+                pEngine->SetDefaultItem( SvxVerJustifyItem(SVX_VER_JUSTIFY_BLOCK, EE_PARA_VER_JUST) );
+        }
+        else
+        {
+            pEngine->SetDefaultItem( SvxJustifyMethodItem(meHorJustMethod, EE_PARA_JUST_METHOD) );
+            if (meVerJust == SVX_VER_JUSTIFY_BLOCK)
+                pEngine->SetDefaultItem( SvxVerJustifyItem(SVX_VER_JUSTIFY_BLOCK, EE_PARA_VER_JUST) );
+        }
+    }
+
+    pEngine->SetVertical(mbAsianVertical);
+}
+
+bool EditAlignmentParam::adjustHorAlignment(ScFieldEditEngine* pEngine)
+{
+    if (meHorJust == SVX_HOR_JUSTIFY_RIGHT || meHorJust == SVX_HOR_JUSTIFY_CENTER ||
+        (meHorJust == SVX_HOR_JUSTIFY_STANDARD && mbCellIsValue))
+    {
+        SvxAdjust eEditAdjust = (meHorJust == SVX_HOR_JUSTIFY_CENTER) ?
+            SVX_ADJUST_CENTER : SVX_ADJUST_RIGHT;
+
+        pEngine->SetUpdateMode(false);
+        pEngine->SetDefaultItem( SvxAdjustItem(eEditAdjust, EE_PARA_JUST) );
+        pEngine->SetUpdateMode(true);
+        return true;
+    }
+    return false;
+}
+
+}
+
 void ScOutputData::DrawEdit(BOOL bPixelToLogic)
 {
     vcl::PDFExtOutDevData* pPDFData = PTR_CAST( vcl::PDFExtOutDevData, pDev->GetExtOutDevData() );
@@ -2222,86 +2507,55 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                         else
                             lcl_ClearEdit( *pEngine );		// also calls SetUpdateMode(FALSE)
 
+                        EditAlignmentParam aAlignParam(pPattern, pCondSet, lcl_SafeIsValue(pCell));
 
-                        BOOL bCellIsValue = lcl_SafeIsValue(pCell);
+                        bool bRepeat = (aAlignParam.meHorJust == SVX_HOR_JUSTIFY_REPEAT && !aAlignParam.mbBreak);
+                        bool bShrink = !aAlignParam.mbBreak && !bRepeat && lcl_GetBoolValue(*pPattern, ATTR_SHRINKTOFIT, pCondSet);
+                        long nAttrRotate = lcl_GetValue<SfxInt32Item, long>(*pPattern, ATTR_ROTATE_VALUE, pCondSet);
 
-                        SvxCellHorJustify eHorJust = (SvxCellHorJustify)((const SvxHorJustifyItem&)
-                                            pPattern->GetItem(ATTR_HOR_JUSTIFY, pCondSet)).GetValue();
-                        BOOL bBreak = ( eHorJust == SVX_HOR_JUSTIFY_BLOCK ) ||
-                                        ((const SfxBoolItem&)pPattern->GetItem(ATTR_LINEBREAK, pCondSet)).GetValue();
-                        BOOL bRepeat = ( eHorJust == SVX_HOR_JUSTIFY_REPEAT && !bBreak );
-                        BOOL bShrink = !bBreak && !bRepeat && static_cast<const SfxBoolItem&>
-                                        (pPattern->GetItem( ATTR_SHRINKTOFIT, pCondSet )).GetValue();
-                        SvxCellOrientation eOrient = pPattern->GetCellOrientation( pCondSet );
-                        long nAttrRotate = ((const SfxInt32Item&)pPattern->
-                                            GetItem(ATTR_ROTATE_VALUE, pCondSet)).GetValue();
-                        if ( eHorJust == SVX_HOR_JUSTIFY_REPEAT )
+                        if ( aAlignParam.meHorJust == SVX_HOR_JUSTIFY_REPEAT )
                         {
                             // ignore orientation/rotation if "repeat" is active
-                            eOrient = SVX_ORIENTATION_STANDARD;
+                            aAlignParam.meOrient = SVX_ORIENTATION_STANDARD;
                             nAttrRotate = 0;
 
                             // #i31843# "repeat" with "line breaks" is treated as default alignment
                             // (but rotation is still disabled)
-                            if ( bBreak )
-                                eHorJust = SVX_HOR_JUSTIFY_STANDARD;
+                            if ( aAlignParam.mbBreak )
+                                aAlignParam.meHorJust = SVX_HOR_JUSTIFY_STANDARD;
                         }
-                        if ( eOrient==SVX_ORIENTATION_STANDARD && nAttrRotate )
+                        if ( aAlignParam.meOrient==SVX_ORIENTATION_STANDARD && nAttrRotate )
                         {
                             //!	Flag setzen, um die Zelle in DrawRotated wiederzufinden ?
                             //!	(oder Flag schon bei DrawBackground, dann hier keine Abfrage)
                             bHidden = TRUE;		// gedreht wird getrennt ausgegeben
                         }
 
-                        BOOL bAsianVertical = ( eOrient == SVX_ORIENTATION_STACKED &&
-                                ((const SfxBoolItem&)pPattern->GetItem( ATTR_VERTICAL_ASIAN, pCondSet )).GetValue() );
-                        if ( bAsianVertical )
+                        aAlignParam.mbAsianVertical = (aAlignParam.meOrient == SVX_ORIENTATION_STACKED) &&
+                            lcl_GetBoolValue(*pPattern, ATTR_VERTICAL_ASIAN, pCondSet);
+
+                        if ( aAlignParam.mbAsianVertical )
                         {
                             // in asian mode, use EditEngine::SetVertical instead of EE_CNTRL_ONECHARPERLINE
-                            eOrient = SVX_ORIENTATION_STANDARD;
+                            aAlignParam.meOrient = SVX_ORIENTATION_STANDARD;
                             // default alignment for asian vertical mode is top-right
-                            if ( eHorJust == SVX_HOR_JUSTIFY_STANDARD )
-                                eHorJust = SVX_HOR_JUSTIFY_RIGHT;
+                            if ( aAlignParam.meHorJust == SVX_HOR_JUSTIFY_STANDARD )
+                                aAlignParam.meHorJust = SVX_HOR_JUSTIFY_RIGHT;
                         }
 
-
-
                         SvxCellHorJustify eOutHorJust =
-                            ( eHorJust != SVX_HOR_JUSTIFY_STANDARD ) ? eHorJust :
-                            ( bCellIsValue ? SVX_HOR_JUSTIFY_RIGHT : SVX_HOR_JUSTIFY_LEFT );
+                            ( aAlignParam.meHorJust != SVX_HOR_JUSTIFY_STANDARD ) ? aAlignParam.meHorJust :
+                            ( aAlignParam.mbCellIsValue ? SVX_HOR_JUSTIFY_RIGHT : SVX_HOR_JUSTIFY_LEFT );
 
                         if ( eOutHorJust == SVX_HOR_JUSTIFY_BLOCK || eOutHorJust == SVX_HOR_JUSTIFY_REPEAT )
                             eOutHorJust = SVX_HOR_JUSTIFY_LEFT;		// repeat is not yet implemented
 
-
-//!						if ( !bHidden && eType == OUTTYPE_PRINTER &&
-//!							pDev->GetOutDevType() == OUTDEV_WINDOW &&
-//!							((const SvxFontHeightItem&)pPattern->
-//!							GetItem(ATTR_FONT_HEIGHT)).GetHeight() <= nMinHeight )
-//!						{
-//!							Point aPos( nStartX, nStartY );
-//!							pDev->DrawPixel( aPos,
-//!											((const SvxColorItem&)pPattern->
-//!											GetItem( ATTR_FONT_COLOR )).GetValue() );
-//!							bHidden = TRUE;
-//!						}
-
                         if (!bHidden)
                         {
                             //!	mirror margin values for RTL?
                             //!	move margin down to after final GetOutputArea call
-
-                            const SvxMarginItem* pMargin = (const SvxMarginItem*)
-                                                    &pPattern->GetItem(ATTR_MARGIN, pCondSet);
-                            USHORT nIndent = 0;
-                            if ( eHorJust == SVX_HOR_JUSTIFY_LEFT )
-                                nIndent = ((const SfxUInt16Item&)pPattern->
-                                                    GetItem(ATTR_INDENT, pCondSet)).GetValue();
-
-                            long nLeftM = (long) ( (pMargin->GetLeftMargin() + nIndent) * nPPTX );
-                            long nTopM  = (long) ( pMargin->GetTopMargin() * nPPTY );
-                            long nRightM = (long) ( pMargin->GetRightMargin() * nPPTX );
-                            long nBottomM = (long) ( pMargin->GetBottomMargin() * nPPTY );
+                            long nTopM, nLeftM, nBottomM, nRightM;
+                            aAlignParam.calcMargins(nTopM, nLeftM, nBottomM, nRightM, nPPTX, nPPTY);
 
                             SCCOL nXForPos = nX;
                             if ( nXForPos < nX1 )
@@ -2323,31 +2577,17 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                             //
 
                             Size aPaperSize = Size( 1000000, 1000000 );
-                            if ( bBreak || eOrient == SVX_ORIENTATION_STACKED || bAsianVertical )
+                            if (aAlignParam.hasLineBreak())
                             {
-                                //!	also stacked, AsianVertical
-
                                 //	call GetOutputArea with nNeeded=0, to get only the cell width
 
                                 //!	handle nArrY == 0
                                 GetOutputArea( nXForPos, nArrYForPos, nPosX, nPosY, nCellX, nCellY, 0,
                                                *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
-                                               bCellIsValue, true, false, aAreaParam );
+                                               aAlignParam.mbCellIsValue, true, false, aAreaParam );
 
                                 //! special ScEditUtil handling if formatting for printer
-
-                                if ( eOrient == SVX_ORIENTATION_TOPBOTTOM || eOrient == SVX_ORIENTATION_BOTTOMTOP )
-                                    aPaperSize.Width() = aAreaParam.maAlignRect.GetHeight() - nTopM - nBottomM;
-                                else
-                                    aPaperSize.Width() = aAreaParam.maAlignRect.GetWidth() - nLeftM - nRightM;
-
-                                if (bAsianVertical && bBreak)
-                                {
-                                    //	add some extra height (default margin value) for safety
-                                    //	as long as GetEditArea isn't used below
-                                    long nExtraHeight = (long)( 20 * nPPTY );
-                                    aPaperSize.Height() = aAreaParam.maAlignRect.GetHeight() - nTopM - nBottomM + nExtraHeight;
-                                }
+                                aAlignParam.calcPaperSize(aPaperSize, aAreaParam.maAlignRect, nPPTX, nPPTY);
                             }
                             if (bPixelToLogic)
                                 pEngine->SetPaperSize(pRefDevice->PixelToLogic(aPaperSize));
@@ -2358,12 +2598,9 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                             //	Fill the EditEngine (cell attributes and text)
                             //
 
-                            SvxCellVerJustify eVerJust = (SvxCellVerJustify)((const SvxVerJustifyItem&)
-                                                pPattern->GetItem(ATTR_VER_JUSTIFY, pCondSet)).GetValue();
-
                             // default alignment for asian vertical mode is top-right
-                            if ( bAsianVertical && eVerJust == SVX_VER_JUSTIFY_STANDARD )
-                                eVerJust = SVX_VER_JUSTIFY_TOP;
+                            if ( aAlignParam.mbAsianVertical && aAlignParam.meVerJust == SVX_VER_JUSTIFY_STANDARD )
+                                aAlignParam.meVerJust = SVX_VER_JUSTIFY_TOP;
 
                             // syntax highlighting mode is ignored here
                             // StringDiffer doesn't look at hyphenate, language items
@@ -2377,7 +2614,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 pOldCondSet = pCondSet;
 
                                 ULONG nControl = pEngine->GetControlWord();
-                                if (eOrient==SVX_ORIENTATION_STACKED)
+                                if (aAlignParam.meOrient==SVX_ORIENTATION_STACKED)
                                     nControl |= EE_CNTRL_ONECHARPERLINE;
                                 else
                                     nControl &= ~EE_CNTRL_ONECHARPERLINE;
@@ -2398,53 +2635,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 pEngine->SetBackgroundColor( aBackCol );
                             }
 
-                            //	horizontal alignment now may depend on cell content
-                            //	(for values with number formats with mixed script types)
-                            //	-> always set adjustment
-
-                            SvxAdjust eSvxAdjust = SVX_ADJUST_LEFT;
-                            if (eOrient==SVX_ORIENTATION_STACKED)
-                                eSvxAdjust = SVX_ADJUST_CENTER;
-                            else if (bBreak)
-                            {
-                                if (eOrient==SVX_ORIENTATION_STANDARD && !bAsianVertical)
-                                    switch (eHorJust)
-                                    {
-                                        case SVX_HOR_JUSTIFY_STANDARD:
-                                            eSvxAdjust = bCellIsValue ? SVX_ADJUST_RIGHT : SVX_ADJUST_LEFT;
-                                            break;
-                                        case SVX_HOR_JUSTIFY_LEFT:
-                                        case SVX_HOR_JUSTIFY_REPEAT:			// nicht implementiert
-                                            eSvxAdjust = SVX_ADJUST_LEFT;
-                                            break;
-                                        case SVX_HOR_JUSTIFY_RIGHT:
-                                            eSvxAdjust = SVX_ADJUST_RIGHT;
-                                            break;
-                                        case SVX_HOR_JUSTIFY_CENTER:
-                                            eSvxAdjust = SVX_ADJUST_CENTER;
-                                            break;
-                                        case SVX_HOR_JUSTIFY_BLOCK:
-                                            eSvxAdjust = SVX_ADJUST_BLOCK;
-                                            break;
-                                    }
-                                else
-                                    switch (eVerJust)
-                                    {
-                                        case SVX_VER_JUSTIFY_TOP:
-                                            eSvxAdjust = (eOrient==SVX_ORIENTATION_TOPBOTTOM || bAsianVertical) ?
-                                                        SVX_ADJUST_LEFT : SVX_ADJUST_RIGHT;
-                                            break;
-                                        case SVX_VER_JUSTIFY_CENTER:
-                                            eSvxAdjust = SVX_ADJUST_CENTER;
-                                            break;
-                                        case SVX_VER_JUSTIFY_BOTTOM:
-                                        case SVX_HOR_JUSTIFY_STANDARD:
-                                            eSvxAdjust = (eOrient==SVX_ORIENTATION_TOPBOTTOM || bAsianVertical) ?
-                                                        SVX_ADJUST_RIGHT : SVX_ADJUST_LEFT;
-                                            break;
-                                    }
-                            }
-                            pEngine->SetDefaultItem( SvxAdjustItem( eSvxAdjust, EE_PARA_JUST ) );
+                            aAlignParam.setAlignmentItems(pEngine);
 
                             //	Read content from cell
 
@@ -2460,7 +2651,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     {
                                         pEngine->SetText(*pData);
 
-                                        if ( bBreak && !bAsianVertical && pData->HasField() )
+                                        if ( aAlignParam.mbBreak && !aAlignParam.mbAsianVertical && pData->HasField() )
                                         {
                                             //	Fields aren't wrapped, so clipping is enabled to prevent
                                             //	a field from being drawn beyond the cell size
@@ -2501,49 +2692,33 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 DBG_ERROR("pCell == NULL");
                             }
 
-                            pEngine->SetVertical( bAsianVertical );
                             pEngine->SetUpdateMode( TRUE );		// after SetText, before CalcTextWidth/GetTextHeight
 
                             //
                             //	Get final output area using the calculated width
                             //
 
-                            long nEngineWidth;
-                            if ( bBreak && eOrient != SVX_ORIENTATION_STACKED && !bAsianVertical )
-                                nEngineWidth = 0;
-                            else
-                                nEngineWidth = (long) pEngine->CalcTextWidth();
-                            long nEngineHeight = pEngine->GetTextHeight();
-
-                            if (eOrient != SVX_ORIENTATION_STANDARD &&
-                                eOrient != SVX_ORIENTATION_STACKED)
-                            {
-                                long nTemp = nEngineWidth;
-                                nEngineWidth = nEngineHeight;
-                                nEngineHeight = nTemp;
-                            }
-
-                            if (eOrient == SVX_ORIENTATION_STACKED)
-                                nEngineWidth = nEngineWidth * 11 / 10;
+                            long nEngineWidth, nEngineHeight;
+                            aAlignParam.getEngineSize(pEngine, nEngineWidth, nEngineHeight);
 
                             long nNeededPixel = nEngineWidth;
                             if (bPixelToLogic)
                                 nNeededPixel = pRefDevice->LogicToPixel(Size(nNeededPixel,0)).Width();
                             nNeededPixel += nLeftM + nRightM;
 
-                            if ( ( !bBreak && eOrient != SVX_ORIENTATION_STACKED ) || bAsianVertical || bShrink )
+                            if ( ( !aAlignParam.mbBreak && aAlignParam.meOrient != SVX_ORIENTATION_STACKED ) || aAlignParam.mbAsianVertical || bShrink )
                             {
                                 // for break, the first GetOutputArea call is sufficient
                                 GetOutputArea( nXForPos, nArrYForPos, nPosX, nPosY, nCellX, nCellY, nNeededPixel,
                                                *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
-                                               bCellIsValue || bRepeat || bShrink, false, false, aAreaParam );
+                                               aAlignParam.mbCellIsValue || bRepeat || bShrink, false, false, aAreaParam );
 
                                 if ( bShrink )
                                 {
-                                    BOOL bWidth = ( eOrient == SVX_ORIENTATION_STANDARD && !bAsianVertical );
+                                    BOOL bWidth = ( aAlignParam.meOrient == SVX_ORIENTATION_STANDARD && !aAlignParam.mbAsianVertical );
                                     ShrinkEditEngine( *pEngine, aAreaParam.maAlignRect,
                                         nLeftM, nTopM, nRightM, nBottomM, bWidth,
-                                        sal::static_int_cast<USHORT>(eOrient), 0, bPixelToLogic,
+                                        sal::static_int_cast<USHORT>(aAlignParam.meOrient), 0, bPixelToLogic,
                                         nEngineWidth, nEngineHeight, nNeededPixel,
                                         aAreaParam.mbLeftClip, aAreaParam.mbRightClip );
                                 }
@@ -2588,7 +2763,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     }
                                 }
 
-                                if ( bCellIsValue && ( aAreaParam.mbLeftClip || aAreaParam.mbRightClip ) )
+                                if ( aAlignParam.mbCellIsValue && ( aAreaParam.mbLeftClip || aAreaParam.mbRightClip ) )
                                 {
                                     pEngine->SetText( String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("###")) );
                                     nEngineWidth = (long) pEngine->CalcTextWidth();
@@ -2601,7 +2776,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     //	No clip marks if "###" doesn't fit (same as in DrawStrings)
                                 }
 
-                                if ( eOutHorJust != SVX_HOR_JUSTIFY_LEFT && eOrient == SVX_ORIENTATION_STANDARD )
+                                if ( eOutHorJust != SVX_HOR_JUSTIFY_LEFT && aAlignParam.meOrient == SVX_ORIENTATION_STANDARD )
                                 {
                                     aPaperSize.Width() = nNeededPixel + 1;
                                     if (bPixelToLogic)
@@ -2617,13 +2792,15 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                             long nOutWidth = nCellWidth - 1 - nLeftM - nRightM;
                             long nOutHeight = aAreaParam.maAlignRect.GetHeight() - nTopM - nBottomM;
 
-                            if ( bBreak || eOrient != SVX_ORIENTATION_STANDARD || bAsianVertical )
+                            if ( aAlignParam.mbBreak || aAlignParam.meOrient != SVX_ORIENTATION_STANDARD || aAlignParam.mbAsianVertical )
                             {
                                 //	text with automatic breaks is aligned only within the
                                 //	edit engine's paper size, the output of the whole area
                                 //	is always left-aligned
 
                                 nStartX += nLeftM;
+                                if (aAlignParam.meOrient == SVX_ORIENTATION_TOPBOTTOM && aAlignParam.meHorJust == SVX_HOR_JUSTIFY_BLOCK)
+                                    nStartX += aPaperSize.Height();
                             }
                             else
                             {
@@ -2699,8 +2876,8 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     //	Only with automatic line breaks, to avoid having to find
                                     //	the cells with the horizontal end of the text again.
                                     if ( nEngineHeight - aCellSize.Height() > 100 &&
-                                         ( bBreak || eOrient == SVX_ORIENTATION_STACKED ) &&
-                                         !bAsianVertical && bMarkClipped &&
+                                         ( aAlignParam.mbBreak || aAlignParam.meOrient == SVX_ORIENTATION_STACKED ) &&
+                                         !aAlignParam.mbAsianVertical && bMarkClipped &&
                                          ( pEngine->GetParagraphCount() > 1 || pEngine->GetLineCount(0) > 1 ) )
                                     {
                                         CellInfo* pClipMarkCell = NULL;
@@ -2763,50 +2940,35 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     aLogicStart = pRefDevice->PixelToLogic( Point(nStartX,nStartY) );
                                 else
                                     aLogicStart = Point(nStartX, nStartY);
-                                if ( eOrient!=SVX_ORIENTATION_STANDARD || bAsianVertical || !bBreak )
+                                if ( aAlignParam.meOrient!=SVX_ORIENTATION_STANDARD || aAlignParam.mbAsianVertical || !aAlignParam.mbBreak )
                                 {
                                     long nAvailWidth = aCellSize.Width();
                                     // space for AutoFilter is already handled in GetOutputArea
 
                                     //	horizontal alignment
 
-                                    if (eOrient==SVX_ORIENTATION_STANDARD && !bAsianVertical)
+                                    if (aAlignParam.meOrient==SVX_ORIENTATION_STANDARD && !aAlignParam.mbAsianVertical)
                                     {
-                                        if (eHorJust==SVX_HOR_JUSTIFY_RIGHT ||
-                                            eHorJust==SVX_HOR_JUSTIFY_CENTER ||
-                                            (eHorJust==SVX_HOR_JUSTIFY_STANDARD && bCellIsValue) )
-                                        {
-                                            pEngine->SetUpdateMode( FALSE );
-
-                                            SvxAdjust eEditAdjust =
-                                                (eHorJust==SVX_HOR_JUSTIFY_CENTER) ?
-                                                    SVX_ADJUST_CENTER : SVX_ADJUST_RIGHT;
-                                            pEngine->SetDefaultItem(
-                                                SvxAdjustItem( eEditAdjust, EE_PARA_JUST ) );
-
+                                        if (aAlignParam.adjustHorAlignment(pEngine))
                                             // #55142# reset adjustment for the next cell
                                             pOldPattern = NULL;
-
-                                            pEngine->SetUpdateMode( TRUE );
-                                        }
                                     }
                                     else
                                     {
-                                        if (eHorJust==SVX_HOR_JUSTIFY_RIGHT)
+                                        if (aAlignParam.meHorJust==SVX_HOR_JUSTIFY_RIGHT)
                                             aLogicStart.X() += nAvailWidth - nEngineWidth;
-                                        else if (eHorJust==SVX_HOR_JUSTIFY_CENTER)
+                                        else if (aAlignParam.meHorJust==SVX_HOR_JUSTIFY_CENTER)
                                             aLogicStart.X() += (nAvailWidth - nEngineWidth) / 2;
                                     }
                                 }
 
-                                if ( bAsianVertical )
+                                if ( aAlignParam.mbAsianVertical )
                                 {
                                     // paper size is subtracted below
                                     aLogicStart.X() += nEngineWidth;
                                 }
 
-                                if ( ( bAsianVertical || eOrient == SVX_ORIENTATION_TOPBOTTOM ||
-                                        eOrient == SVX_ORIENTATION_BOTTOMTOP ) && bBreak )
+                                if ( (aAlignParam.mbAsianVertical || aAlignParam.isVerticallyOriented()) && aAlignParam.mbBreak )
                                 {
                                     // vertical adjustment is within the EditEngine
                                     if (bPixelToLogic)
@@ -2815,11 +2977,11 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                         aLogicStart.Y() += nTopM;
                                 }
 
-                                if ( ( eOrient==SVX_ORIENTATION_STANDARD && !bAsianVertical ) ||
-                                     eOrient==SVX_ORIENTATION_STACKED || !bBreak )
+                                if ( ( aAlignParam.meOrient==SVX_ORIENTATION_STANDARD && !aAlignParam.mbAsianVertical ) ||
+                                     aAlignParam.meOrient==SVX_ORIENTATION_STACKED || !aAlignParam.mbBreak )
                                 {
-                                    if (eVerJust==SVX_VER_JUSTIFY_BOTTOM ||
-                                        eVerJust==SVX_VER_JUSTIFY_STANDARD)
+                                    if (aAlignParam.meVerJust==SVX_VER_JUSTIFY_BOTTOM ||
+                                        aAlignParam.meVerJust==SVX_VER_JUSTIFY_STANDARD)
                                     {
                                         //!	if pRefDevice != pFmtDevice, keep heights in logic units,
                                         //! only converting margin?
@@ -2832,7 +2994,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                         else
                                             aLogicStart.Y() += nTopM + aCellSize.Height() - nEngineHeight;
                                     }
-                                    else if (eVerJust==SVX_VER_JUSTIFY_CENTER)
+                                    else if (aAlignParam.meVerJust==SVX_VER_JUSTIFY_CENTER)
                                     {
                                         if (bPixelToLogic)
                                             aLogicStart.Y() += pRefDevice->PixelToLogic( Size(0, nTopM + (
@@ -2854,19 +3016,20 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 Point aURLStart = aLogicStart;      // copy before modifying for orientation
 
                                 short nOriVal = 0;
-                                if (eOrient==SVX_ORIENTATION_TOPBOTTOM)
+                                if (aAlignParam.meOrient == SVX_ORIENTATION_TOPBOTTOM)
                                 {
                                     // nOriVal = -900;
                                     nOriVal = 2700;
-                                    aLogicStart.X() += nEngineWidth;
+                                    if (aAlignParam.meHorJust != SVX_HOR_JUSTIFY_BLOCK)
+                                        aLogicStart.X() += nEngineWidth;
                                 }
-                                else if (eOrient==SVX_ORIENTATION_BOTTOMTOP)
+                                else if (aAlignParam.meOrient == SVX_ORIENTATION_BOTTOMTOP)
                                 {
                                     nOriVal = 900;
-                                    aLogicStart.Y() += bBreak ? pEngine->GetPaperSize().Width() :
-                                                                nEngineHeight;
+                                    aLogicStart.Y() +=
+                                        aAlignParam.mbBreak ? pEngine->GetPaperSize().Width() : nEngineHeight;
                                 }
-                                else if (eOrient==SVX_ORIENTATION_STACKED)
+                                else if (aAlignParam.meOrient == SVX_ORIENTATION_STACKED)
                                 {
                                     Size aPaperLogic = pEngine->GetPaperSize();
                                     aPaperLogic.Width() = nEngineWidth;
@@ -2889,7 +3052,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 // bMoveClipped handling has been replaced by complete alignment
                                 // handling (also extending to the left).
 
-                                if ( bSimClip && !nOriVal && !bAsianVertical )
+                                if ( bSimClip && !nOriVal && !aAlignParam.mbAsianVertical )
                                 {
                                     //	kein hartes Clipping, aber nur die betroffenen
                                     //	Zeilen ausgeben
@@ -2900,7 +3063,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 }
                                 else
                                 {
-                                    if (bAsianVertical)
+                                    if (aAlignParam.mbAsianVertical)
                                     {
                                         //	with SetVertical, the start position is top left of
                                         //	the whole output area, not the text itself
@@ -2924,17 +3087,17 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 {
                                     long nURLWidth = (long) pEngine->CalcTextWidth();
                                     long nURLHeight = pEngine->GetTextHeight();
-                                    if ( bBreak )
+                                    if ( aAlignParam.mbBreak )
                                     {
                                         Size aPaper = pEngine->GetPaperSize();
-                                        if ( bAsianVertical )
+                                        if ( aAlignParam.mbAsianVertical )
                                             nURLHeight = aPaper.Height();
                                         else
                                             nURLWidth = aPaper.Width();
                                     }
-                                    if ( eOrient == SVX_ORIENTATION_TOPBOTTOM || eOrient == SVX_ORIENTATION_BOTTOMTOP )
+                                    if ( aAlignParam.isVerticallyOriented() )
                                         std::swap( nURLWidth, nURLHeight );
-                                    else if ( bAsianVertical )
+                                    else if ( aAlignParam.mbAsianVertical )
                                         aURLStart.X() -= nURLWidth;
 
                                     Rectangle aURLRect( aURLStart, Size( nURLWidth, nURLHeight ) );
-- 
1.7.0.1

