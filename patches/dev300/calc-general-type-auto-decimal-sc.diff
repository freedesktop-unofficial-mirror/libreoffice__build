From 4e30010537327ec2bb896fc3dd00871be36aea2e Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:56:22 +0200
Subject: [PATCH 205/878] calc-general-type-auto-decimal-sc.diff

---
 sc/inc/docoptio.hxx              |    6 +-
 sc/source/ui/inc/optdlg.hrc      |    1 +
 sc/source/ui/inc/output.hxx      |   23 ++-
 sc/source/ui/inc/tpcalc.hxx      |    1 +
 sc/source/ui/optdlg/tpcalc.cxx   |   59 ++++-
 sc/source/ui/src/optdlg.src      |   38 ++--
 sc/source/ui/unoobj/defltuno.cxx |    2 +-
 sc/source/ui/view/output2.cxx    |  447 ++++++++++++++++++++++++--------------
 8 files changed, 377 insertions(+), 200 deletions(-)

diff --git a/sc/inc/docoptio.hxx b/sc/inc/docoptio.hxx
index 0d3f047..2904332 100644
--- a/sc/inc/docoptio.hxx
+++ b/sc/inc/docoptio.hxx
@@ -40,7 +40,7 @@ class SC_DLLPUBLIC ScDocOptions
 {
     double fIterEps;				// Epsilon-Wert dazu
     USHORT nIterCount;				// Anzahl
-    USHORT nPrecStandardFormat;		// Nachkommastellen Standard
+    sal_uInt16 nPrecStandardFormat; // precision for standard format
     USHORT nDay;					// Nulldatum:
     USHORT nMonth;
     USHORT nYear;
@@ -93,8 +93,8 @@ public:
     inline int					operator==( const ScDocOptions& rOpt ) const;
     inline int					operator!=( const ScDocOptions& rOpt ) const;
 
-    USHORT	GetStdPrecision() const 	{ return nPrecStandardFormat; }
-    void	SetStdPrecision( USHORT n ) { nPrecStandardFormat = n; }
+    sal_uInt16  GetStdPrecision() const { return nPrecStandardFormat; }
+    void        SetStdPrecision( sal_uInt16 n ) { nPrecStandardFormat = n; }
 
     BOOL	IsCalcAsShown() const		{ return bCalcAsShown; }
     void	SetCalcAsShown( BOOL bVal )	{ bCalcAsShown = bVal; }
diff --git a/sc/source/ui/inc/optdlg.hrc b/sc/source/ui/inc/optdlg.hrc
index 52edcfd..ad3d34a 100644
--- a/sc/source/ui/inc/optdlg.hrc
+++ b/sc/source/ui/inc/optdlg.hrc
@@ -71,6 +71,7 @@
 #define BTN_MATCH			18
 #define BTN_LOOKUP			19
 #define BTN_REGEX           20
+#define BTN_GENERAL_PREC    21
 
 // TP_VIEW:
 #define BTN_VSCROLL			1
diff --git a/sc/source/ui/inc/output.hxx b/sc/source/ui/inc/output.hxx
index 70dd987..f6cd4b7 100644
--- a/sc/source/ui/inc/output.hxx
+++ b/sc/source/ui/inc/output.hxx
@@ -73,6 +73,15 @@ class ScOutputData
 {
 friend class ScDrawStringsVars;
 private:
+    struct OutputAreaParam
+    {
+        Rectangle   maAlignRect;
+        Rectangle   maClipRect;
+        long        mnColWidth;
+        bool        mbLeftClip;
+        bool        mbRightClip;
+    };
+
     OutputDevice* pDev;			// Device
     OutputDevice* pRefDevice;	// printer if used for preview
     OutputDevice* pFmtDevice;	// reference for text formatting
@@ -152,19 +161,19 @@ private:
     void			GetVisibleCell( SCCOL nCol, SCROW nRow, SCTAB nTab, ScBaseCell*& rpCell );
 
     BOOL			IsAvailable( SCCOL nX, SCROW nY );
+
     void			GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY,
-                                    SCCOL nCellX, SCROW nCellY, long nNeeded,
-                                    const ScPatternAttr& rPattern,
-                                    USHORT nHorJustify, BOOL bCellIsValue,
-                                    BOOL bBreak, BOOL bOverwrite,
-                                    Rectangle& rAlignRect, Rectangle& rClipRect,
-                                    BOOL& rLeftClip, BOOL& rRightClip );
+                                   SCCOL nCellX, SCROW nCellY, long nNeeded,
+                                   const ScPatternAttr& rPattern,
+                                   USHORT nHorJustify, bool bCellIsValue,
+                                   bool bBreak, bool bOverwrite,
+                                   OutputAreaParam& rParam );
 
     void            ShrinkEditEngine( EditEngine& rEngine, const Rectangle& rAlignRect,
                                     long nLeftM, long nTopM, long nRightM, long nBottomM,
                                     BOOL bWidth, USHORT nOrient, long nAttrRotate, BOOL bPixelToLogic,
                                     long& rEngineWidth, long& rEngineHeight, long& rNeededPixel,
-                                    BOOL& rLeftClip, BOOL& rRightClip );
+                                    bool& rLeftClip, bool& rRightClip );
 
     void			SetSyntaxColor( Font* pFont, ScBaseCell* pCell );
     void			SetEditSyntaxColor( EditEngine& rEngine, ScBaseCell* pCell );
diff --git a/sc/source/ui/inc/tpcalc.hxx b/sc/source/ui/inc/tpcalc.hxx
index 705ace7..71cd5db 100644
--- a/sc/source/ui/inc/tpcalc.hxx
+++ b/sc/source/ui/inc/tpcalc.hxx
@@ -76,6 +76,7 @@ private:
     CheckBox		aBtnMatch;
     CheckBox        aBtnRegex;
     CheckBox		aBtnLookUp;
+    CheckBox		aBtnGeneralPrec;
 
     FixedText		aFtPrec;
     NumericField	aEdPrec;
diff --git a/sc/source/ui/optdlg/tpcalc.cxx b/sc/source/ui/optdlg/tpcalc.cxx
index 208fd65..e618435 100644
--- a/sc/source/ui/optdlg/tpcalc.cxx
+++ b/sc/source/ui/optdlg/tpcalc.cxx
@@ -88,6 +88,7 @@ ScTpCalcOptions::ScTpCalcOptions( Window*			pParent,
         aBtnMatch	 	( this, ScResId( BTN_MATCH ) ),
         aBtnRegex       ( this, ScResId( BTN_REGEX ) ),
         aBtnLookUp   	( this, ScResId( BTN_LOOKUP ) ),
+        aBtnGeneralPrec ( this, ScResId( BTN_GENERAL_PREC ) ),
         aFtPrec 		( this, ScResId( FT_PREC ) ),
         aEdPrec 		( this, ScResId( ED_PREC ) ),
         pOldOptions 	( new ScDocOptions(
@@ -116,6 +117,7 @@ __EXPORT ScTpCalcOptions::~ScTpCalcOptions()
 void ScTpCalcOptions::Init()
 {
     aBtnIterate .SetClickHdl( LINK( this, ScTpCalcOptions, CheckClickHdl ) );
+    aBtnGeneralPrec.SetClickHdl( LINK(this, ScTpCalcOptions, CheckClickHdl) );
     aBtnDateStd .SetClickHdl( LINK( this, ScTpCalcOptions, RadioClickHdl ) );
     aBtnDateSc10.SetClickHdl( LINK( this, ScTpCalcOptions, RadioClickHdl ) );
     aBtnDate1904.SetClickHdl( LINK( this, ScTpCalcOptions, RadioClickHdl ) );
@@ -150,7 +152,6 @@ void __EXPORT ScTpCalcOptions::Reset( const SfxItemSet& /* rCoreAttrs */ )
     aBtnLookUp .Check( pLocalOptions->IsLookUpColRowNames() );
     aBtnIterate.Check( pLocalOptions->IsIter() );
     aEdSteps   .SetValue( pLocalOptions->GetIterCount() );
-    aEdPrec    .SetValue( pLocalOptions->GetStdPrecision() );
     aEdEps     .SetValue( pLocalOptions->GetIterEps(), 6 );
 
     pLocalOptions->GetDate( d, m, y );
@@ -168,6 +169,21 @@ void __EXPORT ScTpCalcOptions::Reset( const SfxItemSet& /* rCoreAttrs */ )
             break;
     }
 
+    sal_uInt16 nPrec = pLocalOptions->GetStdPrecision();
+    if (nPrec == SvNumberFormatter::UNLIMITED_PRECISION)
+    {
+        aFtPrec.Disable();
+        aEdPrec.Disable();
+        aBtnGeneralPrec.Check(false);
+    }
+    else
+    {
+        aBtnGeneralPrec.Check();
+        aFtPrec.Enable();
+        aEdPrec.Enable();
+        aEdPrec.SetValue(nPrec);
+    }
+
     CheckClickHdl( &aBtnIterate );
 }
 
@@ -178,13 +194,18 @@ BOOL __EXPORT ScTpCalcOptions::FillItemSet( SfxItemSet& rCoreAttrs )
 {
     // alle weiteren Optionen werden in den Handlern aktualisiert
     pLocalOptions->SetIterCount( (USHORT)aEdSteps.GetValue() );
-    pLocalOptions->SetStdPrecision( (USHORT)aEdPrec.GetValue() );
     pLocalOptions->SetIgnoreCase( !aBtnCase.IsChecked() );
     pLocalOptions->SetCalcAsShown( aBtnCalc.IsChecked() );
     pLocalOptions->SetMatchWholeCell( aBtnMatch.IsChecked() );
     pLocalOptions->SetFormulaRegexEnabled( aBtnRegex.IsChecked() );
     pLocalOptions->SetLookUpColRowNames( aBtnLookUp.IsChecked() );
 
+    if (aBtnGeneralPrec.IsChecked())
+        pLocalOptions->SetStdPrecision(
+            static_cast<sal_uInt16>(aEdPrec.GetValue()) );
+    else
+        pLocalOptions->SetStdPrecision( SvNumberFormatter::UNLIMITED_PRECISION );
+
     if ( *pLocalOptions != *pOldOptions )
     {
         rCoreAttrs.Put( ScTpCalcItem( nWhichCalc, *pLocalOptions ) );
@@ -245,19 +266,35 @@ IMPL_LINK( ScTpCalcOptions, RadioClickHdl, RadioButton*, pBtn )
 
 //-----------------------------------------------------------------------
 
-IMPL_LINK(  ScTpCalcOptions, CheckClickHdl, CheckBox*, pBtn )
+IMPL_LINK( ScTpCalcOptions, CheckClickHdl, CheckBox*, pBtn )
 {
-    if ( pBtn->IsChecked() )
+    if (pBtn == &aBtnGeneralPrec)
     {
-        pLocalOptions->SetIter( TRUE );
-        aFtSteps.Enable();	aEdSteps.Enable();
-        aFtEps	.Enable();	aEdEps	.Enable();
+        if (pBtn->IsChecked())
+        {
+            aEdPrec.Enable();
+            aFtPrec.Enable();
+        }
+        else
+        {
+            aEdPrec.Disable();
+            aFtPrec.Disable();
+        }
     }
-    else
+    else if (pBtn == &aBtnIterate)
     {
-        pLocalOptions->SetIter( FALSE );
-        aFtSteps.Disable(); aEdSteps.Disable();
-        aFtEps	.Disable(); aEdEps	.Disable();
+        if ( pBtn->IsChecked() )
+        {
+            pLocalOptions->SetIter( TRUE );
+            aFtSteps.Enable();	aEdSteps.Enable();
+            aFtEps	.Enable();	aEdEps	.Enable();
+        }
+        else
+        {
+            pLocalOptions->SetIter( FALSE );
+            aFtSteps.Disable(); aEdSteps.Disable();
+            aFtEps	.Disable(); aEdEps	.Disable();
+        }
     }
 
     return 0;
diff --git a/sc/source/ui/src/optdlg.src b/sc/source/ui/src/optdlg.src
index a8e5bff..108f383 100644
--- a/sc/source/ui/src/optdlg.src
+++ b/sc/source/ui/src/optdlg.src
@@ -119,22 +119,6 @@ TabPage RID_SCPAGE_CALC
         Pos = MAP_APPFONT ( 6 , 64 ) ;
         Size = MAP_APPFONT ( 248 , 8 ) ;
     };
-    FixedText FT_PREC
-    {
-        Pos = MAP_APPFONT ( 150 , 77 ) ;
-        Size = MAP_APPFONT ( 72 , 8 ) ;
-        Text [ en-US ] = "~Decimal places" ;
-        Right = TRUE ;
-    };
-    NumericField ED_PREC
-    {
-        Border = TRUE ;
-        Pos = MAP_APPFONT ( 226 , 75 ) ;
-        Size = MAP_APPFONT ( 25 , 12 ) ;
-        Maximum = 20 ;
-        Spin = TRUE ;
-        Repeat = TRUE ;
-    };
     CheckBox BTN_CASE
     {
         Pos = MAP_APPFONT ( 12 , 77 ) ;
@@ -165,6 +149,28 @@ TabPage RID_SCPAGE_CALC
         Size = MAP_APPFONT ( 239 , 10 ) ;
         Text [ en-US ] = "~Automatically find column and row labels " ;
     };
+    CheckBox BTN_GENERAL_PREC
+    {
+        Pos = MAP_APPFONT ( 12 , 147 ) ;
+        Size = MAP_APPFONT ( 136 , 10 ) ;
+        Text [ en-US ] = "Limit decimals for general number format" ;
+    };
+    FixedText FT_PREC
+    {
+        Pos = MAP_APPFONT ( 150 , 148 ) ;
+        Size = MAP_APPFONT ( 72 , 8 ) ;
+        Text [ en-US ] = "~Decimal places" ;
+        Right = TRUE ;
+    };
+    NumericField ED_PREC
+    {
+        Border = TRUE ;
+        Pos = MAP_APPFONT ( 226 , 146 ) ;
+        Size = MAP_APPFONT ( 25 , 12 ) ;
+        Maximum = 20 ;
+        Spin = TRUE ;
+        Repeat = TRUE ;
+    };
 };
 
 /**************************************************************************/
diff --git a/sc/source/ui/unoobj/defltuno.cxx b/sc/source/ui/unoobj/defltuno.cxx
index b31b3e6..93a538f 100644
--- a/sc/source/ui/unoobj/defltuno.cxx
+++ b/sc/source/ui/unoobj/defltuno.cxx
@@ -157,7 +157,7 @@ void SAL_CALL ScDocDefaultsObj::setPropertyValue(
                 sal_Int16 nValue = 0;
                 if (aValue >>= nValue)
                 {
-                    aDocOpt.SetStdPrecision(static_cast<sal_uInt8> (nValue));
+                    aDocOpt.SetStdPrecision(static_cast<sal_uInt16> (nValue));
                     pDoc->SetDocOptions(aDocOpt);
                 }
             }
diff --git a/sc/source/ui/view/output2.cxx b/sc/source/ui/view/output2.cxx
index 3003ddc..fe47518 100644
--- a/sc/source/ui/view/output2.cxx
+++ b/sc/source/ui/view/output2.cxx
@@ -53,6 +53,7 @@
 #include <svx/udlnitem.hxx>
 #include <svx/unolingu.hxx>
 #include <svtools/zforlist.hxx>
+#include <svtools/zformat.hxx>
 #include <vcl/svapp.hxx>
 #include <vcl/metric.hxx>
 #include <vcl/outdev.hxx>
@@ -108,6 +109,9 @@ class ScDrawStringsVars
     String				aString;				// Inhalte
     Size				aTextSize;
     long				nOriginalWidth;
+    long                nMaxDigitWidth;
+    long                nSignWidth;
+    long                nDotWidth;
 
     ScBaseCell*			pLastCell;
     ULONG				nValueFormat;
@@ -132,7 +136,7 @@ public:
     void		SetPatternSimple( const ScPatternAttr* pNew, const SfxItemSet* pSet );
 
     BOOL		SetText( ScBaseCell* pCell );	// TRUE -> pOldPattern vergessen
-    void		SetHashText();
+    void        SetTextToWidthOrHash( ScBaseCell* pCell, long nWidth );
     void		SetAutoText( const String& rAutoText );
 
     const ScPatternAttr*	GetPattern() const		{ return pPattern; }
@@ -161,6 +165,13 @@ public:
                                         pCondSet->GetItemState( ATTR_FONT_HEIGHT, TRUE ); }
 
     BOOL    HasEditCharacters() const;
+
+private:
+    void        SetHashText();
+    long        GetMaxDigitWidth();
+    long        GetSignWidth();
+    long        GetDotWidth();
+    void        TextChanged();
 };
 
 //==================================================================
@@ -176,6 +187,9 @@ ScDrawStringsVars::ScDrawStringsVars(ScOutputData* pData, BOOL bPTL) :
     nIndent		( 0 ),
     bRotated	( FALSE ),
     nOriginalWidth( 0 ),
+    nMaxDigitWidth( 0 ),
+    nSignWidth( 0 ),
+    nDotWidth( 0 ),
     pLastCell	( NULL ),
     nValueFormat( 0 ),
     bLineBreak	( FALSE ),
@@ -242,6 +256,10 @@ void ScDrawStringsVars::SetShrinkScale( long nScale, BYTE nScript )
 void ScDrawStringsVars::SetPattern( const ScPatternAttr* pNew, const SfxItemSet* pSet,
                                     ScBaseCell* pCell, BYTE nScript )
 {
+    nMaxDigitWidth = 0;
+    nSignWidth     = 0;
+    nDotWidth      = 0;
+
     pPattern = pNew;
     pCondSet = pSet;
 
@@ -393,6 +411,9 @@ void ScDrawStringsVars::SetPattern( const ScPatternAttr* pNew, const SfxItemSet*
 
 void ScDrawStringsVars::SetPatternSimple( const ScPatternAttr* pNew, const SfxItemSet* pSet )
 {
+    nMaxDigitWidth = 0;
+    nSignWidth     = 0;
+    nDotWidth      = 0;
     //	wird gerufen, wenn sich die Font-Variablen nicht aendern (!StringDiffer)
 
     pPattern = pNew;
@@ -467,28 +488,7 @@ BOOL ScDrawStringsVars::SetText( ScBaseCell* pCell )
                 pLastCell = NULL;		// naechstes Mal wieder hierherkommen
             }
 
-            OutputDevice* pRefDevice = pOutput->pRefDevice;
-            OutputDevice* pFmtDevice = pOutput->pFmtDevice;
-            aTextSize.Width() = pFmtDevice->GetTextWidth( aString );
-            aTextSize.Height() = pFmtDevice->GetTextHeight();
-
-            if ( !pRefDevice->GetConnectMetaFile() || pRefDevice->GetOutDevType() == OUTDEV_PRINTER )
-            {
-                double fMul = pOutput->GetStretch();
-                aTextSize.Width() = (long)(aTextSize.Width() / fMul + 0.5);
-            }
-
-            aTextSize.Height() = aMetric.GetAscent() + aMetric.GetDescent();
-            if ( GetOrient() != SVX_ORIENTATION_STANDARD )
-            {
-                long nTemp = aTextSize.Height();
-                aTextSize.Height() = aTextSize.Width();
-                aTextSize.Width() = nTemp;
-            }
-
-            nOriginalWidth = aTextSize.Width();
-            if ( bPixelToLogic )
-                aTextSize = pRefDevice->LogicToPixel( aTextSize );
+            TextChanged();
         }
         //	sonst String/Groesse behalten
     }
@@ -508,6 +508,77 @@ void ScDrawStringsVars::SetHashText()
     SetAutoText( String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("###")) );
 }
 
+void ScDrawStringsVars::SetTextToWidthOrHash( ScBaseCell* pCell, long nWidth )
+{
+    if (!pCell)
+        return;
+
+    CellType eType = pCell->GetCellType();
+    if (eType != CELLTYPE_VALUE && eType != CELLTYPE_FORMULA)
+        // must be a value or formula cell.
+        return;
+
+    if (eType == CELLTYPE_FORMULA && !static_cast<ScFormulaCell*>(pCell)->IsValue())
+        // If it's formula, the result must be a value.
+        return;
+
+    ULONG nFormat = GetValueFormat();
+    if ((nFormat % SV_COUNTRY_LANGUAGE_OFFSET) != 0)
+    {
+        // Not 'General' number format.  Set hash text and bail out.
+        SetHashText();
+        return;
+    }
+
+    double fVal = (eType == CELLTYPE_VALUE) ?
+        static_cast<ScValueCell*>(pCell)->GetValue() : static_cast<ScFormulaCell*>(pCell)->GetValue();
+
+    const SvNumberformat* pNumFormat = pOutput->pDoc->GetFormatTable()->GetEntry(nFormat);
+    if (!pNumFormat)
+        return;
+
+    long nMaxDigit = GetMaxDigitWidth();
+    sal_uInt16 nNumDigits = static_cast<sal_uInt16>(nWidth / nMaxDigit);
+
+    if (!pNumFormat->GetOutputString(fVal, nNumDigits, aString))
+        // Failed to get output string.  Bail out.
+        return;
+
+    sal_uInt8 nSignCount = 0, nDecimalCount = 0;
+    xub_StrLen nLen = aString.Len();
+    sal_Unicode cDecSep = ScGlobal::GetpLocaleData()->getLocaleItem().decimalSeparator.getStr()[0];
+    for (xub_StrLen i = 0; i < nLen; ++i)
+    {
+        sal_Unicode c = aString.GetChar(i);
+        if (c == sal_Unicode('-'))
+            ++nSignCount;
+        else if (c == cDecSep)
+            ++nDecimalCount;
+    }
+    if (nDecimalCount)
+        nWidth += (nMaxDigit - GetDotWidth()) * nDecimalCount;
+    if (nSignCount)
+        nWidth += (nMaxDigit - GetSignWidth()) * nSignCount;
+
+    if (nDecimalCount || nSignCount)
+    {
+        // Re-calculate.
+        nNumDigits = static_cast<sal_uInt16>(nWidth / nMaxDigit);
+        if (!pNumFormat->GetOutputString(fVal, nNumDigits, aString))
+            // Failed to get output string.  Bail out.
+            return;
+    }
+
+    if (pOutput->pFmtDevice->GetTextWidth(aString) > nWidth)
+    {
+        // Even after the decimal adjustment the text doesn't fit.  Give up.
+        SetHashText();
+        return;
+    }
+
+    TextChanged();
+}
+
 void ScDrawStringsVars::SetAutoText( const String& rAutoText )
 {
     aString = rAutoText;
@@ -538,6 +609,66 @@ void ScDrawStringsVars::SetAutoText( const String& rAutoText )
     pLastCell = NULL;		// derselbe Text kann in der naechsten Zelle wieder passen
 }
 
+long ScDrawStringsVars::GetMaxDigitWidth()
+{
+    if (nMaxDigitWidth > 0)
+        return nMaxDigitWidth;
+
+    sal_Char cZero = '0';
+    for (int i = 0; i < 10; ++i)
+    {
+        sal_Char cDigit = cZero + i;
+        long n = pOutput->pFmtDevice->GetTextWidth(String(cDigit));
+        nMaxDigitWidth = ::std::max(nMaxDigitWidth, n);
+    }
+    return nMaxDigitWidth;
+}
+
+long ScDrawStringsVars::GetSignWidth()
+{
+    if (nSignWidth > 0)
+        return nSignWidth;
+
+    nSignWidth = pOutput->pFmtDevice->GetTextWidth(String('-'));
+    return nSignWidth;
+}
+
+long ScDrawStringsVars::GetDotWidth()
+{
+    if (nDotWidth > 0)
+        return nDotWidth;
+
+    const ::rtl::OUString& sep = ScGlobal::GetpLocaleData()->getLocaleItem().decimalSeparator;
+    nDotWidth = pOutput->pFmtDevice->GetTextWidth(sep);
+    return nDotWidth;
+}
+
+void ScDrawStringsVars::TextChanged()
+{
+    OutputDevice* pRefDevice = pOutput->pRefDevice;
+    OutputDevice* pFmtDevice = pOutput->pFmtDevice;
+    aTextSize.Width() = pFmtDevice->GetTextWidth( aString );
+    aTextSize.Height() = pFmtDevice->GetTextHeight();
+
+    if ( !pRefDevice->GetConnectMetaFile() || pRefDevice->GetOutDevType() == OUTDEV_PRINTER )
+    {
+        double fMul = pOutput->GetStretch();
+        aTextSize.Width() = (long)(aTextSize.Width() / fMul + 0.5);
+    }
+
+    aTextSize.Height() = aMetric.GetAscent() + aMetric.GetDescent();
+    if ( GetOrient() != SVX_ORIENTATION_STANDARD )
+    {
+        long nTemp = aTextSize.Height();
+        aTextSize.Height() = aTextSize.Width();
+        aTextSize.Width() = nTemp;
+    }
+
+    nOriginalWidth = aTextSize.Width();
+    if ( bPixelToLogic )
+        aTextSize = pRefDevice->LogicToPixel( aTextSize );
+}
+
 BOOL ScDrawStringsVars::HasEditCharacters() const
 {
     static const sal_Unicode pChars[] =
@@ -919,29 +1050,25 @@ BOOL ScOutputData::IsAvailable( SCCOL nX, SCROW nY )
 // bCellIsValue:	if set, don't extend into empty cells
 // bBreak:			if set, don't extend, and don't set clip marks (but rLeftClip/rRightClip is set)
 // bOverwrite:		if set, also extend into non-empty cells (for rotated text)
-// rAlignRect:		output: single or merged cell, used for alignment (visual rectangle)
-// rClipRect:		output: total output area, for clipping (visual)
-// rLeftClip:		output: need to clip at rClipRect left (visual) edge
-// rRightClip:		output: same for right
+// rParam           output: various area parameters.
 
 void ScOutputData::GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY,
-                                    SCCOL nCellX, SCROW nCellY, long nNeeded,
-                                    const ScPatternAttr& rPattern,
-                                    USHORT nHorJustify, BOOL bCellIsValue,
-                                    BOOL bBreak, BOOL bOverwrite,
-                                    Rectangle& rAlignRect, Rectangle& rClipRect,
-                                    BOOL& rLeftClip, BOOL& rRightClip )
+                                  SCCOL nCellX, SCROW nCellY, long nNeeded,
+                                  const ScPatternAttr& rPattern,
+                                  USHORT nHorJustify, bool bCellIsValue,
+                                  bool bBreak, bool bOverwrite,
+                                  OutputAreaParam& rParam )
 {
-    //	rThisRowInfo may be for a different row than nCellY, is still used for clip marks
+    //  rThisRowInfo may be for a different row than nCellY, is still used for clip marks
     RowInfo& rThisRowInfo = pRowInfo[nArrY];
 
     long nLayoutSign = bLayoutRTL ? -1 : 1;
 
-    long nCellPosX = nPosX;			// find nCellX position, starting at nX/nPosX
+    long nCellPosX = nPosX;         // find nCellX position, starting at nX/nPosX
     SCCOL nCompCol = nX;
     while ( nCellX > nCompCol )
     {
-        //!	extra member function for width?
+        //! extra member function for width?
         long nColWidth = ( nCompCol <= nX2 ) ?
                 pRowInfo[0].pCellInfo[nCompCol+1].nWidth :
                 (long) ( pDoc->GetColWidth( nCompCol, nTab ) * nPPTX );
@@ -957,7 +1084,7 @@ void ScOutputData::GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY
         nCellPosX -= nColWidth * nLayoutSign;
     }
 
-    long nCellPosY = nPosY;			// find nCellY position, starting at nArrY/nPosY
+    long nCellPosY = nPosY;         // find nCellY position, starting at nArrY/nPosY
     SCSIZE nCompArr = nArrY;
     SCROW nCompRow = pRowInfo[nCompArr].nRowNo;
     while ( nCellY > nCompRow )
@@ -1002,28 +1129,30 @@ void ScOutputData::GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY
     {
         // take first row's height from row info
         nMergeSizeY += rThisRowInfo.nHeight;
-        nDirect = 1;		// skip in loop
+        nDirect = 1;        // skip in loop
     }
     // following rows always from document
     nMergeSizeY += (long) pDoc->GetScaledRowHeight( nCellY+nDirect, nCellY+nMergeRows-1, nTab, nPPTY);
 
-    --nMergeSizeX;		// leave out the grid horizontally, also for alignment (align between grid lines)
+    --nMergeSizeX;      // leave out the grid horizontally, also for alignment (align between grid lines)
+
+    rParam.mnColWidth = nMergeSizeX; // store the actual column width.
 
     //
     // construct the rectangles using logical left/right values (justify is called at the end)
     //
 
-    //	rAlignRect is the single cell or merged area, used for alignment.
+    //  rAlignRect is the single cell or merged area, used for alignment.
 
-    rAlignRect.Left() = nCellPosX;
-    rAlignRect.Right() = nCellPosX + ( nMergeSizeX - 1 ) * nLayoutSign;
-    rAlignRect.Top() = nCellPosY;
-    rAlignRect.Bottom() = nCellPosY + nMergeSizeY - 1;
+    rParam.maAlignRect.Left() = nCellPosX;
+    rParam.maAlignRect.Right() = nCellPosX + ( nMergeSizeX - 1 ) * nLayoutSign;
+    rParam.maAlignRect.Top() = nCellPosY;
+    rParam.maAlignRect.Bottom() = nCellPosY + nMergeSizeY - 1;
 
-    //	rClipRect is all cells that are used for output.
-    //	For merged cells this is the same as rAlignRect, otherwise neighboring cells can also be used.
+    //  rClipRect is all cells that are used for output.
+    //  For merged cells this is the same as rAlignRect, otherwise neighboring cells can also be used.
 
-    rClipRect = rAlignRect;
+    rParam.maClipRect = rParam.maAlignRect;
     if ( nNeeded > nMergeSizeX )
     {
         SvxCellHorJustify eHorJust = (SvxCellHorJustify)nHorJustify;
@@ -1057,14 +1186,14 @@ void ScOutputData::GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY
         SCCOL nLeftX = nCellX;
         if ( !bMerged && !bCellIsValue && !bBreak )
         {
-            //	look for empty cells into which the text can be extended
+            //  look for empty cells into which the text can be extended
 
             while ( nRightMissing > 0 && nRightX < MAXCOL && ( bOverwrite || IsAvailable( nRightX+1, nCellY ) ) )
             {
                 ++nRightX;
                 long nAdd = (long) ( pDoc->GetColWidth( nRightX, nTab ) * nPPTX );
                 nRightMissing -= nAdd;
-                rClipRect.Right() += nAdd * nLayoutSign;
+                rParam.maClipRect.Right() += nAdd * nLayoutSign;
 
                 if ( rThisRowInfo.nRowNo == nCellY && nRightX >= nX1 && nRightX <= nX2 )
                     rThisRowInfo.pCellInfo[nRightX].bHideGrid = TRUE;
@@ -1078,33 +1207,33 @@ void ScOutputData::GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY
                 --nLeftX;
                 long nAdd = (long) ( pDoc->GetColWidth( nLeftX, nTab ) * nPPTX );
                 nLeftMissing -= nAdd;
-                rClipRect.Left() -= nAdd * nLayoutSign;
+                rParam.maClipRect.Left() -= nAdd * nLayoutSign;
             }
         }
 
-        //	Set flag and reserve space for clipping mark triangle,
-        //	even if rThisRowInfo isn't for nCellY (merged cells).
+        //  Set flag and reserve space for clipping mark triangle,
+        //  even if rThisRowInfo isn't for nCellY (merged cells).
         if ( nRightMissing > 0 && bMarkClipped && nRightX >= nX1 && nRightX <= nX2 && !bBreak && !bCellIsValue )
         {
             rThisRowInfo.pCellInfo[nRightX+1].nClipMark |= SC_CLIPMARK_RIGHT;
             bAnyClipped = TRUE;
             long nMarkPixel = (long)( SC_CLIPMARK_SIZE * nPPTX );
-            rClipRect.Right() -= nMarkPixel * nLayoutSign;
+            rParam.maClipRect.Right() -= nMarkPixel * nLayoutSign;
         }
         if ( nLeftMissing > 0 && bMarkClipped && nLeftX >= nX1 && nLeftX <= nX2 && !bBreak && !bCellIsValue )
         {
             rThisRowInfo.pCellInfo[nLeftX+1].nClipMark |= SC_CLIPMARK_LEFT;
             bAnyClipped = TRUE;
             long nMarkPixel = (long)( SC_CLIPMARK_SIZE * nPPTX );
-            rClipRect.Left() += nMarkPixel * nLayoutSign;
+            rParam.maClipRect.Left() += nMarkPixel * nLayoutSign;
         }
 
-        rLeftClip = ( nLeftMissing > 0 );
-        rRightClip = ( nRightMissing > 0 );
+        rParam.mbLeftClip = ( nLeftMissing > 0 );
+        rParam.mbRightClip = ( nRightMissing > 0 );
     }
     else
     {
-        rLeftClip = rRightClip = FALSE;
+        rParam.mbLeftClip = rParam.mbRightClip = FALSE;
 
         // leave space for AutoFilter on screen
         // (for automatic line break: only if not formatting for printer, as in ScColumn::GetNeededSize)
@@ -1120,30 +1249,30 @@ void ScOutputData::GetOutputArea( SCCOL nX, SCSIZE nArrY, long nPosX, long nPosY
                 // content fits even in the remaining area without the filter button
                 // -> align within that remaining area
 
-                rAlignRect.Right() -= nFilter * nLayoutSign;
-                rClipRect.Right() -= nFilter * nLayoutSign;
+                rParam.maAlignRect.Right() -= nFilter * nLayoutSign;
+                rParam.maClipRect.Right() -= nFilter * nLayoutSign;
 
                 // if a number doesn't fit, don't hide part of the number behind the button
                 // -> set clip flags, so "###" replacement is used (but also within the smaller area)
 
                 if ( !bFit )
-                    rLeftClip = rRightClip = TRUE;
+                    rParam.mbLeftClip = rParam.mbRightClip = TRUE;
             }
         }
     }
 
-    //	justify both rectangles for alignment calculation, use with DrawText etc.
+    //  justify both rectangles for alignment calculation, use with DrawText etc.
 
-    rAlignRect.Justify();
-    rClipRect.Justify();
+    rParam.maAlignRect.Justify();
+    rParam.maClipRect.Justify();
 
 #if 0
     //! Test !!!
     pDev->Push();
     pDev->SetLineColor();
     pDev->SetFillColor( COL_LIGHTGREEN );
-    pDev->DrawRect( pDev->PixelToLogic(rClipRect) );
-    pDev->DrawRect( rClipRect );	// print preview
+    pDev->DrawRect( pDev->PixelToLogic(rParam.maClipRect) );
+    pDev->DrawRect( rParam.maClipRect );    // print preview
     pDev->Pop();
     //! Test !!!
 #endif
@@ -1184,12 +1313,9 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
         --nLoopStartX;			// start before nX1 for rest of long text to the left
 
     // variables for GetOutputArea
+    OutputAreaParam aAreaParam;
     BOOL bCellIsValue = FALSE;
-    BOOL bLeftClip = FALSE;
-    BOOL bRightClip = FALSE;
     long nNeededWidth = 0;
-    Rectangle aAlignRect;
-    Rectangle aClipRect;
     SvxCellHorJustify eOutHorJust = SVX_HOR_JUSTIFY_STANDARD;
     const ScPatternAttr* pPattern = NULL;
     const SfxItemSet* pCondSet = NULL;
@@ -1360,6 +1486,7 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                     bNeedEdit = aVars.HasEditCharacters() ||
                                     (bFormulaCell && ((ScFormulaCell*)pCell)->IsMultilineResult());                
                 }
+                long nTotalMargin = 0;
                 if (bDoCell && !bNeedEdit)
                 {
                     CellType eCellType = pCell->GetCellType();
@@ -1381,14 +1508,17 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                     BOOL bRepeat = aVars.IsRepeat() && !bBreak;
                     BOOL bShrink = aVars.IsShrink() && !bBreak && !bRepeat;
 
-                    long nTotalMargin = (long) ( aVars.GetLeftTotal() * nPPTX ) +
-                                        (long) ( aVars.GetMargin()->GetRightMargin() * nPPTX );
+                    nTotalMargin =
+                        static_cast<long>(aVars.GetLeftTotal() * nPPTX) +
+                        static_cast<long>(aVars.GetMargin()->GetRightMargin() * nPPTX);
+
                     nNeededWidth = aVars.GetTextSize().Width() + nTotalMargin;
+
                     // GetOutputArea gives justfied rectangles
                     GetOutputArea( nX, nArrY, nPosX, nPosY, nCellX, nCellY, nNeededWidth,
-                                    *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
-                                    bCellIsValue || bRepeat || bShrink, bBreak, FALSE,
-                                    aAlignRect, aClipRect, bLeftClip, bRightClip );
+                                   *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
+                                   bCellIsValue || bRepeat || bShrink, bBreak, FALSE,
+                                   aAreaParam );
 
                     if ( bShrink )
                     {
@@ -1398,9 +1528,9 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                             // DrawEdit is used to vertically scale 90 deg rotated text.
                             bNeedEdit = TRUE;
                         }
-                        else if ( bLeftClip || bRightClip )     // horizontal
+                        else if ( aAreaParam.mbLeftClip || aAreaParam.mbRightClip )     // horizontal
                         {
-                            long nAvailable = aAlignRect.GetWidth() - nTotalMargin;
+                            long nAvailable = aAreaParam.maAlignRect.GetWidth() - nTotalMargin;
                             long nScaleSize = aVars.GetTextSize().Width();         // without margin
 
                             if ( nScaleSize > 0 )       // 0 if the text is empty (formulas, number formats)
@@ -1424,16 +1554,16 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                                 // If even at half the size the font still isn't rendered smaller,
                                 // fall back to normal clipping (showing ### for numbers).
                                 if ( nNewSize <= nAvailable )
-                                    bLeftClip = bRightClip = FALSE;
+                                    aAreaParam.mbLeftClip = aAreaParam.mbRightClip = FALSE;
 
                                 pOldPattern = NULL;
                             }
                         }
                     }
 
-                    if ( bRepeat && !bLeftClip && !bRightClip )
+                    if ( bRepeat && !aAreaParam.mbLeftClip && !aAreaParam.mbRightClip )
                     {
-                        long nAvailable = aAlignRect.GetWidth() - nTotalMargin;
+                        long nAvailable = aAreaParam.maAlignRect.GetWidth() - nTotalMargin;
                         long nRepeatSize = aVars.GetTextSize().Width();         // without margin
                         // When formatting for the printer, the text sizes don't always add up.
                         // Round down (too few repetitions) rather than exceeding the cell size then:
@@ -1457,13 +1587,13 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                     if ( bBreak )
                     {
                         if ( aVars.GetOrient() == SVX_ORIENTATION_STANDARD )
-                            bNeedEdit = ( bLeftClip || bRightClip );
+                            bNeedEdit = ( aAreaParam.mbLeftClip || aAreaParam.mbRightClip );
                         else
                         {
                             long nHeight = aVars.GetTextSize().Height() +
                                             (long)(aVars.GetMargin()->GetTopMargin()*nPPTY) +
                                             (long)(aVars.GetMargin()->GetBottomMargin()*nPPTY);
-                            bNeedEdit = ( nHeight > aClipRect.GetHeight() );
+                            bNeedEdit = ( nHeight > aAreaParam.maClipRect.GetHeight() );
                         }
                     }
                 }
@@ -1479,48 +1609,49 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
                 }
                 if ( bDoCell )
                 {
-                    if ( bCellIsValue && ( bLeftClip || bRightClip ) )
+                    if ( bCellIsValue && ( aAreaParam.mbLeftClip || aAreaParam.mbRightClip ) )
                     {
-                        aVars.SetHashText();
+                        // Adjust the decimals to fit the available column width.
+                        aVars.SetTextToWidthOrHash(pCell, aAreaParam.mnColWidth - nTotalMargin);
                         nNeededWidth = aVars.GetTextSize().Width() +
                                     (long) ( aVars.GetLeftTotal() * nPPTX ) +
                                     (long) ( aVars.GetMargin()->GetRightMargin() * nPPTX );
-                        if ( nNeededWidth <= aClipRect.GetWidth() )
-                            bLeftClip = bRightClip = FALSE;
+                        if ( nNeededWidth <= aAreaParam.maClipRect.GetWidth() )
+                            aAreaParam.mbLeftClip = aAreaParam.mbRightClip = FALSE;
 
                         //	If the "###" replacement doesn't fit into the cells, no clip marks
                         //	are shown, as the "###" already denotes too little space.
                         //	The rectangles from the first GetOutputArea call remain valid.
                     }
 
-                    long nJustPosX = aAlignRect.Left();		// "justified" - effect of alignment will be added
-                    long nJustPosY = aAlignRect.Top();
-                    long nAvailWidth = aAlignRect.GetWidth();
-                    long nOutHeight = aAlignRect.GetHeight();
+                    long nJustPosX = aAreaParam.maAlignRect.Left();		// "justified" - effect of alignment will be added
+                    long nJustPosY = aAreaParam.maAlignRect.Top();
+                    long nAvailWidth = aAreaParam.maAlignRect.GetWidth();
+                    long nOutHeight = aAreaParam.maAlignRect.GetHeight();
 
-                    BOOL bOutside = ( aClipRect.Right() < nScrX || aClipRect.Left() >= nScrX + nScrW );
-                    if ( aClipRect.Left() < nScrX )
+                    BOOL bOutside = ( aAreaParam.maClipRect.Right() < nScrX || aAreaParam.maClipRect.Left() >= nScrX + nScrW );
+                    if ( aAreaParam.maClipRect.Left() < nScrX )
                     {
-                        aClipRect.Left() = nScrX;
-                        bLeftClip = TRUE;
+                        aAreaParam.maClipRect.Left() = nScrX;
+                        aAreaParam.mbLeftClip = TRUE;
                     }
-                    if ( aClipRect.Right() > nScrX + nScrW )
+                    if ( aAreaParam.maClipRect.Right() > nScrX + nScrW )
                     {
-                        aClipRect.Right() = nScrX + nScrW;			//! minus one?
-                        bRightClip = TRUE;
+                        aAreaParam.maClipRect.Right() = nScrX + nScrW;			//! minus one?
+                        aAreaParam.mbRightClip = TRUE;
                     }
 
-                    BOOL bHClip = bLeftClip || bRightClip;
+                    BOOL bHClip = aAreaParam.mbLeftClip || aAreaParam.mbRightClip;
                     BOOL bVClip = FALSE;
 
-                    if ( aClipRect.Top() < nScrY )
+                    if ( aAreaParam.maClipRect.Top() < nScrY )
                     {
-                        aClipRect.Top() = nScrY;
+                        aAreaParam.maClipRect.Top() = nScrY;
                         bVClip = TRUE;
                     }
-                    if ( aClipRect.Bottom() > nScrY + nScrH )
+                    if ( aAreaParam.maClipRect.Bottom() > nScrY + nScrH )
                     {
-                        aClipRect.Bottom() = nScrY + nScrH;         //! minus one?
+                        aAreaParam.maClipRect.Bottom() = nScrY + nScrH;         //! minus one?
                         bVClip = TRUE;
                     }
 
@@ -1603,27 +1734,27 @@ void ScOutputData::DrawStrings( BOOL bPixelToLogic )
 
                             if (!bHClip)
                             {
-                                aClipRect.Left() = nScrX;
-                                aClipRect.Right() = nScrX+nScrW;
+                                aAreaParam.maClipRect.Left() = nScrX;
+                                aAreaParam.maClipRect.Right() = nScrX+nScrW;
                             }
                             if (!bVClip)
                             {
-                                aClipRect.Top() = nScrY;
-                                aClipRect.Bottom() = nScrY+nScrH;
+                                aAreaParam.maClipRect.Top() = nScrY;
+                                aAreaParam.maClipRect.Bottom() = nScrY+nScrH;
                             }
 
                             //	aClipRect is not used after SetClipRegion/IntersectClipRegion,
                             //	so it can be modified here
                             if (bPixelToLogic)
-                                aClipRect = pRefDevice->PixelToLogic( aClipRect );
+                                aAreaParam.maClipRect = pRefDevice->PixelToLogic( aAreaParam.maClipRect );
 
                             if (bMetaFile)
                             {
                                 pDev->Push();
-                                pDev->IntersectClipRegion( aClipRect );
+                                pDev->IntersectClipRegion( aAreaParam.maClipRect );
                             }
                             else
-                                pDev->SetClipRegion( Region( aClipRect ) );
+                                pDev->SetClipRegion( Region( aAreaParam.maClipRect ) );
                         }
 
                         Point aURLStart( nJustPosX, nJustPosY );    // copy before modifying for orientation
@@ -1827,7 +1958,7 @@ long lcl_GetEditSize( EditEngine& rEngine, BOOL bWidth, BOOL bSwap, long nAttrRo
 void ScOutputData::ShrinkEditEngine( EditEngine& rEngine, const Rectangle& rAlignRect,
             long nLeftM, long nTopM, long nRightM, long nBottomM,
             BOOL bWidth, USHORT nOrient, long nAttrRotate, BOOL bPixelToLogic,
-            long& rEngineWidth, long& rEngineHeight, long& rNeededPixel, BOOL& rLeftClip, BOOL& rRightClip )
+            long& rEngineWidth, long& rEngineHeight, long& rNeededPixel, bool& rLeftClip, bool& rRightClip )
 {
     if ( !bWidth )
     {
@@ -2149,10 +2280,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 nPosY = nScrY;
                             }
 
-                            Rectangle aAlignRect;
-                            Rectangle aClipRect;
-                            BOOL bLeftClip = FALSE;
-                            BOOL bRightClip = FALSE;
+                            OutputAreaParam aAreaParam;
 
                             //
                             //	Initial page size - large for normal text, cell size for automatic line breaks
@@ -2167,23 +2295,22 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
 
                                 //!	handle nArrY == 0
                                 GetOutputArea( nXForPos, nArrYForPos, nPosX, nPosY, nCellX, nCellY, 0,
-                                                *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
-                                                bCellIsValue, TRUE, FALSE,
-                                                aAlignRect, aClipRect, bLeftClip, bRightClip );
+                                               *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
+                                               bCellIsValue, true, false, aAreaParam );
 
                                 //! special ScEditUtil handling if formatting for printer
 
                                 if ( eOrient == SVX_ORIENTATION_TOPBOTTOM || eOrient == SVX_ORIENTATION_BOTTOMTOP )
-                                    aPaperSize.Width() = aAlignRect.GetHeight() - nTopM - nBottomM;
+                                    aPaperSize.Width() = aAreaParam.maAlignRect.GetHeight() - nTopM - nBottomM;
                                 else
-                                    aPaperSize.Width() = aAlignRect.GetWidth() - nLeftM - nRightM;
+                                    aPaperSize.Width() = aAreaParam.maAlignRect.GetWidth() - nLeftM - nRightM;
 
                                 if (bAsianVertical && bBreak)
                                 {
                                     //	add some extra height (default margin value) for safety
                                     //	as long as GetEditArea isn't used below
                                     long nExtraHeight = (long)( 20 * nPPTY );
-                                    aPaperSize.Height() = aAlignRect.GetHeight() - nTopM - nBottomM + nExtraHeight;
+                                    aPaperSize.Height() = aAreaParam.maAlignRect.GetHeight() - nTopM - nBottomM + nExtraHeight;
                                 }
                             }
                             if (bPixelToLogic)
@@ -2372,26 +2499,26 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                             {
                                 // for break, the first GetOutputArea call is sufficient
                                 GetOutputArea( nXForPos, nArrYForPos, nPosX, nPosY, nCellX, nCellY, nNeededPixel,
-                                                *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
-                                                bCellIsValue || bRepeat || bShrink, FALSE, FALSE,
-                                                aAlignRect, aClipRect, bLeftClip, bRightClip );
+                                               *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
+                                               bCellIsValue || bRepeat || bShrink, false, false, aAreaParam );
 
                                 if ( bShrink )
                                 {
                                     BOOL bWidth = ( eOrient == SVX_ORIENTATION_STANDARD && !bAsianVertical );
-                                    ShrinkEditEngine( *pEngine, aAlignRect,
+                                    ShrinkEditEngine( *pEngine, aAreaParam.maAlignRect,
                                         nLeftM, nTopM, nRightM, nBottomM, bWidth,
                                         sal::static_int_cast<USHORT>(eOrient), 0, bPixelToLogic,
-                                        nEngineWidth, nEngineHeight, nNeededPixel, bLeftClip, bRightClip );
+                                        nEngineWidth, nEngineHeight, nNeededPixel,
+                                        aAreaParam.mbLeftClip, aAreaParam.mbRightClip );
                                 }
 
-                                if ( bRepeat && !bLeftClip && !bRightClip && pEngine->GetParagraphCount() == 1 )
+                                if ( bRepeat && !aAreaParam.mbLeftClip && !aAreaParam.mbRightClip && pEngine->GetParagraphCount() == 1 )
                                 {
                                     // First check if twice the space for the formatted text is available
                                     // (otherwise just keep it unchanged).
 
                                     long nFormatted = nNeededPixel - nLeftM - nRightM;      // without margin
-                                    long nAvailable = aAlignRect.GetWidth() - nLeftM - nRightM;
+                                    long nAvailable = aAreaParam.maAlignRect.GetWidth() - nLeftM - nRightM;
                                     if ( nAvailable >= 2 * nFormatted )
                                     {
                                         // "repeat" is handled with unformatted text (for performance reasons)
@@ -2425,7 +2552,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     }
                                 }
 
-                                if ( bCellIsValue && ( bLeftClip || bRightClip ) )
+                                if ( bCellIsValue && ( aAreaParam.mbLeftClip || aAreaParam.mbRightClip ) )
                                 {
                                     pEngine->SetText( String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("###")) );
                                     nEngineWidth = (long) pEngine->CalcTextWidth();
@@ -2448,11 +2575,11 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                 }
                             }
 
-                            long nStartX = aAlignRect.Left();
-                            long nStartY = aAlignRect.Top();
-                            long nCellWidth = aAlignRect.GetWidth();
+                            long nStartX = aAreaParam.maAlignRect.Left();
+                            long nStartY = aAreaParam.maAlignRect.Top();
+                            long nCellWidth = aAreaParam.maAlignRect.GetWidth();
                             long nOutWidth = nCellWidth - 1 - nLeftM - nRightM;
-                            long nOutHeight = aAlignRect.GetHeight() - nTopM - nBottomM;
+                            long nOutHeight = aAreaParam.maAlignRect.GetHeight() - nTopM - nBottomM;
 
                             if ( bBreak || eOrient != SVX_ORIENTATION_STANDARD || bAsianVertical )
                             {
@@ -2472,21 +2599,21 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     nStartX += nLeftM;
                             }
 
-                            BOOL bOutside = ( aClipRect.Right() < nScrX || aClipRect.Left() >= nScrX + nScrW );
-                            if ( aClipRect.Left() < nScrX )
+                            BOOL bOutside = ( aAreaParam.maClipRect.Right() < nScrX || aAreaParam.maClipRect.Left() >= nScrX + nScrW );
+                            if ( aAreaParam.maClipRect.Left() < nScrX )
                             {
-                                aClipRect.Left() = nScrX;
-                                bLeftClip = TRUE;
+                                aAreaParam.maClipRect.Left() = nScrX;
+                                aAreaParam.mbLeftClip = true;
                             }
-                            if ( aClipRect.Right() > nScrX + nScrW )
+                            if ( aAreaParam.maClipRect.Right() > nScrX + nScrW )
                             {
-                                aClipRect.Right() = nScrX + nScrW;			//! minus one?
-                                bRightClip = TRUE;
+                                aAreaParam.maClipRect.Right() = nScrX + nScrW;			//! minus one?
+                                aAreaParam.mbRightClip = true;
                             }
 
                             if ( !bHidden && !bOutside )
                             {
-                                BOOL bClip = bLeftClip || bRightClip;
+                                bool bClip = aAreaParam.mbLeftClip || aAreaParam.mbRightClip;
                                 BOOL bSimClip = FALSE;
 
                                 if ( bWrapFields )
@@ -2495,14 +2622,14 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     bClip = TRUE;
                                 }
 
-                                if ( aClipRect.Top() < nScrY )
+                                if ( aAreaParam.maClipRect.Top() < nScrY )
                                 {
-                                    aClipRect.Top() = nScrY;
+                                    aAreaParam.maClipRect.Top() = nScrY;
                                     bClip = TRUE;
                                 }
-                                if ( aClipRect.Bottom() > nScrY + nScrH )
+                                if ( aAreaParam.maClipRect.Bottom() > nScrY + nScrH )
                                 {
-                                    aClipRect.Bottom() = nScrY + nScrH;     //! minus one?
+                                    aAreaParam.maClipRect.Bottom() = nScrY + nScrH;     //! minus one?
                                     bClip = TRUE;
                                 }
 
@@ -2554,8 +2681,8 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                         bAnyClipped = TRUE;
 
                                         long nMarkPixel = (long)( SC_CLIPMARK_SIZE * nPPTX );
-                                        if ( aClipRect.Right() - nMarkPixel > aClipRect.Left() )
-                                            aClipRect.Right() -= nMarkPixel;
+                                        if ( aAreaParam.maClipRect.Right() - nMarkPixel > aAreaParam.maClipRect.Left() )
+                                            aAreaParam.maClipRect.Right() -= nMarkPixel;
                                     }
                                 }
 
@@ -2579,9 +2706,9 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                                     // Clip marks are already handled in GetOutputArea
 
                                     if (bPixelToLogic)
-                                        aLogicClip = pRefDevice->PixelToLogic( aClipRect );
+                                        aLogicClip = pRefDevice->PixelToLogic( aAreaParam.maClipRect );
                                     else
-                                        aLogicClip = aClipRect;
+                                        aLogicClip = aAreaParam.maClipRect;
 
                                     if (bClip)	// bei bSimClip nur aClipRect initialisieren
                                     {
@@ -3215,10 +3342,7 @@ void ScOutputData::DrawRotated(BOOL bPixelToLogic)
 
                                 // use GetOutputArea to hide the grid
                                 // (clip region is done manually below)
-                                BOOL bLeftClip = FALSE;
-                                BOOL bRightClip = FALSE;
-                                Rectangle aAlignRect;
-                                Rectangle aClipRect;
+                                OutputAreaParam aAreaParam;
 
                                 SCCOL nCellX = nX;
                                 SCROW nCellY = nY;
@@ -3231,8 +3355,7 @@ void ScOutputData::DrawRotated(BOOL bPixelToLogic)
 
                                 GetOutputArea( nX, nArrY, nCellStartX, nPosY, nCellX, nCellY, nNeededWidth,
                                                 *pPattern, sal::static_int_cast<USHORT>(eOutHorJust),
-                                                FALSE, FALSE, TRUE,
-                                                aAlignRect, aClipRect, bLeftClip, bRightClip );
+                                                FALSE, FALSE, TRUE, aAreaParam );
 
                                 if ( bShrink )
                                 {
@@ -3240,19 +3363,19 @@ void ScOutputData::DrawRotated(BOOL bPixelToLogic)
                                         pRefDevice->LogicToPixel(Size(nEngineWidth,0)).Width() : nEngineWidth;
                                     long nNeededPixel = nPixelWidth + nLeftM + nRightM;
 
-                                    bLeftClip = bRightClip = TRUE;
+                                    aAreaParam.mbLeftClip = aAreaParam.mbRightClip = TRUE;
 
                                     // always do height
-                                    ShrinkEditEngine( *pEngine, aAlignRect, nLeftM, nTopM, nRightM, nBottomM,
+                                    ShrinkEditEngine( *pEngine, aAreaParam.maAlignRect, nLeftM, nTopM, nRightM, nBottomM,
                                         FALSE, sal::static_int_cast<USHORT>(eOrient), nAttrRotate, bPixelToLogic,
-                                        nEngineWidth, nEngineHeight, nNeededPixel, bLeftClip, bRightClip );
+                                        nEngineWidth, nEngineHeight, nNeededPixel, aAreaParam.mbLeftClip, aAreaParam.mbRightClip );
 
                                     if ( eRotMode == SVX_ROTATE_MODE_STANDARD )
                                     {
                                         // do width only if rotating within the cell (standard mode)
-                                        ShrinkEditEngine( *pEngine, aAlignRect, nLeftM, nTopM, nRightM, nBottomM,
+                                        ShrinkEditEngine( *pEngine, aAreaParam.maAlignRect, nLeftM, nTopM, nRightM, nBottomM,
                                             TRUE, sal::static_int_cast<USHORT>(eOrient), nAttrRotate, bPixelToLogic,
-                                            nEngineWidth, nEngineHeight, nNeededPixel, bLeftClip, bRightClip );
+                                            nEngineWidth, nEngineHeight, nNeededPixel, aAreaParam.mbLeftClip, aAreaParam.mbRightClip );
                                     }
 
                                     // nEngineWidth/nEngineHeight is updated in ShrinkEditEngine
@@ -3306,19 +3429,19 @@ void ScOutputData::DrawRotated(BOOL bPixelToLogic)
                                     }
 
                                     if (bPixelToLogic)
-                                        aClipRect = pRefDevice->PixelToLogic( Rectangle(
+                                        aAreaParam.maClipRect = pRefDevice->PixelToLogic( Rectangle(
                                                         Point(nClipStartX,nClipStartY), aClipSize ) );
                                     else
-                                        aClipRect = Rectangle(Point(nClipStartX, nClipStartY),
+                                        aAreaParam.maClipRect = Rectangle(Point(nClipStartX, nClipStartY),
                                                                 aClipSize );	// Scale = 1
 
                                     if (bMetaFile)
                                     {
                                         pDev->Push();
-                                        pDev->IntersectClipRegion( aClipRect );
+                                        pDev->IntersectClipRegion( aAreaParam.maClipRect );
                                     }
                                     else
-                                        pDev->SetClipRegion( Region( aClipRect ) );
+                                        pDev->SetClipRegion( Region( aAreaParam.maClipRect ) );
                                 }
 
                                 Point aLogicStart;
-- 
1.7.0.1

