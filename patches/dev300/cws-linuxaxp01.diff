diff -r f387649cb501 automation/source/testtool/objtest.cxx
--- automation/source/testtool/objtest.cxx	Fri Mar 12 15:32:45 2010 +0100
+++ automation/source/testtool/objtest.cxx	Mon Mar 15 16:00:09 2010 +0000
@@ -518,6 +518,8 @@
     abGP.Append( "21" );  // Linux S390
 #elif defined LINUX && defined HPPA
     abGP.Append( "22" );  // Linux PA-RISC
+#elif defined LINUX && defined AXP
+    abGP.Append( "23" );  // Linux ALPHA
 #else
 #error ("unknown platform. please request an ID for your platform on qa/dev")
 #endif
diff -r f387649cb501 bridges/prj/build.lst
--- bridges/prj/build.lst	Fri Mar 12 15:32:45 2010 +0100
+++ bridges/prj/build.lst	Mon Mar 15 16:00:09 2010 +0000
@@ -12,16 +12,17 @@
 br	bridges\source\cpp_uno\gcc3_freebsd_intel	nmake	-	u	br_gcc3fi br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_freebsd_x86-64	nmake	-	u	br_gcc3fx br_cppuno_shared br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcclp3 br_cppuno_shared br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_powerpc64	nmake	-	u	br_gcclp3_64 br_cppuno_shared br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_mips		nmake	-	u	br_gcc3mips br_cppuno_shared br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_m68k		nmake	-	u	br_gcc3m68k br_cppuno_shared br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gccl33 br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_s390x		nmake	-	u	br_gccl3x br_unotypes br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes br_cppuno_shared br_inc NULL
-br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gccl3r br_unotypes NULL
-br	bridges\source\cpp_uno\gcc3_linux_ia64		nmake	-	u	br_gccl3a br_unotypes NULL
-br	bridges\source\cpp_uno\gcc3_linux_hppa		nmake	-	u	br_gccl3h br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcc3lp br_cppuno_shared br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_powerpc64	nmake	-	u	br_gcc3lp_64 br_cppuno_shared br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_mips		nmake	-	u	br_gcc3lmips br_cppuno_shared br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_m68k		nmake	-	u	br_gcc3lm68k br_cppuno_shared br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gcc3l3 br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_s390x		nmake	-	u	br_gcc3l3_64 br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gcc3ls br_unotypes br_cppuno_shared br_inc NULL
+br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gcc3lr br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_ia64		nmake	-	u	br_gcc3la br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_hppa		nmake	-	u	br_gcc3lh br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_alpha		nmake	-	u	br_gcc3ll br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_macosx_intel			nmake	-	u	br_gcc3macoxi br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_macosx_powerpc			nmake	-	u	br_gcc3macoxp br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\cc50_solaris_sparc			nmake	-	u	br_cc50sols br_unotypes br_cppuno_shared br_inc NULL
diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/cpp2uno.cxx
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_linux_alpha/cpp2uno.cxx	Mon Mar 15 16:00:09 2010 +0000
@@ -0,0 +1,676 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
+
+#include "share.hxx"
+#include <stdio.h>
+
+//Calling Standards:
+//  "Calling Standard for Alpha Systems"
+//     (Tru64 UNIX Version 5.1 or higher, August 2000)
+//http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/V51_HTML/ARH9MBTE/TITLE.HTM
+
+using namespace ::com::sun::star::uno;
+
+namespace 
+{
+static typelib_TypeClass cpp2uno_call(
+    bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
+    const typelib_TypeDescription * pMemberTypeDescr,
+    typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+    sal_Int32 nParams, typelib_MethodParameter * pParams,
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+    sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+#ifdef CMC_DEBUG
+    fprintf(stderr, "as far as cpp2uno_call\n");
+#endif
+    int nregs = 0; //number of words passed in registers
+       
+    // gpreg:  [ret *], this, [gpr params]
+    // fpreg:  [fpr params]
+    // ovrflw: [gpr or fpr params (properly aligned)]
+
+    // return
+    typelib_TypeDescription * pReturnTypeDescr = 0;
+    if (pReturnTypeRef)
+        TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+    
+    void * pUnoReturn = 0;
+    void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+    
+    if (pReturnTypeDescr)
+    {
+        if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
+        {
+            pUnoReturn = pRegisterReturn; // direct way for simple types
+        }
+        else // complex return via ptr (pCppReturn)
+        {
+            pCppReturn = *(void **)gpreg;
+            gpreg++;
+            fpreg++;
+            nregs++;
+            
+            pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+                          ? alloca( pReturnTypeDescr->nSize )
+                          : pCppReturn); // direct way
+        }
+    }
+    // pop this
+    gpreg++; 
+    fpreg++;
+    nregs++;
+
+    // stack space
+    OSL_ENSURE( sizeof(void *) == sizeof(sal_Int64), "### unexpected size!" );
+    // parameters
+    void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+    void ** pCppArgs = pUnoArgs + nParams;
+    // indizes of values this have to be converted (interface conversion cpp<=>uno)
+    sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+    // type descriptions for reconversions
+    typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+    
+    sal_Int32 nTempIndizes   = 0;
+    for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+    {
+        const typelib_MethodParameter & rParam = pParams[nPos];
+        typelib_TypeDescription * pParamTypeDescr = 0;
+        TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+#ifdef CMC_DEBUG
+        fprintf(stderr, "arg %d of %d\n", nPos, nParams);
+#endif
+
+        if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) // value
+        {
+#ifdef CMC_DEBUG
+            fprintf(stderr, "simple type is %d\n", pParamTypeDescr->eTypeClass);
+#endif
+
+            switch (pParamTypeDescr->eTypeClass)
+            {
+                case typelib_TypeClass_FLOAT:
+                case typelib_TypeClass_DOUBLE:
+                    if (nregs < axp::MAX_WORDS_IN_REGS)
+                    {
+                        if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT)
+                        {
+                            float tmp = (float) (*((double *)fpreg));
+                            (*((float *) fpreg)) = tmp;
+                        }
+
+                        pCppArgs[nPos] = pUnoArgs[nPos] = fpreg;
+                        gpreg++;
+                        fpreg++;
+                        nregs++;
+                    }
+                    else
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        ovrflw++;
+                    }
+                    break;
+                case typelib_TypeClass_BYTE:
+                case typelib_TypeClass_BOOLEAN:
+                    if (nregs < axp::MAX_WORDS_IN_REGS)
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
+                        gpreg++;
+                        fpreg++;
+                        nregs++;
+                    }
+                    else
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        ovrflw++;
+                    }
+                    break;
+                case typelib_TypeClass_CHAR:
+                case typelib_TypeClass_SHORT:
+                case typelib_TypeClass_UNSIGNED_SHORT:
+                    if (nregs < axp::MAX_WORDS_IN_REGS)
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
+                        gpreg++;
+                        fpreg++;
+                        nregs++;
+                    }
+                    else
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        ovrflw++;
+                    }
+                    break;
+                case typelib_TypeClass_ENUM:
+                case typelib_TypeClass_LONG:
+                case typelib_TypeClass_UNSIGNED_LONG:
+                    if (nregs < axp::MAX_WORDS_IN_REGS)
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
+                        gpreg++;
+                        fpreg++;
+                        nregs++;
+                    }
+                    else
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        ovrflw++;
+                    }
+                    break;
+                default:
+                    if (nregs < axp::MAX_WORDS_IN_REGS)
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
+                        gpreg++;
+                        fpreg++;
+                        nregs++;
+                    }
+                    else
+                    {
+                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        ovrflw++;
+                    }
+                    break;
+            }
+
+            // no longer needed
+            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+        }
+        else // ptr to complex value | ref
+        {
+#ifdef CMC_DEBUG
+            fprintf(stderr, "complex, nregs is %d\n", nregs);
+#endif
+
+            void *pCppStack; //temporary stack pointer
+
+            if (nregs < axp::MAX_WORDS_IN_REGS)
+            { 
+                pCppArgs[nPos] = pCppStack = *gpreg;
+                gpreg++;
+                fpreg++;
+                nregs++;
+            }
+            else
+            {
+                pCppArgs[nPos] = pCppStack = *ovrflw;
+                ovrflw++;
+            }
+
+            if (! rParam.bIn) // is pure out
+            {
+                // uno out is unconstructed mem!
+                pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+                pTempIndizes[nTempIndizes] = nPos;
+                // will be released at reconversion
+                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+            }
+            // is in/inout
+            else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+            {
+                uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                                        pCppStack, pParamTypeDescr,
+                                        pThis->getBridge()->getCpp2Uno() );
+                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+                // will be released at reconversion
+                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+            }
+            else // direct way
+            {
+                pUnoArgs[nPos] = pCppStack;
+                // no longer needed
+                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+            }
+        }
+    }
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "end of params\n");
+#endif
+    
+    // ExceptionHolder
+    uno_Any aUnoExc; // Any will be constructed by callee
+    uno_Any * pUnoExc = &aUnoExc;
+
+    // invoke uno dispatch call
+    (*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+    
+    // in case an exception occured...
+    if (pUnoExc)
+    {
+        // destruct temporary in/inout params
+        for ( ; nTempIndizes--; )
+        {
+            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+            
+            if (pParams[nIndex].bIn) // is in/inout => was constructed
+                uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+            TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+        }
+        if (pReturnTypeDescr)
+            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+        
+        CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); // has to destruct the any
+        // is here for dummy
+        return typelib_TypeClass_VOID;
+    }
+    else // else no exception occured...
+    {
+        // temporary params
+        for ( ; nTempIndizes--; )
+        {
+            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+            typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+            
+            if (pParams[nIndex].bOut) // inout/out
+            {
+                // convert and assign
+                uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+                uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+                                        pThis->getBridge()->getUno2Cpp() );
+            }
+            // destroy temp uno param
+            uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+            
+            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+        }
+        // return
+        if (pCppReturn) // has complex return
+        {
+            if (pUnoReturn != pCppReturn) // needs reconversion
+            {
+                uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+                                        pThis->getBridge()->getUno2Cpp() );
+                // destroy temp uno return
+                uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+            }
+            // complex return ptr is set to return reg
+            *(void **)pRegisterReturn = pCppReturn;
+        }
+        if (pReturnTypeDescr)
+        {
+            typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+            return eRet;
+        }
+        else
+            return typelib_TypeClass_VOID;
+    }
+}
+
+
+//============================================================================
+static typelib_TypeClass cpp_mediate(
+    sal_uInt64 nOffsetAndIndex,
+    void ** gpreg, void ** fpreg, void ** ovrflw,
+    sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+    OSL_ENSURE( sizeof(sal_Int64)==sizeof(void *), "### unexpected!" );
+
+    sal_Int32 nVtableOffset = (nOffsetAndIndex >> 32);
+    sal_Int32 nFunctionIndex = (nOffsetAndIndex & 0xFFFFFFFF);
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "nVTableOffset, nFunctionIndex are %x %x\n", nVtableOffset, nFunctionIndex);
+#endif
+
+#ifdef CMC_DEBUG
+        // Let's figure out what is really going on here
+        {
+            fprintf( stderr, "= cpp_mediate () =\nGPR's (%d): ", 6 );
+            for ( unsigned int i = 0; i < 6; ++i )
+                fprintf( stderr, "0x%lx, ", gpreg[i] );
+            fprintf( stderr, "\n");
+            fprintf( stderr, "\nFPR's (%d): ", 6 );
+            for ( unsigned int i = 0; i < 6; ++i )
+                fprintf( stderr, "0x%lx (%f), ", fpreg[i], fpreg[i] );
+            fprintf( stderr, "\n");
+        }
+#endif
+
+    
+    // gpreg:  [ret *], this, [other gpr params]
+    // fpreg:  [fpr params]
+    // ovrflw: [gpr or fpr params (properly aligned)]
+
+    // _this_ ptr is patched cppu_XInterfaceProxy object
+    void * pThis;
+    if( nFunctionIndex & 0x80000000 )
+    {
+        nFunctionIndex &= 0x7fffffff;
+        pThis = gpreg[1];
+    }
+    else
+    {
+        pThis = gpreg[0];
+    }
+
+    pThis = static_cast< char * >(pThis) - nVtableOffset;
+    
+    bridges::cpp_uno::shared::CppInterfaceProxy * pCppI
+        = bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy(
+            pThis);
+
+    typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
+
+    
+    OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+    if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+    {
+        throw RuntimeException(
+            rtl::OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pCppI );
+    }
+    
+    // determine called method
+    OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+    sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
+    OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+    TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+    
+    typelib_TypeClass eRet;
+    switch (aMemberDescr.get()->eTypeClass)
+    {
+    case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+    {
+        if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+        {
+            // is GET method
+            eRet = cpp2uno_call(
+                pCppI, aMemberDescr.get(),
+                ((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+                0, 0, // no params
+                gpreg, fpreg, ovrflw, pRegisterReturn );
+        }
+        else
+        {
+            // is SET method
+            typelib_MethodParameter aParam;
+            aParam.pTypeRef =
+                ((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+            aParam.bIn      = sal_True;
+            aParam.bOut     = sal_False;
+            
+            eRet = cpp2uno_call(
+                pCppI, aMemberDescr.get(),
+                0, // indicates void return
+                1, &aParam,
+                gpreg, fpreg, ovrflw, pRegisterReturn );
+        }
+        break;
+    }
+    case typelib_TypeClass_INTERFACE_METHOD:
+    {
+        // is METHOD
+        switch (nFunctionIndex)
+        {
+        case 1: // acquire()
+            pCppI->acquireProxy(); // non virtual call!
+            eRet = typelib_TypeClass_VOID;
+            break;
+        case 2: // release()
+            pCppI->releaseProxy(); // non virtual call!
+            eRet = typelib_TypeClass_VOID;
+            break;
+        case 0: // queryInterface() opt
+        {
+            typelib_TypeDescription * pTD = 0;
+            TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
+            if (pTD)
+            {
+                XInterface * pInterface = 0;
+                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
+                    pCppI->getBridge()->getCppEnv(),
+                    (void **)&pInterface, pCppI->getOid().pData, 
+                    (typelib_InterfaceTypeDescription *)pTD );
+            
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( gpreg[0] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = gpreg[0];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+        } // else perform queryInterface()
+        default:
+            eRet = cpp2uno_call(
+                pCppI, aMemberDescr.get(),
+                ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+                ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+                ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+                gpreg, fpreg, ovrflw, pRegisterReturn );
+        }
+        break;
+    }
+    default:
+    {
+        throw RuntimeException(
+            rtl::OUString::createFromAscii("no member description found!"),
+            (XInterface *)pCppI );
+        // is here for dummy
+        eRet = typelib_TypeClass_VOID;
+    }
+    }
+
+    return eRet;
+}
+
+long cpp_vtable_call(long r16, long r17, long r18, long r19, long r20, long r21, long firstonstack)
+{
+    register long r1 asm("$1");
+    sal_uInt64 nOffsetAndIndex = r1;
+
+    long sp = (long)&firstonstack;
+
+    sal_uInt64 gpreg[axp::MAX_GPR_REGS];
+    gpreg[0] = r16;
+    gpreg[1] = r17;
+    gpreg[2] = r18;
+    gpreg[3] = r19;
+    gpreg[4] = r20;
+    gpreg[5] = r21;
+
+    double fpreg[axp::MAX_SSE_REGS];
+    register double f16  asm("$f16");  fpreg[0] = f16;
+    register double f17  asm("$f17");  fpreg[1] = f17;
+    register double f18  asm("$f18");  fpreg[2] = f18;
+    register double f19  asm("$f19");  fpreg[3] = f19;
+    register double f20  asm("$f20");  fpreg[4] = f20;
+    register double f21  asm("$f21");  fpreg[5] = f21;
+
+    volatile long nRegReturn[1];
+#ifdef CMC_DEBUG
+    fprintf(stderr, "before mediate with %lx\n",nOffsetAndIndex);
+    fprintf(stderr, "non-doubles are %x %x %x %x %x %x\n", gpreg[0], gpreg[1], gpreg[2], gpreg[3], gpreg[4], gpreg[5]);
+    fprintf(stderr, "doubles are %f %f %f %f %f %f\n", fpreg[0], fpreg[1], fpreg[2], fpreg[3], fpreg[4], fpreg[5]);
+#endif
+    typelib_TypeClass aType = 
+        cpp_mediate( nOffsetAndIndex, (void**)gpreg, (void**)fpreg, (void**)sp, 
+            (sal_Int64*)nRegReturn );
+#ifdef CMC_DEBUG
+    fprintf(stderr, "after mediate ret is %lx %ld\n", nRegReturn[0], nRegReturn[0]);
+#endif
+
+    switch( aType )
+    {
+        case typelib_TypeClass_BOOLEAN:
+        case typelib_TypeClass_BYTE:
+            nRegReturn[0] = (unsigned long)(*(unsigned char *)nRegReturn);
+            break;
+        case typelib_TypeClass_CHAR:
+        case typelib_TypeClass_UNSIGNED_SHORT:
+        case typelib_TypeClass_SHORT:
+            nRegReturn[0] = (unsigned long)(*(unsigned short *)nRegReturn);
+            break;
+        case typelib_TypeClass_ENUM:
+        case typelib_TypeClass_UNSIGNED_LONG:
+        case typelib_TypeClass_LONG:
+            nRegReturn[0] = (unsigned long)(*(unsigned int *)nRegReturn);
+            break;
+        case typelib_TypeClass_VOID:
+        default:
+            break;
+        case typelib_TypeClass_FLOAT:
+            {
+                double tmp = (double) (*((float *)nRegReturn));
+                (*((double *) nRegReturn)) = tmp;
+            }
+            //deliberate fall through
+        case typelib_TypeClass_DOUBLE:
+            __asm__ ( "ldt $f0,%0\n\t"
+                : : "m" (*((double*)nRegReturn)) : "$f0");
+            break;
+    }
+    return nRegReturn[0];
+}
+
+const int codeSnippetSize = 32;
+
+unsigned char *codeSnippet( unsigned char * code, sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset, bool simple_ret_type )
+{
+    if (! simple_ret_type)
+        nFunctionIndex |= 0x80000000;
+
+    unsigned char * p = code;
+    *(unsigned int*)&p[0]  = 0x47fb0401;        /* mov $27,$1           */
+    *(unsigned int*)&p[4]  = 0xa43b0010;        /* ldq $1,16($27)      */
+    *(unsigned int*)&p[8]  = 0xa77b0018;        /* ldq $27,24($27)      */
+    *(unsigned int*)&p[12] = 0x6bfb0000;        /* jmp $31,($27),0      */
+    *(unsigned int*)&p[16] = nFunctionIndex;
+    *(unsigned int*)&p[20] = nVtableOffset;
+    *(unsigned long*)&p[24] = (unsigned long)cpp_vtable_call;
+    return (code + codeSnippetSize);
+}
+}
+
+void bridges::cpp_uno::shared::VtableFactory::flushCode(unsigned char const *, unsigned char const *)
+{
+    //http://www.gnu.org/software/lightning/manual/html_node/Standard-functions.html
+    __asm__ __volatile__("call_pal 0x86");
+}
+
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+{
+    return static_cast< Slot * >(block) + 2;
+}
+
+sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
+    sal_Int32 slotCount)
+{
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
+}
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
+}
+
+unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
+    Slot ** slots, unsigned char * code, sal_PtrDiff writetoexecdiff,
+    typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
+{
+    (*slots) -= functionCount;
+    Slot * s = *slots;
+#ifdef CMC_DEBUG
+    fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
+    fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
+#endif
+
+    for (sal_Int32 i = 0; i < type->nMembers; ++i) {
+        typelib_TypeDescription * member = 0;
+        TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
+        OSL_ASSERT(member != 0);
+        switch (member->eTypeClass) {
+        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+            // Getter:
+            (s++)->fn = code + writetoexecdiff;
+            code = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription * >(
+                        member)->pAttributeTypeRef));
+
+            // Setter:
+            if (!reinterpret_cast<
+                typelib_InterfaceAttributeTypeDescription * >(
+                    member)->bReadOnly)
+            {
+                (s++)->fn = code + writetoexecdiff;
+                code = codeSnippet(code, functionOffset++, vtableOffset, true);
+            }
+            break;
+
+        case typelib_TypeClass_INTERFACE_METHOD:
+            (s++)->fn = code + writetoexecdiff;
+            code = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription * >(
+                        member)->pReturnTypeRef));
+            break;
+
+        default:
+            OSL_ASSERT(false);
+            break;
+        }
+        TYPELIB_DANGER_RELEASE(member);
+    }
+    return code;
+}
+
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/except.cxx
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_linux_alpha/except.cxx	Mon Mar 15 16:00:09 2010 +0000
@@ -0,0 +1,287 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <stdio.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#if OSL_DEBUG_LEVEL > 1
+    char const * start = p;
+#endif
+
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+
+    OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+
+#if OSL_DEBUG_LEVEL > 1
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+
+    Mutex m_mutex;
+    t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
+    if (iRttiFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iRttiFind->second;
+    }
+
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+        ::uno_destructData( pExc, pTD, cpp_release );
+        ::typelib_typedescription_release( pTD );
+    }
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+    typelib_TypeDescription * pTypeDescr = 0;
+    TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+        terminate();
+
+    pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+    ::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+
+    // destruct uno exception
+    ::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+    rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+        terminate();
+    }
+
+    __cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+{
+    OSL_ENSURE( header, "### no exception header!!!" );
+    if (! header)
+        terminate();
+
+    typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
+    if (! pExcTypeDescr)
+        terminate();
+
+    // construct uno exception any
+    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+    ::typelib_typedescription_release( pExcTypeDescr );
+}
+
+}
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/makefile.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_linux_alpha/makefile.mk	Mon Mar 15 16:00:09 2010 +0000
@@ -0,0 +1,77 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2000, 2010 Oracle and/or its affiliates.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)" == "GCCLINUXL"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+# In case someone enabled the non-standard -fomit-frame-pointer which does not
+# work with the .cxx sources in this directory:
+CFLAGSCXX += -fno-omit-frame-pointer
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+SHL1RPATH=URELIB
+
+SHL1OBJS = $(SLOFILES)
+SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
+
+SHL1STDLIBS= \
+        $(CPPULIB)                      \
+        $(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/share.hxx
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_linux_alpha/share.hxx	Mon Mar 15 16:00:09 2010 +0000
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "uno/mapping.h"
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+  void dummy_can_throw_anything( char const * );
+
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
+
+namespace axp
+{
+    enum axplimits { MAX_WORDS_IN_REGS = 6, MAX_GPR_REGS = 6, MAX_SSE_REGS = 6 };
+}
+
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/uno2cpp.cxx
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_linux_alpha/uno2cpp.cxx	Mon Mar 15 16:00:09 2010 +0000
@@ -0,0 +1,532 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <malloc.h>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/vtables.hxx"
+
+#include "share.hxx"
+
+#include <stdio.h>
+#include <string.h>
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+void MapReturn(long r0, typelib_TypeClass eTypeClass, sal_uInt64* pRegisterReturn)
+{
+    register float fret asm("$f0");
+    register double dret asm("$f0");
+
+#ifdef CMC_DEBUG
+    fprintf(stderr,"Mapping Return with %lx %ld %f\n", r0, r0, dret);
+#endif
+    switch (eTypeClass)
+    {
+    case typelib_TypeClass_HYPER:
+    case typelib_TypeClass_UNSIGNED_HYPER:
+            *pRegisterReturn = r0;
+            break;
+    case typelib_TypeClass_LONG:
+    case typelib_TypeClass_UNSIGNED_LONG:
+    case typelib_TypeClass_ENUM:
+            *(unsigned int*)pRegisterReturn = (unsigned int)r0;
+            break;
+    case typelib_TypeClass_CHAR:
+    case typelib_TypeClass_SHORT:
+    case typelib_TypeClass_UNSIGNED_SHORT:
+            *(unsigned short*)pRegisterReturn = (unsigned short)r0;
+            break;
+    case typelib_TypeClass_BOOLEAN:
+    case typelib_TypeClass_BYTE:
+            *(unsigned char*)pRegisterReturn = (unsigned char)r0;
+            break;
+    case typelib_TypeClass_FLOAT:
+            *reinterpret_cast<float *>( pRegisterReturn ) = fret;
+            break;
+    case typelib_TypeClass_DOUBLE:
+            *reinterpret_cast<double *>( pRegisterReturn ) = dret;
+            break;
+    default:
+            break;
+    }
+#ifdef CMC_DEBUG
+    fprintf(stderr, "end of MapReturn with %x\n", pRegisterReturn ? *pRegisterReturn : 0);
+#endif
+}
+
+#define INSERT_FLOAT( pSV, nr, pFPR, pDS ) \
+    { \
+        if ( nr < axp::MAX_WORDS_IN_REGS ) \
+        { \
+                pFPR[nr++] = *reinterpret_cast<float *>( pSV ); \
+        } \
+        else \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); \
+    }
+
+#define INSERT_DOUBLE( pSV, nr, pFPR, pDS ) \
+        if ( nr < axp::MAX_WORDS_IN_REGS ) \
+                pFPR[nr++] = *reinterpret_cast<double *>( pSV ); \
+        else \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); // verbatim!
+
+#define INSERT_INT64( pSV, nr, pGPR, pDS ) \
+        if ( nr < axp::MAX_WORDS_IN_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt64 *>( pSV ); \
+        else \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV );
+
+#define INSERT_INT32( pSV, nr, pGPR, pDS ) \
+        if ( nr < axp::MAX_WORDS_IN_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
+        else \
+                *pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV );
+
+#define INSERT_INT16( pSV, nr, pGPR, pDS ) \
+        if ( nr < axp::MAX_WORDS_IN_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt16 *>( pSV ); \
+        else \
+                *pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV );
+
+#define INSERT_INT8( pSV, nr, pGPR, pDS ) \
+        if ( nr < axp::MAX_WORDS_IN_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt8 *>( pSV ); \
+        else \
+                *pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV );
+
+namespace
+{
+//==================================================================================================
+void callVirtualMethod(
+    void * pThis, sal_Int32 nVtableIndex,
+    void * pRegisterReturn, typelib_TypeDescription * pReturnTypeDescr,
+    sal_uInt64 *pStack, sal_uInt32 nStack,
+    sal_uInt64 *pGPR, sal_uInt32 nGPR,
+    double *pFPR, sal_uInt32 nFPR)
+{
+    // Should not happen, but...
+    if ( nFPR > axp::MAX_SSE_REGS )
+        nFPR = axp::MAX_SSE_REGS;
+    if ( nGPR > axp::MAX_GPR_REGS )
+        nGPR = axp::MAX_GPR_REGS;
+
+#ifdef CMC_DEBUG
+        // Let's figure out what is really going on here
+        {
+            fprintf( stderr, "= nStack is %d\n", nStack );
+            fprintf( stderr, "= callVirtualMethod() =\nGPR's (%d): ", nGPR );
+            for ( unsigned int i = 0; i < nGPR; ++i )
+                fprintf( stderr, "0x%lx, ", pGPR[i] );
+            fprintf( stderr, "\nFPR's (%d): ", nFPR );
+            for ( unsigned int i = 0; i < nFPR; ++i )
+                fprintf( stderr, "0x%lx (%f), ", pFPR[i], pFPR[i] );
+            fprintf( stderr, "\nStack (%d): ", nStack );
+            for ( unsigned int i = 0; i < nStack; ++i )
+                fprintf( stderr, "0x%lx, ", pStack[i] );
+            fprintf( stderr, "\n" );
+            fprintf( stderr, "pRegisterReturn is %p\n", pRegisterReturn);
+        }
+#endif
+
+    // Load parameters to stack, if necessary
+    // Stack, if used, must be 8-bytes aligned
+    sal_uInt64 *stack = (sal_uInt64 *) __builtin_alloca( nStack * 8 );
+    memcpy( stack, pStack, nStack * 8 );
+
+    // To get pointer to method
+    // a) get the address of the vtable
+    sal_uInt64 pMethod = *((sal_uInt64 *)pThis);
+    // b) get the address from the vtable entry at offset
+    pMethod += 8 * nVtableIndex;
+    pMethod = *((sal_uInt64 *)pMethod);
+
+    typedef void (* FunctionCall )( sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64 );
+    FunctionCall pFunc = (FunctionCall)pMethod;
+
+    switch (nFPR) //deliberate fall through
+    {
+        case 6:
+            asm volatile("ldt $f16,%0" :: "m"(pFPR[5]) : "$f16");
+        case 5:
+            asm volatile("ldt $f17,%0" :: "m"(pFPR[4]) : "$f17");
+        case 4:
+            asm volatile("ldt $f18,%0" :: "m"(pFPR[3]) : "$f18");
+        case 3:
+            asm volatile("ldt $f19,%0" :: "m"(pFPR[2]) : "$f19");
+        case 2:
+            asm volatile("ldt $f20,%0" :: "m"(pFPR[1]) : "$f20");
+        case 1:
+            asm volatile("ldt $f21,%0" :: "m"(pFPR[0]) : "$f21");
+        default:
+            break;
+    }
+
+    (*pFunc)(pGPR[0], pGPR[1], pGPR[2], pGPR[3], pGPR[4], pGPR[5]);
+    register sal_uInt64 r0 __asm__("$0");
+    MapReturn(r0, pReturnTypeDescr->eTypeClass, (sal_uInt64*)pRegisterReturn);
+}
+
+
+//============================================================================ 
+static void cpp_call(
+        bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
+        bridges::cpp_uno::shared::VtableSlot  aVtableSlot,
+        typelib_TypeDescriptionReference * pReturnTypeRef,
+    sal_Int32 nParams, typelib_MethodParameter * pParams,
+    void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+    // max space for: [complex ret ptr], values|ptr ...
+    sal_uInt64 * pStack = (sal_uInt64 *)alloca( (nParams+3) * sizeof(sal_Int64) );
+    sal_uInt64 * pStackStart = pStack;
+
+    sal_uInt64 pGPR[axp::MAX_GPR_REGS];
+    double pFPR[axp::MAX_SSE_REGS];
+    sal_uInt32 nRegs = 0;
+    
+    // return
+    typelib_TypeDescription * pReturnTypeDescr = 0;
+    TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+    OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+    
+    void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+
+    if (pReturnTypeDescr)
+    {
+        if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
+        {
+            pCppReturn = pUnoReturn; // direct way for simple types
+        }
+        else
+        {
+            // complex return via ptr
+            pCppReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+                                                ? alloca( pReturnTypeDescr->nSize )
+                                                : pUnoReturn); // direct way
+            INSERT_INT64( &pCppReturn, nRegs, pGPR, pStack );
+        }
+    }
+        // push "this" pointer
+    void * pAdjustedThisPtr = reinterpret_cast< void ** >( pThis->getCppI() ) + aVtableSlot.offset;
+
+    INSERT_INT64( &pAdjustedThisPtr, nRegs, pGPR, pStack );
+
+    // stack space
+    OSL_ENSURE( sizeof(void *) == sizeof(sal_Int64), "### unexpected size!" );
+    // args
+    void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
+    // indizes of values this have to be converted (interface conversion cpp<=>uno)
+    sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+    // type descriptions for reconversions
+    typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+    
+    sal_Int32 nTempIndizes   = 0;
+    
+    for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+    {
+        const typelib_MethodParameter & rParam = pParams[nPos];
+        typelib_TypeDescription * pParamTypeDescr = 0;
+        TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+        
+        if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
+        {
+            uno_copyAndConvertData( pCppArgs[nPos] = alloca( 8 ), pUnoArgs[nPos], pParamTypeDescr,
+                                    pThis->getBridge()->getUno2Cpp() );
+
+            switch (pParamTypeDescr->eTypeClass)
+            {
+                case typelib_TypeClass_HYPER:
+                case typelib_TypeClass_UNSIGNED_HYPER:
+                    INSERT_INT64( pCppArgs[nPos], nRegs, pGPR, pStack );
+                    break;
+                case typelib_TypeClass_LONG:
+                case typelib_TypeClass_UNSIGNED_LONG:
+                case typelib_TypeClass_ENUM:
+                    INSERT_INT32( pCppArgs[nPos], nRegs, pGPR, pStack );
+                    break;
+                case typelib_TypeClass_SHORT:
+                case typelib_TypeClass_CHAR:
+                case typelib_TypeClass_UNSIGNED_SHORT:
+                    INSERT_INT16( pCppArgs[nPos], nRegs, pGPR, pStack );
+                    break;
+                case typelib_TypeClass_BOOLEAN:
+                case typelib_TypeClass_BYTE:
+                    INSERT_INT8( pCppArgs[nPos], nRegs, pGPR, pStack );
+                    break;
+                case typelib_TypeClass_FLOAT:
+                    INSERT_FLOAT( pCppArgs[nPos], nRegs, pFPR, pStack );
+                    break;
+                case typelib_TypeClass_DOUBLE:
+                    INSERT_DOUBLE( pCppArgs[nPos], nRegs, pFPR, pStack );
+                    break;
+                default:
+                    break;
+            }
+
+            // no longer needed
+            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+        }
+        else // ptr to complex value | ref
+        {
+            if (! rParam.bIn) // is pure out
+            {
+                // cpp out is constructed mem, uno out is not!
+                uno_constructData(
+                    pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                    pParamTypeDescr );
+                pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+                // will be released at reconversion
+                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+            }
+            // is in/inout
+            else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+            {
+                uno_copyAndConvertData(
+                    pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                    pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
+                
+                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+                // will be released at reconversion
+                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+            }
+            else // direct way
+            {
+                pCppArgs[nPos] = pUnoArgs[nPos];
+                // no longer needed
+                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+            }
+            INSERT_INT64( &(pCppArgs[nPos]), nRegs, pGPR, pStack );
+        }
+    }
+  
+    try
+    {
+        callVirtualMethod(
+            pAdjustedThisPtr, aVtableSlot.index,
+            pCppReturn, pReturnTypeDescr,
+            pStackStart, (pStack - pStackStart),
+            pGPR, nRegs,
+            pFPR, nRegs );
+        // NO exception occured...
+        *ppUnoExc = 0;
+        
+        // reconvert temporary params
+        for ( ; nTempIndizes--; )
+        {
+            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+            typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+            
+            if (pParams[nIndex].bIn)
+            {
+                if (pParams[nIndex].bOut) // inout
+                {
+                    uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+                    uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+                                            pThis->getBridge()->getCpp2Uno() );
+                }
+            }
+            else // pure out
+            {
+                uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+                                        pThis->getBridge()->getCpp2Uno() );
+            }
+            // destroy temp cpp param => cpp: every param was constructed
+            uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+            
+            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+        }
+        // return value
+        if (pCppReturn && pUnoReturn != pCppReturn)
+        {
+            uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+                                    pThis->getBridge()->getCpp2Uno() );
+            uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+        }
+    }
+    catch (...)
+    {
+        // fill uno exception
+        fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, 
+            *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
+
+        
+        // temporary params
+        for ( ; nTempIndizes--; )
+        {
+            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+            // destroy temp cpp param => cpp: every param was constructed
+            uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+            TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+        }
+        // return type
+        if (pReturnTypeDescr)
+            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+    }
+}
+}
+
+namespace bridges { namespace cpp_uno { namespace shared {
+
+void unoInterfaceProxyDispatch(
+    uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+    void * pReturn, void * pArgs[], uno_Any ** ppException )
+{
+#ifdef CMC_DEBUG
+    fprintf(stderr, "unoInterfaceProxyDispatch\n");
+#endif
+    
+
+    // is my surrogate
+    bridges::cpp_uno::shared::UnoInterfaceProxy * pThis 
+            = static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy *> (pUnoI);
+    
+    switch (pMemberDescr->eTypeClass)
+    {
+    case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+    {
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription const * >(
+                        pMemberDescr)));
+
+        if (pReturn)
+        {
+            // dependent dispatch
+            cpp_call(
+                pThis, aVtableSlot,
+                ((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+                0, 0, // no params
+                pReturn, pArgs, ppException );
+        }
+        else
+        {
+            // is SET
+            typelib_MethodParameter aParam;
+            aParam.pTypeRef =
+                ((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+            aParam.bIn      = sal_True;
+            aParam.bOut     = sal_False;
+
+            typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+            OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+            typelib_typedescriptionreference_new(
+                &pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+            
+            // dependent dispatch
+                        aVtableSlot.index += 1; //get then set method
+            cpp_call(
+                pThis, aVtableSlot,
+                pReturnTypeRef,
+                1, &aParam,
+                pReturn, pArgs, ppException );
+            
+            typelib_typedescriptionreference_release( pReturnTypeRef );
+        }
+        
+        break;
+    }
+    case typelib_TypeClass_INTERFACE_METHOD:
+    {
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription const * >(
+                        pMemberDescr)));
+        switch (aVtableSlot.index)
+        {
+            // standard calls
+        case 1: // acquire uno interface
+            (*pUnoI->acquire)( pUnoI );
+            *ppException = 0;
+            break;
+        case 2: // release uno interface
+            (*pUnoI->release)( pUnoI );
+            *ppException = 0;
+            break;
+        case 0: // queryInterface() opt
+        {
+            typelib_TypeDescription * pTD = 0;
+            TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+            if (pTD)
+            {
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->getUnoEnv()->getRegisteredInterface)(
+                    pThis->pBridge->getUnoEnv(),
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+            
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+        } // else perform queryInterface()
+        default:
+            // dependent dispatch
+            cpp_call(
+                pThis, aVtableSlot,
+                ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+                ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+                ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+                pReturn, pArgs, ppException );
+        }
+        break;
+    }
+    default:
+    {
+        ::com::sun::star::uno::RuntimeException aExc(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+            ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+        
+        Type const & rExcType = ::getCppuType( &aExc );
+        // binary identical null reference
+        ::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+    }
+    }
+}
+
+} } }
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
diff -r f387649cb501 idlc/source/preproc/cpp.h
--- idlc/source/preproc/cpp.h	Fri Mar 12 15:32:45 2010 +0100
+++ idlc/source/preproc/cpp.h	Mon Mar 15 16:00:09 2010 +0000
@@ -40,11 +40,8 @@
 #define NULL	0
 #endif
 
-#ifndef __alpha
 typedef unsigned char uchar;
 
-#endif
-
 enum toktype
 {
     END, UNCLASS, NAME, NUMBER, STRING, CCON, NL, WS, DSHARP,
diff -r f387649cb501 jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx
--- jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	Fri Mar 12 15:32:45 2010 +0100
+++ jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	Mon Mar 15 16:00:09 2010 +0000
@@ -69,9 +69,11 @@
 #define JFW_PLUGIN_ARCH "m68k"
 #elif defined HPPA
 #define JFW_PLUGIN_ARCH "parisc"
-#else // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA
+#elif defined AXP
+#define JFW_PLUGIN_ARCH "alpha"
+#else // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA, ALPHA
 #error unknown plattform
-#endif // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA
+#endif // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA, ALPHA
 
 
 class MalformedVersionException
diff -r f387649cb501 sal/rtl/source/macro.hxx
--- sal/rtl/source/macro.hxx	Fri Mar 12 15:32:45 2010 +0100
+++ sal/rtl/source/macro.hxx	Mon Mar 15 16:00:09 2010 +0000
@@ -89,6 +89,8 @@
 #    define THIS_ARCH "M68K"
 #elif defined HPPA
 #    define THIS_ARCH "HPPA"
+#elif defined AXP
+#    define THIS_ARCH "ALPHA"
 #endif
 
 #if ! defined THIS_ARCH
diff -r f387649cb501 sal/typesconfig/typesconfig.c
--- sal/typesconfig/typesconfig.c	Fri Mar 12 15:32:45 2010 +0100
+++ sal/typesconfig/typesconfig.c	Mon Mar 15 16:00:09 2010 +0000
@@ -160,7 +160,7 @@
 |*	Letzte Aenderung
 |*
 *************************************************************************/
-#if defined(IA64) || defined(ARM32) || defined(HPPA)
+#if defined(IA64) || defined(ARM32) || defined(HPPA) || defined(AXP)
 
 int forceerror()
 {
diff -r f387649cb501 set_soenv.in
--- set_soenv.in	Fri Mar 12 15:32:45 2010 +0100
+++ set_soenv.in	Mon Mar 15 16:00:09 2010 +0000
@@ -509,9 +509,9 @@
    elsif ($platform =~ m/^alpha/) 
    {  print "Setting Linux Alpha specific values... ";
       $outfile        = "LinuxAlphaEnv.Set"; 
-      $CPU            = "A";
-      $CPUNAME        = "ALPHA_";
-      $OUTPATH        = "unxlnga";
+      $CPU            = "L";
+      $CPUNAME        = "AXP";
+      $OUTPATH        = "unxlngaxp";
       $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha";
       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha".$ds."server";
       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha".$ds."native_threads";
diff -r f387649cb501 solenv/inc/unx.mk
--- solenv/inc/unx.mk	Fri Mar 12 15:32:45 2010 +0100
+++ solenv/inc/unx.mk	Mon Mar 15 16:00:09 2010 +0000
@@ -167,6 +167,10 @@
 .INCLUDE : unxlnghppa.mk
 .ENDIF
 
+.IF "$(COM)$(OS)$(CPU)" == "GCCLINUXL"
+.INCLUDE : unxlngaxp.mk
+.ENDIF
+
 # --- general *ix settings ---
 HC=hc
 HCFLAGS=
diff -r f387649cb501 solenv/inc/unxlngaxp.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ solenv/inc/unxlngaxp.mk	Mon Mar 15 16:00:09 2010 +0000
@@ -0,0 +1,34 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2000, 2010 Oracle and/or its affiliates.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+# mk file for Unix Linux Alpha using gcc, please make generic modifications to unxlng.mk
+
+PICSWITCH:=-fPIC
+.INCLUDE : unxlng.mk
+CFLAGS+=-DAXP
+DLLPOSTFIX=ll
+BUILD64=1
diff -r f387649cb501 soltools/cpp/cpp.h
--- soltools/cpp/cpp.h	Fri Mar 12 15:32:45 2010 +0100
+++ soltools/cpp/cpp.h	Mon Mar 15 16:00:09 2010 +0000
@@ -15,11 +15,8 @@
 #define NULL	0
 #endif
 
-#ifndef __alpha
 typedef unsigned char uchar;
 
-#endif
-
 enum toktype
 {
     END, UNCLASS, NAME, NUMBER, STRING, CCON, NL, WS, DSHARP,
diff -r f387649cb501 tools/inc/tools/solar.h
--- tools/inc/tools/solar.h	Fri Mar 12 15:32:45 2010 +0100
+++ tools/inc/tools/solar.h	Mon Mar 15 16:00:09 2010 +0000
@@ -384,6 +384,8 @@
   #define __DLLEXTENSION "lm.so"
 #elif defined LINUX && defined HPPA
   #define __DLLEXTENSION "lh.so"
+#elif defined LINUX && defined AXP
+  #define __DLLEXTENSION "ll.so"
 #elif defined LINUX
   #error unknown plattform
 #elif defined FREEBSD && defined X86

# HG changeset patch
# User Caolán McNamara <cmc@openoffice.org>
# Date 1269009889 0
# Node ID 33875dd3d07bb185d0d8d6cb570ecc8f4241d53c
# Parent  ec31c94b80f964365b6d9e1f63e9bdac1d88c9b1
linuxaxp01: #i110145# yet another hard-coded list to fall over

changeset 0b056a7d1510 in cws/linuxaxp01
details: http://hg.services.openoffice.org/cws/linuxaxp01?cmd=changeset;node=0b056a7d1510
author: Caolán McNamara <cmc@openoffice.org>
date: Tue, 30 Mar 2010 10:43:30 +0100
summary: linuxaxp01: #i110145# add Linux m68k to this list


diff -r ec31c94b80f9 -r 33875dd3d07b desktop/source/deployment/misc/dp_platform.cxx
--- desktop/source/deployment/misc/dp_platform.cxx	Thu Mar 18 11:03:29 2010 +0000
+++ desktop/source/deployment/misc/dp_platform.cxx	Fri Mar 19 14:44:49 2010 +0000
@@ -49,8 +49,11 @@
 #define PLATFORM_LINUX_MIPS_EL      "linux_mips_el"
 #define PLATFORM_LINUX_MIPS_EB      "linux_mips_eb"
 #define PLATFORM_LINUX_IA64         "linux_ia64"
+#define PLATFORM_LINUX_M68K         "linux_m68k"
 #define PLATFORM_LINUX_S390         "linux_s390"
 #define PLATFORM_LINUX_S390x        "linux_s390x"
+#define PLATFORM_LINUX_HPPA         "linux_hppa"
+#define PLATFORM_LINUX_ALPHA        "linux_alpha"
 
 
 
@@ -142,10 +142,16 @@
             ret = checkOSandCPU(OUSTR("Linux"), OUSTR("MIPS_EB"));  
         else if (token.equals(OUSTR(PLATFORM_LINUX_IA64)))
             ret = checkOSandCPU(OUSTR("Linux"), OUSTR("IA64"));  
+        else if (token.equals(OUSTR(PLATFORM_LINUX_M68K)))
+            ret = checkOSandCPU(OUSTR("Linux"), OUSTR("M68K"));  
         else if (token.equals(OUSTR(PLATFORM_LINUX_S390)))
             ret = checkOSandCPU(OUSTR("Linux"), OUSTR("S390"));  
         else if (token.equals(OUSTR(PLATFORM_LINUX_S390x)))
             ret = checkOSandCPU(OUSTR("Linux"), OUSTR("S390x"));  
+        else if (token.equals(OUSTR(PLATFORM_LINUX_HPPA)))
+            ret = checkOSandCPU(OUSTR("Linux"), OUSTR("HPPA"));  
+        else if (token.equals(OUSTR(PLATFORM_LINUX_ALPHA)))
+            ret = checkOSandCPU(OUSTR("Linux"), OUSTR("ALPHA"));  
         else if (token.equals(OUSTR(PLATFORM_SOLARIS_SPARC)))
             ret = checkOSandCPU(OUSTR("Solaris"), OUSTR("SPARC"));
         else if (token.equals(OUSTR(PLATFORM_SOLARIS_SPARC64)))


# HG changeset patch
# User Caolán McNamara <cmc@openoffice.org>
# Date 1269100207 0
# Node ID 8c4d9c55f482e09a6e9053520e9ea5e9e62ab0af
# Parent  33875dd3d07bb185d0d8d6cb570ecc8f4241d53c
linuxaxp01: #i110145# hppa bridge used uninit value and ludicrous logic

diff -r 33875dd3d07b -r 8c4d9c55f482 bridges/source/cpp_uno/gcc3_linux_hppa/cpp2uno.cxx
--- bridges/source/cpp_uno/gcc3_linux_hppa/cpp2uno.cxx	Fri Mar 19 14:44:49 2010 +0000
+++ bridges/source/cpp_uno/gcc3_linux_hppa/cpp2uno.cxx	Sat Mar 20 15:50:07 2010 +0000
@@ -61,7 +61,7 @@
         long r8, void ** gpreg, double *fpreg, void ** ovrflw,
         sal_Int64 * pRegisterReturn /* space for register return */ )
     {
-        void ** startovrflw;
+        void ** startovrflw = ovrflw;
         int nregs = 0; //number of words passed in registers
 
 #ifdef CMC_DEBUG
@@ -143,7 +143,7 @@
                         }
                         else
                         {
-                            if ((startovrflw-ovrflw) & 4)
+                            if ((startovrflw-ovrflw) & 1)
                                 ovrflw--;
                             pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)ovrflw - 4);
                             bOverFlowUsed = true;
@@ -182,7 +182,7 @@
                         }
                         else
                         {
-                            if ((startovrflw-ovrflw) & 4)
+                            if ((startovrflw-ovrflw) & 1)
                                 ovrflw--;
                             pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)ovrflw - 4);
                             bOverFlowUsed = true;

