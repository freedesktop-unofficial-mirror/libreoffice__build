From 7f06afb4876dc52e92d0a1cc7e22af04c4dd9636 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:56:50 +0200
Subject: [PATCH 201/768] calc-perf-page-and-manual-breaks.diff

---
 sc/inc/document.hxx                 |   23 +++
 sc/inc/global.hxx                   |    9 +-
 sc/inc/table.hxx                    |   31 ++++-
 sc/source/core/data/document.cxx    |  105 ++++++++++++++
 sc/source/core/data/table1.cxx      |    3 +-
 sc/source/core/data/table2.cxx      |   59 +++++++--
 sc/source/core/data/table3.cxx      |    6 +-
 sc/source/core/data/table5.cxx      |  260 +++++++++++++++++++++++++++++------
 sc/source/filter/excel/xepage.cxx   |   31 +++--
 sc/source/filter/excel/xipage.cxx   |    4 +-
 sc/source/filter/starcalc/scflt.cxx |   24 ++--
 sc/source/filter/xml/xmlexprt.cxx   |    1 +
 sc/source/ui/docshell/dbdocfun.cxx  |    3 +
 sc/source/ui/docshell/docfunc.cxx   |   35 +++--
 sc/source/ui/docshell/olinefun.cxx  |    2 +
 sc/source/ui/undo/undocell.cxx      |    2 +
 sc/source/ui/undo/undodat.cxx       |    3 +
 sc/source/ui/unoobj/cellsuno.cxx    |   52 ++-----
 sc/source/ui/unoobj/docuno.cxx      |   16 +-
 sc/source/ui/vba/vbarange.cxx       |   10 +-
 sc/source/ui/view/cellsh.cxx        |    8 +-
 sc/source/ui/view/gridwin2.cxx      |   12 +-
 sc/source/ui/view/gridwin4.cxx      |    4 +-
 sc/source/ui/view/output.cxx        |   49 +++----
 sc/source/ui/view/printfun.cxx      |   80 +++++++++--
 25 files changed, 631 insertions(+), 201 deletions(-)

diff --git sc/inc/document.hxx sc/inc/document.hxx
index c81684b..ffee730 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -44,6 +44,7 @@
 
 #include <memory>
 #include <map>
+#include <set>
 
 // Wang Xu Ming -- 2009-8-17
 // DataPilot Migration - Cache&&Performance
@@ -160,6 +161,9 @@ namespace com { namespace sun { namespace star {
     namespace embed {
         class XEmbeddedObject;
     }
+    namespace sheet {
+        struct TablePageBreakData;
+    }
 } } }
 
 #include <svl/zforlist.hxx>
@@ -1328,6 +1332,24 @@ public:
     SC_DLLPUBLIC const ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArray( SCTAB nTab ) const;
     SC_DLLPUBLIC       ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArrayModifiable( SCTAB nTab );
 
+    SC_DLLPUBLIC void           GetAllRowBreaks(::std::set<SCROW>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const;
+    SC_DLLPUBLIC void           GetAllColBreaks(::std::set<SCCOL>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const;
+    SC_DLLPUBLIC ScBreakType    HasRowBreak(SCROW nRow, SCTAB nTab) const;
+    SC_DLLPUBLIC ScBreakType    HasColBreak(SCCOL nCol, SCTAB nTab) const;
+    SC_DLLPUBLIC void           SetRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual);
+    SC_DLLPUBLIC void           SetColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual);
+    void                        RemoveRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual);
+    void                        RemoveColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual);
+    ::com::sun::star::uno::Sequence<
+        ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData(SCTAB nTab) const;
+
+    /**
+     * Write all column row flags to table's flag data, because not all column
+     * row attributes are stored in the flag data members.  This is necessary
+     * for ods export.
+     */
+    void                        SyncColRowFlags();
+
                     /// @return  the index of the last row with any set flags (auto-pagebreak is ignored).
     SC_DLLPUBLIC SCROW			GetLastFlaggedRow( SCTAB nTab ) const;
 
@@ -1367,6 +1389,7 @@ public:
     Size			GetPageSize( SCTAB nTab ) const;
     void			SetPageSize( SCTAB nTab, const Size& rSize );
     void			SetRepeatArea( SCTAB nTab, SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCROW nEndRow );
+    void            InvalidatePageBreaks(SCTAB nTab);
     void			UpdatePageBreaks( SCTAB nTab, const ScRange* pUserArea = NULL );
     void			RemoveManualBreaks( SCTAB nTab );
     BOOL			HasManualBreaks( SCTAB nTab ) const;
diff --git sc/inc/global.hxx sc/inc/global.hxx
index 1dcf01c..e456fed 100644
--- sc/inc/global.hxx
+++ sc/inc/global.hxx
@@ -203,13 +203,16 @@ const SCSIZE PIVOT_MAXPAGEFIELD = 10;
                                     // FILTERED und MANUALSIZE nur fuer Zeilen moeglich
 const BYTE   CR_HIDDEN      = 1;
 //const BYTE CR_MARKED      = 2;
-const BYTE   CR_PAGEBREAK   = 4;
+//const BYTE CR_PAGEBREAK   = 4;
 const BYTE   CR_MANUALBREAK = 8;
 const BYTE   CR_FILTERED    = 16;
 const BYTE   CR_MANUALSIZE  = 32;
+const BYTE   CR_ALL         = (CR_HIDDEN | CR_MANUALBREAK | CR_FILTERED | CR_MANUALSIZE);
 
-//	was davon kommt in die Datei:
-#define CR_SAVEMASK		( ~CR_PAGEBREAK )
+typedef BYTE ScBreakType;
+const ScBreakType BREAK_NONE   = 0;
+const ScBreakType BREAK_PAGE   = 1;
+const ScBreakType BREAK_MANUAL = 2;
 
 // Insert-/Delete-Flags
 const USHORT IDF_NONE       = 0x0000;
diff --git sc/inc/table.hxx sc/inc/table.hxx
index 986fda5..02115b1 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -39,12 +39,19 @@
 #include "compressedarray.hxx"
 
 #include <memory>
+#include <set>
 
 namespace utl {
     class SearchParam;
     class TextSearch;
 }
 
+namespace com { namespace sun { namespace star {
+    namespace sheet {
+        struct TablePageBreakData;
+    }
+} } }
+
 class SfxItemSet;
 class SfxStyleSheetBase;
 class SvxBoxInfoItem;
@@ -117,6 +124,11 @@ private:
     BYTE*			pColFlags;
     ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
 
+    ::std::set<SCROW>                      maRowPageBreaks;
+    ::std::set<SCROW>                      maRowManualBreaks;
+    ::std::set<SCCOL>                      maColPageBreaks;
+    ::std::set<SCCOL>                      maColManualBreaks;
+
     ScOutlineTable*	pOutlineTable;
 
     SCCOL			nTableAreaX;
@@ -156,6 +168,7 @@ private:
     Color			aScenarioColor;
     USHORT			nScenarioFlags;
     BOOL			bActiveScenario;
+    bool            mbPageBreaksValid;
 
 friend class ScDocument;					// fuer FillInfo
 friend class ScDocumentIterator;
@@ -366,7 +379,8 @@ public:
 
     void		CopyUpdated( const ScTable* pPosTab, ScTable* pDestTab ) const;
 
-    void		InvalidateTableArea()						{ bTableAreaValid = FALSE; }
+    void        InvalidateTableArea();
+    void        InvalidatePageBreaks();
 
     BOOL		GetCellArea( SCCOL& rEndCol, SCROW& rEndRow ) const;			// FALSE = leer
     BOOL		GetTableArea( SCCOL& rEndCol, SCROW& rEndRow ) const;
@@ -637,6 +651,21 @@ public:
     void		RemoveManualBreaks();
     BOOL		HasManualBreaks() const;
 
+    void        GetAllRowBreaks(::std::set<SCROW>& rBreaks, bool bPage, bool bManual) const;
+    void        GetAllColBreaks(::std::set<SCCOL>& rBreaks, bool bPage, bool bManual) const;
+    bool        HasRowPageBreak(SCROW nRow) const;
+    bool        HasColPageBreak(SCCOL nCol) const;
+    bool        HasRowManualBreak(SCROW nRow) const;
+    bool        HasColManualBreak(SCCOL nCol) const;
+    void        RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow);
+    void        RemoveRowBreak(SCROW nRow, bool bPage, bool bManual);
+    void        RemoveColBreak(SCCOL nCol, bool bPage, bool bManual);
+    void        SetRowBreak(SCROW nRow, bool bPage, bool bManual);
+    void        SetColBreak(SCCOL nCol, bool bPage, bool bManual);
+    ::com::sun::star::uno::Sequence<
+        ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData() const;
+    void        SyncColRowFlags();
+
     void		StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
     void		ExtendHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
 
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 366211d..de74b81 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -51,6 +51,7 @@
 #include <tools/tenccvt.hxx>
 
 #include <com/sun/star/text/WritingMode2.hpp>
+#include <com/sun/star/sheet/TablePageBreakData.hpp>
 
 #include "document.hxx"
 #include "table.hxx"
@@ -95,6 +96,9 @@
 #include <map>
 
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::sheet::TablePageBreakData;
+using ::std::set;
 
 struct ScDefaultAttr
 {
@@ -3423,6 +3427,102 @@ const ScBitMaskCompressedArray< SCROW, BYTE> & ScDocument::GetRowFlagsArray(
     return *pFlags;
 }
 
+void ScDocument::GetAllRowBreaks(set<SCROW>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->GetAllRowBreaks(rBreaks, bPage, bManual);
+}
+
+void ScDocument::GetAllColBreaks(set<SCCOL>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->GetAllColBreaks(rBreaks, bPage, bManual);
+}
+
+ScBreakType ScDocument::HasRowBreak(SCROW nRow, SCTAB nTab) const
+{
+    ScBreakType nType = BREAK_NONE;
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return nType;
+
+    if (pTab[nTab]->HasRowPageBreak(nRow))
+        nType |= BREAK_PAGE;
+
+    if (pTab[nTab]->HasRowManualBreak(nRow))
+        nType |= BREAK_MANUAL;
+
+    return nType;
+}
+
+ScBreakType ScDocument::HasColBreak(SCCOL nCol, SCTAB nTab) const
+{
+    ScBreakType nType = BREAK_NONE;
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return nType;
+
+    if (pTab[nTab]->HasColPageBreak(nCol))
+        nType |= BREAK_PAGE;
+
+    if (pTab[nTab]->HasColManualBreak(nCol))
+        nType |= BREAK_MANUAL;
+
+    return nType;
+}
+
+void ScDocument::SetRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return;
+
+    pTab[nTab]->SetRowBreak(nRow, bPage, bManual);
+}
+
+void ScDocument::SetColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return;
+
+    pTab[nTab]->SetColBreak(nCol, bPage, bManual);
+}
+
+void ScDocument::RemoveRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return;
+
+    pTab[nTab]->RemoveRowBreak(nRow, bPage, bManual);
+}
+
+void ScDocument::RemoveColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return;
+
+    pTab[nTab]->RemoveColBreak(nCol, bPage, bManual);
+}
+
+Sequence<TablePageBreakData> ScDocument::GetRowBreakData(SCTAB nTab) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return Sequence<TablePageBreakData>();
+
+    return pTab[nTab]->GetRowBreakData();
+}
+
+void ScDocument::SyncColRowFlags()
+{
+    for (SCTAB i = 0; i <= nMaxTableNumber; ++i)
+    {
+        if (!ValidTab(i) || !pTab[i])
+            continue;
+
+        pTab[i]->SyncColRowFlags();
+    }
+}
 
 SCROW ScDocument::GetLastFlaggedRow( SCTAB nTab ) const
 {
@@ -4815,6 +4915,11 @@ void ScDocument::SetRepeatArea( SCTAB nTab, SCCOL nStartCol, SCCOL nEndCol, SCRO
         pTab[nTab]->SetRepeatArea( nStartCol, nEndCol, nStartRow, nEndRow );
 }
 
+void ScDocument::InvalidatePageBreaks(SCTAB nTab)
+{
+    if (ValidTab(nTab) && pTab[nTab])
+        pTab[nTab]->InvalidatePageBreaks();
+}
 
 void ScDocument::UpdatePageBreaks( SCTAB nTab, const ScRange* pUserArea )
 {
diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
index 8b34889..519e8f2 100644
--- sc/source/core/data/table1.cxx
+++ sc/source/core/data/table1.cxx
@@ -154,7 +154,8 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
     pScenarioRanges( NULL ),
     aScenarioColor( COL_LIGHTGRAY ),
     nScenarioFlags( 0 ),
-    bActiveScenario( FALSE )
+    bActiveScenario( FALSE ),
+    mbPageBreaksValid(false)
 {
 
     if (bColInfo)
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index b710be8..c66b933 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -134,6 +134,8 @@ void ScTable::InsertRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
     for (SCCOL j=nStartCol; j<=nEndCol; j++)
         aCol[j].InsertRow( nStartRow, nSize );
     DecRecalcLevel( false );
+
+    InvalidatePageBreaks();
 }
 
 
@@ -161,6 +163,8 @@ void ScTable::DeleteRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
             aCol[j].DeleteRow( nStartRow, nSize );
     }
     DecRecalcLevel();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -227,6 +231,8 @@ void ScTable::InsertCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
         }
     }
     DecRecalcLevel();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -269,6 +275,8 @@ void ScTable::DeleteCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
             aCol[nStartCol + nSize + i].MoveTo(nStartRow, nEndRow, aCol[nStartCol + i]);
     }
     DecRecalcLevel();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -642,29 +650,39 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                 if (bWidth)
                     for (SCCOL i=nCol1; i<=nCol2; i++)
                     {
-                        BOOL bChange = pCharts &&
-                            ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+                        bool bHiddenChange = ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+                        bool bChange = bHiddenChange || (pDestTab->pColWidth[i] != pColWidth[i]);
                         pDestTab->pColWidth[i] = pColWidth[i];
                         pDestTab->pColFlags[i] = pColFlags[i];
                         //!	Aenderungen zusammenfassen?
-                        if (bChange)
+                        if (bHiddenChange && pCharts)
                             pCharts->SetRangeDirty(ScRange( i, 0, nTab, i, MAXROW, nTab ));
+
+                        if (bChange)
+                            pDestTab->InvalidatePageBreaks();
                     }
 
                 if (bHeight)
                 {
+                    bool bChange = pDestTab->pRowHeight->SumValues(nRow1, nRow2) != pRowHeight->SumValues(nRow1, nRow2);
+
+                    if (bChange)
+                        pDestTab->InvalidatePageBreaks();
+
                     pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
                     for (SCROW i=nRow1; i<=nRow2; i++)
                     {
                         // TODO: might need some performance improvement, block
                         // operations instead of single GetValue()/SetValue() calls.
                         BYTE nThisRowFlags = pRowFlags->GetValue(i);
-                        BOOL bChange = pCharts &&
-                            ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
+                        bool bHiddenChange = ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
                         pDestTab->pRowFlags->SetValue( i, nThisRowFlags );
                         //!	Aenderungen zusammenfassen?
-                        if (bChange)
+                        if (bHiddenChange && pCharts)
                             pCharts->SetRangeDirty(ScRange( 0, i, nTab, MAXCOL, i, nTab ));
+
+                        if (bHiddenChange)
+                            pDestTab->InvalidatePageBreaks();
                     }
                 }
                 pDestTab->DecRecalcLevel();
@@ -715,6 +733,16 @@ void ScTable::CopyUpdated( const ScTable* pPosTab, ScTable* pDestTab ) const
         aCol[i].CopyUpdated( pPosTab->aCol[i], pDestTab->aCol[i] );
 }
 
+void ScTable::InvalidateTableArea()
+{
+    bTableAreaValid = FALSE;
+}
+
+void ScTable::InvalidatePageBreaks()
+{
+    mbPageBreaksValid = false;
+}
+
 void ScTable::CopyScenarioTo( ScTable* pDestTab ) const
 {
     DBG_ASSERT( bScenario, "bScenario == FALSE" );
@@ -1947,6 +1975,8 @@ void ScTable::SetColWidth( SCCOL nCol, USHORT nNewWidth )
                 pDrawLayer->WidthChanged( nTab, nCol, ((long) nNewWidth) - (long) pColWidth[nCol] );
             pColWidth[nCol] = nNewWidth;
             DecRecalcLevel();
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -1976,6 +2006,8 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
                 pDrawLayer->HeightChanged( nTab, nRow, ((long) nNewHeight) - (long) nOldHeight );
             pRowHeight->SetValue( nRow, nNewHeight);
             DecRecalcLevel();
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -2075,6 +2107,9 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
             pRowHeight->SetValue( nStartRow, nEndRow, nNewHeight);
         }
         DecRecalcLevel();
+
+        if (bChanged)
+            InvalidatePageBreaks();
     }
     else
     {
@@ -2314,6 +2349,8 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
             ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
             if ( pCharts )
                 pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -2358,6 +2395,8 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
 
             if (pOutlineTable)
                 UpdateOutlineRow( nRow, nRow, bShow );
+
+            InvalidatePageBreaks();
         }
     }
     else
@@ -2452,6 +2491,8 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
             if ( pCharts )
                 pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
+
+            InvalidatePageBreaks();
         }
 
         nStartRow = nEndRow + 1;
@@ -2526,7 +2567,7 @@ SCROW ScTable::GetLastFlaggedRow() const
     if ( !pRowFlags )
         return 0;
 
-    SCROW nLastFound = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    SCROW nLastFound = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(CR_ALL) );
     return ValidRow(nLastFound) ? nLastFound : 0;
 }
 
@@ -2538,7 +2579,7 @@ SCCOL ScTable::GetLastChangedCol() const
 
     SCCOL nLastFound = 0;
     for (SCCOL nCol = 1; nCol <= MAXCOL; nCol++)
-        if ((pColFlags[nCol] & ~CR_PAGEBREAK) || (pColWidth[nCol] != STD_COL_WIDTH))
+        if ((pColFlags[nCol] & CR_ALL) || (pColWidth[nCol] != STD_COL_WIDTH))
             nLastFound = nCol;
 
     return nLastFound;
@@ -2550,7 +2591,7 @@ SCROW ScTable::GetLastChangedRow() const
     if ( !pRowFlags )
         return 0;
 
-    SCROW nLastFlags = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    SCROW nLastFlags = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(CR_ALL) );
     if (!ValidRow(nLastFlags))
         nLastFlags = 0;
 
diff --git sc/source/core/data/table3.cxx sc/source/core/data/table3.cxx
index 6f274e4..1557922 100644
--- sc/source/core/data/table3.cxx
+++ sc/source/core/data/table3.cxx
@@ -768,7 +768,7 @@ void ScTable::RemoveSubTotals( ScSubTotalParam& rParam )
             if ( pCell->GetCellType() == CELLTYPE_FORMULA )
                 if (((ScFormulaCell*)pCell)->IsSubTotal())
                 {
-                    SetRowFlags(nRow+1,GetRowFlags(nRow+1)&(~CR_MANUALBREAK));
+                    RemoveRowBreak(nRow+1, false, true);
                     pDocument->DeleteRow( 0,nTab, MAXCOL,nTab, nRow, 1 );
                     --nEndRow;
                     aIter = ScColumnIterator( &aCol[nCol],nRow,nEndRow );
@@ -936,9 +936,7 @@ BOOL ScTable::DoSubTotals( ScSubTotalParam& rParam )
                     bBlockVis = FALSE;
                     if ( rParam.bPagebreak && nRow < MAXROW &&
                             aRowEntry.nSubStartRow != nStartRow && nLevel == 0)
-                        SetRowFlags( aRowEntry.nSubStartRow,
-                                GetRowFlags(aRowEntry.nSubStartRow) |
-                                CR_MANUALBREAK);
+                        SetRowBreak(aRowEntry.nSubStartRow, false, true);
 
                     if (bSpaceLeft)
                     {
diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
index 42354fb..f87bfd3 100644
--- sc/source/core/data/table5.cxx
+++ sc/source/core/data/table5.cxx
@@ -50,8 +50,13 @@
 #include "brdcst.hxx"
 #include "tabprotection.hxx"
 #include "globstr.hrc"
+#include <com/sun/star/sheet/TablePageBreakData.hpp>
+
+#include <algorithm>
 
 using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::sheet::TablePageBreakData;
+using ::std::set;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -65,6 +70,9 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     if ( !pUserArea && !bPageSizeValid )
         return;
 
+    if (mbPageBreaksValid)
+        return;
+
     SfxStyleSheetBase* pStyle = pDocument->GetStyleSheetPool()->
                                     Find( aPageStyle, SFX_STYLE_FAMILY_PAGE );
     if ( !pStyle )
@@ -76,7 +84,6 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     const SfxPoolItem* pItem;
 
     SCCOL nX;
-    SCROW nY;
     SCCOL nStartCol = 0;
     SCROW nStartRow = 0;
     SCCOL nEndCol = MAXCOL;
@@ -96,8 +103,9 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
             //	bei mehreren Bereichen nichts anzeigen:
 
             for (nX=0; nX<MAXCOL; nX++)
-                pColFlags[nX] &= ~CR_PAGEBREAK;
-            pRowFlags->AndValue( 0, MAXROW-1, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+                RemoveColBreak(nX, true, false);
+
+            RemoveRowPageBreaks(0, MAXROW-1);
 
             return;
         }
@@ -141,13 +149,13 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
         //	Anfang: Breaks loeschen
 
     for (nX=0; nX<nStartCol; nX++)
-        pColFlags[nX] &= ~CR_PAGEBREAK;
-    pRowFlags->AndValue( 0, nStartRow-1, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+        RemoveColBreak(nX, true, false);
+    RemoveRowPageBreaks(0, nStartRow-1);
 
     if (nStartCol > 0)
-        pColFlags[nStartCol] |= CR_PAGEBREAK;			//! AREABREAK
+        SetColBreak(nStartCol, true, false);  // AREABREAK
     if (nStartRow > 0)
-        pRowFlags->OrValue( nStartRow, CR_PAGEBREAK);			//! AREABREAK
+        SetRowBreak(nStartRow, true, false);  // AREABREAK
 
         //	Mittelteil: Breaks verteilen
 
@@ -158,14 +166,15 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     {
         BOOL bStartOfPage = FALSE;
         long nThisX = ( pColFlags[nX] & CR_HIDDEN ) ? 0 : pColWidth[nX];
-        if ( (nSizeX+nThisX > nPageSizeX) || ((pColFlags[nX] & CR_MANUALBREAK) && !bSkipBreaks) )
+        bool bManualBreak = HasColManualBreak(nX);
+        if ( (nSizeX+nThisX > nPageSizeX) || (bManualBreak && !bSkipBreaks) )
         {
-            pColFlags[nX] |= CR_PAGEBREAK;
+            SetColBreak(nX, true, false);
             nSizeX = 0;
             bStartOfPage = TRUE;
         }
         else if (nX != nStartCol)
-            pColFlags[nX] &= ~CR_PAGEBREAK;
+            RemoveColBreak(nX, true, false);
         else
             bStartOfPage = TRUE;
 
@@ -175,7 +184,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
             for (SCCOL i=nRepeatStartX; i<=nRepeatEndX; i++)
                 nPageSizeX -= ( pColFlags[i] & CR_HIDDEN ) ? 0 : pColWidth[i];
             while (nX<=nRepeatEndX)
-                pColFlags[++nX] &= ~CR_PAGEBREAK;
+                RemoveColBreak(++nX, true, false);
             bColFound = TRUE;
         }
 
@@ -183,23 +192,21 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     }
 
     // Remove all page breaks in range.
-    pRowFlags->AndValue( nStartRow+1, nEndRow, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    RemoveRowPageBreaks(nStartRow+1, nEndRow);
+
     // And set new page breaks.
     BOOL bRepeatRow = ( nRepeatStartY != SCROW_REPEAT_NONE );
     BOOL bRowFound = FALSE;
     long nSizeY = 0;
-    ScCompressedArrayIterator< SCROW, BYTE> aFlagsIter( *pRowFlags, nStartRow, nEndRow);
-    ScCompressedArrayIterator< SCROW, USHORT> aHeightIter( *pRowHeight, nStartRow, nEndRow);
-    for ( ; aFlagsIter; ++aFlagsIter, ++aHeightIter)
+    for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
     {
-        nY = aFlagsIter.GetPos();
         BOOL bStartOfPage = FALSE;
-        BYTE nFlags = *aFlagsIter;
-        long nThisY = (nFlags & CR_HIDDEN) ? 0 : *aHeightIter;
-        if ( (nSizeY+nThisY > nPageSizeY) || ((nFlags & CR_MANUALBREAK) && !bSkipBreaks) )
+        BYTE nFlags = pRowFlags->GetValue(nY);
+        long nThisY = (nFlags & CR_HIDDEN) ? 0 : pRowHeight->GetValue(nY);
+        bool bManualBreak = HasRowManualBreak(nY);
+        if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
         {
-            pRowFlags->SetValue( nY, nFlags | CR_PAGEBREAK);
-            aFlagsIter.Resync( nY);
+            SetRowBreak(nY, true, false);
             nSizeY = 0;
             bStartOfPage = TRUE;
         }
@@ -219,12 +226,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 #endif
             nPageSizeY -= nHeights;
             if (nY <= nRepeatEndY)
-            {
-                pRowFlags->AndValue( nY, nRepeatEndY, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
-                nY = nRepeatEndY + 1;
-                aFlagsIter.Resync( nY);
-                aHeightIter.Resync( nY);
-            }
+                RemoveRowPageBreaks(nY, nRepeatEndY);
             bRowFound = TRUE;
         }
 
@@ -235,26 +237,24 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 
     if (nEndCol < MAXCOL)
     {
-        pColFlags[nEndCol+1] |= CR_PAGEBREAK;			//! AREABREAK
+        SetColBreak(nEndCol+1, true, false);  // AREABREAK
         for (nX=nEndCol+2; nX<=MAXCOL; nX++)
-            pColFlags[nX] &= ~CR_PAGEBREAK;
+            RemoveColBreak(nX, true, false);
     }
     if (nEndRow < MAXROW)
     {
-        pRowFlags->OrValue( nEndRow+1, CR_PAGEBREAK);			//! AREABREAK
+        SetRowBreak(nEndRow+1, true, false);  // AREABREAK
         if (nEndRow+2 <= MAXROW)
-            pRowFlags->AndValue( nEndRow+2, MAXROW, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+            RemoveRowPageBreaks(nEndRow+2, MAXROW);
     }
+    mbPageBreaksValid = true;
 }
 
 void ScTable::RemoveManualBreaks()
 {
-    if (pColFlags)
-        for (SCCOL nCol = 0; nCol <= MAXCOL; nCol++)
-            pColFlags[nCol] &= ~CR_MANUALBREAK;
-
-    if (pRowFlags)
-        pRowFlags->AndValue( 0, MAXROW, sal::static_int_cast<BYTE>(~CR_MANUALBREAK) );
+    maRowManualBreaks.clear();
+    maColManualBreaks.clear();
+    InvalidatePageBreaks();
 
     if (IsStreamValid())
         SetStreamValid(FALSE);
@@ -262,22 +262,192 @@ void ScTable::RemoveManualBreaks()
 
 BOOL ScTable::HasManualBreaks() const
 {
-    if (pColFlags)
-        for (SCCOL nCol = 0; nCol <= MAXCOL; nCol++)
-            if ( pColFlags[nCol] & CR_MANUALBREAK )
-                return TRUE;
+    return !maRowManualBreaks.empty() || !maColManualBreaks.empty();
+}
+
+void ScTable::GetAllRowBreaks(set<SCROW>& rBreaks, bool bPage, bool bManual) const
+{
+    if (bPage)
+        rBreaks = maRowPageBreaks;
+
+    if (bManual)
+    {
+        using namespace std;
+        copy(maRowManualBreaks.begin(), maRowManualBreaks.end(), inserter(rBreaks, rBreaks.begin()));
+    }
+}
+
+void ScTable::GetAllColBreaks(set<SCCOL>& rBreaks, bool bPage, bool bManual) const
+{
+    if (bPage)
+        rBreaks = maColPageBreaks;
+
+    if (bManual)
+    {
+        using namespace std;
+        copy(maColManualBreaks.begin(), maColManualBreaks.end(), inserter(rBreaks, rBreaks.begin()));
+    }
+}
 
-    if (pRowFlags)
-        if (ValidRow( pRowFlags->GetLastAnyBitAccess( 0, CR_MANUALBREAK)))
-            return TRUE;
+bool ScTable::HasRowPageBreak(SCROW nRow) const
+{
+    if (!ValidRow(nRow))
+        return false;
 
-    return FALSE;
+    return maRowPageBreaks.count(nRow) > 0;
+}
+
+bool ScTable::HasColPageBreak(SCCOL nCol) const
+{
+    if (!ValidCol(nCol))
+        return false;
+
+    return maColPageBreaks.count(nCol) > 0;
+}
+
+bool ScTable::HasRowManualBreak(SCROW nRow) const
+{
+    if (!ValidRow(nRow))
+        return false;
+
+    return maRowManualBreaks.count(nRow) > 0;
+}
+
+bool ScTable::HasColManualBreak(SCCOL nCol) const
+{
+    if (!ValidCol(nCol))
+        return false;
+
+    return (maColManualBreaks.count(nCol) > 0);
+}
+
+void ScTable::RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow)
+{
+    using namespace std;
+
+    if (!ValidRow(nStartRow) || !ValidRow(nEndRow))
+        return;
+
+    set<SCROW>::iterator low  = maRowPageBreaks.lower_bound(nStartRow);
+    set<SCROW>::iterator high = maRowPageBreaks.upper_bound(nEndRow);
+    maRowPageBreaks.erase(low, high);
+}
+
+void ScTable::RemoveRowBreak(SCROW nRow, bool bPage, bool bManual)
+{
+    if (!ValidRow(nRow))
+        return;
+
+    if (bPage)
+        maRowPageBreaks.erase(nRow);
+
+    if (bManual)
+    {
+        maRowManualBreaks.erase(nRow);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::RemoveColBreak(SCCOL nCol, bool bPage, bool bManual)
+{
+    if (!ValidCol(nCol))
+        return;
+
+    if (bPage)
+        maColPageBreaks.erase(nCol);
+
+    if (bManual)
+    {
+        maColManualBreaks.erase(nCol);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::SetRowBreak(SCROW nRow, bool bPage, bool bManual)
+{
+    if (!ValidRow(nRow))
+        return;
+
+    if (bPage)
+        maRowPageBreaks.insert(nRow);
+
+    if (bManual)
+    {
+        maRowManualBreaks.insert(nRow);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::SetColBreak(SCCOL nCol, bool bPage, bool bManual)
+{
+    if (!ValidCol(nCol))
+        return;
+
+    if (bPage)
+        maColPageBreaks.insert(nCol);
+
+    if (bManual)
+    {
+        maColManualBreaks.insert(nCol);
+        InvalidatePageBreaks();
+    }
+}
+
+Sequence<TablePageBreakData> ScTable::GetRowBreakData() const
+{
+    using ::std::copy;
+    using ::std::inserter;
+
+    set<SCROW> aRowBreaks = maRowPageBreaks;
+    copy(maRowManualBreaks.begin(), maRowManualBreaks.end(), inserter(aRowBreaks, aRowBreaks.begin()));
+
+    set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end();
+    Sequence<TablePageBreakData> aSeq(aRowBreaks.size());
+
+    for (sal_Int32 i = 0; itr != itrEnd; ++itr, ++i)
+    {
+        SCROW nRow = *itr;
+        TablePageBreakData aData;
+        aData.Position = nRow;
+        aData.ManualBreak = HasRowManualBreak(nRow);
+        aSeq[i] = aData;
+    }
+
+    return aSeq;
+}
+
+void ScTable::SyncColRowFlags()
+{
+    using ::sal::static_int_cast;
+
+    // For now, we only need to sync the manual breaks.
+
+    pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~CR_MANUALBREAK));
+    for (SCCOL i = 0; i <= MAXCOL; ++i)
+        pColFlags[i] &= static_int_cast<BYTE>(~CR_MANUALBREAK);
+
+    if (!maRowManualBreaks.empty())
+    {
+        for (set<SCROW>::const_iterator itr = maRowManualBreaks.begin(), itrEnd = maRowManualBreaks.end();
+              itr != itrEnd; ++itr)
+            pRowFlags->OrValue(*itr, static_int_cast<BYTE>(CR_MANUALBREAK));
+    }
+
+    if (!maColManualBreaks.empty())
+    {
+        for (set<SCCOL>::const_iterator itr = maColManualBreaks.begin(), itrEnd = maColManualBreaks.end();
+              itr != itrEnd; ++itr)
+            pColFlags[*itr] |= CR_MANUALBREAK;
+    }
 }
 
 void ScTable::SetPageSize( const Size& rSize )
 {
     if ( rSize.Width() != 0 && rSize.Height() != 0 )
     {
+        if (aPageSizeTwips != rSize)
+            InvalidatePageBreaks();
+
         bPageSizeValid = TRUE;
         aPageSizeTwips = rSize;
     }
diff --git sc/source/filter/excel/xepage.cxx sc/source/filter/excel/xepage.cxx
index 74dd75d..d6c48b4 100644
--- sc/source/filter/excel/xepage.cxx
+++ sc/source/filter/excel/xepage.cxx
@@ -45,9 +45,14 @@
 #include "xehelper.hxx"
 #include "xeescher.hxx"
 
+#include <set>
+#include <limits>
+
 #include <oox/core/tokens.hxx>
 
 using ::rtl::OString;
+using ::std::set;
+using ::std::numeric_limits;
 
 // Page settings records ======================================================
 
@@ -299,17 +304,23 @@ XclExpPageSettings::XclExpPageSettings( const XclExpRoot& rRoot ) :
 
     // *** page breaks ***
 
-    ScCompressedArrayIterator< SCROW, BYTE> aIter( rDoc.GetRowFlagsArray( nScTab), 1, GetMaxPos().Row());
-    do
+    set<SCROW> aRowBreaks;
+    rDoc.GetAllRowBreaks(aRowBreaks, nScTab, false, true);
+
+    SCROW nMaxRow = numeric_limits<sal_uInt16>::max();
+    for (set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end(); itr != itrEnd; ++itr)
     {
-        if (*aIter & CR_MANUALBREAK)
-            for (SCROW j=aIter.GetRangeStart(); j<=aIter.GetRangeEnd(); ++j)
-                maData.maHorPageBreaks.push_back( static_cast< sal_uInt16 >( j ) );
-    } while (aIter.NextRange());
-
-    for( SCCOL nScCol = 1, nScMaxCol = GetMaxPos().Col(); nScCol <= nScMaxCol; ++nScCol )
-        if( rDoc.GetColFlags( nScCol, nScTab ) & CR_MANUALBREAK )
-            maData.maVerPageBreaks.push_back( static_cast< sal_uInt16 >( nScCol ) );
+        SCROW nRow = *itr;
+        if (nRow > nMaxRow)
+            break;
+
+        maData.maHorPageBreaks.push_back(nRow);
+    }
+
+    set<SCCOL> aColBreaks;
+    rDoc.GetAllColBreaks(aColBreaks, nScTab, false, true);
+    for (set<SCCOL>::const_iterator itr = aColBreaks.begin(), itrEnd = aColBreaks.end(); itr != itrEnd; ++itr)
+        maData.maVerPageBreaks.push_back(*itr);
 }
 
 static void lcl_WriteHeaderFooter( XclExpXmlStream& rStrm )
diff --git sc/source/filter/excel/xipage.cxx sc/source/filter/excel/xipage.cxx
index 7013d40..2803d00 100644
--- sc/source/filter/excel/xipage.cxx
+++ sc/source/filter/excel/xipage.cxx
@@ -375,14 +375,14 @@ void XclImpPageSettings::Finalize()
     {
         SCROW nScRow = static_cast< SCROW >( *aIt );
         if( nScRow <= MAXROW )
-            rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetRowBreak(nScRow, nScTab, false, true);
     }
 
     for( aIt = maData.maVerPageBreaks.begin(), aEnd = maData.maVerPageBreaks.end(); aIt != aEnd; ++aIt )
     {
         SCCOL nScCol = static_cast< SCCOL >( *aIt );
         if( nScCol <= MAXCOL )
-            rDoc.SetColFlags( nScCol, nScTab, rDoc.GetColFlags( nScCol, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetColBreak(nScCol, nScTab, false, true);
     }
 }
 
diff --git sc/source/filter/starcalc/scflt.cxx sc/source/filter/starcalc/scflt.cxx
index f5ab9af..f653756 100644
--- sc/source/filter/starcalc/scflt.cxx
+++ sc/source/filter/starcalc/scflt.cxx
@@ -1549,13 +1549,15 @@ void Sc10Import::LoadTables()
             if (DataValue != 0)
             {
                 BYTE nFlags = 0;
-                if ((DataValue & crfSoftBreak) == crfSoftBreak)
-                    nFlags |= CR_PAGEBREAK;
-                if ((DataValue & crfHardBreak) == crfHardBreak)
-                    nFlags |= CR_MANUALBREAK;
+                bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
+                bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
                 if ((DataValue & crfHidden) == crfHidden)
                     nFlags |= CR_HIDDEN;
-                for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++) pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+                for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++)
+                {
+                    pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetColBreak(k, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
+                }
             }
             DataStart = DataEnd + 1;
         }
@@ -1599,13 +1601,15 @@ void Sc10Import::LoadTables()
             if (DataValue != 0)
             {
                 BYTE nFlags = 0;
-                if ((DataValue & crfSoftBreak) == crfSoftBreak)
-                    nFlags |= CR_PAGEBREAK;
-                if ((DataValue & crfHardBreak) == crfHardBreak)
-                    nFlags |= CR_MANUALBREAK;
+                bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
+                bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
                 if ((DataValue & crfHidden) == crfHidden)
                     nFlags |= CR_HIDDEN;
-                for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++) pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++)
+                {
+                    pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetRowBreak(l, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
+                }
             }
             DataStart = DataEnd + 1;
         }
diff --git sc/source/filter/xml/xmlexprt.cxx sc/source/filter/xml/xmlexprt.cxx
index b8f4b3e..a0c0580 100644
--- sc/source/filter/xml/xmlexprt.cxx
+++ sc/source/filter/xml/xmlexprt.cxx
@@ -2556,6 +2556,7 @@ void ScXMLExport::_ExportAutoStyles()
                             {
                                 if (pDoc)
                                 {
+                                    pDoc->SyncColRowFlags();
                                     uno::Reference<table::XTableColumns> xTableColumns(xColumnRowRange->getColumns());
                                     if (xTableColumns.is())
                                     {
diff --git sc/source/ui/docshell/dbdocfun.cxx sc/source/ui/docshell/dbdocfun.cxx
index 7c98088..7e48ad5 100644
--- sc/source/ui/docshell/dbdocfun.cxx
+++ sc/source/ui/docshell/dbdocfun.cxx
@@ -937,7 +937,10 @@ BOOL ScDBDocFunc::Query( SCTAB nTab, const ScQueryParam& rQueryParam,
     }
 
     if (!bCopy)
+    {
+        pDoc->InvalidatePageBreaks(nTab);
         pDoc->UpdatePageBreaks( nTab );
+    }
 
     // #i23299# because of Subtotal functions, the whole rows must be set dirty
     ScRange aDirtyRange( 0 , aLocalParam.nRow1, nDestTab,
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index aa291ab..174a889 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -3209,20 +3209,22 @@ BOOL ScDocFunc::InsertPageBreak( BOOL bColumn, const ScAddress& rPos,
     if (nPos == 0)
         return FALSE;					// erste Spalte / Zeile
 
-    BYTE nFlags = bColumn ? pDoc->GetColFlags( static_cast<SCCOL>(nPos), nTab )
-        : pDoc->GetRowFlags( static_cast<SCROW>(nPos), nTab );
-    if (nFlags & CR_MANUALBREAK)
-        return TRUE;					// Umbruch schon gesetzt
+    ScBreakType nBreak = bColumn ?
+        pDoc->HasColBreak(static_cast<SCCOL>(nPos), nTab) :
+        pDoc->HasRowBreak(static_cast<SCROW>(nPos), nTab);
+    if (nBreak & BREAK_MANUAL)
+        return true;
 
     if (bRecord)
         rDocShell.GetUndoManager()->AddUndoAction(
             new ScUndoPageBreak( &rDocShell, rPos.Col(), rPos.Row(), nTab, bColumn, TRUE ) );
 
-    nFlags |= CR_MANUALBREAK;
     if (bColumn)
-        pDoc->SetColFlags( static_cast<SCCOL>(nPos), nTab, nFlags );
+        pDoc->SetColBreak(static_cast<SCCOL>(nPos), nTab, false, true);
     else
-        pDoc->SetRowFlags( static_cast<SCROW>(nPos), nTab, nFlags );
+        pDoc->SetRowBreak(static_cast<SCROW>(nPos), nTab, false, true);
+
+    pDoc->InvalidatePageBreaks(nTab);
     pDoc->UpdatePageBreaks( nTab );
 
     if (pDoc->IsStreamValid(nTab))
@@ -3268,20 +3270,25 @@ BOOL ScDocFunc::RemovePageBreak( BOOL bColumn, const ScAddress& rPos,
 
     SCCOLROW nPos = bColumn ? static_cast<SCCOLROW>(rPos.Col()) :
         static_cast<SCCOLROW>(rPos.Row());
-    BYTE nFlags = bColumn ? pDoc->GetColFlags( static_cast<SCCOL>(nPos), nTab )
-        : pDoc->GetRowFlags( static_cast<SCROW>(nPos), nTab );
-    if ((nFlags & CR_MANUALBREAK)==0)
-        return FALSE;							// kein Umbruch gesetzt
+
+    ScBreakType nBreak;
+    if (bColumn)
+        nBreak = pDoc->HasColBreak(static_cast<SCCOL>(nPos), nTab);
+    else
+        nBreak = pDoc->HasRowBreak(static_cast<SCROW>(nPos), nTab);
+    if ((nBreak & BREAK_MANUAL) == 0)
+        // There is no manual break.
+        return false;
 
     if (bRecord)
         rDocShell.GetUndoManager()->AddUndoAction(
             new ScUndoPageBreak( &rDocShell, rPos.Col(), rPos.Row(), nTab, bColumn, FALSE ) );
 
-    nFlags &= ~CR_MANUALBREAK;
     if (bColumn)
-        pDoc->SetColFlags( static_cast<SCCOL>(nPos), nTab, nFlags );
+        pDoc->RemoveColBreak(static_cast<SCCOL>(nPos), nTab, false, true);
     else
-        pDoc->SetRowFlags( static_cast<SCROW>(nPos), nTab, nFlags );
+        pDoc->RemoveRowBreak(static_cast<SCROW>(nPos), nTab, false, true);
+
     pDoc->UpdatePageBreaks( nTab );
 
     if (pDoc->IsStreamValid(nTab))
diff --git sc/source/ui/docshell/olinefun.cxx sc/source/ui/docshell/olinefun.cxx
index b1f8d5a..14a1d1d 100644
--- sc/source/ui/docshell/olinefun.cxx
+++ sc/source/ui/docshell/olinefun.cxx
@@ -701,6 +701,7 @@ BOOL ScOutlineDocFunc::ShowOutline( SCTAB nTab, BOOL bColumns, USHORT nLevel, US
 
     pArray->SetVisibleBelow( nLevel, nEntry, TRUE, TRUE );
 
+    pDoc->InvalidatePageBreaks(nTab);
     pDoc->UpdatePageBreaks( nTab );
 
     if (bPaint)
@@ -766,6 +767,7 @@ BOOL ScOutlineDocFunc::HideOutline( SCTAB nTab, BOOL bColumns, USHORT nLevel, US
 
     pArray->SetVisibleBelow( nLevel, nEntry, FALSE );
 
+    pDoc->InvalidatePageBreaks(nTab);
     pDoc->UpdatePageBreaks( nTab );
 
     if (bPaint)
diff --git sc/source/ui/undo/undocell.cxx sc/source/ui/undo/undocell.cxx
index d2260b9..dd0c15a 100644
--- sc/source/ui/undo/undocell.cxx
+++ sc/source/ui/undo/undocell.cxx
@@ -584,6 +584,8 @@ void ScUndoPageBreak::DoChange( BOOL bInsertP ) const
             pViewShell->InsertPageBreak(bColumn, FALSE);
         else
             pViewShell->DeletePageBreak(bColumn, FALSE);
+
+        pDocShell->GetDocument()->InvalidatePageBreaks(nTab);
     }
 }
 
diff --git sc/source/ui/undo/undodat.cxx sc/source/ui/undo/undodat.cxx
index 0bad7c8..85d5ede 100644
--- sc/source/ui/undo/undodat.cxx
+++ sc/source/ui/undo/undodat.cxx
@@ -1027,7 +1027,10 @@ void __EXPORT ScUndoQuery::Undo()
         pDoc->SetDBCollection( new ScDBCollection( *pUndoDB ), TRUE );
 
     if (!bCopy)
+    {
+        pDoc->InvalidatePageBreaks(nTab);
         pDoc->UpdatePageBreaks( nTab );
+    }
 
     ScRange aDirtyRange( 0 , aQueryParam.nRow1, nTab,
         MAXCOL, aQueryParam.nRow2, nTab );
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index 246d078..ca554f0 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -7053,7 +7053,7 @@ uno::Sequence<sheet::TablePageBreakData> SAL_CALL ScTableSheetObj::getColumnPage
         SCCOL nCount = 0;
         SCCOL nCol;
         for (nCol=0; nCol<=MAXCOL; nCol++)
-            if (pDoc->GetColFlags( nCol, nTab ) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+            if (pDoc->HasColBreak(nCol, nTab))
                 ++nCount;
 
         sheet::TablePageBreakData aData;
@@ -7062,11 +7062,11 @@ uno::Sequence<sheet::TablePageBreakData> SAL_CALL ScTableSheetObj::getColumnPage
         USHORT nPos = 0;
         for (nCol=0; nCol<=MAXCOL; nCol++)
         {
-            BYTE nFlags = pDoc->GetColFlags( nCol, nTab );
-            if (nFlags & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            if (nBreak)
             {
                 aData.Position	  = nCol;
-                aData.ManualBreak = ( nFlags & CR_MANUALBREAK ) != 0;
+                aData.ManualBreak = (nBreak & BREAK_MANUAL);
                 pAry[nPos] = aData;
                 ++nPos;
             }
@@ -7095,33 +7095,7 @@ uno::Sequence<sheet::TablePageBreakData> SAL_CALL ScTableSheetObj::getRowPageBre
             ScPrintFunc aPrintFunc( pDocSh, pDocSh->GetPrinter(), nTab );
             aPrintFunc.UpdatePages();
         }
-
-        SCROW nCount = pDoc->GetRowFlagsArray( nTab).CountForAnyBitCondition(
-                0, MAXROW, (CR_PAGEBREAK | CR_MANUALBREAK));
-
-        uno::Sequence<sheet::TablePageBreakData> aSeq(nCount);
-        if (nCount)
-        {
-            sheet::TablePageBreakData aData;
-            sheet::TablePageBreakData* pAry = aSeq.getArray();
-            size_t nPos = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray( nTab), 0, MAXROW);
-            do
-            {
-                BYTE nFlags = *aIter;
-                if (nFlags & ( CR_PAGEBREAK | CR_MANUALBREAK ))
-                {
-                    for (SCROW nRow = aIter.GetRangeStart(); nRow <= aIter.GetRangeEnd(); ++nRow)
-                    {
-                        aData.Position	  = nRow;
-                        aData.ManualBreak = ( nFlags & CR_MANUALBREAK ) != 0;
-                        pAry[nPos] = aData;
-                        ++nPos;
-                    }
-                }
-            } while (aIter.NextRange());
-        }
-        return aSeq;
+        return pDoc->GetRowBreakData(nTab);
     }
     return uno::Sequence<sheet::TablePageBreakData>(0);
 }
@@ -8890,13 +8864,13 @@ void ScTableColumnObj::GetOnePropertyValue( const SfxItemPropertySimpleEntry* pE
         }
         else if ( pEntry->nWID == SC_WID_UNO_NEWPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetColFlags( nCol, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
         }
         else if ( pEntry->nWID == SC_WID_UNO_MANPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetColFlags( nCol, nTab ) & (CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            ScUnoHelpFunctions::SetBoolInAny(rAny, (nBreak & BREAK_MANUAL));
         }
         else
             ScCellRangeObj::GetOnePropertyValue(pEntry, rAny);
@@ -9054,13 +9028,13 @@ void ScTableRowObj::GetOnePropertyValue( const SfxItemPropertySimpleEntry* pEntr
         }
         else if ( pEntry->nWID == SC_WID_UNO_NEWPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nRow, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasRowBreak(nRow, nTab);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
         }
         else if ( pEntry->nWID == SC_WID_UNO_MANPAGE )
         {
-            BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nRow, nTab ) & (CR_MANUALBREAK)) );
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = (pDoc->HasRowBreak(nRow, nTab) & BREAK_MANUAL);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
         }
         else
             ScCellRangeObj::GetOnePropertyValue(pEntry, rAny);
diff --git sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
index e819fda..661abdd 100644
--- sc/source/ui/unoobj/docuno.cxx
+++ sc/source/ui/unoobj/docuno.cxx
@@ -2951,13 +2951,13 @@ uno::Any SAL_CALL ScTableColumnsObj::getPropertyValue( const rtl::OUString& aPro
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetColFlags( nStartCol, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasColBreak(nStartCol, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, nBreak );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_MANPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetColFlags( nStartCol, nTab ) & (CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasColBreak(nStartCol, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, (nBreak & BREAK_MANUAL) );
     }
 
     return aAny;
@@ -3214,13 +3214,13 @@ uno::Any SAL_CALL ScTableRowsObj::getPropertyValue( const rtl::OUString& aProper
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nStartRow, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasRowBreak(nStartRow, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, nBreak );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_MANPAGE ) )
     {
-        BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nStartRow, nTab ) & (CR_MANUALBREAK)) );
-        ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasRowBreak(nStartRow, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, (nBreak & BREAK_MANUAL) );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLBACK ) || aNameString.EqualsAscii( SC_UNONAME_CELLTRAN ) )
     {
diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
index cec0626..d18aa2a 100644
--- sc/source/ui/vba/vbarange.cxx
+++ sc/source/ui/vba/vbarange.cxx
@@ -3727,16 +3727,16 @@ ScVbaRange::getPageBreak() throw (uno::RuntimeException)
         {
             ScDocument* pDoc =  getDocumentFromRange( mxRange );
             
-            BYTE nFlag = 0;
+            ScBreakType nBreak = BREAK_NONE;
             if ( !bColumn )
-                nFlag = pDoc -> GetRowFlags(thisAddress.StartRow, thisAddress.Sheet);
+                nBreak = pDoc->HasRowBreak(thisAddress.StartRow, thisAddress.Sheet);
             else
-                nFlag = pDoc -> GetColFlags(static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.Sheet);
+                nBreak = pDoc->HasColBreak(thisAddress.StartColumn, thisAddress.Sheet);
                 
-            if ( nFlag & CR_PAGEBREAK)
+            if (nBreak & BREAK_PAGE)
                 nPageBreak = excel::XlPageBreak::xlPageBreakAutomatic;
                 
-            if ( nFlag & CR_MANUALBREAK)
+            if (nBreak & BREAK_MANUAL)
                 nPageBreak = excel::XlPageBreak::xlPageBreakManual;
         }		
     }
diff --git sc/source/ui/view/cellsh.cxx sc/source/ui/view/cellsh.cxx
index c0599be..92082a8 100644
--- sc/source/ui/view/cellsh.cxx
+++ sc/source/ui/view/cellsh.cxx
@@ -715,22 +715,22 @@ void ScCellShell::GetState(SfxItemSet &rSet)
                 break;
 
             case FID_INS_ROWBRK:
-                if ( nPosY==0 || (pDoc->GetRowFlags(nPosY,nTab) & CR_MANUALBREAK) )
+                if ( nPosY==0 || (pDoc->HasRowBreak(nPosY, nTab) & BREAK_MANUAL) )
                     rSet.DisableItem( nWhich );
                 break;
 
             case FID_INS_COLBRK:
-                if ( nPosX==0 || (pDoc->GetColFlags(nPosX,nTab) & CR_MANUALBREAK) )
+                if ( nPosX==0 || (pDoc->HasColBreak(nPosX, nTab) & BREAK_MANUAL) )
                     rSet.DisableItem( nWhich );
                 break;
 
             case FID_DEL_ROWBRK:
-                if ( nPosY==0 || (pDoc->GetRowFlags(nPosY,nTab) & CR_MANUALBREAK)==0 )
+                if ( nPosY==0 || (pDoc->HasRowBreak(nPosY, nTab) & BREAK_MANUAL) == 0 )
                     rSet.DisableItem( nWhich );
                 break;
 
             case FID_DEL_COLBRK:
-                if ( nPosX==0 || (pDoc->GetColFlags(nPosX,nTab) & CR_MANUALBREAK)==0 )
+                if ( nPosX==0 || (pDoc->HasColBreak(nPosX, nTab) & BREAK_MANUAL) == 0 )
                     rSet.DisableItem( nWhich );
                 break;
 
diff --git sc/source/ui/view/gridwin2.cxx sc/source/ui/view/gridwin2.cxx
index 0d90774..7698911 100644
--- sc/source/ui/view/gridwin2.cxx
+++ sc/source/ui/view/gridwin2.cxx
@@ -933,7 +933,7 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
                 BOOL bGrow = !bHide && nNew > nPagebreakBreak;
                 if ( bColumn )
                 {
-                    if ( pDoc->GetColFlags( static_cast<SCCOL>(nPagebreakBreak), nTab ) & CR_MANUALBREAK )
+                    if (pDoc->HasColBreak(static_cast<SCCOL>(nPagebreakBreak), nTab) & BREAK_MANUAL)
                     {
                         ScAddress aOldAddr( static_cast<SCCOL>(nPagebreakBreak), nPosY, nTab );
                         pViewFunc->DeletePageBreak( TRUE, TRUE, &aOldAddr, FALSE );
@@ -946,8 +946,8 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
                     if ( bGrow )
                     {
                         //	vorigen Break auf hart, und Skalierung aendern
-                        if ( static_cast<SCCOL>(nPagebreakPrev) > aPagebreakSource.aStart.Col() &&
-                                !(pDoc->GetColFlags( static_cast<SCCOL>(nPagebreakPrev), nTab ) & CR_MANUALBREAK) )
+                        bool bManualBreak = (pDoc->HasColBreak(static_cast<SCCOL>(nPagebreakPrev), nTab) & BREAK_MANUAL);
+                        if ( static_cast<SCCOL>(nPagebreakPrev) > aPagebreakSource.aStart.Col() && !bManualBreak )
                         {
                             ScAddress aPrev( static_cast<SCCOL>(nPagebreakPrev), nPosY, nTab );
                             pViewFunc->InsertPageBreak( TRUE, TRUE, &aPrev, FALSE );
@@ -960,7 +960,7 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
                 }
                 else
                 {
-                    if ( pDoc->GetRowFlags( nPagebreakBreak, nTab ) & CR_MANUALBREAK )
+                    if (pDoc->HasRowBreak(nPagebreakBreak, nTab) & BREAK_MANUAL)
                     {
                         ScAddress aOldAddr( nPosX, nPagebreakBreak, nTab );
                         pViewFunc->DeletePageBreak( FALSE, TRUE, &aOldAddr, FALSE );
@@ -973,8 +973,8 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
                     if ( bGrow )
                     {
                         //	vorigen Break auf hart, und Skalierung aendern
-                        if ( nPagebreakPrev > aPagebreakSource.aStart.Row() &&
-                                !(pDoc->GetRowFlags( nPagebreakPrev, nTab ) & CR_MANUALBREAK) )
+                        bool bManualBreak = (pDoc->HasRowBreak(nPagebreakPrev, nTab) & BREAK_MANUAL);
+                        if ( nPagebreakPrev > aPagebreakSource.aStart.Row() && !bManualBreak )
                         {
                             ScAddress aPrev( nPosX, nPagebreakPrev, nTab );
                             pViewFunc->InsertPageBreak( FALSE, TRUE, &aPrev, FALSE );
diff --git sc/source/ui/view/gridwin4.cxx sc/source/ui/view/gridwin4.cxx
index 38afff8..acdf175 100644
--- sc/source/ui/view/gridwin4.cxx
+++ sc/source/ui/view/gridwin4.cxx
@@ -1088,7 +1088,7 @@ void ScGridWindow::DrawPagePreview( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
                     if ( nBreak >= nX1 && nBreak <= nX2+1 )
                     {
                         //! hidden suchen
-                        if ( pDoc->GetColFlags( nBreak, nTab ) & CR_MANUALBREAK )
+                        if (pDoc->HasColBreak(nBreak, nTab) & BREAK_MANUAL)
                             pContentDev->SetFillColor( aManual );
                         else
                             pContentDev->SetFillColor( aAutomatic );
@@ -1107,7 +1107,7 @@ void ScGridWindow::DrawPagePreview( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
                     if ( nBreak >= nY1 && nBreak <= nY2+1 )
                     {
                         //! hidden suchen
-                        if ( pDoc->GetRowFlags( nBreak, nTab ) & CR_MANUALBREAK )
+                        if (pDoc->HasRowBreak(nBreak, nTab) & BREAK_MANUAL)
                             pContentDev->SetFillColor( aManual );
                         else
                             pContentDev->SetFillColor( aAutomatic );
diff --git sc/source/ui/view/output.cxx sc/source/ui/view/output.cxx
index 4ad425a..5d3d2d2 100644
--- sc/source/ui/view/output.cxx
+++ sc/source/ui/view/output.cxx
@@ -322,8 +322,9 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
     long nPosX;
     long nPosY;
     SCSIZE nArrY;
-    BYTE nOldFlags = 0;
-    BYTE nFlags;
+    ScBreakType nBreak    = BREAK_NONE;
+    ScBreakType nBreakOld = BREAK_NONE;
+
     BOOL bSingle;
     Color aPageColor;
     Color aManualColor;
@@ -378,27 +379,27 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
             if ( bPage )
             {
                 //	Seitenumbrueche auch in ausgeblendeten suchen
-                nFlags = 0;
                 SCCOL nCol = nXplus1;
                 while (nCol <= MAXCOL)
                 {
                     BYTE nDocFl = pDoc->GetColFlags( nCol, nTab );
-                    nFlags = nDocFl & ( CR_PAGEBREAK | CR_MANUALBREAK );
-                    if ( nFlags || !(nDocFl & CR_HIDDEN) )
+                    nBreak = pDoc->HasColBreak(nCol, nTab);
+
+                    if ( nBreak || !(nDocFl & CR_HIDDEN) )
                         break;
                     ++nCol;
                 }
 
-                if (nFlags != nOldFlags)
+                if (nBreak != nBreakOld)
                 {
                     aGrid.Flush();
-                    pDev->SetLineColor( (nFlags & CR_MANUALBREAK) ? aManualColor :
-                                     (nFlags) ? aPageColor : aGridColor );
-                    nOldFlags = nFlags;
+                    pDev->SetLineColor( (nBreak & BREAK_MANUAL) ? aManualColor :
+                                        nBreak ? aPageColor : aGridColor );
+                    nBreakOld = nBreak;
                 }
             }
 
-            BOOL bDraw = bGrid || nOldFlags;	// einfaches Gitter nur wenn eingestellt
+            BOOL bDraw = bGrid || nBreakOld;	// einfaches Gitter nur wenn eingestellt
 
             //!	Mit dieser Abfrage wird zuviel weggelassen, wenn ein automatischer
             //!	Umbruch mitten in den Wiederholungsspalten liegt.
@@ -409,7 +410,7 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
             {
                 if ( nX == MAXCOL )
                     bDraw = FALSE;
-                else if (pDoc->GetColFlags(nXplus1,nTab) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+                else if (pDoc->HasColBreak(nXplus1, nTab))
                     bDraw = FALSE;
             }
 #endif
@@ -500,28 +501,24 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
         {
             if ( bPage )
             {
-                //	Seitenumbrueche auch in ausgeblendeten suchen
-                nFlags = 0;
-                ScCompressedArrayIterator< SCROW, BYTE > aIter(
-                        pDoc->GetRowFlagsArray( nTab), nYplus1, MAXROW);
-                do
+                for (SCROW i = nYplus1; i <= MAXROW; ++i)
                 {
-                    BYTE nDocFl = *aIter;
-                    nFlags = nDocFl & ( CR_PAGEBREAK | CR_MANUALBREAK );
-                    if ( nFlags || !(nDocFl & CR_HIDDEN) )
+                    nBreak = pDoc->HasRowBreak(i, nTab);
+                    bool bHidden = (pDoc->GetRowFlags(i, nTab) & CR_HIDDEN);
+                    if (nBreak || !bHidden)
                         break;
-                } while (aIter.NextRange());
+                }
 
-                if (nFlags != nOldFlags)
+                if (nBreakOld != nBreak)
                 {
                     aGrid.Flush();
-                    pDev->SetLineColor( (nFlags & CR_MANUALBREAK) ? aManualColor :
-                                     (nFlags) ? aPageColor : aGridColor );
-                    nOldFlags = nFlags;
+                    pDev->SetLineColor( (nBreak & BREAK_MANUAL) ? aManualColor :
+                                        (nBreak) ? aPageColor : aGridColor );
+                    nBreakOld = nBreak;
                 }
             }
 
-            BOOL bDraw = bGrid || nOldFlags;	// einfaches Gitter nur wenn eingestellt
+            BOOL bDraw = bGrid || nBreakOld;	// einfaches Gitter nur wenn eingestellt
 
             //!	Mit dieser Abfrage wird zuviel weggelassen, wenn ein automatischer
             //!	Umbruch mitten in den Wiederholungszeilen liegt.
@@ -532,7 +529,7 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
             {
                 if ( nY == MAXROW )
                     bDraw = FALSE;
-                else if (pDoc->GetRowFlags(nYplus1,nTab) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+                else if (pDoc->HasRowBreak(nYplus1, nTab))
                     bDraw = FALSE;
             }
 #endif
diff --git sc/source/ui/view/printfun.cxx sc/source/ui/view/printfun.cxx
index 9e1d653..218670c 100644
--- sc/source/ui/view/printfun.cxx
+++ sc/source/ui/view/printfun.cxx
@@ -2886,30 +2886,84 @@ void ScPrintFunc::CalcZoom( USHORT nRangeNo )						// Zoom berechnen
     if (aTableParam.bScalePageNum)
     {
         nZoom = 100;
-        BOOL bFound = FALSE;
         USHORT nPagesToFit = aTableParam.nScalePageNum;
-        while (!bFound)
+
+        sal_uInt16 nLastFitZoom = 0, nLastNonFitZoom = 0;
+        while (true)
         {
+            if (nZoom <= ZOOM_MIN)
+                break;
+
             CalcPages();
-            if ( nPagesX * nPagesY <= nPagesToFit || nZoom <= ZOOM_MIN )
-                bFound = TRUE;
+            bool bFitsPage = (nPagesX * nPagesY <= nPagesToFit);
+
+            if (bFitsPage)
+            {
+                if (nZoom == 100)
+                    // If it fits at 100 %, it's good enough for me.
+                    break;
+
+                nLastFitZoom = nZoom;
+                nZoom = (nLastNonFitZoom + nZoom) / 2;
+
+                if (nLastFitZoom == nZoom)
+                    // It converged.  Use this zoom level.
+                    break;
+            }
             else
-                --nZoom;
+            {
+                if (nZoom - nLastFitZoom <= 1)
+                {
+                    nZoom = nLastFitZoom;
+                    CalcPages();
+                    break;
+                }
+
+                nLastNonFitZoom = nZoom;
+                nZoom = (nLastFitZoom + nZoom) / 2;
+            }
         }
     }
     else if (aTableParam.bScaleTo)
     {
         nZoom = 100;
-        BOOL bFound = FALSE;
         USHORT nW = aTableParam.nScaleWidth;
         USHORT nH = aTableParam.nScaleHeight;
-        while (!bFound)
+
+        sal_uInt16 nLastFitZoom = 0, nLastNonFitZoom = 0;
+        while (true)
         {
+            if (nZoom <= ZOOM_MIN)
+                break;
+
             CalcPages();
-            if ( ((!nW || (nPagesX <= nW)) && (!nH || (nPagesY <= nH))) || (nZoom <= ZOOM_MIN) )
-                bFound = TRUE;
+            bool bFitsPage = ((!nW || (nPagesX <= nW)) && (!nH || (nPagesY <= nH)));
+
+            if (bFitsPage)
+            {
+                if (nZoom == 100)
+                    // If it fits at 100 %, it's good enough for me.
+                    break;
+
+                nLastFitZoom = nZoom;
+                nZoom = (nLastNonFitZoom + nZoom) / 2;
+
+                if (nLastFitZoom == nZoom)
+                    // It converged.  Use this zoom level.
+                    break;
+            }
             else
-                --nZoom;
+            {
+                if (nZoom - nLastFitZoom <= 1)
+                {
+                    nZoom = nLastFitZoom;
+                    CalcPages();
+                    break;
+                }
+
+                nLastNonFitZoom = nZoom;
+                nZoom = (nLastFitZoom + nZoom) / 2;
+            }
         }
     }
     else if (aTableParam.bScaleAll)
@@ -3033,7 +3087,8 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
     for (SCCOL i=nStartCol; i<=nEndCol; i++)
     {
         BYTE nFlags = pDoc->GetColFlags(i,nPrintTab);
-        if ( i>nStartCol && bVisCol && (nFlags & CR_PAGEBREAK) )
+        bool bPageBreak = (pDoc->HasColBreak(i, nPrintTab) & BREAK_PAGE);
+        if ( i>nStartCol && bVisCol && bPageBreak )
         {
             pPageEndX[nPagesX] = i-1;
             ++nPagesX;
@@ -3058,7 +3113,8 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
         SCROW nRangeEnd = aIter.GetRangeEnd();
         for (SCROW j=aIter.GetRangeStart(); j<=nRangeEnd; ++j)
         {
-            if ( j>nStartRow && bVisRow && (nFlags & CR_PAGEBREAK) )
+            bool bPageBreak = (pDoc->HasRowBreak(j, nPrintTab) & BREAK_PAGE);
+            if ( j>nStartRow && bVisRow && bPageBreak )
             {
                 pPageEndY[nTotalY] = j-1;
                 ++nTotalY;
-- 
1.7.0.1

