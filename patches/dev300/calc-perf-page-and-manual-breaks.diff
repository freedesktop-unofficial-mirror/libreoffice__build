diff --git sc/inc/document.hxx sc/inc/document.hxx
index 986bde8..c3e15ea 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -47,6 +47,7 @@
 
 #include <memory>
 #include <map>
+#include <set>
 
 class KeyEvent;
 class OutputDevice;
@@ -156,6 +157,9 @@ namespace com { namespace sun { namespace star {
     namespace embed {
         class XEmbeddedObject;
     }
+    namespace sheet {
+        struct TablePageBreakData;
+    }
 } } }
 
 namespace com { namespace sun { namespace star { namespace document {
@@ -1296,6 +1300,24 @@ public:
     SC_DLLPUBLIC const ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArray( SCTAB nTab ) const;
     SC_DLLPUBLIC       ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArrayModifiable( SCTAB nTab );
 
+    SC_DLLPUBLIC void           GetAllRowBreaks(::std::set<SCROW>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const;
+    SC_DLLPUBLIC void           GetAllColBreaks(::std::set<SCCOL>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const;
+    SC_DLLPUBLIC ScBreakType    HasRowBreak(SCROW nRow, SCTAB nTab) const;
+    SC_DLLPUBLIC ScBreakType    HasColBreak(SCCOL nCol, SCTAB nTab) const;
+    SC_DLLPUBLIC void           SetRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual);
+    SC_DLLPUBLIC void           SetColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual);
+    void                        RemoveRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual);
+    void                        RemoveColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual);
+    ::com::sun::star::uno::Sequence<
+        ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData(SCTAB nTab) const;
+
+    /** 
+     * Write all column row flags to table's flag data, because not all column 
+     * row attributes are stored in the flag data members.  This is necessary 
+     * for ods export. 
+     */
+    void                        SyncColRowFlags();
+
                     /// @return  the index of the last row with any set flags (auto-pagebreak is ignored).
 	SC_DLLPUBLIC SCROW			GetLastFlaggedRow( SCTAB nTab ) const;
 
@@ -1335,6 +1357,7 @@ public:
 	Size			GetPageSize( SCTAB nTab ) const;
 	void			SetPageSize( SCTAB nTab, const Size& rSize );
 	void			SetRepeatArea( SCTAB nTab, SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCROW nEndRow );
+    void            InvalidatePageBreaks(SCTAB nTab);
 	void			UpdatePageBreaks( SCTAB nTab, const ScRange* pUserArea = NULL );
 	void			RemoveManualBreaks( SCTAB nTab );
 	BOOL			HasManualBreaks( SCTAB nTab ) const;
diff --git sc/inc/global.hxx sc/inc/global.hxx
index b2d6e50..61d748d 100644
--- sc/inc/global.hxx
+++ sc/inc/global.hxx
@@ -213,13 +213,16 @@ const SCSIZE PIVOT_MAXPAGEFIELD = 10;
 									// FILTERED und MANUALSIZE nur fuer Zeilen moeglich
 const BYTE   CR_HIDDEN      = 1;
 //const BYTE CR_MARKED      = 2;
-const BYTE   CR_PAGEBREAK   = 4;
+//const BYTE CR_PAGEBREAK   = 4;
 const BYTE   CR_MANUALBREAK = 8;
 const BYTE   CR_FILTERED    = 16;
 const BYTE   CR_MANUALSIZE  = 32;
+const BYTE   CR_ALL         = (CR_HIDDEN | CR_MANUALBREAK | CR_FILTERED | CR_MANUALSIZE);
 
-//	was davon kommt in die Datei:
-#define CR_SAVEMASK		( ~CR_PAGEBREAK )
+typedef BYTE ScBreakType;
+const ScBreakType BREAK_NONE   = 0;
+const ScBreakType BREAK_PAGE   = 1;
+const ScBreakType BREAK_MANUAL = 2;
 
 // Insert-/Delete-Flags
 const USHORT IDF_NONE       = 0x0000;
diff --git sc/inc/table.hxx sc/inc/table.hxx
index ea24628..bfc4bf2 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -40,12 +40,19 @@
 #include "compressedarray.hxx"
 
 #include <memory>
+#include <set>
 
 namespace utl {
 	class SearchParam;
 	class TextSearch;
 }
 
+namespace com { namespace sun { namespace star {
+    namespace sheet {
+        struct TablePageBreakData;
+    }
+} } }
+
 class SfxItemSet;
 class SfxStyleSheetBase;
 class SvxBoxInfoItem;
@@ -115,6 +122,11 @@ private:
 	BYTE*			pColFlags;
 	ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
 
+    ::std::set<SCROW>                      maRowPageBreaks;
+    ::std::set<SCROW>                      maRowManualBreaks;
+    ::std::set<SCCOL>                      maColPageBreaks;
+    ::std::set<SCCOL>                      maColManualBreaks;
+
 	ScOutlineTable*	pOutlineTable;
 
 	SCCOL			nTableAreaX;
@@ -150,6 +162,7 @@ private:
 	Color			aScenarioColor;
 	USHORT			nScenarioFlags;
 	BOOL			bActiveScenario;
+    bool            mbPageBreaksValid;
 
 friend class ScDocument;					// fuer FillInfo
 friend class ScDocumentIterator;
@@ -337,7 +350,8 @@ public:
 
 	void		CopyUpdated( const ScTable* pPosTab, ScTable* pDestTab ) const;
 
-	void		InvalidateTableArea()						{ bTableAreaValid = FALSE; }
+    void        InvalidateTableArea();
+    void        InvalidatePageBreaks();
 
 	BOOL		GetCellArea( SCCOL& rEndCol, SCROW& rEndRow ) const;			// FALSE = leer
 	BOOL		GetTableArea( SCCOL& rEndCol, SCROW& rEndRow ) const;
@@ -598,6 +612,21 @@ public:
 	void		RemoveManualBreaks();
 	BOOL		HasManualBreaks() const;
 
+    void        GetAllRowBreaks(::std::set<SCROW>& rBreaks, bool bPage, bool bManual) const;
+    void        GetAllColBreaks(::std::set<SCCOL>& rBreaks, bool bPage, bool bManual) const;
+    bool        HasRowPageBreak(SCROW nRow) const;
+    bool        HasColPageBreak(SCCOL nCol) const;
+    bool        HasRowManualBreak(SCROW nRow) const;
+    bool        HasColManualBreak(SCCOL nCol) const;
+    void        RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow);
+    void        RemoveRowBreak(SCROW nRow, bool bPage, bool bManual);
+    void        RemoveColBreak(SCCOL nCol, bool bPage, bool bManual);
+    void        SetRowBreak(SCROW nRow, bool bPage, bool bManual);
+    void        SetColBreak(SCCOL nCol, bool bPage, bool bManual);
+    ::com::sun::star::uno::Sequence<
+        ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData() const;
+    void        SyncColRowFlags();
+
 	void		StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
 	void		ExtendHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
 
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 13c9e66..98001ef 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -54,6 +54,7 @@
 #include <tools/tenccvt.hxx>
 
 #include <com/sun/star/text/WritingMode2.hpp>
+#include <com/sun/star/sheet/TablePageBreakData.hpp>
 
 #include "document.hxx"
 #include "table.hxx"
@@ -103,6 +104,9 @@
 using namespace ::com::sun::star;
 
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::sheet::TablePageBreakData;
+using ::std::set;
 
 struct ScDefaultAttr
 {
@@ -3189,6 +3193,102 @@ const ScBitMaskCompressedArray< SCROW, BYTE> & ScDocument::GetRowFlagsArray(
 	return *pFlags;
 }
 
+void ScDocument::GetAllRowBreaks(set<SCROW>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->GetAllRowBreaks(rBreaks, bPage, bManual);
+}
+
+void ScDocument::GetAllColBreaks(set<SCCOL>& rBreaks, SCTAB nTab, bool bPage, bool bManual) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->GetAllColBreaks(rBreaks, bPage, bManual);
+}
+
+ScBreakType ScDocument::HasRowBreak(SCROW nRow, SCTAB nTab) const
+{
+    ScBreakType nType = BREAK_NONE;
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return nType;
+
+    if (pTab[nTab]->HasRowPageBreak(nRow))
+        nType |= BREAK_PAGE;
+
+    if (pTab[nTab]->HasRowManualBreak(nRow))
+        nType |= BREAK_MANUAL;
+
+    return nType;
+}
+
+ScBreakType ScDocument::HasColBreak(SCCOL nCol, SCTAB nTab) const
+{
+    ScBreakType nType = BREAK_NONE;
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return nType;
+
+    if (pTab[nTab]->HasColPageBreak(nCol))
+        nType |= BREAK_PAGE;
+
+    if (pTab[nTab]->HasColManualBreak(nCol))
+        nType |= BREAK_MANUAL;
+
+    return nType;
+}
+
+void ScDocument::SetRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return;
+
+    pTab[nTab]->SetRowBreak(nRow, bPage, bManual);
+}
+
+void ScDocument::SetColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return;
+
+    pTab[nTab]->SetColBreak(nCol, bPage, bManual);
+}
+
+void ScDocument::RemoveRowBreak(SCROW nRow, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidRow(nRow))
+        return;
+
+    pTab[nTab]->RemoveRowBreak(nRow, bPage, bManual);
+}
+
+void ScDocument::RemoveColBreak(SCCOL nCol, SCTAB nTab, bool bPage, bool bManual)
+{
+    if (!ValidTab(nTab) || !pTab[nTab] || !ValidCol(nCol))
+        return;
+
+    pTab[nTab]->RemoveColBreak(nCol, bPage, bManual);
+}
+
+Sequence<TablePageBreakData> ScDocument::GetRowBreakData(SCTAB nTab) const
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return Sequence<TablePageBreakData>();
+
+    return pTab[nTab]->GetRowBreakData();
+}
+
+void ScDocument::SyncColRowFlags()
+{
+    for (SCTAB i = 0; i <= nMaxTableNumber; ++i)
+    {
+        if (!ValidTab(i) || !pTab[i])
+            continue;
+
+        pTab[i]->SyncColRowFlags();
+    }
+}
 
 SCROW ScDocument::GetLastFlaggedRow( SCTAB nTab ) const
 {
@@ -4569,6 +4669,11 @@ void ScDocument::SetRepeatArea( SCTAB nTab, SCCOL nStartCol, SCCOL nEndCol, SCRO
 		pTab[nTab]->SetRepeatArea( nStartCol, nEndCol, nStartRow, nEndRow );
 }
 
+void ScDocument::InvalidatePageBreaks(SCTAB nTab)
+{
+    if (ValidTab(nTab) && pTab[nTab])
+        pTab[nTab]->InvalidatePageBreaks();
+}
 
 void ScDocument::UpdatePageBreaks( SCTAB nTab, const ScRange* pUserArea )
 {
diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
index ddd1bbb..51c3e5e 100644
--- sc/source/core/data/table1.cxx
+++ sc/source/core/data/table1.cxx
@@ -155,7 +155,8 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 	pScenarioRanges( NULL ),
 	aScenarioColor( COL_LIGHTGRAY ),
 	nScenarioFlags( 0 ),
-	bActiveScenario( FALSE )
+	bActiveScenario( FALSE ),
+    mbPageBreaksValid(false)
 {
 
 	if (bColInfo)
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index 5a78469..151e3d7 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -137,6 +137,8 @@ void ScTable::InsertRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
 		aCol[j].InsertRow( nStartRow, nSize );
 	if( !--nRecalcLvl )
 		SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -164,6 +166,8 @@ void ScTable::DeleteRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
     }
 	if( !--nRecalcLvl )
 		SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -230,6 +234,8 @@ void ScTable::InsertCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
 	}
 	if( !--nRecalcLvl )
 		SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -272,6 +278,8 @@ void ScTable::DeleteCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
 	}
 	if( !--nRecalcLvl )
 		SetDrawPageSize();
+
+    InvalidatePageBreaks();
 }
 
 
@@ -638,29 +646,39 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
 			if (nRow1==0 && nRow2==MAXROW && pColWidth && pDestTab->pColWidth)
 				for (SCCOL i=nCol1; i<=nCol2; i++)
 				{
-					BOOL bChange = pCharts &&
-						( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+                    bool bHiddenChange = ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+                    bool bChange = bHiddenChange || (pDestTab->pColWidth[i] != pColWidth[i]);
 					pDestTab->pColWidth[i] = pColWidth[i];
 					pDestTab->pColFlags[i] = pColFlags[i];
 					//!	Aenderungen zusammenfassen?
-					if (bChange)
+					if (bHiddenChange && pCharts)
 						pCharts->SetRangeDirty(ScRange( i, 0, nTab, i, MAXROW, nTab ));
+
+                    if (bChange)
+                        pDestTab->InvalidatePageBreaks();
 				}
 
 			if (nCol1==0 && nCol2==MAXCOL && pRowHeight && pDestTab->pRowHeight)
             {
+                bool bChange = pDestTab->pRowHeight->SumValues(nRow1, nRow2) != pRowHeight->SumValues(nRow1, nRow2);
+
+                if (bChange)
+                    pDestTab->InvalidatePageBreaks();
+
                 pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
 				for (SCROW i=nRow1; i<=nRow2; i++)
 				{
                     // TODO: might need some performance improvement, block
                     // operations instead of single GetValue()/SetValue() calls.
                     BYTE nThisRowFlags = pRowFlags->GetValue(i);
-					BOOL bChange = pCharts &&
-                        ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
+					bool bHiddenChange = ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
                     pDestTab->pRowFlags->SetValue( i, nThisRowFlags );
 					//!	Aenderungen zusammenfassen?
-					if (bChange)
+					if (bHiddenChange && pCharts)
 						pCharts->SetRangeDirty(ScRange( 0, i, nTab, MAXCOL, i, nTab ));
+
+                    if (bHiddenChange)
+                        pDestTab->InvalidatePageBreaks();
 				}
             }
 
@@ -711,6 +729,16 @@ void ScTable::CopyUpdated( const ScTable* pPosTab, ScTable* pDestTab ) const
 		aCol[i].CopyUpdated( pPosTab->aCol[i], pDestTab->aCol[i] );
 }
 
+void ScTable::InvalidateTableArea()
+{
+    bTableAreaValid = FALSE;
+}
+
+void ScTable::InvalidatePageBreaks()
+{
+    mbPageBreaksValid = false;
+}
+
 void ScTable::CopyScenarioTo( ScTable* pDestTab ) const
 {
 	DBG_ASSERT( bScenario, "bScenario == FALSE" );
@@ -1931,6 +1959,8 @@ void ScTable::SetColWidth( SCCOL nCol, USHORT nNewWidth )
 			pColWidth[nCol] = nNewWidth;
 			if( !--nRecalcLvl )
 				SetDrawPageSize();
+
+            InvalidatePageBreaks();
 		}
 	}
 	else
@@ -1960,6 +1990,8 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
 			pRowHeight->SetValue( nRow, nNewHeight);
 			if( !--nRecalcLvl )
 				SetDrawPageSize();
+
+            InvalidatePageBreaks();
 		}
 	}
 	else
@@ -2041,6 +2073,9 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
 		}
 		if( !--nRecalcLvl )
 			SetDrawPageSize();
+
+        if (bChanged)
+            InvalidatePageBreaks();
 	}
 	else
 	{
@@ -2280,6 +2315,8 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
 			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nRow, nTab, MAXCOL, nRow, nTab ));
+
+            InvalidatePageBreaks();
 		}
 	}
 	else
@@ -2324,6 +2361,8 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
 
 			if (pOutlineTable)
 				UpdateOutlineRow( nRow, nRow, bShow );
+
+            InvalidatePageBreaks();
 		}
 	}
 	else
@@ -2421,6 +2460,8 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 			ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
 			if ( pCharts )
 				pCharts->SetRangeDirty(ScRange( 0, nStartRow, nTab, MAXCOL, nEndRow, nTab ));
+
+            InvalidatePageBreaks();
 		}
 
 		nStartRow = nEndRow + 1;
@@ -2496,7 +2537,7 @@ SCROW ScTable::GetLastFlaggedRow() const
 	if ( !pRowFlags )
 		return 0;
 
-    SCROW nLastFound = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    SCROW nLastFound = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(CR_ALL) );
 	return ValidRow(nLastFound) ? nLastFound : 0;
 }
 
@@ -2508,7 +2549,7 @@ SCCOL ScTable::GetLastChangedCol() const
 
 	SCCOL nLastFound = 0;
 	for (SCCOL nCol = 1; nCol <= MAXCOL; nCol++)
-		if ((pColFlags[nCol] & ~CR_PAGEBREAK) || (pColWidth[nCol] != STD_COL_WIDTH))
+        if ((pColFlags[nCol] & CR_ALL) || (pColWidth[nCol] != STD_COL_WIDTH))
 			nLastFound = nCol;
 
 	return nLastFound;
@@ -2520,7 +2561,7 @@ SCROW ScTable::GetLastChangedRow() const
 	if ( !pRowFlags )
 		return 0;
 
-    SCROW nLastFlags = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    SCROW nLastFlags = pRowFlags->GetLastAnyBitAccess( 0, sal::static_int_cast<BYTE>(CR_ALL) );
     if (!ValidRow(nLastFlags))
         nLastFlags = 0;
 
diff --git sc/source/core/data/table3.cxx sc/source/core/data/table3.cxx
index 5fca4bc..95f68fc 100644
--- sc/source/core/data/table3.cxx
+++ sc/source/core/data/table3.cxx
@@ -771,7 +771,7 @@ void ScTable::RemoveSubTotals( ScSubTotalParam& rParam )
 			if ( pCell->GetCellType() == CELLTYPE_FORMULA )
 				if (((ScFormulaCell*)pCell)->IsSubTotal())
 				{
-					SetRowFlags(nRow+1,GetRowFlags(nRow+1)&(~CR_MANUALBREAK));
+                    RemoveRowBreak(nRow+1, false, true);
 					pDocument->DeleteRow( 0,nTab, MAXCOL,nTab, nRow, 1 );
 					--nEndRow;
 					aIter = ScColumnIterator( &aCol[nCol],nRow,nEndRow );
@@ -939,9 +939,7 @@ BOOL ScTable::DoSubTotals( ScSubTotalParam& rParam )
 					bBlockVis = FALSE;
                     if ( rParam.bPagebreak && nRow < MAXROW &&
                             aRowEntry.nSubStartRow != nStartRow && nLevel == 0)
-                        SetRowFlags( aRowEntry.nSubStartRow,
-                                GetRowFlags(aRowEntry.nSubStartRow) |
-                                CR_MANUALBREAK);
+                        SetRowBreak(aRowEntry.nSubStartRow, false, true);
 
 					if (bSpaceLeft)
 					{
diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
index 3bb433c..618fe75 100644
--- sc/source/core/data/table5.cxx
+++ sc/source/core/data/table5.cxx
@@ -53,8 +53,13 @@
 #include "brdcst.hxx"
 #include "tabprotection.hxx"
 #include "globstr.hrc"
+#include <com/sun/star/sheet/TablePageBreakData.hpp>
+
+#include <algorithm>
 
 using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::sheet::TablePageBreakData;
+using ::std::set;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -68,6 +73,9 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 	if ( !pUserArea && !bPageSizeValid )
 		return;
 
+    if (mbPageBreaksValid)
+        return;
+
 	SfxStyleSheetBase* pStyle = pDocument->GetStyleSheetPool()->
 									Find( aPageStyle, SFX_STYLE_FAMILY_PAGE );
 	if ( !pStyle )
@@ -79,7 +87,6 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 	const SfxPoolItem* pItem;
 
 	SCCOL nX;
-	SCROW nY;
 	SCCOL nStartCol = 0;
 	SCROW nStartRow = 0;
 	SCCOL nEndCol = MAXCOL;
@@ -99,8 +106,9 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 			//	bei mehreren Bereichen nichts anzeigen:
 
 			for (nX=0; nX<MAXCOL; nX++)
-				pColFlags[nX] &= ~CR_PAGEBREAK;
-            pRowFlags->AndValue( 0, MAXROW-1, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+                RemoveColBreak(nX, true, false);
+
+            RemoveRowPageBreaks(0, MAXROW-1);
 
 			return;
 		}
@@ -144,13 +152,13 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 		//	Anfang: Breaks loeschen
 
 	for (nX=0; nX<nStartCol; nX++)
-		pColFlags[nX] &= ~CR_PAGEBREAK;
-    pRowFlags->AndValue( 0, nStartRow-1, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+        RemoveColBreak(nX, true, false);
+    RemoveRowPageBreaks(0, nStartRow-1);
 
 	if (nStartCol > 0)
-		pColFlags[nStartCol] |= CR_PAGEBREAK;			//! AREABREAK
+        SetColBreak(nStartCol, true, false);  // AREABREAK
 	if (nStartRow > 0)
-		pRowFlags->OrValue( nStartRow, CR_PAGEBREAK);			//! AREABREAK
+        SetRowBreak(nStartRow, true, false);  // AREABREAK
 
 		//	Mittelteil: Breaks verteilen
 
@@ -161,14 +169,15 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 	{
 		BOOL bStartOfPage = FALSE;
 		long nThisX = ( pColFlags[nX] & CR_HIDDEN ) ? 0 : pColWidth[nX];
-		if ( (nSizeX+nThisX > nPageSizeX) || ((pColFlags[nX] & CR_MANUALBREAK) && !bSkipBreaks) )
+        bool bManualBreak = HasColManualBreak(nX);
+        if ( (nSizeX+nThisX > nPageSizeX) || (bManualBreak && !bSkipBreaks) )
 		{
-			pColFlags[nX] |= CR_PAGEBREAK;
+            SetColBreak(nX, true, false);
 			nSizeX = 0;
 			bStartOfPage = TRUE;
 		}
 		else if (nX != nStartCol)
-			pColFlags[nX] &= ~CR_PAGEBREAK;
+            RemoveColBreak(nX, true, false);
 		else
 			bStartOfPage = TRUE;
 
@@ -178,7 +187,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 			for (SCCOL i=nRepeatStartX; i<=nRepeatEndX; i++)
 				nPageSizeX -= ( pColFlags[i] & CR_HIDDEN ) ? 0 : pColWidth[i];
 			while (nX<=nRepeatEndX)
-				pColFlags[++nX] &= ~CR_PAGEBREAK;
+                RemoveColBreak(++nX, true, false);
 			bColFound = TRUE;
 		}
 
@@ -186,23 +195,21 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 	}
 
     // Remove all page breaks in range.
-    pRowFlags->AndValue( nStartRow+1, nEndRow, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+    RemoveRowPageBreaks(nStartRow+1, nEndRow);
+
     // And set new page breaks.
 	BOOL bRepeatRow = ( nRepeatStartY != SCROW_REPEAT_NONE );
 	BOOL bRowFound = FALSE;
 	long nSizeY = 0;
-    ScCompressedArrayIterator< SCROW, BYTE> aFlagsIter( *pRowFlags, nStartRow, nEndRow);
-    ScCompressedArrayIterator< SCROW, USHORT> aHeightIter( *pRowHeight, nStartRow, nEndRow);
-    for ( ; aFlagsIter; ++aFlagsIter, ++aHeightIter)
-	{
-        nY = aFlagsIter.GetPos();
+    for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
+    {
 		BOOL bStartOfPage = FALSE;
-        BYTE nFlags = *aFlagsIter;
-		long nThisY = (nFlags & CR_HIDDEN) ? 0 : *aHeightIter;
-		if ( (nSizeY+nThisY > nPageSizeY) || ((nFlags & CR_MANUALBREAK) && !bSkipBreaks) )
+        BYTE nFlags = pRowFlags->GetValue(nY);
+        long nThisY = (nFlags & CR_HIDDEN) ? 0 : pRowHeight->GetValue(nY);
+        bool bManualBreak = HasRowManualBreak(nY);
+		if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
 		{
-			pRowFlags->SetValue( nY, nFlags | CR_PAGEBREAK);
-            aFlagsIter.Resync( nY);
+            SetRowBreak(nY, true, false);
 			nSizeY = 0;
 			bStartOfPage = TRUE;
 		}
@@ -222,12 +229,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 #endif
             nPageSizeY -= nHeights;
             if (nY <= nRepeatEndY)
-            {
-                pRowFlags->AndValue( nY, nRepeatEndY, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
-                nY = nRepeatEndY + 1;
-                aFlagsIter.Resync( nY);
-                aHeightIter.Resync( nY);
-            }
+                RemoveRowPageBreaks(nY, nRepeatEndY);
 			bRowFound = TRUE;
 		}
 
@@ -238,46 +240,214 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
 
 	if (nEndCol < MAXCOL)
 	{
-		pColFlags[nEndCol+1] |= CR_PAGEBREAK;			//! AREABREAK
+        SetColBreak(nEndCol+1, true, false);  // AREABREAK
 		for (nX=nEndCol+2; nX<=MAXCOL; nX++)
-			pColFlags[nX] &= ~CR_PAGEBREAK;
+            RemoveColBreak(nX, true, false);
 	}
 	if (nEndRow < MAXROW)
 	{
-		pRowFlags->OrValue( nEndRow+1, CR_PAGEBREAK);			//! AREABREAK
+        SetRowBreak(nEndRow+1, true, false);  // AREABREAK
 		if (nEndRow+2 <= MAXROW)
-            pRowFlags->AndValue( nEndRow+2, MAXROW, sal::static_int_cast<BYTE>(~CR_PAGEBREAK) );
+            RemoveRowPageBreaks(nEndRow+2, MAXROW);
 	}
+    mbPageBreaksValid = true;
 }
 
 void ScTable::RemoveManualBreaks()
 {
-	if (pColFlags)
-		for (SCCOL nCol = 0; nCol <= MAXCOL; nCol++)
-			pColFlags[nCol] &= ~CR_MANUALBREAK;
-
-	if (pRowFlags)
-        pRowFlags->AndValue( 0, MAXROW, sal::static_int_cast<BYTE>(~CR_MANUALBREAK) );
+    maRowManualBreaks.clear();
+    maColManualBreaks.clear();
+    InvalidatePageBreaks();
 }
 
 BOOL ScTable::HasManualBreaks() const
 {
-	if (pColFlags)
-		for (SCCOL nCol = 0; nCol <= MAXCOL; nCol++)
-			if ( pColFlags[nCol] & CR_MANUALBREAK )
-				return TRUE;
+    return !maRowManualBreaks.empty() || !maColManualBreaks.empty();
+}
+
+void ScTable::GetAllRowBreaks(set<SCROW>& rBreaks, bool bPage, bool bManual) const
+{
+    if (bPage)
+        rBreaks = maRowPageBreaks;
+
+    if (bManual)
+    {
+        using namespace std;    
+        copy(maRowManualBreaks.begin(), maRowManualBreaks.end(), inserter(rBreaks, rBreaks.begin()));
+    }
+}
+
+void ScTable::GetAllColBreaks(set<SCCOL>& rBreaks, bool bPage, bool bManual) const
+{
+    if (bPage)
+        rBreaks = maColPageBreaks;
+
+    if (bManual)
+    {
+        using namespace std;
+        copy(maColManualBreaks.begin(), maColManualBreaks.end(), inserter(rBreaks, rBreaks.begin()));
+    }
+}
+
+bool ScTable::HasRowPageBreak(SCROW nRow) const
+{
+    if (!ValidRow(nRow))
+        return false;
+
+    return maRowPageBreaks.count(nRow) > 0;
+}
 
-	if (pRowFlags)
-        if (ValidRow( pRowFlags->GetLastAnyBitAccess( 0, CR_MANUALBREAK)))
-            return TRUE;
+bool ScTable::HasColPageBreak(SCCOL nCol) const
+{
+    if (!ValidCol(nCol))
+        return false;
 
-	return FALSE;
+    return maColPageBreaks.count(nCol) > 0;
+}
+
+bool ScTable::HasRowManualBreak(SCROW nRow) const
+{
+    if (!ValidRow(nRow))
+        return false;
+
+    return maRowManualBreaks.count(nRow) > 0;
+}
+
+bool ScTable::HasColManualBreak(SCCOL nCol) const
+{
+    if (!ValidCol(nCol))
+        return false;
+
+    return (maColManualBreaks.count(nCol) > 0);
+}
+
+void ScTable::RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow)
+{
+    using namespace std;
+
+    if (!ValidRow(nStartRow) || !ValidRow(nEndRow))
+        return;
+
+    set<SCROW>::iterator low  = maRowPageBreaks.lower_bound(nStartRow);
+    set<SCROW>::iterator high = maRowPageBreaks.upper_bound(nEndRow);
+    maRowPageBreaks.erase(low, high);
+}
+
+void ScTable::RemoveRowBreak(SCROW nRow, bool bPage, bool bManual)
+{
+    if (!ValidRow(nRow))
+        return;
+
+    if (bPage)
+        maRowPageBreaks.erase(nRow);
+
+    if (bManual)
+    {    
+        maRowManualBreaks.erase(nRow);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::RemoveColBreak(SCCOL nCol, bool bPage, bool bManual)
+{
+    if (!ValidCol(nCol))
+        return;
+
+    if (bPage)
+        maColPageBreaks.erase(nCol);
+
+    if (bManual)
+    {    
+        maColManualBreaks.erase(nCol);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::SetRowBreak(SCROW nRow, bool bPage, bool bManual)
+{
+    if (!ValidRow(nRow))
+        return;
+
+    if (bPage)
+        maRowPageBreaks.insert(nRow);
+
+    if (bManual)
+    {    
+        maRowManualBreaks.insert(nRow);
+        InvalidatePageBreaks();
+    }
+}
+
+void ScTable::SetColBreak(SCCOL nCol, bool bPage, bool bManual)
+{
+    if (!ValidCol(nCol))
+        return;
+
+    if (bPage)
+        maColPageBreaks.insert(nCol);
+
+    if (bManual)
+    {    
+        maColManualBreaks.insert(nCol);
+        InvalidatePageBreaks();
+    }
+}
+
+Sequence<TablePageBreakData> ScTable::GetRowBreakData() const
+{
+    using ::std::copy;
+    using ::std::inserter;
+
+    set<SCROW> aRowBreaks = maRowPageBreaks;
+    copy(maRowManualBreaks.begin(), maRowManualBreaks.end(), inserter(aRowBreaks, aRowBreaks.begin()));
+
+    set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end();
+    Sequence<TablePageBreakData> aSeq(aRowBreaks.size());
+
+    for (sal_Int32 i = 0; itr != itrEnd; ++itr, ++i)
+    {
+        SCROW nRow = *itr;
+        TablePageBreakData aData;
+        aData.Position = nRow;
+        aData.ManualBreak = HasRowManualBreak(nRow);
+        aSeq[i] = aData;
+    }
+
+    return aSeq;
+}
+
+void ScTable::SyncColRowFlags()
+{
+    using ::sal::static_int_cast;
+
+    // For now, we only need to sync the manual breaks.
+
+    pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~CR_MANUALBREAK));
+    for (SCCOL i = 0; i <= MAXCOL; ++i)
+        pColFlags[i] &= static_int_cast<BYTE>(~CR_MANUALBREAK);
+
+    if (!maRowManualBreaks.empty())
+    {
+        for (set<SCROW>::const_iterator itr = maRowManualBreaks.begin(), itrEnd = maRowManualBreaks.end();
+              itr != itrEnd; ++itr)
+            pRowFlags->OrValue(*itr, static_int_cast<BYTE>(CR_MANUALBREAK));
+    }
+
+    if (!maColManualBreaks.empty())
+    {
+        for (set<SCCOL>::const_iterator itr = maColManualBreaks.begin(), itrEnd = maColManualBreaks.end();
+              itr != itrEnd; ++itr)
+            pColFlags[*itr] |= CR_MANUALBREAK;
+    }
 }
 
 void ScTable::SetPageSize( const Size& rSize )
 {
 	if ( rSize.Width() != 0 && rSize.Height() != 0 )
 	{
+        if (aPageSizeTwips != rSize)
+            InvalidatePageBreaks();
+
 		bPageSizeValid = TRUE;
 		aPageSizeTwips = rSize;
 	}
diff --git sc/source/filter/excel/xepage.cxx sc/source/filter/excel/xepage.cxx
index 52aa775..f99b732 100644
--- sc/source/filter/excel/xepage.cxx
+++ sc/source/filter/excel/xepage.cxx
@@ -48,9 +48,14 @@
 #include "xehelper.hxx"
 #include "xeescher.hxx"
 
+#include <set>
+#include <limits>
+
 #include <oox/core/tokens.hxx>
 
 using ::rtl::OString;
+using ::std::set;
+using ::std::numeric_limits;
 
 // Page settings records ======================================================
 
@@ -302,17 +307,23 @@ XclExpPageSettings::XclExpPageSettings( const XclExpRoot& rRoot ) :
 
     // *** page breaks ***
 
-    ScCompressedArrayIterator< SCROW, BYTE> aIter( rDoc.GetRowFlagsArray( nScTab), 1, GetMaxPos().Row());
-    do
+    set<SCROW> aRowBreaks;
+    rDoc.GetAllRowBreaks(aRowBreaks, nScTab, false, true);
+
+    SCROW nMaxRow = numeric_limits<sal_uInt16>::max();
+    for (set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end(); itr != itrEnd; ++itr)
     {
-        if (*aIter & CR_MANUALBREAK)
-            for (SCROW j=aIter.GetRangeStart(); j<=aIter.GetRangeEnd(); ++j)
-                maData.maHorPageBreaks.push_back( static_cast< sal_uInt16 >( j ) );
-    } while (aIter.NextRange());
-
-    for( SCCOL nScCol = 1, nScMaxCol = GetMaxPos().Col(); nScCol <= nScMaxCol; ++nScCol )
-        if( rDoc.GetColFlags( nScCol, nScTab ) & CR_MANUALBREAK )
-            maData.maVerPageBreaks.push_back( static_cast< sal_uInt16 >( nScCol ) );
+        SCROW nRow = *itr;
+        if (nRow > nMaxRow)
+            break;
+        
+        maData.maHorPageBreaks.push_back(nRow);
+    }
+
+    set<SCCOL> aColBreaks;
+    rDoc.GetAllColBreaks(aColBreaks, nScTab, false, true);
+    for (set<SCCOL>::const_iterator itr = aColBreaks.begin(), itrEnd = aColBreaks.end(); itr != itrEnd; ++itr)
+        maData.maVerPageBreaks.push_back(*itr);
 }
 
 static void lcl_WriteHeaderFooter( XclExpXmlStream& rStrm )
diff --git sc/source/filter/excel/xipage.cxx sc/source/filter/excel/xipage.cxx
index 2a52521..cb1aba2 100644
--- sc/source/filter/excel/xipage.cxx
+++ sc/source/filter/excel/xipage.cxx
@@ -378,14 +378,14 @@ void XclImpPageSettings::Finalize()
     {
         SCROW nScRow = static_cast< SCROW >( *aIt );
         if( nScRow <= MAXROW )
-            rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetRowBreak(nScRow, nScTab, false, true);
     }
 
     for( aIt = maData.maVerPageBreaks.begin(), aEnd = maData.maVerPageBreaks.end(); aIt != aEnd; ++aIt )
     {
         SCCOL nScCol = static_cast< SCCOL >( *aIt );
         if( nScCol <= MAXCOL )
-            rDoc.SetColFlags( nScCol, nScTab, rDoc.GetColFlags( nScCol, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetColBreak(nScCol, nScTab, false, true);
     }
 }
 
diff --git sc/source/filter/starcalc/scflt.cxx sc/source/filter/starcalc/scflt.cxx
index 444ed23..371ef48 100644
--- sc/source/filter/starcalc/scflt.cxx
+++ sc/source/filter/starcalc/scflt.cxx
@@ -1552,13 +1552,15 @@ void Sc10Import::LoadTables()
 			if (DataValue != 0)
 			{
 				BYTE nFlags = 0;
-				if ((DataValue & crfSoftBreak) == crfSoftBreak)
-					nFlags |= CR_PAGEBREAK;
-				if ((DataValue & crfHardBreak) == crfHardBreak)
-					nFlags |= CR_MANUALBREAK;
+				bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
+				bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
 				if ((DataValue & crfHidden) == crfHidden)
 					nFlags |= CR_HIDDEN;
-				for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++) pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+				for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++) 
+                {    
+                    pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetColBreak(k, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
+                }
 			}
 			DataStart = DataEnd + 1;
 		}
@@ -1602,13 +1604,15 @@ void Sc10Import::LoadTables()
 			if (DataValue != 0)
 			{
 				BYTE nFlags = 0;
-				if ((DataValue & crfSoftBreak) == crfSoftBreak)
-					nFlags |= CR_PAGEBREAK;
-				if ((DataValue & crfHardBreak) == crfHardBreak)
-					nFlags |= CR_MANUALBREAK;
+				bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
+				bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
 				if ((DataValue & crfHidden) == crfHidden)
 					nFlags |= CR_HIDDEN;
-				for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++) pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++) 
+                {    
+                    pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetRowBreak(l, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
+                }
 			}
 			DataStart = DataEnd + 1;
 		}
diff --git sc/source/filter/xlsx/xlsx-xepage.cxx sc/source/filter/xlsx/xlsx-xepage.cxx
index 52aa775..f99b732 100644
--- sc/source/filter/xlsx/xlsx-xepage.cxx
+++ sc/source/filter/xlsx/xlsx-xepage.cxx
@@ -48,9 +48,14 @@
 #include "xehelper.hxx"
 #include "xeescher.hxx"
 
+#include <set>
+#include <limits>
+
 #include <oox/core/tokens.hxx>
 
 using ::rtl::OString;
+using ::std::set;
+using ::std::numeric_limits;
 
 // Page settings records ======================================================
 
@@ -302,17 +307,23 @@ XclExpPageSettings::XclExpPageSettings( const XclExpRoot& rRoot ) :
 
     // *** page breaks ***
 
-    ScCompressedArrayIterator< SCROW, BYTE> aIter( rDoc.GetRowFlagsArray( nScTab), 1, GetMaxPos().Row());
-    do
+    set<SCROW> aRowBreaks;
+    rDoc.GetAllRowBreaks(aRowBreaks, nScTab, false, true);
+
+    SCROW nMaxRow = numeric_limits<sal_uInt16>::max();
+    for (set<SCROW>::const_iterator itr = aRowBreaks.begin(), itrEnd = aRowBreaks.end(); itr != itrEnd; ++itr)
     {
-        if (*aIter & CR_MANUALBREAK)
-            for (SCROW j=aIter.GetRangeStart(); j<=aIter.GetRangeEnd(); ++j)
-                maData.maHorPageBreaks.push_back( static_cast< sal_uInt16 >( j ) );
-    } while (aIter.NextRange());
-
-    for( SCCOL nScCol = 1, nScMaxCol = GetMaxPos().Col(); nScCol <= nScMaxCol; ++nScCol )
-        if( rDoc.GetColFlags( nScCol, nScTab ) & CR_MANUALBREAK )
-            maData.maVerPageBreaks.push_back( static_cast< sal_uInt16 >( nScCol ) );
+        SCROW nRow = *itr;
+        if (nRow > nMaxRow)
+            break;
+        
+        maData.maHorPageBreaks.push_back(nRow);
+    }
+
+    set<SCCOL> aColBreaks;
+    rDoc.GetAllColBreaks(aColBreaks, nScTab, false, true);
+    for (set<SCCOL>::const_iterator itr = aColBreaks.begin(), itrEnd = aColBreaks.end(); itr != itrEnd; ++itr)
+        maData.maVerPageBreaks.push_back(*itr);
 }
 
 static void lcl_WriteHeaderFooter( XclExpXmlStream& rStrm )
diff --git sc/source/filter/xlsx/xlsx-xipage.cxx sc/source/filter/xlsx/xlsx-xipage.cxx
index 2a52521..cb1aba2 100644
--- sc/source/filter/xlsx/xlsx-xipage.cxx
+++ sc/source/filter/xlsx/xlsx-xipage.cxx
@@ -378,14 +378,14 @@ void XclImpPageSettings::Finalize()
     {
         SCROW nScRow = static_cast< SCROW >( *aIt );
         if( nScRow <= MAXROW )
-            rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetRowBreak(nScRow, nScTab, false, true);
     }
 
     for( aIt = maData.maVerPageBreaks.begin(), aEnd = maData.maVerPageBreaks.end(); aIt != aEnd; ++aIt )
     {
         SCCOL nScCol = static_cast< SCCOL >( *aIt );
         if( nScCol <= MAXCOL )
-            rDoc.SetColFlags( nScCol, nScTab, rDoc.GetColFlags( nScCol, nScTab ) | CR_MANUALBREAK );
+            rDoc.SetColBreak(nScCol, nScTab, false, true);
     }
 }
 
diff --git sc/source/filter/xml/xmlexprt.cxx sc/source/filter/xml/xmlexprt.cxx
index 089f12d..4dd19a1 100644
--- sc/source/filter/xml/xmlexprt.cxx
+++ sc/source/filter/xml/xmlexprt.cxx
@@ -1947,6 +1947,7 @@ void ScXMLExport::_ExportAutoStyles()
 						    {
 							    if (pDoc)
 							    {
+                                    pDoc->SyncColRowFlags();
 								    uno::Reference<table::XTableColumns> xTableColumns(xColumnRowRange->getColumns());
 								    if (xTableColumns.is())
 								    {
diff --git sc/source/ui/docshell/dbdocfun.cxx sc/source/ui/docshell/dbdocfun.cxx
index 9e2a647..0e670d8 100644
--- sc/source/ui/docshell/dbdocfun.cxx
+++ sc/source/ui/docshell/dbdocfun.cxx
@@ -938,7 +938,10 @@ BOOL ScDBDocFunc::Query( SCTAB nTab, const ScQueryParam& rQueryParam,
 	}
 
 	if (!bCopy)
+    {
+        pDoc->InvalidatePageBreaks(nTab);    
 		pDoc->UpdatePageBreaks( nTab );
+    }
 
     // #i23299# because of Subtotal functions, the whole rows must be set dirty
 	ScRange aDirtyRange( 0 , aLocalParam.nRow1, nDestTab,
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index 0d98486..1477025 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -3033,20 +3033,22 @@ BOOL ScDocFunc::InsertPageBreak( BOOL bColumn, const ScAddress& rPos,
 	if (nPos == 0)
 		return FALSE;					// erste Spalte / Zeile
 
-    BYTE nFlags = bColumn ? pDoc->GetColFlags( static_cast<SCCOL>(nPos), nTab )
-        : pDoc->GetRowFlags( static_cast<SCROW>(nPos), nTab );
-	if (nFlags & CR_MANUALBREAK)
-		return TRUE;					// Umbruch schon gesetzt
+    ScBreakType nBreak = bColumn ? 
+        pDoc->HasColBreak(static_cast<SCCOL>(nPos), nTab) : 
+        pDoc->HasRowBreak(static_cast<SCROW>(nPos), nTab);
+    if (nBreak & BREAK_MANUAL)
+        return true;
 
 	if (bRecord)
 		rDocShell.GetUndoManager()->AddUndoAction(
 			new ScUndoPageBreak( &rDocShell, rPos.Col(), rPos.Row(), nTab, bColumn, TRUE ) );
 
-	nFlags |= CR_MANUALBREAK;
-	if (bColumn)
-		pDoc->SetColFlags( static_cast<SCCOL>(nPos), nTab, nFlags );
-	else
-		pDoc->SetRowFlags( static_cast<SCROW>(nPos), nTab, nFlags );
+    if (bColumn)
+        pDoc->SetColBreak(static_cast<SCCOL>(nPos), nTab, false, true);
+    else
+        pDoc->SetRowBreak(static_cast<SCROW>(nPos), nTab, false, true);
+
+    pDoc->InvalidatePageBreaks(nTab);
 	pDoc->UpdatePageBreaks( nTab );
 
 	if (bColumn)
@@ -3089,20 +3091,25 @@ BOOL ScDocFunc::RemovePageBreak( BOOL bColumn, const ScAddress& rPos,
 
     SCCOLROW nPos = bColumn ? static_cast<SCCOLROW>(rPos.Col()) :
         static_cast<SCCOLROW>(rPos.Row());
-    BYTE nFlags = bColumn ? pDoc->GetColFlags( static_cast<SCCOL>(nPos), nTab )
-        : pDoc->GetRowFlags( static_cast<SCROW>(nPos), nTab );
-	if ((nFlags & CR_MANUALBREAK)==0)
-		return FALSE;							// kein Umbruch gesetzt
+
+    ScBreakType nBreak;
+    if (bColumn)
+        nBreak = pDoc->HasColBreak(static_cast<SCCOL>(nPos), nTab);
+    else
+        nBreak = pDoc->HasRowBreak(static_cast<SCROW>(nPos), nTab);
+    if ((nBreak & BREAK_MANUAL) == 0)
+        // There is no manual break.
+        return false;
 
 	if (bRecord)
 		rDocShell.GetUndoManager()->AddUndoAction(
 			new ScUndoPageBreak( &rDocShell, rPos.Col(), rPos.Row(), nTab, bColumn, FALSE ) );
 
-	nFlags &= ~CR_MANUALBREAK;
-	if (bColumn)
-		pDoc->SetColFlags( static_cast<SCCOL>(nPos), nTab, nFlags );
-	else
-		pDoc->SetRowFlags( static_cast<SCROW>(nPos), nTab, nFlags );
+    if (bColumn)
+        pDoc->RemoveColBreak(static_cast<SCCOL>(nPos), nTab, false, true);
+    else
+        pDoc->RemoveRowBreak(static_cast<SCROW>(nPos), nTab, false, true);
+
 	pDoc->UpdatePageBreaks( nTab );
 
 	if (bColumn)
diff --git sc/source/ui/docshell/olinefun.cxx sc/source/ui/docshell/olinefun.cxx
index ed5fb52..37023e2 100644
--- sc/source/ui/docshell/olinefun.cxx
+++ sc/source/ui/docshell/olinefun.cxx
@@ -692,6 +692,7 @@ BOOL ScOutlineDocFunc::ShowOutline( SCTAB nTab, BOOL bColumns, USHORT nLevel, US
 
 	pArray->SetVisibleBelow( nLevel, nEntry, TRUE, TRUE );
 
+    pDoc->InvalidatePageBreaks(nTab);
 	pDoc->UpdatePageBreaks( nTab );
 
 	if (bPaint)
@@ -757,6 +758,7 @@ BOOL ScOutlineDocFunc::HideOutline( SCTAB nTab, BOOL bColumns, USHORT nLevel, US
 
 	pArray->SetVisibleBelow( nLevel, nEntry, FALSE );
 
+    pDoc->InvalidatePageBreaks(nTab);
 	pDoc->UpdatePageBreaks( nTab );
 
 	if (bPaint)
diff --git sc/source/ui/undo/undocell.cxx sc/source/ui/undo/undocell.cxx
index 52c8bc0..9237578 100644
--- sc/source/ui/undo/undocell.cxx
+++ sc/source/ui/undo/undocell.cxx
@@ -587,6 +587,8 @@ void ScUndoPageBreak::DoChange( BOOL bInsertP ) const
 			pViewShell->InsertPageBreak(bColumn, FALSE);
 		else
 			pViewShell->DeletePageBreak(bColumn, FALSE);
+
+        pDocShell->GetDocument()->InvalidatePageBreaks(nTab);
 	}
 }
 
diff --git sc/source/ui/undo/undodat.cxx sc/source/ui/undo/undodat.cxx
index 36bb424..7420660 100644
--- sc/source/ui/undo/undodat.cxx
+++ sc/source/ui/undo/undodat.cxx
@@ -1032,7 +1032,10 @@ void __EXPORT ScUndoQuery::Undo()
 		pDoc->SetDBCollection( new ScDBCollection( *pUndoDB ), TRUE );
 
 	if (!bCopy)
+    {
+        pDoc->InvalidatePageBreaks(nTab);    
 		pDoc->UpdatePageBreaks( nTab );
+    }
 
     ScRange aDirtyRange( 0 , aQueryParam.nRow1, nTab,
         MAXCOL, aQueryParam.nRow2, nTab );
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index d4cfb42..53f0d52 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -7150,7 +7150,7 @@ uno::Sequence<sheet::TablePageBreakData> SAL_CALL ScTableSheetObj::getColumnPage
 		SCCOL nCount = 0;
 		SCCOL nCol;
 		for (nCol=0; nCol<=MAXCOL; nCol++)
-			if (pDoc->GetColFlags( nCol, nTab ) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+            if (pDoc->HasColBreak(nCol, nTab))
 				++nCount;
 
 		sheet::TablePageBreakData aData;
@@ -7159,11 +7159,11 @@ uno::Sequence<sheet::TablePageBreakData> SAL_CALL ScTableSheetObj::getColumnPage
 		USHORT nPos = 0;
 		for (nCol=0; nCol<=MAXCOL; nCol++)
 		{
-			BYTE nFlags = pDoc->GetColFlags( nCol, nTab );
-			if (nFlags & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            if (nBreak)
 			{
 				aData.Position	  = nCol;
-				aData.ManualBreak = ( nFlags & CR_MANUALBREAK ) != 0;
+                aData.ManualBreak = (nBreak & BREAK_MANUAL);
 				pAry[nPos] = aData;
 				++nPos;
 			}
@@ -7192,33 +7192,7 @@ uno::Sequence<sheet::TablePageBreakData> SAL_CALL ScTableSheetObj::getRowPageBre
 			ScPrintFunc aPrintFunc( pDocSh, pDocSh->GetPrinter(), nTab );
 			aPrintFunc.UpdatePages();
 		}
-
-        SCROW nCount = pDoc->GetRowFlagsArray( nTab).CountForAnyBitCondition(
-                0, MAXROW, (CR_PAGEBREAK | CR_MANUALBREAK));
-
-		uno::Sequence<sheet::TablePageBreakData> aSeq(nCount);
-        if (nCount)
-        {
-            sheet::TablePageBreakData aData;
-            sheet::TablePageBreakData* pAry = aSeq.getArray();
-            size_t nPos = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray( nTab), 0, MAXROW);
-            do
-            {
-                BYTE nFlags = *aIter;
-                if (nFlags & ( CR_PAGEBREAK | CR_MANUALBREAK ))
-                {
-                    for (SCROW nRow = aIter.GetRangeStart(); nRow <= aIter.GetRangeEnd(); ++nRow)
-                    {
-                        aData.Position	  = nRow;
-                        aData.ManualBreak = ( nFlags & CR_MANUALBREAK ) != 0;
-                        pAry[nPos] = aData;
-                        ++nPos;
-                    }
-                }
-            } while (aIter.NextRange());
-        }
-		return aSeq;
+        return pDoc->GetRowBreakData(nTab);
 	}
 	return uno::Sequence<sheet::TablePageBreakData>(0);
 }
@@ -8987,13 +8961,13 @@ void ScTableColumnObj::GetOnePropertyValue( const SfxItemPropertyMap* pMap,
 		}
 		else if ( pMap->nWID == SC_WID_UNO_NEWPAGE )
 		{
-			BOOL bBreak = ( 0 != (pDoc->GetColFlags( nCol, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-			ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
 		}
 		else if ( pMap->nWID == SC_WID_UNO_MANPAGE )
 		{
-			BOOL bBreak = ( 0 != (pDoc->GetColFlags( nCol, nTab ) & (CR_MANUALBREAK)) );
-			ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasColBreak(nCol, nTab);
+            ScUnoHelpFunctions::SetBoolInAny(rAny, (nBreak & BREAK_MANUAL));
 		}
 		else
 			ScCellRangeObj::GetOnePropertyValue(pMap, rAny);
@@ -9151,13 +9125,13 @@ void ScTableRowObj::GetOnePropertyValue( const SfxItemPropertyMap* pMap,
 		}
 		else if ( pMap->nWID == SC_WID_UNO_NEWPAGE )
 		{
-			BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nRow, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-			ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = pDoc->HasRowBreak(nRow, nTab);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
 		}
 		else if ( pMap->nWID == SC_WID_UNO_MANPAGE )
 		{
-			BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nRow, nTab ) & (CR_MANUALBREAK)) );
-			ScUnoHelpFunctions::SetBoolInAny( rAny, bBreak );
+            ScBreakType nBreak = (pDoc->HasRowBreak(nRow, nTab) & BREAK_MANUAL);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, nBreak );
 		}
 		else
 			ScCellRangeObj::GetOnePropertyValue(pMap, rAny);
diff --git sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
index f14ab4a..f2f1eb5 100644
--- sc/source/ui/unoobj/docuno.cxx
+++ sc/source/ui/unoobj/docuno.cxx
@@ -2685,13 +2685,13 @@ uno::Any SAL_CALL ScTableColumnsObj::getPropertyValue( const rtl::OUString& aPro
 	}
 	else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE ) )
 	{
-		BOOL bBreak = ( 0 != (pDoc->GetColFlags( nStartCol, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-		ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasColBreak(nStartCol, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, nBreak );
 	}
 	else if ( aNameString.EqualsAscii( SC_UNONAME_MANPAGE ) )
 	{
-		BOOL bBreak = ( 0 != (pDoc->GetColFlags( nStartCol, nTab ) & (CR_MANUALBREAK)) );
-		ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasColBreak(nStartCol, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, (nBreak & BREAK_MANUAL) );
 	}
 
 	return aAny;
@@ -2939,13 +2939,13 @@ uno::Any SAL_CALL ScTableRowsObj::getPropertyValue( const rtl::OUString& aProper
 	}
 	else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE ) )
 	{
-		BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nStartRow, nTab ) & (CR_PAGEBREAK|CR_MANUALBREAK)) );
-		ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasRowBreak(nStartRow, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, nBreak );
 	}
 	else if ( aNameString.EqualsAscii( SC_UNONAME_MANPAGE ) )
 	{
-		BOOL bBreak = ( 0 != (pDoc->GetRowFlags( nStartRow, nTab ) & (CR_MANUALBREAK)) );
-		ScUnoHelpFunctions::SetBoolInAny( aAny, bBreak );
+        ScBreakType nBreak = pDoc->HasRowBreak(nStartRow, nTab);
+        ScUnoHelpFunctions::SetBoolInAny( aAny, (nBreak & BREAK_MANUAL) );
 	}
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLBACK ) || aNameString.EqualsAscii( SC_UNONAME_CELLTRAN ) )
     {
diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
index 634443a..986c376 100644
--- sc/source/ui/vba/vbarange.cxx
+++ sc/source/ui/vba/vbarange.cxx
@@ -3719,16 +3719,16 @@ ScVbaRange::getPageBreak() throw (uno::RuntimeException)
 		{
 	        ScDocument* pDoc =  getDocumentFromRange( mxRange );
 	        
-			BYTE nFlag = 0;
+            ScBreakType nBreak = BREAK_NONE;
 			if ( !bColumn )
-			    nFlag = pDoc -> GetRowFlags(thisAddress.StartRow, thisAddress.Sheet);
+                nBreak = pDoc->HasRowBreak(thisAddress.StartRow, thisAddress.Sheet);
 			else
-			    nFlag = pDoc -> GetColFlags(static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.Sheet);
+                nBreak = pDoc->HasColBreak(thisAddress.StartColumn, thisAddress.Sheet);
 			    
-			if ( nFlag & CR_PAGEBREAK)
+            if (nBreak & BREAK_PAGE)
 			    nPageBreak = excel::XlPageBreak::xlPageBreakAutomatic;
 			    
-			if ( nFlag & CR_MANUALBREAK)
+            if (nBreak & BREAK_MANUAL)
 			    nPageBreak = excel::XlPageBreak::xlPageBreakManual;
 		}		
 	}
diff --git sc/source/ui/view/cellsh.cxx sc/source/ui/view/cellsh.cxx
index 3c047da..f228c30 100644
--- sc/source/ui/view/cellsh.cxx
+++ sc/source/ui/view/cellsh.cxx
@@ -717,22 +717,22 @@ void ScCellShell::GetState(SfxItemSet &rSet)
                 break;
 
 			case FID_INS_ROWBRK:
-				if ( nPosY==0 || (pDoc->GetRowFlags(nPosY,nTab) & CR_MANUALBREAK) )
+                if ( nPosY==0 || (pDoc->HasRowBreak(nPosY, nTab) & BREAK_MANUAL) )
 					rSet.DisableItem( nWhich );
 				break;
 
 			case FID_INS_COLBRK:
-				if ( nPosX==0 || (pDoc->GetColFlags(nPosX,nTab) & CR_MANUALBREAK) )
+                if ( nPosX==0 || (pDoc->HasColBreak(nPosX, nTab) & BREAK_MANUAL) )
 					rSet.DisableItem( nWhich );
 				break;
 
 			case FID_DEL_ROWBRK:
-				if ( nPosY==0 || (pDoc->GetRowFlags(nPosY,nTab) & CR_MANUALBREAK)==0 )
+                if ( nPosY==0 || (pDoc->HasRowBreak(nPosY, nTab) & BREAK_MANUAL) == 0 )
 					rSet.DisableItem( nWhich );
 				break;
 
 			case FID_DEL_COLBRK:
-				if ( nPosX==0 || (pDoc->GetColFlags(nPosX,nTab) & CR_MANUALBREAK)==0 )
+                if ( nPosX==0 || (pDoc->HasColBreak(nPosX, nTab) & BREAK_MANUAL) == 0 )
 					rSet.DisableItem( nWhich );
 				break;
 
diff --git sc/source/ui/view/gridwin2.cxx sc/source/ui/view/gridwin2.cxx
index 72a6606..4434440 100644
--- sc/source/ui/view/gridwin2.cxx
+++ sc/source/ui/view/gridwin2.cxx
@@ -1278,7 +1278,7 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
 				BOOL bGrow = !bHide && nNew > nPagebreakBreak;
 				if ( bColumn )
 				{
-					if ( pDoc->GetColFlags( static_cast<SCCOL>(nPagebreakBreak), nTab ) & CR_MANUALBREAK )
+                    if (pDoc->HasColBreak(static_cast<SCCOL>(nPagebreakBreak), nTab) & BREAK_MANUAL)
 					{
 						ScAddress aOldAddr( static_cast<SCCOL>(nPagebreakBreak), nPosY, nTab );
 						pViewFunc->DeletePageBreak( TRUE, TRUE, &aOldAddr, FALSE );
@@ -1291,8 +1291,8 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
 					if ( bGrow )
 					{
 						//	vorigen Break auf hart, und Skalierung aendern
-						if ( static_cast<SCCOL>(nPagebreakPrev) > aPagebreakSource.aStart.Col() &&
-								!(pDoc->GetColFlags( static_cast<SCCOL>(nPagebreakPrev), nTab ) & CR_MANUALBREAK) )
+                        bool bManualBreak = (pDoc->HasColBreak(static_cast<SCCOL>(nPagebreakPrev), nTab) & BREAK_MANUAL);
+                        if ( static_cast<SCCOL>(nPagebreakPrev) > aPagebreakSource.aStart.Col() && !bManualBreak )
 						{
 							ScAddress aPrev( static_cast<SCCOL>(nPagebreakPrev), nPosY, nTab );
 							pViewFunc->InsertPageBreak( TRUE, TRUE, &aPrev, FALSE );
@@ -1305,7 +1305,7 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
 				}
 				else
 				{
-					if ( pDoc->GetRowFlags( nPagebreakBreak, nTab ) & CR_MANUALBREAK )
+                    if (pDoc->HasRowBreak(nPagebreakBreak, nTab) & BREAK_MANUAL)
 					{
 						ScAddress aOldAddr( nPosX, nPagebreakBreak, nTab );
 						pViewFunc->DeletePageBreak( FALSE, TRUE, &aOldAddr, FALSE );
@@ -1318,8 +1318,8 @@ void ScGridWindow::PagebreakMove( const MouseEvent& rMEvt, BOOL bUp )
 					if ( bGrow )
 					{
 						//	vorigen Break auf hart, und Skalierung aendern
-						if ( nPagebreakPrev > aPagebreakSource.aStart.Row() &&
-								!(pDoc->GetRowFlags( nPagebreakPrev, nTab ) & CR_MANUALBREAK) )
+                        bool bManualBreak = (pDoc->HasRowBreak(nPagebreakPrev, nTab) & BREAK_MANUAL);
+                        if ( nPagebreakPrev > aPagebreakSource.aStart.Row() && !bManualBreak )
 						{
 							ScAddress aPrev( nPosX, nPagebreakPrev, nTab );
 							pViewFunc->InsertPageBreak( FALSE, TRUE, &aPrev, FALSE );
diff --git sc/source/ui/view/gridwin4.cxx sc/source/ui/view/gridwin4.cxx
index 0e0742a..2e88791 100644
--- sc/source/ui/view/gridwin4.cxx
+++ sc/source/ui/view/gridwin4.cxx
@@ -1090,7 +1090,7 @@ void ScGridWindow::DrawPagePreview( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
 					if ( nBreak >= nX1 && nBreak <= nX2+1 )
 					{
 						//! hidden suchen
-						if ( pDoc->GetColFlags( nBreak, nTab ) & CR_MANUALBREAK )
+                        if (pDoc->HasColBreak(nBreak, nTab) & BREAK_MANUAL)
 							pContentDev->SetFillColor( aManual );
 						else
 							pContentDev->SetFillColor( aAutomatic );
@@ -1109,7 +1109,7 @@ void ScGridWindow::DrawPagePreview( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
 					if ( nBreak >= nY1 && nBreak <= nY2+1 )
 					{
 						//! hidden suchen
-						if ( pDoc->GetRowFlags( nBreak, nTab ) & CR_MANUALBREAK )
+                        if (pDoc->HasRowBreak(nBreak, nTab) & BREAK_MANUAL)
 							pContentDev->SetFillColor( aManual );
 						else
 							pContentDev->SetFillColor( aAutomatic );
diff --git sc/source/ui/view/output.cxx sc/source/ui/view/output.cxx
index f320558..1585791 100644
--- sc/source/ui/view/output.cxx
+++ sc/source/ui/view/output.cxx
@@ -325,8 +325,9 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
 	long nPosX;
 	long nPosY;
 	SCSIZE nArrY;
-	BYTE nOldFlags = 0;
-	BYTE nFlags;
+    ScBreakType nBreak    = BREAK_NONE;
+    ScBreakType nBreakOld = BREAK_NONE;
+
 	BOOL bSingle;
 	Color aPageColor;
 	Color aManualColor;
@@ -381,27 +382,27 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
 			if ( bPage )
 			{
 				//	Seitenumbrueche auch in ausgeblendeten suchen
-				nFlags = 0;
 				SCCOL nCol = nXplus1;
 				while (nCol <= MAXCOL)
 				{
 					BYTE nDocFl = pDoc->GetColFlags( nCol, nTab );
-					nFlags = nDocFl & ( CR_PAGEBREAK | CR_MANUALBREAK );
-					if ( nFlags || !(nDocFl & CR_HIDDEN) )
+                    nBreak = pDoc->HasColBreak(nCol, nTab);
+
+                    if ( nBreak || !(nDocFl & CR_HIDDEN) )
 						break;
 					++nCol;
 				}
 
-				if (nFlags != nOldFlags)
+                if (nBreak != nBreakOld)
 				{
 					aGrid.Flush();
-					pDev->SetLineColor( (nFlags & CR_MANUALBREAK) ? aManualColor :
-									 (nFlags) ? aPageColor : aGridColor );
-					nOldFlags = nFlags;
+                    pDev->SetLineColor( (nBreak & BREAK_MANUAL) ? aManualColor :
+                                        nBreak ? aPageColor : aGridColor );
+                    nBreakOld = nBreak;
 				}
 			}
 
-			BOOL bDraw = bGrid || nOldFlags;	// einfaches Gitter nur wenn eingestellt
+			BOOL bDraw = bGrid || nBreakOld;	// einfaches Gitter nur wenn eingestellt
 
 			//!	Mit dieser Abfrage wird zuviel weggelassen, wenn ein automatischer
 			//!	Umbruch mitten in den Wiederholungsspalten liegt.
@@ -412,7 +413,7 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
 			{
 				if ( nX == MAXCOL )
 					bDraw = FALSE;
-				else if (pDoc->GetColFlags(nXplus1,nTab) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+                else if (pDoc->HasColBreak(nXplus1, nTab))
 					bDraw = FALSE;
 			}
 #endif
@@ -503,28 +504,24 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
 		{
 			if ( bPage )
 			{
-				//	Seitenumbrueche auch in ausgeblendeten suchen
-				nFlags = 0;
-                ScCompressedArrayIterator< SCROW, BYTE > aIter(
-                        pDoc->GetRowFlagsArray( nTab), nYplus1, MAXROW);
-                do
+                for (SCROW i = nYplus1; i <= MAXROW; ++i)
                 {
-					BYTE nDocFl = *aIter;
-					nFlags = nDocFl & ( CR_PAGEBREAK | CR_MANUALBREAK );
-					if ( nFlags || !(nDocFl & CR_HIDDEN) )
-						break;
-                } while (aIter.NextRange());
+                    nBreak = pDoc->HasRowBreak(i, nTab);
+                    bool bHidden = (pDoc->GetRowFlags(i, nTab) & CR_HIDDEN);
+                    if (nBreak || !bHidden)
+                        break;
+                }
 
-				if (nFlags != nOldFlags)
+                if (nBreakOld != nBreak)
 				{
 					aGrid.Flush();
-					pDev->SetLineColor( (nFlags & CR_MANUALBREAK) ? aManualColor :
-									 (nFlags) ? aPageColor : aGridColor );
-					nOldFlags = nFlags;
+					pDev->SetLineColor( (nBreak & BREAK_MANUAL) ? aManualColor :
+                                        (nBreak) ? aPageColor : aGridColor );
+                    nBreakOld = nBreak;
 				}
 			}
 
-			BOOL bDraw = bGrid || nOldFlags;	// einfaches Gitter nur wenn eingestellt
+			BOOL bDraw = bGrid || nBreakOld;	// einfaches Gitter nur wenn eingestellt
 
 			//!	Mit dieser Abfrage wird zuviel weggelassen, wenn ein automatischer
 			//!	Umbruch mitten in den Wiederholungszeilen liegt.
@@ -535,7 +532,7 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
 			{
 				if ( nY == MAXROW )
 					bDraw = FALSE;
-				else if (pDoc->GetRowFlags(nYplus1,nTab) & ( CR_PAGEBREAK | CR_MANUALBREAK ))
+                else if (pDoc->HasRowBreak(nYplus1, nTab))
 					bDraw = FALSE;
 			}
 #endif
diff --git sc/source/ui/view/printfun.cxx sc/source/ui/view/printfun.cxx
index 020821d..2ddaa99 100644
--- sc/source/ui/view/printfun.cxx
+++ sc/source/ui/view/printfun.cxx
@@ -2874,30 +2874,84 @@ void ScPrintFunc::CalcZoom( USHORT nRangeNo )						// Zoom berechnen
 	if (aTableParam.bScalePageNum)
 	{
 		nZoom = 100;
-		BOOL bFound = FALSE;
 		USHORT nPagesToFit = aTableParam.nScalePageNum;
-		while (!bFound)
-		{
-			CalcPages();
-			if ( nPagesX * nPagesY <= nPagesToFit || nZoom <= ZOOM_MIN )
-				bFound = TRUE;
-			else
-				--nZoom;
-		}
+
+        sal_uInt16 nLastFitZoom = 0, nLastNonFitZoom = 0;
+        while (true)
+        {
+            if (nZoom <= ZOOM_MIN)
+                break;
+
+            CalcPages();
+            bool bFitsPage = (nPagesX * nPagesY <= nPagesToFit);
+
+            if (bFitsPage)
+            {
+                if (nZoom == 100)
+                    // If it fits at 100 %, it's good enough for me.
+                    break;
+                
+                nLastFitZoom = nZoom;
+                nZoom = (nLastNonFitZoom + nZoom) / 2;
+
+                if (nLastFitZoom == nZoom)
+                    // It converged.  Use this zoom level.
+                    break;
+            }
+            else
+            {
+                if (nZoom - nLastFitZoom <= 1)
+                {
+                    nZoom = nLastFitZoom;
+                    CalcPages();
+                    break;
+                }
+
+                nLastNonFitZoom = nZoom;
+                nZoom = (nLastFitZoom + nZoom) / 2;
+            }
+        }
 	}
     else if (aTableParam.bScaleTo)
     {
         nZoom = 100;
-        BOOL bFound = FALSE;
         USHORT nW = aTableParam.nScaleWidth;
         USHORT nH = aTableParam.nScaleHeight;
-        while (!bFound)
+
+        sal_uInt16 nLastFitZoom = 0, nLastNonFitZoom = 0;
+        while (true)
         {
+            if (nZoom <= ZOOM_MIN)
+                break;
+
             CalcPages();
-            if ( ((!nW || (nPagesX <= nW)) && (!nH || (nPagesY <= nH))) || (nZoom <= ZOOM_MIN) )
-                bFound = TRUE;
+            bool bFitsPage = ((!nW || (nPagesX <= nW)) && (!nH || (nPagesY <= nH)));
+
+            if (bFitsPage)
+            {
+                if (nZoom == 100)
+                    // If it fits at 100 %, it's good enough for me.
+                    break;
+                
+                nLastFitZoom = nZoom;
+                nZoom = (nLastNonFitZoom + nZoom) / 2;
+
+                if (nLastFitZoom == nZoom)
+                    // It converged.  Use this zoom level.
+                    break;
+            }
             else
-                --nZoom;
+            {
+                if (nZoom - nLastFitZoom <= 1)
+                {
+                    nZoom = nLastFitZoom;
+                    CalcPages();
+                    break;
+                }
+
+                nLastNonFitZoom = nZoom;
+                nZoom = (nLastFitZoom + nZoom) / 2;
+            }
         }
     }
 	else if (aTableParam.bScaleAll)
@@ -3021,7 +3075,8 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
 	for (SCCOL i=nStartCol; i<=nEndCol; i++)
 	{
 		BYTE nFlags = pDoc->GetColFlags(i,nPrintTab);
-		if ( i>nStartCol && bVisCol && (nFlags & CR_PAGEBREAK) )
+        bool bPageBreak = (pDoc->HasColBreak(i, nPrintTab) & BREAK_PAGE);
+        if ( i>nStartCol && bVisCol && bPageBreak )
 		{
 			pPageEndX[nPagesX] = i-1;
 			++nPagesX;
@@ -3046,7 +3101,8 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
         SCROW nRangeEnd = aIter.GetRangeEnd();
         for (SCROW j=aIter.GetRangeStart(); j<=nRangeEnd; ++j)
         {
-            if ( j>nStartRow && bVisRow && (nFlags & CR_PAGEBREAK) )
+            bool bPageBreak = (pDoc->HasRowBreak(j, nPrintTab) & BREAK_PAGE);
+            if ( j>nStartRow && bVisRow && bPageBreak )
             {
                 pPageEndY[nTotalY] = j-1;
                 ++nTotalY;
