cocofan's gsoc patches

From: Thorsten Behrens <thb@openoffice.org>


---

 offapi/com/sun/star/presentation/XLayoutList.idl   |  171 ++
 offapi/com/sun/star/presentation/makefile.mk       |    3 
 scp2/source/ooo/profileitem_ooo.scp                |    9 
 sd/inc/Test.hxx                                    |   43 +
 sd/inc/drawdoc.hxx                                 |   17 
 sd/inc/layoutlist.hxx                              |  270 ++++
 sd/inc/layouttype.hxx                              |  228 +++
 sd/inc/pres.hxx                                    |   50 -
 sd/inc/sdpage.hxx                                  |   12 
 sd/source/core/drawdoc.cxx                         |  100 +
 sd/source/core/drawdoc3.cxx                        |    6 
 sd/source/core/layoutlist.cxx                      | 1375 ++++++++++++++++++++
 sd/source/core/layouttype.cxx                      |  859 ++++++++++++
 sd/source/core/makefile.mk                         |    2 
 sd/source/core/sdpage.cxx                          |  463 ++-----
 sd/source/filter/ppt/pptin.cxx                     |    2 
 sd/source/filter/ppt/pptin.hxx                     |    1 
 sd/source/ui/func/unprlout.cxx                     |    4 
 sd/source/ui/inc/ViewShellImplementation.hxx       |    3 
 sd/source/ui/inc/unmodpg.hxx                       |    7 
 sd/source/ui/inc/unprlout.hxx                      |   11 
 .../ui/slidesorter/controller/SlsSlotManager.cxx   |    2 
 sd/source/ui/toolpanel/LayoutMenu.cxx              |  187 +--
 sd/source/ui/toolpanel/LayoutMenu.hxx              |    7 
 sd/source/ui/unoidl/unopage.cxx                    |   15 
 sd/source/ui/view/ViewShellImplementation.cxx      |   20 
 sd/source/ui/view/unmodpg.cxx                      |    2 
 sd/source/ui/view/viewshe3.cxx                     |   31 
 sd/test/export.map                                 |   38 +
 sd/test/layouttest.cxx                             |  323 +++++
 sd/test/makefile.mk                                |   91 +
 sd/util/makefile.mk                                |    3 
 xmloff/source/draw/sdxmlexp.cxx                    |  680 +++-------
 33 files changed, 4022 insertions(+), 1013 deletions(-)
 create mode 100644 offapi/com/sun/star/presentation/XLayoutList.idl
 create mode 100644 sd/inc/Test.hxx
 create mode 100644 sd/inc/layoutlist.hxx
 create mode 100644 sd/inc/layouttype.hxx
 create mode 100644 sd/source/core/layoutlist.cxx
 create mode 100644 sd/source/core/layouttype.cxx
 create mode 100644 sd/test/export.map
 create mode 100644 sd/test/layouttest.cxx
 create mode 100644 sd/test/makefile.mk


diff --git offapi/com/sun/star/presentation/XLayoutList.idl offapi/com/sun/star/presentation/XLayoutList.idl
new file mode 100644
index 0000000..3b70b93
--- /dev/null
+++ offapi/com/sun/star/presentation/XLayoutList.idl
@@ -0,0 +1,171 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLayoutList.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_presentation_XLayoutList_idl__
+#define __com_sun_star_presentation_XLayoutList_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+
+#ifndef __com_sun_star_awt_Rectangle_idl__ 
+#include <com/sun/star/awt/Rectangle.idl> 
+#endif 
+
+#ifndef __com_sun_star_awt_Size_idl__ 
+#include <com/sun/star/awt/Size.idl> 
+#endif 
+ 
+
+//=============================================================================
+
+module com {  module sun {  module star {  module presentation {
+
+//============================================================================
+/** for determining autolayout builtins.  This should
+  * match the enum AutoLayoutBuiltins in the sd/inc/layoutlist.hxx
+  */
+
+enum UnoAutoLayout
+{
+   TITLE,
+   ENUM,
+   CHART,
+   2TEXT,
+   TEXTCHART,
+   ORG,
+   TEXTCLIP,
+   CHARTTEXT,
+   TAB,
+   CLIPTEXT,
+   TEXTOBJ,
+   OBJ,
+   TEXT2OBJ,
+   OBJTEXT,
+   OBJOVERTEXT,
+   2OBJTEXT,
+   2OBJOVERTEXT,
+   TEXTOVEROBJ,
+   4OBJ,
+   ONLY_TITLE,
+   NONE,
+   NOTES,
+   HANDOUT1,
+   HANDOUT2,
+   HANDOUT3,
+   HANDOUT4,
+   HANDOUT6,
+   VERTICAL_TITLE_TEXT_CHART,
+   VERTICAL_TITLE_VERTICAL_OUTLINE,
+   TITLE_VERTICAL_OUTLINE,
+   TITLE_VERTICAL_OUTLINE_CLIPART,
+   HANDOUT9,
+   ONLY_TEXT,
+   NUM_OF_BUILTINS 
+};
+
+//=============================================================================
+/** for determining type of presentation object
+  * This should match the enum PresObjKind in sd/inc/pres.hxx 
+  */
+enum UnoPresKind {
+    NONE,
+	TITLE,
+	OUTLINE,
+	TEXT,
+	GRAPHIC,
+	OBJECT,
+	CHART,
+	ORGCHART,
+    TABLE,
+	IMAGE,
+	BACKGROUND,
+	PAGE,
+	HANDOUT,
+	NOTES,
+	HEADER,
+    FOOTER,
+	DATETIME,
+	SLIDENUMBER,
+	MAX
+};
+
+//============================================================================
+/** For determining the page kind.
+  * This should match the enum PageKind in sd/inc/pres.hxx 
+  */
+
+enum UnoPageKind {
+    STANDARD,
+    NOTES,
+    HANDOUT
+};
+
+
+//=============================================================================
+/** The interface for the layout list.  Layout list stores information
+ *  on autolayouts (builtin and custom).
+ */
+ 
+interface XLayoutList : ::com::sun::star::uno::XInterface
+{
+
+   /** gets bounding rectangles for an autolayout (one rect for each elem) */
+
+   sequence< ::com::sun::star::awt::Rectangle > getAutoLayoutRectangles( [in] long Index,
+                                                                         [in]  ::com::sun::star::awt::Rectangle title,
+                                                                         [in]  ::com::sun::star::awt::Rectangle layout,
+                                                                         [in]  ::com::sun::star::awt::Size page,
+                                                                         [in]  boolean bRightToLeft);
+  /** gets the page kind (PK_STANDARD, PK_NOTES, PK_HANDOUT) for an autolayout */
+  
+  UnoPageKind getPageKind( [in] long Index);
+  
+  /** gets the number of elements for the given autolayout */
+  
+  long getElementCount( [in] long Index );
+  
+  /** gets the presentation object kind for the given layout's nth element */
+  
+  UnoPresKind getPresKind( [in] long Index, 
+                           [in] long ElemIdx );
+                           
+  /** gets whether the presentation object is vertical */
+  
+  boolean  isVertical( [in] long Index,
+                       [in] long ElemIdx );
+  
+
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git offapi/com/sun/star/presentation/makefile.mk offapi/com/sun/star/presentation/makefile.mk
index 31a59b0..91471b9 100644
--- offapi/com/sun/star/presentation/makefile.mk
+++ offapi/com/sun/star/presentation/makefile.mk
@@ -92,7 +92,8 @@ IDLFILES=\
     XSlideShowView.idl\
     XPresentation2.idl\
     XTransition.idl\
-    XTransitionFactory.idl
+	XTransitionFactory.idl\
+	XLayoutList.idl
 
 # ------------------------------------------------------------------
 
diff --git scp2/source/ooo/profileitem_ooo.scp scp2/source/ooo/profileitem_ooo.scp
index eaadad0..c1c881f 100644
--- scp2/source/ooo/profileitem_ooo.scp
+++ scp2/source/ooo/profileitem_ooo.scp
@@ -499,6 +499,15 @@ ProfileItem gid_Profileitem_Uno_Pkg_UserUnoFile
     Value = "$UNO_USER_PACKAGES_CACHE/registry/com.sun.star.comp.deployment.component.PackageRegistryBackend/unorc";
 End
 
+ProfileItem gid_Profileitem_Impress_Autolayout_cfgurl
+    ProfileID = gid_Profile_Fundamentalbasis_Ini;
+    ModuleID = gid_Module_Root;
+    Section   = "Bootstrap";
+    Order = 13;
+    Key  = "Impress_CfgUrl";
+    Value = "${${BRAND_BASE_DIR}/program/" PROFILENAME(bootstrap) ":UserInstallation}/user/config";
+End
+
 ProfileItem gid_Profileitem_Fundamentalbasis_Uno_Shared_Packages_Cache
     ModuleID = gid_Module_Root;
     ProfileID = gid_Profile_Fundamentalbasis_Ini;
diff --git sd/inc/Test.hxx sd/inc/Test.hxx
new file mode 100644
index 0000000..c7c1814
--- /dev/null
+++ sd/inc/Test.hxx
@@ -0,0 +1,43 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: LayoutMenu.cxx,v $
+ * $Revision: 1.27 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef _TEST_HXX
+#define _TEST_HXX
+
+#include <vector>
+
+#include "sal/types.h"
+#include "rtl/ustring.hxx"
+#include "tools/string.hxx"
+#include "pres.hxx"
+
+using namespace rtl;
+
+#endif
+
diff --git sd/inc/drawdoc.hxx sd/inc/drawdoc.hxx
index c8c8d40..2d0b6bb 100644
--- sd/inc/drawdoc.hxx
+++ sd/inc/drawdoc.hxx
@@ -57,6 +57,11 @@
 #endif
 #include "sddllapi.h"
 #include "sdpage.hxx"
+#include "layoutlist.hxx"
+
+
+sd::LayoutList* GetLayoutList();
+
 
 namespace com
 {
@@ -522,8 +527,8 @@ public:
         PageKind ePageKind,
         const String& sStandardPageName,
         const String& sNotesPageName,
-        AutoLayout eStandardLayout,
-        AutoLayout eNotesLayout,
+        sd::AutoLayout eStandardLayout,
+        sd::AutoLayout eNotesLayout,
         BOOL bIsPageBack,
         BOOL bIsPageObj);
 
@@ -578,8 +583,8 @@ public:
         PageKind ePageKind,
         const String& sStandardPageName,
         const String& sNotesPageName,
-        AutoLayout eStandardLayout,
-        AutoLayout eNotesLayout,
+        sd::AutoLayout eStandardLayout,
+        sd::AutoLayout eNotesLayout,
         BOOL bIsPageBack,
         BOOL bIsPageObj);
 
@@ -643,8 +648,8 @@ private:
         PageKind ePageKind,
         const String& sStandardPageName,
         const String& sNotesPageName,
-        AutoLayout eStandardLayout,
-        AutoLayout eNotesLayout,
+        sd::AutoLayout eStandardLayout,
+        sd::AutoLayout eNotesLayout,
         BOOL bIsPageBack,
         BOOL bIsPageObj,
 
diff --git sd/inc/layoutlist.hxx sd/inc/layoutlist.hxx
new file mode 100644
index 0000000..c3a12ee
--- /dev/null
+++ sd/inc/layoutlist.hxx
@@ -0,0 +1,270 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: layoutlist.hxx,v $
+ * $Revision: 0.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+#ifndef _LAYOUTLIST_HXX
+#define _LAYOUTLIST_HXX
+
+
+#define LL_NOT_FOUND 100000
+
+#include <vector>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/uno/Sequence.hxx>
+#include <com/sun/star/awt/Rectangle.hpp>
+#include <com/sun/star/awt/Size.hpp>
+#include <com/sun/star/awt/Point.hpp>
+#include <com/sun/star/presentation/XLayoutList.hpp>
+#include <com/sun/star/presentation/UnoAutoLayout.hpp>
+#include <com/sun/star/presentation/UnoPageKind.hpp>
+#include <com/sun/star/presentation/UnoPresKind.hpp>
+#include <com/sun/star/xml/dom/XDocumentBuilder.hpp>
+#include "layouttype.hxx"
+#include "sal/types.h"
+#include "tools/string.hxx"
+#include "sdresid.hxx"
+#include "../source/ui/inc/strings.hrc"
+#include "../source/ui/inc/res_bmp.hrc"
+#include "pres.hxx"
+
+// needed for pptin.cxx (PowerPoint filter)
+// among other files. Also, for calculating
+// handouts and notes.
+
+/** There's is a corresponding UnoAutoLayout in
+ *  /offapi/com/sun/star/presentation/XLayoutList.idl
+ *  If you change anything below, please change the corresponding
+ *  Uno code.
+ */
+
+enum AutoLayoutBuiltin {
+    AUTOLAYOUT_TITLE = 0,
+ 	AUTOLAYOUT_ENUM,
+ 	AUTOLAYOUT_CHART,
+ 	AUTOLAYOUT_2TEXT,
+ 	AUTOLAYOUT_TEXTCHART,
+ 	AUTOLAYOUT_ORG,
+ 	AUTOLAYOUT_TEXTCLIP,
+ 	AUTOLAYOUT_CHARTTEXT,
+ 	AUTOLAYOUT_TAB,
+ 	AUTOLAYOUT_CLIPTEXT,
+ 	AUTOLAYOUT_TEXTOBJ,
+ 	AUTOLAYOUT_OBJ,
+ 	AUTOLAYOUT_TEXT2OBJ,
+ 	AUTOLAYOUT_OBJTEXT,
+ 	AUTOLAYOUT_OBJOVERTEXT,
+ 	AUTOLAYOUT_2OBJTEXT,
+ 	AUTOLAYOUT_2OBJOVERTEXT,
+ 	AUTOLAYOUT_TEXTOVEROBJ,
+ 	AUTOLAYOUT_4OBJ,
+ 	AUTOLAYOUT_ONLY_TITLE,
+ 	AUTOLAYOUT_NONE,
+ 	AUTOLAYOUT_NOTES,
+	AUTOLAYOUT_HANDOUT1,
+ 	AUTOLAYOUT_HANDOUT2,
+ 	AUTOLAYOUT_HANDOUT3,
+ 	AUTOLAYOUT_HANDOUT4,    
+ 	AUTOLAYOUT_HANDOUT6,
+ 	AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART,
+ 	AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE,
+ 	AUTOLAYOUT_TITLE_VERTICAL_OUTLINE,
+ 	AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART,
+ 	AUTOLAYOUT_HANDOUT9,
+    AUTOLAYOUT_ONLY_TEXT,
+    AL_NUM_OF_BUILTINS 
+};
+    
+
+
+
+namespace sd {
+   
+   typedef sal_Int32 AutoLayout;
+   
+   class LayoutList: public ::cppu::WeakImplHelper1< ::com::sun::star::presentation::XLayoutList >
+   {
+   public:
+       
+	   LayoutList(bool testing=false);
+	   ~LayoutList();
+    
+       /** passes back the absolute path plus file name
+        *  of the autolayout configuration file. 
+        */   
+       String* getConfigFile();
+    
+       /** write entire layout information to a config file
+        */
+       void writeToFile();
+      
+       
+       /** read entire layout information to a config file
+        */
+        void readFromFile();
+		   
+	   /** adds a layout object to the list
+	    *  passes back a true if the layout
+		*  was successfully added and passes back
+		*  a false if not (name already in the list,
+		*  for example). Also, adds to the given 
+		*  menu list at the given index (or at
+		*  the end if the index is negative(-1)) */
+	   bool addLayout(LayoutType* pLayout, const sal_Int32& menuIndex,
+	                  const PageKind& eMenu);
+		
+	   /** removes a custom layout from the layout list
+        *  but doesn't remove builtins. 
+	    *  Deletes the layout object and sets a NULL
+        *  in the layout list so as not to change the
+        *  indices of the list.   It also finds the menu
+		*  entry and removes it completely.  Items will
+		*  be moved up in the menu list.
+		*/
+	   void deleteLayoutFromList(const LString& sName);
+	   
+	   /** return the length of the list. This may not be
+	    * the number of actual layouts in the list */
+	   sal_uInt32 length() const;
+
+	   /** return the number of actual layouts in the list 
+        */
+	   sal_uInt32 numberOfLayouts() const;
+
+       /** pass in the index to the list.  for iterating
+	     * the list. Will send back a NULL if a layout isn't there.
+         */
+	   LayoutType* getLayoutByIndex(const sal_uInt32 nIndex); 
+       
+       
+	
+		/** find and pass back a layout object with the given
+		   name or NULL */
+	   LayoutType* getLayoutByName(const LString& sName);
+	   
+	   /** get the autolayout value of the  given name. It will
+	    *  send back a LL_NOT_FOUND if there is no layout.  Need to
+		*  cast this value to a sal_uInt32 to use as an
+		*  index into the list. */
+	   sal_uInt32 getLayoutIndex(const LString& sName);
+       
+	   /** get the layout object for the given layoutMenu
+	    * index.
+	    */
+	   LayoutType* getLayoutAtMenuIndex(const sal_uInt32& nIndex,
+	                                    const PageKind& eMenu);
+	   
+	   /** get the size of a particular menu list */
+	   sal_uInt32 getMenuLength(const PageKind& eMenu);
+	   
+	   /** given an autolayout number, find the index in the menu.
+	    *   If not in the list, then passes back LL_NOT_FOUND*/
+	   sal_uInt32 getMenuIndex(const AutoLayout& nLayout,
+	                           const PageKind& nMenu);
+	   
+	   /** remove the autolayout from the list. Need to move 
+	    *  the layouts over.
+		*/
+	   void removeFromMenuList(const AutoLayout& lnum,
+	                           const PageKind& eMenu);
+	   
+	   /** add an autolayout to the menu list.  will grow
+	    *  the list to fit the given index.  A negative index
+		*  will cause the autolayout to be appended to the
+		* end of the list. */
+	   
+	   void addToMenuList(const sal_Int32& index,
+	                      const AutoLayout& lnum,
+						  const PageKind& eMenu);
+                          
+                          
+        /** UNO implementation of interface XLayoutList
+        *  for use with xmloff code
+        */
+         virtual ::com::sun::star::uno::Sequence< ::com::sun::star::awt::Rectangle > 
+                     SAL_CALL getAutoLayoutRectangles( ::sal_Int32 Index,
+                                                        const ::com::sun::star::awt::Rectangle& title,
+                                                        const ::com::sun::star::awt::Rectangle& layout,
+                                                        const ::com::sun::star::awt::Size& page,
+                                                        ::sal_Bool bRightToLeft )
+                                throw (::com::sun::star::uno::RuntimeException);
+        Rectangle UNORectToRect(const ::com::sun::star::awt::Rectangle& rect);
+        ::com::sun::star::awt::Rectangle RectToUNORect(const Rectangle& rect);
+        
+        
+        /** UNO implementation for getting the Page Kind of a layout
+         *  and the PresObjKind of an element in a layout
+         */
+        virtual ::com::sun::star::presentation::UnoPageKind SAL_CALL getPageKind( ::sal_Int32 Index )
+                                             throw (::com::sun::star::uno::RuntimeException);
+                                             
+                                             
+        virtual ::sal_Int32 SAL_CALL getElementCount( ::sal_Int32 Index) 
+                                             throw (::com::sun::star::uno::RuntimeException);
+        
+        virtual ::com::sun::star::presentation::UnoPresKind SAL_CALL getPresKind( ::sal_Int32 Index,
+                                                                                  ::sal_Int32 ElemIdx )
+                                            throw (::com::sun::star::uno::RuntimeException);
+                                            
+        virtual ::sal_Bool SAL_CALL isVertical( ::sal_Int32 Index, ::sal_Int32 ElemIdx)
+                                  throw (::com::sun::star::uno::RuntimeException);
+
+	   
+   private: 
+   
+       typedef std::vector<AutoLayout> MEListImpl;
+       typedef std::vector<LayoutType*> LListImpl;
+	    
+	   // list used for storing info about
+	   // both builtin and custom layouts
+	   LListImpl maLayoutList;
+	   
+       // lists used to fill the LayoutMenu
+	   // Gives the layouts in order by index.
+	   // There is a list for each view mode.
+	   MEListImpl maStandard; //standard view
+	   MEListImpl maNotes;   // notes view
+	   MEListImpl maHandout;  // handout view
+       
+       bool mbTesting;  // used to determine when testing.
+	   
+	   void initializeList();
+	   void initializeMenuOrder();
+       void writeMenuListToFile(FastSerializerHelper& fsh,
+                                 MEListImpl& list, const char* sTag);
+       void readMenuListFromFile(
+           const ::com::sun::star::uno::Reference< ::com::sun::star::xml::dom::XNodeList >& nodelist,
+           MEListImpl& list); 
+		   
+  }; // Class LayoutList
+	
+}
+
+#endif	   // _LAYOUTLIST_HXX
diff --git sd/inc/layouttype.hxx sd/inc/layouttype.hxx
new file mode 100644
index 0000000..bff5d3d
--- /dev/null
+++ sd/inc/layouttype.hxx
@@ -0,0 +1,228 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: layouttype.hxx,v $
+ * $Revision: 0.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+#ifndef _LAYOUTTYPE_HXX
+#define _LAYOUTTYPE_HXX
+
+#include <vector>
+#include <cppuhelper/implbase1.hxx>
+
+#include <com/sun/star/text/WritingMode.hpp>
+#include "sal/types.h"
+#include "tools/string.hxx"
+#include "tools/gen.hxx"
+#include "pres.hxx"
+#include <sax/fshelper.hxx>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/xml/dom/XDocumentBuilder.hpp>
+
+
+
+using ::com::sun::star::uno::Reference;
+using namespace ::com::sun::star::xml;
+using namespace ::com::sun::star::text;
+using namespace ::sax_fastparser;
+
+namespace sd {
+  
+   typedef String LString;
+
+   /** RectType determines which
+    *  standard rectangle to use
+    *  to calculate bounding rects
+    *  and also determine the factors
+    *  used to calculate the custom
+    *  rects.
+    */
+    
+   enum RectType {
+	   RT_TITLE,  // a non-vertical title
+	   RT_VERTICAL_TITLE, // a vertical title
+	   RT_LAYOUT,  // a non-vertical non-title shape
+	   RT_VERTICAL_LAYOUT, // a vertical non-title shape
+	   RT_TEXT_ONLY, // for the text only layout
+	   RT_LAYOUT_SWITCH, // use if shapes need switching
+	                    // for right to left writing
+	   RT_ERROR,
+	   RT_MAX
+   };
+
+   /** ElemType defines the information for
+    *  one element (or pres. object) in
+    *  a layout.
+    */
+    
+   typedef struct {
+      PresObjKind kind;  // the type of pres. object
+	  bool isVertical;   // whether to make this obj. vertical
+	  double factorX;    // factor for calculating topleft x value
+                         //      X = Xstandard + WidthStandard*factorX
+	  double factorY;    // factor for calculating topleft y value
+                         //      Y = Ystandard + HeightStandard*factorY
+	  double factorHt;   // factor for calculating height
+                         //      Height = HeightStandard*factorHt
+	  double factorWt;   // factor for calculating width
+                         //      Width = WidthStandard*factorWt
+	  RectType recttype; // type of standard rect to use
+                         // for calculating rects.
+   } ElemType;
+	
+   /** LayoutType represents the information for one autolayout 
+    */
+   
+   class LayoutType
+   {
+   public:
+	   LayoutType();
+	   ~LayoutType();
+       
+      /** functions for writing this layout to a xml configuration file */
+       void writeLayoutToFile(FastSerializerHelper& fsh, sal_Int32 autolayout);
+       void writeElementTofile(FastSerializerHelper& fsh,
+                               const sal_uInt32 i,
+                               const char* sNumber,
+                               const ElemType* elem);
+
+      /** functions for reading this layout in from a xml configuration
+       *  file.  Passes back index to the layout list.
+       */ 
+       sal_Int32 getIntValue(const Reference<dom::XNode>& node);
+       double getDoubleValue(const Reference<dom::XNode>& node);
+       sal_Int32 readLayoutFromFile(const Reference<dom::XNode>& node);
+		
+		/** get functions for variables 
+         *  other than elements 
+         */
+	   LString getName();
+       sal_Int32 getStrId();
+	   WritingMode getWritingMode();
+	   sal_uInt32 getHBitmapId();
+	   sal_uInt32 getLBitmapId();
+       PageKind getPageKind();
+	   
+	   /** get functions for elements by index
+	    * and element list functions
+        */
+	   ElemType* getElemByIndex(const sal_uInt32& nIndex);
+	   sal_uInt32 length();
+	   PresObjKind getPresKind(const sal_uInt32& nIndex);
+	   bool isVertical(const sal_uInt32& nIndex);
+	   double factorX(const sal_uInt32& nIndex);
+	   double factorY(const sal_uInt32& nIndex);
+	   double factorHt(const sal_uInt32& nIndex);
+	   double factorWt(const sal_uInt32& nIndex);
+	   RectType recttype(const sal_uInt32& nIndex);
+	   
+	   /** set functions for variables other
+        *  than elements.
+        */
+        
+	   void setName(const LString& sName);
+       void setStrId(const sal_Int32 id);
+	   void setWritingMode(const WritingMode& wmode);
+	   void setHBitmapId(const sal_uInt32& id);
+	   void setLBitmapId(const sal_uInt32& id);
+       void setPageKind(const PageKind& kind);
+
+	   
+	   /** set functions for elements and list
+        */
+        
+	   void createDefaultElement();
+	   void setPresKind(const sal_uInt32& nIndex, PresObjKind nKind);
+	   void setVertical(const sal_uInt32& nIndex, bool bVertical);
+	   void setFactorX(const sal_uInt32& nIndex, double fx);
+	   void setFactorY(const sal_uInt32& nIndex, double fy);
+	   void setFactorHt(const sal_uInt32& nIndex, double ht);
+	   void setFactorWt(const sal_uInt32& nIndex, double wt);
+	   void setRecttype(const sal_uInt32& nIndex, RectType rect);
+       /** add a passed in element to the list */
+	   void addElemToList(ElemType& rElement);
+	   /** deletes element and also removes from list */
+	   void deleteElement(const sal_uInt32& nIndex);
+	   
+	   /** sets the bounding rectangle information
+	    *  for a custom layout.  rRect is the actual
+		*  rectangle from the pres object. rStandard
+		*  is the generic title or layout rectangle.
+		*  For all titles, use RT_TITLE
+		*  and pass in the generic title rect.
+		*  For all else, use RT_LAYOUT,
+		*  (or RT_LAYOUT_SWITCH if a switching of 
+		*  rectangles is needed for right to left
+		*  writing) and pass in a generic layout rect.
+		*/
+	   void setCustomRectInfo(const sal_uInt32& nIndex, 
+                              const RectType& rType,
+                              const Rectangle& rRect,
+			      const Rectangle& rStandard);
+                              
+        /** call this to calculation the bounding rectangles for
+         *  the elements in a layout
+         */
+       void calcAutoLayoutRectangles( const Rectangle& aTitleRect,
+                                      const Rectangle& aLayoutRect,
+				      const Size& aPageSize,
+				      const bool& bRightToLeft,
+				      Rectangle* pRectangle );
+                                      
+        /** initialize the rectInfo for builtin 
+         *  layout elements.
+         *  These functions may not be
+         *  needed after the configuration
+         *  file code is done. 
+         */
+		
+	   void initializeRectInfo(const sal_uInt32& nLayout);
+	   void initFromLayoutNumber(ElemType* elem,
+                                 const sal_uInt32& i,
+                                 const sal_uInt32& nLayout);									  
+	   
+   private: 
+	   LString name;  // String name of the layout
+           sal_Int32 nStrId;  // resource id for the string.
+	   WritingMode nWritingMode; // righttoleft or toptobottom
+	   sal_uInt32 nHBitmapId;  // resource id for the High Contrast? Bitmap
+	   sal_uInt32 nLBitmapId;  // resource id for the Low contrast? Bitmap
+           PageKind nPageKind;  // the page kind for this layout (PK_STANDARD, PK_NOTES, PK_HANDOUT)
+       
+           // list of elements which the pres. objects will be
+           // from for this layout.
+	   typedef std::vector< ElemType* > ListImpl;
+	   ListImpl elemList;
+	   
+	   
+   }; // Class LayoutType
+	
+} //namespace sd
+
+#endif	   // _LAYOUTTYPE_HXX
+
diff --git sd/inc/pres.hxx sd/inc/pres.hxx
index f76bfc5..597128f 100644
--- sd/inc/pres.hxx
+++ sd/inc/pres.hxx
@@ -30,6 +30,12 @@
 #ifndef _PRESENTATION_HXX
 #define _PRESENTATION_HXX
 
+
+/** There's is a corresponding UnoPresKind in
+ *  /offapi/com/sun/star/presentation/XLayoutList.idl
+ *  If you change anything below, please change the corresponding
+ *  Uno code
+ */
 enum PresObjKind
 {
     PRESOBJ_NONE = 0,
@@ -54,45 +60,11 @@ enum PresObjKind
     PRESOBJ_MAX
 };
 
-enum AutoLayout
-{
-    AUTOLAYOUT__START,
-    AUTOLAYOUT_TITLE = AUTOLAYOUT__START,
-    AUTOLAYOUT_ENUM,
-    AUTOLAYOUT_CHART,
-    AUTOLAYOUT_2TEXT,
-    AUTOLAYOUT_TEXTCHART,
-    AUTOLAYOUT_ORG,
-    AUTOLAYOUT_TEXTCLIP,
-    AUTOLAYOUT_CHARTTEXT,
-    AUTOLAYOUT_TAB,
-    AUTOLAYOUT_CLIPTEXT,
-    AUTOLAYOUT_TEXTOBJ,
-    AUTOLAYOUT_OBJ,
-    AUTOLAYOUT_TEXT2OBJ,
-    AUTOLAYOUT_OBJTEXT,
-    AUTOLAYOUT_OBJOVERTEXT,
-    AUTOLAYOUT_2OBJTEXT,
-    AUTOLAYOUT_2OBJOVERTEXT,
-    AUTOLAYOUT_TEXTOVEROBJ,
-    AUTOLAYOUT_4OBJ,
-    AUTOLAYOUT_ONLY_TITLE,
-    AUTOLAYOUT_NONE,
-    AUTOLAYOUT_NOTES,
-    AUTOLAYOUT_HANDOUT1,
-    AUTOLAYOUT_HANDOUT2,
-    AUTOLAYOUT_HANDOUT3,
-    AUTOLAYOUT_HANDOUT4,
-    AUTOLAYOUT_HANDOUT6,
-    AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART,
-    AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE,
-    AUTOLAYOUT_TITLE_VERTICAL_OUTLINE,
-    AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART,
-    AUTOLAYOUT_HANDOUT9,
-    AUTOLAYOUT_ONLY_TEXT,
-    AUTOLAYOUT__END
-};
-
+/** There's is a corresponding UnoPageKind in
+ *  /offapi/com/sun/star/presentation/XLayoutList.idl
+ *  If you change anything below, please change the corresponding
+ *  Uno code
+ */
 enum PageKind
 {
     PK_STANDARD,
diff --git sd/inc/sdpage.hxx sd/inc/sdpage.hxx
index 729fcd0..cd8e8ce 100644
--- sd/inc/sdpage.hxx
+++ sd/inc/sdpage.hxx
@@ -45,6 +45,8 @@
 #include <list>
 #include <functional>
 #include <vector>
+#include "layoutlist.hxx"
+#include "layouttype.hxx"
 #include <svx/svdobj.hxx>
 #ifndef _FM_FMPAGE_HXX //autogen
 #include <svx/fmpage.hxx>
@@ -129,7 +131,7 @@ friend class sd::UndoAttrObject;
 
 protected:
     PageKind	mePageKind;				  // Seitentyp
-    AutoLayout	meAutoLayout;			  // AutoLayout
+    sd::AutoLayout	meAutoLayout;			  // AutoLayout
     sd::ShapeList maPresentationShapeList;			  // Praesentationsobjekte
     sd::ScopeLock maLockAutoLayoutArrangement;
     BOOL		mbSelected;				  // Selektionskennung
@@ -213,9 +215,8 @@ public:
 
     /** inserts the given SdrObject into the presentation object list */
     void			InsertPresObj(SdrObject* pObj, PresObjKind eKind );
-
-    void			SetAutoLayout(AutoLayout eLayout, BOOL bInit=FALSE, BOOL bCreate=FALSE);
-    AutoLayout		GetAutoLayout() const { return meAutoLayout; }
+	void			SetAutoLayout(sd::AutoLayout eLayout, BOOL bInit=FALSE, BOOL bCreate=FALSE);
+	sd::AutoLayout		GetAutoLayout() const { return meAutoLayout; }
     void            CreateTitleAndLayout(BOOL bInit=FALSE, BOOL bCreate=FALSE);
     SdrObject*		InsertAutoLayoutShape(SdrObject* pObj, PresObjKind eObjKind, bool bVertical, Rectangle aRect, bool bInit );
 
@@ -385,8 +386,7 @@ public:
 
     Rectangle   GetTitleRect() const;
     Rectangle   GetLayoutRect() const;
-
-    static void CalculateHandoutAreas( SdDrawDocument& rModel, AutoLayout eLayout, bool bHorizontal, std::vector< Rectangle >& rAreas );
+	static void CalculateHandoutAreas( SdDrawDocument& rModel, sd::AutoLayout eLayout, bool bHorizontal, std::vector< Rectangle >& rAreas );
 
     /** Set the "precious" flag to the given value.
     */
diff --git sd/source/core/drawdoc.cxx sd/source/core/drawdoc.cxx
index 8211ff6..5d7de26 100644
--- sd/source/core/drawdoc.cxx
+++ sd/source/core/drawdoc.cxx
@@ -34,6 +34,7 @@
 #include "PageListWatcher.hxx"
 #include <com/sun/star/text/WritingMode.hpp>
 #include <com/sun/star/document/PrinterIndependentLayout.hpp>
+#include <com/sun/star/presentation/XLayoutList.hpp>
 #include <svx/forbiddencharacterstable.hxx>
 
 #include <svx/svxids.hrc>
@@ -97,6 +98,10 @@
 #include "../ui/inc/optsitem.hxx"
 #include "../ui/inc/FrameView.hxx"
 
+//FOR TESTING LAYOUTLIST
+#include "../ui/inc/res_bmp.hrc"
+#include "../ui/inc/strings.hrc"
+
 // #90477#
 #include <tools/tenccvt.hxx>
 
@@ -107,6 +112,26 @@ using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::linguistic2;
 
+
+rtl::Reference< ::presentation::XLayoutList > autolayoutList;
+
+LayoutList* GetLayoutList()
+{
+   if(!autolayoutList.is())
+   {
+       LayoutList* pList = new LayoutList();
+       if(pList)
+       {
+           pList->readFromFile();
+           autolayoutList.set(pList);
+       }
+       
+   }
+   return (LayoutList*) autolayoutList.get();
+}
+
+
+
 //////////////////////////////////////////////////////////////////////////////
 
 TYPEINIT1( SdDrawDocument, FmFormModel );
@@ -373,6 +398,75 @@ SdDrawDocument::SdDrawDocument(DocumentType eType, SfxObjectShell* pDrDocSh)
 
         rLayerAdmin.SetControlLayerName(aControlLayerName);
     }
+    
+    // Testing code for layoutlist.  To be deleted later.
+    
+    LayoutList* list = GetLayoutList();
+	LayoutType* test;
+	
+	test = new LayoutType();
+    if(test)
+    {
+	   test->setName(LString::CreateFromAscii("testing1..."));
+       test->setStrId(-1);  // no string resource id
+	   test->setWritingMode(WritingMode_LR_TB);
+	   test->setHBitmapId(BMP_FOIL_05_H);
+	   test->setLBitmapId(BMP_FOIL_05);
+	
+	   test->createDefaultElement(); // for title
+	   test->createDefaultElement();
+       test->setPresKind(1,PRESOBJ_TEXT); // top left
+	   test->setFactorHt(1,.488);   // set size
+       test->setFactorWt(1,.488);
+       test->createDefaultElement();
+       test->setPresKind(2, PRESOBJ_GRAPHIC); // top right
+       test->setFactorHt(2,.488);   // set size
+       test->setFactorWt(2,.488);
+       test->setFactorX(2, .5124);  // move to the left
+       test->createDefaultElement();
+       test->setPresKind(3, PRESOBJ_TEXT); // bottom right
+       test->setFactorHt(3, .488);
+       test->setFactorWt(3, .488);
+       test->setFactorX(3, .5124); // move left
+       test->setFactorY(3, .5223); // move down
+       test->createDefaultElement();
+       test->setPresKind(4,PRESOBJ_TEXT); // bottom left
+	   test->setFactorHt(4,.488);   // set size
+       test->setFactorWt(4,.488);
+       test->setFactorY(4, .5223); // move down
+	   test->setRecttype(1, RT_LAYOUT);
+       test->setRecttype(2, RT_LAYOUT);
+       test->setRecttype(3, RT_LAYOUT);
+       test->setRecttype(4, RT_LAYOUT);
+	
+	   if(list->addLayout(test, 3, PK_STANDARD)) OSL_TRACE("layout1 added to list");
+	 } else {  OSL_TRACE("Cannot create layout1"); }
+     
+	// another one
+    test = new LayoutType();
+    if(test)
+    {
+       test->setName(LString::CreateFromAscii("testing2..."));
+       test->setStrId(-1);  // no string resource id
+	   test->setWritingMode(WritingMode_LR_TB);
+	   test->setHBitmapId(BMP_FOIL_05_H);
+	   test->setLBitmapId(BMP_FOIL_05);
+     
+	   test->createDefaultElement(); // title
+	   test->createDefaultElement();
+       test->setPresKind(1, PRESOBJ_CHART); // chart 
+	   test->setFactorY(1,.5223);
+       test->setFactorHt(1,.488);
+       test->setRecttype(1, RT_LAYOUT);
+	   test->createDefaultElement();
+	   test->setPresKind(2,PRESOBJ_OUTLINE);
+	   test->setFactorHt(2,.488);
+	   test->setRecttype(2, RT_LAYOUT);
+	   // put at end of menu (-1)
+       if(list->addLayout(test, -1, PK_STANDARD))
+	   { OSL_TRACE("Layout2 added to the list"); }
+   } else { OSL_TRACE("Cannot create layout2"); }
+
 
 
 }
@@ -403,6 +497,10 @@ SdDrawDocument::~SdDrawDocument()
     CloseBookmarkDoc();
     SetAllocDocSh(FALSE);
 
+    // need to write any autolayout changes to file
+    sd::LayoutList* llist = GetLayoutList();
+    llist->writeToFile();
+    
     // #116168#
     ClearModel(sal_True);
 
@@ -457,6 +555,8 @@ SdDrawDocument::~SdDrawDocument()
 
     delete mpCharClass;
     mpCharClass = NULL;
+    
+
 }
 
 /*************************************************************************
diff --git sd/source/core/drawdoc3.cxx sd/source/core/drawdoc3.cxx
index 7a6f50f..813b3a2 100644
--- sd/source/core/drawdoc3.cxx
+++ sd/source/core/drawdoc3.cxx
@@ -1756,7 +1756,7 @@ void SdDrawDocument::SetMasterPage(USHORT nSdPageNum,
         pPage = (SdPage*)pPageList->First();
         while (pPage)
         {
-            AutoLayout eAutoLayout = pPage->GetAutoLayout();
+			sd::AutoLayout eAutoLayout = pPage->GetAutoLayout();
 
             SdPresentationLayoutUndoAction * pPLUndoAction =
                 new SdPresentationLayoutUndoAction
@@ -1926,8 +1926,8 @@ void SdDrawDocument::SetMasterPage(USHORT nSdPageNum,
         pPage = (SdPage*)pPageList->First();
         while(pPage)
         {
-            AutoLayout eOldAutoLayout = pPage->GetAutoLayout();
-            AutoLayout eNewAutoLayout =
+			sd::AutoLayout eOldAutoLayout = pPage->GetAutoLayout();
+			sd::AutoLayout eNewAutoLayout =
                 pPage->GetPageKind() == PK_STANDARD ? AUTOLAYOUT_NONE : AUTOLAYOUT_NOTES;
 
             SdPresentationLayoutUndoAction * pPLUndoAction =
diff --git sd/source/core/layoutlist.cxx sd/source/core/layoutlist.cxx
new file mode 100644
index 0000000..87475dd
--- /dev/null
+++ sd/source/core/layoutlist.cxx
@@ -0,0 +1,1375 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: layoutlist.cxx,v $
+ * $Revision: 0.1$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+ 
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include <stdio.h>
+#include <tools/debug.hxx>
+#include "osl/diagnose.h"
+#include "osl/file.hxx"
+#include "osl/security.hxx"
+#include "tools/stream.hxx"
+#include <vcl/unohelp.hxx>
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/util/XMacroExpander.hpp>
+#include <com/sun/star/xml/dom/XDocumentBuilder.hpp>
+#include <unotools/streamwrap.hxx>
+#include <sax/fshelper.hxx>
+#include "layoutlist.hxx"
+#include "sal/types.h"
+#include "tools/string.hxx"
+#include "rtl/string.hxx"
+#include "sdresid.hxx"
+#include "pres.hxx"
+#include "../ui/inc/strings.hrc"
+
+#define CHARTOOUSTR(x) rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+#define CHATTOSTR(x) String::createFromAscii(x);
+#define STRTOCHAR(x) (char*) ByteString(x, RTL_TEXTENCODING_UTF8).GetBuffer()
+#define OUSTRTOCHAR(x) (OUStringToOString(x, RTL_TEXTENCODING_UTF8)).getStr()
+
+using namespace sd;
+using namespace ::com::sun::star;
+using ::uno::Reference;
+using ::uno::Sequence;
+using ::io::XOutputStream;
+using ::io::XInputStream;
+using namespace ::xml::dom;
+using namespace ::xml::sax;
+using namespace ::presentation;
+using namespace ::lang;
+using namespace ::uno;
+using namespace ::sax_fastparser;
+
+
+/** xml tags used by the layoutlist class
+ * for reading and writing to the
+ *  configuration file.
+ */
+   
+static char sTopTag[] = "AutoLayoutInfo";
+static char sLListTag[] = "layoutList";
+static char sCountTag[] = "count";
+static char sStandardTag[] = "MenuStandard";
+static char sNotesTag[] = "MenuNotes";
+static char sHandoutTag[] = "MenuHandout";
+static char sNumTag[] = "number";
+
+LayoutList::LayoutList(bool testing)
+{
+    mbTesting = testing;
+    
+    maLayoutList.reserve(50);
+	maStandard.reserve(50);
+	maHandout.reserve(50);
+	maNotes.reserve(50);
+   
+}
+
+LayoutList::~LayoutList()
+{
+    sal_uInt32 size = length();
+    LayoutType* layout;
+    
+    OSL_TRACE("Deleting LayoutList class");
+  
+    if(size == 0) return; // empty list
+  
+  // delete objects in the list if
+  // they are there.
+    for(sal_uInt32 i = 0; i < size; i++)
+    {
+       layout = getLayoutByIndex(i);
+  	   if(layout) 
+ 	   {
+		 // need to do clean up 
+		 // in the layout type class
+	     delete layout;
+	   }
+   }
+  
+   // not sure if this is needed:
+   maLayoutList.clear();
+   maStandard.clear();
+   maNotes.clear();
+   maHandout.clear();
+  
+}
+
+/** Passes back the path with file name for the configuration
+ *  file where autolayout information is stored.
+ */
+
+String* LayoutList::getConfigFile()
+{
+    Reference< uno::XComponentContext > xContext(
+        comphelper_getProcessComponentContext());
+    Reference<util::XMacroExpander> xMacroExpander(
+        xContext->getValueByName(
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "/singletons/com.sun.star.util.theMacroExpander"))),
+        UNO_QUERY_THROW );
+
+    rtl::OUString path = xMacroExpander->expandMacros(
+        rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("$Impress_CfgUrl/AutoLayout.xml")));
+
+    rtl::OUString filePath;
+    osl::FileBase::getSystemPathFromFileURL(path, filePath);
+    return new String(filePath);
+}
+
+/** This writes the autolayout information (the layout list and 
+ *  all menu lists) to the configuration file.
+ */
+
+void LayoutList::writeToFile()
+{
+    // open config file for writing
+    String* psFileName = getConfigFile();
+    StreamMode eMode = (STREAM_WRITE | STREAM_TRUNC);
+    SvFileStream fs(*psFileName, eMode);
+    
+    OSL_TRACE("Writing AutoLayout info to config file."); 
+    if(fs.IsOpen())
+    {
+        LayoutType* layout;
+        static char sCountValue[4];
+        
+        // set fast serial parser
+        utl::OOutputStreamWrapper* osw = new utl::OOutputStreamWrapper(fs); 
+        Reference< XOutputStream > xos(osw);
+        FastSerializerHelper fsh(xos);
+       
+        // get number of layouts
+        sal_Int32 count = numberOfLayouts();
+        sprintf(sCountValue, "%d", (int) count);
+        
+        //<AutoLayoutInfo><layoutList count="35">
+        fsh.startElement(sTopTag,NULL);
+        fsh.startElement(sLListTag, sCountTag, sCountValue, NULL);
+       
+        // get actual size of list
+        sal_Int32 size = (sal_Int32) length();
+        sal_Int32 cnt = 0; // needed to eliminate holes in the list when
+                           // read in.
+        for(sal_Int32 i=0; i < size; i++)
+        {
+            layout = getLayoutByIndex(i);
+            if(layout)
+            {
+                // write each layout type to the file
+                // see layouttype.cxx for details.
+                layout->writeLayoutToFile(fsh, cnt);
+                cnt++;
+            }
+        }
+       
+        // </layoutList>
+        fsh.endElement(sLListTag);
+       
+        // Start of menu order list. The layout's index in the list
+        // is used to identify where in the layout menu the autolayout
+        // is placed.
+        
+        writeMenuListToFile(fsh, maStandard, sStandardTag);
+        writeMenuListToFile(fsh, maNotes, sNotesTag);
+        writeMenuListToFile(fsh, maHandout, sHandoutTag);
+      
+        // </AutoLayoutInfo>
+        fsh.endElement(sTopTag);
+    }
+    fs.Close();
+    delete psFileName;
+
+}   
+
+void LayoutList::writeMenuListToFile(FastSerializerHelper& fsh,
+                                    MEListImpl& list, const char* sTag)
+{
+   static char sNum[10];
+   // <Menu...>
+   fsh.startElement(sTag,NULL);
+      
+   for(sal_uInt32 i=0; i < list.size(); i++)
+   {
+      // <Menu... number="..."/>
+      sprintf(sNum,"%d", (int) list[i]);
+      fsh.singleElement(sTag, sNumTag, sNum, NULL);
+   }
+   // </Menu...>
+   fsh.endElement(sTag);
+    
+}          
+    
+
+void LayoutList::readFromFile()
+{
+    sal_Int32 size, index;
+    String* psFileName = getConfigFile();
+    StreamMode eMode = STREAM_READ;
+    SvFileStream fs(*psFileName, eMode);
+    
+    OSL_TRACE("Reading AutoLayout info from config file."); 
+     if(!fs.IsOpen())
+     {
+       OSL_TRACE("readFromFile: Cannot open autolayout config file %s", STRTOCHAR(*psFileName));
+       // For now, we'll create the builtins from code and write the config
+       // file out.
+       initializeList();
+       writeToFile();
+       return;
+     }
+    
+     const Reference<XMultiServiceFactory> xServiceFactory( vcl::unohelper::GetMultiServiceFactory(), ::uno::UNO_QUERY );
+     rtl::OUString sServName = rtl::OUString::createFromAscii("com.sun.star.xml.dom.DocumentBuilder");
+     Reference<XDocumentBuilder> xDb( xServiceFactory->createInstance(sServName), ::uno::UNO_QUERY);
+     utl::OInputStreamWrapper* isw = new utl::OInputStreamWrapper(fs); 
+     const Reference<XInputStream> xIs(isw);
+     const Reference<XDocument> xDom(xDb->parse(xIs), ::uno::UNO_QUERY_THROW );
+     const Reference<XElement> xElem( xDom->getDocumentElement(), ::uno::UNO_QUERY_THROW );
+     const Reference<XNodeList> topllist(xElem->getElementsByTagName(CHARTOOUSTR(sLListTag)));
+     
+     // load the autolayout list 
+     const Reference<XNode> llist = topllist->item(0);
+     const Reference<XNodeList> layouts = llist->getChildNodes();
+     size = layouts->getLength();
+     sal_Int32 llistsize = 0;
+     
+     // need to get size of layout list (not necessarily the count of
+     // layouts).
+     if(llist->hasAttributes())
+     {
+            Reference<dom::XNamedNodeMap> attrlist = llist->getAttributes();
+            Reference<dom::XNode> enode = attrlist->getNamedItem(CHARTOOUSTR(sCountTag));
+            if(enode.is())
+            {
+               rtl::OUString sNum = enode->getNodeValue();
+               llistsize = sNum.toInt32();
+           }
+     }
+     //OSL_TRACE("SIZE OF LIST %d", llistsize);
+     // create enough entries
+     maLayoutList.resize(llistsize, NULL);
+      
+     // create a layout type for each entry.
+     for(sal_Int32 i=0; i < size; i++)
+     { 
+         LayoutType* layout = new LayoutType();
+         Reference<XNode> alayout = layouts->item(i);
+         index = layout->readLayoutFromFile(alayout);
+         // Put into list where indicated
+         maLayoutList[index] = layout;
+      }
+      
+      
+     
+      // get the menu order lists
+      //   Standard menu list
+      const Reference<XNodeList> topStandardlist(xElem->getElementsByTagName(CHARTOOUSTR(sStandardTag)));
+      readMenuListFromFile(topStandardlist, maStandard); 
+      
+      const Reference<XNodeList> topNoteslist(xElem->getElementsByTagName(CHARTOOUSTR(sNotesTag)));
+      readMenuListFromFile(topNoteslist, maNotes);
+        
+      const Reference<XNodeList> topHandoutlist(xElem->getElementsByTagName(CHARTOOUSTR(sHandoutTag)));
+      readMenuListFromFile(topHandoutlist, maHandout);
+      
+      
+      fs.Close();
+      
+      delete psFileName;
+      
+    
+}  
+
+void LayoutList::readMenuListFromFile(const Reference< XNodeList >& nodelist, MEListImpl& list)
+{
+      sal_Int32 size = nodelist->getLength()-1;
+      sal_Int32 index;
+      //OSL_TRACE("SIZE OF MENU LIST %d", size);
+      
+      list.resize(size, 0);
+          
+      // i = 1 because we need to skip 1st tag
+      for(sal_Int32 i=1; i < size+1; i++)
+      {
+         const Reference<XNode> entry = nodelist->item(i);
+         if(entry->hasAttributes())
+         {
+            Reference<dom::XNamedNodeMap> attrlist = entry->getAttributes();
+            Reference<dom::XNode> enode = attrlist->getNamedItem(CHARTOOUSTR(sNumTag));
+            if(enode.is())
+            {
+               rtl::OUString sNum = enode->getNodeValue();
+               index = sNum.toInt32();
+               list[i-1] = (AutoLayout) index;
+            }
+          
+         }
+        // OSL_TRACE("menu standard: %d = %d", i-1, (int) list[i-1]);
+         
+      }    
+     
+}
+
+/** used for adding new custom layouts. */
+
+bool LayoutList::addLayout(LayoutType* pLayout,
+                    const sal_Int32& menuIndex, const PageKind& eMenu)
+{
+    LayoutType* layout;
+	sal_Int32 idx;
+    bool bFoundAHole = false;
+    
+    if(!layout) return false;
+	
+	LString name = pLayout->getName();
+	idx = getLayoutIndex(name);
+	if(idx != LL_NOT_FOUND)
+	{
+		//DBG_ERROR("sd::LayoutList::addLayout(), given layout name already part of list!");
+		return false;
+	}
+	
+    for(sal_uInt32 i = 0; i < length(); i++)
+    {
+        //looking for any places with NULL
+        layout = maLayoutList[i];
+        if(!layout) 
+        {
+           bFoundAHole = true;
+           maLayoutList[i] = pLayout;
+        }
+    }
+    
+    if(!bFoundAHole)
+    {
+	   //  push onto the back of the list
+       maLayoutList.push_back(pLayout);
+    }
+	
+    //need to set page kind (eMenu is page kind)
+    pLayout->setPageKind(eMenu);
+	//now, find where it was put
+    idx = getLayoutIndex(name);
+	// add this value to the given menu at the given location
+	addToMenuList(menuIndex, (AutoLayout) idx, eMenu);
+	
+	return true;
+}
+	
+
+void LayoutList::deleteLayoutFromList(const LString& sName)
+{
+	sal_Int32 index;
+    LayoutType* layout;
+	
+	index = getLayoutIndex(sName);
+	if(index >= 0)
+	{
+        // make sure builtins don't get deleted from the list
+        // (waive this for testing purposes)
+        if((index >= AL_NUM_OF_BUILTINS)||(mbTesting))
+        {
+           // Since the indices will change if
+           // I use erase (the items get move up
+           // by one) and I don't want to reorder
+           // the list. So I'll just, set the space to 
+           // to NULL and delete the object.
+           layout = maLayoutList[index];
+           maLayoutList[index] = NULL;
+           if(layout) delete layout;
+        }
+       // take out of the menu lists. (Builtins are just removed from
+       // menu lists).
+       removeFromMenuList((AutoLayout) index, PK_STANDARD);
+       removeFromMenuList((AutoLayout) index, PK_NOTES);
+       removeFromMenuList((AutoLayout) index, PK_HANDOUT);
+	}
+}
+ 
+
+sal_uInt32 LayoutList::length() const
+{
+	return maLayoutList.size();
+}
+
+sal_uInt32 LayoutList::numberOfLayouts() const
+{
+	sal_uInt32 count = 0;
+	unsigned int size = (unsigned int) length();
+	
+	for(unsigned int i=0; i < size; i++)
+	{
+		if(maLayoutList[i] != NULL)
+		   count++;
+	}
+	return count; 
+}
+
+LayoutType* LayoutList::getLayoutByIndex(const sal_uInt32 nIndex)
+{
+	// check for valid index (no need to check for less than zero)
+	if(nIndex > length()-1)  return NULL;
+	
+	return maLayoutList[nIndex];
+	
+}
+ 
+
+LayoutType* LayoutList::getLayoutByName(const LString& sName)
+{
+	LayoutType* pLayout=NULL;
+	
+	for(sal_uInt32 i = 0; i < length(); i++)
+	{
+		if ((maLayoutList[i])&&(sName == maLayoutList[i]->getName()))
+        {
+		    pLayout = maLayoutList[i];
+			break;
+        }
+	}
+	
+	return pLayout;
+}
+
+sal_uInt32 LayoutList::getLayoutIndex(const LString& sName)
+{
+	sal_uInt32 idx = LL_NOT_FOUND;
+	
+	for(unsigned int i = 0; i < length(); i++)
+	{
+		if((maLayoutList[i])&&(sName == maLayoutList[i]->getName()))
+		{
+		    idx = (sal_Int32) i;
+			break;
+		}
+	}
+	
+	return idx;
+}
+
+LayoutType* LayoutList::getLayoutAtMenuIndex(const sal_uInt32& nIndex,
+                                             const PageKind& eMenu)
+{
+   sal_uInt32 size = getMenuLength(eMenu);
+   sal_uInt32 index;
+   
+   if(nIndex >= size) return NULL;  //not a valid index
+   
+   switch (eMenu) {
+	   
+     case PK_STANDARD: index = maStandard[nIndex];
+                        break;
+     case PK_NOTES:    index = maNotes[nIndex];
+                        break;
+	 case PK_HANDOUT:  index = maHandout[nIndex];
+	                    break;
+	 default:           return NULL;   // not a valid menu type
+	 
+	}
+	
+	return maLayoutList[index];
+	
+}
+
+sal_uInt32 LayoutList::getMenuIndex(const AutoLayout& nLayout,
+	                                const PageKind& nMenu)
+{
+	sal_uInt32 count = getMenuLength(nMenu);
+	sal_uInt32 idx = LL_NOT_FOUND;
+	MEListImpl* list = NULL;
+	
+	for(sal_uInt32 i = 0; i < count; i++)
+	{
+		 switch (nMenu) {
+			 case PK_STANDARD:  list = &maStandard;
+			                    break;
+			 case PK_NOTES:     list = &maNotes;
+								break;
+			 case PK_HANDOUT:   list = &maHandout;
+								break;
+			 default: /* leave as NULL */;
+		 }
+		 
+	    if(list)
+	    {
+		   if((AutoLayout)(*list)[i] == nLayout)
+		   {
+			  idx = i;
+			  break;
+		   }
+	    }
+     }
+	 
+	 return idx;
+ }
+	
+	
+
+
+sal_uInt32 LayoutList::getMenuLength(const PageKind& eMenu)
+{
+    sal_uInt32 size;  
+	
+	switch (eMenu) {
+	   
+      case PK_STANDARD: size = maStandard.size();
+                        break;
+      case PK_NOTES:    size = maNotes.size();
+                        break;
+	  case PK_HANDOUT:  size = maHandout.size();
+	                    break;     
+	  default:          size = 0; // not a valid menu type
+	}
+
+    return size;
+}
+
+void LayoutList::removeFromMenuList(const AutoLayout& lnum,
+	                                const PageKind& eMenu)
+{
+	 sal_uInt32 index = getMenuIndex(lnum, eMenu);
+	 
+	 if(index == LL_NOT_FOUND) return;
+	 
+	 switch (eMenu) 
+	 {
+		case PK_STANDARD:  maStandard.erase(maStandard.begin()+index);
+		                   break;
+		case PK_NOTES:     maNotes.erase(maNotes.begin()+index);
+		                   break;
+		case PK_HANDOUT:   maHandout.erase(maHandout.begin()+index);
+		                   break;
+	}
+
+	
+}
+	   
+void LayoutList::addToMenuList(const sal_Int32& index,
+	                      const AutoLayout& lnum,
+						  const PageKind& eMenu)
+{
+	 sal_Int32 size;
+	 MEListImpl* list = NULL;
+	
+	 switch (eMenu) 
+	 {
+		case PK_STANDARD:  list = &maStandard;
+		                   break;
+		case PK_NOTES:     list = &maNotes;
+		                   break;
+		case PK_HANDOUT:   list = &maHandout;
+		                   break;
+	 }
+	
+	if(list)
+	{
+		size = list->size();
+		if((index < 0)||(index >= size))
+		{
+			//if too low or too high an index
+			// then assign it to the back of
+			// the list
+			list->push_back(lnum);
+		}
+		else
+		{
+		   // insert at the given index
+		    list->insert(list->begin() + index, lnum);
+		 }
+		
+	}
+	
+}
+
+
+Rectangle LayoutList::UNORectToRect(const ::awt::Rectangle& rect)
+{
+    Rectangle arect;
+    
+    arect.SetSize(Size(rect.Width, rect.Height));
+    arect.SetPos(Point(rect.X, rect.Y));
+    return arect;
+}
+
+::awt::Rectangle LayoutList::RectToUNORect(const Rectangle& rect)
+{
+    ::awt::Rectangle awtrect;
+    Point pos;
+     
+    pos= rect.TopLeft();
+    awtrect.X = pos.X();
+    awtrect.Y = pos.Y();
+    awtrect.Width = rect.GetWidth();
+    awtrect.Height = rect.GetHeight();
+     
+    return awtrect;
+}
+
+ /** UNO implementation of interface XLayoutList
+        *  for use with xmloff code
+        */
+Sequence< ::awt::Rectangle > SAL_CALL LayoutList::getAutoLayoutRectangles( sal_Int32 Index,
+                                                        const ::awt::Rectangle& title,
+                                                        const ::awt::Rectangle& layout,
+                                                        const ::awt::Size& page, 
+                                                        sal_Bool bRightToLeft )
+                                        throw (::uno::RuntimeException)
+{
+    Sequence< ::awt::Rectangle >  list;
+    LayoutType* alayout;
+    sal_uInt32 count;
+    Rectangle atitlerect;
+    Rectangle alayoutrect;
+    Size apage(page.Width, page.Height);
+    
+    atitlerect = UNORectToRect(title);
+    alayoutrect = UNORectToRect(layout);
+    
+    alayout = getLayoutByIndex(Index);
+    if(alayout)
+    {
+        count = alayout->length();
+        Rectangle rect[count];
+        
+        alayout->calcAutoLayoutRectangles(atitlerect, alayoutrect,
+	                  apage, bRightToLeft, rect );
+        list.realloc(count);
+        for(sal_uInt32 i=0; i < count; i++)
+        {
+           list[i] = RectToUNORect(rect[i]);
+        }
+        
+    }
+
+    return list;
+}
+
+
+
+
+::UnoPageKind SAL_CALL LayoutList::getPageKind(sal_Int32 Index)
+                                  throw (::uno::RuntimeException)
+{
+    UnoPageKind kind = UnoPageKind_STANDARD;
+    LayoutType* alayout;
+    
+    alayout = getLayoutByIndex(Index);
+    if(alayout)
+    {
+        kind = (UnoPageKind) alayout->getPageKind();
+    } 
+    
+    return kind;
+}
+
+sal_Int32 SAL_CALL LayoutList::getElementCount(sal_Int32 Index)
+                                  throw (::uno::RuntimeException)
+{
+    sal_Int32 count = 0;
+    LayoutType* alayout;
+    
+    alayout = getLayoutByIndex(Index);
+    if(alayout)
+    {
+       count = alayout->length();
+    }
+    
+    return count;
+}
+
+sal_Bool SAL_CALL LayoutList::isVertical(sal_Int32 Index, sal_Int32 ElemIdx)
+                                  throw (::uno::RuntimeException)
+{
+    sal_Bool bVertical = false;
+    LayoutType* alayout;
+    
+    alayout = getLayoutByIndex(Index);
+    if(alayout)
+    {
+       bVertical = alayout->isVertical(ElemIdx);
+    }
+    
+    return bVertical;
+}
+
+
+::UnoPresKind SAL_CALL LayoutList::getPresKind(sal_Int32 Index, sal_Int32 ElemIdx)
+                                   throw (::uno::RuntimeException)
+{
+    UnoPresKind kind = UnoPresKind_NONE;
+    LayoutType* alayout;
+    
+    alayout = getLayoutByIndex(Index);
+    if(alayout)
+    {
+       kind = (UnoPresKind) alayout->getPresKind(ElemIdx);
+    }
+    
+    return kind;
+}
+
+
+void LayoutList::initializeMenuOrder()
+{
+	// this probably would be best store in a file too.
+	// for keeping track of menu order for builtins
+	
+	maStandard.resize(25, LL_NOT_FOUND);
+	maNotes.resize(1, LL_NOT_FOUND);
+	maHandout.resize(6, LL_NOT_FOUND);
+	
+	// will put custom layouts on the end:
+	
+	// for standard view mode:
+	maStandard[0] = AUTOLAYOUT_NONE;
+	maStandard[1] = AUTOLAYOUT_TITLE;
+	maStandard[2] = AUTOLAYOUT_ENUM;
+	maStandard[3] = AUTOLAYOUT_2TEXT;
+	maStandard[4] = AUTOLAYOUT_ONLY_TITLE;
+	maStandard[5] = AUTOLAYOUT_ONLY_TEXT;
+	maStandard[6] = AUTOLAYOUT_OBJ;
+	maStandard[7] = AUTOLAYOUT_CHART;
+	maStandard[8] = AUTOLAYOUT_TAB;
+	maStandard[9] = AUTOLAYOUT_CLIPTEXT;
+	maStandard[10] = AUTOLAYOUT_TEXTCHART;
+	maStandard[11] = AUTOLAYOUT_TEXTCLIP;
+	maStandard[12] = AUTOLAYOUT_CHARTTEXT;
+	maStandard[13] = AUTOLAYOUT_TEXTOBJ;
+	maStandard[14] = AUTOLAYOUT_TEXT2OBJ;
+	maStandard[15] = AUTOLAYOUT_OBJTEXT;
+	maStandard[16] = AUTOLAYOUT_OBJOVERTEXT;
+	maStandard[17] = AUTOLAYOUT_2OBJTEXT;
+	maStandard[18] = AUTOLAYOUT_2OBJOVERTEXT;
+	maStandard[19] = AUTOLAYOUT_TEXTOVEROBJ;
+	maStandard[20] = AUTOLAYOUT_4OBJ;
+	maStandard[21] = AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART;
+	maStandard[22] = AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE;
+	maStandard[23] = AUTOLAYOUT_TITLE_VERTICAL_OUTLINE;
+	maStandard[24] = AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART;
+	
+	//for notes view:
+	maNotes[0] = AUTOLAYOUT_NOTES;
+	
+	//for handout:
+	maHandout[0] = AUTOLAYOUT_HANDOUT1;
+	maHandout[1] = AUTOLAYOUT_HANDOUT2;
+	maHandout[2] = AUTOLAYOUT_HANDOUT3;
+	maHandout[3] = AUTOLAYOUT_HANDOUT4;
+	maHandout[4] = AUTOLAYOUT_HANDOUT6;
+	maHandout[5] = AUTOLAYOUT_HANDOUT9;
+	
+}
+
+void LayoutList::initializeList()
+{
+	LayoutType* pLayout;
+	
+	initializeMenuOrder();
+	
+	maLayoutList.resize(AL_NUM_OF_BUILTINS, NULL);
+	
+	// AUTOLAYOUT_TITLE (standard title with text box)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TITLE)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TITLE);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_00_H);
+	pLayout->setLBitmapId(BMP_FOIL_00);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // text element
+	pLayout->setPresKind(1,PRESOBJ_TEXT);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TITLE] = pLayout;
+	
+	// AUTOLAYOUT_ENUM (title and outline)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_ENUM)));
+    pLayout->setStrId(STR_AUTOLAYOUT_ENUM);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_01_H);
+	pLayout->setLBitmapId(BMP_FOIL_01);
+        
+	pLayout->createDefaultElement(); // title element
+    
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_ENUM] = pLayout;
+	
+	//  AUTOLAYOUT_CHART (title and Chart)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_CHART)));
+    pLayout->setStrId(STR_AUTOLAYOUT_CHART);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_02_H);
+	pLayout->setLBitmapId(BMP_FOIL_02);
+	 
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // chart element
+	pLayout->setPresKind(1,PRESOBJ_CHART);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_CHART] = pLayout;
+	
+	//  AUTOLAYOUT_2TEXT (title and 2 outlines)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_2TEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_2TEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_03_H);
+	pLayout->setLBitmapId(BMP_FOIL_03);
+	 
+    pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline1 element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	
+	pLayout->createDefaultElement();  // outline2 element
+	pLayout->setPresKind(2,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_2TEXT] = pLayout;
+	
+	//  AUTOLAYOUT_TEXTCHART (title, outline and chart)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TEXTCHART)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TEXTCHART);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_04_H);
+	pLayout->setLBitmapId(BMP_FOIL_04);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	
+	pLayout->createDefaultElement();  // chart element
+	pLayout->setPresKind(2,PRESOBJ_CHART);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TEXTCHART] = pLayout;
+	
+	// AUTOLAYOUT_ORG (title and org. chart)
+	// This layout isn't even put into the menu!
+	// No string resource so for now, I'll borrow chart
+	// TODO:  See if I can eliminate this if not being used.
+	pLayout = new LayoutType();
+	pLayout->setName(LString::CreateFromAscii(""));
+    pLayout->setStrId(-1);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_05_H);  // guessing here :)
+	pLayout->setLBitmapId(BMP_FOIL_05);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // organ. chart element
+	pLayout->setPresKind(1,PRESOBJ_ORGCHART);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+    maLayoutList[AUTOLAYOUT_ORG] = pLayout;	
+	
+	//  AUTOLAYOUT_TEXTCLIP (title, outline and clipart (graphic))
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TEXTCLIP)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TEXTCLIP);
+    pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_06_H);
+	pLayout->setLBitmapId(BMP_FOIL_06);
+	
+    pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	
+	pLayout->createDefaultElement();  // picture element
+	pLayout->setPresKind(2,PRESOBJ_GRAPHIC);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TEXTCLIP] = pLayout;
+	
+    //  AUTOLAYOUT_CHARTTEXT (title, chart and outline)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_CHARTTEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_CHARTTEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_07_H);
+	pLayout->setLBitmapId(BMP_FOIL_07);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // chart element
+	pLayout->setPresKind(1,PRESOBJ_CHART);
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(2,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_CHARTTEXT] = pLayout;
+	
+    //  AUTOLAYOUT_TAB (title and table)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TAB)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TAB);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_08_H);
+	pLayout->setLBitmapId(BMP_FOIL_08);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // table element
+	pLayout->setPresKind(1,PRESOBJ_TABLE);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TAB] = pLayout;
+	
+    //  AUTOLAYOUT_CLIPTEXT (title, clipart (graphic) and outline)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_CLIPTEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_CLIPTEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_09_H);
+	pLayout->setLBitmapId(BMP_FOIL_09);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // picture element
+	pLayout->setPresKind(1,PRESOBJ_GRAPHIC);
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(2,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_CLIPTEXT] = pLayout;
+	
+	//  AUTOLAYOUT_TEXTOBJ (title, outline and object)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TEXTOBJ)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TEXTOBJ);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_10_H);
+	pLayout->setLBitmapId(BMP_FOIL_10);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline1 element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	
+	pLayout->createDefaultElement();  // object element
+	pLayout->setPresKind(2,PRESOBJ_OBJECT);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TEXTOBJ] = pLayout;
+	
+    // AUTOLAYOUT_OBJ (title and object)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_OBJ)));
+    pLayout->setStrId(STR_AUTOLAYOUT_OBJ);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_11_H);
+	pLayout->setLBitmapId(BMP_FOIL_11);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // object element
+	pLayout->setPresKind(1,PRESOBJ_OBJECT);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_OBJ] = pLayout;	
+	
+	
+	//  AUTOLAYOUT_TEXT2OBJ (title, outline and 2 objects)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TEXT2OBJ)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TEXT2OBJ);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_12_H);
+	pLayout->setLBitmapId(BMP_FOIL_12);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	
+    pLayout->createDefaultElement();  // object1 element
+	pLayout->setPresKind(2,PRESOBJ_OBJECT);
+	
+	pLayout->createDefaultElement();  // object2 element
+	pLayout->setPresKind(3,PRESOBJ_OBJECT);
+	pLayout->initializeRectInfo(2); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TEXT2OBJ] = pLayout;
+	
+	// AUTOLAYOUT_OBJTEXT (title, object and outline)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_OBJTEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_OBJTEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_13_H);
+	pLayout->setLBitmapId(BMP_FOIL_13);
+	
+    pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // object element
+	pLayout->setPresKind(1,PRESOBJ_OBJECT);
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(2,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(1); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_OBJTEXT] = pLayout;
+	
+	// AUTOLAYOUT_OBJOVERTEXT (title, object over an outline)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_OBJOVERTEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_OBJOVERTEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_14_H);
+	pLayout->setLBitmapId(BMP_FOIL_14);
+	
+    pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // object element
+	pLayout->setPresKind(1,PRESOBJ_OBJECT);
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(2,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(4); // initialize each element
+	
+    maLayoutList[AUTOLAYOUT_OBJOVERTEXT] = pLayout;
+	
+	// AUTOLAYOUT_2OBJTEXT (2 objects and an outline)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_2OBJTEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_2OBJTEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_15_H);
+	pLayout->setLBitmapId(BMP_FOIL_15);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // object1 element
+	pLayout->setPresKind(1,PRESOBJ_OBJECT);
+	
+	pLayout->createDefaultElement();  // object2 element
+	pLayout->setPresKind(2,PRESOBJ_OBJECT);
+    
+    pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(3,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(3); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_2OBJTEXT] = pLayout;
+	
+	// AUTOLAYOUT_2OBJOVERTEXT (2 objects over the outline)
+	
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_2OBJOVERTEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_2OBJOVERTEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_16_H);
+	pLayout->setLBitmapId(BMP_FOIL_16);
+	
+    pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // object1 element
+	pLayout->setPresKind(1,PRESOBJ_OBJECT);
+	
+	pLayout->createDefaultElement();  // object2 element
+	pLayout->setPresKind(2,PRESOBJ_OBJECT);
+	
+    pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(3,PRESOBJ_OUTLINE);
+	pLayout->initializeRectInfo(5); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_2OBJOVERTEXT] = pLayout;
+	
+	// AUTOLAYOUT_TEXTOVEROBJ (title, an outline over an object)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_TEXTOVEROBJ)));
+    pLayout->setStrId(STR_AUTOLAYOUT_TEXTOVEROBJ);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_17_H);
+	pLayout->setLBitmapId(BMP_FOIL_17);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	
+	pLayout->createDefaultElement();  // object element
+	pLayout->setPresKind(2,PRESOBJ_OBJECT);	
+
+	pLayout->initializeRectInfo(4); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TEXTOVEROBJ] = pLayout;
+	
+	//  AUTOLAYOUT_4OBJ (title and 4 objects)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_4OBJ)));
+    pLayout->setStrId(STR_AUTOLAYOUT_4OBJ);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_18_H);
+	pLayout->setLBitmapId(BMP_FOIL_18);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // object1 element
+    pLayout->setPresKind(1,PRESOBJ_OBJECT);
+	    
+	pLayout->createDefaultElement();  // object2 element
+	pLayout->setPresKind(2,PRESOBJ_OBJECT);
+
+    pLayout->createDefaultElement();  // object3 element
+	pLayout->setPresKind(3,PRESOBJ_OBJECT);
+	
+	pLayout->createDefaultElement();  // object4 element
+	pLayout->setPresKind(4,PRESOBJ_OBJECT);
+	pLayout->initializeRectInfo(6); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_4OBJ] = pLayout;
+	
+	//  AUTOLAYOUT_ONLY_TITLE (just a title)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_ONLY_TITLE)));
+    pLayout->setStrId(STR_AUTOLAYOUT_ONLY_TITLE);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_19_H);
+	pLayout->setLBitmapId(BMP_FOIL_19);
+	
+	pLayout->createDefaultElement();  // title element
+	pLayout->initializeRectInfo(0);
+	
+	maLayoutList[AUTOLAYOUT_ONLY_TITLE] = pLayout;
+	
+	//  AUTOLAYOUT_NONE (blank page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_NONE)));\
+    pLayout->setStrId(STR_AUTOLAYOUT_NONE);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_20_H);
+	pLayout->setLBitmapId(BMP_FOIL_20);
+	
+	maLayoutList[AUTOLAYOUT_NONE] = pLayout;
+
+    // AUTOLAYOUT_NOTES (notes page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_NOTES)));
+    pLayout->setStrId(STR_AUTOLAYOUT_NOTES);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILN_01_H);
+	pLayout->setLBitmapId(BMP_FOILN_01);
+    pLayout->setPageKind(PK_NOTES);
+
+    pLayout->createDefaultElement();  // page element
+	pLayout->setPresKind(0,PRESOBJ_PAGE);
+    pLayout->setRecttype(0, RT_TITLE);
+	
+	pLayout->createDefaultElement();  // notes element
+	pLayout->setPresKind(1,PRESOBJ_NOTES);
+    pLayout->setRecttype(1,RT_LAYOUT);
+	
+	maLayoutList[AUTOLAYOUT_NOTES] = pLayout;
+	
+	// AUTOLAYOUT_HANDOUT1 (1 page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_HANDOUT1)));
+    pLayout->setStrId(STR_AUTOLAYOUT_HANDOUT1);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILH_01_H);
+	pLayout->setLBitmapId(BMP_FOILH_01);
+    pLayout->setPageKind(PK_HANDOUT);
+	
+	maLayoutList[AUTOLAYOUT_HANDOUT1] = pLayout;
+	
+	// AUTOLAYOUT_HANDOUT2 (2 page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_HANDOUT2)));
+    pLayout->setStrId(STR_AUTOLAYOUT_HANDOUT2);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILH_02_H);
+	pLayout->setLBitmapId(BMP_FOILH_02);
+    pLayout->setPageKind(PK_HANDOUT);
+	
+	maLayoutList[AUTOLAYOUT_HANDOUT2] = pLayout;
+	
+	// AUTOLAYOUT_HANDOUT3 (3 page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_HANDOUT3)));
+    pLayout->setStrId(STR_AUTOLAYOUT_HANDOUT3);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILH_03_H);
+	pLayout->setLBitmapId(BMP_FOILH_03);
+    pLayout->setPageKind(PK_HANDOUT);
+	
+	maLayoutList[AUTOLAYOUT_HANDOUT3] = pLayout;
+	
+	// AUTOLAYOUT_HANDOUT4 (4 page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_HANDOUT4)));
+    pLayout->setStrId(STR_AUTOLAYOUT_HANDOUT4);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILH_04_H);
+	pLayout->setLBitmapId(BMP_FOILH_04);
+    pLayout->setPageKind(PK_HANDOUT);
+	
+	maLayoutList[AUTOLAYOUT_HANDOUT4] = pLayout;
+	
+	// AUTOLAYOUT_HANDOUT6 (6 page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_HANDOUT6)));
+    pLayout->setStrId(STR_AUTOLAYOUT_HANDOUT6);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILH_06_H);
+	pLayout->setLBitmapId(BMP_FOILH_06);
+    pLayout->setPageKind(PK_HANDOUT);
+	
+	maLayoutList[AUTOLAYOUT_HANDOUT6] = pLayout;
+	
+	// AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART (vertical title
+	// and outline with chart)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AL_VERT_TITLE_TEXT_CHART)));
+    pLayout->setStrId(STR_AL_VERT_TITLE_TEXT_CHART);
+	pLayout->setWritingMode(WritingMode_TB_RL);
+	pLayout->setHBitmapId(BMP_FOIL_21_H);
+	pLayout->setLBitmapId(BMP_FOIL_21);
+	
+	pLayout->createDefaultElement(); // title element
+	pLayout->setVertical(0,true);
+	pLayout->setRecttype(0, RT_VERTICAL_TITLE);
+	
+	pLayout->createDefaultElement();  // outline1 element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	pLayout->setVertical(1, true);
+	pLayout->setRecttype(1, RT_VERTICAL_LAYOUT);
+	
+	pLayout->createDefaultElement();  // chart element
+	pLayout->setPresKind(2,PRESOBJ_CHART);
+	pLayout->setRecttype(2, RT_VERTICAL_LAYOUT);
+	pLayout->initializeRectInfo(7); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART] = pLayout;
+	
+	// AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AL_VERT_TITLE_VERT_OUTLINE)));
+    pLayout->setStrId(STR_AL_VERT_TITLE_VERT_OUTLINE);
+	pLayout->setWritingMode(WritingMode_TB_RL);
+	pLayout->setHBitmapId(BMP_FOIL_22_H);
+	pLayout->setLBitmapId(BMP_FOIL_22);
+	
+	pLayout->createDefaultElement(); // title element
+	pLayout->setVertical(0,true);
+	pLayout->setRecttype(0,RT_VERTICAL_TITLE);
+	
+	pLayout->createDefaultElement();  // outline1 element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	pLayout->setVertical(1, true);
+	pLayout->setRecttype(1, RT_VERTICAL_LAYOUT);
+	pLayout->initializeRectInfo(8); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE] = pLayout;
+	
+	// AUTOLAYOUT_TITLE_VERTICAL_OUTLINE
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AL_TITLE_VERT_OUTLINE)));
+    pLayout->setStrId(STR_AL_TITLE_VERT_OUTLINE);
+	pLayout->setWritingMode(WritingMode_TB_RL);
+	pLayout->setHBitmapId(BMP_FOIL_23_H);
+	pLayout->setLBitmapId(BMP_FOIL_23);
+	
+	pLayout->createDefaultElement(); // title element
+	
+	pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(1,PRESOBJ_OUTLINE);
+	pLayout->setVertical(1, true);
+    pLayout->setRecttype(1,RT_VERTICAL_LAYOUT);
+	pLayout->initializeRectInfo(0); // initialize each element
+	
+	maLayoutList[AUTOLAYOUT_TITLE_VERTICAL_OUTLINE] = pLayout;
+	
+	
+	// AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AL_TITLE_VERT_OUTLINE_CLIPART)));
+    pLayout->setStrId(STR_AL_TITLE_VERT_OUTLINE_CLIPART);
+	pLayout->setWritingMode(WritingMode_TB_RL);
+	pLayout->setHBitmapId(BMP_FOIL_24_H);
+	pLayout->setLBitmapId(BMP_FOIL_24);
+	
+	pLayout->createDefaultElement(); // title element
+	
+    pLayout->createDefaultElement();  // picture element
+	pLayout->setPresKind(1,PRESOBJ_GRAPHIC);
+    pLayout->setRecttype(1,RT_LAYOUT);
+
+    pLayout->createDefaultElement();  // outline element
+	pLayout->setPresKind(2,PRESOBJ_OUTLINE);
+    pLayout->setRecttype(2, RT_LAYOUT);
+	pLayout->setVertical(2, true);
+    pLayout->initializeRectInfo(9); // initialize each element
+    
+	maLayoutList[AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART] = pLayout;
+	
+	// AUTOLAYOUT_HANDOUT9 (9 per page)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_HANDOUT9)));
+    pLayout->setStrId(STR_AUTOLAYOUT_HANDOUT9);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOILH_09_H);
+	pLayout->setLBitmapId(BMP_FOILH_09);
+    pLayout->setPageKind(PK_HANDOUT);
+	
+	maLayoutList[AUTOLAYOUT_HANDOUT9] = pLayout;
+	
+	// AUTOLAYOUT_ONLY_TEXT (just a text box)
+	pLayout = new LayoutType();
+	pLayout->setName(LString(SdResId(STR_AUTOLAYOUT_ONLY_TEXT)));
+    pLayout->setStrId(STR_AUTOLAYOUT_ONLY_TEXT);
+	pLayout->setWritingMode(WritingMode_LR_TB);
+	pLayout->setHBitmapId(BMP_FOIL_25_H);
+	pLayout->setLBitmapId(BMP_FOIL_25);
+	
+	pLayout->createDefaultElement();  // text element
+	pLayout->setPresKind(0,PRESOBJ_TEXT);
+	pLayout->setRecttype(0,RT_TEXT_ONLY);
+	pLayout->initializeRectInfo(10);
+	
+	maLayoutList[AUTOLAYOUT_ONLY_TEXT] = pLayout;
+	
+}
+
diff --git sd/source/core/layouttype.cxx sd/source/core/layouttype.cxx
new file mode 100644
index 0000000..9519677
--- /dev/null
+++ sd/source/core/layouttype.cxx
@@ -0,0 +1,859 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: layouttype.cxx,v $
+ * $Revision: 0.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include <tools/debug.hxx>
+#include <stdio.h>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/xml/dom/XDocumentBuilder.hpp>
+#include "sdresid.hxx"
+#include "../source/ui/inc/res_bmp.hrc"
+#include "layouttype.hxx"
+
+#define CHARTOOUSTR(x) rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+#define CHATTOSTR(x) String::createFromAscii(x);
+#define STRTOCHAR(x) (char*) ByteString(x, RTL_TEXTENCODING_UTF8).GetBuffer()
+#define OUSTRTOCHAR(x) (OUStringToOString(x, RTL_TEXTENCODING_UTF8)).getStr()
+
+using namespace sd;
+using namespace ::sax_fastparser;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::xml;
+
+/** xml tags used by the layoutlist class
+ * for reading and writing to the
+ *  configuration file.
+ */
+
+static char sElemTag[] = "Element";
+static char sKindTag[] = "PresObjKind";
+static char sVerticalTag[] = "IsVertical";
+static char sFxTag[] = "XFactor";
+static char sFyTag[] = "YFactor";
+static char sFhtTag[] = "HtFactor";
+static char sFwtTag[] = "WtFactor";
+static char sRectTag[] = "RectType";
+static char sLayoutTag[] = "layout";
+static char sNumberTag[] = "number";
+static char sNameTag[] = "Name";
+static char sStrIdTag[] = "StrId";
+static char sWmTag[] = "WritingMode";
+static char sHBitmapTag[] = "HBitmapId";
+static char sLBitmapTag[] = "LBitmapId";
+static char sPageKindTag[] = "PageKind";
+static char sElemListTag[] = "ElementList";
+
+
+
+LayoutType::LayoutType() :
+   name(LString::CreateFromAscii("")),
+   nStrId(-1),
+   nWritingMode(WritingMode_LR_TB),
+   nHBitmapId(BMP_FOIL_01_H),
+   nLBitmapId(BMP_FOIL_01),
+   nPageKind(PK_STANDARD)
+{
+   elemList.reserve(20);
+}
+
+LayoutType::~LayoutType()
+{
+	sal_uInt32 size = elemList.size();
+	
+	for(sal_uInt32 i = 0; i < size; i++)
+	{
+		deleteElement(i);
+	}
+	
+	elemList.clear(); 
+}
+
+/** writes the element list for this layout to the config file */
+
+void LayoutType::writeElementTofile(FastSerializerHelper& fsh,
+                                    const sal_uInt32 i,
+                                    const char* sNumber,
+                                    const ElemType* elem)
+{
+   
+
+   static char sElemNumber[10];       
+   static char sKind[10];
+   static char sVertical[10];
+   static char sRect[10];
+   static char sFx[10];
+   static char sFy[10];
+   static char sHt[10];
+   static char sWt[10];
+   
+   
+   sprintf(sElemNumber,"%d", (int) i); 
+   sprintf(sKind, "%d", (int) elem->kind); // the type of pres. object
+   sprintf(sVertical, "%d", ((elem->isVertical) ? 1 : 0));
+   sprintf(sFx, "%f", elem->factorX);  // factor for finding topleft x value
+   sprintf(sFy,"%f", elem->factorY);  // factor for finding topleft y value
+   sprintf(sHt,"%f", elem->factorHt); // factor for finding height
+   sprintf(sWt,"%f", elem->factorWt); // factor for finding width
+   sprintf(sRect, "%d", (int) elem->recttype);  // type of standard rect to use
+          
+   fsh.singleElement(sLayoutTag,
+                     sElemTag, sElemNumber, 
+                     sNumberTag, sNumber,
+                     sKindTag, sKind,
+                     sVerticalTag, sVertical,
+                     sFxTag, sFx,
+                     sFyTag, sFy,
+                     sFhtTag, sHt,
+                     sFwtTag, sWt,
+                     sRectTag, sRect, NULL);
+    
+    
+}
+
+/** writes this layout to a xml configuration file */
+  
+void LayoutType::writeLayoutToFile(FastSerializerHelper& fsh, const sal_Int32 autolayout)
+{
+   static char sNumber[10];
+   static char sName[40];
+   static char sStrId[10];
+   static char sWm[10]; 
+   static char sHBitmap[10];
+   static char sLBitmap[10];
+   static char sPageKind[10];
+   
+   // write out layout information 
+   sprintf(sNumber,"%d", (int) autolayout);
+   sprintf(sName,"%s", (char*) ByteString(name, RTL_TEXTENCODING_UTF8).GetBuffer());
+   sprintf(sStrId,"%d", (int) nStrId);
+   sprintf(sWm, "%d", (int) nWritingMode);
+   sprintf(sHBitmap, "%d", (int) nHBitmapId);
+   sprintf(sLBitmap, "%d", (int) nLBitmapId);
+   sprintf(sPageKind, "%d", (int) nPageKind);
+    
+   fsh.startElement(sLayoutTag, NULL);
+    
+   fsh.singleElement(sLayoutTag, sNameTag, sName,
+                     sNumberTag, sNumber,
+                     sStrIdTag, sStrId,
+                     sWmTag, sWm,
+                     sHBitmapTag, sHBitmap,
+                     sLBitmapTag, sLBitmap,
+                     sPageKindTag, sPageKind, NULL);
+                     
+                     
+   // write out element list 
+   ElemType* elem;
+   
+   fsh.startElement(sElemListTag, NULL);
+
+   for(sal_uInt32 i=0; i<length();i++)
+   {
+      elem = getElemByIndex(i);
+      if(elem) writeElementTofile(fsh, i, sNumber, elem);
+   }
+    
+    fsh.endElement(sElemListTag);
+
+    fsh.endElement(sLayoutTag);
+
+}
+
+sal_Int32 LayoutType::getIntValue(const Reference<dom::XNode>& node)
+{
+    sal_Int32 num=0;
+    
+    if(node.is())
+    {
+       rtl::OUString sStr= node->getNodeValue();
+       num = sStr.toInt32();
+    }
+
+    return num;
+}
+
+double LayoutType::getDoubleValue(const Reference<dom::XNode>& node)
+{
+    double dnum=0.0;
+    
+    if(node.is())
+    {
+       rtl::OUString sStr= node->getNodeValue();
+       dnum = sStr.toDouble();
+    }
+
+    return dnum;
+    
+}
+
+/** reads in the layout information from
+ * the configuration file 
+ */
+
+sal_Int32 LayoutType::readLayoutFromFile(const Reference<dom::XNode>& node)
+{
+   sal_Int32 lnum=-1;
+   sal_Int32 num;
+   double dnum;
+   Reference<dom::XNodeList> topnodes = node->getChildNodes();
+   Reference<dom::XNode> layoutattrnode = topnodes->item(0);
+   
+   if(layoutattrnode->hasAttributes())
+   {
+       Reference<dom::XNamedNodeMap> attrlist = layoutattrnode->getAttributes();
+       
+       Reference<dom::XNode> anode = attrlist->getNamedItem(CHARTOOUSTR(sStrIdTag));
+       num = getIntValue(anode);
+       if(num > 0)
+       {
+          nStrId = num;
+       } else
+       {
+          nStrId = -1;
+       }
+       Reference<dom::XNode> nameNode = attrlist->getNamedItem(CHARTOOUSTR(sNameTag));
+       rtl::OUString sName = nameNode->getNodeValue();
+       name = LString::CreateFromAscii(OUSTRTOCHAR(sName));
+        //OSL_TRACE("AUTOLAYOUT NAME: %s", STRTOCHAR(name));
+       
+        anode = attrlist->getNamedItem(CHARTOOUSTR(sWmTag));
+        nWritingMode = (WritingMode) getIntValue(anode);
+        //OSL_TRACE("  writing mode %d", (int) nWritingMode);
+       
+        anode = attrlist->getNamedItem(CHARTOOUSTR(sNumberTag));
+        lnum = getIntValue(anode);
+        //OSL_TRACE("   AutoLayout number %d", (int) lnum);
+       
+         anode = attrlist->getNamedItem(CHARTOOUSTR(sHBitmapTag));
+         nHBitmapId = getIntValue(anode);
+         //OSL_TRACE("   HBitmap ID: %d", (int) nHBitmapId);
+       
+         anode = attrlist->getNamedItem(CHARTOOUSTR(sLBitmapTag));
+         nLBitmapId = getIntValue(anode);
+         //OSL_TRACE("   LBitmap ID: %d", (int) nLBitmapId);
+         
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sPageKindTag));
+          nPageKind = (PageKind) getIntValue(anode);
+         //OSL_TRACE("   PageKind: %d", (int) nPageKind);
+        
+   }
+   
+   Reference<dom::XNode> elemlistnode = topnodes->item(1);
+   Reference<dom::XNodeList> elemnodes = elemlistnode->getChildNodes();
+   sal_Int32 elemsize;
+   
+   elemsize = elemnodes->getLength();
+   //OSL_TRACE("NUMBER OF ELEM %d", elemsize);
+   for(sal_Int32 i=0; i < elemsize;i++)
+   {
+       Reference<dom::XNode> elemnode = elemnodes->item(i);
+       //OSL_TRACE("ELEMENT: %i", i);
+       if(elemnode->hasAttributes())
+       {
+          Reference<dom::XNamedNodeMap> attrlist = elemnode->getAttributes();
+          
+          createDefaultElement();
+          Reference<dom::XNode> anode = attrlist->getNamedItem(CHARTOOUSTR(sKindTag));
+          num = getIntValue(anode);
+          setPresKind(i, (PresObjKind) num);
+          //OSL_TRACE("   Kind = %l", (long) getKind(i));
+          
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sVerticalTag));
+          num = getIntValue(anode);
+          bool bVert = (num ? true : false);
+          setVertical(i, bVert);
+          //OSL_TRACE("   isvertical = %d", (isVertical(i) ? 1 : 0));
+          
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sFxTag));
+          dnum = getDoubleValue(anode);
+          setFactorX(i, dnum);
+          //OSL_TRACE("   X = %f", factorX(i));
+          
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sFyTag));
+          dnum = getDoubleValue(anode);
+          setFactorY(i, dnum);
+          //OSL_TRACE("   Y = %f", factorY(i));
+          
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sFhtTag));
+          dnum = getDoubleValue(anode);
+          setFactorHt(i, dnum);
+          //OSL_TRACE("   Ht = %f", factorHt(i));
+          
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sFwtTag));
+          dnum = getDoubleValue(anode);
+          setFactorWt(i, dnum);
+          //OSL_TRACE("   Wt = %f", factorWt(i));
+          
+          anode = attrlist->getNamedItem(CHARTOOUSTR(sRectTag));
+          num = getIntValue(anode);
+          setRecttype(i, (RectType) num);
+          //OSL_TRACE("   recttype = %d", recttype(i));
+          
+       }
+       
+   }
+   return lnum;
+    
+}
+ 
+ 
+/** creates an element of type TITLE
+ *  with default rect bounds.
+ *  and puts it in the elem list
+ * at the end.
+ */
+  
+void LayoutType::createDefaultElement()
+{
+	ElemType* elem = new ElemType;
+	
+	elem->kind = PRESOBJ_TITLE;
+	elem->isVertical = false;
+	elem->factorX = 0.0;
+	elem->factorY = 0.0;
+	elem->factorHt = 1.0;
+	elem->factorWt = 1.0;
+	elem->recttype = RT_TITLE;
+	
+	addElemToList(*elem);
+	
+}
+
+/** Get functions for layout information */
+
+LString LayoutType::getName() 
+{
+	return name;	
+}
+
+sal_Int32 LayoutType::getStrId() 
+{
+	return nStrId;	
+}
+
+WritingMode LayoutType::getWritingMode()
+ {
+	return nWritingMode; 	 
+ }
+
+sal_uInt32 LayoutType::getHBitmapId()
+{
+	return nHBitmapId;	
+}
+
+sal_uInt32 LayoutType::getLBitmapId()
+{
+	return nLBitmapId;
+}
+
+PageKind LayoutType::getPageKind()
+{
+    return nPageKind;   
+}
+
+
+/** gets the element at the given index 
+ * into the elem list 
+ */
+
+ElemType* LayoutType::getElemByIndex(const sal_uInt32& nIndex)
+{
+	// check for valid index (no need to check for negative)
+	if(nIndex >= length())  return NULL;
+	
+	return elemList[nIndex];
+}
+
+/** gets length of elem list. */
+	
+sal_uInt32 LayoutType::length() 
+{
+	return elemList.size();
+}
+
+/**  these are get functions for the element list
+ *   They require passing in the index at which
+ *   the element is located in the list
+ */
+
+ PresObjKind LayoutType::getPresKind(const sal_uInt32& nIndex) 
+ {
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->kind;
+	return PRESOBJ_NONE;
+	 
+ }
+ 
+ 
+bool LayoutType::isVertical(const sal_uInt32& nIndex)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->isVertical;
+	return false;
+}
+
+double LayoutType::factorX(const sal_uInt32& nIndex)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->factorX;
+	return 0.0;
+}
+
+double LayoutType::factorY(const sal_uInt32& nIndex)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->factorY;
+	return 0.0;
+}
+
+double LayoutType::factorHt(const sal_uInt32& nIndex)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->factorHt;
+	return 1.0;
+}
+
+double LayoutType::factorWt(const sal_uInt32& nIndex)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->factorWt;
+	return 1.0;
+}
+
+RectType LayoutType::recttype(const sal_uInt32& nIndex)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) return elem->recttype;
+	return RT_ERROR;
+}
+
+/** Set functions for the layout */
+	
+void LayoutType::setName(const LString& sName)
+{
+   name = sName;	
+}
+
+void LayoutType::setStrId(const sal_Int32 id)
+{
+	nStrId = id;	
+}
+ 
+void LayoutType::setWritingMode(const WritingMode& wmode)
+{
+	nWritingMode = wmode;
+}
+
+void LayoutType::setHBitmapId(const sal_uInt32& id)
+{
+	nHBitmapId = id;
+}
+	   
+void LayoutType::setLBitmapId(const sal_uInt32& id)
+{
+	nLBitmapId = id;
+}
+
+void LayoutType::setPageKind(const PageKind& kind)
+{
+    nPageKind = kind;
+}
+
+/** set functions for the elements in the
+ *  list.  Requires passing in the index
+ *  in the list where the element is
+ *  located
+ */
+
+void LayoutType::setPresKind(const sal_uInt32& nIndex, PresObjKind nKind)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->kind = nKind;
+}
+
+
+void LayoutType::setVertical(const sal_uInt32& nIndex, bool bVertical)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->isVertical = bVertical;
+}
+
+void LayoutType::setFactorX(const sal_uInt32& nIndex, double fx)
+{
+    ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->factorX = fx;
+}
+
+void LayoutType::setFactorY(const sal_uInt32& nIndex, double fy)
+{
+    ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->factorY = fy;
+}
+
+void LayoutType::setFactorHt(const sal_uInt32& nIndex, double ht)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->factorHt = ht;
+}
+
+void LayoutType::setFactorWt(const sal_uInt32& nIndex, double wt)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->factorWt = wt;
+}
+
+void LayoutType::setRecttype(const sal_uInt32& nIndex, RectType rect)
+{
+	ElemType* elem;
+	elem = getElemByIndex(nIndex);
+	if(elem) elem->recttype = rect;
+}
+
+/** adds a passed in element object to the 
+ *  back of the list
+ */
+
+void LayoutType::addElemToList(ElemType& rElement) 
+{
+	elemList.push_back(&rElement);
+		
+}
+
+/** deletes an element from the list 
+ *  This will move elements up
+ *  from where they are
+ */
+
+void LayoutType::deleteElement(const sal_uInt32& nIndex)  
+{
+	ElemType* elem;
+	if(nIndex >= length()) return;
+	elem = elemList[nIndex];
+	elemList.erase(elemList.begin() + nIndex);
+	if(elem) delete elem;
+}
+
+/** Helper function for initializing builtins
+ *  based on a given number.  To possibly be
+ *  removed when the configuration files
+ *  are created
+ */
+
+void LayoutType::initFromLayoutNumber(ElemType* elem,
+                                      const sal_uInt32& i,
+                                      const sal_uInt32& nLayout)
+{
+   Point ncpos(0,0);  //no changes to position
+   Size ncsize(1,1);  //no changes to size
+   Size size;
+   Point pos;	
+   
+   switch (nLayout)
+
+   {
+	  case 9:  // title and 2 vertical side by side layouts
+      case 1:  // TITLE AND 2 side by side LAYOUTS
+         // for right to left switching if needed.
+	     if(nLayout != 9) elem->recttype = RT_LAYOUT_SWITCH; 
+	     elem->factorWt = .488;
+		 if(i == 2) elem->factorX = .5124;
+		 break;
+	  case 2: // TITLE on top, 1 right, 2 left layouts
+	     elem->recttype = RT_LAYOUT_SWITCH;  // for right to left switching
+		                           // if needed.
+		 elem->factorWt = .488;
+		 if((i == 2)||(i == 3)) //2 top to bot.
+		 {
+		    elem->factorHt = .477;
+			elem->factorX = .5124;
+			if(i == 3) elem->factorY = .5223;
+		 }
+		 break;
+	  case 3:  //TITLE, 2 right, 1 left layouts
+	     elem->recttype = RT_LAYOUT_SWITCH;  // for right to left switching
+		                           // if needed. 
+		 elem->factorWt = .488;
+		 if((i == 1)||(i == 2)) //2 top to bot.
+		 {
+		    elem->factorHt = .477;
+			if(i == 2) elem->factorY = .5223;
+		 }
+		 if(i == 3) elem->factorX = .5124;
+		 break;
+	  case 4: //TITLE, 2 layouts top to bot.
+		 elem->factorHt = .477;
+		 if(i == 2) elem->factorY = .5223;		 
+		 break;
+	  case 5:  //TITLE, 2 layouts above 1 layout
+		 elem->factorHt = .477;
+		 if(i != 3) elem->factorWt = .488;
+		 if(i == 2) elem->factorX = .5124;
+		 if(i == 3) elem->factorY = .5223;
+		 break;
+	  case 6:  // 4 layouts (in a square)
+		 elem->factorHt = .477;
+		 elem->factorWt = .488;
+		 if((i == 2)||(i == 3)) elem->factorX = .5124;
+		 if((i == 3)||(i == 4)) elem->factorY = .5223;
+		 break;
+	  case 7: // a vertical title and two layouts (top to bottom)
+	     elem->recttype = RT_VERTICAL_LAYOUT;
+	     elem->factorHt = .47;
+		 elem->factorWt = .7;
+		 if(i == 2) elem->factorY = .53;
+		 break;
+	 case 8: // a vertical title and one shape
+	     elem->recttype = RT_VERTICAL_LAYOUT;
+	     elem->factorWt = .7;
+		 break;
+	 case 0:
+     default:  break; /* do nothing */
+   } // switch nLayout  
+	
+}
+
+/** to be used when the user customizes
+ *  an autolayout.  It sets rect bounds
+ *  factors based on the sizes of a standard
+ *  title (for titles) or layout
+ *  rectangle.
+ */ 
+
+
+void LayoutType::setCustomRectInfo(const sal_uInt32& nIndex, 
+                                   const RectType& rType,
+                                   const Rectangle& rRect,
+								   const Rectangle& rStandard)
+{
+	ElemType* elem;
+	double x, y, ht, wt;
+	double sx, sy, sht, swt;
+	
+	// the actual rectangle
+	x = rRect.TopLeft().X();
+	y = rRect.TopLeft().Y();
+	ht = rRect.getHeight();
+	wt = rRect.getWidth();
+	
+	// the standard to use
+	// to get rel. size factors
+	sx = rStandard.TopLeft().X();
+	sy = rStandard.TopLeft().Y();
+	sht = rStandard.getHeight();
+	swt = rStandard.getWidth();
+	
+	elem = getElemByIndex(nIndex);
+	if(elem)
+	{
+	   	elem->recttype = rType;
+		elem->factorHt = ht/sht;
+		elem->factorWt = wt/swt;
+		elem->factorX = (x - sx)/swt;
+		elem->factorY = (y - sy)/sht;
+	}
+	
+}
+
+/** for initializing rect bounds factors
+ *  for builtins. To be removed once the
+ *  configuration file is implemented.
+ */
+
+void LayoutType::initializeRectInfo(const sal_uInt32& nLayout)
+{
+	ElemType* elem;
+	//Point ncpos(0,0);  //no changes to position
+	//Size ncsize(1,1);  //no changes to size
+	//Size size;
+	//Point pos;
+	
+	for(sal_uInt32 i=0; i < length();i++)
+	{
+	   elem = getElemByIndex(i);
+	   if(!elem) continue;
+	   if(elem->kind == PRESOBJ_NONE) continue;
+	   // default to doing nothing with
+	   // the position and size.
+	   // this will work for 1/2 the
+	   // builtins (ones with 0 )
+	   // and works with some values
+	   // for the others.
+	   elem->factorX = 0.0;
+	   elem->factorY = 0.0;
+	   elem->factorHt = 1.0;
+	   elem->factorWt = 1.0;
+	   switch(elem->kind) {
+		   case PRESOBJ_TITLE:  
+		      if(elem->isVertical)
+			  {
+			     elem->recttype = RT_VERTICAL_TITLE;	
+			  }
+			  else
+			  {
+			     elem->recttype = RT_TITLE;
+			  }
+			  break;
+		   case PRESOBJ_TEXT:
+		      if(nLayout == 10) //TEXT_ONLY
+		      {
+			    elem->recttype = RT_TEXT_ONLY;
+				break;
+			  }
+		   case PRESOBJ_OUTLINE: 
+	       case PRESOBJ_GRAPHIC:
+           case PRESOBJ_OBJECT:
+	       case PRESOBJ_CHART:
+	       case PRESOBJ_TABLE:
+			    elem->recttype = RT_LAYOUT;
+		        initFromLayoutNumber(elem,i, nLayout);
+			    break;
+		   case PRESOBJ_NONE:
+		   case PRESOBJ_ORGCHART:
+	       case PRESOBJ_IMAGE:
+	       case PRESOBJ_BACKGROUND:
+	       case PRESOBJ_PAGE:
+	       case PRESOBJ_HANDOUT:
+	       case PRESOBJ_NOTES:
+	       case PRESOBJ_HEADER:
+	       case PRESOBJ_FOOTER:
+	       case PRESOBJ_DATETIME:
+	       case PRESOBJ_SLIDENUMBER:
+		   case PRESOBJ_MAX:
+		   default:  break; /* do nothing.  all the above handled elsewhere */ 
+		} //switch nKind
+	 } // for		
+	
+}
+
+/** the function called by sdpage.cxx to get rect bounds
+ *  from the factors for each element.
+ */
+
+void LayoutType::calcAutoLayoutRectangles(const Rectangle& aTitleRect,
+                                      const Rectangle& aLayoutRect,
+									  const Size& aPageSize,
+								      const bool& bRightToLeft,
+									  Rectangle* pRectangle )
+{
+    ElemType* elem=NULL;
+	sal_uInt32 count = length();
+	long x,y,ht,wt;
+	long pageHt, pageWt;
+	long vtx, vty, vtht, vtwt;
+	long tx, ty, lx, ly;
+	
+	pageHt = aLayoutRect.BottomLeft().Y() - aTitleRect.TopLeft().Y();
+	pageWt = aPageSize.getWidth();
+	vtx = aTitleRect.TopRight().X()-aTitleRect.getHeight();
+	vty = aTitleRect.TopRight().Y();
+	vtht = pageHt;
+	vtwt = aTitleRect.getHeight();
+	tx = aTitleRect.TopLeft().X();
+	ty = aTitleRect.TopLeft().Y();
+	lx = aLayoutRect.TopLeft().X();
+	ly = aLayoutRect.TopLeft().Y();
+	
+	for(sal_uInt32 i=0; i < count;i++)
+	{
+	   elem = getElemByIndex(i);
+	   if(!elem) continue;
+	   if(elem->kind == PRESOBJ_NONE) continue;
+	   switch (elem->recttype)
+	   {
+	      case RT_TITLE:
+		      x = (long) tx + aTitleRect.getWidth()*elem->factorX;
+		      y = (long) ty + aTitleRect.getHeight()*elem->factorY;
+			  ht = (long) aTitleRect.getHeight()*elem->factorHt;
+			  wt = (long) aTitleRect.getWidth()*elem->factorWt;
+			  break;  
+		  case RT_VERTICAL_TITLE: 
+		      x = vtx;
+			  y =  vty;
+			  ht = vtht;
+			  wt = vtwt;
+		      break;
+		  case RT_VERTICAL_LAYOUT: // need vertical title
+		      ht = vtht*elem->factorHt;
+			  wt = pageWt*elem->factorWt;
+		      x = tx + vtwt*elem->factorX;
+			  y = ty + vtht*elem->factorY;
+			  break;
+		  case RT_TEXT_ONLY: // this takes up the whole page.
+		      ht = pageHt;
+			  wt = aTitleRect.getWidth();
+			  x = tx;
+			  y = ty;
+			  break;
+		  case RT_LAYOUT:
+		  case RT_LAYOUT_SWITCH:
+		  default:  // use layout as default
+		      x = (long) lx + aLayoutRect.getWidth()*elem->factorX;
+		      y = (long) ly + aLayoutRect.getHeight()*elem->factorY;
+			  ht = (long) aLayoutRect.getHeight()*elem->factorHt;
+			  wt = (long) aLayoutRect.getWidth()*elem->factorWt;
+	   }	
+	
+	   pRectangle[i] = Rectangle(Point(x,y), Size(wt, ht));
+   }
+   
+   if((bRightToLeft)&&(elem->recttype == RT_LAYOUT_SWITCH))
+   {
+	   switch (count)
+	   {
+		   case 3:  //2 shapes, switch these
+		      ::std::swap< Rectangle >( pRectangle[1], pRectangle[2] );
+			  break;
+		   case 4:  //3 shapes, rotate
+		      ::std::swap< long >( pRectangle[1].Left(), pRectangle[2].Left() );
+			  pRectangle[3].Left() = pRectangle[2].Left();
+			  break;
+		   default: break;  /* do nothing */
+		}
+		   
+	}
+	  
+ 
+}
+
+
diff --git sd/source/core/makefile.mk sd/source/core/makefile.mk
index 6248f5a..4e2ca5a 100644
--- sd/source/core/makefile.mk
+++ sd/source/core/makefile.mk
@@ -57,6 +57,8 @@ SLOFILES = $(SLO)$/stlsheet.obj  \
            $(SLO)$/drawdoc3.obj \
            $(SLO)$/drawdoc4.obj \
            $(SLO)$/drawdoc_animations.obj\
+		   $(SLO)$/layoutlist.obj \
+		   $(SLO)$/layouttype.obj \
            $(SLO)$/sdpage.obj \
            $(SLO)$/sdpage2.obj	\
            $(SLO)$/sdattr.obj \
diff --git sd/source/core/sdpage.cxx sd/source/core/sdpage.cxx
index 63b5e39..a191237 100644
--- sd/source/core/sdpage.cxx
+++ sd/source/core/sdpage.cxx
@@ -1058,261 +1058,10 @@ Rectangle SdPage::GetLayoutRect() const
 |*
 \*************************************************************************/
 
-const int MAX_PRESOBJS = 5;	// maximum number of presentation objects per layout
-const int VERTICAL = 0x8000;
-
-struct LayoutDescriptor
-{
-    int mnLayout;
-    PresObjKind meKind[MAX_PRESOBJS];
-    bool mbVertical[MAX_PRESOBJS];
-
-    LayoutDescriptor( int nLayout, int k0 = 0, int k1 = 0, int k2 = 0, int k3 = 0, int k4 = 0 );
-};
-
-LayoutDescriptor::LayoutDescriptor( int nLayout, int k0, int k1, int k2, int k3, int k4 )
-: mnLayout( nLayout )
-{
-    meKind[0] = static_cast<PresObjKind>(k0 & (~VERTICAL)); mbVertical[0] = (k0 & VERTICAL) == VERTICAL;
-    meKind[1] = static_cast<PresObjKind>(k1 & (~VERTICAL)); mbVertical[1] = (k1 & VERTICAL) == VERTICAL;
-    meKind[2] = static_cast<PresObjKind>(k2 & (~VERTICAL)); mbVertical[2] = (k2 & VERTICAL) == VERTICAL;
-    meKind[3] = static_cast<PresObjKind>(k3 & (~VERTICAL)); mbVertical[3] = (k3 & VERTICAL) == VERTICAL;
-    meKind[4] = static_cast<PresObjKind>(k4 & (~VERTICAL)); mbVertical[4] = (k4 & VERTICAL) == VERTICAL;
-}
-
-static const LayoutDescriptor& GetLayoutDescriptor( AutoLayout eLayout )
-{
-    static LayoutDescriptor aLayouts[AUTOLAYOUT__END-AUTOLAYOUT__START] =
-    {
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_TEXT ),									// AUTOLAYOUT_TITLE
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_OUTLINE ),								// AUTOLAYOUT_ENUM
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_CHART ),								// AUTOLAYOUT_CHART
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_OUTLINE, PRESOBJ_OUTLINE ),				// AUTOLAYOUT_2TEXT
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_OUTLINE, PRESOBJ_CHART ),				// AUTOLAYOUT_TEXTCHART
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_ORGCHART ),								// AUTOLAYOUT_ORG
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_OUTLINE, PRESOBJ_GRAPHIC ),				// AUTOLAYOUT_TEXTCLbIP
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_CHART, PRESOBJ_OUTLINE ),				// AUTOLAYOUT_CHARTTEXT
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_TABLE ),								// AUTOLAYOUT_TAB
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_GRAPHIC, PRESOBJ_OUTLINE ),				// AUTOLAYOUT_CLIPTEXT
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_OUTLINE, PRESOBJ_OBJECT ),				// AUTOLAYOUT_TEXTOBJ
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_OBJECT ),								// AUTOLAYOUT_OBJ
-        LayoutDescriptor( 2, PRESOBJ_TITLE, PRESOBJ_OUTLINE, PRESOBJ_OBJECT, PRESOBJ_OBJECT ),	// AUTOLAYOUT_TEXT2OBJ
-        LayoutDescriptor( 1, PRESOBJ_TITLE, PRESOBJ_OBJECT, PRESOBJ_OUTLINE ),				// AUTOLAYOUT_TEXTOBJ
-        LayoutDescriptor( 4, PRESOBJ_TITLE, PRESOBJ_OBJECT, PRESOBJ_OUTLINE ),				// AUTOLAYOUT_OBJOVERTEXT
-        LayoutDescriptor( 3, PRESOBJ_TITLE, PRESOBJ_OBJECT, PRESOBJ_OBJECT, PRESOBJ_OUTLINE ),	// AUTOLAYOUT_2OBJTEXT
-        LayoutDescriptor( 5, PRESOBJ_TITLE, PRESOBJ_OBJECT, PRESOBJ_OBJECT, PRESOBJ_OUTLINE ),	// AUTOLAYOUT_2OBJOVERTEXT
-        LayoutDescriptor( 4, PRESOBJ_TITLE, PRESOBJ_OUTLINE, PRESOBJ_OBJECT ),				// AUTOLAYOUT_TEXTOVEROBJ
-        LayoutDescriptor( 6, PRESOBJ_TITLE, PRESOBJ_OBJECT, PRESOBJ_OBJECT,					// AUTOLAYOUT_4OBJ
-            PRESOBJ_OBJECT, PRESOBJ_OBJECT ),
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_NONE ),									// AUTOLAYOUT_ONLY_TITLE
-        LayoutDescriptor( 0, PRESOBJ_NONE ),												// AUTOLAYOUT_NONE
-        LayoutDescriptor( 0, PRESOBJ_PAGE, PRESOBJ_NOTES ),									// AUTOLAYOUT_NOTES
-        LayoutDescriptor( 0 ),																// AUTOLAYOUT_HANDOUT1
-        LayoutDescriptor( 0 ),																// AUTOLAYOUT_HANDOUT2
-        LayoutDescriptor( 0 ),																// AUTOLAYOUT_HANDOUT3
-        LayoutDescriptor( 0 ),																// AUTOLAYOUT_HANDOUT4
-        LayoutDescriptor( 0 ),																// AUTOLAYOUT_HANDOUT6
-        LayoutDescriptor( 7, PRESOBJ_TITLE|VERTICAL, PRESOBJ_OUTLINE|VERTICAL, PRESOBJ_CHART ),// AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART
-        LayoutDescriptor( 8, PRESOBJ_TITLE|VERTICAL, PRESOBJ_OUTLINE|VERTICAL ),			// AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE
-        LayoutDescriptor( 0, PRESOBJ_TITLE, PRESOBJ_OUTLINE|VERTICAL ),						// AUTOLAYOUT_TITLE_VERTICAL_OUTLINE
-        LayoutDescriptor( 9, PRESOBJ_TITLE, PRESOBJ_GRAPHIC, PRESOBJ_OUTLINE|VERTICAL ),	// AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART
-        LayoutDescriptor( 0 ),																// AUTOLAYOUT_HANDOUT9
-        LayoutDescriptor( 10, PRESOBJ_TEXT, PRESOBJ_NONE )                                  // AUTOLAYOUT_ONLY_TEXT
-    };
-
-    if( (eLayout < AUTOLAYOUT__START) || (eLayout >= AUTOLAYOUT__END) )
-        eLayout = AUTOLAYOUT_NONE;
-
-    return aLayouts[ eLayout - AUTOLAYOUT__START ];
-}
-
-static void CalcAutoLayoutRectangles( SdPage& rPage, int nLayout, Rectangle* rRectangle )
-{
-    Rectangle aTitleRect;
-    Rectangle aLayoutRect;
-
-    if( rPage.GetPageKind() != PK_HANDOUT )
-    {
-        SdPage& rMasterPage = static_cast<SdPage&>(rPage.TRG_GetMasterPage());
-        SdrObject* pMasterTitle = rMasterPage.GetPresObj( PRESOBJ_TITLE );
-        SdrObject* pMasterOutline = rMasterPage.GetPresObj( rPage.GetPageKind()==PK_NOTES ? PRESOBJ_NOTES : PRESOBJ_OUTLINE );
-
-        if( pMasterTitle )
-            aTitleRect = pMasterTitle->GetLogicRect();
-
-        if (aTitleRect.IsEmpty() )
-            aTitleRect = rPage.GetTitleRect();
-
-        if( pMasterOutline )
-            aLayoutRect = pMasterOutline->GetLogicRect();
-
-        if (aLayoutRect.IsEmpty() )
-            aLayoutRect = rPage.GetLayoutRect();
-    }
-
-    rRectangle[0] = aTitleRect;
-
-    int i;
-    for( i = 1; i < MAX_PRESOBJS; i++ )
-        rRectangle[i] = aLayoutRect;
-
-    Size        aTitleSize( aTitleRect.GetSize() );
-    Point       aTitlePos( aTitleRect.TopLeft() );
-    Size        aLayoutSize( aLayoutRect.GetSize() );
-    Point       aLayoutPos( aLayoutRect.TopLeft() );
-    Size        aTempSize;
-    Point       aTempPnt;
-
-    sal_Bool    bRightToLeft = ( rPage.GetModel() && static_cast< SdDrawDocument* >( rPage.GetModel() )->GetDefaultWritingMode() == ::com::sun::star::text::WritingMode_RL_TB );
-
-    switch( nLayout )
-    {
-    case 0: // default layout using only the title and layout area
-        break; // do nothing
-    case 1: // title, 2 shapes
-    case 9: // title, 2 vertical shapes
-        aLayoutSize.Width()  = long (aLayoutSize.Width() * 0.488);
-        rRectangle[1] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.X() = long (aLayoutPos.X() + aLayoutSize.Width() * 1.05);
-        rRectangle[2] = Rectangle (aLayoutPos, aLayoutSize);
-
-        if( bRightToLeft && (nLayout != 9) )
-            ::std::swap< Rectangle >( rRectangle[1], rRectangle[2] );
-        break;
-    case 2: // title, shape, 2 shapes
-        aTempPnt = aLayoutPos;
-        aTempSize = aLayoutSize;
-        aLayoutSize.Height() = long (aLayoutSize.Height() * 0.477);
-        aLayoutSize.Width() = long (aLayoutSize.Width() * 0.488);
-        aLayoutPos.X() = long (aLayoutPos.X() + aLayoutSize.Width() * 1.05);
-        rRectangle[2] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.Y() = long (aLayoutPos.Y() + aLayoutSize.Height() * 1.095);
-        rRectangle[3] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos = aTempPnt;
-        aLayoutSize = aTempSize;
-        aLayoutSize.Width() = long (aLayoutSize.Width() * 0.488);
-        rRectangle[1] = Rectangle (aLayoutPos, aLayoutSize);
-
-        if( bRightToLeft )
-        {
-            ::std::swap< long >( rRectangle[1].Left(), rRectangle[2].Left() );
-            rRectangle[3].Left() = rRectangle[2].Left();
-        }
-        break;
-    case 3: // title, 2 shapes, shape
-        aTempPnt = aLayoutPos;
-        aTempSize = aLayoutSize;
-        aLayoutSize.Height() = long (aLayoutSize.Height() * 0.477);
-        aLayoutSize.Width() = long (aLayoutSize.Width() * 0.488);
-        rRectangle[1] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.Y() = long (aLayoutPos.Y() + aLayoutSize.Height() * 1.095);
-        rRectangle[2] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos = aTempPnt;
-        aLayoutSize = aTempSize;
-        aLayoutSize.Width() = long (aLayoutSize.Width() * 0.488);
-        aLayoutPos.X() = long (aLayoutPos.X() + aLayoutSize.Width() * 1.05);
-        rRectangle[3] = Rectangle (aLayoutPos, aLayoutSize);
-
-        if( bRightToLeft )
-        {
-            ::std::swap< long >( rRectangle[1].Left(), rRectangle[2].Left() );
-            rRectangle[3].Left() = rRectangle[2].Left();
-        }
-        break;
-    case 4: // title, shape above shape
-        aLayoutSize.Height() = long (aLayoutSize.Height() * 0.477);
-        rRectangle[1] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.Y() = long (aLayoutPos.Y() + aLayoutSize.Height() * 1.095);
-        rRectangle[2] = Rectangle (aLayoutPos, aLayoutSize);
-        break;
-
-    case 5: // title, 2 shapes above shape
-        aLayoutSize.Height() = long (aLayoutSize.Height() * 0.477);
-        aLayoutSize.Width() = long (aLayoutSize.Width() * 0.488);
-        rRectangle[1] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aTempPnt = aLayoutPos;
-        aLayoutPos.X() = long (aLayoutPos.X() + aLayoutSize.Width() * 1.05);
-        rRectangle[2] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.X() = aTempPnt.X();
-        aLayoutPos.Y() = long (aLayoutPos.Y() + aLayoutSize.Height() * 1.095);
-        aLayoutSize.Width() = long (aLayoutSize.Width() / 0.488);
-        rRectangle[3] = Rectangle (aLayoutPos, aLayoutSize);
-        break;
-    case 6: // title, 4 shapes
-    {
-        ULONG nX = long (aLayoutPos.X());
-
-        aLayoutSize.Height() = long (aLayoutSize.Height() * 0.477);
-        aLayoutSize.Width()  = long (aLayoutSize.Width() * 0.488);
-        rRectangle[1] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.X() = long (nX + aLayoutSize.Width() * 1.05);
-        rRectangle[2] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.Y() = long (aLayoutPos.Y() + aLayoutSize.Height() * 1.095);
-        rRectangle[3] = Rectangle (aLayoutPos, aLayoutSize);
-
-        aLayoutPos.X() = nX;
-        rRectangle[4] = Rectangle (aLayoutPos, aLayoutSize);
-        break;
-    }
-    case 7: // vertical title, shape above shape
-    {
-        Size aSize( rRectangle[0].GetSize().Height(), rRectangle[1].BottomLeft().Y() - rRectangle[0].TopLeft().Y() );
-        rRectangle[0].SetSize( aSize );
-        rRectangle[0].SetPos( aTitleRect.TopRight() - Point( aSize.Width(), 0 ) );
-
-        Size aPageSize ( rPage.GetSize() );
-        aPageSize.Height() -= rPage.GetUppBorder() + rPage.GetLwrBorder();
-        aSize.Height() = long ( rRectangle[0].GetSize().Height() * 0.47 );
-        aSize.Width() = long( aPageSize.Width() * 0.7 );
-        rRectangle[1].SetPos( aTitleRect.TopLeft() );
-        rRectangle[1].SetSize( aSize );
-
-        aSize.Height() = rRectangle[0].GetSize().Height();
-        Point aPos( aTitleRect.TopLeft() );
-        aPos.Y() += long ( aSize.Height() * 0.53 );
-        rRectangle[2].SetPos( aPos );
-        aSize.Height() = long ( rRectangle[0].GetSize().Height() * 0.47 );
-        rRectangle[2].SetSize( aSize );
-        break;
-    }
-    case 8: // vertical title, shape
-    {
-        Size aSize( rRectangle[0].GetSize().Height(), rRectangle[1].BottomLeft().Y() - rRectangle[0].TopLeft().Y() );
-        rRectangle[0].SetSize( aSize );
-        rRectangle[0].SetPos( aTitleRect.TopRight() - Point( aSize.Width(), 0 ) );
-
-        Size aPageSize ( rPage.GetSize() );
-        aPageSize.Height() -= rPage.GetUppBorder() + rPage.GetLwrBorder();
-        aSize.Height() = rRectangle[0].GetSize().Height();
-        aSize.Width() = long( aPageSize.Width() * 0.7 );
-        rRectangle[1].SetPos( aTitleRect.TopLeft() );
-        rRectangle[1].SetSize( aSize );
-        break;
-    }
-    case 10: // onlytext
-    {
-        Size aSize( rRectangle[0].GetSize().Width(), rRectangle[1].BottomLeft().Y() - rRectangle[0].TopLeft().Y() );
-        rRectangle[0].SetSize( aSize );
-        rRectangle[0].SetPos( aTitlePos);
-        break;
-    }
-    }
-}
-
-
-void findAutoLayoutShapesImpl( SdPage& rPage, const LayoutDescriptor& rDescriptor, std::vector< SdrObject* >& rShapes, bool bInit )
+void findAutoLayoutShapesImpl( SdPage& rPage, LayoutType* layout, std::vector< SdrObject* >& rShapes, bool bInit )
 {
-    int i;
+    int i, elemcount = layout->length();
+	PresObjKind eKind;
 
     // init list of indexes for each presentation shape kind
     // this is used to find subsequent shapes with the same presentation shape kind
@@ -1321,10 +1070,16 @@ void findAutoLayoutShapesImpl( SdPage& rPage, const LayoutDescriptor& rDescripto
 
     bool bMissing = false;
 
-    // for each entry in the layoutdescriptor, arrange a presentation shape
-    for( i = 0; (i < PRESOBJ_MAX) && (rDescriptor.meKind[i] != PRESOBJ_NONE); i++ )
+	if(layout)
     {
-        PresObjKind eKind = rDescriptor.meKind[i];
+	   // for each entry in the element list, arrange a presentation shape
+	for( i = 0; i < elemcount ; i++ )
+ 	{
+        eKind = layout->getPresKind(i);
+		if (eKind == PRESOBJ_NONE)
+		{
+			continue;
+		}
         SdrObject* pObj = rPage.GetPresObj( eKind, PresObjIndex[eKind] );
         if( pObj )
         {
@@ -1339,14 +1094,17 @@ void findAutoLayoutShapesImpl( SdPage& rPage, const LayoutDescriptor& rDescripto
 
     if( bMissing && bInit )
     {
-        // for each entry in the layoutdescriptor, look for an alternative shape
-        for( i = 0; (i < PRESOBJ_MAX) && (rDescriptor.meKind[i] != PRESOBJ_NONE); i++ )
-        {
+        // for each entry in the element list, look for an alternative shape
+		for( i = 0; i < elemcount; i++ )
+ 		{
+			eKind = layout->getPresKind(i);
+			if(eKind == PRESOBJ_NONE)
+			{
+				continue;
+			}
             if( rShapes[i] )
                 continue;
 
-            PresObjKind eKind = rDescriptor.meKind[i];
-
             SdrObject* pObj = 0;
             bool bFound = false;
 
@@ -1411,10 +1169,10 @@ void findAutoLayoutShapesImpl( SdPage& rPage, const LayoutDescriptor& rDescripto
                                             bFound = true;
                                         }
                                     }
-                                }
-                             }
-                         }
-                    }
+							    } // if(pPersist...
+                             }// else if (rGetModel...
+                         } // if(pOle2..
+                    }// if(eSdrObjKind...
                     break;
                 case PRESOBJ_CHART:
                 case PRESOBJ_TABLE:
@@ -1434,7 +1192,7 @@ void findAutoLayoutShapesImpl( SdPage& rPage, const LayoutDescriptor& rDescripto
                             }
                         }
                         break;
-                    }
+					} 
                     break;
                 case PRESOBJ_PAGE:
                 case PRESOBJ_HANDOUT:
@@ -1446,13 +1204,14 @@ void findAutoLayoutShapesImpl( SdPage& rPage, const LayoutDescriptor& rDescripto
                     break;
                 default:
                     break;
-                }
-            }
+				} // switch (eKind)...
+			} // while(nShapesIndex...
 
             if( bFound )
                 rShapes[i] = pObj;
-        }
-    }
+		} // for(i = 0; i < elemcount..
+	 } // if(bMissing && bInit..
+   } // if(layout)...
 }
 
 void SdPage::SetAutoLayout(AutoLayout eLayout, BOOL bInit, BOOL bCreate )
@@ -1469,67 +1228,110 @@ void SdPage::SetAutoLayout(AutoLayout eLayout, BOOL bInit, BOOL bCreate )
 
     if((meAutoLayout == AUTOLAYOUT_NONE && maPresentationShapeList.isEmpty()) || mbMaster)
     {
-        // MasterPage or no layout and no presentation shapes available, noting to do
+		// MasterPage or no layout and no presentation shapes available, nothing to do
         return;
     }
-
-    Rectangle aRectangle[MAX_PRESOBJS];
-    const LayoutDescriptor& aDescriptor = GetLayoutDescriptor( meAutoLayout );
-    CalcAutoLayoutRectangles( *this, aDescriptor.mnLayout, aRectangle );
-
-    std::set< SdrObject* > aUsedPresentationObjects;
-
-
-    std::vector< SdrObject* > aLayoutShapes(PRESOBJ_MAX, 0);
-    findAutoLayoutShapesImpl( *this, aDescriptor, aLayoutShapes, bInit );
-
-    int i;
-
-    // for each entry in the layoutdescriptor, arrange a presentation shape
-    for( i = 0; (i < PRESOBJ_MAX) && (aDescriptor.meKind[i] != PRESOBJ_NONE); i++ )
-    {
-        PresObjKind eKind = aDescriptor.meKind[i];
-        SdrObject* pObj = InsertAutoLayoutShape( aLayoutShapes[i], eKind, aDescriptor.mbVertical[i], aRectangle[i], bInit );
-        if( pObj )
-            aUsedPresentationObjects.insert(pObj); // remember that we used this empty shape
-    }
-
-    // now delete all empty presentation objects that are no longer used by the new layout
-    if( bInit )
-    {
-        SdrObject* pObj = maPresentationShapeList.getNextShape(0);
-
-        while( pObj )
-        {
-            SdrObject* pNext = maPresentationShapeList.getNextShape(pObj);
-            if( aUsedPresentationObjects.count(pObj) == 0 )
-            {
-
-                if( pObj->IsEmptyPresObj() )
-                {
-                    if( bUndo )
-                        pUndoManager->AddUndoAction(pModel->GetSdrUndoFactory().CreateUndoDeleteObject(*pObj));
-
-                    RemoveObject( pObj->GetOrdNum() );
-
-                    if( !bUndo )
-                        SdrObject::Free( pObj );
-                }
-                else
-                {
-                    if( bUndo )
-                    {
-                        pUndoManager->AddUndoAction( new UndoObjectPresentationKind( *pObj ) );
-                        if( pObj->GetUserCall() )
-                            pUndoManager->AddUndoAction( new UndoObjectUserCall( *pObj ) );
-                    }
-                    maPresentationShapeList.removeShape( *pObj );
-                    pObj->SetUserCall(0);
-                }
-            }
-            pObj = pNext;
-        }
-    }
+    
+    // get this layout from list
+	LayoutList* list = GetLayoutList();
+    LayoutType* layout = NULL;
+	layout = list->getLayoutByIndex(meAutoLayout);
+	if(layout) 
+	{
+	   int i, elemcount = layout->length();
+	   PresObjKind eKind;
+	   PageKind ePKind  = GetPageKind();
+	   Rectangle aRectangle[elemcount];
+	   Rectangle aTitleRect;
+
+	   Rectangle aLayoutRect;
+       Size aPageSize = GetSize();
+	   bool bRightToLeft = ( GetModel() && static_cast< SdDrawDocument* >( GetModel() )->GetDefaultWritingMode() == ::com::sun::star::text::WritingMode_RL_TB );
+
+									  
+	   if( ePKind != PK_HANDOUT )
+	   {
+		   SdPage& rMasterPage = static_cast<SdPage&>(TRG_GetMasterPage());
+		   SdrObject* pMasterTitle = rMasterPage.GetPresObj( PRESOBJ_TITLE );
+		   SdrObject* pMasterOutline = rMasterPage.GetPresObj( ePKind==PK_NOTES ? PRESOBJ_NOTES : PRESOBJ_OUTLINE );
+
+		   if( pMasterTitle )
+			  aTitleRect = pMasterTitle->GetLogicRect();
+
+
+		   if (aTitleRect.IsEmpty() )
+			  aTitleRect = GetTitleRect();
+
+		   if( pMasterOutline )
+			  aLayoutRect = pMasterOutline->GetLogicRect();
+
+		   if (aLayoutRect.IsEmpty() )
+			  aLayoutRect = GetLayoutRect();
+	   
+        }
+	    layout->calcAutoLayoutRectangles(aTitleRect, aLayoutRect,
+	                  aPageSize, bRightToLeft, aRectangle );
+		
+	   std::set< SdrObject* > aUsedPresentationObjects;
+
+	   std::vector< SdrObject* > aLayoutShapes(PRESOBJ_MAX, 0);
+	   findAutoLayoutShapesImpl( *this, layout, aLayoutShapes, bInit );
+
+	   // for each entry in the element list, arrange a presentation shape
+	   for( i = 0; i < elemcount; i++ )
+	   {
+		   eKind = layout->getPresKind(i);
+		   if (eKind == PRESOBJ_NONE)
+		   {
+			   continue;
+		   }
+		
+		   SdrObject* pObj = InsertAutoLayoutShape( aLayoutShapes[i], eKind, layout->isVertical(i), aRectangle[i], bInit );
+
+		   if( pObj )
+			  aUsedPresentationObjects.insert(pObj); // remember that we used this empty shape
+	   }
+
+	   // now delete all empty presentation objects that are no longer used by the new layout
+	   if( bInit )
+	   {
+		   SdrObject* pObj = maPresentationShapeList.getNextShape(0);
+
+		   while( pObj )
+		   {
+			   SdrObject* pNext = maPresentationShapeList.getNextShape(pObj);
+			   if( aUsedPresentationObjects.count(pObj) == 0 )
+			   {
+
+				   if( pObj->IsEmptyPresObj() )
+				   {
+					  if( bUndo )
+						  pUndoManager->AddUndoAction(pModel->GetSdrUndoFactory().CreateUndoDeleteObject(*pObj));
+
+					  RemoveObject( pObj->GetOrdNum() );
+
+					  if( !bUndo )
+						  SdrObject::Free( pObj );
+				  }
+				  else
+				  {
+					  if( bUndo )
+					  {
+						  pUndoManager->AddUndoAction( new UndoObjectPresentationKind( *pObj ) );
+						  if( pObj->GetUserCall() )
+						  	  pUndoManager->AddUndoAction( new UndoObjectUserCall( *pObj ) );
+					  }
+					  maPresentationShapeList.removeShape( *pObj );
+					  pObj->SetUserCall(0);
+				  }
+			  }
+			  pObj = pNext;
+		  } // while(pObj...
+	   } // if(bInit...
+	
+	} else { // no autolayout object found.
+       DBG_ERROR("SetAutoLayout: no autolayout object found.");
+ 	}
 }
 
 /*************************************************************************
@@ -2918,6 +2720,7 @@ bool SdPage::RestoreDefaultText( SdrObject* pObj )
     return bRet;
 }
 
+
 void SdPage::CalculateHandoutAreas( SdDrawDocument& rModel, AutoLayout eLayout, bool bHorizontal, std::vector< Rectangle >& rAreas )
 {
     SdPage& rHandoutMaster = *rModel.GetMasterSdPage( 0, PK_HANDOUT );
diff --git sd/source/filter/ppt/pptin.cxx sd/source/filter/ppt/pptin.cxx
index a758440..6b44e25 100644
--- sd/source/filter/ppt/pptin.cxx
+++ sd/source/filter/ppt/pptin.cxx
@@ -1097,7 +1097,7 @@ sal_Bool ImplSdPPTImport::Import()
 			////////////////////
 			SetPageNum( i, PPT_SLIDEPAGE );
 			SdPage* pPage = mpDoc->GetSdPage( i, PK_STANDARD );
-			AutoLayout eAutoLayout = AUTOLAYOUT_NONE;
+			sd::AutoLayout eAutoLayout = AUTOLAYOUT_NONE;
 			const PptSlideLayoutAtom* pSlideLayout = GetSlideLayoutAtom();
 			if ( pSlideLayout )
 			{
diff --git sd/source/filter/ppt/pptin.hxx sd/source/filter/ppt/pptin.hxx
index d4b5c04..ca4d488 100644
--- sd/source/filter/ppt/pptin.hxx
+++ sd/source/filter/ppt/pptin.hxx
@@ -38,6 +38,7 @@
 #include <svx/msfiltertracer.hxx>
 #include <com/sun/star/uno/Any.h>
 #include <boost/shared_ptr.hpp>
+#include "layoutlist.hxx"
 
 class SdDrawDocument;
 class SfxMedium;
diff --git sd/source/ui/func/unprlout.cxx sd/source/ui/func/unprlout.cxx
index f5d2ea4..305c036 100644
--- sd/source/ui/func/unprlout.cxx
+++ sd/source/ui/func/unprlout.cxx
@@ -54,8 +54,8 @@ SdPresentationLayoutUndoAction::SdPresentationLayoutUndoAction(
                             SdDrawDocument* pTheDoc,
                             String          aTheOldLayoutName,
                             String          aTheNewLayoutName,
-                            AutoLayout      eTheOldAutoLayout,
-                            AutoLayout      eTheNewAutoLayout,
+							sd::AutoLayout      eTheOldAutoLayout,
+							sd::AutoLayout      eTheNewAutoLayout,
                             BOOL            bSet,
                             SdPage*         pThePage):
                       SdUndoAction(pTheDoc)
diff --git sd/source/ui/inc/ViewShellImplementation.hxx sd/source/ui/inc/ViewShellImplementation.hxx
index 1e4f5dd..1b6ac96 100644
--- sd/source/ui/inc/ViewShellImplementation.hxx
+++ sd/source/ui/inc/ViewShellImplementation.hxx
@@ -34,6 +34,7 @@
 #include "ViewShell.hxx"
 #include "ViewShellManager.hxx"
 #include "ToolBarManager.hxx"
+#include "layoutlist.hxx"
 
 #include <boost/shared_ptr.hpp>
 #include <boost/weak_ptr.hpp>
@@ -129,7 +130,7 @@ public:
     */
     void AssignLayout (
         SdPage* pPage,
-        AutoLayout aLayout);
+        sd::AutoLayout aLayout);
 
     /** Determine the view id of the view shell.  This corresponds to the
         view id stored in the SfxViewFrame class.  
diff --git sd/source/ui/inc/unmodpg.hxx sd/source/ui/inc/unmodpg.hxx
index d034c6e..b3e825f 100644
--- sd/source/ui/inc/unmodpg.hxx
+++ sd/source/ui/inc/unmodpg.hxx
@@ -33,6 +33,7 @@
 
 #include "sdundo.hxx"
 #include "pres.hxx"
+#include "layoutlist.hxx"
 
 class SdDrawDocument;
 class SdPage;
@@ -45,8 +46,8 @@ class ModifyPageUndoAction : public SdUndoAction
     SdPage*         mpPage;
     String          maOldName;
     String          maNewName;
-    AutoLayout      meOldAutoLayout;
-    AutoLayout      meNewAutoLayout;
+	sd::AutoLayout      meOldAutoLayout;
+	sd::AutoLayout      meNewAutoLayout;
     BOOL            mbOldBckgrndVisible;
     BOOL            mbNewBckgrndVisible;
     BOOL            mbOldBckgrndObjsVisible;
@@ -61,7 +62,7 @@ public:
         SdDrawDocument*			pTheDoc,
         SdPage*					pThePage,
         String					aTheNewName,
-        AutoLayout				eTheNewAutoLayout,
+		sd::AutoLayout				eTheNewAutoLayout,
         BOOL					bTheNewBckgrndVisible,
         BOOL					bTheNewBckgrndObjsVisible);
 
diff --git sd/source/ui/inc/unprlout.hxx sd/source/ui/inc/unprlout.hxx
index ba7d188..03550d8 100644
--- sd/source/ui/inc/unprlout.hxx
+++ sd/source/ui/inc/unprlout.hxx
@@ -32,7 +32,8 @@
 #define _SD_UNPRLOUT_HXX
 
 #include "sdundo.hxx"
-#include "pres.hxx"                 // enum AutoLayout
+#include "pres.hxx"        
+#include "layoutlist.hxx"
 
 class SdDrawDocument;
 class SdPage;
@@ -41,8 +42,8 @@ class SdPresentationLayoutUndoAction : public SdUndoAction
 {
     String          aOldLayoutName;
     String          aNewLayoutName;
-    AutoLayout      eOldAutoLayout;
-    AutoLayout      eNewAutoLayout;
+	sd::AutoLayout      eOldAutoLayout;
+	sd::AutoLayout      eNewAutoLayout;
     BOOL            bSetAutoLayout;     // TRUE: AutoLayout aendern
     SdPage*         pPage;
     String          aComment;
@@ -52,8 +53,8 @@ public:
     SdPresentationLayoutUndoAction(SdDrawDocument* pTheDoc,
                          String          aTheOldLayoutName,
                          String          aTheNewLayoutName,
-                         AutoLayout      eTheOldAutoLayout,
-                         AutoLayout      eTheNewAutoLayout,
+						 sd::AutoLayout      eTheOldAutoLayout,
+						 sd::AutoLayout      eTheNewAutoLayout,
                          BOOL            bSet,
                          SdPage*         pThePage);
 
diff --git sd/source/ui/slidesorter/controller/SlsSlotManager.cxx sd/source/ui/slidesorter/controller/SlsSlotManager.cxx
index 0a396f9..526b7d2 100644
--- sd/source/ui/slidesorter/controller/SlsSlotManager.cxx
+++ sd/source/ui/slidesorter/controller/SlsSlotManager.cxx
@@ -248,7 +248,7 @@ void SlotManager::FuTemporary (SfxRequest& rRequest)
             pShell->mpImpl->AssignLayout(
                 pDocument->GetSdPage((USHORT)pWhatPage->GetValue(), 
                     mrSlideSorter.GetModel().GetPageType()),
-                (AutoLayout)pWhatLayout->GetValue());
+                (sd::AutoLayout)pWhatLayout->GetValue());
             rRequest.Done ();
         }
         break;
diff --git sd/source/ui/toolpanel/LayoutMenu.cxx sd/source/ui/toolpanel/LayoutMenu.cxx
index d569033..674ff6d 100644
--- sd/source/ui/toolpanel/LayoutMenu.cxx
+++ sd/source/ui/toolpanel/LayoutMenu.cxx
@@ -128,99 +128,6 @@ SFX_IMPL_INTERFACE(LayoutMenu, SfxShell,
 
 TYPEINIT1(LayoutMenu, SfxShell);
 
-struct snewfoil_value_info
-{
-    USHORT mnBmpResId;
-    USHORT mnHCBmpResId;
-    USHORT mnStrResId;
-    WritingMode meWritingMode;
-    AutoLayout maAutoLayout;
-};
-
-static snewfoil_value_info notes[] =
-{
-    {BMP_FOILN_01, BMP_FOILN_01_H, STR_AUTOLAYOUT_NOTES, WritingMode_LR_TB,
-     AUTOLAYOUT_NOTES},
-    {0, 0, 0, WritingMode_LR_TB, AUTOLAYOUT_NONE},
-};
-
-static snewfoil_value_info handout[] =
-{
-    {BMP_FOILH_01, BMP_FOILH_01_H, STR_AUTOLAYOUT_HANDOUT1, WritingMode_LR_TB,
-     AUTOLAYOUT_HANDOUT1},
-    {BMP_FOILH_02, BMP_FOILH_02_H, STR_AUTOLAYOUT_HANDOUT2, WritingMode_LR_TB,
-     AUTOLAYOUT_HANDOUT2},
-    {BMP_FOILH_03, BMP_FOILH_03_H, STR_AUTOLAYOUT_HANDOUT3, WritingMode_LR_TB,
-     AUTOLAYOUT_HANDOUT3},
-    {BMP_FOILH_04, BMP_FOILH_04_H, STR_AUTOLAYOUT_HANDOUT4, WritingMode_LR_TB,
-     AUTOLAYOUT_HANDOUT4},
-    {BMP_FOILH_06, BMP_FOILH_06_H, STR_AUTOLAYOUT_HANDOUT6, WritingMode_LR_TB,
-     AUTOLAYOUT_HANDOUT6},
-    {BMP_FOILH_09, BMP_FOILH_09_H, STR_AUTOLAYOUT_HANDOUT9, WritingMode_LR_TB,
-     AUTOLAYOUT_HANDOUT9},
-    {0, 0, 0, WritingMode_LR_TB, AUTOLAYOUT_NONE},
-};
-
-static snewfoil_value_info standard[] =
-{
-    {BMP_FOIL_20, BMP_FOIL_20_H, STR_AUTOLAYOUT_NONE, WritingMode_LR_TB,
-     AUTOLAYOUT_NONE},
-    {BMP_FOIL_00, BMP_FOIL_00_H, STR_AUTOLAYOUT_TITLE, WritingMode_LR_TB,
-     AUTOLAYOUT_TITLE},
-    {BMP_FOIL_01, BMP_FOIL_01_H, STR_AUTOLAYOUT_ENUM, WritingMode_LR_TB,
-     AUTOLAYOUT_ENUM},
-    {BMP_FOIL_03, BMP_FOIL_03_H, STR_AUTOLAYOUT_2TEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_2TEXT},
-    {BMP_FOIL_19, BMP_FOIL_19_H, STR_AUTOLAYOUT_ONLY_TITLE, WritingMode_LR_TB,
-     AUTOLAYOUT_ONLY_TITLE},
-    {BMP_FOIL_25, BMP_FOIL_25_H, STR_AUTOLAYOUT_ONLY_TEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_ONLY_TEXT},
-    {BMP_FOIL_11, BMP_FOIL_11_H, STR_AUTOLAYOUT_OBJ, WritingMode_LR_TB,
-     AUTOLAYOUT_OBJ},
-    {BMP_FOIL_02, BMP_FOIL_02_H, STR_AUTOLAYOUT_CHART, WritingMode_LR_TB,
-     AUTOLAYOUT_CHART},
-    {BMP_FOIL_08, BMP_FOIL_08_H, STR_AUTOLAYOUT_TAB, WritingMode_LR_TB,
-     AUTOLAYOUT_TAB},
-    {BMP_FOIL_09, BMP_FOIL_09_H, STR_AUTOLAYOUT_CLIPTEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_CLIPTEXT},
-    {BMP_FOIL_04, BMP_FOIL_04_H, STR_AUTOLAYOUT_TEXTCHART, WritingMode_LR_TB,
-     AUTOLAYOUT_TEXTCHART},
-    {BMP_FOIL_06, BMP_FOIL_06_H, STR_AUTOLAYOUT_TEXTCLIP, WritingMode_LR_TB,
-    AUTOLAYOUT_TEXTCLIP},
-    {BMP_FOIL_07, BMP_FOIL_07_H, STR_AUTOLAYOUT_CHARTTEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_CHARTTEXT},
-    {BMP_FOIL_10, BMP_FOIL_10_H, STR_AUTOLAYOUT_TEXTOBJ, WritingMode_LR_TB,
-     AUTOLAYOUT_TEXTOBJ},
-    {BMP_FOIL_12, BMP_FOIL_12_H, STR_AUTOLAYOUT_TEXT2OBJ, WritingMode_LR_TB,
-     AUTOLAYOUT_TEXT2OBJ},
-    {BMP_FOIL_13, BMP_FOIL_13_H, STR_AUTOLAYOUT_OBJTEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_OBJTEXT},
-    {BMP_FOIL_14, BMP_FOIL_14_H, STR_AUTOLAYOUT_OBJOVERTEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_OBJOVERTEXT},
-    {BMP_FOIL_15, BMP_FOIL_15_H, STR_AUTOLAYOUT_2OBJTEXT, WritingMode_LR_TB,
-     AUTOLAYOUT_2OBJTEXT},
-    {BMP_FOIL_16, BMP_FOIL_16_H, STR_AUTOLAYOUT_2OBJOVERTEXT, 
-     WritingMode_LR_TB, AUTOLAYOUT_2OBJOVERTEXT},
-    {BMP_FOIL_17, BMP_FOIL_17_H, STR_AUTOLAYOUT_TEXTOVEROBJ, WritingMode_LR_TB,
-     AUTOLAYOUT_TEXTOVEROBJ},
-    {BMP_FOIL_18, BMP_FOIL_18_H, STR_AUTOLAYOUT_4OBJ, WritingMode_LR_TB,
-     AUTOLAYOUT_4OBJ},
-    // vertical
-    {BMP_FOIL_21, BMP_FOIL_21_H, STR_AL_VERT_TITLE_TEXT_CHART, 
-     WritingMode_TB_RL, AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART},
-    {BMP_FOIL_22, BMP_FOIL_22_H, STR_AL_VERT_TITLE_VERT_OUTLINE, 
-     WritingMode_TB_RL, AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE},
-    {BMP_FOIL_23, BMP_FOIL_23_H, STR_AL_TITLE_VERT_OUTLINE, WritingMode_TB_RL,
-     AUTOLAYOUT_TITLE_VERTICAL_OUTLINE},
-    {BMP_FOIL_24, BMP_FOIL_24_H, STR_AL_TITLE_VERT_OUTLINE_CLIPART, 
-     WritingMode_TB_RL, AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART},
-    
-    {0, 0, 0, WritingMode_LR_TB, AUTOLAYOUT_NONE}
-};
-
-
-
-
 LayoutMenu::LayoutMenu (
     TreeNode* pParent,
     DrawDocShell& rDocumentShell,
@@ -758,43 +665,89 @@ void LayoutMenu::Fill (void)
     catch (RuntimeException&)
     {}
     
-    snewfoil_value_info* pInfo = NULL;
+    // Get layoutlist 
+    LayoutList* list = GetLayoutList();
+	PageKind eMenu;
+	bool aViewExists = true;
+	LayoutType* layout;
+
+    // determine which view (PageKind) so we can set the right
+    // menu
     if (sCenterPaneViewName.equals(framework::FrameworkHelper::msNotesViewURL))
     {
-        pInfo = notes;
+        eMenu = PK_NOTES;
     }
     else if (sCenterPaneViewName.equals(framework::FrameworkHelper::msHandoutViewURL))
     {
-        pInfo = handout;
+        eMenu = PK_HANDOUT;
     }
     else if (sCenterPaneViewName.equals(framework::FrameworkHelper::msImpressViewURL)
         || sCenterPaneViewName.equals(framework::FrameworkHelper::msSlideSorterURL))
     {
-        pInfo = standard;
+        eMenu = PK_STANDARD;
     }
     else
     {
-        pInfo = NULL;
+        eMenu = PK_STANDARD;
+		aViewExists = false;
     }
 
+   
     Clear();
-    int n = 0;
-    for (sal_uInt16 i=1; pInfo!=NULL&&pInfo->mnBmpResId!=0; i++,pInfo++)
-    {
-        if ((WritingMode_TB_RL != pInfo->meWritingMode) || bVertical)
-        {
-            BitmapEx aBmp (SdResId (bHighContrast 
-                             ? pInfo->mnHCBmpResId 
-                             : pInfo->mnBmpResId));
-        
-            if (bRightToLeft && (WritingMode_TB_RL != pInfo->meWritingMode))
-                aBmp.Mirror (BMP_MIRROR_HORZ);
-
-            InsertItem (i, aBmp, String (SdResId (pInfo->mnStrResId)));
-            SetItemData (i, new AutoLayout(pInfo->maAutoLayout));
-            n++;
-        }
-    }
+    	
+	WritingMode wm;
+	AutoLayout lnum;
+	sal_uInt32 index;
+    sal_Int32 resId;
+	sal_uInt32 Hbitmap, Lbitmap;
+	LString name;
+    
+	sal_uInt32 size = list->getMenuLength(eMenu);
+	
+    // for each entry in the menu order list
+	index = 1;
+	if (aViewExists) {
+	   for (sal_uInt16 i=0; i < size; i++)
+	   {
+           // get the LayoutType for this menu entry
+		   layout = list->getLayoutAtMenuIndex(i,eMenu);
+		   if(layout) // some layouts can be NULL
+		   {
+		      name = layout->getName();  // get string name
+		      lnum = list->getLayoutIndex(name); // get index in list
+			  if(lnum == LL_NOT_FOUND) // no layout at this index, so skip
+              {
+                 continue;
+              }
+              resId = layout->getStrId(); // get resource ID string if there
+              if(resId != -1) // if it has an ID, pull string from resource.
+              {
+                  name = SdResId(resId);
+              }
+	          wm = layout->getWritingMode();  
+		      Hbitmap = layout->getHBitmapId();
+		      Lbitmap = layout->getLBitmapId();
+              // if its vertical but not Right to Left
+		      if((wm != WritingMode_TB_RL) || bVertical)
+		      {
+                  // set which bitmap for the icon to use.
+		         BitmapEx aBmp (SdResId (bHighContrast 
+                               ? Hbitmap
+                              : Lbitmap));
+                // need to reverse the bitmap image for right to left
+		         if(bRightToLeft && (wm != WritingMode_TB_RL))
+		            aBmp.Mirror(BMP_MIRROR_HORZ);
+                  // insert into the menu
+		          InsertItem (index, aBmp, name);
+                  // set the index into the layout list to
+                  // be passed back to SdPage.
+                  SetItemData (index, new AutoLayout(lnum));
+                  index++; // go to next menu item
+		       
+		      } //if wm...
+	       } //if layout..
+	    } // for...
+    }  // if (aViewExists...
 
     mbSelectionUpdatePending = true;
 }
@@ -899,9 +852,7 @@ void LayoutMenu::UpdateSelection (void)
 
         // Get layout of current page.
         AutoLayout aLayout (pCurrentPage->GetAutoLayout());
-        if (aLayout<AUTOLAYOUT__START || aLayout>AUTOLAYOUT__END)
-            break;
-
+    
         // Find the entry of the menu for to the layout.
         USHORT nItemCount (GetItemCount());
         for (USHORT nId=1; nId<=nItemCount; nId++)
diff --git sd/source/ui/toolpanel/LayoutMenu.hxx sd/source/ui/toolpanel/LayoutMenu.hxx
index aad1dd0..e54000b 100644
--- sd/source/ui/toolpanel/LayoutMenu.hxx
+++ sd/source/ui/toolpanel/LayoutMenu.hxx
@@ -39,6 +39,7 @@
 
 #include "glob.hxx"
 #include "pres.hxx"
+#include "layoutlist.hxx"
 #include <vcl/ctrl.hxx>
 #include <svtools/valueset.hxx>
 #include <svtools/transfer.hxx>
@@ -196,7 +197,7 @@ private:
         If no slide sorter is active then this call is ignored.  The slide
         sorter in the center pane is preferred if the choice exists.
     */
-    void AssignLayoutToSelectedSlides (AutoLayout aLayout);
+    void AssignLayoutToSelectedSlides (sd::AutoLayout aLayout);
 
     /** Insert a new page with the given layout.  The page is inserted via
         the main view shell, i.e. its SID_INSERTPAGE slot is called.  It it
@@ -204,7 +205,7 @@ private:
         place.  The new page is inserted after the currently active one (the
         one returned by ViewShell::GetActualPage().)
     */
-    void InsertPageWithLayout (AutoLayout aLayout);
+    void InsertPageWithLayout (sd::AutoLayout aLayout);
 
     /** Create a request structure that can be used with the SID_INSERTPAGE
         and SID_MODIFYPAGE slots.  The parameters are set so that the given
@@ -216,7 +217,7 @@ private:
     */
     SfxRequest CreateRequest (
         USHORT nSlotId,
-        AutoLayout aLayout);
+        sd::AutoLayout aLayout);
 
     /** Select the layout that is used by the current page.
     */
diff --git sd/source/ui/unoidl/unopage.cxx sd/source/ui/unoidl/unopage.cxx
index 5b5a478..c653f53 100644
--- sd/source/ui/unoidl/unopage.cxx
+++ sd/source/ui/unoidl/unopage.cxx
@@ -36,6 +36,7 @@
 #include <com/sun/star/presentation/AnimationEffect.hpp>
 #include <com/sun/star/presentation/PresentationRange.hpp>
 #include <com/sun/star/presentation/AnimationSpeed.hpp>
+#include <com/sun/star/presentation/XLayoutList.hpp>
 #include <com/sun/star/view/PaperOrientation.hpp>
 #include <com/sun/star/animations/AnimationNodeType.hpp>
 #include <com/sun/star/presentation/EffectNodeType.hpp>
@@ -120,7 +121,7 @@ enum WID_PAGE
     WID_PAGE_PAGENUMBERVISIBLE, WID_PAGE_DATETIMEVISIBLE, WID_PAGE_DATETIMEFIXED, 
     WID_PAGE_DATETIMETEXT, WID_PAGE_DATETIMEFORMAT, WID_TRANSITION_TYPE, WID_TRANSITION_SUBTYPE,
     WID_TRANSITION_DIRECTION, WID_TRANSITION_FADE_COLOR, WID_TRANSITION_DURATION, WID_LOOP_SOUND,
-    WID_NAVORDER, WID_PPT_THEME
+    WID_NAVORDER, WID_AUTOLAYOUT_LIST, WID_PPT_THEME
 };
 
 #ifndef SEQTYPE
@@ -177,6 +178,7 @@ const SfxItemPropertyMap* ImplGetDrawPagePropertyMap( sal_Bool bImpress, PageKin
         { MAP_CHAR_LEN("TransitionDuration"),			WID_TRANSITION_DURATION, &::getCppuType((const double*)0),			0,	0},
         { MAP_CHAR_LEN("LoopSound"),					WID_LOOP_SOUND, &::getBooleanCppuType(),					0, 0},
         { MAP_CHAR_LEN("NavigationOrder"),				WID_NAVORDER, &::com::sun::star::container::XIndexAccess::static_type(),0,	0},
+        { MAP_CHAR_LEN("AutoLayoutList"),               WID_AUTOLAYOUT_LIST, &::getCppuType((const Reference< ::com::sun::star::presentation::XLayoutList >*)0), beans::PropertyAttribute::READONLY, 0},
         {0,0,0,0,0,0}
     };
 
@@ -207,7 +209,7 @@ const SfxItemPropertyMap* ImplGetDrawPagePropertyMap( sal_Bool bImpress, PageKin
         { MAP_CHAR_LEN("DateTimeText"),					WID_PAGE_DATETIMETEXT, &::getCppuType((const OUString*)0),				0,	0},
         { MAP_CHAR_LEN("DateTimeFormat"),				WID_PAGE_DATETIMEFORMAT, &::getCppuType((const sal_Int32*)0),			0,	0},
         { MAP_CHAR_LEN("NavigationOrder"),				WID_NAVORDER, &::com::sun::star::container::XIndexAccess::static_type(),0,	0},
-
+        { MAP_CHAR_LEN("AutoLayoutList"),               WID_AUTOLAYOUT_LIST, &::getCppuType((const Reference< ::com::sun::star::presentation::XLayoutList >*)0), beans::PropertyAttribute::READONLY, 0},
         {0,0,0,0,0,0}
     };
 
@@ -268,6 +270,7 @@ const SfxItemPropertyMap* ImplGetMasterPagePropertyMap( PageKind ePageKind )
         { MAP_CHAR_LEN(sUNO_Prop_UserDefinedAttributes),WID_PAGE_USERATTRIBS, &::getCppuType((const Reference< ::com::sun::star::container::XNameContainer >*)0)  , 		0,     0},
         { MAP_CHAR_LEN("IsBackgroundDark" ),			WID_PAGE_ISDARK,	&::getBooleanCppuType(),						beans::PropertyAttribute::READONLY, 0},
 		{ MAP_CHAR_LEN("PPTTheme"),                     WID_PPT_THEME, &::getCppuType((uno::Reference<xml::dom::XDocument>*)0), 0, 0},
+        { MAP_CHAR_LEN("AutoLayoutList"),               WID_AUTOLAYOUT_LIST, &::getCppuType((const Reference< ::com::sun::star::presentation::XLayoutList >*)0), beans::PropertyAttribute::READONLY, 0},
         {0,0,0,0,0,0}
     };
 
@@ -292,6 +295,7 @@ const SfxItemPropertyMap* ImplGetMasterPagePropertyMap( PageKind ePageKind )
         { MAP_CHAR_LEN("IsDateTimeFixed"),				WID_PAGE_DATETIMEFIXED, &::getBooleanCppuType(),					0, 0},
         { MAP_CHAR_LEN("DateTimeText"),					WID_PAGE_DATETIMETEXT, &::getCppuType((const OUString*)0),				0,	0},
         { MAP_CHAR_LEN("DateTimeFormat"),				WID_PAGE_DATETIMEFORMAT, &::getCppuType((const sal_Int32*)0),			0,	0},
+        { MAP_CHAR_LEN("AutoLayoutList"),               WID_AUTOLAYOUT_LIST, &::getCppuType((const Reference< ::com::sun::star::presentation::XLayoutList >*)0), beans::PropertyAttribute::READONLY, 0},
         {0,0,0,0,0,0}
     };
 
@@ -508,6 +512,8 @@ void SAL_CALL SdGenericDrawPage::setPropertyValue( const OUString& aPropertyName
         case WID_NAVORDER:
             setNavigationOrder( aValue );
             break;
+        case WID_AUTOLAYOUT_LIST:
+            break; // do nothing for now
         case WID_PAGE_LEFT:
         case WID_PAGE_RIGHT:
         case WID_PAGE_TOP:
@@ -538,7 +544,7 @@ void SAL_CALL SdGenericDrawPage::setPropertyValue( const OUString& aPropertyName
                 GetPage()->SetPresChange( (PresChange)nValue );
                 break;
             case WID_PAGE_LAYOUT:
-                GetPage()->SetAutoLayout( (AutoLayout)nValue, sal_True );
+				GetPage()->SetAutoLayout( (sd::AutoLayout)nValue, sal_True );
                 break;
             case WID_PAGE_DURATION:
                 GetPage()->SetTime((sal_uInt32)nValue);
@@ -911,6 +917,9 @@ Any SAL_CALL SdGenericDrawPage::getPropertyValue( const OUString& PropertyName )
 
     switch( pMap ? pMap->nWID : -1 )
     {
+    case WID_AUTOLAYOUT_LIST:
+         aAny <<= Reference< ::com::sun::star::presentation::XLayoutList >( GetLayoutList() ) ;
+         break;
     case WID_NAVORDER:
         aAny = getNavigationOrder();
         break;
diff --git sd/source/ui/view/ViewShellImplementation.cxx sd/source/ui/view/ViewShellImplementation.cxx
index 4b870f4..548655e 100644
--- sd/source/ui/view/ViewShellImplementation.cxx
+++ sd/source/ui/view/ViewShellImplementation.cxx
@@ -227,20 +227,12 @@ void ViewShell::Implementation::ProcessModifyPageSlot (
             SFX_REQUEST_ARG (rRequest, pBVisible, SfxBoolItem, ID_VAL_ISPAGEBACK, FALSE);
             SFX_REQUEST_ARG (rRequest, pBObjsVisible, SfxBoolItem, ID_VAL_ISPAGEOBJ, FALSE);
             AutoLayout aLayout ((AutoLayout)pNewAutoLayout->GetValue ());
-            if (aLayout >= AUTOLAYOUT__START
-                && aLayout < AUTOLAYOUT__END)
-            {
-                aNewName		= pNewName->GetValue ();
-                aNewAutoLayout = (AutoLayout) pNewAutoLayout->GetValue ();
-                bBVisible		= pBVisible->GetValue ();
-                bBObjsVisible	= pBObjsVisible->GetValue ();
-            }
-            else
-            {
-                StarBASIC::FatalError (SbERR_BAD_PROP_VALUE);
-                rRequest.Ignore ();
-                break;
-            }
+           
+            aNewName		= pNewName->GetValue ();
+            aNewAutoLayout = (AutoLayout) pNewAutoLayout->GetValue ();
+            bBVisible		= pBVisible->GetValue ();
+            bBObjsVisible	= pBObjsVisible->GetValue ();
+                
             if (ePageKind == PK_HANDOUT)
             {
                 bHandoutMode = TRUE;
diff --git sd/source/ui/view/unmodpg.cxx sd/source/ui/view/unmodpg.cxx
index 5c58574..9ff3d8a 100644
--- sd/source/ui/view/unmodpg.cxx
+++ sd/source/ui/view/unmodpg.cxx
@@ -63,7 +63,7 @@ ModifyPageUndoAction::ModifyPageUndoAction(
     SdDrawDocument* pTheDoc,
     SdPage* pThePage,
     String aTheNewName,
-    AutoLayout	eTheNewAutoLayout,
+	sd::AutoLayout	eTheNewAutoLayout,
     BOOL bTheNewBckgrndVisible,
     BOOL bTheNewBckgrndObjsVisible)
 :	SdUndoAction(pTheDoc),
diff --git sd/source/ui/view/viewshe3.cxx sd/source/ui/view/viewshe3.cxx
index 6690b9c..31c07c9 100644
--- sd/source/ui/view/viewshe3.cxx
+++ sd/source/ui/view/viewshe3.cxx
@@ -293,33 +293,20 @@ SdPage* ViewShell::CreateOrDuplicatePage (
         SFX_REQUEST_ARG (rRequest, pIsPageBack, SfxBoolItem, ID_VAL_ISPAGEBACK, FALSE);
         SFX_REQUEST_ARG (rRequest, pIsPageObj, SfxBoolItem, ID_VAL_ISPAGEOBJ, FALSE);
 
-        if (CHECK_RANGE (AUTOLAYOUT__START, (AutoLayout) pLayout->GetValue (), AUTOLAYOUT__END))
+        if (ePageKind == PK_NOTES)
         {
-            if (ePageKind == PK_NOTES)
-            {
-                aNotesPageName = pPageName->GetValue ();
-                eNotesLayout   = (AutoLayout) pLayout->GetValue ();
-            }
-            else
-            {
-                aStandardPageName = pPageName->GetValue ();
-                eStandardLayout   = (AutoLayout) pLayout->GetValue ();
-            }
-
-            bIsPageBack = pIsPageBack->GetValue ();
-            bIsPageObj	= pIsPageObj->GetValue ();
+           aNotesPageName = pPageName->GetValue ();
+           eNotesLayout   = (AutoLayout) pLayout->GetValue ();
         }
         else
         {
-            Cancel();
-                
-            if(HasCurrentFunction( SID_BEZIER_EDIT ) )
-                GetViewFrame()->GetDispatcher()->Execute(SID_OBJECT_SELECT, SFX_CALLMODE_ASYNCHRON);
-
-            StarBASIC::FatalError (SbERR_BAD_PROP_VALUE);
-            rRequest.Ignore ();
-            return NULL;
+            aStandardPageName = pPageName->GetValue ();
+            eStandardLayout   = (AutoLayout) pLayout->GetValue ();
         }
+
+        bIsPageBack = pIsPageBack->GetValue ();
+        bIsPageObj	= pIsPageObj->GetValue ();
+        
     }
 
     // 2. Create a new page or duplicate an existing one.
diff --git sd/test/export.map sd/test/export.map
new file mode 100644
index 0000000..6e36ffc
--- /dev/null
+++ sd/test/export.map
@@ -0,0 +1,38 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: export.map,v $
+#
+# $Revision: 1.4 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+UDK_3.1 {
+    global:
+		registerAllTestFunction;
+
+    local:
+        *;
+};
diff --git sd/test/layouttest.cxx sd/test/layouttest.cxx
new file mode 100644
index 0000000..e52dd11
--- /dev/null
+++ sd/test/layouttest.cxx
@@ -0,0 +1,323 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: layouttest.cxx,v $
+ * $Revision: 1.14 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+// autogenerated file with codegen.pl
+
+#include <cppunit/simpleheader.hxx>
+#include <com/sun/star/text/WritingMode.hpp>
+#include "layoutlist.hxx"
+
+using namespace sd;
+using namespace rtl;
+
+class LayoutTest : public CppUnit::TestFixture
+{
+public:
+    LayoutTest() {}
+
+    // initialise your test code values here.
+    void setUp()
+    {
+    }
+
+    void tearDown()
+    {
+    }
+
+    // insert your test code here.
+    void layoutTypeTest()
+    {
+		// test values;
+        LayoutType* aTestType = new LayoutType();
+		sal_uInt32 num, listsize;
+
+		sal_Int32 kind;
+		bool vertical;
+		double fx, fy, ht, wt;
+		RectType rt;
+		WritingMode wm;
+        PageKind pg;
+		sal_uInt32 Hbitmap;
+		sal_uInt32 Lbitmap;
+		
+		ElemType* elem1 = new ElemType;
+		ElemType* elem2;
+		ElemType* elem3 = new ElemType;
+		ElemType* elem4 = new ElemType;
+		
+		LString name1(LString::CreateFromAscii("chart"));
+		LString name2;
+
+        // set and get name
+        aTestType->setName(name1);
+		name2 = aTestType->getName();
+        CPPUNIT_ASSERT_MESSAGE("getName/setName", name1 == name2);
+				
+		// set and get string resource id
+		aTestType->setStrId(10000);
+		num = aTestType->getStrId();
+		CPPUNIT_ASSERT_MESSAGE("getStrId/setStrId", num == 10000);
+        
+        // set and get writing mode for layout
+		aTestType->setWritingMode(WritingMode_LR_TB);
+		wm = aTestType->getWritingMode();
+		CPPUNIT_ASSERT_MESSAGE("setwritemode/getwritemode", WritingMode_LR_TB == wm);
+        
+        // set and get PageKind for layout
+		aTestType->setPageKind(PK_HANDOUT);
+		pg = aTestType->getPageKind();
+		CPPUNIT_ASSERT_MESSAGE("setpagekind/getpagekind", PK_HANDOUT  == pg);
+		
+		// set and get High Bitmap
+		aTestType->setHBitmapId(170);
+		Hbitmap = aTestType->getHBitmapId();
+		CPPUNIT_ASSERT_MESSAGE("setHbitmap/getHbitmap", 170 == Hbitmap);
+		
+		// set and get Low Bitmap
+	    aTestType->setLBitmapId(388);
+		Lbitmap = aTestType->getLBitmapId();
+		CPPUNIT_ASSERT_MESSAGE("setLbitmap/getLbitmap", 388 == Lbitmap);
+		
+		 // add an element to the list.
+        aTestType->addElemToList(*elem1);
+        
+		// set and get kind of 1st element in list
+		aTestType->setPresKind(0,PRESOBJ_CHART);
+        kind = aTestType->getPresKind(0);
+		CPPUNIT_ASSERT_MESSAGE("getPresKind/setPresKind", PRESOBJ_CHART == kind);
+		
+		// set and get isvertical for 1st element
+		aTestType->setVertical(0,true);
+        vertical = aTestType->isVertical(0);
+		CPPUNIT_ASSERT_MESSAGE("setVertical/isVertical", vertical);
+		
+		
+		// set and get X factor for 1st element
+		aTestType->setFactorX(0, .5);
+		fx = aTestType->factorX(0);
+		CPPUNIT_ASSERT_MESSAGE("setfactorx/getfactorx", .5 == fx);
+		
+		// set and get Y factor for 1st element
+		aTestType->setFactorY(0, .75);
+		fy = aTestType->factorY(0);
+		CPPUNIT_ASSERT_MESSAGE("setfactory/getfactory", .75 == fy);
+		
+		// set and get Height factor for 1st element
+		aTestType->setFactorHt(0, .84);
+		ht = aTestType->factorHt(0);
+		CPPUNIT_ASSERT_MESSAGE("setfactorht/getfactorht", .84 == ht);
+		
+		// set and get Width factor for 1st element
+		aTestType->setFactorWt(0, 1.25);
+		wt = aTestType->factorWt(0);
+		CPPUNIT_ASSERT_MESSAGE("setfactorwt/getfactorwt", 1.25 == wt);
+		
+		// set and get rectangle type for 1st element
+		aTestType->setRecttype(0, RT_TITLE);
+		rt = aTestType->recttype(0);
+		CPPUNIT_ASSERT_MESSAGE("setrecttype/getrecttype", RT_TITLE == rt);
+		
+		// set up some elements to add
+		elem3->kind = PRESOBJ_IMAGE;
+		elem4->kind = PRESOBJ_OBJECT;
+		
+		// get an element by its index in the list
+		elem2 = aTestType->getElemByIndex(0);
+		CPPUNIT_ASSERT_MESSAGE("addelem/getbyindex0",  elem1 == elem2);
+		
+		// add an element to the list (at the end)
+		aTestType->addElemToList(*elem3);
+		listsize = aTestType->length();
+		CPPUNIT_ASSERT_MESSAGE("addelem/listsize", listsize == 2);
+		
+        // get an element by index and check to see if equal
+		elem2 = aTestType->getElemByIndex(1);		
+		CPPUNIT_ASSERT_MESSAGE("addelem/getbyindex1",  elem3 == elem2);
+		
+		// test the creating of a default element
+		// get it and check to see if set to a title
+		aTestType->createDefaultElement();
+		elem2 = aTestType->getElemByIndex(2);
+		CPPUNIT_ASSERT_MESSAGE("createelement", ((elem2)&&(elem2->kind == PRESOBJ_TITLE)) );
+        
+        // delete an element from the list (0 position)
+		aTestType->deleteElement(0);
+		listsize = aTestType->length();
+		CPPUNIT_ASSERT_MESSAGE("deleteElem/listsize", listsize == 2);
+        // deleting should move elements up one
+        elem2 = aTestType->getElemByIndex(0);
+        CPPUNIT_ASSERT_MESSAGE("deleteElem/checkElem", elem3 == elem2);
+   
+	
+    }
+	
+
+    // insert your test code here.
+    void layoutListTest()
+    {
+		
+        LayoutType* alayout1 = new LayoutType();
+		LayoutType* alayout3;
+		LayoutType* alayout2;
+        LayoutList* aTestList = new LayoutList(true);
+		Rectangle arect;
+		sal_uInt32 listsize, layoutcnt;
+		sal_uInt32 start_size = aTestList->length();
+		
+		// set up a LayoutType
+		LString name1(LString::CreateFromAscii("ateststring"));
+		LString name2(LString::CreateFromAscii("anotherone")); 
+        LString name3(LString::CreateFromAscii("defaultname"));
+
+		alayout1->setName(name1);
+	
+		alayout1->createDefaultElement();
+		alayout1->createDefaultElement();
+		alayout1->setPresKind(1, PRESOBJ_OUTLINE);
+		
+		// add the layout to the list at menu index 0
+		aTestList->addLayout(alayout1, 0, PK_STANDARD);
+	    alayout2 = aTestList->getLayoutByName(name1);
+        CPPUNIT_ASSERT_MESSAGE("addlayout/getbyname/nolayout",  alayout2);
+        if(alayout2)
+        {
+		   CPPUNIT_ASSERT_MESSAGE("addlayout/getbyname/samelayout",  alayout1 == alayout2);
+        }
+        
+        // get the layout out of the list
+		alayout2 = aTestList->getLayoutByIndex(start_size);
+        CPPUNIT_ASSERT_MESSAGE("getbyindex/nolayout",  alayout2);
+        if(alayout2)
+        {
+		   CPPUNIT_ASSERT_MESSAGE("getbyindex/samelayout", alayout2->getName() == name1);
+        }
+
+         		
+		// make sure a layout with the same name can't be added
+		alayout3 = new LayoutType();
+		alayout3->setName(name1);
+
+		CPPUNIT_ASSERT_MESSAGE("insertsamename", !aTestList->addLayout(alayout3, 2, PK_STANDARD));
+		// make sure a layout with a different name can be added
+		alayout3->setName(name2);
+		
+		listsize = aTestList->length();
+		layoutcnt = aTestList->numberOfLayouts();
+		CPPUNIT_ASSERT_MESSAGE("insertdiffname", aTestList->addLayout(alayout3, 1, PK_STANDARD));
+		// check list size and number of layouts.
+		CPPUNIT_ASSERT_MESSAGE("listsize", (listsize+1) == aTestList->length());
+	    CPPUNIT_ASSERT_MESSAGE("remove/numberoflayouts", (layoutcnt+1) == aTestList->numberOfLayouts());
+
+        // test for get layout by name for the second layout
+          
+	    alayout2 = aTestList->getLayoutByName(name2);
+		CPPUNIT_ASSERT_MESSAGE("getbyname2/nolayout",  alayout2);
+        if(alayout2)
+        {
+           CPPUNIT_ASSERT_MESSAGE("getbyname2/correct", alayout2->getName() == name2 );
+        }
+
+
+		// remove a layout from the list (number of layouts
+		// should be different from size of list)
+		sal_uInt32 origsize = aTestList->length();
+		sal_uInt32 origcount = aTestList->numberOfLayouts();
+		
+		aTestList->deleteLayoutFromList(name1);
+		layoutcnt = aTestList->numberOfLayouts();
+		CPPUNIT_ASSERT_MESSAGE("remove/numberoflayouts", layoutcnt == (origcount-1));
+		listsize = aTestList->length();
+		CPPUNIT_ASSERT_MESSAGE("remove/listlength", listsize == origsize);
+
+		// test inserting a layout's index in the menu list
+		alayout2 = aTestList->getLayoutAtMenuIndex(0, PK_STANDARD);
+	    CPPUNIT_ASSERT_MESSAGE("getLayoutMenuidx/nolayout", alayout2 );
+        if(alayout2)
+        {
+           CPPUNIT_ASSERT_MESSAGE("getlayoutmenuidx/correct", alayout2->getName() == alayout3->getName() );
+        }
+	   
+       // add layout1 back at menu 2
+        alayout1 = new LayoutType();
+        alayout1->setName(name1);
+        aTestList->addLayout(alayout1, 2, PK_STANDARD);
+        sal_uInt32 num = aTestList->getLayoutIndex(name1);
+        CPPUNIT_ASSERT_MESSAGE("re-add/correct",  num == 0 );
+        
+        
+	    // test the length of a menu list
+	    sal_uInt32 count = aTestList->getMenuLength(PK_HANDOUT);
+	    CPPUNIT_ASSERT_MESSAGE("getMenuLength", count = 6);
+		
+   
+        
+		// get a layout's index at the given menu index
+		// this is for layout3
+	    sal_uInt32 idx = aTestList->getMenuIndex(3, PK_STANDARD);
+		CPPUNIT_ASSERT_MESSAGE("getMenuIndex", idx = 1);
+	  
+	    //remove the layout from the menu
+	    aTestList->removeFromMenuList(1, PK_STANDARD);
+		CPPUNIT_ASSERT_MESSAGE("removeMenuIndex", idx = 1);
+	   
+	   // add a layout to the menu list
+	   aTestList->addToMenuList(0, 6, PK_STANDARD);
+	   CPPUNIT_ASSERT_MESSAGE("addtoMenu", idx = 1);
+      
+      
+       
+    }
+
+    // Change the following lines only, if you add, remove or rename 
+    // member functions of the current class, 
+    // because these macros are need by auto register mechanism.
+
+    CPPUNIT_TEST_SUITE(LayoutTest);
+    CPPUNIT_TEST(layoutListTest);
+    CPPUNIT_TEST(layoutTypeTest);
+    CPPUNIT_TEST_SUITE_END();
+	
+	
+	
+}; // class b2dvector
+
+// -----------------------------------------------------------------------------
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(LayoutTest, "layout test");
+
+// -----------------------------------------------------------------------------
+
+// this macro creates an empty function, which will called by the RegisterAllFunctions()
+// to let the user the possibility to also register some functions by hand.
+NOADDITIONAL;
+
diff --git sd/test/makefile.mk sd/test/makefile.mk
new file mode 100644
index 0000000..60080d2
--- /dev/null
+++ sd/test/makefile.mk
@@ -0,0 +1,91 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.7 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..
+
+PRJNAME=sd
+TARGET=tests
+
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Common ----------------------------------------------------------
+
+SHL1OBJS=  \
+	$(SLO)$/layouttest.obj \
+	$(SLO)$/layoutlist.obj \
+	$(SLO)$/layouttype.obj
+
+# linking statically against sd parts
+#SHL1LIBS=$(SLB)$/core.lib
+
+SHL1TARGET= sd_tests
+SHL1STDLIBS= \
+                         $(CPPUHELPERLIB) \
+                         $(CPPULIB)       \
+                         $(CPPUNITLIB)    \
+                         $(TOOLSLIB)      \
+                         $(SALLIB)        \
+                         $(ISDLIB)        \
+                         $(SAXLIB)        \
+						 $(UNOTOOLSLIB)   \
+						 $(VCLLIB)
+
+
+SHL1IMPLIB= i$(SHL1TARGET)
+
+DEF1NAME    =$(SHL1TARGET)
+SHL1VERSIONMAP = export.map 
+
+# END ------------------------------------------------------------------
+
+#------------------------------- All object files -------------------------------
+# do this here, so we get correct dependencies
+SLOFILES=$(SHL1OBJS) 
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : target.mk
+.INCLUDE : _cppunit.mk 
+
+# --- Enable testshl2 execution in normal build ------------------------
+
+$(MISC)$/unittest_succeeded : $(SHL1TARGETN)
+		@echo ----------------------------------------------------------
+		@echo - start unit test on library $(SHL1TARGETN)
+		@echo ----------------------------------------------------------
+		testshl2 -sf $(mktmp ) -forward $(BIN)$/ $(SHL1TARGETN)
+		$(TOUCH) $@
+
+ALLTAR : $(MISC)$/unittest_succeeded
diff --git sd/util/makefile.mk sd/util/makefile.mk
index 2458fb2..f7da7aa 100644
--- sd/util/makefile.mk
+++ sd/util/makefile.mk
@@ -91,7 +91,8 @@ SHL1STDLIBS+= \
     $(VOSLIB) \
     $(CANVASLIB) \
     $(SALLIB) \
-    $(AVMEDIALIB)
+	$(AVMEDIALIB) \
+	$(SAXLIB)
 
 SHL1LIBS= $(LIB3TARGET) $(LIB5TARGET) $(LIB6TARGET)
 SHL1DEPN+=	makefile.mk
diff --git xmloff/source/draw/sdxmlexp.cxx xmloff/source/draw/sdxmlexp.cxx
index 49c1510..484fa67 100644
--- xmloff/source/draw/sdxmlexp.cxx
+++ xmloff/source/draw/sdxmlexp.cxx
@@ -47,6 +47,11 @@
 #include <com/sun/star/drawing/XMasterPagesSupplier.hpp>
 #include <com/sun/star/presentation/XHandoutMasterSupplier.hpp>
 #include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/presentation/XLayoutList.hpp>
+#include <com/sun/star/presentation/UnoAutoLayout.hpp>
+#include <com/sun/star/presentation/UnoPresKind.hpp>
+#include <com/sun/star/awt/Rectangle.hpp>
+#include <com/sun/star/awt/Size.hpp>
 #include <com/sun/star/view/PaperOrientation.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/style/XStyle.hpp>
@@ -209,11 +214,13 @@ DECLARE_LIST(ImpXMLEXPPageMasterList, ImpXMLEXPPageMasterInfo*)
 
 //////////////////////////////////////////////////////////////////////////////
 
-#define	IMP_AUTOLAYOUT_INFO_MAX			(33L)
-
 class ImpXMLAutoLayoutInfo
 {
     sal_uInt16					mnType;
+    UnoPresKind*                mpKinds;
+    Rectangle*                  mpRects;
+    bool*                       mpVertical;
+    sal_Int32                   mnElemCount;
     ImpXMLEXPPageMasterInfo*	mpPageMasterInfo;
     OUString					msLayoutName;
     Rectangle					maTitleRect;
@@ -222,7 +229,7 @@ class ImpXMLAutoLayoutInfo
     sal_Int32					mnGapY;
 
 public:
-    ImpXMLAutoLayoutInfo(sal_uInt16 nTyp, ImpXMLEXPPageMasterInfo* pInf);
+	ImpXMLAutoLayoutInfo(sal_uInt16 nTyp, ImpXMLEXPPageMasterInfo* pInf, Reference< XLayoutList > rLList);
 
     BOOL operator==(const ImpXMLAutoLayoutInfo& rInfo) const;
 
@@ -235,18 +242,13 @@ public:
 
     const Rectangle& GetTitleRectangle() const { return maTitleRect; }
     const Rectangle& GetPresRectangle() const { return maPresRect; }
-
-    static BOOL IsCreateNecessary(sal_uInt16 nTyp);
+    Rectangle* GetRects() const { return mpRects; }
+    UnoPresKind* GetKinds() const { return mpKinds; }
+    bool* GetVerticalList() const { return mpVertical; }
+    sal_Int32 GetElemCount() const { return mnElemCount; }
 };
 
-BOOL ImpXMLAutoLayoutInfo::IsCreateNecessary(sal_uInt16 nTyp)
-{
-    if(nTyp == 5 /* AUTOLAYOUT_ORG */
-        || nTyp == 20 /* AUTOLAYOUT_NONE */
-        || nTyp >= IMP_AUTOLAYOUT_INFO_MAX)
-        return FALSE;
-    return TRUE;
-}
+
 
 BOOL ImpXMLAutoLayoutInfo::operator==(const ImpXMLAutoLayoutInfo& rInfo) const
 {
@@ -254,15 +256,28 @@ BOOL ImpXMLAutoLayoutInfo::operator==(const ImpXMLAutoLayoutInfo& rInfo) const
         && mpPageMasterInfo == rInfo.mpPageMasterInfo));
 }
 
-ImpXMLAutoLayoutInfo::ImpXMLAutoLayoutInfo(sal_uInt16 nTyp, ImpXMLEXPPageMasterInfo* pInf)
+ImpXMLAutoLayoutInfo::ImpXMLAutoLayoutInfo(sal_uInt16 nTyp, ImpXMLEXPPageMasterInfo* pInf, Reference< XLayoutList > rLList)
 :	mnType(nTyp),
     mpPageMasterInfo(pInf)
 {
+    Size titlesize;
+    Point titlepos;
+    Size layoutsize;
+    Point layoutpos;
+    UnoPageKind kind;
+    
     // create full info (initialze with typical values)
     Point aPagePos(0,0);
     Size aPageSize(28000, 21000);
     Size aPageInnerSize(28000, 21000);
-
+   
+    
+    if(!rLList.is()) 
+    {
+        DBG_ERROR("ImpXMLAutoLayoutInfo::const:  No uno layout list!");
+        return;
+    }
+    
     if(mpPageMasterInfo)
     {
         aPagePos = Point(mpPageMasterInfo->GetBorderLeft(), mpPageMasterInfo->GetBorderTop());
@@ -270,85 +285,86 @@ ImpXMLAutoLayoutInfo::ImpXMLAutoLayoutInfo(sal_uInt16 nTyp, ImpXMLEXPPageMasterI
         aPageInnerSize = aPageSize;
         aPageInnerSize.Width() -= mpPageMasterInfo->GetBorderLeft() + mpPageMasterInfo->GetBorderRight();
         aPageInnerSize.Height() -= mpPageMasterInfo->GetBorderTop() + mpPageMasterInfo->GetBorderBottom();
+        
     }
-
-    // title rectangle aligning
+    
+    Size aTitleSize(aPageSize);
     Point aTitlePos(aPagePos);
-    Size aTitleSize(aPageInnerSize);
-
-    if(mnType == 21 /* AUTOLAYOUT_NOTES */)
-    {
-        aTitleSize.Height() = (long) (aTitleSize.Height() / 2.5);
-        Point aPos = aTitlePos;
-        aPos.Y() += long( aTitleSize.Height() * 0.083 );
-        Size aPartArea = aTitleSize;
-        Size aSize;
-
-        // tatsaechliche Seitengroesse in das Handout-Rechteck skalieren
-        double fH = (double) aPartArea.Width()  / aPageSize.Width();
-        double fV = (double) aPartArea.Height() / aPageSize.Height();
-
-        if ( fH > fV )
-            fH = fV;
-        aSize.Width()  = (long) (fH * aPageSize.Width());
-        aSize.Height() = (long) (fH * aPageSize.Height());
-
-        aPos.X() += (aPartArea.Width() - aSize.Width()) / 2;
-        aPos.Y() += (aPartArea.Height()- aSize.Height())/ 2;
-
-        aTitlePos = aPos;
-        aTitleSize = aSize;
-    }
-    else if(mnType == 27 || mnType == 28)
-    {
-        // AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART or
-        // AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE
-        Point aClassicTPos(
-            aTitlePos.X() + long( aTitleSize.Width() * 0.0735 ),
-            aTitlePos.Y() + long( aTitleSize.Height() * 0.083 ));
-        Size aClassicTSize(
-            long( aTitleSize.Width() * 0.854 ),
-            long( aTitleSize.Height() * 0.167 ));
-        Point aLPos(aPagePos);
-        Size aLSize(aPageInnerSize);
-        Point aClassicLPos(
-            aLPos.X() + long( aLSize.Width() * 0.0735 ),
-            aLPos.Y() + long( aLSize.Height() * 0.472 ));
-        Size aClassicLSize(
-            long( aLSize.Width() * 0.854 ),
-            long( aLSize.Height() * 0.444 ));
-
-        aTitlePos.X() = (aClassicTPos.X() + aClassicTSize.Width()) - aClassicTSize.Height();
-        aTitlePos.Y() = aClassicTPos.Y();
-        aTitleSize.Width() = aClassicTSize.Height();
-        aTitleSize.Height() = (aClassicLPos.Y() + aClassicLSize.Height()) - aClassicTPos.Y();
-    }
-    else
-    {
-        aTitlePos.X() += long( aTitleSize.Width() * 0.0735 );
-        aTitlePos.Y() += long( aTitleSize.Height() * 0.083 );
-        aTitleSize.Width() = long( aTitleSize.Width() * 0.854 );
-        aTitleSize.Height() = long( aTitleSize.Height() * 0.167 );
-    }
-
-    maTitleRect.SetPos(aTitlePos);
-    maTitleRect.SetSize(aTitleSize);
-
-    // layout rectangle aligning
-    Point aLayoutPos(aPagePos);
-    Size aLayoutSize(aPageInnerSize);
-
-    if(mnType == 21 /* AUTOLAYOUT_NOTES */)
-    {
-        aLayoutPos.X() += long( aLayoutSize.Width() * 0.0735 );
-        aLayoutPos.Y() += long( aLayoutSize.Height() * 0.472 );
-        aLayoutSize.Width() = long( aLayoutSize.Width() * 0.854 );
-        aLayoutSize.Height() = long( aLayoutSize.Height() * 0.444 );
+    
+     // taken from SdPage::getTitleRect and getLayoutRect
+    kind = rLList->getPageKind(nTyp);
+    if(kind == UnoPageKind_STANDARD)
+    {
+       titlesize.setWidth( long(aPageInnerSize.Width()*.9));
+       layoutsize.setWidth( long(aPageInnerSize.Width()*.9));
+       titlesize.setHeight(  long(aPageInnerSize.Height()*.167));
+       layoutsize.setHeight( long(aPageInnerSize.Height()*.66));
+       titlepos.X() = aPagePos.X() + long(aPageInnerSize.Width()*.05);
+       layoutpos.X() = aPagePos.X() + long(aPageInnerSize.Width()*.05);
+       titlepos.Y() = aPagePos.Y() + long(aPageInnerSize.Height()*.0399);
+       layoutpos.Y() = aPagePos.Y() + long(aPageInnerSize.Height()*.234);
+       
+    }
+    else if(kind == UnoPageKind_NOTES)
+    {
+       titlepos.X() = aPagePos.X();
+       titlepos.Y() = aPagePos.Y() + long(aPageInnerSize.Height()*.076);
+       titlesize.setWidth(aPageInnerSize.Width());
+       titlesize.setHeight( long(aPageInnerSize.Height()*.375));
+       layoutpos.X() = aPagePos.X() + long(aPageInnerSize.Width()*.1);
+       layoutpos.Y() = aPagePos.Y() + long(aPageInnerSize.Height()*.475);
+       layoutsize.setWidth( long(aPageInnerSize.Width()*.8));
+       layoutsize.setHeight( long(aPageInnerSize.Height()*.45));
+        
     }
-    else if((mnType >= 22 && mnType <= 26) || (mnType == 31)) // AUTOLAYOUT_HANDOUT
+    else // HANDOUT (or other)
+    {
+        // use pagesize and pos for title
+        titlepos = aPagePos;
+        layoutpos = aPagePos;
+        titlesize = aPageInnerSize;
+        layoutsize = aPageInnerSize;
+    }
+    
+    if(kind  != UnoPageKind_HANDOUT)
+    {
+       ::uno::Sequence< ::awt::Rectangle >  rectlist;
+       ::awt::Rectangle titlerect;
+       ::awt::Rectangle layoutrect;
+       ::awt::Rectangle arect;
+       ::awt::Size  pagesize;
+       
+       titlerect.X = titlepos.X();
+       titlerect.Y = titlepos.Y();
+       titlerect.Width = titlesize.Width();
+       titlerect.Height = titlesize.Height();
+       
+       layoutrect.X = layoutpos.X();
+       layoutrect.Y = layoutpos.Y();
+       layoutrect.Width = layoutsize.Width();
+       layoutrect.Height = layoutsize.Height();
+       
+       pagesize.Width = aPageInnerSize.Width();
+       pagesize.Height = aPageInnerSize.Height();
+       
+       rectlist = rLList->getAutoLayoutRectangles((sal_uInt32) nTyp, titlerect, layoutrect, pagesize, false);
+       
+       mnElemCount = rLList->getElementCount((sal_Int32) nTyp);
+       mpKinds = new UnoPresKind[mnElemCount];
+       mpVertical = new bool[mnElemCount];
+       mpRects = new Rectangle[mnElemCount];
+       
+       for(sal_Int32 i=0; i < mnElemCount; i++)
+       {
+           mpKinds[i] = rLList->getPresKind((sal_Int32) nTyp, i);
+           mpVertical[i] = rLList->isVertical((sal_Int32) nTyp, i);
+           arect = rectlist[i];
+           mpRects[i] = Rectangle( Point(arect.X, arect.Y), Size(arect.Width, arect.Height) );
+       }
+       
+    } 
+    else  // for HANDOUT, calculate gaps and use just the title rect
     {
-        // keep info for inner area in maPresRect, put info for gap size
-        // to maTitleRect position
         mnGapX = (aPageSize.Width() - aPageInnerSize.Width()) / 2;
         mnGapY = (aPageSize.Height() - aPageInnerSize.Height()) / 2;
 
@@ -363,47 +379,12 @@ ImpXMLAutoLayoutInfo::ImpXMLAutoLayoutInfo(sal_uInt16 nTyp, ImpXMLEXPPageMasterI
 
         if(mnGapY < aPageInnerSize.Height() / 10)
             mnGapY = aPageInnerSize.Height() / 10;
+            
+        mpRects = new Rectangle(aPagePos, aPageInnerSize);
+        mpVertical = new bool(false);
+        mpKinds = new UnoPresKind(UnoPresKind_HANDOUT);
     }
-    else if(mnType == 27 || mnType == 28)
-    {
-        // AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART or
-        // AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE
-        Point aClassicTPos(
-            aTitlePos.X() + long( aTitleSize.Width() * 0.0735 ),
-            aTitlePos.Y() + long( aTitleSize.Height() * 0.083 ));
-        Size aClassicTSize(
-            long( aTitleSize.Width() * 0.854 ),
-            long( aTitleSize.Height() * 0.167 ));
-        Point aClassicLPos(
-            aLayoutPos.X() + long( aLayoutSize.Width() * 0.0735 ),
-            aLayoutPos.Y() + long( aLayoutSize.Height() * 0.472 ));
-        Size aClassicLSize(
-            long( aLayoutSize.Width() * 0.854 ),
-            long( aLayoutSize.Height() * 0.444 ));
-
-        aLayoutPos.X() = aClassicLPos.X();
-        aLayoutPos.Y() = aClassicTPos.Y();
-        aLayoutSize.Width() = (aClassicLPos.X() + aClassicLSize.Width())
-            - (aClassicTSize.Height() + (aClassicLPos.Y() - (aClassicTPos.Y() + aClassicTSize.Height())));
-        aLayoutSize.Height() = (aClassicLPos.Y() + aClassicLSize.Height()) - aClassicTPos.Y();
-    }
-    else if( mnType == 32 )
-    {
-        // AUTOLAYOUT_ONLY_TEXT
-        aLayoutPos = aTitlePos;
-        aLayoutSize.Width() = aTitleSize.Width();
-        aLayoutSize.Height() = long( aLayoutSize.Height() * 0.825 );
-    }
-    else
-    {
-        aLayoutPos.X() += long( aLayoutSize.Width() * 0.0735 );
-        aLayoutPos.Y() += long( aLayoutSize.Height() * 0.278 );
-        aLayoutSize.Width() = long( aLayoutSize.Width() * 0.854 );
-        aLayoutSize.Height() = long( aLayoutSize.Height() * 0.630 );
-    }
-
-    maPresRect.SetPos(aLayoutPos);
-    maPresRect.SetSize(aLayoutSize);
+ 
 }
 
 DECLARE_LIST(ImpXMLAutoLayoutInfoList, ImpXMLAutoLayoutInfo*)
@@ -868,8 +849,6 @@ BOOL SdXMLExport::ImpPrepAutoLayoutInfo(const Reference<XDrawPage>& xPage, OUStr
         aAny = xPropSet->getPropertyValue(OUString(RTL_CONSTASCII_USTRINGPARAM("Layout")));
         if(aAny >>= nType)
         {
-            if(ImpXMLAutoLayoutInfo::IsCreateNecessary(nType))
-            {
                 ImpXMLEXPPageMasterInfo* pInfo = 0L;
 
                 // get master-page info
@@ -887,9 +866,21 @@ BOOL SdXMLExport::ImpPrepAutoLayoutInfo(const Reference<XDrawPage>& xPage, OUStr
                         }
                     }
                 }
+                
+                Reference< XLayoutList > llist;
+                
+                Reference< beans::XPropertySetInfo > xPropsInfo( xPropSet->getPropertySetInfo() );
+                if( xPropsInfo.is() )
+		        {
+                    if(xPropsInfo->hasPropertyByName(OUString(RTL_CONSTASCII_USTRINGPARAM("AutoLayoutList") )))
+                    {                
+                       aAny = xPropSet->getPropertyValue(OUString(RTL_CONSTASCII_USTRINGPARAM("AutoLayoutList")));
+                       aAny >>= llist;
+                    }
+                }    
 
                 // create entry and look for existance
-                ImpXMLAutoLayoutInfo* pNew = new ImpXMLAutoLayoutInfo(nType, pInfo);
+				ImpXMLAutoLayoutInfo* pNew = new ImpXMLAutoLayoutInfo(nType, pInfo, llist);
                 BOOL bDidExist(FALSE);
 
                 for(sal_uInt32 nCnt = 0L; !bDidExist && nCnt < mpAutoLayoutInfoList->Count(); nCnt++)
@@ -915,7 +906,7 @@ BOOL SdXMLExport::ImpPrepAutoLayoutInfo(const Reference<XDrawPage>& xPage, OUStr
                 rName = pNew->GetLayoutName();
                 bRetval = TRUE;
             }
-        }
+
     }
 
     return bRetval;
@@ -925,6 +916,17 @@ BOOL SdXMLExport::ImpPrepAutoLayoutInfo(const Reference<XDrawPage>& xPage, OUStr
 
 void SdXMLExport::ImpWriteAutoLayoutInfos()
 {
+    Rectangle* pRects;
+    UnoPresKind*  pKinds;
+    bool* pVertical;
+    sal_Int32 nType, nCount;
+    sal_Int32 nColCnt, nRowCnt;
+    sal_Int32 nGapX;
+    sal_Int32 nGapY;
+    Size aPartSize;
+    Point aPartPos, aTmpPos;
+
+    
     if(mpAutoLayoutInfoList->Count())
     {
         for(sal_uInt32 nCnt = 0L; nCnt < mpAutoLayoutInfoList->Count(); nCnt++)
@@ -938,328 +940,100 @@ void SdXMLExport::ImpWriteAutoLayoutInfos()
                 // write draw-style attributes
                 SvXMLElementExport aDSE(*this, XML_NAMESPACE_STYLE, XML_PRESENTATION_PAGE_LAYOUT, sal_True, sal_True);
 
-                // write presentation placeholders
-                switch(pInfo->GetLayoutType())
+                pRects = pInfo->GetRects();
+                pKinds = pInfo->GetKinds();
+                pVertical = pInfo->GetVerticalList();
+                nType = pInfo->GetLayoutType();
+                nCount = pInfo->GetElemCount();
+                nGapX = pInfo->GetGapX();
+                nGapY = pInfo->GetGapY();
+                
+                for(sal_Int32 i=0; i < nCount; i++)
                 {
-                    case 0 : // AUTOLAYOUT_TITLE
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderSubtitle, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 1 : // AUTOLAYOUT_ENUM
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 2 : // AUTOLAYOUT_CHART
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderChart, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 3 : // AUTOLAYOUT_2TEXT
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aRight);
-                        break;
-                    }
-                    case 4 : // AUTOLAYOUT_TEXTCHART
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderChart, aRight);
-                        break;
-                    }
-                    case 6 : // AUTOLAYOUT_TEXTCLIP
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderGraphic, aRight);
-                        break;
-                    }
-                    case 7 : // AUTOLAYOUT_CHARTTEXT
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderChart, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aRight);
-                        break;
-                    }
-                    case 8 : // AUTOLAYOUT_TAB
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTable, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 9 : // AUTOLAYOUT_CLIPTEXT
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderGraphic, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aRight);
-                        break;
-                    }
-                    case 10 : // AUTOLAYOUT_TEXTOBJ
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aRight);
-                        break;
-                    }
-                    case 11 : // AUTOLAYOUT_OBJ
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 12 : // AUTOLAYOUT_TEXT2OBJ
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRightTop(aLeft);
-                        aRightTop.Left() = long(aRightTop.Left() + aRightTop.GetWidth() * 1.05);
-                        aRightTop.setHeight(long(aRightTop.GetHeight() * 0.477));
-                        Rectangle aRightBottom(aRightTop);
-                        aRightBottom.Top() = long(aRightBottom.Top() + aRightBottom.GetHeight() * 1.095);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aRightTop);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aRightBottom);
-                        break;
-                    }
-                    case 13 : // AUTOLAYOUT_OBJTEXT
+                    switch (pKinds[i]) 
                     {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aRight);
+                        case UnoPresKind_TITLE: if(pVertical[i])
+                                                  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalTitle, pRects[i]);
+                                                else
+                                                  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pRects[i]);
+                                                break;
+                        case UnoPresKind_TEXT:  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderText, pRects[i]);
+                                                break;
+                        case UnoPresKind_OUTLINE: if(pVertical[i])
+                                                    ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalOutline, pRects[i]);
+                                                  else
+                                                    ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, pRects[i]);
+                                                  break;
+                        case UnoPresKind_CHART:  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderChart, pRects[i]);
+                                                 break;
+                        case UnoPresKind_TABLE:  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTable, pRects[i]);
+                                                 break;
+                        case UnoPresKind_IMAGE:
+                        case UnoPresKind_GRAPHIC: ImpWriteAutoLayoutPlaceholder(XmlPlaceholderGraphic, pRects[i]);
+                                                  break;
+                        case UnoPresKind_OBJECT: ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, pRects[i]);
+                                                 break;
+                        case UnoPresKind_NOTES:  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderNotes, pRects[i]);
+                                                 break;
+                        case UnoPresKind_PAGE:   ImpWriteAutoLayoutPlaceholder(XmlPlaceholderPage, pRects[i]);
+                                                 break;
+                        case UnoPresKind_HANDOUT: 
+						   switch(nType)
+						   {
+							   case UnoAutoLayout_HANDOUT1 : nColCnt = 1; nRowCnt = 1; break;
+							   case UnoAutoLayout_HANDOUT2 : nColCnt = 1; nRowCnt = 2; break;
+							   case UnoAutoLayout_HANDOUT3 : nColCnt = 1; nRowCnt = 3; break;
+							   case UnoAutoLayout_HANDOUT4 : nColCnt = 2; nRowCnt = 2; break;
+							   case UnoAutoLayout_HANDOUT6 : nColCnt = 3; nRowCnt = 2; break;
+							   case UnoAutoLayout_HANDOUT9 : nColCnt = 3; nRowCnt = 3; break;
+							   default:  nColCnt = 0; nRowCnt = 0; break; 
+						   }
+
+						   aPartSize = pRects->GetSize();
+						   aPartPos = pRects->TopLeft();
+
+						   if(aPartSize.Width() > aPartSize.Height())
+						   {
+							  sal_Int32 nZwi(nColCnt);
+							  nColCnt = nRowCnt;
+							  nRowCnt = nZwi;
+						   }
+
+						   aPartSize.Width() = (aPartSize.Width() - ((nColCnt - 1) * nGapX)) / nColCnt;
+						   aPartSize.Height() = (aPartSize.Height() - ((nRowCnt - 1) * nGapY)) / nRowCnt;
+
+						   aTmpPos = aPartPos;
+
+						   for(sal_Int32 a = 0L; a < nRowCnt; a++)
+						   {
+							  aTmpPos.X() = aPartPos.X();
+
+							  for(sal_Int32 b = 0L; b < nColCnt; b++)
+							  {
+								  Rectangle aTmpRect(aTmpPos, aPartSize);
+
+								  ImpWriteAutoLayoutPlaceholder(XmlPlaceholderHandout, aTmpRect);
+								  aTmpPos.X() += aPartSize.Width() + nGapX;
+							  }
+
+							  aTmpPos.Y() += aPartSize.Height() + nGapY;
+						   }
                         break;
-                    }
-                    case 14 : // AUTOLAYOUT_OBJOVERTEXT
-                    {
-                        Rectangle aTop(pInfo->GetPresRectangle());
-                        aTop.setHeight(long(aTop.GetHeight() * 0.477));
-                        Rectangle aBottom(aTop);
-                        aBottom.Top() = long(aBottom.Top() + aBottom.GetHeight() * 1.095);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aTop);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aBottom);
-                        break;
-                    }
-                    case 15 : // AUTOLAYOUT_2OBJTEXT
-                    {
-                        Rectangle aLeftTop(pInfo->GetPresRectangle());
-                        aLeftTop.setWidth(long(aLeftTop.GetWidth() * 0.488));
-                        Rectangle aRight(aLeftTop);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-                        aLeftTop.setHeight(long(aLeftTop.GetHeight() * 0.477));
-                        Rectangle aLeftBottom(aLeftTop);
-                        aLeftBottom.Top() = long(aLeftBottom.Top() + aLeftBottom.GetHeight() * 1.095);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aLeftTop);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aLeftBottom);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aRight);
-                        break;
-                    }
-                    case 16 : // AUTOLAYOUT_2OBJOVERTEXT
-                    {
-                        Rectangle aTopLeft(pInfo->GetPresRectangle());
-                        aTopLeft.setHeight(long(aTopLeft.GetHeight() * 0.477));
-                        Rectangle aBottom(aTopLeft);
-                        aBottom.Top() = long(aBottom.Top() + aBottom.GetHeight() * 1.095);
-                        aTopLeft.setWidth(long(aTopLeft.GetWidth() * 0.488));
-                        Rectangle aTopRight(aTopLeft);
-                        aTopRight.Left() = long(aTopRight.Left() + aTopRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aTopLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aTopRight);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aBottom);
-                        break;
-                    }
-                    case 17 : // AUTOLAYOUT_TEXTOVEROBJ
-                    {
-                        Rectangle aTop(pInfo->GetPresRectangle());
-                        aTop.setHeight(long(aTop.GetHeight() * 0.477));
-                        Rectangle aBottom(aTop);
-                        aBottom.Top() = long(aBottom.Top() + aBottom.GetHeight() * 1.095);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderOutline, aTop);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aBottom);
-                        break;
-                    }
-                    case 18 : // AUTOLAYOUT_4OBJ
-                    {
-                        Rectangle aTopLeft(pInfo->GetPresRectangle());
-                        aTopLeft.setHeight(long(aTopLeft.GetHeight() * 0.477));
-                        aTopLeft.setWidth(long(aTopLeft.GetWidth() * 0.488));
-                        Rectangle aBottomLeft(aTopLeft);
-                        aBottomLeft.Top() = long(aBottomLeft.Top() + aBottomLeft.GetHeight() * 1.095);
-                        Rectangle aTopRight(aTopLeft);
-                        aTopRight.Left() = long(aTopRight.Left() + aTopRight.GetWidth() * 1.05);
-                        Rectangle aBottomRight(aTopRight);
-                        aBottomRight.Top() = long(aBottomRight.Top() + aBottomRight.GetHeight() * 1.095);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aTopLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aTopRight);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aBottomLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderObject, aBottomRight);
-                        break;
-                    }
-                    case 19 : // AUTOLAYOUT_ONLY_TITLE
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        break;
-                    }
-                    case 21 : // AUTOLAYOUT_NOTES
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderPage, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderNotes, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 22 : // AUTOLAYOUT_HANDOUT1
-                    case 23 : // AUTOLAYOUT_HANDOUT2
-                    case 24 : // AUTOLAYOUT_HANDOUT3
-                    case 25 : // AUTOLAYOUT_HANDOUT4
-                    case 26 : // AUTOLAYOUT_HANDOUT6
-                    case 31 : // AUTOLAYOUT_HANDOUT9
-                    {
-                        sal_Int32 nColCnt, nRowCnt;
-                        sal_Int32 nGapX = pInfo->GetGapX();
-                        sal_Int32 nGapY = pInfo->GetGapY();
-
-                        switch(pInfo->GetLayoutType())
-                        {
-                            case 22 : nColCnt = 1; nRowCnt = 1; break;
-                            case 23 : nColCnt = 1; nRowCnt = 2; break;
-                            case 24 : nColCnt = 1; nRowCnt = 3; break;
-                            case 25 : nColCnt = 2; nRowCnt = 2; break;
-                            case 26 : nColCnt = 3; nRowCnt = 2; break;
-                            case 31 : nColCnt = 3; nRowCnt = 3; break;
-                            default:  nColCnt = 0; nRowCnt = 0; break;  // FIXME - What is correct values?
-                        }
-
-                        Size aPartSize(pInfo->GetTitleRectangle().GetSize());
-                        Point aPartPos(pInfo->GetTitleRectangle().TopLeft());
-
-                        if(aPartSize.Width() > aPartSize.Height())
-                        {
-                            sal_Int32 nZwi(nColCnt);
-                            nColCnt = nRowCnt;
-                            nRowCnt = nZwi;
-                        }
-
-                        aPartSize.Width() = (aPartSize.Width() - ((nColCnt - 1) * nGapX)) / nColCnt;
-                        aPartSize.Height() = (aPartSize.Height() - ((nRowCnt - 1) * nGapY)) / nRowCnt;
-
-                        Point aTmpPos(aPartPos);
-
-                        for(sal_Int32 a = 0L; a < nRowCnt; a++)
-                        {
-                            aTmpPos.X() = aPartPos.X();
-
-                            for(sal_Int32 b = 0L; b < nColCnt; b++)
-                            {
-                                Rectangle aTmpRect(aTmpPos, aPartSize);
-
-                                ImpWriteAutoLayoutPlaceholder(XmlPlaceholderHandout, aTmpRect);
-                                aTmpPos.X() += aPartSize.Width() + nGapX;
-                            }
-
-                            aTmpPos.Y() += aPartSize.Height() + nGapY;
-                        }
-                        break;
-                    }
-                    case 27 : // AUTOLAYOUT_VERTICAL_TITLE_TEXT_CHART
-                    {
-                        Rectangle aTop(pInfo->GetPresRectangle());
-                        aTop.setHeight(long(aTop.GetHeight() * 0.488));
-                        Rectangle aBottom(aTop);
-                        aBottom.Top() = long(aBottom.Top() + aBottom.GetHeight() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalOutline, aTop);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderChart, aBottom);
-                        break;
-                    }
-                    case 28 : // AUTOLAYOUT_VERTICAL_TITLE_VERTICAL_OUTLINE
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalOutline, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 29 : // AUTOLAYOUT_TITLE_VERTICAL_OUTLINE
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalOutline, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    case 30 : // AUTOLAYOUT_TITLE_VERTICAL_OUTLINE_CLIPART
-                    {
-                        Rectangle aLeft(pInfo->GetPresRectangle());
-                        aLeft.setWidth(long(aLeft.GetWidth() * 0.488));
-                        Rectangle aRight(aLeft);
-                        aRight.Left() = long(aRight.Left() + aRight.GetWidth() * 1.05);
-
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderTitle, pInfo->GetTitleRectangle());
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderGraphic, aLeft);
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderVerticalOutline, aRight);
-                        break;
-                    }
-                    case 32 : // AUTOLAYOUT_TITLE
-                    {
-                        ImpWriteAutoLayoutPlaceholder(XmlPlaceholderSubtitle, pInfo->GetPresRectangle());
-                        break;
-                    }
-                    default:
-                    {
-                        DBG_ERROR("XMLEXP: unknown autolayout export");
-                        break;
-                    }
-                }
-            }
-        }
-    }
+                    case UnoPresKind_NONE: 
+                    case UnoPresKind_ORGCHART:
+                    case UnoPresKind_BACKGROUND:
+                    case UnoPresKind_FOOTER:
+                    case UnoPresKind_HEADER:
+                    case UnoPresKind_DATETIME:
+                    case UnoPresKind_SLIDENUMBER:
+                    default:  break; /* do nothing */
+                    
+                } // switch (kinds[i]...
+    
+		     } // for each elem..
+	      } //if pInfo
+      } // for each layout...
+   }  // if (mpAutoLayoutInfo...
 }
 
 //////////////////////////////////////////////////////////////////////////////
