From 6c0a25baaf1c73a9aeded23c7276a750976c7c76 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 17:07:55 +0200
Subject: [PATCH 692/768] calc-perf-print-calc-pages.diff

---
 sc/inc/dociter.hxx               |   17 +++++++++++++++++
 sc/inc/document.hxx              |    3 +++
 sc/source/core/data/dociter.cxx  |   23 +++++++++++++++++++++++
 sc/source/core/data/document.cxx |    7 +++++++
 sc/source/ui/view/printfun.cxx   |   35 ++++++++++++++++++++++++++++++-----
 5 files changed, 80 insertions(+), 5 deletions(-)

diff --git sc/inc/dociter.hxx sc/inc/dociter.hxx
index ce1ee02..a5d66fd 100644
--- sc/inc/dociter.hxx
+++ sc/inc/dociter.hxx
@@ -36,6 +36,7 @@
 
 #include <memory>
 #include <vector>
+#include <set>
 #include <boost/shared_ptr.hpp>
 
 class ScDocument;
@@ -552,6 +553,22 @@ private:
     const ::std::vector<TabRanges>* mpTabRangesArray;
 };
 
+// ============================================================================
+
+class ScRowBreakIterator
+{
+public:
+    static SCROW NOT_FOUND;
+
+    explicit ScRowBreakIterator(::std::set<SCROW>& rBreaks);
+    SCROW first();
+    SCROW next();
+
+private:
+    ::std::set<SCROW>& mrBreaks;
+    ::std::set<SCROW>::const_iterator maItr;
+    ::std::set<SCROW>::const_iterator maEnd;
+};
 
 #endif
 
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 185c2b7..6f0bef1 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -149,6 +149,7 @@ struct ScClipRangeNameData;
 struct ScSetStringParam;
 class ScDocRowHeightUpdater;
 struct ScColWidthParam;
+class ScRowBreakIterator;
 
 namespace com { namespace sun { namespace star {
     namespace lang {
@@ -1816,6 +1817,8 @@ public:
     void RemoveSubTotalCell(ScFormulaCell* pCell);
     void SetSubTotalCellsDirty(const ScRange& rDirtyRange);
 
+    ScRowBreakIterator* GetRowBreakIterator(SCTAB nTab) const;
+
 private: // CLOOK-Impl-Methoden
 
     /** 
diff --git sc/source/core/data/dociter.cxx sc/source/core/data/dociter.cxx
index 5bca66e..9e6c8d1 100644
--- sc/source/core/data/dociter.cxx
+++ sc/source/core/data/dociter.cxx
@@ -52,6 +52,7 @@
 
 using ::rtl::math::approxEqual;
 using ::std::vector;
+using ::std::set;
 using ::rtl::OUString;
 
 // STATIC DATA -----------------------------------------------------------
@@ -2244,3 +2245,25 @@ void ScDocRowHeightUpdater::updateAll()
         nProgressStart += mrDoc.pTab[nTab]->GetWeightedCount();
     }
 }
+
+// ============================================================================
+
+SCROW ScRowBreakIterator::NOT_FOUND = -1;
+
+ScRowBreakIterator::ScRowBreakIterator(set<SCROW>& rBreaks) :
+    mrBreaks(rBreaks),
+    maItr(rBreaks.begin()), maEnd(rBreaks.end())
+{
+}
+
+SCROW ScRowBreakIterator::first()
+{
+    maItr = mrBreaks.begin();
+    return maItr == maEnd ? NOT_FOUND : *maItr;
+}
+
+SCROW ScRowBreakIterator::next()
+{
+    ++maItr;
+    return maItr == maEnd ? NOT_FOUND : *maItr;
+}
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 332d25c..429f9ca 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -5300,6 +5300,13 @@ void ScDocument::SetSubTotalCellsDirty(const ScRange& rDirtyRange)
     maSubTotalCells.swap(aNewSet); // update the list.
 }
 
+ScRowBreakIterator* ScDocument::GetRowBreakIterator(SCTAB nTab) const
+{
+    if (ValidTab(nTab) && pTab[nTab])
+        return new ScRowBreakIterator(pTab[nTab]->maRowPageBreaks);
+    return NULL;
+}
+
 void ScDocument::EnableUndo( bool bVal )
 {
     GetUndoManager()->EnableUndo(bVal);
diff --git sc/source/ui/view/printfun.cxx sc/source/ui/view/printfun.cxx
index cd26e9e..f51bc6b 100644
--- sc/source/ui/view/printfun.cxx
+++ sc/source/ui/view/printfun.cxx
@@ -85,6 +85,8 @@
 #include <vcl/lineinfo.hxx>
 #include <tools/pstm.hxx>
 
+#include <boost/scoped_ptr.hpp>
+
 #define ZOOM_MIN	10
 
 #define GET_BOOL(set,which)   ((const SfxBoolItem&)(set)->Get((which))).GetValue()
@@ -3104,11 +3106,22 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
         ++nPagesX;
     }
 
-    BOOL bVisRow = FALSE;
+    bool bVisRow = false;
     SCROW nPageStartRow = nStartRow;
+    SCROW nLastVisibleRow = -1;
+
+    ::boost::scoped_ptr<ScRowBreakIterator> pRowBreakIter(pDoc->GetRowBreakIterator(nPrintTab));
+    SCROW nNextPageBreak = pRowBreakIter->first();
+    while (nNextPageBreak != ScRowBreakIterator::NOT_FOUND && nNextPageBreak < nStartRow)
+        // Skip until the page break position is at the start row or greater.
+        nNextPageBreak = pRowBreakIter->next();
+
     for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
     {
-        bool bPageBreak = (pDoc->HasRowBreak(nRow, nPrintTab) & BREAK_PAGE);
+        bool bPageBreak = (nNextPageBreak == nRow);
+        if (bPageBreak)
+            nNextPageBreak = pRowBreakIter->next();
+
         if (nRow > nStartRow && bVisRow && bPageBreak )
         {
             pPageEndY[nTotalY] = nRow-1;
@@ -3126,11 +3139,23 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
             }
 
             nPageStartRow = nRow;
-            bVisRow = FALSE;
+            bVisRow = false;
+        }
+
+        if (nRow <= nLastVisibleRow)
+        {
+            // This row is still visible.  Don't bother calling RowHidden() to
+            // find out, for speed optimization.
+            bVisRow = true;
+            continue;
         }
+
         SCROW nLastRow = -1;
-        if (!pDoc->RowHidden(nRow, nPrintTab, nLastRow))
-            bVisRow = TRUE;
+        if (!pDoc->RowHidden(nRow, nPrintTab, NULL, &nLastRow))
+        {
+            bVisRow = true;
+            nLastVisibleRow = nLastRow;
+        }
         else
             // skip all hidden rows.
             nRow = nLastRow;
-- 
1.7.0.1

