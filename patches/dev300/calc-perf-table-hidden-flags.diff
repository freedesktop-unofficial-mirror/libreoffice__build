diff --git sc/inc/column.hxx sc/inc/column.hxx
index 3aa524f..1d7cd5f 100644
--- sc/inc/column.hxx
+++ sc/inc/column.hxx
@@ -213,10 +213,10 @@ public:
                 //	UpdateSelectionFunction: Mehrfachselektion
     void		UpdateSelectionFunction( const ScMarkData& rMark,
                                     ScFunctionData& rData,
-                                    const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+                                    ScFlatBoolRowSegments& rHiddenRows,
                                     BOOL bDoExclude, SCROW nExStartRow, SCROW nExEndRow );
     void		UpdateAreaFunction( ScFunctionData& rData,
-                                    const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+                                    ScFlatBoolRowSegments& rHiddenRows,
                                     SCROW nStartRow, SCROW nEndRow );
 
     void		CopyToColumn(SCROW nRow1, SCROW nRow2, USHORT nFlags, BOOL bMarked,
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 6fef3aa..9ef314f 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -420,16 +420,11 @@ private:
 
     sal_Int16           mnNamedRangesLockCount;
 
-    inline BOOL 		RowHidden( SCROW nRow, SCTAB nTab );		// FillInfo
-
 public:
     SC_DLLPUBLIC ULONG			GetCellCount() const;		// alle Zellen
     ULONG			GetWeightedCount() const;	// Formeln und Edit staerker gewichtet
     ULONG			GetCodeCount() const;		// RPN-Code in Formeln
     DECL_LINK( GetUserDefinedColor, USHORT * );
-    BOOL        RowFiltered( SCROW nRow, SCTAB nTab ) const;    // FillInfo
-    BOOL        ColFiltered( SCCOL nCol, SCTAB nTab ) const;    // FillInfo
-                                                                // Numberformatter
 
 public:
     SC_DLLPUBLIC 				ScDocument( ScDocumentMode eMode = SCDOCMODE_DOCUMENT,
@@ -1247,7 +1242,6 @@ public:
                         SCTAB nTab, double fScale ) const;
     SC_DLLPUBLIC inline USHORT	FastGetRowHeight( SCROW nRow, SCTAB nTab ) const;
     inline SCROW	FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const;
-    inline SCROW    FastGetFirstNonHiddenRow( SCROW nStartRow, SCTAB nTab ) const;
                     /** No check for flags whether row is hidden, height value
                         is returned unconditionally. */
     inline USHORT   FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const;
@@ -1299,6 +1293,26 @@ public:
     ::com::sun::star::uno::Sequence<
         ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData(SCTAB nTab) const;
 
+    SC_DLLPUBLIC bool           RowHidden(SCROW nRow, SCTAB nTab, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    SC_DLLPUBLIC bool           RowHidden(SCROW nRow, SCTAB nTab, SCROW& rLastRow);
+    SC_DLLPUBLIC bool           HasHiddenRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SC_DLLPUBLIC bool           ColHidden(SCCOL nCol, SCTAB nTab, SCCOL& rLastCol);
+    SC_DLLPUBLIC bool           ColHidden(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    SC_DLLPUBLIC void           SetRowHidden(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bHidden);
+    SC_DLLPUBLIC void           SetColHidden(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bHidden);
+    SC_DLLPUBLIC SCROW          FirstVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SC_DLLPUBLIC SCROW          LastVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SCROW                       CountVisibleRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+
+    bool                        RowFiltered(SCROW nRow, SCTAB nTab, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    bool                        HasFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    bool                        ColFiltered(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    SC_DLLPUBLIC void           SetRowFiltered(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bFiltered);
+    SC_DLLPUBLIC void           SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bFiltered);
+    SCROW                       FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SCROW                       LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SCROW                       CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+
     /** 
      * Write all column row flags to table's flag data, because not all column 
      * row attributes are stored in the flag data members.  This is necessary 
@@ -1327,8 +1341,6 @@ public:
     BOOL			GetColDefault( SCTAB nTab, SCCOL nCol, SCROW nLastRow, SCROW& nDefault);
     BOOL			GetRowDefault( SCTAB nTab, SCROW nRow, SCCOL nLastCol, SCCOL& nDefault);
 
-    BOOL			IsFiltered( SCROW nRow, SCTAB nTab ) const;
-
     BOOL			UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, BOOL bShow );
     BOOL			UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, SCTAB nTab, BOOL bShow );
 
@@ -1807,58 +1819,24 @@ inline void ScDocument::SetSortParam( ScSortParam& rParam, SCTAB nTab )
 inline ULONG ScDocument::FastGetScaledRowHeight( SCROW nStartRow, SCROW nEndRow,
         SCTAB nTab, double fScale ) const
 {
-    return pTab[nTab]->pRowFlags->SumScaledCoupledArrayForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0, *(pTab[nTab]->pRowHeight), fScale);
+    ULONG nHeight = FastGetRowHeight(nStartRow, nEndRow, nTab);
+    return nHeight * fScale;
 }
 
 inline USHORT ScDocument::FastGetRowHeight( SCROW nRow, SCTAB nTab ) const
 {
-    return ( pTab[nTab]->pRowFlags->GetValue(nRow) & CR_HIDDEN ) ? 0 :
-        pTab[nTab]->pRowHeight->GetValue(nRow);
+    return pTab[nTab]->GetRowHeight(nRow);
 }
 
 inline SCROW ScDocument::FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const
 {
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            *(pTab[nTab]->pRowFlags), 0, MAXROW, CR_HIDDEN, 0,
-            *(pTab[nTab]->pRowHeight));
-    ULONG nSum = 0;
-    for ( ; aIter; aIter.NextRange() )
-    {
-        ULONG nNew = *aIter * (aIter.GetRangeEnd() - aIter.GetRangeStart() + 1);
-        if (nSum + nNew > nHeight)
-        {
-            for ( ; aIter && nSum <= nHeight; ++aIter )
-            {
-                nSum += *aIter;
-            }
-            return aIter.GetPos();
-        }
-        nSum += nNew;
-    }
-    return aIter.GetPos();
-}
-
-inline SCROW ScDocument::FastGetFirstNonHiddenRow( SCROW nStartRow, SCTAB nTab) const
-{
-    return pTab[nTab]->pRowFlags->GetFirstForCondition( nStartRow, MAXROW,
-            CR_HIDDEN, 0);
+    return pTab[nTab]->GetRowForHeight(nHeight);
 }
 
 inline USHORT ScDocument::FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const
 {
     return pTab[nTab]->pRowHeight->GetValue(nRow);
 }
-
-inline BOOL ScDocument::ColFiltered( SCCOL nCol, SCTAB nTab ) const
-{
-    return ( pTab[nTab]->pColFlags[nCol] & CR_FILTERED) != 0;
-}
-
-inline BOOL ScDocument::RowFiltered( SCROW nRow, SCTAB nTab ) const
-{
-    return pTab[nTab]->IsFiltered(nRow);
-}
  
 #endif
 
diff --git sc/inc/olinetab.hxx sc/inc/olinetab.hxx
index 456d223..a71519b 100644
--- sc/inc/olinetab.hxx
+++ sc/inc/olinetab.hxx
@@ -39,6 +39,7 @@
 #define SC_OL_MAXDEPTH		7
 
 class SvStream;
+class ScTable;
 
 
 class ScOutlineEntry : public ScDataObject
@@ -126,9 +127,7 @@ public:
     void					InsertSpace( SCCOLROW nStartPos, SCSIZE nSize );
     BOOL					DeleteSpace( SCCOLROW nStartPos, SCSIZE nSize );
 
-    BOOL					ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos,
-                                BOOL bShow,
-                                const ScBitMaskCompressedArray< SCCOLROW, BYTE>& rHiddenFlags );
+    bool                    ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos, bool bShow, ScTable& rTable, bool bCol );
 
     void					RemoveAll();
 };
diff --git sc/inc/table.hxx sc/inc/table.hxx
index 6045438..0ace618 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -43,6 +43,7 @@
 
 #include <memory>
 #include <set>
+#include <boost/shared_ptr.hpp>
 
 namespace utl {
     class SearchParam;
@@ -83,6 +84,8 @@ struct RowInfo;
 struct ScFunctionData;
 struct ScLineFlags;
 class CollatorWrapper;
+class ScFlatBoolRowSegments;
+class ScFlatBoolColSegments;
 
 
 class ScTable
@@ -125,6 +128,10 @@ private:
 
     BYTE*			pColFlags;
     ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
+    ::boost::shared_ptr<ScFlatBoolColSegments>  mpHiddenCols;
+    ::boost::shared_ptr<ScFlatBoolRowSegments>  mpHiddenRows;
+    ::boost::shared_ptr<ScFlatBoolColSegments>  mpFilteredCols;
+    ::boost::shared_ptr<ScFlatBoolRowSegments>  mpFilteredRows;
 
     ::std::set<SCROW>                      maRowPageBreaks;
     ::std::set<SCROW>                      maRowManualBreaks;
@@ -471,7 +478,7 @@ public:
                                 SCCOL& rCol, SCROW& rRow, ScMarkData& rMark,
                                 String& rUndoStr, ScDocument* pUndoDoc);
 
-    void		FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 ) const;
+	void		FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 );
 
     void		GetBorderLines( SCCOL nCol, SCROW nRow,
                                 const SvxBorderLine** ppLeft, const SvxBorderLine** ppTop,
@@ -593,19 +600,29 @@ public:
                         // nPPT fuer Test auf Veraenderung
     void		SetManualHeight( SCROW nStartRow, SCROW nEndRow, BOOL bManual );
 
-    USHORT		GetColWidth( SCCOL nCol ) const;
-    USHORT		GetRowHeight( SCROW nRow ) const;
-    ULONG		GetRowHeight( SCROW nStartRow, SCROW nEndRow ) const;
-    ULONG		GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale ) const;
-    ULONG		GetColOffset( SCCOL nCol ) const;
-    ULONG		GetRowOffset( SCROW nRow ) const;
+	USHORT		GetColWidth( SCCOL nCol );
+    SC_DLLPUBLIC USHORT GetRowHeight( SCROW nRow );
+	ULONG		GetRowHeight( SCROW nStartRow, SCROW nEndRow );
+	ULONG		GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale );
+	ULONG		GetColOffset( SCCOL nCol );
+	ULONG		GetRowOffset( SCROW nRow );
+
+    /** 
+     * Get the last row such that the height of row 0 to the end row is as 
+     * high as possible without exceeding the specified height value.
+     *
+     * @param nHeight maximum desired height
+     * 
+     * @return SCROW last row of the range within specified height.
+     */
+    SCROW       GetRowForHeight(ULONG nHeight);
 
     USHORT		GetOriginalWidth( SCCOL nCol ) const;
     USHORT		GetOriginalHeight( SCROW nRow ) const;
 
-    USHORT		GetCommonWidth( SCCOL nEndCol ) const;
+	USHORT		GetCommonWidth( SCCOL nEndCol );
 
-    SCROW		GetHiddenRowCount( SCROW nRow ) const;
+	SCROW		GetHiddenRowCount( SCROW nRow );
 
     void		ShowCol(SCCOL nCol, BOOL bShow);
     void		ShowRow(SCROW nRow, BOOL bShow);
@@ -626,8 +643,6 @@ public:
                 /// @return  the index of the last changed row (flags and row height, auto pagebreak is ignored).
     SCROW      GetLastChangedRow() const;
 
-    BOOL		IsFiltered(SCROW nRow) const;
-
     BYTE		GetColFlags( SCCOL nCol ) const;
     BYTE		GetRowFlags( SCROW nRow ) const;
 
@@ -656,6 +671,34 @@ public:
     void        SetColBreak(SCCOL nCol, bool bPage, bool bManual);
     ::com::sun::star::uno::Sequence<
         ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData() const;
+
+    bool        RowHidden(SCROW nRow, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    bool        RowHidden(SCROW nRow, SCROW& rLastRow);
+    bool        HasHiddenRows(SCROW nStartRow, SCROW nEndRow);
+    bool        ColHidden(SCCOL nCol, SCCOL& rLastCol);
+    bool        ColHidden(SCCOL nCol, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    void        SetRowHidden(SCROW nStartRow, SCROW nEndRow, bool bHidden);
+    void        SetColHidden(SCCOL nStartCol, SCCOL nEndCol, bool bHidden);
+    void        CopyColHidden(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol);
+    void        CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow);
+    SCROW       FirstVisibleRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       LastVisibleRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       CountVisibleRows(SCROW nStartRow, SCROW nEndRow);
+    sal_uInt32  GetTotalRowHeight(SCROW nStartRow, SCROW nEndRow);
+
+    SCCOLROW    LastHiddenColRow(SCCOLROW nPos, bool bCol);
+
+    bool        RowFiltered(SCROW nRow, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    bool        ColFiltered(SCCOL nCol, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    bool        HasFilteredRows(SCROW nStartRow, SCROW nEndRow);
+    void        CopyColFiltered(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol);
+    void        CopyRowFiltered(ScTable& rTable, SCROW nStartRow, SCROW nEndRow);
+    void        SetRowFiltered(SCROW nStartRow, SCROW nEndRow, bool bFiltered);
+    void        SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, bool bFiltered);
+    SCROW       FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow);
+
     void        SyncColRowFlags();
 
     void		StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
@@ -786,7 +829,7 @@ private:
 
     SCSIZE		FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2,
                             SCCOL nCol, SCROW nAttrRow1, SCROW nAttrRow2, SCSIZE nArrY,
-                            const ScPatternAttr* pPattern, const SfxItemSet* pCondSet ) const;
+							const ScPatternAttr* pPattern, const SfxItemSet* pCondSet );
 
     // idle calculation of OutputDevice text width for cell
     // also invalidates script type, broadcasts for "calc as shown"
diff --git sc/source/core/data/column2.cxx sc/source/core/data/column2.cxx
index 2291859..c97fbda 100644
--- sc/source/core/data/column2.cxx
+++ sc/source/core/data/column2.cxx
@@ -69,6 +69,7 @@
 #include "compiler.hxx"			// ScTokenArray GetCodeLen
 #include "dbcolect.hxx"
 #include "fillinfo.hxx"
+#include "segmenttree.hxx"
 
 #include <math.h>
 
@@ -1785,7 +1786,7 @@ void lcl_UpdateSubTotal( ScFunctionData& rData, ScBaseCell* pCell )
 //	Mehrfachselektion:
 void ScColumn::UpdateSelectionFunction( const ScMarkData& rMark,
                                         ScFunctionData& rData,
-                                        const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+										ScFlatBoolRowSegments& rHiddenRows,
                                         BOOL bDoExclude, SCROW nExStartRow, SCROW nExEndRow )
 {
     SCSIZE nIndex;
@@ -1793,7 +1794,8 @@ void ScColumn::UpdateSelectionFunction( const ScMarkData& rMark,
     while (aDataIter.Next( nIndex ))
     {
         SCROW nRow = pItems[nIndex].nRow;
-        if ( !pRowFlags || !( pRowFlags->GetValue(nRow) & CR_HIDDEN ) )
+		bool bRowHidden = rHiddenRows.getValue(nRow);
+		if ( !bRowHidden )
             if ( !bDoExclude || nRow < nExStartRow || nRow > nExEndRow )
                 lcl_UpdateSubTotal( rData, pItems[nIndex].pCell );
     }
@@ -1801,7 +1803,7 @@ void ScColumn::UpdateSelectionFunction( const ScMarkData& rMark,
 
 //	bei bNoMarked die Mehrfachselektion weglassen
 void ScColumn::UpdateAreaFunction( ScFunctionData& rData,
-                                    const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+								   ScFlatBoolRowSegments& rHiddenRows,
                                     SCROW nStartRow, SCROW nEndRow )
 {
     SCSIZE nIndex;
@@ -1809,7 +1811,8 @@ void ScColumn::UpdateAreaFunction( ScFunctionData& rData,
     while ( nIndex<nCount && pItems[nIndex].nRow<=nEndRow )
     {
         SCROW nRow = pItems[nIndex].nRow;
-        if ( !pRowFlags || !( pRowFlags->GetValue(nRow) & CR_HIDDEN ) )
+		bool bRowHidden = rHiddenRows.getValue(nRow);
+		if ( !bRowHidden )
             lcl_UpdateSubTotal( rData, pItems[nIndex].pCell );
         ++nIndex;
     }
diff --git sc/source/core/data/dociter.cxx sc/source/core/data/dociter.cxx
index 911d473..055c64f 100644
--- sc/source/core/data/dociter.cxx
+++ sc/source/core/data/dociter.cxx
@@ -334,7 +334,7 @@ BOOL ScValueIterator::GetThis(double& rValue, USHORT& rErr)
         if ( nColRow < pCol->nCount && pCol->pItems[nColRow].nRow <= nEndRow )
         {
             nRow = pCol->pItems[nColRow].nRow + 1;
-            if ( !bSubTotal || !pDoc->pTab[nTab]->IsFiltered( nRow-1 ) )
+			if ( !bSubTotal || !pDoc->pTab[nTab]->RowFiltered( nRow-1 ) )
             {
                 ScBaseCell* pCell = pCol->pItems[nColRow].pCell;
                 ++nColRow;
@@ -725,7 +725,7 @@ ScBaseCell* ScCellIterator::GetThis()
         if ( nColRow < pCol->nCount	&& pCol->pItems[nColRow].nRow <= nEndRow )
         {
             nRow = pCol->pItems[nColRow].nRow;
-            if ( !bSubTotal || !pDoc->pTab[nTab]->IsFiltered( nRow ) )
+			if ( !bSubTotal || !pDoc->pTab[nTab]->RowFiltered( nRow ) )
             {
                 ScBaseCell* pCell = pCol->pItems[nColRow].pCell;
 
diff --git sc/source/core/data/documen3.cxx sc/source/core/data/documen3.cxx
index 17ae763..4cff6f3 100644
--- sc/source/core/data/documen3.cxx
+++ sc/source/core/data/documen3.cxx
@@ -1123,15 +1123,6 @@ BOOL ScDocument::SearchAndReplace(const SvxSearchItem& rSearchItem,
     return bFound;
 }
 
-BOOL ScDocument::IsFiltered( SCROW nRow, SCTAB nTab ) const
-{
-    if (VALIDTAB(nTab))
-        if (pTab[nTab])
-            return pTab[nTab]->IsFiltered( nRow );
-    DBG_ERROR("Falsche Tabellennummer");
-    return 0;
-}
-
 //	Outline anpassen
 
 BOOL ScDocument::UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, BOOL bShow )
@@ -1558,46 +1549,43 @@ ScRange ScDocument::GetRange( SCTAB nTab, const Rectangle& rMMRect )
     nTwips = (long) (aPosRect.Top() / HMM_PER_TWIPS);
 
     SCROW nY1 = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            *(pTable->GetRowFlagsArray()), nY1, MAXROW, CR_HIDDEN, 0,
-            *(pTable->GetRowHeightArray()));
     bEnd = FALSE;
-    while (!bEnd && aIter)
+    for (SCROW i = nY1; i <= MAXROW && !bEnd; ++i)
     {
-        nY1 = aIter.GetPos();
-        nAdd = (long) *aIter;
+        if (pTable->RowHidden(i))
+            continue;
+
+        nY1 = i;
+        nAdd = static_cast<long>(pTable->GetRowHeight(i));
         if (nSize+nAdd <= nTwips+1 && nY1<MAXROW)
         {
             nSize += nAdd;
             ++nY1;
-            ++aIter;
         }
         else
             bEnd = TRUE;
     }
-    if (!aIter)
-        nY1 = aIter.GetIterEnd();   // all hidden down to the bottom
+    if (!bEnd)
+        nY1 = MAXROW;   // all hidden down to the bottom
 
     nTwips = (long) (aPosRect.Bottom() / HMM_PER_TWIPS);
 
     SCROW nY2 = nY1;
-    aIter.NewLimits( nY2, MAXROW);
     bEnd = FALSE;
-    while (!bEnd && aIter)
+    for (SCROW i = nY2; i <= MAXROW && !bEnd; ++i)
     {
-        nY2 = aIter.GetPos();
-        nAdd = (long) *aIter;
+        nY2 = i;
+        nAdd = static_cast<long>(pTable->GetRowHeight(i));
         if (nSize+nAdd < nTwips && nY2<MAXROW)
         {
             nSize += nAdd;
             ++nY2;
-            ++aIter;
         }
         else
             bEnd = TRUE;
     }
-    if (!aIter)
-        nY2 = aIter.GetIterEnd();   // all hidden down to the bottom
+    if (!bEnd)
+        nY2 = MAXROW;   // all hidden down to the bottom
 
     return ScRange( nX1,nY1,nTab, nX2,nY2,nTab );
 }
@@ -1635,24 +1623,33 @@ void lcl_SnapVer( ScTable* pTable, long& rVal, SCROW& rStartRow )
     SCROW nRow = 0;
     long nTwips = (long) (rVal / HMM_PER_TWIPS);
     long nSnap = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            *(pTable->GetRowFlagsArray()), nRow, MAXROW, CR_HIDDEN, 0,
-            *(pTable->GetRowHeightArray()));
-    while ( aIter )
+
+    bool bFound = false;
+    for (SCROW i = nRow; i <= MAXROW; ++i)
     {
-        nRow = aIter.GetPos();
-        long nAdd = *aIter;
+        SCROW nLastRow;
+        if (pTable->RowHidden(i, NULL, &nLastRow))
+        {
+            i = nLastRow;    
+            continue;
+        }
+
+        nRow = i;
+		long nAdd = pTable->GetRowHeight(i);
         if ( nSnap + nAdd/2 < nTwips || nRow < rStartRow )
         {
             nSnap += nAdd;
             ++nRow;
-            ++aIter;
         }
         else
+        {
+            bFound = true;    
             break;
+        }
     }
-    if (!aIter)
+    if (!bFound)
         nRow = MAXROW;  // all hidden down to the bottom
+
     rVal = (long) ( nSnap * HMM_PER_TWIPS );
     rStartRow = nRow;
 }
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 8151aec..9374c35 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -97,6 +97,7 @@
 #include "clipparam.hxx"
 
 #include <map>
+#include <limits>
 
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
 using ::com::sun::star::uno::Sequence;
@@ -1951,9 +1952,6 @@ void ScDocument::CopyNonFilteredFromClip( SCCOL nCol1, SCROW nRow1,
     while ( nFlagTab < MAXTAB && !ppClipTab[nFlagTab] )
         ++nFlagTab;
 
-    const ScBitMaskCompressedArray< SCROW, BYTE> & rSourceFlags =
-        pCBFCP->pClipDoc->GetRowFlagsArray( nFlagTab);
-
     SCROW nSourceRow = rClipStartRow;
 	SCROW nSourceEnd = 0;
     if (pCBFCP->pClipDoc->GetClipParam().maRanges.Count())
@@ -1963,12 +1961,15 @@ void ScDocument::CopyNonFilteredFromClip( SCCOL nCol1, SCROW nRow1,
     while ( nSourceRow <= nSourceEnd && nDestRow <= nRow2 )
     {
         // skip filtered rows
-        nSourceRow = rSourceFlags.GetFirstForCondition( nSourceRow, nSourceEnd, CR_FILTERED, 0);
+        nSourceRow = pCBFCP->pClipDoc->FirstNonFilteredRow(nSourceRow, nSourceEnd, nFlagTab);
 
         if ( nSourceRow <= nSourceEnd )
         {
             // look for more non-filtered rows following
-            SCROW nFollow = rSourceFlags.GetBitStateEnd( nSourceRow, CR_FILTERED, 0) - nSourceRow;
+            SCROW nLastRow = nSourceRow;
+            pCBFCP->pClipDoc->RowFiltered(nSourceRow, nFlagTab, NULL, &nLastRow);
+            SCROW nFollow = nLastRow - nSourceRow;
+
             if (nFollow > nSourceEnd - nSourceRow)
                 nFollow = nSourceEnd - nSourceRow;
             if (nFollow > nRow2 - nDestRow)
@@ -2376,8 +2377,7 @@ void ScDocument::GetClipArea(SCCOL& nClipX, SCROW& nClipY, BOOL bIncludeFiltered
         while ( nCountTab < MAXTAB && !pTab[nCountTab] )
             ++nCountTab;
 
-        SCROW nResult = GetRowFlagsArray( nCountTab).CountForCondition(
-                nStartRow, nEndRow, CR_FILTERED, 0);
+        SCROW nResult = CountNonFilteredRows(nStartRow, nEndRow, nCountTab);
 
         if ( nResult > 0 )
             nClipY = nResult - 1;
@@ -2416,8 +2416,13 @@ BOOL ScDocument::HasClipFilteredRows()
     if (!rClipRanges.Count())
         return false;
 
-    return GetRowFlagsArray( nCountTab).HasCondition( rClipRanges.First()->aStart.Row(),
-            rClipRanges.First()->aEnd.Row(), CR_FILTERED, CR_FILTERED);
+    for (ScRange* p = rClipRanges.First(); p; p = rClipRanges.Next())
+    {
+        bool bAnswer = pTab[nCountTab]->HasFilteredRows(p->aStart.Row(), p->aEnd.Row());
+        if (bAnswer)
+            return true;
+    }
+    return false;
 }
 
 
@@ -3118,8 +3123,7 @@ ULONG ScDocument::GetRowHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab ) con
 ULONG ScDocument::FastGetRowHeight( SCROW nStartRow, SCROW nEndRow,
         SCTAB nTab ) const
 {
-    return pTab[nTab]->pRowFlags->SumCoupledArrayForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0, *(pTab[nTab]->pRowHeight));
+	return GetRowHeight(nStartRow, nEndRow, nTab);
 }
 
 ULONG ScDocument::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow,
@@ -3431,6 +3435,163 @@ Sequence<TablePageBreakData> ScDocument::GetRowBreakData(SCTAB nTab) const
     return pTab[nTab]->GetRowBreakData();
 }
 
+bool ScDocument::RowHidden(SCROW nRow, SCTAB nTab, SCROW* pFirstRow, SCROW* pLastRow)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+		return false;
+
+	return pTab[nTab]->RowHidden(nRow, pFirstRow, pLastRow);
+}
+
+bool ScDocument::RowHidden(SCROW nRow, SCTAB nTab, SCROW& rLastRow)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+	{
+		rLastRow = nRow;	
+		return false;
+	}
+
+	return pTab[nTab]->RowHidden(nRow, rLastRow);
+}
+
+
+bool ScDocument::HasHiddenRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+		return false;
+
+	return pTab[nTab]->HasHiddenRows(nStartRow, nEndRow);
+}
+
+bool ScDocument::ColHidden(SCCOL nCol, SCTAB nTab, SCCOL& rLastCol)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+	{
+		rLastCol = nCol;	
+		return false;
+	}
+
+	return pTab[nTab]->ColHidden(nCol, rLastCol);
+}
+
+bool ScDocument::ColHidden(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+	{
+        if (pFirstCol)
+            *pFirstCol = nCol;
+        if (pLastCol)
+            *pLastCol = nCol;
+		return false;
+	}
+
+	return pTab[nTab]->ColHidden(nCol, pFirstCol, pLastCol);
+}
+
+void ScDocument::SetRowHidden(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bHidden)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return;
+
+	pTab[nTab]->SetRowHidden(nStartRow, nEndRow, bHidden);
+}
+
+void ScDocument::SetColHidden(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bHidden)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return;
+
+	pTab[nTab]->SetColHidden(nStartCol, nEndCol, bHidden);
+}
+
+SCROW ScDocument::FirstVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->FirstVisibleRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::LastVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->LastVisibleRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::CountVisibleRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+        return 0;
+
+    return pTab[nTab]->CountVisibleRows(nStartRow, nEndRow);
+}
+
+bool ScDocument::RowFiltered(SCROW nRow, SCTAB nTab, SCROW* pFirstRow, SCROW* pLastRow)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+		return false;
+
+	return pTab[nTab]->RowFiltered(nRow, pFirstRow, pLastRow);
+}
+
+bool ScDocument::HasFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+		return false;
+
+	return pTab[nTab]->HasFilteredRows(nStartRow, nEndRow);
+}
+
+bool ScDocument::ColFiltered(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+		return false;
+
+	return pTab[nTab]->ColFiltered(nCol, pFirstCol, pLastCol);
+}
+
+void ScDocument::SetRowFiltered(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bFiltered)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return;
+
+	pTab[nTab]->SetRowFiltered(nStartRow, nEndRow, bFiltered);
+}
+
+void ScDocument::SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bFiltered)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return;
+
+	pTab[nTab]->SetColFiltered(nStartCol, nEndCol, bFiltered);
+}
+
+SCROW ScDocument::FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->FirstNonFilteredRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+		return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->LastNonFilteredRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+	if (!ValidTab(nTab) || !pTab[nTab])
+        return 0;
+
+    return pTab[nTab]->CountNonFilteredRows(nStartRow, nEndRow);
+}
+
 void ScDocument::SyncColRowFlags()
 {
     for (SCTAB i = 0; i <= nMaxTableNumber; ++i)
diff --git sc/source/core/data/drwlayer.cxx sc/source/core/data/drwlayer.cxx
index 94708e1..03c48f5 100644
--- sc/source/core/data/drwlayer.cxx
+++ sc/source/core/data/drwlayer.cxx
@@ -610,12 +610,14 @@ void ScDrawLayer::RecalcPos( SdrObject* pObj, const ScDrawObjData& rData, bool b
     {
         //!	nicht mehrere Undos fuer ein Objekt erzeugen (hinteres kann dann weggelassen werden)
 
+        SCCOL nLastCol;
+        SCROW nLastRow;
         if( bValid1 )
         {
             Point aPos( pDoc->GetColOffset( nCol1, nTab1 ), pDoc->GetRowOffset( nRow1, nTab1 ) );
-            if( (pDoc->GetColFlags( nCol1, nTab1 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->ColHidden(nCol1, nTab1, nLastCol))
                 aPos.X() += pDoc->GetColWidth( nCol1, nTab1 ) / 4;
-            if( (pDoc->GetRowFlags( nRow1, nTab1 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->RowHidden(nRow1, nTab1, nLastRow))
                 aPos.Y() += pDoc->GetRowHeight( nRow1, nTab1 ) / 2;
             TwipsToMM( aPos.X() );
             TwipsToMM( aPos.Y() );
@@ -647,9 +649,9 @@ void ScDrawLayer::RecalcPos( SdrObject* pObj, const ScDrawObjData& rData, bool b
         if( bValid2 )
         {
             Point aPos( pDoc->GetColOffset( nCol2, nTab2 ), pDoc->GetRowOffset( nRow2, nTab2 ) );
-            if( (pDoc->GetColFlags( nCol2, nTab2 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->ColHidden(nCol2, nTab2, nLastCol))
                 aPos.X() += pDoc->GetColWidth( nCol2, nTab2 ) / 4;
-            if( (pDoc->GetRowFlags( nRow2, nTab2 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->RowHidden(nRow2, nTab2, nLastRow))
                 aPos.Y() += pDoc->GetRowHeight( nRow2, nTab2 ) / 2;
             TwipsToMM( aPos.X() );
             TwipsToMM( aPos.Y() );
diff --git sc/source/core/data/fillinfo.cxx sc/source/core/data/fillinfo.cxx
index 54ffe10..e875167 100644
--- sc/source/core/data/fillinfo.cxx
+++ sc/source/core/data/fillinfo.cxx
@@ -55,7 +55,6 @@
 #include "conditio.hxx"
 #include "stlpool.hxx"
 
-
 // -----------------------------------------------------------------------
 
 const USHORT ROWINFO_MAX = 1024;
@@ -100,11 +99,13 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
     rStartY = nY;
     BOOL bHOver = pInfo->bHOverlapped;
     BOOL bVOver = pInfo->bVOverlapped;
+    SCCOL nLastCol;
+    SCROW nLastRow;
 
     while (bHOver)				// nY konstant
     {
         --rStartX;
-        if (rStartX >= (SCsCOL) nX1 && (pDoc->GetColFlags(rStartX,nTab) & CR_HIDDEN) == 0)
+        if (rStartX >= (SCsCOL) nX1 && !pDoc->ColHidden(rStartX, nTab, nLastCol))
         {
             bHOver = pRowInfo[nArrY].pCellInfo[rStartX+1].bHOverlapped;
             bVOver = pRowInfo[nArrY].pCellInfo[rStartX+1].bVOverlapped;
@@ -126,8 +127,8 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
             --nArrY;						// lokale Kopie !
 
         if (rStartX >= (SCsCOL) nX1 && rStartY >= (SCsROW) nY1 &&
-            (pDoc->GetColFlags(rStartX,nTab) & CR_HIDDEN) == 0 &&
-            (pDoc->GetRowFlags(rStartY,nTab) & CR_HIDDEN) == 0 &&
+            !pDoc->ColHidden(rStartX, nTab, nLastCol) &&
+            !pDoc->RowHidden(rStartY, nTab, nLastRow) &&
             (SCsROW) pRowInfo[nArrY].nRowNo == rStartY)
         {
             bHOver = pRowInfo[nArrY].pCellInfo[rStartX+1].bHOverlapped;
@@ -144,8 +145,8 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
 
     const ScMergeAttr* pMerge;
     if (rStartX >= (SCsCOL) nX1 && rStartY >= (SCsROW) nY1 &&
-        (pDoc->GetColFlags(rStartX,nTab) & CR_HIDDEN) == 0 &&
-        (pDoc->GetRowFlags(rStartY,nTab) & CR_HIDDEN) == 0 &&
+        !pDoc->ColHidden(rStartX, nTab, nLastCol) &&
+        !pDoc->RowHidden(rStartY, nTab, nLastRow) &&
         (SCsROW) pRowInfo[nArrY].nRowNo == rStartY)
     {
         pMerge = (const ScMergeAttr*) &pRowInfo[nArrY].pCellInfo[rStartX+1].pPatternAttr->
@@ -158,12 +159,6 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
     rEndY = rStartY + pMerge->GetRowMerge() - 1;
 }
 
-inline BOOL ScDocument::RowHidden( SCROW nRow, SCTAB nTab )
-{
-    return ( pTab[nTab]->pRowFlags->GetValue(nRow) & CR_HIDDEN ) != 0;
-}
-
-
 #define CELLINFO(x,y) pRowInfo[nArrY+y].pCellInfo[nArrX+x]
 
 void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
@@ -359,7 +354,7 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
         nX = nArrX-1;
         if ( ValidCol(nX) )
         {
-            if ( (GetColFlags(nX,nTab) & CR_HIDDEN) == 0 )			// Spalte nicht versteckt
+            if (!ColHidden(nX, nTab))
             {
                 USHORT nThisWidth = (USHORT) (GetColWidth( nX, nTab ) * nScaleX);
                 if (!nThisWidth)
@@ -379,7 +374,8 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
             // #i58049#, #i57939# Hidden columns must be skipped here, or their attributes
             // will disturb the output
 
-            if ( (GetColFlags(nX,nTab) & CR_HIDDEN) == 0 )          // column not hidden
+            // TODO: Optimize this loop.
+            if (!ColHidden(nX, nTab))
             {
                 USHORT nThisWidth = (USHORT) (GetColWidth( nX, nTab ) * nScaleX);
                 if (!nThisWidth)
@@ -484,7 +480,14 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
 
                         do
                         {
-                            if ( nArrY==0 || !RowHidden( nCurRow,nTab ) )
+#define NEW_METHOD 1
+#if NEW_METHOD
+                            SCROW nLastHiddenRow = -1;
+                            bool bRowHidden = RowHidden(nCurRow, nTab, nLastHiddenRow);
+#else
+                            bool bRowHidden = RowHidden(nCurRow, nTab);
+#endif
+							if ( nArrY==0 || !bRowHidden )
                             {
                                 RowInfo* pThisRowInfo = &pRowInfo[nArrY];
                                 if (pBackground != pDefBackground)			// Spalten-HG == Standard ?
@@ -554,6 +557,14 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
 
                                 ++nArrY;
                             }
+#if NEW_METHOD
+                            else if (bRowHidden && nLastHiddenRow >= 0)
+                            {
+                                nCurRow = nLastHiddenRow;
+                                if (nCurRow > nThisRow)
+                                    nCurRow = nThisRow;
+                            }
+#endif
                             ++nCurRow;
                         }
                         while (nCurRow <= nThisRow && nCurRow <= nYExtra);
diff --git sc/source/core/data/olinetab.cxx sc/source/core/data/olinetab.cxx
index a30065e..cc4f7f6 100644
--- sc/source/core/data/olinetab.cxx
+++ sc/source/core/data/olinetab.cxx
@@ -44,6 +44,7 @@
 #include "global.hxx"
 #include "rechead.hxx"
 #include "address.hxx"
+#include "table.hxx"
 
 //------------------------------------------------------------------------
 
@@ -640,8 +641,7 @@ BOOL ScOutlineArray::DeleteSpace( SCCOLROW nStartPos, SCSIZE nSize )
     return bNeedSave;
 }
 
-BOOL ScOutlineArray::ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos,
-        BOOL bShow, const ScBitMaskCompressedArray< SCCOLROW, BYTE>& rHiddenFlags )
+bool ScOutlineArray::ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos, bool bShow, ScTable& rTable, bool bCol )
 {
     BOOL bModified = FALSE;
     ScSubOutlineIterator aIter( this );
@@ -657,9 +657,7 @@ BOOL ScOutlineArray::ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos,
             {
                 //	#i12341# hide if all columns/rows are hidden, show if at least one
                 //	is visible
-
-                SCCOLROW nEnd = rHiddenFlags.GetBitStateEnd( nEntryStart,
-                        CR_HIDDEN, CR_HIDDEN);
+                SCCOLROW nEnd = rTable.LastHiddenColRow(nEntryStart, bCol);
                 BOOL bAllHidden = (nEntryEnd <= nEnd && nEnd <
                         ::std::numeric_limits<SCCOLROW>::max());
 
diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
index 6a672e8..862508b 100644
--- sc/source/core/data/table1.cxx
+++ sc/source/core/data/table1.cxx
@@ -115,6 +115,7 @@
 #include "hints.hxx"		// fuer Paint-Broadcast
 #include "prnsave.hxx"
 #include "tabprotection.hxx"
+#include "segmenttree.hxx"
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -138,6 +139,10 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
     pRowHeight( NULL ),
     pColFlags( NULL ),
     pRowFlags( NULL ),
+    mpHiddenCols(new ScFlatBoolColSegments),
+    mpHiddenRows(new ScFlatBoolRowSegments),
+    mpFilteredCols(new ScFlatBoolColSegments),
+    mpFilteredRows(new ScFlatBoolRowSegments),
     pOutlineTable( NULL ),
     bTableAreaValid( FALSE ),
     bVisible( TRUE ),
@@ -888,9 +893,10 @@ BOOL ScTable::ValidNextPos( SCCOL nCol, SCROW nRow, const ScMarkData& rMark,
         //	auf der naechsten Zelle landet, auch wenn die geschuetzt/nicht markiert ist.
         //!	per Extra-Parameter steuern, nur fuer Cursor-Bewegung ???
 
-        if ( pRowFlags && ( pRowFlags->GetValue(nRow) & CR_HIDDEN ) )
+        if (RowHidden(nRow))
             return FALSE;
-        if ( pColFlags && ( pColFlags[nCol] & CR_HIDDEN ) )
+
+        if (ColHidden(nCol))
             return FALSE;
     }
 
@@ -917,8 +923,8 @@ void ScTable::GetNextPos( SCCOL& rCol, SCROW& rRow, SCsCOL nMovX, SCsROW nMovY,
     {
         BOOL bUp = ( nMovY < 0 );
         nRow = rMark.GetNextMarked( nCol, nRow, bUp );
-        while ( VALIDROW(nRow) && ((pRowFlags && (pRowFlags->GetValue(nRow) & CR_HIDDEN)) ||
-                pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
+        while ( VALIDROW(nRow) && 
+                (RowHidden(nRow) || pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
         {
             //	#53697# ausgeblendete ueberspringen (s.o.)
             nRow += nMovY;
@@ -928,7 +934,7 @@ void ScTable::GetNextPos( SCCOL& rCol, SCROW& rRow, SCsCOL nMovX, SCsROW nMovY,
         while ( nRow < 0 || nRow > MAXROW )
         {
             nCol = sal::static_int_cast<SCsCOL>( nCol + static_cast<SCsCOL>(nMovY) );
-            while ( VALIDCOL(nCol) && pColFlags && (pColFlags[nCol] & CR_HIDDEN) )
+			while ( VALIDCOL(nCol) && ColHidden(nCol) )
                 nCol = sal::static_int_cast<SCsCOL>( nCol + static_cast<SCsCOL>(nMovY) );   //	#53697# skip hidden rows (see above)
             if (nCol < 0)
             {
@@ -947,8 +953,8 @@ void ScTable::GetNextPos( SCCOL& rCol, SCROW& rRow, SCsCOL nMovX, SCsROW nMovY,
             else if (nRow > MAXROW)
                 nRow = 0;
             nRow = rMark.GetNextMarked( nCol, nRow, bUp );
-            while ( VALIDROW(nRow) && ((pRowFlags && (pRowFlags->GetValue(nRow) & CR_HIDDEN)) ||
-                    pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
+            while ( VALIDROW(nRow) && 
+                    (RowHidden(nRow) || pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
             {
                 //	#53697# ausgeblendete ueberspringen (s.o.)
                 nRow += nMovY;
@@ -1336,19 +1342,14 @@ void ScTable::ExtendPrintArea( OutputDevice* pDev,
 
     SCSIZE nIndex;
     SCCOL nPrintCol = rEndCol;
-    SCSIZE nRowFlagsIndex;
-    SCROW nRowFlagsEndRow;
-    BYTE nRowFlag = pRowFlags->GetValue( nStartRow, nRowFlagsIndex, nRowFlagsEndRow);
     for (SCROW nRow = nStartRow; nRow<=nEndRow; nRow++)
     {
-        if (nRow > nRowFlagsEndRow)
-            nRowFlag = pRowFlags->GetNextValue( nRowFlagsIndex, nRowFlagsEndRow);
-        if ( ( nRowFlag & CR_HIDDEN ) == 0 )
+		if (!RowHidden(nRow))
         {
             SCCOL nDataCol = rEndCol;
             while (nDataCol > 0 && ( bEmpty[nDataCol] || !aCol[nDataCol].Search(nRow,nIndex) ) )
                 --nDataCol;
-            if ( ( pColFlags[nDataCol] & CR_HIDDEN ) == 0 )
+            if (!ColHidden(nDataCol))
             {
                 ScBaseCell* pCell = aCol[nDataCol].GetCell(nRow);
                 if (pCell)
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index 972ec16..889510f 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -132,6 +132,9 @@ void ScTable::InsertRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
         }
         if (pOutlineTable)
             pOutlineTable->InsertRow( nStartRow, nSize );
+
+        mpFilteredRows->insertSegment(nStartRow, nSize, true);
+        mpHiddenRows->insertSegment(nStartRow, nSize, true);
     }
 
     for (SCCOL j=nStartCol; j<=nEndCol; j++)
@@ -159,6 +162,9 @@ void ScTable::DeleteRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
             if (pOutlineTable->DeleteRow( nStartRow, nSize ))
                 if (pUndoOutline)
                     *pUndoOutline = TRUE;
+
+        mpFilteredRows->removeSegment(nStartRow, nStartRow+nSize);
+        mpHiddenRows->removeSegment(nStartRow, nStartRow+nSize);
     }
 
     {   // scope for bulk broadcast
@@ -205,6 +211,9 @@ void ScTable::InsertCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
         }
         if (pOutlineTable)
             pOutlineTable->InsertCol( nStartCol, nSize );
+
+        mpHiddenCols->insertSegment(nStartCol, nSize, true);
+        mpFilteredCols->insertSegment(nStartCol, nSize, true);
     }
 
 
@@ -260,6 +269,9 @@ void ScTable::DeleteCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
             if (pOutlineTable->DeleteCol( nStartCol, nSize ))
                 if (pUndoOutline)
                     *pUndoOutline = TRUE;
+
+        mpHiddenCols->removeSegment(nStartCol, nStartCol+nSize);
+        mpFilteredCols->removeSegment(nStartCol, nStartCol+nSize);
     }
 
 
@@ -357,20 +369,21 @@ void ScTable::CopyToClip(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
         //	copy widths/heights, and only "hidden", "filtered" and "manual" flags
         //	also for all preceding columns/rows, to have valid positions for drawing objects
 
-        if (pColFlags && pTable->pColFlags && pColWidth && pTable->pColWidth)
+		if (pColWidth && pTable->pColWidth)
             for (i=0; i<=nCol2; i++)
-            {
-                pTable->pColFlags[i] = pColFlags[i] & CR_HIDDEN;
                 pTable->pColWidth[i] = pColWidth[i];
-            }
+
+        pTable->CopyColHidden(*this, 0, nCol2);
+        pTable->CopyColFiltered(*this, 0, nCol2);
 
         if (pRowFlags && pTable->pRowFlags && pRowHeight && pTable->pRowHeight)
         {
-            pTable->pRowFlags->CopyFromAnded( *pRowFlags, 0, nRow2,
-                    (CR_HIDDEN | CR_FILTERED | CR_MANUALSIZE));
+            pTable->pRowFlags->CopyFromAnded( *pRowFlags, 0, nRow2, CR_MANUALSIZE);
             pTable->pRowHeight->CopyFrom( *pRowHeight, 0, nRow2);
         }
 
+        pTable->CopyRowHidden(*this, 0, nRow2);
+        pTable->CopyRowFiltered(*this, 0, nRow2);
 
         //	ggf. Formeln durch Werte ersetzen
 
@@ -660,10 +673,12 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                 if (bWidth)
                     for (SCCOL i=nCol1; i<=nCol2; i++)
                     {
-						bool bHiddenChange = ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+                    bool bThisHidden = ColHidden(i);
+                    bool bHiddenChange = (pDestTab->ColHidden(i) != bThisHidden);
 						bool bChange = bHiddenChange || (pDestTab->pColWidth[i] != pColWidth[i]);
                         pDestTab->pColWidth[i] = pColWidth[i];
                         pDestTab->pColFlags[i] = pColFlags[i];
+                    pDestTab->SetColHidden(i, i, bThisHidden);
                         //!	Aenderungen zusammenfassen?
 						if (bHiddenChange && pCharts) 
                             pCharts->SetRangeDirty(ScRange( i, 0, nTab, i, MAXROW, nTab ));
@@ -685,8 +700,10 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                         // TODO: might need some performance improvement, block
                         // operations instead of single GetValue()/SetValue() calls.
                         BYTE nThisRowFlags = pRowFlags->GetValue(i);
-						bool bHiddenChange = ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
+                    bool bThisHidden = RowHidden(i);
+                    bool bHiddenChange = (pDestTab->RowHidden(i) != bThisHidden);
                         pDestTab->pRowFlags->SetValue( i, nThisRowFlags );
+                    pDestTab->SetRowHidden(i, i, bThisHidden);
                         //!	Aenderungen zusammenfassen?
 						if (bHiddenChange && pCharts)
                             pCharts->SetRangeDirty(ScRange( 0, i, nTab, MAXCOL, i, nTab ));
@@ -1299,7 +1316,7 @@ BOOL ScTable::IsBlockEmpty( SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
 
 SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2,
                             SCCOL nCol, SCROW nAttrRow1, SCROW nAttrRow2, SCSIZE nArrY,
-                            const ScPatternAttr* pPattern, const SfxItemSet* pCondSet ) const
+							const ScPatternAttr* pPattern, const SfxItemSet* pCondSet )
 {
     //	Rueckgabe = neues nArrY
 
@@ -1332,7 +1349,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
 
             for ( SCROW nRow = nAttrRow1; nRow <= nAttrRow2; nRow++ )
             {
-                if ( !(pRowFlags->GetValue(nRow) & CR_HIDDEN) )
+                if (!RowHidden(nRow))
                 {
                     BOOL bHitOne = TRUE;
                     if ( nCol > nX2+1 )
@@ -1366,7 +1383,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
     return nArrY;
 }
 
-void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 ) const
+void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 )
 {
     if ( !pColWidth || !pRowHeight || !pColFlags || !pRowFlags )
     {
@@ -1381,7 +1398,7 @@ void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCC
 
     for (SCCOL nCol=0; nCol<=MAXCOL; nCol++)
     {
-        if ( !(pColFlags[nCol] & CR_HIDDEN) )
+        if (!ColHidden(nCol))
         {
             SCSIZE nArrY = 0;
             ScDocAttrIterator aIter( pDocument, nTab, nCol, nY1, nCol, nY2 );
@@ -2160,13 +2177,13 @@ void ScTable::SetManualHeight( SCROW nStartRow, SCROW nEndRow, BOOL bManual )
 }
 
 
-USHORT ScTable::GetColWidth( SCCOL nCol ) const
+USHORT ScTable::GetColWidth( SCCOL nCol )
 {
     DBG_ASSERT(VALIDCOL(nCol),"Falsche Spaltennummer");
 
     if (VALIDCOL(nCol) && pColFlags && pColWidth)
     {
-        if ( pColFlags[nCol] & CR_HIDDEN )
+        if (ColHidden(nCol))
             return 0;
         else
             return pColWidth[nCol];
@@ -2187,7 +2204,7 @@ USHORT ScTable::GetOriginalWidth( SCCOL nCol ) const		// immer die eingestellte
 }
 
 
-USHORT ScTable::GetCommonWidth( SCCOL nEndCol ) const
+USHORT ScTable::GetCommonWidth( SCCOL nEndCol )
 {
     //	get the width that is used in the largest continuous column range (up to nEndCol)
 
@@ -2199,24 +2216,24 @@ USHORT ScTable::GetCommonWidth( SCCOL nEndCol ) const
 
     USHORT nMaxWidth = 0;
     USHORT nMaxCount = 0;
-    USHORT nRangeStart = 0;
+	SCCOL nRangeStart = 0;
     while ( nRangeStart <= nEndCol )
     {
         //	skip hidden columns
-        while ( nRangeStart <= nEndCol && (pColFlags[nRangeStart] & CR_HIDDEN) )
+		while ( nRangeStart <= nEndCol && ColHidden(nRangeStart) )
             ++nRangeStart;
         if ( nRangeStart <= nEndCol )
         {
             USHORT nThisCount = 0;
             USHORT nThisWidth = pColWidth[nRangeStart];
-            USHORT nRangeEnd = nRangeStart;
+			SCCOL nRangeEnd = nRangeStart;
             while ( nRangeEnd <= nEndCol && pColWidth[nRangeEnd] == nThisWidth )
             {
                 ++nThisCount;
                 ++nRangeEnd;
 
                 //	skip hidden columns
-                while ( nRangeEnd <= nEndCol && (pColFlags[nRangeEnd] & CR_HIDDEN) )
+				while ( nRangeEnd <= nEndCol && ColHidden(nRangeEnd) )
                     ++nRangeEnd;
             }
 
@@ -2234,13 +2251,13 @@ USHORT ScTable::GetCommonWidth( SCCOL nEndCol ) const
 }
 
 
-USHORT ScTable::GetRowHeight( SCROW nRow ) const
+USHORT ScTable::GetRowHeight( SCROW nRow )
 {
     DBG_ASSERT(VALIDROW(nRow),"Falsche Zeilennummer");
 
-    if (VALIDROW(nRow) && pRowFlags && pRowHeight)
+	if (VALIDROW(nRow) && pRowHeight)
     {
-        if ( pRowFlags->GetValue(nRow) & CR_HIDDEN )
+        if (RowHidden(nRow))
             return 0;
         else
             return pRowHeight->GetValue(nRow);
@@ -2250,28 +2267,53 @@ USHORT ScTable::GetRowHeight( SCROW nRow ) const
 }
 
 
-ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow ) const
+ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow )
 {
     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
 
-    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowFlags && pRowHeight)
+	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
     {
-        return pRowFlags->SumCoupledArrayForCondition( nStartRow, nEndRow,
-                CR_HIDDEN, 0, *pRowHeight);
+        ULONG nHeight = 0;
+        SCROW nRow = nStartRow;
+        while (nRow <= nEndRow)
+        {
+            SCROW nLastRow = -1;
+            if (!RowHidden(nRow, nLastRow))
+            {
+                if (nLastRow > nEndRow)
+                    nLastRow = nEndRow;
+                nHeight += pRowFlags->SumCoupledArrayForCondition(nRow, nLastRow, 0, 0, *pRowHeight);
+            }
+            nRow = nLastRow + 1;
+        }
+        return nHeight;
     }
     else
         return (ULONG) ((nEndRow - nStartRow + 1) * ScGlobal::nStdRowHeight);
 }
 
 
-ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale ) const
+ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale )
 {
     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
 
-    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowFlags && pRowHeight)
+	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
     {
-        return pRowFlags->SumScaledCoupledArrayForCondition( nStartRow,
-                nEndRow, CR_HIDDEN, 0, *pRowHeight, fScale);
+        ULONG nHeight = 0;
+        SCROW nRow = nStartRow;
+        while (nRow <= nEndRow)
+        {
+            SCROW nLastRow = -1;
+            if (!RowHidden(nRow, nLastRow))
+            {
+                if (nLastRow > nEndRow)
+                    nLastRow = nEndRow;
+                nHeight += pRowFlags->SumScaledCoupledArrayForCondition(
+                    nRow, nLastRow, 0, 0, *pRowHeight, fScale);
+            }
+            nRow = nLastRow + 1;
+        }
+        return nHeight;
     }
     else
         return (ULONG) ((nEndRow - nStartRow + 1) * ScGlobal::nStdRowHeight * fScale);
@@ -2292,18 +2334,16 @@ USHORT ScTable::GetOriginalHeight( SCROW nRow ) const		// non-0 even if hidden
 //	Spalten-/Zeilen-Flags
 
 
-SCROW ScTable::GetHiddenRowCount( SCROW nRow ) const
+SCROW ScTable::GetHiddenRowCount( SCROW nRow )
 {
-    SCROW nEndRow = nRow;
-    if ( pRowFlags )
-    {
-        nEndRow = pRowFlags->GetBitStateEnd( nRow, CR_HIDDEN, CR_HIDDEN);
-        if (ValidRow(nEndRow))
-            ++nEndRow;
-        else
-            nEndRow = nRow;
-    }
-    return nEndRow - nRow;
+    if (!ValidRow(nRow))
+        return 0;
+
+    SCROW nLastRow = -1;
+    if (!RowHidden(nRow, nLastRow) || !ValidRow(nLastRow))
+        return 0;
+
+    return nLastRow - nRow + 1;
 }
 
 
@@ -2311,9 +2351,9 @@ SCROW ScTable::GetHiddenRowCount( SCROW nRow ) const
 
 void ScTable::ShowCol(SCCOL nCol, BOOL bShow)
 {
-    if (VALIDCOL(nCol) && pColFlags)
+	if (VALIDCOL(nCol))
     {
-        BOOL bWasVis = ( pColFlags[nCol] & CR_HIDDEN ) == 0;
+        bool bWasVis = !ColHidden(nCol);
         if (bWasVis != bShow)
         {
             nRecalcLvl++;
@@ -2327,10 +2367,8 @@ void ScTable::ShowCol(SCCOL nCol, BOOL bShow)
                     pDrawLayer->WidthChanged( nTab, nCol, -(long) pColWidth[nCol] );
             }
 
-            if (bShow)
-                pColFlags[nCol] &= ~CR_HIDDEN;
-            else
-                pColFlags[nCol] |= CR_HIDDEN;
+            SetColHidden(nCol, nCol, !bShow);
+
             if( !--nRecalcLvl )
                 SetDrawPageSize();
 
@@ -2350,8 +2388,7 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
 {
     if (VALIDROW(nRow) && pRowFlags)
     {
-        BYTE nFlags = pRowFlags->GetValue(nRow);
-        BOOL bWasVis = ( nFlags & CR_HIDDEN ) == 0;
+        bool bWasVis = !RowHidden(nRow);
         if (bWasVis != bShow)
         {
             nRecalcLvl++;
@@ -2365,10 +2402,10 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
                     pDrawLayer->HeightChanged( nTab, nRow, -(long) pRowHeight->GetValue(nRow) );
             }
 
+            SetRowHidden(nRow, nRow, !bShow);
             if (bShow)
-                pRowFlags->SetValue( nRow, nFlags & ~(CR_HIDDEN | CR_FILTERED));
-            else
-                pRowFlags->SetValue( nRow, nFlags | CR_HIDDEN);
+                SetRowFiltered(nRow, nRow, false);
+
             if( !--nRecalcLvl )
                 SetDrawPageSize();
 
@@ -2390,8 +2427,7 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
 {
     if (VALIDROW(nRow) && pRowFlags)
     {
-        BYTE nFlags = pRowFlags->GetValue(nRow);
-        BOOL bWasVis = ( nFlags & CR_HIDDEN ) == 0;
+        bool bWasVis = !RowHidden(nRow);
         nRecalcLvl++;
         InitializeNoteCaptions();
         if (bWasVis != bShow)
@@ -2407,10 +2443,10 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
         }
 
         //	Filter-Flag immer setzen, auch wenn Hidden unveraendert
-        if (bShow)
-            pRowFlags->SetValue( nRow, nFlags & ~(CR_HIDDEN | CR_FILTERED));
-        else
-            pRowFlags->SetValue( nRow, nFlags | (CR_HIDDEN | CR_FILTERED));
+
+        SetRowHidden(nRow, nRow, !bShow);
+        SetRowFiltered(nRow, nRow, !bShow);
+
         if( !--nRecalcLvl )
             SetDrawPageSize();
 
@@ -2440,12 +2476,11 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
     InitializeNoteCaptions();
     while (nStartRow <= nRow2)
     {
-        BYTE nOldFlag = pRowFlags->GetValue(nStartRow) & CR_HIDDEN;
-        SCROW nEndRow = pRowFlags->GetBitStateEnd( nStartRow, CR_HIDDEN, nOldFlag);
+        SCROW nEndRow = -1;
+        bool bWasVis = !RowHidden(nStartRow, nEndRow);
         if (nEndRow > nRow2)
             nEndRow = nRow2;
 
-        BOOL bWasVis = ( nOldFlag == 0 );
         BOOL bChanged = ( bWasVis != bShow );
         if ( bChanged )
         {
@@ -2460,10 +2495,8 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             }
         }
 
-        if (bShow)
-            pRowFlags->AndValue( nStartRow, nEndRow, sal::static_int_cast<BYTE>(~(CR_HIDDEN | CR_FILTERED)) );
-        else
-            pRowFlags->OrValue( nStartRow, nEndRow, (CR_HIDDEN | CR_FILTERED));
+        SetRowHidden(nStartRow, nEndRow, !bShow);
+        SetRowFiltered(nStartRow, nEndRow, !bShow);
 
         if ( bChanged )
         {
@@ -2493,12 +2526,11 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
     InitializeNoteCaptions();
     while (nStartRow <= nRow2)
     {
-        BYTE nOldFlag = pRowFlags->GetValue(nStartRow) & CR_HIDDEN;
-        SCROW nEndRow = pRowFlags->GetBitStateEnd( nStartRow, CR_HIDDEN, nOldFlag);
+        SCROW nEndRow = -1;
+        bool bWasVis = !RowHidden(nStartRow, nEndRow);
         if (nEndRow > nRow2)
             nEndRow = nRow2;
 
-        BOOL bWasVis = ( nOldFlag == 0 );
         BOOL bChanged = ( bWasVis != bShow );
         if ( bChanged )
         {
@@ -2513,10 +2545,9 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             }
         }
 
+        SetRowHidden(nStartRow, nEndRow, !bShow);
         if (bShow)
-            pRowFlags->AndValue( nStartRow, nEndRow, sal::static_int_cast<BYTE>(~(CR_HIDDEN | CR_FILTERED)) );
-        else
-            pRowFlags->OrValue( nStartRow, nEndRow, CR_HIDDEN);
+            SetRowFiltered(nStartRow, nEndRow, false);
 
         if ( bChanged )
         {
@@ -2534,16 +2565,6 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 }
 
 
-BOOL ScTable::IsFiltered(SCROW nRow) const
-{
-    if (VALIDROW(nRow) && pRowFlags)
-        return ( pRowFlags->GetValue(nRow) & CR_FILTERED ) != 0;
-
-    DBG_ERROR("Falsche Zeilennummer oder keine Flags");
-    return FALSE;
-}
-
-
 void ScTable::SetColFlags( SCCOL nCol, BYTE nNewFlags )
 {
     if (VALIDCOL(nCol) && pColFlags)
@@ -2641,7 +2662,7 @@ BOOL ScTable::UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, BOOL bShow )
     if (pOutlineTable && pColFlags)
     {
         ScBitMaskCompressedArray< SCCOLROW, BYTE> aArray( MAXCOL, pColFlags, MAXCOLCOUNT);
-        return pOutlineTable->GetColArray()->ManualAction( nStartCol, nEndCol, bShow, aArray );
+		return pOutlineTable->GetColArray()->ManualAction( nStartCol, nEndCol, bShow, *this, true );
     }
     else
         return FALSE;
@@ -2651,7 +2672,7 @@ BOOL ScTable::UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, BOOL bShow )
 BOOL ScTable::UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, BOOL bShow )
 {
     if (pOutlineTable && pRowFlags)
-        return pOutlineTable->GetRowArray()->ManualAction( nStartRow, nEndRow, bShow, *pRowFlags );
+		return pOutlineTable->GetRowArray()->ManualAction( nStartRow, nEndRow, bShow, *this, false );
     else
         return FALSE;
 }
@@ -2659,54 +2680,58 @@ BOOL ScTable::UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, BOOL bShow )
 
 void ScTable::ExtendHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 )
 {
-    if (pColFlags)
-    {
-        while ( rX1>0 ? (pColFlags[rX1-1] & CR_HIDDEN) : FALSE )
-            --rX1;
-        while ( rX2<MAXCOL ? (pColFlags[rX2+1] & CR_HIDDEN) : FALSE )
-            ++rX2;
-    }
-    if (pRowFlags)
+    // Column-wise expansion
+
+    while (rX1 > 0 && ColHidden(rX1-1))
+        --rX1;
+
+    while (rX2 < MAXCOL && ColHidden(rX2+1))
+        ++rX2;
+
+    // Row-wise expansion
+
+    if (rY1 > 0)
     {
-        if (rY1 > 0)
+        ScFlatBoolRowSegments::RangeData aData;
+        if (mpHiddenRows->getRangeData(rY1-1, aData) && aData.mbValue)
         {
-            SCROW nStartRow = pRowFlags->GetBitStateStart( rY1-1, CR_HIDDEN, CR_HIDDEN);
+            SCROW nStartRow = aData.mnRow1;
             if (ValidRow(nStartRow))
                 rY1 = nStartRow;
         }
-        if (rY2 < MAXROW)
-        {
-            SCROW nEndRow = pRowFlags->GetBitStateEnd( rY2+1, CR_HIDDEN, CR_HIDDEN);
-            if (ValidRow(nEndRow))
-                rY2 = nEndRow;
-        }
+    }
+    if (rY2 < MAXROW)
+    {
+        SCROW nEndRow = -1;
+        if (RowHidden(rY2+1, nEndRow) && ValidRow(nEndRow))
+            rY2 = nEndRow;
     }
 }
 
 
 void ScTable::StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 )
 {
-    if (pColFlags)
-    {
-        while ( rX2>rX1 && (pColFlags[rX2] & CR_HIDDEN) )
-            --rX2;
-        while ( rX2>rX1 && (pColFlags[rX1] & CR_HIDDEN) )
-            ++rX1;
-    }
-    if (pRowFlags)
+    while ( rX2>rX1 && ColHidden(rX2) )
+        --rX2;
+    while ( rX2>rX1 && ColHidden(rX1) )
+        ++rX1;
+
+    if (rY1 < rY2)
     {
-        if (rY1 < rY2)
+        ScFlatBoolRowSegments::RangeData aData;
+        if (mpHiddenRows->getRangeData(rY2, aData) && aData.mbValue)
         {
-            SCROW nStartRow = pRowFlags->GetBitStateStart( rY2, CR_HIDDEN, CR_HIDDEN);
+            SCROW nStartRow = aData.mnRow1;
             if (ValidRow(nStartRow) && nStartRow >= rY1)
                 rY2 = nStartRow;
         }
-        if (rY1 < rY2)
-        {
-            SCROW nEndRow = pRowFlags->GetBitStateEnd( rY1, CR_HIDDEN, CR_HIDDEN);
-            if (ValidRow(nEndRow) && nEndRow <= rY2)
-                rY1 = nEndRow;
-        }
+    }
+
+    if (rY1 < rY2)
+    {
+        SCROW nEndRow = -1;
+        if (RowHidden(rY1, nEndRow) && ValidRow(nEndRow) && nEndRow <= rY2)
+            rY1 = nEndRow;
     }
 }
 
@@ -2868,16 +2893,16 @@ BOOL ScTable::RefVisible(ScFormulaCell* pCell)
 
     if (pCell->HasOneReference(aRef))
     {
-        if (aRef.aStart.Col()==aRef.aEnd.Col() && aRef.aStart.Tab()==aRef.aEnd.Tab() && pRowFlags)
+		if (aRef.aStart.Col()==aRef.aEnd.Col() && aRef.aStart.Tab()==aRef.aEnd.Tab())
         {
-            // while ((value & CR_FILTERED) == CR_FILTERED)
-            // most times will be faster than
-            // while ((value & CR_FILTERED) == 0)
-            SCROW nEndRow = pRowFlags->GetBitStateEnd( aRef.aStart.Row(),
-                    CR_FILTERED, CR_FILTERED);
+            SCROW nEndRow;
+            if (!RowFiltered(aRef.aStart.Row(), NULL, &nEndRow))
+                // row not filtered.
+                nEndRow = ::std::numeric_limits<SCROW>::max();
+
             if (!ValidRow(nEndRow) || nEndRow < aRef.aEnd.Row())
                 return TRUE;    // at least partly visible
-            return FALSE;       // completely unvisible
+            return FALSE;       // completely invisible
         }
     }
 
@@ -2914,7 +2939,7 @@ void ScTable::SetDrawPageSize()
 }
 
 
-ULONG ScTable::GetRowOffset( SCROW nRow ) const
+ULONG ScTable::GetRowOffset( SCROW nRow )
 {
     ULONG n = 0;
     if ( pRowFlags && pRowHeight )
@@ -2924,8 +2949,7 @@ ULONG ScTable::GetRowOffset( SCROW nRow ) const
         else if (nRow == 1)
             return GetRowHeight(0);
 
-        n = pRowFlags->SumCoupledArrayForCondition( 0, nRow-1, CR_HIDDEN, 0,
-                *pRowHeight);
+        n = GetTotalRowHeight(0, nRow-1);
 #ifdef DBG_UTIL
         if (n == ::std::numeric_limits<unsigned long>::max())
             DBG_ERRORFILE("ScTable::GetRowOffset: row heights overflow");
@@ -2938,18 +2962,42 @@ ULONG ScTable::GetRowOffset( SCROW nRow ) const
     return n;
 }
 
+SCROW ScTable::GetRowForHeight(ULONG nHeight)
+{
+    sal_uInt32 nSum = 0;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    for (SCROW nRow = 0; nRow <= MAXROW; ++nRow)
+    {
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mbValue)
+        {
+            nRow = aData.mnRow2;
+            continue;
+        }
+
+        sal_uInt32 nNew = pRowHeight->GetValue(nRow);
+        nSum += nNew;
+        if (nSum > nHeight)
+        {
+            return nRow < MAXROW ? nRow + 1 : MAXROW;
+        }
+    }
+    return -1;
+}
+
 
-ULONG ScTable::GetColOffset( SCCOL nCol ) const
+ULONG ScTable::GetColOffset( SCCOL nCol )
 {
     ULONG n = 0;
-    if ( pColFlags && pColWidth )
+	if ( pColWidth )
     {
         SCCOL i;
-        BYTE* pFlags = pColFlags;
-        USHORT* pWidth = pColWidth;
-        for( i = 0; i < nCol; i++, pFlags++, pWidth++ )
-            if( !( *pFlags & CR_HIDDEN ) )
-                n += *pWidth;
+		for( i = 0; i < nCol; i++ )
+            if (!ColHidden(i))
+				n += pColWidth[i];
     }
     else
     {
diff --git sc/source/core/data/table3.cxx sc/source/core/data/table3.cxx
index 4d3b4de..cbf417b 100644
--- sc/source/core/data/table3.cxx
+++ sc/source/core/data/table3.cxx
@@ -603,14 +603,17 @@ void ScTable::SwapRow(SCROW nRow1, SCROW nRow2)
             }
         }
     }
-    if (bGlobalKeepQuery && pRowFlags)
+	if (bGlobalKeepQuery)
     {
-        BYTE nRow1Flags = pRowFlags->GetValue(nRow1);
-        BYTE nRow2Flags = pRowFlags->GetValue(nRow2);
-        BYTE nFlags1 = nRow1Flags & ( CR_HIDDEN | CR_FILTERED );
-        BYTE nFlags2 = nRow2Flags & ( CR_HIDDEN | CR_FILTERED );
-        pRowFlags->SetValue( nRow1, (nRow1Flags & ~( CR_HIDDEN | CR_FILTERED )) | nFlags2);
-        pRowFlags->SetValue( nRow2, (nRow2Flags & ~( CR_HIDDEN | CR_FILTERED )) | nFlags1);
+        bool bRow1Hidden = RowHidden(nRow1);
+        bool bRow2Hidden = RowHidden(nRow2);
+        SetRowHidden(nRow1, nRow1, bRow2Hidden);
+        SetRowHidden(nRow2, nRow2, bRow1Hidden);
+
+        bool bRow1Filtered = RowFiltered(nRow1);
+        bool bRow2Filtered = RowFiltered(nRow2);
+        SetRowFiltered(nRow1, nRow1, bRow2Filtered);
+        SetRowFiltered(nRow2, nRow2, bRow1Filtered);
     }
 }
 
@@ -991,13 +994,6 @@ BOOL ScTable::DoSubTotals( ScSubTotalParam& rParam )
                         SetString( nGroupCol[aRowEntry.nGroupNo], aRowEntry.nDestRow, nTab, aOutString );
                         ApplyStyle( nGroupCol[aRowEntry.nGroupNo], aRowEntry.nDestRow, *pStyle );
 
-/*						if (rParam.bPagebreak && nRow < MAXROW)
-                        {
-                            BYTE nFlags = GetRowFlags( nRow+1 );
-                            nFlags |= CR_MANUALBREAK;
-                            SetRowFlags( nRow+1, nFlags );
-                        }
-*/
                         ++nRow;
                         ++nEndRow;
                         aRowEntry.nSubStartRow = nRow;
@@ -1011,11 +1007,7 @@ BOOL ScTable::DoSubTotals( ScSubTotalParam& rParam )
                         }
                     }
                 }
-                if (!pRowFlags)
-                    bBlockVis = TRUE;
-                else
-                    if ( (pRowFlags->GetValue(nRow) & CR_FILTERED) == 0 )
-                        bBlockVis = TRUE;
+                bBlockVis = !RowFiltered(nRow);
             }
         }
         else
@@ -2051,8 +2043,8 @@ void ScTable::UpdateSelectionFunction( ScFunctionData& rData,
     SCCOL nCol;
     if ( rMark.IsMultiMarked() )
         for (nCol=0; nCol<=MAXCOL && !rData.bError; nCol++)
-            if ( !pColFlags || !( pColFlags[nCol] & CR_HIDDEN ) )
-                aCol[nCol].UpdateSelectionFunction( rMark, rData, pRowFlags,
+			if ( !pColFlags || !ColHidden(nCol) )
+				aCol[nCol].UpdateSelectionFunction( rMark, rData, *mpHiddenRows,
                                                     bSingle && ( nCol >= nStartCol && nCol <= nEndCol ),
                                                     nStartRow, nEndRow );
 
@@ -2060,8 +2052,8 @@ void ScTable::UpdateSelectionFunction( ScFunctionData& rData,
 
     if ( bSingle && !rMark.IsMarkNegative() )
         for (nCol=nStartCol; nCol<=nEndCol && !rData.bError; nCol++)
-            if ( !pColFlags || !( pColFlags[nCol] & CR_HIDDEN ) )
-                aCol[nCol].UpdateAreaFunction( rData, pRowFlags, nStartRow, nEndRow );
+			if ( !pColFlags || !ColHidden(nCol) )
+				aCol[nCol].UpdateAreaFunction( rData, *mpHiddenRows, nStartRow, nEndRow );
 }
 
 void ScTable::FindConditionalFormat( ULONG nKey, ScRangeList& rList )
diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
index 48f7110..7e7cab9 100644
--- sc/source/core/data/table5.cxx
+++ sc/source/core/data/table5.cxx
@@ -53,9 +53,11 @@
 #include "brdcst.hxx"
 #include "tabprotection.hxx"
 #include "globstr.hrc"
+#include "segmenttree.hxx"
 #include <com/sun/star/sheet/TablePageBreakData.hpp>
 
 #include <algorithm>
+#include <limits>
 
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::sheet::TablePageBreakData;
@@ -168,7 +170,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     for (nX=nStartCol; nX<=nEndCol; nX++)
     {
         BOOL bStartOfPage = FALSE;
-        long nThisX = ( pColFlags[nX] & CR_HIDDEN ) ? 0 : pColWidth[nX];
+		long nThisX = ColHidden(nX) ? 0 : pColWidth[nX];
         bool bManualBreak = HasColManualBreak(nX);
         if ( (nSizeX+nThisX > nPageSizeX) || (bManualBreak && !bSkipBreaks) )
         {
@@ -185,7 +187,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
         {
             // subtract size of repeat columns from page size
             for (SCCOL i=nRepeatStartX; i<=nRepeatEndX; i++)
-                nPageSizeX -= ( pColFlags[i] & CR_HIDDEN ) ? 0 : pColWidth[i];
+				nPageSizeX -= ColHidden(i) ? 0 : pColWidth[i];
             while (nX<=nRepeatEndX)
                 RemoveColBreak(++nX, true, false);
             bColFound = TRUE;
@@ -204,8 +206,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
     {
         BOOL bStartOfPage = FALSE;
-        BYTE nFlags = pRowFlags->GetValue(nY);
-        long nThisY = (nFlags & CR_HIDDEN) ? 0 : pRowHeight->GetValue(nY);
+        long nThisY = RowHidden(nY) ? 0 : pRowHeight->GetValue(nY);
         bool bManualBreak = HasRowManualBreak(nY);
 		if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
         {
@@ -221,8 +222,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
         if ( bStartOfPage && bRepeatRow && nY>nRepeatStartY && !bRowFound )
         {
             // subtract size of repeat rows from page size
-            unsigned long nHeights = pRowFlags->SumCoupledArrayForCondition(
-                    nRepeatStartY, nRepeatEndY, CR_HIDDEN, 0, *pRowHeight);
+            unsigned long nHeights = GetTotalRowHeight(nRepeatStartY, nRepeatEndY);
 #ifdef DBG_UTIL
             if (nHeights == ::std::numeric_limits<unsigned long>::max())
                 DBG_ERRORFILE("ScTable::UpdatePageBreaks: row heights overflow");
@@ -416,12 +416,516 @@ Sequence<TablePageBreakData> ScTable::GetRowBreakData() const
     return aSeq;
 }
 
-void ScTable::SyncColRowFlags()
+bool ScTable::RowHidden(SCROW nRow, SCROW* pFirstRow, SCROW* pLastRow)
+{
+    if (!ValidRow(nRow))
+        return true;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    if (!mpHiddenRows->getRangeData(nRow, aData))
+        // search failed.
+        return true;
+
+    if (pFirstRow)
+        *pFirstRow = aData.mnRow1;
+    if (pLastRow)
+        *pLastRow = aData.mnRow2;
+
+    return aData.mbValue;
+}
+
+
+bool ScTable::RowHidden(SCROW nRow, SCROW& rLastRow)
+{
+    rLastRow = nRow;    
+    if (!ValidRow(nRow))
+        return true;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    if (!mpHiddenRows->getRangeData(nRow, aData))
+        // search failed.
+        return true;
+
+    rLastRow = aData.mnRow2;
+    return aData.mbValue;
+}
+
+bool ScTable::HasHiddenRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = -1;
+        bool bHidden = RowHidden(nRow, nLastRow);
+        if (bHidden)
+            return true;
+
+        nRow = nLastRow + 1;
+    }
+    return false;
+}
+
+bool ScTable::ColHidden(SCCOL nCol, SCCOL& rLastCol)
+{
+    rLastCol = nCol;    
+    if (!ValidCol(nCol))
+        return true;
+
+    ScFlatBoolColSegments::RangeData aData;
+    if (!mpHiddenCols->getRangeData(nCol, aData))
+        return true;
+
+    rLastCol = aData.mnCol2;
+    return aData.mbValue;
+}
+
+bool ScTable::ColHidden(SCCOL nCol, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+    if (!ValidCol(nCol))
+        return true;
+
+    ScFlatBoolColSegments::RangeData aData;
+    if (!mpHiddenCols->getRangeData(nCol, aData))
+        return true;
+
+    if (pFirstCol)
+        *pFirstCol = aData.mnCol1;
+    if (pLastCol)
+        *pLastCol = aData.mnCol2;
+
+    return aData.mbValue;
+}
+
+void ScTable::SetRowHidden(SCROW nStartRow, SCROW nEndRow, bool bHidden)
+{
+    if (bHidden)
+        mpHiddenRows->setTrue(nStartRow, nEndRow);
+    else
+        mpHiddenRows->setFalse(nStartRow, nEndRow);
+
+#if 0
+    // Remove this once the refactoring is complete.
+    if (bHidden)
+        pRowFlags->OrValue(nStartRow, nEndRow, CR_HIDDEN);
+    else
+        pRowFlags->AndValue(nStartRow, nEndRow, ~CR_HIDDEN);
+#endif
+}
+
+void ScTable::SetColHidden(SCCOL nStartCol, SCCOL nEndCol, bool bHidden)
+{
+    if (bHidden)
+        mpHiddenCols->setTrue(nStartCol, nEndCol);
+    else
+        mpHiddenCols->setFalse(nStartCol, nEndCol);
+#if 0
+    for (SCCOL nCol = nStartCol; nCol <= nEndCol; ++nCol)
+    {
+        if (bHidden)
+            pColFlags[nCol] |= CR_HIDDEN;
+        else
+            pColFlags[nCol] &= ~CR_HIDDEN;
+    }
+#endif
+}
+
+void ScTable::CopyColHidden(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol)
+{
+    SCCOL nCol = nStartCol;
+    while (nCol <= nEndCol)
+    {
+        SCCOL nLastCol;
+        bool bHidden = rTable.ColHidden(nCol, NULL, &nLastCol);
+        if (nLastCol > nEndCol)
+            nLastCol = nEndCol;
+
+        SetColHidden(nCol, nLastCol, bHidden);
+        nCol = nLastCol + 1;
+    }
+}
+
+void ScTable::CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = -1;
+        bool bHidden = rTable.RowHidden(nRow, nLastRow);
+        if (nLastRow > nEndRow)
+            nLastRow = nEndRow;
+        SetRowHidden(nRow, nLastRow, bHidden);
+        nRow = nLastRow + 1;
+    }
+}
+
+SCROW ScTable::FirstVisibleRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // visible row found
+            return nRow;
+
+        nRow = aData.mnRow2 + 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::LastVisibleRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nEndRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow >= nStartRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // visible row found
+            return nRow;
+
+        nRow = aData.mnRow1 - 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::CountVisibleRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nCount = 0;
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mnRow2 > nEndRow)
+            aData.mnRow2 = nEndRow;
+
+        if (!aData.mbValue)
+            nCount += aData.mnRow2 - nRow + 1;
+
+        nRow = aData.mnRow2 + 1;
+    }
+    return nCount;
+}
+
+sal_uInt32 ScTable::GetTotalRowHeight(SCROW nStartRow, SCROW nEndRow)
+{
+    sal_uInt32 nHeight = 0;
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mnRow2 > nEndRow)
+            aData.mnRow2 = nEndRow;
+
+        if (!aData.mbValue)
+            // visible row range.
+            nHeight += pRowHeight->SumValues(nRow, aData.mnRow2);
+
+        nRow = aData.mnRow2 + 1;
+    }
+
+    return nHeight;
+}
+
+SCCOLROW ScTable::LastHiddenColRow(SCCOLROW nPos, bool bCol)
+{
+    if (bCol)
+    {
+        SCCOL nCol = static_cast<SCCOL>(nPos);
+        if (ColHidden(nCol))
+        {
+            for (SCCOL i = nCol+1; i <= MAXCOL; ++i)
+            {
+                if (!ColHidden(nCol))
+                    return nCol - 1;
+            }
+        }
+    }
+    else
+    {
+        SCROW nRow = static_cast<SCROW>(nPos);
+        SCROW nLastRow;
+        if (RowHidden(nRow, NULL, &nLastRow))
+            return static_cast<SCCOLROW>(nLastRow);
+    }
+    return ::std::numeric_limits<SCCOLROW>::max();
+}
+
+bool ScTable::RowFiltered(SCROW nRow, SCROW* pFirstRow, SCROW* pLastRow)
+{
+#if 1
+    if (!ValidRow(nRow))
+        return false;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    if (!mpFilteredRows->getRangeData(nRow, aData))
+        // search failed.
+        return false;
+
+    if (pFirstRow)
+        *pFirstRow = aData.mnRow1;
+    if (pLastRow)
+        *pLastRow = aData.mnRow2;
+
+    return aData.mbValue;
+#else
+    if (pFirstRow)
+        *pFirstRow = nRow;
+    if (pLastRow)
+        *pLastRow = nRow;
+    return (pRowFlags->GetValue(nRow) & CR_FILTERED) == CR_FILTERED;
+#endif
+}
+
+bool ScTable::ColFiltered(SCCOL nCol, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+#if 1
+    if (!ValidCol(nCol))
+        return false;
+
+    ScFlatBoolColSegments::RangeData aData;
+    if (!mpFilteredCols->getRangeData(nCol, aData))
+        // search failed.
+        return false;
+
+    if (pFirstCol)
+        *pFirstCol = aData.mnCol1;
+    if (pLastCol)
+        *pLastCol = aData.mnCol2;
+
+    return aData.mbValue;
+#else
+    if (pFirstCol)
+        *pFirstCol = nCol;
+    if (pLastCol)
+        *pLastCol = nCol;
+    return (pColFlags[nCol] & CR_FILTERED) == CR_FILTERED;
+#endif
+}
+
+bool ScTable::HasFilteredRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = nRow;
+        bool bFiltered = RowFiltered(nRow, NULL, &nLastRow);
+        if (bFiltered)
+            return true;
+
+        nRow = nLastRow + 1;
+    }
+    return false;
+}
+
+void ScTable::CopyColFiltered(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol)
+{
+    SCCOL nCol = nStartCol;
+    while (nCol <= nEndCol)
+    {
+        SCCOL nLastCol;
+        bool bFiltered = rTable.ColFiltered(nCol, NULL, &nLastCol);
+        if (nLastCol > nEndCol)
+            nLastCol = nEndCol;
+
+        SetColFiltered(nCol, nLastCol, bFiltered);
+        nCol = nLastCol + 1;
+    }
+}
+
+void ScTable::CopyRowFiltered(ScTable& rTable, SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = -1;
+        bool bFiltered = rTable.RowFiltered(nRow, NULL, &nLastRow);
+        if (nLastRow > nEndRow)
+            nLastRow = nEndRow;
+        SetRowFiltered(nRow, nLastRow, bFiltered);
+        nRow = nLastRow + 1;
+    }
+}
+
+void ScTable::SetRowFiltered(SCROW nStartRow, SCROW nEndRow, bool bFiltered)
+{
+    if (bFiltered)
+        mpFilteredRows->setTrue(nStartRow, nEndRow);
+    else
+        mpFilteredRows->setFalse(nStartRow, nEndRow);
+
+#if 0
+    // Remove this once the refactoring is complete.
+    if (bFiltered)
+        pRowFlags->OrValue(nStartRow, nEndRow, CR_FILTERED);
+    else
+        pRowFlags->AndValue(nStartRow, nEndRow, ~CR_FILTERED);
+#endif
+}
+
+void ScTable::SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, bool bFiltered)
+{
+    if (bFiltered)
+        mpFilteredCols->setTrue(nStartCol, nEndCol);
+    else
+        mpFilteredCols->setFalse(nStartCol, nEndCol);
+
+#if 0
+    // Remove this once the refactoring is complete.
+    for (SCCOL nCol = nStartCol; nCol <= nEndCol; ++nCol)
+    {
+        if (bFiltered)
+            pColFlags[nCol] |= CR_FILTERED;
+        else
+            pColFlags[nCol] &= ~CR_FILTERED;
+    }
+#endif
+}
+
+SCROW ScTable::FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpFilteredRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // non-filtered row found
+            return nRow;
+
+        nRow = aData.mnRow2 + 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nEndRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow >= nStartRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpFilteredRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // non-filtered row found
+            return nRow;
+
+        nRow = aData.mnRow1 - 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nCount = 0;
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!mpFilteredRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mnRow2 > nEndRow)
+            aData.mnRow2 = nEndRow;
+
+        if (!aData.mbValue)
+            nCount += aData.mnRow2 - nRow + 1;
+
+        nRow = aData.mnRow2 + 1;
+    }
+    return nCount;
+}
+
+namespace {
+
+void lcl_syncFlags(ScFlatBoolColSegments& rColSegments, ScFlatBoolRowSegments& rRowSegments,
+    BYTE* pColFlags, ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags, const BYTE nFlagMask)
 {
     using ::sal::static_int_cast;
 
-    // For now, we only need to sync the manual breaks.
+    pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~nFlagMask));
+    for (SCCOL i = 0; i <= MAXCOL; ++i)
+        pColFlags[i] &= static_int_cast<BYTE>(~nFlagMask);
 
+    {
+        // row hidden flags.
+
+        SCROW nRow = 0;
+        ScFlatBoolRowSegments::RangeData aData;
+        while (nRow <= MAXROW)
+        {
+            if (!rRowSegments.getRangeData(nRow, aData))
+                break;
+
+            if (aData.mbValue)
+                pRowFlags->OrValue(nRow, aData.mnRow2, static_int_cast<BYTE>(nFlagMask));
+
+            nRow = aData.mnRow2 + 1;
+        }
+    }
+
+    {
+        // column hidden flags.
+
+        SCCOL nCol = 0;
+        ScFlatBoolColSegments::RangeData aData;
+        while (nCol <= MAXCOL)
+        {
+            if (!rColSegments.getRangeData(nCol, aData))
+                break;
+
+            if (aData.mbValue)
+            {
+                for (SCCOL i = nCol; i <= aData.mnCol2; ++i)
+                    pColFlags[i] |= nFlagMask;
+            }
+
+            nCol = aData.mnCol2 + 1;
+        }
+    }
+}
+
+}
+
+void ScTable::SyncColRowFlags()
+{
+    using ::sal::static_int_cast;
+
+    // Manual breaks.
     pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~CR_MANUALBREAK));
     for (SCCOL i = 0; i <= MAXCOL; ++i)
         pColFlags[i] &= static_int_cast<BYTE>(~CR_MANUALBREAK);
@@ -439,6 +943,10 @@ void ScTable::SyncColRowFlags()
               itr != itrEnd; ++itr)
             pColFlags[*itr] |= CR_MANUALBREAK;
     }
+
+    // Hidden flags.
+    lcl_syncFlags(*mpHiddenCols, *mpHiddenRows, pColFlags, pRowFlags, CR_HIDDEN);
+    lcl_syncFlags(*mpFilteredCols, *mpFilteredRows, pColFlags, pRowFlags, CR_FILTERED);
 }
 
 void ScTable::SetPageSize( const Size& rSize )
diff --git sc/source/core/tool/chartarr.cxx sc/source/core/tool/chartarr.cxx
index 5445a9d..5951957 100644
--- sc/source/core/tool/chartarr.cxx
+++ sc/source/core/tool/chartarr.cxx
@@ -47,6 +47,9 @@
 #include "cell.hxx"
 #include "docoptio.hxx"
 
+#include <vector>
+
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -166,11 +169,17 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
 
     SCCOL nStrCol = nCol1;		// fuer Beschriftung merken
     SCROW nStrRow = nRow1;
-    // Beschriftungen auch nach HiddenCols finden
-    while ( (pDocument->GetColFlags( nCol1, nTab1) & CR_HIDDEN) != 0 )
-        nCol1++;
-    nRow1 = pDocument->GetRowFlagsArray( nTab1).GetFirstForCondition( nRow1,
-            nRow2, CR_HIDDEN, 0);
+	// Skip hidden columns.
+	// TODO: make use of last column value once implemented.
+	SCCOL nLastCol = -1;
+	while (pDocument->ColHidden(nCol1, nTab1, nLastCol))
+		++nCol1;
+
+	// Skip hidden rows.
+	SCROW nLastRow = -1;
+	if (pDocument->RowHidden(nRow1, nTab1, nLastRow))
+		nRow1 = nLastRow + 1;
+
     // falls alles hidden ist, bleibt die Beschriftung am Anfang
     if ( nCol1 <= nCol2 )
     {
@@ -184,17 +193,33 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
     }
 
     SCSIZE nTotalCols = ( nCol1 <= nCol2 ? nCol2 - nCol1 + 1 : 0 );
-    SCCOL* pCols = new SCCOL[nTotalCols > 0 ? nTotalCols : 1];
-    SCSIZE nColCount = 0;
+	vector<SCCOL> aCols;
+	aCols.reserve(nTotalCols);
     for (SCSIZE i=0; i<nTotalCols; i++)
-        if ((pDocument->GetColFlags(sal::static_int_cast<SCCOL>(nCol1+i),nTab1)&CR_HIDDEN)==0)
-            pCols[nColCount++] = sal::static_int_cast<SCCOL>(nCol1+i);
+	{
+		SCCOL nThisCol = sal::static_int_cast<SCCOL>(nCol1+i);
+		if (!pDocument->ColHidden(nThisCol, nTab1, nLastCol))
+			aCols.push_back(nThisCol);
+	}
+	SCSIZE nColCount = aCols.size();
 
     SCSIZE nTotalRows = ( nRow1 <= nRow2 ? nRow2 - nRow1 + 1 : 0 );
-    SCROW* pRows = new SCROW[nTotalRows > 0 ? nTotalRows : 1];
-    SCSIZE nRowCount = (nTotalRows ?
-            pDocument->GetRowFlagsArray( nTab1).FillArrayForCondition( nRow1,
-                nRow2, CR_HIDDEN, 0, pRows, nTotalRows) : 0);
+	vector<SCROW> aRows;
+	aRows.reserve(nTotalRows);
+	if (nRow1 <= nRow2)
+	{
+		// Get all visible rows between nRow1 and nRow2.
+		SCROW nThisRow = nRow1;
+		while (nThisRow <= nRow2)
+		{
+			if (pDocument->RowHidden(nThisRow, nTab1, nLastRow))
+				nThisRow = nLastRow;
+			else
+				aRows.push_back(nThisRow);
+			++nThisRow;
+		}
+	}
+	SCSIZE nRowCount = aRows.size();
 
     // May happen at least with more than 32k rows.
     if (nColCount > SHRT_MAX || nRowCount > SHRT_MAX)
@@ -208,13 +233,13 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
     {
         bValidData = FALSE;
         nColCount = 1;
-        pCols[0] = nStrCol;
+		aCols.push_back(nStrCol);
     }
     if ( !nRowCount )
     {
         bValidData = FALSE;
         nRowCount = 1;
-        pRows[0] = nStrRow;
+		aRows.push_back(nStrRow);
     }
 
         //
@@ -237,7 +262,7 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
                 {
                     double nVal = DBL_MIN;		// Hack fuer Chart, um leere Zellen zu erkennen
 
-                    pDocument->GetCell( pCols[nCol], pRows[nRow], nTab1, pCell );
+					pDocument->GetCell( aCols[nCol], aRows[nRow], nTab1, pCell );
                     if (pCell)
                     {
                         CellType eType = pCell->GetCellType();
@@ -247,8 +272,8 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
                             if ( bCalcAsShown && nVal != 0.0 )
                             {
                                 sal_uInt32 nFormat;
-                                pDocument->GetNumberFormat( pCols[nCol],
-                                    pRows[nRow], nTab1, nFormat );
+								pDocument->GetNumberFormat( aCols[nCol],
+									aRows[nRow], nTab1, nFormat );
                                 nVal = pDocument->RoundValueAsShown( nVal, nFormat );
                             }
                         }
@@ -280,13 +305,13 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
         {
             String aString, aColStr;
             if (HasColHeaders())
-                pDocument->GetString( pCols[nCol], nStrRow, nTab1, aString );
+				pDocument->GetString( aCols[nCol], nStrRow, nTab1, aString );
             if ( !aString.Len() )
             {
                 aString = ScGlobal::GetRscString(STR_COLUMN);
                 aString += ' ';
 //                aString += String::CreateFromInt32( pCols[nCol]+1 );
-                ScAddress aPos( pCols[ nCol ], 0, 0 );
+                ScAddress aPos( aCols[ nCol ], 0, 0 );
                 aPos.Format( aColStr, SCA_VALID_COL, NULL );
                 aString += aColStr;
             }
@@ -306,14 +331,14 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
             String aString;
             if (HasRowHeaders())
             {
-                ScAddress aAddr( nStrCol, pRows[nRow], nTab1 );
-                pDocument->GetString( nStrCol, pRows[nRow], nTab1, aString );
+				ScAddress aAddr( nStrCol, aRows[nRow], nTab1 );
+				pDocument->GetString( nStrCol, aRows[nRow], nTab1, aString );
             }
             if ( !aString.Len() )
             {
                 aString = ScGlobal::GetRscString(STR_ROW);
                 aString += ' ';
-                aString += String::CreateFromInt32( pRows[nRow]+1 );
+				aString += String::CreateFromInt32( aRows[nRow]+1 );
             }
             pMemChart->SetRowText( static_cast<short>(nRow), aString);
 
@@ -349,11 +374,6 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
 //        SetExtraStrings( *pMemChart );
     }
 
-        //	Aufraeumen
-
-    delete[] pRows;
-    delete[] pCols;
-
     return pMemChart;
 }
 
diff --git sc/source/filter/excel/colrowst.cxx sc/source/filter/excel/colrowst.cxx
index 174ab20..45d3c9e 100644
--- sc/source/filter/excel/colrowst.cxx
+++ sc/source/filter/excel/colrowst.cxx
@@ -309,7 +309,7 @@ void XclImpColRowSettings::ConvertHiddenFlags( SCTAB nScTab )
             rDoc.ShowRow( nScRow, nScTab, FALSE );
             // #i38093# rows hidden by filter need extra flag
             if( (nFirstFilterScRow <= nScRow) && (nScRow <= nLastFilterScRow) )
-                rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_FILTERED );
+                rDoc.SetRowFiltered(nScRow, nScRow, nScTab, true);
         }
     }
 
diff --git sc/source/filter/excel/xetable.cxx sc/source/filter/excel/xetable.cxx
index 2aef64c..2816daf 100644
--- sc/source/filter/excel/xetable.cxx
+++ sc/source/filter/excel/xetable.cxx
@@ -1604,8 +1604,7 @@ XclExpColinfo::XclExpColinfo( const XclExpRoot& rRoot,
     mnWidth = XclTools::GetXclColumnWidth( nScWidth, GetCharWidth() );
 
     // column flags
-    BYTE nScColFlags = rDoc.GetColFlags( nScCol, nScTab );
-    ::set_flag( mnFlags, EXC_COLINFO_HIDDEN, (nScColFlags & CR_HIDDEN) != 0 );
+    ::set_flag( mnFlags, EXC_COLINFO_HIDDEN, rDoc.ColHidden(nScCol, nScTab) );
 
     // outline data
     rOutlineBfr.Update( nScCol );
@@ -1830,7 +1829,7 @@ XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
 
     BYTE nRowFlags = GetDoc().GetRowFlags( nScRow, nScTab );
     bool bUserHeight = ::get_flag< BYTE >( nRowFlags, CR_MANUALSIZE );
-    bool bHidden = ::get_flag< BYTE >( nRowFlags, CR_HIDDEN );
+    bool bHidden = GetDoc().RowHidden(nScRow, nScTab);
     ::set_flag( mnFlags, EXC_ROW_UNSYNCED, bUserHeight );
     ::set_flag( mnFlags, EXC_ROW_HIDDEN, bHidden );
 
diff --git sc/source/filter/excel/xlescher.cxx sc/source/filter/excel/xlescher.cxx
index bea2ed1..98312a2 100644
--- sc/source/filter/excel/xlescher.cxx
+++ sc/source/filter/excel/xlescher.cxx
@@ -136,21 +136,20 @@ void lclGetRowFromY(
     // rnStartH in conjunction with nXclStartRow is used as buffer for previously calculated height
     long nTwipsY = static_cast< long >( nY / fScale + 0.5 );
     long nRowH = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            rDoc.GetRowFlagsArray( nScTab), static_cast<SCROW>(nXclStartRow),
-            MAXROW, CR_HIDDEN, 0, rDoc.GetRowHeightArray( nScTab));
-    for ( ; aIter; ++aIter )
+    bool bFound = false;
+    for (SCROW nRow = static_cast<SCROW>(nXclStartRow); nRow <= MAXROW; ++nRow)
     {
-        nRowH = *aIter;
+        nRowH = rDoc.GetRowHeight(nRow, nScTab);
         if( rnStartH + nRowH > nTwipsY )
         {
-            rnXclRow = static_cast< sal_uInt16 >( aIter.GetPos() );
+            rnXclRow = static_cast< sal_uInt16 >(nRow);
+            bFound = true;
             break;
         }
         rnStartH += nRowH;
     }
-    if (!aIter)
-        rnXclRow = static_cast< sal_uInt16 >( aIter.GetIterEnd() );  // down to the bottom..
+    if (!bFound)
+        rnXclRow = static_cast<sal_uInt16>(MAXROW);
     rnOffset = static_cast< sal_uInt16 >( nRowH ? ((nTwipsY - rnStartH) * 256.0 / nRowH + 0.5) : 0 );
 }
 
diff --git sc/source/filter/html/htmlexp.cxx sc/source/filter/html/htmlexp.cxx
index ecb2b2a..9698b9d 100644
--- sc/source/filter/html/htmlexp.cxx
+++ sc/source/filter/html/htmlexp.cxx
@@ -749,7 +749,7 @@ void ScHTMLExport::WriteTables()
         SCCOL nCol;
         for ( nCol=nStartCol; nCol<=nEndCol; nCol++ )
         {
-            if ( !(pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) )
+			if ( !pDoc->ColHidden(nCol, nTab) )
                 ++nColCnt;
         }
         (((aByteStrOut += ' ') += OOO_STRING_SVTOOLS_HTML_O_cols) += '=') += ByteString::CreateFromInt32( nColCnt );
@@ -770,7 +770,7 @@ void ScHTMLExport::WriteTables()
         aByteStr += '=';
         for ( nCol=nStartCol; nCol<=nEndCol; nCol++ )
         {
-            if ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN )
+			if ( pDoc->ColHidden(nCol, nTab) )
                 continue;	// for
 
             aByteStrOut  = aByteStr;
@@ -785,14 +785,12 @@ void ScHTMLExport::WriteTables()
         // At least old (3.x, 4.x?) Netscape doesn't follow <TABLE COLS=n> and
         // <COL WIDTH=x> specified, but needs a width at every column.
         bTableDataWidth = TRUE;     // widths in first row
-        bool bHasHiddenRows = pDoc->GetRowFlagsArray( nTab).HasCondition(
-                nStartRow, nEndRow, CR_HIDDEN, CR_HIDDEN);
+		bool bHasHiddenRows = pDoc->HasHiddenRows(nStartRow, nEndRow, nTab);
         for ( SCROW nRow=nStartRow; nRow<=nEndRow; nRow++ )
         {
-            if ( bHasHiddenRows && (pDoc->GetRowFlags( nRow, nTab ) & CR_HIDDEN) )
+			if ( bHasHiddenRows && pDoc->RowHidden(nRow, nTab) )
             {
-                nRow = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition(
-                        nRow+1, nEndRow, CR_HIDDEN, 0);
+                nRow = pDoc->FirstVisibleRow(nRow+1, nEndRow, nTab);
                 --nRow;
                 continue;	// for
             }
@@ -801,7 +799,7 @@ void ScHTMLExport::WriteTables()
             bTableDataHeight = TRUE;  // height at every first cell of each row
             for ( SCCOL nCol2=nStartCol; nCol2<=nEndCol; nCol2++ )
             {
-                if ( pDoc->GetColFlags( nCol2, nTab ) & CR_HIDDEN )
+				if ( pDoc->ColHidden(nCol2, nTab) )
                     continue;	// for
 
                 if ( nCol2 == nEndCol )
diff --git sc/source/filter/lotus/lotimpop.cxx sc/source/filter/lotus/lotimpop.cxx
index 17a48cb..8d887b0 100644
--- sc/source/filter/lotus/lotimpop.cxx
+++ sc/source/filter/lotus/lotimpop.cxx
@@ -183,8 +183,7 @@ void ImportLotus::Hiddencolumn( UINT16 nRecLen )
         {
             Read( nCol );
 
-            pD->SetColFlags( static_cast<SCCOL> (nCol), static_cast<SCTAB> (nLTab), pD->GetColFlags( static_cast<SCCOL> (nCol), static_cast<SCTAB> (nLTab) ) | CR_HIDDEN );
-
+            pD->SetColHidden(static_cast<SCCOL>(nCol), static_cast<SCCOL>(nCol), static_cast<SCTAB>(nLTab), true);
             nCnt--;
         }
     }
diff --git sc/source/filter/lotus/op.cxx sc/source/filter/lotus/op.cxx
index 028993b..eb7d043 100644
--- sc/source/filter/lotus/op.cxx
+++ sc/source/filter/lotus/op.cxx
@@ -229,7 +229,7 @@ void OP_ColumnWidth( SvStream& r, UINT16 /*n*/ )
         nBreite = ( UINT16 ) ( TWIPS_PER_CHAR * nWidthSpaces );
     else
     {
-        pDoc->SetColFlags( static_cast<SCCOL> (nCol), 0, pDoc->GetColFlags( static_cast<SCCOL> (nCol), 0 ) | CR_HIDDEN );
+        pDoc->SetColHidden(static_cast<SCCOL>(nCol), static_cast<SCCOL>(nCol), 0, true);
         nBreite = nDefWidth;
     }
 
@@ -338,7 +338,7 @@ void OP_HiddenCols( SvStream& r, UINT16 /*n*/ )
         {
             if( nAkt & 0x01 )   // unterstes Bit gesetzt?
                 // -> Hidden Col
-                pDoc->SetColFlags( nCount, 0, pDoc->GetColFlags( nCount, 0 ) | CR_HIDDEN );
+                pDoc->SetColHidden(nCount, nCount, 0, true);
 
             nCount++;
             nAkt = nAkt / 2;    // der Naechste bitte...
diff --git sc/source/filter/rtf/expbase.cxx sc/source/filter/rtf/expbase.cxx
index 2c2cf22..98aef5e 100644
--- sc/source/filter/rtf/expbase.cxx
+++ sc/source/filter/rtf/expbase.cxx
@@ -78,16 +78,13 @@ BOOL ScExportBase::GetDataArea( SCTAB nTab, SCCOL& nStartCol,
 BOOL ScExportBase::TrimDataArea( SCTAB nTab, SCCOL& nStartCol,
             SCROW& nStartRow, SCCOL& nEndCol, SCROW& nEndRow ) const
 {
-    while ( nStartCol <= nEndCol &&
-            pDoc->GetColFlags( nStartCol, nTab ) & CR_HIDDEN )
+    SCCOL nLastCol;
+	while ( nStartCol <= nEndCol && pDoc->ColHidden(nStartCol, nTab, nLastCol))
         ++nStartCol;
-    while ( nStartCol <= nEndCol &&
-            pDoc->GetColFlags( nEndCol, nTab ) & CR_HIDDEN )
+	while ( nStartCol <= nEndCol && pDoc->ColHidden(nEndCol, nTab, nLastCol))
         --nEndCol;
-    nStartRow = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0);
-    nEndRow = pDoc->GetRowFlagsArray( nTab).GetLastForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0);
+    nStartRow = pDoc->FirstVisibleRow(nStartRow, nEndRow, nTab);
+    nEndRow = pDoc->LastVisibleRow(nStartRow, nEndRow, nTab);
     return nStartCol <= nEndCol && nStartRow <= nEndRow && nEndRow !=
         ::std::numeric_limits<SCROW>::max();
 }
diff --git sc/source/filter/starcalc/scflt.cxx sc/source/filter/starcalc/scflt.cxx
index 8c98903..a456235 100644
--- sc/source/filter/starcalc/scflt.cxx
+++ sc/source/filter/starcalc/scflt.cxx
@@ -1551,14 +1551,12 @@ void Sc10Import::LoadTables()
             rStream >> DataValue;
             if (DataValue != 0)
             {
-                BYTE nFlags = 0;
 				bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
 				bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
-                if ((DataValue & crfHidden) == crfHidden)
-                    nFlags |= CR_HIDDEN;
+				bool bHidden = ((DataValue & crfHidden) == crfHidden);
 				for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++) 
-                {    
-                    pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+                {
+					pDoc->SetColHidden(k, k, static_cast<SCTAB>(TabNo), bHidden);
                     pDoc->SetColBreak(k, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
                 }
             }
@@ -1603,14 +1601,12 @@ void Sc10Import::LoadTables()
             rStream >> DataValue;
             if (DataValue != 0)
             {
-                BYTE nFlags = 0;
 				bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
 				bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
-                if ((DataValue & crfHidden) == crfHidden)
-                    nFlags |= CR_HIDDEN;
+                bool bHidden      = ((DataValue & crfHidden) == crfHidden);
                 for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++) 
                 {    
-                    pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetRowHidden(l, l, static_cast<SCTAB> (TabNo), bHidden);
                     pDoc->SetRowBreak(l, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
                 }
             }
diff --git sc/source/ui/Accessibility/AccessibleCellBase.cxx sc/source/ui/Accessibility/AccessibleCellBase.cxx
index d112ea0..046b4ce 100644
--- sc/source/ui/Accessibility/AccessibleCellBase.cxx
+++ sc/source/ui/Accessibility/AccessibleCellBase.cxx
@@ -95,10 +95,12 @@ sal_Bool SAL_CALL ScAccessibleCellBase::isVisible(  )
     sal_Bool bVisible(sal_True);
     if (mpDoc)
     {
-        BYTE nColFlags = mpDoc->GetColFlags(maCellAddress.Col(), maCellAddress.Tab());
-        BYTE nRowFlags = mpDoc->GetRowFlags(maCellAddress.Row(), maCellAddress.Tab());
-        if (((nColFlags & CR_HIDDEN) == CR_HIDDEN) || ((nColFlags & CR_FILTERED) == CR_FILTERED) ||
-            ((nRowFlags & CR_HIDDEN) == CR_HIDDEN) || ((nRowFlags & CR_FILTERED) == CR_FILTERED))
+        bool bColHidden = mpDoc->ColHidden(maCellAddress.Col(), maCellAddress.Tab());
+        bool bRowHidden = mpDoc->RowHidden(maCellAddress.Row(), maCellAddress.Tab());
+        bool bColFiltered = mpDoc->ColFiltered(maCellAddress.Col(), maCellAddress.Tab());
+        bool bRowFiltered = mpDoc->RowFiltered(maCellAddress.Row(), maCellAddress.Tab());
+
+        if (bColHidden || bColFiltered || bRowHidden || bRowFiltered)
             bVisible = sal_False;
     }
     return bVisible;
diff --git sc/source/ui/app/inputwin.cxx sc/source/ui/app/inputwin.cxx
index 80625f0..754e110 100644
--- sc/source/ui/app/inputwin.cxx
+++ sc/source/ui/app/inputwin.cxx
@@ -294,7 +294,7 @@ sal_Bool ScInputWindow::UseSubTotal(ScRangeList* pRangeList) const
                     SCROW nRow(pRange->aStart.Row());
                     while (!bSubTotal && nRow <= nRowEnd)
                     {
-                        if (pDoc->IsFiltered(nRow, nTab))
+                        if (pDoc->RowFiltered(nRow, nTab))
                             bSubTotal = sal_True;
                         else
                             ++nRow;
diff --git sc/source/ui/app/transobj.cxx sc/source/ui/app/transobj.cxx
index b35d177..87f888c 100644
--- sc/source/ui/app/transobj.cxx
+++ sc/source/ui/app/transobj.cxx
@@ -605,25 +605,24 @@ void ScTransferObj::InitDocShell()
         //	widths / heights
         //	(must be copied before CopyFromClip, for drawing objects)
 
-        SCCOL nCol;
+		SCCOL nCol, nLastCol;
         SCROW nRow;
         SCTAB nSrcTab = aBlock.aStart.Tab();
         pDestDoc->SetLayoutRTL(0, pDoc->IsLayoutRTL(nSrcTab));
         for (nCol=nStartX; nCol<=nEndX; nCol++)
-            if ( pDoc->GetColFlags( nCol, nSrcTab ) & CR_HIDDEN )
+			if ( pDoc->ColHidden(nCol, nSrcTab, nLastCol) )
                 pDestDoc->ShowCol( nCol, 0, FALSE );
             else
                 pDestDoc->SetColWidth( nCol, 0, pDoc->GetColWidth( nCol, nSrcTab ) );
 
         ScBitMaskCompressedArray< SCROW, BYTE> & rDestRowFlags =
             pDestDoc->GetRowFlagsArrayModifiable(0);
-        ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray(
-                    nSrcTab), nStartY, nEndY);
-        for ( ; aIter; ++aIter )
+
+		for (SCROW nRow = nStartY; nRow <= nEndY; ++nRow)
         {
-            nRow = aIter.GetPos();
-            BYTE nSourceFlags = *aIter;
-            if ( nSourceFlags & CR_HIDDEN )
+            BYTE nSourceFlags = pDoc->GetRowFlags(nRow, nSrcTab);
+            SCROW nLastRow = -1;
+            if ( pDoc->RowHidden(nRow, nSrcTab, nLastRow) )
                 pDestDoc->ShowRow( nRow, 0, FALSE );
             else
             {
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index bb7cdef..6dbec45 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -2980,7 +2980,9 @@ BOOL ScDocFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRa
                     for (SCROW nRow=nStartNo; nRow<=nEndNo; nRow++)
                     {
                         BYTE nOld = pDoc->GetRowFlags(nRow,nTab);
-                        if ( (nOld & CR_HIDDEN) == 0 && ( nOld & CR_MANUALSIZE ) )
+						SCROW nLastRow = -1;
+						bool bHidden = pDoc->RowHidden(nRow, nTab, nLastRow);
+						if ( !bHidden && ( nOld & CR_MANUALSIZE ) )
                             pDoc->SetRowFlags( nRow, nTab, nOld & ~CR_MANUALSIZE );
                     }
                 }
@@ -3015,8 +3017,8 @@ BOOL ScDocFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRa
         {
             for (SCCOL nCol=static_cast<SCCOL>(nStartNo); nCol<=static_cast<SCCOL>(nEndNo); nCol++)
             {
-                if ( eMode != SC_SIZE_VISOPT ||
-                     (pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) == 0 )
+                SCCOL nLastCol = -1;
+                if ( eMode != SC_SIZE_VISOPT || !pDoc->ColHidden(nCol, nTab, nLastCol) )
                 {
                     USHORT nThisSize = nSizeTwips;
 
diff --git sc/source/ui/docshell/impex.cxx sc/source/ui/docshell/impex.cxx
index 08dfcfb..6df6637 100644
--- sc/source/ui/docshell/impex.cxx
+++ sc/source/ui/docshell/impex.cxx
@@ -1444,7 +1444,7 @@ BOOL ScImportExport::Doc2Text( SvStream& rStrm )
 
     for (nRow = nStartRow; nRow <= nEndRow; nRow++)
     {
-        if (bIncludeFiltered || !pDoc->IsFiltered( nRow, aRange.aStart.Tab() ))
+		if (bIncludeFiltered || !pDoc->RowFiltered( nRow, aRange.aStart.Tab() ))
         {
             for (nCol = nStartCol; nCol <= nEndCol; nCol++)
             {
diff --git sc/source/ui/docshell/olinefun.cxx sc/source/ui/docshell/olinefun.cxx
index 01b4f9a..fd120a8 100644
--- sc/source/ui/docshell/olinefun.cxx
+++ sc/source/ui/docshell/olinefun.cxx
@@ -411,7 +411,7 @@ BOOL ScOutlineDocFunc::SelectLevel( SCTAB nTab, BOOL bColumns, USHORT nLevel,
             if ( bColumns )
                 pDoc->ShowCol( static_cast<SCCOL>(i), nTab, bShow );
             else
-                if ( !bShow || !pDoc->IsFiltered( i,nTab ) )
+				if ( !bShow || !pDoc->RowFiltered( i,nTab ) )
                     pDoc->ShowRow( i, nTab, bShow );
         }
     }
@@ -509,7 +509,7 @@ BOOL ScOutlineDocFunc::ShowMarkedOutlines( const ScRange& rRange, BOOL bRecord,
             }
         }
         for ( i=nMin; i<=nMax; i++ )
-            if ( !pDoc->IsFiltered( i,nTab ) )				// weggefilterte nicht einblenden
+			if ( !pDoc->RowFiltered( i,nTab ) )				// weggefilterte nicht einblenden
                 pDoc->ShowRow( i, nTab, TRUE );
 
         pDoc->UpdatePageBreaks( nTab );
@@ -669,7 +669,7 @@ BOOL ScOutlineDocFunc::ShowOutline( SCTAB nTab, BOOL bColumns, USHORT nLevel, US
         if ( bColumns )
             pDoc->ShowCol( static_cast<SCCOL>(i), nTab, TRUE );
         else
-            if ( !pDoc->IsFiltered( i,nTab ) )				// weggefilterte nicht einblenden
+			if ( !pDoc->RowFiltered( i,nTab ) )				// weggefilterte nicht einblenden
                 pDoc->ShowRow( i, nTab, TRUE );
     }
 
diff --git sc/source/ui/inc/viewutil.hxx sc/source/ui/inc/viewutil.hxx
index 55f0039..18b4d68 100644
--- sc/source/ui/inc/viewutil.hxx
+++ sc/source/ui/inc/viewutil.hxx
@@ -71,10 +71,10 @@ public:
 
     static sal_Int32 GetTransliterationType( USHORT nSlotID );
 
-    static bool HasFiltered( const ScRange& rRange, const ScDocument* pDoc );
+    static bool HasFiltered( const ScRange& rRange, ScDocument* pDoc );
     /** Fit a range to cover nRows number of unfiltered rows.
         @return <TRUE/> if the resulting range covers nRows unfiltered rows. */
-    static bool FitToUnfilteredRows( ScRange & rRange, const ScDocument * pDoc, size_t nRows );
+    static bool FitToUnfilteredRows( ScRange & rRange, ScDocument * pDoc, size_t nRows );
     static void UnmarkFiltered( ScMarkData& rMark, ScDocument* pDoc );
 
     static void HideDisabledSlot( SfxItemSet& rSet, SfxBindings& rBindings, USHORT nSlotId );
diff --git sc/source/ui/undo/undoblk.cxx sc/source/ui/undo/undoblk.cxx
index f92adea..002aa14 100644
--- sc/source/ui/undo/undoblk.cxx
+++ sc/source/ui/undo/undoblk.cxx
@@ -1152,10 +1152,10 @@ ScUndoDragDrop::ScUndoDragDrop( ScDocShell* pNewDocShell,
     BOOL bIncludeFiltered = bCut;
     if ( !bIncludeFiltered )
     {
-        //	manually find number of non-filtered rows
-        SCROW nPastedCount = pDocShell->GetDocument()->GetRowFlagsArray(
-                aSrcRange.aStart.Tab()).CountForCondition(
-                aSrcRange.aStart.Row(), aSrcRange.aEnd.Row(), CR_FILTERED, 0);
+        // find number of non-filtered rows
+        SCROW nPastedCount = pDocShell->GetDocument()->CountNonFilteredRows(
+            aSrcRange.aStart.Row(), aSrcRange.aEnd.Row(), aSrcRange.aStart.Tab());
+
         if ( nPastedCount == 0 )
             nPastedCount = 1;
         aDestEnd.SetRow( aNewDestPos.Row() + nPastedCount - 1 );
diff --git sc/source/ui/undo/undoblk3.cxx sc/source/ui/undo/undoblk3.cxx
index c6dba05..cb6f62c 100644
--- sc/source/ui/undo/undoblk3.cxx
+++ sc/source/ui/undo/undoblk3.cxx
@@ -1082,17 +1082,20 @@ void __EXPORT ScUndoAutoFormat::Redo()
             aDestMark.MarkToMulti();
 
             // wie SC_SIZE_VISOPT
+            SCROW nLastRow = -1;
             for (SCROW nRow=nStartY; nRow<=nEndY; nRow++)
             {
                 BYTE nOld = pDoc->GetRowFlags(nRow,nTab);
-                if ( (nOld & CR_HIDDEN) == 0 && ( nOld & CR_MANUALSIZE ) )
+                bool bHidden = pDoc->RowHidden(nRow, nTab, nLastRow);
+				if ( !bHidden && ( nOld & CR_MANUALSIZE ) )
                     pDoc->SetRowFlags( nRow, nTab, nOld & ~CR_MANUALSIZE );
             }
             pDoc->SetOptimalHeight( nStartY, nEndY, nTab, 0, &aVirtDev,
                                         nPPTX, nPPTY, aZoomX, aZoomY, FALSE );
 
+            SCCOL nLastCol = -1;
             for (SCCOL nCol=nStartX; nCol<=nEndX; nCol++)
-                if ((pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) == 0)
+                if (!pDoc->ColHidden(nCol, nTab, nLastCol))
                 {
                     USHORT nThisSize = STD_EXTRA_WIDTH + pDoc->GetOptimalColWidth( nCol, nTab,
                                                 &aVirtDev, nPPTX, nPPTY, aZoomX, aZoomY, bFormula,
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index 520a788..37eb67c 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -3379,18 +3379,25 @@ uno::Reference<sheet::XSheetCellRanges> SAL_CALL ScCellRangesBase::queryVisibleC
         ScMarkData aMarkData(*GetMarkData());
 
         ScDocument* pDoc = pDocShell->GetDocument();
-        for (SCCOL nCol=0; nCol<=MAXCOL; nCol++)
-            if (pDoc->GetColFlags(nCol,nTab) & CR_HIDDEN)
-                aMarkData.SetMultiMarkArea( ScRange( nCol,0,nTab, nCol,MAXROW,nTab ), FALSE );
-
-        //!	nur bis zur letzten selektierten Zeile testen?
-        ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray( nTab), 0, MAXROW);
-        do
-        {
-            if (*aIter & CR_HIDDEN)
-                aMarkData.SetMultiMarkArea( ScRange( 0, aIter.GetRangeStart(),
-                            nTab, MAXCOL, aIter.GetRangeEnd(), nTab ), FALSE );
-        } while (aIter.NextRange());
+		SCCOL nCol = 0, nLastCol;
+		while (nCol <= MAXCOL)
+		{
+			if (pDoc->ColHidden(nCol, nTab, nLastCol))
+				// hidden columns.  Unselect them.
+				aMarkData.SetMultiMarkArea(ScRange(nCol, 0, nTab, nLastCol, MAXROW, nTab), false);
+
+			nCol = nLastCol + 1;
+		}
+
+		SCROW nRow = 0, nLastRow;
+		while (nRow <= MAXROW)
+		{
+			if (pDoc->RowHidden(nRow, nTab, nLastRow))
+				// These rows are hidden.  Unselect them.
+				aMarkData.SetMultiMarkArea(ScRange(0, nRow, nTab, MAXCOL, nLastRow, nTab), false);
+
+			nRow = nLastRow + 1;
+		}
 
         ScRangeList aNewRanges;
         aMarkData.FillRangeListWithMarks( &aNewRanges, FALSE );
@@ -8882,8 +8889,9 @@ void ScTableColumnObj::GetOnePropertyValue( const SfxItemPropertySimpleEntry* pE
         }
         else if ( pEntry->nWID == SC_WID_UNO_CELLVIS )
         {
-            BOOL bVis = !(pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN);
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bVis );
+			SCCOL nDummy;
+			bool bHidden = pDoc->ColHidden(nCol, nTab, nDummy);
+			ScUnoHelpFunctions::SetBoolInAny( rAny, !bHidden );
         }
         else if ( pEntry->nWID == SC_WID_UNO_OWIDTH )
         {
@@ -8985,12 +8993,7 @@ void ScTableRowObj::SetOnePropertyValue( const SfxItemPropertySimpleEntry* pEntr
 //			ScSizeMode eMode = bVis ? SC_SIZE_SHOW : SC_SIZE_DIRECT;
 //			aFunc.SetWidthOrHeight( FALSE, 1, nRowArr, nTab, eMode, 0, TRUE, TRUE );
             //	SC_SIZE_DIRECT mit Groesse 0 blendet aus
-            BYTE nFlags = pDoc->GetRowFlags(nRow, nTab);
-            if (bFil)
-                nFlags |= CR_FILTERED;
-            else
-                nFlags &= ~CR_FILTERED;
-            pDoc->SetRowFlags(nRow, nTab, nFlags);
+            pDoc->SetRowFiltered(nRow, nRow, nTab, bFil);
         }
         else if ( pEntry->nWID == SC_WID_UNO_OHEIGHT )
         {
@@ -9042,12 +9045,13 @@ void ScTableRowObj::GetOnePropertyValue( const SfxItemPropertySimpleEntry* pEntr
         }
         else if ( pEntry->nWID == SC_WID_UNO_CELLVIS )
         {
-            BOOL bVis = !(pDoc->GetRowFlags( nRow, nTab ) & CR_HIDDEN);
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bVis );
+            SCROW nDummy;
+            bool bHidden = pDoc->RowHidden(nRow, nTab, nDummy);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, !bHidden );
         }
         else if ( pEntry->nWID == SC_WID_UNO_CELLFILT )
         {
-            BOOL bVis = ((pDoc->GetRowFlags( nRow, nTab ) & CR_FILTERED) != 0);
+            bool bVis = pDoc->RowFiltered(nRow, nTab);
             ScUnoHelpFunctions::SetBoolInAny( rAny, bVis );
         }
         else if ( pEntry->nWID == SC_WID_UNO_OHEIGHT )
diff --git sc/source/ui/unoobj/chart2uno.cxx sc/source/ui/unoobj/chart2uno.cxx
index 7c1cfc6..174d213 100644
--- sc/source/ui/unoobj/chart2uno.cxx
+++ sc/source/ui/unoobj/chart2uno.cxx
@@ -2840,14 +2840,17 @@ void ScChart2DataSequence::BuildDataCache()
             if (!ScRefTokenHelper::getRangeFromToken(aRange, *itr))
                 continue;
 
+            SCCOL nLastCol = -1;
+            SCROW nLastRow = -1;
             for (SCTAB nTab = aRange.aStart.Tab(); nTab <= aRange.aEnd.Tab(); ++nTab)
             {
                 for (SCCOL nCol = aRange.aStart.Col(); nCol <= aRange.aEnd.Col(); ++nCol)
                 {
                     for (SCROW nRow = aRange.aStart.Row(); nRow <= aRange.aEnd.Row(); ++nRow)
                     {
-                        bool bColHidden = (m_pDocument->GetColFlags(nCol, nTab) & CR_HIDDEN);
-                        bool bRowHidden = (m_pDocument->GetRowFlags(nRow, nTab) & CR_HIDDEN);
+                        bool bColHidden = m_pDocument->ColHidden(nCol, nTab, nLastCol);
+                        bool bRowHidden = m_pDocument->RowHidden(nRow, nTab, nLastRow);
+
                         if (bColHidden || bRowHidden)
                         {
                             // hidden cell
diff --git sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
index 5c4113b..5b4a50b 100644
--- sc/source/ui/unoobj/docuno.cxx
+++ sc/source/ui/unoobj/docuno.cxx
@@ -2613,7 +2613,8 @@ uno::Any SAL_CALL ScTableColumnsObj::getPropertyValue( const rtl::OUString& aPro
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLVIS ) )
     {
-        BOOL bVis = !(pDoc->GetColFlags( nStartCol, nTab ) & CR_HIDDEN);
+        SCCOL nLastCol;
+        bool bVis = !pDoc->ColHidden(nStartCol, nTab, nLastCol);
         ScUnoHelpFunctions::SetBoolInAny( aAny, bVis );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_OWIDTH ) )
@@ -2821,9 +2822,9 @@ void SAL_CALL ScTableRowsObj::setPropertyValue(
     {
         //!	undo etc.
         if (ScUnoHelpFunctions::GetBoolFromAny( aValue ))
-            pDoc->GetRowFlagsArrayModifiable( nTab).OrValue( nStartRow, nEndRow, CR_FILTERED);
+            pDoc->SetRowFiltered(nStartRow, nEndRow, nTab, true);
         else
-            pDoc->GetRowFlagsArrayModifiable( nTab).AndValue( nStartRow, nEndRow, sal::static_int_cast<BYTE>(~CR_FILTERED) );
+            pDoc->SetRowFiltered(nStartRow, nEndRow, nTab, false);
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE) || aNameString.EqualsAscii( SC_UNONAME_MANPAGE) )
     {
@@ -2871,12 +2872,13 @@ uno::Any SAL_CALL ScTableRowsObj::getPropertyValue( const rtl::OUString& aProper
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLVIS ) )
     {
-        BOOL bVis = !(pDoc->GetRowFlags( nStartRow, nTab ) & CR_HIDDEN);
+        SCROW nLastRow;
+        bool bVis = !pDoc->RowHidden(nStartRow, nTab, nLastRow);
         ScUnoHelpFunctions::SetBoolInAny( aAny, bVis );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLFILT ) )
     {
-        BOOL bVis = ((pDoc->GetRowFlags( nStartRow, nTab ) & CR_FILTERED) != 0);
+        bool bVis = pDoc->RowFiltered(nStartRow, nTab);
         ScUnoHelpFunctions::SetBoolInAny( aAny, bVis );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_OHEIGHT ) )
diff --git sc/source/ui/view/colrowba.cxx sc/source/ui/view/colrowba.cxx
index ecd0a37..e7613c1 100644
--- sc/source/ui/view/colrowba.cxx
+++ sc/source/ui/view/colrowba.cxx
@@ -101,7 +101,8 @@ USHORT ScColBar::GetEntrySize( SCCOLROW nEntryNo )
 {
     ScDocument* pDoc = pViewData->GetDocument();
     SCTAB nTab = pViewData->GetTabNo();
-    if ( pDoc->GetColFlags( static_cast<SCCOL>(nEntryNo), nTab ) & CR_HIDDEN )
+	SCCOL nLastCol = -1;
+	if (pDoc->ColHidden(static_cast<SCCOL>(nEntryNo), nTab, nLastCol))
         return 0;
     else
         return (USHORT) ScViewData::ToPixel( pDoc->GetColWidth( static_cast<SCCOL>(nEntryNo), nTab ), pViewData->GetPPTX() );
@@ -267,7 +268,8 @@ USHORT ScRowBar::GetEntrySize( SCCOLROW nEntryNo )
 {
     ScDocument* pDoc = pViewData->GetDocument();
     SCTAB nTab = pViewData->GetTabNo();
-    if ( pDoc->GetRowFlags( nEntryNo, nTab ) & CR_HIDDEN )
+	SCROW nLastRow = -1;
+	if (pDoc->RowHidden(nEntryNo, nTab, nLastRow))
         return 0;
     else
         return (USHORT) ScViewData::ToPixel( pDoc->GetOriginalHeight( nEntryNo,
diff --git sc/source/ui/view/drawutil.cxx sc/source/ui/view/drawutil.cxx
index 48b03b5..ddb2f06 100644
--- sc/source/ui/view/drawutil.cxx
+++ sc/source/ui/view/drawutil.cxx
@@ -69,14 +69,19 @@ void ScDrawUtil::CalcScale( ScDocument* pDoc, SCTAB nTab,
         nTwipsX += (long) nWidth;
         nPixelX += ScViewData::ToPixel( nWidth, nPPTX );
     }
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            pDoc->GetRowFlagsArray( nTab), nStartRow, nEndRow-1, CR_HIDDEN, 0,
-            pDoc->GetRowHeightArray( nTab));
-    for ( ; aIter; ++aIter )
+
+    for (SCROW nRow = nStartRow; nRow <= nEndRow-1; ++nRow)
     {
-        USHORT nHeight = *aIter;
-        nTwipsY += (long) nHeight;
-        nPixelY += ScViewData::ToPixel( nHeight, nPPTY );
+        SCROW nLastRow = nRow;
+        if (pDoc->RowHidden(nRow, nTab, NULL, &nLastRow))
+        {    
+            nRow = nLastRow;
+            continue;
+        }
+
+        USHORT nHeight = pDoc->GetRowHeight(nRow, nTab);
+        nTwipsY += static_cast<long>(nHeight);
+        nPixelY += ScViewData::ToPixel(nHeight, nPPTY);
     }
 
     MapMode aHMMMode( MAP_100TH_MM, Point(), rZoomX, rZoomY );
diff --git sc/source/ui/view/gridwin.cxx sc/source/ui/view/gridwin.cxx
index ac4d80f..e591f86 100644
--- sc/source/ui/view/gridwin.cxx
+++ sc/source/ui/view/gridwin.cxx
@@ -4601,18 +4601,17 @@ void lcl_PaintOneRange( ScDocShell* pDocSh, const ScRange& rRange, USHORT nEdges
     SCROW nTmp;
 
     ScDocument* pDoc = pDocSh->GetDocument();
-    while ( nCol1 > 0 && ( pDoc->GetColFlags( nCol1, nTab1 ) & CR_HIDDEN ) )
+    while ( nCol1 > 0 && pDoc->ColHidden(nCol1, nTab1) )
     {
         --nCol1;
         bHiddenEdge = TRUE;
     }
-    while ( nCol2 < MAXCOL && ( pDoc->GetColFlags( nCol2, nTab1 ) & CR_HIDDEN ) )
+    while ( nCol2 < MAXCOL && pDoc->ColHidden(nCol2, nTab1) )
     {
         ++nCol2;
         bHiddenEdge = TRUE;
     }
-    nTmp = pDoc->GetRowFlagsArray( nTab1).GetLastForCondition( 0, nRow1,
-            CR_HIDDEN, 0);
+    nTmp = pDoc->FirstVisibleRow(0, nRow1, nTab1);
     if (!ValidRow(nTmp))
         nTmp = 0;
     if (nTmp < nRow1)
@@ -4620,8 +4619,7 @@ void lcl_PaintOneRange( ScDocShell* pDocSh, const ScRange& rRange, USHORT nEdges
         nRow1 = nTmp;
         bHiddenEdge = TRUE;
     }
-    nTmp = pDoc->GetRowFlagsArray( nTab1).GetFirstForCondition( nRow2, MAXROW,
-            CR_HIDDEN, 0);
+    nTmp = pDoc->FirstVisibleRow(nRow2, MAXROW, nTab1);
     if (!ValidRow(nTmp))
         nTmp = MAXROW;
     if (nTmp > nRow2)
diff --git sc/source/ui/view/gridwin4.cxx sc/source/ui/view/gridwin4.cxx
index 4dfc08f..23edc22 100644
--- sc/source/ui/view/gridwin4.cxx
+++ sc/source/ui/view/gridwin4.cxx
@@ -1378,7 +1378,7 @@ Rectangle ScGridWindow::GetListValButtonRect( const ScAddress& rButtonPos )
     const ScMergeAttr* pMerge = static_cast<const ScMergeAttr*>(pDoc->GetAttr( nCol,nRow,nTab, ATTR_MERGE ));
     if ( pMerge->GetColMerge() > 1 )
         nNextCol = nCol + pMerge->GetColMerge();    // next cell after the merged area
-    while ( nNextCol <= MAXCOL && (pDoc->GetColFlags( nNextCol, nTab ) & CR_HIDDEN) )
+    while ( nNextCol <= MAXCOL && pDoc->ColHidden(nNextCol, nTab) )
         ++nNextCol;
     BOOL bNextCell = ( nNextCol <= MAXCOL );
     if ( bNextCell )
@@ -1581,7 +1581,7 @@ void ScGridWindow::InvertSimple( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
                         if ( pMergeFlag->IsVerOverlapped() && ( bDoHidden || bFirstRow ) )
                         {
                             while ( pMergeFlag->IsVerOverlapped() && nThisY > 0 &&
-                                        ( (pDoc->GetRowFlags( nThisY-1, nTab ) & CR_HIDDEN) || bFirstRow ) )
+                                    (pDoc->RowHidden(nThisY-1, nTab) || bFirstRow) )
                             {
                                 --nThisY;
                                 pPattern = pDoc->GetPattern( nX, nThisY, nTab );
@@ -1768,7 +1768,7 @@ void ScGridWindow::GetSelectionRects( ::std::vector< Rectangle >& rPixelRects )
                         if ( pMergeFlag->IsVerOverlapped() && ( bDoHidden || bFirstRow ) )
                         {
                             while ( pMergeFlag->IsVerOverlapped() && nThisY > 0 &&
-                                        ( (pDoc->GetRowFlags( nThisY-1, nTab ) & CR_HIDDEN) || bFirstRow ) )
+                                    (pDoc->RowHidden(nThisY-1, nTab) || bFirstRow) )
                             {
                                 --nThisY;
                                 pPattern = pDoc->GetPattern( nX, nThisY, nTab );
diff --git sc/source/ui/view/olinewin.cxx sc/source/ui/view/olinewin.cxx
index fa00785..82d66d1 100644
--- sc/source/ui/view/olinewin.cxx
+++ sc/source/ui/view/olinewin.cxx
@@ -186,16 +186,15 @@ const ScOutlineEntry* ScOutlineWindow::GetOutlineEntry( size_t nLevel, size_t nE
 
 bool ScOutlineWindow::IsHidden( SCCOLROW nColRowIndex ) const
 {
-    sal_uInt8 nFlags = mbHoriz ?
-        GetDoc().GetColFlags( static_cast<SCCOL>(nColRowIndex), GetTab() ) :
-        GetDoc().GetRowFlags( static_cast<SCROW>(nColRowIndex), GetTab() );
-    return (nFlags & CR_HIDDEN) != 0;
+    return mbHoriz ? 
+        GetDoc().ColHidden(static_cast<SCCOL>(nColRowIndex), GetTab()) : 
+        GetDoc().RowHidden(static_cast<SCROW>(nColRowIndex), GetTab());
 }
 
 bool ScOutlineWindow::IsFiltered( SCCOLROW nColRowIndex ) const
 {
     // columns cannot be filtered
-    return !mbHoriz && GetDoc().IsFiltered( static_cast<SCROW>(nColRowIndex), GetTab() );
+    return !mbHoriz && GetDoc().RowFiltered( static_cast<SCROW>(nColRowIndex), GetTab() );
 }
 
 bool ScOutlineWindow::IsFirstVisible( SCCOLROW nColRowIndex ) const
diff --git sc/source/ui/view/output.cxx sc/source/ui/view/output.cxx
index 9a27bb8..989ea07 100644
--- sc/source/ui/view/output.cxx
+++ sc/source/ui/view/output.cxx
@@ -387,8 +387,9 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
                 {
                     BYTE nDocFl = pDoc->GetColFlags( nCol, nTab );
                     nBreak = pDoc->HasColBreak(nCol, nTab);
+                    bool bHidden = pDoc->ColHidden(nCol, nTab);
 
-                    if ( nBreak || !(nDocFl & CR_HIDDEN) )
+                    if ( nBreak || !bHidden )
                         break;
                     ++nCol;
                 }
@@ -507,7 +508,7 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
                 for (SCROW i = nYplus1; i <= MAXROW; ++i)
                 {
                     nBreak = pDoc->HasRowBreak(i, nTab);
-                    bool bHidden = (pDoc->GetRowFlags(i, nTab) & CR_HIDDEN);
+                    bool bHidden = pDoc->RowHidden(i, nTab);
                     if (nBreak || !bHidden)
                         break;
                 }
@@ -654,7 +655,7 @@ void ScOutputData::FindRotated()
                 const ScPatternAttr* pPattern = pInfo->pPatternAttr;
                 const SfxItemSet* pCondSet = pInfo->pConditionSet;
 
-                if ( !pPattern && (pDoc->GetColFlags(nX,nTab) & CR_HIDDEN) == 0 )
+                if ( !pPattern && !pDoc->ColHidden(nX, nTab) )
                 {
                     pPattern = pDoc->GetPattern( nX, nY, nTab );
                     pCondSet = pDoc->GetCondResult( nX, nY, nTab );
diff --git sc/source/ui/view/output2.cxx sc/source/ui/view/output2.cxx
index dec757a..3867c17 100644
--- sc/source/ui/view/output2.cxx
+++ sc/source/ui/view/output2.cxx
@@ -697,7 +697,7 @@ BOOL ScOutputData::GetMergeOrigin( SCCOL nX, SCROW nY, SCSIZE nArrY,
     while (bHOver)				// nY konstant
     {
         --rOverX;
-        bHidden = ( (pDoc->GetColFlags(rOverX,nTab) & CR_HIDDEN) != 0 );
+        bHidden = pDoc->ColHidden(rOverX, nTab);
         if ( !bDoMerge && !bHidden )
             return FALSE;
 
@@ -721,7 +721,7 @@ BOOL ScOutputData::GetMergeOrigin( SCCOL nX, SCROW nY, SCSIZE nArrY,
     while (bVOver)
     {
         --rOverY;
-        bHidden = ( (pDoc->GetRowFlags(rOverY,nTab) & CR_HIDDEN) != 0 );
+        bHidden = pDoc->RowHidden(rOverY, nTab);
         if ( !bDoMerge && !bHidden )
             return FALSE;
 
@@ -729,8 +729,8 @@ BOOL ScOutputData::GetMergeOrigin( SCCOL nX, SCROW nY, SCSIZE nArrY,
             --nArrY;						// lokale Kopie !
 
         if (rOverX >= nX1 && rOverY >= nY1 &&
-            (pDoc->GetColFlags(rOverX,nTab) & CR_HIDDEN) == 0 &&
-            (pDoc->GetRowFlags(rOverY,nTab) & CR_HIDDEN) == 0 &&
+            !pDoc->ColHidden(rOverX, nTab) &&
+            !pDoc->RowHidden(rOverY, nTab) &&
             pRowInfo[nArrY].nRowNo == rOverY)
         {
 //			rVirtPosY -= pRowInfo[nArrY].nHeight;
@@ -2014,7 +2014,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                     if (bDoCell)
                     {
                         if ( nCellY == nY && nCellX >= nX1 && nCellX <= nX2 &&
-                             (pDoc->GetColFlags(nCellX,nTab) & CR_HIDDEN) == 0 )
+                             !pDoc->ColHidden(nCellX, nTab) )
                         {
                             CellInfo& rCellInfo = pThisRowInfo->pCellInfo[nCellX+1];
                             pPattern = rCellInfo.pPatternAttr;
diff --git sc/source/ui/view/prevloc.cxx sc/source/ui/view/prevloc.cxx
index 54f7376..fb65955 100644
--- sc/source/ui/view/prevloc.cxx
+++ sc/source/ui/view/prevloc.cxx
@@ -602,11 +602,11 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         ++nColCount;
     if ( bHasRepCols )
         for ( nCol=nRepeatColStart; nCol<=nRepeatColEnd; nCol++ )
-            if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+            if (!pDoc->ColHidden(nCol, nTab))
                 ++nColCount;
     if ( bHasMainCols )
         for ( nCol=nMainColStart; nCol<=nMainColEnd; nCol++ )
-            if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+            if (!pDoc->ColHidden(nCol, nTab))
                 ++nColCount;
 
     if ( nColCount > 0 )
@@ -623,7 +623,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         {
             long nPosX = 0;
             for ( nCol=nRepeatColStart; nCol<=nRepeatColEnd; nCol++ )
-                if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+                if (!pDoc->ColHidden(nCol, nTab))
                 {
                     USHORT nDocW = pDoc->GetColWidth( nCol, nTab );
                     long nNextX = nPosX + (long) (nDocW * nScaleX);
@@ -642,7 +642,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         {
             long nPosX = 0;
             for ( nCol=nMainColStart; nCol<=nMainColEnd; nCol++ )
-                if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+                if (!pDoc->ColHidden(nCol, nTab))
                 {
                     USHORT nDocW = pDoc->GetColWidth( nCol, nTab );
                     long nNextX = nPosX + (long) (nDocW * nScaleX);
@@ -670,11 +670,9 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
     if ( bHasHeaderRow )
         ++nRowCount;
     if ( bHasRepRows )
-        nRowCount += pDoc->GetRowFlagsArray( nTab).CountForCondition(
-                nRepeatRowStart, nRepeatRowEnd, CR_HIDDEN, 0);
+        nRowCount += pDoc->CountVisibleRows(nRepeatRowStart, nRepeatRowEnd, nTab);
     if ( bHasMainRows )
-        nRowCount += pDoc->GetRowFlagsArray( nTab).CountForCondition(
-                nMainRowStart, nMainRowEnd, CR_HIDDEN, 0);
+        nRowCount += pDoc->CountVisibleRows(nMainRowStart, nMainRowEnd, nTab);
 
     if ( nRowCount > 0 )
     {
@@ -689,58 +687,44 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         if ( bHasRepRows )
         {
             long nPosY = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter(
-                    pDoc->GetRowFlagsArray( nTab), nRepeatRowStart,
-                    nRepeatRowEnd);
-            do
+            for (SCROW nRow = nRepeatRowStart; nRow <= nRepeatRowEnd; ++nRow)
             {
-                if ((*aIter & CR_HIDDEN) == 0)
-                {
-                    SCROW nRangeEnd = aIter.GetRangeEnd();
-                    for (SCROW nRow=aIter.GetRangeStart(); nRow<=nRangeEnd; ++nRow)
-                    {
-                        USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
-                        long nNextY = nPosY + (long) (nDocH * nScaleY);
-
-                        long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
-                        long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
-                        pRowInfo[nRowPos].Set( FALSE, nRow,
-                                aRepeatRect.Top() + nPixelStart,
-                                aRepeatRect.Top() + nPixelEnd );
-
-                        nPosY = nNextY;
-                        ++nRowPos;
-                    }
-                }
-            } while (aIter.NextRange());
+                if (pDoc->RowHidden(nRow, nTab))
+                    continue;
+
+                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
+                long nNextY = nPosY + (long) (nDocH * nScaleY);
+
+                long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
+                long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
+                pRowInfo[nRowPos].Set( FALSE, nRow,
+                        aRepeatRect.Top() + nPixelStart,
+                        aRepeatRect.Top() + nPixelEnd );
+
+                nPosY = nNextY;
+                ++nRowPos;
+            }
         }
         if ( bHasMainRows )
         {
             long nPosY = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter(
-                    pDoc->GetRowFlagsArray( nTab), nMainRowStart,
-                    nMainRowEnd);
-            do
+            for (SCROW nRow = nMainRowStart; nRow <= nMainRowEnd; ++nRow)
             {
-                if ((*aIter & CR_HIDDEN) == 0)
-                {
-                    SCROW nRangeEnd = aIter.GetRangeEnd();
-                    for (SCROW nRow=aIter.GetRangeStart(); nRow<=nRangeEnd; ++nRow)
-                    {
-                        USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
-                        long nNextY = nPosY + (long) (nDocH * nScaleY);
-
-                        long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
-                        long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
-                        pRowInfo[nRowPos].Set( FALSE, nRow,
-                                aMainRect.Top() + nPixelStart,
-                                aMainRect.Top() + nPixelEnd );
-
-                        nPosY = nNextY;
-                        ++nRowPos;
-                    }
-                }
-            } while (aIter.NextRange());
+                if (pDoc->RowHidden(nRow, nTab))
+                    continue;
+
+                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
+                long nNextY = nPosY + (long) (nDocH * nScaleY);
+
+                long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
+                long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
+                pRowInfo[nRowPos].Set( FALSE, nRow,
+                        aMainRect.Top() + nPixelStart,
+                        aMainRect.Top() + nPixelEnd );
+
+                nPosY = nNextY;
+                ++nRowPos;
+            }
         }
         rInfo.SetRowInfo( nRowCount, pRowInfo );
     }
diff --git sc/source/ui/view/printfun.cxx sc/source/ui/view/printfun.cxx
index 7c9e431..982c02e 100644
--- sc/source/ui/view/printfun.cxx
+++ sc/source/ui/view/printfun.cxx
@@ -3073,9 +3073,10 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
     nTotalY = 0;
 
     BOOL bVisCol = FALSE;
+	SCCOL nLastCol = -1;
     for (SCCOL i=nStartCol; i<=nEndCol; i++)
     {
-        BYTE nFlags = pDoc->GetColFlags(i,nPrintTab);
+		bool bHidden = pDoc->ColHidden(i, nPrintTab, nLastCol);
         bool bPageBreak = (pDoc->HasColBreak(i, nPrintTab) & BREAK_PAGE);
         if ( i>nStartCol && bVisCol && bPageBreak )
         {
@@ -3083,7 +3084,7 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
             ++nPagesX;
             bVisCol = FALSE;
         }
-        if (!(nFlags & CR_HIDDEN))
+		if (!bHidden)
             bVisCol = TRUE;
     }
     if (bVisCol)	// auch am Ende keine leeren Seiten
@@ -3094,38 +3095,35 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
 
     BOOL bVisRow = FALSE;
     SCROW nPageStartRow = nStartRow;
-    ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray(
-                nPrintTab), nStartRow, nEndRow);
-    do
-    {
-        BYTE nFlags = *aIter;
-        SCROW nRangeEnd = aIter.GetRangeEnd();
-        for (SCROW j=aIter.GetRangeStart(); j<=nRangeEnd; ++j)
-        {
-            bool bPageBreak = (pDoc->HasRowBreak(j, nPrintTab) & BREAK_PAGE);
-            if ( j>nStartRow && bVisRow && bPageBreak )
-            {
-                pPageEndY[nTotalY] = j-1;
-                ++nTotalY;
-
-                if ( !aTableParam.bSkipEmpty ||
-                        !pDoc->IsPrintEmpty( nPrintTab, nStartCol, nPageStartRow, nEndCol, j-1 ) )
-                {
-                    pPageRows[nPagesY].SetStartRow( nPageStartRow );
-                    pPageRows[nPagesY].SetEndRow( j-1 );
-                    pPageRows[nPagesY].SetPagesX( nPagesX );
-                    if (aTableParam.bSkipEmpty)
-                        lcl_SetHidden( pDoc, nPrintTab, pPageRows[nPagesY], nStartCol, pPageEndX );
-                    ++nPagesY;
-                }
-
-                nPageStartRow = j;
-                bVisRow = FALSE;
-            }
-            if (!(nFlags & CR_HIDDEN))
-                bVisRow = TRUE;
-        }
-    } while (aIter.NextRange());
+	for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
+	{
+		bool bPageBreak = (pDoc->HasRowBreak(nRow, nPrintTab) & BREAK_PAGE);
+		if (nRow > nStartRow && bVisRow && bPageBreak )
+		{
+			pPageEndY[nTotalY] = nRow-1;
+			++nTotalY;
+
+			if ( !aTableParam.bSkipEmpty ||
+					!pDoc->IsPrintEmpty( nPrintTab, nStartCol, nPageStartRow, nEndCol, nRow-1 ) )
+			{
+				pPageRows[nPagesY].SetStartRow( nPageStartRow );
+				pPageRows[nPagesY].SetEndRow( nRow-1 );
+				pPageRows[nPagesY].SetPagesX( nPagesX );
+				if (aTableParam.bSkipEmpty)
+					lcl_SetHidden( pDoc, nPrintTab, pPageRows[nPagesY], nStartCol, pPageEndX );
+				++nPagesY;
+			}
+
+			nPageStartRow = nRow;
+			bVisRow = FALSE;
+		}
+		SCROW nLastRow = -1;
+		if (!pDoc->RowHidden(nRow, nPrintTab, nLastRow))
+			bVisRow = TRUE;
+		else
+			// skip all hidden rows.
+			nRow = nLastRow;
+	}
 
     if (bVisRow)
     {
diff --git sc/source/ui/view/select.cxx sc/source/ui/view/select.cxx
index 8ab9801..4ac0b68 100644
--- sc/source/ui/view/select.cxx
+++ sc/source/ui/view/select.cxx
@@ -278,12 +278,12 @@ BOOL __EXPORT ScViewFunctionSet::SetCursorAtPoint( const Point& rPointPixel, BOO
         ScDocument* pDoc = pViewData->GetDocument();
         SCTAB nTab = pViewData->GetTabNo();
         if ( bLeft && !bRightScroll )
-            do --nPosX; while ( nPosX>=0 && ( pDoc->GetColFlags( nPosX, nTab ) & CR_HIDDEN ) );
+			do --nPosX; while ( nPosX>=0 && pDoc->ColHidden( nPosX, nTab ) );
         if ( bTop && !bBottomScroll )
         {
             if (--nPosY >= 0)
             {
-                pDoc->GetRowFlagsArray( nTab).GetLastForCondition( 0, nPosY, CR_HIDDEN, 0);
+                nPosY = pDoc->LastVisibleRow(0, nPosY, nTab);
                 if (!ValidRow(nPosY))
                     nPosY = -1;
             }
@@ -479,7 +479,7 @@ BOOL ScViewFunctionSet::SetCursorAtCell( SCsCOL nPosX, SCsROW nPosY, BOOL bScrol
             {
                 //	#94321# in SetCursorAtPoint hidden columns are skipped.
                 //	They must be skipped here too, or the result will always be the first hidden column.
-                do ++nPosX; while ( nPosX<nStartX && ( pDoc->GetColFlags( nPosX, nTab ) & CR_HIDDEN ) );
+				do ++nPosX; while ( nPosX<nStartX && pDoc->ColHidden(nPosX, nTab) );
                 for (SCCOL i=nPosX; i<nStartX; i++)
                     nSizeX += pDoc->GetColWidth( i, nTab );
             }
@@ -494,8 +494,7 @@ BOOL ScViewFunctionSet::SetCursorAtCell( SCsCOL nPosX, SCsROW nPosY, BOOL bScrol
                 //	They must be skipped here too, or the result will always be the first hidden row.
                 if (++nPosY < nStartY)
                 {
-                    nPosY = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition(
-                            nPosY, nStartY-1, CR_HIDDEN, 0);
+                    nPosY = pDoc->FirstVisibleRow(nPosY, nStartY-1, nTab);
                     if (!ValidRow(nPosY))
                         nPosY = nStartY;
                 }
diff --git sc/source/ui/view/tabview.cxx sc/source/ui/view/tabview.cxx
index f39dd17..eb6908b 100644
--- sc/source/ui/view/tabview.cxx
+++ sc/source/ui/view/tabview.cxx
@@ -1441,7 +1441,7 @@ void ScTabView::ScrollX( long nDeltaX, ScHSplitPos eWhich, BOOL bUpdBars )
     SCsCOL nDir = ( nDeltaX > 0 ) ? 1 : -1;
     ScDocument* pDoc = aViewData.GetDocument();
     SCTAB nTab = aViewData.GetTabNo();
-    while ( ( pDoc->GetColFlags( nNewX, nTab ) & CR_HIDDEN ) &&
+    while ( pDoc->ColHidden(nNewX, nTab) &&
             nNewX+nDir >= 0 && nNewX+nDir <= MAXCOL )
         nNewX = sal::static_int_cast<SCsCOL>( nNewX + nDir );
 
@@ -1530,7 +1530,7 @@ void ScTabView::ScrollY( long nDeltaY, ScVSplitPos eWhich, BOOL bUpdBars )
     SCsROW nDir = ( nDeltaY > 0 ) ? 1 : -1;
     ScDocument* pDoc = aViewData.GetDocument();
     SCTAB nTab = aViewData.GetTabNo();
-    while ( ( pDoc->GetRowFlags( nNewY, nTab ) & CR_HIDDEN ) &&
+    while ( pDoc->RowHidden(nNewY, nTab) &&
             nNewY+nDir >= 0 && nNewY+nDir <= MAXROW )
         nNewY += nDir;
 
diff --git sc/source/ui/view/tabview2.cxx sc/source/ui/view/tabview2.cxx
index 687f936..02a2710 100644
--- sc/source/ui/view/tabview2.cxx
+++ sc/source/ui/view/tabview2.cxx
@@ -928,13 +928,13 @@ BOOL lcl_FitsInWindow( double fScaleX, double fScaleY, USHORT nZoom,
     }
 
     long nBlockY = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            pDoc->GetRowFlagsArray( nTab), 0, nFixPosY-1, CR_HIDDEN, 0,
-            pDoc->GetRowHeightArray( nTab));
-    for ( ; aIter; ++aIter)
+    for (SCROW nRow = 0; nRow <= nFixPosY-1; ++nRow)
     {
+        if (pDoc->RowHidden(nRow, nTab))
+            continue;
+
         //	for frozen panes, add both parts
-        USHORT nRowTwips = *aIter;
+        USHORT nRowTwips = pDoc->GetRowHeight(nRow, nTab);
         if (nRowTwips)
         {
             nBlockY += (long)(nRowTwips * fScaleY);
@@ -942,10 +942,9 @@ BOOL lcl_FitsInWindow( double fScaleX, double fScaleY, USHORT nZoom,
                 return FALSE;
         }
     }
-    aIter.NewLimits( nStartRow, nEndRow);
-    for ( ; aIter; ++aIter)
+    for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
     {
-        USHORT nRowTwips = *aIter;
+        USHORT nRowTwips = pDoc->GetRowHeight(nRow, nTab);
         if (nRowTwips)
         {
             nBlockY += (long)(nRowTwips * fScaleY);
diff --git sc/source/ui/view/tabview3.cxx sc/source/ui/view/tabview3.cxx
index 5493de4..5317d0a 100644
--- sc/source/ui/view/tabview3.cxx
+++ sc/source/ui/view/tabview3.cxx
@@ -993,8 +993,8 @@ void ScTabView::MoveCursorRel( SCsCOL nMovX, SCsROW nMovY, ScFollowMode eMode,
         BOOL bHFlip = FALSE;
         do
         {
-            BYTE nColFlags = pDoc->GetColFlags( nCurX, nTab );
-            bSkipCell = (nColFlags & CR_HIDDEN) || pDoc->IsHorOverlapped( nCurX, nCurY, nTab );
+			SCCOL nLastCol = -1;
+            bSkipCell = pDoc->ColHidden(nCurX, nTab, nLastCol) || pDoc->IsHorOverlapped( nCurX, nCurY, nTab );
             if (bSkipProtected && !bSkipCell)
                 bSkipCell = pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
             if (bSkipUnprotected && !bSkipCell)
@@ -1035,8 +1035,8 @@ void ScTabView::MoveCursorRel( SCsCOL nMovX, SCsROW nMovY, ScFollowMode eMode,
         BOOL bVFlip = FALSE;
         do
         {
-            BYTE nRowFlags = pDoc->GetRowFlags( nCurY, nTab );
-            bSkipCell = (nRowFlags & CR_HIDDEN) || pDoc->IsVerOverlapped( nCurX, nCurY, nTab );
+			SCROW nLastRow = -1;
+            bSkipCell = pDoc->RowHidden(nCurY, nTab, nLastRow) || pDoc->IsVerOverlapped( nCurX, nCurY, nTab );
             if (bSkipProtected && !bSkipCell)
                 bSkipCell = pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
             if (bSkipUnprotected && !bSkipCell)
@@ -2058,17 +2058,18 @@ void ScTabView::PaintRangeFinder( long nNumber )
                             BOOL bHiddenEdge = FALSE;
                             SCROW nTmp;
                             ScDocument* pDoc = aViewData.GetDocument();
-                            while ( nCol1 > 0 && ( pDoc->GetColFlags( nCol1, nTab ) & CR_HIDDEN ) )
+							SCCOL nLastCol = -1;
+							while ( nCol1 > 0 && pDoc->ColHidden(nCol1, nTab, nLastCol) )
                             {
                                 --nCol1;
                                 bHiddenEdge = TRUE;
                             }
-                            while ( nCol2 < MAXCOL && ( pDoc->GetColFlags( nCol2, nTab ) & CR_HIDDEN ) )
+							while ( nCol2 < MAXCOL && pDoc->ColHidden(nCol2, nTab, nLastCol) )
                             {
                                 ++nCol2;
                                 bHiddenEdge = TRUE;
                             }
-                            nTmp = pDoc->GetRowFlagsArray( nTab).GetLastForCondition( 0, nRow1, CR_HIDDEN, 0);
+                            nTmp = pDoc->LastVisibleRow(0, nRow1, nTab);
                             if (!ValidRow(nTmp))
                                 nTmp = 0;
                             if (nTmp < nRow1)
@@ -2076,7 +2077,7 @@ void ScTabView::PaintRangeFinder( long nNumber )
                                 nRow1 = nTmp;
                                 bHiddenEdge = TRUE;
                             }
-                            nTmp = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition( nRow2, MAXROW, CR_HIDDEN, 0);
+                            nTmp = pDoc->FirstVisibleRow(nRow2, MAXROW, nTab);
                             if (!ValidRow(nTmp))
                                 nTmp = MAXROW;
                             if (nTmp > nRow2)
diff --git sc/source/ui/view/viewdata.cxx sc/source/ui/view/viewdata.cxx
index 344f5b6..2ca5d83 100644
--- sc/source/ui/view/viewdata.cxx
+++ sc/source/ui/view/viewdata.cxx
@@ -1560,7 +1560,7 @@ Point ScViewData::GetScrPos( SCCOL nWhereX, SCROW nWhereY, ScSplitPos eWhich,
                 else if ( nY < MAXROW )
                 {
                     // skip multiple hidden rows (forward only for now)
-                    SCROW nNext = pDoc->FastGetFirstNonHiddenRow( nY + 1, nTabNo );
+                    SCROW nNext = pDoc->FirstVisibleRow(nY + 1, MAXROW, nTabNo);
                     if ( nNext > MAXROW )
                         nY = MAXROW;
                     else
@@ -1672,7 +1672,7 @@ SCROW ScViewData::CellsAtY( SCsROW nPosY, SCsROW nDir, ScVSplitPos eWhichY, USHO
             else if ( nDir == 1 && nRowNo < MAXROW )
             {
                 // skip multiple hidden rows (forward only for now)
-                SCROW nNext = pDoc->FastGetFirstNonHiddenRow( nRowNo + 1, nTabNo );
+                SCROW nNext = pDoc->FirstVisibleRow(nRowNo + 1, MAXROW, nTabNo);
                 if ( nNext > MAXROW )
                 {
                     // same behavior as without the optimization: set bOut with nY=MAXROW+1
@@ -1735,11 +1735,19 @@ BOOL ScViewData::GetMergeSizePixel( SCCOL nX, SCROW nY, long& rSizeXPix, long& r
         for (SCCOL i=0; i<nCountX; i++)
             nOutWidth += ToPixel( pDoc->GetColWidth(nX+i,nTabNo), nPPTX );
         SCROW nCountY = pMerge->GetRowMerge();
-        ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-                pDoc->GetRowFlagsArray( nTabNo), nY, nY+nCountY-1, CR_HIDDEN,
-                0, pDoc->GetRowHeightArray( nTabNo));
-        for ( ; aIter; ++aIter )
-            nOutHeight += ToPixel( *aIter, nPPTY );
+
+        for (SCROW nRow = nY; nRow <= nY+nCountY-1; ++nRow)
+        {
+            SCROW nLastRow = nRow;
+            if (pDoc->RowHidden(nRow, nTabNo, NULL, &nLastRow))
+            {    
+                nRow = nLastRow;
+                continue;
+            }
+
+            USHORT nHeight = pDoc->GetRowHeight(nRow, nTabNo);
+            nOutHeight += ToPixel(nHeight, nPPTY);
+        }
 
         rSizeXPix = nOutWidth;
         rSizeYPix = nOutHeight;
diff --git sc/source/ui/view/viewfun3.cxx sc/source/ui/view/viewfun3.cxx
index d0d565a..af68b6b 100644
--- sc/source/ui/view/viewfun3.cxx
+++ sc/source/ui/view/viewfun3.cxx
@@ -1727,10 +1727,10 @@ BOOL ScViewFunc::MoveBlockTo( const ScRange& rSource, const ScAddress& rDestPos,
         BOOL bIncludeFiltered = bCut;
         if ( !bIncludeFiltered )
         {
-            //	manually find number of non-filtered rows
-            SCROW nPastedCount = pDocSh->GetDocument()->GetRowFlagsArray(
-                    rSource.aStart.Tab()).CountForCondition(
-                    rSource.aStart.Row(), rSource.aEnd.Row(), CR_FILTERED, 0);
+			// find number of non-filtered rows
+            SCROW nPastedCount = pDocSh->GetDocument()->CountNonFilteredRows(
+                rSource.aStart.Row(), rSource.aEnd.Row(), rSource.aStart.Tab());
+
             if ( nPastedCount == 0 )
                 nPastedCount = 1;
             aDestEnd.SetRow( rDestPos.Row() + nPastedCount - 1 );
diff --git sc/source/ui/view/viewfunc.cxx sc/source/ui/view/viewfunc.cxx
index 61670e7..96132fc 100644
--- sc/source/ui/view/viewfunc.cxx
+++ sc/source/ui/view/viewfunc.cxx
@@ -2215,28 +2215,19 @@ void ScViewFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pR
                         {
                             //	fuer alle eingeblendeten CR_MANUALSIZE loeschen,
                             //	dann SetOptimalHeight mit bShrink = FALSE
-                            ScCompressedArrayIterator< SCROW, BYTE> aIter(
-                                    pDoc->GetRowFlagsArray( nTab), nStartNo,
-                                    nEndNo);
-                            do
+                            for (SCROW nRow = nStartNo; nRow <= nEndNo; ++nRow)
                             {
-                                BYTE nOld = *aIter;
-                                if ( (nOld & CR_HIDDEN) == 0 && ( nOld & CR_MANUALSIZE ) )
+                                SCROW nLastRow = nRow;
+                                if (pDoc->RowHidden(nRow, nTab, NULL, &nLastRow))
                                 {
-                                    SCROW nRangeEnd = aIter.GetRangeEnd();
-                                    pDoc->SetRowFlags( aIter.GetRangeStart(),
-                                            nRangeEnd, nTab,
-                                            nOld & ~CR_MANUALSIZE);
-                                    aIter.Resync( nRangeEnd);
-                                    // Range may be extended due to merges and
-                                    // now aIter.GetRangeEnd() may point behind
-                                    // the previous row, but all flags of this
-                                    // range have the CR_MANUALSIZE bit
-                                    // removed, so it is safe to continue with
-                                    // the next range, not necessary to catch
-                                    // up with the remaining rows.
+                                    nRow = nLastRow;
+                                    continue;
                                 }
-                            } while (aIter.NextRange());
+
+                                BYTE nOld = pDoc->GetRowFlags(nRow, nTab);
+                                if (nOld & CR_MANUALSIZE)
+                                    pDoc->SetRowFlags(nRow, nTab, nOld & ~CR_MANUALSIZE);
+                            }
                         }
 
                         double nPPTX = GetViewData()->GetPPTX();
@@ -2278,8 +2269,7 @@ void ScViewFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pR
                 {
                     for (SCCOL nCol=static_cast<SCCOL>(nStartNo); nCol<=static_cast<SCCOL>(nEndNo); nCol++)
                     {
-                        if ( eMode != SC_SIZE_VISOPT ||
-                             (pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) == 0 )
+						if ( eMode != SC_SIZE_VISOPT || !pDoc->ColHidden(nCol, nTab) )
                         {
                             USHORT nThisSize = nSizeTwips;
 
diff --git sc/source/ui/view/viewutil.cxx sc/source/ui/view/viewutil.cxx
index 964695c..4215562 100644
--- sc/source/ui/view/viewutil.cxx
+++ sc/source/ui/view/viewutil.cxx
@@ -264,20 +264,19 @@ void ScViewUtil::UnmarkFiltered( ScMarkData& rMark, ScDocument* pDoc )
     for (SCTAB nTab=0; nTab<nTabCount; nTab++)
         if ( rMark.GetTableSelect(nTab ) )
         {
-            ScCompressedArrayIterator<SCROW, BYTE> aIter(pDoc->GetRowFlagsArray(nTab), nStartRow, nEndRow);
-            do
+            for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
             {
-                if (*aIter & CR_FILTERED)
+                SCROW nLastRow = nRow;
+                if (pDoc->RowFiltered(nRow, nTab, NULL, &nLastRow))
                 {
                     // use nStartCol/nEndCol, so the multi mark area isn't extended to all columns
                     // (visible in repaint for indentation)
-
-                    rMark.SetMultiMarkArea( ScRange( nStartCol, aIter.GetRangeStart(), nTab,
-                                                     nEndCol, aIter.GetRangeEnd(), nTab ), FALSE );
+                    rMark.SetMultiMarkArea(
+                        ScRange(nStartCol, nRow, nTab, nEndCol, nLastRow, nTab), false);
                     bChanged = true;
+                    nRow = nLastRow;
                 }
             }
-            while (aIter.NextRange());
         }
 
     if ( bChanged && !rMark.HasAnyMultiMarks() )
@@ -288,13 +287,19 @@ void ScViewUtil::UnmarkFiltered( ScMarkData& rMark, ScDocument* pDoc )
 
 
 // static
-bool ScViewUtil::FitToUnfilteredRows( ScRange & rRange, const ScDocument * pDoc, size_t nRows )
+bool ScViewUtil::FitToUnfilteredRows( ScRange & rRange, ScDocument * pDoc, size_t nRows )
 {
     SCTAB nTab = rRange.aStart.Tab();
     bool bOneTabOnly = (nTab == rRange.aEnd.Tab());
     // Always fit the range on its first sheet.
     DBG_ASSERT( bOneTabOnly, "ScViewUtil::ExtendToUnfilteredRows: works only on one sheet");
     SCROW nStartRow = rRange.aStart.Row();
+#if 1
+    SCROW nLastRow = pDoc->LastNonFilteredRow(nStartRow, MAXROW, nTab);
+    if (ValidRow(nLastRow))
+        rRange.aEnd.SetRow(nLastRow);
+    SCROW nCount = pDoc->CountNonFilteredRows(nStartRow, MAXROW, nTab);
+#else
     // FillArrayForCondition() usually is the fastest to determine such a set
     // in one pass, even if the array isn't used but the last element.
     SCROW* pArr = new SCROW[nRows];
@@ -303,19 +308,19 @@ bool ScViewUtil::FitToUnfilteredRows( ScRange & rRange, const ScDocument * pDoc,
     if (nCount)
         rRange.aEnd.SetRow( pArr[nCount-1]);
     delete [] pArr;
+#endif
     return nCount == nRows && bOneTabOnly;
 }
 
 
 // static
-bool ScViewUtil::HasFiltered( const ScRange& rRange, const ScDocument* pDoc )
+bool ScViewUtil::HasFiltered( const ScRange& rRange, ScDocument* pDoc )
 {
     SCROW nStartRow = rRange.aStart.Row();
     SCROW nEndRow = rRange.aEnd.Row();
     for (SCTAB nTab=rRange.aStart.Tab(); nTab<=rRange.aEnd.Tab(); nTab++)
     {
-        if ( pDoc->GetRowFlagsArray( nTab).HasCondition( nStartRow, nEndRow,
-                CR_FILTERED, CR_FILTERED ) )
+        if (pDoc->HasFilteredRows(nStartRow, nEndRow, nTab))
             return true;
     }
 
