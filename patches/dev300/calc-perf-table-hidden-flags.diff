From a297d5831f468abaf4069bd546234ecdde56cb00 Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 16:56:51 +0200
Subject: [PATCH 202/768] calc-perf-table-hidden-flags.diff

---
 sc/inc/column.hxx                                 |    4 +-
 sc/inc/document.hxx                               |   70 +--
 sc/inc/olinetab.hxx                               |    5 +-
 sc/inc/table.hxx                                  |   67 +++-
 sc/source/core/data/column2.cxx                   |   11 +-
 sc/source/core/data/dociter.cxx                   |    4 +-
 sc/source/core/data/documen3.cxx                  |   63 ++--
 sc/source/core/data/document.cxx                  |  183 +++++++-
 sc/source/core/data/drwlayer.cxx                  |   10 +-
 sc/source/core/data/fillinfo.cxx                  |   41 +-
 sc/source/core/data/olinetab.cxx                  |    8 +-
 sc/source/core/data/table1.cxx                    |   29 +-
 sc/source/core/data/table2.cxx                    |  312 +++++++------
 sc/source/core/data/table3.cxx                    |   38 +-
 sc/source/core/data/table5.cxx                    |  524 ++++++++++++++++++++-
 sc/source/core/tool/chartarr.cxx                  |   76 ++--
 sc/source/filter/excel/colrowst.cxx               |    2 +-
 sc/source/filter/excel/xetable.cxx                |    5 +-
 sc/source/filter/excel/xlescher.cxx               |   15 +-
 sc/source/filter/html/htmlexp.cxx                 |   14 +-
 sc/source/filter/lotus/lotimpop.cxx               |    3 +-
 sc/source/filter/lotus/op.cxx                     |    4 +-
 sc/source/filter/rtf/expbase.cxx                  |   13 +-
 sc/source/filter/starcalc/scflt.cxx               |   12 +-
 sc/source/ui/Accessibility/AccessibleCellBase.cxx |   10 +-
 sc/source/ui/app/inputwin.cxx                     |    2 +-
 sc/source/ui/app/transobj.cxx                     |   15 +-
 sc/source/ui/docshell/docfunc.cxx                 |    8 +-
 sc/source/ui/docshell/impex.cxx                   |    2 +-
 sc/source/ui/docshell/olinefun.cxx                |    6 +-
 sc/source/ui/inc/viewutil.hxx                     |    4 +-
 sc/source/ui/undo/undoblk.cxx                     |    8 +-
 sc/source/ui/undo/undoblk3.cxx                    |    7 +-
 sc/source/ui/unoobj/cellsuno.cxx                  |   46 +-
 sc/source/ui/unoobj/chart2uno.cxx                 |    7 +-
 sc/source/ui/unoobj/docuno.cxx                    |   12 +-
 sc/source/ui/view/colrowba.cxx                    |    6 +-
 sc/source/ui/view/drawutil.cxx                    |   19 +-
 sc/source/ui/view/gridwin.cxx                     |   10 +-
 sc/source/ui/view/gridwin4.cxx                    |    6 +-
 sc/source/ui/view/olinewin.cxx                    |    9 +-
 sc/source/ui/view/output.cxx                      |    7 +-
 sc/source/ui/view/output2.cxx                     |   10 +-
 sc/source/ui/view/prevloc.cxx                     |   92 ++---
 sc/source/ui/view/printfun.cxx                    |   56 +--
 sc/source/ui/view/select.cxx                      |    9 +-
 sc/source/ui/view/tabview.cxx                     |    4 +-
 sc/source/ui/view/tabview2.cxx                    |   15 +-
 sc/source/ui/view/tabview3.cxx                    |   17 +-
 sc/source/ui/view/viewdata.cxx                    |   22 +-
 sc/source/ui/view/viewfun3.cxx                    |    8 +-
 sc/source/ui/view/viewfunc.cxx                    |   32 +-
 sc/source/ui/view/viewutil.cxx                    |   27 +-
 53 files changed, 1371 insertions(+), 618 deletions(-)

diff --git sc/inc/column.hxx sc/inc/column.hxx
index 2ef9e90..9ef97ac 100644
--- sc/inc/column.hxx
+++ sc/inc/column.hxx
@@ -211,10 +211,10 @@ public:
                 //	UpdateSelectionFunction: Mehrfachselektion
     void		UpdateSelectionFunction( const ScMarkData& rMark,
                                     ScFunctionData& rData,
-                                    const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+                                    ScFlatBoolRowSegments& rHiddenRows,
                                     BOOL bDoExclude, SCROW nExStartRow, SCROW nExEndRow );
     void		UpdateAreaFunction( ScFunctionData& rData,
-                                    const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+                                    ScFlatBoolRowSegments& rHiddenRows,
                                     SCROW nStartRow, SCROW nEndRow );
 
     void		CopyToColumn(SCROW nRow1, SCROW nRow2, USHORT nFlags, BOOL bMarked,
diff --git sc/inc/document.hxx sc/inc/document.hxx
index ffee730..de772bc 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -434,17 +434,12 @@ private:
 
     sal_Int16           mnNamedRangesLockCount;
 
-    inline BOOL 		RowHidden( SCROW nRow, SCTAB nTab );		// FillInfo
-
 public:
     SC_DLLPUBLIC ULONG			GetCellCount() const;		// alle Zellen
     SCSIZE          GetCellCount(SCTAB nTab, SCCOL nCol) const;
     ULONG			GetWeightedCount() const;	// Formeln und Edit staerker gewichtet
     ULONG			GetCodeCount() const;		// RPN-Code in Formeln
     DECL_LINK( GetUserDefinedColor, USHORT * );
-    BOOL        RowFiltered( SCROW nRow, SCTAB nTab ) const;    // FillInfo
-    BOOL        ColFiltered( SCCOL nCol, SCTAB nTab ) const;    // FillInfo
-                                                                // Numberformatter
 
 public:
     SC_DLLPUBLIC 				ScDocument( ScDocumentMode eMode = SCDOCMODE_DOCUMENT,
@@ -1291,7 +1286,6 @@ public:
                         SCTAB nTab, double fScale ) const;
     SC_DLLPUBLIC inline USHORT	FastGetRowHeight( SCROW nRow, SCTAB nTab ) const;
     inline SCROW	FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const;
-    inline SCROW    FastGetFirstNonHiddenRow( SCROW nStartRow, SCTAB nTab ) const;
                     /** No check for flags whether row is hidden, height value
                         is returned unconditionally. */
     inline USHORT   FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const;
@@ -1343,6 +1337,26 @@ public:
     ::com::sun::star::uno::Sequence<
         ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData(SCTAB nTab) const;
 
+    SC_DLLPUBLIC bool           RowHidden(SCROW nRow, SCTAB nTab, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    SC_DLLPUBLIC bool           RowHidden(SCROW nRow, SCTAB nTab, SCROW& rLastRow);
+    SC_DLLPUBLIC bool           HasHiddenRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SC_DLLPUBLIC bool           ColHidden(SCCOL nCol, SCTAB nTab, SCCOL& rLastCol);
+    SC_DLLPUBLIC bool           ColHidden(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    SC_DLLPUBLIC void           SetRowHidden(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bHidden);
+    SC_DLLPUBLIC void           SetColHidden(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bHidden);
+    SC_DLLPUBLIC SCROW          FirstVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SC_DLLPUBLIC SCROW          LastVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SCROW                       CountVisibleRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+
+    bool                        RowFiltered(SCROW nRow, SCTAB nTab, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    bool                        HasFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    bool                        ColFiltered(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    SC_DLLPUBLIC void           SetRowFiltered(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bFiltered);
+    SC_DLLPUBLIC void           SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bFiltered);
+    SCROW                       FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SCROW                       LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+    SCROW                       CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab);
+
     /**
      * Write all column row flags to table's flag data, because not all column
      * row attributes are stored in the flag data members.  This is necessary
@@ -1371,8 +1385,6 @@ public:
     BOOL			GetColDefault( SCTAB nTab, SCCOL nCol, SCROW nLastRow, SCROW& nDefault);
     BOOL			GetRowDefault( SCTAB nTab, SCROW nRow, SCCOL nLastCol, SCCOL& nDefault);
 
-    BOOL			IsFiltered( SCROW nRow, SCTAB nTab ) const;
-
     BOOL			UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, BOOL bShow );
     BOOL			UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, SCTAB nTab, BOOL bShow );
 
@@ -1851,42 +1863,18 @@ inline void ScDocument::SetSortParam( ScSortParam& rParam, SCTAB nTab )
 inline ULONG ScDocument::FastGetScaledRowHeight( SCROW nStartRow, SCROW nEndRow,
         SCTAB nTab, double fScale ) const
 {
-    return pTab[nTab]->pRowFlags->SumScaledCoupledArrayForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0, *(pTab[nTab]->pRowHeight), fScale);
+    ULONG nHeight = FastGetRowHeight(nStartRow, nEndRow, nTab);
+    return nHeight * fScale;
 }
 
 inline USHORT ScDocument::FastGetRowHeight( SCROW nRow, SCTAB nTab ) const
 {
-    return ( pTab[nTab]->pRowFlags->GetValue(nRow) & CR_HIDDEN ) ? 0 :
-        pTab[nTab]->pRowHeight->GetValue(nRow);
+    return pTab[nTab]->GetRowHeight(nRow);
 }
 
 inline SCROW ScDocument::FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const
 {
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            *(pTab[nTab]->pRowFlags), 0, MAXROW, CR_HIDDEN, 0,
-            *(pTab[nTab]->pRowHeight));
-    ULONG nSum = 0;
-    for ( ; aIter; aIter.NextRange() )
-    {
-        ULONG nNew = *aIter * (aIter.GetRangeEnd() - aIter.GetRangeStart() + 1);
-        if (nSum + nNew > nHeight)
-        {
-            for ( ; aIter && nSum <= nHeight; ++aIter )
-            {
-                nSum += *aIter;
-            }
-            return aIter.GetPos();
-        }
-        nSum += nNew;
-    }
-    return aIter.GetPos();
-}
-
-inline SCROW ScDocument::FastGetFirstNonHiddenRow( SCROW nStartRow, SCTAB nTab) const
-{
-    return pTab[nTab]->pRowFlags->GetFirstForCondition( nStartRow, MAXROW,
-            CR_HIDDEN, 0);
+    return pTab[nTab]->GetRowForHeight(nHeight);
 }
 
 inline USHORT ScDocument::FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const
@@ -1894,16 +1882,6 @@ inline USHORT ScDocument::FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) con
     return pTab[nTab]->pRowHeight->GetValue(nRow);
 }
 
-inline BOOL ScDocument::ColFiltered( SCCOL nCol, SCTAB nTab ) const
-{
-    return ( pTab[nTab]->pColFlags[nCol] & CR_FILTERED) != 0;
-}
-
-inline BOOL ScDocument::RowFiltered( SCROW nRow, SCTAB nTab ) const
-{
-    return pTab[nTab]->IsFiltered(nRow);
-}
-
 #endif
 
 
diff --git sc/inc/olinetab.hxx sc/inc/olinetab.hxx
index 8c5be5d..337bdea 100644
--- sc/inc/olinetab.hxx
+++ sc/inc/olinetab.hxx
@@ -36,6 +36,7 @@
 #define SC_OL_MAXDEPTH		7
 
 class SvStream;
+class ScTable;
 
 
 class ScOutlineEntry : public ScDataObject
@@ -123,9 +124,7 @@ public:
     void					InsertSpace( SCCOLROW nStartPos, SCSIZE nSize );
     BOOL					DeleteSpace( SCCOLROW nStartPos, SCSIZE nSize );
 
-    BOOL					ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos,
-                                BOOL bShow,
-                                const ScBitMaskCompressedArray< SCCOLROW, BYTE>& rHiddenFlags );
+    bool                    ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos, bool bShow, ScTable& rTable, bool bCol );
 
     void					RemoveAll();
 };
diff --git sc/inc/table.hxx sc/inc/table.hxx
index 02115b1..f7a83fa 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -40,6 +40,7 @@
 
 #include <memory>
 #include <set>
+#include <boost/shared_ptr.hpp>
 
 namespace utl {
     class SearchParam;
@@ -81,6 +82,8 @@ struct ScFunctionData;
 struct ScLineFlags;
 class CollatorWrapper;
 struct ScSetStringParam;
+class ScFlatBoolRowSegments;
+class ScFlatBoolColSegments;
 
 class ScTable
 {
@@ -123,6 +126,10 @@ private:
 
     BYTE*			pColFlags;
     ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
+    ::boost::shared_ptr<ScFlatBoolColSegments>  mpHiddenCols;
+    ::boost::shared_ptr<ScFlatBoolRowSegments>  mpHiddenRows;
+    ::boost::shared_ptr<ScFlatBoolColSegments>  mpFilteredCols;
+    ::boost::shared_ptr<ScFlatBoolRowSegments>  mpFilteredRows;
 
     ::std::set<SCROW>                      maRowPageBreaks;
     ::std::set<SCROW>                      maRowManualBreaks;
@@ -479,7 +486,7 @@ public:
                                 SCCOL& rCol, SCROW& rRow, ScMarkData& rMark,
                                 String& rUndoStr, ScDocument* pUndoDoc);
 
-    void		FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 ) const;
+    void		FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 );
 
     void		GetBorderLines( SCCOL nCol, SCROW nRow,
                                 const SvxBorderLine** ppLeft, const SvxBorderLine** ppTop,
@@ -601,19 +608,29 @@ public:
                         // nPPT fuer Test auf Veraenderung
     void		SetManualHeight( SCROW nStartRow, SCROW nEndRow, BOOL bManual );
 
-    USHORT		GetColWidth( SCCOL nCol ) const;
-    USHORT		GetRowHeight( SCROW nRow ) const;
-    ULONG		GetRowHeight( SCROW nStartRow, SCROW nEndRow ) const;
-    ULONG		GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale ) const;
-    ULONG		GetColOffset( SCCOL nCol ) const;
-    ULONG		GetRowOffset( SCROW nRow ) const;
+    USHORT		GetColWidth( SCCOL nCol );
+    SC_DLLPUBLIC USHORT GetRowHeight( SCROW nRow );
+    ULONG		GetRowHeight( SCROW nStartRow, SCROW nEndRow );
+    ULONG		GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale );
+    ULONG		GetColOffset( SCCOL nCol );
+    ULONG		GetRowOffset( SCROW nRow );
+
+    /**
+     * Get the last row such that the height of row 0 to the end row is as
+     * high as possible without exceeding the specified height value.
+     *
+     * @param nHeight maximum desired height
+     *
+     * @return SCROW last row of the range within specified height.
+     */
+    SCROW       GetRowForHeight(ULONG nHeight);
 
     USHORT		GetOriginalWidth( SCCOL nCol ) const;
     USHORT		GetOriginalHeight( SCROW nRow ) const;
 
-    USHORT		GetCommonWidth( SCCOL nEndCol ) const;
+    USHORT		GetCommonWidth( SCCOL nEndCol );
 
-    SCROW		GetHiddenRowCount( SCROW nRow ) const;
+    SCROW		GetHiddenRowCount( SCROW nRow );
 
     void		ShowCol(SCCOL nCol, BOOL bShow);
     void		ShowRow(SCROW nRow, BOOL bShow);
@@ -634,8 +651,6 @@ public:
                 /// @return  the index of the last changed row (flags and row height, auto pagebreak is ignored).
     SCROW      GetLastChangedRow() const;
 
-    BOOL		IsFiltered(SCROW nRow) const;
-
     BYTE		GetColFlags( SCCOL nCol ) const;
     BYTE		GetRowFlags( SCROW nRow ) const;
 
@@ -664,6 +679,34 @@ public:
     void        SetColBreak(SCCOL nCol, bool bPage, bool bManual);
     ::com::sun::star::uno::Sequence<
         ::com::sun::star::sheet::TablePageBreakData> GetRowBreakData() const;
+
+    bool        RowHidden(SCROW nRow, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    bool        RowHidden(SCROW nRow, SCROW& rLastRow);
+    bool        HasHiddenRows(SCROW nStartRow, SCROW nEndRow);
+    bool        ColHidden(SCCOL nCol, SCCOL& rLastCol);
+    bool        ColHidden(SCCOL nCol, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    void        SetRowHidden(SCROW nStartRow, SCROW nEndRow, bool bHidden);
+    void        SetColHidden(SCCOL nStartCol, SCCOL nEndCol, bool bHidden);
+    void        CopyColHidden(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol);
+    void        CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow);
+    SCROW       FirstVisibleRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       LastVisibleRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       CountVisibleRows(SCROW nStartRow, SCROW nEndRow);
+    sal_uInt32  GetTotalRowHeight(SCROW nStartRow, SCROW nEndRow);
+
+    SCCOLROW    LastHiddenColRow(SCCOLROW nPos, bool bCol);
+
+    bool        RowFiltered(SCROW nRow, SCROW* pFirstRow = NULL, SCROW* pLastRow = NULL);
+    bool        ColFiltered(SCCOL nCol, SCCOL* pFirstCol = NULL, SCCOL* pLastCol = NULL);
+    bool        HasFilteredRows(SCROW nStartRow, SCROW nEndRow);
+    void        CopyColFiltered(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol);
+    void        CopyRowFiltered(ScTable& rTable, SCROW nStartRow, SCROW nEndRow);
+    void        SetRowFiltered(SCROW nStartRow, SCROW nEndRow, bool bFiltered);
+    void        SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, bool bFiltered);
+    SCROW       FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow);
+    SCROW       CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow);
+
     void        SyncColRowFlags();
 
     void		StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 );
@@ -794,7 +837,7 @@ private:
 
     SCSIZE		FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2,
                             SCCOL nCol, SCROW nAttrRow1, SCROW nAttrRow2, SCSIZE nArrY,
-                            const ScPatternAttr* pPattern, const SfxItemSet* pCondSet ) const;
+                            const ScPatternAttr* pPattern, const SfxItemSet* pCondSet );
 
     // idle calculation of OutputDevice text width for cell
     // also invalidates script type, broadcasts for "calc as shown"
diff --git sc/source/core/data/column2.cxx sc/source/core/data/column2.cxx
index 94d3b98..926e621 100644
--- sc/source/core/data/column2.cxx
+++ sc/source/core/data/column2.cxx
@@ -66,6 +66,7 @@
 #include "compiler.hxx"			// ScTokenArray GetCodeLen
 #include "dbcolect.hxx"
 #include "fillinfo.hxx"
+#include "segmenttree.hxx"
 
 #include <math.h>
 
@@ -1786,7 +1787,7 @@ void lcl_UpdateSubTotal( ScFunctionData& rData, ScBaseCell* pCell )
 //	Mehrfachselektion:
 void ScColumn::UpdateSelectionFunction( const ScMarkData& rMark,
                                         ScFunctionData& rData,
-                                        const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+                                        ScFlatBoolRowSegments& rHiddenRows,
                                         BOOL bDoExclude, SCROW nExStartRow, SCROW nExEndRow )
 {
     SCSIZE nIndex;
@@ -1794,7 +1795,8 @@ void ScColumn::UpdateSelectionFunction( const ScMarkData& rMark,
     while (aDataIter.Next( nIndex ))
     {
         SCROW nRow = pItems[nIndex].nRow;
-        if ( !pRowFlags || !( pRowFlags->GetValue(nRow) & CR_HIDDEN ) )
+        bool bRowHidden = rHiddenRows.getValue(nRow);
+        if ( !bRowHidden )
             if ( !bDoExclude || nRow < nExStartRow || nRow > nExEndRow )
                 lcl_UpdateSubTotal( rData, pItems[nIndex].pCell );
     }
@@ -1802,7 +1804,7 @@ void ScColumn::UpdateSelectionFunction( const ScMarkData& rMark,
 
 //	bei bNoMarked die Mehrfachselektion weglassen
 void ScColumn::UpdateAreaFunction( ScFunctionData& rData,
-                                    const ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags,
+                                   ScFlatBoolRowSegments& rHiddenRows,
                                     SCROW nStartRow, SCROW nEndRow )
 {
     SCSIZE nIndex;
@@ -1810,7 +1812,8 @@ void ScColumn::UpdateAreaFunction( ScFunctionData& rData,
     while ( nIndex<nCount && pItems[nIndex].nRow<=nEndRow )
     {
         SCROW nRow = pItems[nIndex].nRow;
-        if ( !pRowFlags || !( pRowFlags->GetValue(nRow) & CR_HIDDEN ) )
+        bool bRowHidden = rHiddenRows.getValue(nRow);
+        if ( !bRowHidden )
             lcl_UpdateSubTotal( rData, pItems[nIndex].pCell );
         ++nIndex;
     }
diff --git sc/source/core/data/dociter.cxx sc/source/core/data/dociter.cxx
index ff3032d..c03eb91 100644
--- sc/source/core/data/dociter.cxx
+++ sc/source/core/data/dociter.cxx
@@ -345,7 +345,7 @@ BOOL ScValueIterator::GetThis(double& rValue, USHORT& rErr)
         if ( nColRow < pCol->nCount && pCol->pItems[nColRow].nRow <= nEndRow )
         {
             nRow = pCol->pItems[nColRow].nRow + 1;
-            if ( !bSubTotal || !pDoc->pTab[nTab]->IsFiltered( nRow-1 ) )
+            if ( !bSubTotal || !pDoc->pTab[nTab]->RowFiltered( nRow-1 ) )
             {
                 ScBaseCell* pCell = pCol->pItems[nColRow].pCell;
                 ++nColRow;
@@ -1071,7 +1071,7 @@ ScBaseCell* ScCellIterator::GetThis()
         if ( nColRow < pCol->nCount	&& pCol->pItems[nColRow].nRow <= nEndRow )
         {
             nRow = pCol->pItems[nColRow].nRow;
-            if ( !bSubTotal || !pDoc->pTab[nTab]->IsFiltered( nRow ) )
+            if ( !bSubTotal || !pDoc->pTab[nTab]->RowFiltered( nRow ) )
             {
                 ScBaseCell* pCell = pCol->pItems[nColRow].pCell;
 
diff --git sc/source/core/data/documen3.cxx sc/source/core/data/documen3.cxx
index 8ac8be1..dabcebb 100644
--- sc/source/core/data/documen3.cxx
+++ sc/source/core/data/documen3.cxx
@@ -1124,15 +1124,6 @@ BOOL ScDocument::SearchAndReplace(const SvxSearchItem& rSearchItem,
     return bFound;
 }
 
-BOOL ScDocument::IsFiltered( SCROW nRow, SCTAB nTab ) const
-{
-    if (VALIDTAB(nTab))
-        if (pTab[nTab])
-            return pTab[nTab]->IsFiltered( nRow );
-    DBG_ERROR("Falsche Tabellennummer");
-    return 0;
-}
-
 //	Outline anpassen
 
 BOOL ScDocument::UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, BOOL bShow )
@@ -1559,46 +1550,43 @@ ScRange ScDocument::GetRange( SCTAB nTab, const Rectangle& rMMRect )
     nTwips = (long) (aPosRect.Top() / HMM_PER_TWIPS);
 
     SCROW nY1 = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            *(pTable->GetRowFlagsArray()), nY1, MAXROW, CR_HIDDEN, 0,
-            *(pTable->GetRowHeightArray()));
     bEnd = FALSE;
-    while (!bEnd && aIter)
+    for (SCROW i = nY1; i <= MAXROW && !bEnd; ++i)
     {
-        nY1 = aIter.GetPos();
-        nAdd = (long) *aIter;
+        if (pTable->RowHidden(i))
+            continue;
+
+        nY1 = i;
+        nAdd = static_cast<long>(pTable->GetRowHeight(i));
         if (nSize+nAdd <= nTwips+1 && nY1<MAXROW)
         {
             nSize += nAdd;
             ++nY1;
-            ++aIter;
         }
         else
             bEnd = TRUE;
     }
-    if (!aIter)
-        nY1 = aIter.GetIterEnd();   // all hidden down to the bottom
+    if (!bEnd)
+        nY1 = MAXROW;   // all hidden down to the bottom
 
     nTwips = (long) (aPosRect.Bottom() / HMM_PER_TWIPS);
 
     SCROW nY2 = nY1;
-    aIter.NewLimits( nY2, MAXROW);
     bEnd = FALSE;
-    while (!bEnd && aIter)
+    for (SCROW i = nY2; i <= MAXROW && !bEnd; ++i)
     {
-        nY2 = aIter.GetPos();
-        nAdd = (long) *aIter;
+        nY2 = i;
+        nAdd = static_cast<long>(pTable->GetRowHeight(i));
         if (nSize+nAdd < nTwips && nY2<MAXROW)
         {
             nSize += nAdd;
             ++nY2;
-            ++aIter;
         }
         else
             bEnd = TRUE;
     }
-    if (!aIter)
-        nY2 = aIter.GetIterEnd();   // all hidden down to the bottom
+    if (!bEnd)
+        nY2 = MAXROW;   // all hidden down to the bottom
 
     return ScRange( nX1,nY1,nTab, nX2,nY2,nTab );
 }
@@ -1636,24 +1624,33 @@ void lcl_SnapVer( ScTable* pTable, long& rVal, SCROW& rStartRow )
     SCROW nRow = 0;
     long nTwips = (long) (rVal / HMM_PER_TWIPS);
     long nSnap = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            *(pTable->GetRowFlagsArray()), nRow, MAXROW, CR_HIDDEN, 0,
-            *(pTable->GetRowHeightArray()));
-    while ( aIter )
+
+    bool bFound = false;
+    for (SCROW i = nRow; i <= MAXROW; ++i)
     {
-        nRow = aIter.GetPos();
-        long nAdd = *aIter;
+        SCROW nLastRow;
+        if (pTable->RowHidden(i, NULL, &nLastRow))
+        {
+            i = nLastRow;
+            continue;
+        }
+
+        nRow = i;
+        long nAdd = pTable->GetRowHeight(i);
         if ( nSnap + nAdd/2 < nTwips || nRow < rStartRow )
         {
             nSnap += nAdd;
             ++nRow;
-            ++aIter;
         }
         else
+        {
+            bFound = true;
             break;
+        }
     }
-    if (!aIter)
+    if (!bFound)
         nRow = MAXROW;  // all hidden down to the bottom
+
     rVal = (long) ( nSnap * HMM_PER_TWIPS );
     rStartRow = nRow;
 }
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index de74b81..41ec85c 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -94,6 +94,7 @@
 #include "clipparam.hxx"
 
 #include <map>
+#include <limits>
 
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
 using ::com::sun::star::uno::Sequence;
@@ -2012,9 +2013,6 @@ void ScDocument::CopyNonFilteredFromClip( SCCOL nCol1, SCROW nRow1,
     while ( nFlagTab < MAXTAB && !ppClipTab[nFlagTab] )
         ++nFlagTab;
 
-    const ScBitMaskCompressedArray< SCROW, BYTE> & rSourceFlags =
-        pCBFCP->pClipDoc->GetRowFlagsArray( nFlagTab);
-
     SCROW nSourceRow = rClipStartRow;
     SCROW nSourceEnd = 0;
     if (pCBFCP->pClipDoc->GetClipParam().maRanges.Count())
@@ -2024,12 +2022,15 @@ void ScDocument::CopyNonFilteredFromClip( SCCOL nCol1, SCROW nRow1,
     while ( nSourceRow <= nSourceEnd && nDestRow <= nRow2 )
     {
         // skip filtered rows
-        nSourceRow = rSourceFlags.GetFirstForCondition( nSourceRow, nSourceEnd, CR_FILTERED, 0);
+        nSourceRow = pCBFCP->pClipDoc->FirstNonFilteredRow(nSourceRow, nSourceEnd, nFlagTab);
 
         if ( nSourceRow <= nSourceEnd )
         {
             // look for more non-filtered rows following
-            SCROW nFollow = rSourceFlags.GetBitStateEnd( nSourceRow, CR_FILTERED, 0) - nSourceRow;
+            SCROW nLastRow = nSourceRow;
+            pCBFCP->pClipDoc->RowFiltered(nSourceRow, nFlagTab, NULL, &nLastRow);
+            SCROW nFollow = nLastRow - nSourceRow;
+
             if (nFollow > nSourceEnd - nSourceRow)
                 nFollow = nSourceEnd - nSourceRow;
             if (nFollow > nRow2 - nDestRow)
@@ -2437,8 +2438,7 @@ void ScDocument::GetClipArea(SCCOL& nClipX, SCROW& nClipY, BOOL bIncludeFiltered
         while ( nCountTab < MAXTAB && !pTab[nCountTab] )
             ++nCountTab;
 
-        SCROW nResult = GetRowFlagsArray( nCountTab).CountForCondition(
-                nStartRow, nEndRow, CR_FILTERED, 0);
+        SCROW nResult = CountNonFilteredRows(nStartRow, nEndRow, nCountTab);
 
         if ( nResult > 0 )
             nClipY = nResult - 1;
@@ -2477,8 +2477,13 @@ BOOL ScDocument::HasClipFilteredRows()
     if (!rClipRanges.Count())
         return false;
 
-    return GetRowFlagsArray( nCountTab).HasCondition( rClipRanges.First()->aStart.Row(),
-            rClipRanges.First()->aEnd.Row(), CR_FILTERED, CR_FILTERED);
+    for (ScRange* p = rClipRanges.First(); p; p = rClipRanges.Next())
+    {
+        bool bAnswer = pTab[nCountTab]->HasFilteredRows(p->aStart.Row(), p->aEnd.Row());
+        if (bAnswer)
+            return true;
+    }
+    return false;
 }
 
 
@@ -3200,8 +3205,7 @@ ULONG ScDocument::GetRowHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab ) con
 ULONG ScDocument::FastGetRowHeight( SCROW nStartRow, SCROW nEndRow,
         SCTAB nTab ) const
 {
-    return pTab[nTab]->pRowFlags->SumCoupledArrayForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0, *(pTab[nTab]->pRowHeight));
+    return GetRowHeight(nStartRow, nEndRow, nTab);
 }
 
 ULONG ScDocument::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow,
@@ -3513,6 +3517,163 @@ Sequence<TablePageBreakData> ScDocument::GetRowBreakData(SCTAB nTab) const
     return pTab[nTab]->GetRowBreakData();
 }
 
+bool ScDocument::RowHidden(SCROW nRow, SCTAB nTab, SCROW* pFirstRow, SCROW* pLastRow)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return false;
+
+    return pTab[nTab]->RowHidden(nRow, pFirstRow, pLastRow);
+}
+
+bool ScDocument::RowHidden(SCROW nRow, SCTAB nTab, SCROW& rLastRow)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+    {
+        rLastRow = nRow;
+        return false;
+    }
+
+    return pTab[nTab]->RowHidden(nRow, rLastRow);
+}
+
+
+bool ScDocument::HasHiddenRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return false;
+
+    return pTab[nTab]->HasHiddenRows(nStartRow, nEndRow);
+}
+
+bool ScDocument::ColHidden(SCCOL nCol, SCTAB nTab, SCCOL& rLastCol)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+    {
+        rLastCol = nCol;
+        return false;
+    }
+
+    return pTab[nTab]->ColHidden(nCol, rLastCol);
+}
+
+bool ScDocument::ColHidden(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+    {
+        if (pFirstCol)
+            *pFirstCol = nCol;
+        if (pLastCol)
+            *pLastCol = nCol;
+        return false;
+    }
+
+    return pTab[nTab]->ColHidden(nCol, pFirstCol, pLastCol);
+}
+
+void ScDocument::SetRowHidden(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bHidden)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->SetRowHidden(nStartRow, nEndRow, bHidden);
+}
+
+void ScDocument::SetColHidden(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bHidden)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->SetColHidden(nStartCol, nEndCol, bHidden);
+}
+
+SCROW ScDocument::FirstVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->FirstVisibleRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::LastVisibleRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->LastVisibleRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::CountVisibleRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return 0;
+
+    return pTab[nTab]->CountVisibleRows(nStartRow, nEndRow);
+}
+
+bool ScDocument::RowFiltered(SCROW nRow, SCTAB nTab, SCROW* pFirstRow, SCROW* pLastRow)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return false;
+
+    return pTab[nTab]->RowFiltered(nRow, pFirstRow, pLastRow);
+}
+
+bool ScDocument::HasFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return false;
+
+    return pTab[nTab]->HasFilteredRows(nStartRow, nEndRow);
+}
+
+bool ScDocument::ColFiltered(SCCOL nCol, SCTAB nTab, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return false;
+
+    return pTab[nTab]->ColFiltered(nCol, pFirstCol, pLastCol);
+}
+
+void ScDocument::SetRowFiltered(SCROW nStartRow, SCROW nEndRow, SCTAB nTab, bool bFiltered)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->SetRowFiltered(nStartRow, nEndRow, bFiltered);
+}
+
+void ScDocument::SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, SCTAB nTab, bool bFiltered)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return;
+
+    pTab[nTab]->SetColFiltered(nStartCol, nEndCol, bFiltered);
+}
+
+SCROW ScDocument::FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->FirstNonFilteredRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return ::std::numeric_limits<SCROW>::max();;
+
+    return pTab[nTab]->LastNonFilteredRow(nStartRow, nEndRow);
+}
+
+SCROW ScDocument::CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow, SCTAB nTab)
+{
+    if (!ValidTab(nTab) || !pTab[nTab])
+        return 0;
+
+    return pTab[nTab]->CountNonFilteredRows(nStartRow, nEndRow);
+}
+
 void ScDocument::SyncColRowFlags()
 {
     for (SCTAB i = 0; i <= nMaxTableNumber; ++i)
diff --git sc/source/core/data/drwlayer.cxx sc/source/core/data/drwlayer.cxx
index 79126b8..4d23b2e 100755
--- sc/source/core/data/drwlayer.cxx
+++ sc/source/core/data/drwlayer.cxx
@@ -606,12 +606,14 @@ void ScDrawLayer::RecalcPos( SdrObject* pObj, const ScDrawObjData& rData, bool b
     {
         //!	nicht mehrere Undos fuer ein Objekt erzeugen (hinteres kann dann weggelassen werden)
 
+        SCCOL nLastCol;
+        SCROW nLastRow;
         if( bValid1 )
         {
             Point aPos( pDoc->GetColOffset( nCol1, nTab1 ), pDoc->GetRowOffset( nRow1, nTab1 ) );
-            if( (pDoc->GetColFlags( nCol1, nTab1 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->ColHidden(nCol1, nTab1, nLastCol))
                 aPos.X() += pDoc->GetColWidth( nCol1, nTab1 ) / 4;
-            if( (pDoc->GetRowFlags( nRow1, nTab1 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->RowHidden(nRow1, nTab1, nLastRow))
                 aPos.Y() += pDoc->GetRowHeight( nRow1, nTab1 ) / 2;
             TwipsToMM( aPos.X() );
             TwipsToMM( aPos.Y() );
@@ -643,9 +645,9 @@ void ScDrawLayer::RecalcPos( SdrObject* pObj, const ScDrawObjData& rData, bool b
         if( bValid2 )
         {
             Point aPos( pDoc->GetColOffset( nCol2, nTab2 ), pDoc->GetRowOffset( nRow2, nTab2 ) );
-            if( (pDoc->GetColFlags( nCol2, nTab2 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->ColHidden(nCol2, nTab2, nLastCol))
                 aPos.X() += pDoc->GetColWidth( nCol2, nTab2 ) / 4;
-            if( (pDoc->GetRowFlags( nRow2, nTab2 ) & CR_HIDDEN) == 0 )
+            if (!pDoc->RowHidden(nRow2, nTab2, nLastRow))
                 aPos.Y() += pDoc->GetRowHeight( nRow2, nTab2 ) / 2;
             TwipsToMM( aPos.X() );
             TwipsToMM( aPos.Y() );
diff --git sc/source/core/data/fillinfo.cxx sc/source/core/data/fillinfo.cxx
index c5f3ab4..b2626c3 100644
--- sc/source/core/data/fillinfo.cxx
+++ sc/source/core/data/fillinfo.cxx
@@ -52,7 +52,6 @@
 #include "conditio.hxx"
 #include "stlpool.hxx"
 
-
 // -----------------------------------------------------------------------
 
 const USHORT ROWINFO_MAX = 1024;
@@ -97,11 +96,13 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
     rStartY = nY;
     BOOL bHOver = pInfo->bHOverlapped;
     BOOL bVOver = pInfo->bVOverlapped;
+    SCCOL nLastCol;
+    SCROW nLastRow;
 
     while (bHOver)				// nY konstant
     {
         --rStartX;
-        if (rStartX >= (SCsCOL) nX1 && (pDoc->GetColFlags(rStartX,nTab) & CR_HIDDEN) == 0)
+        if (rStartX >= (SCsCOL) nX1 && !pDoc->ColHidden(rStartX, nTab, nLastCol))
         {
             bHOver = pRowInfo[nArrY].pCellInfo[rStartX+1].bHOverlapped;
             bVOver = pRowInfo[nArrY].pCellInfo[rStartX+1].bVOverlapped;
@@ -123,8 +124,8 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
             --nArrY;						// lokale Kopie !
 
         if (rStartX >= (SCsCOL) nX1 && rStartY >= (SCsROW) nY1 &&
-            (pDoc->GetColFlags(rStartX,nTab) & CR_HIDDEN) == 0 &&
-            (pDoc->GetRowFlags(rStartY,nTab) & CR_HIDDEN) == 0 &&
+            !pDoc->ColHidden(rStartX, nTab, nLastCol) &&
+            !pDoc->RowHidden(rStartY, nTab, nLastRow) &&
             (SCsROW) pRowInfo[nArrY].nRowNo == rStartY)
         {
             bHOver = pRowInfo[nArrY].pCellInfo[rStartX+1].bHOverlapped;
@@ -141,8 +142,8 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
 
     const ScMergeAttr* pMerge;
     if (rStartX >= (SCsCOL) nX1 && rStartY >= (SCsROW) nY1 &&
-        (pDoc->GetColFlags(rStartX,nTab) & CR_HIDDEN) == 0 &&
-        (pDoc->GetRowFlags(rStartY,nTab) & CR_HIDDEN) == 0 &&
+        !pDoc->ColHidden(rStartX, nTab, nLastCol) &&
+        !pDoc->RowHidden(rStartY, nTab, nLastRow) &&
         (SCsROW) pRowInfo[nArrY].nRowNo == rStartY)
     {
         pMerge = (const ScMergeAttr*) &pRowInfo[nArrY].pCellInfo[rStartX+1].pPatternAttr->
@@ -155,12 +156,6 @@ void lcl_GetMergeRange( SCsCOL nX, SCsROW nY, SCSIZE nArrY,
     rEndY = rStartY + pMerge->GetRowMerge() - 1;
 }
 
-inline BOOL ScDocument::RowHidden( SCROW nRow, SCTAB nTab )
-{
-    return ( pTab[nTab]->pRowFlags->GetValue(nRow) & CR_HIDDEN ) != 0;
-}
-
-
 #define CELLINFO(x,y) pRowInfo[nArrY+y].pCellInfo[nArrX+x]
 
 void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
@@ -356,7 +351,7 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
         nX = nArrX-1;
         if ( ValidCol(nX) )
         {
-            if ( (GetColFlags(nX,nTab) & CR_HIDDEN) == 0 )			// Spalte nicht versteckt
+            if (!ColHidden(nX, nTab))
             {
                 USHORT nThisWidth = (USHORT) (GetColWidth( nX, nTab ) * nScaleX);
                 if (!nThisWidth)
@@ -376,7 +371,8 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
             // #i58049#, #i57939# Hidden columns must be skipped here, or their attributes
             // will disturb the output
 
-            if ( (GetColFlags(nX,nTab) & CR_HIDDEN) == 0 )          // column not hidden
+            // TODO: Optimize this loop.
+            if (!ColHidden(nX, nTab))
             {
                 USHORT nThisWidth = (USHORT) (GetColWidth( nX, nTab ) * nScaleX);
                 if (!nThisWidth)
@@ -481,7 +477,14 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
 
                         do
                         {
-                            if ( nArrY==0 || !RowHidden( nCurRow,nTab ) )
+#define NEW_METHOD 1
+#if NEW_METHOD
+                            SCROW nLastHiddenRow = -1;
+                            bool bRowHidden = RowHidden(nCurRow, nTab, nLastHiddenRow);
+#else
+                            bool bRowHidden = RowHidden(nCurRow, nTab);
+#endif
+                            if ( nArrY==0 || !bRowHidden )
                             {
                                 RowInfo* pThisRowInfo = &pRowInfo[nArrY];
                                 if (pBackground != pDefBackground)			// Spalten-HG == Standard ?
@@ -551,6 +554,14 @@ void ScDocument::FillInfo( ScTableInfo& rTabInfo, SCCOL nX1, SCROW nY1, SCCOL nX
 
                                 ++nArrY;
                             }
+#if NEW_METHOD
+                            else if (bRowHidden && nLastHiddenRow >= 0)
+                            {
+                                nCurRow = nLastHiddenRow;
+                                if (nCurRow > nThisRow)
+                                    nCurRow = nThisRow;
+                            }
+#endif
                             ++nCurRow;
                         }
                         while (nCurRow <= nThisRow && nCurRow <= nYExtra);
diff --git sc/source/core/data/olinetab.cxx sc/source/core/data/olinetab.cxx
index d3e5942..75efebd 100644
--- sc/source/core/data/olinetab.cxx
+++ sc/source/core/data/olinetab.cxx
@@ -41,6 +41,7 @@
 #include "global.hxx"
 #include "rechead.hxx"
 #include "address.hxx"
+#include "table.hxx"
 
 //------------------------------------------------------------------------
 
@@ -637,8 +638,7 @@ BOOL ScOutlineArray::DeleteSpace( SCCOLROW nStartPos, SCSIZE nSize )
     return bNeedSave;
 }
 
-BOOL ScOutlineArray::ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos,
-        BOOL bShow, const ScBitMaskCompressedArray< SCCOLROW, BYTE>& rHiddenFlags )
+bool ScOutlineArray::ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos, bool bShow, ScTable& rTable, bool bCol )
 {
     BOOL bModified = FALSE;
     ScSubOutlineIterator aIter( this );
@@ -654,9 +654,7 @@ BOOL ScOutlineArray::ManualAction( SCCOLROW nStartPos, SCCOLROW nEndPos,
             {
                 //	#i12341# hide if all columns/rows are hidden, show if at least one
                 //	is visible
-
-                SCCOLROW nEnd = rHiddenFlags.GetBitStateEnd( nEntryStart,
-                        CR_HIDDEN, CR_HIDDEN);
+                SCCOLROW nEnd = rTable.LastHiddenColRow(nEntryStart, bCol);
                 BOOL bAllHidden = (nEntryEnd <= nEnd && nEnd <
                         ::std::numeric_limits<SCCOLROW>::max());
 
diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
index 519e8f2..f17c888 100644
--- sc/source/core/data/table1.cxx
+++ sc/source/core/data/table1.cxx
@@ -112,6 +112,7 @@
 #include "hints.hxx"		// fuer Paint-Broadcast
 #include "prnsave.hxx"
 #include "tabprotection.hxx"
+#include "segmenttree.hxx"
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -136,6 +137,10 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
     pRowHeight( NULL ),
     pColFlags( NULL ),
     pRowFlags( NULL ),
+    mpHiddenCols(new ScFlatBoolColSegments),
+    mpHiddenRows(new ScFlatBoolRowSegments),
+    mpFilteredCols(new ScFlatBoolColSegments),
+    mpFilteredRows(new ScFlatBoolRowSegments),
     pOutlineTable( NULL ),
     bTableAreaValid( FALSE ),
     bVisible( TRUE ),
@@ -975,9 +980,10 @@ BOOL ScTable::ValidNextPos( SCCOL nCol, SCROW nRow, const ScMarkData& rMark,
         //	auf der naechsten Zelle landet, auch wenn die geschuetzt/nicht markiert ist.
         //!	per Extra-Parameter steuern, nur fuer Cursor-Bewegung ???
 
-        if ( pRowFlags && ( pRowFlags->GetValue(nRow) & CR_HIDDEN ) )
+        if (RowHidden(nRow))
             return FALSE;
-        if ( pColFlags && ( pColFlags[nCol] & CR_HIDDEN ) )
+
+        if (ColHidden(nCol))
             return FALSE;
     }
 
@@ -1004,8 +1010,8 @@ void ScTable::GetNextPos( SCCOL& rCol, SCROW& rRow, SCsCOL nMovX, SCsROW nMovY,
     {
         BOOL bUp = ( nMovY < 0 );
         nRow = rMark.GetNextMarked( nCol, nRow, bUp );
-        while ( VALIDROW(nRow) && ((pRowFlags && (pRowFlags->GetValue(nRow) & CR_HIDDEN)) ||
-                pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
+        while ( VALIDROW(nRow) &&
+                (RowHidden(nRow) || pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
         {
             //	#53697# ausgeblendete ueberspringen (s.o.)
             nRow += nMovY;
@@ -1015,7 +1021,7 @@ void ScTable::GetNextPos( SCCOL& rCol, SCROW& rRow, SCsCOL nMovX, SCsROW nMovY,
         while ( nRow < 0 || nRow > MAXROW )
         {
             nCol = sal::static_int_cast<SCsCOL>( nCol + static_cast<SCsCOL>(nMovY) );
-            while ( VALIDCOL(nCol) && pColFlags && (pColFlags[nCol] & CR_HIDDEN) )
+            while ( VALIDCOL(nCol) && ColHidden(nCol) )
                 nCol = sal::static_int_cast<SCsCOL>( nCol + static_cast<SCsCOL>(nMovY) );   //	#53697# skip hidden rows (see above)
             if (nCol < 0)
             {
@@ -1034,8 +1040,8 @@ void ScTable::GetNextPos( SCCOL& rCol, SCROW& rRow, SCsCOL nMovX, SCsROW nMovY,
             else if (nRow > MAXROW)
                 nRow = 0;
             nRow = rMark.GetNextMarked( nCol, nRow, bUp );
-            while ( VALIDROW(nRow) && ((pRowFlags && (pRowFlags->GetValue(nRow) & CR_HIDDEN)) ||
-                    pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
+            while ( VALIDROW(nRow) &&
+                    (RowHidden(nRow) || pDocument->HasAttrib(nCol, nRow, nTab, nCol, nRow, nTab, HASATTR_OVERLAPPED)) )
             {
                 //	#53697# ausgeblendete ueberspringen (s.o.)
                 nRow += nMovY;
@@ -1432,19 +1438,14 @@ void ScTable::ExtendPrintArea( OutputDevice* pDev,
 
     SCSIZE nIndex;
     SCCOL nPrintCol = rEndCol;
-    SCSIZE nRowFlagsIndex;
-    SCROW nRowFlagsEndRow;
-    BYTE nRowFlag = pRowFlags->GetValue( nStartRow, nRowFlagsIndex, nRowFlagsEndRow);
     for (SCROW nRow = nStartRow; nRow<=nEndRow; nRow++)
     {
-        if (nRow > nRowFlagsEndRow)
-            nRowFlag = pRowFlags->GetNextValue( nRowFlagsIndex, nRowFlagsEndRow);
-        if ( ( nRowFlag & CR_HIDDEN ) == 0 )
+        if (!RowHidden(nRow))
         {
             SCCOL nDataCol = rEndCol;
             while (nDataCol > 0 && ( bEmpty[nDataCol] || !aCol[nDataCol].Search(nRow,nIndex) ) )
                 --nDataCol;
-            if ( ( pColFlags[nDataCol] & CR_HIDDEN ) == 0 )
+            if (!ColHidden(nDataCol))
             {
                 ScBaseCell* pCell = aCol[nDataCol].GetCell(nRow);
                 if (pCell)
diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
index c66b933..14e6aef 100644
--- sc/source/core/data/table2.cxx
+++ sc/source/core/data/table2.cxx
@@ -129,6 +129,9 @@ void ScTable::InsertRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
         }
         if (pOutlineTable)
             pOutlineTable->InsertRow( nStartRow, nSize );
+
+        mpFilteredRows->insertSegment(nStartRow, nSize, true);
+        mpHiddenRows->insertSegment(nStartRow, nSize, true);
     }
 
     for (SCCOL j=nStartCol; j<=nEndCol; j++)
@@ -155,6 +158,9 @@ void ScTable::DeleteRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
             if (pOutlineTable->DeleteRow( nStartRow, nSize ))
                 if (pUndoOutline)
                     *pUndoOutline = TRUE;
+
+        mpFilteredRows->removeSegment(nStartRow, nStartRow+nSize);
+        mpHiddenRows->removeSegment(nStartRow, nStartRow+nSize);
     }
 
     {   // scope for bulk broadcast
@@ -200,6 +206,9 @@ void ScTable::InsertCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
         }
         if (pOutlineTable)
             pOutlineTable->InsertCol( nStartCol, nSize );
+
+        mpHiddenCols->insertSegment(nStartCol, nSize, true);
+        mpFilteredCols->insertSegment(nStartCol, nSize, true);
     }
 
 
@@ -254,6 +263,9 @@ void ScTable::DeleteCol( SCCOL nStartCol, SCROW nStartRow, SCROW nEndRow, SCSIZE
             if (pOutlineTable->DeleteCol( nStartCol, nSize ))
                 if (pUndoOutline)
                     *pUndoOutline = TRUE;
+
+        mpHiddenCols->removeSegment(nStartCol, nStartCol+nSize);
+        mpFilteredCols->removeSegment(nStartCol, nStartCol+nSize);
     }
 
 
@@ -348,20 +360,21 @@ void ScTable::CopyToClip(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
         //	copy widths/heights, and only "hidden", "filtered" and "manual" flags
         //	also for all preceding columns/rows, to have valid positions for drawing objects
 
-        if (pColFlags && pTable->pColFlags && pColWidth && pTable->pColWidth)
+        if (pColWidth && pTable->pColWidth)
             for (i=0; i<=nCol2; i++)
-            {
-                pTable->pColFlags[i] = pColFlags[i] & CR_HIDDEN;
                 pTable->pColWidth[i] = pColWidth[i];
-            }
+
+        pTable->CopyColHidden(*this, 0, nCol2);
+        pTable->CopyColFiltered(*this, 0, nCol2);
 
         if (pRowFlags && pTable->pRowFlags && pRowHeight && pTable->pRowHeight)
         {
-            pTable->pRowFlags->CopyFromAnded( *pRowFlags, 0, nRow2,
-                    (CR_HIDDEN | CR_FILTERED | CR_MANUALSIZE));
+            pTable->pRowFlags->CopyFromAnded( *pRowFlags, 0, nRow2, CR_MANUALSIZE);
             pTable->pRowHeight->CopyFrom( *pRowHeight, 0, nRow2);
         }
 
+        pTable->CopyRowHidden(*this, 0, nRow2);
+        pTable->CopyRowFiltered(*this, 0, nRow2);
 
         //	ggf. Formeln durch Werte ersetzen
 
@@ -650,10 +663,12 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                 if (bWidth)
                     for (SCCOL i=nCol1; i<=nCol2; i++)
                     {
-                        bool bHiddenChange = ( pDestTab->pColFlags[i] & CR_HIDDEN ) != ( pColFlags[i] & CR_HIDDEN );
+                    bool bThisHidden = ColHidden(i);
+                    bool bHiddenChange = (pDestTab->ColHidden(i) != bThisHidden);
                         bool bChange = bHiddenChange || (pDestTab->pColWidth[i] != pColWidth[i]);
                         pDestTab->pColWidth[i] = pColWidth[i];
                         pDestTab->pColFlags[i] = pColFlags[i];
+                    pDestTab->SetColHidden(i, i, bThisHidden);
                         //!	Aenderungen zusammenfassen?
                         if (bHiddenChange && pCharts)
                             pCharts->SetRangeDirty(ScRange( i, 0, nTab, i, MAXROW, nTab ));
@@ -675,8 +690,10 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
                         // TODO: might need some performance improvement, block
                         // operations instead of single GetValue()/SetValue() calls.
                         BYTE nThisRowFlags = pRowFlags->GetValue(i);
-                        bool bHiddenChange = ( pDestTab->pRowFlags->GetValue(i) & CR_HIDDEN ) != ( nThisRowFlags & CR_HIDDEN );
+                    bool bThisHidden = RowHidden(i);
+                    bool bHiddenChange = (pDestTab->RowHidden(i) != bThisHidden);
                         pDestTab->pRowFlags->SetValue( i, nThisRowFlags );
+                    pDestTab->SetRowHidden(i, i, bThisHidden);
                         //!	Aenderungen zusammenfassen?
                         if (bHiddenChange && pCharts)
                             pCharts->SetRangeDirty(ScRange( 0, i, nTab, MAXCOL, i, nTab ));
@@ -1278,7 +1295,7 @@ BOOL ScTable::IsBlockEmpty( SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
 
 SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2,
                             SCCOL nCol, SCROW nAttrRow1, SCROW nAttrRow2, SCSIZE nArrY,
-                            const ScPatternAttr* pPattern, const SfxItemSet* pCondSet ) const
+                            const ScPatternAttr* pPattern, const SfxItemSet* pCondSet )
 {
     //	Rueckgabe = neues nArrY
 
@@ -1311,7 +1328,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
 
             for ( SCROW nRow = nAttrRow1; nRow <= nAttrRow2; nRow++ )
             {
-                if ( !(pRowFlags->GetValue(nRow) & CR_HIDDEN) )
+                if (!RowHidden(nRow))
                 {
                     BOOL bHitOne = TRUE;
                     if ( nCol > nX2+1 )
@@ -1345,7 +1362,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
     return nArrY;
 }
 
-void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 ) const
+void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 )
 {
     if ( !pColWidth || !pRowHeight || !pColFlags || !pRowFlags )
     {
@@ -1360,7 +1377,7 @@ void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCC
 
     for (SCCOL nCol=0; nCol<=MAXCOL; nCol++)
     {
-        if ( !(pColFlags[nCol] & CR_HIDDEN) )
+        if (!ColHidden(nCol))
         {
             SCSIZE nArrY = 0;
             ScDocAttrIterator aIter( pDocument, nTab, nCol, nY1, nCol, nY2 );
@@ -2136,13 +2153,13 @@ void ScTable::SetManualHeight( SCROW nStartRow, SCROW nEndRow, BOOL bManual )
 }
 
 
-USHORT ScTable::GetColWidth( SCCOL nCol ) const
+USHORT ScTable::GetColWidth( SCCOL nCol )
 {
     DBG_ASSERT(VALIDCOL(nCol),"Falsche Spaltennummer");
 
     if (VALIDCOL(nCol) && pColFlags && pColWidth)
     {
-        if ( pColFlags[nCol] & CR_HIDDEN )
+        if (ColHidden(nCol))
             return 0;
         else
             return pColWidth[nCol];
@@ -2163,7 +2180,7 @@ USHORT ScTable::GetOriginalWidth( SCCOL nCol ) const		// immer die eingestellte
 }
 
 
-USHORT ScTable::GetCommonWidth( SCCOL nEndCol ) const
+USHORT ScTable::GetCommonWidth( SCCOL nEndCol )
 {
     //	get the width that is used in the largest continuous column range (up to nEndCol)
 
@@ -2175,24 +2192,24 @@ USHORT ScTable::GetCommonWidth( SCCOL nEndCol ) const
 
     USHORT nMaxWidth = 0;
     USHORT nMaxCount = 0;
-    USHORT nRangeStart = 0;
+    SCCOL nRangeStart = 0;
     while ( nRangeStart <= nEndCol )
     {
         //	skip hidden columns
-        while ( nRangeStart <= nEndCol && (pColFlags[nRangeStart] & CR_HIDDEN) )
+        while ( nRangeStart <= nEndCol && ColHidden(nRangeStart) )
             ++nRangeStart;
         if ( nRangeStart <= nEndCol )
         {
             USHORT nThisCount = 0;
             USHORT nThisWidth = pColWidth[nRangeStart];
-            USHORT nRangeEnd = nRangeStart;
+            SCCOL nRangeEnd = nRangeStart;
             while ( nRangeEnd <= nEndCol && pColWidth[nRangeEnd] == nThisWidth )
             {
                 ++nThisCount;
                 ++nRangeEnd;
 
                 //	skip hidden columns
-                while ( nRangeEnd <= nEndCol && (pColFlags[nRangeEnd] & CR_HIDDEN) )
+                while ( nRangeEnd <= nEndCol && ColHidden(nRangeEnd) )
                     ++nRangeEnd;
             }
 
@@ -2210,13 +2227,13 @@ USHORT ScTable::GetCommonWidth( SCCOL nEndCol ) const
 }
 
 
-USHORT ScTable::GetRowHeight( SCROW nRow ) const
+USHORT ScTable::GetRowHeight( SCROW nRow )
 {
     DBG_ASSERT(VALIDROW(nRow),"Falsche Zeilennummer");
 
-    if (VALIDROW(nRow) && pRowFlags && pRowHeight)
+    if (VALIDROW(nRow) && pRowHeight)
     {
-        if ( pRowFlags->GetValue(nRow) & CR_HIDDEN )
+        if (RowHidden(nRow))
             return 0;
         else
             return pRowHeight->GetValue(nRow);
@@ -2226,28 +2243,53 @@ USHORT ScTable::GetRowHeight( SCROW nRow ) const
 }
 
 
-ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow ) const
+ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow )
 {
     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
 
-    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowFlags && pRowHeight)
+    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
     {
-        return pRowFlags->SumCoupledArrayForCondition( nStartRow, nEndRow,
-                CR_HIDDEN, 0, *pRowHeight);
+        ULONG nHeight = 0;
+        SCROW nRow = nStartRow;
+        while (nRow <= nEndRow)
+        {
+            SCROW nLastRow = -1;
+            if (!RowHidden(nRow, nLastRow))
+            {
+                if (nLastRow > nEndRow)
+                    nLastRow = nEndRow;
+                nHeight += pRowFlags->SumCoupledArrayForCondition(nRow, nLastRow, 0, 0, *pRowHeight);
+            }
+            nRow = nLastRow + 1;
+        }
+        return nHeight;
     }
     else
         return (ULONG) ((nEndRow - nStartRow + 1) * ScGlobal::nStdRowHeight);
 }
 
 
-ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale ) const
+ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale )
 {
     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
 
-    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowFlags && pRowHeight)
+    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
     {
-        return pRowFlags->SumScaledCoupledArrayForCondition( nStartRow,
-                nEndRow, CR_HIDDEN, 0, *pRowHeight, fScale);
+        ULONG nHeight = 0;
+        SCROW nRow = nStartRow;
+        while (nRow <= nEndRow)
+        {
+            SCROW nLastRow = -1;
+            if (!RowHidden(nRow, nLastRow))
+            {
+                if (nLastRow > nEndRow)
+                    nLastRow = nEndRow;
+                nHeight += pRowFlags->SumScaledCoupledArrayForCondition(
+                    nRow, nLastRow, 0, 0, *pRowHeight, fScale);
+            }
+            nRow = nLastRow + 1;
+        }
+        return nHeight;
     }
     else
         return (ULONG) ((nEndRow - nStartRow + 1) * ScGlobal::nStdRowHeight * fScale);
@@ -2268,18 +2310,16 @@ USHORT ScTable::GetOriginalHeight( SCROW nRow ) const		// non-0 even if hidden
 //	Spalten-/Zeilen-Flags
 
 
-SCROW ScTable::GetHiddenRowCount( SCROW nRow ) const
+SCROW ScTable::GetHiddenRowCount( SCROW nRow )
 {
-    SCROW nEndRow = nRow;
-    if ( pRowFlags )
-    {
-        nEndRow = pRowFlags->GetBitStateEnd( nRow, CR_HIDDEN, CR_HIDDEN);
-        if (ValidRow(nEndRow))
-            ++nEndRow;
-        else
-            nEndRow = nRow;
-    }
-    return nEndRow - nRow;
+    if (!ValidRow(nRow))
+        return 0;
+
+    SCROW nLastRow = -1;
+    if (!RowHidden(nRow, nLastRow) || !ValidRow(nLastRow))
+        return 0;
+
+    return nLastRow - nRow + 1;
 }
 
 
@@ -2287,9 +2327,9 @@ SCROW ScTable::GetHiddenRowCount( SCROW nRow ) const
 
 void ScTable::ShowCol(SCCOL nCol, BOOL bShow)
 {
-    if (VALIDCOL(nCol) && pColFlags)
+    if (VALIDCOL(nCol))
     {
-        BOOL bWasVis = ( pColFlags[nCol] & CR_HIDDEN ) == 0;
+        bool bWasVis = !ColHidden(nCol);
         if (bWasVis != bShow)
         {
             IncRecalcLevel();
@@ -2303,10 +2343,8 @@ void ScTable::ShowCol(SCCOL nCol, BOOL bShow)
                     pDrawLayer->WidthChanged( nTab, nCol, -(long) pColWidth[nCol] );
             }
 
-            if (bShow)
-                pColFlags[nCol] &= ~CR_HIDDEN;
-            else
-                pColFlags[nCol] |= CR_HIDDEN;
+            SetColHidden(nCol, nCol, !bShow);
+
             DecRecalcLevel();
 
             ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
@@ -2325,8 +2363,7 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
 {
     if (VALIDROW(nRow) && pRowFlags)
     {
-        BYTE nFlags = pRowFlags->GetValue(nRow);
-        BOOL bWasVis = ( nFlags & CR_HIDDEN ) == 0;
+        bool bWasVis = !RowHidden(nRow);
         if (bWasVis != bShow)
         {
             IncRecalcLevel();
@@ -2340,10 +2377,10 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
                     pDrawLayer->HeightChanged( nTab, nRow, -(long) pRowHeight->GetValue(nRow) );
             }
 
+            SetRowHidden(nRow, nRow, !bShow);
             if (bShow)
-                pRowFlags->SetValue( nRow, nFlags & ~(CR_HIDDEN | CR_FILTERED));
-            else
-                pRowFlags->SetValue( nRow, nFlags | CR_HIDDEN);
+                SetRowFiltered(nRow, nRow, false);
+
             DecRecalcLevel();
 
             ScChartListenerCollection* pCharts = pDocument->GetChartListenerCollection();
@@ -2364,8 +2401,7 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
 {
     if (VALIDROW(nRow) && pRowFlags)
     {
-        BYTE nFlags = pRowFlags->GetValue(nRow);
-        BOOL bWasVis = ( nFlags & CR_HIDDEN ) == 0;
+        bool bWasVis = !RowHidden(nRow);
         IncRecalcLevel();
         InitializeNoteCaptions();
         if (bWasVis != bShow)
@@ -2381,10 +2417,10 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
         }
 
         //	Filter-Flag immer setzen, auch wenn Hidden unveraendert
-        if (bShow)
-            pRowFlags->SetValue( nRow, nFlags & ~(CR_HIDDEN | CR_FILTERED));
-        else
-            pRowFlags->SetValue( nRow, nFlags | (CR_HIDDEN | CR_FILTERED));
+
+        SetRowHidden(nRow, nRow, !bShow);
+        SetRowFiltered(nRow, nRow, !bShow);
+
         DecRecalcLevel();
 
         if (bWasVis != bShow)
@@ -2411,12 +2447,11 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
     SCROW nStartRow = nRow1;
     while (nStartRow <= nRow2)
     {
-        BYTE nOldFlag = pRowFlags->GetValue(nStartRow) & CR_HIDDEN;
-        SCROW nEndRow = pRowFlags->GetBitStateEnd( nStartRow, CR_HIDDEN, nOldFlag);
+        SCROW nEndRow = -1;
+        bool bWasVis = !RowHidden(nStartRow, nEndRow);
         if (nEndRow > nRow2)
             nEndRow = nRow2;
 
-        BOOL bWasVis = ( nOldFlag == 0 );
         BOOL bChanged = ( bWasVis != bShow );
         if ( bChanged )
         {
@@ -2431,10 +2466,8 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             }
         }
 
-        if (bShow)
-            pRowFlags->AndValue( nStartRow, nEndRow, sal::static_int_cast<BYTE>(~(CR_HIDDEN | CR_FILTERED)) );
-        else
-            pRowFlags->OrValue( nStartRow, nEndRow, (CR_HIDDEN | CR_FILTERED));
+        SetRowHidden(nStartRow, nEndRow, !bShow);
+        SetRowFiltered(nStartRow, nEndRow, !bShow);
 
         if ( bChanged )
         {
@@ -2461,12 +2494,11 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
     InitializeNoteCaptions();
     while (nStartRow <= nRow2)
     {
-        BYTE nOldFlag = pRowFlags->GetValue(nStartRow) & CR_HIDDEN;
-        SCROW nEndRow = pRowFlags->GetBitStateEnd( nStartRow, CR_HIDDEN, nOldFlag);
+        SCROW nEndRow = -1;
+        bool bWasVis = !RowHidden(nStartRow, nEndRow);
         if (nEndRow > nRow2)
             nEndRow = nRow2;
 
-        BOOL bWasVis = ( nOldFlag == 0 );
         BOOL bChanged = ( bWasVis != bShow );
         if ( bChanged )
         {
@@ -2481,10 +2513,9 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
             }
         }
 
+        SetRowHidden(nStartRow, nEndRow, !bShow);
         if (bShow)
-            pRowFlags->AndValue( nStartRow, nEndRow, sal::static_int_cast<BYTE>(~(CR_HIDDEN | CR_FILTERED)) );
-        else
-            pRowFlags->OrValue( nStartRow, nEndRow, CR_HIDDEN);
+            SetRowFiltered(nStartRow, nEndRow, false);
 
         if ( bChanged )
         {
@@ -2501,16 +2532,6 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
 }
 
 
-BOOL ScTable::IsFiltered(SCROW nRow) const
-{
-    if (VALIDROW(nRow) && pRowFlags)
-        return ( pRowFlags->GetValue(nRow) & CR_FILTERED ) != 0;
-
-    DBG_ERROR("Falsche Zeilennummer oder keine Flags");
-    return FALSE;
-}
-
-
 void ScTable::SetColFlags( SCCOL nCol, BYTE nNewFlags )
 {
     if (VALIDCOL(nCol) && pColFlags)
@@ -2608,7 +2629,7 @@ BOOL ScTable::UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, BOOL bShow )
     if (pOutlineTable && pColFlags)
     {
         ScBitMaskCompressedArray< SCCOLROW, BYTE> aArray( MAXCOL, pColFlags, MAXCOLCOUNT);
-        return pOutlineTable->GetColArray()->ManualAction( nStartCol, nEndCol, bShow, aArray );
+        return pOutlineTable->GetColArray()->ManualAction( nStartCol, nEndCol, bShow, *this, true );
     }
     else
         return FALSE;
@@ -2618,7 +2639,7 @@ BOOL ScTable::UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, BOOL bShow )
 BOOL ScTable::UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, BOOL bShow )
 {
     if (pOutlineTable && pRowFlags)
-        return pOutlineTable->GetRowArray()->ManualAction( nStartRow, nEndRow, bShow, *pRowFlags );
+        return pOutlineTable->GetRowArray()->ManualAction( nStartRow, nEndRow, bShow, *this, false );
     else
         return FALSE;
 }
@@ -2626,54 +2647,58 @@ BOOL ScTable::UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, BOOL bShow )
 
 void ScTable::ExtendHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 )
 {
-    if (pColFlags)
-    {
-        while ( rX1>0 ? (pColFlags[rX1-1] & CR_HIDDEN) : FALSE )
-            --rX1;
-        while ( rX2<MAXCOL ? (pColFlags[rX2+1] & CR_HIDDEN) : FALSE )
-            ++rX2;
-    }
-    if (pRowFlags)
+    // Column-wise expansion
+
+    while (rX1 > 0 && ColHidden(rX1-1))
+        --rX1;
+
+    while (rX2 < MAXCOL && ColHidden(rX2+1))
+        ++rX2;
+
+    // Row-wise expansion
+
+    if (rY1 > 0)
     {
-        if (rY1 > 0)
+        ScFlatBoolRowSegments::RangeData aData;
+        if (mpHiddenRows->getRangeData(rY1-1, aData) && aData.mbValue)
         {
-            SCROW nStartRow = pRowFlags->GetBitStateStart( rY1-1, CR_HIDDEN, CR_HIDDEN);
+            SCROW nStartRow = aData.mnRow1;
             if (ValidRow(nStartRow))
                 rY1 = nStartRow;
         }
-        if (rY2 < MAXROW)
-        {
-            SCROW nEndRow = pRowFlags->GetBitStateEnd( rY2+1, CR_HIDDEN, CR_HIDDEN);
-            if (ValidRow(nEndRow))
-                rY2 = nEndRow;
-        }
+    }
+    if (rY2 < MAXROW)
+    {
+        SCROW nEndRow = -1;
+        if (RowHidden(rY2+1, nEndRow) && ValidRow(nEndRow))
+            rY2 = nEndRow;
     }
 }
 
 
 void ScTable::StripHidden( SCCOL& rX1, SCROW& rY1, SCCOL& rX2, SCROW& rY2 )
 {
-    if (pColFlags)
-    {
-        while ( rX2>rX1 && (pColFlags[rX2] & CR_HIDDEN) )
-            --rX2;
-        while ( rX2>rX1 && (pColFlags[rX1] & CR_HIDDEN) )
-            ++rX1;
-    }
-    if (pRowFlags)
+    while ( rX2>rX1 && ColHidden(rX2) )
+        --rX2;
+    while ( rX2>rX1 && ColHidden(rX1) )
+        ++rX1;
+
+    if (rY1 < rY2)
     {
-        if (rY1 < rY2)
+        ScFlatBoolRowSegments::RangeData aData;
+        if (mpHiddenRows->getRangeData(rY2, aData) && aData.mbValue)
         {
-            SCROW nStartRow = pRowFlags->GetBitStateStart( rY2, CR_HIDDEN, CR_HIDDEN);
+            SCROW nStartRow = aData.mnRow1;
             if (ValidRow(nStartRow) && nStartRow >= rY1)
                 rY2 = nStartRow;
         }
-        if (rY1 < rY2)
-        {
-            SCROW nEndRow = pRowFlags->GetBitStateEnd( rY1, CR_HIDDEN, CR_HIDDEN);
-            if (ValidRow(nEndRow) && nEndRow <= rY2)
-                rY1 = nEndRow;
-        }
+    }
+
+    if (rY1 < rY2)
+    {
+        SCROW nEndRow = -1;
+        if (RowHidden(rY1, nEndRow) && ValidRow(nEndRow) && nEndRow <= rY2)
+            rY1 = nEndRow;
     }
 }
 
@@ -2835,16 +2860,16 @@ BOOL ScTable::RefVisible(ScFormulaCell* pCell)
 
     if (pCell->HasOneReference(aRef))
     {
-        if (aRef.aStart.Col()==aRef.aEnd.Col() && aRef.aStart.Tab()==aRef.aEnd.Tab() && pRowFlags)
+        if (aRef.aStart.Col()==aRef.aEnd.Col() && aRef.aStart.Tab()==aRef.aEnd.Tab())
         {
-            // while ((value & CR_FILTERED) == CR_FILTERED)
-            // most times will be faster than
-            // while ((value & CR_FILTERED) == 0)
-            SCROW nEndRow = pRowFlags->GetBitStateEnd( aRef.aStart.Row(),
-                    CR_FILTERED, CR_FILTERED);
+            SCROW nEndRow;
+            if (!RowFiltered(aRef.aStart.Row(), NULL, &nEndRow))
+                // row not filtered.
+                nEndRow = ::std::numeric_limits<SCROW>::max();
+
             if (!ValidRow(nEndRow) || nEndRow < aRef.aEnd.Row())
                 return TRUE;    // at least partly visible
-            return FALSE;       // completely unvisible
+            return FALSE;       // completely invisible
         }
     }
 
@@ -2886,7 +2911,7 @@ void ScTable::SetDrawPageSize(bool bResetStreamValid, bool bUpdateNoteCaptionPos
 }
 
 
-ULONG ScTable::GetRowOffset( SCROW nRow ) const
+ULONG ScTable::GetRowOffset( SCROW nRow )
 {
     ULONG n = 0;
     if ( pRowFlags && pRowHeight )
@@ -2896,8 +2921,7 @@ ULONG ScTable::GetRowOffset( SCROW nRow ) const
         else if (nRow == 1)
             return GetRowHeight(0);
 
-        n = pRowFlags->SumCoupledArrayForCondition( 0, nRow-1, CR_HIDDEN, 0,
-                *pRowHeight);
+        n = GetTotalRowHeight(0, nRow-1);
 #ifdef DBG_UTIL
         if (n == ::std::numeric_limits<unsigned long>::max())
             DBG_ERRORFILE("ScTable::GetRowOffset: row heights overflow");
@@ -2910,18 +2934,42 @@ ULONG ScTable::GetRowOffset( SCROW nRow ) const
     return n;
 }
 
+SCROW ScTable::GetRowForHeight(ULONG nHeight)
+{
+    sal_uInt32 nSum = 0;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    for (SCROW nRow = 0; nRow <= MAXROW; ++nRow)
+    {
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mbValue)
+        {
+            nRow = aData.mnRow2;
+            continue;
+        }
+
+        sal_uInt32 nNew = pRowHeight->GetValue(nRow);
+        nSum += nNew;
+        if (nSum > nHeight)
+        {
+            return nRow < MAXROW ? nRow + 1 : MAXROW;
+        }
+    }
+    return -1;
+}
+
 
-ULONG ScTable::GetColOffset( SCCOL nCol ) const
+ULONG ScTable::GetColOffset( SCCOL nCol )
 {
     ULONG n = 0;
-    if ( pColFlags && pColWidth )
+    if ( pColWidth )
     {
         SCCOL i;
-        BYTE* pFlags = pColFlags;
-        USHORT* pWidth = pColWidth;
-        for( i = 0; i < nCol; i++, pFlags++, pWidth++ )
-            if( !( *pFlags & CR_HIDDEN ) )
-                n += *pWidth;
+        for( i = 0; i < nCol; i++ )
+            if (!ColHidden(i))
+                n += pColWidth[i];
     }
     else
     {
diff --git sc/source/core/data/table3.cxx sc/source/core/data/table3.cxx
index 1557922..f05eec0 100644
--- sc/source/core/data/table3.cxx
+++ sc/source/core/data/table3.cxx
@@ -601,14 +601,17 @@ void ScTable::SwapRow(SCROW nRow1, SCROW nRow2)
             }
         }
     }
-    if (bGlobalKeepQuery && pRowFlags)
+    if (bGlobalKeepQuery)
     {
-        BYTE nRow1Flags = pRowFlags->GetValue(nRow1);
-        BYTE nRow2Flags = pRowFlags->GetValue(nRow2);
-        BYTE nFlags1 = nRow1Flags & ( CR_HIDDEN | CR_FILTERED );
-        BYTE nFlags2 = nRow2Flags & ( CR_HIDDEN | CR_FILTERED );
-        pRowFlags->SetValue( nRow1, (nRow1Flags & ~( CR_HIDDEN | CR_FILTERED )) | nFlags2);
-        pRowFlags->SetValue( nRow2, (nRow2Flags & ~( CR_HIDDEN | CR_FILTERED )) | nFlags1);
+        bool bRow1Hidden = RowHidden(nRow1);
+        bool bRow2Hidden = RowHidden(nRow2);
+        SetRowHidden(nRow1, nRow1, bRow2Hidden);
+        SetRowHidden(nRow2, nRow2, bRow1Hidden);
+
+        bool bRow1Filtered = RowFiltered(nRow1);
+        bool bRow2Filtered = RowFiltered(nRow2);
+        SetRowFiltered(nRow1, nRow1, bRow2Filtered);
+        SetRowFiltered(nRow2, nRow2, bRow1Filtered);
     }
 }
 
@@ -989,13 +992,6 @@ BOOL ScTable::DoSubTotals( ScSubTotalParam& rParam )
                         SetString( nGroupCol[aRowEntry.nGroupNo], aRowEntry.nDestRow, nTab, aOutString );
                         ApplyStyle( nGroupCol[aRowEntry.nGroupNo], aRowEntry.nDestRow, *pStyle );
 
-/*						if (rParam.bPagebreak && nRow < MAXROW)
-                        {
-                            BYTE nFlags = GetRowFlags( nRow+1 );
-                            nFlags |= CR_MANUALBREAK;
-                            SetRowFlags( nRow+1, nFlags );
-                        }
-*/
                         ++nRow;
                         ++nEndRow;
                         aRowEntry.nSubStartRow = nRow;
@@ -1009,11 +1005,7 @@ BOOL ScTable::DoSubTotals( ScSubTotalParam& rParam )
                         }
                     }
                 }
-                if (!pRowFlags)
-                    bBlockVis = TRUE;
-                else
-                    if ( (pRowFlags->GetValue(nRow) & CR_FILTERED) == 0 )
-                        bBlockVis = TRUE;
+                bBlockVis = !RowFiltered(nRow);
             }
         }
         else
@@ -2055,8 +2047,8 @@ void ScTable::UpdateSelectionFunction( ScFunctionData& rData,
     SCCOL nCol;
     if ( rMark.IsMultiMarked() )
         for (nCol=0; nCol<=MAXCOL && !rData.bError; nCol++)
-            if ( !pColFlags || !( pColFlags[nCol] & CR_HIDDEN ) )
-                aCol[nCol].UpdateSelectionFunction( rMark, rData, pRowFlags,
+            if ( !pColFlags || !ColHidden(nCol) )
+                aCol[nCol].UpdateSelectionFunction( rMark, rData, *mpHiddenRows,
                                                     bSingle && ( nCol >= nStartCol && nCol <= nEndCol ),
                                                     nStartRow, nEndRow );
 
@@ -2064,8 +2056,8 @@ void ScTable::UpdateSelectionFunction( ScFunctionData& rData,
 
     if ( bSingle && !rMark.IsMarkNegative() )
         for (nCol=nStartCol; nCol<=nEndCol && !rData.bError; nCol++)
-            if ( !pColFlags || !( pColFlags[nCol] & CR_HIDDEN ) )
-                aCol[nCol].UpdateAreaFunction( rData, pRowFlags, nStartRow, nEndRow );
+            if ( !pColFlags || !ColHidden(nCol) )
+                aCol[nCol].UpdateAreaFunction( rData, *mpHiddenRows, nStartRow, nEndRow );
 }
 
 void ScTable::FindConditionalFormat( ULONG nKey, ScRangeList& rList )
diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
index f87bfd3..cc4438e 100644
--- sc/source/core/data/table5.cxx
+++ sc/source/core/data/table5.cxx
@@ -50,9 +50,11 @@
 #include "brdcst.hxx"
 #include "tabprotection.hxx"
 #include "globstr.hrc"
+#include "segmenttree.hxx"
 #include <com/sun/star/sheet/TablePageBreakData.hpp>
 
 #include <algorithm>
+#include <limits>
 
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::sheet::TablePageBreakData;
@@ -165,7 +167,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     for (nX=nStartCol; nX<=nEndCol; nX++)
     {
         BOOL bStartOfPage = FALSE;
-        long nThisX = ( pColFlags[nX] & CR_HIDDEN ) ? 0 : pColWidth[nX];
+        long nThisX = ColHidden(nX) ? 0 : pColWidth[nX];
         bool bManualBreak = HasColManualBreak(nX);
         if ( (nSizeX+nThisX > nPageSizeX) || (bManualBreak && !bSkipBreaks) )
         {
@@ -182,7 +184,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
         {
             // subtract size of repeat columns from page size
             for (SCCOL i=nRepeatStartX; i<=nRepeatEndX; i++)
-                nPageSizeX -= ( pColFlags[i] & CR_HIDDEN ) ? 0 : pColWidth[i];
+                nPageSizeX -= ColHidden(i) ? 0 : pColWidth[i];
             while (nX<=nRepeatEndX)
                 RemoveColBreak(++nX, true, false);
             bColFound = TRUE;
@@ -201,8 +203,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
     for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
     {
         BOOL bStartOfPage = FALSE;
-        BYTE nFlags = pRowFlags->GetValue(nY);
-        long nThisY = (nFlags & CR_HIDDEN) ? 0 : pRowHeight->GetValue(nY);
+        long nThisY = RowHidden(nY) ? 0 : pRowHeight->GetValue(nY);
         bool bManualBreak = HasRowManualBreak(nY);
         if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
         {
@@ -218,8 +219,7 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
         if ( bStartOfPage && bRepeatRow && nY>nRepeatStartY && !bRowFound )
         {
             // subtract size of repeat rows from page size
-            unsigned long nHeights = pRowFlags->SumCoupledArrayForCondition(
-                    nRepeatStartY, nRepeatEndY, CR_HIDDEN, 0, *pRowHeight);
+            unsigned long nHeights = GetTotalRowHeight(nRepeatStartY, nRepeatEndY);
 #ifdef DBG_UTIL
             if (nHeights == ::std::numeric_limits<unsigned long>::max())
                 DBG_ERRORFILE("ScTable::UpdatePageBreaks: row heights overflow");
@@ -416,12 +416,516 @@ Sequence<TablePageBreakData> ScTable::GetRowBreakData() const
     return aSeq;
 }
 
-void ScTable::SyncColRowFlags()
+bool ScTable::RowHidden(SCROW nRow, SCROW* pFirstRow, SCROW* pLastRow)
+{
+    if (!ValidRow(nRow))
+        return true;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    if (!mpHiddenRows->getRangeData(nRow, aData))
+        // search failed.
+        return true;
+
+    if (pFirstRow)
+        *pFirstRow = aData.mnRow1;
+    if (pLastRow)
+        *pLastRow = aData.mnRow2;
+
+    return aData.mbValue;
+}
+
+
+bool ScTable::RowHidden(SCROW nRow, SCROW& rLastRow)
+{
+    rLastRow = nRow;
+    if (!ValidRow(nRow))
+        return true;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    if (!mpHiddenRows->getRangeData(nRow, aData))
+        // search failed.
+        return true;
+
+    rLastRow = aData.mnRow2;
+    return aData.mbValue;
+}
+
+bool ScTable::HasHiddenRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = -1;
+        bool bHidden = RowHidden(nRow, nLastRow);
+        if (bHidden)
+            return true;
+
+        nRow = nLastRow + 1;
+    }
+    return false;
+}
+
+bool ScTable::ColHidden(SCCOL nCol, SCCOL& rLastCol)
+{
+    rLastCol = nCol;
+    if (!ValidCol(nCol))
+        return true;
+
+    ScFlatBoolColSegments::RangeData aData;
+    if (!mpHiddenCols->getRangeData(nCol, aData))
+        return true;
+
+    rLastCol = aData.mnCol2;
+    return aData.mbValue;
+}
+
+bool ScTable::ColHidden(SCCOL nCol, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+    if (!ValidCol(nCol))
+        return true;
+
+    ScFlatBoolColSegments::RangeData aData;
+    if (!mpHiddenCols->getRangeData(nCol, aData))
+        return true;
+
+    if (pFirstCol)
+        *pFirstCol = aData.mnCol1;
+    if (pLastCol)
+        *pLastCol = aData.mnCol2;
+
+    return aData.mbValue;
+}
+
+void ScTable::SetRowHidden(SCROW nStartRow, SCROW nEndRow, bool bHidden)
+{
+    if (bHidden)
+        mpHiddenRows->setTrue(nStartRow, nEndRow);
+    else
+        mpHiddenRows->setFalse(nStartRow, nEndRow);
+
+#if 0
+    // Remove this once the refactoring is complete.
+    if (bHidden)
+        pRowFlags->OrValue(nStartRow, nEndRow, CR_HIDDEN);
+    else
+        pRowFlags->AndValue(nStartRow, nEndRow, ~CR_HIDDEN);
+#endif
+}
+
+void ScTable::SetColHidden(SCCOL nStartCol, SCCOL nEndCol, bool bHidden)
+{
+    if (bHidden)
+        mpHiddenCols->setTrue(nStartCol, nEndCol);
+    else
+        mpHiddenCols->setFalse(nStartCol, nEndCol);
+#if 0
+    for (SCCOL nCol = nStartCol; nCol <= nEndCol; ++nCol)
+    {
+        if (bHidden)
+            pColFlags[nCol] |= CR_HIDDEN;
+        else
+            pColFlags[nCol] &= ~CR_HIDDEN;
+    }
+#endif
+}
+
+void ScTable::CopyColHidden(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol)
+{
+    SCCOL nCol = nStartCol;
+    while (nCol <= nEndCol)
+    {
+        SCCOL nLastCol;
+        bool bHidden = rTable.ColHidden(nCol, NULL, &nLastCol);
+        if (nLastCol > nEndCol)
+            nLastCol = nEndCol;
+
+        SetColHidden(nCol, nLastCol, bHidden);
+        nCol = nLastCol + 1;
+    }
+}
+
+void ScTable::CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = -1;
+        bool bHidden = rTable.RowHidden(nRow, nLastRow);
+        if (nLastRow > nEndRow)
+            nLastRow = nEndRow;
+        SetRowHidden(nRow, nLastRow, bHidden);
+        nRow = nLastRow + 1;
+    }
+}
+
+SCROW ScTable::FirstVisibleRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // visible row found
+            return nRow;
+
+        nRow = aData.mnRow2 + 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::LastVisibleRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nEndRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow >= nStartRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // visible row found
+            return nRow;
+
+        nRow = aData.mnRow1 - 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::CountVisibleRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nCount = 0;
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mnRow2 > nEndRow)
+            aData.mnRow2 = nEndRow;
+
+        if (!aData.mbValue)
+            nCount += aData.mnRow2 - nRow + 1;
+
+        nRow = aData.mnRow2 + 1;
+    }
+    return nCount;
+}
+
+sal_uInt32 ScTable::GetTotalRowHeight(SCROW nStartRow, SCROW nEndRow)
+{
+    sal_uInt32 nHeight = 0;
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!mpHiddenRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mnRow2 > nEndRow)
+            aData.mnRow2 = nEndRow;
+
+        if (!aData.mbValue)
+            // visible row range.
+            nHeight += pRowHeight->SumValues(nRow, aData.mnRow2);
+
+        nRow = aData.mnRow2 + 1;
+    }
+
+    return nHeight;
+}
+
+SCCOLROW ScTable::LastHiddenColRow(SCCOLROW nPos, bool bCol)
+{
+    if (bCol)
+    {
+        SCCOL nCol = static_cast<SCCOL>(nPos);
+        if (ColHidden(nCol))
+        {
+            for (SCCOL i = nCol+1; i <= MAXCOL; ++i)
+            {
+                if (!ColHidden(nCol))
+                    return nCol - 1;
+            }
+        }
+    }
+    else
+    {
+        SCROW nRow = static_cast<SCROW>(nPos);
+        SCROW nLastRow;
+        if (RowHidden(nRow, NULL, &nLastRow))
+            return static_cast<SCCOLROW>(nLastRow);
+    }
+    return ::std::numeric_limits<SCCOLROW>::max();
+}
+
+bool ScTable::RowFiltered(SCROW nRow, SCROW* pFirstRow, SCROW* pLastRow)
+{
+#if 1
+    if (!ValidRow(nRow))
+        return false;
+
+    ScFlatBoolRowSegments::RangeData aData;
+    if (!mpFilteredRows->getRangeData(nRow, aData))
+        // search failed.
+        return false;
+
+    if (pFirstRow)
+        *pFirstRow = aData.mnRow1;
+    if (pLastRow)
+        *pLastRow = aData.mnRow2;
+
+    return aData.mbValue;
+#else
+    if (pFirstRow)
+        *pFirstRow = nRow;
+    if (pLastRow)
+        *pLastRow = nRow;
+    return (pRowFlags->GetValue(nRow) & CR_FILTERED) == CR_FILTERED;
+#endif
+}
+
+bool ScTable::ColFiltered(SCCOL nCol, SCCOL* pFirstCol, SCCOL* pLastCol)
+{
+#if 1
+    if (!ValidCol(nCol))
+        return false;
+
+    ScFlatBoolColSegments::RangeData aData;
+    if (!mpFilteredCols->getRangeData(nCol, aData))
+        // search failed.
+        return false;
+
+    if (pFirstCol)
+        *pFirstCol = aData.mnCol1;
+    if (pLastCol)
+        *pLastCol = aData.mnCol2;
+
+    return aData.mbValue;
+#else
+    if (pFirstCol)
+        *pFirstCol = nCol;
+    if (pLastCol)
+        *pLastCol = nCol;
+    return (pColFlags[nCol] & CR_FILTERED) == CR_FILTERED;
+#endif
+}
+
+bool ScTable::HasFilteredRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = nRow;
+        bool bFiltered = RowFiltered(nRow, NULL, &nLastRow);
+        if (bFiltered)
+            return true;
+
+        nRow = nLastRow + 1;
+    }
+    return false;
+}
+
+void ScTable::CopyColFiltered(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol)
+{
+    SCCOL nCol = nStartCol;
+    while (nCol <= nEndCol)
+    {
+        SCCOL nLastCol;
+        bool bFiltered = rTable.ColFiltered(nCol, NULL, &nLastCol);
+        if (nLastCol > nEndCol)
+            nLastCol = nEndCol;
+
+        SetColFiltered(nCol, nLastCol, bFiltered);
+        nCol = nLastCol + 1;
+    }
+}
+
+void ScTable::CopyRowFiltered(ScTable& rTable, SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    while (nRow <= nEndRow)
+    {
+        SCROW nLastRow = -1;
+        bool bFiltered = rTable.RowFiltered(nRow, NULL, &nLastRow);
+        if (nLastRow > nEndRow)
+            nLastRow = nEndRow;
+        SetRowFiltered(nRow, nLastRow, bFiltered);
+        nRow = nLastRow + 1;
+    }
+}
+
+void ScTable::SetRowFiltered(SCROW nStartRow, SCROW nEndRow, bool bFiltered)
+{
+    if (bFiltered)
+        mpFilteredRows->setTrue(nStartRow, nEndRow);
+    else
+        mpFilteredRows->setFalse(nStartRow, nEndRow);
+
+#if 0
+    // Remove this once the refactoring is complete.
+    if (bFiltered)
+        pRowFlags->OrValue(nStartRow, nEndRow, CR_FILTERED);
+    else
+        pRowFlags->AndValue(nStartRow, nEndRow, ~CR_FILTERED);
+#endif
+}
+
+void ScTable::SetColFiltered(SCCOL nStartCol, SCCOL nEndCol, bool bFiltered)
+{
+    if (bFiltered)
+        mpFilteredCols->setTrue(nStartCol, nEndCol);
+    else
+        mpFilteredCols->setFalse(nStartCol, nEndCol);
+
+#if 0
+    // Remove this once the refactoring is complete.
+    for (SCCOL nCol = nStartCol; nCol <= nEndCol; ++nCol)
+    {
+        if (bFiltered)
+            pColFlags[nCol] |= CR_FILTERED;
+        else
+            pColFlags[nCol] &= ~CR_FILTERED;
+    }
+#endif
+}
+
+SCROW ScTable::FirstNonFilteredRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpFilteredRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // non-filtered row found
+            return nRow;
+
+        nRow = aData.mnRow2 + 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::LastNonFilteredRow(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nRow = nEndRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow >= nStartRow)
+    {
+        if (!ValidRow(nRow))
+            break;
+
+        if (!mpFilteredRows->getRangeData(nRow, aData))
+            // failed to get range data.
+            break;
+
+        if (!aData.mbValue)
+            // non-filtered row found
+            return nRow;
+
+        nRow = aData.mnRow1 - 1;
+    }
+
+    return ::std::numeric_limits<SCROW>::max();
+}
+
+SCROW ScTable::CountNonFilteredRows(SCROW nStartRow, SCROW nEndRow)
+{
+    SCROW nCount = 0;
+    SCROW nRow = nStartRow;
+    ScFlatBoolRowSegments::RangeData aData;
+    while (nRow <= nEndRow)
+    {
+        if (!mpFilteredRows->getRangeData(nRow, aData))
+            break;
+
+        if (aData.mnRow2 > nEndRow)
+            aData.mnRow2 = nEndRow;
+
+        if (!aData.mbValue)
+            nCount += aData.mnRow2 - nRow + 1;
+
+        nRow = aData.mnRow2 + 1;
+    }
+    return nCount;
+}
+
+namespace {
+
+void lcl_syncFlags(ScFlatBoolColSegments& rColSegments, ScFlatBoolRowSegments& rRowSegments,
+    BYTE* pColFlags, ScBitMaskCompressedArray< SCROW, BYTE>* pRowFlags, const BYTE nFlagMask)
 {
     using ::sal::static_int_cast;
 
-    // For now, we only need to sync the manual breaks.
+    pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~nFlagMask));
+    for (SCCOL i = 0; i <= MAXCOL; ++i)
+        pColFlags[i] &= static_int_cast<BYTE>(~nFlagMask);
 
+    {
+        // row hidden flags.
+
+        SCROW nRow = 0;
+        ScFlatBoolRowSegments::RangeData aData;
+        while (nRow <= MAXROW)
+        {
+            if (!rRowSegments.getRangeData(nRow, aData))
+                break;
+
+            if (aData.mbValue)
+                pRowFlags->OrValue(nRow, aData.mnRow2, static_int_cast<BYTE>(nFlagMask));
+
+            nRow = aData.mnRow2 + 1;
+        }
+    }
+
+    {
+        // column hidden flags.
+
+        SCCOL nCol = 0;
+        ScFlatBoolColSegments::RangeData aData;
+        while (nCol <= MAXCOL)
+        {
+            if (!rColSegments.getRangeData(nCol, aData))
+                break;
+
+            if (aData.mbValue)
+            {
+                for (SCCOL i = nCol; i <= aData.mnCol2; ++i)
+                    pColFlags[i] |= nFlagMask;
+            }
+
+            nCol = aData.mnCol2 + 1;
+        }
+    }
+}
+
+}
+
+void ScTable::SyncColRowFlags()
+{
+    using ::sal::static_int_cast;
+
+    // Manual breaks.
     pRowFlags->AndValue(0, MAXROW, static_int_cast<BYTE>(~CR_MANUALBREAK));
     for (SCCOL i = 0; i <= MAXCOL; ++i)
         pColFlags[i] &= static_int_cast<BYTE>(~CR_MANUALBREAK);
@@ -439,6 +943,10 @@ void ScTable::SyncColRowFlags()
               itr != itrEnd; ++itr)
             pColFlags[*itr] |= CR_MANUALBREAK;
     }
+
+    // Hidden flags.
+    lcl_syncFlags(*mpHiddenCols, *mpHiddenRows, pColFlags, pRowFlags, CR_HIDDEN);
+    lcl_syncFlags(*mpFilteredCols, *mpFilteredRows, pColFlags, pRowFlags, CR_FILTERED);
 }
 
 void ScTable::SetPageSize( const Size& rSize )
diff --git sc/source/core/tool/chartarr.cxx sc/source/core/tool/chartarr.cxx
index 4de7865..4a359b5 100644
--- sc/source/core/tool/chartarr.cxx
+++ sc/source/core/tool/chartarr.cxx
@@ -44,6 +44,9 @@
 #include "cell.hxx"
 #include "docoptio.hxx"
 
+#include <vector>
+
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -163,11 +166,17 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
 
     SCCOL nStrCol = nCol1;		// fuer Beschriftung merken
     SCROW nStrRow = nRow1;
-    // Beschriftungen auch nach HiddenCols finden
-    while ( (pDocument->GetColFlags( nCol1, nTab1) & CR_HIDDEN) != 0 )
-        nCol1++;
-    nRow1 = pDocument->GetRowFlagsArray( nTab1).GetFirstForCondition( nRow1,
-            nRow2, CR_HIDDEN, 0);
+    // Skip hidden columns.
+    // TODO: make use of last column value once implemented.
+    SCCOL nLastCol = -1;
+    while (pDocument->ColHidden(nCol1, nTab1, nLastCol))
+        ++nCol1;
+
+    // Skip hidden rows.
+    SCROW nLastRow = -1;
+    if (pDocument->RowHidden(nRow1, nTab1, nLastRow))
+        nRow1 = nLastRow + 1;
+
     // falls alles hidden ist, bleibt die Beschriftung am Anfang
     if ( nCol1 <= nCol2 )
     {
@@ -181,17 +190,33 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
     }
 
     SCSIZE nTotalCols = ( nCol1 <= nCol2 ? nCol2 - nCol1 + 1 : 0 );
-    SCCOL* pCols = new SCCOL[nTotalCols > 0 ? nTotalCols : 1];
-    SCSIZE nColCount = 0;
+    vector<SCCOL> aCols;
+    aCols.reserve(nTotalCols);
     for (SCSIZE i=0; i<nTotalCols; i++)
-        if ((pDocument->GetColFlags(sal::static_int_cast<SCCOL>(nCol1+i),nTab1)&CR_HIDDEN)==0)
-            pCols[nColCount++] = sal::static_int_cast<SCCOL>(nCol1+i);
+    {
+        SCCOL nThisCol = sal::static_int_cast<SCCOL>(nCol1+i);
+        if (!pDocument->ColHidden(nThisCol, nTab1, nLastCol))
+            aCols.push_back(nThisCol);
+    }
+    SCSIZE nColCount = aCols.size();
 
     SCSIZE nTotalRows = ( nRow1 <= nRow2 ? nRow2 - nRow1 + 1 : 0 );
-    SCROW* pRows = new SCROW[nTotalRows > 0 ? nTotalRows : 1];
-    SCSIZE nRowCount = (nTotalRows ?
-            pDocument->GetRowFlagsArray( nTab1).FillArrayForCondition( nRow1,
-                nRow2, CR_HIDDEN, 0, pRows, nTotalRows) : 0);
+    vector<SCROW> aRows;
+    aRows.reserve(nTotalRows);
+    if (nRow1 <= nRow2)
+    {
+        // Get all visible rows between nRow1 and nRow2.
+        SCROW nThisRow = nRow1;
+        while (nThisRow <= nRow2)
+        {
+            if (pDocument->RowHidden(nThisRow, nTab1, nLastRow))
+                nThisRow = nLastRow;
+            else
+                aRows.push_back(nThisRow);
+            ++nThisRow;
+        }
+    }
+    SCSIZE nRowCount = aRows.size();
 
     // May happen at least with more than 32k rows.
     if (nColCount > SHRT_MAX || nRowCount > SHRT_MAX)
@@ -205,13 +230,13 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
     {
         bValidData = FALSE;
         nColCount = 1;
-        pCols[0] = nStrCol;
+        aCols.push_back(nStrCol);
     }
     if ( !nRowCount )
     {
         bValidData = FALSE;
         nRowCount = 1;
-        pRows[0] = nStrRow;
+        aRows.push_back(nStrRow);
     }
 
         //
@@ -234,7 +259,7 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
                 {
                     double nVal = DBL_MIN;		// Hack fuer Chart, um leere Zellen zu erkennen
 
-                    pDocument->GetCell( pCols[nCol], pRows[nRow], nTab1, pCell );
+                    pDocument->GetCell( aCols[nCol], aRows[nRow], nTab1, pCell );
                     if (pCell)
                     {
                         CellType eType = pCell->GetCellType();
@@ -244,8 +269,8 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
                             if ( bCalcAsShown && nVal != 0.0 )
                             {
                                 sal_uInt32 nFormat;
-                                pDocument->GetNumberFormat( pCols[nCol],
-                                    pRows[nRow], nTab1, nFormat );
+                                pDocument->GetNumberFormat( aCols[nCol],
+                                    aRows[nRow], nTab1, nFormat );
                                 nVal = pDocument->RoundValueAsShown( nVal, nFormat );
                             }
                         }
@@ -277,13 +302,13 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
         {
             String aString, aColStr;
             if (HasColHeaders())
-                pDocument->GetString( pCols[nCol], nStrRow, nTab1, aString );
+                pDocument->GetString( aCols[nCol], nStrRow, nTab1, aString );
             if ( !aString.Len() )
             {
                 aString = ScGlobal::GetRscString(STR_COLUMN);
                 aString += ' ';
 //                aString += String::CreateFromInt32( pCols[nCol]+1 );
-                ScAddress aPos( pCols[ nCol ], 0, 0 );
+                ScAddress aPos( aCols[ nCol ], 0, 0 );
                 aPos.Format( aColStr, SCA_VALID_COL, NULL );
                 aString += aColStr;
             }
@@ -303,14 +328,14 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
             String aString;
             if (HasRowHeaders())
             {
-                ScAddress aAddr( nStrCol, pRows[nRow], nTab1 );
-                pDocument->GetString( nStrCol, pRows[nRow], nTab1, aString );
+                ScAddress aAddr( nStrCol, aRows[nRow], nTab1 );
+                pDocument->GetString( nStrCol, aRows[nRow], nTab1, aString );
             }
             if ( !aString.Len() )
             {
                 aString = ScGlobal::GetRscString(STR_ROW);
                 aString += ' ';
-                aString += String::CreateFromInt32( pRows[nRow]+1 );
+                aString += String::CreateFromInt32( aRows[nRow]+1 );
             }
             pMemChart->SetRowText( static_cast<short>(nRow), aString);
 
@@ -346,11 +371,6 @@ ScMemChart* ScChartArray::CreateMemChartSingle()
 //        SetExtraStrings( *pMemChart );
     }
 
-        //	Aufraeumen
-
-    delete[] pRows;
-    delete[] pCols;
-
     return pMemChart;
 }
 
diff --git sc/source/filter/excel/colrowst.cxx sc/source/filter/excel/colrowst.cxx
index fb1caaf..d7a464f 100644
--- sc/source/filter/excel/colrowst.cxx
+++ sc/source/filter/excel/colrowst.cxx
@@ -307,7 +307,7 @@ void XclImpColRowSettings::ConvertHiddenFlags( SCTAB nScTab )
             rDoc.ShowRow( nScRow, nScTab, FALSE );
             // #i38093# rows hidden by filter need extra flag
             if( (nFirstFilterScRow <= nScRow) && (nScRow <= nLastFilterScRow) )
-                rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_FILTERED );
+                rDoc.SetRowFiltered(nScRow, nScRow, nScTab, true);
         }
     }
 
diff --git sc/source/filter/excel/xetable.cxx sc/source/filter/excel/xetable.cxx
index c279a57..30f18e6 100644
--- sc/source/filter/excel/xetable.cxx
+++ sc/source/filter/excel/xetable.cxx
@@ -1601,8 +1601,7 @@ XclExpColinfo::XclExpColinfo( const XclExpRoot& rRoot,
     mnWidth = XclTools::GetXclColumnWidth( nScWidth, GetCharWidth() );
 
     // column flags
-    BYTE nScColFlags = rDoc.GetColFlags( nScCol, nScTab );
-    ::set_flag( mnFlags, EXC_COLINFO_HIDDEN, (nScColFlags & CR_HIDDEN) != 0 );
+    ::set_flag( mnFlags, EXC_COLINFO_HIDDEN, rDoc.ColHidden(nScCol, nScTab) );
 
     // outline data
     rOutlineBfr.Update( nScCol );
@@ -1827,7 +1826,7 @@ XclExpRow::XclExpRow( const XclExpRoot& rRoot, sal_uInt16 nXclRow,
 
     BYTE nRowFlags = GetDoc().GetRowFlags( nScRow, nScTab );
     bool bUserHeight = ::get_flag< BYTE >( nRowFlags, CR_MANUALSIZE );
-    bool bHidden = ::get_flag< BYTE >( nRowFlags, CR_HIDDEN );
+    bool bHidden = GetDoc().RowHidden(nScRow, nScTab);
     ::set_flag( mnFlags, EXC_ROW_UNSYNCED, bUserHeight );
     ::set_flag( mnFlags, EXC_ROW_HIDDEN, bHidden );
 
diff --git sc/source/filter/excel/xlescher.cxx sc/source/filter/excel/xlescher.cxx
index 026673e..a6ff66b 100644
--- sc/source/filter/excel/xlescher.cxx
+++ sc/source/filter/excel/xlescher.cxx
@@ -133,21 +133,20 @@ void lclGetRowFromY(
     // rnStartH in conjunction with nXclStartRow is used as buffer for previously calculated height
     long nTwipsY = static_cast< long >( nY / fScale + 0.5 );
     long nRowH = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            rDoc.GetRowFlagsArray( nScTab), static_cast<SCROW>(nXclStartRow),
-            MAXROW, CR_HIDDEN, 0, rDoc.GetRowHeightArray( nScTab));
-    for ( ; aIter; ++aIter )
+    bool bFound = false;
+    for (SCROW nRow = static_cast<SCROW>(nXclStartRow); nRow <= MAXROW; ++nRow)
     {
-        nRowH = *aIter;
+        nRowH = rDoc.GetRowHeight(nRow, nScTab);
         if( rnStartH + nRowH > nTwipsY )
         {
-            rnXclRow = static_cast< sal_uInt16 >( aIter.GetPos() );
+            rnXclRow = static_cast< sal_uInt16 >(nRow);
+            bFound = true;
             break;
         }
         rnStartH += nRowH;
     }
-    if (!aIter)
-        rnXclRow = static_cast< sal_uInt16 >( aIter.GetIterEnd() );  // down to the bottom..
+    if (!bFound)
+        rnXclRow = static_cast<sal_uInt16>(MAXROW);
     rnOffset = static_cast< sal_uInt16 >( nRowH ? ((nTwipsY - rnStartH) * 256.0 / nRowH + 0.5) : 0 );
 }
 
diff --git sc/source/filter/html/htmlexp.cxx sc/source/filter/html/htmlexp.cxx
index 008595c..92fb448 100644
--- sc/source/filter/html/htmlexp.cxx
+++ sc/source/filter/html/htmlexp.cxx
@@ -746,7 +746,7 @@ void ScHTMLExport::WriteTables()
         SCCOL nCol;
         for ( nCol=nStartCol; nCol<=nEndCol; nCol++ )
         {
-            if ( !(pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) )
+            if ( !pDoc->ColHidden(nCol, nTab) )
                 ++nColCnt;
         }
         (((aByteStrOut += ' ') += OOO_STRING_SVTOOLS_HTML_O_cols) += '=') += ByteString::CreateFromInt32( nColCnt );
@@ -767,7 +767,7 @@ void ScHTMLExport::WriteTables()
         aByteStr += '=';
         for ( nCol=nStartCol; nCol<=nEndCol; nCol++ )
         {
-            if ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN )
+            if ( pDoc->ColHidden(nCol, nTab) )
                 continue;	// for
 
             aByteStrOut  = aByteStr;
@@ -782,14 +782,12 @@ void ScHTMLExport::WriteTables()
         // At least old (3.x, 4.x?) Netscape doesn't follow <TABLE COLS=n> and
         // <COL WIDTH=x> specified, but needs a width at every column.
         bTableDataWidth = TRUE;     // widths in first row
-        bool bHasHiddenRows = pDoc->GetRowFlagsArray( nTab).HasCondition(
-                nStartRow, nEndRow, CR_HIDDEN, CR_HIDDEN);
+        bool bHasHiddenRows = pDoc->HasHiddenRows(nStartRow, nEndRow, nTab);
         for ( SCROW nRow=nStartRow; nRow<=nEndRow; nRow++ )
         {
-            if ( bHasHiddenRows && (pDoc->GetRowFlags( nRow, nTab ) & CR_HIDDEN) )
+            if ( bHasHiddenRows && pDoc->RowHidden(nRow, nTab) )
             {
-                nRow = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition(
-                        nRow+1, nEndRow, CR_HIDDEN, 0);
+                nRow = pDoc->FirstVisibleRow(nRow+1, nEndRow, nTab);
                 --nRow;
                 continue;	// for
             }
@@ -798,7 +796,7 @@ void ScHTMLExport::WriteTables()
             bTableDataHeight = TRUE;  // height at every first cell of each row
             for ( SCCOL nCol2=nStartCol; nCol2<=nEndCol; nCol2++ )
             {
-                if ( pDoc->GetColFlags( nCol2, nTab ) & CR_HIDDEN )
+                if ( pDoc->ColHidden(nCol2, nTab) )
                     continue;	// for
 
                 if ( nCol2 == nEndCol )
diff --git sc/source/filter/lotus/lotimpop.cxx sc/source/filter/lotus/lotimpop.cxx
index ad924a2..1b8b9d9 100644
--- sc/source/filter/lotus/lotimpop.cxx
+++ sc/source/filter/lotus/lotimpop.cxx
@@ -180,8 +180,7 @@ void ImportLotus::Hiddencolumn( UINT16 nRecLen )
         {
             Read( nCol );
 
-            pD->SetColFlags( static_cast<SCCOL> (nCol), static_cast<SCTAB> (nLTab), pD->GetColFlags( static_cast<SCCOL> (nCol), static_cast<SCTAB> (nLTab) ) | CR_HIDDEN );
-
+            pD->SetColHidden(static_cast<SCCOL>(nCol), static_cast<SCCOL>(nCol), static_cast<SCTAB>(nLTab), true);
             nCnt--;
         }
     }
diff --git sc/source/filter/lotus/op.cxx sc/source/filter/lotus/op.cxx
index 0cf2b40..b51774f 100644
--- sc/source/filter/lotus/op.cxx
+++ sc/source/filter/lotus/op.cxx
@@ -226,7 +226,7 @@ void OP_ColumnWidth( SvStream& r, UINT16 /*n*/ )
         nBreite = ( UINT16 ) ( TWIPS_PER_CHAR * nWidthSpaces );
     else
     {
-        pDoc->SetColFlags( static_cast<SCCOL> (nCol), 0, pDoc->GetColFlags( static_cast<SCCOL> (nCol), 0 ) | CR_HIDDEN );
+        pDoc->SetColHidden(static_cast<SCCOL>(nCol), static_cast<SCCOL>(nCol), 0, true);
         nBreite = nDefWidth;
     }
 
@@ -335,7 +335,7 @@ void OP_HiddenCols( SvStream& r, UINT16 /*n*/ )
         {
             if( nAkt & 0x01 )   // unterstes Bit gesetzt?
                 // -> Hidden Col
-                pDoc->SetColFlags( nCount, 0, pDoc->GetColFlags( nCount, 0 ) | CR_HIDDEN );
+                pDoc->SetColHidden(nCount, nCount, 0, true);
 
             nCount++;
             nAkt = nAkt / 2;    // der Naechste bitte...
diff --git sc/source/filter/rtf/expbase.cxx sc/source/filter/rtf/expbase.cxx
index 2ee2291..a849fb9 100644
--- sc/source/filter/rtf/expbase.cxx
+++ sc/source/filter/rtf/expbase.cxx
@@ -75,16 +75,13 @@ BOOL ScExportBase::GetDataArea( SCTAB nTab, SCCOL& nStartCol,
 BOOL ScExportBase::TrimDataArea( SCTAB nTab, SCCOL& nStartCol,
             SCROW& nStartRow, SCCOL& nEndCol, SCROW& nEndRow ) const
 {
-    while ( nStartCol <= nEndCol &&
-            pDoc->GetColFlags( nStartCol, nTab ) & CR_HIDDEN )
+    SCCOL nLastCol;
+    while ( nStartCol <= nEndCol && pDoc->ColHidden(nStartCol, nTab, nLastCol))
         ++nStartCol;
-    while ( nStartCol <= nEndCol &&
-            pDoc->GetColFlags( nEndCol, nTab ) & CR_HIDDEN )
+    while ( nStartCol <= nEndCol && pDoc->ColHidden(nEndCol, nTab, nLastCol))
         --nEndCol;
-    nStartRow = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0);
-    nEndRow = pDoc->GetRowFlagsArray( nTab).GetLastForCondition( nStartRow,
-            nEndRow, CR_HIDDEN, 0);
+    nStartRow = pDoc->FirstVisibleRow(nStartRow, nEndRow, nTab);
+    nEndRow = pDoc->LastVisibleRow(nStartRow, nEndRow, nTab);
     return nStartCol <= nEndCol && nStartRow <= nEndRow && nEndRow !=
         ::std::numeric_limits<SCROW>::max();
 }
diff --git sc/source/filter/starcalc/scflt.cxx sc/source/filter/starcalc/scflt.cxx
index f653756..0da5a33 100644
--- sc/source/filter/starcalc/scflt.cxx
+++ sc/source/filter/starcalc/scflt.cxx
@@ -1548,14 +1548,12 @@ void Sc10Import::LoadTables()
             rStream >> DataValue;
             if (DataValue != 0)
             {
-                BYTE nFlags = 0;
                 bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
                 bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
-                if ((DataValue & crfHidden) == crfHidden)
-                    nFlags |= CR_HIDDEN;
+                bool bHidden = ((DataValue & crfHidden) == crfHidden);
                 for (SCCOL k = static_cast<SCCOL>(DataStart); k <= static_cast<SCCOL>(DataEnd); k++)
                 {
-                    pDoc->SetColFlags(k, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetColHidden(k, k, static_cast<SCTAB>(TabNo), bHidden);
                     pDoc->SetColBreak(k, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
                 }
             }
@@ -1600,14 +1598,12 @@ void Sc10Import::LoadTables()
             rStream >> DataValue;
             if (DataValue != 0)
             {
-                BYTE nFlags = 0;
                 bool bPageBreak   = ((DataValue & crfSoftBreak) == crfSoftBreak);
                 bool bManualBreak = ((DataValue & crfHardBreak) == crfHardBreak);
-                if ((DataValue & crfHidden) == crfHidden)
-                    nFlags |= CR_HIDDEN;
+                bool bHidden      = ((DataValue & crfHidden) == crfHidden);
                 for (SCROW l = static_cast<SCROW>(DataStart); l <= static_cast<SCROW>(DataEnd); l++)
                 {
-                    pDoc->SetRowFlags(l, static_cast<SCTAB> (TabNo), nFlags);
+                    pDoc->SetRowHidden(l, l, static_cast<SCTAB> (TabNo), bHidden);
                     pDoc->SetRowBreak(l, static_cast<SCTAB> (TabNo), bPageBreak, bManualBreak);
                 }
             }
diff --git sc/source/ui/Accessibility/AccessibleCellBase.cxx sc/source/ui/Accessibility/AccessibleCellBase.cxx
index e7ab3fa..666d88f 100644
--- sc/source/ui/Accessibility/AccessibleCellBase.cxx
+++ sc/source/ui/Accessibility/AccessibleCellBase.cxx
@@ -92,10 +92,12 @@ sal_Bool SAL_CALL ScAccessibleCellBase::isVisible(  )
     sal_Bool bVisible(sal_True);
     if (mpDoc)
     {
-        BYTE nColFlags = mpDoc->GetColFlags(maCellAddress.Col(), maCellAddress.Tab());
-        BYTE nRowFlags = mpDoc->GetRowFlags(maCellAddress.Row(), maCellAddress.Tab());
-        if (((nColFlags & CR_HIDDEN) == CR_HIDDEN) || ((nColFlags & CR_FILTERED) == CR_FILTERED) ||
-            ((nRowFlags & CR_HIDDEN) == CR_HIDDEN) || ((nRowFlags & CR_FILTERED) == CR_FILTERED))
+        bool bColHidden = mpDoc->ColHidden(maCellAddress.Col(), maCellAddress.Tab());
+        bool bRowHidden = mpDoc->RowHidden(maCellAddress.Row(), maCellAddress.Tab());
+        bool bColFiltered = mpDoc->ColFiltered(maCellAddress.Col(), maCellAddress.Tab());
+        bool bRowFiltered = mpDoc->RowFiltered(maCellAddress.Row(), maCellAddress.Tab());
+
+        if (bColHidden || bColFiltered || bRowHidden || bRowFiltered)
             bVisible = sal_False;
     }
     return bVisible;
diff --git sc/source/ui/app/inputwin.cxx sc/source/ui/app/inputwin.cxx
index 79d90f3..2a832cd 100644
--- sc/source/ui/app/inputwin.cxx
+++ sc/source/ui/app/inputwin.cxx
@@ -289,7 +289,7 @@ sal_Bool ScInputWindow::UseSubTotal(ScRangeList* pRangeList) const
                     SCROW nRow(pRange->aStart.Row());
                     while (!bSubTotal && nRow <= nRowEnd)
                     {
-                        if (pDoc->IsFiltered(nRow, nTab))
+                        if (pDoc->RowFiltered(nRow, nTab))
                             bSubTotal = sal_True;
                         else
                             ++nRow;
diff --git sc/source/ui/app/transobj.cxx sc/source/ui/app/transobj.cxx
index 1fe1e30..38340a5 100644
--- sc/source/ui/app/transobj.cxx
+++ sc/source/ui/app/transobj.cxx
@@ -602,25 +602,24 @@ void ScTransferObj::InitDocShell()
         //	widths / heights
         //	(must be copied before CopyFromClip, for drawing objects)
 
-        SCCOL nCol;
+        SCCOL nCol, nLastCol;
         SCROW nRow;
         SCTAB nSrcTab = aBlock.aStart.Tab();
         pDestDoc->SetLayoutRTL(0, pDoc->IsLayoutRTL(nSrcTab));
         for (nCol=nStartX; nCol<=nEndX; nCol++)
-            if ( pDoc->GetColFlags( nCol, nSrcTab ) & CR_HIDDEN )
+            if ( pDoc->ColHidden(nCol, nSrcTab, nLastCol) )
                 pDestDoc->ShowCol( nCol, 0, FALSE );
             else
                 pDestDoc->SetColWidth( nCol, 0, pDoc->GetColWidth( nCol, nSrcTab ) );
 
         ScBitMaskCompressedArray< SCROW, BYTE> & rDestRowFlags =
             pDestDoc->GetRowFlagsArrayModifiable(0);
-        ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray(
-                    nSrcTab), nStartY, nEndY);
-        for ( ; aIter; ++aIter )
+
+        for (SCROW nRow = nStartY; nRow <= nEndY; ++nRow)
         {
-            nRow = aIter.GetPos();
-            BYTE nSourceFlags = *aIter;
-            if ( nSourceFlags & CR_HIDDEN )
+            BYTE nSourceFlags = pDoc->GetRowFlags(nRow, nSrcTab);
+            SCROW nLastRow = -1;
+            if ( pDoc->RowHidden(nRow, nSrcTab, nLastRow) )
                 pDestDoc->ShowRow( nRow, 0, FALSE );
             else
             {
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index 174a889..46c487c 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -3103,7 +3103,9 @@ BOOL ScDocFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRa
                     for (SCROW nRow=nStartNo; nRow<=nEndNo; nRow++)
                     {
                         BYTE nOld = pDoc->GetRowFlags(nRow,nTab);
-                        if ( (nOld & CR_HIDDEN) == 0 && ( nOld & CR_MANUALSIZE ) )
+                        SCROW nLastRow = -1;
+                        bool bHidden = pDoc->RowHidden(nRow, nTab, nLastRow);
+                        if ( !bHidden && ( nOld & CR_MANUALSIZE ) )
                             pDoc->SetRowFlags( nRow, nTab, nOld & ~CR_MANUALSIZE );
                     }
                 }
@@ -3138,8 +3140,8 @@ BOOL ScDocFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRa
         {
             for (SCCOL nCol=static_cast<SCCOL>(nStartNo); nCol<=static_cast<SCCOL>(nEndNo); nCol++)
             {
-                if ( eMode != SC_SIZE_VISOPT ||
-                     (pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) == 0 )
+                SCCOL nLastCol = -1;
+                if ( eMode != SC_SIZE_VISOPT || !pDoc->ColHidden(nCol, nTab, nLastCol) )
                 {
                     USHORT nThisSize = nSizeTwips;
 
diff --git sc/source/ui/docshell/impex.cxx sc/source/ui/docshell/impex.cxx
index 296085c..3b8182e 100644
--- sc/source/ui/docshell/impex.cxx
+++ sc/source/ui/docshell/impex.cxx
@@ -1462,7 +1462,7 @@ BOOL ScImportExport::Doc2Text( SvStream& rStrm )
 
     for (nRow = nStartRow; nRow <= nEndRow; nRow++)
     {
-        if (bIncludeFiltered || !pDoc->IsFiltered( nRow, aRange.aStart.Tab() ))
+        if (bIncludeFiltered || !pDoc->RowFiltered( nRow, aRange.aStart.Tab() ))
         {
             for (nCol = nStartCol; nCol <= nEndCol; nCol++)
             {
diff --git sc/source/ui/docshell/olinefun.cxx sc/source/ui/docshell/olinefun.cxx
index 14a1d1d..105783b 100644
--- sc/source/ui/docshell/olinefun.cxx
+++ sc/source/ui/docshell/olinefun.cxx
@@ -420,7 +420,7 @@ BOOL ScOutlineDocFunc::SelectLevel( SCTAB nTab, BOOL bColumns, USHORT nLevel,
             if ( bColumns )
                 pDoc->ShowCol( static_cast<SCCOL>(i), nTab, bShow );
             else
-                if ( !bShow || !pDoc->IsFiltered( i,nTab ) )
+                if ( !bShow || !pDoc->RowFiltered( i,nTab ) )
                     pDoc->ShowRow( i, nTab, bShow );
         }
     }
@@ -518,7 +518,7 @@ BOOL ScOutlineDocFunc::ShowMarkedOutlines( const ScRange& rRange, BOOL bRecord,
             }
         }
         for ( i=nMin; i<=nMax; i++ )
-            if ( !pDoc->IsFiltered( i,nTab ) )				// weggefilterte nicht einblenden
+            if ( !pDoc->RowFiltered( i,nTab ) )				// weggefilterte nicht einblenden
                 pDoc->ShowRow( i, nTab, TRUE );
 
         pDoc->UpdatePageBreaks( nTab );
@@ -678,7 +678,7 @@ BOOL ScOutlineDocFunc::ShowOutline( SCTAB nTab, BOOL bColumns, USHORT nLevel, US
         if ( bColumns )
             pDoc->ShowCol( static_cast<SCCOL>(i), nTab, TRUE );
         else
-            if ( !pDoc->IsFiltered( i,nTab ) )				// weggefilterte nicht einblenden
+            if ( !pDoc->RowFiltered( i,nTab ) )				// weggefilterte nicht einblenden
                 pDoc->ShowRow( i, nTab, TRUE );
     }
 
diff --git sc/source/ui/inc/viewutil.hxx sc/source/ui/inc/viewutil.hxx
index 8489d0d..9d17f86 100644
--- sc/source/ui/inc/viewutil.hxx
+++ sc/source/ui/inc/viewutil.hxx
@@ -68,10 +68,10 @@ public:
 
     static sal_Int32 GetTransliterationType( USHORT nSlotID );
 
-    static bool HasFiltered( const ScRange& rRange, const ScDocument* pDoc );
+    static bool HasFiltered( const ScRange& rRange, ScDocument* pDoc );
     /** Fit a range to cover nRows number of unfiltered rows.
         @return <TRUE/> if the resulting range covers nRows unfiltered rows. */
-    static bool FitToUnfilteredRows( ScRange & rRange, const ScDocument * pDoc, size_t nRows );
+    static bool FitToUnfilteredRows( ScRange & rRange, ScDocument * pDoc, size_t nRows );
     static void UnmarkFiltered( ScMarkData& rMark, ScDocument* pDoc );
 
     static void HideDisabledSlot( SfxItemSet& rSet, SfxBindings& rBindings, USHORT nSlotId );
diff --git sc/source/ui/undo/undoblk.cxx sc/source/ui/undo/undoblk.cxx
index 31285e2..389d9b7 100644
--- sc/source/ui/undo/undoblk.cxx
+++ sc/source/ui/undo/undoblk.cxx
@@ -1149,10 +1149,10 @@ ScUndoDragDrop::ScUndoDragDrop( ScDocShell* pNewDocShell,
     BOOL bIncludeFiltered = bCut;
     if ( !bIncludeFiltered )
     {
-        //	manually find number of non-filtered rows
-        SCROW nPastedCount = pDocShell->GetDocument()->GetRowFlagsArray(
-                aSrcRange.aStart.Tab()).CountForCondition(
-                aSrcRange.aStart.Row(), aSrcRange.aEnd.Row(), CR_FILTERED, 0);
+        // find number of non-filtered rows
+        SCROW nPastedCount = pDocShell->GetDocument()->CountNonFilteredRows(
+            aSrcRange.aStart.Row(), aSrcRange.aEnd.Row(), aSrcRange.aStart.Tab());
+
         if ( nPastedCount == 0 )
             nPastedCount = 1;
         aDestEnd.SetRow( aNewDestPos.Row() + nPastedCount - 1 );
diff --git sc/source/ui/undo/undoblk3.cxx sc/source/ui/undo/undoblk3.cxx
index ef46f62..5152fff 100644
--- sc/source/ui/undo/undoblk3.cxx
+++ sc/source/ui/undo/undoblk3.cxx
@@ -1079,17 +1079,20 @@ void __EXPORT ScUndoAutoFormat::Redo()
             aDestMark.MarkToMulti();
 
             // wie SC_SIZE_VISOPT
+            SCROW nLastRow = -1;
             for (SCROW nRow=nStartY; nRow<=nEndY; nRow++)
             {
                 BYTE nOld = pDoc->GetRowFlags(nRow,nTab);
-                if ( (nOld & CR_HIDDEN) == 0 && ( nOld & CR_MANUALSIZE ) )
+                bool bHidden = pDoc->RowHidden(nRow, nTab, nLastRow);
+                if ( !bHidden && ( nOld & CR_MANUALSIZE ) )
                     pDoc->SetRowFlags( nRow, nTab, nOld & ~CR_MANUALSIZE );
             }
             pDoc->SetOptimalHeight( nStartY, nEndY, nTab, 0, &aVirtDev,
                                         nPPTX, nPPTY, aZoomX, aZoomY, FALSE );
 
+            SCCOL nLastCol = -1;
             for (SCCOL nCol=nStartX; nCol<=nEndX; nCol++)
-                if ((pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) == 0)
+                if (!pDoc->ColHidden(nCol, nTab, nLastCol))
                 {
                     USHORT nThisSize = STD_EXTRA_WIDTH + pDoc->GetOptimalColWidth( nCol, nTab,
                                                 &aVirtDev, nPPTX, nPPTY, aZoomX, aZoomY, bFormula,
diff --git sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
index ca554f0..21b7c0c 100644
--- sc/source/ui/unoobj/cellsuno.cxx
+++ sc/source/ui/unoobj/cellsuno.cxx
@@ -3376,18 +3376,25 @@ uno::Reference<sheet::XSheetCellRanges> SAL_CALL ScCellRangesBase::queryVisibleC
         ScMarkData aMarkData(*GetMarkData());
 
         ScDocument* pDoc = pDocShell->GetDocument();
-        for (SCCOL nCol=0; nCol<=MAXCOL; nCol++)
-            if (pDoc->GetColFlags(nCol,nTab) & CR_HIDDEN)
-                aMarkData.SetMultiMarkArea( ScRange( nCol,0,nTab, nCol,MAXROW,nTab ), FALSE );
+        SCCOL nCol = 0, nLastCol;
+        while (nCol <= MAXCOL)
+        {
+            if (pDoc->ColHidden(nCol, nTab, nLastCol))
+                // hidden columns.  Unselect them.
+                aMarkData.SetMultiMarkArea(ScRange(nCol, 0, nTab, nLastCol, MAXROW, nTab), false);
 
-        //!	nur bis zur letzten selektierten Zeile testen?
-        ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray( nTab), 0, MAXROW);
-        do
+            nCol = nLastCol + 1;
+        }
+
+        SCROW nRow = 0, nLastRow;
+        while (nRow <= MAXROW)
         {
-            if (*aIter & CR_HIDDEN)
-                aMarkData.SetMultiMarkArea( ScRange( 0, aIter.GetRangeStart(),
-                            nTab, MAXCOL, aIter.GetRangeEnd(), nTab ), FALSE );
-        } while (aIter.NextRange());
+            if (pDoc->RowHidden(nRow, nTab, nLastRow))
+                // These rows are hidden.  Unselect them.
+                aMarkData.SetMultiMarkArea(ScRange(0, nRow, nTab, MAXCOL, nLastRow, nTab), false);
+
+            nRow = nLastRow + 1;
+        }
 
         ScRangeList aNewRanges;
         aMarkData.FillRangeListWithMarks( &aNewRanges, FALSE );
@@ -8853,8 +8860,9 @@ void ScTableColumnObj::GetOnePropertyValue( const SfxItemPropertySimpleEntry* pE
         }
         else if ( pEntry->nWID == SC_WID_UNO_CELLVIS )
         {
-            BOOL bVis = !(pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN);
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bVis );
+            SCCOL nDummy;
+            bool bHidden = pDoc->ColHidden(nCol, nTab, nDummy);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, !bHidden );
         }
         else if ( pEntry->nWID == SC_WID_UNO_OWIDTH )
         {
@@ -8956,12 +8964,7 @@ void ScTableRowObj::SetOnePropertyValue( const SfxItemPropertySimpleEntry* pEntr
 //			ScSizeMode eMode = bVis ? SC_SIZE_SHOW : SC_SIZE_DIRECT;
 //			aFunc.SetWidthOrHeight( FALSE, 1, nRowArr, nTab, eMode, 0, TRUE, TRUE );
             //	SC_SIZE_DIRECT mit Groesse 0 blendet aus
-            BYTE nFlags = pDoc->GetRowFlags(nRow, nTab);
-            if (bFil)
-                nFlags |= CR_FILTERED;
-            else
-                nFlags &= ~CR_FILTERED;
-            pDoc->SetRowFlags(nRow, nTab, nFlags);
+            pDoc->SetRowFiltered(nRow, nRow, nTab, bFil);
         }
         else if ( pEntry->nWID == SC_WID_UNO_OHEIGHT )
         {
@@ -9013,12 +9016,13 @@ void ScTableRowObj::GetOnePropertyValue( const SfxItemPropertySimpleEntry* pEntr
         }
         else if ( pEntry->nWID == SC_WID_UNO_CELLVIS )
         {
-            BOOL bVis = !(pDoc->GetRowFlags( nRow, nTab ) & CR_HIDDEN);
-            ScUnoHelpFunctions::SetBoolInAny( rAny, bVis );
+            SCROW nDummy;
+            bool bHidden = pDoc->RowHidden(nRow, nTab, nDummy);
+            ScUnoHelpFunctions::SetBoolInAny( rAny, !bHidden );
         }
         else if ( pEntry->nWID == SC_WID_UNO_CELLFILT )
         {
-            BOOL bVis = ((pDoc->GetRowFlags( nRow, nTab ) & CR_FILTERED) != 0);
+            bool bVis = pDoc->RowFiltered(nRow, nTab);
             ScUnoHelpFunctions::SetBoolInAny( rAny, bVis );
         }
         else if ( pEntry->nWID == SC_WID_UNO_OHEIGHT )
diff --git sc/source/ui/unoobj/chart2uno.cxx sc/source/ui/unoobj/chart2uno.cxx
index 209cac7..bdd26e8 100644
--- sc/source/ui/unoobj/chart2uno.cxx
+++ sc/source/ui/unoobj/chart2uno.cxx
@@ -2569,14 +2569,17 @@ void ScChart2DataSequence::BuildDataCache()
             if (!ScRefTokenHelper::getRangeFromToken(aRange, *itr))
                 continue;
 
+            SCCOL nLastCol = -1;
+            SCROW nLastRow = -1;
             for (SCTAB nTab = aRange.aStart.Tab(); nTab <= aRange.aEnd.Tab(); ++nTab)
             {
                 for (SCCOL nCol = aRange.aStart.Col(); nCol <= aRange.aEnd.Col(); ++nCol)
                 {
                     for (SCROW nRow = aRange.aStart.Row(); nRow <= aRange.aEnd.Row(); ++nRow)
                     {
-                        bool bColHidden = (m_pDocument->GetColFlags(nCol, nTab) & CR_HIDDEN);
-                        bool bRowHidden = (m_pDocument->GetRowFlags(nRow, nTab) & CR_HIDDEN);
+                        bool bColHidden = m_pDocument->ColHidden(nCol, nTab, nLastCol);
+                        bool bRowHidden = m_pDocument->RowHidden(nRow, nTab, nLastRow);
+
                         if (bColHidden || bRowHidden)
                         {
                             // hidden cell
diff --git sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
index 661abdd..b7f9a50 100644
--- sc/source/ui/unoobj/docuno.cxx
+++ sc/source/ui/unoobj/docuno.cxx
@@ -2941,7 +2941,8 @@ uno::Any SAL_CALL ScTableColumnsObj::getPropertyValue( const rtl::OUString& aPro
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLVIS ) )
     {
-        BOOL bVis = !(pDoc->GetColFlags( nStartCol, nTab ) & CR_HIDDEN);
+        SCCOL nLastCol;
+        bool bVis = !pDoc->ColHidden(nStartCol, nTab, nLastCol);
         ScUnoHelpFunctions::SetBoolInAny( aAny, bVis );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_OWIDTH ) )
@@ -3149,9 +3150,9 @@ void SAL_CALL ScTableRowsObj::setPropertyValue(
     {
         //!	undo etc.
         if (ScUnoHelpFunctions::GetBoolFromAny( aValue ))
-            pDoc->GetRowFlagsArrayModifiable( nTab).OrValue( nStartRow, nEndRow, CR_FILTERED);
+            pDoc->SetRowFiltered(nStartRow, nEndRow, nTab, true);
         else
-            pDoc->GetRowFlagsArrayModifiable( nTab).AndValue( nStartRow, nEndRow, sal::static_int_cast<BYTE>(~CR_FILTERED) );
+            pDoc->SetRowFiltered(nStartRow, nEndRow, nTab, false);
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_NEWPAGE) || aNameString.EqualsAscii( SC_UNONAME_MANPAGE) )
     {
@@ -3199,12 +3200,13 @@ uno::Any SAL_CALL ScTableRowsObj::getPropertyValue( const rtl::OUString& aProper
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLVIS ) )
     {
-        BOOL bVis = !(pDoc->GetRowFlags( nStartRow, nTab ) & CR_HIDDEN);
+        SCROW nLastRow;
+        bool bVis = !pDoc->RowHidden(nStartRow, nTab, nLastRow);
         ScUnoHelpFunctions::SetBoolInAny( aAny, bVis );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_CELLFILT ) )
     {
-        BOOL bVis = ((pDoc->GetRowFlags( nStartRow, nTab ) & CR_FILTERED) != 0);
+        bool bVis = pDoc->RowFiltered(nStartRow, nTab);
         ScUnoHelpFunctions::SetBoolInAny( aAny, bVis );
     }
     else if ( aNameString.EqualsAscii( SC_UNONAME_OHEIGHT ) )
diff --git sc/source/ui/view/colrowba.cxx sc/source/ui/view/colrowba.cxx
index 736b065..0286946 100644
--- sc/source/ui/view/colrowba.cxx
+++ sc/source/ui/view/colrowba.cxx
@@ -98,7 +98,8 @@ USHORT ScColBar::GetEntrySize( SCCOLROW nEntryNo )
 {
     ScDocument* pDoc = pViewData->GetDocument();
     SCTAB nTab = pViewData->GetTabNo();
-    if ( pDoc->GetColFlags( static_cast<SCCOL>(nEntryNo), nTab ) & CR_HIDDEN )
+    SCCOL nLastCol = -1;
+    if (pDoc->ColHidden(static_cast<SCCOL>(nEntryNo), nTab, nLastCol))
         return 0;
     else
         return (USHORT) ScViewData::ToPixel( pDoc->GetColWidth( static_cast<SCCOL>(nEntryNo), nTab ), pViewData->GetPPTX() );
@@ -264,7 +265,8 @@ USHORT ScRowBar::GetEntrySize( SCCOLROW nEntryNo )
 {
     ScDocument* pDoc = pViewData->GetDocument();
     SCTAB nTab = pViewData->GetTabNo();
-    if ( pDoc->GetRowFlags( nEntryNo, nTab ) & CR_HIDDEN )
+    SCROW nLastRow = -1;
+    if (pDoc->RowHidden(nEntryNo, nTab, nLastRow))
         return 0;
     else
         return (USHORT) ScViewData::ToPixel( pDoc->GetOriginalHeight( nEntryNo,
diff --git sc/source/ui/view/drawutil.cxx sc/source/ui/view/drawutil.cxx
index 13ab91f..baf9f1c 100644
--- sc/source/ui/view/drawutil.cxx
+++ sc/source/ui/view/drawutil.cxx
@@ -66,14 +66,19 @@ void ScDrawUtil::CalcScale( ScDocument* pDoc, SCTAB nTab,
         nTwipsX += (long) nWidth;
         nPixelX += ScViewData::ToPixel( nWidth, nPPTX );
     }
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            pDoc->GetRowFlagsArray( nTab), nStartRow, nEndRow-1, CR_HIDDEN, 0,
-            pDoc->GetRowHeightArray( nTab));
-    for ( ; aIter; ++aIter )
+
+    for (SCROW nRow = nStartRow; nRow <= nEndRow-1; ++nRow)
     {
-        USHORT nHeight = *aIter;
-        nTwipsY += (long) nHeight;
-        nPixelY += ScViewData::ToPixel( nHeight, nPPTY );
+        SCROW nLastRow = nRow;
+        if (pDoc->RowHidden(nRow, nTab, NULL, &nLastRow))
+        {
+            nRow = nLastRow;
+            continue;
+        }
+
+        USHORT nHeight = pDoc->GetRowHeight(nRow, nTab);
+        nTwipsY += static_cast<long>(nHeight);
+        nPixelY += ScViewData::ToPixel(nHeight, nPPTY);
     }
 
     MapMode aHMMMode( MAP_100TH_MM, Point(), rZoomX, rZoomY );
diff --git sc/source/ui/view/gridwin.cxx sc/source/ui/view/gridwin.cxx
index 567a51a..9af3125 100644
--- sc/source/ui/view/gridwin.cxx
+++ sc/source/ui/view/gridwin.cxx
@@ -4621,18 +4621,17 @@ void lcl_PaintOneRange( ScDocShell* pDocSh, const ScRange& rRange, USHORT nEdges
     SCROW nTmp;
 
     ScDocument* pDoc = pDocSh->GetDocument();
-    while ( nCol1 > 0 && ( pDoc->GetColFlags( nCol1, nTab1 ) & CR_HIDDEN ) )
+    while ( nCol1 > 0 && pDoc->ColHidden(nCol1, nTab1) )
     {
         --nCol1;
         bHiddenEdge = TRUE;
     }
-    while ( nCol2 < MAXCOL && ( pDoc->GetColFlags( nCol2, nTab1 ) & CR_HIDDEN ) )
+    while ( nCol2 < MAXCOL && pDoc->ColHidden(nCol2, nTab1) )
     {
         ++nCol2;
         bHiddenEdge = TRUE;
     }
-    nTmp = pDoc->GetRowFlagsArray( nTab1).GetLastForCondition( 0, nRow1,
-            CR_HIDDEN, 0);
+    nTmp = pDoc->FirstVisibleRow(0, nRow1, nTab1);
     if (!ValidRow(nTmp))
         nTmp = 0;
     if (nTmp < nRow1)
@@ -4640,8 +4639,7 @@ void lcl_PaintOneRange( ScDocShell* pDocSh, const ScRange& rRange, USHORT nEdges
         nRow1 = nTmp;
         bHiddenEdge = TRUE;
     }
-    nTmp = pDoc->GetRowFlagsArray( nTab1).GetFirstForCondition( nRow2, MAXROW,
-            CR_HIDDEN, 0);
+    nTmp = pDoc->FirstVisibleRow(nRow2, MAXROW, nTab1);
     if (!ValidRow(nTmp))
         nTmp = MAXROW;
     if (nTmp > nRow2)
diff --git sc/source/ui/view/gridwin4.cxx sc/source/ui/view/gridwin4.cxx
index acdf175..c485ea7 100644
--- sc/source/ui/view/gridwin4.cxx
+++ sc/source/ui/view/gridwin4.cxx
@@ -1376,7 +1376,7 @@ Rectangle ScGridWindow::GetListValButtonRect( const ScAddress& rButtonPos )
     const ScMergeAttr* pMerge = static_cast<const ScMergeAttr*>(pDoc->GetAttr( nCol,nRow,nTab, ATTR_MERGE ));
     if ( pMerge->GetColMerge() > 1 )
         nNextCol = nCol + pMerge->GetColMerge();    // next cell after the merged area
-    while ( nNextCol <= MAXCOL && (pDoc->GetColFlags( nNextCol, nTab ) & CR_HIDDEN) )
+    while ( nNextCol <= MAXCOL && pDoc->ColHidden(nNextCol, nTab) )
         ++nNextCol;
     BOOL bNextCell = ( nNextCol <= MAXCOL );
     if ( bNextCell )
@@ -1579,7 +1579,7 @@ void ScGridWindow::InvertSimple( SCCOL nX1, SCROW nY1, SCCOL nX2, SCROW nY2,
                         if ( pMergeFlag->IsVerOverlapped() && ( bDoHidden || bFirstRow ) )
                         {
                             while ( pMergeFlag->IsVerOverlapped() && nThisY > 0 &&
-                                        ( (pDoc->GetRowFlags( nThisY-1, nTab ) & CR_HIDDEN) || bFirstRow ) )
+                                    (pDoc->RowHidden(nThisY-1, nTab) || bFirstRow) )
                             {
                                 --nThisY;
                                 pPattern = pDoc->GetPattern( nX, nThisY, nTab );
@@ -1766,7 +1766,7 @@ void ScGridWindow::GetSelectionRects( ::std::vector< Rectangle >& rPixelRects )
                         if ( pMergeFlag->IsVerOverlapped() && ( bDoHidden || bFirstRow ) )
                         {
                             while ( pMergeFlag->IsVerOverlapped() && nThisY > 0 &&
-                                        ( (pDoc->GetRowFlags( nThisY-1, nTab ) & CR_HIDDEN) || bFirstRow ) )
+                                    (pDoc->RowHidden(nThisY-1, nTab) || bFirstRow) )
                             {
                                 --nThisY;
                                 pPattern = pDoc->GetPattern( nX, nThisY, nTab );
diff --git sc/source/ui/view/olinewin.cxx sc/source/ui/view/olinewin.cxx
index 7aae17a..8f050f8 100644
--- sc/source/ui/view/olinewin.cxx
+++ sc/source/ui/view/olinewin.cxx
@@ -183,16 +183,15 @@ const ScOutlineEntry* ScOutlineWindow::GetOutlineEntry( size_t nLevel, size_t nE
 
 bool ScOutlineWindow::IsHidden( SCCOLROW nColRowIndex ) const
 {
-    sal_uInt8 nFlags = mbHoriz ?
-        GetDoc().GetColFlags( static_cast<SCCOL>(nColRowIndex), GetTab() ) :
-        GetDoc().GetRowFlags( static_cast<SCROW>(nColRowIndex), GetTab() );
-    return (nFlags & CR_HIDDEN) != 0;
+    return mbHoriz ?
+        GetDoc().ColHidden(static_cast<SCCOL>(nColRowIndex), GetTab()) :
+        GetDoc().RowHidden(static_cast<SCROW>(nColRowIndex), GetTab());
 }
 
 bool ScOutlineWindow::IsFiltered( SCCOLROW nColRowIndex ) const
 {
     // columns cannot be filtered
-    return !mbHoriz && GetDoc().IsFiltered( static_cast<SCROW>(nColRowIndex), GetTab() );
+    return !mbHoriz && GetDoc().RowFiltered( static_cast<SCROW>(nColRowIndex), GetTab() );
 }
 
 bool ScOutlineWindow::IsFirstVisible( SCCOLROW nColRowIndex ) const
diff --git sc/source/ui/view/output.cxx sc/source/ui/view/output.cxx
index 5d3d2d2..d35d0e3 100644
--- sc/source/ui/view/output.cxx
+++ sc/source/ui/view/output.cxx
@@ -384,8 +384,9 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
                 {
                     BYTE nDocFl = pDoc->GetColFlags( nCol, nTab );
                     nBreak = pDoc->HasColBreak(nCol, nTab);
+                    bool bHidden = pDoc->ColHidden(nCol, nTab);
 
-                    if ( nBreak || !(nDocFl & CR_HIDDEN) )
+                    if ( nBreak || !bHidden )
                         break;
                     ++nCol;
                 }
@@ -504,7 +505,7 @@ void ScOutputData::DrawGrid( BOOL bGrid, BOOL bPage )
                 for (SCROW i = nYplus1; i <= MAXROW; ++i)
                 {
                     nBreak = pDoc->HasRowBreak(i, nTab);
-                    bool bHidden = (pDoc->GetRowFlags(i, nTab) & CR_HIDDEN);
+                    bool bHidden = pDoc->RowHidden(i, nTab);
                     if (nBreak || !bHidden)
                         break;
                 }
@@ -651,7 +652,7 @@ void ScOutputData::FindRotated()
                 const ScPatternAttr* pPattern = pInfo->pPatternAttr;
                 const SfxItemSet* pCondSet = pInfo->pConditionSet;
 
-                if ( !pPattern && (pDoc->GetColFlags(nX,nTab) & CR_HIDDEN) == 0 )
+                if ( !pPattern && !pDoc->ColHidden(nX, nTab) )
                 {
                     pPattern = pDoc->GetPattern( nX, nY, nTab );
                     pCondSet = pDoc->GetCondResult( nX, nY, nTab );
diff --git sc/source/ui/view/output2.cxx sc/source/ui/view/output2.cxx
index 4aa7472..6707e6c 100644
--- sc/source/ui/view/output2.cxx
+++ sc/source/ui/view/output2.cxx
@@ -844,7 +844,7 @@ BOOL ScOutputData::GetMergeOrigin( SCCOL nX, SCROW nY, SCSIZE nArrY,
     while (bHOver)				// nY konstant
     {
         --rOverX;
-        bHidden = ( (pDoc->GetColFlags(rOverX,nTab) & CR_HIDDEN) != 0 );
+        bHidden = pDoc->ColHidden(rOverX, nTab);
         if ( !bDoMerge && !bHidden )
             return FALSE;
 
@@ -868,7 +868,7 @@ BOOL ScOutputData::GetMergeOrigin( SCCOL nX, SCROW nY, SCSIZE nArrY,
     while (bVOver)
     {
         --rOverY;
-        bHidden = ( (pDoc->GetRowFlags(rOverY,nTab) & CR_HIDDEN) != 0 );
+        bHidden = pDoc->RowHidden(rOverY, nTab);
         if ( !bDoMerge && !bHidden )
             return FALSE;
 
@@ -876,8 +876,8 @@ BOOL ScOutputData::GetMergeOrigin( SCCOL nX, SCROW nY, SCSIZE nArrY,
             --nArrY;						// lokale Kopie !
 
         if (rOverX >= nX1 && rOverY >= nY1 &&
-            (pDoc->GetColFlags(rOverX,nTab) & CR_HIDDEN) == 0 &&
-            (pDoc->GetRowFlags(rOverY,nTab) & CR_HIDDEN) == 0 &&
+            !pDoc->ColHidden(rOverX, nTab) &&
+            !pDoc->RowHidden(rOverY, nTab) &&
             pRowInfo[nArrY].nRowNo == rOverY)
         {
 //			rVirtPosY -= pRowInfo[nArrY].nHeight;
@@ -2175,7 +2175,7 @@ void ScOutputData::DrawEdit(BOOL bPixelToLogic)
                     if (bDoCell)
                     {
                         if ( nCellY == nY && nCellX >= nX1 && nCellX <= nX2 &&
-                             (pDoc->GetColFlags(nCellX,nTab) & CR_HIDDEN) == 0 )
+                             !pDoc->ColHidden(nCellX, nTab) )
                         {
                             CellInfo& rCellInfo = pThisRowInfo->pCellInfo[nCellX+1];
                             pPattern = rCellInfo.pPatternAttr;
diff --git sc/source/ui/view/prevloc.cxx sc/source/ui/view/prevloc.cxx
index 5fafb0a..8c089fd 100644
--- sc/source/ui/view/prevloc.cxx
+++ sc/source/ui/view/prevloc.cxx
@@ -599,11 +599,11 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         ++nColCount;
     if ( bHasRepCols )
         for ( nCol=nRepeatColStart; nCol<=nRepeatColEnd; nCol++ )
-            if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+            if (!pDoc->ColHidden(nCol, nTab))
                 ++nColCount;
     if ( bHasMainCols )
         for ( nCol=nMainColStart; nCol<=nMainColEnd; nCol++ )
-            if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+            if (!pDoc->ColHidden(nCol, nTab))
                 ++nColCount;
 
     if ( nColCount > 0 )
@@ -620,7 +620,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         {
             long nPosX = 0;
             for ( nCol=nRepeatColStart; nCol<=nRepeatColEnd; nCol++ )
-                if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+                if (!pDoc->ColHidden(nCol, nTab))
                 {
                     USHORT nDocW = pDoc->GetColWidth( nCol, nTab );
                     long nNextX = nPosX + (long) (nDocW * nScaleX);
@@ -639,7 +639,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         {
             long nPosX = 0;
             for ( nCol=nMainColStart; nCol<=nMainColEnd; nCol++ )
-                if ( ( pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN ) == 0 )
+                if (!pDoc->ColHidden(nCol, nTab))
                 {
                     USHORT nDocW = pDoc->GetColWidth( nCol, nTab );
                     long nNextX = nPosX + (long) (nDocW * nScaleX);
@@ -667,11 +667,9 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
     if ( bHasHeaderRow )
         ++nRowCount;
     if ( bHasRepRows )
-        nRowCount += pDoc->GetRowFlagsArray( nTab).CountForCondition(
-                nRepeatRowStart, nRepeatRowEnd, CR_HIDDEN, 0);
+        nRowCount += pDoc->CountVisibleRows(nRepeatRowStart, nRepeatRowEnd, nTab);
     if ( bHasMainRows )
-        nRowCount += pDoc->GetRowFlagsArray( nTab).CountForCondition(
-                nMainRowStart, nMainRowEnd, CR_HIDDEN, 0);
+        nRowCount += pDoc->CountVisibleRows(nMainRowStart, nMainRowEnd, nTab);
 
     if ( nRowCount > 0 )
     {
@@ -686,58 +684,44 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
         if ( bHasRepRows )
         {
             long nPosY = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter(
-                    pDoc->GetRowFlagsArray( nTab), nRepeatRowStart,
-                    nRepeatRowEnd);
-            do
+            for (SCROW nRow = nRepeatRowStart; nRow <= nRepeatRowEnd; ++nRow)
             {
-                if ((*aIter & CR_HIDDEN) == 0)
-                {
-                    SCROW nRangeEnd = aIter.GetRangeEnd();
-                    for (SCROW nRow=aIter.GetRangeStart(); nRow<=nRangeEnd; ++nRow)
-                    {
-                        USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
-                        long nNextY = nPosY + (long) (nDocH * nScaleY);
-
-                        long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
-                        long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
-                        pRowInfo[nRowPos].Set( FALSE, nRow,
-                                aRepeatRect.Top() + nPixelStart,
-                                aRepeatRect.Top() + nPixelEnd );
-
-                        nPosY = nNextY;
-                        ++nRowPos;
-                    }
-                }
-            } while (aIter.NextRange());
+                if (pDoc->RowHidden(nRow, nTab))
+                    continue;
+
+                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
+                long nNextY = nPosY + (long) (nDocH * nScaleY);
+
+                long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
+                long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
+                pRowInfo[nRowPos].Set( FALSE, nRow,
+                        aRepeatRect.Top() + nPixelStart,
+                        aRepeatRect.Top() + nPixelEnd );
+
+                nPosY = nNextY;
+                ++nRowPos;
+            }
         }
         if ( bHasMainRows )
         {
             long nPosY = 0;
-            ScCompressedArrayIterator< SCROW, BYTE> aIter(
-                    pDoc->GetRowFlagsArray( nTab), nMainRowStart,
-                    nMainRowEnd);
-            do
+            for (SCROW nRow = nMainRowStart; nRow <= nMainRowEnd; ++nRow)
             {
-                if ((*aIter & CR_HIDDEN) == 0)
-                {
-                    SCROW nRangeEnd = aIter.GetRangeEnd();
-                    for (SCROW nRow=aIter.GetRangeStart(); nRow<=nRangeEnd; ++nRow)
-                    {
-                        USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
-                        long nNextY = nPosY + (long) (nDocH * nScaleY);
-
-                        long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
-                        long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
-                        pRowInfo[nRowPos].Set( FALSE, nRow,
-                                aMainRect.Top() + nPixelStart,
-                                aMainRect.Top() + nPixelEnd );
-
-                        nPosY = nNextY;
-                        ++nRowPos;
-                    }
-                }
-            } while (aIter.NextRange());
+                if (pDoc->RowHidden(nRow, nTab))
+                    continue;
+
+                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
+                long nNextY = nPosY + (long) (nDocH * nScaleY);
+
+                long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
+                long nPixelEnd = pWindow->LogicToPixel( Size( 0, nNextY ), aCellMapMode ).Height() - 1;
+                pRowInfo[nRowPos].Set( FALSE, nRow,
+                        aMainRect.Top() + nPixelStart,
+                        aMainRect.Top() + nPixelEnd );
+
+                nPosY = nNextY;
+                ++nRowPos;
+            }
         }
         rInfo.SetRowInfo( nRowCount, pRowInfo );
     }
diff --git sc/source/ui/view/printfun.cxx sc/source/ui/view/printfun.cxx
index 218670c..cd26e9e 100644
--- sc/source/ui/view/printfun.cxx
+++ sc/source/ui/view/printfun.cxx
@@ -3084,9 +3084,10 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
     nTotalY = 0;
 
     BOOL bVisCol = FALSE;
+    SCCOL nLastCol = -1;
     for (SCCOL i=nStartCol; i<=nEndCol; i++)
     {
-        BYTE nFlags = pDoc->GetColFlags(i,nPrintTab);
+        bool bHidden = pDoc->ColHidden(i, nPrintTab, nLastCol);
         bool bPageBreak = (pDoc->HasColBreak(i, nPrintTab) & BREAK_PAGE);
         if ( i>nStartCol && bVisCol && bPageBreak )
         {
@@ -3094,7 +3095,7 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
             ++nPagesX;
             bVisCol = FALSE;
         }
-        if (!(nFlags & CR_HIDDEN))
+        if (!bHidden)
             bVisCol = TRUE;
     }
     if (bVisCol)	// auch am Ende keine leeren Seiten
@@ -3105,38 +3106,35 @@ void ScPrintFunc::CalcPages()				// berechnet aPageRect und Seiten aus nZoom
 
     BOOL bVisRow = FALSE;
     SCROW nPageStartRow = nStartRow;
-    ScCompressedArrayIterator< SCROW, BYTE> aIter( pDoc->GetRowFlagsArray(
-                nPrintTab), nStartRow, nEndRow);
-    do
+    for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
     {
-        BYTE nFlags = *aIter;
-        SCROW nRangeEnd = aIter.GetRangeEnd();
-        for (SCROW j=aIter.GetRangeStart(); j<=nRangeEnd; ++j)
+        bool bPageBreak = (pDoc->HasRowBreak(nRow, nPrintTab) & BREAK_PAGE);
+        if (nRow > nStartRow && bVisRow && bPageBreak )
         {
-            bool bPageBreak = (pDoc->HasRowBreak(j, nPrintTab) & BREAK_PAGE);
-            if ( j>nStartRow && bVisRow && bPageBreak )
-            {
-                pPageEndY[nTotalY] = j-1;
-                ++nTotalY;
-
-                if ( !aTableParam.bSkipEmpty ||
-                        !pDoc->IsPrintEmpty( nPrintTab, nStartCol, nPageStartRow, nEndCol, j-1 ) )
-                {
-                    pPageRows[nPagesY].SetStartRow( nPageStartRow );
-                    pPageRows[nPagesY].SetEndRow( j-1 );
-                    pPageRows[nPagesY].SetPagesX( nPagesX );
-                    if (aTableParam.bSkipEmpty)
-                        lcl_SetHidden( pDoc, nPrintTab, pPageRows[nPagesY], nStartCol, pPageEndX );
-                    ++nPagesY;
-                }
+            pPageEndY[nTotalY] = nRow-1;
+            ++nTotalY;
 
-                nPageStartRow = j;
-                bVisRow = FALSE;
+            if ( !aTableParam.bSkipEmpty ||
+                    !pDoc->IsPrintEmpty( nPrintTab, nStartCol, nPageStartRow, nEndCol, nRow-1 ) )
+            {
+                pPageRows[nPagesY].SetStartRow( nPageStartRow );
+                pPageRows[nPagesY].SetEndRow( nRow-1 );
+                pPageRows[nPagesY].SetPagesX( nPagesX );
+                if (aTableParam.bSkipEmpty)
+                    lcl_SetHidden( pDoc, nPrintTab, pPageRows[nPagesY], nStartCol, pPageEndX );
+                ++nPagesY;
             }
-            if (!(nFlags & CR_HIDDEN))
-                bVisRow = TRUE;
+
+            nPageStartRow = nRow;
+            bVisRow = FALSE;
         }
-    } while (aIter.NextRange());
+        SCROW nLastRow = -1;
+        if (!pDoc->RowHidden(nRow, nPrintTab, nLastRow))
+            bVisRow = TRUE;
+        else
+            // skip all hidden rows.
+            nRow = nLastRow;
+    }
 
     if (bVisRow)
     {
diff --git sc/source/ui/view/select.cxx sc/source/ui/view/select.cxx
index f2ea80f..cfe5cfe 100644
--- sc/source/ui/view/select.cxx
+++ sc/source/ui/view/select.cxx
@@ -275,12 +275,12 @@ BOOL __EXPORT ScViewFunctionSet::SetCursorAtPoint( const Point& rPointPixel, BOO
         ScDocument* pDoc = pViewData->GetDocument();
         SCTAB nTab = pViewData->GetTabNo();
         if ( bLeft && !bRightScroll )
-            do --nPosX; while ( nPosX>=0 && ( pDoc->GetColFlags( nPosX, nTab ) & CR_HIDDEN ) );
+            do --nPosX; while ( nPosX>=0 && pDoc->ColHidden( nPosX, nTab ) );
         if ( bTop && !bBottomScroll )
         {
             if (--nPosY >= 0)
             {
-                pDoc->GetRowFlagsArray( nTab).GetLastForCondition( 0, nPosY, CR_HIDDEN, 0);
+                nPosY = pDoc->LastVisibleRow(0, nPosY, nTab);
                 if (!ValidRow(nPosY))
                     nPosY = -1;
             }
@@ -476,7 +476,7 @@ BOOL ScViewFunctionSet::SetCursorAtCell( SCsCOL nPosX, SCsROW nPosY, BOOL bScrol
             {
                 //	#94321# in SetCursorAtPoint hidden columns are skipped.
                 //	They must be skipped here too, or the result will always be the first hidden column.
-                do ++nPosX; while ( nPosX<nStartX && ( pDoc->GetColFlags( nPosX, nTab ) & CR_HIDDEN ) );
+                do ++nPosX; while ( nPosX<nStartX && pDoc->ColHidden(nPosX, nTab) );
                 for (SCCOL i=nPosX; i<nStartX; i++)
                     nSizeX += pDoc->GetColWidth( i, nTab );
             }
@@ -491,8 +491,7 @@ BOOL ScViewFunctionSet::SetCursorAtCell( SCsCOL nPosX, SCsROW nPosY, BOOL bScrol
                 //	They must be skipped here too, or the result will always be the first hidden row.
                 if (++nPosY < nStartY)
                 {
-                    nPosY = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition(
-                            nPosY, nStartY-1, CR_HIDDEN, 0);
+                    nPosY = pDoc->FirstVisibleRow(nPosY, nStartY-1, nTab);
                     if (!ValidRow(nPosY))
                         nPosY = nStartY;
                 }
diff --git sc/source/ui/view/tabview.cxx sc/source/ui/view/tabview.cxx
index 05d3733..a2fead6 100644
--- sc/source/ui/view/tabview.cxx
+++ sc/source/ui/view/tabview.cxx
@@ -1438,7 +1438,7 @@ void ScTabView::ScrollX( long nDeltaX, ScHSplitPos eWhich, BOOL bUpdBars )
     SCsCOL nDir = ( nDeltaX > 0 ) ? 1 : -1;
     ScDocument* pDoc = aViewData.GetDocument();
     SCTAB nTab = aViewData.GetTabNo();
-    while ( ( pDoc->GetColFlags( nNewX, nTab ) & CR_HIDDEN ) &&
+    while ( pDoc->ColHidden(nNewX, nTab) &&
             nNewX+nDir >= 0 && nNewX+nDir <= MAXCOL )
         nNewX = sal::static_int_cast<SCsCOL>( nNewX + nDir );
 
@@ -1527,7 +1527,7 @@ void ScTabView::ScrollY( long nDeltaY, ScVSplitPos eWhich, BOOL bUpdBars )
     SCsROW nDir = ( nDeltaY > 0 ) ? 1 : -1;
     ScDocument* pDoc = aViewData.GetDocument();
     SCTAB nTab = aViewData.GetTabNo();
-    while ( ( pDoc->GetRowFlags( nNewY, nTab ) & CR_HIDDEN ) &&
+    while ( pDoc->RowHidden(nNewY, nTab) &&
             nNewY+nDir >= 0 && nNewY+nDir <= MAXROW )
         nNewY += nDir;
 
diff --git sc/source/ui/view/tabview2.cxx sc/source/ui/view/tabview2.cxx
index c7dcbda..7be5ea7 100644
--- sc/source/ui/view/tabview2.cxx
+++ sc/source/ui/view/tabview2.cxx
@@ -940,13 +940,13 @@ BOOL lcl_FitsInWindow( double fScaleX, double fScaleY, USHORT nZoom,
     }
 
     long nBlockY = 0;
-    ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-            pDoc->GetRowFlagsArray( nTab), 0, nFixPosY-1, CR_HIDDEN, 0,
-            pDoc->GetRowHeightArray( nTab));
-    for ( ; aIter; ++aIter)
+    for (SCROW nRow = 0; nRow <= nFixPosY-1; ++nRow)
     {
+        if (pDoc->RowHidden(nRow, nTab))
+            continue;
+
         //	for frozen panes, add both parts
-        USHORT nRowTwips = *aIter;
+        USHORT nRowTwips = pDoc->GetRowHeight(nRow, nTab);
         if (nRowTwips)
         {
             nBlockY += (long)(nRowTwips * fScaleY);
@@ -954,10 +954,9 @@ BOOL lcl_FitsInWindow( double fScaleX, double fScaleY, USHORT nZoom,
                 return FALSE;
         }
     }
-    aIter.NewLimits( nStartRow, nEndRow);
-    for ( ; aIter; ++aIter)
+    for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
     {
-        USHORT nRowTwips = *aIter;
+        USHORT nRowTwips = pDoc->GetRowHeight(nRow, nTab);
         if (nRowTwips)
         {
             nBlockY += (long)(nRowTwips * fScaleY);
diff --git sc/source/ui/view/tabview3.cxx sc/source/ui/view/tabview3.cxx
index 355b4bc..11c5e25 100644
--- sc/source/ui/view/tabview3.cxx
+++ sc/source/ui/view/tabview3.cxx
@@ -987,8 +987,8 @@ void ScTabView::MoveCursorRel( SCsCOL nMovX, SCsROW nMovY, ScFollowMode eMode,
         BOOL bHFlip = FALSE;
         do
         {
-            BYTE nColFlags = pDoc->GetColFlags( nCurX, nTab );
-            bSkipCell = (nColFlags & CR_HIDDEN) || pDoc->IsHorOverlapped( nCurX, nCurY, nTab );
+            SCCOL nLastCol = -1;
+            bSkipCell = pDoc->ColHidden(nCurX, nTab, nLastCol) || pDoc->IsHorOverlapped( nCurX, nCurY, nTab );
             if (bSkipProtected && !bSkipCell)
                 bSkipCell = pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
             if (bSkipUnprotected && !bSkipCell)
@@ -1029,8 +1029,8 @@ void ScTabView::MoveCursorRel( SCsCOL nMovX, SCsROW nMovY, ScFollowMode eMode,
         BOOL bVFlip = FALSE;
         do
         {
-            BYTE nRowFlags = pDoc->GetRowFlags( nCurY, nTab );
-            bSkipCell = (nRowFlags & CR_HIDDEN) || pDoc->IsVerOverlapped( nCurX, nCurY, nTab );
+            SCROW nLastRow = -1;
+            bSkipCell = pDoc->RowHidden(nCurY, nTab, nLastRow) || pDoc->IsVerOverlapped( nCurX, nCurY, nTab );
             if (bSkipProtected && !bSkipCell)
                 bSkipCell = pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
             if (bSkipUnprotected && !bSkipCell)
@@ -2053,17 +2053,18 @@ void ScTabView::PaintRangeFinder( long nNumber )
                             BOOL bHiddenEdge = FALSE;
                             SCROW nTmp;
                             ScDocument* pDoc = aViewData.GetDocument();
-                            while ( nCol1 > 0 && ( pDoc->GetColFlags( nCol1, nTab ) & CR_HIDDEN ) )
+                            SCCOL nLastCol = -1;
+                            while ( nCol1 > 0 && pDoc->ColHidden(nCol1, nTab, nLastCol) )
                             {
                                 --nCol1;
                                 bHiddenEdge = TRUE;
                             }
-                            while ( nCol2 < MAXCOL && ( pDoc->GetColFlags( nCol2, nTab ) & CR_HIDDEN ) )
+                            while ( nCol2 < MAXCOL && pDoc->ColHidden(nCol2, nTab, nLastCol) )
                             {
                                 ++nCol2;
                                 bHiddenEdge = TRUE;
                             }
-                            nTmp = pDoc->GetRowFlagsArray( nTab).GetLastForCondition( 0, nRow1, CR_HIDDEN, 0);
+                            nTmp = pDoc->LastVisibleRow(0, nRow1, nTab);
                             if (!ValidRow(nTmp))
                                 nTmp = 0;
                             if (nTmp < nRow1)
@@ -2071,7 +2072,7 @@ void ScTabView::PaintRangeFinder( long nNumber )
                                 nRow1 = nTmp;
                                 bHiddenEdge = TRUE;
                             }
-                            nTmp = pDoc->GetRowFlagsArray( nTab).GetFirstForCondition( nRow2, MAXROW, CR_HIDDEN, 0);
+                            nTmp = pDoc->FirstVisibleRow(nRow2, MAXROW, nTab);
                             if (!ValidRow(nTmp))
                                 nTmp = MAXROW;
                             if (nTmp > nRow2)
diff --git sc/source/ui/view/viewdata.cxx sc/source/ui/view/viewdata.cxx
index 514b162..fd60c7d 100644
--- sc/source/ui/view/viewdata.cxx
+++ sc/source/ui/view/viewdata.cxx
@@ -1679,7 +1679,7 @@ Point ScViewData::GetScrPos( SCCOL nWhereX, SCROW nWhereY, ScSplitPos eWhich,
                 else if ( nY < MAXROW )
                 {
                     // skip multiple hidden rows (forward only for now)
-                    SCROW nNext = pDoc->FastGetFirstNonHiddenRow( nY + 1, nTabNo );
+                    SCROW nNext = pDoc->FirstVisibleRow(nY + 1, MAXROW, nTabNo);
                     if ( nNext > MAXROW )
                         nY = MAXROW;
                     else
@@ -1791,7 +1791,7 @@ SCROW ScViewData::CellsAtY( SCsROW nPosY, SCsROW nDir, ScVSplitPos eWhichY, USHO
             else if ( nDir == 1 && nRowNo < MAXROW )
             {
                 // skip multiple hidden rows (forward only for now)
-                SCROW nNext = pDoc->FastGetFirstNonHiddenRow( nRowNo + 1, nTabNo );
+                SCROW nNext = pDoc->FirstVisibleRow(nRowNo + 1, MAXROW, nTabNo);
                 if ( nNext > MAXROW )
                 {
                     // same behavior as without the optimization: set bOut with nY=MAXROW+1
@@ -1854,11 +1854,19 @@ BOOL ScViewData::GetMergeSizePixel( SCCOL nX, SCROW nY, long& rSizeXPix, long& r
         for (SCCOL i=0; i<nCountX; i++)
             nOutWidth += ToPixel( pDoc->GetColWidth(nX+i,nTabNo), nPPTX );
         SCROW nCountY = pMerge->GetRowMerge();
-        ScCoupledCompressedArrayIterator< SCROW, BYTE, USHORT> aIter(
-                pDoc->GetRowFlagsArray( nTabNo), nY, nY+nCountY-1, CR_HIDDEN,
-                0, pDoc->GetRowHeightArray( nTabNo));
-        for ( ; aIter; ++aIter )
-            nOutHeight += ToPixel( *aIter, nPPTY );
+
+        for (SCROW nRow = nY; nRow <= nY+nCountY-1; ++nRow)
+        {
+            SCROW nLastRow = nRow;
+            if (pDoc->RowHidden(nRow, nTabNo, NULL, &nLastRow))
+            {
+                nRow = nLastRow;
+                continue;
+            }
+
+            USHORT nHeight = pDoc->GetRowHeight(nRow, nTabNo);
+            nOutHeight += ToPixel(nHeight, nPPTY);
+        }
 
         rSizeXPix = nOutWidth;
         rSizeYPix = nOutHeight;
diff --git sc/source/ui/view/viewfun3.cxx sc/source/ui/view/viewfun3.cxx
index 325bda3..8fc5acd 100644
--- sc/source/ui/view/viewfun3.cxx
+++ sc/source/ui/view/viewfun3.cxx
@@ -1723,10 +1723,10 @@ BOOL ScViewFunc::MoveBlockTo( const ScRange& rSource, const ScAddress& rDestPos,
         BOOL bIncludeFiltered = bCut;
         if ( !bIncludeFiltered )
         {
-            //	manually find number of non-filtered rows
-            SCROW nPastedCount = pDocSh->GetDocument()->GetRowFlagsArray(
-                    rSource.aStart.Tab()).CountForCondition(
-                    rSource.aStart.Row(), rSource.aEnd.Row(), CR_FILTERED, 0);
+            // find number of non-filtered rows
+            SCROW nPastedCount = pDocSh->GetDocument()->CountNonFilteredRows(
+                rSource.aStart.Row(), rSource.aEnd.Row(), rSource.aStart.Tab());
+
             if ( nPastedCount == 0 )
                 nPastedCount = 1;
             aDestEnd.SetRow( rDestPos.Row() + nPastedCount - 1 );
diff --git sc/source/ui/view/viewfunc.cxx sc/source/ui/view/viewfunc.cxx
index f4a0d56..b5dc1be 100644
--- sc/source/ui/view/viewfunc.cxx
+++ sc/source/ui/view/viewfunc.cxx
@@ -2215,28 +2215,19 @@ void ScViewFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pR
                         {
                             //	fuer alle eingeblendeten CR_MANUALSIZE loeschen,
                             //	dann SetOptimalHeight mit bShrink = FALSE
-                            ScCompressedArrayIterator< SCROW, BYTE> aIter(
-                                    pDoc->GetRowFlagsArray( nTab), nStartNo,
-                                    nEndNo);
-                            do
+                            for (SCROW nRow = nStartNo; nRow <= nEndNo; ++nRow)
                             {
-                                BYTE nOld = *aIter;
-                                if ( (nOld & CR_HIDDEN) == 0 && ( nOld & CR_MANUALSIZE ) )
+                                SCROW nLastRow = nRow;
+                                if (pDoc->RowHidden(nRow, nTab, NULL, &nLastRow))
                                 {
-                                    SCROW nRangeEnd = aIter.GetRangeEnd();
-                                    pDoc->SetRowFlags( aIter.GetRangeStart(),
-                                            nRangeEnd, nTab,
-                                            nOld & ~CR_MANUALSIZE);
-                                    aIter.Resync( nRangeEnd);
-                                    // Range may be extended due to merges and
-                                    // now aIter.GetRangeEnd() may point behind
-                                    // the previous row, but all flags of this
-                                    // range have the CR_MANUALSIZE bit
-                                    // removed, so it is safe to continue with
-                                    // the next range, not necessary to catch
-                                    // up with the remaining rows.
+                                    nRow = nLastRow;
+                                    continue;
                                 }
-                            } while (aIter.NextRange());
+
+                                BYTE nOld = pDoc->GetRowFlags(nRow, nTab);
+                                if (nOld & CR_MANUALSIZE)
+                                    pDoc->SetRowFlags(nRow, nTab, nOld & ~CR_MANUALSIZE);
+                            }
                         }
 
                         double nPPTX = GetViewData()->GetPPTX();
@@ -2278,8 +2269,7 @@ void ScViewFunc::SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pR
                 {
                     for (SCCOL nCol=static_cast<SCCOL>(nStartNo); nCol<=static_cast<SCCOL>(nEndNo); nCol++)
                     {
-                        if ( eMode != SC_SIZE_VISOPT ||
-                             (pDoc->GetColFlags( nCol, nTab ) & CR_HIDDEN) == 0 )
+                        if ( eMode != SC_SIZE_VISOPT || !pDoc->ColHidden(nCol, nTab) )
                         {
                             USHORT nThisSize = nSizeTwips;
 
diff --git sc/source/ui/view/viewutil.cxx sc/source/ui/view/viewutil.cxx
index 56b8f17..e1d464a 100644
--- sc/source/ui/view/viewutil.cxx
+++ sc/source/ui/view/viewutil.cxx
@@ -260,20 +260,19 @@ void ScViewUtil::UnmarkFiltered( ScMarkData& rMark, ScDocument* pDoc )
     for (SCTAB nTab=0; nTab<nTabCount; nTab++)
         if ( rMark.GetTableSelect(nTab ) )
         {
-            ScCompressedArrayIterator<SCROW, BYTE> aIter(pDoc->GetRowFlagsArray(nTab), nStartRow, nEndRow);
-            do
+            for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
             {
-                if (*aIter & CR_FILTERED)
+                SCROW nLastRow = nRow;
+                if (pDoc->RowFiltered(nRow, nTab, NULL, &nLastRow))
                 {
                     // use nStartCol/nEndCol, so the multi mark area isn't extended to all columns
                     // (visible in repaint for indentation)
-
-                    rMark.SetMultiMarkArea( ScRange( nStartCol, aIter.GetRangeStart(), nTab,
-                                                     nEndCol, aIter.GetRangeEnd(), nTab ), FALSE );
+                    rMark.SetMultiMarkArea(
+                        ScRange(nStartCol, nRow, nTab, nEndCol, nLastRow, nTab), false);
                     bChanged = true;
+                    nRow = nLastRow;
                 }
             }
-            while (aIter.NextRange());
         }
 
     if ( bChanged && !rMark.HasAnyMultiMarks() )
@@ -284,13 +283,19 @@ void ScViewUtil::UnmarkFiltered( ScMarkData& rMark, ScDocument* pDoc )
 
 
 // static
-bool ScViewUtil::FitToUnfilteredRows( ScRange & rRange, const ScDocument * pDoc, size_t nRows )
+bool ScViewUtil::FitToUnfilteredRows( ScRange & rRange, ScDocument * pDoc, size_t nRows )
 {
     SCTAB nTab = rRange.aStart.Tab();
     bool bOneTabOnly = (nTab == rRange.aEnd.Tab());
     // Always fit the range on its first sheet.
     DBG_ASSERT( bOneTabOnly, "ScViewUtil::ExtendToUnfilteredRows: works only on one sheet");
     SCROW nStartRow = rRange.aStart.Row();
+#if 1
+    SCROW nLastRow = pDoc->LastNonFilteredRow(nStartRow, MAXROW, nTab);
+    if (ValidRow(nLastRow))
+        rRange.aEnd.SetRow(nLastRow);
+    SCROW nCount = pDoc->CountNonFilteredRows(nStartRow, MAXROW, nTab);
+#else
     // FillArrayForCondition() usually is the fastest to determine such a set
     // in one pass, even if the array isn't used but the last element.
     SCROW* pArr = new SCROW[nRows];
@@ -299,19 +304,19 @@ bool ScViewUtil::FitToUnfilteredRows( ScRange & rRange, const ScDocument * pDoc,
     if (nCount)
         rRange.aEnd.SetRow( pArr[nCount-1]);
     delete [] pArr;
+#endif
     return nCount == nRows && bOneTabOnly;
 }
 
 
 // static
-bool ScViewUtil::HasFiltered( const ScRange& rRange, const ScDocument* pDoc )
+bool ScViewUtil::HasFiltered( const ScRange& rRange, ScDocument* pDoc )
 {
     SCROW nStartRow = rRange.aStart.Row();
     SCROW nEndRow = rRange.aEnd.Row();
     for (SCTAB nTab=rRange.aStart.Tab(); nTab<=rRange.aEnd.Tab(); nTab++)
     {
-        if ( pDoc->GetRowFlagsArray( nTab).HasCondition( nStartRow, nEndRow,
-                CR_FILTERED, CR_FILTERED ) )
+        if (pDoc->HasFilteredRows(nStartRow, nEndRow, nTab))
             return true;
     }
 
-- 
1.7.0.1

