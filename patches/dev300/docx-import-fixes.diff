diff --git oox/inc/oox/core/namespaces.hxx oox/inc/oox/core/namespaces.hxx
deleted file mode 100644
index ccc7d37..0000000
--- oox/inc/oox/core/namespaces.hxx
+++ /dev/null
@@ -1,88 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: namespaces.hxx,v $
- * $Revision: 1.5.4.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef OOX_CORE_NAMESPACES_HXX
-#define OOX_CORE_NAMESPACES_HXX
-
-#include <sal/types.h>
-
-namespace oox {
-
-// ============================================================================
-
-// relations, XML
-const sal_Int32 NMSP_XML                    = 1 << 16;
-const sal_Int32 NMSP_PACKAGE_RELATIONSHIPS  = 2 << 16;
-const sal_Int32 NMSP_RELATIONSHIPS          = 3 << 16;
-const sal_Int32 NMSP_CONTENT_TYPES          = 4 << 16;
-// office global
-const sal_Int32 NMSP_ACTIVATION             = 12 << 16;
-// DrawingML
-const sal_Int32 NMSP_DRAWINGML              = 21 << 16;
-const sal_Int32 NMSP_DIAGRAM                = 22 << 16;
-const sal_Int32 NMSP_CHART                  = 23 << 16;
-// VML
-const sal_Int32 NMSP_VML                    = 31 << 16;
-const sal_Int32 NMSP_OFFICE                 = 32 << 16;
-const sal_Int32 NMSP_VML_DOC                = 33 << 16; // Word VML
-const sal_Int32 NMSP_VML_XLS                = 34 << 16; // Excel VML
-const sal_Int32 NMSP_VML_PPT                = 35 << 16; // PowerPoint VML
-const sal_Int32 NMSP_AX                     = 36 << 16; // ActiveX (for OCX form controls)
-// SpreadsheetML
-const sal_Int32 NMSP_XLS                    = 41 << 16;
-const sal_Int32 NMSP_XDR                    = 42 << 16; // SpreadsheetDrawingML
-const sal_Int32 NMSP_XM                     = 43 << 16; // Macro sheet
-// PresentationML
-const sal_Int32 NMSP_PPT                    = 51 << 16;
-// Document properties
-const sal_Int32 NMSP_COREPR                 = 61 << 16;
-const sal_Int32 NMSP_DC                     = 62 << 16;
-const sal_Int32 NMSP_DCTERMS                = 63 << 16;
-const sal_Int32 NMSP_EXTPR                  = 64 << 16;
-const sal_Int32 NMSP_CUSTPR                 = 65 << 16;
-const sal_Int32 NMSP_VT                     = 66 << 16;
-
-// ----------------------------------------------------------------------------
-
-const sal_Int32 TOKEN_MASK                  = SAL_MAX_UINT16;
-const sal_Int32 NMSP_MASK                   = SAL_MAX_INT16 << 16;
-
-/** Returns the token identifier of the passed element without namespace. */
-inline sal_Int32 getToken( sal_Int32 nElement ) { return nElement & TOKEN_MASK; }
-
-/** Returns the namespace of the passed element without token identifier. */
-inline sal_Int32 getNamespace( sal_Int32 nElement ) { return nElement & NMSP_MASK; }
-
-// ============================================================================
-
-} // namespace oox
-
-#endif // OOX_CORE_NAMESPACES_HXX
-
diff --git oox/inc/oox/vml/shape.hxx oox/inc/oox/vml/shape.hxx
index ce2c3ea..6ff095c 100644
--- oox/inc/oox/vml/shape.hxx
+++ oox/inc/oox/vml/shape.hxx
@@ -72,9 +72,17 @@ class Shape
 	sal_Int32		mnCoordWidth;
 	sal_Int32		mnCoordHeight;
 	sal_Int32		mnStroked;
+    sal_Int32       mnZOrder;
+    bool            mbContainsText;
 
-	::boost::optional< sal_Int32 >		moFilled;
-	::boost::optional< rtl::OUString >	moFillColor;
+    ::boost::optional< sal_Bool >       moFilled;
+	::boost::optional< sal_Int32 >      moFillType;
+	::boost::optional< sal_Int32 >	    moFillColor;
+    ::boost::optional< rtl::OUString >  moFillImageUrl;
+    sal_Int32                           meFillImageMode;
+
+    ::boost::optional< sal_Int32 >      moStrokeColor;
+    ::boost::optional< sal_Int32 >      moStrokeWeight;
 
 	rtl::OUString	msGraphicURL;
 	rtl::OUString	msImageTitle;
@@ -96,12 +104,19 @@ class Shape
 		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
 			const ::com::sun::star::awt::Rectangle* pShapeRect );
 
+    void updateShape( );
+
 	private :
 
 	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
 		createAndInsert( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Shape& rShape,
 			const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes, 
 				const ::com::sun::star::awt::Rectangle* pShapeRect );
+		
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
+        createAndInsertFrame( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Shape& rShape,
+			const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes, 
+				const ::com::sun::star::awt::Rectangle* pShapeRect );
 
 	void addChilds( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Drawing& rDrawing,
 		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
diff --git oox/prj/d.lst oox/prj/d.lst
index 2bf664a..48d59a7 100644
--- oox/prj/d.lst
+++ oox/prj/d.lst
@@ -17,6 +17,7 @@ mkdir: %_DEST%\inc%_EXT%\oox\drawingml\table
 
 ..\inc\oox\dllapi.h %_DEST%\inc%_EXT%\oox\dllapi.h
 ..\source\token\tokens.txt %_DEST%\inc%_EXT%\oox\token.txt
+..\source\token\namespaces.txt %_DEST%\inc%_EXT%\oox\namespaces.txt
 ..\inc\oox\core\filterbase.hxx %_DEST%\inc%_EXT%\oox\core\filterbase.hxx
 ..\inc\oox\core\relations.hxx %_DEST%\inc%_EXT%\oox\core\relations.hxx
 ..\%__SRC%\inc\tokens.hxx %_DEST%\inc%_EXT%\oox\core\tokens.hxx
diff --git oox/source/shape/ShapeContextHandler.cxx oox/source/shape/ShapeContextHandler.cxx
index d7b2784..470eac3 100644
--- oox/source/shape/ShapeContextHandler.cxx
+++ oox/source/shape/ShapeContextHandler.cxx
@@ -32,6 +32,11 @@
 #include "oox/vml/drawingfragmenthandler.hxx"
 #include "tokens.hxx"
 
+#if DEBUG
+#include <iostream>
+using namespace std;
+#endif
+
 namespace oox { namespace shape {
 
 using namespace ::com::sun::star;
@@ -89,6 +94,9 @@ ShapeContextHandler::getGraphicShapeContext(::sal_Int32 Element )
 uno::Reference<xml::sax::XFastContextHandler> 
 ShapeContextHandler::getDrawingShapeContext()
 {
+#if DEBUG
+    clog << "ShapeContextHandler::getDrawingShapeContext" << endl;
+#endif
     if (!mxDrawingFragmentHandler.is())
     {
         mpDrawing.reset( new oox::vml::Drawing() );
@@ -108,6 +116,7 @@ ShapeContextHandler::getContextHandler()
     
     switch (mnStartToken & NMSP_MASK)
     {
+        case NMSP_DOC:
         case NMSP_VML:
             xResult.set(getDrawingShapeContext());
             break;
@@ -178,6 +187,9 @@ ShapeContextHandler::createFastChildContext
  const uno::Reference< xml::sax::XFastAttributeList > & Attribs)
     throw (uno::RuntimeException, xml::sax::SAXException)
 {
+#if DEBUG
+    clog << "ShapeContextHandler::createFastChildContext" << endl;
+#endif
     uno::Reference< xml::sax::XFastContextHandler > xResult;
     uno::Reference< xml::sax::XFastContextHandler > xContextHandler(getContextHandler());
 
diff --git oox/source/token/gennamespaces.pl oox/source/token/gennamespaces.pl
new file mode 100644
index 0000000..8c2ede6
--- /dev/null
+++ oox/source/token/gennamespaces.pl
@@ -0,0 +1,50 @@
+$ARGV0 = shift @ARGV;
+$ARGV1 = shift @ARGV;
+
+open ( NAMESPACES, $ARGV0 ) || die "can't open namespaces file: $!";
+
+
+open ( HXX, ">$ARGV1" ) or die "can't open namespaces.hxx file: $!";
+
+print ( HXX "#ifndef OOX_NAMESPACES_HXX\n" );
+print ( HXX "#define OOX_NAMESPACES_HXX\n\n" );
+print ( HXX "#include <sal/types.h>\n\n" );
+print ( HXX "namespace oox {\n\n" );
+
+$group = 0;
+$i = 1;
+while ( <NAMESPACES> )
+{
+    chomp( $_ );
+    $_ =~ s/\s*//g;
+    if ( $_ =~ m/^$/ )
+    {
+        # Start a new group
+        print ( HXX "\n" );
+        $i = 0;
+        $group++;
+    } 
+    elsif ( $_ =~ m/^[^#]/ )
+    {
+        # Neither an empty line nor a comment
+        $_ =~ /^[a-zA-Z0-9-_]+$/ or die "Invalid namespace token $_";
+        $id = "NMSP_$_";
+        $id =~ s/-/_/g;
+        $no = $group*10 + $i;
+        print ( HXX "const sal_Int32 $id = $no << 16;\n" );
+        ++$i;
+    }
+}
+close ( NAMESPACES );
+
+print ( HXX "\nconst sal_Int32 TOKEN_MASK                  = SAL_MAX_UINT16;\n" );
+print ( HXX "const sal_Int32 NMSP_MASK                   = SAL_MAX_INT16 << 16;\n" );
+
+print ( HXX "/** Returns the token identifier of the passed element without namespace. */\n" );
+print ( HXX "inline sal_Int32 getToken( sal_Int32 nElement ) { return nElement & TOKEN_MASK; }\n\n" );
+
+print ( HXX "/** Returns the namespace of the passed element without token identifier. */\n" );
+print ( HXX "inline sal_Int32 getNamespace( sal_Int32 nElement ) { return nElement & NMSP_MASK; }\n\n" );
+
+print ( HXX "} // namespace oox\n\n" );
+print ( HXX "#endif // OOX_NAMESPACES_HXX\n" );
diff --git oox/source/token/makefile.mk oox/source/token/makefile.mk
index bd1a4e3..4174830 100644
--- oox/source/token/makefile.mk
+++ oox/source/token/makefile.mk
@@ -50,14 +50,24 @@ SLOFILES =	\
 
 .INCLUDE :  target.mk
 
-$(MISC)$/tokens.gperf $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx : 
+$(MISC)$/tokens.gperf $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx $(INCCOM)$/oox$/core$/namespaces.hxx : 
 	@@noop $(assign do_phony:=.PHONY)
 
 $(MISC)$/do_tokens $(do_phony) : tokens.txt gentoken.pl $(MISC)$/tokens.gperf $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx
-		$(PERL) gentoken.pl tokens.txt $(INCCOM)$/tokens.hxx $(INCCOM)$/tokenwords.inc $(MISC)$/tokens.gperf && $(TOUCH) $@
+	$(PERL) gentoken.pl tokens.txt $(INCCOM)$/tokens.hxx $(INCCOM)$/tokenwords.inc $(MISC)$/tokens.gperf && $(TOUCH) $@
+
+$(INCCOM)$/oox:
+	$(MKDIR) $(INCCOM)$/oox
+
+$(INCCOM)$/oox$/core: $(INCCOM)$/oox
+	$(MKDIR) $(INCCOM)$/oox$/core
+
+$(MISC)$/do_namespaces $(do_phony) : namespaces.txt gennamespaces.pl
+	$(MKDIRHIER) $(INCCOM)$/oox$/core
+	$(PERL) gennamespaces.pl namespaces.txt $(INCCOM)$/oox$/core$/namespaces.hxx && $(TOUCH) $@
 
 $(INCCOM)$/tokens.inc : $(MISC)$/tokens.gperf $(MISC)$/do_tokens
 		gperf --compare-strncmp $(MISC)$/tokens.gperf | $(SED) -e "s/(char\*)0/(char\*)0, 0/g" | $(GREP) -v "^#line" >$(INCCOM)$/tokens.inc
 
-$(SLO)$/tokenmap.obj : $(INCCOM)$/tokens.inc $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx $(MISC)$/do_tokens
+$(SLO)$/tokenmap.obj : $(INCCOM)$/tokens.inc $(INCCOM)$/tokenwords.inc $(INCCOM)$/tokens.hxx $(INCCOM)$/oox$/core$/namespaces.hxx $(MISC)$/do_tokens $(MISC)$/do_namespaces
 
diff --git oox/source/token/namespaces.txt oox/source/token/namespaces.txt
new file mode 100644
index 0000000..63ca76e
--- /dev/null
+++ oox/source/token/namespaces.txt
@@ -0,0 +1,48 @@
+# Relations, XML
+XML
+PACKAGE_RELATIONSHIPS
+RELATIONSHIPS
+CONTENT_TYPES
+
+# Office global
+THEME
+ACTIVATION
+MATH
+
+#DrawingML
+DRAWINGML
+PICTURE
+DIAGRAM
+CHART
+DOC_DRAWINGML
+
+# VML
+VML
+OFFICE
+VML_DOC
+VML_XLS
+VML_PPT
+AX
+
+#SpreadsheetML
+XLS
+XDR
+XM
+
+#PresentationML
+PPT
+
+#WordprocessingML
+DOC
+SML
+
+# Document properties
+COREPR
+DC
+DCTERMS
+EXTPR
+CUSTPR
+VT
+
+# Other elements: used by writerfilter
+SPRM
diff --git oox/source/vml/vmldrawingfragmenthandler.cxx oox/source/vml/vmldrawingfragmenthandler.cxx
index a1dfb2e..802e82f 100644
--- oox/source/vml/vmldrawingfragmenthandler.cxx
+++ oox/source/vml/vmldrawingfragmenthandler.cxx
@@ -36,11 +36,19 @@
 #include "oox/core/contexthandler.hxx"
 #include <com/sun/star/beans/XMultiPropertySet.hpp>
 #include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/drawing/BitmapMode.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
 #include <com/sun/star/drawing/PointSequence.hpp>
 #include <com/sun/star/drawing/PointSequenceSequence.hpp>
 #include "oox/core/namespaces.hxx"
 #include "tokens.hxx"
 
+#if DEBUG
+#include <iostream>
+using namespace std;
+#endif
+
+
 using ::rtl::OUString;
 using namespace ::com::sun::star;
 using namespace ::oox::core;
@@ -50,6 +58,85 @@ using namespace ::com::sun::star::container;
 
 namespace oox { namespace vml {
 
+static sal_Int32 getColor( const rtl::OUString& rColor )
+{
+    sal_Int32 nId = 0;
+    rtl::OUString sValue ( rColor.getToken( 0, ' ', nId ) );
+    
+    static const rtl::OUString aColorNames[] =
+    {
+        rtl::OUString::createFromAscii( "Black" ),
+        rtl::OUString::createFromAscii( "Silver" ),
+        rtl::OUString::createFromAscii( "Gray" ),
+        rtl::OUString::createFromAscii( "White" ),
+        rtl::OUString::createFromAscii( "Maroon" ),
+        rtl::OUString::createFromAscii( "Red" ),
+        rtl::OUString::createFromAscii( "Purple" ),
+        rtl::OUString::createFromAscii( "Fuchsia" ),
+        rtl::OUString::createFromAscii( "Green" ),
+        rtl::OUString::createFromAscii( "Lime" ),
+        rtl::OUString::createFromAscii( "Olive" ),
+        rtl::OUString::createFromAscii( "Yellow" ),
+        rtl::OUString::createFromAscii( "Navy" ),
+        rtl::OUString::createFromAscii( "Blue" ),
+        rtl::OUString::createFromAscii( "Teal" ),
+        rtl::OUString::createFromAscii( "Aqua" )
+    };
+
+    static const rtl::OUString aColorValues[] =
+    {
+        rtl::OUString::createFromAscii( "000000" ),
+        rtl::OUString::createFromAscii( "C0C0C0" ),
+        rtl::OUString::createFromAscii( "808080" ),
+        rtl::OUString::createFromAscii( "FFFFFF" ),
+        rtl::OUString::createFromAscii( "800000" ),
+        rtl::OUString::createFromAscii( "FF0000" ),
+        rtl::OUString::createFromAscii( "800080" ),
+        rtl::OUString::createFromAscii( "FF00FF" ),
+        rtl::OUString::createFromAscii( "008000" ),
+        rtl::OUString::createFromAscii( "00FF00" ),
+        rtl::OUString::createFromAscii( "808000" ),
+        rtl::OUString::createFromAscii( "FFFF00" ),
+        rtl::OUString::createFromAscii( "000080" ),
+        rtl::OUString::createFromAscii( "0000FF" ),
+        rtl::OUString::createFromAscii( "008080" ),
+        rtl::OUString::createFromAscii( "00FFFF" )
+    };
+
+    rtl::OUString sHexValue;
+    if ( sValue.compareToAscii( "#", 1 ) == 0 )
+    {
+        // Removes the # of the hexa value if needed
+        sHexValue = sValue.copy( 1 );
+
+        // Check if the color is 6 or 3 chars long
+        if ( sHexValue.getLength( ) == 3 )
+        {
+            // All the characters have to be doubled
+            OUString sRed = sHexValue.copy( 0, 1 );
+            OUString sGreen = sHexValue.copy( 1, 1 );
+            OUString sBlue = sHexValue.copy( 2, 1 );
+
+            sHexValue = sRed + sRed + sGreen + sGreen + sGreen + sBlue  + sBlue;
+        }
+    }
+    else
+    {
+        // Convert the color name into an hexa value
+        int i = 0;
+        while ( sHexValue.getLength( ) == 0 && i < 16 )
+        {
+            if ( sValue.equalsIgnoreAsciiCase( aColorNames[i] ) )
+            {
+                sHexValue = aColorValues[i];
+            }
+            i++;
+        }
+    }
+
+    return sHexValue.toInt32( sal_Int16( 16 ) );
+}
+
 static sal_Int32 getMeasure( const rtl::OUString& rVal )
 {
 	double fVal = rVal.toDouble();
@@ -67,6 +154,30 @@ static sal_Int32 getMeasure( const rtl::OUString& rVal )
 	return static_cast< sal_Int32 >( fVal );
 }
 
+static OUString getRelId( const Reference< XFastAttributeList >& xAttribs )
+{
+    static const sal_Int32 aTokens[] = 
+    {
+        NMSP_RELATIONSHIPS | XML_id,
+        NMSP_OFFICE | XML_relid,
+        NMSP_RELATIONSHIPS | XML_href
+    };
+
+    // Look for the relation id
+    OUString sId;
+
+    int i = 0;
+    while ( ( i < 3 ) && ( sId.getLength( ) == 0 ) )
+    {
+        OUString sValue( xAttribs->getOptionalValue( aTokens[i] ) );
+        if ( sValue.getLength( ) > 0 )
+            sId = sValue;
+        i++;
+    }
+
+    return sId;
+}
+
 // AG_CoreAttributes
 static void ApplyCoreAttributes( const Reference< XFastAttributeList >& xAttribs, Shape& rShape )
 {
@@ -96,6 +207,7 @@ static void ApplyCoreAttributes( const Reference< XFastAttributeList >& xAttribs
 					static const ::rtl::OUString sHeight( RTL_CONSTASCII_USTRINGPARAM( "height" ) );
 					static const ::rtl::OUString sMarginLeft( RTL_CONSTASCII_USTRINGPARAM( "margin-left" ) );
 					static const ::rtl::OUString sMarginTop( RTL_CONSTASCII_USTRINGPARAM( "margin-top" ) );
+					static const ::rtl::OUString sZIndex( RTL_CONSTASCII_USTRINGPARAM( "z-index" ) );
 					if ( aName == sPosition )
 						rShape.msPosition = aVal;
 					else if ( aName == sLeft )
@@ -110,6 +222,8 @@ static void ApplyCoreAttributes( const Reference< XFastAttributeList >& xAttribs
 						rShape.maPosition.X = getMeasure( aVal );
 					else if ( aName == sMarginTop )
 						rShape.maPosition.Y = getMeasure( aVal );
+                    else if ( aName == sZIndex )
+                        rShape.mnZOrder = aVal.toInt32( );
 				}
 			}
         }
@@ -147,8 +261,22 @@ static void ApplyShapeAttributes( const Reference< XFastAttributeList >& xAttrib
 	rShape.mnStroked = xAttribs->getOptionalValueToken( XML_stroked, 0 );
 	if ( xAttribs->hasAttribute( XML_filled ) )
 		rShape.moFilled = ::boost::optional< sal_Bool >( aAttributeList.getBool( XML_filled, sal_False ) );
+
 	if ( xAttribs->hasAttribute( XML_fillcolor ) )
-		rShape.moFillColor = ::boost::optional< rtl::OUString >( xAttribs->getOptionalValue( XML_fillcolor ) );
+    {
+		rShape.moFillColor = ::boost::optional< sal_Int32 >( getColor( xAttribs->getOptionalValue( XML_fillcolor ) ) );
+        rShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_SOLID );
+    }
+
+    if ( xAttribs->hasAttribute( XML_strokecolor ) )
+        rShape.moStrokeColor = ::boost::optional< sal_Int32 >( getColor( xAttribs->getOptionalValue( XML_strokecolor ) ) );
+    else
+        rShape.moStrokeColor = ::boost::optional< sal_Int32 >( 0 );
+    
+    if ( xAttribs->hasAttribute( XML_strokeweight ) )
+        rShape.moStrokeWeight = ::boost::optional< sal_Int32 >( getMeasure( xAttribs->getOptionalValue( XML_strokeweight ) ) );
+    else
+        rShape.moStrokeColor = ::boost::optional< sal_Int32 >( getMeasure( OUString::createFromAscii( "1pt" ) ) );
 }
 
 //--------------------------------------------------------------------------------------------------------------
@@ -160,7 +288,7 @@ public:
 		sal_Int32 aElement, const Reference< XFastAttributeList >& xAttribs, Shape& rShape );
     virtual Reference< XFastContextHandler > SAL_CALL createFastChildContext( sal_Int32 Element,
 		const Reference< XFastAttributeList >& Attribs ) throw (::com::sun::star::xml::sax::SAXException, RuntimeException);
-private:
+protected:
 	Shape& mrShape;
 };
 
@@ -180,11 +308,22 @@ Reference< XFastContextHandler > BasicShapeContext::createFastChildContext( sal_
 	{
 		case NMSP_VML|XML_imagedata:
 			{
-                OUString aRelId( xAttribs->getOptionalValue( NMSP_OFFICE|XML_relid ) );
-                mrShape.msGraphicURL = getFragmentPathFromRelId( aRelId );
+                // A picture in a custom shape isn't shown
+                if ( mrShape.msServiceName.equalsAscii( "com.sun.star.drawing.CustomShape" ) )
+                    mrShape.msServiceName = OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" );
+
+                OUString aRelId( getRelId( xAttribs ) );
+                OUString sUrl( getFragmentPathFromRelId( aRelId ) );
+                mrShape.moFillImageUrl = ::boost::optional< OUString >( sUrl );
+                mrShape.moFillType = ::boost::optional< sal_Int32 > ( drawing::FillStyle_BITMAP );
 				mrShape.msImageTitle = xAttribs->getOptionalValue( NMSP_OFFICE|XML_title );
 			}
 			break;
+        case NMSP_VML|XML_textbox:
+            {
+                mrShape.mbContainsText = true;
+            }
+            break;
 		default:
 			break;
 	}
@@ -316,6 +455,7 @@ public:
 		sal_Int32 aElement, const Reference< XFastAttributeList >& xAttribs, Shape& rShape );
     virtual Reference< XFastContextHandler > SAL_CALL createFastChildContext( sal_Int32 Element,
 		const Reference< XFastAttributeList >& Attribs ) throw (SAXException, RuntimeException);
+    void ApplyFillAttributes( const Reference< XFastAttributeList >& xAttribs );
 };
 
 ShapeContext::ShapeContext( ContextHandler& rParent,
@@ -331,17 +471,68 @@ Reference< XFastContextHandler > ShapeContext::createFastChildContext( sal_Int32
 	throw (SAXException, RuntimeException)
 {
 	Reference< XFastContextHandler > xRet;
-//	switch( aElementToken )
-//	{
-//		default:
+	switch( aElementToken )
+	{
+        case NMSP_VML|XML_fill:
+            {
+                ApplyFillAttributes( xAttribs );
+            }
+            break;
+		default:
 			xRet = BasicShapeContext::createFastChildContext( aElementToken, xAttribs );
-//		break;
-//	}
+		break;
+	}
 	if( !xRet.is() )
 		xRet.set( this );
 	return xRet;
 }
 
+void ShapeContext::ApplyFillAttributes( const Reference< XFastAttributeList >& xAttribs )
+{
+    // Fill type
+    if ( xAttribs->hasAttribute( XML_type ) )
+    {
+       OUString sType = xAttribs->getValue( XML_type );
+
+       if ( sType.equalsIgnoreAsciiCaseAscii( "frame" ) ||
+         sType.equalsIgnoreAsciiCaseAscii( "tile" ) )
+       {
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_BITMAP );
+           mrShape.moFilled = ::boost::optional< sal_Bool >( sal_True );
+
+           // TODO Its a picture
+           if ( sType.equalsIgnoreAsciiCaseAscii( "frame" ) )
+               mrShape.meFillImageMode = com::sun::star::drawing::BitmapMode_STRETCH;
+           else
+               mrShape.meFillImageMode = com::sun::star::drawing::BitmapMode_REPEAT;
+           
+           if ( xAttribs->hasAttribute( NMSP_RELATIONSHIPS|XML_id ) )
+           {
+               OUString aRelId( getRelId( xAttribs ) );
+               OUString sUrl = getFragmentPathFromRelId( aRelId );
+               mrShape.moFillImageUrl = ::boost::optional< OUString >( sUrl );
+           }
+       }
+       else if ( sType.equalsIgnoreAsciiCaseAscii( "gradient" ) || 
+               sType.equalsIgnoreAsciiCaseAscii( "grandientradial" ) )
+       {
+           // TODO Its a gradient
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_GRADIENT );
+       }
+       else if ( sType.equalsIgnoreAsciiCaseAscii( "solid" ) )
+       {
+           // TODO Its a solid
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_SOLID );
+       }
+       else if ( sType.equalsIgnoreAsciiCaseAscii( "pattern" ) )
+       {
+           // TODO Its a Hatch
+           mrShape.moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_HATCH );
+       }
+    }
+}
+
+
 //--------------------------------------------------------------------------------------------------------------
 
 class GroupShapeContext : public BasicShapeContext
@@ -365,9 +556,9 @@ GroupShapeContext::GroupShapeContext( ContextHandler& rParent,
 {
 	AttributeList aAttributeList( xAttribs );
 	if ( xAttribs->hasAttribute( XML_filled ) )
-		rShape.moFilled = ::boost::optional< sal_Bool >( aAttributeList.getBool( XML_filled, sal_False ) );	
+		rShape.moFilled = ::boost::optional< sal_Int32>( aAttributeList.getBool( XML_filled, sal_False ) );
 	if ( xAttribs->hasAttribute( XML_fillcolor ) )
-		rShape.moFillColor = ::boost::optional< rtl::OUString >( xAttribs->getOptionalValue( XML_fillcolor ) );
+		rShape.moFillColor = ::boost::optional< sal_Int32 >( getColor( xAttribs->getOptionalValue( XML_fillcolor ) ) );
 	ApplyCoreAttributes( xAttribs, rShape );
 }
 Reference< XFastContextHandler > GroupShapeContext::createFastChildContext( sal_Int32 aElementToken, const Reference< XFastAttributeList >& xAttribs )
@@ -397,6 +588,10 @@ DrawingFragmentHandler::~DrawingFragmentHandler()
 		std::vector< ShapePtr >& rShapes, std::vector< ShapePtr >& rShapeTypes )
 		throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException )
 {
+#if DEBUG
+    clog << "DrawingFragmentHandler::StaticCreateContext" << endl;
+#endif
+
 	static const ::rtl::OUString sCustomShape( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.CustomShape" ) );
 
 	Reference< XFastContextHandler > xRet;
@@ -502,6 +697,9 @@ DrawingFragmentHandler::~DrawingFragmentHandler()
 Reference< XFastContextHandler > DrawingFragmentHandler::createFastChildContext( sal_Int32 aElementToken, const Reference< XFastAttributeList >& xAttribs )
 	throw (SAXException, RuntimeException)
 {
+#if DEBUG
+    clog << "DrawingFragmentHandler::createFastChildContext" << endl;
+#endif
 	return aElementToken == XML_xml
 		? getFastContextHandler()
 		: StaticCreateContext( *this, aElementToken, xAttribs, mrShapes, mrShapeTypes );
diff --git oox/source/vml/vmlshape.cxx oox/source/vml/vmlshape.cxx
index e06c984..ab892ed 100644
--- oox/source/vml/vmlshape.cxx
+++ oox/source/vml/vmlshape.cxx
@@ -31,11 +31,26 @@
 #include <rtl/ustring.hxx>
 #include "oox/vml/shape.hxx"
 #include "oox/core/xmlfilterbase.hxx"
+#include <com/sun/star/awt/XBitmap.hpp>
 #include <com/sun/star/drawing/XEnhancedCustomShapeDefaulter.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/beans/PropertyValues.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/VertOrientation.hpp>
+#include <com/sun/star/text/RelOrientation.hpp>
+#include <com/sun/star/text/SizeType.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextFrame.hpp>
+
+#if DEBUG
+#include <iostream>
+using namespace std;
+#endif
 
+using rtl::OUString;
 using namespace com::sun::star;
 
 namespace oox { namespace vml {
@@ -45,7 +60,14 @@ Shape::Shape( const rtl::OUString& rServiceName )
 , mnCoordWidth( 0 )
 , mnCoordHeight( 0 )
 , mnStroked( 0 )
+, mnZOrder( 0 )
+, mbContainsText( false )
 {
+    // By default all the shapes are filled
+    moFilled = ::boost::optional< sal_Bool > ( sal_True );
+
+    sal_Int32 nWhite = OUString::createFromAscii( "FFFFFF" ).toInt32( sal_Int16( 16 ) );
+    moFillColor = ::boost::optional< sal_Int32 > ( nWhite );
 }
 Shape::~Shape()
 {
@@ -67,16 +89,26 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 		mnCoordHeight = rSource.mnCoordHeight;
 	if ( rSource.mnStroked )
 		mnStroked = rSource.mnStroked;
-	if ( rSource.moFilled )
-		moFilled = rSource.moFilled;
+    if ( rSource.moFilled )
+        moFilled = rSource.moFilled;
+    if ( rSource.moFillType )
+		moFillType = rSource.moFillType;
+    if ( rSource.moFillImageUrl )
+        moFillImageUrl = rSource.moFillImageUrl;
 	if ( rSource.moFillColor )
 		moFillColor = rSource.moFillColor;
 	if ( rSource.maPath.Name.getLength() )
 		maPath = rSource.maPath;
 	if ( rSource.msPosition.getLength() )
 		msPosition = rSource.msPosition;
+    if ( rSource.moStrokeColor )
+        moStrokeColor = rSource.moStrokeColor;
+    if ( rSource.moStrokeWeight )
+        moStrokeWeight = rSource.moStrokeWeight;
 	maPosition = rSource.maPosition;
 	maSize = rSource.maSize;
+    meFillImageMode = rSource.meFillImageMode;
+    mbContainsText = rSource.mbContainsText;
 }
 
 ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > Shape::createAndInsert(
@@ -85,13 +117,15 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 			const awt::Rectangle* pShapeRect )
 {
 	uno::Reference< drawing::XShape > xShape;
+            
 	if ( rShape.msServiceName )
 	{
 		try
 		{
 			uno::Reference< lang::XMultiServiceFactory > xServiceFact( rFilterBase.getModel(), uno::UNO_QUERY_THROW );
 			xShape.set( xServiceFact->createInstance( rShape.msServiceName ), uno::UNO_QUERY_THROW );
-			rxShapes->add( xShape );
+    		rxShapes->add( xShape );
+
 			awt::Point aPosition;
 			awt::Size aSize;
 			if ( pShapeRect )
@@ -113,13 +147,54 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 			{
 				if ( maPath.Name.getLength() )
 					xPropSet->setPropertyValue( maPath.Name, maPath.Value );
+                if ( !moFilled )
+                    moFillType = ::boost::optional< sal_Int32 >( drawing::FillStyle_NONE );
 
 				::rtl::OUString sFillStyle( rtl::OUString::createFromAscii( "FillStyle" ) );
-				if ( moFilled )
-					xPropSet->setPropertyValue( sFillStyle, uno::Any( *moFilled ? drawing::FillStyle_SOLID : drawing::FillStyle_NONE ) );
+				xPropSet->setPropertyValue( sFillStyle, uno::Any( *moFillType ) );
+
+                if ( moFillImageUrl )
+                {
+                    // load the bitmap
+                    uno::Reference< io::XInputStream > xInputStream( rFilterBase.openInputStream( *moFillImageUrl ), uno::UNO_QUERY_THROW );
+
+		        	// load the fill bitmap into an XGraphic with the GraphicProvider
+                    static const rtl::OUString sGraphicProvider = rtl::OUString::createFromAscii( "com.sun.star.graphic.GraphicProvider" );
+                    uno::Reference< graphic::XGraphicProvider > xGraphicProvider( 
+                            rFilterBase.getGlobalFactory()->createInstance( sGraphicProvider ), uno::UNO_QUERY_THROW );
+
+                    static const rtl::OUString sInputStream = rtl::OUString::createFromAscii( "InputStream" );
+                    beans::PropertyValues aMediaProperties(1);
+		        	aMediaProperties[0].Name = sInputStream;
+        			aMediaProperties[0].Value <<= xInputStream;
+
+                    uno::Reference< awt::XBitmap > xBitmap( xGraphicProvider->queryGraphic( aMediaProperties ), 
+                            uno::UNO_QUERY_THROW );
+                    xPropSet->setPropertyValue( rtl::OUString::createFromAscii( "FillBitmap" ), uno::Any( xBitmap ) );
+
+                    // Set the bitmap fill size/repeat properties
+                    xPropSet->setPropertyValue( rtl::OUString::createFromAscii( "FillBitmapMode" ), uno::Any( meFillImageMode ) );
+                }
+
+                ::rtl::OUString sFillColor( rtl::OUString::createFromAscii( "FillColor" ) );
+                if ( moFillColor )
+                    xPropSet->setPropertyValue( sFillColor, uno::Any( *moFillColor ) );
+                
+                ::rtl::OUString sLineColor( rtl::OUString::createFromAscii( "LineColor" ) );
+                if ( moStrokeColor )
+                    xPropSet->setPropertyValue( sLineColor, uno::Any( *moStrokeColor ) );
+                
+                ::rtl::OUString sLineWidth( rtl::OUString::createFromAscii( "LineWidth" ) );
+                if ( moStrokeWeight )
+                    xPropSet->setPropertyValue( sLineWidth, uno::Any( *moStrokeWeight ) );
 			}
-			catch ( uno::Exception& )
+			catch ( uno::Exception& e )
 			{
+#if DEBUG
+                clog << "Exception when setting shape properties: ";
+                clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( );
+                clog << endl;
+#endif
 			}
 			::rtl::OUString rServiceName( rtl::OUString::createFromAscii( "com.sun.star.drawing.CustomShape" ) );
 			if ( rShape.msShapeType.getLength() && ( msServiceName == rServiceName ) )
@@ -130,13 +205,88 @@ void Shape::applyAttributes( const vml::Shape& rSource )
 			}
 			mxShape = xShape;
 		}
-		catch( uno::Exception& )
+		catch( uno::Exception& e )
 		{
+#if DEBUG
+            clog << "Exception thrown when creating shape: ";
+            clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
 		}
 	}
 	return xShape;
 }
 
+::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > Shape::createAndInsertFrame( 
+	const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Shape& rShape,
+		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
+			const awt::Rectangle* pShapeRect )
+{
+	uno::Reference< drawing::XShape > xShape;
+    static const OUString sFrameService( OUString::createFromAscii( "com.sun.star.text.TextFrame" ) );
+
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xServiceFact( rFilterBase.getModel(), uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextFrame > xFrame ( xServiceFact->createInstance( sFrameService ), uno::UNO_QUERY_THROW );
+        xShape.set( xFrame, uno::UNO_QUERY_THROW );
+  
+        // Set all the properties to the frame
+	    awt::Point aPosition;
+    	awt::Size aSize;
+	    if ( pShapeRect )
+		{
+			aPosition.X = pShapeRect->X;
+			aPosition.Y = pShapeRect->Y;
+			aSize.Width = pShapeRect->Width;
+			aSize.Height = pShapeRect->Height;
+		}
+		else
+		{
+			aPosition = maPosition;
+			aSize = maSize;
+		}
+		
+        uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+
+        // The size
+        xProps->setPropertyValue( OUString::createFromAscii( "SizeType" ), uno::Any( text::SizeType::FIX ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "FrameIsAutomaticHeight" ), uno::Any( sal_False ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "Height" ), uno::Any( aSize.Height ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "Width" ), uno::Any( aSize.Width ) );
+
+        // The position
+        xProps->setPropertyValue( OUString::createFromAscii( "HoriOrientPosition" ), uno::Any( aPosition.X ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "HoriOrientRelation" ), 
+                uno::Any( text::RelOrientation::FRAME ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "HoriOrient" ), 
+                uno::Any( text::HoriOrientation::NONE ) );
+
+        xProps->setPropertyValue( OUString::createFromAscii( "VertOrientPosition" ), uno::Any( aPosition.Y ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "VertOrientRelation" ), 
+                uno::Any( text::RelOrientation::FRAME ) );
+        xProps->setPropertyValue( OUString::createFromAscii( "VertOrient" ), 
+                uno::Any( text::VertOrientation::NONE ) );
+
+
+        // Anchor the frame into the document
+        uno::Reference< text::XTextDocument > xDoc( rFilterBase.getModel( ), uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextContent > xCtnt( xShape, uno::UNO_QUERY_THROW );
+        xCtnt->attach( xDoc->getText( )->getStart( ) );
+			
+        mxShape = xShape;
+    }
+    catch ( uno::Exception& e )
+    {
+#if DEBUG
+        clog << "Exception during TextFrame creation: ";
+        clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( );
+        clog << endl;
+#endif
+    }
+
+    return xShape;
+}
+
 void Shape::addChilds( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox::vml::Drawing& rDrawing,
 		const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
 			const awt::Rectangle& rClientRect )
@@ -212,7 +362,14 @@ void Shape::addShape( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox
 	aShape.applyAttributes( *this );
 
 	// creating XShape
-	uno::Reference< drawing::XShape > xShape( createAndInsert( rFilterBase, aShape, rxShapes, pShapeRect ) );
+    static const OUString sRectService( OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" ) );
+    bool bIsRectangle = msServiceName.equals( sRectService );
+
+    uno::Reference< drawing::XShape > xShape;
+    if ( mbContainsText && bIsRectangle )
+        xShape.set( createAndInsertFrame( rFilterBase, aShape, rxShapes, pShapeRect ) );
+    else
+    	xShape.set( createAndInsert( rFilterBase, aShape, rxShapes, pShapeRect ) );
 
 	// creating GroupShape if possible
 	uno::Reference< drawing::XShapes > xShapes( xShape, uno::UNO_QUERY );
@@ -232,4 +389,9 @@ void Shape::addShape( const ::oox::core::XmlFilterBase& rFilterBase, const ::oox
 	}
 }
 
+void Shape::updateShape( )
+{
+    // TODO Apply the shape attributes to the already added shape
+}
+
 } }
diff --git sw/source/core/doc/docredln.cxx sw/source/core/doc/docredln.cxx
index fd13119..86b6267 100644
--- sw/source/core/doc/docredln.cxx
+++ sw/source/core/doc/docredln.cxx
@@ -312,6 +312,7 @@ bool SwDoc::AppendRedline( SwRedline* pNewRedl, bool bCallDelete )
 #ifndef PRODUCT
     SwRedline aCopy( *pNewRedl );
 #endif
+    bool bError = true;
 	_CHECK_REDLINE( this )
 
 	if( IsRedlineOn() && !IsShowOriginal( eRedlineMode ) &&
@@ -431,6 +432,7 @@ bool SwDoc::AppendRedline( SwRedline* pNewRedl, bool bCallDelete )
 								pRedlineTbl->Insert( pRedl );
 							}
 
+                            bError = false;
 							bDelete = true;
 						}
 						else if( (( POS_BEFORE == eCmpPos &&
@@ -446,6 +448,7 @@ bool SwDoc::AppendRedline( SwRedline* pNewRedl, bool bCallDelete )
 							pRedlineTbl->Remove( n );
 							pRedlineTbl->Insert( pRedl );
 
+                            bError = false;
 							bDelete = true;
 						}
 						else if ( POS_OUTSIDE == eCmpPos )
@@ -1108,7 +1111,8 @@ bool SwDoc::AppendRedline( SwRedline* pNewRedl, bool bCallDelete )
 
 					case POS_EQUAL:
 					case POS_INSIDE:
-						delete pNewRedl, pNewRedl = 0;
+                        // TODO Check if there is any side effect
+						//delete pNewRedl, pNewRedl = 0;
 						break;
 
 					case POS_OUTSIDE:
@@ -1271,7 +1275,7 @@ bool SwDoc::AppendRedline( SwRedline* pNewRedl, bool bCallDelete )
 	}
 	_CHECK_REDLINE( this )
 
-	return 0 != pNewRedl;
+	return ( 0 != pNewRedl ) || !bError;
 }
 
 void SwDoc::CompressRedlines()
diff --git sw/source/core/docnode/ndtbl.cxx sw/source/core/docnode/ndtbl.cxx
index 7d67c27..744ab3b 100644
--- sw/source/core/docnode/ndtbl.cxx
+++ sw/source/core/docnode/ndtbl.cxx
@@ -1327,7 +1327,8 @@ SwTableNode* SwNodes::TextToTable( const std::vector< std::vector<SwNodeRange> >
                 SwTxtNode& rTxtNode = static_cast<SwTxtNode&>(rNode);
                 // setze den bei allen TextNode in der Tabelle den TableNode
                 // als StartNode
-                rTxtNode.pStartOfSection = pTblNd;
+// FIXME: this is setting wrong node StartOfSections in nested tables.
+//                rTxtNode.pStartOfSection = pTblNd;
                 // remove PageBreaks/PageDesc/ColBreak
                 const SwAttrSet* pSet = rTxtNode.GetpSwAttrSet();
                 if( pSet )
@@ -1406,7 +1407,6 @@ SwTableNode* SwNodes::TextToTable( const std::vector< std::vector<SwNodeRange> >
                         aCellNodeIdx = SwNodeIndex( *aCellNodeIdx.GetNode().EndOfSectionNode() );
                 }
 
-
                 // Section der Box zuweisen
                 pBox = new SwTableBox( pBoxFmt, *pSttNd, pLine );
                 pLine->GetTabBoxes().C40_INSERT( SwTableBox, pBox, nBoxes++ );
diff --git sw/source/core/unocore/unocrsrhelper.cxx sw/source/core/unocore/unocrsrhelper.cxx
index 89ca76b..ea7bdc4 100644
--- sw/source/core/unocore/unocrsrhelper.cxx
+++ sw/source/core/unocore/unocrsrhelper.cxx
@@ -1015,9 +1015,11 @@ void makeRedline( SwPaM& rPaM,
     }
 
     SwRedline* pRedline = new SwRedline( aRedlineData, rPaM );
+    RedlineMode_t nPrevMode = pRedlineAccess->GetRedlineMode( );
+
     pRedlineAccess->SetRedlineMode_intern(nsRedlineMode_t::REDLINE_ON);
     bool bRet = pRedlineAccess->AppendRedline( pRedline, false );
-    pRedlineAccess->SetRedlineMode_intern(nsRedlineMode_t::REDLINE_NONE);
+    pRedlineAccess->SetRedlineMode_intern( nPrevMode );
     if( !bRet )
         throw lang::IllegalArgumentException();
 }
diff --git sw/source/core/unocore/unodraw.cxx sw/source/core/unocore/unodraw.cxx
index 1c809ee..aea5c37 100644
--- sw/source/core/unocore/unodraw.cxx
+++ sw/source/core/unocore/unodraw.cxx
@@ -1977,6 +1977,7 @@ void SwXShape::attach(const uno::Reference< text::XTextRange > & xTextRange)
         OTextCursorHelper* pCursor = 0;
         SwXTextPortion* pPortion = 0;
         SwXText* pText = 0;
+        SwXParagraph* pParagraph = 0;
 
 		pRange 	= reinterpret_cast< SwXTextRange * >(
 				sal::static_int_cast< sal_IntPtr >( xRangeTunnel->getSomething( SwXTextRange::getUnoTunnelId()) ));
@@ -1986,6 +1987,8 @@ void SwXShape::attach(const uno::Reference< text::XTextRange > & xTextRange)
 				sal::static_int_cast< sal_IntPtr >( xRangeTunnel->getSomething( OTextCursorHelper::getUnoTunnelId()) ));
         pPortion = reinterpret_cast< SwXTextPortion * >(
 				sal::static_int_cast< sal_IntPtr >( xRangeTunnel->getSomething( SwXTextPortion::getUnoTunnelId()) ));
+        pParagraph = reinterpret_cast< SwXParagraph * >(
+                sal::static_int_cast< sal_IntPtr >( xRangeTunnel->getSomething( SwXParagraph::getUnoTunnelId( ) ) ) );
 
         if (pRange)
             pDoc = pRange->GetDoc();
@@ -1995,6 +1998,8 @@ void SwXShape::attach(const uno::Reference< text::XTextRange > & xTextRange)
             pDoc = pCursor->GetDoc();
 		else if ( !pDoc && pPortion && pPortion->GetCrsr() )
 			pDoc = pPortion->GetCrsr()->GetDoc();
+        else if ( !pDoc && pParagraph )
+           pDoc = pParagraph->GetCrsr( )->GetDoc( ); 
 
     }
 
diff --git sw/source/core/unocore/unoobj2.cxx sw/source/core/unocore/unoobj2.cxx
index 715fed4..12d4d27 100644
--- sw/source/core/unocore/unoobj2.cxx
+++ sw/source/core/unocore/unoobj2.cxx
@@ -1249,6 +1249,12 @@ SwXTextRange::SwXTextRange(SwFrmFmt& rTblFmt) :
 	aObjectDepend(this, &rTblFmt),
 	aPropSet(aSwMapProvider.GetPropertyMap(PROPERTY_MAP_TEXT_CURSOR))
 {
+    SwTable* pTable = SwTable::FindTable( &rTblFmt );
+    SwTableNode* pTblNode = pTable->GetTableNode( );
+    SwPosition aPosition( *pTblNode );
+    SwPaM aPam( aPosition );
+
+    _CreateNewBookmark( aPam );
 }
 
 /*-- 10.12.98 12:54:44---------------------------------------------------
diff --git sw/source/core/unocore/unotext.cxx sw/source/core/unocore/unotext.cxx
index fe6139d..fab01f9 100644
--- sw/source/core/unocore/unotext.cxx
+++ sw/source/core/unocore/unotext.cxx
@@ -68,6 +68,8 @@
 #include <memory>
 #include <stdlib.h>
 
+#include <iostream>
+
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
@@ -256,8 +258,8 @@ void SwXText::insertString(const uno::Reference< text::XTextRange > & xTextRange
 					sal::static_int_cast< sal_IntPtr >( xRangeTunnel->getSomething( OTextCursorHelper::getUnoTunnelId()) ));
 		}
 
-		if(pRange && pRange->GetDoc()  == GetDoc() ||
-			pCursor && pCursor->GetDoc()  == GetDoc())
+		if( ( pRange && pRange->GetDoc()  == GetDoc() ) ||
+			( pCursor && pCursor->GetDoc()  == GetDoc() ) )
 		{
 			const SwStartNode* pOwnStartNode = GetStartNode();
 			if(pCursor)
@@ -1871,18 +1873,11 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
             if(aStartCellPam.Start()->nNode < aEndCellPam.End()->nNode)
             {
                 const SwNode& rStartNode = aStartCellPam.Start()->nNode.GetNode();
-                if(!rStartNode.IsTxtNode() ||
-                        !aEndCellPam.End()->nNode.GetNode().IsTxtNode())
-                {
-                    //start and end of the cell must be on a SwTxtNode
-                    bExcept = true;
-                    break;
-                }
                 // increment on each StartNode and decrement on each EndNode
                 // we must reach zero at the end and must not go below zero
                 long nOpenNodeBlock = 0;
                 SwNodeIndex aCellIndex = aStartCellPam.Start()->nNode;
-                while( ++aCellIndex < aEndCellPam.End()->nNode.GetIndex())
+                while( aCellIndex < aEndCellPam.End()->nNode.GetIndex())
                 {
                     if( aCellIndex.GetNode().IsStartNode() )
                         ++nOpenNodeBlock;
@@ -1893,6 +1888,7 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
                         bExcept = true;
                         break;
                     }
+                    ++aCellIndex;
                 }
                 if( nOpenNodeBlock != 0)
                 {
@@ -1938,7 +1934,9 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
                     //node border anyway
                 }
                 else
+                {
                     bExcept = true;
+                }
             }
            //now check if there's a need to insert another paragraph break
             if( aEndCellPam.End()->nContent.GetIndex() < aEndCellPam.End()->nNode.GetNode().GetTxtNode()->Len())
@@ -1995,7 +1993,22 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
         const beans::PropertyValue* pTableProperties = rTableProperties.getConstArray();
         sal_Int32 nProperty = 0;
         for( ; nProperty < rTableProperties.getLength(); ++nProperty)
-            xPrSet->setPropertyValue( pTableProperties[nProperty].Name, pTableProperties[nProperty].Value );
+        {
+            try 
+            {
+                xPrSet->setPropertyValue( pTableProperties[nProperty].Name, pTableProperties[nProperty].Value );
+            }
+            catch ( const uno::Exception e )
+            {
+#if DEBUG
+                std::clog << "Exception when setting property: ";
+                std::clog << rtl::OUStringToOString( pTableProperties[nProperty].Name, RTL_TEXTENCODING_UTF8 ).getStr( );
+                std::clog << ". Message: ";
+                std::clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( );
+                std::clog << std::endl;
+#endif
+            }
+        }
 
         //apply row properties
         uno::Reference< table::XTableRows >  xRows = xRet->getRows();
@@ -2052,6 +2065,7 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
 //--<
 #endif
 
+
         //apply cell properties
         for( nRow = 0; nRow < rCellProperties.getLength(); ++nRow)
         {
@@ -2064,7 +2078,8 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
                 uno::Reference< beans::XPropertySet > xCell( pTextTable->getCellByPosition(nCell, nRow), uno::UNO_QUERY );
                 for( nProperty = 0; nProperty < nCellProperties; ++nProperty)
                 {
-                    if(aCellProperties[nProperty].Name.equalsAsciiL(
+                    const OUString& rName = aCellProperties[nProperty].Name;
+                    if( rName.equalsAsciiL(
                                 RTL_CONSTASCII_STRINGPARAM ( "VerticalMerge")))
                     {
                         //determine left border position
@@ -2127,8 +2142,24 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
                             }
                         }
                     }
-                    else
-                        xCell->setPropertyValue(aCellProperties[nProperty].Name, aCellProperties[nProperty].Value);
+                    else 
+                    {
+                        try
+                        {
+                            xCell->setPropertyValue(rName, aCellProperties[nProperty].Value);
+                        }
+                        catch ( const uno::Exception e )
+                        {
+                            // Apply the paragraph and char properties to the cell's content
+                            uno::Reference< text::XText > xCellText( xCell, uno::UNO_QUERY );
+                            uno::Reference< text::XTextCursor > xCellCurs = xCellText->createTextCursor( );
+                            xCellCurs->gotoStart( false );
+                            xCellCurs->gotoEnd( true );
+    
+                            uno::Reference< beans::XPropertySet > xCellTextProps( xCellCurs, uno::UNO_QUERY );
+                            xCellTextProps->setPropertyValue( rName, aCellProperties[nProperty].Value );
+                        }
+                    }
                 }
             }
         }
@@ -2166,30 +2197,6 @@ uno::Reference< text::XTextTable > SwXText::convertToTable(
     {
         (void)rBounds;
     }
-
-
-        bool bIllegalException = false;
-        bool bRuntimeException = false;
-        ::rtl::OUString sMessage;
-        pDoc->StartUndo(UNDO_START, NULL);
-        pDoc->EndUndo(UNDO_START, NULL);
-        if( bIllegalException || bRuntimeException )
-        {
-            SwUndoIter aUndoIter( pFirstPaM.get(), UNDO_EMPTY );
-            pDoc->Undo(aUndoIter);
-            if(bIllegalException)
-            {
-                lang::IllegalArgumentException aEx;
-                aEx.Message = sMessage;
-                throw aEx;
-            }
-            else //if(bRuntimeException)
-            {
-                uno::RuntimeException aEx;
-                aEx.Message = sMessage;
-                throw aEx;
-            }
-        }
     return xRet;
 }
 
diff --git writerfilter/inc/dmapper/DomainMapper.hxx writerfilter/inc/dmapper/DomainMapper.hxx
index 7d16243..3f2ad51 100644
--- writerfilter/inc/dmapper/DomainMapper.hxx
+++ writerfilter/inc/dmapper/DomainMapper.hxx
@@ -66,6 +66,7 @@ using namespace std;
 
 class PropertyMap;
 class DomainMapper_Impl;
+class ListTable;
 
 // different context types require different sprm handling (e.g. names)
 enum SprmType
@@ -107,8 +108,12 @@ public:
     virtual void endSectionGroup();
     virtual void startParagraphGroup();
     virtual void endParagraphGroup();
+    virtual void markLastParagraphInSection();
     virtual void startCharacterGroup();
     virtual void endCharacterGroup();
+    virtual void startShape( ::com::sun::star::uno::Reference< com::sun::star::drawing::XShape > xShape );
+    virtual void endShape( );
+
     virtual void text(const sal_uInt8 * data, size_t len);
     virtual void utext(const sal_uInt8 * data, size_t len);
     virtual void props(writerfilter::Reference<Properties>::Pointer_t ref);
@@ -120,8 +125,8 @@ public:
 
     void sprm( Sprm& sprm, ::boost::shared_ptr<PropertyMap> pContext, SprmType = SPRM_DEFAULT );
 
-    void PushStyleSheetProperties( ::boost::shared_ptr<PropertyMap> pStyleProperties );
-    void PopStyleSheetProperties();
+    void PushStyleSheetProperties( ::boost::shared_ptr<PropertyMap> pStyleProperties, bool bAffectTableMngr = false );
+    void PopStyleSheetProperties( bool bAffectTableMngr = false );
     
     void PushListProperties( ::boost::shared_ptr<PropertyMap> pListProperties );
     void PopListProperties();
@@ -132,6 +137,7 @@ public:
     ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > GetCurrentTextRange();
 
     ::rtl::OUString getOrCreateCharStyle( PropertyValueVector_t& rCharProperties );
+    boost::shared_ptr< ListTable > GetListTable( );
 
 private:
     void handleUnderlineType(const sal_Int32 nIntValue, const ::boost::shared_ptr<PropertyMap> pContext);
diff --git writerfilter/inc/resourcemodel/TableData.hxx writerfilter/inc/resourcemodel/TableData.hxx
index 3d3076e..a43f253 100644
--- writerfilter/inc/resourcemodel/TableData.hxx
+++ writerfilter/inc/resourcemodel/TableData.hxx
@@ -276,6 +276,11 @@ class WRITERFILTER_DLLPUBLIC TableData
     typedef ::std::vector<RowPointer_t> Rows;
 
     /**
+       the table properties
+     */
+    PropertiesPointer mpTableProps;
+
+    /**
        the data of the rows of the table
     */
     Rows mRows;
@@ -349,6 +354,22 @@ public:
         mpRow->insertCellProperties(i, pProps);
     }
 
+    void insertTableProperties( PropertiesPointer pProps )
+    {
+        if ( mpTableProps.get( ) )
+            mpTableProps->insert( pProps );
+        else
+            mpTableProps = pProps;
+    }
+
+    /**
+      Return the table properties.
+     */
+    PropertiesPointer getTableProperties( ) 
+    {
+        return mpTableProps;
+    }
+
     /**
        Return number of rows in the table.
      */
diff --git writerfilter/inc/resourcemodel/TableManager.hxx writerfilter/inc/resourcemodel/TableManager.hxx
index 54169d9..24e9aec 100644
--- writerfilter/inc/resourcemodel/TableManager.hxx
+++ writerfilter/inc/resourcemodel/TableManager.hxx
@@ -103,6 +103,11 @@ public:
         @param rT    end handle of cell
     */
     virtual void endCell(const T & rT) = 0;
+
+    virtual T* getTable( )
+    {
+        return NULL;
+    };
 };
 
 template <typename T, typename PropertiesPointer>
@@ -151,16 +156,16 @@ class TableManager
     /**
        properties of the current cell
     */
-    PropertiesPointer mpCellProps;
+    vector< PropertiesPointer > mpCellProps;
 
     /**
         properties of the current row
     */
-    PropertiesPointer mpRowProps;
+    vector< PropertiesPointer > mpRowProps;
 
-    /**
-       properties of the current table
-    */
+    /** 
+        properties of the current table: don't use them directly.
+     */
     PropertiesPointer mpTableProps;
 
     /**
@@ -168,6 +173,7 @@ class TableManager
     */
     T mCurHandle;
 
+    T* mpInnerTable;
     /**
        stack of table data
 
@@ -231,7 +237,6 @@ protected:
      */
     virtual void clearData();
 
-
 public:
     TableManager();
     virtual ~TableManager(){}
@@ -351,7 +356,7 @@ public:
 template <typename T, typename PropertiesPointer>
 TableManager<T, PropertiesPointer>::TableManager()
 : mbRowEnd(false), mbInCell(false), mbCellEnd(false), mnTableDepthNew(0),
-  mnTableDepth(0)
+  mnTableDepth(0), mpInnerTable( NULL )
 {
 }
 
@@ -398,19 +403,30 @@ void TableManager<T, PropertiesPointer>::handle(const T & rHandle)
 template <typename T, typename PropertiesPointer>
 void TableManager<T, PropertiesPointer>::startLevel()
 {
+#if DEBUG
+    std::clog << "TableManager::startLevel()" << std::endl;
+#endif
     typename TableData<T, PropertiesPointer>::Pointer_t pTableData
         (new TableData<T, PropertiesPointer>(mTableDataStack.size()));
 
     mTableDataStack.push(pTableData);
+
+    PropertiesPointer pEmptyProps;
+    cellProps( pEmptyProps );
 }
 
 template <typename T, typename PropertiesPointer>
 void TableManager<T, PropertiesPointer>::endLevel()
 {
+#if DEBUG
+    std::clog << "TableManager::endLevel()" << std::endl;
+#endif
     if (mpTableDataHandler.get() != NULL)
         resolveCurrentTable();
-
     mTableDataStack.pop();
+
+    if ( mpCellProps.size( ) > 0 )
+        mpCellProps.pop_back( );
 }
 
 template <typename T, typename PropertiesPointer>
@@ -426,12 +442,6 @@ template <typename T, typename PropertiesPointer>
 void TableManager<T, PropertiesPointer>::endParagraphGroup()
 {
     sal_Int32 nTableDepthDifference = mnTableDepthNew - mnTableDepth;
-    while (nTableDepthDifference > 0)
-    {
-        startLevel();
-
-        --nTableDepthDifference;
-    }
     while (nTableDepthDifference < 0)
     {
         endLevel();
@@ -447,14 +457,23 @@ void TableManager<T, PropertiesPointer>::endParagraphGroup()
     if (mbRowEnd)
     {
         endOfRowAction();
-        pTableData->endRow(mpRowProps);
-        mpRowProps.reset();
+        pTableData->endRow( mpRowProps.back( ) );
+        mpRowProps.back( ).reset();
     }
-
-    else if (mbInCell)
+    else if ( mbInCell )
     {
         if (! pTableData->isCellOpen())
-            pTableData->addCell(mCurHandle, mpCellProps);
+        {
+            if ( mpInnerTable )
+            {
+                pTableData->addCell( *mpInnerTable, mpCellProps.back( ) );
+                mpInnerTable = NULL;
+            }
+            else
+            {
+                pTableData->addCell( mCurHandle, mpCellProps.back( ) );
+            }
+        }
 
         if (mbCellEnd)
         {
@@ -462,7 +481,8 @@ void TableManager<T, PropertiesPointer>::endParagraphGroup()
             pTableData->endCell(mCurHandle);
         }
     }
-    mpCellProps.reset();
+    if ( mpCellProps.size( ) > 0 )
+        mpCellProps.back().reset( );
 }
 
 template <typename T, typename PropertiesPointer>
@@ -538,10 +558,15 @@ void TableManager<T, PropertiesPointer>::utext(const sal_uInt8 * data, size_t le
 template <typename T, typename PropertiesPointer>
 void TableManager<T, PropertiesPointer>::cellProps(PropertiesPointer pProps)
 {
-    if(mpCellProps.get())
-        mpCellProps->insert( pProps );
+    if ( mpCellProps.size( ) == mTableDataStack.size( ) )
+    {
+        if ( mpCellProps.back( ).get( ) )
+            mpCellProps.back()->insert( pProps );
+        else
+            mpCellProps.back( ) = pProps;
+    }
     else
-        mpCellProps = pProps;
+        mpCellProps.push_back( pProps );
 }
 
 template <typename T, typename PropertiesPointer>
@@ -554,19 +579,24 @@ void TableManager<T, PropertiesPointer>::cellPropsByCell
 template <typename T, typename PropertiesPointer>
 void TableManager<T, PropertiesPointer>::insertRowProps(PropertiesPointer pProps)
 {
-    if( mpRowProps.get() )
-        mpRowProps->insert( pProps );
+    if ( mpRowProps.size( ) == ( mTableDataStack.size( ) - 1 ) )
+    {
+        if( mpRowProps.back( ).get( ) )
+            mpRowProps.back( )->insert( pProps );
+        else
+            mpRowProps.back( ) = pProps;
+    }
     else
-        mpRowProps = pProps;
+        mpRowProps.push_back( pProps );
 }
 
 template <typename T, typename PropertiesPointer>
 void TableManager<T, PropertiesPointer>::insertTableProps(PropertiesPointer pProps)
 {
-    if( mpTableProps.get() )
-        mpTableProps->insert( pProps );
-    else
-        mpTableProps = pProps;
+    typename TableData<T, PropertiesPointer>::Pointer_t
+        pTableData = mTableDataStack.top();
+
+    pTableData->insertTableProperties( pProps );
 }
 
 template <typename T, typename PropertiesPointer>
@@ -579,7 +609,7 @@ void TableManager<T, PropertiesPointer>::resolveCurrentTable()
 
         unsigned int nRows = pTableData->getRowCount();
 
-        mpTableDataHandler->startTable(nRows, pTableData->getDepth(), mpTableProps);
+        mpTableDataHandler->startTable(nRows, pTableData->getDepth(), pTableData->getTableProperties( ) );
 
         for (unsigned int nRow = 0; nRow < nRows; ++nRow)
         {
@@ -602,8 +632,12 @@ void TableManager<T, PropertiesPointer>::resolveCurrentTable()
         }
 
         mpTableDataHandler->endTable();
+
+        // The inner table has to be stored only if there is something in the stack
+        // The 0 depth is the dummy table for the whole stream
+        if ( pTableData->getDepth( ) > 1 )
+            mpInnerTable = mpTableDataHandler->getTable( );
     }
-    mpTableProps.reset();
     clearData();
 }
 
diff --git writerfilter/inc/resourcemodel/WW8ResourceModel.hxx writerfilter/inc/resourcemodel/WW8ResourceModel.hxx
index 76c08d1..d506f38 100644
--- writerfilter/inc/resourcemodel/WW8ResourceModel.hxx
+++ writerfilter/inc/resourcemodel/WW8ResourceModel.hxx
@@ -35,6 +35,7 @@
 #include <memory>
 #include <boost/shared_ptr.hpp>
 #include <sal/types.h>
+#include <com/sun/star/drawing/XShape.hpp>
 #include <com/sun/star/uno/Any.hxx>
 #include <WriterFilterDllApi.hxx>
 #include <resourcemodel/OutputWithDepth.hxx>
@@ -208,6 +209,8 @@ public:
        Receives end mark for group with the same paragraph properties.
      */
     virtual void endParagraphGroup() = 0;
+    
+    virtual void markLastParagraphInSection( ) { };
 
     /**
        Receives start mark for group with the same character properties.
@@ -220,6 +223,13 @@ public:
     virtual void endCharacterGroup() = 0;
 
     /**
+      Receives a shape.
+     */
+    virtual void startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape ) = 0;
+
+    virtual void endShape( ) = 0;
+
+    /**
        Receives 8-bit per character text.
 
        @param data  buffer containing the text
diff --git writerfilter/source/dmapper/BorderHandler.cxx writerfilter/source/dmapper/BorderHandler.cxx
index c3ed4ed..a7679a8 100644
--- writerfilter/source/dmapper/BorderHandler.cxx
+++ writerfilter/source/dmapper/BorderHandler.cxx
@@ -137,6 +137,8 @@ void BorderHandler::sprm(Sprm & rSprm)
                 pProperties->resolve(*this);
             ConversionHelper::MakeBorderLine( m_nLineWidth,   m_nLineType, m_nLineColor,  
                                    m_aBorderLines[rSprm.getId() - NS_ooxml::LN_CT_TblBorders_top], m_bOOXML );
+
+            m_aFilledLines[ rSprm.getId( ) - NS_ooxml::LN_CT_TblBorders_top] = true;
         }
         break;
         default:;
@@ -161,7 +163,11 @@ PropertyMapPtr  BorderHandler::getProperties()
     if( m_bOOXML || m_nCurrentBorderPosition )
     {
         for( sal_Int32 nProp = 0; nProp < BORDER_COUNT; ++nProp)
-            pPropertyMap->Insert( aPropNames[nProp], false, uno::makeAny( m_aBorderLines[nProp] ) );
+        {
+            if ( m_aFilledLines[nProp] ) {
+                pPropertyMap->Insert( aPropNames[nProp], false, uno::makeAny( m_aBorderLines[nProp] ) );
+            }
+        }
     }
     return pPropertyMap;
 }
diff --git writerfilter/source/dmapper/BorderHandler.hxx writerfilter/source/dmapper/BorderHandler.hxx
index cc2c263..53fa912 100644
--- writerfilter/source/dmapper/BorderHandler.hxx
+++ writerfilter/source/dmapper/BorderHandler.hxx
@@ -63,6 +63,7 @@ private:
     sal_Int32       m_nLineDistance;
     bool            m_bOOXML;
 
+    bool                                        m_aFilledLines[BORDER_COUNT];
     ::com::sun::star::table::BorderLine         m_aBorderLines[BORDER_COUNT];
 
 public:
diff --git writerfilter/source/dmapper/CellColorHandler.cxx writerfilter/source/dmapper/CellColorHandler.cxx
index f97ee4d..fc931f4 100644
--- writerfilter/source/dmapper/CellColorHandler.cxx
+++ writerfilter/source/dmapper/CellColorHandler.cxx
@@ -110,6 +110,11 @@ void CellColorHandler::attribute(Id rName, Value & rVal)
 //            }
 //        }
 //        break;
+        case NS_ooxml::LN_CT_Shd_themeFill:
+        case NS_ooxml::LN_CT_Shd_themeFillTint:
+        case NS_ooxml::LN_CT_Shd_themeFillShade:
+            // ignored
+            break;
         default:
             OSL_ENSURE( false, "unknown attribute");
     }
diff --git writerfilter/source/dmapper/ConversionHelper.cxx writerfilter/source/dmapper/ConversionHelper.cxx
index 18196b3..a3bde53 100644
--- writerfilter/source/dmapper/ConversionHelper.cxx
+++ writerfilter/source/dmapper/ConversionHelper.cxx
@@ -276,6 +276,10 @@ void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
         case 21:
             eCodeIdx = double1;//  60 Twips for us
             break;
+        case 0:
+        case 255:
+            eCodeIdx = none;
+            break;
         default:
             eCodeIdx = single0;
             break;
@@ -306,7 +310,8 @@ void MakeBorderLine( sal_Int32 nLineThickness,   sal_Int32 nLineType,
         /*13*/  { DOUBLE_LINE7_OUT, DOUBLE_LINE7_IN, DOUBLE_LINE7_DIST },
         /*14*/  { DOUBLE_LINE8_OUT, DOUBLE_LINE8_IN, DOUBLE_LINE8_DIST },
         /*15*/  { DOUBLE_LINE9_OUT, DOUBLE_LINE9_IN, DOUBLE_LINE9_DIST },
-        /*16*/  { DOUBLE_LINE10_OUT,DOUBLE_LINE10_IN,DOUBLE_LINE10_DIST}
+        /*16*/  { DOUBLE_LINE10_OUT,DOUBLE_LINE10_IN,DOUBLE_LINE10_DIST},
+        /*17*/  { 0, 0, 0 }
     };
 
     rToFill.Color = nLineColor;
diff --git writerfilter/source/dmapper/DomainMapper.cxx writerfilter/source/dmapper/DomainMapper.cxx
index 5758176..4fd3e61 100644
--- writerfilter/source/dmapper/DomainMapper.cxx
+++ writerfilter/source/dmapper/DomainMapper.cxx
@@ -28,9 +28,12 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
+#include "PageBordersHandler.hxx"
+
 #include <dmapper/DomainMapper.hxx>
 #include <DomainMapper_Impl.hxx>
 #include <ConversionHelper.hxx>
+#include <ListTable.hxx>
 #include <ThemeTable.hxx>
 #include <ModelEventListener.hxx>
 #include <MeasureHandler.hxx>
@@ -179,6 +182,10 @@ DomainMapper::~DomainMapper()
             uno::Reference< document::XEventBroadcaster > xBroadcaster(xIndexesSupplier, uno::UNO_QUERY);
             xBroadcaster->addEventListener(uno::Reference< document::XEventListener >(new ModelEventListener));
         }
+
+
+        // Apply the document settings after everything else
+        m_pImpl->GetSettingsTable()->ApplyProperties( m_pImpl->GetTextDocument( ) );
     }
     catch( const uno::Exception& rEx )
     {
@@ -554,8 +561,8 @@ void DomainMapper::attribute(Id nName, Value & val)
             //if the style is a user defined style then it must have an ISTD - built-in styles might not have it
             StyleSheetTablePtr pStyleSheets = m_pImpl->GetStyleSheetTable();
             ::rtl::OUString sValue = ::rtl::OUString::valueOf(nIntValue, 16);
-            const StyleSheetEntry* pEntry = pStyleSheets->FindStyleSheetByISTD(sValue);
-            if(pEntry)
+            const StyleSheetEntryPtr pEntry = pStyleSheets->FindStyleSheetByISTD(sValue);
+            if( pEntry.get( ) )
             {
                 bool bParaStyle = (pEntry->nStyleTypeCode == STYLE_TYPE_PARA);
                 if(bParaStyle)
@@ -1884,12 +1891,12 @@ void DomainMapper::attribute(Id nName, Value & val)
             /* WRITERFILTERSTATUS: done: 80, planned: 0.5, spent: 0.2 */
             //TODO: autospacing depends on some document property (called fDontUseHTMLAutoSpacing in old ww8 filter) 100 or 280 twip
             //and should be set to 0 on start of page
-            m_pImpl->GetTopContext()->Insert( PROP_TOP_MARGIN, false, uno::makeAny( AUTO_PARA_SPACING ) );
+            m_pImpl->GetTopContext()->Insert( PROP_PARA_TOP_MARGIN, false, uno::makeAny( AUTO_PARA_SPACING ) );
         break;
         case NS_ooxml::LN_CT_Spacing_afterAutospacing:
             /* WRITERFILTERSTATUS: done: 80, planned: 0.5, spent: 0.2 */
             //TODO: autospacing depends on some document property (called fDontUseHTMLAutoSpacing in old ww8 filter) 100 or 280 twip
-            m_pImpl->GetTopContext()->Insert( PROP_BOTTOM_MARGIN, false, uno::makeAny( AUTO_PARA_SPACING ) );
+            m_pImpl->GetTopContext()->Insert( PROP_PARA_BOTTOM_MARGIN, false, uno::makeAny( AUTO_PARA_SPACING ) );
         break;
         case NS_ooxml::LN_CT_SmartTagRun_uri:
         case NS_ooxml::LN_CT_SmartTagRun_element:
@@ -1928,13 +1935,6 @@ void DomainMapper::attribute(Id nName, Value & val)
             //afterwards the adding of the binary data.
             m_pImpl->GetGraphicImport( IMPORT_AS_DETECTED_INLINE )->attribute(nName, val);
             m_pImpl->ImportGraphic( val.getProperties(), IMPORT_AS_DETECTED_INLINE );
-            if( m_pImpl->IsInShapeContext() )
-            {
-                //imported text from temporary shape needs to be copied to the real shape
-                uno::Reference< drawing::XShape > xShape;
-                val.getAny() >>= xShape;
-                m_pImpl->CopyTemporaryShapeText( xShape );
-            }
         }
         break;
         case NS_ooxml::LN_CT_FramePr_dropCap:
@@ -2092,19 +2092,12 @@ void DomainMapper::attribute(Id nName, Value & val)
         break;
         case NS_ooxml::LN_CT_Markup_id:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            m_pImpl->SetCurrentRedlineId( sStringValue );
+            m_pImpl->SetCurrentRedlineId( nIntValue );
         break;
         case NS_ooxml::LN_token:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             m_pImpl->SetCurrentRedlineToken( nIntValue );
         break;
-        case NS_ooxml::LN_mark_shape:
-            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            if( nIntValue )
-                m_pImpl->PopShapeContext();
-            else
-                m_pImpl->PushShapeContext();
-        break;
         case NS_ooxml::LN_CT_LineNumber_countBy:
         /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
         case NS_ooxml::LN_CT_LineNumber_restart:
@@ -2146,6 +2139,9 @@ void DomainMapper::attribute(Id nName, Value & val)
         case NS_ooxml::LN_CT_Color_themeShade:
             //unsupported
         break;
+    case NS_ooxml::LN_endtrackchange:
+        m_pImpl->RemoveCurrentRedline( );
+    break;
         default:
             {
 #if OSL_DEBUG_LEVEL > 0
@@ -2627,6 +2623,15 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         break;  // sprmPPropRMark
     case NS_sprm::LN_POutLvl:
         /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
+        { 
+            if( m_pImpl->IsStyleSheetImport() )
+            {
+                sal_Int16 nLvl = static_cast< sal_Int16 >( nIntValue );
+
+                StyleSheetPropertyMap* pStyleSheetPropertyMap = dynamic_cast< StyleSheetPropertyMap* >( rContext.get() );
+                pStyleSheetPropertyMap->SetOutlineLevel( nLvl );
+            }
+        }
         break;  // sprmPOutLvl
     case NS_sprm::LN_PFBiDi:
         /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
@@ -3876,6 +3881,20 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         }
     }
     break;
+    case NS_ooxml::LN_EG_SectPrContents_pgBorders:
+    {
+        writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+        if( pProperties.get( ) && pSectionContext )
+        {
+            PageBordersHandlerPtr pHandler( new PageBordersHandler );
+            pProperties->resolve( *pHandler );
+
+            // Set the borders to the context and apply them to the styles
+            pHandler->SetBorders( pSectionContext );
+            pSectionContext->SetBorderParams( pHandler->GetDisplayOffset( ) );
+        }
+    }
+    break;
 
     case NS_ooxml::LN_CT_PPrBase_pStyle:
     {
@@ -3885,20 +3904,31 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         const ::rtl::OUString sConvertedStyleName = pStyleTable->ConvertStyleName( sStringValue, true );
 		if (m_pImpl->GetTopContext() && m_pImpl->GetTopContextType() != CONTEXT_SECTION)
 	        m_pImpl->GetTopContext()->Insert( PROP_PARA_STYLE_NAME, true, uno::makeAny( sConvertedStyleName ));
-        const StyleSheetEntry* pEntry = pStyleTable->FindStyleSheetByISTD(sStringValue);
+        const StyleSheetEntryPtr pEntry = pStyleTable->FindStyleSheetByISTD(sStringValue);
         //apply numbering to paragraph if it was set at the style
-        OSL_ENSURE( pEntry, "no style sheet found" );
+        OSL_ENSURE( pEntry.get(), "no style sheet found" );
         const StyleSheetPropertyMap* pStyleSheetProperties = dynamic_cast<const StyleSheetPropertyMap*>(pEntry ? pEntry->pProperties.get() : 0);
+        
         if( pStyleSheetProperties && pStyleSheetProperties->GetListId() >= 0 )
-            rContext->Insert( PROP_NUMBERING_RULES, true, uno::makeAny(m_pImpl->GetListTable()->GetNumberingRules(pStyleSheetProperties->GetListId())), false);
+            rContext->Insert( PROP_NUMBERING_STYLE_NAME, true, uno::makeAny( 
+                        m_pImpl->GetListTable( )->GetStyleName( pStyleSheetProperties->GetListId( ) ) ), false);
+        
         if( pStyleSheetProperties && pStyleSheetProperties->GetListLevel() >= 0 )
             rContext->Insert( PROP_NUMBERING_LEVEL, true, uno::makeAny(pStyleSheetProperties->GetListLevel()), false);
     }
     break;
     case NS_ooxml::LN_EG_RPrBase_rStyle:
         /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-        if (m_pImpl->GetTopContext())
-            m_pImpl->GetTopContext()->Insert( PROP_CHAR_STYLE_NAME, true, uno::makeAny( m_pImpl->GetStyleSheetTable()->ConvertStyleName( sStringValue, true )));
+        {
+            rtl::OUString sConvertedName( m_pImpl->GetStyleSheetTable()->ConvertStyleName( sStringValue, true ) );
+            // First check if the style exists in the document.
+            StyleSheetEntryPtr pEntry = m_pImpl->GetStyleSheetTable( )->FindStyleSheetByStyleName( sConvertedName );
+            bool bExists = pEntry.get( ) && ( pEntry->nStyleTypeCode == STYLE_TYPE_CHAR );
+
+            // Add the property if the style exists
+            if ( bExists && m_pImpl->GetTopContext() )
+                m_pImpl->GetTopContext()->Insert( PROP_CHAR_STYLE_NAME, true, uno::makeAny( sConvertedName ) );
+        }
     break;
     case NS_ooxml::LN_CT_TblPrBase_tblCellMar: //cell margins
         /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
@@ -3966,7 +3996,7 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
                 m_pImpl->ResetGraphicImport();
                 // todo: It's a shape, now start shape import
             }
-        }
+        } 
     }
     break;
     case NS_ooxml::LN_EG_RPrBase_vertAlign:
@@ -4035,16 +4065,16 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
         }
     }
     break;
+    case NS_ooxml::LN_paratrackchange:
+        m_pImpl->StartParaChange( );
     case NS_ooxml::LN_trackchange:
         /* WRITERFILTERSTATUS: done: 100, planned: 5, spent: 0 */
     case NS_ooxml::LN_EG_RPrContent_rPrChange:
         /* WRITERFILTERSTATUS: done: 100, planned: 5, spent: 0 */
     {
+        m_pImpl->AddNewRedline( );
         resolveSprmProps( rSprm );
         // now the properties author, date and id should be available
-        ::rtl::OUString sAuthor = m_pImpl->GetCurrentRedlineAuthor();
-        ::rtl::OUString sDate = m_pImpl->GetCurrentRedlineDate();
-        ::rtl::OUString sId = m_pImpl->GetCurrentRedlineId();
         sal_Int32 nToken = m_pImpl->GetCurrentRedlineToken();
         switch( nToken & 0xffff )
         {
@@ -4053,6 +4083,7 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
             case ooxml::OOXML_del : break;
             default: OSL_ENSURE( false, "redline token other than mod, ins or del" );
         }
+        m_pImpl->EndParaChange( );
     }
     break;
     case NS_ooxml::LN_CT_RPrChange_rPr:
@@ -4061,16 +4092,22 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
     /* WRITERFILTERSTATUS: done: 0, planned: 4, spent: 0 */
     case NS_ooxml::LN_object:
     {
+#if DEBUG
+        clog << "DomainMapper: LN_object" << endl;
+#endif
         writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-        if( pProperties.get())
+        if( pProperties.get( ) )
         {
             OLEHandlerPtr pOLEHandler( new OLEHandler );
             pProperties->resolve(*pOLEHandler);
-            ::rtl::OUString sStreamName = pOLEHandler->copyOLEOStream( m_pImpl->GetTextDocument() );
-            if(sStreamName.getLength())
+            if ( pOLEHandler->isOLEObject( ) )
             {
-                m_pImpl->appendOLE( sStreamName, pOLEHandler );
-            }
+                ::rtl::OUString sStreamName = pOLEHandler->copyOLEOStream( m_pImpl->GetTextDocument() );
+                if( sStreamName.getLength() )
+                {
+                    m_pImpl->appendOLE( sStreamName, pOLEHandler );
+                }
+            } 
         }
     }
     break;
@@ -4098,7 +4135,6 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
     case NS_ooxml::LN_CT_Lvl_pStyle:
         //TODO: numbering style should apply current numbering level - not yet supported
     break;
-
     default:
         {
 #if OSL_DEBUG_LEVEL > 0
@@ -4106,7 +4142,10 @@ void DomainMapper::sprm( Sprm& rSprm, PropertyMapPtr rContext, SprmType eSprmTyp
             sMessage += ::rtl::OString::valueOf( sal_Int32( nSprmId ), 10 );
             sMessage += ::rtl::OString(" / 0x");
             sMessage += ::rtl::OString::valueOf( sal_Int32( nSprmId ), 16 );
-            OSL_ENSURE( false, sMessage.getStr()); //
+            sMessage += ::rtl::OString(" / ");
+            sMessage += ::rtl::OString( rSprm.getName( ).c_str( ) );
+            clog << sMessage.getStr( ) << endl;
+//            OSL_ENSURE( false, sMessage.getStr()); //
 #endif
         }
     }
@@ -4183,38 +4222,6 @@ void DomainMapper::startParagraphGroup()
 -----------------------------------------------------------------------*/
 void DomainMapper::endParagraphGroup()
 {
-    //handle unprocessed deferred breaks
-    PropertyMapPtr pParaProperties = m_pImpl->GetTopContextOfType(CONTEXT_PARAGRAPH);
-    if( pParaProperties->hasEmptyPropertyValues() )
-    {
-        PropertyMap::const_iterator aIter = pParaProperties->find(PropertyDefinition( PROP_BREAK_TYPE , false ) );
-        if( aIter != pParaProperties->end() )
-        {
-            style::BreakType eType;
-            aIter->second >>= eType;
-            bool bPage = false;
-            bool bColumn = false;
-            if( eType == style::BreakType_PAGE_BEFORE )
-                bPage = true;
-            else if( eType == style::BreakType_COLUMN_BEFORE )
-                 bColumn = true;
-
-            if( bPage || bColumn )
-            {
-                try
-                {
-                        uno::Reference< beans::XPropertySet > xRangeProperties( m_pImpl->GetTopTextAppend()->getEnd(), uno::UNO_QUERY_THROW );
-                        xRangeProperties->setPropertyValue(
-                            PropertyNameSupplier::GetPropertyNameSupplier().GetName(PROP_BREAK_TYPE),
-                                                    uno::makeAny( bPage ? style::BreakType_PAGE_BEFORE : style::BreakType_COLUMN_BEFORE));
-                }
-                catch( const uno::Exception& )
-                {
-                }
-            }
-        }
-    }
-
     m_pImpl->PopProperties(CONTEXT_PARAGRAPH);
     m_pImpl->getTableManager().endParagraphGroup();
     //frame conversion has to be executed after table conversion
@@ -4224,19 +4231,44 @@ void DomainMapper::endParagraphGroup()
 #endif
 }
 
+void DomainMapper::markLastParagraphInSection( )
+{
+#ifdef DEBUG_DOMAINMAPPER
+    dmapper_logger->element( "markLastParagraphInSection" );
+#endif
+    m_pImpl->SetIsLastParagraphInSection( true );
+}
+
+void DomainMapper::startShape( uno::Reference< drawing::XShape > xShape )
+{
+    m_pImpl->PushShapeContext( xShape );
+}
+
+void DomainMapper::endShape( ) 
+{
+    m_pImpl->PopShapeContext( );
+}
+
 /*-- 13.06.2007 16:15:55---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void DomainMapper::PushStyleSheetProperties( PropertyMapPtr pStyleProperties )
+void DomainMapper::PushStyleSheetProperties( PropertyMapPtr pStyleProperties, bool bAffectTableMngr )
 {
     m_pImpl->PushStyleProperties( pStyleProperties );
+    if ( bAffectTableMngr )
+        m_pImpl->getTableManager( ).SetStyleProperties( pStyleProperties );
 }
 /*-- 13.06.2007 16:15:55---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void DomainMapper::PopStyleSheetProperties()
+void DomainMapper::PopStyleSheetProperties( bool bAffectTableMngr )
 {
     m_pImpl->PopProperties( CONTEXT_STYLESHEET );
+    if ( bAffectTableMngr )
+    {
+        PropertyMapPtr emptyPtr;
+        m_pImpl->getTableManager( ).SetStyleProperties( emptyPtr );
+    }
 }
 /*-- 28.01.2008 14:52:33---------------------------------------------------
 
@@ -4483,10 +4515,13 @@ void DomainMapper::table(Id name, writerfilter::Reference<Table>::Pointer_t ref)
         break;
     case NS_ooxml::LN_NUMBERING:
     case NS_rtf::LN_LISTTABLE:
-        /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
+        {
+            /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
 
-        //the same for list tables
-        ref->resolve( *m_pImpl->GetListTable() );
+            //the same for list tables
+            ref->resolve( *m_pImpl->GetListTable() );
+            m_pImpl->GetListTable( )->CreateNumberingRules( );
+        }
         break;
     case NS_rtf::LN_LFOTABLE:
         /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
@@ -4496,6 +4531,9 @@ void DomainMapper::table(Id name, writerfilter::Reference<Table>::Pointer_t ref)
     case NS_ooxml::LN_THEMETABLE:
         ref->resolve ( *m_pImpl->GetThemeTable() );
     break;
+    case NS_ooxml::LN_SETTINGS:
+        ref->resolve( *m_pImpl->GetSettingsTable( ) );
+    break;
     default:
         OSL_ENSURE( false, "which table is to be filled here?");
     }
@@ -4581,7 +4619,7 @@ void DomainMapper::substream(Id rName, ::writerfilter::Reference<Stream>::Pointe
         m_pImpl->PopAnnotation();
     break;
     }
-
+    
     m_pImpl->getTableManager().endLevel();
 
 #ifdef DEBUG_DOMAINMAPPER
@@ -4818,5 +4856,10 @@ uno::Reference< text::XTextRange > DomainMapper::GetCurrentTextRange()
     return pStyleSheets->getOrCreateCharStyle( rCharProperties );
 }
 
+ListTablePtr DomainMapper::GetListTable( )
+{
+    return m_pImpl->GetListTable( );
+}
+
 } //namespace dmapper
 } //namespace writerfilter
diff --git writerfilter/source/dmapper/DomainMapperTableHandler.cxx writerfilter/source/dmapper/DomainMapperTableHandler.cxx
index 8f6febe..5f2efa4 100644
--- writerfilter/source/dmapper/DomainMapperTableHandler.cxx
+++ writerfilter/source/dmapper/DomainMapperTableHandler.cxx
@@ -68,7 +68,22 @@ static void  lcl_printProperties( PropertyMapPtr pProps )
         {
             rtl::OUString aOUStr = rPropSupplier.GetName( aMapIter->first.eId );
             rtl::OString aOStr(aOUStr.getStr(), aOUStr.getLength(),  RTL_TEXTENCODING_ASCII_US );
-            clog << aOStr.getStr() << '-';
+            clog << aOStr.getStr();
+
+            table::BorderLine aLine;
+            sal_Int32 nColor; 
+            if ( aMapIter->second >>= aLine )
+            {
+                clog << ": BorderLine ( Color: " << aLine.Color;
+                clog << ", Inner: " << aLine.InnerLineWidth;
+                clog << ", Outer: " << aLine.OuterLineWidth << ") ";
+            }
+            else if ( aMapIter->second >>= nColor )
+            {
+                clog << ": Color ( " << nColor << " ) ";
+            }
+
+            clog << " - ";
         }
         clog << endl;
     }
@@ -106,21 +121,121 @@ void DomainMapperTableHandler::startTable(unsigned int nRows,
 /*-- 22.02.2008 10:18:37---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-PropertyMapPtr lcl_SearchParentStyleSheetAndMergeProperties(const StyleSheetEntry* pStyleSheet, StyleSheetTablePtr pStyleSheetTable)
+PropertyMapPtr lcl_SearchParentStyleSheetAndMergeProperties(const StyleSheetEntryPtr pStyleSheet, StyleSheetTablePtr pStyleSheetTable)
 {
     PropertyMapPtr pRet;
     if( pStyleSheet->sBaseStyleIdentifier.getLength())
     {
-        const StyleSheetEntry* pParentStyleSheet = pStyleSheetTable->FindStyleSheetByISTD( pStyleSheet->sBaseStyleIdentifier );
+        const StyleSheetEntryPtr pParentStyleSheet = pStyleSheetTable->FindStyleSheetByISTD( pStyleSheet->sBaseStyleIdentifier );
         pRet = lcl_SearchParentStyleSheetAndMergeProperties( pParentStyleSheet, pStyleSheetTable );
     }    
     else
     {
         pRet.reset( new PropertyMap );
     }
+
     pRet->insert(  pStyleSheet->pProperties, true );
     return pRet;
 }
+
+void lcl_mergeBorder( PropertyIds nId, PropertyMapPtr pOrig, PropertyMapPtr pDest )
+{
+    PropertyDefinition aDef( nId, false );
+    PropertyMap::iterator pOrigIt = pOrig->find( aDef );
+
+    if ( pOrigIt != pOrig->end( ) )
+    {
+        pDest->Insert( nId, false, pOrigIt->second, false );
+    }
+}
+
+void lcl_computeCellBorders( PropertyMapPtr pTableBorders, PropertyMapPtr pCellProps, 
+        sal_Int32 nCell, sal_Int32 nRow, bool bIsEndCol, bool bIsEndRow )
+{
+    PropertyDefinition aVertPDef( META_PROP_VERTICAL_BORDER, false );
+    PropertyDefinition aHorizPDef( META_PROP_HORIZONTAL_BORDER, false );
+
+    PropertyMap::iterator aVerticalIter = pCellProps->find( aVertPDef );
+    PropertyMap::iterator aHorizontalIter = pCellProps->find( aHorizPDef );
+
+    // Handle the vertical and horizontal borders  
+    bool bHasVert = ( aVerticalIter != pCellProps->end(  ) );
+    uno::Any aVertProp;
+    if ( !bHasVert )
+    {
+        aVerticalIter = pTableBorders->find( aVertPDef );
+        bHasVert = ( aVerticalIter != pTableBorders->end( ) );
+        if ( bHasVert )
+            aVertProp = aVerticalIter->second;
+    }
+    else
+    {
+        aVertProp = aVerticalIter->second;
+        pCellProps->erase( aVerticalIter );
+    }
+
+    bool bHasHoriz = ( aHorizontalIter != pCellProps->end(  ) );
+    uno::Any aHorizProp;
+    if ( !bHasHoriz )
+    {
+        aHorizontalIter = pTableBorders->find( aHorizPDef );
+        bHasHoriz = ( aHorizontalIter != pTableBorders->end( ) );
+        if ( bHasHoriz )
+            aHorizProp = aHorizontalIter->second;
+    }
+    else
+    {
+        aHorizProp = aHorizontalIter->second;
+        pCellProps->erase( aHorizontalIter );
+    }
+
+    if ( nCell == 0 )
+    {
+        lcl_mergeBorder( PROP_LEFT_BORDER, pTableBorders, pCellProps );
+        if ( bHasVert )
+            pCellProps->Insert( PROP_RIGHT_BORDER, false, aVertProp, false );
+    }
+    
+    if ( bIsEndCol )
+    {
+        lcl_mergeBorder( PROP_RIGHT_BORDER, pTableBorders, pCellProps );
+        if ( bHasVert )
+            pCellProps->Insert( PROP_LEFT_BORDER, false, aVertProp, false );
+    }
+    
+    if ( nCell > 0 && !bIsEndCol )
+    {
+        if ( bHasVert )
+        {
+            pCellProps->Insert( PROP_RIGHT_BORDER, false, aVertProp, false );
+            pCellProps->Insert( PROP_LEFT_BORDER, false, aVertProp, false );
+        }
+    }
+
+    if ( nRow == 0 )
+    {
+        lcl_mergeBorder( PROP_TOP_BORDER, pTableBorders, pCellProps );
+        if ( bHasHoriz )
+            pCellProps->Insert( PROP_BOTTOM_BORDER, false, aHorizProp, false );
+    }
+
+    if ( bIsEndRow )
+    {
+        lcl_mergeBorder( PROP_BOTTOM_BORDER, pTableBorders, pCellProps );
+        if ( bHasHoriz )
+            pCellProps->Insert( PROP_TOP_BORDER, false, aHorizProp, false );
+    }
+    
+    if ( nRow > 0 && !bIsEndRow )
+    {
+        if ( bHasHoriz )
+        {
+            pCellProps->Insert( PROP_TOP_BORDER, false, aHorizProp, false );
+            pCellProps->Insert( PROP_BOTTOM_BORDER, false, aHorizProp, false );
+        }
+    }
+}
+
 void DomainMapperTableHandler::endTable()
 {
 #if OSL_DEBUG_LEVEL > 1
@@ -140,7 +255,7 @@ void DomainMapperTableHandler::endTable()
     if( nTblPropSize )
     {
         const beans::PropertyValues aDebugTbl = m_aTableProperties->GetPropertyValues();
-        for( sal_Int32  nDebug = 0; nDebug < nTblPropSize; ++nDebug)
+        for( sal_uInt32 nDebug = 0; nDebug < nTblPropSize; ++nDebug)
         {
             const ::rtl::OUString sName = aDebugTbl[nDebug].Name;
             sNames += sName;
@@ -148,6 +263,7 @@ void DomainMapperTableHandler::endTable()
         }
         m_aTableProperties->Invalidate();
         sNames += ::rtl::OUString(' ');
+        clog << "Props: " << rtl::OUStringToOString( sNames, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
     }
 }
 #endif
@@ -156,6 +272,13 @@ void DomainMapperTableHandler::endTable()
     sal_Int32 nLeftBorderDistance, nRightBorderDistance, nTopBorderDistance, nBottomBorderDistance;
     nLeftBorderDistance = nRightBorderDistance = DEF_BORDER_DIST;
     nTopBorderDistance = nBottomBorderDistance = 0;
+
+    PropertyMapPtr pTableDefaults( new PropertyMap );
+    PropertyMapPtr pTableBorders( new PropertyMap );
+        
+    // will receive the table style if any
+    TableStyleSheetEntry* pTableStyle = NULL;
+
     if( m_aTableProperties.get() )
     {
         //create properties from the table attributes
@@ -169,35 +292,31 @@ void DomainMapperTableHandler::endTable()
                                 m_aTableProperties->find( PropertyDefinition( META_PROP_TABLE_STYLE_NAME, false ) );
         if(aTableStyleIter != m_aTableProperties->end())
         {
-            //TODO: apply table style properties recursively
+            // Apply table style properties recursively
             ::rtl::OUString sTableStyleName; 
             aTableStyleIter->second >>= sTableStyleName;
             StyleSheetTablePtr pStyleSheetTable = m_rDMapper_Impl.GetStyleSheetTable();
-            const StyleSheetEntry* pStyleSheet = pStyleSheetTable->FindStyleSheetByISTD( sTableStyleName );
+            const StyleSheetEntryPtr pStyleSheet = pStyleSheetTable->FindStyleSheetByISTD( sTableStyleName );
+            pTableStyle = static_cast<TableStyleSheetEntry*>( pStyleSheet.get( ) );
+            m_aTableProperties->erase( aTableStyleIter );
+
             if( pStyleSheet )
             {
-                PropertyMapPtr pMergedProperties = lcl_SearchParentStyleSheetAndMergeProperties(pStyleSheet, pStyleSheetTable);
-               
-                PropertyMap::const_iterator aStylePropIter = 
-                    pMergedProperties->find(PropertyDefinition( META_PROP_CELL_MAR_TOP, false ) );
-                if( aStylePropIter != pMergedProperties->end() )
-                    aStylePropIter->second >>= nTopBorderDistance;    
+                // First get the style properties, then the table ones
+                PropertyMapPtr pTableProps( m_aTableProperties );
+                TablePropertyMapPtr pEmptyProps( new TablePropertyMap );
                 
-                aStylePropIter = pMergedProperties->find(PropertyDefinition( META_PROP_CELL_MAR_BOTTOM, false ) );
-                if( aStylePropIter != pMergedProperties->end() )
-                    aStylePropIter->second >>= nBottomBorderDistance; 
-                
-                aStylePropIter = pMergedProperties->find(PropertyDefinition( META_PROP_CELL_MAR_LEFT, false ) );
-                if( aStylePropIter != pMergedProperties->end() )
-                    aStylePropIter->second >>= nLeftBorderDistance; 
-                
-                aStylePropIter = pMergedProperties->find(PropertyDefinition( META_PROP_CELL_MAR_RIGHT, false ) );
-                if( aStylePropIter != pMergedProperties->end() )
-                    aStylePropIter->second >>= nRightBorderDistance; 
+                m_aTableProperties = pEmptyProps;
                 
+                PropertyMapPtr pMergedProperties = lcl_SearchParentStyleSheetAndMergeProperties(pStyleSheet, pStyleSheetTable);
+    
+                m_aTableProperties->insert( pMergedProperties );
+                m_aTableProperties->insert( pTableProps );
             }    
-            m_aTableProperties->erase( aTableStyleIter );
         }
+        
+        // Set the table default attributes for the cells
+        pTableDefaults->insert( m_aTableProperties );
 
         m_aTableProperties->getValue( TablePropertyMap::GAP_HALF, nGapHalf );
         m_aTableProperties->getValue( TablePropertyMap::LEFT_MARGIN, nLeftMargin );
@@ -228,6 +347,11 @@ void DomainMapperTableHandler::endTable()
             aTblBorderIter->second >>= aTableBorder.TopLine;
             aTableBorder.IsTopLineValid = true;
             m_aTableProperties->erase( aTblBorderIter );
+
+            pTableBorders->Insert( PROP_TOP_BORDER, false, uno::makeAny( aTableBorder.TopLine ) );
+            PropertyMap::iterator pIt = pTableDefaults->find( PropertyDefinition( PROP_TOP_BORDER, false ) );
+            if ( pIt != pTableDefaults->end( ) )
+                pTableDefaults->erase( pIt );
         }
         aTblBorderIter = m_aTableProperties->find( PropertyDefinition(PROP_BOTTOM_BORDER, false) );
         if( aTblBorderIter != m_aTableProperties->end() )
@@ -235,6 +359,11 @@ void DomainMapperTableHandler::endTable()
             aTblBorderIter->second >>= aTableBorder.BottomLine;
             aTableBorder.IsBottomLineValid = true;
             m_aTableProperties->erase( aTblBorderIter );
+
+            pTableBorders->Insert( PROP_BOTTOM_BORDER, false, uno::makeAny( aTableBorder.BottomLine ) );
+            PropertyMap::iterator pIt = pTableDefaults->find( PropertyDefinition( PROP_BOTTOM_BORDER, false ) );
+            if ( pIt != pTableDefaults->end( ) )
+                pTableDefaults->erase( pIt );
         }
         aTblBorderIter = m_aTableProperties->find( PropertyDefinition(PROP_LEFT_BORDER, false) );
         if( aTblBorderIter != m_aTableProperties->end() )
@@ -242,6 +371,11 @@ void DomainMapperTableHandler::endTable()
             aTblBorderIter->second >>= aTableBorder.LeftLine;
             aTableBorder.IsLeftLineValid = true;
             m_aTableProperties->erase( aTblBorderIter );
+
+            pTableBorders->Insert( PROP_LEFT_BORDER, false, uno::makeAny( aTableBorder.LeftLine ) );
+            PropertyMap::iterator pIt = pTableDefaults->find( PropertyDefinition( PROP_LEFT_BORDER, false ) );
+            if ( pIt != pTableDefaults->end( ) )
+                pTableDefaults->erase( pIt );
         }
         aTblBorderIter = m_aTableProperties->find( PropertyDefinition(PROP_RIGHT_BORDER, false) );
         if( aTblBorderIter != m_aTableProperties->end() )
@@ -249,6 +383,11 @@ void DomainMapperTableHandler::endTable()
             aTblBorderIter->second >>= aTableBorder.RightLine;
             aTableBorder.IsRightLineValid = true;
             m_aTableProperties->erase( aTblBorderIter );
+
+            pTableBorders->Insert( PROP_RIGHT_BORDER, false, uno::makeAny( aTableBorder.RightLine ) );
+            PropertyMap::iterator pIt = pTableDefaults->find( PropertyDefinition( PROP_RIGHT_BORDER, false ) );
+            if ( pIt != pTableDefaults->end( ) )
+                pTableDefaults->erase( pIt );
         }
         aTblBorderIter = m_aTableProperties->find( PropertyDefinition(META_PROP_HORIZONTAL_BORDER, false) );
         if( aTblBorderIter != m_aTableProperties->end() )
@@ -256,6 +395,11 @@ void DomainMapperTableHandler::endTable()
             aTblBorderIter->second >>= aTableBorder.HorizontalLine;
             aTableBorder.IsHorizontalLineValid = true;
             m_aTableProperties->erase( aTblBorderIter );
+
+            pTableBorders->Insert( META_PROP_HORIZONTAL_BORDER, false, uno::makeAny( aTableBorder.HorizontalLine ) );
+            PropertyMap::iterator pIt = pTableDefaults->find( PropertyDefinition( META_PROP_HORIZONTAL_BORDER, false ) );
+            if ( pIt != pTableDefaults->end( ) )
+                pTableDefaults->erase( pIt );
         }
         aTblBorderIter = m_aTableProperties->find( PropertyDefinition(META_PROP_VERTICAL_BORDER, false) );
         if( aTblBorderIter != m_aTableProperties->end() )
@@ -263,10 +407,15 @@ void DomainMapperTableHandler::endTable()
             aTblBorderIter->second >>= aTableBorder.VerticalLine;
             aTableBorder.IsVerticalLineValid = true;
             m_aTableProperties->erase( aTblBorderIter );
+
+            pTableBorders->Insert( META_PROP_VERTICAL_BORDER, false, uno::makeAny( aTableBorder.VerticalLine ) );
+            PropertyMap::iterator pIt = pTableDefaults->find( PropertyDefinition( META_PROP_VERTICAL_BORDER, false ) );
+            if ( pIt != pTableDefaults->end( ) )
+                pTableDefaults->erase( pIt );
         }
         aTableBorder.Distance = 0;
         aTableBorder.IsDistanceValid = false;
-        
+       
         m_aTableProperties->Insert( PROP_TABLE_BORDER, false, uno::makeAny( aTableBorder ) );
         
         m_aTableProperties->Insert( PROP_LEFT_MARGIN, false, uno::makeAny( nLeftMargin - nGapHalf - nLeftBorderDistance));
@@ -284,18 +433,26 @@ void DomainMapperTableHandler::endTable()
                                 m_aTableProperties->find( PropertyDefinition( PROP_HEADER_ROW_COUNT, false ) );
         if( aRepeatIter == m_aTableProperties->end() )
             m_aTableProperties->Insert( PROP_HEADER_ROW_COUNT, false, uno::makeAny( (sal_Int32)0 ));
+
+        // Remove the PROP_HEADER_ROW_COUNT from the table default to avoid
+        // propagating it to the cells
+        PropertyMap::iterator aDefaultRepeatIt =
+                                pTableDefaults->find( PropertyDefinition( PROP_HEADER_ROW_COUNT, false ) );
+        if ( aDefaultRepeatIt != pTableDefaults->end( ) )
+            pTableDefaults->erase( aDefaultRepeatIt );
         
         aTableProperties = m_aTableProperties->GetPropertyValues();
     }
-    
+   
     //  expands to uno::Sequence< Sequence< beans::PropertyValues > > 
     CellPropertyValuesSeq_t     aCellProperties( m_aCellProperties.size() );
     
     // std::vector< std::vector<PropertyMapPtr> > m_aCellProperties
     PropertyMapVector2::const_iterator aRowOfCellsIterator = m_aCellProperties.begin();
     PropertyMapVector2::const_iterator aRowOfCellsIteratorEnd = m_aCellProperties.end();
+    PropertyMapVector2::const_iterator aLastRowIterator = m_aCellProperties.end() - 1;
     sal_Int32 nRow = 0;
-    
+
     //it's a uno::Sequence< beans::PropertyValues >*
     RowPropertyValuesSeq_t* pCellProperties = aCellProperties.getArray();
     while( aRowOfCellsIterator != aRowOfCellsIteratorEnd )
@@ -303,67 +460,72 @@ void DomainMapperTableHandler::endTable()
         //aRowOfCellsIterator points to a vector of PropertyMapPtr
         PropertyMapVector1::const_iterator aCellIterator = aRowOfCellsIterator->begin();
         PropertyMapVector1::const_iterator aCellIteratorEnd = aRowOfCellsIterator->end();
-
-        //contains the default border of the line
-        PropertyMapPtr aCellBorders( new PropertyMap );
-
+        PropertyMapVector1::const_iterator aLastCellIterator = aRowOfCellsIterator->end() - 1;
+        
+        // Get the row style properties
+        sal_Int32 nRowStyleMask = sal_Int32( 0 );
+        PropertyMapPtr pRowProps = m_aRowProperties[nRow];
+        if ( pRowProps.get( ) )
+        {
+            PropertyMap::iterator pTcCnfStyleIt = pRowProps->find( PropertyDefinition( PROP_CNF_STYLE, true ) );
+            if ( pTcCnfStyleIt != pRowProps->end( ) )
+            {
+                if ( pTableStyle )
+                {
+                    rtl::OUString sMask;
+                    pTcCnfStyleIt->second >>= sMask;
+                    nRowStyleMask = sMask.toInt32( 2 );
+                }
+                pRowProps->erase( pTcCnfStyleIt );
+            }
+        }
+        
         sal_Int32 nCell = 0;
         pCellProperties[nRow].realloc( aRowOfCellsIterator->size() );
         beans::PropertyValues* pSingleCellProperties = pCellProperties[nRow].getArray();
         while( aCellIterator != aCellIteratorEnd )
         {
-            //TODO: aCellIterator contains HorizontalBorder and VerticalBorder 
-            // they have to be removed, depending on the position of the cell they 
-            // have to be moved to BottomBorder/RightBorder respectively
+            PropertyMapPtr pAllCellProps( new PropertyMap );
+                
+            bool bIsEndCol = aCellIterator == aLastCellIterator;
+            bool bIsEndRow = aRowOfCellsIterator == aLastRowIterator;
+
             //aCellIterator points to a PropertyMapPtr;
             if( aCellIterator->get() )
             {
-                if( nCell && aCellBorders->size() )
-                {
-                    //now apply the default border
-                    //TODO: This overwrites the existing values!
-                    aCellIterator->get()->insert( aCellBorders, false );
-                }    
-
-                    
-                const PropertyMap::iterator aVerticalIter = 
-                                aCellIterator->get()->find( PropertyDefinition(META_PROP_VERTICAL_BORDER, false) );
-                const PropertyMap::iterator aHorizontalIter = 
-                                aCellIterator->get()->find( PropertyDefinition(META_PROP_HORIZONTAL_BORDER, false) );
-                const PropertyMap::const_iterator aRightIter = 
-                                aCellIterator->get()->find( PropertyDefinition(PROP_RIGHT_BORDER, false) );
-                const PropertyMap::const_iterator aBottomIter = 
-                                aCellIterator->get()->find( PropertyDefinition(PROP_BOTTOM_BORDER, false) );
-                
-                if( aVerticalIter != aCellIterator->get()->end())
+                if ( pTableDefaults->size( ) )
+                    pAllCellProps->insert( pTableDefaults );
+
+                // Fill the cell properties with the ones of the style
+                sal_Int32 nCellStyleMask = 0;
+                const PropertyMap::iterator aCnfStyleIter = 
+                    aCellIterator->get()->find( PropertyDefinition( PROP_CNF_STYLE, false ) );
+                if ( aCnfStyleIter != aCellIterator->get( )->end( ) )
                 {
-                    if( !nCell )
-                        aCellBorders->insert(*aVerticalIter);
-                    aCellIterator->get()->erase( aVerticalIter );
+                    if ( pTableStyle ) {
+                        rtl::OUString sMask;
+                        aCnfStyleIter->second >>= sMask;
+                        nCellStyleMask = sMask.toInt32( 2 );
+                    }
+                    aCellIterator->get( )->erase( aCnfStyleIter );
                 }
-                if( aHorizontalIter != aCellIterator->get()->end())
+                
+                if ( pTableStyle )
                 {
-                    if( !nCell )
-                        aCellBorders->insert(*aHorizontalIter);
-                    aCellIterator->get()->erase( aHorizontalIter );
+                    PropertyMapPtr pStyleProps = pTableStyle->GetProperties( nCellStyleMask + nRowStyleMask );
+                    pAllCellProps->insert( pStyleProps );
                 }
-                //fill the additional borders into the line default border
-                if( !nCell )
-                {
-                    const PropertyMap::const_iterator aLeftIter = 
-                                    aCellIterator->get()->find( PropertyDefinition(PROP_RIGHT_BORDER, false) );
-                    if(aLeftIter != aCellIterator->get()->end())
-                        aCellBorders->insert(*aLeftIter);
-                    if(aRightIter != aCellIterator->get()->end())
-                        aCellBorders->insert(*aRightIter);
-                    const PropertyMap::const_iterator aTopIter = 
-                                    aCellIterator->get()->find( PropertyDefinition(PROP_TOP_BORDER, false) );
-                    if(aTopIter != aCellIterator->get()->end())
-                        aCellBorders->insert(*aTopIter);
-                    if(aBottomIter != aCellIterator->get()->end())
-                        aCellBorders->insert(*aBottomIter);
-                }   
-                
+
+                // Then add the cell properties
+                pAllCellProps->insert( *aCellIterator );
+                aCellIterator->get( )->swap( *pAllCellProps.get( ) );
+
+#if DEBUG
+                clog << "Cell #" << nCell << ", Row #" << nRow << endl;
+#endif
+
+                lcl_computeCellBorders( pTableBorders, *aCellIterator, nCell, nRow, bIsEndCol, bIsEndRow );
+
                 //now set the default left+right border distance TODO: there's an sprm containing the default distance!
                 const PropertyMap::const_iterator aLeftDistanceIter = 
                                 aCellIterator->get()->find( PropertyDefinition(PROP_LEFT_BORDER_DISTANCE, false) );
@@ -410,7 +572,7 @@ void DomainMapperTableHandler::endTable()
                     sNames += sName;
                     sNames += ::rtl::OUString('-');
                 }
-                sNames += ::rtl::OUString(' ');
+                sNames += ::rtl::OUString('\n');
             }
             (void)sNames;
         }
@@ -479,11 +641,15 @@ void DomainMapperTableHandler::endTable()
         (void) nCellPropertiesProperties;
         ++nCellPropertiesProperties;
     }    
-#endif            
-            m_xText->convertToTable(*m_pTableSeq, 
+            clog << "Converting table" << endl;
+#endif           
+                
+            uno::Reference<text::XTextTable> xTable = m_xText->convertToTable(*m_pTableSeq, 
                                     aCellProperties,
                                     aRowProperties,
                                     aTableProperties);
+
+            m_xTableRange = xTable->getAnchor( );
         }
         catch (lang::IllegalArgumentException e)
         {
@@ -491,7 +657,14 @@ void DomainMapperTableHandler::endTable()
             clog << "failed to import table!" << endl;
 #endif
         }
+#if OSL_DEBUG_LEVEL > 1
+        catch ( uno::Exception e )
+        {
+            clog << "Caught an other exception: " << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+        }
+#endif
     }
+
     m_aTableProperties.reset();
     m_aCellProperties.clear();
     m_aRowProperties.clear();
@@ -529,7 +702,15 @@ void DomainMapperTableHandler::startCell(const Handle_t & start,
                                          TablePropertyMapPtr pProps )
 {
     sal_uInt32 nRow = m_aRowProperties.size();
-    m_aCellProperties[nRow - 1].push_back( pProps );
+    if ( pProps.get( ) )
+        m_aCellProperties[nRow - 1].push_back( pProps );
+    else
+    {
+        // Adding an empty cell properties map to be able to get
+        // the table defaults properties
+        TablePropertyMapPtr pEmptyProps( new TablePropertyMap( ) );
+        m_aCellProperties[nRow - 1].push_back( pEmptyProps );
+    }
     
 #if OSL_DEBUG_LEVEL > 1
     clog << "<table.cell>";
diff --git writerfilter/source/dmapper/DomainMapperTableHandler.hxx writerfilter/source/dmapper/DomainMapperTableHandler.hxx
index d0e4382..833dd3c 100644
--- writerfilter/source/dmapper/DomainMapperTableHandler.hxx
+++ writerfilter/source/dmapper/DomainMapperTableHandler.hxx
@@ -66,6 +66,8 @@ class DomainMapperTableHandler : public TableDataHandler<Handle_t , TablePropert
     RowSequencePointer_t    m_pRowSeq;
     TableSequencePointer_t  m_pTableSeq;
 
+    Handle_t               m_xTableRange;
+
     // properties
     PropertyMapVector2      m_aCellProperties;
     PropertyMapVector1      m_aRowProperties;
@@ -87,6 +89,11 @@ public:
     virtual void endRow();
     virtual void startCell(const Handle_t & start, TablePropertyMapPtr pProps);
     virtual void endCell(const Handle_t & end);
+
+    virtual Handle_t* getTable( ) 
+    {
+        return &m_xTableRange;
+    };
 };
 
 }}
diff --git writerfilter/source/dmapper/DomainMapperTableManager.cxx writerfilter/source/dmapper/DomainMapperTableManager.cxx
index 4367f90..5790e9f 100644
--- writerfilter/source/dmapper/DomainMapperTableManager.cxx
+++ writerfilter/source/dmapper/DomainMapperTableManager.cxx
@@ -56,14 +56,18 @@ DomainMapperTableManager::DomainMapperTableManager(bool bOOXML) :
     m_nCellBorderIndex(0),
     m_nHeaderRepeat(0),
     m_nTableWidth(0),
-    m_bOOXML( bOOXML )
+    m_bOOXML( bOOXML ),
+    m_pTablePropsHandler( new TablePropertiesHandler( bOOXML ) )
 {
+    m_pTablePropsHandler->SetTableManager( this );
 }
 /*-- 23.04.2007 14:57:49---------------------------------------------------
 
   -----------------------------------------------------------------------*/
 DomainMapperTableManager::~DomainMapperTableManager()
 {
+    if ( m_pTablePropsHandler )
+        delete m_pTablePropsHandler, m_pTablePropsHandler = NULL;
 }
 /*-- 23.04.2007 15:25:37---------------------------------------------------
 
@@ -73,39 +77,17 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
     bool bRet = DomainMapperTableManager_Base_t::sprm(rSprm);
     if( !bRet )
     {
+        bRet = m_pTablePropsHandler->sprm( rSprm );
+    }
+
+    if ( !bRet )
+    {
         bRet = true;
         sal_uInt32 nSprmId = rSprm.getId();
         Value::Pointer_t pValue = rSprm.getValue();
         sal_Int32 nIntValue = ((pValue.get() != NULL) ? pValue->getInt() : 0);
-        /* WRITERFILTERSTATUS: table: table_sprmdata */
-        switch( nSprmId )
+        switch ( nSprmId )
         {
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 2 */
-            case NS_ooxml::LN_CT_TrPrBase_jc: //90706
-            /* WRITERFILTERSTATUS: done: 1, planned: 0.5, spent: 0.5 */
-            case NS_ooxml::LN_CT_TblPrBase_jc:
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 2 */
-            case 0x5400: // sprmTJc
-            {
-                //table justification 0: left, 1: center, 2: right
-                sal_Int16 nOrient = ConversionHelper::convertTableJustification( nIntValue );
-                TablePropertyMapPtr pTableMap( new TablePropertyMap );
-                pTableMap->setValue( TablePropertyMap::HORI_ORIENT, nOrient );
-                insertTableProps( pTableMap );
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
-            case 0x9601: // sprmTDxaLeft
-            break;  
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0x9602: // sprmTDxaGapHalf
-            {    
-                //m_nGapHalf = ConversionHelper::convertTwipToMM100( nIntValue );
-                TablePropertyMapPtr pPropMap( new TablePropertyMap );
-                pPropMap->setValue( TablePropertyMap::GAP_HALF, ConversionHelper::convertTwipToMM100( nIntValue ) );
-                insertTableProps(pPropMap);
-            }
-            break;  
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case 0xf661: //sprmTTRLeft left table indent
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
@@ -136,32 +118,6 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
                 }
             }
             break;
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 2 */
-            case NS_ooxml::LN_CT_TrPrBase_trHeight: //90703
-            {
-                //contains unit and value 
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if( pProperties.get())
-                {   //contains attributes x2902 (LN_unit) and x17e2 (LN_trleft)
-                    MeasureHandlerPtr pMeasureHandler( new MeasureHandler );
-                    pProperties->resolve(*pMeasureHandler);
-                    TablePropertyMapPtr pPropMap( new TablePropertyMap );
-                    pPropMap->Insert( PROP_SIZE_TYPE, false, uno::makeAny( pMeasureHandler->GetRowHeightSizeType() ));
-                    pPropMap->Insert( PROP_HEIGHT, false, uno::makeAny(pMeasureHandler->getMeasureValue() ));
-                    insertRowProps(pPropMap);
-                }
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0x3403: // sprmTFCantSplit
-            case NS_sprm::LN_TCantSplit: // 0x3644
-            {    
-                //row can't break across pages if nIntValue == 1
-                TablePropertyMapPtr pPropMap( new TablePropertyMap );
-                pPropMap->Insert( PROP_IS_SPLIT_ALLOWED, false, uno::makeAny(sal_Bool( nIntValue == 1 ? sal_False : sal_True ) ));
-                insertRowProps(pPropMap);
-            }
-            break;  
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case 0x3404:// sprmTTableHeader
             case NS_ooxml::LN_CT_TrPrBase_tblHeader: //90704  
@@ -178,23 +134,6 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
                     m_nHeaderRepeat = -1;
             break;  
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0x9407: // sprmTDyaRowHeight
-            {    
-                // table row height - negative values indicate 'exact height' - positive 'at least'
-                TablePropertyMapPtr pPropMap( new TablePropertyMap );
-                bool bMinHeight = true;
-                sal_Int16 nHeight = static_cast<sal_Int16>( nIntValue );
-                if( nHeight < 0 )
-                {
-                    bMinHeight = false;
-                    nHeight *= -1;
-                }    
-                pPropMap->Insert( PROP_SIZE_TYPE, false, uno::makeAny(bMinHeight ? text::SizeType::MIN : text::SizeType::FIX ));
-                pPropMap->Insert( PROP_HEIGHT, false, uno::makeAny(ConversionHelper::convertTwipToMM100( nHeight )));
-                insertRowProps(pPropMap);
-            }
-            break;  
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case 0xd608: // TDefTable
             {    
                 writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
@@ -226,22 +165,6 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
             }
             break;
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case NS_ooxml::LN_CT_TcPrBase_vAlign://90694
-            {    
-                sal_Int16 nVertOrient = text::VertOrientation::NONE;
-                switch( nIntValue ) //0 - top 1 - center 3 - bottom
-                {
-                    case 1: nVertOrient = text::VertOrientation::CENTER; break;
-                    case 3: nVertOrient = text::VertOrientation::BOTTOM; break;
-                    default:;
-                };
-                TablePropertyMapPtr pCellPropMap( new TablePropertyMap() );
-                pCellPropMap->Insert( PROP_VERT_ORIENT, false, uno::makeAny( nVertOrient ) );
-                //todo: in ooxml import the value of m_ncell is wrong
-                cellProps( pCellPropMap );
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case 0xD605: // sprmTTableBorders
             {
                 writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
@@ -256,70 +179,6 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
                 }
             }
             break;
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case NS_ooxml::LN_CT_TblPrBase_tblBorders: //table borders, might be defined in table style
-            {    
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if( pProperties.get())
-                {
-                    BorderHandlerPtr pBorderHandler( new BorderHandler(m_bOOXML) );
-                    pProperties->resolve(*pBorderHandler);
-                    TablePropertyMapPtr pTablePropMap( new TablePropertyMap );
-                    pTablePropMap->insert( pBorderHandler->getProperties() );
-                    insertTableProps( pTablePropMap );
-                }
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case NS_ooxml::LN_CT_TcPrBase_tcBorders ://cell borders
-            //contains CT_TcBorders_left, right, top, bottom
-            {    
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if( pProperties.get())
-                {
-                    //in OOXML there's one set of borders at each cell (if there is any)
-                    TDefTableHandlerPtr pTDefTableHandler( new TDefTableHandler( m_bOOXML ));
-                    pProperties->resolve( *pTDefTableHandler );
-                    TablePropertyMapPtr pCellPropMap( new TablePropertyMap );
-                    pTDefTableHandler->fillCellProperties( 0, pCellPropMap );
-                    cellProps( pCellPropMap );
-                }    
-            }
-            break;
-            case NS_ooxml::LN_CT_TblPrBase_shd:
-            {    
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if( pProperties.get())
-                {
-                    CellColorHandlerPtr pCellColorHandler( new CellColorHandler);
-                    pProperties->resolve( *pCellColorHandler );
-                    TablePropertyMapPtr pTablePropMap( new TablePropertyMap );
-                    insertTableProps( pCellColorHandler->getProperties() );
-                }    
-            }
-            break;
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0xd61a : // sprmTCellTopColor
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0xd61b : // sprmTCellLeftColor
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0xd61c : // sprmTCellBottomColor
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case 0xd61d : // sprmTCellRightColor
-            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
-            case NS_ooxml::LN_CT_TcPrBase_shd:
-            {    
-                // each color sprm contains as much colors as cells are in a row
-                //LN_CT_TcPrBase_shd: cell shading contains: LN_CT_Shd_val, LN_CT_Shd_fill, LN_CT_Shd_color
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if( pProperties.get())
-                {
-                    CellColorHandlerPtr pCellColorHandler( new CellColorHandler );
-                    pProperties->resolve( *pCellColorHandler );
-                    cellProps( pCellColorHandler->getProperties());
-                }    
-            }
-            break;
             /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
             case 0xd632 : //sprmTNewSpacing
             /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
@@ -356,7 +215,6 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
             case 0xf618 : //unknown
                 bRet = false;
             break;
-//OOXML table properties            
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case NS_ooxml::LN_CT_TblPrBase_tblStyle: //table style name
             {    
@@ -368,34 +226,10 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
             break;
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case NS_ooxml::LN_CT_TblGridBase_gridCol:
-            
-            if(!m_nRow)
-            {    
-                m_aTableGrid.push_back( ConversionHelper::convertTwipToMM100( nIntValue ) );
+            {   
+                getCurrentGrid()->push_back( ConversionHelper::convertTwipToMM100( nIntValue ) );
             }    
             break;
-            /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
-            case NS_ooxml::LN_CT_TblPrBase_tblCellMar: //cell margins
-            {    
-                //contains LN_CT_TblCellMar_top, LN_CT_TblCellMar_left, LN_CT_TblCellMar_bottom, LN_CT_TblCellMar_right
-                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
-                if( pProperties.get())
-                {
-                    CellMarginHandlerPtr pCellMarginHandler( new CellMarginHandler );
-                    pProperties->resolve( *pCellMarginHandler );
-                    TablePropertyMapPtr pMarginProps( new TablePropertyMap );
-                    if( pCellMarginHandler->m_bTopMarginValid )
-                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_TOP, pCellMarginHandler->m_nTopMargin );
-                    if( pCellMarginHandler->m_bBottomMarginValid )
-                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_BOTTOM, pCellMarginHandler->m_nBottomMargin );
-                    if( pCellMarginHandler->m_bLeftMarginValid )
-                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_LEFT, pCellMarginHandler->m_nLeftMargin );
-                    if( pCellMarginHandler->m_bRightMarginValid )
-                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_RIGHT, pCellMarginHandler->m_nRightMargin );
-                    insertTableProps(pMarginProps);
-                }    
-            }
-            break;
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case NS_ooxml::LN_CT_TcPrBase_vMerge : //vertical merge
             {    
@@ -408,25 +242,84 @@ bool DomainMapperTableManager::sprm(Sprm & rSprm)
             /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
             case NS_ooxml::LN_CT_TcPrBase_gridSpan: //number of grid positions spanned by this cell
             {    
+#if DEBUG
+                clog << "GridSpan: " << nIntValue << endl;
+#endif
                 //the cell width is determined by its position in the table grid 
                 //it takes 'gridSpan' grid elements
-                if( m_aGridSpans.size() < m_nCell)
+                IntVectorPtr pCurrentSpans = getCurrentSpans( );
+                if( pCurrentSpans->size() < m_nCell)
                 {
                     //fill missing elements with '1'
-                    m_aGridSpans.insert( m_aGridSpans.end(), m_nCell - m_aGridSpans.size(), 1 );
-                }    
-                m_aGridSpans.push_back( nIntValue );
+                    pCurrentSpans->insert( pCurrentSpans->end(), m_nCell - pCurrentSpans->size(), 1 );
+                }   
+                pCurrentSpans->push_back( nIntValue );
             }
             break;
             /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
-            case NS_ooxml::LN_CT_TblPrBase_tblLook: break; //todo: table look specifier
+            case NS_ooxml::LN_CT_TblPrBase_tblLook: 
+                break; //todo: table look specifier
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-            case NS_ooxml::LN_CT_TcPrBase_tcW: break; //fixed column width is not supported
-            default: bRet = false;
+            case NS_ooxml::LN_CT_TcPrBase_tcW: 
+                break; //fixed column width is not supported
+            case NS_ooxml::LN_CT_TrPrBase_cnfStyle:
+                {
+                    TablePropertyMapPtr pProps( new TablePropertyMap );
+                    pProps->Insert( PROP_CNF_STYLE, true, uno::makeAny( pValue->getString( ) ) );
+                    insertRowProps( pProps );
+                }
+                break;
+            case NS_ooxml::LN_CT_PPrBase_cnfStyle:
+                // TODO cnfStyle on a paragraph
+                break;
+            case NS_ooxml::LN_CT_TcPrBase_cnfStyle:
+                {
+                    TablePropertyMapPtr pProps( new TablePropertyMap );
+                    pProps->Insert( PROP_CNF_STYLE, true, uno::makeAny( pValue->getString( ) ) );
+                    cellProps( pProps );
+                }
+                break;
+            case NS_ooxml::LN_tblStart:
+                {
+                    startLevel( );
+                }
+                break;
+            default:
+                bRet = false;
         }
     }
     return bRet;
 }
+
+boost::shared_ptr< vector<sal_Int32> > DomainMapperTableManager::getCurrentGrid( )
+{
+    return m_aTableGrid.back( );
+}
+
+boost::shared_ptr< vector< sal_Int32 > > DomainMapperTableManager::getCurrentSpans( )
+{
+    return m_aGridSpans.back( );
+}
+
+void DomainMapperTableManager::startLevel( )
+{
+    DomainMapperTableManager_Base_t::startLevel( );
+
+    IntVectorPtr pNewGrid( new vector<sal_Int32> );
+    IntVectorPtr pNewSpans( new vector<sal_Int32> );
+    m_aTableGrid.push_back( pNewGrid );
+    m_aGridSpans.push_back( pNewSpans );
+    m_nTableWidth = 0;
+}
+
+void DomainMapperTableManager::endLevel( )
+{
+    m_aTableGrid.pop_back( );
+    m_aGridSpans.pop_back( );
+    
+    DomainMapperTableManager_Base_t::endLevel( );
+}
+
 /*-- 02.05.2007 14:36:26---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -439,10 +332,11 @@ void DomainMapperTableManager::endOfCellAction()
   -----------------------------------------------------------------------*/
 void DomainMapperTableManager::endOfRowAction()
 {
-    if(!m_nRow && !m_nTableWidth && m_aTableGrid.size())
+    IntVectorPtr pTableGrid = getCurrentGrid( );
+    if(!m_nTableWidth && pTableGrid->size())
     {
-        ::std::vector<sal_Int32>::const_iterator aCellIter = m_aTableGrid.begin();
-        while( aCellIter != m_aTableGrid.end() )
+        ::std::vector<sal_Int32>::const_iterator aCellIter = pTableGrid->begin();
+        while( aCellIter != pTableGrid->end() )
              m_nTableWidth += *aCellIter++;
         if( m_nTableWidth > 0)
         {
@@ -452,18 +346,20 @@ void DomainMapperTableManager::endOfRowAction()
             insertTableProps(pPropMap);
         }
     }
-    if( m_aGridSpans.size() < m_nCell)
+
+    IntVectorPtr pCurrentSpans = getCurrentSpans( );
+    if( pCurrentSpans->size() < m_nCell)
     {
         //fill missing elements with '1'
-        m_aGridSpans.insert( m_aGridSpans.end(), m_nCell - m_aGridSpans.size(), 1 );
+        pCurrentSpans->insert( pCurrentSpans->end( ), m_nCell - pCurrentSpans->size(), 1 );
     }    
     //calculate number of used grids - it has to match the size of m_aTableGrid
     size_t nGrids = 0;
-    ::std::vector<sal_Int32>::const_iterator aGridSpanIter = m_aGridSpans.begin();
-    for( ; aGridSpanIter != m_aGridSpans.end(); ++aGridSpanIter)
+    ::std::vector<sal_Int32>::const_iterator aGridSpanIter = pCurrentSpans->begin();
+    for( ; aGridSpanIter != pCurrentSpans->end(); ++aGridSpanIter)
         nGrids += *aGridSpanIter;
 
-    if( m_aTableGrid.size() == nGrids )
+    if( pTableGrid->size() == nGrids )
     {
         //determine table width 
         double nFullWidth = m_nTableWidth;
@@ -473,13 +369,15 @@ void DomainMapperTableManager::endOfRowAction()
         text::TableColumnSeparator* pSeparators = aSeparators.getArray();
         sal_Int16 nLastRelPos = 0;
         sal_uInt32 nBorderGridIndex = 0;
+
+        ::std::vector< sal_Int32 >::const_iterator aSpansIter = pCurrentSpans->begin( );
         for( sal_uInt32 nBorder = 0; nBorder < m_nCell - 1; ++nBorder )
         {
-            sal_Int32 nGridCount = m_aGridSpans[nBorder];
+            sal_Int32 nGridCount = *aSpansIter;
             double fGridWidth = 0.;
             do
             {
-                fGridWidth += m_aTableGrid[nBorderGridIndex++];
+                fGridWidth += (*pTableGrid.get())[nBorderGridIndex++];
             }while( --nGridCount );
             
             sal_Int16 nRelPos = 
@@ -488,6 +386,7 @@ void DomainMapperTableManager::endOfRowAction()
             pSeparators[nBorder].Position =  nRelPos + nLastRelPos;
             pSeparators[nBorder].IsVisible = sal_True;
             nLastRelPos = nLastRelPos + nRelPos;
+            aSpansIter++;
         }
         TablePropertyMapPtr pPropMap( new TablePropertyMap );
         pPropMap->Insert( PROP_TABLE_COLUMN_SEPARATORS, false, uno::makeAny( aSeparators ) );
@@ -497,7 +396,7 @@ void DomainMapperTableManager::endOfRowAction()
     ++m_nRow;
     m_nCell = 0;
     m_nCellBorderIndex = 0;
-    m_aGridSpans.clear();
+    pCurrentSpans->clear();
 }
 /*-- 18.06.2007 10:34:37---------------------------------------------------
 
@@ -505,8 +404,6 @@ void DomainMapperTableManager::endOfRowAction()
 void DomainMapperTableManager::clearData()
 {
     m_nRow = m_nCell = m_nCellBorderIndex = m_nHeaderRepeat = m_nTableWidth = 0;
-    m_aTableGrid.clear();
-    m_aGridSpans.clear();
     m_sTableStyleName = ::rtl::OUString();
     m_pTableStyleTextProperies.reset();
 }
@@ -521,10 +418,10 @@ void lcl_CopyTextProperties(PropertyMapPtr pToFill,
     //fill base style properties first, recursively
     if( pStyleSheetEntry->sBaseStyleIdentifier.getLength())
     {
-        const StyleSheetEntry* pParentStyleSheet = 
+        const StyleSheetEntryPtr pParentStyleSheet = 
             pStyleSheetTable->FindStyleSheetByISTD(pStyleSheetEntry->sBaseStyleIdentifier);
         OSL_ENSURE( pParentStyleSheet, "table style not found" );
-        lcl_CopyTextProperties( pToFill, pParentStyleSheet, pStyleSheetTable);
+        lcl_CopyTextProperties( pToFill, pParentStyleSheet.get( ), pStyleSheetTable);
     }
 
     PropertyMap::const_iterator aPropIter = pStyleSheetEntry->pProperties->begin();
@@ -541,10 +438,10 @@ void DomainMapperTableManager::CopyTextProperties(PropertyMapPtr pContext, Style
     if( !m_pTableStyleTextProperies.get())
     {
         m_pTableStyleTextProperies.reset( new PropertyMap );
-        const StyleSheetEntry* pStyleSheetEntry = pStyleSheetTable->FindStyleSheetByISTD(
+        const StyleSheetEntryPtr pStyleSheetEntry = pStyleSheetTable->FindStyleSheetByISTD(
                                                         m_sTableStyleName);
         OSL_ENSURE( pStyleSheetEntry, "table style not found" );
-        lcl_CopyTextProperties(m_pTableStyleTextProperies, pStyleSheetEntry, pStyleSheetTable);
+        lcl_CopyTextProperties(m_pTableStyleTextProperies, pStyleSheetEntry.get( ), pStyleSheetTable);
     }
     pContext->insert( m_pTableStyleTextProperies );
 }
diff --git writerfilter/source/dmapper/DomainMapperTableManager.hxx writerfilter/source/dmapper/DomainMapperTableManager.hxx
index c183252..d301acf 100644
--- writerfilter/source/dmapper/DomainMapperTableManager.hxx
+++ writerfilter/source/dmapper/DomainMapperTableManager.hxx
@@ -30,6 +30,8 @@
 #ifndef INCLUDED_DOMAIN_MAPPER_TABLE_MANAGER_HXX
 #define INCLUDED_DOMAIN_MAPPER_TABLE_MANAGER_HXX
 
+#include "TablePropertiesHandler.hxx"
+
 #include <resourcemodel/TableManager.hxx>
 #include <PropertyMap.hxx>
 #include <StyleSheetTable.hxx>
@@ -38,10 +40,11 @@
 
 namespace writerfilter {
 namespace dmapper {
-typedef ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > Handle_t;
-typedef TableManager<Handle_t , TablePropertyMapPtr > DomainMapperTableManager_Base_t;
+
 class DomainMapperTableManager : public DomainMapperTableManager_Base_t
 {
+    typedef boost::shared_ptr< std::vector<sal_Int32> > IntVectorPtr;
+
     sal_uInt32      m_nRow;
     sal_uInt32      m_nCell;
     sal_uInt32      m_nCellBorderIndex; //borders are provided for all cells and need counting
@@ -51,9 +54,12 @@ class DomainMapperTableManager : public DomainMapperTableManager_Base_t
     ::rtl::OUString m_sTableStyleName;    
     PropertyMapPtr  m_pTableStyleTextProperies;
 
-    ::std::vector<sal_Int32>  m_aTableGrid;
-    ::std::vector<sal_Int32>  m_aGridSpans;
+    ::std::vector< IntVectorPtr >  m_aTableGrid;
+    ::std::vector< IntVectorPtr >  m_aGridSpans;
     
+    TablePropertiesHandler   *m_pTablePropsHandler;
+    PropertyMapPtr            m_pStyleProps;
+
     virtual void clearData();
 
 public:
@@ -61,15 +67,56 @@ public:
     DomainMapperTableManager(bool bOOXML);
     virtual ~DomainMapperTableManager();
 
+    // use this method to avoid adding the properties for the table
+    // but in the provided properties map.
+    inline void SetStyleProperties( PropertyMapPtr pProperties ) { m_pStyleProps = pProperties; };
+
     virtual bool sprm(Sprm & rSprm);
 
+    virtual void startLevel( );
+    virtual void endLevel( );
+
     virtual void endOfCellAction();
     virtual void endOfRowAction();
 
+    IntVectorPtr getCurrentGrid( );
+    IntVectorPtr getCurrentSpans( );
+
     const ::rtl::OUString& getTableStyleName() const { return m_sTableStyleName; }
     /// copy the text properties of the table style and its parent into pContext
     void    CopyTextProperties(PropertyMapPtr pContext, StyleSheetTablePtr pStyleSheetTable);
 
+    inline virtual void cellProps(TablePropertyMapPtr pProps)
+    {
+        if ( m_pStyleProps.get( ) )
+            m_pStyleProps->insert( pProps, true );
+        else
+           DomainMapperTableManager_Base_t::cellProps( pProps );
+    };
+
+    inline virtual void cellPropsByCell(unsigned int i, TablePropertyMapPtr pProps)
+    {
+        if ( m_pStyleProps.get( ) )
+            m_pStyleProps->insert( pProps, true );
+        else
+           DomainMapperTableManager_Base_t::cellPropsByCell( i, pProps );
+    };
+
+    inline virtual void insertRowProps(TablePropertyMapPtr pProps)
+    {
+        if ( m_pStyleProps.get( ) )
+            m_pStyleProps->insert( pProps, true );
+        else
+           DomainMapperTableManager_Base_t::insertRowProps( pProps );
+    };
+
+    inline virtual void insertTableProps(TablePropertyMapPtr pProps)
+    {
+        if ( m_pStyleProps.get( ) )
+            m_pStyleProps->insert( pProps, true );
+        else
+           DomainMapperTableManager_Base_t::insertTableProps( pProps );
+    };
 };
 
 }}
diff --git writerfilter/source/dmapper/DomainMapper_Impl.cxx writerfilter/source/dmapper/DomainMapper_Impl.cxx
index 051a2b8..a7c10ce 100644
--- writerfilter/source/dmapper/DomainMapper_Impl.cxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.cxx
@@ -36,6 +36,8 @@
 #include <com/sun/star/beans/XPropertyState.hpp>
 #include <com/sun/star/container/XIndexReplace.hpp>
 #include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/drawing/XShapes.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/style/LineNumberPosition.hpp>
@@ -55,6 +57,7 @@
 #include <com/sun/star/text/ReferenceFieldPart.hpp>
 #include <com/sun/star/text/ReferenceFieldSource.hpp>
 #include <com/sun/star/text/SizeType.hpp>
+#include <com/sun/star/text/TextContentAnchorType.hpp>
 #include <com/sun/star/text/WrapTextMode.hpp>
 #include <com/sun/star/text/XDependentTextField.hpp>
 #include <com/sun/star/text/XParagraphCursor.hpp>
@@ -69,12 +72,17 @@
 #include <com/sun/star/util/XNumberFormats.hpp>
 #include <rtl/ustrbuf.hxx>
 #include <rtl/string.h>
+
+#include <tools/string.hxx>
 #ifdef DEBUG_DOMAINMAPPER
 #include <resourcemodel/QNameToString.hxx>
 #include <resourcemodel/util.hxx>
 #endif
 #include <ooxml/OOXMLFastTokens.hxx>
 
+#if DEBUG
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
 
 #include <map>
 
@@ -393,6 +401,8 @@ DomainMapper_Impl::DomainMapper_Impl(
         m_bIsFirstSection( true ),
         m_bIsColumnBreakDeferred( false ),
         m_bIsPageBreakDeferred( false ),
+        m_bIsInShape( false ),
+        m_bShapeContextAdded( false ),
         m_TableManager( eDocumentType == DOCUMENT_OOXML ),
         m_nCurrentTabStopIndex( 0 ),
         m_sCurrentParaStyleId(),
@@ -401,7 +411,9 @@ DomainMapper_Impl::DomainMapper_Impl(
         m_bLineNumberingSet( false ),
         m_bIsInFootnoteProperties( true ),
         m_bIsCustomFtnMark( false ),
-        n_CurrentRedlineToken( ooxml::OOXML_mod )
+        m_bIsParaChange( false ),
+        m_bParaChanged( false ),
+        m_bIsLastParaInSection( false )
 {
     GetBodyText();
     uno::Reference< text::XTextAppend > xBodyTextAppend = uno::Reference< text::XTextAppend >( m_xBodyText, uno::UNO_QUERY );
@@ -420,8 +432,10 @@ DomainMapper_Impl::DomainMapper_Impl(
   -----------------------------------------------------------------------*/
 DomainMapper_Impl::~DomainMapper_Impl()
 {
+    RemoveLastParagraph( ); 
     m_TableManager.endLevel();
 }
+
 /*-------------------------------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -474,6 +488,28 @@ void DomainMapper_Impl::SetDocumentSettingsProperty( const ::rtl::OUString& rPro
         }
     }
 }
+
+void DomainMapper_Impl::RemoveLastParagraph( )
+{
+    uno::Reference< text::XTextAppend >  xTextAppend = m_aTextAppendStack.top().xTextAppend;
+    try
+    {
+        uno::Reference< text::XTextCursor > xCursor = xTextAppend->createTextCursor();
+        xCursor->gotoEnd(false);
+        xCursor->goLeft( 1, true );
+        xCursor->setString(::rtl::OUString());
+    }
+    catch( const uno::Exception& rEx)
+    {
+        (void)rEx;
+    }
+}
+
+void DomainMapper_Impl::SetIsLastParagraphInSection( bool bIsLast )
+{
+    m_bIsLastParaInSection = bIsLast;
+}
+   
 /*-------------------------------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -524,6 +560,7 @@ void DomainMapper_Impl::PushListProperties(PropertyMapPtr pListProperties)
 void    DomainMapper_Impl::PopProperties(ContextType eId)
 {
     OSL_ENSURE(!m_aPropertyStacks[eId].empty(), "section stack already empty");
+
     m_aPropertyStacks[eId].pop();
     m_aContextStack.pop();
     if(!m_aContextStack.empty() && !m_aPropertyStacks[m_aContextStack.top()].empty())
@@ -685,13 +722,13 @@ uno::Sequence< style::TabStop > DomainMapper_Impl::GetCurrentTabStopAndClear()
   -----------------------------------------------------------------------*/
 uno::Any DomainMapper_Impl::GetPropertyFromStyleSheet(PropertyIds eId)
 {
-    const StyleSheetEntry* pEntry = 0;
+    StyleSheetEntryPtr pEntry;
     if( m_bInStyleSheetImport )
         pEntry = GetStyleSheetTable()->FindParentStyleSheet(::rtl::OUString());
     else
         pEntry =
                 GetStyleSheetTable()->FindStyleSheetByISTD(GetCurrentParaStyleId());
-    while(pEntry)
+    while(pEntry.get( ) )
     {
         //is there a tab stop set?
         if(pEntry->pProperties)
@@ -725,10 +762,10 @@ void DomainMapper_Impl::deferBreak( BreakType deferredBreakType)
     switch (deferredBreakType)
     {
     case COLUMN_BREAK:
-        m_bIsColumnBreakDeferred = true;
+            m_bIsColumnBreakDeferred = true;
         break;
     case PAGE_BREAK:
-        m_bIsPageBreakDeferred = true;
+            m_bIsPageBreakDeferred = true;
         break;
     default:
         return;
@@ -831,11 +868,15 @@ void lcl_AddRangeAndStyle(
 /*-------------------------------------------------------------------------
 
   -----------------------------------------------------------------------*/
-//define some default frame width - 10cm ATM
-#define DEFAULT_FRAME_MIN_WIDTH 10000
+//define some default frame width - 0cm ATM: this allow the frame to be wrapped around the text
+#define DEFAULT_FRAME_MIN_WIDTH 0
 
 void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
 {
+#if DEBUG
+    clog << "finishParagraph" << endl;
+#endif
+
     ParagraphPropertyMap* pParaContext = dynamic_cast< ParagraphPropertyMap* >( pPropertyMap.get() );
     TextAppendContext& rAppendContext = m_aTextAppendStack.top();
     uno::Reference< text::XTextAppend >  xTextAppend = rAppendContext.xTextAppend;
@@ -903,11 +944,11 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
                     try
                        {
                             //
-                           const StyleSheetEntry* pParaStyle =
+                            StyleSheetEntryPtr pParaStyle =
                                 m_pStyleSheetTable->FindStyleSheetByConvertedStyleName(rAppendContext.pLastParagraphProperties->GetParaStyleName());
 
                             uno::Sequence< beans::PropertyValue > aFrameProperties(pParaStyle ? 15: 0);
-                            if(pParaStyle)
+                            if ( pParaStyle.get( ) )
                             {
                                 const ParagraphProperties* pStyleProperties = dynamic_cast<const ParagraphProperties*>( pParaStyle->pProperties.get() );
                                 beans::PropertyValue* pFrameProperties = aFrameProperties.getArray();
@@ -1045,14 +1086,43 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
                 uno::Reference< text::XTextRange > xTextRange =
                     xTextAppend->finishParagraph( aProperties );
                 m_TableManager.handle(xTextRange);
-            }
-            else
-            {
+            
+                // Set the anchor of the objects to the created paragraph
+                while ( m_aAnchoredStack.size( ) > 0 && !m_bIsInShape )
+                {
+                    uno::Reference< text::XTextContent > xObj = m_aAnchoredStack.top( );
+                    try 
+                    {
+#if DEBUG
+                        rtl::OUString sText( xTextRange->getString( ) );
+#endif
+                        xObj->attach( xTextRange );
+                    } 
+                    catch ( uno::RuntimeException& )
+                    {
+                        // this is normal: the shape is already attached
+                    }   
+                    m_aAnchoredStack.pop( );
+                }
+    
+                // Get the end of paragraph character inserted
+                uno::Reference< text::XTextCursor > xCur = xTextRange->getText( )->createTextCursor( );
+                xCur->gotoEnd( false );
+                xCur->goLeft( 1 , true );
+                uno::Reference< text::XTextRange > xParaEnd( xCur, uno::UNO_QUERY );
+                CheckParaRedline( xParaEnd );
+
+                // Remove the last empty section paragraph if needed
+                if ( m_bIsLastParaInSection && !m_bParaChanged )
+                {
+                    RemoveLastParagraph( );
+                    m_bIsLastParaInSection = false;
+                }
 
+                m_bParaChanged = false;
             }
             if( !bKeepLastParagraphProperties )
                 rAppendContext.pLastParagraphProperties = pToBeSavedProperties;
-
         }
         catch(const lang::IllegalArgumentException& rIllegal)
         {
@@ -1062,7 +1132,7 @@ void DomainMapper_Impl::finishParagraph( PropertyMapPtr pPropertyMap )
         catch(const uno::Exception& rEx)
         {
             (void)rEx;
-            OSL_ENSURE( false, "ArgumentException in DomainMapper_Impl::finishParagraph" );
+            //OSL_ENSURE( false, "ArgumentException in DomainMapper_Impl::finishParagraph" );
         }
     }
 }
@@ -1099,35 +1169,9 @@ void DomainMapper_Impl::appendTextPortion( const ::rtl::OUString& rString, Prope
             uno::Reference< text::XTextRange > xTextRange =
                 xTextAppend->appendTextPortion
                 (rString, pPropertyMap->GetPropertyValues());
-            if( m_CurrentRedlineDate.getLength() )
-            {
-                try
-                {
-                    ::rtl::OUString sType;
-                    PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-                    switch(n_CurrentRedlineToken & 0xffff)
-                    {
-                        case ooxml::OOXML_mod : sType = rPropNameSupplier.GetName( PROP_FORMAT ); break;
-                        case ooxml::OOXML_ins : sType = rPropNameSupplier.GetName( PROP_INSERT ); break;
-                        case ooxml::OOXML_del : sType = rPropNameSupplier.GetName( PROP_DELETE ); break;
-                    }
-                    uno::Reference< text::XRedline > xRedline( xTextRange, uno::UNO_QUERY_THROW );
-                    beans::PropertyValues aRedlineProperties( 2 );
-                    beans::PropertyValue* pRedlineProperties = aRedlineProperties.getArray();
-                    pRedlineProperties[0].Name = rPropNameSupplier.GetName( PROP_REDLINE_AUTHOR );
-                    pRedlineProperties[0].Value <<= m_CurrentRedlineAuthor;
-                    pRedlineProperties[1].Name = rPropNameSupplier.GetName( PROP_REDLINE_DATE_TIME );
-                    pRedlineProperties[1].Value <<= lcl_DateStringToDateTime( m_CurrentRedlineDate );
-                    xRedline->makeRedline( sType, aRedlineProperties);
+            CheckRedline( xTextRange );
 
-                }
-                catch( const uno::Exception& rEx )
-                {
-                    (void)rEx;
-                    OSL_ENSURE( false, "Exception in makeRedline" );
-                }
-                ResetRedlineProperties();
-            }
+            m_bParaChanged = true;
 
             //m_TableManager.handle(xTextRange);
         }
@@ -1167,6 +1211,7 @@ void DomainMapper_Impl::appendTextContent(
         }
     }
 }
+
 /*-- 24.04.2008 08:38:07---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -1319,18 +1364,7 @@ void DomainMapper_Impl::PopPageHeaderFooter()
 {
     //header and footer always have an empty paragraph at the end
     //this has to be removed
-    uno::Reference< text::XTextAppend >  xTextAppend = m_aTextAppendStack.top().xTextAppend;
-    try
-    {
-        uno::Reference< text::XTextCursor > xCursor = xTextAppend->createTextCursor();
-        xCursor->gotoEnd(false);
-        xCursor->goLeft( 1, true );
-        xCursor->setString(::rtl::OUString());
-    }
-    catch( const uno::Exception& rEx)
-    {
-        (void)rEx;
-    }
+    RemoveLastParagraph( ); 
     m_aTextAppendStack.pop();
 }
 /*-- 24.05.2007 14:22:28---------------------------------------------------
@@ -1351,31 +1385,99 @@ void DomainMapper_Impl::PushFootOrEndnote( bool bIsFootnote )
         {
             xFootnote->setLabel( ::rtl::OUString( pTopContext->GetFootnoteSymbol() ) );
         }
-        FontTablePtr pFontTable = GetFontTable();
-        uno::Sequence< beans::PropertyValue > aFontProperties;
-        if( pFontTable && pTopContext->GetFootnoteFontId() >= 0 && pFontTable->size() > (size_t)pTopContext->GetFootnoteFontId() )
+
+        appendTextContent( uno::Reference< text::XTextContent >( xFootnoteText, uno::UNO_QUERY_THROW ), 
+               pTopContext->GetPropertyValues( ) );
+        m_aTextAppendStack.push(uno::Reference< text::XTextAppend >( xFootnoteText, uno::UNO_QUERY_THROW ));
+
+        // Redlines for the footnote anchor
+        CheckRedline( xFootnote->getAnchor( ) );
+    }
+    catch( uno::Exception& )
+    {
+        OSL_ENSURE( false, "exception in PushFootOrEndnote" );
+    }
+}
+
+void DomainMapper_Impl::CreateRedline( uno::Reference< text::XTextRange > xRange, RedlineParamsPtr& pRedline )
+{
+    if ( pRedline.get( ) )
+    {
+#if DEBUG
+        clog << "REDLINE: Writing redline: " << pRedline->m_nId << endl;
+#endif
+        try
         {
-            const FontEntry* pFontEntry = pFontTable->getFontEntry(sal_uInt32(pTopContext->GetFootnoteFontId()));
-            PropertyMapPtr aFontProps( new PropertyMap );
-            aFontProps->Insert(PROP_CHAR_FONT_NAME, true, uno::makeAny( pFontEntry->sFontName  ));
-            aFontProps->Insert(PROP_CHAR_FONT_CHAR_SET, true, uno::makeAny( (sal_Int16)pFontEntry->nTextEncoding  ));
-            aFontProps->Insert(PROP_CHAR_FONT_PITCH, true, uno::makeAny( pFontEntry->nPitchRequest  ));
-            aFontProperties = aFontProps->GetPropertyValues();
+            ::rtl::OUString sType;
+            PropertyNameSupplier & rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier(  );
+            switch ( pRedline->m_nToken & 0xffff )
+            {
+            case ooxml::OOXML_mod:
+                sType = rPropNameSupplier.GetName( PROP_FORMAT );
+                break;
+            case ooxml::OOXML_ins:
+                sType = rPropNameSupplier.GetName( PROP_INSERT );
+                break;
+            case ooxml::OOXML_del:
+                sType = rPropNameSupplier.GetName( PROP_DELETE );
+                break;
+            }
+            uno::Reference < text::XRedline > xRedline( xRange, uno::UNO_QUERY_THROW );
+            beans::PropertyValues aRedlineProperties( 2 );
+            beans::PropertyValue * pRedlineProperties = aRedlineProperties.getArray(  );
+            pRedlineProperties[0].Name = rPropNameSupplier.GetName( PROP_REDLINE_AUTHOR );
+            pRedlineProperties[0].Value <<= pRedline->m_sAuthor;
+            pRedlineProperties[1].Name = rPropNameSupplier.GetName( PROP_REDLINE_DATE_TIME );
+            pRedlineProperties[1].Value <<= lcl_DateStringToDateTime( pRedline->m_sDate );
+            
+            xRedline->makeRedline( sType, aRedlineProperties );
         }
-        else if(pTopContext->GetFootnoteFontName().getLength())
+        catch( const uno::Exception & rEx )
         {
-            PropertyMapPtr aFontProps( new PropertyMap );
-            aFontProps->Insert(PROP_CHAR_FONT_NAME, true, uno::makeAny( pTopContext->GetFootnoteFontName()  ));
-            aFontProperties = aFontProps->GetPropertyValues();
+#if DEBUG
+            clog << "REDLINE: error - " << rtl::OUStringToOString( rEx.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
+            ( void ) rEx;
+            OSL_ENSURE( false, "Exception in makeRedline" );
         }
+    }
+}
 
-        appendTextContent( uno::Reference< text::XTextContent >( xFootnoteText, uno::UNO_QUERY_THROW ), aFontProperties );
-        m_aTextAppendStack.push(uno::Reference< text::XTextAppend >( xFootnoteText, uno::UNO_QUERY_THROW ));
+void DomainMapper_Impl::CheckParaRedline( uno::Reference< text::XTextRange > xRange )
+{
+    if ( m_pParaRedline.get( ) )
+    {
+        CreateRedline( xRange, m_pParaRedline );
+        ResetParaRedline( ); 
     }
-    catch( uno::Exception& )
+}
+
+void DomainMapper_Impl::CheckRedline( uno::Reference< text::XTextRange > xRange )
+{
+    vector<RedlineParamsPtr>::iterator pIt = m_aRedlines.begin( );
+    vector< RedlineParamsPtr > aCleaned;
+    for (; pIt != m_aRedlines.end( ); pIt++ )
     {
-        OSL_ENSURE( false, "exception in PushFootOrEndnote" );
+        CreateRedline( xRange, *pIt );
+        
+        // Adding the non-mod redlines to the temporary vector
+        if ( pIt->get( ) && ( ( *pIt )->m_nToken & 0xffff ) != ooxml::OOXML_mod ) 
+        {
+            aCleaned.push_back( *pIt );
+        }
     }
+
+    m_aRedlines.swap( aCleaned );
+}
+
+void DomainMapper_Impl::StartParaChange( )
+{
+    m_bIsParaChange = true;
+}
+
+void DomainMapper_Impl::EndParaChange( )
+{
+    m_bIsParaChange = false;
 }
 
 /*-- 22.12.2008 13:45:15---------------------------------------------------
@@ -1416,57 +1518,58 @@ void DomainMapper_Impl::PopAnnotation()
     m_xAnnotationField.clear();
 
 }
-/*-- 20.03.2008 09:01:58---------------------------------------------------
 
-  -----------------------------------------------------------------------*/
-void DomainMapper_Impl::PushShapeContext()
+void DomainMapper_Impl::PushShapeContext( const uno::Reference< drawing::XShape > xShape )
 {
-    try
+#if DEBUG
+    clog << "PushShapeContext" << endl;
+#endif
+    m_bIsInShape = true;
+    try 
     {
-        uno::Reference< text::XText > xTemporaryShape( GetTextFactory()->createInstance(
-                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.drawing.RectangleShape") )),
-                uno::UNO_QUERY_THROW );
-        uno::Reference< text::XTextAppend > xShapeAppend( xTemporaryShape, uno::UNO_QUERY );
-        //insert into the document
-        uno::Reference< text::XTextContent > xShapeContent( xTemporaryShape, uno::UNO_QUERY_THROW );
-        xShapeContent->attach( GetBodyText()->getStart() );
-        m_aTextAppendStack.push(uno::Reference< text::XTextAppend >( xShapeAppend, uno::UNO_QUERY_THROW ));
-    }
-    catch( uno::Exception& )
+        // Add the shape to the text append stack
+        m_aTextAppendStack.push( uno::Reference< text::XTextAppend >( xShape, uno::UNO_QUERY_THROW ) );
+        m_bShapeContextAdded = true;
+
+        // Add the shape to the anchored objects stack
+        uno::Reference< text::XTextContent > xTxtContent( xShape, uno::UNO_QUERY_THROW );
+        m_aAnchoredStack.push( xTxtContent );
+
+        PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+        uno::Reference< beans::XPropertySet > xProps( xShape, uno::UNO_QUERY_THROW );
+        xProps->setPropertyValue( 
+                rPropNameSupplier.GetName( PROP_ANCHOR_TYPE ),
+                uno::makeAny( text::TextContentAnchorType_AT_PARAGRAPH ) );
+        xProps->setPropertyValue(
+                rPropNameSupplier.GetName( PROP_OPAQUE ),
+                uno::makeAny( true ) );
+    } 
+    catch ( const uno::Exception& e )
     {
-        OSL_ENSURE( false, "exception in DomainMapper_Impl::PushShapeContext" );
+#if DEBUG
+        clog << "Exception when adding shape: ";
+        clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( );
+        clog << endl;
+#endif
     }
 }
+
 /*-- 20.03.2008 09:01:59---------------------------------------------------
 
   -----------------------------------------------------------------------*/
 void DomainMapper_Impl::PopShapeContext()
 {
-    m_xTemporaryShape = uno::Reference< drawing::XShape >( m_aTextAppendStack.top().xTextAppend, uno::UNO_QUERY );
-    m_aTextAppendStack.pop();
-}
-/*-- 20.03.2008 12:31:58---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void DomainMapper_Impl::CopyTemporaryShapeText( uno::Reference< drawing::XShape > xShape )
-{
-    uno::Reference< text::XTextCopy >xShapeText( xShape, uno::UNO_QUERY );
-    uno::Reference< text::XTextCopy >xTempShapeText( m_xTemporaryShape, uno::UNO_QUERY );
-    if( xShapeText.is() && xTempShapeText.is() )
-    {
-        xShapeText->copyText( xTempShapeText );
-    }
-    try
-    {
-        uno::Reference< lang::XComponent >xTemp( m_xTemporaryShape, uno::UNO_QUERY );
-        if( xTemp.is() )
-            xTemp->dispose();
-    }
-    catch( const uno::Exception& )
+#if DEBUG
+        clog << "PopShapeContext" << endl;
+#endif
+    
+    if ( m_bShapeContextAdded )
     {
+        m_aTextAppendStack.pop();
+        m_bShapeContextAdded = false;
     }
-    m_xTemporaryShape = uno::Reference< drawing::XShape >();
-
+    m_bIsInShape = false;
 }
 /*-- 12.09.2006 08:07:55---------------------------------------------------
 
@@ -2952,6 +3055,7 @@ void DomainMapper_Impl::CloseFieldCommand()
                         bool bHyperlinks = false;
                         bool bFromOutline = false;
                         bool bFromEntries = false;
+                        sal_Int16 nMaxLevel = 10;
                         ::rtl::OUString sTemplate;
                         ::rtl::OUString sChapterNoSeparator;
     //                  \a Builds a table of figures but does not include the captions's label and number
@@ -3001,6 +3105,10 @@ void DomainMapper_Impl::CloseFieldCommand()
                         if( lcl_FindInCommand( pContext->GetCommand(), 'o', sValue ))
                         {
                             bFromOutline = true;
+                            UniString sParam( sValue );
+                            xub_StrLen nIndex = 0;
+                            sParam.GetToken( 0, '-', nIndex );
+                            nMaxLevel = sal_Int16( sParam.Copy( nIndex ).ToInt32( ) );
                         }
     //                  \p Defines the separator between the table entry and its page number
                         if( lcl_FindInCommand( pContext->GetCommand(), 'p', sValue ))
@@ -3048,6 +3156,7 @@ void DomainMapper_Impl::CloseFieldCommand()
                         xTOC->setPropertyValue(rPropNameSupplier.GetName( PROP_TITLE ), uno::makeAny(::rtl::OUString()));
                         if( !bTableOfFigures )
                         {
+                            xTOC->setPropertyValue( rPropNameSupplier.GetName( PROP_LEVEL ), uno::makeAny( nMaxLevel ) );
                             xTOC->setPropertyValue( rPropNameSupplier.GetName( PROP_CREATE_FROM_OUTLINE ), uno::makeAny( bFromOutline ));
                             xTOC->setPropertyValue( rPropNameSupplier.GetName( PROP_CREATE_FROM_MARKS ), uno::makeAny( bFromEntries ));
                             if( sTemplate.getLength() )
@@ -3531,14 +3640,98 @@ bool DomainMapper_Impl::ExecuteFrameConversion()
     }
     return bRet;
 }
+
+void DomainMapper_Impl::AddNewRedline(  )
+{
+    RedlineParamsPtr pNew( new RedlineParams );
+    pNew->m_nToken = ooxml::OOXML_mod;
+    if ( !m_bIsParaChange ) 
+    {
+#if DEBUG
+    clog << "REDLINE: Adding a new redline to stack" << endl;
+#endif
+        m_aRedlines.push_back( pNew );
+    }
+    else
+    {
+#if DEBUG
+    clog << "REDLINE: Setting a new paragraph redline" << endl;
+#endif
+        m_pParaRedline.swap( pNew );
+    }
+}
+
+RedlineParamsPtr DomainMapper_Impl::GetTopRedline(  )
+{
+    RedlineParamsPtr pResult;
+    if ( !m_bIsParaChange && m_aRedlines.size(  ) > 0 )
+        pResult = m_aRedlines.back(  );
+    else if ( m_bIsParaChange )
+        pResult = m_pParaRedline;
+    return pResult;
+}
+
+sal_Int32 DomainMapper_Impl::GetCurrentRedlineToken(  )
+{
+    sal_Int32 nToken;
+    RedlineParamsPtr pCurrent( GetTopRedline(  ) );
+    if ( pCurrent.get(  ) )
+        nToken = pCurrent->m_nToken;
+    return nToken;
+}
+
+void DomainMapper_Impl::SetCurrentRedlineAuthor( rtl::OUString sAuthor )
+{
+    RedlineParamsPtr pCurrent( GetTopRedline(  ) );
+    if ( pCurrent.get(  ) )
+        pCurrent->m_sAuthor = sAuthor;
+}
+
+void DomainMapper_Impl::SetCurrentRedlineDate( rtl::OUString sDate )
+{
+    RedlineParamsPtr pCurrent( GetTopRedline(  ) );
+    if ( pCurrent.get(  ) )
+        pCurrent->m_sDate = sDate;
+}
+
+void DomainMapper_Impl::SetCurrentRedlineId( sal_Int32 sId )
+{
+    RedlineParamsPtr pCurrent( GetTopRedline(  ) );
+    if ( pCurrent.get(  ) )
+        pCurrent->m_nId = sId;
+}
+
+void DomainMapper_Impl::SetCurrentRedlineToken( sal_Int32 nToken )
+{
+    RedlineParamsPtr pCurrent( GetTopRedline(  ) );
+    if ( pCurrent.get(  ) )
+        pCurrent->m_nToken = nToken;
+}
+
 /*-- 19.03.2008 11:35:38---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void DomainMapper_Impl::ResetRedlineProperties()
+void DomainMapper_Impl::RemoveCurrentRedline( )
 {
-    m_CurrentRedlineAuthor = m_CurrentRedlineDate = m_CurrentRedlineId = ::rtl::OUString();
-    n_CurrentRedlineToken = ooxml::OOXML_mod;
+    if ( m_aRedlines.size( ) > 0 )
+    {
+#if DEBUG
+        clog << "REDLINE: Removing back redline" << endl;
+#endif
+        m_aRedlines.pop_back( );
+    }
 }
 
+void DomainMapper_Impl::ResetParaRedline( )
+{
+    if ( m_pParaRedline.get( ) )
+    {
+#if DEBUG
+        clog << "REDLINE: Cleaning the para redline" << endl;
+#endif
+        RedlineParamsPtr pEmpty;
+        m_pParaRedline.swap( pEmpty );
+    }
+}
 
 }}
diff --git writerfilter/source/dmapper/DomainMapper_Impl.hxx writerfilter/source/dmapper/DomainMapper_Impl.hxx
index f4dfaf0..52a53b4 100644
--- writerfilter/source/dmapper/DomainMapper_Impl.hxx
+++ writerfilter/source/dmapper/DomainMapper_Impl.hxx
@@ -34,6 +34,7 @@
 #include <com/sun/star/text/XTextCursor.hpp>
 #include <com/sun/star/text/XTextAppend.hpp>
 #include <com/sun/star/text/XTextAppendAndConvert.hpp>
+#include <com/sun/star/text/XTextFrame.hpp>
 #include <com/sun/star/style/TabStop.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <vector>
@@ -51,6 +52,7 @@
 #include <LFOTable.hxx>
 #include <StyleSheetTable.hxx>
 #include <ThemeTable.hxx>
+#include <SettingsTable.hxx>
 #include <GraphicImport.hxx>
 #include <OLEHandler.hxx>
 #include <map>
@@ -177,6 +179,7 @@ typedef std::stack<ContextType>                 ContextStack;
 typedef std::stack<PropertyMapPtr>              PropertyStack;
 typedef std::stack< TextAppendContext >         TextAppendStack;
 typedef std::stack<FieldContextPtr>                FieldStack;
+typedef std::stack< com::sun::star::uno::Reference< com::sun::star::text::XTextContent > >  TextContentStack;
 
 /*-- 18.07.2006 08:49:08---------------------------------------------------
 
@@ -225,6 +228,15 @@ struct BookmarkInsertPosition
      {}
 };
 
+struct RedlineParams
+{
+    ::rtl::OUString m_sAuthor;
+    ::rtl::OUString m_sDate;
+    sal_Int32       m_nId;
+    sal_Int32       m_nToken;
+};
+typedef boost::shared_ptr< RedlineParams > RedlineParamsPtr;
+
 /*-- 03.03.2008 11:01:38---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -267,12 +279,17 @@ private:
 
     TextAppendStack                                                                 m_aTextAppendStack;
 
+    TextContentStack
+              m_aAnchoredStack; 
+
     FieldStack                                                                      m_aFieldStack;
     bool                                                                            m_bFieldMode;
     bool                                                                            m_bSetUserFieldContent;
     bool                                                                            m_bIsFirstSection;
     bool                                                                            m_bIsColumnBreakDeferred;
     bool                                                                            m_bIsPageBreakDeferred;
+    bool                                                                            m_bIsInShape;
+    bool                                                                            m_bShapeContextAdded;
 
     LineNumberSettings                                                              m_aLineNumberSettings;
 
@@ -293,6 +310,7 @@ private:
     StyleSheetTablePtr      m_pStyleSheetTable;
     ThemeTablePtr           m_pThemeTable;
     GraphicImportPtr        m_pGraphicImport;
+    SettingsTablePtr        m_pSettingsTable;
 
     PropertyMapPtr                  m_pTopContext;
 
@@ -311,14 +329,14 @@ private:
     ::com::sun::star::uno::Reference< text::XTextRange >      m_xFrameStartRange;
     ::com::sun::star::uno::Reference< text::XTextRange >      m_xFrameEndRange;
 
-    //current redline
-    ::rtl::OUString                 m_CurrentRedlineAuthor;
-    ::rtl::OUString                 m_CurrentRedlineDate;
-    ::rtl::OUString                 m_CurrentRedlineId;
-    sal_Int32                       n_CurrentRedlineToken;
+    // Redline stack
+    std::vector< RedlineParamsPtr > m_aRedlines;
+    RedlineParamsPtr                m_pParaRedline;
+    bool                            m_bIsParaChange;
+
+    bool                            m_bParaChanged;
+    bool                            m_bIsLastParaInSection;
 
-    //shape import
-    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >      m_xTemporaryShape;
 
     //annotation import
     uno::Reference< beans::XPropertySet >                                      m_xAnnotationField;
@@ -357,6 +375,18 @@ public:
     }
     void SetDocumentSettingsProperty( const ::rtl::OUString& rPropName, const uno::Any& rValue );
 
+    void CreateRedline( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > xRange, RedlineParamsPtr& pRedline  );
+
+    void CheckParaRedline( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > xRange );
+
+    void CheckRedline( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > xRange );
+
+    void StartParaChange( );
+    void EndParaChange( );
+
+    void RemoveLastParagraph( );
+    void SetIsLastParagraphInSection( bool bIsLast );
+
     void deferBreak( BreakType deferredBreakType );
     bool isBreakDeferred( BreakType deferredBreakType );
     void clearDeferredBreaks();
@@ -412,6 +442,13 @@ public:
         return m_pThemeTable;
     }
 
+    SettingsTablePtr GetSettingsTable( )
+    {
+        if ( !m_pSettingsTable )
+            m_pSettingsTable.reset( new SettingsTable );
+        return m_pSettingsTable;
+    }
+
     GraphicImportPtr GetGraphicImport( GraphicImportType eGraphicImportType );
     void            ResetGraphicImport();
     // this method deletes the current m_pGraphicImport after import
@@ -432,10 +469,8 @@ public:
     void        SetAnyTableImport( bool bSet ) { m_bInAnyTableImport = bSet;}
     bool        IsAnyTableImport()const { return m_bInAnyTableImport;}
 
-    void PushShapeContext();
+    void PushShapeContext( const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
     void PopShapeContext();
-    bool IsInShapeContext() const { return m_xTemporaryShape.is(); }
-    void CopyTemporaryShapeText( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
 
     void PushPageHeader(SectionPropertyMap::PageType eType);
     void PushPageFooter(SectionPropertyMap::PageType eType);
@@ -495,19 +530,17 @@ public:
         );
     bool ExecuteFrameConversion();
 
-    ::rtl::OUString  GetCurrentRedlineAuthor() const { return m_CurrentRedlineAuthor; }
-    void SetCurrentRedlineAuthor( const ::rtl::OUString& rSet ) { m_CurrentRedlineAuthor = rSet; }
-
-    ::rtl::OUString  GetCurrentRedlineDate() const   { return m_CurrentRedlineDate;   }
-    void SetCurrentRedlineDate( const ::rtl::OUString& rSet )    { m_CurrentRedlineDate = rSet;   }
-
-    ::rtl::OUString  GetCurrentRedlineId() const     { return m_CurrentRedlineId;     }
-    void SetCurrentRedlineId( const ::rtl::OUString& rSet ) { m_CurrentRedlineId = rSet;     }
+    void AddNewRedline( );
 
-    sal_Int32        GetCurrentRedlineToken() const  { return n_CurrentRedlineToken;  }
-    void SetCurrentRedlineToken(sal_Int32 nSet) { n_CurrentRedlineToken = nSet;  }
+    RedlineParamsPtr GetTopRedline( );
 
-    void ResetRedlineProperties();
+    sal_Int32 GetCurrentRedlineToken( ); 
+    void SetCurrentRedlineAuthor( rtl::OUString sAuthor );
+    void SetCurrentRedlineDate( rtl::OUString sDate );
+    void SetCurrentRedlineId( sal_Int32 nId );
+    void SetCurrentRedlineToken( sal_Int32 nToken );
+    void RemoveCurrentRedline( );
+    void ResetParaRedline( );
 
 };
 } //namespace dmapper
diff --git writerfilter/source/dmapper/FontTable.cxx writerfilter/source/dmapper/FontTable.cxx
index 7e3251d..16be55d 100644
--- writerfilter/source/dmapper/FontTable.cxx
+++ writerfilter/source/dmapper/FontTable.cxx
@@ -647,6 +647,15 @@ void FontTable::substream(Id, ::writerfilter::Reference<Stream>::Pointer_t)
 void FontTable::info(const string& )
 {
 }
+
+void FontTable::startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > )
+{
+}
+
+void FontTable::endShape( )
+{
+}
+
 /*-- 21.06.2006 11:21:38---------------------------------------------------
 
   -----------------------------------------------------------------------*/
diff --git writerfilter/source/dmapper/FontTable.hxx writerfilter/source/dmapper/FontTable.hxx
index 498e816..f6e8859 100644
--- writerfilter/source/dmapper/FontTable.hxx
+++ writerfilter/source/dmapper/FontTable.hxx
@@ -98,6 +98,8 @@ public:
     virtual void substream(Id name,
                            ::writerfilter::Reference<Stream>::Pointer_t ref);
     virtual void info(const string & info);
+    virtual void startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual void endShape( );
 
     const FontEntry*    getFontEntry(sal_uInt32 nIndex);
     sal_uInt32          size();
diff --git writerfilter/source/dmapper/GraphicHelpers.cxx writerfilter/source/dmapper/GraphicHelpers.cxx
new file mode 100644
index 0000000..a9508c5
--- /dev/null
+++ writerfilter/source/dmapper/GraphicHelpers.cxx
@@ -0,0 +1,223 @@
+#include "ConversionHelper.hxx"
+#include "GraphicHelpers.hxx"
+
+#include <ooxml/resourceids.hxx>
+
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/VertOrientation.hpp>
+#include <com/sun/star/text/RelOrientation.hpp>
+#include <com/sun/star/text/WrapTextMode.hpp>
+
+#include <iostream>
+using namespace std;
+
+namespace writerfilter {
+namespace dmapper {
+
+using namespace com::sun::star;
+
+PositionHandler::PositionHandler( ) :
+    Properties( )
+{
+    m_nOrient = text::VertOrientation::NONE;
+    m_nRelation = text::RelOrientation::FRAME;
+    m_nPosition = 0;
+}
+
+PositionHandler::~PositionHandler( )
+{
+}
+
+void PositionHandler::attribute( Id aName, Value& rVal )
+{
+    sal_Int32 nIntValue = rVal.getInt( );
+    switch ( aName )
+    {
+        case NS_ooxml::LN_CT_PosV_relativeFrom:
+            {
+                // TODO There are some other unhandled values
+                static Id pVertRelValues[] =
+                {
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromV_margin,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromV_page,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromV_paragraph,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromV_line
+                };
+
+                static sal_Int16 pVertRelations[] = 
+                {
+                    text::RelOrientation::PAGE_PRINT_AREA,
+                    text::RelOrientation::PAGE_FRAME,
+                    text::RelOrientation::FRAME,
+                    text::RelOrientation::TEXT_LINE
+                };
+                
+                for ( int i = 0; i < 4; i++ )
+                {
+                    if ( pVertRelValues[i] == sal_uInt32( nIntValue ) )
+                        m_nRelation = pVertRelations[i];
+                }
+            }
+            break;
+        case NS_ooxml::LN_CT_PosH_relativeFrom:
+            {
+                // TODO There are some other unhandled values
+                static Id pHoriRelValues[] =
+                {
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromH_margin,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromH_page,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromH_column,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_RelFromH_character
+                };
+
+                static sal_Int16 pHoriRelations[] = 
+                {
+                    text::RelOrientation::PAGE_PRINT_AREA,
+                    text::RelOrientation::PAGE_FRAME,
+                    text::RelOrientation::FRAME,
+                    text::RelOrientation::CHAR,
+                };
+                
+                for ( int i = 0; i < 4; i++ )
+                {
+                    if ( pHoriRelValues[i] == sal_uInt32( nIntValue ) )
+                        m_nRelation = pHoriRelations[i];
+                }
+            }
+            break;
+        default:;
+    }
+}
+
+void PositionHandler::sprm( Sprm& rSprm )
+{
+    Value::Pointer_t pValue = rSprm.getValue();
+    sal_Int32 nIntValue = pValue->getInt();
+    
+    switch ( rSprm.getId( ) )
+    {
+        case NS_ooxml::LN_CT_PosV_align:
+            {
+                static Id pVertValues[] = 
+                {
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignV_top,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignV_bottom,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignV_center,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignV_inside,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignV_outside
+                };
+
+                static sal_Int16 pVertOrients[] =
+                {
+                    text::VertOrientation::TOP,
+                    text::VertOrientation::BOTTOM,
+                    text::VertOrientation::CENTER,
+                    text::VertOrientation::NONE,
+                    text::VertOrientation::NONE
+                };
+
+                for ( int i = 0; i < 5; i++ )
+                {
+                    if ( pVertValues[i] == sal_uInt32( nIntValue ) )
+                        m_nOrient = pVertOrients[i];
+                }
+            }
+            break;
+        case NS_ooxml::LN_CT_PosH_align:
+            {
+                static Id pHoriValues[] = 
+                {
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignH_left,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignH_right,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignH_center,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignH_inside,
+                    NS_ooxml::LN_Value_wordprocessingDrawing_ST_AlignH_outside
+                };
+
+                static sal_Int16 pHoriOrients[] =
+                {
+                    text::HoriOrientation::LEFT,
+                    text::HoriOrientation::RIGHT,
+                    text::HoriOrientation::CENTER,
+                    text::HoriOrientation::INSIDE,
+                    text::HoriOrientation::OUTSIDE
+                };
+
+                for ( int i = 0; i < 5; i++ )
+                {
+                    if ( pHoriValues[i] == sal_uInt32( nIntValue ) )
+                        m_nOrient = pHoriOrients[i];
+                }
+            }
+            break;
+        case NS_ooxml::LN_CT_PosH_posOffset:
+        case NS_ooxml::LN_CT_PosV_posOffset:
+            m_nPosition = ConversionHelper::convertEMUToMM100( nIntValue );
+        default:;
+    }
+}
+
+WrapHandler::WrapHandler( ) :
+    Properties( ),
+    m_nType( 0 ),
+    m_nSide( 0 )
+{
+}
+
+WrapHandler::~WrapHandler( )
+{
+}
+
+void WrapHandler::attribute( Id aName, Value& rVal )
+{
+    switch ( aName )
+    {
+        case NS_ooxml::LN_CT_Wrap_type:
+            m_nType = sal_Int32( rVal.getInt( ) );
+            break;
+        case NS_ooxml::LN_CT_Wrap_side:
+            m_nSide = sal_Int32( rVal.getInt( ) );
+            break; 
+        default:;
+    }
+}
+
+void WrapHandler::sprm( Sprm& )
+{
+}
+
+sal_Int32 WrapHandler::getWrapMode( )
+{
+    sal_Int32 nMode = com::sun::star::text::WrapTextMode_NONE;
+
+    switch ( m_nType )
+    {
+        case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapType_square:
+        case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapType_tight:
+            {
+                switch ( m_nSide )
+                {
+                    case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapSide_left:
+                        nMode = com::sun::star::text::WrapTextMode_LEFT;
+                        break;
+                    case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapSide_right:
+                        nMode = com::sun::star::text::WrapTextMode_RIGHT;
+                        break;
+                    default:
+                        nMode = com::sun::star::text::WrapTextMode_PARALLEL;
+                }
+            }
+            break;
+        case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapType_through:
+            nMode = com::sun::star::text::WrapTextMode_THROUGHT;
+            break;
+        case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapType_topAndBottom:
+        case NS_ooxml::LN_Value_vml_wordprocessingDrawing_ST_WrapType_none:
+        default:
+            nMode = com::sun::star::text::WrapTextMode_NONE;
+    }
+
+    return nMode;
+}
+
+} }
diff --git writerfilter/source/dmapper/GraphicHelpers.hxx writerfilter/source/dmapper/GraphicHelpers.hxx
new file mode 100644
index 0000000..5142c8b
--- /dev/null
+++ writerfilter/source/dmapper/GraphicHelpers.hxx
@@ -0,0 +1,48 @@
+#ifndef INCLUDED_GRAPHICHELPERS_HXX
+#define INCLUDED_GRAPHICHELPERS_HXX
+
+#include "PropertyMap.hxx"
+
+#include <WriterFilterDllApi.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+
+#include <boost/shared_ptr.hpp>
+
+namespace writerfilter {
+namespace dmapper
+{
+
+class WRITERFILTER_DLLPRIVATE PositionHandler: public Properties
+{
+public:
+    PositionHandler( );
+    ~PositionHandler( );
+
+    sal_Int16 m_nOrient;
+    sal_Int16 m_nRelation;
+    sal_Int32 m_nPosition;
+
+    virtual void attribute( Id aName, Value& rVal );
+    virtual void sprm( Sprm& rSprm );
+}; 
+typedef boost::shared_ptr<PositionHandler> PositionHandlerPtr;
+
+class WRITERFILTER_DLLPRIVATE WrapHandler: public Properties
+{
+public:
+    WrapHandler( );
+    ~WrapHandler( );
+
+    sal_Int32 m_nType;
+    sal_Int32 m_nSide;
+
+    sal_Int32 getWrapMode( );
+
+    virtual void attribute( Id aName, Value& rVal );
+    virtual void sprm( Sprm& rSprm );
+};
+typedef boost::shared_ptr<WrapHandler> WrapHandlerPtr;
+
+} }
+
+#endif
diff --git writerfilter/source/dmapper/GraphicImport.cxx writerfilter/source/dmapper/GraphicImport.cxx
index c234d69..31519f8 100644
--- writerfilter/source/dmapper/GraphicImport.cxx
+++ writerfilter/source/dmapper/GraphicImport.cxx
@@ -29,7 +29,9 @@
  *
  ************************************************************************/
 
-#include <GraphicImport.hxx>
+#include "GraphicImport.hxx"
+#include "GraphicHelpers.hxx"
+
 #include <dmapper/DomainMapper.hxx>
 #include <PropertyMap.hxx>
 #include <doctok/resourceids.hxx>
@@ -995,35 +997,79 @@ void GraphicImport::attribute(Id nName, Value & val)
         case NS_ooxml::LN_shape:
             /* WRITERFILTERSTATUS: done: 0, planned: 0.5, spent: 0 */
             {
-                val.getAny() >>= m_xShape;
-                
-                if (m_xShape.is())
-                {
-                    uno::Reference< beans::XPropertySet > xShapeProps
-                        (m_xShape, uno::UNO_QUERY_THROW);
-                    
-                    PropertyNameSupplier& rPropNameSupplier = 
-                        PropertyNameSupplier::GetPropertyNameSupplier();
-                    xShapeProps->setPropertyValue
-                        (rPropNameSupplier.GetName(PROP_ANCHOR_TYPE),
-                         uno::makeAny
-                         (text::TextContentAnchorType_AS_CHARACTER));
-                    xShapeProps->setPropertyValue
-                        (rPropNameSupplier.GetName(PROP_TEXT_RANGE),
-                         uno::makeAny
-                         (m_pImpl->rDomainMapper.GetCurrentTextRange()));
-
-                    awt::Point aPoint(m_xShape->getPosition());
-                    awt::Size aSize(m_xShape->getSize());
-
-                    if (m_pImpl->isXSizeValid())
-                        aSize.Width = m_pImpl->getXSize();
-                    if (m_pImpl->isYSizeValis())
-                        aSize.Height = m_pImpl->getYSize();
-
-                    m_xShape->setSize(aSize);
-
-                    m_pImpl->bIsGraphic = true;
+                uno::Reference< drawing::XShape> xShape;
+                val.getAny( ) >>= xShape;
+
+                if ( xShape.is( ) )
+                {                
+                    // Is it a graphic image
+                    bool bUseShape = true;
+                    try
+                    {
+                        uno::Reference< beans::XPropertySet > xShapeProps
+                            ( xShape, uno::UNO_QUERY_THROW );
+    
+                        rtl::OUString sUrl;
+                        xShapeProps->getPropertyValue( rtl::OUString::createFromAscii( "GraphicURL" ) ) >>= sUrl;
+    
+                        ::com::sun::star::beans::PropertyValues aMediaProperties( 1 );
+                        aMediaProperties[0].Name = rtl::OUString::createFromAscii( "URL" );
+                        aMediaProperties[0].Value <<= sUrl;
+    
+                        m_xGraphicObject = createGraphicObject( aMediaProperties );
+    
+                        bUseShape = !m_xGraphicObject.is( );
+
+                        if ( !bUseShape )
+                        {
+                            // Define the object size
+                            uno::Reference< beans::XPropertySet > xGraphProps( m_xGraphicObject, 
+                                    uno::UNO_QUERY );
+                            awt::Size aSize = xShape->getSize( );
+                            xGraphProps->setPropertyValue( rtl::OUString::createFromAscii( "Height" ),
+                                   uno::makeAny( aSize.Height ) );
+                            xGraphProps->setPropertyValue( rtl::OUString::createFromAscii( "Width" ),
+                                   uno::makeAny( aSize.Width ) );
+                        }
+                    }
+                    catch( const beans::UnknownPropertyException e )
+                    {
+                        // It isn't a graphic image
+                    }
+    
+                    if ( bUseShape )
+                        m_xShape = xShape;
+
+                   
+                    if ( m_xShape.is( ) )
+                    { 
+                        uno::Reference< beans::XPropertySet > xShapeProps
+                            (m_xShape, uno::UNO_QUERY_THROW);
+                     
+    
+                        PropertyNameSupplier& rPropNameSupplier = 
+                            PropertyNameSupplier::GetPropertyNameSupplier();
+                        xShapeProps->setPropertyValue
+                            (rPropNameSupplier.GetName(PROP_ANCHOR_TYPE),
+                             uno::makeAny
+                             (text::TextContentAnchorType_AS_CHARACTER));
+                        xShapeProps->setPropertyValue
+                            (rPropNameSupplier.GetName(PROP_TEXT_RANGE),
+                             uno::makeAny
+                             (m_pImpl->rDomainMapper.GetCurrentTextRange()));
+    
+                        awt::Point aPoint(m_xShape->getPosition());
+                        awt::Size aSize(m_xShape->getSize());
+    
+                        if (m_pImpl->isXSizeValid())
+                            aSize.Width = m_pImpl->getXSize();
+                        if (m_pImpl->isYSizeValis())
+                            aSize.Height = m_pImpl->getYSize();
+    
+                        m_xShape->setSize(aSize);
+    
+                        m_pImpl->bIsGraphic = true;
+                    }
                 }
             }
         break;
@@ -1769,8 +1815,6 @@ void GraphicImport::sprm(Sprm & rSprm)
         case NS_ooxml::LN_CT_NonVisualGraphicFrameProperties_graphicFrameLocks:// 90657
         case NS_ooxml::LN_CT_Inline_a_graphic:// 90915
         case NS_ooxml::LN_CT_Anchor_simplePos_elem: // 90975;
-        case NS_ooxml::LN_CT_Anchor_positionH: // 90976;
-        case NS_ooxml::LN_CT_Anchor_positionV: // 90977;
         case NS_ooxml::LN_CT_Anchor_extent: // 90978;
         case NS_ooxml::LN_CT_Anchor_effectExtent: // 90979;
         case NS_ooxml::LN_EG_WrapType_wrapSquare: // 90945;                   
@@ -1791,6 +1835,36 @@ void GraphicImport::sprm(Sprm & rSprm)
             }
         }
         break;
+        case NS_ooxml::LN_CT_Anchor_positionH: // 90976;
+        {
+            // Use a special handler for the positionning
+            PositionHandlerPtr pHandler( new PositionHandler );
+            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            if( pProperties.get( ) )
+            {
+                pProperties->resolve( *pHandler );
+
+                m_pImpl->nHoriRelation = pHandler->m_nRelation;
+                m_pImpl->nHoriOrient = pHandler->m_nOrient;
+                m_pImpl->nLeftPosition = pHandler->m_nPosition;
+            }
+        }
+        break;
+        case NS_ooxml::LN_CT_Anchor_positionV: // 90977;
+        {
+            // Use a special handler for the positionning
+            PositionHandlerPtr pHandler( new PositionHandler );
+            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            if( pProperties.get( ) )
+            {
+                pProperties->resolve( *pHandler );
+
+                m_pImpl->nVertRelation = pHandler->m_nRelation;
+                m_pImpl->nVertOrient = pHandler->m_nOrient;
+                m_pImpl->nTopPosition = pHandler->m_nPosition;
+            }
+        }
+        break;
         case 0x271b:
         case 0x271c:
         {
@@ -1858,11 +1932,9 @@ void lcl_CalcCrop( sal_Int32& nCrop, sal_Int32 nRef )
        + (((nCrop & 0xffff) * nRef ) >> 16);
 }
 
-/*-- 01.11.2006 09:45:02---------------------------------------------------
-
-  -----------------------------------------------------------------------*/
-void GraphicImport::data(const sal_uInt8* buf, size_t len, writerfilter::Reference<Properties>::Pointer_t /*ref*/)
+uno::Reference< text::XTextContent > GraphicImport::createGraphicObject( const beans::PropertyValues& aMediaProperties )
 {
+    uno::Reference< text::XTextContent > xGraphicObject;
     try
     {
         uno::Reference< graphic::XGraphicProvider > xGraphicProvider(
@@ -1870,28 +1942,22 @@ void GraphicImport::data(const sal_uInt8* buf, size_t len, writerfilter::Referen
                                 ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.graphic.GraphicProvider")),
                                 m_xComponentContext),
                             uno::UNO_QUERY_THROW );
-        uno::Reference< io::XInputStream > xIStream = new XInputStreamHelper( buf, len, m_pImpl->bIsBitmap );
-
-        PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-
-        ::com::sun::star::beans::PropertyValues aMediaProperties( 1 );
-        aMediaProperties[0].Name = rPropNameSupplier.GetName(PROP_INPUT_STREAM);
-        aMediaProperties[0].Value <<= xIStream;
+        
         uno::Reference< graphic::XGraphic > xGraphic = xGraphicProvider->queryGraphic( aMediaProperties );
-        //
+
         if(xGraphic.is())
         {
-            clog << "Graphic loaded" << endl;
+            PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
 
             uno::Reference< beans::XPropertySet > xGraphicObjectProperties(
             m_xTextFactory->createInstance(::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextGraphicObject"))),
-            uno::UNO_QUERY_THROW);
+                uno::UNO_QUERY_THROW);
             xGraphicObjectProperties->setPropertyValue(rPropNameSupplier.GetName(PROP_GRAPHIC), uno::makeAny( xGraphic ));
             xGraphicObjectProperties->setPropertyValue(rPropNameSupplier.GetName(PROP_ANCHOR_TYPE),
                 uno::makeAny( m_pImpl->eGraphicImportType == IMPORT_AS_SHAPE || m_pImpl->eGraphicImportType == IMPORT_AS_DETECTED_ANCHOR ?
                                     text::TextContentAnchorType_AT_CHARACTER :
                                     text::TextContentAnchorType_AS_CHARACTER ));
-            m_xGraphicObject = uno::Reference< text::XTextContent >( xGraphicObjectProperties, uno::UNO_QUERY_THROW );
+            xGraphicObject = uno::Reference< text::XTextContent >( xGraphicObjectProperties, uno::UNO_QUERY_THROW );
 
             //shapes have only one border, PICF might have four
             table::BorderLine aBorderLine;
@@ -2083,11 +2149,28 @@ void GraphicImport::data(const sal_uInt8* buf, size_t len, writerfilter::Referen
             }    
         }
     }
-    catch( const uno::Exception& )
+    catch( const uno::Exception& e )
     {
-        clog << __FILE__ << __LINE__ << " failed!" << endl;
+        clog << __FILE__ << ":" << __LINE__ << " failed. Message :" ;
+        clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( )  << endl;
     }
+    return xGraphicObject;
+}
+
+/*-- 01.11.2006 09:45:02---------------------------------------------------
 
+  -----------------------------------------------------------------------*/
+void GraphicImport::data(const sal_uInt8* buf, size_t len, writerfilter::Reference<Properties>::Pointer_t /*ref*/)
+{
+        PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+        ::com::sun::star::beans::PropertyValues aMediaProperties( 1 );
+        aMediaProperties[0].Name = rPropNameSupplier.GetName(PROP_INPUT_STREAM);
+        
+        uno::Reference< io::XInputStream > xIStream = new XInputStreamHelper( buf, len, m_pImpl->bIsBitmap );
+        aMediaProperties[0].Value <<= xIStream;
+
+        m_xGraphicObject = createGraphicObject( aMediaProperties );
 }
 /*-- 01.11.2006 09:45:03---------------------------------------------------
 
@@ -2161,6 +2244,15 @@ void GraphicImport::substream(Id /*name*/, ::writerfilter::Reference<Stream>::Po
 void GraphicImport::info(const string & /*info*/)
 {
 }
+    
+void GraphicImport::startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > /*xShape*/ )
+{
+}
+
+void GraphicImport::endShape( )
+{
+}
+
 /*-- 09.08.2007 10:17:00---------------------------------------------------
 
   -----------------------------------------------------------------------*/
diff --git writerfilter/source/dmapper/GraphicImport.hxx writerfilter/source/dmapper/GraphicImport.hxx
index 99daac9..6ff1c3f 100644
--- writerfilter/source/dmapper/GraphicImport.hxx
+++ writerfilter/source/dmapper/GraphicImport.hxx
@@ -51,6 +51,11 @@ namespace com{ namespace sun { namespace star {
     {
         class XShape;
     }
+    namespace beans
+    {
+        class PropertyValue;
+        typedef ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > PropertyValues;
+    }
 }}}
 
 namespace writerfilter {
@@ -79,6 +84,9 @@ class WRITERFILTER_DLLPRIVATE GraphicImport : public Properties, public Table
 
     ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape> m_xShape;
     void ProcessShapeOptions(Value & val);
+    
+    ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent > createGraphicObject( 
+            const ::com::sun::star::beans::PropertyValues& aMediaProperties );
 
 public:
     explicit GraphicImport(::com::sun::star::uno::Reference < ::com::sun::star::uno::XComponentContext >    xComponentContext,
@@ -112,6 +120,8 @@ public:
     virtual void substream(Id name,
                            ::writerfilter::Reference<Stream>::Pointer_t ref);
     virtual void info(const string & info);
+    virtual void startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual void endShape( );
 
     ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent > GetGraphicObject();
     bool    IsGraphic() const;
diff --git writerfilter/source/dmapper/ListTable.cxx writerfilter/source/dmapper/ListTable.cxx
index e965cf8..4255104 100644
--- writerfilter/source/dmapper/ListTable.cxx
+++ writerfilter/source/dmapper/ListTable.cxx
@@ -38,9 +38,12 @@
 #include <resourcemodel/WW8ResourceModel.hxx>
 #endif
 #include <com/sun/star/container/XIndexReplace.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/style/NumberingType.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/PositionAndSpaceMode.hpp>
 #include <vector>
 
 #define NUMBERING_MAX_LEVELS    10
@@ -139,6 +142,7 @@ class ListPropertyMap : public PropertyMap
     ::rtl::OUString                                 sRGBXchNums;     //LN_RGBXCHNUMS
     sal_Int32                                       nXChFollow;      //LN_IXCHFOLLOW
     ::rtl::OUString                                 sBulletChar;
+    sal_Int32                                       nTabstop;
 public:
     ListPropertyMap() :
         nIStartAt(-1)
@@ -150,6 +154,7 @@ public:
         ,nFPrevSpace(-1)
         ,nFWord6(-1)
         ,nXChFollow(-1)
+        ,nTabstop( 0 )
         {}
     ~ListPropertyMap(){}
 
@@ -187,6 +192,8 @@ uno::Sequence< beans::PropertyValue >  ListPropertyMap::GetPropertyValuesList( P
     if( nNumberFormat == style::NumberingType::CHAR_SPECIAL && sBulletChar.getLength() )
         aNumberingProperties.push_back( MAKE_PROPVAL(PROP_BULLET_CHAR, sBulletChar.copy(0,1)));
 
+    aNumberingProperties.push_back( MAKE_PROPVAL( PROP_LISTTAB_STOP_POSITION, nTabstop ) );
+
     //TODO: handling of nFLegal?
     //TODO: nFNoRestart lower levels do not restart when higher levels are incremented, like:
     //1.
@@ -215,6 +222,9 @@ uno::Sequence< beans::PropertyValue >  ListPropertyMap::GetPropertyValuesList( P
         {
             switch( aMapIter->first.eId )
             {
+                case PROP_ADJUST:
+                case PROP_INDENT_AT:
+                case PROP_FIRST_LINE_INDENT:
                 case PROP_FIRST_LINE_OFFSET:
                 case PROP_LEFT_MARGIN:
                     aNumberingProperties.push_back(
@@ -818,22 +828,27 @@ void ListTable::attribute(Id nName, Value & rVal)
         case NS_ooxml::LN_CT_Ind_left:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_LEFT_MARGIN, true, uno::makeAny( ConversionHelper::convertTwipToMM100(nIntValue ) ));
+                PROP_INDENT_AT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
             break;
         case NS_ooxml::LN_CT_Ind_hanging:
             /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
             m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-                PROP_FIRST_LINE_OFFSET, true, uno::makeAny( - ConversionHelper::convertTwipToMM100(nIntValue ) ));
+                PROP_FIRST_LINE_INDENT, true, uno::makeAny( - ConversionHelper::convertTwipToMM100( nIntValue ) ));
+        break;
+        case NS_ooxml::LN_CT_Ind_firstLine:
+            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
+            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
+                PROP_FIRST_LINE_INDENT, true, uno::makeAny( ConversionHelper::convertTwipToMM100( nIntValue ) ));
         break;
-//        case NS_ooxml::LN_CT_Ind_firstLine:
-//            /* WRITERFILTERSTATUS: done: 100, planned: 0.5, spent: 0 */
-//            m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert(
-//                PROP_FIRST_LINE_OFFSET, true, uno::makeAny( ConversionHelper::convertTwipToMM100(nIntValue ) ));
-//        break;
         case NS_ooxml::LN_CT_Lvl_ilvl: //overrides previous level - unsupported
         case NS_ooxml::LN_CT_Lvl_tplc: //template code - unsupported
         case NS_ooxml::LN_CT_Lvl_tentative: //marks level as unused in the document - unsupported
-        case NS_ooxml::LN_CT_Ind_firstLine: //todo: first line indent in numbering not yet supported
+        break;
+        case NS_ooxml::LN_CT_TabStop_pos:
+        {
+            //no paragraph attributes in ListTable char style sheets
+            m_pImpl->m_pCurrentEntry->pCurrentProperties->nTabstop = ConversionHelper::convertTwipToMM100( nIntValue );
+        }
         break;
         default:
         {
@@ -955,7 +970,17 @@ void ListTable::sprm(Sprm & rSprm)
             }
             break;
             case NS_ooxml::LN_CT_Lvl_lvlJc:
-                //todo: ????
+            {
+                static sal_Int16 aWWAlignments[ ] = 
+                {
+                    text::HoriOrientation::LEFT,
+                    text::HoriOrientation::CENTER,
+                    text::HoriOrientation::RIGHT
+                };
+                m_pImpl->m_pCurrentEntry->pCurrentProperties->Insert( 
+                    PROP_ADJUST, true, uno::makeAny( aWWAlignments[ nIntValue ] ) );
+                    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            }
             break;
             case NS_ooxml::LN_CT_Lvl_pPr:
             case NS_ooxml::LN_CT_PPrBase_ind:
@@ -967,7 +992,12 @@ void ListTable::sprm(Sprm & rSprm)
             }
             break;
             case NS_ooxml::LN_CT_PPrBase_tabs:
-                //no paragraph attributes in ListTable char style sheets
+            case NS_ooxml::LN_CT_Tabs_tab:
+            {
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if(pProperties.get())
+                    pProperties->resolve(*this);
+            }
             break;
             case NS_ooxml::LN_CT_Lvl_suff:
                 //todo: currently unsupported suffix 
@@ -1057,105 +1087,181 @@ sal_uInt32 ListTable::size() const
 {
     return m_pImpl->m_aListEntries.size();
 }
-/*-- 26.06.2006 10:33:56---------------------------------------------------
 
-  -----------------------------------------------------------------------*/
-uno::Reference< container::XIndexReplace > ListTable::GetNumberingRules(sal_Int32 nListId)
+rtl::OUString ListTable::GetStyleName( sal_Int32 nListId )
+{
+    rtl::OUString sStyleName( rtl::OUString::createFromAscii( "WWNum" ) );
+    sStyleName += rtl::OUString::valueOf( nListId + 1 );
+
+    return sStyleName;
+}
+
+void ListTable::CreateNumberingRules( )
 {
     uno::Reference< container::XIndexReplace > xRet;
     std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
     std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
+    
+    uno::Reference< container::XNameContainer > xStyles;
+
+    try
+    {
+        uno::Reference< style::XStyleFamiliesSupplier > xFamilies( m_pImpl->m_xFactory, uno::UNO_QUERY_THROW );
+        uno::Any oFamily = xFamilies->getStyleFamilies( )->getByName( rtl::OUString::createFromAscii( "NumberingStyles" ) );
+
+        oFamily >>= xStyles;
+    }
+    catch ( const uno::Exception )
+    {
+    }
+
     for(; aIt != aEndIt; ++aIt)
     {
-        if((*aIt)->nListId == nListId)
+        if( !(*aIt)->m_xNumRules.is() && m_pImpl->m_xFactory.is() && xStyles.is( ) )
         {
-            if( !(*aIt)->m_xNumRules.is() && m_pImpl->m_xFactory.is())
+            try
             {
-                try
+                // Create the numbering style
+                uno::Reference< beans::XPropertySet > xStyle (
+                    m_pImpl->m_xFactory->createInstance(
+                        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.NumberingStyle"))),
+                    uno::UNO_QUERY_THROW );
+
+                rtl::OUString sStyleName = GetStyleName( ( *aIt )->nListId );
+#if DEBUG
+                clog << "Creating numbering style: ";
+                clog << rtl::OUStringToOString( sStyleName, RTL_TEXTENCODING_UTF8 ).getStr( );
+                clog << endl;
+#endif
+
+                xStyles->insertByName( sStyleName, makeAny( xStyle ) );
+                
+                uno::Any oStyle = xStyles->getByName( sStyleName );
+                xStyle.set( oStyle, uno::UNO_QUERY_THROW );
+                
+                PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+                uno::Any aRules = xStyle->getPropertyValue( aPropNameSupplier.GetName( PROP_NUMBERING_RULES ) );
+                aRules >>= ( *aIt )->m_xNumRules;
+
+                //now fill the numbering levels appropriately
+                ::std::vector< ListPropertyMapPtr >::const_iterator aIter = (*aIt)->aLevelProperties.begin();
+                ::std::vector< ListPropertyMapPtr >::const_iterator aEnd = (*aIt)->aLevelProperties.end();
+                sal_Int32 nLevel = 0;
+                while(aIter != aEnd)
                 {
-                    (*aIt)->m_xNumRules = uno::Reference< container::XIndexReplace >(
-                            m_pImpl->m_xFactory->createInstance(::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.NumberingRules"))),
-                            uno::UNO_QUERY_THROW);
-
-                    //now fill the numbering levels appropriately
-                    ::std::vector< ListPropertyMapPtr >::const_iterator aIter = (*aIt)->aLevelProperties.begin();
-                    ::std::vector< ListPropertyMapPtr >::const_iterator aEnd = (*aIt)->aLevelProperties.end();
-                    sal_Int32 nLevel = 0;
-                    PropertyNameSupplier& aPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
-                    while(aIter != aEnd)
+                    PropertyValueVector_t aCharStyleProperties;
+                    uno::Sequence< beans::PropertyValue> aValues = (*aIter)->GetPropertyValuesList(aCharStyleProperties);
+                    if( aCharStyleProperties.size() )
                     {
-                        PropertyValueVector_t aCharStyleProperties;
-                        uno::Sequence< beans::PropertyValue> aValues = (*aIter)->GetPropertyValuesList(aCharStyleProperties);
-                        if( aCharStyleProperties.size() )
-                        {
-                            //create (or find) a character style containing the character attributes of the symbol
-                            //and apply it to the numbering level
-                            ::rtl::OUString sStyle = m_pImpl->m_rDMapper.getOrCreateCharStyle( aCharStyleProperties );
-                            aValues.realloc( aValues.getLength() + 1);
-                            aValues[aValues.getLength() - 1].Name = aPropNameSupplier.GetName( PROP_CHAR_STYLE_NAME );
-                            aValues[aValues.getLength() - 1].Value <<= sStyle;
-                        }    
-                        //now parse the text to find %n from %1 to %nLevel+1
-                        //everything before the first % and the last %x is prefix and suffix
-                        ::rtl::OUString sLevelText( (*aIter)->sBulletChar );
-                        sal_Int32 nCurrentIndex = 0;
-                        sal_Int32 nFound = sLevelText.indexOf( '%', nCurrentIndex );
-                        if( nFound > 0 )
-                        {
-                            ::rtl::OUString sPrefix = sLevelText.copy( 0, nFound );
-                            aValues.realloc( aValues.getLength() + 1 );
-                            aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_PREFIX, sPrefix);
-                            sLevelText = sLevelText.copy( nFound );
-                        } 
-                        sal_Int32 nMinLevel = nLevel;
-                        //now the text should either be empty or start with %
-                        nFound = 0;
-                        while( nFound >= 0 )
+                        //create (or find) a character style containing the character attributes of the symbol
+                        //and apply it to the numbering level
+                        ::rtl::OUString sStyle = m_pImpl->m_rDMapper.getOrCreateCharStyle( aCharStyleProperties );
+                        aValues.realloc( aValues.getLength() + 1);
+                        aValues[aValues.getLength() - 1].Name = aPropNameSupplier.GetName( PROP_CHAR_STYLE_NAME );
+                        aValues[aValues.getLength() - 1].Value <<= sStyle;
+                    }    
+                    //now parse the text to find %n from %1 to %nLevel+1
+                    //everything before the first % and the last %x is prefix and suffix
+                    ::rtl::OUString sLevelText( (*aIter)->sBulletChar );
+                    sal_Int32 nCurrentIndex = 0;
+                    sal_Int32 nFound = sLevelText.indexOf( '%', nCurrentIndex );
+                    if( nFound > 0 )
+                    {
+                        ::rtl::OUString sPrefix = sLevelText.copy( 0, nFound );
+                        aValues.realloc( aValues.getLength() + 1 );
+                        aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_PREFIX, sPrefix);
+                        sLevelText = sLevelText.copy( nFound );
+                    } 
+                    sal_Int32 nMinLevel = nLevel;
+                    //now the text should either be empty or start with %
+                    nFound = 0;
+                    while( nFound >= 0 )
+                    {
+                        if( sLevelText.getLength() > 1 )
                         {
-                            if( sLevelText.getLength() > 1 )
+                            sal_Unicode cLevel = sLevelText.getStr()[1];
+                            if( cLevel >= '1' && cLevel <= '9' )
                             {
-                                sal_Unicode cLevel = sLevelText.getStr()[1];
-                                if( cLevel >= '1' && cLevel <= '9' )
-                                {
-                                    if( cLevel - '1' < nMinLevel )
-                                        nMinLevel = cLevel - '1';
-                                    //remove first char - next char is removed later
-                                    sLevelText = sLevelText.copy( 1 );
-                                }
-                            }    
-                            //remove old '%' or number 
-                            sLevelText = sLevelText.copy( 1 );
-                            nCurrentIndex = 0;
-                            nFound = sLevelText.indexOf( '%', nCurrentIndex );
-                            //remove the text before the next %
-                            if(nFound > 0)
-                                sLevelText = sLevelText.copy( nFound -1 );
-                        }
-                        if( nMinLevel < nLevel )
-                        {
-                            aValues.realloc( aValues.getLength() + 1);
-                            aValues[ aValues.getLength() - 1 ] = 
-                                MAKE_PROPVAL(PROP_PARENT_NUMBERING, sal_Int16( nLevel - nMinLevel ));
-                        }
-                        if( sLevelText.getLength() ) 
-                        {
-                            aValues.realloc( aValues.getLength() + 1);
-                            aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_SUFFIX, sLevelText);
+                                if( cLevel - '1' < nMinLevel )
+                                    nMinLevel = cLevel - '1';
+                                //remove first char - next char is removed later
+                                sLevelText = sLevelText.copy( 1 );
+                            }
                         }    
-
-                        (*aIt)->m_xNumRules->replaceByIndex(nLevel, uno::makeAny(aValues));
-
-                        ++aIter;
-                        ++nLevel;
+                        //remove old '%' or number 
+                        sLevelText = sLevelText.copy( 1 );
+                        nCurrentIndex = 0;
+                        nFound = sLevelText.indexOf( '%', nCurrentIndex );
+                        //remove the text before the next %
+                        if(nFound > 0)
+                            sLevelText = sLevelText.copy( nFound -1 );
+                    }
+                    if( nMinLevel < nLevel )
+                    {
+                        aValues.realloc( aValues.getLength() + 1);
+                        aValues[ aValues.getLength() - 1 ] = 
+                            MAKE_PROPVAL(PROP_PARENT_NUMBERING, sal_Int16( nLevel - nMinLevel + 1));
                     }
+                    aValues.realloc( aValues.getLength() + 1);
+                    aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL(PROP_SUFFIX, sLevelText);
 
-                }
-                catch( const uno::Exception& rEx)
+                    aValues.realloc( aValues.getLength() + 1);
+                    aValues[ aValues.getLength() - 1 ] = MAKE_PROPVAL( PROP_POSITION_AND_SPACE_MODE, 
+                            sal_Int16( text::PositionAndSpaceMode::LABEL_ALIGNMENT ) );
+                    
+#if DEBUG
+                clog << endl << "Numbering rule properties - " << nLevel << endl;
+                for ( sal_Int32 i = 0, len = aValues.getLength( ); i < len; i++ )
                 {
-                    (void)rEx;
-                    OSL_ENSURE( false, "ListTable::GetNumberingRules");
+                    beans::PropertyValue aVal = aValues[i];
+                    clog << "    " << rtl::OUStringToOString( aVal.Name, RTL_TEXTENCODING_UTF8 ).getStr( );
+                    clog << ": ";
+                    rtl::OUString sVal;
+                    sal_Int32 nVal;
+                    if ( aVal.Value >>= sVal )
+                    {
+                        clog << rtl::OUStringToOString( sVal, RTL_TEXTENCODING_UTF8 ).getStr( );
+                    }
+                    else if ( aVal.Value >>= nVal )
+                    {
+                        clog << nVal;
+                    }
+                    clog << endl;
+                }
+#endif
+
+                    (*aIt)->m_xNumRules->replaceByIndex(nLevel, uno::makeAny(aValues));
+                    ++aIter;
+                    ++nLevel;
                 }
+            
+                // Create the numbering style for these rules 
+                rtl::OUString sNumRulesName = aPropNameSupplier.GetName( PROP_NUMBERING_RULES );
+                xStyle->setPropertyValue( 
+                        sNumRulesName, 
+                        uno::makeAny( ( *aIt )->m_xNumRules ) );
             }
+            catch( const uno::Exception& rEx)
+            {
+                (void)rEx;
+                OSL_ENSURE( false, "ListTable::CreateNumberingRules");
+            }
+        }
+    }
+}
+
+/*-- 26.06.2006 10:33:56---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+uno::Reference< container::XIndexReplace > ListTable::GetNumberingRules(sal_Int32 nListId)
+{
+    uno::Reference< container::XIndexReplace > xRet;
+    std::vector< ListEntryPtr >::const_iterator aIt = m_pImpl->m_aListEntries.begin();
+    std::vector< ListEntryPtr >::const_iterator aEndIt = m_pImpl->m_aListEntries.end();
+    for(; aIt != aEndIt; ++aIt)
+    {
+        if((*aIt)->nListId == nListId)
+        {
             xRet = (*aIt)->m_xNumRules;
             break;
         }
diff --git writerfilter/source/dmapper/ListTable.hxx writerfilter/source/dmapper/ListTable.hxx
index c42515a..65cc216 100644
--- writerfilter/source/dmapper/ListTable.hxx
+++ writerfilter/source/dmapper/ListTable.hxx
@@ -78,6 +78,8 @@ public:
 //                      writerfilter::Reference<Properties>::Pointer_t ref);
 
     sal_uInt32          size() const;
+    rtl::OUString GetStyleName( sal_Int32 nListId );
+    void CreateNumberingRules( );
     ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexReplace >
             GetNumberingRules(sal_Int32 nListId);
 
diff --git writerfilter/source/dmapper/OLEHandler.cxx writerfilter/source/dmapper/OLEHandler.cxx
index 48ae2fe..9a70000 100644
--- writerfilter/source/dmapper/OLEHandler.cxx
+++ writerfilter/source/dmapper/OLEHandler.cxx
@@ -29,6 +29,8 @@
  ************************************************************************/
 #include <OLEHandler.hxx>
 #include <PropertyMap.hxx>
+#include "GraphicHelpers.hxx"
+
 #include <doctok/resourceids.hxx>
 #include <ooxml/resourceids.hxx>
 #include <com/sun/star/beans/PropertyValue.hpp>
@@ -54,7 +56,8 @@ using namespace ::com::sun::star;
   -----------------------------------------------------------------------*/
 OLEHandler::OLEHandler() :
     m_nDxaOrig(0),
-    m_nDyaOrig(0)
+    m_nDyaOrig(0),
+    m_nWrapMode(0)
 {
 }
 /*-- 23.04.2008 10:46:14---------------------------------------------------
@@ -108,15 +111,28 @@ void OLEHandler::attribute(Id rName, Value & rVal)
             rVal.getAny() >>= xTempShape;
             if( xTempShape.is() )
             {
-                m_aShapeSize = xTempShape->getSize();
-                m_aShapePosition = xTempShape->getPosition();
+                m_xShape.set( xTempShape );
+                
                 try
                 {
+                    m_aShapeSize = xTempShape->getSize();
+                    m_aShapePosition = xTempShape->getPosition();
+
                     uno::Reference< beans::XPropertySet > xShapeProps( xTempShape, uno::UNO_QUERY_THROW );
-                    xShapeProps->getPropertyValue( PropertyNameSupplier::GetPropertyNameSupplier().GetName( PROP_BITMAP ) ) >>= m_xReplacement;
+                    PropertyNameSupplier& rNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+                    xShapeProps->getPropertyValue( rNameSupplier.GetName( PROP_BITMAP ) ) >>= m_xReplacement;
+               
+                    xShapeProps->setPropertyValue( 
+                        rNameSupplier.GetName( PROP_SURROUND ),
+                        uno::makeAny( m_nWrapMode ) );
                 }
-                catch( const uno::Exception& )
+                catch( const uno::Exception& e )
                 {
+#if DEBUG
+                    clog << "Exception in OLE Handler: ";
+                    clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
                 }    
             }
         }
@@ -142,8 +158,39 @@ void OLEHandler::sprm(Sprm & rSprm)
             }
         }
         break;
+        case NS_ooxml::LN_wrap_wrap:
+        {
+            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            if ( pProperties.get( ) )
+            {
+                WrapHandlerPtr pHandler( new WrapHandler );
+                pProperties->resolve( *pHandler );
+
+                m_nWrapMode = pHandler->getWrapMode( );
+
+                try
+                { 
+                    uno::Reference< beans::XPropertySet > xShapeProps( m_xShape, uno::UNO_QUERY_THROW );
+                    PropertyNameSupplier& rNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
+
+                    xShapeProps->setPropertyValue( 
+                        rNameSupplier.GetName( PROP_SURROUND ),
+                        uno::makeAny( m_nWrapMode ) );
+                }
+                catch( const uno::Exception& e )
+                {
+#if DEBUG
+                    clog << "Exception in OLE Handler: ";
+                    clog << rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr( ) << endl;
+#endif
+                } 
+            }
+        }
+        break;
         default:
+        {
             OSL_ENSURE( false, "unknown attribute");
+        }
     }
 }
 /*-- 23.04.2008 11:15:19---------------------------------------------------
@@ -152,9 +199,10 @@ void OLEHandler::sprm(Sprm & rSprm)
 ::rtl::OUString OLEHandler::copyOLEOStream( uno::Reference< text::XTextDocument > xTextDocument )
 {
     ::rtl::OUString sRet;
-    if( !m_xInputStream.is() )
+    if( !m_xInputStream.is( ) )
         return sRet;
-    try{
+    try
+    {
         uno::Reference < lang::XMultiServiceFactory > xFactory(xTextDocument, uno::UNO_QUERY_THROW);
         uno::Reference< document::XEmbeddedObjectResolver > xEmbeddedResolver(
             xFactory->createInstance(
diff --git writerfilter/source/dmapper/OLEHandler.hxx writerfilter/source/dmapper/OLEHandler.hxx
index c56358a..d65035f 100644
--- writerfilter/source/dmapper/OLEHandler.hxx
+++ writerfilter/source/dmapper/OLEHandler.hxx
@@ -38,6 +38,8 @@
 #include <com/sun/star/awt/Size.hpp>
 #include <com/sun/star/awt/Point.hpp>
 
+#include <com/sun/star/drawing/XShape.hpp>
+
 namespace com{ namespace sun{ namespace star{
     namespace embed{
         class XEmbeddedObject;
@@ -72,6 +74,9 @@ class WRITERFILTER_DLLPRIVATE OLEHandler : public Properties
 
     sal_Int32                   m_nDxaOrig;
     sal_Int32                   m_nDyaOrig;
+    sal_Int32                   m_nWrapMode;
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > m_xShape;
 
     ::com::sun::star::awt::Size m_aShapeSize;
     ::com::sun::star::awt::Point m_aShapePosition;
@@ -87,6 +92,10 @@ public:
     virtual void attribute(Id Name, Value & val);
     virtual void sprm(Sprm & sprm);
 
+    inline ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > getShape( ) { return m_xShape; };
+
+    inline bool isOLEObject( ) { return m_xInputStream.is( ); };
+
     ::rtl::OUString copyOLEOStream( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextDocument > xTextDocument );
 
     ::com::sun::star::awt::Size     getSize() const { return m_aShapeSize;}
diff --git writerfilter/source/dmapper/PageBordersHandler.cxx writerfilter/source/dmapper/PageBordersHandler.cxx
new file mode 100644
index 0000000..5280697
--- /dev/null
+++ writerfilter/source/dmapper/PageBordersHandler.cxx
@@ -0,0 +1,121 @@
+#include "PageBordersHandler.hxx"
+
+#include <ooxml/resourceids.hxx>
+
+namespace writerfilter {
+namespace dmapper {
+
+_PgBorder::_PgBorder( ) :
+    m_nDistance( 0 ),
+    m_ePos( BORDER_RIGHT )
+{
+}
+
+_PgBorder::~_PgBorder( )
+{
+}
+
+PageBordersHandler::PageBordersHandler( ) :
+    m_nDisplay( 0 ),
+    m_nOffset( 0 )
+{
+}
+
+PageBordersHandler::~PageBordersHandler( )
+{
+}
+
+void PageBordersHandler::attribute( Id eName, Value& rVal )
+{
+    int nIntValue = rVal.getInt( );
+    switch ( eName )
+    {
+        case NS_ooxml::LN_CT_PageBorders_display:
+        {
+            switch ( nIntValue )
+            {
+                default:
+                case NS_ooxml::LN_Value_wordprocessingml_ST_PageBorderDisplay_allPages:
+                    m_nDisplay = 0;
+                    break;
+                case NS_ooxml::LN_Value_wordprocessingml_ST_PageBorderDisplay_firstPage:
+                    m_nDisplay = 1;
+                    break;
+                case NS_ooxml::LN_Value_wordprocessingml_ST_PageBorderDisplay_notFirstPage:
+                    m_nDisplay = 2;
+                    break;
+            }
+        }
+        break;
+        case NS_ooxml::LN_CT_PageBorders_offsetFrom:
+        {
+            switch ( nIntValue )
+            {
+                default:
+                case NS_ooxml::LN_Value_wordprocessingml_ST_PageBorderOffset_page:
+                    m_nOffset = 1;
+                    break;
+                case NS_ooxml::LN_Value_wordprocessingml_ST_PageBorderOffset_text:
+                    m_nOffset = 0;
+                    break;
+            }
+        }
+        break;
+        default:;
+    }
+}
+
+void PageBordersHandler::sprm( Sprm& rSprm )
+{
+    switch ( rSprm.getId( ) )
+    {
+        case NS_ooxml::LN_CT_PageBorders_top:
+        case NS_ooxml::LN_CT_PageBorders_left:
+        case NS_ooxml::LN_CT_PageBorders_bottom:
+        case NS_ooxml::LN_CT_PageBorders_right:
+        {
+            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            if( pProperties.get())
+            {
+                BorderHandlerPtr pBorderHandler( new BorderHandler( true ) );
+                pProperties->resolve(*pBorderHandler);
+                BorderPosition ePos = BorderPosition( 0 );
+                switch( rSprm.getId( ) )
+                {
+                    case NS_ooxml::LN_CT_PageBorders_top:
+                        ePos = BORDER_TOP;
+                    break;
+                    case NS_ooxml::LN_CT_PageBorders_left:
+                        ePos = BORDER_LEFT;
+                    break;
+                    case NS_ooxml::LN_CT_PageBorders_bottom:
+                        ePos = BORDER_BOTTOM;
+                    break;
+                    case NS_ooxml::LN_CT_PageBorders_right:
+                        ePos = BORDER_RIGHT;
+                    break;
+                    default:;
+                }
+                
+                _PgBorder aPgBorder;
+                aPgBorder.m_rLine = pBorderHandler->getBorderLine( );
+                aPgBorder.m_nDistance = pBorderHandler->getLineDistance( );
+                aPgBorder.m_ePos = ePos;
+                m_aBorders.push_back( aPgBorder );
+            }
+        }
+        break;
+        default:;
+    }
+}
+
+void PageBordersHandler::SetBorders( SectionPropertyMap* pSectContext )
+{
+    for ( int i = 0, length = m_aBorders.size( ); i < length; i++ )
+    {
+        _PgBorder aBorder = m_aBorders[i];
+        pSectContext->SetBorder( aBorder.m_ePos, aBorder.m_nDistance, aBorder.m_rLine );
+    }
+}
+
+} }
diff --git writerfilter/source/dmapper/PageBordersHandler.hxx writerfilter/source/dmapper/PageBordersHandler.hxx
new file mode 100644
index 0000000..5f501d2
--- /dev/null
+++ writerfilter/source/dmapper/PageBordersHandler.hxx
@@ -0,0 +1,58 @@
+#ifndef INCLUDED_PAGEBORDERSHANDLER_HXX
+#define INCLUDED_PAGEBORDERSHANDLER_HXX
+
+#include "BorderHandler.hxx"
+#include "PropertyMap.hxx"
+
+#include <WriterFilterDllApi.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+#include <boost/shared_ptr.hpp>
+
+#include <com/sun/star/table/BorderLine.hpp>
+
+#include <vector>
+
+using namespace std;
+
+namespace writerfilter {
+namespace dmapper {
+
+class _PgBorder
+{
+public:
+    com::sun::star::table::BorderLine m_rLine;
+    sal_Int32   m_nDistance;
+    BorderPosition m_ePos;
+
+    _PgBorder( );
+    ~_PgBorder( );
+};
+
+class WRITERFILTER_DLLPRIVATE PageBordersHandler : public Properties
+{
+private:
+
+    // See implementation of SectionPropertyMap::ApplyBorderToPageStyles
+    sal_Int32 m_nDisplay;
+    sal_Int32 m_nOffset;
+    vector<_PgBorder> m_aBorders;
+
+public:
+    PageBordersHandler( );
+    ~PageBordersHandler( );
+
+    // Properties
+    virtual void attribute( Id eName, Value& rVal );
+    virtual void sprm( Sprm& rSprm );
+
+    inline sal_Int32 GetDisplayOffset( ) 
+    { 
+        return ( m_nOffset << 5 ) + m_nDisplay;
+    };
+    void SetBorders( SectionPropertyMap* pSectContext );
+};
+typedef boost::shared_ptr< PageBordersHandler > PageBordersHandlerPtr;
+
+} }
+
+#endif
diff --git writerfilter/source/dmapper/PropertyIds.cxx writerfilter/source/dmapper/PropertyIds.cxx
index f74cb57..9e54c06 100644
--- writerfilter/source/dmapper/PropertyIds.cxx
+++ writerfilter/source/dmapper/PropertyIds.cxx
@@ -315,9 +315,13 @@ const rtl::OUString& PropertyNameSupplier::GetName( PropertyIds eId ) const
             case PROP_STREAM_NAME:    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("StreamName")); break;
             case PROP_BITMAP :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Bitmap")); break;
             case PROP_IS_DATE :   sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("IsDate")); break;
-//            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
-//            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
-//            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
+            case PROP_CNF_STYLE  :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("CnfStyle")); break;
+            case PROP_INDENT_AT :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("IndentAt")); break;
+            case PROP_FIRST_LINE_INDENT :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent")); break;
+            case PROP_NUMBERING_STYLE_NAME  :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("NumberingStyleName")); break;
+            case PROP_OUTLINE_LEVEL  :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("OutlineLevel")); break;
+            case PROP_LISTTAB_STOP_POSITION :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition")); break;
+            case PROP_POSITION_AND_SPACE_MODE :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("PositionAndSpaceMode")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
 //            case       :    sName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("")); break;
diff --git writerfilter/source/dmapper/PropertyIds.hxx writerfilter/source/dmapper/PropertyIds.hxx
index c9acac7..b46e502 100644
--- writerfilter/source/dmapper/PropertyIds.hxx
+++ writerfilter/source/dmapper/PropertyIds.hxx
@@ -278,6 +278,13 @@ enum PropertyIds
 /*239*/ ,PROP_STREAM_NAME
 /*240*/ ,PROP_BITMAP
 /*241*/ ,PROP_IS_DATE
+/*242*/ ,PROP_CNF_STYLE
+/*243*/ ,PROP_INDENT_AT
+/*244*/ ,PROP_FIRST_LINE_INDENT
+/*245*/ ,PROP_NUMBERING_STYLE_NAME
+/*246*/ ,PROP_OUTLINE_LEVEL
+/*247*/ ,PROP_LISTTAB_STOP_POSITION
+/*248*/ ,PROP_POSITION_AND_SPACE_MODE
 };
 struct PropertyNameSupplier_Impl;
 class PropertyNameSupplier
diff --git writerfilter/source/dmapper/PropertyMap.cxx writerfilter/source/dmapper/PropertyMap.cxx
index 0ca1023..01f2cf4 100644
--- writerfilter/source/dmapper/PropertyMap.cxx
+++ writerfilter/source/dmapper/PropertyMap.cxx
@@ -35,6 +35,8 @@
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/table/BorderLine.hpp>
+#include <com/sun/star/container/XEnumeration.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/style/BreakType.hpp>
 #include <com/sun/star/text/RelOrientation.hpp>
@@ -175,6 +177,7 @@ void PropertyMap::insertTableProperties( const PropertyMap* )
   -----------------------------------------------------------------------*/
 SectionPropertyMap::SectionPropertyMap(bool bIsFirstSection) :
     m_bIsFirstSection( bIsFirstSection )
+    ,m_nBorderParams( 0 )
     ,m_bTitlePage( false )
     ,m_nColumnCount( 0 )
     ,m_nColumnDistance( 1249 )
@@ -375,32 +378,21 @@ void SectionPropertyMap::ApplyBorderToPageStyles(
     sal_Int32 nOffsetFrom = (nValue & 0x00E0) >> 5;
     //sal_Int32 bPageDepth = (nValue & 0x0018) >> 3; //unused infromation: 0 - in front 1 - in back
     //todo: negative spacing (from ww8par6.cxx)
-    if( nOffsetFrom == 1 )
-    {
-//        USHORT nDist;
-//        if (aBox.GetLeft())
-//        {
-//            nDist = aBox.GetDistance(BOX_LINE_LEFT);
-//    lcl_MakeSafeNegativeSpacing( ) sets the distance to 0 if  > SHRT_MAX
-//
-//            aBox.SetDistance(lcl_MakeSafeNegativeSpacing(static_cast<USHORT>(aLR.GetLeft() - nDist)), BOX_LINE_LEFT);
-//            aSizeArray[WW8_LEFT] =
-//                aSizeArray[WW8_LEFT] - nDist + aBox.GetDistance(BOX_LINE_LEFT);
-//        }
-        //the same for right, top, bottom
-
-    }
     switch( nValue & 0x07)
     {
         case 0: /*all styles*/
-            xFirst = GetPageStyle( xPageStyles, xTextFactory, false );
-            xSecond = GetPageStyle( xPageStyles, xTextFactory, true );
+            if ( m_sFollowPageStyleName.getLength( ) > 0 )
+                xFirst = GetPageStyle( xPageStyles, xTextFactory, false );
+            if ( m_sFirstPageStyleName.getLength( ) > 0 )
+                xSecond = GetPageStyle( xPageStyles, xTextFactory, true );
         break;
         case 1: /*first page*/
-            xFirst = GetPageStyle( xPageStyles, xTextFactory, true );
+            if ( m_sFirstPageStyleName.getLength( ) > 0 )
+                xFirst = GetPageStyle( xPageStyles, xTextFactory, true );
         break;
         case 2: /*left and right*/
-            xFirst  = GetPageStyle( xPageStyles, xTextFactory, false );
+            if ( m_sFollowPageStyleName.getLength( ) > 0 )
+                xFirst  = GetPageStyle( xPageStyles, xTextFactory, false );
         break;
         case 3: //whole document?
             //todo: how to apply a border to the whole document - find all sections or access all page styles?
@@ -420,8 +412,16 @@ void SectionPropertyMap::ApplyBorderToPageStyles(
         PROP_LEFT_BORDER_DISTANCE,
         PROP_RIGHT_BORDER_DISTANCE,
         PROP_TOP_BORDER_DISTANCE,
-        PROP_BOTTOM_BORDER_DISTANCE,
+        PROP_BOTTOM_BORDER_DISTANCE
     };
+    static const PropertyIds aMarginIds[4] = 
+    {
+        PROP_LEFT_MARGIN,
+        PROP_RIGHT_MARGIN,
+        PROP_TOP_MARGIN,
+        PROP_BOTTOM_MARGIN
+    };
+
     PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
     for( sal_Int32 nBorder = 0; nBorder < 4; ++nBorder)
     {
@@ -434,19 +434,38 @@ void SectionPropertyMap::ApplyBorderToPageStyles(
         }
         if( m_nBorderDistances[nBorder] >= 0 )
         {
-            const ::rtl::OUString sBorderDistanceName = rPropNameSupplier.GetName( aBorderDistanceIds[nBorder] );
-            xFirst->setPropertyValue( sBorderDistanceName, uno::makeAny( m_nBorderDistances[nBorder] ));
+            SetBorderDistance( xFirst, aMarginIds[nBorder], aBorderDistanceIds[nBorder],
+                  m_nBorderDistances[nBorder], nOffsetFrom );
             if(xSecond.is())
-                xSecond->setPropertyValue( sBorderDistanceName, uno::makeAny( m_nBorderDistances[nBorder] ));
+                SetBorderDistance( xSecond, aMarginIds[nBorder], aBorderDistanceIds[nBorder],
+                      m_nBorderDistances[nBorder], nOffsetFrom );
         }
     }
+}
 
-//                rContext->Insert( aBorderIds[nId - 0x702B], uno::makeAny( aBorderLine ));
-//                rContext->Insert( aBorderDistanceIds[nId - 0x702B], uno::makeAny( nLineDistance) );
-
-//    uno::Reference< beans::XPropertySet > xStyle = GetPageStyle( ePageType );
+void SectionPropertyMap::SetBorderDistance( uno::Reference< beans::XPropertySet > xStyle, 
+        PropertyIds eMarginId, PropertyIds eDistId, sal_Int32 nDistance, sal_Int32 nOffsetFrom )
+{ 
+    PropertyNameSupplier& rPropNameSupplier = PropertyNameSupplier::GetPropertyNameSupplier();
 
+    sal_Int32 nDist = nDistance;
+    if( nOffsetFrom == 1 )
+    {
+        const ::rtl::OUString sMarginName = rPropNameSupplier.GetName( eMarginId );
+        uno::Any aMargin = xStyle->getPropertyValue( sMarginName );
+        sal_Int32 nMargin;
+        aMargin >>= nMargin;
+    
+        // Change the margins with the border distance
+        xStyle->setPropertyValue( sMarginName, uno::makeAny( nDistance ) );
+    
+        // Set the distance to ( Margin - distance )
+        nDist = nMargin - nDistance;
+    }
+    const ::rtl::OUString sBorderDistanceName = rPropNameSupplier.GetName( eDistId );
+    xStyle->setPropertyValue( sBorderDistanceName, uno::makeAny( nDist ));
 }
+
 /*-- 14.12.2006 12:50:06---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -724,8 +743,8 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
 
         sal_Int32 nCharWidth = 423; //240 twip/ 12 pt
         //todo: is '0' the right index here?
-        const StyleSheetEntry* pEntry = rDM_Impl.GetStyleSheetTable()->FindStyleSheetByISTD(::rtl::OUString::valueOf(static_cast<sal_Int32>(0), 16));
-        if( pEntry )
+        const StyleSheetEntryPtr pEntry = rDM_Impl.GetStyleSheetTable()->FindStyleSheetByISTD(::rtl::OUString::valueOf(static_cast<sal_Int32>(0), 16));
+        if( pEntry.get( ) )
         {
             PropertyMap::iterator aElement_ = pEntry->pProperties->find(PropertyDefinition( PROP_CHAR_HEIGHT_ASIAN, false ));
             if( aElement_ != pEntry->pProperties->end())
@@ -764,6 +783,7 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
             uno::Reference< beans::XPropertySet > xFirstPageStyle = GetPageStyle(
                                 rDM_Impl.GetPageStyles(), rDM_Impl.GetTextFactory(), true );
             _ApplyProperties( xFirstPageStyle );
+
             sal_Int32 nPaperBin = m_nFirstPaperBin >= 0 ? m_nFirstPaperBin : m_nPaperBin >= 0 ? m_nPaperBin : 0;
             if( nPaperBin )
                 xFollowPageStyle->setPropertyValue( sTrayIndex, uno::makeAny( nPaperBin ) );
@@ -771,6 +791,8 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
                 xFollowPageStyle->setPropertyValue(
                     rPropNameSupplier.GetName( PROP_TEXT_COLUMNS ), uno::makeAny( xColumns ));
         }
+
+        ApplyBorderToPageStyles( rDM_Impl.GetPageStyles( ), rDM_Impl.GetTextFactory( ), m_nBorderParams );
         try
         {
 //            if( m_xStartingRange.is() )
@@ -778,28 +800,24 @@ void SectionPropertyMap::CloseSectionGroup( DomainMapper_Impl& rDM_Impl )
                 //now apply this break at the first paragraph of this section
                 uno::Reference< beans::XPropertySet > xRangeProperties;
                 if( m_bIsFirstSection )
-                    xRangeProperties = uno::Reference< beans::XPropertySet >( rDM_Impl.GetBodyText()->getStart(), uno::UNO_QUERY_THROW );
+                {
+                    uno::Reference< container::XEnumerationAccess > xEnumAccess( rDM_Impl.GetBodyText( ), uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XEnumeration >  xEnum = xEnumAccess->createEnumeration( );
+                    xRangeProperties = uno::Reference< beans::XPropertySet >( xEnum->nextElement( ), uno::UNO_QUERY_THROW );
+                }
                 else
                     xRangeProperties = uno::Reference< beans::XPropertySet >( m_xStartingRange, uno::UNO_QUERY_THROW );
             /* break type
             0 - No break 1 - New Colunn 2 - New page 3 - Even page 4 - odd page */
-                if( m_nBreakType == 2 || m_nBreakType == 3)
-                {
-                    xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_BREAK_TYPE),
-                        uno::makeAny( m_nBreakType == 2 ? style::BreakType_COLUMN_AFTER : style::BreakType_PAGE_AFTER  ) );
-                }
-                else
-                {
-                    xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_DESC_NAME ),
-                        uno::makeAny( m_bTitlePage ? m_sFirstPageStyleName : m_sFollowPageStyleName ));
+                xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_DESC_NAME ),
+                    uno::makeAny( m_bTitlePage ? m_sFirstPageStyleName : m_sFollowPageStyleName ));
     //  todo: page breaks with odd/even page numbering are not available - find out current page number to check how to change the number
     //  or add even/odd page break types
-                    if(m_bPageNoRestart || m_nPageNumber >= 0)
-                    {
-                        sal_Int16 nPageNumber = m_nPageNumber >= 0 ? static_cast< sal_Int16 >(m_nPageNumber) : 1;
-                        xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_NUMBER_OFFSET ),
-                            uno::makeAny( nPageNumber ));
-                    }
+                if(m_bPageNoRestart || m_nPageNumber >= 0)
+                {
+                    sal_Int16 nPageNumber = m_nPageNumber >= 0 ? static_cast< sal_Int16 >(m_nPageNumber) : 1;
+                    xRangeProperties->setPropertyValue(rPropNameSupplier.GetName( PROP_PAGE_NUMBER_OFFSET ),
+                        uno::makeAny( nPageNumber ));
                 }
             }
         }
@@ -875,7 +893,8 @@ StyleSheetPropertyMap::StyleSheetPropertyMap() :
     mbCT_TblWidth_wSet( false ),
     mbCT_TblWidth_typeSet( false ),
     mnListId( -1 ),
-    mnListLevel( -1 )
+    mnListLevel( -1 ),
+    mnOutlineLevel( -1 )
 {
 }
 /*-- 14.06.2007 13:57:43---------------------------------------------------
diff --git writerfilter/source/dmapper/PropertyMap.hxx writerfilter/source/dmapper/PropertyMap.hxx
index c6736fe..526f902 100644
--- writerfilter/source/dmapper/PropertyMap.hxx
+++ writerfilter/source/dmapper/PropertyMap.hxx
@@ -158,6 +158,7 @@ class SectionPropertyMap : public PropertyMap
 
     ::com::sun::star::table::BorderLine*    m_pBorderLines[4];
     sal_Int32                               m_nBorderDistances[4];
+    sal_Int32                               m_nBorderParams;
 
     bool                                    m_bTitlePage;
     sal_Int16                               m_nColumnCount;
@@ -202,6 +203,9 @@ class SectionPropertyMap : public PropertyMap
     bool HasHeader( bool bFirstPage ) const;
     bool HasFooter( bool bFirstPage ) const;
 
+    void SetBorderDistance( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > xStyle, 
+        PropertyIds eMarginId, PropertyIds eDistId, sal_Int32 nDistance, sal_Int32 nOffsetFrom );
+
 public:
         explicit SectionPropertyMap(bool bIsFirstSection);
         ~SectionPropertyMap();
@@ -227,6 +231,7 @@ public:
             bool bFirst );
 
     void SetBorder( BorderPosition ePos, sal_Int32 nLineDistance, const ::com::sun::star::table::BorderLine& rBorderLine );
+    void SetBorderParams( sal_Int32 nSet ) { m_nBorderParams = nSet; }
 
     void SetColumnCount( sal_Int16 nCount ) { m_nColumnCount = nCount; }
     void SetColumnDistance( sal_Int32 nDist ) { m_nColumnDistance = nDist; }
@@ -376,6 +381,9 @@ typedef boost::shared_ptr<ParagraphProperties>  ParagraphPropertiesPtr;
 /*-- 14.06.2007 12:12:34---------------------------------------------------
     property map of a stylesheet 
   -----------------------------------------------------------------------*/
+
+#define WW_OUTLINE_MAX  sal_Int16( 9 )
+
 class StyleSheetPropertyMap : public PropertyMap, public ParagraphProperties
 
 {
@@ -405,6 +413,8 @@ class StyleSheetPropertyMap : public PropertyMap, public ParagraphProperties
 
     sal_Int32               mnListId;
     sal_Int16               mnListLevel;
+
+    sal_Int16               mnOutlineLevel;
 public: 
     explicit StyleSheetPropertyMap();
     ~StyleSheetPropertyMap();
@@ -479,6 +489,12 @@ public:
     sal_Int16   GetListLevel() const            { return mnListLevel; }
     void        SetListLevel(sal_Int16 nLevel)  { mnListLevel = nLevel; }
     
+    sal_Int16   GetOutlineLevel() const            { return mnOutlineLevel; }
+    void        SetOutlineLevel(sal_Int16 nLevel)  
+    { 
+        if ( nLevel < WW_OUTLINE_MAX )
+            mnOutlineLevel = nLevel; 
+    }
 };
 /*-- 27.12.2007 12:38:06---------------------------------------------------
 
diff --git writerfilter/source/dmapper/SettingsTable.cxx writerfilter/source/dmapper/SettingsTable.cxx
new file mode 100644
index 0000000..6facbf9
--- /dev/null
+++ writerfilter/source/dmapper/SettingsTable.cxx
@@ -0,0 +1,86 @@
+#include "SettingsTable.hxx"
+
+#include <ooxml/resourceids.hxx>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+#if DEBUG
+#include <iostream>
+#endif
+
+using namespace com::sun::star;
+using namespace rtl;
+
+namespace writerfilter {
+namespace dmapper {
+
+SettingsTable_Impl::SettingsTable_Impl( ) :
+   m_bRecordChanges( false )
+{
+}
+
+SettingsTable_Impl::~SettingsTable_Impl( ) 
+{
+}
+
+SettingsTable::SettingsTable( ) :
+    m_pImpl( new SettingsTable_Impl )
+{
+}
+
+SettingsTable::~SettingsTable( )
+{
+    delete m_pImpl, m_pImpl = NULL;
+}
+
+void SettingsTable::attribute( Id nName, Value& rVal )
+{
+#if DEBUG
+    clog << "SettingsTable::attribute( )" << endl;
+#endif
+}
+
+void SettingsTable::sprm( Sprm& rSprm )
+{
+    switch ( rSprm.getId( ) )
+    {
+        case NS_ooxml::LN_CT_Settings_trackRevisions:
+            {
+                m_pImpl->m_bRecordChanges = bool(rSprm.getValue( )->getInt( ) );
+            }
+            break;
+        default:
+            {
+#if DEBUG
+                clog << __FILE__ << ":" << __LINE__;
+                clog << ": unknown SPRM: " << rSprm.getName( ) << endl;
+#endif
+            }
+    }
+}
+
+void SettingsTable::entry( int nPos, writerfilter::Reference<Properties>::Pointer_t pRef )
+{
+#if DEBUG
+    clog << "SettingsTable::entry( ), pos: " << nPos << endl;
+#endif
+    pRef->resolve( *this );
+}
+
+void SettingsTable::resolveSprmProps( Sprm& rSprm )
+{
+    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+    if( pProperties.get())
+        pProperties->resolve(*this);
+}
+    
+void SettingsTable::ApplyProperties( uno::Reference< text::XTextDocument > xDoc )
+{
+    uno::Reference< beans::XPropertySet> xDocProps( xDoc, uno::UNO_QUERY );
+
+    // Record changes value
+    xDocProps->setPropertyValue( OUString::createFromAscii( "RecordChanges" ), uno::makeAny( m_pImpl->m_bRecordChanges ) );
+}
+
+} }
diff --git writerfilter/source/dmapper/SettingsTable.hxx writerfilter/source/dmapper/SettingsTable.hxx
new file mode 100644
index 0000000..6a5e8b9
--- /dev/null
+++ writerfilter/source/dmapper/SettingsTable.hxx
@@ -0,0 +1,47 @@
+#ifndef INCLUDED_SETTINGSTABLE_HXX
+#define INCLUDED_SETTINGSTABLE_HXX
+
+#include <WriterFilterDllApi.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+
+#include <com/sun/star/text/XTextDocument.hpp>
+
+namespace writerfilter {
+namespace dmapper
+{
+using namespace std;
+
+struct SettingsTable_Impl
+{
+public:
+    bool m_bRecordChanges;
+
+    SettingsTable_Impl( );
+    ~SettingsTable_Impl( );
+};
+
+class WRITERFILTER_DLLPRIVATE SettingsTable: public Properties, public Table
+{
+public:
+    SettingsTable_Impl* m_pImpl;
+
+    SettingsTable( );
+    ~SettingsTable( );
+    
+    // Properties
+    virtual void attribute(Id Name, Value & val);
+    virtual void sprm(Sprm & sprm);
+
+    // Table
+    virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
+
+    void resolveSprmProps( Sprm& rSprm );
+
+    void ApplyProperties( com::sun::star::uno::Reference< com::sun::star::text::XTextDocument > xDoc );
+};
+typedef boost::shared_ptr< SettingsTable > SettingsTablePtr;
+
+
+} }
+
+#endif
diff --git writerfilter/source/dmapper/StyleSheetTable.cxx writerfilter/source/dmapper/StyleSheetTable.cxx
index 20efc0a..e67cffd 100644
--- writerfilter/source/dmapper/StyleSheetTable.cxx
+++ writerfilter/source/dmapper/StyleSheetTable.cxx
@@ -29,7 +29,9 @@
  ************************************************************************/
 #include <StyleSheetTable.hxx>
 #include <dmapper/DomainMapper.hxx>
+#include <ListTable.hxx>
 #include <ConversionHelper.hxx>
+#include <TblStylePrHandler.hxx>
 #include <BorderHandler.hxx>
 #include <doctok/resourceids.hxx>
 #include <ooxml/resourceids.hxx>
@@ -38,6 +40,7 @@
 #include <com/sun/star/beans/XPropertyState.hpp>
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/text/XChapterNumberingSupplier.hpp>
 #include <com/sun/star/text/XTextDocument.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/style/XStyle.hpp>
@@ -70,6 +73,175 @@ StyleSheetEntry::StyleSheetEntry() :
         {
         }
 
+TableStyleSheetEntry::TableStyleSheetEntry( StyleSheetEntry& rEntry, StyleSheetTable* pStyles ):
+    StyleSheetEntry( ),
+    m_pStyleSheet( pStyles )
+{
+    bIsDefaultStyle = rEntry.bIsDefaultStyle;
+    bInvalidHeight = rEntry.bInvalidHeight;
+    bHasUPE = rEntry.bHasUPE;
+    nStyleTypeCode = STYLE_TYPE_TABLE;
+    sBaseStyleIdentifier = rEntry.sBaseStyleIdentifier;
+    sNextStyleIdentifier = rEntry.sNextStyleIdentifier;
+    sStyleName = rEntry.sStyleName;
+    sStyleName1 = rEntry.sStyleName1;
+
+    m_nColBandSize = 1;
+    m_nRowBandSize = 1;
+}
+
+TableStyleSheetEntry::~TableStyleSheetEntry( )
+{
+    m_pStyleSheet = NULL;
+}
+
+void TableStyleSheetEntry::AddTblStylePr( TblStyleType nType, PropertyMapPtr pProps )
+{
+    static TblStyleType pTypesToFix[] =
+    {
+        TBL_STYLE_FIRSTROW,
+        TBL_STYLE_LASTROW,
+        TBL_STYLE_FIRSTCOL,
+        TBL_STYLE_LASTCOL
+    };
+
+    static PropertyIds pPropsToCheck[] =
+    {
+        PROP_BOTTOM_BORDER,
+        PROP_TOP_BORDER,
+        PROP_RIGHT_BORDER,
+        PROP_LEFT_BORDER
+    };
+
+    int i = 0;
+    while ( i < 4 )
+    {
+        if ( nType == pTypesToFix[i] )
+        {
+            PropertyIds nChecked = pPropsToCheck[i];
+            PropertyMap::iterator pCheckedIt = pProps->find( PropertyDefinition( nChecked, false )  );
+
+            PropertyIds nInsideProp = ( i < 2 ) ? META_PROP_HORIZONTAL_BORDER : META_PROP_VERTICAL_BORDER;
+            PropertyMap::iterator pInsideIt = pProps->find( PropertyDefinition( nInsideProp, false )  );
+
+            bool bHasChecked = pCheckedIt != pProps->end( );
+            bool bHasInside = pInsideIt != pProps->end( );
+
+            if ( bHasChecked && bHasInside )
+            {
+                // In this case, remove the inside border
+                pProps->erase( pInsideIt );
+            }
+
+            i = 4; // Stop looping stupidly
+        }
+        i++;
+    }
+
+    // Append the tblStylePr
+    m_aStyles[nType] = pProps;
+}
+
+PropertyMapPtr TableStyleSheetEntry::GetProperties( sal_Int32 nMask )
+{
+    PropertyMapPtr pProps( new PropertyMap );
+
+    // First get the parent properties
+    StyleSheetEntryPtr pEntry = m_pStyleSheet->FindParentStyleSheet( sBaseStyleIdentifier );
+
+    if ( pEntry.get( ) )
+    {
+        TableStyleSheetEntry* pParent = static_cast<TableStyleSheetEntry *>( pEntry.get( ) );
+        pProps->insert( pParent->GetProperties( nMask ) );
+    }
+    
+    // And finally get the mask ones
+    pProps->insert( GetLocalPropertiesFromMask( nMask ) );
+
+    return pProps;
+}
+
+void lcl_mergeProps( PropertyMapPtr pToFill,  PropertyMapPtr pToAdd, TblStyleType nStyleId )
+{
+    static PropertyIds pPropsToCheck[] =
+    {
+        PROP_BOTTOM_BORDER,
+        PROP_TOP_BORDER,
+        PROP_RIGHT_BORDER,
+        PROP_LEFT_BORDER,
+    };
+
+    bool pRemoveInside[] =
+    {
+        ( nStyleId == TBL_STYLE_FIRSTROW ),
+        ( nStyleId == TBL_STYLE_LASTROW ),
+        ( nStyleId == TBL_STYLE_LASTCOL ),
+        ( nStyleId == TBL_STYLE_FIRSTCOL )
+    };
+
+    for ( int i = 0 ; i < 7; i++ )
+    {
+        PropertyIds nId = pPropsToCheck[i];
+        PropertyDefinition aProp( nId, false );
+        PropertyMap::iterator pIt = pToAdd->find( aProp );
+   
+        if ( pIt != pToAdd->end( ) )
+        {
+            PropertyMap::iterator pDestIt = pToFill->find( aProp );
+            
+            if ( pRemoveInside[i] )
+            {
+                // Remove the insideH and insideV depending on the cell pos
+                PropertyIds nInsideProp = ( i < 2 ) ? META_PROP_HORIZONTAL_BORDER : META_PROP_VERTICAL_BORDER;
+                pDestIt = pToFill->find( PropertyDefinition( nInsideProp, false ) );
+                if ( pDestIt != pToFill->end( ) )
+                    pToFill->erase( pDestIt );
+            }
+        }    
+    }
+
+    pToFill->insert( pToAdd );
+}
+
+PropertyMapPtr TableStyleSheetEntry::GetLocalPropertiesFromMask( sal_Int32 nMask )
+{
+    // Order from right to left
+    static TblStyleType aBitsOrder[] = 
+    {
+        TBL_STYLE_SWCELL,
+        TBL_STYLE_SECELL,
+        TBL_STYLE_NWCELL,
+        TBL_STYLE_NECELL,
+        TBL_STYLE_BAND2HORZ,
+        TBL_STYLE_BAND1HORZ,
+        TBL_STYLE_BAND2VERT,
+        TBL_STYLE_BAND1VERT,
+        TBL_STYLE_LASTCOL,
+        TBL_STYLE_FIRSTCOL,
+        TBL_STYLE_LASTROW,
+        TBL_STYLE_FIRSTROW
+    };
+
+    // Get the properties applying according to the mask
+    PropertyMapPtr pProps( new PropertyMap( ) );
+    short nBit = 0;
+    do
+    {
+        TblStyleType nStyleId = aBitsOrder[nBit];
+        TblStylePrs::iterator pIt = m_aStyles.find( nStyleId );
+
+        short nTestBit = 1 << nBit;
+        sal_Int32 nBitMask = sal_Int32( nTestBit );
+        if ( ( nMask & nBitMask ) && ( pIt != m_aStyles.end( ) ) )
+            lcl_mergeProps( pProps, pIt->second, nStyleId );
+
+        nBit++;
+    }
+    while ( nBit < 12 );
+
+    return pProps;
+}
+
 /*-- 06.02.2008 11:30:46---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -92,8 +264,8 @@ struct StyleSheetTable_Impl
     DomainMapper&                           m_rDMapper;
     uno::Reference< text::XTextDocument>    m_xTextDocument;
     uno::Reference< beans::XPropertySet>    m_xTextDefaults; 
-    std::vector< StyleSheetEntry >          m_aStyleSheetEntries;
-    StyleSheetEntry                         *m_pCurrentEntry;
+    std::vector< StyleSheetEntryPtr >       m_aStyleSheetEntries;
+    StyleSheetEntryPtr                      m_pCurrentEntry;
     PropertyMapPtr                          m_pDefaultParaProps, m_pDefaultCharProps;
     PropertyMapPtr                          m_pCurrentProps;
     StringPairMap_t                         m_aStyleNameMap;
@@ -110,7 +282,7 @@ struct StyleSheetTable_Impl
 StyleSheetTable_Impl::StyleSheetTable_Impl(DomainMapper& rDMapper, uno::Reference< text::XTextDocument> xTextDocument ) :
             m_rDMapper( rDMapper ),
             m_xTextDocument( xTextDocument ),
-            m_pCurrentEntry(0),
+            m_pCurrentEntry(),
             m_pDefaultParaProps(new PropertyMap),
             m_pDefaultCharProps(new PropertyMap)
 {
@@ -659,13 +831,23 @@ void StyleSheetTable::attribute(Id Name, Value & val)
 //        case NS_rtf::LN_STYLESHEET: break;
         /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_Style_type:
+        {
 /*          defaults should be set at the service "com.sun.star.text.Defaults"          
              if (nIntValue == 1)
                 *(m_pImpl->m_pCurrentEntry->pProperties) = *(m_pImpl->m_pDefaultParaProps);
             else if (nIntValue == 2)
                 *(m_pImpl->m_pCurrentEntry->pProperties) = *(m_pImpl->m_pDefaultCharProps);*/
-            m_pImpl->m_pCurrentEntry->nStyleTypeCode = (StyleType)nIntValue;
+            StyleType nType = ( StyleType ) nIntValue;
+            if ( nType == STYLE_TYPE_TABLE )
+            {
+                StyleSheetEntryPtr pEntry = m_pImpl->m_pCurrentEntry;
+                TableStyleSheetEntryPtr pTableEntry( new TableStyleSheetEntry( *pEntry.get( ), this ) );
+                m_pImpl->m_pCurrentEntry = pTableEntry;
+            }
+            else
+                m_pImpl->m_pCurrentEntry->nStyleTypeCode = (StyleType)nIntValue;
         break;
+        }
         /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_Style_default:
             m_pImpl->m_pCurrentEntry->bIsDefaultStyle = (nIntValue != 0);
@@ -707,7 +889,7 @@ void StyleSheetTable::sprm(Sprm & rSprm)
     (void)nIntValue;
     rtl::OUString sStringValue = pValue.get() ? pValue->getString() : rtl::OUString();
     //printf ( "StyleSheetTable::sprm(0x%.4x, 0x%.4x) [%s]\n", (unsigned int)nSprmId, (unsigned int)nIntValue, ::rtl::OUStringToOString(sStringValue, RTL_TEXTENCODING_DONTKNOW).getStr());
-    
+   
     /* WRITERFILTERSTATUS: table: StyleSheetTable_sprm */
     switch(nSprmId)
     {
@@ -753,13 +935,28 @@ void StyleSheetTable::sprm(Sprm & rSprm)
         case NS_ooxml::LN_CT_Style_rsid:
         /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_Style_trPr:
-        /* WRITERFILTERSTATUS: done: 0, planned: 0, spent: 0 */
-        case NS_ooxml::LN_CT_Style_tcPr:
         break;
         /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
-        case NS_ooxml::LN_CT_Style_tblPr: //contains table properties
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_Style_tblStylePr: //contains  to table properties
+        {
+            writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+            if( pProperties.get())
+            {
+                TblStylePrHandlerPtr pTblStylePrHandler( new TblStylePrHandler( m_pImpl->m_rDMapper ) );
+                pProperties->resolve( *pTblStylePrHandler );
+
+                // Add the properties to the table style
+                TblStyleType nType = pTblStylePrHandler->getType( );
+                PropertyMapPtr pProps = pTblStylePrHandler->getProperties( );
+                StyleSheetEntryPtr pEntry = m_pImpl->m_pCurrentEntry;
+                TableStyleSheetEntry* pTableEntry = static_cast<TableStyleSheetEntry*>( pEntry.get( ) );
+                pTableEntry->AddTblStylePr( nType, pProps );
+            }
+            break;
+        }
+        case NS_ooxml::LN_CT_Style_tcPr:
+        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+        case NS_ooxml::LN_CT_Style_tblPr: //contains table properties
         /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_DocDefaults_pPrDefault:
         /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
@@ -805,14 +1002,35 @@ void StyleSheetTable::sprm(Sprm & rSprm)
             }
         }
         break;
-        /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
+        case NS_ooxml::LN_CT_TblPrBase_tblStyleRowBandSize:
+        case NS_ooxml::LN_CT_TblPrBase_tblStyleColBandSize:
+        {
+            StyleSheetEntry* pEntry = m_pImpl->m_pCurrentEntry.get( );
+            TableStyleSheetEntry *pTEntry = static_cast<TableStyleSheetEntry*>( pEntry );
+            if ( pTEntry )
+            {
+                if ( nSprmId == NS_ooxml::LN_CT_TblPrBase_tblStyleRowBandSize )
+                    pTEntry->m_nRowBandSize = nIntValue;
+                else
+                    pTEntry->m_nColBandSize = nIntValue;
+            }
+        }
+        break;
+            /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_Style_pPr:
         /* WRITERFILTERSTATUS: done: 100, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_Style_rPr:
         default:
             if (!m_pImpl->m_pCurrentEntry)
                 break;
-            m_pImpl->m_rDMapper.sprm( rSprm, m_pImpl->m_pCurrentEntry->pProperties );
+            TablePropertiesHandlerPtr pTblHandler( new TablePropertiesHandler( true ) );
+            pTblHandler->SetProperties( m_pImpl->m_pCurrentEntry->pProperties );
+            if ( !pTblHandler->sprm( rSprm ) )
+            {
+                m_pImpl->m_rDMapper.PushStyleSheetProperties( m_pImpl->m_pCurrentEntry->pProperties );
+                m_pImpl->m_rDMapper.sprm( rSprm );
+                m_pImpl->m_rDMapper.PopStyleSheetProperties( );
+            }
     }
 }
 /*-- 19.06.2006 12:04:33---------------------------------------------------
@@ -823,7 +1041,8 @@ void StyleSheetTable::entry(int /*pos*/, writerfilter::Reference<Properties>::Po
     //create a new style entry
     // printf("StyleSheetTable::entry(...)\n");
     OSL_ENSURE( !m_pImpl->m_pCurrentEntry, "current entry has to be NULL here");
-    m_pImpl->m_pCurrentEntry = new StyleSheetEntry;
+    StyleSheetEntryPtr pNewEntry( new StyleSheetEntry );
+    m_pImpl->m_pCurrentEntry = pNewEntry;
     m_pImpl->m_rDMapper.PushStyleSheetProperties( m_pImpl->m_pCurrentEntry->pProperties );
     ref->resolve(*this);
     //append it to the table
@@ -831,13 +1050,14 @@ void StyleSheetTable::entry(int /*pos*/, writerfilter::Reference<Properties>::Po
     if( !m_pImpl->m_rDMapper.IsOOXMLImport() || m_pImpl->m_pCurrentEntry->sStyleName.getLength() >0)
     {
         m_pImpl->m_pCurrentEntry->sConvertedStyleName = ConvertStyleName( m_pImpl->m_pCurrentEntry->sStyleName );
-        m_pImpl->m_aStyleSheetEntries.push_back( *m_pImpl->m_pCurrentEntry );
+        m_pImpl->m_aStyleSheetEntries.push_back( m_pImpl->m_pCurrentEntry );
     }
     else
     {
         //TODO: this entry contains the default settings - they have to be added to the settings
     }    
-    m_pImpl->m_pCurrentEntry = 0;
+    StyleSheetEntryPtr pEmptyEntry;
+    m_pImpl->m_pCurrentEntry = pEmptyEntry;
 }
 /*-- 21.06.2006 15:34:49---------------------------------------------------
     sorting helper
@@ -910,16 +1130,17 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
         xStyleFamilies->getByName(rPropNameSupplier.GetName( PROP_PARAGRAPH_STYLES )) >>= xParaStyles;
         if(xCharStyles.is() && xParaStyles.is())
         {
-            std::vector< StyleSheetEntry >::iterator aIt = m_pImpl->m_aStyleSheetEntries.begin();
+            std::vector< StyleSheetEntryPtr >::iterator aIt = m_pImpl->m_aStyleSheetEntries.begin();
             while( aIt != m_pImpl->m_aStyleSheetEntries.end() )
             {
-                if( aIt->nStyleTypeCode == STYLE_TYPE_CHAR || aIt->nStyleTypeCode == STYLE_TYPE_PARA )
+                StyleSheetEntryPtr pEntry = *aIt;
+                if( pEntry->nStyleTypeCode == STYLE_TYPE_CHAR || pEntry->nStyleTypeCode == STYLE_TYPE_PARA )
                 {
-                    bool bParaStyle = aIt->nStyleTypeCode == STYLE_TYPE_PARA;
+                    bool bParaStyle = pEntry->nStyleTypeCode == STYLE_TYPE_PARA;
                     bool bInsert = false;
                     uno::Reference< container::XNameContainer > xStyles = bParaStyle ? xParaStyles : xCharStyles;
                     uno::Reference< style::XStyle > xStyle;
-                    ::rtl::OUString sConvertedStyleName = ConvertStyleName( aIt->sStyleName );
+                    ::rtl::OUString sConvertedStyleName = ConvertStyleName( pEntry->sStyleName );
                     if(xStyles->hasByName( sConvertedStyleName ))
                         xStyles->getByName( sConvertedStyleName ) >>= xStyle;
                     else
@@ -931,12 +1152,13 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
                                         rPropNameSupplier.GetName( PROP_SERVICE_CHAR_STYLE )),
                                         uno::UNO_QUERY_THROW);
                     }
-                    if( aIt->sBaseStyleIdentifier.getLength() )
+                    if( pEntry->sBaseStyleIdentifier.getLength() )
                     {
                         try
                         {
                             //TODO: Handle cases where a paragraph <> character style relation is needed
-                            xStyle->setParentStyle(ConvertStyleName( aIt->sBaseStyleIdentifier ));
+                            StyleSheetEntryPtr pParent = FindStyleSheetByISTD( pEntry->sBaseStyleIdentifier );
+                            xStyle->setParentStyle(ConvertStyleName( pParent->sStyleName ));
                         }
                         catch( const uno::RuntimeException& )
                         {
@@ -955,43 +1177,103 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
                         {
                             uno::Any aTwoHundredFortyTwip = uno::makeAny(12.);
     //                      font size to 240 twip (12 pts) for all if not set
-                            aIt->pProperties->Insert(PROP_CHAR_HEIGHT, true, aTwoHundredFortyTwip, false);
+                            pEntry->pProperties->Insert(PROP_CHAR_HEIGHT, true, aTwoHundredFortyTwip, false);
     //                      western font not already set -> apply first font
                             const FontEntry* pWesternFontEntry = rFontTable->getFontEntry( 0 );
                             rtl::OUString sWesternFontName = pWesternFontEntry->sFontName;
-                            aIt->pProperties->Insert(PROP_CHAR_FONT_NAME, true, uno::makeAny( sWesternFontName ), false);
+                            pEntry->pProperties->Insert(PROP_CHAR_FONT_NAME, true, uno::makeAny( sWesternFontName ), false);
 
     //                      CJK  ... apply second font
                             const FontEntry* pCJKFontEntry  = rFontTable->getFontEntry( 2 );
-                            aIt->pProperties->Insert(PROP_CHAR_FONT_NAME_ASIAN, true, uno::makeAny( pCJKFontEntry->sFontName ), false);
-                            aIt->pProperties->Insert(PROP_CHAR_HEIGHT_ASIAN, true, aTwoHundredFortyTwip, false);
+                            pEntry->pProperties->Insert(PROP_CHAR_FONT_NAME_ASIAN, true, uno::makeAny( pCJKFontEntry->sFontName ), false);
+                            pEntry->pProperties->Insert(PROP_CHAR_HEIGHT_ASIAN, true, aTwoHundredFortyTwip, false);
     //                      CTL  ... apply third font, if available
                             if( nFontCount > 3 )
                             {
                                 const FontEntry* pCTLFontEntry  = rFontTable->getFontEntry( 3 );
-                                aIt->pProperties->Insert(PROP_CHAR_FONT_NAME_COMPLEX, true, uno::makeAny( pCTLFontEntry->sFontName ), false);
-                                aIt->pProperties->Insert(PROP_CHAR_HEIGHT_COMPLEX, true, aTwoHundredFortyTwip, false);
+                                pEntry->pProperties->Insert(PROP_CHAR_FONT_NAME_COMPLEX, true, uno::makeAny( pCTLFontEntry->sFontName ), false);
+                                pEntry->pProperties->Insert(PROP_CHAR_HEIGHT_COMPLEX, true, aTwoHundredFortyTwip, false);
                             }
                         }
     //                  Widow/Orphan -> set both to two if not already set
                         uno::Any aTwo = uno::makeAny(sal_Int8(2));
-                        aIt->pProperties->Insert(PROP_PARA_WIDOWS, true, aTwo, false);
-                        aIt->pProperties->Insert(PROP_PARA_ORPHANS, true, aTwo, false);
+                        pEntry->pProperties->Insert(PROP_PARA_WIDOWS, true, aTwo, false);
+                        pEntry->pProperties->Insert(PROP_PARA_ORPHANS, true, aTwo, false);
     //                  Left-to-right direction if not already set
-                        aIt->pProperties->Insert(PROP_WRITING_MODE, true, uno::makeAny( sal_Int16(text::WritingMode_LR_TB) ), false);
+                        pEntry->pProperties->Insert(PROP_WRITING_MODE, true, uno::makeAny( sal_Int16(text::WritingMode_LR_TB) ), false);
     //                  font color COL_AUTO if not already set
-                        aIt->pProperties->Insert(PROP_CHAR_COLOR, true, uno::makeAny( sal_Int32(0xffffffff) ), false);
+                        pEntry->pProperties->Insert(PROP_CHAR_COLOR, true, uno::makeAny( sal_Int32(0xffffffff) ), false);
                     }
 
-                    uno::Sequence< beans::PropertyValue > aPropValues = aIt->pProperties->GetPropertyValues();
+                    uno::Sequence< beans::PropertyValue > aPropValues = pEntry->pProperties->GetPropertyValues();
                     bool bAddFollowStyle = false;
-                    if(bParaStyle && !aIt->sNextStyleIdentifier.getLength() )
+                    if(bParaStyle && !pEntry->sNextStyleIdentifier.getLength() )
                     {
                             bAddFollowStyle = true;
                     }
                     //remove Left/RightMargin values from TOX heading styles
                     if( bParaStyle )
                     {
+                        // Set the outline levels
+                        const StyleSheetPropertyMap* pStyleSheetProperties = dynamic_cast<const StyleSheetPropertyMap*>(pEntry ? pEntry->pProperties.get() : 0);
+                        if ( pStyleSheetProperties )
+                        {
+                            aPropValues.realloc( aPropValues.getLength( ) + 1 );
+
+                            beans::PropertyValue aLvlVal( rPropNameSupplier.GetName( PROP_OUTLINE_LEVEL ), 0, 
+                                    uno::makeAny( sal_Int16( pStyleSheetProperties->GetOutlineLevel( ) + 1 ) ), 
+                                    beans::PropertyState_DIRECT_VALUE );
+                            aPropValues[ aPropValues.getLength( ) - 1 ] = aLvlVal;
+                            
+                            if ( pStyleSheetProperties->GetOutlineLevel( ) == 0 )
+                            {
+                                aPropValues.realloc( aPropValues.getLength( ) + 1 );
+                                beans::PropertyValue aStyleVal( rPropNameSupplier.GetName( PROP_NUMBERING_STYLE_NAME ), 0, 
+                                        uno::makeAny( rtl::OUString::createFromAscii( "" ) ), 
+                                        beans::PropertyState_DIRECT_VALUE );
+                                aPropValues[ aPropValues.getLength( ) - 1 ] = aStyleVal;
+                            }
+                        }
+
+                        if ( pStyleSheetProperties && pStyleSheetProperties->GetOutlineLevel( ) >= 0 )
+                        {
+                            ListTablePtr pListTable = m_pImpl->m_rDMapper.GetListTable( );
+                            sal_Int32 nNumId = pStyleSheetProperties->GetListId( );
+                            uno::Reference< container::XIndexReplace> xStyleRules = pListTable->GetNumberingRules( nNumId );
+
+                            sal_Int16 nLvl = pStyleSheetProperties->GetOutlineLevel( );
+                            uno::Reference< text::XChapterNumberingSupplier > xOutlines ( m_pImpl->m_xTextDocument,
+                                    uno::UNO_QUERY_THROW );
+
+                            uno::Reference< container::XIndexReplace > xRules = xOutlines->getChapterNumberingRules( );
+                            if ( xStyleRules.is( ) )
+                            {
+                                for ( sal_Int32 i = 0, nCount = xStyleRules->getCount( ); i < nCount; i++ )
+                                {
+                                    xRules->replaceByIndex( i, xStyleRules->getByIndex( i ) );
+                                }
+                            }
+
+                            uno::Any aLevel = xRules->getByIndex( nLvl );
+                            uno::Sequence< beans::PropertyValue > aLevelProps;
+                            aLevel >>= aLevelProps;
+
+                            sal_Int32 nLen = aLevelProps.getLength( );
+                            sal_Int32 i = 0;
+                            bool bPropFound = false;
+                            rtl::OUString sPropName( rtl::OUString::createFromAscii( "HeadingStyleName" ) );
+                            while ( i < nLen && !bPropFound )
+                            {
+                                if ( aLevelProps[i].Name.equals( sPropName ) )
+                                {
+                                    aLevelProps[i].Value = uno::makeAny( ConvertStyleName( pEntry->sStyleName ) );
+                                    bPropFound = true;
+                                }
+                                i++;
+                            }
+                            xRules->replaceByIndex( nLvl, uno::makeAny( aLevelProps ) );
+                        }
+
                         uno::Reference< beans::XPropertyState >xState( xStyle, uno::UNO_QUERY_THROW );
                         if( sConvertedStyleName.equalsAscii( "Contents Heading" ) ||
                             sConvertedStyleName.equalsAscii( "User Index Heading" ) ||
@@ -1028,24 +1310,27 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
 
                     if(bAddFollowStyle || aPropValues.getLength())
                     {
-                        const beans::PropertyValue* pPropValues = aPropValues.getConstArray();
                         PropValVector aSortedPropVals;
                         for( sal_Int32 nProp = 0; nProp < aPropValues.getLength(); ++nProp)
                         {
-                            aSortedPropVals.Insert( pPropValues[nProp] );
+                            // Don't add the style name properties
+                            bool bIsParaStyleName = aPropValues[nProp].Name.equalsAscii( "ParaStyleName" );
+                            bool bIsCharStyleName = aPropValues[nProp].Name.equalsAscii( "CharStyleName" );
+                            if ( !bInsert &&  !bIsParaStyleName && !bIsCharStyleName )
+                                aSortedPropVals.Insert( aPropValues[nProp] );
                         }
                         if(bAddFollowStyle)
                         {
                             //find the name of the Next style
-                            std::vector< StyleSheetEntry >::iterator aNextStyleIt = m_pImpl->m_aStyleSheetEntries.begin();
+                            std::vector< StyleSheetEntryPtr >::iterator aNextStyleIt = m_pImpl->m_aStyleSheetEntries.begin();
                             for( ; aNextStyleIt !=  m_pImpl->m_aStyleSheetEntries.end(); ++aNextStyleIt )
                             {
-                                if( aNextStyleIt->sStyleName.getLength() &&
-                                        aNextStyleIt->sStyleName == aIt->sNextStyleIdentifier)
+                                if( ( *aNextStyleIt )->sStyleName.getLength() &&
+                                        ( *aNextStyleIt )->sStyleName == pEntry->sNextStyleIdentifier)
                                 {
                                     beans::PropertyValue aNew;
                                     aNew.Name = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("FollowStyle"));
-                                    aNew.Value = uno::makeAny(ConvertStyleName( aNextStyleIt->sStyleIdentifierD ));
+                                    aNew.Value = uno::makeAny(ConvertStyleName( ( *aNextStyleIt )->sStyleIdentifierD ));
                                     aSortedPropVals.Insert( aNew );
                                     break;
                                 }
@@ -1084,14 +1369,14 @@ void StyleSheetTable::ApplyStyleSheets( FontTablePtr rFontTable )
 /*-- 22.06.2006 15:56:56---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-const StyleSheetEntry* StyleSheetTable::FindStyleSheetByISTD(const ::rtl::OUString& sIndex)
+const StyleSheetEntryPtr StyleSheetTable::FindStyleSheetByISTD(const ::rtl::OUString& sIndex)
 {
-    const StyleSheetEntry* pRet = 0;
+    StyleSheetEntryPtr pRet;
     for( sal_uInt32 nPos = 0; nPos < m_pImpl->m_aStyleSheetEntries.size(); ++nPos )
     {
-        if( m_pImpl->m_aStyleSheetEntries[nPos].sStyleIdentifierD == sIndex)
+        if( m_pImpl->m_aStyleSheetEntries[nPos]->sStyleIdentifierD == sIndex)
         {
-            pRet = &m_pImpl->m_aStyleSheetEntries[nPos];
+            pRet = m_pImpl->m_aStyleSheetEntries[nPos];
             break;
         }
     }
@@ -1100,14 +1385,14 @@ const StyleSheetEntry* StyleSheetTable::FindStyleSheetByISTD(const ::rtl::OUStri
 /*-- 28.12.2007 14:45:45---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-const StyleSheetEntry* StyleSheetTable::FindStyleSheetByStyleName(const ::rtl::OUString& sIndex)
+const StyleSheetEntryPtr StyleSheetTable::FindStyleSheetByStyleName(const ::rtl::OUString& sIndex)
 {
-    const StyleSheetEntry* pRet = 0;
+    StyleSheetEntryPtr pRet;
     for( sal_uInt32 nPos = 0; nPos < m_pImpl->m_aStyleSheetEntries.size(); ++nPos )
     {
-        if( m_pImpl->m_aStyleSheetEntries[nPos].sStyleName == sIndex)
+        if( m_pImpl->m_aStyleSheetEntries[nPos]->sStyleName == sIndex)
         {
-            pRet = &m_pImpl->m_aStyleSheetEntries[nPos];
+            pRet = m_pImpl->m_aStyleSheetEntries[nPos];
             break;
         }
     }
@@ -1116,14 +1401,14 @@ const StyleSheetEntry* StyleSheetTable::FindStyleSheetByStyleName(const ::rtl::O
 /*-- 28.12.2007 14:45:45---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-const StyleSheetEntry* StyleSheetTable::FindStyleSheetByConvertedStyleName(const ::rtl::OUString& sIndex)
+const StyleSheetEntryPtr StyleSheetTable::FindStyleSheetByConvertedStyleName(const ::rtl::OUString& sIndex)
 {
-    const StyleSheetEntry* pRet = 0;
+    StyleSheetEntryPtr pRet;
     for( sal_uInt32 nPos = 0; nPos < m_pImpl->m_aStyleSheetEntries.size(); ++nPos )
     {
-        if( m_pImpl->m_aStyleSheetEntries[nPos].sConvertedStyleName == sIndex)
+        if( m_pImpl->m_aStyleSheetEntries[nPos]->sConvertedStyleName == sIndex)
         {
-            pRet = &m_pImpl->m_aStyleSheetEntries[nPos];
+            pRet = m_pImpl->m_aStyleSheetEntries[nPos];
             break;
         }
     }
@@ -1133,23 +1418,17 @@ const StyleSheetEntry* StyleSheetTable::FindStyleSheetByConvertedStyleName(const
 /*-- 17.07.2006 11:47:00---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-const StyleSheetEntry* StyleSheetTable::FindParentStyleSheet(::rtl::OUString sBaseStyle)
+const StyleSheetEntryPtr StyleSheetTable::FindParentStyleSheet(::rtl::OUString sBaseStyle)
 {
     if( !sBaseStyle.getLength() )
-        return 0;
+    {
+        StyleSheetEntryPtr pEmptyPtr;
+        return pEmptyPtr;
+    }
     if( m_pImpl->m_pCurrentEntry)
         sBaseStyle = m_pImpl->m_pCurrentEntry->sBaseStyleIdentifier;
 
-    const StyleSheetEntry* pRet = 0;
-    for( sal_uInt32 nPos = 0; nPos < m_pImpl->m_aStyleSheetEntries.size(); ++nPos )
-    {
-        if( m_pImpl->m_aStyleSheetEntries[nPos].sStyleIdentifierD == sBaseStyle )
-        {
-            pRet = &m_pImpl->m_aStyleSheetEntries[nPos];
-            break;
-        }
-    }
-    return pRet;
+    return FindStyleSheetByISTD( sBaseStyle );
 }
 /*-- 21.12.2006 15:58:23---------------------------------------------------
 
@@ -1187,12 +1466,12 @@ static const sal_Char *aStyleNamePairs[] =
     "Index 1",                   "Index 1",                 
     "Index 2",                   "Index 2",                 
     "Index 3",                   "Index 3",                 
-    "Index 4",                   0,                         
-    "Index 5",                   0,                         
-    "Index 6",                   0,                         
-    "Index 7",                   0,                         
-    "Index 8",                   0,                         
-    "Index 9",                   0,                         
+    "Index 4",                   "",                         
+    "Index 5",                   "",                         
+    "Index 6",                   "",                         
+    "Index 7",                   "",                         
+    "Index 8",                   "",                         
+    "Index 9",                   "",                         
     "TOC 1",                     "Contents 1",              
     "TOC 2",                     "Contents 2",              
     "TOC 3",                     "Contents 3",              
@@ -1222,46 +1501,46 @@ static const sal_Char *aStyleNamePairs[] =
     "TOC7",                     "Contents 7",
     "TOC8",                     "Contents 8",
     "TOC9",                     "Contents 9",
-    "Normal Indent",             0,                         
+    "Normal Indent",             "",                         
     "Footnote Text",             "Footnote",                
-    "Annotation Text",           0,                         
+    "Annotation Text",           "",                         
     "Header",                    "Header",                  
     "header",                    "Header",                  
     "Footer",                    "Footer",                  
     "footer",                    "Footer",                  
     "Index Heading",             "Index Heading",           
-    "Caption",                   0,                         
-    "Table of Figures",          0,                         
+    "Caption",                   "",                         
+    "Table of Figures",          "",                         
     "Envelope Address",          "Addressee",               
     "Envelope Return",           "Sender",                  
     "Footnote Reference",        "Footnote anchor",         
-    "Annotation Reference",      0,                         
+    "Annotation Reference",      "",                         
     "Line Number",               "Line numbering",          
     "Page Number",               "Page Number",             
     "Endnote Reference",         "Endnote anchor",          
     "Endnote Text",              "Endnote Symbol",          
-    "Table of Authorities",      0,                         
-    "Macro Text",                0,                         
-    "TOA Heading",               0,                         
+    "Table of Authorities",      "",                         
+    "Macro Text",                "",                         
+    "TOA Heading",               "",                         
     "List",                      "List",                    
-    "List 2",                    0,                         
-    "List 3",                    0,                         
-    "List 4",                    0,                         
-    "List 5",                    0,                         
-    "List Bullet",               0,                         
-    "List Bullet 2",             0,                         
-    "List Bullet 3",             0,                         
-    "List Bullet 4",             0,                         
-    "List Bullet 5",             0,                         
-    "List Number",               0,                         
-    "List Number 2",             0,                         
-    "List Number 3",             0,                         
-    "List Number 4",             0,                         
-    "List Number 5",             0,                         
+    "List 2",                    "",                         
+    "List 3",                    "",                         
+    "List 4",                    "",                         
+    "List 5",                    "",                         
+    "List Bullet",               "",                         
+    "List Bullet 2",             "",                         
+    "List Bullet 3",             "",                         
+    "List Bullet 4",             "",                         
+    "List Bullet 5",             "",                         
+    "List Number",               "",                         
+    "List Number 2",             "",                         
+    "List Number 3",             "",                         
+    "List Number 4",             "",                         
+    "List Number 5",             "",                         
     "Title",                     "Title",                   
-    "Closing",                   0,                         
+    "Closing",                   "",                         
     "Signature",                 "Signature",               
-    "Default Paragraph Font",    0,                         
+    "Default Paragraph Font",    "",                         
     "DefaultParagraphFont",      "Default Paragraph Font",
     "Body Text",                 "Text body",               
     "BodyText",                  "Text body",
@@ -1269,29 +1548,29 @@ static const sal_Char *aStyleNamePairs[] =
     "Body Text Indent",          "Text body indent",        
     "BodyTextIndent",           "Text body indent",
     "BodyTextIndent2",          "Text body indent2",
-    "List Continue",             0,                         
-    "List Continue 2",           0,                         
-    "List Continue 3",           0,                         
-    "List Continue 4",           0,                         
-    "List Continue 5",           0,                         
-    "Message Header",            0,                         
+    "List Continue",             "",                         
+    "List Continue 2",           "",                         
+    "List Continue 3",           "",                         
+    "List Continue 4",           "",                         
+    "List Continue 5",           "",                         
+    "Message Header",            "",                         
     "Subtitle",                  "Subtitle",                
-    "Salutation",                0,                         
-    "Date",                      0,                         
+    "Salutation",                "",                         
+    "Date",                      "",                         
     "Body Text First Indent",    "Body Text Indent",        
-    "Body Text First Indent 2",  0,                         
-    "Note Heading",              0,                         
-    "Body Text 2",               0,                         
-    "Body Text 3",               0,                         
-    "Body Text Indent 2",        0,                         
-    "Body Text Indent 3",        0,                         
-    "Block Text",                0,                         
+    "Body Text First Indent 2",  "",                         
+    "Note Heading",              "",                         
+    "Body Text 2",               "",                         
+    "Body Text 3",               "",                         
+    "Body Text Indent 2",        "",                         
+    "Body Text Indent 3",        "",                         
+    "Block Text",                "",                         
     "Hyperlink",                 "Internet link",           
     "Followed Hyperlink",        "Visited Internet Link",   
     "Strong",                    "Strong Emphasis",         
     "Emphasis",                  "Emphasis",                
-    "Document Map",              0,                         
-    "Plain Text",                0,
+    "Document Map",              "",                         
+    "Plain Text",                "",
     "NoList",                   "No List",
     "AbstractHeading",          "Abstract Heading",
     "AbstractBody",             "Abstract Body",
@@ -1307,12 +1586,12 @@ static const sal_Char *aStyleNamePairs[] =
     if( bExtendedSearch )
     {
         //search for the rWWName in the IdentifierD of the existing styles and convert the sStyleName member
-        std::vector< StyleSheetEntry >::iterator aIt = m_pImpl->m_aStyleSheetEntries.begin();
+        std::vector< StyleSheetEntryPtr >::iterator aIt = m_pImpl->m_aStyleSheetEntries.begin();
         //TODO: performance issue - put styles list into a map sorted by it's sStyleIdentifierD members
         while( aIt != m_pImpl->m_aStyleSheetEntries.end() )
         {
-            if( rWWName == aIt->sStyleIdentifierD ) 
-                sRet = aIt->sStyleName;
+            if( rWWName == ( *aIt )->sStyleIdentifierD ) 
+                sRet = ( *aIt )->sStyleName;
             ++aIt;
         }    
     }    
diff --git writerfilter/source/dmapper/StyleSheetTable.hxx writerfilter/source/dmapper/StyleSheetTable.hxx
index 2cab554..9c01dbc 100644
--- writerfilter/source/dmapper/StyleSheetTable.hxx
+++ writerfilter/source/dmapper/StyleSheetTable.hxx
@@ -30,6 +30,8 @@
 #ifndef INCLUDED_STYLESHEETTABLE_HXX
 #define INCLUDED_STYLESHEETTABLE_HXX
 
+#include "TblStylePrHandler.hxx"
+
 #include <WriterFilterDllApi.hxx>
 #include <dmapper/DomainMapper.hxx>
 #include <com/sun/star/lang/XComponent.hpp>
@@ -41,6 +43,7 @@ namespace com{ namespace sun { namespace star { namespace text{
     class XTextDocument;
 }}}}
 
+
 namespace writerfilter {
 namespace dmapper
 {
@@ -72,6 +75,9 @@ struct StyleSheetEntry
     ::rtl::OUString sConvertedStyleName;
     StyleSheetEntry();
 };
+
+typedef boost::shared_ptr<StyleSheetEntry> StyleSheetEntryPtr;
+
 class DomainMapper;
 class WRITERFILTER_DLLPRIVATE StyleSheetTable :
         public Properties,
@@ -92,11 +98,11 @@ public:
     virtual void entry(int pos, writerfilter::Reference<Properties>::Pointer_t ref);
 
     void ApplyStyleSheets( FontTablePtr rFontTable );
-    const StyleSheetEntry* FindStyleSheetByISTD(const ::rtl::OUString& sIndex);
-    const StyleSheetEntry* FindStyleSheetByStyleName(const ::rtl::OUString& rIndex);
-    const StyleSheetEntry* FindStyleSheetByConvertedStyleName(const ::rtl::OUString& rIndex);
+    const StyleSheetEntryPtr FindStyleSheetByISTD(const ::rtl::OUString& sIndex);
+    const StyleSheetEntryPtr FindStyleSheetByStyleName(const ::rtl::OUString& rIndex);
+    const StyleSheetEntryPtr FindStyleSheetByConvertedStyleName(const ::rtl::OUString& rIndex);
     // returns the parent of the one with the given name - if empty the parent of the current style sheet is returned
-    const StyleSheetEntry* FindParentStyleSheet(::rtl::OUString sBaseStyle);
+    const StyleSheetEntryPtr FindParentStyleSheet(::rtl::OUString sBaseStyle);
 
     ::rtl::OUString ConvertStyleName( const ::rtl::OUString& rWWName, bool bExtendedSearch = false );
     ::rtl::OUString GetStyleIdFromIndex(const sal_uInt32 sti);
@@ -110,6 +116,38 @@ private:
 };
 typedef boost::shared_ptr< StyleSheetTable >    StyleSheetTablePtr;
 
+
+class WRITERFILTER_DLLPRIVATE TableStyleSheetEntry : 
+    public StyleSheetEntry
+{
+private:
+    typedef std::map<TblStyleType, PropertyMapPtr> TblStylePrs;
+
+    StyleSheetTable* m_pStyleSheet;
+    TblStylePrs m_aStyles;
+
+public:
+
+    short m_nColBandSize;
+    short m_nRowBandSize;
+
+    // Adds a new tblStylePr to the table style entry. This method
+    // fixes some possible properties conflicts, like borders ones.
+    void AddTblStylePr( TblStyleType nType, PropertyMapPtr pProps );
+
+    // Gets all the properties 
+    //     + corresponding to the mask,
+    //     + from the parent styles
+    PropertyMapPtr GetProperties( sal_Int32 nMask );
+
+    TableStyleSheetEntry( StyleSheetEntry& aEntry, StyleSheetTable* pStyles );
+    ~TableStyleSheetEntry( );
+
+protected:
+    PropertyMapPtr GetLocalPropertiesFromMask( sal_Int32 nMask );
+};
+typedef boost::shared_ptr<TableStyleSheetEntry> TableStyleSheetEntryPtr;
+
 }}
 
 #endif //
diff --git writerfilter/source/dmapper/TDefTableHandler.cxx writerfilter/source/dmapper/TDefTableHandler.cxx
index d695299..1ef9e8a 100644
--- writerfilter/source/dmapper/TDefTableHandler.cxx
+++ writerfilter/source/dmapper/TDefTableHandler.cxx
@@ -155,6 +155,11 @@ void TDefTableHandler::attribute(Id rName, Value & rVal)
         case NS_rtf::LN_UNUSED2_15: // 0x2877
             // ignored
         break;
+        case NS_ooxml::LN_CT_Border_themeColor:
+        case NS_ooxml::LN_CT_Border_themeTint:
+        case NS_ooxml::LN_CT_Border_themeShade:
+            // ignored
+        break;
         default:
             OSL_ENSURE(false, "unknown attribute");
     }
@@ -199,6 +204,12 @@ void TDefTableHandler::localResolve(Id rName, writerfilter::Reference<Properties
             case NS_rtf::LN_BRCRIGHT:
                 m_aRightBorderLines.push_back(aBorderLine);
             break;
+            case NS_ooxml::LN_CT_TcBorders_insideH:
+                m_aInsideHBorderLines.push_back(aBorderLine);
+            break;
+            case NS_ooxml::LN_CT_TcBorders_insideV:
+                m_aInsideVBorderLines.push_back(aBorderLine);
+            break;
             default:;
         }
     }
@@ -219,6 +230,10 @@ void TDefTableHandler::sprm(Sprm & rSprm)
         case NS_ooxml::LN_CT_TcBorders_bottom: 
         /* WRITERFILTERSTATUS: done: 1, planned: 0, spent: 0 */
         case NS_ooxml::LN_CT_TcBorders_right:
+        case NS_ooxml::LN_CT_TcBorders_insideH:
+        case NS_ooxml::LN_CT_TcBorders_insideV:
+        case NS_ooxml::LN_CT_TcBorders_tl2br: 
+        case NS_ooxml::LN_CT_TcBorders_tr2bl:
         {    
             writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
             localResolve( rSprm.getId(), pProperties );
@@ -281,6 +296,10 @@ void TDefTableHandler::fillCellProperties(
         pCellProperties->Insert( PROP_BOTTOM_BORDER, false, uno::makeAny( m_aBottomBorderLines[nCell] ) );
     if( m_aRightBorderLines.size() > nCell )
         pCellProperties->Insert( PROP_RIGHT_BORDER, false, uno::makeAny( m_aRightBorderLines[nCell] ) );
+    if( m_aInsideHBorderLines.size() > nCell )
+        pCellProperties->Insert( META_PROP_HORIZONTAL_BORDER, false, uno::makeAny( m_aInsideHBorderLines[nCell] ) );
+    if( m_aInsideVBorderLines.size() > nCell )
+        pCellProperties->Insert( META_PROP_VERTICAL_BORDER, false, uno::makeAny( m_aInsideVBorderLines[nCell] ) );
 }
 /*-- 09.05.2007 13:14:17---------------------------------------------------
 
diff --git writerfilter/source/dmapper/TDefTableHandler.hxx writerfilter/source/dmapper/TDefTableHandler.hxx
index f5a720c..22e2682 100644
--- writerfilter/source/dmapper/TDefTableHandler.hxx
+++ writerfilter/source/dmapper/TDefTableHandler.hxx
@@ -56,6 +56,10 @@ private:
     ::std::vector< ::com::sun::star::table::BorderLine >    m_aRightBorderLines;
     ::std::vector< ::com::sun::star::table::BorderLine >    m_aTopBorderLines;
     ::std::vector< ::com::sun::star::table::BorderLine >    m_aBottomBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine >    m_aInsideHBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine >    m_aInsideVBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine >    m_aTl2brBorderLines;
+    ::std::vector< ::com::sun::star::table::BorderLine >    m_aTr2blBorderLines;
 
     //values of the current border
     sal_Int32                                           m_nLineWidth;
diff --git writerfilter/source/dmapper/TablePropertiesHandler.cxx writerfilter/source/dmapper/TablePropertiesHandler.cxx
new file mode 100644
index 0000000..e7bc423
--- /dev/null
+++ writerfilter/source/dmapper/TablePropertiesHandler.cxx
@@ -0,0 +1,217 @@
+#include "BorderHandler.hxx"
+#include "CellColorHandler.hxx"
+#include "CellMarginHandler.hxx"
+#include "ConversionHelper.hxx"
+#include "MeasureHandler.hxx"
+#include "TablePropertiesHandler.hxx"
+#include "TDefTableHandler.hxx"
+
+#include <ooxml/resourceids.hxx>
+#include <doctok/sprmids.hxx>
+
+#include <com/sun/star/text/SizeType.hpp>
+#include <com/sun/star/text/VertOrientation.hpp>
+
+
+namespace writerfilter {
+namespace dmapper {
+
+    TablePropertiesHandler::TablePropertiesHandler( bool bOOXML ) :
+        m_pTableManager( NULL ),
+        m_bOOXML( bOOXML )
+    {
+    }
+
+
+    TablePropertiesHandler::~TablePropertiesHandler( )
+    {
+        // Do not delete the table manager... this will be done somewhere else
+        m_pTableManager = NULL;
+    }
+
+    bool TablePropertiesHandler::sprm(Sprm & rSprm)
+    {
+        bool bRet = true;
+        sal_uInt32 nSprmId = rSprm.getId();
+        Value::Pointer_t pValue = rSprm.getValue();
+        sal_Int32 nIntValue = ((pValue.get() != NULL) ? pValue->getInt() : 0);
+        /* WRITERFILTERSTATUS: table: table_sprmdata */
+        switch( nSprmId )
+       {
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 2 */
+            case NS_ooxml::LN_CT_TrPrBase_jc: //90706
+            /* WRITERFILTERSTATUS: done: 1, planned: 0.5, spent: 0.5 */
+            case NS_ooxml::LN_CT_TblPrBase_jc:
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 2 */
+            case 0x5400: // sprmTJc
+            {
+                //table justification 0: left, 1: center, 2: right
+                sal_Int16 nOrient = ConversionHelper::convertTableJustification( nIntValue );
+                TablePropertyMapPtr pTableMap( new TablePropertyMap );
+                pTableMap->setValue( TablePropertyMap::HORI_ORIENT, nOrient );
+                insertTableProps( pTableMap );
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
+            case 0x9601: // sprmTDxaLeft
+            break;  
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0x9602: // sprmTDxaGapHalf
+            {    
+                //m_nGapHalf = ConversionHelper::convertTwipToMM100( nIntValue );
+                TablePropertyMapPtr pPropMap( new TablePropertyMap );
+                pPropMap->setValue( TablePropertyMap::GAP_HALF, ConversionHelper::convertTwipToMM100( nIntValue ) );
+                insertTableProps(pPropMap);
+            }
+            break;  
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 2 */
+            case NS_ooxml::LN_CT_TrPrBase_trHeight: //90703
+            {
+                //contains unit and value 
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if( pProperties.get())
+                {   //contains attributes x2902 (LN_unit) and x17e2 (LN_trleft)
+                    MeasureHandlerPtr pMeasureHandler( new MeasureHandler );
+                    pProperties->resolve(*pMeasureHandler);
+                    TablePropertyMapPtr pPropMap( new TablePropertyMap );
+                    pPropMap->Insert( PROP_SIZE_TYPE, false, uno::makeAny( pMeasureHandler->GetRowHeightSizeType() ));
+                    pPropMap->Insert( PROP_HEIGHT, false, uno::makeAny(pMeasureHandler->getMeasureValue() ));
+                    insertRowProps(pPropMap);
+                }
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0x3403: // sprmTFCantSplit
+            case NS_sprm::LN_TCantSplit: // 0x3644
+            {    
+                //row can't break across pages if nIntValue == 1
+                TablePropertyMapPtr pPropMap( new TablePropertyMap );
+                pPropMap->Insert( PROP_IS_SPLIT_ALLOWED, false, uno::makeAny(sal_Bool( nIntValue == 1 ? sal_False : sal_True ) ));
+                insertRowProps(pPropMap);
+            }
+            break;  
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0x9407: // sprmTDyaRowHeight
+            {    
+                // table row height - negative values indicate 'exact height' - positive 'at least'
+                TablePropertyMapPtr pPropMap( new TablePropertyMap );
+                bool bMinHeight = true;
+                sal_Int16 nHeight = static_cast<sal_Int16>( nIntValue );
+                if( nHeight < 0 )
+                {
+                    bMinHeight = false;
+                    nHeight *= -1;
+                }    
+                pPropMap->Insert( PROP_SIZE_TYPE, false, uno::makeAny(bMinHeight ? text::SizeType::MIN : text::SizeType::FIX ));
+                pPropMap->Insert( PROP_HEIGHT, false, uno::makeAny(ConversionHelper::convertTwipToMM100( nHeight )));
+                insertRowProps(pPropMap);
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case NS_ooxml::LN_CT_TcPrBase_vAlign://90694
+            {    
+                sal_Int16 nVertOrient = text::VertOrientation::NONE;
+                switch( nIntValue ) //0 - top 1 - center 3 - bottom
+                {
+                    case 1: nVertOrient = text::VertOrientation::CENTER; break;
+                    case 3: nVertOrient = text::VertOrientation::BOTTOM; break;
+                    default:;
+                };
+                TablePropertyMapPtr pCellPropMap( new TablePropertyMap() );
+                pCellPropMap->Insert( PROP_VERT_ORIENT, false, uno::makeAny( nVertOrient ) );
+                //todo: in ooxml import the value of m_ncell is wrong
+                cellProps( pCellPropMap );
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case NS_ooxml::LN_CT_TblPrBase_tblBorders: //table borders, might be defined in table style
+            {    
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if( pProperties.get())
+                {
+                    BorderHandlerPtr pBorderHandler( new BorderHandler(m_bOOXML) );
+                    pProperties->resolve(*pBorderHandler);
+                    TablePropertyMapPtr pTablePropMap( new TablePropertyMap );
+                    pTablePropMap->insert( pBorderHandler->getProperties() );
+                    insertTableProps( pTablePropMap );
+                }
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case NS_ooxml::LN_CT_TcPrBase_tcBorders ://cell borders
+            //contains CT_TcBorders_left, right, top, bottom
+            {    
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if( pProperties.get())
+                {
+                    //in OOXML there's one set of borders at each cell (if there is any)
+                    TDefTableHandlerPtr pTDefTableHandler( new TDefTableHandler( m_bOOXML ));
+                    pProperties->resolve( *pTDefTableHandler );
+                    TablePropertyMapPtr pCellPropMap( new TablePropertyMap );
+                    pTDefTableHandler->fillCellProperties( 0, pCellPropMap );
+                    cellProps( pCellPropMap );
+                }    
+            }
+            break;
+            case NS_ooxml::LN_CT_TblPrBase_shd:
+            {    
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if( pProperties.get())
+                {
+                    CellColorHandlerPtr pCellColorHandler( new CellColorHandler);
+                    pProperties->resolve( *pCellColorHandler );
+                    TablePropertyMapPtr pTablePropMap( new TablePropertyMap );
+                    insertTableProps( pCellColorHandler->getProperties() );
+                }    
+            }
+            break;
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0xd61a : // sprmTCellTopColor
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0xd61b : // sprmTCellLeftColor
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0xd61c : // sprmTCellBottomColor
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case 0xd61d : // sprmTCellRightColor
+            /* WRITERFILTERSTATUS: done: 1, planned: 2, spent: 0 */
+            case NS_ooxml::LN_CT_TcPrBase_shd:
+            {    
+                // each color sprm contains as much colors as cells are in a row
+                //LN_CT_TcPrBase_shd: cell shading contains: LN_CT_Shd_val, LN_CT_Shd_fill, LN_CT_Shd_color
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if( pProperties.get())
+                {
+                    CellColorHandlerPtr pCellColorHandler( new CellColorHandler );
+                    pProperties->resolve( *pCellColorHandler );
+                    cellProps( pCellColorHandler->getProperties());
+                }    
+            }
+            break;
+//OOXML table properties            
+            /* WRITERFILTERSTATUS: done: 0, planned: 2, spent: 0 */
+            case NS_ooxml::LN_CT_TblPrBase_tblCellMar: //cell margins
+            {    
+                //contains LN_CT_TblCellMar_top, LN_CT_TblCellMar_left, LN_CT_TblCellMar_bottom, LN_CT_TblCellMar_right
+                writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+                if( pProperties.get())
+                {
+                    CellMarginHandlerPtr pCellMarginHandler( new CellMarginHandler );
+                    pProperties->resolve( *pCellMarginHandler );
+                    TablePropertyMapPtr pMarginProps( new TablePropertyMap );
+                    if( pCellMarginHandler->m_bTopMarginValid )
+                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_TOP, pCellMarginHandler->m_nTopMargin );
+                    if( pCellMarginHandler->m_bBottomMarginValid )
+                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_BOTTOM, pCellMarginHandler->m_nBottomMargin );
+                    if( pCellMarginHandler->m_bLeftMarginValid )
+                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_LEFT, pCellMarginHandler->m_nLeftMargin );
+                    if( pCellMarginHandler->m_bRightMarginValid )
+                        pMarginProps->setValue( TablePropertyMap::CELL_MAR_RIGHT, pCellMarginHandler->m_nRightMargin );
+                    insertTableProps(pMarginProps);
+                }    
+            }
+            break;
+            default: bRet = false;
+        }
+        return bRet;
+    }
+}}
diff --git writerfilter/source/dmapper/TablePropertiesHandler.hxx writerfilter/source/dmapper/TablePropertiesHandler.hxx
new file mode 100644
index 0000000..9c91b41
--- /dev/null
+++ writerfilter/source/dmapper/TablePropertiesHandler.hxx
@@ -0,0 +1,84 @@
+#ifndef INCLUDED_TABLEPROPERTIESHANDLER_HXX
+#define INCLUDED_TABLEPROPERTIESHANDLER_HXX
+
+#include <PropertyMap.hxx>
+
+#include <resourcemodel/TableManager.hxx>
+#include <WriterFilterDllApi.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+
+#include <boost/shared_ptr.hpp>
+
+#include <vector>
+
+namespace writerfilter {
+namespace dmapper {
+
+using namespace std;
+
+typedef ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > Handle_t;
+typedef TableManager<Handle_t , TablePropertyMapPtr > DomainMapperTableManager_Base_t;
+
+class TablePropertiesHandler
+{
+private:
+    vector< PropertyMapPtr > m_rPropertiesStack;
+    PropertyMapPtr m_pCurrentProperties;
+    DomainMapperTableManager_Base_t *m_pTableManager;
+    bool m_bOOXML;
+
+public:
+    TablePropertiesHandler( bool bOOXML );
+    virtual ~TablePropertiesHandler( );
+
+    bool sprm(Sprm & sprm); 
+
+    inline void SetTableManager( DomainMapperTableManager_Base_t *pTableManager )
+    {
+        m_pTableManager = pTableManager;
+    };
+
+    inline void SetProperties( PropertyMapPtr pProperties )
+    {
+        m_pCurrentProperties = pProperties;
+    };
+
+private:
+
+    inline void cellProps( TablePropertyMapPtr pProps )
+    {
+        if ( m_pTableManager )
+            m_pTableManager->cellProps( pProps );
+        else
+            m_pCurrentProperties->insert( pProps, true );
+    };
+
+    inline void cellPropsByCell( unsigned int i, TablePropertyMapPtr pProps )
+    {
+        if ( m_pTableManager )
+            m_pTableManager->cellPropsByCell( i, pProps );
+        else
+            m_pCurrentProperties->insert( pProps, true );
+    };
+
+    inline void insertRowProps( TablePropertyMapPtr pProps )
+    {
+        if ( m_pTableManager )
+            m_pTableManager->insertRowProps( pProps );
+        else
+            m_pCurrentProperties->insert( pProps, true );
+    };
+
+    inline void insertTableProps( TablePropertyMapPtr pProps )
+    {
+        if ( m_pTableManager )
+            m_pTableManager->insertTableProps( pProps );
+        else
+            m_pCurrentProperties->insert( pProps, true );
+    };
+};
+typedef boost::shared_ptr<TablePropertiesHandler> TablePropertiesHandlerPtr;
+
+} }
+
+#endif
diff --git writerfilter/source/dmapper/TblStylePrHandler.cxx writerfilter/source/dmapper/TblStylePrHandler.cxx
new file mode 100644
index 0000000..8f901ec
--- /dev/null
+++ writerfilter/source/dmapper/TblStylePrHandler.cxx
@@ -0,0 +1,69 @@
+#include <TblStylePrHandler.hxx>
+#include <PropertyMap.hxx>
+#include <ooxml/resourceids.hxx>
+
+namespace writerfilter {
+namespace dmapper {
+
+TblStylePrHandler::TblStylePrHandler( DomainMapper & rDMapper ) :
+   m_rDMapper( rDMapper ), 
+   m_pTablePropsHandler( new TablePropertiesHandler( true ) ),
+   m_nType( TBL_STYLE_UNKNOWN ),
+   m_pProperties( new PropertyMap )
+{
+}
+
+TblStylePrHandler::~TblStylePrHandler( )
+{
+    delete m_pTablePropsHandler, m_pTablePropsHandler = NULL;
+}
+
+void TblStylePrHandler::attribute(Id rName, Value & rVal)
+{
+    switch ( rName )
+    {
+        case NS_ooxml::LN_CT_TblStyleOverrideType:
+            {
+                // The tokenid should be the same in the model.xml than
+                // in the TblStyleType enum
+                m_nType = TblStyleType( rVal.getInt( ) );
+            }
+            break;
+    }
+}
+
+void TblStylePrHandler::sprm(Sprm & rSprm)
+{
+    Value::Pointer_t pValue = rSprm.getValue();
+    switch ( rSprm.getId( ) )
+    {
+        case NS_ooxml::LN_CT_PPrBase:
+        case NS_ooxml::LN_EG_RPrBase:
+        case NS_ooxml::LN_CT_TblPrBase:
+        case NS_ooxml::LN_CT_TrPrBase: 
+        case NS_ooxml::LN_CT_TcPrBase:
+            resolveSprmProps( rSprm );
+            break;
+        default:
+            // Tables specific properties have to handled here
+            m_pTablePropsHandler->SetProperties( m_pProperties );
+            bool bRet = m_pTablePropsHandler->sprm( rSprm );
+
+            if ( !bRet )
+            {
+                // The DomainMapper can handle some of the properties
+                m_rDMapper.PushStyleSheetProperties( m_pProperties, true );
+                m_rDMapper.sprm( rSprm );
+                m_rDMapper.PopStyleSheetProperties( true );
+            }
+    }
+}
+
+void TblStylePrHandler::resolveSprmProps(Sprm & rSprm)
+{
+    writerfilter::Reference<Properties>::Pointer_t pProperties = rSprm.getProps();
+    if( pProperties.get())
+        pProperties->resolve(*this);
+}
+
+}}
diff --git writerfilter/source/dmapper/TblStylePrHandler.hxx writerfilter/source/dmapper/TblStylePrHandler.hxx
new file mode 100644
index 0000000..4b1298e
--- /dev/null
+++ writerfilter/source/dmapper/TblStylePrHandler.hxx
@@ -0,0 +1,64 @@
+#ifndef INCLUDED_TBLSTYLEPRHANDLER_HXX
+#define INCLUDED_TBLSTYLEPRHANDLER_HXX
+
+#include "TablePropertiesHandler.hxx"
+
+#include <dmapper/DomainMapper.hxx>
+#include <WriterFilterDllApi.hxx>
+#include <resourcemodel/WW8ResourceModel.hxx>
+#include <boost/shared_ptr.hpp>
+
+namespace writerfilter {
+namespace dmapper {
+
+class DomainMapper;
+class PropertyMap;
+    
+enum TblStyleType
+{
+    TBL_STYLE_UNKNOWN,
+    TBL_STYLE_WHOLETABLE,
+    TBL_STYLE_FIRSTROW,
+    TBL_STYLE_LASTROW,
+    TBL_STYLE_FIRSTCOL,
+    TBL_STYLE_LASTCOL,
+    TBL_STYLE_BAND1VERT,
+    TBL_STYLE_BAND2VERT,
+    TBL_STYLE_BAND1HORZ,
+    TBL_STYLE_BAND2HORZ,
+    TBL_STYLE_NECELL,
+    TBL_STYLE_NWCELL,
+    TBL_STYLE_SECELL,
+    TBL_STYLE_SWCELL
+};
+
+class WRITERFILTER_DLLPRIVATE TblStylePrHandler : public Properties
+{
+private:
+    DomainMapper &              m_rDMapper;
+    TablePropertiesHandler *    m_pTablePropsHandler;
+
+    TblStyleType                m_nType;
+    PropertyMapPtr              m_pProperties;
+
+public:
+    TblStylePrHandler( DomainMapper & rDMapper );
+    virtual ~TblStylePrHandler( );
+    
+    // Properties
+    virtual void attribute(Id Name, Value & val);
+    virtual void sprm(Sprm & sprm);
+    
+    inline PropertyMapPtr       getProperties() { return m_pProperties; };
+    inline TblStyleType         getType() { return m_nType; };
+
+private:
+
+    void resolveSprmProps(Sprm & rSprm);
+};
+
+typedef boost::shared_ptr< TblStylePrHandler > TblStylePrHandlerPtr;
+
+}}
+
+#endif
diff --git writerfilter/source/dmapper/makefile.mk writerfilter/source/dmapper/makefile.mk
index 012b45d..5f42164 100644
--- writerfilter/source/dmapper/makefile.mk
+++ writerfilter/source/dmapper/makefile.mk
@@ -43,6 +43,9 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Files -------------------------------------
 
 SLOFILES=           $(SLO)$/BorderHandler.obj \
+                    $(SLO)$/TblStylePrHandler.obj \
+                    $(SLO)$/GraphicHelpers.obj \
+                    $(SLO)$/TablePropertiesHandler.obj \
                     $(SLO)$/CellColorHandler.obj \
                     $(SLO)$/CellMarginHandler.obj \
                     $(SLO)$/SectionColumnHandler.obj \
@@ -60,9 +63,11 @@ SLOFILES=           $(SLO)$/BorderHandler.obj \
                     $(SLO)$/PropertyIds.obj  \
                     $(SLO)$/StyleSheetTable.obj \
                     $(SLO)$/TDefTableHandler.obj \
-		    $(SLO)$/ThemeTable.obj \
+                    $(SLO)$/ThemeTable.obj \
+                    $(SLO)$/SettingsTable.obj \
                     $(SLO)$/ModelEventListener.obj\
-                    $(SLO)$/OLEHandler.obj
+                    $(SLO)$/OLEHandler.obj \
+                    $(SLO)$/PageBordersHandler.obj 
 
 # --- Targets ----------------------------------
 
diff --git writerfilter/source/ooxml/OOXMLDocumentImpl.cxx writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
index 542cf81..41a3e6c 100644
--- writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
+++ writerfilter/source/ooxml/OOXMLDocumentImpl.cxx
@@ -48,7 +48,7 @@ using namespace ::std;
 
 OOXMLDocumentImpl::OOXMLDocumentImpl
 (OOXMLStream::Pointer_t pStream)
-: mpStream(pStream), mXNoteType(0)
+: mpStream(pStream), mXNoteType(0), mbIsSubstream( false )
 {
 }
 
@@ -138,6 +138,7 @@ OOXMLDocumentImpl::getSubStream(const rtl::OUString & rId)
     writerfilter::Reference<Stream>::Pointer_t pRet( pTemp = new OOXMLDocumentImpl(pStream) );
     pTemp->setModel(mxModel);
     pTemp->setShapes(mxShapes);
+    pTemp->setIsSubstream( true );
     return pRet;
 }
 
@@ -317,6 +318,7 @@ void OOXMLDocumentImpl::resolve(Stream & rStream)
         pDocHandler->setStream(&rStream);
         pDocHandler->setDocument(this);
         pDocHandler->setXNoteId(msXNoteId);
+        pDocHandler->setIsSubstream( mbIsSubstream );
         uno::Reference < xml::sax::XFastDocumentHandler > xDocumentHandler
             (pDocHandler);
         uno::Reference < xml::sax::XFastTokenHandler > xTokenHandler
diff --git writerfilter/source/ooxml/OOXMLDocumentImpl.hxx writerfilter/source/ooxml/OOXMLDocumentImpl.hxx
index 7d736b3..5f8cad7 100644
--- writerfilter/source/ooxml/OOXMLDocumentImpl.hxx
+++ writerfilter/source/ooxml/OOXMLDocumentImpl.hxx
@@ -53,6 +53,8 @@ class OOXMLDocumentImpl : public OOXMLDocument
     uno::Reference<frame::XModel> mxModel;
     uno::Reference<drawing::XShapes> mxShapes;
 
+    bool mbIsSubstream;
+
 protected:
     virtual void resolveFastSubStream(Stream & rStream, 
                                       OOXMLStream::StreamType_t nType);
@@ -69,6 +71,10 @@ protected:
                    const Id & rType,
                    const rtl::OUString & rNoteId);
 
+    writerfilter::Reference<Stream>::Pointer_t;
+
+    void setIsSubstream( bool bSubstream ) { mbIsSubstream = bSubstream; };
+
 public:
     OOXMLDocumentImpl(OOXMLStream::Pointer_t pStream);
     virtual ~OOXMLDocumentImpl();
diff --git writerfilter/source/ooxml/OOXMLFastContextHandler.cxx writerfilter/source/ooxml/OOXMLFastContextHandler.cxx
index c6e81d5..5e168cd 100644
--- writerfilter/source/ooxml/OOXMLFastContextHandler.cxx
+++ writerfilter/source/ooxml/OOXMLFastContextHandler.cxx
@@ -752,6 +752,7 @@ void OOXMLFastContextHandler::setLastParagraphInSection()
 #endif
 
     mpParserState->setLastParagraphInSection(true);
+    mpStream->markLastParagraphInSection( );
 }
 
 void OOXMLFastContextHandler::newProperty
@@ -1869,6 +1870,16 @@ void OOXMLFastContextHandlerTextTable::lcl_startFastElement
     throw (uno::RuntimeException, xml::sax::SAXException)
 {
     mnTableDepth++;
+        
+    boost::shared_ptr<OOXMLPropertySet> pProps( new OOXMLPropertySetImpl );
+    {
+        OOXMLValue::Pointer_t pVal
+            (new OOXMLIntegerValue(mnTableDepth));
+        OOXMLProperty::Pointer_t pProp
+            (new OOXMLPropertyImpl(NS_ooxml::LN_tblStart, pVal, OOXMLPropertyImpl::SPRM));
+        pProps->add(pProp);
+    }
+    mpParserState->setCharacterProperties(pProps);
 
     startAction(Element);
 }
@@ -1954,7 +1965,7 @@ void SAL_CALL ShapesNoAdd::remove(const uno::Reference< drawing::XShape > & xSha
 
 OOXMLFastContextHandlerShape::OOXMLFastContextHandlerShape
 (OOXMLFastContextHandler * pContext)
-: OOXMLFastContextHandlerProperties(pContext)
+: OOXMLFastContextHandlerProperties(pContext), m_bShapeSent( false )
 {
     uno::Reference<uno::XComponentContext> xContext(getComponentContext());
 
@@ -2010,7 +2021,9 @@ void OOXMLFastContextHandlerShape::lcl_startFastElement
     startAction(Element);
 
     if (mrShapeContext.is())
+    {
         mrShapeContext->startFastElement(Element, Attribs);
+    }
 }
 
 void SAL_CALL OOXMLFastContextHandlerShape::startUnknownElement
@@ -2031,28 +2044,43 @@ void OOXMLFastContextHandlerShape::setToken(Token_t nToken)
         mrShapeContext->setStartToken(nToken);
 }
 
-void OOXMLFastContextHandlerShape::lcl_endFastElement
-(Token_t Element)
-    throw (uno::RuntimeException, xml::sax::SAXException)
+void OOXMLFastContextHandlerShape::sendShape( Token_t Element )
 {
-    if (mrShapeContext.is())
+    if ( mrShapeContext.is() && !m_bShapeSent )
     {
-        mrShapeContext->endFastElement(Element);
-
         uno::Reference<drawing::XShape> xShape(mrShapeContext->getShape());
-
         if (xShape.is())
         {
-            awt::Point aPoint(xShape->getPosition());
-            awt::Size aSize(xShape->getSize());
-
             OOXMLValue::Pointer_t
                 pValue(new OOXMLShapeValue(xShape));
             newProperty(NS_ooxml::LN_shape, pValue);
+            m_bShapeSent = true;
+    
+            bool bIsPicture = Element == ( NS_picture | OOXML_pic );
+      
+            // Notify the dmapper that the shape is ready to use
+            if ( !bIsPicture )
+                mpStream->startShape( xShape );
         }
     }
+}
+
+void OOXMLFastContextHandlerShape::lcl_endFastElement
+(Token_t Element)
+    throw (uno::RuntimeException, xml::sax::SAXException)
+{
+    if (mrShapeContext.is())
+    {
+        mrShapeContext->endFastElement(Element);
+        sendShape( Element );
+    }
 
     OOXMLFastContextHandlerProperties::lcl_endFastElement(Element);
+    
+    // Ending the shape should be the last thing to do
+    bool bIsPicture = Element == ( NS_picture | OOXML_pic );
+    if ( !bIsPicture )
+        mpStream->endShape( );
 }
 
 void SAL_CALL OOXMLFastContextHandlerShape::endUnknownElement
@@ -2093,6 +2121,7 @@ OOXMLFastContextHandlerShape::lcl_createFastChildContext
                 pWrapper->addNamespace(NS_wordprocessingml);
                 pWrapper->addNamespace(NS_vml_wordprocessingDrawing);
                 pWrapper->addNamespace(NS_office);
+                pWrapper->addToken( NS_vml|OOXML_textbox );
 
                 xContextHandler.set(pWrapper);
             }
@@ -2100,6 +2129,7 @@ OOXMLFastContextHandlerShape::lcl_createFastChildContext
                 xContextHandler.set(this);
             break;
     }
+   
 
     return xContextHandler;
 }
@@ -2209,6 +2239,11 @@ void OOXMLFastContextHandlerWrapper::addNamespace(const Id & nId)
     mMyNamespaces.insert(nId);
 }
 
+void OOXMLFastContextHandlerWrapper::addToken( Token_t Token )
+{
+    mMyTokens.insert( Token );
+}
+
 void OOXMLFastContextHandlerWrapper::lcl_startFastElement
 (Token_t Element,
  const uno::Reference< xml::sax::XFastAttributeList > & Attribs)
@@ -2253,7 +2288,9 @@ OOXMLFastContextHandlerWrapper::lcl_createFastChildContext
     debug_logger->endElement("Wrapper-createChildContext");
 #endif
 
-    if (mMyNamespaces.find(nNameSpace) != mMyNamespaces.end())
+    bool bInNamespaces = mMyNamespaces.find(nNameSpace) != mMyNamespaces.end();
+    bool bInTokens = mMyTokens.find( Element ) != mMyTokens.end( );
+    if ( bInNamespaces )
         xResult.set(createFromStart(Element, Attribs));
     else if (mxContext.is())
     {
@@ -2266,6 +2303,12 @@ OOXMLFastContextHandlerWrapper::lcl_createFastChildContext
     }
     else
         xResult.set(this);
+    
+    if ( bInTokens )
+    {
+        OOXMLFastContextHandlerShape* pShapeCtx = (OOXMLFastContextHandlerShape*)mpParent;
+        pShapeCtx->sendShape( Element );
+    }
 
     return xResult;
 }
diff --git writerfilter/source/ooxml/OOXMLFastContextHandler.hxx writerfilter/source/ooxml/OOXMLFastContextHandler.hxx
index 33ad4b4..0958671 100644
--- writerfilter/source/ooxml/OOXMLFastContextHandler.hxx
+++ writerfilter/source/ooxml/OOXMLFastContextHandler.hxx
@@ -558,6 +558,9 @@ protected:
 
 class OOXMLFastContextHandlerShape: public OOXMLFastContextHandlerProperties
 {
+private:
+    bool m_bShapeSent;
+
 public:
     explicit OOXMLFastContextHandlerShape
     (OOXMLFastContextHandler * pContext);
@@ -585,6 +588,9 @@ public:
     virtual void setToken(Token_t nToken);
     
     virtual ResourceEnum_t getResource() const { return SHAPE; }
+
+    void sendShape( Token_t Element );
+
 protected:
     typedef uno::Reference<XFastShapeContextHandler> ShapeContextRef;
     ShapeContextRef mrShapeContext;
@@ -649,6 +655,7 @@ public:
     virtual ResourceEnum_t getResource() const;
 
     void addNamespace(const Id & nId);
+    void addToken( Token_t Element );
 
     virtual void newProperty(const Id & rId, OOXMLValue::Pointer_t pVal);
     virtual void setPropertySet(OOXMLPropertySet::Pointer_t pPropertySet);
@@ -683,6 +690,7 @@ protected:
 private:
     uno::Reference<XFastContextHandler> mxContext;
     set<Id> mMyNamespaces;
+    set<Token_t> mMyTokens;
     OOXMLPropertySet::Pointer_t mpPropertySet;
 
     OOXMLFastContextHandler * getFastContextHandler() const;
diff --git writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx
index 2557387..71a0065 100644
--- writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx
+++ writerfilter/source/ooxml/OOXMLFastDocumentHandler.cxx
@@ -225,4 +225,9 @@ void OOXMLFastDocumentHandler::setXNoteId(const ::rtl::OUString & rXNoteId)
     msXNoteId = rXNoteId;
 }
 
+void OOXMLFastDocumentHandler::setIsSubstream( bool bSubstream ) 
+{ 
+    getContextHandler( )->getParserState( )->setInSectionGroup( bSubstream ); 
+};
+
 }}
diff --git writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx
index c7dfefe..b8ed9a5 100644
--- writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx
+++ writerfilter/source/ooxml/OOXMLFastDocumentHandler.hxx
@@ -100,6 +100,8 @@ public:
     
     OOXMLParserState::Pointer_t getParserState() const;
 
+    void setIsSubstream( bool bSubstream );
+
 private:
     OOXMLFastDocumentHandler(OOXMLFastDocumentHandler &); // not defined
     void operator =(OOXMLFastDocumentHandler &); // not defined
diff --git writerfilter/source/ooxml/makefile.mk writerfilter/source/ooxml/makefile.mk
index 29df82f..35f7db7 100644
--- writerfilter/source/ooxml/makefile.mk
+++ writerfilter/source/ooxml/makefile.mk
@@ -151,6 +151,8 @@ OOXMLGPERFFASTTOKENXSL=gperffasttokenhandler.xsl
 
 OOXMLRESOURCEIDSHXX=$(OOXMLHXXOUTDIR)$/resourceids.hxx
 
+NSPROCESS=namespace_preprocess.pl
+
 TOKENXML=$(OOXMLCXXOUTDIR)$/token.xml
 TOKENXMLTMP=$(OOXMLCXXOUTDIR)$/token.tmp
 
@@ -162,6 +164,7 @@ OOXMLVALUESHXX=$(OOXMLCXXOUTDIR)$/OOXMLvalues.hxx
 OOXMLVALUESCXX=$(OOXMLCXXOUTDIR)$/OOXMLvalues.cxx
 GPERFFASTTOKENHXX=$(OOXMLHXXOUTDIR)$/gperffasttoken.hxx
 MODELPROCESSED=$(MISC)$/model_preprocessed.xml
+NSXSL=$(MISC)$/namespacesmap.xsl
 
 OOXMLGENHEADERS= \
 	$(OOXMLFASTRESOURCESHXX) \
@@ -192,8 +195,12 @@ $(TOKENXMLTMP): $(SOLARVER)$/$(INPATH)$/inc$(UPDMINOREXT)$/oox$/token.txt
 $(TOKENXML): tokenxmlheader $(TOKENXMLTMP) tokenxmlfooter
 	$(TYPE) tokenxmlheader $(TOKENXMLTMP) tokenxmlfooter > $@
 
-$(MODELPROCESSED): $(OOXMLPREPROCESSXSL) $(OOXMLMODEL)
-	$(XSLTPROC) $(OOXMLPREPROCESSXSL) $(OOXMLMODEL) > $@
+$(NSXSL) : $(OOXMLMODEL) $(SOLARVER)$/$(INPATH)$/inc$(UPDMINOREXT)$/oox$/namespaces.txt $(OOXMLPREPROCESSXSL) $(NSPROCESS)
+    $(PERL) $(NSPROCESS) $(SOLARVER)$/$(INPATH)$/inc$(UPDMINOREXT)$/oox$/namespaces.txt $(PWD)$/$(OOXMLPREPROCESSXSL) > $@
+
+
+$(MODELPROCESSED): $(NSXSL) $(OOXMLPREPROCESSXSL) $(OOXMLMODEL)
+	$(XSLTPROC) $(NSXSL) $(OOXMLMODEL) > $@
 
 $(OOXMLHXXOUTDIRCREATED):
 	$(MKDIRHIER) $(OOXMLHXXOUTDIR)
diff --git writerfilter/source/ooxml/model.xml writerfilter/source/ooxml/model.xml
index 8eadd58..7d07b6a 100644
--- writerfilter/source/ooxml/model.xml
+++ writerfilter/source/ooxml/model.xml
@@ -1,23 +1,24 @@
 <?xml version="1.0"?>
 <model xmlns:rng="http://relaxng.org/ns/structure/1.0">
-  <namespace-alias name="http://www.w3.org/XML/1998/namespace" alias="xml" id="1"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/officeDocument/2006/relationships" alias="relationships" id="3"/>
-  <namespace-alias name="urn:schemas-microsoft-com:office:office" alias="office" id="11"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" alias="theme" id="14"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" alias="wordprocessingDrawing" id="15"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/drawingml/2006/main" alias="drawingml" id="21"/>
-  <namespace-alias name="urn:schemas-microsoft-com:vml" alias="vml" id="24"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/drawingml/2006/picture" alias="picture" id="25"/>
-  <namespace-alias name="urn:schemas-microsoft-com:office:word" alias="vml_wordprocessingDrawing" id="32"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/wordprocessingml/2006/main" alias="wordprocessingml" id="60"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/officeDocument/2006/math" alias="math" id="61"/>
-  <namespace-alias name="http://schemas.openxmlformats.org/schemaLibrary/2006/main" alias="schemaLibrary" id="62"/>
-  <namespace-alias name="http://sprm" alias="sprm" id="99"/>
+  <namespace-alias name="http://www.w3.org/XML/1998/namespace" alias="xml" id="XML"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/officeDocument/2006/relationships" alias="relationships" id="RELATIONSHIPS"/>
+  <namespace-alias name="urn:schemas-microsoft-com:office:office" alias="office" id="OFFICE"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" alias="theme" id="THEME"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" alias="wordprocessingDrawing" id="DOC_DRAWINGML"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/drawingml/2006/main" alias="drawingml" id="DRAWINGML"/>
+  <namespace-alias name="urn:schemas-microsoft-com:vml" alias="vml" id="VML"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/drawingml/2006/picture" alias="picture" id="PICTURE"/>
+  <namespace-alias name="urn:schemas-microsoft-com:office:word" alias="vml_wordprocessingDrawing" id="VML_DOC"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/wordprocessingml/2006/main" alias="wordprocessingml" id="DOC"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/officeDocument/2006/math" alias="math" id="MATH"/>
+  <namespace-alias name="http://schemas.openxmlformats.org/schemaLibrary/2006/main" alias="schemaLibrary" id="SML"/>
+  <namespace-alias name="http://sprm" alias="sprm" id="SPRM"/>
   <token tokenid="ooxml:shape"/>
   <token tokenid="ooxml:token"/>
   <token tokenid="ooxml:inputstream"/>
   <token tokenid="ooxml:trackchange"/>
   <token tokenid="ooxml:object"/>
+  <token tokenid="ooxml:tblStart"/>
   <namespace name="dml-stylesheet" url="http://schemas.openxmlformats.org/drawingml/2006/main" file="dml-stylesheet.rng">
     <start name="theme"/>
     <start name="themeOverride"/>
@@ -6505,11 +6506,17 @@
           </element>
         </choice>
       </define>
+      <define name="CT_PositionOffset">
+        <ref name="ST_PositionOffset"/>
+      </define>
       <define name="ST_PositionOffset">
         <data type="int">
           <xs:documentation>Absolute Position Offset Value</xs:documentation>
         </data>
       </define>
+      <define name="CT_AlignH">
+        <ref name="ST_AlignH"/>
+      </define>
       <define name="ST_AlignH">
         <list>
           <xs:documentation>Relative Horizontal Alignment Positions</xs:documentation>
@@ -6553,10 +6560,10 @@
       <define name="CT_PosH">
         <choice>
           <element name="align">
-            <ref name="ST_AlignH"/>
+            <ref name="CT_AlignH"/>
           </element>
           <element name="posOffset">
-            <ref name="ST_PositionOffset"/>
+            <ref name="CT_PositionOffset"/>
           </element>
         </choice>
         <attribute name="relativeFrom">
@@ -6564,6 +6571,9 @@
           <xs:documentation>Horizontal Position Relative Base</xs:documentation>
         </attribute>
       </define>
+      <define name="CT_AlignV">
+        <ref name="ST_AlignV"/>
+      </define>
       <define name="ST_AlignV">
         <list>
           <xs:documentation>Vertical Alignment Definition</xs:documentation>
@@ -6607,10 +6617,10 @@
       <define name="CT_PosV">
         <choice>
           <element name="align">
-            <ref name="ST_AlignV"/>
+            <ref name="CT_AlignV"/>
           </element>
           <element name="posOffset">
-            <ref name="ST_PositionOffset"/>
+            <ref name="CT_PositionOffset"/>
           </element>
         </choice>
         <attribute name="relativeFrom">
@@ -6793,6 +6803,7 @@
       <element name="wrapTopAndBottom" tokenid="ooxml:EG_WrapType_wrapTopAndBottom"/>
     </resource>
     <resource name="ST_PositionOffset" resource="Integer" generated="yes"/>
+    <resource name="CT_PositionOffset" resource="IntegerValue"/>
     <resource name="ST_AlignH" resource="List" generated="yes">
       <value name="left" tokenid="ooxml:Value_wordprocessingDrawing_ST_AlignH_left">left</value>
       <value name="right" tokenid="ooxml:Value_wordprocessingDrawing_ST_AlignH_right">right</value>
@@ -6800,6 +6811,7 @@
       <value name="inside" tokenid="ooxml:Value_wordprocessingDrawing_ST_AlignH_inside">inside</value>
       <value name="outside" tokenid="ooxml:Value_wordprocessingDrawing_ST_AlignH_outside">outside</value>
     </resource>
+    <resource name="CT_AlignH" resource="ListValue"/>
     <resource name="ST_RelFromH" resource="List" generated="yes">
       <value name="margin" tokenid="ooxml:Value_wordprocessingDrawing_ST_RelFromH_margin">margin</value>
       <value name="page" tokenid="ooxml:Value_wordprocessingDrawing_ST_RelFromH_page">page</value>
@@ -6815,6 +6827,7 @@
       <element name="posOffset" tokenid="ooxml:CT_PosH_posOffset"/>
       <attribute name="relativeFrom" tokenid="ooxml:CT_PosH_relativeFrom"/>
     </resource>
+    <resource name="CT_AlignV" resource="ListValue"/>
     <resource name="ST_AlignV" resource="List" generated="yes">
       <value name="top" tokenid="ooxml:Value_wordprocessingDrawing_ST_AlignV_top">top</value>
       <value name="bottom" tokenid="ooxml:Value_wordprocessingDrawing_ST_AlignV_bottom">bottom</value>
@@ -8326,8 +8339,6 @@
       <element name="nvPicPr" tokenid="ooxml:CT_Picture_nvPicPr"/>
       <element name="blipFill" tokenid="ooxml:CT_Picture_blipFill"/>
       <element name="spPr" tokenid="ooxml:CT_Picture_spPr"/>
-      <action name="start" action="mark" sendtokenid="ooxml:mark_shape" value="0"/>
-      <action name="end" action="mark" sendtokenid="ooxml:mark_shape" value="1"/>
     </resource>
     <resource name="pic" resource="Properties">
       <element name="pic" tokenid="ooxml:pic_pic"/>
@@ -15471,19 +15482,19 @@
         </group>
         <optional>
           <attribute name="zOrder">
-            <text/>
+            <ref name="ST_PageBorderZOrder"/>
             <xs:documentation>Z-Ordering of Page Border</xs:documentation>
           </attribute>
         </optional>
         <optional>
           <attribute name="display">
-            <text/>
+            <ref name="ST_PageBorderDisplay"/>
             <xs:documentation>Pages to Display Page Borders</xs:documentation>
           </attribute>
         </optional>
         <optional>
           <attribute name="offsetFrom">
-            <text/>
+            <ref name="ST_PageBorderOffset"/>
             <xs:documentation>Page Border Positioning</xs:documentation>
           </attribute>
         </optional>
@@ -16563,15 +16574,18 @@
           </element>
         </optional>
       </define>
+      <define name="CT_ParaTrackChange">
+        <ref name="CT_TrackChange"/>
+      </define>
       <define name="EG_ParaRPrTrackChanges">
         <optional>
           <element name="ins">
-            <ref name="CT_TrackChange"/>
+            <ref name="CT_ParaTrackChange"/>
           </element>
         </optional>
         <optional>
           <element name="del">
-            <ref name="CT_TrackChange"/>
+            <ref name="CT_ParaTrackChange"/>
           </element>
         </optional>
         <optional>
@@ -17550,7 +17564,7 @@
       </define>
       <define name="CT_Cnf">
         <attribute name="val">
-          <text/>
+          <ref name="ST_Cnf"/>
           <xs:documentation>Conditional Formatting Bit Mask</xs:documentation>
         </attribute>
       </define>
@@ -19867,16 +19881,16 @@
           </choice>
         </list>
       </define>
-      <define name="CT_TblStylePr">
+      <define name="CT_Style_tblStylePr">
         <group>
           <optional>
             <element name="pPr">
-              <ref name="CT_PPr"/>
+              <ref name="CT_PPrBase"/>
             </element>
           </optional>
           <optional>
             <element name="rPr">
-              <ref name="CT_RPr"/>
+              <ref name="EG_RPrBase"/>
             </element>
           </optional>
           <optional>
@@ -19886,20 +19900,29 @@
           </optional>
           <optional>
             <element name="trPr">
-              <ref name="CT_TrPr"/>
+              <ref name="CT_TrPrBase"/>
             </element>
           </optional>
           <optional>
             <element name="tcPr">
-              <ref name="CT_TcPr"/>
+              <ref name="CT_TcPrBase"/>
             </element>
           </optional>
         </group>
         <attribute name="type">
-          <text/>
+          <ref name="ST_TblStyleOverrideType"/>
           <xs:documentation>Table Style Conditional Formatting Type</xs:documentation>
         </attribute>
       </define>
+      <define name="CT_Style_TblPr">
+        <ref name="CT_TblPrBase"/>
+      </define>
+      <define name="CT_Style_TrPr">
+        <ref name="CT_TrPrBase"/>
+      </define>
+      <define name="CT_Style_TcPr">
+        <ref name="CT_TcPrBase"/>
+      </define>
       <define name="ST_StyleType">
         <list>
           <xs:documentation>Style Types</xs:documentation>
@@ -19999,12 +20022,12 @@
           </optional>
           <optional>
             <element name="pPr">
-              <ref name="CT_PPr"/>
+              <ref name="CT_PPrBase"/>
             </element>
           </optional>
           <optional>
             <element name="rPr">
-              <ref name="CT_RPr"/>
+              <ref name="EG_RPrBase"/>
             </element>
           </optional>
           <optional>
@@ -20014,17 +20037,17 @@
           </optional>
           <optional>
             <element name="trPr">
-              <ref name="CT_TrPr"/>
+              <ref name="CT_TrPrBase"/>
             </element>
           </optional>
           <optional>
             <element name="tcPr">
-              <ref name="CT_TcPr"/>
+              <ref name="CT_TcPrBase"/>
             </element>
           </optional>
           <zeroOrMore>
             <element name="tblStylePr">
-              <ref name="CT_TblStylePr"/>
+              <ref name="CT_Style_tblStylePr"/>
             </element>
           </zeroOrMore>
         </group>
@@ -21617,6 +21640,11 @@
       <attribute name="author" tokenid="ooxml:CT_TrackChange_author"/>
       <attribute name="date" tokenid="ooxml:CT_TrackChange_date"/>
     </resource>
+    <resource name="CT_ParaTrackChange" resource="Properties">
+      <action name="start" action="tokenproperty"/>
+      <action name="start" action="propagateCharacterPropertiesAsSet" sendtokenid="ooxml:paratrackchange"/>
+      <action name="start" action="clearProps"/>
+    </resource>
     <resource name="CT_CellMergeTrackChange" resource="Properties">
       <attribute name="vMerge" tokenid="ooxml:CT_CellMergeTrackChange_vMerge"/>
       <attribute name="vMergeOrig" tokenid="ooxml:CT_CellMergeTrackChange_vMergeOrig"/>
@@ -21681,6 +21709,7 @@
       <action name="start" action="tokenproperty"/>
       <action name="start" action="propagateCharacterPropertiesAsSet" sendtokenid="ooxml:trackchange"/>
       <action name="start" action="clearProps"/>
+      <action name="end" action="mark" sendtokenid="ooxml:endtrackchange"/>
     </resource>
     <resource name="CT_NumPr" resource="Properties">
       <kind name="paragraph"/>
@@ -21775,8 +21804,6 @@
     <resource name="CT_Picture" resource="Shape">
       <element name="movie" tokenid="ooxml:CT_Picture_movie"/>
       <element name="control" tokenid="ooxml:CT_Picture_control"/>
-      <action name="start" action="mark" sendtokenid="ooxml:mark_shape" value="0"/>
-      <action name="end" action="mark" sendtokenid="ooxml:mark_shape" value="1"/>
       <action name="end" action="sendPropertiesWithId" sendtokenid="ooxml:object"/>
       <action name="end" action="clearProps"/>
     </resource>
@@ -22021,18 +22048,13 @@
     <resource xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" name="CT_HdrFtrRef" resource="Properties">
       <attribute name="type" tokenid="ooxml:CT_HdrFtrRef_type"/>
       <attribute name="r:id" tokenid="ooxml:CT_HdrFtrRef_id"/>
-      <action name="end" action="endCharacterGroup"/>
-      <action name="end" action="endParagraphGroup"/>
       <action name="end" action="handleHdrFtr"/>
     </resource>
     <resource name="EG_HdrFtrReferences" resource="Properties">
       <element name="headerReference" tokenid="ooxml:EG_HdrFtrReferences_headerReference"/>
       <element name="footerReference" tokenid="ooxml:EG_HdrFtrReferences_footerReference"/>
     </resource>
-    <resource name="CT_HdrFtr" resource="Stream">
-      <action name="start" action="startSectionGroup"/>
-      <action name="end" action="endSectionGroup"/>
-    </resource>
+    <resource name="CT_HdrFtr" resource="Stream"/>
     <resource name="EG_SectPrContents" resource="Properties">
       <element name="bidi" tokenid="ooxml:EG_SectPrContents_bidi"/>
       <element name="cols" tokenid="ooxml:EG_SectPrContents_cols"/>
@@ -22251,6 +22273,8 @@
     <resource name="CT_RPrOriginal" resource="Properties"/>
     <resource name="CT_ParaRPrOriginal" resource="Properties"/>
     <resource name="CT_ParaRPr" resource="Properties">
+      <element name="ins" tokenid="ooxml:CT_ParaRPr_ins"/>
+      <element name="del" tokenid="ooxml:CT_ParaRPr_del"/>
       <element name="rPrChange" tokenid="ooxml:CT_ParaRPr_rPrChange"/>
     </resource>
     <resource name="ST_RubyAlign" resource="List" generated="yes">
@@ -22863,20 +22887,20 @@
       <element name="num" tokenid="ooxml:CT_Numbering_num"/>
       <element name="numIdMacAtCleanup" tokenid="ooxml:CT_Numbering_numIdMacAtCleanup"/>
     </resource>
-    <resource name="ST_TblStyleOverrideType" resource="List" generated="yes">
-      <value name="wholeTable" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_wholeTable">wholeTable</value>
-      <value name="firstRow" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_firstRow">firstRow</value>
-      <value name="lastRow" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_lastRow">lastRow</value>
-      <value name="firstCol" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_firstCol">firstCol</value>
-      <value name="lastCol" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_lastCol">lastCol</value>
-      <value name="band1Vert" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_band1Vert">band1Vert</value>
-      <value name="band2Vert" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_band2Vert">band2Vert</value>
-      <value name="band1Horz" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_band1Horz">band1Horz</value>
-      <value name="band2Horz" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_band2Horz">band2Horz</value>
-      <value name="neCell" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_neCell">neCell</value>
-      <value name="nwCell" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_nwCell">nwCell</value>
-      <value name="seCell" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_seCell">seCell</value>
-      <value name="swCell" tokenid="ooxml:Value_wordprocessingml_ST_TblStyleOverrideType_swCell">swCell</value>
+    <resource name="ST_TblStyleOverrideType" resource="List">
+      <value tokenid="1">wholeTable</value>
+      <value tokenid="2">firstRow</value>
+      <value tokenid="3">lastRow</value>
+      <value tokenid="4">firstCol</value>
+      <value tokenid="5">lastCol</value>
+      <value tokenid="6">band1Vert</value>
+      <value tokenid="7">band2Vert</value>
+      <value tokenid="8">band1Horz</value>
+      <value tokenid="9">band2Horz</value>
+      <value tokenid="10">neCell</value>
+      <value tokenid="11">nwCell</value>
+      <value tokenid="12">seCell</value>
+      <value tokenid="13">swCell</value>
     </resource>
     <resource name="ST_StyleType" resource="List">
       <value tokenid="1">paragraph</value>
@@ -22884,6 +22908,14 @@
       <value tokenid="3">table</value>
       <value tokenid="4">numbering</value>
     </resource>
+    <resource name="CT_Style_tblStylePr" resource="Properties">
+      <element name="pPr" tokenid="ooxml:CT_PPrBase"/>
+      <element name="rPr" tokenid="ooxml:EG_RPrBase"/>
+      <element name="tblPr" tokenid="ooxml:CT_TblPrBase"/>
+      <element name="trPr" tokenid="ooxml:CT_TrPrBase"/>
+      <element name="tcPr" tokenid="ooxml:CT_TcPrBase"/>
+      <attribute name="type" tokenid="ooxml:CT_TblStyleOverrideType"/>
+    </resource>
     <resource name="CT_Style" resource="Properties">
       <element name="name" tokenid="ooxml:CT_Style_name"/>
       <element name="aliases" tokenid="ooxml:CT_Style_aliases"/>
diff --git writerfilter/source/ooxml/modelpreprocess.xsl writerfilter/source/ooxml/modelpreprocess.xsl
index 51efa93..90376fc 100644
--- writerfilter/source/ooxml/modelpreprocess.xsl
+++ writerfilter/source/ooxml/modelpreprocess.xsl
@@ -225,4 +225,4 @@
      <xsl:apply-templates/>
    </xsl:copy>
   </xsl:template>
-</xsl:stylesheet>
\ No newline at end of file
+</xsl:stylesheet>
diff --git writerfilter/source/ooxml/namespace_preprocess.pl writerfilter/source/ooxml/namespace_preprocess.pl
new file mode 100644
index 0000000..f354cdb
--- /dev/null
+++ writerfilter/source/ooxml/namespace_preprocess.pl
@@ -0,0 +1,66 @@
+$ARGV0 = shift @ARGV;
+$ARGV1 = shift @ARGV;
+
+print <<EOF;
+<?xml version="1.0"?>
+<xsl:stylesheet version="1.0"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+  <xsl:output method="xml"/>
+
+  <xsl:include href="$ARGV1"/>
+
+  <xsl:template match="namespace-alias[\@id]">
+    <xsl:variable name="value">
+      <xsl:call-template name="getnamespaceid">
+        <xsl:with-param name="id" select="\@id" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:copy>
+      <xsl:apply-templates select="@*"/>
+      <xsl:attribute name="id">
+        <xsl:value-of select="\$value"/>
+      </xsl:attribute>
+    </xsl:copy>
+  </xsl:template>
+
+  <xsl:template name="getnamespaceid">
+    <xsl:param name='id'/>
+    <xsl:choose>
+EOF
+
+
+# print the mapping
+open ( NAMESPACES, $ARGV0 ) || die "can't open namespace file: $!";
+$group = 0;
+$i = 1;
+while ( <NAMESPACES> )
+{
+    chomp( $_ );
+    $_ =~ s/\s*//g;
+    if ( $_ =~ m/^$/ )
+    {
+        # Start a new group
+        $i = 0;
+        $group++;
+    } 
+    elsif ( $_ =~ m/^[^#]/ )
+    {
+        # Neither an empty line nor a comment
+        $_ =~ /^[a-zA-Z0-9-_]+$/ or die "Invalid namespace token $_";
+        $_ =~ s/-/_/g;
+        $no = $group*10 + $i;
+        print <<EOF;
+      <xsl:when test="\$id = '$_'">
+        <xsl:text>$no</xsl:text>
+      </xsl:when>
+EOF
+        ++$i;
+    }
+}
+
+print <<EOF;
+    </xsl:choose>
+  </xsl:template>
+
+</xsl:stylesheet>
+EOF
diff --git writerfilter/source/ooxml/resourcestools.xsl writerfilter/source/ooxml/resourcestools.xsl
index 9b17e4d..7296cbd 100644
--- writerfilter/source/ooxml/resourcestools.xsl
+++ writerfilter/source/ooxml/resourcestools.xsl
@@ -92,6 +92,20 @@
            match="rng:define" use="ancestor::rng:grammar/@application"/>
 
   <xsl:key name="namespace-aliases" match="//namespace-alias" use="@name"/>
+  
+  <!-- Tiny template helping devs to debug -->
+  <xsl:template name="dbg_path">
+    <xsl:text>/*</xsl:text>
+    <xsl:for-each select="ancestor::*">
+      <xsl:value-of select="name(.)"/>
+      <xsl:text>/</xsl:text>
+    </xsl:for-each>
+    <xsl:value-of select="name(.)"/>
+    <xsl:text>[@name=</xsl:text>
+    <xsl:value-of select="@name"/>
+    <xsl:text>]</xsl:text>
+    <xsl:text>*/</xsl:text>
+  </xsl:template>
 
   <xsl:template name="licenseheader">
     <xsl:text>
@@ -398,7 +412,7 @@ public:
        Generate switch body for createFastChildContext
   -->
   <xsl:template name="switchbodycreatechildcontext">
-    <xsl:for-each select=".//rng:element[@name]">
+      <xsl:for-each select=".//rng:element[@name]">
         <xsl:call-template name="caselabelfasttoken"/>
         <xsl:variable name="createstatement">
           <xsl:call-template name="fastelementcreatestatement"/>
@@ -1543,6 +1557,12 @@ uno::Reference &lt; xml::sax::XFastParser &gt; OOXMLStreamImpl::getFastParser()
       </xsl:if>
     </xsl:for-each>
   </xsl:template>
+  
+  <xsl:template name="fastcharactersstringvalue">
+      <xsl:text>
+        
+        msValue = sText;</xsl:text>
+  </xsl:template>
 
   <xsl:template name="fastattributesstringvalue">
     <xsl:for-each select=".//rng:attribute">
@@ -1555,6 +1575,12 @@ uno::Reference &lt; xml::sax::XFastParser &gt; OOXMLStreamImpl::getFastParser()
         <xsl:text>);</xsl:text>
     </xsl:for-each>
   </xsl:template>
+  
+  <xsl:template name="fastcharactersintvalue">
+    <xsl:text>
+
+        mnValue = sText.toInt32();</xsl:text>
+  </xsl:template>
 
   <xsl:template name="fastattributesintvalue">
     <xsl:for-each select=".//rng:attribute">
@@ -1568,6 +1594,12 @@ uno::Reference &lt; xml::sax::XFastParser &gt; OOXMLStreamImpl::getFastParser()
     </xsl:for-each>
   </xsl:template>
 
+  <xsl:template name="fastcharactershexvalue">
+    <xsl:text>
+      
+      mnValue = sText.toInt32(16);</xsl:text>
+  </xsl:template>
+  
   <xsl:template name="fastattributeshexvalue">
     <xsl:for-each select=".//rng:attribute">
       <xsl:text>
@@ -1580,6 +1612,12 @@ uno::Reference &lt; xml::sax::XFastParser &gt; OOXMLStreamImpl::getFastParser()
     </xsl:for-each>
   </xsl:template>
 
+  <xsl:template name="fastcharactersboolvalue">
+    <xsl:text>
+      
+      setValue( sText );</xsl:text>
+  </xsl:template>
+  
   <xsl:template name="fastattributesboolvalue">
     <xsl:for-each select=".//rng:attribute">
       <xsl:text>
@@ -1592,6 +1630,35 @@ uno::Reference &lt; xml::sax::XFastParser &gt; OOXMLStreamImpl::getFastParser()
     </xsl:for-each>
   </xsl:template>
 
+  <xsl:template name="fastcharacterslistvalue">
+    <xsl:variable name="bodywithns">        
+      <xsl:for-each select="rng:ref">
+        <xsl:variable name="refname" select="@name"/>
+        <xsl:variable name="refns">
+          <xsl:call-template name="searchdefinenamespace">
+            <xsl:with-param name="name" select="@name"/>
+          </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="valname">
+          <xsl:for-each select="/model/namespace[@name=substring-before($refns, ':')]">
+            <xsl:for-each select="./rng:grammar/rng:define[@name=substring-after($refns, ':')]">
+              <xsl:call-template name="valuenamefordefine"/>
+            </xsl:for-each>
+          </xsl:for-each>
+        </xsl:variable>
+        <xsl:text>
+          mpValue = OOXMLValue::Pointer_t (new </xsl:text>
+        <xsl:value-of select="$valname"/>
+      <xsl:text>( sText ) );</xsl:text>
+      </xsl:for-each>
+    </xsl:variable>
+    <xsl:if test="string-length($bodywithns) > 0">
+      <xsl:text>
+      </xsl:text>
+      <xsl:value-of select="$bodywithns"/>
+    </xsl:if>
+  </xsl:template>
+
   <xsl:template name="fastattributeslistvalue">
     <xsl:for-each select=".//rng:attribute">
       <xsl:variable name="myfasttoken">
@@ -1739,9 +1806,9 @@ void </xsl:text>
       </xsl:if>
         <!-- </xsl:if> -->
   </xsl:template>
-
+  
   <xsl:template name="fastelementcreatestatement">
-    <xsl:for-each select=".//rng:ref">
+    <xsl:for-each select=".//rng:ref">  
       <xsl:choose>
         <xsl:when test="@name='BUILT_IN_ANY_TYPE'">
           <xsl:text>createFromStart(Element, Attribs)</xsl:text>
@@ -1999,6 +2066,29 @@ void </xsl:text>
 
   <xsl:template name="fastcharactersbody">
     <xsl:variable name="name" select="@name"/>
+    <!-- ST values as text -->
+    <xsl:variable name="resource">
+      <xsl:call-template name="contextresource"/>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$resource = 'StringValue'">
+        <xsl:call-template name="fastcharactersstringvalue"/>
+      </xsl:when>
+      <xsl:when test="$resource = 'IntegerValue'">
+        <xsl:call-template name="fastcharactersintvalue"/>
+      </xsl:when>
+      <xsl:when test="$resource = 'HexValue'">
+        <xsl:call-template name="fastcharactershexvalue"/>
+      </xsl:when>
+      <xsl:when test="$resource = 'BooleanValue'">
+        <xsl:call-template name="fastcharactersboolvalue"/>
+      </xsl:when>
+      <xsl:when test="$resource = 'ListValue'">
+        <xsl:call-template name="fastcharacterslistvalue"/>
+      </xsl:when>
+    </xsl:choose>
+
+    <!-- characters action -->
     <xsl:for-each select="ancestor::namespace/resource[@name = $name]//action[@name='characters']">
       <xsl:call-template name="chooseaction"/>
     </xsl:for-each>
diff --git writerfilter/source/resourcemodel/TagLogger.cxx writerfilter/source/resourcemodel/TagLogger.cxx
index ff23dfc..97f3f28 100644
--- writerfilter/source/resourcemodel/TagLogger.cxx
+++ writerfilter/source/resourcemodel/TagLogger.cxx
@@ -273,7 +273,7 @@ namespace writerfilter
             
             fileName += "/writerfilter.";
             fileName += name;
-            fileName += ".tmp";
+            fileName += ".xml";
 
             ofstream dumpStream(fileName.c_str());
             aIt->second->output(dumpStream);
diff --git writerfilter/source/resourcemodel/WW8Analyzer.cxx writerfilter/source/resourcemodel/WW8Analyzer.cxx
index 0bcf198..a3d70cf 100644
--- writerfilter/source/resourcemodel/WW8Analyzer.cxx
+++ writerfilter/source/resourcemodel/WW8Analyzer.cxx
@@ -168,6 +168,14 @@ void WW8Analyzer::info(const string & /*info*/)
 {
 }
 
+void WW8Analyzer::startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > /*xShape*/ )
+{
+}
+
+void WW8Analyzer::endShape( )
+{
+}
+
 void WW8Analyzer::dumpStats(ostream & o) const
 {
     {
diff --git writerfilter/source/resourcemodel/WW8Analyzer.hxx writerfilter/source/resourcemodel/WW8Analyzer.hxx
index e437ed9..763d531 100644
--- writerfilter/source/resourcemodel/WW8Analyzer.hxx
+++ writerfilter/source/resourcemodel/WW8Analyzer.hxx
@@ -92,6 +92,8 @@ public:
     virtual void substream(Id name, 
                            writerfilter::Reference<Stream>::Pointer_t ref);
     virtual void info(const string & info);
+    virtual void startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual void endShape( );
 
     void dumpStats(ostream & o) const;
 };
diff --git writerfilter/source/resourcemodel/resourcemodel.cxx writerfilter/source/resourcemodel/resourcemodel.cxx
index 7b4bdf8..d0ae060 100644
--- writerfilter/source/resourcemodel/resourcemodel.cxx
+++ writerfilter/source/resourcemodel/resourcemodel.cxx
@@ -266,6 +266,16 @@ void WW8StreamHandler::endCharacterGroup()
 {
     output.addItem("</character-group>");
 }
+    
+void WW8StreamHandler::startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > /*xShape*/ )
+{
+    output.addItem("<shape>");
+}
+
+void WW8StreamHandler::endShape( )
+{
+    output.addItem( "</shape>" );
+}
 
 void WW8StreamHandler::text(const sal_uInt8 * data, size_t len)
 {
diff --git writerfilter/source/resourcemodel/resourcemodel.hxx writerfilter/source/resourcemodel/resourcemodel.hxx
index eb2a2a4..14c73f0 100644
--- writerfilter/source/resourcemodel/resourcemodel.hxx
+++ writerfilter/source/resourcemodel/resourcemodel.hxx
@@ -50,6 +50,9 @@ public:
     virtual void props(writerfilter::Reference<Properties>::Pointer_t ref);
     virtual void table(Id name, 
                        writerfilter::Reference<Table>::Pointer_t ref);
+    
+    virtual void startShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual void endShape( );
 
     virtual void substream(Id name, writerfilter::Reference<Stream>::Pointer_t ref);
 
