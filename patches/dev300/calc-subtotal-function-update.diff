diff --git sc/inc/document.hxx sc/inc/document.hxx
index 2b5dc0f..603a005 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -449,6 +449,8 @@ private:
 	// for worksheet calculate event
 	::std::vector< SCTAB > maTabs;
 
+    ::std::set<ScFormulaCell*> maSubTotalCells;
+    
 public:
     SC_DLLPUBLIC ULONG			GetCellCount() const;		// alle Zellen
     SCSIZE          GetCellCount(SCTAB nTab, SCCOL nCol) const;
@@ -1829,6 +1831,10 @@ public:
     bool IsInVBAMode() const;
     ScRowBreakIterator* GetRowBreakIterator(SCTAB nTab) const;
 
+    void AddSubTotalCell(ScFormulaCell* pCell);
+    void RemoveSubTotalCell(ScFormulaCell* pCell);
+    void SetSubTotalCellsDirty(const ScRange& rDirtyRange);
+
 private: // CLOOK-Impl-Methoden
 
     /** 
diff --git sc/source/core/data/cell.cxx sc/source/core/data/cell.cxx
index 8104d0a..88ccbfe 100644
--- sc/source/core/data/cell.cxx
+++ sc/source/core/data/cell.cxx
@@ -725,6 +725,9 @@ ScFormulaCell::ScFormulaCell( ScDocument* pDoc, const ScAddress& rPos,
         if ( pCode->GetNextOpCodeRPN( ocSubTotal ) )
             bSubTotal = TRUE;
     }
+
+    if (bSubTotal)
+        pDocument->AddSubTotalCell(this);
 }
 
 ScFormulaCell::ScFormulaCell( const ScFormulaCell& rCell, ScDocument& rDoc, const ScAddress& rPos, int nCloneFlags ) :
@@ -815,11 +818,17 @@ ScFormulaCell::ScFormulaCell( const ScFormulaCell& rCell, ScDocument& rDoc, cons
 
     if( nCloneFlags & SC_CLONECELL_STARTLISTENING )
         StartListeningTo( &rDoc );
+
+    if (bSubTotal)
+        pDocument->AddSubTotalCell(this);
+
 }
 
 ScFormulaCell::~ScFormulaCell()
 {
     pDocument->RemoveFromFormulaTree( this );
+    pDocument->RemoveSubTotalCell(this);
+
     if (pCode->HasOpCode(ocMacro))
         pDocument->GetMacroManager()->RemoveDependentCell(this);
 
@@ -987,6 +996,9 @@ void ScFormulaCell::CompileTokenArray( BOOL bNoListening )
         }
         if ( bWasInFormulaTree )
             pDocument->PutInFormulaTree( this );
+
+        if (bSubTotal)
+            pDocument->AddSubTotalCell(this);
     }
 }
 
@@ -1030,6 +1042,9 @@ void ScFormulaCell::CompileXML( ScProgress& rProgress )
             bCompile = FALSE;
             StartListeningTo( pDocument );
         }
+
+        if (bSubTotal)
+            pDocument->AddSubTotalCell(this);
     }
     else
     {
@@ -1069,6 +1084,9 @@ void ScFormulaCell::CalcAfterLoad()
         bDirty = TRUE;
         bCompile = FALSE;
         bNewCompiled = TRUE;
+
+        if (bSubTotal)
+            pDocument->AddSubTotalCell(this);
     }
     // irgendwie koennen unter os/2 mit rotter FPU-Exception /0 ohne Err503
     // gespeichert werden, woraufhin spaeter im NumberFormatter die BLC Lib
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index ea615c5..f3106cd 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -5270,6 +5270,55 @@ ScRowBreakIterator* ScDocument::GetRowBreakIterator(SCTAB nTab) const
     return NULL;
 }
 
+void ScDocument::AddSubTotalCell(ScFormulaCell* pCell)
+{
+    maSubTotalCells.insert(pCell);
+}
+
+void ScDocument::RemoveSubTotalCell(ScFormulaCell* pCell)
+{
+    maSubTotalCells.erase(pCell);
+}
+
+namespace {
+
+bool lcl_hasDirtyRange(ScFormulaCell* pCell, const ScRange& rDirtyRange)
+{
+    ScDetectiveRefIter aRefIter(pCell);
+    ScRange aRange;
+    while (aRefIter.GetNextRef(aRange))
+    {
+        if (aRange.Intersects(rDirtyRange))
+            return true;
+    }
+    return false;
+}
+
+}
+
+void ScDocument::SetSubTotalCellsDirty(const ScRange& rDirtyRange)
+{
+    // to update the list by skipping cells that no longer contain subtotal function.
+    set<ScFormulaCell*> aNewSet;
+
+    bool bOldRecalc = GetAutoCalc();
+    SetAutoCalc(false);
+    set<ScFormulaCell*>::iterator itr = maSubTotalCells.begin(), itrEnd = maSubTotalCells.end();
+    for (; itr != itrEnd; ++itr)
+    {
+        ScFormulaCell* pCell = *itr;
+        if (pCell->IsSubTotal())
+        {
+            aNewSet.insert(pCell);
+            if (lcl_hasDirtyRange(pCell, rDirtyRange))
+                pCell->SetDirty();
+        }
+    }
+
+    SetAutoCalc(bOldRecalc);
+    maSubTotalCells.swap(aNewSet); // update the list.
+}
+
 void ScDocument::EnableUndo( bool bVal )
 {
     GetUndoManager()->EnableUndo(bVal);
diff --git sc/source/ui/docshell/dbdocfun.cxx sc/source/ui/docshell/dbdocfun.cxx
index 318ee76..5917798 100644
--- sc/source/ui/docshell/dbdocfun.cxx
+++ sc/source/ui/docshell/dbdocfun.cxx
@@ -942,10 +942,9 @@ BOOL ScDBDocFunc::Query( SCTAB nTab, const ScQueryParam& rQueryParam,
         pDoc->UpdatePageBreaks( nTab );
     }
 
-    // #i23299# because of Subtotal functions, the whole rows must be set dirty
-    ScRange aDirtyRange( 0 , aLocalParam.nRow1, nDestTab,
-        MAXCOL, aLocalParam.nRow2, nDestTab );
-    pDoc->SetDirty( aDirtyRange );
+    // #i23299# Subtotal functions depend on cell's filtered states.
+    ScRange aDirtyRange(0 , aLocalParam.nRow1, nDestTab, MAXCOL, aLocalParam.nRow2, nDestTab);
+    pDoc->SetSubTotalCellsDirty(aDirtyRange);
 
     if ( bRecord )
     {
