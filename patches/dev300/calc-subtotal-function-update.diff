From 0c4144946c2c1ee7ea833a4cb3baf33793255d9d Mon Sep 17 00:00:00 2001
From: Jan Holesovsky <kendy@suse.cz>
Date: Fri, 14 May 2010 17:07:54 +0200
Subject: [PATCH 691/768] calc-subtotal-function-update.diff

---
 sc/inc/document.hxx                |    7 +++++
 sc/source/core/data/cell.cxx       |   16 ++++++++++++
 sc/source/core/data/document.cxx   |   48 ++++++++++++++++++++++++++++++++++++
 sc/source/ui/docshell/dbdocfun.cxx |    7 ++---
 4 files changed, 74 insertions(+), 4 deletions(-)

diff --git sc/inc/document.hxx sc/inc/document.hxx
index 65c695b..185c2b7 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -438,6 +438,8 @@ private:
 
     sal_Int16           mnNamedRangesLockCount;
 
+    ::std::set<ScFormulaCell*> maSubTotalCells;
+
 public:
     SC_DLLPUBLIC ULONG			GetCellCount() const;		// alle Zellen
     SCSIZE          GetCellCount(SCTAB nTab, SCCOL nCol) const;
@@ -1809,6 +1811,11 @@ public:
                             { return eStorageGrammar; }
 
     SfxUndoManager*     GetUndoManager();
+
+    void AddSubTotalCell(ScFormulaCell* pCell);
+    void RemoveSubTotalCell(ScFormulaCell* pCell);
+    void SetSubTotalCellsDirty(const ScRange& rDirtyRange);
+
 private: // CLOOK-Impl-Methoden
 
     /** 
diff --git sc/source/core/data/cell.cxx sc/source/core/data/cell.cxx
index d73bc1f..e999050 100644
--- sc/source/core/data/cell.cxx
+++ sc/source/core/data/cell.cxx
@@ -724,6 +724,9 @@ ScFormulaCell::ScFormulaCell( ScDocument* pDoc, const ScAddress& rPos,
         if ( pCode->GetNextOpCodeRPN( ocSubTotal ) )
             bSubTotal = TRUE;
     }
+
+    if (bSubTotal)
+        pDocument->AddSubTotalCell(this);
 }
 
 ScFormulaCell::ScFormulaCell( const ScFormulaCell& rCell, ScDocument& rDoc, const ScAddress& rPos, int nCloneFlags ) :
@@ -814,11 +817,15 @@ ScFormulaCell::ScFormulaCell( const ScFormulaCell& rCell, ScDocument& rDoc, cons
 
     if( nCloneFlags & SC_CLONECELL_STARTLISTENING )
         StartListeningTo( &rDoc );
+
+    if (bSubTotal)
+        pDocument->AddSubTotalCell(this);
 }
 
 ScFormulaCell::~ScFormulaCell()
 {
     pDocument->RemoveFromFormulaTree( this );
+    pDocument->RemoveSubTotalCell(this);
 
     if (pDocument->HasExternalRefManager())
         pDocument->GetExternalRefManager()->removeRefCell(this);
@@ -985,6 +992,9 @@ void ScFormulaCell::CompileTokenArray( BOOL bNoListening )
         }
         if ( bWasInFormulaTree )
             pDocument->PutInFormulaTree( this );
+
+        if (bSubTotal)
+            pDocument->AddSubTotalCell(this);
     }
 }
 
@@ -1028,6 +1038,9 @@ void ScFormulaCell::CompileXML( ScProgress& rProgress )
             bCompile = FALSE;
             StartListeningTo( pDocument );
         }
+
+        if (bSubTotal)
+            pDocument->AddSubTotalCell(this);
     }
     else
     {
@@ -1067,6 +1080,9 @@ void ScFormulaCell::CalcAfterLoad()
         bDirty = TRUE;
         bCompile = FALSE;
         bNewCompiled = TRUE;
+
+        if (bSubTotal)
+            pDocument->AddSubTotalCell(this);
     }
     // irgendwie koennen unter os/2 mit rotter FPU-Exception /0 ohne Err503
     // gespeichert werden, woraufhin spaeter im NumberFormatter die BLC Lib
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 2d08aa8..332d25c 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -5251,6 +5251,54 @@ SfxUndoManager* ScDocument::GetUndoManager()
     return mpUndoManager;
 }
 
+void ScDocument::AddSubTotalCell(ScFormulaCell* pCell)
+{
+    maSubTotalCells.insert(pCell);
+}
+
+void ScDocument::RemoveSubTotalCell(ScFormulaCell* pCell)
+{
+    maSubTotalCells.erase(pCell);
+}
+
+namespace {
+
+bool lcl_hasDirtyRange(ScFormulaCell* pCell, const ScRange& rDirtyRange)
+{
+    ScDetectiveRefIter aRefIter(pCell);
+    ScRange aRange;
+    while (aRefIter.GetNextRef(aRange))
+    {
+        if (aRange.Intersects(rDirtyRange))
+            return true;
+    }
+    return false;
+}
+
+}
+
+void ScDocument::SetSubTotalCellsDirty(const ScRange& rDirtyRange)
+{
+    // to update the list by skipping cells that no longer contain subtotal function.
+    set<ScFormulaCell*> aNewSet;
+
+    bool bOldRecalc = GetAutoCalc();
+    SetAutoCalc(false);
+    set<ScFormulaCell*>::iterator itr = maSubTotalCells.begin(), itrEnd = maSubTotalCells.end();
+    for (; itr != itrEnd; ++itr)
+    {
+        ScFormulaCell* pCell = *itr;
+        if (pCell->IsSubTotal())
+        {
+            aNewSet.insert(pCell);
+            if (lcl_hasDirtyRange(pCell, rDirtyRange))
+                pCell->SetDirty();
+        }
+    }
+
+    SetAutoCalc(bOldRecalc);
+    maSubTotalCells.swap(aNewSet); // update the list.
+}
 
 void ScDocument::EnableUndo( bool bVal )
 {
diff --git sc/source/ui/docshell/dbdocfun.cxx sc/source/ui/docshell/dbdocfun.cxx
index 7e48ad5..49ae273 100644
--- sc/source/ui/docshell/dbdocfun.cxx
+++ sc/source/ui/docshell/dbdocfun.cxx
@@ -942,10 +942,9 @@ BOOL ScDBDocFunc::Query( SCTAB nTab, const ScQueryParam& rQueryParam,
         pDoc->UpdatePageBreaks( nTab );
     }
 
-    // #i23299# because of Subtotal functions, the whole rows must be set dirty
-    ScRange aDirtyRange( 0 , aLocalParam.nRow1, nDestTab,
-        MAXCOL, aLocalParam.nRow2, nDestTab );
-    pDoc->SetDirty( aDirtyRange );
+    // #i23299# Subtotal functions depend on cell's filtered states.
+    ScRange aDirtyRange(0 , aLocalParam.nRow1, nDestTab, MAXCOL, aLocalParam.nRow2, nDestTab);
+    pDoc->SetSubTotalCellsDirty(aDirtyRange);
 
     if ( bRecord )
     {
-- 
1.7.0.1

