--- basegfx/inc/basegfx/polygon/b2dpolypolygontools.hxx
+++ basegfx/inc/basegfx/polygon/b2dpolypolygontools.hxx
@@ -127,19 +127,37 @@ namespace basegfx
         /** Read poly-polygon from SVG.
 
         	This function imports a poly-polygon from an SVG-D
-        	statement. Currently, elliptical arc elements are not yet
+        	attribute. Currently, elliptical arc elements are not yet
         	supported (and ignored during parsing).
 
             @param o_rPolyPoly
             The output poly-polygon
 
-            @param rSvgDStatement
-            A valid SVG-D statement
+            @param rSvgDAttribute
+            A valid SVG-D attribute string
 
             @return true, if the string was successfully parsed
          */
-        bool importFromSvgD( B2DPolyPolygon& o_rPolyPoly,
-                             const ::rtl::OUString& 	rSvgDStatement );
+        bool importFromSvgD( B2DPolyPolygon&        o_rPolyPoly,
+                             const ::rtl::OUString& rSvgDAttribute );
+
+        /** Read poly-polygon from SVG.
+
+        	This function imports a poly-polygon from an SVG points
+        	attribute (a plain list of coordinate pairs).
+
+            @param o_rPoly
+            The output polygon. Note that svg:points can only define a
+            single polygon
+
+            @param rSvgPointsAttribute
+            A valid SVG points attribute string
+
+            @return true, if the string was successfully parsed
+         */
+        bool importFromSvgPoints( B2DPolygon&            o_rPoly,
+                                  const ::rtl::OUString& rSvgPointsAttribute );
+
 
 		// create 3d PolyPolygon from given 2d PolyPolygon. The given fZCoordinate is used to expand the
 		// third coordinate.
--- basegfx/source/polygon/b2dsvgpolypolygon.cxx	2008-04-10 21:02:54.000000000 +0200
+++ basegfx/source/polygon/b2dsvgpolypolygon.cxx	2008-05-09 00:03:56.000000000 +0200
@@ -32,7 +32,9 @@
 #include "precompiled_basegfx.hxx"
 
 #include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
 #include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
 #include <rtl/ustring.hxx>
 #include <rtl/math.hxx>
 
@@ -64,7 +66,7 @@
                 }
             }
 
-            bool lcl_isOnNumberChar(const ::rtl::OUString& rStr, const sal_Int32 nPos, bool bSignAllowed = true)
+            inline bool lcl_isOnNumberChar(const ::rtl::OUString& rStr, const sal_Int32 nPos, bool bSignAllowed = true)
             {
                 const sal_Unicode aChar(rStr[nPos]);
 
@@ -141,6 +143,37 @@
                 return true;
             }
 
+            bool lcl_importNumberAndSpaces(sal_Int32&                o_nRetval,
+                                           sal_Int32& 				io_rPos, 
+                                           const ::rtl::OUString& 	rStr, 
+                                           const sal_Int32 		nLen)
+            {
+                sal_Unicode aChar( rStr[io_rPos] );
+                ::rtl::OUStringBuffer sNumberString;
+
+                if(sal_Unicode('+') == aChar || sal_Unicode('-') == aChar)
+                {
+                    sNumberString.append(rStr[io_rPos]);
+                    aChar = rStr[++io_rPos];
+                }
+
+                while(sal_Unicode('0') <= aChar && sal_Unicode('9') >= aChar)
+                {
+                    sNumberString.append(rStr[io_rPos]);
+                    aChar = rStr[++io_rPos];
+                }
+
+                if(sNumberString.getLength())
+                {
+                    o_nRetval = sNumberString.makeStringAndClear().toInt32();
+                    lcl_skipSpacesAndCommas(io_rPos, rStr, nLen);
+
+                    return true;
+                }
+
+                return false;
+            }
+
             void lcl_skipNumber(sal_Int32& 				io_rPos, 
                                 const ::rtl::OUString& 	rStr, 
                                 const sal_Int32 		nLen)
@@ -613,24 +646,185 @@
                         break;
                     }
 
-                    // #100617# not yet supported: elliptical arc
-                    case 'A' :
-                        // FALLTHROUGH intended
                     case 'a' :
                     {
-                        OSL_ENSURE(false, "importFromSvgD(): non-interpreted tags in svg:d element (elliptical arc)!");
+                        bRelative = true;
+                        // FALLTHROUGH intended
+                    }
+                    case 'A' :
+                    {
                         nPos++;
                         lcl_skipSpaces(nPos, rSvgDStatement, nLen);
 
                         while(nPos < nLen && lcl_isOnNumberChar(rSvgDStatement, nPos))
                         {
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipNumberAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipNumberAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
-                            lcl_skipDoubleAndSpacesAndCommas(nPos, rSvgDStatement, nLen);
+                            double nX, nY;
+                            double fRX, fRY, fPhi;
+                            sal_Int32 bLargeArcFlag, bSweepFlag;
+
+                            if(!lcl_importDoubleAndSpaces(fRX, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(fRY, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(fPhi, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importNumberAndSpaces(bLargeArcFlag, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importNumberAndSpaces(bSweepFlag, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(nX, nPos, rSvgDStatement, nLen)) return false;
+                            if(!lcl_importDoubleAndSpaces(nY, nPos, rSvgDStatement, nLen)) return false;
+
+                            if(bRelative)
+                            {
+                                nX += nLastX;
+                                nY += nLastY;
+                            }
+
+							const B2DPoint aPrevPoint(aCurrPoly.getB2DPoint(aCurrPoly.count() - 1));
+
+                            if( nX == nLastX && nY == nLastY )
+                                continue; // start==end -> skip according to SVG spec
+
+                            if( fRX == 0.0 || fRY == 0.0 )
+                            {
+                                // straight line segment according to SVG spec
+                                aCurrPoly.append(B2DPoint(nX, nY));
+                            }
+                            else
+                            {
+                                // normalize according to SVG spec
+                                fRX=fabs(fRX); fRY=fabs(fRY);
+                                
+                                // from the SVG spec, appendix F.6.4
+
+                                // |x1'|   |cos phi   sin phi|  |(x1 - x2)/2|
+                                // |y1'| = |-sin phi  cos phi|  |(y1 - y2)/2|
+                                const B2DPoint p1(nLastX, nLastY);
+                                const B2DPoint p2(nX, nY);
+                                B2DHomMatrix aTransform; aTransform.rotate(-fPhi*M_PI/180);
+                                
+                                const B2DPoint p1_prime( aTransform * B2DPoint(((p1-p2)/2.0)) );
+
+                                //           ______________________________________       rx y1'
+                                // |cx'|  + /  rx^2 ry^2 - rx^2 y1'^2 - ry^2 x1^2           ry
+                                // |cy'| =-/       rx^2y1'^2 + ry^2 x1'^2               - ry x1' 
+                                //                                                          rx
+                                // chose + if f_A != f_S
+                                // chose - if f_A  = f_S
+                                B2DPoint aCenter_prime;
+                                const double fRadicant(
+                                    (fRX*fRX*fRY*fRY - fRX*fRX*p1_prime.getY()*p1_prime.getY() - fRY*fRY*p1_prime.getX()*p1_prime.getX())/
+                                    (fRX*fRX*p1_prime.getY()*p1_prime.getY() + fRY*fRY*p1_prime.getX()*p1_prime.getX()));
+                                if( fRadicant < 0.0 )
+                                {
+                                    // no solution - according to SVG
+                                    // spec, scale up ellipse
+                                    // uniformly such that it passes
+                                    // through end points (denominator
+                                    // of radicant solved for fRY,
+                                    // with s=fRX/fRY)
+                                    const double fRatio(fRX/fRY);
+                                    const double fRadicant2(
+                                        p1_prime.getY()*p1_prime.getY() +
+                                        p1_prime.getX()*p1_prime.getX()/(fRatio*fRatio));
+                                    if( fRadicant2 < 0.0 )
+                                    {
+                                        // only trivial solution, one
+                                        // of the axes 0 -> straight
+                                        // line segment according to
+                                        // SVG spec
+                                        aCurrPoly.append(B2DPoint(nX, nY));
+                                        continue;
+                                    }
+                                    
+                                    fRY=sqrt(fRadicant2);
+                                    fRX=fRatio*fRY;
+
+                                    // keep center_prime forced to (0,0)
+                                }
+                                else
+                                {
+                                    // todo:   <path d="M200,100 h 50 
+                                    // a25,50 20 0,0 50,-25 l 50,-25"
+                                    // fill="none" stroke="green" stroke-width="5"  />
+                                    //
+                                    // sweep flag not considered right for e.g. 
+                                    // <path d="M0,400 l 50,-25 
+                                    // a25,25 -30 0,1 50,-25 l 50,-25 
+                                    // a25,50 -30 0,1 50,-25 l 50,-25 
+                                    // a25,75 -30 0,1 50,-25 l 50,-25 
+                                    // a25,100 -30 0,1 50,-25 l 50,-25"
+                                    // fill="none" stroke="red" stroke-width="5"  />
+
+
+                                    const double fFactor(
+                                        (bLargeArcFlag==bSweepFlag) ? -1.0 : 1.0 *
+                                        sqrt((fRX*fRX*fRY*fRY - fRX*fRX*p1_prime.getY()*p1_prime.getY() - fRY*fRY*p1_prime.getX()*p1_prime.getX())/
+                                             (fRX*fRX*p1_prime.getY()*p1_prime.getY() + fRY*fRY*p1_prime.getX()*p1_prime.getX())));
+
+                                    // actually calculate center_prime
+                                    aCenter_prime = B2DPoint(
+                                        fFactor*fRX*p1_prime.getY()/fRY,
+                                        -fFactor*fRY*p1_prime.getX()/fRX);
+                                }
+
+                                //              +           u - v 
+                                // angle(u,v) =  arccos( ------------ )     (take the sign of (ux vy - uy vx))
+                                //              -        ||u|| ||v||
+
+                                //                  1    | (x1' - cx')/rx |
+                                // theta1 = angle((   ), |                | )
+                                //                  0    | (y1' - cy')/ry |
+                                const B2DPoint aRadii(fRX,fRY);
+                                double fTheta1( 
+                                    B2DVector(1.0,0.0).angle(
+                                        (p1_prime-aCenter_prime)/aRadii));
+
+                                //                 |1|    |  (-x1' - cx')/rx |
+                                // theta2 = angle( | | ,  |                  | )
+                                //                 |0|    |  (-y1' - cy')/ry |
+                                double fTheta2( 
+                                    B2DVector(1.0,0.0).angle(
+                                        (-p1_prime-aCenter_prime)/aRadii));
+
+                                // map both angles to [0,2pi)
+                                fTheta1 = fmod(2*M_PI+fTheta1,2*M_PI);
+                                fTheta2 = fmod(2*M_PI+fTheta2,2*M_PI);
+
+                                // make sure the large arc is taken
+                                // (since
+                                // createPolygonFromEllipseSegment()
+                                // normalizes to e.g. cw arc)
+                                const bool bFlipSegment( (bLargeArcFlag!=0) == 
+                                    (fmod(fTheta2+2*M_PI-fTheta1,
+                                          2*M_PI)<M_PI) );
+                                if( bFlipSegment )
+                                    std::swap(fTheta1,fTheta2);
+
+                                // finally, create bezier polygon from this
+                                B2DPolygon aSegment(
+                                    tools::createPolygonFromUnitEllipseSegment( 
+                                        fTheta1, fTheta2 ));
+
+                                // transform ellipse by rotation & move to final center
+                                aTransform.identity(); 
+                                aTransform.scale(fRX,fRY);
+                                aTransform.translate(aCenter_prime.getX(),
+                                                     aCenter_prime.getY());
+                                aTransform.rotate(fPhi*M_PI/180);
+                                const B2DPoint aOffset((p1+p2)/2.0);
+                                aTransform.translate(aOffset.getX(),
+                                                     aOffset.getY());
+                                aSegment.transform(aTransform);
+                                
+                                // createPolygonFromEllipseSegment()
+                                // always creates arcs that are
+                                // positively oriented - flip polygon
+                                // if we swapped angles above
+                                if( bFlipSegment )
+                                    aSegment.flip();
+                                aCurrPoly.append(aSegment);
+                            }
+
+                            // set last position
+                            nLastX = nX;
+                            nLastY = nY;
                         }
                         break;
                     }
@@ -655,6 +849,32 @@
             return true;
         }
 
+        bool importFromSvgPoints( B2DPolygon&            o_rPoly,
+                                  const ::rtl::OUString& rSvgPointsAttribute )
+        {
+            o_rPoly.clear();
+            const sal_Int32 nLen(rSvgPointsAttribute.getLength());
+            sal_Int32 nPos(0);
+            double nX, nY;
+
+            // skip initial whitespace
+            lcl_skipSpaces(nPos, rSvgPointsAttribute, nLen);
+
+            while(nPos < nLen)
+            {
+                if(!lcl_importDoubleAndSpaces(nX, nPos, rSvgPointsAttribute, nLen)) return false;
+                if(!lcl_importDoubleAndSpaces(nY, nPos, rSvgPointsAttribute, nLen)) return false;
+                
+                // add point        
+                o_rPoly.append(B2DPoint(nX, nY));
+
+                // skip to next number, or finish
+                lcl_skipSpaces(nPos, rSvgPointsAttribute, nLen);
+            }
+
+            return true;
+        }
+
         ::rtl::OUString exportToSvgD(
 			const B2DPolyPolygon& rPolyPolygon,
 			bool bUseRelativeCoordinates, 
@@ -668,13 +888,23 @@
             {
                 const B2DPolygon aPolygon(rPolyPolygon.getB2DPolygon(i));
                 const sal_uInt32 nPointCount(aPolygon.count());
+
+                // simply skip empty polygons - avoids special-casing
+                // this below for the n+1 fix for closed polygons
+                if( !aPolygon.count() )
+                    continue;
+
                 const bool bPolyUsesControlPoints(aPolygon.areControlPointsUsed());
+                // to correctly write out closed curves, need to
+                // output first point twice (so output one additional
+                // point)
+                const sal_uInt32 nExtendedPointCount(nPointCount + aPolygon.isClosed()*bPolyUsesControlPoints);
                 sal_Unicode aLastSVGCommand(' '); // last SVG command char
 				B2DPoint aLeft, aRight; // for quadratic bezier test
 
-                for(sal_uInt32 j(0); j < nPointCount; j++)
+                for(sal_uInt32 j(0); j<nExtendedPointCount; j++)
                 {
-                    const B2DPoint aCurrent(aPolygon.getB2DPoint(j));
+                    const B2DPoint aCurrent(aPolygon.getB2DPoint(j%nPointCount));
 
                     if(0 == j)
                     {
@@ -687,16 +917,18 @@
                     else
                     {
 						// handle edge from j-1 to j
-						const bool bEdgeIsBezier(bPolyUsesControlPoints
-							&& (aPolygon.isNextControlPointUsed(j - 1) || aPolygon.isPrevControlPointUsed(j)));
-
+						const bool bEdgeIsBezier(
+                            bPolyUsesControlPoints
+                            && (aPolygon.isNextControlPointUsed((j - 1)%nPointCount) 
+                                || aPolygon.isPrevControlPointUsed(j%nPointCount)));
+                        
                         if(bEdgeIsBezier)
                         {
                             // handle bezier edge
-                            const B2DPoint aControl0(aPolygon.getNextControlPoint(j - 1));
-                            const B2DPoint aControl1(aPolygon.getPrevControlPoint(j));
-							const B2VectorContinuity aPrevCont(aPolygon.getContinuityInPoint(j - 1));
-							const bool bSymmetricControlVector(CONTINUITY_C2 == aPrevCont);
+                            const B2DPoint aControl0(aPolygon.getNextControlPoint((j - 1)%nPointCount));
+                            const B2DPoint aControl1(aPolygon.getPrevControlPoint(j%nPointCount));
+							const B2VectorContinuity aPrevCont(aPolygon.getContinuityInPoint((j - 1)%nPointCount));
+							const bool bSymmetricControlVector(j>1 && CONTINUITY_C2 == aPrevCont);
 							bool bIsQuadraticBezier(false);
 
 							if(bDetectQuadraticBeziers)
@@ -788,7 +1020,13 @@
                         }
                         else
                         {
-                            // normal straight line points
+                            // normal straight line points - no need
+                            // to write extra segments for closed
+                            // polygons here (see n+1 fix above for
+                            // reasoning)
+                            if( j==nPointCount )
+                                continue;
+
                             if(aLastPoint.getX() == aCurrent.getX())
                             {
 								// export as vertical line
--- basegfx/test/basegfx2d.cxx	18 Jul 2007 11:08:37 -0000	1.9
+++ basegfx/test/basegfx2d.cxx	28 Feb 2008 09:04:44 -0000
@@ -470,6 +470,37 @@
         aExport = tools::exportToSvgD( aPoly );
         CPPUNIT_ASSERT_MESSAGE("exporting complex polygon to SVG-D (round-trip)", 
                                !aExport.compareToAscii(sExportString2));
+
+        const B2DPolygon aCircle( 
+            tools::createPolygonFromEllipse( B2DPoint(0,0),
+                                             1.0, 2.0 ));
+        aExport = tools::exportToSvgD( B2DPolyPolygon(aCircle), false, false);
+
+        const char* sExportString3 =
+            "M1 0S0.552284749830794 2 0 2-1 1.10456949966159-1 0-0.552284749830794-2 0-2 1-1.10456949966159 1 0Z";
+        CPPUNIT_ASSERT_MESSAGE("exporting bezier circle polygon to SVG-D", 
+                               !aExport.compareToAscii(sExportString3));
+
+        ::std::ofstream output("elliptical_arc.gnuplot");
+        DebugPlotter aPlotter( "elliptical arg testcases",
+                               output );
+
+        tools::importFromSvgD( aPoly,
+                               ::rtl::OUString::createFromAscii( 
+                                   "M300,200 h-150 a150,150 0 1,0 150,-150 z") );
+        aPlotter.plot( aPoly, "a" );
+        tools::importFromSvgD( aPoly,
+                               ::rtl::OUString::createFromAscii( 
+                                   "M275,175 v-150 a150,150 0 0,0 -150,150 z") );
+        aPlotter.plot( aPoly, "b" );
+        tools::importFromSvgD( aPoly,
+                               ::rtl::OUString::createFromAscii( 
+            "M600,350 l 50,-25 "
+            "a25,25 -30 0,1 50,-25 l 50,-25 "
+            "a25,50 -30 0,1 50,-25 l 50,-25 "
+            "a25,75 -30 0,1 50,-25 l 50,-25 "
+            "a25,100 -30 0,1 50,-25 l 50,-25") );
+        aPlotter.plot( aPoly, "c" );
     }
 
     // Change the following lines only, if you add, remove or rename 
