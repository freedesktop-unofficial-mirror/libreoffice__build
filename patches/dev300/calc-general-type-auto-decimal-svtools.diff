diff --git svtools/inc/svtools/zforlist.hxx svtools/inc/svtools/zforlist.hxx
index bb4a589..148bba9 100644
--- svtools/inc/svtools/zforlist.hxx
+++ svtools/inc/svtools/zforlist.hxx
@@ -336,9 +336,20 @@ class SvNumberFormatterRegistry_Impl;
 class SVT_DLLPUBLIC SvNumberFormatter
 {
 public:
+    /** 
+     * We can't technically have an "infinite" value, so we use an arbitrary 
+     * upper precision threshold to represent the "unlimited" precision. 
+     */ 
+    static const sal_uInt16 UNLIMITED_PRECISION;
+
+    /** 
+     * Precision suitable for numbers displayed in input bar, for instance 
+     * Calc's formula input bar. 
+     */
+    static const sal_uInt16 INPUTSTRING_PRECISION;
 
-    /// Preferred ctor with service manager and language/country enum
-    SvNumberFormatter(
+	/// Preferred ctor with service manager and language/country enum
+	SvNumberFormatter(
         const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xSMgr,
         LanguageType eLang
         );
@@ -582,14 +593,13 @@ public:
 
     /// Whether nFIndex is a special builtin format
     BOOL IsSpecialStandardFormat( sal_uInt32 nFIndex, LanguageType eLnge );
-
-    /// Return the reference date
-    Date* GetNullDate();
-    /// Return the standard decimal precision
-    short GetStandardPrec();
-    /// Return whether zero suppression is switched on
-    BOOL GetNoZero() { return bNoZero; }
-    /** Get the type of a format (or NUMBERFORMAT_UNDEFINED if no entry),
+	/// Return the reference date
+	Date* GetNullDate();
+	/// Return the standard decimal precision
+    sal_uInt16 GetStandardPrec();
+	/// Return whether zero suppression is switched on
+	BOOL GetNoZero() { return bNoZero; }
+	/** Get the type of a format (or NUMBERFORMAT_UNDEFINED if no entry),
          but with NUMBERFORMAT_DEFINED masked out */
     short GetType(sal_uInt32 nFIndex);
 
diff --git svtools/inc/svtools/zformat.hxx svtools/inc/svtools/zformat.hxx
index 4c52b10..8158524 100644
--- svtools/inc/svtools/zformat.hxx
+++ svtools/inc/svtools/zformat.hxx
@@ -239,6 +239,12 @@ public:
     // in fact that could be any string used in number formats.
     static void LoadString( SvStream& rStream, String& rStr );
 
+    /** 
+     * Get output string from a numeric value that fits the number of 
+     * characters specified.
+     */
+    bool GetOutputString( double fNumber, sal_uInt16 nCharCount, String& rOutString ) const;
+
     BOOL GetOutputString( double fNumber, String& OutString, Color** ppColor );
     BOOL GetOutputString( String& sString, String& OutString, Color** ppColor );
 
@@ -490,6 +496,7 @@ private:
 
     // standard number output
     SVT_DLLPRIVATE void ImpGetOutputStandard( double& fNumber, String& OutString );
+    SVT_DLLPRIVATE void ImpGetOutputStdToPrecision( double& rNumber, String& rOutString, sal_uInt16 nPrecision ) const;
     // numbers in input line
     SVT_DLLPRIVATE void ImpGetOutputInputLine( double fNumber, String& OutString );
 
diff --git svtools/source/numbers/zforlist.cxx svtools/source/numbers/zforlist.cxx
index 4b13774..703a8d1 100644
--- svtools/source/numbers/zforlist.cxx
+++ svtools/source/numbers/zforlist.cxx
@@ -70,6 +70,7 @@
 #include <rtl/instance.hxx>
 
 #include <math.h>
+#include <limits>
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
@@ -190,11 +191,15 @@ SV_IMPL_PTRARR( NfWSStringsDtor, String* );
 #define NF_BANKSYMBOL_FIX_POSITION 1
 
 
+
 /***********************Funktionen SvNumberFormatter**************************/
 
+const sal_uInt16 SvNumberFormatter::UNLIMITED_PRECISION   = ::std::numeric_limits<sal_uInt16>::max();
+const sal_uInt16 SvNumberFormatter::INPUTSTRING_PRECISION = ::std::numeric_limits<sal_uInt16>::max()-1;
+
 SvNumberFormatter::SvNumberFormatter(
-            const Reference< XMultiServiceFactory >& xSMgr,
-            LanguageType eLang )
+			const Reference< XMultiServiceFactory >& xSMgr,
+			LanguageType eLang )
         :
         xServiceManager( xSMgr )
 {
@@ -349,14 +354,13 @@ Date* SvNumberFormatter::GetNullDate()
 
 void SvNumberFormatter::ChangeStandardPrec(short nPrec)
 {
-    pFormatScanner->ChangeStandardPrec(nPrec);
+	pFormatScanner->ChangeStandardPrec(nPrec);
 }
 
-short SvNumberFormatter::GetStandardPrec()
+sal_uInt16 SvNumberFormatter::GetStandardPrec()
 {
-    return pFormatScanner->GetStandardPrec();
+	return pFormatScanner->GetStandardPrec();
 }
-
 void SvNumberFormatter::ImpChangeSysCL( LanguageType eLnge, BOOL bLoadingSO5 )
 {
     if (eLnge == LANGUAGE_DONTKNOW)
@@ -1486,32 +1490,32 @@ sal_uInt32 SvNumberFormatter::GetStandardFormat( double fNumber, sal_uInt32 nFIn
 
 void SvNumberFormatter::GetInputLineString(const double& fOutNumber,
                                            sal_uInt32 nFIndex,
-                                           String& sOutString)
+										   String& sOutString)
 {
-    SvNumberformat* pFormat;
-    short nOldPrec;
-    Color* pColor;
-    pFormat = (SvNumberformat*) aFTable.Get(nFIndex);
-    if (!pFormat)
+	SvNumberformat* pFormat;
+	Color* pColor;
+	pFormat = (SvNumberformat*) aFTable.Get(nFIndex);
+	if (!pFormat)
         pFormat = aFTable.Get(ZF_STANDARD);
     LanguageType eLang = pFormat->GetLanguage();
     ChangeIntl( eLang );
-    short eType = pFormat->GetType() & ~NUMBERFORMAT_DEFINED;
-    if (eType == 0)
-        eType = NUMBERFORMAT_DEFINED;
-    nOldPrec = -1;
-    if (eType == NUMBERFORMAT_NUMBER || eType == NUMBERFORMAT_PERCENT
-                                     || eType == NUMBERFORMAT_CURRENCY
-                                     || eType == NUMBERFORMAT_SCIENTIFIC
+	short eType = pFormat->GetType() & ~NUMBERFORMAT_DEFINED;
+	if (eType == 0)
+		eType = NUMBERFORMAT_DEFINED;
+    sal_uInt16 nOldPrec = pFormatScanner->GetStandardPrec();
+    bool bPrecChanged = false;
+	if (eType == NUMBERFORMAT_NUMBER || eType == NUMBERFORMAT_PERCENT
+									 || eType == NUMBERFORMAT_CURRENCY
+									 || eType == NUMBERFORMAT_SCIENTIFIC
                                      || eType == NUMBERFORMAT_FRACTION)
-    {
-        if (eType != NUMBERFORMAT_PERCENT)	// spaeter Sonderbehandlung %
-            eType = NUMBERFORMAT_NUMBER;
-        nOldPrec = pFormatScanner->GetStandardPrec();
-        ChangeStandardPrec(300);						// Merkwert
-    }
-    sal_uInt32 nKey = nFIndex;
-    switch ( eType )
+	{
+		if (eType != NUMBERFORMAT_PERCENT)	// spaeter Sonderbehandlung %
+			eType = NUMBERFORMAT_NUMBER;
+        ChangeStandardPrec(INPUTSTRING_PRECISION);
+        bPrecChanged = true;
+	}
+	sal_uInt32 nKey = nFIndex;
+	switch ( eType )
     {	// #61619# immer vierstelliges Jahr editieren
         case NUMBERFORMAT_DATE :
             nKey = GetFormatIndex( NF_DATE_SYS_DDMMYYYY, eLang );
@@ -1528,12 +1532,12 @@ void SvNumberFormatter::GetInputLineString(const double& fOutNumber,
     {
         if ( eType == NUMBERFORMAT_TIME && pFormat->GetFormatPrecision() )
         {
-            nOldPrec = pFormatScanner->GetStandardPrec();
-            ChangeStandardPrec(300);						// Merkwert
+            ChangeStandardPrec(INPUTSTRING_PRECISION);
+            bPrecChanged = true;
         }
         pFormat->GetOutputString(fOutNumber, sOutString, &pColor);
     }
-    if (nOldPrec != -1)
+    if (bPrecChanged)
         ChangeStandardPrec(nOldPrec);
 }
 
diff --git svtools/source/numbers/zformat.cxx svtools/source/numbers/zformat.cxx
index 368fb16..37233de 100644
--- svtools/source/numbers/zformat.cxx
+++ svtools/source/numbers/zformat.cxx
@@ -57,6 +57,9 @@
 #include "numhead.hxx"
 #include <unotools/digitgroupingiterator.hxx>
 #include "nfsymbol.hxx"
+
+#include <cmath>
+
 using namespace svt;
 
 namespace {
@@ -66,6 +69,10 @@ struct Gregorian
         return ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("gregorian"));
     }
 };
+
+const sal_uInt16 UPPER_PRECISION = 300; // entirely arbitrary...
+const double EXP_LOWER_BOUND = 1.0E-4; // prefer scientific notation below this value.
+
 }
 
 const double _D_MAX_U_LONG_ = (double) 0xffffffff;      // 4294967295.0
@@ -1777,47 +1784,62 @@ void SvNumberformat::Build50Formatstring( String& rStr ) const
 
 void SvNumberformat::ImpGetOutputStandard(double& fNumber, String& OutString)
 {
-    USHORT nStandardPrec = rScan.GetStandardPrec();
+    sal_uInt16 nStandardPrec = rScan.GetStandardPrec();
+
     if ( fabs(fNumber) > 1.0E15 )       // #58531# war E16
+    {
+        nStandardPrec = ::std::min(nStandardPrec, static_cast<sal_uInt16>(14)); // limits to 14 decimals
         OutString = ::rtl::math::doubleToUString( fNumber,
                 rtl_math_StringFormat_E, nStandardPrec /*2*/,
                 GetFormatter().GetNumDecimalSep().GetChar(0));
+    }
     else
-    {
+        ImpGetOutputStdToPrecision(fNumber, OutString, nStandardPrec);
+}
+
+void SvNumberformat::ImpGetOutputStdToPrecision(double& rNumber, String& rOutString, sal_uInt16 nPrecision) const
+{
+    // Make sure the precision doesn't go over the maximum allowable precision.
+    nPrecision = ::std::min(UPPER_PRECISION, nPrecision);
+
 #if 0
 {
-        // debugger test case for ANSI standard correctness
-        ::rtl::OUString aTest;
-        // expect 0.00123   OK
-        aTest = ::rtl::math::doubleToUString( 0.001234567,
-                rtl_math_StringFormat_G, 3, '.', sal_True );
-        // expect 123       OK
-        aTest = ::rtl::math::doubleToUString( 123.4567,
-                rtl_math_StringFormat_G, 3, '.', sal_True );
-        // expect 123.5     OK
-        aTest = ::rtl::math::doubleToUString( 123.4567,
-                rtl_math_StringFormat_G, 4, '.', sal_True );
-        // expect 1e+03 (as 999.6 rounded to 3 significant digits results in
-        // 1000 with an exponent equal to significant digits)
-        // Currently (24-Jan-2003) we do fail in this case and output 1000
-        // instead, negligible.
-        aTest = ::rtl::math::doubleToUString( 999.6,
-                rtl_math_StringFormat_G, 3, '.', sal_True );
-        // expect what? result is 1.2e+004
-        aTest = ::rtl::math::doubleToUString( 12345.6789,
-                rtl_math_StringFormat_G, -3, '.', sal_True );
+    // debugger test case for ANSI standard correctness
+    ::rtl::OUString aTest;
+    // expect 0.00123   OK
+    aTest = ::rtl::math::doubleToUString( 0.001234567,
+            rtl_math_StringFormat_G, 3, '.', sal_True );
+    // expect 123       OK
+    aTest = ::rtl::math::doubleToUString( 123.4567,
+            rtl_math_StringFormat_G, 3, '.', sal_True );
+    // expect 123.5     OK
+    aTest = ::rtl::math::doubleToUString( 123.4567,
+            rtl_math_StringFormat_G, 4, '.', sal_True );
+    // expect 1e+03 (as 999.6 rounded to 3 significant digits results in
+    // 1000 with an exponent equal to significant digits)
+    // Currently (24-Jan-2003) we do fail in this case and output 1000
+    // instead, negligible.
+    aTest = ::rtl::math::doubleToUString( 999.6,
+            rtl_math_StringFormat_G, 3, '.', sal_True );
+    // expect what? result is 1.2e+004
+    aTest = ::rtl::math::doubleToUString( 12345.6789,
+            rtl_math_StringFormat_G, -3, '.', sal_True );
 }
 #endif
 
-        OutString = ::rtl::math::doubleToUString( fNumber,
-                rtl_math_StringFormat_F, nStandardPrec /*2*/,
-                GetFormatter().GetNumDecimalSep().GetChar(0), sal_True );
-        if (OutString.GetChar(0) == '-' &&
-            OutString.GetTokenCount('0') == OutString.Len())
-            OutString.EraseLeadingChars('-');            // nicht -0
-    }
-    ImpTransliterate( OutString, NumFor[0].GetNatNum() );
-    return;
+    // If truncating the value to desired precision alters the original value,
+    // we should show the trailing zeros, otherwise strip them.
+    double fRounded = ::rtl::math::round(rNumber, nPrecision);
+    bool bRemoveZeros = ::rtl::math::approxEqual(fRounded, rNumber);
+
+    rOutString = ::rtl::math::doubleToUString( rNumber,
+            rtl_math_StringFormat_F, nPrecision /*2*/,
+            GetFormatter().GetNumDecimalSep().GetChar(0), bRemoveZeros );
+    if (rOutString.GetChar(0) == '-' &&
+        rOutString.GetTokenCount('0') == rOutString.Len())
+        rOutString.EraseLeadingChars('-');            // nicht -0
+
+    ImpTransliterate( rOutString, NumFor[0].GetNatNum() );
 }
 
 void SvNumberformat::ImpGetOutputInputLine(double fNumber, String& OutString)
@@ -1958,6 +1980,71 @@ ULONG SvNumberformat::ImpGGTRound(ULONG x, ULONG y)
     }
 }
 
+namespace {
+
+void lcl_GetOutputStringScientific(
+    double fNumber, sal_uInt16 nCharCount, const SvNumberFormatter& rFormatter, String& rOutString)
+{
+    bool bSign = ::rtl::math::isSignBitSet(fNumber);
+
+    // 1.000E+015 (one digit and the decimal point, and the five chars for the exponential part, totalling 7).
+    sal_uInt16 nPrec = nCharCount > 7 ? nCharCount - 7 : 0;
+    if (nPrec && bSign)
+        // Make room for the negative sign.
+        --nPrec;
+
+    nPrec = ::std::min(nPrec, static_cast<sal_uInt16>(14)); // limit to 14 decimals.
+
+    rOutString = ::rtl::math::doubleToUString(
+        fNumber, rtl_math_StringFormat_E, nPrec, rFormatter.GetNumDecimalSep().GetChar(0));
+}
+
+}
+
+bool SvNumberformat::GetOutputString(double fNumber, sal_uInt16 nCharCount, String& rOutString) const
+{
+    using namespace std;
+
+    if (eType != NUMBERFORMAT_NUMBER)
+        return false;
+
+    double fTestNum = fNumber;
+    bool bSign = ::rtl::math::isSignBitSet(fTestNum);
+    if (bSign)
+        fTestNum = -fTestNum;
+
+    if (fTestNum < EXP_LOWER_BOUND)
+    {
+        lcl_GetOutputStringScientific(fNumber, nCharCount, GetFormatter(), rOutString);
+        return true;
+    }
+
+    double fExp = log10(fTestNum);
+    // Values < 1.0 always have one digit before the decimal point.
+    sal_uInt16 nDigitPre = fExp >= 0.0 ? static_cast<sal_uInt16>(ceil(fExp)) : 1;
+
+    if (nDigitPre > 15)
+    {
+        lcl_GetOutputStringScientific(fNumber, nCharCount, GetFormatter(), rOutString);
+        return true;
+    }
+
+    sal_uInt16 nPrec = nCharCount >= nDigitPre ? nCharCount - nDigitPre : 0;
+    if (nPrec && bSign)
+        // Subtract the negative sign.
+        --nPrec;
+    if (nPrec)
+        // Subtract the decimal point.
+        --nPrec;
+
+    ImpGetOutputStdToPrecision(fNumber, rOutString, nPrec);
+    if (rOutString.Len() > nCharCount)
+        // String still wider than desired.  Switch to scientific notation.
+        lcl_GetOutputStringScientific(fNumber, nCharCount, GetFormatter(), rOutString);
+
+    return true;
+}
+
 BOOL SvNumberformat::GetOutputString(double fNumber,
                                      String& OutString,
                                      Color** ppColor)
@@ -1981,16 +2068,43 @@ BOOL SvNumberformat::GetOutputString(double fNumber,
     BOOL bHadStandard = FALSE;
     if (bStandard)                              // einzelne Standardformate
     {
-        if (rScan.GetStandardPrec() == 300)     // alle Zahlformate InputLine
+        if (rScan.GetStandardPrec() == SvNumberFormatter::INPUTSTRING_PRECISION)     // alle Zahlformate InputLine
         {
             ImpGetOutputInputLine(fNumber, OutString);
-            return FALSE;
+            return false;
         }
         switch (eType)
         {
             case NUMBERFORMAT_NUMBER:                   // Standardzahlformat
+            {
+                if (rScan.GetStandardPrec() == SvNumberFormatter::UNLIMITED_PRECISION)
+                {
+                    bool bSign = ::rtl::math::isSignBitSet(fNumber);
+                    if (bSign)
+                        fNumber = -fNumber;
+                    ImpGetOutputInputLine(fNumber, OutString);
+                    if (fNumber < EXP_LOWER_BOUND)
+                    {
+                        xub_StrLen nLen = OutString.Len();
+                        if (!nLen)
+                            return false;
+        
+                        if (nLen > 11)
+                        {
+                            sal_uInt16 nStandardPrec = rScan.GetStandardPrec();
+                            nStandardPrec = ::std::min(nStandardPrec, static_cast<sal_uInt16>(14)); // limits to 14 decimals
+                            OutString = ::rtl::math::doubleToUString( fNumber,
+                                    rtl_math_StringFormat_E, nStandardPrec /*2*/,
+                                    GetFormatter().GetNumDecimalSep().GetChar(0), true);
+                        }
+                    }
+                    if (bSign)
+                        OutString.Insert('-', 0);
+                    return false;
+                }
                 ImpGetOutputStandard(fNumber, OutString);
                 bHadStandard = TRUE;
+            }
             break;
             case NUMBERFORMAT_DATE:
                 bRes |= ImpGetDateOutput(fNumber, 0, OutString);
diff --git svtools/source/numbers/zforscan.cxx svtools/source/numbers/zforscan.cxx
index ab780cd..119d292 100644
--- svtools/source/numbers/zforscan.cxx
+++ svtools/source/numbers/zforscan.cxx
@@ -465,14 +465,13 @@ void ImpSvNumberformatScan::ChangeNullDate(USHORT nDay, USHORT nMonth, USHORT nY
     if ( pNullDate )
         *pNullDate = Date(nDay, nMonth, nYear);
     else
-        pNullDate = new Date(nDay, nMonth, nYear);
+		pNullDate = new Date(nDay, nMonth, nYear);
 }
 
-void ImpSvNumberformatScan::ChangeStandardPrec(short nPrec)
+void ImpSvNumberformatScan::ChangeStandardPrec(sal_uInt16 nPrec)
 {
-    nStandardPrec = nPrec;
+	nStandardPrec = nPrec;
 }
-
 Color* ImpSvNumberformatScan::GetColor(String& sStr)
 {
     String sString = pFormatter->GetCharClass()->upper(sStr);
diff --git svtools/source/numbers/zforscan.hxx svtools/source/numbers/zforscan.hxx
index df243f1..cd3f13e 100644
--- svtools/source/numbers/zforscan.hxx
+++ svtools/source/numbers/zforscan.hxx
@@ -55,11 +55,12 @@ public:
     ~ImpSvNumberformatScan();
     void ChangeIntl();							// tauscht Keywords aus
 
-    void ChangeNullDate(USHORT nDay, USHORT nMonth, USHORT nYear);
-                                                // tauscht Referenzdatum aus
-    void ChangeStandardPrec(short nPrec);		// tauscht Standardprecision aus
 
-    xub_StrLen ScanFormat( String& rString, String& rComment );	// Aufruf der Scan-Analyse
+	void ChangeNullDate(USHORT nDay, USHORT nMonth, USHORT nYear);
+												// tauscht Referenzdatum aus
+    void ChangeStandardPrec(sal_uInt16 nPrec);  // tauscht Standardprecision aus
+
+	xub_StrLen ScanFormat( String& rString, String& rComment );	// Aufruf der Scan-Analyse
 
     void CopyInfo(ImpSvNumberformatInfo* pInfo,
                      USHORT nAnz);				// Kopiert die FormatInfo
@@ -96,11 +97,10 @@ public:
                 InitKeywords();
             return sNameStandardFormat;
         }
-    short GetStandardPrec() const				{ return nStandardPrec; }
-    const Color& GetRedColor() const			{ return StandardColor[4]; }
-    Color* GetColor(String& sStr);			// Setzt Hauptfarben oder
-                                                // definierte Farben
-
+    sal_uInt16 GetStandardPrec() const          { return nStandardPrec; }
+	const Color& GetRedColor() const			{ return StandardColor[4]; }
+	Color* GetColor(String& sStr);			// Setzt Hauptfarben oder
+												// definierte Farben
     // the compatibility currency symbol for old automatic currency formats
     const String& GetCurSymbol() const
         {
@@ -158,13 +158,13 @@ public:
 private:							// ---- privater Teil
     NfKeywordTable sKeyword; 					// Schluesselworte der Syntax
     Color StandardColor[NF_MAX_DEFAULT_COLORS];
-                                                // Array der Standardfarben
-    Date* pNullDate;							// 30Dec1899
-    String sNameStandardFormat;				// "Standard"
-    short nStandardPrec;						// default Precision fuer Standardformat (2)
-    SvNumberFormatter* pFormatter;				// Pointer auf die Formatliste
+												// Array der Standardfarben
+	Date* pNullDate;							// 30Dec1899
+	String sNameStandardFormat;				// "Standard"
+    sal_uInt16 nStandardPrec;                   // default Precision for Standardformat
+	SvNumberFormatter* pFormatter;				// Pointer auf die Formatliste
 
-    String sStrArray[NF_MAX_FORMAT_SYMBOLS];    // Array der Symbole
+	String sStrArray[NF_MAX_FORMAT_SYMBOLS];    // Array der Symbole
     short nTypeArray[NF_MAX_FORMAT_SYMBOLS];    // Array der Infos
                                                 // externe Infos:
     USHORT nAnzResStrings;						// Anzahl der Ergebnissymbole
