diff --git officecfg/registry/data/org/openoffice/ucb/Configuration.xcu officecfg/registry/data/org/openoffice/ucb/Configuration.xcu
index 988a475..c822331 100644
--- officecfg/registry/data/org/openoffice/ucb/Configuration.xcu
+++ officecfg/registry/data/org/openoffice/ucb/Configuration.xcu
@@ -178,6 +178,28 @@
                 <value/>
               </prop>
             </node>
+            <node oor:name="Provider14" oor:op="replace">
+              <prop oor:name="ServiceName">
+                <value>com.sun.star.ucb.WebDAVContentProvider</value>
+              </prop>
+              <prop oor:name="URLTemplate">
+                <value>webdav</value>
+              </prop>
+              <prop oor:name="Arguments">
+                <value/>
+              </prop>
+            </node>
+            <node oor:name="Provider15" oor:op="replace">
+              <prop oor:name="ServiceName">
+                <value>com.sun.star.ucb.WebDAVContentProvider</value>
+              </prop>
+              <prop oor:name="URLTemplate">
+                <value>webdavs</value>
+              </prop>
+              <prop oor:name="Arguments">
+                <value/>
+              </prop>
+            </node>
             <!-- We want the Provider to be the final fallback provider -->
             <node oor:name="Provider999" oor:op="replace" install:module="gio">
               <prop oor:name="ServiceName">
diff --git sal/inc/osl/file.h sal/inc/osl/file.h
index 482004f..e5b35e4 100644
--- sal/inc/osl/file.h
+++ sal/inc/osl/file.h
@@ -139,6 +139,7 @@ typedef enum {
 	osl_File_E_USERS,
 	osl_File_E_OVERFLOW,
 	osl_File_E_NOTREADY,
+	osl_File_E_TXTBSY,
 	osl_File_E_invalidError,		/* unmapped error: always last entry in enum! */
     osl_File_E_TIMEDOUT,
 	osl_File_E_NETWORK,
diff --git sal/inc/osl/file.hxx sal/inc/osl/file.hxx
index 26f2645..e989ff8 100644
--- sal/inc/osl/file.hxx
+++ sal/inc/osl/file.hxx
@@ -106,6 +106,7 @@ public:
 		E_USERS        = osl_File_E_USERS,
 		E_OVERFLOW     = osl_File_E_OVERFLOW,
 		E_NOTREADY     = osl_File_E_NOTREADY,
+		E_TXTBSY       = osl_File_E_TXTBSY,
 		E_invalidError = osl_File_E_invalidError,	/* unmapped error: always last entry in enum! */
         E_TIMEDOUT     = osl_File_E_TIMEDOUT,
 		E_NETWORK      = osl_File_E_NETWORK
diff --git sal/osl/unx/file_error_transl.cxx sal/osl/unx/file_error_transl.cxx
index 5333cfe..4ffa6be 100644
--- sal/osl/unx/file_error_transl.cxx
+++ sal/osl/unx/file_error_transl.cxx
@@ -247,6 +247,10 @@ oslFileError oslTranslateFileError(sal_Bool bIsError, int Errno)
             osl_error = osl_File_E_TIMEDOUT;
             break;
         
+        case ETXTBSY:
+            osl_error = osl_File_E_TXTBSY;
+            break;
+
         default:
             /* FIXME translateFileError: is this alright? Or add a new one: osl_File_E_Unknown? */
             osl_error = osl_File_E_invalidError;
diff --git sc/source/ui/docshell/docsh.cxx sc/source/ui/docshell/docsh.cxx
index 07e68a5..8591efa 100644
--- sc/source/ui/docshell/docsh.cxx
+++ sc/source/ui/docshell/docsh.cxx
@@ -1025,7 +1025,7 @@ BOOL __EXPORT ScDocShell::ConvertFrom( SfxMedium& rMedium )
 	//	Alle Filter brauchen die komplette Datei am Stueck (nicht asynchron),
 	//	darum vorher per CreateFileStream dafuer sorgen, dass die komplette
 	//	Datei uebertragen wird.
-	rMedium.GetPhysicalName();	//! CreateFileStream direkt rufen, wenn verfuegbar
+	rMedium.GetPhysicalName( sal_False );	//! CreateFileStream direkt rufen, wenn verfuegbar
 
     SFX_ITEMSET_ARG( rMedium.GetItemSet(), pUpdateDocItem, SfxUInt16Item, SID_UPDATEDOCMODE, sal_False);
     nCanUpdate = pUpdateDocItem ? pUpdateDocItem->GetValue() : com::sun::star::document::UpdateDocMode::NO_UPDATE;
diff --git sfx2/inc/sfx2/docfile.hxx sfx2/inc/sfx2/docfile.hxx
index 219cf18..b548b22 100644
--- sfx2/inc/sfx2/docfile.hxx
+++ sfx2/inc/sfx2/docfile.hxx
@@ -181,7 +181,7 @@ public:
     ::com::sun::star::util::DateTime GetInitFileDate();
 
     ::com::sun::star::uno::Reference< ::com::sun::star::ucb::XContent > GetContent() const;
-	const String&       GetPhysicalName() const;
+	const String&       GetPhysicalName( sal_Bool bForceCreateTempIfRemote = sal_True ) const;
 	void                SetTemporary( sal_Bool bTemp );
     sal_Bool            IsTemporary() const;
     sal_Bool            IsRemote();
@@ -254,6 +254,8 @@ public:
 	void				SetCharset( ::rtl::OUString );
     ::rtl::OUString     GetBaseURL( bool bForSaving=false );
 
+    sal_Bool            SupportsActiveStreaming( const rtl::OUString &rName ) const;
+
 #if _SOLAR__PRIVATE
 //REMOVE		// the storage will be truncated, if it is still not open then the stream will be truncated
 //REMOVE	    ::com::sun::star::uno::Reference< ::com::sun::star::embed::XStorage > GetOutputStorage_Impl();
diff --git sfx2/source/bastyp/helper.cxx sfx2/source/bastyp/helper.cxx
index 3e08e8a..2206cc9 100644
--- sfx2/source/bastyp/helper.cxx
+++ sfx2/source/bastyp/helper.cxx
@@ -796,16 +796,15 @@ ErrCode SfxContentHelper::QueryDiskSpace( const String& rPath, sal_Int64& rFreeB
 
 // -----------------------------------------------------------------------
 
-ULONG SfxContentHelper::GetSize( const String& rContent )
+sal_Int64 SfxContentHelper::GetSize( const String& rContent )
 {
-	ULONG nSize = 0;
-	sal_Int64 nTemp = 0;
+	sal_Int64 nSize = -1;
     INetURLObject aObj( rContent );
     DBG_ASSERT( aObj.GetProtocol() != INET_PROT_NOT_VALID, "Invalid URL!" );
 	try
 	{
 		::ucbhelper::Content aCnt( aObj.GetMainURL( INetURLObject::NO_DECODE ), uno::Reference< ucb::XCommandEnvironment > () );
-		aCnt.getPropertyValue( OUString::createFromAscii( "Size" ) ) >>= nTemp;
+		aCnt.getPropertyValue( OUString::createFromAscii( "Size" ) ) >>= nSize;
 	}
 	catch( ucb::CommandAbortedException& )
 	{
@@ -815,7 +814,6 @@ ULONG SfxContentHelper::GetSize( const String& rContent )
 	{
 		DBG_ERRORFILE( "Any other exception" );
 	}
-	nSize = (UINT32)nTemp;
 	return nSize;
 }
 
diff --git sfx2/source/dialog/dinfdlg.cxx sfx2/source/dialog/dinfdlg.cxx
index 7455a59..075f9ee 100644
--- sfx2/source/dialog/dinfdlg.cxx
+++ sfx2/source/dialog/dinfdlg.cxx
@@ -1066,8 +1066,9 @@ void SfxDocumentPage::Reset( const SfxItemSet& rSet )
 
 	// determine size and type
 	String aSizeText( aUnknownSize );
-	if ( aURL.GetProtocol() == INET_PROT_FILE )
-		aSizeText = CreateSizeText( SfxContentHelper::GetSize( aURL.GetMainURL( INetURLObject::NO_DECODE ) ) );
+	sal_Int64 nSize = SfxContentHelper::GetSize( aURL.GetMainURL( INetURLObject::NO_DECODE ) );
+	if ( nSize >= 0 )
+		aSizeText = CreateSizeText( static_cast< ULONG >( nSize ) );
 	aShowSizeFT.SetText( aSizeText );
 
 	String aDescription = SvFileInformationManager::GetDescription( INetURLObject(rMainURL) );
diff --git sfx2/source/doc/docfile.cxx sfx2/source/doc/docfile.cxx
index 44bf761..d80a13b 100644
--- sfx2/source/doc/docfile.cxx
+++ sfx2/source/doc/docfile.cxx
@@ -653,10 +653,13 @@ sal_Bool SfxMedium::CloseOutStream_Impl()
 }
 
 //------------------------------------------------------------------
-const String& SfxMedium::GetPhysicalName() const
+const String& SfxMedium::GetPhysicalName( sal_Bool bForceCreateTempIfRemote ) const
 {
     if ( !aName.Len() && aLogicName.Len() )
-        (( SfxMedium*)this)->CreateFileStream();
+    {
+        if ( bForceCreateTempIfRemote || !SupportsActiveStreaming( aLogicName ) )
+            (( SfxMedium*)this)->CreateFileStream();
+    }
 
     // return the name then
     return aName;
@@ -692,8 +692,6 @@ sal_Bool SfxMedium::Commit()
         GetInitFileDate();
     }
 
-    // remove truncation mode from the flags
-    nStorOpenMode &= (~STREAM_TRUNC);
     return bResult;
 }
 
@@ -822,11 +825,31 @@ sal_Bool SfxMedium::TryStorage()
 }
 
 //------------------------------------------------------------------
+sal_Bool SfxMedium::SupportsActiveStreaming( const rtl::OUString &rName ) const
+{
+    if ( ::utl::LocalFileHelper::IsLocalFile( rName ) )
+        return sal_True;
+
+    ::ucbhelper::Content aTmpContent;
+    Reference< ::com::sun::star::ucb::XCommandEnvironment > xDummyEnv;
+    if ( ::ucbhelper::Content::create( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ), xDummyEnv, aTmpContent ) )
+    {
+        Any aAny = aTmpContent.getPropertyValue(
+                ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "SupportsActiveStreaming" )) );
+
+        sal_Bool bSupportsStreaming = sal_False;
+        return ( ( aAny >>= bSupportsStreaming ) && bSupportsStreaming );
+    }
+
+    return sal_False;
+}
+
+//------------------------------------------------------------------
 sal_Bool SfxMedium::BasedOnOriginalFile_Impl()
 {
 	return ( !pImp->pTempFile && !( aLogicName.Len() && pImp->m_bSalvageMode )
 	  && GetURLObject().GetMainURL( INetURLObject::NO_DECODE ).getLength()
-      && ::utl::LocalFileHelper::IsLocalFile( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) )
+ 	  && SupportsActiveStreaming( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) )
 	  && ::utl::UCBContentHelper::IsDocument( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) );
 }
 
@@ -892,10 +890,105 @@ uno::Reference < embed::XStorage > SfxMe
 
     DBG_ASSERT( !pOutStream, "OutStream in a readonly Medium?!" );
 
-    // TODO/LATER: The current solution is to store the document temporary and then copy it to the target location;
-    // in future it should be stored directly and then copied to the temporary location, since in this case no
-    // file attributes have to be preserved and system copying mechanics could be used instead of streaming.
+    // medium based on OutputStream: must work with TempFile
+    if( aLogicName.CompareToAscii( "private:stream", 14 ) == COMPARE_EQUAL
+	  || !::utl::LocalFileHelper::IsLocalFile( aLogicName ) )
     CreateTempFileNoCopy();
+	// if Medium already contains a stream - TODO/LATER: store stream/outputstream in ImplData, not in Medium
+	else if ( GetItemSet()->GetItemState( SID_STREAM ) < SFX_ITEM_SET )
+	{
+		// check whether the backup should be created
+		StorageBackup_Impl();
+
+		if ( GetError() )
+			return uno::Reference< embed::XStorage >();
+
+        ::rtl::OUString aOutputURL = GetOutputStorageURL_Impl();
+
+        SFX_ITEMSET_ARG( GetItemSet(), pOverWrite, SfxBoolItem, SID_OVERWRITE, sal_False );
+        SFX_ITEMSET_ARG( GetItemSet(), pRename, SfxBoolItem, SID_RENAME, sal_False );
+        sal_Bool bRename = pRename ? pRename->GetValue() : FALSE;
+        sal_Bool bOverWrite = pOverWrite ? pOverWrite->GetValue() : !bRename;
+
+        // the target file must be truncated before a storage based on it is created
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xFactory = ::comphelper::getProcessServiceFactory();
+            uno::Reference< ::com::sun::star::ucb::XSimpleFileAccess > xSimpleFileAccess(
+                    xFactory->createInstance( ::rtl::OUString::createFromAscii("com.sun.star.ucb.SimpleFileAccess") ),
+                    uno::UNO_QUERY_THROW );
+
+            uno::Reference< ucb::XCommandEnvironment > xDummyEnv;
+            ::ucbhelper::Content aContent = ::ucbhelper::Content( aOutputURL, xDummyEnv );
+
+            uno::Reference< io::XStream > xStream;
+            sal_Bool bDeleteOnFailure = sal_False;
+
+            try
+            {
+                xStream = aContent.openWriteableStreamNoLock();
+
+                if ( !bOverWrite )
+                {
+                    // the stream should not exist, it should not be possible to open it
+                    if ( xStream->getOutputStream().is() )
+                        xStream->getOutputStream()->closeOutput();
+                    if ( xStream->getInputStream().is() )
+                        xStream->getInputStream()->closeInput();
+
+                    xStream = uno::Reference< io::XStream >();
+                    SetError( ERRCODE_IO_GENERAL );
+                }
+            }
+            catch ( ucb::InteractiveIOException const & e )
+            {
+                if ( e.Code == ucb::IOErrorCode_NOT_EXISTING )
+                {
+                    // Create file...
+                    SvMemoryStream aStream(0,0);
+                    uno::Reference< io::XInputStream > xInput( new ::utl::OInputStreamWrapper( aStream ) );
+                    ucb::InsertCommandArgument aInsertArg;
+                    aInsertArg.Data = xInput;
+                    aInsertArg.ReplaceExisting = sal_False;
+                    aContent.executeCommand( rtl::OUString::createFromAscii( "insert" ), uno::makeAny( aInsertArg ) );
+
+                    // Try to open one more time
+                    xStream = aContent.openWriteableStreamNoLock();
+                    bDeleteOnFailure = sal_True;
+                }
+                else
+                    throw;
+            }
+
+            if ( xStream.is() )
+            {
+                if ( BasedOnOriginalFile_Impl() )
+                {
+                    // the storage will be based on original file, the wrapper should be used
+                    xStream = new OPostponedTruncationFileStream( aOutputURL, xFactory, xSimpleFileAccess, xStream, bDeleteOnFailure );
+                }
+                else
+                {
+                    // the storage will be based on the temporary file, the stream can be truncated directly
+                    uno::Reference< io::XOutputStream > xOutStream = xStream->getOutputStream();
+                    uno::Reference< io::XTruncate > xTruncate( xOutStream, uno::UNO_QUERY );
+                    if ( !xTruncate.is() )
+                        throw uno::RuntimeException();
+
+                    xTruncate->truncate();
+                    xOutStream->flush();
+                }
+
+                pImp->xStream = xStream;
+                GetItemSet()->Put( SfxUsrAnyItem( SID_STREAM, makeAny( xStream ) ) );
+            }
+        }
+        catch( uno::Exception& )
+        {
+            // TODO/LATER: try to use the temporary file in case the target content can not be opened, it might happen in case of some FS, the copy functionality might work in this case
+            SetError( ERRCODE_IO_GENERAL );
+        }
+    }
 
     return GetStorage();
 }
@@ -1165,7 +1188,7 @@ uno::Reference < embed::XStorage > SfxMedium::GetStorage()
 
             try
             {
-                if ( IsReadOnly() && ::utl::LocalFileHelper::IsLocalFile( aLogicName ) )
+                if ( IsReadOnly() && SupportsActiveStreaming( aLogicName ) )
                 {
                     //TODO/LATER: performance problem if not controlled by special Mode in SfxMedium
                     //(should be done only for permanently open storages)
@@ -1982,7 +2005,7 @@ void SfxMedium::Transfer_Impl()
 			xComEnv = new ::ucbhelper::CommandEnvironment( xInteractionHandler,
 													  Reference< ::com::sun::star::ucb::XProgressHandler >() );
 
-        if ( ::utl::LocalFileHelper::IsLocalFile( aDest.GetMainURL( INetURLObject::NO_DECODE ) ) || !aDest.removeSegment() )
+        if ( SupportsActiveStreaming( aDest.GetMainURL( INetURLObject::NO_DECODE ) ) || !aDest.removeSegment() )
 		{
 			TransactedTransferForFS_Impl( aSource, aDest, xComEnv );
 		}
@@ -2529,7 +2529,7 @@
                     aMedium.erase( comphelper::MediaDescriptor::PROP_READONLY() );
                     aMedium.addInputStream();
                 }
-                else if ( ::utl::LocalFileHelper::IsLocalFile( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) )
+                else if ( SupportsActiveStreaming( GetURLObject().GetMainURL( INetURLObject::NO_DECODE ) ) )
                 {
                     // use the special locking approach only for file URLs
                     aMedium.addInputStreamOwnLock();
diff --git sfx2/source/inc/helper.hxx sfx2/source/inc/helper.hxx
index f37477d..1f46ed7 100644
--- sfx2/source/inc/helper.hxx
+++ sfx2/source/inc/helper.hxx
@@ -69,7 +69,7 @@ public:
 
 	static sal_Bool				MakeFolder( const String& rFolder );
 	static ErrCode				QueryDiskSpace( const String& rPath, sal_Int64& rFreeBytes );
-	static ULONG				GetSize( const String& rContent );
+	static sal_Int64			GetSize( const String& rContent );
 	static sal_Bool				IsYounger( const String& rIsYoung, const String& rIsOlder );
 
 	// please don't use this!
diff --git sfx2/source/view/viewfrm.cxx sfx2/source/view/viewfrm.cxx
index c19a833..160fe9b 100644
--- sfx2/source/view/viewfrm.cxx
+++ sfx2/source/view/viewfrm.cxx
@@ -626,6 +626,11 @@ void SfxViewFrame::ExecReload_Impl( SfxRequest& rReq )
                 sal_Bool bHandsOff =
                     ( pMedium->GetURLObject().GetProtocol() == INET_PROT_FILE && !xOldObj->IsDocShared() );
 
+                // we must do the same for the contents that support active
+                // streaming
+                if ( !bHandsOff && pMedium && pMedium->SupportsActiveStreaming( aURL ) )
+                    bHandsOff = sal_True;
+
                 // bestehende SfxMDIFrames f"ur dieses Doc leeren
                 // eigenes Format oder R/O jetzt editierbar "offnen?
                 SfxViewNotificatedFrameList_Impl aFrames;
diff --git tools/inc/tools/urlobj.hxx tools/inc/tools/urlobj.hxx
index 10202ab..2ab1459 100644
--- tools/inc/tools/urlobj.hxx
+++ tools/inc/tools/urlobj.hxx
@@ -141,9 +141,14 @@ enum INetProtocol
     INET_PROT_TELNET = 28,
     INET_PROT_VND_SUN_STAR_EXPAND = 29,
     INET_PROT_VND_SUN_STAR_TDOC = 30,
-    INET_PROT_GENERIC = 31,
-    INET_PROT_SMB = 32,
-	INET_PROT_END = 33
+    INET_PROT_SMB = 31,
+    INET_PROT_DAV = 32,
+    INET_PROT_DAVS = 33,
+    INET_PROT_WEBDAV = 34,
+    INET_PROT_WEBDAVS = 35,
+    INET_PROT_GENERIC = 36,
+    INET_PROT_GENERIC_HIERARCHICAL = 37,
+    INET_PROT_END = 38
 };
 
 //============================================================================
diff --git tools/source/fsys/urlobj.cxx tools/source/fsys/urlobj.cxx
index f195b18..55aa073 100644
--- tools/source/fsys/urlobj.cxx
+++ tools/source/fsys/urlobj.cxx
@@ -374,21 +374,21 @@ static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
 		  false },
 		{ "ftp", "ftp://", 21, true, true, false, true, true, true, true,
 		  false },
-		{ "http", "http://", 80, true, false, false, false, true, true,
+		{ "http", "http://", 80, true, true, false, true, true, true,
 		  true, true },
 		{ "file", "file://", 0, true, false, false, false, true, false,
 		  true, false },
 		{ "mailto", "mailto:", 0, false, false, false, false, false,
 		  false, false, true },
-		{ "vnd.sun.star.webdav", "vnd.sun.star.webdav://", 80, true, false,
-		  false, false, true, true, true, true },
+		{ "vnd.sun.star.webdav", "vnd.sun.star.webdav://", 80, true, true,
+		  false, true, true, true, true, true },
 		{ "news", "news:", 0, false, false, false, false, false, false, false,
           false },
 		{ "private", "private:", 0, false, false, false, false, false,
 		  false, false, true },
 		{ "vnd.sun.star.help", "vnd.sun.star.help://", 0, true, false, false,
 		  false, false, false, true, true },
-		{ "https", "https://", 443, true, false, false, false, true, true,
+		{ "https", "https://", 443, true, true, false, true, true, true,
 		  true, true },
 		{ "slot", "slot:", 0, false, false, false, false, false, false,
 		  false, true },
@@ -432,9 +432,19 @@ static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
 		  false, false, false, false, false },
         { "vnd.sun.star.tdoc", "vnd.sun.star.tdoc:", 0, false, false, false,
           false, false, false, true, false },
-        { "", "", 0, false, false, false, false, false, false, false, false },
         { "smb", "smb://", 139, true, true, false, true, true, true, true,
-          true } };
+          true },
+        { "dav", "dav://", 80, true, true, false, true, true, true, true,
+          true },
+        { "davs", "davs://", 443, true, true, false, true, true, true,
+          true, true },
+        { "webdav", "webdav://", 80, true, true, false, true, true, true, true,
+          true },
+        { "webdavs", "webdavs://", 443, true, true, false, true, true, true,
+          true, true },
+        { "", "", 0, false, false, false, false, false, false, false, false },
+        { "", "", 0, false, false, false, false, false, false, true, false }
+      };
 
 // static
 inline INetURLObject::SchemeInfo const &
@@ -847,7 +857,10 @@ bool INetURLObject::setAbsURIRef(rtl::OUString const & rTheAbsURIRef,
             aSynScheme = parseScheme(&p1, pEnd, nFragmentDelimiter);
             if (aSynScheme.getLength() > 0)
             {
-                m_eScheme = INET_PROT_GENERIC;
+                if (p1 != pEnd && *p1 == '/')
+                    m_eScheme = INET_PROT_GENERIC_HIERARCHICAL;
+                else
+                    m_eScheme = INET_PROT_GENERIC;
                 pPos = p1;
             }
         }
@@ -864,8 +877,9 @@ bool INetURLObject::setAbsURIRef(rtl::OUString const & rTheAbsURIRef,
 			return false;
 		}
 
-        if (m_eScheme != INET_PROT_GENERIC) {
-            aSynScheme = rtl::OUString::createFromAscii(getSchemeInfo().m_pScheme);
+        const char *pSchemeName = getSchemeInfo().m_pScheme;
+        if (pSchemeName[0] != '\0') {
+            aSynScheme = rtl::OUString::createFromAscii(pSchemeName);
         }
         m_aScheme.set(aSynAbsURIRef, aSynScheme, aSynAbsURIRef.getLength());
         aSynAbsURIRef.append(sal_Unicode(':'));
@@ -2052,6 +2066,8 @@ INetURLObject::getPrefix(sal_Unicode const *& rBegin,
 			  PrefixInfo::INTERNAL },
 			{ "cid:", 0, INET_PROT_CID, PrefixInfo::OFFICIAL },
 			{ "data:", 0, INET_PROT_DATA, PrefixInfo::OFFICIAL },
+			{ "dav:", 0, INET_PROT_DAV, PrefixInfo::OFFICIAL },
+			{ "davs:", 0, INET_PROT_DAVS, PrefixInfo::OFFICIAL },
 			{ "db:", "staroffice.db:", INET_PROT_DB, PrefixInfo::INTERNAL },
 			{ "file:", 0, INET_PROT_FILE, PrefixInfo::OFFICIAL },
 			{ "ftp:", 0, INET_PROT_FTP, PrefixInfo::OFFICIAL },
@@ -2133,6 +2149,8 @@ INetURLObject::getPrefix(sal_Unicode const *& rBegin,
 			  PrefixInfo::OFFICIAL },
 			{ "vnd.sun.star.wfs:", 0, INET_PROT_VND_SUN_STAR_WFS,
 			  PrefixInfo::OFFICIAL },
+			{ "webdav:", 0, INET_PROT_WEBDAV, PrefixInfo::OFFICIAL },
+			{ "webdavs:", 0, INET_PROT_WEBDAVS, PrefixInfo::OFFICIAL },
 			{ "wfs:", "vnd.sun.star.wfs:", INET_PROT_VND_SUN_STAR_WFS,
 			  PrefixInfo::ALIAS } };
 	PrefixInfo const * pFirst = aMap + 1;
@@ -2929,6 +2947,10 @@ bool INetURLObject::parsePath(INetProtocol eScheme,
 		case INET_PROT_VND_SUN_STAR_WEBDAV:
 		case INET_PROT_HTTPS:
         case INET_PROT_SMB:
+        case INET_PROT_DAV:
+        case INET_PROT_DAVS:
+        case INET_PROT_WEBDAV:
+        case INET_PROT_WEBDAVS:
 			if (pPos < pEnd && *pPos != '/')
 				return false;
 			while (pPos < pEnd && *pPos != nQueryDelimiter
@@ -3343,6 +3365,7 @@ bool INetURLObject::parsePath(INetProtocol eScheme,
 			break;
 
         case INET_PROT_GENERIC:
+        case INET_PROT_GENERIC_HIERARCHICAL:
 			while (pPos < pEnd && *pPos != nFragmentDelimiter)
 			{
 				EscapeType eEscapeType;
@@ -4044,10 +4067,13 @@ bool INetURLObject::ConcatData(INetProtocol eTheScheme,
 {
 	setInvalid();
 	m_eScheme = eTheScheme;
-	if (HasError() || m_eScheme == INET_PROT_GENERIC)
+	const char *pSchemeName = getSchemeInfo().m_pScheme;
+
+	if (HasError() || pSchemeName[0] == '\0')
 		return false;
+
 	m_aAbsURIRef.setLength(0);
-	m_aAbsURIRef.appendAscii(getSchemeInfo().m_pScheme);
+	m_aAbsURIRef.appendAscii(pSchemeName);
 	m_aAbsURIRef.append(sal_Unicode(':'));
 	if (getSchemeInfo().m_bAuthority)
 	{
diff --git tools/workben/urltest.cxx tools/workben/urltest.cxx
index dd0f964..74380be 100644
--- tools/workben/urltest.cxx
+++ tools/workben/urltest.cxx
@@ -1476,7 +1476,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("A-b.3:/%2f?x#y"));
         urlobj = INetURLObject(url);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("a-b.3:/%2F?x#y")),
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
@@ -1504,7 +1504,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("foo:/"));
         urlobj = INetURLObject(url);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, url,
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
@@ -1542,7 +1542,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("A-b.3:/%2f?x#y"));
         urlobj = INetURLObject(url, INET_PROT_CID);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("a-b.3:/%2F?x#y")),
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
@@ -1563,7 +1563,7 @@ main()
 
         url = rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("foo:/"));
         urlobj = INetURLObject(url, INET_PROT_CID);
-        bSuccess &= assertEqual(url, INET_PROT_GENERIC, urlobj.GetProtocol());
+        bSuccess &= assertEqual(url, INET_PROT_GENERIC_HIERARCHICAL, urlobj.GetProtocol());
         bSuccess &= assertEqual(
             url, url,
             rtl::OUString(urlobj.GetMainURL(INetURLObject::NO_DECODE)));
diff --git ucb/source/ucp/file/filglob.cxx ucb/source/ucp/file/filglob.cxx
index b1fc23e..1a89ce0 100644
--- ucb/source/ucp/file/filglob.cxx
+++ ucb/source/ucp/file/filglob.cxx
@@ -435,17 +435,13 @@ namespace fileaccess {
 					// not enough memory for allocating structures 
 					ioErrorCode = IOErrorCode_OUT_OF_MEMORY;
 					break;
-				case FileBase::E_BUSY:
-					// Text file busy
-					ioErrorCode = IOErrorCode_LOCKING_VIOLATION;
-					break;
-                case FileBase::E_AGAIN:
-					// Operation would block
+
+				case FileBase::E_BUSY:  // Text file busy
+				case FileBase::E_AGAIN: // Operation would block
+				case FileBase::E_NOLCK: // No record locks available
+				case FileBase::E_TXTBSY:// Text file busy
 					ioErrorCode = IOErrorCode_LOCKING_VIOLATION;
 					break;
-				case FileBase::E_NOLCK:  // No record locks available
-                    ioErrorCode = IOErrorCode_LOCKING_VIOLATION;
-                    break;
 
 				case FileBase::E_FAULT: // Bad address
 				case FileBase::E_LOOP:	// Too many symbolic links encountered
diff -u ucb/webdav-orig/DAVRequestEnvironment.hxx ucb/source/ucp/webdav/DAVRequestEnvironment.hxx
--- ucb/webdav-orig/DAVRequestEnvironment.hxx	2009-03-05 13:01:30.378250000 +0200
+++ ucb/source/ucp/webdav/DAVRequestEnvironment.hxx	2009-03-02 17:52:48.425125000 +0200
@@ -34,6 +34,10 @@
 #include <rtl/ref.hxx>
 #include "DAVAuthListener.hxx"
 
+#ifndef _COM_SUN_STAR_UCB_XCOMMANDENVIRONMENT_HPP_
+#include <com/sun/star/ucb/XCommandEnvironment.hpp>
+#endif
+
 namespace webdav_ucp
 {
     typedef std::pair< rtl::OUString, rtl::OUString > DAVRequestHeader;
@@ -46,12 +50,12 @@
 //    rtl::Reference< DAVStatusListener >   m_xStatusListener;
 //    rtl::Reference< DAVProgressListener > m_xStatusListener;
     DAVRequestHeaders                     m_aRequestHeaders;
-    uno::Reference< ucb::XCommandEnvironment > m_xEnv;
+    com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > m_xEnv;
 
-DAVRequestEnvironment( const rtl::OUString & rRequestURI,
+    DAVRequestEnvironment( const rtl::OUString & rRequestURI,
                            const rtl::Reference< DAVAuthListener > & xListener,
                            const DAVRequestHeaders & rRequestHeaders,
-                           const uno::Reference< ucb::XCommandEnvironment > & xEnv)
+                           const com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > & xEnv)
     : m_aRequestURI( rRequestURI ), 
       m_xAuthListener( xListener ),
       m_aRequestHeaders( rRequestHeaders ),
diff -u ucb/webdav-orig/DAVResourceAccess.cxx ucb/source/ucp/webdav/DAVResourceAccess.cxx
--- ucb/webdav-orig/DAVResourceAccess.cxx	2009-03-05 13:01:30.409500000 +0200
+++ ucb/source/ucp/webdav/DAVResourceAccess.cxx	2009-03-05 19:50:51.659500000 +0200
@@ -42,6 +42,9 @@
 #include "DAVAuthListenerImpl.hxx"
 #include "DAVResourceAccess.hxx"
 
+#include <comphelper/processfactory.hxx>
+#include <ucbhelper/commandenvironment.hxx>
+
 using namespace webdav_ucp;
 using namespace com::sun::star;
 
@@ -61,56 +64,55 @@
     ::rtl::OUString & inoutUserName,
     ::rtl::OUString & outPassWord )
 {
-    if ( m_xEnv.is() )
-    {
-        uno::Reference< task::XInteractionHandler > xIH
-            = m_xEnv->getInteractionHandler();
-        if ( xIH.is() )
-        {
-            // #102871# - Supply username and password from previous try.
-            // Password container service depends on this!
-            if ( inoutUserName.getLength() == 0 )
-                inoutUserName = m_aPrevUsername;
-
-            if ( outPassWord.getLength() == 0 )
-                outPassWord = m_aPrevPassword;
-
-            rtl::Reference< ucbhelper::SimpleAuthenticationRequest > xRequest
-                = new ucbhelper::SimpleAuthenticationRequest( inHostName,
-                                                              inRealm,
-                                                              inoutUserName,
-                                                              outPassWord );
-            xIH->handle( xRequest.get() );
+    uno::Reference< task::XInteractionHandler > xIH;
 
-            rtl::Reference< ucbhelper::InteractionContinuation > xSelection
-				= xRequest->getSelection();
-            
-            if ( xSelection.is() )
-            {
-                // Handler handled the request.
-                uno::Reference< task::XInteractionAbort > xAbort(
-                    xSelection.get(), uno::UNO_QUERY );
-                if ( !xAbort.is() )
-                {
-                    const rtl::Reference<
-                        ucbhelper::InteractionSupplyAuthentication > & xSupp
-                        = xRequest->getAuthenticationSupplier();
-
-                    inoutUserName = xSupp->getUserName();
-                    outPassWord   = xSupp->getPassword();
-		    
-                    // #102871# - Remember username and password.
-                    m_aPrevUsername = inoutUserName;
-                    m_aPrevPassword = outPassWord;
+    if ( m_xEnv.is() )
+        xIH = m_xEnv->getInteractionHandler();
+    else
+        xIH = DAVResourceAccess::createCommandEnvironment()->getInteractionHandler();
+
+    if ( !xIH.is() )
+        return -1;
+
+    // #102871# - Supply username and password from previous try.
+    // Password container service depends on this!
+    if ( inoutUserName.getLength() == 0 )
+        inoutUserName = m_aPrevUsername;
+
+    if ( outPassWord.getLength() == 0 )
+        outPassWord = m_aPrevPassword;
+
+    rtl::Reference< ucbhelper::SimpleAuthenticationRequest > xRequest
+        = new ucbhelper::SimpleAuthenticationRequest( inHostName,
+                inRealm,
+                inoutUserName,
+                outPassWord );
+    xIH->handle( xRequest.get() );
+
+    rtl::Reference< ucbhelper::InteractionContinuation > xSelection
+        = xRequest->getSelection();
+
+    if ( !xSelection.is() )
+        return -1;
+
+    // Handler handled the request.
+    uno::Reference< task::XInteractionAbort > xAbort(
+            xSelection.get(), uno::UNO_QUERY );
+    if ( xAbort.is() )
+        return -1;
+
+    const rtl::Reference< ucbhelper::InteractionSupplyAuthentication > & xSupp
+        = xRequest->getAuthenticationSupplier();
+
+    inoutUserName = xSupp->getUserName();
+    outPassWord   = xSupp->getPassword();
+
+    // #102871# - Remember username and password.
+    m_aPrevUsername = inoutUserName;
+    m_aPrevPassword = outPassWord;
 
-                    // go on.
-                    return 0;
-                }
-            }
-        }
-    }
-    // Abort.
-    return -1;
+    // go on.
+    return 0;
 }
 
 //=========================================================================
@@ -444,15 +446,16 @@
 }
 
 //=========================================================================
-uno::Reference< io::XInputStream > DAVResourceAccess::GET(
+uno::Reference< io::XStream > DAVResourceAccess::GET(
     const std::vector< rtl::OUString > & rHeaderNames,
     DAVResource & rResource,
-    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv,
+    sal_Bool bAllowEmpty )
   throw( DAVException )
 {
     initialize();
 
-    uno::Reference< io::XInputStream > xStream;
+    uno::Reference< io::XStream > xStream;
 	int errorCount = 0;
     bool bRetry;
     do
@@ -472,7 +475,8 @@
                                        DAVRequestEnvironment(
                                            getRequestURI(),
                                            new DAVAuthListener_Impl( xEnv ),
-                                           aHeaders, xEnv ) );
+                                           aHeaders, xEnv ),
+                                       bAllowEmpty );
         }
         catch ( DAVException & e )
         {
@@ -606,6 +610,45 @@
 }
 
 //=========================================================================
+void DAVResourceAccess::PUT(
+        const char * buffer, size_t size,
+        const uno::Reference< ucb::XCommandEnvironment > & xEnv )
+throw( DAVException )
+{
+    initialize();
+
+    bool bRetry = false;
+    int errorCount = 0;
+    do
+    {
+        bRetry = false;
+        try
+        {
+            DAVRequestHeaders aHeaders;
+            getUserRequestHeaders( xEnv, 
+                                   getRequestURI(), 
+                                   rtl::OUString::createFromAscii( "PUT" ), 
+                                   aHeaders );
+            
+            m_xSession->PUT( getRequestURI(),
+                             buffer, size,
+                             DAVRequestEnvironment(
+                                 getRequestURI(),
+                                 new DAVAuthListener_Impl( xEnv ),
+                                 aHeaders, xEnv ) );
+        }
+        catch ( DAVException & e )
+        {
+            errorCount++;
+            bRetry = handleException( e, errorCount );
+            if ( !bRetry )
+                throw;
+        }
+    }
+    while ( bRetry );
+}
+
+//=========================================================================
 uno::Reference< io::XInputStream > DAVResourceAccess::POST(
 	const rtl::OUString & rContentType,
 	const rtl::OUString & rReferer,
@@ -888,22 +931,44 @@
 
 //=========================================================================
 void DAVResourceAccess::LOCK ( 
-    const ucb::Lock & /*rLock*/,
-    const uno::Reference< ucb::XCommandEnvironment > & /*xEnv*/ )
+    ucb::Lock & rLock,
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
   throw( DAVException )
 {
-//    initialize();
-    OSL_ENSURE( sal_False, "DAVResourceAccess::LOCK - NYI" );
+    initialize();
+
+    DAVRequestHeaders aHeaders;
+    getUserRequestHeaders( xEnv, 
+            getRequestURI(), 
+            rtl::OUString::createFromAscii( "LOCK" ), 
+            aHeaders );
+    
+    m_xSession->LOCK( rLock,
+            DAVRequestEnvironment(
+                getRequestURI(),
+                new DAVAuthListener_Impl( xEnv ),
+                aHeaders, xEnv ) );
 }
 
 //=========================================================================
 void DAVResourceAccess::UNLOCK ( 
-    const ucb::Lock & /*rLock*/,
-    const uno::Reference< ucb::XCommandEnvironment > & /*xEnv*/ )
+    ucb::Lock & rLock,
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
   throw( DAVException )
 {
-//    initialize();
-    OSL_ENSURE( sal_False, "DAVResourceAccess::UNLOCK - NYI" );
+    initialize();
+
+    DAVRequestHeaders aHeaders;
+    getUserRequestHeaders( xEnv, 
+            getRequestURI(), 
+            rtl::OUString::createFromAscii( "UNLOCK" ), 
+            aHeaders );
+
+    m_xSession->UNLOCK( rLock,
+            DAVRequestEnvironment(
+                getRequestURI(),
+                new DAVAuthListener_Impl( xEnv ),
+                aHeaders, xEnv ) );
 }
 
 //=========================================================================
@@ -1008,6 +1073,18 @@
     }
 }
 
+// static
+com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > DAVResourceAccess::createCommandEnvironment( void )
+{
+    uno::Reference< lang::XMultiServiceFactory > xFactory( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+    uno::Reference< task::XInteractionHandler > xInteractionHandler = uno::Reference< task::XInteractionHandler > (
+            xFactory->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uui.InteractionHandler") ) ), uno::UNO_QUERY );
+    ucbhelper::CommandEnvironment* pCommandEnv = new ::ucbhelper::CommandEnvironment( xInteractionHandler, uno::Reference< ucb::XProgressHandler >() );
+
+    return uno::Reference< ucb::XCommandEnvironment >( static_cast< ucb::XCommandEnvironment* >( pCommandEnv ), uno::UNO_QUERY );
+}
+
+
 //=========================================================================
 sal_Bool DAVResourceAccess::detectRedirectCycle(
                                 const rtl::OUString& rRedirectURL )
diff -u ucb/webdav-orig/DAVResourceAccess.hxx ucb/source/ucp/webdav/DAVResourceAccess.hxx
--- ucb/webdav-orig/DAVResourceAccess.hxx	2009-03-05 13:01:30.409500000 +0200
+++ ucb/source/ucp/webdav/DAVResourceAccess.hxx	2009-03-02 17:52:48.440750000 +0200
@@ -134,11 +134,12 @@
 	     com::sun::star::ucb::XCommandEnvironment > & xEnv )
         throw( DAVException );
 
-    com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
+    com::sun::star::uno::Reference< com::sun::star::io::XStream >
     GET( const std::vector< rtl::OUString > & rHeaderNames, // empty == 'all'
          DAVResource & rResource,
          const com::sun::star::uno::Reference<
-	     com::sun::star::ucb::XCommandEnvironment > & xEnv )
+	     com::sun::star::ucb::XCommandEnvironment > & xEnv,
+         sal_Bool bAllowEmpty = sal_False )
         throw( DAVException );
 
     void
@@ -157,6 +158,11 @@
 	     com::sun::star::ucb::XCommandEnvironment > & xEnv )
 	throw( DAVException );
 
+    void
+    PUT( const char * buffer, size_t size,
+         const com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > & xEnv )
+        throw( DAVException );
+
     com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
     POST( const rtl::OUString & rContentType,
 	  const rtl::OUString & rReferer,
@@ -204,13 +210,13 @@
 	throw( DAVException );
 
     void
-    LOCK( const com::sun::star::ucb::Lock & rLock,
+    LOCK( com::sun::star::ucb::Lock & rLock,
 	  const com::sun::star::uno::Reference<
 	      com::sun::star::ucb::XCommandEnvironment > & xEnv )
 	throw( DAVException );
 
     void
-    UNLOCK( const com::sun::star::ucb::Lock & rLock,
+    UNLOCK( com::sun::star::ucb::Lock & rLock,
 	    const com::sun::star::uno::Reference<
 	        com::sun::star::ucb::XCommandEnvironment > & xEnv )
 	throw( DAVException );
@@ -223,6 +229,8 @@
 	const rtl::OUString & rMethod,
     DAVRequestHeaders & rRequestHeaders );
 
+    static com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > createCommandEnvironment( void );
+
 private:
     const rtl::OUString & getRequestURI() const;
     sal_Bool detectRedirectCycle( const rtl::OUString& rRedirectURL )
diff -u ucb/webdav-orig/DAVSession.hxx ucb/source/ucp/webdav/DAVSession.hxx
--- ucb/webdav-orig/DAVSession.hxx	2009-03-05 13:01:30.425125000 +0200
+++ ucb/source/ucp/webdav/DAVSession.hxx	2009-03-02 17:52:48.440750000 +0200
@@ -33,8 +33,11 @@
 
 #include <memory>
 #include <rtl/ustring.hxx>
+#include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XInputStream.hpp>
 #include <com/sun/star/io/XOutputStream.hpp>
+#include <com/sun/star/ucb/Lock.hpp>
+
 #include "DAVException.hxx"
 #include "DAVProperties.hxx"
 #include "DAVResource.hxx"
@@ -42,8 +45,6 @@
 #include "DAVTypes.hxx"
 #include "DAVRequestEnvironment.hxx"
 
-
-
 namespace webdav_ucp
 {
 
@@ -114,11 +115,12 @@
         const DAVRequestEnvironment & rEnv )
 		throw( DAVException ) = 0;
 
-    virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
+    virtual com::sun::star::uno::Reference< com::sun::star::io::XStream >
                     GET( const ::rtl::OUString & inPath,
                          const std::vector< ::rtl::OUString > & inHeaderNames,
                          DAVResource & ioResource,
-                         const DAVRequestEnvironment & rEnv )
+                         const DAVRequestEnvironment & rEnv,
+                         sal_Bool bAllowEmpty )
         throw( DAVException ) = 0;
 
     virtual void    GET( const ::rtl::OUString & inPath,
@@ -134,6 +136,12 @@
         const DAVRequestEnvironment & rEnv )
 		throw( DAVException ) = 0;
 
+    virtual void PUT( const ::rtl::OUString & inPath,
+             const char * buffer,
+             size_t size,
+             const DAVRequestEnvironment & rEnv )
+        throw ( DAVException ) = 0;
+
     virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream >
                     POST( const rtl::OUString & inPath,
                           const rtl::OUString & rContentType,
@@ -173,16 +181,14 @@
                              const DAVRequestEnvironment & rEnv )
 		throw( DAVException ) = 0;
 
-	// Note: Uncomment the following if locking support is required
-	/*
-	virtual void LOCK ( const Lock & inLock,
+	virtual void LOCK ( com::sun::star::ucb::Lock & rLock,
                         const DAVRequestEnvironment & rEnv )
 		throw( DAVException ) = 0;
 
-	virtual void UNLOCK ( const Lock & inLock,
+	virtual void UNLOCK ( com::sun::star::ucb::Lock & rLock,
                           const DAVRequestEnvironment & rEnv )
 		throw( DAVException ) = 0;
-	*/
+
 protected:
     rtl::Reference< DAVSessionFactory > m_xFactory;
 
diff -u ucb/webdav-orig/NeonInputStream.cxx ucb/source/ucp/webdav/NeonInputStream.cxx
--- ucb/webdav-orig/NeonInputStream.cxx	2009-03-05 13:01:30.425125000 +0200
+++ ucb/source/ucp/webdav/NeonInputStream.cxx	2009-03-05 14:49:12.847000000 +0200
@@ -31,21 +31,28 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_ucb.hxx"
 #include "NeonInputStream.hxx"
+#include "DAVResourceAccess.hxx"
+
 #include <rtl/memory.h>
+#include <com/sun/star/ucb/CommandFailedException.hpp>
+
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+#include <cstdio>
 
 using namespace cppu;
-using namespace rtl;
 using namespace com::sun::star::io;
-using namespace com::sun::star::uno;
+using namespace com::sun::star;
 using namespace webdav_ucp;
 
-
 // -------------------------------------------------------------------
 // Constructor
 // -------------------------------------------------------------------
-NeonInputStream::NeonInputStream( void )
-: mLen( 0 ),
-  mPos( 0 )
+NeonInputStream::NeonInputStream()
+: m_nLen( 0 ),
+  m_nPos( 0 ),
+  m_bDirty( sal_False )
 {
 }
 
@@ -62,24 +69,59 @@
 // -------------------------------------------------------------------
 void NeonInputStream::AddToStream( const char * inBuf, sal_Int32 inLen )
 {
-    mInputBuffer.realloc( sal::static_int_cast<sal_Int32>(mLen) + inLen );
-    rtl_copyMemory( mInputBuffer.getArray() + mLen, inBuf, inLen );
-	mLen += inLen;
+    OSL_ENSURE( !m_bDirty, "Cannot AddToStream() when it was already written to it." );
+
+    m_aInputBuffer.realloc( sal::static_int_cast<sal_Int32>(m_nLen) + inLen );
+    rtl_copyMemory( m_aInputBuffer.getArray() + m_nLen, inBuf, inLen );
+    m_nLen += inLen;
+}
+
+// -------------------------------------------------------------------
+// Associate a URL with this stream
+// -------------------------------------------------------------------
+void NeonInputStream::SetURL( const rtl::OUString &rURL )
+{
+    osl::MutexGuard aGuard( m_aLock );
+
+    m_aURL = rURL;
 }
 
 // -------------------------------------------------------------------
 // queryInterface
 // -------------------------------------------------------------------
-Any NeonInputStream::queryInterface( const Type &type )
-						throw( RuntimeException )
+uno::Any NeonInputStream::queryInterface( const uno::Type &type )
+						throw( uno::RuntimeException )
 {
-	Any aRet = ::cppu::queryInterface( type,
-									   static_cast< XInputStream * >( this ),
-									   static_cast< XSeekable * >( this ) );
+    uno::Any aRet = ::cppu::queryInterface( type,
+            static_cast< XStream * >( this ),
+            static_cast< XInputStream * >( this ),
+            static_cast< XOutputStream * >( this ),
+            static_cast< XSeekable * >( this ),
+            static_cast< XTruncate * >( this ) );
 	return aRet.hasValue() ? aRet : OWeakObject::queryInterface( type );
 }
 
 // -------------------------------------------------------------------
+// getInputStream
+// -------------------------------------------------------------------
+com::sun::star::uno::Reference< com::sun::star::io::XInputStream > SAL_CALL
+NeonInputStream::getInputStream( void )
+	throw( com::sun::star::uno::RuntimeException )
+{
+    return uno::Reference< XInputStream >( this );
+}
+
+// -------------------------------------------------------------------
+// getOutputStream
+// -------------------------------------------------------------------
+com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > SAL_CALL
+NeonInputStream::getOutputStream( void )
+	throw( com::sun::star::uno::RuntimeException )
+{
+    return uno::Reference< XOutputStream >( this );
+}
+
+// -------------------------------------------------------------------
 // readBytes
 // "Reads" the specified number of bytes from the stream
 // -------------------------------------------------------------------
@@ -92,7 +134,7 @@
 {
 	// Work out how much we're actually going to write
 	sal_Int32 theBytes2Read = nBytesToRead;
-	sal_Int32 theBytesLeft  = sal::static_int_cast<sal_Int32>(mLen - mPos);
+	sal_Int32 theBytesLeft  = sal::static_int_cast<sal_Int32>(m_nLen - m_nPos);
 	if ( theBytes2Read > theBytesLeft )
 		theBytes2Read = theBytesLeft;
 
@@ -101,10 +143,10 @@
 
 	// Write the data
 	rtl_copyMemory(
-		aData.getArray(), mInputBuffer.getConstArray() + mPos, theBytes2Read );
+		aData.getArray(), m_aInputBuffer.getConstArray() + m_nPos, theBytes2Read );
 
 	// Update our stream position for next time
-	mPos += theBytes2Read;
+	m_nPos += theBytes2Read;
 
     return theBytes2Read;
 }
@@ -133,9 +175,9 @@
                ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException )
 {
-	mPos += nBytesToSkip;
-	if ( mPos >= mLen )
-		mPos = mLen;
+    m_nPos += nBytesToSkip;
+    if ( m_nPos >= m_nLen )
+        m_nPos = m_nLen;
 }
 
 // -------------------------------------------------------------------
@@ -147,7 +189,7 @@
                ::com::sun::star::io::IOException,
                ::com::sun::star::uno::RuntimeException )
 {
-	return sal::static_int_cast<sal_Int32>(mLen - mPos);
+    return sal::static_int_cast<sal_Int32>(m_nLen - m_nPos);
 }
 
 // -------------------------------------------------------------------
@@ -168,12 +210,12 @@
 			   ::com::sun::star::io::IOException,
 			   ::com::sun::star::uno::RuntimeException )
 {
-	if ( location < 0 )
-		throw ::com::sun::star::lang::IllegalArgumentException();
+    if ( location < 0 )
+        throw ::com::sun::star::lang::IllegalArgumentException();
 
-    if ( location <= mLen )
-		mPos = location;
-	else
+    if ( location <= m_nLen )
+        m_nPos = location;
+    else
         throw ::com::sun::star::lang::IllegalArgumentException();
 }
 
@@ -184,7 +226,7 @@
 		throw( ::com::sun::star::io::IOException,
 			   ::com::sun::star::uno::RuntimeException )
 {
-	return mPos;
+    return m_nPos;
 }
 
 // -------------------------------------------------------------------
@@ -194,5 +236,108 @@
 		throw( ::com::sun::star::io::IOException,
 			   ::com::sun::star::uno::RuntimeException )
 {
-	return mLen;
+    return m_nLen;
+}
+
+// -------------------------------------------------------------------
+// writeBytes
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::writeBytes( const com::sun::star::uno::Sequence< sal_Int8 >& aData )
+	throw( com::sun::star::io::NotConnectedException,
+	       com::sun::star::io::BufferSizeExceededException,
+	       com::sun::star::io::IOException,
+	       com::sun::star::uno::RuntimeException)
+{
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: writeBytes()\n" );
+#endif
+
+    sal_Int32 nDataLen = aData.getLength();
+    OSL_ASSERT( nDataLen >= 0 );
+
+    // Anything to do?
+    if ( nDataLen == 0 )
+        return;
+
+    // Update the length of the stream & size of the buffer
+    if ( m_nLen < m_nPos + nDataLen )
+    {
+        m_nLen = m_nPos + nDataLen;
+        if ( m_aInputBuffer.getLength() < m_nLen )
+            m_aInputBuffer.realloc( sal::static_int_cast<sal_Int32>( m_nLen ) );
+    }
+
+    rtl_copyMemory( m_aInputBuffer.getArray() + m_nPos, aData.getConstArray(), nDataLen );
+    m_nPos += nDataLen;
+
+    m_bDirty = sal_True;
+}
+
+// -------------------------------------------------------------------
+// flush
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::flush( void )
+	throw( NotConnectedException, BufferSizeExceededException,
+	       IOException, uno::RuntimeException )
+{
+    if ( m_bDirty )
+    {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: flush(), saving the changed file.\n" );
+#endif
+        // FIXME It's really hacky to create the new session
+        // But so far it seems I have no other chance...
+        uno::Reference< lang::XMultiServiceFactory > xFactory( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        rtl::Reference< DAVSessionFactory > rDAVFactory( new DAVSessionFactory() );
+        
+        DAVResourceAccess aResourceAccess( xFactory, rDAVFactory, m_aURL );
+        
+        try {
+            aResourceAccess.PUT( reinterpret_cast<const char*>( m_aInputBuffer.getConstArray() ), m_nLen,
+                    DAVResourceAccess::createCommandEnvironment() );
+        }
+        catch ( DAVException & e )
+        {
+            throw ucb::CommandFailedException(
+                    e.getData(),
+                    uno::Reference< uno::XInterface >(),
+                    uno::makeAny( e.getData() ) );
+        }
+
+        m_bDirty = sal_False;
+    }
+}
+        
+// -------------------------------------------------------------------
+// closeOutput
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::closeOutput( void )
+	throw( com::sun::star::io::NotConnectedException,
+	       com::sun::star::io::IOException,
+	       com::sun::star::uno::RuntimeException )
+{
+    if ( m_bDirty )
+    {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: TODO write on closeOutput(), the stream is dirty!\n" );
+#endif
+    }
+}
+
+// -------------------------------------------------------------------
+// truncate
+// -------------------------------------------------------------------
+void SAL_CALL NeonInputStream::truncate( void )
+	throw( com::sun::star::io::IOException,
+	       com::sun::star::uno::RuntimeException )
+{
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: truncate()\n" );
+#endif
+
+    if ( m_nLen > 0 )
+    {
+        m_nLen = m_nPos = 0;
+        m_bDirty = sal_True;
+    }
 }
diff -u ucb/webdav-orig/NeonInputStream.hxx ucb/source/ucp/webdav/NeonInputStream.hxx
--- ucb/webdav-orig/NeonInputStream.hxx	2009-03-05 13:01:30.440750000 +0200
+++ ucb/source/ucp/webdav/NeonInputStream.hxx	2009-03-05 13:29:30.425125000 +0200
@@ -31,11 +31,19 @@
 #define _NEONINPUTSTREAM_HXX_
 
 #include <sal/types.h>
+#include <osl/mutex.hxx>
+#include <osl/signal.h>
 #include <rtl/ustring.hxx>
 #include <cppuhelper/weak.hxx>
+
+#include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/io/XSeekable.hpp>
+#include <com/sun/star/io/XTruncate.hpp>
+#include <com/sun/star/ucb/Lock.hpp>
 
+#include "DAVRequestEnvironment.hxx"
 
 namespace webdav_ucp
 {
@@ -45,21 +53,33 @@
 // A simple XInputStream implementation provided specifically for use
 // by the DAVSession::GET method.
 // -------------------------------------------------------------------
-class NeonInputStream : public ::com::sun::star::io::XInputStream,
+class NeonInputStream : public ::com::sun::star::io::XStream,
+                        public ::com::sun::star::io::XInputStream,
+                        public ::com::sun::star::io::XOutputStream,
 						public ::com::sun::star::io::XSeekable,
+                        public ::com::sun::star::io::XTruncate,
 						public ::cppu::OWeakObject
 {
-	private:
-		com::sun::star::uno::Sequence< sal_Int8 > mInputBuffer;
-		sal_Int64 mLen;
-		sal_Int64 mPos;
-
-	public:
-				 NeonInputStream( void );
-		virtual ~NeonInputStream();
+private:
+    com::sun::star::uno::Sequence< sal_Int8 > m_aInputBuffer;
+    sal_Int64                  m_nLen; // cannot be just m_aInputBuffer.getLength() - the buffer can be bigger
+    sal_Int64                  m_nPos;
+
+    sal_Bool                   m_bDirty;
+
+    rtl::OUString              m_aURL;
+
+    osl::Mutex                 m_aLock;
 
-		// Add some data to the end of the stream
-		void AddToStream( const char * inBuf, sal_Int32 inLen );
+public:
+             NeonInputStream( void );
+    virtual ~NeonInputStream();
+
+    // Add some data to the end of the stream
+    void AddToStream( const char * inBuf, sal_Int32 inLen );
+
+    // Associate a URL with this stream
+    void SetURL( const rtl::OUString &rURL );
 
 	// XInterface
 	virtual com::sun::star::uno::Any SAL_CALL queryInterface(
@@ -74,6 +94,12 @@
 							throw()
 								{ OWeakObject::release(); }
 
+    // XStream
+    virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream > SAL_CALL getInputStream( void )
+        throw( com::sun::star::uno::RuntimeException );
+
+    virtual com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > SAL_CALL getOutputStream( void )
+        throw( com::sun::star::uno::RuntimeException );
 
 	// XInputStream
 	virtual sal_Int32 SAL_CALL readBytes(
@@ -121,6 +147,30 @@
 	virtual sal_Int64 SAL_CALL getLength()
 		throw( ::com::sun::star::io::IOException,
 			   ::com::sun::star::uno::RuntimeException );
+
+    // XOutputStream
+    virtual void SAL_CALL writeBytes( const com::sun::star::uno::Sequence< sal_Int8 >& aData )
+        throw( com::sun::star::io::NotConnectedException,
+                com::sun::star::io::BufferSizeExceededException,
+                com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL flush( void )
+        throw( com::sun::star::io::NotConnectedException,
+                com::sun::star::io::BufferSizeExceededException,
+                com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException);
+
+
+    virtual void SAL_CALL closeOutput( void )
+        throw( com::sun::star::io::NotConnectedException,
+                com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException );
+
+    // XTruncate
+    virtual void SAL_CALL truncate( void )
+        throw( com::sun::star::io::IOException,
+                com::sun::star::uno::RuntimeException );
 };
 
 } // namespace webdav_ucp
diff -u ucb/webdav-orig/NeonSession.cxx ucb/source/ucp/webdav/NeonSession.cxx
--- ucb/webdav-orig/NeonSession.cxx	2009-03-05 13:01:30.456375000 +0200
+++ ucb/source/ucp/webdav/NeonSession.cxx	2009-03-06 13:29:19.847000000 +0200
@@ -65,6 +65,9 @@
 #ifndef _SIMPLECERTIFICATIONVALIDATIONREQUEST_HXX_
 #include "ucbhelper/simplecertificatevalidationrequest.hxx"
 #endif
+#ifndef _UCBHELPER_CANCELCOMMANDEXECUTION_HXX_
+#include <ucbhelper/cancelcommandexecution.hxx>
+#endif
 
 #include <cppuhelper/bootstrap.hxx> 
 
@@ -153,6 +156,12 @@
     return sal_uInt16( rStatusText.copy( 0, nPos ).toInt32() );
 }
 
+static sal_uInt16 getStatusCode( HttpSession *pSession )
+{
+    rtl::OUString aText = rtl::OUString::createFromAscii( ne_get_error( pSession ) );
+    return makeStatusCode( aText );
+}
+
 // -------------------------------------------------------------------
 struct NeonRequestContext
 {
@@ -196,12 +205,13 @@
 // -------------------------------------------------------------------
 
 #if NEON_VERSION >= 0x0250
-extern "C" int NeonSession_ResponseBlockReader(void * inUserData, 
+extern "C" int
 #else
-extern "C" void NeonSession_ResponseBlockReader(void * inUserData, 
+extern "C" void
 #endif
-                                               const char * inBuf, 
-                                               size_t inLen )
+NeonSession_ResponseBlockReader( void * inUserData, 
+                                 const char * inBuf, 
+                                 size_t inLen )
 {
     // neon calls this function with (inLen == 0)...
     if ( inLen > 0 )
@@ -226,12 +236,13 @@
 // -------------------------------------------------------------------
 
 #if NEON_VERSION >= 0x0250
-extern "C" int NeonSession_ResponseBlockWriter( void * inUserData, 
+extern "C" int
 #else
-extern "C" void NeonSession_ResponseBlockWriter( void * inUserData, 
+extern "C" void
 #endif
-                                                const char * inBuf, 
-                                                size_t inLen )
+NeonSession_ResponseBlockWriter( void * inUserData, 
+                                 const char * inBuf, 
+                                 size_t inLen )
 {
     // neon calls this function with (inLen == 0)...
     if ( inLen > 0 )
@@ -299,11 +310,10 @@
 
         try
         {
-            NeonUri uri( theSession->getRequestEnvironment().m_aRequestURI );
-            rtl::OUString aUserInfo( uri.GetUserInfo() );
+            rtl::OUString aUserInfo( theSession->getUserInfo() );
             if ( aUserInfo.getLength() )
             {
-                sal_Int32 nPos = aUserInfo.indexOf( '@' );
+                sal_Int32 nPos = aUserInfo.indexOf( ':' );
                 if ( nPos == -1 )
                 {
                     theUserName = aUserInfo;
@@ -564,6 +574,8 @@
     }
 }
 
+NeonLockStore * NeonSession::s_aNeonLockStore = NULL;
+
 // -------------------------------------------------------------------
 // Constructor
 // -------------------------------------------------------------------
@@ -581,6 +593,7 @@
     m_aScheme    = theUri.GetScheme();
     m_aHostName  = theUri.GetHost();
     m_nPort      = theUri.GetPort();
+    m_aUserInfo  = theUri.GetUserInfo();
 
 //   Init();
 }
@@ -594,14 +607,6 @@
     {
         ne_session_destroy( m_pHttpSession );
         m_pHttpSession = 0;
-	// Note: Uncomment the following if locking support is required
-	/*
-	  if ( mNeonLockSession != NULL )
-	  {
-	  ne_lock_unregister( mNeonLockSession );
-	  mNeonLockSession = NULL;
-	  }
-	*/
     }
 
     delete static_cast<RequestDataMap*>(m_pRequestData);
@@ -629,6 +634,9 @@
                 throw DAVException( DAVException::DAV_SESSION_CREATE,
                                     NeonUri::makeConnectionEndPointString(
                                                     m_aHostName, m_nPort ) );
+#if OSL_DEBUG_LEVEL > 0
+			ne_debug_init( stderr, NE_DBG_LOCKS );
+#endif
             // #122205# - libxml2 needs to be initialized once if used by 
             // multithreaded programs like OOo.
             xmlInitParser();
@@ -746,14 +754,15 @@
                               m_nProxyPort );
         }
 
-        // Note: Uncomment the following if locking support is required
-        /*
-        mNeonLockSession = ne_lock_register( m_pHttpSession );
+        if ( !s_aNeonLockStore )
+            s_aNeonLockStore = ne_lockstore_create();
 
-        if ( mNeonLockSession == NULL )
+        if ( s_aNeonLockStore == NULL )
             throw DAVException( DAVException::DAV_SESSION_CREATE,
-                                theUri::makeConnectionEndPointString() );
-        */
+                                NeonUri::makeConnectionEndPointString( m_aHostName, m_nPort ) );
+
+        // Register the lock store
+        ne_lockstore_register( s_aNeonLockStore, m_pHttpSession );
 
         // Register for redirects.
         ne_redirect_register( m_pHttpSession );
@@ -1086,11 +1095,12 @@
 // -------------------------------------------------------------------
 // GET
 // -------------------------------------------------------------------
-uno::Reference< io::XInputStream > 
+uno::Reference< io::XStream > 
 NeonSession::GET( const rtl::OUString & inPath,
 		  const std::vector< ::rtl::OUString > & inHeaderNames,
 		  DAVResource & ioResource,
-		  const DAVRequestEnvironment & rEnv )
+		  const DAVRequestEnvironment & rEnv,
+		  sal_Bool bAllowEmpty )
     throw ( DAVException )
 {
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
@@ -1102,16 +1112,23 @@
     ioResource.uri = inPath;
     ioResource.properties.clear();
 
-    rtl::Reference< NeonInputStream > xInputStream( new NeonInputStream );
-    NeonRequestContext aCtx( xInputStream, inHeaderNames, ioResource );
+    rtl::Reference< NeonInputStream > xStream( new NeonInputStream );
+    NeonRequestContext aCtx( xStream, inHeaderNames, ioResource );
     int theRetVal = GET( m_pHttpSession,
                          rtl::OUStringToOString(
                              inPath, RTL_TEXTENCODING_UTF8 ),
                          NeonSession_ResponseBlockReader,
                          true,
                          &aCtx );
-    HandleError( theRetVal );
-    return uno::Reference< io::XInputStream >( xInputStream.get() );
+    try {
+        HandleError( theRetVal );
+    }
+    catch ( DAVException const & e )
+    {
+        if ( !bAllowEmpty || ( e.getStatus() != SC_NOT_FOUND ) )
+            throw;
+    }
+    return uno::Reference< io::XStream >( xStream.get() );
 }
 
 // -------------------------------------------------------------------
@@ -1151,22 +1168,38 @@
                        const DAVRequestEnvironment & rEnv )
     throw ( DAVException )
 {
+    // initialization etc. is performed in the other PUT
+
+    uno::Sequence< sal_Int8 > aDataToSend;
+    if ( !getDataFromInputStream( inInputStream, aDataToSend, false ) )
+        throw DAVException( DAVException::DAV_INVALID_ARG );
+
+    PUT( inPath,
+            reinterpret_cast< const char * >( aDataToSend.getConstArray() ),
+            aDataToSend.getLength(),
+            rEnv );
+}
+
+// -------------------------------------------------------------------
+// PUT
+// -------------------------------------------------------------------
+void NeonSession::PUT( const rtl::OUString &inPath,
+                       const char * buffer,
+                       size_t size,
+                       const DAVRequestEnvironment & rEnv )
+    throw ( DAVException )
+{
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
 
     Init();
 
     m_aEnv = rEnv;
 
-    uno::Sequence< sal_Int8 > aDataToSend;
-    if ( !getDataFromInputStream( inInputStream, aDataToSend, false ) )
-        throw DAVException( DAVException::DAV_INVALID_ARG );
-
     int theRetVal = PUT( m_pHttpSession,
                          rtl::OUStringToOString(
                             inPath, RTL_TEXTENCODING_UTF8 ),
-                         reinterpret_cast< const char * >(
-                            aDataToSend.getConstArray() ),
-                         aDataToSend.getLength() );
+                         buffer,
+                         size );
 
     HandleError( theRetVal );
 }
@@ -1342,9 +1375,7 @@
 // -------------------------------------------------------------------
 // LOCK
 // -------------------------------------------------------------------
-// Note: Uncomment the following if locking support is required
-/*
-void NeonSession::LOCK( const Lock & inLock,
+void NeonSession::LOCK( ucb::Lock & rLock,
                         const DAVRequestEnvironment & rEnv )
 	throw ( DAVException )
 {
@@ -1354,16 +1385,13 @@
 
     m_aEnv = rEnv;
 
-	Lockit( inLock, true );
+    Lockit( rLock, true );
 }
-*/
 
 // -------------------------------------------------------------------
 // UNLOCK
 // -------------------------------------------------------------------
-// Note: Uncomment the following if locking support is required
-/*
-void NeonSession::UNLOCK( const Lock & inLock,
+void NeonSession::UNLOCK( ucb::Lock & rLock,
                           const DAVRequestEnvironment & rEnv )
 	throw ( DAVException )
 {
@@ -1373,9 +1401,8 @@
 
     m_aEnv = rEnv;
 
-	Lockit( inLock, false );
+    Lockit( rLock, false );
 }
-*/
 
 // -------------------------------------------------------------------
 const ucbhelper::InternetProxyServer & NeonSession::getProxySettings() const
@@ -1414,7 +1441,10 @@
         case NE_ERROR:        // Generic error
         {
             rtl::OUString aText = rtl::OUString::createFromAscii(
-		ne_get_error( m_pHttpSession ) );
+                    ne_get_error( m_pHttpSession ) );
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: got error '%s'\n", rtl::OUStringToOString( aText, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
             throw DAVException( DAVException::DAV_HTTP_ERROR,
                                 aText,
                                 makeStatusCode( aText ) );
@@ -1471,77 +1501,151 @@
     }
 }
 
-// Note: Uncomment the following if locking support is required
-/*
-void NeonSession::Lockit( const Lock & inLock, bool inLockit )
+void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
 	throw ( DAVException )
 {
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
 
-	// Create the neon lock
-	NeonLock * theLock = new NeonLock;
-	int theRetVal;
-
-	// Set the lock uri
-	NeonUri theUri( inLock.uri );
-	theLock->uri = const_cast< char * >
-        ( rtl::OUStringToOString(
-                theUri.GetPath(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( !s_aNeonLockStore )
+        throw DAVException( DAVException::DAV_INVALID_ARG );
 
-	if ( inLockit )
-	{
-		// Set the lock depth
-		switch( inLock.depth )
-		{
-			case DAVZERO:
-			case DAVINFINITY:
-				theLock->depth = int ( inLock.depth );
-				break;
-			default:
-				throw DAVException( DAVException::DAV_INVALID_ARG );
-				break;
-		}
+    ne_uri aUri;
+    ne_uri_parse( rtl::OUStringToOString( m_aEnv.m_aRequestURI, RTL_TEXTENCODING_UTF8 ).getStr(),
+            &aUri );
+    
+#if NEON_VERSION < 0x0260
+#define FILLIN( field, val ) aUri.field = aUri.field? aUri.field: strdup( rtl::OUStringToOString( val, RTL_TEXTENCODING_UTF8 ).getStr() )
+    FILLIN( scheme, m_aScheme );
+    FILLIN( host, m_aHostName );
+    aUri.port = aUri.port? aUri.port: m_nPort;
+#undef FILLIN
+#endif
 
-		// Set the lock scope
-		switch ( inLock.scope )
-		{
-			case EXCLUSIVE:
-                theLock->scope = ne_lockscope_exclusive;
-				break;
-			case SHARED:
-                theLock->scope = ne_lockscope_shared;
-				break;
-			default:
-				throw DAVException( DAVException::DAV_INVALID_ARG );
-				break;
-		}
+    // Create the neon lock
+    NeonLock * theLock = ne_lockstore_findbyuri( s_aNeonLockStore, &aUri );
+    bool bAlreadyExists = false;
+    if ( theLock )
+        bAlreadyExists = true;
+    else
+    {
+        theLock = ne_lock_create();
 
-		// Set the lock owner
-        const char * theOwner = rtl::OUStringToOString( inLock.owner,
-                                                        RTL_TEXTENCODING_UTF8 );
-		theLock->owner = const_cast< char * > ( theOwner );
-
-		// Set the lock timeout
-		// Note: Neon ignores the timeout
-		//theLock->timeout = inLock.timeout;
+        // Set the lock uri
+        theLock->uri = aUri;
 
-        theRetVal = ne_lock( m_pHttpSession, theLock );
-	}
-	else
-	{
+        // Set the lock depth
+        switch( rLock.Depth )
+        {
+            case ucb::LockDepth_ZERO:     theLock->depth = NE_DEPTH_ZERO;     break;
+            case ucb::LockDepth_ONE:      theLock->depth = NE_DEPTH_ONE;      break;
+            case ucb::LockDepth_INFINITY: theLock->depth = NE_DEPTH_INFINITE; break;
+            default:
+                                          throw DAVException( DAVException::DAV_INVALID_ARG );
+        }
 
-		// Set the lock token
-        rtl::OUString theToken = inLock.locktoken.getConstArray()[ 0 ];
-		theLock->token = const_cast< char * >
-            ( rtl::OUStringToOString(
-                    theToken, RTL_TEXTENCODING_UTF8 ).getStr() );
+        // Set the lock scope
+        switch ( rLock.Scope )
+        {
+            case ucb::LockScope_EXCLUSIVE: theLock->scope = ne_lockscope_exclusive; break;
+            case ucb::LockScope_SHARED:    theLock->scope = ne_lockscope_shared;    break;
+            default:
+                                           throw DAVException( DAVException::DAV_INVALID_ARG );
+                                           break;
+        }
 
-        theRetVal = ne_unlock( m_pHttpSession, theLock );
-	}
+        // Set the lock owner
+        rtl::OUString aValue;
+        rLock.Owner >>= aValue;
 
-	HandleError( theRetVal );
+        theLock->owner = strdup( rtl::OUStringToOString( aValue, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+        // Set the lock timeout
+        // We re-new the lock while the stream is open
+        theLock->timeout = rLock.Timeout;
+    }
+
+    if ( bLockit )
+    {
+        int nRet;
+        if ( !bAlreadyExists )
+        {
+            nRet = ne_lock( m_pHttpSession, theLock );
+
+            if ( nRet == NE_OK )
+            {
+                ne_lockstore_add( s_aNeonLockStore, theLock );
+
+                uno::Sequence< rtl::OUString > aTokens( 1 );
+                aTokens[0] = rtl::OUString::createFromAscii( theLock->token );
+                rLock.LockTokens = aTokens;
+
+#if OSL_DEBUG_LEVEL > 0
+                fprintf( stderr, "WebDAV: locked the URL, the token is: %s\n", theLock->token );
+#endif
+            }
+        }
+        else
+        {
+#if NEON_VERSION >= 0x0260
+            nRet = ne_lock_refresh( m_pHttpSession, theLock );
+#else
+            // workaround for a bug in neon 0.24
+            // we have to call with a bigger structure that is used internally
+            // and initialize parts of it
+
+            struct lock_ctx
+            {
+                struct ne_lock active; /* activelock */
+                char *token; /* the token we're after. */
+                int found;
+                ne_buffer *cdata;
+            };
+
+            struct lock_ctx ctx;
+
+            memset( &ctx, 0, sizeof ctx );
+            ctx.cdata = ne_buffer_create();
+            
+            memcpy( &ctx, theLock, sizeof( *theLock ) );
+            nRet = ne_lock_refresh( m_pHttpSession, reinterpret_cast<NeonLock*>( &ctx ) );
+
+            ne_buffer_destroy( ctx.cdata );
+#endif
+        }
+
+        if ( ( nRet == NE_ERROR ) && ( getStatusCode( m_pHttpSession ) == SC_LOCKED ) )
+        {
+            ucbhelper::cancelCommandExecution( ucb::IOErrorCode_LOCKING_VIOLATION,
+                    uno::Sequence< uno::Any >( 0 ), // FIXME more info about the file?
+                    m_aEnv.m_xEnv,
+                    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "a locking error occured" ) ),
+                    uno::Reference< ucb::XCommandProcessor >() );
+        }
+#if OSL_DEBUG_LEVEL > 0
+        else if ( nRet == NE_OK )
+            fprintf( stderr, "WebDAV: locked/refreshed lock OK\n" );
+        else
+            fprintf( stderr, "WebDAV: failed to lock the file, status code is: %d\n", getStatusCode( m_pHttpSession ) );
+#endif
+    }
+    else
+    {
+        // Set the lock token
+        if ( rLock.LockTokens.getLength() > 0 )
+        {
+            rtl::OUString theToken = rLock.LockTokens.getConstArray()[ 0 ];
+            theLock->token = strdup( rtl::OUStringToOString( theToken, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: going to unlock the URL, the token is: %s\n", theLock->token );
+#endif
+
+            ne_unlock( m_pHttpSession, theLock );
+            ne_lockstore_remove( s_aNeonLockStore, theLock );
+            // FIXME even ne_lock_destroy( theLock )?
+        }
+    }
 }
-*/
 
 // -------------------------------------------------------------------
 namespace {
diff -u ucb/webdav-orig/NeonSession.hxx ucb/source/ucp/webdav/NeonSession.hxx
--- ucb/webdav-orig/NeonSession.hxx	2009-03-05 13:01:30.472000000 +0200
+++ ucb/source/ucp/webdav/NeonSession.hxx	2009-03-02 17:52:48.487625000 +0200
@@ -57,6 +57,7 @@
         rtl::OUString     m_aScheme;
         rtl::OUString     m_aHostName;
         rtl::OUString     m_aProxyName;
+        rtl::OUString     m_aUserInfo;
         sal_Int32         m_nPort;
         sal_Int32         m_nProxyPort;
         HttpSession *     m_pHttpSession;
@@ -70,8 +71,7 @@
         // moment.
         DAVRequestEnvironment m_aEnv;
 
-		// Note: Uncomment the following if locking support is required
-        // NeonLockSession *      mNeonLockSession;
+        static NeonLockStore *s_aNeonLockStore;
 
         static bool       m_bGlobalsInited;
 
@@ -92,6 +92,8 @@
         const DAVRequestEnvironment & getRequestEnvironment() const
         { return m_aEnv; }
 
+        const rtl::OUString & getUserInfo() const { return m_aUserInfo; }
+
         virtual void
         OPTIONS( const ::rtl::OUString &  inPath,
                  DAVCapabilities & outCapabilities,
@@ -142,11 +144,12 @@
 			throw ( DAVException );
 
         virtual com::sun::star::uno::Reference<
-            com::sun::star::io::XInputStream >
+            com::sun::star::io::XStream >
         GET( const ::rtl::OUString & inPath,
              const std::vector< ::rtl::OUString > & inHeaderNames,
              DAVResource & ioResource,
-             const DAVRequestEnvironment & rEnv )
+             const DAVRequestEnvironment & rEnv,
+             sal_Bool bAllowEmpty = sal_False )
             throw ( DAVException );
 
         virtual void
@@ -165,6 +168,13 @@
                 const DAVRequestEnvironment & rEnv )
 			throw ( DAVException );
 
+        virtual void
+        PUT( const ::rtl::OUString & inPath,
+             const char * buffer,
+             size_t size,
+             const DAVRequestEnvironment & rEnv )
+            throw ( DAVException );
+
         virtual com::sun::star::uno::Reference<
             com::sun::star::io::XInputStream >
         POST( const rtl::OUString & inPath,
@@ -209,16 +219,13 @@
                               const DAVRequestEnvironment & rEnv )
 			throw ( DAVException );
 
-		// Note: Uncomment the following if locking support is required
-		/*
-		virtual void LOCK (const Lock & inLock,
-                           const DAVRequestEnvironment & rEnv )
+		virtual void LOCK ( com::sun::star::ucb::Lock & rLock,
+                            const DAVRequestEnvironment & rEnv )
 			throw ( DAVException );
 
-		virtual void UNLOCK (const Lock & inLock,
-                             const DAVRequestEnvironment & rEnv )
+		virtual void UNLOCK ( com::sun::star::ucb::Lock & rLock,
+                              const DAVRequestEnvironment & rEnv )
 			throw ( DAVException );
-		*/
 
         // helpers
         const rtl::OUString & getHostName() const { return m_aHostName; }
@@ -239,9 +246,8 @@
 
         const ucbhelper::InternetProxyServer & getProxySettings() const;
 
-		// Note: Uncomment the following if locking support is required
-		// void			Lockit( const Lock & inLock, bool inLockit )
-		//	throw ( DAVException );
+		void Lockit( com::sun::star::ucb::Lock & rLock, bool bLockit )
+			throw ( DAVException );
 
         // low level GET implementation, used by public GET implementations
         static int GET( ne_session * sess,
diff -u ucb/webdav-orig/NeonTypes.hxx ucb/source/ucp/webdav/NeonTypes.hxx
--- ucb/webdav-orig/NeonTypes.hxx	2009-03-05 13:01:30.472000000 +0200
+++ ucb/source/ucp/webdav/NeonTypes.hxx	2009-03-02 17:52:48.487625000 +0200
@@ -35,6 +35,7 @@
 #include <ne_utils.h>
 #include <ne_basic.h>
 #include <ne_props.h>
+#include <ne_locks.h>
 
 typedef ne_session                  HttpSession;
 typedef ne_status                   HttpStatus;
@@ -43,4 +44,7 @@
 typedef ne_propname                 NeonPropName;
 typedef ne_prop_result_set          NeonPropFindResultSet;
 
+typedef ne_lock_store               NeonLockStore;
+typedef struct ne_lock              NeonLock;
+
 #endif // _NEONTYPES_HXX_
diff -u ucb/webdav-orig/webdavcontent.cxx ucb/source/ucp/webdav/webdavcontent.cxx
--- ucb/webdav-orig/webdavcontent.cxx	2009-03-05 13:01:30.487625000 +0200
+++ ucb/source/ucp/webdav/webdavcontent.cxx	2009-03-08 14:00:39.935935600 +0200
@@ -37,6 +37,7 @@
 
  *************************************************************************/
 #include <osl/diagnose.h>
+#include <osl/thread.hxx>
 
 #include "osl/doublecheckedlocking.h"
 #include <rtl/uri.hxx>
@@ -48,20 +49,17 @@
 #include <com/sun/star/beans/PropertySetInfoChangeEvent.hpp>
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/io/XActiveDataSink.hpp>
+#include <com/sun/star/io/XActiveDataStreamer.hpp>
 #include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/lang/IllegalAccessException.hpp>
 #include "com/sun/star/ucb/AuthenticationRequest.hpp"
 #include <com/sun/star/ucb/CommandFailedException.hpp>
 #include <com/sun/star/ucb/ContentInfoAttribute.hpp>
 #include <com/sun/star/ucb/InsertCommandArgument.hpp>
-#ifndef _COM_SUN_STAR_UCB_INTERACTIVEBADTRANSFRERURLEXCEPTION_HPP_
 #include <com/sun/star/ucb/InteractiveBadTransferURLException.hpp>
-#endif
 #include <com/sun/star/ucb/InteractiveAugmentedIOException.hpp>
 #include <com/sun/star/ucb/InteractiveNetworkConnectException.hpp>
-#ifndef _COM_SUN_STAR_UCB_INTERACTIVENETWORKGENBERALEXCEPTION_HPP_
 #include <com/sun/star/ucb/InteractiveNetworkGeneralException.hpp>
-#endif
 #include <com/sun/star/ucb/InteractiveNetworkReadException.hpp>
 #include <com/sun/star/ucb/InteractiveNetworkResolveNameException.hpp>
 #include <com/sun/star/ucb/InteractiveNetworkWriteException.hpp>
@@ -90,6 +88,8 @@
 #include "NeonUri.hxx"
 #include "UCBDeadPropertyValue.hxx"
 
+#include "NeonInputStream.hxx"
+
 using namespace com::sun::star;
 using namespace webdav_ucp;
 
@@ -345,6 +345,123 @@
 //=========================================================================
 //=========================================================================
 
+// Our signal - 246 is just a random number ;-)
+#define TICKER_THREAD_USER_SIGNAL ( OSL_SIGNAL_USER_RESERVED + 246 )
+
+// -------------------------------------------------------------------
+// A thread that 'ticks' - emits the user signal every second
+// -------------------------------------------------------------------
+class TickerThread : public osl::Thread
+{
+    bool m_bFinish;
+
+public:
+
+    TickerThread() : osl::Thread(), m_bFinish( false ) {}
+
+    void finish() { m_bFinish = true; }
+
+protected:
+
+    virtual void SAL_CALL run();
+};
+
+void TickerThread::run()
+{
+    // we have to go through the loop more often to be able to finish ~quickly
+    const int nNth = 25;
+
+    int nCount = nNth;
+    while ( !m_bFinish )
+    {
+        if ( nCount-- <= 0 )
+        {
+            osl_raiseSignal( TICKER_THREAD_USER_SIGNAL, NULL );
+            nCount = nNth;
+        }
+
+        TimeValue aTV;
+        aTV.Seconds = 0;
+        aTV.Nanosec = 1000000000/nNth;
+        wait( aTV );
+    }
+}
+
+// -------------------------------------------------------------------
+// A class that takes care of creating and destroying the ticker thread
+// -------------------------------------------------------------------
+class TickerThreadController
+{
+    osl::Mutex    m_aMutex;
+    int           m_nCount;
+    TickerThread *m_pTickerThread;
+
+public:
+
+    TickerThreadController() : m_nCount( 0 ), m_pTickerThread( NULL ) {}
+
+    void start();
+    void stop();
+};
+
+void TickerThreadController::start()
+{
+    osl::MutexGuard aGuard( m_aMutex );
+    
+    if ( ( m_nCount++ == 0 ) && !m_pTickerThread )
+    {
+        m_pTickerThread = new TickerThread();
+        m_pTickerThread->create();
+    }
+}
+        
+void TickerThreadController::stop()
+{
+    osl::MutexGuard aGuard( m_aMutex );
+
+    if ( ( --m_nCount == 0 ) && m_pTickerThread )
+    {
+        m_pTickerThread->finish();
+        m_pTickerThread->join();
+
+        delete m_pTickerThread;
+        m_pTickerThread = NULL;
+    }
+}
+
+// -------------------------------------------------------------------
+// Signal handler
+// -------------------------------------------------------------------
+oslSignalAction Content::HandleLockingSignal( void* pData, oslSignalInfo* pSignalInfo )
+{
+    Content *pContent = static_cast< Content *>( pData );
+
+#if OSL_DEBUG_LEVEL > 0
+	fprintf( stderr, "Content::HandleLockingSignal: pContent=%p\n", pContent );
+#endif
+
+    if ( !pContent )
+        return osl_Signal_ActCallNextHdl;
+
+    if ( pSignalInfo  &&
+            pSignalInfo->Signal == osl_Signal_User &&
+            pSignalInfo->UserSignal == TICKER_THREAD_USER_SIGNAL )
+    {
+        pContent->RefreshLock();
+    }
+    else if ( !pSignalInfo || ( pSignalInfo->Signal != osl_Signal_User ) )
+    {
+        // terminating or something
+		pContent->m_xResAccess->UNLOCK( *pContent->m_pLock, *pContent->m_pLockEnv );
+		delete pContent->m_pLock;
+		pContent->m_pLock = NULL;
+    }
+
+    return osl_Signal_ActCallNextHdl;
+}
+
+static TickerThreadController sTickerThreadController;
+
 //=========================================================================
 // ctr for content on an existing webdav resource
 Content::Content(
@@ -358,7 +475,11 @@
   m_pProvider( pProvider ),
   m_bTransient( false ),
   m_bCollection( false ),
-  m_bDidGetOrHead( false )
+  m_bDidGetOrHead( false ),
+  m_bForceReadOnly( false ),
+  m_pLock( NULL ),
+  m_nToExpire( -1 ),
+  m_pSignalHandler( NULL )
 {
     try
     {
@@ -369,6 +490,13 @@
 
         NeonUri aURI( Identifier->getContentIdentifier() );
         m_aEscapedTitle = aURI.GetPathBaseName();
+
+		m_pSignalHandler = osl_addSignalHandler( HandleLockingSignal, this );
+
+#if OSL_DEBUG_LEVEL > 0
+		fprintf( stderr, "Content::Content: this=%p m_pSignalHandler=%p\n", this, m_pSignalHandler );
+#endif
+		sTickerThreadController.start();
     }
     catch ( DAVException const & )
     {
@@ -390,12 +518,23 @@
   m_pProvider( pProvider ),
   m_bTransient( true ),
   m_bCollection( isCollection ),
-  m_bDidGetOrHead( false )
+  m_bDidGetOrHead( false ),
+  m_bForceReadOnly( false ),
+  m_pLock( NULL ),
+  m_nToExpire( -1 ),
+  m_pSignalHandler( NULL )
 {
     try
     {
         m_xResAccess.reset( new DAVResourceAccess(
             rxSMgr, rSessionFactory, Identifier->getContentIdentifier() ) );
+
+		m_pSignalHandler = osl_addSignalHandler( HandleLockingSignal, this );
+
+#if OSL_DEBUG_LEVEL > 0
+		fprintf( stderr, "Content::Content: this=%p m_pSignalHandler=%p\n", this, m_pSignalHandler );
+#endif
+		sTickerThreadController.start();
     }
     catch ( DAVException const & )
     {
@@ -409,6 +548,48 @@
 // virtual
 Content::~Content()
 {
+#if OSL_DEBUG_LEVEL > 0
+	fprintf( stderr, "Content::~Content: this=%p m_pSignalHandler=%p\n", this, m_pSignalHandler );
+#endif
+	sTickerThreadController.stop();
+
+	osl_removeSignalHandler( m_pSignalHandler );
+
+	if (m_pLock != NULL)
+	{
+		try {
+			m_xResAccess->UNLOCK( *m_pLock, *m_pLockEnv );
+			delete m_pLock;
+			m_pLock = NULL;
+		}
+		catch ( ucb::CommandFailedException const & )
+		{
+		}
+	}
+}
+
+// -------------------------------------------------------------------
+// Lock the resource again
+// -------------------------------------------------------------------
+void Content::RefreshLock( void )
+{
+    osl::MutexGuard aGuard( m_aLock );
+
+#if OSL_DEBUG_LEVEL > 0
+	if (m_nToExpire > 0)
+		fprintf( stderr, "WebDAV: RefreshLock() - will refresh in %d sec\n", m_nToExpire - 30 );
+#endif
+
+    if ( m_nToExpire > 0 )
+        --m_nToExpire;
+
+    // Refresh the lock if it expires in less than 30 s
+    if ( m_pLock && m_nToExpire >= 0 && m_nToExpire < 30 )
+    {
+        m_xResAccess->LOCK( *m_pLock, *m_pLockEnv );
+
+        m_nToExpire = m_pLock->Timeout;
+    }
 }
 
 //=========================================================================
@@ -630,6 +811,11 @@
            ucb::CommandAbortedException,
            uno::RuntimeException )
 {
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: Execute command '%s'\n",
+            rtl::OUStringToOString( aCommand.Name, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+
     uno::Any aRet;
     
     if ( aCommand.Name.equalsAsciiL(
@@ -1349,6 +1535,31 @@
     uno::Reference< ucb::XContentIdentifier >    xIdentifier;
     rtl::Reference< ::ucbhelper::ContentProviderImplHelper > xProvider;
 
+#if OSL_DEBUG_LEVEL > 0
+    fprintf( stderr, "WebDAV: getPropertyValues: answering the following properties: " );
+    for ( int i = 0; i < rProperties.getLength(); ++i )
+        fprintf( stderr, " %s,",
+                rtl::OUStringToOString( rProperties[i].Name, RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( stderr, "\n" );
+#endif
+
+    // WebDAV supports XActiveDataStreamer
+    // We have to return TRUE on
+    // - SupportsActiveStreaming - always
+    // - IsReadOnly - if we forced read only due to failed locking
+    if ( rProperties.getLength() == 1 )
+    {
+        if ( rProperties[ 0 ].Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "SupportsActiveStreaming" ) ) ||
+             ( rProperties[ 0 ].Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) && m_bForceReadOnly ) )
+        {
+            rtl::Reference< ::ucbhelper::PropertyValueSet > xRow
+                = new ::ucbhelper::PropertyValueSet( m_xSMgr );
+            xRow->appendBoolean( rProperties[0], sal_True );
+
+            return uno::Reference< sdbc::XRow >( xRow.get() );
+        }
+    }
+
     {
         osl::Guard< osl::Mutex > aGuard( m_aMutex );
 
@@ -1475,8 +1686,13 @@
 						
 						if ( !bNetworkAccessAllowed )
 						{
-							cancelCommandExecution( e, xEnv );
-							// unreachable
+                            if ( e.getStatus() == SC_NOT_FOUND )
+                                xProps.reset();
+                            else
+                            {
+                                cancelCommandExecution( e, xEnv );
+                                // unreachable
+                            }
 						}
 					}
 				}
@@ -2092,9 +2308,10 @@
         }
     }
 
-    if ( rArg.Sink.is() )
-    {
-        // Open document.
+    if ( !rArg.Sink.is() )
+        return aRet;
+
+       // Open document.
 
     if ( rArg.Mode == ucb::OpenMode::DOCUMENT_SHARE_DENY_WRITE )
         {
@@ -2114,6 +2331,9 @@
             = uno::Reference< io::XOutputStream >( rArg.Sink, uno::UNO_QUERY );
         if ( xOut.is() )
         {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: rArg.Sink is XOutputStream\n" );
+#endif
             // PUSH: write data
             try
             {
@@ -2158,6 +2378,60 @@
                                                          uno::UNO_QUERY );
             if ( xDataSink.is() )
             {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataSink\n" );
+#endif
+            // PULL: wait for client read
+            try
+            {
+                {
+                    osl::MutexGuard aGuard( m_aMutex );
+
+                    // throw away previously cached headers.
+                    m_xCachedProps.reset();
+                }
+                // fill inputsream sync; return if all data present
+                DAVResource aResource;
+                std::vector< rtl::OUString > aHeaders;
+                //                        // Obtain list containing all HTTP headers that can
+                //                        // be mapped to UCB properties.
+                //                        ContentProperties::getMappableHTTPHeaders( aHeaders );
+                uno::Reference< io::XInputStream > xIn
+                    = m_xResAccess->GET( aHeaders, aResource, xEnv )->getInputStream();
+
+                {
+                    osl::MutexGuard aGuard( m_aMutex );
+
+                    m_xCachedProps.reset(
+                            new ContentProperties( aResource ) );
+                }
+
+                xDataSink->setInputStream( xIn );
+            }
+            catch ( DAVException const & e )
+            {
+                cancelCommandExecution( e, xEnv );
+                // Unreachable
+            }
+        }
+        else
+        {
+            uno::Reference< io::XActiveDataStreamer > xDataStreamer
+                = uno::Reference< io::XActiveDataStreamer >( rArg.Sink,
+                        uno::UNO_QUERY );
+            if ( xDataStreamer.is() && !m_bForceReadOnly )
+            {
+#if OSL_DEBUG_LEVEL > 0
+                fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataStreamer\n" );
+#endif
+                // prepare the lock
+                m_pLock = new ucb::Lock;
+                m_pLock->Depth = ucb::LockDepth_ZERO;
+                m_pLock->Scope = ucb::LockScope_EXCLUSIVE;
+                m_pLock->Timeout = 2*60; // 2 minutes
+
+				m_nToExpire = m_pLock->Timeout;
+
                 // PULL: wait for client read
                 try
                 {
@@ -2173,9 +2447,31 @@
                     DAVResource aResource;
                     std::vector< rtl::OUString > aHeaders;
 
-                    uno::Reference< io::XInputStream > xIn
-                        = xResAccess->GET( aHeaders, aResource, xEnv );
+                    try {
+                        m_xResAccess->LOCK( *m_pLock, xEnv );
+						m_pLockEnv = &xEnv;
+                    }
+                    catch ( ucb::CommandFailedException const &e )
+                    {
+                        // stream locked?
+                        ucb::InteractiveIOException aIoException;
+                        if ( ( e.Reason >>= aIoException ) && ( aIoException.Code == ucb::IOErrorCode_LOCKING_VIOLATION ) )
+                        {
+							delete m_pLock;
+							m_pLock = NULL;
+                            // yes => we must be read only at the next try
+                            m_bForceReadOnly = sal_True;
+                        }
+
+                        throw;
+                    }
+
+                    uno::Reference< io::XStream > xStream
+                        = xResAccess->GET( aHeaders, aResource, xEnv, sal_True );
 					m_bDidGetOrHead = true;
+
+                    // pass the URL to the stream
+                    static_cast< NeonInputStream* >( xStream.get() )->SetURL( m_xResAccess->getURL() );
 					
                     {
                         osl::MutexGuard aGuard( m_aMutex );
@@ -2190,16 +2486,24 @@
                             new DAVResourceAccess( *xResAccess.get() ) );
                     }
 
-                    xDataSink->setInputStream( xIn );
+                    xDataStreamer->setStream( xStream );
                 }
                 catch ( DAVException const & e )
                 {
+                    m_xResAccess->UNLOCK( *m_pLock, xEnv );
+					delete m_pLock;
+					m_pLock = NULL;
+                    m_bForceReadOnly = sal_False;
+
                     cancelCommandExecution( e, xEnv );
                     // Unreachable
                 }
             }
             else
             {
+#if OSL_DEBUG_LEVEL > 0
+                fprintf( stderr, "WebDAV: unsupported rArg.Sink\n" );
+#endif
                 // Note: aOpenCommand.Sink may contain an XStream
                 //       implementation. Support for this type of
                 //       sink is optional...
@@ -2227,6 +2531,9 @@
     uno::Reference< io::XActiveDataSink > xSink( rArg.Sink, uno::UNO_QUERY );
     if ( xSink.is() )
     {
+#if OSL_DEBUG_LEVEL > 0
+        fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataSink\n" );
+#endif
         try
         {
             std::auto_ptr< DAVResourceAccess > xResAccess;
@@ -2261,6 +2568,9 @@
         uno::Reference< io::XOutputStream > xResult( rArg.Sink, uno::UNO_QUERY );
         if ( xResult.is() )
         {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XOutputStream\n" );
+#endif
             try
             {
                 std::auto_ptr< DAVResourceAccess > xResAccess;
@@ -2290,6 +2600,9 @@
         }
         else
         {
+#if OSL_DEBUG_LEVEL > 0
+            fprintf( stderr, "WebDAV: rArg.Sink is XActiveDataStreamer (or something)\n" );
+#endif
             ucbhelper::cancelCommandExecution(
                 uno::makeAny(
                     ucb::UnsupportedDataSinkException(
@@ -2642,11 +2955,23 @@
                 rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
         }
         else if ( aScheme.equalsAsciiL(
+                RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAV_URL_SCHEME ) ) )
+        {
+            sourceURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
+        }
+        else if ( aScheme.equalsAsciiL(
                 RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) )
         {
             sourceURI.SetScheme(
                 rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
         }
+        else if ( aScheme.equalsAsciiL(
+                RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAVS_URL_SCHEME ) ) )
+        {
+            sourceURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
+        }
         else
         {
             if ( !aScheme.equalsAsciiL(
@@ -2673,6 +2998,18 @@
                  RTL_CONSTASCII_STRINGPARAM( DAV_URL_SCHEME ) ) )
             targetURI.SetScheme(
                 rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
+        else if ( targetURI.GetScheme().toAsciiLowerCase().equalsAsciiL(
+                 RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAV_URL_SCHEME ) ) )
+            targetURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTP_URL_SCHEME ) );
+        else if ( targetURI.GetScheme().toAsciiLowerCase().equalsAsciiL(
+                 RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) )
+            targetURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
+        else if ( targetURI.GetScheme().toAsciiLowerCase().equalsAsciiL(
+                 RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAVS_URL_SCHEME ) ) )
+            targetURI.SetScheme(
+                rtl::OUString::createFromAscii( HTTPS_URL_SCHEME ) );
 	
         // @@@ This implementation of 'transfer' only works
         //     if the source and target are located at same host.
diff -u ucb/webdav-orig/webdavcontent.hxx ucb/source/ucp/webdav/webdavcontent.hxx
--- ucb/webdav-orig/webdavcontent.hxx	2009-03-05 13:01:30.503250000 +0200
+++ ucb/source/ucp/webdav/webdavcontent.hxx	2009-03-06 14:29:05.378250000 +0200
@@ -33,10 +33,13 @@
 
 #include <memory>
 #include <list>
+#include <osl/signal.h>
 #include <rtl/ref.hxx>
 #include <com/sun/star/ucb/ContentCreationException.hpp>
 #include <com/sun/star/ucb/XContentCreator.hpp>
+#include <com/sun/star/ucb/Lock.hpp>
 #include <ucbhelper/contenthelper.hxx>
+
 #include "DAVResourceAccess.hxx"
 #include "PropertyMap.hxx"
 
@@ -91,6 +94,9 @@
   	bool			  m_bTransient;
 	bool              m_bCollection;
 	bool              m_bDidGetOrHead;
+	bool              m_bForceReadOnly;
+	com::sun::star::ucb::Lock *m_pLock;
+	const uno::Reference< ucb::XCommandEnvironment > *m_pLockEnv;
 	std::vector< rtl::OUString > m_aFailedPropNames;
 
 private:
@@ -184,6 +190,17 @@
 
     static bool shouldAccessNetworkAfterException( const DAVException & e );
 
+    oslSignalHandler           m_pSignalHandler;
+    int                        m_nToExpire;
+    osl::Mutex                 m_aLock;
+
+    // Refresh the lock of the resource
+    void RefreshLock( void );
+
+    // Refresh the lock if necessary, or unlock the resource when
+    // OOo crashes or is terminated
+    static oslSignalAction HandleLockingSignal( void* pData, oslSignalInfo* pInfo );
+
 public:
   	Content( const ::com::sun::star::uno::Reference<
 	   		 ::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
diff -u ucb/webdav-orig/webdavcontentcaps.cxx ucb/source/ucp/webdav/webdavcontentcaps.cxx
--- ucb/webdav-orig/webdavcontentcaps.cxx	2009-03-05 13:01:30.503250000 +0200
+++ ucb/source/ucp/webdav/webdavcontentcaps.cxx	2009-03-02 17:52:48.518875000 +0200
@@ -263,6 +263,24 @@
 				    -1,
                     getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
                     beans::PropertyAttribute::BOUND ) );
+
+			m_pProps->insert(
+				beans::Property(
+					rtl::OUString(
+						RTL_CONSTASCII_USTRINGPARAM( "SupportsActiveStreaming" ) ),
+					-1,
+					getCppuBooleanType(),
+					beans::PropertyAttribute::BOUND
+						| beans::PropertyAttribute::READONLY ) );
+
+			m_pProps->insert(
+				beans::Property(
+					rtl::OUString(
+						RTL_CONSTASCII_USTRINGPARAM( "IsReadOnly" ) ),
+					-1,
+					getCppuBooleanType(),
+					beans::PropertyAttribute::BOUND
+						| beans::PropertyAttribute::READONLY ) );
 		}
 	}
 
diff -u ucb/webdav-orig/webdavprovider.cxx ucb/source/ucp/webdav/webdavprovider.cxx
--- ucb/webdav-orig/webdavprovider.cxx	2009-03-05 13:01:30.518875000 +0200
+++ ucb/source/ucp/webdav/webdavprovider.cxx	2009-03-02 17:52:48.518875000 +0200
@@ -36,6 +36,9 @@
  **************************************************************************
 
  *************************************************************************/
+
+#include <string.h>
+
 #include <ucbhelper/contentidentifier.hxx>
 #include "webdavprovider.hxx"
 #include "webdavcontent.hxx"
@@ -138,7 +141,11 @@
             RTL_CONSTASCII_STRINGPARAM( DAV_URL_SCHEME ) ) &&
          !aScheme.equalsAsciiL(
             RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) &&
-          !aScheme.equalsAsciiL(
+         !aScheme.equalsAsciiL(
+            RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAV_URL_SCHEME ) ) &&
+         !aScheme.equalsAsciiL(
+            RTL_CONSTASCII_STRINGPARAM( PLAIN_WEBDAVS_URL_SCHEME ) ) &&
+         !aScheme.equalsAsciiL(
              RTL_CONSTASCII_STRINGPARAM( FTP_URL_SCHEME ) )       )
         throw ucb::IllegalIdentifierException();
 
@@ -157,32 +164,27 @@
     uno::Reference< ucb::XContentIdentifier > xCanonicId;
 
     bool bNewId = false;
-    if ( aScheme.equalsAsciiL(
-            RTL_CONSTASCII_STRINGPARAM( WEBDAV_URL_SCHEME ) ) )
+    struct {
+        const char *from;
+        const char *to;
+    } const *pScheme, pReplace[] = {
+        { WEBDAV_URL_SCHEME, HTTP_URL_SCHEME },
+        { DAV_URL_SCHEME, HTTP_URL_SCHEME },
+        { DAVS_URL_SCHEME, HTTPS_URL_SCHEME },
+        { PLAIN_WEBDAV_URL_SCHEME, HTTP_URL_SCHEME },
+        { PLAIN_WEBDAVS_URL_SCHEME, HTTPS_URL_SCHEME },
+        { NULL, NULL }
+    };
+    for ( pScheme = pReplace; pScheme->from ; ++pScheme )
     {
-        aURL = aURL.replaceAt( 0,
-                               WEBDAV_URL_SCHEME_LENGTH,
-                               rtl::OUString::createFromAscii(
-                                                    HTTP_URL_SCHEME ) );
-        bNewId = true;
-    }
-    else if ( aScheme.equalsAsciiL(
-            RTL_CONSTASCII_STRINGPARAM( DAV_URL_SCHEME ) ) )
-    {
-        aURL = aURL.replaceAt( 0,
-                               DAV_URL_SCHEME_LENGTH,
-                               rtl::OUString::createFromAscii(
-                                                    HTTP_URL_SCHEME ) );
-        bNewId = true;
-    }
-    else if ( aScheme.equalsAsciiL(
-            RTL_CONSTASCII_STRINGPARAM( DAVS_URL_SCHEME ) ) )
-    {
-        aURL = aURL.replaceAt( 0,
-                               DAVS_URL_SCHEME_LENGTH,
-                               rtl::OUString::createFromAscii(
-                                                    HTTPS_URL_SCHEME ) );
-        bNewId = true;
+        if ( aScheme.equalsAscii( pScheme->from ) )
+        {
+            aURL = aURL.replaceAt( 0,
+                    strlen( pScheme->from ),
+                    rtl::OUString::createFromAscii( pScheme->to ) );
+            bNewId = true;
+            break;
+        }
     }
 
     sal_Int32 nPos = aURL.lastIndexOf( '/' );
@@ -232,4 +234,3 @@
 
 	return xContent;
 }
-
diff -u ucb/webdav-orig/webdavprovider.hxx ucb/source/ucp/webdav/webdavprovider.hxx
--- ucb/webdav-orig/webdavprovider.hxx	2009-03-05 13:01:30.518875000 +0200
+++ ucb/source/ucp/webdav/webdavprovider.hxx	2009-03-02 17:52:48.518875000 +0200
@@ -52,13 +52,10 @@
 // contents ) according to this scheme.
 #define WEBDAV_URL_SCHEME \
 				"vnd.sun.star.webdav"
-#define WEBDAV_URL_SCHEME_LENGTH	19
 
 #define HTTP_URL_SCHEME 		"http"
-#define HTTP_URL_SCHEME_LENGTH	4
 
 #define HTTPS_URL_SCHEME 		"https"
-#define HTTPS_URL_SCHEME_LENGTH	5
 
 #define DAV_URL_SCHEME			"dav"
 #define DAV_URL_SCHEME_LENGTH	3	
@@ -70,6 +67,12 @@
 
 #define FTP_URL_SCHEME "ftp"
 
+#define DAV_URL_SCHEME "dav"
+#define DAVS_URL_SCHEME "davs"
+
+#define PLAIN_WEBDAV_URL_SCHEME "webdav"
+#define PLAIN_WEBDAVS_URL_SCHEME "webdavs"
+
 #define HTTP_CONTENT_TYPE \
 				"application/" HTTP_URL_SCHEME "-content"
 
diff --git unotools/source/ucbhelper/ucblockbytes.cxx unotools/source/ucbhelper/ucblockbytes.cxx
index be78f73..6a7860c 100644
--- unotools/source/ucbhelper/ucblockbytes.cxx
+++ unotools/source/ucbhelper/ucblockbytes.cxx
@@ -964,6 +964,10 @@ static sal_Bool UCBOpenContentSync(
     if( ! aScheme.equalsIgnoreAsciiCaseAscii("http")                &&
 		! aScheme.equalsIgnoreAsciiCaseAscii("https")                &&
         ! aScheme.equalsIgnoreAsciiCaseAscii("vnd.sun.star.webdav") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("dav") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("davs") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("webdav") &&
+        ! aScheme.equalsIgnoreAsciiCaseAscii("webdavs") &&
         ! aScheme.equalsIgnoreAsciiCaseAscii("ftp"))
 		return _UCBOpenContentSync(
 			xLockBytes,xContent,rArg,xSink,xInteract,xProgress,xHandler);
@@ -1541,7 +1545,13 @@ ErrCode UcbLockBytes::Flush() const
     Reference <XOutputStream > xOutputStream = getOutputStream_Impl();
     if ( !xOutputStream.is() )
         return ERRCODE_IO_CANTWRITE;
-    xOutputStream->flush();
+    try {
+        xOutputStream->flush();
+    }
+    catch (...)
+    {
+        return ERRCODE_IO_CANTWRITE;
+    }
     return ERRCODE_NONE;
 }
 
