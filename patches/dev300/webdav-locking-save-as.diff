diff --git ucb/source/ucp/webdav/DAVResourceAccess.cxx ucb/source/ucp/webdav/DAVResourceAccess.cxx
index 1686958..a9b3742 100644
--- ucb/source/ucp/webdav/DAVResourceAccess.cxx
+++ ucb/source/ucp/webdav/DAVResourceAccess.cxx
@@ -444,7 +444,8 @@ void DAVResourceAccess::GET(
 uno::Reference< io::XStream > DAVResourceAccess::GET(
     const std::vector< rtl::OUString > & rHeaderNames,
     DAVResource & rResource,
-    const uno::Reference< ucb::XCommandEnvironment > & xEnv )
+    const uno::Reference< ucb::XCommandEnvironment > & xEnv,
+    sal_Bool bAllowEmpty )
   throw( DAVException )
 {
     initialize();
@@ -468,7 +469,8 @@ uno::Reference< io::XStream > DAVResourceAccess::GET(
                                        DAVRequestEnvironment(
                                            getRequestURI(),
                                            new DAVAuthListener_Impl( xEnv ),
-                                           aHeaders, xEnv ) );
+                                           aHeaders, xEnv ),
+                                       bAllowEmpty );
         }
         catch ( DAVException & e )
         {
diff --git ucb/source/ucp/webdav/DAVResourceAccess.hxx ucb/source/ucp/webdav/DAVResourceAccess.hxx
index aba8342..b7cc610 100644
--- ucb/source/ucp/webdav/DAVResourceAccess.hxx
+++ ucb/source/ucp/webdav/DAVResourceAccess.hxx
@@ -171,7 +171,8 @@ public:
     GET( const std::vector< rtl::OUString > & rHeaderNames, // empty == 'all'
          DAVResource & rResource,
          const com::sun::star::uno::Reference<
-	     com::sun::star::ucb::XCommandEnvironment > & xEnv )
+	     com::sun::star::ucb::XCommandEnvironment > & xEnv,
+         sal_Bool bAllowEmpty = sal_False )
         throw( DAVException );
 
     void
diff --git ucb/source/ucp/webdav/DAVSession.hxx ucb/source/ucp/webdav/DAVSession.hxx
index a0d6d38..ae4ae52 100644
--- ucb/source/ucp/webdav/DAVSession.hxx
+++ ucb/source/ucp/webdav/DAVSession.hxx
@@ -150,7 +150,8 @@ public:
                     GET( const ::rtl::OUString & inPath,
                          const std::vector< ::rtl::OUString > & inHeaderNames,
                          DAVResource & ioResource,
-                         const DAVRequestEnvironment & rEnv )
+                         const DAVRequestEnvironment & rEnv,
+                         sal_Bool bAllowEmpty )
         throw( DAVException ) = 0;
 
     virtual void    GET( const ::rtl::OUString & inPath,
diff --git ucb/source/ucp/webdav/NeonSession.cxx ucb/source/ucp/webdav/NeonSession.cxx
index 5c05445..6ca255b 100644
--- ucb/source/ucp/webdav/NeonSession.cxx
+++ ucb/source/ucp/webdav/NeonSession.cxx
@@ -1146,7 +1146,8 @@ uno::Reference< io::XStream >
 NeonSession::GET( const rtl::OUString & inPath,
 		  const std::vector< ::rtl::OUString > & inHeaderNames,
 		  DAVResource & ioResource,
-		  const DAVRequestEnvironment & rEnv )
+		  const DAVRequestEnvironment & rEnv,
+		  sal_Bool bAllowEmpty )
     throw ( DAVException )
 {
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
@@ -1166,7 +1167,14 @@ NeonSession::GET( const rtl::OUString & inPath,
                          NeonSession_ResponseBlockReader,
                          true,
                          &aCtx );
-    HandleError( theRetVal );
+    try {
+        HandleError( theRetVal );
+    }
+    catch ( DAVException const & e )
+    {
+        if ( !bAllowEmpty || ( e.getStatus() != SC_NOT_FOUND ) )
+            throw;
+    }
     return uno::Reference< io::XStream >( xStream.get() );
 }
 
diff --git ucb/source/ucp/webdav/NeonSession.hxx ucb/source/ucp/webdav/NeonSession.hxx
index 7ac692d..7099da1 100644
--- ucb/source/ucp/webdav/NeonSession.hxx
+++ ucb/source/ucp/webdav/NeonSession.hxx
@@ -159,7 +159,8 @@ class NeonSession : public DAVSession
         GET( const ::rtl::OUString & inPath,
              const std::vector< ::rtl::OUString > & inHeaderNames,
              DAVResource & ioResource,
-             const DAVRequestEnvironment & rEnv )
+             const DAVRequestEnvironment & rEnv,
+             sal_Bool bAllowEmpty = sal_False )
             throw ( DAVException );
 
         virtual void
diff --git ucb/source/ucp/webdav/webdavcontent.cxx ucb/source/ucp/webdav/webdavcontent.cxx
index 6e01a66..f91405c 100644
--- ucb/source/ucp/webdav/webdavcontent.cxx
+++ ucb/source/ucp/webdav/webdavcontent.cxx
@@ -1558,8 +1558,13 @@ uno::Reference< sdbc::XRow > Content::getPropertyValues(
 
                         if ( !bNetworkAccessAllowed )
                         {
-                            cancelCommandExecution( e, xEnv );
-                            // unreachable
+                            if ( e.getStatus() == SC_NOT_FOUND )
+                                xProps.reset();
+                            else
+                            {
+                                cancelCommandExecution( e, xEnv );
+                                // unreachable
+                            }
                         }
                     }
 
@@ -2321,20 +2326,28 @@ uno::Any Content::open(
                     //                        // be mapped to UCB properties.
                     //                        ContentProperties::getMappableHTTPHeaders( aHeaders );
 
-                    // if the locking or the creation of the stream below
-		    // fails, we are read only at the next try
-		    m_bForceReadOnly = sal_True;
+                    try {
+                        m_xResAccess->LOCK( aLock, xEnv );
+                    }
+                    catch ( ucb::CommandFailedException const &e )
+                    {
+                        // stream locked?
+                        ucb::InteractiveIOException aIoException;
+                        if ( ( e.Reason >>= aIoException ) && ( aIoException.Code == ucb::IOErrorCode_LOCKING_VIOLATION ) )
+                        {
+                            // yes => we must be read only at the next try
+                            m_bForceReadOnly = sal_True;
+                        }
 
-		    m_xResAccess->LOCK( aLock, xEnv );
+                        throw;
+                    }
 
-		    uno::Reference< io::XStream > xStream
-                        = xResAccess->GET( aHeaders, aResource, xEnv );
+                    uno::Reference< io::XStream > xStream
+                        = xResAccess->GET( aHeaders, aResource, xEnv, sal_True );
 
                     // pass the lock to the stream
-		    static_cast< NeonInputStream* >( xStream.get() )->SetLock( aLock, m_xResAccess->getURL() );
+                    static_cast< NeonInputStream* >( xStream.get() )->SetLock( aLock, m_xResAccess->getURL() );
 
-		    // everything went well wrt. locking
-		    m_bForceReadOnly = sal_False;
                     {
 
                         osl::MutexGuard aGuard( m_aMutex );
@@ -2350,8 +2363,8 @@ uno::Any Content::open(
                 }
                 catch ( DAVException const & e )
                 {
-		    m_xResAccess->UNLOCK( aLock, xEnv );
-		    m_bForceReadOnly = sal_False;
+                    m_xResAccess->UNLOCK( aLock, xEnv );
+                    m_bForceReadOnly = sal_False;
 
                     cancelCommandExecution( e, xEnv );
                     // Unreachable
