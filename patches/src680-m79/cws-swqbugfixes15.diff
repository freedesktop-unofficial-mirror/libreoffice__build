Index: filter/source/pdf/pdfexport.cxx
===================================================================
RCS file: /cvs/framework/filter/source/pdf/pdfexport.cxx,v
retrieving revision 1.34
retrieving revision 1.34.58.2
diff -u -p -r1.34 -r1.34.58.2
--- filter/source/pdf/pdfexport.cxx	7 Jan 2005 09:20:01 -0000	1.34
+++ filter/source/pdf/pdfexport.cxx	18 Feb 2005 15:18:57 -0000	1.34.58.2
@@ -154,6 +154,7 @@ PDFExport::PDFExport( const Reference< X
 	mbUseTransitionEffects	( sal_True ),
 	mbUseLosslessCompression( sal_False ),
 	mbReduceImageResolution	( sal_False ),
+    mbSkipEmptyPages        ( sal_False ),
 	mnMaxImageResolution	( 300 ),
 	mnQuality				( 90 ),
 	mnFormsFormat			( 0 ),
@@ -233,8 +234,9 @@ sal_Bool PDFExport::ExportSelection( vcl
 					aMtf.Stop();
 					aMtf.WindStart();
 
-					if( aMtf.GetActionCount() )
-						bRet = ImplExportPage( rPDFWriter, *pPDFExtOutDevData, aMtf ) || bRet;
+                    if( aMtf.GetActionCount() &&
+                             ( !mbSkipEmptyPages || aPageSize.Width || aPageSize.Height ) )
+                        bRet = ImplExportPage( rPDFWriter, *pPDFExtOutDevData, aMtf ) || bRet;
 
 					pOut->Pop();
 
@@ -313,6 +315,8 @@ sal_Bool PDFExport::Export( const OUStri
 					rFilterData[ nData ].Value >>= mnQuality;
 				else if ( rFilterData[ nData ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "ReduceImageResolution" ) ) )
 					rFilterData[ nData ].Value >>= mbReduceImageResolution;
+                else if ( rFilterData[ nData ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "SkipEmptyPages" ) ) )
+                    rFilterData[ nData ].Value >>= mbSkipEmptyPages;
 				else if ( rFilterData[ nData ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxImageResolution" ) ) )
 					rFilterData[ nData ].Value >>= mnMaxImageResolution;
 				else if ( rFilterData[ nData ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "UseTaggedPDF" ) ) )
@@ -349,7 +353,7 @@ sal_Bool PDFExport::Export( const OUStri
 				pPDFExtOutDevData->SetIsLosslessCompression( mbUseLosslessCompression );
 				pPDFExtOutDevData->SetIsReduceImageResolution( mbReduceImageResolution );
 
-                Sequence< PropertyValue > aRenderOptions( 4 );
+                Sequence< PropertyValue > aRenderOptions( 6 );
 				aRenderOptions[ 0 ].Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "RenderDevice" ) );
 				aRenderOptions[ 0 ].Value <<= Reference< awt::XDevice >( pXDevice );
 				aRenderOptions[ 1 ].Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "ExportNotesPages" ) );
@@ -359,6 +363,10 @@ sal_Bool PDFExport::Export( const OUStri
 				aRenderOptions[ 2 ].Value <<= sal_True;
                 aRenderOptions[ 3 ].Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "LastPage" ) );
                 aRenderOptions[ 3 ].Value <<= sal_False;
+                aRenderOptions[ 4 ].Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "PageRange" ) );
+                aRenderOptions[ 4 ].Value <<= aPageRange;
+                aRenderOptions[ 5 ].Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "SkipEmptyPages" ) );
+                aRenderOptions[ 5 ].Value <<= mbSkipEmptyPages;
 
 				if( aPageRange.getLength() || !aSelection.hasValue() )
 				{
Index: filter/source/pdf/pdfexport.hxx
===================================================================
RCS file: /cvs/framework/filter/source/pdf/pdfexport.hxx,v
retrieving revision 1.4
retrieving revision 1.4.118.1
diff -u -p -r1.4 -r1.4.118.1
--- filter/source/pdf/pdfexport.hxx	8 Sep 2004 16:00:13 -0000	1.4
+++ filter/source/pdf/pdfexport.hxx	18 Feb 2005 15:18:58 -0000	1.4.118.1
@@ -99,6 +99,7 @@ private:
 
 	sal_Bool				mbUseLosslessCompression;
 	sal_Bool				mbReduceImageResolution;
+    sal_Bool                mbSkipEmptyPages;
 	sal_Int32				mnMaxImageResolution;
 	sal_Int32				mnQuality;
 	sal_Int32				mnFormsFormat;
@@ -117,7 +118,7 @@ public:
 
 					        PDFExport( const Reference< XComponent >& rxSrcDoc, Reference< task::XStatusIndicator >& xStatusIndicator );
 					        ~PDFExport();
-                        
+
 	sal_Bool                ExportSelection( vcl::PDFWriter& rPDFWriter, Reference< com::sun::star::view::XRenderable >& rRenderable, Any& rSelection,
 								MultiSelection aMultiSelection, Sequence< PropertyValue >& rRenderOptions );
 
Index: binfilter/bf_sw/source/core/unocore/sw_unofield.cxx
===================================================================
RCS file: /cvs/framework/binfilter/bf_sw/source/core/unocore/sw_unofield.cxx,v
retrieving revision 1.4
retrieving revision 1.4.66.1
diff -u -p -r1.4 -r1.4.66.1
--- binfilter/bf_sw/source/core/unocore/sw_unofield.cxx	3 Aug 2004 18:10:04 -0000	1.4
+++ binfilter/bf_sw/source/core/unocore/sw_unofield.cxx	8 Feb 2005 06:49:25 -0000	1.4.66.1
@@ -241,7 +241,7 @@
 #ifndef _DDEFLD_HXX
 #include <ddefld.hxx>
 #endif
-#ifndef _DATETIME_HXX 
+#ifndef _DATETIME_HXX
 #include <tools/datetime.hxx>
 #endif
 #define _SVSTDARR_STRINGS
@@ -262,7 +262,7 @@
 #include <unofldmid.h>
 #endif
 namespace binfilter {
-String& GetString( const ::com::sun::star::uno::Any& rAny, String& rStr ); //STRIP008 
+String& GetString( const ::com::sun::star::uno::Any& rAny, String& rStr ); //STRIP008
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
@@ -1289,9 +1289,9 @@ SwXTextField::SwXTextField(sal_uInt16 nS
     m_bCallUpdate(sal_False)
 {
 	//Set visible as default!
-    if(SW_SERVICE_FIELDTYPE_SET_EXP == nServiceId || 
-            SW_SERVICE_FIELDTYPE_DATABASE_SET_NUM == nServiceId || 
-            SW_SERVICE_FIELDTYPE_DATABASE == nServiceId || 
+    if(SW_SERVICE_FIELDTYPE_SET_EXP == nServiceId ||
+            SW_SERVICE_FIELDTYPE_DATABASE_SET_NUM == nServiceId ||
+            SW_SERVICE_FIELDTYPE_DATABASE == nServiceId ||
             SW_SERVICE_FIELDTYPE_DATABASE_NAME == nServiceId  )
 		m_pProps->bBool2 = sal_True;
     else if(SW_SERVICE_FIELDTYPE_TABLE_FORMULA == nServiceId)
@@ -1832,12 +1832,12 @@ void SwXTextField::attachToRange(
                 pFld = new SwDropDownField
                     ((SwDropDownFieldType *)
                      pDoc->GetSysFldType(RES_DROPDOWN));
-                    
+
                 ((SwDropDownField *) pFld)->SetItems(m_pProps->aStrings);
                 ((SwDropDownField *) pFld)->SetSelectedItem(m_pProps->sPar1);
                 ((SwDropDownField *) pFld)->SetName(m_pProps->sPar2);
                 break;
-           
+
             case SW_SERVICE_FIELDTYPE_TABLE_FORMULA :
             {
 
@@ -2449,26 +2449,10 @@ sal_uInt16 lcl_GetIdByName( String& rNam
 		nResId = RES_DDEFLD;
 	else if(rTypeName.EqualsAscii("SetExpression"))
 	{
-        // build indices do access programmatic names
-        static sal_uInt16 nIds[] =
-        {
-            RES_POOLCOLL_LABEL_DRAWING  - RES_POOLCOLL_EXTRA_BEGIN,
-            RES_POOLCOLL_LABEL_ABB      - RES_POOLCOLL_EXTRA_BEGIN,
-            RES_POOLCOLL_LABEL_TABLE    - RES_POOLCOLL_EXTRA_BEGIN,
-            RES_POOLCOLL_LABEL_FRAME    - RES_POOLCOLL_EXTRA_BEGIN,
-            0
-        };
-        const SvStringsDtor& rExtraArr = SwStyleNameMapper::GetExtraProgNameArray();
-
-		nResId = RES_SETEXPFLD;
+        nResId = RES_SETEXPFLD;
 
         String sFldTypName( rName.GetToken( 1, '.' ));
-        String sUIName( sFldTypName );
-        if (*rExtraArr[ nIds[0] ] == sUIName ||
-            *rExtraArr[ nIds[1] ] == sUIName ||
-            *rExtraArr[ nIds[2] ] == sUIName ||
-            *rExtraArr[ nIds[3] ] == sUIName)
-            sUIName = SwStyleNameMapper::GetUIName( sFldTypName, GET_POOLID_TXTCOLL );
+        String sUIName( SwStyleNameMapper::GetSpecialExtraUIName( sFldTypName ) );
 
 		if( sUIName != sFldTypName )
 			rName.SetToken( 1, '.', sUIName );
@@ -2538,9 +2522,8 @@ sal_Bool SwXTextFieldMasters::getInstanc
 	case RES_SETEXPFLD:
 		rName.AppendAscii( RTL_CONSTASCII_STRINGPARAM( COM_TEXT_FLDMASTER ));
 		rName.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "SetExpression."));
-		rName += String(SwStyleNameMapper::GetProgName( rFldType.GetName(),
-														GET_POOLID_TXTCOLL ));
-		break;
+        rName += String( SwStyleNameMapper::GetSpecialExtraProgName( rFldType.GetName() ) );
+        break;
 
 	case RES_DBFLD:
 		{
Index: goodies/source/graphic/grfmgr2.cxx
===================================================================
RCS file: /cvs/graphics/goodies/source/graphic/grfmgr2.cxx,v
retrieving revision 1.17
retrieving revision 1.17.52.1
diff -u -p -r1.17 -r1.17.52.1
--- goodies/source/graphic/grfmgr2.cxx	11 Jun 2004 09:49:31 -0000	1.17
+++ goodies/source/graphic/grfmgr2.cxx	15 Feb 2005 08:41:23 -0000	1.17.52.1
@@ -1869,8 +1869,11 @@ bool GraphicObject::ImplDrawTiled( Outpu
     const MapMode	aMapMode( aOutMapMode.GetMapUnit(), Point(), aOutMapMode.GetScaleX(), aOutMapMode.GetScaleY() );
     bool 			bRet( false );
 
+    // #i42643# Casting to Int64, to avoid integer overflow for
+    // huge-DPI output devices
     if( GetGraphic().GetType() == GRAPHIC_BITMAP &&
-        rSizePixel.Width() * rSizePixel.Height() < nTileCacheSize1D*nTileCacheSize1D )
+        static_cast<sal_Int64>(rSizePixel.Width()) * rSizePixel.Height() < 
+        static_cast<sal_Int64>(nTileCacheSize1D)*nTileCacheSize1D )
     {
         // First combine very small bitmaps into a larger tile
         // ===================================================
@@ -1879,7 +1882,8 @@ bool GraphicObject::ImplDrawTiled( Outpu
         const int		nNumTilesInCacheX( (nTileCacheSize1D + rSizePixel.Width()-1) / rSizePixel.Width() );
         const int		nNumTilesInCacheY( (nTileCacheSize1D + rSizePixel.Height()-1) / rSizePixel.Height() );
 
-        aVDev.SetOutputSizePixel( Size( nNumTilesInCacheX*rSizePixel.Width(), nNumTilesInCacheY*rSizePixel.Height() ) );
+        aVDev.SetOutputSizePixel( Size( nNumTilesInCacheX*rSizePixel.Width(), 
+                                        nNumTilesInCacheY*rSizePixel.Height() ) );
         aVDev.SetMapMode( aMapMode );
 
         // draw bitmap content
Index: sw/inc/EnhancedPDFExportHelper.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/EnhancedPDFExportHelper.hxx,v
retrieving revision 1.3
retrieving revision 1.3.202.2
diff -u -p -r1.3 -r1.3.202.2
--- sw/inc/EnhancedPDFExportHelper.hxx	28 Oct 2004 10:16:03 -0000	1.3
+++ sw/inc/EnhancedPDFExportHelper.hxx	18 Feb 2005 15:20:55 -0000	1.3.202.2
@@ -78,6 +78,8 @@ class SwFrm;
 class SwLinePortion;
 class SwTxtPainter;
 class SwEditShell;
+class rtl::OUString;
+class MultiSelection;
 
 
 /*
@@ -203,15 +205,26 @@ class SwEnhancedPDFExportHelper
     SwEditShell& mrSh;
     OutputDevice& mrOut;
 
+    MultiSelection* pPageRange;
+
+    bool mbSkipEmptyPages;
+    bool mbEditEngineOnly;
+
     static LinkIdMap aLinkIdMap;
     static FrmTagIdMap aFrmTagIdMap;
 
-    void EnhancedPDFExport( bool bEditEngineOnly );
+    void EnhancedPDFExport();
+    sal_Int32 CalcOutputPageNum( const SwRect& rRect );
 
     public:
 
-    SwEnhancedPDFExportHelper( SwEditShell& rSh, OutputDevice& rOut,
-                               bool bEditEngineOnly = false );
+    SwEnhancedPDFExportHelper( SwEditShell& rSh,
+                               OutputDevice& rOut,
+                               const rtl::OUString& rPageRange,
+                               bool bSkipEmptyPages,
+                               bool bEditEngineOnly );
+
+    ~SwEnhancedPDFExportHelper();
 
     static LinkIdMap& GetLinkIdMap() { return aLinkIdMap; }
     static FrmTagIdMap& GetFrmTagIdMap() { return aFrmTagIdMap; }
Index: sw/inc/dbmgr.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/dbmgr.hxx,v
retrieving revision 1.27
retrieving revision 1.27.12.1
diff -u -p -r1.27 -r1.27.12.1
--- sw/inc/dbmgr.hxx	28 Jan 2005 15:25:21 -0000	1.27
+++ sw/inc/dbmgr.hxx	18 Feb 2005 15:20:56 -0000	1.27.12.1
@@ -211,19 +211,21 @@ struct SwMergeDescriptor
     SwWrtShell&                                         rSh;
     const ::svx::ODataAccessDescriptor&                 rDescriptor;
     String                                              sSaveToFilter; //export filter to save resulting files
-            
-    String                                              sSubject;           
-    String                                              sAddressFromColumn; 
-    String                                              sMailBody;          
-    String                                              sAttachmentName;    
-    ::com::sun::star::uno::Sequence< ::rtl::OUString >  aCopiesTo;          
-    ::com::sun::star::uno::Sequence< ::rtl::OUString >  aBlindCopiesTo;     
-    
+    String                                              sSaveToFilterOptions; //
+    com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > aSaveToFilterData;
+
+    String                                              sSubject;
+    String                                              sAddressFromColumn;
+    String                                              sMailBody;
+    String                                              sAttachmentName;
+    ::com::sun::star::uno::Sequence< ::rtl::OUString >  aCopiesTo;
+    ::com::sun::star::uno::Sequence< ::rtl::OUString >  aBlindCopiesTo;
+
     ::com::sun::star::uno::Reference< com::sun::star::mail::XSmtpService > xSmtpServer;
-    
-    sal_Bool                                            bSendAsHTML;        
-    sal_Bool                                            bSendAsAttachment;      
-    
+
+    sal_Bool                                            bSendAsHTML;
+    sal_Bool                                            bSendAsAttachment;
+
     sal_Bool                                            bPrintAsync;
     sal_Bool                                            bCreateSingleFile;
 
@@ -250,7 +252,7 @@ class AbstractMailMergeDlg;
 class SW_DLLPUBLIC SwNewDBMgr
 {
 friend class SwConnectionDisposedListener_Impl;
-    
+
     static SwDbtoolsClient* pDbtoolsClient;
 
     String              sEMailAddrFld;  // Mailing: Spaltenname der E-Mail Adresse
@@ -263,7 +265,7 @@ friend class SwConnectionDisposedListene
 
 	BOOL 				bInMerge	: 1;	//merge process active
     BOOL                bMergeSilent : 1;   // suppress display of dialogs/boxes (used when called over API)
-    BOOL                bMergeLock : 1;     // prevent update of database fields while document is 
+    BOOL                bMergeLock : 1;     // prevent update of database fields while document is
                                             // actually printed at the ViewShell
 	SwDSParamArr		aDataSourceParams;
     SwNewDBMgr_Impl*    pImpl;
@@ -286,7 +288,7 @@ friend class SwConnectionDisposedListene
 	SW_DLLPRIVATE void ImportDBEntry(SwWrtShell* pSh);
 
     // merge to file _and_ merge to e-Mail
-    SW_DLLPRIVATE BOOL          MergeMailFiles(SwWrtShell* pSh, 
+    SW_DLLPRIVATE BOOL          MergeMailFiles(SwWrtShell* pSh,
                                         const SwMergeDescriptor& rMergeDescriptor );
     SW_DLLPRIVATE BOOL          ToNextRecord(SwDSParam* pParam);
 
@@ -297,7 +299,7 @@ public:
 	// Art des aktellen Mergens. Siehe DBMgrOptions-enum
 	inline USHORT	GetMergeType() const			{ return nMergeType; }
 	inline void 	SetMergeType( USHORT nTyp ) 	{ nMergeType = nTyp; }
-    
+
     // MailMergeEvent source
     const SwXMailMerge *    GetMailMergeEvtSrc() const  { return pMergeEvtSrc; }
     void SetMailMergeEvtSrc( const SwXMailMerge *pSrc ) { pMergeEvtSrc = pSrc; }
@@ -314,7 +316,7 @@ public:
     // printing parts of a merge result document
     BOOL            MergePrintDocuments( SwView& rView,
                                 SwPrtOptions& rOpt, SfxProgress& rProgress );
-    
+
     // Datenbankfelder mit fehlendem Datenbankname initialisieren
 	inline BOOL 	IsInitDBFields() const 	{ return bInitDBFields;	}
 	inline void 	SetInitDBFields(BOOL b)	{ bInitDBFields = b;	}
@@ -418,12 +420,12 @@ public:
 									BYTE	eTableOrQuery = SW_DB_SELECT_UNKNOWN);
 
 	static ::com::sun::star::uno::Sequence<rtl::OUString> GetExistingDatabaseNames();
-    
+
     /**
      Loads a data source from file and registers it. Returns the registered name.
      */
     static String               LoadAndRegisterDataSource();
-    
+
     static SwDbtoolsClient&    GetDbtoolsClient();
     // has to be called from _FinitUI()
     static void                RemoveDbtoolsClient();
Index: sw/inc/doc.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/doc.hxx,v
retrieving revision 1.100
retrieving revision 1.100.26.1
diff -u -p -r1.100 -r1.100.26.1
--- sw/inc/doc.hxx	25 Jan 2005 14:41:12 -0000	1.100
+++ sw/inc/doc.hxx	18 Feb 2005 15:20:57 -0000	1.100.26.1
@@ -1476,7 +1476,7 @@ public:
 	SW_DLLPUBLIC void UpdateDocStat( SwDocStat& rStat );
 
     sal_uInt16 GetPageCount() const;
-    const Size GetPageSize( sal_uInt16 nPageNum ) const;
+    const Size GetPageSize( sal_uInt16 nPageNum, bool bSkipEmptyPages ) const;
 
 		//PageDescriptor-Schnittstelle
 	sal_uInt16 GetPageDescCnt() const { return aPageDescs.Count(); }
Index: sw/inc/unomailmerge.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/unomailmerge.hxx,v
retrieving revision 1.4
retrieving revision 1.4.12.1
diff -u -p -r1.4 -r1.4.12.1
--- sw/inc/unomailmerge.hxx	28 Jan 2005 15:26:22 -0000	1.4
+++ sw/inc/unomailmerge.hxx	18 Feb 2005 15:20:57 -0000	1.4.12.1
@@ -99,12 +99,12 @@
 #include <sfx2/objsh.hxx>   // SfxObjectShellRef
 #endif
 
-namespace com { namespace sun { namespace star { 
+namespace com { namespace sun { namespace star {
 
     namespace sdbc {
         class XResultSet;
         class XConnection;
-    }    
+    }
     namespace frame {
         class XModel;
     }
@@ -145,7 +145,7 @@ typedef cppu::OMultiTypeInterfaceContain
 
 ////////////////////////////////////////////////////////////
 
-class SwXMailMerge : 
+class SwXMailMerge :
     public cppu::WeakImplHelper5
     <
         com::sun::star::task::XJob,
@@ -182,30 +182,32 @@ class SwXMailMerge : 
     sal_Bool        bEscapeProcessing;
     sal_Bool        bSinglePrintJobs;
     sal_Bool        bFileNameFromColumn;
-    
-    
-    ::rtl::OUString                                         sInServerPassword;           
-    ::rtl::OUString                                         sOutServerPassword; 
-    ::rtl::OUString                                         sSubject;           
-    ::rtl::OUString                                         sAddressFromColumn; 
-    ::rtl::OUString                                         sMailBody;          
-    ::rtl::OUString                                         sAttachmentName;    
-    ::rtl::OUString                                         sAttachmentFilter;  
-    com::sun::star::uno::Sequence< ::rtl::OUString >        aCopiesTo;          
-    com::sun::star::uno::Sequence< ::rtl::OUString >        aBlindCopiesTo;     
-    sal_Bool                                                bSendAsHTML;        
-    sal_Bool                                                bSendAsAttachment;      
-                                          
-    com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > aPrintSettings;     
-                                          
-    sal_Bool                                                bSaveAsSingleFile;  
-    ::rtl::OUString                                         sSaveFilter;        
-        
-    
+
+
+    ::rtl::OUString                                         sInServerPassword;
+    ::rtl::OUString                                         sOutServerPassword;
+    ::rtl::OUString                                         sSubject;
+    ::rtl::OUString                                         sAddressFromColumn;
+    ::rtl::OUString                                         sMailBody;
+    ::rtl::OUString                                         sAttachmentName;
+    ::rtl::OUString                                         sAttachmentFilter;
+    com::sun::star::uno::Sequence< ::rtl::OUString >        aCopiesTo;
+    com::sun::star::uno::Sequence< ::rtl::OUString >        aBlindCopiesTo;
+    sal_Bool                                                bSendAsHTML;
+    sal_Bool                                                bSendAsAttachment;
+
+    com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > aPrintSettings;
+
+    sal_Bool                                                bSaveAsSingleFile;
+    ::rtl::OUString                                         sSaveFilter;
+    ::rtl::OUString                                         sSaveFilterOptions;
+    com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > aSaveFilterData;
+
+
 
     sal_Bool        bDisposing;
 
-    
+
     void    launchEvent( const com::sun::star::beans::PropertyChangeEvent &rEvt ) const;
 
     // disallow use of copy-constructor and assignment-operator for now
@@ -215,7 +217,7 @@ protected:
 	virtual ~SwXMailMerge();
 public:
     SwXMailMerge();
-    
+
 
     void LaunchMailMergeEvent( const com::sun::star::text::MailMergeEvent &rData ) const;
 
Index: sw/inc/unomap.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/unomap.hxx,v
retrieving revision 1.48
retrieving revision 1.48.12.1
diff -u -p -r1.48 -r1.48.12.1
--- sw/inc/unomap.hxx	28 Jan 2005 15:26:38 -0000	1.48
+++ sw/inc/unomap.hxx	18 Feb 2005 15:20:58 -0000	1.48.12.1
@@ -309,6 +309,8 @@
 #define WID_BLIND_COPIES_TO                     1097
 #define WID_IN_SERVER_PASSWORD                  1098
 #define WID_OUT_SERVER_PASSWORD                 1099
+#define WID_SAVE_FILTER_OPTIONS                 1100
+#define WID_SAVE_FILTER_DATA                    1101
 
 //AutoText
 #define WID_GROUP_PATH							0
Index: sw/inc/unoprnms.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/unoprnms.hxx,v
retrieving revision 1.104
retrieving revision 1.104.12.1
diff -u -p -r1.104 -r1.104.12.1
--- sw/inc/unoprnms.hxx	28 Jan 2005 15:26:52 -0000	1.104
+++ sw/inc/unoprnms.hxx	18 Feb 2005 15:20:58 -0000	1.104.12.1
@@ -777,11 +777,14 @@ enum SwPropNameIds
 /* 0687 */  UNO_NAME_SAVE_AS_SINGLE_FILE,
 /* 0688 */  UNO_NAME_SAVE_FILTER,
 /* 0689 */  UNO_NAME_COPIES_TO,
-/* 0890 */  UNO_NAME_BLIND_COPIES_TO,  
-/* 0891 */  UNO_NAME_IN_SERVER_PASSWORD,
-/* 0892 */  UNO_NAME_OUT_SERVER_PASSWORD,
+/* 0690 */  UNO_NAME_BLIND_COPIES_TO,
+/* 0691 */  UNO_NAME_IN_SERVER_PASSWORD,
+/* 0692 */  UNO_NAME_OUT_SERVER_PASSWORD,
+/* 0693 */  UNO_NAME_SAVE_FILTER_OPTIONS,
+/* 0694 */  UNO_NAME_SAVE_FILTER_DATA,
+
 // <--
-/* 0893 */  SW_PROPNAME_END
+/* 0695 */  SW_PROPNAME_END
 };
 
 
Index: sw/source/core/doc/doc.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/doc.cxx,v
retrieving revision 1.35
retrieving revision 1.35.88.1
diff -u -p -r1.35 -r1.35.88.1
--- sw/source/core/doc/doc.cxx	5 Jan 2005 15:59:33 -0000	1.35
+++ sw/source/core/doc/doc.cxx	18 Feb 2005 15:22:34 -0000	1.35.88.1
@@ -655,17 +655,20 @@ sal_uInt16 SwDoc::GetPageCount() const
     return GetRootFrm() ? GetRootFrm()->GetPageNum() : 0;
 }
 
-const Size SwDoc::GetPageSize( sal_uInt16 nPageNum ) const
+const Size SwDoc::GetPageSize( sal_uInt16 nPageNum, bool bSkipEmptyPages ) const
 {
     Size aSize;
     if( GetRootFrm() && nPageNum )
     {
         const SwPageFrm* pPage = static_cast<const SwPageFrm*>
                                  (GetRootFrm()->Lower());
+
         while( --nPageNum && pPage->GetNext() )
             pPage = static_cast<const SwPageFrm*>( pPage->GetNext() );
-        if( pPage->IsEmptyPage() && pPage->GetNext() )
+
+        if( !bSkipEmptyPages && pPage->IsEmptyPage() && pPage->GetNext() )
             pPage = static_cast<const SwPageFrm*>( pPage->GetNext() );
+
         aSize = pPage->Frm().SSize();
     }
     return aSize;
@@ -1149,13 +1152,17 @@ BOOL SwDoc::ConvertFieldsToText()
 {
     BOOL bRet = FALSE;
     StartUndo( UIUNDO_REPLACE );
-    
+
     const SwFldTypes* pFldTypes = GetFldTypes();
     sal_uInt16 nCount = pFldTypes->Count();
     //go backward, field types are removed
     for(sal_uInt16 nType = nCount;  nType > 0;  --nType)
     {
         const SwFieldType *pCurType = pFldTypes->GetObject(nType - 1);
+
+        if ( RES_POSTITFLD == pCurType->Which() )
+            continue;
+
         SwClientIter aIter( *(SwFieldType*)pCurType );
         const SwFmtFld* pCurFldFmt = (SwFmtFld*)aIter.First( TYPE( SwFmtFld ));
         ::std::vector<const SwFmtFld*> aFieldFmts;
@@ -1167,14 +1174,14 @@ BOOL SwDoc::ConvertFieldsToText()
         ::std::vector<const SwFmtFld*>::iterator aBegin = aFieldFmts.begin();
         ::std::vector<const SwFmtFld*>::iterator aEnd = aFieldFmts.end();
         while(aBegin != aEnd)
-        {        
+        {
             const SwTxtFld *pTxtFld = (*aBegin)->GetTxtFld();
             // skip fields that are currently not in the document
             // e.g. fields in undo or redo array
             BOOL bSkip = !pTxtFld ||
                          !pTxtFld->GetpTxtNode()->GetNodes().IsDocNodes() ||
                          IsInHeaderFooter(SwNodeIndex(*pTxtFld->GetpTxtNode(), 0));
-    
+
             if (!bSkip)
             {
                 const SwFmtFld& rFmtFld = pTxtFld->GetFld();
@@ -1194,12 +1201,12 @@ BOOL SwDoc::ConvertFieldsToText()
             ++aBegin;
         }
     }
-    
+
     if( bRet )
         SetModified();
     EndUndo( UIUNDO_REPLACE );
     return bRet;
-    
+
 }
 
 	// embedded alle lokalen Links (Bereiche/Grafiken)
Index: sw/source/core/doc/doclay.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/doclay.cxx,v
retrieving revision 1.31
retrieving revision 1.31.26.1
diff -u -p -r1.31 -r1.31.26.1
--- sw/source/core/doc/doclay.cxx	27 Jan 2005 11:10:37 -0000	1.31
+++ sw/source/core/doc/doclay.cxx	9 Feb 2005 15:21:18 -0000	1.31.26.1
@@ -1123,11 +1123,17 @@ SwDrawFrmFmt* SwDoc::Insert( const SwPaM
 										SwFmtFlyCnt( pFmt ), nStt, nStt );
 	}
 
-	new SwDrawContact( pFmt, &rDrawObj );
+    SwDrawContact* pContact = new SwDrawContact( pFmt, &rDrawObj );
 
 	// ggfs. Frames anlegen
 	if( GetRootFrm() )
+    {
 		pFmt->MakeFrms();
+        // --> OD 2005-02-09 #i42319# - follow-up of #i35635#
+        // move object to visible layer
+        pContact->MoveObjToVisibleLayer( &rDrawObj );
+        // <--
+    }
 
 	if( DoesUndo() )
 	{
Index: sw/source/core/doc/extinput.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/extinput.cxx,v
retrieving revision 1.10
retrieving revision 1.10.292.1
diff -u -p -r1.10 -r1.10.292.1
--- sw/source/core/doc/extinput.cxx	12 Aug 2004 12:17:52 -0000	1.10
+++ sw/source/core/doc/extinput.cxx	11 Feb 2005 10:16:08 -0000	1.10.292.1
@@ -129,18 +129,26 @@ SwExtTextInput::~SwExtTextInput()
 
 			// damit Undo / Redlining usw. richtig funktioniert,
 			// muss ueber die Doc-Schnittstellen gegangen werden !!!
-			SwDoc* pDoc = GetDoc();
+            SwDoc* pDoc = GetDoc();
             if(eInputLanguage != LANGUAGE_DONTKNOW)
-            {        
+            {
+                // --> FME 2005-02-11 #i41974# Only set language attribute
+                // for CJK/CTL scripts.
+                bool bLang = true;
+                // <--
                 USHORT nWhich = RES_CHRATR_LANGUAGE;
                 switch(GetI18NScriptTypeOfLanguage(eInputLanguage))
                 {
                     case  ::com::sun::star::i18n::ScriptType::ASIAN:     nWhich = RES_CHRATR_CJK_LANGUAGE; break;
                     case  ::com::sun::star::i18n::ScriptType::COMPLEX:   nWhich = RES_CHRATR_CTL_LANGUAGE; break;
-                }            
-                SvxLanguageItem aLangItem( eInputLanguage, nWhich );
-                pDoc->Insert(*this, aLangItem, 0 );
-            }            
+                    default: bLang = false;
+                }
+                if ( bLang )
+                {
+                    SvxLanguageItem aLangItem( eInputLanguage, nWhich );
+                    pDoc->Insert(*this, aLangItem, 0 );
+                }
+            }
             rIdx = nSttCnt;
 			String sTxt( pTNd->GetTxt().Copy( nSttCnt, nEndCnt - nSttCnt ));
 			if( bIsOverwriteCursor && sOverwriteText.Len() )
Index: sw/source/core/layout/layact.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/layact.cxx,v
retrieving revision 1.48
retrieving revision 1.48.34.1
diff -u -p -r1.48 -r1.48.34.1
--- sw/source/core/layout/layact.cxx	21 Jan 2005 10:35:10 -0000	1.48
+++ sw/source/core/layout/layact.cxx	15 Feb 2005 15:21:46 -0000	1.48.34.1
@@ -231,7 +231,7 @@ void SwLayAction::CheckWaitCrsr()
 //Ist es wirklich schon soweit...
 inline void SwLayAction::CheckIdleEnd()
 {
-	if ( !IsInput() )
+    if ( !IsInput() )
         bInput = GetInputType() && Application::AnyInput( GetInputType() );
 }
 
@@ -1071,7 +1071,12 @@ void SwLayAction::InternalAction()
         // OD 14.04.2003 #106346# - set flag for interrupt content formatting
         mbFormatCntntOnInterrupt = IsInput() && !IsStopPrt();
         long nBottom = rVis.Bottom();
-        while ( pPg && pPg->Frm().Top() < nBottom )
+        // --> OD 2005-02-15 #i42586# - format current page, if idle action is active
+        // This is an optimization for the case that the interrupt is created by
+        // the move of a form control object, which is represented by a window.
+        while ( pPg && ( pPg->Frm().Top() < nBottom ||
+                         ( IsIdle() && pPg == pPage ) ) )
+        // <--
 		{
             // --> OD 2004-10-11 #i26945# - follow-up of #i28701#
             NotifyLayoutOfPageInProgress aLayoutOfPageInProgress( *pPg );
Index: sw/source/core/layout/paintfrm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/paintfrm.cxx,v
retrieving revision 1.87
retrieving revision 1.87.146.1
diff -u -p -r1.87 -r1.87.146.1
--- sw/source/core/layout/paintfrm.cxx	16 Nov 2004 10:23:28 -0000	1.87
+++ sw/source/core/layout/paintfrm.cxx	15 Feb 2005 08:43:13 -0000	1.87.146.1
@@ -1870,10 +1870,38 @@ void MA_FASTCALL DrawGraphic( const SvxB
                 // calculate paint offset
                 Point aPaintOffset( aAlignedPaintRect.Pos() - aGrf.Pos() );
                 // draw background graphic tiled for aligned paint rectangle
+                // --> OD 2005-02-15 #i42643# - apply fix #104004# for Calc
+                // also for Writer - see /sc/source/view/printfun.cxx
+                // For PDF export, every draw operation for bitmaps takes a
+                // noticeable amount of place (~50 characters). Thus, optimize
+                // between tile bitmap size and number of drawing operations here.
+                //
+                //                  A_out
+                // n_chars = k1 *  ---------- + k2 * A_bitmap
+                //                  A_bitmap
+                //
+                // minimum n_chars is obtained for (derive for  A_bitmap,
+                // set to 0, take positive solution):
+                //                   k1
+                // A_bitmap = Sqrt( ---- A_out )
+                //                   k2
+                //
+                // where k1 is the number of chars per draw operation, and
+                // k2 is the number of chars per bitmap pixel.
+                // This is approximately 50 and 7 for current PDF writer, respectively.
+                //
+                const double    k1( 50 );
+                const double    k2( 7 );
+                const Size      aSize( aAlignedPaintRect.SSize() );
+                const double    Abitmap( k1/k2 * static_cast<double>(aSize.Width())*aSize.Height() );
+
                 pGraphicObj->DrawTiled( pOutDev,
                                         aAlignedPaintRect.SVRect(),
                                         aGrf.SSize(),
-                                        Size( aPaintOffset.X(), aPaintOffset.Y() ) );
+                                        Size( aPaintOffset.X(), aPaintOffset.Y() ),
+                                        NULL, GRFMGR_DRAW_STANDARD,
+                                        ::std::max( 128, static_cast<int>( sqrt(sqrt( Abitmap)) + .5 ) ) );
+                // <--
             }
             // reset clipping at output device
             pOutDev->Pop();
@@ -5675,7 +5703,7 @@ void SwLayoutFrm::PaintSubsidiaryLines( 
     SwRect aOriginal( bUseFrmArea ? Frm() : Prt() );
     if ( !bUseFrmArea )
         aOriginal.Pos() += Frm().Pos();
-    
+
     // OD 13.02.2003 #i3662# - enlarge top of column body frame's printing area
     // in sections to top of section frame.
     const bool bColBodyInSection = IsBodyFrm() &&
Index: sw/source/core/layout/tabfrm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/tabfrm.cxx,v
retrieving revision 1.71
retrieving revision 1.71.12.2
diff -u -p -r1.71 -r1.71.12.2
--- sw/source/core/layout/tabfrm.cxx	31 Jan 2005 13:56:05 -0000	1.71
+++ sw/source/core/layout/tabfrm.cxx	10 Feb 2005 10:27:32 -0000	1.71.12.2
@@ -2179,20 +2179,27 @@ void SwTabFrm::MakeAll()
                     bTryToSplit = !bSplitError;
 
                     // --> FME 2004-06-09 #i29771# Two tries to split the table:
+                    // If an error occured during splitting. We start a second
+                    // try, this time without splitting of table rows.
                     if ( bSplitError )
                     {
-                        // An error occured during splitting. We start a second
-                        // try, this time without splitting of table rows.
                         if ( HasFollowFlowLine() )
                             RemoveFollowFlowLine();
+                    }
 
-                        if ( GetFollow() && !GetFollow()->GetFirstNonHeadlineRow() )
-                            Join();
+                    // --> FME 2005-02-10 #119477#
+                    // If splitting the table was successfull or not, 
+                    // we do not want to have 'empty' follow tables.
+                    if ( GetFollow() && !GetFollow()->GetFirstNonHeadlineRow() )
+                        Join();
+                    // <--
 
-                        // We want to restore the situation before the failed
-                        // split operation as good as possible. Therefore we
-                        // do some more calculations. Note: Restricting this
-                        // to nDeadLine may not be enough.
+                    // We want to restore the situation before the failed
+                    // split operation as good as possible. Therefore we
+                    // do some more calculations. Note: Restricting this
+                    // to nDeadLine may not be enough.
+                    if ( bSplitError )
+                    {
                         ::lcl_CalcLayout( (SwLayoutFrm*)Lower(), LONG_MAX );
                         bValidPos = FALSE;
                         continue;
@@ -5049,7 +5056,7 @@ SwTwips SwTabFrm::CalcHeightOfFirstConte
     // nTmpHeight is the height of the heading row if we are a follow.
     if ( pFirstRow )
     {
-        const bool bSplittable = ((SwRowFrm*)pFirstRow)->IsRowSplitAllowed();
+        const bool bSplittable = static_cast<const SwRowFrm*>(pFirstRow)->IsRowSplitAllowed();
         const bool bDontSplit = !IsFollow() && !GetFmt()->GetLayoutSplit().GetValue();
 
         if ( bDontSplit )
@@ -5065,7 +5072,15 @@ SwTwips SwTabFrm::CalcHeightOfFirstConte
         {
             const bool bOldJoinLock = IsJoinLocked();
             ((SwTabFrm*)this)->LockJoin();
-            nTmpHeight += lcl_CalcHeightOfFirstContentLine( *(SwRowFrm*)pFirstRow );
+            const SwTwips nHeightOfFirstContentLine = lcl_CalcHeightOfFirstContentLine( *(SwRowFrm*)pFirstRow );
+        
+            // Consider minimum row height:    
+            const SwFmtFrmSize &rSz = static_cast<const SwRowFrm*>(pFirstRow)->GetFmt()->GetFrmSize();
+            const SwTwips nMinRowHeight = rSz.GetHeightSizeType() == ATT_MIN_SIZE ?
+                                          rSz.GetHeight() : 0;
+
+            nTmpHeight += Max( nHeightOfFirstContentLine, nMinRowHeight );
+
             if ( !bOldJoinLock )
                 ((SwTabFrm*)this)->UnlockJoin();
         }
Index: sw/source/core/objectpositioning/tocntntanchoredobjectposition.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/objectpositioning/tocntntanchoredobjectposition.cxx,v
retrieving revision 1.10
retrieving revision 1.10.34.1
diff -u -p -r1.10 -r1.10.34.1
--- sw/source/core/objectpositioning/tocntntanchoredobjectposition.cxx	21 Jan 2005 10:39:43 -0000	1.10
+++ sw/source/core/objectpositioning/tocntntanchoredobjectposition.cxx	7 Feb 2005 13:30:35 -0000	1.10.34.1
@@ -468,6 +468,20 @@ void SwToCntntAnchoredObjectPosition::Ca
                                       _GetTopForObjPos( rAnchorTxtFrm, fnRect, bVert ) );
             }
 
+            // --> OD 2005-02-07 #i42124# - capture object inside vertical
+            // layout environment.
+            {
+                const SwTwips nTopOfAnch =
+                                _GetTopForObjPos( *pOrientFrm, fnRect, bVert );
+                const SwLayoutFrm& rVertEnvironLayFrm =
+                    aEnvOfObj.GetVertEnvironmentLayoutFrm(
+                                            *(pOrientFrm->GetUpper()), false );
+                const bool bCheckBottom = !bFollowTextFlow;
+                nRelPosY = _AdjustVertRelPos( nTopOfAnch, bVert,
+                                              rVertEnvironLayFrm, nRelPosY,
+                                              bFollowTextFlow, bCheckBottom );
+            }
+            // <--
             // keep calculated relative vertical position - needed for filters
             // (including the xml-filter)
             {
Index: sw/source/core/text/EnhancedPDFExportHelper.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/EnhancedPDFExportHelper.cxx,v
retrieving revision 1.7
retrieving revision 1.7.34.3
diff -u -p -r1.7 -r1.7.34.3
--- sw/source/core/text/EnhancedPDFExportHelper.cxx	21 Jan 2005 10:40:16 -0000	1.7
+++ sw/source/core/text/EnhancedPDFExportHelper.cxx	18 Feb 2005 15:22:36 -0000	1.7.34.3
@@ -74,6 +74,9 @@
 #ifndef _OUTDEV_HXX
 #include <vcl/outdev.hxx>
 #endif
+#ifndef _SV_MULTISEL_HXX
+#include <tools/multisel.hxx>
+#endif
 #ifndef _SVX_ADJITEM_HXX
 #include <svx/adjitem.hxx>
 #endif
@@ -123,6 +126,9 @@
 #ifndef _FMTANCHR_HXX
 #include <fmtanchr.hxx>
 #endif
+#ifndef _FMTURL_HXX
+#include <fmturl.hxx>
+#endif
 #ifndef _EDITSH_HXX
 #include <editsh.hxx>
 #endif
@@ -138,6 +144,9 @@
 #ifndef _DOC_HXX
 #include <doc.hxx>
 #endif
+#ifndef _DOCARY_HXX
+#include <docary.hxx>
+#endif
 #ifndef _CRSSKIP_HXX
 #include <crsskip.hxx>
 #endif
@@ -159,6 +168,9 @@
 #ifndef _FMTFTN_HXX
 #include <fmtftn.hxx>
 #endif
+#ifndef _ROOTFRM_HXX
+#include <rootfrm.hxx>
+#endif
 #ifndef _PAGEFRM_HXX
 #include <pagefrm.hxx>
 #endif
@@ -1128,9 +1140,18 @@ void SwTaggedPDFHelper::BeginInlineStruc
  */
 SwEnhancedPDFExportHelper::SwEnhancedPDFExportHelper( SwEditShell& rSh,
                                                       OutputDevice& rOut,
+                                                      const rtl::OUString& rPageRange,
+                                                      bool bSkipEmptyPages,
                                                       bool bEditEngineOnly )
-    : mrSh( rSh ), mrOut( rOut )
+    : mrSh( rSh ),
+      mrOut( rOut ),
+      pPageRange( 0 ),
+      mbSkipEmptyPages( bSkipEmptyPages ),
+      mbEditEngineOnly( bEditEngineOnly )
 {
+    if ( rPageRange.getLength() )
+        pPageRange = new MultiSelection( rPageRange );
+
     aLinkIdMap.clear();
     aFrmTagIdMap.clear();
 
@@ -1138,14 +1159,18 @@ SwEnhancedPDFExportHelper::SwEnhancedPDF
     aStructStack.clear();
 #endif
 
-    EnhancedPDFExport( bEditEngineOnly );
+    EnhancedPDFExport();
 }
 
+SwEnhancedPDFExportHelper::~SwEnhancedPDFExportHelper()
+{
+    delete pPageRange;
+}
 
 /*
  * SwEnhancedPDFExportHelper::EnhancedPDFExport()
  */
-void SwEnhancedPDFExportHelper::EnhancedPDFExport( bool bEditEngineOnly )
+void SwEnhancedPDFExportHelper::EnhancedPDFExport()
 {
     vcl::PDFExtOutDevData* pPDFExtOutDevData =
         PTR_CAST( vcl::PDFExtOutDevData, mrOut.GetExtOutDevData() );
@@ -1170,7 +1195,7 @@ void SwEnhancedPDFExportHelper::Enhanced
     const BOOL bOldLockView = mrSh.IsViewLocked();
     mrSh.LockView( TRUE );
 
-    if ( !bEditEngineOnly )
+    if ( !mbEditEngineOnly )
     {
         //
         // POSTITS
@@ -1196,38 +1221,38 @@ void SwEnhancedPDFExportHelper::Enhanced
                           mrSh.GotoFld( *(SwFmtFld*)pFirst ) &&
                          !mrSh.SelectHiddenRange() )
                     {
-
-                        // Link Note
-                        vcl::PDFNote aNote;
-
-                        // Use the NumberFormatter to get the date string:
-                        const SwPostItField* pField = (SwPostItField*)((SwFmtFld*)pFirst)->GetFld();
-                        SvNumberFormatter* pNumFormatter = pDoc->GetNumberFormatter();
-                        const Date aDateDiff( pField->GetDate() -
-                                             *pNumFormatter->GetNullDate() );
-                        const ULONG nFormat =
-                            pNumFormatter->GetStandardFormat( NUMBERFORMAT_DATE, pField->GetLanguage() );
-                        String sDate;
-                        Color* pColor;
-                        pNumFormatter->GetOutputString( aDateDiff.GetDate(), nFormat, sDate, &pColor );
-
-                        // The title should consist of the author and the date:
-                        String sTitle( pField->GetPar1() );
-                        sTitle.AppendAscii( RTL_CONSTASCII_STRINGPARAM( ", " ) );
-                        sTitle += sDate;
-                        aNote.Title = sTitle;
-                        // Guess what the contents contains...
-                        aNote.Contents = pField->GetTxt();
-
                         // Link Rectangle
                         const SwRect& rNoteRect = mrSh.GetCharRect();
 
                         // Link PageNum
-                        const sal_Int32 nPageNum =
-                            mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rNoteRect );
+                        const sal_Int32 nNotePageNum = CalcOutputPageNum( rNoteRect );
+                        if ( -1 != nNotePageNum )
+                        {
+                            // Link Note
+                            vcl::PDFNote aNote;
+
+                            // Use the NumberFormatter to get the date string:
+                            const SwPostItField* pField = (SwPostItField*)((SwFmtFld*)pFirst)->GetFld();
+                            SvNumberFormatter* pNumFormatter = pDoc->GetNumberFormatter();
+                            const Date aDateDiff( pField->GetDate() -
+                                                 *pNumFormatter->GetNullDate() );
+                            const ULONG nFormat =
+                                pNumFormatter->GetStandardFormat( NUMBERFORMAT_DATE, pField->GetLanguage() );
+                            String sDate;
+                            Color* pColor;
+                            pNumFormatter->GetOutputString( aDateDiff.GetDate(), nFormat, sDate, &pColor );
+
+                            // The title should consist of the author and the date:
+                            String sTitle( pField->GetPar1() );
+                            sTitle.AppendAscii( RTL_CONSTASCII_STRINGPARAM( ", " ) );
+                            sTitle += sDate;
+                            aNote.Title = sTitle;
+                            // Guess what the contents contains...
+                            aNote.Contents = pField->GetTxt();
 
-                        // Link Export
-                        pPDFExtOutDevData->CreateNote( rNoteRect.SVRect(), aNote, nPageNum );
+                            // Link Export
+                            pPDFExtOutDevData->CreateNote( rNoteRect.SVRect(), aNote, nNotePageNum );
+                        }
                     }
                 }
                 pFirst = aIter++;
@@ -1280,7 +1305,7 @@ void SwEnhancedPDFExportHelper::Enhanced
                     ASSERT( aTmp.Count() > 0, "Enhanced pdf export - rectangles are missing" )
 
                     // Create the destination for internal links:
-                    sal_Int32 nDestId = 0;
+                    sal_Int32 nDestId = -1;
                     if ( bIntern )
                     {
                         aURL.Erase( 0, 1 );
@@ -1291,31 +1316,95 @@ void SwEnhancedPDFExportHelper::Enhanced
                         const SwRect& rDestRect = mrSh.GetCharRect();
 
                         // Destination PageNum
-                        const sal_Int32 nDestPageNum =
-                            mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rDestRect );
+                        const sal_Int32 nDestPageNum = CalcOutputPageNum( rDestRect );
 
                         // Destination Export
-                        nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
+                        if ( -1 != nDestPageNum )
+                            nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
                     }
 
-                    // Create links for all selected rectangles:
-                    const USHORT nNumOfRects = aTmp.Count();
-                    for ( int i = 0; i < nNumOfRects; ++i )
+                    if ( !bIntern || -1 != nDestId )
                     {
-                        // Link Rectangle
-                        const SwRect& rLinkRect( aTmp[ i ] );
+                        // Create links for all selected rectangles:
+                        const USHORT nNumOfRects = aTmp.Count();
+                        for ( int i = 0; i < nNumOfRects; ++i )
+                        {
+                            // Link Rectangle
+                            const SwRect& rLinkRect( aTmp[ i ] );
 
-                        // Link PageNum
-                        const sal_Int32 nLinkPageNum =
-                            mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rLinkRect );
+                            // Link PageNum
+                            const sal_Int32 nLinkPageNum = CalcOutputPageNum( rLinkRect );
 
-                        // Link Export
-                        const sal_Int32 nLinkId =
-                            pPDFExtOutDevData->CreateLink( rLinkRect.SVRect(), nLinkPageNum );
+                            if ( -1 != nLinkPageNum )
+                            {
+                                // Link Export
+                                const sal_Int32 nLinkId =
+                                    pPDFExtOutDevData->CreateLink( rLinkRect.SVRect(), nLinkPageNum );
+
+                                // Store link info for tagged pdf output:
+                                const IdMapEntry aLinkEntry( rLinkRect, nLinkId );
+                                aLinkIdMap.push_back( aLinkEntry );
+
+                                // Connect Link and Destination:
+                                if ( bIntern )
+                                    pPDFExtOutDevData->SetLinkDest( nLinkId, nDestId );
+                                else
+                                    pPDFExtOutDevData->SetLinkURL( nLinkId, aURL );
+                            }
+                        }
+                    }
+                }
+            }
+            mrSh.SwCrsrShell::ClearMark();
+        }
+
+        //
+        // HYPERLINKS (Graphics, Frames, OLEs )
+        //
+        const SwSpzFrmFmts* pTbl = pDoc->GetSpzFrmFmts();
+        const sal_uInt16 nSpzFrmFmtsCount = pTbl->Count();
+        for( sal_uInt16 n = 0; n < nSpzFrmFmtsCount; ++n )
+        {
+            const SwFrmFmt* pFrmFmt = (*pTbl)[n];
+            const SfxPoolItem* pItem;
+            if ( RES_DRAWFRMFMT != pFrmFmt->Which() &&
+                 SFX_ITEM_SET == pFrmFmt->GetAttrSet().GetItemState( RES_URL, TRUE, &pItem ) )
+            {
+                String aURL( static_cast<const SwFmtURL*>(pItem)->GetURL() );
+                const bool bIntern = '#' == aURL.GetChar( 0 );
+
+                // Create the destination for internal links:
+                sal_Int32 nDestId = -1;
+                if ( bIntern )
+                {
+                    aURL.Erase( 0, 1 );
+                    mrSh.SwCrsrShell::ClearMark();
+                    JumpToSwMark( &mrSh, aURL );
+
+                    // Destination Rectangle
+                    const SwRect& rDestRect = mrSh.GetCharRect();
 
-                        // Store link info for tagged pdf output:
-                        const IdMapEntry aLinkEntry( rLinkRect, nLinkId );
-                        aLinkIdMap.push_back( aLinkEntry );
+                    // Destination PageNum
+                    const sal_Int32 nDestPageNum = CalcOutputPageNum( rDestRect );
+
+                    // Destination Export
+                    if ( -1 != nDestPageNum )
+                        nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
+                }
+
+                if ( !bIntern || -1 != nDestId )
+                {
+                    Point aNullPt;
+                    const SwRect aLinkRect = pFrmFmt->FindLayoutRect( sal_False, &aNullPt );
+
+                    // Link PageNum
+                    const sal_Int32 nLinkPageNum = CalcOutputPageNum( aLinkRect );
+
+                    // Link Export
+                    if ( -1 != nLinkPageNum )
+                    {
+                        const sal_Int32 nLinkId =
+                            pPDFExtOutDevData->CreateLink( aLinkRect.SVRect(), nLinkPageNum );
 
                         // Connect Link and Destination:
                         if ( bIntern )
@@ -1369,33 +1458,37 @@ void SwEnhancedPDFExportHelper::Enhanced
                     const SwRect& rDestRect = mrSh.GetCharRect();
 
                     // Destination PageNum
-                    const sal_Int32 nDestPageNum =
-                        mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rDestRect );
-
-                    // Destination Export
-                    const sal_Int32 nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
+                    const sal_Int32 nDestPageNum = CalcOutputPageNum( rDestRect );
 
-                    // Create links for all selected rectangles:
-                    const USHORT nNumOfRects = aTmp.Count();
-                    for ( int i = 0; i < nNumOfRects; ++i )
+                    if ( -1 != nDestPageNum )
                     {
-                        // Link rectangle
-                        const SwRect& rLinkRect( aTmp[ i ] );
-
-                        // Link PageNum
-                        const sal_Int32 nLinkPageNum =
-                            mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rLinkRect );
+                        // Destination Export
+                        const sal_Int32 nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
 
-                        // Link Export
-                        const sal_Int32 nLinkId =
-                            pPDFExtOutDevData->CreateLink( rLinkRect.SVRect(), nLinkPageNum );
+                        // Create links for all selected rectangles:
+                        const USHORT nNumOfRects = aTmp.Count();
+                        for ( int i = 0; i < nNumOfRects; ++i )
+                        {
+                            // Link rectangle
+                            const SwRect& rLinkRect( aTmp[ i ] );
 
-                        // Store link info for tagged pdf output:
-                        const IdMapEntry aLinkEntry( rLinkRect, nLinkId );
-                        aLinkIdMap.push_back( aLinkEntry );
+                            // Link PageNum
+                            const sal_Int32 nLinkPageNum = CalcOutputPageNum( rLinkRect );
 
-                        // Connect Link and Destination:
-                        pPDFExtOutDevData->SetLinkDest( nLinkId, nDestId );
+                            if ( -1 != nLinkPageNum )
+                            {
+                                // Link Export
+                                const sal_Int32 nLinkId =
+                                    pPDFExtOutDevData->CreateLink( rLinkRect.SVRect(), nLinkPageNum );
+
+                                // Store link info for tagged pdf output:
+                                const IdMapEntry aLinkEntry( rLinkRect, nLinkId );
+                                aLinkIdMap.push_back( aLinkEntry );
+
+                                // Connect Link and Destination:
+                                pPDFExtOutDevData->SetLinkDest( nLinkId, nDestId );
+                            }
+                        }
                     }
                 }
             }
@@ -1441,29 +1534,33 @@ void SwEnhancedPDFExportHelper::Enhanced
             if ( mrSh.GotoFtnTxt() )
             {
                 // Link PageNum
-                const sal_Int32 nLinkPageNum =
-                    mrSh.GetPageNumAndSetOffsetForPDF( mrOut, aLinkRect );
+                const sal_Int32 nLinkPageNum = CalcOutputPageNum( aLinkRect );
 
-                // Link Export
-                const sal_Int32 nLinkId =
-                    pPDFExtOutDevData->CreateLink( aLinkRect.SVRect(), nLinkPageNum );
-
-                // Store link info for tagged pdf output:
-                const IdMapEntry aLinkEntry( aLinkRect, nLinkId );
-                aLinkIdMap.push_back( aLinkEntry );
+                if ( -1 != nLinkPageNum )
+                {
+                    // Link Export
+                    const sal_Int32 nLinkId =
+                        pPDFExtOutDevData->CreateLink( aLinkRect.SVRect(), nLinkPageNum );
+
+                    // Store link info for tagged pdf output:
+                    const IdMapEntry aLinkEntry( aLinkRect, nLinkId );
+                    aLinkIdMap.push_back( aLinkEntry );
 
-                // Destination Rectangle
-                const SwRect& rDestRect = mrSh.GetCharRect();
+                    // Destination Rectangle
+                    const SwRect& rDestRect = mrSh.GetCharRect();
 
-                // Destination PageNum
-                const sal_Int32 nDestPageNum =
-                     mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rDestRect );
+                    // Destination PageNum
+                    const sal_Int32 nDestPageNum = CalcOutputPageNum( rDestRect );
 
-                // Destination Export
-                const sal_Int32 nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
+                    if ( -1 != nDestPageNum )
+                    {
+                        // Destination Export
+                        const sal_Int32 nDestId = pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
 
-                // Connect Link and Destination:
-                pPDFExtOutDevData->SetLinkDest( nLinkId, nDestId );
+                        // Connect Link and Destination:
+                        pPDFExtOutDevData->SetLinkDest( nLinkId, nDestId );
+                    }
+                }
             }
         }
 
@@ -1503,22 +1600,24 @@ void SwEnhancedPDFExportHelper::Enhanced
             const SwRect& rDestRect = mrSh.GetCharRect();
 
             // Destination PageNum
-            const sal_Int32 nDestPageNum =
-                mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rDestRect );
+            const sal_Int32 nDestPageNum = CalcOutputPageNum( rDestRect );
 
-            // Destination Export
-            const sal_Int32 nDestId =
-                pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
-
-            // Outline entry text
-            const String& rEntry = mrSh.GetOutlineText( i );
-
-            // Create a new outline item:
-            const sal_Int32 nOutlineId =
-                pPDFExtOutDevData->CreateOutlineItem( nParent, rEntry, nDestId );
+            if ( -1 != nDestPageNum )
+            {
+                // Destination Export
+                const sal_Int32 nDestId =
+                    pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
+
+                // Outline entry text
+                const String& rEntry = mrSh.GetOutlineText( i );
+
+                // Create a new outline item:
+                const sal_Int32 nOutlineId =
+                    pPDFExtOutDevData->CreateOutlineItem( nParent, rEntry, nDestId );
 
-            // Push current level and nOutlineId on stack:
-            aOutlineStack.push( StackEntry( nLevel, nOutlineId ) );
+                // Push current level and nOutlineId on stack:
+                aOutlineStack.push( StackEntry( nLevel, nOutlineId ) );
+            }
         }
     }
     else
@@ -1542,15 +1641,17 @@ void SwEnhancedPDFExportHelper::Enhanced
                 const SwRect& rDestRect = mrSh.GetCharRect();
 
                 // Destination PageNum
-                const sal_Int32 nDestPageNum =
-                    mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rDestRect );
+                const sal_Int32 nDestPageNum = CalcOutputPageNum( rDestRect );
 
-                // Destination Export
-                const sal_Int32 nDestId =
-                    pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
+                if ( -1 != nDestPageNum )
+                {
+                    // Destination Export
+                    const sal_Int32 nDestId =
+                        pPDFExtOutDevData->CreateDest( rDestRect.SVRect(), nDestPageNum );
 
-                // Connect Link and Destination:
-                pPDFExtOutDevData->SetLinkDest( aIBeg->nLinkId, nDestId );
+                    // Connect Link and Destination:
+                    pPDFExtOutDevData->SetLinkDest( aIBeg->nLinkId, nDestId );
+                }
             }
             else
                 pPDFExtOutDevData->SetLinkURL( aIBeg->nLinkId, aBookmarkName );
@@ -1564,4 +1665,40 @@ void SwEnhancedPDFExportHelper::Enhanced
     mrSh.LockView( bOldLockView );
     mrSh.SwCrsrShell::Pop( FALSE );
     mrOut.Pop();
+}
+
+/*
+ * SwEnhancedPDFExportHelper::CalcOutputPageNum()
+ */
+sal_Int32 SwEnhancedPDFExportHelper::CalcOutputPageNum( const SwRect& rRect )
+{
+    // Document page numbers are 0, 1, 2, ...
+    const sal_Int32 nPageNumOfRect = mrSh.GetPageNumAndSetOffsetForPDF( mrOut, rRect );
+
+    // Shortcut:
+    if ( -1 == nPageNumOfRect || ( !pPageRange && !mbSkipEmptyPages ) )
+        return nPageNumOfRect;
+
+    // pPageRange page numbers are 1, 2, 3, ...
+    if ( pPageRange && !pPageRange->IsSelected( nPageNumOfRect + 1 ) )
+        return -1;
+
+    // What will be the page number of page nPageNumOfRect in the output doc?
+    sal_Int32 nOutputPageNum = -1;
+    const SwRootFrm* pRootFrm = mrSh.GetLayout();
+    const SwPageFrm* pCurrPage = static_cast<const SwPageFrm*>(pRootFrm->Lower());
+
+    for ( sal_Int32 nPageIndex = 0;
+          nPageIndex <= nPageNumOfRect && pCurrPage;
+          ++nPageIndex )
+    {
+        if ( ( !pPageRange || pPageRange->IsSelected( nPageIndex + 1 ) ) &&
+             ( !mbSkipEmptyPages || !pCurrPage->IsEmptyPage() ) )
+            ++nOutputPageNum;
+
+        pCurrPage = static_cast<const SwPageFrm*>(pCurrPage->GetNext());
+    }
+
+    // pdf export page numbers are 0, 1, 2, ...
+    return nOutputPageNum;
 }
Index: sw/source/core/text/itrform2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itrform2.cxx,v
retrieving revision 1.90
retrieving revision 1.90.88.1
diff -u -p -r1.90 -r1.90.88.1
--- sw/source/core/text/itrform2.cxx	5 Jan 2005 14:31:10 -0000	1.90
+++ sw/source/core/text/itrform2.cxx	14 Feb 2005 13:41:31 -0000	1.90.88.1
@@ -1263,8 +1263,13 @@ SwLinePortion *SwTxtFormatter::NewPortio
 
 	if( !pPor )
 	{
-        if( !pMulti || pMulti->IsBidi() )
-		{   // We open a multiportion part, if we enter a multi-line part
+        if( ( !pMulti || pMulti->IsBidi() ) &&
+            // --> FME 2005-02-14 #i42734#
+            // No multi portion if there is a hook character waiting:
+            ( !rInf.GetRest() || '\0' == rInf.GetHookChar() ) )
+            // <--
+        {
+            // We open a multiportion part, if we enter a multi-line part
 			// of the paragraph.
         	xub_StrLen nEnd = rInf.GetIdx();
             SwMultiCreator* pCreate = rInf.GetMultiCreator( nEnd, pMulti );
Index: sw/source/core/text/makefile.mk
===================================================================
RCS file: /cvs/sw/sw/source/core/text/makefile.mk,v
retrieving revision 1.10
retrieving revision 1.10.274.1
diff -u -p -r1.10 -r1.10.274.1
--- sw/source/core/text/makefile.mk	8 Sep 2004 16:12:13 -0000	1.10
+++ sw/source/core/text/makefile.mk	7 Feb 2005 16:05:49 -0000	1.10.274.1
@@ -73,8 +73,6 @@ AUTOSEG=true
 .INCLUDE :  settings.mk
 .INCLUDE :  $(PRJ)$/inc$/sw.mk
 
-INCEXT=s:\solar\inc\hm
-
 .IF "$(mydebug)" != ""
 CDEFS+=-Dmydebug
 .ENDIF
Index: sw/source/core/text/porfld.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/porfld.cxx,v
retrieving revision 1.47
retrieving revision 1.47.272.1
diff -u -p -r1.47 -r1.47.272.1
--- sw/source/core/text/porfld.cxx	20 Sep 2004 15:15:01 -0000	1.47
+++ sw/source/core/text/porfld.cxx	14 Feb 2005 13:41:31 -0000	1.47.272.1
@@ -322,7 +322,9 @@ void SwFldPortion::CheckScript( const Sw
 
         // #i16354# Change script type for RTL text to CTL.
         const SwScriptInfo& rSI = rInf.GetParaPortion()->GetScriptInfo();
-        const BYTE nFldDir = rSI.DirType( IsFollow() ? rInf.GetIdx() - 1 : rInf.GetIdx() );
+        const BYTE nFldDir = IsNumberPortion() ?
+                             rSI.GetDefaultDir() :
+                             rSI.DirType( IsFollow() ? rInf.GetIdx() - 1 : rInf.GetIdx() );
         if ( UBIDI_RTL == nFldDir )
         {
             UErrorCode nError = U_ZERO_ERROR;
@@ -361,24 +363,22 @@ sal_Bool SwFldPortion::Format( SwTxtForm
         SwLayoutModeModifier aLayoutModeModifier( *rInf.GetOut() );
         aLayoutModeModifier.SetAuto();
 
+        // Field portion has to be split in several parts if
+        // 1. There are script/direction changes inside the field
+        // 2. There are portion breaks (tab, break) inside the field:
 		const xub_StrLen nOldFullLen = rInf.GetLen();
-		const MSHORT nFollow = IsFollow() ? 0 : 1;
-		xub_StrLen nFullLen;
-
-        // Look for portion breaks (special characters like tab, break...)
-        nFullLen = rInf.ScanPortionEnd( rInf.GetIdx(),
-                   rInf.GetIdx() + nOldFullLen ) - rInf.GetIdx();
-		if( nFullLen && CH_BREAK == aExpand.GetChar( nFullLen - 1 ) )
-			--nFullLen;
+        xub_StrLen nFullLen = rInf.ScanPortionEnd( rInf.GetIdx(), rInf.GetIdx() + nOldFullLen ) - rInf.GetIdx();
+        if ( nNextScriptChg < nFullLen )
+        {
+            nFullLen = nNextScriptChg;
+            rInf.SetHookChar( 0 );
+        }
+		rInf.SetLen( nFullLen );
 
         if ( STRING_LEN != rInf.GetUnderScorePos() &&
              rInf.GetUnderScorePos() > rInf.GetIdx() )
              rInf.SetUnderScorePos( rInf.GetIdx() );
 
-        // field portion has to break if script changes
-        nFullLen = Min( nFullLen, nNextScriptChg );
-
-		rInf.SetLen( nFullLen );
 		if( pFnt )
 			pFnt->GoMagic( rInf.GetVsh(), pFnt->GetActual() );
 
@@ -388,6 +388,7 @@ sal_Bool SwFldPortion::Format( SwTxtForm
 		// gesetzt und wird in nRest uebertragen. Ansonsten bleibt die
 		// Laenge erhalten und wuerde auch in nRest einfliessen!
 		SetLen(0);
+   		const MSHORT nFollow = IsFollow() ? 0 : 1;
 
 		// So komisch es aussieht, die Abfrage auf GetLen() muss wegen der
 		// ExpandPortions _hinter_ aDiffTxt (vgl. SoftHyphs)
Index: sw/source/core/unocore/unofield.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unofield.cxx,v
retrieving revision 1.86
retrieving revision 1.86.140.1
diff -u -p -r1.86 -r1.86.140.1
--- sw/source/core/unocore/unofield.cxx	27 Nov 2004 09:01:50 -0000	1.86
+++ sw/source/core/unocore/unofield.cxx	8 Feb 2005 06:50:26 -0000	1.86.140.1
@@ -752,7 +752,7 @@ void SwXFieldMaster::setPropertyValue( c
             // nothing special to be done here for the properties
             // UNO_NAME_DATA_BASE_NAME, UNO_NAME_DATA_BASE_URL and
             // UNO_NAME_DATA_BASE_RESOURCE.
-            // We just call PutValue (empty string is allowed). 
+            // We just call PutValue (empty string is allowed).
             // Thus the last property set will be used as Data Source.
 
             BYTE nMId = GetFieldTypeMId( rPropertyName, *pType  );
@@ -858,7 +858,7 @@ void SwXFieldMaster::setPropertyValue( c
             if(rPropertyName.equalsAsciiL( SW_PROP_NAME(UNO_NAME_DATA_BASE_RESOURCE)))
                 ::GetString( rValue, sParam6 );
 
-            if((sParam1.Len() || sParam5.Len() || sParam6.Len()) 
+            if((sParam1.Len() || sParam5.Len() || sParam6.Len())
                     && sParam2.Len() && sParam3.Len())
                 GetFldType();
 			break;
@@ -1024,7 +1024,7 @@ uno::Any SwXFieldMaster::getPropertyValu
                     }
                     if (pStr)
                         aRet <<= *pStr;
-                }            
+                }
             }
             else
         		throw UnknownPropertyException(OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Unknown property: " ) ) + rPropertyName, static_cast < cppu::OWeakObject * > ( this ) );
@@ -2583,26 +2583,10 @@ sal_uInt16 lcl_GetIdByName( String& rNam
 		nResId = RES_DDEFLD;
 	else if(rTypeName.EqualsAscii("SetExpression"))
 	{
-        // build indices do access programmatic names
-        static sal_uInt16 nIds[] =
-        {
-            RES_POOLCOLL_LABEL_DRAWING  - RES_POOLCOLL_EXTRA_BEGIN,
-            RES_POOLCOLL_LABEL_ABB      - RES_POOLCOLL_EXTRA_BEGIN,
-            RES_POOLCOLL_LABEL_TABLE    - RES_POOLCOLL_EXTRA_BEGIN,
-            RES_POOLCOLL_LABEL_FRAME    - RES_POOLCOLL_EXTRA_BEGIN,
-            0
-        };
-        const SvStringsDtor& rExtraArr = SwStyleNameMapper::GetExtraProgNameArray();
-
 		nResId = RES_SETEXPFLD;
 
         String sFldTypName( rName.GetToken( 1, '.' ));
-        String sUIName( sFldTypName );
-        if (*rExtraArr[ nIds[0] ] == sUIName ||
-            *rExtraArr[ nIds[1] ] == sUIName ||
-            *rExtraArr[ nIds[2] ] == sUIName ||
-            *rExtraArr[ nIds[3] ] == sUIName)
-            sUIName = SwStyleNameMapper::GetUIName( sFldTypName, GET_POOLID_TXTCOLL );
+        String sUIName( SwStyleNameMapper::GetSpecialExtraUIName( sFldTypName ) );
 
 		if( sUIName != sFldTypName )
 			rName.SetToken( 1, '.', sUIName );
@@ -2672,8 +2656,7 @@ sal_Bool SwXTextFieldMasters::getInstanc
 	case RES_SETEXPFLD:
 		rName.AppendAscii( RTL_CONSTASCII_STRINGPARAM( COM_TEXT_FLDMASTER ));
 		rName.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "SetExpression."));
-		rName += String(SwStyleNameMapper::GetProgName( rFldType.GetName(),
-														GET_POOLID_TXTCOLL ));
+        rName += String( SwStyleNameMapper::GetSpecialExtraProgName( rFldType.GetName() ) );
 		break;
 
 	case RES_DBFLD:
Index: sw/source/core/unocore/unomap.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unomap.cxx,v
retrieving revision 1.171
retrieving revision 1.171.12.1
diff -u -p -r1.171 -r1.171.12.1
--- sw/source/core/unocore/unomap.cxx	28 Jan 2005 15:27:22 -0000	1.171
+++ sw/source/core/unocore/unomap.cxx	18 Feb 2005 15:22:38 -0000	1.171.12.1
@@ -2363,16 +2363,18 @@ const SfxItemPropertyMap* SwUnoPropertyM
                     { SW_PROP_NMID(UNO_NAME_SINGLE_PRINT_JOBS),     WID_SINGLE_PRINT_JOBS,      CPPU_E2T(CPPUTYPE_BOOLEAN),     PROPERTY_NONE, 0},
                     { SW_PROP_NMID(UNO_NAME_FILE_NAME_FROM_COLUMN), WID_FILE_NAME_FROM_COLUMN,  CPPU_E2T(CPPUTYPE_BOOLEAN),     PROPERTY_NONE, 0},
                     { SW_PROP_NMID(UNO_NAME_FILE_NAME_PREFIX),      WID_FILE_NAME_PREFIX,       CPPU_E2T(CPPUTYPE_OUSTRING),    PROPERTY_NONE, 0},
-                    { SW_PROP_NMID(UNO_NAME_SUBJECT),               WID_MAIL_SUBJECT,           CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},          
-                    { SW_PROP_NMID(UNO_NAME_ADDRESS_FROM_COLUMN),   WID_ADDRESS_FROM_COLUMN,    CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_SEND_AS_HTML),          WID_SEND_AS_HTML,           CPPU_E2T(CPPUTYPE_BOOLEAN),         PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_SEND_AS_ATTACHMENT),    WID_SEND_AS_ATTACHMENT,     CPPU_E2T(CPPUTYPE_BOOLEAN),         PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_MAIL_BODY),             WID_MAIL_BODY,              CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_ATTACHMENT_NAME),       WID_ATTACHMENT_NAME,        CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_ATTACHMENT_FILTER),     WID_ATTACHMENT_FILTER,      CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_PRINT_OPTIONS),         WID_PRINT_OPTIONS,          CPPU_E2T(CPPUTYPE_PROPERTYVALUES),  PROPERTY_NONE, 0},     
-                    { SW_PROP_NMID(UNO_NAME_SAVE_AS_SINGLE_FILE),   WID_SAVE_AS_SINGLE_FILE,    CPPU_E2T(CPPUTYPE_BOOLEAN),         PROPERTY_NONE, 0}, 
-                    { SW_PROP_NMID(UNO_NAME_SAVE_FILTER),           WID_SAVE_FILTER,            CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0}, 
+                    { SW_PROP_NMID(UNO_NAME_SUBJECT),               WID_MAIL_SUBJECT,           CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_ADDRESS_FROM_COLUMN),   WID_ADDRESS_FROM_COLUMN,    CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_SEND_AS_HTML),          WID_SEND_AS_HTML,           CPPU_E2T(CPPUTYPE_BOOLEAN),         PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_SEND_AS_ATTACHMENT),    WID_SEND_AS_ATTACHMENT,     CPPU_E2T(CPPUTYPE_BOOLEAN),         PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_MAIL_BODY),             WID_MAIL_BODY,              CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_ATTACHMENT_NAME),       WID_ATTACHMENT_NAME,        CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_ATTACHMENT_FILTER),     WID_ATTACHMENT_FILTER,      CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_PRINT_OPTIONS),         WID_PRINT_OPTIONS,          CPPU_E2T(CPPUTYPE_PROPERTYVALUES),  PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_SAVE_AS_SINGLE_FILE),   WID_SAVE_AS_SINGLE_FILE,    CPPU_E2T(CPPUTYPE_BOOLEAN),         PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_SAVE_FILTER),           WID_SAVE_FILTER,            CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_SAVE_FILTER_OPTIONS),   WID_SAVE_FILTER_OPTIONS,    CPPU_E2T(CPPUTYPE_OUSTRING),        PROPERTY_NONE, 0},
+                    { SW_PROP_NMID(UNO_NAME_SAVE_FILTER_DATA),      WID_SAVE_FILTER_DATA,       CPPU_E2T(CPPUTYPE_PROPERTYVALUES),        PROPERTY_NONE, 0},
                     { SW_PROP_NMID(UNO_NAME_COPIES_TO),             WID_COPIES_TO,              CPPU_E2T(CPPUTYPE_OUSTRINGS),       PROPERTY_NONE, 0},
                     { SW_PROP_NMID(UNO_NAME_BLIND_COPIES_TO),       WID_BLIND_COPIES_TO,        CPPU_E2T(CPPUTYPE_OUSTRINGS),       PROPERTY_NONE, 0},
                     { SW_PROP_NMID(UNO_NAME_IN_SERVER_PASSWORD),     WID_IN_SERVER_PASSWORD,     CPPU_E2T(CPPUTYPE_OUSTRING),    PROPERTY_NONE, 0},
Index: sw/source/core/unocore/unoprnms.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unoprnms.cxx,v
retrieving revision 1.108
retrieving revision 1.108.12.1
diff -u -p -r1.108 -r1.108.12.1
--- sw/source/core/unocore/unoprnms.cxx	28 Jan 2005 15:27:40 -0000	1.108
+++ sw/source/core/unocore/unoprnms.cxx	18 Feb 2005 15:22:39 -0000	1.108.12.1
@@ -768,10 +768,12 @@ const SwPropNameTab aPropNameTab = {
 /* 0686 UNO_NAME_PRINT_OPTIONS      */  {MAP_CHAR_LEN("PrintOptions")},
 /* 0687 UNO_NAME_SAVE_AS_SINGLE_FILE */  {MAP_CHAR_LEN("SaveAsSingleFile")},
 /* 0688 UNO_NAME_SAVE_FILTER         */  {MAP_CHAR_LEN("SaveFilter")},
-/* 0689 UNO_NAME_COPIES_TO           */  {MAP_CHAR_LEN("CopiesTo")},       
-/* 0890 UNO_NAME_BLIND_COPIES_TO     */  {MAP_CHAR_LEN("BlindCopiesTo")},
-/* 0891 UNO_NAME_IN_SERVER_PASSWORD  */  {MAP_CHAR_LEN("InServerPassword")},
-/* 0892 UNO_NAME_OUT_SERVER_PASSWORD */  {MAP_CHAR_LEN("OutServerPassword")}
+/* 0689 UNO_NAME_COPIES_TO           */  {MAP_CHAR_LEN("CopiesTo")},
+/* 0690 UNO_NAME_BLIND_COPIES_TO     */  {MAP_CHAR_LEN("BlindCopiesTo")},
+/* 0691 UNO_NAME_IN_SERVER_PASSWORD  */  {MAP_CHAR_LEN("InServerPassword")},
+/* 0692 UNO_NAME_OUT_SERVER_PASSWORD */  {MAP_CHAR_LEN("OutServerPassword")},
+/* 0693 UNO_NAME_SAVE_FILTER         */  {MAP_CHAR_LEN("SaveFilterOptions")},
+/* 0694 UNO_NAME_SAVE_DATA           */  {MAP_CHAR_LEN("SaveFilterData")}
 };
 
 const SwPropNameLen& SwGetPropName( USHORT nId )
Index: sw/source/core/view/viewsh.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/view/viewsh.cxx,v
retrieving revision 1.58
retrieving revision 1.58.34.2
diff -u -p -r1.58 -r1.58.34.2
--- sw/source/core/view/viewsh.cxx	21 Jan 2005 10:42:30 -0000	1.58
+++ sw/source/core/view/viewsh.cxx	18 Feb 2005 15:22:40 -0000	1.58.34.2
@@ -2404,21 +2404,30 @@ String ViewShell::GetMarkListDescription
 sal_Int32 ViewShell::GetPageNumAndSetOffsetForPDF( OutputDevice& rOut, const SwRect& rRect ) const
 {
     ASSERT( GetLayout(), "GetPageNumAndSetOffsetForPDF assumes presence of layout" )
+
+    sal_Int32 nRet = -1;
+
     // --> FME 2005-01-07 #i40059# Position out of bounds:
     SwRect aRect( rRect );
     aRect.Pos().X() = Max( aRect.Left(), DOCUMENTBORDER );
     // <--
+
     const SwPageFrm* pPage = GetLayout()->GetPageAtPos( aRect.Center() );
-    ASSERT( pPage, "GetPageNumAndSetOffsetForPDF: No page found" )
+    if ( pPage )
+    {
+        ASSERT( pPage, "GetPageNumAndSetOffsetForPDF: No page found" )
+
+        Point aOffset( pPage->Frm().Pos() );
+        aOffset.X() = -aOffset.X();
+        aOffset.Y() = -aOffset.Y();
 
-    Point aOffset( pPage->Frm().Pos() );
-    aOffset.X() = -aOffset.X();
-    aOffset.Y() = -aOffset.Y();
+        MapMode aMapMode( rOut.GetMapMode() );
+        aMapMode.SetOrigin( aOffset );
+        rOut.SetMapMode( aMapMode );
 
-    MapMode aMapMode( rOut.GetMapMode() );
-    aMapMode.SetOrigin( aOffset );
-    rOut.SetMapMode( aMapMode );
+        nRet = pPage->GetPhyPageNum() - 1;
+    }
 
-    return pPage->GetPhyPageNum() - 1;
+    return nRet;
 }
 // <--
Index: sw/source/core/view/vprint.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/view/vprint.cxx,v
retrieving revision 1.31
retrieving revision 1.31.12.1
diff -u -p -r1.31 -r1.31.12.1
--- sw/source/core/view/vprint.cxx	31 Jan 2005 09:06:21 -0000	1.31
+++ sw/source/core/view/vprint.cxx	10 Feb 2005 15:15:56 -0000	1.31.12.1
@@ -1604,8 +1604,15 @@ void ViewShell::PrtOle2( SwDoc *pDoc, co
 			pDoc->GetRootFrm()->Lower()->InvalidateSize();
 		}
 
+        // --> FME 2005-02-10 #119474#
+        // CalcPagesForPrint() should not be necessary here. The pages in the
+        // visible area will be formatted in SwRootFrm::Paint().
+        // Removing this gives us a performance gain during saving the
+        // document because the thumbnail creation will not trigger a complete
+        // formatting of the document.
 		// Seiten fuers Drucken formatieren
-		pSh->CalcPagesForPrint( SHRT_MAX );
+        // pSh->CalcPagesForPrint( SHRT_MAX );
+        // <--
 
 		//#39275# jetzt will der Meyer doch ein Clipping
 		pOleOut->Push( PUSH_CLIPREGION );
Index: sw/source/filter/ww8/ww8graf.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8graf.cxx,v
retrieving revision 1.128
retrieving revision 1.128.64.1
diff -u -p -r1.128 -r1.128.64.1
--- sw/source/filter/ww8/ww8graf.cxx	11 Jan 2005 13:26:10 -0000	1.128
+++ sw/source/filter/ww8/ww8graf.cxx	7 Feb 2005 11:15:32 -0000	1.128.64.1
@@ -2409,10 +2409,6 @@ RndStdIds SwWW8ImplReader::ProcessEscher
     UINT32 nXRelTo = nCntRelTo > pRecord->nXRelTo ? pRecord->nXRelTo : 1;
     UINT32 nYRelTo = nCntRelTo > pRecord->nYRelTo ? pRecord->nYRelTo : 1;
 
-    //Drawing layer stuff that is not going to be replaced as a fly,
-    //ideally we will be able to remove this special check.
-    bool bDrawingHacks = (!bOrgObjectWasReplace && !pRecord->bReplaceByFly);
-
     RndStdIds eAnchor = FLY_AUTO_CNTNT;
     SwFmtAnchor aAnchor( eAnchor );
 	aAnchor.SetAnchor( pPaM->GetPoint() );
@@ -2516,8 +2512,9 @@ RndStdIds SwWW8ImplReader::ProcessEscher
             pFSPA->nXaLeft = 0;
         }
 
-        //#109311# Miserable miserable hack.
-        if (!bDrawingHacks)
+        // --> OD 2005-02-07 #i24255# - position of floating screen objects in
+        // R2L layout are given in L2R layout, thus convert them of all
+        // floating screen objects, which are imported.
         {
             //#109311# Miserable miserable hack.
             long nWidth = (pFSPA->nXaRight - pFSPA->nXaLeft);
@@ -2527,6 +2524,7 @@ RndStdIds SwWW8ImplReader::ProcessEscher
                 pFSPA->nXaRight = pFSPA->nXaLeft + nWidth;
             }
         }
+        // <--
 
         SwFmtHoriOrient aHoriOri(MakeSafePositioningValue(pFSPA->nXaLeft),
             eHoriOri, eHoriRel);
@@ -2794,8 +2792,8 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLaye
     // If we are to be "below text" then we are not to be opaque
     // #i14045# MM If we are in a header or footer then make the object transparent
     // Not exactly like word but close enough for now
-    if ( (pF->bBelowText || pRecord->bDrawHell) || 
-         ( ( bIsHeader || bIsFooter ) && pF->nwr == 3 ) ) 
+    if ( (pF->bBelowText || pRecord->bDrawHell) ||
+         ( ( bIsHeader || bIsFooter ) && pF->nwr == 3 ) )
         aFlySet.Put(SvxOpaqueItem(RES_OPAQUE,false));
 
     SwFrmFmt* pRetFrmFmt = 0;
@@ -2895,6 +2893,14 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLaye
         }
     }
 
+    // --> OD 2005-02-07 #i24255# - position of floating screen object is
+    // given in the layout direction of its anchor.
+    if ( pRetFrmFmt )
+    {
+        pRetFrmFmt->SetPositionLayoutDir(
+            com::sun::star::text::PositionLayoutDir::PositionInLayoutDirOfAnchor );
+    }
+    // <--
     if (!IsInlineEscherHack())
         MapWrapIntoFlyFmt(pRecord, pRetFrmFmt);
     return AddAutoAnchor(pRetFrmFmt);
Index: sw/source/ui/app/docshini.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/app/docshini.cxx,v
retrieving revision 1.48
retrieving revision 1.48.66.1
diff -u -p -r1.48 -r1.48.66.1
--- sw/source/ui/app/docshini.cxx	11 Jan 2005 12:38:51 -0000	1.48
+++ sw/source/ui/app/docshini.cxx	10 Feb 2005 10:04:28 -0000	1.48.66.1
@@ -487,6 +487,12 @@ sal_Bool SwDocShell::InitNew( const uno:
     pDoc->SetDefault( SfxBoolItem( RES_COLLAPSING_BORDERS, TRUE ) );
 // <-- collapsing
 
+    // --> OD 2005-02-10 #i42080# - Due to the several calls of method <SetDefault(..)>
+    // at the document instance, the document is modified. Thus, reset this
+    // status here. Note: In method <SubInitNew()> this is also done.
+    pDoc->ResetModified();
+    // <--
+
 	return bRet;
 }
 
Index: sw/source/ui/dbui/dbmgr.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/dbui/dbmgr.cxx,v
retrieving revision 1.88
retrieving revision 1.88.12.1
diff -u -p -r1.88 -r1.88.12.1
--- sw/source/ui/dbui/dbmgr.cxx	28 Jan 2005 15:47:46 -0000	1.88
+++ sw/source/ui/dbui/dbmgr.cxx	18 Feb 2005 15:22:41 -0000	1.88.12.1
@@ -439,7 +439,7 @@ struct SwNewDBMgr_Impl
        ,pMergeDialog(0)
        ,xDisposeListener(new SwConnectionDisposedListener_Impl(rDBMgr))
         {}
-};   
+};
 /*-- 24.10.2003 15:54:18---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -648,7 +648,7 @@ BOOL SwNewDBMgr::MergeNew(const SwMergeD
         {
             SwView& rView = rMergeDesc.rSh.GetView();
             SfxDispatcher *pDis = rView.GetViewFrame()->GetDispatcher();
-            SfxItemSet aPrintArgs( rView.GetPool(), 
+            SfxItemSet aPrintArgs( rView.GetPool(),
                     SID_SILENT, SID_SILENT, //5528
                     SID_ASYNCHRON, SID_ASYNCHRON, //5811
                     SID_PRINT_FIRST_PAGE, SID_PRINT_FIRST_PAGE,  //   5001
@@ -659,7 +659,7 @@ BOOL SwNewDBMgr::MergeNew(const SwMergeD
                     SID_FILE_NAME,        SID_FILE_NAME,         // 5507
                     SID_PRINT_PAGES,      SID_PRINT_PAGES,      //6589
                     SID_PRINT_COLLATE,    SID_PRINT_COLLATE,    //6590
-                    FN_QRY_MERGE, FN_QRY_MERGE, 
+                    FN_QRY_MERGE, FN_QRY_MERGE,
                     0 );
             aPrintArgs.Put(SfxBoolItem(FN_QRY_MERGE, TRUE) );
 
@@ -669,7 +669,7 @@ BOOL SwNewDBMgr::MergeNew(const SwMergeD
             // !! Therefore it has to be the 0 pointer when not silent.
             if(IsMergeSilent())
                 aPrintArgs.Put( SfxBoolItem(SID_SILENT, TRUE) );
-            // #i25686# printing should be done asynchronously to prevent dangling offices 
+            // #i25686# printing should be done asynchronously to prevent dangling offices
             // when mail merge is called as command line macro
             aPrintArgs.Put( SfxBoolItem( SID_ASYNCHRON, rMergeDesc.bPrintAsync ));
             // convert PropertyValues
@@ -678,36 +678,36 @@ BOOL SwNewDBMgr::MergeNew(const SwMergeD
             {
                 if( pPrintOptions[nOption].Name.equalsAscii( "CopyCount" ))
                 {
-                    sal_Int16 nCopies; 
+                    sal_Int16 nCopies;
                     if((pPrintOptions[nOption].Value >>= nCopies) && nCopies > 0)
                         aPrintArgs.Put( SfxInt16Item( SID_PRINT_COPIES, nCopies ));
-                }            
+                }
                 else if( pPrintOptions[nOption].Name.equalsAscii( "FileName" ))
                 {
                     ::rtl::OUString sFileName;
                     if( (pPrintOptions[nOption].Value >>= sFileName) && sFileName.getLength() > 0)
-                        aPrintArgs.Put( SfxStringItem( SID_FILE_NAME, sFileName ));        
-                }            
+                        aPrintArgs.Put( SfxStringItem( SID_FILE_NAME, sFileName ));
+                }
                 else if( pPrintOptions[nOption].Name.equalsAscii( "Collate" ))
                 {
                     sal_Bool bCollate;
                     if( pPrintOptions[nOption].Value >>= bCollate )
                         aPrintArgs.Put( SfxBoolItem( SID_PRINT_COLLATE, bCollate ));
-                }            
+                }
                 else if( pPrintOptions[nOption].Name.equalsAscii( "Pages" ))
                 {
                     ::rtl::OUString sPages;
                     if( (pPrintOptions[nOption].Value >>= sPages) && sPages.getLength() )
                         aPrintArgs.Put( SfxStringItem( SID_PRINT_PAGES, sPages ));
-                }            
+                }
                 else if( pPrintOptions[nOption].Name.equalsAscii( "Wait" ))
                 {
                     sal_Bool bWait;
                     if( pPrintOptions[nOption].Value >>= bWait )
                         aPrintArgs.Put( SfxBoolItem( SID_ASYNCHRON, !bWait ));
-                }            
-                
-            }            
+                }
+
+            }
             pDis->Execute( SID_PRINTDOC,
                                  SFX_CALLMODE_SYNCHRON|SFX_CALLMODE_RECORD,
                                  aPrintArgs );
@@ -717,8 +717,8 @@ BOOL SwNewDBMgr::MergeNew(const SwMergeD
 		case DBMGR_MERGE_MAILING:
         case DBMGR_MERGE_MAILFILES:
             // save files and send them as e-Mail if required
-            bRet = MergeMailFiles(&rMergeDesc.rSh, 
-                    rMergeDesc); 
+            bRet = MergeMailFiles(&rMergeDesc.rSh,
+                    rMergeDesc);
 			break;
 
 		default:    	// Einfuegen der selektierten Eintraege
@@ -1198,7 +1198,7 @@ BOOL SwNewDBMgr::MergePrint( SwView& rVi
 /*-- 21.06.2004 09:08:16---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-BOOL SwNewDBMgr::MergePrintDocuments( SwView& rView, 
+BOOL SwNewDBMgr::MergePrintDocuments( SwView& rView,
                                 SwPrtOptions& rOpt, SfxProgress& rProgress )
 {
     SwWrtShell* pSh = &rView.GetWrtShell();
@@ -1256,7 +1256,7 @@ BOOL SwNewDBMgr::MergePrintDocuments( Sw
     DBG_ASSERT(pConfigItem, "mail merge config item is missing")
     if(!pConfigItem)
         return sal_False;
-    
+
     USHORT nDocStart = pConfigItem->GetPrintRangeStart();
     USHORT nDocEnd = pConfigItem->GetPrintRangeEnd();
     DBG_ASSERT(nDocStart < nDocEnd && nDocEnd <= pConfigItem->GetMergedDocumentCount(),
@@ -1343,14 +1343,14 @@ BOOL SwNewDBMgr::MergePrintDocuments( Sw
 	Beschreibung:	Serienbriefe als einzelne Dokumente speichern
  --------------------------------------------------------------------*/
 
-BOOL SwNewDBMgr::MergeMailFiles(SwWrtShell* pSourceShell, 
+BOOL SwNewDBMgr::MergeMailFiles(SwWrtShell* pSourceShell,
         const SwMergeDescriptor& rMergeDescriptor)
 {
 	//check if the doc is synchronized and contains at least one linked section
     BOOL bSynchronizedDoc = pSourceShell->IsLabelDoc() && pSourceShell->GetSectionFmtCount() > 1;
 	BOOL bLoop = TRUE;
     BOOL bEMail = rMergeDescriptor.nMergeType == DBMGR_MERGE_MAILING;
-    
+
     ::rtl::Reference< MailDispatcher >          xMailDispatcher;
     ::rtl::OUString sBodyMimeType;
     rtl_TextEncoding eEncoding = ::gsl_getSystemTextEncoding();
@@ -1361,15 +1361,15 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
         if(!rMergeDescriptor.bSendAsAttachment && rMergeDescriptor.bSendAsHTML)
         {
             sBodyMimeType = ::rtl::OUString::createFromAscii("text/html; charset=");
-            sBodyMimeType += ::rtl::OUString::createFromAscii( 
+            sBodyMimeType += ::rtl::OUString::createFromAscii(
                                 rtl_getBestMimeCharsetFromTextEncoding( eEncoding ));
             SvxHtmlOptions* pHtmlOptions = SvxHtmlOptions::Get();
             eEncoding = pHtmlOptions->GetTextEncoding();
         }
         else
-            sBodyMimeType =  
-                ::rtl::OUString::createFromAscii("text/plain; charset=UTF-8; format=flowed"); 
-    }            
+            sBodyMimeType =
+                ::rtl::OUString::createFromAscii("text/plain; charset=UTF-8; format=flowed");
+    }
 
     uno::Reference< XPropertySet > xColumnProp;
 	{
@@ -1396,21 +1396,26 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
             String sSourceDocumentURL(pOrig->GetURLObject().GetMainURL( INetURLObject::NO_DECODE ));
 			const SfxFilter* pSfxFlt = SwIoSystem::GetFileFilter(
                                                     sSourceDocumentURL, ::aEmptyStr );
-            const SfxFilter* pStoreToFilter = pSfxFlt;                        
+            const SfxFilter* pStoreToFilter = pSfxFlt;
             SfxFilterContainer* pFilterContainer = SwDocShell::Factory().GetFilterContainer();
+            const String* pStoreToFilterOptions = 0;
             // if a save_to filter is set then use it - otherwise use the default
             if( bEMail && !rMergeDescriptor.bSendAsAttachment )
             {
-                String sExtension( String::CreateFromAscii( 
+                String sExtension( String::CreateFromAscii(
                         rMergeDescriptor.bSendAsHTML ? "html" : "txt" ));
                 pStoreToFilter = pFilterContainer->GetFilter4Extension(sExtension, SFX_FILTER_EXPORT);
-            }            
+            }
             else if( rMergeDescriptor.sSaveToFilter.Len())
             {
-                const SfxFilter* pFilter = 
+                const SfxFilter* pFilter =
                         pFilterContainer->GetFilter4FilterName( rMergeDescriptor.sSaveToFilter );
                 if(pFilter)
+                {
                     pStoreToFilter = pFilter;
+                    if(rMergeDescriptor.sSaveToFilterOptions.Len())
+                        pStoreToFilterOptions = &rMergeDescriptor.sSaveToFilterOptions;
+                }
             }
             String sAddress;
 			bCancel = FALSE;
@@ -1422,7 +1427,7 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
             String sStartingPageDesc;
             USHORT nStartingPageNo = 0;
             if(rMergeDescriptor.bCreateSingleFile)
-            {    
+            {
                 // create a target docshell to put the merged document into
                 xTargetDocShell = new SwDocShell( SFX_CREATE_MODE_STANDARD );
                 xTargetDocShell->DoInitNew( 0 );
@@ -1440,15 +1445,15 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                 aOpt.SetPageDescs( sal_True );
                 aOpt.SetNumRules( sal_True );
                 aOpt.SetMerge( sal_False );
-                pTargetView->GetDocShell()->LoadStylesFromFile( 
+                pTargetView->GetDocShell()->LoadStylesFromFile(
                         sSourceDocumentURL, aOpt, sal_True );
                 //determine the page style and number used at the start of the source document
                 pSourceShell->SwCrsrShell::SttDoc();
                 nStartingPageNo = pSourceShell->GetVirtPageNum();
-                sStartingPageDesc = pSourceShell->GetPageDesc( 
+                sStartingPageDesc = pSourceShell->GetPageDesc(
                                             pSourceShell->GetCurPageDesc()).GetName();
             }
-            
+
             PrintMonitor aPrtMonDlg(&pSourceShell->GetView().GetEditWin());
             aPrtMonDlg.aDocName.SetText(pSourceShell->GetView().GetDocShell()->GetTitle(22));
 
@@ -1471,7 +1476,7 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
 			ULONG nCounter = 0;
 
             long nStartRow, nEndRow;
-            // collect temporary files 
+            // collect temporary files
             ::std::vector< String> aFilesToRemove;
             do
             {
@@ -1500,9 +1505,9 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                         sPath = aEntry.GetMainURL( INetURLObject::NO_DECODE );
                         String sExt( pStoreToFilter->GetDefaultExtension() );
                         sExt.EraseLeadingChars('*');
-                        aTempFile = std::auto_ptr< utl::TempFile >( 
+                        aTempFile = std::auto_ptr< utl::TempFile >(
                                 new utl::TempFile(sLeading,&sExt,&sPath ));
-                    }            
+                    }
 
                     if( !aTempFile->IsValid() )
 					{
@@ -1533,7 +1538,7 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                             //create a view frame for the document
                             SfxViewFrame* pWorkFrame = SFX_APP()->CreateViewFrame( *xWorkDocSh, 0, TRUE );
                             //request the layout calculation
-                            SwWrtShell& rWorkShell = 
+                            SwWrtShell& rWorkShell =
                                     static_cast< SwView* >(pWorkFrame->GetViewShell())->GetWrtShell();
                             rWorkShell.CalcLayout();
                             SwDoc* pWorkDoc = ((SwDocShell*)(&xWorkDocSh))->GetDoc();
@@ -1558,7 +1563,7 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                                 DBG_ASSERT( pTargetShell, "no target shell available!" )
                                 // copy created file into the target document
                                 rWorkShell.ConvertFieldsToText();
-    
+
                                 // insert the document into the target document
                                 rWorkShell.SwCrsrShell::EndDoc();
                                 rWorkShell.SwCrsrShell::SttDoc();
@@ -1578,6 +1583,13 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                                     sFileURL,
                                     STREAM_STD_READWRITE, TRUE );
                                 pDstMed->SetFilter( pStoreToFilter );
+                                if(pDstMed->GetItemSet())
+                                {
+                                    if(pStoreToFilterOptions )
+                                        pDstMed->GetItemSet()->Put(SfxStringItem(SID_FILE_FILTEROPTIONS, *pStoreToFilterOptions));
+                                    if(rMergeDescriptor.aSaveToFilterData.getLength())
+                                        pDstMed->GetItemSet()->Put(SfxUsrAnyItem(SID_FILTER_DATA, makeAny(rMergeDescriptor.aSaveToFilterData)));
+                                }
 
                                 xWorkDocSh->DoSaveAs(*pDstMed);
                                 xWorkDocSh->DoSaveCompleted(pDstMed);
@@ -1599,9 +1611,9 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                                         DBG_ERROR("invalid e-Mail address in database column")
                                     }
                                     else
-                                    {        
+                                    {
                                         SwMailMessage* pMessage = 0;
-                                        uno::Reference< mail::XMailMessage > xMessage = 
+                                        uno::Reference< mail::XMailMessage > xMessage =
                                                                 pMessage = new SwMailMessage;
                                         if(rMergeDescriptor.pMailMergeConfigItem->IsMailReplyTo())
                                             pMessage->setReplyToAddress(rMergeDescriptor.pMailMergeConfigItem->GetMailReplyTo());
@@ -1612,22 +1624,22 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                                         {
                                             sBody = rMergeDescriptor.sMailBody;
                                             mail::MailAttachment aAttach;
-                                            aAttach.Data = new SwMailTransferable( 
-                                                    sFileURL, 
-                                                    rMergeDescriptor.sAttachmentName, 
+                                            aAttach.Data = new SwMailTransferable(
+                                                    sFileURL,
+                                                    rMergeDescriptor.sAttachmentName,
                                                     pStoreToFilter->GetMimeType());
                                             aAttach.ReadableName = rMergeDescriptor.sAttachmentName;
-                                            pMessage->addAttachment( aAttach ); 
+                                            pMessage->addAttachment( aAttach );
                                         }
                                         else
                                         {
                                             {
-                                                //read in the temporary file and use it as mail body 
+                                                //read in the temporary file and use it as mail body
                                                 SfxMedium aMedium( sFileURL, STREAM_READ, TRUE);
                                                 SvStream* pInStream = aMedium.GetInStream();
                                                 DBG_ASSERT(pInStream, "no output file created?")
                                                 if(pInStream)
-                                                {        
+                                                {
                                                     pInStream->SetStreamCharSet( eEncoding );
                                                     ByteString sLine;
                                                     sal_Bool bDone = pInStream->ReadLine( sLine );
@@ -1641,20 +1653,20 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                                             }
                                         }
                                         pMessage->setSubject( rMergeDescriptor.sSubject );
-                                        uno::Reference< datatransfer::XTransferable> xBody = 
+                                        uno::Reference< datatransfer::XTransferable> xBody =
                                                     new SwMailTransferable(
-                                                        sBody, 
+                                                        sBody,
                                                         sBodyMimeType);
                                         pMessage->setBody( xBody );
-            
+
                                         if(rMergeDescriptor.aCopiesTo.getLength())
-                                        {        
+                                        {
                                             const ::rtl::OUString* pCopies = rMergeDescriptor.aCopiesTo.getConstArray();
                                             for( sal_Int32 nToken = 0; nToken < rMergeDescriptor.aCopiesTo.getLength(); ++nToken)
                                                 pMessage->addCcRecipient( pCopies[nToken] );
                                         }
                                         if(rMergeDescriptor.aBlindCopiesTo.getLength())
-                                        {        
+                                        {
                                             const ::rtl::OUString* pCopies = rMergeDescriptor.aBlindCopiesTo.getConstArray();
                                             for( sal_Int32 nToken = 0; nToken < rMergeDescriptor.aBlindCopiesTo.getLength(); ++nToken)
                                                 pMessage->addBccRecipient( pCopies[nToken] );
@@ -1665,8 +1677,8 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                                         //schedule for removal
                                         aFilesToRemove.push_back(sFileURL);
                                     }
-                                }            
-                            }            
+                                }
+                            }
                             pWorkDoc->SetNewDBMgr( pOldDBMgr );
 						}
                         xWorkDocSh->DoClose();
@@ -1679,12 +1691,19 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
             // save the single output document
             if(rMergeDescriptor.bCreateSingleFile)
             {
-                DBG_ASSERT( aTempFile.get(), "Temporary file not available" ) 
+                DBG_ASSERT( aTempFile.get(), "Temporary file not available" )
                 INetURLObject aTempFileURL(aTempFile->GetURL());
                 SfxMedium* pDstMed = new SfxMedium(
                     aTempFileURL.GetMainURL( INetURLObject::NO_DECODE ),
                     STREAM_STD_READWRITE, TRUE );
                 pDstMed->SetFilter( pStoreToFilter );
+                if(pDstMed->GetItemSet())
+                {
+                    if(pStoreToFilterOptions )
+                        pDstMed->GetItemSet()->Put(SfxStringItem(SID_FILE_FILTEROPTIONS, *pStoreToFilterOptions));
+                    if(rMergeDescriptor.aSaveToFilterData.getLength())
+                        pDstMed->GetItemSet()->Put(SfxUsrAnyItem(SID_FILTER_DATA, makeAny(rMergeDescriptor.aSaveToFilterData)));
+                }
 
                 xTargetDocShell->DoSaveAs(*pDstMed);
                 xTargetDocShell->DoSaveCompleted(pDstMed);
@@ -1695,14 +1714,14 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
                     bLoop = FALSE;
                 }
                 xTargetDocShell->DoClose();
-            }    
+            }
 
             //remove the temporary files
             ::std::vector<String>::iterator aFileIter;
-            for(aFileIter = aFilesToRemove.begin(); 
+            for(aFileIter = aFilesToRemove.begin();
                         aFileIter != aFilesToRemove.end(); aFileIter++)
                 SWUnoHelper::UCB_DeleteFile( *aFileIter );
-            
+
             // Alle Dispatcher freigeben
 			pViewFrm = SfxViewFrame::GetFirst(pDocSh);
 			while (pViewFrm)
@@ -1721,9 +1740,9 @@ BOOL SwNewDBMgr::MergeMailFiles(SwWrtShe
     {
         xMailDispatcher->stop();
         xMailDispatcher->shutdown();
-        
-    }            
-    
+
+    }
+
     return bLoop;
 }
 
@@ -1947,7 +1966,7 @@ uno::Reference< sdbcx::XColumnsSupplier>
 {
     Reference< sdbcx::XColumnsSupplier> xRet;
     try
-    {        
+    {
         if(eTableOrQuery == SW_DB_SELECT_UNKNOWN)
         {
             //search for a table with the given command name
@@ -1955,24 +1974,24 @@ uno::Reference< sdbcx::XColumnsSupplier>
             if(xTSupplier.is())
             {
                 Reference<XNameAccess> xTbls = xTSupplier->getTables();
-                eTableOrQuery = xTbls->hasByName(rTableOrQuery) ? 
+                eTableOrQuery = xTbls->hasByName(rTableOrQuery) ?
                             SW_DB_SELECT_TABLE : SW_DB_SELECT_QUERY;
             }
-        }            
+        }
         sal_Int32 nCommandType = SW_DB_SELECT_TABLE == eTableOrQuery ?
                 CommandType::TABLE : CommandType::QUERY;
         Reference< XMultiServiceFactory > xMgr( ::comphelper::getProcessServiceFactory() );
-        Reference<XRowSet> xRowSet( 
+        Reference<XRowSet> xRowSet(
                 xMgr->createInstance(C2U("com.sun.star.sdb.RowSet")), UNO_QUERY);
 
         ::rtl::OUString sDataSource;
         Reference<XDataSource> xSource = SwNewDBMgr::getDataSourceAsParent(xConnection, sDataSource);
         Reference<XPropertySet> xSourceProperties(xSource, UNO_QUERY);
         if(xSourceProperties.is())
-        {        
+        {
             xSourceProperties->getPropertyValue(C2U("Name")) >>= sDataSource;
-        }            
-    
+        }
+
         Reference<XPropertySet> xRowProperties(xRowSet, UNO_QUERY);
         xRowProperties->setPropertyValue(C2U("DataSourceName"), makeAny(sDataSource));
         xRowProperties->setPropertyValue(C2U("Command"), makeAny(::rtl::OUString(rTableOrQuery)));
@@ -1986,8 +2005,8 @@ uno::Reference< sdbcx::XColumnsSupplier>
     {
         rEx;
         DBG_ERROR("Exception in SwDBMgr::GetColumnSupplier")
-    }        
-    
+    }
+
     return xRet;
 }
 /* -----------------------------05.07.00 13:44--------------------------------
@@ -2608,9 +2627,9 @@ String SwNewDBMgr::LoadAndRegisterDataSo
 
     String sHomePath(SvtPathOptions().GetWorkPath());
     aDlgHelper.SetDisplayDirectory( sHomePath );
-    
+
     Reference<XFilterManager> xFltMgr(xFP, UNO_QUERY);
-    
+
     String sFilterAll(SW_RES(STR_FILTER_ALL));
     String sFilterAllData(SW_RES(STR_FILTER_ALL_DATA));
     String sFilterSXB(SW_RES(STR_FILTER_SXB));
@@ -2622,7 +2641,7 @@ String SwNewDBMgr::LoadAndRegisterDataSo
 
     xFltMgr->appendFilter( sFilterAll, C2U("*") );
     xFltMgr->appendFilter( sFilterAllData, C2U("*.ods;*.sxc;*.dbf;*.xls;*.txt;*.csv"));
-            
+
     xFltMgr->appendFilter( sFilterSXB, C2U("*.odb") );
     xFltMgr->appendFilter( sFilterSXC, C2U("*.sxc") );
     xFltMgr->appendFilter( sFilterDBF, C2U("*.dbf") );
@@ -2633,7 +2652,7 @@ String SwNewDBMgr::LoadAndRegisterDataSo
     xFltMgr->setCurrentFilter( sFilterAll ) ;
     String sFind;
     if( ERRCODE_NONE == aDlgHelper.Execute() )
-    {        
+    {
         String sURL = xFP->getFiles().getConstArray()[0];
         //data sources have to be registered depending on their extensions
         INetURLObject aURL( sURL );
@@ -2647,8 +2666,8 @@ String SwNewDBMgr::LoadAndRegisterDataSo
         {
             bStore = false;
         }
-        else if(sExt.EqualsAscii("sxc") 
-            || sExt.EqualsAscii("ods") 
+        else if(sExt.EqualsAscii("sxc")
+            || sExt.EqualsAscii("ods")
                 || sExt.EqualsAscii("xls"))
         {
             rtl::OUString sDBURL(C2U("sdbc:calc:"));
@@ -2676,13 +2695,13 @@ String SwNewDBMgr::LoadAndRegisterDataSo
             //only the 'path' has to be added
             sDBURL += aTempURL.GetMainURL(INetURLObject::NO_DECODE);
             aURLAny <<= sDBURL;
-        
+
             //set the filter to the file name without extension
             Sequence<rtl::OUString> aFilters(1);
             rtl::OUString sTmp(aURL.getBase());
             aFilters[0] = aURL.getBase();
             aTableFilterAny <<= aFilters;
-        
+
             Sequence<PropertyValue> aInfo(5);
             PropertyValue* pInfo = aInfo.getArray();
             pInfo[0].Name = C2U("FieldDelimiter");
@@ -2698,7 +2717,7 @@ String SwNewDBMgr::LoadAndRegisterDataSo
             aInfoAny <<= aInfo;
         }
         try
-        {        
+        {
             Reference< XMultiServiceFactory > xMgr( ::comphelper::getProcessServiceFactory() );
             Reference<XInterface> xInstance = xMgr->createInstance( C2U( "com.sun.star.sdb.DatabaseContext" ));
             Reference<XNameAccess> xDBContext(xInstance, UNO_QUERY_THROW);
@@ -2708,7 +2727,7 @@ String SwNewDBMgr::LoadAndRegisterDataSo
 													 INET_HEX_ESCAPE,
 													 INetURLObject::DECODE_UNAMBIGUOUS,
 													 RTL_TEXTENCODING_UTF8 );
-            xub_StrLen nExtLen = aURL.GetExtension().getLength(); 
+            xub_StrLen nExtLen = aURL.GetExtension().getLength();
             sNewName.Erase( sNewName.Len() - nExtLen - 1, nExtLen + 1 );
 
             //find a unique name if sNewName already exists
@@ -2719,16 +2738,16 @@ String SwNewDBMgr::LoadAndRegisterDataSo
                 sFind = sNewName;
                 sFind += String::CreateFromInt32(++nIndex);
             }
-            
+
             Reference<XInterface> xNewInstance;
             if(!bStore)
             {
                 //odb-file
                 Any aDataSource = xDBContext->getByName(aTempURL.GetMainURL(INetURLObject::NO_DECODE));
                 aDataSource >>= xNewInstance;
-            }            
+            }
             else
-            {        
+            {
                 xNewInstance = xFact->createInstance();
                 Reference<XPropertySet> xDataProperties(xNewInstance, UNO_QUERY);
 
@@ -2751,15 +2770,15 @@ String SwNewDBMgr::LoadAndRegisterDataSo
             }
             Reference<XNamingService> xNaming(xDBContext, UNO_QUERY);
             xNaming->registerObject( sFind, xNewInstance );
-            
+
         }
         catch(Exception& rEx)
         {
             rEx; // make compiler happy
-        }    
+        }
     }
     return sFind;
-    
+
 }
 /* -----------------------------10.11.00 17:10--------------------------------
 
@@ -2889,7 +2908,7 @@ void SwNewDBMgr::InsertText(SwWrtShell& 
 //CHINA001	aDBData );
 	SwAbstractDialogFactory* pFact = SwAbstractDialogFactory::Create();//CHINA001
 	DBG_ASSERT(pFact, "SwAbstractDialogFactory fail!");//CHINA001
-			
+
 	AbstractSwInsertDBColAutoPilot* pDlg = pFact->CreateSwInsertDBColAutoPilot( rSh.GetView(),
 																				xSource,
 																				xColSupp,
@@ -2998,13 +3017,13 @@ uno::Reference<XResultSet> SwNewDBMgr::c
     merge all data into one resulting document and return the number of
     merged documents
   -----------------------------------------------------------------------*/
-sal_Int32 SwNewDBMgr::MergeDocuments( SwMailMergeConfigItem& rMMConfig, 
+sal_Int32 SwNewDBMgr::MergeDocuments( SwMailMergeConfigItem& rMMConfig,
                             SwView& rSourceView )
 {
     // check the availability of all data in the config item
     uno::Reference< XResultSet> xResultSet = rMMConfig.GetResultSet();
     if(!xResultSet.is())
-        return false;   
+        return false;
 	bInMerge = TRUE;
     sal_Int32 nRet  = 0;
     pImpl->pMergeData = new SwDSParam(
@@ -3048,14 +3067,14 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
         for( USHORT i = 0; i < 25; i++)
             Application::Reschedule();
     }
-    
+
     SwWrtShell& rSourceShell = rSourceView.GetWrtShell();
     BOOL bSynchronizedDoc = rSourceShell.IsLabelDoc() && rSourceShell.GetSectionFmtCount() > 1;
     String sSourceDocURL;
-    //save the settings of the first 
+    //save the settings of the first
     rSourceShell.SwCrsrShell::SttDoc();
     USHORT nStartingPageNo = rSourceShell.GetVirtPageNum();
-    String sStartingPageDesc = rSourceShell.GetPageDesc( 
+    String sStartingPageDesc = rSourceShell.GetPageDesc(
                                 rSourceShell.GetCurPageDesc()).GetName();
 
     try
@@ -3070,19 +3089,19 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
                 SwDocShell::Factory().GetFilterContainer() );
 
         SfxStringItem aFilterName( SID_FILTER_NAME, pSfxFlt->GetFilterName());
-        rSourceView.GetViewFrame()->GetDispatcher()->Execute( 
+        rSourceView.GetViewFrame()->GetDispatcher()->Execute(
                             SID_EXPORTDOC, SFX_CALLMODE_SYNCHRON, &aURL, &aFilterName, 0);
-    
+
         // create a target docshell to put the merged document into
         SfxObjectShellRef xTargetDocShell( new SwDocShell( SFX_CREATE_MODE_STANDARD ) );
         xTargetDocShell->DoInitNew( 0 );
         SfxViewFrame* pTargetFrame = SFX_APP()->CreateViewFrame( *xTargetDocShell, 0, TRUE );
-        
+
         //the created window has to be located at the same position as the source window
         Window& rTargetWindow = pTargetFrame->GetFrame()->GetWindow();
         Window& rSourceWindow = rSourceView.GetViewFrame()->GetFrame()->GetWindow();
         rTargetWindow.SetPosPixel(rSourceWindow.GetPosPixel());
-        
+
 //        pTargetFrame->GetFrame()->Appear();
         SwView* pTargetView = static_cast<SwView*>( pTargetFrame->GetViewShell() );
         rMMConfig.SetTargetView(pTargetView);
@@ -3096,10 +3115,10 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
         aOpt.SetPageDescs( sal_True );
         aOpt.SetNumRules( sal_True );
         aOpt.SetMerge( sal_False );
-        pTargetView->GetDocShell()->LoadStylesFromFile( 
+        pTargetView->GetDocShell()->LoadStylesFromFile(
                 sSourceDocURL, aOpt, sal_True );
 
-    
+
         long nStartRow, nEndRow;
         ULONG nDocNo = 1;
         sal_Int32 nDocCount = 0;
@@ -3107,7 +3126,7 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
             aMonitorDlg.SetTotalCount( nDocCount );
 
         do
-        {        
+        {
             nStartRow = pImpl->pMergeData->xResultSet->getRow();
             if (!IsMergeSilent())
             {
@@ -3118,12 +3137,12 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
                 for( USHORT i = 0; i < 25; i++)
                     Application::Reschedule();
             }
-            
+
             // create a new docshell from the temporary document
             SfxBoolItem aHidden( SID_HIDDEN, TRUE );
             SfxStringItem aReferer( SID_REFERER, String::CreateFromAscii(URL_PREFIX_PRIV_SOFFICE ));
             SfxStringItem aTarget( SID_TARGETNAME, String::CreateFromAscii("_blank") );
-            const SfxPoolItem* pReturnValue = 
+            const SfxPoolItem* pReturnValue =
                             rSourceView.GetViewFrame()->GetDispatcher()->Execute( SID_OPENDOC, SFX_CALLMODE_SYNCHRON,
                                     &aURL, &aFilterName, &aHidden, &aReferer, &aTarget, 0);
             if(pReturnValue)
@@ -3132,8 +3151,8 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
                 SwView* pWorkView = (SwView*) pVItem->GetFrame()->GetViewShell();
                 SwWrtShell& rWorkShell = pWorkView->GetWrtShell();
                 pWorkView->AttrChangedNotify( &rWorkShell );//Damit SelectShell gerufen wird.
-    
-                // merge the data 
+
+                // merge the data
                 SwDoc* pWorkDoc = rWorkShell.GetDoc();
                 SwNewDBMgr* pWorkDBMgr = pWorkDoc->GetNewDBMgr();
                 pWorkDoc->SetNewDBMgr( this );
@@ -3147,25 +3166,25 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
                 // strip invisible content and convert fields to text
                 rWorkShell.RemoveInvisibleContent();
                 rWorkShell.ConvertFieldsToText();
-    
-    
+
+
                 // insert the document into the target document
                 rWorkShell.SwCrsrShell::EndDoc();
                 rWorkShell.SwCrsrShell::SttDoc();
                 rWorkShell.SelAll();
                 pTargetShell->SwCrsrShell::EndDoc();
                 if(nDocNo > 1)
-                {        
+                {
                     pTargetShell->InsertPageBreak( &sStartingPageDesc, nStartingPageNo );
                 }
                 else
                 {
                     pTargetShell->SetPageStyle(sStartingPageDesc);
-                }        
+                }
                 USHORT nPageCountBefore = pTargetShell->GetPageCnt();
                 DBG_ASSERT(!pTargetShell->GetTableFmt(),"target document ends with a table - paragraph should be appended")
                 pTargetShell->Paste( rWorkShell.GetDoc(), sal_True );
-                
+
                 //add the document info to the config item
                 SwDocMergeInfo aMergeInfo;
                 aMergeInfo.nStartPageInTarget = nPageCountBefore;
@@ -3173,11 +3192,11 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
                 aMergeInfo.nDBRow = nStartRow;
                 rMMConfig.AddMergedDocument( aMergeInfo );
                 ++nRet;
-                
+
                 // the print monitor needs some time to act
                 for( USHORT i = 0; i < 25; i++)
                     Application::Reschedule();
-                
+
                 //restore the ole DBMgr
                 pWorkDoc->SetNewDBMgr( pWorkDBMgr );
                 //now the temporary document should be closed
@@ -3205,7 +3224,7 @@ sal_Int32 SwNewDBMgr::MergeDocuments( Sw
     {
         rEx; // make compiler happy
         DBG_ERROR("exception caught in SwNewDBMgr::MergeDocuments")
-    }            
+    }
     if(sSourceDocURL.Len())
         File::remove( sSourceDocURL );
     DELETEZ(pImpl->pMergeData);
Index: sw/source/ui/uno/unomailmerge.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/uno/unomailmerge.cxx,v
retrieving revision 1.14
retrieving revision 1.14.12.1
diff -u -p -r1.14 -r1.14.12.1
--- sw/source/ui/uno/unomailmerge.cxx	28 Jan 2005 15:33:13 -0000	1.14
+++ sw/source/ui/uno/unomailmerge.cxx	18 Feb 2005 15:22:44 -0000	1.14.12.1
@@ -574,10 +574,10 @@ SwXMailMerge::SwXMailMerge() :
     aEvtListeners   ( GetMailMergeMutex() ),
     aMergeListeners ( GetMailMergeMutex() ),
     aPropListeners  ( GetMailMergeMutex() ),
-    bSendAsHTML(sal_False),     
+    bSendAsHTML(sal_False),
     bSendAsAttachment(sal_False),
     bSaveAsSingleFile(sal_False)
-                                     
+
 {
     // create empty document
     // like in: SwModule::InsertEnv (appenv.cxx)
@@ -694,7 +694,7 @@ uno::Any SAL_CALL SwXMailMerge::execute(
         else if (rName.equalsAscii( GetPropName( UNO_NAME_MAIL_BODY ) ))
             bOK = rValue >>= sMailBody;
         else if (rName.equalsAscii( GetPropName( UNO_NAME_ATTACHMENT_NAME ) ))
-            bOK = rValue >>= sAttachmentName;    
+            bOK = rValue >>= sAttachmentName;
         else if (rName.equalsAscii( GetPropName( UNO_NAME_ATTACHMENT_FILTER ) ))
             bOK = rValue >>= sAttachmentFilter;
         else if (rName.equalsAscii( GetPropName( UNO_NAME_COPIES_TO ) ))
@@ -709,6 +709,10 @@ uno::Any SAL_CALL SwXMailMerge::execute(
             bOK = rValue >>= bSaveAsSingleFile;
         else if (rName.equalsAscii( GetPropName( UNO_NAME_SAVE_FILTER ) ))
             bOK = rValue >>= sSaveFilter;
+        else if (rName.equalsAscii( GetPropName( UNO_NAME_SAVE_FILTER_OPTIONS ) ))
+            bOK = rValue >>= sSaveFilterOptions;
+        else if (rName.equalsAscii( GetPropName( UNO_NAME_SAVE_FILTER_DATA ) ))
+            bOK = rValue >>= aSaveFilterData;
         else if (rName.equalsAscii( GetPropName( UNO_NAME_IN_SERVER_PASSWORD ) ))
             bOK = rValue >>= sInServerPassword;
         else if (rName.equalsAscii( GetPropName( UNO_NAME_OUT_SERVER_PASSWORD ) ))
@@ -844,9 +848,9 @@ uno::Any SAL_CALL SwXMailMerge::execute(
     //force layout creation
     rSh.CalcLayout();
     DBG_ASSERT( pMgr, "database manager missing" );
-    
+
     SwMergeDescriptor aMergeDesc( nMergeType, rSh, aDescriptor );
-    
+
     std::auto_ptr< SwMailMergeConfigItem > pMMConfigItem;
     uno::Reference< mail::XMailService > xInService;
     if (MailMergeType::PRINTER == nCurOutputType)
@@ -857,7 +861,7 @@ uno::Any SAL_CALL SwXMailMerge::execute(
             aPrtData = *pShellPrintData;
         aPrtData.SetPrintSingleJobs( bCurSinglePrintJobs );
         rSh.SetPrintData( aPrtData );
-        // #i25686# printing should not be done asynchronously to prevent dangling offices 
+        // #i25686# printing should not be done asynchronously to prevent dangling offices
         // when mail merge is called as command line macro
         aMergeDesc.bPrintAsync = sal_False;
         aMergeDesc.aPrintOptions = aPrintSettings;
@@ -903,38 +907,40 @@ uno::Any SAL_CALL SwXMailMerge::execute(
         }
         pMgr->SetSubject( aPath );
         if(MailMergeType::FILE == nCurOutputType)
-        {        
+        {
             aMergeDesc.sSaveToFilter = sSaveFilter;
+            aMergeDesc.sSaveToFilterOptions = sSaveFilterOptions;
+            aMergeDesc.aSaveToFilterData = aSaveFilterData;
             aMergeDesc.bCreateSingleFile = bSaveAsSingleFile;
         }
         else /*if(MailMergeType::MAIL == nCurOutputType)*/
         {
             pMgr->SetEMailColumn( sAddressFromColumn );
             if(!sAddressFromColumn.getLength())
-                throw RuntimeException( OUString ( RTL_CONSTASCII_USTRINGPARAM ( 
+                throw RuntimeException( OUString ( RTL_CONSTASCII_USTRINGPARAM (
                         "Mail address column not set." ) ), static_cast < cppu::OWeakObject * > ( this ) );
             aMergeDesc.sSaveToFilter     = sAttachmentFilter;
             aMergeDesc.sSubject          = sSubject;
-            aMergeDesc.sMailBody         = sMailBody;          
-            aMergeDesc.sAttachmentName   = sAttachmentName;    
-            aMergeDesc.aCopiesTo         = aCopiesTo;          
-            aMergeDesc.aBlindCopiesTo    = aBlindCopiesTo;     
-            aMergeDesc.bSendAsHTML       = bSendAsHTML;        
-            aMergeDesc.bSendAsAttachment = bSendAsAttachment;   
+            aMergeDesc.sMailBody         = sMailBody;
+            aMergeDesc.sAttachmentName   = sAttachmentName;
+            aMergeDesc.aCopiesTo         = aCopiesTo;
+            aMergeDesc.aBlindCopiesTo    = aBlindCopiesTo;
+            aMergeDesc.bSendAsHTML       = bSendAsHTML;
+            aMergeDesc.bSendAsAttachment = bSendAsAttachment;
 
             aMergeDesc.bCreateSingleFile = sal_False;
             pMMConfigItem = std::auto_ptr< SwMailMergeConfigItem >(new SwMailMergeConfigItem);
             aMergeDesc.pMailMergeConfigItem = pMMConfigItem.get();
-            aMergeDesc.xSmtpServer = SwMailMergeHelper::ConnectToSmtpServer( 
+            aMergeDesc.xSmtpServer = SwMailMergeHelper::ConnectToSmtpServer(
                     *pMMConfigItem,
                     xInService,
                     sInServerPassword, sOutServerPassword );
             if( !aMergeDesc.xSmtpServer.is() || !aMergeDesc.xSmtpServer->isConnected())
-                throw RuntimeException( OUString ( RTL_CONSTASCII_USTRINGPARAM ( 
+                throw RuntimeException( OUString ( RTL_CONSTASCII_USTRINGPARAM (
                         "Failed to connect to mail server." ) ), static_cast < cppu::OWeakObject * > ( this ) );
         }
     }
-                
+
 
     // save document with temporary filename
     const SfxFilter *pSfxFlt = SwIoSystem::GetFilterOfFormat(
@@ -1057,7 +1063,7 @@ void SAL_CALL SwXMailMerge::setPropertyV
             case WID_FILE_NAME_FROM_COLUMN :    pData = &bFileNameFromColumn;  break;
             case WID_FILE_NAME_PREFIX :         pData = &aFileNamePrefix;  break;
             case WID_MAIL_SUBJECT:              pData = &sSubject; break;
-            case WID_ADDRESS_FROM_COLUMN:       pData = &sAddressFromColumn; break; 
+            case WID_ADDRESS_FROM_COLUMN:       pData = &sAddressFromColumn; break;
             case WID_SEND_AS_HTML:              pData = &bSendAsHTML; break;
             case WID_SEND_AS_ATTACHMENT:        pData = &bSendAsAttachment; break;
             case WID_MAIL_BODY:                 pData = &sMailBody; break;
@@ -1066,6 +1072,8 @@ void SAL_CALL SwXMailMerge::setPropertyV
             case WID_PRINT_OPTIONS:             pData = &aPrintSettings; break;
             case WID_SAVE_AS_SINGLE_FILE:       pData = &bSaveAsSingleFile; break;
             case WID_SAVE_FILTER:               pData = &sSaveFilter; break;
+            case WID_SAVE_FILTER_OPTIONS:       pData = &sSaveFilterOptions; break;
+            case WID_SAVE_FILTER_DATA:          pData = &aSaveFilterData; break;
             case WID_COPIES_TO:                 pData = &aCopiesTo; break;
             case WID_BLIND_COPIES_TO:           pData = &aBlindCopiesTo;break;
             case WID_IN_SERVER_PASSWORD:        pData = &sInServerPassword; break;
@@ -1127,34 +1135,38 @@ void SAL_CALL SwXMailMerge::setPropertyV
                 bOK = rValue >>= bFileNameFromColumn;
             else if (pData == &aFileNamePrefix)
                 bOK = rValue >>= aFileNamePrefix;
-            else if (pData == &sSubject) 
+            else if (pData == &sSubject)
                 bOK = rValue >>= sSubject;
-            else if (pData == &sAddressFromColumn) 
-                bOK = rValue >>= sAddressFromColumn;    
+            else if (pData == &sAddressFromColumn)
+                bOK = rValue >>= sAddressFromColumn;
             else if (pData == &bSendAsHTML)
-                bOK = rValue >>= bSendAsHTML;           
-            else if (pData == &bSendAsAttachment) 
-                bOK = rValue >>= bSendAsAttachment;     
-            else if (pData == &sMailBody) 
-                bOK = rValue >>= sMailBody;             
-            else if (pData == &sAttachmentName) 
-                bOK = rValue >>= sAttachmentName;       
+                bOK = rValue >>= bSendAsHTML;
+            else if (pData == &bSendAsAttachment)
+                bOK = rValue >>= bSendAsAttachment;
+            else if (pData == &sMailBody)
+                bOK = rValue >>= sMailBody;
+            else if (pData == &sAttachmentName)
+                bOK = rValue >>= sAttachmentName;
             else if (pData == &sAttachmentFilter)
-                bOK = rValue >>= sAttachmentFilter;      
-            else if (pData == &aPrintSettings) 
-                bOK = rValue >>= aPrintSettings;        
-            else if (pData == &bSaveAsSingleFile) 
-                bOK = rValue >>= bSaveAsSingleFile;     
-            else if (pData == &sSaveFilter) 
-                bOK = rValue >>= sSaveFilter;           
-            else if (pData == &aCopiesTo) 
-                bOK = rValue >>= aCopiesTo;             
+                bOK = rValue >>= sAttachmentFilter;
+            else if (pData == &aPrintSettings)
+                bOK = rValue >>= aPrintSettings;
+            else if (pData == &bSaveAsSingleFile)
+                bOK = rValue >>= bSaveAsSingleFile;
+            else if (pData == &sSaveFilter)
+                bOK = rValue >>= sSaveFilter;
+            else if (pData == &sSaveFilterOptions)
+                bOK = rValue >>= sSaveFilterOptions;
+            else if (pData == &aSaveFilterData)
+                bOK = rValue >>= aSaveFilterData;
+            else if (pData == &aCopiesTo)
+                bOK = rValue >>= aCopiesTo;
             else if (pData == &aBlindCopiesTo)
-                bOK = rValue >>= aBlindCopiesTo;         
+                bOK = rValue >>= aBlindCopiesTo;
             else if(pData == &sInServerPassword)
-                bOK = rValue >>= sInServerPassword;         
+                bOK = rValue >>= sInServerPassword;
             else if(pData == &sOutServerPassword)
-                bOK = rValue >>= sInServerPassword;         
+                bOK = rValue >>= sInServerPassword;
             else
                 DBG_ERROR( "invalid pointer" );
             DBG_ASSERT( bOK, "set value failed" );
@@ -1203,7 +1215,7 @@ uno::Any SAL_CALL SwXMailMerge::getPrope
             case WID_FILE_NAME_FROM_COLUMN :    aRet <<= bFileNameFromColumn;  break;
             case WID_FILE_NAME_PREFIX :         aRet <<= aFileNamePrefix;  break;
             case WID_MAIL_SUBJECT:              aRet <<= sSubject; break;
-            case WID_ADDRESS_FROM_COLUMN:       aRet <<= sAddressFromColumn; break; 
+            case WID_ADDRESS_FROM_COLUMN:       aRet <<= sAddressFromColumn; break;
             case WID_SEND_AS_HTML:              aRet <<= bSendAsHTML; break;
             case WID_SEND_AS_ATTACHMENT:        aRet <<= bSendAsAttachment; break;
             case WID_MAIL_BODY:                 aRet <<= sMailBody; break;
@@ -1212,6 +1224,8 @@ uno::Any SAL_CALL SwXMailMerge::getPrope
             case WID_PRINT_OPTIONS:             aRet <<= aPrintSettings; break;
             case WID_SAVE_AS_SINGLE_FILE:       aRet <<= bSaveAsSingleFile; break;
             case WID_SAVE_FILTER:               aRet <<= sSaveFilter; break;
+            case WID_SAVE_FILTER_OPTIONS:       aRet <<= sSaveFilterOptions; break;
+            case WID_SAVE_FILTER_DATA:          aRet <<= aSaveFilterData; break;
             case WID_COPIES_TO:                 aRet <<= aCopiesTo; break;
             case WID_BLIND_COPIES_TO:           aRet <<= aBlindCopiesTo;break;
             case WID_IN_SERVER_PASSWORD:        aRet <<= sInServerPassword; break;
Index: sw/source/ui/uno/unotxdoc.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/uno/unotxdoc.cxx,v
retrieving revision 1.96
retrieving revision 1.96.128.2
diff -u -p -r1.96 -r1.96.128.2
--- sw/source/ui/uno/unotxdoc.cxx	9 Dec 2004 16:41:35 -0000	1.96
+++ sw/source/ui/uno/unotxdoc.cxx	18 Feb 2005 15:22:44 -0000	1.96.128.2
@@ -1829,8 +1829,8 @@ Reference< XInterface >  SwXTextDocument
             }
 			if(!xRet.is())
 			{
-				//! we don't want to insert OLE2 Shapes (e.g. "com.sun.star.drawing.OLE2Shape", ...) 
-				//! like this (by creating them with the documents factory and 
+				//! we don't want to insert OLE2 Shapes (e.g. "com.sun.star.drawing.OLE2Shape", ...)
+				//! like this (by creating them with the documents factory and
 				//! adding the shapes to the draw page).
 				//! For inserting OLE objects the proper way is to use
 				//! "com.sun.star.text.TextEmbeddedObject"!
@@ -2598,8 +2598,14 @@ uno::Sequence< beans::PropertyValue > SA
     if (nRenderer >= pDoc->GetPageCount())
         return uno::Sequence< beans::PropertyValue >();
 
-    Size aPgSize( pDoc->GetPageSize( sal_uInt16(nRenderer + 1) ) );
-    DBG_ASSERT( aPgSize != Size(), "no page size" );
+    bool bSkipEmptyPages = false;
+    for( sal_Int32 nProperty = 0, nPropertyCount = rxOptions.getLength(); nProperty < nPropertyCount; ++nProperty )
+    {
+        if( rxOptions[ nProperty ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "SkipEmptyPages" ) ) )
+            rxOptions[ nProperty].Value >>= bSkipEmptyPages;
+    }
+
+    Size aPgSize( pDoc->GetPageSize( sal_uInt16(nRenderer + 1), bSkipEmptyPages ) );
 
     awt::Size aPageSize( TWIP_TO_MM100( aPgSize.Width() ),
                          TWIP_TO_MM100( aPgSize.Height() ));
@@ -2683,7 +2689,9 @@ void SAL_CALL SwXTextDocument::render(
     uno::Reference< awt::XDevice >  xRenderDevice;
     bool bFirstPage = false;
     bool bLastPage = false;
-    const sal_Int32 nPageNumber = nRenderer + 1;
+    rtl::OUString aPages;
+    bool bSkipEmptyPages = false;
+
     for( sal_Int32 nProperty = 0, nPropertyCount = rxOptions.getLength(); nProperty < nPropertyCount; ++nProperty )
     {
         if( rxOptions[ nProperty ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "RenderDevice" ) ) )
@@ -2692,7 +2700,12 @@ void SAL_CALL SwXTextDocument::render(
             rxOptions[ nProperty].Value >>= bFirstPage;
         else if( rxOptions[ nProperty ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "LastPage" ) ) )
             rxOptions[ nProperty].Value >>= bLastPage;
+        else if( rxOptions[ nProperty ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "PageRange" ) ) )
+            rxOptions[ nProperty].Value >>= aPages;
+        else if( rxOptions[ nProperty ].Name == OUString( RTL_CONSTASCII_USTRINGPARAM( "SkipEmptyPages" ) ) )
+            rxOptions[ nProperty].Value >>= bSkipEmptyPages;
     }
+
     OutputDevice*   pOut = 0;
     if (xRenderDevice.is())
     {
@@ -2739,7 +2752,7 @@ void SAL_CALL SwXTextDocument::render(
 
         if ( bFirstPage && pWrtShell )
         {
-            SwEnhancedPDFExportHelper aHelper( *pWrtShell, *pOut );
+            SwEnhancedPDFExportHelper aHelper( *pWrtShell, *pOut, aPages, bSkipEmptyPages, sal_False );
         }
         // <--
 
@@ -2753,7 +2766,7 @@ void SAL_CALL SwXTextDocument::render(
         //
         if ( bLastPage && pWrtShell )
         {
-            SwEnhancedPDFExportHelper aHelper( *pWrtShell, *pOut, sal_True );
+            SwEnhancedPDFExportHelper aHelper( *pWrtShell, *pOut, aPages, bSkipEmptyPages,  sal_True );
         }
         // <--
 
Index: svx/source/editeng/svxacorr.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/editeng/svxacorr.cxx,v
retrieving revision 1.45
retrieving revision 1.45.40.1
diff -u -p -r1.45 -r1.45.40.1
--- svx/source/editeng/svxacorr.cxx	28 Jan 2005 16:24:28 -0000	1.45
+++ svx/source/editeng/svxacorr.cxx	14 Feb 2005 09:56:32 -0000	1.45.40.1
@@ -877,7 +877,10 @@ BOOL SvxAutoCorrect::FnCptlSttSntnc( Svx
 		{
 			if( lcl_IsInAsciiArr( sImplWordChars, *pStr ) &&
 				pWordStt - 1 == pStr &&
-				(long)(pStart + 1) < (long)pStr &&
+                // --> FME 2005-02-14 #i38971#
+                // l'intallazione at beginning of paragraph. Replaced < by <=
+				(long)(pStart + 1) <= (long)pStr &&
+                // <--
 				rCC.isLetter( aText, pStr-1 - pStart ) )
 				pWordStt = --pStr;
 			else
