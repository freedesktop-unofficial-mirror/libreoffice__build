Index: sd/qa/unoapi/knownissues.xcl
===================================================================
RCS file: /cvs/graphics/sd/qa/unoapi/knownissues.xcl,v
retrieving revision 1.5
retrieving revision 1.5.88.1
diff -u -p -u -p -r1.5 -r1.5.88.1
--- sd/qa/unoapi/knownissues.xcl	26 Nov 2004 15:09:13 -0000	1.5
+++ sd/qa/unoapi/knownissues.xcl	17 Feb 2005 12:59:02 -0000	1.5.88.1
@@ -17,24 +17,16 @@ sd.SdUnoDrawView::com::sun::star::view::
 ### i22891 ###
 sd.SdUnoPresView::com::sun::star::presentation::PreviewView
 
-### i22893 ###
-sd.SdXImpressDocument::com::sun::star::document::XDocumentInfoSupplier
-sd.SdXImpressDocument::com::sun::star::view::XPrintJobBroadcaster
-sd.SdXImpressDocument::com::sun::star::document::XViewDataSupplier
-
 ### i22896 ###
 sd.SdXImpressDocument::com::sun::star::document::XEventBroadcaster
 
-### i26264 ###
-sd.SdXImpressDocument::com::sun::star::view::XPrintable
-
-### i36322 ###
-sd.SdUnoPresView::com::sun::star::lang::XComponent
-sd.SdUnoDrawView::com::sun::star::lang::XComponent
+### i34994 ###
+sd.SdXPresentation::com::sun::star::presentation::Presentation
 
-### i36330 ###
-sd.SdUnoPresView::com::sun::star::lang::XServiceInfo
+### i42991 ###
 sd.SdUnoDrawView::com::sun::star::lang::XServiceInfo
 
-### i34994 ###
-sd.SdXPresentation::com::sun::star::presentation::Presentation
+### runner creates faulty urls ###
+sd.SdXImpressDocument::com::sun::star::view::XPrintable
+sd.SdXImpressDocument::com::sun::star::view::XPrintJobBroadcaster
+sd.SdXImpressDocument::com::sun::star::frame::XStorable
Index: sd/qa/unoapi/sd.sce
===================================================================
RCS file: /cvs/graphics/sd/qa/unoapi/sd.sce,v
retrieving revision 1.4
retrieving revision 1.4.88.1
diff -u -p -u -p -r1.4 -r1.4.88.1
--- sd/qa/unoapi/sd.sce	26 Nov 2004 15:09:32 -0000	1.4
+++ sd/qa/unoapi/sd.sce	17 Feb 2005 12:58:46 -0000	1.4.88.1
@@ -2,7 +2,7 @@
 -o sd.SdXCustomPresentationAccess
 -o sd.SdUnoOutlineView
 -o sd.SdUnoPresView
--o sd.AccessibleDrawDocumentView
+#i35935#-o sd.AccessibleDrawDocumentView
 -o sd.AccessibleOutlineView
 #i35935#-o sd.AccessibleSlideView
 -o sd.SdDocLinkTargets
Index: sd/source/core/CustomAnimationEffect.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/core/CustomAnimationEffect.cxx,v
retrieving revision 1.5
retrieving revision 1.5.2.1
diff -u -p -u -p -r1.5 -r1.5.2.1
--- sd/source/core/CustomAnimationEffect.cxx	28 Jan 2005 15:53:17 -0000	1.5
+++ sd/source/core/CustomAnimationEffect.cxx	10 Feb 2005 12:18:49 -0000	1.5.2.1
@@ -881,7 +881,7 @@ void CustomAnimationEffect::replaceNode(
 
 	setNode( xNode );
 
-	mxAudio = xAudio;
+	setAudio( xAudio );
 	setNodeType( nNodeType );
 	setTarget( aTarget );
 	setDuration( fDuration );
@@ -1557,32 +1557,41 @@ static Reference< XCommand > findCommand
 
 void CustomAnimationEffect::removeAudio()
 {
-	Reference< XAnimationNode > xChild;
-
-	if( mxAudio.is() )
+	try
 	{
-		xChild.set( mxAudio, UNO_QUERY );
-		mxAudio.clear();
+		Reference< XAnimationNode > xChild;
+
+		if( mxAudio.is() )
+		{
+			xChild.set( mxAudio, UNO_QUERY );
+			mxAudio.clear();
+		}
+		else if( mnCommand == EffectCommands::STOPAUDIO )
+		{
+			xChild.set( findCommandNode( mxNode ), UNO_QUERY );
+			mnCommand = 0;
+		}
+
+		if( xChild.is() )
+		{
+			Reference< XTimeContainer > xContainer( mxNode, UNO_QUERY );
+			if( xContainer.is() )
+				xContainer->removeChild( xChild );
+		}
 	}
-	else if( mnCommand == EffectCommands::STOPAUDIO )
+	catch( Exception& e )
 	{
-		xChild.set( findCommandNode( mxNode ), UNO_QUERY );
-		mnCommand = 0;
+		(void)e;
+		DBG_ERROR("sd::CustomAnimationEffect::removeAudio(), exception caught!" );
 	}
 
-	if( xChild.is() )
-	{
-		Reference< XTimeContainer > xContainer( mxNode, UNO_QUERY );
-		if( xContainer.is() )
-			xContainer->removeChild( xChild );
-	}
 }
 
 // --------------------------------------------------------------------
 
 void CustomAnimationEffect::setAudio( const Reference< ::com::sun::star::animations::XAudio >& xAudio )
 {
-	if( mxAudio != xAudio )
+	if( mxAudio != xAudio ) try
 	{
 		removeAudio();
 		mxAudio = xAudio;
@@ -1591,6 +1600,11 @@ void CustomAnimationEffect::setAudio( co
 		if( xContainer.is() && xChild.is() )
 			xContainer->appendChild( xChild );
 	}
+	catch( Exception& e )
+	{
+		(void)e;
+		DBG_ERROR("sd::CustomAnimationEffect::setAudio(), exception caught!" );
+	}
 }
 
 // --------------------------------------------------------------------
Index: sd/source/ui/app/strings.src
===================================================================
RCS file: /cvs/graphics/sd/source/ui/app/strings.src,v
retrieving revision 1.108
retrieving revision 1.108.2.1
diff -u -p -u -p -r1.108 -r1.108.2.1
--- sd/source/ui/app/strings.src	31 Jan 2005 14:50:37 -0000	1.108
+++ sd/source/ui/app/strings.src	10 Feb 2005 15:35:33 -0000	1.108.2.1
@@ -2546,33 +2546,11 @@ String STR_IMPRESS_DOCUMENT_FULLTYPE_60
     Text [ de ] = "%PRODUCTNAME %PRODUCTVERSION Präsentation" ;
     Text [ en-US ] = "%PRODUCTNAME %PRODUCTVERSION Presentation" ;
 };
-String STR_IMPRESS_DOCUMENT_FULLTYPE_50
-{
-	Text [ de ] = "%PRODUCTNAME 5.0 Präsentation" ;
-	Text [ en-US ] = "%PRODUCTNAME 5.0 Presentation" ;
-};
-String STR_IMPRESS_DOCUMENT_FULLTYPE_40
-{
-	/* ### ACHTUNG: Neuer Text in Resource? StarOffice 4.0 Präsentation : StarOffice 4.0 Prõsentation */
-	Text [ de ] = "%PRODUCTNAME 4.0 Präsentation" ;
-	Text [ en-US ] = "%PRODUCTNAME 4.0 Presentation" ;
-};
-String STR_IMPRESS_DOCUMENT_FULLTYPE_31
-{
-	/* ### ACHTUNG: Neuer Text in Resource? StarOffice 3.0 Graphik / Präsentation : StarOffice 3.0 Graphik / Prõsentation */
-	Text [ de ] = "%PRODUCTNAME 3.0 Graphik / Präsentation" ;
-	Text [ en-US ] = "Graphics/presentation (%PRODUCTNAME 3.0)" ;
-};
 String STR_GRAPHIC_DOCUMENT
 {
 	Text [ de ] = "Zeichnung" ;
 	Text [ en-US ] = "Drawing" ;
 };
-String STR_GRAPHIC_DOCUMENT_FULLTYPE_50
-{
-	Text [ de ] = "%PRODUCTNAME 5.0 Zeichnung" ;
-	Text [ en-US ] = "Drawing (%PRODUCTNAME 5.0)" ;
-};
 String STR_GRAPHIC_DOCUMENT_FULLTYPE_60
 {
     Text [ de ] = "%PRODUCTNAME %PRODUCTVERSION Zeichnung" ;
Index: sd/source/ui/inc/PaneManager.hxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/inc/PaneManager.hxx,v
retrieving revision 1.6
retrieving revision 1.6.2.1
diff -u -p -u -p -r1.6 -r1.6.2.1
--- sd/source/ui/inc/PaneManager.hxx	28 Jan 2005 15:40:56 -0000	1.6
+++ sd/source/ui/inc/PaneManager.hxx	7 Feb 2005 18:00:13 -0000	1.6.2.1
@@ -170,10 +170,21 @@ public:
             an Execute() method (when it is called from SFX.)
     */
     void SetWindow (
-        PaneType ePane, 
+        PaneType ePane,
         ::Window* pWindow,
         CallMode eCallMode = CM_ASYNCHRONOUS);
 
+    /** Show or hide the visibility of the specified pane.
+        @return
+            When the new visibility is different from the current one then
+            <TRUE/> is returned.  When nothing had to be changed then
+            <FALSE/> is returned.
+    */
+    bool RequestWindowVisibilityChange (
+        PaneType ePane, 
+        bool bVisible,
+        CallMode eCallMode = CM_ASYNCHRONOUS);
+
     /** Handle slot calls for the slots SID_DRAWINGMODE, SID_NOTESMODE,
         SID_HANDOUTMODE, SID_DIAMODE, and SID_OUTLINEMODE.  As a result
         RequestViewShellChange is called with the proper shell type.
@@ -192,11 +203,37 @@ public:
         @param eCallMode
             This flag specifies whether the slot call is made synchronously
             or asynchronously.
+        @return
+            When the new view shell type is different from the current one then
+            <TRUE/> is returned.  When nothing had to be changed then
+            <FALSE/> is returned.
     */
     bool RequestMainViewShellChange (
         ViewShell::ShellType eType,
         CallMode eCallMode = CM_ASYNCHRONOUS);
 
+    /** 
+        Request the specified pane to change its view shell.  In contrast to
+        the RequestMainViewShellChange() this method only operates on one
+        pane.  The given shell type is stored in the configuration. 
+        @param ePane
+            The pane of which to change the view shell.
+        @param eType
+            The type of the view shell determines the visibility of the
+            pane.  When ST_NONE is given the pane is hidden, for every
+            other valid view shell type it is shown.  When that is not the
+            desired behaviour call this method asynchronously and after that
+            call SetWindowVisibility() to show or hide the pane.
+        @return
+            When the new view shell type is different from the current one then
+            <TRUE/> is returned.  When nothing had to be changed then
+            <FALSE/> is returned.
+    */
+    bool RequestViewShellChange(
+        PaneType ePane, 
+        ViewShell::ShellType eType,
+        CallMode eCallMode = CM_ASYNCHRONOUS);
+
     /** Callback function for slots related to changing the view or
         edit mode.
     */
Index: sd/source/ui/inc/PrintManager.hxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/inc/PrintManager.hxx,v
retrieving revision 1.2
retrieving revision 1.2.362.1
diff -u -p -u -p -r1.2 -r1.2.362.1
--- sd/source/ui/inc/PrintManager.hxx	20 Jan 2004 11:40:59 -0000	1.2
+++ sd/source/ui/inc/PrintManager.hxx	10 Feb 2005 13:40:43 -0000	1.2.362.1
@@ -154,6 +154,29 @@ private:
 
     /// Assignment operator not supported.
     PrintManager& operator= (const PrintManager&);
+
+    /** Make sure that the pages that are to be printed do fit to the
+        printer pages.  When the internal pages are larger then the printer
+        pages and no method of resolution has yet been provided then a
+        dialog is opened that asks for one.  These methods are 
+        a) scale internal page down to the printer page,
+        b) crop internal page
+        c) print internal page on several printer pages.
+        @param pPrinter
+            The printer to print the pages on that are specified by the
+            msPageRange member.
+        @param bSilent
+            This flag, when set, tells the method not to wait for user
+            input, i.e. show a dialog.
+        @return
+            The returned flag indicates whether the method was successfull (<TRUE/>)
+            or whether the printing has to be aborted (<FALSE/>).  The later
+            one is the case only when the dialog is shown and the user
+            selects 'Cancel'.
+    */
+    bool FitPageToPrinterWithDialog (
+        SfxPrinter *pPrinter,
+        bool bSilent);
 };
 
 } // end of namespace sd
Index: sd/source/ui/inc/ViewShellBase.hxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/inc/ViewShellBase.hxx,v
retrieving revision 1.10
retrieving revision 1.10.2.1
diff -u -p -u -p -r1.10 -r1.10.2.1
--- sd/source/ui/inc/ViewShellBase.hxx	28 Jan 2005 15:41:10 -0000	1.10
+++ sd/source/ui/inc/ViewShellBase.hxx	10 Feb 2005 13:28:35 -0000	1.10.2.1
@@ -75,9 +75,6 @@
 #ifndef _VIEWFAC_HXX
 #include <sfx2/viewfac.hxx>
 #endif
-#ifndef SD_PRINT_MANAGER_HXX
-#include "PrintManager.hxx"
-#endif
 #include <memory>
 
 class SdDrawDocument;
@@ -92,6 +89,7 @@ namespace sd {
 class DrawDocShell;
 class FormShellManager;
 class PaneManager;
+class PrintManager;
 class ViewShell;
 class ViewShellManager;
 
@@ -311,7 +309,7 @@ private:
 	SdDrawDocument* mpDocument;
 
     /// The print manager is responsible for printing documents.
-    PrintManager maPrintManager;
+    ::std::auto_ptr<PrintManager> mpPrintManager;
 
     ::std::auto_ptr<FormShellManager> mpFormShellManager;
 
Index: sd/source/ui/inc/strings.hrc
===================================================================
RCS file: /cvs/graphics/sd/source/ui/inc/strings.hrc,v
retrieving revision 1.27
retrieving revision 1.27.2.1
diff -u -p -u -p -r1.27 -r1.27.2.1
--- sd/source/ui/inc/strings.hrc	31 Jan 2005 14:52:49 -0000	1.27
+++ sd/source/ui/inc/strings.hrc	10 Feb 2005 15:35:50 -0000	1.27.2.1
@@ -263,9 +263,6 @@
 
 #define STR_FORMAT_HTML             (RID_APP_START+166)
 
-#define STR_IMPRESS_DOCUMENT_FULLTYPE_31  (RID_APP_START+167)
-#define STR_IMPRESS_DOCUMENT_FULLTYPE_40  (RID_APP_START+168)
-#define STR_IMPRESS_DOCUMENT_FULLTYPE_50  (RID_APP_START+169)
 #define STR_IMPRESS_DOCUMENT_FULLTYPE_60  (RID_APP_START+170)
 
 /*
@@ -583,7 +580,6 @@
 
 #define STR_GRAPHIC                         (RID_APP_START+498)
 #define STR_GRAPHIC_DOCUMENT                (RID_APP_START+499)
-#define STR_GRAPHIC_DOCUMENT_FULLTYPE_50    (RID_APP_START+500)
 #define STR_GRAPHIC_DOCUMENT_FULLTYPE_60    (RID_APP_START+501)
 
 #define STR_FIX								(RID_APP_START+502)
Index: sd/source/ui/slideshow/slideshowimpl.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/slideshow/slideshowimpl.cxx,v
retrieving revision 1.9
retrieving revision 1.9.2.2
diff -u -p -u -p -r1.9 -r1.9.2.2
--- sd/source/ui/slideshow/slideshowimpl.cxx	28 Jan 2005 15:53:08 -0000	1.9
+++ sd/source/ui/slideshow/slideshowimpl.cxx	11 Feb 2005 09:30:12 -0000	1.9.2.2
@@ -442,13 +442,7 @@ 
 		xSet->getPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM( "Number" ) ) ) >>= nPageNumber;
 		mpAnimationPageList->insertPageNumber( nPageNumber-1 );
 
-		if( (pParent == 0) && mpViewShell )
-		{
-//			pParent = dynamic_cast< ::Window* >( mpView->GetWin( 0 ) );
-			pParent = mpViewShell->GetParentWindow();
-		}
-
-		mpShowWindow = new ShowWindow( pParent );
+		mpShowWindow = new ShowWindow( ((pParent == 0) && mpViewShell) ?  mpViewShell->GetParentWindow() : pParent );
 		if( mpViewShell )
 		{
 			mpViewShell->SetActiveWindow( mpShowWindow );
@@ -460,13 +454,21 @@ 
 			mpView->AddWin( mpShowWindow );
 
 		// call resize handler
-		if (mpViewShell)
+		if( pParent )
+		{
+			maPresSize = pParent->GetSizePixel();
+		}
+		else if( mpViewShell )
 		{
 			const Rectangle& aContentRect = mpViewShell->GetViewShellBase().getClientRectangle();
 			maPresSize = aContentRect.GetSize();
 			mpShowWindow->SetPosPixel( aContentRect.TopLeft() );
-			resize( maPresSize );
 		}
+		else
+		{
+			DBG_ERROR("sd::SlideshowImpl::startPreview(), I need either a parent window or a viewshell!");
+		}
+		resize( maPresSize );
 
 		sal_Int32 nPropertyCount = 1;
 		if( mxPreviewAnimationNode.is() )
@@ -630,9 +635,15 @@ bool SlideshowImpl::startShow( Presentat
 			const Rectangle& aClientRect = mpViewShell->GetViewShellBase().getClientRectangle();
 			maPresSize = aClientRect.GetSize();
 			mpShowWindow->SetPosPixel( aClientRect.TopLeft() );
+            resize( maPresSize );
 		}
 
-		resize( maPresSize );
+        // #i41824#
+        // Note: In FullScreen Mode the OS (window manager) sends a resize to
+        // the WorkWindow once it actually resized it to full size.  The
+        // WorkWindow propagates the resize to the DrawViewShell which calls
+        // resize() at the SlideShow (this).  Calling resize here results in a
+        // temporary display of a black window in the window's default size
 
 /*
 		if ( mbRehearseTimings ) 

Index: sd/source/ui/slidesorter/controller/SlideSorterController.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/slidesorter/controller/SlideSorterController.cxx,v
retrieving revision 1.9
retrieving revision 1.9.12.3
diff -u -p -u -p -r1.9 -r1.9.12.3
--- sd/source/ui/slidesorter/controller/SlideSorterController.cxx	27 Jan 2005 14:17:41 -0000	1.9
+++ sd/source/ui/slidesorter/controller/SlideSorterController.cxx	11 Feb 2005 14:22:46 -0000	1.9.12.3
@@ -59,6 +59,7 @@
  *
  ************************************************************************/
 
+
 #include "controller/SlideSorterController.hxx"
 
 #include "SlideSorterViewShell.hxx"
@@ -158,7 +159,8 @@ SlideSorterController::SlideSorterContro
       mbPostModelChangePending (false),
       maSelectionBeforeSwitch(),
       mnCurrentPageBeforeSwitch(0),
-      mpEditModeChangeMasterPage(NULL)
+      mpEditModeChangeMasterPage(NULL),
+      mbIsMakeSelectionVisiblePending(false)
 {
     OSL_ASSERT(pFrame!=NULL);
     OSL_ASSERT(pParentWindow!=NULL);
@@ -307,25 +309,55 @@ ScrollBarManager& SlideSorterController:
 
 
 
+void SlideSorterController::Paint (
+    const Rectangle& rBBox,
+    ::sd::Window* pWindow)
+{
+    if (mbIsMakeSelectionVisiblePending)
+    {
+        MakeSelectionVisible();
+        mbIsMakeSelectionVisiblePending = false;
+    }
+
+    GetView().CompleteRedraw(pWindow, Region(rBBox));
+}
+
+
+
+
 SdPage*	SlideSorterController::GetActualPage (void)
 {
-    // First try the currently focused page.
-    model::PageDescriptor* pDescriptor = NULL;
-    if (GetFocusManager().IsFocusShowing())
-        pDescriptor = GetFocusManager().GetFocusedPageDescriptor();
-    if (pDescriptor == NULL)
-    {
-        // No focus so try the selection.
-        model::SlideSorterModel::Enumeration aEnumeration (
-            GetModel().GetSelectedPagesEnumeration());
-        if (aEnumeration.HasMoreElements())
-            pDescriptor = &aEnumeration.GetNextElement();
+    SdPage* pCurrentPage = NULL;
+
+    // 1. Try to get the current page from the view shell in the center pane
+    // (if we are that not ourself).
+    if ( ! GetViewShell().IsMainViewShell())
+    {
+        ViewShell* pMainViewShell =  GetViewShell().GetViewShellBase().GetMainViewShell();
+        if (pMainViewShell != NULL)
+            pCurrentPage = pMainViewShell->GetActualPage();
     }
+
+    // 2. Try the currently focused page.
+    if (pCurrentPage == NULL)
+    {
+        model::PageDescriptor* pDescriptor = NULL;
+        if (GetFocusManager().IsFocusShowing())
+            pDescriptor = GetFocusManager().GetFocusedPageDescriptor();
+        if (pDescriptor == NULL)
+        {
+            // 3. Take the first selected page.
+            model::SlideSorterModel::Enumeration aEnumeration (
+                GetModel().GetSelectedPagesEnumeration());
+            if (aEnumeration.HasMoreElements())
+                pDescriptor = &aEnumeration.GetNextElement();
+        }
     
-    if (pDescriptor != NULL)
-        return pDescriptor->GetPage();
-    else
-        return NULL;
+        if (pDescriptor != NULL)
+            pCurrentPage = pDescriptor->GetPage();
+    }
+
+    return pCurrentPage;
 }
 
 
@@ -534,30 +566,20 @@ IMPL_LINK(SlideSorterController, WindowE
             switch (pEvent->GetId())
             {
                 case VCLEVENT_WINDOW_ACTIVATE:
-                    //                    rShell.ArrangeGUIElements();
-                    mrView.RequestRepaint();
-                    break;
-
                 case VCLEVENT_WINDOW_SHOW:
-                    //                    rShell.ArrangeGUIElements();
                     mrView.RequestRepaint();
                     break;
             }
         }
         else if (pWindow == rShell.GetActiveWindow())
         {
-            /*
             switch (pEvent->GetId())
             {
-                case VCLEVENT_WINDOW_GETFOCUS:
-                    GetFocusManager().ShowFocus();
-                    break;
-                    
-                case VCLEVENT_WINDOW_LOSEFOCUS:
-                    GetFocusManager().HideFocus();
+                case VCLEVENT_WINDOW_SHOW:
+                case VCLEVENT_WINDOW_RESIZE:
+                    //                    SelectionHasChanged(true);
                     break;
             }
-            */
         }
         else
         {
@@ -636,9 +658,10 @@ void SlideSorterController::DeleteSelect
         DBG_ASSERT(pPage!=NULL, "page does not exist");
         DBG_ASSERT(pNotesPage!=NULL, "notes does not exist");
 
-        // Add undo actions and delete the pages.
-        GetView().AddUndo (new SdrUndoDelPage (*pPage));
+        // Add undo actions and delete the pages.  The order of adding the
+        // undo actions is important.
         GetView().AddUndo (new SdrUndoDelPage (*pNotesPage));
+        GetView().AddUndo (new SdrUndoDelPage (*pPage));
         if (GetModel().GetEditMode() == EM_PAGE)
         {
             // Remove regular slides with the API.
@@ -815,7 +838,8 @@ void SlideSorterController::SelectionHas
     bool bMakeSelectionVisible)
 {
     if (bMakeSelectionVisible)
-        MakeSelectionVisible();
+        mbIsMakeSelectionVisiblePending = true;
+    //        MakeSelectionVisible();
 
     SlideSorterViewShell& rViewShell (GetViewShell());
 	rViewShell.Invalidate (SID_EXPAND_PAGE);
@@ -861,15 +885,16 @@ void SlideSorterController::SelectionHas
 
 
 
-/** We have to distinguish two cases: a) the selection fits completely into
-    the visible area, b) it does not.
-    a) When the selection fits completely into the visible area we have to
+/** We have to distinguish three cases: 1) the selection is empty, 2) the
+    selection fits completely into the visible area, 3) it does not.
+    1) The visible area is not modified.
+    2) When the selection fits completely into the visible area we have to
     decide how to align it.  It is done by scrolling it there and thus when
     we scoll up the (towards the end of the document) the bottom of the
     selection is aligned with the bottom of the window.  When we scroll
     down (towards the beginning of the document) the top of the selection is
     aligned with the top of the window.
-    b) We have to decide what part of the selection to make visible.  Here
+    3) We have to decide what part of the selection to make visible.  Here
     we use the eSelectionHint and concentrate on either the first, the last,
     or the most recently selected page.  We then again apply the algorithm
     of a).
@@ -879,7 +904,7 @@ void SlideSorterController::MakeSelectio
     SelectionHint eSelectionHint)
 {
     // Determine the descriptors of the first, last, and most recently
-    // selected page and the bounding box that encloses all those page objects.
+    // selected page and the bounding box that encloses their page objects.
     model::PageDescriptor* pFirst = NULL;
     model::PageDescriptor* pLast = NULL;
     Rectangle aSelectionBox;
@@ -898,46 +923,52 @@ void SlideSorterController::MakeSelectio
             view::SlideSorterView::CS_MODEL,
             view::SlideSorterView::BBT_INFO));
     }
-    model::PageDescriptor* pRecent 
-        = GetPageSelector().GetMostRecentlySelectedPage();
-    
-    // Determine scroll direction and the position in model coordinates that
-    // will be aligned with the top or bottom window border.
-    Rectangle aVisibleArea (GetViewShell().GetActiveWindow()->PixelToLogic(
-        Rectangle(
-            Point(0,0),
-            GetViewShell().GetActiveWindow()->GetOutputSizePixel())));
-    if (aSelectionBox.GetHeight() > aVisibleArea.GetHeight())
-    {
-        // We can show only a part of the selection.
 
-        // Get the bounding box of the page object on which to concentrate.
-        model::PageDescriptor* pRepresentative;
-        switch (eSelectionHint)
+    if (pFirst != NULL)
+    {
+        // The mose recently selected page is assumed to lie in the range
+        // between first and last selected page.  Therefore the bounding box
+        // is not modified.
+        model::PageDescriptor* pRecent = GetPageSelector().GetMostRecentlySelectedPage();
+    
+        // Determine scroll direction and the position in model coordinates
+        // that will be aligned with the top or bottom window border.
+        Rectangle aVisibleArea (GetViewShell().GetActiveWindow()->PixelToLogic(
+            Rectangle(
+                Point(0,0),
+                GetViewShell().GetActiveWindow()->GetOutputSizePixel())));
+        if (aSelectionBox.GetHeight() > aVisibleArea.GetHeight())
         {
-            case SH_FIRST:
-                pRepresentative = pFirst;
-                break;
+            // We can show only a part of the selection.
 
-            case SH_LAST:
-                pRepresentative = pLast;
-                break;
-
-            case SH_RECENT:
-                if (pRecent == NULL)
+            // Get the bounding box of the page object on which to concentrate.
+            model::PageDescriptor* pRepresentative;
+            switch (eSelectionHint)
+            {
+                case SH_FIRST:
                     pRepresentative = pFirst;
-                else
-                    pRepresentative = pRecent;
-                break;
+                    break;
+
+                case SH_LAST:
+                    pRepresentative = pLast;
+                    break;
+
+                case SH_RECENT:
+                    if (pRecent == NULL)
+                        pRepresentative = pFirst;
+                    else
+                        pRepresentative = pRecent;
+                    break;
+            }
+            if (pRepresentative != NULL)
+                aSelectionBox = mrView.GetPageBoundingBox (
+                    *pRepresentative,
+                    view::SlideSorterView::CS_MODEL,
+                    view::SlideSorterView::BBT_INFO);
         }
-        if (pRepresentative != NULL)
-            aSelectionBox = mrView.GetPageBoundingBox (
-                *pRepresentative,
-                view::SlideSorterView::CS_MODEL,
-                view::SlideSorterView::BBT_INFO);
+        
+        MakeRectangleVisible (aSelectionBox);
     }
-
-    MakeRectangleVisible (aSelectionBox);
 }
 
 
Index: sd/source/ui/slidesorter/controller/SlsListener.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/slidesorter/controller/SlsListener.cxx,v
retrieving revision 1.4
retrieving revision 1.4.94.1
diff -u -p -u -p -r1.4 -r1.4.94.1
--- sd/source/ui/slidesorter/controller/SlsListener.cxx	16 Nov 2004 16:14:16 -0000	1.4
+++ sd/source/ui/slidesorter/controller/SlsListener.cxx	11 Feb 2005 14:29:14 -0000	1.4.94.1
@@ -233,8 +233,7 @@ void Listener::ConnectToController (void
         catch (beans::UnknownPropertyException aEvent)
         {
             OSL_TRACE ("caught exception in SlideSorterController::SetupListeners: %s",
-                ::rtl::OUStringToOString(aEvent.Message,
-                    RTL_TEXTENCODING_UTF8).getStr());
+                ::rtl::OUStringToOString(aEvent.Message, RTL_TEXTENCODING_UTF8).getStr());
         }
 
         // Listen for disposing events.
@@ -449,6 +448,7 @@ void SAL_CALL Listener::frameAction (con
 
         case frame::FrameAction_COMPONENT_REATTACHED:
             ConnectToController();
+            mrController.GetPageSelector().UpdateAllPages();
             break;
 
         default:
Index: sd/source/ui/slidesorter/controller/SlsSelectionFunction.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/slidesorter/controller/SlsSelectionFunction.cxx,v
retrieving revision 1.15
retrieving revision 1.15.2.2
diff -u -p -u -p -r1.15 -r1.15.2.2
--- sd/source/ui/slidesorter/controller/SlsSelectionFunction.cxx	31 Jan 2005 14:53:30 -0000	1.15
+++ sd/source/ui/slidesorter/controller/SlsSelectionFunction.cxx	11 Feb 2005 15:01:30 -0000	1.15.2.2
@@ -740,6 +740,11 @@ void SelectionFunction::SetCurrentPageAn
 }
 
 #define ANY_MODIFIER(code) code|NO_MODIFIER:case code|SHIFT_MODIFIER: case code|CONTROL_MODIFIER
+#define ANY_PAGE(code) code|NOT_OVER_PAGE:case code|OVER_UNSELECTED_PAGE: case code|OVER_SELECTED_PAGE
+#define ANY_PAGE_AND_MODIFIER(code)         \
+         ANY_PAGE(code|NO_MODIFIER):        \
+    case ANY_PAGE(code|SHIFT_MODIFIER):     \
+    case ANY_PAGE(code|CONTROL_MODIFIER)
 
 /** This method consists of two parts:
     1. Create a numeric code that describes the relevant information of the
@@ -891,30 +896,27 @@ void SelectionFunction::ProcessMouseEven
         // Rectangle selection.
         case BUTTON_DOWN | LEFT_BUTTON | SINGLE_CLICK | NOT_OVER_PAGE | NO_MODIFIER:
             DeselectAllPages();
-            OSL_TRACE("start rectangle selection");
             StartRectangleSelection(aMouseModelPosition);
             break;
 
         case BUTTON_DOWN | LEFT_BUTTON | SINGLE_CLICK | NOT_OVER_PAGE | SHIFT_MODIFIER:
         case BUTTON_DOWN | LEFT_BUTTON | SINGLE_CLICK | NOT_OVER_PAGE | CONTROL_MODIFIER:
-            OSL_TRACE("start rectangle selection2");
             StartRectangleSelection(aMouseModelPosition);
             break;
 
-        case ANY_MODIFIER(MOUSE_MOTION | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | NOT_OVER_PAGE):
-        case ANY_MODIFIER(MOUSE_MOTION | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | OVER_SELECTED_PAGE):
-        case ANY_MODIFIER(MOUSE_MOTION | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | OVER_UNSELECTED_PAGE):
-            OSL_TRACE("update rectangle selection");
+        case ANY_MODIFIER(MOUSE_MOTION | LEFT_BUTTON | SINGLE_CLICK | NOT_OVER_PAGE):
+        case ANY_MODIFIER(MOUSE_MOTION | LEFT_BUTTON | SINGLE_CLICK | OVER_UNSELECTED_PAGE):
+        case ANY_PAGE_AND_MODIFIER(MOUSE_MOTION | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE):
             mrController.GetScrollBarManager().AutoScroll(aMousePosition);
             UpdateRectangleSelection(aMouseModelPosition);
             break;
 
-        case BUTTON_UP | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | NO_MODIFIER:
+        case ANY_PAGE(BUTTON_UP | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | NO_MODIFIER):
             ProcessRectangleSelection(false);
             break;
 
-        case BUTTON_UP | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | SHIFT_MODIFIER:
-        case BUTTON_UP | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | CONTROL_MODIFIER:
+        case ANY_PAGE(BUTTON_UP | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | SHIFT_MODIFIER):
+        case ANY_PAGE(BUTTON_UP | LEFT_BUTTON | SINGLE_CLICK | RECTANGLE_VISIBLE | CONTROL_MODIFIER):
             ProcessRectangleSelection(true);
             break;
 
@@ -956,12 +958,10 @@ void SelectionFunction::DeselectAllPages
 
 void SelectionFunction::StartRectangleSelection (const Point& rMouseModelPosition)
 {
-    mbRectangleSelection = true;
-    OSL_TRACE("starting  rectangle selection at %d %d", 
+    OSL_TRACE("starting  rectangle selection at %d %d",
         rMouseModelPosition.X(), rMouseModelPosition.Y());
 
     mrController.GetView().GetOverlay().GetSelectionRectangleOverlay().Start(rMouseModelPosition);
-    //    mrController.GetView().BegEncirclement (aMouseModelPosition);
 }
 
 
@@ -969,8 +969,8 @@ void SelectionFunction::StartRectangleSe
 
 void SelectionFunction::UpdateRectangleSelection (const Point& rMouseModelPosition)
 {
+    mbRectangleSelection = true;
     mrController.GetView().GetOverlay().GetSelectionRectangleOverlay().Update(rMouseModelPosition);
-    //    mrController.GetView().MovEncirclement(rMouseModelPosition);
 }
 
 
@@ -1156,18 +1156,23 @@ void SelectionFunction::UpdateSubstituti
 
 void SelectionFunction::GotoNextPage (int nOffset)
 {
-    SdPage* pPage = mrController.GetViewShell().GetActualPage();
-    sal_Int32 nIndex = (pPage->GetPageNum()-1) / 2;
-    nIndex += nOffset;
-    USHORT nPageCount = mrController.GetModel().GetPageCount();
-
-    if (nIndex >= nPageCount)
-        nIndex = nPageCount - 1;
-    if (nIndex < 0)
-        nIndex = 0;
-
-    mrController.GetFocusManager().SetFocusedPage(nIndex);
-    mrController.GetPageSelector().SetCurrentPage(nIndex);
+    SdPage* pPage = mrController.GetActualPage();
+    if (pPage != NULL)
+    {
+        sal_Int32 nIndex = (pPage->GetPageNum()-1) / 2;
+        nIndex += nOffset;
+        USHORT nPageCount = mrController.GetModel().GetPageCount();
+
+        if (nIndex >= nPageCount)
+            nIndex = nPageCount - 1;
+        if (nIndex < 0)
+            nIndex = 0;
+
+        mrController.GetFocusManager().SetFocusedPage(nIndex);
+        mrController.GetPageSelector().DeselectAllPages();
+        mrController.GetPageSelector().SelectPage(nIndex);
+        mrController.GetPageSelector().SetCurrentPage(nIndex);
+    }
 }
 
 
Index: sd/source/ui/slidesorter/inc/controller/SlideSorterController.hxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/slidesorter/inc/controller/SlideSorterController.hxx,v
retrieving revision 1.4
retrieving revision 1.4.88.2
diff -u -p -u -p -r1.4 -r1.4.88.2
--- sd/source/ui/slidesorter/inc/controller/SlideSorterController.hxx	26 Nov 2004 20:22:22 -0000	1.4
+++ sd/source/ui/slidesorter/inc/controller/SlideSorterController.hxx	11 Feb 2005 14:27:59 -0000	1.4.88.2
@@ -162,24 +162,33 @@ public:
     */
     ScrollBarManager& GetScrollBarManager (void);
 
-    /** Return the page that currently has the focus or is the first page of
-        the selection.
-        @return
-            When there is no focus and the selection is empty then NULL is
-            returned.
+    /** This method forwards the call to the SlideSorterView and executes
+        pending operations like moving selected pages into the visible area.
     */
-	virtual SdPage*	GetActualPage (void);
+    void Paint (const Rectangle& rRect, ::sd::Window* pWin);
 
-	virtual void FuTemporary (SfxRequest& rRequest);
-	virtual void FuPermanent (SfxRequest& rRequest);
-	virtual void FuSupport (SfxRequest& rRequest);
-    virtual bool Command (
+    /** The name of this method is taken from the ViewShell class.  It
+        returns the page that (hopefully) has currently the attention of the
+        user.
+        @return
+            When the slide sorter is not displayed in the center pane then
+            the current page of the center pane view shell is returned.
+            Other wise the focused page is returned or, if the focus
+            indicator is not currently visible, the first selected page is
+            returned.  If all that fails then NULL is returned.
+    */
+    SdPage* GetActualPage (void);
+
+	void FuTemporary (SfxRequest& rRequest);
+	void FuPermanent (SfxRequest& rRequest);
+	void FuSupport (SfxRequest& rRequest);
+    bool Command (
         const CommandEvent& rEvent, 
         ::sd::Window* pWindow);
 
-	virtual void GetCtrlState (SfxItemSet &rSet);
-	virtual void GetMenuState (SfxItemSet &rSet);
-	virtual void GetStatusBarState (SfxItemSet& rSet);
+	void GetCtrlState (SfxItemSet &rSet);
+	void GetMenuState (SfxItemSet &rSet);
+	void GetStatusBarState (SfxItemSet& rSet);
 
 	void ExecCtrl (SfxRequest& rRequest);
 	void GetAttrState (SfxItemSet& rSet);
@@ -254,16 +263,22 @@ public:
     enum SelectionHint { SH_FIRST, SH_LAST, SH_RECENT };
 
     /** Try to make all currently selected page objects visible, i.e. set
-        the zoom factor and origin so that the page objects lie inside the
-        visible area.
+        the origin so that the page objects lie inside the visible area.
+        When the selection is empty then the visible area is not modified.
         @param eSelectionHint
-            This is an advice on which selected page object is handled with
+            This is an advice on which selected page object to handle with
             the highest priority when the whole selection does not fit in to
             the visible area.
     */
     void MakeSelectionVisible (
         SelectionHint eSelectionHint = SH_RECENT);
 
+    /** Modify the origin of the visible area so that the given rectangle
+        comes into view.  This is done with the smallest change: no
+        scrolling takes place when the given rectangle already lies in the
+        visible area.  Otherwise either the top or the bottom of the given
+        rectangle is aligned with the top or the bottom of the visible area.
+    */
     void MakeRectangleVisible (const Rectangle& rBox);
 
     /** Set the zoom factor.  The given value is clipped against an upper
@@ -357,6 +372,11 @@ private:
         FinishEditModeChange().
     */
     SdPage* mpEditModeChangeMasterPage;
+
+    /** When this flag is set then on the next call to Paint() the selection
+        is moved into the visible area.
+    */
+    bool mbIsMakeSelectionVisiblePending;
 };
 
 } } } // end of namespace ::sd::slidesorter::controller
Index: sd/source/ui/slidesorter/shell/SlideSorterViewShell.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/slidesorter/shell/SlideSorterViewShell.cxx,v
retrieving revision 1.8
retrieving revision 1.8.2.1
diff -u -p -u -p -r1.8 -r1.8.2.1
--- sd/source/ui/slidesorter/shell/SlideSorterViewShell.cxx	31 Jan 2005 14:59:49 -0000	1.8
+++ sd/source/ui/slidesorter/shell/SlideSorterViewShell.cxx	11 Feb 2005 14:33:00 -0000	1.8.2.1
@@ -505,7 +505,7 @@ void SlideSorterViewShell::Paint (
     ::sd::Window* pWindow)
 {
     SetActiveWindow (pWindow);
-    mpSlideSorterView->CompleteRedraw (pWindow, Region(rBBox));
+    mpSlideSorterController->Paint(rBBox,pWindow);
 }
 
 
Index: sd/source/ui/toolpanel/controls/MasterPagesPanel.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/toolpanel/controls/MasterPagesPanel.cxx,v
retrieving revision 1.4
retrieving revision 1.4.2.1
diff -u -p -u -p -r1.4 -r1.4.2.1
--- sd/source/ui/toolpanel/controls/MasterPagesPanel.cxx	31 Jan 2005 14:54:31 -0000	1.4
+++ sd/source/ui/toolpanel/controls/MasterPagesPanel.cxx	10 Feb 2005 09:48:59 -0000	1.4.2.1
@@ -60,7 +60,6 @@
  ************************************************************************/
 
 #include "MasterPagesPanel.hxx"
-#include "../ScrollPanel.hxx"
 #include "CurrentMasterPagesSelector.hxx"
 #include "RecentMasterPagesSelector.hxx"
 #include "AllMasterPagesSelector.hxx"
@@ -77,24 +76,22 @@ namespace sd { namespace toolpanel { nam
 
 
 MasterPagesPanel::MasterPagesPanel (TreeNode* pParent, ViewShellBase& rBase)
-    : SubToolPanel (pParent)
+    : ScrollPanel (pParent)
 {
     SdDrawDocument* pDocument = rBase.GetDocument();
+    controls::MasterPagesSelector* pSelector;
     
-    ScrollPanel* pScrollPanel = new ScrollPanel (this);
-
     // Create a panel with the master pages that are in use by the currently
     // edited document.
     DrawViewShell* pDrawViewShell = static_cast<DrawViewShell*>(
         rBase.GetMainViewShell());
-    controls::MasterPagesSelector* pSelector 
-        = new controls::CurrentMasterPagesSelector (
-            this, 
-            *pDocument,
-            rBase,
-            *pDrawViewShell);
+    pSelector = new controls::CurrentMasterPagesSelector (
+        this, 
+        *pDocument,
+        rBase,
+        *pDrawViewShell);
     pSelector->LateInit();
-    pScrollPanel->AddControl (
+    AddControl (
         ::std::auto_ptr<TreeNode>(pSelector),
         SdResId(STR_TASKPANEL_CURRENT_MASTER_PAGES_TITLE),
         HID_SD_CURRENT_MASTERS);
@@ -106,7 +103,7 @@ MasterPagesPanel::MasterPagesPanel (Tree
         *pDocument,
         rBase);
     pSelector->LateInit();
-    pScrollPanel->AddControl (
+    AddControl (
         ::std::auto_ptr<TreeNode>(pSelector),
         SdResId(STR_TASKPANEL_RECENT_MASTER_PAGES_TITLE),
         HID_SD_RECENT_MASTERS);
@@ -119,12 +116,10 @@ MasterPagesPanel::MasterPagesPanel (Tree
         rBase,
         *pDrawViewShell);
     pSelector->LateInit();
-    pScrollPanel->AddControl (
+    AddControl (
         ::std::auto_ptr<TreeNode>(pSelector),
         SdResId(STR_TASKPANEL_ALL_MASTER_PAGES_TITLE),
         HID_SD_ALL_MASTERS);
-
-    AddControl (::std::auto_ptr<TreeNode>(pScrollPanel));
 	pSelector->SetSmartHelpId( SmartId(HID_SD_TASK_PANE_PREVIEW_ALL) );
 }
 
Index: sd/source/ui/toolpanel/controls/MasterPagesPanel.hxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/toolpanel/controls/MasterPagesPanel.hxx,v
retrieving revision 1.2
retrieving revision 1.2.228.1
diff -u -p -u -p -r1.2 -r1.2.228.1
--- sd/source/ui/toolpanel/controls/MasterPagesPanel.hxx	13 Jul 2004 14:44:41 -0000	1.2
+++ sd/source/ui/toolpanel/controls/MasterPagesPanel.hxx	10 Feb 2005 09:48:38 -0000	1.2.228.1
@@ -62,7 +62,7 @@
 #ifndef SD_TOOLPANEL_CONTROLS_MASTER_PAGES_PANEL_HXX
 #define SD_TOOLPANEL_CONTROLS_MASTER_PAGES_PANEL_HXX
 
-#include "../SubToolPanel.hxx"
+#include "../ScrollPanel.hxx"
 
 namespace sd {
 class ViewShellBase;
@@ -74,8 +74,12 @@ class TreeNode;
 
 namespace sd { namespace toolpanel { namespace controls {
 
+/** The master pages panel combines three master page related panels into
+    one.  This has the benefit that creation of the task pane becomes a
+    little bit simpler and that common scroll bars can be displayed.
+*/
 class MasterPagesPanel
-    : public SubToolPanel
+    : public ScrollPanel
 {
 public:
     MasterPagesPanel (
Index: sd/source/ui/toolpanel/controls/MasterPagesSelector.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/toolpanel/controls/MasterPagesSelector.cxx,v
retrieving revision 1.6
retrieving revision 1.6.2.2
diff -u -p -u -p -r1.6 -r1.6.2.2
--- sd/source/ui/toolpanel/controls/MasterPagesSelector.cxx	31 Jan 2005 14:54:49 -0000	1.6
+++ sd/source/ui/toolpanel/controls/MasterPagesSelector.cxx	9 Feb 2005 17:48:34 -0000	1.6.2.2
@@ -438,9 +438,16 @@ void MasterPagesSelector::AssignMasterPa
             nInsertionIndex = rPageList.back()->GetPageNum();
         }
 
+		SfxUndoManager* pUndoMgr = mrDocument.GetDocSh()->GetUndoManager();
+		if( pUndoMgr )
+			pUndoMgr->EnterListAction(String(SdResId(STR_UNDO_SET_PRESLAYOUT)), String());
+
         // Add copies of the master pages.
         SdPage* pClonedMasterPage = AddMasterPage (&mrDocument, pMasterPage, nInsertionIndex);
-        AddMasterPage (&mrDocument, pNotesMasterPage, nInsertionIndex+1);
+		mrDocument.AddUndo(new SdrUndoNewPage(*pClonedMasterPage));
+
+		SdPage* pClonedNotesMasterPage = AddMasterPage (&mrDocument, pNotesMasterPage, nInsertionIndex+1);
+		mrDocument.AddUndo(new SdrUndoNewPage(*pClonedNotesMasterPage));
 
         // Assign the master pages to the selected pages.
         for (iPage=rPageList.begin(); 
@@ -452,7 +459,10 @@ void MasterPagesSelector::AssignMasterPa
                 sBaseLayoutName,
                 *iPage);
         }
-    }
+
+		if( pUndoMgr )
+			pUndoMgr->LeaveListAction();
+	}
     while (false);
 }
 
Index: sd/source/ui/view/PaneManager.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/PaneManager.cxx,v
retrieving revision 1.13
retrieving revision 1.13.2.2
diff -u -p -u -p -r1.13 -r1.13.2.2
--- sd/source/ui/view/PaneManager.cxx	28 Jan 2005 16:25:42 -0000	1.13
+++ sd/source/ui/view/PaneManager.cxx	8 Feb 2005 11:10:58 -0000	1.13.2.2
@@ -143,7 +143,11 @@ using namespace sd;
 /** Define this variable to destroy unused pane windows.  When undefined
     unused pane windows are hidden.
 */
+#if 0
 #define DESTROY_UNUSED_PANES
+#else
+#undef DESTROY_UNUSED_PANES
+#endif
 
 namespace {
 class ViewShellFactory
@@ -187,7 +191,7 @@ public:
     virtual void Show (void) = 0;
     virtual void Hide (void) = 0;
     ::Window* GetWindow (void);
-    void SetWindow (::Window* pWindow);
+    virtual void SetWindow (::Window* pWindow);
     bool IsVisible (void);
 
 protected:
@@ -217,9 +221,14 @@ public:
     PaneChildWindow (ViewShellBase& rBase, USHORT nChildWindowId);
     virtual void Show (void);
     virtual void Hide (void);
+    virtual void SetWindow (::Window* pWindow);
+
 private:
     ViewShellBase& mrBase;
     USHORT mnChildWindowId;
+    bool mbInitialized;
+
+    void Initialize (void);
 };
 
 
@@ -337,8 +346,8 @@ class PaneConfiguration
 public:
     PaneConfiguration (void);
     PaneConfiguration (
-        ViewShell::ShellType eCenterShellTye,
         ViewShell::ShellType eLeftShellTye,
+        ViewShell::ShellType eCenterShellTye,
         ViewShell::ShellType eRightShellTye);
     PaneConfiguration (const PaneConfiguration& rConfiguration);
 
@@ -347,7 +356,14 @@ public:
     void SetViewShellType (PaneManager::PaneType ePane, ViewShell::ShellType eShellType);
     ViewShell::ShellType GetViewShellType (PaneManager::PaneType ePane) const;
 
-    void SetWindowVisibility (PaneManager::PaneType ePane, bool bVisibility);
+    /** Set the desired visibility of the specified pane.
+        @return
+            Returns whether an update of the UI is necessart to reflect the
+            new value of the configuration.  When the given value is the
+            same as the current one then <FALSE/> is returned to indicate
+            that nothing has to be done.
+    */
+    bool SetWindowVisibility (PaneManager::PaneType ePane, bool bVisibility);
     bool GetWindowVisibility (PaneManager::PaneType ePane) const;
 
 private:
@@ -463,6 +479,17 @@ public:
     PaneConfiguration& GetPaneConfiguration (
         ViewShell::ShellType eCenterPaneShellType);
 
+    /** Return the configuration that currently is in use.  This
+        configuration may not yet be visible when the last request to change
+        it has been made asynchronously and the update has not yet been
+        made.
+        @return
+            The returned pointer is NULL only in rare cases.  When the pane
+            manager has not yet been properly initialized, it has been shut
+            down, or the internal pointer has been incorrectly set.
+    */
+    PaneConfiguration* GetCurrentConfiguration (void) const;
+
     /** The second part of an asynchronous shell change.  This method is
         called as response to an SID_SWITCH_SHELL slot call (these slot
         calls are received by ViewShellBase and forwarded here.)
@@ -528,6 +555,14 @@ private:
         desired values.
     */
     void UpdateConfiguration (void);
+
+    /** Set the configuration of shell types that are associated with the
+        type of view shell of the center pane.
+    */
+    void SetConfiguration (
+        ViewShell::ShellType eCenterShellType,
+        bool bLeftPaneVisible,
+        bool bRightPaneVisible);
 };
 
 } // end of namespace sd
@@ -659,6 +694,26 @@ String PaneManager::GetWindowTitle (Pane
 
 
 
+bool PaneManager::RequestWindowVisibilityChange (
+    PaneType ePane, 
+    bool bVisible,
+    CallMode eCallMode)
+{
+    bool bUpdateNecessary (false);
+    if (mbValid)
+    {
+        bUpdateNecessary = mpImpl->GetCurrentConfiguration()->SetWindowVisibility(
+            ePane,
+            bVisible);
+        if (bUpdateNecessary)
+            mpImpl->RequestUpdateConfiguration(eCallMode);
+    }
+    return bUpdateNecessary;
+}
+
+
+
+
 void PaneManager::HandleModeChangeSlot (ULONG nSlotId, SfxRequest& rRequest)
 {
     if (mbValid)
@@ -677,7 +732,7 @@ bool PaneManager::RequestMainViewShellCh
     {
         bUpdateNecessary = mpImpl->SwitchConfiguration(eType);
         if (bUpdateNecessary)
-            mpImpl->RequestUpdateConfiguration (eCallMode);
+            mpImpl->RequestUpdateConfiguration(eCallMode);
     }
 
     return bUpdateNecessary;
@@ -686,6 +741,27 @@ bool PaneManager::RequestMainViewShellCh
 
 
 
+bool PaneManager::RequestViewShellChange(
+    PaneType ePane, 
+    ViewShell::ShellType eType,
+    CallMode eCallMode)
+{
+    bool bUpdateNecessary (false);
+    if (mbValid)
+    {
+        bUpdateNecessary = mpImpl->SwitchViewShell(ePane,eType);
+        bUpdateNecessary |= mpImpl->GetCurrentConfiguration()->SetWindowVisibility(
+            ePane,
+            eType!=ViewShell::ST_NONE);
+        if (bUpdateNecessary)
+            mpImpl->RequestUpdateConfiguration(eCallMode);
+    }
+    return bUpdateNecessary;
+}
+
+
+
+
 void PaneManager::ExecuteModeChange (SfxRequest& rRequest)
 {
     if (mbValid)
@@ -801,35 +877,66 @@ void PaneFrameWindow::Hide (void)
 
 PaneChildWindow::PaneChildWindow (ViewShellBase& rBase, USHORT nChildWindowId)
     : mrBase(rBase),
-      mnChildWindowId(nChildWindowId)
+      mnChildWindowId(nChildWindowId),
+      mbInitialized(false)
 {
-    SfxChildWindow* pChildWindow = mrBase.GetViewFrame()->GetChildWindow(mnChildWindowId);
-    if (pChildWindow != NULL)
-        mpWindow = pChildWindow->GetWindow();
+    Initialize();
 }
 
 
 
 
-void PaneChildWindow::Show (void)
+void PaneChildWindow::Initialize (void)
 {
-    if (mpWindow == NULL)
+    if ( ! mbInitialized
+        && mrBase.GetViewFrame()->HasChildWindow(mnChildWindowId))
     {
         SfxChildWindow* pChildWindow = mrBase.GetViewFrame()->GetChildWindow(mnChildWindowId);
-        if (pChildWindow == NULL)
+        if (pChildWindow != NULL)
         {
-            // Make the child window visible.
+            pChildWindow->SetHideNotDelete(sal_True);
+            pChildWindow->SetHideAtToggle(sal_True);
+
+            mpWindow = pChildWindow->GetWindow();
+
+            mbInitialized = true;
+        }
+    }
+}
+
+
+
+
+void PaneChildWindow::SetWindow (::Window* pWindow)
+{
+    PaneWindow::SetWindow(pWindow);
+    if (pWindow != NULL)
+    {
+        mbInitialized = false;
+        Initialize();
+    }
+}
+
+
+
+
+void PaneChildWindow::Show (void)
+{
+    if ( ! mbInitialized)
+        Initialize();
+
+        // Make the child window visible.
 #ifdef DESTROY_UNUSED_PANES
-            mrBase.GetViewFrame()->SetChildWindow(mnChildWindowId, TRUE);
+    mrBase.GetViewFrame()->SetChildWindow(mnChildWindowId, TRUE);
 #else
-            mrBase.GetViewFrame()->ShowChildWindow(mnChildWindowId, TRUE);
+    mrBase.GetViewFrame()->SetChildWindow(mnChildWindowId, TRUE);
+    //    mrBase.GetViewFrame()->ShowChildWindow(mnChildWindowId, TRUE);
 #endif
-            pChildWindow = mrBase.GetViewFrame()->GetChildWindow(mnChildWindowId);
-        }
-        if (pChildWindow != NULL)
-            // Get the actual window pointer.
-            mpWindow = pChildWindow->GetWindow();
-    }
+
+    // Get the actual window pointer.
+    SfxChildWindow* pChildWindow = mrBase.GetViewFrame()->GetChildWindow(mnChildWindowId);
+    if (pChildWindow != NULL)
+        mpWindow = pChildWindow->GetWindow();
 
     if (mpWindow != NULL)
         mpWindow->Show();
@@ -840,18 +947,24 @@ void PaneChildWindow::Show (void)
 
 void PaneChildWindow::Hide (void)
 {
+    if ( ! mbInitialized)
+        Initialize();
+
     if (mpWindow != NULL)
-    {
         mpWindow->Hide();
-        mpWindow = NULL;
 
     // Hide the child window.
 #ifdef DESTROY_UNUSED_PANES
-        mrBase.GetViewFrame()->SetChildWindow(mnChildWindowId, FALSE);
+    mrBase.GetViewFrame()->SetChildWindow(mnChildWindowId, FALSE);
 #else
-        mrBase.GetViewFrame()->ShowChildWindow(mnChildWindowId, FALSE);
+    mrBase.GetViewFrame()->SetChildWindow(mnChildWindowId, FALSE);
+    //    mrBase.GetViewFrame()->ShowChildWindow(mnChildWindowId, FALSE);
 #endif
-    }
+
+    // Get the actual window pointer.
+    SfxChildWindow* pChildWindow = mrBase.GetViewFrame()->GetChildWindow(mnChildWindowId);
+    if (pChildWindow != NULL)
+        mpWindow = pChildWindow->GetWindow();
 }
 
 
@@ -1212,8 +1325,8 @@ PaneConfiguration::PaneConfiguration (vo
 
 
 PaneConfiguration::PaneConfiguration (
-    ViewShell::ShellType eCenterShellType,
     ViewShell::ShellType eLeftShellType,
+    ViewShell::ShellType eCenterShellType,
    ViewShell::ShellType eRightShellType)
     : maLeftPane(eLeftShellType, eLeftShellType!=ViewShell::ST_NONE),
       maCenterPane(eCenterShellType, eCenterShellType!=ViewShell::ST_NONE),
@@ -1267,12 +1380,15 @@ ViewShell::ShellType PaneConfiguration::
 
 
 
-void PaneConfiguration::SetWindowVisibility (
+bool PaneConfiguration::SetWindowVisibility (
     PaneManager::PaneType ePane,
     bool bVisibility)
 {
+    bool bUpdateNecessary (false);
     Descriptor& rDescriptor (GetDescriptor(ePane));
+    bUpdateNecessary = (rDescriptor.mbWindowVisibility != bVisibility);
     rDescriptor.mbWindowVisibility = bVisibility;
+    return bUpdateNecessary;
 }
 
 
@@ -1357,26 +1473,20 @@ PaneManager::Implementation::Implementat
       maRightPane(PT_RIGHT, rBase, maEventBroadcaster, ::sd::RightPaneChildWindow::GetChildWindowId())
 {
     // The fall-back configuration.  Used for shutting down the PaneManager.
-    maConfigurationList[ViewShell::ST_NONE] 
-        = PaneConfiguration(ViewShell::ST_NONE, ViewShell::ST_NONE, ViewShell::ST_NONE);
+    SetConfiguration (ViewShell::ST_NONE, false, false);
+
     // Several configurations for Impress.
-    maConfigurationList[ViewShell::ST_IMPRESS] 
-        = PaneConfiguration(ViewShell::ST_IMPRESS, ViewShell::ST_SLIDE_SORTER, ViewShell::ST_TASK_PANE);
-    maConfigurationList[ViewShell::ST_OUTLINE] 
-        = PaneConfiguration(ViewShell::ST_OUTLINE, ViewShell::ST_SLIDE_SORTER, ViewShell::ST_NONE);
-    maConfigurationList[ViewShell::ST_NOTES] 
-        = PaneConfiguration(ViewShell::ST_NOTES, ViewShell::ST_SLIDE_SORTER, ViewShell::ST_TASK_PANE);
-    maConfigurationList[ViewShell::ST_HANDOUT] 
-        = PaneConfiguration(ViewShell::ST_HANDOUT, ViewShell::ST_NONE, ViewShell::ST_TASK_PANE);
-    maConfigurationList[ViewShell::ST_SLIDE_SORTER] 
-        = PaneConfiguration(ViewShell::ST_SLIDE_SORTER, ViewShell::ST_NONE, ViewShell::ST_TASK_PANE);
+    SetConfiguration(ViewShell::ST_IMPRESS, true, true);
+    SetConfiguration(ViewShell::ST_OUTLINE, true, false);
+    SetConfiguration(ViewShell::ST_NOTES, true, true);
+    SetConfiguration(ViewShell::ST_HANDOUT, false, true);
+    SetConfiguration(ViewShell::ST_SLIDE_SORTER, false, true);
+
     // Draw has only one configuration.
-    maConfigurationList[ViewShell::ST_DRAW] 
-        = PaneConfiguration(ViewShell::ST_DRAW, ViewShell::ST_SLIDE_SORTER, ViewShell::ST_NONE);
-    // The full screen presentation.
-    maConfigurationList[ViewShell::ST_PRESENTATION] 
-        = PaneConfiguration(ViewShell::ST_PRESENTATION, ViewShell::ST_NONE, ViewShell::ST_NONE);
+    SetConfiguration(ViewShell::ST_DRAW, true, false);
 
+    // The full screen presentation.
+    SetConfiguration(ViewShell::ST_PRESENTATION, false, false);
 
     mpCurrentConfiguration = &GetPaneConfiguration(eInitialConfiguration);
 
@@ -1386,6 +1496,44 @@ PaneManager::Implementation::Implementat
 
 
 
+void PaneManager::Implementation::SetConfiguration (
+    ViewShell::ShellType eCenterShellType,
+    bool bLeftPaneVisible,
+    bool bRightPaneVisible)
+{
+    // Set the type of the view shells int the left and right panes to
+    // values that avoid construction and destruction of their view shells
+    // when possible.  As a result ST_NONE is used only for the full screen
+    // presentation and the configuration used for shutting down the pane
+    // manager.  For all other configurations the slide sorter and task pane
+    // are used respectively, regardless of whether they are visible or not.
+    ViewShell::ShellType eLeftShellType;
+    ViewShell::ShellType eRightShellType;
+    switch (eCenterShellType)
+    {
+        case ViewShell::ST_NONE:
+        case ViewShell::ST_PRESENTATION:
+            eLeftShellType = ViewShell::ST_NONE;
+            eRightShellType = ViewShell::ST_NONE;
+            break;
+
+        default:
+            eLeftShellType = ViewShell::ST_SLIDE_SORTER;
+            eRightShellType = ViewShell::ST_TASK_PANE;
+            break;
+    }
+    
+    maConfigurationList[eCenterShellType] = PaneConfiguration(
+        eLeftShellType,
+        eCenterShellType,
+        eRightShellType);
+    maConfigurationList[eCenterShellType].SetWindowVisibility(PT_LEFT, bLeftPaneVisible);
+    maConfigurationList[eCenterShellType].SetWindowVisibility(PT_RIGHT, bRightPaneVisible);
+}
+
+
+
+
 PaneManager::Implementation::~Implementation (void)
 {
     MasterPageObserver::Instance().UnregisterDocument (
@@ -1762,27 +1910,19 @@ void PaneManager::Implementation::GetSlo
         switch (nItemId)
         {
             case SID_LEFT_PANE_IMPRESS:
-            {
-                USHORT nId = ::sd::LeftPaneChildWindow::GetChildWindowId();
-                rSet.Put (SfxBoolItem (SID_LEFT_PANE_IMPRESS, pFrame->HasChildWindow(nId)));
-            }
-            break;
-
             case SID_LEFT_PANE_DRAW:
             {
-                USHORT nId = ::sd::LeftPaneChildWindow::GetChildWindowId();
-                rSet.Put (SfxBoolItem (SID_LEFT_PANE_DRAW, pFrame->HasChildWindow(nId)));
+                ::Window* pWindow = GetWindow(PT_LEFT);
+                BOOL bVisible (pWindow!=NULL && pWindow->IsVisible());
+                rSet.Put(SfxBoolItem(nItemId, bVisible));
             }
             break;
 
             case SID_RIGHT_PANE:
             {
-                BOOL bVisible (FALSE);
                 ::Window* pWindow = GetWindow(PT_RIGHT);
-                if (pWindow!=NULL && pWindow->IsVisible())
-                    bVisible = TRUE;
-                USHORT nId = ::sd::RightPaneChildWindow::GetChildWindowId();
-                rSet.Put (SfxBoolItem (SID_RIGHT_PANE, bVisible));
+                BOOL bVisible (pWindow!=NULL && pWindow->IsVisible());
+                rSet.Put(SfxBoolItem(SID_RIGHT_PANE, bVisible));
             }
             break;
             
@@ -1875,7 +2015,10 @@ void PaneManager::Implementation::SetChi
         bShowChildWindow = static_cast<const SfxBoolItem&>(
             pArguments->Get(nSlotId)).GetValue();
     else
-        bShowChildWindow = ! pFrame->HasChildWindow (nChildWindowId);
+    {
+        ::Window* pWindow = GetWindow(ePane);
+        bShowChildWindow = ! (pWindow!=NULL && pWindow->IsVisible());
+    }
     
     // Set the desired visibility state at the current configuration and
     // update it accordingly.
@@ -1975,15 +2118,20 @@ void PaneManager::Implementation::Update
         }
 
         // Now update the side panes.  Note that the visibility of the
-        // windows may change.  Showing a window is done before changing the
-        // shell type so that the shell can access the new window.  Hiding a
-        // window is done after switching the shell type so that the shell
-        // can access the window.
+        // windows may change.  A window is shown before or hidden after the
+        // shell type is changed so that either a new shell can access the
+        // new window or the current shell can access the current window.
+        // The shell type is switched only when the pane is visible
+        // afterwards.  This avoids the constant construction and
+        // destruction of shells just because their panes are temporarily
+        // hidden.
+
         if ( ! bLeftUpToDate)
         {
             if (bShowLeftPane)
                 SetupPaneVisibility(PT_LEFT, true);
-            rLeftPane.SetViewShellType(eLeftType);
+            if (bShowLeftPane)
+                rLeftPane.SetViewShellType(eLeftType);
             if ( ! bShowLeftPane)
                 SetupPaneVisibility(PT_LEFT, false);
         }
@@ -1992,7 +2140,8 @@ void PaneManager::Implementation::Update
         {
             if (bShowRightPane)
                 SetupPaneVisibility(PT_RIGHT, true);
-            rRightPane.SetViewShellType(eRightType);
+            if (bShowRightPane)
+                rRightPane.SetViewShellType(eRightType);
             if ( ! bShowRightPane)
                 SetupPaneVisibility(PT_RIGHT, false);
         }
@@ -2019,6 +2168,14 @@ PaneConfiguration& PaneManager::Implemen
 
 
 
+PaneConfiguration* PaneManager::Implementation::GetCurrentConfiguration (void) const
+{
+    return mpCurrentConfiguration;
+}
+
+
+
+
 void PaneManager::Implementation::SetupPaneVisibility (PaneType ePane, bool bShow)
 {
     bool bValid (mrBase.IsActive());
Index: sd/source/ui/view/PrintManager.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/PrintManager.cxx,v
retrieving revision 1.6
retrieving revision 1.6.228.1
diff -u -p -u -p -r1.6 -r1.6.228.1
--- sd/source/ui/view/PrintManager.cxx	13 Jul 2004 14:52:08 -0000	1.6
+++ sd/source/ui/view/PrintManager.cxx	10 Feb 2005 13:41:51 -0000	1.6.228.1
@@ -300,62 +300,14 @@ USHORT  PrintManager::Print (SfxProgress
 	    nCntrl &= ~EE_CNTRL_ONLINESPELLING;
 	    rOutliner.SetControlWord( nCntrl );
 
-	    // Pruefen des Seitenformates und ggfs. Dialog hochbringen
-	    const SfxItemSet&	rOptions = pPrinter->GetOptions();
-	    SdOptionsPrintItem* pPrintOpts = NULL;
-	    BOOL                bScalePage = TRUE;
-	    BOOL                bTilePage = FALSE;
-	    BOOL                bPrintBooklet = FALSE;
-
-	    if( rOptions.GetItemState( ATTR_OPTIONS_PRINT, FALSE, (const SfxPoolItem**) &pPrintOpts ) == SFX_ITEM_SET )
-	    {
-		    bScalePage = pPrintOpts->IsPagesize();
-		    bPrintBooklet = pPrintOpts->IsBooklet();
-		    pPrintOpts->SetCutPage( FALSE );
-	    }
-	    else
-		    pPrintOpts = NULL;
-
-	    SdPage* pPage = mrViewShell.GetDocument()->GetSdPage( 0, PK_STANDARD );
-	    Size    aPageSize( pPage->GetSize() );
-	    Size    aPrintSize( pPrinter->GetOutputSize() );
-	    long    nPageWidth = aPageSize.Width() - pPage->GetLftBorder() - pPage->GetRgtBorder();
-	    long    nPageHeight = aPageSize.Height() - pPage->GetUppBorder() - pPage->GetLwrBorder();
-	    long    nPrintWidth = aPrintSize.Width();
-	    long    nPrintHeight = aPrintSize.Height();
-	    USHORT  nRet = RET_OK;
-
-        if( !bScalePage && !bTilePage && !bPrintBooklet &&
-		    ( ( nPageWidth > nPrintWidth || nPageHeight > nPrintHeight ) &&
-              ( nPageWidth > nPrintHeight || nPageHeight > nPrintWidth ) ) )
-	    {
-		    //CHINA001 SdPrintDlg aDlg (mrViewShell.GetWindow());
-			SdAbstractDialogFactory* pFact = SdAbstractDialogFactory::Create();//CHINA001
-			DBG_ASSERT(pFact, "SdAbstractDialogFactory fail!");//CHINA001
-			AbstractSdPrintDlg* pDlg = pFact->CreateSdPrintDlg(ResId( DLG_PRINT_WARNINGS ), mrViewShell.GetWindow() );
-			DBG_ASSERT(pDlg, "Dialogdiet fail!");//CHINA001 		    
-			nRet = pDlg->Execute(); //CHINA001 nRet = aDlg.Execute();
-		    if( nRet == RET_OK )
-		    {
-			    USHORT nOption = pDlg->GetAttr(); //CHINA001 USHORT nOption = aDlg.GetAttr();
-
-			    if( nOption == 1 )
-				    pPrintOpts->SetPagesize();
-
-			    // ( nOption == 2 ) ist der Default
-
-			    if( nOption == 3 )
-				    pPrintOpts->SetCutPage();
-		    }
-			delete pDlg; //add by CHINA001 
-	    }
-
-        if( nRet == RET_CANCEL )
-	    {
-            pPrinter->SetPrinterOptions( aOldPrinterOptions );
-		    pPrinter->SetMapMode( aOldMap );
-		    return 0;
-	    }
+        // old place of FitPageToPrinterWithDialog().
+        SdOptionsPrintItem* pPrintOpts = NULL;
+        if (pPrinter->GetOptions().GetItemState(
+            ATTR_OPTIONS_PRINT, FALSE, 
+            (const SfxPoolItem**) &pPrintOpts ) != SFX_ITEM_SET )
+        {
+            pPrintOpts = NULL;
+        }
 
 	    // Wenn wir im Gliederungsmodus sind, muss das Model auf Stand gebracht werden
 	    if (pShell->ISA(OutlineViewShell))
@@ -617,9 +569,15 @@ ErrCode PrintManager::DoPrint (
 {
     ErrCode nResult = ERRCODE_NONE;
 
-    ViewShell* pShell = mrViewShell.GetMainViewShell();
-    if (pShell != NULL)
+    do
     {
+        ViewShell* pShell = mrViewShell.GetMainViewShell();
+        if (pShell == NULL)
+            break;
+
+        if ( ! FitPageToPrinterWithDialog(pPrinter, bSilent))
+            break;
+
         const SdrMarkList& rMarkList = pShell->GetView()->GetMarkedObjectList();
     
         // Retrieve the range of marked pages.
@@ -662,6 +620,7 @@ ErrCode PrintManager::DoPrint (
             RestrictPrintingToSelection (FALSE);
         }
     }
+    while(false);
 
 	return nResult;
 }
@@ -754,4 +713,102 @@ void PrintManager::SetPrintingPageRange 
 }
 
 
+
+
+bool PrintManager::FitPageToPrinterWithDialog (
+    SfxPrinter* pPrinter,
+    bool bSilent)
+{
+    bool bContinuePrinting = true;
+
+    if (pPrinter != NULL)
+    {
+        // Remember old printer values so that they can be restored when
+        // printing is aborted by the user.
+        const PrinterOptions aOldPrinterOptions (pPrinter->GetPrinterOptions());
+        const MapMode aOldMap (pPrinter->GetMapMode());
+
+        // Get values from the priner in order to decide whether to show a
+        // dialog.
+        const SfxItemSet&	rOptions = pPrinter->GetOptions();
+        SdOptionsPrintItem* pPrintOpts = NULL;
+        BOOL                bScalePage = TRUE;
+        BOOL                bTilePage = FALSE;
+        BOOL                bPrintBooklet = FALSE;
+
+        if( rOptions.GetItemState( ATTR_OPTIONS_PRINT, FALSE, (const SfxPoolItem**) &pPrintOpts ) == SFX_ITEM_SET )
+        {
+            bScalePage = pPrintOpts->IsPagesize();
+            bPrintBooklet = pPrintOpts->IsBooklet();
+            pPrintOpts->SetCutPage( FALSE );
+        }
+        else
+            pPrintOpts = NULL;
+
+        SdPage* pPage = mrViewShell.GetDocument()->GetSdPage( 0, PK_STANDARD );
+        Size    aPageSize( pPage->GetSize() );
+        Size    aPrintSize( pPrinter->GetOutputSize() );
+        long    nPageWidth = aPageSize.Width() - pPage->GetLftBorder() - pPage->GetRgtBorder();
+        long    nPageHeight = aPageSize.Height() - pPage->GetUppBorder() - pPage->GetLwrBorder();
+        long    nPrintWidth = aPrintSize.Width();
+        long    nPrintHeight = aPrintSize.Height();
+        USHORT  nRet = RET_OK;
+
+        // When necessary then show a dialog that asks the user how to fit
+        // the pages to be printed to the (smaller) printer pages.
+        if ( !bScalePage 
+            && !bTilePage 
+            && !bPrintBooklet 
+            && ( ( nPageWidth > nPrintWidth || nPageHeight > nPrintHeight ) 
+                && ( nPageWidth > nPrintHeight || nPageHeight > nPrintWidth ) 
+                ) 
+            )
+        {
+            SdAbstractDialogFactory* pFact = SdAbstractDialogFactory::Create();
+            DBG_ASSERT(pFact, "SdAbstractDialogFactory fail!");
+            AbstractSdPrintDlg* pDlg = pFact->CreateSdPrintDlg(ResId( DLG_PRINT_WARNINGS ), mrViewShell.GetWindow() );
+            DBG_ASSERT(pDlg, "Dialogdiet fail!");
+            // Do not show the dialog when the bSilent flag is set.  We do
+            // create the dialog anyway so that we can extract the default
+            // method of mapping internal pages to printer pages from it.
+            if ( ! bSilent)
+                nRet = pDlg->Execute();
+            if( nRet == RET_OK )
+            {
+                switch (pDlg->GetAttr())
+                {
+                    case 1:
+                        pPrintOpts->SetPagesize();
+                        break;
+
+                    case 2:
+                        // Tiling is the default behaviour in
+                        // ViewShell::PrintStdOrNotes().  The poperty of
+                        // pPrintOpts is ignored there so setting it here
+                        // may only lead to unwanted side effects.
+                        break;
+
+                    case 3:
+                        pPrintOpts->SetCutPage();
+                        break;
+                }
+                bContinuePrinting = true;
+            }
+            delete pDlg;
+        }
+
+        // The user has pressed the 'Cancel' button.  Restore the old values and
+        // return a flag to tell the caller to abort printing.
+        if( nRet == RET_CANCEL )
+        {
+            pPrinter->SetPrinterOptions( aOldPrinterOptions );
+            pPrinter->SetMapMode( aOldMap );
+            bContinuePrinting = false;
+        }
+    }
+
+    return bContinuePrinting;
+}
+
+
 } // end of namespace sd
Index: sd/source/ui/view/ViewShellBase.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/ViewShellBase.cxx,v
retrieving revision 1.16
retrieving revision 1.16.2.2
diff -u -p -u -p -r1.16 -r1.16.2.2
--- sd/source/ui/view/ViewShellBase.cxx	28 Jan 2005 15:43:27 -0000	1.16
+++ sd/source/ui/view/ViewShellBase.cxx	10 Feb 2005 13:29:19 -0000	1.16.2.2
@@ -94,6 +94,9 @@
 #ifndef SD_DRAW_CONTROLLER_HXX
 #include "DrawController.hxx"
 #endif
+#ifndef SD_PRINT_MANAGER_HXX
+#include "PrintManager.hxx"
+#endif
 #ifndef _SFXEVENT_HXX
 #include <sfx2/event.hxx>
 #endif
@@ -247,7 +250,7 @@ ViewShellBase::ViewShellBase (
       mpPaneManager (NULL),
       mpDocShell (NULL),
       mpDocument (NULL),
-      maPrintManager (*this),
+      mpPrintManager (new PrintManager(*this)),
       mpFormShellManager(NULL),
       mpEventMultiplexer(NULL)
 {
@@ -309,6 +312,7 @@ ViewShellBase::~ViewShellBase (void)
 
     mpViewShellManager.reset();
     mpPaneManager.reset();
+    mpPrintManager.reset();
 
     SetWindow(NULL);
 }
@@ -623,7 +627,7 @@ ErrCode ViewShellBase::DoVerb (long nVer
 
 SfxPrinter* ViewShellBase::GetPrinter (BOOL bCreate)
 {
-    return maPrintManager.GetPrinter (bCreate);
+    return mpPrintManager->GetPrinter (bCreate);
 }
 
 
@@ -634,7 +638,7 @@ USHORT ViewShellBase::SetPrinter (
 
     USHORT nDiffFlags)
 {
-    return maPrintManager.SetPrinter (pNewPrinter, nDiffFlags);
+    return mpPrintManager->SetPrinter (pNewPrinter, nDiffFlags);
 }
 
 
@@ -642,7 +646,7 @@ USHORT ViewShellBase::SetPrinter (
 
 PrintDialog* ViewShellBase::CreatePrintDialog (::Window *pParent)
 {
-    return maPrintManager.CreatePrintDialog (pParent);
+    return mpPrintManager->CreatePrintDialog (pParent);
 }
 
 
@@ -652,7 +656,7 @@ SfxTabPage*  ViewShellBase::CreatePrintO
     ::Window *pParent,
     const SfxItemSet &rOptions)
 {
-    return maPrintManager.CreatePrintOptionsPage (pParent, rOptions);
+    return mpPrintManager->CreatePrintOptionsPage (pParent, rOptions);
 }
 
 
@@ -660,7 +664,7 @@ SfxTabPage*  ViewShellBase::CreatePrintO
 
 USHORT  ViewShellBase::Print(SfxProgress& rProgress, PrintDialog* pDlg)
 {
-    return maPrintManager.Print (rProgress, pDlg);
+    return mpPrintManager->Print (rProgress, pDlg);
 }
 
 
@@ -671,7 +675,7 @@ ErrCode ViewShellBase::DoPrint (
     PrintDialog* pPrintDialog,
     BOOL bSilent)
 {
-    return maPrintManager.DoPrint (pPrinter, pPrintDialog, bSilent);
+    return mpPrintManager->DoPrint (pPrinter, pPrintDialog, bSilent);
 }
 
 
@@ -682,8 +686,10 @@ USHORT ViewShellBase::SetPrinterOptDlg (
     USHORT nDiffFlags,
     BOOL bShowDialog)
 {
-   return maPrintManager.SetPrinterOptDlg (
-       pNewPrinter, nDiffFlags, bShowDialog);
+   return mpPrintManager->SetPrinterOptDlg (
+       pNewPrinter, 
+       nDiffFlags, 
+       bShowDialog);
 }
 
 
@@ -692,9 +698,12 @@ USHORT ViewShellBase::SetPrinterOptDlg (
 void ViewShellBase::PreparePrint (PrintDialog* pPrintDialog)
 {
     SfxViewShell::PreparePrint (pPrintDialog);
-    return maPrintManager.PreparePrint (pPrintDialog);
+    return mpPrintManager->PreparePrint (pPrintDialog);
 }
 
+
+
+
 void ViewShellBase::UIActivating( SfxInPlaceClient* pClient )
 {
 	ViewShell* pViewShell = mpPaneManager->GetViewShell(PaneManager::PT_CENTER);
@@ -805,9 +814,9 @@ void ViewShellBase::Execute (SfxRequest&
             }
 
             // Set the visibility of the right pane.
-            GetViewFrame()->SetChildWindow (
-                ::sd::RightPaneChildWindow::GetChildWindowId(),
-                bShowToolPanel,
+            GetPaneManager().RequestViewShellChange(
+                PaneManager::PT_RIGHT,
+                ViewShell::ST_TASK_PANE,
                 PaneManager::CM_SYNCHRONOUS);
 
             // Now we can call the tool pane to make the specified panel
Index: sd/source/ui/view/ViewTabBar.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/ViewTabBar.cxx,v
retrieving revision 1.4
retrieving revision 1.4.2.1
diff -u -p -u -p -r1.4 -r1.4.2.1
--- sd/source/ui/view/ViewTabBar.cxx	31 Jan 2005 13:11:38 -0000	1.4
+++ sd/source/ui/view/ViewTabBar.cxx	11 Feb 2005 12:22:02 -0000	1.4.2.1
@@ -207,7 +207,7 @@ void ViewTabBar::ActivatePage (void)
     ViewShell* pViewShell = mrViewShellBase.GetMainViewShell();
     FrameView* pFrameView = pViewShell->GetFrameView();
     pFrameView->SetViewShEditMode (EM_PAGE, pFrameView->GetPageKind());
-    DrawViewShell* pDrawViewShell = static_cast<DrawViewShell*>(pViewShell);
+    DrawViewShell* pDrawViewShell = dynamic_cast<DrawViewShell*>(pViewShell);
     if (pDrawViewShell != NULL)
     {
         pFrameView->SetLayerMode (pDrawViewShell->IsLayerModeActive());
Index: sd/source/ui/view/drviews1.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/drviews1.cxx,v
retrieving revision 1.51
retrieving revision 1.51.2.1
diff -u -p -u -p -r1.51 -r1.51.2.1
--- sd/source/ui/view/drviews1.cxx	28 Jan 2005 16:26:19 -0000	1.51
+++ sd/source/ui/view/drviews1.cxx	7 Feb 2005 18:04:23 -0000	1.51.2.1
@@ -569,6 +569,7 @@ void DrawViewShell::ChangeEditMode(EditM
             if (eEditMode == EM_PAGE)
                 aTabControl.SetCurPageId (nActualPageNum + 1);
 		}
+        /*AF: The LayerDialogChildWindow is not used anymore (I hope).
         if (GetViewFrame()->KnowsChildWindow(
             LayerDialogChildWindow::GetChildWindowId()))
         {
@@ -576,7 +577,7 @@ void DrawViewShell::ChangeEditMode(EditM
                 LayerDialogChildWindow::GetChildWindowId(),
                 IsLayerModeActive());
         }
-
+        */
 		ResetActualLayer();
 
 		Invalidate( SID_PAGEMODE );
Index: sd/source/ui/view/drviews5.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/drviews5.cxx,v
retrieving revision 1.40
retrieving revision 1.40.86.2
diff -u -p -u -p -r1.40 -r1.40.86.2
--- sd/source/ui/view/drviews5.cxx	26 Nov 2004 20:31:35 -0000	1.40
+++ sd/source/ui/view/drviews5.cxx	11 Feb 2005 11:14:22 -0000	1.40.86.2
@@ -97,7 +97,6 @@
 
 #include <sfx2/viewfrm.hxx>
 #include "LayerTabBar.hxx"
-#include "LayerDialogChildWindow.hxx"
 
 #include "strings.hrc"
 #include "res_bmp.hrc"
@@ -194,95 +193,10 @@ void DrawViewShell::Resize (const Point 
 		}
 	}
 
-	sd::Slideshow* pSlideShow = ( mpSlideShow ? mpSlideShow : ( pDrView ? pDrView->GetSlideShow() : NULL ) );
-
     if(mpSlideShow != NULL)
 		mpSlideShow->resize( rSize );
 }
 
-#if 0
-
-/*************************************************************************
-|*
-|* Ersatz fuer AdjustPosSizePixel ab Sfx 248a
-|*
-\************************************************************************/
-
-void DrawViewShell::OuterResizePixel(const Point &rPos, const Size &rSize)
-{
-	if (!mpSlideShow || !mpSlideShow->isFullScreen())
-	{
-		ViewShell::OuterResizePixel(rPos, rSize);
-
-		if ( GetDocSh()->GetCreateMode() == SFX_CREATE_MODE_EMBEDDED )
-		{
-			SetZoomRect( GetDocSh()->GetVisArea(ASPECT_CONTENT) );
-		}
-	}
-
-	sd::Slideshow* pSlideShow = ( mpSlideShow ? mpSlideShow : ( pDrView ? pDrView->GetSlideShow() : NULL ) );
-
-    if( pSlideShow && !pSlideShow->isFullScreen())
-		mpSlideShow->resize( rSize );
-}
-
-
-
-/*************************************************************************
-|*
-|* Ersatz fuer AdjustPosSizePixel ab Sfx 248a
-|*
-\************************************************************************/
-
-void DrawViewShell::InnerResizePixel(const Point &rPos, const Size &rSize)
-{
-	if (!mpSlideShow)
-	{
-		// Da die innere Groesse vorgegeben wird, ist ein Zoomen auf
-		// Seitenbreite nicht erlaubt
-		bZoomOnPage = FALSE;
-
-		ViewShell::InnerResizePixel(rPos, rSize);
-
-		SetZoomRect( GetDocSh()->GetVisArea(ASPECT_CONTENT) );
-	}
-}
-
-/*************************************************************************
-|*
-|* Ersatz fuer AdjustPosSizePixel ab Sfx 248a
-|*
-\************************************************************************/
-
-void DrawViewShell::OuterResizePixel(const Point &rPos, const Size &rSize)
-{
-	if (!mpSlideShow || !mpSlideShow->isFullScreen())
-	{
-		ViewShell::OuterResizePixel(rPos, rSize);
-
-		if ( GetDocSh()->GetCreateMode() == SFX_CREATE_MODE_EMBEDDED )
-		{
-			SetZoomRect( GetDocSh()->GetVisArea(ASPECT_CONTENT) );
-		}
-	}
-
-	sd::Slideshow* pSlideShow = ( mpSlideShow ? mpSlideShow : ( pDrView ? pDrView->GetSlideShow() : NULL ) );
-
-    if( pSlideShow )
-		pSlideShow->resize( rSize );
-}
-
-
-/** This call is simply delegated to the base class.
-*/
-void DrawViewShell::AdjustPosSizePixel(const Point &rNewPos,
-										 const Size &rNewSize)
-{
-    ViewShell::AdjustPosSizePixel (rNewPos, rNewSize);
-}
-#endif
-
-
 void DrawViewShell::ArrangeGUIElements (void)
 {
     // Retrieve the current size (thickness) of the scroll bars.  That is
Index: sd/source/ui/view/drviewse.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/drviewse.cxx,v
retrieving revision 1.51
retrieving revision 1.51.16.3
diff -u -p -u -p -r1.51 -r1.51.16.3
--- sd/source/ui/view/drviewse.cxx	21 Jan 2005 16:38:04 -0000	1.51
+++ sd/source/ui/view/drviewse.cxx	11 Feb 2005 12:28:59 -0000	1.51.16.3
@@ -227,9 +227,6 @@
 #ifndef SD_VIEW_SHELL_BASE_HXX
 #include "ViewShellBase.hxx"
 #endif
-#ifndef SD_LAYER_DIALOG_CHILD_WINDOW_HXX
-#include "LayerDialogChildWindow.hxx"
-#endif
 
 // #97016#
 #ifndef _SD_OPTSITEM_HXX
@@ -251,8 +248,6 @@
 
 #include "Window.hxx"
 
-#include <memory>
-
 
 using namespace ::rtl;
 using namespace ::com::sun::star;
@@ -851,13 +846,15 @@ void DrawViewShell::FuSupport(SfxRequest
                 else
                 {
                     pFrameView->SetPreviousViewShellType(GetShellType());
-                    
-                    std::auto_ptr<Slideshow> pSlideShow(
-                        new Slideshow( this, pDrView, GetDoc() ) );
-                    pSlideShow->setRehearseTimings(
+
+                    mpSlideShow = new Slideshow( this, pDrView, GetDoc() );
+                    mpSlideShow->setRehearseTimings(
                         nSId == SID_REHEARSE_TIMINGS );
-					if (pSlideShow->startShow())
-                        mpSlideShow = pSlideShow.release();
+					if (!mpSlideShow->startShow())
+                    {
+                        delete mpSlideShow;
+                        mpSlideShow = 0;
+                    }
                 }
 			}
 
@@ -1841,9 +1838,10 @@ void DrawViewShell::ShowUIControls (bool
 {
     ViewShell::ShowUIControls (bVisible);
 
-    GetViewFrame()->SetChildWindow(
-        LayerDialogChildWindow::GetChildWindowId(),
-        IsLayerModeActive() && bVisible);
+    //AF: The LayerDialogChildWindow is not used anymore (I hope).
+    //    GetViewFrame()->SetChildWindow(
+    //        LayerDialogChildWindow::GetChildWindowId(),
+    //        IsLayerModeActive() && bVisible);
     aTabControl.Show (bVisible);
 }
 
Index: sd/source/ui/view/presvish.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/ui/view/presvish.cxx,v
retrieving revision 1.22
retrieving revision 1.22.18.2
diff -u -p -u -p -r1.22 -r1.22.18.2
--- sd/source/ui/view/presvish.cxx	21 Jan 2005 16:38:18 -0000	1.22
+++ sd/source/ui/view/presvish.cxx	11 Feb 2005 12:28:22 -0000	1.22.18.2
@@ -109,8 +109,6 @@
 using namespace sd;
 #include "sdslots.hxx"
 
-#include <memory>
-
 
 namespace sd {
 
@@ -223,21 +221,24 @@ void PresentationViewShell::FinishInitia
     SfxUInt16Item aId (SID_CONFIGITEMID, SID_NAVIGATOR);
     GetViewFrame()->GetDispatcher()->Execute(
         SID_SHOWPOPUPS, SFX_CALLMODE_SYNCHRON, &aShowItem, &aId, 0L );
-    GetViewFrame()->Show();
 
-    std::auto_ptr<Slideshow> pSlideShow(
-        new sd::Slideshow( this, GetView(), GetDoc() ) );
-    pSlideShow->setRehearseTimings(
+    mpSlideShow = new sd::Slideshow( this, GetView(), GetDoc() );
+    mpSlideShow->setRehearseTimings(
         rRequest.GetSlot() == SID_REHEARSE_TIMINGS );
     GetActiveWindow()->GrabFocus();
 
     // Start the show.
-    if (pSlideShow->startShow(0)) {
-        mpSlideShow = pSlideShow.release();
+    if (mpSlideShow->startShow(0))
         mbShowStarted = sal_True;
+    else
+    {
+        delete mpSlideShow;
+        mpSlideShow = 0;
     }
-    
-	Activate(TRUE);
+
+    GetViewFrame()->Show();
+
+    Activate(TRUE);
 }
 
 
@@ -337,7 +338,7 @@ void PresentationViewShell::CreateFullSc
             if (pCurrentPage != NULL)
                 nStartPage = (pCurrentPage->GetPageNum() - 1) / 2;
 
-            pBase->GetViewFrame()->Show();
+//            pBase->GetViewFrame()->Show();
             // The following GrabFocus() is responsible for activating the
             // new view shell.  Without it the screen remains blank (under
             // Windows and some Linux variants.)
Index: svx/qa/unoapi/knownissues.xcl
===================================================================
RCS file: /cvs/graphics/svx/qa/unoapi/knownissues.xcl,v
retrieving revision 1.5
retrieving revision 1.5.376.1
diff -u -p -u -p -r1.5 -r1.5.376.1
--- svx/qa/unoapi/knownissues.xcl	11 Aug 2004 15:33:58 -0000	1.5
+++ svx/qa/unoapi/knownissues.xcl	17 Feb 2005 13:46:36 -0000	1.5.376.1
@@ -1,5 +1,6 @@
 ### 100941 ###
 svx.SvxUnoText::com::sun::star::text::XTextRangeMover
+
 ### 101696 ###
 svx.SvxUnoTextRange::com::sun::star::text::XTextRange
 
@@ -16,32 +17,17 @@ svx.AccessiblePresentationShape::com::su
 ### 97139 ###
 svx.SvxUnoTextCursor::com::sun::star::beans::XMultiPropertyStates
 
-### i23298 ###
-svx.SvxDrawPage::com::sun::star::drawing::GenericDrawPage
-
 ### i23461 ###
 svx.SvxDrawPage::com::sun::star::drawing::XMasterPageTarget
 
-### i23462 ###
+### i42513 ###
 svx.SvxGraphicObject::com::sun::star::drawing::GraphicObjectShape
 
-### i26126 ###
-svx.AccessibleControlShape::com::sun::star::accessibility::XAccessibleComponent
-svx.AccessibleControlShape::com::sun::star::accessibility::XAccessibleEventBroadcaster
-svx.AccessibleControlShape::com::sun::star::accessibility::XAccessibleExtendedComponent
-svx.AccessibleControlShape::com::sun::star::accessibility::XAccessible
-svx.AccessibleControlShape::com::sun::star::accessibility::XAccessibleContext
-svx.AccessibleGraphicShape::com::sun::star::accessibility::XAccessibleComponent
-svx.AccessibleGraphicShape::com::sun::star::accessibility::XAccessible
-svx.AccessibleGraphicShape::com::sun::star::accessibility::XAccessibleContext
-svx.AccessibleOLEShape::com::sun::star::accessibility::XAccessibleComponent
-svx.AccessibleOLEShape::com::sun::star::accessibility::XAccessibleEventBroadcaster
-svx.AccessibleOLEShape::com::sun::star::accessibility::XAccessibleExtendedComponent
-svx.AccessibleOLEShape::com::sun::star::accessibility::XAccessible
-svx.AccessibleOLEShape::com::sun::star::accessibility::XAccessibleContext
-svx.AccessiblePageShape::com::sun::star::accessibility::XAccessibleComponent
-svx.AccessiblePageShape::com::sun::star::accessibility::XAccessibleEventBroadcaster
-svx.AccessiblePageShape::com::sun::star::accessibility::XAccessibleExtendedComponent
-svx.AccessiblePageShape::com::sun::star::accessibility::XAccessible
-svx.AccessiblePageShape::com::sun::star::accessibility::XAccessibleContext
-svx.AccessiblePresentationShape::com::sun::star::accessibility::XAccessibleEventBroadcaster
+### i38575 ###
+svx.GraphicExporter::com::sun::star::document::XFilter
+
+### i38579 ###
+svx.SvxUnoText::com::sun::star::text::XTextRangeCompare
+
+### i38623 ###
+svx.SvxUnoTextCursor::com::sun::star::text::XTextRange
Index: svx/qa/unoapi/svx.sce
===================================================================
RCS file: /cvs/graphics/svx/qa/unoapi/svx.sce,v
retrieving revision 1.3
retrieving revision 1.3.622.1
diff -u -p -u -p -r1.3 -r1.3.622.1
--- svx/qa/unoapi/svx.sce	17 Mar 2004 11:24:09 -0000	1.3
+++ svx/qa/unoapi/svx.sce	17 Feb 2005 13:46:52 -0000	1.3.622.1
@@ -1,12 +1,12 @@
 -o svx.SvxShapeDimensioning
 -o svx.SvxShapeControl
 -o svx.SvxGraphicObject
-#i26126#-o svx.AccessibleGraphicShape
-#i26126#-o svx.AccessibleOLEShape
-#i26126#-o svx.AccessiblePageShape
-#i26126#-o svx.AccessiblePresentationGraphicShape
-#i26126#-o svx.AccessiblePresentationOLEShape
-#i26126#-o svx.AccessibleShape
+-o svx.AccessibleGraphicShape
+#i37641#-o svx.AccessibleOLEShape
+#i37641#-o svx.AccessiblePageShape
+-o svx.AccessiblePresentationGraphicShape
+#i37641#-o svx.AccessiblePresentationOLEShape
+#i37641#-o svx.AccessibleShape
 -o svx.GraphicExporter
 -o svx.SvxDrawPage
 -o svx.SvxShape
@@ -24,7 +24,7 @@
 -o svx.SvxUnoTextField
 -o svx.SvxUnoTextRange
 -o svx.SvxUnoTextRangeEnumeration
-#i26126#-o svx.AccessibleControlShape
+#i37641#-o svx.AccessibleControlShape
 -o svx.SvxGraphCtrlAccessibleContext
-#i26126#-o svx.AccessiblePresentationShape
+#i37641#-o svx.AccessiblePresentationShape
 -o svx.AccessibleEditableTextPara
Index: svx/source/svdraw/svdoole2.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/svdraw/svdoole2.cxx,v
retrieving revision 1.50
retrieving revision 1.50.6.1
diff -u -p -u -p -r1.50 -r1.50.6.1
--- svx/source/svdraw/svdoole2.cxx	31 Jan 2005 09:14:42 -0000	1.50
+++ svx/source/svdraw/svdoole2.cxx	10 Feb 2005 11:22:54 -0000	1.50.6.1
@@ -87,6 +87,7 @@
 #endif
 
 #include <comphelper/processfactory.hxx>
+#include <cppuhelper/exc_hlp.hxx>
 #include <unotools/ucbstreamhelper.hxx>
 #include <svtools/filter.hxx>
 #include <toolkit/helper/vclunohelper.hxx>
@@ -96,6 +97,7 @@
 #include <sfx2/ipclient.hxx>
 #include <sfx2/lnkbase.hxx>
 #include <tools/stream.hxx>
+#include <comphelper/anytostring.hxx>
 
 #ifndef _SVDPAGV_HXX
 #include <svdpagv.hxx>
@@ -513,8 +515,16 @@ sal_Bool SdrOle2Obj::UpdateLinkURL_Impl(
 						if ( nCurState != embed::EmbedStates::LOADED )
 							xObjRef->changeState( nCurState );
 					}
-					catch( uno::Exception& )
-					{}
+					catch( ::com::sun::star::uno::Exception& e )
+					{
+						(void)e;
+						DBG_ERROR(
+							(OString("SdrOle2Obj::UpdateLinkURL_Impl(), "
+									"exception caught: ") +
+							rtl::OUStringToOString(
+								comphelper::anyToString( cppu::getCaughtException() ),
+								RTL_TEXTENCODING_UTF8 )).getStr() );
+					}
 				}
 
 				if ( !bResult )
@@ -547,8 +557,15 @@ void SdrOle2Obj::BreakFileLink_Impl()
 				DisconnectFileLink_Impl();
 				mpImpl->maLinkURL = String();
 			}
-			catch( uno::Exception& )
+			catch( ::com::sun::star::uno::Exception& e )
 			{
+				(void)e;
+				DBG_ERROR(
+					(OString("SdrOle2Obj::BreakFileLink_Impl(), "
+							"exception caught: ") +
+					rtl::OUStringToOString(
+						comphelper::anyToString( cppu::getCaughtException() ),
+						RTL_TEXTENCODING_UTF8 )).getStr() );
 			}
 		}
 	}
@@ -592,8 +609,15 @@ void SdrOle2Obj::CheckFileLink_Impl()
 				}
 			}
 		}
-		catch( uno::Exception& )
+		catch( ::com::sun::star::uno::Exception& e )
 		{
+			(void)e;
+			DBG_ERROR(
+				(OString("SdrOle2Obj::CheckFileLink_Impl(), "
+						"exception caught: ") +
+				rtl::OUStringToOString(
+					comphelper::anyToString( cppu::getCaughtException() ),
+					RTL_TEXTENCODING_UTF8 )).getStr() );
 		}
 	}
 }
@@ -610,48 +634,61 @@ void SdrOle2Obj::Connect_Impl()
 {
     if( pModel && mpImpl->aPersistName.Len() )
 	{
-        SfxObjectShell* pPers=pModel->GetPersist();
-        if ( pPers )
+		try
 		{
-            comphelper::EmbeddedObjectContainer& rContainer = pPers->GetEmbeddedObjectContainer();
-            if ( !rContainer.HasEmbeddedObject( mpImpl->aPersistName ) )
-            {
-                // object not known to container document
-                // No object -> disaster!
-                DBG_ASSERT( xObjRef.is(), "No object in connect!");
-                if ( xObjRef.is() )
-                {
-                    // object came from the outside, now add it to the container
-                    ::rtl::OUString aTmp;
-                    rContainer.InsertEmbeddedObject( xObjRef.GetObject(), aTmp );
-                    mpImpl->aPersistName = aTmp;
-                }
-            }
-            else if ( !xObjRef.is() )
-                xObjRef.Assign( rContainer.GetEmbeddedObject( mpImpl->aPersistName ), xObjRef.GetViewAspect() );
+			SfxObjectShell* pPers=pModel->GetPersist();
+			if ( pPers )
+			{
+				comphelper::EmbeddedObjectContainer& rContainer = pPers->GetEmbeddedObjectContainer();
+				if ( !rContainer.HasEmbeddedObject( mpImpl->aPersistName ) )
+				{
+					// object not known to container document
+					// No object -> disaster!
+					DBG_ASSERT( xObjRef.is(), "No object in connect!");
+					if ( xObjRef.is() )
+					{
+						// object came from the outside, now add it to the container
+						::rtl::OUString aTmp;
+						rContainer.InsertEmbeddedObject( xObjRef.GetObject(), aTmp );
+						mpImpl->aPersistName = aTmp;
+					}
+				}
+				else if ( !xObjRef.is() )
+					xObjRef.Assign( rContainer.GetEmbeddedObject( mpImpl->aPersistName ), xObjRef.GetViewAspect() );
 
-            if ( xObjRef.GetObject().is() )
-            {
-                xObjRef.AssignToContainer( &rContainer, mpImpl->aPersistName );
-                mpImpl->mbConnected = true;
-                xObjRef.Lock( TRUE );
-            }
-		}
+				if ( xObjRef.GetObject().is() )
+				{
+					xObjRef.AssignToContainer( &rContainer, mpImpl->aPersistName );
+					mpImpl->mbConnected = true;
+					xObjRef.Lock( TRUE );
+				}
+			}
 
-        if ( xObjRef.is() )
-        {
-            if ( !mpImpl->pStateListener )
-            {
-                mpImpl->pStateListener = new SdrEmbeddedObjectStateListener_Impl( this );
-                mpImpl->pStateListener->acquire();
-            }
+			if ( xObjRef.is() )
+			{
+				if ( !mpImpl->pStateListener )
+				{
+					mpImpl->pStateListener = new SdrEmbeddedObjectStateListener_Impl( this );
+					mpImpl->pStateListener->acquire();
+				}
 
-            xObjRef->addStateChangeListener ( mpImpl->pStateListener );
-            if ( xObjRef->getCurrentState() != embed::EmbedStates::LOADED )
-                GetSdrGlobalData().GetOLEObjCache().InsertObj(this);
+				xObjRef->addStateChangeListener ( mpImpl->pStateListener );
+				if ( xObjRef->getCurrentState() != embed::EmbedStates::LOADED )
+					GetSdrGlobalData().GetOLEObjCache().InsertObj(this);
 
-			CheckFileLink_Impl();
-        }
+				CheckFileLink_Impl();
+			}
+		}
+		catch( ::com::sun::star::uno::Exception& e )
+		{
+			(void)e;
+			DBG_ERROR(
+				(OString("SdrOle2Obj::Connect_Impl(), "
+						"exception caught: ") +
+				rtl::OUStringToOString(
+					comphelper::anyToString( cppu::getCaughtException() ),
+					RTL_TEXTENCODING_UTF8 )).getStr() );
+		}
 	}
 
     //TODO/LATER: wait for definition of MiscStatus RESIZEONPRINTERCHANGE
@@ -714,65 +751,91 @@ void SdrOle2Obj::RemoveListeners_Impl()
 {
     if( xObjRef.is() && mpImpl->aPersistName.Len() )
 	{
-        sal_Int32 nState = xObjRef->getCurrentState();
-        if ( nState != embed::EmbedStates::LOADED )
-        {
-            uno::Reference< util::XModifyBroadcaster > xBC( getXModel(), uno::UNO_QUERY );
-            if( xBC.is() && pModifyListener )
-            {
-                uno::Reference< util::XModifyListener > xListener( pModifyListener );
-                xBC->removeModifyListener( xListener );
-            }
-        }
+		try
+		{
+			sal_Int32 nState = xObjRef->getCurrentState();
+			if ( nState != embed::EmbedStates::LOADED )
+			{
+				uno::Reference< util::XModifyBroadcaster > xBC( getXModel(), uno::UNO_QUERY );
+				if( xBC.is() && pModifyListener )
+				{
+					uno::Reference< util::XModifyListener > xListener( pModifyListener );
+					xBC->removeModifyListener( xListener );
+				}
+			}
+		}
+		catch( ::com::sun::star::uno::Exception& e )
+		{
+			(void)e;
+			DBG_ERROR(
+				(OString("SdrOle2Obj::RemoveListeners_Impl(), "
+						"exception caught: ") +
+				rtl::OUStringToOString(
+					comphelper::anyToString( cppu::getCaughtException() ),
+					RTL_TEXTENCODING_UTF8 )).getStr() );
+		}
 	}
 }
 
 void SdrOle2Obj::Disconnect_Impl()
 {
-    if ( pModel && mpImpl->aPersistName.Len() )
+	try
 	{
-        if( pModel->IsInDestruction() )
-        {
-            // TODO/LATER: here we must assume that the destruction of the model is enough to make clear that we will not
-            // remove the object from the container, even if the DrawingObject itself is not destroyed (unfortunately this
-            // happens later than the destruction of the model, so we can't assert that).
-            //DBG_ASSERT( bInDestruction, "Model is destroyed, but not me?!" );
-            //TODO/LATER: should be make sure that the ObjectShell also forgets the object, because we will close it soon?
-            /*
-            uno::Reference < util::XCloseable > xClose( xObjRef, uno::UNO_QUERY );
-            if ( xClose.is() )
-            {
-                try
-                {
-                    xClose->close( sal_True );
-                }
-                catch ( util::CloseVetoException& )
-                {
-                    // there's still someone who needs the object!
-                }
-            }
+		if ( pModel && mpImpl->aPersistName.Len() )
+		{
+			if( pModel->IsInDestruction() )
+			{
+				// TODO/LATER: here we must assume that the destruction of the model is enough to make clear that we will not
+				// remove the object from the container, even if the DrawingObject itself is not destroyed (unfortunately this
+				// happens later than the destruction of the model, so we can't assert that).
+				//DBG_ASSERT( bInDestruction, "Model is destroyed, but not me?!" );
+				//TODO/LATER: should be make sure that the ObjectShell also forgets the object, because we will close it soon?
+				/*
+				uno::Reference < util::XCloseable > xClose( xObjRef, uno::UNO_QUERY );
+				if ( xClose.is() )
+				{
+					try
+					{
+						xClose->close( sal_True );
+					}
+					catch ( util::CloseVetoException& )
+					{
+						// there's still someone who needs the object!
+					}
+				}
 
-            xObjRef = NULL;*/
-        }
-        else if ( xObjRef.is() )
+				xObjRef = NULL;*/
+			}
+			else if ( xObjRef.is() )
+			{
+				SfxObjectShell* pPers = pModel->GetPersist();
+				if ( pPers )
+				{
+					// remove object, but don't close it (that's up to someone else)
+					comphelper::EmbeddedObjectContainer& rContainer = pPers->GetEmbeddedObjectContainer();
+					xObjRef.AssignToContainer( NULL, mpImpl->aPersistName );
+					rContainer.RemoveEmbeddedObject( xObjRef.GetObject(), sal_False);
+					DisconnectFileLink_Impl();
+				}
+			}
+		}
+
+		if ( xObjRef.is() && mpImpl->pStateListener )
 		{
-            SfxObjectShell* pPers = pModel->GetPersist();
-            if ( pPers )
-            {
-                // remove object, but don't close it (that's up to someone else)
-                comphelper::EmbeddedObjectContainer& rContainer = pPers->GetEmbeddedObjectContainer();
-                xObjRef.AssignToContainer( NULL, mpImpl->aPersistName );
-                rContainer.RemoveEmbeddedObject( xObjRef.GetObject(), sal_False);
-				DisconnectFileLink_Impl();
-            }
+			xObjRef->removeStateChangeListener ( mpImpl->pStateListener );
+			GetSdrGlobalData().GetOLEObjCache().RemoveObj(this);
 		}
 	}
-
-    if ( xObjRef.is() && mpImpl->pStateListener )
-    {
-        xObjRef->removeStateChangeListener ( mpImpl->pStateListener );
-        GetSdrGlobalData().GetOLEObjCache().RemoveObj(this);
-    }
+	catch( ::com::sun::star::uno::Exception& e )
+	{
+		(void)e;
+		DBG_ERROR(
+			(OString("SdrOle2Obj::Disconnect_Impl(), "
+					"exception caught: ") +
+			rtl::OUStringToOString(
+				comphelper::anyToString( cppu::getCaughtException() ),
+				RTL_TEXTENCODING_UTF8 )).getStr() );
+	}
 
 	mpImpl->mbConnected = false;
 }
@@ -797,25 +860,37 @@ void SdrOle2Obj::SetModel(SdrModel* pNew
 
     if( pDestPers && pSrcPers )
     {
-        // move the objects' storage; ObjectRef remains the same, but PersistName may change
-        ::rtl::OUString aTmp;
-        comphelper::EmbeddedObjectContainer& rContainer = pSrcPers->GetEmbeddedObjectContainer();
-        uno::Reference < embed::XEmbeddedObject > xObj = rContainer.GetEmbeddedObject( mpImpl->aPersistName );
-        DBG_ASSERT( !xObjRef.is() || xObjRef.GetObject() == xObj, "Wrong object identity!" );
-        if ( xObj.is() )
-        {
-            pDestPers->GetEmbeddedObjectContainer().CopyEmbeddedObject( xObj, aTmp );
-
-			if ( xObjRef.is() )
+		try
+		{
+			// move the objects' storage; ObjectRef remains the same, but PersistName may change
+			::rtl::OUString aTmp;
+			comphelper::EmbeddedObjectContainer& rContainer = pSrcPers->GetEmbeddedObjectContainer();
+			uno::Reference < embed::XEmbeddedObject > xObj = rContainer.GetEmbeddedObject( mpImpl->aPersistName );
+			DBG_ASSERT( !xObjRef.is() || xObjRef.GetObject() == xObj, "Wrong object identity!" );
+			if ( xObj.is() )
 			{
-				// if the object already assigned to the helper the new one must be assigned 
-				xObjRef.Clear();
-			}
+				pDestPers->GetEmbeddedObjectContainer().CopyEmbeddedObject( xObj, aTmp );
 
-            mpImpl->aPersistName = aTmp;
-        }
+				if ( xObjRef.is() )
+				{
+					// if the object already assigned to the helper the new one must be assigned 
+					xObjRef.Clear();
+				}
 
-        DBG_ASSERT( aTmp.getLength(), "Copying embedded object failed!" );
+				mpImpl->aPersistName = aTmp;
+			}
+	        DBG_ASSERT( aTmp.getLength(), "Copying embedded object failed!" );
+		}
+		catch( ::com::sun::star::uno::Exception& e )
+		{
+			(void)e;
+			DBG_ERROR(
+				(OString("SdrOle2Obj::SetModel(), "
+						"exception caught: ") +
+				rtl::OUStringToOString(
+					comphelper::anyToString( cppu::getCaughtException() ),
+					RTL_TEXTENCODING_UTF8 )).getStr() );
+		}
     }
 
 	SdrRectObj::SetModel( pNewModel );
@@ -1226,6 +1301,16 @@ void SdrOle2Obj::operator=(const SdrObje
                 {
                     // setting of VisArea not necessary for objects that don't cache it in loaded state
                 }
+				catch( ::com::sun::star::uno::Exception& e )
+				{
+					(void)e;
+					DBG_ERROR(
+						(OString("SdrOle2Obj::operator=(), "
+								"exception caught: ") +
+						rtl::OUStringToOString(
+							comphelper::anyToString( cppu::getCaughtException() ),
+							RTL_TEXTENCODING_UTF8 )).getStr() );
+				}
             }
         }
 	}
@@ -1413,9 +1498,16 @@ BOOL SdrOle2Obj::Unload()
                     xObjRef->changeState( embed::EmbedStates::LOADED );
                     bUnloaded = TRUE;
                 }
-                catch ( uno::Exception& )
-                {
-                }
+				catch( ::com::sun::star::uno::Exception& e )
+				{
+					(void)e;
+					DBG_ERROR(
+						(OString("SdrOle2Obj::Unload=(), "
+								"exception caught: ") +
+						rtl::OUStringToOString(
+							comphelper::anyToString( cppu::getCaughtException() ),
+							RTL_TEXTENCODING_UTF8 )).getStr() );
+				}
             }
         }
 	}
