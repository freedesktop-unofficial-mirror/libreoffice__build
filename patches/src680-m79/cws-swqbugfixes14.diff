Index: xmloff/inc/XMLFootnoteConfigurationImportContext.hxx
===================================================================
RCS file: /cvs/xml/xmloff/inc/XMLFootnoteConfigurationImportContext.hxx,v
retrieving revision 1.4
retrieving revision 1.4.158.1
diff -u -p -u -p -r1.4 -r1.4.158.1
--- xmloff/inc/XMLFootnoteConfigurationImportContext.hxx	13 Jul 2004 07:55:05 -0000	1.4
+++ xmloff/inc/XMLFootnoteConfigurationImportContext.hxx	31 Jan 2005 14:55:05 -0000	1.4.158.1
@@ -112,8 +112,8 @@ public:
 
 	TYPEINFO();
 
-	XMLFootnoteConfigurationImportContext( 
-		SvXMLImport& rImport, 
+	XMLFootnoteConfigurationImportContext(
+		SvXMLImport& rImport,
 		sal_uInt16 nPrfx,
 		const ::rtl::OUString& rLName,
 		const ::com::sun::star::uno::Reference<
@@ -127,20 +127,21 @@ public:
 			::com::sun::star::xml::sax::XAttributeList> & xAttrList );
 
 	/// for footnotes, also parse begin and end notices
-	virtual SvXMLImportContext *CreateChildContext( 
+	virtual SvXMLImportContext *CreateChildContext(
 		USHORT nPrefix,
 		const ::rtl::OUString& rLocalName,
-		const ::com::sun::star::uno::Reference< 
+		const ::com::sun::star::uno::Reference<
 			::com::sun::star::xml::sax::XAttributeList> & xAttrList );
 
 	/// get token map for attributes
 	const SvXMLTokenMap& GetFtnConfigAttrTokenMap();
 
-	/// set configuration at document; calls ProcessSettings
-	/// Uses CreateAndInsertLate() to ensure that all styles it references 
-	/// have been set.
-	virtual void XMLFootnoteConfigurationImportContext::CreateAndInsertLate( 
+    /// set configuration at document; calls ProcessSettings
+    // --> OD 2005-01-31 #i40579# - move code from <CreateAndInsertLate(..)>
+    // to <Finish(..)>, because at this time all styles it references have been set.
+    virtual void XMLFootnoteConfigurationImportContext::Finish(
 		sal_Bool bOverwrite );
+    // <--
 
 	/// set configuration at document
 	void ProcessSettings(
Index: xmloff/source/text/XMLFootnoteConfigurationImportContext.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/text/XMLFootnoteConfigurationImportContext.cxx,v
retrieving revision 1.13
retrieving revision 1.13.158.1
diff -u -p -u -p -r1.13 -r1.13.158.1
--- xmloff/source/text/XMLFootnoteConfigurationImportContext.cxx	13 Jul 2004 08:31:25 -0000	1.13
+++ xmloff/source/text/XMLFootnoteConfigurationImportContext.cxx	31 Jan 2005 14:56:46 -0000	1.13.158.1
@@ -75,7 +75,7 @@
 #include <tools/debug.hxx>
 #endif
 
-#ifndef _XMLOFF_NMSPMAP_HXX 
+#ifndef _XMLOFF_NMSPMAP_HXX
 #include "nmspmap.hxx"
 #endif
 
@@ -111,7 +111,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #endif
 
-#ifndef _COM_SUN_STAR_TEXT_XFOOTNOTE_HPP_ 
+#ifndef _COM_SUN_STAR_TEXT_XFOOTNOTE_HPP_
 #include <com/sun/star/text/XFootnote.hpp>
 #endif
 
@@ -154,7 +154,7 @@ public:
 	TYPEINFO();
 
 	XMLFootnoteConfigHelper(
-		SvXMLImport& rImport, 
+		SvXMLImport& rImport,
 		sal_uInt16 nPrfx,
 		const OUString& rLName,
 		XMLFootnoteConfigurationImportContext& rConfigImport,
@@ -168,7 +168,7 @@ public:
 TYPEINIT1( XMLFootnoteConfigHelper, SvXMLImportContext );
 
 XMLFootnoteConfigHelper::XMLFootnoteConfigHelper(
-	SvXMLImport& rImport, 
+	SvXMLImport& rImport,
 	sal_uInt16 nPrfx,
 	const OUString& rLName,
 	XMLFootnoteConfigurationImportContext& rConfigImport,
@@ -206,8 +206,8 @@ void XMLFootnoteConfigHelper::Characters
 
 TYPEINIT1( XMLFootnoteConfigurationImportContext, SvXMLStyleContext );
 
-XMLFootnoteConfigurationImportContext::XMLFootnoteConfigurationImportContext( 
-	SvXMLImport& rImport, 
+XMLFootnoteConfigurationImportContext::XMLFootnoteConfigurationImportContext(
+	SvXMLImport& rImport,
 	sal_uInt16 nPrfx,
 	const OUString& rLocalName,
 	const Reference<XAttributeList> & xAttrList) :
@@ -250,7 +250,7 @@ XMLFootnoteConfigurationImportContext::X
 	{
 		OUString sLocalName;
 		sal_uInt16 nPrefix = GetImport().GetNamespaceMap().
-			GetKeyByAttrName( xAttrList->getNameByIndex(nAttr), 
+			GetKeyByAttrName( xAttrList->getNameByIndex(nAttr),
 							  &sLocalName );
 		if( XML_NAMESPACE_TEXT == nPrefix && IsXMLToken( sLocalName,
 														XML_NOTE_CLASS ) )
@@ -271,7 +271,7 @@ XMLFootnoteConfigurationImportContext::~
     delete pAttrTokenMap;
 }
 
-enum XMLFtnConfigToken 
+enum XMLFtnConfigToken
 {
 	XML_TOK_FTNCONFIG_CITATION_STYLENAME,
 	XML_TOK_FTNCONFIG_ANCHOR_STYLENAME,
@@ -308,9 +308,9 @@ static __FAR_DATA SvXMLTokenMapEntry aTe
 };
 
 const SvXMLTokenMap&
-	XMLFootnoteConfigurationImportContext::GetFtnConfigAttrTokenMap() 
+	XMLFootnoteConfigurationImportContext::GetFtnConfigAttrTokenMap()
 {
-	if (NULL == pAttrTokenMap) 
+	if (NULL == pAttrTokenMap)
 	{
 		pAttrTokenMap = new SvXMLTokenMap(aTextFieldAttrTokenMap);
 	}
@@ -334,7 +334,7 @@ void XMLFootnoteConfigurationImportConte
 	{
 		OUString sLocalName;
 		sal_uInt16 nPrefix = GetImport().GetNamespaceMap().
-			GetKeyByAttrName( xAttrList->getNameByIndex(nAttr), 
+			GetKeyByAttrName( xAttrList->getNameByIndex(nAttr),
 							  &sLocalName );
 		OUString sValue = xAttrList->getValueByIndex(nAttr);
 		switch (GetFtnConfigAttrTokenMap().Get(nPrefix, sLocalName))
@@ -375,7 +375,7 @@ void XMLFootnoteConfigurationImportConte
 			case XML_TOK_FTNCONFIG_START_AT:
 			{
 				sal_uInt16 nTmp;
-				if (SvXMLUnitConverter::convertEnum(nTmp, sValue, 
+				if (SvXMLUnitConverter::convertEnum(nTmp, sValue,
 													aFootnoteNumberingMap))
 				{
 					nNumbering = nTmp;
@@ -391,7 +391,7 @@ void XMLFootnoteConfigurationImportConte
 	}
 }
 
-SvXMLImportContext *XMLFootnoteConfigurationImportContext::CreateChildContext( 
+SvXMLImportContext *XMLFootnoteConfigurationImportContext::CreateChildContext(
 	USHORT nPrefix,
 	const OUString& rLocalName,
 	const Reference<XAttributeList> & xAttrList )
@@ -402,14 +402,14 @@ SvXMLImportContext *XMLFootnoteConfigura
 	{
 		if (XML_NAMESPACE_TEXT == nPrefix)
 		{
-			if ( IsXMLToken( rLocalName, 
+			if ( IsXMLToken( rLocalName,
                              XML_FOOTNOTE_CONTINUATION_NOTICE_FORWARD ) )
 			{
 				pContext = new XMLFootnoteConfigHelper(GetImport(),
 													   nPrefix, rLocalName,
 													   *this, sal_False);
 			}
-			else if ( IsXMLToken( rLocalName, 
+			else if ( IsXMLToken( rLocalName,
                                   XML_FOOTNOTE_CONTINUATION_NOTICE_BACKWARD ) )
 			{
 				pContext = new XMLFootnoteConfigHelper(GetImport(),
@@ -425,8 +425,8 @@ SvXMLImportContext *XMLFootnoteConfigura
 	if (pContext == NULL)
 	{
 		// default: delegate to super class
-		pContext = SvXMLStyleContext::CreateChildContext(nPrefix, 
-														 rLocalName, 
+		pContext = SvXMLStyleContext::CreateChildContext(nPrefix,
+														 rLocalName,
 														 xAttrList);
 	}
 
@@ -434,10 +434,12 @@ SvXMLImportContext *XMLFootnoteConfigura
 }
 
 
-void XMLFootnoteConfigurationImportContext::CreateAndInsertLate( 
-	sal_Bool bOverwrite )
+// --> OD 2005-01-31 #i40597# - rename method <CreateAndInsertLate(..)> to
+// <Finish(..)>
+void XMLFootnoteConfigurationImportContext::Finish( sal_Bool bOverwrite )
+// <--
 {
-	
+
 	if (bOverwrite)
 	{
 		if (bIsEndnote)
@@ -469,28 +471,28 @@ void XMLFootnoteConfigurationImportConte
 
 	if (sCitationStyle.getLength() > 0)
 	{
-		aAny <<= GetImport().GetStyleDisplayName( 
+		aAny <<= GetImport().GetStyleDisplayName(
 						XML_STYLE_FAMILY_TEXT_TEXT, sCitationStyle );
 		rConfig->setPropertyValue(sPropertyCharStyleName, aAny);
 	}
 
 	if (sAnchorStyle.getLength() > 0)
 	{
-		aAny <<= GetImport().GetStyleDisplayName( 
+		aAny <<= GetImport().GetStyleDisplayName(
 						XML_STYLE_FAMILY_TEXT_TEXT, sAnchorStyle );
 		rConfig->setPropertyValue(sPropertyAnchorCharStyleName, aAny);
 	}
 
 	if (sPageStyle.getLength() > 0)
 	{
-		aAny <<= GetImport().GetStyleDisplayName( 
+		aAny <<= GetImport().GetStyleDisplayName(
 						XML_STYLE_FAMILY_MASTER_PAGE, sPageStyle );
 		rConfig->setPropertyValue(sPropertyPageStyleName, aAny);
 	}
 
 	if (sDefaultStyle.getLength() > 0)
 	{
-		aAny <<= GetImport().GetStyleDisplayName( 
+		aAny <<= GetImport().GetStyleDisplayName(
 						XML_STYLE_FAMILY_TEXT_PARAGRAPH, sDefaultStyle );
 		rConfig->setPropertyValue(sPropertyParagraphStyleName, aAny);
 	}
@@ -526,7 +528,7 @@ void XMLFootnoteConfigurationImportConte
 	}
 }
 
-void XMLFootnoteConfigurationImportContext::SetBeginNotice( 
+void XMLFootnoteConfigurationImportContext::SetBeginNotice(
 	OUString sText)
 {
 	sBeginNotice = sText;
@@ -537,5 +539,3 @@ void XMLFootnoteConfigurationImportConte
 {
 	sEndNotice = sText;
 }
-
-
Index: sw/inc/anchoredobject.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/anchoredobject.hxx,v
retrieving revision 1.10
retrieving revision 1.10.4.1
diff -u -p -u -p -r1.10 -r1.10.4.1
--- sw/inc/anchoredobject.hxx	21 Jan 2005 10:26:23 -0000	1.10
+++ sw/inc/anchoredobject.hxx	28 Jan 2005 12:34:28 -0000	1.10.4.1
@@ -533,6 +533,8 @@ class SwAnchoredObject
             Usage: Needed layout information for WW8 export
 
             @author OD
+
+            @return Point - determined relative position
         */
         Point GetRelPosToAnchorFrm() const;
 
@@ -541,10 +543,26 @@ class SwAnchoredObject
 
             OD 2005-01-06 #i30669#
             Usage: Needed layout information for WW8 export
+            OD 2005-01-27 #i33818# - add parameters <_bFollowTextFlow> and
+            <_obRelToTableCell>
+            If <_bFollowTextFlow> is set and object is anchored inside table,
+            the position relative to the table cell is determined. Output
+            parameter <_obRelToTableCell> reflects this situation
 
             @author OD
+
+            @param _bFollowTextFlow
+            input parameter - boolean indicating, if the anchored object has to
+            follow the text flow.
+
+            @param _obRelToTableCell
+            output parameter - boolean indicating, the determine position is
+            relative to the table cell
+
+            @return Point - determined relative position
         */
-        Point GetRelPosToPageFrm() const;
+        Point GetRelPosToPageFrm( const bool _bFollowTextFlow,
+                                  bool& _obRelToTableCell ) const;
 
         /** method to determine position of anchored object relative to
             anchor character
@@ -553,6 +571,8 @@ class SwAnchoredObject
             Usage: Needed layout information for WW8 export
 
             @author OD
+
+            @return Point - determined relative position
         */
         Point GetRelPosToChar() const;
 
@@ -563,6 +583,8 @@ class SwAnchoredObject
             Usage: Needed layout information for WW8 export
 
             @author OD
+
+            @return Point - determined relative position
         */
         Point GetRelPosToLine() const;
 };
Index: sw/inc/crsrsh.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/crsrsh.hxx,v
retrieving revision 1.30
retrieving revision 1.30.144.1
diff -u -p -u -p -r1.30 -r1.30.144.1
--- sw/inc/crsrsh.hxx	9 Nov 2004 13:42:44 -0000	1.30
+++ sw/inc/crsrsh.hxx	31 Jan 2005 13:01:05 -0000	1.30.144.1
@@ -398,6 +398,10 @@ protected:
     FASTBOOL _SelTblRowOrCol( bool bRow, bool bRowSimple = false );
     // <--
 
+    // --> FME 2005-01-31 #i41424# Only update the marked number levels if necessary
+    bool SetInFrontOfLabel( FASTBOOL bNew );
+    // <--
+
 public:
 	TYPEINFO();
 	SwCrsrShell( SwDoc& rDoc, Window *pWin,
Index: sw/inc/ndtxt.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/ndtxt.hxx,v
retrieving revision 1.34
retrieving revision 1.34.62.2
diff -u -p -u -p -r1.34 -r1.34.62.2
--- sw/inc/ndtxt.hxx	5 Jan 2005 11:46:24 -0000	1.34
+++ sw/inc/ndtxt.hxx	2 Feb 2005 08:12:19 -0000	1.34.62.2
@@ -5,6 +5,9 @@
  *  $Revision$
  *
  *  last change: $Author$ $Date$
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
  *
  *  The Contents of this file are made available subject to the terms of
  *  either of the following licenses
@@ -301,9 +304,31 @@ public:
 	// (Methode steht im ndcopy.cxx!!)
 	void CopyCollFmt( SwTxtNode& rDestNd );
 
-	// Numerierung
-	const SwNodeNum* UpdateNum( const SwNodeNum& );
-	SwNumRule *GetNumRule() const;
+
+    //
+    // BEGIN OF BULLET/NUMBERING/OUTLINE STUFF:
+    //
+
+    /**
+       Updates SwNodeNum of this node.
+
+       @param rNum     SwNodeNum to be set
+
+       Copies rNum to this node's SwNodeNum.
+
+       EXCEPTION: If the level of rNum is NO_NUMBERING the SwNodeNum
+       is deleted.
+
+       @return pointer to this node's SwNodeNum after update
+     */
+    const SwNodeNum* UpdateNum( const SwNodeNum& rNum);
+
+    /**
+       Returns numbering rule of this text node.
+
+       @return numbering rule of this text node or NULL if none is set
+     */
+    SwNumRule *GetNumRule() const;
 
     /**
        Returns number of this node.
@@ -325,10 +350,9 @@ public:
                         - FALSE: do not care about numrule's validity
 
        @return     outline number of this node
-    */       
+    */
 	const SwNodeNum* GetOutlineNum(BOOL bUpdate = FALSE) const;
 
-    // ->#i36903#
     /**
        Return non-outline number of this text node.
 
@@ -346,21 +370,192 @@ public:
        @retval FALSE     else
      */
     BOOL IsOutline() const;
-    // <- #i36903#
 
-    BOOL MayBeNumbered() const; // #i23730#
-	void NumRuleChgd();					// Frames benachrichtigen
-	XubString GetNumString() const;		// returnt Outline oder Num - String
+    /** -> #i23730#
+
+        Returns if this text node may be numbered.
+
+        A text node may be numbered if
+          - it has no SwNodeNum
+          - it has a SwNodeNum and it has a numbering rule and the according
+            SwNumFmt defines a numbering type that is an enumeration.
+
+       @retval TRUE      this text node may be numbered
+       @retval FALSE     else
+     */
+    BOOL MayBeNumbered() const;
+
+    /**
+       Notify this textnode that its numbering rule has changed.
+     */
+    void NumRuleChgd();
+
+    /**
+       Returns outline of numbering string
+     */
+    XubString GetNumString() const;
+
+    /**
+       Returns the additional indents of this text node and its numbering.
+
+       @param bTxtLeft  ???
+
+       @return additional indents
+     */
 	long GetLeftMarginWithNum( BOOL bTxtLeft = FALSE ) const;
-	BOOL GetFirstLineOfsWithNum( short& rFirstOffset ) const;
 
-#ifdef VERTICAL_LAYOUT
+    /**
+       Returns the combined first line indent of this text node and
+       its numbering.
+
+       @param the first line indent of this text node taking the
+               numbering into account (return parameter)
+
+       If the paragraph has a SwNodeNum and it has a numbering rule:
+         - if the number is not shown (! IsNum()) the first line offset is 0
+         - else if old numbering is active the first line offset is the first
+              line offset of the numbering (aka spacing to text).
+         - else the first line offset is the sum of the text node's first line
+              offset and that of the numbering.
+
+       @retval TRUE   this node has SwNodeNum and has numbering rule
+       @retval FALSE  else
+     */
+    BOOL GetFirstLineOfsWithNum( short& rFirstOffset ) const;
+
+    /** -> #i29560
+        Returns if this text node has a number.
+
+        This text node has a number if it has a SwNodeNum and a
+        numbering rule and the numbering format specified for the
+        level of the SwNodeNum is of an enumeration type.
+
+        @retval TRUE    This text node has a number.
+        @retval FALSE   else
+     */
+    BOOL HasNumber() const;
+
+    /** -> #i29560
+        Returns if this text node has a bullet.
+
+        This text node has a bullet if it has a SwNodeNum and a
+        numbering rule and the numbering format specified for the
+        level of the SwNodeNum is of a bullet type.
+
+        @retval TRUE    This text node has a bullet.
+        @retval FALSE   else
+     */
+    BOOL HasBullet() const;
+
+    /** -> #i27615#
+        Returns is this text node is numbered.
+
+        This node is numbered if it has a SwNodeNum and it has a
+        numbering rule and has not a hidden SwNodeNum.
+
+        ATTENTION: Returns TRUE even if the SwNumFmt has type
+        SVX_NUM_NUMBER_NONE.
+
+        @retval TRUE      This node is numbered.
+        @retval FALSE     else
+     */
+    BOOL IsNumbered() const;
+
+    /** -> #i27615#
+        Returns if this text node has a marked label.
+
+        This text node has a marked label if it has a label and it has
+        a numbering rule and the level of the label is marked in the
+        numbering rule.
+
+        @retval TRUE       This text node has a marked label.
+        @retval FALSE      else
+     */
+    BOOL HasMarkedLabel() const;
+
+    /**
+       Returns the numbering level of this text node.
+
+       The level returned is the real level, no flags included.
+
+       @return the level of this node or NO_NUMBERING if it has no
+               numbering label.
+     */
+    BYTE GetLevel() const;
+
+    /**
+       Sets the numbering level of this text node.
+
+       @param nLevel     level to set (no flags)
+     */
+    void SetLevel(BYTE nLevel);
+
+    /**
+       Returns outline level of this textn node.
+
+       If a text node has an outline number (i.e. it has an SwNodeNum
+       and a outline numbering rule) the outline level is the level of
+       this SwNodeNum.
+
+       If a text node has no outline number and has a paragraph style
+       attached the outline level is the outline level of the
+       paragraph style.
+
+       Otherwise the text node has no outline level (NO_NUMBERING).
+
+       NOTE: The outline level of text nodes is subject to change. The
+       plan is to have an SwTxtNode::nOutlineLevel member that is
+       updated from a paragraph style upon appliance of that paragraph
+       style.
+
+       @return outline level or NO_NUMBERING if there is no outline level
+     */
+    BYTE GetOutlineLevel() const;
+
+    /**
+       Sets the out line level *at* a text node.
+
+       @param nLevel     the level to be set
+
+       If the text node has an outline number the level is set at the
+       outline number.
+
+       If the text node has no outline number but has a paragraph
+       style applied the outline level is set at the paragraph style.
+
+       NOTE: This is subject to change, see GetOutlineLevel.
+     */
+    void SetOutlineLevel(BYTE nLevel);
+
+    /**
+       Returns the width of leading tabs/blanks in this paragraph.
+       This space will be converted into numbering indent if the paragraph
+       is set to be numbered.
+
+       @return     the width of the leading whitespace
+     */
+    USHORT GetWidthOfLeadingTabs() const;
+
+
+    /**
+       Returns if the paragraph has a visible numbering or bullet.
+       This includes all kinds of numbering/bullet/outlines.
+       Note: This function returns false, if the numbering format is
+       SVX_NUM_NUMBER_NONE or if the numbering/bullet has been deleted.
+
+       @return     TRUE if the paragraph has a visible numbering/bullet/outline
+     */
+    bool HasVisibleNumberingOrBullet() const;
+
+    //
+    // END OF BULLET/NUMBERING/OUTLINE STUFF:
+    //
+
+
     USHORT GetLang( const xub_StrLen nBegin, const xub_StrLen nLen = 0,
                     USHORT nScript = 0 ) const;
-#else
-	USHORT GetLang( const xub_StrLen nBegin, const xub_StrLen nLen = 0) const;
-#endif
-		// steht in ndcopy.cxx
+
+    // steht in ndcopy.cxx
 	BOOL IsSymbol( const xub_StrLen nBegin ) const;	// steht in itratr.cxx
 	virtual SwCntntNode* MakeCopy( SwDoc*, const SwNodeIndex& ) const;
 
@@ -434,7 +629,6 @@ public:
 
 	// fuers Umhaengen der TxtFmtCollections (Outline-Nummerierung!!)
 	virtual void Modify( SfxPoolItem*, SfxPoolItem* );
-//	virtual BOOL GetInfo( SfxPoolItem& ) const;
 
 	// aus SwIndexReg
 	virtual void Update( const SwIndex & aPos, USHORT xub_StrLen,
@@ -458,25 +652,8 @@ public:
      */
     SwPosition * GetPosition(const SwTxtAttr * pAttr);
 
-    // -> #i29560
-    BOOL HasNumber() const;
-    BOOL HasBullet() const;
-    // <- #i29560
-
 	USHORT GetScalingOfSelectedText( xub_StrLen nStt, xub_StrLen nEnd ) const;
 
-    // -> #i27615#
-    BOOL IsNumbered() const;
-    BOOL HasMarkedLabel() const;
-    // <- #i27615#
-
-    BYTE GetLevel() const;
-    void SetLevel(BYTE nLevel);
-    BYTE GetOutlineLevel() const;
-    void SetOutlineLevel(BYTE nLevel);
-
-    USHORT GetWidthOfLeadingTabs() const;
-
 	DECL_FIXEDMEMPOOL_NEWDEL(SwTxtNode)
 };
 
Index: sw/inc/pam.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/pam.hxx,v
retrieving revision 1.11
retrieving revision 1.11.124.1
diff -u -p -u -p -r1.11 -r1.11.124.1
--- sw/inc/pam.hxx	16 Nov 2004 10:19:14 -0000	1.11
+++ sw/inc/pam.hxx	31 Jan 2005 13:01:06 -0000	1.11.124.1
@@ -219,8 +219,9 @@ public:
 				SwMoveFn fnMove = fnMoveForward,
 				const SwPaM *pPam =0, FASTBOOL bInReadOnly = FALSE );
 
-    FASTBOOL IsInFrontOfLabel() const;
-    void SetInFrontOfLabel(FASTBOOL bIsInFrontOfLabel); // #i27615#
+
+    inline FASTBOOL IsInFrontOfLabel() const { return bIsInFrontOfLabel; }
+    inline void _SetInFrontOfLabel( FASTBOOL bNew ) { bIsInFrontOfLabel = bNew; }
 
 	virtual void SetMark();
 	void DeleteMark() { pMark = pPoint; }
Index: sw/source/core/crsr/crsrsh.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/crsr/crsrsh.cxx,v
retrieving revision 1.52
retrieving revision 1.52.4.3
diff -u -p -u -p -r1.52 -r1.52.4.3
--- sw/source/core/crsr/crsrsh.cxx	21 Jan 2005 10:27:59 -0000	1.52
+++ sw/source/core/crsr/crsrsh.cxx	4 Feb 2005 12:49:43 -0000	1.52.4.3
@@ -443,29 +443,42 @@ FASTBOOL SwCrsrShell::LeftRight( BOOL bL
 		return bLeft ? GoPrevCell() : GoNextCell();
 
 	SwCallLink aLk( *this );        // Crsr-Moves ueberwachen, evt. Link callen
-    BOOL bSkipHidden = !GetViewOptions()->IsShowHiddenChar();
+    FASTBOOL bRet = FALSE;
 
     // #i27615# Handle cursor in front of label.
-    const SwTxtNode* pTxtNode = 0;
-    FASTBOOL bRet = FALSE;
-    if ( !bLeft && pCurCrsr->IsInFrontOfLabel() )
+    const SwTxtNode* pTxtNd = 0;
+
+    //
+    // 1. CASE: Cursor is in front of label. A move to the right
+    // will simply reset the bInFrontOfLabel flag:
+    //
+    if ( !bLeft && _GetCrsr()->IsInFrontOfLabel() )
     {
-        pCurCrsr->SetInFrontOfLabel(FALSE);
+        SetInFrontOfLabel( FALSE );
         bRet = TRUE;
     }
-    else if ( bLeft && 0 == pCurCrsr->GetPoint()->nContent.GetIndex() &&
-             !pCurCrsr->IsInFrontOfLabel() &&
-             0 != ( pTxtNode = pCurCrsr->GetPoint()->nNode.GetNode().GetTxtNode() ) &&
-             pTxtNode->IsNumbered() )
+    //
+    // 2. CASE: Cursor is at beginning of numbered paragraph. A move
+    // to the left will simply set the bInFrontOfLabel flag:
+    //
+    else if ( bLeft && 0 == _GetCrsr()->GetPoint()->nContent.GetIndex() &&
+             !_GetCrsr()->IsInFrontOfLabel() && !_GetCrsr()->HasMark() &&
+             0 != ( pTxtNd = _GetCrsr()->GetNode()->GetTxtNode() ) &&
+             pTxtNd->HasVisibleNumberingOrBullet() )
     {
-        pCurCrsr->SetInFrontOfLabel(TRUE);
+        SetInFrontOfLabel( TRUE );
         bRet = TRUE;
     }
+    //
+    // 3. CASE: Regular cursor move. Reset the bInFrontOfLabel flag:
+    //
     else
     {
+        const BOOL bSkipHidden = !GetViewOptions()->IsShowHiddenChar();
+        bRet = SetInFrontOfLabel( FALSE );
         bRet = pCurCrsr->LeftRight( bLeft, nCnt, nMode, bVisualAllowed,
                                     bSkipHidden,
-                                    !IsOverwriteCrsr() );
+                                   !IsOverwriteCrsr() ) || bRet;
     }
 
 	if( bRet )
@@ -480,8 +493,6 @@ void SwCrsrShell::SetMarkedNumLevel(cons
 {
     if (sNumRule != sMarkedNumRule || nLevel != nMarkedNumLevel)
     {
-        StartAction();
-
         if (sMarkedNumRule.Len() > 0)
             pDoc->SetMarkedNumLevel(sMarkedNumRule, nMarkedNumLevel, FALSE);
 
@@ -492,22 +503,18 @@ void SwCrsrShell::SetMarkedNumLevel(cons
 
         sMarkedNumRule = sNumRule;
         nMarkedNumLevel = nLevel;
-
-        EndAction();
     }
 }
 
 void SwCrsrShell::UpdateMarkedNumLevel()
 {
-    SwTxtNode * pTxtNd =
-        pCurCrsr->GetPoint()->nNode.GetNode().GetTxtNode();
+    SwTxtNode * pTxtNd = _GetCrsr()->GetNode()->GetTxtNode();
 
-    if (pTxtNd && ! pCurCrsr->HasMark()) // #i27615#
+    if ( pTxtNd ) // #i27615#
     {
         if (! pTxtNd->IsNumbered())
         {
-            pCurCrsr->SetInFrontOfLabel(FALSE);
-
+            pCurCrsr->_SetInFrontOfLabel( FALSE );
             SetMarkedNumLevel(String(), 0);
         }
         else if (pCurCrsr->IsInFrontOfLabel())
@@ -537,11 +544,10 @@ FASTBOOL SwCrsrShell::UpDown( BOOL bUp, 
 	BOOL bTableMode = IsTableMode();
 	SwShellCrsr* pTmpCrsr = bTableMode ? pTblCrsr : pCurCrsr;
 
-	FASTBOOL bRet = pTmpCrsr->UpDown( bUp, nCnt );
-
+    FASTBOOL bRet = pTmpCrsr->UpDown( bUp, nCnt );
     // --> FME 2005-01-10 #i40019# UpDown should always reset the
     // bInFrontOfLabel flag:
-    pCurCrsr->SetInFrontOfLabel(FALSE);
+    bRet = SetInFrontOfLabel(FALSE) || bRet;
     // <--
 
 	if( bRet )
@@ -566,9 +572,25 @@ FASTBOOL SwCrsrShell::LRMargin( BOOL bLe
 	SET_CURR_SHELL( this );
 	eMvState = MV_LEFTMARGIN;		// Status fuers Crsr-Travelling - GetCrsrOfst
 
-	BOOL bTableMode = IsTableMode();
+    const BOOL bTableMode = IsTableMode();
 	SwShellCrsr* pTmpCrsr = bTableMode ? pTblCrsr : pCurCrsr;
+
+    const FASTBOOL bWasAtLM =
+            ( 0 == _GetCrsr()->GetPoint()->nContent.GetIndex() );
+
 	FASTBOOL bRet = pTmpCrsr->LeftRightMargin( bLeft, bAPI );
+
+    if ( bLeft && !bTableMode && bRet && bWasAtLM && !_GetCrsr()->HasMark() )
+    {
+        const SwTxtNode * pTxtNd = _GetCrsr()->GetNode()->GetTxtNode();
+        if ( pTxtNd && pTxtNd->HasVisibleNumberingOrBullet() )
+            SetInFrontOfLabel( TRUE );
+    }
+    else if ( !bLeft )
+    {
+        bRet = SetInFrontOfLabel( FALSE ) || bRet;
+    }
+
 	if( bRet )
     {
 		UpdateCrsr();
@@ -685,22 +707,29 @@ int SwCrsrShell::SetCrsr( const Point &r
 									bOnlyText ?  MV_SETONLYTEXT : MV_NONE );
 	aTmpState.bSetInReadOnly = IsReadOnlyAvailable();
 
-    SwTxtNode * pTxtNd = pCrsr->GetPoint()->nNode.GetNode().GetTxtNode();
+    SwTxtNode * pTxtNd = pCrsr->GetNode()->GetTxtNode();
 
-    if (pTxtNd && pTxtNd->GetNum() &&
+    if ( pTxtNd && !IsTableMode() &&
         // --> FME 2004-11-25 #i37515# No bInFrontOfLabel during selection
-        !pCrsr->HasMark() )
+        !pCrsr->HasMark() &&
         // <--
+        pTxtNd->HasVisibleNumberingOrBullet() )
+    {
         aTmpState.bInFrontOfLabel = TRUE; // #i27615#
+    }
     else
+    {
         aTmpState.bInFrontOfLabel = FALSE;
+    }
 
 	int bRet = CRSR_POSOLD |
 				( GetLayout()->GetCrsrOfst( &aPos, aPt, &aTmpState )
 					? 0 : CRSR_POSCHG );
 
+    const bool bOldInFrontOfLabel = IsInFrontOfLabel();
+    const bool bNewInFrontOfLabel = aTmpState.bInFrontOfLabel;
+
     pCrsr->SetCrsrBidiLevel( aTmpState.nCursorBidiLevel );
-    pCrsr->SetInFrontOfLabel( aTmpState.bInFrontOfLabel ); // #i27615#
 
 	if( MV_RIGHTMARGIN == aTmpState.eState )
 		eMvState = MV_RIGHTMARGIN;
@@ -716,7 +745,8 @@ int SwCrsrShell::SetCrsr( const Point &r
 	{
 		// steht an der gleichen Position und wenn im Header/Footer,
 		// dann im gleichen
-		if( aPos == *pCrsr->GetPoint() )
+		if( aPos == *pCrsr->GetPoint() &&
+            bOldInFrontOfLabel == bNewInFrontOfLabel )
 		{
 			if( pFrm )
 			{
@@ -754,6 +784,13 @@ int SwCrsrShell::SetCrsr( const Point &r
 	*pCrsr->GetPoint() = aPos;
 	rAktCrsrPt = aPt;
 
+    // --> FME 2005-01-31 #i41424# Only update the marked number levels if necessary
+    // Force update of marked number levels if necessary.
+    if ( bNewInFrontOfLabel || bOldInFrontOfLabel )
+        pCurCrsr->_SetInFrontOfLabel( !bNewInFrontOfLabel );
+    SetInFrontOfLabel( bNewInFrontOfLabel );
+    // <--
+
 	if( !pCrsr->IsSelOvr( SELOVER_CHANGEPOS ) )
 	{
 		UpdateCrsr( SwCrsrShell::SCROLLWIN | SwCrsrShell::CHKRANGE);
@@ -978,6 +1015,17 @@ FASTBOOL SwCrsrShell::IsInFrontOfLabel()
     return pCurCrsr->IsInFrontOfLabel();
 }
 
+bool SwCrsrShell::SetInFrontOfLabel( FASTBOOL bNew )
+{
+    if ( bNew != IsInFrontOfLabel() )
+    {
+        pCurCrsr->_SetInFrontOfLabel( bNew );
+        UpdateMarkedNumLevel();
+        return true;
+    }
+    return false;
+}
+
 FASTBOOL SwCrsrShell::GotoPage( USHORT nPage )
 {
 	SET_CURR_SHELL( this );
@@ -1679,9 +1727,7 @@ void SwCrsrShell::UpdateCrsr( USHORT eFl
 
 #endif
 
-    UpdateMarkedNumLevel(); // #i27615#
-
-	if( bSVCrsrVis )
+    if( bSVCrsrVis )
 		pVisCrsr->Show();           // wieder anzeigen
 }
 
@@ -2088,7 +2134,7 @@ FASTBOOL SwCrsrShell::SetVisCrsr( const 
 
 	FASTBOOL bRet = GetLayout()->GetCrsrOfst( &aPos, aPt /*, &aTmpState*/ );
 
-    pCurCrsr->SetInFrontOfLabel(FALSE); // #i27615#
+    SetInFrontOfLabel( FALSE ); // #i27615#
 
 	// nur in TextNodes anzeigen !!
 	SwTxtNode* pTxtNd = aPos.nNode.GetNode().GetTxtNode();
Index: sw/source/core/crsr/pam.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/crsr/pam.cxx,v
retrieving revision 1.15
retrieving revision 1.15.124.1
diff -u -p -u -p -r1.15 -r1.15.124.1
--- sw/source/core/crsr/pam.cxx	16 Nov 2004 10:21:47 -0000	1.15
+++ sw/source/core/crsr/pam.cxx	31 Jan 2005 13:04:28 -0000	1.15.124.1
@@ -579,16 +579,6 @@ void SwPaM::Exchange()
 }
 #endif
 
-FASTBOOL SwPaM::IsInFrontOfLabel() const
-{
-    return bIsInFrontOfLabel;
-}
-
-void SwPaM::SetInFrontOfLabel(FASTBOOL _bIsInFrontOfLabel)
-{
-    bIsInFrontOfLabel = _bIsInFrontOfLabel;
-}
-
 // Bewegen des Cursors
 
 
Index: sw/source/core/crsr/swcrsr.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/crsr/swcrsr.cxx,v
retrieving revision 1.43
retrieving revision 1.43.4.4
diff -u -p -u -p -r1.43 -r1.43.4.4
--- sw/source/core/crsr/swcrsr.cxx	21 Jan 2005 10:28:33 -0000	1.43
+++ sw/source/core/crsr/swcrsr.cxx	31 Jan 2005 13:04:29 -0000	1.43.4.4
@@ -1730,28 +1730,8 @@ FASTBOOL SwCursor::LeftRightMargin( BOOL
     if ( pFrm )
         SetCrsrBidiLevel( pFrm->IsRightToLeft() ? 1 : 0 );
 
-    // #i27615# Manage cursor in front of label.
-    if (pFrm)
-    {
-        if (bLeft)
-        {
-            FASTBOOL bWasAtLeftMargin = IsAtLeftRightMargin(TRUE, bAPI);
-            bRet = pFrm->LeftMargin( this );
-
-            const SwTxtNode* pTxtNd = GetNode()->GetTxtNode();
-            if (! bAPI && bWasAtLeftMargin && pTxtNd && pTxtNd->IsNumbered() )
-                SetInFrontOfLabel(TRUE);
-        }
-        else
-        {
-            bRet = pFrm->RightMargin( this, bAPI );
-
-            if (! bAPI )
-                SetInFrontOfLabel(FALSE);
-        }
-    }
-
-    return bRet;
+    return pFrm && (bLeft ? pFrm->LeftMargin( this ) :
+                            pFrm->RightMargin( this, bAPI ) );
 }
 
 FASTBOOL SwCursor::IsAtLeftRightMargin( BOOL bLeft, BOOL bAPI ) const
Index: sw/source/core/draw/dcontact.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/draw/dcontact.cxx,v
retrieving revision 1.40
retrieving revision 1.40.4.1
diff -u -p -u -p -r1.40 -r1.40.4.1
--- sw/source/core/draw/dcontact.cxx	21 Jan 2005 10:30:46 -0000	1.40
+++ sw/source/core/draw/dcontact.cxx	28 Jan 2005 13:21:25 -0000	1.40.4.1
@@ -1382,6 +1382,15 @@ void SwDrawContact::_Changed( const SdrO
                                                ? *(pAnchoredDrawObj->GetLastObjRect())
                                                : *(pOldBoundRect);
                 // <--
+                // --> OD 2005-01-28 #i41324# - notify background before
+                // adjusting position and change the last object rectangle.
+                if ( bNotify )
+                {
+                    // --> OD 2004-07-20 #i31573# - correction: Only invalidate
+                    // background of given drawing object.
+                    lcl_NotifyBackgroundOfObj( *this, rObj, &aOldObjRect );
+                }
+                // <--
                 // --> OD 2004-08-04 #i31698# - determine layout direction
                 // via draw frame format.
                 SwFrmFmt::tLayoutDir eLayoutDir =
@@ -1478,12 +1487,6 @@ void SwDrawContact::_Changed( const SdrO
                     }
                     // <--
                 }
-                if ( bNotify )
-                {
-                    // --> OD 2004-07-20 #i31573# - correction: Only invalidate
-                    // background of given drawing object.
-                    lcl_NotifyBackgroundOfObj( *this, rObj, &aOldObjRect );
-                }
             }
         }
         break;
Index: sw/source/core/edit/editsh.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/edit/editsh.cxx,v
retrieving revision 1.35
retrieving revision 1.35.116.1
diff -u -p -u -p -r1.35 -r1.35.116.1
--- sw/source/core/edit/editsh.cxx	26 Nov 2004 16:26:27 -0000	1.35
+++ sw/source/core/edit/editsh.cxx	31 Jan 2005 13:04:29 -0000	1.35.116.1
@@ -259,7 +259,7 @@ void SwEditShell::Insert(const String &r
         }
     }
 
-    pTmpCrsr->SetInFrontOfLabel(FALSE); // #i27615#
+    SetInFrontOfLabel( FALSE ); // #i27615#
 
     EndAllAction();
 }
Index: sw/source/core/inc/frame.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/inc/frame.hxx,v
retrieving revision 1.42
retrieving revision 1.42.124.1
diff -u -p -u -p -r1.42 -r1.42.124.1
--- sw/source/core/inc/frame.hxx	16 Nov 2004 15:41:35 -0000	1.42
+++ sw/source/core/inc/frame.hxx	28 Jan 2005 09:29:53 -0000	1.42.124.1
@@ -544,11 +544,13 @@ public:
 
     // If frame is inside a split table row, this function returns
     // the corresponding row frame in the follow table.
-   const SwRowFrm* IsInSplitTableRow() const;
+    const SwRowFrm* IsInSplitTableRow() const;
 
     // If frame is inside a follow flow row, this function returns
     // the corresponding row frame master table
-   const SwRowFrm* IsInFollowFlowRow() const;
+    const SwRowFrm* IsInFollowFlowRow() const;
+
+    bool IsInBalancedSection() const;
 
     inline BOOL IsReverse() const { return bReverse; }
     inline void SetReverse( BOOL bNew ){ bReverse = bNew ? 1 : 0; }
Index: sw/source/core/inc/layouter.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/inc/layouter.hxx,v
retrieving revision 1.4
retrieving revision 1.4.4.1
diff -u -p -u -p -r1.4 -r1.4.4.1
--- sw/source/core/inc/layouter.hxx	21 Jan 2005 10:32:00 -0000	1.4
+++ sw/source/core/inc/layouter.hxx	28 Jan 2005 09:29:54 -0000	1.4.4.1
@@ -113,6 +113,7 @@ public:
 
 	void LoopControl( SwPageFrm* pPage, BYTE nLoop );
 	void EndLoopControl();
+    void LoopingLouieLight( const SwDoc& rDoc, const SwTxtFrm& rFrm );
 
 	static void CollectEndnotes( SwDoc* pDoc, SwSectionFrm* pSect );
 	static BOOL Collecting( SwDoc* pDoc, SwSectionFrm* pSect, SwFtnFrm* pFtn );
@@ -151,6 +152,9 @@ public:
     // <--
 };
 
-#endif	//_LAYOUTER_HXX
+
+extern void LOOPING_LOUIE_LIGHT( bool bCondition, const SwTxtFrm& rTxtFrm );
+
+#endif  //_LAYOUTER_HXX
 
 
Index: sw/source/core/inc/movedfwdfrmsbyobjpos.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/inc/movedfwdfrmsbyobjpos.hxx,v
retrieving revision 1.4
retrieving revision 1.4.4.2
diff -u -p -u -p -r1.4 -r1.4.4.2
--- sw/source/core/inc/movedfwdfrmsbyobjpos.hxx	21 Jan 2005 10:32:29 -0000	1.4
+++ sw/source/core/inc/movedfwdfrmsbyobjpos.hxx	4 Feb 2005 15:00:33 -0000	1.4.4.2
@@ -61,7 +61,7 @@
 #ifndef _MOVEDFWDFRMSBYOBJPOS_HXX
 #define _MOVEDFWDFRMSBYOBJPOS_HXX
 
-#include <vector>
+#include <map>
 
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
@@ -73,16 +73,15 @@ class SwTxtFrm;
 class SwRowFrm;
 // <--
 
+typedef std::map< const SwTxtNode*, const sal_uInt32 > NodeMap;
+typedef std::map< const SwTxtNode*, const sal_uInt32 >::const_iterator NodeMapIter;
+typedef NodeMap::value_type NodeMapEntry;
+
+
 class SwMovedFwdFrmsByObjPos
 {
     private:
-        struct Entry
-        {
-            const SwTxtNode* mpTxtNode;
-            sal_uInt32 mnToPageNum;
-        };
-
-        std::vector< Entry* > maMovedFwdFrms;
+        NodeMap maMovedFwdFrms;
 
     public:
         SwMovedFwdFrmsByObjPos();
@@ -101,7 +100,8 @@ class SwMovedFwdFrmsByObjPos
         // --> OD 2004-10-05 #i26945#
         bool DoesRowContainMovedFwdFrm( const SwRowFrm& _rRowFrm ) const;
         // <--
-        void Clear();
+
+        void Clear() { maMovedFwdFrms.clear(); };
 };
 
 #endif
Index: sw/source/core/inc/sectfrm.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/inc/sectfrm.hxx,v
retrieving revision 1.7
retrieving revision 1.7.268.1
diff -u -p -u -p -r1.7 -r1.7.268.1
--- sw/source/core/inc/sectfrm.hxx	12 Aug 2004 12:28:31 -0000	1.7
+++ sw/source/core/inc/sectfrm.hxx	28 Jan 2005 09:29:54 -0000	1.7.268.1
@@ -160,6 +160,9 @@ public:
 		{ if( IsEndnAtEnd() ) return _GetEndSectFmt(); return NULL; }
 
 	static void MoveCntntAndDelete( SwSectionFrm* pDel, BOOL bSave );
+
+    bool IsBalancedSection() const;
+
 	DECL_FIXEDMEMPOOL_NEWDEL(SwSectionFrm)
 };
 
Index: sw/source/core/layout/anchoredobject.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/anchoredobject.cxx,v
retrieving revision 1.10
retrieving revision 1.10.4.1
diff -u -p -u -p -r1.10 -r1.10.4.1
--- sw/source/core/layout/anchoredobject.cxx	21 Jan 2005 10:33:21 -0000	1.10
+++ sw/source/core/layout/anchoredobject.cxx	28 Jan 2005 12:35:43 -0000	1.10.4.1
@@ -909,12 +909,19 @@ Point SwAnchoredObject::GetRelPosToAncho
 
     OD 2005-01-06 #i30669#
     Usage: Needed layout information for WW8 export
+    OD 2005-01-27 #i33818# - add parameters <_bFollowTextFlow> and
+    <_obRelToTableCell>
+    If <_bFollowTextFlow> is set and object is anchored inside table,
+    the position relative to the table cell is determined. Output
+    parameter <_obRelToTableCell> reflects this situation
 
     @author OD
 */
-Point SwAnchoredObject::GetRelPosToPageFrm() const
+Point SwAnchoredObject::GetRelPosToPageFrm( const bool _bFollowTextFlow,
+                                            bool& _obRelToTableCell ) const
 {
     Point aRelPos;
+    _obRelToTableCell = false;
 
     ASSERT( GetAnchorFrm(),
             "<SwAnchoredObject::GetRelPosToPageFrm()> - missing anchor frame." );
@@ -922,7 +929,31 @@ Point SwAnchoredObject::GetRelPosToPageF
             "<SwAnchoredObject::GetRelPosToPageFrm()> - missing page frame." );
 
     aRelPos = GetObjRect().Pos();
-    aRelPos -= GetAnchorFrm()->FindPageFrm()->Frm().Pos();
+    // --> OD 2005-01-27 #i33818# - search for cell frame, if object has to
+    // follow the text flow.
+    const SwFrm* pFrm( 0L );
+    if ( _bFollowTextFlow )
+    {
+        pFrm = GetAnchorFrm()->GetUpper();
+        while ( !pFrm->IsCellFrm() && !pFrm->IsPageFrm() )
+        {
+            pFrm = pFrm->GetUpper();
+        }
+    }
+    else
+    {
+        pFrm = GetAnchorFrm()->FindPageFrm();
+    }
+    if ( pFrm->IsCellFrm() )
+    {
+        aRelPos -= ( pFrm->Frm().Pos() + pFrm->Prt().Pos() );
+        _obRelToTableCell = true;
+    }
+    else
+    {
+        aRelPos -= pFrm->Frm().Pos();
+    }
+    // <--
 
     return aRelPos;
 }
Index: sw/source/core/layout/calcmove.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/calcmove.cxx,v
retrieving revision 1.53
retrieving revision 1.53.4.1
diff -u -p -u -p -r1.53 -r1.53.4.1
--- sw/source/core/layout/calcmove.cxx	21 Jan 2005 10:34:12 -0000	1.53
+++ sw/source/core/layout/calcmove.cxx	28 Jan 2005 09:29:54 -0000	1.53.4.1
@@ -1672,7 +1672,7 @@ void SwCntntFrm::MakeAll()
         else
             bMovedFwd = TRUE;
 
-		bFormatted = FALSE;
+        bFormatted = FALSE;
 		if ( bMoveOrFit && GetUpper() == pOldUp )
 		{
 			Prepare( PREP_MUST_FIT, 0, FALSE );
@@ -1689,7 +1689,27 @@ void SwCntntFrm::MakeAll()
 
 	} //while ( !bValidPos || !bValidSize || !bValidPrtArea )
 
-	if ( pSaveFtn )
+
+    // NEW: Looping Louie (Light). Should not be applied in balanced sections.
+    // Should only be applied if there is no better solution!
+    LOOPING_LOUIE_LIGHT( bMovedFwd && bMovedBwd && !IsInBalancedSection() &&
+                            (
+
+                                // --> FME 2005-01-26 #118572#
+                                ( bFtn && !FindFtnFrm()->GetRef()->IsInSct() ) ||
+                                // <--
+
+                                // --> FME 2005-01-27 #i33887#
+                                ( IsInSct() && bKeep )
+                                // <--
+
+                                // ... add your conditions here ...
+
+                            ),
+                         static_cast<SwTxtFrm&>(*this) );
+
+
+    if ( pSaveFtn )
 		delete pSaveFtn;
 
 	UnlockJoin();
Index: sw/source/core/layout/findfrm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/findfrm.cxx,v
retrieving revision 1.32
retrieving revision 1.32.64.1
diff -u -p -u -p -r1.32 -r1.32.64.1
--- sw/source/core/layout/findfrm.cxx	5 Jan 2005 14:30:04 -0000	1.32
+++ sw/source/core/layout/findfrm.cxx	28 Jan 2005 09:29:55 -0000	1.32.64.1
@@ -1500,4 +1500,17 @@ const SwRowFrm* SwFrm::IsInFollowFlowRow
     return pMasterRow;
 }
 
+bool SwFrm::IsInBalancedSection() const
+{
+    bool bRet = false;
+
+    if ( IsInSct() )
+    {
+        const SwSectionFrm* pSectionFrm = FindSctFrm();
+        if ( pSectionFrm )
+            bRet = pSectionFrm->IsBalancedSection();
+    }
+    return bRet;
+}
+
 
Index: sw/source/core/layout/layouter.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/layouter.cxx,v
retrieving revision 1.8
retrieving revision 1.8.4.1
diff -u -p -u -p -r1.8 -r1.8.4.1
--- sw/source/core/layout/layouter.cxx	21 Jan 2005 10:35:39 -0000	1.8
+++ sw/source/core/layout/layouter.cxx	28 Jan 2005 09:29:55 -0000	1.8.4.1
@@ -69,6 +69,8 @@
 #include "cntfrm.hxx"
 #include "pagefrm.hxx"
 #include "ftnfrm.hxx"
+#include "txtfrm.hxx"
+
 // --> OD 2004-06-23 #i28701#
 #ifndef _MOVEDFWDFRMSBYOBJPOS_HXX
 #include <movedfwdfrmsbyobjpos.hxx>
@@ -91,6 +93,7 @@ public:
 	SwLooping( SwPageFrm* pPage );
 	void Control( SwPageFrm* pPage );
 	static void Drastic( SwFrm* pFrm );
+    bool IsLoopingLouieLight() const { return nCount > LOOP_DETECT - 30; };
 };
 
 class SwEndnoter
@@ -311,6 +314,17 @@ void SwLayouter::LoopControl( SwPageFrm*
 	pLooping->Control( pPage );
 }
 
+void SwLayouter::LoopingLouieLight( const SwDoc& rDoc, const SwTxtFrm& rFrm )
+{
+    if ( pLooping && pLooping->IsLoopingLouieLight() )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        ASSERT( false, "Looping Louie (Light): Fixating fractious frame" )
+#endif
+        SwLayouter::InsertMovedFwdFrm( rDoc, rFrm, rFrm.FindPageFrm()->GetPhyPageNum() );
+    }
+}
+
 BOOL SwLayouter::StartLooping( SwPageFrm* pPage )
 {
 	if( pLooping )
@@ -519,3 +533,15 @@ bool SwLayouter::FrmNotToWrap( const SwD
     }
 }
 // <--
+
+void LOOPING_LOUIE_LIGHT( bool bCondition, const SwTxtFrm& rTxtFrm )
+{
+    if ( bCondition )
+    {
+        const SwDoc& rDoc = *rTxtFrm.GetAttrSet()->GetDoc();
+        if ( rDoc.GetLayouter() )
+        {
+            const_cast<SwDoc&>(rDoc).GetLayouter()->LoopingLouieLight( rDoc, rTxtFrm );
+        }
+    }
+}
Index: sw/source/core/layout/movedfwdfrmsbyobjpos.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/movedfwdfrmsbyobjpos.cxx,v
retrieving revision 1.5
retrieving revision 1.5.4.1
diff -u -p -u -p -r1.5 -r1.5.4.1
--- sw/source/core/layout/movedfwdfrmsbyobjpos.cxx	21 Jan 2005 10:36:19 -0000	1.5
+++ sw/source/core/layout/movedfwdfrmsbyobjpos.cxx	28 Jan 2005 09:29:55 -0000	1.5.4.1
@@ -88,52 +88,30 @@ SwMovedFwdFrmsByObjPos::~SwMovedFwdFrmsB
 void SwMovedFwdFrmsByObjPos::Insert( const SwTxtFrm& _rMovedFwdFrmByObjPos,
                                      const sal_uInt32 _nToPageNum )
 {
-    sal_uInt32 nDummy;
-    if ( !FrmMovedFwdByObjPos( _rMovedFwdFrmByObjPos, nDummy ) )
+    if ( maMovedFwdFrms.end() ==
+         maMovedFwdFrms.find( _rMovedFwdFrmByObjPos.GetTxtNode() ) )
     {
-        Entry* pNewEntry = new Entry;
-
-        pNewEntry->mpTxtNode = _rMovedFwdFrmByObjPos.GetTxtNode();
-        pNewEntry->mnToPageNum = _nToPageNum;
-
-        maMovedFwdFrms.push_back( pNewEntry );
+        const NodeMapEntry aEntry( _rMovedFwdFrmByObjPos.GetTxtNode(), _nToPageNum );
+        maMovedFwdFrms.insert( aEntry );
     }
 }
 
-// --> OD 2005-01-12 #i40155#
 void SwMovedFwdFrmsByObjPos::Remove( const SwTxtFrm& _rTxtFrm )
 {
-    std::vector< Entry* >::iterator aIter = maMovedFwdFrms.begin();
-    for ( ; aIter != maMovedFwdFrms.end(); ++aIter )
-    {
-        const Entry* pCurrEntry = *(aIter);
-        if ( pCurrEntry->mpTxtNode == _rTxtFrm.GetTxtNode() )
-        {
-            maMovedFwdFrms.erase( aIter );
-            break;
-        }
-    }
-}
-// <--
+    maMovedFwdFrms.erase( _rTxtFrm.GetTxtNode() );
+};
 
 bool SwMovedFwdFrmsByObjPos::FrmMovedFwdByObjPos( const SwTxtFrm& _rTxtFrm,
                                                   sal_uInt32& _ornToPageNum ) const
 {
-    bool bFrmMovedFwd( false );
-
-    std::vector< Entry* >::const_iterator aIter = maMovedFwdFrms.begin();
-    for ( ; aIter != maMovedFwdFrms.end(); ++aIter )
+    NodeMapIter aIter = maMovedFwdFrms.find( _rTxtFrm.GetTxtNode() );
+    if ( maMovedFwdFrms.end() != aIter )
     {
-        const Entry* pCurrEntry = *(aIter);
-        if ( pCurrEntry->mpTxtNode == _rTxtFrm.GetTxtNode() )
-        {
-            bFrmMovedFwd = true;
-            _ornToPageNum = pCurrEntry->mnToPageNum;
-            break;
-        }
+        _ornToPageNum = (*aIter).second;
+        return true;
     }
 
-    return bFrmMovedFwd;
+    return false;
 }
 
 // --> OD 2004-10-05 #i26945#
@@ -143,13 +121,13 @@ bool SwMovedFwdFrmsByObjPos::DoesRowCont
 
     const sal_uInt32 nPageNumOfRow = _rRowFrm.FindPageFrm()->GetPhyPageNum();
 
-    std::vector< Entry* >::const_iterator aIter = maMovedFwdFrms.begin();
+    NodeMapIter aIter = maMovedFwdFrms.begin();
     for ( ; aIter != maMovedFwdFrms.end(); ++aIter )
     {
-        const Entry* pCurrEntry = *(aIter);
-        if ( pCurrEntry->mnToPageNum >= nPageNumOfRow )
+        const NodeMapEntry& rEntry = *(aIter);
+        if ( rEntry.second >= nPageNumOfRow )
         {
-            SwClientIter aIter( *(const_cast<SwTxtNode*>(pCurrEntry->mpTxtNode)) );
+            SwClientIter aIter( *const_cast<SwTxtNode*>( rEntry.first ) );
             for( SwTxtFrm* pTxtFrm = (SwTxtFrm*)aIter.First( TYPE(SwTxtFrm) );
                  pTxtFrm;
                  pTxtFrm = (SwTxtFrm*)aIter.Next() )
@@ -170,11 +148,3 @@ bool SwMovedFwdFrmsByObjPos::DoesRowCont
 }
 // <--
 
-void SwMovedFwdFrmsByObjPos::Clear()
-{
-    while ( maMovedFwdFrms.size() )
-    {
-        delete maMovedFwdFrms.back();
-        maMovedFwdFrms.pop_back();
-    }
-}
Index: sw/source/core/layout/sectfrm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/sectfrm.cxx,v
retrieving revision 1.38
retrieving revision 1.38.4.1
diff -u -p -u -p -r1.38 -r1.38.4.1
--- sw/source/core/layout/sectfrm.cxx	21 Jan 2005 10:39:14 -0000	1.38
+++ sw/source/core/layout/sectfrm.cxx	28 Jan 2005 09:29:56 -0000	1.38.4.1
@@ -2733,3 +2733,14 @@ BOOL SwRootFrm::IsInDelList( SwSectionFr
 }
 
 #endif
+
+bool SwSectionFrm::IsBalancedSection() const
+{
+    bool bRet = false;
+    if ( GetSection() && Lower() && Lower()->IsColumnFrm() && Lower()->GetNext() )
+    {
+        bRet = !GetSection()->GetFmt()->GetBalancedColumns().GetValue();
+    }
+    return bRet;
+}
+
Index: sw/source/core/layout/wsfrm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/wsfrm.cxx,v
retrieving revision 1.62
retrieving revision 1.62.64.1
diff -u -p -u -p -r1.62 -r1.62.64.1
--- sw/source/core/layout/wsfrm.cxx	5 Jan 2005 14:30:39 -0000	1.62
+++ sw/source/core/layout/wsfrm.cxx	31 Jan 2005 12:54:48 -0000	1.62.64.1
@@ -2800,7 +2800,7 @@ void SwLayoutFrm::ChgLowersProp( const S
                IsSctFrm() ) )
                // <--
     {
-        // Determine page frame the body frame belongs to.
+        // Determine page frame the body frame resp. the section frame belongs to.
 		SwPageFrm *pPage = FindPageFrm();
         // Determine last lower by traveling through them using <GetNext()>.
         // During travel check each section frame, if it will be sized to
@@ -2850,14 +2850,13 @@ void SwLayoutFrm::ChgLowersProp( const S
                     pLowerFrm = pTableFrm;
                 }
             }
-            // Check, if variable size of body frame has grown
+            // Check, if variable size of body frame resp. section frame has grown
             // OD 28.10.2002 #97265# - correct check, if variable size has grown.
-            //SwTwips nOldHeight = bVert ? rOldSize.Height() : rOldSize.Width();
             SwTwips nOldHeight = bVert ? rOldSize.Width() : rOldSize.Height();
             if( nOldHeight < (Prt().*fnRect->fnGetHeight)() )
 			{
-                // If variable size of body frame has grown, only found last lower
-                // and the position of the its next have to be invalidated.
+                // If variable size of body|section frame has grown, only found
+                // last lower and the position of the its next have to be invalidated.
                 pLowerFrm->_InvalidateAll();
                 pLowerFrm->InvalidatePage( pPage );
                 if( !pLowerFrm->IsFlowFrm() ||
@@ -2865,21 +2864,12 @@ void SwLayoutFrm::ChgLowersProp( const S
                     pLowerFrm->InvalidateNextPos( TRUE );
                 if ( pLowerFrm->IsTxtFrm() )
                     ((SwCntntFrm*)pLowerFrm)->Prepare( PREP_ADJUST_FRM );
-                if ( pLowerFrm->IsInSct() )
-				{
-                    pLowerFrm = pLowerFrm->FindSctFrm();
-                    if( IsAnLower( pLowerFrm ) )
-					{
-                        pLowerFrm->_InvalidateSize();
-                        pLowerFrm->InvalidatePage( pPage );
-					}
-				}
 			}
 			else
 			{
-                // variable size of body frame has shrinked. Thus, invalidate
-                // all lowers not matching the new body size and the dedicated
-                // new last lower.
+                // variable size of body|section frame has shrinked. Thus,
+                // invalidate all lowers not matching the new body|section size
+                // and the dedicated new last lower.
                 if( bVert )
                 {
                     SwTwips nBot = Frm().Left() + Prt().Left();
@@ -2906,18 +2896,26 @@ void SwLayoutFrm::ChgLowersProp( const S
                     pLowerFrm->InvalidatePage( pPage );
                     if ( pLowerFrm->IsTxtFrm() )
                         ((SwCntntFrm*)pLowerFrm)->Prepare( PREP_ADJUST_FRM );
-                    if ( pLowerFrm->IsInSct() )
-					{
-                        pLowerFrm = pLowerFrm->FindSctFrm();
-                        if( IsAnLower( pLowerFrm ) )
-						{
-                            pLowerFrm->_InvalidateSize();
-                            pLowerFrm->InvalidatePage( pPage );
-						}
-					}
 				}
 			}
-		}
+            // --> OD 2005-01-31 #i41694# - improvement by removing duplicates
+            if ( pLowerFrm )
+            {
+                if ( pLowerFrm->IsInSct() )
+                {
+                    // --> OD 2005-01-31 #i41694# - follow-up of issue #i10826#:
+                    // No invalidation of section frame, if it's the this.
+                    SwFrm* pSectFrm = pLowerFrm->FindSctFrm();
+                    if( pSectFrm != this && IsAnLower( pSectFrm ) )
+                    {
+                        pSectFrm->_InvalidateSize();
+                        pSectFrm->InvalidatePage( pPage );
+                    }
+                    // <--
+                }
+            }
+            // <--
+        }
 		return;
     } // end of { special case }
 
Index: sw/source/core/txtnode/ndtxt.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/txtnode/ndtxt.cxx,v
retrieving revision 1.43
retrieving revision 1.43.64.1
diff -u -p -u -p -r1.43 -r1.43.64.1
--- sw/source/core/txtnode/ndtxt.cxx	5 Jan 2005 11:47:24 -0000	1.43
+++ sw/source/core/txtnode/ndtxt.cxx	1 Feb 2005 10:28:15 -0000	1.43.64.1
@@ -1000,11 +1000,11 @@ void SwTxtNode::Update( const SwIndex & 
 		{
 			// Bookmarks must never grow to either side, when
 			// editing (directly) to the left or right (#i29942#)!
-			// And a bookmark with same start and end must remain 
+			// And a bookmark with same start and end must remain
 			// to the left of the inserted text (used in XML import).
 			const SwPosition* pEnd = rBkmk[i]->End();
 			pIdx = (SwIndex*)&pEnd->nContent;
-			if( this == &pEnd->nNode.GetNode() && 
+			if( this == &pEnd->nNode.GetNode() &&
 				aPos.GetIndex() == pIdx->GetIndex() )
 				pIdx->Assign( &aTmpIdxReg, pIdx->GetIndex() );
 		}
@@ -1054,12 +1054,12 @@ void SwTxtNode::_ChgTxtCollUpdateNum( co
 	{
 		// Numerierung aufheben, falls sie aus der Vorlage kommt
 		// und nicht nicht aus der neuen
-		if( NO_NUMBERING != nNewLevel && pNdNum && 
+		if( NO_NUMBERING != nNewLevel && pNdNum &&
             ( !GetpSwAttrSet() ||
-              SFX_ITEM_SET != 
+              SFX_ITEM_SET !=
               GetpSwAttrSet()->GetItemState(RES_PARATR_NUMRULE, FALSE )))
         {
-            if ((!pNewColl || 
+            if ((!pNewColl ||
                  SFX_ITEM_SET != pNewColl->GetItemState(RES_PARATR_NUMRULE )) )
                 delete pNdNum, pNdNum = 0;
         }
@@ -1069,10 +1069,10 @@ void SwTxtNode::_ChgTxtCollUpdateNum( co
 	}
 
     const SfxPoolItem * pItem = NULL;
-    if (SFX_ITEM_SET == 
+    if (SFX_ITEM_SET ==
         pNewColl->GetItemState(RES_PARATR_NUMRULE, FALSE, &pItem))
     {
-        SwNumRule * pRule = 
+        SwNumRule * pRule =
             GetDoc()->FindNumRulePtr(((SwNumRuleItem *) pItem)->GetValue());
 
         if (pRule)
@@ -2253,6 +2253,7 @@ void SwTxtNode::GCAttr()
 	}
 }
 
+
 const SwNodeNum* SwTxtNode::UpdateNum( const SwNodeNum& rNum )
 {
     // #111955#
@@ -2501,10 +2502,6 @@ SwTxtAttr *SwTxtNode::GetTxtAttr( const 
 	return 0;
 }
 
-/*************************************************************************
- *						SwTxtNode::GetExpandTxt
- *************************************************************************/
-// Felder werden expandiert:
 // -> #i29560#
 BOOL SwTxtNode::HasNumber() const
 {
@@ -2555,14 +2552,14 @@ XubString SwTxtNode::GetNumString() cons
     {
         const SwNumRule* pRule = GetNumRule();
 
-        if (pRule && 
-            pNum->GetLevel() < MAXLEVEL && 
+        if (pRule &&
+            pNum->GetLevel() < MAXLEVEL &&
             pRule->Get(pNum->GetLevel()).IsTxtFmt())
             return pRule->MakeNumString(*pNum);
     }
 
     return aEmptyStr;
-            
+
 #if 0
 	if( (( 0 != ( pNum = GetNum() ) &&
 			0 != ( pRule = GetNumRule() )) ||
@@ -2705,6 +2702,11 @@ void SwTxtNode::Replace0xFF( XubString& 
 	}
 }
 
+/*************************************************************************
+ *                      SwTxtNode::GetExpandTxt
+ * Expand fields
+ *************************************************************************/
+
 XubString SwTxtNode::GetExpandTxt( const xub_StrLen nIdx, const xub_StrLen nLen,
 								const BOOL bWithNum  ) const
 {
@@ -3061,7 +3063,7 @@ const SwNodeNum * SwTxtNode::GetNum(BOOL
         if (bUpdate && pRule->IsInvalidRule())
             const_cast<SwDoc *>(GetDoc())->UpdateNumRule(*pRule, 0);
     }
- 
+
     return pNdNum;
 }
 
@@ -3072,7 +3074,7 @@ BOOL SwTxtNode::IsOutline() const
 
     if (pRule && pRule->IsOutlineRule())
         bResult = TRUE;
-    
+
     return bResult;
 }
 
@@ -3109,7 +3111,7 @@ BYTE SwTxtNode::GetOutlineLevel() const
 
     if (pNum)
         aResult = pNum->GetRealLevel();
-    else 
+    else
     {
         SwFmtColl * pFmtColl = GetFmtColl();
 
@@ -3142,9 +3144,35 @@ void SwTxtNode::SetOutlineLevel(BYTE nLe
     else
     {
         SwFmtColl * pFmtColl = GetFmtColl();
-        
+
         if (pFmtColl)
             ((SwTxtFmtColl *) pFmtColl)->SetOutlineLevel(nLevel);
     }
 }
 
+/**
+   Returns if the paragraph has a visible numbering or bullet.
+   This includes all kinds of numbering/bullet/outlines.
+   Note: This function returns false, if the numbering format is
+   SVX_NUM_NUMBER_NONE or if the numbering/bullet has been deleted.
+ */
+
+bool SwTxtNode::HasVisibleNumberingOrBullet() const
+{
+    bool bRet = false;
+
+    if ( pNdNum && pNdNum->IsShowNum() )
+    {
+        const SwNumRule * pRule = GetNumRule();
+        if ( pRule )
+        {
+            const SwNumFmt& rFmt = pRule->Get( pNdNum->GetRealLevel() );
+            if ( SVX_NUM_NUMBER_NONE != rFmt.GetNumberingType() )
+            {
+                bRet = true;
+            }
+        }
+    }
+
+    return bRet;
+}
Index: sw/source/core/undo/undobj1.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/undo/undobj1.cxx,v
retrieving revision 1.8
retrieving revision 1.8.124.1
diff -u -p -u -p -r1.8 -r1.8.124.1
--- sw/source/core/undo/undobj1.cxx	17 Nov 2004 14:22:22 -0000	1.8
+++ sw/source/core/undo/undobj1.cxx	31 Jan 2005 10:17:26 -0000	1.8.124.1
@@ -161,6 +161,10 @@ void SwUndoFlyBase::InsFly( SwUndoIter& 
         if ( pDrawContact )
         {
             pDrawContact->InsertMasterIntoDrawPage();
+            // --> OD 2005-01-31 #i40845# - follow-up of #i35635#
+            // move object to visible layer
+            pDrawContact->MoveObjToVisibleLayer( pDrawContact->GetMaster() );
+            // <--
         }
     }
 
Index: sw/source/core/unocore/unodraw.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unodraw.cxx,v
retrieving revision 1.62
retrieving revision 1.62.72.1
diff -u -p -u -p -r1.62 -r1.62.72.1
--- sw/source/core/unocore/unodraw.cxx	23 Dec 2004 10:10:53 -0000	1.62
+++ sw/source/core/unocore/unodraw.cxx	3 Feb 2005 08:29:15 -0000	1.62.72.1
@@ -2021,14 +2021,22 @@ void SwXShape::dispose(void) throw( uno:
         // <pObj> must be the same as <pFmt->FindSdrObject()>, if <pObj> isn't
         // a 'virtual' drawing object.
         // OD 25.08.2003 #111713# - refine assertion for safety reason.
+        // --> OD 2005-02-02 #119236# - correct assertion and refine it.
         ASSERT( !pObj ||
-                !pObj->ISA(SwDrawVirtObj) || pObj == pFmt->FindSdrObject(),
+                pObj->ISA(SwDrawVirtObj) ||
+                pObj->GetUpGroup() ||
+                pObj == pFmt->FindSdrObject(),
                 "<SwXShape::dispose(..) - different 'master' drawing objects!!" );
+        // <--
         // OD 10.07.2003 #110742# - perform delete of draw frame format *not*
         // for 'virtual' drawing objects.
+        // --> OD 2005-02-02 #119236# - no delete of draw format for members
+        // of a group
         if ( pObj &&
              !pObj->ISA(SwDrawVirtObj) &&
+             !pObj->GetUpGroup() &&
              pObj->IsInserted() )
+        // <--
         {
             if( pFmt->GetAnchor().GetAnchorId() == FLY_IN_CNTNT )
             {
Index: sw/source/filter/html/swhtml.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/html/swhtml.cxx,v
retrieving revision 1.32
retrieving revision 1.32.40.1
diff -u -p -u -p -r1.32 -r1.32.40.1
--- sw/source/filter/html/swhtml.cxx	11 Jan 2005 12:28:43 -0000	1.32
+++ sw/source/filter/html/swhtml.cxx	28 Jan 2005 12:37:22 -0000	1.32.40.1
@@ -341,19 +341,24 @@ String HTMLReader::GetTemplateName() con
 	sTemplate.AppendAscii( TOOLS_CONSTASCII_STRINGPARAM("html") );
 	String sTemplateWithoutExt( sTemplate );
 #ifndef MAC_WITHOUT_EXT
-	sTemplate.AppendAscii( TOOLS_CONSTASCII_STRINGPARAM(".stw") );
+    // --> OD 2005-01-26 - first search for OpenDocument Writer/Web template
+    sTemplate.AppendAscii( TOOLS_CONSTASCII_STRINGPARAM(".oth") );
+    // <--
 #endif
 
 	SvtPathOptions aOpt;
-	// 6.0 (extension .stw)
+    // OpenDocument Writer/Web template (extension .oth)
 	BOOL bSet = aOpt.SearchFile( sTemplate, SvtPathOptions::PATH_TEMPLATE );
 
 #ifndef MAC_WITHOUT_EXT
 	if( !bSet )
 	{
-		// 5.0 (extension .vor)
+        // 6.0 (extension .stw)
 		sTemplate = sTemplateWithoutExt;
-		sTemplate.AppendAscii( TOOLS_CONSTASCII_STRINGPARAM(".vor") );
+        // --> OD 2005-01-26 - no OpenDocument Writer/Web template found.
+        // search for OpenOffice.org Writer/Web template
+        sTemplate.AppendAscii( TOOLS_CONSTASCII_STRINGPARAM(".stw") );
+        // <--
 		bSet = aOpt.SearchFile( sTemplate, SvtPathOptions::PATH_TEMPLATE );
 	}
 #endif
Index: sw/source/filter/ww8/wrtw8esh.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtw8esh.cxx,v
retrieving revision 1.82
retrieving revision 1.82.4.1
diff -u -p -u -p -r1.82 -r1.82.4.1
--- sw/source/filter/ww8/wrtw8esh.cxx	21 Jan 2005 10:43:17 -0000	1.82
+++ sw/source/filter/ww8/wrtw8esh.cxx	28 Jan 2005 12:40:04 -0000	1.82.4.1
@@ -2330,7 +2330,15 @@ bool WinwordAnchoring::ConvertPosition( 
                 if ( eHoriConv == CONV2PG )
                 {
                     _iorHoriOri.SetRelationOrient( REL_PG_FRAME );
-                    aPos = pAnchoredObj->GetRelPosToPageFrm();
+                    // --> OD 2005-01-27 #i33818#
+                    bool bRelToTableCell( false );
+                    aPos = pAnchoredObj->GetRelPosToPageFrm( bFollowTextFlow,
+                                                             bRelToTableCell );
+                    if ( bRelToTableCell )
+                    {
+                        _iorHoriOri.SetRelationOrient( REL_PG_PRTAREA );
+                    }
+                    // <--
                 }
                 else if ( eHoriConv == CONV2COL )
                 {
@@ -2427,7 +2435,15 @@ bool WinwordAnchoring::ConvertPosition( 
                 if ( eVertConv == CONV2PG )
                 {
                     _iorVertOri.SetRelationOrient( REL_PG_FRAME );
-                    aPos = pAnchoredObj->GetRelPosToPageFrm();
+                    // --> OD 2005-01-27 #i33818#
+                    bool bRelToTableCell( false );
+                    aPos = pAnchoredObj->GetRelPosToPageFrm( bFollowTextFlow,
+                                                             bRelToTableCell );
+                    if ( bRelToTableCell )
+                    {
+                        _iorVertOri.SetRelationOrient( REL_PG_PRTAREA );
+                    }
+                    // <--
                 }
                 else if ( eVertConv == CONV2PARA )
                 {
Index: sw/source/filter/ww8/ww8atr.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8atr.cxx,v
retrieving revision 1.86
retrieving revision 1.86.40.1
diff -u -p -u -p -r1.86 -r1.86.40.1
--- sw/source/filter/ww8/ww8atr.cxx	11 Jan 2005 13:25:49 -0000	1.86
+++ sw/source/filter/ww8/ww8atr.cxx	4 Feb 2005 16:01:25 -0000	1.86.40.1
@@ -1907,19 +1907,23 @@ bool lcl_IsHyperlinked(const SwForm& rFo
     {
         // #i21237#
         SwFormTokens aPattern = rForm.GetPattern(nI);
-        SwFormTokens::iterator aIt = aPattern.begin();
 
-        FormTokenType eTType;
-        // #i21237#
-        while ( ++aIt != aPattern.end() )
-        {
-            eTType = aIt->eTokenType;
-            switch (eTType)
-            {
-                case TOKEN_LINK_START:
-                case TOKEN_LINK_END:
-                    return true;
-                    break;
+        if ( !aPattern.empty() )
+        {
+            SwFormTokens::iterator aIt = aPattern.begin();
+
+            FormTokenType eTType;
+            // #i21237#
+            while ( ++aIt != aPattern.end() )
+            {
+                eTType = aIt->eTokenType;
+                switch (eTType)
+                {
+                    case TOKEN_LINK_START:
+                    case TOKEN_LINK_END:
+                        return true;
+                        break;
+                }
             }
         }
     }
@@ -2032,7 +2036,7 @@ void SwWW8Writer::StartTOX( const SwSect
                             ( RES_POOLCOLL_HEADLINE1 > nPoolId ||
                               RES_POOLCOLL_HEADLINE9 < nPoolId ))
                         {
-                      
+
 
                     // If we are using the default heading styles then use nTOXLvl
                     if(!nMinLvl)
Index: sw/source/filter/ww8/ww8par2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par2.cxx,v
retrieving revision 1.110
retrieving revision 1.110.40.4
diff -u -p -u -p -r1.110 -r1.110.40.4
--- sw/source/filter/ww8/ww8par2.cxx	11 Jan 2005 13:27:00 -0000	1.110
+++ sw/source/filter/ww8/ww8par2.cxx	4 Feb 2005 15:59:43 -0000	1.110.40.4
@@ -180,6 +180,11 @@
 #ifndef _FMTROWSPLT_HXX
 #include <fmtrowsplt.hxx>
 #endif
+// --> OD 2005-01-27 #i33818#
+#ifndef _FMTFOLLOWTEXTFLOW_HXX
+#include <fmtfollowtextflow.hxx>
+#endif
+// <--
 
 #ifndef WW_WWSTYLES_HXX
 #   include "../inc/wwstyles.hxx"
@@ -667,7 +672,7 @@ ApoTestResults SwWW8ImplReader::TestApo(
         //in tables)
         if (nCellLevel == nInTable)
         {
-            
+
             if (!nInTable)
                 bTestAllowed = true;
             else
@@ -679,8 +684,15 @@ ApoTestResults SwWW8ImplReader::TestApo(
                 }
                 else
                 {
-                    bTestAllowed = pTableDesc->GetAktCol() == 0  &&
-                        pTableDesc->InFirstParaInCell();
+                    // --> OD 2005-02-01 #i39468#
+                    // If current cell isn't valid, the test is allowed.
+                    // The cell isn't valid, if e.g. there is a new row
+                    // <pTableDesc->nAktRow> >= <pTableDesc->pTabLines->Count()>
+                    bTestAllowed =
+                        pTableDesc->GetAktCol() == 0 &&
+                        ( !pTableDesc->IsValidCell( pTableDesc->GetAktCol() ) ||
+                          pTableDesc->InFirstParaInCell() );
+                    // <--
                 }
             }
         }
@@ -1679,12 +1691,12 @@ const BYTE *HasTabCellSprm(WW8PLCFx_Cp_F
 }
 
 WW8TabDesc::WW8TabDesc(SwWW8ImplReader* pIoClass, WW8_CP nStartCp)
-    : mpOldRedlineStack(0), pIo(pIoClass), pFirstBand(0), pActBand(0), 
-    pTmpPos(0), pTblNd(0), pTabLines(0), pTabLine(0), pTabBoxes(0), pTabBox(0), 
-    pMergeGroups(0), pAktWWCell(0), nRows(0), nDefaultSwCols(0), nBands(0), 
-    nMinLeft(0), nConvertedLeft(0), nMaxRight(0), nSwWidth(0), bOk(true), 
-    nRowsToRepeat(0), bClaimLineFmt(false), eOri(HORI_NONE), bIsBiDi(false), 
-    nAktRow(0), nAktBandRow(0), nAktCol(0), pTable(0), pParentPos(0), 
+    : mpOldRedlineStack(0), pIo(pIoClass), pFirstBand(0), pActBand(0),
+    pTmpPos(0), pTblNd(0), pTabLines(0), pTabLine(0), pTabBoxes(0), pTabBox(0),
+    pMergeGroups(0), pAktWWCell(0), nRows(0), nDefaultSwCols(0), nBands(0),
+    nMinLeft(0), nConvertedLeft(0), nMaxRight(0), nSwWidth(0), bOk(true),
+    nRowsToRepeat(0), bClaimLineFmt(false), eOri(HORI_NONE), bIsBiDi(false),
+    nAktRow(0), nAktBandRow(0), nAktCol(0), pTable(0), pParentPos(0),
     pFlyFmt(0),
     aItemSet(pIo->rDoc.GetAttrPool(),RES_FRMATR_BEGIN,RES_FRMATR_END-1)
 {
@@ -1739,7 +1751,7 @@ WW8TabDesc::WW8TabDesc(SwWW8ImplReader* 
             bool bRepeatedSprm = false;
             while ( aSprmIter.GetSprms() &&
                 (0 != (pParams = aSprmIter.GetAktParams())) )
-            {               
+            {
                 switch( aSprmIter.GetAktId() )
                 {
                 case 0x7629:
@@ -2188,7 +2200,7 @@ void WW8TabDesc::CalcDefaults()
     {
         pR->nSwCols = pR->nWwCols;
         pR->bLEmptyCol = pR->nCenter[0] - nMinLeft >= MINLAY;
-        pR->bREmptyCol = nMaxRight - pR->nCenter[pR->nWwCols] >= MINLAY;
+        pR->bREmptyCol = (nMaxRight - pR->nCenter[pR->nWwCols] - nRightMaxThickness) >= MINLAY;
 
         short nAddCols = pR->bLEmptyCol + pR->bREmptyCol;
         USHORT i;
@@ -2363,7 +2375,7 @@ void WW8TabDesc::CreateSwTable()
     // schneller geht als Loeschen Zahl der Zeilen ist die Zahl der Baender,
     // da sich die (identischen) Zeilen eines Bandes prima duplizieren lassen
     pTable = pIo->rDoc.InsertTable(
-            SwInsertTableOptions( tabopts::HEADLINE_NO_BORDER, 0 ), 
+            SwInsertTableOptions( tabopts::HEADLINE_NO_BORDER, 0 ),
             *pTmpPos, nBands, nDefaultSwCols, eOri );
 
     ASSERT(pTable && pTable->GetFrmFmt(), "insert table failed");
@@ -2461,7 +2473,7 @@ void WW8TabDesc::UseSwTable()
         GetSttNd()->FindTableNode();
     ASSERT( pTblNd, "wo ist mein TabellenNode" );
 
-    pTblNd->GetTable().SetRowsToRepeat( nRowsToRepeat ); 
+    pTblNd->GetTable().SetRowsToRepeat( nRowsToRepeat );
     // ggfs. Zusatz-Zellen einfuegen u.dgl.
     AdjustNewBand();
 
@@ -2502,7 +2514,7 @@ void WW8TabDesc::MergeCells()
                     pTabBoxes = &pTabLine->GetTabBoxes();
 
                     USHORT nCol = pActBand->nTransCell[ i ];
-                    if (!pActBand->bExist[nCol])    //#113434#
+                    if (!pActBand->bExist[i])    //#113434#
                         continue;
                     ASSERT(nCol < pTabBoxes->Count(),
                         "Too few columns, table ended early");
@@ -2555,19 +2567,40 @@ void WW8TabDesc::MergeCells()
                         // anlegen
                         if( !pMergeGroups )
                             pMergeGroups = new WW8MergeGroups;
-                        else
-                        {
-                            // 1. ggfs. alte Mergegruppe(n) schliessen, die
-                            // den von unserer neuen Gruppe betroffenen
-                            // X-Bereich ueberdecken
-                            short nMGrIdx;
-                            while(FindMergeGroup( nX1, nWidth, false, nMGrIdx))
-                                (*pMergeGroups)[ nMGrIdx ]->bGroupLocked = true;
-                        }
 
                         // 2. aktuelle Merge-Gruppe anlegen
                         pActMGroup = new WW8SelBoxInfo( nX1, nWidth );
 
+                        // --> OD 2005-02-04 #118544# - determine size of new
+                        // merge group before inserted the new merge group.
+                        // Needed to correctly locked previously created merge groups.
+                        // Gesamtbreite ermitteln und zuweisen
+                        short nSizCell = pActBand->nWidth[ i ];
+                        for (USHORT i2 = i+1; i2 < pActBand->nWwCols; i2++ )
+                            if (pActBand->pTCs[ i2 ].bMerged &&
+                                !pActBand->pTCs[ i2 ].bFirstMerged  )
+                            {
+                                nSizCell += pActBand->nWidth[ i2 ];
+                            }
+                            else
+                                break;
+                        pActMGroup->nGroupWidth = nSizCell;
+                        // <--
+
+                        // --> OD 2005-02-03 #118544# - locked previously
+                        // created merge groups, after determining the size
+                        // for the new merge group.
+                        // 1. ggfs. alte Mergegruppe(n) schliessen, die
+                        // den von unserer neuen Gruppe betroffenen
+                        // X-Bereich ueberdecken
+                        short nMGrIdx;
+                        while ( FindMergeGroup( nX1, pActMGroup->nGroupWidth,
+                                                false, nMGrIdx ) )
+                        {
+                            (*pMergeGroups)[ nMGrIdx ]->bGroupLocked = true;
+                        }
+                        // <--
+
                         // 3. und in Gruppen-Array eintragen
                         pMergeGroups->Insert(pActMGroup, pMergeGroups->Count());
 
@@ -2597,17 +2630,7 @@ void WW8TabDesc::MergeCells()
                         // Border der O-L-Box der Gruppe wird Border der
                         // Targetbox
                         pNewFrmFmt->SetAttr( pTabBox->GetFrmFmt()->GetBox() );
-                        // Gesamtbreite ermitteln und zuweisen
-                        short nSizCell = pActBand->nWidth[ i ];
-                        for (USHORT i2 = i+1; i2 < pActBand->nWwCols; i2++ )
-                            if (pActBand->pTCs[ i2 ].bMerged &&
-                                !pActBand->pTCs[ i2 ].bFirstMerged  )
-                            {
-                                nSizCell += pActBand->nWidth[ i2 ];
-                            }
-                            else
-                                break;
-                        pActMGroup->nGroupWidth = nSizCell;
+
                         pNewFrmFmt->SetAttr( SwFmtFrmSize( ATT_VAR_SIZE,
                             pActMGroup->nGroupWidth ));
                     }
@@ -2877,7 +2900,9 @@ bool WW8TabDesc::FindMergeGroup(short nX
         short nGrX1;
         short nGrX2;
 
-        for( USHORT iGr = 0; iGr < pMergeGroups->Count(); iGr++ )
+        // --> OD 2005-02-04 #118544# - improvement: search backwards
+        //for ( USHORT iGr = 0; iGr < pMergeGroups->Count(); iGr++ )
+        for ( short iGr = pMergeGroups->Count() - 1; iGr >= 0; --iGr )
         {
             // die aktuell untersuchte Gruppe
             pActGroup = (*pMergeGroups)[ iGr ];
@@ -3041,9 +3066,9 @@ bool WW8TabDesc::SetPamInCell(short nWwC
             const SfxPoolItem &rItm = pNd->SwCntntNode::GetAttr(RES_PARATR_SNAPTOGRID);
             SvxParaGridItem &rSnapToGrid = (SvxParaGridItem&)(rItm);
 
-            if(rSnapToGrid.GetValue())            
+            if(rSnapToGrid.GetValue())
             {
-                SvxParaGridItem aGridItem( rSnapToGrid );            
+                SvxParaGridItem aGridItem( rSnapToGrid );
                 aGridItem.SetValue(false);
 
                 SwPosition* pGridPos = pIo->pPaM->GetPoint();
@@ -3084,7 +3109,7 @@ void WW8TabDesc::SetTabBorders(SwTableBo
     {
         WW8_TCell* pT = &pActBand->pTCs[nWwIdx];
         if (pIo->IsBorder(pT->rgbrc))
-            pIo->SetBorder(aFmtBox, pT->rgbrc);         
+            pIo->SetBorder(aFmtBox, pT->rgbrc);
     }
 
     if (pActBand->nOverrideSpacing[nWwIdx] & (1 << WW8TabBandDesc::wwTOP))
@@ -3299,7 +3324,7 @@ void WW8TabDesc::AdjustNewBand()
             int nOldBoxRightLineWidth = 0;
             if(pRightLine)
                 nOldBoxRightLineWidth = pRightLine->GetInWidth() + pRightLine->GetOutWidth() + pRightLine->GetDistance();
-            
+
             if(nOldBoxRightLineWidth>nCurrentRightLineWidth)
                 aCurrentBox.SetLine(aOldBox.GetLine(BOX_LINE_RIGHT), BOX_LINE_LEFT);
 
@@ -3392,11 +3417,17 @@ SwTableBox* WW8TabDesc::UpdateTableMerge
     SwTableBox* pResult = 0;
 
     // pruefen, ob die Box zu mergen ist
-    if( pActBand->bExist[ nCol ] &&
-        (rCell.bFirstMerged
-        || rCell.bMerged
-        || rCell.bVertMerge
-        || rCell.bVertRestart) )
+    // --> OD 2005-02-04 #118544# - If cell is the first one to be merged,
+    // a new merge group has to be provided.
+    // E.g., it could be that a cell is the first one to be merged, but no
+    // new merge group is provided, because the potential other cell to be merged
+    // doesn't exist - see method <WW8TabDesc::MergeCells>.
+    if ( pActBand->bExist[ nCol ] &&
+         ( ( rCell.bFirstMerged && pActGroup ) ||
+           rCell.bMerged ||
+           rCell.bVertMerge ||
+           rCell.bVertRestart ) )
+    // <--
     {
         // passende Merge-Gruppe ermitteln
         WW8SelBoxInfo* pTheMergeGroup = 0;
@@ -3468,6 +3499,38 @@ bool SwWW8ImplReader::StartTable(WW8_CP 
     if (pTableDesc)
         maTableStack.push(pTableDesc);
 
+    // --> OD 2005-01-27 #i33818# - determine absolute position object attributes,
+    // if possible. It's needed for nested tables.
+    WW8FlyPara* pTableWFlyPara( 0L );
+    WW8SwFlyPara* pTableSFlyPara( 0L );
+    if ( nInTable )
+    {
+        WW8_TablePos* pNestedTabPos( 0L );
+        WW8_TablePos aNestedTabPos;
+        WW8PLCFxSave1 aSave;
+        pPlcxMan->GetPap()->Save( aSave );
+        WW8PLCFx_Cp_FKP* pPap = pPlcxMan->GetPapPLCF();
+        WW8_CP nMyStartCp = nStartCp;
+        if ( SearchRowEnd( pPap, nMyStartCp, nInTable ) &&
+             ParseTabPos( &aNestedTabPos, pPap ) )
+        {
+            pNestedTabPos = &aNestedTabPos;
+        }
+        pPlcxMan->GetPap()->Restore( aSave );
+        if ( pNestedTabPos )
+        {
+            ApoTestResults aApo = TestApo( nInTable + 1, false, pNestedTabPos );
+            pTableWFlyPara = ConstructApo( aApo, pNestedTabPos );
+            if ( pTableWFlyPara )
+            {
+                pTableSFlyPara = new WW8SwFlyPara(*pPaM, *this, *pTableWFlyPara,
+                    maSectionManager.GetPageLeft(), maSectionManager.GetTextAreaWidth(),
+                    nIniFlyDx, nIniFlyDy);
+            }
+        }
+    }
+    // <--
+
     pTableDesc = new WW8TabDesc( this, nStartCp );
 
     if( pTableDesc->Ok() )
@@ -3479,28 +3542,50 @@ bool SwWW8ImplReader::StartTable(WW8_CP 
                 "how could we be in a local apo and have no apo");
         }
 
-        if (!maTableStack.empty() && !InEqualApo(nNewInTable))
+        if ( !maTableStack.empty() && !InEqualApo(nNewInTable) )
         {
             pTableDesc->pParentPos = new SwPosition(*pPaM->GetPoint());
             SfxItemSet aItemSet(rDoc.GetAttrPool(),
                 RES_FRMATR_BEGIN, RES_FRMATR_END-1);
-            SwFmtAnchor aAnchor(FLY_IN_CNTNT);
+            // --> OD 2005-01-26 #i33818# - anchor the Writer fly frame for
+            // the nested table at-character.
+            SwFmtAnchor aAnchor(FLY_AUTO_CNTNT);
             aAnchor.SetAnchor(pTableDesc->pParentPos);
             aItemSet.Put(aAnchor);
-            pTableDesc->pFlyFmt = rDoc.MakeFlySection(FLY_IN_CNTNT,
+            pTableDesc->pFlyFmt = rDoc.MakeFlySection(FLY_AUTO_CNTNT,
                 pTableDesc->pParentPos, &aItemSet);
-            ASSERT(pTableDesc->pFlyFmt->GetAnchor().GetAnchorId()
-                == FLY_IN_CNTNT, "Not the anchor type requested!");
+            ASSERT( pTableDesc->pFlyFmt->GetAnchor().GetAnchorId() == FLY_AUTO_CNTNT,
+                    "Not the anchor type requested!" );
+            // <--
             MoveInsideFly(pTableDesc->pFlyFmt);
         }
         pTableDesc->CreateSwTable();
         if (pTableDesc->pFlyFmt)
         {
-            SwFmtHoriOrient aHori = pTableDesc->pTable->GetFrmFmt()->
-                GetHoriOrient();
             pTableDesc->SetSizePosition(pTableDesc->pFlyFmt);
-            pTableDesc->pFlyFmt->SetAttr(SwFmtSurround(SURROUND_NONE));
-            pTableDesc->pFlyFmt->SetAttr(aHori);
+            // --> OD 2005-01-26 #i33818# - Use absolute position object
+            // attributes, if existing, and apply them to the created Writer fly
+            // frame.
+            if ( pTableWFlyPara && pTableSFlyPara )
+            {
+                WW8FlySet aFlySet( *this, pTableWFlyPara, pTableSFlyPara, false );
+                SwFmtAnchor aAnchor( FLY_AUTO_CNTNT );
+                aAnchor.SetAnchor( pTableDesc->pParentPos );
+                aFlySet.Put( aAnchor );
+                pTableDesc->pFlyFmt->SetAttr( aFlySet );
+            }
+            else
+            {
+                SwFmtHoriOrient aHori =
+                            pTableDesc->pTable->GetFrmFmt()->GetHoriOrient();
+                pTableDesc->pFlyFmt->SetAttr(aHori);
+                pTableDesc->pFlyFmt->SetAttr( SwFmtSurround( SURROUND_NONE ) );
+            }
+            // <--
+            // --> OD 2005-01-27 #i33818# - The nested table doesn't have to leave
+            // the table cell. Thus, the Writer fly frame has to follow the text flow.
+            pTableDesc->pFlyFmt->SetAttr( SwFmtFollowTextFlow( TRUE ) );
+            // <--
         }
         else
             pTableDesc->SetSizePosition(0);
@@ -3509,6 +3594,11 @@ bool SwWW8ImplReader::StartTable(WW8_CP 
     else
         PopTableDesc();
 
+    // --> OD 2005-01-28 #i33818#
+    delete pTableWFlyPara;
+    delete pTableSFlyPara;
+    // <--
+
     bool bSuccess = (0 != pTableDesc);
     if (bSuccess)
     {
@@ -3534,7 +3624,9 @@ void SwWW8ImplReader::Read_TabRowEnd( US
 void SwWW8ImplReader::PopTableDesc()
 {
     if (pTableDesc && pTableDesc->pFlyFmt)
+    {
         MoveOutsideFly(pTableDesc->pFlyFmt,*pTableDesc->pParentPos);
+    }
 
     delete pTableDesc;
     if (maTableStack.empty())
Index: sw/source/filter/xml/xmlfmt.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/xml/xmlfmt.cxx,v
retrieving revision 1.27
retrieving revision 1.27.116.1
diff -u -p -u -p -r1.27 -r1.27.116.1
--- sw/source/filter/xml/xmlfmt.cxx	26 Nov 2004 13:29:59 -0000	1.27
+++ sw/source/filter/xml/xmlfmt.cxx	1 Feb 2005 07:45:00 -0000	1.27.116.1
@@ -187,19 +187,19 @@ class SwXMLConditionParser_Impl
 
 	sal_uInt32 nCondition;
 	sal_uInt32 nSubCondition;
-	
+
 	sal_Int32 nPos;
 	sal_Int32 nLength;
-	
+
 	inline sal_Bool SkipWS();
 	inline sal_Bool MatchChar( sal_Unicode c );
 	inline sal_Bool MatchName( OUString& rName );
 	inline sal_Bool MatchNumber( sal_uInt32& rNumber );
 
-public:	
-	
+public:
+
 	SwXMLConditionParser_Impl( const OUString& rInp );
-	
+
 	sal_Bool IsValid() const { return 0 != nCondition; }
 
 	sal_uInt32 GetCondition() const { return nCondition; }
@@ -227,7 +227,7 @@ inline sal_Bool SwXMLConditionParser_Imp
 inline sal_Bool SwXMLConditionParser_Impl::MatchName( OUString& rName )
 {
 	OUStringBuffer sBuffer( nLength );
-	while( nPos < nLength && 
+	while( nPos < nLength &&
 		   ( ('a' <= sInput[nPos] && sInput[nPos] <= 'z') ||
 		 	 '-' == sInput[nPos] ) )
 	{
@@ -246,7 +246,7 @@ inline sal_Bool SwXMLConditionParser_Imp
 		sBuffer.append( sInput[nPos] );
 		nPos++;
 	}
-		
+
 	OUString sNum( sBuffer.makeStringAndClear() );
 	if( sNum.getLength() )
 		rNumber = sNum.toInt32();
@@ -285,13 +285,13 @@ SwXMLConditionParser_Impl::SwXMLConditio
             nCondition = PARA_IN_HEADER;
         else if( IsXMLToken( sFunc, XML_LIST_LEVEL) &&
 				nSub >=1 && nSub <= MAXLEVEL )
-		{ 
+		{
             nCondition = PARA_IN_LIST;
             nSubCondition = nSub-1;
         }
-        else if( IsXMLToken( sFunc, XML_OUTLINE_LEVEL) && 
+        else if( IsXMLToken( sFunc, XML_OUTLINE_LEVEL) &&
                  nSub >=1 && nSub <= MAXLEVEL )
-		{ 
+		{
             nCondition = PARA_IN_OUTLINE;
             nSubCondition = nSub-1;
         }
@@ -320,9 +320,9 @@ class SwXMLConditionContext_Impl : publi
 {
 	sal_uInt32 nCondition;
 	sal_uInt32 nSubCondition;
-	
+
 	OUString sApplyStyle;
-	
+
 	void ParseCondition( const OUString& rCond );
 
 public:
@@ -334,7 +334,7 @@ public:
 	virtual ~SwXMLConditionContext_Impl();
 
 	TYPEINFO();
-	
+
 	sal_Bool IsValid() const { return 0 != nCondition; }
 
 	sal_uInt32 GetCondition() const { return nCondition; }
@@ -479,7 +479,7 @@ SvXMLImportContext *SwXMLTextStyleContex
 
 	if( XML_NAMESPACE_STYLE == nPrefix && IsXMLToken( rLocalName, XML_MAP ) )
 	{
-		SwXMLConditionContext_Impl *pCond = 
+		SwXMLConditionContext_Impl *pCond =
 			new SwXMLConditionContext_Impl( GetImport(), nPrefix,
 											rLocalName, xAttrList );
 		if( pCond->IsValid() )
@@ -491,7 +491,7 @@ SvXMLImportContext *SwXMLTextStyleContex
 		}
 		pContext = pCond;
 	}
-		
+
 	if( !pContext )
 		pContext = XMLTextStyleContext::CreateChildContext( nPrefix, rLocalName,
 														  xAttrList );
@@ -534,7 +534,7 @@ void SwXMLTextStyleContext_Impl::Finish(
 	{
 		const SwXMLConditionContext_Impl *pCond = (*pConditions)[i];
 		OUString aDisplayName(
-			GetImport().GetStyleDisplayName( XML_STYLE_FAMILY_TEXT_PARAGRAPH, 
+			GetImport().GetStyleDisplayName( XML_STYLE_FAMILY_TEXT_PARAGRAPH,
 				pCond->GetApplyStyle() ) );
 		SwStyleNameMapper::FillUIName( aDisplayName,
 									  aString,
@@ -726,7 +726,7 @@ SvXMLImportContext *SwXMLItemSetStyleCon
 			pContext = CreateItemSetContext( nPrefix, rLocalName, xAttrList );
 		}
 	}
-		
+
 	if( !pContext )
 		pContext = SvXMLStyleContext::CreateChildContext( nPrefix, rLocalName,
 														  xAttrList );
@@ -749,12 +749,15 @@ void SwXMLItemSetStyleContext_Impl::Conn
 	SwDoc *pDoc = pTxtCrsr->GetDoc();
 
 	String sName;
-	SwStyleNameMapper::FillUIName( GetMasterPageName(),
+    // --> OD 2005-02-01 #i40788# - first determine the display name of the
+    // page style, then map this name to the corresponding user interface name.
+    sName = GetImport().GetStyleDisplayName( XML_STYLE_FAMILY_MASTER_PAGE,
+                                             GetMasterPageName() );
+    SwStyleNameMapper::FillUIName( sName,
 								   sName,
 								   GET_POOLID_PAGEDESC,
 								   sal_True);
-	sName = GetImport().GetStyleDisplayName( XML_STYLE_FAMILY_MASTER_PAGE,
-											 sName );
+    // <--
 	SwPageDesc *pPageDesc = pDoc->FindPageDescByName( sName );
 	if( !pPageDesc )
 	{
@@ -779,7 +782,7 @@ void SwXMLItemSetStyleContext_Impl::Conn
 	if( SFX_ITEM_SET == pItemSet->GetItemState( RES_PAGEDESC, sal_False,
 												&pItem ) )
 	{
-	 	if( ((SwFmtPageDesc *)pItem)->GetPageDesc() != pPageDesc )	
+	 	if( ((SwFmtPageDesc *)pItem)->GetPageDesc() != pPageDesc )
 			pFmtPageDesc = new SwFmtPageDesc( *(SwFmtPageDesc *)pItem );
 	}
 	else
@@ -801,7 +804,7 @@ sal_Bool SwXMLItemSetStyleContext_Impl::
 	if (! bDataStyleIsResolved)
 	{
 		// get the format key
-		sal_Int32 nFormat = 
+		sal_Int32 nFormat =
 			GetImport().GetTextImport()->GetDataStyleKey(sDataStyleName);
 
 		// if the key is valid, insert Item into ItemSet
@@ -910,7 +913,7 @@ SvXMLStyleContext *SwXMLStylesContext_Im
 		break;
 	case XML_STYLE_FAMILY_SD_GRAPHICS_ID:
 		// As long as there are no element items, we can use the text
-		// style class. 
+		// style class.
 		pStyle = new XMLTextShapeStyleContext( GetImport(), nPrefix,
 							rLocalName, xAttrList, *this, nFamily );
 		break;
@@ -935,7 +938,7 @@ SvXMLStyleContext *SwXMLStylesContext_Im
 	{
 	case XML_STYLE_FAMILY_TEXT_PARAGRAPH:
 		pStyle = new XMLTextStyleContext( GetImport(), nPrefix, rLocalName,
-										  xAttrList, *this, nFamily, 
+										  xAttrList, *this, nFamily,
 										  sal_True );
 		break;
 	case XML_STYLE_FAMILY_SD_GRAPHICS_ID:
@@ -1106,7 +1109,7 @@ void SwXMLMasterStylesContext_Impl::EndE
 // ---------------------------------------------------------------------
 
 SvXMLImportContext *SwXMLImport::CreateStylesContext(
-		const OUString& rLocalName,   
+		const OUString& rLocalName,
 		const Reference< xml::sax::XAttributeList > & xAttrList,
 		sal_Bool bAuto )
 {
@@ -1122,7 +1125,7 @@ SvXMLImportContext *SwXMLImport::CreateS
 }
 
 SvXMLImportContext *SwXMLImport::CreateMasterStylesContext(
-		const OUString& rLocalName,   
+		const OUString& rLocalName,
 		const Reference< xml::sax::XAttributeList > & xAttrList )
 {
 	SvXMLStylesContext *pContext =
Index: sw/source/ui/app/docsh2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/app/docsh2.cxx,v
retrieving revision 1.73
retrieving revision 1.73.38.1
diff -u -p -u -p -r1.73 -r1.73.38.1
--- sw/source/ui/app/docsh2.cxx	11 Jan 2005 12:38:37 -0000	1.73
+++ sw/source/ui/app/docsh2.cxx	1 Feb 2005 15:15:38 -0000	1.73.38.1
@@ -422,15 +422,24 @@ void SwDocShell::Notify( SfxBroadcaster&
 			break;
         // --> OD 2004-12-03 #i38126# - own action for event LOADFINISHED
         // in order to avoid a modified document.
+        // --> OD 2005-02-01 #i41679# - Also for the instance of <SwDoc>
+        // it has to be assured, that it's not modified.
         // Perform the same as for action id 1, but disable <SetModified>.
         case 3:
             {
                 const bool bResetModified = IsEnableSetModified();
                 if ( bResetModified )
                     EnableSetModified( FALSE );
+                // --> OD 2005-02-01 #i41679#
+                const bool bIsDocModified = pDoc->IsModified();
+                // <--
 
                 pDoc->DocInfoChgd( GetDocInfo() );
 
+                // --> OD 2005-02-01 #i41679#
+                if ( !bIsDocModified )
+                    pDoc->ResetModified();
+                // <--
                 if ( bResetModified )
                     EnableSetModified( TRUE );
             }
Index: sw/source/ui/docvw/edtwin.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/docvw/edtwin.cxx,v
retrieving revision 1.107
retrieving revision 1.106.64.2
diff -u -p -u -p -r1.107 -r1.106.64.2
--- sw/source/ui/docvw/edtwin.cxx	27 Jan 2005 11:13:03 -0000	1.107
+++ sw/source/ui/docvw/edtwin.cxx	4 Feb 2005 11:48:30 -0000	1.106.64.2
@@ -1066,6 +1066,12 @@ void SwEditWin::ChangeFly( BYTE nDir, BO
  ---------------------------------------------------------------------------*/
 void SwEditWin::ChangeDrawing( BYTE nDir )
 {
+    // --> OD 2005-01-31 #i40845# - start undo action in order to get only one
+    // undo action for this change.
+    SwWrtShell &rSh = rView.GetWrtShell();
+    rSh.StartUndo();
+    // <--
+
     long nX = 0;
     long nY = 0;
     sal_Bool bOnePixel = sal_False;
@@ -1182,6 +1188,10 @@ void SwEditWin::ChangeDrawing( BYTE nDir
         }
         rSh.EndAllAction();
     }
+
+    // --> OD 2005-01-31 #i40845# - end undo action
+    rSh.EndUndo();
+    // <--
 }
 
 /*--------------------------------------------------------------------
Index: sw/source/ui/wrtsh/delete.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/wrtsh/delete.cxx,v
retrieving revision 1.10
retrieving revision 1.10.196.1
diff -u -p -u -p -r1.10 -r1.10.196.1
--- sw/source/ui/wrtsh/delete.cxx	22 Oct 2004 08:15:05 -0000	1.10
+++ sw/source/ui/wrtsh/delete.cxx	28 Jan 2005 13:47:12 -0000	1.10.196.1
@@ -114,7 +114,7 @@ BOOL SwWrtShell::TryRemoveIndent()
         aItem.SetLeft(aItem.GetLeft() + aOldFirstLineOfst);
 
         bResult = TRUE;
-    } 
+    }
     else if (aItem.GetLeft() != 0)
     {
         aItem.SetLeft(0);
@@ -189,7 +189,7 @@ long SwWrtShell::DelLeft()
         Point aTmpPt = GetObjRect().TopLeft();
 
 		DelSelectedObj();
-        
+
         /*  #108205# Set cursor to remembered position. */
         SetCrsr(&aTmpPt);
 
@@ -288,21 +288,29 @@ long SwWrtShell::DelRight(BOOL bDelFrm)
 		}
 
 		pWasInTblNd = IsCrsrInTbl();
-        
+
 		if( SEL_TXT & nSelection && SwCrsrShell::IsSttPara() &&
-			SwCrsrShell::IsEndPara() &&
-			SwCrsrShell::Right(1,CRSR_SKIP_CHARS) )
-		{
-        	const SwTableNode * pCurrTblNd = IsCrsrInTbl();
-			const BOOL bDelFull = pCurrTblNd && pCurrTblNd != pWasInTblNd;
-			SwCrsrShell::Left(1,CRSR_SKIP_CHARS);
+			SwCrsrShell::IsEndPara() )
+        {
+            // save cursor
+            SwCrsrShell::Push();
 
-			if( bDelFull )
-			{
-				DelFullPara();
-				UpdateAttr();
-				break;
-			}
+            bool bDelFull = false;
+            if ( SwCrsrShell::Right(1,CRSR_SKIP_CHARS) )
+		    {
+            	const SwTableNode * pCurrTblNd = IsCrsrInTbl();
+			    bDelFull = pCurrTblNd && pCurrTblNd != pWasInTblNd;
+            }
+
+            // restore cursor
+            SwCrsrShell::Pop( FALSE );
+
+    	    if( bDelFull )
+		    {
+    			DelFullPara();
+			    UpdateAttr();
+			    break;
+		    }
 		}
 
         {
@@ -311,25 +319,38 @@ long SwWrtShell::DelRight(BOOL bDelFrm)
             pSNdOld = GetSwCrsr()->GetNode()->
                 FindTableBoxStartNode();
 
-            if (SwCrsrShell::IsEndPara() &&
-                SwCrsrShell::Right(1, CRSR_SKIP_CHARS))
+            if ( SwCrsrShell::IsEndPara() )
             {
-                if (IsCrsrInTbl() || (pWasInTblNd != IsCrsrInTbl()))
+                // --> FME 2005-01-28 #i41424# Introduced a couple of
+                // Push()-Pop() pairs here. The reason for this is thet a
+                // Right()-Left() combination does not make sure, that
+                // the cursor will be in its initial state, because there
+                // may be a numbering in front of the next paragraph.
+                SwCrsrShell::Push();
+                // <--
+
+                if ( SwCrsrShell::Right(1, CRSR_SKIP_CHARS) )
                 {
-                    /* #108049# Save the startnode of the current
-                        cell. May be different to pSNdOld as we have
-                        moved. */
-                    const SwStartNode * pSNdNew = GetSwCrsr()
-                        ->GetNode()->FindTableBoxStartNode();
-                    
-                    /* #108049# Only move instead of deleting if we
-                        have moved to a different cell */
-                    if (pSNdOld != pSNdNew)
-                        break;
+                    if (IsCrsrInTbl() || (pWasInTblNd != IsCrsrInTbl()))
+                    {
+                        /* #108049# Save the startnode of the current
+                            cell. May be different to pSNdOld as we have
+                            moved. */
+                        const SwStartNode * pSNdNew = GetSwCrsr()
+                            ->GetNode()->FindTableBoxStartNode();
+
+                        /* #108049# Only move instead of deleting if we
+                            have moved to a different cell */
+                        if (pSNdOld != pSNdNew)
+                        {
+                            SwCrsrShell::Pop( TRUE );
+                            break;
+                        }
+                    }
                 }
 
-                SwCrsrShell::Left(1, CRSR_SKIP_CHARS);
-
+                // restore cursor
+                SwCrsrShell::Pop( FALSE );
             }
         }
 
@@ -350,7 +371,7 @@ long SwWrtShell::DelRight(BOOL bDelFrm)
             Point aTmpPt = GetObjRect().TopLeft();
 
             DelSelectedObj();
-            
+
             /*  #108205# Set cursor to remembered position. */
             SetCrsr(&aTmpPt);
 
